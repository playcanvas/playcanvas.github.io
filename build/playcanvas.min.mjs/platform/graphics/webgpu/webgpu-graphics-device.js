import"../../../core/tracing.js";import{Vec2 as e}from"../../../core/math/vec2.js";import{DEVICETYPE_WEBGPU as t,PIXELFORMAT_RGBA32F as r,PIXELFORMAT_RGBA8 as s,PIXELFORMAT_BGRA8 as i,CULLFACE_BACK as n}from"../constants.js";import{GraphicsDevice as a}from"../graphics-device.js";import{RenderTarget as h}from"../render-target.js";import{WebgpuBindGroup as o}from"./webgpu-bind-group.js";import{WebgpuBindGroupFormat as u}from"./webgpu-bind-group-format.js";import{WebgpuIndexBuffer as p}from"./webgpu-index-buffer.js";import{WebgpuRenderPipeline as d}from"./webgpu-render-pipeline.js";import{WebgpuRenderTarget as m}from"./webgpu-render-target.js";import{WebgpuShader as f}from"./webgpu-shader.js";import{WebgpuTexture as l}from"./webgpu-texture.js";import{WebgpuUniformBuffer as c}from"./webgpu-uniform-buffer.js";import{WebgpuVertexBuffer as g}from"./webgpu-vertex-buffer.js";import{WebgpuClearRenderer as x}from"./webgpu-clear-renderer.js";class w extends a{constructor(e,r={}){super(e),this.frameBuffer=void 0,this.renderPipeline=new d(this),this.clearRenderer=void 0,this.pipeline=void 0,this.bindGroupFormats=[],this.commandEncoder=void 0,this.isWebGPU=!0,this._deviceType=t,this.samples=r.antialias?4:1}destroy(){super.destroy()}initDeviceCaps(){const e=this.gpuAdapter.limits;this.precision="highp",this.maxPrecision="highp",this.maxSamples=4,this.maxTextures=16,this.maxTextureSize=e.maxTextureDimension2D,this.maxCubeMapSize=e.maxTextureDimension2D,this.maxVolumeSize=e.maxTextureDimension3D,this.maxPixelRatio=1,this.supportsInstancing=!0,this.supportsUniformBuffers=!0,this.supportsBoneTextures=!0,this.supportsMorphTargetTexturesCore=!0,this.supportsAreaLights=!0,this.supportsDepthShadow=!0,this.extUintElement=!0,this.extTextureFloat=!0,this.textureFloatRenderable=!0,this.extTextureHalfFloat=!0,this.textureHalfFloatRenderable=!0,this.textureHalfFloatUpdatable=!0,this.boneLimit=1024,this.supportsImageBitmap=!0,this.extStandardDerivatives=!0,this.extBlendMinmax=!0,this.areaLightLutFormat=this.floatFilterable?r:s,this.supportsTextureFetch=!0}async initWebGpu(e,t){if(!window.navigator.gpu)throw new Error("Unable to retrieve GPU. Ensure you are using a browser that supports WebGPU rendering.");const r=e=>new Promise((function(t,r){const s=document.createElement("script");s.src=e,s.async=!1,s.onload=function(){t(e)},s.onerror=function(){r(new Error(`Failed to download script ${e}`))},document.body.appendChild(s)}));await r(e),await r(t),this.glslang=await glslang();const n=t.replace(".js",".wasm");this.twgsl=await twgsl(n),this.gpuAdapter=await window.navigator.gpu.requestAdapter();const a=[];this.floatFilterable=(e=>!!this.gpuAdapter.features.has(e)&&(a.push(e),!0))("float32-filterable"),this.wgpu=await this.gpuAdapter.requestDevice({requiredFeatures:a,requiredLimits:{}}),this.initDeviceCaps(),this.setResolution(window.innerWidth,window.innerHeight),this.gpuContext=this.canvas.getContext("webgpu");const h=navigator.gpu.getPreferredCanvasFormat();return this.framebufferFormat="rgba8unorm"===h?s:i,this.canvasConfig={device:this.wgpu,colorSpace:"srgb",alphaMode:"opaque",format:h,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST,viewFormats:[]},this.gpuContext.configure(this.canvasConfig),this.createFramebuffer(),this.clearRenderer=new x(this),this.postInit(),this}createFramebuffer(){this.frameBufferDimensions=new e,this.frameBuffer=new h({name:"WebgpuFramebuffer",graphicsDevice:this,depth:!0,samples:this.samples})}resizeCanvas(e,t){this._width=e,this._height=t,this.canvas.width===e&&this.canvas.height===t||(this.canvas.width=e,this.canvas.height=t,this.fire(a.EVENT_RESIZE,e,t))}frameStart(){super.frameStart();const e=this.gpuContext.getCurrentTexture();this.frameBufferDimensions.x===e.width&&this.frameBufferDimensions.y===e.height||(this.frameBufferDimensions.set(e.width,e.height),this.frameBuffer.destroy(),this.frameBuffer=null,this.createFramebuffer());const t=this.frameBuffer,r=t.impl;r.colorFormat=e.format,this.initRenderTarget(t),r.assignColorTexture(e)}createUniformBufferImpl(e){return new c(e)}createVertexBufferImpl(e,t){return new g(e,t)}createIndexBufferImpl(e){return new p(e)}createShaderImpl(e){return new f(e)}createTextureImpl(e){return new l(e)}createRenderTargetImpl(e){return new m(e)}createBindGroupFormatImpl(e){return new u(e)}createBindGroupImpl(e){return new o}setBindGroup(e,t){this.passEncoder&&(this.passEncoder.setBindGroup(e,t.impl.bindGroup),this.bindGroupFormats[e]=t.format.impl)}submitVertexBuffer(e,t){const r=e.format,s=r.elements.length,i=e.impl.buffer;for(let e=0;e<s;e++){const s=r.elements[e];this.passEncoder.setVertexBuffer(t+e,i,s.offset)}return s}draw(e,t=1,r){if(this.shader.ready&&!this.shader.failed){const r=this.passEncoder,s=this.vertexBuffers[0],i=this.vertexBuffers[1];if(this.vertexBuffers.length=0,s){const e=this.submitVertexBuffer(s,0);i&&this.submitVertexBuffer(i,e)}const n=this.renderPipeline.get(e,null==s?void 0:s.format,null==i?void 0:i.format,this.shader,this.renderTarget,this.bindGroupFormats,this.blendState,this.depthState);this.pipeline!==n&&(this.pipeline=n,r.setPipeline(n));const a=this.indexBuffer;a?(this.indexBuffer=null,r.setIndexBuffer(a.impl.buffer,a.impl.format),r.drawIndexed(e.count,t,0,0,0)):r.draw(e.count,t,0,0)}}setShader(e){return this.shader=e,!0}setBlendState(e){this.blendState.copy(e)}setDepthState(e){this.depthState.copy(e)}setBlendColor(e,t,r,s){}setDepthFunc(e){}setDepthTest(e){}setCullMode(e){}getCullMode(){return n}setAlphaToCoverage(e){}setDepthWrite(e){}initializeContextCaches(){super.initializeContextCaches()}startPass(e){const t=e.renderTarget||this.frameBuffer;this.renderTarget=t;const r=t.impl;t!==this.frameBuffer&&this.initRenderTarget(t),r.setupForRenderPass(e),this.commandEncoder=this.wgpu.createCommandEncoder(),this.pipeline=null,this.passEncoder=this.commandEncoder.beginRenderPass(r.renderPassDescriptor);const{width:s,height:i}=t;this.setViewport(0,0,s,i),this.setScissor(0,0,s,i),this.insideRenderPass=!0}endPass(e){this.passEncoder.end(),this.passEncoder=null,this.wgpu.queue.submit([this.commandEncoder.finish()]),this.commandEncoder=null,this.bindGroupFormats.length=0,this.insideRenderPass=!1}clear(e){e.flags&&this.clearRenderer.clear(this,this.renderTarget,e,this.defaultClearOptions)}get width(){return this._width}get height(){return this._height}setDepthBias(e){}setDepthBiasValues(e,t){}setStencilTest(e){}setStencilFunc(e,t,r){}setStencilOperation(e,t,r,s){}setViewport(e,t,r,s){this.passEncoder&&(this.renderTarget.flipY||(t=this.renderTarget.height-t-s),this.vx=e,this.vy=t,this.vw=r,this.vh=s,this.passEncoder.setViewport(e,t,r,s,0,1))}setScissor(e,t,r,s){this.passEncoder&&(this.renderTarget.flipY||(t=this.renderTarget.height-t-s),this.sx=e,this.sy=t,this.sw=r,this.sh=s,this.passEncoder.setScissorRect(e,t,r,s))}copyRenderTarget(e,t,r,s){var i;const n={width:e?e.width:t.width,height:e?e.height:t.height,depthOrArrayLayers:1},a=null!=(i=this.commandEncoder)?i:this.wgpu.createCommandEncoder();if(r){const r={texture:e?e.colorBuffer.impl.gpuTexture:this.renderTarget.impl.assignedColorTexture,mipLevel:0},s={texture:t?t.colorBuffer.impl.gpuTexture:this.renderTarget.impl.assignedColorTexture,mipLevel:0};a.copyTextureToTexture(r,s,n)}if(s){const r={texture:(e||this.renderTarget).impl.depthTexture,mipLevel:0},s={texture:t?t.depthBuffer.impl.gpuTexture:this.renderTarget.impl.depthTexture,mipLevel:0};a.copyTextureToTexture(r,s,n)}return this.commandEncoder||this.wgpu.queue.submit([a.finish()]),!0}}export{w as WebgpuGraphicsDevice};
