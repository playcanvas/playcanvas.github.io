import{AnimTargetValue as t}from"./anim-target-value.js";import{AnimBlend as e}from"./anim-blend.js";class s{constructor(t){this._binder=t,this._clips=[],this._inputs=[],this._outputs=[],this._targets={}}get clips(){return this._clips}addClip(e){const s=this._targets,n=this._binder,r=e.track.curves,i=e.snapshot,a=[],o=[];for(let e=0;e<r.length;++e){const l=r[e].paths;for(let r=0;r<l.length;++r){const h=l[r],p=n.resolve(h);let u=s[p&&p.targetPath||null];if(!u&&p){u={target:p,value:[],curves:0,blendCounter:0};for(let t=0;t<u.target.components;++t)u.value.push(0);if(s[p.targetPath]=u,n.animComponent){if(!n.animComponent.targets[p.targetPath]){let e;e="localRotation"===p.targetPath.substring(p.targetPath.length-13)?t.TYPE_QUAT:t.TYPE_VEC3,n.animComponent.targets[p.targetPath]=new t(n.animComponent,e)}n.animComponent.targets[p.targetPath].layerCounter++,n.animComponent.targets[p.targetPath].setMask(n.layerIndex,1)}}u&&(u.curves++,a.push(i._results[e]),o.push(u))}}this._clips.push(e),this._inputs.push(a),this._outputs.push(o)}removeClip(t){const e=this._targets,s=this._binder,n=this._clips,r=n[t].track.curves;for(let t=0;t<r.length;++t){const n=r[t].paths;for(let t=0;t<n.length;++t){const r=n[t],i=this._binder.resolve(r);i&&(i.curves--,0===i.curves&&(s.unresolve(r),delete e[i.targetPath],s.animComponent&&s.animComponent.targets[i.targetPath].layerCounter--))}}n.splice(t,1),this._inputs.splice(t,1),this._outputs.splice(t,1)}removeClips(){for(;this._clips.length>0;)this.removeClip(0)}updateClipTrack(t,e){this._clips.forEach((s=>{s.name.includes(t)&&(s.track=e)})),this.rebind()}findClip(t){const e=this._clips;for(let s=0;s<e.length;++s){const n=e[s];if(n.name===t)return n}return null}rebind(){this._binder.rebind(),this._targets={};const t=[...this.clips];this.removeClips(),t.forEach((t=>{this.addClip(t)}))}assignMask(t){return this._binder.assignMask(t)}update(t,s=!0){const n=this._clips,r=n.map((function(t,e){return e}));e.stableSort(r,(function(t,e){return n[t].blendOrder<n[e].blendOrder}));for(let i=0;i<r.length;++i){const a=r[i],o=n[a],l=this._inputs[a],h=this._outputs[a],p=o.blendWeight;if(p>0&&o._update(t),!s)break;let u,c,g;if(p>=1)for(let t=0;t<l.length;++t)u=l[t],c=h[t],g=c.value,e.set(g,u,c.target.type),c.blendCounter++;else if(p>0)for(let t=0;t<l.length;++t)u=l[t],c=h[t],g=c.value,0===c.blendCounter?e.set(g,u,c.target.type):e.blend(g,u,p,c.target.type),c.blendCounter++}const i=this._targets,a=this._binder;for(const t in i)if(i.hasOwnProperty(t)){const e=i[t];if(a.animComponent&&e.target.isTransform){const s=a.animComponent.targets[t];s.counter===s.layerCounter&&(s.counter=0),s.path||(s.path=t,s.baseValue=e.target.get(),s.setter=e.target.set),s.updateValue(a.layerIndex,e.value),s.counter++}else e.target.set(e.value);e.blendCounter=0}this._binder.update(t)}}export{s as AnimEvaluator};
