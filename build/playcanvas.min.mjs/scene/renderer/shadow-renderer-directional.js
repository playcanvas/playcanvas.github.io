import"../../core/tracing.js";import{math as e}from"../../core/math/math.js";import{Vec3 as s}from"../../core/math/vec3.js";import{Mat4 as a}from"../../core/math/mat4.js";import{BoundingBox as t}from"../../core/shape/bounding-box.js";import{SHADOWUPDATE_NONE as r,SHADOWUPDATE_THISFRAME as o}from"../constants.js";import{RenderPass as n}from"../../platform/graphics/render-pass.js";import{ShadowMap as d}from"./shadow-map.js";const i=new t,c=new s,h=new a,l=[new s,new s,new s,new s,new s,new s,new s,new s],m={min:0,max:0};function w(e,s,a){l[0].x=l[1].x=l[2].x=l[3].x=s.x,l[1].y=l[3].y=l[7].y=l[5].y=s.y,l[2].z=l[3].z=l[6].z=l[7].z=s.z,l[4].x=l[5].x=l[6].x=l[7].x=a.x,l[0].y=l[2].y=l[4].y=l[6].y=a.y,l[0].z=l[1].z=l[4].z=l[5].z=a.z;let t=9999999999,r=-9999999999;for(let s=0;s<8;++s){e.transformPoint(l[s],l[s]);const a=l[s].z;a<t&&(t=a),a>r&&(r=a)}return m.min=t,m.max=r,m}class p{constructor(e,s){this.renderer=void 0,this.shadowRenderer=void 0,this.device=void 0,this.renderer=e,this.shadowRenderer=s,this.device=e.device}cull(e,s,a){e.visibleThisFrame=!0,e._shadowMap||(e._shadowMap=d.create(this.device,e));const t=a._nearClip;this.generateSplitDistances(e,t,Math.min(a._farClip,e.shadowDistance));const o=e.shadowUpdateOverrides;for(let n=0;n<e.numCascades&&(null==o?void 0:o[n])!==r;n++){const r=e.getRenderData(a,n),o=r.shadowCamera;o.renderTarget=e._shadowMap.renderTargets[0],r.shadowViewport.copy(e.cascades[n]),r.shadowScissor.copy(e.cascades[n]);const d=o._node,l=e._node;d.setPosition(l.getPosition()),d.setRotation(l.getRotation()),d.rotateLocal(-90,0,0);const m=0===n?t:e._shadowCascadeDistances[n-1],p=e._shadowCascadeDistances[n],u=a.getFrustumCorners(m,p);c.set(0,0,0);const f=a.node.getWorldTransform();for(let e=0;e<8;e++)f.transformPoint(u[e],u[e]),c.add(u[e]);c.mulScalar(1/8);let g=0;for(let e=0;e<8;e++){const s=u[e].sub(c).length();s>g&&(g=s)}const v=d.right,C=d.up,x=d.forward,R=.25*e._shadowResolution/g,y=Math.ceil(c.dot(C)*R)/R,b=Math.ceil(c.dot(v)*R)/R,_=C.mulScalar(y),z=v.mulScalar(b),S=c.dot(x),D=x.mulScalar(S);c.add2(_,z).add(D),d.setPosition(c),d.translateLocal(0,0,1e6),o.nearClip=.01,o.farClip=2e6,o.orthoHeight=g,this.renderer.updateCameraFrustum(o),this.shadowRenderer.cullShadowCasters(s,r.visibleCasters,o);let P=!0;const j=r.visibleCasters;for(let e=0;e<j.length;e++){const s=j[e];P?(P=!1,i.copy(s.aabb)):i.add(s.aabb)}h.copy(d.getWorldTransform()).invert();const M=w(h,i.getMin(),i.getMax());d.translateLocal(0,0,M.max+.1),o.farClip=M.max-M.min+.2}}generateSplitDistances(s,a,t){s._shadowCascadeDistances.fill(t);for(let r=1;r<s.numCascades;r++){const o=r/s.numCascades,n=a+(t-a)*o,d=a*(t/a)**o,i=e.lerp(n,d,s.cascadeDistribution);s._shadowCascadeDistances[r-1]=i}}addLightRenderPasses(e,s,a){const t=s.numShadowFaces,d=s.shadowUpdateOverrides;let i,c=!0;for(let e=0;e<t;e++)(null==d?void 0:d[e])===r&&(c=!1),i=this.shadowRenderer.prepareFace(s,a,e);const h=new n(this.device,(()=>{for(let e=0;e<t;e++)(null==d?void 0:d[e])!==r&&this.shadowRenderer.renderFace(s,a,e,!c),(null==d?void 0:d[e])===o&&(d[e]=r)}));h.after=()=>{this.shadowRenderer.renderVms(s,a)},this.shadowRenderer.setupRenderPass(h,i,c),e.addRenderPass(h)}buildFrameGraph(e,s,a){const t=s.directionalLights;for(let s=0;s<t.length;s++){const r=t[s];this.shadowRenderer.needsShadowRendering(r)&&this.addLightRenderPasses(e,r,a.camera)}}}export{p as ShadowRendererDirectional};
