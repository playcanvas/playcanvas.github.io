import { Debug } from './debug.js';

// id for debug tracing
const TRACEID = 'Preprocessor';

// accepted keywords
const KEYWORD = /[ \t]*#(ifn?def|if|endif|else|elif|define|undef|extension)/g;

// #define EXPRESSION
const DEFINE = /define[ \t]+([^\n]+)\r?(?:\n|$)/g;

// #extension IDENTIFIER : enabled
const EXTENSION = /extension[ \t]+([\w-]+)[ \t]*:[ \t]*(enable|require)/g;

// #undef EXPRESSION
const UNDEF = /undef[ \t]+([^\n]+)\r?(?:\n|$)/g;

// #ifdef/#ifndef SOMEDEFINE, #if EXPRESSION
const IF = /(ifdef|ifndef|if)[ \t]*([^\r\n]+)\r?\n/g;

// #endif/#else or #elif EXPRESSION
const ENDIF = /(endif|else|elif)([ \t]+[^\r\n]+)?\r?(?:\n|$)/g;

// identifier
const IDENTIFIER = /([\w-]+)/;

// [!]defined(EXPRESSION)
const DEFINED = /(!|\s)?defined\(([\w-]+)\)/;

// currently unsupported characters in the expression: | & < > = + -
const INVALID = /[><=|&+-]/g;

/**
 * Pure static class implementing subset of C-style preprocessor.
 * inspired by: https://github.com/dcodeIO/Preprocessor.js
 *
 * @ignore
 */
class Preprocessor {
  /**
   * Run c-like preprocessor on the source code, and resolves the code based on the defines and ifdefs
   *
   * @param {string} source - The source code to work on.
   * @returns {string|null} Returns preprocessed source code, or null in case of error.
   */
  static run(source) {
    // strips comments, handles // and many cases of /*
    source = source.replace(/\/\*[\s\S]*?\*\/|([^\\:]|^)\/\/.*$/gm, '$1');

    // right trim each line
    source = source.split(/\r?\n/).map(line => line.trimEnd()).join('\n');

    // preprocess defines / ifdefs ..
    source = this._preprocess(source);
    if (source !== null) {
      // convert lines with only white space into empty string
      source = source.split(/\r?\n/).map(line => line.trim() === '' ? '' : line).join('\n');

      // remove more than 1 consecutive empty lines
      source = source.replace(/(\n\n){3,}/gm, '\n\n');
    }
    return source;
  }
  static _preprocess(source) {
    const originalSource = source;

    // stack, storing info about ifdef blocks
    const stack = [];

    // true if the function encounter a problem
    let error = false;

    // active defines, maps define name to its value
    /** @type {Map<string, string>} */
    const defines = new Map();
    let match;
    while ((match = KEYWORD.exec(source)) !== null) {
      const keyword = match[1];
      switch (keyword) {
        case 'define':
          {
            // read the rest of the define line
            DEFINE.lastIndex = match.index;
            const define = DEFINE.exec(source);
            Debug.assert(define, `Invalid [${keyword}]: ${source.substring(match.index, match.index + 100)}...`);
            error || (error = define === null);
            const expression = define[1];

            // split it to identifier name and a value
            IDENTIFIER.lastIndex = define.index;
            const identifierValue = IDENTIFIER.exec(expression);
            const identifier = identifierValue[1];
            let value = expression.substring(identifier.length).trim();
            if (value === "") value = "true";

            // are we inside if-blocks that are accepted
            const keep = Preprocessor._keep(stack);
            if (keep) {
              defines.set(identifier, value);
            }
            Debug.trace(TRACEID, `${keyword}: [${identifier}] ${value} ${keep ? "" : "IGNORED"}`);

            // continue on the next line
            KEYWORD.lastIndex = define.index + define[0].length;
            break;
          }
        case 'undef':
          {
            // read the rest of the define line
            UNDEF.lastIndex = match.index;
            const undef = UNDEF.exec(source);
            const identifier = undef[1].trim();

            // are we inside if-blocks that are accepted
            const keep = Preprocessor._keep(stack);

            // remove it from defines
            if (keep) {
              defines.delete(identifier);
            }
            Debug.trace(TRACEID, `${keyword}: [${identifier}] ${keep ? "" : "IGNORED"}`);

            // continue on the next line
            KEYWORD.lastIndex = undef.index + undef[0].length;
            break;
          }
        case 'extension':
          {
            EXTENSION.lastIndex = match.index;
            const extension = EXTENSION.exec(source);
            Debug.assert(extension, `Invalid [${keyword}]: ${source.substring(match.index, match.index + 100)}...`);
            error || (error = extension === null);
            if (extension) {
              const identifier = extension[1];

              // are we inside if-blocks that are accepted
              const keep = Preprocessor._keep(stack);
              if (keep) {
                defines.set(identifier, "true");
              }
              Debug.trace(TRACEID, `${keyword}: [${identifier}] ${keep ? "" : "IGNORED"}`);
            }

            // continue on the next line
            KEYWORD.lastIndex = extension.index + extension[0].length;
            break;
          }
        case 'ifdef':
        case 'ifndef':
        case 'if':
          {
            // read the if line
            IF.lastIndex = match.index;
            const iff = IF.exec(source);
            const expression = iff[2];

            // evaluate expression
            const evaluated = Preprocessor.evaluate(expression, defines);
            error || (error = evaluated.error);
            let result = evaluated.result;
            if (keyword === 'ifndef') {
              result = !result;
            }

            // add info to the stack (to be handled later)
            stack.push({
              anyKeep: result,
              // true if any branch was already accepted
              keep: result,
              // true if this branch is being taken
              start: match.index,
              // start index if IF line
              end: IF.lastIndex // end index of IF line
            });

            Debug.trace(TRACEID, `${keyword}: [${expression}] => ${result}`);

            // continue on the next line
            KEYWORD.lastIndex = iff.index + iff[0].length;
            break;
          }
        case 'endif':
        case 'else':
        case 'elif':
          {
            // match the endif
            ENDIF.lastIndex = match.index;
            const endif = ENDIF.exec(source);
            const blockInfo = stack.pop();

            // code between if and endif
            const blockCode = blockInfo.keep ? source.substring(blockInfo.end, match.index) : "";
            Debug.trace(TRACEID, `${keyword}: [previous block] => ${blockCode !== ""}`);

            // cut out the IF and ENDIF lines, leave block if required
            source = source.substring(0, blockInfo.start) + blockCode + source.substring(ENDIF.lastIndex);
            KEYWORD.lastIndex = blockInfo.start + blockCode.length;

            // handle else if
            const endifCommand = endif[1];
            if (endifCommand === 'else' || endifCommand === 'elif') {
              // if any branch was already accepted, all else branches need to fail regardless of the result
              let result = false;
              if (!blockInfo.anyKeep) {
                if (endifCommand === 'else') {
                  result = !blockInfo.keep;
                } else {
                  const evaluated = Preprocessor.evaluate(endif[2], defines);
                  result = evaluated.result;
                  error || (error = evaluated.error);
                }
              }

              // add back to stack
              stack.push({
                anyKeep: blockInfo.anyKeep || result,
                keep: result,
                start: KEYWORD.lastIndex,
                end: KEYWORD.lastIndex
              });
              Debug.trace(TRACEID, `${keyword}: [${endif[2]}] => ${result}`);
            }
            break;
          }
      }
    }
    if (error) {
      console.warn("Failed to preprocess shader: ", {
        source: originalSource
      });
      return originalSource;
    }
    return source;
  }

  // function returns true if the evaluation is inside keep branches
  static _keep(stack) {
    for (let i = 0; i < stack.length; i++) {
      if (!stack[i].keep) return false;
    }
    return true;
  }

  /**
   * Very simple expression evaluation, handles cases:
   * expression
   * defined(expression)
   * !defined(expression)
   *
   * But does not handle more complex cases, which would require more complex system:
   * defined(A) || defined(B)
   */
  static evaluate(expression, defines) {
    const correct = INVALID.exec(expression) === null;
    Debug.assert(correct, `Resolving expression like this is not supported: ${expression}`);

    // if the format is defined(expression), extract expression
    let invert = false;
    const defined = DEFINED.exec(expression);
    if (defined) {
      invert = defined[1] === '!';
      expression = defined[2];
    }

    // test if expression define exists
    expression = expression.trim();
    let exists = defines.has(expression);

    // handle inversion
    if (invert) {
      exists = !exists;
    }
    return {
      result: exists,
      error: !correct
    };
  }
}

export { Preprocessor };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJlcHJvY2Vzc29yLmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvY29yZS9wcmVwcm9jZXNzb3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGVidWcgfSBmcm9tICcuL2RlYnVnLmpzJztcblxuLy8gaWQgZm9yIGRlYnVnIHRyYWNpbmdcbmNvbnN0IFRSQUNFSUQgPSAnUHJlcHJvY2Vzc29yJztcblxuLy8gYWNjZXB0ZWQga2V5d29yZHNcbmNvbnN0IEtFWVdPUkQgPSAvWyBcXHRdKiMoaWZuP2RlZnxpZnxlbmRpZnxlbHNlfGVsaWZ8ZGVmaW5lfHVuZGVmfGV4dGVuc2lvbikvZztcblxuLy8gI2RlZmluZSBFWFBSRVNTSU9OXG5jb25zdCBERUZJTkUgPSAvZGVmaW5lWyBcXHRdKyhbXlxcbl0rKVxccj8oPzpcXG58JCkvZztcblxuLy8gI2V4dGVuc2lvbiBJREVOVElGSUVSIDogZW5hYmxlZFxuY29uc3QgRVhURU5TSU9OID0gL2V4dGVuc2lvblsgXFx0XSsoW1xcdy1dKylbIFxcdF0qOlsgXFx0XSooZW5hYmxlfHJlcXVpcmUpL2c7XG5cbi8vICN1bmRlZiBFWFBSRVNTSU9OXG5jb25zdCBVTkRFRiA9IC91bmRlZlsgXFx0XSsoW15cXG5dKylcXHI/KD86XFxufCQpL2c7XG5cbi8vICNpZmRlZi8jaWZuZGVmIFNPTUVERUZJTkUsICNpZiBFWFBSRVNTSU9OXG5jb25zdCBJRiA9IC8oaWZkZWZ8aWZuZGVmfGlmKVsgXFx0XSooW15cXHJcXG5dKylcXHI/XFxuL2c7XG5cbi8vICNlbmRpZi8jZWxzZSBvciAjZWxpZiBFWFBSRVNTSU9OXG5jb25zdCBFTkRJRiA9IC8oZW5kaWZ8ZWxzZXxlbGlmKShbIFxcdF0rW15cXHJcXG5dKyk/XFxyPyg/OlxcbnwkKS9nO1xuXG4vLyBpZGVudGlmaWVyXG5jb25zdCBJREVOVElGSUVSID0gLyhbXFx3LV0rKS87XG5cbi8vIFshXWRlZmluZWQoRVhQUkVTU0lPTilcbmNvbnN0IERFRklORUQgPSAvKCF8XFxzKT9kZWZpbmVkXFwoKFtcXHctXSspXFwpLztcblxuLy8gY3VycmVudGx5IHVuc3VwcG9ydGVkIGNoYXJhY3RlcnMgaW4gdGhlIGV4cHJlc3Npb246IHwgJiA8ID4gPSArIC1cbmNvbnN0IElOVkFMSUQgPSAvWz48PXwmKy1dL2c7XG5cbi8qKlxuICogUHVyZSBzdGF0aWMgY2xhc3MgaW1wbGVtZW50aW5nIHN1YnNldCBvZiBDLXN0eWxlIHByZXByb2Nlc3Nvci5cbiAqIGluc3BpcmVkIGJ5OiBodHRwczovL2dpdGh1Yi5jb20vZGNvZGVJTy9QcmVwcm9jZXNzb3IuanNcbiAqXG4gKiBAaWdub3JlXG4gKi9cbmNsYXNzIFByZXByb2Nlc3NvciB7XG4gICAgLyoqXG4gICAgICogUnVuIGMtbGlrZSBwcmVwcm9jZXNzb3Igb24gdGhlIHNvdXJjZSBjb2RlLCBhbmQgcmVzb2x2ZXMgdGhlIGNvZGUgYmFzZWQgb24gdGhlIGRlZmluZXMgYW5kIGlmZGVmc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSAtIFRoZSBzb3VyY2UgY29kZSB0byB3b3JrIG9uLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gUmV0dXJucyBwcmVwcm9jZXNzZWQgc291cmNlIGNvZGUsIG9yIG51bGwgaW4gY2FzZSBvZiBlcnJvci5cbiAgICAgKi9cbiAgICBzdGF0aWMgcnVuKHNvdXJjZSkge1xuXG4gICAgICAgIC8vIHN0cmlwcyBjb21tZW50cywgaGFuZGxlcyAvLyBhbmQgbWFueSBjYXNlcyBvZiAvKlxuICAgICAgICBzb3VyY2UgPSBzb3VyY2UucmVwbGFjZSgvXFwvXFwqW1xcc1xcU10qP1xcKlxcL3woW15cXFxcOl18XilcXC9cXC8uKiQvZ20sICckMScpO1xuXG4gICAgICAgIC8vIHJpZ2h0IHRyaW0gZWFjaCBsaW5lXG4gICAgICAgIHNvdXJjZSA9IHNvdXJjZS5zcGxpdCgvXFxyP1xcbi8pXG4gICAgICAgICAgICAubWFwKGxpbmUgPT4gbGluZS50cmltRW5kKCkpXG4gICAgICAgICAgICAuam9pbignXFxuJyk7XG5cbiAgICAgICAgLy8gcHJlcHJvY2VzcyBkZWZpbmVzIC8gaWZkZWZzIC4uXG4gICAgICAgIHNvdXJjZSA9IHRoaXMuX3ByZXByb2Nlc3Moc291cmNlKTtcblxuICAgICAgICBpZiAoc291cmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBjb252ZXJ0IGxpbmVzIHdpdGggb25seSB3aGl0ZSBzcGFjZSBpbnRvIGVtcHR5IHN0cmluZ1xuICAgICAgICAgICAgc291cmNlID0gc291cmNlLnNwbGl0KC9cXHI/XFxuLylcbiAgICAgICAgICAgICAgICAubWFwKGxpbmUgPT4gKGxpbmUudHJpbSgpID09PSAnJyA/ICcnIDogbGluZSkpXG4gICAgICAgICAgICAgICAgLmpvaW4oJ1xcbicpO1xuXG4gICAgICAgICAgICAvLyByZW1vdmUgbW9yZSB0aGFuIDEgY29uc2VjdXRpdmUgZW1wdHkgbGluZXNcbiAgICAgICAgICAgIHNvdXJjZSA9IHNvdXJjZS5yZXBsYWNlKC8oXFxuXFxuKXszLH0vZ20sICdcXG5cXG4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfVxuXG4gICAgc3RhdGljIF9wcmVwcm9jZXNzKHNvdXJjZSkge1xuXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsU291cmNlID0gc291cmNlO1xuXG4gICAgICAgIC8vIHN0YWNrLCBzdG9yaW5nIGluZm8gYWJvdXQgaWZkZWYgYmxvY2tzXG4gICAgICAgIGNvbnN0IHN0YWNrID0gW107XG5cbiAgICAgICAgLy8gdHJ1ZSBpZiB0aGUgZnVuY3Rpb24gZW5jb3VudGVyIGEgcHJvYmxlbVxuICAgICAgICBsZXQgZXJyb3IgPSBmYWxzZTtcblxuICAgICAgICAvLyBhY3RpdmUgZGVmaW5lcywgbWFwcyBkZWZpbmUgbmFtZSB0byBpdHMgdmFsdWVcbiAgICAgICAgLyoqIEB0eXBlIHtNYXA8c3RyaW5nLCBzdHJpbmc+fSAqL1xuICAgICAgICBjb25zdCBkZWZpbmVzID0gbmV3IE1hcCgpO1xuXG4gICAgICAgIGxldCBtYXRjaDtcbiAgICAgICAgd2hpbGUgKChtYXRjaCA9IEtFWVdPUkQuZXhlYyhzb3VyY2UpKSAhPT0gbnVsbCkge1xuXG4gICAgICAgICAgICBjb25zdCBrZXl3b3JkID0gbWF0Y2hbMV07XG4gICAgICAgICAgICBzd2l0Y2ggKGtleXdvcmQpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdkZWZpbmUnOiB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gcmVhZCB0aGUgcmVzdCBvZiB0aGUgZGVmaW5lIGxpbmVcbiAgICAgICAgICAgICAgICAgICAgREVGSU5FLmxhc3RJbmRleCA9IG1hdGNoLmluZGV4O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWZpbmUgPSBERUZJTkUuZXhlYyhzb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICBEZWJ1Zy5hc3NlcnQoZGVmaW5lLCBgSW52YWxpZCBbJHtrZXl3b3JkfV06ICR7c291cmNlLnN1YnN0cmluZyhtYXRjaC5pbmRleCwgbWF0Y2guaW5kZXggKyAxMDApfS4uLmApO1xuICAgICAgICAgICAgICAgICAgICBlcnJvciB8fD0gZGVmaW5lID09PSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gZGVmaW5lWzFdO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHNwbGl0IGl0IHRvIGlkZW50aWZpZXIgbmFtZSBhbmQgYSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICBJREVOVElGSUVSLmxhc3RJbmRleCA9IGRlZmluZS5pbmRleDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaWRlbnRpZmllclZhbHVlID0gSURFTlRJRklFUi5leGVjKGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpZGVudGlmaWVyID0gaWRlbnRpZmllclZhbHVlWzFdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBleHByZXNzaW9uLnN1YnN0cmluZyhpZGVudGlmaWVyLmxlbmd0aCkudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IFwiXCIpIHZhbHVlID0gXCJ0cnVlXCI7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYXJlIHdlIGluc2lkZSBpZi1ibG9ja3MgdGhhdCBhcmUgYWNjZXB0ZWRcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2VlcCA9IFByZXByb2Nlc3Nvci5fa2VlcChzdGFjayk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGtlZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmluZXMuc2V0KGlkZW50aWZpZXIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIERlYnVnLnRyYWNlKFRSQUNFSUQsIGAke2tleXdvcmR9OiBbJHtpZGVudGlmaWVyfV0gJHt2YWx1ZX0gJHtrZWVwID8gXCJcIiA6IFwiSUdOT1JFRFwifWApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVlIG9uIHRoZSBuZXh0IGxpbmVcbiAgICAgICAgICAgICAgICAgICAgS0VZV09SRC5sYXN0SW5kZXggPSBkZWZpbmUuaW5kZXggKyBkZWZpbmVbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjYXNlICd1bmRlZic6IHtcblxuICAgICAgICAgICAgICAgICAgICAvLyByZWFkIHRoZSByZXN0IG9mIHRoZSBkZWZpbmUgbGluZVxuICAgICAgICAgICAgICAgICAgICBVTkRFRi5sYXN0SW5kZXggPSBtYXRjaC5pbmRleDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdW5kZWYgPSBVTkRFRi5leGVjKHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSB1bmRlZlsxXS50cmltKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYXJlIHdlIGluc2lkZSBpZi1ibG9ja3MgdGhhdCBhcmUgYWNjZXB0ZWRcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2VlcCA9IFByZXByb2Nlc3Nvci5fa2VlcChzdGFjayk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGl0IGZyb20gZGVmaW5lc1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2VlcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmaW5lcy5kZWxldGUoaWRlbnRpZmllcik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBEZWJ1Zy50cmFjZShUUkFDRUlELCBgJHtrZXl3b3JkfTogWyR7aWRlbnRpZmllcn1dICR7a2VlcCA/IFwiXCIgOiBcIklHTk9SRURcIn1gKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBjb250aW51ZSBvbiB0aGUgbmV4dCBsaW5lXG4gICAgICAgICAgICAgICAgICAgIEtFWVdPUkQubGFzdEluZGV4ID0gdW5kZWYuaW5kZXggKyB1bmRlZlswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNhc2UgJ2V4dGVuc2lvbic6IHtcbiAgICAgICAgICAgICAgICAgICAgRVhURU5TSU9OLmxhc3RJbmRleCA9IG1hdGNoLmluZGV4O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBleHRlbnNpb24gPSBFWFRFTlNJT04uZXhlYyhzb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICBEZWJ1Zy5hc3NlcnQoZXh0ZW5zaW9uLCBgSW52YWxpZCBbJHtrZXl3b3JkfV06ICR7c291cmNlLnN1YnN0cmluZyhtYXRjaC5pbmRleCwgbWF0Y2guaW5kZXggKyAxMDApfS4uLmApO1xuICAgICAgICAgICAgICAgICAgICBlcnJvciB8fD0gZXh0ZW5zaW9uID09PSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpZGVudGlmaWVyID0gZXh0ZW5zaW9uWzFdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhcmUgd2UgaW5zaWRlIGlmLWJsb2NrcyB0aGF0IGFyZSBhY2NlcHRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2VlcCA9IFByZXByb2Nlc3Nvci5fa2VlcChzdGFjayk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZWVwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmaW5lcy5zZXQoaWRlbnRpZmllciwgXCJ0cnVlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBEZWJ1Zy50cmFjZShUUkFDRUlELCBgJHtrZXl3b3JkfTogWyR7aWRlbnRpZmllcn1dICR7a2VlcCA/IFwiXCIgOiBcIklHTk9SRURcIn1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVlIG9uIHRoZSBuZXh0IGxpbmVcbiAgICAgICAgICAgICAgICAgICAgS0VZV09SRC5sYXN0SW5kZXggPSBleHRlbnNpb24uaW5kZXggKyBleHRlbnNpb25bMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjYXNlICdpZmRlZic6XG4gICAgICAgICAgICAgICAgY2FzZSAnaWZuZGVmJzpcbiAgICAgICAgICAgICAgICBjYXNlICdpZic6IHtcblxuICAgICAgICAgICAgICAgICAgICAvLyByZWFkIHRoZSBpZiBsaW5lXG4gICAgICAgICAgICAgICAgICAgIElGLmxhc3RJbmRleCA9IG1hdGNoLmluZGV4O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpZmYgPSBJRi5leGVjKHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBpZmZbMl07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZXZhbHVhdGUgZXhwcmVzc2lvblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBldmFsdWF0ZWQgPSBQcmVwcm9jZXNzb3IuZXZhbHVhdGUoZXhwcmVzc2lvbiwgZGVmaW5lcyk7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yIHx8PSBldmFsdWF0ZWQuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBldmFsdWF0ZWQucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5d29yZCA9PT0gJ2lmbmRlZicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9ICFyZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgaW5mbyB0byB0aGUgc3RhY2sgKHRvIGJlIGhhbmRsZWQgbGF0ZXIpXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgYW55S2VlcDogcmVzdWx0LCAgICAgICAgLy8gdHJ1ZSBpZiBhbnkgYnJhbmNoIHdhcyBhbHJlYWR5IGFjY2VwdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBrZWVwOiByZXN1bHQsICAgICAgICAgICAvLyB0cnVlIGlmIHRoaXMgYnJhbmNoIGlzIGJlaW5nIHRha2VuXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogbWF0Y2guaW5kZXgsICAgICAvLyBzdGFydCBpbmRleCBpZiBJRiBsaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IElGLmxhc3RJbmRleCAgICAgICAvLyBlbmQgaW5kZXggb2YgSUYgbGluZVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBEZWJ1Zy50cmFjZShUUkFDRUlELCBgJHtrZXl3b3JkfTogWyR7ZXhwcmVzc2lvbn1dID0+ICR7cmVzdWx0fWApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVlIG9uIHRoZSBuZXh0IGxpbmVcbiAgICAgICAgICAgICAgICAgICAgS0VZV09SRC5sYXN0SW5kZXggPSBpZmYuaW5kZXggKyBpZmZbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjYXNlICdlbmRpZic6XG4gICAgICAgICAgICAgICAgY2FzZSAnZWxzZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnZWxpZic6IHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBtYXRjaCB0aGUgZW5kaWZcbiAgICAgICAgICAgICAgICAgICAgRU5ESUYubGFzdEluZGV4ID0gbWF0Y2guaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVuZGlmID0gRU5ESUYuZXhlYyhzb3VyY2UpO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrSW5mbyA9IHN0YWNrLnBvcCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvZGUgYmV0d2VlbiBpZiBhbmQgZW5kaWZcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmxvY2tDb2RlID0gYmxvY2tJbmZvLmtlZXAgPyBzb3VyY2Uuc3Vic3RyaW5nKGJsb2NrSW5mby5lbmQsIG1hdGNoLmluZGV4KSA6IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIERlYnVnLnRyYWNlKFRSQUNFSUQsIGAke2tleXdvcmR9OiBbcHJldmlvdXMgYmxvY2tdID0+ICR7YmxvY2tDb2RlICE9PSBcIlwifWApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGN1dCBvdXQgdGhlIElGIGFuZCBFTkRJRiBsaW5lcywgbGVhdmUgYmxvY2sgaWYgcmVxdWlyZWRcbiAgICAgICAgICAgICAgICAgICAgc291cmNlID0gc291cmNlLnN1YnN0cmluZygwLCBibG9ja0luZm8uc3RhcnQpICsgYmxvY2tDb2RlICsgc291cmNlLnN1YnN0cmluZyhFTkRJRi5sYXN0SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBLRVlXT1JELmxhc3RJbmRleCA9IGJsb2NrSW5mby5zdGFydCArIGJsb2NrQ29kZS5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxlIGVsc2UgaWZcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZW5kaWZDb21tYW5kID0gZW5kaWZbMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmRpZkNvbW1hbmQgPT09ICdlbHNlJyB8fCBlbmRpZkNvbW1hbmQgPT09ICdlbGlmJykge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBhbnkgYnJhbmNoIHdhcyBhbHJlYWR5IGFjY2VwdGVkLCBhbGwgZWxzZSBicmFuY2hlcyBuZWVkIHRvIGZhaWwgcmVnYXJkbGVzcyBvZiB0aGUgcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJsb2NrSW5mby5hbnlLZWVwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVuZGlmQ29tbWFuZCA9PT0gJ2Vsc2UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9ICFibG9ja0luZm8ua2VlcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBldmFsdWF0ZWQgPSBQcmVwcm9jZXNzb3IuZXZhbHVhdGUoZW5kaWZbMl0sIGRlZmluZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBldmFsdWF0ZWQucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvciB8fD0gZXZhbHVhdGVkLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGJhY2sgdG8gc3RhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFueUtlZXA6IGJsb2NrSW5mby5hbnlLZWVwIHx8IHJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZWVwOiByZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IEtFWVdPUkQubGFzdEluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogS0VZV09SRC5sYXN0SW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgRGVidWcudHJhY2UoVFJBQ0VJRCwgYCR7a2V5d29yZH06IFske2VuZGlmWzJdfV0gPT4gJHtyZXN1bHR9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkZhaWxlZCB0byBwcmVwcm9jZXNzIHNoYWRlcjogXCIsIHsgc291cmNlOiBvcmlnaW5hbFNvdXJjZSB9KTtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbFNvdXJjZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfVxuXG4gICAgLy8gZnVuY3Rpb24gcmV0dXJucyB0cnVlIGlmIHRoZSBldmFsdWF0aW9uIGlzIGluc2lkZSBrZWVwIGJyYW5jaGVzXG4gICAgc3RhdGljIF9rZWVwKHN0YWNrKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghc3RhY2tbaV0ua2VlcClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBWZXJ5IHNpbXBsZSBleHByZXNzaW9uIGV2YWx1YXRpb24sIGhhbmRsZXMgY2FzZXM6XG4gICAgICogZXhwcmVzc2lvblxuICAgICAqIGRlZmluZWQoZXhwcmVzc2lvbilcbiAgICAgKiAhZGVmaW5lZChleHByZXNzaW9uKVxuICAgICAqXG4gICAgICogQnV0IGRvZXMgbm90IGhhbmRsZSBtb3JlIGNvbXBsZXggY2FzZXMsIHdoaWNoIHdvdWxkIHJlcXVpcmUgbW9yZSBjb21wbGV4IHN5c3RlbTpcbiAgICAgKiBkZWZpbmVkKEEpIHx8IGRlZmluZWQoQilcbiAgICAgKi9cbiAgICBzdGF0aWMgZXZhbHVhdGUoZXhwcmVzc2lvbiwgZGVmaW5lcykge1xuXG4gICAgICAgIGNvbnN0IGNvcnJlY3QgPSBJTlZBTElELmV4ZWMoZXhwcmVzc2lvbikgPT09IG51bGw7XG4gICAgICAgIERlYnVnLmFzc2VydChjb3JyZWN0LCBgUmVzb2x2aW5nIGV4cHJlc3Npb24gbGlrZSB0aGlzIGlzIG5vdCBzdXBwb3J0ZWQ6ICR7ZXhwcmVzc2lvbn1gKTtcblxuICAgICAgICAvLyBpZiB0aGUgZm9ybWF0IGlzIGRlZmluZWQoZXhwcmVzc2lvbiksIGV4dHJhY3QgZXhwcmVzc2lvblxuICAgICAgICBsZXQgaW52ZXJ0ID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGRlZmluZWQgPSBERUZJTkVELmV4ZWMoZXhwcmVzc2lvbik7XG4gICAgICAgIGlmIChkZWZpbmVkKSB7XG4gICAgICAgICAgICBpbnZlcnQgPSBkZWZpbmVkWzFdID09PSAnISc7XG4gICAgICAgICAgICBleHByZXNzaW9uID0gZGVmaW5lZFsyXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRlc3QgaWYgZXhwcmVzc2lvbiBkZWZpbmUgZXhpc3RzXG4gICAgICAgIGV4cHJlc3Npb24gPSBleHByZXNzaW9uLnRyaW0oKTtcbiAgICAgICAgbGV0IGV4aXN0cyA9IGRlZmluZXMuaGFzKGV4cHJlc3Npb24pO1xuXG4gICAgICAgIC8vIGhhbmRsZSBpbnZlcnNpb25cbiAgICAgICAgaWYgKGludmVydCkge1xuICAgICAgICAgICAgZXhpc3RzID0gIWV4aXN0cztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN1bHQ6IGV4aXN0cyxcbiAgICAgICAgICAgIGVycm9yOiAhY29ycmVjdFxuICAgICAgICB9O1xuICAgIH1cbn1cblxuZXhwb3J0IHsgUHJlcHJvY2Vzc29yIH07XG4iXSwibmFtZXMiOlsiVFJBQ0VJRCIsIktFWVdPUkQiLCJERUZJTkUiLCJFWFRFTlNJT04iLCJVTkRFRiIsIklGIiwiRU5ESUYiLCJJREVOVElGSUVSIiwiREVGSU5FRCIsIklOVkFMSUQiLCJQcmVwcm9jZXNzb3IiLCJydW4iLCJzb3VyY2UiLCJyZXBsYWNlIiwic3BsaXQiLCJtYXAiLCJsaW5lIiwidHJpbUVuZCIsImpvaW4iLCJfcHJlcHJvY2VzcyIsInRyaW0iLCJvcmlnaW5hbFNvdXJjZSIsInN0YWNrIiwiZXJyb3IiLCJkZWZpbmVzIiwiTWFwIiwibWF0Y2giLCJleGVjIiwia2V5d29yZCIsImxhc3RJbmRleCIsImluZGV4IiwiZGVmaW5lIiwiRGVidWciLCJhc3NlcnQiLCJzdWJzdHJpbmciLCJleHByZXNzaW9uIiwiaWRlbnRpZmllclZhbHVlIiwiaWRlbnRpZmllciIsInZhbHVlIiwibGVuZ3RoIiwia2VlcCIsIl9rZWVwIiwic2V0IiwidHJhY2UiLCJ1bmRlZiIsImRlbGV0ZSIsImV4dGVuc2lvbiIsImlmZiIsImV2YWx1YXRlZCIsImV2YWx1YXRlIiwicmVzdWx0IiwicHVzaCIsImFueUtlZXAiLCJzdGFydCIsImVuZCIsImVuZGlmIiwiYmxvY2tJbmZvIiwicG9wIiwiYmxvY2tDb2RlIiwiZW5kaWZDb21tYW5kIiwiY29uc29sZSIsIndhcm4iLCJpIiwiY29ycmVjdCIsImludmVydCIsImRlZmluZWQiLCJleGlzdHMiLCJoYXMiXSwibWFwcGluZ3MiOiI7O0FBRUE7QUFDQSxNQUFNQSxPQUFPLEdBQUcsY0FBYyxDQUFBOztBQUU5QjtBQUNBLE1BQU1DLE9BQU8sR0FBRyw2REFBNkQsQ0FBQTs7QUFFN0U7QUFDQSxNQUFNQyxNQUFNLEdBQUcsa0NBQWtDLENBQUE7O0FBRWpEO0FBQ0EsTUFBTUMsU0FBUyxHQUFHLHVEQUF1RCxDQUFBOztBQUV6RTtBQUNBLE1BQU1DLEtBQUssR0FBRyxpQ0FBaUMsQ0FBQTs7QUFFL0M7QUFDQSxNQUFNQyxFQUFFLEdBQUcseUNBQXlDLENBQUE7O0FBRXBEO0FBQ0EsTUFBTUMsS0FBSyxHQUFHLGdEQUFnRCxDQUFBOztBQUU5RDtBQUNBLE1BQU1DLFVBQVUsR0FBRyxVQUFVLENBQUE7O0FBRTdCO0FBQ0EsTUFBTUMsT0FBTyxHQUFHLDRCQUE0QixDQUFBOztBQUU1QztBQUNBLE1BQU1DLE9BQU8sR0FBRyxZQUFZLENBQUE7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU1DLFlBQVksQ0FBQztBQUNmO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNJLE9BQU9DLEdBQUdBLENBQUNDLE1BQU0sRUFBRTtBQUVmO0lBQ0FBLE1BQU0sR0FBR0EsTUFBTSxDQUFDQyxPQUFPLENBQUMsc0NBQXNDLEVBQUUsSUFBSSxDQUFDLENBQUE7O0FBRXJFO0lBQ0FELE1BQU0sR0FBR0EsTUFBTSxDQUFDRSxLQUFLLENBQUMsT0FBTyxDQUFDLENBQ3pCQyxHQUFHLENBQUNDLElBQUksSUFBSUEsSUFBSSxDQUFDQyxPQUFPLEVBQUUsQ0FBQyxDQUMzQkMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFBOztBQUVmO0FBQ0FOLElBQUFBLE1BQU0sR0FBRyxJQUFJLENBQUNPLFdBQVcsQ0FBQ1AsTUFBTSxDQUFDLENBQUE7SUFFakMsSUFBSUEsTUFBTSxLQUFLLElBQUksRUFBRTtBQUNq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
