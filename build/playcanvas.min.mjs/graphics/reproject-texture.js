import"../core/tracing.js";import{TEXTUREPROJECTION_OCTAHEDRAL as e,TEXTUREPROJECTION_CUBE as t,FILTER_NEAREST as r}from"./constants.js";import{Vec3 as n}from"../math/vec3.js";import{random as s}from"../math/random.js";import{createShaderFromCode as o}from"./program-lib/utils.js";import{drawQuadWithShader as a}from"./simple-post-effect.js";import{ChunkUtils as i}from"./program-lib/chunk-utils.js";import{shaderChunks as c}from"./program-lib/chunks/chunks.js";import{RenderTarget as h}from"./render-target.js";import{GraphicsDevice as l}from"./graphics-device.js";import{Texture as m}from"./texture.js";import{DeviceCache as p}from"./device-cache.js";const u=r=>{switch(r){case t:return"Cubemap";case e:return"Octahedral";default:return"Equirect"}},d=(e,t,r)=>{if(e<=0)t[r+0]=0,t[r+1]=0,t[r+2]=0,t[r+3]=0;else if(e>=1)t[r+0]=255,t[r+1]=0,t[r+2]=0,t[r+3]=0;else{let n=1*e%1,s=255*e%1,o=65025*e%1;const a=16581375*e%1;n-=s/255,s-=o/255,o-=a/255,t[r+0]=Math.min(255,Math.floor(256*n)),t[r+1]=Math.min(255,Math.floor(256*s)),t[r+2]=Math.min(255,Math.floor(256*o)),t[r+3]=Math.min(255,Math.floor(256*a))}},f=(e,t,r,n)=>{const s=2*r*Math.PI,o=Math.pow(1-t,1/(n+1)),a=Math.sqrt(1-o*o);e.set(Math.cos(s)*a,Math.sin(s)*a,o).normalize()},g=(e,t,r)=>{const n=2*r*Math.PI,s=Math.sqrt(1-t),o=Math.sqrt(t);e.set(Math.cos(n)*o,Math.sin(n)*o,s).normalize()},M=(e,t,r,n)=>{const s=2*r*Math.PI,o=Math.sqrt((1-t)/(1+(n*n-1)*t)),a=Math.sqrt(1-o*o);e.set(Math.cos(s)*a,Math.sin(s)*a,o).normalize()},v=(e,t)=>{const r=e*t,n=t/(1-e*e+r*r);return n*n*(1/Math.PI)},w={16:{2:26,8:20,32:17,128:16,512:16},32:{2:53,8:40,32:34,128:32,512:32},128:{2:214,8:163,32:139,128:130,512:128},1024:{2:1722,8:1310,32:1114,128:1041,512:1025}},x=(e,t,r)=>{const o=r/e,a=1-Math.log2(t)/11,i=a*a,c=new n,h=new n,l=new n(0,0,1),m=[],p=((e,t)=>{const r=w[e];return r&&r[t]||e})(e,t);for(let e=0;e<p;++e){M(c,e/p,s.radicalInverse(e),i);const t=c.z;if(h.set(c.x,c.y,c.z).mulScalar(2*t).sub(l),h.z>0){const e=v(Math.min(1,t),i)/4+.001,r=.5*Math.log2(o/e);m.push(h.x,h.y,h.z,r)}}for(;m.length<4*e;)m.push(0,0,0,0);return m},_=(e,t,n)=>{const s=(e=>{const t=e.length,r=Math.min(t,512),n=Math.ceil(t/r),s=new Uint8Array(r*n*4);let o=0;for(let r=0;r<t;++r)d(.5*e[4*r+0]+.5,s,o+0),d(.5*e[4*r+1]+.5,s,o+4),d(.5*e[4*r+2]+.5,s,o+8),d(e[4*r+3]/8,s,o+12),o+=16;return{width:r,height:n,data:s}})(n);return new m(e,{name:t,width:s.width,height:s.height,mipmaps:!1,minFilter:r,magFilter:r,levels:[s.data]})};class ${constructor(e=!0){this.map=new Map,this.destroyContent=e}destroy(){this.destroyContent&&this.map.forEach(((e,t)=>{e.destroy()}))}get(e,t){if(!this.map.has(e)){const r=t();return this.map.set(e,r),r}return this.map.get(e)}}const b=new $(!1),S=new p,P=(e,t,r)=>S.get(e,(()=>new $)).get(t,(()=>_(e,t,b.get(t,r)))),j=(e,t,r)=>P(e,`lambert-samples-${t}-${r}`,(()=>((e,t)=>{const r=t/e,o=new n,a=[];for(let t=0;t<e;++t){g(o,t/e,s.radicalInverse(t));const n=o.z/Math.PI,i=.5*Math.log2(r/n);a.push(o.x,o.y,o.z,i)}return a})(t,r))),y=(e,t,r)=>P(e,`phong-samples-${t}-${r}`,(()=>((e,t)=>{const r=new n,o=[];for(let n=0;n<e;++n)f(r,n/e,s.radicalInverse(n),t),o.push(r.x,r.y,r.z,0);return o})(t,r))),C=(e,t,r,n)=>P(e,`ggx-samples-${t}-${r}-${n}`,(()=>x(t,r,n))),E="\nattribute vec2 vertex_position;\n\nuniform vec4 uvMod;\n\nvarying vec2 vUv0;\n\nvoid main(void) {\n    gl_Position = vec4(vertex_position, 0.5, 1.0);\n    vUv0 = (vertex_position.xy * 0.5 + 0.5) * uvMod.xy + uvMod.zw;\n}\n";function U(e,t,r={}){var n;e instanceof l&&(e=arguments[1],t=arguments[2],r={},void 0!==arguments[3]&&(r.specularPower=arguments[3]),void 0!==arguments[4]&&(r.numSamples=arguments[4]));const s={none:"reproject",lambert:"prefilterSamplesUnweighted",phong:"prefilterSamplesUnweighted",ggx:"prefilterSamples"},m=r.hasOwnProperty("specularPower")?r.specularPower:1,p=r.hasOwnProperty("face")?r.face:null,d=r.hasOwnProperty("distribution")?r.distribution:1===m?"none":"phong",f=s[d]||"reproject",g=i.decodeFunc(e.encoding),M=i.encodeFunc(t.encoding),v=`sample${u(e.projection)}`,w=`getDirection${u(t.projection)}`,x=r.hasOwnProperty("numSamples")?r.numSamples:1024,_=`${f}_${g}_${M}_${v}_${w}_${x}`,$=e.device;let b=$.programLib._cache[_];if(!b){const e=`#define PROCESS_FUNC ${f}\n#define DECODE_FUNC ${g}\n#define ENCODE_FUNC ${M}\n#define SOURCE_FUNC ${v}\n#define TARGET_FUNC ${w}\n#define NUM_SAMPLES ${x}\n#define NUM_SAMPLES_SQRT ${Math.round(Math.sqrt(x)).toFixed(1)}\n`+($.extTextureLod?"#define SUPPORTS_TEXLOD\n":"");let t="";$.webgl2||(t="#extension GL_OES_standard_derivatives: enable\n",$.extTextureLod&&(t+="#extension GL_EXT_shader_texture_lod: enable\n\n")),b=o($,E,`${e}\n${c.reprojectPS}`,_,!1,t)}const S=$.scope.resolve(e.cubemap?"sourceCube":"sourceTex");S.setValue(e);const P=$.scope.resolve("params"),U=$.scope.resolve("params2"),z=$.scope.resolve("uvMod");if(null!=(n=r)&&n.seamPixels){const e=r.seamPixels,n=(r.rect?r.rect.z:t.width)-2*e,s=(r.rect?r.rect.w:t.height)-2*e;z.setValue([(n+2*e)/n,(s+2*e)/s,-e/n,-e/s])}else z.setValue([1,1,0,0]);const O=[0,m,e.fixCubemapSeams?1/e.width:0,t.fixCubemapSeams?1/t.width:0],T=[t.width*t.height*(t.cubemap?6:1),e.width*e.height*(e.cubemap?6:1)];if(f.startsWith("prefilterSamples")){const t=e.width*e.height*(e.cubemap?6:1),r="ggx"===d?C($,x,m,t):"lambert"===d?j($,x,t):y($,x,m);$.scope.resolve("samplesTex").setValue(r),$.scope.resolve("samplesTexInverseSize").setValue([1/r.width,1/r.height])}for(let e=0;e<(t.cubemap?6:1);e++)if(null===p||e===p){var F;const n=new h({colorBuffer:t,face:e,depth:!1});O[0]=e,P.setValue(O),U.setValue(T),a($,n,b,null==(F=r)?void 0:F.rect),n.destroy()}}export{U as reprojectTexture};
