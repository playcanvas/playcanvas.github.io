import{SEMANTIC_POSITION as t,SEMANTIC_ATTR12 as e,SEMANTIC_ATTR13 as i,SEMANTIC_ATTR14 as n,SEMANTIC_ATTR15 as a,SEMANTIC_NORMAL as r,SEMANTIC_TANGENT as s,SEMANTIC_COLOR as d,SEMANTIC_ATTR8 as o,SEMANTIC_ATTR9 as l,SEMANTIC_ATTR10 as p,SEMANTIC_ATTR11 as h,SEMANTIC_BLENDWEIGHT as c,SEMANTIC_BLENDINDICES as g,PIXELFORMAT_RGBA8 as u,SHADERTAG_MATERIAL as f,SEMANTIC_TEXCOORD0 as S,SEMANTIC_TEXCOORD1 as m}from"../../../platform/graphics/constants.js";import{shaderChunks as _}from"../chunks/chunks.js";import{ChunkUtils as v}from"../chunk-utils.js";import{SPRITE_RENDERMODE_SLICED as A,SPRITE_RENDERMODE_TILED as P,LIGHTTYPE_SPOT as b,LIGHTSHAPE_SPHERE as w,LIGHTSHAPE_DISK as C,LIGHTSHAPE_RECT as D,SHADER_DEPTH as L,SHADOW_VSM32 as N,SHADOW_PCF3 as E,LIGHTTYPE_OMNI as W,SHADOW_VSM8 as M,LIGHTTYPE_DIRECTIONAL as T,SHADOW_PCF5 as x,LIGHTSHAPE_PUNCTUAL as y,FRESNEL_SCHLICK as F,SPECOCC_GLOSSDEPENDENT as R,SPECOCC_AO as V,SHADOW_VSM16 as I,SPECULAR_PHONG as $,shadowTypeToString as k,LIGHTFALLOFF_LINEAR as O,BLEND_NORMAL as G,BLEND_PREMULTIPLIED as B,BLEND_ADDITIVEALPHA as U,SHADER_PICK as H}from"../../constants.js";import{LightsBuffer as j}from"../../lighting/lights-buffer.js";import{ShaderPass as X}from"../../shader-pass.js";import{skinCode as z,begin as q,end as Q,gammaCode as Y,tonemapCode as Z,fogCode as K}from"./common.js";import"../../../core/tracing.js";import{ShaderUtils as J}from"../../../platform/graphics/shader-utils.js";import{ChunkBuilder as tt}from"../chunk-builder.js";const et={vertex_normal:r,vertex_tangent:s,vertex_texCoord0:S,vertex_texCoord1:m,vertex_color:d,vertex_boneWeights:c,vertex_boneIndices:g},it={vVertexColor:"vec4",vPositionW:"vec3",vNormalV:"vec3",vNormalW:"vec3",vTangentW:"vec3",vBinormalW:"vec3",vObjectSpaceUpW:"vec3",vUv0:"vec2",vUv1:"vec2"};class nt{constructor(e,i){if(this.device=e,this.options=i,this.attributes={vertex_position:t},i.chunks){this.chunks={};const t=i.chunks;for(const e in _)if(t.hasOwnProperty(e)){const i=t[e];for(const t in et)et.hasOwnProperty(t)&&i.indexOf(t)>=0&&(this.attributes[t]=et[t]);this.chunks[e]=i}else this.chunks[e]=_[e]}else this.chunks=_;this.lighting=i.lights.length>0||i.dirLightMapEnabled||i.clusteredLightingEnabled,this.reflections=!!i.reflectionSource,this.shadowPass=X.isShadow(i.pass),this.needsNormal=this.lighting||this.reflections||i.useSpecular||i.ambientSH||i.heightMapEnabled||i.enableGGXSpecular||i.clusteredLightingEnabled&&!this.shadowPass||i.clearCoatNormalMapEnabled,this.needsNormal=this.needsNormal&&!this.shadowPass,this.needsSceneColor=i.useDynamicRefraction,this.needsScreenSize=i.useDynamicRefraction,this.needsTransforms=i.useDynamicRefraction,this.varyings="",this.vshader=null,this.frontendDecl=null,this.frontendCode=null,this.frontendFunc=null,this.lightingUv=null,this.defines=[],this.fshader=null}_vsAddBaseCode(t,e,i){return t+=e.baseVS,i.nineSlicedMode!==A&&i.nineSlicedMode!==P||(t+=e.baseNineSlicedVS),t}_vsAddTransformCode(t,e,i,n){return t+=this.chunks.transformVS}_setMapTransform(t,e,i,n){const a=i+100*n;if(!t[3][a]){const r=`texture_${e}MapTransform`;t[0]+=`uniform vec3 ${r}0;\n`,t[0]+=`uniform vec3 ${r}1;\n`,t[1]+=`varying vec2 vUV${n}_${i};\n`,t[2]+=`   vUV${n}_${i} = vec2(dot(vec3(uv${n}, 1), ${r}0), dot(vec3(uv${n}, 1), ${r}1));\n`,t[3][a]=!0}return t}_fsGetBaseCode(){const t=this.options,e=this.chunks;let i=this.chunks.basePS;return t.nineSlicedMode===A?i+=e.baseNineSlicedPS:t.nineSlicedMode===P&&(i+=e.baseNineSlicedTiledPS),i}_fsGetStartCode(t,e,i,n){let a=i.startPS;return n.nineSlicedMode===A?a+=i.startNineSlicedPS:n.nineSlicedMode===P&&(a+=i.startNineSlicedTiledPS),a}_directionalShadowMapProjection(t,e,i,n,a,r){let s="";const d=n?", "+n:"";let o=`(${e}, ${i}${d});`;return t.numCascades>1&&(s+=`getShadowCascadeMatrix(light${a}_shadowMatrixPalette, light${a}_shadowCascadeDistances, light${a}_shadowCascadeCount);\n`,o=`(cascadeShadowMat, ${i}${d});\n`),s+=r+o,s+=`fadeShadow(light${a}_shadowCascadeDistances);\n`,s}_nonPointShadowMapProjection(t,e,i,n,a){const r="dLightPosW, dLightDirW, dLightDirNormW, dVertexNormalW",s=`(${i}, ${n});\n`,d=`(${i}, ${n}, dVertexNormalW);\n`,o=`(${i}, ${n}, dLightDirW);\n`,l=`(${i}, ${n}, ${r});\n`;return!e._normalOffsetBias||e._isVsm?e._type===b?e._isPcf&&(t.webgl2||t.extStandardDerivatives||t.isWebGPU)?"       getShadowCoordPerspZbuffer"+s:"       getShadowCoordPersp"+o:this._directionalShadowMapProjection(e,i,n,null,a,"getShadowCoordOrtho"):e._type===b?e._isPcf&&(t.webgl2||t.extStandardDerivatives||t.isWebGPU)?"       getShadowCoordPerspZbufferNormalOffset"+d:"       getShadowCoordPerspNormalOffset"+l:this._directionalShadowMapProjection(e,i,n,r,a,"getShadowCoordOrthoNormalOffset")}_getLightSourceShapeString(t){switch(t){case D:return"Rect";case C:return"Disk";case w:return"Sphere";default:return""}}generateVertexShader(t,u,f){const S=this.device,m=this.options,_=this.chunks;let v="",A="";v=this._vsAddBaseCode(v,_,m),A+="   vPositionW    = getWorldPosition();\n",this.options.pass===L&&(v+="varying float vDepth;\n",v+="#ifndef VIEWMATRIX\n",v+="#define VIEWMATRIX\n",v+="uniform mat4 matrix_view;\n",v+="#endif\n",v+="#ifndef CAMERAPLANES\n",v+="#define CAMERAPLANES\n",v+="uniform vec4 camera_params;\n\n",v+="#endif\n",A+="    vDepth = -(matrix_view * vec4(vPositionW,1.0)).z * camera_params.x;\n"),this.options.useInstancing&&(this.attributes.instance_line1=e,this.attributes.instance_line2=i,this.attributes.instance_line3=n,this.attributes.instance_line4=a,v+=_.instancingVS),this.needsNormal&&(this.attributes.vertex_normal=r,A+="   vNormalW = getNormal();\n","sphereMap"===m.reflectionSource&&S.fragmentUniformsCount<=16&&(v+=_.viewNormalVS,A+="   vNormalV    = getViewNormal();\n"),m.hasTangents&&(m.heightMapEnabled||m.normalMapEnabled||m.enableGGXSpecular)?(this.attributes.vertex_tangent=s,v+=_.tangentBinormalVS,A+="   vTangentW   = getTangent();\n",A+="   vBinormalW  = getBinormal();\n"):!m.enableGGXSpecular&&S.extStandardDerivatives||(A+="   vObjectSpaceUpW = normalize(dNormalMatrix * vec3(0, 1, 0));\n"));for(let e=0;e<2;e++)t[e]&&(this.attributes["vertex_texCoord"+e]="TEXCOORD"+e,v+=_["uv"+e+"VS"],A+="   vec2 uv"+e+" = getUv"+e+"();\n"),u[e]&&(A+="   vUv"+e+" = uv"+e+";\n");const P=[v,this.varyings,A,[]];f.forEach((t=>{this._setMapTransform(P,t.name,t.id,t.uv)})),v=P[0],this.varyings=P[1],A=P[2],m.vertexColors&&(this.attributes.vertex_color=d,A+="   vVertexColor = vertex_color;\n"),m.useMsdf&&m.msdfTextAttribute&&(this.attributes.vertex_outlineParameters=o,this.attributes.vertex_shadowParameters=l,A+="    unpackMsdfParams();\n",v+=_.msdfVS),(m.useMorphPosition||m.useMorphNormal)&&(m.useMorphTextureBased?(v+="#define MORPHING_TEXTURE_BASED\n",m.useMorphPosition&&(v+="#define MORPHING_TEXTURE_BASED_POSITION\n"),m.useMorphNormal&&(v+="#define MORPHING_TEXTURE_BASED_NORMAL\n"),this.attributes.morph_vertex_id=a,v+="attribute float morph_vertex_id;\n"):(v+="#define MORPHING\n",m.useMorphPosition?(this.attributes.morph_pos0=o,this.attributes.morph_pos1=l,this.attributes.morph_pos2=p,this.attributes.morph_pos3=h,v+="#define MORPHING_POS03\n",v+="attribute vec3 morph_pos0;\n",v+="attribute vec3 morph_pos1;\n",v+="attribute vec3 morph_pos2;\n",v+="attribute vec3 morph_pos3;\n"):m.useMorphNormal&&(this.attributes.morph_nrm0=o,this.attributes.morph_nrm1=l,this.attributes.morph_nrm2=p,this.attributes.morph_nrm3=h,v+="#define MORPHING_NRM03\n",v+="attribute vec3 morph_nrm0;\n",v+="attribute vec3 morph_nrm1;\n",v+="attribute vec3 morph_nrm2;\n",v+="attribute vec3 morph_nrm3;\n"),m.useMorphNormal?(this.attributes.morph_nrm4=e,this.attributes.morph_nrm5=i,this.attributes.morph_nrm6=n,this.attributes.morph_nrm7=a,v+="#define MORPHING_NRM47\n",v+="attribute vec3 morph_nrm4;\n",v+="attribute vec3 morph_nrm5;\n",v+="attribute vec3 morph_nrm6;\n",v+="attribute vec3 morph_nrm7;\n"):(this.attributes.morph_pos4=e,this.attributes.morph_pos5=i,this.attributes.morph_pos6=n,this.attributes.morph_pos7=a,v+="#define MORPHING_POS47\n",v+="attribute vec3 morph_pos4;\n",v+="attribute vec3 morph_pos5;\n",v+="attribute vec3 morph_pos6;\n",v+="attribute vec3 morph_pos7;\n"))),m.skin?(this.attributes.vertex_boneWeights=c,this.attributes.vertex_boneIndices=g,v+=z(S,_),v+="#define SKIN\n"):m.useInstancing&&(v+="#define INSTANCING\n"),m.screenSpace&&(v+="#define SCREENSPACE\n"),m.pixelSnap&&(v+="#define PIXELSNAP\n"),v=this._vsAddTransformCode(v,S,_,m),this.needsNormal&&(v+=_.normalVS),v+="\n",v+=_.startVS,v+=A,v+=_.endVS,v+="}",Object.keys(it).forEach((t=>{v.indexOf(t)>=0&&(this.varyings+=`varying ${it[t]} ${t};\n`)}));const b=X.getPassShaderDefine(this.options.pass);this.vshader=b+this.varyings+v}_fsGetBeginCode(){let t=X.getPassShaderDefine(this.options.pass);for(let e=0;e<this.defines.length;e++)t+=`#define ${this.defines[e]}\n`;return t}_fsGetPickPassCode(){let t=this._fsGetBeginCode();return t+="uniform vec4 uColor;\n",t+=this.varyings,t+=this.frontendDecl,t+=this.frontendCode,t+=q(),t+=this.frontendFunc,t+="    gl_FragColor = uColor;\n",t+=Q(),t}_fsGetDepthPassCode(){const t=this.chunks;let e=this._fsGetBeginCode();return e+="varying float vDepth;\n",e+=this.varyings,e+=t.packDepthPS,e+=this.frontendDecl,e+=this.frontendCode,e+=q(),e+=this.frontendFunc,e+="    gl_FragColor = packFloat(vDepth);\n",e+=Q(),e}_fsGetShadowPassCode(){const t=this.device,e=this.options,i=this.chunks,n=this.varyings,a=X.toLightType(e.pass),r=X.toShadowType(e.pass);let s=this._fsGetBeginCode();!t.extStandardDerivatives||t.webgl2||t.isWebGPU||(s+="uniform vec2 polygonOffset;\n"),r===N?t.textureFloatHighPrecision?s+="#define VSM_EXPONENT 15.0\n\n":s+="#define VSM_EXPONENT 5.54\n\n":r===I&&(s+="#define VSM_EXPONENT 5.54\n\n"),a!==T&&(s+="uniform vec3 view_position;\n",s+="uniform float light_radius;\n"),s+=n,s+=this.frontendDecl,s+=this.frontendCode,r!==E||t.webgl2&&t.isWebGPU&&a!==W?r===M&&(s+="vec2 encodeFloatRG( float v ) {\n",s+="    vec2 enc = vec2(1.0, 255.0) * v;\n",s+="    enc = fract(enc);\n",s+="    enc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\n",s+="    return enc;\n",s+="}\n\n"):s+=i.packDepthPS,s+=q(),s+=this.frontendFunc;const d=r===M||r===I||r===N,o=!t.webgl2&&t.extStandardDerivatives&&!t.isWebGPU;return s+=a===W||d&&a!==T?"    float depth = min(distance(view_position, vPositionW) / light_radius, 0.99999);\n":"    float depth = gl_FragCoord.z;\n",o&&(s+="    float minValue = 2.3374370500153186e-10; //(1.0 / 255.0) / (256.0 * 256.0 * 256.0);\n",s+="    depth += polygonOffset.x * max(abs(dFdx(depth)), abs(dFdy(depth))) + minValue * polygonOffset.y;\n"),r!==E||t.webgl2&&(a!==W||e.clusteredLightingEnabled)?r===E||r===x?(s+="    gl_FragColor = vec4(1.0);\n",e.clusteredLightingEnabled&&a===W&&t.webgl2&&(s+="    gl_FragDepth = depth;\n")):s+=r===M?"    gl_FragColor = vec4(encodeFloatRG(depth), encodeFloatRG(depth*depth));\n":i.storeEVSMPS:s+="    gl_FragColor = packFloat(depth);\n",s+=Q(),s}_fsGetLitPassCode(){const t=this.device,e=this.options,i=this.chunks,n=new tt,a=new tt,r=new tt,s=new tt;!1===e.opacityFadesSpecular&&n.append("uniform float material_alphaFade;"),e.useSpecular&&(this.defines.push("LIT_SPECULAR"),this.reflections&&this.defines.push("LIT_REFLECTIONS"),e.useClearCoat&&this.defines.push("LIT_CLEARCOAT"),e.fresnelModel>0&&this.defines.push("LIT_SPECULAR_FRESNEL"),e.conserveEnergy&&this.defines.push("LIT_CONSERVE_ENERGY"),e.useSheen&&this.defines.push("LIT_SHEEN"),e.useIridescence&&this.defines.push("LIT_IRIDESCENCE"));const d=[];let o=0,l=!1,p=!1,h=!1,c=e.lights.some((function(t){return t._shape&&t._shape!==y}));e.clusteredLightingEnabled&&e.clusteredLightingAreaLightsEnabled&&(c=!0);let g="highp";t.areaLightLutFormat===u&&(n.append("#define AREA_R8_G8_B8_A8_LUTS"),g="lowp"),(c||e.clusteredLightingEnabled)&&(n.append("#define AREA_LIGHTS"),n.append(`uniform ${g} sampler2D areaLightsLutTex1;`),n.append(`uniform ${g} sampler2D areaLightsLutTex2;`));for(let i=0;i<e.lights.length;i++){const a=e.lights[i],r=a._type;if(e.clusteredLightingEnabled&&r!==T)continue;const s=c&&a._shape?a._shape:y;n.append("uniform vec3 light"+i+"_color;"),r===T?n.append("uniform vec3 light"+i+"_direction;"):(n.append("uniform vec3 light"+i+"_position;"),n.append("uniform float light"+i+"_radius;"),r===b&&(n.append("uniform vec3 light"+i+"_direction;"),n.append("uniform float light"+i+"_innerConeAngle;"),n.append("uniform float light"+i+"_outerConeAngle;"))),s!==y&&(r===T&&n.append("uniform vec3 light"+i+"_position;"),n.append("uniform vec3 light"+i+"_halfWidth;"),n.append("uniform vec3 light"+i+"_halfHeight;")),a.castShadows&&!e.noShadow&&(n.append("uniform mat4 light"+i+"_shadowMatrix;"),n.append("uniform float light"+i+"_shadowIntensity;"),r===T&&(n.append("uniform mat4 light"+i+"_shadowMatrixPalette[4];"),n.append("uniform float light"+i+"_shadowCascadeDistances[4];"),n.append("uniform float light"+i+"_shadowCascadeCount;")),r!==T?n.append("uniform vec4 light"+i+"_shadowParams;"):(l=!0,n.append("uniform vec3 light"+i+"_shadowParams;")),r===W?n.append("uniform samplerCube light"+i+"_shadowMap;"):a._isPcf&&t.supportsDepthShadow?n.append("uniform sampler2DShadow light"+i+"_shadowMap;"):n.append("uniform sampler2D light"+i+"_shadowMap;"),o++,d[a._shadowType]=!0,a._isVsm&&(p=!0),a._isPcf&&(t.supportsDepthShadow||t.extStandardDerivatives)&&r===b&&(h=!0)),a._cookie&&(a._cookie._cubemap?r===W&&(n.append("uniform samplerCube light"+i+"_cookie;"),n.append("uniform float light"+i+"_cookieIntensity;"),a.castShadows&&!e.noShadow||n.append("uniform mat4 light"+i+"_shadowMatrix;")):r===b&&(n.append("uniform sampler2D light"+i+"_cookie;"),n.append("uniform float light"+i+"_cookieIntensity;"),a.castShadows&&!e.noShadow||n.append("uniform mat4 light"+i+"_shadowMatrix;"),a._cookieTransform&&(n.append("uniform vec4 light"+i+"_cookieMatrix;"),n.append("uniform vec2 light"+i+"_cookieOffset;"))))}const f=this.needsNormal&&(e.normalMapEnabled||e.clearCoatNormalMapEnabled||e.enableGGXSpecular&&!e.heightMapEnabled);f&&(e.hasTangents?a.append(e.fastTbn?i.TBNfastPS:i.TBNPS):t.extStandardDerivatives&&(e.normalMapEnabled||e.clearCoatNormalMapEnabled)?a.append(i.TBNderivativePS.replace(/\$UV/g,this.lightingUv)):a.append(i.TBNObjectSpacePS)),a.append(i.sphericalPS),a.append(i.decodePS),a.append(Y(e.gamma,i)),a.append(Z(e.toneMap,i)),a.append(K(e.fog,i)),a.append(this.frontendCode),e.useCubeMapRotation&&n.append("#define CUBEMAP_ROTATION"),this.needsNormal&&(a.append(i.cubeMapRotatePS),a.append(e.cubeMapProjection>0?i.cubeMapProjectBoxPS:i.cubeMapProjectNonePS),a.append(e.skyboxIntensity?i.envMultiplyPS:i.envConstPS)),(this.lighting&&e.useSpecular||this.reflections)&&(e.useMetalness&&a.append(i.metalnessModulatePS),e.fresnelModel===F&&a.append(i.fresnelSchlickPS),e.useIridescence&&a.append(i.iridescenceDiffractionPS));const S=e.aoMapEnabled||e.useAoVertexColors;if(S)switch(a.append(i.aoDiffuseOccPS),e.occludeSpecular){case V:a.append(e.occludeSpecularFloat?i.aoSpecOccSimplePS:i.aoSpecOccConstSimplePS);break;case R:a.append(e.occludeSpecularFloat?i.aoSpecOccPS:i.aoSpecOccConstPS)}if("envAtlasHQ"===e.reflectionSource)a.append(e.fixSeams?i.fixCubemapSeamsStretchPS:i.fixCubemapSeamsNonePS),a.append(i.envAtlasPS),a.append(i.reflectionEnvHQPS.replace(/\$DECODE/g,v.decodeFunc(e.reflectionEncoding)));else if("envAtlas"===e.reflectionSource)a.append(i.envAtlasPS),a.append(i.reflectionEnvPS.replace(/\$DECODE/g,v.decodeFunc(e.reflectionEncoding)));else if("cubeMap"===e.reflectionSource)a.append(e.fixSeams?i.fixCubemapSeamsStretchPS:i.fixCubemapSeamsNonePS),a.append(i.reflectionCubePS.replace(/\$DECODE/g,v.decodeFunc(e.reflectionEncoding)));else if("sphereMap"===e.reflectionSource){const n=t.fragmentUniformsCount>16?i.reflectionSpherePS:i.reflectionSphereLowPS;a.append(n.replace(/\$DECODE/g,v.decodeFunc(e.reflectionEncoding)))}this.reflections&&(e.useClearCoat&&a.append(i.reflectionCCPS),e.useSheen&&a.append(i.reflectionSheenPS)),e.useRefraction&&(e.useDynamicRefraction?a.append(i.refractionDynamicPS):this.reflections&&a.append(i.refractionCubePS)),e.useSheen&&a.append(i.lightSheenPS),e.clusteredLightingEnabled&&(a.append(i.clusteredLightUtilsPS),e.clusteredLightingCookiesEnabled&&a.append(i.clusteredLightCookiesPS),e.clusteredLightingShadowsEnabled&&!e.noShadow&&(d[E]=!0,d[x]=!0),h=!0),(o>0||e.clusteredLightingEnabled)&&(l&&a.append(i.shadowCascadesPS),d[E]&&a.append(i.shadowStandardPS),d[x]&&(t.webgl2||t.isWebGPU)&&a.append(i.shadowStandardGL2PS),p&&(a.append(i.shadowVSM_commonPS),d[M]&&a.append(i.shadowVSM8PS),d[I]&&a.append(t.extTextureHalfFloatLinear?i.shadowEVSMPS.replace(/\$/g,"16"):i.shadowEVSMnPS.replace(/\$/g,"16")),d[N]&&a.append(t.extTextureFloatLinear?i.shadowEVSMPS.replace(/\$/g,"32"):i.shadowEVSMnPS.replace(/\$/g,"32"))),t.webgl2||t.extStandardDerivatives||t.isWebGPU||a.append(i.biasConstPS),a.append(i.shadowCoordPS+i.shadowCommonPS),h&&a.append(i.shadowCoordPerspZbufferPS)),e.enableGGXSpecular&&a.append("uniform float material_anisotropy;"),this.lighting&&(a.append(i.lightDiffuseLambertPS),(c||e.clusteredLightingAreaLightsEnabled)&&a.append(i.ltcPS));let m=!1;e.useSpecular&&(this.lighting&&a.append(e.shadingModel===$?i.lightSpecularPhongPS:e.enableGGXSpecular?i.lightSpecularAnisoGGXPS:i.lightSpecularBlinnPS),e.fresnelModel||this.reflections||e.diffuseMapEnabled||(n.append("uniform vec3 material_ambient;"),n.append("#define LIT_OLD_AMBIENT"),m=!0)),a.append(i.combinePS),(e.lightMapEnabled||e.useLightMapVertexColors)&&a.append(e.useSpecular&&e.dirLightMapEnabled?i.lightmapDirAddPS:i.lightmapAddPS);const _=!e.lightMapEnabled&&!e.useLightMapVertexColors||e.lightMapWithoutAmbient;_&&("ambientSH"===e.ambientSource?a.append(i.ambientSHPS):"envAtlas"===e.ambientSource?("envAtlas"!==e.reflectionSource&&"envAtlasHQ"!==e.reflectionSource&&a.append(i.envAtlasPS),a.append(i.ambientEnvPS.replace(/\$DECODE/g,v.decodeFunc(e.ambientEncoding)))):a.append(i.ambientConstantPS)),e.useAmbientTint&&!m&&n.append("uniform vec3 material_ambient;"),e.useMsdf&&(e.msdfTextAttribute||n.append("#define UNIFORM_TEXT_PARAMETERS"),a.append(i.msdfPS)),this.needsNormal&&(a.append(i.viewDirPS),e.useSpecular&&a.append(e.enableGGXSpecular?i.reflDirAnisoPS:i.reflDirPS));let A,P=!1,w=!1,C=!1,D=!1,L=!1;if(e.clusteredLightingEnabled&&this.lighting&&(D=!0,P=!0,w=!0,L=!0,a.append(i.floatUnpackingPS),e.lightMaskDynamic&&n.append("#define CLUSTER_MESH_DYNAMIC_LIGHTS"),e.clusteredLightingCookiesEnabled&&n.append("#define CLUSTER_COOKIES"),e.clusteredLightingShadowsEnabled&&!e.noShadow&&(n.append("#define CLUSTER_SHADOWS"),n.append("#define CLUSTER_SHADOW_TYPE_"+k[e.clusteredLightingShadowType])),e.clusteredLightingAreaLightsEnabled&&n.append("#define CLUSTER_AREALIGHTS"),n.append(j.shaderDefines),e.clusteredLightingShadowsEnabled&&!e.noShadow&&a.append(i.clusteredLightShadowsPS),a.append(i.clusteredLightPS)),e.twoSidedLighting&&n.append("uniform float twoSidedLightingNegScaleFactor;"),s.append(this._fsGetStartCode(s,t,i,e)),this.needsNormal&&(e.twoSidedLighting?s.append("    dVertexNormalW = normalize(gl_FrontFacing ? vNormalW * twoSidedLightingNegScaleFactor : -vNormalW * twoSidedLightingNegScaleFactor);"):s.append("    dVertexNormalW = normalize(vNormalW);"),(e.heightMapEnabled||e.normalMapEnabled)&&e.hasTangents&&(e.twoSidedLighting?(s.append("    dTangentW = gl_FrontFacing ? vTangentW * twoSidedLightingNegScaleFactor : -vTangentW * twoSidedLightingNegScaleFactor;"),s.append("    dBinormalW = gl_FrontFacing ? vBinormalW * twoSidedLightingNegScaleFactor : -vBinormalW * twoSidedLightingNegScaleFactor;")):(s.append("    dTangentW = vTangentW;"),s.append("    dBinormalW = vBinormalW;"))),s.append("    getViewDir();"),f&&s.append("    getTBN(dTangentW, dBinormalW, dVertexNormalW);")),s.append(this.frontendFunc),this.needsNormal&&(e.useSpecular&&r.append("    getReflDir(litShaderArgs.worldNormal, dViewDirW, litShaderArgs.gloss, dTBN);"),e.useClearCoat&&r.append("    ccReflDirW = normalize(-reflect(dViewDirW, litShaderArgs.clearcoat.worldNormal));")),(this.lighting&&e.useSpecular||this.reflections)&&(e.useMetalness&&r.append("    getMetalnessModulate(litShaderArgs);"),e.useIridescence&&r.append("    vec3 iridescenceFresnel = getIridescence(saturate(dot(dViewDirW, litShaderArgs.worldNormal)), litShaderArgs.specularity, litShaderArgs.iridescence);")),_&&(r.append("    addAmbient(litShaderArgs.worldNormal);"),e.conserveEnergy&&e.useSpecular&&r.append("   dDiffuseLight = dDiffuseLight * (1.0 - litShaderArgs.specularity);"),e.separateAmbient&&r.append("\n\t\t\t\t\t\t\t\t\t\tvec3 dAmbientLight = dDiffuseLight;\n\t\t\t\t\t\t\t\t\t\tdDiffuseLight = vec3(0);\n\t\t\t\t\t\t\t\t")),e.useAmbientTint&&!m&&r.append("    dDiffuseLight *= material_ambient;"),S&&!e.occludeDirect&&r.append("    occludeDiffuse(litShaderArgs.ao);"),(e.lightMapEnabled||e.useLightMapVertexColors)&&r.append("    addLightMap(\n\t\t\t\t\t\t\t\tlitShaderArgs.lightmap, \n\t\t\t\t\t\t\t\tlitShaderArgs.lightmapDir, \n\t\t\t\t\t\t\t\tlitShaderArgs.worldNormal, \n\t\t\t\t\t\t\t\tdViewDirW, \n\t\t\t\t\t\t\t\tdReflDirW, \n\t\t\t\t\t\t\t\tlitShaderArgs.gloss, \n\t\t\t\t\t\t\t\tlitShaderArgs.specularity, \n\t\t\t\t\t\t\t\tdVertexNormalW,\n\t\t\t\t\t\t\t\tdTBN\n\t\t\t\t\t\t#if defined(LIT_IRIDESCENCE)\n\t\t\t\t\t\t\t\t, iridescenceFresnel,\n\t\t\t\t\t\t\t\tlitShaderArgs.iridescence\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\t\t);"),this.lighting||this.reflections){this.reflections&&(e.useClearCoat&&(r.append("    addReflectionCC(ccReflDirW, litShaderArgs.clearcoat.gloss);"),e.fresnelModel>0?(r.append("    ccFresnel = getFresnelCC(dot(dViewDirW, litShaderArgs.clearcoat.worldNormal));"),r.append("    ccReflection.rgb *= ccFresnel;")):r.append("    ccFresnel = 0.0;")),e.useSpecularityFactor&&r.append("    ccReflection.rgb *= litShaderArgs.specularityFactor;"),e.useSheen&&r.append("    addReflectionSheen(litShaderArgs.worldNormal, dViewDirW, litShaderArgs.sheen.gloss);"),r.append("    addReflection(dReflDirW, litShaderArgs.gloss);"),e.fresnelModel>0?r.append("    dReflection.rgb *= \n\t\t\t\t\t\t\t\t\t\t\t\tgetFresnel(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdot(dViewDirW, litShaderArgs.worldNormal), \n\t\t\t\t\t\t\t\t\t\t\t\t\t\tlitShaderArgs.gloss, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\tlitShaderArgs.specularity\n\t\t\t\t\t\t\t\t\t\t\t\t#if defined(LIT_IRIDESCENCE)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t, iridescenceFresnel,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tlitShaderArgs.iridescence\n\t\t\t\t\t\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t);"):r.append("    dReflection.rgb *= litShaderArgs.specularity;"),e.useSpecularityFactor&&r.append("    dReflection.rgb *= litShaderArgs.specularityFactor;")),c&&(r.append("    dSpecularLight *= litShaderArgs.specularity;"),e.useSpecular&&r.append("    calcLTCLightValues(litShaderArgs.gloss, litShaderArgs.worldNormal, dViewDirW, litShaderArgs.specularity, litShaderArgs.clearcoat.gloss, litShaderArgs.clearcoat.worldNormal, litShaderArgs.clearcoat.specularity);"));for(let i=0;i<e.lights.length;i++){const n=e.lights[i],a=n._type;if(e.clusteredLightingEnabled&&a!==T)continue;A=!1;const s=c&&n._shape?n.shape:y,d=c&&n._shape?this._getLightSourceShapeString(s):"";if(s!==y&&r.append("    calc"+d+"LightValues(light"+i+"_position, light"+i+"_halfWidth, light"+i+"_halfHeight);"),a===T?(r.append("    dLightDirNormW = light"+i+"_direction;"),r.append("    dAtten = 1.0;")):(n._cookie&&(a!==b||n._cookie._cubemap?a===W&&n._cookie._cubemap&&(L=!0,A=!0):(L=!0,A=!0)),r.append("    getLightDirPoint(light"+i+"_position);"),P=!0,A&&(a===b?r.append("    dAtten3 = getCookie2D"+(n._cookieFalloff?"":"Clip")+(n._cookieTransform?"Xform":"")+"(light"+i+"_cookie, light"+i+"_shadowMatrix, light"+i+"_cookieIntensity"+(n._cookieTransform?", light"+i+"_cookieMatrix, light"+i+"_cookieOffset":"")+")."+n._cookieChannel+";"):r.append("    dAtten3 = getCookieCube(light"+i+"_cookie, light"+i+"_shadowMatrix, light"+i+"_cookieIntensity)."+n._cookieChannel+";")),s===y?n._falloffMode===O?(r.append("    dAtten = getFalloffLinear(light"+i+"_radius, dLightDirW);"),w=!0):(r.append("    dAtten = getFalloffInvSquared(light"+i+"_radius, dLightDirW);"),C=!0):(r.append("    dAtten = getFalloffWindow(light"+i+"_radius, dLightDirW);"),C=!0),r.append("    if (dAtten > 0.00001) {"),a===b&&(A&&!n._cookieFalloff||(r.append("    dAtten *= getSpotEffect(light"+i+"_direction, light"+i+"_innerConeAngle, light"+i+"_outerConeAngle, dLightDirNormW);"),D=!0))),s!==y?a===T?r.append("    dAttenD = getLightDiffuse(litShaderArgs.worldNormal, dViewDirW, dLightDirW, dLightDirNormW);"):r.append("    dAttenD = get"+d+"LightDiffuse(litShaderArgs.worldNormal, dViewDirW, dLightDirW, dLightDirNormW) * 16.0;"):r.append("    dAtten *= getLightDiffuse(litShaderArgs.worldNormal, dViewDirW, dLightDirW, dLightDirNormW);"),n.castShadows&&!e.noShadow){let s,d=null;if(n._shadowType===M?(d="VSM8",s="0.0"):n._shadowType===I?(d="VSM16",s="5.54"):n._shadowType===N?(d="VSM32",s=t.textureFloatHighPrecision?"15.0":"5.54"):d=n._shadowType===x?"PCF5x5":"PCF3x3",null!==d)if(a===W){const t="(light"+i+"_shadowMap, dShadowCoord, light"+i+"_shadowParams, dLightDirW);";n._normalOffsetBias&&r.append("    normalOffsetPointShadow(light"+i+"_shadowParams, dLightPosW, dLightDirW, dLightDirNormW, dVertexNormalW);"),r.append(`    float shadow${i} = getShadowPoint${d}${t}`),r.append(`    dAtten *= mix(1.0, shadow${i}, light${i}_shadowIntensity);`)}else{const o=`light${i}_shadowMatrix`,l=`light${i}_shadowParams`;r.append(this._nonPointShadowMapProjection(t,e.lights[i],o,l,i)),a===b&&(d="Spot"+d),r.append(`    float shadow${i} = getShadow${d}(SHADOWMAP_PASS(light${i}_shadowMap), dShadowCoord, light${i}_shadowParams${n._isVsm?", "+s+", dLightDirW":""});`),r.append(`    dAtten *= mix(1.0, shadow${i}, light${i}_shadowIntensity);`)}}if(s!==y?e.conserveEnergy&&e.useSpecular?r.append("    dDiffuseLight += ((dAttenD * dAtten) * light"+i+"_color"+(A?" * dAtten3":"")+") * (1.0 - dLTCSpecFres);"):r.append("    dDiffuseLight += (dAttenD * dAtten) * light"+i+"_color"+(A?" * dAtten3":"")+";"):c&&e.conserveEnergy&&e.useSpecular?r.append("    dDiffuseLight += (dAtten * light"+i+"_color"+(A?" * dAtten3":"")+") * (1.0 - litShaderArgs.specularity);"):r.append("    dDiffuseLight += dAtten * light"+i+"_color"+(A?" * dAtten3":"")+";"),e.useSpecular&&r.append("    dHalfDirW = normalize(-dLightDirNormW + dViewDirW);"),s!==y)e.useClearCoat&&r.append(`    ccSpecularLight += ccLTCSpecFres * get${d}LightSpecular(litShaderArgs.clearcoat.worldNormal, dViewDirW) * dAtten * light${i}_color`+(A?" * dAtten3":"")+";"),e.useSpecular&&r.append(`    dSpecularLight += dLTCSpecFres * get${d}LightSpecular(litShaderArgs.worldNormal, dViewDirW) * dAtten * light${i}_color`+(A?" * dAtten3":"")+";");else{var H=!1;a===T&&e.fresnelModel>0&&(H=!0),e.useClearCoat&&r.append(`    ccSpecularLight += getLightSpecular(dHalfDirW, ccReflDirW, litShaderArgs.clearcoat.worldNormal, dViewDirW, dLightDirNormW, litShaderArgs.clearcoat.gloss, dTBN) * dAtten * light${i}_color`+(A?" * dAtten3":"")+(H?" * getFresnelCC(dot(dViewDirW, dHalfDirW));":";")),e.useSheen&&r.append(`    sSpecularLight += getLightSpecularSheen(dHalfDirW, litShaderArgs.worldNormal, dViewDirW, dLightDirNormW, litShaderArgs.sheen.gloss) * dAtten * light${i}_color`+(A?" * dAtten3;":";")),e.useSpecular&&r.append(`    dSpecularLight += getLightSpecular(dHalfDirW, dReflDirW, litShaderArgs.worldNormal, dViewDirW, dLightDirNormW, litShaderArgs.gloss, dTBN) * dAtten * light${i}_color`+(A?" * dAtten3":"")+(H?" \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t* getFresnel(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdot(dViewDirW, dHalfDirW), \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlitShaderArgs.gloss, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlitShaderArgs.specularity\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#if defined(LIT_IRIDESCENCE)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t, iridescenceFresnel, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlitShaderArgs.iridescence\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t);":"* litShaderArgs.specularity;"))}a!==T&&r.append("    }")}e.clusteredLightingEnabled&&this.lighting&&(w=!0,C=!0,P=!0,r.append("    addClusteredLights(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlitShaderArgs.worldNormal, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdViewDirW, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdReflDirW,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#if defined(LIT_CLEARCOAT)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tccReflDirW,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlitShaderArgs.gloss, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlitShaderArgs.specularity, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdVertexNormalW, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdTBN, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#if defined(LIT_IRIDESCENCE)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiridescenceFresnel,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlitShaderArgs.clearcoat, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlitShaderArgs.sheen, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlitShaderArgs.iridescence\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t);")),c&&(e.useClearCoat&&r.append("    litShaderArgs.clearcoat.specularity = 1.0;"),e.useSpecular&&r.append("    litShaderArgs.specularity = vec3(1);")),e.useRefraction&&r.append("    addRefraction(\n\t\t\t\t\t\t\t\t\t\t\t\tlitShaderArgs.worldNormal, \n\t\t\t\t\t\t\t\t\t\t\t\tdViewDirW, \n\t\t\t\t\t\t\t\t\t\t\t\tlitShaderArgs.thickness, \n\t\t\t\t\t\t\t\t\t\t\t\tlitShaderArgs.gloss, \n\t\t\t\t\t\t\t\t\t\t\t\tlitShaderArgs.specularity, \n\t\t\t\t\t\t\t\t\t\t\t\tlitShaderArgs.albedo, \n\t\t\t\t\t\t\t\t\t\t\t\tlitShaderArgs.transmission\n\t\t\t\t\t\t\t\t\t\t#if defined(LIT_IRIDESCENCE)\n\t\t\t\t\t\t\t\t\t\t\t\t, iridescenceFresnel, \n\t\t\t\t\t\t\t\t\t\t\t\tlitShaderArgs.iridescence\n\t\t\t\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\t\t\t\t);")}S&&(e.occludeDirect&&r.append("    occludeDiffuse(litShaderArgs.ao);"),e.occludeSpecular!==V&&e.occludeSpecular!==R||r.append("    occludeSpecular(litShaderArgs.gloss, litShaderArgs.ao, litShaderArgs.worldNormal, dViewDirW);")),e.useSpecularityFactor&&r.append("    dSpecularLight *= litShaderArgs.specularityFactor;"),!1===e.opacityFadesSpecular&&(e.blendType!==G&&e.blendType!==B||(r.append("float specLum = dot((dSpecularLight + dReflection.rgb * dReflection.a), vec3( 0.2126, 0.7152, 0.0722 ));"),r.append("#ifdef LIT_CLEARCOAT\n specLum += dot(ccSpecularLight * litShaderArgs.clearcoat.specularity + ccReflection.rgb * litShaderArgs.clearcoat.specularity, vec3( 0.2126, 0.7152, 0.0722 ));\n#endif"),r.append("litShaderArgs.opacity = clamp(litShaderArgs.opacity + gammaCorrectInput(specLum), 0.0, 1.0);")),r.append("litShaderArgs.opacity *= material_alphaFade;")),r.append(i.endPS),e.blendType===G||e.blendType===U||e.alphaToCoverage?r.append(i.outputAlphaPS):e.blendType===B?r.append(i.outputAlphaPremulPS):r.append(i.outputAlphaOpaquePS),e.useMsdf&&r.append("    gl_FragColor = applyMsdf(gl_FragColor);"),P&&a.prepend(i.lightDirPointPS),w&&a.prepend(i.falloffLinearPS),C&&a.prepend(i.falloffInvSquaredPS),D&&a.prepend(i.spotPS),L&&!e.clusteredLightingEnabled&&a.prepend(i.cookiePS);let X="";const z=`void evaluateBackend(LitShaderArguments litShaderArgs) {\n${r.code}\n}`;a.append(z),s.append("    evaluateBackend(litShaderArgs);"),s.append(Q());const q=n.code+a.code+s.code;q.includes("dTBN")&&(X+="mat3 dTBN;\n"),q.includes("dVertexNormalW")&&(X+="vec3 dVertexNormalW;\n"),q.includes("dTangentW")&&(X+="vec3 dTangentW;\n"),q.includes("dBinormalW")&&(X+="vec3 dBinormalW;\n"),q.includes("dViewDirW")&&(X+="vec3 dViewDirW;\n"),q.includes("dReflDirW")&&(X+="vec3 dReflDirW;\n"),q.includes("dHalfDirW")&&(X+="vec3 dHalfDirW;\n"),q.includes("ccReflDirW")&&(X+="vec3 ccReflDirW;\n"),q.includes("dLightDirNormW")&&(X+="vec3 dLightDirNormW;\n"),q.includes("dLightDirW")&&(X+="vec3 dLightDirW;\n"),q.includes("dLightPosW")&&(X+="vec3 dLightPosW;\n"),q.includes("dShadowCoord")&&(X+="vec3 dShadowCoord;\n"),q.includes("dReflection")&&(X+="vec4 dReflection;\n"),q.includes("dDiffuseLight")&&(X+="vec3 dDiffuseLight;\n"),q.includes("dSpecularLight")&&(X+="vec3 dSpecularLight;\n"),q.includes("dAtten")&&(X+="float dAtten;\n"),q.includes("dAttenD")&&(X+="float dAttenD;\n"),q.includes("dAtten3")&&(X+="vec3 dAtten3;\n"),q.includes("dMsdf")&&(X+="vec4 dMsdf;\n"),q.includes("ccFresnel")&&(X+="float ccFresnel;\n"),q.includes("ccReflection")&&(X+="vec3 ccReflection;\n"),q.includes("ccSpecularLight")&&(X+="vec3 ccSpecularLight;\n"),q.includes("ccSpecularityNoFres")&&(X+="float ccSpecularityNoFres;\n"),q.includes("sSpecularLight")&&(X+="vec3 sSpecularLight;\n"),q.includes("sReflection")&&(X+="vec3 sReflection;\n");return this._fsGetBeginCode()+this.varyings+this._fsGetBaseCode()+(e.detailModes?i.detailModesPS:"")+X+this.frontendDecl+q}generateFragmentShader(t,e,i,n){const a=this.options;this.frontendDecl=t,this.frontendCode=e,this.frontendFunc=i,this.lightingUv=n,a.pass===H?this.fshader=this._fsGetPickPassCode():a.pass===L?this.fshader=this._fsGetDepthPassCode():this.shadowPass?this.fshader=this._fsGetShadowPassCode():a.customFragmentShader?this.fshader=this._fsGetBeginCode()+a.customFragmentShader:this.fshader=this._fsGetLitPassCode()}getDefinition(){const t=J.createDefinition(this.device,{name:"LitShader",attributes:this.attributes,vertexCode:this.vshader,fragmentCode:this.fshader});return X.isForward(this.options.pass)&&(t.tag=f),t}}export{nt as LitShader};
