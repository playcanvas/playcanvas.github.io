/**
 * @license
 * PlayCanvas Engine v1.62.0 revision 818511d2b (DEBUG PROFILER)
 * Copyright 2011-2023 PlayCanvas Ltd. All rights reserved.
 */
/**
 * Used to set the anim state graph transition interruption source to no state.
 *
 * @type {string}
 */
const ANIM_INTERRUPTION_NONE = 'NONE';

/**
 * Used to set the anim state graph transition interruption source as the previous state only.
 *
 * @type {string}
 */
const ANIM_INTERRUPTION_PREV = 'PREV_STATE';

/**
 * Used to set the anim state graph transition interruption source as the next state only.
 *
 * @type {string}
 */
const ANIM_INTERRUPTION_NEXT = 'NEXT_STATE';

/**
 * Used to set the anim state graph transition interruption sources as the previous state followed
 * by the next state.
 *
 * @type {string}
 */
const ANIM_INTERRUPTION_PREV_NEXT = 'PREV_STATE_NEXT_STATE';

/**
 * Used to set the anim state graph transition interruption sources as the next state followed by
 * the previous state.
 *
 * @type {string}
 */
const ANIM_INTERRUPTION_NEXT_PREV = 'NEXT_STATE_PREV_STATE';

/**
 * Used to set an anim state graph transition condition predicate as '>'.
 *
 * @type {string}
 */
const ANIM_GREATER_THAN = 'GREATER_THAN';

/**
 * Used to set an anim state graph transition condition predicate as '<'.
 *
 * @type {string}
 */
const ANIM_LESS_THAN = 'LESS_THAN';

/**
 * Used to set an anim state graph transition condition predicate as '>='.
 *
 * @type {string}
 */
const ANIM_GREATER_THAN_EQUAL_TO = 'GREATER_THAN_EQUAL_TO';

/**
 * Used to set an anim state graph transition condition predicate as '<='.
 *
 * @type {string}
 */
const ANIM_LESS_THAN_EQUAL_TO = 'LESS_THAN_EQUAL_TO';

/**
 * Used to set an anim state graph transition condition predicate as '==='.
 *
 * @type {string}
 */
const ANIM_EQUAL_TO = 'EQUAL_TO';

/**
 * Used to set an anim state graph transition condition predicate as '!=='.
 *
 * @type {string}
 */
const ANIM_NOT_EQUAL_TO = 'NOT_EQUAL_TO';

/**
 * Used to set an anim state graph parameter as type integer.
 *
 * @type {string}
 */
const ANIM_PARAMETER_INTEGER = 'INTEGER';

/**
 * Used to set an anim state graph parameter as type float.
 *
 * @type {string}
 */
const ANIM_PARAMETER_FLOAT = 'FLOAT';

/**
 * Used to set an anim state graph parameter as type boolean.
 *
 * @type {string}
 */
const ANIM_PARAMETER_BOOLEAN = 'BOOLEAN';

/**
 * Used to set an anim state graph parameter as type trigger.
 *
 * @type {string}
 */
const ANIM_PARAMETER_TRIGGER = 'TRIGGER';

/**
 * @type {string}
 */
const ANIM_BLEND_1D = '1D';

/**
 * @type {string}
 */
const ANIM_BLEND_2D_DIRECTIONAL = '2D_DIRECTIONAL';

/**
 * @type {string}
 */
const ANIM_BLEND_2D_CARTESIAN = '2D_CARTESIAN';

/**
 * @type {string}
 */
const ANIM_BLEND_DIRECT = 'DIRECT';

/**
 * The starting state in an anim state graph layer.
 *
 * @type {string}
 */
const ANIM_STATE_START = 'START';

/**
 * The ending state in an anim state graph layer.
 *
 * @type {string}
 */
const ANIM_STATE_END = 'END';

/**
 * Used to indicate any state in an anim state graph layer.
 *
 * @type {string}
 */
const ANIM_STATE_ANY = 'ANY';
const ANIM_CONTROL_STATES = [ANIM_STATE_START, ANIM_STATE_END, ANIM_STATE_ANY];

/**
 * Used to indicate that a layers animations should overwrite all previous layers.
 *
 * @type {string}
 */
const ANIM_LAYER_OVERWRITE = 'OVERWRITE';

/**
 * Used to indicate that a layers animations should blend additively with previous layers.
 *
 * @type {string}
 */
const ANIM_LAYER_ADDITIVE = 'ADDITIVE';

export { ANIM_BLEND_1D, ANIM_BLEND_2D_CARTESIAN, ANIM_BLEND_2D_DIRECTIONAL, ANIM_BLEND_DIRECT, ANIM_CONTROL_STATES, ANIM_EQUAL_TO, ANIM_GREATER_THAN, ANIM_GREATER_THAN_EQUAL_TO, ANIM_INTERRUPTION_NEXT, ANIM_INTERRUPTION_NEXT_PREV, ANIM_INTERRUPTION_NONE, ANIM_INTERRUPTION_PREV, ANIM_INTERRUPTION_PREV_NEXT, ANIM_LAYER_ADDITIVE, ANIM_LAYER_OVERWRITE, ANIM_LESS_THAN, ANIM_LESS_THAN_EQUAL_TO, ANIM_NOT_EQUAL_TO, ANIM_PARAMETER_BOOLEAN, ANIM_PARAMETER_FLOAT, ANIM_PARAMETER_INTEGER, ANIM_PARAMETER_TRIGGER, ANIM_STATE_ANY, ANIM_STATE_END, ANIM_STATE_START };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29uc3RhbnRzLmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvZnJhbWV3b3JrL2FuaW0vY29udHJvbGxlci9jb25zdGFudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBVc2VkIHRvIHNldCB0aGUgYW5pbSBzdGF0ZSBncmFwaCB0cmFuc2l0aW9uIGludGVycnVwdGlvbiBzb3VyY2UgdG8gbm8gc3RhdGUuXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IEFOSU1fSU5URVJSVVBUSU9OX05PTkUgPSAnTk9ORSc7XG5cbi8qKlxuICogVXNlZCB0byBzZXQgdGhlIGFuaW0gc3RhdGUgZ3JhcGggdHJhbnNpdGlvbiBpbnRlcnJ1cHRpb24gc291cmNlIGFzIHRoZSBwcmV2aW91cyBzdGF0ZSBvbmx5LlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBBTklNX0lOVEVSUlVQVElPTl9QUkVWID0gJ1BSRVZfU1RBVEUnO1xuXG4vKipcbiAqIFVzZWQgdG8gc2V0IHRoZSBhbmltIHN0YXRlIGdyYXBoIHRyYW5zaXRpb24gaW50ZXJydXB0aW9uIHNvdXJjZSBhcyB0aGUgbmV4dCBzdGF0ZSBvbmx5LlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBBTklNX0lOVEVSUlVQVElPTl9ORVhUID0gJ05FWFRfU1RBVEUnO1xuXG4vKipcbiAqIFVzZWQgdG8gc2V0IHRoZSBhbmltIHN0YXRlIGdyYXBoIHRyYW5zaXRpb24gaW50ZXJydXB0aW9uIHNvdXJjZXMgYXMgdGhlIHByZXZpb3VzIHN0YXRlIGZvbGxvd2VkXG4gKiBieSB0aGUgbmV4dCBzdGF0ZS5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgQU5JTV9JTlRFUlJVUFRJT05fUFJFVl9ORVhUID0gJ1BSRVZfU1RBVEVfTkVYVF9TVEFURSc7XG5cbi8qKlxuICogVXNlZCB0byBzZXQgdGhlIGFuaW0gc3RhdGUgZ3JhcGggdHJhbnNpdGlvbiBpbnRlcnJ1cHRpb24gc291cmNlcyBhcyB0aGUgbmV4dCBzdGF0ZSBmb2xsb3dlZCBieVxuICogdGhlIHByZXZpb3VzIHN0YXRlLlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBBTklNX0lOVEVSUlVQVElPTl9ORVhUX1BSRVYgPSAnTkVYVF9TVEFURV9QUkVWX1NUQVRFJztcblxuLyoqXG4gKiBVc2VkIHRvIHNldCBhbiBhbmltIHN0YXRlIGdyYXBoIHRyYW5zaXRpb24gY29uZGl0aW9uIHByZWRpY2F0ZSBhcyAnPicuXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IEFOSU1fR1JFQVRFUl9USEFOID0gJ0dSRUFURVJfVEhBTic7XG5cbi8qKlxuICogVXNlZCB0byBzZXQgYW4gYW5pbSBzdGF0ZSBncmFwaCB0cmFuc2l0aW9uIGNvbmRpdGlvbiBwcmVkaWNhdGUgYXMgJzwnLlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBBTklNX0xFU1NfVEhBTiA9ICdMRVNTX1RIQU4nO1xuXG4vKipcbiAqIFVzZWQgdG8gc2V0IGFuIGFuaW0gc3RhdGUgZ3JhcGggdHJhbnNpdGlvbiBjb25kaXRpb24gcHJlZGljYXRlIGFzICc+PScuXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IEFOSU1fR1JFQVRFUl9USEFOX0VRVUFMX1RPID0gJ0dSRUFURVJfVEhBTl9FUVVBTF9UTyc7XG5cbi8qKlxuICogVXNlZCB0byBzZXQgYW4gYW5pbSBzdGF0ZSBncmFwaCB0cmFuc2l0aW9uIGNvbmRpdGlvbiBwcmVkaWNhdGUgYXMgJzw9Jy5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgQU5JTV9MRVNTX1RIQU5fRVFVQUxfVE8gPSAnTEVTU19USEFOX0VRVUFMX1RPJztcblxuLyoqXG4gKiBVc2VkIHRvIHNldCBhbiBhbmltIHN0YXRlIGdyYXBoIHRyYW5zaXRpb24gY29uZGl0aW9uIHByZWRpY2F0ZSBhcyAnPT09Jy5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgQU5JTV9FUVVBTF9UTyA9ICdFUVVBTF9UTyc7XG5cbi8qKlxuICogVXNlZCB0byBzZXQgYW4gYW5pbSBzdGF0ZSBncmFwaCB0cmFuc2l0aW9uIGNvbmRpdGlvbiBwcmVkaWNhdGUgYXMgJyE9PScuXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IEFOSU1fTk9UX0VRVUFMX1RPID0gJ05PVF9FUVVBTF9UTyc7XG5cbiAvKipcbiAgKiBVc2VkIHRvIHNldCBhbiBhbmltIHN0YXRlIGdyYXBoIHBhcmFtZXRlciBhcyB0eXBlIGludGVnZXIuXG4gICpcbiAgKiBAdHlwZSB7c3RyaW5nfVxuICAqL1xuZXhwb3J0IGNvbnN0IEFOSU1fUEFSQU1FVEVSX0lOVEVHRVIgPSAnSU5URUdFUic7XG5cbi8qKlxuICogVXNlZCB0byBzZXQgYW4gYW5pbSBzdGF0ZSBncmFwaCBwYXJhbWV0ZXIgYXMgdHlwZSBmbG9hdC5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgQU5JTV9QQVJBTUVURVJfRkxPQVQgPSAnRkxPQVQnO1xuXG4vKipcbiAqIFVzZWQgdG8gc2V0IGFuIGFuaW0gc3RhdGUgZ3JhcGggcGFyYW1ldGVyIGFzIHR5cGUgYm9vbGVhbi5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgQU5JTV9QQVJBTUVURVJfQk9PTEVBTiA9ICdCT09MRUFOJztcblxuLyoqXG4gKiBVc2VkIHRvIHNldCBhbiBhbmltIHN0YXRlIGdyYXBoIHBhcmFtZXRlciBhcyB0eXBlIHRyaWdnZXIuXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IEFOSU1fUEFSQU1FVEVSX1RSSUdHRVIgPSAnVFJJR0dFUic7XG5cbi8qKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IEFOSU1fQkxFTkRfMUQgPSAnMUQnO1xuXG4vKipcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBBTklNX0JMRU5EXzJEX0RJUkVDVElPTkFMID0gJzJEX0RJUkVDVElPTkFMJztcblxuLyoqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgQU5JTV9CTEVORF8yRF9DQVJURVNJQU4gPSAnMkRfQ0FSVEVTSUFOJztcblxuLyoqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgQU5JTV9CTEVORF9ESVJFQ1QgPSAnRElSRUNUJztcblxuLyoqXG4gKiBUaGUgc3RhcnRpbmcgc3RhdGUgaW4gYW4gYW5pbSBzdGF0ZSBncmFwaCBsYXllci5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgQU5JTV9TVEFURV9TVEFSVCA9ICdTVEFSVCc7XG5cbi8qKlxuICogVGhlIGVuZGluZyBzdGF0ZSBpbiBhbiBhbmltIHN0YXRlIGdyYXBoIGxheWVyLlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBBTklNX1NUQVRFX0VORCA9ICdFTkQnO1xuXG4vKipcbiAqIFVzZWQgdG8gaW5kaWNhdGUgYW55IHN0YXRlIGluIGFuIGFuaW0gc3RhdGUgZ3JhcGggbGF5ZXIuXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IEFOSU1fU1RBVEVfQU5ZID0gJ0FOWSc7XG5cbmV4cG9ydCBjb25zdCBBTklNX0NPTlRST0xfU1RBVEVTID0gW0FOSU1fU1RBVEVfU1RBUlQsIEFOSU1fU1RBVEVfRU5ELCBBTklNX1NUQVRFX0FOWV07XG5cbi8qKlxuICogVXNlZCB0byBpbmRpY2F0ZSB0aGF0IGEgbGF5ZXJzIGFuaW1hdGlvbnMgc2hvdWxkIG92ZXJ3cml0ZSBhbGwgcHJldmlvdXMgbGF5ZXJzLlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBBTklNX0xBWUVSX09WRVJXUklURSA9ICdPVkVSV1JJVEUnO1xuXG4vKipcbiAqIFVzZWQgdG8gaW5kaWNhdGUgdGhhdCBhIGxheWVycyBhbmltYXRpb25zIHNob3VsZCBibGVuZCBhZGRpdGl2ZWx5IHdpdGggcHJldmlvdXMgbGF5ZXJzLlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBBTklNX0xBWUVSX0FERElUSVZFID0gJ0FERElUSVZFJztcbiJdLCJuYW1lcyI6WyJBTklNX0lOVEVSUlVQVElPTl9OT05FIiwiQU5JTV9JTlRFUlJVUFRJT05fUFJFViIsIkFOSU1fSU5URVJSVVBUSU9OX05FWFQiLCJBTklNX0lOVEVSUlVQVElPTl9QUkVWX05FWFQiLCJBTklNX0lOVEVSUlVQVElPTl9ORVhUX1BSRVYiLCJBTklNX0dSRUFURVJfVEhBTiIsIkFOSU1fTEVTU19USEFOIiwiQU5JTV9HUkVBVEVSX1RIQU5fRVFVQUxfVE8iLCJBTklNX0xFU1NfVEhBTl9FUVVBTF9UTyIsIkFOSU1fRVFVQUxfVE8iLCJBTklNX05PVF9FUVVBTF9UTyIsIkFOSU1fUEFSQU1FVEVSX0lOVEVHRVIiLCJBTklNX1BBUkFNRVRFUl9GTE9BVCIsIkFOSU1fUEFSQU1FVEVSX0JPT0xFQU4iLCJBTklNX1BBUkFNRVRFUl9UUklHR0VSIiwiQU5JTV9CTEVORF8xRCIsIkFOSU1fQkxFTkRfMkRfRElSRUNUSU9OQUwiLCJBTklNX0JMRU5EXzJEX0NBUlRFU0lBTiIsIkFOSU1fQkxFTkRfRElSRUNUIiwiQU5JTV9TVEFURV9TVEFSVCIsIkFOSU1fU1RBVEVfRU5EIiwiQU5JTV9TVEFURV9BTlkiLCJBTklNX0NPTlRST0xfU1RBVEVTIiwiQU5JTV9MQVlFUl9PVkVSV1JJVEUiLCJBTklNX0xBWUVSX0FERElUSVZFIl0sIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxNQUFNQSxzQkFBc0IsR0FBRyxPQUFNOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sTUFBTUMsc0JBQXNCLEdBQUcsYUFBWTs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLE1BQU1DLHNCQUFzQixHQUFHLGFBQVk7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLE1BQU1DLDJCQUEyQixHQUFHLHdCQUF1Qjs7QUFFbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sTUFBTUMsMkJBQTJCLEdBQUcsd0JBQXVCOztBQUVsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sTUFBTUMsaUJBQWlCLEdBQUcsZUFBYzs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLE1BQU1DLGNBQWMsR0FBRyxZQUFXOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sTUFBTUMsMEJBQTBCLEdBQUcsd0JBQXVCOztBQUVqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sTUFBTUMsdUJBQXVCLEdBQUcscUJBQW9COztBQUUzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sTUFBTUMsYUFBYSxHQUFHLFdBQVU7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxNQUFNQyxpQkFBaUIsR0FBRyxlQUFjOztBQUU5QztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ08sTUFBTUMsc0JBQXNCLEdBQUcsVUFBUzs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLE1BQU1DLG9CQUFvQixHQUFHLFFBQU87O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxNQUFNQyxzQkFBc0IsR0FBRyxVQUFTOztBQUUvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sTUFBTUMsc0JBQXNCLEdBQUcsVUFBUzs7QUFFL0M7QUFDQTtBQUNBO0FBQ08sTUFBTUMsYUFBYSxHQUFHLEtBQUk7O0FBRWpDO0FBQ0E7QUFDQTtBQUNPLE1BQU1DLHlCQUF5QixHQUFHLGlCQUFnQjs7QUFFekQ7QUFDQTtBQUNBO0FBQ08sTUFBTUMsdUJBQXVCLEdBQUcsZUFBYzs7QUFFckQ7QUFDQTtBQUNBO0FBQ08sTUFBTUMsaUJBQWlCLEdBQUcsU0FBUTs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLE1BQU1DLGdCQUFnQixHQUFHLFFBQU87O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxNQUFNQyxjQUFjLEdBQUcsTUFBSzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLE1BQU1DLGNBQWMsR0FBRyxNQUFLO0FBRTVCLE1BQU1DLG1CQUFtQixHQUFHLENBQUNILGdCQUFnQixFQUFFQyxjQUFjLEVBQUVDLGNBQWMsRUFBQzs7QUFFckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLE1BQU1FLG9CQUFvQixHQUFHLFlBQVc7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxNQUFNQyxtQkFBbUIsR0FBRzs7OzsifQ==
