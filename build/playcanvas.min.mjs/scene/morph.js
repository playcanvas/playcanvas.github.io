import"../core/tracing.js";import{RefCountedObject as t}from"../core/ref-counted-object.js";import{Vec3 as e}from"../core/math/vec3.js";import{FloatPacking as r}from"../core/math/float-packing.js";import{BoundingBox as s}from"../core/shape/bounding-box.js";import{Texture as i}from"../platform/graphics/texture.js";import{VertexBuffer as o}from"../platform/graphics/vertex-buffer.js";import{VertexFormat as h}from"../platform/graphics/vertex-format.js";import{PIXELFORMAT_RGBA16F as a,PIXELFORMAT_RGBA32F as n,PIXELFORMAT_RGB32F as l,BUFFER_STATIC as p,FILTER_NEAREST as u,ADDRESS_CLAMP_TO_EDGE as m,SEMANTIC_ATTR15 as g,TYPE_FLOAT32 as c}from"../platform/graphics/constants.js";import{GraphicsDeviceAccess as f}from"../platform/graphics/graphics-device-access.js";const _={preferHighPrecision:!1};class x extends t{constructor(t,e,r=_){super(),this._aabb=void 0,this.preferHighPrecision=void 0,this.device=e||f.get(),this.preferHighPrecision=r.preferHighPrecision,t.forEach((t=>{})),this._targets=t.slice();const s=this.device;if(s.supportsMorphTargetTexturesCore){const t=s.extTextureHalfFloat&&s.textureHalfFloatRenderable?a:void 0,e=s.extTextureFloat&&s.textureFloatRenderable?n:void 0;this._renderTextureFormat=this.preferHighPrecision?null!=e?e:t:null!=t?t:e;const r=s.extTextureHalfFloat&&s.textureHalfFloatUpdatable?a:void 0,i=s.extTextureFloat?l:void 0;this._textureFormat=this.preferHighPrecision?null!=i?i:r:null!=r?r:i,void 0!==this._renderTextureFormat&&void 0!==this._textureFormat&&(this._useTextureMorph=!0)}this._init(),this._updateMorphFlags()}get aabb(){if(!this._aabb){const t=new e,r=new e;for(let e=0;e<this._targets.length;e++){const s=this._targets[e].aabb;t.min(s.getMin()),r.max(s.getMax())}this._aabb=new s,this._aabb.setMinMax(t,r)}return this._aabb}get morphPositions(){return this._morphPositions}get morphNormals(){return this._morphNormals}get maxActiveTargets(){return this._useTextureMorph?this._targets.length:this._morphPositions&&this._morphNormals?4:8}get useTextureMorph(){return this._useTextureMorph}_init(){if(this._useTextureMorph&&(this._useTextureMorph=this._initTextureBased()),!this._useTextureMorph)for(let t=0;t<this._targets.length;t++)this._targets[t]._initVertexBuffers(this.device);for(let t=0;t<this._targets.length;t++)this._targets[t]._postInit()}_findSparseSet(t,e,r){let s=1;const i=t[0].length;for(let o=0;o<i;o+=3){let i=!1;for(let e=0;e<t.length;e++){const r=t[e];if(0!==r[o]||0!==r[o+1]||0!==r[o+2]){i=!0;break}}i?(e.push(s+.2),r.push(o/3),s++):e.push(.2)}return s}_initTextureBased(){const t=[],e=[];for(let r=0;r<this._targets.length;r++){const s=this._targets[r];s.options.deltaPositions&&(t.push(s.options.deltaPositions),e.push({target:s,name:"texturePositions"})),s.options.deltaNormals&&(t.push(s.options.deltaNormals),e.push({target:s,name:"textureNormals"}))}const s=[],i=[],n=this._findSparseSet(t,s,i),l=Math.min(this.device.maxTextureSize,4096);let u=Math.ceil(Math.sqrt(n));u=Math.min(u,l);const m=Math.ceil(n/u);if(m>l)return!1;this.morphTextureWidth=u,this.morphTextureHeight=m;let f=!1,_=3;const x=r.float2Half;this._textureFormat===a&&(f=!0,_=4);const d=[];for(let e=0;e<t.length;e++)d.push(this._createTexture("MorphTarget",this._textureFormat));for(let r=0;r<t.length;r++){const s=t[r],o=d[r],h=o.lock();if(f)for(let t=0;t<i.length;t++){const e=3*i[t],r=t*_+_;h[r]=x(s[e]),h[r+1]=x(s[e+1]),h[r+2]=x(s[e+2])}else for(let t=0;t<i.length;t++){const e=3*i[t],r=t*_+_;h[r]=s[e],h[r+1]=s[e+1],h[r+2]=s[e+2]}o.unlock();e[r].target._setTexture(e[r].name,o)}const T=[{semantic:g,components:1,type:c}];return this.vertexBufferIds=new o(this.device,new h(this.device,T),s.length,p,new Float32Array(s)),!0}destroy(){var t;null==(t=this.vertexBufferIds)||t.destroy(),this.vertexBufferIds=null;for(let t=0;t<this._targets.length;t++)this._targets[t].destroy();this._targets.length=0}get targets(){return this._targets}_updateMorphFlags(){this._morphPositions=!1,this._morphNormals=!1;for(let t=0;t<this._targets.length;t++){const e=this._targets[t];e.morphPositions&&(this._morphPositions=!0),e.morphNormals&&(this._morphNormals=!0)}}_createTexture(t,e){return new i(this.device,{width:this.morphTextureWidth,height:this.morphTextureHeight,format:e,cubemap:!1,mipmaps:!1,minFilter:u,magFilter:u,addressU:m,addressV:m,name:t})}}export{x as Morph};
