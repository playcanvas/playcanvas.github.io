/**
 * @license
 * PlayCanvas Engine v1.62.0 revision 818511d2b (DEBUG PROFILER)
 * Copyright 2011-2023 PlayCanvas Ltd. All rights reserved.
 */
import { Debug } from '../../core/debug.js';
import { CULLFACE_BACK, BLENDMODE_ONE, BLENDEQUATION_REVERSE_SUBTRACT, BLENDMODE_ZERO, BLENDEQUATION_ADD, BLENDMODE_SRC_ALPHA, BLENDMODE_ONE_MINUS_SRC_ALPHA, BLENDMODE_DST_COLOR, BLENDMODE_SRC_COLOR, BLENDMODE_ONE_MINUS_DST_COLOR, BLENDEQUATION_MIN, BLENDEQUATION_MAX } from '../../platform/graphics/constants.js';
import { BlendState } from '../../platform/graphics/blend-state.js';
import { DepthState } from '../../platform/graphics/depth-state.js';
import { ShaderProcessorOptions } from '../../platform/graphics/shader-processor-options.js';
import { BLEND_NONE, BLEND_NORMAL, BLEND_SUBTRACTIVE, BLEND_PREMULTIPLIED, BLEND_ADDITIVE, BLEND_ADDITIVEALPHA, BLEND_MULTIPLICATIVE2X, BLEND_SCREEN, BLEND_MULTIPLICATIVE, BLEND_MIN, BLEND_MAX } from '../constants.js';
import { processShader } from '../shader-lib/utils.js';
import { getDefaultMaterial } from './default-material.js';

// blend mode mapping to op, srcBlend and dstBlend
const blendModes = [];
blendModes[BLEND_SUBTRACTIVE] = {
  src: BLENDMODE_ONE,
  dst: BLENDMODE_ONE,
  op: BLENDEQUATION_REVERSE_SUBTRACT
};
blendModes[BLEND_NONE] = {
  src: BLENDMODE_ONE,
  dst: BLENDMODE_ZERO,
  op: BLENDEQUATION_ADD
};
blendModes[BLEND_NORMAL] = {
  src: BLENDMODE_SRC_ALPHA,
  dst: BLENDMODE_ONE_MINUS_SRC_ALPHA,
  op: BLENDEQUATION_ADD
};
blendModes[BLEND_PREMULTIPLIED] = {
  src: BLENDMODE_ONE,
  dst: BLENDMODE_ONE_MINUS_SRC_ALPHA,
  op: BLENDEQUATION_ADD
};
blendModes[BLEND_ADDITIVE] = {
  src: BLENDMODE_ONE,
  dst: BLENDMODE_ONE,
  op: BLENDEQUATION_ADD
};
blendModes[BLEND_ADDITIVEALPHA] = {
  src: BLENDMODE_SRC_ALPHA,
  dst: BLENDMODE_ONE,
  op: BLENDEQUATION_ADD
};
blendModes[BLEND_MULTIPLICATIVE2X] = {
  src: BLENDMODE_DST_COLOR,
  dst: BLENDMODE_SRC_COLOR,
  op: BLENDEQUATION_ADD
};
blendModes[BLEND_SCREEN] = {
  src: BLENDMODE_ONE_MINUS_DST_COLOR,
  dst: BLENDMODE_ONE,
  op: BLENDEQUATION_ADD
};
blendModes[BLEND_MULTIPLICATIVE] = {
  src: BLENDMODE_DST_COLOR,
  dst: BLENDMODE_ZERO,
  op: BLENDEQUATION_ADD
};
blendModes[BLEND_MIN] = {
  src: BLENDMODE_ONE,
  dst: BLENDMODE_ONE,
  op: BLENDEQUATION_MIN
};
blendModes[BLEND_MAX] = {
  src: BLENDMODE_ONE,
  dst: BLENDMODE_ONE,
  op: BLENDEQUATION_MAX
};
let id = 0;

/**
 * A material determines how a particular mesh instance is rendered. It specifies the shader and
 * render state that is set before the mesh instance is submitted to the graphics device.
 */
class Material {
  constructor() {
    this._shader = null;
    this.meshInstances = [];
    this.name = 'Untitled';
    this.id = id++;
    this.variants = {};
    this.parameters = {};
    this.alphaTest = 0;
    this.alphaToCoverage = false;
    this._blendState = new BlendState();
    this._depthState = new DepthState();
    this.cull = CULLFACE_BACK;
    this.stencilFront = null;
    this.stencilBack = null;
    this.depthBias = 0;
    this.slopeDepthBias = 0;
    this._shaderVersion = 0;
    this._scene = null;
    this._dirtyBlend = false;
    this.dirty = true;
  }
  /**
   * If true, the red component of fragments generated by the shader of this material is written
   * to the color buffer of the currently active render target. If false, the red component will
   * not be written. Defaults to true.
   *
   * @type {boolean}
   */
  set redWrite(value) {
    this._blendState.redWrite = value;
  }
  get redWrite() {
    return this._blendState.redWrite;
  }

  /**
   * If true, the green component of fragments generated by the shader of this material is
   * written to the color buffer of the currently active render target. If false, the green
   * component will not be written. Defaults to true.
   *
   * @type {boolean}
   */
  set greenWrite(value) {
    this._blendState.greenWrite = value;
  }
  get greenWrite() {
    return this._blendState.greenWrite;
  }

  /**
   * If true, the blue component of fragments generated by the shader of this material is
   * written to the color buffer of the currently active render target. If false, the blue
   * component will not be written. Defaults to true.
   *
   * @type {boolean}
   */
  set blueWrite(value) {
    this._blendState.blueWrite = value;
  }
  get blueWrite() {
    return this._blendState.blueWrite;
  }

  /**
   * If true, the alpha component of fragments generated by the shader of this material is
   * written to the color buffer of the currently active render target. If false, the alpha
   * component will not be written. Defaults to true.
   *
   * @type {boolean}
   */
  set alphaWrite(value) {
    this._blendState.alphaWrite = value;
  }
  get alphaWrite() {
    return this._blendState.alphaWrite;
  }

  /**
   * The shader used by this material to render mesh instances (default is null).
   *
   * @type {import('../../platform/graphics/shader.js').Shader|null}
   */
  set shader(shader) {
    this._shader = shader;
  }
  get shader() {
    return this._shader;
  }

  // returns boolean depending on material being transparent
  get transparent() {
    return this._blendState.blend;
  }

  // called when material changes transparency, for layer composition to add it to appropriate
  // queue (opaque or transparent)
  _markBlendDirty() {
    if (this._scene) {
      this._scene.layers._dirtyBlend = true;
    } else {
      this._dirtyBlend = true;
    }
  }

  /**
   * Controls how fragment shader outputs are blended when being written to the currently active
   * render target. This overwrites blending type set using {@link pc.Material#blendType}, and
   * offers more control over blending.
   *
   * @type { BlendState }
   */
  set blendState(value) {
    if (this._blendState.blend !== value.blend) {
      this._markBlendDirty();
    }
    this._blendState.copy(value);
  }
  get blendState() {
    return this._blendState;
  }

  /**
   * Controls how fragment shader outputs are blended when being written to the currently active
   * render target. Can be:
   *
   * - {@link BLEND_SUBTRACTIVE}: Subtract the color of the source fragment from the destination
   * fragment and write the result to the frame buffer.
   * - {@link BLEND_ADDITIVE}: Add the color of the source fragment to the destination fragment
   * and write the result to the frame buffer.
   * - {@link BLEND_NORMAL}: Enable simple translucency for materials such as glass. This is
   * equivalent to enabling a source blend mode of {@link BLENDMODE_SRC_ALPHA} and a destination
   * blend mode of {@link BLENDMODE_ONE_MINUS_SRC_ALPHA}.
   * - {@link BLEND_NONE}: Disable blending.
   * - {@link BLEND_PREMULTIPLIED}: Similar to {@link BLEND_NORMAL} expect the source fragment is
   * assumed to have already been multiplied by the source alpha value.
   * - {@link BLEND_MULTIPLICATIVE}: Multiply the color of the source fragment by the color of the
   * destination fragment and write the result to the frame buffer.
   * - {@link BLEND_ADDITIVEALPHA}: Same as {@link BLEND_ADDITIVE} except the source RGB is
   * multiplied by the source alpha.
   * - {@link BLEND_MULTIPLICATIVE2X}: Multiplies colors and doubles the result.
   * - {@link BLEND_SCREEN}: Softer version of additive.
   * - {@link BLEND_MIN}: Minimum color. Check app.graphicsDevice.extBlendMinmax for support.
   * - {@link BLEND_MAX}: Maximum color. Check app.graphicsDevice.extBlendMinmax for support.
   *
   * Defaults to {@link BLEND_NONE}.
   *
   * @type {number}
   */
  set blendType(type) {
    const blendMode = blendModes[type];
    Debug.assert(blendMode, `Unknown blend mode ${type}`);
    this._blendState.setColorBlend(blendMode.op, blendMode.src, blendMode.dst);
    this._blendState.setAlphaBlend(blendMode.op, blendMode.src, blendMode.dst);
    const blend = type !== BLEND_NONE;
    if (this._blendState.blend !== blend) {
      this._blendState.blend = blend;
      this._markBlendDirty();
    }
    this._updateMeshInstanceKeys();
  }
  get blendType() {
    if (!this.transparent) {
      return BLEND_NONE;
    }
    const {
      colorOp,
      colorSrcFactor,
      colorDstFactor,
      alphaOp,
      alphaSrcFactor,
      alphaDstFactor
    } = this._blendState;
    for (let i = 0; i < blendModes.length; i++) {
      const blendMode = blendModes[i];
      if (blendMode.src === colorSrcFactor && blendMode.dst === colorDstFactor && blendMode.op === colorOp && blendMode.src === alphaSrcFactor && blendMode.dst === alphaDstFactor && blendMode.op === alphaOp) {
        return i;
      }
    }
    return BLEND_NORMAL;
  }

  /**
   * Sets the depth state. Note that this can also be done by using {@link Material#depthTest},
   * {@link Material#depthFunc} and {@link Material#depthWrite}.
   *
   * @type { DepthState }
   */
  set depthState(value) {
    this._depthState.copy(value);
  }
  get depthState() {
    return this._depthState;
  }

  /**
   * If true, fragments generated by the shader of this material are only written to the current
   * render target if they pass the depth test. If false, fragments generated by the shader of
   * this material are written to the current render target regardless of what is in the depth
   * buffer. Defaults to true.
   *
   * @type {boolean}
   */
  set depthTest(value) {
    this._depthState.test = value;
  }
  get depthTest() {
    return this._depthState.test;
  }

  /**
   * Controls how the depth of new fragments is compared against the current depth contained in
   * the depth buffer. Can be:
   *
   * - {@link FUNC_NEVER}: don't draw
   * - {@link FUNC_LESS}: draw if new depth < depth buffer
   * - {@link FUNC_EQUAL}: draw if new depth == depth buffer
   * - {@link FUNC_LESSEQUAL}: draw if new depth <= depth buffer
   * - {@link FUNC_GREATER}: draw if new depth > depth buffer
   * - {@link FUNC_NOTEQUAL}: draw if new depth != depth buffer
   * - {@link FUNC_GREATEREQUAL}: draw if new depth >= depth buffer
   * - {@link FUNC_ALWAYS}: always draw
   *
   * Defaults to {@link FUNC_LESSEQUAL}.
   *
   * @type {number}
   */
  set depthFunc(value) {
    this._depthState.func = value;
  }
  get depthFunc() {
    return this._depthState.func;
  }

  /**
   * If true, fragments generated by the shader of this material write a depth value to the depth
   * buffer of the currently active render target. If false, no depth value is written. Defaults
   * to true.
   *
   * @type {boolean}
   */
  set depthWrite(value) {
    this._depthState.write = value;
  }
  get depthWrite() {
    return this._depthState.write;
  }

  /**
   * Copy a material.
   *
   * @param {Material} source - The material to copy.
   * @returns {Material} The destination material.
   */
  copy(source) {
    this.name = source.name;
    this._shader = source._shader;

    // Render states
    this.alphaTest = source.alphaTest;
    this.alphaToCoverage = source.alphaToCoverage;
    this._blendState.copy(source._blendState);
    this._depthState.copy(source._depthState);
    this.cull = source.cull;
    this.depthBias = source.depthBias;
    this.slopeDepthBias = source.slopeDepthBias;
    if (source.stencilFront) this.stencilFront = source.stencilFront.clone();
    if (source.stencilBack) {
      if (source.stencilFront === source.stencilBack) {
        this.stencilBack = this.stencilFront;
      } else {
        this.stencilBack = source.stencilBack.clone();
      }
    }
    return this;
  }

  /**
   * Clone a material.
   *
   * @returns {this} A newly cloned material.
   */
  clone() {
    const clone = new this.constructor();
    return clone.copy(this);
  }
  _updateMeshInstanceKeys() {
    const meshInstances = this.meshInstances;
    for (let i = 0; i < meshInstances.length; i++) {
      meshInstances[i].updateKey();
    }
  }
  updateUniforms(device, scene) {}
  getShaderVariant(device, scene, objDefs, staticLightList, pass, sortedLights, viewUniformFormat, viewBindGroupFormat, vertexFormat) {
    // generate shader variant - its the same shader, but with different processing options
    const processingOptions = new ShaderProcessorOptions(viewUniformFormat, viewBindGroupFormat, vertexFormat);
    return processShader(this._shader, processingOptions);
  }

  /**
   * Applies any changes made to the material's properties.
   */
  update() {
    this.dirty = true;
    if (this._shader) this._shader.failed = false;
  }

  // Parameter management
  clearParameters() {
    this.parameters = {};
  }
  getParameters() {
    return this.parameters;
  }
  clearVariants() {
    // clear variants on the material
    this.variants = {};

    // but also clear them from all materials that reference them
    const meshInstances = this.meshInstances;
    const count = meshInstances.length;
    for (let i = 0; i < count; i++) {
      meshInstances[i].clearShaders();
    }
  }

  /**
   * Retrieves the specified shader parameter from a material.
   *
   * @param {string} name - The name of the parameter to query.
   * @returns {object} The named parameter.
   */
  getParameter(name) {
    return this.parameters[name];
  }

  /**
   * Sets a shader parameter on a material.
   *
   * @param {string} name - The name of the parameter to set.
   * @param {number|number[]|Float32Array|import('../../platform/graphics/texture.js').Texture} data -
   * The value for the specified parameter.
   */
  setParameter(name, data) {
    if (data === undefined && typeof name === 'object') {
      const uniformObject = name;
      if (uniformObject.length) {
        for (let i = 0; i < uniformObject.length; i++) {
          this.setParameter(uniformObject[i]);
        }
        return;
      }
      name = uniformObject.name;
      data = uniformObject.value;
    }
    const param = this.parameters[name];
    if (param) {
      param.data = data;
    } else {
      this.parameters[name] = {
        scopeId: null,
        data: data
      };
    }
  }

  /**
   * Deletes a shader parameter on a material.
   *
   * @param {string} name - The name of the parameter to delete.
   */
  deleteParameter(name) {
    if (this.parameters[name]) {
      delete this.parameters[name];
    }
  }

  // used to apply parameters from this material into scope of uniforms, called internally by forward-renderer
  // optional list of parameter names to be set can be specified, otherwise all parameters are set
  setParameters(device, names) {
    const parameters = this.parameters;
    if (names === undefined) names = parameters;
    for (const paramName in names) {
      const parameter = parameters[paramName];
      if (parameter) {
        if (!parameter.scopeId) {
          parameter.scopeId = device.scope.resolve(paramName);
        }
        parameter.scopeId.setValue(parameter.data);
      }
    }
  }

  /**
   * Removes this material from the scene and possibly frees up memory from its shaders (if there
   * are no other materials using it).
   */
  destroy() {
    this.variants = {};
    this._shader = null;
    for (let i = 0; i < this.meshInstances.length; i++) {
      const meshInstance = this.meshInstances[i];
      meshInstance.clearShaders();
      meshInstance._material = null;
      if (meshInstance.mesh) {
        const defaultMaterial = getDefaultMaterial(meshInstance.mesh.device);
        if (this !== defaultMaterial) {
          meshInstance.material = defaultMaterial;
        }
      } else {
        Debug.warn('pc.Material: MeshInstance.mesh is null, default material cannot be assigned to the MeshInstance');
      }
    }
    this.meshInstances.length = 0;
  }

  /**
   * Registers mesh instance as referencing the material.
   *
   * @param {import('../mesh-instance.js').MeshInstance} meshInstance - The mesh instance to
   * de-register.
   * @ignore
   */
  addMeshInstanceRef(meshInstance) {
    this.meshInstances.push(meshInstance);
  }

  /**
   * De-registers mesh instance as referencing the material.
   *
   * @param {import('../mesh-instance.js').MeshInstance} meshInstance - The mesh instance to
   * de-register.
   * @ignore
   */
  removeMeshInstanceRef(meshInstance) {
    const meshInstances = this.meshInstances;
    const i = meshInstances.indexOf(meshInstance);
    if (i !== -1) {
      meshInstances.splice(i, 1);
    }
  }
}

export { Material };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF0ZXJpYWwuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9zY2VuZS9tYXRlcmlhbHMvbWF0ZXJpYWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGVidWcgfSBmcm9tICcuLi8uLi9jb3JlL2RlYnVnLmpzJztcblxuaW1wb3J0IHtcbiAgICBCTEVORE1PREVfWkVSTywgQkxFTkRNT0RFX09ORSwgQkxFTkRNT0RFX1NSQ19DT0xPUixcbiAgICBCTEVORE1PREVfRFNUX0NPTE9SLCBCTEVORE1PREVfT05FX01JTlVTX0RTVF9DT0xPUiwgQkxFTkRNT0RFX1NSQ19BTFBIQSxcbiAgICBCTEVORE1PREVfT05FX01JTlVTX1NSQ19BTFBIQSxcbiAgICBCTEVOREVRVUFUSU9OX0FERCwgQkxFTkRFUVVBVElPTl9SRVZFUlNFX1NVQlRSQUNULFxuICAgIEJMRU5ERVFVQVRJT05fTUlOLCBCTEVOREVRVUFUSU9OX01BWCxcbiAgICBDVUxMRkFDRV9CQUNLXG59IGZyb20gJy4uLy4uL3BsYXRmb3JtL2dyYXBoaWNzL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBCbGVuZFN0YXRlIH0gZnJvbSAnLi4vLi4vcGxhdGZvcm0vZ3JhcGhpY3MvYmxlbmQtc3RhdGUuanMnO1xuaW1wb3J0IHsgRGVwdGhTdGF0ZSB9IGZyb20gJy4uLy4uL3BsYXRmb3JtL2dyYXBoaWNzL2RlcHRoLXN0YXRlLmpzJztcbmltcG9ydCB7IFNoYWRlclByb2Nlc3Nvck9wdGlvbnMgfSBmcm9tICcuLi8uLi9wbGF0Zm9ybS9ncmFwaGljcy9zaGFkZXItcHJvY2Vzc29yLW9wdGlvbnMuanMnO1xuXG5pbXBvcnQge1xuICAgIEJMRU5EX0FERElUSVZFLCBCTEVORF9OT1JNQUwsIEJMRU5EX05PTkUsIEJMRU5EX1BSRU1VTFRJUExJRUQsXG4gICAgQkxFTkRfTVVMVElQTElDQVRJVkUsIEJMRU5EX0FERElUSVZFQUxQSEEsIEJMRU5EX01VTFRJUExJQ0FUSVZFMlgsIEJMRU5EX1NDUkVFTixcbiAgICBCTEVORF9NSU4sIEJMRU5EX01BWCwgQkxFTkRfU1VCVFJBQ1RJVkVcbn0gZnJvbSAnLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IHByb2Nlc3NTaGFkZXIgfSBmcm9tICcuLi9zaGFkZXItbGliL3V0aWxzLmpzJztcbmltcG9ydCB7IGdldERlZmF1bHRNYXRlcmlhbCB9IGZyb20gJy4vZGVmYXVsdC1tYXRlcmlhbC5qcyc7XG5cbi8vIGJsZW5kIG1vZGUgbWFwcGluZyB0byBvcCwgc3JjQmxlbmQgYW5kIGRzdEJsZW5kXG5jb25zdCBibGVuZE1vZGVzID0gW107XG5ibGVuZE1vZGVzW0JMRU5EX1NVQlRSQUNUSVZFXSA9IHsgc3JjOiBCTEVORE1PREVfT05FLCBkc3Q6IEJMRU5ETU9ERV9PTkUsIG9wOiBCTEVOREVRVUFUSU9OX1JFVkVSU0VfU1VCVFJBQ1QgfTtcbmJsZW5kTW9kZXNbQkxFTkRfTk9ORV0gPSB7IHNyYzogQkxFTkRNT0RFX09ORSwgZHN0OiBCTEVORE1PREVfWkVSTywgb3A6IEJMRU5ERVFVQVRJT05fQUREIH07XG5ibGVuZE1vZGVzW0JMRU5EX05PUk1BTF0gPSB7IHNyYzogQkxFTkRNT0RFX1NSQ19BTFBIQSwgZHN0OiBCTEVORE1PREVfT05FX01JTlVTX1NSQ19BTFBIQSwgb3A6IEJMRU5ERVFVQVRJT05fQUREIH07XG5ibGVuZE1vZGVzW0JMRU5EX1BSRU1VTFRJUExJRURdID0geyBzcmM6IEJMRU5ETU9ERV9PTkUsIGRzdDogQkxFTkRNT0RFX09ORV9NSU5VU19TUkNfQUxQSEEsIG9wOiBCTEVOREVRVUFUSU9OX0FERCB9O1xuYmxlbmRNb2Rlc1tCTEVORF9BRERJVElWRV0gPSB7IHNyYzogQkxFTkRNT0RFX09ORSwgZHN0OiBCTEVORE1PREVfT05FLCBvcDogQkxFTkRFUVVBVElPTl9BREQgfTtcbmJsZW5kTW9kZXNbQkxFTkRfQURESVRJVkVBTFBIQV0gPSB7IHNyYzogQkxFTkRNT0RFX1NSQ19BTFBIQSwgZHN0OiBCTEVORE1PREVfT05FLCBvcDogQkxFTkRFUVVBVElPTl9BREQgfTtcbmJsZW5kTW9kZXNbQkxFTkRfTVVMVElQTElDQVRJVkUyWF0gPSB7IHNyYzogQkxFTkRNT0RFX0RTVF9DT0xPUiwgZHN0OiBCTEVORE1PREVfU1JDX0NPTE9SLCBvcDogQkxFTkRFUVVBVElPTl9BREQgfTtcbmJsZW5kTW9kZXNbQkxFTkRfU0NSRUVOXSA9IHsgc3JjOiBCTEVORE1PREVfT05FX01JTlVTX0RTVF9DT0xPUiwgZHN0OiBCTEVORE1PREVfT05FLCBvcDogQkxFTkRFUVVBVElPTl9BREQgfTtcbmJsZW5kTW9kZXNbQkxFTkRfTVVMVElQTElDQVRJVkVdID0geyBzcmM6IEJMRU5ETU9ERV9EU1RfQ09MT1IsIGRzdDogQkxFTkRNT0RFX1pFUk8sIG9wOiBCTEVOREVRVUFUSU9OX0FERCB9O1xuYmxlbmRNb2Rlc1tCTEVORF9NSU5dID0geyBzcmM6IEJMRU5ETU9ERV9PTkUsIGRzdDogQkxFTkRNT0RFX09ORSwgb3A6IEJMRU5ERVFVQVRJT05fTUlOIH07XG5ibGVuZE1vZGVzW0JMRU5EX01BWF0gPSB7IHNyYzogQkxFTkRNT0RFX09ORSwgZHN0OiBCTEVORE1PREVfT05FLCBvcDogQkxFTkRFUVVBVElPTl9NQVggfTtcblxubGV0IGlkID0gMDtcblxuLyoqXG4gKiBBIG1hdGVyaWFsIGRldGVybWluZXMgaG93IGEgcGFydGljdWxhciBtZXNoIGluc3RhbmNlIGlzIHJlbmRlcmVkLiBJdCBzcGVjaWZpZXMgdGhlIHNoYWRlciBhbmRcbiAqIHJlbmRlciBzdGF0ZSB0aGF0IGlzIHNldCBiZWZvcmUgdGhlIG1lc2ggaW5zdGFuY2UgaXMgc3VibWl0dGVkIHRvIHRoZSBncmFwaGljcyBkZXZpY2UuXG4gKi9cbmNsYXNzIE1hdGVyaWFsIHtcbiAgICAvKipcbiAgICAgKiBBIHNoYWRlciB1c2VkIHRvIHJlbmRlciB0aGUgbWF0ZXJpYWwuIE5vdGUgdGhhdCB0aGlzIGlzIHVzZWQgb25seSBieSBtYXRlcmlhbHMgd2hlcmUgdGhlXG4gICAgICogdXNlciBzcGVjaWZpZXMgdGhlIHNoYWRlci4gTW9zdCBtYXRlcmlhbCB0eXBlcyBnZW5lcmF0ZSBtdWx0aXBsZSBzaGFkZXIgdmFyaWFudHMsIGFuZCBkbyBub3RcbiAgICAgKiBzZXQgdGhpcy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoJy4uLy4uL3BsYXRmb3JtL2dyYXBoaWNzL3NoYWRlci5qcycpLlNoYWRlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zaGFkZXIgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG1lc2ggaW5zdGFuY2VzIHJlZmVyZW5jaW5nIHRoaXMgbWF0ZXJpYWxcbiAgICAgKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoJy4uL21lc2gtaW5zdGFuY2UuanMnKS5NZXNoSW5zdGFuY2VbXX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG1lc2hJbnN0YW5jZXMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBtYXRlcmlhbC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgbmFtZSA9ICdVbnRpdGxlZCc7XG5cbiAgICBpZCA9IGlkKys7XG5cbiAgICB2YXJpYW50cyA9IHt9O1xuXG4gICAgcGFyYW1ldGVycyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFscGhhIHRlc3QgcmVmZXJlbmNlIHZhbHVlIHRvIGNvbnRyb2wgd2hpY2ggZnJhZ21lbnRzIGFyZSB3cml0dGVuIHRvIHRoZSBjdXJyZW50bHlcbiAgICAgKiBhY3RpdmUgcmVuZGVyIHRhcmdldCBiYXNlZCBvbiBhbHBoYSB2YWx1ZS4gQWxsIGZyYWdtZW50cyB3aXRoIGFuIGFscGhhIHZhbHVlIG9mIGxlc3MgdGhhblxuICAgICAqIHRoZSBhbHBoYVRlc3QgcmVmZXJlbmNlIHZhbHVlIHdpbGwgYmUgZGlzY2FyZGVkLiBhbHBoYVRlc3QgZGVmYXVsdHMgdG8gMCAoYWxsIGZyYWdtZW50c1xuICAgICAqIHBhc3MpLlxuICAgICAqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBhbHBoYVRlc3QgPSAwO1xuXG4gICAgLyoqXG4gICAgICogRW5hYmxlcyBvciBkaXNhYmxlcyBhbHBoYSB0byBjb3ZlcmFnZSAoV2ViR0wyIG9ubHkpLiBXaGVuIGVuYWJsZWQsIGFuZCBpZiBoYXJkd2FyZVxuICAgICAqIGFudGktYWxpYXNpbmcgaXMgb24sIGxpbWl0ZWQgb3JkZXItaW5kZXBlbmRlbnQgdHJhbnNwYXJlbmN5IGNhbiBiZSBhY2hpZXZlZC4gUXVhbGl0eSBkZXBlbmRzXG4gICAgICogb24gdGhlIG51bWJlciBvZiBNU0FBIHNhbXBsZXMgb2YgdGhlIGN1cnJlbnQgcmVuZGVyIHRhcmdldC4gSXQgY2FuIG5pY2VseSBzb2Z0ZW4gZWRnZXMgb2ZcbiAgICAgKiBvdGhlcndpc2Ugc2hhcnAgYWxwaGEgY3V0b3V0cywgYnV0IGlzbid0IHJlY29tbWVuZGVkIGZvciBsYXJnZSBhcmVhIHNlbWktdHJhbnNwYXJlbnRcbiAgICAgKiBzdXJmYWNlcy4gTm90ZSwgdGhhdCB5b3UgZG9uJ3QgbmVlZCB0byBlbmFibGUgYmxlbmRpbmcgdG8gbWFrZSBhbHBoYSB0byBjb3ZlcmFnZSB3b3JrLiBJdFxuICAgICAqIHdpbGwgd29yayB3aXRob3V0IGl0LCBqdXN0IGxpa2UgYWxwaGFUZXN0LlxuICAgICAqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgYWxwaGFUb0NvdmVyYWdlID0gZmFsc2U7XG5cbiAgICAvKiogQGlnbm9yZSAqL1xuICAgIF9ibGVuZFN0YXRlID0gbmV3IEJsZW5kU3RhdGUoKTtcblxuICAgIC8qKiBAaWdub3JlICovXG4gICAgX2RlcHRoU3RhdGUgPSBuZXcgRGVwdGhTdGF0ZSgpO1xuXG4gICAgLyoqXG4gICAgICogQ29udHJvbHMgaG93IHRyaWFuZ2xlcyBhcmUgY3VsbGVkIGJhc2VkIG9uIHRoZWlyIGZhY2UgZGlyZWN0aW9uIHdpdGggcmVzcGVjdCB0byB0aGVcbiAgICAgKiB2aWV3cG9pbnQuIENhbiBiZTpcbiAgICAgKlxuICAgICAqIC0ge0BsaW5rIENVTExGQUNFX05PTkV9OiBEbyBub3QgY3VsbCB0cmlhbmdsZXMgYmFzZWQgb24gZmFjZSBkaXJlY3Rpb24uXG4gICAgICogLSB7QGxpbmsgQ1VMTEZBQ0VfQkFDS306IEN1bGwgdGhlIGJhY2sgZmFjZXMgb2YgdHJpYW5nbGVzIChkbyBub3QgcmVuZGVyIHRyaWFuZ2xlcyBmYWNpbmdcbiAgICAgKiBhd2F5IGZyb20gdGhlIHZpZXcgcG9pbnQpLlxuICAgICAqIC0ge0BsaW5rIENVTExGQUNFX0ZST05UfTogQ3VsbCB0aGUgZnJvbnQgZmFjZXMgb2YgdHJpYW5nbGVzIChkbyBub3QgcmVuZGVyIHRyaWFuZ2xlcyBmYWNpbmdcbiAgICAgKiB0b3dhcmRzIHRoZSB2aWV3IHBvaW50KS5cbiAgICAgKiAtIHtAbGluayBDVUxMRkFDRV9GUk9OVEFOREJBQ0t9OiBDdWxsIGJvdGggZnJvbnQgYW5kIGJhY2sgZmFjZXMgKHRyaWFuZ2xlcyB3aWxsIG5vdCBiZVxuICAgICAqIHJlbmRlcmVkKS5cbiAgICAgKlxuICAgICAqIERlZmF1bHRzIHRvIHtAbGluayBDVUxMRkFDRV9CQUNLfS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgY3VsbCA9IENVTExGQUNFX0JBQ0s7XG5cbiAgICAvKipcbiAgICAgKiBTdGVuY2lsIHBhcmFtZXRlcnMgZm9yIGZyb250IGZhY2VzIChkZWZhdWx0IGlzIG51bGwpLlxuICAgICAqXG4gICAgICogQHR5cGUge2ltcG9ydCgnLi4vc3RlbmNpbC1wYXJhbWV0ZXJzLmpzJykuU3RlbmNpbFBhcmFtZXRlcnN8bnVsbH1cbiAgICAgKi9cbiAgICBzdGVuY2lsRnJvbnQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogU3RlbmNpbCBwYXJhbWV0ZXJzIGZvciBiYWNrIGZhY2VzIChkZWZhdWx0IGlzIG51bGwpLlxuICAgICAqXG4gICAgICogQHR5cGUge2ltcG9ydCgnLi4vc3RlbmNpbC1wYXJhbWV0ZXJzLmpzJykuU3RlbmNpbFBhcmFtZXRlcnN8bnVsbH1cbiAgICAgKi9cbiAgICBzdGVuY2lsQmFjayA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBPZmZzZXRzIHRoZSBvdXRwdXQgZGVwdGggYnVmZmVyIHZhbHVlLiBVc2VmdWwgZm9yIGRlY2FscyB0byBwcmV2ZW50IHotZmlnaHRpbmcuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGRlcHRoQmlhcyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBTYW1lIGFzIHtAbGluayBNYXRlcmlhbCNkZXB0aEJpYXN9LCBidXQgYWxzbyBkZXBlbmRzIG9uIHRoZSBzbG9wZSBvZiB0aGUgdHJpYW5nbGUgcmVsYXRpdmVcbiAgICAgKiB0byB0aGUgY2FtZXJhLlxuICAgICAqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBzbG9wZURlcHRoQmlhcyA9IDA7XG5cbiAgICBfc2hhZGVyVmVyc2lvbiA9IDA7XG5cbiAgICBfc2NlbmUgPSBudWxsO1xuXG4gICAgX2RpcnR5QmxlbmQgPSBmYWxzZTtcblxuICAgIGRpcnR5ID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHRoZSByZWQgY29tcG9uZW50IG9mIGZyYWdtZW50cyBnZW5lcmF0ZWQgYnkgdGhlIHNoYWRlciBvZiB0aGlzIG1hdGVyaWFsIGlzIHdyaXR0ZW5cbiAgICAgKiB0byB0aGUgY29sb3IgYnVmZmVyIG9mIHRoZSBjdXJyZW50bHkgYWN0aXZlIHJlbmRlciB0YXJnZXQuIElmIGZhbHNlLCB0aGUgcmVkIGNvbXBvbmVudCB3aWxsXG4gICAgICogbm90IGJlIHdyaXR0ZW4uIERlZmF1bHRzIHRvIHRydWUuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBzZXQgcmVkV3JpdGUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fYmxlbmRTdGF0ZS5yZWRXcml0ZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIGdldCByZWRXcml0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JsZW5kU3RhdGUucmVkV3JpdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgdGhlIGdyZWVuIGNvbXBvbmVudCBvZiBmcmFnbWVudHMgZ2VuZXJhdGVkIGJ5IHRoZSBzaGFkZXIgb2YgdGhpcyBtYXRlcmlhbCBpc1xuICAgICAqIHdyaXR0ZW4gdG8gdGhlIGNvbG9yIGJ1ZmZlciBvZiB0aGUgY3VycmVudGx5IGFjdGl2ZSByZW5kZXIgdGFyZ2V0LiBJZiBmYWxzZSwgdGhlIGdyZWVuXG4gICAgICogY29tcG9uZW50IHdpbGwgbm90IGJlIHdyaXR0ZW4uIERlZmF1bHRzIHRvIHRydWUuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBzZXQgZ3JlZW5Xcml0ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9ibGVuZFN0YXRlLmdyZWVuV3JpdGUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXQgZ3JlZW5Xcml0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JsZW5kU3RhdGUuZ3JlZW5Xcml0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCB0aGUgYmx1ZSBjb21wb25lbnQgb2YgZnJhZ21lbnRzIGdlbmVyYXRlZCBieSB0aGUgc2hhZGVyIG9mIHRoaXMgbWF0ZXJpYWwgaXNcbiAgICAgKiB3cml0dGVuIHRvIHRoZSBjb2xvciBidWZmZXIgb2YgdGhlIGN1cnJlbnRseSBhY3RpdmUgcmVuZGVyIHRhcmdldC4gSWYgZmFsc2UsIHRoZSBibHVlXG4gICAgICogY29tcG9uZW50IHdpbGwgbm90IGJlIHdyaXR0ZW4uIERlZmF1bHRzIHRvIHRydWUuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBzZXQgYmx1ZVdyaXRlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2JsZW5kU3RhdGUuYmx1ZVdyaXRlID0gdmFsdWU7XG4gICAgfVxuXG4gICAgZ2V0IGJsdWVXcml0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JsZW5kU3RhdGUuYmx1ZVdyaXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHRoZSBhbHBoYSBjb21wb25lbnQgb2YgZnJhZ21lbnRzIGdlbmVyYXRlZCBieSB0aGUgc2hhZGVyIG9mIHRoaXMgbWF0ZXJpYWwgaXNcbiAgICAgKiB3cml0dGVuIHRvIHRoZSBjb2xvciBidWZmZXIgb2YgdGhlIGN1cnJlbnRseSBhY3RpdmUgcmVuZGVyIHRhcmdldC4gSWYgZmFsc2UsIHRoZSBhbHBoYVxuICAgICAqIGNvbXBvbmVudCB3aWxsIG5vdCBiZSB3cml0dGVuLiBEZWZhdWx0cyB0byB0cnVlLlxuICAgICAqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgc2V0IGFscGhhV3JpdGUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fYmxlbmRTdGF0ZS5hbHBoYVdyaXRlID0gdmFsdWU7XG4gICAgfVxuXG4gICAgZ2V0IGFscGhhV3JpdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ibGVuZFN0YXRlLmFscGhhV3JpdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHNoYWRlciB1c2VkIGJ5IHRoaXMgbWF0ZXJpYWwgdG8gcmVuZGVyIG1lc2ggaW5zdGFuY2VzIChkZWZhdWx0IGlzIG51bGwpLlxuICAgICAqXG4gICAgICogQHR5cGUge2ltcG9ydCgnLi4vLi4vcGxhdGZvcm0vZ3JhcGhpY3Mvc2hhZGVyLmpzJykuU2hhZGVyfG51bGx9XG4gICAgICovXG4gICAgc2V0IHNoYWRlcihzaGFkZXIpIHtcbiAgICAgICAgdGhpcy5fc2hhZGVyID0gc2hhZGVyO1xuICAgIH1cblxuICAgIGdldCBzaGFkZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaGFkZXI7XG4gICAgfVxuXG4gICAgLy8gcmV0dXJucyBib29sZWFuIGRlcGVuZGluZyBvbiBtYXRlcmlhbCBiZWluZyB0cmFuc3BhcmVudFxuICAgIGdldCB0cmFuc3BhcmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JsZW5kU3RhdGUuYmxlbmQ7XG4gICAgfVxuXG4gICAgLy8gY2FsbGVkIHdoZW4gbWF0ZXJpYWwgY2hhbmdlcyB0cmFuc3BhcmVuY3ksIGZvciBsYXllciBjb21wb3NpdGlvbiB0byBhZGQgaXQgdG8gYXBwcm9wcmlhdGVcbiAgICAvLyBxdWV1ZSAob3BhcXVlIG9yIHRyYW5zcGFyZW50KVxuICAgIF9tYXJrQmxlbmREaXJ0eSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NjZW5lKSB7XG4gICAgICAgICAgICB0aGlzLl9zY2VuZS5sYXllcnMuX2RpcnR5QmxlbmQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZGlydHlCbGVuZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb250cm9scyBob3cgZnJhZ21lbnQgc2hhZGVyIG91dHB1dHMgYXJlIGJsZW5kZWQgd2hlbiBiZWluZyB3cml0dGVuIHRvIHRoZSBjdXJyZW50bHkgYWN0aXZlXG4gICAgICogcmVuZGVyIHRhcmdldC4gVGhpcyBvdmVyd3JpdGVzIGJsZW5kaW5nIHR5cGUgc2V0IHVzaW5nIHtAbGluayBwYy5NYXRlcmlhbCNibGVuZFR5cGV9LCBhbmRcbiAgICAgKiBvZmZlcnMgbW9yZSBjb250cm9sIG92ZXIgYmxlbmRpbmcuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7IEJsZW5kU3RhdGUgfVxuICAgICAqL1xuICAgIHNldCBibGVuZFN0YXRlKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLl9ibGVuZFN0YXRlLmJsZW5kICE9PSB2YWx1ZS5ibGVuZCkge1xuICAgICAgICAgICAgdGhpcy5fbWFya0JsZW5kRGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9ibGVuZFN0YXRlLmNvcHkodmFsdWUpO1xuICAgIH1cblxuICAgIGdldCBibGVuZFN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYmxlbmRTdGF0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb250cm9scyBob3cgZnJhZ21lbnQgc2hhZGVyIG91dHB1dHMgYXJlIGJsZW5kZWQgd2hlbiBiZWluZyB3cml0dGVuIHRvIHRoZSBjdXJyZW50bHkgYWN0aXZlXG4gICAgICogcmVuZGVyIHRhcmdldC4gQ2FuIGJlOlxuICAgICAqXG4gICAgICogLSB7QGxpbmsgQkxFTkRfU1VCVFJBQ1RJVkV9OiBTdWJ0cmFjdCB0aGUgY29sb3Igb2YgdGhlIHNvdXJjZSBmcmFnbWVudCBmcm9tIHRoZSBkZXN0aW5hdGlvblxuICAgICAqIGZyYWdtZW50IGFuZCB3cml0ZSB0aGUgcmVzdWx0IHRvIHRoZSBmcmFtZSBidWZmZXIuXG4gICAgICogLSB7QGxpbmsgQkxFTkRfQURESVRJVkV9OiBBZGQgdGhlIGNvbG9yIG9mIHRoZSBzb3VyY2UgZnJhZ21lbnQgdG8gdGhlIGRlc3RpbmF0aW9uIGZyYWdtZW50XG4gICAgICogYW5kIHdyaXRlIHRoZSByZXN1bHQgdG8gdGhlIGZyYW1lIGJ1ZmZlci5cbiAgICAgKiAtIHtAbGluayBCTEVORF9OT1JNQUx9OiBFbmFibGUgc2ltcGxlIHRyYW5zbHVjZW5jeSBmb3IgbWF0ZXJpYWxzIHN1Y2ggYXMgZ2xhc3MuIFRoaXMgaXNcbiAgICAgKiBlcXVpdmFsZW50IHRvIGVuYWJsaW5nIGEgc291cmNlIGJsZW5kIG1vZGUgb2Yge0BsaW5rIEJMRU5ETU9ERV9TUkNfQUxQSEF9IGFuZCBhIGRlc3RpbmF0aW9uXG4gICAgICogYmxlbmQgbW9kZSBvZiB7QGxpbmsgQkxFTkRNT0RFX09ORV9NSU5VU19TUkNfQUxQSEF9LlxuICAgICAqIC0ge0BsaW5rIEJMRU5EX05PTkV9OiBEaXNhYmxlIGJsZW5kaW5nLlxuICAgICAqIC0ge0BsaW5rIEJMRU5EX1BSRU1VTFRJUExJRUR9OiBTaW1pbGFyIHRvIHtAbGluayBCTEVORF9OT1JNQUx9IGV4cGVjdCB0aGUgc291cmNlIGZyYWdtZW50IGlzXG4gICAgICogYXNzdW1lZCB0byBoYXZlIGFscmVhZHkgYmVlbiBtdWx0aXBsaWVkIGJ5IHRoZSBzb3VyY2UgYWxwaGEgdmFsdWUuXG4gICAgICogLSB7QGxpbmsgQkxFTkRfTVVMVElQTElDQVRJVkV9OiBNdWx0aXBseSB0aGUgY29sb3Igb2YgdGhlIHNvdXJjZSBmcmFnbWVudCBieSB0aGUgY29sb3Igb2YgdGhlXG4gICAgICogZGVzdGluYXRpb24gZnJhZ21lbnQgYW5kIHdyaXRlIHRoZSByZXN1bHQgdG8gdGhlIGZyYW1lIGJ1ZmZlci5cbiAgICAgKiAtIHtAbGluayBCTEVORF9BRERJVElWRUFMUEhBfTogU2FtZSBhcyB7QGxpbmsgQkxFTkRfQURESVRJVkV9IGV4Y2VwdCB0aGUgc291cmNlIFJHQiBpc1xuICAgICAqIG11bHRpcGxpZWQgYnkgdGhlIHNvdXJjZSBhbHBoYS5cbiAgICAgKiAtIHtAbGluayBCTEVORF9NVUxUSVBMSUNBVElWRTJYfTogTXVsdGlwbGllcyBjb2xvcnMgYW5kIGRvdWJsZXMgdGhlIHJlc3VsdC5cbiAgICAgKiAtIHtAbGluayBCTEVORF9TQ1JFRU59OiBTb2Z0ZXIgdmVyc2lvbiBvZiBhZGRpdGl2ZS5cbiAgICAgKiAtIHtAbGluayBCTEVORF9NSU59OiBNaW5pbXVtIGNvbG9yLiBDaGVjayBhcHAuZ3JhcGhpY3NEZXZpY2UuZXh0QmxlbmRNaW5tYXggZm9yIHN1cHBvcnQuXG4gICAgICogLSB7QGxpbmsgQkxFTkRfTUFYfTogTWF4aW11bSBjb2xvci4gQ2hlY2sgYXBwLmdyYXBoaWNzRGV2aWNlLmV4dEJsZW5kTWlubWF4IGZvciBzdXBwb3J0LlxuICAgICAqXG4gICAgICogRGVmYXVsdHMgdG8ge0BsaW5rIEJMRU5EX05PTkV9LlxuICAgICAqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBzZXQgYmxlbmRUeXBlKHR5cGUpIHtcblxuICAgICAgICBjb25zdCBibGVuZE1vZGUgPSBibGVuZE1vZGVzW3R5cGVdO1xuICAgICAgICBEZWJ1Zy5hc3NlcnQoYmxlbmRNb2RlLCBgVW5rbm93biBibGVuZCBtb2RlICR7dHlwZX1gKTtcbiAgICAgICAgdGhpcy5fYmxlbmRTdGF0ZS5zZXRDb2xvckJsZW5kKGJsZW5kTW9kZS5vcCwgYmxlbmRNb2RlLnNyYywgYmxlbmRNb2RlLmRzdCk7XG4gICAgICAgIHRoaXMuX2JsZW5kU3RhdGUuc2V0QWxwaGFCbGVuZChibGVuZE1vZGUub3AsIGJsZW5kTW9kZS5zcmMsIGJsZW5kTW9kZS5kc3QpO1xuXG4gICAgICAgIGNvbnN0IGJsZW5kID0gdHlwZSAhPT0gQkxFTkRfTk9ORTtcbiAgICAgICAgaWYgKHRoaXMuX2JsZW5kU3RhdGUuYmxlbmQgIT09IGJsZW5kKSB7XG4gICAgICAgICAgICB0aGlzLl9ibGVuZFN0YXRlLmJsZW5kID0gYmxlbmQ7XG4gICAgICAgICAgICB0aGlzLl9tYXJrQmxlbmREaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3VwZGF0ZU1lc2hJbnN0YW5jZUtleXMoKTtcbiAgICB9XG5cbiAgICBnZXQgYmxlbmRUeXBlKCkge1xuICAgICAgICBpZiAoIXRoaXMudHJhbnNwYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBCTEVORF9OT05FO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBjb2xvck9wLCBjb2xvclNyY0ZhY3RvciwgY29sb3JEc3RGYWN0b3IsIGFscGhhT3AsIGFscGhhU3JjRmFjdG9yLCBhbHBoYURzdEZhY3RvciB9ID0gdGhpcy5fYmxlbmRTdGF0ZTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsZW5kTW9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGJsZW5kTW9kZSA9IGJsZW5kTW9kZXNbaV07XG4gICAgICAgICAgICBpZiAoYmxlbmRNb2RlLnNyYyA9PT0gY29sb3JTcmNGYWN0b3IgJiYgYmxlbmRNb2RlLmRzdCA9PT0gY29sb3JEc3RGYWN0b3IgJiYgYmxlbmRNb2RlLm9wID09PSBjb2xvck9wICYmXG4gICAgICAgICAgICAgICAgYmxlbmRNb2RlLnNyYyA9PT0gYWxwaGFTcmNGYWN0b3IgJiYgYmxlbmRNb2RlLmRzdCA9PT0gYWxwaGFEc3RGYWN0b3IgJiYgYmxlbmRNb2RlLm9wID09PSBhbHBoYU9wKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gQkxFTkRfTk9STUFMO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGRlcHRoIHN0YXRlLiBOb3RlIHRoYXQgdGhpcyBjYW4gYWxzbyBiZSBkb25lIGJ5IHVzaW5nIHtAbGluayBNYXRlcmlhbCNkZXB0aFRlc3R9LFxuICAgICAqIHtAbGluayBNYXRlcmlhbCNkZXB0aEZ1bmN9IGFuZCB7QGxpbmsgTWF0ZXJpYWwjZGVwdGhXcml0ZX0uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7IERlcHRoU3RhdGUgfVxuICAgICAqL1xuICAgIHNldCBkZXB0aFN0YXRlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2RlcHRoU3RhdGUuY29weSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgZ2V0IGRlcHRoU3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZXB0aFN0YXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIGZyYWdtZW50cyBnZW5lcmF0ZWQgYnkgdGhlIHNoYWRlciBvZiB0aGlzIG1hdGVyaWFsIGFyZSBvbmx5IHdyaXR0ZW4gdG8gdGhlIGN1cnJlbnRcbiAgICAgKiByZW5kZXIgdGFyZ2V0IGlmIHRoZXkgcGFzcyB0aGUgZGVwdGggdGVzdC4gSWYgZmFsc2UsIGZyYWdtZW50cyBnZW5lcmF0ZWQgYnkgdGhlIHNoYWRlciBvZlxuICAgICAqIHRoaXMgbWF0ZXJpYWwgYXJlIHdyaXR0ZW4gdG8gdGhlIGN1cnJlbnQgcmVuZGVyIHRhcmdldCByZWdhcmRsZXNzIG9mIHdoYXQgaXMgaW4gdGhlIGRlcHRoXG4gICAgICogYnVmZmVyLiBEZWZhdWx0cyB0byB0cnVlLlxuICAgICAqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgc2V0IGRlcHRoVGVzdCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9kZXB0aFN0YXRlLnRlc3QgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXQgZGVwdGhUZXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVwdGhTdGF0ZS50ZXN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnRyb2xzIGhvdyB0aGUgZGVwdGggb2YgbmV3IGZyYWdtZW50cyBpcyBjb21wYXJlZCBhZ2FpbnN0IHRoZSBjdXJyZW50IGRlcHRoIGNvbnRhaW5lZCBpblxuICAgICAqIHRoZSBkZXB0aCBidWZmZXIuIENhbiBiZTpcbiAgICAgKlxuICAgICAqIC0ge0BsaW5rIEZVTkNfTkVWRVJ9OiBkb24ndCBkcmF3XG4gICAgICogLSB7QGxpbmsgRlVOQ19MRVNTfTogZHJhdyBpZiBuZXcgZGVwdGggPCBkZXB0aCBidWZmZXJcbiAgICAgKiAtIHtAbGluayBGVU5DX0VRVUFMfTogZHJhdyBpZiBuZXcgZGVwdGggPT0gZGVwdGggYnVmZmVyXG4gICAgICogLSB7QGxpbmsgRlVOQ19MRVNTRVFVQUx9OiBkcmF3IGlmIG5ldyBkZXB0aCA8PSBkZXB0aCBidWZmZXJcbiAgICAgKiAtIHtAbGluayBGVU5DX0dSRUFURVJ9OiBkcmF3IGlmIG5ldyBkZXB0aCA+IGRlcHRoIGJ1ZmZlclxuICAgICAqIC0ge0BsaW5rIEZVTkNfTk9URVFVQUx9OiBkcmF3IGlmIG5ldyBkZXB0aCAhPSBkZXB0aCBidWZmZXJcbiAgICAgKiAtIHtAbGluayBGVU5DX0dSRUFURVJFUVVBTH06IGRyYXcgaWYgbmV3IGRlcHRoID49IGRlcHRoIGJ1ZmZlclxuICAgICAqIC0ge0BsaW5rIEZVTkNfQUxXQVlTfTogYWx3YXlzIGRyYXdcbiAgICAgKlxuICAgICAqIERlZmF1bHRzIHRvIHtAbGluayBGVU5DX0xFU1NFUVVBTH0uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHNldCBkZXB0aEZ1bmModmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZGVwdGhTdGF0ZS5mdW5jID0gdmFsdWU7XG4gICAgfVxuXG4gICAgZ2V0IGRlcHRoRnVuYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlcHRoU3RhdGUuZnVuYztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCBmcmFnbWVudHMgZ2VuZXJhdGVkIGJ5IHRoZSBzaGFkZXIgb2YgdGhpcyBtYXRlcmlhbCB3cml0ZSBhIGRlcHRoIHZhbHVlIHRvIHRoZSBkZXB0aFxuICAgICAqIGJ1ZmZlciBvZiB0aGUgY3VycmVudGx5IGFjdGl2ZSByZW5kZXIgdGFyZ2V0LiBJZiBmYWxzZSwgbm8gZGVwdGggdmFsdWUgaXMgd3JpdHRlbi4gRGVmYXVsdHNcbiAgICAgKiB0byB0cnVlLlxuICAgICAqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgc2V0IGRlcHRoV3JpdGUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZGVwdGhTdGF0ZS53cml0ZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIGdldCBkZXB0aFdyaXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVwdGhTdGF0ZS53cml0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3B5IGEgbWF0ZXJpYWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge01hdGVyaWFsfSBzb3VyY2UgLSBUaGUgbWF0ZXJpYWwgdG8gY29weS5cbiAgICAgKiBAcmV0dXJucyB7TWF0ZXJpYWx9IFRoZSBkZXN0aW5hdGlvbiBtYXRlcmlhbC5cbiAgICAgKi9cbiAgICBjb3B5KHNvdXJjZSkge1xuICAgICAgICB0aGlzLm5hbWUgPSBzb3VyY2UubmFtZTtcbiAgICAgICAgdGhpcy5fc2hhZGVyID0gc291cmNlLl9zaGFkZXI7XG5cbiAgICAgICAgLy8gUmVuZGVyIHN0YXRlc1xuICAgICAgICB0aGlzLmFscGhhVGVzdCA9IHNvdXJjZS5hbHBoYVRlc3Q7XG4gICAgICAgIHRoaXMuYWxwaGFUb0NvdmVyYWdlID0gc291cmNlLmFscGhhVG9Db3ZlcmFnZTtcblxuICAgICAgICB0aGlzLl9ibGVuZFN0YXRlLmNvcHkoc291cmNlLl9ibGVuZFN0YXRlKTtcbiAgICAgICAgdGhpcy5fZGVwdGhTdGF0ZS5jb3B5KHNvdXJjZS5fZGVwdGhTdGF0ZSk7XG5cbiAgICAgICAgdGhpcy5jdWxsID0gc291cmNlLmN1bGw7XG5cbiAgICAgICAgdGhpcy5kZXB0aEJpYXMgPSBzb3VyY2UuZGVwdGhCaWFzO1xuICAgICAgICB0aGlzLnNsb3BlRGVwdGhCaWFzID0gc291cmNlLnNsb3BlRGVwdGhCaWFzO1xuICAgICAgICBpZiAoc291cmNlLnN0ZW5jaWxGcm9udCkgdGhpcy5zdGVuY2lsRnJvbnQgPSBzb3VyY2Uuc3RlbmNpbEZyb250LmNsb25lKCk7XG4gICAgICAgIGlmIChzb3VyY2Uuc3RlbmNpbEJhY2spIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2Uuc3RlbmNpbEZyb250ID09PSBzb3VyY2Uuc3RlbmNpbEJhY2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0ZW5jaWxCYWNrID0gdGhpcy5zdGVuY2lsRnJvbnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RlbmNpbEJhY2sgPSBzb3VyY2Uuc3RlbmNpbEJhY2suY2xvbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsb25lIGEgbWF0ZXJpYWwuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7dGhpc30gQSBuZXdseSBjbG9uZWQgbWF0ZXJpYWwuXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IGNsb25lID0gbmV3IHRoaXMuY29uc3RydWN0b3IoKTtcbiAgICAgICAgcmV0dXJuIGNsb25lLmNvcHkodGhpcyk7XG4gICAgfVxuXG4gICAgX3VwZGF0ZU1lc2hJbnN0YW5jZUtleXMoKSB7XG4gICAgICAgIGNvbnN0IG1lc2hJbnN0YW5jZXMgPSB0aGlzLm1lc2hJbnN0YW5jZXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVzaEluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbWVzaEluc3RhbmNlc1tpXS51cGRhdGVLZXkoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZVVuaWZvcm1zKGRldmljZSwgc2NlbmUpIHtcbiAgICB9XG5cbiAgICBnZXRTaGFkZXJWYXJpYW50KGRldmljZSwgc2NlbmUsIG9iakRlZnMsIHN0YXRpY0xpZ2h0TGlzdCwgcGFzcywgc29ydGVkTGlnaHRzLCB2aWV3VW5pZm9ybUZvcm1hdCwgdmlld0JpbmRHcm91cEZvcm1hdCwgdmVydGV4Rm9ybWF0KSB7XG5cbiAgICAgICAgLy8gZ2VuZXJhdGUgc2hhZGVyIHZhcmlhbnQgLSBpdHMgdGhlIHNhbWUgc2hhZGVyLCBidXQgd2l0aCBkaWZmZXJlbnQgcHJvY2Vzc2luZyBvcHRpb25zXG4gICAgICAgIGNvbnN0IHByb2Nlc3NpbmdPcHRpb25zID0gbmV3IFNoYWRlclByb2Nlc3Nvck9wdGlvbnModmlld1VuaWZvcm1Gb3JtYXQsIHZpZXdCaW5kR3JvdXBGb3JtYXQsIHZlcnRleEZvcm1hdCk7XG4gICAgICAgIHJldHVybiBwcm9jZXNzU2hhZGVyKHRoaXMuX3NoYWRlciwgcHJvY2Vzc2luZ09wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgYW55IGNoYW5nZXMgbWFkZSB0byB0aGUgbWF0ZXJpYWwncyBwcm9wZXJ0aWVzLlxuICAgICAqL1xuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLl9zaGFkZXIpIHRoaXMuX3NoYWRlci5mYWlsZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBQYXJhbWV0ZXIgbWFuYWdlbWVudFxuICAgIGNsZWFyUGFyYW1ldGVycygpIHtcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzID0ge307XG4gICAgfVxuXG4gICAgZ2V0UGFyYW1ldGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyYW1ldGVycztcbiAgICB9XG5cbiAgICBjbGVhclZhcmlhbnRzKCkge1xuXG4gICAgICAgIC8vIGNsZWFyIHZhcmlhbnRzIG9uIHRoZSBtYXRlcmlhbFxuICAgICAgICB0aGlzLnZhcmlhbnRzID0ge307XG5cbiAgICAgICAgLy8gYnV0IGFsc28gY2xlYXIgdGhlbSBmcm9tIGFsbCBtYXRlcmlhbHMgdGhhdCByZWZlcmVuY2UgdGhlbVxuICAgICAgICBjb25zdCBtZXNoSW5zdGFuY2VzID0gdGhpcy5tZXNoSW5zdGFuY2VzO1xuICAgICAgICBjb25zdCBjb3VudCA9IG1lc2hJbnN0YW5jZXMubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIG1lc2hJbnN0YW5jZXNbaV0uY2xlYXJTaGFkZXJzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHNwZWNpZmllZCBzaGFkZXIgcGFyYW1ldGVyIGZyb20gYSBtYXRlcmlhbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHBhcmFtZXRlciB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBUaGUgbmFtZWQgcGFyYW1ldGVyLlxuICAgICAqL1xuICAgIGdldFBhcmFtZXRlcihuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmFtZXRlcnNbbmFtZV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBhIHNoYWRlciBwYXJhbWV0ZXIgb24gYSBtYXRlcmlhbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHBhcmFtZXRlciB0byBzZXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ8bnVtYmVyW118RmxvYXQzMkFycmF5fGltcG9ydCgnLi4vLi4vcGxhdGZvcm0vZ3JhcGhpY3MvdGV4dHVyZS5qcycpLlRleHR1cmV9IGRhdGEgLVxuICAgICAqIFRoZSB2YWx1ZSBmb3IgdGhlIHNwZWNpZmllZCBwYXJhbWV0ZXIuXG4gICAgICovXG4gICAgc2V0UGFyYW1ldGVyKG5hbWUsIGRhdGEpIHtcblxuICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBuYW1lID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgY29uc3QgdW5pZm9ybU9iamVjdCA9IG5hbWU7XG4gICAgICAgICAgICBpZiAodW5pZm9ybU9iamVjdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVuaWZvcm1PYmplY3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRQYXJhbWV0ZXIodW5pZm9ybU9iamVjdFtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5hbWUgPSB1bmlmb3JtT2JqZWN0Lm5hbWU7XG4gICAgICAgICAgICBkYXRhID0gdW5pZm9ybU9iamVjdC52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHBhcmFtID0gdGhpcy5wYXJhbWV0ZXJzW25hbWVdO1xuICAgICAgICBpZiAocGFyYW0pIHtcbiAgICAgICAgICAgIHBhcmFtLmRhdGEgPSBkYXRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wYXJhbWV0ZXJzW25hbWVdID0ge1xuICAgICAgICAgICAgICAgIHNjb3BlSWQ6IG51bGwsXG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgYSBzaGFkZXIgcGFyYW1ldGVyIG9uIGEgbWF0ZXJpYWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBwYXJhbWV0ZXIgdG8gZGVsZXRlLlxuICAgICAqL1xuICAgIGRlbGV0ZVBhcmFtZXRlcihuYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcmFtZXRlcnNbbmFtZV0pIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnBhcmFtZXRlcnNbbmFtZV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB1c2VkIHRvIGFwcGx5IHBhcmFtZXRlcnMgZnJvbSB0aGlzIG1hdGVyaWFsIGludG8gc2NvcGUgb2YgdW5pZm9ybXMsIGNhbGxlZCBpbnRlcm5hbGx5IGJ5IGZvcndhcmQtcmVuZGVyZXJcbiAgICAvLyBvcHRpb25hbCBsaXN0IG9mIHBhcmFtZXRlciBuYW1lcyB0byBiZSBzZXQgY2FuIGJlIHNwZWNpZmllZCwgb3RoZXJ3aXNlIGFsbCBwYXJhbWV0ZXJzIGFyZSBzZXRcbiAgICBzZXRQYXJhbWV0ZXJzKGRldmljZSwgbmFtZXMpIHtcbiAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IHRoaXMucGFyYW1ldGVycztcbiAgICAgICAgaWYgKG5hbWVzID09PSB1bmRlZmluZWQpIG5hbWVzID0gcGFyYW1ldGVycztcbiAgICAgICAgZm9yIChjb25zdCBwYXJhbU5hbWUgaW4gbmFtZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtZXRlciA9IHBhcmFtZXRlcnNbcGFyYW1OYW1lXTtcbiAgICAgICAgICAgIGlmIChwYXJhbWV0ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcmFtZXRlci5zY29wZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlci5zY29wZUlkID0gZGV2aWNlLnNjb3BlLnJlc29sdmUocGFyYW1OYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyYW1ldGVyLnNjb3BlSWQuc2V0VmFsdWUocGFyYW1ldGVyLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGlzIG1hdGVyaWFsIGZyb20gdGhlIHNjZW5lIGFuZCBwb3NzaWJseSBmcmVlcyB1cCBtZW1vcnkgZnJvbSBpdHMgc2hhZGVycyAoaWYgdGhlcmVcbiAgICAgKiBhcmUgbm8gb3RoZXIgbWF0ZXJpYWxzIHVzaW5nIGl0KS5cbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnZhcmlhbnRzID0ge307XG4gICAgICAgIHRoaXMuX3NoYWRlciA9IG51bGw7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1lc2hJbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG1lc2hJbnN0YW5jZSA9IHRoaXMubWVzaEluc3RhbmNlc1tpXTtcbiAgICAgICAgICAgIG1lc2hJbnN0YW5jZS5jbGVhclNoYWRlcnMoKTtcbiAgICAgICAgICAgIG1lc2hJbnN0YW5jZS5fbWF0ZXJpYWwgPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAobWVzaEluc3RhbmNlLm1lc2gpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWZhdWx0TWF0ZXJpYWwgPSBnZXREZWZhdWx0TWF0ZXJpYWwobWVzaEluc3RhbmNlLm1lc2guZGV2aWNlKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcyAhPT0gZGVmYXVsdE1hdGVyaWFsKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc2hJbnN0YW5jZS5tYXRlcmlhbCA9IGRlZmF1bHRNYXRlcmlhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIERlYnVnLndhcm4oJ3BjLk1hdGVyaWFsOiBNZXNoSW5zdGFuY2UubWVzaCBpcyBudWxsLCBkZWZhdWx0IG1hdGVyaWFsIGNhbm5vdCBiZSBhc3NpZ25lZCB0byB0aGUgTWVzaEluc3RhbmNlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1lc2hJbnN0YW5jZXMubGVuZ3RoID0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgbWVzaCBpbnN0YW5jZSBhcyByZWZlcmVuY2luZyB0aGUgbWF0ZXJpYWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vbWVzaC1pbnN0YW5jZS5qcycpLk1lc2hJbnN0YW5jZX0gbWVzaEluc3RhbmNlIC0gVGhlIG1lc2ggaW5zdGFuY2UgdG9cbiAgICAgKiBkZS1yZWdpc3Rlci5cbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgYWRkTWVzaEluc3RhbmNlUmVmKG1lc2hJbnN0YW5jZSkge1xuICAgICAgICB0aGlzLm1lc2hJbnN0YW5jZXMucHVzaChtZXNoSW5zdGFuY2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlLXJlZ2lzdGVycyBtZXNoIGluc3RhbmNlIGFzIHJlZmVyZW5jaW5nIHRoZSBtYXRlcmlhbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KCcuLi9tZXNoLWluc3RhbmNlLmpzJykuTWVzaEluc3RhbmNlfSBtZXNoSW5zdGFuY2UgLSBUaGUgbWVzaCBpbnN0YW5jZSB0b1xuICAgICAqIGRlLXJlZ2lzdGVyLlxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICByZW1vdmVNZXNoSW5zdGFuY2VSZWYobWVzaEluc3RhbmNlKSB7XG4gICAgICAgIGNvbnN0IG1lc2hJbnN0YW5jZXMgPSB0aGlzLm1lc2hJbnN0YW5jZXM7XG4gICAgICAgIGNvbnN0IGkgPSBtZXNoSW5zdGFuY2VzLmluZGV4T2YobWVzaEluc3RhbmNlKTtcbiAgICAgICAgaWYgKGkgIT09IC0xKSB7XG4gICAgICAgICAgICBtZXNoSW5zdGFuY2VzLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IHsgTWF0ZXJpYWwgfTtcbiJdLCJuYW1lcyI6WyJibGVuZE1vZGVzIiwiQkxFTkRfU1VCVFJBQ1RJVkUiLCJzcmMiLCJCTEVORE1PREVfT05FIiwiZHN0Iiwib3AiLCJCTEVOREVRVUFUSU9OX1JFVkVSU0VfU1VCVFJBQ1QiLCJCTEVORF9OT05FIiwiQkxFTkRNT0RFX1pFUk8iLCJCTEVOREVRVUFUSU9OX0FERCIsIkJMRU5EX05PUk1BTCIsIkJMRU5ETU9ERV9TUkNfQUxQSEEiLCJCTEVORE1PREVfT05FX01JTlVTX1NSQ19BTFBIQSIsIkJMRU5EX1BSRU1VTFRJUExJRUQiLCJCTEVORF9BRERJVElWRSIsIkJMRU5EX0FERElUSVZFQUxQSEEiLCJCTEVORF9NVUxUSVBMSUNBVElWRTJYIiwiQkxFTkRNT0RFX0RTVF9DT0xPUiIsIkJMRU5ETU9ERV9TUkNfQ09MT1IiLCJCTEVORF9TQ1JFRU4iLCJCTEVORE1PREVfT05FX01JTlVTX0RTVF9DT0xPUiIsIkJMRU5EX01VTFRJUExJQ0FUSVZFIiwiQkxFTkRfTUlOIiwiQkxFTkRFUVVBVElPTl9NSU4iLCJCTEVORF9NQVgiLCJCTEVOREVRVUFUSU9OX01BWCIsImlkIiwiTWF0ZXJpYWwiLCJfc2hhZGVyIiwibWVzaEluc3RhbmNlcyIsIm5hbWUiLCJ2YXJpYW50cyIsInBhcmFtZXRlcnMiLCJhbHBoYVRlc3QiLCJhbHBoYVRvQ292ZXJhZ2UiLCJfYmxlbmRTdGF0ZSIsIkJsZW5kU3RhdGUiLCJfZGVwdGhTdGF0ZSIsIkRlcHRoU3RhdGUiLCJjdWxsIiwiQ1VMTEZBQ0VfQkFDSyIsInN0ZW5jaWxGcm9udCIsInN0ZW5jaWxCYWNrIiwiZGVwdGhCaWFzIiwic2xvcGVEZXB0aEJpYXMiLCJfc2hhZGVyVmVyc2lvbiIsIl9zY2VuZSIsIl9kaXJ0eUJsZW5kIiwiZGlydHkiLCJyZWRXcml0ZSIsInZhbHVlIiwiZ3JlZW5Xcml0ZSIsImJsdWVXcml0ZSIsImFscGhhV3JpdGUiLCJzaGFkZXIiLCJ0cmFuc3BhcmVudCIsImJsZW5kIiwiX21hcmtCbGVuZERpcnR5IiwibGF5ZXJzIiwiYmxlbmRTdGF0ZSIsImNvcHkiLCJibGVuZFR5cGUiLCJ0eXBlIiwiYmxlbmRNb2RlIiwiRGVidWciLCJhc3NlcnQiLCJzZXRDb2xvckJsZW5kIiwic2V0QWxwaGFCbGVuZCIsIl91cGRhdGVNZXNoSW5zdGFuY2VLZXlzIiwiY29sb3JPcCIsImNvbG9yU3JjRmFjdG9yIiwiY29sb3JEc3RGYWN0b3IiLCJhbHBoYU9wIiwiYWxwaGFTcmNGYWN0b3IiLCJhbHBoYURzdEZhY3RvciIsImkiLCJsZW5ndGgiLCJkZXB0aFN0YXRlIiwiZGVwdGhUZXN0IiwidGVzdCIsImRlcHRoRnVuYyIsImZ1bmMiLCJkZXB0aFdyaXRlIiwid3JpdGUiLCJzb3VyY2UiLCJjbG9uZSIsImNvbnN0cnVjdG9yIiwidXBkYXRlS2V5IiwidXBkYXRlVW5pZm9ybXMiLCJkZXZpY2UiLCJzY2VuZSIsImdldFNoYWRlclZhcmlhbnQiLCJvYmpEZWZzIiwic3RhdGljTGlnaHRMaXN0IiwicGFzcyIsInNvcnRlZExpZ2h0cyIsInZpZXdVbmlmb3JtRm9ybWF0Iiwidmlld0JpbmRHcm91cEZvcm1hdCIsInZlcnRleEZvcm1hdCIsInByb2Nlc3NpbmdPcHRpb25zIiwiU2hhZGVyUHJvY2Vzc29yT3B0aW9ucyIsInByb2Nlc3NTaGFkZXIiLCJ1cGRhdGUiLCJmYWlsZWQiLCJjbGVhclBhcmFtZXRlcnMiLCJnZXRQYXJhbWV0ZXJzIiwiY2xlYXJWYXJpYW50cyIsImNvdW50IiwiY2xlYXJTaGFkZXJzIiwiZ2V0UGFyYW1ldGVyIiwic2V0UGFyYW1ldGVyIiwiZGF0YSIsInVuZGVmaW5lZCIsInVuaWZvcm1PYmplY3QiLCJwYXJhbSIsInNjb3BlSWQiLCJkZWxldGVQYXJhbWV0ZXIiLCJzZXRQYXJhbWV0ZXJzIiwibmFtZXMiLCJwYXJhbU5hbWUiLCJwYXJhbWV0ZXIiLCJzY29wZSIsInJlc29sdmUiLCJzZXRWYWx1ZSIsImRlc3Ryb3kiLCJtZXNoSW5zdGFuY2UiLCJfbWF0ZXJpYWwiLCJtZXNoIiwiZGVmYXVsdE1hdGVyaWFsIiwiZ2V0RGVmYXVsdE1hdGVyaWFsIiwibWF0ZXJpYWwiLCJ3YXJuIiwiYWRkTWVzaEluc3RhbmNlUmVmIiwicHVzaCIsInJlbW92ZU1lc2hJbnN0YW5jZVJlZiIsImluZGV4T2YiLCJzcGxpY2UiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBc0JBO0FBQ0EsTUFBTUEsVUFBVSxHQUFHLEVBQUUsQ0FBQTtBQUNyQkEsVUFBVSxDQUFDQyxpQkFBaUIsQ0FBQyxHQUFHO0FBQUVDLEVBQUFBLEdBQUcsRUFBRUMsYUFBYTtBQUFFQyxFQUFBQSxHQUFHLEVBQUVELGFBQWE7QUFBRUUsRUFBQUEsRUFBRSxFQUFFQyw4QkFBQUE7QUFBK0IsQ0FBQyxDQUFBO0FBQzlHTixVQUFVLENBQUNPLFVBQVUsQ0FBQyxHQUFHO0FBQUVMLEVBQUFBLEdBQUcsRUFBRUMsYUFBYTtBQUFFQyxFQUFBQSxHQUFHLEVBQUVJLGNBQWM7QUFBRUgsRUFBQUEsRUFBRSxFQUFFSSxpQkFBQUE7QUFBa0IsQ0FBQyxDQUFBO0FBQzNGVCxVQUFVLENBQUNVLFlBQVksQ0FBQyxHQUFHO0FBQUVSLEVBQUFBLEdBQUcsRUFBRVMsbUJBQW1CO0FBQUVQLEVBQUFBLEdBQUcsRUFBRVEsNkJBQTZCO0FBQUVQLEVBQUFBLEVBQUUsRUFBRUksaUJBQUFBO0FBQWtCLENBQUMsQ0FBQTtBQUNsSFQsVUFBVSxDQUFDYSxtQkFBbUIsQ0FBQyxHQUFHO0FBQUVYLEVBQUFBLEdBQUcsRUFBRUMsYUFBYTtBQUFFQyxFQUFBQSxHQUFHLEVBQUVRLDZCQUE2QjtBQUFFUCxFQUFBQSxFQUFFLEVBQUVJLGlCQUFBQTtBQUFrQixDQUFDLENBQUE7QUFDbkhULFVBQVUsQ0FBQ2MsY0FBYyxDQUFDLEdBQUc7QUFBRVosRUFBQUEsR0FBRyxFQUFFQyxhQUFhO0FBQUVDLEVBQUFBLEdBQUcsRUFBRUQsYUFBYTtBQUFFRSxFQUFBQSxFQUFFLEVBQUVJLGlCQUFBQTtBQUFrQixDQUFDLENBQUE7QUFDOUZULFVBQVUsQ0FBQ2UsbUJBQW1CLENB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
