import"../core/tracing.js";import{hashCode as t}from"../core/hash.js";import{math as e}from"../math/math.js";import{typedArrayTypesByteSize as s,SEMANTIC_TEXCOORD0 as n,SEMANTIC_TEXCOORD1 as i,SEMANTIC_COLOR as a,SEMANTIC_TANGENT as o,SEMANTIC_ATTR12 as r,TYPE_FLOAT32 as h,SEMANTIC_ATTR13 as m,SEMANTIC_ATTR14 as c,SEMANTIC_ATTR15 as l}from"./constants.js";class p{constructor(t,r,h){this._elements=[],this.hasUv0=!1,this.hasUv1=!1,this.hasColor=!1,this.hasTangents=!1,this.verticesByteSize=0,this.vertexCount=h,this.interleaved=void 0===h,this.size=r.reduce(((t,e)=>t+4*Math.ceil(e.components*s[e.type]/4)),0);let m,c=0;for(let t=0,l=r.length;t<l;t++){const l=r[t];m=l.components*s[l.type],h&&(c=e.roundUp(c,m));const p={name:l.semantic,offset:h?c:l.hasOwnProperty("offset")?l.offset:c,stride:h?m:l.hasOwnProperty("stride")?l.stride:this.size,dataType:l.type,numComponents:l.components,normalize:void 0!==l.normalize&&l.normalize,size:m};this._elements.push(p),c+=h?m*h:4*Math.ceil(m/4),l.semantic===n?this.hasUv0=!0:l.semantic===i?this.hasUv1=!0:l.semantic===a?this.hasColor=!0:l.semantic===o&&(this.hasTangents=!0)}h&&(this.verticesByteSize=c),this._evaluateHash()}get elements(){return this._elements}static get defaultInstancingFormat(){return p._defaultInstancingFormat||(p._defaultInstancingFormat=new p(null,[{semantic:r,components:4,type:h},{semantic:m,components:4,type:h},{semantic:c,components:4,type:h},{semantic:l,components:4,type:h}])),p._defaultInstancingFormat}_evaluateHash(){let e;const s=[];let n;const i=[],a=this._elements.length;for(let t=0;t<a;t++){const a=this._elements[t];e=a.name,e+=a.dataType,e+=a.numComponents,e+=a.normalize,s.push(e),n=e,n+=a.offset,n+=a.stride,n+=a.size,i.push(n)}s.sort(),this.batchingHash=t(s.join()),this.renderingingHashString=i.join("_"),this.renderingingHash=t(this.renderingingHashString)}}p._defaultInstancingFormat=null;export{p as VertexFormat};
