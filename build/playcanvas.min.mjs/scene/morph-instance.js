import"../core/tracing.js";import{BLENDEQUATION_ADD as t,BLENDMODE_ONE as e}from"../platform/graphics/constants.js";import{drawQuadWithShader as r}from"./graphics/quad-render-utils.js";import{RenderTarget as s}from"../platform/graphics/render-target.js";import{createShaderFromCode as i}from"./shader-lib/utils.js";import{BlendState as h}from"../platform/graphics/blend-state.js";const o=new h(!0,t,e,e);class a{constructor(t){this.morph=t,t.incRefCount(),this.device=t.device,this._weights=[],this._weightMap=new Map;for(let e=0;e<t._targets.length;e++){const r=t._targets[e];r.name&&this._weightMap.set(r.name,e),this.setWeight(e,r.defaultWeight)}if(this._activeTargets=[],t.useTextureMorph){this.shaderCache={},this.maxSubmitCount=this.device.maxTextures,this._shaderMorphWeights=new Float32Array(this.maxSubmitCount);const e=(e,r)=>(this[r]=t._createTexture(e,t._renderTextureFormat),new s({colorBuffer:this[r],depth:!1}));t.morphPositions&&(this.rtPositions=e("MorphRTPos","texturePositions")),t.morphNormals&&(this.rtNormals=e("MorphRTNrm","textureNormals")),this._textureParams=new Float32Array([t.morphTextureWidth,t.morphTextureHeight,1/t.morphTextureWidth,1/t.morphTextureHeight]);for(let t=0;t<this.maxSubmitCount;t++)this["morphBlendTex"+t]=this.device.scope.resolve("morphBlendTex"+t);this.morphFactor=this.device.scope.resolve("morphFactor[0]"),this.zeroTextures=!1}else this.maxSubmitCount=8,this._shaderMorphWeights=new Float32Array(this.maxSubmitCount),this._shaderMorphWeightsA=new Float32Array(this._shaderMorphWeights.buffer,0,4),this._shaderMorphWeightsB=new Float32Array(this._shaderMorphWeights.buffer,16,4),this._activeVertexBuffers=new Array(this.maxSubmitCount)}destroy(){this.shader=null;const t=this.morph;t&&(this.morph=null,t.decRefCount(),t.refCount<1&&t.destroy()),this.rtPositions&&(this.rtPositions.destroy(),this.rtPositions=null),this.texturePositions&&(this.texturePositions.destroy(),this.texturePositions=null),this.rtNormals&&(this.rtNormals.destroy(),this.rtNormals=null),this.textureNormals&&(this.textureNormals.destroy(),this.textureNormals=null)}clone(){return new a(this.morph)}_getWeightIndex(t){if("string"==typeof t){return this._weightMap.get(t)}return t}getWeight(t){const e=this._getWeightIndex(t);return this._weights[e]}setWeight(t,e){const r=this._getWeightIndex(t);this._weights[r]=e,this._dirty=!0}_getFragmentShader(t){let e="";t>0&&(e+="varying vec2 uv0;\nuniform highp float morphFactor["+t+"];\n");for(let r=0;r<t;r++)e+="uniform highp sampler2D morphBlendTex"+r+";\n";e+="void main (void) {\n    highp vec4 color = vec4(0, 0, 0, 1);\n";for(let r=0;r<t;r++)e+="    color.xyz += morphFactor["+r+"] * texture2D(morphBlendTex"+r+", uv0).xyz;\n";return e+="    gl_FragColor = color;\n}\n",e}_getShader(t){let e=this.shaderCache[t];if(!e){const r=this._getFragmentShader(t);e=i(this.device,"\n\t\tattribute vec2 vertex_position;\n\t\tvarying vec2 uv0;\n\t\tvoid main(void) {\n\t\t\t\tgl_Position = vec4(vertex_position, 0.5, 1.0);\n\t\t\t\tuv0 = vertex_position.xy * 0.5 + 0.5;\n\t\t}\n\t\t",r,"textureMorph"+t),this.shaderCache[t]=e}return e}_updateTextureRenderTarget(t,e){const s=this.device,i=(e,i)=>{this.morphFactor.setValue(this._shaderMorphWeights),s.setBlendState(i?o:h.DEFAULT);const a=this._getShader(e);r(s,t,a)};let a=0,n=!1;const g=this._activeTargets.length;for(let t=0;t<g;t++){const r=this._activeTargets[t],s=r.target[e];s&&(this["morphBlendTex"+a].setValue(s),this._shaderMorphWeights[a]=r.weight,a++,a>=this.maxSubmitCount&&(i(a,n),a=0,n=!0))}(a>0||0===g&&!this.zeroTextures)&&i(a,n)}_updateTextureMorph(){this.device,(this._activeTargets.length>0||!this.zeroTextures)&&(this.rtPositions&&this._updateTextureRenderTarget(this.rtPositions,"texturePositions"),this.rtNormals&&this._updateTextureRenderTarget(this.rtNormals,"textureNormals"),this.zeroTextures=0===this._activeTargets.length)}_updateVertexMorph(){const t=this.maxSubmitCount;for(let e=0;e<t;e++)this._shaderMorphWeights[e]=0,this._activeVertexBuffers[e]=null;let e=0,r=this.morph.morphPositions?4:0;for(let t=0;t<this._activeTargets.length;t++){const s=this._activeTargets[t].target;s._vertexBufferPositions&&(this._activeVertexBuffers[e]=s._vertexBufferPositions,this._shaderMorphWeights[e]=this._activeTargets[t].weight,e++),s._vertexBufferNormals&&(this._activeVertexBuffers[r]=s._vertexBufferNormals,this._shaderMorphWeights[r]=this._activeTargets[t].weight,r++)}}update(){this._dirty=!1;const t=this.morph._targets;let e=0;for(let r=0;r<t.length;r++){const s=Math.abs(this.getWeight(r));if(s>1e-5){this._activeTargets.length<=e&&(this._activeTargets[e]={});const i=this._activeTargets[e++];i.absWeight=s,i.weight=this.getWeight(r),i.target=t[r]}}this._activeTargets.length=e;const r=this.morph.maxActiveTargets;this._activeTargets.length>r&&(this._activeTargets.sort((function(t,e){return t.absWeight<e.absWeight?1:e.absWeight<t.absWeight?-1:0})),this._activeTargets.length=r),this.morph.useTextureMorph?this._updateTextureMorph():this._updateVertexMorph()}}export{a as MorphInstance};
