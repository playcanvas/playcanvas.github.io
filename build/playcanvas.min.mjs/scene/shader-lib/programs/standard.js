import{hashCode as e}from"../../../core/hash.js";import"../../../core/tracing.js";import{LIGHTTYPE_DIRECTIONAL as a,SPRITE_RENDERMODE_SLICED as n,SPRITE_RENDERMODE_TILED as t,SPECULAR_PHONG as s,FRESNEL_SCHLICK as p,BLEND_NONE as i}from"../../constants.js";import{ShaderPass as r}from"../../shader-pass.js";import{LitShader as d}from"./lit-shader.js";import{ChunkBuilder as o}from"../chunk-builder.js";import{ChunkUtils as l}from"../chunk-utils.js";import{StandardMaterialOptions as c}from"../../materials/standard-material-options.js";const h=[],u={optionsContext:new c,optionsContextMin:new c,generateKey:function(n){const t=function(e){const a=[];for(const n in e)e.hasOwnProperty(n)&&"chunks"!==n&&"lights"!==n&&a.push(n);return a.sort()};let s;n===this.optionsContextMin?(this.propsMin||(this.propsMin=t(n)),s=this.propsMin):n===this.optionsContext?(this.props||(this.props=t(n)),s=this.props):s=t(n);let p="standard";for(let e=0;e<s.length;e++)n[s[e]]&&(p+=s[e]+n[s[e]]);if(n.chunks){const e=[];for(const a in n.chunks)n.chunks.hasOwnProperty(a)&&e.push(a+n.chunks[a]);e.sort(),p+=e}if(n.litOptions)for(const e in n.litOptions)if("lights"===e){const e=n.litOptions.clusteredLightingEnabled;for(let t=0;t<n.litOptions.lights.length;t++){const s=n.litOptions.lights[t];e&&s._type!==a||(p+=s.key)}}else p+=e+n.litOptions[e];return e(p)},_getUvSourceExpression:function(e,a,s){const p=s[e],i=s[a],d=r.isForward(s.pass);let o;return d&&s.litOptions.nineSlicedMode===n||d&&s.litOptions.nineSlicedMode===t?o="nineSlicedUv":(o=0===p?"vUv"+i:"vUV"+i+"_"+p,s.heightMap&&"heightMapTransform"!==e&&(o+=" + dUvOffset")),o},_addMapDef:function(e,a){return a?`#define ${e}\n`:`#undef ${e}\n`},_addMapDefs:function(e,a,n,t,s){return this._addMapDef("MAPFLOAT",e)+this._addMapDef("MAPCOLOR",a)+this._addMapDef("MAPVERTEX",n)+this._addMapDef("MAPTEXTURE",t)+this._addMapDef("MAPINVERT",s)},_addMap:function(e,a,n,t,s,p=null){const i=e+"Map",r=i+"Uv",d=i+"Identifier",o=i+"Transform",c=i+"Channel",h=e+"VertexColorChannel",u=e+"VertexColor",g=e+"Mode",f=e+"Invert",S=n[e+"Tint"],m=n[u],M=n[i],_=n[d],A=n[g];let k=t[a];if(M){const e=this._getUvSourceExpression(o,r,n);if(k=k.replace(/\$UV/g,e).replace(/\$CH/g,n[c]),s&&-1!==k.search(/\$SAMPLER/g)){let e="texture_"+i;const a=s[_];a?e=a:s[_]=e,k=k.replace(/\$SAMPLER/g,e)}if(p&&(k="aaa"===n[c]?k.replace(/\$DECODE/g,"passThrough"):k.replace(/\$DECODE/g,l.decodeFunc(n.litOptions.gamma||"srgb"!==p?p:"linear")),k.indexOf("$texture2DSAMPLE"))){const e={linear:"texture2D",srgb:"texture2DSRGB",rgbm:"texture2DRGBM",rgbe:"texture2DRGBE"};k=k.replace(/\$texture2DSAMPLE/g,e[p]||"texture2D")}}m&&(k=k.replace(/\$VC/g,n[h])),A&&(k=k.replace(/\$DETAILMODE/g,A));const O=!!(1&S),P=!!(2&S),C=!!n[f];return k=this._addMapDefs(O,P,m,M,C)+k,k.replace(/\$/g,"")},_correctChannel:function(e,a,n){if(n[e]>0){if(n[e]<a.length)return a.substring(0,n[e]);if(n[e]>a.length){let t=a;const s=t.charAt(t.length-1),p=n[e]-t.length;for(let e=0;e<p;e++)t+=s;return t}return a}},createShaderDefinition:function(e,a){const n=new d(e,a.litOptions),l=[],c=[],u=[],g={};for(const e in h){const n=e+"Map";if(a[e+"VertexColor"]){const n=e+"VertexColorChannel";a[n]=this._correctChannel(e,a[n],h)}if(a[n]){const t=n+"Channel",s=n+"Transform",p=n+"Uv";a[p]=Math.min(a[p],1),a[t]=this._correctChannel(e,a[t],h);const i=a[p];l[i]=!0,c[i]=c[i]||a[n]&&!a[s],a[s]&&u.push({name:e,id:a[s],uv:a[p]})}}a.forceUv1&&(l[1]=!0,c[1]=void 0===c[1]||c[1]),n.generateVertexShader(l,c,u),a.litOptions.shadingModel===s?(a.litOptions.fresnelModel=0,a.litOptions.ambientSH=!1):a.litOptions.fresnelModel=0===a.litOptions.fresnelModel?p:a.litOptions.fresnelModel;const f=new o,S=new o,m=new o,M=new o;let _="";if(a.litOptions.nineSlicedMode===t?f.append("const float textureBias = -1000.0;"):f.append("uniform float textureBias;"),r.isForward(a.pass)){if(a.heightMap&&(f.append("vec2 dUvOffset;"),S.append(this._addMap("height","parallaxPS",a,n.chunks,g)),m.append("getParallax();")),a.litOptions.blendType!==i||a.litOptions.alphaTest||a.litOptions.alphaToCoverage?(f.append("float dAlpha;"),S.append(this._addMap("opacity","opacityPS",a,n.chunks,g)),m.append("getOpacity();"),M.append("_litShaderArgs.opacity = dAlpha;"),a.litOptions.alphaTest&&(S.append(n.chunks.alphaTestPS),m.append("alphaTest(dAlpha);"))):f.append("float dAlpha = 1.0;"),n.needsNormal){if((a.normalMap||a.clearCoatNormalMap)&&(S.append(a.packedNormal?n.chunks.normalXYPS:n.chunks.normalXYZPS),!a.litOptions.hasTangents)){const e=a.normalMap?"normalMap":"clearCoatNormalMap";_=this._getUvSourceExpression(`${e}Transform`,`${e}Uv`,a)}f.append("vec3 dNormalW;"),S.append(this._addMap("normalDetail","normalDetailMapPS",a,n.chunks,g)),S.append(this._addMap("normal","normalMapPS",a,n.chunks,g)),m.append("getNormal();"),M.append("_litShaderArgs.worldNormal = dNormalW;")}if(n.needsSceneColor&&f.append("uniform sampler2D uSceneColorMap;"),n.needsScreenSize&&f.append("uniform vec4 uScreenSize;"),n.needsTransforms&&(f.append("uniform mat4 matrix_viewProjection;"),f.append("uniform mat4 matrix_model;")),f.append("vec3 dAlbedo;"),a.diffuseDetail&&S.append(this._addMap("diffuseDetail","diffuseDetailMapPS",a,n.chunks,g,a.diffuseDetailEncoding)),S.append(this._addMap("diffuse","diffusePS",a,n.chunks,g,a.diffuseEncoding)),m.append("getAlbedo();"),M.append("_litShaderArgs.albedo = dAlbedo;"),a.litOptions.useRefraction&&(f.append("float dTransmission;"),S.append(this._addMap("refraction","transmissionPS",a,n.chunks,g)),m.append("getRefraction();"),M.append("_litShaderArgs.transmission = dTransmission;"),f.append("float dThickness;"),S.append(this._addMap("thickness","thicknessPS",a,n.chunks,g)),m.append("getThickness();"),M.append("_litShaderArgs.thickness = dThickness;")),a.litOptions.useIridescence&&(f.append("float dIridescence;"),S.append(this._addMap("iridescence","iridescencePS",a,n.chunks,g)),m.append("getIridescence();"),M.append("_litShaderArgs.iridescence.intensity = dIridescence;"),f.append("float dIridescenceThickness;"),S.append(this._addMap("iridescenceThickness","iridescenceThicknessPS",a,n.chunks,g)),m.append("getIridescenceThickness();"),M.append("_litShaderArgs.iridescence.thickness = dIridescenceThickness;")),n.lighting&&a.litOptions.useSpecular||n.reflections?(f.append("vec3 dSpecularity;"),f.append("float dGlossiness;"),a.litOptions.useSheen&&(f.append("vec3 sSpecularity;"),S.append(this._addMap("sheen","sheenPS",a,n.chunks,g,a.sheenEncoding)),m.append("getSheen();"),M.append("_litShaderArgs.sheen.specularity = sSpecularity;"),f.append("float sGlossiness;"),S.append(this._addMap("sheenGloss","sheenGlossPS",a,n.chunks,g)),m.append("getSheenGlossiness();"),M.append("_litShaderArgs.sheen.gloss = sGlossiness;")),a.litOptions.useMetalness&&(f.append("float dMetalness;"),S.append(this._addMap("metalness","metalnessPS",a,n.chunks,g)),m.append("getMetalness();"),M.append("_litShaderArgs.metalness = dMetalness;")),a.litOptions.useSpecularityFactor&&(f.append("float dSpecularityFactor;"),S.append(this._addMap("specularityFactor","specularityFactorPS",a,n.chunks,g)),m.append("getSpecularityFactor();"),M.append("_litShaderArgs.specularityFactor = dSpecularityFactor;")),a.litOptions.useSpecularColor?S.append(this._addMap("specular","specularPS",a,n.chunks,g,a.specularEncoding)):S.append("void getSpecularity() { dSpecularity = vec3(1); }"),S.append(this._addMap("gloss","glossPS",a,n.chunks,g)),m.append("getGlossiness();"),m.append("getSpecularity();"),M.append("_litShaderArgs.specularity = dSpecularity;"),M.append("_litShaderArgs.gloss = dGlossiness;")):(f.append("vec3 dSpecularity = vec3(0.0);"),f.append("float dGlossiness = 0.0;")),(a.aoMap||a.aoVertexColor)&&(f.append("float dAo;"),S.append(this._addMap("ao","aoPS",a,n.chunks,g)),m.append("getAO();"),M.append("_litShaderArgs.ao = dAo;")),f.append("vec3 dEmission;"),S.append(this._addMap("emissive","emissivePS",a,n.chunks,g,a.emissiveEncoding)),m.append("getEmission();"),M.append("_litShaderArgs.emission = dEmission;"),a.litOptions.useClearCoat&&(f.append("float ccSpecularity;"),f.append("float ccGlossiness;"),f.append("vec3 ccNormalW;"),S.append(this._addMap("clearCoat","clearCoatPS",a,n.chunks,g)),S.append(this._addMap("clearCoatGloss","clearCoatGlossPS",a,n.chunks,g)),S.append(this._addMap("clearCoatNormal","clearCoatNormalPS",a,n.chunks,g)),m.append("getClearCoat();"),m.append("getClearCoatGlossiness();"),m.append("getClearCoatNormal();"),M.append("_litShaderArgs.clearcoat.specularity = ccSpecularity;"),M.append("_litShaderArgs.clearcoat.gloss = ccGlossiness;"),M.append("_litShaderArgs.clearcoat.worldNormal = ccNormalW;")),a.lightMap||a.lightVertexColor){const e=a.dirLightMap&&a.litOptions.useSpecular,t=e?"lightmapDirPS":"lightmapSinglePS";f.append("vec3 dLightmap;"),e&&f.append("vec3 dLightmapDir;"),S.append(this._addMap("light",t,a,n.chunks,g,a.lightMapEncoding)),m.append("getLightMap();"),M.append("_litShaderArgs.lightmap = dLightmap;"),e&&M.append("_litShaderArgs.lightmapDir = dLightmapDir;")}-1===S.code.indexOf("texture2DSRGB")&&-1===S.code.indexOf("texture2DRGBM")&&-1===S.code.indexOf("texture2DRGBE")||S.prepend(n.chunks.textureSamplePS)}else a.litOptions.alphaTest&&(f.append("float dAlpha;"),S.append(this._addMap("opacity","opacityPS",a,n.chunks,g)),S.append(n.chunks.alphaTestPS),m.append("getOpacity();"),m.append("alphaTest(dAlpha);"),M.append("_litShaderArgs.opacity = dAlpha;"));f.append(n.chunks.litShaderArgsPS),S.append(`LitShaderArguments evaluateFrontend() { LitShaderArguments _litShaderArgs; \n${m.code}\n${M.code}\n return _litShaderArgs;\n }\n`),m.code="LitShaderArguments litShaderArgs = evaluateFrontend();";for(const e in g)f.append(`uniform sampler2D ${g[e]};`);return m.code=`\n${m.code.split("\n").map((e=>`    ${e}`)).join("\n")}\n\n`,n.generateFragmentShader(f.code,S.code,m.code,_),n.getDefinition()}};export{h as _matTex2D,u as standard};
