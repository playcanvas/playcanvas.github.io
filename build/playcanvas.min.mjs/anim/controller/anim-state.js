import"../../core/tracing.js";import{AnimBlendTree1D as t}from"./anim-blend-tree-1d.js";import{AnimBlendTreeCartesian2D as e}from"./anim-blend-tree-2d-cartesian.js";import{AnimBlendTreeDirectional2D as n}from"./anim-blend-tree-2d-directional.js";import{AnimBlendTreeDirect as i}from"./anim-blend-tree-direct.js";import{AnimNode as r}from"./anim-node.js";import{ANIM_BLEND_DIRECT as s,ANIM_BLEND_2D_DIRECTIONAL as a,ANIM_BLEND_2D_CARTESIAN as o,ANIM_BLEND_1D as m,ANIM_CONTROL_STATES as h}from"./constants.js";class l{constructor(t,e,n,i,s){this._controller=t,this._name=e,this._animations={},this._animationList=[],this._speed=n||1,this._loop=void 0===i||i;const a=this._controller.findParameter.bind(this._controller);this._blendTree=s?this._createTree(s.type,this,null,e,1,s.parameter?[s.parameter]:s.parameters,s.children,s.syncAnimations,this._createTree,a):new r(this,null,e,1,n)}_createTree(r,h,l,d,c,u,_,p,g,f){switch(r){case m:return new t(h,l,d,c,u,_,p,g,f);case o:return new e(h,l,d,c,u,_,p,g,f);case a:return new n(h,l,d,c,u,_,p,g,f);case s:return new i(h,l,d,c,u,_,p,g,f)}}_getNodeFromPath(t){let e=this._blendTree;for(let n=1;n<t.length;n++)e=e.getChild(t[n]);return e}addAnimation(t,e){const n=t.join("."),i=this._animationList.findIndex((function(t){return t.path===n}));if(i>=0)this._animationList[i].animTrack=e;else{const n=this._getNodeFromPath(t);n.animTrack=e,this._animationList.push(n)}}get name(){return this._name}set animations(t){this._animationList=t}get animations(){return this._animationList}set speed(t){this._speed=t}get speed(){return this._speed}set loop(t){this._loop=t}get loop(){return this._loop}get nodeCount(){return this._blendTree&&this._blendTree.constructor!==r?this._blendTree.getNodeCount():1}get playable(){return-1!==h.indexOf(this.name)||this.animations.length===this.nodeCount}get looping(){if(this.animations.length>0){const t=this.name+"."+this.animations[0].animTrack.name,e=this._controller.animEvaluator.findClip(t);if(e)return e.loop}return!1}get totalWeight(){let t=0;for(let e=0;e<this.animations.length;e++)t+=this.animations[e].weight;return t}get timelineDuration(){let t=0;for(let e=0;e<this.animations.length;e++){const n=this.animations[e];n.animTrack.duration>t&&(t=n.animTrack.duration)}return t}}export{l as AnimState};
