/**
 * @license
 * PlayCanvas Engine v1.56.0 revision 50ffa14a7
 * Copyright 2011-2022 PlayCanvas Ltd. All rights reserved.
 */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.pc = {}));
})(this, (function (exports) { 'use strict';

	function defineProtoFunc(cls, name, func) {
	  if (!cls.prototype[name]) {
	    Object.defineProperty(cls.prototype, name, {
	      value: func,
	      configurable: true,
	      enumerable: false,
	      writable: true
	    });
	  }
	}

	defineProtoFunc(Array, 'fill', function (value) {
	  if (this == null) {
	    throw new TypeError('this is null or not defined');
	  }

	  var O = Object(this);
	  var len = O.length >>> 0;
	  var start = arguments[1];
	  var relativeStart = start >> 0;
	  var k = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);
	  var end = arguments[2];
	  var relativeEnd = end === undefined ? len : end >> 0;
	  var finalValue = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len);

	  while (k < finalValue) {
	    O[k] = value;
	    k++;
	  }

	  return O;
	});

	defineProtoFunc(Array, 'find', function (predicate) {
	  if (this == null) {
	    throw TypeError('"this" is null or not defined');
	  }

	  var o = Object(this);
	  var len = o.length >>> 0;

	  if (typeof predicate !== 'function') {
	    throw TypeError('predicate must be a function');
	  }

	  var thisArg = arguments[1];
	  var k = 0;

	  while (k < len) {
	    var kValue = o[k];

	    if (predicate.call(thisArg, kValue, k, o)) {
	      return kValue;
	    }

	    k++;
	  }

	  return undefined;
	});

	defineProtoFunc(Array, 'findIndex', function (predicate) {
	  if (this == null) {
	    throw new TypeError('"this" is null or not defined');
	  }

	  var o = Object(this);
	  var len = o.length >>> 0;

	  if (typeof predicate !== 'function') {
	    throw new TypeError('predicate must be a function');
	  }

	  var thisArg = arguments[1];
	  var k = 0;

	  while (k < len) {
	    var kValue = o[k];

	    if (predicate.call(thisArg, kValue, k, o)) {
	      return k;
	    }

	    k++;
	  }

	  return -1;
	});

	Math.log2 = Math.log2 || function (x) {
	  return Math.log(x) * Math.LOG2E;
	};

	if (!Math.sign) {
	  Math.sign = function (x) {
	    return (x > 0) - (x < 0) || +x;
	  };
	}

	if (Number.isFinite === undefined) Number.isFinite = function (value) {
	  return typeof value === 'number' && isFinite(value);
	};

	if (typeof Object.assign != 'function') {
	  Object.defineProperty(Object, "assign", {
	    value: function assign(target, varArgs) {

	      if (target == null) {
	        throw new TypeError('Cannot convert undefined or null to object');
	      }

	      var to = Object(target);

	      for (var index = 1; index < arguments.length; index++) {
	        var nextSource = arguments[index];

	        if (nextSource != null) {
	          for (var nextKey in nextSource) {
	            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
	              to[nextKey] = nextSource[nextKey];
	            }
	          }
	        }
	      }

	      return to;
	    },
	    writable: true,
	    configurable: true
	  });
	}

	Object.values = Object.values || function (object) {
	  return Object.keys(object).map(function (key) {
	    return object[key];
	  });
	};

	(function () {
	  if (typeof navigator === 'undefined' || typeof document === 'undefined') {
	    return;
	  }

	  navigator.pointer = navigator.pointer || navigator.webkitPointer || navigator.mozPointer;

	  var pointerlockchange = function pointerlockchange() {
	    var e = document.createEvent('CustomEvent');
	    e.initCustomEvent('pointerlockchange', true, false, null);
	    document.dispatchEvent(e);
	  };

	  var pointerlockerror = function pointerlockerror() {
	    var e = document.createEvent('CustomEvent');
	    e.initCustomEvent('pointerlockerror', true, false, null);
	    document.dispatchEvent(e);
	  };

	  document.addEventListener('webkitpointerlockchange', pointerlockchange, false);
	  document.addEventListener('webkitpointerlocklost', pointerlockchange, false);
	  document.addEventListener('mozpointerlockchange', pointerlockchange, false);
	  document.addEventListener('mozpointerlocklost', pointerlockchange, false);
	  document.addEventListener('webkitpointerlockerror', pointerlockerror, false);
	  document.addEventListener('mozpointerlockerror', pointerlockerror, false);

	  if (Element.prototype.mozRequestPointerLock) {
	    Element.prototype.requestPointerLock = function () {
	      this.mozRequestPointerLock();
	    };
	  } else {
	    Element.prototype.requestPointerLock = Element.prototype.requestPointerLock || Element.prototype.webkitRequestPointerLock || Element.prototype.mozRequestPointerLock;
	  }

	  if (!Element.prototype.requestPointerLock && navigator.pointer) {
	    Element.prototype.requestPointerLock = function () {
	      var el = this;
	      document.pointerLockElement = el;
	      navigator.pointer.lock(el, pointerlockchange, pointerlockerror);
	    };
	  }

	  document.exitPointerLock = document.exitPointerLock || document.webkitExitPointerLock || document.mozExitPointerLock;

	  if (!document.exitPointerLock) {
	    document.exitPointerLock = function () {
	      if (navigator.pointer) {
	        document.pointerLockElement = null;
	        navigator.pointer.unlock();
	      }
	    };
	  }
	})();

	(function () {
	  if (typeof window === 'undefined') return;
	  var lastTime = 0;
	  var vendors = ['ms', 'moz', 'webkit', 'o'];

	  for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
	    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
	    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];
	  }

	  if (!window.requestAnimationFrame) window.requestAnimationFrame = function (callback, element) {
	    var currTime = new Date().getTime();
	    var timeToCall = Math.max(0, 16 - (currTime - lastTime));
	    var id = window.setTimeout(function () {
	      callback(currTime + timeToCall);
	    }, timeToCall);
	    lastTime = currTime + timeToCall;
	    return id;
	  };
	  if (!window.cancelAnimationFrame) window.cancelAnimationFrame = function (id) {
	    clearTimeout(id);
	  };
	})();

	defineProtoFunc(String, 'endsWith', function (search, this_len) {
	  if (this_len === undefined || this_len > this.length) {
	    this_len = this.length;
	  }

	  return this.substring(this_len - search.length, this_len) === search;
	});
	defineProtoFunc(String, 'includes', function (search, start) {

	  if (typeof start !== 'number') {
	    start = 0;
	  }

	  if (start + search.length > this.length) {
	    return false;
	  } else {
	    return this.indexOf(search, start) !== -1;
	  }
	});
	defineProtoFunc(String, 'startsWith', function (search, rawPos) {
	  var pos = rawPos > 0 ? rawPos | 0 : 0;
	  return this.substring(pos, pos + search.length) === search;
	});
	defineProtoFunc(String, 'trimEnd', function () {
	  return this.replace(new RegExp(/[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]+/.source + '$', 'g'), '');
	});

	var typedArrays = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array];

	for (var _i = 0, _typedArrays = typedArrays; _i < _typedArrays.length; _i++) {
	  var typedArray = _typedArrays[_i];
	  defineProtoFunc(typedArray, "fill", Array.prototype.fill);
	  defineProtoFunc(typedArray, "join", Array.prototype.join);
	}

	var glErrorShadow = {};

	function error(msg) {
	  if (window.console && window.console.error) {
	    window.console.error(msg);
	  }
	}

	function log$1(msg) {
	  if (window.console && window.console.log) {
	    window.console.log(msg);
	  }
	}

	function synthesizeGLError(err, opt_msg) {
	  glErrorShadow[err] = true;

	  if (opt_msg !== undefined) {
	    error(opt_msg);
	  }
	}

	function wrapGLError(gl) {
	  var f = gl.getError;

	  gl.getError = function () {
	    var err;

	    do {
	      err = f.apply(gl);

	      if (err != gl.NO_ERROR) {
	        glErrorShadow[err] = true;
	      }
	    } while (err != gl.NO_ERROR);

	    for (var err in glErrorShadow) {
	      if (glErrorShadow[err]) {
	        delete glErrorShadow[err];
	        return parseInt(err);
	      }
	    }

	    return gl.NO_ERROR;
	  };
	}

	var WebGLVertexArrayObjectOES = function WebGLVertexArrayObjectOES(ext) {
	  var gl = ext.gl;
	  this.ext = ext;
	  this.isAlive = true;
	  this.hasBeenBound = false;
	  this.elementArrayBuffer = null;
	  this.attribs = new Array(ext.maxVertexAttribs);

	  for (var n = 0; n < this.attribs.length; n++) {
	    var attrib = new WebGLVertexArrayObjectOES.VertexAttrib(gl);
	    this.attribs[n] = attrib;
	  }

	  this.maxAttrib = 0;
	};

	WebGLVertexArrayObjectOES.VertexAttrib = function VertexAttrib(gl) {
	  this.enabled = false;
	  this.buffer = null;
	  this.size = 4;
	  this.type = gl.FLOAT;
	  this.normalized = false;
	  this.stride = 16;
	  this.offset = 0;
	  this.cached = "";
	  this.recache();
	};

	WebGLVertexArrayObjectOES.VertexAttrib.prototype.recache = function recache() {
	  this.cached = [this.size, this.type, this.normalized, this.stride, this.offset].join(":");
	};

	var OESVertexArrayObject = function OESVertexArrayObject(gl) {
	  var self = this;
	  this.gl = gl;
	  wrapGLError(gl);
	  var original = this.original = {
	    getParameter: gl.getParameter,
	    enableVertexAttribArray: gl.enableVertexAttribArray,
	    disableVertexAttribArray: gl.disableVertexAttribArray,
	    bindBuffer: gl.bindBuffer,
	    getVertexAttrib: gl.getVertexAttrib,
	    vertexAttribPointer: gl.vertexAttribPointer
	  };

	  gl.getParameter = function getParameter(pname) {
	    if (pname == self.VERTEX_ARRAY_BINDING_OES) {
	      if (self.currentVertexArrayObject == self.defaultVertexArrayObject) {
	        return null;
	      } else {
	        return self.currentVertexArrayObject;
	      }
	    }

	    return original.getParameter.apply(this, arguments);
	  };

	  gl.enableVertexAttribArray = function enableVertexAttribArray(index) {
	    var vao = self.currentVertexArrayObject;
	    vao.maxAttrib = Math.max(vao.maxAttrib, index);
	    var attrib = vao.attribs[index];
	    attrib.enabled = true;
	    return original.enableVertexAttribArray.apply(this, arguments);
	  };

	  gl.disableVertexAttribArray = function disableVertexAttribArray(index) {
	    var vao = self.currentVertexArrayObject;
	    vao.maxAttrib = Math.max(vao.maxAttrib, index);
	    var attrib = vao.attribs[index];
	    attrib.enabled = false;
	    return original.disableVertexAttribArray.apply(this, arguments);
	  };

	  gl.bindBuffer = function bindBuffer(target, buffer) {
	    switch (target) {
	      case gl.ARRAY_BUFFER:
	        self.currentArrayBuffer = buffer;
	        break;

	      case gl.ELEMENT_ARRAY_BUFFER:
	        self.currentVertexArrayObject.elementArrayBuffer = buffer;
	        break;
	    }

	    return original.bindBuffer.apply(this, arguments);
	  };

	  gl.getVertexAttrib = function getVertexAttrib(index, pname) {
	    var vao = self.currentVertexArrayObject;
	    var attrib = vao.attribs[index];

	    switch (pname) {
	      case gl.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:
	        return attrib.buffer;

	      case gl.VERTEX_ATTRIB_ARRAY_ENABLED:
	        return attrib.enabled;

	      case gl.VERTEX_ATTRIB_ARRAY_SIZE:
	        return attrib.size;

	      case gl.VERTEX_ATTRIB_ARRAY_STRIDE:
	        return attrib.stride;

	      case gl.VERTEX_ATTRIB_ARRAY_TYPE:
	        return attrib.type;

	      case gl.VERTEX_ATTRIB_ARRAY_NORMALIZED:
	        return attrib.normalized;

	      default:
	        return original.getVertexAttrib.apply(this, arguments);
	    }
	  };

	  gl.vertexAttribPointer = function vertexAttribPointer(indx, size, type, normalized, stride, offset) {
	    var vao = self.currentVertexArrayObject;
	    vao.maxAttrib = Math.max(vao.maxAttrib, indx);
	    var attrib = vao.attribs[indx];
	    attrib.buffer = self.currentArrayBuffer;
	    attrib.size = size;
	    attrib.type = type;
	    attrib.normalized = normalized;
	    attrib.stride = stride;
	    attrib.offset = offset;
	    attrib.recache();
	    return original.vertexAttribPointer.apply(this, arguments);
	  };

	  if (gl.instrumentExtension) {
	    gl.instrumentExtension(this, "OES_vertex_array_object");
	  }

	  gl.canvas.addEventListener('webglcontextrestored', function () {
	    log$1("OESVertexArrayObject emulation library context restored");
	    self.reset_();
	  }, true);
	  this.reset_();
	};

	OESVertexArrayObject.prototype.VERTEX_ARRAY_BINDING_OES = 0x85B5;

	OESVertexArrayObject.prototype.reset_ = function reset_() {
	  var contextWasLost = this.vertexArrayObjects !== undefined;

	  if (contextWasLost) {
	    for (var ii = 0; ii < this.vertexArrayObjects.length; ++ii) {
	      this.vertexArrayObjects.isAlive = false;
	    }
	  }

	  var gl = this.gl;
	  this.maxVertexAttribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
	  this.defaultVertexArrayObject = new WebGLVertexArrayObjectOES(this);
	  this.currentVertexArrayObject = null;
	  this.currentArrayBuffer = null;
	  this.vertexArrayObjects = [this.defaultVertexArrayObject];
	  this.bindVertexArrayOES(null);
	};

	OESVertexArrayObject.prototype.createVertexArrayOES = function createVertexArrayOES() {
	  var arrayObject = new WebGLVertexArrayObjectOES(this);
	  this.vertexArrayObjects.push(arrayObject);
	  return arrayObject;
	};

	OESVertexArrayObject.prototype.deleteVertexArrayOES = function deleteVertexArrayOES(arrayObject) {
	  arrayObject.isAlive = false;
	  this.vertexArrayObjects.splice(this.vertexArrayObjects.indexOf(arrayObject), 1);

	  if (this.currentVertexArrayObject == arrayObject) {
	    this.bindVertexArrayOES(null);
	  }
	};

	OESVertexArrayObject.prototype.isVertexArrayOES = function isVertexArrayOES(arrayObject) {
	  if (arrayObject && arrayObject instanceof WebGLVertexArrayObjectOES) {
	    if (arrayObject.hasBeenBound && arrayObject.ext == this) {
	      return true;
	    }
	  }

	  return false;
	};

	OESVertexArrayObject.prototype.bindVertexArrayOES = function bindVertexArrayOES(arrayObject) {
	  var gl = this.gl;

	  if (arrayObject && !arrayObject.isAlive) {
	    synthesizeGLError(gl.INVALID_OPERATION, "bindVertexArrayOES: attempt to bind deleted arrayObject");
	    return;
	  }

	  var original = this.original;
	  var oldVAO = this.currentVertexArrayObject;
	  this.currentVertexArrayObject = arrayObject || this.defaultVertexArrayObject;
	  this.currentVertexArrayObject.hasBeenBound = true;
	  var newVAO = this.currentVertexArrayObject;

	  if (oldVAO == newVAO) {
	    return;
	  }

	  if (!oldVAO || newVAO.elementArrayBuffer != oldVAO.elementArrayBuffer) {
	    original.bindBuffer.call(gl, gl.ELEMENT_ARRAY_BUFFER, newVAO.elementArrayBuffer);
	  }

	  var currentBinding = this.currentArrayBuffer;
	  var maxAttrib = Math.max(oldVAO ? oldVAO.maxAttrib : 0, newVAO.maxAttrib);

	  for (var n = 0; n <= maxAttrib; n++) {
	    var attrib = newVAO.attribs[n];
	    var oldAttrib = oldVAO ? oldVAO.attribs[n] : null;

	    if (!oldVAO || attrib.enabled != oldAttrib.enabled) {
	      if (attrib.enabled) {
	        original.enableVertexAttribArray.call(gl, n);
	      } else {
	        original.disableVertexAttribArray.call(gl, n);
	      }
	    }

	    if (attrib.enabled) {
	      var bufferChanged = false;

	      if (!oldVAO || attrib.buffer != oldAttrib.buffer) {
	        if (currentBinding != attrib.buffer) {
	          original.bindBuffer.call(gl, gl.ARRAY_BUFFER, attrib.buffer);
	          currentBinding = attrib.buffer;
	        }

	        bufferChanged = true;
	      }

	      if (bufferChanged || attrib.cached != oldAttrib.cached) {
	        original.vertexAttribPointer.call(gl, n, attrib.size, attrib.type, attrib.normalized, attrib.stride, attrib.offset);
	      }
	    }
	  }

	  if (this.currentArrayBuffer != currentBinding) {
	    original.bindBuffer.call(gl, gl.ARRAY_BUFFER, this.currentArrayBuffer);
	  }
	};

	var setupVertexArrayObject = function setupVertexArrayObject(gl) {
	  if (gl.getSupportedExtensions) {
	    var exts = gl.getSupportedExtensions();

	    if (exts.indexOf("OES_vertex_array_object") != -1) {
	      return;
	    }
	  } else if (gl.getExtension) {
	    var vao = gl.getExtension("OES_vertex_array_object");

	    if (vao) {
	      return;
	    }
	  }

	  if (gl.getSupportedExtensions) {
	    var original_getSupportedExtensions = gl.getSupportedExtensions;

	    gl.getSupportedExtensions = function getSupportedExtensions() {
	      var list = original_getSupportedExtensions.call(this) || [];
	      list.push("OES_vertex_array_object");
	      return list;
	    };
	  }

	  var original_getExtension = gl.getExtension;

	  gl.getExtension = function getExtension(name) {
	    if (name == "OES_vertex_array_object") {
	      if (!gl.__OESVertexArrayObject) {
	        gl.__OESVertexArrayObject = new OESVertexArrayObject(gl);
	      }

	      return gl.__OESVertexArrayObject;
	    }

	    if (original_getExtension) {
	      return original_getExtension.call(this, name);
	    } else {
	      return null;
	    }
	  };
	};

	var TRACEID_RENDER_FRAME = 'RenderFrame';
	var TRACEID_RENDER_PASS = 'RenderPass';
	var TRACEID_RENDER_PASS_DETAIL = 'RenderPassDetail';
	var TRACEID_RENDER_ACTION = 'RenderAction';
	var TRACEID_RENDER_TARGET_ALLOC = 'RenderTargetAlloc';
	var TRACEID_TEXTURE_ALLOC = 'TextureAlloc';
	var TRACEID_SHADER_ALLOC = 'ShaderAlloc';
	var TRACEID_VRAM_TEXTURE = 'VRAM.Texture';
	var TRACEID_VRAM_VB = 'VRAM.Vb';
	var TRACEID_VRAM_IB = 'VRAM.Ib';

	var version = '1.56.0';
	var revision = '50ffa14a7';
	var config = {};
	var common = {};
	var apps = {};
	var data = {};

	var _typeLookup = function () {
	  var result = {};
	  var names = ['Array', 'Object', 'Function', 'Date', 'RegExp', 'Float32Array'];

	  for (var i = 0; i < names.length; i++) {
	    result['[object ' + names[i] + ']'] = names[i].toLowerCase();
	  }

	  return result;
	}();

	function type$1(obj) {
	  if (obj === null) {
	    return 'null';
	  }

	  var type = typeof obj;

	  if (type === 'undefined' || type === 'number' || type === 'string' || type === 'boolean') {
	    return type;
	  }

	  return _typeLookup[Object.prototype.toString.call(obj)];
	}

	function extend(target, ex) {
	  for (var prop in ex) {
	    var copy = ex[prop];

	    if (type$1(copy) === 'object') {
	      target[prop] = extend({}, copy);
	    } else if (type$1(copy) === 'array') {
	      target[prop] = extend([], copy);
	    } else {
	      target[prop] = copy;
	    }
	  }

	  return target;
	}

	function isDefined(o) {
	  var a;
	  return o !== a;
	}

	var EventHandler = function () {
	  function EventHandler() {
	    this._callbacks = {};
	    this._callbackActive = {};
	  }

	  var _proto = EventHandler.prototype;

	  _proto.initEventHandler = function initEventHandler() {
	    this._callbacks = {};
	    this._callbackActive = {};
	  };

	  _proto._addCallback = function _addCallback(name, callback, scope, once) {
	    if (once === void 0) {
	      once = false;
	    }

	    if (!name || typeof name !== 'string' || !callback) return;
	    if (!this._callbacks[name]) this._callbacks[name] = [];
	    if (this._callbackActive[name] && this._callbackActive[name] === this._callbacks[name]) this._callbackActive[name] = this._callbackActive[name].slice();

	    this._callbacks[name].push({
	      callback: callback,
	      scope: scope || this,
	      once: once
	    });
	  };

	  _proto.on = function on(name, callback, scope) {
	    this._addCallback(name, callback, scope, false);

	    return this;
	  };

	  _proto.off = function off(name, callback, scope) {
	    if (name) {
	      if (this._callbackActive[name] && this._callbackActive[name] === this._callbacks[name]) this._callbackActive[name] = this._callbackActive[name].slice();
	    } else {
	      for (var key in this._callbackActive) {
	        if (!this._callbacks[key]) continue;
	        if (this._callbacks[key] !== this._callbackActive[key]) continue;
	        this._callbackActive[key] = this._callbackActive[key].slice();
	      }
	    }

	    if (!name) {
	      this._callbacks = {};
	    } else if (!callback) {
	      if (this._callbacks[name]) this._callbacks[name] = [];
	    } else {
	      var events = this._callbacks[name];
	      if (!events) return this;
	      var count = events.length;

	      for (var i = 0; i < count; i++) {
	        if (events[i].callback !== callback) continue;
	        if (scope && events[i].scope !== scope) continue;
	        events[i--] = events[--count];
	      }

	      events.length = count;
	    }

	    return this;
	  };

	  _proto.fire = function fire(name, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {
	    if (!name || !this._callbacks[name]) return this;
	    var callbacks;

	    if (!this._callbackActive[name]) {
	      this._callbackActive[name] = this._callbacks[name];
	    } else {
	      if (this._callbackActive[name] === this._callbacks[name]) this._callbackActive[name] = this._callbackActive[name].slice();
	      callbacks = this._callbacks[name].slice();
	    }

	    for (var i = 0; (callbacks || this._callbackActive[name]) && i < (callbacks || this._callbackActive[name]).length; i++) {
	      var evt = (callbacks || this._callbackActive[name])[i];
	      evt.callback.call(evt.scope, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);

	      if (evt.once) {
	        var existingCallback = this._callbacks[name];
	        var ind = existingCallback ? existingCallback.indexOf(evt) : -1;

	        if (ind !== -1) {
	          if (this._callbackActive[name] === existingCallback) this._callbackActive[name] = this._callbackActive[name].slice();

	          this._callbacks[name].splice(ind, 1);
	        }
	      }
	    }

	    if (!callbacks) this._callbackActive[name] = null;
	    return this;
	  };

	  _proto.once = function once(name, callback, scope) {
	    this._addCallback(name, callback, scope, true);

	    return this;
	  };

	  _proto.hasEvent = function hasEvent(name) {
	    return this._callbacks[name] && this._callbacks[name].length !== 0 || false;
	  };

	  return EventHandler;
	}();

	var events = {
	  attach: function attach(target) {
	    var ev = events;
	    target._addCallback = ev._addCallback;
	    target.on = ev.on;
	    target.off = ev.off;
	    target.fire = ev.fire;
	    target.once = ev.once;
	    target.hasEvent = ev.hasEvent;
	    target._callbacks = {};
	    target._callbackActive = {};
	    return target;
	  },
	  _addCallback: EventHandler.prototype._addCallback,
	  on: EventHandler.prototype.on,
	  off: EventHandler.prototype.off,
	  fire: EventHandler.prototype.fire,
	  once: EventHandler.prototype.once,
	  hasEvent: EventHandler.prototype.hasEvent
	};

	var guid = {
	  create: function create() {
	    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
	      var r = Math.random() * 16 | 0;
	      var v = c === 'x' ? r : r & 0x3 | 0x8;
	      return v.toString(16);
	    });
	  }
	};

	var path = {
	  delimiter: '/',
	  join: function join() {
	    var num = arguments.length;
	    var result = arguments[0];

	    for (var index = 0; index < num - 1; ++index) {
	      var one = arguments[index];
	      var two = arguments[index + 1];

	      if (!isDefined(one) || !isDefined(two)) {
	        throw new Error('undefined argument to pc.path.join');
	      }

	      if (two[0] === path.delimiter) {
	        result = two;
	        continue;
	      }

	      if (one && two && one[one.length - 1] !== path.delimiter && two[0] !== path.delimiter) {
	        result += path.delimiter + two;
	      } else {
	        result += two;
	      }
	    }

	    return result;
	  },
	  normalize: function normalize(pathname) {
	    var lead = pathname.startsWith(path.delimiter);
	    var trail = pathname.endsWith(path.delimiter);
	    var parts = pathname.split('/');
	    var result = '';
	    var cleaned = [];

	    for (var i = 0; i < parts.length; i++) {
	      if (parts[i] === '') continue;
	      if (parts[i] === '.') continue;

	      if (parts[i] === '..' && cleaned.length > 0) {
	        cleaned = cleaned.slice(0, cleaned.length - 2);
	        continue;
	      }

	      if (i > 0) cleaned.push(path.delimiter);
	      cleaned.push(parts[i]);
	    }

	    result = cleaned.join('');

	    if (!lead && result[0] === path.delimiter) {
	      result = result.slice(1);
	    }

	    if (trail && result[result.length - 1] !== path.delimiter) {
	      result += path.delimiter;
	    }

	    return result;
	  },
	  split: function split(pathname) {
	    var parts = pathname.split(path.delimiter);
	    var tail = parts.slice(parts.length - 1)[0];
	    var head = parts.slice(0, parts.length - 1).join(path.delimiter);
	    return [head, tail];
	  },
	  getBasename: function getBasename(pathname) {
	    return path.split(pathname)[1];
	  },
	  getDirectory: function getDirectory(pathname) {
	    var parts = pathname.split(path.delimiter);
	    return parts.slice(0, parts.length - 1).join(path.delimiter);
	  },
	  getExtension: function getExtension(pathname) {
	    var ext = pathname.split('?')[0].split('.').pop();

	    if (ext !== pathname) {
	      return '.' + ext;
	    }

	    return '';
	  },
	  isRelativePath: function isRelativePath(pathname) {
	    return pathname.charAt(0) !== '/' && pathname.match(/:\/\//) === null;
	  },
	  extractPath: function extractPath(pathname) {
	    var result = '';
	    var parts = pathname.split('/');
	    var i = 0;

	    if (parts.length > 1) {
	      if (path.isRelativePath(pathname)) {
	        if (parts[0] === '.') {
	          for (i = 0; i < parts.length - 1; ++i) {
	            result += i === 0 ? parts[i] : '/' + parts[i];
	          }
	        } else if (parts[0] === '..') {
	          for (i = 0; i < parts.length - 1; ++i) {
	            result += i === 0 ? parts[i] : '/' + parts[i];
	          }
	        } else {
	          result = '.';

	          for (i = 0; i < parts.length - 1; ++i) {
	            result += '/' + parts[i];
	          }
	        }
	      } else {
	        for (i = 0; i < parts.length - 1; ++i) {
	          result += i === 0 ? parts[i] : '/' + parts[i];
	        }
	      }
	    }

	    return result;
	  }
	};

	var desktop = false;
	var mobile = false;
	var windows = false;
	var xbox = false;
	var android = false;
	var ios = false;
	var touch = false;
	var gamepads = false;
	var workers = false;
	var passiveEvents = false;

	if (typeof navigator !== 'undefined') {
	  var ua = navigator.userAgent;
	  if (/(windows|mac os|linux|cros)/i.test(ua)) desktop = true;
	  if (/xbox/i.test(ua)) xbox = true;

	  if (/(windows phone|iemobile|wpdesktop)/i.test(ua)) {
	    desktop = false;
	    mobile = true;
	    windows = true;
	  } else if (/android/i.test(ua)) {
	    desktop = false;
	    mobile = true;
	    android = true;
	  } else if (/ip([ao]d|hone)/i.test(ua)) {
	    desktop = false;
	    mobile = true;
	    ios = true;
	  }

	  if (typeof window !== 'undefined') {
	    touch = 'ontouchstart' in window || 'maxTouchPoints' in navigator && navigator.maxTouchPoints > 0;
	  }

	  gamepads = 'getGamepads' in navigator;
	  workers = typeof Worker !== 'undefined';

	  try {
	    var opts = Object.defineProperty({}, 'passive', {
	      get: function get() {
	        passiveEvents = true;
	        return false;
	      }
	    });
	    window.addEventListener('testpassive', null, opts);
	    window.removeEventListener('testpassive', null, opts);
	  } catch (e) {}
	}

	var environment = typeof window !== 'undefined' ? 'browser' : 'node';
	var platform = {
	  environment: environment,
	  global: environment === 'browser' ? window : global,
	  browser: environment === 'browser',
	  desktop: desktop,
	  mobile: mobile,
	  ios: ios,
	  android: android,
	  windows: windows,
	  xbox: xbox,
	  gamepads: gamepads,
	  touch: touch,
	  workers: workers,
	  passiveEvents: passiveEvents
	};

	var ASCII_LOWERCASE = 'abcdefghijklmnopqrstuvwxyz';
	var ASCII_UPPERCASE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
	var ASCII_LETTERS = ASCII_LOWERCASE + ASCII_UPPERCASE;
	var HIGH_SURROGATE_BEGIN = 0xD800;
	var HIGH_SURROGATE_END = 0xDBFF;
	var LOW_SURROGATE_BEGIN = 0xDC00;
	var LOW_SURROGATE_END = 0xDFFF;
	var ZERO_WIDTH_JOINER = 0x200D;
	var REGIONAL_INDICATOR_BEGIN = 0x1F1E6;
	var REGIONAL_INDICATOR_END = 0x1F1FF;
	var FITZPATRICK_MODIFIER_BEGIN = 0x1F3FB;
	var FITZPATRICK_MODIFIER_END = 0x1F3FF;
	var DIACRITICAL_MARKS_BEGIN = 0x20D0;
	var DIACRITICAL_MARKS_END = 0x20FF;
	var VARIATION_MODIFIER_BEGIN = 0xFE00;
	var VARIATION_MODIFIER_END = 0xFE0F;

	function getCodePointData(string, i) {
	  if (i === void 0) {
	    i = 0;
	  }

	  var size = string.length;

	  if (i < 0 || i >= size) {
	    return null;
	  }

	  var first = string.charCodeAt(i);

	  if (size > 1 && first >= HIGH_SURROGATE_BEGIN && first <= HIGH_SURROGATE_END) {
	    var second = string.charCodeAt(i + 1);

	    if (second >= LOW_SURROGATE_BEGIN && second <= LOW_SURROGATE_END) {
	      return {
	        code: (first - HIGH_SURROGATE_BEGIN) * 0x400 + second - LOW_SURROGATE_BEGIN + 0x10000,
	        long: true
	      };
	    }
	  }

	  return {
	    code: first,
	    long: false
	  };
	}

	function isCodeBetween(string, begin, end) {
	  if (!string) return false;
	  var codeData = getCodePointData(string);

	  if (codeData) {
	    var code = codeData.code;
	    return code >= begin && code <= end;
	  }

	  return false;
	}

	function numCharsToTakeForNextSymbol(string, index) {
	  if (index === string.length - 1) {
	    return 1;
	  }

	  if (isCodeBetween(string[index], HIGH_SURROGATE_BEGIN, HIGH_SURROGATE_END)) {
	    var first = string.substring(index, index + 2);
	    var second = string.substring(index + 2, index + 4);

	    if (isCodeBetween(second, FITZPATRICK_MODIFIER_BEGIN, FITZPATRICK_MODIFIER_END) || isCodeBetween(first, REGIONAL_INDICATOR_BEGIN, REGIONAL_INDICATOR_END) && isCodeBetween(second, REGIONAL_INDICATOR_BEGIN, REGIONAL_INDICATOR_END)) {
	      return 4;
	    }

	    if (isCodeBetween(second, VARIATION_MODIFIER_BEGIN, VARIATION_MODIFIER_END)) {
	      return 3;
	    }

	    return 2;
	  }

	  if (isCodeBetween(string[index + 1], VARIATION_MODIFIER_BEGIN, VARIATION_MODIFIER_END)) {
	    return 2;
	  }

	  return 1;
	}

	var string = {
	  ASCII_LOWERCASE: ASCII_LOWERCASE,
	  ASCII_UPPERCASE: ASCII_UPPERCASE,
	  ASCII_LETTERS: ASCII_LETTERS,
	  format: function format(s) {
	    for (var i = 1; i < arguments.length; i++) {
	      s = s.replace('{' + (i - 1) + '}', arguments[i]);
	    }

	    return s;
	  },
	  toBool: function toBool(s, strict) {
	    if (strict === void 0) {
	      strict = false;
	    }

	    if (s === 'true') {
	      return true;
	    }

	    if (strict) {
	      if (s === 'false') {
	        return false;
	      }

	      throw new TypeError('Not a boolean string');
	    }

	    return false;
	  },
	  getCodePoint: function getCodePoint(string, i) {
	    var codePointData = getCodePointData(string, i);
	    return codePointData && codePointData.code;
	  },
	  getCodePoints: function getCodePoints(string) {
	    if (typeof string !== 'string') {
	      throw new TypeError('Not a string');
	    }

	    var i = 0;
	    var arr = [];
	    var codePoint;

	    while (!!(codePoint = getCodePointData(string, i))) {
	      arr.push(codePoint.code);
	      i += codePoint.long ? 2 : 1;
	    }

	    return arr;
	  },
	  getSymbols: function getSymbols(string) {
	    if (typeof string !== 'string') {
	      throw new TypeError('Not a string');
	    }

	    var index = 0;
	    var length = string.length;
	    var output = [];
	    var take = 0;
	    var ch;

	    while (index < length) {
	      take += numCharsToTakeForNextSymbol(string, index + take);
	      ch = string[index + take];

	      if (isCodeBetween(ch, DIACRITICAL_MARKS_BEGIN, DIACRITICAL_MARKS_END)) {
	        ch = string[index + take++];
	      }

	      if (isCodeBetween(ch, VARIATION_MODIFIER_BEGIN, VARIATION_MODIFIER_END)) {
	        ch = string[index + take++];
	      }

	      if (ch && ch.charCodeAt(0) === ZERO_WIDTH_JOINER) {
	        ch = string[index + take++];
	        continue;
	      }

	      var char = string.substring(index, index + take);
	      output.push(char);
	      index += take;
	      take = 0;
	    }

	    return output;
	  },
	  fromCodePoint: function fromCodePoint() {
	    var chars = [];
	    var current;
	    var codePoint;
	    var units;

	    for (var i = 0; i < arguments.length; ++i) {
	      current = Number(arguments[i]);
	      codePoint = current - 0x10000;
	      units = current > 0xFFFF ? [(codePoint >> 10) + 0xD800, codePoint % 0x400 + 0xDC00] : [current];
	      chars.push(String.fromCharCode.apply(null, units));
	    }

	    return chars.join('');
	  }
	};

	var IndexedList = function () {
	  function IndexedList() {
	    this._list = [];
	    this._index = {};
	  }

	  var _proto = IndexedList.prototype;

	  _proto.push = function push(key, item) {
	    if (this._index[key]) {
	      throw Error('Key already in index ' + key);
	    }

	    var location = this._list.push(item) - 1;
	    this._index[key] = location;
	  };

	  _proto.has = function has(key) {
	    return this._index[key] !== undefined;
	  };

	  _proto.get = function get(key) {
	    var location = this._index[key];

	    if (location !== undefined) {
	      return this._list[location];
	    }

	    return null;
	  };

	  _proto.remove = function remove(key) {
	    var location = this._index[key];

	    if (location !== undefined) {
	      this._list.splice(location, 1);

	      delete this._index[key];

	      for (key in this._index) {
	        var idx = this._index[key];

	        if (idx > location) {
	          this._index[key] = idx - 1;
	        }
	      }

	      return true;
	    }

	    return false;
	  };

	  _proto.list = function list() {
	    return this._list;
	  };

	  _proto.clear = function clear() {
	    this._list.length = 0;

	    for (var prop in this._index) {
	      delete this._index[prop];
	    }
	  };

	  return IndexedList;
	}();

	var cachedResult = function cachedResult(func) {
	  var uninitToken = {};
	  var result = uninitToken;
	  return function () {
	    if (result === uninitToken) {
	      result = func();
	    }

	    return result;
	  };
	};

	var Impl = function () {
	  function Impl() {}

	  Impl.loadScript = function loadScript(url, callback) {
	    var s = document.createElement('script');
	    s.setAttribute('src', url);

	    s.onload = function () {
	      callback(null);
	    };

	    s.onerror = function () {
	      callback("Failed to load script='" + url + "'");
	    };

	    document.body.appendChild(s);
	  };

	  Impl.loadWasm = function loadWasm(moduleName, config, callback) {
	    var loadUrl = Impl.wasmSupported() && config.glueUrl && config.wasmUrl ? config.glueUrl : config.fallbackUrl;

	    if (loadUrl) {
	      Impl.loadScript(loadUrl, function (err) {
	        if (err) {
	          callback(err, null);
	        } else {
	          var module = window[moduleName];
	          window[moduleName] = undefined;
	          module({
	            locateFile: function locateFile() {
	              return config.wasmUrl;
	            },
	            onAbort: function onAbort() {
	              callback('wasm module aborted.');
	            }
	          }).then(function (instance) {
	            callback(null, instance);
	          });
	        }
	      });
	    } else {
	      callback('No supported wasm modules found.', null);
	    }
	  };

	  Impl.getModule = function getModule(name) {
	    if (!Impl.modules.hasOwnProperty(name)) {
	      Impl.modules[name] = {
	        config: null,
	        initializing: false,
	        instance: null,
	        callbacks: []
	      };
	    }

	    return Impl.modules[name];
	  };

	  Impl.initialize = function initialize(moduleName, module) {
	    if (module.initializing) {
	      return;
	    }

	    var config = module.config;

	    if (config.glueUrl || config.wasmUrl || config.fallbackUrl) {
	      module.initializing = true;
	      Impl.loadWasm(moduleName, config, function (err, instance) {
	        if (err) {
	          if (config.errorHandler) {
	            config.errorHandler(err);
	          } else {
	            console.error("failed to initialize module=" + moduleName + " error=" + err);
	          }
	        } else {
	          module.instance = instance;
	          module.callbacks.forEach(function (callback) {
	            callback(instance);
	          });
	        }
	      });
	    }
	  };

	  return Impl;
	}();

	Impl.modules = {};
	Impl.wasmSupported = cachedResult(function () {
	  try {
	    if (typeof WebAssembly === "object" && typeof WebAssembly.instantiate === "function") {
	      var module = new WebAssembly.Module(Uint8Array.of(0x0, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00));
	      if (module instanceof WebAssembly.Module) return new WebAssembly.Instance(module) instanceof WebAssembly.Instance;
	    }
	  } catch (e) {}

	  return false;
	});

	var WasmModule = function () {
	  function WasmModule() {}

	  WasmModule.setConfig = function setConfig(moduleName, config) {
	    var module = Impl.getModule(moduleName);
	    module.config = config;

	    if (module.callbacks.length > 0) {
	      Impl.initialize(moduleName, module);
	    }
	  };

	  WasmModule.getInstance = function getInstance(moduleName, callback) {
	    var module = Impl.getModule(moduleName);

	    if (module.instance) {
	      callback(module.instance);
	    } else {
	      module.callbacks.push(callback);

	      if (module.config) {
	        Impl.initialize(moduleName, module);
	      }
	    }
	  };

	  return WasmModule;
	}();

	function _defineProperties(target, props) {
	  for (var i = 0; i < props.length; i++) {
	    var descriptor = props[i];
	    descriptor.enumerable = descriptor.enumerable || false;
	    descriptor.configurable = true;
	    if ("value" in descriptor) descriptor.writable = true;
	    Object.defineProperty(target, descriptor.key, descriptor);
	  }
	}

	function _createClass(Constructor, protoProps, staticProps) {
	  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
	  if (staticProps) _defineProperties(Constructor, staticProps);
	  Object.defineProperty(Constructor, "prototype", {
	    writable: false
	  });
	  return Constructor;
	}

	function _extends() {
	  _extends = Object.assign ? Object.assign.bind() : function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];

	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }

	    return target;
	  };
	  return _extends.apply(this, arguments);
	}

	function _inheritsLoose(subClass, superClass) {
	  subClass.prototype = Object.create(superClass.prototype);
	  subClass.prototype.constructor = subClass;

	  _setPrototypeOf(subClass, superClass);
	}

	function _setPrototypeOf(o, p) {
	  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
	    o.__proto__ = p;
	    return o;
	  };
	  return _setPrototypeOf(o, p);
	}

	function _assertThisInitialized(self) {
	  if (self === void 0) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }

	  return self;
	}

	function _unsupportedIterableToArray(o, minLen) {
	  if (!o) return;
	  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
	  var n = Object.prototype.toString.call(o).slice(8, -1);
	  if (n === "Object" && o.constructor) n = o.constructor.name;
	  if (n === "Map" || n === "Set") return Array.from(o);
	  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
	}

	function _arrayLikeToArray(arr, len) {
	  if (len == null || len > arr.length) len = arr.length;

	  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

	  return arr2;
	}

	function _createForOfIteratorHelperLoose(o, allowArrayLike) {
	  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
	  if (it) return (it = it.call(o)).next.bind(it);

	  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
	    if (it) o = it;
	    var i = 0;
	    return function () {
	      if (i >= o.length) return {
	        done: true
	      };
	      return {
	        done: false,
	        value: o[i++]
	      };
	    };
	  }

	  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	}

	var ReadStream = function () {
	  function ReadStream(arraybuffer) {
	    this.arraybuffer = arraybuffer;
	    this.dataView = new DataView(arraybuffer);
	    this.offset = 0;
	    this.stack = [];
	  }

	  var _proto = ReadStream.prototype;

	  _proto.reset = function reset(offset) {
	    if (offset === void 0) {
	      offset = 0;
	    }

	    this.offset = offset;
	  };

	  _proto.skip = function skip(bytes) {
	    this.offset += bytes;
	  };

	  _proto.align = function align(bytes) {
	    this.offset = this.offset + bytes - 1 & ~(bytes - 1);
	  };

	  _proto._inc = function _inc(amount) {
	    this.offset += amount;
	    return this.offset - amount;
	  };

	  _proto.readChar = function readChar() {
	    return String.fromCharCode(this.dataView.getUint8(this.offset++));
	  };

	  _proto.readChars = function readChars(numChars) {
	    var result = '';

	    for (var i = 0; i < numChars; ++i) {
	      result += this.readChar();
	    }

	    return result;
	  };

	  _proto.readU8 = function readU8() {
	    return this.dataView.getUint8(this.offset++);
	  };

	  _proto.readU16 = function readU16() {
	    return this.dataView.getUint16(this._inc(2), true);
	  };

	  _proto.readU32 = function readU32() {
	    return this.dataView.getUint32(this._inc(4), true);
	  };

	  _proto.readU64 = function readU64() {
	    return this.readU32() + Math.pow(2, 32) * this.readU32();
	  };

	  _proto.readU32be = function readU32be() {
	    return this.dataView.getUint32(this._inc(4), false);
	  };

	  _proto.readArray = function readArray(result) {
	    for (var i = 0; i < result.length; ++i) {
	      result[i] = this.readU8();
	    }
	  };

	  _proto.readLine = function readLine() {
	    var view = this.dataView;
	    var result = '';

	    while (true) {
	      if (this.offset >= view.byteLength) {
	        break;
	      }

	      var c = String.fromCharCode(this.readU8());

	      if (c === '\n') {
	        break;
	      }

	      result += c;
	    }

	    return result;
	  };

	  _createClass(ReadStream, [{
	    key: "remainingBytes",
	    get: function get() {
	      return this.dataView.byteLength - this.offset;
	    }
	  }]);

	  return ReadStream;
	}();

	var SortedLoopArray = function () {
	  function SortedLoopArray(args) {
	    this.items = [];
	    this.length = 0;
	    this.loopIndex = -1;
	    this._sortBy = args.sortBy;
	    this._sortHandler = this._doSort.bind(this);
	  }

	  var _proto = SortedLoopArray.prototype;

	  _proto._binarySearch = function _binarySearch(item) {
	    var left = 0;
	    var right = this.items.length - 1;
	    var search = item[this._sortBy];
	    var middle;
	    var current;

	    while (left <= right) {
	      middle = Math.floor((left + right) / 2);
	      current = this.items[middle][this._sortBy];

	      if (current <= search) {
	        left = middle + 1;
	      } else if (current > search) {
	        right = middle - 1;
	      }
	    }

	    return left;
	  };

	  _proto._doSort = function _doSort(a, b) {
	    var sortBy = this._sortBy;
	    return a[sortBy] - b[sortBy];
	  };

	  _proto.insert = function insert(item) {
	    var index = this._binarySearch(item);

	    this.items.splice(index, 0, item);
	    this.length++;

	    if (this.loopIndex >= index) {
	      this.loopIndex++;
	    }
	  };

	  _proto.append = function append(item) {
	    this.items.push(item);
	    this.length++;
	  };

	  _proto.remove = function remove(item) {
	    var idx = this.items.indexOf(item);
	    if (idx < 0) return;
	    this.items.splice(idx, 1);
	    this.length--;

	    if (this.loopIndex >= idx) {
	      this.loopIndex--;
	    }
	  };

	  _proto.sort = function sort() {
	    var current = this.loopIndex >= 0 ? this.items[this.loopIndex] : null;
	    this.items.sort(this._sortHandler);

	    if (current !== null) {
	      this.loopIndex = this.items.indexOf(current);
	    }
	  };

	  return SortedLoopArray;
	}();

	var Tags = function (_EventHandler) {
	  _inheritsLoose(Tags, _EventHandler);

	  function Tags(parent) {
	    var _this;

	    _this = _EventHandler.call(this) || this;
	    _this._index = {};
	    _this._list = [];
	    _this._parent = parent;
	    return _this;
	  }

	  var _proto = Tags.prototype;

	  _proto.add = function add() {
	    var changed = false;

	    var tags = this._processArguments(arguments, true);

	    if (!tags.length) return changed;

	    for (var i = 0; i < tags.length; i++) {
	      if (this._index[tags[i]]) continue;
	      changed = true;
	      this._index[tags[i]] = true;

	      this._list.push(tags[i]);

	      this.fire('add', tags[i], this._parent);
	    }

	    if (changed) this.fire('change', this._parent);
	    return changed;
	  };

	  _proto.remove = function remove() {
	    var changed = false;
	    if (!this._list.length) return changed;

	    var tags = this._processArguments(arguments, true);

	    if (!tags.length) return changed;

	    for (var i = 0; i < tags.length; i++) {
	      if (!this._index[tags[i]]) continue;
	      changed = true;
	      delete this._index[tags[i]];

	      this._list.splice(this._list.indexOf(tags[i]), 1);

	      this.fire('remove', tags[i], this._parent);
	    }

	    if (changed) this.fire('change', this._parent);
	    return changed;
	  };

	  _proto.clear = function clear() {
	    if (!this._list.length) return;

	    var tags = this._list.slice(0);

	    this._list = [];
	    this._index = {};

	    for (var i = 0; i < tags.length; i++) {
	      this.fire('remove', tags[i], this._parent);
	    }

	    this.fire('change', this._parent);
	  };

	  _proto.has = function has() {
	    if (!this._list.length) return false;
	    return this._has(this._processArguments(arguments));
	  };

	  _proto._has = function _has(tags) {
	    if (!this._list.length || !tags.length) return false;

	    for (var i = 0; i < tags.length; i++) {
	      if (tags[i].length === 1) {
	        if (this._index[tags[i][0]]) return true;
	      } else {
	        var multiple = true;

	        for (var t = 0; t < tags[i].length; t++) {
	          if (this._index[tags[i][t]]) continue;
	          multiple = false;
	          break;
	        }

	        if (multiple) return true;
	      }
	    }

	    return false;
	  };

	  _proto.list = function list() {
	    return this._list.slice(0);
	  };

	  _proto._processArguments = function _processArguments(args, flat) {
	    var tags = [];
	    var tmp = [];
	    if (!args || !args.length) return tags;

	    for (var i = 0; i < args.length; i++) {
	      if (args[i] instanceof Array) {
	        if (!flat) tmp = [];

	        for (var t = 0; t < args[i].length; t++) {
	          if (typeof args[i][t] !== 'string') continue;

	          if (flat) {
	            tags.push(args[i][t]);
	          } else {
	            tmp.push(args[i][t]);
	          }
	        }

	        if (!flat && tmp.length) tags.push(tmp);
	      } else if (typeof args[i] === 'string') {
	        if (flat) {
	          tags.push(args[i]);
	        } else {
	          tags.push([args[i]]);
	        }
	      }
	    }

	    return tags;
	  };

	  _createClass(Tags, [{
	    key: "size",
	    get: function get() {
	      return this._list.length;
	    }
	  }]);

	  return Tags;
	}(EventHandler);

	var now = typeof window !== 'undefined' && window.performance && window.performance.now && window.performance.timing ? performance.now.bind(performance) : Date.now;

	var Timer = function () {
	  function Timer() {
	    this._isRunning = false;
	    this._a = 0;
	    this._b = 0;
	  }

	  var _proto = Timer.prototype;

	  _proto.start = function start() {
	    this._isRunning = true;
	    this._a = now();
	  };

	  _proto.stop = function stop() {
	    this._isRunning = false;
	    this._b = now();
	  };

	  _proto.getMilliseconds = function getMilliseconds() {
	    return this._b - this._a;
	  };

	  return Timer;
	}();

	function createURI(options) {
	  var s = '';

	  if ((options.authority || options.scheme) && (options.host || options.hostpath)) {
	    throw new Error('Can\'t have \'scheme\' or \'authority\' and \'host\' or \'hostpath\' option');
	  }

	  if (options.host && options.hostpath) {
	    throw new Error('Can\'t have \'host\' and \'hostpath\' option');
	  }

	  if (options.path && options.hostpath) {
	    throw new Error('Can\'t have \'path\' and \'hostpath\' option');
	  }

	  if (options.scheme) {
	    s += options.scheme + ':';
	  }

	  if (options.authority) {
	    s += '//' + options.authority;
	  }

	  if (options.host) {
	    s += options.host;
	  }

	  if (options.path) {
	    s += options.path;
	  }

	  if (options.hostpath) {
	    s += options.hostpath;
	  }

	  if (options.query) {
	    s += '?' + options.query;
	  }

	  if (options.fragment) {
	    s += '#' + options.fragment;
	  }

	  return s;
	}

	var re = /^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;

	var URI = function () {
	  function URI(uri) {
	    var result = uri.match(re);
	    this.scheme = result[2];
	    this.authority = result[4];
	    this.path = result[5];
	    this.query = result[7];
	    this.fragment = result[9];
	  }

	  var _proto = URI.prototype;

	  _proto.toString = function toString() {
	    var s = '';

	    if (this.scheme) {
	      s += this.scheme + ':';
	    }

	    if (this.authority) {
	      s += '//' + this.authority;
	    }

	    s += this.path;

	    if (this.query) {
	      s += '?' + this.query;
	    }

	    if (this.fragment) {
	      s += '#' + this.fragment;
	    }

	    return s;
	  };

	  _proto.getQuery = function getQuery() {
	    var result = {};

	    if (this.query) {
	      var queryParams = decodeURIComponent(this.query).split('&');

	      for (var _iterator = _createForOfIteratorHelperLoose(queryParams), _step; !(_step = _iterator()).done;) {
	        var queryParam = _step.value;
	        var pair = queryParam.split('=');
	        result[pair[0]] = pair[1];
	      }
	    }

	    return result;
	  };

	  _proto.setQuery = function setQuery(params) {
	    var q = '';

	    for (var key in params) {
	      if (params.hasOwnProperty(key)) {
	        if (q !== '') {
	          q += '&';
	        }

	        q += encodeURIComponent(key) + '=' + encodeURIComponent(params[key]);
	      }
	    }

	    this.query = q;
	  };

	  return URI;
	}();

	var Tracing = function () {
	  function Tracing() {}

	  Tracing.set = function set(channel, enabled) {
	  };

	  Tracing.get = function get(channel) {
	    return Tracing._traceChannels.has(channel);
	  };

	  return Tracing;
	}();

	Tracing._traceChannels = new Set();

	var math = {
	  DEG_TO_RAD: Math.PI / 180,
	  RAD_TO_DEG: 180 / Math.PI,
	  clamp: function clamp(value, min, max) {
	    if (value >= max) return max;
	    if (value <= min) return min;
	    return value;
	  },
	  intToBytes24: function intToBytes24(i) {
	    var r = i >> 16 & 0xff;
	    var g = i >> 8 & 0xff;
	    var b = i & 0xff;
	    return [r, g, b];
	  },
	  intToBytes32: function intToBytes32(i) {
	    var r = i >> 24 & 0xff;
	    var g = i >> 16 & 0xff;
	    var b = i >> 8 & 0xff;
	    var a = i & 0xff;
	    return [r, g, b, a];
	  },
	  bytesToInt24: function bytesToInt24(r, g, b) {
	    if (r.length) {
	      b = r[2];
	      g = r[1];
	      r = r[0];
	    }

	    return r << 16 | g << 8 | b;
	  },
	  bytesToInt32: function bytesToInt32(r, g, b, a) {
	    if (r.length) {
	      a = r[3];
	      b = r[2];
	      g = r[1];
	      r = r[0];
	    }

	    return (r << 24 | g << 16 | b << 8 | a) >>> 0;
	  },
	  lerp: function lerp(a, b, alpha) {
	    return a + (b - a) * math.clamp(alpha, 0, 1);
	  },
	  lerpAngle: function lerpAngle(a, b, alpha) {
	    if (b - a > 180) {
	      b -= 360;
	    }

	    if (b - a < -180) {
	      b += 360;
	    }

	    return math.lerp(a, b, math.clamp(alpha, 0, 1));
	  },
	  powerOfTwo: function powerOfTwo(x) {
	    return x !== 0 && !(x & x - 1);
	  },
	  nextPowerOfTwo: function nextPowerOfTwo(val) {
	    val--;
	    val |= val >> 1;
	    val |= val >> 2;
	    val |= val >> 4;
	    val |= val >> 8;
	    val |= val >> 16;
	    val++;
	    return val;
	  },
	  random: function random(min, max) {
	    var diff = max - min;
	    return Math.random() * diff + min;
	  },
	  smoothstep: function smoothstep(min, max, x) {
	    if (x <= min) return 0;
	    if (x >= max) return 1;
	    x = (x - min) / (max - min);
	    return x * x * (3 - 2 * x);
	  },
	  smootherstep: function smootherstep(min, max, x) {
	    if (x <= min) return 0;
	    if (x >= max) return 1;
	    x = (x - min) / (max - min);
	    return x * x * x * (x * (x * 6 - 15) + 10);
	  },
	  roundUp: function roundUp(numToRound, multiple) {
	    if (multiple === 0) return numToRound;
	    return Math.ceil(numToRound / multiple) * multiple;
	  },
	  between: function between(num, a, b, inclusive) {
	    var min = Math.min(a, b);
	    var max = Math.max(a, b);
	    return inclusive ? num >= min && num <= max : num > min && num < max;
	  }
	};

	var Http = function () {
	  function Http() {}

	  var _proto = Http.prototype;

	  _proto.get = function get(url, options, callback) {
	    if (typeof options === 'function') {
	      callback = options;
	      options = {};
	    }

	    return this.request('GET', url, options, callback);
	  };

	  _proto.post = function post(url, data, options, callback) {
	    if (typeof options === 'function') {
	      callback = options;
	      options = {};
	    }

	    options.postdata = data;
	    return this.request('POST', url, options, callback);
	  };

	  _proto.put = function put(url, data, options, callback) {
	    if (typeof options === 'function') {
	      callback = options;
	      options = {};
	    }

	    options.postdata = data;
	    return this.request('PUT', url, options, callback);
	  };

	  _proto.del = function del(url, options, callback) {
	    if (typeof options === 'function') {
	      callback = options;
	      options = {};
	    }

	    return this.request('DELETE', url, options, callback);
	  };

	  _proto.request = function request(method, url, options, callback) {
	    var _this = this;

	    var uri, query, postdata;
	    var errored = false;

	    if (typeof options === 'function') {
	      callback = options;
	      options = {};
	    }

	    if (options.retry) {
	      options = Object.assign({
	        retries: 0,
	        maxRetries: 5
	      }, options);
	    }

	    options.callback = callback;

	    if (options.async == null) {
	      options.async = true;
	    }

	    if (options.headers == null) {
	      options.headers = {};
	    }

	    if (options.postdata != null) {
	      if (options.postdata instanceof Document) {
	        postdata = options.postdata;
	      } else if (options.postdata instanceof FormData) {
	        postdata = options.postdata;
	      } else if (options.postdata instanceof Object) {
	        var contentType = options.headers['Content-Type'];

	        if (contentType === undefined) {
	          options.headers['Content-Type'] = Http.ContentType.FORM_URLENCODED;
	          contentType = options.headers['Content-Type'];
	        }

	        switch (contentType) {
	          case Http.ContentType.FORM_URLENCODED:
	            {
	              postdata = '';
	              var bFirstItem = true;

	              for (var key in options.postdata) {
	                if (options.postdata.hasOwnProperty(key)) {
	                  if (bFirstItem) {
	                    bFirstItem = false;
	                  } else {
	                    postdata += '&';
	                  }

	                  var encodedKey = encodeURIComponent(key);
	                  var encodedValue = encodeURIComponent(options.postdata[key]);
	                  postdata += encodedKey + "=" + encodedValue;
	                }
	              }

	              break;
	            }

	          default:
	          case Http.ContentType.JSON:
	            if (contentType == null) {
	              options.headers['Content-Type'] = Http.ContentType.JSON;
	            }

	            postdata = JSON.stringify(options.postdata);
	            break;
	        }
	      } else {
	        postdata = options.postdata;
	      }
	    }

	    if (options.cache === false) {
	      var timestamp = now();
	      uri = new URI(url);

	      if (!uri.query) {
	        uri.query = 'ts=' + timestamp;
	      } else {
	        uri.query = uri.query + '&ts=' + timestamp;
	      }

	      url = uri.toString();
	    }

	    if (options.query) {
	      uri = new URI(url);
	      query = extend(uri.getQuery(), options.query);
	      uri.setQuery(query);
	      url = uri.toString();
	    }

	    var xhr = new XMLHttpRequest();
	    xhr.open(method, url, options.async);
	    xhr.withCredentials = options.withCredentials !== undefined ? options.withCredentials : false;
	    xhr.responseType = options.responseType || this._guessResponseType(url);

	    for (var header in options.headers) {
	      if (options.headers.hasOwnProperty(header)) {
	        xhr.setRequestHeader(header, options.headers[header]);
	      }
	    }

	    xhr.onreadystatechange = function () {
	      _this._onReadyStateChange(method, url, options, xhr);
	    };

	    xhr.onerror = function () {
	      _this._onError(method, url, options, xhr);

	      errored = true;
	    };

	    try {
	      xhr.send(postdata);
	    } catch (e) {
	      if (!errored) {
	        options.error(xhr.status, xhr, e);
	      }
	    }

	    return xhr;
	  };

	  _proto._guessResponseType = function _guessResponseType(url) {
	    var uri = new URI(url);
	    var ext = path.getExtension(uri.path);

	    if (Http.binaryExtensions.indexOf(ext) >= 0) {
	      return Http.ResponseType.ARRAY_BUFFER;
	    }

	    if (ext === '.xml') {
	      return Http.ResponseType.DOCUMENT;
	    }

	    return Http.ResponseType.TEXT;
	  };

	  _proto._isBinaryContentType = function _isBinaryContentType(contentType) {
	    var binTypes = [Http.ContentType.MP4, Http.ContentType.WAV, Http.ContentType.OGG, Http.ContentType.MP3, Http.ContentType.BIN, Http.ContentType.DDS, Http.ContentType.BASIS, Http.ContentType.GLB, Http.ContentType.OPUS];

	    if (binTypes.indexOf(contentType) >= 0) {
	      return true;
	    }

	    return false;
	  };

	  _proto._onReadyStateChange = function _onReadyStateChange(method, url, options, xhr) {
	    if (xhr.readyState === 4) {
	      switch (xhr.status) {
	        case 0:
	          {
	            if (xhr.responseURL && xhr.responseURL.startsWith('file:///')) {
	              this._onSuccess(method, url, options, xhr);
	            } else {
	              this._onError(method, url, options, xhr);
	            }

	            break;
	          }

	        case 200:
	        case 201:
	        case 206:
	        case 304:
	          {
	            this._onSuccess(method, url, options, xhr);

	            break;
	          }

	        default:
	          {
	            this._onError(method, url, options, xhr);

	            break;
	          }
	      }
	    }
	  };

	  _proto._onSuccess = function _onSuccess(method, url, options, xhr) {
	    var response;
	    var contentType;
	    var header = xhr.getResponseHeader('Content-Type');

	    if (header) {
	      var parts = header.split(';');
	      contentType = parts[0].trim();
	    }

	    try {
	      if (contentType === Http.ContentType.JSON || url.split('?')[0].endsWith('.json')) {
	        response = JSON.parse(xhr.responseText);
	      } else if (this._isBinaryContentType(contentType)) {
	        response = xhr.response;
	      } else {
	        if (xhr.responseType === Http.ResponseType.ARRAY_BUFFER) {
	          response = xhr.response;
	        } else if (xhr.responseType === Http.ResponseType.BLOB || xhr.responseType === Http.ResponseType.JSON) {
	          response = xhr.response;
	        } else {
	          if (xhr.responseType === Http.ResponseType.DOCUMENT || contentType === Http.ContentType.XML) {
	            response = xhr.responseXML;
	          } else {
	            response = xhr.responseText;
	          }
	        }
	      }

	      options.callback(null, response);
	    } catch (err) {
	      options.callback(err);
	    }
	  };

	  _proto._onError = function _onError(method, url, options, xhr) {
	    var _this2 = this;

	    if (options.retrying) {
	      return;
	    }

	    if (options.retry && options.retries < options.maxRetries) {
	      options.retries++;
	      options.retrying = true;
	      var retryDelay = math.clamp(Math.pow(2, options.retries) * Http.retryDelay, 0, options.maxRetryDelay || 5000);
	      console.log(method + ": " + url + " - Error " + xhr.status + ". Retrying in " + retryDelay + " ms");
	      setTimeout(function () {
	        options.retrying = false;

	        _this2.request(method, url, options, options.callback);
	      }, retryDelay);
	    } else {
	      options.callback(xhr.status === 0 ? 'Network error' : xhr.status, null);
	    }
	  };

	  return Http;
	}();

	Http.ContentType = {
	  FORM_URLENCODED: 'application/x-www-form-urlencoded',
	  GIF: 'image/gif',
	  JPEG: 'image/jpeg',
	  DDS: 'image/dds',
	  JSON: 'application/json',
	  PNG: 'image/png',
	  TEXT: 'text/plain',
	  XML: 'application/xml',
	  WAV: 'audio/x-wav',
	  OGG: 'audio/ogg',
	  MP3: 'audio/mpeg',
	  MP4: 'audio/mp4',
	  AAC: 'audio/aac',
	  BIN: 'application/octet-stream',
	  BASIS: 'image/basis',
	  GLB: 'model/gltf-binary',
	  OPUS: 'audio/ogg; codecs="opus"'
	};
	Http.ResponseType = {
	  TEXT: 'text',
	  ARRAY_BUFFER: 'arraybuffer',
	  BLOB: 'blob',
	  DOCUMENT: 'document',
	  JSON: 'json'
	};
	Http.binaryExtensions = ['.model', '.wav', '.ogg', '.mp3', '.mp4', '.m4a', '.aac', '.dds', '.basis', '.glb', '.opus'];
	Http.retryDelay = 100;
	var http = new Http();

	var CURVE_LINEAR = 0;
	var CURVE_SMOOTHSTEP = 1;
	var CURVE_CATMULL = 2;
	var CURVE_CARDINAL = 3;
	var CURVE_SPLINE = 4;
	var CURVE_STEP = 5;

	var Color = function () {
	  function Color(r, g, b, a) {
	    if (r === void 0) {
	      r = 0;
	    }

	    if (g === void 0) {
	      g = 0;
	    }

	    if (b === void 0) {
	      b = 0;
	    }

	    if (a === void 0) {
	      a = 1;
	    }

	    var length = r.length;

	    if (length === 3 || length === 4) {
	      this.r = r[0];
	      this.g = r[1];
	      this.b = r[2];
	      this.a = r[3] !== undefined ? r[3] : 1;
	    } else {
	      this.r = r;
	      this.g = g;
	      this.b = b;
	      this.a = a;
	    }
	  }

	  var _proto = Color.prototype;

	  _proto.clone = function clone() {
	    var cstr = this.constructor;
	    return new cstr(this.r, this.g, this.b, this.a);
	  };

	  _proto.copy = function copy(rhs) {
	    this.r = rhs.r;
	    this.g = rhs.g;
	    this.b = rhs.b;
	    this.a = rhs.a;
	    return this;
	  };

	  _proto.equals = function equals(rhs) {
	    return this.r === rhs.r && this.g === rhs.g && this.b === rhs.b && this.a === rhs.a;
	  };

	  _proto.set = function set(r, g, b, a) {
	    if (a === void 0) {
	      a = 1;
	    }

	    this.r = r;
	    this.g = g;
	    this.b = b;
	    this.a = a;
	    return this;
	  };

	  _proto.lerp = function lerp(lhs, rhs, alpha) {
	    this.r = lhs.r + alpha * (rhs.r - lhs.r);
	    this.g = lhs.g + alpha * (rhs.g - lhs.g);
	    this.b = lhs.b + alpha * (rhs.b - lhs.b);
	    this.a = lhs.a + alpha * (rhs.a - lhs.a);
	    return this;
	  };

	  _proto.fromString = function fromString(hex) {
	    var i = parseInt(hex.replace('#', '0x'), 16);
	    var bytes;

	    if (hex.length > 7) {
	      bytes = math.intToBytes32(i);
	    } else {
	      bytes = math.intToBytes24(i);
	      bytes[3] = 255;
	    }

	    this.set(bytes[0] / 255, bytes[1] / 255, bytes[2] / 255, bytes[3] / 255);
	    return this;
	  };

	  _proto.toString = function toString(alpha) {
	    var s = '#' + ((1 << 24) + (Math.round(this.r * 255) << 16) + (Math.round(this.g * 255) << 8) + Math.round(this.b * 255)).toString(16).slice(1);

	    if (alpha === true) {
	      var a = Math.round(this.a * 255).toString(16);

	      if (this.a < 16 / 255) {
	        s += '0' + a;
	      } else {
	        s += a;
	      }
	    }

	    return s;
	  };

	  return Color;
	}();

	Color.BLACK = Object.freeze(new Color(0, 0, 0, 1));
	Color.BLUE = Object.freeze(new Color(0, 0, 1, 1));
	Color.CYAN = Object.freeze(new Color(0, 1, 1, 1));
	Color.GRAY = Object.freeze(new Color(0.5, 0.5, 0.5, 1));
	Color.GREEN = Object.freeze(new Color(0, 1, 0, 1));
	Color.MAGENTA = Object.freeze(new Color(1, 0, 1, 1));
	Color.RED = Object.freeze(new Color(1, 0, 0, 1));
	Color.WHITE = Object.freeze(new Color(1, 1, 1, 1));
	Color.YELLOW = Object.freeze(new Color(1, 1, 0, 1));

	var CurveEvaluator = function () {
	  function CurveEvaluator(curve, time) {
	    if (time === void 0) {
	      time = 0;
	    }

	    this._curve = curve;
	    this._left = -Infinity;
	    this._right = Infinity;
	    this._recip = 0;
	    this._p0 = 0;
	    this._p1 = 0;
	    this._m0 = 0;
	    this._m1 = 0;

	    this._reset(time);
	  }

	  var _proto = CurveEvaluator.prototype;

	  _proto.evaluate = function evaluate(time, forceReset) {
	    if (forceReset === void 0) {
	      forceReset = false;
	    }

	    if (forceReset || time < this._left || time >= this._right) {
	      this._reset(time);
	    }

	    var result;
	    var type = this._curve.type;

	    if (type === CURVE_STEP) {
	      result = this._p0;
	    } else {
	      var t = this._recip === 0 ? 0 : (time - this._left) * this._recip;

	      if (type === CURVE_LINEAR) {
	        result = math.lerp(this._p0, this._p1, t);
	      } else if (type === CURVE_SMOOTHSTEP) {
	        result = math.lerp(this._p0, this._p1, t * t * (3 - 2 * t));
	      } else {
	        result = this._evaluateHermite(this._p0, this._p1, this._m0, this._m1, t);
	      }
	    }

	    return result;
	  };

	  _proto._reset = function _reset(time) {
	    var keys = this._curve.keys;
	    var len = keys.length;

	    if (!len) {
	      this._left = -Infinity;
	      this._right = Infinity;
	      this._recip = 0;
	      this._p0 = this._p1 = this._m0 = this._m1 = 0;
	    } else {
	      if (time < keys[0][0]) {
	        this._left = -Infinity;
	        this._right = keys[0][0];
	        this._recip = 0;
	        this._p0 = this._p1 = keys[0][1];
	        this._m0 = this._m1 = 0;
	      } else if (time >= keys[len - 1][0]) {
	        this._left = keys[len - 1][0];
	        this._right = Infinity;
	        this._recip = 0;
	        this._p0 = this._p1 = keys[len - 1][1];
	        this._m0 = this._m1 = 0;
	      } else {
	        var index = 0;

	        while (time >= keys[index + 1][0]) {
	          index++;
	        }

	        this._left = keys[index][0];
	        this._right = keys[index + 1][0];
	        var diff = 1.0 / (this._right - this._left);
	        this._recip = isFinite(diff) ? diff : 0;
	        this._p0 = keys[index][1];
	        this._p1 = keys[index + 1][1];

	        if (this._isHermite()) {
	          this._calcTangents(keys, index);
	        }
	      }
	    }
	  };

	  _proto._isHermite = function _isHermite() {
	    return this._curve.type === CURVE_CATMULL || this._curve.type === CURVE_CARDINAL || this._curve.type === CURVE_SPLINE;
	  };

	  _proto._calcTangents = function _calcTangents(keys, index) {
	    var a;
	    var b = keys[index];
	    var c = keys[index + 1];
	    var d;

	    if (index === 0) {
	      a = [keys[0][0] + (keys[0][0] - keys[1][0]), keys[0][1] + (keys[0][1] - keys[1][1])];
	    } else {
	      a = keys[index - 1];
	    }

	    if (index === keys.length - 2) {
	      d = [keys[index + 1][0] + (keys[index + 1][0] - keys[index][0]), keys[index + 1][1] + (keys[index + 1][1] - keys[index][1])];
	    } else {
	      d = keys[index + 2];
	    }

	    if (this._curve.type === CURVE_SPLINE) {
	      var s1_ = 2 * (c[0] - b[0]) / (c[0] - a[0]);
	      var s2_ = 2 * (c[0] - b[0]) / (d[0] - b[0]);
	      this._m0 = this._curve.tension * (isFinite(s1_) ? s1_ : 0) * (c[1] - a[1]);
	      this._m1 = this._curve.tension * (isFinite(s2_) ? s2_ : 0) * (d[1] - b[1]);
	    } else {
	      var s1 = (c[0] - b[0]) / (b[0] - a[0]);
	      var s2 = (c[0] - b[0]) / (d[0] - c[0]);
	      var a_ = b[1] + (a[1] - b[1]) * (isFinite(s1) ? s1 : 0);
	      var d_ = c[1] + (d[1] - c[1]) * (isFinite(s2) ? s2 : 0);
	      var tension = this._curve.type === CURVE_CATMULL ? 0.5 : this._curve.tension;
	      this._m0 = tension * (c[1] - a_);
	      this._m1 = tension * (d_ - b[1]);
	    }
	  };

	  _proto._evaluateHermite = function _evaluateHermite(p0, p1, m0, m1, t) {
	    var t2 = t * t;
	    var twot = t + t;
	    var omt = 1 - t;
	    var omt2 = omt * omt;
	    return p0 * ((1 + twot) * omt2) + m0 * (t * omt2) + p1 * (t2 * (3 - twot)) + m1 * (t2 * (t - 1));
	  };

	  return CurveEvaluator;
	}();

	var Curve = function () {
	  function Curve(data) {
	    this.keys = [];
	    this.type = CURVE_SMOOTHSTEP;
	    this.tension = 0.5;
	    this._eval = new CurveEvaluator(this);

	    if (data) {
	      for (var i = 0; i < data.length - 1; i += 2) {
	        this.keys.push([data[i], data[i + 1]]);
	      }
	    }

	    this.sort();
	  }

	  var _proto = Curve.prototype;

	  _proto.add = function add(time, value) {
	    var keys = this.keys;
	    var len = keys.length;
	    var i = 0;

	    for (; i < len; i++) {
	      if (keys[i][0] > time) {
	        break;
	      }
	    }

	    var key = [time, value];
	    this.keys.splice(i, 0, key);
	    return key;
	  };

	  _proto.get = function get(index) {
	    return this.keys[index];
	  };

	  _proto.sort = function sort() {
	    this.keys.sort(function (a, b) {
	      return a[0] - b[0];
	    });
	  };

	  _proto.value = function value(time) {
	    return this._eval.evaluate(time, true);
	  };

	  _proto.closest = function closest(time) {
	    var keys = this.keys;
	    var length = keys.length;
	    var min = 2;
	    var result = null;

	    for (var i = 0; i < length; i++) {
	      var diff = Math.abs(time - keys[i][0]);

	      if (min >= diff) {
	        min = diff;
	        result = keys[i];
	      } else {
	        break;
	      }
	    }

	    return result;
	  };

	  _proto.clone = function clone() {
	    var result = new this.constructor();
	    result.keys = extend(result.keys, this.keys);
	    result.type = this.type;
	    result.tension = this.tension;
	    return result;
	  };

	  _proto.quantize = function quantize(precision) {
	    precision = Math.max(precision, 2);
	    var values = new Float32Array(precision);
	    var step = 1.0 / (precision - 1);
	    values[0] = this._eval.evaluate(0, true);

	    for (var i = 1; i < precision; i++) {
	      values[i] = this._eval.evaluate(step * i);
	    }

	    return values;
	  };

	  _proto.quantizeClamped = function quantizeClamped(precision, min, max) {
	    var result = this.quantize(precision);

	    for (var i = 0; i < result.length; ++i) {
	      result[i] = Math.min(max, Math.max(min, result[i]));
	    }

	    return result;
	  };

	  _createClass(Curve, [{
	    key: "length",
	    get: function get() {
	      return this.keys.length;
	    }
	  }]);

	  return Curve;
	}();

	var CurveSet = function () {
	  function CurveSet() {
	    this.curves = [];
	    this._type = CURVE_SMOOTHSTEP;

	    if (arguments.length > 1) {
	      for (var i = 0; i < arguments.length; i++) {
	        this.curves.push(new Curve(arguments[i]));
	      }
	    } else {
	      if (arguments.length === 0) {
	        this.curves.push(new Curve());
	      } else {
	        var arg = arguments[0];

	        if (typeof arg === 'number') {
	          for (var _i = 0; _i < arg; _i++) {
	            this.curves.push(new Curve());
	          }
	        } else {
	          for (var _i2 = 0; _i2 < arg.length; _i2++) {
	            this.curves.push(new Curve(arg[_i2]));
	          }
	        }
	      }
	    }
	  }

	  var _proto = CurveSet.prototype;

	  _proto.get = function get(index) {
	    return this.curves[index];
	  };

	  _proto.value = function value(time, result) {
	    if (result === void 0) {
	      result = [];
	    }

	    var length = this.curves.length;
	    result.length = length;

	    for (var i = 0; i < length; i++) {
	      result[i] = this.curves[i].value(time);
	    }

	    return result;
	  };

	  _proto.clone = function clone() {
	    var result = new this.constructor();
	    result.curves = [];

	    for (var i = 0; i < this.curves.length; i++) {
	      result.curves.push(this.curves[i].clone());
	    }

	    result._type = this._type;
	    return result;
	  };

	  _proto.quantize = function quantize(precision) {
	    precision = Math.max(precision, 2);
	    var numCurves = this.curves.length;
	    var values = new Float32Array(precision * numCurves);
	    var step = 1.0 / (precision - 1);

	    for (var c = 0; c < numCurves; c++) {
	      var ev = new CurveEvaluator(this.curves[c]);

	      for (var i = 0; i < precision; i++) {
	        values[i * numCurves + c] = ev.evaluate(step * i);
	      }
	    }

	    return values;
	  };

	  _proto.quantizeClamped = function quantizeClamped(precision, min, max) {
	    var result = this.quantize(precision);

	    for (var i = 0; i < result.length; ++i) {
	      result[i] = Math.min(max, Math.max(min, result[i]));
	    }

	    return result;
	  };

	  _createClass(CurveSet, [{
	    key: "length",
	    get: function get() {
	      return this.curves.length;
	    }
	  }, {
	    key: "type",
	    get: function get() {
	      return this._type;
	    },
	    set: function set(value) {
	      this._type = value;

	      for (var i = 0; i < this.curves.length; i++) {
	        this.curves[i].type = value;
	      }
	    }
	  }]);

	  return CurveSet;
	}();

	var Vec3 = function () {
	  function Vec3(x, y, z) {
	    if (x === void 0) {
	      x = 0;
	    }

	    if (y === void 0) {
	      y = 0;
	    }

	    if (z === void 0) {
	      z = 0;
	    }

	    if (x.length === 3) {
	      this.x = x[0];
	      this.y = x[1];
	      this.z = x[2];
	    } else {
	      this.x = x;
	      this.y = y;
	      this.z = z;
	    }
	  }

	  var _proto = Vec3.prototype;

	  _proto.add = function add(rhs) {
	    this.x += rhs.x;
	    this.y += rhs.y;
	    this.z += rhs.z;
	    return this;
	  };

	  _proto.add2 = function add2(lhs, rhs) {
	    this.x = lhs.x + rhs.x;
	    this.y = lhs.y + rhs.y;
	    this.z = lhs.z + rhs.z;
	    return this;
	  };

	  _proto.addScalar = function addScalar(scalar) {
	    this.x += scalar;
	    this.y += scalar;
	    this.z += scalar;
	    return this;
	  };

	  _proto.clone = function clone() {
	    var cstr = this.constructor;
	    return new cstr(this.x, this.y, this.z);
	  };

	  _proto.copy = function copy(rhs) {
	    this.x = rhs.x;
	    this.y = rhs.y;
	    this.z = rhs.z;
	    return this;
	  };

	  _proto.cross = function cross(lhs, rhs) {
	    var lx = lhs.x;
	    var ly = lhs.y;
	    var lz = lhs.z;
	    var rx = rhs.x;
	    var ry = rhs.y;
	    var rz = rhs.z;
	    this.x = ly * rz - ry * lz;
	    this.y = lz * rx - rz * lx;
	    this.z = lx * ry - rx * ly;
	    return this;
	  };

	  _proto.distance = function distance(rhs) {
	    var x = this.x - rhs.x;
	    var y = this.y - rhs.y;
	    var z = this.z - rhs.z;
	    return Math.sqrt(x * x + y * y + z * z);
	  };

	  _proto.div = function div(rhs) {
	    this.x /= rhs.x;
	    this.y /= rhs.y;
	    this.z /= rhs.z;
	    return this;
	  };

	  _proto.div2 = function div2(lhs, rhs) {
	    this.x = lhs.x / rhs.x;
	    this.y = lhs.y / rhs.y;
	    this.z = lhs.z / rhs.z;
	    return this;
	  };

	  _proto.divScalar = function divScalar(scalar) {
	    this.x /= scalar;
	    this.y /= scalar;
	    this.z /= scalar;
	    return this;
	  };

	  _proto.dot = function dot(rhs) {
	    return this.x * rhs.x + this.y * rhs.y + this.z * rhs.z;
	  };

	  _proto.equals = function equals(rhs) {
	    return this.x === rhs.x && this.y === rhs.y && this.z === rhs.z;
	  };

	  _proto.length = function length() {
	    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
	  };

	  _proto.lengthSq = function lengthSq() {
	    return this.x * this.x + this.y * this.y + this.z * this.z;
	  };

	  _proto.lerp = function lerp(lhs, rhs, alpha) {
	    this.x = lhs.x + alpha * (rhs.x - lhs.x);
	    this.y = lhs.y + alpha * (rhs.y - lhs.y);
	    this.z = lhs.z + alpha * (rhs.z - lhs.z);
	    return this;
	  };

	  _proto.mul = function mul(rhs) {
	    this.x *= rhs.x;
	    this.y *= rhs.y;
	    this.z *= rhs.z;
	    return this;
	  };

	  _proto.mul2 = function mul2(lhs, rhs) {
	    this.x = lhs.x * rhs.x;
	    this.y = lhs.y * rhs.y;
	    this.z = lhs.z * rhs.z;
	    return this;
	  };

	  _proto.mulScalar = function mulScalar(scalar) {
	    this.x *= scalar;
	    this.y *= scalar;
	    this.z *= scalar;
	    return this;
	  };

	  _proto.normalize = function normalize() {
	    var lengthSq = this.x * this.x + this.y * this.y + this.z * this.z;

	    if (lengthSq > 0) {
	      var invLength = 1 / Math.sqrt(lengthSq);
	      this.x *= invLength;
	      this.y *= invLength;
	      this.z *= invLength;
	    }

	    return this;
	  };

	  _proto.floor = function floor() {
	    this.x = Math.floor(this.x);
	    this.y = Math.floor(this.y);
	    this.z = Math.floor(this.z);
	    return this;
	  };

	  _proto.ceil = function ceil() {
	    this.x = Math.ceil(this.x);
	    this.y = Math.ceil(this.y);
	    this.z = Math.ceil(this.z);
	    return this;
	  };

	  _proto.round = function round() {
	    this.x = Math.round(this.x);
	    this.y = Math.round(this.y);
	    this.z = Math.round(this.z);
	    return this;
	  };

	  _proto.min = function min(rhs) {
	    if (rhs.x < this.x) this.x = rhs.x;
	    if (rhs.y < this.y) this.y = rhs.y;
	    if (rhs.z < this.z) this.z = rhs.z;
	    return this;
	  };

	  _proto.max = function max(rhs) {
	    if (rhs.x > this.x) this.x = rhs.x;
	    if (rhs.y > this.y) this.y = rhs.y;
	    if (rhs.z > this.z) this.z = rhs.z;
	    return this;
	  };

	  _proto.project = function project(rhs) {
	    var a_dot_b = this.x * rhs.x + this.y * rhs.y + this.z * rhs.z;
	    var b_dot_b = rhs.x * rhs.x + rhs.y * rhs.y + rhs.z * rhs.z;
	    var s = a_dot_b / b_dot_b;
	    this.x = rhs.x * s;
	    this.y = rhs.y * s;
	    this.z = rhs.z * s;
	    return this;
	  };

	  _proto.set = function set(x, y, z) {
	    this.x = x;
	    this.y = y;
	    this.z = z;
	    return this;
	  };

	  _proto.sub = function sub(rhs) {
	    this.x -= rhs.x;
	    this.y -= rhs.y;
	    this.z -= rhs.z;
	    return this;
	  };

	  _proto.sub2 = function sub2(lhs, rhs) {
	    this.x = lhs.x - rhs.x;
	    this.y = lhs.y - rhs.y;
	    this.z = lhs.z - rhs.z;
	    return this;
	  };

	  _proto.subScalar = function subScalar(scalar) {
	    this.x -= scalar;
	    this.y -= scalar;
	    this.z -= scalar;
	    return this;
	  };

	  _proto.toString = function toString() {
	    return "[" + this.x + ", " + this.y + ", " + this.z + "]";
	  };

	  return Vec3;
	}();

	Vec3.ZERO = Object.freeze(new Vec3(0, 0, 0));
	Vec3.ONE = Object.freeze(new Vec3(1, 1, 1));
	Vec3.UP = Object.freeze(new Vec3(0, 1, 0));
	Vec3.DOWN = Object.freeze(new Vec3(0, -1, 0));
	Vec3.RIGHT = Object.freeze(new Vec3(1, 0, 0));
	Vec3.LEFT = Object.freeze(new Vec3(-1, 0, 0));
	Vec3.FORWARD = Object.freeze(new Vec3(0, 0, -1));
	Vec3.BACK = Object.freeze(new Vec3(0, 0, 1));

	var Mat3 = function () {
	  function Mat3() {
	    var data = new Float32Array(9);
	    data[0] = data[4] = data[8] = 1;
	    this.data = data;
	  }

	  var _proto = Mat3.prototype;

	  _proto.clone = function clone() {
	    var cstr = this.constructor;
	    return new cstr().copy(this);
	  };

	  _proto.copy = function copy(rhs) {
	    var src = rhs.data;
	    var dst = this.data;
	    dst[0] = src[0];
	    dst[1] = src[1];
	    dst[2] = src[2];
	    dst[3] = src[3];
	    dst[4] = src[4];
	    dst[5] = src[5];
	    dst[6] = src[6];
	    dst[7] = src[7];
	    dst[8] = src[8];
	    return this;
	  };

	  _proto.set = function set(src) {
	    var dst = this.data;
	    dst[0] = src[0];
	    dst[1] = src[1];
	    dst[2] = src[2];
	    dst[3] = src[3];
	    dst[4] = src[4];
	    dst[5] = src[5];
	    dst[6] = src[6];
	    dst[7] = src[7];
	    dst[8] = src[8];
	    return this;
	  };

	  _proto.equals = function equals(rhs) {
	    var l = this.data;
	    var r = rhs.data;
	    return l[0] === r[0] && l[1] === r[1] && l[2] === r[2] && l[3] === r[3] && l[4] === r[4] && l[5] === r[5] && l[6] === r[6] && l[7] === r[7] && l[8] === r[8];
	  };

	  _proto.isIdentity = function isIdentity() {
	    var m = this.data;
	    return m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 0 && m[4] === 1 && m[5] === 0 && m[6] === 0 && m[7] === 0 && m[8] === 1;
	  };

	  _proto.setIdentity = function setIdentity() {
	    var m = this.data;
	    m[0] = 1;
	    m[1] = 0;
	    m[2] = 0;
	    m[3] = 0;
	    m[4] = 1;
	    m[5] = 0;
	    m[6] = 0;
	    m[7] = 0;
	    m[8] = 1;
	    return this;
	  };

	  _proto.toString = function toString() {
	    return '[' + this.data.join(', ') + ']';
	  };

	  _proto.transpose = function transpose() {
	    var m = this.data;
	    var tmp;
	    tmp = m[1];
	    m[1] = m[3];
	    m[3] = tmp;
	    tmp = m[2];
	    m[2] = m[6];
	    m[6] = tmp;
	    tmp = m[5];
	    m[5] = m[7];
	    m[7] = tmp;
	    return this;
	  };

	  _proto.setFromMat4 = function setFromMat4(m) {
	    var src = m.data;
	    var dst = this.data;
	    dst[0] = src[0];
	    dst[1] = src[1];
	    dst[2] = src[2];
	    dst[3] = src[4];
	    dst[4] = src[5];
	    dst[5] = src[6];
	    dst[6] = src[8];
	    dst[7] = src[9];
	    dst[8] = src[10];
	    return this;
	  };

	  _proto.transformVector = function transformVector(vec, res) {
	    if (res === void 0) {
	      res = new Vec3();
	    }

	    var m = this.data;
	    var x = vec.x;
	    var y = vec.y;
	    var z = vec.z;
	    res.x = x * m[0] + y * m[3] + z * m[6];
	    res.y = x * m[1] + y * m[4] + z * m[7];
	    res.z = x * m[2] + y * m[5] + z * m[8];
	    return res;
	  };

	  return Mat3;
	}();

	Mat3.IDENTITY = Object.freeze(new Mat3());
	Mat3.ZERO = Object.freeze(new Mat3().set([0, 0, 0, 0, 0, 0, 0, 0, 0]));

	var Vec2 = function () {
	  function Vec2(x, y) {
	    if (x === void 0) {
	      x = 0;
	    }

	    if (y === void 0) {
	      y = 0;
	    }

	    if (x.length === 2) {
	      this.x = x[0];
	      this.y = x[1];
	    } else {
	      this.x = x;
	      this.y = y;
	    }
	  }

	  var _proto = Vec2.prototype;

	  _proto.add = function add(rhs) {
	    this.x += rhs.x;
	    this.y += rhs.y;
	    return this;
	  };

	  _proto.add2 = function add2(lhs, rhs) {
	    this.x = lhs.x + rhs.x;
	    this.y = lhs.y + rhs.y;
	    return this;
	  };

	  _proto.addScalar = function addScalar(scalar) {
	    this.x += scalar;
	    this.y += scalar;
	    return this;
	  };

	  _proto.clone = function clone() {
	    var cstr = this.constructor;
	    return new cstr(this.x, this.y);
	  };

	  _proto.copy = function copy(rhs) {
	    this.x = rhs.x;
	    this.y = rhs.y;
	    return this;
	  };

	  _proto.cross = function cross(rhs) {
	    return this.x * rhs.y - this.y * rhs.x;
	  };

	  _proto.distance = function distance(rhs) {
	    var x = this.x - rhs.x;
	    var y = this.y - rhs.y;
	    return Math.sqrt(x * x + y * y);
	  };

	  _proto.div = function div(rhs) {
	    this.x /= rhs.x;
	    this.y /= rhs.y;
	    return this;
	  };

	  _proto.div2 = function div2(lhs, rhs) {
	    this.x = lhs.x / rhs.x;
	    this.y = lhs.y / rhs.y;
	    return this;
	  };

	  _proto.divScalar = function divScalar(scalar) {
	    this.x /= scalar;
	    this.y /= scalar;
	    return this;
	  };

	  _proto.dot = function dot(rhs) {
	    return this.x * rhs.x + this.y * rhs.y;
	  };

	  _proto.equals = function equals(rhs) {
	    return this.x === rhs.x && this.y === rhs.y;
	  };

	  _proto.length = function length() {
	    return Math.sqrt(this.x * this.x + this.y * this.y);
	  };

	  _proto.lengthSq = function lengthSq() {
	    return this.x * this.x + this.y * this.y;
	  };

	  _proto.lerp = function lerp(lhs, rhs, alpha) {
	    this.x = lhs.x + alpha * (rhs.x - lhs.x);
	    this.y = lhs.y + alpha * (rhs.y - lhs.y);
	    return this;
	  };

	  _proto.mul = function mul(rhs) {
	    this.x *= rhs.x;
	    this.y *= rhs.y;
	    return this;
	  };

	  _proto.mul2 = function mul2(lhs, rhs) {
	    this.x = lhs.x * rhs.x;
	    this.y = lhs.y * rhs.y;
	    return this;
	  };

	  _proto.mulScalar = function mulScalar(scalar) {
	    this.x *= scalar;
	    this.y *= scalar;
	    return this;
	  };

	  _proto.normalize = function normalize() {
	    var lengthSq = this.x * this.x + this.y * this.y;

	    if (lengthSq > 0) {
	      var invLength = 1 / Math.sqrt(lengthSq);
	      this.x *= invLength;
	      this.y *= invLength;
	    }

	    return this;
	  };

	  _proto.floor = function floor() {
	    this.x = Math.floor(this.x);
	    this.y = Math.floor(this.y);
	    return this;
	  };

	  _proto.ceil = function ceil() {
	    this.x = Math.ceil(this.x);
	    this.y = Math.ceil(this.y);
	    return this;
	  };

	  _proto.round = function round() {
	    this.x = Math.round(this.x);
	    this.y = Math.round(this.y);
	    return this;
	  };

	  _proto.min = function min(rhs) {
	    if (rhs.x < this.x) this.x = rhs.x;
	    if (rhs.y < this.y) this.y = rhs.y;
	    return this;
	  };

	  _proto.max = function max(rhs) {
	    if (rhs.x > this.x) this.x = rhs.x;
	    if (rhs.y > this.y) this.y = rhs.y;
	    return this;
	  };

	  _proto.set = function set(x, y) {
	    this.x = x;
	    this.y = y;
	    return this;
	  };

	  _proto.sub = function sub(rhs) {
	    this.x -= rhs.x;
	    this.y -= rhs.y;
	    return this;
	  };

	  _proto.sub2 = function sub2(lhs, rhs) {
	    this.x = lhs.x - rhs.x;
	    this.y = lhs.y - rhs.y;
	    return this;
	  };

	  _proto.subScalar = function subScalar(scalar) {
	    this.x -= scalar;
	    this.y -= scalar;
	    return this;
	  };

	  _proto.toString = function toString() {
	    return "[" + this.x + ", " + this.y + "]";
	  };

	  Vec2.angleRad = function angleRad(lhs, rhs) {
	    return Math.atan2(lhs.x * rhs.y - lhs.y * rhs.x, lhs.x * rhs.x + lhs.y * rhs.y);
	  };

	  return Vec2;
	}();

	Vec2.ZERO = Object.freeze(new Vec2(0, 0));
	Vec2.ONE = Object.freeze(new Vec2(1, 1));
	Vec2.UP = Object.freeze(new Vec2(0, 1));
	Vec2.DOWN = Object.freeze(new Vec2(0, -1));
	Vec2.RIGHT = Object.freeze(new Vec2(1, 0));
	Vec2.LEFT = Object.freeze(new Vec2(-1, 0));

	var Vec4 = function () {
	  function Vec4(x, y, z, w) {
	    if (x === void 0) {
	      x = 0;
	    }

	    if (y === void 0) {
	      y = 0;
	    }

	    if (z === void 0) {
	      z = 0;
	    }

	    if (w === void 0) {
	      w = 0;
	    }

	    if (x.length === 4) {
	      this.x = x[0];
	      this.y = x[1];
	      this.z = x[2];
	      this.w = x[3];
	    } else {
	      this.x = x;
	      this.y = y;
	      this.z = z;
	      this.w = w;
	    }
	  }

	  var _proto = Vec4.prototype;

	  _proto.add = function add(rhs) {
	    this.x += rhs.x;
	    this.y += rhs.y;
	    this.z += rhs.z;
	    this.w += rhs.w;
	    return this;
	  };

	  _proto.add2 = function add2(lhs, rhs) {
	    this.x = lhs.x + rhs.x;
	    this.y = lhs.y + rhs.y;
	    this.z = lhs.z + rhs.z;
	    this.w = lhs.w + rhs.w;
	    return this;
	  };

	  _proto.addScalar = function addScalar(scalar) {
	    this.x += scalar;
	    this.y += scalar;
	    this.z += scalar;
	    this.w += scalar;
	    return this;
	  };

	  _proto.clone = function clone() {
	    var cstr = this.constructor;
	    return new cstr(this.x, this.y, this.z, this.w);
	  };

	  _proto.copy = function copy(rhs) {
	    this.x = rhs.x;
	    this.y = rhs.y;
	    this.z = rhs.z;
	    this.w = rhs.w;
	    return this;
	  };

	  _proto.div = function div(rhs) {
	    this.x /= rhs.x;
	    this.y /= rhs.y;
	    this.z /= rhs.z;
	    this.w /= rhs.w;
	    return this;
	  };

	  _proto.div2 = function div2(lhs, rhs) {
	    this.x = lhs.x / rhs.x;
	    this.y = lhs.y / rhs.y;
	    this.z = lhs.z / rhs.z;
	    this.w = lhs.w / rhs.w;
	    return this;
	  };

	  _proto.divScalar = function divScalar(scalar) {
	    this.x /= scalar;
	    this.y /= scalar;
	    this.z /= scalar;
	    this.w /= scalar;
	    return this;
	  };

	  _proto.dot = function dot(rhs) {
	    return this.x * rhs.x + this.y * rhs.y + this.z * rhs.z + this.w * rhs.w;
	  };

	  _proto.equals = function equals(rhs) {
	    return this.x === rhs.x && this.y === rhs.y && this.z === rhs.z && this.w === rhs.w;
	  };

	  _proto.length = function length() {
	    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
	  };

	  _proto.lengthSq = function lengthSq() {
	    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
	  };

	  _proto.lerp = function lerp(lhs, rhs, alpha) {
	    this.x = lhs.x + alpha * (rhs.x - lhs.x);
	    this.y = lhs.y + alpha * (rhs.y - lhs.y);
	    this.z = lhs.z + alpha * (rhs.z - lhs.z);
	    this.w = lhs.w + alpha * (rhs.w - lhs.w);
	    return this;
	  };

	  _proto.mul = function mul(rhs) {
	    this.x *= rhs.x;
	    this.y *= rhs.y;
	    this.z *= rhs.z;
	    this.w *= rhs.w;
	    return this;
	  };

	  _proto.mul2 = function mul2(lhs, rhs) {
	    this.x = lhs.x * rhs.x;
	    this.y = lhs.y * rhs.y;
	    this.z = lhs.z * rhs.z;
	    this.w = lhs.w * rhs.w;
	    return this;
	  };

	  _proto.mulScalar = function mulScalar(scalar) {
	    this.x *= scalar;
	    this.y *= scalar;
	    this.z *= scalar;
	    this.w *= scalar;
	    return this;
	  };

	  _proto.normalize = function normalize() {
	    var lengthSq = this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

	    if (lengthSq > 0) {
	      var invLength = 1 / Math.sqrt(lengthSq);
	      this.x *= invLength;
	      this.y *= invLength;
	      this.z *= invLength;
	      this.w *= invLength;
	    }

	    return this;
	  };

	  _proto.floor = function floor() {
	    this.x = Math.floor(this.x);
	    this.y = Math.floor(this.y);
	    this.z = Math.floor(this.z);
	    this.w = Math.floor(this.w);
	    return this;
	  };

	  _proto.ceil = function ceil() {
	    this.x = Math.ceil(this.x);
	    this.y = Math.ceil(this.y);
	    this.z = Math.ceil(this.z);
	    this.w = Math.ceil(this.w);
	    return this;
	  };

	  _proto.round = function round() {
	    this.x = Math.round(this.x);
	    this.y = Math.round(this.y);
	    this.z = Math.round(this.z);
	    this.w = Math.round(this.w);
	    return this;
	  };

	  _proto.min = function min(rhs) {
	    if (rhs.x < this.x) this.x = rhs.x;
	    if (rhs.y < this.y) this.y = rhs.y;
	    if (rhs.z < this.z) this.z = rhs.z;
	    if (rhs.w < this.w) this.w = rhs.w;
	    return this;
	  };

	  _proto.max = function max(rhs) {
	    if (rhs.x > this.x) this.x = rhs.x;
	    if (rhs.y > this.y) this.y = rhs.y;
	    if (rhs.z > this.z) this.z = rhs.z;
	    if (rhs.w > this.w) this.w = rhs.w;
	    return this;
	  };

	  _proto.set = function set(x, y, z, w) {
	    this.x = x;
	    this.y = y;
	    this.z = z;
	    this.w = w;
	    return this;
	  };

	  _proto.sub = function sub(rhs) {
	    this.x -= rhs.x;
	    this.y -= rhs.y;
	    this.z -= rhs.z;
	    this.w -= rhs.w;
	    return this;
	  };

	  _proto.sub2 = function sub2(lhs, rhs) {
	    this.x = lhs.x - rhs.x;
	    this.y = lhs.y - rhs.y;
	    this.z = lhs.z - rhs.z;
	    this.w = lhs.w - rhs.w;
	    return this;
	  };

	  _proto.subScalar = function subScalar(scalar) {
	    this.x -= scalar;
	    this.y -= scalar;
	    this.z -= scalar;
	    this.w -= scalar;
	    return this;
	  };

	  _proto.toString = function toString() {
	    return "[" + this.x + ", " + this.y + ", " + this.z + ", " + this.w + "]";
	  };

	  return Vec4;
	}();

	Vec4.ZERO = Object.freeze(new Vec4(0, 0, 0, 0));
	Vec4.ONE = Object.freeze(new Vec4(1, 1, 1, 1));

	var _halfSize$1 = new Vec2();

	var x = new Vec3();
	var y = new Vec3();
	var z = new Vec3();
	var scale = new Vec3();

	var Mat4 = function () {
	  function Mat4() {
	    var data = new Float32Array(16);
	    data[0] = data[5] = data[10] = data[15] = 1;
	    this.data = data;
	  }

	  Mat4._getPerspectiveHalfSize = function _getPerspectiveHalfSize(halfSize, fov, aspect, znear, fovIsHorizontal) {
	    if (fovIsHorizontal) {
	      halfSize.x = znear * Math.tan(fov * Math.PI / 360);
	      halfSize.y = halfSize.x / aspect;
	    } else {
	      halfSize.y = znear * Math.tan(fov * Math.PI / 360);
	      halfSize.x = halfSize.y * aspect;
	    }
	  };

	  var _proto = Mat4.prototype;

	  _proto.add2 = function add2(lhs, rhs) {
	    var a = lhs.data,
	        b = rhs.data,
	        r = this.data;
	    r[0] = a[0] + b[0];
	    r[1] = a[1] + b[1];
	    r[2] = a[2] + b[2];
	    r[3] = a[3] + b[3];
	    r[4] = a[4] + b[4];
	    r[5] = a[5] + b[5];
	    r[6] = a[6] + b[6];
	    r[7] = a[7] + b[7];
	    r[8] = a[8] + b[8];
	    r[9] = a[9] + b[9];
	    r[10] = a[10] + b[10];
	    r[11] = a[11] + b[11];
	    r[12] = a[12] + b[12];
	    r[13] = a[13] + b[13];
	    r[14] = a[14] + b[14];
	    r[15] = a[15] + b[15];
	    return this;
	  };

	  _proto.add = function add(rhs) {
	    return this.add2(this, rhs);
	  };

	  _proto.clone = function clone() {
	    var cstr = this.constructor;
	    return new cstr().copy(this);
	  };

	  _proto.copy = function copy(rhs) {
	    var src = rhs.data,
	        dst = this.data;
	    dst[0] = src[0];
	    dst[1] = src[1];
	    dst[2] = src[2];
	    dst[3] = src[3];
	    dst[4] = src[4];
	    dst[5] = src[5];
	    dst[6] = src[6];
	    dst[7] = src[7];
	    dst[8] = src[8];
	    dst[9] = src[9];
	    dst[10] = src[10];
	    dst[11] = src[11];
	    dst[12] = src[12];
	    dst[13] = src[13];
	    dst[14] = src[14];
	    dst[15] = src[15];
	    return this;
	  };

	  _proto.equals = function equals(rhs) {
	    var l = this.data,
	        r = rhs.data;
	    return l[0] === r[0] && l[1] === r[1] && l[2] === r[2] && l[3] === r[3] && l[4] === r[4] && l[5] === r[5] && l[6] === r[6] && l[7] === r[7] && l[8] === r[8] && l[9] === r[9] && l[10] === r[10] && l[11] === r[11] && l[12] === r[12] && l[13] === r[13] && l[14] === r[14] && l[15] === r[15];
	  };

	  _proto.isIdentity = function isIdentity() {
	    var m = this.data;
	    return m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 0 && m[4] === 0 && m[5] === 1 && m[6] === 0 && m[7] === 0 && m[8] === 0 && m[9] === 0 && m[10] === 1 && m[11] === 0 && m[12] === 0 && m[13] === 0 && m[14] === 0 && m[15] === 1;
	  };

	  _proto.mul2 = function mul2(lhs, rhs) {
	    var a = lhs.data;
	    var b = rhs.data;
	    var r = this.data;
	    var a00 = a[0];
	    var a01 = a[1];
	    var a02 = a[2];
	    var a03 = a[3];
	    var a10 = a[4];
	    var a11 = a[5];
	    var a12 = a[6];
	    var a13 = a[7];
	    var a20 = a[8];
	    var a21 = a[9];
	    var a22 = a[10];
	    var a23 = a[11];
	    var a30 = a[12];
	    var a31 = a[13];
	    var a32 = a[14];
	    var a33 = a[15];
	    var b0, b1, b2, b3;
	    b0 = b[0];
	    b1 = b[1];
	    b2 = b[2];
	    b3 = b[3];
	    r[0] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
	    r[1] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
	    r[2] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
	    r[3] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;
	    b0 = b[4];
	    b1 = b[5];
	    b2 = b[6];
	    b3 = b[7];
	    r[4] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
	    r[5] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
	    r[6] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
	    r[7] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;
	    b0 = b[8];
	    b1 = b[9];
	    b2 = b[10];
	    b3 = b[11];
	    r[8] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
	    r[9] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
	    r[10] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
	    r[11] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;
	    b0 = b[12];
	    b1 = b[13];
	    b2 = b[14];
	    b3 = b[15];
	    r[12] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
	    r[13] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
	    r[14] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
	    r[15] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;
	    return this;
	  };

	  _proto.mulAffine2 = function mulAffine2(lhs, rhs) {
	    var a = lhs.data;
	    var b = rhs.data;
	    var r = this.data;
	    var a00 = a[0];
	    var a01 = a[1];
	    var a02 = a[2];
	    var a10 = a[4];
	    var a11 = a[5];
	    var a12 = a[6];
	    var a20 = a[8];
	    var a21 = a[9];
	    var a22 = a[10];
	    var a30 = a[12];
	    var a31 = a[13];
	    var a32 = a[14];
	    var b0, b1, b2;
	    b0 = b[0];
	    b1 = b[1];
	    b2 = b[2];
	    r[0] = a00 * b0 + a10 * b1 + a20 * b2;
	    r[1] = a01 * b0 + a11 * b1 + a21 * b2;
	    r[2] = a02 * b0 + a12 * b1 + a22 * b2;
	    r[3] = 0;
	    b0 = b[4];
	    b1 = b[5];
	    b2 = b[6];
	    r[4] = a00 * b0 + a10 * b1 + a20 * b2;
	    r[5] = a01 * b0 + a11 * b1 + a21 * b2;
	    r[6] = a02 * b0 + a12 * b1 + a22 * b2;
	    r[7] = 0;
	    b0 = b[8];
	    b1 = b[9];
	    b2 = b[10];
	    r[8] = a00 * b0 + a10 * b1 + a20 * b2;
	    r[9] = a01 * b0 + a11 * b1 + a21 * b2;
	    r[10] = a02 * b0 + a12 * b1 + a22 * b2;
	    r[11] = 0;
	    b0 = b[12];
	    b1 = b[13];
	    b2 = b[14];
	    r[12] = a00 * b0 + a10 * b1 + a20 * b2 + a30;
	    r[13] = a01 * b0 + a11 * b1 + a21 * b2 + a31;
	    r[14] = a02 * b0 + a12 * b1 + a22 * b2 + a32;
	    r[15] = 1;
	    return this;
	  };

	  _proto.mul = function mul(rhs) {
	    return this.mul2(this, rhs);
	  };

	  _proto.transformPoint = function transformPoint(vec, res) {
	    if (res === void 0) {
	      res = new Vec3();
	    }

	    var m = this.data;
	    var x = vec.x;
	    var y = vec.y;
	    var z = vec.z;
	    res.x = x * m[0] + y * m[4] + z * m[8] + m[12];
	    res.y = x * m[1] + y * m[5] + z * m[9] + m[13];
	    res.z = x * m[2] + y * m[6] + z * m[10] + m[14];
	    return res;
	  };

	  _proto.transformVector = function transformVector(vec, res) {
	    if (res === void 0) {
	      res = new Vec3();
	    }

	    var m = this.data;
	    var x = vec.x;
	    var y = vec.y;
	    var z = vec.z;
	    res.x = x * m[0] + y * m[4] + z * m[8];
	    res.y = x * m[1] + y * m[5] + z * m[9];
	    res.z = x * m[2] + y * m[6] + z * m[10];
	    return res;
	  };

	  _proto.transformVec4 = function transformVec4(vec, res) {
	    if (res === void 0) {
	      res = new Vec4();
	    }

	    var m = this.data;
	    var x = vec.x;
	    var y = vec.y;
	    var z = vec.z;
	    var w = vec.w;
	    res.x = x * m[0] + y * m[4] + z * m[8] + w * m[12];
	    res.y = x * m[1] + y * m[5] + z * m[9] + w * m[13];
	    res.z = x * m[2] + y * m[6] + z * m[10] + w * m[14];
	    res.w = x * m[3] + y * m[7] + z * m[11] + w * m[15];
	    return res;
	  };

	  _proto.setLookAt = function setLookAt(position, target, up) {
	    z.sub2(position, target).normalize();
	    y.copy(up).normalize();
	    x.cross(y, z).normalize();
	    y.cross(z, x);
	    var r = this.data;
	    r[0] = x.x;
	    r[1] = x.y;
	    r[2] = x.z;
	    r[3] = 0;
	    r[4] = y.x;
	    r[5] = y.y;
	    r[6] = y.z;
	    r[7] = 0;
	    r[8] = z.x;
	    r[9] = z.y;
	    r[10] = z.z;
	    r[11] = 0;
	    r[12] = position.x;
	    r[13] = position.y;
	    r[14] = position.z;
	    r[15] = 1;
	    return this;
	  };

	  _proto.setFrustum = function setFrustum(left, right, bottom, top, znear, zfar) {
	    var temp1 = 2 * znear;
	    var temp2 = right - left;
	    var temp3 = top - bottom;
	    var temp4 = zfar - znear;
	    var r = this.data;
	    r[0] = temp1 / temp2;
	    r[1] = 0;
	    r[2] = 0;
	    r[3] = 0;
	    r[4] = 0;
	    r[5] = temp1 / temp3;
	    r[6] = 0;
	    r[7] = 0;
	    r[8] = (right + left) / temp2;
	    r[9] = (top + bottom) / temp3;
	    r[10] = (-zfar - znear) / temp4;
	    r[11] = -1;
	    r[12] = 0;
	    r[13] = 0;
	    r[14] = -temp1 * zfar / temp4;
	    r[15] = 0;
	    return this;
	  };

	  _proto.setPerspective = function setPerspective(fov, aspect, znear, zfar, fovIsHorizontal) {
	    Mat4._getPerspectiveHalfSize(_halfSize$1, fov, aspect, znear, fovIsHorizontal);

	    return this.setFrustum(-_halfSize$1.x, _halfSize$1.x, -_halfSize$1.y, _halfSize$1.y, znear, zfar);
	  };

	  _proto.setOrtho = function setOrtho(left, right, bottom, top, near, far) {
	    var r = this.data;
	    r[0] = 2 / (right - left);
	    r[1] = 0;
	    r[2] = 0;
	    r[3] = 0;
	    r[4] = 0;
	    r[5] = 2 / (top - bottom);
	    r[6] = 0;
	    r[7] = 0;
	    r[8] = 0;
	    r[9] = 0;
	    r[10] = -2 / (far - near);
	    r[11] = 0;
	    r[12] = -(right + left) / (right - left);
	    r[13] = -(top + bottom) / (top - bottom);
	    r[14] = -(far + near) / (far - near);
	    r[15] = 1;
	    return this;
	  };

	  _proto.setFromAxisAngle = function setFromAxisAngle(axis, angle) {
	    angle *= math.DEG_TO_RAD;
	    var x = axis.x;
	    var y = axis.y;
	    var z = axis.z;
	    var c = Math.cos(angle);
	    var s = Math.sin(angle);
	    var t = 1 - c;
	    var tx = t * x;
	    var ty = t * y;
	    var m = this.data;
	    m[0] = tx * x + c;
	    m[1] = tx * y + s * z;
	    m[2] = tx * z - s * y;
	    m[3] = 0;
	    m[4] = tx * y - s * z;
	    m[5] = ty * y + c;
	    m[6] = ty * z + s * x;
	    m[7] = 0;
	    m[8] = tx * z + s * y;
	    m[9] = ty * z - x * s;
	    m[10] = t * z * z + c;
	    m[11] = 0;
	    m[12] = 0;
	    m[13] = 0;
	    m[14] = 0;
	    m[15] = 1;
	    return this;
	  };

	  _proto.setTranslate = function setTranslate(x, y, z) {
	    var m = this.data;
	    m[0] = 1;
	    m[1] = 0;
	    m[2] = 0;
	    m[3] = 0;
	    m[4] = 0;
	    m[5] = 1;
	    m[6] = 0;
	    m[7] = 0;
	    m[8] = 0;
	    m[9] = 0;
	    m[10] = 1;
	    m[11] = 0;
	    m[12] = x;
	    m[13] = y;
	    m[14] = z;
	    m[15] = 1;
	    return this;
	  };

	  _proto.setScale = function setScale(x, y, z) {
	    var m = this.data;
	    m[0] = x;
	    m[1] = 0;
	    m[2] = 0;
	    m[3] = 0;
	    m[4] = 0;
	    m[5] = y;
	    m[6] = 0;
	    m[7] = 0;
	    m[8] = 0;
	    m[9] = 0;
	    m[10] = z;
	    m[11] = 0;
	    m[12] = 0;
	    m[13] = 0;
	    m[14] = 0;
	    m[15] = 1;
	    return this;
	  };

	  _proto.setViewport = function setViewport(x, y, width, height) {
	    var m = this.data;
	    m[0] = width * 0.5;
	    m[1] = 0;
	    m[2] = 0;
	    m[3] = 0;
	    m[4] = 0;
	    m[5] = height * 0.5;
	    m[6] = 0;
	    m[7] = 0;
	    m[8] = 0;
	    m[9] = 0;
	    m[10] = 0.5;
	    m[11] = 0;
	    m[12] = x + width * 0.5;
	    m[13] = y + height * 0.5;
	    m[14] = 0.5;
	    m[15] = 1;
	    return this;
	  };

	  _proto.invert = function invert() {
	    var m = this.data;
	    var a00 = m[0];
	    var a01 = m[1];
	    var a02 = m[2];
	    var a03 = m[3];
	    var a10 = m[4];
	    var a11 = m[5];
	    var a12 = m[6];
	    var a13 = m[7];
	    var a20 = m[8];
	    var a21 = m[9];
	    var a22 = m[10];
	    var a23 = m[11];
	    var a30 = m[12];
	    var a31 = m[13];
	    var a32 = m[14];
	    var a33 = m[15];
	    var b00 = a00 * a11 - a01 * a10;
	    var b01 = a00 * a12 - a02 * a10;
	    var b02 = a00 * a13 - a03 * a10;
	    var b03 = a01 * a12 - a02 * a11;
	    var b04 = a01 * a13 - a03 * a11;
	    var b05 = a02 * a13 - a03 * a12;
	    var b06 = a20 * a31 - a21 * a30;
	    var b07 = a20 * a32 - a22 * a30;
	    var b08 = a20 * a33 - a23 * a30;
	    var b09 = a21 * a32 - a22 * a31;
	    var b10 = a21 * a33 - a23 * a31;
	    var b11 = a22 * a33 - a23 * a32;
	    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

	    if (det === 0) {
	      this.setIdentity();
	    } else {
	      var invDet = 1 / det;
	      m[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;
	      m[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;
	      m[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;
	      m[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;
	      m[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * invDet;
	      m[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;
	      m[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * invDet;
	      m[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;
	      m[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;
	      m[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;
	      m[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;
	      m[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;
	      m[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet;
	      m[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;
	      m[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet;
	      m[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;
	    }

	    return this;
	  };

	  _proto.set = function set(src) {
	    var dst = this.data;
	    dst[0] = src[0];
	    dst[1] = src[1];
	    dst[2] = src[2];
	    dst[3] = src[3];
	    dst[4] = src[4];
	    dst[5] = src[5];
	    dst[6] = src[6];
	    dst[7] = src[7];
	    dst[8] = src[8];
	    dst[9] = src[9];
	    dst[10] = src[10];
	    dst[11] = src[11];
	    dst[12] = src[12];
	    dst[13] = src[13];
	    dst[14] = src[14];
	    dst[15] = src[15];
	    return this;
	  };

	  _proto.setIdentity = function setIdentity() {
	    var m = this.data;
	    m[0] = 1;
	    m[1] = 0;
	    m[2] = 0;
	    m[3] = 0;
	    m[4] = 0;
	    m[5] = 1;
	    m[6] = 0;
	    m[7] = 0;
	    m[8] = 0;
	    m[9] = 0;
	    m[10] = 1;
	    m[11] = 0;
	    m[12] = 0;
	    m[13] = 0;
	    m[14] = 0;
	    m[15] = 1;
	    return this;
	  };

	  _proto.setTRS = function setTRS(t, r, s) {
	    var qx = r.x;
	    var qy = r.y;
	    var qz = r.z;
	    var qw = r.w;
	    var sx = s.x;
	    var sy = s.y;
	    var sz = s.z;
	    var x2 = qx + qx;
	    var y2 = qy + qy;
	    var z2 = qz + qz;
	    var xx = qx * x2;
	    var xy = qx * y2;
	    var xz = qx * z2;
	    var yy = qy * y2;
	    var yz = qy * z2;
	    var zz = qz * z2;
	    var wx = qw * x2;
	    var wy = qw * y2;
	    var wz = qw * z2;
	    var m = this.data;
	    m[0] = (1 - (yy + zz)) * sx;
	    m[1] = (xy + wz) * sx;
	    m[2] = (xz - wy) * sx;
	    m[3] = 0;
	    m[4] = (xy - wz) * sy;
	    m[5] = (1 - (xx + zz)) * sy;
	    m[6] = (yz + wx) * sy;
	    m[7] = 0;
	    m[8] = (xz + wy) * sz;
	    m[9] = (yz - wx) * sz;
	    m[10] = (1 - (xx + yy)) * sz;
	    m[11] = 0;
	    m[12] = t.x;
	    m[13] = t.y;
	    m[14] = t.z;
	    m[15] = 1;
	    return this;
	  };

	  _proto.transpose = function transpose() {
	    var tmp;
	    var m = this.data;
	    tmp = m[1];
	    m[1] = m[4];
	    m[4] = tmp;
	    tmp = m[2];
	    m[2] = m[8];
	    m[8] = tmp;
	    tmp = m[3];
	    m[3] = m[12];
	    m[12] = tmp;
	    tmp = m[6];
	    m[6] = m[9];
	    m[9] = tmp;
	    tmp = m[7];
	    m[7] = m[13];
	    m[13] = tmp;
	    tmp = m[11];
	    m[11] = m[14];
	    m[14] = tmp;
	    return this;
	  };

	  _proto.invertTo3x3 = function invertTo3x3(res) {
	    var m = this.data;
	    var r = res.data;
	    var m0 = m[0];
	    var m1 = m[1];
	    var m2 = m[2];
	    var m4 = m[4];
	    var m5 = m[5];
	    var m6 = m[6];
	    var m8 = m[8];
	    var m9 = m[9];
	    var m10 = m[10];
	    var a11 = m10 * m5 - m6 * m9;
	    var a21 = -m10 * m1 + m2 * m9;
	    var a31 = m6 * m1 - m2 * m5;
	    var a12 = -m10 * m4 + m6 * m8;
	    var a22 = m10 * m0 - m2 * m8;
	    var a32 = -m6 * m0 + m2 * m4;
	    var a13 = m9 * m4 - m5 * m8;
	    var a23 = -m9 * m0 + m1 * m8;
	    var a33 = m5 * m0 - m1 * m4;
	    var det = m0 * a11 + m1 * a12 + m2 * a13;

	    if (det === 0) {
	      return this;
	    }

	    var idet = 1 / det;
	    r[0] = idet * a11;
	    r[1] = idet * a21;
	    r[2] = idet * a31;
	    r[3] = idet * a12;
	    r[4] = idet * a22;
	    r[5] = idet * a32;
	    r[6] = idet * a13;
	    r[7] = idet * a23;
	    r[8] = idet * a33;
	    return this;
	  };

	  _proto.getTranslation = function getTranslation(t) {
	    if (t === void 0) {
	      t = new Vec3();
	    }

	    return t.set(this.data[12], this.data[13], this.data[14]);
	  };

	  _proto.getX = function getX(x) {
	    if (x === void 0) {
	      x = new Vec3();
	    }

	    return x.set(this.data[0], this.data[1], this.data[2]);
	  };

	  _proto.getY = function getY(y) {
	    if (y === void 0) {
	      y = new Vec3();
	    }

	    return y.set(this.data[4], this.data[5], this.data[6]);
	  };

	  _proto.getZ = function getZ(z) {
	    if (z === void 0) {
	      z = new Vec3();
	    }

	    return z.set(this.data[8], this.data[9], this.data[10]);
	  };

	  _proto.getScale = function getScale(scale) {
	    if (scale === void 0) {
	      scale = new Vec3();
	    }

	    this.getX(x);
	    this.getY(y);
	    this.getZ(z);
	    scale.set(x.length(), y.length(), z.length());
	    return scale;
	  };

	  _proto.setFromEulerAngles = function setFromEulerAngles(ex, ey, ez) {
	    ex *= math.DEG_TO_RAD;
	    ey *= math.DEG_TO_RAD;
	    ez *= math.DEG_TO_RAD;
	    var s1 = Math.sin(-ex);
	    var c1 = Math.cos(-ex);
	    var s2 = Math.sin(-ey);
	    var c2 = Math.cos(-ey);
	    var s3 = Math.sin(-ez);
	    var c3 = Math.cos(-ez);
	    var m = this.data;
	    m[0] = c2 * c3;
	    m[1] = -c2 * s3;
	    m[2] = s2;
	    m[3] = 0;
	    m[4] = c1 * s3 + c3 * s1 * s2;
	    m[5] = c1 * c3 - s1 * s2 * s3;
	    m[6] = -c2 * s1;
	    m[7] = 0;
	    m[8] = s1 * s3 - c1 * c3 * s2;
	    m[9] = c3 * s1 + c1 * s2 * s3;
	    m[10] = c1 * c2;
	    m[11] = 0;
	    m[12] = 0;
	    m[13] = 0;
	    m[14] = 0;
	    m[15] = 1;
	    return this;
	  };

	  _proto.getEulerAngles = function getEulerAngles(eulers) {
	    if (eulers === void 0) {
	      eulers = new Vec3();
	    }

	    this.getScale(scale);
	    var sx = scale.x;
	    var sy = scale.y;
	    var sz = scale.z;
	    if (sx === 0 || sy === 0 || sz === 0) return eulers.set(0, 0, 0);
	    var m = this.data;
	    var y = Math.asin(-m[2] / sx);
	    var halfPi = Math.PI * 0.5;
	    var x, z;

	    if (y < halfPi) {
	      if (y > -halfPi) {
	        x = Math.atan2(m[6] / sy, m[10] / sz);
	        z = Math.atan2(m[1] / sx, m[0] / sx);
	      } else {
	        z = 0;
	        x = -Math.atan2(m[4] / sy, m[5] / sy);
	      }
	    } else {
	      z = 0;
	      x = Math.atan2(m[4] / sy, m[5] / sy);
	    }

	    return eulers.set(x, y, z).mulScalar(math.RAD_TO_DEG);
	  };

	  _proto.toString = function toString() {
	    return '[' + this.data.join(', ') + ']';
	  };

	  return Mat4;
	}();

	Mat4.IDENTITY = Object.freeze(new Mat4());
	Mat4.ZERO = Object.freeze(new Mat4().set([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]));

	var Quat = function () {
	  function Quat(x, y, z, w) {
	    if (x === void 0) {
	      x = 0;
	    }

	    if (y === void 0) {
	      y = 0;
	    }

	    if (z === void 0) {
	      z = 0;
	    }

	    if (w === void 0) {
	      w = 1;
	    }

	    if (x.length === 4) {
	      this.x = x[0];
	      this.y = x[1];
	      this.z = x[2];
	      this.w = x[3];
	    } else {
	      this.x = x;
	      this.y = y;
	      this.z = z;
	      this.w = w;
	    }
	  }

	  var _proto = Quat.prototype;

	  _proto.clone = function clone() {
	    var cstr = this.constructor;
	    return new cstr(this.x, this.y, this.z, this.w);
	  };

	  _proto.conjugate = function conjugate() {
	    this.x *= -1;
	    this.y *= -1;
	    this.z *= -1;
	    return this;
	  };

	  _proto.copy = function copy(rhs) {
	    this.x = rhs.x;
	    this.y = rhs.y;
	    this.z = rhs.z;
	    this.w = rhs.w;
	    return this;
	  };

	  _proto.equals = function equals(rhs) {
	    return this.x === rhs.x && this.y === rhs.y && this.z === rhs.z && this.w === rhs.w;
	  };

	  _proto.getAxisAngle = function getAxisAngle(axis) {
	    var rad = Math.acos(this.w) * 2;
	    var s = Math.sin(rad / 2);

	    if (s !== 0) {
	      axis.x = this.x / s;
	      axis.y = this.y / s;
	      axis.z = this.z / s;

	      if (axis.x < 0 || axis.y < 0 || axis.z < 0) {
	        axis.x *= -1;
	        axis.y *= -1;
	        axis.z *= -1;
	        rad *= -1;
	      }
	    } else {
	      axis.x = 1;
	      axis.y = 0;
	      axis.z = 0;
	    }

	    return rad * math.RAD_TO_DEG;
	  };

	  _proto.getEulerAngles = function getEulerAngles(eulers) {
	    if (eulers === void 0) {
	      eulers = new Vec3();
	    }

	    var x, y, z;
	    var qx = this.x;
	    var qy = this.y;
	    var qz = this.z;
	    var qw = this.w;
	    var a2 = 2 * (qw * qy - qx * qz);

	    if (a2 <= -0.99999) {
	      x = 2 * Math.atan2(qx, qw);
	      y = -Math.PI / 2;
	      z = 0;
	    } else if (a2 >= 0.99999) {
	      x = 2 * Math.atan2(qx, qw);
	      y = Math.PI / 2;
	      z = 0;
	    } else {
	      x = Math.atan2(2 * (qw * qx + qy * qz), 1 - 2 * (qx * qx + qy * qy));
	      y = Math.asin(a2);
	      z = Math.atan2(2 * (qw * qz + qx * qy), 1 - 2 * (qy * qy + qz * qz));
	    }

	    return eulers.set(x, y, z).mulScalar(math.RAD_TO_DEG);
	  };

	  _proto.invert = function invert() {
	    return this.conjugate().normalize();
	  };

	  _proto.length = function length() {
	    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
	  };

	  _proto.lengthSq = function lengthSq() {
	    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
	  };

	  _proto.mul = function mul(rhs) {
	    var q1x = this.x;
	    var q1y = this.y;
	    var q1z = this.z;
	    var q1w = this.w;
	    var q2x = rhs.x;
	    var q2y = rhs.y;
	    var q2z = rhs.z;
	    var q2w = rhs.w;
	    this.x = q1w * q2x + q1x * q2w + q1y * q2z - q1z * q2y;
	    this.y = q1w * q2y + q1y * q2w + q1z * q2x - q1x * q2z;
	    this.z = q1w * q2z + q1z * q2w + q1x * q2y - q1y * q2x;
	    this.w = q1w * q2w - q1x * q2x - q1y * q2y - q1z * q2z;
	    return this;
	  };

	  _proto.mul2 = function mul2(lhs, rhs) {
	    var q1x = lhs.x;
	    var q1y = lhs.y;
	    var q1z = lhs.z;
	    var q1w = lhs.w;
	    var q2x = rhs.x;
	    var q2y = rhs.y;
	    var q2z = rhs.z;
	    var q2w = rhs.w;
	    this.x = q1w * q2x + q1x * q2w + q1y * q2z - q1z * q2y;
	    this.y = q1w * q2y + q1y * q2w + q1z * q2x - q1x * q2z;
	    this.z = q1w * q2z + q1z * q2w + q1x * q2y - q1y * q2x;
	    this.w = q1w * q2w - q1x * q2x - q1y * q2y - q1z * q2z;
	    return this;
	  };

	  _proto.normalize = function normalize() {
	    var len = this.length();

	    if (len === 0) {
	      this.x = this.y = this.z = 0;
	      this.w = 1;
	    } else {
	      len = 1 / len;
	      this.x *= len;
	      this.y *= len;
	      this.z *= len;
	      this.w *= len;
	    }

	    return this;
	  };

	  _proto.set = function set(x, y, z, w) {
	    this.x = x;
	    this.y = y;
	    this.z = z;
	    this.w = w;
	    return this;
	  };

	  _proto.setFromAxisAngle = function setFromAxisAngle(axis, angle) {
	    angle *= 0.5 * math.DEG_TO_RAD;
	    var sa = Math.sin(angle);
	    var ca = Math.cos(angle);
	    this.x = sa * axis.x;
	    this.y = sa * axis.y;
	    this.z = sa * axis.z;
	    this.w = ca;
	    return this;
	  };

	  _proto.setFromEulerAngles = function setFromEulerAngles(ex, ey, ez) {
	    if (ex instanceof Vec3) {
	      var vec = ex;
	      ex = vec.x;
	      ey = vec.y;
	      ez = vec.z;
	    }

	    var halfToRad = 0.5 * math.DEG_TO_RAD;
	    ex *= halfToRad;
	    ey *= halfToRad;
	    ez *= halfToRad;
	    var sx = Math.sin(ex);
	    var cx = Math.cos(ex);
	    var sy = Math.sin(ey);
	    var cy = Math.cos(ey);
	    var sz = Math.sin(ez);
	    var cz = Math.cos(ez);
	    this.x = sx * cy * cz - cx * sy * sz;
	    this.y = cx * sy * cz + sx * cy * sz;
	    this.z = cx * cy * sz - sx * sy * cz;
	    this.w = cx * cy * cz + sx * sy * sz;
	    return this;
	  };

	  _proto.setFromMat4 = function setFromMat4(m) {
	    var m00, m01, m02, m10, m11, m12, m20, m21, m22, s, rs, lx, ly, lz;
	    m = m.data;
	    m00 = m[0];
	    m01 = m[1];
	    m02 = m[2];
	    m10 = m[4];
	    m11 = m[5];
	    m12 = m[6];
	    m20 = m[8];
	    m21 = m[9];
	    m22 = m[10];
	    lx = m00 * m00 + m01 * m01 + m02 * m02;
	    if (lx === 0) return this;
	    lx = 1 / Math.sqrt(lx);
	    ly = m10 * m10 + m11 * m11 + m12 * m12;
	    if (ly === 0) return this;
	    ly = 1 / Math.sqrt(ly);
	    lz = m20 * m20 + m21 * m21 + m22 * m22;
	    if (lz === 0) return this;
	    lz = 1 / Math.sqrt(lz);
	    m00 *= lx;
	    m01 *= lx;
	    m02 *= lx;
	    m10 *= ly;
	    m11 *= ly;
	    m12 *= ly;
	    m20 *= lz;
	    m21 *= lz;
	    m22 *= lz;
	    var tr = m00 + m11 + m22;

	    if (tr >= 0) {
	      s = Math.sqrt(tr + 1);
	      this.w = s * 0.5;
	      s = 0.5 / s;
	      this.x = (m12 - m21) * s;
	      this.y = (m20 - m02) * s;
	      this.z = (m01 - m10) * s;
	    } else {
	      if (m00 > m11) {
	        if (m00 > m22) {
	          rs = m00 - (m11 + m22) + 1;
	          rs = Math.sqrt(rs);
	          this.x = rs * 0.5;
	          rs = 0.5 / rs;
	          this.w = (m12 - m21) * rs;
	          this.y = (m01 + m10) * rs;
	          this.z = (m02 + m20) * rs;
	        } else {
	          rs = m22 - (m00 + m11) + 1;
	          rs = Math.sqrt(rs);
	          this.z = rs * 0.5;
	          rs = 0.5 / rs;
	          this.w = (m01 - m10) * rs;
	          this.x = (m20 + m02) * rs;
	          this.y = (m21 + m12) * rs;
	        }
	      } else if (m11 > m22) {
	        rs = m11 - (m22 + m00) + 1;
	        rs = Math.sqrt(rs);
	        this.y = rs * 0.5;
	        rs = 0.5 / rs;
	        this.w = (m20 - m02) * rs;
	        this.z = (m12 + m21) * rs;
	        this.x = (m10 + m01) * rs;
	      } else {
	        rs = m22 - (m00 + m11) + 1;
	        rs = Math.sqrt(rs);
	        this.z = rs * 0.5;
	        rs = 0.5 / rs;
	        this.w = (m01 - m10) * rs;
	        this.x = (m20 + m02) * rs;
	        this.y = (m21 + m12) * rs;
	      }
	    }

	    return this;
	  };

	  _proto.slerp = function slerp(lhs, rhs, alpha) {
	    var lx = lhs.x;
	    var ly = lhs.y;
	    var lz = lhs.z;
	    var lw = lhs.w;
	    var rx = rhs.x;
	    var ry = rhs.y;
	    var rz = rhs.z;
	    var rw = rhs.w;
	    var cosHalfTheta = lw * rw + lx * rx + ly * ry + lz * rz;

	    if (cosHalfTheta < 0) {
	      rw = -rw;
	      rx = -rx;
	      ry = -ry;
	      rz = -rz;
	      cosHalfTheta = -cosHalfTheta;
	    }

	    if (Math.abs(cosHalfTheta) >= 1) {
	      this.w = lw;
	      this.x = lx;
	      this.y = ly;
	      this.z = lz;
	      return this;
	    }

	    var halfTheta = Math.acos(cosHalfTheta);
	    var sinHalfTheta = Math.sqrt(1 - cosHalfTheta * cosHalfTheta);

	    if (Math.abs(sinHalfTheta) < 0.001) {
	      this.w = lw * 0.5 + rw * 0.5;
	      this.x = lx * 0.5 + rx * 0.5;
	      this.y = ly * 0.5 + ry * 0.5;
	      this.z = lz * 0.5 + rz * 0.5;
	      return this;
	    }

	    var ratioA = Math.sin((1 - alpha) * halfTheta) / sinHalfTheta;
	    var ratioB = Math.sin(alpha * halfTheta) / sinHalfTheta;
	    this.w = lw * ratioA + rw * ratioB;
	    this.x = lx * ratioA + rx * ratioB;
	    this.y = ly * ratioA + ry * ratioB;
	    this.z = lz * ratioA + rz * ratioB;
	    return this;
	  };

	  _proto.transformVector = function transformVector(vec, res) {
	    if (res === void 0) {
	      res = new Vec3();
	    }

	    var x = vec.x,
	        y = vec.y,
	        z = vec.z;
	    var qx = this.x,
	        qy = this.y,
	        qz = this.z,
	        qw = this.w;
	    var ix = qw * x + qy * z - qz * y;
	    var iy = qw * y + qz * x - qx * z;
	    var iz = qw * z + qx * y - qy * x;
	    var iw = -qx * x - qy * y - qz * z;
	    res.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
	    res.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
	    res.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
	    return res;
	  };

	  _proto.toString = function toString() {
	    return "[" + this.x + ", " + this.y + ", " + this.z + ", " + this.w + "]";
	  };

	  return Quat;
	}();

	Quat.IDENTITY = Object.freeze(new Quat(0, 0, 0, 1));
	Quat.ZERO = Object.freeze(new Quat(0, 0, 0, 0));

	var tmpVecA$2 = new Vec3();
	var tmpVecB$1 = new Vec3();
	var tmpVecC = new Vec3();
	var tmpVecD = new Vec3();
	var tmpVecE = new Vec3();

	var BoundingBox = function () {
	  function BoundingBox(center, halfExtents) {
	    if (center === void 0) {
	      center = new Vec3();
	    }

	    if (halfExtents === void 0) {
	      halfExtents = new Vec3(0.5, 0.5, 0.5);
	    }

	    this.center = center;
	    this.halfExtents = halfExtents;
	    this._min = new Vec3();
	    this._max = new Vec3();
	  }

	  var _proto = BoundingBox.prototype;

	  _proto.add = function add(other) {
	    var tc = this.center;
	    var tcx = tc.x;
	    var tcy = tc.y;
	    var tcz = tc.z;
	    var th = this.halfExtents;
	    var thx = th.x;
	    var thy = th.y;
	    var thz = th.z;
	    var tminx = tcx - thx;
	    var tmaxx = tcx + thx;
	    var tminy = tcy - thy;
	    var tmaxy = tcy + thy;
	    var tminz = tcz - thz;
	    var tmaxz = tcz + thz;
	    var oc = other.center;
	    var ocx = oc.x;
	    var ocy = oc.y;
	    var ocz = oc.z;
	    var oh = other.halfExtents;
	    var ohx = oh.x;
	    var ohy = oh.y;
	    var ohz = oh.z;
	    var ominx = ocx - ohx;
	    var omaxx = ocx + ohx;
	    var ominy = ocy - ohy;
	    var omaxy = ocy + ohy;
	    var ominz = ocz - ohz;
	    var omaxz = ocz + ohz;
	    if (ominx < tminx) tminx = ominx;
	    if (omaxx > tmaxx) tmaxx = omaxx;
	    if (ominy < tminy) tminy = ominy;
	    if (omaxy > tmaxy) tmaxy = omaxy;
	    if (ominz < tminz) tminz = ominz;
	    if (omaxz > tmaxz) tmaxz = omaxz;
	    tc.x = (tminx + tmaxx) * 0.5;
	    tc.y = (tminy + tmaxy) * 0.5;
	    tc.z = (tminz + tmaxz) * 0.5;
	    th.x = (tmaxx - tminx) * 0.5;
	    th.y = (tmaxy - tminy) * 0.5;
	    th.z = (tmaxz - tminz) * 0.5;
	  };

	  _proto.copy = function copy(src) {
	    this.center.copy(src.center);
	    this.halfExtents.copy(src.halfExtents);
	  };

	  _proto.clone = function clone() {
	    return new BoundingBox(this.center.clone(), this.halfExtents.clone());
	  };

	  _proto.intersects = function intersects(other) {
	    var aMax = this.getMax();
	    var aMin = this.getMin();
	    var bMax = other.getMax();
	    var bMin = other.getMin();
	    return aMin.x <= bMax.x && aMax.x >= bMin.x && aMin.y <= bMax.y && aMax.y >= bMin.y && aMin.z <= bMax.z && aMax.z >= bMin.z;
	  };

	  _proto._intersectsRay = function _intersectsRay(ray, point) {
	    var tMin = tmpVecA$2.copy(this.getMin()).sub(ray.origin);
	    var tMax = tmpVecB$1.copy(this.getMax()).sub(ray.origin);
	    var dir = ray.direction;

	    if (dir.x === 0) {
	      tMin.x = tMin.x < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
	      tMax.x = tMax.x < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
	    } else {
	      tMin.x /= dir.x;
	      tMax.x /= dir.x;
	    }

	    if (dir.y === 0) {
	      tMin.y = tMin.y < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
	      tMax.y = tMax.y < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
	    } else {
	      tMin.y /= dir.y;
	      tMax.y /= dir.y;
	    }

	    if (dir.z === 0) {
	      tMin.z = tMin.z < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
	      tMax.z = tMax.z < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
	    } else {
	      tMin.z /= dir.z;
	      tMax.z /= dir.z;
	    }

	    var realMin = tmpVecC.set(Math.min(tMin.x, tMax.x), Math.min(tMin.y, tMax.y), Math.min(tMin.z, tMax.z));
	    var realMax = tmpVecD.set(Math.max(tMin.x, tMax.x), Math.max(tMin.y, tMax.y), Math.max(tMin.z, tMax.z));
	    var minMax = Math.min(Math.min(realMax.x, realMax.y), realMax.z);
	    var maxMin = Math.max(Math.max(realMin.x, realMin.y), realMin.z);
	    var intersects = minMax >= maxMin && maxMin >= 0;
	    if (intersects) point.copy(ray.direction).mulScalar(maxMin).add(ray.origin);
	    return intersects;
	  };

	  _proto._fastIntersectsRay = function _fastIntersectsRay(ray) {
	    var diff = tmpVecA$2;
	    var cross = tmpVecB$1;
	    var prod = tmpVecC;
	    var absDiff = tmpVecD;
	    var absDir = tmpVecE;
	    var rayDir = ray.direction;
	    diff.sub2(ray.origin, this.center);
	    absDiff.set(Math.abs(diff.x), Math.abs(diff.y), Math.abs(diff.z));
	    prod.mul2(diff, rayDir);
	    if (absDiff.x > this.halfExtents.x && prod.x >= 0) return false;
	    if (absDiff.y > this.halfExtents.y && prod.y >= 0) return false;
	    if (absDiff.z > this.halfExtents.z && prod.z >= 0) return false;
	    absDir.set(Math.abs(rayDir.x), Math.abs(rayDir.y), Math.abs(rayDir.z));
	    cross.cross(rayDir, diff);
	    cross.set(Math.abs(cross.x), Math.abs(cross.y), Math.abs(cross.z));
	    if (cross.x > this.halfExtents.y * absDir.z + this.halfExtents.z * absDir.y) return false;
	    if (cross.y > this.halfExtents.x * absDir.z + this.halfExtents.z * absDir.x) return false;
	    if (cross.z > this.halfExtents.x * absDir.y + this.halfExtents.y * absDir.x) return false;
	    return true;
	  };

	  _proto.intersectsRay = function intersectsRay(ray, point) {
	    if (point) {
	      return this._intersectsRay(ray, point);
	    }

	    return this._fastIntersectsRay(ray);
	  };

	  _proto.setMinMax = function setMinMax(min, max) {
	    this.center.add2(max, min).mulScalar(0.5);
	    this.halfExtents.sub2(max, min).mulScalar(0.5);
	  };

	  _proto.getMin = function getMin() {
	    return this._min.copy(this.center).sub(this.halfExtents);
	  };

	  _proto.getMax = function getMax() {
	    return this._max.copy(this.center).add(this.halfExtents);
	  };

	  _proto.containsPoint = function containsPoint(point) {
	    var min = this.getMin();
	    var max = this.getMax();

	    if (point.x < min.x || point.x > max.x || point.y < min.y || point.y > max.y || point.z < min.z || point.z > max.z) {
	      return false;
	    }

	    return true;
	  };

	  _proto.setFromTransformedAabb = function setFromTransformedAabb(aabb, m, ignoreScale) {
	    if (ignoreScale === void 0) {
	      ignoreScale = false;
	    }

	    var ac = aabb.center;
	    var ar = aabb.halfExtents;
	    var d = m.data;
	    var mx0 = d[0];
	    var mx1 = d[4];
	    var mx2 = d[8];
	    var my0 = d[1];
	    var my1 = d[5];
	    var my2 = d[9];
	    var mz0 = d[2];
	    var mz1 = d[6];
	    var mz2 = d[10];

	    if (ignoreScale) {
	      var lengthSq = mx0 * mx0 + mx1 * mx1 + mx2 * mx2;

	      if (lengthSq > 0) {
	        var invLength = 1 / Math.sqrt(lengthSq);
	        mx0 *= invLength;
	        mx1 *= invLength;
	        mx2 *= invLength;
	      }

	      lengthSq = my0 * my0 + my1 * my1 + my2 * my2;

	      if (lengthSq > 0) {
	        var _invLength = 1 / Math.sqrt(lengthSq);

	        my0 *= _invLength;
	        my1 *= _invLength;
	        my2 *= _invLength;
	      }

	      lengthSq = mz0 * mz0 + mz1 * mz1 + mz2 * mz2;

	      if (lengthSq > 0) {
	        var _invLength2 = 1 / Math.sqrt(lengthSq);

	        mz0 *= _invLength2;
	        mz1 *= _invLength2;
	        mz2 *= _invLength2;
	      }
	    }

	    this.center.set(d[12] + mx0 * ac.x + mx1 * ac.y + mx2 * ac.z, d[13] + my0 * ac.x + my1 * ac.y + my2 * ac.z, d[14] + mz0 * ac.x + mz1 * ac.y + mz2 * ac.z);
	    this.halfExtents.set(Math.abs(mx0) * ar.x + Math.abs(mx1) * ar.y + Math.abs(mx2) * ar.z, Math.abs(my0) * ar.x + Math.abs(my1) * ar.y + Math.abs(my2) * ar.z, Math.abs(mz0) * ar.x + Math.abs(mz1) * ar.y + Math.abs(mz2) * ar.z);
	  };

	  _proto.compute = function compute(vertices, numVerts) {
	    numVerts = numVerts === undefined ? vertices.length / 3 : numVerts;

	    if (numVerts > 0) {
	      var min = tmpVecA$2.set(vertices[0], vertices[1], vertices[2]);
	      var max = tmpVecB$1.set(vertices[0], vertices[1], vertices[2]);

	      for (var i = 1; i < numVerts; i++) {
	        var x = vertices[i * 3 + 0];
	        var y = vertices[i * 3 + 1];
	        var z = vertices[i * 3 + 2];
	        if (x < min.x) min.x = x;
	        if (y < min.y) min.y = y;
	        if (z < min.z) min.z = z;
	        if (x > max.x) max.x = x;
	        if (y > max.y) max.y = y;
	        if (z > max.z) max.z = z;
	      }

	      this.setMinMax(min, max);
	    }
	  };

	  _proto.intersectsBoundingSphere = function intersectsBoundingSphere(sphere) {
	    var sq = this._distanceToBoundingSphereSq(sphere);

	    if (sq <= sphere.radius * sphere.radius) {
	      return true;
	    }

	    return false;
	  };

	  _proto._distanceToBoundingSphereSq = function _distanceToBoundingSphereSq(sphere) {
	    var boxMin = this.getMin();
	    var boxMax = this.getMax();
	    var sq = 0;
	    var axis = ['x', 'y', 'z'];

	    for (var i = 0; i < 3; ++i) {
	      var out = 0;
	      var pn = sphere.center[axis[i]];
	      var bMin = boxMin[axis[i]];
	      var bMax = boxMax[axis[i]];
	      var val = 0;

	      if (pn < bMin) {
	        val = bMin - pn;
	        out += val * val;
	      }

	      if (pn > bMax) {
	        val = pn - bMax;
	        out += val * val;
	      }

	      sq += out;
	    }

	    return sq;
	  };

	  _proto._expand = function _expand(expandMin, expandMax) {
	    tmpVecA$2.add2(this.getMin(), expandMin);
	    tmpVecB$1.add2(this.getMax(), expandMax);
	    this.setMinMax(tmpVecA$2, tmpVecB$1);
	  };

	  return BoundingBox;
	}();

	var tmpVecA$1 = new Vec3();
	var tmpVecB = new Vec3();

	var BoundingSphere = function () {
	  function BoundingSphere(center, radius) {
	    if (center === void 0) {
	      center = new Vec3();
	    }

	    if (radius === void 0) {
	      radius = 0.5;
	    }

	    this.center = center;
	    this.radius = radius;
	  }

	  var _proto = BoundingSphere.prototype;

	  _proto.containsPoint = function containsPoint(point) {
	    var lenSq = tmpVecA$1.sub2(point, this.center).lengthSq();
	    var r = this.radius;
	    return lenSq < r * r;
	  };

	  _proto.intersectsRay = function intersectsRay(ray, point) {
	    var m = tmpVecA$1.copy(ray.origin).sub(this.center);
	    var b = m.dot(tmpVecB.copy(ray.direction).normalize());
	    var c = m.dot(m) - this.radius * this.radius;
	    if (c > 0 && b > 0) return false;
	    var discr = b * b - c;
	    if (discr < 0) return false;
	    var t = Math.abs(-b - Math.sqrt(discr));
	    if (point) point.copy(ray.direction).mulScalar(t).add(ray.origin);
	    return true;
	  };

	  _proto.intersectsBoundingSphere = function intersectsBoundingSphere(sphere) {
	    tmpVecA$1.sub2(sphere.center, this.center);
	    var totalRadius = sphere.radius + this.radius;

	    if (tmpVecA$1.lengthSq() <= totalRadius * totalRadius) {
	      return true;
	    }

	    return false;
	  };

	  return BoundingSphere;
	}();

	var BLEND_SUBTRACTIVE = 0;
	var BLEND_ADDITIVE = 1;
	var BLEND_NORMAL = 2;
	var BLEND_NONE = 3;
	var BLEND_PREMULTIPLIED = 4;
	var BLEND_MULTIPLICATIVE = 5;
	var BLEND_ADDITIVEALPHA = 6;
	var BLEND_MULTIPLICATIVE2X = 7;
	var BLEND_SCREEN = 8;
	var BLEND_MIN = 9;
	var BLEND_MAX = 10;
	var FOG_NONE = 'none';
	var FOG_LINEAR = 'linear';
	var FOG_EXP = 'exp';
	var FOG_EXP2 = 'exp2';
	var FRESNEL_NONE = 0;
	var FRESNEL_SCHLICK = 2;
	var LAYER_HUD = 0;
	var LAYER_GIZMO = 1;
	var LAYER_FX = 2;
	var LAYER_WORLD = 15;
	var LAYERID_WORLD = 0;
	var LAYERID_DEPTH = 1;
	var LAYERID_SKYBOX = 2;
	var LAYERID_IMMEDIATE = 3;
	var LAYERID_UI = 4;
	var LIGHTTYPE_DIRECTIONAL = 0;
	var LIGHTTYPE_OMNI = 1;
	var LIGHTTYPE_POINT = LIGHTTYPE_OMNI;
	var LIGHTTYPE_SPOT = 2;
	var LIGHTTYPE_COUNT = 3;
	var LIGHTSHAPE_PUNCTUAL = 0;
	var LIGHTSHAPE_RECT = 1;
	var LIGHTSHAPE_DISK = 2;
	var LIGHTSHAPE_SPHERE = 3;
	var LIGHTFALLOFF_LINEAR = 0;
	var LIGHTFALLOFF_INVERSESQUARED = 1;
	var SHADOW_PCF3 = 0;
	var SHADOW_DEPTH = 0;
	var SHADOW_VSM8 = 1;
	var SHADOW_VSM16 = 2;
	var SHADOW_VSM32 = 3;
	var SHADOW_PCF5 = 4;
	var SHADOW_PCF1 = 5;
	var SHADOW_COUNT = 6;
	var shadowTypeToString = {};
	shadowTypeToString[SHADOW_PCF3] = 'PCF3';
	shadowTypeToString[SHADOW_VSM8] = 'VSM8';
	shadowTypeToString[SHADOW_VSM16] = 'VSM16';
	shadowTypeToString[SHADOW_VSM32] = 'VSM32';
	shadowTypeToString[SHADOW_PCF5] = 'PCF5';
	shadowTypeToString[SHADOW_PCF1] = 'PCF1';
	var BLUR_BOX = 0;
	var BLUR_GAUSSIAN = 1;
	var PARTICLESORT_NONE = 0;
	var PARTICLESORT_DISTANCE = 1;
	var PARTICLESORT_NEWER_FIRST = 2;
	var PARTICLESORT_OLDER_FIRST = 3;
	var PARTICLEMODE_GPU = 0;
	var PARTICLEMODE_CPU = 1;
	var EMITTERSHAPE_BOX = 0;
	var EMITTERSHAPE_SPHERE = 1;
	var PARTICLEORIENTATION_SCREEN = 0;
	var PARTICLEORIENTATION_WORLD = 1;
	var PARTICLEORIENTATION_EMITTER = 2;
	var PROJECTION_PERSPECTIVE = 0;
	var PROJECTION_ORTHOGRAPHIC = 1;
	var RENDERSTYLE_SOLID = 0;
	var RENDERSTYLE_WIREFRAME = 1;
	var RENDERSTYLE_POINTS = 2;
	var CUBEPROJ_NONE = 0;
	var CUBEPROJ_BOX = 1;
	var SPECULAR_PHONG = 0;
	var SPECULAR_BLINN = 1;
	var DETAILMODE_MUL = 'mul';
	var DETAILMODE_ADD = 'add';
	var DETAILMODE_SCREEN = 'screen';
	var DETAILMODE_OVERLAY = 'overlay';
	var DETAILMODE_MIN = 'min';
	var DETAILMODE_MAX = 'max';
	var GAMMA_NONE = 0;
	var GAMMA_SRGB = 1;
	var GAMMA_SRGBFAST = 2;
	var GAMMA_SRGBHDR = 3;
	var TONEMAP_LINEAR = 0;
	var TONEMAP_FILMIC = 1;
	var TONEMAP_HEJL = 2;
	var TONEMAP_ACES = 3;
	var TONEMAP_ACES2 = 4;
	var SPECOCC_NONE = 0;
	var SPECOCC_AO = 1;
	var SPECOCC_GLOSSDEPENDENT = 2;
	var SHADERDEF_NOSHADOW = 1;
	var SHADERDEF_SKIN = 2;
	var SHADERDEF_UV0 = 4;
	var SHADERDEF_UV1 = 8;
	var SHADERDEF_VCOLOR = 16;
	var SHADERDEF_INSTANCING = 32;
	var SHADERDEF_LM = 64;
	var SHADERDEF_DIRLM = 128;
	var SHADERDEF_SCREENSPACE = 256;
	var SHADERDEF_TANGENTS = 512;
	var SHADERDEF_MORPH_POSITION = 1024;
	var SHADERDEF_MORPH_NORMAL = 2048;
	var SHADERDEF_MORPH_TEXTURE_BASED = 4096;
	var SHADERDEF_LMAMBIENT = 8192;
	var LINEBATCH_WORLD = 0;
	var LINEBATCH_OVERLAY = 1;
	var LINEBATCH_GIZMO = 2;
	var SHADOWUPDATE_NONE = 0;
	var SHADOWUPDATE_THISFRAME = 1;
	var SHADOWUPDATE_REALTIME = 2;
	var SORTKEY_FORWARD = 0;
	var SORTKEY_DEPTH = 1;
	var MASK_AFFECT_DYNAMIC = 1;
	var MASK_AFFECT_LIGHTMAPPED = 2;
	var MASK_BAKE = 4;
	var SHADER_FORWARD = 0;
	var SHADER_FORWARDHDR = 1;
	var SHADER_DEPTH = 2;
	var SHADER_PICK = 3;
	var SHADER_SHADOW = 4;
	var SHADERTYPE_FORWARD = 'forward';
	var SHADERTYPE_DEPTH = 'depth';
	var SHADERTYPE_PICK = 'pick';
	var SHADERTYPE_SHADOW = 'shadow';
	var SPRITE_RENDERMODE_SIMPLE = 0;
	var SPRITE_RENDERMODE_SLICED = 1;
	var SPRITE_RENDERMODE_TILED = 2;
	var BAKE_COLOR = 0;
	var BAKE_COLORDIR = 1;
	var VIEW_CENTER = 0;
	var VIEW_LEFT = 1;
	var VIEW_RIGHT = 2;
	var SORTMODE_NONE = 0;
	var SORTMODE_MANUAL = 1;
	var SORTMODE_MATERIALMESH = 2;
	var SORTMODE_BACK2FRONT = 3;
	var SORTMODE_FRONT2BACK = 4;
	var SORTMODE_CUSTOM = 5;
	var COMPUPDATED_INSTANCES = 1;
	var COMPUPDATED_LIGHTS = 2;
	var COMPUPDATED_CAMERAS = 4;
	var COMPUPDATED_BLEND = 8;
	var ASPECT_AUTO = 0;
	var ASPECT_MANUAL = 1;
	var ORIENTATION_HORIZONTAL = 0;
	var ORIENTATION_VERTICAL = 1;

	var _frustumPoints = [new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3()];

	var Frustum = function () {
	  function Frustum() {
	    this.planes = [];

	    for (var i = 0; i < 6; i++) {
	      this.planes[i] = [];
	    }
	  }

	  var _proto = Frustum.prototype;

	  _proto.setFromMat4 = function setFromMat4(matrix) {
	    var vpm = matrix.data;
	    var plane;
	    var planes = this.planes;
	    plane = planes[0];
	    plane[0] = vpm[3] - vpm[0];
	    plane[1] = vpm[7] - vpm[4];
	    plane[2] = vpm[11] - vpm[8];
	    plane[3] = vpm[15] - vpm[12];
	    var t = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);
	    plane[0] /= t;
	    plane[1] /= t;
	    plane[2] /= t;
	    plane[3] /= t;
	    plane = planes[1];
	    plane[0] = vpm[3] + vpm[0];
	    plane[1] = vpm[7] + vpm[4];
	    plane[2] = vpm[11] + vpm[8];
	    plane[3] = vpm[15] + vpm[12];
	    t = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);
	    plane[0] /= t;
	    plane[1] /= t;
	    plane[2] /= t;
	    plane[3] /= t;
	    plane = planes[2];
	    plane[0] = vpm[3] + vpm[1];
	    plane[1] = vpm[7] + vpm[5];
	    plane[2] = vpm[11] + vpm[9];
	    plane[3] = vpm[15] + vpm[13];
	    t = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);
	    plane[0] /= t;
	    plane[1] /= t;
	    plane[2] /= t;
	    plane[3] /= t;
	    plane = planes[3];
	    plane[0] = vpm[3] - vpm[1];
	    plane[1] = vpm[7] - vpm[5];
	    plane[2] = vpm[11] - vpm[9];
	    plane[3] = vpm[15] - vpm[13];
	    t = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);
	    plane[0] /= t;
	    plane[1] /= t;
	    plane[2] /= t;
	    plane[3] /= t;
	    plane = planes[4];
	    plane[0] = vpm[3] - vpm[2];
	    plane[1] = vpm[7] - vpm[6];
	    plane[2] = vpm[11] - vpm[10];
	    plane[3] = vpm[15] - vpm[14];
	    t = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);
	    plane[0] /= t;
	    plane[1] /= t;
	    plane[2] /= t;
	    plane[3] /= t;
	    plane = planes[5];
	    plane[0] = vpm[3] + vpm[2];
	    plane[1] = vpm[7] + vpm[6];
	    plane[2] = vpm[11] + vpm[10];
	    plane[3] = vpm[15] + vpm[14];
	    t = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);
	    plane[0] /= t;
	    plane[1] /= t;
	    plane[2] /= t;
	    plane[3] /= t;
	  };

	  _proto.containsPoint = function containsPoint(point) {
	    var p, plane;

	    for (p = 0; p < 6; p++) {
	      plane = this.planes[p];

	      if (plane[0] * point.x + plane[1] * point.y + plane[2] * point.z + plane[3] <= 0) {
	        return false;
	      }
	    }

	    return true;
	  };

	  _proto.containsSphere = function containsSphere(sphere) {
	    var c = 0;
	    var d;
	    var p;
	    var sr = sphere.radius;
	    var sc = sphere.center;
	    var scx = sc.x;
	    var scy = sc.y;
	    var scz = sc.z;
	    var planes = this.planes;
	    var plane;

	    for (p = 0; p < 6; p++) {
	      plane = planes[p];
	      d = plane[0] * scx + plane[1] * scy + plane[2] * scz + plane[3];
	      if (d <= -sr) return 0;
	      if (d > sr) c++;
	    }

	    return c === 6 ? 2 : 1;
	  };

	  Frustum.getPoints = function getPoints(camera, near, far) {
	    near = near || camera._nearClip;
	    far = far || camera._farClip;
	    var fov = camera._fov * Math.PI / 180.0;
	    var y = camera._projection === PROJECTION_PERSPECTIVE ? Math.tan(fov / 2.0) * near : camera._orthoHeight;
	    var x = y * camera._aspectRatio;
	    var points = _frustumPoints;
	    points[0].x = x;
	    points[0].y = -y;
	    points[0].z = -near;
	    points[1].x = x;
	    points[1].y = y;
	    points[1].z = -near;
	    points[2].x = -x;
	    points[2].y = y;
	    points[2].z = -near;
	    points[3].x = -x;
	    points[3].y = -y;
	    points[3].z = -near;

	    if (camera._projection === PROJECTION_PERSPECTIVE) {
	      y = Math.tan(fov / 2.0) * far;
	      x = y * camera._aspectRatio;
	    }

	    points[4].x = x;
	    points[4].y = -y;
	    points[4].z = -far;
	    points[5].x = x;
	    points[5].y = y;
	    points[5].z = -far;
	    points[6].x = -x;
	    points[6].y = y;
	    points[6].z = -far;
	    points[7].x = -x;
	    points[7].y = -y;
	    points[7].z = -far;
	    return points;
	  };

	  return Frustum;
	}();

	var Ray = function () {
	  function Ray(origin, direction) {
	    if (origin === void 0) {
	      origin = new Vec3();
	    }

	    if (direction === void 0) {
	      direction = new Vec3(0, 0, -1);
	    }

	    this.origin = origin;
	    this.direction = direction;
	  }

	  var _proto = Ray.prototype;

	  _proto.set = function set(origin, direction) {
	    this.origin.copy(origin);
	    this.direction.copy(direction);
	    return this;
	  };

	  return Ray;
	}();

	var tmpRay = new Ray();
	var tmpVec3$2 = new Vec3();
	var tmpSphere = new BoundingSphere();
	var tmpMat4$1 = new Mat4();

	var OrientedBox = function () {
	  function OrientedBox(worldTransform, halfExtents) {
	    if (worldTransform === void 0) {
	      worldTransform = new Mat4();
	    }

	    if (halfExtents === void 0) {
	      halfExtents = new Vec3(0.5, 0.5, 0.5);
	    }

	    this.halfExtents = halfExtents;
	    this._modelTransform = worldTransform.clone().invert();
	    this._worldTransform = worldTransform.clone();
	    this._aabb = new BoundingBox(new Vec3(), this.halfExtents);
	  }

	  var _proto = OrientedBox.prototype;

	  _proto.intersectsRay = function intersectsRay(ray, point) {
	    this._modelTransform.transformPoint(ray.origin, tmpRay.origin);

	    this._modelTransform.transformVector(ray.direction, tmpRay.direction);

	    if (point) {
	      var result = this._aabb._intersectsRay(tmpRay, point);

	      tmpMat4$1.copy(this._modelTransform).invert().transformPoint(point, point);
	      return result;
	    }

	    return this._aabb._fastIntersectsRay(tmpRay);
	  };

	  _proto.containsPoint = function containsPoint(point) {
	    this._modelTransform.transformPoint(point, tmpVec3$2);

	    return this._aabb.containsPoint(tmpVec3$2);
	  };

	  _proto.intersectsBoundingSphere = function intersectsBoundingSphere(sphere) {
	    this._modelTransform.transformPoint(sphere.center, tmpSphere.center);

	    tmpSphere.radius = sphere.radius;

	    if (this._aabb.intersectsBoundingSphere(tmpSphere)) {
	      return true;
	    }

	    return false;
	  };

	  _createClass(OrientedBox, [{
	    key: "worldTransform",
	    get: function get() {
	      return this._worldTransform;
	    },
	    set: function set(value) {
	      this._worldTransform.copy(value);

	      this._modelTransform.copy(value).invert();
	    }
	  }]);

	  return OrientedBox;
	}();

	var tmpVecA = new Vec3();

	var Plane = function () {
	  function Plane(point, normal) {
	    if (point === void 0) {
	      point = new Vec3();
	    }

	    if (normal === void 0) {
	      normal = new Vec3(0, 0, 1);
	    }

	    this.normal = normal;
	    this.point = point;
	  }

	  var _proto = Plane.prototype;

	  _proto.intersectsLine = function intersectsLine(start, end, point) {
	    var d = -this.normal.dot(this.point);
	    var d0 = this.normal.dot(start) + d;
	    var d1 = this.normal.dot(end) + d;
	    var t = d0 / (d0 - d1);
	    var intersects = t >= 0 && t <= 1;
	    if (intersects && point) point.lerp(start, end, t);
	    return intersects;
	  };

	  _proto.intersectsRay = function intersectsRay(ray, point) {
	    var pointToOrigin = tmpVecA.sub2(this.point, ray.origin);
	    var t = this.normal.dot(pointToOrigin) / this.normal.dot(ray.direction);
	    var intersects = t >= 0;
	    if (intersects && point) point.copy(ray.direction).mulScalar(t).add(ray.origin);
	    return intersects;
	  };

	  return Plane;
	}();

	var ADDRESS_REPEAT = 0;
	var ADDRESS_CLAMP_TO_EDGE = 1;
	var ADDRESS_MIRRORED_REPEAT = 2;
	var BLENDMODE_ZERO = 0;
	var BLENDMODE_ONE = 1;
	var BLENDMODE_SRC_COLOR = 2;
	var BLENDMODE_ONE_MINUS_SRC_COLOR = 3;
	var BLENDMODE_DST_COLOR = 4;
	var BLENDMODE_ONE_MINUS_DST_COLOR = 5;
	var BLENDMODE_SRC_ALPHA = 6;
	var BLENDMODE_SRC_ALPHA_SATURATE = 7;
	var BLENDMODE_ONE_MINUS_SRC_ALPHA = 8;
	var BLENDMODE_DST_ALPHA = 9;
	var BLENDMODE_ONE_MINUS_DST_ALPHA = 10;
	var BLENDMODE_CONSTANT_COLOR = 11;
	var BLENDMODE_ONE_MINUS_CONSTANT_COLOR = 12;
	var BLENDMODE_CONSTANT_ALPHA = 13;
	var BLENDMODE_ONE_MINUS_CONSTANT_ALPHA = 14;
	var BLENDEQUATION_ADD = 0;
	var BLENDEQUATION_SUBTRACT = 1;
	var BLENDEQUATION_REVERSE_SUBTRACT = 2;
	var BLENDEQUATION_MIN = 3;
	var BLENDEQUATION_MAX = 4;
	var BUFFER_STATIC = 0;
	var BUFFER_DYNAMIC = 1;
	var BUFFER_STREAM = 2;
	var BUFFER_GPUDYNAMIC = 3;
	var CLEARFLAG_COLOR = 1;
	var CLEARFLAG_DEPTH = 2;
	var CLEARFLAG_STENCIL = 4;
	var CUBEFACE_POSX = 0;
	var CUBEFACE_NEGX = 1;
	var CUBEFACE_POSY = 2;
	var CUBEFACE_NEGY = 3;
	var CUBEFACE_POSZ = 4;
	var CUBEFACE_NEGZ = 5;
	var CULLFACE_NONE = 0;
	var CULLFACE_BACK = 1;
	var CULLFACE_FRONT = 2;
	var CULLFACE_FRONTANDBACK = 3;
	var FILTER_NEAREST = 0;
	var FILTER_LINEAR = 1;
	var FILTER_NEAREST_MIPMAP_NEAREST = 2;
	var FILTER_NEAREST_MIPMAP_LINEAR = 3;
	var FILTER_LINEAR_MIPMAP_NEAREST = 4;
	var FILTER_LINEAR_MIPMAP_LINEAR = 5;
	var FUNC_NEVER = 0;
	var FUNC_LESS = 1;
	var FUNC_EQUAL = 2;
	var FUNC_LESSEQUAL = 3;
	var FUNC_GREATER = 4;
	var FUNC_NOTEQUAL = 5;
	var FUNC_GREATEREQUAL = 6;
	var FUNC_ALWAYS = 7;
	var INDEXFORMAT_UINT8 = 0;
	var INDEXFORMAT_UINT16 = 1;
	var INDEXFORMAT_UINT32 = 2;
	var PIXELFORMAT_A8 = 0;
	var PIXELFORMAT_L8 = 1;
	var PIXELFORMAT_L8_A8 = 2;
	var PIXELFORMAT_R5_G6_B5 = 3;
	var PIXELFORMAT_R5_G5_B5_A1 = 4;
	var PIXELFORMAT_R4_G4_B4_A4 = 5;
	var PIXELFORMAT_R8_G8_B8 = 6;
	var PIXELFORMAT_R8_G8_B8_A8 = 7;
	var PIXELFORMAT_DXT1 = 8;
	var PIXELFORMAT_DXT3 = 9;
	var PIXELFORMAT_DXT5 = 10;
	var PIXELFORMAT_RGB16F = 11;
	var PIXELFORMAT_RGBA16F = 12;
	var PIXELFORMAT_RGB32F = 13;
	var PIXELFORMAT_RGBA32F = 14;
	var PIXELFORMAT_R32F = 15;
	var PIXELFORMAT_DEPTH = 16;
	var PIXELFORMAT_DEPTHSTENCIL = 17;
	var PIXELFORMAT_111110F = 18;
	var PIXELFORMAT_SRGB = 19;
	var PIXELFORMAT_SRGBA = 20;
	var PIXELFORMAT_ETC1 = 21;
	var PIXELFORMAT_ETC2_RGB = 22;
	var PIXELFORMAT_ETC2_RGBA = 23;
	var PIXELFORMAT_PVRTC_2BPP_RGB_1 = 24;
	var PIXELFORMAT_PVRTC_2BPP_RGBA_1 = 25;
	var PIXELFORMAT_PVRTC_4BPP_RGB_1 = 26;
	var PIXELFORMAT_PVRTC_4BPP_RGBA_1 = 27;
	var PIXELFORMAT_ASTC_4x4 = 28;
	var PIXELFORMAT_ATC_RGB = 29;
	var PIXELFORMAT_ATC_RGBA = 30;
	var PRIMITIVE_POINTS = 0;
	var PRIMITIVE_LINES = 1;
	var PRIMITIVE_LINELOOP = 2;
	var PRIMITIVE_LINESTRIP = 3;
	var PRIMITIVE_TRIANGLES = 4;
	var PRIMITIVE_TRISTRIP = 5;
	var PRIMITIVE_TRIFAN = 6;
	var SEMANTIC_POSITION = "POSITION";
	var SEMANTIC_NORMAL = "NORMAL";
	var SEMANTIC_TANGENT = "TANGENT";
	var SEMANTIC_BLENDWEIGHT = "BLENDWEIGHT";
	var SEMANTIC_BLENDINDICES = "BLENDINDICES";
	var SEMANTIC_COLOR = "COLOR";
	var SEMANTIC_TEXCOORD = "TEXCOORD";
	var SEMANTIC_TEXCOORD0 = "TEXCOORD0";
	var SEMANTIC_TEXCOORD1 = "TEXCOORD1";
	var SEMANTIC_TEXCOORD2 = "TEXCOORD2";
	var SEMANTIC_TEXCOORD3 = "TEXCOORD3";
	var SEMANTIC_TEXCOORD4 = "TEXCOORD4";
	var SEMANTIC_TEXCOORD5 = "TEXCOORD5";
	var SEMANTIC_TEXCOORD6 = "TEXCOORD6";
	var SEMANTIC_TEXCOORD7 = "TEXCOORD7";
	var SEMANTIC_ATTR = "ATTR";
	var SEMANTIC_ATTR0 = "ATTR0";
	var SEMANTIC_ATTR1 = "ATTR1";
	var SEMANTIC_ATTR2 = "ATTR2";
	var SEMANTIC_ATTR3 = "ATTR3";
	var SEMANTIC_ATTR4 = "ATTR4";
	var SEMANTIC_ATTR5 = "ATTR5";
	var SEMANTIC_ATTR6 = "ATTR6";
	var SEMANTIC_ATTR7 = "ATTR7";
	var SEMANTIC_ATTR8 = "ATTR8";
	var SEMANTIC_ATTR9 = "ATTR9";
	var SEMANTIC_ATTR10 = "ATTR10";
	var SEMANTIC_ATTR11 = "ATTR11";
	var SEMANTIC_ATTR12 = "ATTR12";
	var SEMANTIC_ATTR13 = "ATTR13";
	var SEMANTIC_ATTR14 = "ATTR14";
	var SEMANTIC_ATTR15 = "ATTR15";
	var SHADERTAG_MATERIAL = 1;
	var STENCILOP_KEEP = 0;
	var STENCILOP_ZERO = 1;
	var STENCILOP_REPLACE = 2;
	var STENCILOP_INCREMENT = 3;
	var STENCILOP_INCREMENTWRAP = 4;
	var STENCILOP_DECREMENT = 5;
	var STENCILOP_DECREMENTWRAP = 6;
	var STENCILOP_INVERT = 7;
	var TEXTURELOCK_READ = 1;
	var TEXTURELOCK_WRITE = 2;
	var TEXTURETYPE_DEFAULT = 'default';
	var TEXTURETYPE_RGBM = 'rgbm';
	var TEXTURETYPE_RGBE = 'rgbe';
	var TEXTURETYPE_RGBP = 'rgbp';
	var TEXTURETYPE_SWIZZLEGGGR = 'swizzleGGGR';
	var TEXHINT_NONE = 0;
	var TEXHINT_SHADOWMAP = 1;
	var TEXHINT_ASSET = 2;
	var TEXHINT_LIGHTMAP = 3;
	var TEXTUREPROJECTION_NONE = "none";
	var TEXTUREPROJECTION_CUBE = "cube";
	var TEXTUREPROJECTION_EQUIRECT = "equirect";
	var TEXTUREPROJECTION_OCTAHEDRAL = "octahedral";
	var TYPE_INT8 = 0;
	var TYPE_UINT8 = 1;
	var TYPE_INT16 = 2;
	var TYPE_UINT16 = 3;
	var TYPE_INT32 = 4;
	var TYPE_UINT32 = 5;
	var TYPE_FLOAT32 = 6;
	var UNIFORMTYPE_BOOL = 0;
	var UNIFORMTYPE_INT = 1;
	var UNIFORMTYPE_FLOAT = 2;
	var UNIFORMTYPE_VEC2 = 3;
	var UNIFORMTYPE_VEC3 = 4;
	var UNIFORMTYPE_VEC4 = 5;
	var UNIFORMTYPE_IVEC2 = 6;
	var UNIFORMTYPE_IVEC3 = 7;
	var UNIFORMTYPE_IVEC4 = 8;
	var UNIFORMTYPE_BVEC2 = 9;
	var UNIFORMTYPE_BVEC3 = 10;
	var UNIFORMTYPE_BVEC4 = 11;
	var UNIFORMTYPE_MAT2 = 12;
	var UNIFORMTYPE_MAT3 = 13;
	var UNIFORMTYPE_MAT4 = 14;
	var UNIFORMTYPE_TEXTURE2D = 15;
	var UNIFORMTYPE_TEXTURECUBE = 16;
	var UNIFORMTYPE_FLOATARRAY = 17;
	var UNIFORMTYPE_TEXTURE2D_SHADOW = 18;
	var UNIFORMTYPE_TEXTURECUBE_SHADOW = 19;
	var UNIFORMTYPE_TEXTURE3D = 20;
	var UNIFORMTYPE_VEC2ARRAY = 21;
	var UNIFORMTYPE_VEC3ARRAY = 22;
	var UNIFORMTYPE_VEC4ARRAY = 23;
	var uniformTypeToName = ['bool', 'int', 'float', 'vec2', 'vec3', 'vec4', 'ivec2', 'ivec3', 'ivec4', 'bec2', 'bec3', 'bec4', 'mat2', 'mat3', 'mat4', 'sampler2D', 'samplerCube', '', 'sampler2DShadow', 'samplerCubeShadow', 'sampler3D', '', '', ''];
	var DEVICETYPE_WEBGL = 'webgl';
	var DEVICETYPE_WEBGPU = 'webgpu';
	var SHADERSTAGE_VERTEX = 1;
	var SHADERSTAGE_FRAGMENT = 2;
	var SHADERSTAGE_COMPUTE = 4;
	var BINDGROUP_VIEW = 0;
	var BINDGROUP_MESH = 1;
	var UNIFORM_BUFFER_DEFAULT_SLOT_NAME = 'default';
	var bindGroupNames = ['view', 'mesh'];
	var typedArrayTypes = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array];
	var typedArrayTypesByteSize = [1, 1, 2, 2, 4, 4, 4];
	var typedArrayToType = {
	  "Int8Array": TYPE_INT8,
	  "Uint8Array": TYPE_UINT8,
	  "Int16Array": TYPE_INT16,
	  "Uint16Array": TYPE_UINT16,
	  "Int32Array": TYPE_INT32,
	  "Uint32Array": TYPE_UINT32,
	  "Float32Array": TYPE_FLOAT32
	};
	var typedArrayIndexFormats = [Uint8Array, Uint16Array, Uint32Array];
	var typedArrayIndexFormatsByteSize = [1, 2, 4];
	var semanticToLocation = {};
	semanticToLocation[SEMANTIC_POSITION] = 0;
	semanticToLocation[SEMANTIC_NORMAL] = 1;
	semanticToLocation[SEMANTIC_BLENDWEIGHT] = 2;
	semanticToLocation[SEMANTIC_BLENDINDICES] = 3;
	semanticToLocation[SEMANTIC_COLOR] = 4;
	semanticToLocation[SEMANTIC_TEXCOORD0] = 5;
	semanticToLocation[SEMANTIC_TEXCOORD1] = 6;
	semanticToLocation[SEMANTIC_TEXCOORD2] = 7;
	semanticToLocation[SEMANTIC_TEXCOORD3] = 8;
	semanticToLocation[SEMANTIC_TEXCOORD4] = 9;
	semanticToLocation[SEMANTIC_TEXCOORD5] = 10;
	semanticToLocation[SEMANTIC_TEXCOORD6] = 11;
	semanticToLocation[SEMANTIC_TEXCOORD7] = 12;
	semanticToLocation[SEMANTIC_TANGENT] = 13;
	semanticToLocation[SEMANTIC_ATTR0] = 0;
	semanticToLocation[SEMANTIC_ATTR1] = 1;
	semanticToLocation[SEMANTIC_ATTR2] = 2;
	semanticToLocation[SEMANTIC_ATTR3] = 3;
	semanticToLocation[SEMANTIC_ATTR4] = 4;
	semanticToLocation[SEMANTIC_ATTR5] = 5;
	semanticToLocation[SEMANTIC_ATTR6] = 6;
	semanticToLocation[SEMANTIC_ATTR7] = 7;
	semanticToLocation[SEMANTIC_ATTR8] = 8;
	semanticToLocation[SEMANTIC_ATTR9] = 9;
	semanticToLocation[SEMANTIC_ATTR10] = 10;
	semanticToLocation[SEMANTIC_ATTR11] = 11;
	semanticToLocation[SEMANTIC_ATTR12] = 12;
	semanticToLocation[SEMANTIC_ATTR13] = 13;
	semanticToLocation[SEMANTIC_ATTR14] = 14;
	semanticToLocation[SEMANTIC_ATTR15] = 15;
	var CHUNKAPI_1_51 = '1.51';
	var CHUNKAPI_1_55 = '1.55';
	var CHUNKAPI_1_56 = '1.56';

	var id$7 = 0;

	var VertexBuffer = function () {
	  function VertexBuffer(graphicsDevice, format, numVertices, usage, initialData) {
	    if (usage === void 0) {
	      usage = BUFFER_STATIC;
	    }

	    this.device = graphicsDevice;
	    this.format = format;
	    this.numVertices = numVertices;
	    this.usage = usage;
	    this.id = id$7++;
	    this.impl = graphicsDevice.createVertexBufferImpl(this, format);
	    this.instancing = false;
	    this.numBytes = format.verticesByteSize ? format.verticesByteSize : format.size * numVertices;
	    this.adjustVramSizeTracking(graphicsDevice._vram, this.numBytes);

	    if (initialData) {
	      this.setData(initialData);
	    } else {
	      this.storage = new ArrayBuffer(this.numBytes);
	    }

	    this.device.buffers.push(this);
	  }

	  var _proto = VertexBuffer.prototype;

	  _proto.destroy = function destroy() {
	    var device = this.device;
	    var idx = device.buffers.indexOf(this);

	    if (idx !== -1) {
	      device.buffers.splice(idx, 1);
	    }

	    if (this.impl.initialized) {
	      this.impl.destroy(device);
	      this.adjustVramSizeTracking(device._vram, -this.storage.byteLength);
	    }
	  };

	  _proto.adjustVramSizeTracking = function adjustVramSizeTracking(vram, size) {
	    vram.vb += size;
	  };

	  _proto.loseContext = function loseContext() {
	    this.impl.loseContext();
	  };

	  _proto.getFormat = function getFormat() {
	    return this.format;
	  };

	  _proto.getUsage = function getUsage() {
	    return this.usage;
	  };

	  _proto.getNumVertices = function getNumVertices() {
	    return this.numVertices;
	  };

	  _proto.lock = function lock() {
	    return this.storage;
	  };

	  _proto.unlock = function unlock() {
	    this.impl.unlock(this);
	  };

	  _proto.setData = function setData(data) {
	    if (data.byteLength !== this.numBytes) {
	      return false;
	    }

	    this.storage = data;
	    this.unlock();
	    return true;
	  };

	  return VertexBuffer;
	}();

	function hashCode(str) {
	  var hash = 0;

	  for (var i = 0, len = str.length; i < len; i++) {
	    hash = (hash << 5) - hash + str.charCodeAt(i);
	    hash |= 0;
	  }

	  return hash;
	}

	var VertexFormat = function () {
	  function VertexFormat(graphicsDevice, description, vertexCount) {
	    this._elements = [];
	    this.hasUv0 = false;
	    this.hasUv1 = false;
	    this.hasColor = false;
	    this.hasTangents = false;
	    this.verticesByteSize = 0;
	    this.vertexCount = vertexCount;
	    this.interleaved = vertexCount === undefined;
	    this.size = description.reduce(function (total, desc) {
	      return total + Math.ceil(desc.components * typedArrayTypesByteSize[desc.type] / 4) * 4;
	    }, 0);
	    var offset = 0,
	        elementSize;

	    for (var i = 0, len = description.length; i < len; i++) {
	      var elementDesc = description[i];
	      elementSize = elementDesc.components * typedArrayTypesByteSize[elementDesc.type];

	      if (vertexCount) {
	        offset = math.roundUp(offset, elementSize);
	      }

	      var element = {
	        name: elementDesc.semantic,
	        offset: vertexCount ? offset : elementDesc.hasOwnProperty('offset') ? elementDesc.offset : offset,
	        stride: vertexCount ? elementSize : elementDesc.hasOwnProperty('stride') ? elementDesc.stride : this.size,
	        dataType: elementDesc.type,
	        numComponents: elementDesc.components,
	        normalize: elementDesc.normalize === undefined ? false : elementDesc.normalize,
	        size: elementSize
	      };

	      this._elements.push(element);

	      if (vertexCount) {
	        offset += elementSize * vertexCount;
	      } else {
	        offset += Math.ceil(elementSize / 4) * 4;
	      }

	      if (elementDesc.semantic === SEMANTIC_TEXCOORD0) {
	        this.hasUv0 = true;
	      } else if (elementDesc.semantic === SEMANTIC_TEXCOORD1) {
	        this.hasUv1 = true;
	      } else if (elementDesc.semantic === SEMANTIC_COLOR) {
	        this.hasColor = true;
	      } else if (elementDesc.semantic === SEMANTIC_TANGENT) {
	        this.hasTangents = true;
	      }
	    }

	    if (vertexCount) {
	      this.verticesByteSize = offset;
	    }

	    this._evaluateHash();
	  }

	  var _proto = VertexFormat.prototype;

	  _proto._evaluateHash = function _evaluateHash() {
	    var stringElementBatch;
	    var stringElementsBatch = [];
	    var stringElementRender;
	    var stringElementsRender = [];
	    var len = this._elements.length;

	    for (var i = 0; i < len; i++) {
	      var element = this._elements[i];
	      stringElementBatch = element.name;
	      stringElementBatch += element.dataType;
	      stringElementBatch += element.numComponents;
	      stringElementBatch += element.normalize;
	      stringElementsBatch.push(stringElementBatch);
	      stringElementRender = stringElementBatch;
	      stringElementRender += element.offset;
	      stringElementRender += element.stride;
	      stringElementRender += element.size;
	      stringElementsRender.push(stringElementRender);
	    }

	    stringElementsBatch.sort();
	    this.batchingHash = hashCode(stringElementsBatch.join());
	    this.renderingingHashString = stringElementsRender.join('_');
	    this.renderingingHash = hashCode(this.renderingingHashString);
	  };

	  _createClass(VertexFormat, [{
	    key: "elements",
	    get: function get() {
	      return this._elements;
	    }
	  }], [{
	    key: "defaultInstancingFormat",
	    get: function get() {
	      if (!VertexFormat._defaultInstancingFormat) {
	        VertexFormat._defaultInstancingFormat = new VertexFormat(null, [{
	          semantic: SEMANTIC_ATTR12,
	          components: 4,
	          type: TYPE_FLOAT32
	        }, {
	          semantic: SEMANTIC_ATTR13,
	          components: 4,
	          type: TYPE_FLOAT32
	        }, {
	          semantic: SEMANTIC_ATTR14,
	          components: 4,
	          type: TYPE_FLOAT32
	        }, {
	          semantic: SEMANTIC_ATTR15,
	          components: 4,
	          type: TYPE_FLOAT32
	        }]);
	      }

	      return VertexFormat._defaultInstancingFormat;
	    }
	  }]);

	  return VertexFormat;
	}();

	VertexFormat._defaultInstancingFormat = null;

	var DeviceCache = function () {
	  function DeviceCache() {
	    this._cache = new Map();
	  }

	  var _proto = DeviceCache.prototype;

	  _proto.get = function get(device, onCreate) {
	    var _this = this;

	    if (!this._cache.has(device)) {
	      this._cache.set(device, onCreate());

	      device.on('destroy', function () {
	        _this.remove(device);
	      });
	    }

	    return this._cache.get(device);
	  };

	  _proto.remove = function remove(device) {
	    var _this$_cache$get;

	    (_this$_cache$get = this._cache.get(device)) == null ? void 0 : _this$_cache$get.destroy();

	    this._cache.delete(device);
	  };

	  return DeviceCache;
	}();

	var _postEffectQuadDraw = {
	  type: PRIMITIVE_TRISTRIP,
	  base: 0,
	  count: 4,
	  indexed: false
	};
	var postEffectDeviceCache = new DeviceCache();

	function getPostEffectQuadVB(device) {
	  return postEffectDeviceCache.get(device, function () {
	    var vertexFormat = new VertexFormat(device, [{
	      semantic: SEMANTIC_POSITION,
	      components: 2,
	      type: TYPE_FLOAT32
	    }]);
	    var positions = new Float32Array(8);
	    positions.set([-1, -1, 1, -1, -1, 1, 1, 1]);
	    return new VertexBuffer(device, vertexFormat, 4, BUFFER_STATIC, positions);
	  });
	}

	function drawQuadWithShader(device, target, shader, rect, scissorRect, useBlend) {
	  if (useBlend === void 0) {
	    useBlend = false;
	  }

	  var oldRt = device.renderTarget;
	  device.setRenderTarget(target);
	  device.updateBegin();
	  var x, y, w, h;
	  var sx, sy, sw, sh;

	  if (!rect) {
	    w = target ? target.width : device.width;
	    h = target ? target.height : device.height;
	    x = 0;
	    y = 0;
	  } else {
	    x = rect.x;
	    y = rect.y;
	    w = rect.z;
	    h = rect.w;
	  }

	  if (!scissorRect) {
	    sx = x;
	    sy = y;
	    sw = w;
	    sh = h;
	  } else {
	    sx = scissorRect.x;
	    sy = scissorRect.y;
	    sw = scissorRect.z;
	    sh = scissorRect.w;
	  }

	  var oldVx = device.vx;
	  var oldVy = device.vy;
	  var oldVw = device.vw;
	  var oldVh = device.vh;
	  device.setViewport(x, y, w, h);
	  var oldSx = device.sx;
	  var oldSy = device.sy;
	  var oldSw = device.sw;
	  var oldSh = device.sh;
	  device.setScissor(sx, sy, sw, sh);
	  var oldDepthTest = device.getDepthTest();
	  var oldDepthWrite = device.getDepthWrite();
	  var oldCullMode = device.getCullMode();
	  var oldWR = device.writeRed;
	  var oldWG = device.writeGreen;
	  var oldWB = device.writeBlue;
	  var oldWA = device.writeAlpha;
	  device.setDepthTest(false);
	  device.setDepthWrite(false);
	  device.setCullMode(CULLFACE_NONE);
	  device.setColorWrite(true, true, true, true);
	  if (!useBlend) device.setBlending(false);
	  device.setVertexBuffer(getPostEffectQuadVB(device), 0);
	  device.setShader(shader);
	  device.draw(_postEffectQuadDraw);
	  device.setDepthTest(oldDepthTest);
	  device.setDepthWrite(oldDepthWrite);
	  device.setCullMode(oldCullMode);
	  device.setColorWrite(oldWR, oldWG, oldWB, oldWA);
	  device.updateEnd();
	  device.setRenderTarget(oldRt);
	  device.updateBegin();
	  device.setViewport(oldVx, oldVy, oldVw, oldVh);
	  device.setScissor(oldSx, oldSy, oldSw, oldSh);
	}

	function drawTexture(device, texture, target, shader, rect, scissorRect, useBlend) {
	  if (useBlend === void 0) {
	    useBlend = false;
	  }

	  shader = shader || device.getCopyShader();
	  device.constantTexSource.setValue(texture);
	  drawQuadWithShader(device, target, shader, rect, scissorRect, useBlend);
	}

	var KEYWORD = /[ \t]*#(ifn?def|if|endif|else|elif|define|undef|extension)/g;
	var DEFINE = /define[ \t]+([^\n]+)\r?(?:\n|$)/g;
	var EXTENSION = /extension[ \t]+([\w-]+)[ \t]*:[ \t]*enable/g;
	var UNDEF = /undef[ \t]+([^\n]+)\r?(?:\n|$)/g;
	var IF = /(ifdef|ifndef|if)[ \t]*([^\r\n]+)\r?\n/g;
	var ENDIF = /(endif|else|elif)([ \t]+[^\r\n]+)?\r?(?:\n|$)/g;
	var IDENTIFIER$1 = /([\w-]+)/;
	var DEFINED = /(!|\s)?defined\(([\w-]+)\)/;
	var INVALID = /[><=|&+-]/g;

	var Preprocessor = function () {
	  function Preprocessor() {}

	  Preprocessor.run = function run(source) {
	    source = source.replace(/\/\*[\s\S]*?\*\/|([^\\:]|^)\/\/.*$/gm, '$1');
	    source = source.split(/\r?\n/).map(function (line) {
	      return line.trimEnd();
	    }).join('\n');
	    source = this._preprocess(source);

	    if (source !== null) {
	      source = source.split(/\r?\n/).map(function (line) {
	        return line.trim() === '' ? '' : line;
	      }).join('\n');
	      source = source.replace(/(\n\n){3,}/gm, '\n\n');
	    }

	    return source;
	  };

	  Preprocessor._preprocess = function _preprocess(source) {
	    var originalSource = source;
	    var stack = [];
	    var error = false;
	    var defines = new Map();
	    var match;

	    while ((match = KEYWORD.exec(source)) !== null) {
	      var keyword = match[1];

	      switch (keyword) {
	        case 'define':
	          {
	            DEFINE.lastIndex = match.index;
	            var define = DEFINE.exec(source);
	            error || (error = define === null);
	            var expression = define[1];
	            IDENTIFIER$1.lastIndex = define.index;
	            var identifierValue = IDENTIFIER$1.exec(expression);
	            var identifier = identifierValue[1];
	            var value = expression.substring(identifier.length).trim();
	            if (value === "") value = "true";

	            var keep = Preprocessor._keep(stack);

	            if (keep) {
	              defines.set(identifier, value);
	            }

	            KEYWORD.lastIndex = define.index + define[0].length;
	            break;
	          }

	        case 'undef':
	          {
	            UNDEF.lastIndex = match.index;
	            var undef = UNDEF.exec(source);

	            var _identifier = undef[1].trim();

	            var _keep2 = Preprocessor._keep(stack);

	            if (_keep2) {
	              defines.delete(_identifier);
	            }

	            KEYWORD.lastIndex = undef.index + undef[0].length;
	            break;
	          }

	        case 'extension':
	          {
	            EXTENSION.lastIndex = match.index;
	            var extension = EXTENSION.exec(source);
	            error || (error = extension === null);

	            if (extension) {
	              var _identifier2 = extension[1];

	              var _keep3 = Preprocessor._keep(stack);

	              if (_keep3) {
	                defines.set(_identifier2, "true");
	              }
	            }

	            KEYWORD.lastIndex = extension.index + extension[0].length;
	            break;
	          }

	        case 'ifdef':
	        case 'ifndef':
	        case 'if':
	          {
	            IF.lastIndex = match.index;
	            var iff = IF.exec(source);
	            var _expression = iff[2];
	            var evaluated = Preprocessor.evaluate(_expression, defines);
	            error || (error = evaluated.error);
	            var result = evaluated.result;

	            if (keyword === 'ifndef') {
	              result = !result;
	            }

	            stack.push({
	              anyKeep: result,
	              keep: result,
	              start: match.index,
	              end: IF.lastIndex
	            });
	            KEYWORD.lastIndex = iff.index + iff[0].length;
	            break;
	          }

	        case 'endif':
	        case 'else':
	        case 'elif':
	          {
	            ENDIF.lastIndex = match.index;
	            var endif = ENDIF.exec(source);
	            var blockInfo = stack.pop();
	            var blockCode = blockInfo.keep ? source.substring(blockInfo.end, match.index) : "";
	            source = source.substring(0, blockInfo.start) + blockCode + source.substring(ENDIF.lastIndex);
	            KEYWORD.lastIndex = blockInfo.start + blockCode.length;
	            var endifCommand = endif[1];

	            if (endifCommand === 'else' || endifCommand === 'elif') {
	              var _result = false;

	              if (!blockInfo.anyKeep) {
	                if (endifCommand === 'else') {
	                  _result = !blockInfo.keep;
	                } else {
	                  var _evaluated = Preprocessor.evaluate(endif[2], defines);

	                  _result = _evaluated.result;
	                  error || (error = _evaluated.error);
	                }
	              }

	              stack.push({
	                anyKeep: blockInfo.anyKeep || _result,
	                keep: _result,
	                start: KEYWORD.lastIndex,
	                end: KEYWORD.lastIndex
	              });
	            }

	            break;
	          }
	      }
	    }

	    if (error) {
	      console.warn("Failed to preprocess shader: ", {
	        source: originalSource
	      });
	      return originalSource;
	    }

	    return source;
	  };

	  Preprocessor._keep = function _keep(stack) {
	    for (var i = 0; i < stack.length; i++) {
	      if (!stack[i].keep) return false;
	    }

	    return true;
	  };

	  Preprocessor.evaluate = function evaluate(expression, defines) {
	    var correct = INVALID.exec(expression) === null;
	    var invert = false;
	    var defined = DEFINED.exec(expression);

	    if (defined) {
	      invert = defined[1] === '!';
	      expression = defined[2];
	    }

	    expression = expression.trim();
	    var exists = defines.has(expression);

	    if (invert) {
	      exists = !exists;
	    }

	    return {
	      result: exists,
	      error: !correct
	    };
	  };

	  return Preprocessor;
	}();

	var id$6 = 0;

	var Shader = function () {
	  function Shader(graphicsDevice, definition) {
	    this.meshUniformBufferFormat = void 0;
	    this.meshBindGroupFormat = void 0;
	    this.id = id$6++;
	    this.device = graphicsDevice;
	    this.definition = definition;
	    this.name = definition.name || 'Untitled';
	    definition.vshader = Preprocessor.run(definition.vshader);
	    definition.fshader = Preprocessor.run(definition.fshader);
	    this.init();
	    this.impl = graphicsDevice.createShaderImpl(this);
	  }

	  var _proto = Shader.prototype;

	  _proto.init = function init() {
	    this.ready = false;
	    this.failed = false;
	  };

	  _proto.destroy = function destroy() {
	    this.impl.destroy(this);
	  };

	  _proto.loseContext = function loseContext() {
	    this.init();
	  };

	  _proto.restoreContext = function restoreContext() {
	    this.impl.restoreContext(this.device, this);
	  };

	  return Shader;
	}();

	var alphaTestPS = "\nuniform float alpha_ref;\n\nvoid alphaTest(float a) {\n    if (a < alpha_ref) discard;\n}\n";

	var ambientConstantPS = "\nvoid addAmbient() {\n    dDiffuseLight += light_globalAmbient;\n}\n";

	var ambientEnvPS = "\n#ifndef ENV_ATLAS\n#define ENV_ATLAS\nuniform sampler2D texture_envAtlas;\n#endif\n\nvoid addAmbient() {\n    vec3 dir = normalize(cubeMapRotate(dNormalW) * vec3(-1.0, 1.0, 1.0));\n    vec2 uv = mapUv(toSphericalUv(dir), vec4(128.0, 256.0 + 128.0, 64.0, 32.0) / atlasSize);\n\n    vec4 raw = texture2D(texture_envAtlas, uv);\n    vec3 linear = $DECODE(raw);\n    dDiffuseLight += processEnvironment(linear);\n}\n";

	var ambientSHPS = "\nuniform vec3 ambientSH[9];\n\nvoid addAmbient() {\n    vec3 n = cubeMapRotate(dNormalW);\n\n    vec3 color =\n        ambientSH[0] +\n        ambientSH[1] * n.x +\n        ambientSH[2] * n.y +\n        ambientSH[3] * n.z +\n        ambientSH[4] * n.x * n.z +\n        ambientSH[5] * n.z * n.y +\n        ambientSH[6] * n.y * n.x +\n        ambientSH[7] * (3.0 * n.z * n.z - 1.0) +\n        ambientSH[8] * (n.x * n.x - n.y * n.y);\n\n    dDiffuseLight += processEnvironment(max(color, vec3(0.0)));\n}\n";

	var aoPS = "\n#ifdef MAPTEXTURE\nuniform sampler2D texture_aoMap;\n#endif\n\nvoid getAO() {\n    dAo = 1.0;\n\n    #ifdef MAPTEXTURE\n    dAo *= texture2DBias(texture_aoMap, $UV, textureBias).$CH;\n    #endif\n\n    #ifdef MAPVERTEX\n    dAo *= saturate(vVertexColor.$VC);\n    #endif\n}\n";

	var aoDiffuseOccPS = "\nvoid occludeDiffuse() {\n    dDiffuseLight *= dAo;\n}\n";

	var aoSpecOccPS = "\nuniform float material_occludeSpecularIntensity;\n\nvoid occludeSpecular() {\n    // approximated specular occlusion from AO\n    float specPow = exp2(dGlossiness * 11.0);\n    // http://research.tri-ace.com/Data/cedec2011_RealtimePBR_Implementation_e.pptx\n    float specOcc = saturate(pow(dot(dNormalW, dViewDirW) + dAo, 0.01*specPow) - 1.0 + dAo);\n    specOcc = mix(1.0, specOcc, material_occludeSpecularIntensity);\n\n    dSpecularLight *= specOcc;\n    dReflection *= specOcc;\n}\n";

	var aoSpecOccConstPS = "\nvoid occludeSpecular() {\n    // approximated specular occlusion from AO\n    float specPow = exp2(dGlossiness * 11.0);\n    // http://research.tri-ace.com/Data/cedec2011_RealtimePBR_Implementation_e.pptx\n    float specOcc = saturate(pow(dot(dNormalW, dViewDirW) + dAo, 0.01*specPow) - 1.0 + dAo);\n\n    dSpecularLight *= specOcc;\n    dReflection *= specOcc;\n}\n";

	var aoSpecOccConstSimplePS = "\nvoid occludeSpecular() {\n    dSpecularLight *= dAo;\n    dReflection *= dAo;\n}\n";

	var aoSpecOccSimplePS = "\nuniform float material_occludeSpecularIntensity;\n\nvoid occludeSpecular() {\n    float specOcc = mix(1.0, dAo, material_occludeSpecularIntensity);\n    dSpecularLight *= specOcc;\n    dReflection *= specOcc;\n}\n";

	var basePS = "\nuniform vec3 view_position;\n\nuniform vec3 light_globalAmbient;\n\nfloat square(float x) {\n    return x*x;\n}\n\nfloat saturate(float x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nvec3 saturate(vec3 x) {\n    return clamp(x, vec3(0.0), vec3(1.0));\n}\n";

	var baseVS = "\nattribute vec3 vertex_position;\nattribute vec3 vertex_normal;\nattribute vec4 vertex_tangent;\nattribute vec2 vertex_texCoord0;\nattribute vec2 vertex_texCoord1;\nattribute vec4 vertex_color;\n\nuniform mat4 matrix_viewProjection;\nuniform mat4 matrix_model;\nuniform mat3 matrix_normal;\n\nvec3 dPositionW;\nmat4 dModelMatrix;\nmat3 dNormalMatrix;\n";

	var baseNineSlicedPS = "\n#define NINESLICED\n\nvarying vec2 vMask;\nvarying vec2 vTiledUv;\n\nuniform mediump vec4 innerOffset;\nuniform mediump vec2 outerScale;\nuniform mediump vec4 atlasRect;\n\nvec2 nineSlicedUv;\n";

	var baseNineSlicedVS = "\n#define NINESLICED\n\nvarying vec2 vMask;\nvarying vec2 vTiledUv;\n\nuniform mediump vec4 innerOffset;\nuniform mediump vec2 outerScale;\nuniform mediump vec4 atlasRect;\n";

	var baseNineSlicedTiledPS = "\n#define NINESLICED\n#define NINESLICETILED\n\nvarying vec2 vMask;\nvarying vec2 vTiledUv;\n\nuniform mediump vec4 innerOffset;\nuniform mediump vec2 outerScale;\nuniform mediump vec4 atlasRect;\n\nvec2 nineSlicedUv;\n";

	var biasConstPS = "\n#define SHADOWBIAS\n\nfloat getShadowBias(float resolution, float maxBias) {\n    return maxBias;\n}\n";

	var blurVSMPS = "\nvarying vec2 vUv0;\n\nuniform sampler2D source;\nuniform vec2 pixelOffset;\n\n#ifdef GAUSS\nuniform float weight[SAMPLES];\n#endif\n\n#ifdef PACKED\nfloat decodeFloatRG(vec2 rg) {\n    return rg.y*(1.0/255.0) + rg.x;\n}\n\nvec2 encodeFloatRG( float v ) {\n    vec2 enc = vec2(1.0, 255.0) * v;\n    enc = fract(enc);\n    enc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\n    return enc;\n}\n#endif\n\nvoid main(void) {\n    vec3 moments = vec3(0.0);\n    vec2 uv = vUv0 - pixelOffset * (float(SAMPLES) * 0.5);\n    for (int i=0; i<SAMPLES; i++) {\n        vec4 c = texture2D(source, uv + pixelOffset * float(i));\n\n        #ifdef PACKED\n        c.xy = vec2(decodeFloatRG(c.xy), decodeFloatRG(c.zw));\n        #endif\n\n        #ifdef GAUSS\n        moments += c.xyz * weight[i];\n        #else\n        moments += c.xyz;\n        #endif\n    }\n\n    #ifndef GAUSS\n    moments /= float(SAMPLES);\n    #endif\n\n    #ifdef PACKED\n    gl_FragColor = vec4(encodeFloatRG(moments.x), encodeFloatRG(moments.y));\n    #else\n    gl_FragColor = vec4(moments.x, moments.y, moments.z, 1.0);\n    #endif\n}\n";

	var clearCoatPS = "\n#ifdef MAPFLOAT\nuniform float material_clearCoat;\n#endif\n\n#ifdef MAPTEXTURE\nuniform sampler2D texture_clearCoatMap;\n#endif\n\nvoid getClearCoat() {\n    ccSpecularity = 1.0;\n\n    #ifdef MAPFLOAT\n    ccSpecularity *= material_clearCoat;\n    #endif\n\n    #ifdef MAPTEXTURE\n    ccSpecularity *= texture2DBias(texture_clearCoatMap, $UV, textureBias).$CH;\n    #endif\n\n    #ifdef MAPVERTEX\n    ccSpecularity *= saturate(vVertexColor.$VC);\n    #endif\n}\n";

	var clearCoatGlossPS = "\n#ifdef MAPFLOAT\nuniform float material_clearCoatGlossiness;\n#endif\n\n#ifdef MAPTEXTURE\nuniform sampler2D texture_clearCoatGlossMap;\n#endif\n\nvoid getClearCoatGlossiness() {\n    ccGlossiness = 1.0;\n\n    #ifdef MAPFLOAT\n    ccGlossiness *= material_clearCoatGlossiness;\n    #endif\n\n    #ifdef MAPTEXTURE\n    ccGlossiness *= texture2DBias(texture_clearCoatGlossMap, $UV, textureBias).$CH;\n    #endif\n\n    #ifdef MAPVERTEX\n    ccGlossiness *= saturate(vVertexColor.$VC);\n    #endif\n\n    ccGlossiness += 0.0000001;\n}\n";

	var clearCoatNormalPS = "\n#ifdef MAPTEXTURE\nuniform sampler2D texture_clearCoatNormalMap;\nuniform float material_clearCoatBumpiness;\n#endif\n\nvoid getClearCoatNormal() {\n#ifdef MAPTEXTURE\n    vec3 normalMap = unpackNormal(texture2DBias(texture_clearCoatNormalMap, $UV, textureBias));\n    normalMap = mix(vec3(0.0, 0.0, 1.0), normalMap, material_clearCoatBumpiness);\n    ccNormalW = normalize(dTBN * normalMap);\n#else\n    ccNormalW = dVertexNormalW;\n#endif\n}\n";

	var clusteredLightUtilsPS = "\n// Converts unnormalized direction vector to a cubemap face index [0..5] and uv coordinates within the face in [0..1] range.\n// Additionally offset to a tile in atlas within 3x3 subdivision is provided\nvec2 getCubemapFaceCoordinates(const vec3 dir, out float faceIndex, out vec2 tileOffset)\n{\n    vec3 vAbs = abs(dir);\n    float ma;\n    vec2 uv;\n    if (vAbs.z >= vAbs.x && vAbs.z >= vAbs.y) {   // front / back\n\n        faceIndex = dir.z < 0.0 ? 5.0 : 4.0;\n        ma = 0.5 / vAbs.z;\n        uv = vec2(dir.z < 0.0 ? -dir.x : dir.x, -dir.y);\n\n        tileOffset.x = 2.0;\n        tileOffset.y = dir.z < 0.0 ? 1.0 : 0.0;\n\n    } else if(vAbs.y >= vAbs.x) {  // top index 2, bottom index 3\n\n        faceIndex = dir.y < 0.0 ? 3.0 : 2.0;\n        ma = 0.5 / vAbs.y;\n        uv = vec2(dir.x, dir.y < 0.0 ? -dir.z : dir.z);\n\n        tileOffset.x = 1.0;\n        tileOffset.y = dir.y < 0.0 ? 1.0 : 0.0;\n\n    } else {    // left / right\n\n        faceIndex = dir.x < 0.0 ? 1.0 : 0.0;\n        ma = 0.5 / vAbs.x;\n        uv = vec2(dir.x < 0.0 ? dir.z : -dir.z, -dir.y);\n\n        tileOffset.x = 0.0;\n        tileOffset.y = dir.x < 0.0 ? 1.0 : 0.0;\n\n    }\n    return uv * ma + 0.5;\n}\n\n// converts unnormalized direction vector to a texture coordinate for a cubemap face stored within texture atlas described by the viewport\nvec2 getCubemapAtlasCoordinates(const vec3 omniAtlasViewport, float shadowEdgePixels, float shadowTextureResolution, const vec3 dir) {\n\n    float faceIndex;\n    vec2 tileOffset;\n    vec2 uv = getCubemapFaceCoordinates(dir, faceIndex, tileOffset);\n\n    // move uv coordinates inwards inside to compensate for larger fov when rendering shadow into atlas\n    float atlasFaceSize = omniAtlasViewport.z;\n    float tileSize = shadowTextureResolution * atlasFaceSize;\n    float offset = shadowEdgePixels / tileSize;\n    uv = uv * vec2(1.0 - offset * 2.0) + vec2(offset * 1.0);\n\n    // scale uv coordinates to cube face area within the viewport\n    uv *= atlasFaceSize;\n\n    // offset into face of the atlas (3x3 grid)\n    uv += tileOffset * atlasFaceSize;\n\n    // offset into the atlas viewport\n    uv += omniAtlasViewport.xy;\n\n    return uv;\n}\n";

	var clusteredLightCookiesPS = "\nvec3 _getCookieClustered(sampler2D tex, vec2 uv, float intensity, bool isRgb, vec4 cookieChannel) {\n    vec4 pixel = mix(vec4(1.0), texture2D(tex, uv), intensity);\n    return isRgb == true ? pixel.rgb : vec3(dot(pixel, cookieChannel));\n}\n\n// getCookie2D for clustered lighting including channel selector\nvec3 getCookie2DClustered(sampler2D tex, mat4 transform, vec3 worldPosition, float intensity, bool isRgb, vec4 cookieChannel) {\n    vec4 projPos = transform * vec4(worldPosition, 1.0);\n    return _getCookieClustered(tex, projPos.xy / projPos.w, intensity, isRgb, cookieChannel);\n}\n\n// getCookie for clustered omni light with the cookie texture being stored in the cookie atlas\nvec3 getCookieCubeClustered(sampler2D tex, vec3 dir, float intensity, bool isRgb, vec4 cookieChannel, float shadowTextureResolution, float shadowEdgePixels, vec3 omniAtlasViewport) {\n    vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);\n    return _getCookieClustered(tex, uv, intensity, isRgb, cookieChannel);\n}\n";

	var clusteredLightShadowsPS = "\n// Clustered Omni Sampling using atlas\n\n#ifdef GL2\n\n    #if defined(CLUSTER_SHADOW_TYPE_PCF1)\n\n    float getShadowOmniClusteredPCF1(sampler2DShadow shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 dir) {\n\n        float shadowTextureResolution = shadowParams.x;\n        vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);\n\n        float shadowZ = length(dir) * shadowParams.w + shadowParams.z;\n        return texture(shadowMap, vec3(uv, shadowZ));\n    }\n\n    #endif\n\n    #if defined(CLUSTER_SHADOW_TYPE_PCF3)\n\n    float getShadowOmniClusteredPCF3(sampler2DShadow shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 dir) {\n\n        float shadowTextureResolution = shadowParams.x;\n        vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);\n\n        float shadowZ = length(dir) * shadowParams.w + shadowParams.z;\n        dShadowCoord = vec3(uv, shadowZ);\n        return getShadowPCF3x3(shadowMap, shadowParams.xyz);\n    }\n\n    #endif\n\n    #if defined(CLUSTER_SHADOW_TYPE_PCF5)\n\n    float getShadowOmniClusteredPCF5(sampler2DShadow shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 dir) {\n\n        float shadowTextureResolution = shadowParams.x;\n        vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);\n\n        float shadowZ = length(dir) * shadowParams.w + shadowParams.z;\n        dShadowCoord = vec3(uv, shadowZ);\n        return getShadowPCF5x5(shadowMap, shadowParams.xyz);\n    }\n\n    #endif\n\n#else\n\n    #if defined(CLUSTER_SHADOW_TYPE_PCF1)\n\n    float getShadowOmniClusteredPCF1(sampler2D shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 dir) {\n\n        float shadowTextureResolution = shadowParams.x;\n        vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);\n\n        // no filter shadow sampling\n        float depth = unpackFloat(texture2D(shadowMap, uv));\n        float shadowZ = length(dir) * shadowParams.w + shadowParams.z;\n        return depth > shadowZ ? 1.0 : 0.0;\n    }\n\n    #endif\n\n    #if defined(CLUSTER_SHADOW_TYPE_PCF3)\n\n    float getShadowOmniClusteredPCF3(sampler2D shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 dir) {\n\n        float shadowTextureResolution = shadowParams.x;\n        vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);\n\n        // pcf3\n        float shadowZ = length(dir) * shadowParams.w + shadowParams.z;\n        dShadowCoord = vec3(uv, shadowZ);\n        return getShadowPCF3x3(shadowMap, shadowParams.xyz);\n    }\n\n    #endif\n\n    #if defined(CLUSTER_SHADOW_TYPE_PCF5)\n\n    // we don't have PCF5 implementation for webgl1, use PCF3\n    float getShadowOmniClusteredPCF5(sampler2D shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 dir) {\n\n        float shadowTextureResolution = shadowParams.x;\n        vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);\n\n        // pcf3\n        float shadowZ = length(dir) * shadowParams.w + shadowParams.z;\n        dShadowCoord = vec3(uv, shadowZ);\n        return getShadowPCF3x3(shadowMap, shadowParams.xyz);\n    }\n\n    #endif\n\n#endif\n\n\n// Clustered Spot Sampling using atlas\n\n#ifdef GL2\n\n    #if defined(CLUSTER_SHADOW_TYPE_PCF1)\n\n    float getShadowSpotClusteredPCF1(sampler2DShadow shadowMap, vec4 shadowParams) {\n        return texture(shadowMap, dShadowCoord);\n    }\n\n    #endif\n\n    #if defined(CLUSTER_SHADOW_TYPE_PCF3)\n\n    float getShadowSpotClusteredPCF3(sampler2DShadow shadowMap, vec4 shadowParams) {\n        return getShadowSpotPCF3x3(shadowMap, shadowParams);\n    }\n\n    #endif\n\n    #if defined(CLUSTER_SHADOW_TYPE_PCF5)\n\n    float getShadowSpotClusteredPCF5(sampler2DShadow shadowMap, vec4 shadowParams) {\n        return getShadowPCF5x5(shadowMap, shadowParams.xyz);\n    }\n    #endif\n\n#else\n\n    #if defined(CLUSTER_SHADOW_TYPE_PCF1)\n\n    float getShadowSpotClusteredPCF1(sampler2D shadowMap, vec4 shadowParams) {\n\n        float depth = unpackFloat(texture2D(shadowMap, dShadowCoord.xy));\n\n        return depth > dShadowCoord.z ? 1.0 : 0.0;\n\n    }\n\n    #endif\n\n    #if defined(CLUSTER_SHADOW_TYPE_PCF3)\n\n    float getShadowSpotClusteredPCF3(sampler2D shadowMap, vec4 shadowParams) {\n        return getShadowSpotPCF3x3(shadowMap, shadowParams);\n    }\n\n    #endif\n\n    #if defined(CLUSTER_SHADOW_TYPE_PCF5)\n\n    // we don't have PCF5 implementation for webgl1, use PCF3\n    float getShadowSpotClusteredPCF5(sampler2D shadowMap, vec4 shadowParams) {\n        return getShadowSpotPCF3x3(shadowMap, shadowParams);\n    }\n\n    #endif\n\n#endif\n";

	var clusteredLightPS = "\nuniform sampler2D clusterWorldTexture;\nuniform sampler2D lightsTexture8;\nuniform highp sampler2D lightsTextureFloat;\n\n// complex ifdef expression are not supported, handle it here\n// defined(CLUSTER_COOKIES) || defined(CLUSTER_SHADOWS)\n#if defined(CLUSTER_COOKIES)\n    #define CLUSTER_COOKIES_OR_SHADOWS\n#endif\n#if defined(CLUSTER_SHADOWS)\n    #define CLUSTER_COOKIES_OR_SHADOWS\n#endif\n\n#ifdef CLUSTER_SHADOWS\n    #ifdef GL2\n        // TODO: when VSM shadow is supported, it needs to use sampler2D in webgl2\n        uniform sampler2DShadow shadowAtlasTexture;\n    #else\n        uniform sampler2D shadowAtlasTexture;\n    #endif\n#endif\n\n#ifdef CLUSTER_COOKIES\n    uniform sampler2D cookieAtlasTexture;\n#endif\n\nuniform float clusterPixelsPerCell;\nuniform vec3 clusterCellsCountByBoundsSize;\nuniform vec4 lightsTextureInvSize;\nuniform vec3 clusterTextureSize;\nuniform vec3 clusterBoundsMin;\nuniform vec3 clusterBoundsDelta;\nuniform vec3 clusterCellsDot;\nuniform vec3 clusterCellsMax;\nuniform vec2 clusterCompressionLimit0;\nuniform vec2 shadowAtlasParams;\n\n// structure storing light properties of a clustered light\nstruct ClusterLightData {\n\n    // v coordinate to look up the light textures\n    float lightV;\n\n    // type of the light (spot or omni)\n    float type;\n\n    // area light shape\n    float shape;\n\n    // area light sizes / orientation\n    vec3 halfWidth;\n    vec3 halfHeight;\n\n    // light follow mode\n    float falloffMode;\n\n    // 0.0 if the light doesn't cast shadows\n    float shadowIntensity;\n\n    // shadow bias values\n    float shadowBias;\n    float shadowNormalBias;\n\n    // world space position\n    vec3 position;\n\n    // world space direction (spot light only)\n    vec3 direction;\n\n    // range of the light\n    float range;\n\n    // spot light inner and outer angle cosine\n    float innerConeAngleCos;\n    float outerConeAngleCos;\n\n    // color\n    vec3 color;\n\n    // atlas viewport for omni light shadow and cookie (.xy is offset to the viewport slot, .z is size of the face in the atlas)\n    vec3 omniAtlasViewport;\n\n    // 1.0 if the light has a cookie texture\n    float cookie;\n\n    // 1.0 if cookie texture is rgb, otherwise it is using a single channel selectable by cookieChannelMask\n    float cookieRgb;\n\n    // intensity of the cookie\n    float cookieIntensity;\n\n    // channel mask - one of the channels has 1, the others are 0\n    vec4 cookieChannelMask;\n\n    // light mask\n    float mask;\n};\n\n// Note: on some devices (tested on Pixel 3A XL), this matrix when stored inside the light struct has lower precision compared to\n// when stored outside, so we store it outside to avoid spot shadow flickering. This might need to be done to other / all members\n// of the structure if further similar issues are observed.\n\n// shadow (spot light only) / cookie projection matrix\nmat4 lightProjectionMatrix;\n\n// macros for light properties\n#define isClusteredLightCastShadow(light) ( light.shadowIntensity > 0.0 )\n#define isClusteredLightCookie(light) (light.cookie > 0.5 )\n#define isClusteredLightCookieRgb(light) (light.cookieRgb > 0.5 )\n#define isClusteredLightSpot(light) ( light.type > 0.5 )\n#define isClusteredLightFalloffLinear(light) ( light.falloffMode < 0.5 )\n\n// macros to test light shape\n// Note: Following functions need to be called serially in listed order as they do not test both '>' and '<'\n#define isClusteredLightArea(light) ( light.shape > 0.1 )\n#define isClusteredLightRect(light) ( light.shape < 0.3 )\n#define isClusteredLightDisk(light) ( light.shape < 0.6 )\n\n// macro to test light mask (mesh accepts dynamic vs lightmapped lights)\n#ifdef CLUSTER_MESH_DYNAMIC_LIGHTS\n    // accept lights marked as dynamic or both dynamic and lightmapped\n    #define acceptLightMask(light) ( light.mask < 0.75)\n#else\n    // accept lights marked as lightmapped or both dynamic and lightmapped\n    #define acceptLightMask(light) ( light.mask > 0.25)\n#endif\n\nvec4 decodeClusterLowRange4Vec4(vec4 d0, vec4 d1, vec4 d2, vec4 d3) {\n    return vec4(\n        bytes2floatRange4(d0, -2.0, 2.0),\n        bytes2floatRange4(d1, -2.0, 2.0),\n        bytes2floatRange4(d2, -2.0, 2.0),\n        bytes2floatRange4(d3, -2.0, 2.0)\n    );\n}\n\n// use LOD sampling if supported to sample data textures as it has better chance of getting skipped inside dynamic branches\n#ifdef SUPPORTS_TEXLOD\n    #define textureData(texture, uv) texture2DLodEXT(texture, uv, 0.0)\n#else\n    #define textureData(texture, uv) texture2D(texture, uv)\n#endif\n\nvec4 sampleLightsTexture8(const ClusterLightData clusterLightData, float index) {\n    return textureData(lightsTexture8, vec2(index * lightsTextureInvSize.z, clusterLightData.lightV));\n}\n\nvec4 sampleLightTextureF(const ClusterLightData clusterLightData, float index) {\n    return textureData(lightsTextureFloat, vec2(index * lightsTextureInvSize.x, clusterLightData.lightV));\n}\n\nvoid decodeClusterLightCore(inout ClusterLightData clusterLightData, float lightIndex) {\n\n    // read omni light properties\n    clusterLightData.lightV = (lightIndex + 0.5) * lightsTextureInvSize.w;\n\n    // shared data from 8bit texture\n    vec4 lightInfo = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_FLAGS);\n    clusterLightData.type = lightInfo.x;\n    clusterLightData.shape = lightInfo.y;\n    clusterLightData.falloffMode = lightInfo.z;\n    clusterLightData.shadowIntensity = lightInfo.w;\n\n    // color\n    vec4 colorA = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COLOR_A);\n    vec4 colorB = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COLOR_B);\n    clusterLightData.color = vec3(bytes2float2(colorA.xy), bytes2float2(colorA.zw), bytes2float2(colorB.xy)) * clusterCompressionLimit0.y;\n\n    // cookie\n    clusterLightData.cookie = colorB.z;\n\n    // light mask\n    clusterLightData.mask = colorB.w;\n\n    #ifdef CLUSTER_TEXTURE_FLOAT\n\n        vec4 lightPosRange = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_POSITION_RANGE);\n        clusterLightData.position = lightPosRange.xyz;\n        clusterLightData.range = lightPosRange.w;\n\n        // spot light direction\n        vec4 lightDir_Unused = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_SPOT_DIRECTION);\n        clusterLightData.direction = lightDir_Unused.xyz;\n\n    #else   // 8bit\n\n        vec4 encPosX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_POSITION_X);\n        vec4 encPosY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_POSITION_Y);\n        vec4 encPosZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_POSITION_Z);\n        clusterLightData.position = vec3(bytes2float4(encPosX), bytes2float4(encPosY), bytes2float4(encPosZ)) * clusterBoundsDelta + clusterBoundsMin;\n\n        vec4 encRange = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_RANGE);\n        clusterLightData.range = bytes2float4(encRange) * clusterCompressionLimit0.x;\n\n        // spot light direction\n        vec4 encDirX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_DIRECTION_X);\n        vec4 encDirY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_DIRECTION_Y);\n        vec4 encDirZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_DIRECTION_Z);\n        clusterLightData.direction = vec3(bytes2float4(encDirX), bytes2float4(encDirY), bytes2float4(encDirZ)) * 2.0 - 1.0;\n\n    #endif\n}\n\nvoid decodeClusterLightSpot(inout ClusterLightData clusterLightData) {\n\n    // spot light cos angles\n    vec4 coneAngle = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_ANGLES);\n    clusterLightData.innerConeAngleCos = bytes2float2(coneAngle.xy) * 2.0 - 1.0;\n    clusterLightData.outerConeAngleCos = bytes2float2(coneAngle.zw) * 2.0 - 1.0;\n}\n\nvoid decodeClusterLightOmniAtlasViewport(inout ClusterLightData clusterLightData) {\n    #ifdef CLUSTER_TEXTURE_FLOAT\n        clusterLightData.omniAtlasViewport = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_0).xyz;\n    #else\n        vec4 viewportA = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_ATLAS_VIEWPORT_A);\n        vec4 viewportB = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_ATLAS_VIEWPORT_B);\n        clusterLightData.omniAtlasViewport = vec3(bytes2float2(viewportA.xy), bytes2float2(viewportA.zw), bytes2float2(viewportB.xy));\n    #endif\n}\n\nvoid decodeClusterLightAreaData(inout ClusterLightData clusterLightData) {\n    #ifdef CLUSTER_TEXTURE_FLOAT\n        clusterLightData.halfWidth = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_AREA_DATA_WIDTH).xyz;\n        clusterLightData.halfHeight = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_AREA_DATA_HEIGHT).xyz;\n    #else\n        vec4 areaWidthX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_WIDTH_X);\n        vec4 areaWidthY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_WIDTH_Y);\n        vec4 areaWidthZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_WIDTH_Z);\n        clusterLightData.halfWidth = vec3(mantissaExponent2Float(areaWidthX), mantissaExponent2Float(areaWidthY), mantissaExponent2Float(areaWidthZ));\n\n        vec4 areaHeightX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_HEIGHT_X);\n        vec4 areaHeightY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_HEIGHT_Y);\n        vec4 areaHeightZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_HEIGHT_Z);\n        clusterLightData.halfHeight = vec3(mantissaExponent2Float(areaHeightX), mantissaExponent2Float(areaHeightY), mantissaExponent2Float(areaHeightZ));\n    #endif\n}\n\nvoid decodeClusterLightProjectionMatrixData(inout ClusterLightData clusterLightData) {\n    \n    // shadow matrix\n    #ifdef CLUSTER_TEXTURE_FLOAT\n        vec4 m0 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_0);\n        vec4 m1 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_1);\n        vec4 m2 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_2);\n        vec4 m3 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_3);\n    #else\n        vec4 m00 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_00);\n        vec4 m01 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_01);\n        vec4 m02 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_02);\n        vec4 m03 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_03);\n        vec4 m0 = decodeClusterLowRange4Vec4(m00, m01, m02, m03);\n\n        vec4 m10 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_10);\n        vec4 m11 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_11);\n        vec4 m12 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_12);\n        vec4 m13 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_13);\n        vec4 m1 = decodeClusterLowRange4Vec4(m10, m11, m12, m13);\n\n        vec4 m20 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_20);\n        vec4 m21 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_21);\n        vec4 m22 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_22);\n        vec4 m23 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_23);\n        vec4 m2 = decodeClusterLowRange4Vec4(m20, m21, m22, m23);\n\n        vec4 m30 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_30);\n        vec4 m31 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_31);\n        vec4 m32 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_32);\n        vec4 m33 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_33);\n        vec4 m3 = vec4(mantissaExponent2Float(m30), mantissaExponent2Float(m31), mantissaExponent2Float(m32), mantissaExponent2Float(m33));\n    #endif\n    \n    lightProjectionMatrix = mat4(m0, m1, m2, m3);\n}\n\nvoid decodeClusterLightShadowData(inout ClusterLightData clusterLightData) {\n    \n    // shadow biases\n    vec4 biases = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SHADOW_BIAS);\n    clusterLightData.shadowBias = bytes2floatRange2(biases.xy, -1.0, 20.0),\n    clusterLightData.shadowNormalBias = bytes2float2(biases.zw);\n}\n\nvoid decodeClusterLightCookieData(inout ClusterLightData clusterLightData) {\n\n    vec4 cookieA = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COOKIE_A);\n    clusterLightData.cookieIntensity = cookieA.x;\n    clusterLightData.cookieRgb = cookieA.y;\n\n    clusterLightData.cookieChannelMask = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COOKIE_B);\n}\n\nvoid evaluateLight(ClusterLightData light) {\n\n    dAtten3 = vec3(1.0);\n\n    // evaluate omni part of the light\n    getLightDirPoint(light.position);\n\n    #ifdef CLUSTER_AREALIGHTS\n\n    // distance attenuation\n    if (isClusteredLightArea(light)) { // area light\n\n        // area lights\n        decodeClusterLightAreaData(light);\n\n        // handle light shape\n        if (isClusteredLightRect(light)) {\n            calcRectLightValues(light.position, light.halfWidth, light.halfHeight);\n        } else if (isClusteredLightDisk(light)) {\n            calcDiskLightValues(light.position, light.halfWidth, light.halfHeight);\n        } else { // sphere\n            calcSphereLightValues(light.position, light.halfWidth, light.halfHeight);\n        }\n\n        dAtten = getFalloffWindow(light.range);\n\n    } else\n\n    #endif\n\n    {   // punctual light\n\n        if (isClusteredLightFalloffLinear(light))\n            dAtten = getFalloffLinear(light.range);\n        else\n            dAtten = getFalloffInvSquared(light.range);\n    }\n\n    if (dAtten > 0.00001) {\n\n        #ifdef CLUSTER_AREALIGHTS\n\n        if (isClusteredLightArea(light)) { // area light\n\n            // handle light shape\n            if (isClusteredLightRect(light)) {\n                dAttenD = getRectLightDiffuse() * 16.0;\n            } else if (isClusteredLightDisk(light)) {\n                dAttenD = getDiskLightDiffuse() * 16.0;\n            } else { // sphere\n                dAttenD = getSphereLightDiffuse() * 16.0;\n            }\n\n        } else\n\n        #endif\n\n        {\n            dAtten *= getLightDiffuse();\n        }\n\n        // spot light falloff\n        if (isClusteredLightSpot(light)) {\n            decodeClusterLightSpot(light);\n            dAtten *= getSpotEffect(light.direction, light.innerConeAngleCos, light.outerConeAngleCos);\n        }\n\n        #if defined(CLUSTER_COOKIES_OR_SHADOWS)\n\n        if (dAtten > 0.00001) {\n\n            // shadow / cookie\n            if (isClusteredLightCastShadow(light) || isClusteredLightCookie(light)) {\n\n                // shared shadow / cookie data depends on light type\n                if (isClusteredLightSpot(light)) {\n                    decodeClusterLightProjectionMatrixData(light);\n                } else {\n                    decodeClusterLightOmniAtlasViewport(light);\n                }\n\n                float shadowTextureResolution = shadowAtlasParams.x;\n                float shadowEdgePixels = shadowAtlasParams.y;\n\n                #ifdef CLUSTER_COOKIES\n\n                // cookie\n                if (isClusteredLightCookie(light)) {\n                    decodeClusterLightCookieData(light);\n\n                    if (isClusteredLightSpot(light)) {\n                        dAtten3 = getCookie2DClustered(cookieAtlasTexture, lightProjectionMatrix, vPositionW, light.cookieIntensity, isClusteredLightCookieRgb(light), light.cookieChannelMask);\n                    } else {\n                        dAtten3 = getCookieCubeClustered(cookieAtlasTexture, dLightDirW, light.cookieIntensity, isClusteredLightCookieRgb(light), light.cookieChannelMask, shadowTextureResolution, shadowEdgePixels, light.omniAtlasViewport);\n                    }\n                }\n\n                #endif\n\n                #ifdef CLUSTER_SHADOWS\n\n                // shadow\n                if (isClusteredLightCastShadow(light)) {\n                    decodeClusterLightShadowData(light);\n\n                    vec4 shadowParams = vec4(shadowTextureResolution, light.shadowNormalBias, light.shadowBias, 1.0 / light.range);\n\n                    if (isClusteredLightSpot(light)) {\n\n                        // spot shadow\n                        getShadowCoordPerspZbufferNormalOffset(lightProjectionMatrix, shadowParams);\n                        \n                        #if defined(CLUSTER_SHADOW_TYPE_PCF1)\n                            float shadow = getShadowSpotClusteredPCF1(shadowAtlasTexture, shadowParams);\n                        #elif defined(CLUSTER_SHADOW_TYPE_PCF3)\n                            float shadow = getShadowSpotClusteredPCF3(shadowAtlasTexture, shadowParams);\n                        #elif defined(CLUSTER_SHADOW_TYPE_PCF5)\n                            float shadow = getShadowSpotClusteredPCF5(shadowAtlasTexture, shadowParams);\n                        #endif\n                        dAtten *= mix(1.0, shadow, light.shadowIntensity);\n\n                    } else {\n\n                        // omni shadow\n                        normalOffsetPointShadow(shadowParams);  // normalBias adjusted for distance\n\n                        #if defined(CLUSTER_SHADOW_TYPE_PCF1)\n                            float shadow = getShadowOmniClusteredPCF1(shadowAtlasTexture, shadowParams, light.omniAtlasViewport, shadowEdgePixels, dLightDirW);\n                        #elif defined(CLUSTER_SHADOW_TYPE_PCF3)\n                            float shadow = getShadowOmniClusteredPCF3(shadowAtlasTexture, shadowParams, light.omniAtlasViewport, shadowEdgePixels, dLightDirW);\n                        #elif defined(CLUSTER_SHADOW_TYPE_PCF5)\n                            float shadow = getShadowOmniClusteredPCF5(shadowAtlasTexture, shadowParams, light.omniAtlasViewport, shadowEdgePixels, dLightDirW);\n                        #endif\n                        dAtten *= mix(1.0, shadow, light.shadowIntensity);\n                    }\n                }\n\n                #endif\n            }\n        }\n\n        #endif\n\n        // diffuse / specular / clearcoat\n        #ifdef CLUSTER_AREALIGHTS\n\n        if (isClusteredLightArea(light)) { // area light\n\n            // area light diffuse\n            {\n                vec3 areaDiffuse = (dAttenD * dAtten) * light.color * dAtten3;\n\n                #if defined(LIT_SPECULAR)\n                    #if defined(LIT_CONSERVE_ENERGY)\n                        areaDiffuse = mix(areaDiffuse, vec3(0), dLTCSpecFres);\n                    #endif\n                #endif\n\n                // area light diffuse - it does not mix diffuse lighting into specular attenuation\n                dDiffuseLight += areaDiffuse;\n            }\n\n            // specular and clear coat are material settings and get included by a define based on the material\n            #ifdef LIT_SPECULAR\n\n                // area light specular\n                float areaLightSpecular;\n\n                if (isClusteredLightRect(light)) {\n                    areaLightSpecular = getRectLightSpecular();\n                } else if (isClusteredLightDisk(light)) {\n                    areaLightSpecular = getDiskLightSpecular();\n                } else { // sphere\n                    areaLightSpecular = getSphereLightSpecular();\n                }\n\n                dSpecularLight += dLTCSpecFres * areaLightSpecular * dAtten * light.color * dAtten3;\n\n                #ifdef LIT_CLEARCOAT\n\n                    // area light specular clear coat\n                    float areaLightSpecularCC;\n\n                    if (isClusteredLightRect(light)) {\n                        areaLightSpecularCC = getRectLightSpecularCC();\n                    } else if (isClusteredLightDisk(light)) {\n                        areaLightSpecularCC = getDiskLightSpecularCC();\n                    } else { // sphere\n                        areaLightSpecularCC = getSphereLightSpecularCC();\n                    }\n\n                    ccSpecularLight += ccLTCSpecFres * areaLightSpecularCC * dAtten * light.color  * dAtten3;\n\n                #endif\n\n            #endif\n\n        } else\n\n        #endif\n\n        {    // punctual light\n\n            // punctual light diffuse\n            {\n                vec3 punctualDiffuse = dAtten * light.color * dAtten3;\n\n                #if defined(CLUSTER_AREALIGHTS)\n                #if defined(LIT_SPECULAR)\n                #if defined(LIT_CONSERVE_ENERGY)\n                    punctualDiffuse = mix(punctualDiffuse, vec3(0), dSpecularity);\n                #endif\n                #endif\n                #endif\n\n                dDiffuseLight += punctualDiffuse;\n            }\n   \n            // specular and clear coat are material settings and get included by a define based on the material\n            #ifdef LIT_SPECULAR\n\n                vec3 halfDir = normalize(-dLightDirNormW + dViewDirW);\n                \n                // specular\n                #ifdef LIT_SPECULAR_FRESNEL\n                    dSpecularLight += getLightSpecular(halfDir) * dAtten * light.color * dAtten3 * getFresnel(dot(dViewDirW, halfDir), dSpecularity);\n                #else\n                    dSpecularLight += getLightSpecular(halfDir) * dAtten * light.color * dAtten3 * dSpecularity;\n                #endif\n\n                #ifdef LIT_CLEARCOAT\n                    #ifdef LIT_SPECULAR_FRESNEL\n                        ccSpecularLight += getLightSpecularCC(halfDir) * dAtten * light.color * dAtten3 * getFresnel(dot(dViewDirW, halfDir), vec3(ccSpecularity));\n                    #else\n                        ccSpecularLight += getLightSpecularCC(halfDir) * dAtten * light.color * dAtten3 * vec3(ccSpecularity);\n                    #endif\n                #endif\n\n                #ifdef LIT_SHEEN\n                    sSpecularLight += getLightSpecularSheen(halfDir) * dAtten * light.color * dAtten3 * sSpecularity;\n                #endif\n\n            #endif\n        }\n    }\n}\n\nvoid evaluateClusterLight(float lightIndex) {\n\n    // decode core light data from textures\n    ClusterLightData clusterLightData;\n    decodeClusterLightCore(clusterLightData, lightIndex);\n\n    // evaluate light if it uses accepted light mask\n    if (acceptLightMask(clusterLightData))\n        evaluateLight(clusterLightData);\n}\n\nvoid addClusteredLights() {\n    // world space position to 3d integer cell cordinates in the cluster structure\n    vec3 cellCoords = floor((vPositionW - clusterBoundsMin) * clusterCellsCountByBoundsSize);\n\n    // no lighting when cell coordinate is out of range\n    if (!(any(lessThan(cellCoords, vec3(0.0))) || any(greaterThanEqual(cellCoords, clusterCellsMax)))) {\n\n        // cell index (mapping from 3d cell coordinates to linear memory)\n        float cellIndex = dot(clusterCellsDot, cellCoords);\n\n        // convert cell index to uv coordinates\n        float clusterV = floor(cellIndex * clusterTextureSize.y);\n        float clusterU = cellIndex - (clusterV * clusterTextureSize.x);\n        clusterV = (clusterV + 0.5) * clusterTextureSize.z;\n\n        // loop over maximum possible number of supported light cells\n        const float maxLightCells = 256.0 / 4.0;  // 8 bit index, each stores 4 lights\n        for (float lightCellIndex = 0.5; lightCellIndex < maxLightCells; lightCellIndex++) {\n\n            vec4 lightIndices = textureData(clusterWorldTexture, vec2(clusterTextureSize.y * (clusterU + lightCellIndex), clusterV));\n            vec4 indices = lightIndices * 255.0;\n\n            // evaluate up to 4 lights. This is written using a loop instead of manually unrolling to keep shader compile time smaller\n            for (int i = 0; i < 4; i++) {\n                \n                if (indices.x <= 0.0)\n                    return;\n\n                evaluateClusterLight(indices.x); \n                indices = indices.yzwx;\n            }\n\n            // end of the cell array\n            if (lightCellIndex > clusterPixelsPerCell) {\n                break;\n            }\n        }\n    }\n}\n";

	var combinePS = "\nvec3 combineColor() {\n    vec3 ret = vec3(0);\n#ifdef LIT_OLD_AMBIENT\n    ret += (dDiffuseLight - light_globalAmbient) * dAlbedo + material_ambient * light_globalAmbient;\n#else\n    ret += dAlbedo * dDiffuseLight;\n#endif\n#ifdef LIT_SPECULAR\n    ret += dSpecularLight;\n#endif\n#ifdef LIT_REFLECTIONS\n    ret += dReflection.rgb * dReflection.a;\n#endif\n#ifdef LIT_CLEARCOAT\n    ret += ccSpecularLight + ccReflection.rgb * ccReflection.a;\n#endif\n#ifdef LIT_SHEEN\n    float scaling = 1.0 - max(max(sSpecularity.r, sSpecularity.g), sSpecularity.b) * 0.157;\n    ret = ret * scaling + sSpecularLight + sReflection.rgb * sReflection.a;\n#endif\n    return ret;\n}\n";

	var cookiePS = "\n// light cookie functionality for non-clustered lights\nvec4 getCookie2D(sampler2D tex, mat4 transform, float intensity) {\n    vec4 projPos = transform * vec4(vPositionW, 1.0);\n    projPos.xy /= projPos.w;\n    return mix(vec4(1.0), texture2D(tex, projPos.xy), intensity);\n}\n\nvec4 getCookie2DClip(sampler2D tex, mat4 transform, float intensity) {\n    vec4 projPos = transform * vec4(vPositionW, 1.0);\n    projPos.xy /= projPos.w;\n    if (projPos.x < 0.0 || projPos.x > 1.0 || projPos.y < 0.0 || projPos.y > 1.0 || projPos.z < 0.0) return vec4(0.0);\n    return mix(vec4(1.0), texture2D(tex, projPos.xy), intensity);\n}\n\nvec4 getCookie2DXform(sampler2D tex, mat4 transform, float intensity, vec4 cookieMatrix, vec2 cookieOffset) {\n    vec4 projPos = transform * vec4(vPositionW, 1.0);\n    projPos.xy /= projPos.w;\n    projPos.xy += cookieOffset;\n    vec2 uv = mat2(cookieMatrix) * (projPos.xy-vec2(0.5)) + vec2(0.5);\n    return mix(vec4(1.0), texture2D(tex, uv), intensity);\n}\n\nvec4 getCookie2DClipXform(sampler2D tex, mat4 transform, float intensity, vec4 cookieMatrix, vec2 cookieOffset) {\n    vec4 projPos = transform * vec4(vPositionW, 1.0);\n    projPos.xy /= projPos.w;\n    projPos.xy += cookieOffset;\n    if (projPos.x < 0.0 || projPos.x > 1.0 || projPos.y < 0.0 || projPos.y > 1.0 || projPos.z < 0.0) return vec4(0.0);\n    vec2 uv = mat2(cookieMatrix) * (projPos.xy-vec2(0.5)) + vec2(0.5);\n    return mix(vec4(1.0), texture2D(tex, uv), intensity);\n}\n\nvec4 getCookieCube(samplerCube tex, mat4 transform, float intensity) {\n    return mix(vec4(1.0), textureCube(tex, dLightDirNormW * mat3(transform)), intensity);\n}\n";

	var cubeMapProjectBoxPS = "\nuniform vec3 envBoxMin, envBoxMax;\n\nvec3 cubeMapProject(vec3 nrdir) {\n    nrdir = cubeMapRotate(nrdir);\n\n    vec3 rbmax = (envBoxMax - vPositionW) / nrdir;\n    vec3 rbmin = (envBoxMin - vPositionW) / nrdir;\n\n    vec3 rbminmax;\n    rbminmax.x = nrdir.x>0.0? rbmax.x : rbmin.x;\n    rbminmax.y = nrdir.y>0.0? rbmax.y : rbmin.y;\n    rbminmax.z = nrdir.z>0.0? rbmax.z : rbmin.z;\n\n    float fa = min(min(rbminmax.x, rbminmax.y), rbminmax.z);\n\n    vec3 posonbox = vPositionW + nrdir * fa;\n    vec3 envBoxPos = (envBoxMin + envBoxMax) * 0.5;\n    return normalize(posonbox - envBoxPos);\n}\n";

	var cubeMapProjectNonePS = "\nvec3 cubeMapProject(vec3 dir) {\n    return cubeMapRotate(dir);\n}\n";

	var cubeMapRotatePS = "\n#ifdef CUBEMAP_ROTATION\nuniform mat3 cubeMapRotationMatrix;\n#endif\n\nvec3 cubeMapRotate(vec3 refDir) {\n#ifdef CUBEMAP_ROTATION\n    return refDir * cubeMapRotationMatrix;\n#else\n    return refDir;\n#endif\n}\n";

	var decodePS = "\nvec3 decodeLinear(vec4 raw) {\n    return raw.rgb;\n}\n\nfloat decodeGamma(float raw) {\n    return pow(raw, 2.2);\n}\n\nvec3 decodeGamma(vec3 raw) {\n    return pow(raw, vec3(2.2));\n}\n\nvec3 decodeGamma(vec4 raw) {\n    return pow(raw.xyz, vec3(2.2));\n}\n\nvec3 decodeRGBM(vec4 raw) {\n    vec3 color = (8.0 * raw.a) * raw.rgb;\n    return color * color;\n}\n\nvec3 decodeRGBP(vec4 raw) {\n    vec3 color = raw.rgb * (-raw.a * 7.0 + 8.0);\n    return color * color;\n}\n\nvec3 decodeRGBE(vec4 raw) {\n    if (raw.a == 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    } else {\n        return raw.xyz * pow(2.0, raw.w * 255.0 - 128.0);\n    }\n}\n\nvec4 passThrough(vec4 raw) {\n    return raw;\n}\n";

	var detailModesPS = "\nvec3 detailMode_mul(vec3 c1, vec3 c2) {\n    return c1 * c2;\n}\n\nvec3 detailMode_add(vec3 c1, vec3 c2) {\n    return c1 + c2;\n}\n\n// https://en.wikipedia.org/wiki/Blend_modes#Screen\nvec3 detailMode_screen(vec3 c1, vec3 c2) {\n    return 1.0 - (1.0 - c1)*(1.0 - c2);\n}\n\n// https://en.wikipedia.org/wiki/Blend_modes#Overlay\nvec3 detailMode_overlay(vec3 c1, vec3 c2) {\n    return mix(1.0 - 2.0*(1.0 - c1)*(1.0 - c2), 2.0*c1*c2, step(c1, vec3(0.5)));\n}\n\nvec3 detailMode_min(vec3 c1, vec3 c2) {\n    return min(c1, c2);\n}\n\nvec3 detailMode_max(vec3 c1, vec3 c2) {\n    return max(c1, c2);\n}\n";

	var diffusePS = "\n#ifdef MAPCOLOR\nuniform vec3 material_diffuse;\n#endif\n\n#ifdef MAPTEXTURE\nuniform sampler2D texture_diffuseMap;\n#endif\n\nvoid getAlbedo() {\n    dAlbedo = vec3(1.0);\n\n#ifdef MAPCOLOR\n    dAlbedo *= material_diffuse.rgb;\n#endif\n\n#ifdef MAPTEXTURE\n    vec3 albedoBase = gammaCorrectInput(texture2DBias(texture_diffuseMap, $UV, textureBias).$CH);\n    dAlbedo *= addAlbedoDetail(albedoBase);\n#endif\n\n#ifdef MAPVERTEX\n    dAlbedo *= gammaCorrectInput(saturate(vVertexColor.$VC));\n#endif\n}\n";

	var diffuseDetailMapPS = "\n#ifdef MAPTEXTURE\nuniform sampler2D texture_diffuseDetailMap;\n#endif\n\nvec3 addAlbedoDetail(vec3 albedo) {\n#ifdef MAPTEXTURE\n    vec3 albedoDetail = gammaCorrectInput(texture2DBias(texture_diffuseDetailMap, $UV, textureBias).$CH);\n    return detailMode_$DETAILMODE(albedo, albedoDetail);\n#else\n    return albedo;\n#endif\n}\n";

	var emissivePS = "\n#ifdef MAPCOLOR\nuniform vec3 material_emissive;\n#endif\n\n#ifdef MAPFLOAT\nuniform float material_emissiveIntensity;\n#endif\n\n#ifdef MAPTEXTURE\nuniform sampler2D texture_emissiveMap;\n#endif\n\nvoid getEmission() {\n    dEmission = vec3(1.0);\n\n    #ifdef MAPFLOAT\n    dEmission *= material_emissiveIntensity;\n    #endif\n\n    #ifdef MAPCOLOR\n    dEmission *= material_emissive;\n    #endif\n\n    #ifdef MAPTEXTURE\n    dEmission *= $DECODE(texture2DBias(texture_emissiveMap, $UV, textureBias)).$CH;\n    #endif\n\n    #ifdef MAPVERTEX\n    dEmission *= gammaCorrectInput(saturate(vVertexColor.$VC));\n    #endif\n}\n";

	var encodePS = "\nvec4 encodeLinear(vec3 source) {\n    return vec4(source, 1.0);\n}\n\nvec4 encodeGamma(vec3 source) {\n    return vec4(pow(source + 0.0000001, vec3(1.0 / 2.2)), 1.0);\n}\n\nvec4 encodeRGBM(vec3 source) { // modified RGBM\n    vec4 result;\n    result.rgb = pow(source.rgb, vec3(0.5));\n    result.rgb *= 1.0 / 8.0;\n\n    result.a = saturate( max( max( result.r, result.g ), max( result.b, 1.0 / 255.0 ) ) );\n    result.a = ceil(result.a * 255.0) / 255.0;\n\n    result.rgb /= result.a;\n    return result;\n}\n\nvec4 encodeRGBP(vec3 source) {\n    // convert incoming linear to gamma(ish)\n    vec3 gamma = pow(source, vec3(0.5));\n\n    // calculate the maximum component clamped to 1..8\n    float maxVal = min(8.0, max(1.0, max(gamma.x, max(gamma.y, gamma.z))));\n\n    // calculate storage factor\n    float v = 1.0 - ((maxVal - 1.0) / 7.0);\n\n    // round the value for storage in 8bit channel\n    v = ceil(v * 255.0) / 255.0;\n\n    return vec4(gamma / (-v * 7.0 + 8.0), v);    \n}\n\nvec4 encodeRGBE(vec3 source) {\n    float maxVal = max(source.x, max(source.y, source.z));\n    if (maxVal < 1e-32) {\n        return vec4(0, 0, 0, 0);\n    } else {\n        float e = ceil(log2(maxVal));\n        return vec4(source / pow(2.0, e), (e + 128.0) / 255.0);\n    }\n}\n";

	var endPS = "\n    gl_FragColor.rgb = combineColor();\n\n    gl_FragColor.rgb += dEmission;\n    gl_FragColor.rgb = addFog(gl_FragColor.rgb);\n\n    #ifndef HDR\n    gl_FragColor.rgb = toneMap(gl_FragColor.rgb);\n    gl_FragColor.rgb = gammaCorrectOutput(gl_FragColor.rgb);\n    #endif\n";

	var endVS = "\n";

	var envAtlasPS = "\n// the envAtlas is fixed at 512 pixels. every equirect is generated with 1 pixel boundary.\nconst float atlasSize = 512.0;\nconst float seamSize = 1.0 / atlasSize;\n\n// map a normalized equirect UV to the given rectangle (taking 1 pixel seam into account).\nvec2 mapUv(vec2 uv, vec4 rect) {\n    return vec2(mix(rect.x + seamSize, rect.x + rect.z - seamSize, uv.x),\n                mix(rect.y + seamSize, rect.y + rect.w - seamSize, uv.y));\n}\n\n// map a normalized equirect UV and roughness level to the correct atlas rect.\nvec2 mapRoughnessUv(vec2 uv, float level) {\n    float t = 1.0 / exp2(level);\n    return mapUv(uv, vec4(0, 1.0 - t, t, t * 0.5));\n}\n\n// map shiny level UV\nvec2 mapShinyUv(vec2 uv, float level) {\n    float t = 1.0 / exp2(level);\n    return mapUv(uv, vec4(1.0 - t, 1.0 - t, t, t * 0.5));\n}\n";

	var envConstPS = "\nvec3 processEnvironment(vec3 color) {\n    return color;\n}\n";

	var envMultiplyPS = "\nuniform float skyboxIntensity;\n\nvec3 processEnvironment(vec3 color) {\n    return color * skyboxIntensity;\n}\n";

	var extensionPS = "\n";

	var extensionVS = "\n";

	var falloffInvSquaredPS = "\nfloat getFalloffWindow(float lightRadius) {\n    float sqrDist = dot(dLightDirW, dLightDirW);\n    float invRadius = 1.0 / lightRadius;\n    return square( saturate( 1.0 - square( sqrDist * square(invRadius) ) ) );\n}\n\nfloat getFalloffInvSquared(float lightRadius) {\n    float sqrDist = dot(dLightDirW, dLightDirW);\n    float falloff = 1.0 / (sqrDist + 1.0);\n    float invRadius = 1.0 / lightRadius;\n\n    falloff *= 16.0;\n    falloff *= square( saturate( 1.0 - square( sqrDist * square(invRadius) ) ) );\n\n    return falloff;\n}\n";

	var falloffLinearPS = "\nfloat getFalloffLinear(float lightRadius) {\n    float d = length(dLightDirW);\n    return max(((lightRadius - d) / lightRadius), 0.0);\n}\n";

	var fixCubemapSeamsNonePS = "\nvec3 fixSeams(vec3 vec, float mipmapIndex) {\n    return vec;\n}\n\nvec3 fixSeams(vec3 vec) {\n    return vec;\n}\n\nvec3 fixSeamsStatic(vec3 vec, float invRecMipSize) {\n    return vec;\n}\n\nvec3 calcSeam(vec3 vec) {\n    return vec3(0);\n}\n\nvec3 applySeam(vec3 vec, vec3 seam, float scale) {\n    return vec;\n}\n";

	var fixCubemapSeamsStretchPS = "\nvec3 fixSeams(vec3 vec, float mipmapIndex) {\n    vec3 avec = abs(vec);\n    float scale = 1.0 - exp2(mipmapIndex) / 128.0;\n    float M = max(max(avec.x, avec.y), avec.z);\n    if (avec.x != M) vec.x *= scale;\n    if (avec.y != M) vec.y *= scale;\n    if (avec.z != M) vec.z *= scale;\n    return vec;\n}\n\nvec3 fixSeams(vec3 vec) {\n    vec3 avec = abs(vec);\n    float scale = 1.0 - 1.0 / 128.0;\n    float M = max(max(avec.x, avec.y), avec.z);\n    if (avec.x != M) vec.x *= scale;\n    if (avec.y != M) vec.y *= scale;\n    if (avec.z != M) vec.z *= scale;\n    return vec;\n}\n\nvec3 fixSeamsStatic(vec3 vec, float invRecMipSize) {\n    vec3 avec = abs(vec);\n    float scale = invRecMipSize;\n    float M = max(max(avec.x, avec.y), avec.z);\n    if (avec.x != M) vec.x *= scale;\n    if (avec.y != M) vec.y *= scale;\n    if (avec.z != M) vec.z *= scale;\n    return vec;\n}\n\nvec3 calcSeam(vec3 vec) {\n    vec3 avec = abs(vec);\n    float M = max(avec.x, max(avec.y, avec.z));\n    return vec3(avec.x != M ? 1.0 : 0.0,\n                avec.y != M ? 1.0 : 0.0,\n                avec.z != M ? 1.0 : 0.0);\n}\n\nvec3 applySeam(vec3 vec, vec3 seam, float scale) {\n    return vec * (seam * -scale + vec3(1.0));\n}\n";

	var floatUnpackingPS = "\n// float unpacking functionality, complimentary to float-packing.js\nfloat bytes2float2(vec2 data) {\n    return dot(data, vec2(1.0, 1.0 / 255.0));\n}\n\nfloat bytes2float3(vec3 data) {\n    return dot(data, vec3(1.0, 1.0 / 255.0, 1.0 / 65025.0));\n}\n\nfloat bytes2float4(vec4 data) {\n    return dot(data, vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n}\n\nfloat bytes2floatRange2(vec2 data, float min, float max) {\n    return mix(min, max, bytes2float2(data));\n}\n\nfloat bytes2floatRange3(vec3 data, float min, float max) {\n    return mix(min, max, bytes2float3(data));\n}\n\nfloat bytes2floatRange4(vec4 data, float min, float max) {\n    return mix(min, max, bytes2float4(data));\n}\n\nfloat mantissaExponent2Float(vec4 pack)\n{\n    float value = bytes2floatRange3(pack.xyz, -1.0, 1.0);\n    float exponent = floor(pack.w * 255.0 - 127.0);\n    return value * exp2(exponent);\n}\n";

	var fogExpPS = "\nuniform vec3 fog_color;\nuniform float fog_density;\nfloat dBlendModeFogFactor = 1.0;\n\nvec3 addFog(vec3 color) {\n    float depth = gl_FragCoord.z / gl_FragCoord.w;\n    float fogFactor = exp(-depth * fog_density);\n    fogFactor = clamp(fogFactor, 0.0, 1.0);\n    return mix(fog_color * dBlendModeFogFactor, color, fogFactor);\n}\n";

	var fogExp2PS = "\nuniform vec3 fog_color;\nuniform float fog_density;\nfloat dBlendModeFogFactor = 1.0;\n\nvec3 addFog(vec3 color) {\n    float depth = gl_FragCoord.z / gl_FragCoord.w;\n    float fogFactor = exp(-depth * depth * fog_density * fog_density);\n    fogFactor = clamp(fogFactor, 0.0, 1.0);\n    return mix(fog_color * dBlendModeFogFactor, color, fogFactor);\n}\n";

	var fogLinearPS = "\nuniform vec3 fog_color;\nuniform float fog_start;\nuniform float fog_end;\nfloat dBlendModeFogFactor = 1.0;\n\nvec3 addFog(vec3 color) {\n    float depth = gl_FragCoord.z / gl_FragCoord.w;\n    float fogFactor = (fog_end - depth) / (fog_end - fog_start);\n    fogFactor = clamp(fogFactor, 0.0, 1.0);\n    return mix(fog_color * dBlendModeFogFactor, color, fogFactor);\n}\n";

	var fogNonePS = "\nfloat dBlendModeFogFactor = 1.0;\n\nvec3 addFog(vec3 color) {\n    return color;\n}\n";

	var fresnelSchlickPS = "\n// Schlick's approximation\nvec3 getFresnel(float cosTheta, vec3 f0) {\n    float fresnel = pow(1.0 - max(cosTheta, 0.0), 5.0);\n    float glossSq = dGlossiness * dGlossiness;\n    return f0 + (max(vec3(glossSq), f0) - f0) * fresnel;\n}\n";

	var fullscreenQuadPS = "\nvarying vec2 vUv0;\n\nuniform sampler2D source;\n\nvoid main(void) {\n    gl_FragColor = texture2D(source, vUv0);\n}\n";

	var fullscreenQuadVS = "\nattribute vec2 vertex_position;\n\nvarying vec2 vUv0;\n\nvoid main(void)\n{\n    gl_Position = vec4(vertex_position, 0.5, 1.0);\n    vUv0 = vertex_position.xy*0.5+0.5;\n}\n";

	var gamma1_0PS = "\nfloat gammaCorrectInput(float color) {\n    return color;\n}\n\nvec3 gammaCorrectInput(vec3 color) {\n    return color;\n}\n\nvec4 gammaCorrectInput(vec4 color) {\n    return color;\n}\n\nvec3 gammaCorrectOutput(vec3 color) {\n    return color;\n}\n";

	var gamma2_2PS = "\nfloat gammaCorrectInput(float color) {\n    return decodeGamma(color);\n}\n\nvec3 gammaCorrectInput(vec3 color) {\n    return decodeGamma(color);\n}\n\nvec4 gammaCorrectInput(vec4 color) {\n    return vec4(decodeGamma(color.xyz), color.w);\n}\n\nvec3 gammaCorrectOutput(vec3 color) {\n#ifdef HDR\n    return color;\n#else\n    return pow(color + 0.0000001, vec3(1.0 / 2.2));\n#endif\n}\n";

	var gles2PS = "\n#define texture2DBias texture2D\n";

	var gles3PS = "\n#define varying in\nout highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define texture2D texture\n#define texture2DBias texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\n#define GL2\n#define SUPPORTS_TEXLOD\n";

	var gles3VS = "\n#define attribute in\n#define varying out\n#define texture2D texture\n#define GL2\n#define VERTEXSHADER\n";

	var glossPS = "\n#ifdef MAPFLOAT\nuniform float material_shininess;\n#endif\n\n#ifdef MAPTEXTURE\nuniform sampler2D texture_glossMap;\n#endif\n\nvoid getGlossiness() {\n    dGlossiness = 1.0;\n\n    #ifdef MAPFLOAT\n    dGlossiness *= material_shininess;\n    #endif\n\n    #ifdef MAPTEXTURE\n    dGlossiness *= texture2DBias(texture_glossMap, $UV, textureBias).$CH;\n    #endif\n\n    #ifdef MAPVERTEX\n    dGlossiness *= saturate(vVertexColor.$VC);\n    #endif\n\n    dGlossiness += 0.0000001;\n}\n";

	var instancingVS = "\nattribute vec4 instance_line1;\nattribute vec4 instance_line2;\nattribute vec4 instance_line3;\nattribute vec4 instance_line4;\n";

	var lightDiffuseLambertPS = "\nfloat getLightDiffuse() {\n    return max(dot(dNormalW, -dLightDirNormW), 0.0);\n}\n";

	var lightDirPointPS = "\nvoid getLightDirPoint(vec3 lightPosW) {\n    dLightDirW = vPositionW - lightPosW;\n    dLightDirNormW = normalize(dLightDirW);\n    dLightPosW = lightPosW;\n}\n";

	var lightmapAddPS = "\nvoid addLightMap() {\n    dDiffuseLight += dLightmap;\n}\n";

	var lightmapDirAddPS = "\nvoid addLightMap() {\n    if (dot(dLightmapDir, dLightmapDir) < 0.0001) {\n        dDiffuseLight += dLightmap;\n    } else {\n        dLightDirNormW = dLightmapDir;\n\n        float vlight = saturate(dot(dLightDirNormW, -dVertexNormalW));\n        float flight = saturate(dot(dLightDirNormW, -dNormalW));\n        float nlight = (flight / max(vlight, 0.01)) * 0.5;\n\n        dDiffuseLight += dLightmap * nlight * 2.0;\n\n        vec3 halfDirW = normalize(-dLightmapDir + dViewDirW);\n        vec3 specularLight = dLightmap * getLightSpecular(halfDirW);\n\n        #ifdef LIT_SPECULAR_FRESNEL\n        specularLight *= getFresnel(dot(dViewDirW, halfDirW), dSpecularity);\n        #endif\n\n        dSpecularLight += specularLight;\n    }\n}\n";

	var lightmapDirPS = "\nuniform sampler2D texture_lightMap;\nuniform sampler2D texture_dirLightMap;\n\nvoid getLightMap() {\n    dLightmap = $DECODE(texture2DBias(texture_lightMap, $UV, textureBias)).$CH;\n\n    vec3 dir = texture2DBias(texture_dirLightMap, $UV, textureBias).xyz * 2.0 - 1.0;\n    float dirDot = dot(dir, dir);\n    dLightmapDir = (dirDot > 0.001) ? dir / sqrt(dirDot) : vec3(0.0);\n}\n";

	var lightmapSinglePS = "\n#ifdef MAPTEXTURE\nuniform sampler2D texture_lightMap;\n#endif\n\nvoid getLightMap() {\n    dLightmap = vec3(1.0);\n\n    #ifdef MAPTEXTURE\n    dLightmap *= $DECODE(texture2DBias(texture_lightMap, $UV, textureBias)).$CH;\n    #endif\n\n    #ifdef MAPVERTEX\n    dLightmap *= saturate(vVertexColor.$VC);\n    #endif\n}\n";

	var lightSpecularAnisoGGXPS = "\n// Anisotropic GGX\nfloat calcLightSpecular(float tGlossiness, vec3 tNormalW, vec3 h) {\n    float PI = 3.141592653589793;\n    float roughness = max((1.0 - tGlossiness) * (1.0 - tGlossiness), 0.001);\n    float anisotropy = material_anisotropy * roughness;\n \n    float at = max((roughness + anisotropy), roughness / 4.0);\n    float ab = max((roughness - anisotropy), roughness / 4.0);\n\n    float NoH = dot(tNormalW, h);\n    float ToH = dot(dTBN[0], h);\n    float BoH = dot(dTBN[1], h);\n\n    float a2 = at * ab;\n    vec3 v = vec3(ab * ToH, at * BoH, a2 * NoH);\n    float v2 = dot(v, v);\n    float w2 = a2 / v2;\n    float D = a2 * w2 * w2 * (1.0 / PI);\n\n    float ToV = dot(dTBN[0], dViewDirW);\n    float BoV = dot(dTBN[1], dViewDirW);\n    float ToL = dot(dTBN[0], -dLightDirNormW);\n    float BoL = dot(dTBN[1], -dLightDirNormW);\n    float NoV = dot(tNormalW, dViewDirW);\n    float NoL = dot(tNormalW, -dLightDirNormW);\n\n    float lambdaV = NoL * length(vec3(at * ToV, ab * BoV, NoV));\n    float lambdaL = NoV * length(vec3(at * ToL, ab * BoL, NoL));\n    float G = 0.5 / (lambdaV + lambdaL);\n\n    return D * G;\n}\n\nfloat getLightSpecular(vec3 h) {\n    return calcLightSpecular(dGlossiness, dNormalW, h);\n}\n\n#ifdef LIT_CLEARCOAT\nfloat getLightSpecularCC(vec3 h) {\n    return calcLightSpecular(ccGlossiness, ccNormalW, h);\n}\n#endif\n";

	var lightSpecularBlinnPS = "\n// Energy-conserving (hopefully) Blinn-Phong\nfloat calcLightSpecular(float tGlossiness, vec3 tNormalW, vec3 h) {\n    float nh = max( dot( h, tNormalW ), 0.0 );\n\n    float specPow = exp2(tGlossiness * 11.0); // glossiness is linear, power is not; 0 - 2048\n\n    // Hack: On Mac OS X, calling pow with zero for the exponent generates hideous artifacts so bias up a little\n    specPow = max(specPow, 0.0001);\n\n    return pow(nh, specPow) * (specPow + 2.0) / 8.0;\n}\n\nfloat getLightSpecular(vec3 h) {\n    return calcLightSpecular(dGlossiness, dNormalW, h);\n}\n\n#ifdef LIT_CLEARCOAT\nfloat getLightSpecularCC(vec3 h) {\n    return calcLightSpecular(ccGlossiness, ccNormalW, h);\n}\n#endif\n";

	var lightSpecularPhongPS = "\nfloat calcLightSpecular(float tGlossiness, vec3 tReflDirW, vec3 h) {\n    float specPow = tGlossiness;\n\n    // Hack: On Mac OS X, calling pow with zero for the exponent generates hideous artifacts so bias up a little\n    return pow(max(dot(tReflDirW, -dLightDirNormW), 0.0), specPow + 0.0001);\n}\n\nfloat getLightSpecular(vec3 h) {\n    return calcLightSpecular(dGlossiness, dReflDirW, h);\n}\n\n#ifdef LIT_CLEARCOAT\nfloat getLightSpecularCC(vec3 h) {\n    return calcLightSpecular(ccGlossiness, ccReflDirW,h );\n}\n#endif\n";

	var lightSheenPS = "\n\nfloat sheenD(vec3 normal, vec3 h, float roughness) {\n    float invR = 1.0 / (roughness * roughness);\n    float cos2h = max(dot(normal, h), 0.0);\n    cos2h *= cos2h;\n    float sin2h = max(1.0 - cos2h, 0.0078125);\n    return (2.0 + invR) * pow(sin2h, invR * 0.5) / (2.0 * PI);\n}\n\nfloat sheenV(vec3 normal, vec3 view, vec3 light) {\n    float NoV = max(dot(normal, view), 0.000001);\n    float NoL = max(dot(normal, light), 0.000001);\n    return 1.0 / (4.0 * (NoL + NoV - NoL * NoV));\n}\n\nfloat getLightSpecularSheen(vec3 h) {\n    float D = sheenD(dNormalW, h, sGlossiness);\n    float V = sheenV(dNormalW, dViewDirW, -dLightDirNormW);\n    return D * V;\n}\n";

	var ltc = "\n// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines\n// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt\n// code: https://github.com/selfshadow/ltc_code/\n\nmat3 transposeMat3( const in mat3 m ) {\n    mat3 tmp;\n    tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n    tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n    tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n    return tmp;\n}\n\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n    const float LUT_SIZE = 64.0;\n    const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n    const float LUT_BIAS = 0.5 / LUT_SIZE;\n    float dotNV = saturate( dot( N, V ) );\n    // texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )\n    vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n    uv = uv * LUT_SCALE + LUT_BIAS;\n    return uv;\n}\n\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n    // Real-Time Area Lighting: a Journey from Research to Production (p.102)\n    // An approximation of the form factor of a horizon-clipped rectangle.\n    float l = length( f );\n    return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\n\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n    float x = dot( v1, v2 );\n    float y = abs( x );\n    // rational polynomial approximation to theta / sin( theta ) / 2PI\n    float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n    float b = 3.4175940 + ( 4.1616724 + y ) * y;\n    float v = a / b;\n    float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n    return cross( v1, v2 ) * theta_sintheta;\n}\n\nstruct Coords {\n    vec3 coord0;\n    vec3 coord1;\n    vec3 coord2;\n    vec3 coord3;\n};\n\nfloat LTC_EvaluateRect( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in Coords rectCoords) {\n    // bail if point is on back side of plane of light\n    // assumes ccw winding order of light vertices\n    vec3 v1 = rectCoords.coord1 - rectCoords.coord0;\n    vec3 v2 = rectCoords.coord3 - rectCoords.coord0;\n    \n    vec3 lightNormal = cross( v1, v2 );\n    // if( dot( lightNormal, P - rectCoords.coord0 ) < 0.0 ) return 0.0;\n    float factor = sign(-dot( lightNormal, P - rectCoords.coord0 ));\n\n    // construct orthonormal basis around N\n    vec3 T1, T2;\n    T1 = normalize( V - N * dot( V, N ) );\n    T2 =  factor * cross( N, T1 ); // negated from paper; possibly due to a different handedness of world coordinate system\n    // compute transform\n    mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n    // transform rect\n    vec3 coords[ 4 ];\n    coords[ 0 ] = mat * ( rectCoords.coord0 - P );\n    coords[ 1 ] = mat * ( rectCoords.coord1 - P );\n    coords[ 2 ] = mat * ( rectCoords.coord2 - P );\n    coords[ 3 ] = mat * ( rectCoords.coord3 - P );\n    // project rect onto sphere\n    coords[ 0 ] = normalize( coords[ 0 ] );\n    coords[ 1 ] = normalize( coords[ 1 ] );\n    coords[ 2 ] = normalize( coords[ 2 ] );\n    coords[ 3 ] = normalize( coords[ 3 ] );\n    // calculate vector form factor\n    vec3 vectorFormFactor = vec3( 0.0 );\n    vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n    vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n    vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n    vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n    // adjust for horizon clipping\n    float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\n    return result;\n}\n\nCoords dLTCCoords;\nCoords getLTCLightCoords(vec3 lightPos, vec3 halfWidth, vec3 halfHeight){\n    Coords coords;\n    coords.coord0 = lightPos + halfWidth - halfHeight;\n    coords.coord1 = lightPos - halfWidth - halfHeight;\n    coords.coord2 = lightPos - halfWidth + halfHeight;\n    coords.coord3 = lightPos + halfWidth + halfHeight;\n    return coords;\n}\n\nfloat dSphereRadius;\nCoords getSphereLightCoords(vec3 lightPos, vec3 halfWidth, vec3 halfHeight){\n    // used for simple sphere light falloff\n    // also, the code only handles a spherical light, it cannot be non-uniformly scaled in world space, and so we enforce it here\n    dSphereRadius = max(length(halfWidth), length(halfHeight));\n\n    // Billboard the 2d light quad to reflection vector, as it's used for specular. This allows us to use disk math for the sphere.\n    vec3 f = reflect(normalize(lightPos - view_position), vNormalW);\n    vec3 w = normalize(cross(f, halfHeight));\n    vec3 h = normalize(cross(f, w));\n\n    return getLTCLightCoords(lightPos, w * dSphereRadius, h * dSphereRadius);\n}\n\n// used for LTC LUT texture lookup\nvec2 dLTCUV;\n#ifdef LIT_CLEARCOAT\nvec2 ccLTCUV;\n#endif\nvec2 getLTCLightUV(float tGlossiness, vec3 tNormalW)\n{\n    float roughness = max((1.0 - tGlossiness) * (1.0 - tGlossiness), 0.001);\n    return LTC_Uv( tNormalW, dViewDirW, roughness );\n}\n\n//used for energy conservation and to modulate specular\nvec3 dLTCSpecFres;\n#ifdef LIT_CLEARCOAT\nvec3 ccLTCSpecFres;\n#endif\nvec3 getLTCLightSpecFres(vec2 uv, vec3 tSpecularity)\n{\n    vec4 t2 = texture2D( areaLightsLutTex2, uv );\n\n    #ifdef AREA_R8_G8_B8_A8_LUTS\n    t2 *= vec4(0.693103,1,1,1);\n    t2 += vec4(0.306897,0,0,0);\n    #endif\n\n    return tSpecularity * t2.x + ( vec3( 1.0 ) - tSpecularity) * t2.y;\n}\n\nvoid calcLTCLightValues()\n{\n    dLTCUV = getLTCLightUV(dGlossiness, dNormalW);\n    dLTCSpecFres = getLTCLightSpecFres(dLTCUV, dSpecularity); \n\n#ifdef LIT_CLEARCOAT\n    ccLTCUV = getLTCLightUV(ccGlossiness, ccNormalW);\n    ccLTCSpecFres = getLTCLightSpecFres(ccLTCUV, vec3(ccSpecularity));\n#endif\n}\n\nvoid calcRectLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)\n{\n    dLTCCoords = getLTCLightCoords(lightPos, halfWidth, halfHeight);\n}\nvoid calcDiskLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)\n{\n    calcRectLightValues(lightPos, halfWidth, halfHeight);\n}\nvoid calcSphereLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)\n{\n    dLTCCoords = getSphereLightCoords(lightPos, halfWidth, halfHeight);\n}\n\n// An extended version of the implementation from\n// \"How to solve a cubic equation, revisited\"\n// http://momentsingraphics.de/?p=105\nvec3 SolveCubic(vec4 Coefficient)\n{\n    float pi = 3.14159;\n    // Normalize the polynomial\n    Coefficient.xyz /= Coefficient.w;\n    // Divide middle coefficients by three\n    Coefficient.yz /= 3.0;\n\n    float A = Coefficient.w;\n    float B = Coefficient.z;\n    float C = Coefficient.y;\n    float D = Coefficient.x;\n\n    // Compute the Hessian and the discriminant\n    vec3 Delta = vec3(\n        -Coefficient.z * Coefficient.z + Coefficient.y,\n        -Coefficient.y * Coefficient.z + Coefficient.x,\n        dot(vec2(Coefficient.z, -Coefficient.y), Coefficient.xy)\n    );\n\n    float Discriminant = dot(vec2(4.0 * Delta.x, -Delta.y), Delta.zy);\n\n    vec3 RootsA, RootsD;\n\n    vec2 xlc, xsc;\n\n    // Algorithm A\n    {\n        float A_a = 1.0;\n        float C_a = Delta.x;\n        float D_a = -2.0 * B * Delta.x + Delta.y;\n\n        // Take the cubic root of a normalized complex number\n        float Theta = atan(sqrt(Discriminant), -D_a) / 3.0;\n\n        float x_1a = 2.0 * sqrt(-C_a) * cos(Theta);\n        float x_3a = 2.0 * sqrt(-C_a) * cos(Theta + (2.0 / 3.0) * pi);\n\n        float xl;\n        if ((x_1a + x_3a) > 2.0 * B)\n            xl = x_1a;\n        else\n            xl = x_3a;\n\n        xlc = vec2(xl - B, A);\n    }\n\n    // Algorithm D\n    {\n        float A_d = D;\n        float C_d = Delta.z;\n        float D_d = -D * Delta.y + 2.0 * C * Delta.z;\n\n        // Take the cubic root of a normalized complex number\n        float Theta = atan(D * sqrt(Discriminant), -D_d) / 3.0;\n\n        float x_1d = 2.0 * sqrt(-C_d) * cos(Theta);\n        float x_3d = 2.0 * sqrt(-C_d) * cos(Theta + (2.0 / 3.0) * pi);\n\n        float xs;\n        if (x_1d + x_3d < 2.0 * C)\n            xs = x_1d;\n        else\n            xs = x_3d;\n\n        xsc = vec2(-D, xs + C);\n    }\n\n    float E =  xlc.y * xsc.y;\n    float F = -xlc.x * xsc.y - xlc.y * xsc.x;\n    float G =  xlc.x * xsc.x;\n\n    vec2 xmc = vec2(C * F - B * G, -B * F + C * E);\n\n    vec3 Root = vec3(xsc.x / xsc.y, xmc.x / xmc.y, xlc.x / xlc.y);\n\n    if (Root.x < Root.y && Root.x < Root.z)\n        Root.xyz = Root.yxz;\n    else if (Root.z < Root.x && Root.z < Root.y)\n        Root.xyz = Root.xzy;\n\n    return Root;\n}\n\nfloat LTC_EvaluateDisk(vec3 N, vec3 V, vec3 P, mat3 Minv, Coords points)\n{\n    // construct orthonormal basis around N\n    vec3 T1, T2;\n    T1 = normalize(V - N * dot(V, N));\n    T2 = cross(N, T1);\n\n    // rotate area light in (T1, T2, N) basis\n    //mat3 R = transpose(mat3(T1, T2, N));\n    mat3 R = transposeMat3( mat3( T1, T2, N ) );\n    // polygon (allocate 5 vertices for clipping)\n    vec3 L_[ 3 ];\n    L_[ 0 ] = R * ( points.coord0 - P );\n    L_[ 1 ] = R * ( points.coord1 - P );\n    L_[ 2 ] = R * ( points.coord2 - P );\n\n    vec3 Lo_i = vec3(0);\n\n    // init ellipse\n    vec3 C  = 0.5 * (L_[0] + L_[2]);\n    vec3 V1 = 0.5 * (L_[1] - L_[2]);\n    vec3 V2 = 0.5 * (L_[1] - L_[0]);\n\n    C  = Minv * C;\n    V1 = Minv * V1;\n    V2 = Minv * V2;\n\n    //if(dot(cross(V1, V2), C) > 0.0)\n    //    return 0.0;\n\n    // compute eigenvectors of ellipse\n    float a, b;\n    float d11 = dot(V1, V1);\n    float d22 = dot(V2, V2);\n    float d12 = dot(V1, V2);\n    if (abs(d12) / sqrt(d11 * d22) > 0.0001)\n    {\n        float tr = d11 + d22;\n        float det = -d12 * d12 + d11 * d22;\n\n        // use sqrt matrix to solve for eigenvalues\n        det = sqrt(det);\n        float u = 0.5 * sqrt(tr - 2.0 * det);\n        float v = 0.5 * sqrt(tr + 2.0 * det);\n        float e_max = (u + v) * (u + v);\n        float e_min = (u - v) * (u - v);\n\n        vec3 V1_, V2_;\n\n        if (d11 > d22)\n        {\n            V1_ = d12 * V1 + (e_max - d11) * V2;\n            V2_ = d12 * V1 + (e_min - d11) * V2;\n        }\n        else\n        {\n            V1_ = d12*V2 + (e_max - d22)*V1;\n            V2_ = d12*V2 + (e_min - d22)*V1;\n        }\n\n        a = 1.0 / e_max;\n        b = 1.0 / e_min;\n        V1 = normalize(V1_);\n        V2 = normalize(V2_);\n    }\n    else\n    {\n        a = 1.0 / dot(V1, V1);\n        b = 1.0 / dot(V2, V2);\n        V1 *= sqrt(a);\n        V2 *= sqrt(b);\n    }\n\n    vec3 V3 = cross(V1, V2);\n    if (dot(C, V3) < 0.0)\n        V3 *= -1.0;\n\n    float L  = dot(V3, C);\n    float x0 = dot(V1, C) / L;\n    float y0 = dot(V2, C) / L;\n\n    float E1 = inversesqrt(a);\n    float E2 = inversesqrt(b);\n\n    a *= L * L;\n    b *= L * L;\n\n    float c0 = a * b;\n    float c1 = a * b * (1.0 + x0 * x0 + y0 * y0) - a - b;\n    float c2 = 1.0 - a * (1.0 + x0 * x0) - b * (1.0 + y0 * y0);\n    float c3 = 1.0;\n\n    vec3 roots = SolveCubic(vec4(c0, c1, c2, c3));\n    float e1 = roots.x;\n    float e2 = roots.y;\n    float e3 = roots.z;\n\n    vec3 avgDir = vec3(a * x0 / (a - e2), b * y0 / (b - e2), 1.0);\n\n    mat3 rotate = mat3(V1, V2, V3);\n\n    avgDir = rotate * avgDir;\n    avgDir = normalize(avgDir);\n\n    float L1 = sqrt(-e2 / e3);\n    float L2 = sqrt(-e2 / e1);\n\n    float formFactor = L1 * L2 * inversesqrt((1.0 + L1 * L1) * (1.0 + L2 * L2));\n    \n    const float LUT_SIZE = 64.0;\n    const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n    const float LUT_BIAS = 0.5 / LUT_SIZE;\n\n    // use tabulated horizon-clipped sphere\n    vec2 uv = vec2(avgDir.z * 0.5 + 0.5, formFactor);\n    uv = uv*LUT_SCALE + LUT_BIAS;\n\n    float scale = texture2D( areaLightsLutTex2, uv ).w;\n\n    return formFactor*scale;\n}\n\nfloat getRectLightDiffuse() {\n    return LTC_EvaluateRect( dNormalW, dViewDirW, vPositionW, mat3( 1.0 ), dLTCCoords );\n}\n\nfloat getDiskLightDiffuse() {\n    return LTC_EvaluateDisk( dNormalW, dViewDirW, vPositionW, mat3( 1.0 ), dLTCCoords );\n}\n\nfloat getSphereLightDiffuse() {\n    // NB: this could be improved further with distance based wrap lighting\n    float falloff = dSphereRadius / (dot(dLightDirW, dLightDirW) + dSphereRadius);\n    return getLightDiffuse()*falloff;\n}\n\nmat3 getLTCLightInvMat(vec2 uv)\n{\n    vec4 t1 = texture2D( areaLightsLutTex1, uv );\n\n    #ifdef AREA_R8_G8_B8_A8_LUTS\n    t1 *= vec4(1.001, 0.3239, 0.60437568, 1.0);\n    t1 += vec4(0.0, -0.2976, -0.01381, 0.0);\n    #endif\n\n    return mat3(\n        vec3( t1.x, 0, t1.y ),\n        vec3(    0, 1,    0 ),\n        vec3( t1.z, 0, t1.w )\n    );\n}\n\nfloat calcRectLightSpecular(vec3 tNormalW, vec2 uv) {\n    mat3 mInv = getLTCLightInvMat(uv);\n    return LTC_EvaluateRect( tNormalW, dViewDirW, vPositionW, mInv, dLTCCoords );\n}\n\nfloat getRectLightSpecular() {\n    return calcRectLightSpecular(dNormalW, dLTCUV);\n}\n\n#ifdef LIT_CLEARCOAT\nfloat getRectLightSpecularCC() {\n    return calcRectLightSpecular(ccNormalW, ccLTCUV);\n}\n#endif\n\nfloat calcDiskLightSpecular(vec3 tNormalW, vec2 uv) {\n    mat3 mInv = getLTCLightInvMat(uv);\n    return LTC_EvaluateDisk( tNormalW, dViewDirW, vPositionW, mInv, dLTCCoords );\n}\n\nfloat getDiskLightSpecular() {\n    return calcDiskLightSpecular(dNormalW, dLTCUV);\n}\n\n#ifdef LIT_CLEARCOAT\nfloat getDiskLightSpecularCC() {\n    return calcDiskLightSpecular(ccNormalW, ccLTCUV);\n}\n#endif\n\nfloat getSphereLightSpecular() {\n    return calcDiskLightSpecular(dNormalW, dLTCUV);\n}\n\n#ifdef LIT_CLEARCOAT\nfloat getSphereLightSpecularCC() {\n    return calcDiskLightSpecular(ccNormalW, ccLTCUV);\n}\n#endif\n";

	var metalnessPS = "\n#ifdef MAPFLOAT\nuniform float material_metalness;\n#endif\n\n#ifdef MAPTEXTURE\nuniform sampler2D texture_metalnessMap;\n#endif\n\nvoid getMetalness() {\n    float metalness = 1.0;\n\n    #ifdef MAPFLOAT\n    metalness *= material_metalness;\n    #endif\n\n    #ifdef MAPTEXTURE\n    metalness *= texture2DBias(texture_metalnessMap, $UV, textureBias).$CH;\n    #endif\n\n    #ifdef MAPVERTEX\n    metalness *= saturate(vVertexColor.$VC);\n    #endif\n\n    dMetalness = metalness;\n}\n";

	var msdfPS = "\nuniform sampler2D texture_msdfMap;\n\n#ifdef GL_OES_standard_derivatives\n#define USE_FWIDTH\n#endif\n\n#ifdef GL2\n#define USE_FWIDTH\n#endif\n\nfloat median(float r, float g, float b) {\n    return max(min(r, g), min(max(r, g), b));\n}\n\nfloat map (float min, float max, float v) {\n    return (v - min) / (max - min);\n}\n\nuniform float font_sdfIntensity; // intensity is used to boost the value read from the SDF, 0 is no boost, 1.0 is max boost\nuniform float font_pxrange;      // the number of pixels between inside and outside the font in SDF\nuniform float font_textureWidth; // the width of the texture atlas\n\n#ifdef UNIFORM_TEXT_PARAMETERS\nuniform vec4 outline_color;\nuniform float outline_thickness;\nuniform vec4 shadow_color;\nuniform vec2 shadow_offset;\n#else\nvarying vec4 outline_color;\nvarying float outline_thickness;\nvarying vec4 shadow_color;\nvarying vec2 shadow_offset;\n#endif\n\nvec4 applyMsdf(vec4 color) {\n    // sample the field\n    vec3 tsample = texture2D(texture_msdfMap, vUv0).rgb;\n    vec2 uvShdw = vUv0 - shadow_offset;\n    vec3 ssample = texture2D(texture_msdfMap, uvShdw).rgb;\n    // get the signed distance value\n    float sigDist = median(tsample.r, tsample.g, tsample.b);\n    float sigDistShdw = median(ssample.r, ssample.g, ssample.b);\n\n    // smoothing limit - smaller value makes for sharper but more aliased text, especially on angles\n    // too large value (0.5) creates a dark glow around the letters\n    float smoothingMax = 0.2;\n\n    #ifdef USE_FWIDTH\n    // smoothing depends on size of texture on screen\n    vec2 w = fwidth(vUv0);\n    float smoothing = clamp(w.x * font_textureWidth / font_pxrange, 0.0, smoothingMax);\n    #else\n    float font_size = 16.0; // TODO fix this\n    // smoothing gets smaller as the font size gets bigger\n    // don't have fwidth we can approximate from font size, this doesn't account for scaling\n    // so a big font scaled down will be wrong...\n    float smoothing = clamp(font_pxrange / font_size, 0.0, smoothingMax);\n    #endif\n\n    float mapMin = 0.05;\n    float mapMax = clamp(1.0 - font_sdfIntensity, mapMin, 1.0);\n\n    // remap to a smaller range (used on smaller font sizes)\n    float sigDistInner = map(mapMin, mapMax, sigDist);\n    float sigDistOutline = map(mapMin, mapMax, sigDist + outline_thickness);\n    sigDistShdw = map(mapMin, mapMax, sigDistShdw + outline_thickness);\n\n    float center = 0.5;\n    // calculate smoothing and use to generate opacity\n    float inside = smoothstep(center-smoothing, center+smoothing, sigDistInner);\n    float outline = smoothstep(center-smoothing, center+smoothing, sigDistOutline);\n    float shadow = smoothstep(center-smoothing, center+smoothing, sigDistShdw);\n\n    vec4 tcolor = (outline > inside) ? outline * vec4(outline_color.a * outline_color.rgb, outline_color.a) : vec4(0.0);\n    tcolor = mix(tcolor, color, inside);\n\n    vec4 scolor = (shadow > outline) ? shadow * vec4(shadow_color.a * shadow_color.rgb, shadow_color.a) : tcolor;\n    tcolor = mix(scolor, tcolor, outline);\n    \n    return tcolor;\n}\n";

	var metalnessModulatePS = "\n\nuniform float material_f0;\n\nvoid getMetalnessModulate() {\n    vec3 dielectricF0 = material_f0 * dSpecularity;\n    dSpecularity = mix(dielectricF0, dAlbedo, dMetalness);\n    dAlbedo *= 1.0 - dMetalness;\n}\n";

	var msdfVS = "\nattribute vec3 vertex_outlineParameters;\nattribute vec3 vertex_shadowParameters;\n\nvarying vec4 outline_color;\nvarying float outline_thickness;\nvarying vec4 shadow_color;\nvarying vec2 shadow_offset;\n\nvoid unpackMsdfParams() {\n    outline_color.rb = mod(vertex_outlineParameters.xy, 256.) / 256.;\n    outline_color.ga = vertex_outlineParameters.xy / 256. / 256.;\n\n    // _outlineThicknessScale === 0.2\n    outline_thickness = vertex_outlineParameters.z / 255. * 0.2;\n\n    vec3 little = mod(vertex_shadowParameters, 256.) / 256.;\n    vec3 big = vertex_shadowParameters / 256. / 256.;\n\n    shadow_color.rb = little.xy;\n    shadow_color.ga = big.xy;\n\n    // vec2(little.z, big.z) * 2. srink from (0.5, 0.5) to (1, 1)\n    // _shadowOffsetScale === 0.005\n    shadow_offset = (vec2(little.z, big.z) * 2. - 1.) * 0.005;\n}\n";

	var normalVS = "\n#ifdef MORPHING_TEXTURE_BASED_NORMAL\nuniform highp sampler2D morphNormalTex;\n#endif\n\nvec3 getNormal() {\n    #ifdef SKIN\n    dNormalMatrix = mat3(dModelMatrix[0].xyz, dModelMatrix[1].xyz, dModelMatrix[2].xyz);\n    #elif defined(INSTANCING)\n    dNormalMatrix = mat3(instance_line1.xyz, instance_line2.xyz, instance_line3.xyz);\n    #else\n    dNormalMatrix = matrix_normal;\n    #endif\n\n    vec3 tempNormal = vertex_normal;\n\n    #ifdef MORPHING\n    #ifdef MORPHING_NRM03\n    tempNormal += morph_weights_a[0] * morph_nrm0;\n    tempNormal += morph_weights_a[1] * morph_nrm1;\n    tempNormal += morph_weights_a[2] * morph_nrm2;\n    tempNormal += morph_weights_a[3] * morph_nrm3;\n    #endif\n    #ifdef MORPHING_NRM47\n    tempNormal += morph_weights_b[0] * morph_nrm4;\n    tempNormal += morph_weights_b[1] * morph_nrm5;\n    tempNormal += morph_weights_b[2] * morph_nrm6;\n    tempNormal += morph_weights_b[3] * morph_nrm7;\n    #endif\n    #endif\n\n    #ifdef MORPHING_TEXTURE_BASED_NORMAL\n    // apply morph offset from texture\n    vec2 morphUV = getTextureMorphCoords();\n    vec3 morphNormal = texture2D(morphNormalTex, morphUV).xyz;\n    tempNormal += morphNormal;\n    #endif\n\n    return normalize(dNormalMatrix * tempNormal);\n}\n";

	var normalDetailMapPS = "\n#ifdef MAPTEXTURE\nuniform sampler2D texture_normalDetailMap;\nuniform float material_normalDetailMapBumpiness;\n\nvec3 blendNormals(vec3 n1, vec3 n2) {\n    // https://blog.selfshadow.com/publications/blending-in-detail/#detail-oriented\n    n1 += vec3(0, 0, 1);\n    n2 *= vec3(-1, -1, 1);\n    return n1 * dot(n1, n2) / n1.z - n2;\n}\n#endif\n\nvec3 addNormalDetail(vec3 normalMap) {\n#ifdef MAPTEXTURE\n    vec3 normalDetailMap = unpackNormal(texture2DBias(texture_normalDetailMap, $UV, textureBias));\n    normalDetailMap = mix(vec3(0.0, 0.0, 1.0), normalDetailMap, material_normalDetailMapBumpiness);\n    return blendNormals(normalMap, normalDetailMap);\n#else\n    return normalMap;\n#endif\n}\n";

	var normalInstancedVS = "\nvec3 getNormal() {\n    dNormalMatrix = mat3(instance_line1.xyz, instance_line2.xyz, instance_line3.xyz);\n    return normalize(dNormalMatrix * vertex_normal);\n}\n";

	var normalMapPS = "\n#ifdef MAPTEXTURE\nuniform sampler2D texture_normalMap;\nuniform float material_bumpiness;\n#endif\n\nvoid getNormal() {\n#ifdef MAPTEXTURE\n    vec3 normalMap = unpackNormal(texture2DBias(texture_normalMap, $UV, textureBias));\n    normalMap = mix(vec3(0.0, 0.0, 1.0), normalMap, material_bumpiness);\n    dNormalW = normalize(dTBN * addNormalDetail(normalMap));\n#else\n    dNormalW = dVertexNormalW;\n#endif\n}\n";

	var normalSkinnedVS = "\nvec3 getNormal() {\n    dNormalMatrix = mat3(dModelMatrix[0].xyz, dModelMatrix[1].xyz, dModelMatrix[2].xyz);\n    return normalize(dNormalMatrix * vertex_normal);\n}\n";

	var normalXYPS = "\nvec3 unpackNormal(vec4 nmap) {\n    vec3 normal;\n    normal.xy = nmap.wy * 2.0 - 1.0;\n    normal.z = sqrt(1.0 - saturate(dot(normal.xy, normal.xy)));\n    return normal;\n}\n";

	var normalXYZPS = "\nvec3 unpackNormal(vec4 nmap) {\n    return nmap.xyz * 2.0 - 1.0;\n}\n";

	var opacityPS = "\n#ifdef MAPFLOAT\nuniform float material_opacity;\n#endif\n\n#ifdef MAPTEXTURE\nuniform sampler2D texture_opacityMap;\n#endif\n\nvoid getOpacity() {\n    dAlpha = 1.0;\n\n    #ifdef MAPFLOAT\n    dAlpha *= material_opacity;\n    #endif\n\n    #ifdef MAPTEXTURE\n    dAlpha *= texture2DBias(texture_opacityMap, $UV, textureBias).$CH;\n    #endif\n\n    #ifdef MAPVERTEX\n    dAlpha *= clamp(vVertexColor.$VC, 0.0, 1.0);\n    #endif\n}\n";

	var outputAlphaPS = "\ngl_FragColor.a = dAlpha;\n";

	var outputAlphaOpaquePS = "\n    gl_FragColor.a = 1.0;\n";

	var outputAlphaPremulPS = "\ngl_FragColor.rgb *= dAlpha;\ngl_FragColor.a = dAlpha;\n";

	var outputTex2DPS = "\nvarying vec2 vUv0;\n\nuniform sampler2D source;\n\nvoid main(void) {\n    gl_FragColor = texture2D(source, vUv0);\n}\n";

	var packDepthPS = "\n// Packing a float in GLSL with multiplication and mod\n// http://blog.gradientstudios.com/2012/08/23/shadow-map-improvement\nvec4 packFloat(float depth) {\n    const vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);\n    const vec4 bit_mask  = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\n\n    // combination of mod and multiplication and division works better\n    vec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);\n    res -= res.xxyz * bit_mask;\n    return res;\n}\n";

	var sheenPS = "\n\n#ifdef MAPCOLOR\nuniform vec3 material_sheen;\n#endif\n\n#ifdef MAPTEXTURE\nuniform sampler2D texture_sheenMap;\n#endif\n\nvoid getSheen() {\n    vec3 sheenColor = vec3(1, 1, 1);\n\n    #ifdef MAPCOLOR\n    sheenColor *= material_sheen;\n    #endif\n\n    #ifdef MAPTEXTURE\n    sheenColor *= $DECODE(texture2DBias(texture_sheenMap, $UV, textureBias)).$CH;\n    #endif\n\n    #ifdef MAPVERTEX\n    sheenColor *= saturate(vVertexColor.$VC);\n    #endif\n\n    sSpecularity = sheenColor;\n}\n";

	var sheenGlossPS = "\n#ifdef MAPFLOAT\nuniform float material_sheenGlossiness;\n#endif\n\n#ifdef MAPTEXTURE\nuniform sampler2D texture_sheenGlossinessMap;\n#endif\n\nvoid getSheenGlossiness() {\n    float sheenGlossiness = 1.0;\n\n    #ifdef MAPFLOAT\n    sheenGlossiness *= material_sheenGlossiness;\n    #endif\n\n    #ifdef MAPTEXTURE\n    sheenGlossiness *= texture2DBias(texture_sheenGlossinessMap, $UV, textureBias).$CH;\n    #endif\n\n    #ifdef MAPVERTEX\n    sheenGlossiness *= saturate(vVertexColor.$VC);\n    #endif\n\n    sheenGlossiness += 0.0000001;\n    sGlossiness = sheenGlossiness;\n}\n";

	var parallaxPS = "\nuniform sampler2D texture_heightMap;\nuniform float material_heightMapFactor;\n\nvoid getParallax() {\n    float parallaxScale = material_heightMapFactor;\n\n    float height = texture2DBias(texture_heightMap, $UV, textureBias).$CH;\n    height = height * parallaxScale - parallaxScale*0.5;\n    vec3 viewDirT = dViewDirW * dTBN;\n\n    viewDirT.z += 0.42;\n    dUvOffset = height * (viewDirT.xy / viewDirT.z);\n}\n";

	var particlePS = "\nvarying vec4 texCoordsAlphaLife;\n\nuniform sampler2D colorMap;\nuniform sampler2D colorParam;\nuniform float graphSampleSize;\nuniform float graphNumSamples;\n\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params;\n#endif\n\nuniform float softening;\nuniform float colorMult;\n\nfloat saturate(float x) {\n    return clamp(x, 0.0, 1.0);\n}\n\n#ifndef UNPACKFLOAT\n#define UNPACKFLOAT\nfloat unpackFloat(vec4 rgbaDepth) {\n    const vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n    float depth = dot(rgbaDepth, bitShift);\n    return depth;\n}\n#endif\n\nvoid main(void) {\n    vec4 tex  = gammaCorrectInput(texture2D(colorMap, vec2(texCoordsAlphaLife.x, 1.0 - texCoordsAlphaLife.y)));\n    vec4 ramp = gammaCorrectInput(texture2D(colorParam, vec2(texCoordsAlphaLife.w, 0.0)));\n    ramp.rgb *= colorMult;\n\n    ramp.a += texCoordsAlphaLife.z;\n\n    vec3 rgb = tex.rgb * ramp.rgb;\n    float a  = tex.a * ramp.a;\n";

	var particleVS = "\nvec3 unpack3NFloats(float src) {\n    float r = fract(src);\n    float g = fract(src * 256.0);\n    float b = fract(src * 65536.0);\n    return vec3(r, g, b);\n}\n\nfloat saturate(float x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nvec4 tex1Dlod_lerp(highp sampler2D tex, vec2 tc) {\n    return mix( texture2D(tex,tc), texture2D(tex,tc + graphSampleSize), fract(tc.x*graphNumSamples) );\n}\n\nvec4 tex1Dlod_lerp(highp sampler2D tex, vec2 tc, out vec3 w) {\n    vec4 a = texture2D(tex,tc);\n    vec4 b = texture2D(tex,tc + graphSampleSize);\n    float c = fract(tc.x*graphNumSamples);\n\n    vec3 unpackedA = unpack3NFloats(a.w);\n    vec3 unpackedB = unpack3NFloats(b.w);\n    w = mix(unpackedA, unpackedB, c);\n\n    return mix(a, b, c);\n}\n\nvec2 rotate(vec2 quadXY, float pRotation, out mat2 rotMatrix) {\n    float c = cos(pRotation);\n    float s = sin(pRotation);\n\n    mat2 m = mat2(c, -s, s, c);\n    rotMatrix = m;\n\n    return m * quadXY;\n}\n\nvec3 billboard(vec3 InstanceCoords, vec2 quadXY) {\n    #ifdef SCREEN_SPACE\n        vec3 pos = vec3(-1, 0, 0) * quadXY.x + vec3(0, -1, 0) * quadXY.y;\n    #else\n        vec3 pos = -matrix_viewInverse[0].xyz * quadXY.x + -matrix_viewInverse[1].xyz * quadXY.y;\n    #endif\n\n    return pos;\n}\n\nvec3 customFace(vec3 InstanceCoords, vec2 quadXY) {\n    vec3 pos = faceTangent * quadXY.x + faceBinorm * quadXY.y;\n    return pos;\n}\n\nvec2 safeNormalize(vec2 v) {\n    float l = length(v);\n    return (l > 1e-06) ? v / l : v;\n}\n\nvoid main(void) {\n    vec3 meshLocalPos = particle_vertexData.xyz;\n    float id = floor(particle_vertexData.w);\n\n    float rndFactor = fract(sin(id + 1.0 + seed));\n    vec3 rndFactor3 = vec3(rndFactor, fract(rndFactor*10.0), fract(rndFactor*100.0));\n\n    float uv = id / numParticlesPot;\n    readInput(uv);\n\n#ifdef LOCAL_SPACE\n    inVel = mat3(matrix_model) * inVel;\n#endif\n    vec2 velocityV = safeNormalize((mat3(matrix_view) * inVel).xy); // should be removed by compiler if align/stretch is not used\n\n    float particleLifetime = lifetime;\n\n    if (inLife <= 0.0 || inLife > particleLifetime || !inShow) meshLocalPos = vec3(0.0);\n    vec2 quadXY = meshLocalPos.xy;\n    float nlife = clamp(inLife / particleLifetime, 0.0, 1.0);\n\n    vec3 paramDiv;\n    vec4 params = tex1Dlod_lerp(internalTex2, vec2(nlife, 0), paramDiv);\n    float scale = params.y;\n    float scaleDiv = paramDiv.x;\n    float alphaDiv = paramDiv.z;\n\n    scale += (scaleDiv * 2.0 - 1.0) * scaleDivMult * fract(rndFactor*10000.0);\n\n#ifndef USE_MESH\n    texCoordsAlphaLife = vec4(quadXY * -0.5 + 0.5, (alphaDiv * 2.0 - 1.0) * alphaDivMult * fract(rndFactor*1000.0), nlife);\n#else\n    texCoordsAlphaLife = vec4(particle_uv, (alphaDiv * 2.0 - 1.0) * alphaDivMult * fract(rndFactor*1000.0), nlife);\n#endif\n\n    vec3 particlePos = inPos;\n    vec3 particlePosMoved = vec3(0.0);\n\n    mat2 rotMatrix;\n";

	var particleAnimFrameClampVS = "\n    float animFrame = min(floor(texCoordsAlphaLife.w * animTexParams.y) + animTexParams.x, animTexParams.z);\n";

	var particleAnimFrameLoopVS = "\n    float animFrame = floor(mod(texCoordsAlphaLife.w * animTexParams.y + animTexParams.x, animTexParams.z + 1.0));\n";

	var particleAnimTexVS = "\n    float animationIndex;\n\n    if (animTexIndexParams.y == 1.0) {\n        animationIndex = floor((animTexParams.w + 1.0) * rndFactor3.z) * (animTexParams.z + 1.0);\n    } else {\n        animationIndex = animTexIndexParams.x * (animTexParams.z + 1.0);\n    }\n\n    float atlasX = (animationIndex + animFrame) * animTexTilesParams.x;\n    float atlasY = 1.0 - floor(atlasX + 1.0) * animTexTilesParams.y;\n    atlasX = fract(atlasX);\n\n    texCoordsAlphaLife.xy *= animTexTilesParams.xy;\n    texCoordsAlphaLife.xy += vec2(atlasX, atlasY);\n";

	var particleInputFloatPS = "\nvoid readInput(float uv) {\n    vec4 tex = texture2D(particleTexIN, vec2(uv, 0.25));\n    vec4 tex2 = texture2D(particleTexIN, vec2(uv, 0.75));\n\n    inPos = tex.xyz;\n    inVel = tex2.xyz;\n    inAngle = (tex.w < 0.0? -tex.w : tex.w) - 1000.0;\n    inShow = tex.w >= 0.0;\n    inLife = tex2.w;\n}\n";

	var particleInputRgba8PS = "\n//RG=X, BA=Y\n//RG=Z, BA=A\n//RGB=V, A=visMode\n//RGBA=life\n\n#define PI2 6.283185307179586\n\nuniform vec3 inBoundsSize;\nuniform vec3 inBoundsCenter;\n\nuniform float maxVel;\n\nfloat decodeFloatRG(vec2 rg) {\n    return rg.y*(1.0/255.0) + rg.x;\n}\n\nfloat decodeFloatRGBA( vec4 rgba ) {\n  return dot( rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/160581375.0) );\n}\n\nvoid readInput(float uv) {\n    vec4 tex0 = texture2D(particleTexIN, vec2(uv, 0.125));\n    vec4 tex1 = texture2D(particleTexIN, vec2(uv, 0.375));\n    vec4 tex2 = texture2D(particleTexIN, vec2(uv, 0.625));\n    vec4 tex3 = texture2D(particleTexIN, vec2(uv, 0.875));\n\n    inPos = vec3(decodeFloatRG(tex0.rg), decodeFloatRG(tex0.ba), decodeFloatRG(tex1.rg));\n    inPos = (inPos - vec3(0.5)) * inBoundsSize + inBoundsCenter;\n\n    inVel = tex2.xyz;\n    inVel = (inVel - vec3(0.5)) * maxVel;\n\n    inAngle = decodeFloatRG(tex1.ba) * PI2;\n    inShow = tex2.a > 0.5;\n\n    inLife = decodeFloatRGBA(tex3);\n    float maxNegLife = max(lifetime, (numParticles - 1.0) * (rate+rateDiv));\n    float maxPosLife = lifetime+1.0;\n    inLife = inLife * (maxNegLife + maxPosLife) - maxNegLife;\n}\n";

	var particleOutputFloatPS = "\nvoid writeOutput() {\n    if (gl_FragCoord.y<1.0) {\n        gl_FragColor = vec4(outPos, (outAngle + 1000.0) * visMode);\n    } else {\n        gl_FragColor = vec4(outVel, outLife);\n    }\n}\n";

	var particleOutputRgba8PS = "\nuniform vec3 outBoundsMul;\nuniform vec3 outBoundsAdd;\n\nvec2 encodeFloatRG( float v ) {\n    vec2 enc = vec2(1.0, 255.0) * v;\n    enc = fract(enc);\n    enc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\n    return enc;\n}\n\nvec4 encodeFloatRGBA( float v ) {\n    vec4 enc = vec4(1.0, 255.0, 65025.0, 160581375.0) * v;\n    enc = fract(enc);\n    enc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);\n    return enc;\n}\n\nvoid writeOutput() {\n    outPos = outPos * outBoundsMul + outBoundsAdd;\n    outAngle = fract(outAngle / PI2);\n\n    outVel = (outVel / maxVel) + vec3(0.5); // TODO: mul\n\n    float maxNegLife = max(lifetime, (numParticles - 1.0) * (rate+rateDiv));\n    float maxPosLife = lifetime+1.0;\n    outLife = (outLife + maxNegLife) / (maxNegLife + maxPosLife);\n\n    if (gl_FragCoord.y < 1.0) {\n        gl_FragColor = vec4(encodeFloatRG(outPos.x), encodeFloatRG(outPos.y));\n    } else if (gl_FragCoord.y < 2.0) {\n        gl_FragColor = vec4(encodeFloatRG(outPos.z), encodeFloatRG(outAngle));\n    } else if (gl_FragCoord.y < 3.0) {\n        gl_FragColor = vec4(outVel, visMode*0.5+0.5);\n    } else {\n        gl_FragColor = encodeFloatRGBA(outLife);\n    }\n}\n";

	var particleUpdaterAABBPS = "\nuniform mat3 spawnBounds;\nuniform vec3 spawnPosInnerRatio;\n\nvec3 calcSpawnPosition(vec3 inBounds, float rndFactor) {\n    vec3 pos = inBounds - vec3(0.5);\n\n    vec3 posAbs = abs(pos);\n    vec3 maxPos = vec3(max(posAbs.x, max(posAbs.y, posAbs.z)));\n\n    vec3 edge = maxPos + (vec3(0.5) - maxPos) * spawnPosInnerRatio;\n\n    pos.x = edge.x * (maxPos.x == posAbs.x ? sign(pos.x) : 2.0 * pos.x);\n    pos.y = edge.y * (maxPos.y == posAbs.y ? sign(pos.y) : 2.0 * pos.y);\n    pos.z = edge.z * (maxPos.z == posAbs.z ? sign(pos.z) : 2.0 * pos.z);\n\n#ifndef LOCAL_SPACE\n    return emitterPos + spawnBounds * pos;\n#else\n    return spawnBounds * pos;\n#endif\n}\n\nvoid addInitialVelocity(inout vec3 localVelocity, vec3 inBounds) {\n    localVelocity -= vec3(0, 0, initialVelocity);\n}\n";

	var particleUpdaterEndPS = "\n    writeOutput();\n}\n";

	var particleUpdaterInitPS = "\nvarying vec2 vUv0;\n\nuniform highp sampler2D particleTexIN;\nuniform highp sampler2D internalTex0;\nuniform highp sampler2D internalTex1;\nuniform highp sampler2D internalTex2;\nuniform highp sampler2D internalTex3;\n\nuniform mat3 emitterMatrix, emitterMatrixInv;\nuniform vec3 emitterScale;\n\nuniform vec3 emitterPos, frameRandom, localVelocityDivMult, velocityDivMult;\nuniform float delta, rate, rateDiv, lifetime, numParticles, rotSpeedDivMult, radialSpeedDivMult, seed;\nuniform float startAngle, startAngle2;\nuniform float initialVelocity;\n\nuniform float graphSampleSize;\nuniform float graphNumSamples;\n\nvec3 inPos;\nvec3 inVel;\nfloat inAngle;\nbool inShow;\nfloat inLife;\nfloat visMode;\n\nvec3 outPos;\nvec3 outVel;\nfloat outAngle;\nbool outShow;\nfloat outLife;\n";

	var particleUpdaterNoRespawnPS = "\n    if (outLife >= lifetime) {\n        outLife -= max(lifetime, (numParticles - 1.0) * particleRate);\n        visMode = -1.0;\n    }\n";

	var particleUpdaterOnStopPS = "\n    visMode = outLife < 0.0? -1.0: visMode;\n";

	var particleUpdaterRespawnPS = "\n    if (outLife >= lifetime) {\n        outLife -= max(lifetime, (numParticles - 1.0) * particleRate);\n        visMode = 1.0;\n    }\n    visMode = outLife < 0.0? 1.0: visMode;\n";

	var particleUpdaterSpherePS = "\nuniform float spawnBoundsSphere;\nuniform float spawnBoundsSphereInnerRatio;\n\nvec3 calcSpawnPosition(vec3 inBounds, float rndFactor) {\n    float rnd4 = fract(rndFactor * 1000.0);\n    vec3 norm = normalize(inBounds.xyz - vec3(0.5));\n    float r = rnd4 * (1.0 - spawnBoundsSphereInnerRatio) + spawnBoundsSphereInnerRatio;\n#ifndef LOCAL_SPACE\n    return emitterPos + norm * r * spawnBoundsSphere;\n#else\n    return norm * r * spawnBoundsSphere;\n#endif\n}\n\nvoid addInitialVelocity(inout vec3 localVelocity, vec3 inBounds) {\n    localVelocity += normalize(inBounds - vec3(0.5)) * initialVelocity;\n}\n";

	var particleUpdaterStartPS = "\nfloat saturate(float x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nvec3 unpack3NFloats(float src) {\n    float r = fract(src);\n    float g = fract(src * 256.0);\n    float b = fract(src * 65536.0);\n    return vec3(r, g, b);\n}\n\nvec3 tex1Dlod_lerp(highp sampler2D tex, vec2 tc, out vec3 w) {\n    vec4 a = texture2D(tex, tc);\n    vec4 b = texture2D(tex, tc + graphSampleSize);\n    float c = fract(tc.x * graphNumSamples);\n\n    vec3 unpackedA = unpack3NFloats(a.w);\n    vec3 unpackedB = unpack3NFloats(b.w);\n    w = mix(unpackedA, unpackedB, c);\n\n    return mix(a.xyz, b.xyz, c);\n}\n\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\nvec4 hash41(float p) {\n    vec4 p4 = fract(vec4(p) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract(vec4((p4.x + p4.y)*p4.z, (p4.x + p4.z)*p4.y, (p4.y + p4.z)*p4.w, (p4.z + p4.w)*p4.x));\n}\n\nvoid main(void) {\n    if (gl_FragCoord.x > numParticles) discard;\n\n    readInput(vUv0.x);\n    visMode = inShow? 1.0 : -1.0;\n\n    vec4 rndFactor = hash41(gl_FragCoord.x + seed);\n\n    float particleRate = rate + rateDiv * rndFactor.x;\n\n    outLife = inLife + delta;\n    float nlife = clamp(outLife / lifetime, 0.0, 1.0);\n\n    vec3 localVelocityDiv;\n    vec3 velocityDiv;\n    vec3 paramDiv;\n    vec3 localVelocity = tex1Dlod_lerp(internalTex0, vec2(nlife, 0), localVelocityDiv);\n    vec3 velocity =      tex1Dlod_lerp(internalTex1, vec2(nlife, 0), velocityDiv);\n    vec3 params =        tex1Dlod_lerp(internalTex2, vec2(nlife, 0), paramDiv);\n    float rotSpeed = params.x;\n    float rotSpeedDiv = paramDiv.y;\n\n    vec3 radialParams = tex1Dlod_lerp(internalTex3, vec2(nlife, 0), paramDiv);\n    float radialSpeed = radialParams.x;\n    float radialSpeedDiv = radialParams.y;\n\n    bool respawn = inLife <= 0.0 || outLife >= lifetime;\n    inPos = respawn ? calcSpawnPosition(rndFactor.xyz, rndFactor.x) : inPos;\n    inAngle = respawn ? mix(startAngle, startAngle2, rndFactor.x) : inAngle;\n\n#ifndef LOCAL_SPACE\n    vec3 radialVel = inPos - emitterPos;\n#else\n    vec3 radialVel = inPos;\n#endif\n    radialVel = (dot(radialVel, radialVel) > 1.0E-8) ? radialSpeed * normalize(radialVel) : vec3(0.0);\n    radialVel += (radialSpeedDiv * vec3(2.0) - vec3(1.0)) * radialSpeedDivMult * rndFactor.xyz;\n\n    localVelocity +=    (localVelocityDiv * vec3(2.0) - vec3(1.0)) * localVelocityDivMult * rndFactor.xyz;\n    velocity +=         (velocityDiv * vec3(2.0) - vec3(1.0)) * velocityDivMult * rndFactor.xyz;\n    rotSpeed +=         (rotSpeedDiv * 2.0 - 1.0) * rotSpeedDivMult * rndFactor.y;\n\n    addInitialVelocity(localVelocity, rndFactor.xyz);\n\n#ifndef LOCAL_SPACE\n    outVel = emitterMatrix * localVelocity + (radialVel + velocity) * emitterScale;\n#else\n    outVel = (localVelocity + radialVel) / emitterScale + emitterMatrixInv * velocity;\n#endif\n\n    outPos = inPos + outVel * delta;\n    outAngle = inAngle + rotSpeed * delta;\n";

	var particle_billboardVS = "\n    quadXY = rotate(quadXY, inAngle, rotMatrix);\n    vec3 localPos = billboard(particlePos, quadXY);\n";

	var particle_blendAddPS = "\n    dBlendModeFogFactor = 0.0;\n    rgb *= saturate(gammaCorrectInput(max(a, 0.0)));\n    if ((rgb.r + rgb.g + rgb.b) < 0.000001) discard;\n";

	var particle_blendMultiplyPS = "\n    rgb = mix(vec3(1.0), rgb, vec3(a));\n    if (rgb.r + rgb.g + rgb.b > 2.99) discard;\n";

	var particle_blendNormalPS = "\n    if (a < 0.01) discard;\n";

	var particle_cpuVS = "\nattribute vec4 particle_vertexData;   // XYZ = world pos, W = life\nattribute vec4 particle_vertexData2;  // X = angle, Y = scale, Z = alpha, W = velocity.x\nattribute vec4 particle_vertexData3;  // XYZ = particle local pos, W = velocity.y\nattribute float particle_vertexData4; // particle id\n#ifndef USE_MESH\n#define VDATA5TYPE vec2\n#else\n#define VDATA5TYPE vec4\n#endif\nattribute VDATA5TYPE particle_vertexData5; // VDATA4TYPE depends on useMesh property. Start with X = velocity.z, Y = particle ID and for mesh particles proceeds with Z = mesh UV.x, W = mesh UV.y\n\nuniform mat4 matrix_viewProjection;\nuniform mat4 matrix_model;\n\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\n\nuniform mat3 matrix_normal;\nuniform mat4 matrix_viewInverse;\n\nuniform float numParticles;\nuniform float lifetime;\nuniform float stretch;\nuniform float seed;\nuniform vec3 wrapBounds, emitterScale, faceTangent, faceBinorm;\nuniform sampler2D texLifeAndSourcePosOUT;\nuniform highp sampler2D internalTex0;\nuniform highp sampler2D internalTex1;\nuniform highp sampler2D internalTex2;\nuniform vec3 emitterPos;\n\nvarying vec4 texCoordsAlphaLife;\n\nvec2 rotate(vec2 quadXY, float pRotation, out mat2 rotMatrix)\n{\n    float c = cos(pRotation);\n    float s = sin(pRotation);\n    //vec4 rotationMatrix = vec4(c, -s, s, c);\n\n    mat2 m = mat2(c, -s, s, c);\n    rotMatrix = m;\n\n    return m * quadXY;\n}\n\nvec3 billboard(vec3 InstanceCoords, vec2 quadXY)\n{\n    vec3 pos = -matrix_viewInverse[0].xyz * quadXY.x + -matrix_viewInverse[1].xyz * quadXY.y;\n    return pos;\n}\n\nvec3 customFace(vec3 InstanceCoords, vec2 quadXY)\n{\n    vec3 pos = faceTangent * quadXY.x + faceBinorm * quadXY.y;\n    return pos;\n}\n\nvoid main(void)\n{\n    vec3 particlePos = particle_vertexData.xyz;\n    vec3 inPos = particlePos;\n    vec3 vertPos = particle_vertexData3.xyz;\n    vec3 inVel = vec3(particle_vertexData2.w, particle_vertexData3.w, particle_vertexData5.x);\n\n    float id = floor(particle_vertexData4);\n    float rndFactor = fract(sin(id + 1.0 + seed));\n    vec3 rndFactor3 = vec3(rndFactor, fract(rndFactor*10.0), fract(rndFactor*100.0));\n\n#ifdef LOCAL_SPACE\n    inVel = mat3(matrix_model) * inVel;\n#endif\n    vec2 velocityV = normalize((mat3(matrix_view) * inVel).xy); // should be removed by compiler if align/stretch is not used\n\n    vec2 quadXY = vertPos.xy;\n\n#ifdef USE_MESH\n    texCoordsAlphaLife = vec4(particle_vertexData5.zw, particle_vertexData2.z, particle_vertexData.w);\n#else\n    texCoordsAlphaLife = vec4(quadXY * -0.5 + 0.5, particle_vertexData2.z, particle_vertexData.w);\n#endif\n    mat2 rotMatrix;\n\n    float inAngle = particle_vertexData2.x;\n    vec3 particlePosMoved = vec3(0.0);\n    vec3 meshLocalPos = particle_vertexData3.xyz;\n";

	var particle_cpu_endVS = "\n    localPos *= particle_vertexData2.y * emitterScale;\n    localPos += particlePos;\n\n    gl_Position = matrix_viewProjection * vec4(localPos, 1.0);\n";

	var particle_customFaceVS = "\n    quadXY = rotate(quadXY, inAngle, rotMatrix);\n    vec3 localPos = customFace(particlePos, quadXY);\n";

	var particle_endPS = "\n    rgb = addFog(rgb);\n    rgb = toneMap(rgb);\n    rgb = gammaCorrectOutput(rgb);\n    gl_FragColor = vec4(rgb, a);\n}\n";

	var particle_endVS = "\n    localPos *= scale * emitterScale;\n    localPos += particlePos;\n\n    #ifdef SCREEN_SPACE\n    gl_Position = vec4(localPos.x, localPos.y, 0.0, 1.0);\n    #else\n    gl_Position = matrix_viewProjection * vec4(localPos.xyz, 1.0);\n    #endif\n";

	var particle_halflambertPS = "\n    vec3 negNormal = normal*0.5+0.5;\n    vec3 posNormal = -normal*0.5+0.5;\n    negNormal *= negNormal;\n    posNormal *= posNormal;\n";

	var particle_initVS = "\nattribute vec4 particle_vertexData; // XYZ = particle position, W = particle ID + random factor\n#ifdef USE_MESH\nattribute vec2 particle_uv;         // mesh UV\n#endif\n\nuniform mat4 matrix_viewProjection;\nuniform mat4 matrix_model;\nuniform mat3 matrix_normal;\nuniform mat4 matrix_viewInverse;\n\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\n\nuniform float numParticles, numParticlesPot;\nuniform float graphSampleSize;\nuniform float graphNumSamples;\nuniform float stretch;\nuniform vec3 wrapBounds;\nuniform vec3 emitterScale, emitterPos, faceTangent, faceBinorm;\nuniform float rate, rateDiv, lifetime, deltaRandomnessStatic, scaleDivMult, alphaDivMult, seed, delta;\nuniform sampler2D particleTexOUT, particleTexIN;\nuniform highp sampler2D internalTex0;\nuniform highp sampler2D internalTex1;\nuniform highp sampler2D internalTex2;\n\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params;\n#endif\n\nvarying vec4 texCoordsAlphaLife;\n\nvec3 inPos;\nvec3 inVel;\nfloat inAngle;\nbool inShow;\nfloat inLife;\n";

	var particle_lambertPS = "\n    vec3 negNormal = max(normal, vec3(0.0));\n    vec3 posNormal = max(-normal, vec3(0.0));\n";

	var particle_lightingPS = "\n    vec3 light = negNormal.x*lightCube[0] + posNormal.x*lightCube[1] +\n                        negNormal.y*lightCube[2] + posNormal.y*lightCube[3] +\n                        negNormal.z*lightCube[4] + posNormal.z*lightCube[5];\n\n    rgb *= light;\n";

	var particle_localShiftVS = "\n    particlePos = (matrix_model * vec4(particlePos, 1.0)).xyz;\n";

	var particle_meshVS = "\n    vec3 localPos = meshLocalPos;\n    localPos.xy = rotate(localPos.xy, inAngle, rotMatrix);\n    localPos.yz = rotate(localPos.yz, inAngle, rotMatrix);\n\n    billboard(particlePos, quadXY);\n";

	var particle_normalVS = "\n    Normal = normalize(localPos + matrix_viewInverse[2].xyz);\n";

	var particle_normalMapPS = "\n    vec3 normalMap = normalize(texture2D(normalMap, vec2(texCoordsAlphaLife.x, 1.0 - texCoordsAlphaLife.y)).xyz * 2.0 - 1.0);\n    vec3 normal = ParticleMat * normalMap;\n";

	var particle_pointAlongVS = "\n    inAngle = atan(velocityV.x, velocityV.y); // not the fastest way, but easier to plug in; TODO: create rot matrix right from vectors\n\n";

	var particle_softPS = "\n    float depth = getLinearScreenDepth();\n    float particleDepth = vDepth;\n    float depthDiff = saturate(abs(particleDepth - depth) * softening);\n    a *= depthDiff;\n";

	var particle_softVS = "\n    vDepth = getLinearDepth(localPos);\n";

	var particle_stretchVS = "\n    vec3 moveDir = inVel * stretch;\n    vec3 posPrev = particlePos - moveDir;\n    posPrev += particlePosMoved;\n\n    vec2 centerToVertexV = normalize((mat3(matrix_view) * localPos).xy);\n\n    float interpolation = dot(-velocityV, centerToVertexV) * 0.5 + 0.5;\n\n    particlePos = mix(particlePos, posPrev, interpolation);\n";

	var particle_TBNVS = "\n    mat3 rot3 = mat3(rotMatrix[0][0], rotMatrix[0][1], 0.0, rotMatrix[1][0], rotMatrix[1][1], 0.0, 0.0, 0.0, 1.0);\n    ParticleMat = mat3(-matrix_viewInverse[0].xyz, -matrix_viewInverse[1].xyz, matrix_viewInverse[2].xyz) * rot3;\n";

	var particle_wrapVS = "\n    vec3 origParticlePos = particlePos;\n    particlePos -= matrix_model[3].xyz;\n    particlePos = mod(particlePos, wrapBounds) - wrapBounds * 0.5;\n    particlePos += matrix_model[3].xyz;\n    particlePosMoved = particlePos - origParticlePos;\n";

	var precisionTestPS = "\nvoid main(void) {\n    gl_FragColor = vec4(2147483648.0);\n}\n";

	var precisionTest2PS = "\nuniform sampler2D source;\n\nvec4 packFloat(float depth) {\n    const vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);\n    const vec4 bit_mask  = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\n\n    vec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);\n    res -= res.xxyz * bit_mask;\n    return res;\n}\n\nvoid main(void) {\n    float c = texture2D(source, vec2(0.0)).r;\n    float diff = abs(c - 2147483648.0) / 2147483648.0;\n    gl_FragColor = packFloat(diff);\n}\n";

	var reflDirPS = "\nvoid getReflDir() {\n    dReflDirW = normalize(-reflect(dViewDirW, dNormalW));\n}\n";

	var reflDirAnisoPS = "\nvoid getReflDir() {\n    float roughness = sqrt(1.0 - min(dGlossiness, 1.0));\n    float anisotropy = material_anisotropy * roughness;\n    vec3 anisotropicDirection = anisotropy >= 0.0 ? dTBN[1] : dTBN[0];\n    vec3 anisotropicTangent = cross(anisotropicDirection, dViewDirW);\n    vec3 anisotropicNormal = cross(anisotropicTangent, anisotropicDirection);\n    vec3 bentNormal = normalize(mix(normalize(dNormalW), normalize(anisotropicNormal), anisotropy));\n    dReflDirW = reflect(-dViewDirW, bentNormal);\n}\n";

	var reflectionCCPS = "\n#ifdef LIT_CLEARCOAT\nuniform float material_clearCoatReflectivity;\n\nvoid addReflectionCC() {\n    ccReflection += vec4(calcReflection(ccReflDirW, ccGlossiness), material_clearCoatReflectivity);\n}\n#endif\n";

	var reflectionCubePS = "\nuniform samplerCube texture_cubeMap;\nuniform float material_reflectivity;\n\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\n    vec3 lookupVec = fixSeams(cubeMapProject(tReflDirW));\n    lookupVec.x *= -1.0;\n    return $DECODE(textureCube(texture_cubeMap, lookupVec));\n}\n\nvoid addReflection() {   \n    dReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\n}\n";

	var reflectionEnvHQPS = "\n#ifndef ENV_ATLAS\n#define ENV_ATLAS\nuniform sampler2D texture_envAtlas;\n#endif\nuniform samplerCube texture_cubeMap;\nuniform float material_reflectivity;\n\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\n    vec3 dir = cubeMapProject(tReflDirW) * vec3(-1.0, 1.0, 1.0);\n    vec2 uv = toSphericalUv(dir);\n\n    // calculate roughness level\n    float level = saturate(1.0 - tGlossiness) * 5.0;\n    float ilevel = floor(level);\n    float flevel = level - ilevel;\n\n    vec3 sharp = $DECODE(textureCube(texture_cubeMap, fixSeams(dir)));\n    vec3 roughA = $DECODE(texture2D(texture_envAtlas, mapRoughnessUv(uv, ilevel)));\n    vec3 roughB = $DECODE(texture2D(texture_envAtlas, mapRoughnessUv(uv, ilevel + 1.0)));\n\n    return processEnvironment(mix(sharp, mix(roughA, roughB, flevel), min(level, 1.0)));\n}\n\nvoid addReflection() {   \n    dReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\n}\n";

	var reflectionEnvPS = "\n#ifndef ENV_ATLAS\n#define ENV_ATLAS\nuniform sampler2D texture_envAtlas;\n#endif\nuniform float material_reflectivity;\n\n// calculate mip level for shiny reflection given equirect coords uv.\nfloat shinyMipLevel(vec2 uv) {\n    vec2 dx = dFdx(uv);\n    vec2 dy = dFdy(uv);\n\n    // calculate second dF at 180 degrees\n    vec2 uv2 = vec2(fract(uv.x + 0.5), uv.y);\n    vec2 dx2 = dFdx(uv2);\n    vec2 dy2 = dFdy(uv2);\n\n    // calculate min of both sets of dF to handle discontinuity at the azim edge\n    float maxd = min(max(dot(dx, dx), dot(dy, dy)), max(dot(dx2, dx2), dot(dy2, dy2)));\n\n    return clamp(0.5 * log2(maxd) - 1.0 + textureBias, 0.0, 5.0);\n}\n\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\n    vec3 dir = cubeMapProject(tReflDirW) * vec3(-1.0, 1.0, 1.0);\n    vec2 uv = toSphericalUv(dir);\n\n    // calculate roughness level\n    float level = saturate(1.0 - tGlossiness) * 5.0;\n    float ilevel = floor(level);\n\n    // accessing the shiny (top level) reflection - perform manual mipmap lookup\n    float level2 = shinyMipLevel(uv * atlasSize);\n    float ilevel2 = floor(level2);\n\n    vec2 uv0, uv1;\n    float weight;\n    if (ilevel == 0.0) {\n        uv0 = mapShinyUv(uv, ilevel2);\n        uv1 = mapShinyUv(uv, ilevel2 + 1.0);\n        weight = level2 - ilevel2;\n    } else {\n        // accessing rough reflection - just sample the same part twice\n        uv0 = uv1 = mapRoughnessUv(uv, ilevel);\n        weight = 0.0;\n    }\n\n    vec3 linearA = $DECODE(texture2D(texture_envAtlas, uv0));\n    vec3 linearB = $DECODE(texture2D(texture_envAtlas, uv1));\n    vec3 linear0 = mix(linearA, linearB, weight);\n    vec3 linear1 = $DECODE(texture2D(texture_envAtlas, mapRoughnessUv(uv, ilevel + 1.0)));\n\n    return processEnvironment(mix(linear0, linear1, level - ilevel));\n}\n\nvoid addReflection() {   \n    dReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\n}\n";

	var reflectionSpherePS = "\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform sampler2D texture_sphereMap;\nuniform float material_reflectivity;\n\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\n    vec3 reflDirV = (mat3(matrix_view) * tReflDirW).xyz;\n\n    float m = 2.0 * sqrt( dot(reflDirV.xy, reflDirV.xy) + (reflDirV.z+1.0)*(reflDirV.z+1.0) );\n    vec2 sphereMapUv = reflDirV.xy / m + 0.5;\n\n    return $DECODE(texture2D(texture_sphereMap, sphereMapUv));\n}\n\nvoid addReflection() {   \n    dReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\n}\n";

	var reflectionSphereLowPS = "\nuniform sampler2D texture_sphereMap;\nuniform float material_reflectivity;\n\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\n    vec3 reflDirV = vNormalV;\n\n    vec2 sphereMapUv = reflDirV.xy * 0.5 + 0.5;\n    return $DECODE(texture2D(texture_sphereMap, sphereMapUv));\n}\n\nvoid addReflection() {   \n    dReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\n}\n";

	var reflectionSheenPS = "\n\nvoid addReflectionSheen() {\n    float NoV = dot(dNormalW, dViewDirW);\n    float alphaG = sGlossiness * sGlossiness;\n\n    // Avoid using a LUT and approximate the values analytically\n    float a = sGlossiness < 0.25 ? -339.2 * alphaG + 161.4 * sGlossiness - 25.9 : -8.48 * alphaG + 14.3 * sGlossiness - 9.95;\n    float b = sGlossiness < 0.25 ? 44.0 * alphaG - 23.7 * sGlossiness + 3.26 : 1.97 * alphaG - 3.27 * sGlossiness + 0.72;\n    float DG = exp( a * NoV + b ) + ( sGlossiness < 0.25 ? 0.0 : 0.1 * ( sGlossiness - 0.25 ) );\n    sReflection += vec4(calcReflection(dReflDirW, sGlossiness), saturate(DG * 1.0/PI));\n}\n";

	var refractionCubePS = "\nuniform float material_refractionIndex;\n\nvec3 refract2(vec3 viewVec, vec3 Normal, float IOR) {\n    float vn = dot(viewVec, Normal);\n    float k = 1.0 - IOR * IOR * (1.0 - vn * vn);\n    vec3 refrVec = IOR * viewVec - (IOR * vn + sqrt(k)) * Normal;\n    return refrVec;\n}\n\nvoid addRefraction() {\n    // use same reflection code with refraction vector\n    vec3 tmpDir = dReflDirW;\n    vec4 tmpRefl = dReflection;\n    dReflDirW = refract2(-dViewDirW, dNormalW, material_refractionIndex);\n    dReflection = vec4(0);\n    addReflection();\n    dDiffuseLight = mix(dDiffuseLight, dReflection.rgb * dAlbedo, dTransmission);\n    dReflection = tmpRefl;\n    dReflDirW = tmpDir;\n}\n";

	var refractionDynamicPS = "\nuniform float material_refractionIndex;\nuniform float material_invAttenuationDistance;\nuniform vec3 material_attenuation;\n\nvec3 refract2(vec3 viewVec, vec3 Normal, float IOR) {\n    float vn = dot(viewVec, Normal);\n    float k = 1.0 - IOR * IOR * (1.0 - vn * vn);\n    vec3 refrVec = IOR * viewVec - (IOR * vn + sqrt(k)) * Normal;\n    return refrVec;\n}\n\nvoid addRefraction() {\n\n    // Extract scale from the model transform\n    vec3 modelScale;\n    modelScale.x = length(vec3(matrix_model[0].xyz));\n    modelScale.y = length(vec3(matrix_model[1].xyz));\n    modelScale.z = length(vec3(matrix_model[2].xyz));\n\n    // Calculate the refraction vector, scaled by the thickness and scale of the object\n    vec3 refractionVector = normalize(refract(-dViewDirW, dNormalW, material_refractionIndex)) * dThickness * modelScale;\n\n    // The refraction point is the entry point + vector to exit point\n    vec4 pointOfRefraction = vec4(vPositionW + refractionVector, 1.0);\n\n    // Project to texture space so we can sample it\n    vec4 projectionPoint = matrix_viewProjection * pointOfRefraction;\n    vec2 uv = projectionPoint.xy / projectionPoint.ww;\n    uv += vec2(1.0);\n    uv *= vec2(0.5);\n\n    #ifdef GL2\n        // Use IOR and roughness to select mip\n        float iorToRoughness = (1.0 - dGlossiness) * clamp((1.0 / material_refractionIndex) * 2.0 - 2.0, 0.0, 1.0);\n        float refractionLod = log2(uScreenSize.x) * iorToRoughness;\n        vec3 refraction = texture2DLodEXT(uSceneColorMap, uv, refractionLod).rgb;\n    #else\n        vec3 refraction = texture2D(uSceneColorMap, uv).rgb;\n    #endif\n\n    // Transmittance is our final refraction color\n    vec3 transmittance;\n    if (material_invAttenuationDistance != 0.0)\n    {\n        vec3 attenuation = -log(material_attenuation) * material_invAttenuationDistance;\n        transmittance = exp(-attenuation * length(refractionVector));\n    }\n    else\n    {\n        transmittance = refraction;\n    }\n\n    // Apply fresnel effect on refraction\n    vec3 fresnel = vec3(1.0) - getFresnel(dot(dViewDirW, dNormalW), dSpecularity);\n    dDiffuseLight = mix(dDiffuseLight, refraction * transmittance * fresnel, dTransmission);\n}\n";

	var reprojectPS = "\n// This shader requires the following #DEFINEs:\n//\n// PROCESS_FUNC - must be one of reproject, prefilter\n// DECODE_FUNC - must be one of decodeRGBM, decodeRGBE, decodeGamma or decodeLinear\n// ENCODE_FUNC - must be one of encodeRGBM, encodeRGBE, encideGamma or encodeLinear\n// SOURCE_FUNC - must be one of sampleCubemap, sampleEquirect, sampleOctahedral\n// TARGET_FUNC - must be one of getDirectionCubemap, getDirectionEquirect, getDirectionOctahedral\n//\n// When filtering:\n// NUM_SAMPLES - number of samples\n// NUM_SAMPLES_SQRT - sqrt of number of samples\n//\n// SUPPORTS_TEXLOD - whether supports texlod is supported\n\nvarying vec2 vUv0;\n\n// source\nuniform sampler2D sourceTex;\nuniform samplerCube sourceCube;\n\n// samples\nuniform sampler2D samplesTex;\nuniform vec2 samplesTexInverseSize;\n\n// params:\n// x - target cubemap face 0..6\n// y - specular power (when prefiltering)\n// z - source cubemap seam scale (0 to disable)\n// w - target cubemap size for seam calc (0 to disable)\nuniform vec4 params;\n\n// params2:\n// x - target image total pixels\n// y - source cubemap size\nuniform vec2 params2;\n\nfloat targetFace() { return params.x; }\nfloat specularPower() { return params.y; }\nfloat sourceCubeSeamScale() { return params.z; }\nfloat targetCubeSeamScale() { return params.w; }\n\nfloat targetTotalPixels() { return params2.x; }\nfloat sourceTotalPixels() { return params2.y; }\n\nfloat PI = 3.141592653589793;\n\nfloat saturate(float x) {\n    return clamp(x, 0.0, 1.0);\n}\n\n" + decodePS + "\n" + encodePS + "\n\n//-- supported projections\n\nvec3 modifySeams(vec3 dir, float scale) {\n    vec3 adir = abs(dir);\n    float M = max(max(adir.x, adir.y), adir.z);\n    return dir / M * vec3(\n        adir.x == M ? 1.0 : scale,\n        adir.y == M ? 1.0 : scale,\n        adir.z == M ? 1.0 : scale\n    );\n}\n\nvec2 toSpherical(vec3 dir) {\n    return vec2(dir.xz == vec2(0.0) ? 0.0 : atan(dir.x, dir.z), asin(dir.y));\n}\n\nvec3 fromSpherical(vec2 uv) {\n    return vec3(cos(uv.y) * sin(uv.x),\n                sin(uv.y),\n                cos(uv.y) * cos(uv.x));\n}\n\nvec3 getDirectionEquirect() {\n    return fromSpherical((vec2(vUv0.x, 1.0 - vUv0.y) * 2.0 - 1.0) * vec2(PI, PI * 0.5));\n}\n\nvec4 sampleEquirect(vec2 sph) {\n    vec2 uv = sph / vec2(PI * 2.0, PI) + 0.5;\n    return texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));\n}\n\nvec4 sampleEquirect(vec3 dir) {\n    return sampleEquirect(toSpherical(dir));\n}\n\nvec4 sampleCubemap(vec3 dir) {\n    return textureCube(sourceCube, modifySeams(dir, 1.0 - sourceCubeSeamScale()));\n}\n\nvec4 sampleCubemap(vec2 sph) {\n    return sampleCubemap(fromSpherical(sph));\n}\n\nvec4 sampleEquirect(vec2 sph, float mipLevel) {\n    vec2 uv = sph / vec2(PI * 2.0, PI) + 0.5;\n#ifdef SUPPORTS_TEXLOD\n    return texture2DLodEXT(sourceTex, vec2(uv.x, 1.0 - uv.y), mipLevel);\n#else\n    return texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));\n#endif\n}\n\nvec4 sampleEquirect(vec3 dir, float mipLevel) {\n    return sampleEquirect(toSpherical(dir), mipLevel);\n}\n\nvec4 sampleCubemap(vec3 dir, float mipLevel) {\n#ifdef SUPPORTS_TEXLOD\n    return textureCubeLodEXT(sourceCube, modifySeams(dir, 1.0 - exp2(mipLevel) * sourceCubeSeamScale()), mipLevel);\n#else\n    return textureCube(sourceCube, modifySeams(dir, 1.0 - exp2(mipLevel) * sourceCubeSeamScale()));\n#endif\n}\n\nvec4 sampleCubemap(vec2 sph, float mipLevel) {\n    return sampleCubemap(fromSpherical(sph), mipLevel);\n}\n\n// octahedral code, based on http://jcgt.org/published/0003/02/01\n// \"Survey of Efficient Representations for Independent Unit Vectors\" by Cigolle, Donow, Evangelakos, Mara, McGuire, Meyer\n\nfloat signNotZero(float k){\n    return(k >= 0.0) ? 1.0 : -1.0;\n}\n\nvec2 signNotZero(vec2 v) {\n    return vec2(signNotZero(v.x), signNotZero(v.y));\n}\n\n// Returns a unit vector. Argument o is an octahedral vector packed via octEncode, on the [-1, +1] square\nvec3 octDecode(vec2 o) {\n    vec3 v = vec3(o.x, 1.0 - abs(o.x) - abs(o.y), o.y);\n    if (v.y < 0.0) {\n        v.xz = (1.0 - abs(v.zx)) * signNotZero(v.xz);\n    }\n    return normalize(v);\n}\n\nvec3 getDirectionOctahedral() {\n    return octDecode(vec2(vUv0.x, 1.0 - vUv0.y) * 2.0 - 1.0);\n}\n\n// Assumes that v is a unit vector. The result is an octahedral vector on the [-1, +1] square\nvec2 octEncode(in vec3 v) {\n    float l1norm = abs(v.x) + abs(v.y) + abs(v.z);\n    vec2 result = v.xz * (1.0 / l1norm);\n    if (v.y < 0.0) {\n        result = (1.0 - abs(result.yx)) * signNotZero(result.xy);\n    }\n    return result;\n}\n\nvec4 sampleOctahedral(vec3 dir) {\n    vec2 uv = octEncode(dir) * 0.5 + 0.5;\n    return texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));\n}\n\nvec4 sampleOctahedral(vec2 sph) {\n    return sampleOctahedral(fromSpherical(sph));\n}\n\nvec4 sampleOctahedral(vec3 dir, float mipLevel) {\n    vec2 uv = octEncode(dir) * 0.5 + 0.5;\n#ifdef SUPPORTS_TEXLOD\n    return texture2DLodEXT(sourceTex, vec2(uv.x, 1.0 - uv.y), mipLevel);\n#else\n    return texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));\n#endif\n}\n\nvec4 sampleOctahedral(vec2 sph, float mipLevel) {\n    return sampleOctahedral(fromSpherical(sph), mipLevel);\n}\n\n/////////////////////////////////////////////////////////////////////\n\nvec3 getDirectionCubemap() {\n    vec2 st = vUv0 * 2.0 - 1.0;\n    float face = targetFace();\n\n    vec3 vec;\n    if (face == 0.0) {\n        vec = vec3(1, -st.y, -st.x);\n    } else if (face == 1.0) {\n        vec = vec3(-1, -st.y, st.x);\n    } else if (face == 2.0) {\n        vec = vec3(st.x, 1, st.y);\n    } else if (face == 3.0) {\n        vec = vec3(st.x, -1, -st.y);\n    } else if (face == 4.0) {\n        vec = vec3(st.x, -st.y, 1);\n    } else {\n        vec = vec3(-st.x, -st.y, -1);\n    }\n\n    return normalize(modifySeams(vec, 1.0 / (1.0 - targetCubeSeamScale())));\n}\n\nmat3 matrixFromVector(vec3 n) { // frisvad\n    float a = 1.0 / (1.0 + n.z);\n    float b = -n.x * n.y * a;\n    vec3 b1 = vec3(1.0 - n.x * n.x * a, b, -n.x);\n    vec3 b2 = vec3(b, 1.0 - n.y * n.y * a, -n.y);\n    return mat3(b1, b2, n);\n}\n\nmat3 matrixFromVectorSlow(vec3 n) {\n    vec3 up = (1.0 - abs(n.y) <= 0.0000001) ? vec3(0.0, 0.0, n.y > 0.0 ? 1.0 : -1.0) : vec3(0.0, 1.0, 0.0);\n    vec3 x = normalize(cross(up, n));\n    vec3 y = cross(n, x);\n    return mat3(x, y, n);\n}\n\nvec4 reproject() {\n    if (NUM_SAMPLES <= 1) {\n        // single sample\n        return ENCODE_FUNC(DECODE_FUNC(SOURCE_FUNC(TARGET_FUNC())));\n    } else {\n        // multi sample\n        vec3 t = TARGET_FUNC();\n        vec3 tu = dFdx(t);\n        vec3 tv = dFdy(t);\n\n        vec3 result = vec3(0.0);\n        for (float u = 0.0; u < NUM_SAMPLES_SQRT; ++u) {\n            for (float v = 0.0; v < NUM_SAMPLES_SQRT; ++v) {\n                result += DECODE_FUNC(SOURCE_FUNC(normalize(t +\n                                                            tu * (u / NUM_SAMPLES_SQRT - 0.5) +\n                                                            tv * (v / NUM_SAMPLES_SQRT - 0.5))));\n            }\n        }\n        return ENCODE_FUNC(result / (NUM_SAMPLES_SQRT * NUM_SAMPLES_SQRT));\n    }\n}\n\nvec4 unpackFloat = vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0);\n\nvoid unpackSample(int i, out vec3 L, out float mipLevel) {\n    float u = (float(i * 4) + 0.5) * samplesTexInverseSize.x;\n    float v = (floor(u) + 0.5) * samplesTexInverseSize.y;\n\n    vec4 raw;\n    raw.x = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;\n    raw.y = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;\n    raw.z = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;\n    raw.w = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat);\n\n    L.xyz = raw.xyz * 2.0 - 1.0;\n    mipLevel = raw.w * 8.0;\n}\n\n// convolve an environment given pre-generated samples\nvec4 prefilterSamples() {\n    // construct vector space given target direction\n    mat3 vecSpace = matrixFromVectorSlow(TARGET_FUNC());\n\n    vec3 L;\n    float mipLevel;\n\n    vec3 result = vec3(0.0);\n    float totalWeight = 0.0;\n    for (int i = 0; i < NUM_SAMPLES; ++i) {\n        unpackSample(i, L, mipLevel);\n        result += DECODE_FUNC(SOURCE_FUNC(vecSpace * L, mipLevel)) * L.z;\n        totalWeight += L.z;\n    }\n\n    return ENCODE_FUNC(result / totalWeight);\n}\n\n// unweighted version of prefilterSamples\nvec4 prefilterSamplesUnweighted() {\n    // construct vector space given target direction\n    mat3 vecSpace = matrixFromVectorSlow(TARGET_FUNC());\n\n    vec3 L;\n    float mipLevel;\n\n    vec3 result = vec3(0.0);\n    float totalWeight = 0.0;\n    for (int i = 0; i < NUM_SAMPLES; ++i) {\n        unpackSample(i, L, mipLevel);\n        result += DECODE_FUNC(SOURCE_FUNC(vecSpace * L, mipLevel));\n    }\n\n    return ENCODE_FUNC(result / float(NUM_SAMPLES));\n}\n\nvoid main(void) {\n    gl_FragColor = PROCESS_FUNC();\n}\n";

	var screenDepthPS = "\nuniform highp sampler2D uSceneDepthMap;\n\n#ifndef SCREENSIZE\n#define SCREENSIZE\nuniform vec4 uScreenSize;\n#endif\n\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\n\n\n\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params; // 1 / camera_far,      camera_far,     camera_near,        is_ortho\n#endif\n\n#ifdef GL2\nfloat linearizeDepth(float z) {\n    if (camera_params.w == 0.0)\n        return (camera_params.z * camera_params.y) / (camera_params.y + z * (camera_params.z - camera_params.y));\n    else\n        return camera_params.z + z * (camera_params.y - camera_params.z);\n}\n#else\n#ifndef UNPACKFLOAT\n#define UNPACKFLOAT\nfloat unpackFloat(vec4 rgbaDepth) {\n    const vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n    return dot(rgbaDepth, bitShift);\n}\n#endif\n#endif\n\n// Retrieves rendered linear camera depth by UV\nfloat getLinearScreenDepth(vec2 uv) {\n    #ifdef GL2\n        return linearizeDepth(texture2D(uSceneDepthMap, uv).r);\n    #else\n        return unpackFloat(texture2D(uSceneDepthMap, uv)) * camera_params.y;\n    #endif\n}\n\n#ifndef VERTEXSHADER\n// Retrieves rendered linear camera depth under the current pixel\nfloat getLinearScreenDepth() {\n    vec2 uv = gl_FragCoord.xy * uScreenSize.zw;\n    return getLinearScreenDepth(uv);\n}\n#endif\n\n// Generates linear camera depth for the given world position\nfloat getLinearDepth(vec3 pos) {\n    return -(matrix_view * vec4(pos, 1.0)).z;\n}\n";

	var shadowCascadesPS = "\nconst float maxCascades = 4.0;\n\n// shadow matrix for selected cascade\nmat4 cascadeShadowMat;\n\n// function which selects a shadow projection matrix based on cascade distances \nvoid getShadowCascadeMatrix(mat4 shadowMatrixPalette[4], float shadowCascadeDistances[4], float shadowCascadeCount) {\n\n    // depth in 0 .. far plane range\n    float depth = 1.0 / gl_FragCoord.w;\n\n    // find cascade index based on the depth (loop as there is no per component vec compare operator in webgl)\n    float cascadeIndex = 0.0;\n    for (float i = 0.0; i < maxCascades; i++) {\n        if (depth < shadowCascadeDistances[int(i)]) {\n            cascadeIndex = i;\n            break;\n        }\n    }\n\n    // limit to actual number of used cascades\n    cascadeIndex = min(cascadeIndex, shadowCascadeCount - 1.0);\n\n    // pick shadow matrix\n    #ifdef GL2\n        cascadeShadowMat = shadowMatrixPalette[int(cascadeIndex)];\n    #else\n        // webgl 1 does not allow non-cost index array lookup\n        if (cascadeIndex == 0.0) {\n            cascadeShadowMat = shadowMatrixPalette[0];\n        }\n        else if (cascadeIndex == 1.0) {\n            cascadeShadowMat = shadowMatrixPalette[1];\n        }\n        else if (cascadeIndex == 2.0) {\n            cascadeShadowMat = shadowMatrixPalette[2];\n        }\n        else {\n            cascadeShadowMat = shadowMatrixPalette[3];\n        }\n    #endif\n}\n\nvoid fadeShadow(float shadowCascadeDistances[4]) {                  \n\n    // if the pixel is past the shadow distance, remove shadow\n    // this enforces straight line instead of corner of shadow which moves when camera rotates  \n    float depth = 1.0 / gl_FragCoord.w;\n    if (depth > shadowCascadeDistances[int(maxCascades - 1.0)]) {\n        dShadowCoord.z = -9999999.0;\n    }\n}\n";

	var shadowCommonPS = "\nvoid normalOffsetPointShadow(vec4 shadowParams) {\n    float distScale = length(dLightDirW);\n    vec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0) * distScale; //0.02\n    vec3 dir = wPos - dLightPosW;\n    dLightDirW = dir;\n}\n";

	var shadowCoordPS = "\nvoid _getShadowCoordOrtho(mat4 shadowMatrix, vec3 shadowParams, vec3 wPos) {\n    dShadowCoord = (shadowMatrix * vec4(wPos, 1.0)).xyz;\n    dShadowCoord.z = saturate(dShadowCoord.z) - 0.0001;\n\n    #ifdef SHADOWBIAS\n    dShadowCoord.z += getShadowBias(shadowParams.x, shadowParams.z);\n    #endif\n}\n\nvoid _getShadowCoordPersp(mat4 shadowMatrix, vec4 shadowParams, vec3 wPos) {\n    vec4 projPos = shadowMatrix * vec4(wPos, 1.0);\n    projPos.xy /= projPos.w;\n    dShadowCoord.xy = projPos.xy;\n    dShadowCoord.z = length(dLightDirW) * shadowParams.w;\n\n    #ifdef SHADOWBIAS\n    dShadowCoord.z += getShadowBias(shadowParams.x, shadowParams.z);\n    #endif\n}\n\nvoid getShadowCoordOrtho(mat4 shadowMatrix, vec3 shadowParams) {\n    _getShadowCoordOrtho(shadowMatrix, shadowParams, vPositionW);\n}\n\nvoid getShadowCoordPersp(mat4 shadowMatrix, vec4 shadowParams) {\n    _getShadowCoordPersp(shadowMatrix, shadowParams, vPositionW);\n}\n\nvoid getShadowCoordPerspNormalOffset(mat4 shadowMatrix, vec4 shadowParams) {\n    float distScale = abs(dot(vPositionW - dLightPosW, dLightDirNormW)); // fov?\n    vec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0) * distScale;\n\n    _getShadowCoordPersp(shadowMatrix, shadowParams, wPos);\n}\n\nvoid getShadowCoordOrthoNormalOffset(mat4 shadowMatrix, vec3 shadowParams) {\n    vec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0); //0.08\n\n    _getShadowCoordOrtho(shadowMatrix, shadowParams, wPos);\n}\n";

	var shadowCoordPerspZbufferPS = "\nvoid _getShadowCoordPerspZbuffer(mat4 shadowMatrix, vec4 shadowParams, vec3 wPos) {\n    vec4 projPos = shadowMatrix * vec4(wPos, 1.0);\n    projPos.xyz /= projPos.w;\n    dShadowCoord = projPos.xyz;\n    // depth bias is already applied on render\n}\n\nvoid getShadowCoordPerspZbufferNormalOffset(mat4 shadowMatrix, vec4 shadowParams) {\n    vec3 wPos = vPositionW + dVertexNormalW * shadowParams.y;\n    _getShadowCoordPerspZbuffer(shadowMatrix, shadowParams, wPos);\n}\n\nvoid getShadowCoordPerspZbuffer(mat4 shadowMatrix, vec4 shadowParams) {\n    _getShadowCoordPerspZbuffer(shadowMatrix, shadowParams, vPositionW);\n}\n";

	var shadowEVSMPS = "\nfloat VSM$(sampler2D tex, vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {\n    vec3 moments = texture2D(tex, texCoords).xyz;\n    return calculateEVSM(moments, Z, vsmBias, exponent);\n}\n\nfloat getShadowVSM$(sampler2D shadowMap, vec3 shadowParams, float exponent) {\n    return VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, dShadowCoord.z, shadowParams.y, exponent);\n}\n\nfloat getShadowSpotVSM$(sampler2D shadowMap, vec4 shadowParams, float exponent) {\n    return VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, length(dLightDirW) * shadowParams.w + shadowParams.z, shadowParams.y, exponent);\n}\n";

	var shadowEVSMnPS = "\nfloat VSM$(sampler2D tex, vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {\n    float pixelSize = 1.0 / resolution;\n    texCoords -= vec2(pixelSize);\n    vec3 s00 = texture2D(tex, texCoords).xyz;\n    vec3 s10 = texture2D(tex, texCoords + vec2(pixelSize, 0)).xyz;\n    vec3 s01 = texture2D(tex, texCoords + vec2(0, pixelSize)).xyz;\n    vec3 s11 = texture2D(tex, texCoords + vec2(pixelSize)).xyz;\n    vec2 fr = fract(texCoords * resolution);\n    vec3 h0 = mix(s00, s10, fr.x);\n    vec3 h1 = mix(s01, s11, fr.x);\n    vec3 moments = mix(h0, h1, fr.y);\n    return calculateEVSM(moments, Z, vsmBias, exponent);\n}\n\nfloat getShadowVSM$(sampler2D shadowMap, vec3 shadowParams, float exponent) {\n    return VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, dShadowCoord.z, shadowParams.y, exponent);\n}\n\nfloat getShadowSpotVSM$(sampler2D shadowMap, vec4 shadowParams, float exponent) {\n    return VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, length(dLightDirW) * shadowParams.w + shadowParams.z, shadowParams.y, exponent);\n}\n";

	var shadowStandardPS = "\nvec3 lessThan2(vec3 a, vec3 b) {\n    return clamp((b - a)*1000.0, 0.0, 1.0); // softer version\n}\n\n#ifndef UNPACKFLOAT\n#define UNPACKFLOAT\nfloat unpackFloat(vec4 rgbaDepth) {\n    const vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n    return dot(rgbaDepth, bitShift);\n}\n#endif\n\n// ----- Direct/Spot Sampling -----\n\n#ifdef GL2\nfloat _getShadowPCF3x3(sampler2DShadow shadowMap, vec3 shadowParams) {\n    float z = dShadowCoord.z;\n    vec2 uv = dShadowCoord.xy * shadowParams.x; // 1 unit - 1 texel\n    float shadowMapSizeInv = 1.0 / shadowParams.x;\n    vec2 base_uv = floor(uv + 0.5);\n    float s = (uv.x + 0.5 - base_uv.x);\n    float t = (uv.y + 0.5 - base_uv.y);\n    base_uv -= vec2(0.5);\n    base_uv *= shadowMapSizeInv;\n\n    float sum = 0.0;\n\n    float uw0 = (3.0 - 2.0 * s);\n    float uw1 = (1.0 + 2.0 * s);\n\n    float u0 = (2.0 - s) / uw0 - 1.0;\n    float u1 = s / uw1 + 1.0;\n\n    float vw0 = (3.0 - 2.0 * t);\n    float vw1 = (1.0 + 2.0 * t);\n\n    float v0 = (2.0 - t) / vw0 - 1.0;\n    float v1 = t / vw1 + 1.0;\n\n    u0 = u0 * shadowMapSizeInv + base_uv.x;\n    v0 = v0 * shadowMapSizeInv + base_uv.y;\n\n    u1 = u1 * shadowMapSizeInv + base_uv.x;\n    v1 = v1 * shadowMapSizeInv + base_uv.y;\n\n    sum += uw0 * vw0 * texture(shadowMap, vec3(u0, v0, z));\n    sum += uw1 * vw0 * texture(shadowMap, vec3(u1, v0, z));\n    sum += uw0 * vw1 * texture(shadowMap, vec3(u0, v1, z));\n    sum += uw1 * vw1 * texture(shadowMap, vec3(u1, v1, z));\n\n    sum *= 1.0f / 16.0;\n    return sum;\n}\n\nfloat getShadowPCF3x3(sampler2DShadow shadowMap, vec3 shadowParams) {\n    return _getShadowPCF3x3(shadowMap, shadowParams);\n}\n\nfloat getShadowSpotPCF3x3(sampler2DShadow shadowMap, vec4 shadowParams) {\n    return _getShadowPCF3x3(shadowMap, shadowParams.xyz);\n}\n#else\nfloat _xgetShadowPCF3x3(mat3 depthKernel, sampler2D shadowMap, vec3 shadowParams) {\n    mat3 shadowKernel;\n    vec3 shadowCoord = dShadowCoord;\n    vec3 shadowZ = vec3(shadowCoord.z);\n    shadowKernel[0] = vec3(greaterThan(depthKernel[0], shadowZ));\n    shadowKernel[1] = vec3(greaterThan(depthKernel[1], shadowZ));\n    shadowKernel[2] = vec3(greaterThan(depthKernel[2], shadowZ));\n\n    vec2 fractionalCoord = fract( shadowCoord.xy * shadowParams.x );\n\n    shadowKernel[0] = mix(shadowKernel[0], shadowKernel[1], fractionalCoord.x);\n    shadowKernel[1] = mix(shadowKernel[1], shadowKernel[2], fractionalCoord.x);\n\n    vec4 shadowValues;\n    shadowValues.x = mix(shadowKernel[0][0], shadowKernel[0][1], fractionalCoord.y);\n    shadowValues.y = mix(shadowKernel[0][1], shadowKernel[0][2], fractionalCoord.y);\n    shadowValues.z = mix(shadowKernel[1][0], shadowKernel[1][1], fractionalCoord.y);\n    shadowValues.w = mix(shadowKernel[1][1], shadowKernel[1][2], fractionalCoord.y);\n\n    return dot( shadowValues, vec4( 1.0 ) ) * 0.25;\n}\n\nfloat _getShadowPCF3x3(sampler2D shadowMap, vec3 shadowParams) {\n    vec3 shadowCoord = dShadowCoord;\n\n    float xoffset = 1.0 / shadowParams.x; // 1/shadow map width\n    float dx0 = -xoffset;\n    float dx1 = xoffset;\n\n    mat3 depthKernel;\n    depthKernel[0][0] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx0, dx0)));\n    depthKernel[0][1] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx0, 0.0)));\n    depthKernel[0][2] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx0, dx1)));\n    depthKernel[1][0] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(0.0, dx0)));\n    depthKernel[1][1] = unpackFloat(texture2D(shadowMap, shadowCoord.xy));\n    depthKernel[1][2] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(0.0, dx1)));\n    depthKernel[2][0] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx1, dx0)));\n    depthKernel[2][1] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx1, 0.0)));\n    depthKernel[2][2] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx1, dx1)));\n\n    return _xgetShadowPCF3x3(depthKernel, shadowMap, shadowParams);\n}\n\nfloat getShadowPCF3x3(sampler2D shadowMap, vec3 shadowParams) {\n    return _getShadowPCF3x3(shadowMap, shadowParams);\n}\n\nfloat getShadowSpotPCF3x3(sampler2D shadowMap, vec4 shadowParams) {\n    return _getShadowPCF3x3(shadowMap, shadowParams.xyz);\n}\n#endif\n\n\n// ----- Omni Sampling -----\n\nfloat _getShadowPoint(samplerCube shadowMap, vec4 shadowParams, vec3 dir) {\n\n    vec3 tc = normalize(dir);\n    vec3 tcAbs = abs(tc);\n\n    vec4 dirX = vec4(1,0,0, tc.x);\n    vec4 dirY = vec4(0,1,0, tc.y);\n    float majorAxisLength = tc.z;\n    if ((tcAbs.x > tcAbs.y) && (tcAbs.x > tcAbs.z)) {\n        dirX = vec4(0,0,1, tc.z);\n        dirY = vec4(0,1,0, tc.y);\n        majorAxisLength = tc.x;\n    } else if ((tcAbs.y > tcAbs.x) && (tcAbs.y > tcAbs.z)) {\n        dirX = vec4(1,0,0, tc.x);\n        dirY = vec4(0,0,1, tc.z);\n        majorAxisLength = tc.y;\n    }\n\n    float shadowParamsInFaceSpace = ((1.0/shadowParams.x) * 2.0) * abs(majorAxisLength);\n\n    vec3 xoffset = (dirX.xyz * shadowParamsInFaceSpace);\n    vec3 yoffset = (dirY.xyz * shadowParamsInFaceSpace);\n    vec3 dx0 = -xoffset;\n    vec3 dy0 = -yoffset;\n    vec3 dx1 = xoffset;\n    vec3 dy1 = yoffset;\n\n    mat3 shadowKernel;\n    mat3 depthKernel;\n\n    depthKernel[0][0] = unpackFloat(textureCube(shadowMap, tc + dx0 + dy0));\n    depthKernel[0][1] = unpackFloat(textureCube(shadowMap, tc + dx0));\n    depthKernel[0][2] = unpackFloat(textureCube(shadowMap, tc + dx0 + dy1));\n    depthKernel[1][0] = unpackFloat(textureCube(shadowMap, tc + dy0));\n    depthKernel[1][1] = unpackFloat(textureCube(shadowMap, tc));\n    depthKernel[1][2] = unpackFloat(textureCube(shadowMap, tc + dy1));\n    depthKernel[2][0] = unpackFloat(textureCube(shadowMap, tc + dx1 + dy0));\n    depthKernel[2][1] = unpackFloat(textureCube(shadowMap, tc + dx1));\n    depthKernel[2][2] = unpackFloat(textureCube(shadowMap, tc + dx1 + dy1));\n\n    vec3 shadowZ = vec3(length(dir) * shadowParams.w + shadowParams.z);\n\n    shadowKernel[0] = vec3(lessThan2(depthKernel[0], shadowZ));\n    shadowKernel[1] = vec3(lessThan2(depthKernel[1], shadowZ));\n    shadowKernel[2] = vec3(lessThan2(depthKernel[2], shadowZ));\n\n    vec2 uv = (vec2(dirX.w, dirY.w) / abs(majorAxisLength)) * 0.5;\n\n    vec2 fractionalCoord = fract( uv * shadowParams.x );\n\n    shadowKernel[0] = mix(shadowKernel[0], shadowKernel[1], fractionalCoord.x);\n    shadowKernel[1] = mix(shadowKernel[1], shadowKernel[2], fractionalCoord.x);\n\n    vec4 shadowValues;\n    shadowValues.x = mix(shadowKernel[0][0], shadowKernel[0][1], fractionalCoord.y);\n    shadowValues.y = mix(shadowKernel[0][1], shadowKernel[0][2], fractionalCoord.y);\n    shadowValues.z = mix(shadowKernel[1][0], shadowKernel[1][1], fractionalCoord.y);\n    shadowValues.w = mix(shadowKernel[1][1], shadowKernel[1][2], fractionalCoord.y);\n\n    return 1.0 - dot( shadowValues, vec4( 1.0 ) ) * 0.25;\n}\n\nfloat getShadowPointPCF3x3(samplerCube shadowMap, vec4 shadowParams) {\n    return _getShadowPoint(shadowMap, shadowParams, dLightDirW);\n}\n";

	var shadowStandardGL2PS = "\nfloat _getShadowPCF5x5(sampler2DShadow shadowMap, vec3 shadowParams) {\n    // http://the-witness.net/news/2013/09/shadow-mapping-summary-part-1/\n\n    float z = dShadowCoord.z;\n    vec2 uv = dShadowCoord.xy * shadowParams.x; // 1 unit - 1 texel\n    float shadowMapSizeInv = 1.0 / shadowParams.x;\n    vec2 base_uv = floor(uv + 0.5);\n    float s = (uv.x + 0.5 - base_uv.x);\n    float t = (uv.y + 0.5 - base_uv.y);\n    base_uv -= vec2(0.5);\n    base_uv *= shadowMapSizeInv;\n\n\n    float uw0 = (4.0 - 3.0 * s);\n    float uw1 = 7.0;\n    float uw2 = (1.0 + 3.0 * s);\n\n    float u0 = (3.0 - 2.0 * s) / uw0 - 2.0;\n    float u1 = (3.0 + s) / uw1;\n    float u2 = s / uw2 + 2.0;\n\n    float vw0 = (4.0 - 3.0 * t);\n    float vw1 = 7.0;\n    float vw2 = (1.0 + 3.0 * t);\n\n    float v0 = (3.0 - 2.0 * t) / vw0 - 2.0;\n    float v1 = (3.0 + t) / vw1;\n    float v2 = t / vw2 + 2.0;\n\n    float sum = 0.0;\n\n    u0 = u0 * shadowMapSizeInv + base_uv.x;\n    v0 = v0 * shadowMapSizeInv + base_uv.y;\n\n    u1 = u1 * shadowMapSizeInv + base_uv.x;\n    v1 = v1 * shadowMapSizeInv + base_uv.y;\n\n    u2 = u2 * shadowMapSizeInv + base_uv.x;\n    v2 = v2 * shadowMapSizeInv + base_uv.y;\n\n    sum += uw0 * vw0 * texture(shadowMap, vec3(u0, v0, z));\n    sum += uw1 * vw0 * texture(shadowMap, vec3(u1, v0, z));\n    sum += uw2 * vw0 * texture(shadowMap, vec3(u2, v0, z));\n\n    sum += uw0 * vw1 * texture(shadowMap, vec3(u0, v1, z));\n    sum += uw1 * vw1 * texture(shadowMap, vec3(u1, v1, z));\n    sum += uw2 * vw1 * texture(shadowMap, vec3(u2, v1, z));\n\n    sum += uw0 * vw2 * texture(shadowMap, vec3(u0, v2, z));\n    sum += uw1 * vw2 * texture(shadowMap, vec3(u1, v2, z));\n    sum += uw2 * vw2 * texture(shadowMap, vec3(u2, v2, z));\n\n    sum *= 1.0f / 144.0;\n\n    sum = gammaCorrectInput(sum); // gives softer gradient\n    sum = saturate(sum);\n\n    return sum;\n}\n\nfloat getShadowPCF5x5(sampler2DShadow shadowMap, vec3 shadowParams) {\n    return _getShadowPCF5x5(shadowMap, shadowParams);\n}\n\nfloat getShadowSpotPCF5x5(sampler2DShadow shadowMap, vec4 shadowParams) {\n    return _getShadowPCF5x5(shadowMap, shadowParams.xyz);\n}\n";

	var shadowVSM8PS = "\nfloat calculateVSM8(vec3 moments, float Z, float vsmBias) {\n    float VSMBias = vsmBias;//0.01 * 0.25;\n    float depthScale = VSMBias * Z;\n    float minVariance1 = depthScale * depthScale;\n    return chebyshevUpperBound(moments.xy, Z, minVariance1, 0.1);\n}\n\nfloat decodeFloatRG(vec2 rg) {\n    return rg.y*(1.0/255.0) + rg.x;\n}\n\nfloat VSM8(sampler2D tex, vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {\n    vec4 c = texture2D(tex, texCoords);\n    vec3 moments = vec3(decodeFloatRG(c.xy), decodeFloatRG(c.zw), 0.0);\n    return calculateVSM8(moments, Z, vsmBias);\n}\n\nfloat getShadowVSM8(sampler2D shadowMap, vec3 shadowParams, float exponent) {\n    return VSM8(shadowMap, dShadowCoord.xy, shadowParams.x, dShadowCoord.z, shadowParams.y, 0.0);\n}\n\nfloat getShadowSpotVSM8(sampler2D shadowMap, vec4 shadowParams, float exponent) {\n    return VSM8(shadowMap, dShadowCoord.xy, shadowParams.x, length(dLightDirW) * shadowParams.w + shadowParams.z, shadowParams.y, 0.0);\n}\n";

	var shadowVSM_commonPS = "\nfloat linstep(float a, float b, float v) {\n    return saturate((v - a) / (b - a));\n}\n\nfloat reduceLightBleeding(float pMax, float amount) {\n   // Remove the [0, amount] tail and linearly rescale (amount, 1].\n   return linstep(amount, 1.0, pMax);\n}\n\nfloat chebyshevUpperBound(vec2 moments, float mean, float minVariance, float lightBleedingReduction) {\n    // Compute variance\n    float variance = moments.y - (moments.x * moments.x);\n    variance = max(variance, minVariance);\n\n    // Compute probabilistic upper bound\n    float d = mean - moments.x;\n    float pMax = variance / (variance + (d * d));\n\n    pMax = reduceLightBleeding(pMax, lightBleedingReduction);\n\n    // One-tailed Chebyshev\n    return (mean <= moments.x ? 1.0 : pMax);\n}\n\nfloat calculateEVSM(vec3 moments, float Z, float vsmBias, float exponent) {\n    Z = 2.0 * Z - 1.0;\n    float warpedDepth = exp(exponent * Z);\n\n    moments.xy += vec2(warpedDepth, warpedDepth*warpedDepth) * (1.0 - moments.z);\n\n    float VSMBias = vsmBias;//0.01 * 0.25;\n    float depthScale = VSMBias * exponent * warpedDepth;\n    float minVariance1 = depthScale * depthScale;\n    return chebyshevUpperBound(moments.xy, warpedDepth, minVariance1, 0.1);\n}\n";

	var skinBatchConstVS = "\nattribute float vertex_boneIndices;\n\nuniform vec4 matrix_pose[BONE_LIMIT * 3];\n\nmat4 getBoneMatrix(const in float i) {\n    // read 4x3 matrix\n    vec4 v1 = matrix_pose[int(3.0 * i)];\n    vec4 v2 = matrix_pose[int(3.0 * i + 1.0)];\n    vec4 v3 = matrix_pose[int(3.0 * i + 2.0)];\n\n    // transpose to 4x4 matrix\n    return mat4(\n        v1.x, v2.x, v3.x, 0,\n        v1.y, v2.y, v3.y, 0,\n        v1.z, v2.z, v3.z, 0,\n        v1.w, v2.w, v3.w, 1\n    );\n}\n";

	var skinBatchTexVS = "\nattribute float vertex_boneIndices;\n\nuniform highp sampler2D texture_poseMap;\nuniform vec4 texture_poseMapSize;\n\nmat4 getBoneMatrix(const in float i) {\n    float j = i * 3.0;\n    float dx = texture_poseMapSize.z;\n    float dy = texture_poseMapSize.w;\n\n    float y = floor(j * dx);\n    float x = j - (y * texture_poseMapSize.x);\n    y = dy * (y + 0.5);\n\n    // read elements of 4x3 matrix\n    vec4 v1 = texture2D(texture_poseMap, vec2(dx * (x + 0.5), y));\n    vec4 v2 = texture2D(texture_poseMap, vec2(dx * (x + 1.5), y));\n    vec4 v3 = texture2D(texture_poseMap, vec2(dx * (x + 2.5), y));\n\n    // transpose to 4x4 matrix\n    return mat4(\n        v1.x, v2.x, v3.x, 0,\n        v1.y, v2.y, v3.y, 0,\n        v1.z, v2.z, v3.z, 0,\n        v1.w, v2.w, v3.w, 1\n    );\n}\n";

	var skinConstVS = "\nattribute vec4 vertex_boneWeights;\nattribute vec4 vertex_boneIndices;\n\nuniform vec4 matrix_pose[BONE_LIMIT * 3];\n\nvoid getBoneMatrix(const in float i, out vec4 v1, out vec4 v2, out vec4 v3) {\n    // read 4x3 matrix\n    v1 = matrix_pose[int(3.0 * i)];\n    v2 = matrix_pose[int(3.0 * i + 1.0)];\n    v3 = matrix_pose[int(3.0 * i + 2.0)];\n}\n\nmat4 getSkinMatrix(const in vec4 indices, const in vec4 weights) {\n    // get 4 bone matrices\n    vec4 a1, a2, a3;\n    getBoneMatrix(indices.x, a1, a2, a3);\n\n    vec4 b1, b2, b3;\n    getBoneMatrix(indices.y, b1, b2, b3);\n\n    vec4 c1, c2, c3;\n    getBoneMatrix(indices.z, c1, c2, c3);\n\n    vec4 d1, d2, d3;\n    getBoneMatrix(indices.w, d1, d2, d3);\n\n    // multiply them by weights and add up to get final 4x3 matrix\n    vec4 v1 = a1 * weights.x + b1 * weights.y + c1 * weights.z + d1 * weights.w;\n    vec4 v2 = a2 * weights.x + b2 * weights.y + c2 * weights.z + d2 * weights.w;\n    vec4 v3 = a3 * weights.x + b3 * weights.y + c3 * weights.z + d3 * weights.w;\n\n    // add up weights\n    float one = dot(weights, vec4(1.0));\n\n    // transpose to 4x4 matrix\n    return mat4(\n        v1.x, v2.x, v3.x, 0,\n        v1.y, v2.y, v3.y, 0,\n        v1.z, v2.z, v3.z, 0,\n        v1.w, v2.w, v3.w, one\n    );\n}\n";

	var skinTexVS = "\nattribute vec4 vertex_boneWeights;\nattribute vec4 vertex_boneIndices;\n\nuniform highp sampler2D texture_poseMap;\nuniform vec4 texture_poseMapSize;\n\nvoid getBoneMatrix(const in float i, out vec4 v1, out vec4 v2, out vec4 v3) {\n    float j = i * 3.0;\n    float dx = texture_poseMapSize.z;\n    float dy = texture_poseMapSize.w;\n    \n    float y = floor(j * dx);\n    float x = j - (y * texture_poseMapSize.x);\n    y = dy * (y + 0.5);\n\n    // read elements of 4x3 matrix\n    v1 = texture2D(texture_poseMap, vec2(dx * (x + 0.5), y));\n    v2 = texture2D(texture_poseMap, vec2(dx * (x + 1.5), y));\n    v3 = texture2D(texture_poseMap, vec2(dx * (x + 2.5), y));\n}\n\nmat4 getSkinMatrix(const in vec4 indices, const in vec4 weights) {\n    // get 4 bone matrices\n    vec4 a1, a2, a3;\n    getBoneMatrix(indices.x, a1, a2, a3);\n\n    vec4 b1, b2, b3;\n    getBoneMatrix(indices.y, b1, b2, b3);\n\n    vec4 c1, c2, c3;\n    getBoneMatrix(indices.z, c1, c2, c3);\n\n    vec4 d1, d2, d3;\n    getBoneMatrix(indices.w, d1, d2, d3);\n\n    // multiply them by weights and add up to get final 4x3 matrix\n    vec4 v1 = a1 * weights.x + b1 * weights.y + c1 * weights.z + d1 * weights.w;\n    vec4 v2 = a2 * weights.x + b2 * weights.y + c2 * weights.z + d2 * weights.w;\n    vec4 v3 = a3 * weights.x + b3 * weights.y + c3 * weights.z + d3 * weights.w;\n\n    // add up weights\n    float one = dot(weights, vec4(1.0));\n\n    // transpose to 4x4 matrix\n    return mat4(\n        v1.x, v2.x, v3.x, 0,\n        v1.y, v2.y, v3.y, 0,\n        v1.z, v2.z, v3.z, 0,\n        v1.w, v2.w, v3.w, one\n    );\n}\n";

	var skyboxEnvPS = "\nvarying vec3 vViewDir;\n\nuniform sampler2D texture_envAtlas;\nuniform float mipLevel;\n\nvoid main(void) {\n    vec3 dir = vViewDir * vec3(-1.0, 1.0, 1.0);\n    vec2 uv = toSphericalUv(normalize(dir));\n\n    vec3 linear = $DECODE(texture2D(texture_envAtlas, mapRoughnessUv(uv, mipLevel)));\n\n    gl_FragColor = vec4(gammaCorrectOutput(toneMap(processEnvironment(linear))), 1.0);\n}\n";

	var skyboxHDRPS = "\nvarying vec3 vViewDir;\n\nuniform samplerCube texture_cubeMap;\n\nvoid main(void) {\n    vec3 dir=vViewDir;\n    dir.x *= -1.0;\n\n    vec3 linear = $DECODE(textureCube(texture_cubeMap, fixSeamsStatic(dir, $FIXCONST)));\n\n    gl_FragColor = vec4(gammaCorrectOutput(toneMap(processEnvironment(linear))), 1.0);\n}\n";

	var skyboxVS = "\nattribute vec3 aPosition;\n\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\n\nuniform mat4 matrix_projectionSkybox;\nuniform mat3 cubeMapRotationMatrix;\n\nvarying vec3 vViewDir;\n\nvoid main(void) {\n    mat4 view = matrix_view;\n    view[3][0] = view[3][1] = view[3][2] = 0.0;\n    gl_Position = matrix_projectionSkybox * view * vec4(aPosition, 1.0);\n\n    // Force skybox to far Z, regardless of the clip planes on the camera\n    // Subtract a tiny fudge factor to ensure floating point errors don't\n    // still push pixels beyond far Z. See:\n    // http://www.opengl.org/discussion_boards/showthread.php/171867-skybox-problem\n\n    gl_Position.z = gl_Position.w - 0.00001;\n    vViewDir = aPosition * cubeMapRotationMatrix;\n}\n";

	var specularPS = "\n\n#ifdef MAPCOLOR\nuniform vec3 material_specular;\n#endif\n\n#ifdef MAPTEXTURE\nuniform sampler2D texture_specularMap;\n#endif\n\nvoid getSpecularity() {\n    vec3 specularColor = vec3(1,1,1);\n\n    #ifdef MAPCOLOR\n    specularColor *= material_specular;\n    #endif\n\n    #ifdef MAPTEXTURE\n    specularColor *= $DECODE(texture2DBias(texture_specularMap, $UV, textureBias)).$CH;\n    #endif\n\n    #ifdef MAPVERTEX\n    specularColor *= saturate(vVertexColor.$VC);\n    #endif\n\n    dSpecularity = specularColor;\n}\n";

	var sphericalPS = "\n// equirectangular helper functions\nconst float PI = 3.141592653589793;\n\nvec2 toSpherical(vec3 dir) {\n    return vec2(dir.xz == vec2(0.0) ? 0.0 : atan(dir.x, dir.z), asin(dir.y));\n}\n\nvec2 toSphericalUv(vec3 dir) {\n    vec2 uv = toSpherical(dir) / vec2(PI * 2.0, PI) + 0.5;\n    return vec2(uv.x, 1.0 - uv.y);\n}\n";

	var specularityFactorPS = "\n\n#ifdef MAPFLOAT\nuniform float material_specularityFactor;\n#endif\n\n#ifdef MAPTEXTURE\nuniform sampler2D texture_specularityFactorMap;\n#endif\n\nvoid getSpecularityFactor() {\n    float specularityFactor = 1.0;\n\n    #ifdef MAPFLOAT\n    specularityFactor *= material_specularityFactor;\n    #endif\n\n    #ifdef MAPTEXTURE\n    specularityFactor *= texture2DBias(texture_specularityFactorMap, $UV, textureBias).$CH;\n    #endif\n\n    #ifdef MAPVERTEX\n    specularityFactor *= saturate(vVertexColor.$VC);\n    #endif\n\n    dSpecularityFactor = specularityFactor;\n}\n";

	var spotPS = "\nfloat getSpotEffect(vec3 lightSpotDirW, float lightInnerConeAngle, float lightOuterConeAngle) {\n    float cosAngle = dot(dLightDirNormW, lightSpotDirW);\n    return smoothstep(lightOuterConeAngle, lightInnerConeAngle, cosAngle);\n}\n";

	var startPS = "\nvoid main(void) {\n    dReflection = vec4(0);\n\n    #ifdef LIT_CLEARCOAT\n    ccSpecularLight = vec3(0);\n    ccReflection = vec4(0);\n    #endif\n";

	var startVS = "\nvoid main(void) {\n    gl_Position = getPosition();\n";

	var startNineSlicedPS = "\n    nineSlicedUv = vUv0;\n    nineSlicedUv.y = 1.0 - nineSlicedUv.y;\n\n";

	var startNineSlicedTiledPS = "\n    vec2 tileMask = step(vMask, vec2(0.99999));\n    vec2 tileSize = 0.5 * (innerOffset.xy + innerOffset.zw);\n    vec2 tileScale = vec2(1.0) / (vec2(1.0) - tileSize);\n    vec2 clampedUv = mix(innerOffset.xy * 0.5, vec2(1.0) - innerOffset.zw * 0.5, fract((vTiledUv - tileSize) * tileScale));\n    clampedUv = clampedUv * atlasRect.zw + atlasRect.xy;\n    nineSlicedUv = vUv0 * tileMask + clampedUv * (vec2(1.0) - tileMask);\n    nineSlicedUv.y = 1.0 - nineSlicedUv.y;\n    \n";

	var storeEVSMPS = "\nfloat exponent = VSM_EXPONENT;\n\ndepth = 2.0 * depth - 1.0;\ndepth =  exp(exponent * depth);\ngl_FragColor = vec4(depth, depth*depth, 1.0, 1.0);\n";

	var tangentBinormalVS = "\nvec3 getTangent() {\n    return normalize(dNormalMatrix * vertex_tangent.xyz);\n}\n\nvec3 getBinormal() {\n    return cross(vNormalW, vTangentW) * vertex_tangent.w;\n}\n\nvec3 getObjectSpaceUp() {\n    return normalize(dNormalMatrix * vec3(0, 1, 0));\n}\n";

	var TBNPS = "\nvoid getTBN() {\n    dTBN = mat3(normalize(dTangentW), normalize(dBinormalW), normalize(dVertexNormalW));\n}\n";

	var TBNderivativePS = "\nuniform float tbnBasis;\n\n// http://www.thetenthplanet.de/archives/1180\nvoid getTBN() {\n    vec2 uv = $UV;\n\n    // get edge vectors of the pixel triangle\n    vec3 dp1 = dFdx( vPositionW );\n    vec3 dp2 = dFdy( vPositionW );\n    vec2 duv1 = dFdx( uv );\n    vec2 duv2 = dFdy( uv );\n\n    // solve the linear system\n    vec3 dp2perp = cross( dp2, dVertexNormalW );\n    vec3 dp1perp = cross( dVertexNormalW, dp1 );\n    vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;\n    vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;\n\n    // construct a scale-invariant frame\n    float denom = max( dot(T,T), dot(B,B) );\n    float invmax = (denom == 0.0) ? 0.0 : tbnBasis / sqrt( denom );\n    dTBN = mat3(T * invmax, -B * invmax, dVertexNormalW );\n}\n";

	var TBNfastPS = "\nvoid getTBN() {\n    dTBN = mat3(dTangentW, dBinormalW, dVertexNormalW);\n}\n";

	var TBNObjectSpacePS = "\nvoid getTBN() {\n\n    vec3 B = cross(dVertexNormalW, vObjectSpaceUpW);\n    vec3 T = cross(dVertexNormalW, B);\n\n    if (dot(B,B)==0.0) // deal with case when vObjectSpaceUpW dVertexNormalW are parallel\n    {\n        float major=max(max(dVertexNormalW.x, dVertexNormalW.y),dVertexNormalW.z);\n\n        if (dVertexNormalW.x==major)\n        {\n            B=cross(dVertexNormalW, vec3(0,1,0));\n            T=cross(dVertexNormalW, B);\n        }\n        else if (dVertexNormalW.y==major)\n        {\n            B=cross(dVertexNormalW, vec3(0,0,1));\n            T=cross(dVertexNormalW, B);\n        }\n        else if (dVertexNormalW.z==major)\n        {\n            B=cross(dVertexNormalW, vec3(1,0,0));\n            T=cross(dVertexNormalW, B);\n        }\n    }\n\n    dTBN = mat3(normalize(T), normalize(B), normalize(dVertexNormalW));\n}\n";

	var textureSamplePS = "\nvec4 texture2DSRGB(sampler2D tex, vec2 uv) {\n    return gammaCorrectInput(texture2D(tex, uv));\n}\n\nvec4 texture2DSRGB(sampler2D tex, vec2 uv, float bias) {\n    return gammaCorrectInput(texture2D(tex, uv, bias));\n}\n\nvec3 texture2DRGBM(sampler2D tex, vec2 uv) {\n    return decodeRGBM(texture2D(tex, uv));\n}\n\nvec3 texture2DRGBM(sampler2D tex, vec2 uv, float bias) {\n    return decodeRGBM(texture2D(tex, uv, bias));\n}\n\nvec3 texture2DRGBE(sampler2D tex, vec2 uv) {\n    return decodeRGBM(texture2D(tex, uv));\n}\n\nvec3 texture2DRGBE(sampler2D tex, vec2 uv, float bias) {\n    return decodeRGBM(texture2D(tex, uv, bias));\n}\n";

	var thicknessPS = "\n#ifdef MAPFLOAT\nuniform float material_thickness;\n#endif\n\n#ifdef MAPTEXTURE\nuniform sampler2D texture_thicknessMap;\n#endif\n\nvoid getThickness() {\n    dThickness = 1.0;\n\n    #ifdef MAPFLOAT\n    dThickness *= material_thickness;\n    #endif\n\n    #ifdef MAPTEXTURE\n    dThickness *= texture2DBias(texture_thicknessMap, $UV, textureBias).$CH;\n    #endif\n\n    #ifdef MAPVERTEX\n    dThickness *= saturate(vVertexColor.$VC);\n    #endif\n}\n";

	var tonemappingAcesPS = "\nuniform float exposure;\n\nvec3 toneMap(vec3 color) {\n    float tA = 2.51;\n    float tB = 0.03;\n    float tC = 2.43;\n    float tD = 0.59;\n    float tE = 0.14;\n    vec3 x = color * exposure;\n    return (x*(tA*x+tB))/(x*(tC*x+tD)+tE);\n}\n";

	var tonemappingAces2PS = "\nuniform float exposure;\n\n// ACES approximation by Stephen Hill\n\n// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT\nconst mat3 ACESInputMat = mat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\n// ODT_SAT => XYZ => D60_2_D65 => sRGB\nconst mat3 ACESOutputMat = mat3(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit(vec3 v) {\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\n\nvec3 toneMap(vec3 color) {\n    color *= exposure;\n    color = color * ACESInputMat;\n\n    // Apply RRT and ODT\n    color = RRTAndODTFit(color);\n    color = color * ACESOutputMat;\n\n    // Clamp to [0, 1]\n    color = clamp(color, 0.0, 1.0);\n\n    return color;\n}\n";

	var tonemappingFilmicPS = "\nconst float A =  0.15;\nconst float B =  0.50;\nconst float C =  0.10;\nconst float D =  0.20;\nconst float E =  0.02;\nconst float F =  0.30;\nconst float W =  11.2;\n\nuniform float exposure;\n\nvec3 uncharted2Tonemap(vec3 x) {\n   return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n}\n\nvec3 toneMap(vec3 color) {\n    color = uncharted2Tonemap(color * exposure);\n    vec3 whiteScale = 1.0 / uncharted2Tonemap(vec3(W,W,W));\n    color = color * whiteScale;\n\n    return color;\n}\n";

	var tonemappingHejlPS = "\nuniform float exposure;\n\nvec3 toneMap(vec3 color) {\n    color *= exposure;\n    const float  A = 0.22, B = 0.3, C = .1, D = 0.2, E = .01, F = 0.3;\n    const float Scl = 1.25;\n\n    vec3 h = max( vec3(0.0), color - vec3(0.004) );\n    return (h*((Scl*A)*h+Scl*vec3(C*B,C*B,C*B))+Scl*vec3(D*E,D*E,D*E)) / (h*(A*h+vec3(B,B,B))+vec3(D*F,D*F,D*F)) - Scl*vec3(E/F,E/F,E/F);\n}\n";

	var tonemappingLinearPS = "\nuniform float exposure;\n\nvec3 toneMap(vec3 color) {\n    return color * exposure;\n}\n";

	var tonemappingNonePS = "\nvec3 toneMap(vec3 color) {\n    return color;\n}\n";

	var transformVS = "\n#ifdef PIXELSNAP\nuniform vec4 uScreenSize;\n#endif\n\n#ifdef SCREENSPACE\nuniform float projectionFlipY;\n#endif\n\n#ifdef MORPHING\nuniform vec4 morph_weights_a;\nuniform vec4 morph_weights_b;\n#endif\n\n#ifdef MORPHING_TEXTURE_BASED\nuniform vec4 morph_tex_params;\n\nvec2 getTextureMorphCoords() {\n    float vertexId = morph_vertex_id;\n    vec2 textureSize = morph_tex_params.xy;\n    vec2 invTextureSize = morph_tex_params.zw;\n\n    // turn vertexId into int grid coordinates\n    float morphGridV = floor(vertexId * invTextureSize.x);\n    float morphGridU = vertexId - (morphGridV * textureSize.x);\n\n    // convert grid coordinates to uv coordinates with half pixel offset\n    return (vec2(morphGridU, morphGridV) * invTextureSize) + (0.5 * invTextureSize);\n}\n#endif\n\n#ifdef MORPHING_TEXTURE_BASED_POSITION\nuniform highp sampler2D morphPositionTex;\n#endif\n\nmat4 getModelMatrix() {\n    #ifdef DYNAMICBATCH\n    return getBoneMatrix(vertex_boneIndices);\n    #elif defined(SKIN)\n    return matrix_model * getSkinMatrix(vertex_boneIndices, vertex_boneWeights);\n    #elif defined(INSTANCING)\n    return mat4(instance_line1, instance_line2, instance_line3, instance_line4);\n    #else\n    return matrix_model;\n    #endif\n}\n\nvec4 getPosition() {\n    dModelMatrix = getModelMatrix();\n    vec3 localPos = vertex_position;\n\n    #ifdef NINESLICED\n    // outer and inner vertices are at the same position, scale both\n    localPos.xz *= outerScale;\n\n    // offset inner vertices inside\n    // (original vertices must be in [-1;1] range)\n    vec2 positiveUnitOffset = clamp(vertex_position.xz, vec2(0.0), vec2(1.0));\n    vec2 negativeUnitOffset = clamp(-vertex_position.xz, vec2(0.0), vec2(1.0));\n    localPos.xz += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;\n\n    vTiledUv = (localPos.xz - outerScale + innerOffset.xy) * -0.5 + 1.0; // uv = local pos - inner corner\n\n    localPos.xz *= -0.5; // move from -1;1 to -0.5;0.5\n    localPos = localPos.xzy;\n    #endif\n\n    #ifdef MORPHING\n    #ifdef MORPHING_POS03\n    localPos.xyz += morph_weights_a[0] * morph_pos0;\n    localPos.xyz += morph_weights_a[1] * morph_pos1;\n    localPos.xyz += morph_weights_a[2] * morph_pos2;\n    localPos.xyz += morph_weights_a[3] * morph_pos3;\n    #endif // MORPHING_POS03\n    #ifdef MORPHING_POS47\n    localPos.xyz += morph_weights_b[0] * morph_pos4;\n    localPos.xyz += morph_weights_b[1] * morph_pos5;\n    localPos.xyz += morph_weights_b[2] * morph_pos6;\n    localPos.xyz += morph_weights_b[3] * morph_pos7;\n    #endif // MORPHING_POS47\n    #endif // MORPHING\n\n    #ifdef MORPHING_TEXTURE_BASED_POSITION\n    // apply morph offset from texture\n    vec2 morphUV = getTextureMorphCoords();\n    vec3 morphPos = texture2D(morphPositionTex, morphUV).xyz;\n    localPos += morphPos;\n    #endif\n\n    vec4 posW = dModelMatrix * vec4(localPos, 1.0);\n    #ifdef SCREENSPACE\n    posW.zw = vec2(0.0, 1.0);\n    #endif\n    dPositionW = posW.xyz;\n\n    vec4 screenPos;\n    #ifdef UV1LAYOUT\n    screenPos = vec4(vertex_texCoord1.xy * 2.0 - 1.0, 0.5, 1);\n    #else\n    #ifdef SCREENSPACE\n    screenPos = posW;\n    screenPos.y *= projectionFlipY;\n    #else\n    screenPos = matrix_viewProjection * posW;\n    #endif\n\n    #ifdef PIXELSNAP\n    // snap vertex to a pixel boundary\n    screenPos.xy = (screenPos.xy * 0.5) + 0.5;\n    screenPos.xy *= uScreenSize.xy;\n    screenPos.xy = floor(screenPos.xy);\n    screenPos.xy *= uScreenSize.zw;\n    screenPos.xy = (screenPos.xy * 2.0) - 1.0;\n    #endif\n    #endif\n\n    return screenPos;\n}\n\nvec3 getWorldPosition() {\n    return dPositionW;\n}\n";

	var transformDeclVS = "\nattribute vec3 vertex_position;\n\nuniform mat4 matrix_model;\nuniform mat4 matrix_viewProjection;\n\nvec3 dPositionW;\nmat4 dModelMatrix;\n";

	var transmissionPS = "\n\n#ifdef MAPFLOAT\nuniform float material_refraction;\n#endif\n\n#ifdef MAPTEXTURE\nuniform sampler2D texture_refractionMap;\n#endif\n\nvoid getRefraction() {\n    float refraction = 1.0;\n\n    #ifdef MAPFLOAT\n    refraction = material_refraction;\n    #endif\n\n    #ifdef MAPTEXTURE\n    refraction *= gammaCorrectInput(texture2DBias(texture_refractionMap, $UV, textureBias)).$CH;\n    #endif\n\n    #ifdef MAPVERTEX\n    refraction *= saturate(vVertexColor.$VC);\n    #endif\n\n    dTransmission = refraction;\n}\n";

	var uv0VS = "\n#ifdef NINESLICED\nvec2 getUv0() {\n    vec2 uv = vertex_position.xz;\n\n    // offset inner vertices inside\n    // (original vertices must be in [-1;1] range)\n    vec2 positiveUnitOffset = clamp(vertex_position.xz, vec2(0.0), vec2(1.0));\n    vec2 negativeUnitOffset = clamp(-vertex_position.xz, vec2(0.0), vec2(1.0));\n    uv += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;\n\n    uv = uv * -0.5 + 0.5;\n    uv = uv * atlasRect.zw + atlasRect.xy;\n\n    vMask = vertex_texCoord0.xy;\n\n    return uv;\n}\n#else\nvec2 getUv0() {\n    return vertex_texCoord0;\n}\n#endif\n";

	var uv1VS = "\nvec2 getUv1() {\n    return vertex_texCoord1;\n}\n";

	var viewDirPS = "\nvoid getViewDir() {\n    dViewDirW = normalize(view_position - vPositionW);\n}\n";

	var viewNormalVS = "\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\n\nvec3 getViewNormal() {\n    return mat3(matrix_view) * vNormalW;\n}\n";

	var webgpuPS = "\n\nlayout(location = 0) out highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n\n#define texture2D(res, uv) texture(sampler2D(res, res ## _sampler), uv)\n#define texture2DBias(res, uv, bias) texture(sampler2D(res, res ## _sampler), uv, bias)\n\n// TODO: implement other texture sampling macros\n// #define textureCube texture\n// #define texture2DProj textureProj\n// #define texture2DLodEXT textureLod\n// #define texture2DProjLodEXT textureProjLod\n// #define textureCubeLodEXT textureLod\n// #define texture2DGradEXT textureGrad\n// #define texture2DProjGradEXT textureProjGrad\n// #define textureCubeGradEXT textureGrad\n#define GL2\n#define SUPPORTS_TEXLOD\n";

	var webgpuVS = "\n#define texture2D(res, uv) texture(sampler2D(res, res ## _sampler), uv)\n\n#define GL2\n#define VERTEXSHADER\n";

	var shaderChunks = {
	  alphaTestPS: alphaTestPS,
	  ambientConstantPS: ambientConstantPS,
	  ambientEnvPS: ambientEnvPS,
	  ambientSHPS: ambientSHPS,
	  aoPS: aoPS,
	  aoDiffuseOccPS: aoDiffuseOccPS,
	  aoSpecOccPS: aoSpecOccPS,
	  aoSpecOccConstPS: aoSpecOccConstPS,
	  aoSpecOccConstSimplePS: aoSpecOccConstSimplePS,
	  aoSpecOccSimplePS: aoSpecOccSimplePS,
	  basePS: basePS,
	  baseVS: baseVS,
	  baseNineSlicedPS: baseNineSlicedPS,
	  baseNineSlicedVS: baseNineSlicedVS,
	  baseNineSlicedTiledPS: baseNineSlicedTiledPS,
	  biasConstPS: biasConstPS,
	  blurVSMPS: blurVSMPS,
	  clearCoatPS: clearCoatPS,
	  clearCoatGlossPS: clearCoatGlossPS,
	  clearCoatNormalPS: clearCoatNormalPS,
	  clusteredLightCookiesPS: clusteredLightCookiesPS,
	  clusteredLightShadowsPS: clusteredLightShadowsPS,
	  clusteredLightUtilsPS: clusteredLightUtilsPS,
	  clusteredLightPS: clusteredLightPS,
	  combinePS: combinePS,
	  cookiePS: cookiePS,
	  cubeMapProjectBoxPS: cubeMapProjectBoxPS,
	  cubeMapProjectNonePS: cubeMapProjectNonePS,
	  cubeMapRotatePS: cubeMapRotatePS,
	  detailModesPS: detailModesPS,
	  diffusePS: diffusePS,
	  diffuseDetailMapPS: diffuseDetailMapPS,
	  decodePS: decodePS,
	  emissivePS: emissivePS,
	  encodePS: encodePS,
	  endPS: endPS,
	  endVS: endVS,
	  envAtlasPS: envAtlasPS,
	  envConstPS: envConstPS,
	  envMultiplyPS: envMultiplyPS,
	  extensionPS: extensionPS,
	  extensionVS: extensionVS,
	  falloffInvSquaredPS: falloffInvSquaredPS,
	  falloffLinearPS: falloffLinearPS,
	  fixCubemapSeamsNonePS: fixCubemapSeamsNonePS,
	  fixCubemapSeamsStretchPS: fixCubemapSeamsStretchPS,
	  floatUnpackingPS: floatUnpackingPS,
	  fogExpPS: fogExpPS,
	  fogExp2PS: fogExp2PS,
	  fogLinearPS: fogLinearPS,
	  fogNonePS: fogNonePS,
	  fresnelSchlickPS: fresnelSchlickPS,
	  fullscreenQuadPS: fullscreenQuadPS,
	  fullscreenQuadVS: fullscreenQuadVS,
	  gamma1_0PS: gamma1_0PS,
	  gamma2_2PS: gamma2_2PS,
	  gles2PS: gles2PS,
	  gles3PS: gles3PS,
	  gles3VS: gles3VS,
	  glossPS: glossPS,
	  instancingVS: instancingVS,
	  lightDiffuseLambertPS: lightDiffuseLambertPS,
	  lightDirPointPS: lightDirPointPS,
	  lightmapAddPS: lightmapAddPS,
	  lightmapDirAddPS: lightmapDirAddPS,
	  lightmapDirPS: lightmapDirPS,
	  lightmapSinglePS: lightmapSinglePS,
	  lightSpecularAnisoGGXPS: lightSpecularAnisoGGXPS,
	  lightSpecularBlinnPS: lightSpecularBlinnPS,
	  lightSpecularPhongPS: lightSpecularPhongPS,
	  lightSheenPS: lightSheenPS,
	  ltc: ltc,
	  metalnessPS: metalnessPS,
	  metalnessModulatePS: metalnessModulatePS,
	  msdfPS: msdfPS,
	  msdfVS: msdfVS,
	  normalVS: normalVS,
	  normalDetailMapPS: normalDetailMapPS,
	  normalInstancedVS: normalInstancedVS,
	  normalMapPS: normalMapPS,
	  normalSkinnedVS: normalSkinnedVS,
	  normalXYPS: normalXYPS,
	  normalXYZPS: normalXYZPS,
	  opacityPS: opacityPS,
	  outputAlphaPS: outputAlphaPS,
	  outputAlphaOpaquePS: outputAlphaOpaquePS,
	  outputAlphaPremulPS: outputAlphaPremulPS,
	  outputTex2DPS: outputTex2DPS,
	  packDepthPS: packDepthPS,
	  sheenPS: sheenPS,
	  sheenGlossPS: sheenGlossPS,
	  parallaxPS: parallaxPS,
	  particlePS: particlePS,
	  particleVS: particleVS,
	  particleAnimFrameClampVS: particleAnimFrameClampVS,
	  particleAnimFrameLoopVS: particleAnimFrameLoopVS,
	  particleAnimTexVS: particleAnimTexVS,
	  particleInputFloatPS: particleInputFloatPS,
	  particleInputRgba8PS: particleInputRgba8PS,
	  particleOutputFloatPS: particleOutputFloatPS,
	  particleOutputRgba8PS: particleOutputRgba8PS,
	  particleUpdaterAABBPS: particleUpdaterAABBPS,
	  particleUpdaterEndPS: particleUpdaterEndPS,
	  particleUpdaterInitPS: particleUpdaterInitPS,
	  particleUpdaterNoRespawnPS: particleUpdaterNoRespawnPS,
	  particleUpdaterOnStopPS: particleUpdaterOnStopPS,
	  particleUpdaterRespawnPS: particleUpdaterRespawnPS,
	  particleUpdaterSpherePS: particleUpdaterSpherePS,
	  particleUpdaterStartPS: particleUpdaterStartPS,
	  particle_billboardVS: particle_billboardVS,
	  particle_blendAddPS: particle_blendAddPS,
	  particle_blendMultiplyPS: particle_blendMultiplyPS,
	  particle_blendNormalPS: particle_blendNormalPS,
	  particle_cpuVS: particle_cpuVS,
	  particle_cpu_endVS: particle_cpu_endVS,
	  particle_customFaceVS: particle_customFaceVS,
	  particle_endPS: particle_endPS,
	  particle_endVS: particle_endVS,
	  particle_halflambertPS: particle_halflambertPS,
	  particle_initVS: particle_initVS,
	  particle_lambertPS: particle_lambertPS,
	  particle_lightingPS: particle_lightingPS,
	  particle_localShiftVS: particle_localShiftVS,
	  particle_meshVS: particle_meshVS,
	  particle_normalVS: particle_normalVS,
	  particle_normalMapPS: particle_normalMapPS,
	  particle_pointAlongVS: particle_pointAlongVS,
	  particle_softPS: particle_softPS,
	  particle_softVS: particle_softVS,
	  particle_stretchVS: particle_stretchVS,
	  particle_TBNVS: particle_TBNVS,
	  particle_wrapVS: particle_wrapVS,
	  precisionTestPS: precisionTestPS,
	  precisionTest2PS: precisionTest2PS,
	  reflDirPS: reflDirPS,
	  reflDirAnisoPS: reflDirAnisoPS,
	  reflectionCCPS: reflectionCCPS,
	  reflectionCubePS: reflectionCubePS,
	  reflectionEnvHQPS: reflectionEnvHQPS,
	  reflectionEnvPS: reflectionEnvPS,
	  reflectionSpherePS: reflectionSpherePS,
	  reflectionSphereLowPS: reflectionSphereLowPS,
	  reflectionSheenPS: reflectionSheenPS,
	  refractionCubePS: refractionCubePS,
	  refractionDynamicPS: refractionDynamicPS,
	  reprojectPS: reprojectPS,
	  screenDepthPS: screenDepthPS,
	  shadowCascadesPS: shadowCascadesPS,
	  shadowCommonPS: shadowCommonPS,
	  shadowCoordPS: shadowCoordPS,
	  shadowCoordPerspZbufferPS: shadowCoordPerspZbufferPS,
	  shadowEVSMPS: shadowEVSMPS,
	  shadowEVSMnPS: shadowEVSMnPS,
	  shadowStandardPS: shadowStandardPS,
	  shadowStandardGL2PS: shadowStandardGL2PS,
	  shadowVSM8PS: shadowVSM8PS,
	  shadowVSM_commonPS: shadowVSM_commonPS,
	  skinBatchConstVS: skinBatchConstVS,
	  skinBatchTexVS: skinBatchTexVS,
	  skinConstVS: skinConstVS,
	  skinTexVS: skinTexVS,
	  skyboxEnvPS: skyboxEnvPS,
	  skyboxHDRPS: skyboxHDRPS,
	  skyboxVS: skyboxVS,
	  specularPS: specularPS,
	  sphericalPS: sphericalPS,
	  specularityFactorPS: specularityFactorPS,
	  spotPS: spotPS,
	  startPS: startPS,
	  startVS: startVS,
	  startNineSlicedPS: startNineSlicedPS,
	  startNineSlicedTiledPS: startNineSlicedTiledPS,
	  storeEVSMPS: storeEVSMPS,
	  tangentBinormalVS: tangentBinormalVS,
	  TBNPS: TBNPS,
	  TBNderivativePS: TBNderivativePS,
	  TBNfastPS: TBNfastPS,
	  TBNObjectSpacePS: TBNObjectSpacePS,
	  textureSamplePS: textureSamplePS,
	  thicknessPS: thicknessPS,
	  tonemappingAcesPS: tonemappingAcesPS,
	  tonemappingAces2PS: tonemappingAces2PS,
	  tonemappingFilmicPS: tonemappingFilmicPS,
	  tonemappingHejlPS: tonemappingHejlPS,
	  tonemappingLinearPS: tonemappingLinearPS,
	  tonemappingNonePS: tonemappingNonePS,
	  transformVS: transformVS,
	  transformDeclVS: transformDeclVS,
	  transmissionPS: transmissionPS,
	  uv0VS: uv0VS,
	  uv1VS: uv1VS,
	  viewDirPS: viewDirPS,
	  viewNormalVS: viewNormalVS,
	  webgpuPS: webgpuPS,
	  webgpuVS: webgpuVS
	};

	var ShaderPass = function () {
	  function ShaderPass() {}

	  ShaderPass.getType = function getType(shaderPass) {
	    switch (shaderPass) {
	      case SHADER_FORWARD:
	      case SHADER_FORWARDHDR:
	        return SHADERTYPE_FORWARD;

	      case SHADER_DEPTH:
	        return SHADERTYPE_DEPTH;

	      case SHADER_PICK:
	        return SHADERTYPE_PICK;

	      default:
	        return shaderPass >= SHADER_SHADOW && shaderPass < SHADER_SHADOW + SHADOW_COUNT * LIGHTTYPE_COUNT ? SHADERTYPE_SHADOW : SHADERTYPE_FORWARD;
	    }
	  };

	  ShaderPass.isForward = function isForward(pass) {
	    return this.getType(pass) === SHADERTYPE_FORWARD;
	  };

	  ShaderPass.isShadow = function isShadow(pass) {
	    return this.getType(pass) === SHADERTYPE_SHADOW;
	  };

	  ShaderPass.toLightType = function toLightType(pass) {
	    var shadowMode = pass - SHADER_SHADOW;
	    return Math.floor(shadowMode / SHADOW_COUNT);
	  };

	  ShaderPass.toShadowType = function toShadowType(pass) {
	    var shadowMode = pass - SHADER_SHADOW;
	    var lightType = Math.floor(shadowMode / SHADOW_COUNT);
	    return shadowMode - lightType * SHADOW_COUNT;
	  };

	  ShaderPass.getShadow = function getShadow(lightType, shadowType) {
	    var shadowMode = shadowType + lightType * SHADOW_COUNT;
	    var pass = SHADER_SHADOW + shadowMode;
	    return pass;
	  };

	  ShaderPass.getPassShaderDefine = function getPassShaderDefine(pass) {
	    if (pass === SHADER_PICK) {
	      return '#define PICK_PASS\n';
	    } else if (pass === SHADER_DEPTH) {
	      return '#define DEPTH_PASS\n';
	    } else if (ShaderPass.isShadow(pass)) {
	      return '#define SHADOW_PASS\n';
	    }

	    return '';
	  };

	  return ShaderPass;
	}();

	function gammaCode(value, chunks) {
	  if (!chunks) chunks = shaderChunks;

	  if (value === GAMMA_SRGB || value === GAMMA_SRGBFAST) {
	    return chunks.gamma2_2PS ? chunks.gamma2_2PS : shaderChunks.gamma2_2PS;
	  } else if (value === GAMMA_SRGBHDR) {
	    return "#define HDR\n" + (chunks.gamma2_2PS ? chunks.gamma2_2PS : shaderChunks.gamma2_2PS);
	  }

	  return chunks.gamma1_0PS ? chunks.gamma1_0PS : shaderChunks.gamma1_0PS;
	}

	function tonemapCode(value, chunks) {
	  if (!chunks) chunks = shaderChunks;

	  if (value === TONEMAP_FILMIC) {
	    return chunks.tonemappingFilmicPS ? chunks.tonemappingFilmicPS : shaderChunks.tonemappingFilmicPS;
	  } else if (value === TONEMAP_LINEAR) {
	    return chunks.tonemappingLinearPS ? chunks.tonemappingLinearPS : shaderChunks.tonemappingLinearPS;
	  } else if (value === TONEMAP_HEJL) {
	    return chunks.tonemappingHejlPS ? chunks.tonemappingHejlPS : shaderChunks.tonemappingHejlPS;
	  } else if (value === TONEMAP_ACES) {
	    return chunks.tonemappingAcesPS ? chunks.tonemappingAcesPS : shaderChunks.tonemappingAcesPS;
	  } else if (value === TONEMAP_ACES2) {
	    return chunks.tonemappingAces2PS ? chunks.tonemappingAces2PS : shaderChunks.tonemappingAces2PS;
	  }

	  return chunks.tonemapingNonePS ? chunks.tonemapingNonePS : shaderChunks.tonemappingNonePS;
	}

	function fogCode(value, chunks) {
	  if (!chunks) chunks = shaderChunks;

	  if (value === 'linear') {
	    return chunks.fogLinearPS ? chunks.fogLinearPS : shaderChunks.fogLinearPS;
	  } else if (value === 'exp') {
	    return chunks.fogExpPS ? chunks.fogExpPS : shaderChunks.fogExpPS;
	  } else if (value === 'exp2') {
	    return chunks.fogExp2PS ? chunks.fogExp2PS : shaderChunks.fogExp2PS;
	  }

	  return chunks.fogNonePS ? chunks.fogNonePS : shaderChunks.fogNonePS;
	}

	function skinCode(device, chunks) {
	  if (!chunks) chunks = shaderChunks;

	  if (device.supportsBoneTextures) {
	    return chunks.skinTexVS;
	  }

	  return "#define BONE_LIMIT " + device.getBoneLimit() + "\n" + chunks.skinConstVS;
	}

	function precisionCode(device, forcePrecision, shadowPrecision) {
	  var code = '';

	  if (device.deviceType === DEVICETYPE_WEBGL) {
	    if (forcePrecision && forcePrecision !== 'highp' && forcePrecision !== 'mediump' && forcePrecision !== 'lowp') {
	      forcePrecision = null;
	    }

	    if (forcePrecision) {
	      if (forcePrecision === 'highp' && device.maxPrecision !== 'highp') {
	        forcePrecision = 'mediump';
	      }

	      if (forcePrecision === 'mediump' && device.maxPrecision === 'lowp') {
	        forcePrecision = 'lowp';
	      }
	    }

	    var precision = forcePrecision ? forcePrecision : device.precision;
	    code = "precision " + precision + " float;\n";

	    if (shadowPrecision && device.webgl2) {
	      code += "precision " + precision + " sampler2DShadow;\n";
	    }
	  }

	  return code;
	}

	function versionCode(device) {
	  if (device.deviceType === DEVICETYPE_WEBGPU) {
	    return '#version 450\n';
	  }

	  return device.webgl2 ? "#version 300 es\n" : "";
	}

	function getShaderNameCode(name) {
	  return "#define SHADER_NAME " + name + "\n";
	}

	function vertexIntro(device, name, pass, extensionCode) {
	  var code = versionCode(device);

	  if (device.deviceType === DEVICETYPE_WEBGPU) {
	    code += shaderChunks.webgpuVS;
	  } else {
	    if (extensionCode) {
	      code += extensionCode + "\n";
	    }

	    if (device.webgl2) {
	      code += shaderChunks.gles3VS;
	    }
	  }

	  code += getShaderNameCode(name);
	  code += ShaderPass.getPassShaderDefine(pass);
	  return code;
	}

	function fragmentIntro(device, name, pass, extensionCode, forcePrecision) {
	  var code = versionCode(device);

	  if (device.deviceType === DEVICETYPE_WEBGPU) {
	    code += shaderChunks.webgpuPS;
	  } else {
	    if (extensionCode) {
	      code += extensionCode + "\n";
	    }

	    if (device.webgl2) {
	      code += shaderChunks.gles3PS;
	    } else {
	      if (device.extStandardDerivatives) {
	        code += "#extension GL_OES_standard_derivatives : enable\n";
	      }

	      if (device.extTextureLod) {
	        code += "#extension GL_EXT_shader_texture_lod : enable\n";
	        code += "#define SUPPORTS_TEXLOD\n";
	      }

	      code += shaderChunks.gles2PS;
	    }
	  }

	  code += precisionCode(device, forcePrecision, true);
	  code += getShaderNameCode(name);
	  code += ShaderPass.getPassShaderDefine(pass);
	  return code;
	}

	function dummyFragmentCode() {
	  return "void main(void) {gl_FragColor = vec4(0.0);}";
	}

	function begin() {
	  return 'void main(void)\n{\n';
	}

	function end() {
	  return '}\n';
	}

	var attrib2Semantic = {
	  vertex_position: SEMANTIC_POSITION,
	  vertex_normal: SEMANTIC_NORMAL,
	  vertex_tangent: SEMANTIC_TANGENT,
	  vertex_texCoord0: SEMANTIC_TEXCOORD0,
	  vertex_texCoord1: SEMANTIC_TEXCOORD1,
	  vertex_texCoord2: SEMANTIC_TEXCOORD2,
	  vertex_texCoord3: SEMANTIC_TEXCOORD3,
	  vertex_texCoord4: SEMANTIC_TEXCOORD4,
	  vertex_texCoord5: SEMANTIC_TEXCOORD5,
	  vertex_texCoord6: SEMANTIC_TEXCOORD6,
	  vertex_texCoord7: SEMANTIC_TEXCOORD7,
	  vertex_color: SEMANTIC_COLOR,
	  vertex_boneIndices: SEMANTIC_BLENDINDICES,
	  vertex_boneWeights: SEMANTIC_BLENDWEIGHT
	};

	function collectAttribs(vsCode) {
	  var attribs = {};
	  var attrs = 0;
	  var found = vsCode.indexOf("attribute");

	  while (found >= 0) {
	    if (found > 0 && vsCode[found - 1] === "/") break;
	    var endOfLine = vsCode.indexOf(';', found);
	    var startOfAttribName = vsCode.lastIndexOf(' ', endOfLine);
	    var attribName = vsCode.substring(startOfAttribName + 1, endOfLine);
	    var semantic = attrib2Semantic[attribName];

	    if (semantic !== undefined) {
	      attribs[attribName] = semantic;
	    } else {
	      attribs[attribName] = "ATTR" + attrs;
	      attrs++;
	    }

	    found = vsCode.indexOf("attribute", found + 1);
	  }

	  return attribs;
	}

	function createShader(device, vsName, psName, useTransformFeedback) {
	  if (useTransformFeedback === void 0) {
	    useTransformFeedback = false;
	  }

	  var vsCode = shaderChunks[vsName];
	  var psCode = precisionCode(device) + "\n" + shaderChunks[psName];
	  var attribs = collectAttribs(vsCode);

	  if (device.deviceType === DEVICETYPE_WEBGPU) {
	    vsCode = versionCode(device) + shaderChunks.webgpuVS + vsCode;
	    psCode = versionCode(device) + shaderChunks.webgpuPS + psCode;
	  } else if (device.webgl2) {
	    vsCode = versionCode(device) + shaderChunks.gles3VS + vsCode;
	    psCode = versionCode(device) + shaderChunks.gles3PS + psCode;
	  }

	  return new Shader(device, {
	    attributes: attribs,
	    vshader: vsCode,
	    fshader: psCode,
	    useTransformFeedback: useTransformFeedback,
	    name: vsName + "_" + psName
	  });
	}

	function createShaderFromCode(device, vsCode, psCode, uName, useTransformFeedback, psPreamble) {
	  if (useTransformFeedback === void 0) {
	    useTransformFeedback = false;
	  }

	  if (psPreamble === void 0) {
	    psPreamble = "";
	  }

	  var shaderCache = device.programLib._cache;
	  var cached = shaderCache[uName];
	  if (cached !== undefined) return cached;
	  psCode = precisionCode(device) + "\n" + (psCode || dummyFragmentCode());
	  var attribs = collectAttribs(vsCode);

	  if (device.deviceType === DEVICETYPE_WEBGPU) {
	    vsCode = versionCode(device) + shaderChunks.webgpuVS + vsCode;
	    psCode = versionCode(device) + shaderChunks.webgpuPS + psCode;
	  } else if (device.webgl2) {
	    vsCode = versionCode(device) + shaderChunks.gles3VS + vsCode;
	    psCode = versionCode(device) + shaderChunks.gles3PS + psCode;
	  }

	  shaderCache[uName] = new Shader(device, {
	    name: uName,
	    attributes: attribs,
	    vshader: vsCode,
	    fshader: psPreamble + psCode,
	    useTransformFeedback: useTransformFeedback
	  });
	  return shaderCache[uName];
	}

	shaderChunks.collectAttribs = collectAttribs;
	shaderChunks.createShader = createShader;
	shaderChunks.createShaderFromCode = createShaderFromCode;

	var Version = function () {
	  function Version() {
	    this.globalId = 0;
	    this.revision = 0;
	  }

	  var _proto = Version.prototype;

	  _proto.equals = function equals(other) {
	    return this.globalId === other.globalId && this.revision === other.revision;
	  };

	  _proto.copy = function copy(other) {
	    this.globalId = other.globalId;
	    this.revision = other.revision;
	  };

	  _proto.reset = function reset() {
	    this.globalId = 0;
	    this.revision = 0;
	  };

	  return Version;
	}();

	var idCounter = 0;

	var VersionedObject = function () {
	  function VersionedObject() {
	    idCounter++;
	    this.version = new Version();
	    this.version.globalId = idCounter;
	  }

	  var _proto = VersionedObject.prototype;

	  _proto.increment = function increment() {
	    this.version.revision++;
	  };

	  return VersionedObject;
	}();

	var ScopeId = function () {
	  function ScopeId(name) {
	    this.name = name;
	    this.value = null;
	    this.versionObject = new VersionedObject();
	  }

	  var _proto = ScopeId.prototype;

	  _proto.toJSON = function toJSON(key) {
	    return undefined;
	  };

	  _proto.setValue = function setValue(value) {
	    this.value = value;
	    this.versionObject.increment();
	  };

	  _proto.getValue = function getValue() {
	    return this.value;
	  };

	  return ScopeId;
	}();

	var ScopeSpace = function () {
	  function ScopeSpace(name) {
	    this.name = name;
	    this.variables = new Map();
	  }

	  var _proto = ScopeSpace.prototype;

	  _proto.resolve = function resolve(name) {
	    if (!this.variables.has(name)) {
	      this.variables.set(name, new ScopeId(name));
	    }

	    return this.variables.get(name);
	  };

	  _proto.removeValue = function removeValue(value) {
	    for (var uniformName in this.variables) {
	      var uniform = this.variables[uniformName];

	      if (uniform.value === value) {
	        uniform.value = null;
	      }
	    }
	  };

	  return ScopeSpace;
	}();

	var decodeTable = {
	  'linear': 'decodeLinear',
	  'srgb': 'decodeGamma',
	  'rgbm': 'decodeRGBM',
	  'rgbe': 'decodeRGBE',
	  'rgbp': 'decodeRGBP'
	};
	var encodeTable = {
	  'linear': 'encodeLinear',
	  'srgb': 'encodeGamma',
	  'rgbm': 'encodeRGBM',
	  'rgbe': 'encodeRGBE',
	  'rgbp': 'encodeRGBP'
	};

	var ChunkUtils = function () {
	  function ChunkUtils() {}

	  ChunkUtils.decodeFunc = function decodeFunc(encoding) {
	    return decodeTable[encoding] || 'decodeGamma';
	  };

	  ChunkUtils.encodeFunc = function encodeFunc(encoding) {
	    return encodeTable[encoding] || 'encodeGamma';
	  };

	  return ChunkUtils;
	}();

	var oneDiv255 = 1 / 255;
	var floatView = new Float32Array(1);
	var int32View = new Int32Array(floatView.buffer);

	var FloatPacking = function () {
	  function FloatPacking() {}

	  FloatPacking.float2Half = function float2Half(value) {
	    floatView[0] = value;
	    var x = int32View[0];
	    var bits = x >> 16 & 0x8000;
	    var m = x >> 12 & 0x07ff;
	    var e = x >> 23 & 0xff;

	    if (e < 103) {
	      return bits;
	    }

	    if (e > 142) {
	      bits |= 0x7c00;
	      bits |= (e === 255 ? 0 : 1) && x & 0x007fffff;
	      return bits;
	    }

	    if (e < 113) {
	      m |= 0x0800;
	      bits |= (m >> 114 - e) + (m >> 113 - e & 1);
	      return bits;
	    }

	    bits |= e - 112 << 10 | m >> 1;
	    bits += m & 1;
	    return bits;
	  };

	  FloatPacking.float2Bytes = function float2Bytes(value, array, offset, numBytes) {
	    var enc1 = 255.0 * value % 1;
	    array[offset + 0] = Math.round((value % 1 - oneDiv255 * enc1) * 255);

	    if (numBytes > 1) {
	      var enc2 = 65025.0 * value % 1;
	      array[offset + 1] = Math.round((enc1 - oneDiv255 * enc2) * 255);

	      if (numBytes > 2) {
	        var enc3 = 16581375.0 * value % 1;
	        array[offset + 2] = Math.round((enc2 - oneDiv255 * enc3) * 255);

	        if (numBytes > 3) {
	          array[offset + 3] = Math.round(enc3 * 255);
	        }
	      }
	    }
	  };

	  FloatPacking.float2BytesRange = function float2BytesRange(value, array, offset, min, max, numBytes) {
	    value = math.clamp((value - min) / (max - min), 0, 1);
	    FloatPacking.float2Bytes(value, array, offset, numBytes);
	  };

	  FloatPacking.float2MantissaExponent = function float2MantissaExponent(value, array, offset, numBytes) {
	    var exponent = Math.floor(Math.log2(Math.abs(value))) + 1;
	    value /= Math.pow(2, exponent);
	    FloatPacking.float2BytesRange(value, array, offset, -1, 1, numBytes - 1);
	    array[offset + numBytes - 1] = Math.round(exponent + 127);
	  };

	  return FloatPacking;
	}();

	var _pixelSizeTable = null;
	var _blockSizeTable = null;
	var id$5 = 0;

	var Texture = function () {
	  function Texture(graphicsDevice, options) {
	    this.id = id$5++;
	    this.device = graphicsDevice;
	    this.name = null;
	    this._width = 4;
	    this._height = 4;
	    this._depth = 1;
	    this._format = PIXELFORMAT_R8_G8_B8_A8;
	    this.type = TEXTURETYPE_DEFAULT;
	    this.projection = TEXTUREPROJECTION_NONE;
	    this._cubemap = false;
	    this._volume = false;
	    this.fixCubemapSeams = false;
	    this._flipY = false;
	    this._premultiplyAlpha = false;
	    this._isRenderTarget = false;
	    this._mipmaps = true;
	    this._minFilter = FILTER_LINEAR_MIPMAP_LINEAR;
	    this._magFilter = FILTER_LINEAR;
	    this._anisotropy = 1;
	    this._addressU = ADDRESS_REPEAT;
	    this._addressV = ADDRESS_REPEAT;
	    this._addressW = ADDRESS_REPEAT;
	    this._compareOnRead = false;
	    this._compareFunc = FUNC_LESS;

	    if (options !== undefined) {
	      if (options.name !== undefined) {
	        this.name = options.name;
	      }

	      this._width = options.width !== undefined ? options.width : this._width;
	      this._height = options.height !== undefined ? options.height : this._height;
	      this._format = options.format !== undefined ? options.format : this._format;

	      if (options.hasOwnProperty('type')) {
	        this.type = options.type;
	      } else if (options.hasOwnProperty('rgbm')) {
	        this.type = options.rgbm ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT;
	      } else if (options.hasOwnProperty('swizzleGGGR')) {
	        this.type = options.swizzleGGGR ? TEXTURETYPE_SWIZZLEGGGR : TEXTURETYPE_DEFAULT;
	      }

	      if (options.mipmaps !== undefined) {
	        this._mipmaps = options.mipmaps;
	      } else {
	        this._mipmaps = options.autoMipmap !== undefined ? options.autoMipmap : this._mipmaps;
	      }

	      this._levels = options.levels;
	      this._cubemap = options.cubemap !== undefined ? options.cubemap : this._cubemap;
	      this.fixCubemapSeams = options.fixCubemapSeams !== undefined ? options.fixCubemapSeams : this.fixCubemapSeams;

	      if (this._cubemap) {
	        this.projection = TEXTUREPROJECTION_CUBE;
	      } else if (options.projection && options.projection !== TEXTUREPROJECTION_CUBE) {
	        this.projection = options.projection;
	      }

	      this._minFilter = options.minFilter !== undefined ? options.minFilter : this._minFilter;
	      this._magFilter = options.magFilter !== undefined ? options.magFilter : this._magFilter;
	      this._anisotropy = options.anisotropy !== undefined ? options.anisotropy : this._anisotropy;
	      this._addressU = options.addressU !== undefined ? options.addressU : this._addressU;
	      this._addressV = options.addressV !== undefined ? options.addressV : this._addressV;
	      this._compareOnRead = options.compareOnRead !== undefined ? options.compareOnRead : this._compareOnRead;
	      this._compareFunc = options._compareFunc !== undefined ? options._compareFunc : this._compareFunc;
	      this._flipY = options.flipY !== undefined ? options.flipY : this._flipY;
	      this._premultiplyAlpha = options.premultiplyAlpha !== undefined ? options.premultiplyAlpha : this._premultiplyAlpha;

	      if (graphicsDevice.webgl2) {
	        this._depth = options.depth !== undefined ? options.depth : this._depth;
	        this._volume = options.volume !== undefined ? options.volume : this._volume;
	        this._addressW = options.addressW !== undefined ? options.addressW : this._addressW;
	      }
	    }

	    this._compressed = this._format === PIXELFORMAT_DXT1 || this._format === PIXELFORMAT_DXT3 || this._format === PIXELFORMAT_DXT5 || this._format >= PIXELFORMAT_ETC1;
	    this._invalid = false;
	    this._lockedLevel = -1;

	    if (!this._levels) {
	      this._levels = this._cubemap ? [[null, null, null, null, null, null]] : [null];
	    }

	    this.dirtyAll();
	    this._gpuSize = 0;
	    this.impl = graphicsDevice.createTextureImpl(this);
	    graphicsDevice.textures.push(this);
	  }

	  var _proto = Texture.prototype;

	  _proto.destroy = function destroy() {
	    if (this.device) {
	      var device = this.device;
	      var idx = device.textures.indexOf(this);

	      if (idx !== -1) {
	        device.textures.splice(idx, 1);
	      }

	      device.scope.removeValue(this);
	      this.impl.destroy(device);
	      this.adjustVramSizeTracking(device._vram, -this._gpuSize);
	      this._levels = null;
	      this.device = null;
	    }
	  };

	  _proto.loseContext = function loseContext() {
	    this.impl.loseContext();
	    this.dirtyAll();
	  };

	  _proto.adjustVramSizeTracking = function adjustVramSizeTracking(vram, size) {
	    vram.tex += size;
	  };

	  Texture.calcGpuSize = function calcGpuSize(width, height, depth, format, mipmaps, cubemap) {
	    if (!_pixelSizeTable) {
	      _pixelSizeTable = [];
	      _pixelSizeTable[PIXELFORMAT_A8] = 1;
	      _pixelSizeTable[PIXELFORMAT_L8] = 1;
	      _pixelSizeTable[PIXELFORMAT_L8_A8] = 2;
	      _pixelSizeTable[PIXELFORMAT_R5_G6_B5] = 2;
	      _pixelSizeTable[PIXELFORMAT_R5_G5_B5_A1] = 2;
	      _pixelSizeTable[PIXELFORMAT_R4_G4_B4_A4] = 2;
	      _pixelSizeTable[PIXELFORMAT_R8_G8_B8] = 4;
	      _pixelSizeTable[PIXELFORMAT_R8_G8_B8_A8] = 4;
	      _pixelSizeTable[PIXELFORMAT_RGB16F] = 8;
	      _pixelSizeTable[PIXELFORMAT_RGBA16F] = 8;
	      _pixelSizeTable[PIXELFORMAT_RGB32F] = 16;
	      _pixelSizeTable[PIXELFORMAT_RGBA32F] = 16;
	      _pixelSizeTable[PIXELFORMAT_R32F] = 4;
	      _pixelSizeTable[PIXELFORMAT_DEPTH] = 4;
	      _pixelSizeTable[PIXELFORMAT_DEPTHSTENCIL] = 4;
	      _pixelSizeTable[PIXELFORMAT_111110F] = 4;
	      _pixelSizeTable[PIXELFORMAT_SRGB] = 4;
	      _pixelSizeTable[PIXELFORMAT_SRGBA] = 4;
	    }

	    if (!_blockSizeTable) {
	      _blockSizeTable = [];
	      _blockSizeTable[PIXELFORMAT_ETC1] = 8;
	      _blockSizeTable[PIXELFORMAT_ETC2_RGB] = 8;
	      _blockSizeTable[PIXELFORMAT_PVRTC_2BPP_RGB_1] = 8;
	      _blockSizeTable[PIXELFORMAT_PVRTC_2BPP_RGBA_1] = 8;
	      _blockSizeTable[PIXELFORMAT_PVRTC_4BPP_RGB_1] = 8;
	      _blockSizeTable[PIXELFORMAT_PVRTC_4BPP_RGBA_1] = 8;
	      _blockSizeTable[PIXELFORMAT_DXT1] = 8;
	      _blockSizeTable[PIXELFORMAT_ATC_RGB] = 8;
	      _blockSizeTable[PIXELFORMAT_ETC2_RGBA] = 16;
	      _blockSizeTable[PIXELFORMAT_DXT3] = 16;
	      _blockSizeTable[PIXELFORMAT_DXT5] = 16;
	      _blockSizeTable[PIXELFORMAT_ASTC_4x4] = 16;
	      _blockSizeTable[PIXELFORMAT_ATC_RGBA] = 16;
	    }

	    var pixelSize = _pixelSizeTable.hasOwnProperty(format) ? _pixelSizeTable[format] : 0;
	    var blockSize = _blockSizeTable.hasOwnProperty(format) ? _blockSizeTable[format] : 0;
	    var result = 0;

	    while (1) {
	      if (pixelSize > 0) {
	        result += width * height * depth * pixelSize;
	      } else {
	        var blockWidth = Math.floor((width + 3) / 4);
	        var blockHeight = Math.floor((height + 3) / 4);
	        var blockDepth = Math.floor((depth + 3) / 4);

	        if (format === PIXELFORMAT_PVRTC_2BPP_RGB_1 || format === PIXELFORMAT_PVRTC_2BPP_RGBA_1) {
	          blockWidth = Math.max(Math.floor(blockWidth / 2), 1);
	        }

	        result += blockWidth * blockHeight * blockDepth * blockSize;
	      }

	      if (!mipmaps || width === 1 && height === 1 && depth === 1) {
	        break;
	      }

	      width = Math.max(Math.floor(width / 2), 1);
	      height = Math.max(Math.floor(height / 2), 1);
	      depth = Math.max(Math.floor(depth / 2), 1);
	    }

	    return result * (cubemap ? 6 : 1);
	  };

	  _proto.dirtyAll = function dirtyAll() {
	    this._levelsUpdated = this._cubemap ? [[true, true, true, true, true, true]] : [true];
	    this._needsUpload = true;
	    this._needsMipmapsUpload = this._mipmaps;
	    this._mipmapsUploaded = false;
	    this._parameterFlags = 255;
	  };

	  _proto.lock = function lock(options) {
	    if (options === void 0) {
	      options = {};
	    }

	    if (options.level === undefined) {
	      options.level = 0;
	    }

	    if (options.face === undefined) {
	      options.face = 0;
	    }

	    if (options.mode === undefined) {
	      options.mode = TEXTURELOCK_WRITE;
	    }

	    this._lockedLevel = options.level;

	    if (this._levels[options.level] === null) {
	      switch (this._format) {
	        case PIXELFORMAT_A8:
	        case PIXELFORMAT_L8:
	          this._levels[options.level] = new Uint8Array(this._width * this._height * this._depth);
	          break;

	        case PIXELFORMAT_L8_A8:
	          this._levels[options.level] = new Uint8Array(this._width * this._height * this._depth * 2);
	          break;

	        case PIXELFORMAT_R5_G6_B5:
	        case PIXELFORMAT_R5_G5_B5_A1:
	        case PIXELFORMAT_R4_G4_B4_A4:
	          this._levels[options.level] = new Uint16Array(this._width * this._height * this._depth);
	          break;

	        case PIXELFORMAT_R8_G8_B8:
	          this._levels[options.level] = new Uint8Array(this._width * this._height * this._depth * 3);
	          break;

	        case PIXELFORMAT_R8_G8_B8_A8:
	          this._levels[options.level] = new Uint8Array(this._width * this._height * this._depth * 4);
	          break;

	        case PIXELFORMAT_DXT1:
	          this._levels[options.level] = new Uint8Array(Math.floor((this._width + 3) / 4) * Math.floor((this._height + 3) / 4) * 8 * this._depth);
	          break;

	        case PIXELFORMAT_DXT3:
	        case PIXELFORMAT_DXT5:
	          this._levels[options.level] = new Uint8Array(Math.floor((this._width + 3) / 4) * Math.floor((this._height + 3) / 4) * 16 * this._depth);
	          break;

	        case PIXELFORMAT_RGB16F:
	          this._levels[options.level] = new Uint16Array(this._width * this._height * this._depth * 3);
	          break;

	        case PIXELFORMAT_RGB32F:
	          this._levels[options.level] = new Float32Array(this._width * this._height * this._depth * 3);
	          break;

	        case PIXELFORMAT_RGBA16F:
	          this._levels[options.level] = new Uint16Array(this._width * this._height * this._depth * 4);
	          break;

	        case PIXELFORMAT_RGBA32F:
	          this._levels[options.level] = new Float32Array(this._width * this._height * this._depth * 4);
	          break;
	      }
	    }

	    return this._levels[options.level];
	  };

	  _proto.setSource = function setSource(source, mipLevel) {
	    if (mipLevel === void 0) {
	      mipLevel = 0;
	    }

	    var invalid = false;
	    var width, height;

	    if (this._cubemap) {
	      if (source[0]) {
	        width = source[0].width || 0;
	        height = source[0].height || 0;

	        for (var i = 0; i < 6; i++) {
	          var face = source[i];

	          if (!face || face.width !== width || face.height !== height || !this.device._isBrowserInterface(face)) {
	            invalid = true;
	            break;
	          }
	        }
	      } else {
	        invalid = true;
	      }

	      if (!invalid) {
	        for (var _i = 0; _i < 6; _i++) {
	          if (this._levels[mipLevel][_i] !== source[_i]) this._levelsUpdated[mipLevel][_i] = true;
	        }
	      }
	    } else {
	      if (!this.device._isBrowserInterface(source)) invalid = true;

	      if (!invalid) {
	        if (source !== this._levels[mipLevel]) this._levelsUpdated[mipLevel] = true;
	        width = source.width;
	        height = source.height;
	      }
	    }

	    if (invalid) {
	      this._width = 4;
	      this._height = 4;

	      if (this._cubemap) {
	        for (var _i2 = 0; _i2 < 6; _i2++) {
	          this._levels[mipLevel][_i2] = null;
	          this._levelsUpdated[mipLevel][_i2] = true;
	        }
	      } else {
	        this._levels[mipLevel] = null;
	        this._levelsUpdated[mipLevel] = true;
	      }
	    } else {
	      if (mipLevel === 0) {
	        this._width = width;
	        this._height = height;
	      }

	      this._levels[mipLevel] = source;
	    }

	    if (this._invalid !== invalid || !invalid) {
	      this._invalid = invalid;
	      this.upload();
	    }
	  };

	  _proto.getSource = function getSource(mipLevel) {
	    if (mipLevel === void 0) {
	      mipLevel = 0;
	    }

	    return this._levels[mipLevel];
	  };

	  _proto.unlock = function unlock() {
	    if (this._lockedLevel === -1) ;

	    this.upload();
	    this._lockedLevel = -1;
	  };

	  _proto.upload = function upload() {
	    this._needsUpload = true;
	    this._needsMipmapsUpload = this._mipmaps;
	  };

	  _proto.getDds = function getDds() {
	    var fsize = 128;
	    var idx = 0;

	    while (this._levels[idx]) {
	      if (!this.cubemap) {
	        var mipSize = this._levels[idx].length;

	        if (!mipSize) {
	          return undefined;
	        }

	        fsize += mipSize;
	      } else {
	        for (var face = 0; face < 6; face++) {
	          if (!this._levels[idx][face]) {
	            return undefined;
	          }

	          var _mipSize = this._levels[idx][face].length;

	          if (!_mipSize) {
	            return undefined;
	          }

	          fsize += _mipSize;
	        }
	      }

	      fsize += this._levels[idx].length;
	      idx++;
	    }

	    var buff = new ArrayBuffer(fsize);
	    var header = new Uint32Array(buff, 0, 128 / 4);
	    var DDS_MAGIC = 542327876;
	    var DDS_HEADER_SIZE = 124;
	    var DDS_FLAGS_REQUIRED = 0x01 | 0x02 | 0x04 | 0x1000 | 0x80000;
	    var DDS_FLAGS_MIPMAP = 0x20000;
	    var DDS_PIXELFORMAT_SIZE = 32;
	    var DDS_PIXELFLAGS_RGBA8 = 0x01 | 0x40;
	    var DDS_CAPS_REQUIRED = 0x1000;
	    var DDS_CAPS_MIPMAP = 0x400000;
	    var DDS_CAPS_COMPLEX = 0x8;
	    var DDS_CAPS2_CUBEMAP = 0x200 | 0x400 | 0x800 | 0x1000 | 0x2000 | 0x4000 | 0x8000;
	    var flags = DDS_FLAGS_REQUIRED;
	    if (this._levels.length > 1) flags |= DDS_FLAGS_MIPMAP;
	    var caps = DDS_CAPS_REQUIRED;
	    if (this._levels.length > 1) caps |= DDS_CAPS_MIPMAP;
	    if (this._levels.length > 1 || this.cubemap) caps |= DDS_CAPS_COMPLEX;
	    var caps2 = this.cubemap ? DDS_CAPS2_CUBEMAP : 0;
	    header[0] = DDS_MAGIC;
	    header[1] = DDS_HEADER_SIZE;
	    header[2] = flags;
	    header[3] = this.height;
	    header[4] = this.width;
	    header[5] = this.width * this.height * 4;
	    header[6] = 0;
	    header[7] = this._levels.length;

	    for (var i = 0; i < 11; i++) {
	      header[8 + i] = 0;
	    }

	    header[19] = DDS_PIXELFORMAT_SIZE;
	    header[20] = DDS_PIXELFLAGS_RGBA8;
	    header[21] = 0;
	    header[22] = 32;
	    header[23] = 0x00FF0000;
	    header[24] = 0x0000FF00;
	    header[25] = 0x000000FF;
	    header[26] = 0xFF000000;
	    header[27] = caps;
	    header[28] = caps2;
	    header[29] = 0;
	    header[30] = 0;
	    header[31] = 0;
	    var offset = 128;

	    if (!this.cubemap) {
	      for (var _i3 = 0; _i3 < this._levels.length; _i3++) {
	        var level = this._levels[_i3];
	        var mip = new Uint8Array(buff, offset, level.length);

	        for (var j = 0; j < level.length; j++) {
	          mip[j] = level[j];
	        }

	        offset += level.length;
	      }
	    } else {
	      for (var _face = 0; _face < 6; _face++) {
	        for (var _i4 = 0; _i4 < this._levels.length; _i4++) {
	          var _level = this._levels[_i4][_face];

	          var _mip = new Uint8Array(buff, offset, _level.length);

	          for (var _j = 0; _j < _level.length; _j++) {
	            _mip[_j] = _level[_j];
	          }

	          offset += _level.length;
	        }
	      }
	    }

	    return buff;
	  };

	  _createClass(Texture, [{
	    key: "minFilter",
	    get: function get() {
	      return this._minFilter;
	    },
	    set: function set(v) {
	      if (this._minFilter !== v) {
	        this._minFilter = v;
	        this._parameterFlags |= 1;
	      }
	    }
	  }, {
	    key: "magFilter",
	    get: function get() {
	      return this._magFilter;
	    },
	    set: function set(v) {
	      if (this._magFilter !== v) {
	        this._magFilter = v;
	        this._parameterFlags |= 2;
	      }
	    }
	  }, {
	    key: "addressU",
	    get: function get() {
	      return this._addressU;
	    },
	    set: function set(v) {
	      if (this._addressU !== v) {
	        this._addressU = v;
	        this._parameterFlags |= 4;
	      }
	    }
	  }, {
	    key: "addressV",
	    get: function get() {
	      return this._addressV;
	    },
	    set: function set(v) {
	      if (this._addressV !== v) {
	        this._addressV = v;
	        this._parameterFlags |= 8;
	      }
	    }
	  }, {
	    key: "addressW",
	    get: function get() {
	      return this._addressW;
	    },
	    set: function set(addressW) {
	      if (!this.device.webgl2) return;

	      if (!this._volume) {
	        return;
	      }

	      if (addressW !== this._addressW) {
	        this._addressW = addressW;
	        this._parameterFlags |= 16;
	      }
	    }
	  }, {
	    key: "compareOnRead",
	    get: function get() {
	      return this._compareOnRead;
	    },
	    set: function set(v) {
	      if (this._compareOnRead !== v) {
	        this._compareOnRead = v;
	        this._parameterFlags |= 32;
	      }
	    }
	  }, {
	    key: "compareFunc",
	    get: function get() {
	      return this._compareFunc;
	    },
	    set: function set(v) {
	      if (this._compareFunc !== v) {
	        this._compareFunc = v;
	        this._parameterFlags |= 64;
	      }
	    }
	  }, {
	    key: "anisotropy",
	    get: function get() {
	      return this._anisotropy;
	    },
	    set: function set(v) {
	      if (this._anisotropy !== v) {
	        this._anisotropy = v;
	        this._parameterFlags |= 128;
	      }
	    }
	  }, {
	    key: "autoMipmap",
	    get: function get() {
	      return this._mipmaps;
	    },
	    set: function set(v) {
	      this._mipmaps = v;
	    }
	  }, {
	    key: "mipmaps",
	    get: function get() {
	      return this._mipmaps;
	    },
	    set: function set(v) {
	      if (this._mipmaps !== v) {
	        this._mipmaps = v;
	        if (v) this._needsMipmapsUpload = true;
	      }
	    }
	  }, {
	    key: "width",
	    get: function get() {
	      return this._width;
	    }
	  }, {
	    key: "height",
	    get: function get() {
	      return this._height;
	    }
	  }, {
	    key: "depth",
	    get: function get() {
	      return this._depth;
	    }
	  }, {
	    key: "format",
	    get: function get() {
	      return this._format;
	    }
	  }, {
	    key: "cubemap",
	    get: function get() {
	      return this._cubemap;
	    }
	  }, {
	    key: "gpuSize",
	    get: function get() {
	      var mips = this.pot && this._mipmaps && !(this._compressed && this._levels.length === 1);
	      return Texture.calcGpuSize(this._width, this._height, this._depth, this._format, mips, this._cubemap);
	    }
	  }, {
	    key: "volume",
	    get: function get() {
	      return this._volume;
	    }
	  }, {
	    key: "flipY",
	    get: function get() {
	      return this._flipY;
	    },
	    set: function set(flipY) {
	      if (this._flipY !== flipY) {
	        this._flipY = flipY;
	        this._needsUpload = true;
	      }
	    }
	  }, {
	    key: "premultiplyAlpha",
	    get: function get() {
	      return this._premultiplyAlpha;
	    },
	    set: function set(premultiplyAlpha) {
	      if (this._premultiplyAlpha !== premultiplyAlpha) {
	        this._premultiplyAlpha = premultiplyAlpha;
	        this._needsUpload = true;
	      }
	    }
	  }, {
	    key: "pot",
	    get: function get() {
	      return math.powerOfTwo(this._width) && math.powerOfTwo(this._height);
	    }
	  }, {
	    key: "encoding",
	    get: function get() {
	      switch (this.type) {
	        case TEXTURETYPE_RGBM:
	          return 'rgbm';

	        case TEXTURETYPE_RGBE:
	          return 'rgbe';

	        case TEXTURETYPE_RGBP:
	          return 'rgbp';

	        default:
	          return this.format === PIXELFORMAT_RGB16F || this.format === PIXELFORMAT_RGB32F || this.format === PIXELFORMAT_RGBA16F || this.format === PIXELFORMAT_RGBA32F ? 'linear' : 'srgb';
	      }
	    }
	  }]);

	  return Texture;
	}();

	var _deviceCoord = new Vec3();

	var _halfSize = new Vec3();

	var _point = new Vec3();

	var _invViewProjMat = new Mat4();

	var Camera = function () {
	  function Camera() {
	    this._aspectRatio = 16 / 9;
	    this._aspectRatioMode = ASPECT_AUTO;
	    this._calculateProjection = null;
	    this._calculateTransform = null;
	    this._clearColor = new Color(0.75, 0.75, 0.75, 1);
	    this._clearColorBuffer = true;
	    this._clearDepth = 1;
	    this._clearDepthBuffer = true;
	    this._clearStencil = 0;
	    this._clearStencilBuffer = true;
	    this._cullingMask = 0xFFFFFFFF;
	    this._cullFaces = true;
	    this._farClip = 1000;
	    this._flipFaces = false;
	    this._fov = 45;
	    this._frustumCulling = true;
	    this._horizontalFov = false;
	    this._layers = [LAYERID_WORLD, LAYERID_DEPTH, LAYERID_SKYBOX, LAYERID_UI, LAYERID_IMMEDIATE];
	    this._layersSet = new Set(this._layers);
	    this._nearClip = 0.1;
	    this._node = null;
	    this._orthoHeight = 10;
	    this._projection = PROJECTION_PERSPECTIVE;
	    this._rect = new Vec4(0, 0, 1, 1);
	    this._renderTarget = null;
	    this._scissorRect = new Vec4(0, 0, 1, 1);
	    this._scissorRectClear = false;
	    this._projMat = new Mat4();
	    this._projMatDirty = true;
	    this._projMatSkybox = new Mat4();
	    this._viewMat = new Mat4();
	    this._viewMatDirty = true;
	    this._viewProjMat = new Mat4();
	    this._viewProjMatDirty = true;
	    this.frustum = new Frustum();
	  }

	  var _proto = Camera.prototype;

	  _proto.clone = function clone() {
	    return new Camera().copy(this);
	  };

	  _proto.copy = function copy(other) {
	    this.aspectRatio = other.aspectRatio;
	    this.aspectRatioMode = other.aspectRatioMode;
	    this.calculateProjection = other.calculateProjection;
	    this.calculateTransform = other.calculateTransform;
	    this.clearColor = other.clearColor;
	    this.clearColorBuffer = other.clearColorBuffer;
	    this.clearDepth = other.clearDepth;
	    this.clearDepthBuffer = other.clearDepthBuffer;
	    this.clearStencil = other.clearStencil;
	    this.clearStencilBuffer = other.clearStencilBuffer;
	    this.cullFaces = other.cullFaces;
	    this.cullingMask = other.cullingMask;
	    this.farClip = other.farClip;
	    this.flipFaces = other.flipFaces;
	    this.fov = other.fov;
	    this.frustumCulling = other.frustumCulling;
	    this.horizontalFov = other.horizontalFov;
	    this.layers = other.layers;
	    this.nearClip = other.nearClip;
	    this.orthoHeight = other.orthoHeight;
	    this.projection = other.projection;
	    this.rect = other.rect;
	    this.renderTarget = other.renderTarget;
	    this.scissorRect = other.scissorRect;
	    return this;
	  };

	  _proto._updateViewProjMat = function _updateViewProjMat() {
	    if (this._projMatDirty || this._viewMatDirty || this._viewProjMatDirty) {
	      this._viewProjMat.mul2(this.projectionMatrix, this.viewMatrix);

	      this._viewProjMatDirty = false;
	    }
	  };

	  _proto.worldToScreen = function worldToScreen(worldCoord, cw, ch, screenCoord) {
	    if (screenCoord === void 0) {
	      screenCoord = new Vec3();
	    }

	    this._updateViewProjMat();

	    this._viewProjMat.transformPoint(worldCoord, screenCoord);

	    var vpm = this._viewProjMat.data;
	    var w = worldCoord.x * vpm[3] + worldCoord.y * vpm[7] + worldCoord.z * vpm[11] + 1 * vpm[15];
	    screenCoord.x = (screenCoord.x / w + 1) * 0.5 * cw;
	    screenCoord.y = (1 - screenCoord.y / w) * 0.5 * ch;
	    return screenCoord;
	  };

	  _proto.screenToWorld = function screenToWorld(x, y, z, cw, ch, worldCoord) {
	    if (worldCoord === void 0) {
	      worldCoord = new Vec3();
	    }

	    var range = this._farClip - this._nearClip;

	    _deviceCoord.set(x / cw, (ch - y) / ch, z / range);

	    _deviceCoord.mulScalar(2);

	    _deviceCoord.sub(Vec3.ONE);

	    if (this._projection === PROJECTION_PERSPECTIVE) {
	      Mat4._getPerspectiveHalfSize(_halfSize, this._fov, this._aspectRatio, this._nearClip, this._horizontalFov);

	      _halfSize.x *= _deviceCoord.x;
	      _halfSize.y *= _deviceCoord.y;

	      var invView = this._node.getWorldTransform();

	      _halfSize.z = -this._nearClip;
	      invView.transformPoint(_halfSize, _point);

	      var cameraPos = this._node.getPosition();

	      worldCoord.sub2(_point, cameraPos);
	      worldCoord.normalize();
	      worldCoord.mulScalar(z);
	      worldCoord.add(cameraPos);
	    } else {
	      this._updateViewProjMat();

	      _invViewProjMat.copy(this._viewProjMat).invert();

	      _invViewProjMat.transformPoint(_deviceCoord, worldCoord);
	    }

	    return worldCoord;
	  };

	  _proto._evaluateProjectionMatrix = function _evaluateProjectionMatrix() {
	    if (this._projMatDirty) {
	      if (this._projection === PROJECTION_PERSPECTIVE) {
	        this._projMat.setPerspective(this._fov, this._aspectRatio, this._nearClip, this._farClip, this._horizontalFov);

	        this._projMatSkybox.copy(this._projMat);
	      } else {
	        var y = this._orthoHeight;
	        var x = y * this._aspectRatio;

	        this._projMat.setOrtho(-x, x, -y, y, this._nearClip, this._farClip);

	        this._projMatSkybox.setPerspective(this._fov, this._aspectRatio, this._nearClip, this._farClip);
	      }

	      this._projMatDirty = false;
	    }
	  };

	  _proto.getProjectionMatrixSkybox = function getProjectionMatrixSkybox() {
	    this._evaluateProjectionMatrix();

	    return this._projMatSkybox;
	  };

	  _proto.getScreenSize = function getScreenSize(sphere) {
	    if (this._projection === PROJECTION_PERSPECTIVE) {
	      var distance = this._node.getPosition().distance(sphere.center);

	      if (distance < sphere.radius) {
	        return 1;
	      }

	      var viewAngle = Math.asin(sphere.radius / distance);
	      var sphereViewHeight = Math.tan(viewAngle);
	      var screenViewHeight = Math.tan(this._fov / 2 * math.DEG_TO_RAD);
	      return Math.min(sphereViewHeight / screenViewHeight, 1);
	    }

	    return math.clamp(sphere.radius / this._orthoHeight, 0, 1);
	  };

	  _createClass(Camera, [{
	    key: "fullSizeClearRect",
	    get: function get() {
	      var rect = this._scissorRectClear ? this.scissorRect : this._rect;
	      return rect.x === 0 && rect.y === 0 && rect.z === 1 && rect.w === 1;
	    }
	  }, {
	    key: "aspectRatio",
	    get: function get() {
	      return this._aspectRatio;
	    },
	    set: function set(newValue) {
	      if (this._aspectRatio !== newValue) {
	        this._aspectRatio = newValue;
	        this._projMatDirty = true;
	      }
	    }
	  }, {
	    key: "aspectRatioMode",
	    get: function get() {
	      return this._aspectRatioMode;
	    },
	    set: function set(newValue) {
	      if (this._aspectRatioMode !== newValue) {
	        this._aspectRatioMode = newValue;
	        this._projMatDirty = true;
	      }
	    }
	  }, {
	    key: "calculateProjection",
	    get: function get() {
	      return this._calculateProjection;
	    },
	    set: function set(newValue) {
	      this._calculateProjection = newValue;
	      this._projMatDirty = true;
	    }
	  }, {
	    key: "calculateTransform",
	    get: function get() {
	      return this._calculateTransform;
	    },
	    set: function set(newValue) {
	      this._calculateTransform = newValue;
	    }
	  }, {
	    key: "clearColor",
	    get: function get() {
	      return this._clearColor;
	    },
	    set: function set(newValue) {
	      this._clearColor.copy(newValue);
	    }
	  }, {
	    key: "clearColorBuffer",
	    get: function get() {
	      return this._clearColorBuffer;
	    },
	    set: function set(newValue) {
	      this._clearColorBuffer = newValue;
	    }
	  }, {
	    key: "clearDepth",
	    get: function get() {
	      return this._clearDepth;
	    },
	    set: function set(newValue) {
	      this._clearDepth = newValue;
	    }
	  }, {
	    key: "clearDepthBuffer",
	    get: function get() {
	      return this._clearDepthBuffer;
	    },
	    set: function set(newValue) {
	      this._clearDepthBuffer = newValue;
	    }
	  }, {
	    key: "clearStencil",
	    get: function get() {
	      return this._clearStencil;
	    },
	    set: function set(newValue) {
	      this._clearStencil = newValue;
	    }
	  }, {
	    key: "clearStencilBuffer",
	    get: function get() {
	      return this._clearStencilBuffer;
	    },
	    set: function set(newValue) {
	      this._clearStencilBuffer = newValue;
	    }
	  }, {
	    key: "cullingMask",
	    get: function get() {
	      return this._cullingMask;
	    },
	    set: function set(newValue) {
	      this._cullingMask = newValue;
	    }
	  }, {
	    key: "cullFaces",
	    get: function get() {
	      return this._cullFaces;
	    },
	    set: function set(newValue) {
	      this._cullFaces = newValue;
	    }
	  }, {
	    key: "farClip",
	    get: function get() {
	      return this._farClip;
	    },
	    set: function set(newValue) {
	      if (this._farClip !== newValue) {
	        this._farClip = newValue;
	        this._projMatDirty = true;
	      }
	    }
	  }, {
	    key: "flipFaces",
	    get: function get() {
	      return this._flipFaces;
	    },
	    set: function set(newValue) {
	      this._flipFaces = newValue;
	    }
	  }, {
	    key: "fov",
	    get: function get() {
	      return this._fov;
	    },
	    set: function set(newValue) {
	      if (this._fov !== newValue) {
	        this._fov = newValue;
	        this._projMatDirty = true;
	      }
	    }
	  }, {
	    key: "frustumCulling",
	    get: function get() {
	      return this._frustumCulling;
	    },
	    set: function set(newValue) {
	      this._frustumCulling = newValue;
	    }
	  }, {
	    key: "horizontalFov",
	    get: function get() {
	      return this._horizontalFov;
	    },
	    set: function set(newValue) {
	      if (this._horizontalFov !== newValue) {
	        this._horizontalFov = newValue;
	        this._projMatDirty = true;
	      }
	    }
	  }, {
	    key: "layers",
	    get: function get() {
	      return this._layers;
	    },
	    set: function set(newValue) {
	      this._layers = newValue.slice(0);
	      this._layersSet = new Set(this._layers);
	    }
	  }, {
	    key: "layersSet",
	    get: function get() {
	      return this._layersSet;
	    }
	  }, {
	    key: "nearClip",
	    get: function get() {
	      return this._nearClip;
	    },
	    set: function set(newValue) {
	      if (this._nearClip !== newValue) {
	        this._nearClip = newValue;
	        this._projMatDirty = true;
	      }
	    }
	  }, {
	    key: "node",
	    get: function get() {
	      return this._node;
	    },
	    set: function set(newValue) {
	      this._node = newValue;
	    }
	  }, {
	    key: "orthoHeight",
	    get: function get() {
	      return this._orthoHeight;
	    },
	    set: function set(newValue) {
	      if (this._orthoHeight !== newValue) {
	        this._orthoHeight = newValue;
	        this._projMatDirty = true;
	      }
	    }
	  }, {
	    key: "projection",
	    get: function get() {
	      return this._projection;
	    },
	    set: function set(newValue) {
	      if (this._projection !== newValue) {
	        this._projection = newValue;
	        this._projMatDirty = true;
	      }
	    }
	  }, {
	    key: "projectionMatrix",
	    get: function get() {
	      this._evaluateProjectionMatrix();

	      return this._projMat;
	    }
	  }, {
	    key: "rect",
	    get: function get() {
	      return this._rect;
	    },
	    set: function set(newValue) {
	      this._rect.copy(newValue);
	    }
	  }, {
	    key: "renderTarget",
	    get: function get() {
	      return this._renderTarget;
	    },
	    set: function set(newValue) {
	      this._renderTarget = newValue;
	    }
	  }, {
	    key: "scissorRect",
	    get: function get() {
	      return this._scissorRect;
	    },
	    set: function set(newValue) {
	      this._scissorRect.copy(newValue);
	    }
	  }, {
	    key: "viewMatrix",
	    get: function get() {
	      if (this._viewMatDirty) {
	        var wtm = this._node.getWorldTransform();

	        this._viewMat.copy(wtm).invert();

	        this._viewMatDirty = false;
	      }

	      return this._viewMat;
	    }
	  }]);

	  return Camera;
	}();

	var scaleCompensatePosTransform = new Mat4();
	var scaleCompensatePos = new Vec3();
	var scaleCompensateRot = new Quat();
	var scaleCompensateRot2 = new Quat();
	var scaleCompensateScale = new Vec3();
	var scaleCompensateScaleForParent = new Vec3();
	var tmpMat4 = new Mat4();
	var tmpQuat = new Quat();
	var position$1 = new Vec3();
	var invParentWtm$1 = new Mat4();
	var rotation = new Quat();
	var invParentRot = new Quat();
	var matrix = new Mat4();
	var target = new Vec3();
	var up = new Vec3();

	var GraphNode = function (_EventHandler) {
	  _inheritsLoose(GraphNode, _EventHandler);

	  function GraphNode(name) {
	    var _this;

	    if (name === void 0) {
	      name = 'Untitled';
	    }

	    _this = _EventHandler.call(this) || this;
	    _this.name = name;
	    _this.tags = new Tags(_assertThisInitialized(_this));
	    _this._labels = {};
	    _this.localPosition = new Vec3();
	    _this.localRotation = new Quat();
	    _this.localScale = new Vec3(1, 1, 1);
	    _this.localEulerAngles = new Vec3();
	    _this.position = new Vec3();
	    _this.rotation = new Quat();
	    _this.eulerAngles = new Vec3();
	    _this._scale = null;
	    _this.localTransform = new Mat4();
	    _this._dirtyLocal = false;
	    _this._aabbVer = 0;
	    _this._frozen = false;
	    _this.worldTransform = new Mat4();
	    _this._dirtyWorld = false;
	    _this.normalMatrix = new Mat3();
	    _this._dirtyNormal = true;
	    _this._right = null;
	    _this._up = null;
	    _this._forward = null;
	    _this._parent = null;
	    _this._children = [];
	    _this._graphDepth = 0;
	    _this._enabled = true;
	    _this._enabledInHierarchy = false;
	    _this.scaleCompensation = false;
	    return _this;
	  }

	  var _proto = GraphNode.prototype;

	  _proto._notifyHierarchyStateChanged = function _notifyHierarchyStateChanged(node, enabled) {
	    node._onHierarchyStateChanged(enabled);

	    var c = node._children;

	    for (var i = 0, len = c.length; i < len; i++) {
	      if (c[i]._enabled) this._notifyHierarchyStateChanged(c[i], enabled);
	    }
	  };

	  _proto._onHierarchyStateChanged = function _onHierarchyStateChanged(enabled) {
	    this._enabledInHierarchy = enabled;
	    if (enabled && !this._frozen) this._unfreezeParentToRoot();
	  };

	  _proto._cloneInternal = function _cloneInternal(clone) {
	    clone.name = this.name;
	    var tags = this.tags._list;
	    clone.tags.clear();

	    for (var i = 0; i < tags.length; i++) {
	      clone.tags.add(tags[i]);
	    }

	    clone._labels = Object.assign({}, this._labels);
	    clone.localPosition.copy(this.localPosition);
	    clone.localRotation.copy(this.localRotation);
	    clone.localScale.copy(this.localScale);
	    clone.localEulerAngles.copy(this.localEulerAngles);
	    clone.position.copy(this.position);
	    clone.rotation.copy(this.rotation);
	    clone.eulerAngles.copy(this.eulerAngles);
	    clone.localTransform.copy(this.localTransform);
	    clone._dirtyLocal = this._dirtyLocal;
	    clone.worldTransform.copy(this.worldTransform);
	    clone._dirtyWorld = this._dirtyWorld;
	    clone._dirtyNormal = this._dirtyNormal;
	    clone._aabbVer = this._aabbVer + 1;
	    clone._enabled = this._enabled;
	    clone.scaleCompensation = this.scaleCompensation;
	    clone._enabledInHierarchy = false;
	  };

	  _proto.clone = function clone() {
	    var clone = new this.constructor();

	    this._cloneInternal(clone);

	    return clone;
	  };

	  _proto.copy = function copy(source) {
	    source._cloneInternal(this);

	    return this;
	  };

	  _proto.find = function find(attr, value) {
	    var result,
	        results = [];
	    var len = this._children.length;

	    if (attr instanceof Function) {
	      var fn = attr;
	      result = fn(this);
	      if (result) results.push(this);

	      for (var i = 0; i < len; i++) {
	        var descendants = this._children[i].find(fn);

	        if (descendants.length) results = results.concat(descendants);
	      }
	    } else {
	      var testValue;

	      if (this[attr]) {
	        if (this[attr] instanceof Function) {
	          testValue = this[attr]();
	        } else {
	          testValue = this[attr];
	        }

	        if (testValue === value) results.push(this);
	      }

	      for (var _i = 0; _i < len; ++_i) {
	        var _descendants = this._children[_i].find(attr, value);

	        if (_descendants.length) results = results.concat(_descendants);
	      }
	    }

	    return results;
	  };

	  _proto.findOne = function findOne(attr, value) {
	    var len = this._children.length;
	    var result = null;

	    if (attr instanceof Function) {
	      var fn = attr;
	      result = fn(this);
	      if (result) return this;

	      for (var i = 0; i < len; i++) {
	        result = this._children[i].findOne(fn);
	        if (result) return result;
	      }
	    } else {
	      var testValue;

	      if (this[attr]) {
	        if (this[attr] instanceof Function) {
	          testValue = this[attr]();
	        } else {
	          testValue = this[attr];
	        }

	        if (testValue === value) {
	          return this;
	        }
	      }

	      for (var _i2 = 0; _i2 < len; _i2++) {
	        result = this._children[_i2].findOne(attr, value);
	        if (result !== null) return result;
	      }
	    }

	    return null;
	  };

	  _proto.findByTag = function findByTag() {
	    var query = arguments;
	    var results = [];

	    var queryNode = function queryNode(node, checkNode) {
	      var _node$tags;

	      if (checkNode && (_node$tags = node.tags).has.apply(_node$tags, query)) {
	        results.push(node);
	      }

	      for (var i = 0; i < node._children.length; i++) {
	        queryNode(node._children[i], true);
	      }
	    };

	    queryNode(this, false);
	    return results;
	  };

	  _proto.findByName = function findByName(name) {
	    if (this.name === name) return this;

	    for (var i = 0; i < this._children.length; i++) {
	      var found = this._children[i].findByName(name);

	      if (found !== null) return found;
	    }

	    return null;
	  };

	  _proto.findByPath = function findByPath(path) {
	    var parts = Array.isArray(path) ? path : path.split('/');
	    var result = this;

	    var _loop = function _loop(i, imax) {
	      result = result.children.find(function (c) {
	        return c.name === parts[i];
	      });

	      if (!result) {
	        return {
	          v: null
	        };
	      }
	    };

	    for (var i = 0, imax = parts.length; i < imax; ++i) {
	      var _ret = _loop(i);

	      if (typeof _ret === "object") return _ret.v;
	    }

	    return result;
	  };

	  _proto.forEach = function forEach(callback, thisArg) {
	    callback.call(thisArg, this);
	    var children = this._children;

	    for (var i = 0; i < children.length; i++) {
	      children[i].forEach(callback, thisArg);
	    }
	  };

	  _proto.isDescendantOf = function isDescendantOf(node) {
	    var parent = this._parent;

	    while (parent) {
	      if (parent === node) return true;
	      parent = parent._parent;
	    }

	    return false;
	  };

	  _proto.isAncestorOf = function isAncestorOf(node) {
	    return node.isDescendantOf(this);
	  };

	  _proto.getEulerAngles = function getEulerAngles() {
	    this.getWorldTransform().getEulerAngles(this.eulerAngles);
	    return this.eulerAngles;
	  };

	  _proto.getLocalEulerAngles = function getLocalEulerAngles() {
	    this.localRotation.getEulerAngles(this.localEulerAngles);
	    return this.localEulerAngles;
	  };

	  _proto.getLocalPosition = function getLocalPosition() {
	    return this.localPosition;
	  };

	  _proto.getLocalRotation = function getLocalRotation() {
	    return this.localRotation;
	  };

	  _proto.getLocalScale = function getLocalScale() {
	    return this.localScale;
	  };

	  _proto.getLocalTransform = function getLocalTransform() {
	    if (this._dirtyLocal) {
	      this.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale);
	      this._dirtyLocal = false;
	    }

	    return this.localTransform;
	  };

	  _proto.getPosition = function getPosition() {
	    this.getWorldTransform().getTranslation(this.position);
	    return this.position;
	  };

	  _proto.getRotation = function getRotation() {
	    this.rotation.setFromMat4(this.getWorldTransform());
	    return this.rotation;
	  };

	  _proto.getScale = function getScale() {
	    if (!this._scale) {
	      this._scale = new Vec3();
	    }

	    return this.getWorldTransform().getScale(this._scale);
	  };

	  _proto.getWorldTransform = function getWorldTransform() {
	    if (!this._dirtyLocal && !this._dirtyWorld) return this.worldTransform;
	    if (this._parent) this._parent.getWorldTransform();

	    this._sync();

	    return this.worldTransform;
	  };

	  _proto.reparent = function reparent(parent, index) {
	    var current = this._parent;
	    if (current) current.removeChild(this);

	    if (parent) {
	      if (index >= 0) {
	        parent.insertChild(this, index);
	      } else {
	        parent.addChild(this);
	      }
	    }
	  };

	  _proto.setLocalEulerAngles = function setLocalEulerAngles(x, y, z) {
	    this.localRotation.setFromEulerAngles(x, y, z);
	    if (!this._dirtyLocal) this._dirtifyLocal();
	  };

	  _proto.setLocalPosition = function setLocalPosition(x, y, z) {
	    if (x instanceof Vec3) {
	      this.localPosition.copy(x);
	    } else {
	      this.localPosition.set(x, y, z);
	    }

	    if (!this._dirtyLocal) this._dirtifyLocal();
	  };

	  _proto.setLocalRotation = function setLocalRotation(x, y, z, w) {
	    if (x instanceof Quat) {
	      this.localRotation.copy(x);
	    } else {
	      this.localRotation.set(x, y, z, w);
	    }

	    if (!this._dirtyLocal) this._dirtifyLocal();
	  };

	  _proto.setLocalScale = function setLocalScale(x, y, z) {
	    if (x instanceof Vec3) {
	      this.localScale.copy(x);
	    } else {
	      this.localScale.set(x, y, z);
	    }

	    if (!this._dirtyLocal) this._dirtifyLocal();
	  };

	  _proto._dirtifyLocal = function _dirtifyLocal() {
	    if (!this._dirtyLocal) {
	      this._dirtyLocal = true;
	      if (!this._dirtyWorld) this._dirtifyWorld();
	    }
	  };

	  _proto._unfreezeParentToRoot = function _unfreezeParentToRoot() {
	    var p = this._parent;

	    while (p) {
	      p._frozen = false;
	      p = p._parent;
	    }
	  };

	  _proto._dirtifyWorld = function _dirtifyWorld() {
	    if (!this._dirtyWorld) this._unfreezeParentToRoot();

	    this._dirtifyWorldInternal();
	  };

	  _proto._dirtifyWorldInternal = function _dirtifyWorldInternal() {
	    if (!this._dirtyWorld) {
	      this._frozen = false;
	      this._dirtyWorld = true;

	      for (var i = 0; i < this._children.length; i++) {
	        if (!this._children[i]._dirtyWorld) this._children[i]._dirtifyWorldInternal();
	      }
	    }

	    this._dirtyNormal = true;
	    this._aabbVer++;
	  };

	  _proto.setPosition = function setPosition(x, y, z) {
	    if (x instanceof Vec3) {
	      position$1.copy(x);
	    } else {
	      position$1.set(x, y, z);
	    }

	    if (this._parent === null) {
	      this.localPosition.copy(position$1);
	    } else {
	      invParentWtm$1.copy(this._parent.getWorldTransform()).invert();
	      invParentWtm$1.transformPoint(position$1, this.localPosition);
	    }

	    if (!this._dirtyLocal) this._dirtifyLocal();
	  };

	  _proto.setRotation = function setRotation(x, y, z, w) {
	    if (x instanceof Quat) {
	      rotation.copy(x);
	    } else {
	      rotation.set(x, y, z, w);
	    }

	    if (this._parent === null) {
	      this.localRotation.copy(rotation);
	    } else {
	      var parentRot = this._parent.getRotation();

	      invParentRot.copy(parentRot).invert();
	      this.localRotation.copy(invParentRot).mul(rotation);
	    }

	    if (!this._dirtyLocal) this._dirtifyLocal();
	  };

	  _proto.setEulerAngles = function setEulerAngles(x, y, z) {
	    this.localRotation.setFromEulerAngles(x, y, z);

	    if (this._parent !== null) {
	      var parentRot = this._parent.getRotation();

	      invParentRot.copy(parentRot).invert();
	      this.localRotation.mul2(invParentRot, this.localRotation);
	    }

	    if (!this._dirtyLocal) this._dirtifyLocal();
	  };

	  _proto.addChild = function addChild(node) {
	    this._prepareInsertChild(node);

	    this._children.push(node);

	    this._onInsertChild(node);
	  };

	  _proto.addChildAndSaveTransform = function addChildAndSaveTransform(node) {
	    var wPos = node.getPosition();
	    var wRot = node.getRotation();

	    this._prepareInsertChild(node);

	    node.setPosition(tmpMat4.copy(this.worldTransform).invert().transformPoint(wPos));
	    node.setRotation(tmpQuat.copy(this.getRotation()).invert().mul(wRot));

	    this._children.push(node);

	    this._onInsertChild(node);
	  };

	  _proto.insertChild = function insertChild(node, index) {
	    this._prepareInsertChild(node);

	    this._children.splice(index, 0, node);

	    this._onInsertChild(node);
	  };

	  _proto._prepareInsertChild = function _prepareInsertChild(node) {
	    if (node._parent) {
	      node._parent.removeChild(node);
	    }
	  };

	  _proto._fireOnHierarchy = function _fireOnHierarchy(name, nameHierarchy, parent) {
	    this.fire(name, parent);

	    for (var i = 0; i < this._children.length; i++) {
	      this._children[i]._fireOnHierarchy(nameHierarchy, nameHierarchy, parent);
	    }
	  };

	  _proto._onInsertChild = function _onInsertChild(node) {
	    node._parent = this;
	    var enabledInHierarchy = node._enabled && this.enabled;

	    if (node._enabledInHierarchy !== enabledInHierarchy) {
	      node._enabledInHierarchy = enabledInHierarchy;

	      node._notifyHierarchyStateChanged(node, enabledInHierarchy);
	    }

	    node._updateGraphDepth();

	    node._dirtifyWorld();

	    if (this._frozen) node._unfreezeParentToRoot();

	    node._fireOnHierarchy('insert', 'inserthierarchy', this);

	    if (this.fire) this.fire('childinsert', node);
	  };

	  _proto._updateGraphDepth = function _updateGraphDepth() {
	    this._graphDepth = this._parent ? this._parent._graphDepth + 1 : 0;

	    for (var i = 0, len = this._children.length; i < len; i++) {
	      this._children[i]._updateGraphDepth();
	    }
	  };

	  _proto.removeChild = function removeChild(child) {
	    var index = this._children.indexOf(child);

	    if (index === -1) {
	      return;
	    }

	    this._children.splice(index, 1);

	    child._parent = null;

	    child._fireOnHierarchy('remove', 'removehierarchy', this);

	    this.fire('childremove', child);
	  };

	  _proto._sync = function _sync() {
	    if (this._dirtyLocal) {
	      this.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale);
	      this._dirtyLocal = false;
	    }

	    if (this._dirtyWorld) {
	      if (this._parent === null) {
	        this.worldTransform.copy(this.localTransform);
	      } else {
	        if (this.scaleCompensation) {
	          var parentWorldScale;
	          var parent = this._parent;
	          var scale = this.localScale;
	          var parentToUseScaleFrom = parent;

	          if (parentToUseScaleFrom) {
	            while (parentToUseScaleFrom && parentToUseScaleFrom.scaleCompensation) {
	              parentToUseScaleFrom = parentToUseScaleFrom._parent;
	            }

	            if (parentToUseScaleFrom) {
	              parentToUseScaleFrom = parentToUseScaleFrom._parent;

	              if (parentToUseScaleFrom) {
	                parentWorldScale = parentToUseScaleFrom.worldTransform.getScale();
	                scaleCompensateScale.mul2(parentWorldScale, this.localScale);
	                scale = scaleCompensateScale;
	              }
	            }
	          }

	          scaleCompensateRot2.setFromMat4(parent.worldTransform);
	          scaleCompensateRot.mul2(scaleCompensateRot2, this.localRotation);
	          var tmatrix = parent.worldTransform;

	          if (parent.scaleCompensation) {
	            scaleCompensateScaleForParent.mul2(parentWorldScale, parent.getLocalScale());
	            scaleCompensatePosTransform.setTRS(parent.worldTransform.getTranslation(scaleCompensatePos), scaleCompensateRot2, scaleCompensateScaleForParent);
	            tmatrix = scaleCompensatePosTransform;
	          }

	          tmatrix.transformPoint(this.localPosition, scaleCompensatePos);
	          this.worldTransform.setTRS(scaleCompensatePos, scaleCompensateRot, scale);
	        } else {
	          this.worldTransform.mulAffine2(this._parent.worldTransform, this.localTransform);
	        }
	      }

	      this._dirtyWorld = false;
	    }
	  };

	  _proto.syncHierarchy = function syncHierarchy() {
	    if (!this._enabled) return;
	    if (this._frozen) return;
	    this._frozen = true;

	    if (this._dirtyLocal || this._dirtyWorld) {
	      this._sync();
	    }

	    var children = this._children;

	    for (var i = 0, len = children.length; i < len; i++) {
	      children[i].syncHierarchy();
	    }
	  };

	  _proto.lookAt = function lookAt(x, y, z, ux, uy, uz) {
	    if (ux === void 0) {
	      ux = 0;
	    }

	    if (uy === void 0) {
	      uy = 1;
	    }

	    if (uz === void 0) {
	      uz = 0;
	    }

	    if (x instanceof Vec3) {
	      target.copy(x);

	      if (y instanceof Vec3) {
	        up.copy(y);
	      } else {
	        up.copy(Vec3.UP);
	      }
	    } else if (z === undefined) {
	      return;
	    } else {
	      target.set(x, y, z);
	      up.set(ux, uy, uz);
	    }

	    matrix.setLookAt(this.getPosition(), target, up);
	    rotation.setFromMat4(matrix);
	    this.setRotation(rotation);
	  };

	  _proto.translate = function translate(x, y, z) {
	    if (x instanceof Vec3) {
	      position$1.copy(x);
	    } else {
	      position$1.set(x, y, z);
	    }

	    position$1.add(this.getPosition());
	    this.setPosition(position$1);
	  };

	  _proto.translateLocal = function translateLocal(x, y, z) {
	    if (x instanceof Vec3) {
	      position$1.copy(x);
	    } else {
	      position$1.set(x, y, z);
	    }

	    this.localRotation.transformVector(position$1, position$1);
	    this.localPosition.add(position$1);
	    if (!this._dirtyLocal) this._dirtifyLocal();
	  };

	  _proto.rotate = function rotate(x, y, z) {
	    rotation.setFromEulerAngles(x, y, z);

	    if (this._parent === null) {
	      this.localRotation.mul2(rotation, this.localRotation);
	    } else {
	      var rot = this.getRotation();

	      var parentRot = this._parent.getRotation();

	      invParentRot.copy(parentRot).invert();
	      rotation.mul2(invParentRot, rotation);
	      this.localRotation.mul2(rotation, rot);
	    }

	    if (!this._dirtyLocal) this._dirtifyLocal();
	  };

	  _proto.rotateLocal = function rotateLocal(x, y, z) {
	    rotation.setFromEulerAngles(x, y, z);
	    this.localRotation.mul(rotation);
	    if (!this._dirtyLocal) this._dirtifyLocal();
	  };

	  _createClass(GraphNode, [{
	    key: "right",
	    get: function get() {
	      if (!this._right) {
	        this._right = new Vec3();
	      }

	      return this.getWorldTransform().getX(this._right).normalize();
	    }
	  }, {
	    key: "up",
	    get: function get() {
	      if (!this._up) {
	        this._up = new Vec3();
	      }

	      return this.getWorldTransform().getY(this._up).normalize();
	    }
	  }, {
	    key: "forward",
	    get: function get() {
	      if (!this._forward) {
	        this._forward = new Vec3();
	      }

	      return this.getWorldTransform().getZ(this._forward).normalize().mulScalar(-1);
	    }
	  }, {
	    key: "enabled",
	    get: function get() {
	      return this._enabled && this._enabledInHierarchy;
	    },
	    set: function set(enabled) {
	      if (this._enabled !== enabled) {
	        var _this$_parent;

	        this._enabled = enabled;

	        if (enabled && (_this$_parent = this._parent) != null && _this$_parent.enabled || !enabled) {
	          this._notifyHierarchyStateChanged(this, enabled);
	        }
	      }
	    }
	  }, {
	    key: "parent",
	    get: function get() {
	      return this._parent;
	    }
	  }, {
	    key: "path",
	    get: function get() {
	      var node = this._parent;

	      if (!node) {
	        return '';
	      }

	      var result = this.name;

	      while (node && node._parent) {
	        result = node.name + "/" + result;
	        node = node._parent;
	      }

	      return result;
	    }
	  }, {
	    key: "root",
	    get: function get() {
	      var result = this;

	      while (result._parent) {
	        result = result._parent;
	      }

	      return result;
	    }
	  }, {
	    key: "children",
	    get: function get() {
	      return this._children;
	    }
	  }, {
	    key: "graphDepth",
	    get: function get() {
	      return this._graphDepth;
	    }
	  }]);

	  return GraphNode;
	}(EventHandler);

	var _viewMat = new Mat4();

	var _viewProjMat = new Mat4();

	var _viewportMatrix = new Mat4();

	var LightCamera = function () {
	  function LightCamera() {}

	  LightCamera.create = function create(name, lightType, face) {
	    var camera = new Camera();
	    camera.node = new GraphNode(name);
	    camera.aspectRatio = 1;
	    camera.aspectRatioMode = ASPECT_MANUAL;
	    camera._scissorRectClear = true;

	    switch (lightType) {
	      case LIGHTTYPE_OMNI:
	        camera.node.setRotation(LightCamera.pointLightRotations[face]);
	        camera.fov = 90;
	        camera.projection = PROJECTION_PERSPECTIVE;
	        break;

	      case LIGHTTYPE_SPOT:
	        camera.projection = PROJECTION_PERSPECTIVE;
	        break;

	      case LIGHTTYPE_DIRECTIONAL:
	        camera.projection = PROJECTION_ORTHOGRAPHIC;
	        break;
	    }

	    return camera;
	  };

	  LightCamera.evalSpotCookieMatrix = function evalSpotCookieMatrix(light) {
	    var cookieCamera = LightCamera._spotCookieCamera;

	    if (!cookieCamera) {
	      cookieCamera = LightCamera.create('SpotCookieCamera', LIGHTTYPE_SPOT);
	      LightCamera._spotCookieCamera = cookieCamera;
	    }

	    cookieCamera.fov = light._outerConeAngle * 2;
	    var cookieNode = cookieCamera._node;
	    cookieNode.setPosition(light._node.getPosition());
	    cookieNode.setRotation(light._node.getRotation());
	    cookieNode.rotateLocal(-90, 0, 0);

	    _viewMat.setTRS(cookieNode.getPosition(), cookieNode.getRotation(), Vec3.ONE).invert();

	    _viewProjMat.mul2(cookieCamera.projectionMatrix, _viewMat);

	    var cookieMatrix = light.cookieMatrix;
	    var rectViewport = light.atlasViewport;

	    _viewportMatrix.setViewport(rectViewport.x, rectViewport.y, rectViewport.z, rectViewport.w);

	    cookieMatrix.mul2(_viewportMatrix, _viewProjMat);
	    return cookieMatrix;
	  };

	  return LightCamera;
	}();

	LightCamera.pointLightRotations = [new Quat().setFromEulerAngles(0, 90, 180), new Quat().setFromEulerAngles(0, -90, 180), new Quat().setFromEulerAngles(90, 0, 0), new Quat().setFromEulerAngles(-90, 0, 0), new Quat().setFromEulerAngles(0, 180, 180), new Quat().setFromEulerAngles(0, 0, 180)];
	LightCamera._spotCookieCamera = null;

	var epsilon$1 = 0.000001;
	var tempVec3$1 = new Vec3();
	var tempAreaLightSizes = new Float32Array(6);
	var areaHalfAxisWidth = new Vec3(-0.5, 0, 0);
	var areaHalfAxisHeight = new Vec3(0, 0, 0.5);
	var TextureIndex8 = {
	  FLAGS: 0,
	  COLOR_A: 1,
	  COLOR_B: 2,
	  SPOT_ANGLES: 3,
	  SHADOW_BIAS: 4,
	  COOKIE_A: 5,
	  COOKIE_B: 6,
	  COUNT_ALWAYS: 7,
	  POSITION_X: 7,
	  POSITION_Y: 8,
	  POSITION_Z: 9,
	  RANGE: 10,
	  SPOT_DIRECTION_X: 11,
	  SPOT_DIRECTION_Y: 12,
	  SPOT_DIRECTION_Z: 13,
	  PROJ_MAT_00: 14,
	  ATLAS_VIEWPORT_A: 14,
	  PROJ_MAT_01: 15,
	  ATLAS_VIEWPORT_B: 15,
	  PROJ_MAT_02: 16,
	  PROJ_MAT_03: 17,
	  PROJ_MAT_10: 18,
	  PROJ_MAT_11: 19,
	  PROJ_MAT_12: 20,
	  PROJ_MAT_13: 21,
	  PROJ_MAT_20: 22,
	  PROJ_MAT_21: 23,
	  PROJ_MAT_22: 24,
	  PROJ_MAT_23: 25,
	  PROJ_MAT_30: 26,
	  PROJ_MAT_31: 27,
	  PROJ_MAT_32: 28,
	  PROJ_MAT_33: 29,
	  AREA_DATA_WIDTH_X: 30,
	  AREA_DATA_WIDTH_Y: 31,
	  AREA_DATA_WIDTH_Z: 32,
	  AREA_DATA_HEIGHT_X: 33,
	  AREA_DATA_HEIGHT_Y: 34,
	  AREA_DATA_HEIGHT_Z: 35,
	  COUNT: 36
	};
	var TextureIndexFloat = {
	  POSITION_RANGE: 0,
	  SPOT_DIRECTION: 1,
	  PROJ_MAT_0: 2,
	  ATLAS_VIEWPORT: 2,
	  PROJ_MAT_1: 3,
	  PROJ_MAT_2: 4,
	  PROJ_MAT_3: 5,
	  AREA_DATA_WIDTH: 6,
	  AREA_DATA_HEIGHT: 7,
	  COUNT: 8
	};

	var LightsBuffer = function () {
	  LightsBuffer.initShaderDefines = function initShaderDefines() {
	    var clusterTextureFormat = LightsBuffer.lightTextureFormat === LightsBuffer.FORMAT_FLOAT ? 'FLOAT' : '8BIT';
	    LightsBuffer.shaderDefines = "\n            \n#define CLUSTER_TEXTURE_" + clusterTextureFormat + "\n            " + LightsBuffer.buildShaderDefines(TextureIndex8, 'CLUSTER_TEXTURE_8_') + "\n            " + LightsBuffer.buildShaderDefines(TextureIndexFloat, 'CLUSTER_TEXTURE_F_') + "\n        ";
	  };

	  LightsBuffer.buildShaderDefines = function buildShaderDefines(object, prefix) {
	    var str = '';
	    Object.keys(object).forEach(function (key) {
	      str += "\n#define " + prefix + key + " " + object[key] + ".5";
	    });
	    return str;
	  };

	  LightsBuffer.init = function init(device) {
	    LightsBuffer.lightTextureFormat = device.extTextureFloat && device.maxTextures > 8 ? LightsBuffer.FORMAT_FLOAT : LightsBuffer.FORMAT_8BIT;
	    LightsBuffer.initShaderDefines();
	  };

	  LightsBuffer.createTexture = function createTexture(device, width, height, format, name) {
	    var tex = new Texture(device, {
	      name: name,
	      width: width,
	      height: height,
	      mipmaps: false,
	      format: format,
	      addressU: ADDRESS_CLAMP_TO_EDGE,
	      addressV: ADDRESS_CLAMP_TO_EDGE,
	      type: TEXTURETYPE_DEFAULT,
	      magFilter: FILTER_NEAREST,
	      minFilter: FILTER_NEAREST,
	      anisotropy: 1
	    });
	    return tex;
	  };

	  function LightsBuffer(device) {
	    this.device = device;
	    this.cookiesEnabled = false;
	    this.shadowsEnabled = false;
	    this.areaLightsEnabled = false;
	    this.maxLights = 255;
	    var pixelsPerLight8 = TextureIndex8.COUNT_ALWAYS;
	    var pixelsPerLightFloat = 0;

	    if (LightsBuffer.lightTextureFormat === LightsBuffer.FORMAT_FLOAT) {
	      pixelsPerLightFloat = TextureIndexFloat.COUNT;
	    } else {
	      pixelsPerLight8 = TextureIndex8.COUNT;
	    }

	    this.lights8 = new Uint8ClampedArray(4 * pixelsPerLight8 * this.maxLights);
	    this.lightsTexture8 = LightsBuffer.createTexture(this.device, pixelsPerLight8, this.maxLights, PIXELFORMAT_R8_G8_B8_A8, 'LightsTexture8');
	    this._lightsTexture8Id = this.device.scope.resolve('lightsTexture8');

	    if (pixelsPerLightFloat) {
	      this.lightsFloat = new Float32Array(4 * pixelsPerLightFloat * this.maxLights);
	      this.lightsTextureFloat = LightsBuffer.createTexture(this.device, pixelsPerLightFloat, this.maxLights, PIXELFORMAT_RGBA32F, 'LightsTextureFloat');
	      this._lightsTextureFloatId = this.device.scope.resolve('lightsTextureFloat');
	    } else {
	      this.lightsFloat = null;
	      this.lightsTextureFloat = null;
	      this._lightsTextureFloatId = undefined;
	    }

	    this._lightsTextureInvSizeId = this.device.scope.resolve('lightsTextureInvSize');
	    this._lightsTextureInvSizeData = new Float32Array(4);
	    this._lightsTextureInvSizeData[0] = pixelsPerLightFloat ? 1.0 / this.lightsTextureFloat.width : 0;
	    this._lightsTextureInvSizeData[1] = pixelsPerLightFloat ? 1.0 / this.lightsTextureFloat.height : 0;
	    this._lightsTextureInvSizeData[2] = 1.0 / this.lightsTexture8.width;
	    this._lightsTextureInvSizeData[3] = 1.0 / this.lightsTexture8.height;
	    this.invMaxColorValue = 0;
	    this.invMaxAttenuation = 0;
	    this.boundsMin = new Vec3();
	    this.boundsDelta = new Vec3();
	  }

	  var _proto = LightsBuffer.prototype;

	  _proto.destroy = function destroy() {
	    if (this.lightsTexture8) {
	      this.lightsTexture8.destroy();
	      this.lightsTexture8 = null;
	    }

	    if (this.lightsTextureFloat) {
	      this.lightsTextureFloat.destroy();
	      this.lightsTextureFloat = null;
	    }
	  };

	  _proto.setCompressionRanges = function setCompressionRanges(maxAttenuation, maxColorValue) {
	    this.invMaxColorValue = 1 / maxColorValue;
	    this.invMaxAttenuation = 1 / maxAttenuation;
	  };

	  _proto.setBounds = function setBounds(min, delta) {
	    this.boundsMin.copy(min);
	    this.boundsDelta.copy(delta);
	  };

	  _proto.uploadTextures = function uploadTextures() {
	    if (this.lightsTextureFloat) {
	      this.lightsTextureFloat.lock().set(this.lightsFloat);
	      this.lightsTextureFloat.unlock();
	    }

	    this.lightsTexture8.lock().set(this.lights8);
	    this.lightsTexture8.unlock();
	  };

	  _proto.updateUniforms = function updateUniforms() {
	    this._lightsTexture8Id.setValue(this.lightsTexture8);

	    if (LightsBuffer.lightTextureFormat === LightsBuffer.FORMAT_FLOAT) {
	      this._lightsTextureFloatId.setValue(this.lightsTextureFloat);
	    }

	    this._lightsTextureInvSizeId.setValue(this._lightsTextureInvSizeData);
	  };

	  _proto.getSpotDirection = function getSpotDirection(direction, spot) {
	    var mat = spot._node.getWorldTransform();

	    mat.getY(direction).mulScalar(-1);
	    direction.normalize();
	  };

	  _proto.getLightAreaSizes = function getLightAreaSizes(light) {
	    var mat = light._node.getWorldTransform();

	    mat.transformVector(areaHalfAxisWidth, tempVec3$1);
	    tempAreaLightSizes[0] = tempVec3$1.x;
	    tempAreaLightSizes[1] = tempVec3$1.y;
	    tempAreaLightSizes[2] = tempVec3$1.z;
	    mat.transformVector(areaHalfAxisHeight, tempVec3$1);
	    tempAreaLightSizes[3] = tempVec3$1.x;
	    tempAreaLightSizes[4] = tempVec3$1.y;
	    tempAreaLightSizes[5] = tempVec3$1.z;
	    return tempAreaLightSizes;
	  };

	  _proto.addLightDataFlags = function addLightDataFlags(data8, index, light, isSpot, castShadows, shadowIntensity) {
	    data8[index + 0] = isSpot ? 255 : 0;
	    data8[index + 1] = light._shape * 64;
	    data8[index + 2] = light._falloffMode * 255;
	    data8[index + 3] = castShadows ? shadowIntensity * 255 : 0;
	  };

	  _proto.addLightDataColor = function addLightDataColor(data8, index, light, gammaCorrection, isCookie) {
	    var invMaxColorValue = this.invMaxColorValue;
	    var color = gammaCorrection ? light._linearFinalColor : light._finalColor;
	    FloatPacking.float2Bytes(color[0] * invMaxColorValue, data8, index + 0, 2);
	    FloatPacking.float2Bytes(color[1] * invMaxColorValue, data8, index + 2, 2);
	    FloatPacking.float2Bytes(color[2] * invMaxColorValue, data8, index + 4, 2);
	    data8[index + 6] = isCookie ? 255 : 0;
	    var isDynamic = !!(light.mask & MASK_AFFECT_DYNAMIC);
	    var isLightmapped = !!(light.mask & MASK_AFFECT_LIGHTMAPPED);
	    data8[index + 7] = isDynamic && isLightmapped ? 127 : isLightmapped ? 255 : 0;
	  };

	  _proto.addLightDataSpotAngles = function addLightDataSpotAngles(data8, index, light) {
	    FloatPacking.float2Bytes(light._innerConeAngleCos * (0.5 - epsilon$1) + 0.5, data8, index + 0, 2);
	    FloatPacking.float2Bytes(light._outerConeAngleCos * (0.5 - epsilon$1) + 0.5, data8, index + 2, 2);
	  };

	  _proto.addLightDataShadowBias = function addLightDataShadowBias(data8, index, light) {
	    var lightRenderData = light.getRenderData(null, 0);

	    var biases = light._getUniformBiasValues(lightRenderData);

	    FloatPacking.float2BytesRange(biases.bias, data8, index, -1, 20, 2);
	    FloatPacking.float2Bytes(biases.normalBias, data8, index + 2, 2);
	  };

	  _proto.addLightDataPositionRange = function addLightDataPositionRange(data8, index, light, pos) {
	    var normPos = tempVec3$1.sub2(pos, this.boundsMin).div(this.boundsDelta);
	    FloatPacking.float2Bytes(normPos.x, data8, index + 0, 4);
	    FloatPacking.float2Bytes(normPos.y, data8, index + 4, 4);
	    FloatPacking.float2Bytes(normPos.z, data8, index + 8, 4);
	    FloatPacking.float2Bytes(light.attenuationEnd * this.invMaxAttenuation, data8, index + 12, 4);
	  };

	  _proto.addLightDataSpotDirection = function addLightDataSpotDirection(data8, index, light) {
	    this.getSpotDirection(tempVec3$1, light);
	    FloatPacking.float2Bytes(tempVec3$1.x * (0.5 - epsilon$1) + 0.5, data8, index + 0, 4);
	    FloatPacking.float2Bytes(tempVec3$1.y * (0.5 - epsilon$1) + 0.5, data8, index + 4, 4);
	    FloatPacking.float2Bytes(tempVec3$1.z * (0.5 - epsilon$1) + 0.5, data8, index + 8, 4);
	  };

	  _proto.addLightDataLightProjMatrix = function addLightDataLightProjMatrix(data8, index, lightProjectionMatrix) {
	    var matData = lightProjectionMatrix.data;

	    for (var m = 0; m < 12; m++) {
	      FloatPacking.float2BytesRange(matData[m], data8, index + 4 * m, -2, 2, 4);
	    }

	    for (var _m = 12; _m < 16; _m++) {
	      FloatPacking.float2MantissaExponent(matData[_m], data8, index + 4 * _m, 4);
	    }
	  };

	  _proto.addLightDataCookies = function addLightDataCookies(data8, index, light) {
	    var isRgb = light._cookieChannel === 'rgb';
	    data8[index + 0] = Math.floor(light.cookieIntensity * 255);
	    data8[index + 1] = isRgb ? 255 : 0;

	    if (!isRgb) {
	      var channel = light._cookieChannel;
	      data8[index + 4] = channel === 'rrr' ? 255 : 0;
	      data8[index + 5] = channel === 'ggg' ? 255 : 0;
	      data8[index + 6] = channel === 'bbb' ? 255 : 0;
	      data8[index + 7] = channel === 'aaa' ? 255 : 0;
	    }
	  };

	  _proto.addLightAtlasViewport = function addLightAtlasViewport(data8, index, atlasViewport) {
	    FloatPacking.float2Bytes(atlasViewport.x, data8, index + 0, 2);
	    FloatPacking.float2Bytes(atlasViewport.y, data8, index + 2, 2);
	    FloatPacking.float2Bytes(atlasViewport.z / 3, data8, index + 4, 2);
	  };

	  _proto.addLightAreaSizes = function addLightAreaSizes(data8, index, light) {
	    var areaSizes = this.getLightAreaSizes(light);

	    for (var i = 0; i < 6; i++) {
	      FloatPacking.float2MantissaExponent(areaSizes[i], data8, index + 4 * i, 4);
	    }
	  };

	  _proto.addLightData = function addLightData(light, lightIndex, gammaCorrection) {
	    var isSpot = light._type === LIGHTTYPE_SPOT;
	    var hasAtlasViewport = light.atlasViewportAllocated;
	    var isCookie = this.cookiesEnabled && !!light._cookie && hasAtlasViewport;
	    var isArea = this.areaLightsEnabled && light.shape !== LIGHTSHAPE_PUNCTUAL;
	    var castShadows = this.shadowsEnabled && light.castShadows && hasAtlasViewport;

	    var pos = light._node.getPosition();

	    var lightProjectionMatrix = null;
	    var atlasViewport = null;

	    if (isSpot) {
	      if (castShadows) {
	        var lightRenderData = light.getRenderData(null, 0);
	        lightProjectionMatrix = lightRenderData.shadowMatrix;
	      } else if (isCookie) {
	        lightProjectionMatrix = LightCamera.evalSpotCookieMatrix(light);
	      }
	    } else {
	      if (castShadows || isCookie) {
	        atlasViewport = light.atlasViewport;
	      }
	    }

	    var data8 = this.lights8;
	    var data8Start = lightIndex * this.lightsTexture8.width * 4;
	    this.addLightDataFlags(data8, data8Start + 4 * TextureIndex8.FLAGS, light, isSpot, castShadows, light.shadowIntensity);
	    this.addLightDataColor(data8, data8Start + 4 * TextureIndex8.COLOR_A, light, gammaCorrection, isCookie);

	    if (isSpot) {
	      this.addLightDataSpotAngles(data8, data8Start + 4 * TextureIndex8.SPOT_ANGLES, light);
	    }

	    if (light.castShadows) {
	      this.addLightDataShadowBias(data8, data8Start + 4 * TextureIndex8.SHADOW_BIAS, light);
	    }

	    if (isCookie) {
	      this.addLightDataCookies(data8, data8Start + 4 * TextureIndex8.COOKIE_A, light);
	    }

	    if (LightsBuffer.lightTextureFormat === LightsBuffer.FORMAT_FLOAT) {
	      var dataFloat = this.lightsFloat;
	      var dataFloatStart = lightIndex * this.lightsTextureFloat.width * 4;
	      dataFloat[dataFloatStart + 4 * TextureIndexFloat.POSITION_RANGE + 0] = pos.x;
	      dataFloat[dataFloatStart + 4 * TextureIndexFloat.POSITION_RANGE + 1] = pos.y;
	      dataFloat[dataFloatStart + 4 * TextureIndexFloat.POSITION_RANGE + 2] = pos.z;
	      dataFloat[dataFloatStart + 4 * TextureIndexFloat.POSITION_RANGE + 3] = light.attenuationEnd;

	      if (isSpot) {
	        this.getSpotDirection(tempVec3$1, light);
	        dataFloat[dataFloatStart + 4 * TextureIndexFloat.SPOT_DIRECTION + 0] = tempVec3$1.x;
	        dataFloat[dataFloatStart + 4 * TextureIndexFloat.SPOT_DIRECTION + 1] = tempVec3$1.y;
	        dataFloat[dataFloatStart + 4 * TextureIndexFloat.SPOT_DIRECTION + 2] = tempVec3$1.z;
	      }

	      if (lightProjectionMatrix) {
	        var matData = lightProjectionMatrix.data;

	        for (var m = 0; m < 16; m++) {
	          dataFloat[dataFloatStart + 4 * TextureIndexFloat.PROJ_MAT_0 + m] = matData[m];
	        }
	      }

	      if (atlasViewport) {
	        dataFloat[dataFloatStart + 4 * TextureIndexFloat.ATLAS_VIEWPORT + 0] = atlasViewport.x;
	        dataFloat[dataFloatStart + 4 * TextureIndexFloat.ATLAS_VIEWPORT + 1] = atlasViewport.y;
	        dataFloat[dataFloatStart + 4 * TextureIndexFloat.ATLAS_VIEWPORT + 2] = atlasViewport.z / 3;
	      }

	      if (isArea) {
	        var areaSizes = this.getLightAreaSizes(light);
	        dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_WIDTH + 0] = areaSizes[0];
	        dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_WIDTH + 1] = areaSizes[1];
	        dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_WIDTH + 2] = areaSizes[2];
	        dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_HEIGHT + 0] = areaSizes[3];
	        dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_HEIGHT + 1] = areaSizes[4];
	        dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_HEIGHT + 2] = areaSizes[5];
	      }
	    } else {
	      this.addLightDataPositionRange(data8, data8Start + 4 * TextureIndex8.POSITION_X, light, pos);

	      if (isSpot) {
	        this.addLightDataSpotDirection(data8, data8Start + 4 * TextureIndex8.SPOT_DIRECTION_X, light);
	      }

	      if (lightProjectionMatrix) {
	        this.addLightDataLightProjMatrix(data8, data8Start + 4 * TextureIndex8.PROJ_MAT_00, lightProjectionMatrix);
	      }

	      if (atlasViewport) {
	        this.addLightAtlasViewport(data8, data8Start + 4 * TextureIndex8.ATLAS_VIEWPORT_A, atlasViewport);
	      }

	      if (isArea) {
	        this.addLightAreaSizes(data8, data8Start + 4 * TextureIndex8.AREA_DATA_WIDTH_X, light);
	      }
	    }
	  };

	  return LightsBuffer;
	}();

	LightsBuffer.FORMAT_FLOAT = 0;
	LightsBuffer.FORMAT_8BIT = 1;
	LightsBuffer.lightTextureFormat = LightsBuffer.FORMAT_8BIT;
	LightsBuffer.shaderDefines = '';

	var builtinAttributes = {
	  vertex_normal: SEMANTIC_NORMAL,
	  vertex_tangent: SEMANTIC_TANGENT,
	  vertex_texCoord0: SEMANTIC_TEXCOORD0,
	  vertex_texCoord1: SEMANTIC_TEXCOORD1,
	  vertex_color: SEMANTIC_COLOR,
	  vertex_boneWeights: SEMANTIC_BLENDWEIGHT,
	  vertex_boneIndices: SEMANTIC_BLENDINDICES
	};
	var builtinVaryings = {
	  vVertexColor: "vec4",
	  vPositionW: "vec3",
	  vNormalV: "vec3",
	  vNormalW: "vec3",
	  vTangentW: "vec3",
	  vBinormalW: "vec3",
	  vObjectSpaceUpW: "vec3",
	  vUv0: "vec2",
	  vUv1: "vec2"
	};

	var LitShader = function () {
	  function LitShader(device, options) {
	    this.device = device;
	    this.options = options;
	    this.attributes = {
	      vertex_position: SEMANTIC_POSITION
	    };

	    if (options.chunks) {
	      this.chunks = {};
	      var userChunks = options.chunks;

	      for (var chunkName in shaderChunks) {
	        if (userChunks.hasOwnProperty(chunkName)) {
	          var chunk = userChunks[chunkName];

	          for (var a in builtinAttributes) {
	            if (builtinAttributes.hasOwnProperty(a) && chunk.indexOf(a) >= 0) {
	              this.attributes[a] = builtinAttributes[a];
	            }
	          }

	          this.chunks[chunkName] = chunk;
	        } else {
	          this.chunks[chunkName] = shaderChunks[chunkName];
	        }
	      }
	    } else {
	      this.chunks = shaderChunks;
	    }

	    this.lighting = options.lights.length > 0 || !!options.dirLightMap || !!options.clusteredLightingEnabled;
	    this.reflections = !!options.reflectionSource;
	    if (!options.useSpecular) options.specularMap = options.glossMap = null;
	    this.shadowPass = ShaderPass.isShadow(options.pass);
	    this.needsNormal = this.lighting || this.reflections || options.useSpecular || options.ambientSH || options.heightMap || options.enableGGXSpecular || options.clusteredLightingEnabled && !this.shadowPass || options.clearCoatNormalMap;
	    this.needsSceneColor = options.useDynamicRefraction;
	    this.needsScreenSize = options.useDynamicRefraction;
	    this.needsTransforms = options.useDynamicRefraction;
	    this.varyings = "";
	    this.vshader = null;
	    this.frontendDecl = null;
	    this.frontendCode = null;
	    this.frontendFunc = null;
	    this.lightingUv = null;
	    this.defines = [];
	    this.fshader = null;
	  }

	  var _proto = LitShader.prototype;

	  _proto._vsAddBaseCode = function _vsAddBaseCode(code, chunks, options) {
	    code += chunks.baseVS;

	    if (options.nineSlicedMode === SPRITE_RENDERMODE_SLICED || options.nineSlicedMode === SPRITE_RENDERMODE_TILED) {
	      code += chunks.baseNineSlicedVS;
	    }

	    return code;
	  };

	  _proto._vsAddTransformCode = function _vsAddTransformCode(code, device, chunks, options) {
	    code += this.chunks.transformVS;
	    return code;
	  };

	  _proto._setMapTransform = function _setMapTransform(codes, name, id, uv) {
	    var checkId = id + uv * 100;

	    if (!codes[3][checkId]) {
	      var varName = "texture_" + name + "MapTransform";
	      codes[0] += "uniform vec3 " + varName + "0;\n";
	      codes[0] += "uniform vec3 " + varName + "1;\n";
	      codes[1] += "varying vec2 vUV" + uv + "_" + id + ";\n";
	      codes[2] += "   vUV" + uv + "_" + id + " = vec2(dot(vec3(uv" + uv + ", 1), " + varName + "0), dot(vec3(uv" + uv + ", 1), " + varName + "1));\n";
	      codes[3][checkId] = true;
	    }

	    return codes;
	  };

	  _proto._fsGetBaseCode = function _fsGetBaseCode() {
	    var options = this.options;
	    var chunks = this.chunks;
	    var result = this.chunks.basePS;

	    if (options.nineSlicedMode === SPRITE_RENDERMODE_SLICED) {
	      result += chunks.baseNineSlicedPS;
	    } else if (options.nineSlicedMode === SPRITE_RENDERMODE_TILED) {
	      result += chunks.baseNineSlicedTiledPS;
	    }

	    return result;
	  };

	  _proto._fsGetStartCode = function _fsGetStartCode(code, device, chunks, options) {
	    var result = chunks.startPS;

	    if (options.nineSlicedMode === SPRITE_RENDERMODE_SLICED) {
	      result += chunks.startNineSlicedPS;
	    } else if (options.nineSlicedMode === SPRITE_RENDERMODE_TILED) {
	      result += chunks.startNineSlicedTiledPS;
	    }

	    return result;
	  };

	  _proto._directionalShadowMapProjection = function _directionalShadowMapProjection(light, shadowCoordArgs, shadowParamArg, lightIndex, coordsFunctionName) {
	    var code = "";

	    if (light.numCascades > 1) {
	      code += "getShadowCascadeMatrix(light" + lightIndex + "_shadowMatrixPalette, light" + lightIndex + "_shadowCascadeDistances, light" + lightIndex + "_shadowCascadeCount);\n";
	      shadowCoordArgs = "(cascadeShadowMat, " + shadowParamArg + ");\n";
	    }

	    code += coordsFunctionName + shadowCoordArgs;
	    code += "fadeShadow(light" + lightIndex + "_shadowCascadeDistances);\n";
	    return code;
	  };

	  _proto._nonPointShadowMapProjection = function _nonPointShadowMapProjection(device, light, shadowMatArg, shadowParamArg, lightIndex) {
	    var shadowCoordArgs = "(" + shadowMatArg + ", " + shadowParamArg + ");\n";

	    if (!light._normalOffsetBias || light._isVsm) {
	      if (light._type === LIGHTTYPE_SPOT) {
	        if (light._isPcf && (device.webgl2 || device.extStandardDerivatives)) {
	          return "       getShadowCoordPerspZbuffer" + shadowCoordArgs;
	        }

	        return "       getShadowCoordPersp" + shadowCoordArgs;
	      }

	      return this._directionalShadowMapProjection(light, shadowCoordArgs, shadowParamArg, lightIndex, "getShadowCoordOrtho");
	    }

	    if (light._type === LIGHTTYPE_SPOT) {
	      if (light._isPcf && (device.webgl2 || device.extStandardDerivatives)) {
	        return "       getShadowCoordPerspZbufferNormalOffset" + shadowCoordArgs;
	      }

	      return "       getShadowCoordPerspNormalOffset" + shadowCoordArgs;
	    }

	    return this._directionalShadowMapProjection(light, shadowCoordArgs, shadowParamArg, lightIndex, "getShadowCoordOrthoNormalOffset");
	  };

	  _proto._getLightSourceShapeString = function _getLightSourceShapeString(shape) {
	    switch (shape) {
	      case LIGHTSHAPE_RECT:
	        return 'Rect';

	      case LIGHTSHAPE_DISK:
	        return 'Disk';

	      case LIGHTSHAPE_SPHERE:
	        return 'Sphere';

	      default:
	        return '';
	    }
	  };

	  _proto.generateVertexShader = function generateVertexShader(useUv, useUnmodifiedUv, mapTransforms) {
	    var _this = this;

	    var device = this.device;
	    var options = this.options;
	    var chunks = this.chunks;
	    var code = '';
	    var codeBody = '';
	    code = this._vsAddBaseCode(code, chunks, options);
	    codeBody += "   vPositionW    = getWorldPosition();\n";

	    if (this.options.pass === SHADER_DEPTH) {
	      code += 'varying float vDepth;\n';
	      code += '#ifndef VIEWMATRIX\n';
	      code += '#define VIEWMATRIX\n';
	      code += 'uniform mat4 matrix_view;\n';
	      code += '#endif\n';
	      code += '#ifndef CAMERAPLANES\n';
	      code += '#define CAMERAPLANES\n';
	      code += 'uniform vec4 camera_params;\n\n';
	      code += '#endif\n';
	      codeBody += "    vDepth = -(matrix_view * vec4(vPositionW,1.0)).z * camera_params.x;\n";
	    }

	    if (this.options.useInstancing) {
	      this.attributes.instance_line1 = SEMANTIC_ATTR12;
	      this.attributes.instance_line2 = SEMANTIC_ATTR13;
	      this.attributes.instance_line3 = SEMANTIC_ATTR14;
	      this.attributes.instance_line4 = SEMANTIC_ATTR15;
	      code += chunks.instancingVS;
	    }

	    if (this.needsNormal) {
	      this.attributes.vertex_normal = SEMANTIC_NORMAL;
	      codeBody += "   vNormalW = getNormal();\n";

	      if (options.reflectionSource === 'sphereMap' && device.fragmentUniformsCount <= 16) {
	        code += chunks.viewNormalVS;
	        codeBody += "   vNormalV    = getViewNormal();\n";
	      }

	      if (options.hasTangents && (options.heightMap || options.normalMap || options.enableGGXSpecular)) {
	        this.attributes.vertex_tangent = SEMANTIC_TANGENT;
	        code += chunks.tangentBinormalVS;
	        codeBody += "   vTangentW   = getTangent();\n";
	        codeBody += "   vBinormalW  = getBinormal();\n";
	      } else if (options.enableGGXSpecular) {
	        code += chunks.tangentBinormalVS;
	        codeBody += "   vObjectSpaceUpW  = getObjectSpaceUp();\n";
	      }
	    }

	    var maxUvSets = 2;

	    for (var i = 0; i < maxUvSets; i++) {
	      if (useUv[i]) {
	        this.attributes["vertex_texCoord" + i] = "TEXCOORD" + i;
	        code += chunks["uv" + i + "VS"];
	        codeBody += "   vec2 uv" + i + " = getUv" + i + "();\n";
	      }

	      if (useUnmodifiedUv[i]) {
	        codeBody += "   vUv" + i + " = uv" + i + ";\n";
	      }
	    }

	    var codes = [code, this.varyings, codeBody, []];
	    mapTransforms.forEach(function (mapTransform) {
	      _this._setMapTransform(codes, mapTransform.name, mapTransform.id, mapTransform.uv);
	    });
	    code = codes[0];
	    this.varyings = codes[1];
	    codeBody = codes[2];

	    if (options.vertexColors) {
	      this.attributes.vertex_color = SEMANTIC_COLOR;
	      codeBody += "   vVertexColor = vertex_color;\n";
	    }

	    if (options.msdf && options.msdfTextAttribute) {
	      this.attributes.vertex_outlineParameters = SEMANTIC_ATTR8;
	      this.attributes.vertex_shadowParameters = SEMANTIC_ATTR9;
	      codeBody += "    unpackMsdfParams();\n";
	      code += chunks.msdfVS;
	    }

	    if (options.useMorphPosition || options.useMorphNormal) {
	      if (options.useMorphTextureBased) {
	        code += "#define MORPHING_TEXTURE_BASED\n";

	        if (options.useMorphPosition) {
	          code += "#define MORPHING_TEXTURE_BASED_POSITION\n";
	        }

	        if (options.useMorphNormal) {
	          code += "#define MORPHING_TEXTURE_BASED_NORMAL\n";
	        }

	        this.attributes.morph_vertex_id = SEMANTIC_ATTR15;
	        code += "attribute float morph_vertex_id;\n";
	      } else {
	        code += "#define MORPHING\n";

	        if (options.useMorphPosition) {
	          this.attributes.morph_pos0 = SEMANTIC_ATTR8;
	          this.attributes.morph_pos1 = SEMANTIC_ATTR9;
	          this.attributes.morph_pos2 = SEMANTIC_ATTR10;
	          this.attributes.morph_pos3 = SEMANTIC_ATTR11;
	          code += "#define MORPHING_POS03\n";
	          code += "attribute vec3 morph_pos0;\n";
	          code += "attribute vec3 morph_pos1;\n";
	          code += "attribute vec3 morph_pos2;\n";
	          code += "attribute vec3 morph_pos3;\n";
	        } else if (options.useMorphNormal) {
	          this.attributes.morph_nrm0 = SEMANTIC_ATTR8;
	          this.attributes.morph_nrm1 = SEMANTIC_ATTR9;
	          this.attributes.morph_nrm2 = SEMANTIC_ATTR10;
	          this.attributes.morph_nrm3 = SEMANTIC_ATTR11;
	          code += "#define MORPHING_NRM03\n";
	          code += "attribute vec3 morph_nrm0;\n";
	          code += "attribute vec3 morph_nrm1;\n";
	          code += "attribute vec3 morph_nrm2;\n";
	          code += "attribute vec3 morph_nrm3;\n";
	        }

	        if (!options.useMorphNormal) {
	          this.attributes.morph_pos4 = SEMANTIC_ATTR12;
	          this.attributes.morph_pos5 = SEMANTIC_ATTR13;
	          this.attributes.morph_pos6 = SEMANTIC_ATTR14;
	          this.attributes.morph_pos7 = SEMANTIC_ATTR15;
	          code += "#define MORPHING_POS47\n";
	          code += "attribute vec3 morph_pos4;\n";
	          code += "attribute vec3 morph_pos5;\n";
	          code += "attribute vec3 morph_pos6;\n";
	          code += "attribute vec3 morph_pos7;\n";
	        } else {
	          this.attributes.morph_nrm4 = SEMANTIC_ATTR12;
	          this.attributes.morph_nrm5 = SEMANTIC_ATTR13;
	          this.attributes.morph_nrm6 = SEMANTIC_ATTR14;
	          this.attributes.morph_nrm7 = SEMANTIC_ATTR15;
	          code += "#define MORPHING_NRM47\n";
	          code += "attribute vec3 morph_nrm4;\n";
	          code += "attribute vec3 morph_nrm5;\n";
	          code += "attribute vec3 morph_nrm6;\n";
	          code += "attribute vec3 morph_nrm7;\n";
	        }
	      }
	    }

	    if (options.skin) {
	      this.attributes.vertex_boneWeights = SEMANTIC_BLENDWEIGHT;
	      this.attributes.vertex_boneIndices = SEMANTIC_BLENDINDICES;
	      code += skinCode(device, chunks);
	      code += "#define SKIN\n";
	    } else if (options.useInstancing) {
	      code += "#define INSTANCING\n";
	    }

	    if (options.screenSpace) {
	      code += "#define SCREENSPACE\n";
	    }

	    if (options.pixelSnap) {
	      code += "#define PIXELSNAP\n";
	    }

	    code = this._vsAddTransformCode(code, device, chunks, options);

	    if (this.needsNormal) {
	      code += chunks.normalVS;
	    }

	    code += "\n";
	    code += chunks.startVS;
	    code += codeBody;
	    code += chunks.endVS;
	    code += "}";
	    Object.keys(builtinVaryings).forEach(function (v) {
	      if (code.indexOf(v) >= 0) {
	        _this.varyings += "varying " + builtinVaryings[v] + " " + v + ";\n";
	      }
	    });
	    var startCode = vertexIntro(device, 'LitShader', this.options.pass, chunks.extensionVS);
	    this.vshader = startCode + this.varyings + code;
	  };

	  _proto._fsGetBeginCode = function _fsGetBeginCode() {
	    var device = this.device;
	    var chunks = this.chunks;
	    var precision = this.options.forceFragmentPrecision;
	    var code = fragmentIntro(device, 'LitShader', this.options.pass, chunks.extensionPS, precision);

	    for (var i = 0; i < this.defines.length; i++) {
	      code += "#define " + this.defines[i] + "\n";
	    }

	    return code;
	  };

	  _proto._fsGetPickPassCode = function _fsGetPickPassCode() {
	    var code = this._fsGetBeginCode();

	    code += "uniform vec4 uColor;\n";
	    code += this.varyings;
	    code += this.frontendDecl;
	    code += this.frontendCode;
	    code += begin();
	    code += this.frontendFunc;
	    code += "    gl_FragColor = uColor;\n";
	    code += end();
	    return code;
	  };

	  _proto._fsGetDepthPassCode = function _fsGetDepthPassCode() {
	    var chunks = this.chunks;

	    var code = this._fsGetBeginCode();

	    code += 'varying float vDepth;\n';
	    code += this.varyings;
	    code += chunks.packDepthPS;
	    code += this.frontendDecl;
	    code += this.frontendCode;
	    code += begin();
	    code += this.frontendFunc;
	    code += "    gl_FragColor = packFloat(vDepth);\n";
	    code += end();
	    return code;
	  };

	  _proto._fsGetShadowPassCode = function _fsGetShadowPassCode() {
	    var device = this.device;
	    var options = this.options;
	    var chunks = this.chunks;
	    var varyings = this.varyings;
	    var lightType = ShaderPass.toLightType(options.pass);
	    var shadowType = ShaderPass.toShadowType(options.pass);

	    var code = this._fsGetBeginCode();

	    if (device.extStandardDerivatives && !device.webgl2) {
	      code += 'uniform vec2 polygonOffset;\n';
	    }

	    if (shadowType === SHADOW_VSM32) {
	      if (device.textureFloatHighPrecision) {
	        code += '#define VSM_EXPONENT 15.0\n\n';
	      } else {
	        code += '#define VSM_EXPONENT 5.54\n\n';
	      }
	    } else if (shadowType === SHADOW_VSM16) {
	      code += '#define VSM_EXPONENT 5.54\n\n';
	    }

	    if (lightType !== LIGHTTYPE_DIRECTIONAL) {
	      code += 'uniform vec3 view_position;\n';
	      code += 'uniform float light_radius;\n';
	    }

	    code += varyings;
	    code += this.frontendDecl;
	    code += this.frontendCode;

	    if (shadowType === SHADOW_PCF3 && (!device.webgl2 || lightType === LIGHTTYPE_OMNI)) {
	      code += chunks.packDepthPS;
	    } else if (shadowType === SHADOW_VSM8) {
	      code += "vec2 encodeFloatRG( float v ) {\n";
	      code += "    vec2 enc = vec2(1.0, 255.0) * v;\n";
	      code += "    enc = fract(enc);\n";
	      code += "    enc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\n";
	      code += "    return enc;\n";
	      code += "}\n\n";
	    }

	    code += begin();
	    code += this.frontendFunc;
	    var isVsm = shadowType === SHADOW_VSM8 || shadowType === SHADOW_VSM16 || shadowType === SHADOW_VSM32;
	    var applySlopeScaleBias = !device.webgl2 && device.extStandardDerivatives;

	    if (lightType === LIGHTTYPE_OMNI || isVsm && lightType !== LIGHTTYPE_DIRECTIONAL) {
	      code += "    float depth = min(distance(view_position, vPositionW) / light_radius, 0.99999);\n";
	    } else {
	      code += "    float depth = gl_FragCoord.z;\n";
	    }

	    if (applySlopeScaleBias) {
	      code += "    float minValue = 2.3374370500153186e-10; //(1.0 / 255.0) / (256.0 * 256.0 * 256.0);\n";
	      code += "    depth += polygonOffset.x * max(abs(dFdx(depth)), abs(dFdy(depth))) + minValue * polygonOffset.y;\n";
	    }

	    if (shadowType === SHADOW_PCF3 && (!device.webgl2 || lightType === LIGHTTYPE_OMNI && !options.clusteredLightingEnabled)) {
	      code += "    gl_FragColor = packFloat(depth);\n";
	    } else if (shadowType === SHADOW_PCF3 || shadowType === SHADOW_PCF5) {
	      code += "    gl_FragColor = vec4(1.0);\n";

	      if (options.clusteredLightingEnabled && lightType === LIGHTTYPE_OMNI && device.webgl2) {
	        code += "    gl_FragDepth = depth;\n";
	      }
	    } else if (shadowType === SHADOW_VSM8) {
	      code += "    gl_FragColor = vec4(encodeFloatRG(depth), encodeFloatRG(depth*depth));\n";
	    } else {
	      code += chunks.storeEVSMPS;
	    }

	    code += end();
	    return code;
	  };

	  _proto._fsGetLitPassCode = function _fsGetLitPassCode() {
	    var device = this.device;
	    var options = this.options;
	    var chunks = this.chunks;
	    var code = "";

	    if (options.opacityFadesSpecular === false) {
	      code += 'uniform float material_alphaFade;\n';
	    }

	    if (options.useSpecular) {
	      this.defines.push("LIT_SPECULAR");

	      if (this.reflections) {
	        this.defines.push("LIT_REFLECTIONS");
	      }

	      if (options.clearCoat) {
	        this.defines.push("LIT_CLEARCOAT");
	      }

	      if (options.fresnelModel > 0) {
	        this.defines.push("LIT_SPECULAR_FRESNEL");
	      }

	      if (options.conserveEnergy) {
	        this.defines.push("LIT_CONSERVE_ENERGY");
	      }

	      if (options.sheen) {
	        this.defines.push("LIT_SHEEN");
	      }
	    }

	    var shadowTypeUsed = [];
	    var numShadowLights = 0;
	    var shadowedDirectionalLightUsed = false;
	    var useVsm = false;
	    var usePerspZbufferShadow = false;
	    var hasAreaLights = options.lights.some(function (light) {
	      return light._shape && light._shape !== LIGHTSHAPE_PUNCTUAL;
	    });

	    if (options.clusteredLightingEnabled && options.clusteredLightingAreaLightsEnabled) {
	      hasAreaLights = true;
	    }

	    if (device.areaLightLutFormat === PIXELFORMAT_R8_G8_B8_A8) {
	      code += "#define AREA_R8_G8_B8_A8_LUTS\n";
	      code += "#define AREA_LUTS_PRECISION lowp\n";
	    } else {
	      code += "#define AREA_LUTS_PRECISION highp\n";
	    }

	    if (hasAreaLights || options.clusteredLightingEnabled) {
	      code += "#define AREA_LIGHTS\n";
	      code += "uniform AREA_LUTS_PRECISION sampler2D areaLightsLutTex1;\n";
	      code += "uniform AREA_LUTS_PRECISION sampler2D areaLightsLutTex2;\n";
	    }

	    for (var i = 0; i < options.lights.length; i++) {
	      var light = options.lights[i];
	      var lightType = light._type;
	      if (options.clusteredLightingEnabled && lightType !== LIGHTTYPE_DIRECTIONAL) continue;
	      var lightShape = hasAreaLights && light._shape ? light._shape : LIGHTSHAPE_PUNCTUAL;
	      code += "uniform vec3 light" + i + "_color;\n";

	      if (lightType === LIGHTTYPE_DIRECTIONAL) {
	        code += "uniform vec3 light" + i + "_direction;\n";
	      } else {
	        code += "uniform vec3 light" + i + "_position;\n";
	        code += "uniform float light" + i + "_radius;\n";

	        if (lightType === LIGHTTYPE_SPOT) {
	          code += "uniform vec3 light" + i + "_direction;\n";
	          code += "uniform float light" + i + "_innerConeAngle;\n";
	          code += "uniform float light" + i + "_outerConeAngle;\n";
	        }
	      }

	      if (lightShape !== LIGHTSHAPE_PUNCTUAL) {
	        if (lightType === LIGHTTYPE_DIRECTIONAL) {
	          code += "uniform vec3 light" + i + "_position;\n";
	        }

	        code += "uniform vec3 light" + i + "_halfWidth;\n";
	        code += "uniform vec3 light" + i + "_halfHeight;\n";
	      }

	      if (light.castShadows && !options.noShadow) {
	        code += "uniform mat4 light" + i + "_shadowMatrix;\n";
	        code += "uniform float light" + i + "_shadowIntensity;\n";

	        if (lightType === LIGHTTYPE_DIRECTIONAL) {
	          code += "uniform mat4 light" + i + "_shadowMatrixPalette[4];\n";
	          code += "uniform float light" + i + "_shadowCascadeDistances[4];\n";
	          code += "uniform float light" + i + "_shadowCascadeCount;\n";
	        }

	        if (lightType !== LIGHTTYPE_DIRECTIONAL) {
	          code += "uniform vec4 light" + i + "_shadowParams;\n";
	        } else {
	          shadowedDirectionalLightUsed = true;
	          code += "uniform vec3 light" + i + "_shadowParams;\n";
	        }

	        if (lightType === LIGHTTYPE_OMNI) {
	          code += "uniform samplerCube light" + i + "_shadowMap;\n";
	        } else {
	          if (light._isPcf && device.webgl2) {
	            code += "uniform sampler2DShadow light" + i + "_shadowMap;\n";
	          } else {
	            code += "uniform sampler2D light" + i + "_shadowMap;\n";
	          }
	        }

	        numShadowLights++;
	        shadowTypeUsed[light._shadowType] = true;
	        if (light._isVsm) useVsm = true;
	        if (light._isPcf && (device.webgl2 || device.extStandardDerivatives) && lightType === LIGHTTYPE_SPOT) usePerspZbufferShadow = true;
	      }

	      if (light._cookie) {
	        if (light._cookie._cubemap) {
	          if (lightType === LIGHTTYPE_OMNI) {
	            code += "uniform samplerCube light" + i + "_cookie;\n";
	            code += "uniform float light" + i + "_cookieIntensity;\n";
	            if (!light.castShadows || options.noShadow) code += "uniform mat4 light" + i + "_shadowMatrix;\n";
	          }
	        } else {
	          if (lightType === LIGHTTYPE_SPOT) {
	            code += "uniform sampler2D light" + i + "_cookie;\n";
	            code += "uniform float light" + i + "_cookieIntensity;\n";
	            if (!light.castShadows || options.noShadow) code += "uniform mat4 light" + i + "_shadowMatrix;\n";

	            if (light._cookieTransform) {
	              code += "uniform vec4 light" + i + "_cookieMatrix;\n";
	              code += "uniform vec2 light" + i + "_cookieOffset;\n";
	            }
	          }
	        }
	      }
	    }

	    code += "\n";
	    var hasTBN = this.needsNormal && (options.normalMap || options.clearCoatNormalMap || options.enableGGXSpecular && !options.heightMap);

	    if (hasTBN) {
	      if (options.hasTangents) {
	        code += options.fastTbn ? chunks.TBNfastPS : chunks.TBNPS;
	      } else {
	        if (device.extStandardDerivatives && (options.normalMap || options.clearCoatNormalMap)) {
	          code += chunks.TBNderivativePS.replace(/\$UV/g, this.lightingUv);
	        } else {
	          code += chunks.TBNObjectSpacePS;
	        }
	      }
	    }

	    code += chunks.sphericalPS;
	    code += chunks.decodePS;
	    code += gammaCode(options.gamma, chunks);
	    code += tonemapCode(options.toneMap, chunks);
	    code += fogCode(options.fog, chunks);
	    code += this.frontendCode;

	    if (options.useCubeMapRotation) {
	      code += "#define CUBEMAP_ROTATION\n";
	    }

	    if (this.needsNormal) {
	      code += chunks.cubeMapRotatePS;
	      code += options.cubeMapProjection > 0 ? chunks.cubeMapProjectBoxPS : chunks.cubeMapProjectNonePS;
	      code += options.skyboxIntensity ? chunks.envMultiplyPS : chunks.envConstPS;
	    }

	    if (this.lighting && options.useSpecular || this.reflections) {
	      if (options.useMetalness) {
	        code += chunks.metalnessModulatePS;
	      }

	      if (options.fresnelModel === FRESNEL_SCHLICK) {
	        code += chunks.fresnelSchlickPS;
	      }
	    }

	    var useAo = options.aoMap || options.aoVertexColor;

	    if (useAo) {
	      code += chunks.aoDiffuseOccPS;

	      switch (options.occludeSpecular) {
	        case SPECOCC_AO:
	          code += options.occludeSpecularFloat ? chunks.aoSpecOccSimplePS : chunks.aoSpecOccConstSimplePS;
	          break;

	        case SPECOCC_GLOSSDEPENDENT:
	          code += options.occludeSpecularFloat ? chunks.aoSpecOccPS : chunks.aoSpecOccConstPS;
	          break;
	      }
	    }

	    if (options.reflectionSource === 'envAtlasHQ') {
	      code += options.fixSeams ? chunks.fixCubemapSeamsStretchPS : chunks.fixCubemapSeamsNonePS;
	      code += chunks.envAtlasPS;
	      code += chunks.reflectionEnvHQPS.replace(/\$DECODE/g, ChunkUtils.decodeFunc(options.reflectionEncoding));
	    } else if (options.reflectionSource === 'envAtlas') {
	      code += chunks.envAtlasPS;
	      code += chunks.reflectionEnvPS.replace(/\$DECODE/g, ChunkUtils.decodeFunc(options.reflectionEncoding));
	    } else if (options.reflectionSource === 'cubeMap') {
	      code += options.fixSeams ? chunks.fixCubemapSeamsStretchPS : chunks.fixCubemapSeamsNonePS;
	      code += chunks.reflectionCubePS.replace(/\$DECODE/g, ChunkUtils.decodeFunc(options.reflectionEncoding));
	    } else if (options.reflectionSource === 'sphereMap') {
	      var scode = device.fragmentUniformsCount > 16 ? chunks.reflectionSpherePS : chunks.reflectionSphereLowPS;
	      code += scode.replace(/\$DECODE/g, ChunkUtils.decodeFunc(options.reflectionEncoding));
	    }

	    if (this.reflections) {
	      if (options.clearCoat) {
	        code += chunks.reflectionCCPS;
	      }

	      if (options.refraction) {
	        if (options.useDynamicRefraction) {
	          code += chunks.refractionDynamicPS;
	        } else {
	          code += chunks.refractionCubePS;
	        }
	      }

	      if (options.sheen) {
	        code += chunks.reflectionSheenPS;
	      }
	    }

	    if (options.sheen) {
	      code += chunks.lightSheenPS;
	    }

	    if (options.clusteredLightingEnabled) {
	      code += chunks.clusteredLightUtilsPS;
	      code += chunks.clusteredLightCookiesPS;
	      shadowTypeUsed[SHADOW_PCF3] = true;
	      shadowTypeUsed[SHADOW_PCF5] = true;
	      usePerspZbufferShadow = true;
	    }

	    if (numShadowLights > 0 || options.clusteredLightingEnabled) {
	      if (shadowedDirectionalLightUsed) {
	        code += chunks.shadowCascadesPS;
	      }

	      if (shadowTypeUsed[SHADOW_PCF3]) {
	        code += chunks.shadowStandardPS;
	      }

	      if (shadowTypeUsed[SHADOW_PCF5] && device.webgl2) {
	        code += chunks.shadowStandardGL2PS;
	      }

	      if (useVsm) {
	        code += chunks.shadowVSM_commonPS;

	        if (shadowTypeUsed[SHADOW_VSM8]) {
	          code += chunks.shadowVSM8PS;
	        }

	        if (shadowTypeUsed[SHADOW_VSM16]) {
	          code += device.extTextureHalfFloatLinear ? chunks.shadowEVSMPS.replace(/\$/g, "16") : chunks.shadowEVSMnPS.replace(/\$/g, "16");
	        }

	        if (shadowTypeUsed[SHADOW_VSM32]) {
	          code += device.extTextureFloatLinear ? chunks.shadowEVSMPS.replace(/\$/g, "32") : chunks.shadowEVSMnPS.replace(/\$/g, "32");
	        }
	      }

	      if (!(device.webgl2 || device.extStandardDerivatives)) {
	        code += chunks.biasConstPS;
	      }

	      code += chunks.shadowCoordPS + chunks.shadowCommonPS;
	      if (usePerspZbufferShadow) code += chunks.shadowCoordPerspZbufferPS;
	    }

	    if (options.enableGGXSpecular) code += "uniform float material_anisotropy;\n";

	    if (this.lighting) {
	      code += chunks.lightDiffuseLambertPS;
	      if (hasAreaLights || options.clusteredLightingEnabled) code += chunks.ltc;
	    }

	    code += '\n';
	    var useOldAmbient = false;

	    if (options.useSpecular) {
	      if (this.lighting) {
	        code += options.shadingModel === SPECULAR_PHONG ? chunks.lightSpecularPhongPS : options.enableGGXSpecular ? chunks.lightSpecularAnisoGGXPS : chunks.lightSpecularBlinnPS;
	      }

	      if (!options.fresnelModel && !this.reflections && !options.diffuseMap) {
	        code += "    uniform vec3 material_ambient;\n";
	        code += "#define LIT_OLD_AMBIENT";
	        useOldAmbient = true;
	      }
	    }

	    code += chunks.combinePS;

	    if (options.lightMap || options.lightVertexColor) {
	      code += options.useSpecular && options.dirLightMap ? chunks.lightmapDirAddPS : chunks.lightmapAddPS;
	    }

	    var addAmbient = !options.lightMap && !options.lightVertexColor || options.lightMapWithoutAmbient;

	    if (addAmbient) {
	      if (options.ambientSource === 'ambientSH') {
	        code += chunks.ambientSHPS;
	      } else if (options.ambientSource === 'envAtlas') {
	        if (options.reflectionSource !== 'envAtlas' && options.reflectionSource !== 'envAtlasHQ') {
	          code += chunks.envAtlasPS;
	        }

	        code += chunks.ambientEnvPS.replace(/\$DECODE/g, ChunkUtils.decodeFunc(options.ambientEncoding));
	      } else {
	        code += chunks.ambientConstantPS;
	      }
	    }

	    if (options.ambientTint && !useOldAmbient) {
	      code += "uniform vec3 material_ambient;\n";
	    }

	    if (options.msdf) {
	      if (!options.msdfTextAttribute) {
	        code += "\n#define UNIFORM_TEXT_PARAMETERS";
	      }

	      code += chunks.msdfPS;
	    }

	    if (this.needsNormal) {
	      code += chunks.viewDirPS;

	      if (options.useSpecular) {
	        code += options.enableGGXSpecular ? chunks.reflDirAnisoPS : chunks.reflDirPS;
	      }
	    }

	    var hasPointLights = false;
	    var usesLinearFalloff = false;
	    var usesInvSquaredFalloff = false;
	    var usesSpot = false;
	    var usesCookie = false;
	    var usesCookieNow;

	    if (options.clusteredLightingEnabled && this.lighting) {
	      usesSpot = true;
	      hasPointLights = true;
	      usesLinearFalloff = true;
	      usesCookie = true;
	      code += chunks.floatUnpackingPS;
	      if (options.lightMaskDynamic) code += "\n#define CLUSTER_MESH_DYNAMIC_LIGHTS";
	      if (options.clusteredLightingCookiesEnabled) code += "\n#define CLUSTER_COOKIES";

	      if (options.clusteredLightingShadowsEnabled && !options.noShadow) {
	        code += "\n#define CLUSTER_SHADOWS";
	        code += "\n#define CLUSTER_SHADOW_TYPE_" + shadowTypeToString[options.clusteredLightingShadowType];
	      }

	      if (options.clusteredLightingAreaLightsEnabled) code += "\n#define CLUSTER_AREALIGHTS";
	      code += LightsBuffer.shaderDefines;
	      code += chunks.clusteredLightShadowsPS;
	      code += chunks.clusteredLightPS;
	    }

	    if (options.twoSidedLighting) code += "uniform float twoSidedLightingNegScaleFactor;\n";
	    code += this._fsGetStartCode(code, device, chunks, options);

	    if (this.needsNormal) {
	      if (options.twoSidedLighting) {
	        code += "    dVertexNormalW = normalize(gl_FrontFacing ? vNormalW * twoSidedLightingNegScaleFactor : -vNormalW * twoSidedLightingNegScaleFactor);\n";
	      } else {
	        code += "    dVertexNormalW = normalize(vNormalW);\n";
	      }

	      if ((options.heightMap || options.normalMap) && options.hasTangents) {
	        if (options.twoSidedLighting) {
	          code += "    dTangentW = gl_FrontFacing ? vTangentW * twoSidedLightingNegScaleFactor : -vTangentW * twoSidedLightingNegScaleFactor;\n";
	          code += "    dBinormalW = gl_FrontFacing ? vBinormalW * twoSidedLightingNegScaleFactor : -vBinormalW * twoSidedLightingNegScaleFactor;\n";
	        } else {
	          code += "    dTangentW = vTangentW;\n";
	          code += "    dBinormalW = vBinormalW;\n";
	        }
	      }

	      code += "    getViewDir();\n";

	      if (hasTBN) {
	        code += "    getTBN();\n";
	      }
	    }

	    code += this.frontendFunc;

	    if (this.needsNormal) {
	      if (options.useSpecular) {
	        code += "    getReflDir();\n";
	      }

	      if (options.clearCoat) {
	        code += "    ccReflDirW = normalize(-reflect(dViewDirW, ccNormalW));\n";
	      }
	    }

	    if (this.lighting && options.useSpecular || this.reflections) {
	      if (options.useMetalness) {
	        code += "    getMetalnessModulate();\n";
	      }
	    }

	    if (addAmbient) {
	      code += "    addAmbient();\n";

	      if (options.separateAmbient) {
	        code += "\n                    vec3 dAmbientLight = dDiffuseLight;\n                    dDiffuseLight = vec3(0);\n                ";
	      }
	    }

	    if (options.ambientTint && !useOldAmbient) {
	      code += "    dDiffuseLight *= material_ambient;\n";
	    }

	    if (useAo && !options.occludeDirect) {
	      code += "    occludeDiffuse();\n";
	    }

	    if (options.lightMap || options.lightVertexColor) {
	      code += "    addLightMap();\n";
	    }

	    if (this.lighting || this.reflections) {
	      if (this.reflections) {
	        if (options.clearCoat) {
	          code += "    addReflectionCC();\n";

	          if (options.fresnelModel > 0) {
	            code += "    ccReflection.rgb *= getFresnel(dot(dViewDirW, ccNormalW), vec3(ccSpecularity));\n";
	          } else {
	            code += "    ccReflection.rgb *= ccSpecularity;\n";
	          }
	        }

	        if (options.useSpecularityFactor) {
	          code += "    ccReflection.rgb *= dSpecularityFactor;\n";
	        }

	        if (options.sheen) {
	          code += "    addReflectionSheen();\n";
	          code += "    sReflection.rgb *= sSpecularity;\n";
	        }

	        code += "    addReflection();\n";

	        if (options.fresnelModel > 0) {
	          code += "    dReflection.rgb *= getFresnel(dot(dViewDirW, dNormalW), dSpecularity);\n";
	        } else {
	          code += "    dReflection.rgb *= dSpecularity;\n";
	        }

	        if (options.useSpecularityFactor) {
	          code += "    dReflection.rgb *= dSpecularityFactor;\n";
	        }
	      }

	      if (hasAreaLights) {
	        code += "    dSpecularLight *= dSpecularity;\n";

	        if (options.useSpecular) {
	          code += "    calcLTCLightValues();\n";
	        }
	      }

	      for (var _i = 0; _i < options.lights.length; _i++) {
	        var _light = options.lights[_i];
	        var _lightType = _light._type;

	        if (options.clusteredLightingEnabled && _lightType !== LIGHTTYPE_DIRECTIONAL) {
	          continue;
	        }

	        usesCookieNow = false;

	        var _lightShape = hasAreaLights && _light._shape ? _light.shape : LIGHTSHAPE_PUNCTUAL;

	        var shapeString = hasAreaLights && _light._shape ? this._getLightSourceShapeString(_lightShape) : '';

	        if (_lightShape !== LIGHTSHAPE_PUNCTUAL) {
	          code += "    calc" + shapeString + "LightValues(light" + _i + "_position, light" + _i + "_halfWidth, light" + _i + "_halfHeight);\n";
	        }

	        if (_lightType === LIGHTTYPE_DIRECTIONAL) {
	          code += "    dLightDirNormW = light" + _i + "_direction;\n";
	          code += "    dAtten = 1.0;\n";
	        } else {
	          if (_light._cookie) {
	            if (_lightType === LIGHTTYPE_SPOT && !_light._cookie._cubemap) {
	              usesCookie = true;
	              usesCookieNow = true;
	            } else if (_lightType === LIGHTTYPE_OMNI && _light._cookie._cubemap) {
	              usesCookie = true;
	              usesCookieNow = true;
	            }
	          }

	          code += "    getLightDirPoint(light" + _i + "_position);\n";
	          hasPointLights = true;

	          if (usesCookieNow) {
	            if (_lightType === LIGHTTYPE_SPOT) {
	              code += "    dAtten3 = getCookie2D" + (_light._cookieFalloff ? "" : "Clip") + (_light._cookieTransform ? "Xform" : "") + "(light" + _i + "_cookie, light" + _i + "_shadowMatrix, light" + _i + "_cookieIntensity" + (_light._cookieTransform ? ", light" + _i + "_cookieMatrix, light" + _i + "_cookieOffset" : "") + ")." + _light._cookieChannel + ";\n";
	            } else {
	              code += "    dAtten3 = getCookieCube(light" + _i + "_cookie, light" + _i + "_shadowMatrix, light" + _i + "_cookieIntensity)." + _light._cookieChannel + ";\n";
	            }
	          }

	          if (_lightShape === LIGHTSHAPE_PUNCTUAL) {
	            if (_light._falloffMode === LIGHTFALLOFF_LINEAR) {
	              code += "    dAtten = getFalloffLinear(light" + _i + "_radius);\n";
	              usesLinearFalloff = true;
	            } else {
	              code += "    dAtten = getFalloffInvSquared(light" + _i + "_radius);\n";
	              usesInvSquaredFalloff = true;
	            }
	          } else {
	            code += "    dAtten = getFalloffWindow(light" + _i + "_radius);\n";
	            usesInvSquaredFalloff = true;
	          }

	          code += "    if (dAtten > 0.00001) {\n";

	          if (_lightType === LIGHTTYPE_SPOT) {
	            if (!(usesCookieNow && !_light._cookieFalloff)) {
	              code += "    dAtten *= getSpotEffect(light" + _i + "_direction, light" + _i + "_innerConeAngle, light" + _i + "_outerConeAngle);\n";
	              usesSpot = true;
	            }
	          }
	        }

	        if (_lightShape !== LIGHTSHAPE_PUNCTUAL) {
	          if (_lightType === LIGHTTYPE_DIRECTIONAL) {
	            code += "    dAttenD = getLightDiffuse();\n";
	          } else {
	            code += "    dAttenD = get" + shapeString + "LightDiffuse() * 16.0;\n";
	          }
	        } else {
	          code += "    dAtten *= getLightDiffuse();\n";
	        }

	        if (_light.castShadows && !options.noShadow) {
	          var shadowReadMode = null;
	          var evsmExp = void 0;

	          if (_light._shadowType === SHADOW_VSM8) {
	            shadowReadMode = "VSM8";
	            evsmExp = "0.0";
	          } else if (_light._shadowType === SHADOW_VSM16) {
	            shadowReadMode = "VSM16";
	            evsmExp = "5.54";
	          } else if (_light._shadowType === SHADOW_VSM32) {
	            shadowReadMode = "VSM32";

	            if (device.textureFloatHighPrecision) {
	              evsmExp = "15.0";
	            } else {
	              evsmExp = "5.54";
	            }
	          } else if (_light._shadowType === SHADOW_PCF5) {
	            shadowReadMode = "PCF5x5";
	          } else {
	            shadowReadMode = "PCF3x3";
	          }

	          if (shadowReadMode !== null) {
	            if (_lightType === LIGHTTYPE_OMNI) {
	              var shadowCoordArgs = "(light" + _i + "_shadowMap, light" + _i + "_shadowParams);\n";

	              if (_light._normalOffsetBias) {
	                code += "    normalOffsetPointShadow(light" + _i + "_shadowParams);\n";
	              }

	              code += "    float shadow" + _i + " = getShadowPoint" + shadowReadMode + shadowCoordArgs;
	              code += "    dAtten *= mix(1.0, shadow" + _i + ", light" + _i + "_shadowIntensity);\n";
	            } else {
	              var shadowMatArg = "light" + _i + "_shadowMatrix";
	              var shadowParamArg = "light" + _i + "_shadowParams";
	              code += this._nonPointShadowMapProjection(device, options.lights[_i], shadowMatArg, shadowParamArg, _i);
	              if (_lightType === LIGHTTYPE_SPOT) shadowReadMode = "Spot" + shadowReadMode;
	              code += "    float shadow" + _i + " = getShadow" + shadowReadMode + "(light" + _i + "_shadowMap, light" + _i + "_shadowParams" + (_light._isVsm ? ", " + evsmExp : "") + ");\n";
	              code += "    dAtten *= mix(1.0, shadow" + _i + ", light" + _i + "_shadowIntensity);\n";
	            }
	          }
	        }

	        if (_lightShape !== LIGHTSHAPE_PUNCTUAL) {
	          if (options.conserveEnergy && options.useSpecular) {
	            code += "    dDiffuseLight += mix((dAttenD * dAtten) * light" + _i + "_color" + (usesCookieNow ? " * dAtten3" : "") + ", vec3(0), dLTCSpecFres);\n";
	          } else {
	            code += "    dDiffuseLight += (dAttenD * dAtten) * light" + _i + "_color" + (usesCookieNow ? " * dAtten3" : "") + ";\n";
	          }
	        } else {
	          if (hasAreaLights && options.conserveEnergy && options.useSpecular) {
	            code += "    dDiffuseLight += mix(dAtten * light" + _i + "_color" + (usesCookieNow ? " * dAtten3" : "") + ", vec3(0), dSpecularity);\n";
	          } else {
	            code += "    dDiffuseLight += dAtten * light" + _i + "_color" + (usesCookieNow ? " * dAtten3" : "") + ";\n";
	          }
	        }

	        if (options.useSpecular) {
	          code += "    dHalfDirW = normalize(-dLightDirNormW + dViewDirW);\n";
	        }

	        if (_lightShape !== LIGHTSHAPE_PUNCTUAL) {
	          if (options.clearCoat) code += "    ccSpecularLight += ccLTCSpecFres * get" + shapeString + "LightSpecularCC() * dAtten * light" + _i + "_color" + (usesCookieNow ? " * dAtten3" : "") + ";\n";
	          if (options.useSpecular) code += "    dSpecularLight += dLTCSpecFres * get" + shapeString + "LightSpecular() * dAtten * light" + _i + "_color" + (usesCookieNow ? " * dAtten3" : "") + ";\n";
	        } else {
	          var calcFresnel = false;

	          if (_lightType === LIGHTTYPE_DIRECTIONAL && options.fresnelModel > 0) {
	            calcFresnel = true;
	          }

	          if (options.clearCoat) {
	            code += "    ccSpecularLight += getLightSpecularCC(dHalfDirW) * dAtten * light" + _i + "_color";
	            code += usesCookieNow ? " * dAtten3" : "";
	            code += calcFresnel ? " * getFresnel(dot(dViewDirW, dHalfDirW), vec3(ccSpecularity))" : " * vec3(ccSpecularity)";
	            code += ";\n";
	          }

	          if (options.sheen) {
	            code += "    dSpecularLight += getLightSpecularSheen(dHalfDirW) * dAtten * light" + _i + "_color * sSpecularity";
	            code += usesCookieNow ? " * dAtten3" : "";
	            code += ";\n";
	          }

	          if (options.useSpecular) {
	            code += "    dSpecularLight += getLightSpecular(dHalfDirW) * dAtten * light" + _i + "_color";
	            code += usesCookieNow ? " * dAtten3" : "";
	            code += calcFresnel ? " * getFresnel(dot(dViewDirW, dHalfDirW), dSpecularity)" : " * dSpecularity";
	            code += ";\n";
	          }
	        }

	        if (_lightType !== LIGHTTYPE_DIRECTIONAL) {
	          code += "    }\n";
	        }

	        code += "\n";
	      }

	      if (options.clusteredLightingEnabled && this.lighting) {
	        usesLinearFalloff = true;
	        usesInvSquaredFalloff = true;
	        hasPointLights = true;
	        code += "    addClusteredLights();\n";
	      }

	      if (hasAreaLights) {
	        if (options.clearCoat) {
	          code += "    ccSpecularity = 1.0;\n";
	        }

	        if (options.useSpecular) {
	          code += "    dSpecularity = vec3(1);\n";
	        }
	      }

	      if (this.reflections && options.refraction) {
	        code += "    addRefraction();\n";
	      }
	    }

	    code += "\n";

	    if (useAo) {
	      if (options.occludeDirect) {
	        code += "    occludeDiffuse();\n";
	      }

	      if (options.occludeSpecular === SPECOCC_AO || options.occludeSpecular === SPECOCC_GLOSSDEPENDENT) {
	        code += "    occludeSpecular();\n";
	      }
	    }

	    if (options.useSpecularityFactor) {
	      code += "    dSpecularLight *= dSpecularityFactor;\n";
	    }

	    if (options.opacityFadesSpecular === false) {
	      if (options.blendType === BLEND_NORMAL || options.blendType === BLEND_PREMULTIPLIED) {
	        code += "float specLum = dot((dSpecularLight + dReflection.rgb * dReflection.a), vec3( 0.2126, 0.7152, 0.0722 ));\n";
	        code += "#ifdef LIT_CLEARCOAT\n specLum += dot(ccSpecularLight * ccSpecularity + ccReflection.rgb * ccReflection.a * ccSpecularity, vec3( 0.2126, 0.7152, 0.0722 ));\n#endif\n";
	        code += "dAlpha = clamp(dAlpha + gammaCorrectInput(specLum), 0.0, 1.0);\n";
	      }

	      code += "dAlpha *= material_alphaFade;\n";
	    }

	    code += chunks.endPS;

	    if (options.blendType === BLEND_NORMAL || options.blendType === BLEND_ADDITIVEALPHA || options.alphaToCoverage) {
	      code += chunks.outputAlphaPS;
	    } else if (options.blendType === BLEND_PREMULTIPLIED) {
	      code += chunks.outputAlphaPremulPS;
	    } else {
	      code += chunks.outputAlphaOpaquePS;
	    }

	    if (options.msdf) {
	      code += "    gl_FragColor = applyMsdf(gl_FragColor);\n";
	    }

	    code += "\n";
	    code += end();

	    if (hasPointLights) {
	      code = chunks.lightDirPointPS + code;
	    }

	    if (usesLinearFalloff) {
	      code = chunks.falloffLinearPS + code;
	    }

	    if (usesInvSquaredFalloff) {
	      code = chunks.falloffInvSquaredPS + code;
	    }

	    if (usesSpot) {
	      code = chunks.spotPS + code;
	    }

	    if (usesCookie) {
	      code = chunks.cookiePS + code;
	    }

	    var structCode = "";
	    if (code.includes("dReflection")) structCode += "vec4 dReflection;\n";
	    if (code.includes("dTBN")) structCode += "mat3 dTBN;\n";
	    if (code.includes("dVertexNormalW")) structCode += "vec3 dVertexNormalW;\n";
	    if (code.includes("dTangentW")) structCode += "vec3 dTangentW;\n";
	    if (code.includes("dBinormalW")) structCode += "vec3 dBinormalW;\n";
	    if (code.includes("dViewDirW")) structCode += "vec3 dViewDirW;\n";
	    if (code.includes("dReflDirW")) structCode += "vec3 dReflDirW;\n";
	    if (code.includes("dHalfDirW")) structCode += "vec3 dHalfDirW;\n";
	    if (code.includes("dDiffuseLight")) structCode += "vec3 dDiffuseLight;\n";
	    if (code.includes("dSpecularLight")) structCode += "vec3 dSpecularLight;\n";
	    if (code.includes("dLightDirNormW")) structCode += "vec3 dLightDirNormW;\n";
	    if (code.includes("dLightDirW")) structCode += "vec3 dLightDirW;\n";
	    if (code.includes("dLightPosW")) structCode += "vec3 dLightPosW;\n";
	    if (code.includes("dShadowCoord")) structCode += "vec3 dShadowCoord;\n";
	    if (code.includes("dAtten")) structCode += "float dAtten;\n";
	    if (code.includes("dAttenD")) structCode += "float dAttenD;\n";
	    if (code.includes("dAtten3")) structCode += "vec3 dAtten3;\n";
	    if (code.includes("dMsdf")) structCode += "vec4 dMsdf;\n";
	    if (code.includes("ccReflection")) structCode += "vec4 ccReflection;\n";
	    if (code.includes("ccReflDirW")) structCode += "vec3 ccReflDirW;\n";
	    if (code.includes("ccSpecularLight")) structCode += "vec3 ccSpecularLight;\n";
	    if (code.includes("ccSpecularityNoFres")) structCode += "float ccSpecularityNoFres;\n";
	    if (code.includes("sSpecularLight")) structCode += "vec3 sSpecularLight;\n";
	    if (code.includes("sReflection")) structCode += "vec4 sReflection;\n";
	    var result = this._fsGetBeginCode() + this.varyings + this._fsGetBaseCode() + (options.detailModes ? chunks.detailModesPS : "") + structCode + this.frontendDecl + code;
	    return result;
	  };

	  _proto.generateFragmentShader = function generateFragmentShader(frontendDecl, frontendCode, frontendFunc, lightingUv) {
	    var options = this.options;
	    this.frontendDecl = frontendDecl;
	    this.frontendCode = frontendCode;
	    this.frontendFunc = frontendFunc;
	    this.lightingUv = lightingUv;

	    if (options.pass === SHADER_PICK) {
	      this.fshader = this._fsGetPickPassCode();
	    } else if (options.pass === SHADER_DEPTH) {
	      this.fshader = this._fsGetDepthPassCode();
	    } else if (this.shadowPass) {
	      this.fshader = this._fsGetShadowPassCode();
	    } else if (options.customFragmentShader) {
	      this.fshader = this._fsGetBeginCode() + options.customFragmentShader;
	    } else {
	      this.fshader = this._fsGetLitPassCode();
	    }
	  };

	  _proto.getDefinition = function getDefinition() {
	    var result = {
	      attributes: this.attributes,
	      vshader: this.vshader,
	      fshader: this.fshader
	    };

	    if (ShaderPass.isForward(this.options.pass)) {
	      result.tag = SHADERTAG_MATERIAL;
	    }

	    return result;
	  };

	  return LitShader;
	}();

	var ChunkBuilder = function () {
	  function ChunkBuilder() {
	    this.code = '';
	  }

	  var _proto = ChunkBuilder.prototype;

	  _proto.append = function append() {
	    var _this = this;

	    for (var _len = arguments.length, chunks = new Array(_len), _key = 0; _key < _len; _key++) {
	      chunks[_key] = arguments[_key];
	    }

	    chunks.forEach(function (chunk) {
	      if (chunk.endsWith('\n')) {
	        _this.code += chunk;
	      } else {
	        _this.code += chunk + '\n';
	      }
	    });
	  };

	  _proto.prepend = function prepend() {
	    var _this2 = this;

	    for (var _len2 = arguments.length, chunks = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	      chunks[_key2] = arguments[_key2];
	    }

	    chunks.forEach(function (chunk) {
	      if (chunk.endsWith('\n')) {
	        _this2.code = chunk + _this2.code;
	      } else {
	        _this2.code = chunk + '\n' + _this2.code;
	      }
	    });
	  };

	  return ChunkBuilder;
	}();

	var _matTex2D = [];
	var standard = {
	  optionsContext: {},
	  optionsContextMin: {},
	  generateKey: function generateKey(options) {
	    var buildPropertiesList = function buildPropertiesList(options) {
	      var props = [];

	      for (var prop in options) {
	        if (options.hasOwnProperty(prop) && prop !== "chunks" && prop !== "lights") props.push(prop);
	      }

	      return props.sort();
	    };

	    var props;

	    if (options === this.optionsContextMin) {
	      if (!this.propsMin) this.propsMin = buildPropertiesList(options);
	      props = this.propsMin;
	    } else if (options === this.optionsContext) {
	      if (!this.props) this.props = buildPropertiesList(options);
	      props = this.props;
	    } else {
	      props = buildPropertiesList(options);
	    }

	    var key = "standard";

	    for (var i = 0; i < props.length; i++) {
	      if (options[props[i]]) key += props[i] + options[props[i]];
	    }

	    if (options.chunks) {
	      var chunks = [];

	      for (var p in options.chunks) {
	        if (options.chunks.hasOwnProperty(p)) {
	          chunks.push(p + options.chunks[p]);
	        }
	      }

	      chunks.sort();
	      key += chunks;
	    }

	    if (options.lights) {
	      var isClustered = options.clusteredLightingEnabled;

	      for (var _i = 0; _i < options.lights.length; _i++) {
	        var light = options.lights[_i];

	        if (!isClustered || light._type === LIGHTTYPE_DIRECTIONAL) {
	          key += light.key;
	        }
	      }
	    }

	    return hashCode(key);
	  },
	  _getUvSourceExpression: function _getUvSourceExpression(transformPropName, uVPropName, options) {
	    var transformId = options[transformPropName];
	    var uvChannel = options[uVPropName];
	    var isMainPass = ShaderPass.isForward(options.pass);
	    var expression;

	    if (isMainPass && options.nineSlicedMode === SPRITE_RENDERMODE_SLICED) {
	      expression = "nineSlicedUv";
	    } else if (isMainPass && options.nineSlicedMode === SPRITE_RENDERMODE_TILED) {
	      expression = "nineSlicedUv";
	    } else {
	      if (transformId === 0) {
	        expression = "vUv" + uvChannel;
	      } else {
	        expression = "vUV" + uvChannel + "_" + transformId;
	      }

	      if (options.heightMap && transformPropName !== "heightMapTransform") {
	        expression += " + dUvOffset";
	      }
	    }

	    return expression;
	  },
	  _addMapDef: function _addMapDef(name, enabled) {
	    return enabled ? "#define " + name + "\n" : "#undef " + name + "\n";
	  },
	  _addMapDefs: function _addMapDefs(float, color, vertex, map) {
	    return this._addMapDef("MAPFLOAT", float) + this._addMapDef("MAPCOLOR", color) + this._addMapDef("MAPVERTEX", vertex) + this._addMapDef("MAPTEXTURE", map);
	  },
	  _addMap: function _addMap(propName, chunkName, options, chunks, encoding) {
	    if (encoding === void 0) {
	      encoding = null;
	    }

	    var mapPropName = propName + "Map";
	    var uVPropName = mapPropName + "Uv";
	    var transformPropName = mapPropName + "Transform";
	    var channelPropName = mapPropName + "Channel";
	    var vertexColorChannelPropName = propName + "VertexColorChannel";
	    var tintPropName = propName + "Tint";
	    var vertexColorPropName = propName + "VertexColor";
	    var detailModePropName = propName + "Mode";
	    var tintOption = options[tintPropName];
	    var vertexColorOption = options[vertexColorPropName];
	    var textureOption = options[mapPropName];
	    var detailModeOption = options[detailModePropName];
	    var subCode = chunks[chunkName];

	    if (textureOption) {
	      var uv = this._getUvSourceExpression(transformPropName, uVPropName, options);

	      subCode = subCode.replace(/\$UV/g, uv).replace(/\$CH/g, options[channelPropName]);

	      if (encoding) {
	        if (options[channelPropName] === 'aaa') {
	          subCode = subCode.replace(/\$DECODE/g, 'passThrough');
	        } else {
	          subCode = subCode.replace(/\$DECODE/g, ChunkUtils.decodeFunc(!options.gamma && encoding === 'srgb' ? 'linear' : encoding));
	        }

	        if (subCode.indexOf('$texture2DSAMPLE')) {
	          var decodeTable = {
	            linear: 'texture2D',
	            srgb: 'texture2DSRGB',
	            rgbm: 'texture2DRGBM',
	            rgbe: 'texture2DRGBE'
	          };
	          subCode = subCode.replace(/\$texture2DSAMPLE/g, decodeTable[encoding] || 'texture2D');
	        }
	      }
	    }

	    if (vertexColorOption) {
	      subCode = subCode.replace(/\$VC/g, options[vertexColorChannelPropName]);
	    }

	    if (detailModeOption) {
	      subCode = subCode.replace(/\$DETAILMODE/g, detailModeOption);
	    }

	    var isFloatTint = !!(tintOption & 1);
	    var isVecTint = !!(tintOption & 2);
	    subCode = this._addMapDefs(isFloatTint, isVecTint, vertexColorOption, textureOption) + subCode;
	    return subCode.replace(/\$/g, "");
	  },
	  _correctChannel: function _correctChannel(p, chan, _matTex2D) {
	    if (_matTex2D[p] > 0) {
	      if (_matTex2D[p] < chan.length) {
	        return chan.substring(0, _matTex2D[p]);
	      } else if (_matTex2D[p] > chan.length) {
	        var str = chan;
	        var chr = str.charAt(str.length - 1);
	        var addLen = _matTex2D[p] - str.length;

	        for (var i = 0; i < addLen; i++) {
	          str += chr;
	        }

	        return str;
	      }

	      return chan;
	    }
	  },
	  createShaderDefinition: function createShaderDefinition(device, options) {
	    var litShader = new LitShader(device, options);
	    var useUv = [];
	    var useUnmodifiedUv = [];
	    var mapTransforms = [];
	    var maxUvSets = 2;

	    for (var p in _matTex2D) {
	      var mname = p + "Map";

	      if (options[p + "VertexColor"]) {
	        var cname = p + "VertexColorChannel";
	        options[cname] = this._correctChannel(p, options[cname], _matTex2D);
	      }

	      if (options[mname]) {
	        var _cname = mname + "Channel";

	        var tname = mname + "Transform";
	        var uname = mname + "Uv";
	        options[uname] = Math.min(options[uname], maxUvSets - 1);
	        options[_cname] = this._correctChannel(p, options[_cname], _matTex2D);
	        var uvSet = options[uname];
	        useUv[uvSet] = true;
	        useUnmodifiedUv[uvSet] = useUnmodifiedUv[uvSet] || options[mname] && !options[tname];

	        if (options[tname]) {
	          mapTransforms.push({
	            name: p,
	            id: options[tname],
	            uv: options[uname]
	          });
	        }
	      }
	    }

	    if (options.forceUv1) {
	      useUv[1] = true;
	      useUnmodifiedUv[1] = useUnmodifiedUv[1] !== undefined ? useUnmodifiedUv[1] : true;
	    }

	    litShader.generateVertexShader(useUv, useUnmodifiedUv, mapTransforms);

	    if (options.shadingModel === SPECULAR_PHONG) {
	      options.fresnelModel = 0;
	      options.ambientSH = false;
	    } else {
	      options.fresnelModel = options.fresnelModel === 0 ? FRESNEL_SCHLICK : options.fresnelModel;
	    }

	    var decl = new ChunkBuilder();
	    var code = new ChunkBuilder();
	    var func = new ChunkBuilder();
	    var lightingUv = "";

	    if (options.nineSlicedMode === SPRITE_RENDERMODE_TILED) {
	      decl.append("const float textureBias = -1000.0;");
	    } else {
	      decl.append("uniform float textureBias;");
	    }

	    if (ShaderPass.isForward(options.pass)) {
	      if (options.heightMap) {
	        decl.append("vec2 dUvOffset;");
	        code.append(this._addMap("height", "parallaxPS", options, litShader.chunks));
	        func.append("getParallax();");
	      }

	      if (options.blendType !== BLEND_NONE || options.alphaTest || options.alphaToCoverage) {
	        decl.append("float dAlpha;");
	        code.append(this._addMap("opacity", "opacityPS", options, litShader.chunks));
	        func.append("getOpacity();");

	        if (options.alphaTest) {
	          code.append(litShader.chunks.alphaTestPS);
	          func.append("alphaTest(dAlpha);");
	        }
	      } else {
	        decl.append("float dAlpha = 1.0;");
	      }

	      if (litShader.needsNormal) {
	        if (options.normalMap || options.clearCoatNormalMap) {
	          code.append(options.packedNormal ? litShader.chunks.normalXYPS : litShader.chunks.normalXYZPS);

	          if (!options.hasTangents) {
	            var baseName = options.normalMap ? "normalMap" : "clearCoatNormalMap";
	            lightingUv = this._getUvSourceExpression(baseName + "Transform", baseName + "Uv", options);
	          }
	        }

	        decl.append("vec3 dNormalW;");
	        code.append(this._addMap("normalDetail", "normalDetailMapPS", options, litShader.chunks));
	        code.append(this._addMap("normal", "normalMapPS", options, litShader.chunks));
	        func.append("getNormal();");
	      }

	      if (litShader.needsSceneColor) {
	        decl.append("uniform sampler2D uSceneColorMap;");
	      }

	      if (litShader.needsScreenSize) {
	        decl.append("uniform vec4 uScreenSize;");
	      }

	      if (litShader.needsTransforms) {
	        decl.append("uniform mat4 matrix_viewProjection;");
	        decl.append("uniform mat4 matrix_model;");
	      }

	      decl.append("vec3 dAlbedo;");

	      if (options.diffuseDetail) {
	        code.append(this._addMap("diffuseDetail", "diffuseDetailMapPS", options, litShader.chunks));
	      }

	      code.append(this._addMap("diffuse", "diffusePS", options, litShader.chunks));
	      func.append("getAlbedo();");

	      if (options.refraction) {
	        decl.append("float dTransmission;");
	        code.append(this._addMap("refraction", "transmissionPS", options, litShader.chunks));
	        func.append("getRefraction();");
	        decl.append("float dThickness;");
	        code.append(this._addMap("thickness", "thicknessPS", options, litShader.chunks));
	        func.append("getThickness();");
	      }

	      if (litShader.lighting && options.useSpecular || litShader.reflections) {
	        decl.append("vec3 dSpecularity;");
	        decl.append("float dGlossiness;");

	        if (options.sheen) {
	          decl.append("vec3 sSpecularity;");
	          code.append(this._addMap("sheen", "sheenPS", options, litShader.chunks));
	          func.append("getSheen();");
	          decl.append("float sGlossiness;");
	          code.append(this._addMap("sheenGlossiness", "sheenGlossPS", options, litShader.chunks));
	          func.append("getSheenGlossiness();");
	        }

	        if (options.useMetalness) {
	          decl.append("float dMetalness;");
	          code.append(this._addMap("metalness", "metalnessPS", options, litShader.chunks));
	          func.append("getMetalness();");
	        }

	        if (options.useSpecularityFactor) {
	          decl.append("float dSpecularityFactor;");
	          code.append(this._addMap("specularityFactor", "specularityFactorPS", options, litShader.chunks));
	          func.append("getSpecularityFactor();");
	        }

	        if (options.useSpecularColor) {
	          code.append(this._addMap("specular", "specularPS", options, litShader.chunks, options.specularEncoding));
	        } else {
	          code.append("void getSpecularity() { dSpecularity = vec3(1); }");
	        }

	        code.append(this._addMap("gloss", "glossPS", options, litShader.chunks));
	        func.append("getGlossiness();");
	        func.append("getSpecularity();");
	      } else {
	        decl.append("vec3 dSpecularity = vec3(0.0);");
	        decl.append("float dGlossiness = 0.0;");
	      }

	      if (options.aoMap || options.aoVertexColor) {
	        decl.append("float dAo;");
	        code.append(this._addMap("ao", "aoPS", options, litShader.chunks));
	        func.append("getAO();");
	      }

	      decl.append("vec3 dEmission;");
	      code.append(this._addMap("emissive", "emissivePS", options, litShader.chunks, options.emissiveEncoding));
	      func.append("getEmission();");

	      if (options.clearCoat > 0) {
	        decl.append("float ccSpecularity;");
	        decl.append("float ccGlossiness;");
	        decl.append("vec3 ccNormalW;");
	        code.append(this._addMap("clearCoat", "clearCoatPS", options, litShader.chunks));
	        code.append(this._addMap("clearCoatGloss", "clearCoatGlossPS", options, litShader.chunks));
	        code.append(this._addMap("clearCoatNormal", "clearCoatNormalPS", options, litShader.chunks));
	        func.append("getClearCoat();");
	        func.append("getClearCoatGlossiness();");
	        func.append("getClearCoatNormal();");
	      }

	      if (options.lightMap || options.lightVertexColor) {
	        var lightmapDir = options.dirLightMap && options.useSpecular;
	        var lightmapChunkPropName = lightmapDir ? 'lightmapDirPS' : 'lightmapSinglePS';
	        decl.append("vec3 dLightmap;");

	        if (lightmapDir) {
	          decl.append("vec3 dLightmapDir;");
	        }

	        code.append(this._addMap("light", lightmapChunkPropName, options, litShader.chunks, options.lightMapEncoding));
	        func.append("getLightMap();");
	      }

	      if (code.code.indexOf('texture2DSRGB') !== -1 || code.code.indexOf('texture2DRGBM') !== -1 || code.code.indexOf('texture2DRGBE') !== -1) {
	        code.prepend(litShader.chunks.textureSamplePS);
	      }
	    } else {
	      if (options.alphaTest) {
	        decl.append("float dAlpha;");
	        code.append(this._addMap("opacity", "opacityPS", options, litShader.chunks));
	        code.append(litShader.chunks.alphaTestPS);
	        func.append("getOpacity();");
	        func.append("alphaTest(dAlpha);");
	      }
	    }

	    func.code = "\n" + func.code.split('\n').map(function (l) {
	      return "    " + l;
	    }).join('\n') + "\n\n";
	    litShader.generateFragmentShader(decl.code, code.code, func.code, lightingUv);
	    return litShader.getDefinition();
	  }
	};

	var _goldenAngle = 2.399963229728653;
	var random = {
	  circlePoint: function circlePoint(point) {
	    var r = Math.sqrt(Math.random());
	    var theta = Math.random() * 2 * Math.PI;
	    point.x = r * Math.cos(theta);
	    point.y = r * Math.sin(theta);
	  },
	  circlePointDeterministic: function circlePointDeterministic(point, index, numPoints) {
	    var theta = index * _goldenAngle;
	    var r = Math.sqrt(index) / Math.sqrt(numPoints);
	    point.x = r * Math.cos(theta);
	    point.y = r * Math.sin(theta);
	  },
	  spherePointDeterministic: function spherePointDeterministic(point, index, numPoints, start, end) {
	    if (start === void 0) {
	      start = 0;
	    }

	    if (end === void 0) {
	      end = 1;
	    }

	    start = 1 - 2 * start;
	    end = 1 - 2 * end;
	    var y = math.lerp(start, end, index / numPoints);
	    var radius = Math.sqrt(1 - y * y);
	    var theta = _goldenAngle * index;
	    point.x = Math.cos(theta) * radius;
	    point.y = y;
	    point.z = Math.sin(theta) * radius;
	  },
	  radicalInverse: function radicalInverse(i) {
	    var bits = (i << 16 | i >>> 16) >>> 0;
	    bits = ((bits & 0x55555555) << 1 | (bits & 0xAAAAAAAA) >>> 1) >>> 0;
	    bits = ((bits & 0x33333333) << 2 | (bits & 0xCCCCCCCC) >>> 2) >>> 0;
	    bits = ((bits & 0x0F0F0F0F) << 4 | (bits & 0xF0F0F0F0) >>> 4) >>> 0;
	    bits = ((bits & 0x00FF00FF) << 8 | (bits & 0xFF00FF00) >>> 8) >>> 0;
	    return bits * 2.3283064365386963e-10;
	  }
	};

	var getProjectionName = function getProjectionName(projection) {
	  switch (projection) {
	    case TEXTUREPROJECTION_CUBE:
	      return "Cubemap";

	    case TEXTUREPROJECTION_OCTAHEDRAL:
	      return "Octahedral";

	    default:
	      return "Equirect";
	  }
	};

	var packFloat32ToRGBA8 = function packFloat32ToRGBA8(value, array, offset) {
	  if (value <= 0) {
	    array[offset + 0] = 0;
	    array[offset + 1] = 0;
	    array[offset + 2] = 0;
	    array[offset + 3] = 0;
	  } else if (value >= 1.0) {
	    array[offset + 0] = 255;
	    array[offset + 1] = 0;
	    array[offset + 2] = 0;
	    array[offset + 3] = 0;
	  } else {
	    var encX = 1 * value % 1;
	    var encY = 255 * value % 1;
	    var encZ = 65025 * value % 1;
	    var encW = 16581375.0 * value % 1;
	    encX -= encY / 255;
	    encY -= encZ / 255;
	    encZ -= encW / 255;
	    array[offset + 0] = Math.min(255, Math.floor(encX * 256));
	    array[offset + 1] = Math.min(255, Math.floor(encY * 256));
	    array[offset + 2] = Math.min(255, Math.floor(encZ * 256));
	    array[offset + 3] = Math.min(255, Math.floor(encW * 256));
	  }
	};

	var packSamples = function packSamples(samples) {
	  var numSamples = samples.length;
	  var w = Math.min(numSamples, 512);
	  var h = Math.ceil(numSamples / w);
	  var data = new Uint8Array(w * h * 4);
	  var off = 0;

	  for (var i = 0; i < numSamples; ++i) {
	    packFloat32ToRGBA8(samples[i * 4 + 0] * 0.5 + 0.5, data, off + 0);
	    packFloat32ToRGBA8(samples[i * 4 + 1] * 0.5 + 0.5, data, off + 4);
	    packFloat32ToRGBA8(samples[i * 4 + 2] * 0.5 + 0.5, data, off + 8);
	    packFloat32ToRGBA8(samples[i * 4 + 3] / 8, data, off + 12);
	    off += 16;
	  }

	  return {
	    width: w,
	    height: h,
	    data: data
	  };
	};

	var hemisphereSamplePhong = function hemisphereSamplePhong(dstVec, x, y, specularPower) {
	  var phi = y * 2 * Math.PI;
	  var cosTheta = Math.pow(1 - x, 1 / (specularPower + 1));
	  var sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
	  dstVec.set(Math.cos(phi) * sinTheta, Math.sin(phi) * sinTheta, cosTheta).normalize();
	};

	var hemisphereSampleLambert = function hemisphereSampleLambert(dstVec, x, y) {
	  var phi = y * 2 * Math.PI;
	  var cosTheta = Math.sqrt(1 - x);
	  var sinTheta = Math.sqrt(x);
	  dstVec.set(Math.cos(phi) * sinTheta, Math.sin(phi) * sinTheta, cosTheta).normalize();
	};

	var hemisphereSampleGGX = function hemisphereSampleGGX(dstVec, x, y, a) {
	  var phi = y * 2 * Math.PI;
	  var cosTheta = Math.sqrt((1 - x) / (1 + (a * a - 1) * x));
	  var sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
	  dstVec.set(Math.cos(phi) * sinTheta, Math.sin(phi) * sinTheta, cosTheta).normalize();
	};

	var D_GGX = function D_GGX(NoH, linearRoughness) {
	  var a = NoH * linearRoughness;
	  var k = linearRoughness / (1.0 - NoH * NoH + a * a);
	  return k * k * (1 / Math.PI);
	};

	var generatePhongSamples = function generatePhongSamples(numSamples, specularPower) {
	  var H = new Vec3();
	  var result = [];

	  for (var i = 0; i < numSamples; ++i) {
	    hemisphereSamplePhong(H, i / numSamples, random.radicalInverse(i), specularPower);
	    result.push(H.x, H.y, H.z, 0);
	  }

	  return result;
	};

	var generateLambertSamples = function generateLambertSamples(numSamples, sourceTotalPixels) {
	  var pixelsPerSample = sourceTotalPixels / numSamples;
	  var H = new Vec3();
	  var result = [];

	  for (var i = 0; i < numSamples; ++i) {
	    hemisphereSampleLambert(H, i / numSamples, random.radicalInverse(i));
	    var pdf = H.z / Math.PI;
	    var mipLevel = 0.5 * Math.log2(pixelsPerSample / pdf);
	    result.push(H.x, H.y, H.z, mipLevel);
	  }

	  return result;
	};

	var requiredSamplesGGX = {
	  "16": {
	    "2": 26,
	    "8": 20,
	    "32": 17,
	    "128": 16,
	    "512": 16
	  },
	  "32": {
	    "2": 53,
	    "8": 40,
	    "32": 34,
	    "128": 32,
	    "512": 32
	  },
	  "128": {
	    "2": 214,
	    "8": 163,
	    "32": 139,
	    "128": 130,
	    "512": 128
	  },
	  "1024": {
	    "2": 1722,
	    "8": 1310,
	    "32": 1114,
	    "128": 1041,
	    "512": 1025
	  }
	};

	var getRequiredSamplesGGX = function getRequiredSamplesGGX(numSamples, specularPower) {
	  var table = requiredSamplesGGX[numSamples];
	  return table && table[specularPower] || numSamples;
	};

	var generateGGXSamples = function generateGGXSamples(numSamples, specularPower, sourceTotalPixels) {
	  var pixelsPerSample = sourceTotalPixels / numSamples;
	  var roughness = 1 - Math.log2(specularPower) / 11.0;
	  var a = roughness * roughness;
	  var H = new Vec3();
	  var L = new Vec3();
	  var N = new Vec3(0, 0, 1);
	  var result = [];
	  var requiredSamples = getRequiredSamplesGGX(numSamples, specularPower);

	  for (var i = 0; i < requiredSamples; ++i) {
	    hemisphereSampleGGX(H, i / requiredSamples, random.radicalInverse(i), a);
	    var NoH = H.z;
	    L.set(H.x, H.y, H.z).mulScalar(2 * NoH).sub(N);

	    if (L.z > 0) {
	      var pdf = D_GGX(Math.min(1, NoH), a) / 4 + 0.001;
	      var mipLevel = 0.5 * Math.log2(pixelsPerSample / pdf);
	      result.push(L.x, L.y, L.z, mipLevel);
	    }
	  }

	  while (result.length < numSamples * 4) {
	    result.push(0, 0, 0, 0);
	  }

	  return result;
	};

	var createSamplesTex = function createSamplesTex(device, name, samples) {
	  var packedSamples = packSamples(samples);
	  return new Texture(device, {
	    name: name,
	    width: packedSamples.width,
	    height: packedSamples.height,
	    mipmaps: false,
	    minFilter: FILTER_NEAREST,
	    magFilter: FILTER_NEAREST,
	    levels: [packedSamples.data]
	  });
	};

	var SimpleCache = function () {
	  function SimpleCache(destroyContent) {
	    if (destroyContent === void 0) {
	      destroyContent = true;
	    }

	    this.map = new Map();
	    this.destroyContent = destroyContent;
	  }

	  var _proto = SimpleCache.prototype;

	  _proto.destroy = function destroy() {
	    if (this.destroyContent) {
	      this.map.forEach(function (value, key) {
	        value.destroy();
	      });
	    }
	  };

	  _proto.get = function get(key, missFunc) {
	    if (!this.map.has(key)) {
	      var result = missFunc();
	      this.map.set(key, result);
	      return result;
	    }

	    return this.map.get(key);
	  };

	  return SimpleCache;
	}();

	var samplesCache = new SimpleCache(false);
	var deviceCache$1 = new DeviceCache();

	var getCachedTexture = function getCachedTexture(device, key, getSamplesFnc) {
	  var cache = deviceCache$1.get(device, function () {
	    return new SimpleCache();
	  });
	  return cache.get(key, function () {
	    return createSamplesTex(device, key, samplesCache.get(key, getSamplesFnc));
	  });
	};

	var generateLambertSamplesTex = function generateLambertSamplesTex(device, numSamples, sourceTotalPixels) {
	  var key = "lambert-samples-" + numSamples + "-" + sourceTotalPixels;
	  return getCachedTexture(device, key, function () {
	    return generateLambertSamples(numSamples, sourceTotalPixels);
	  });
	};

	var generatePhongSamplesTex = function generatePhongSamplesTex(device, numSamples, specularPower) {
	  var key = "phong-samples-" + numSamples + "-" + specularPower;
	  return getCachedTexture(device, key, function () {
	    return generatePhongSamples(numSamples, specularPower);
	  });
	};

	var generateGGXSamplesTex = function generateGGXSamplesTex(device, numSamples, specularPower, sourceTotalPixels) {
	  var key = "ggx-samples-" + numSamples + "-" + specularPower + "-" + sourceTotalPixels;
	  return getCachedTexture(device, key, function () {
	    return generateGGXSamples(numSamples, specularPower, sourceTotalPixels);
	  });
	};

	var vsCode = "\nattribute vec2 vertex_position;\n\nuniform vec4 uvMod;\n\nvarying vec2 vUv0;\n\nvoid main(void) {\n    gl_Position = vec4(vertex_position, 0.5, 1.0);\n    vUv0 = (vertex_position.xy * 0.5 + 0.5) * uvMod.xy + uvMod.zw;\n}\n";

	function reprojectTexture(source, target, options) {
	  var _options;

	  if (options === void 0) {
	    options = {};
	  }

	  if (source instanceof GraphicsDevice) {
	    source = arguments[1];
	    target = arguments[2];
	    options = {};

	    if (arguments[3] !== undefined) {
	      options.specularPower = arguments[3];
	    }

	    if (arguments[4] !== undefined) {
	      options.numSamples = arguments[4];
	    }
	  }

	  var funcNames = {
	    'none': 'reproject',
	    'lambert': 'prefilterSamplesUnweighted',
	    'phong': 'prefilterSamplesUnweighted',
	    'ggx': 'prefilterSamples'
	  };
	  var specularPower = options.hasOwnProperty('specularPower') ? options.specularPower : 1;
	  var face = options.hasOwnProperty('face') ? options.face : null;
	  var distribution = options.hasOwnProperty('distribution') ? options.distribution : specularPower === 1 ? 'none' : 'phong';
	  var processFunc = funcNames[distribution] || 'reproject';
	  var decodeFunc = ChunkUtils.decodeFunc(source.encoding);
	  var encodeFunc = ChunkUtils.encodeFunc(target.encoding);
	  var sourceFunc = "sample" + getProjectionName(source.projection);
	  var targetFunc = "getDirection" + getProjectionName(target.projection);
	  var numSamples = options.hasOwnProperty('numSamples') ? options.numSamples : 1024;
	  var shaderKey = processFunc + "_" + decodeFunc + "_" + encodeFunc + "_" + sourceFunc + "_" + targetFunc + "_" + numSamples;
	  var device = source.device;
	  var shader = device.programLib._cache[shaderKey];

	  if (!shader) {
	    var defines = "#define PROCESS_FUNC " + processFunc + "\n" + ("#define DECODE_FUNC " + decodeFunc + "\n") + ("#define ENCODE_FUNC " + encodeFunc + "\n") + ("#define SOURCE_FUNC " + sourceFunc + "\n") + ("#define TARGET_FUNC " + targetFunc + "\n") + ("#define NUM_SAMPLES " + numSamples + "\n") + ("#define NUM_SAMPLES_SQRT " + Math.round(Math.sqrt(numSamples)).toFixed(1) + "\n") + (device.extTextureLod ? "#define SUPPORTS_TEXLOD\n" : '');
	    var extensions = '';

	    if (!device.webgl2) {
	      extensions = '#extension GL_OES_standard_derivatives: enable\n';

	      if (device.extTextureLod) {
	        extensions += '#extension GL_EXT_shader_texture_lod: enable\n\n';
	      }
	    }

	    shader = createShaderFromCode(device, vsCode, defines + "\n" + shaderChunks.reprojectPS, shaderKey, false, extensions);
	  }

	  var constantSource = device.scope.resolve(source.cubemap ? "sourceCube" : "sourceTex");
	  constantSource.setValue(source);
	  var constantParams = device.scope.resolve("params");
	  var constantParams2 = device.scope.resolve("params2");
	  var uvModParam = device.scope.resolve("uvMod");

	  if ((_options = options) != null && _options.seamPixels) {
	    var p = options.seamPixels;
	    var w = options.rect ? options.rect.z : target.width;
	    var h = options.rect ? options.rect.w : target.height;
	    var innerWidth = w - p * 2;
	    var innerHeight = h - p * 2;
	    uvModParam.setValue([(innerWidth + p * 2) / innerWidth, (innerHeight + p * 2) / innerHeight, -p / innerWidth, -p / innerHeight]);
	  } else {
	    uvModParam.setValue([1, 1, 0, 0]);
	  }

	  var params = [0, specularPower, source.fixCubemapSeams ? 1.0 / source.width : 0.0, target.fixCubemapSeams ? 1.0 / target.width : 0.0];
	  var params2 = [target.width * target.height * (target.cubemap ? 6 : 1), source.width * source.height * (source.cubemap ? 6 : 1)];

	  if (processFunc.startsWith('prefilterSamples')) {
	    var sourceTotalPixels = source.width * source.height * (source.cubemap ? 6 : 1);
	    var samplesTex = distribution === 'ggx' ? generateGGXSamplesTex(device, numSamples, specularPower, sourceTotalPixels) : distribution === 'lambert' ? generateLambertSamplesTex(device, numSamples, sourceTotalPixels) : generatePhongSamplesTex(device, numSamples, specularPower);
	    device.scope.resolve("samplesTex").setValue(samplesTex);
	    device.scope.resolve("samplesTexInverseSize").setValue([1.0 / samplesTex.width, 1.0 / samplesTex.height]);
	  }

	  for (var f = 0; f < (target.cubemap ? 6 : 1); f++) {
	    if (face === null || f === face) {
	      var _options2;

	      var renderTarget = new RenderTarget({
	        colorBuffer: target,
	        face: f,
	        depth: false
	      });
	      params[0] = f;
	      constantParams.setValue(params);
	      constantParams2.setValue(params2);
	      drawQuadWithShader(device, renderTarget, shader, (_options2 = options) == null ? void 0 : _options2.rect);
	      renderTarget.destroy();
	    }
	  }
	}

	var fixCubemapSeams = true;
	var RGBA8_TYPE = TEXTURETYPE_RGBM;

	var calcLevels = function calcLevels(width, height) {
	  if (height === void 0) {
	    height = 0;
	  }

	  return 1 + Math.floor(Math.log2(Math.max(width, height)));
	};

	var supportsFloat16 = function supportsFloat16(device) {
	  return device.extTextureHalfFloat && device.textureHalfFloatRenderable;
	};

	var supportsFloat32 = function supportsFloat32(device) {
	  return device.extTextureFloat && device.textureFloatRenderable;
	};

	var lightingSourcePixelFormat = function lightingSourcePixelFormat(device) {
	  return supportsFloat16(device) ? PIXELFORMAT_RGBA16F : supportsFloat32(device) ? PIXELFORMAT_RGBA32F : PIXELFORMAT_R8_G8_B8_A8;
	};

	var lightingPixelFormat = function lightingPixelFormat(device) {
	  return PIXELFORMAT_R8_G8_B8_A8;
	};

	var createCubemap = function createCubemap(device, size, format, mipmaps) {
	  return new Texture(device, {
	    name: "lighting-" + size,
	    cubemap: true,
	    width: size,
	    height: size,
	    format: format,
	    type: format === PIXELFORMAT_R8_G8_B8_A8 ? RGBA8_TYPE : TEXTURETYPE_DEFAULT,
	    addressU: ADDRESS_CLAMP_TO_EDGE,
	    addressV: ADDRESS_CLAMP_TO_EDGE,
	    fixCubemapSeams: fixCubemapSeams,
	    mipmaps: !!mipmaps
	  });
	};

	var EnvLighting = function () {
	  function EnvLighting() {}

	  EnvLighting.generateSkyboxCubemap = function generateSkyboxCubemap(source, size) {
	    var device = source.device;
	    var result = createCubemap(device, size || (source.cubemap ? source.width : source.width / 4), PIXELFORMAT_R8_G8_B8_A8, false);
	    reprojectTexture(source, result, {
	      numSamples: 1024
	    });
	    return result;
	  };

	  EnvLighting.generateLightingSource = function generateLightingSource(source, options) {
	    var device = source.device;
	    var format = lightingSourcePixelFormat(device);
	    var result = (options == null ? void 0 : options.target) || new Texture(device, {
	      name: "lighting-source",
	      cubemap: true,
	      width: (options == null ? void 0 : options.size) || 128,
	      height: (options == null ? void 0 : options.size) || 128,
	      format: format,
	      type: format === PIXELFORMAT_R8_G8_B8_A8 ? RGBA8_TYPE : TEXTURETYPE_DEFAULT,
	      addressU: ADDRESS_CLAMP_TO_EDGE,
	      addressV: ADDRESS_CLAMP_TO_EDGE,
	      fixCubemapSeams: false,
	      mipmaps: true
	    });
	    reprojectTexture(source, result, {
	      numSamples: source.mipmaps ? 1 : 1024
	    });
	    return result;
	  };

	  EnvLighting.generateAtlas = function generateAtlas(source, options) {
	    var device = source.device;
	    var format = lightingPixelFormat();
	    var result = (options == null ? void 0 : options.target) || new Texture(device, {
	      name: 'envAtlas',
	      width: (options == null ? void 0 : options.size) || 512,
	      height: (options == null ? void 0 : options.size) || 512,
	      format: format,
	      type: RGBA8_TYPE ,
	      projection: TEXTUREPROJECTION_EQUIRECT,
	      addressU: ADDRESS_CLAMP_TO_EDGE,
	      addressV: ADDRESS_CLAMP_TO_EDGE,
	      mipmaps: false
	    });
	    var s = result.width / 512;
	    var rect = new Vec4(0, 0, 512 * s, 256 * s);
	    var levels = calcLevels(256) - calcLevels(4);

	    for (var i = 0; i < levels; ++i) {
	      reprojectTexture(source, result, {
	        numSamples: 1,
	        rect: rect,
	        seamPixels: s
	      });
	      rect.x += rect.w;
	      rect.y += rect.w;
	      rect.z = Math.max(1, Math.floor(rect.z * 0.5));
	      rect.w = Math.max(1, Math.floor(rect.w * 0.5));
	    }

	    rect.set(0, 256 * s, 256 * s, 128 * s);

	    for (var _i = 1; _i < 7; ++_i) {
	      reprojectTexture(source, result, {
	        numSamples: (options == null ? void 0 : options.numReflectionSamples) || 1024,
	        distribution: (options == null ? void 0 : options.distribution) || 'ggx',
	        specularPower: Math.max(1, 2048 >> _i * 2),
	        rect: rect,
	        seamPixels: s
	      });
	      rect.y += rect.w;
	      rect.z = Math.max(1, Math.floor(rect.z * 0.5));
	      rect.w = Math.max(1, Math.floor(rect.w * 0.5));
	    }

	    rect.set(128 * s, (256 + 128) * s, 64 * s, 32 * s);
	    reprojectTexture(source, result, {
	      numSamples: (options == null ? void 0 : options.numAmbientSamples) || 2048,
	      distribution: 'lambert',
	      rect: rect,
	      seamPixels: s
	    });
	    return result;
	  };

	  EnvLighting.generatePrefilteredAtlas = function generatePrefilteredAtlas(sources, options) {
	    var device = sources[0].device;
	    var format = lightingPixelFormat();
	    var result = (options == null ? void 0 : options.target) || new Texture(device, {
	      name: 'envPrefilteredAtlas',
	      width: (options == null ? void 0 : options.size) || 512,
	      height: (options == null ? void 0 : options.size) || 512,
	      format: format,
	      type: RGBA8_TYPE ,
	      projection: TEXTUREPROJECTION_EQUIRECT,
	      addressU: ADDRESS_CLAMP_TO_EDGE,
	      addressV: ADDRESS_CLAMP_TO_EDGE,
	      mipmaps: false
	    });
	    var s = result.width / 512;
	    var rect = new Vec4(0, 0, 512 * s, 256 * s);
	    var levels = calcLevels(512);

	    for (var i = 0; i < levels; ++i) {
	      reprojectTexture(sources[0], result, {
	        numSamples: 1,
	        rect: rect,
	        seamPixels: s
	      });
	      rect.x += rect.w;
	      rect.y += rect.w;
	      rect.z = Math.max(1, Math.floor(rect.z * 0.5));
	      rect.w = Math.max(1, Math.floor(rect.w * 0.5));
	    }

	    rect.set(0, 256 * s, 256 * s, 128 * s);

	    for (var _i2 = 1; _i2 < sources.length; ++_i2) {
	      reprojectTexture(sources[_i2], result, {
	        numSamples: 1,
	        rect: rect,
	        seamPixels: s
	      });
	      rect.y += rect.w;
	      rect.z = Math.max(1, Math.floor(rect.z * 0.5));
	      rect.w = Math.max(1, Math.floor(rect.w * 0.5));
	    }

	    rect.set(128 * s, (256 + 128) * s, 64 * s, 32 * s);

	    if (options != null && options.legacyAmbient) {
	      reprojectTexture(sources[5], result, {
	        numSamples: 1,
	        rect: rect,
	        seamPixels: s
	      });
	    } else {
	      reprojectTexture(sources[0], result, {
	        numSamples: (options == null ? void 0 : options.numSamples) || 2048,
	        distribution: 'lambert',
	        rect: rect,
	        seamPixels: s
	      });
	    }

	    return result;
	  };

	  return EnvLighting;
	}();

	var defaultMaterialDeviceCache = new DeviceCache();

	function getDefaultMaterial(device) {
	  var material = defaultMaterialDeviceCache.get(device);
	  return material;
	}

	function setDefaultMaterial(device, material) {
	  defaultMaterialDeviceCache.get(device, function () {
	    return material;
	  });
	}

	var ShaderProcessorOptions = function () {
	  function ShaderProcessorOptions(viewUniformFormat, viewBindGroupFormat) {
	    this.uniformFormats = [];
	    this.bindGroupFormats = [];
	    this.uniformFormats[BINDGROUP_VIEW] = viewUniformFormat;
	    this.bindGroupFormats[BINDGROUP_VIEW] = viewBindGroupFormat;
	  }

	  var _proto = ShaderProcessorOptions.prototype;

	  _proto.hasUniform = function hasUniform(name) {
	    for (var i = 0; i < this.uniformFormats.length; i++) {
	      var uniformFormat = this.uniformFormats[i];

	      if (uniformFormat.get(name)) {
	        return true;
	      }
	    }

	    return false;
	  };

	  _proto.hasTexture = function hasTexture(name) {
	    for (var i = 0; i < this.bindGroupFormats.length; i++) {
	      var groupFormat = this.bindGroupFormats[i];

	      if (groupFormat.getTexture(name)) {
	        return true;
	      }
	    }

	    return false;
	  };

	  return ShaderProcessorOptions;
	}();

	var id$4 = 0;

	var Material = function () {
	  function Material() {
	    this._shader = null;
	    this.meshInstances = [];
	    this.name = 'Untitled';
	    this.id = id$4++;
	    this.variants = {};
	    this.parameters = {};
	    this.alphaTest = 0;
	    this.alphaToCoverage = false;
	    this.blend = false;
	    this.blendSrc = BLENDMODE_ONE;
	    this.blendDst = BLENDMODE_ZERO;
	    this.blendEquation = BLENDEQUATION_ADD;
	    this.separateAlphaBlend = false;
	    this.blendSrcAlpha = BLENDMODE_ONE;
	    this.blendDstAlpha = BLENDMODE_ZERO;
	    this.blendAlphaEquation = BLENDEQUATION_ADD;
	    this.cull = CULLFACE_BACK;
	    this.depthTest = true;
	    this.depthFunc = FUNC_LESSEQUAL;
	    this.depthWrite = true;
	    this.stencilFront = null;
	    this.stencilBack = null;
	    this.depthBias = 0;
	    this.slopeDepthBias = 0;
	    this.redWrite = true;
	    this.greenWrite = true;
	    this.blueWrite = true;
	    this.alphaWrite = true;
	    this._shaderVersion = 0;
	    this._scene = null;
	    this._dirtyBlend = false;
	    this.dirty = true;
	  }

	  var _proto = Material.prototype;

	  _proto.copy = function copy(source) {
	    this.name = source.name;
	    this._shader = source._shader;
	    this.alphaTest = source.alphaTest;
	    this.alphaToCoverage = source.alphaToCoverage;
	    this.blend = source.blend;
	    this.blendSrc = source.blendSrc;
	    this.blendDst = source.blendDst;
	    this.blendEquation = source.blendEquation;
	    this.separateAlphaBlend = source.separateAlphaBlend;
	    this.blendSrcAlpha = source.blendSrcAlpha;
	    this.blendDstAlpha = source.blendDstAlpha;
	    this.blendAlphaEquation = source.blendAlphaEquation;
	    this.cull = source.cull;
	    this.depthTest = source.depthTest;
	    this.depthFunc = source.depthFunc;
	    this.depthWrite = source.depthWrite;
	    this.depthBias = source.depthBias;
	    this.slopeDepthBias = source.slopeDepthBias;
	    if (source.stencilFront) this.stencilFront = source.stencilFront.clone();

	    if (source.stencilBack) {
	      if (source.stencilFront === source.stencilBack) {
	        this.stencilBack = this.stencilFront;
	      } else {
	        this.stencilBack = source.stencilBack.clone();
	      }
	    }

	    this.redWrite = source.redWrite;
	    this.greenWrite = source.greenWrite;
	    this.blueWrite = source.blueWrite;
	    this.alphaWrite = source.alphaWrite;
	    return this;
	  };

	  _proto.clone = function clone() {
	    var clone = new this.constructor();
	    return clone.copy(this);
	  };

	  _proto._updateMeshInstanceKeys = function _updateMeshInstanceKeys() {
	    var meshInstances = this.meshInstances;

	    for (var i = 0; i < meshInstances.length; i++) {
	      meshInstances[i].updateKey();
	    }
	  };

	  _proto.updateUniforms = function updateUniforms(device, scene) {};

	  _proto.getShaderVariant = function getShaderVariant(device, scene, objDefs, staticLightList, pass, sortedLights, viewUniformFormat, viewBindGroupFormat) {
	    var key = "shader-id-" + this._shader.id;
	    var shaderDefinition = this._shader.definition;
	    var materialGenerator = {
	      generateKey: function generateKey(options) {
	        return key;
	      },
	      createShaderDefinition: function createShaderDefinition(device, options) {
	        return shaderDefinition;
	      }
	    };
	    var libraryModuleName = 'shader';
	    var library = device.getProgramLibrary();
	    library.register(libraryModuleName, materialGenerator);
	    var processingOptions = new ShaderProcessorOptions(viewUniformFormat, viewBindGroupFormat);
	    var variant = library.getProgram(libraryModuleName, {}, processingOptions);
	    library.unregister(libraryModuleName);
	    return variant;
	  };

	  _proto.update = function update() {
	    this.dirty = true;
	    if (this._shader) this._shader.failed = false;
	  };

	  _proto.clearParameters = function clearParameters() {
	    this.parameters = {};
	  };

	  _proto.getParameters = function getParameters() {
	    return this.parameters;
	  };

	  _proto.clearVariants = function clearVariants() {
	    this.variants = {};
	    var meshInstances = this.meshInstances;
	    var count = meshInstances.length;

	    for (var i = 0; i < count; i++) {
	      meshInstances[i].clearShaders();
	    }
	  };

	  _proto.getParameter = function getParameter(name) {
	    return this.parameters[name];
	  };

	  _proto.setParameter = function setParameter(name, data) {
	    if (data === undefined && typeof name === 'object') {
	      var uniformObject = name;

	      if (uniformObject.length) {
	        for (var i = 0; i < uniformObject.length; i++) {
	          this.setParameter(uniformObject[i]);
	        }

	        return;
	      }

	      name = uniformObject.name;
	      data = uniformObject.value;
	    }

	    var param = this.parameters[name];

	    if (param) {
	      param.data = data;
	    } else {
	      this.parameters[name] = {
	        scopeId: null,
	        data: data
	      };
	    }
	  };

	  _proto.deleteParameter = function deleteParameter(name) {
	    if (this.parameters[name]) {
	      delete this.parameters[name];
	    }
	  };

	  _proto.setParameters = function setParameters(device, names) {
	    var parameters = this.parameters;
	    if (names === undefined) names = parameters;

	    for (var paramName in names) {
	      var parameter = parameters[paramName];

	      if (parameter) {
	        if (!parameter.scopeId) {
	          parameter.scopeId = device.scope.resolve(paramName);
	        }

	        parameter.scopeId.setValue(parameter.data);
	      }
	    }
	  };

	  _proto.destroy = function destroy() {
	    this.variants = {};
	    this._shader = null;

	    for (var i = 0; i < this.meshInstances.length; i++) {
	      var meshInstance = this.meshInstances[i];
	      meshInstance.clearShaders();
	      meshInstance._material = null;

	      if (meshInstance.mesh) {
	        var defaultMaterial = getDefaultMaterial(meshInstance.mesh.device);

	        if (this !== defaultMaterial) {
	          meshInstance.material = defaultMaterial;
	        }
	      }
	    }

	    this.meshInstances.length = 0;
	  };

	  _proto.addMeshInstanceRef = function addMeshInstanceRef(meshInstance) {
	    this.meshInstances.push(meshInstance);
	  };

	  _proto.removeMeshInstanceRef = function removeMeshInstanceRef(meshInstance) {
	    var meshInstances = this.meshInstances;
	    var i = meshInstances.indexOf(meshInstance);

	    if (i !== -1) {
	      meshInstances.splice(i, 1);
	    }
	  };

	  _createClass(Material, [{
	    key: "shader",
	    get: function get() {
	      return this._shader;
	    },
	    set: function set(shader) {
	      this._shader = shader;
	    }
	  }, {
	    key: "transparent",
	    get: function get() {
	      return this.blend;
	    }
	  }, {
	    key: "blendType",
	    get: function get() {
	      if (!this.blend) {
	        return BLEND_NONE;
	      }

	      if (this.blendSrc === BLENDMODE_SRC_ALPHA && this.blendDst === BLENDMODE_ONE_MINUS_SRC_ALPHA && this.blendEquation === BLENDEQUATION_ADD) {
	        return BLEND_NORMAL;
	      }

	      if (this.blendSrc === BLENDMODE_ONE && this.blendDst === BLENDMODE_ONE && this.blendEquation === BLENDEQUATION_ADD) {
	        return BLEND_ADDITIVE;
	      }

	      if (this.blendSrc === BLENDMODE_SRC_ALPHA && this.blendDst === BLENDMODE_ONE && this.blendEquation === BLENDEQUATION_ADD) {
	        return BLEND_ADDITIVEALPHA;
	      }

	      if (this.blendSrc === BLENDMODE_DST_COLOR && this.blendDst === BLENDMODE_SRC_COLOR && this.blendEquation === BLENDEQUATION_ADD) {
	        return BLEND_MULTIPLICATIVE2X;
	      }

	      if (this.blendSrc === BLENDMODE_ONE_MINUS_DST_COLOR && this.blendDst === BLENDMODE_ONE && this.blendEquation === BLENDEQUATION_ADD) {
	        return BLEND_SCREEN;
	      }

	      if (this.blendSrc === BLENDMODE_ONE && this.blendDst === BLENDMODE_ONE && this.blendEquation === BLENDEQUATION_MIN) {
	        return BLEND_MIN;
	      }

	      if (this.blendSrc === BLENDMODE_ONE && this.blendDst === BLENDMODE_ONE && this.blendEquation === BLENDEQUATION_MAX) {
	        return BLEND_MAX;
	      }

	      if (this.blendSrc === BLENDMODE_DST_COLOR && this.blendDst === BLENDMODE_ZERO && this.blendEquation === BLENDEQUATION_ADD) {
	        return BLEND_MULTIPLICATIVE;
	      }

	      if (this.blendSrc === BLENDMODE_ONE && this.blendDst === BLENDMODE_ONE_MINUS_SRC_ALPHA && this.blendEquation === BLENDEQUATION_ADD) {
	        return BLEND_PREMULTIPLIED;
	      }

	      return BLEND_NORMAL;
	    },
	    set: function set(type) {
	      var blend = true;

	      switch (type) {
	        case BLEND_NONE:
	          blend = false;
	          this.blendSrc = BLENDMODE_ONE;
	          this.blendDst = BLENDMODE_ZERO;
	          this.blendEquation = BLENDEQUATION_ADD;
	          break;

	        case BLEND_NORMAL:
	          this.blendSrc = BLENDMODE_SRC_ALPHA;
	          this.blendDst = BLENDMODE_ONE_MINUS_SRC_ALPHA;
	          this.blendEquation = BLENDEQUATION_ADD;
	          break;

	        case BLEND_PREMULTIPLIED:
	          this.blendSrc = BLENDMODE_ONE;
	          this.blendDst = BLENDMODE_ONE_MINUS_SRC_ALPHA;
	          this.blendEquation = BLENDEQUATION_ADD;
	          break;

	        case BLEND_ADDITIVE:
	          this.blendSrc = BLENDMODE_ONE;
	          this.blendDst = BLENDMODE_ONE;
	          this.blendEquation = BLENDEQUATION_ADD;
	          break;

	        case BLEND_ADDITIVEALPHA:
	          this.blendSrc = BLENDMODE_SRC_ALPHA;
	          this.blendDst = BLENDMODE_ONE;
	          this.blendEquation = BLENDEQUATION_ADD;
	          break;

	        case BLEND_MULTIPLICATIVE2X:
	          this.blendSrc = BLENDMODE_DST_COLOR;
	          this.blendDst = BLENDMODE_SRC_COLOR;
	          this.blendEquation = BLENDEQUATION_ADD;
	          break;

	        case BLEND_SCREEN:
	          this.blendSrc = BLENDMODE_ONE_MINUS_DST_COLOR;
	          this.blendDst = BLENDMODE_ONE;
	          this.blendEquation = BLENDEQUATION_ADD;
	          break;

	        case BLEND_MULTIPLICATIVE:
	          this.blendSrc = BLENDMODE_DST_COLOR;
	          this.blendDst = BLENDMODE_ZERO;
	          this.blendEquation = BLENDEQUATION_ADD;
	          break;

	        case BLEND_MIN:
	          this.blendSrc = BLENDMODE_ONE;
	          this.blendDst = BLENDMODE_ONE;
	          this.blendEquation = BLENDEQUATION_MIN;
	          break;

	        case BLEND_MAX:
	          this.blendSrc = BLENDMODE_ONE;
	          this.blendDst = BLENDMODE_ONE;
	          this.blendEquation = BLENDEQUATION_MAX;
	          break;
	      }

	      if (this.blend !== blend) {
	        this.blend = blend;

	        if (this._scene) {
	          this._scene.layers._dirtyBlend = true;
	        } else {
	          this._dirtyBlend = true;
	        }
	      }

	      this._updateMeshInstanceKeys();
	    }
	  }]);

	  return Material;
	}();

	var arraysEqual = function arraysEqual(a, b) {
	  if (a.length !== b.length) {
	    return false;
	  }

	  for (var i = 0; i < a.length; ++i) {
	    if (a[i] !== b[i]) {
	      return false;
	    }
	  }

	  return true;
	};

	var notWhite = function notWhite(color) {
	  return color.r !== 1 || color.g !== 1 || color.b !== 1;
	};

	var notBlack = function notBlack(color) {
	  return color.r !== 0 || color.g !== 0 || color.b !== 0;
	};

	var StandardMaterialOptionsBuilder = function () {
	  function StandardMaterialOptionsBuilder() {
	    this._mapXForms = null;
	  }

	  var _proto = StandardMaterialOptionsBuilder.prototype;

	  _proto.updateMinRef = function updateMinRef(options, scene, stdMat, objDefs, staticLightList, pass, sortedLights) {
	    this._updateSharedOptions(options, scene, stdMat, objDefs, pass);

	    this._updateMinOptions(options, stdMat);

	    this._updateUVOptions(options, stdMat, objDefs, true);
	  };

	  _proto.updateRef = function updateRef(options, scene, stdMat, objDefs, staticLightList, pass, sortedLights) {
	    this._updateSharedOptions(options, scene, stdMat, objDefs, pass);

	    this._updateEnvOptions(options, stdMat, scene);

	    this._updateMaterialOptions(options, stdMat);

	    if (pass === SHADER_FORWARDHDR) {
	      if (options.gamma) options.gamma = GAMMA_SRGBHDR;
	      options.toneMap = TONEMAP_LINEAR;
	    }

	    options.hasTangents = objDefs && (objDefs & SHADERDEF_TANGENTS) !== 0;

	    this._updateLightOptions(options, stdMat, objDefs, sortedLights, staticLightList);

	    this._updateUVOptions(options, stdMat, objDefs, false);
	  };

	  _proto._updateSharedOptions = function _updateSharedOptions(options, scene, stdMat, objDefs, pass) {
	    options.pass = pass;
	    options.alphaTest = stdMat.alphaTest > 0;
	    options.forceFragmentPrecision = stdMat.forceFragmentPrecision || '';
	    options.chunks = stdMat.chunks || '';
	    options.blendType = stdMat.blendType;
	    options.forceUv1 = stdMat.forceUv1;
	    options.separateAmbient = false;
	    options.screenSpace = objDefs && (objDefs & SHADERDEF_SCREENSPACE) !== 0;
	    options.skin = objDefs && (objDefs & SHADERDEF_SKIN) !== 0;
	    options.useInstancing = objDefs && (objDefs & SHADERDEF_INSTANCING) !== 0;
	    options.useMorphPosition = objDefs && (objDefs & SHADERDEF_MORPH_POSITION) !== 0;
	    options.useMorphNormal = objDefs && (objDefs & SHADERDEF_MORPH_NORMAL) !== 0;
	    options.useMorphTextureBased = objDefs && (objDefs & SHADERDEF_MORPH_TEXTURE_BASED) !== 0;
	    options.nineSlicedMode = stdMat.nineSlicedMode || 0;

	    if (scene.clusteredLightingEnabled && stdMat.useLighting) {
	      options.clusteredLightingEnabled = true;
	      options.clusteredLightingCookiesEnabled = scene.lighting.cookiesEnabled;
	      options.clusteredLightingShadowsEnabled = scene.lighting.shadowsEnabled;
	      options.clusteredLightingShadowType = scene.lighting.shadowType;
	      options.clusteredLightingAreaLightsEnabled = scene.lighting.areaLightsEnabled;
	    } else {
	      options.clusteredLightingEnabled = false;
	      options.clusteredLightingCookiesEnabled = false;
	      options.clusteredLightingShadowsEnabled = false;
	      options.clusteredLightingAreaLightsEnabled = false;
	    }
	  };

	  _proto._updateUVOptions = function _updateUVOptions(options, stdMat, objDefs, minimalOptions) {
	    var hasUv0 = false;
	    var hasUv1 = false;
	    var hasVcolor = false;

	    if (objDefs) {
	      hasUv0 = (objDefs & SHADERDEF_UV0) !== 0;
	      hasUv1 = (objDefs & SHADERDEF_UV1) !== 0;
	      hasVcolor = (objDefs & SHADERDEF_VCOLOR) !== 0;
	    }

	    options.vertexColors = false;
	    this._mapXForms = [];

	    for (var p in _matTex2D) {
	      this._updateTexOptions(options, stdMat, p, hasUv0, hasUv1, hasVcolor, minimalOptions);
	    }

	    this._mapXForms = null;
	  };

	  _proto._updateMinOptions = function _updateMinOptions(options, stdMat) {
	    options.opacityTint = stdMat.opacity !== 1 && stdMat.blendType !== BLEND_NONE;
	    options.lights = [];
	  };

	  _proto._updateMaterialOptions = function _updateMaterialOptions(options, stdMat) {
	    var diffuseTint = (stdMat.diffuseTint || !stdMat.diffuseMap && !stdMat.diffuseVertexColor) && notWhite(stdMat.diffuse);
	    var useSpecular = !!(stdMat.useMetalness || stdMat.specularMap || stdMat.sphereMap || stdMat.cubeMap || notBlack(stdMat.specular) || stdMat.specularityFactor > 0 || stdMat.enableGGXSpecular || stdMat.clearCoat > 0);
	    var useSpecularColor = !stdMat.useMetalness || stdMat.useMetalnessSpecularColor;
	    var specularTint = useSpecular && (stdMat.specularTint || !stdMat.specularMap && !stdMat.specularVertexColor) && notWhite(stdMat.specular);
	    var specularityFactorTint = useSpecular && stdMat.useMetalness && (stdMat.specularityFactorTint || stdMat.specularityFactor < 1 && !stdMat.specularityFactorMap);
	    var emissiveTintColor = !stdMat.emissiveMap || notWhite(stdMat.emissive) && stdMat.emissiveTint;
	    var emissiveTintIntensity = stdMat.emissiveIntensity !== 1;
	    var isPackedNormalMap = stdMat.normalMap ? stdMat.normalMap.format === PIXELFORMAT_DXT5 || stdMat.normalMap.type === TEXTURETYPE_SWIZZLEGGGR : false;
	    options.opacityTint = stdMat.opacity !== 1 && stdMat.blendType !== BLEND_NONE ? 1 : 0;
	    options.blendMapsWithColors = true;
	    options.ambientTint = stdMat.ambientTint;
	    options.diffuseTint = diffuseTint ? 2 : 0;
	    options.specularTint = specularTint ? 2 : 0;
	    options.specularityFactorTint = specularityFactorTint ? 1 : 0;
	    options.useSpecularityFactor = specularityFactorTint || !!stdMat.specularityFactorMap;
	    options.useSpecularColor = useSpecularColor;
	    options.metalnessTint = stdMat.useMetalness && stdMat.metalness < 1 ? 1 : 0;
	    options.glossTint = 1;
	    options.emissiveTint = (emissiveTintColor ? 2 : 0) + (emissiveTintIntensity ? 1 : 0);
	    options.alphaToCoverage = stdMat.alphaToCoverage;
	    options.normalizeNormalMap = stdMat.normalizeNormalMap;
	    options.ambientSH = !!stdMat.ambientSH;
	    options.useSpecular = useSpecular;
	    options.emissiveEncoding = stdMat.emissiveMap ? stdMat.emissiveMap.encoding : null;
	    options.lightMapEncoding = stdMat.lightMap ? stdMat.lightMap.encoding : null;
	    options.conserveEnergy = stdMat.conserveEnergy;
	    options.opacityFadesSpecular = stdMat.opacityFadesSpecular;
	    options.alphaFade = stdMat.alphaFade;
	    options.occludeSpecular = stdMat.occludeSpecular;
	    options.occludeSpecularFloat = stdMat.occludeSpecularIntensity !== 1.0;
	    options.occludeDirect = stdMat.occludeDirect;
	    options.shadingModel = stdMat.shadingModel;
	    options.fresnelModel = stdMat.fresnelModel;
	    options.packedNormal = isPackedNormalMap;
	    options.fastTbn = stdMat.fastTbn;
	    options.cubeMapProjection = stdMat.cubeMapProjection;
	    options.customFragmentShader = stdMat.customFragmentShader;
	    options.refraction = !!stdMat.refraction || !!stdMat.refractionMap;
	    options.useDynamicRefraction = stdMat.useDynamicRefraction;
	    options.refractionIndexTint = stdMat.refractionIndex !== 1.0 / 1.5 ? 1 : 0;
	    options.thicknessTint = stdMat.useDynamicRefraction && stdMat.thickness !== 1.0 ? 1 : 0;
	    options.useMetalness = stdMat.useMetalness;
	    options.specularEncoding = stdMat.specularEncoding === undefined ? 'linear' : stdMat.specularEncoding;
	    options.enableGGXSpecular = stdMat.enableGGXSpecular;
	    options.msdf = !!stdMat.msdfMap;
	    options.msdfTextAttribute = !!stdMat.msdfTextAttribute;
	    options.twoSidedLighting = stdMat.twoSidedLighting;
	    options.pixelSnap = stdMat.pixelSnap;
	    options.aoMapUv = stdMat.aoUvSet;
	    options.diffuseDetail = !!stdMat.diffuseMap;
	    options.normalDetail = !!stdMat.normalMap;
	    options.diffuseDetailMode = stdMat.diffuseDetailMode;
	    options.detailModes = !!options.diffuseDetail;
	    options.clearCoat = !!stdMat.clearCoat;
	    options.clearCoatTint = stdMat.clearCoat !== 1.0 ? 1 : 0;
	    options.clearCoatGlossiness = !!stdMat.clearCoatGlossiness;
	    options.clearCoatGlossTint = stdMat.clearCoatGlossiness !== 1.0 ? 1 : 0;
	    options.sheen = stdMat.useSheen;
	    options.sheenTint = stdMat.useSheen && notWhite(stdMat.sheen) ? 2 : 0;
	    options.sheenGlossinessTint = stdMat.useSheen && stdMat.sheenGlossiness < 1 ? 1 : 0;
	  };

	  _proto._updateEnvOptions = function _updateEnvOptions(options, stdMat, scene) {
	    options.fog = stdMat.useFog ? scene.fog : 'none';
	    options.gamma = stdMat.useGammaTonemap ? scene.gammaCorrection : GAMMA_NONE;
	    options.toneMap = stdMat.useGammaTonemap ? scene.toneMapping : -1;
	    options.fixSeams = stdMat.cubeMap ? stdMat.cubeMap.fixCubemapSeams : false;
	    var isPhong = stdMat.shadingModel === SPECULAR_PHONG;
	    var usingSceneEnv = false;

	    if (stdMat.envAtlas && stdMat.cubeMap && !isPhong) {
	      options.reflectionSource = 'envAtlasHQ';
	      options.reflectionEncoding = stdMat.envAtlas.encoding;
	    } else if (stdMat.envAtlas && !isPhong) {
	      options.reflectionSource = 'envAtlas';
	      options.reflectionEncoding = stdMat.envAtlas.encoding;
	    } else if (stdMat.cubeMap) {
	      options.reflectionSource = 'cubeMap';
	      options.reflectionEncoding = stdMat.cubeMap.encoding;
	    } else if (stdMat.sphereMap) {
	      options.reflectionSource = 'sphereMap';
	      options.reflectionEncoding = stdMat.sphereMap.encoding;
	    } else if (stdMat.useSkybox && scene.envAtlas && scene.skybox && !isPhong) {
	      options.reflectionSource = 'envAtlasHQ';
	      options.reflectionEncoding = scene.envAtlas.encoding;
	      usingSceneEnv = true;
	    } else if (stdMat.useSkybox && scene.envAtlas && !isPhong) {
	      options.reflectionSource = 'envAtlas';
	      options.reflectionEncoding = scene.envAtlas.encoding;
	      usingSceneEnv = true;
	    } else if (stdMat.useSkybox && scene.skybox) {
	      options.reflectionSource = 'cubeMap';
	      options.reflectionEncoding = scene.skybox.encoding;
	      usingSceneEnv = true;
	    } else {
	      options.reflectionSource = null;
	      options.reflectionEncoding = null;
	    }

	    if (stdMat.ambientSH && !isPhong) {
	      options.ambientSource = 'ambientSH';
	      options.ambientEncoding = null;
	    } else {
	      var envAtlas = stdMat.envAtlas || (stdMat.useSkybox && scene.envAtlas ? scene.envAtlas : null);

	      if (envAtlas && !isPhong) {
	        options.ambientSource = 'envAtlas';
	        options.ambientEncoding = envAtlas.encoding;
	      } else {
	        options.ambientSource = 'constant';
	        options.ambientEncoding = null;
	      }
	    }

	    options.skyboxIntensity = usingSceneEnv && scene.skyboxIntensity !== 1;
	    options.useCubeMapRotation = usingSceneEnv && scene.skyboxRotation && !scene.skyboxRotation.equals(Quat.IDENTITY);
	  };

	  _proto._updateLightOptions = function _updateLightOptions(options, stdMat, objDefs, sortedLights, staticLightList) {
	    options.lightMap = false;
	    options.lightMapChannel = '';
	    options.lightMapUv = 0;
	    options.lightMapTransform = 0;
	    options.lightMapWithoutAmbient = false;
	    options.dirLightMap = false;

	    if (objDefs) {
	      options.noShadow = (objDefs & SHADERDEF_NOSHADOW) !== 0;

	      if ((objDefs & SHADERDEF_LM) !== 0) {
	        options.lightMapEncoding = 'rgbm';
	        options.lightMap = true;
	        options.lightMapChannel = 'rgb';
	        options.lightMapUv = 1;
	        options.lightMapTransform = 0;
	        options.lightMapWithoutAmbient = !stdMat.lightMap;

	        if ((objDefs & SHADERDEF_DIRLM) !== 0) {
	          options.dirLightMap = true;
	        }

	        if ((objDefs & SHADERDEF_LMAMBIENT) !== 0) {
	          options.lightMapWithoutAmbient = false;
	        }
	      }
	    }

	    if (stdMat.useLighting) {
	      var lightsFiltered = [];
	      var mask = objDefs ? objDefs >> 16 : MASK_AFFECT_DYNAMIC;
	      options.lightMaskDynamic = !!(mask & MASK_AFFECT_DYNAMIC);

	      if (sortedLights) {
	        this._collectLights(LIGHTTYPE_DIRECTIONAL, sortedLights[LIGHTTYPE_DIRECTIONAL], lightsFiltered, mask);

	        this._collectLights(LIGHTTYPE_OMNI, sortedLights[LIGHTTYPE_OMNI], lightsFiltered, mask, staticLightList);

	        this._collectLights(LIGHTTYPE_SPOT, sortedLights[LIGHTTYPE_SPOT], lightsFiltered, mask, staticLightList);
	      }

	      options.lights = lightsFiltered;
	    } else {
	      options.lights = [];
	    }

	    if (options.lights.length === 0) {
	      options.noShadow = true;
	    }
	  };

	  _proto._updateTexOptions = function _updateTexOptions(options, stdMat, p, hasUv0, hasUv1, hasVcolor, minimalOptions) {
	    var mname = p + 'Map';
	    var vname = p + 'VertexColor';
	    var vcname = p + 'VertexColorChannel';
	    var cname = mname + 'Channel';
	    var tname = mname + 'Transform';
	    var uname = mname + 'Uv';

	    if (p !== 'light') {
	      options[mname] = false;
	      options[cname] = '';
	      options[tname] = 0;
	      options[uname] = 0;
	    }

	    options[vname] = false;
	    options[vcname] = '';
	    var isOpacity = p === 'opacity';
	    if (isOpacity && stdMat.blendType === BLEND_NONE && stdMat.alphaTest === 0.0 && !stdMat.alphaToCoverage) return;

	    if (!minimalOptions || isOpacity) {
	      if (p !== 'height' && stdMat[vname]) {
	        if (hasVcolor) {
	          options[vname] = stdMat[vname];
	          options[vcname] = stdMat[vcname];
	          options.vertexColors = true;
	        }
	      }

	      if (stdMat[mname]) {
	        var allow = true;
	        if (stdMat[uname] === 0 && !hasUv0) allow = false;
	        if (stdMat[uname] === 1 && !hasUv1) allow = false;

	        if (allow) {
	          options[mname] = !!stdMat[mname];
	          options[tname] = this._getMapTransformID(stdMat.getUniform(tname), stdMat[uname]);
	          options[cname] = stdMat[cname];
	          options[uname] = stdMat[uname];
	        }
	      }
	    }
	  };

	  _proto._collectLights = function _collectLights(lType, lights, lightsFiltered, mask, staticLightList) {
	    for (var i = 0; i < lights.length; i++) {
	      var light = lights[i];

	      if (light.enabled) {
	        if (light.mask & mask) {
	          if (lType !== LIGHTTYPE_DIRECTIONAL) {
	            if (light.isStatic) {
	              continue;
	            }
	          }

	          lightsFiltered.push(light);
	        }
	      }
	    }

	    if (staticLightList) {
	      for (var _i = 0; _i < staticLightList.length; _i++) {
	        var _light = staticLightList[_i];

	        if (_light._type === lType) {
	          lightsFiltered.push(_light);
	        }
	      }
	    }
	  };

	  _proto._getMapTransformID = function _getMapTransformID(xform, uv) {
	    if (!xform) return 0;
	    var xforms = this._mapXForms[uv];

	    if (!xforms) {
	      xforms = [];
	      this._mapXForms[uv] = xforms;
	    }

	    for (var i = 0; i < xforms.length; i++) {
	      if (arraysEqual(xforms[i][0].value, xform[0].value) && arraysEqual(xforms[i][1].value, xform[1].value)) {
	        return i + 1;
	      }
	    }

	    return xforms.push(xform);
	  };

	  return StandardMaterialOptionsBuilder;
	}();

	var standardMaterialParameterTypes = {
	  name: 'string',
	  chunks: 'chunks',
	  mappingFormat: 'string',
	  _engine: 'boolean',
	  ambient: 'rgb',
	  ambientTint: 'boolean',
	  aoVertexColor: 'boolean',
	  aoVertexColorChannel: 'string',
	  aoMap: 'texture',
	  aoMapChannel: 'string',
	  aoMapUv: 'number',
	  aoMapTiling: 'vec2',
	  aoMapOffset: 'vec2',
	  aoMapRotation: 'number',
	  diffuse: 'rgb',
	  diffuseTint: 'boolean',
	  diffuseVertexColor: 'boolean',
	  diffuseVertexColorChannel: 'string',
	  diffuseMap: 'texture',
	  diffuseMapChannel: 'string',
	  diffuseMapUv: 'number',
	  diffuseMapTiling: 'vec2',
	  diffuseMapOffset: 'vec2',
	  diffuseMapRotation: 'number',
	  diffuseDetailMap: 'texture',
	  diffuseDetailMapChannel: 'string',
	  diffuseDetailMapUv: 'number',
	  diffuseDetailMapTiling: 'vec2',
	  diffuseDetailMapOffset: 'vec2',
	  diffuseDetailMapRotation: 'number',
	  diffuseDetailMode: 'string',
	  specular: 'rgb',
	  specularTint: 'boolean',
	  specularVertexColor: 'boolean',
	  specularVertexColorChannel: 'string',
	  specularMap: 'texture',
	  specularMapChannel: 'string',
	  specularMapUv: 'number',
	  specularMapTiling: 'vec2',
	  specularMapOffset: 'vec2',
	  specularMapRotation: 'number',
	  occludeSpecular: 'enum:occludeSpecular',
	  specularityFactor: 'number',
	  specularityFactorTint: 'boolean',
	  specularityFactorVertexColor: 'boolean',
	  specularityFactorVertexColorChannel: 'string',
	  specularityFactorMap: 'texture',
	  specularityFactorMapChannel: 'string',
	  specularityFactorMapUv: 'number',
	  specularityFactorMapTiling: 'vec2',
	  specularityFactorMapOffset: 'vec2',
	  specularityFactorMapRotation: 'number',
	  useMetalness: 'boolean',
	  metalness: 'number',
	  enableGGXSpecular: 'boolean',
	  anisotropy: 'number',
	  metalnessTint: 'boolean',
	  metalnessVertexColor: 'boolean',
	  metalnessVertexColorChannel: 'string',
	  metalnessMap: 'texture',
	  metalnessMapChannel: 'string',
	  metalnessMapUv: 'number',
	  metalnessMapTiling: 'vec2',
	  metalnessMapOffset: 'vec2',
	  metalnessMapRotation: 'number',
	  useMetalnessSpecularColor: 'boolean',
	  conserveEnergy: 'boolean',
	  shininess: 'number',
	  glossVertexColor: 'boolean',
	  glossVertexColorChannel: 'string',
	  glossMap: 'texture',
	  glossMapChannel: 'string',
	  glossMapUv: 'number',
	  glossMapTiling: 'vec2',
	  glossMapOffset: 'vec2',
	  glossMapRotation: 'number',
	  clearCoat: 'number',
	  clearCoatVertexColor: 'boolean',
	  clearCoatVertexColorChannel: 'string',
	  clearCoatMap: 'texture',
	  clearCoatMapChannel: 'string',
	  clearCoatMapUv: 'number',
	  clearCoatMapTiling: 'vec2',
	  clearCoatMapOffset: 'vec2',
	  clearCoatMapRotation: 'number',
	  clearCoatGlossiness: 'number',
	  clearCoatGlossVertexColor: 'boolean',
	  clearCoatGlossVertexColorChannel: 'string',
	  clearCoatGlossMap: 'texture',
	  clearCoatGlossMapChannel: 'string',
	  clearCoatGlossMapUv: 'number',
	  clearCoatGlossMapTiling: 'vec2',
	  clearCoatGlossMapOffset: 'vec2',
	  clearCoatGlossMapRotation: 'number',
	  clearCoatBumpiness: 'number',
	  clearCoatNormalMap: 'texture',
	  clearCoatNormalMapUv: 'number',
	  clearCoatNormalMapTiling: 'vec2',
	  clearCoatNormalMapOffset: 'vec2',
	  clearCoatNormalMapRotation: 'number',
	  useSheen: 'boolean',
	  sheen: 'rgb',
	  sheenMap: 'texture',
	  sheenMapChannel: 'string',
	  sheenMapUv: 'number',
	  sheenMapTiling: 'vec2',
	  sheenMapOffset: 'vec2',
	  sheenMapMapRotation: 'number',
	  sheenTint: 'boolean',
	  sheenVertexColor: 'boolean',
	  sheenVertexColorChannel: 'string',
	  fresnelModel: 'number',
	  emissive: 'rgb',
	  emissiveTint: 'boolean',
	  emissiveVertexColor: 'boolean',
	  emissiveVertexColorChannel: 'string',
	  emissiveMap: 'texture',
	  emissiveMapChannel: 'string',
	  emissiveMapUv: 'number',
	  emissiveMapTiling: 'vec2',
	  emissiveMapOffset: 'vec2',
	  emissiveMapMapRotation: 'number',
	  emissiveIntensity: 'number',
	  normalMap: 'texture',
	  normalMapTiling: 'vec2',
	  normalMapOffset: 'vec2',
	  normalMapRotation: 'number',
	  normalMapUv: 'number',
	  bumpiness: 'number',
	  normalDetailMap: 'texture',
	  normalDetailMapTiling: 'vec2',
	  normalDetailMapOffset: 'vec2',
	  normalDetailMapRotation: 'number',
	  normalDetailMapUv: 'number',
	  normalDetailMapBumpiness: 'number',
	  heightMap: 'texture',
	  heightMapChannel: 'string',
	  heightMapUv: 'number',
	  heightMapTiling: 'vec2',
	  heightMapOffset: 'vec2',
	  heightMapRotation: 'number',
	  heightMapFactor: 'number',
	  alphaToCoverage: 'boolean',
	  alphaTest: 'number',
	  alphaFade: 'number',
	  opacity: 'number',
	  opacityVertexColor: 'boolean',
	  opacityVertexColorChannel: 'string',
	  opacityMap: 'texture',
	  opacityMapChannel: 'string',
	  opacityMapUv: 'number',
	  opacityMapTiling: 'vec2',
	  opacityMapOffset: 'vec2',
	  opacityMapRotation: 'number',
	  opacityFadesSpecular: 'boolean',
	  reflectivity: 'number',
	  refraction: 'number',
	  refractionIndex: 'number',
	  sphereMap: 'texture',
	  cubeMap: 'cubemap',
	  cubeMapProjection: 'number',
	  cubeMapProjectionBox: 'boundingbox',
	  lightVertexColor: 'boolean',
	  lightVertexColorChannel: 'string',
	  lightMap: 'texture',
	  lightMapChannel: 'string',
	  lightMapUv: 'number',
	  lightMapTiling: 'vec2',
	  lightMapOffset: 'vec2',
	  lightMapRotation: 'number',
	  depthTest: 'boolean',
	  depthFunc: 'enum:depthFunc',
	  depthWrite: 'boolean',
	  depthBias: 'number',
	  slopeDepthBias: 'number',
	  cull: 'enum:cull',
	  blendType: 'enum:blendType',
	  shadingModel: 'enum:shadingModel',
	  useFog: 'boolean',
	  useLighting: 'boolean',
	  useSkybox: 'boolean',
	  useGammaTonemap: 'boolean',
	  envAtlas: 'texture'
	};
	var standardMaterialTextureParameters = [];

	for (var key in standardMaterialParameterTypes) {
	  var type = standardMaterialParameterTypes[key];

	  if (type === 'texture') {
	    standardMaterialTextureParameters.push(key);
	  }
	}

	var standardMaterialCubemapParameters = [];

	for (var _key in standardMaterialParameterTypes) {
	  var _type = standardMaterialParameterTypes[_key];

	  if (_type === 'cubemap') {
	    standardMaterialCubemapParameters.push(_key);
	  }
	}

	var standardMaterialRemovedParameters = {
	  specularAntialias: 'boolean'
	};

	var _props = {};
	var _uniforms = {};

	var _params = new Set();

	var StandardMaterial = function (_Material) {
	  _inheritsLoose(StandardMaterial, _Material);

	  function StandardMaterial() {
	    var _this;

	    _this = _Material.call(this) || this;
	    _this._dirtyShader = true;
	    _this._assetReferences = {};
	    _this._activeParams = new Set();
	    _this._activeLightingParams = new Set();
	    _this.shaderOptBuilder = new StandardMaterialOptionsBuilder();

	    _this.reset();

	    return _this;
	  }

	  var _proto = StandardMaterial.prototype;

	  _proto.reset = function reset() {
	    var _this2 = this;

	    Object.keys(_props).forEach(function (name) {
	      _this2["_" + name] = _props[name].value();
	    });
	    this._chunks = {};
	    this._uniformCache = {};
	  };

	  _proto.copy = function copy(source) {
	    var _this3 = this;

	    _Material.prototype.copy.call(this, source);

	    Object.keys(_props).forEach(function (k) {
	      _this3[k] = source[k];
	    });

	    for (var p in source._chunks) {
	      if (source._chunks.hasOwnProperty(p)) this._chunks[p] = source._chunks[p];
	    }

	    return this;
	  };

	  _proto._setParameter = function _setParameter(name, value) {
	    _params.add(name);

	    this.setParameter(name, value);
	  };

	  _proto._setParameters = function _setParameters(parameters) {
	    var _this4 = this;

	    parameters.forEach(function (v) {
	      _this4._setParameter(v.name, v.value);
	    });
	  };

	  _proto._processParameters = function _processParameters(paramsName) {
	    var _this5 = this;

	    var prevParams = this[paramsName];
	    prevParams.forEach(function (param) {
	      if (!_params.has(param)) {
	        delete _this5.parameters[param];
	      }
	    });
	    this[paramsName] = _params;
	    _params = prevParams;

	    _params.clear();
	  };

	  _proto._updateMap = function _updateMap(p) {
	    var mname = p + 'Map';
	    var map = this[mname];

	    if (map) {
	      this._setParameter('texture_' + mname, map);

	      var tname = mname + 'Transform';
	      var uniform = this.getUniform(tname);

	      if (uniform) {
	        this._setParameters(uniform);
	      }
	    }
	  };

	  _proto._allocUniform = function _allocUniform(name, allocFunc) {
	    var uniform = this._uniformCache[name];

	    if (!uniform) {
	      uniform = allocFunc();
	      this._uniformCache[name] = uniform;
	    }

	    return uniform;
	  };

	  _proto.getUniform = function getUniform(name, device, scene) {
	    return _uniforms[name](this, device, scene);
	  };

	  _proto.updateUniforms = function updateUniforms(device, scene) {
	    var _this6 = this;

	    var getUniform = function getUniform(name) {
	      return _this6.getUniform(name, device, scene);
	    };

	    this._setParameter('material_ambient', getUniform('ambient'));

	    if (!this.diffuseMap || this.diffuseTint) {
	      this._setParameter('material_diffuse', getUniform('diffuse'));
	    }

	    if (!this.useMetalness) {
	      if (!this.specularMap || this.specularTint) {
	        this._setParameter('material_specular', getUniform('specular'));
	      }
	    } else {
	      if (!this.metalnessMap || this.metalness < 1) {
	        this._setParameter('material_metalness', this.metalness);
	      }

	      if (!this.specularMap || this.specularTint) {
	        this._setParameter('material_specular', getUniform('specular'));
	      }

	      if (!this.specularityFactorMap || this.specularityFactorTint) {
	        this._setParameter('material_specularityFactor', this.specularityFactor);
	      }

	      if (!this.sheenMap || this.sheenTint) {
	        this._setParameter('material_sheen', getUniform('sheen'));
	      }

	      if (!this.sheenGlossinessMap || this.sheenGlossinessTint) {
	        this._setParameter('material_sheenGlossiness', this.sheenGlossiness);
	      }

	      if (this.refractionIndex > 0.0) {
	        var oneOverRefractionIndex = 1.0 / this.refractionIndex;
	        var f0 = (oneOverRefractionIndex - 1) / (oneOverRefractionIndex + 1);

	        this._setParameter('material_f0', f0 * f0);
	      } else {
	        this._setParameter('material_f0', 1.0);
	      }
	    }

	    if (this.enableGGXSpecular) {
	      this._setParameter('material_anisotropy', this.anisotropy);
	    }

	    if (this.clearCoat > 0) {
	      this._setParameter('material_clearCoat', this.clearCoat);

	      this._setParameter('material_clearCoatGlossiness', this.clearCoatGlossiness);

	      this._setParameter('material_clearCoatReflectivity', this.clearCoat);

	      this._setParameter('material_clearCoatBumpiness', this.clearCoatBumpiness);
	    }

	    this._setParameter('material_shininess', getUniform('shininess'));

	    if (!this.emissiveMap || this.emissiveTint) {
	      this._setParameter('material_emissive', getUniform('emissive'));
	    }

	    if (this.emissiveIntensity !== 1) {
	      this._setParameter('material_emissiveIntensity', this.emissiveIntensity);
	    }

	    if (this.refraction > 0) {
	      this._setParameter('material_refraction', this.refraction);

	      this._setParameter('material_refractionIndex', this.refractionIndex);
	    }

	    if (this.useDynamicRefraction) {
	      this._setParameter('material_thickness', this.thickness);

	      this._setParameter('material_attenuation', getUniform('attenuation'));

	      this._setParameter('material_invAttenuationDistance', this.attenuationDistance === 0 ? 0 : 1.0 / this.attenuationDistance);
	    }

	    this._setParameter('material_opacity', this.opacity);

	    if (this.opacityFadesSpecular === false) {
	      this._setParameter('material_alphaFade', this.alphaFade);
	    }

	    if (this.occludeSpecular) {
	      this._setParameter('material_occludeSpecularIntensity', this.occludeSpecularIntensity);
	    }

	    if (this.cubeMapProjection === CUBEPROJ_BOX) {
	      this._setParameter(getUniform('cubeMapProjectionBox'));
	    }

	    for (var p in _matTex2D) {
	      this._updateMap(p);
	    }

	    if (this.ambientSH) {
	      this._setParameter('ambientSH[0]', this.ambientSH);
	    }

	    if (this.normalMap) {
	      this._setParameter('material_bumpiness', this.bumpiness);
	    }

	    if (this.normalMap && this.normalDetailMap) {
	      this._setParameter('material_normalDetailMapBumpiness', this.normalDetailMapBumpiness);
	    }

	    if (this.heightMap) {
	      this._setParameter('material_heightMapFactor', getUniform('heightMapFactor'));
	    }

	    var isPhong = this.shadingModel === SPECULAR_PHONG;

	    if (this.envAtlas && this.cubeMap && !isPhong) {
	      this._setParameter('texture_envAtlas', this.envAtlas);

	      this._setParameter('texture_cubeMap', this.cubeMap);
	    } else if (this.envAtlas && !isPhong) {
	      this._setParameter('texture_envAtlas', this.envAtlas);
	    } else if (this.cubeMap) {
	      this._setParameter('texture_cubeMap', this.cubeMap);
	    } else if (this.sphereMap) {
	      this._setParameter('texture_sphereMap', this.sphereMap);
	    }

	    this._setParameter('material_reflectivity', this.reflectivity);

	    this._processParameters('_activeParams');

	    if (this._dirtyShader) {
	      this.clearVariants();
	    }
	  };

	  _proto.updateEnvUniforms = function updateEnvUniforms(device, scene) {
	    var isPhong = this.shadingModel === SPECULAR_PHONG;
	    var hasLocalEnvOverride = this.envAtlas && !isPhong || this.cubeMap || this.sphereMap;

	    if (!hasLocalEnvOverride && this.useSkybox) {
	      if (scene.envAtlas && scene.skybox && !isPhong) {
	        this._setParameter('texture_envAtlas', scene.envAtlas);

	        this._setParameter('texture_cubeMap', scene.skybox);
	      } else if (scene.envAtlas && !isPhong) {
	        this._setParameter('texture_envAtlas', scene.envAtlas);
	      } else if (scene.skybox) {
	        this._setParameter('texture_cubeMap', scene.skybox);
	      }

	      if (!scene.skyboxRotation.equals(Quat.IDENTITY) && scene._skyboxRotationMat3) {
	        this._setParameter('cubeMapRotationMatrix', scene._skyboxRotationMat3.data);
	      }
	    }

	    this._processParameters('_activeLightingParams');
	  };

	  _proto.getShaderVariant = function getShaderVariant(device, scene, objDefs, staticLightList, pass, sortedLights, viewUniformFormat, viewBindGroupFormat) {
	    this.updateEnvUniforms(device, scene);
	    var minimalOptions = pass === SHADER_DEPTH || pass === SHADER_PICK || ShaderPass.isShadow(pass);
	    var options = minimalOptions ? standard.optionsContextMin : standard.optionsContext;
	    if (minimalOptions) this.shaderOptBuilder.updateMinRef(options, scene, this, objDefs, staticLightList, pass, sortedLights);else this.shaderOptBuilder.updateRef(options, scene, this, objDefs, staticLightList, pass, sortedLights);

	    if (this.onUpdateShader) {
	      options = this.onUpdateShader(options);
	    }

	    var processingOptions = new ShaderProcessorOptions(viewUniformFormat, viewBindGroupFormat);
	    var library = device.getProgramLibrary();
	    library.register('standard', standard);
	    var shader = library.getProgram('standard', options, processingOptions);
	    this._dirtyShader = false;
	    return shader;
	  };

	  _proto.destroy = function destroy() {
	    for (var asset in this._assetReferences) {
	      this._assetReferences[asset]._unbind();
	    }

	    this._assetReferences = null;

	    _Material.prototype.destroy.call(this);
	  };

	  _createClass(StandardMaterial, [{
	    key: "shader",
	    get: function get() {
	      return null;
	    },
	    set: function set(shader) {}
	  }, {
	    key: "chunks",
	    get: function get() {
	      this._dirtyShader = true;
	      return this._chunks;
	    },
	    set: function set(value) {
	      this._dirtyShader = true;
	      this._chunks = value;
	    }
	  }]);

	  return StandardMaterial;
	}(Material);

	StandardMaterial.TEXTURE_PARAMETERS = standardMaterialTextureParameters;
	StandardMaterial.CUBEMAP_PARAMETERS = standardMaterialCubemapParameters;

	var defineUniform = function defineUniform(name, getUniformFunc) {
	  _uniforms[name] = getUniformFunc;
	};

	var definePropInternal = function definePropInternal(name, constructorFunc, setterFunc, getterFunc) {
	  Object.defineProperty(StandardMaterial.prototype, name, {
	    get: getterFunc || function () {
	      return this["_" + name];
	    },
	    set: setterFunc
	  });
	  _props[name] = {
	    value: constructorFunc
	  };
	};

	var defineValueProp = function defineValueProp(prop) {
	  var internalName = "_" + prop.name;

	  var dirtyShaderFunc = prop.dirtyShaderFunc || function () {
	    return true;
	  };

	  var setterFunc = function setterFunc(value) {
	    var oldValue = this[internalName];

	    if (oldValue !== value) {
	      this._dirtyShader = this._dirtyShader || dirtyShaderFunc(oldValue, value);
	      this[internalName] = value;
	    }
	  };

	  definePropInternal(prop.name, function () {
	    return prop.defaultValue;
	  }, setterFunc, prop.getterFunc);
	};

	var defineAggProp = function defineAggProp(prop) {
	  var internalName = "_" + prop.name;

	  var dirtyShaderFunc = prop.dirtyShaderFunc || function () {
	    return true;
	  };

	  var setterFunc = function setterFunc(value) {
	    var oldValue = this[internalName];

	    if (!oldValue.equals(value)) {
	      this._dirtyShader = this._dirtyShader || dirtyShaderFunc(oldValue, value);
	      this[internalName] = oldValue.copy(value);
	    }
	  };

	  definePropInternal(prop.name, function () {
	    return prop.defaultValue.clone();
	  }, setterFunc, prop.getterFunc);
	};

	var defineProp = function defineProp(prop) {
	  return prop.defaultValue && prop.defaultValue.clone ? defineAggProp(prop) : defineValueProp(prop);
	};

	function _defineTex2D(name, uv, channels, defChannel, vertexColor, detailMode) {
	  _matTex2D[name] = channels;
	  defineProp({
	    name: name + "Map",
	    defaultValue: null,
	    dirtyShaderFunc: function dirtyShaderFunc(oldValue, newValue) {
	      return !!oldValue !== !!newValue || oldValue && (oldValue.type !== newValue.type || oldValue.fixCubemapSeams !== newValue.fixCubemapSeams || oldValue.format !== newValue.format);
	    }
	  });
	  defineProp({
	    name: name + "MapTiling",
	    defaultValue: new Vec2(1, 1)
	  });
	  defineProp({
	    name: name + "MapOffset",
	    defaultValue: new Vec2(0, 0)
	  });
	  defineProp({
	    name: name + "MapRotation",
	    defaultValue: 0
	  });
	  defineProp({
	    name: name + "MapUv",
	    defaultValue: uv
	  });

	  if (channels > 0) {
	    defineProp({
	      name: name + "MapChannel",
	      defaultValue: defChannel ? defChannel : channels > 1 ? 'rgb' : 'g'
	    });
	  }

	  if (vertexColor) {
	    defineProp({
	      name: name + "VertexColor",
	      defaultValue: false
	    });

	    if (channels > 0) {
	      defineProp({
	        name: name + "VertexColorChannel",
	        defaultValue: defChannel ? defChannel : channels > 1 ? 'rgb' : 'g'
	      });
	    }
	  }

	  if (detailMode) {
	    defineProp({
	      name: name + "Mode",
	      defaultValue: DETAILMODE_MUL
	    });
	  }

	  var mapTiling = name + "MapTiling";
	  var mapOffset = name + "MapOffset";
	  var mapRotation = name + "MapRotation";
	  var mapTransform = name + "MapTransform";
	  defineUniform(mapTransform, function (material, device, scene) {
	    var tiling = material[mapTiling];
	    var offset = material[mapOffset];
	    var rotation = material[mapRotation];

	    if (tiling.x === 1 && tiling.y === 1 && offset.x === 0 && offset.y === 0 && rotation === 0) {
	      return null;
	    }

	    var uniform = material._allocUniform(mapTransform, function () {
	      return [{
	        name: "texture_" + mapTransform + "0",
	        value: new Float32Array(3)
	      }, {
	        name: "texture_" + mapTransform + "1",
	        value: new Float32Array(3)
	      }];
	    });

	    var cr = Math.cos(rotation * math.DEG_TO_RAD);
	    var sr = Math.sin(rotation * math.DEG_TO_RAD);
	    var uniform0 = uniform[0].value;
	    uniform0[0] = cr * tiling.x;
	    uniform0[1] = -sr * tiling.y;
	    uniform0[2] = offset.x;
	    var uniform1 = uniform[1].value;
	    uniform1[0] = sr * tiling.x;
	    uniform1[1] = cr * tiling.y;
	    uniform1[2] = 1.0 - tiling.y - offset.y;
	    return uniform;
	  });
	}

	function _defineColor(name, defaultValue) {
	  defineProp({
	    name: name,
	    defaultValue: defaultValue,
	    getterFunc: function getterFunc() {
	      this._dirtyShader = true;
	      return this["_" + name];
	    }
	  });
	  defineUniform(name, function (material, device, scene) {
	    var uniform = material._allocUniform(name, function () {
	      return new Float32Array(3);
	    });

	    var color = material[name];
	    var gamma = material.useGammaTonemap && scene.gammaCorrection;

	    if (gamma) {
	      uniform[0] = Math.pow(color.r, 2.2);
	      uniform[1] = Math.pow(color.g, 2.2);
	      uniform[2] = Math.pow(color.b, 2.2);
	    } else {
	      uniform[0] = color.r;
	      uniform[1] = color.g;
	      uniform[2] = color.b;
	    }

	    return uniform;
	  });
	}

	function _defineFloat(name, defaultValue, getUniformFunc) {
	  defineProp({
	    name: name,
	    defaultValue: defaultValue,
	    dirtyShaderFunc: function dirtyShaderFunc(oldValue, newValue) {
	      return (oldValue === 0 || oldValue === 1) !== (newValue === 0 || newValue === 1);
	    }
	  });
	  defineUniform(name, getUniformFunc);
	}

	function _defineObject(name, getUniformFunc) {
	  defineProp({
	    name: name,
	    defaultValue: null,
	    dirtyShaderFunc: function dirtyShaderFunc(oldValue, newValue) {
	      return !!oldValue === !!newValue;
	    }
	  });
	  defineUniform(name, getUniformFunc);
	}

	function _defineFlag(name, defaultValue) {
	  defineProp({
	    name: name,
	    defaultValue: defaultValue
	  });
	}

	function _defineMaterialProps() {
	  _defineColor('ambient', new Color(0.7, 0.7, 0.7));

	  _defineColor('diffuse', new Color(1, 1, 1));

	  _defineColor('specular', new Color(0, 0, 0));

	  _defineColor('emissive', new Color(0, 0, 0));

	  _defineColor('sheen', new Color(1, 1, 1));

	  _defineColor('attenuation', new Color(1, 1, 1));

	  _defineFloat('emissiveIntensity', 1);

	  _defineFloat('specularityFactor', 1);

	  _defineFloat('sheenGlossiness', 0);

	  _defineFloat('shininess', 25, function (material, device, scene) {
	    return material.shadingModel === SPECULAR_PHONG ? Math.pow(2, material.shininess * 0.01 * 11) : material.shininess * 0.01;
	  });

	  _defineFloat('heightMapFactor', 1, function (material, device, scene) {
	    return material.heightMapFactor * 0.025;
	  });

	  _defineFloat('opacity', 1);

	  _defineFloat('alphaFade', 1);

	  _defineFloat('alphaTest', 0);

	  _defineFloat('bumpiness', 1);

	  _defineFloat('normalDetailMapBumpiness', 1);

	  _defineFloat('reflectivity', 1);

	  _defineFloat('occludeSpecularIntensity', 1);

	  _defineFloat('refraction', 0);

	  _defineFloat('refractionIndex', 1.0 / 1.5);

	  _defineFloat('thickness', 0);

	  _defineFloat('attenuationDistance', 0);

	  _defineFloat('metalness', 1);

	  _defineFloat('anisotropy', 0);

	  _defineFloat('clearCoat', 0);

	  _defineFloat('clearCoatGlossiness', 1);

	  _defineFloat('clearCoatBumpiness', 1);

	  _defineFloat('aoUvSet', 0, null);

	  _defineObject('ambientSH');

	  _defineObject('cubeMapProjectionBox', function (material, device, scene) {
	    var uniform = material._allocUniform('cubeMapProjectionBox', function () {
	      return [{
	        name: 'envBoxMin',
	        value: new Float32Array(3)
	      }, {
	        name: 'envBoxMax',
	        value: new Float32Array(3)
	      }];
	    });

	    var bboxMin = material.cubeMapProjectionBox.getMin();
	    var minUniform = uniform[0].value;
	    minUniform[0] = bboxMin.x;
	    minUniform[1] = bboxMin.y;
	    minUniform[2] = bboxMin.z;
	    var bboxMax = material.cubeMapProjectionBox.getMax();
	    var maxUniform = uniform[1].value;
	    maxUniform[0] = bboxMax.x;
	    maxUniform[1] = bboxMax.y;
	    maxUniform[2] = bboxMax.z;
	    return uniform;
	  });

	  _defineFlag('ambientTint', false);

	  _defineFlag('diffuseTint', false);

	  _defineFlag('specularTint', false);

	  _defineFlag('specularityFactorTint', false);

	  _defineFlag('emissiveTint', false);

	  _defineFlag('fastTbn', false);

	  _defineFlag('useMetalness', false);

	  _defineFlag('useMetalnessSpecularColor', false);

	  _defineFlag('useSheen', false);

	  _defineFlag('enableGGXSpecular', false);

	  _defineFlag('occludeDirect', false);

	  _defineFlag('normalizeNormalMap', true);

	  _defineFlag('conserveEnergy', true);

	  _defineFlag('opacityFadesSpecular', true);

	  _defineFlag('occludeSpecular', SPECOCC_AO);

	  _defineFlag('shadingModel', SPECULAR_BLINN);

	  _defineFlag('fresnelModel', FRESNEL_SCHLICK);

	  _defineFlag('useDynamicRefraction', false);

	  _defineFlag('cubeMapProjection', CUBEPROJ_NONE);

	  _defineFlag('customFragmentShader', null);

	  _defineFlag('forceFragmentPrecision', null);

	  _defineFlag('useFog', true);

	  _defineFlag('useLighting', true);

	  _defineFlag('useGammaTonemap', true);

	  _defineFlag('useSkybox', true);

	  _defineFlag('forceUv1', false);

	  _defineFlag('pixelSnap', false);

	  _defineFlag('twoSidedLighting', false);

	  _defineFlag('nineSlicedMode', undefined);

	  _defineFlag('msdfTextAttribute', false);

	  _defineTex2D('diffuse', 0, 3, '', true);

	  _defineTex2D('specular', 0, 3, '', true);

	  _defineTex2D('emissive', 0, 3, '', true);

	  _defineTex2D('thickness', 0, 1, '', true);

	  _defineTex2D('specularityFactor', 0, 1, '', true);

	  _defineTex2D('normal', 0, -1, '', false);

	  _defineTex2D('metalness', 0, 1, '', true);

	  _defineTex2D('gloss', 0, 1, '', true);

	  _defineTex2D('opacity', 0, 1, 'a', true);

	  _defineTex2D('refraction', 0, 1, '', true);

	  _defineTex2D('height', 0, 1, '', false);

	  _defineTex2D('ao', 0, 1, '', true);

	  _defineTex2D('light', 1, 3, '', true);

	  _defineTex2D('msdf', 0, 3, '', false);

	  _defineTex2D('diffuseDetail', 0, 3, '', false, true);

	  _defineTex2D('normalDetail', 0, -1, '', false);

	  _defineTex2D('clearCoat', 0, 1, '', true);

	  _defineTex2D('clearCoatGloss', 0, 1, '', true);

	  _defineTex2D('clearCoatNormal', 0, -1, '', false);

	  _defineObject('cubeMap');

	  _defineObject('sphereMap');

	  _defineObject('envAtlas');

	  var getterFunc = function getterFunc() {
	    return this._prefilteredCubemaps;
	  };

	  var setterFunc = function setterFunc(value) {
	    var cubemaps = this._prefilteredCubemaps;
	    value = value || [];
	    var changed = false;
	    var complete = true;

	    for (var i = 0; i < 6; ++i) {
	      var v = value[i] || null;

	      if (cubemaps[i] !== v) {
	        cubemaps[i] = v;
	        changed = true;
	      }

	      complete = complete && !!cubemaps[i];
	    }

	    if (changed) {
	      if (complete) {
	        this.envAtlas = EnvLighting.generatePrefilteredAtlas(cubemaps, {
	          target: this.envAtlas
	        });
	      } else {
	        if (this.envAtlas) {
	          this.envAtlas.destroy();
	          this.envAtlas = null;
	        }
	      }

	      this._dirtyShader = true;
	    }
	  };

	  var empty = [null, null, null, null, null, null];
	  definePropInternal('prefilteredCubemaps', function () {
	    return empty.slice();
	  }, setterFunc, getterFunc);
	}

	_defineMaterialProps();

	var ProgramLibrary = function () {
	  function ProgramLibrary(device) {
	    this.processedCache = new Map();
	    this._device = device;
	    this._cache = {};
	    this._generators = {};
	    this._isClearingCache = false;
	    this._precached = false;
	    this._programsCollection = [];
	    this._defaultStdMatOption = {};
	    this._defaultStdMatOptionMin = {};
	    var m = new StandardMaterial();
	    m.shaderOptBuilder.updateRef(this._defaultStdMatOption, {}, m, null, [], SHADER_FORWARD, null);
	    m.shaderOptBuilder.updateMinRef(this._defaultStdMatOptionMin, {}, m, null, [], SHADER_SHADOW, null);
	  }

	  var _proto = ProgramLibrary.prototype;

	  _proto.register = function register(name, generator) {
	    if (!this.isRegistered(name)) {
	      this._generators[name] = generator;
	    }
	  };

	  _proto.unregister = function unregister(name) {
	    if (this.isRegistered(name)) {
	      delete this._generators[name];
	    }
	  };

	  _proto.isRegistered = function isRegistered(name) {
	    var generator = this._generators[name];
	    return generator !== undefined;
	  };

	  _proto.generateShader = function generateShader(generator, name, key, options) {
	    var shader = this._cache[key];

	    if (!shader) {
	      var lights;

	      if (options.lights) {
	        lights = options.lights;
	        options.lights = lights.map(function (l) {
	          var lcopy = l.clone ? l.clone() : l;
	          lcopy.key = l.key;
	          return lcopy;
	        });
	      }

	      this.storeNewProgram(name, options);
	      if (options.lights) options.lights = lights;
	      if (this._precached) ;
	      var device = this._device;
	      var shaderDefinition = generator.createShaderDefinition(device, options);
	      shaderDefinition.name = name + "-pass:" + options.pass;
	      shader = this._cache[key] = new Shader(device, shaderDefinition);
	    }

	    return shader;
	  };

	  _proto.getProgram = function getProgram(name, options, processingOptions) {
	    var generator = this._generators[name];

	    if (!generator) {
	      return null;
	    }

	    var generationKey = generator.generateKey(options);
	    var processingKey = JSON.stringify(processingOptions);
	    var totalKey = generationKey + "#" + processingKey;
	    var processedShader = this.processedCache.get(totalKey);

	    if (!processedShader) {
	      var generatedShader = this.generateShader(generator, name, generationKey, options);
	      var generatedShaderDef = generatedShader.definition;
	      var shaderDefinition = {
	        attributes: generatedShaderDef.attributes,
	        vshader: generatedShaderDef.vshader,
	        fshader: generatedShaderDef.fshader,
	        processingOptions: processingOptions
	      };
	      processedShader = new Shader(this._device, shaderDefinition);
	      this.processedCache.set(totalKey, processedShader);
	    }

	    return processedShader;
	  };

	  _proto.storeNewProgram = function storeNewProgram(name, options) {
	    var opt = {};

	    if (name === "standard") {
	      var defaultMat = this._getDefaultStdMatOptions(options.pass);

	      for (var p in options) {
	        if (options.hasOwnProperty(p) && defaultMat[p] !== options[p] || p === "pass") opt[p] = options[p];
	      }
	    } else {
	      opt = options;
	    }

	    this._programsCollection.push(JSON.stringify({
	      name: name,
	      options: opt
	    }));
	  };

	  _proto.dumpPrograms = function dumpPrograms() {
	    var text = 'let device = pc.app ? pc.app.graphicsDevice : pc.Application.getApplication().graphicsDevice;\n';
	    text += 'let shaders = [';
	    if (this._programsCollection[0]) text += '\n\t' + this._programsCollection[0];

	    for (var i = 1; i < this._programsCollection.length; ++i) {
	      text += ',\n\t' + this._programsCollection[i];
	    }

	    text += '\n];\n';
	    text += 'device.programLib.precompile(shaders);\n';
	    text += 'if (pc.version != \"' + version + '\" || pc.revision != \"' + revision + '\")\n';
	    text += '\tconsole.warn(\"precompile-shaders.js: engine version mismatch, rebuild shaders lib with current engine\");';
	    var element = document.createElement('a');
	    element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
	    element.setAttribute('download', 'precompile-shaders.js');
	    element.style.display = 'none';
	    document.body.appendChild(element);
	    element.click();
	    document.body.removeChild(element);
	  };

	  _proto.clearCache = function clearCache() {
	    var cache = this._cache;
	    this._isClearingCache = true;

	    for (var key in cache) {
	      if (cache.hasOwnProperty(key)) {
	        cache[key].destroy();
	      }
	    }

	    this._cache = {};
	    this._isClearingCache = false;
	  };

	  _proto.removeFromCache = function removeFromCache(shader) {
	    if (this._isClearingCache) return;
	    var cache = this._cache;

	    for (var key in cache) {
	      if (cache.hasOwnProperty(key)) {
	        if (cache[key] === shader) {
	          delete cache[key];
	          break;
	        }
	      }
	    }
	  };

	  _proto._getDefaultStdMatOptions = function _getDefaultStdMatOptions(pass) {
	    return pass === SHADER_DEPTH || pass === SHADER_PICK || ShaderPass.isShadow(pass) ? this._defaultStdMatOptionMin : this._defaultStdMatOption;
	  };

	  _proto.precompile = function precompile(cache) {
	    if (cache) {
	      var shaders = new Array(cache.length);

	      for (var i = 0; i < cache.length; i++) {
	        if (cache[i].name === "standard") {
	          var opt = cache[i].options;

	          var defaultMat = this._getDefaultStdMatOptions(opt.pass);

	          for (var p in defaultMat) {
	            if (defaultMat.hasOwnProperty(p) && opt[p] === undefined) opt[p] = defaultMat[p];
	          }
	        }

	        shaders[i] = this.getProgram(cache[i].name, cache[i].options);
	      }
	    }

	    this._precached = true;
	  };

	  return ProgramLibrary;
	}();

	var EVENT_RESIZE = 'resizecanvas';

	var GraphicsDevice = function (_EventHandler) {
	  _inheritsLoose(GraphicsDevice, _EventHandler);

	  function GraphicsDevice(canvas) {
	    var _this;

	    _this = _EventHandler.call(this) || this;
	    _this.canvas = void 0;
	    _this.deviceType = void 0;
	    _this.scope = void 0;
	    _this.boneLimit = void 0;
	    _this.maxAnisotropy = void 0;
	    _this.maxCubeMapSize = void 0;
	    _this.maxTextureSize = void 0;
	    _this.maxVolumeSize = void 0;
	    _this.precision = void 0;
	    _this.renderTarget = null;
	    _this.insideRenderPass = false;
	    _this.supportsInstancing = void 0;
	    _this.supportsUniformBuffers = false;
	    _this.textureFloatRenderable = void 0;
	    _this.textureHalfFloatRenderable = void 0;
	    _this.canvas = canvas;
	    _this._width = 0;
	    _this._height = 0;
	    _this._maxPixelRatio = 1;
	    _this.shaders = [];
	    _this.buffers = [];
	    _this.textures = [];
	    _this.targets = [];
	    _this._vram = {
	      tex: 0,
	      vb: 0,
	      ib: 0,
	      ub: 0
	    };
	    _this._shaderStats = {
	      vsCompiled: 0,
	      fsCompiled: 0,
	      linked: 0,
	      materialShaders: 0,
	      compileTime: 0
	    };

	    _this.initializeContextCaches();

	    _this._drawCallsPerFrame = 0;
	    _this._shaderSwitchesPerFrame = 0;
	    _this._primsPerFrame = [];

	    for (var i = PRIMITIVE_POINTS; i <= PRIMITIVE_TRIFAN; i++) {
	      _this._primsPerFrame[i] = 0;
	    }

	    _this._renderTargetCreationTime = 0;
	    _this.scope = new ScopeSpace("Device");
	    _this.textureBias = _this.scope.resolve("textureBias");

	    _this.textureBias.setValue(0.0);

	    _this.programLib = new ProgramLibrary(_assertThisInitialized(_this));
	    return _this;
	  }

	  var _proto = GraphicsDevice.prototype;

	  _proto.destroy = function destroy() {
	    this.fire('destroy');
	  };

	  _proto.postDestroy = function postDestroy() {
	    this.scope = null;
	    this.canvas = null;
	  };

	  _proto.toJSON = function toJSON(key) {
	    return undefined;
	  };

	  _proto.initializeContextCaches = function initializeContextCaches() {
	    this.indexBuffer = null;
	    this.vertexBuffers = [];
	    this.shader = null;
	    this.renderTarget = null;
	  };

	  _proto.getProgramLibrary = function getProgramLibrary() {
	    return this.programLib;
	  };

	  _proto.setProgramLibrary = function setProgramLibrary(programLib) {
	    this.programLib = programLib;
	  };

	  _proto.setRenderTarget = function setRenderTarget(renderTarget) {
	    this.renderTarget = renderTarget;
	  };

	  _proto.setIndexBuffer = function setIndexBuffer(indexBuffer) {
	    this.indexBuffer = indexBuffer;
	  };

	  _proto.setVertexBuffer = function setVertexBuffer(vertexBuffer) {
	    if (vertexBuffer) {
	      this.vertexBuffers.push(vertexBuffer);
	    }
	  };

	  _proto.getRenderTarget = function getRenderTarget() {
	    return this.renderTarget;
	  };

	  _proto.initRenderTarget = function initRenderTarget(target) {
	    if (target.initialized) return;
	    target.init();
	    this.targets.push(target);
	  };

	  _proto._isBrowserInterface = function _isBrowserInterface(texture) {
	    return typeof HTMLCanvasElement !== 'undefined' && texture instanceof HTMLCanvasElement || typeof HTMLImageElement !== 'undefined' && texture instanceof HTMLImageElement || typeof HTMLVideoElement !== 'undefined' && texture instanceof HTMLVideoElement || typeof ImageBitmap !== 'undefined' && texture instanceof ImageBitmap;
	  };

	  _proto.resizeCanvas = function resizeCanvas(width, height) {
	    this._width = width;
	    this._height = height;
	    var ratio = Math.min(this._maxPixelRatio, platform.browser ? window.devicePixelRatio : 1);
	    width = Math.floor(width * ratio);
	    height = Math.floor(height * ratio);

	    if (this.canvas.width !== width || this.canvas.height !== height) {
	      this.canvas.width = width;
	      this.canvas.height = height;
	      this.fire(EVENT_RESIZE, width, height);
	    }
	  };

	  _proto.setResolution = function setResolution(width, height) {
	    this._width = width;
	    this._height = height;
	    this.canvas.width = width;
	    this.canvas.height = height;
	    this.fire(EVENT_RESIZE, width, height);
	  };

	  _proto.updateClientRect = function updateClientRect() {
	    this.clientRect = this.canvas.getBoundingClientRect();
	  };

	  _proto.getBoneLimit = function getBoneLimit() {
	    return this.boneLimit;
	  };

	  _proto.setBoneLimit = function setBoneLimit(maxBones) {
	    this.boneLimit = maxBones;
	  };

	  _createClass(GraphicsDevice, [{
	    key: "width",
	    get: function get() {
	      return this.canvas.width;
	    }
	  }, {
	    key: "height",
	    get: function get() {
	      return this.canvas.height;
	    }
	  }, {
	    key: "fullscreen",
	    get: function get() {
	      return false;
	    },
	    set: function set(fullscreen) {}
	  }, {
	    key: "maxPixelRatio",
	    get: function get() {
	      return this._maxPixelRatio;
	    },
	    set: function set(ratio) {
	      this._maxPixelRatio = ratio;
	      this.resizeCanvas(this._width, this._height);
	    }
	  }]);

	  return GraphicsDevice;
	}(EventHandler);

	var defaultOptions = {
	  depth: true,
	  face: 0
	};
	var id$3 = 0;

	var RenderTarget = function () {
	  function RenderTarget(options) {
	    var _this$_colorBuffer, _this$_depthBuffer;

	    this.id = id$3++;
	    var _arg2 = arguments[1];
	    var _arg3 = arguments[2];

	    if (options instanceof GraphicsDevice) {
	      this._colorBuffer = _arg2;
	      options = _arg3;
	    } else {
	      this._colorBuffer = options.colorBuffer;
	    }

	    if (this._colorBuffer) {
	      this._colorBuffer._isRenderTarget = true;
	    }

	    options = options !== undefined ? options : defaultOptions;
	    this._depthBuffer = options.depthBuffer;
	    this._face = options.face !== undefined ? options.face : 0;

	    if (this._depthBuffer) {
	      var format = this._depthBuffer._format;

	      if (format === PIXELFORMAT_DEPTH) {
	        this._depth = true;
	        this._stencil = false;
	      } else if (format === PIXELFORMAT_DEPTHSTENCIL) {
	        this._depth = true;
	        this._stencil = true;
	      } else {
	        this._depth = false;
	        this._stencil = false;
	      }
	    } else {
	      this._depth = options.depth !== undefined ? options.depth : true;
	      this._stencil = options.stencil !== undefined ? options.stencil : false;
	    }

	    var device = ((_this$_colorBuffer = this._colorBuffer) == null ? void 0 : _this$_colorBuffer.device) || ((_this$_depthBuffer = this._depthBuffer) == null ? void 0 : _this$_depthBuffer.device) || options.graphicsDevice;
	    this._device = device;
	    this._samples = options.samples !== undefined ? Math.min(options.samples, this._device.maxSamples) : 1;
	    this.autoResolve = options.autoResolve !== undefined ? options.autoResolve : true;
	    this.name = options.name;

	    if (!this.name) {
	      var _this$_colorBuffer2;

	      this.name = (_this$_colorBuffer2 = this._colorBuffer) == null ? void 0 : _this$_colorBuffer2.name;
	    }

	    if (!this.name) {
	      var _this$_depthBuffer2;

	      this.name = (_this$_depthBuffer2 = this._depthBuffer) == null ? void 0 : _this$_depthBuffer2.name;
	    }

	    if (!this.name) {
	      this.name = "Untitled";
	    }

	    this.flipY = !!options.flipY;
	    this.impl = device.createRenderTargetImpl(this);
	  }

	  var _proto = RenderTarget.prototype;

	  _proto.destroy = function destroy() {
	    var device = this._device;

	    if (device) {
	      var idx = device.targets.indexOf(this);

	      if (idx !== -1) {
	        device.targets.splice(idx, 1);
	      }

	      this.destroyFrameBuffers();
	    }
	  };

	  _proto.destroyFrameBuffers = function destroyFrameBuffers() {
	    var device = this._device;

	    if (device) {
	      this.impl.destroy(device);
	    }
	  };

	  _proto.destroyTextureBuffers = function destroyTextureBuffers() {
	    if (this._depthBuffer) {
	      this._depthBuffer.destroy();

	      this._depthBuffer = null;
	    }

	    if (this._colorBuffer) {
	      this._colorBuffer.destroy();

	      this._colorBuffer = null;
	    }
	  };

	  _proto.init = function init() {
	    this.impl.init(this._device, this);
	  };

	  _proto.loseContext = function loseContext() {
	    this.impl.loseContext();
	  };

	  _proto.resolve = function resolve(color, depth) {
	    if (color === void 0) {
	      color = true;
	    }

	    if (depth === void 0) {
	      depth = !!this._depthBuffer;
	    }

	    if (this._device && this._samples > 1) {
	      this.impl.resolve(this._device, this, color, depth);
	    }
	  };

	  _proto.copy = function copy(source, color, depth) {
	    if (!this._device) {
	      if (source._device) {
	        this._device = source._device;
	      } else {
	        return false;
	      }
	    }

	    var success = this._device.copyRenderTarget(source, this, color, depth);

	    return success;
	  };

	  _createClass(RenderTarget, [{
	    key: "initialized",
	    get: function get() {
	      return this.impl.initialized;
	    }
	  }, {
	    key: "samples",
	    get: function get() {
	      return this._samples;
	    }
	  }, {
	    key: "depth",
	    get: function get() {
	      return this._depth;
	    }
	  }, {
	    key: "stencil",
	    get: function get() {
	      return this._stencil;
	    }
	  }, {
	    key: "colorBuffer",
	    get: function get() {
	      return this._colorBuffer;
	    }
	  }, {
	    key: "depthBuffer",
	    get: function get() {
	      return this._depthBuffer;
	    }
	  }, {
	    key: "face",
	    get: function get() {
	      return this._face;
	    }
	  }, {
	    key: "width",
	    get: function get() {
	      var _this$_colorBuffer3, _this$_depthBuffer3;

	      return ((_this$_colorBuffer3 = this._colorBuffer) == null ? void 0 : _this$_colorBuffer3.width) || ((_this$_depthBuffer3 = this._depthBuffer) == null ? void 0 : _this$_depthBuffer3.width) || this._device.width;
	    }
	  }, {
	    key: "height",
	    get: function get() {
	      var _this$_colorBuffer4, _this$_depthBuffer4;

	      return ((_this$_colorBuffer4 = this._colorBuffer) == null ? void 0 : _this$_colorBuffer4.height) || ((_this$_depthBuffer4 = this._depthBuffer) == null ? void 0 : _this$_depthBuffer4.height) || this._device.height;
	    }
	  }]);

	  return RenderTarget;
	}();

	function areaElement(x, y) {
	  return Math.atan2(x * y, Math.sqrt(x * x + y * y + 1));
	}

	function texelCoordSolidAngle(u, v, size) {
	  var _u = 2.0 * (u + 0.5) / size - 1.0;

	  var _v = 2.0 * (v + 0.5) / size - 1.0;

	  _u *= 1.0 - 1.0 / size;
	  _v *= 1.0 - 1.0 / size;
	  var invResolution = 1.0 / size;
	  var x0 = _u - invResolution;
	  var y0 = _v - invResolution;
	  var x1 = _u + invResolution;
	  var y1 = _v + invResolution;
	  var solidAngle = areaElement(x0, y0) - areaElement(x0, y1) - areaElement(x1, y0) + areaElement(x1, y1);

	  if (u === 0 && v === 0 || u === size - 1 && v === 0 || u === 0 && v === size - 1 || u === size - 1 && v === size - 1) {
	    solidAngle /= 3;
	  } else if (u === 0 || v === 0 || u === size - 1 || v === size - 1) {
	    solidAngle *= 0.5;
	  }

	  return solidAngle;
	}

	function shFromCubemap(device, source, dontFlipX) {
	  if (source.format !== PIXELFORMAT_R8_G8_B8_A8) {
	    return null;
	  }

	  if (!source._levels[0] || !source._levels[0][0]) {
	    return null;
	  }

	  var cubeSize = source.width;

	  if (!source._levels[0][0].length) {
	    if (source._levels[0][0] instanceof HTMLImageElement) {
	      var shader = createShaderFromCode(device, shaderChunks.fullscreenQuadVS, shaderChunks.fullscreenQuadPS, "fsQuadSimple");
	      var constantTexSource = device.scope.resolve("source");

	      for (var face = 0; face < 6; face++) {
	        var img = source._levels[0][face];
	        var tex = new Texture(device, {
	          name: 'prefiltered-cube',
	          cubemap: false,
	          type: TEXTURETYPE_DEFAULT,
	          format: source.format,
	          width: cubeSize,
	          height: cubeSize,
	          mipmaps: false
	        });
	        tex._levels[0] = img;
	        tex.upload();
	        var tex2 = new Texture(device, {
	          name: 'prefiltered-cube',
	          cubemap: false,
	          type: TEXTURETYPE_DEFAULT,
	          format: source.format,
	          width: cubeSize,
	          height: cubeSize,
	          mipmaps: false
	        });
	        var targ = new RenderTarget({
	          colorBuffer: tex2,
	          depth: false
	        });
	        constantTexSource.setValue(tex);
	        drawQuadWithShader(device, targ, shader);
	        var gl = device.gl;
	        gl.bindFramebuffer(gl.FRAMEBUFFER, targ.impl._glFrameBuffer);
	        var pixels = new Uint8Array(cubeSize * cubeSize * 4);
	        gl.readPixels(0, 0, tex.width, tex.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
	        source._levels[0][face] = pixels;
	      }
	    } else {
	      return null;
	    }
	  }

	  var dirs = [];

	  for (var y = 0; y < cubeSize; y++) {
	    for (var x = 0; x < cubeSize; x++) {
	      var u = x / (cubeSize - 1) * 2 - 1;
	      var v = y / (cubeSize - 1) * 2 - 1;
	      dirs[y * cubeSize + x] = new Vec3(u, v, 1.0).normalize();
	    }
	  }

	  var sh = new Float32Array(9 * 3);
	  var coef1 = 0;
	  var coef2 = 1 * 3;
	  var coef3 = 2 * 3;
	  var coef4 = 3 * 3;
	  var coef5 = 4 * 3;
	  var coef6 = 5 * 3;
	  var coef7 = 6 * 3;
	  var coef8 = 7 * 3;
	  var coef9 = 8 * 3;
	  var nx = 0;
	  var px = 1;
	  var ny = 2;
	  var py = 3;
	  var nz = 4;
	  var pz = 5;
	  var accum = 0;

	  for (var _face = 0; _face < 6; _face++) {
	    for (var _y = 0; _y < cubeSize; _y++) {
	      for (var _x = 0; _x < cubeSize; _x++) {
	        var addr = _y * cubeSize + _x;
	        var weight = texelCoordSolidAngle(_x, _y, cubeSize);
	        var weight1 = weight * 4 / 17;
	        var weight2 = weight * 8 / 17;
	        var weight3 = weight * 15 / 17;
	        var weight4 = weight * 5 / 68;
	        var weight5 = weight * 15 / 68;
	        var dir = dirs[addr];
	        var dx = void 0,
	            dy = void 0,
	            dz = void 0;

	        if (_face === nx) {
	          dx = dir.z;
	          dy = -dir.y;
	          dz = -dir.x;
	        } else if (_face === px) {
	          dx = -dir.z;
	          dy = -dir.y;
	          dz = dir.x;
	        } else if (_face === ny) {
	          dx = dir.x;
	          dy = dir.z;
	          dz = dir.y;
	        } else if (_face === py) {
	          dx = dir.x;
	          dy = -dir.z;
	          dz = -dir.y;
	        } else if (_face === nz) {
	          dx = dir.x;
	          dy = -dir.y;
	          dz = dir.z;
	        } else if (_face === pz) {
	          dx = -dir.x;
	          dy = -dir.y;
	          dz = -dir.z;
	        }

	        if (!dontFlipX) dx = -dx;
	        var a = source._levels[0][_face][addr * 4 + 3] / 255.0;

	        for (var c = 0; c < 3; c++) {
	          var value = source._levels[0][_face][addr * 4 + c] / 255.0;

	          if (source.type === TEXTURETYPE_RGBM) {
	            value *= a * 8.0;
	            value *= value;
	          } else {
	            value = Math.pow(value, 2.2);
	          }

	          sh[coef1 + c] += value * weight1;
	          sh[coef2 + c] += value * weight2 * dx;
	          sh[coef3 + c] += value * weight2 * dy;
	          sh[coef4 + c] += value * weight2 * dz;
	          sh[coef5 + c] += value * weight3 * dx * dz;
	          sh[coef6 + c] += value * weight3 * dz * dy;
	          sh[coef7 + c] += value * weight3 * dy * dx;
	          sh[coef8 + c] += value * weight4 * (3.0 * dz * dz - 1.0);
	          sh[coef9 + c] += value * weight5 * (dx * dx - dy * dy);
	          accum += weight;
	        }
	      }
	    }
	  }

	  for (var _c = 0; _c < sh.length; _c++) {
	    sh[_c] *= 4 * Math.PI / accum;
	  }

	  return sh;
	}

	var id$2 = 0;

	var IndexBuffer = function () {
	  function IndexBuffer(graphicsDevice, format, numIndices, usage, initialData) {
	    if (usage === void 0) {
	      usage = BUFFER_STATIC;
	    }

	    this.device = graphicsDevice;
	    this.format = format;
	    this.numIndices = numIndices;
	    this.usage = usage;
	    this.id = id$2++;
	    this.impl = graphicsDevice.createIndexBufferImpl(this);
	    var bytesPerIndex = typedArrayIndexFormatsByteSize[format];
	    this.bytesPerIndex = bytesPerIndex;
	    this.numBytes = this.numIndices * bytesPerIndex;

	    if (initialData) {
	      this.setData(initialData);
	    } else {
	      this.storage = new ArrayBuffer(this.numBytes);
	    }

	    this.adjustVramSizeTracking(graphicsDevice._vram, this.numBytes);
	    this.device.buffers.push(this);
	  }

	  var _proto = IndexBuffer.prototype;

	  _proto.destroy = function destroy() {
	    var device = this.device;
	    var idx = device.buffers.indexOf(this);

	    if (idx !== -1) {
	      device.buffers.splice(idx, 1);
	    }

	    if (this.device.indexBuffer === this) {
	      this.device.indexBuffer = null;
	    }

	    if (this.impl.initialized) {
	      this.impl.destroy(device);
	      this.adjustVramSizeTracking(device._vram, -this.storage.byteLength);
	    }
	  };

	  _proto.adjustVramSizeTracking = function adjustVramSizeTracking(vram, size) {
	    vram.ib += size;
	  };

	  _proto.loseContext = function loseContext() {
	    this.impl.loseContext();
	  };

	  _proto.getFormat = function getFormat() {
	    return this.format;
	  };

	  _proto.getNumIndices = function getNumIndices() {
	    return this.numIndices;
	  };

	  _proto.lock = function lock() {
	    return this.storage;
	  };

	  _proto.unlock = function unlock() {
	    this.impl.unlock(this);
	  };

	  _proto.setData = function setData(data) {
	    if (data.byteLength !== this.numBytes) {
	      return false;
	    }

	    this.storage = data;
	    this.unlock();
	    return true;
	  };

	  _proto._lockTypedArray = function _lockTypedArray() {
	    var lock = this.lock();
	    var indices = this.format === INDEXFORMAT_UINT32 ? new Uint32Array(lock) : this.format === INDEXFORMAT_UINT16 ? new Uint16Array(lock) : new Uint8Array(lock);
	    return indices;
	  };

	  _proto.writeData = function writeData(data, count) {
	    var indices = this._lockTypedArray();

	    if (data.length > count) {
	      if (ArrayBuffer.isView(data)) {
	        data = data.subarray(0, count);
	        indices.set(data);
	      } else {
	        for (var i = 0; i < count; i++) {
	          indices[i] = data[i];
	        }
	      }
	    } else {
	      indices.set(data);
	    }

	    this.unlock();
	  };

	  _proto.readData = function readData(data) {
	    var indices = this._lockTypedArray();

	    var count = this.numIndices;

	    if (ArrayBuffer.isView(data)) {
	      data.set(indices);
	    } else {
	      data.length = 0;

	      for (var i = 0; i < count; i++) {
	        data[i] = indices[i];
	      }
	    }

	    return count;
	  };

	  return IndexBuffer;
	}();

	function set1(a) {
	  this.array[this.index] = a;
	}

	function set2(a, b) {
	  this.array[this.index] = a;
	  this.array[this.index + 1] = b;
	}

	function set3(a, b, c) {
	  this.array[this.index] = a;
	  this.array[this.index + 1] = b;
	  this.array[this.index + 2] = c;
	}

	function set4(a, b, c, d) {
	  this.array[this.index] = a;
	  this.array[this.index + 1] = b;
	  this.array[this.index + 2] = c;
	  this.array[this.index + 3] = d;
	}

	function arraySet1(index, inputArray, inputIndex) {
	  this.array[index] = inputArray[inputIndex];
	}

	function arraySet2(index, inputArray, inputIndex) {
	  this.array[index] = inputArray[inputIndex];
	  this.array[index + 1] = inputArray[inputIndex + 1];
	}

	function arraySet3(index, inputArray, inputIndex) {
	  this.array[index] = inputArray[inputIndex];
	  this.array[index + 1] = inputArray[inputIndex + 1];
	  this.array[index + 2] = inputArray[inputIndex + 2];
	}

	function arraySet4(index, inputArray, inputIndex) {
	  this.array[index] = inputArray[inputIndex];
	  this.array[index + 1] = inputArray[inputIndex + 1];
	  this.array[index + 2] = inputArray[inputIndex + 2];
	  this.array[index + 3] = inputArray[inputIndex + 3];
	}

	function arrayGet1(offset, outputArray, outputIndex) {
	  outputArray[outputIndex] = this.array[offset];
	}

	function arrayGet2(offset, outputArray, outputIndex) {
	  outputArray[outputIndex] = this.array[offset];
	  outputArray[outputIndex + 1] = this.array[offset + 1];
	}

	function arrayGet3(offset, outputArray, outputIndex) {
	  outputArray[outputIndex] = this.array[offset];
	  outputArray[outputIndex + 1] = this.array[offset + 1];
	  outputArray[outputIndex + 2] = this.array[offset + 2];
	}

	function arrayGet4(offset, outputArray, outputIndex) {
	  outputArray[outputIndex] = this.array[offset];
	  outputArray[outputIndex + 1] = this.array[offset + 1];
	  outputArray[outputIndex + 2] = this.array[offset + 2];
	  outputArray[outputIndex + 3] = this.array[offset + 3];
	}

	var VertexIteratorAccessor = function () {
	  function VertexIteratorAccessor(buffer, vertexElement, vertexFormat) {
	    this.index = 0;
	    this.numComponents = vertexElement.numComponents;

	    if (vertexFormat.interleaved) {
	      this.array = new typedArrayTypes[vertexElement.dataType](buffer, vertexElement.offset);
	    } else {
	      this.array = new typedArrayTypes[vertexElement.dataType](buffer, vertexElement.offset, vertexFormat.vertexCount * vertexElement.numComponents);
	    }

	    this.stride = vertexElement.stride / this.array.constructor.BYTES_PER_ELEMENT;

	    switch (vertexElement.numComponents) {
	      case 1:
	        this.set = set1;
	        this.getToArray = arrayGet1;
	        this.setFromArray = arraySet1;
	        break;

	      case 2:
	        this.set = set2;
	        this.getToArray = arrayGet2;
	        this.setFromArray = arraySet2;
	        break;

	      case 3:
	        this.set = set3;
	        this.getToArray = arrayGet3;
	        this.setFromArray = arraySet3;
	        break;

	      case 4:
	        this.set = set4;
	        this.getToArray = arrayGet4;
	        this.setFromArray = arraySet4;
	        break;
	    }
	  }

	  var _proto = VertexIteratorAccessor.prototype;

	  _proto.get = function get(offset) {
	    return this.array[this.index + offset];
	  };

	  _proto.set = function set(a, b, c, d) {};

	  _proto.getToArray = function getToArray(offset, outputArray, outputIndex) {};

	  _proto.setFromArray = function setFromArray(index, inputArray, inputIndex) {};

	  return VertexIteratorAccessor;
	}();

	var VertexIterator = function () {
	  function VertexIterator(vertexBuffer) {
	    this.vertexBuffer = vertexBuffer;
	    this.vertexFormatSize = vertexBuffer.getFormat().size;
	    this.buffer = this.vertexBuffer.lock();
	    this.accessors = [];
	    this.element = {};
	    var vertexFormat = this.vertexBuffer.getFormat();

	    for (var i = 0; i < vertexFormat.elements.length; i++) {
	      var vertexElement = vertexFormat.elements[i];
	      this.accessors[i] = new VertexIteratorAccessor(this.buffer, vertexElement, vertexFormat);
	      this.element[vertexElement.name] = this.accessors[i];
	    }
	  }

	  var _proto2 = VertexIterator.prototype;

	  _proto2.next = function next(count) {
	    if (count === void 0) {
	      count = 1;
	    }

	    var i = 0;
	    var accessors = this.accessors;
	    var numAccessors = this.accessors.length;

	    while (i < numAccessors) {
	      var accessor = accessors[i++];
	      accessor.index += count * accessor.stride;
	    }
	  };

	  _proto2.end = function end() {
	    this.vertexBuffer.unlock();
	  };

	  _proto2.writeData = function writeData(semantic, data, numVertices) {
	    var element = this.element[semantic];

	    if (element) {
	      if (numVertices > this.vertexBuffer.numVertices) {
	        numVertices = this.vertexBuffer.numVertices;
	      }

	      var numComponents = element.numComponents;

	      if (this.vertexBuffer.getFormat().interleaved) {
	        var index = 0;

	        for (var i = 0; i < numVertices; i++) {
	          element.setFromArray(index, data, i * numComponents);
	          index += element.stride;
	        }
	      } else {
	        if (data.length > numVertices * numComponents) {
	          var copyCount = numVertices * numComponents;

	          if (ArrayBuffer.isView(data)) {
	            data = data.subarray(0, copyCount);
	            element.array.set(data);
	          } else {
	            for (var _i = 0; _i < copyCount; _i++) {
	              element.array[_i] = data[_i];
	            }
	          }
	        } else {
	          element.array.set(data);
	        }
	      }
	    }
	  };

	  _proto2.readData = function readData(semantic, data) {
	    var element = this.element[semantic];
	    var count = 0;

	    if (element) {
	      count = this.vertexBuffer.numVertices;
	      var i;
	      var numComponents = element.numComponents;

	      if (this.vertexBuffer.getFormat().interleaved) {
	        if (Array.isArray(data)) data.length = 0;
	        element.index = 0;
	        var offset = 0;

	        for (i = 0; i < count; i++) {
	          element.getToArray(offset, data, i * numComponents);
	          offset += element.stride;
	        }
	      } else {
	        if (ArrayBuffer.isView(data)) {
	          data.set(element.array);
	        } else {
	          data.length = 0;
	          var copyCount = count * numComponents;

	          for (i = 0; i < copyCount; i++) {
	            data[i] = element.array[i];
	          }
	        }
	      }
	    }

	    return count;
	  };

	  return VertexIterator;
	}();

	var primitive = {
	  type: PRIMITIVE_TRISTRIP,
	  base: 0,
	  count: 4,
	  indexed: false
	};

	var PostEffect$1 = function () {
	  function PostEffect(graphicsDevice) {
	    this.device = graphicsDevice;
	    this.shader = null;
	    this.vertexBuffer = createFullscreenQuad(graphicsDevice);
	    this.needsDepthBuffer = false;
	    this.depthMap = null;
	  }

	  var _proto = PostEffect.prototype;

	  _proto.render = function render(inputTarget, outputTarget, rect) {};

	  return PostEffect;
	}();

	function createFullscreenQuad(device) {
	  var vertexFormat = new VertexFormat(device, [{
	    semantic: SEMANTIC_POSITION,
	    components: 2,
	    type: TYPE_FLOAT32
	  }]);
	  var vertexBuffer = new VertexBuffer(device, vertexFormat, 4);
	  var iterator = new VertexIterator(vertexBuffer);
	  iterator.element[SEMANTIC_POSITION].set(-1.0, -1.0);
	  iterator.next();
	  iterator.element[SEMANTIC_POSITION].set(1.0, -1.0);
	  iterator.next();
	  iterator.element[SEMANTIC_POSITION].set(-1.0, 1.0);
	  iterator.next();
	  iterator.element[SEMANTIC_POSITION].set(1.0, 1.0);
	  iterator.end();
	  return vertexBuffer;
	}

	function drawFullscreenQuad(device, target, vertexBuffer, shader, rect) {
	  var oldRt = device.getRenderTarget();
	  device.setRenderTarget(target);
	  device.updateBegin();
	  var w = target ? target.width : device.width;
	  var h = target ? target.height : device.height;
	  var x = 0;
	  var y = 0;

	  if (rect) {
	    x = rect.x * w;
	    y = rect.y * h;
	    w *= rect.z;
	    h *= rect.w;
	  }

	  var oldVx = device.vx;
	  var oldVy = device.vy;
	  var oldVw = device.vw;
	  var oldVh = device.vh;
	  device.setViewport(x, y, w, h);
	  var oldSx = device.sx;
	  var oldSy = device.sy;
	  var oldSw = device.sw;
	  var oldSh = device.sh;
	  device.setScissor(x, y, w, h);
	  var oldBlending = device.getBlending();
	  var oldDepthTest = device.getDepthTest();
	  var oldDepthWrite = device.getDepthWrite();
	  var oldCullMode = device.getCullMode();
	  var oldWR = device.writeRed;
	  var oldWG = device.writeGreen;
	  var oldWB = device.writeBlue;
	  var oldWA = device.writeAlpha;
	  device.setBlending(false);
	  device.setDepthTest(false);
	  device.setDepthWrite(false);
	  device.setCullMode(CULLFACE_NONE);
	  device.setColorWrite(true, true, true, true);
	  device.setVertexBuffer(vertexBuffer, 0);
	  device.setShader(shader);
	  device.draw(primitive);
	  device.setBlending(oldBlending);
	  device.setDepthTest(oldDepthTest);
	  device.setDepthWrite(oldDepthWrite);
	  device.setCullMode(oldCullMode);
	  device.setColorWrite(oldWR, oldWG, oldWB, oldWA);
	  device.updateEnd();
	  device.setRenderTarget(oldRt);
	  device.updateBegin();
	  device.setViewport(oldVx, oldVy, oldVw, oldVh);
	  device.setScissor(oldSx, oldSy, oldSw, oldSh);
	}

	var TransformFeedback = function () {
	  function TransformFeedback(inputBuffer, usage) {
	    if (usage === void 0) {
	      usage = BUFFER_GPUDYNAMIC;
	    }

	    this.device = inputBuffer.device;
	    var gl = this.device.gl;
	    this._inputBuffer = inputBuffer;

	    if (usage === BUFFER_GPUDYNAMIC && inputBuffer.usage !== usage) {
	      gl.bindBuffer(gl.ARRAY_BUFFER, inputBuffer.impl.bufferId);
	      gl.bufferData(gl.ARRAY_BUFFER, inputBuffer.storage, gl.DYNAMIC_COPY);
	    }

	    this._outputBuffer = new VertexBuffer(inputBuffer.device, inputBuffer.format, inputBuffer.numVertices, usage, inputBuffer.storage);
	  }

	  TransformFeedback.createShader = function createShader(graphicsDevice, vsCode, name) {
	    return createShaderFromCode(graphicsDevice, vsCode, null, name, true);
	  };

	  var _proto = TransformFeedback.prototype;

	  _proto.destroy = function destroy() {
	    this._outputBuffer.destroy();
	  };

	  _proto.process = function process(shader, swap) {
	    if (swap === void 0) {
	      swap = true;
	    }

	    var device = this.device;
	    var oldRt = device.getRenderTarget();
	    device.setRenderTarget(null);
	    device.updateBegin();
	    device.setVertexBuffer(this._inputBuffer, 0);
	    device.setRaster(false);
	    device.setTransformFeedbackBuffer(this._outputBuffer);
	    device.setShader(shader);
	    device.draw({
	      type: PRIMITIVE_POINTS,
	      base: 0,
	      count: this._inputBuffer.numVertices,
	      indexed: false
	    });
	    device.setTransformFeedbackBuffer(null);
	    device.setRaster(true);
	    device.updateEnd();
	    device.setRenderTarget(oldRt);

	    if (swap) {
	      var tmp = this._inputBuffer.impl.bufferId;
	      this._inputBuffer.impl.bufferId = this._outputBuffer.impl.bufferId;
	      this._outputBuffer.impl.bufferId = tmp;
	      tmp = this._inputBuffer.impl.vao;
	      this._inputBuffer.impl.vao = this._outputBuffer.impl.vao;
	      this._outputBuffer.impl.vao = tmp;
	    }
	  };

	  _createClass(TransformFeedback, [{
	    key: "inputBuffer",
	    get: function get() {
	      return this._inputBuffer;
	    }
	  }, {
	    key: "outputBuffer",
	    get: function get() {
	      return this._outputBuffer;
	    }
	  }]);

	  return TransformFeedback;
	}();

	var WebglBuffer = function () {
	  function WebglBuffer() {
	    this.bufferId = null;
	  }

	  var _proto = WebglBuffer.prototype;

	  _proto.destroy = function destroy(device) {
	    if (this.bufferId) {
	      device.gl.deleteBuffer(this.bufferId);
	      this.bufferId = null;
	    }
	  };

	  _proto.loseContext = function loseContext() {
	    this.bufferId = null;
	  };

	  _proto.unlock = function unlock(device, usage, target, storage) {
	    var gl = device.gl;

	    if (!this.bufferId) {
	      this.bufferId = gl.createBuffer();
	    }

	    var glUsage;

	    switch (usage) {
	      case BUFFER_STATIC:
	        glUsage = gl.STATIC_DRAW;
	        break;

	      case BUFFER_DYNAMIC:
	        glUsage = gl.DYNAMIC_DRAW;
	        break;

	      case BUFFER_STREAM:
	        glUsage = gl.STREAM_DRAW;
	        break;

	      case BUFFER_GPUDYNAMIC:
	        if (device.webgl2) {
	          glUsage = gl.DYNAMIC_COPY;
	        } else {
	          glUsage = gl.STATIC_DRAW;
	        }

	        break;
	    }

	    gl.bindBuffer(target, this.bufferId);
	    gl.bufferData(target, storage, glUsage);
	  };

	  _createClass(WebglBuffer, [{
	    key: "initialized",
	    get: function get() {
	      return !!this.bufferId;
	    }
	  }]);

	  return WebglBuffer;
	}();

	var WebglVertexBuffer = function (_WebglBuffer) {
	  _inheritsLoose(WebglVertexBuffer, _WebglBuffer);

	  function WebglVertexBuffer() {
	    var _this;

	    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    _this = _WebglBuffer.call.apply(_WebglBuffer, [this].concat(args)) || this;
	    _this.vao = null;
	    return _this;
	  }

	  var _proto = WebglVertexBuffer.prototype;

	  _proto.destroy = function destroy(device) {
	    _WebglBuffer.prototype.destroy.call(this, device);

	    device.boundVao = null;
	    device.gl.bindVertexArray(null);
	  };

	  _proto.loseContext = function loseContext() {
	    _WebglBuffer.prototype.loseContext.call(this);

	    this.vao = null;
	  };

	  _proto.unlock = function unlock(vertexBuffer) {
	    var device = vertexBuffer.device;

	    _WebglBuffer.prototype.unlock.call(this, device, vertexBuffer.usage, device.gl.ARRAY_BUFFER, vertexBuffer.storage);
	  };

	  return WebglVertexBuffer;
	}(WebglBuffer);

	var WebglIndexBuffer = function (_WebglBuffer) {
	  _inheritsLoose(WebglIndexBuffer, _WebglBuffer);

	  function WebglIndexBuffer(indexBuffer) {
	    var _this;

	    _this = _WebglBuffer.call(this) || this;
	    var gl = indexBuffer.device.gl;
	    var format = indexBuffer.format;

	    if (format === INDEXFORMAT_UINT8) {
	      _this.glFormat = gl.UNSIGNED_BYTE;
	    } else if (format === INDEXFORMAT_UINT16) {
	      _this.glFormat = gl.UNSIGNED_SHORT;
	    } else if (format === INDEXFORMAT_UINT32) {
	      _this.glFormat = gl.UNSIGNED_INT;
	    }

	    return _this;
	  }

	  var _proto = WebglIndexBuffer.prototype;

	  _proto.unlock = function unlock(indexBuffer) {
	    var device = indexBuffer.device;

	    _WebglBuffer.prototype.unlock.call(this, device, indexBuffer.usage, device.gl.ELEMENT_ARRAY_BUFFER, indexBuffer.storage);
	  };

	  return WebglIndexBuffer;
	}(WebglBuffer);

	var ShaderInput = function ShaderInput(graphicsDevice, name, type, locationId) {
	  this.locationId = locationId;
	  this.scopeId = graphicsDevice.scope.resolve(name);
	  this.version = new Version();

	  if (name.substring(name.length - 3) === "[0]") {
	    switch (type) {
	      case UNIFORMTYPE_FLOAT:
	        type = UNIFORMTYPE_FLOATARRAY;
	        break;

	      case UNIFORMTYPE_VEC2:
	        type = UNIFORMTYPE_VEC2ARRAY;
	        break;

	      case UNIFORMTYPE_VEC3:
	        type = UNIFORMTYPE_VEC3ARRAY;
	        break;

	      case UNIFORMTYPE_VEC4:
	        type = UNIFORMTYPE_VEC4ARRAY;
	        break;
	    }
	  }

	  this.dataType = type;
	  this.value = [null, null, null, null];
	  this.array = [];
	};

	var WebglShader = function () {
	  function WebglShader(shader) {
	    this.uniforms = [];
	    this.samplers = [];
	    this.attributes = [];
	    this.glProgram = null;
	    this.glVertexShader = null;
	    this.glFragmentShader = null;
	    this.compileAndLink(shader.device, shader);
	    shader.device.shaders.push(shader);
	  }

	  var _proto = WebglShader.prototype;

	  _proto.destroy = function destroy(shader) {
	    var device = shader.device;
	    var idx = device.shaders.indexOf(shader);

	    if (idx !== -1) {
	      device.shaders.splice(idx, 1);
	    }

	    if (this.glProgram) {
	      device.gl.deleteProgram(this.glProgram);
	      this.glProgram = null;
	      device.removeShaderFromCache(shader);
	    }
	  };

	  _proto.restoreContext = function restoreContext(device, shader) {
	    this.compileAndLink(device, shader);
	  };

	  _proto.compileAndLink = function compileAndLink(device, shader) {
	    var definition = shader.definition;

	    var glVertexShader = this._compileShaderSource(device, definition.vshader, true);

	    var glFragmentShader = this._compileShaderSource(device, definition.fshader, false);

	    var gl = device.gl;
	    var glProgram = gl.createProgram();
	    gl.attachShader(glProgram, glVertexShader);
	    gl.attachShader(glProgram, glFragmentShader);
	    var attrs = definition.attributes;

	    if (device.webgl2 && definition.useTransformFeedback) {
	      var outNames = [];

	      for (var attr in attrs) {
	        if (attrs.hasOwnProperty(attr)) {
	          outNames.push("out_" + attr);
	        }
	      }

	      gl.transformFeedbackVaryings(glProgram, outNames, gl.INTERLEAVED_ATTRIBS);
	    }

	    for (var _attr in attrs) {
	      if (attrs.hasOwnProperty(_attr)) {
	        var semantic = attrs[_attr];
	        var loc = semanticToLocation[semantic];
	        gl.bindAttribLocation(glProgram, loc, _attr);
	      }
	    }

	    gl.linkProgram(glProgram);
	    this.glVertexShader = glVertexShader;
	    this.glFragmentShader = glFragmentShader;
	    this.glProgram = glProgram;
	  };

	  _proto._compileShaderSource = function _compileShaderSource(device, src, isVertexShader) {
	    var gl = device.gl;
	    var shaderCache = isVertexShader ? device.vertexShaderCache : device.fragmentShaderCache;
	    var glShader = shaderCache[src];

	    if (!glShader) {
	      glShader = gl.createShader(isVertexShader ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER);
	      gl.shaderSource(glShader, src);
	      gl.compileShader(glShader);
	      shaderCache[src] = glShader;
	    }

	    return glShader;
	  };

	  _proto.postLink = function postLink(device, shader) {
	    var gl = device.gl;
	    var glProgram = this.glProgram;
	    var definition = shader.definition;
	    if (!this._isCompiled(device, shader, this.glVertexShader, definition.vshader, "vertex")) return false;
	    if (!this._isCompiled(device, shader, this.glFragmentShader, definition.fshader, "fragment")) return false;

	    if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {
	      var message = "Failed to link shader program. Error: " + gl.getProgramInfoLog(glProgram);
	      console.error(message);
	      return false;
	    }

	    var i, info, location, shaderInput;
	    i = 0;
	    var numAttributes = gl.getProgramParameter(glProgram, gl.ACTIVE_ATTRIBUTES);

	    while (i < numAttributes) {
	      info = gl.getActiveAttrib(glProgram, i++);
	      location = gl.getAttribLocation(glProgram, info.name);

	      if (definition.attributes[info.name] === undefined) {
	        console.error("Vertex shader attribute \"" + info.name + "\" is not mapped to a semantic in shader definition.");
	      }

	      shaderInput = new ShaderInput(device, definition.attributes[info.name], device.pcUniformType[info.type], location);
	      this.attributes.push(shaderInput);
	    }

	    i = 0;
	    var numUniforms = gl.getProgramParameter(glProgram, gl.ACTIVE_UNIFORMS);

	    while (i < numUniforms) {
	      info = gl.getActiveUniform(glProgram, i++);
	      location = gl.getUniformLocation(glProgram, info.name);
	      shaderInput = new ShaderInput(device, info.name, device.pcUniformType[info.type], location);

	      if (info.type === gl.SAMPLER_2D || info.type === gl.SAMPLER_CUBE || device.webgl2 && (info.type === gl.SAMPLER_2D_SHADOW || info.type === gl.SAMPLER_CUBE_SHADOW || info.type === gl.SAMPLER_3D)) {
	        this.samplers.push(shaderInput);
	      } else {
	        this.uniforms.push(shaderInput);
	      }
	    }

	    shader.ready = true;
	    return true;
	  };

	  _proto._isCompiled = function _isCompiled(device, shader, glShader, source, shaderType) {
	    var gl = device.gl;

	    if (!gl.getShaderParameter(glShader, gl.COMPILE_STATUS)) {
	      var infoLog = gl.getShaderInfoLog(glShader);

	      var _this$_processError = this._processError(source, infoLog),
	          code = _this$_processError[0];
	          _this$_processError[1];

	      var message = "Failed to compile " + shaderType + " shader:\n\n" + infoLog + "\n" + code;
	      console.error(message);
	      return false;
	    }

	    return true;
	  };

	  _proto._processError = function _processError(src, infoLog) {
	    var error = {};
	    var code = '';

	    if (src) {
	      var lines = src.split('\n');
	      var from = 0;
	      var to = lines.length;

	      if (infoLog && infoLog.startsWith('ERROR:')) {
	        var match = infoLog.match(/^ERROR:\s([0-9]+):([0-9]+):\s*(.+)/);

	        if (match) {
	          error.message = match[3];
	          error.line = parseInt(match[2], 10);
	          from = Math.max(0, error.line - 6);
	          to = Math.min(lines.length, error.line + 5);
	        }
	      }

	      for (var i = from; i < to; i++) {
	        code += i + 1 + ":\t" + lines[i] + '\n';
	      }

	      error.source = src;
	    }

	    return [code, error];
	  };

	  return WebglShader;
	}();

	function downsampleImage(image, size) {
	  var srcW = image.width;
	  var srcH = image.height;

	  if (srcW > size || srcH > size) {
	    var scale = size / Math.max(srcW, srcH);
	    var dstW = Math.floor(srcW * scale);
	    var dstH = Math.floor(srcH * scale);
	    var canvas = document.createElement('canvas');
	    canvas.width = dstW;
	    canvas.height = dstH;
	    var context = canvas.getContext('2d');
	    context.drawImage(image, 0, 0, srcW, srcH, 0, 0, dstW, dstH);
	    return canvas;
	  }

	  return image;
	}

	var WebglTexture = function () {
	  function WebglTexture() {
	    this._glTexture = null;
	    this._glTarget = void 0;
	    this._glFormat = void 0;
	    this._glInternalFormat = void 0;
	    this._glPixelType = void 0;
	  }

	  var _proto = WebglTexture.prototype;

	  _proto.destroy = function destroy(device) {
	    if (this._glTexture) {
	      for (var i = 0; i < device.textureUnits.length; i++) {
	        var textureUnit = device.textureUnits[i];

	        for (var j = 0; j < textureUnit.length; j++) {
	          if (textureUnit[j] === this._glTexture) {
	            textureUnit[j] = null;
	          }
	        }
	      }

	      device.gl.deleteTexture(this._glTexture);
	      this._glTexture = null;
	    }
	  };

	  _proto.loseContext = function loseContext() {
	    this._glTexture = null;
	  };

	  _proto.initialize = function initialize(device, texture) {
	    var gl = device.gl;
	    this._glTexture = gl.createTexture();
	    this._glTarget = texture._cubemap ? gl.TEXTURE_CUBE_MAP : texture._volume ? gl.TEXTURE_3D : gl.TEXTURE_2D;

	    switch (texture._format) {
	      case PIXELFORMAT_A8:
	        this._glFormat = gl.ALPHA;
	        this._glInternalFormat = gl.ALPHA;
	        this._glPixelType = gl.UNSIGNED_BYTE;
	        break;

	      case PIXELFORMAT_L8:
	        this._glFormat = gl.LUMINANCE;
	        this._glInternalFormat = gl.LUMINANCE;
	        this._glPixelType = gl.UNSIGNED_BYTE;
	        break;

	      case PIXELFORMAT_L8_A8:
	        this._glFormat = gl.LUMINANCE_ALPHA;
	        this._glInternalFormat = gl.LUMINANCE_ALPHA;
	        this._glPixelType = gl.UNSIGNED_BYTE;
	        break;

	      case PIXELFORMAT_R5_G6_B5:
	        this._glFormat = gl.RGB;
	        this._glInternalFormat = gl.RGB;
	        this._glPixelType = gl.UNSIGNED_SHORT_5_6_5;
	        break;

	      case PIXELFORMAT_R5_G5_B5_A1:
	        this._glFormat = gl.RGBA;
	        this._glInternalFormat = gl.RGBA;
	        this._glPixelType = gl.UNSIGNED_SHORT_5_5_5_1;
	        break;

	      case PIXELFORMAT_R4_G4_B4_A4:
	        this._glFormat = gl.RGBA;
	        this._glInternalFormat = gl.RGBA;
	        this._glPixelType = gl.UNSIGNED_SHORT_4_4_4_4;
	        break;

	      case PIXELFORMAT_R8_G8_B8:
	        this._glFormat = gl.RGB;
	        this._glInternalFormat = device.webgl2 ? gl.RGB8 : gl.RGB;
	        this._glPixelType = gl.UNSIGNED_BYTE;
	        break;

	      case PIXELFORMAT_R8_G8_B8_A8:
	        this._glFormat = gl.RGBA;
	        this._glInternalFormat = device.webgl2 ? gl.RGBA8 : gl.RGBA;
	        this._glPixelType = gl.UNSIGNED_BYTE;
	        break;

	      case PIXELFORMAT_DXT1:
	        this._glFormat = gl.RGB;
	        this._glInternalFormat = device.extCompressedTextureS3TC.COMPRESSED_RGB_S3TC_DXT1_EXT;
	        break;

	      case PIXELFORMAT_DXT3:
	        this._glFormat = gl.RGBA;
	        this._glInternalFormat = device.extCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT3_EXT;
	        break;

	      case PIXELFORMAT_DXT5:
	        this._glFormat = gl.RGBA;
	        this._glInternalFormat = device.extCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT5_EXT;
	        break;

	      case PIXELFORMAT_ETC1:
	        this._glFormat = gl.RGB;
	        this._glInternalFormat = device.extCompressedTextureETC1.COMPRESSED_RGB_ETC1_WEBGL;
	        break;

	      case PIXELFORMAT_PVRTC_2BPP_RGB_1:
	        this._glFormat = gl.RGB;
	        this._glInternalFormat = device.extCompressedTexturePVRTC.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
	        break;

	      case PIXELFORMAT_PVRTC_2BPP_RGBA_1:
	        this._glFormat = gl.RGBA;
	        this._glInternalFormat = device.extCompressedTexturePVRTC.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
	        break;

	      case PIXELFORMAT_PVRTC_4BPP_RGB_1:
	        this._glFormat = gl.RGB;
	        this._glInternalFormat = device.extCompressedTexturePVRTC.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
	        break;

	      case PIXELFORMAT_PVRTC_4BPP_RGBA_1:
	        this._glFormat = gl.RGBA;
	        this._glInternalFormat = device.extCompressedTexturePVRTC.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
	        break;

	      case PIXELFORMAT_ETC2_RGB:
	        this._glFormat = gl.RGB;
	        this._glInternalFormat = device.extCompressedTextureETC.COMPRESSED_RGB8_ETC2;
	        break;

	      case PIXELFORMAT_ETC2_RGBA:
	        this._glFormat = gl.RGBA;
	        this._glInternalFormat = device.extCompressedTextureETC.COMPRESSED_RGBA8_ETC2_EAC;
	        break;

	      case PIXELFORMAT_ASTC_4x4:
	        this._glFormat = gl.RGBA;
	        this._glInternalFormat = device.extCompressedTextureASTC.COMPRESSED_RGBA_ASTC_4x4_KHR;
	        break;

	      case PIXELFORMAT_ATC_RGB:
	        this._glFormat = gl.RGB;
	        this._glInternalFormat = device.extCompressedTextureATC.COMPRESSED_RGB_ATC_WEBGL;
	        break;

	      case PIXELFORMAT_ATC_RGBA:
	        this._glFormat = gl.RGBA;
	        this._glInternalFormat = device.extCompressedTextureATC.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL;
	        break;

	      case PIXELFORMAT_RGB16F:
	        this._glFormat = gl.RGB;

	        if (device.webgl2) {
	          this._glInternalFormat = gl.RGB16F;
	          this._glPixelType = gl.HALF_FLOAT;
	        } else {
	          this._glInternalFormat = gl.RGB;
	          this._glPixelType = device.extTextureHalfFloat.HALF_FLOAT_OES;
	        }

	        break;

	      case PIXELFORMAT_RGBA16F:
	        this._glFormat = gl.RGBA;

	        if (device.webgl2) {
	          this._glInternalFormat = gl.RGBA16F;
	          this._glPixelType = gl.HALF_FLOAT;
	        } else {
	          this._glInternalFormat = gl.RGBA;
	          this._glPixelType = device.extTextureHalfFloat.HALF_FLOAT_OES;
	        }

	        break;

	      case PIXELFORMAT_RGB32F:
	        this._glFormat = gl.RGB;

	        if (device.webgl2) {
	          this._glInternalFormat = gl.RGB32F;
	        } else {
	          this._glInternalFormat = gl.RGB;
	        }

	        this._glPixelType = gl.FLOAT;
	        break;

	      case PIXELFORMAT_RGBA32F:
	        this._glFormat = gl.RGBA;

	        if (device.webgl2) {
	          this._glInternalFormat = gl.RGBA32F;
	        } else {
	          this._glInternalFormat = gl.RGBA;
	        }

	        this._glPixelType = gl.FLOAT;
	        break;

	      case PIXELFORMAT_R32F:
	        this._glFormat = gl.RED;
	        this._glInternalFormat = gl.R32F;
	        this._glPixelType = gl.FLOAT;
	        break;

	      case PIXELFORMAT_DEPTH:
	        if (device.webgl2) {
	          this._glFormat = gl.DEPTH_COMPONENT;
	          this._glInternalFormat = gl.DEPTH_COMPONENT32F;
	          this._glPixelType = gl.FLOAT;
	        } else {
	          this._glFormat = gl.DEPTH_COMPONENT;
	          this._glInternalFormat = gl.DEPTH_COMPONENT;
	          this._glPixelType = gl.UNSIGNED_SHORT;
	        }

	        break;

	      case PIXELFORMAT_DEPTHSTENCIL:
	        this._glFormat = gl.DEPTH_STENCIL;

	        if (device.webgl2) {
	          this._glInternalFormat = gl.DEPTH24_STENCIL8;
	          this._glPixelType = gl.UNSIGNED_INT_24_8;
	        } else {
	          this._glInternalFormat = gl.DEPTH_STENCIL;
	          this._glPixelType = device.extDepthTexture.UNSIGNED_INT_24_8_WEBGL;
	        }

	        break;

	      case PIXELFORMAT_111110F:
	        this._glFormat = gl.RGB;
	        this._glInternalFormat = gl.R11F_G11F_B10F;
	        this._glPixelType = gl.UNSIGNED_INT_10F_11F_11F_REV;
	        break;

	      case PIXELFORMAT_SRGB:
	        this._glFormat = gl.RGB;
	        this._glInternalFormat = gl.SRGB8;
	        this._glPixelType = gl.UNSIGNED_BYTE;
	        break;

	      case PIXELFORMAT_SRGBA:
	        this._glFormat = gl.RGBA;
	        this._glInternalFormat = gl.SRGB8_ALPHA8;
	        this._glPixelType = gl.UNSIGNED_BYTE;
	        break;
	    }
	  };

	  _proto.upload = function upload(device, texture) {
	    var gl = device.gl;
	    if (!texture._needsUpload && (texture._needsMipmapsUpload && texture._mipmapsUploaded || !texture.pot)) return;
	    var mipLevel = 0;
	    var mipObject;
	    var resMult;
	    var requiredMipLevels = Math.log2(Math.max(texture._width, texture._height)) + 1;

	    while (texture._levels[mipLevel] || mipLevel === 0) {
	      if (!texture._needsUpload && mipLevel === 0) {
	        mipLevel++;
	        continue;
	      } else if (mipLevel && (!texture._needsMipmapsUpload || !texture._mipmaps)) {
	        break;
	      }

	      mipObject = texture._levels[mipLevel];

	      if (mipLevel === 1 && !texture._compressed && texture._levels.length < requiredMipLevels) {
	        gl.generateMipmap(this._glTarget);
	        texture._mipmapsUploaded = true;
	      }

	      if (texture._cubemap) {
	        var face = void 0;

	        if (device._isBrowserInterface(mipObject[0])) {
	          for (face = 0; face < 6; face++) {
	            if (!texture._levelsUpdated[0][face]) continue;
	            var src = mipObject[face];

	            if (src instanceof HTMLImageElement) {
	              if (src.width > device.maxCubeMapSize || src.height > device.maxCubeMapSize) {
	                src = downsampleImage(src, device.maxCubeMapSize);

	                if (mipLevel === 0) {
	                  texture._width = src.width;
	                  texture._height = src.height;
	                }
	              }
	            }

	            device.setUnpackFlipY(false);
	            device.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
	            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, this._glInternalFormat, this._glFormat, this._glPixelType, src);
	          }
	        } else {
	          resMult = 1 / Math.pow(2, mipLevel);

	          for (face = 0; face < 6; face++) {
	            if (!texture._levelsUpdated[0][face]) continue;
	            var texData = mipObject[face];

	            if (texture._compressed) {
	              gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, this._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), 0, texData);
	            } else {
	              device.setUnpackFlipY(false);
	              device.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
	              gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, this._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), 0, this._glFormat, this._glPixelType, texData);
	            }
	          }
	        }
	      } else if (texture._volume) {
	        resMult = 1 / Math.pow(2, mipLevel);

	        if (texture._compressed) {
	          gl.compressedTexImage3D(gl.TEXTURE_3D, mipLevel, this._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), Math.max(texture._depth * resMult, 1), 0, mipObject);
	        } else {
	          device.setUnpackFlipY(false);
	          device.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
	          gl.texImage3D(gl.TEXTURE_3D, mipLevel, this._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), Math.max(texture._depth * resMult, 1), 0, this._glFormat, this._glPixelType, mipObject);
	        }
	      } else {
	        if (device._isBrowserInterface(mipObject)) {
	          if (mipObject instanceof HTMLImageElement) {
	            if (mipObject.width > device.maxTextureSize || mipObject.height > device.maxTextureSize) {
	              mipObject = downsampleImage(mipObject, device.maxTextureSize);

	              if (mipLevel === 0) {
	                texture._width = mipObject.width;
	                texture._height = mipObject.height;
	              }
	            }
	          }

	          device.setUnpackFlipY(texture._flipY);
	          device.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
	          gl.texImage2D(gl.TEXTURE_2D, mipLevel, this._glInternalFormat, this._glFormat, this._glPixelType, mipObject);
	        } else {
	          resMult = 1 / Math.pow(2, mipLevel);

	          if (texture._compressed) {
	            gl.compressedTexImage2D(gl.TEXTURE_2D, mipLevel, this._glInternalFormat, Math.max(Math.floor(texture._width * resMult), 1), Math.max(Math.floor(texture._height * resMult), 1), 0, mipObject);
	          } else {
	            device.setUnpackFlipY(false);
	            device.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
	            gl.texImage2D(gl.TEXTURE_2D, mipLevel, this._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), 0, this._glFormat, this._glPixelType, mipObject);
	          }
	        }

	        if (mipLevel === 0) {
	          texture._mipmapsUploaded = false;
	        } else {
	          texture._mipmapsUploaded = true;
	        }
	      }

	      mipLevel++;
	    }

	    if (texture._needsUpload) {
	      if (texture._cubemap) {
	        for (var i = 0; i < 6; i++) {
	          texture._levelsUpdated[0][i] = false;
	        }
	      } else {
	        texture._levelsUpdated[0] = false;
	      }
	    }

	    if (!texture._compressed && texture._mipmaps && texture._needsMipmapsUpload && (texture.pot || device.webgl2) && texture._levels.length === 1) {
	      gl.generateMipmap(this._glTarget);
	      texture._mipmapsUploaded = true;
	    }

	    if (texture._gpuSize) {
	      texture.adjustVramSizeTracking(device._vram, -texture._gpuSize);
	    }

	    texture._gpuSize = texture.gpuSize;
	    texture.adjustVramSizeTracking(device._vram, texture._gpuSize);
	  };

	  return WebglTexture;
	}();

	var WebglRenderTarget = function () {
	  function WebglRenderTarget() {
	    this._glFrameBuffer = null;
	    this._glDepthBuffer = null;
	    this._glResolveFrameBuffer = null;
	    this._glMsaaColorBuffer = null;
	    this._glMsaaDepthBuffer = null;
	  }

	  var _proto = WebglRenderTarget.prototype;

	  _proto.destroy = function destroy(device) {
	    var gl = device.gl;

	    if (this._glFrameBuffer) {
	      gl.deleteFramebuffer(this._glFrameBuffer);
	      this._glFrameBuffer = null;
	    }

	    if (this._glDepthBuffer) {
	      gl.deleteRenderbuffer(this._glDepthBuffer);
	      this._glDepthBuffer = null;
	    }

	    if (this._glResolveFrameBuffer) {
	      gl.deleteFramebuffer(this._glResolveFrameBuffer);
	      this._glResolveFrameBuffer = null;
	    }

	    if (this._glMsaaColorBuffer) {
	      gl.deleteRenderbuffer(this._glMsaaColorBuffer);
	      this._glMsaaColorBuffer = null;
	    }

	    if (this._glMsaaDepthBuffer) {
	      gl.deleteRenderbuffer(this._glMsaaDepthBuffer);
	      this._glMsaaDepthBuffer = null;
	    }
	  };

	  _proto.init = function init(device, target) {
	    var gl = device.gl;
	    this._glFrameBuffer = gl.createFramebuffer();
	    device.setFramebuffer(this._glFrameBuffer);
	    var colorBuffer = target._colorBuffer;

	    if (colorBuffer) {
	      if (!colorBuffer.impl._glTexture) {
	        colorBuffer._width = Math.min(colorBuffer.width, device.maxRenderBufferSize);
	        colorBuffer._height = Math.min(colorBuffer.height, device.maxRenderBufferSize);
	        device.setTexture(colorBuffer, 0);
	      }

	      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, colorBuffer._cubemap ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + target._face : gl.TEXTURE_2D, colorBuffer.impl._glTexture, 0);
	    }

	    var depthBuffer = target._depthBuffer;

	    if (depthBuffer) {
	      if (!depthBuffer.impl._glTexture) {
	        depthBuffer._width = Math.min(depthBuffer.width, device.maxRenderBufferSize);
	        depthBuffer._height = Math.min(depthBuffer.height, device.maxRenderBufferSize);
	        device.setTexture(depthBuffer, 0);
	      }

	      if (target._stencil) {
	        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, depthBuffer._cubemap ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + target._face : gl.TEXTURE_2D, target._depthBuffer.impl._glTexture, 0);
	      } else {
	        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, depthBuffer._cubemap ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + target._face : gl.TEXTURE_2D, target._depthBuffer.impl._glTexture, 0);
	      }
	    } else if (target._depth) {
	      var willRenderMsaa = target._samples > 1 && device.webgl2;

	      if (!willRenderMsaa) {
	        if (!this._glDepthBuffer) {
	          this._glDepthBuffer = gl.createRenderbuffer();
	        }

	        gl.bindRenderbuffer(gl.RENDERBUFFER, this._glDepthBuffer);

	        if (target._stencil) {
	          gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, target.width, target.height);
	          gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, this._glDepthBuffer);
	        } else {
	          var depthFormat = device.webgl2 ? gl.DEPTH_COMPONENT32F : gl.DEPTH_COMPONENT16;
	          gl.renderbufferStorage(gl.RENDERBUFFER, depthFormat, target.width, target.height);
	          gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this._glDepthBuffer);
	        }

	        gl.bindRenderbuffer(gl.RENDERBUFFER, null);
	      }
	    }

	    if (device.webgl2 && target._samples > 1) {
	      this._glResolveFrameBuffer = this._glFrameBuffer;
	      this._glFrameBuffer = gl.createFramebuffer();
	      device.setFramebuffer(this._glFrameBuffer);

	      if (colorBuffer) {
	        if (!this._glMsaaColorBuffer) {
	          this._glMsaaColorBuffer = gl.createRenderbuffer();
	        }

	        gl.bindRenderbuffer(gl.RENDERBUFFER, this._glMsaaColorBuffer);
	        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, target._samples, colorBuffer.impl._glInternalFormat, target.width, target.height);
	        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, this._glMsaaColorBuffer);
	      }

	      if (target._depth) {
	        if (!this._glMsaaDepthBuffer) {
	          this._glMsaaDepthBuffer = gl.createRenderbuffer();
	        }

	        gl.bindRenderbuffer(gl.RENDERBUFFER, this._glMsaaDepthBuffer);

	        if (target._stencil) {
	          gl.renderbufferStorageMultisample(gl.RENDERBUFFER, target._samples, gl.DEPTH24_STENCIL8, target.width, target.height);
	          gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, this._glMsaaDepthBuffer);
	        } else {
	          gl.renderbufferStorageMultisample(gl.RENDERBUFFER, target._samples, gl.DEPTH_COMPONENT32F, target.width, target.height);
	          gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this._glMsaaDepthBuffer);
	        }
	      }
	    }
	  };

	  _proto._checkFbo = function _checkFbo(device) {
	    var gl = device.gl;
	    var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

	    switch (status) {
	      case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
	        console.error("ERROR: FRAMEBUFFER_INCOMPLETE_ATTACHMENT");
	        break;

	      case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
	        console.error("ERROR: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
	        break;

	      case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
	        console.error("ERROR: FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
	        break;

	      case gl.FRAMEBUFFER_UNSUPPORTED:
	        console.error("ERROR: FRAMEBUFFER_UNSUPPORTED");
	        break;

	      case gl.FRAMEBUFFER_COMPLETE:
	        break;
	    }
	  };

	  _proto.loseContext = function loseContext() {
	    this._glFrameBuffer = null;
	    this._glDepthBuffer = null;
	    this._glResolveFrameBuffer = null;
	    this._glMsaaColorBuffer = null;
	    this._glMsaaDepthBuffer = null;
	  };

	  _proto.resolve = function resolve(device, target, color, depth) {
	    if (device.webgl2) {
	      var gl = device.gl;
	      gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this._glFrameBuffer);
	      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this._glResolveFrameBuffer);
	      gl.blitFramebuffer(0, 0, target.width, target.height, 0, 0, target.width, target.height, (color ? gl.COLOR_BUFFER_BIT : 0) | (depth ? gl.DEPTH_BUFFER_BIT : 0), gl.NEAREST);
	      gl.bindFramebuffer(gl.FRAMEBUFFER, this._glFrameBuffer);
	    }
	  };

	  _createClass(WebglRenderTarget, [{
	    key: "initialized",
	    get: function get() {
	      return this._glFrameBuffer !== null;
	    }
	  }]);

	  return WebglRenderTarget;
	}();

	var invalidateAttachments = [];

	function testRenderable(gl, pixelFormat) {
	  var result = true;
	  var texture = gl.createTexture();
	  gl.bindTexture(gl.TEXTURE_2D, texture);
	  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
	  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
	  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, pixelFormat, null);
	  var framebuffer = gl.createFramebuffer();
	  gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
	  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);

	  if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) {
	    result = false;
	  }

	  gl.bindTexture(gl.TEXTURE_2D, null);
	  gl.deleteTexture(texture);
	  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
	  gl.deleteFramebuffer(framebuffer);
	  return result;
	}

	function testTextureHalfFloatUpdatable(gl, pixelFormat) {
	  var result = true;
	  var texture = gl.createTexture();
	  gl.bindTexture(gl.TEXTURE_2D, texture);
	  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
	  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
	  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	  var data = new Uint16Array(4 * 2 * 2);
	  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, pixelFormat, data);

	  if (gl.getError() !== gl.NO_ERROR) {
	    result = false;
	    console.log("Above error related to HALF_FLOAT_OES can be ignored, it was triggered by testing half float texture support");
	  }

	  gl.bindTexture(gl.TEXTURE_2D, null);
	  gl.deleteTexture(texture);
	  return result;
	}

	function testTextureFloatHighPrecision(device) {
	  if (!device.textureFloatRenderable) return false;
	  var test1 = createShaderFromCode(device, shaderChunks.fullscreenQuadVS, shaderChunks.precisionTestPS, "ptest1");
	  var test2 = createShaderFromCode(device, shaderChunks.fullscreenQuadVS, shaderChunks.precisionTest2PS, "ptest2");
	  var textureOptions = {
	    format: PIXELFORMAT_RGBA32F,
	    width: 1,
	    height: 1,
	    mipmaps: false,
	    minFilter: FILTER_NEAREST,
	    magFilter: FILTER_NEAREST,
	    name: 'testFHP'
	  };
	  var tex1 = new Texture(device, textureOptions);
	  var targ1 = new RenderTarget({
	    colorBuffer: tex1,
	    depth: false
	  });
	  drawQuadWithShader(device, targ1, test1);
	  textureOptions.format = PIXELFORMAT_R8_G8_B8_A8;
	  var tex2 = new Texture(device, textureOptions);
	  var targ2 = new RenderTarget({
	    colorBuffer: tex2,
	    depth: false
	  });
	  device.constantTexSource.setValue(tex1);
	  drawQuadWithShader(device, targ2, test2);
	  var prevFramebuffer = device.activeFramebuffer;
	  device.setFramebuffer(targ2.impl._glFrameBuffer);
	  var pixels = new Uint8Array(4);
	  device.readPixels(0, 0, 1, 1, pixels);
	  device.setFramebuffer(prevFramebuffer);
	  var x = pixels[0] / 255;
	  var y = pixels[1] / 255;
	  var z = pixels[2] / 255;
	  var w = pixels[3] / 255;
	  var f = x / (256 * 256 * 256) + y / (256 * 256) + z / 256 + w;
	  tex1.destroy();
	  targ1.destroy();
	  tex2.destroy();
	  targ2.destroy();
	  return f === 0;
	}

	var WebglGraphicsDevice = function (_GraphicsDevice) {
	  _inheritsLoose(WebglGraphicsDevice, _GraphicsDevice);

	  function WebglGraphicsDevice(canvas, options) {
	    var _this;

	    if (options === void 0) {
	      options = {};
	    }

	    _this = _GraphicsDevice.call(this, canvas) || this;
	    _this.gl = void 0;
	    _this.webgl2 = void 0;
	    _this.deviceType = DEVICETYPE_WEBGL;
	    _this.defaultFramebuffer = null;
	    _this.defaultFramebufferAlpha = options.alpha;

	    _this.updateClientRect();

	    _this.contextLost = false;

	    _this._contextLostHandler = function (event) {
	      event.preventDefault();
	      _this.contextLost = true;

	      _this.loseContext();

	      _this.fire('devicelost');
	    };

	    _this._contextRestoredHandler = function () {
	      _this.restoreContext();

	      _this.contextLost = false;

	      _this.fire('devicerestored');
	    };

	    options.stencil = true;

	    if (!options.powerPreference) {
	      options.powerPreference = 'high-performance';
	    }

	    var ua = typeof navigator !== 'undefined' && navigator.userAgent;
	    _this.forceDisableMultisampling = ua && ua.includes('AppleWebKit') && (ua.includes('15.4') || ua.includes('15_4'));

	    if (_this.forceDisableMultisampling) {
	      options.antialias = false;
	    }

	    var preferWebGl2 = options.preferWebGl2 !== undefined ? options.preferWebGl2 : true;
	    var names = preferWebGl2 ? ["webgl2", "webgl", "experimental-webgl"] : ["webgl", "experimental-webgl"];
	    var gl = null;

	    for (var i = 0; i < names.length; i++) {
	      gl = canvas.getContext(names[i], options);

	      if (gl) {
	        _this.webgl2 = names[i] === 'webgl2';
	        break;
	      }
	    }

	    if (!gl) {
	      throw new Error("WebGL not supported");
	    }

	    var isChrome = platform.browser && !!window.chrome;
	    var isMac = platform.browser && navigator.appVersion.indexOf("Mac") !== -1;
	    _this.gl = gl;
	    _this._tempEnableSafariTextureUnitWorkaround = platform.browser && !!window.safari;
	    _this._tempMacChromeBlitFramebufferWorkaround = isMac && isChrome && !options.alpha;

	    if (!_this.webgl2) {
	      setupVertexArrayObject(gl);
	    }

	    canvas.addEventListener("webglcontextlost", _this._contextLostHandler, false);
	    canvas.addEventListener("webglcontextrestored", _this._contextRestoredHandler, false);

	    _this.initializeExtensions();

	    _this.initializeCapabilities();

	    _this.initializeRenderState();

	    _this.initializeContextCaches();

	    _this.defaultClearOptions = {
	      color: [0, 0, 0, 1],
	      depth: 1,
	      stencil: 0,
	      flags: CLEARFLAG_COLOR | CLEARFLAG_DEPTH
	    };
	    _this.glAddress = [gl.REPEAT, gl.CLAMP_TO_EDGE, gl.MIRRORED_REPEAT];
	    _this.glBlendEquation = [gl.FUNC_ADD, gl.FUNC_SUBTRACT, gl.FUNC_REVERSE_SUBTRACT, _this.webgl2 ? gl.MIN : _this.extBlendMinmax ? _this.extBlendMinmax.MIN_EXT : gl.FUNC_ADD, _this.webgl2 ? gl.MAX : _this.extBlendMinmax ? _this.extBlendMinmax.MAX_EXT : gl.FUNC_ADD];
	    _this.glBlendFunction = [gl.ZERO, gl.ONE, gl.SRC_COLOR, gl.ONE_MINUS_SRC_COLOR, gl.DST_COLOR, gl.ONE_MINUS_DST_COLOR, gl.SRC_ALPHA, gl.SRC_ALPHA_SATURATE, gl.ONE_MINUS_SRC_ALPHA, gl.DST_ALPHA, gl.ONE_MINUS_DST_ALPHA, gl.CONSTANT_COLOR, gl.ONE_MINUS_CONSTANT_COLOR, gl.CONSTANT_ALPHA, gl.ONE_MINUS_CONSTANT_ALPHA];
	    _this.glComparison = [gl.NEVER, gl.LESS, gl.EQUAL, gl.LEQUAL, gl.GREATER, gl.NOTEQUAL, gl.GEQUAL, gl.ALWAYS];
	    _this.glStencilOp = [gl.KEEP, gl.ZERO, gl.REPLACE, gl.INCR, gl.INCR_WRAP, gl.DECR, gl.DECR_WRAP, gl.INVERT];
	    _this.glClearFlag = [0, gl.COLOR_BUFFER_BIT, gl.DEPTH_BUFFER_BIT, gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT, gl.STENCIL_BUFFER_BIT, gl.STENCIL_BUFFER_BIT | gl.COLOR_BUFFER_BIT, gl.STENCIL_BUFFER_BIT | gl.DEPTH_BUFFER_BIT, gl.STENCIL_BUFFER_BIT | gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT];
	    _this.glCull = [0, gl.BACK, gl.FRONT, gl.FRONT_AND_BACK];
	    _this.glFilter = [gl.NEAREST, gl.LINEAR, gl.NEAREST_MIPMAP_NEAREST, gl.NEAREST_MIPMAP_LINEAR, gl.LINEAR_MIPMAP_NEAREST, gl.LINEAR_MIPMAP_LINEAR];
	    _this.glPrimitive = [gl.POINTS, gl.LINES, gl.LINE_LOOP, gl.LINE_STRIP, gl.TRIANGLES, gl.TRIANGLE_STRIP, gl.TRIANGLE_FAN];
	    _this.glType = [gl.BYTE, gl.UNSIGNED_BYTE, gl.SHORT, gl.UNSIGNED_SHORT, gl.INT, gl.UNSIGNED_INT, gl.FLOAT];
	    _this.pcUniformType = {};
	    _this.pcUniformType[gl.BOOL] = UNIFORMTYPE_BOOL;
	    _this.pcUniformType[gl.INT] = UNIFORMTYPE_INT;
	    _this.pcUniformType[gl.FLOAT] = UNIFORMTYPE_FLOAT;
	    _this.pcUniformType[gl.FLOAT_VEC2] = UNIFORMTYPE_VEC2;
	    _this.pcUniformType[gl.FLOAT_VEC3] = UNIFORMTYPE_VEC3;
	    _this.pcUniformType[gl.FLOAT_VEC4] = UNIFORMTYPE_VEC4;
	    _this.pcUniformType[gl.INT_VEC2] = UNIFORMTYPE_IVEC2;
	    _this.pcUniformType[gl.INT_VEC3] = UNIFORMTYPE_IVEC3;
	    _this.pcUniformType[gl.INT_VEC4] = UNIFORMTYPE_IVEC4;
	    _this.pcUniformType[gl.BOOL_VEC2] = UNIFORMTYPE_BVEC2;
	    _this.pcUniformType[gl.BOOL_VEC3] = UNIFORMTYPE_BVEC3;
	    _this.pcUniformType[gl.BOOL_VEC4] = UNIFORMTYPE_BVEC4;
	    _this.pcUniformType[gl.FLOAT_MAT2] = UNIFORMTYPE_MAT2;
	    _this.pcUniformType[gl.FLOAT_MAT3] = UNIFORMTYPE_MAT3;
	    _this.pcUniformType[gl.FLOAT_MAT4] = UNIFORMTYPE_MAT4;
	    _this.pcUniformType[gl.SAMPLER_2D] = UNIFORMTYPE_TEXTURE2D;
	    _this.pcUniformType[gl.SAMPLER_CUBE] = UNIFORMTYPE_TEXTURECUBE;

	    if (_this.webgl2) {
	      _this.pcUniformType[gl.SAMPLER_2D_SHADOW] = UNIFORMTYPE_TEXTURE2D_SHADOW;
	      _this.pcUniformType[gl.SAMPLER_CUBE_SHADOW] = UNIFORMTYPE_TEXTURECUBE_SHADOW;
	      _this.pcUniformType[gl.SAMPLER_3D] = UNIFORMTYPE_TEXTURE3D;
	    }

	    _this.targetToSlot = {};
	    _this.targetToSlot[gl.TEXTURE_2D] = 0;
	    _this.targetToSlot[gl.TEXTURE_CUBE_MAP] = 1;
	    _this.targetToSlot[gl.TEXTURE_3D] = 2;
	    var scopeX, scopeY, scopeZ, scopeW;
	    var uniformValue;
	    _this.commitFunction = [];

	    _this.commitFunction[UNIFORMTYPE_BOOL] = function (uniform, value) {
	      if (uniform.value !== value) {
	        gl.uniform1i(uniform.locationId, value);
	        uniform.value = value;
	      }
	    };

	    _this.commitFunction[UNIFORMTYPE_INT] = _this.commitFunction[UNIFORMTYPE_BOOL];

	    _this.commitFunction[UNIFORMTYPE_FLOAT] = function (uniform, value) {
	      if (uniform.value !== value) {
	        gl.uniform1f(uniform.locationId, value);
	        uniform.value = value;
	      }
	    };

	    _this.commitFunction[UNIFORMTYPE_VEC2] = function (uniform, value) {
	      uniformValue = uniform.value;
	      scopeX = value[0];
	      scopeY = value[1];

	      if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY) {
	        gl.uniform2fv(uniform.locationId, value);
	        uniformValue[0] = scopeX;
	        uniformValue[1] = scopeY;
	      }
	    };

	    _this.commitFunction[UNIFORMTYPE_VEC3] = function (uniform, value) {
	      uniformValue = uniform.value;
	      scopeX = value[0];
	      scopeY = value[1];
	      scopeZ = value[2];

	      if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ) {
	        gl.uniform3fv(uniform.locationId, value);
	        uniformValue[0] = scopeX;
	        uniformValue[1] = scopeY;
	        uniformValue[2] = scopeZ;
	      }
	    };

	    _this.commitFunction[UNIFORMTYPE_VEC4] = function (uniform, value) {
	      uniformValue = uniform.value;
	      scopeX = value[0];
	      scopeY = value[1];
	      scopeZ = value[2];
	      scopeW = value[3];

	      if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ || uniformValue[3] !== scopeW) {
	        gl.uniform4fv(uniform.locationId, value);
	        uniformValue[0] = scopeX;
	        uniformValue[1] = scopeY;
	        uniformValue[2] = scopeZ;
	        uniformValue[3] = scopeW;
	      }
	    };

	    _this.commitFunction[UNIFORMTYPE_IVEC2] = function (uniform, value) {
	      uniformValue = uniform.value;
	      scopeX = value[0];
	      scopeY = value[1];

	      if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY) {
	        gl.uniform2iv(uniform.locationId, value);
	        uniformValue[0] = scopeX;
	        uniformValue[1] = scopeY;
	      }
	    };

	    _this.commitFunction[UNIFORMTYPE_BVEC2] = _this.commitFunction[UNIFORMTYPE_IVEC2];

	    _this.commitFunction[UNIFORMTYPE_IVEC3] = function (uniform, value) {
	      uniformValue = uniform.value;
	      scopeX = value[0];
	      scopeY = value[1];
	      scopeZ = value[2];

	      if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ) {
	        gl.uniform3iv(uniform.locationId, value);
	        uniformValue[0] = scopeX;
	        uniformValue[1] = scopeY;
	        uniformValue[2] = scopeZ;
	      }
	    };

	    _this.commitFunction[UNIFORMTYPE_BVEC3] = _this.commitFunction[UNIFORMTYPE_IVEC3];

	    _this.commitFunction[UNIFORMTYPE_IVEC4] = function (uniform, value) {
	      uniformValue = uniform.value;
	      scopeX = value[0];
	      scopeY = value[1];
	      scopeZ = value[2];
	      scopeW = value[3];

	      if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ || uniformValue[3] !== scopeW) {
	        gl.uniform4iv(uniform.locationId, value);
	        uniformValue[0] = scopeX;
	        uniformValue[1] = scopeY;
	        uniformValue[2] = scopeZ;
	        uniformValue[3] = scopeW;
	      }
	    };

	    _this.commitFunction[UNIFORMTYPE_BVEC4] = _this.commitFunction[UNIFORMTYPE_IVEC4];

	    _this.commitFunction[UNIFORMTYPE_MAT2] = function (uniform, value) {
	      gl.uniformMatrix2fv(uniform.locationId, false, value);
	    };

	    _this.commitFunction[UNIFORMTYPE_MAT3] = function (uniform, value) {
	      gl.uniformMatrix3fv(uniform.locationId, false, value);
	    };

	    _this.commitFunction[UNIFORMTYPE_MAT4] = function (uniform, value) {
	      gl.uniformMatrix4fv(uniform.locationId, false, value);
	    };

	    _this.commitFunction[UNIFORMTYPE_FLOATARRAY] = function (uniform, value) {
	      gl.uniform1fv(uniform.locationId, value);
	    };

	    _this.commitFunction[UNIFORMTYPE_VEC2ARRAY] = function (uniform, value) {
	      gl.uniform2fv(uniform.locationId, value);
	    };

	    _this.commitFunction[UNIFORMTYPE_VEC3ARRAY] = function (uniform, value) {
	      gl.uniform3fv(uniform.locationId, value);
	    };

	    _this.commitFunction[UNIFORMTYPE_VEC4ARRAY] = function (uniform, value) {
	      gl.uniform4fv(uniform.locationId, value);
	    };

	    _this.supportsBoneTextures = _this.extTextureFloat && _this.maxVertexTextures > 0;
	    var numUniforms = _this.vertexUniformsCount;
	    numUniforms -= 4 * 4;
	    numUniforms -= 8;
	    numUniforms -= 1;
	    numUniforms -= 4 * 4;
	    _this.boneLimit = Math.floor(numUniforms / 3);
	    _this.boneLimit = Math.min(_this.boneLimit, 128);

	    if (_this.unmaskedRenderer === 'Mali-450 MP') {
	      _this.boneLimit = 34;
	    }

	    _this.constantTexSource = _this.scope.resolve("source");

	    if (_this.extTextureFloat) {
	      if (_this.webgl2) {
	        _this.textureFloatRenderable = !!_this.extColorBufferFloat;
	      } else {
	        _this.textureFloatRenderable = testRenderable(gl, gl.FLOAT);
	      }
	    } else {
	      _this.textureFloatRenderable = false;
	    }

	    if (_this.extColorBufferHalfFloat) {
	      _this.textureHalfFloatRenderable = !!_this.extColorBufferHalfFloat;
	    } else if (_this.extTextureHalfFloat) {
	      if (_this.webgl2) {
	        _this.textureHalfFloatRenderable = !!_this.extColorBufferFloat;
	      } else {
	        _this.textureHalfFloatRenderable = testRenderable(gl, _this.extTextureHalfFloat.HALF_FLOAT_OES);
	      }
	    } else {
	      _this.textureHalfFloatRenderable = false;
	    }

	    _this.supportsMorphTargetTexturesCore = _this.maxPrecision === "highp" && _this.maxVertexTextures >= 2;
	    _this._textureFloatHighPrecision = undefined;
	    _this._textureHalfFloatUpdatable = undefined;
	    _this.areaLightLutFormat = PIXELFORMAT_R8_G8_B8_A8;

	    if (_this.extTextureHalfFloat && _this.textureHalfFloatUpdatable && _this.extTextureHalfFloatLinear) {
	      _this.areaLightLutFormat = PIXELFORMAT_RGBA16F;
	    } else if (_this.extTextureFloat && _this.extTextureFloatLinear) {
	      _this.areaLightLutFormat = PIXELFORMAT_RGBA32F;
	    }

	    return _this;
	  }

	  var _proto = WebglGraphicsDevice.prototype;

	  _proto.destroy = function destroy() {
	    _GraphicsDevice.prototype.destroy.call(this);

	    var gl = this.gl;

	    if (this.webgl2 && this.feedback) {
	      gl.deleteTransformFeedback(this.feedback);
	    }

	    this.clearShaderCache();
	    this.clearVertexArrayObjectCache();
	    this.canvas.removeEventListener('webglcontextlost', this._contextLostHandler, false);
	    this.canvas.removeEventListener('webglcontextrestored', this._contextRestoredHandler, false);
	    this._contextLostHandler = null;
	    this._contextRestoredHandler = null;
	    this.gl = null;

	    _GraphicsDevice.prototype.postDestroy.call(this);
	  };

	  _proto.createVertexBufferImpl = function createVertexBufferImpl(vertexBuffer, format) {
	    return new WebglVertexBuffer();
	  };

	  _proto.createIndexBufferImpl = function createIndexBufferImpl(indexBuffer) {
	    return new WebglIndexBuffer(indexBuffer);
	  };

	  _proto.createShaderImpl = function createShaderImpl(shader) {
	    return new WebglShader(shader);
	  };

	  _proto.createTextureImpl = function createTextureImpl(texture) {
	    return new WebglTexture();
	  };

	  _proto.createRenderTargetImpl = function createRenderTargetImpl(renderTarget) {
	    return new WebglRenderTarget();
	  };

	  _proto.getPrecision = function getPrecision() {
	    var gl = this.gl;
	    var precision = "highp";

	    if (gl.getShaderPrecisionFormat) {
	      var vertexShaderPrecisionHighpFloat = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT);
	      var vertexShaderPrecisionMediumpFloat = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT);
	      var fragmentShaderPrecisionHighpFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
	      var fragmentShaderPrecisionMediumpFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT);
	      var highpAvailable = vertexShaderPrecisionHighpFloat.precision > 0 && fragmentShaderPrecisionHighpFloat.precision > 0;
	      var mediumpAvailable = vertexShaderPrecisionMediumpFloat.precision > 0 && fragmentShaderPrecisionMediumpFloat.precision > 0;

	      if (!highpAvailable) {
	        if (mediumpAvailable) {
	          precision = "mediump";
	        } else {
	          precision = "lowp";
	        }
	      }
	    }

	    return precision;
	  };

	  _proto.initializeExtensions = function initializeExtensions() {
	    var gl = this.gl;
	    var supportedExtensions = gl.getSupportedExtensions();

	    var getExtension = function getExtension() {
	      for (var i = 0; i < arguments.length; i++) {
	        if (supportedExtensions.indexOf(arguments[i]) !== -1) {
	          return gl.getExtension(arguments[i]);
	        }
	      }

	      return null;
	    };

	    if (this.webgl2) {
	      this.extBlendMinmax = true;
	      this.extDrawBuffers = true;
	      this.extInstancing = true;
	      this.extStandardDerivatives = true;
	      this.extTextureFloat = true;
	      this.extTextureHalfFloat = true;
	      this.extTextureLod = true;
	      this.extUintElement = true;
	      this.extVertexArrayObject = true;
	      this.extColorBufferFloat = getExtension('EXT_color_buffer_float');
	      this.extDisjointTimerQuery = getExtension('EXT_disjoint_timer_query_webgl2', 'EXT_disjoint_timer_query');
	      this.extDepthTexture = true;
	    } else {
	      this.extBlendMinmax = getExtension("EXT_blend_minmax");
	      this.extDrawBuffers = getExtension('EXT_draw_buffers');
	      this.extInstancing = getExtension("ANGLE_instanced_arrays");

	      if (this.extInstancing) {
	        var ext = this.extInstancing;
	        gl.drawArraysInstanced = ext.drawArraysInstancedANGLE.bind(ext);
	        gl.drawElementsInstanced = ext.drawElementsInstancedANGLE.bind(ext);
	        gl.vertexAttribDivisor = ext.vertexAttribDivisorANGLE.bind(ext);
	      }

	      this.extStandardDerivatives = getExtension("OES_standard_derivatives");
	      this.extTextureFloat = getExtension("OES_texture_float");
	      this.extTextureHalfFloat = getExtension("OES_texture_half_float");
	      this.extTextureLod = getExtension('EXT_shader_texture_lod');
	      this.extUintElement = getExtension("OES_element_index_uint");
	      this.extVertexArrayObject = getExtension("OES_vertex_array_object");

	      if (this.extVertexArrayObject) {
	        var _ext = this.extVertexArrayObject;
	        gl.createVertexArray = _ext.createVertexArrayOES.bind(_ext);
	        gl.deleteVertexArray = _ext.deleteVertexArrayOES.bind(_ext);
	        gl.isVertexArray = _ext.isVertexArrayOES.bind(_ext);
	        gl.bindVertexArray = _ext.bindVertexArrayOES.bind(_ext);
	      }

	      this.extColorBufferFloat = null;
	      this.extDisjointTimerQuery = null;
	      this.extDepthTexture = gl.getExtension('WEBGL_depth_texture');
	    }

	    this.extDebugRendererInfo = getExtension('WEBGL_debug_renderer_info');
	    this.extTextureFloatLinear = getExtension("OES_texture_float_linear");
	    this.extTextureHalfFloatLinear = getExtension("OES_texture_half_float_linear");
	    this.extFloatBlend = getExtension("EXT_float_blend");
	    this.extTextureFilterAnisotropic = getExtension('EXT_texture_filter_anisotropic', 'WEBKIT_EXT_texture_filter_anisotropic');
	    this.extCompressedTextureETC1 = getExtension('WEBGL_compressed_texture_etc1');
	    this.extCompressedTextureETC = getExtension('WEBGL_compressed_texture_etc');
	    this.extCompressedTexturePVRTC = getExtension('WEBGL_compressed_texture_pvrtc', 'WEBKIT_WEBGL_compressed_texture_pvrtc');
	    this.extCompressedTextureS3TC = getExtension('WEBGL_compressed_texture_s3tc', 'WEBKIT_WEBGL_compressed_texture_s3tc');
	    this.extCompressedTextureATC = getExtension('WEBGL_compressed_texture_atc');
	    this.extCompressedTextureASTC = getExtension('WEBGL_compressed_texture_astc');
	    this.extParallelShaderCompile = getExtension('KHR_parallel_shader_compile');
	    this.extColorBufferHalfFloat = getExtension("EXT_color_buffer_half_float");
	  };

	  _proto.initializeCapabilities = function initializeCapabilities() {
	    var gl = this.gl;
	    var ext;
	    var userAgent = typeof navigator !== 'undefined' ? navigator.userAgent : "";
	    this.maxPrecision = this.precision = this.getPrecision();
	    var contextAttribs = gl.getContextAttributes();
	    this.supportsMsaa = contextAttribs.antialias;
	    this.supportsStencil = contextAttribs.stencil;
	    this.supportsInstancing = !!this.extInstancing;
	    this.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
	    this.maxCubeMapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
	    this.maxRenderBufferSize = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);
	    this.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
	    this.maxCombinedTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
	    this.maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
	    this.vertexUniformsCount = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
	    this.fragmentUniformsCount = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);

	    if (this.webgl2) {
	      this.maxDrawBuffers = gl.getParameter(gl.MAX_DRAW_BUFFERS);
	      this.maxColorAttachments = gl.getParameter(gl.MAX_COLOR_ATTACHMENTS);
	      this.maxVolumeSize = gl.getParameter(gl.MAX_3D_TEXTURE_SIZE);
	    } else {
	      ext = this.extDrawBuffers;
	      this.maxDrawBuffers = ext ? gl.getParameter(ext.MAX_DRAW_BUFFERS_EXT) : 1;
	      this.maxColorAttachments = ext ? gl.getParameter(ext.MAX_COLOR_ATTACHMENTS_EXT) : 1;
	      this.maxVolumeSize = 1;
	    }

	    ext = this.extDebugRendererInfo;
	    this.unmaskedRenderer = ext ? gl.getParameter(ext.UNMASKED_RENDERER_WEBGL) : '';
	    this.unmaskedVendor = ext ? gl.getParameter(ext.UNMASKED_VENDOR_WEBGL) : '';
	    var samsungModelRegex = /SM-[a-zA-Z0-9]+/;
	    this.supportsGpuParticles = !(this.unmaskedVendor === 'ARM' && userAgent.match(samsungModelRegex));
	    ext = this.extTextureFilterAnisotropic;
	    this.maxAnisotropy = ext ? gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1;
	    this.samples = gl.getParameter(gl.SAMPLES);
	    this.maxSamples = this.webgl2 && !this.forceDisableMultisampling ? gl.getParameter(gl.MAX_SAMPLES) : 1;
	    this.supportsAreaLights = this.webgl2 || !platform.android;

	    if (this.maxTextures <= 8) {
	      this.supportsAreaLights = false;
	    }
	  };

	  _proto.initializeRenderState = function initializeRenderState() {
	    var gl = this.gl;
	    this.blending = false;
	    gl.disable(gl.BLEND);
	    this.blendSrc = BLENDMODE_ONE;
	    this.blendDst = BLENDMODE_ZERO;
	    this.blendSrcAlpha = BLENDMODE_ONE;
	    this.blendDstAlpha = BLENDMODE_ZERO;
	    this.separateAlphaBlend = false;
	    this.blendEquation = BLENDEQUATION_ADD;
	    this.blendAlphaEquation = BLENDEQUATION_ADD;
	    this.separateAlphaEquation = false;
	    gl.blendFunc(gl.ONE, gl.ZERO);
	    gl.blendEquation(gl.FUNC_ADD);
	    this.blendColor = new Color(0, 0, 0, 0);
	    gl.blendColor(0, 0, 0, 0);
	    this.writeRed = true;
	    this.writeGreen = true;
	    this.writeBlue = true;
	    this.writeAlpha = true;
	    gl.colorMask(true, true, true, true);
	    this.cullMode = CULLFACE_BACK;
	    gl.enable(gl.CULL_FACE);
	    gl.cullFace(gl.BACK);
	    this.depthTest = true;
	    gl.enable(gl.DEPTH_TEST);
	    this.depthFunc = FUNC_LESSEQUAL;
	    gl.depthFunc(gl.LEQUAL);
	    this.depthWrite = true;
	    gl.depthMask(true);
	    this.stencil = false;
	    gl.disable(gl.STENCIL_TEST);
	    this.stencilFuncFront = this.stencilFuncBack = FUNC_ALWAYS;
	    this.stencilRefFront = this.stencilRefBack = 0;
	    this.stencilMaskFront = this.stencilMaskBack = 0xFF;
	    gl.stencilFunc(gl.ALWAYS, 0, 0xFF);
	    this.stencilFailFront = this.stencilFailBack = STENCILOP_KEEP;
	    this.stencilZfailFront = this.stencilZfailBack = STENCILOP_KEEP;
	    this.stencilZpassFront = this.stencilZpassBack = STENCILOP_KEEP;
	    this.stencilWriteMaskFront = 0xFF;
	    this.stencilWriteMaskBack = 0xFF;
	    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
	    gl.stencilMask(0xFF);
	    this.alphaToCoverage = false;
	    this.raster = true;

	    if (this.webgl2) {
	      gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
	      gl.disable(gl.RASTERIZER_DISCARD);
	    }

	    this.depthBiasEnabled = false;
	    gl.disable(gl.POLYGON_OFFSET_FILL);
	    this.clearDepth = 1;
	    gl.clearDepth(1);
	    this.clearColor = new Color(0, 0, 0, 0);
	    gl.clearColor(0, 0, 0, 0);
	    this.clearStencil = 0;
	    gl.clearStencil(0);
	    this.vx = this.vy = this.vw = this.vh = 0;
	    this.sx = this.sy = this.sw = this.sh = 0;

	    if (this.webgl2) {
	      gl.hint(gl.FRAGMENT_SHADER_DERIVATIVE_HINT, gl.NICEST);
	    } else {
	      if (this.extStandardDerivatives) {
	        gl.hint(this.extStandardDerivatives.FRAGMENT_SHADER_DERIVATIVE_HINT_OES, gl.NICEST);
	      }
	    }

	    gl.enable(gl.SCISSOR_TEST);
	    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
	    this.unpackFlipY = false;
	    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
	    this.unpackPremultiplyAlpha = false;
	    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
	    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
	  };

	  _proto.initializeContextCaches = function initializeContextCaches() {
	    _GraphicsDevice.prototype.initializeContextCaches.call(this);

	    this.vertexShaderCache = {};
	    this.fragmentShaderCache = {};
	    this._vaoMap = new Map();
	    this.boundVao = null;
	    this.activeFramebuffer = null;
	    this.feedback = null;
	    this.transformFeedbackBuffer = null;
	    this.textureUnit = 0;
	    this.textureUnits = [];

	    for (var i = 0; i < this.maxCombinedTextures; i++) {
	      this.textureUnits.push([null, null, null]);
	    }
	  };

	  _proto.loseContext = function loseContext() {
	    for (var _iterator = _createForOfIteratorHelperLoose(this.shaders), _step; !(_step = _iterator()).done;) {
	      var shader = _step.value;
	      shader.loseContext();
	    }

	    for (var _iterator2 = _createForOfIteratorHelperLoose(this.textures), _step2; !(_step2 = _iterator2()).done;) {
	      var texture = _step2.value;
	      texture.loseContext();
	    }

	    for (var _iterator3 = _createForOfIteratorHelperLoose(this.buffers), _step3; !(_step3 = _iterator3()).done;) {
	      var buffer = _step3.value;
	      buffer.loseContext();
	    }

	    for (var _iterator4 = _createForOfIteratorHelperLoose(this.targets), _step4; !(_step4 = _iterator4()).done;) {
	      var target = _step4.value;
	      target.loseContext();
	    }
	  };

	  _proto.restoreContext = function restoreContext() {
	    this.initializeExtensions();
	    this.initializeCapabilities();
	    this.initializeRenderState();
	    this.initializeContextCaches();

	    for (var _iterator5 = _createForOfIteratorHelperLoose(this.shaders), _step5; !(_step5 = _iterator5()).done;) {
	      var shader = _step5.value;
	      shader.restoreContext();
	    }

	    for (var _iterator6 = _createForOfIteratorHelperLoose(this.buffers), _step6; !(_step6 = _iterator6()).done;) {
	      var buffer = _step6.value;
	      buffer.unlock();
	    }
	  };

	  _proto.setViewport = function setViewport(x, y, w, h) {
	    if (this.vx !== x || this.vy !== y || this.vw !== w || this.vh !== h) {
	      this.gl.viewport(x, y, w, h);
	      this.vx = x;
	      this.vy = y;
	      this.vw = w;
	      this.vh = h;
	    }
	  };

	  _proto.setScissor = function setScissor(x, y, w, h) {
	    if (this.sx !== x || this.sy !== y || this.sw !== w || this.sh !== h) {
	      this.gl.scissor(x, y, w, h);
	      this.sx = x;
	      this.sy = y;
	      this.sw = w;
	      this.sh = h;
	    }
	  };

	  _proto.setFramebuffer = function setFramebuffer(fb) {
	    if (this.activeFramebuffer !== fb) {
	      var gl = this.gl;
	      gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
	      this.activeFramebuffer = fb;
	    }
	  };

	  _proto.copyRenderTarget = function copyRenderTarget(source, dest, color, depth) {
	    var gl = this.gl;

	    if (!this.webgl2 && depth) {
	      return false;
	    }

	    if (color) {
	      if (!dest) {
	        if (!source._colorBuffer) {
	          return false;
	        }
	      } else if (source) {
	        if (!source._colorBuffer || !dest._colorBuffer) {
	          return false;
	        }

	        if (source._colorBuffer._format !== dest._colorBuffer._format) {
	          return false;
	        }
	      }
	    }

	    if (depth && source) {
	      if (!source._depth) {
	        if (!source._depthBuffer || !dest._depthBuffer) {
	          return false;
	        }

	        if (source._depthBuffer._format !== dest._depthBuffer._format) {
	          return false;
	        }
	      }
	    }

	    if (this.webgl2 && dest) {
	      var prevRt = this.renderTarget;
	      this.renderTarget = dest;
	      this.updateBegin();
	      gl.bindFramebuffer(gl.READ_FRAMEBUFFER, source ? source.impl._glFrameBuffer : null);
	      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, dest.impl._glFrameBuffer);
	      var w = source ? source.width : dest.width;
	      var h = source ? source.height : dest.height;
	      gl.blitFramebuffer(0, 0, w, h, 0, 0, w, h, (color ? gl.COLOR_BUFFER_BIT : 0) | (depth ? gl.DEPTH_BUFFER_BIT : 0), gl.NEAREST);
	      this.renderTarget = prevRt;
	      gl.bindFramebuffer(gl.FRAMEBUFFER, prevRt ? prevRt.impl._glFrameBuffer : null);
	    } else {
	      var shader = this.getCopyShader();
	      this.constantTexSource.setValue(source._colorBuffer);
	      drawQuadWithShader(this, dest, shader);
	    }

	    return true;
	  };

	  _proto.getCopyShader = function getCopyShader() {
	    if (!this._copyShader) {
	      var vs = shaderChunks.fullscreenQuadVS;
	      var fs = shaderChunks.outputTex2DPS;
	      this._copyShader = createShaderFromCode(this, vs, fs, "outputTex2D");
	    }

	    return this._copyShader;
	  };

	  _proto.startPass = function startPass(renderPass) {
	    this.setRenderTarget(renderPass.renderTarget);
	    this.updateBegin();
	    var colorOps = renderPass.colorOps;
	    var depthStencilOps = renderPass.depthStencilOps;

	    if (colorOps.clear || depthStencilOps.clearDepth || depthStencilOps.clearStencil) {
	      var rt = renderPass.renderTarget;
	      var width = rt ? rt.width : this.width;
	      var height = rt ? rt.height : this.height;
	      this.setViewport(0, 0, width, height);
	      this.setScissor(0, 0, width, height);
	      var clearFlags = 0;
	      var clearOptions = {};

	      if (colorOps.clear) {
	        clearFlags |= CLEARFLAG_COLOR;
	        clearOptions.color = [colorOps.clearValue.r, colorOps.clearValue.g, colorOps.clearValue.b, colorOps.clearValue.a];
	      }

	      if (depthStencilOps.clearDepth) {
	        clearFlags |= CLEARFLAG_DEPTH;
	        clearOptions.depth = depthStencilOps.clearDepthValue;
	      }

	      if (depthStencilOps.clearStencil) {
	        clearFlags |= CLEARFLAG_STENCIL;
	        clearOptions.stencil = depthStencilOps.clearStencilValue;
	      }

	      clearOptions.flags = clearFlags;
	      this.clear(clearOptions);
	    }

	    this.insideRenderPass = true;
	  };

	  _proto.endPass = function endPass(renderPass) {
	    this.unbindVertexArray();
	    var target = this.renderTarget;

	    if (target) {
	      if (this.webgl2) {
	        invalidateAttachments.length = 0;
	        var gl = this.gl;

	        if (!(renderPass.colorOps.store || renderPass.colorOps.resolve)) {
	          invalidateAttachments.push(gl.COLOR_ATTACHMENT0);
	        }

	        if (!renderPass.depthStencilOps.storeDepth) {
	          invalidateAttachments.push(gl.DEPTH_ATTACHMENT);
	        }

	        if (!renderPass.depthStencilOps.storeStencil) {
	          invalidateAttachments.push(gl.STENCIL_ATTACHMENT);
	        }

	        if (invalidateAttachments.length > 0) {
	          if (renderPass.fullSizeClearRect) {
	            gl.invalidateFramebuffer(gl.DRAW_FRAMEBUFFER, invalidateAttachments);
	          }
	        }
	      }

	      if (renderPass.colorOps.resolve) {
	        if (this.webgl2 && renderPass.samples > 1 && target.autoResolve) {
	          target.resolve(true, false);
	        }
	      }

	      if (renderPass.colorOps.mipmaps) {
	        var colorBuffer = target._colorBuffer;

	        if (colorBuffer && colorBuffer.impl._glTexture && colorBuffer.mipmaps && (colorBuffer.pot || this.webgl2)) {
	          this.activeTexture(this.maxCombinedTextures - 1);
	          this.bindTexture(colorBuffer);
	          this.gl.generateMipmap(colorBuffer.impl._glTarget);
	        }
	      }
	    }

	    this.insideRenderPass = false;
	  };

	  _proto.updateBegin = function updateBegin() {
	    this.boundVao = null;

	    if (this._tempEnableSafariTextureUnitWorkaround) {
	      for (var unit = 0; unit < this.textureUnits.length; ++unit) {
	        for (var slot = 0; slot < 3; ++slot) {
	          this.textureUnits[unit][slot] = null;
	        }
	      }
	    }

	    var target = this.renderTarget;

	    if (target) {
	      if (!target.impl.initialized) {
	        this.initRenderTarget(target);
	      } else {
	        this.setFramebuffer(target.impl._glFrameBuffer);
	      }
	    } else {
	      this.setFramebuffer(this.defaultFramebuffer);
	    }
	  };

	  _proto.updateEnd = function updateEnd() {
	    this.unbindVertexArray();
	    var target = this.renderTarget;

	    if (target) {
	      var colorBuffer = target._colorBuffer;

	      if (colorBuffer && colorBuffer.impl._glTexture && colorBuffer.mipmaps && (colorBuffer.pot || this.webgl2)) {
	        this.activeTexture(this.maxCombinedTextures - 1);
	        this.bindTexture(colorBuffer);
	        this.gl.generateMipmap(colorBuffer.impl._glTarget);
	      }

	      if (this.webgl2 && target._samples > 1 && target.autoResolve) {
	        target.resolve();
	      }
	    }
	  };

	  _proto.setUnpackFlipY = function setUnpackFlipY(flipY) {
	    if (this.unpackFlipY !== flipY) {
	      this.unpackFlipY = flipY;
	      var gl = this.gl;
	      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
	    }
	  };

	  _proto.setUnpackPremultiplyAlpha = function setUnpackPremultiplyAlpha(premultiplyAlpha) {
	    if (this.unpackPremultiplyAlpha !== premultiplyAlpha) {
	      this.unpackPremultiplyAlpha = premultiplyAlpha;
	      var gl = this.gl;
	      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiplyAlpha);
	    }
	  };

	  _proto.activeTexture = function activeTexture(textureUnit) {
	    if (this.textureUnit !== textureUnit) {
	      this.gl.activeTexture(this.gl.TEXTURE0 + textureUnit);
	      this.textureUnit = textureUnit;
	    }
	  };

	  _proto.bindTexture = function bindTexture(texture) {
	    var impl = texture.impl;
	    var textureTarget = impl._glTarget;
	    var textureObject = impl._glTexture;
	    var textureUnit = this.textureUnit;
	    var slot = this.targetToSlot[textureTarget];

	    if (this.textureUnits[textureUnit][slot] !== textureObject) {
	      this.gl.bindTexture(textureTarget, textureObject);
	      this.textureUnits[textureUnit][slot] = textureObject;
	    }
	  };

	  _proto.bindTextureOnUnit = function bindTextureOnUnit(texture, textureUnit) {
	    var impl = texture.impl;
	    var textureTarget = impl._glTarget;
	    var textureObject = impl._glTexture;
	    var slot = this.targetToSlot[textureTarget];

	    if (this.textureUnits[textureUnit][slot] !== textureObject) {
	      this.activeTexture(textureUnit);
	      this.gl.bindTexture(textureTarget, textureObject);
	      this.textureUnits[textureUnit][slot] = textureObject;
	    }
	  };

	  _proto.setTextureParameters = function setTextureParameters(texture) {
	    var gl = this.gl;
	    var flags = texture._parameterFlags;
	    var target = texture.impl._glTarget;

	    if (flags & 1) {
	      var filter = texture._minFilter;

	      if (!texture.pot && !this.webgl2 || !texture._mipmaps || texture._compressed && texture._levels.length === 1) {
	        if (filter === FILTER_NEAREST_MIPMAP_NEAREST || filter === FILTER_NEAREST_MIPMAP_LINEAR) {
	          filter = FILTER_NEAREST;
	        } else if (filter === FILTER_LINEAR_MIPMAP_NEAREST || filter === FILTER_LINEAR_MIPMAP_LINEAR) {
	          filter = FILTER_LINEAR;
	        }
	      }

	      gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, this.glFilter[filter]);
	    }

	    if (flags & 2) {
	      gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, this.glFilter[texture._magFilter]);
	    }

	    if (flags & 4) {
	      if (this.webgl2) {
	        gl.texParameteri(target, gl.TEXTURE_WRAP_S, this.glAddress[texture._addressU]);
	      } else {
	        gl.texParameteri(target, gl.TEXTURE_WRAP_S, this.glAddress[texture.pot ? texture._addressU : ADDRESS_CLAMP_TO_EDGE]);
	      }
	    }

	    if (flags & 8) {
	      if (this.webgl2) {
	        gl.texParameteri(target, gl.TEXTURE_WRAP_T, this.glAddress[texture._addressV]);
	      } else {
	        gl.texParameteri(target, gl.TEXTURE_WRAP_T, this.glAddress[texture.pot ? texture._addressV : ADDRESS_CLAMP_TO_EDGE]);
	      }
	    }

	    if (flags & 16) {
	      if (this.webgl2) {
	        gl.texParameteri(target, gl.TEXTURE_WRAP_R, this.glAddress[texture._addressW]);
	      }
	    }

	    if (flags & 32) {
	      if (this.webgl2) {
	        gl.texParameteri(target, gl.TEXTURE_COMPARE_MODE, texture._compareOnRead ? gl.COMPARE_REF_TO_TEXTURE : gl.NONE);
	      }
	    }

	    if (flags & 64) {
	      if (this.webgl2) {
	        gl.texParameteri(target, gl.TEXTURE_COMPARE_FUNC, this.glComparison[texture._compareFunc]);
	      }
	    }

	    if (flags & 128) {
	      var ext = this.extTextureFilterAnisotropic;

	      if (ext) {
	        gl.texParameterf(target, ext.TEXTURE_MAX_ANISOTROPY_EXT, Math.max(1, Math.min(Math.round(texture._anisotropy), this.maxAnisotropy)));
	      }
	    }
	  };

	  _proto.setTexture = function setTexture(texture, textureUnit) {
	    if (!texture.impl._glTexture) texture.impl.initialize(this, texture);

	    if (texture._parameterFlags > 0 || texture._needsUpload || texture._needsMipmapsUpload) {
	      this.activeTexture(textureUnit);
	      this.bindTexture(texture);

	      if (texture._parameterFlags) {
	        this.setTextureParameters(texture);
	        texture._parameterFlags = 0;
	      }

	      if (texture._needsUpload || texture._needsMipmapsUpload) {
	        texture.impl.upload(this, texture);
	        texture._needsUpload = false;
	        texture._needsMipmapsUpload = false;
	      }
	    } else {
	      this.bindTextureOnUnit(texture, textureUnit);
	    }
	  };

	  _proto.createVertexArray = function createVertexArray(vertexBuffers) {
	    var key, vao;
	    var useCache = vertexBuffers.length > 1;

	    if (useCache) {
	      key = "";

	      for (var i = 0; i < vertexBuffers.length; i++) {
	        var vertexBuffer = vertexBuffers[i];
	        key += vertexBuffer.id + vertexBuffer.format.renderingingHash;
	      }

	      vao = this._vaoMap.get(key);
	    }

	    if (!vao) {
	      var gl = this.gl;
	      vao = gl.createVertexArray();
	      gl.bindVertexArray(vao);
	      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

	      for (var _i = 0; _i < vertexBuffers.length; _i++) {
	        var _vertexBuffer = vertexBuffers[_i];
	        gl.bindBuffer(gl.ARRAY_BUFFER, _vertexBuffer.impl.bufferId);
	        var elements = _vertexBuffer.format.elements;

	        for (var j = 0; j < elements.length; j++) {
	          var e = elements[j];
	          var loc = semanticToLocation[e.name];

	          gl.vertexAttribPointer(loc, e.numComponents, this.glType[e.dataType], e.normalize, e.stride, e.offset);
	          gl.enableVertexAttribArray(loc);

	          if (_vertexBuffer.instancing) {
	            gl.vertexAttribDivisor(loc, 1);
	          }
	        }
	      }

	      gl.bindVertexArray(null);
	      gl.bindBuffer(gl.ARRAY_BUFFER, null);

	      if (useCache) {
	        this._vaoMap.set(key, vao);
	      }
	    }

	    return vao;
	  };

	  _proto.unbindVertexArray = function unbindVertexArray() {
	    if (this.boundVao) {
	      this.boundVao = null;
	      this.gl.bindVertexArray(null);
	    }
	  };

	  _proto.setBuffers = function setBuffers() {
	    var gl = this.gl;
	    var vao;

	    if (this.vertexBuffers.length === 1) {
	      var vertexBuffer = this.vertexBuffers[0];

	      if (!vertexBuffer.impl.vao) {
	        vertexBuffer.impl.vao = this.createVertexArray(this.vertexBuffers);
	      }

	      vao = vertexBuffer.impl.vao;
	    } else {
	      vao = this.createVertexArray(this.vertexBuffers);
	    }

	    if (this.boundVao !== vao) {
	      this.boundVao = vao;
	      gl.bindVertexArray(vao);
	    }

	    this.vertexBuffers.length = 0;
	    var bufferId = this.indexBuffer ? this.indexBuffer.impl.bufferId : null;
	    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufferId);
	  };

	  _proto.draw = function draw(primitive, numInstances, keepBuffers) {
	    var gl = this.gl;
	    var sampler, samplerValue, texture, numTextures;
	    var uniform, scopeId, uniformVersion, programVersion;
	    var shader = this.shader;
	    if (!shader) return;
	    var samplers = shader.impl.samplers;
	    var uniforms = shader.impl.uniforms;

	    if (!keepBuffers) {
	      this.setBuffers();
	    }

	    var textureUnit = 0;

	    for (var i = 0, len = samplers.length; i < len; i++) {
	      sampler = samplers[i];
	      samplerValue = sampler.scopeId.value;

	      if (!samplerValue) {
	        continue;
	      }

	      if (samplerValue instanceof Texture) {
	        texture = samplerValue;
	        this.setTexture(texture, textureUnit);

	        if (sampler.slot !== textureUnit) {
	          gl.uniform1i(sampler.locationId, textureUnit);
	          sampler.slot = textureUnit;
	        }

	        textureUnit++;
	      } else {
	        sampler.array.length = 0;
	        numTextures = samplerValue.length;

	        for (var j = 0; j < numTextures; j++) {
	          texture = samplerValue[j];
	          this.setTexture(texture, textureUnit);
	          sampler.array[j] = textureUnit;
	          textureUnit++;
	        }

	        gl.uniform1iv(sampler.locationId, sampler.array);
	      }
	    }

	    for (var _i2 = 0, _len = uniforms.length; _i2 < _len; _i2++) {
	      uniform = uniforms[_i2];
	      scopeId = uniform.scopeId;
	      uniformVersion = uniform.version;
	      programVersion = scopeId.versionObject.version;

	      if (uniformVersion.globalId !== programVersion.globalId || uniformVersion.revision !== programVersion.revision) {
	        uniformVersion.globalId = programVersion.globalId;
	        uniformVersion.revision = programVersion.revision;

	        if (scopeId.value !== null) {
	          this.commitFunction[uniform.dataType](uniform, scopeId.value);
	        }
	      }
	    }

	    if (this.webgl2 && this.transformFeedbackBuffer) {
	      gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, this.transformFeedbackBuffer.impl.bufferId);
	      gl.beginTransformFeedback(gl.POINTS);
	    }

	    var mode = this.glPrimitive[primitive.type];
	    var count = primitive.count;

	    if (primitive.indexed) {
	      var indexBuffer = this.indexBuffer;
	      var format = indexBuffer.impl.glFormat;
	      var offset = primitive.base * indexBuffer.bytesPerIndex;

	      if (numInstances > 0) {
	        gl.drawElementsInstanced(mode, count, format, offset, numInstances);
	      } else {
	        gl.drawElements(mode, count, format, offset);
	      }
	    } else {
	      var first = primitive.base;

	      if (numInstances > 0) {
	        gl.drawArraysInstanced(mode, first, count, numInstances);
	      } else {
	        gl.drawArrays(mode, first, count);
	      }
	    }

	    if (this.webgl2 && this.transformFeedbackBuffer) {
	      gl.endTransformFeedback();
	      gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, null);
	    }

	    this._drawCallsPerFrame++;
	  };

	  _proto.clear = function clear(options) {
	    var defaultOptions = this.defaultClearOptions;
	    options = options || defaultOptions;
	    var flags = options.flags === undefined ? defaultOptions.flags : options.flags;

	    if (flags !== 0) {
	      var gl = this.gl;

	      if (flags & CLEARFLAG_COLOR) {
	        var color = options.color === undefined ? defaultOptions.color : options.color;
	        this.setClearColor(color[0], color[1], color[2], color[3]);
	        this.setColorWrite(true, true, true, true);
	      }

	      if (flags & CLEARFLAG_DEPTH) {
	        var depth = options.depth === undefined ? defaultOptions.depth : options.depth;
	        this.setClearDepth(depth);
	        this.setDepthWrite(true);
	      }

	      if (flags & CLEARFLAG_STENCIL) {
	        var stencil = options.stencil === undefined ? defaultOptions.stencil : options.stencil;
	        this.setClearStencil(stencil);
	      }

	      gl.clear(this.glClearFlag[flags]);
	    }
	  };

	  _proto.readPixels = function readPixels(x, y, w, h, pixels) {
	    var gl = this.gl;
	    gl.readPixels(x, y, w, h, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
	  };

	  _proto.setClearDepth = function setClearDepth(depth) {
	    if (depth !== this.clearDepth) {
	      this.gl.clearDepth(depth);
	      this.clearDepth = depth;
	    }
	  };

	  _proto.setClearColor = function setClearColor(r, g, b, a) {
	    var c = this.clearColor;

	    if (r !== c.r || g !== c.g || b !== c.b || a !== c.a) {
	      this.gl.clearColor(r, g, b, a);
	      this.clearColor.set(r, g, b, a);
	    }
	  };

	  _proto.setClearStencil = function setClearStencil(value) {
	    if (value !== this.clearStencil) {
	      this.gl.clearStencil(value);
	      this.clearStencil = value;
	    }
	  };

	  _proto.getDepthTest = function getDepthTest() {
	    return this.depthTest;
	  };

	  _proto.setDepthTest = function setDepthTest(depthTest) {
	    if (this.depthTest !== depthTest) {
	      var gl = this.gl;

	      if (depthTest) {
	        gl.enable(gl.DEPTH_TEST);
	      } else {
	        gl.disable(gl.DEPTH_TEST);
	      }

	      this.depthTest = depthTest;
	    }
	  };

	  _proto.setDepthFunc = function setDepthFunc(func) {
	    if (this.depthFunc === func) return;
	    this.gl.depthFunc(this.glComparison[func]);
	    this.depthFunc = func;
	  };

	  _proto.getDepthWrite = function getDepthWrite() {
	    return this.depthWrite;
	  };

	  _proto.setDepthWrite = function setDepthWrite(writeDepth) {
	    if (this.depthWrite !== writeDepth) {
	      this.gl.depthMask(writeDepth);
	      this.depthWrite = writeDepth;
	    }
	  };

	  _proto.setColorWrite = function setColorWrite(writeRed, writeGreen, writeBlue, writeAlpha) {
	    if (this.writeRed !== writeRed || this.writeGreen !== writeGreen || this.writeBlue !== writeBlue || this.writeAlpha !== writeAlpha) {
	      this.gl.colorMask(writeRed, writeGreen, writeBlue, writeAlpha);
	      this.writeRed = writeRed;
	      this.writeGreen = writeGreen;
	      this.writeBlue = writeBlue;
	      this.writeAlpha = writeAlpha;
	    }
	  };

	  _proto.setAlphaToCoverage = function setAlphaToCoverage(state) {
	    if (!this.webgl2) return;
	    if (this.alphaToCoverage === state) return;
	    this.alphaToCoverage = state;

	    if (state) {
	      this.gl.enable(this.gl.SAMPLE_ALPHA_TO_COVERAGE);
	    } else {
	      this.gl.disable(this.gl.SAMPLE_ALPHA_TO_COVERAGE);
	    }
	  };

	  _proto.setTransformFeedbackBuffer = function setTransformFeedbackBuffer(tf) {
	    if (this.transformFeedbackBuffer === tf) return;
	    this.transformFeedbackBuffer = tf;

	    if (this.webgl2) {
	      var gl = this.gl;

	      if (tf) {
	        if (!this.feedback) {
	          this.feedback = gl.createTransformFeedback();
	        }

	        gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, this.feedback);
	      } else {
	        gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
	      }
	    }
	  };

	  _proto.setRaster = function setRaster(on) {
	    if (this.raster === on) return;
	    this.raster = on;

	    if (this.webgl2) {
	      if (on) {
	        this.gl.disable(this.gl.RASTERIZER_DISCARD);
	      } else {
	        this.gl.enable(this.gl.RASTERIZER_DISCARD);
	      }
	    }
	  };

	  _proto.setDepthBias = function setDepthBias(on) {
	    if (this.depthBiasEnabled === on) return;
	    this.depthBiasEnabled = on;

	    if (on) {
	      this.gl.enable(this.gl.POLYGON_OFFSET_FILL);
	    } else {
	      this.gl.disable(this.gl.POLYGON_OFFSET_FILL);
	    }
	  };

	  _proto.setDepthBiasValues = function setDepthBiasValues(constBias, slopeBias) {
	    this.gl.polygonOffset(slopeBias, constBias);
	  };

	  _proto.getBlending = function getBlending() {
	    return this.blending;
	  };

	  _proto.setBlending = function setBlending(blending) {
	    if (this.blending !== blending) {
	      var gl = this.gl;

	      if (blending) {
	        gl.enable(gl.BLEND);
	      } else {
	        gl.disable(gl.BLEND);
	      }

	      this.blending = blending;
	    }
	  };

	  _proto.setStencilTest = function setStencilTest(enable) {
	    if (this.stencil !== enable) {
	      var gl = this.gl;

	      if (enable) {
	        gl.enable(gl.STENCIL_TEST);
	      } else {
	        gl.disable(gl.STENCIL_TEST);
	      }

	      this.stencil = enable;
	    }
	  };

	  _proto.setStencilFunc = function setStencilFunc(func, ref, mask) {
	    if (this.stencilFuncFront !== func || this.stencilRefFront !== ref || this.stencilMaskFront !== mask || this.stencilFuncBack !== func || this.stencilRefBack !== ref || this.stencilMaskBack !== mask) {
	      var gl = this.gl;
	      gl.stencilFunc(this.glComparison[func], ref, mask);
	      this.stencilFuncFront = this.stencilFuncBack = func;
	      this.stencilRefFront = this.stencilRefBack = ref;
	      this.stencilMaskFront = this.stencilMaskBack = mask;
	    }
	  };

	  _proto.setStencilFuncFront = function setStencilFuncFront(func, ref, mask) {
	    if (this.stencilFuncFront !== func || this.stencilRefFront !== ref || this.stencilMaskFront !== mask) {
	      var gl = this.gl;
	      gl.stencilFuncSeparate(gl.FRONT, this.glComparison[func], ref, mask);
	      this.stencilFuncFront = func;
	      this.stencilRefFront = ref;
	      this.stencilMaskFront = mask;
	    }
	  };

	  _proto.setStencilFuncBack = function setStencilFuncBack(func, ref, mask) {
	    if (this.stencilFuncBack !== func || this.stencilRefBack !== ref || this.stencilMaskBack !== mask) {
	      var gl = this.gl;
	      gl.stencilFuncSeparate(gl.BACK, this.glComparison[func], ref, mask);
	      this.stencilFuncBack = func;
	      this.stencilRefBack = ref;
	      this.stencilMaskBack = mask;
	    }
	  };

	  _proto.setStencilOperation = function setStencilOperation(fail, zfail, zpass, writeMask) {
	    if (this.stencilFailFront !== fail || this.stencilZfailFront !== zfail || this.stencilZpassFront !== zpass || this.stencilFailBack !== fail || this.stencilZfailBack !== zfail || this.stencilZpassBack !== zpass) {
	      this.gl.stencilOp(this.glStencilOp[fail], this.glStencilOp[zfail], this.glStencilOp[zpass]);
	      this.stencilFailFront = this.stencilFailBack = fail;
	      this.stencilZfailFront = this.stencilZfailBack = zfail;
	      this.stencilZpassFront = this.stencilZpassBack = zpass;
	    }

	    if (this.stencilWriteMaskFront !== writeMask || this.stencilWriteMaskBack !== writeMask) {
	      this.gl.stencilMask(writeMask);
	      this.stencilWriteMaskFront = writeMask;
	      this.stencilWriteMaskBack = writeMask;
	    }
	  };

	  _proto.setStencilOperationFront = function setStencilOperationFront(fail, zfail, zpass, writeMask) {
	    if (this.stencilFailFront !== fail || this.stencilZfailFront !== zfail || this.stencilZpassFront !== zpass) {
	      this.gl.stencilOpSeparate(this.gl.FRONT, this.glStencilOp[fail], this.glStencilOp[zfail], this.glStencilOp[zpass]);
	      this.stencilFailFront = fail;
	      this.stencilZfailFront = zfail;
	      this.stencilZpassFront = zpass;
	    }

	    if (this.stencilWriteMaskFront !== writeMask) {
	      this.gl.stencilMaskSeparate(this.gl.FRONT, writeMask);
	      this.stencilWriteMaskFront = writeMask;
	    }
	  };

	  _proto.setStencilOperationBack = function setStencilOperationBack(fail, zfail, zpass, writeMask) {
	    if (this.stencilFailBack !== fail || this.stencilZfailBack !== zfail || this.stencilZpassBack !== zpass) {
	      this.gl.stencilOpSeparate(this.gl.BACK, this.glStencilOp[fail], this.glStencilOp[zfail], this.glStencilOp[zpass]);
	      this.stencilFailBack = fail;
	      this.stencilZfailBack = zfail;
	      this.stencilZpassBack = zpass;
	    }

	    if (this.stencilWriteMaskBack !== writeMask) {
	      this.gl.stencilMaskSeparate(this.gl.BACK, writeMask);
	      this.stencilWriteMaskBack = writeMask;
	    }
	  };

	  _proto.setBlendFunction = function setBlendFunction(blendSrc, blendDst) {
	    if (this.blendSrc !== blendSrc || this.blendDst !== blendDst || this.separateAlphaBlend) {
	      this.gl.blendFunc(this.glBlendFunction[blendSrc], this.glBlendFunction[blendDst]);
	      this.blendSrc = blendSrc;
	      this.blendDst = blendDst;
	      this.separateAlphaBlend = false;
	    }
	  };

	  _proto.setBlendFunctionSeparate = function setBlendFunctionSeparate(blendSrc, blendDst, blendSrcAlpha, blendDstAlpha) {
	    if (this.blendSrc !== blendSrc || this.blendDst !== blendDst || this.blendSrcAlpha !== blendSrcAlpha || this.blendDstAlpha !== blendDstAlpha || !this.separateAlphaBlend) {
	      this.gl.blendFuncSeparate(this.glBlendFunction[blendSrc], this.glBlendFunction[blendDst], this.glBlendFunction[blendSrcAlpha], this.glBlendFunction[blendDstAlpha]);
	      this.blendSrc = blendSrc;
	      this.blendDst = blendDst;
	      this.blendSrcAlpha = blendSrcAlpha;
	      this.blendDstAlpha = blendDstAlpha;
	      this.separateAlphaBlend = true;
	    }
	  };

	  _proto.setBlendEquation = function setBlendEquation(blendEquation) {
	    if (this.blendEquation !== blendEquation || this.separateAlphaEquation) {
	      this.gl.blendEquation(this.glBlendEquation[blendEquation]);
	      this.blendEquation = blendEquation;
	      this.separateAlphaEquation = false;
	    }
	  };

	  _proto.setBlendEquationSeparate = function setBlendEquationSeparate(blendEquation, blendAlphaEquation) {
	    if (this.blendEquation !== blendEquation || this.blendAlphaEquation !== blendAlphaEquation || !this.separateAlphaEquation) {
	      this.gl.blendEquationSeparate(this.glBlendEquation[blendEquation], this.glBlendEquation[blendAlphaEquation]);
	      this.blendEquation = blendEquation;
	      this.blendAlphaEquation = blendAlphaEquation;
	      this.separateAlphaEquation = true;
	    }
	  };

	  _proto.setBlendColor = function setBlendColor(r, g, b, a) {
	    var c = this.blendColor;

	    if (r !== c.r || g !== c.g || b !== c.b || a !== c.a) {
	      this.gl.blendColor(r, g, b, a);
	      c.set(r, g, b, a);
	    }
	  };

	  _proto.setCullMode = function setCullMode(cullMode) {
	    if (this.cullMode !== cullMode) {
	      if (cullMode === CULLFACE_NONE) {
	        this.gl.disable(this.gl.CULL_FACE);
	      } else {
	        if (this.cullMode === CULLFACE_NONE) {
	          this.gl.enable(this.gl.CULL_FACE);
	        }

	        var mode = this.glCull[cullMode];

	        if (this.cullFace !== mode) {
	          this.gl.cullFace(mode);
	          this.cullFace = mode;
	        }
	      }

	      this.cullMode = cullMode;
	    }
	  };

	  _proto.getCullMode = function getCullMode() {
	    return this.cullMode;
	  };

	  _proto.setShader = function setShader(shader) {
	    if (shader !== this.shader) {
	      if (shader.failed) {
	        return false;
	      } else if (!shader.ready && !shader.impl.postLink(this, shader)) {
	        shader.failed = true;
	        return false;
	      }

	      this.shader = shader;
	      this.gl.useProgram(shader.impl.glProgram);
	      this.attributesInvalidated = true;
	    }

	    return true;
	  };

	  _proto.getHdrFormat = function getHdrFormat() {
	    if (this.textureHalfFloatRenderable) {
	      return PIXELFORMAT_RGBA16F;
	    } else if (this.textureFloatRenderable) {
	      return PIXELFORMAT_RGBA32F;
	    }

	    return PIXELFORMAT_R8_G8_B8_A8;
	  };

	  _proto.clearShaderCache = function clearShaderCache() {
	    var gl = this.gl;

	    for (var shaderSrc in this.fragmentShaderCache) {
	      gl.deleteShader(this.fragmentShaderCache[shaderSrc]);
	      delete this.fragmentShaderCache[shaderSrc];
	    }

	    for (var _shaderSrc in this.vertexShaderCache) {
	      gl.deleteShader(this.vertexShaderCache[_shaderSrc]);
	      delete this.vertexShaderCache[_shaderSrc];
	    }

	    this.programLib.clearCache();
	  };

	  _proto.clearVertexArrayObjectCache = function clearVertexArrayObjectCache() {
	    var gl = this.gl;

	    this._vaoMap.forEach(function (item, key, mapObj) {
	      gl.deleteVertexArray(item);
	    });

	    this._vaoMap.clear();
	  };

	  _proto.removeShaderFromCache = function removeShaderFromCache(shader) {
	    this.programLib.removeFromCache(shader);
	  };

	  _createClass(WebglGraphicsDevice, [{
	    key: "width",
	    get: function get() {
	      return this.gl.drawingBufferWidth || this.canvas.width;
	    }
	  }, {
	    key: "height",
	    get: function get() {
	      return this.gl.drawingBufferHeight || this.canvas.height;
	    }
	  }, {
	    key: "fullscreen",
	    get: function get() {
	      return !!document.fullscreenElement;
	    },
	    set: function set(fullscreen) {
	      if (fullscreen) {
	        var canvas = this.gl.canvas;
	        canvas.requestFullscreen();
	      } else {
	        document.exitFullscreen();
	      }
	    }
	  }, {
	    key: "textureFloatHighPrecision",
	    get: function get() {
	      if (this._textureFloatHighPrecision === undefined) {
	        this._textureFloatHighPrecision = testTextureFloatHighPrecision(this);
	      }

	      return this._textureFloatHighPrecision;
	    }
	  }, {
	    key: "textureHalfFloatUpdatable",
	    get: function get() {
	      if (this._textureHalfFloatUpdatable === undefined) {
	        if (this.webgl2) {
	          this._textureHalfFloatUpdatable = true;
	        } else {
	          this._textureHalfFloatUpdatable = testTextureHalfFloatUpdatable(this.gl, this.extTextureHalfFloat.HALF_FLOAT_OES);
	        }
	      }

	      return this._textureHalfFloatUpdatable;
	    }
	  }]);

	  return WebglGraphicsDevice;
	}(GraphicsDevice);

	var RefCountedObject = function () {
	  function RefCountedObject() {
	    this._refCount = 0;
	  }

	  var _proto = RefCountedObject.prototype;

	  _proto.incRefCount = function incRefCount() {
	    this._refCount++;
	  };

	  _proto.decRefCount = function decRefCount() {
	    this._refCount--;
	  };

	  _createClass(RefCountedObject, [{
	    key: "refCount",
	    get: function get() {
	      return this._refCount;
	    }
	  }]);

	  return RefCountedObject;
	}();

	var currentApplication;

	function getApplication() {
	  return currentApplication;
	}

	function setApplication(app) {
	  currentApplication = app;
	}

	var id$1 = 0;

	var GeometryData = function () {
	  function GeometryData() {
	    this.initDefaults();
	  }

	  var _proto = GeometryData.prototype;

	  _proto.initDefaults = function initDefaults() {
	    this.recreate = false;
	    this.verticesUsage = BUFFER_STATIC;
	    this.indicesUsage = BUFFER_STATIC;
	    this.maxVertices = 0;
	    this.maxIndices = 0;
	    this.vertexCount = 0;
	    this.indexCount = 0;
	    this.vertexStreamsUpdated = false;
	    this.indexStreamUpdated = false;
	    this.vertexStreamDictionary = {};
	    this.indices = null;
	  };

	  _proto._changeVertexCount = function _changeVertexCount(count, semantic) {
	    if (!this.vertexCount) {
	      this.vertexCount = count;
	    }
	  };

	  return GeometryData;
	}();

	GeometryData.DEFAULT_COMPONENTS_POSITION = 3;
	GeometryData.DEFAULT_COMPONENTS_NORMAL = 3;
	GeometryData.DEFAULT_COMPONENTS_UV = 2;
	GeometryData.DEFAULT_COMPONENTS_COLORS = 4;

	var GeometryVertexStream = function GeometryVertexStream(data, componentCount, dataType, dataTypeNormalize) {
	  this.data = data;
	  this.componentCount = componentCount;
	  this.dataType = dataType;
	  this.dataTypeNormalize = dataTypeNormalize;
	};

	var Mesh = function (_RefCountedObject) {
	  _inheritsLoose(Mesh, _RefCountedObject);

	  function Mesh(graphicsDevice) {
	    var _this;

	    _this = _RefCountedObject.call(this) || this;
	    _this.id = id$1++;
	    _this.device = graphicsDevice || getApplication().graphicsDevice;
	    _this.vertexBuffer = null;
	    _this.indexBuffer = [null];
	    _this.primitive = [{
	      type: 0,
	      base: 0,
	      count: 0
	    }];
	    _this.skin = null;
	    _this._morph = null;
	    _this._geometryData = null;
	    _this._aabb = new BoundingBox();
	    _this.boneAabb = null;
	    return _this;
	  }

	  var _proto2 = Mesh.prototype;

	  _proto2.destroy = function destroy() {
	    var morph = this.morph;

	    if (morph) {
	      this.morph = null;

	      if (morph.refCount < 1) {
	        morph.destroy();
	      }
	    }

	    if (this.vertexBuffer) {
	      this.vertexBuffer.destroy();
	      this.vertexBuffer = null;
	    }

	    for (var j = 0; j < this.indexBuffer.length; j++) {
	      this._destroyIndexBuffer(j);
	    }

	    this.indexBuffer.length = 0;
	    this._geometryData = null;
	  };

	  _proto2._destroyIndexBuffer = function _destroyIndexBuffer(index) {
	    if (this.indexBuffer[index]) {
	      this.indexBuffer[index].destroy();
	      this.indexBuffer[index] = null;
	    }
	  };

	  _proto2._initBoneAabbs = function _initBoneAabbs(morphTargets) {
	    this.boneAabb = [];
	    this.boneUsed = [];
	    var x, y, z;
	    var bMax, bMin;
	    var boneMin = [];
	    var boneMax = [];
	    var boneUsed = this.boneUsed;
	    var numBones = this.skin.boneNames.length;
	    var maxMorphX, maxMorphY, maxMorphZ;

	    for (var i = 0; i < numBones; i++) {
	      boneMin[i] = new Vec3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
	      boneMax[i] = new Vec3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
	    }

	    var iterator = new VertexIterator(this.vertexBuffer);
	    var posElement = iterator.element[SEMANTIC_POSITION];
	    var weightsElement = iterator.element[SEMANTIC_BLENDWEIGHT];
	    var indicesElement = iterator.element[SEMANTIC_BLENDINDICES];
	    var numVerts = this.vertexBuffer.numVertices;

	    for (var j = 0; j < numVerts; j++) {
	      for (var k = 0; k < 4; k++) {
	        var boneWeight = weightsElement.array[weightsElement.index + k];

	        if (boneWeight > 0) {
	          var boneIndex = indicesElement.array[indicesElement.index + k];
	          boneUsed[boneIndex] = true;
	          x = posElement.array[posElement.index];
	          y = posElement.array[posElement.index + 1];
	          z = posElement.array[posElement.index + 2];
	          bMax = boneMax[boneIndex];
	          bMin = boneMin[boneIndex];
	          if (bMin.x > x) bMin.x = x;
	          if (bMin.y > y) bMin.y = y;
	          if (bMin.z > z) bMin.z = z;
	          if (bMax.x < x) bMax.x = x;
	          if (bMax.y < y) bMax.y = y;
	          if (bMax.z < z) bMax.z = z;

	          if (morphTargets) {
	            var minMorphX = maxMorphX = x;
	            var minMorphY = maxMorphY = y;
	            var minMorphZ = maxMorphZ = z;

	            for (var l = 0; l < morphTargets.length; l++) {
	              var target = morphTargets[l];
	              var dx = target.deltaPositions[j * 3];
	              var dy = target.deltaPositions[j * 3 + 1];
	              var dz = target.deltaPositions[j * 3 + 2];

	              if (dx < 0) {
	                minMorphX += dx;
	              } else {
	                maxMorphX += dx;
	              }

	              if (dy < 0) {
	                minMorphY += dy;
	              } else {
	                maxMorphY += dy;
	              }

	              if (dz < 0) {
	                minMorphZ += dz;
	              } else {
	                maxMorphZ += dz;
	              }
	            }

	            if (bMin.x > minMorphX) bMin.x = minMorphX;
	            if (bMin.y > minMorphY) bMin.y = minMorphY;
	            if (bMin.z > minMorphZ) bMin.z = minMorphZ;
	            if (bMax.x < maxMorphX) bMax.x = maxMorphX;
	            if (bMax.y < maxMorphY) bMax.y = maxMorphY;
	            if (bMax.z < maxMorphZ) bMax.z = maxMorphZ;
	          }
	        }
	      }

	      iterator.next();
	    }

	    var positionElement = this.vertexBuffer.getFormat().elements.find(function (e) {
	      return e.name === SEMANTIC_POSITION;
	    });

	    if (positionElement && positionElement.normalize) {
	      var func = function () {
	        switch (positionElement.dataType) {
	          case TYPE_INT8:
	            return function (x) {
	              return Math.max(x / 127.0, -1.0);
	            };

	          case TYPE_UINT8:
	            return function (x) {
	              return x / 255.0;
	            };

	          case TYPE_INT16:
	            return function (x) {
	              return Math.max(x / 32767.0, -1.0);
	            };

	          case TYPE_UINT16:
	            return function (x) {
	              return x / 65535.0;
	            };

	          default:
	            return function (x) {
	              return x;
	            };
	        }
	      }();

	      for (var _i = 0; _i < numBones; _i++) {
	        if (boneUsed[_i]) {
	          var min = boneMin[_i];
	          var max = boneMax[_i];
	          min.set(func(min.x), func(min.y), func(min.z));
	          max.set(func(max.x), func(max.y), func(max.z));
	        }
	      }
	    }

	    for (var _i2 = 0; _i2 < numBones; _i2++) {
	      var aabb = new BoundingBox();
	      aabb.setMinMax(boneMin[_i2], boneMax[_i2]);
	      this.boneAabb.push(aabb);
	    }
	  };

	  _proto2._initGeometryData = function _initGeometryData() {
	    if (!this._geometryData) {
	      this._geometryData = new GeometryData();

	      if (this.vertexBuffer) {
	        this._geometryData.vertexCount = this.vertexBuffer.numVertices;
	        this._geometryData.maxVertices = this.vertexBuffer.numVertices;
	      }

	      if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
	        this._geometryData.indexCount = this.indexBuffer[0].numIndices;
	        this._geometryData.maxIndices = this.indexBuffer[0].numIndices;
	      }
	    }
	  };

	  _proto2.clear = function clear(verticesDynamic, indicesDynamic, maxVertices, maxIndices) {
	    if (maxVertices === void 0) {
	      maxVertices = 0;
	    }

	    if (maxIndices === void 0) {
	      maxIndices = 0;
	    }

	    this._initGeometryData();

	    this._geometryData.initDefaults();

	    this._geometryData.recreate = true;
	    this._geometryData.maxVertices = maxVertices;
	    this._geometryData.maxIndices = maxIndices;
	    this._geometryData.verticesUsage = verticesDynamic ? BUFFER_STATIC : BUFFER_DYNAMIC;
	    this._geometryData.indicesUsage = indicesDynamic ? BUFFER_STATIC : BUFFER_DYNAMIC;
	  };

	  _proto2.setVertexStream = function setVertexStream(semantic, data, componentCount, numVertices, dataType, dataTypeNormalize) {
	    if (dataType === void 0) {
	      dataType = TYPE_FLOAT32;
	    }

	    if (dataTypeNormalize === void 0) {
	      dataTypeNormalize = false;
	    }

	    this._initGeometryData();

	    var vertexCount = numVertices || data.length / componentCount;

	    this._geometryData._changeVertexCount(vertexCount, semantic);

	    this._geometryData.vertexStreamsUpdated = true;
	    this._geometryData.vertexStreamDictionary[semantic] = new GeometryVertexStream(data, componentCount, dataType, dataTypeNormalize);
	  };

	  _proto2.getVertexStream = function getVertexStream(semantic, data) {
	    var count = 0;
	    var done = false;

	    if (this._geometryData) {
	      var stream = this._geometryData.vertexStreamDictionary[semantic];

	      if (stream) {
	        done = true;
	        count = this._geometryData.vertexCount;

	        if (ArrayBuffer.isView(data)) {
	          data.set(stream.data);
	        } else {
	          data.length = 0;
	          data.push(stream.data);
	        }
	      }
	    }

	    if (!done) {
	      if (this.vertexBuffer) {
	        var iterator = new VertexIterator(this.vertexBuffer);
	        count = iterator.readData(semantic, data);
	      }
	    }

	    return count;
	  };

	  _proto2.setPositions = function setPositions(positions, componentCount, numVertices) {
	    if (componentCount === void 0) {
	      componentCount = GeometryData.DEFAULT_COMPONENTS_POSITION;
	    }

	    this.setVertexStream(SEMANTIC_POSITION, positions, componentCount, numVertices, TYPE_FLOAT32, false);
	  };

	  _proto2.setNormals = function setNormals(normals, componentCount, numVertices) {
	    if (componentCount === void 0) {
	      componentCount = GeometryData.DEFAULT_COMPONENTS_NORMAL;
	    }

	    this.setVertexStream(SEMANTIC_NORMAL, normals, componentCount, numVertices, TYPE_FLOAT32, false);
	  };

	  _proto2.setUvs = function setUvs(channel, uvs, componentCount, numVertices) {
	    if (componentCount === void 0) {
	      componentCount = GeometryData.DEFAULT_COMPONENTS_UV;
	    }

	    this.setVertexStream(SEMANTIC_TEXCOORD + channel, uvs, componentCount, numVertices, TYPE_FLOAT32, false);
	  };

	  _proto2.setColors = function setColors(colors, componentCount, numVertices) {
	    if (componentCount === void 0) {
	      componentCount = GeometryData.DEFAULT_COMPONENTS_COLORS;
	    }

	    this.setVertexStream(SEMANTIC_COLOR, colors, componentCount, numVertices, TYPE_FLOAT32, false);
	  };

	  _proto2.setColors32 = function setColors32(colors, numVertices) {
	    this.setVertexStream(SEMANTIC_COLOR, colors, GeometryData.DEFAULT_COMPONENTS_COLORS, numVertices, TYPE_UINT8, true);
	  };

	  _proto2.setIndices = function setIndices(indices, numIndices) {
	    this._initGeometryData();

	    this._geometryData.indexStreamUpdated = true;
	    this._geometryData.indices = indices;
	    this._geometryData.indexCount = numIndices || indices.length;
	  };

	  _proto2.getPositions = function getPositions(positions) {
	    return this.getVertexStream(SEMANTIC_POSITION, positions);
	  };

	  _proto2.getNormals = function getNormals(normals) {
	    return this.getVertexStream(SEMANTIC_NORMAL, normals);
	  };

	  _proto2.getUvs = function getUvs(channel, uvs) {
	    return this.getVertexStream(SEMANTIC_TEXCOORD + channel, uvs);
	  };

	  _proto2.getColors = function getColors(colors) {
	    return this.getVertexStream(SEMANTIC_COLOR, colors);
	  };

	  _proto2.getIndices = function getIndices(indices) {
	    var count = 0;

	    if (this._geometryData && this._geometryData.indices) {
	      var streamIndices = this._geometryData.indices;
	      count = this._geometryData.indexCount;

	      if (ArrayBuffer.isView(indices)) {
	        indices.set(streamIndices);
	      } else {
	        indices.length = 0;
	        indices.push(streamIndices);
	      }
	    } else {
	      if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
	        var indexBuffer = this.indexBuffer[0];
	        count = indexBuffer.readData(indices);
	      }
	    }

	    return count;
	  };

	  _proto2.update = function update(primitiveType, updateBoundingBox) {
	    if (primitiveType === void 0) {
	      primitiveType = PRIMITIVE_TRIANGLES;
	    }

	    if (updateBoundingBox === void 0) {
	      updateBoundingBox = true;
	    }

	    if (this._geometryData) {
	      if (updateBoundingBox) {
	        var stream = this._geometryData.vertexStreamDictionary[SEMANTIC_POSITION];

	        if (stream) {
	          if (stream.componentCount === 3) {
	            this._aabb.compute(stream.data, this._geometryData.vertexCount);
	          }
	        }
	      }

	      var destroyVB = this._geometryData.recreate;

	      if (this._geometryData.vertexCount > this._geometryData.maxVertices) {
	        destroyVB = true;
	        this._geometryData.maxVertices = this._geometryData.vertexCount;
	      }

	      if (destroyVB) {
	        if (this.vertexBuffer) {
	          this.vertexBuffer.destroy();
	          this.vertexBuffer = null;
	        }
	      }

	      var destroyIB = this._geometryData.recreate;

	      if (this._geometryData.indexCount > this._geometryData.maxIndices) {
	        destroyIB = true;
	        this._geometryData.maxIndices = this._geometryData.indexCount;
	      }

	      if (destroyIB) {
	        if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
	          this.indexBuffer[0].destroy();
	          this.indexBuffer[0] = null;
	        }
	      }

	      if (this._geometryData.vertexStreamsUpdated) {
	        this._updateVertexBuffer();
	      }

	      if (this._geometryData.indexStreamUpdated) {
	        this._updateIndexBuffer();
	      }

	      this.primitive[0].type = primitiveType;

	      if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
	        if (this._geometryData.indexStreamUpdated) {
	          this.primitive[0].count = this._geometryData.indexCount;
	          this.primitive[0].indexed = true;
	        }
	      } else {
	        if (this._geometryData.vertexStreamsUpdated) {
	          this.primitive[0].count = this._geometryData.vertexCount;
	          this.primitive[0].indexed = false;
	        }
	      }

	      this._geometryData.vertexCount = 0;
	      this._geometryData.indexCount = 0;
	      this._geometryData.vertexStreamsUpdated = false;
	      this._geometryData.indexStreamUpdated = false;
	      this._geometryData.recreate = false;
	      this.updateRenderStates();
	    }
	  };

	  _proto2._buildVertexFormat = function _buildVertexFormat(vertexCount) {
	    var vertexDesc = [];

	    for (var semantic in this._geometryData.vertexStreamDictionary) {
	      var stream = this._geometryData.vertexStreamDictionary[semantic];
	      vertexDesc.push({
	        semantic: semantic,
	        components: stream.componentCount,
	        type: stream.dataType,
	        normalize: stream.dataTypeNormalize
	      });
	    }

	    return new VertexFormat(this.device, vertexDesc, vertexCount);
	  };

	  _proto2._updateVertexBuffer = function _updateVertexBuffer() {
	    if (!this.vertexBuffer) {
	      var allocateVertexCount = this._geometryData.maxVertices;

	      var format = this._buildVertexFormat(allocateVertexCount);

	      this.vertexBuffer = new VertexBuffer(this.device, format, allocateVertexCount, this._geometryData.verticesUsage);
	    }

	    var iterator = new VertexIterator(this.vertexBuffer);
	    var numVertices = this._geometryData.vertexCount;

	    for (var semantic in this._geometryData.vertexStreamDictionary) {
	      var stream = this._geometryData.vertexStreamDictionary[semantic];
	      iterator.writeData(semantic, stream.data, numVertices);
	      delete this._geometryData.vertexStreamDictionary[semantic];
	    }

	    iterator.end();
	  };

	  _proto2._updateIndexBuffer = function _updateIndexBuffer() {
	    if (this.indexBuffer.length <= 0 || !this.indexBuffer[0]) {
	      var createFormat = this._geometryData.maxVertices > 0xffff ? INDEXFORMAT_UINT32 : INDEXFORMAT_UINT16;
	      this.indexBuffer[0] = new IndexBuffer(this.device, createFormat, this._geometryData.maxIndices, this._geometryData.indicesUsage);
	    }

	    var srcIndices = this._geometryData.indices;

	    if (srcIndices) {
	      var indexBuffer = this.indexBuffer[0];
	      indexBuffer.writeData(srcIndices, this._geometryData.indexCount);
	      this._geometryData.indices = null;
	    }
	  };

	  _proto2.prepareRenderState = function prepareRenderState(renderStyle) {
	    if (renderStyle === RENDERSTYLE_WIREFRAME) {
	      this.generateWireframe();
	    } else if (renderStyle === RENDERSTYLE_POINTS) {
	      this.primitive[RENDERSTYLE_POINTS] = {
	        type: PRIMITIVE_POINTS,
	        base: 0,
	        count: this.vertexBuffer ? this.vertexBuffer.numVertices : 0,
	        indexed: false
	      };
	    }
	  };

	  _proto2.updateRenderStates = function updateRenderStates() {
	    if (this.primitive[RENDERSTYLE_POINTS]) {
	      this.prepareRenderState(RENDERSTYLE_POINTS);
	    }

	    if (this.primitive[RENDERSTYLE_WIREFRAME]) {
	      this.prepareRenderState(RENDERSTYLE_WIREFRAME);
	    }
	  };

	  _proto2.generateWireframe = function generateWireframe() {
	    this._destroyIndexBuffer(RENDERSTYLE_WIREFRAME);

	    var lines = [];
	    var format;

	    if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
	      var offsets = [[0, 1], [1, 2], [2, 0]];
	      var base = this.primitive[RENDERSTYLE_SOLID].base;
	      var count = this.primitive[RENDERSTYLE_SOLID].count;
	      var indexBuffer = this.indexBuffer[RENDERSTYLE_SOLID];
	      var srcIndices = new typedArrayIndexFormats[indexBuffer.format](indexBuffer.storage);
	      var uniqueLineIndices = {};

	      for (var j = base; j < base + count; j += 3) {
	        for (var k = 0; k < 3; k++) {
	          var i1 = srcIndices[j + offsets[k][0]];
	          var i2 = srcIndices[j + offsets[k][1]];
	          var line = i1 > i2 ? i2 << 16 | i1 : i1 << 16 | i2;

	          if (uniqueLineIndices[line] === undefined) {
	            uniqueLineIndices[line] = 0;
	            lines.push(i1, i2);
	          }
	        }
	      }

	      format = indexBuffer.format;
	    } else {
	      for (var i = 0; i < this.vertexBuffer.numVertices; i += 3) {
	        lines.push(i, i + 1, i + 1, i + 2, i + 2, i);
	      }

	      format = lines.length > 65535 ? INDEXFORMAT_UINT32 : INDEXFORMAT_UINT16;
	    }

	    var wireBuffer = new IndexBuffer(this.vertexBuffer.device, format, lines.length);
	    var dstIndices = new typedArrayIndexFormats[wireBuffer.format](wireBuffer.storage);
	    dstIndices.set(lines);
	    wireBuffer.unlock();
	    this.primitive[RENDERSTYLE_WIREFRAME] = {
	      type: PRIMITIVE_LINES,
	      base: 0,
	      count: lines.length,
	      indexed: true
	    };
	    this.indexBuffer[RENDERSTYLE_WIREFRAME] = wireBuffer;
	  };

	  _createClass(Mesh, [{
	    key: "morph",
	    get: function get() {
	      return this._morph;
	    },
	    set: function set(morph) {
	      if (morph !== this._morph) {
	        if (this._morph) {
	          this._morph.decRefCount();
	        }

	        this._morph = morph;

	        if (morph) {
	          morph.incRefCount();
	        }
	      }
	    }
	  }, {
	    key: "aabb",
	    get: function get() {
	      return this._aabb;
	    },
	    set: function set(aabb) {
	      this._aabb = aabb;
	    }
	  }]);

	  return Mesh;
	}(RefCountedObject);

	var primitiveUv1Padding = 4.0 / 64;
	var primitiveUv1PaddingScale = 1.0 - primitiveUv1Padding * 2;
	var shapePrimitives = [];

	function calculateNormals(positions, indices) {
	  var triangleCount = indices.length / 3;
	  var vertexCount = positions.length / 3;
	  var p1 = new Vec3();
	  var p2 = new Vec3();
	  var p3 = new Vec3();
	  var p1p2 = new Vec3();
	  var p1p3 = new Vec3();
	  var faceNormal = new Vec3();
	  var normals = [];

	  for (var i = 0; i < positions.length; i++) {
	    normals[i] = 0;
	  }

	  for (var _i = 0; _i < triangleCount; _i++) {
	    var i1 = indices[_i * 3];
	    var i2 = indices[_i * 3 + 1];
	    var i3 = indices[_i * 3 + 2];
	    p1.set(positions[i1 * 3], positions[i1 * 3 + 1], positions[i1 * 3 + 2]);
	    p2.set(positions[i2 * 3], positions[i2 * 3 + 1], positions[i2 * 3 + 2]);
	    p3.set(positions[i3 * 3], positions[i3 * 3 + 1], positions[i3 * 3 + 2]);
	    p1p2.sub2(p2, p1);
	    p1p3.sub2(p3, p1);
	    faceNormal.cross(p1p2, p1p3).normalize();
	    normals[i1 * 3] += faceNormal.x;
	    normals[i1 * 3 + 1] += faceNormal.y;
	    normals[i1 * 3 + 2] += faceNormal.z;
	    normals[i2 * 3] += faceNormal.x;
	    normals[i2 * 3 + 1] += faceNormal.y;
	    normals[i2 * 3 + 2] += faceNormal.z;
	    normals[i3 * 3] += faceNormal.x;
	    normals[i3 * 3 + 1] += faceNormal.y;
	    normals[i3 * 3 + 2] += faceNormal.z;
	  }

	  for (var _i2 = 0; _i2 < vertexCount; _i2++) {
	    var nx = normals[_i2 * 3];
	    var ny = normals[_i2 * 3 + 1];
	    var nz = normals[_i2 * 3 + 2];
	    var invLen = 1 / Math.sqrt(nx * nx + ny * ny + nz * nz);
	    normals[_i2 * 3] *= invLen;
	    normals[_i2 * 3 + 1] *= invLen;
	    normals[_i2 * 3 + 2] *= invLen;
	  }

	  return normals;
	}

	function calculateTangents(positions, normals, uvs, indices) {
	  var triangleCount = indices.length / 3;
	  var vertexCount = positions.length / 3;
	  var v1 = new Vec3();
	  var v2 = new Vec3();
	  var v3 = new Vec3();
	  var w1 = new Vec2();
	  var w2 = new Vec2();
	  var w3 = new Vec2();
	  var sdir = new Vec3();
	  var tdir = new Vec3();
	  var tan1 = new Float32Array(vertexCount * 3);
	  var tan2 = new Float32Array(vertexCount * 3);
	  var tangents = [];

	  for (var i = 0; i < triangleCount; i++) {
	    var i1 = indices[i * 3];
	    var i2 = indices[i * 3 + 1];
	    var i3 = indices[i * 3 + 2];
	    v1.set(positions[i1 * 3], positions[i1 * 3 + 1], positions[i1 * 3 + 2]);
	    v2.set(positions[i2 * 3], positions[i2 * 3 + 1], positions[i2 * 3 + 2]);
	    v3.set(positions[i3 * 3], positions[i3 * 3 + 1], positions[i3 * 3 + 2]);
	    w1.set(uvs[i1 * 2], uvs[i1 * 2 + 1]);
	    w2.set(uvs[i2 * 2], uvs[i2 * 2 + 1]);
	    w3.set(uvs[i3 * 2], uvs[i3 * 2 + 1]);
	    var x1 = v2.x - v1.x;
	    var x2 = v3.x - v1.x;
	    var y1 = v2.y - v1.y;
	    var y2 = v3.y - v1.y;
	    var z1 = v2.z - v1.z;
	    var z2 = v3.z - v1.z;
	    var s1 = w2.x - w1.x;
	    var s2 = w3.x - w1.x;

	    var _t = w2.y - w1.y;

	    var _t2 = w3.y - w1.y;

	    var area = s1 * _t2 - s2 * _t;

	    if (area === 0) {
	      sdir.set(0, 1, 0);
	      tdir.set(1, 0, 0);
	    } else {
	      var r = 1 / area;
	      sdir.set((_t2 * x1 - _t * x2) * r, (_t2 * y1 - _t * y2) * r, (_t2 * z1 - _t * z2) * r);
	      tdir.set((s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r, (s1 * z2 - s2 * z1) * r);
	    }

	    tan1[i1 * 3 + 0] += sdir.x;
	    tan1[i1 * 3 + 1] += sdir.y;
	    tan1[i1 * 3 + 2] += sdir.z;
	    tan1[i2 * 3 + 0] += sdir.x;
	    tan1[i2 * 3 + 1] += sdir.y;
	    tan1[i2 * 3 + 2] += sdir.z;
	    tan1[i3 * 3 + 0] += sdir.x;
	    tan1[i3 * 3 + 1] += sdir.y;
	    tan1[i3 * 3 + 2] += sdir.z;
	    tan2[i1 * 3 + 0] += tdir.x;
	    tan2[i1 * 3 + 1] += tdir.y;
	    tan2[i1 * 3 + 2] += tdir.z;
	    tan2[i2 * 3 + 0] += tdir.x;
	    tan2[i2 * 3 + 1] += tdir.y;
	    tan2[i2 * 3 + 2] += tdir.z;
	    tan2[i3 * 3 + 0] += tdir.x;
	    tan2[i3 * 3 + 1] += tdir.y;
	    tan2[i3 * 3 + 2] += tdir.z;
	  }

	  var t1 = new Vec3();
	  var t2 = new Vec3();
	  var n = new Vec3();
	  var temp = new Vec3();

	  for (var _i3 = 0; _i3 < vertexCount; _i3++) {
	    n.set(normals[_i3 * 3], normals[_i3 * 3 + 1], normals[_i3 * 3 + 2]);
	    t1.set(tan1[_i3 * 3], tan1[_i3 * 3 + 1], tan1[_i3 * 3 + 2]);
	    t2.set(tan2[_i3 * 3], tan2[_i3 * 3 + 1], tan2[_i3 * 3 + 2]);
	    var ndott = n.dot(t1);
	    temp.copy(n).mulScalar(ndott);
	    temp.sub2(t1, temp).normalize();
	    tangents[_i3 * 4] = temp.x;
	    tangents[_i3 * 4 + 1] = temp.y;
	    tangents[_i3 * 4 + 2] = temp.z;
	    temp.cross(n, t1);
	    tangents[_i3 * 4 + 3] = temp.dot(t2) < 0.0 ? -1.0 : 1.0;
	  }

	  return tangents;
	}

	function createMesh$1(device, positions, opts) {
	  var mesh = new Mesh(device);
	  mesh.setPositions(positions);

	  if (opts) {
	    if (opts.normals) {
	      mesh.setNormals(opts.normals);
	    }

	    if (opts.tangents) {
	      mesh.setVertexStream(SEMANTIC_TANGENT, opts.tangents, 4);
	    }

	    if (opts.colors) {
	      mesh.setColors32(opts.colors);
	    }

	    if (opts.uvs) {
	      mesh.setUvs(0, opts.uvs);
	    }

	    if (opts.uvs1) {
	      mesh.setUvs(1, opts.uvs1);
	    }

	    if (opts.blendIndices) {
	      mesh.setVertexStream(SEMANTIC_BLENDINDICES, opts.blendIndices, 4, opts.blendIndices.length / 4, TYPE_UINT8);
	    }

	    if (opts.blendWeights) {
	      mesh.setVertexStream(SEMANTIC_BLENDWEIGHT, opts.blendWeights, 4);
	    }

	    if (opts.indices) {
	      mesh.setIndices(opts.indices);
	    }
	  }

	  mesh.update();
	  return mesh;
	}

	function createTorus(device, opts) {
	  var rc = opts && opts.tubeRadius !== undefined ? opts.tubeRadius : 0.2;
	  var rt = opts && opts.ringRadius !== undefined ? opts.ringRadius : 0.3;
	  var segments = opts && opts.segments !== undefined ? opts.segments : 30;
	  var sides = opts && opts.sides !== undefined ? opts.sides : 20;
	  var calcTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;
	  var positions = [];
	  var normals = [];
	  var uvs = [];
	  var indices = [];

	  for (var i = 0; i <= sides; i++) {
	    for (var j = 0; j <= segments; j++) {
	      var x = Math.cos(2 * Math.PI * j / segments) * (rt + rc * Math.cos(2 * Math.PI * i / sides));
	      var y = Math.sin(2 * Math.PI * i / sides) * rc;
	      var z = Math.sin(2 * Math.PI * j / segments) * (rt + rc * Math.cos(2 * Math.PI * i / sides));
	      var nx = Math.cos(2 * Math.PI * j / segments) * Math.cos(2 * Math.PI * i / sides);
	      var ny = Math.sin(2 * Math.PI * i / sides);
	      var nz = Math.sin(2 * Math.PI * j / segments) * Math.cos(2 * Math.PI * i / sides);
	      var u = i / sides;
	      var v = 1 - j / segments;
	      positions.push(x, y, z);
	      normals.push(nx, ny, nz);
	      uvs.push(u, 1.0 - v);

	      if (i < sides && j < segments) {
	        var first = i * (segments + 1) + j;
	        var second = (i + 1) * (segments + 1) + j;
	        var third = i * (segments + 1) + (j + 1);
	        var fourth = (i + 1) * (segments + 1) + (j + 1);
	        indices.push(first, second, third);
	        indices.push(second, fourth, third);
	      }
	    }
	  }

	  var options = {
	    normals: normals,
	    uvs: uvs,
	    uvs1: uvs,
	    indices: indices
	  };

	  if (calcTangents) {
	    options.tangents = calculateTangents(positions, normals, uvs, indices);
	  }

	  return createMesh$1(device, positions, options);
	}

	function _createConeData(baseRadius, peakRadius, height, heightSegments, capSegments, roundedCaps) {
	  var pos = new Vec3();
	  var bottomToTop = new Vec3();
	  var norm = new Vec3();
	  var top = new Vec3();
	  var bottom = new Vec3();
	  var tangent = new Vec3();
	  var positions = [];
	  var normals = [];
	  var uvs = [];
	  var uvs1 = [];
	  var indices = [];
	  var offset;

	  if (height > 0) {
	    for (var i = 0; i <= heightSegments; i++) {
	      for (var j = 0; j <= capSegments; j++) {
	        var theta = j / capSegments * 2 * Math.PI - Math.PI;
	        var sinTheta = Math.sin(theta);
	        var cosTheta = Math.cos(theta);
	        bottom.set(sinTheta * baseRadius, -height / 2, cosTheta * baseRadius);
	        top.set(sinTheta * peakRadius, height / 2, cosTheta * peakRadius);
	        pos.lerp(bottom, top, i / heightSegments);
	        bottomToTop.sub2(top, bottom).normalize();
	        tangent.set(cosTheta, 0, -sinTheta);
	        norm.cross(tangent, bottomToTop).normalize();
	        positions.push(pos.x, pos.y, pos.z);
	        normals.push(norm.x, norm.y, norm.z);
	        var u = j / capSegments;
	        var v = i / heightSegments;
	        uvs.push(u, 1 - v);
	        var _v = v;
	        v = u;
	        u = _v;
	        u = u * primitiveUv1PaddingScale + primitiveUv1Padding;
	        v = v * primitiveUv1PaddingScale + primitiveUv1Padding;
	        u /= 3;
	        uvs1.push(u, 1 - v);

	        if (i < heightSegments && j < capSegments) {
	          var first = i * (capSegments + 1) + j;
	          var second = i * (capSegments + 1) + (j + 1);
	          var third = (i + 1) * (capSegments + 1) + j;
	          var fourth = (i + 1) * (capSegments + 1) + (j + 1);
	          indices.push(first, second, third);
	          indices.push(second, fourth, third);
	        }
	      }
	    }
	  }

	  if (roundedCaps) {
	    var latitudeBands = Math.floor(capSegments / 2);
	    var longitudeBands = capSegments;
	    var capOffset = height / 2;

	    for (var lat = 0; lat <= latitudeBands; lat++) {
	      var _theta = lat * Math.PI * 0.5 / latitudeBands;

	      var _sinTheta = Math.sin(_theta);

	      var _cosTheta = Math.cos(_theta);

	      for (var lon = 0; lon <= longitudeBands; lon++) {
	        var phi = lon * 2 * Math.PI / longitudeBands - Math.PI / 2;
	        var sinPhi = Math.sin(phi);
	        var cosPhi = Math.cos(phi);
	        var x = cosPhi * _sinTheta;
	        var y = _cosTheta;
	        var z = sinPhi * _sinTheta;

	        var _u = 1 - lon / longitudeBands;

	        var _v2 = 1 - lat / latitudeBands;

	        positions.push(x * peakRadius, y * peakRadius + capOffset, z * peakRadius);
	        normals.push(x, y, z);
	        uvs.push(_u, 1 - _v2);
	        _u = _u * primitiveUv1PaddingScale + primitiveUv1Padding;
	        _v2 = _v2 * primitiveUv1PaddingScale + primitiveUv1Padding;
	        _u /= 3;
	        _v2 /= 3;
	        _u += 1.0 / 3;
	        uvs1.push(_u, 1 - _v2);
	      }
	    }

	    offset = (heightSegments + 1) * (capSegments + 1);

	    for (var _lat = 0; _lat < latitudeBands; ++_lat) {
	      for (var _lon = 0; _lon < longitudeBands; ++_lon) {
	        var _first = _lat * (longitudeBands + 1) + _lon;

	        var _second = _first + longitudeBands + 1;

	        indices.push(offset + _first + 1, offset + _second, offset + _first);
	        indices.push(offset + _first + 1, offset + _second + 1, offset + _second);
	      }
	    }

	    for (var _lat2 = 0; _lat2 <= latitudeBands; _lat2++) {
	      var _theta2 = Math.PI * 0.5 + _lat2 * Math.PI * 0.5 / latitudeBands;

	      var _sinTheta2 = Math.sin(_theta2);

	      var _cosTheta2 = Math.cos(_theta2);

	      for (var _lon2 = 0; _lon2 <= longitudeBands; _lon2++) {
	        var _phi = _lon2 * 2 * Math.PI / longitudeBands - Math.PI / 2;

	        var _sinPhi = Math.sin(_phi);

	        var _cosPhi = Math.cos(_phi);

	        var _x = _cosPhi * _sinTheta2;

	        var _y = _cosTheta2;

	        var _z = _sinPhi * _sinTheta2;

	        var _u2 = 1 - _lon2 / longitudeBands;

	        var _v3 = 1 - _lat2 / latitudeBands;

	        positions.push(_x * peakRadius, _y * peakRadius - capOffset, _z * peakRadius);
	        normals.push(_x, _y, _z);
	        uvs.push(_u2, 1 - _v3);
	        _u2 = _u2 * primitiveUv1PaddingScale + primitiveUv1Padding;
	        _v3 = _v3 * primitiveUv1PaddingScale + primitiveUv1Padding;
	        _u2 /= 3;
	        _v3 /= 3;
	        _u2 += 2.0 / 3;
	        uvs1.push(_u2, 1 - _v3);
	      }
	    }

	    offset = (heightSegments + 1) * (capSegments + 1) + (longitudeBands + 1) * (latitudeBands + 1);

	    for (var _lat3 = 0; _lat3 < latitudeBands; ++_lat3) {
	      for (var _lon3 = 0; _lon3 < longitudeBands; ++_lon3) {
	        var _first2 = _lat3 * (longitudeBands + 1) + _lon3;

	        var _second2 = _first2 + longitudeBands + 1;

	        indices.push(offset + _first2 + 1, offset + _second2, offset + _first2);
	        indices.push(offset + _first2 + 1, offset + _second2 + 1, offset + _second2);
	      }
	    }
	  } else {
	    offset = (heightSegments + 1) * (capSegments + 1);

	    if (baseRadius > 0) {
	      for (var _i4 = 0; _i4 < capSegments; _i4++) {
	        var _theta3 = _i4 / capSegments * 2 * Math.PI;

	        var _x2 = Math.sin(_theta3);

	        var _y2 = -height / 2;

	        var _z2 = Math.cos(_theta3);

	        var _u3 = 1 - (_x2 + 1) / 2;

	        var _v4 = (_z2 + 1) / 2;

	        positions.push(_x2 * baseRadius, _y2, _z2 * baseRadius);
	        normals.push(0, -1, 0);
	        uvs.push(_u3, 1 - _v4);
	        _u3 = _u3 * primitiveUv1PaddingScale + primitiveUv1Padding;
	        _v4 = _v4 * primitiveUv1PaddingScale + primitiveUv1Padding;
	        _u3 /= 3;
	        _v4 /= 3;
	        _u3 += 1 / 3;
	        uvs1.push(_u3, 1 - _v4);

	        if (_i4 > 1) {
	          indices.push(offset, offset + _i4, offset + _i4 - 1);
	        }
	      }
	    }

	    offset += capSegments;

	    if (peakRadius > 0) {
	      for (var _i5 = 0; _i5 < capSegments; _i5++) {
	        var _theta4 = _i5 / capSegments * 2 * Math.PI;

	        var _x3 = Math.sin(_theta4);

	        var _y3 = height / 2;

	        var _z3 = Math.cos(_theta4);

	        var _u4 = 1 - (_x3 + 1) / 2;

	        var _v5 = (_z3 + 1) / 2;

	        positions.push(_x3 * peakRadius, _y3, _z3 * peakRadius);
	        normals.push(0, 1, 0);
	        uvs.push(_u4, 1 - _v5);
	        _u4 = _u4 * primitiveUv1PaddingScale + primitiveUv1Padding;
	        _v5 = _v5 * primitiveUv1PaddingScale + primitiveUv1Padding;
	        _u4 /= 3;
	        _v5 /= 3;
	        _u4 += 2 / 3;
	        uvs1.push(_u4, 1 - _v5);

	        if (_i5 > 1) {
	          indices.push(offset, offset + _i5 - 1, offset + _i5);
	        }
	      }
	    }
	  }

	  return {
	    positions: positions,
	    normals: normals,
	    uvs: uvs,
	    uvs1: uvs1,
	    indices: indices
	  };
	}

	function createCylinder(device, opts) {
	  var radius = opts && (opts.radius || opts.baseRadius);
	  radius = radius !== undefined ? radius : 0.5;
	  var height = opts && opts.height !== undefined ? opts.height : 1.0;
	  var heightSegments = opts && opts.heightSegments !== undefined ? opts.heightSegments : 5;
	  var capSegments = opts && opts.capSegments !== undefined ? opts.capSegments : 20;
	  var calcTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;

	  var options = _createConeData(radius, radius, height, heightSegments, capSegments, false);

	  if (calcTangents) {
	    options.tangents = calculateTangents(options.positions, options.normals, options.uvs, options.indices);
	  }

	  return createMesh$1(device, options.positions, options);
	}

	function createCapsule(device, opts) {
	  var radius = opts && opts.radius !== undefined ? opts.radius : 0.3;
	  var height = opts && opts.height !== undefined ? opts.height : 1.0;
	  var heightSegments = opts && opts.heightSegments !== undefined ? opts.heightSegments : 1;
	  var sides = opts && opts.sides !== undefined ? opts.sides : 20;
	  var calcTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;

	  var options = _createConeData(radius, radius, height - 2 * radius, heightSegments, sides, true);

	  if (calcTangents) {
	    options.tangents = calculateTangents(options.positions, options.normals, options.uvs, options.indices);
	  }

	  return createMesh$1(device, options.positions, options);
	}

	function createCone(device, opts) {
	  var baseRadius = opts && opts.baseRadius !== undefined ? opts.baseRadius : 0.5;
	  var peakRadius = opts && opts.peakRadius !== undefined ? opts.peakRadius : 0.0;
	  var height = opts && opts.height !== undefined ? opts.height : 1.0;
	  var heightSegments = opts && opts.heightSegments !== undefined ? opts.heightSegments : 5;
	  var capSegments = opts && opts.capSegments !== undefined ? opts.capSegments : 18;
	  var calcTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;

	  var options = _createConeData(baseRadius, peakRadius, height, heightSegments, capSegments, false);

	  if (calcTangents) {
	    options.tangents = calculateTangents(options.positions, options.normals, options.uvs, options.indices);
	  }

	  return createMesh$1(device, options.positions, options);
	}

	function createSphere(device, opts) {
	  var radius = opts && opts.radius !== undefined ? opts.radius : 0.5;
	  var latitudeBands = opts && opts.latitudeBands !== undefined ? opts.latitudeBands : 16;
	  var longitudeBands = opts && opts.longitudeBands !== undefined ? opts.longitudeBands : 16;
	  var calcTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;
	  var positions = [];
	  var normals = [];
	  var uvs = [];
	  var indices = [];

	  for (var lat = 0; lat <= latitudeBands; lat++) {
	    var theta = lat * Math.PI / latitudeBands;
	    var sinTheta = Math.sin(theta);
	    var cosTheta = Math.cos(theta);

	    for (var lon = 0; lon <= longitudeBands; lon++) {
	      var phi = lon * 2 * Math.PI / longitudeBands - Math.PI / 2;
	      var sinPhi = Math.sin(phi);
	      var cosPhi = Math.cos(phi);
	      var x = cosPhi * sinTheta;
	      var y = cosTheta;
	      var z = sinPhi * sinTheta;
	      var u = 1 - lon / longitudeBands;
	      var v = 1 - lat / latitudeBands;
	      positions.push(x * radius, y * radius, z * radius);
	      normals.push(x, y, z);
	      uvs.push(u, 1 - v);
	    }
	  }

	  for (var _lat4 = 0; _lat4 < latitudeBands; ++_lat4) {
	    for (var _lon4 = 0; _lon4 < longitudeBands; ++_lon4) {
	      var first = _lat4 * (longitudeBands + 1) + _lon4;
	      var second = first + longitudeBands + 1;
	      indices.push(first + 1, second, first);
	      indices.push(first + 1, second + 1, second);
	    }
	  }

	  var options = {
	    normals: normals,
	    uvs: uvs,
	    uvs1: uvs,
	    indices: indices
	  };

	  if (calcTangents) {
	    options.tangents = calculateTangents(positions, normals, uvs, indices);
	  }

	  return createMesh$1(device, positions, options);
	}

	function createPlane(device, opts) {
	  var he = opts && opts.halfExtents !== undefined ? opts.halfExtents : new Vec2(0.5, 0.5);
	  var ws = opts && opts.widthSegments !== undefined ? opts.widthSegments : 5;
	  var ls = opts && opts.lengthSegments !== undefined ? opts.lengthSegments : 5;
	  var calcTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;
	  var positions = [];
	  var normals = [];
	  var uvs = [];
	  var indices = [];
	  var vcounter = 0;

	  for (var i = 0; i <= ws; i++) {
	    for (var j = 0; j <= ls; j++) {
	      var x = -he.x + 2 * he.x * i / ws;
	      var y = 0.0;
	      var z = -(-he.y + 2 * he.y * j / ls);
	      var u = i / ws;
	      var v = j / ls;
	      positions.push(x, y, z);
	      normals.push(0, 1, 0);
	      uvs.push(u, 1 - v);

	      if (i < ws && j < ls) {
	        indices.push(vcounter + ls + 1, vcounter + 1, vcounter);
	        indices.push(vcounter + ls + 1, vcounter + ls + 2, vcounter + 1);
	      }

	      vcounter++;
	    }
	  }

	  var options = {
	    normals: normals,
	    uvs: uvs,
	    uvs1: uvs,
	    indices: indices
	  };

	  if (calcTangents) {
	    options.tangents = calculateTangents(positions, normals, uvs, indices);
	  }

	  return createMesh$1(device, positions, options);
	}

	function createBox(device, opts) {
	  var he = opts && opts.halfExtents !== undefined ? opts.halfExtents : new Vec3(0.5, 0.5, 0.5);
	  var ws = opts && opts.widthSegments !== undefined ? opts.widthSegments : 1;
	  var ls = opts && opts.lengthSegments !== undefined ? opts.lengthSegments : 1;
	  var hs = opts && opts.heightSegments !== undefined ? opts.heightSegments : 1;
	  var calcTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;
	  var corners = [new Vec3(-he.x, -he.y, he.z), new Vec3(he.x, -he.y, he.z), new Vec3(he.x, he.y, he.z), new Vec3(-he.x, he.y, he.z), new Vec3(he.x, -he.y, -he.z), new Vec3(-he.x, -he.y, -he.z), new Vec3(-he.x, he.y, -he.z), new Vec3(he.x, he.y, -he.z)];
	  var faceAxes = [[0, 1, 3], [4, 5, 7], [3, 2, 6], [1, 0, 4], [1, 4, 2], [5, 0, 6]];
	  var faceNormals = [[0, 0, 1], [0, 0, -1], [0, 1, 0], [0, -1, 0], [1, 0, 0], [-1, 0, 0]];
	  var sides = {
	    FRONT: 0,
	    BACK: 1,
	    TOP: 2,
	    BOTTOM: 3,
	    RIGHT: 4,
	    LEFT: 5
	  };
	  var positions = [];
	  var normals = [];
	  var uvs = [];
	  var uvs1 = [];
	  var indices = [];
	  var vcounter = 0;

	  var generateFace = function generateFace(side, uSegments, vSegments) {
	    var temp1 = new Vec3();
	    var temp2 = new Vec3();
	    var temp3 = new Vec3();
	    var r = new Vec3();

	    for (var i = 0; i <= uSegments; i++) {
	      for (var j = 0; j <= vSegments; j++) {
	        temp1.lerp(corners[faceAxes[side][0]], corners[faceAxes[side][1]], i / uSegments);
	        temp2.lerp(corners[faceAxes[side][0]], corners[faceAxes[side][2]], j / vSegments);
	        temp3.sub2(temp2, corners[faceAxes[side][0]]);
	        r.add2(temp1, temp3);
	        var u = i / uSegments;
	        var v = j / vSegments;
	        positions.push(r.x, r.y, r.z);
	        normals.push(faceNormals[side][0], faceNormals[side][1], faceNormals[side][2]);
	        uvs.push(u, 1 - v);
	        u = u * primitiveUv1PaddingScale + primitiveUv1Padding;
	        v = v * primitiveUv1PaddingScale + primitiveUv1Padding;
	        u /= 3;
	        v /= 3;
	        u += side % 3 / 3;
	        v += Math.floor(side / 3) / 3;
	        uvs1.push(u, 1 - v);

	        if (i < uSegments && j < vSegments) {
	          indices.push(vcounter + vSegments + 1, vcounter + 1, vcounter);
	          indices.push(vcounter + vSegments + 1, vcounter + vSegments + 2, vcounter + 1);
	        }

	        vcounter++;
	      }
	    }
	  };

	  generateFace(sides.FRONT, ws, hs);
	  generateFace(sides.BACK, ws, hs);
	  generateFace(sides.TOP, ws, ls);
	  generateFace(sides.BOTTOM, ws, ls);
	  generateFace(sides.RIGHT, ls, hs);
	  generateFace(sides.LEFT, ls, hs);
	  var options = {
	    normals: normals,
	    uvs: uvs,
	    uvs1: uvs1,
	    indices: indices
	  };

	  if (calcTangents) {
	    options.tangents = calculateTangents(positions, normals, uvs, indices);
	  }

	  return createMesh$1(device, positions, options);
	}

	function getShapePrimitive(device, type) {
	  var primData = null;

	  for (var i = 0; i < shapePrimitives.length; i++) {
	    if (shapePrimitives[i].type === type && shapePrimitives[i].device === device) {
	      primData = shapePrimitives[i].primData;
	    }
	  }

	  if (!primData) {
	    var mesh, area;

	    switch (type) {
	      case 'box':
	        mesh = createBox(device, {
	          halfExtents: new Vec3(0.5, 0.5, 0.5)
	        });
	        area = {
	          x: 2,
	          y: 2,
	          z: 2,
	          uv: 2.0 / 3
	        };
	        break;

	      case 'capsule':
	        mesh = createCapsule(device, {
	          radius: 0.5,
	          height: 2
	        });
	        area = {
	          x: Math.PI * 2,
	          y: Math.PI,
	          z: Math.PI * 2,
	          uv: 1.0 / 3 + 1.0 / 3 / 3 * 2
	        };
	        break;

	      case 'cone':
	        mesh = createCone(device, {
	          baseRadius: 0.5,
	          peakRadius: 0,
	          height: 1
	        });
	        area = {
	          x: 2.54,
	          y: 2.54,
	          z: 2.54,
	          uv: 1.0 / 3 + 1.0 / 3 / 3
	        };
	        break;

	      case 'cylinder':
	        mesh = createCylinder(device, {
	          radius: 0.5,
	          height: 1
	        });
	        area = {
	          x: Math.PI,
	          y: 0.79 * 2,
	          z: Math.PI,
	          uv: 1.0 / 3 + 1.0 / 3 / 3 * 2
	        };
	        break;

	      case 'plane':
	        mesh = createPlane(device, {
	          halfExtents: new Vec2(0.5, 0.5),
	          widthSegments: 1,
	          lengthSegments: 1
	        });
	        area = {
	          x: 0,
	          y: 1,
	          z: 0,
	          uv: 1
	        };
	        break;

	      case 'sphere':
	        mesh = createSphere(device, {
	          radius: 0.5
	        });
	        area = {
	          x: Math.PI,
	          y: Math.PI,
	          z: Math.PI,
	          uv: 1
	        };
	        break;

	      case 'torus':
	        mesh = createTorus(device, {
	          tubeRadius: 0.2,
	          ringRadius: 0.3
	        });
	        area = {
	          x: Math.PI * 0.5 * 0.5 - Math.PI * 0.1 * 0.1,
	          y: 0.4,
	          z: 0.4,
	          uv: 1
	        };
	        break;

	      default:
	        throw new Error('Invalid primitive type: ' + type);
	    }

	    mesh.incRefCount();
	    primData = {
	      mesh: mesh,
	      area: area
	    };
	    shapePrimitives.push({
	      type: type,
	      device: device,
	      primData: primData
	    });
	  }

	  return primData;
	}

	var basic = {
	  generateKey: function generateKey(options) {
	    var key = 'basic';
	    if (options.fog) key += '_fog';
	    if (options.alphaTest) key += '_atst';
	    if (options.vertexColors) key += '_vcol';
	    if (options.diffuseMap) key += '_diff';
	    if (options.skin) key += '_skin';
	    if (options.screenSpace) key += '_ss';
	    if (options.useInstancing) key += '_inst';
	    if (options.useMorphPosition) key += '_morphp';
	    if (options.useMorphNormal) key += '_morphn';
	    if (options.useMorphTextureBased) key += '_morpht';
	    key += '_' + options.pass;
	    return key;
	  },
	  createShaderDefinition: function createShaderDefinition(device, options) {
	    var attributes = {
	      vertex_position: SEMANTIC_POSITION
	    };

	    if (options.skin) {
	      attributes.vertex_boneWeights = SEMANTIC_BLENDWEIGHT;
	      attributes.vertex_boneIndices = SEMANTIC_BLENDINDICES;
	    }

	    if (options.vertexColors) {
	      attributes.vertex_color = SEMANTIC_COLOR;
	    }

	    if (options.diffuseMap) {
	      attributes.vertex_texCoord0 = SEMANTIC_TEXCOORD0;
	    }

	    var code = vertexIntro(device, 'BasicShader', options.pass);
	    code += shaderChunks.transformDeclVS;

	    if (options.skin) {
	      code += skinCode(device);
	      code += shaderChunks.transformSkinnedVS;
	    } else {
	      code += shaderChunks.transformVS;
	    }

	    if (options.vertexColors) {
	      code += 'attribute vec4 vertex_color;\n';
	      code += 'varying vec4 vColor;\n';
	    }

	    if (options.diffuseMap) {
	      code += 'attribute vec2 vertex_texCoord0;\n';
	      code += 'varying vec2 vUv0;\n';
	    }

	    if (options.pass === SHADER_DEPTH) {
	      code += 'varying float vDepth;\n';
	      code += '#ifndef VIEWMATRIX\n';
	      code += '#define VIEWMATRIX\n';
	      code += 'uniform mat4 matrix_view;\n';
	      code += '#endif\n';
	      code += '#ifndef CAMERAPLANES\n';
	      code += '#define CAMERAPLANES\n';
	      code += 'uniform vec4 camera_params;\n\n';
	      code += '#endif\n';
	    }

	    code += begin();
	    code += "   gl_Position = getPosition();\n";

	    if (options.pass === SHADER_DEPTH) {
	      code += "    vDepth = -(matrix_view * vec4(getWorldPosition(),1.0)).z * camera_params.x;\n";
	    }

	    if (options.vertexColors) {
	      code += '    vColor = vertex_color;\n';
	    }

	    if (options.diffuseMap) {
	      code += '    vUv0 = vertex_texCoord0;\n';
	    }

	    code += end();
	    var vshader = code;
	    code = fragmentIntro(device, 'BasicMaterial', options.pass);

	    if (options.vertexColors) {
	      code += 'varying vec4 vColor;\n';
	    } else {
	      code += 'uniform vec4 uColor;\n';
	    }

	    if (options.diffuseMap) {
	      code += 'varying vec2 vUv0;\n';
	      code += 'uniform sampler2D texture_diffuseMap;\n';
	    }

	    if (options.fog) {
	      code += fogCode(options.fog);
	    }

	    if (options.alphaTest) {
	      code += shaderChunks.alphaTestPS;
	    }

	    if (options.pass === SHADER_DEPTH) {
	      code += 'varying float vDepth;\n';
	      code += shaderChunks.packDepthPS;
	    }

	    code += begin();

	    if (options.vertexColors) {
	      code += '    gl_FragColor = vColor;\n';
	    } else {
	      code += '    gl_FragColor = uColor;\n';
	    }

	    if (options.diffuseMap) {
	      code += '    gl_FragColor *= texture2D(texture_diffuseMap, vUv0);\n';
	    }

	    if (options.alphaTest) {
	      code += "   alphaTest(gl_FragColor.a);\n";
	    }

	    if (options.pass !== SHADER_PICK) {
	      if (options.pass === SHADER_DEPTH) {
	        code += "    gl_FragColor = packFloat(vDepth);\n";
	      } else {
	        if (options.fog) {
	          code += "   glFragColor.rgb = addFog(gl_FragColor.rgb);\n";
	        }
	      }
	    }

	    code += end();
	    var fshader = code;
	    return {
	      attributes: attributes,
	      vshader: vshader,
	      fshader: fshader
	    };
	  }
	};

	var BasicMaterial = function (_Material) {
	  _inheritsLoose(BasicMaterial, _Material);

	  function BasicMaterial() {
	    var _this;

	    _this = _Material.call(this) || this;
	    _this.color = new Color(1, 1, 1, 1);
	    _this.colorUniform = new Float32Array(4);
	    _this.colorMap = null;
	    _this.vertexColors = false;
	    return _this;
	  }

	  var _proto = BasicMaterial.prototype;

	  _proto.copy = function copy(source) {
	    _Material.prototype.copy.call(this, source);

	    this.color.copy(source.color);
	    this.colorMap = source.colorMap;
	    this.vertexColors = source.vertexColors;
	    return this;
	  };

	  _proto.updateUniforms = function updateUniforms(device, scene) {
	    this.clearParameters();
	    this.colorUniform[0] = this.color.r;
	    this.colorUniform[1] = this.color.g;
	    this.colorUniform[2] = this.color.b;
	    this.colorUniform[3] = this.color.a;
	    this.setParameter('uColor', this.colorUniform);

	    if (this.colorMap) {
	      this.setParameter('texture_diffuseMap', this.colorMap);
	    }
	  };

	  _proto.getShaderVariant = function getShaderVariant(device, scene, objDefs, staticLightList, pass, sortedLights, viewUniformFormat, viewBindGroupFormat) {
	    if (this.updateShader) {
	      this.updateShader(device, scene, objDefs, staticLightList, pass, sortedLights);
	      return this.shader;
	    }

	    var options = {
	      skin: objDefs && (objDefs & SHADERDEF_SKIN) !== 0,
	      screenSpace: objDefs && (objDefs & SHADERDEF_SCREENSPACE) !== 0,
	      useInstancing: objDefs && (objDefs & SHADERDEF_INSTANCING) !== 0,
	      useMorphPosition: objDefs && (objDefs & SHADERDEF_MORPH_POSITION) !== 0,
	      useMorphNormal: objDefs && (objDefs & SHADERDEF_MORPH_NORMAL) !== 0,
	      useMorphTextureBased: objDefs && (objDefs & SHADERDEF_MORPH_TEXTURE_BASED) !== 0,
	      alphaTest: this.alphaTest > 0,
	      vertexColors: this.vertexColors,
	      diffuseMap: !!this.colorMap,
	      pass: pass
	    };
	    var processingOptions = new ShaderProcessorOptions(viewUniformFormat, viewBindGroupFormat);
	    var library = device.getProgramLibrary();
	    library.register('basic', basic);
	    return library.getProgram('basic', options, processingOptions);
	  };

	  return BasicMaterial;
	}(Material);

	var Batch = function () {
	  function Batch(meshInstances, dynamic, batchGroupId) {
	    this.origMeshInstances = meshInstances;
	    this._aabb = new BoundingBox();
	    this.meshInstance = null;
	    this.dynamic = dynamic;
	    this.batchGroupId = batchGroupId;
	  }

	  var _proto = Batch.prototype;

	  _proto.destroy = function destroy(scene, layers) {
	    if (this.meshInstance) {
	      this.removeFromLayers(scene, layers);
	      this.meshInstance.destroy();
	    }
	  };

	  _proto.addToLayers = function addToLayers(scene, layers) {
	    for (var i = 0; i < layers.length; i++) {
	      var layer = scene.layers.getLayerById(layers[i]);

	      if (layer) {
	        layer.addMeshInstances([this.meshInstance]);
	      }
	    }
	  };

	  _proto.removeFromLayers = function removeFromLayers(scene, layers) {
	    for (var i = 0; i < layers.length; i++) {
	      var layer = scene.layers.getLayerById(layers[i]);

	      if (layer) {
	        layer.removeMeshInstances([this.meshInstance]);
	      }
	    }
	  };

	  _proto.updateBoundingBox = function updateBoundingBox() {
	    this._aabb.copy(this.origMeshInstances[0].aabb);

	    for (var i = 1; i < this.origMeshInstances.length; i++) {
	      this._aabb.add(this.origMeshInstances[i].aabb);
	    }

	    this.meshInstance.aabb = this._aabb;
	    this.meshInstance._aabbVer = 0;
	  };

	  return Batch;
	}();

	var BatchGroup = function BatchGroup(id, name, dynamic, maxAabbSize, layers) {
	  if (layers === void 0) {
	    layers = [LAYERID_WORLD];
	  }

	  this.dynamic = dynamic;
	  this.maxAabbSize = maxAabbSize;
	  this.id = id;
	  this.name = name;
	  this.layers = layers;
	  this._ui = false;
	  this._sprite = false;
	  this._obj = {
	    model: [],
	    element: [],
	    sprite: [],
	    render: []
	  };
	};

	BatchGroup.MODEL = 'model';
	BatchGroup.ELEMENT = 'element';
	BatchGroup.SPRITE = 'sprite';
	BatchGroup.RENDER = 'render';

	var _invMatrix = new Mat4();

	var SkinInstance = function () {
	  function SkinInstance(skin) {
	    this.bones = void 0;
	    this._dirty = true;
	    this._rootBone = null;
	    this._skinUpdateIndex = -1;
	    this._updateBeforeCull = true;

	    if (skin) {
	      this.initSkin(skin);
	    }
	  }

	  var _proto = SkinInstance.prototype;

	  _proto.init = function init(device, numBones) {
	    if (device.supportsBoneTextures) {
	      var numPixels = numBones * 3;
	      var width = Math.ceil(Math.sqrt(numPixels));
	      width = math.roundUp(width, 3);
	      var height = Math.ceil(numPixels / width);
	      this.boneTexture = new Texture(device, {
	        width: width,
	        height: height,
	        format: PIXELFORMAT_RGBA32F,
	        mipmaps: false,
	        minFilter: FILTER_NEAREST,
	        magFilter: FILTER_NEAREST,
	        name: 'skin'
	      });
	      this.matrixPalette = this.boneTexture.lock();
	    } else {
	      this.matrixPalette = new Float32Array(numBones * 12);
	    }
	  };

	  _proto.destroy = function destroy() {
	    if (this.boneTexture) {
	      this.boneTexture.destroy();
	      this.boneTexture = null;
	    }
	  };

	  _proto.resolve = function resolve(rootBone, entity) {
	    this.rootBone = rootBone;
	    var skin = this.skin;
	    var bones = [];

	    for (var j = 0; j < skin.boneNames.length; j++) {
	      var boneName = skin.boneNames[j];
	      var bone = rootBone.findByName(boneName);

	      if (!bone) {
	        bone = entity;
	      }

	      bones.push(bone);
	    }

	    this.bones = bones;
	  };

	  _proto.initSkin = function initSkin(skin) {
	    this.skin = skin;
	    this.bones = [];
	    var numBones = skin.inverseBindPose.length;
	    this.init(skin.device, numBones);
	    this.matrices = [];

	    for (var i = 0; i < numBones; i++) {
	      this.matrices[i] = new Mat4();
	    }
	  };

	  _proto.uploadBones = function uploadBones(device) {
	    if (device.supportsBoneTextures) {
	      this.boneTexture.lock();
	      this.boneTexture.unlock();
	    }
	  };

	  _proto._updateMatrices = function _updateMatrices(rootNode, skinUpdateIndex) {
	    if (this._skinUpdateIndex !== skinUpdateIndex) {
	      this._skinUpdateIndex = skinUpdateIndex;

	      _invMatrix.copy(rootNode.getWorldTransform()).invert();

	      for (var i = this.bones.length - 1; i >= 0; i--) {
	        this.matrices[i].mulAffine2(_invMatrix, this.bones[i].getWorldTransform());
	        this.matrices[i].mulAffine2(this.matrices[i], this.skin.inverseBindPose[i]);
	      }
	    }
	  };

	  _proto.updateMatrices = function updateMatrices(rootNode, skinUpdateIndex) {
	    if (this._updateBeforeCull) {
	      this._updateMatrices(rootNode, skinUpdateIndex);
	    }
	  };

	  _proto.updateMatrixPalette = function updateMatrixPalette(rootNode, skinUpdateIndex) {
	    this._updateMatrices(rootNode, skinUpdateIndex);

	    var mp = this.matrixPalette;
	    var count = this.bones.length;

	    for (var i = 0; i < count; i++) {
	      var pe = this.matrices[i].data;
	      var base = i * 12;
	      mp[base] = pe[0];
	      mp[base + 1] = pe[4];
	      mp[base + 2] = pe[8];
	      mp[base + 3] = pe[12];
	      mp[base + 4] = pe[1];
	      mp[base + 5] = pe[5];
	      mp[base + 6] = pe[9];
	      mp[base + 7] = pe[13];
	      mp[base + 8] = pe[2];
	      mp[base + 9] = pe[6];
	      mp[base + 10] = pe[10];
	      mp[base + 11] = pe[14];
	    }

	    this.uploadBones(this.skin.device);
	  };

	  _createClass(SkinInstance, [{
	    key: "rootBone",
	    get: function get() {
	      return this._rootBone;
	    },
	    set: function set(rootBone) {
	      this._rootBone = rootBone;
	    }
	  }]);

	  return SkinInstance;
	}();

	var SkinBatchInstance = function (_SkinInstance) {
	  _inheritsLoose(SkinBatchInstance, _SkinInstance);

	  function SkinBatchInstance(device, nodes, rootNode) {
	    var _this;

	    _this = _SkinInstance.call(this) || this;
	    var numBones = nodes.length;

	    _this.init(device, numBones);

	    _this.device = device;
	    _this.rootNode = rootNode;
	    _this.bones = nodes;
	    return _this;
	  }

	  var _proto = SkinBatchInstance.prototype;

	  _proto.updateMatrices = function updateMatrices(rootNode, skinUpdateIndex) {};

	  _proto.updateMatrixPalette = function updateMatrixPalette(rootNode, skinUpdateIndex) {
	    var mp = this.matrixPalette;
	    var count = this.bones.length;

	    for (var i = 0; i < count; i++) {
	      var pe = this.bones[i].getWorldTransform().data;
	      var base = i * 12;
	      mp[base] = pe[0];
	      mp[base + 1] = pe[4];
	      mp[base + 2] = pe[8];
	      mp[base + 3] = pe[12];
	      mp[base + 4] = pe[1];
	      mp[base + 5] = pe[5];
	      mp[base + 6] = pe[9];
	      mp[base + 7] = pe[13];
	      mp[base + 8] = pe[2];
	      mp[base + 9] = pe[6];
	      mp[base + 10] = pe[10];
	      mp[base + 11] = pe[14];
	    }

	    this.uploadBones(this.device);
	  };

	  return SkinBatchInstance;
	}(SkinInstance);

	var BindGroup = function () {
	  function BindGroup(graphicsDevice, format, defaultUniformBuffer) {
	    this.device = graphicsDevice;
	    this.format = format;
	    this.dirty = true;
	    this.impl = graphicsDevice.createBindGroupImpl(this);
	    this.textures = [];
	    this.uniformBuffers = [];
	    this.defaultUniformBuffer = defaultUniformBuffer;

	    if (defaultUniformBuffer) {
	      this.setUniformBuffer(UNIFORM_BUFFER_DEFAULT_SLOT_NAME, defaultUniformBuffer);
	    }
	  }

	  var _proto = BindGroup.prototype;

	  _proto.destroy = function destroy() {
	    this.impl.destroy();
	    this.impl = null;
	    this.format = null;
	    this.defaultUniformBuffer = null;
	  };

	  _proto.setUniformBuffer = function setUniformBuffer(name, uniformBuffer) {
	    var index = this.format.bufferFormatsMap.get(name);

	    if (this.uniformBuffers[index] !== uniformBuffer) {
	      this.uniformBuffers[index] = uniformBuffer;
	      this.dirty = true;
	    }
	  };

	  _proto.setTexture = function setTexture(name, texture) {
	    var index = this.format.textureFormatsMap.get(name);

	    if (this.textures[index] !== texture) {
	      this.textures[index] = texture;
	      this.dirty = true;
	    }
	  };

	  _proto.update = function update() {
	    var textureFormats = this.format.textureFormats;

	    for (var i = 0; i < textureFormats.length; i++) {
	      var textureFormat = textureFormats[i];
	      var value = textureFormat.scopeId.value;
	      this.setTexture(textureFormat.name, value);
	    }

	    if (this.dirty) {
	      this.dirty = false;
	      this.impl.update(this);
	    }
	  };

	  return BindGroup;
	}();

	var _updateFunctions = [];

	_updateFunctions[UNIFORMTYPE_FLOAT] = function (uniformBuffer, value, offset) {
	  var dst = uniformBuffer.storageFloat32;
	  dst[offset] = value;
	};

	_updateFunctions[UNIFORMTYPE_VEC2] = function (uniformBuffer, value, offset) {
	  var dst = uniformBuffer.storageFloat32;
	  dst[offset] = value[0];
	  dst[offset + 1] = value[1];
	};

	_updateFunctions[UNIFORMTYPE_VEC3] = function (uniformBuffer, value, offset) {
	  var dst = uniformBuffer.storageFloat32;
	  dst[offset] = value[0];
	  dst[offset + 1] = value[1];
	  dst[offset + 2] = value[2];
	};

	_updateFunctions[UNIFORMTYPE_VEC4] = function (uniformBuffer, value, offset) {
	  var dst = uniformBuffer.storageFloat32;
	  dst[offset] = value[0];
	  dst[offset + 1] = value[1];
	  dst[offset + 2] = value[2];
	  dst[offset + 3] = value[3];
	};

	_updateFunctions[UNIFORMTYPE_INT] = function (uniformBuffer, value, offset) {
	  var dst = uniformBuffer.storageInt32;
	  dst[offset] = value;
	};

	_updateFunctions[UNIFORMTYPE_IVEC2] = function (uniformBuffer, value, offset) {
	  var dst = uniformBuffer.storageInt32;
	  dst[offset] = value[0];
	  dst[offset + 1] = value[1];
	};

	_updateFunctions[UNIFORMTYPE_IVEC3] = function (uniformBuffer, value, offset) {
	  var dst = uniformBuffer.storageInt32;
	  dst[offset] = value[0];
	  dst[offset + 1] = value[1];
	  dst[offset + 2] = value[2];
	};

	_updateFunctions[UNIFORMTYPE_IVEC4] = function (uniformBuffer, value, offset) {
	  var dst = uniformBuffer.storageInt32;
	  dst[offset] = value[0];
	  dst[offset + 1] = value[1];
	  dst[offset + 2] = value[2];
	  dst[offset + 3] = value[3];
	};

	_updateFunctions[UNIFORMTYPE_MAT2] = function (uniformBuffer, value, offset) {
	  var dst = uniformBuffer.storageFloat32;
	  dst[offset] = value[0];
	  dst[offset + 1] = value[1];
	  dst[offset + 4] = value[2];
	  dst[offset + 5] = value[3];
	  dst[offset + 8] = value[4];
	  dst[offset + 9] = value[5];
	};

	_updateFunctions[UNIFORMTYPE_MAT3] = function (uniformBuffer, value, offset) {
	  var dst = uniformBuffer.storageFloat32;
	  dst[offset] = value[0];
	  dst[offset + 1] = value[1];
	  dst[offset + 2] = value[2];
	  dst[offset + 4] = value[3];
	  dst[offset + 5] = value[4];
	  dst[offset + 6] = value[5];
	  dst[offset + 8] = value[6];
	  dst[offset + 9] = value[7];
	  dst[offset + 10] = value[8];
	};

	var UniformBuffer = function () {
	  function UniformBuffer(graphicsDevice, format) {
	    this.device = graphicsDevice;
	    this.format = format;
	    this.impl = graphicsDevice.createUniformBufferImpl(this);
	    this.storage = new ArrayBuffer(format.byteSize);
	    this.storageFloat32 = new Float32Array(this.storage);
	    this.storageInt32 = new Int32Array(this.storage);
	    graphicsDevice._vram.ub += this.format.byteSize;
	  }

	  var _proto = UniformBuffer.prototype;

	  _proto.destroy = function destroy() {
	    var device = this.device;
	    this.impl.destroy(device);
	    device._vram.ub -= this.format.byteSize;
	  };

	  _proto.loseContext = function loseContext() {
	    this.impl.loseContext();
	  };

	  _proto.setUniform = function setUniform(uniformFormat) {
	    var offset = uniformFormat.offset;
	    var value = uniformFormat.scopeId.value;

	    if (value !== null && value !== undefined) {
	      var updateFunction = _updateFunctions[uniformFormat.type];

	      if (updateFunction) {
	        updateFunction(this, value, offset);
	      } else {
	        this.storageFloat32.set(value, offset);
	      }
	    }
	  };

	  _proto.set = function set(name) {
	    var uniformFormat = this.format.map.get(name);

	    if (uniformFormat) {
	      this.setUniform(uniformFormat);
	    }
	  };

	  _proto.update = function update() {
	    var uniforms = this.format.uniforms;

	    for (var i = 0; i < uniforms.length; i++) {
	      this.setUniform(uniforms[i]);
	    }

	    this.impl.unlock(this);
	  };

	  return UniformBuffer;
	}();

	var RefCountedCache = function () {
	  function RefCountedCache() {
	    this.cache = new Map();
	  }

	  var _proto = RefCountedCache.prototype;

	  _proto.destroy = function destroy() {
	    this.cache.forEach(function (refCount, object) {
	      object.destroy();
	    });
	    this.cache.clear();
	  };

	  _proto.incRef = function incRef(object) {
	    var refCount = (this.cache.get(object) || 0) + 1;
	    this.cache.set(object, refCount);
	  };

	  _proto.decRef = function decRef(object) {
	    if (object) {
	      var refCount = this.cache.get(object);

	      if (refCount) {
	        refCount--;

	        if (refCount === 0) {
	          this.cache.delete(object);
	          object.destroy();
	        } else {
	          this.cache.set(object, refCount);
	        }
	      }
	    }
	  };

	  return RefCountedCache;
	}();

	var LightmapCache = function () {
	  function LightmapCache() {}

	  LightmapCache.incRef = function incRef(texture) {
	    this.cache.incRef(texture);
	  };

	  LightmapCache.decRef = function decRef(texture) {
	    this.cache.decRef(texture);
	  };

	  LightmapCache.destroy = function destroy() {
	    this.cache.destroy();
	  };

	  return LightmapCache;
	}();

	LightmapCache.cache = new RefCountedCache();

	var _tmpAabb = new BoundingBox();

	var _tempBoneAabb = new BoundingBox();

	var _tempSphere = new BoundingSphere();

	var _meshSet = new Set();

	var InstancingData = function InstancingData(numObjects) {
	  this.vertexBuffer = null;
	  this.count = numObjects;
	};

	var Command = function () {
	  function Command(layer, blendType, command) {
	    this._key = [];
	    this._key[SORTKEY_FORWARD] = getKey(layer, blendType, true, 0);
	    this.command = command;
	  }

	  _createClass(Command, [{
	    key: "key",
	    get: function get() {
	      return this._key[SORTKEY_FORWARD];
	    },
	    set: function set(val) {
	      this._key[SORTKEY_FORWARD] = val;
	    }
	  }]);

	  return Command;
	}();

	var MeshInstance = function () {
	  function MeshInstance(mesh, material, node) {
	    if (node === void 0) {
	      node = null;
	    }

	    this._material = void 0;
	    this._shader = [];
	    this._bindGroups = [];

	    if (mesh instanceof GraphNode) {
	      var temp = mesh;
	      mesh = material;
	      material = node;
	      node = temp;
	    }

	    this._key = [0, 0];
	    this.isStatic = false;
	    this._staticLightList = null;
	    this._staticSource = null;
	    this.node = node;
	    this._mesh = mesh;
	    mesh.incRefCount();
	    this.material = material;
	    this._shaderDefs = MASK_AFFECT_DYNAMIC << 16;
	    this._shaderDefs |= mesh.vertexBuffer.format.hasUv0 ? SHADERDEF_UV0 : 0;
	    this._shaderDefs |= mesh.vertexBuffer.format.hasUv1 ? SHADERDEF_UV1 : 0;
	    this._shaderDefs |= mesh.vertexBuffer.format.hasColor ? SHADERDEF_VCOLOR : 0;
	    this._shaderDefs |= mesh.vertexBuffer.format.hasTangents ? SHADERDEF_TANGENTS : 0;
	    this._lightHash = 0;
	    this.visible = true;
	    this.layer = LAYER_WORLD;
	    this._renderStyle = RENDERSTYLE_SOLID;
	    this.castShadow = false;
	    this._receiveShadow = true;
	    this._screenSpace = false;
	    this._noDepthDrawGl1 = false;
	    this.cull = true;
	    this.pick = true;
	    this._updateAabb = true;
	    this._updateAabbFunc = null;
	    this._calculateSortDistance = null;
	    this.updateKey();
	    this._skinInstance = null;
	    this._morphInstance = null;
	    this.instancingData = null;
	    this._customAabb = null;
	    this.aabb = new BoundingBox();
	    this._aabbVer = -1;
	    this.drawOrder = 0;
	    this.visibleThisFrame = false;
	    this.isVisibleFunc = null;
	    this.parameters = {};
	    this.stencilFront = null;
	    this.stencilBack = null;
	    this.flipFaces = false;
	  }

	  var _proto = MeshInstance.prototype;

	  _proto.clearShaders = function clearShaders() {
	    var shaders = this._shader;

	    for (var i = 0; i < shaders.length; i++) {
	      shaders[i] = null;
	    }

	    this.destroyBindGroups();
	  };

	  _proto.destroyBindGroups = function destroyBindGroups() {
	    var groups = this._bindGroups;

	    for (var i = 0; i < groups.length; i++) {
	      var group = groups[i];

	      if (group) {
	        var uniformBuffer = group.defaultUniformBuffer;

	        if (uniformBuffer) {
	          uniformBuffer.destroy();
	        }

	        group.destroy();
	      }
	    }

	    groups.length = 0;
	  };

	  _proto.getBindGroup = function getBindGroup(device, pass) {
	    var bindGroup = this._bindGroups[pass];

	    if (!bindGroup) {
	      var shader = this._shader[pass];
	      var ubFormat = shader.meshUniformBufferFormat;
	      var uniformBuffer = new UniformBuffer(device, ubFormat);
	      var bingGroupFormat = shader.meshBindGroupFormat;
	      bindGroup = new BindGroup(device, bingGroupFormat, uniformBuffer);
	      this._bindGroups[pass] = bindGroup;
	    }

	    return bindGroup;
	  };

	  _proto.destroy = function destroy() {
	    var mesh = this.mesh;

	    if (mesh) {
	      this.mesh = null;

	      if (mesh.refCount < 1) {
	        mesh.destroy();
	      }
	    }

	    this.setRealtimeLightmap(MeshInstance.lightmapParamNames[0], null);
	    this.setRealtimeLightmap(MeshInstance.lightmapParamNames[1], null);

	    if (this._skinInstance) {
	      this._skinInstance.destroy();

	      this._skinInstance = null;
	    }

	    if (this.morphInstance) {
	      this.morphInstance.destroy();
	      this.morphInstance = null;
	    }

	    this.destroyBindGroups();
	    this.material = null;
	  };

	  MeshInstance._prepareRenderStyleForArray = function _prepareRenderStyleForArray(meshInstances, renderStyle) {
	    if (meshInstances) {
	      for (var i = 0; i < meshInstances.length; i++) {
	        meshInstances[i]._renderStyle = renderStyle;
	        var mesh = meshInstances[i].mesh;

	        if (!_meshSet.has(mesh)) {
	          _meshSet.add(mesh);

	          mesh.prepareRenderState(renderStyle);
	        }
	      }

	      _meshSet.clear();
	    }
	  };

	  _proto._isVisible = function _isVisible(camera) {
	    if (this.visible) {
	      if (this.isVisibleFunc) {
	        return this.isVisibleFunc(camera);
	      }

	      _tempSphere.center = this.aabb.center;
	      _tempSphere.radius = this._aabb.halfExtents.length();
	      return camera.frustum.containsSphere(_tempSphere);
	    }

	    return false;
	  };

	  _proto.updateKey = function updateKey() {
	    var material = this.material;
	    this._key[SORTKEY_FORWARD] = getKey(this.layer, material.alphaToCoverage || material.alphaTest ? BLEND_NORMAL : material.blendType, false, material.id);
	  };

	  _proto.setInstancing = function setInstancing(vertexBuffer) {
	    if (vertexBuffer) {
	      this.instancingData = new InstancingData(vertexBuffer.numVertices);
	      this.instancingData.vertexBuffer = vertexBuffer;
	      vertexBuffer.instancing = true;
	      this.cull = false;
	    } else {
	      this.instancingData = null;
	      this.cull = true;
	    }
	  };

	  _proto.updatePassShader = function updatePassShader(scene, pass, staticLightList, sortedLights, viewUniformFormat, viewBindGroupFormat) {
	    this._shader[pass] = this.material.getShaderVariant(this.mesh.device, scene, this._shaderDefs, staticLightList, pass, sortedLights, viewUniformFormat, viewBindGroupFormat);
	  };

	  _proto.ensureMaterial = function ensureMaterial(device) {
	    if (!this.material) {
	      this.material = getDefaultMaterial(device);
	    }
	  };

	  _proto.clearParameters = function clearParameters() {
	    this.parameters = {};
	  };

	  _proto.getParameters = function getParameters() {
	    return this.parameters;
	  };

	  _proto.getParameter = function getParameter(name) {
	    return this.parameters[name];
	  };

	  _proto.setParameter = function setParameter(name, data, passFlags) {
	    if (passFlags === void 0) {
	      passFlags = -262141;
	    }

	    if (data === undefined && typeof name === 'object') {
	      var uniformObject = name;

	      if (uniformObject.length) {
	        for (var i = 0; i < uniformObject.length; i++) {
	          this.setParameter(uniformObject[i]);
	        }

	        return;
	      }

	      name = uniformObject.name;
	      data = uniformObject.value;
	    }

	    var param = this.parameters[name];

	    if (param) {
	      param.data = data;
	      param.passFlags = passFlags;
	    } else {
	      this.parameters[name] = {
	        scopeId: null,
	        data: data,
	        passFlags: passFlags
	      };
	    }
	  };

	  _proto.setRealtimeLightmap = function setRealtimeLightmap(name, texture) {
	    var old = this.getParameter(name);
	    if (old === texture) return;

	    if (old) {
	      LightmapCache.decRef(old.data);
	    }

	    if (texture) {
	      LightmapCache.incRef(texture);
	      this.setParameter(name, texture);
	    } else {
	      this.deleteParameter(name);
	    }
	  };

	  _proto.deleteParameter = function deleteParameter(name) {
	    if (this.parameters[name]) {
	      delete this.parameters[name];
	    }
	  };

	  _proto.setParameters = function setParameters(device, passFlag) {
	    var parameters = this.parameters;

	    for (var paramName in parameters) {
	      var parameter = parameters[paramName];

	      if (parameter.passFlags & passFlag) {
	        if (!parameter.scopeId) {
	          parameter.scopeId = device.scope.resolve(paramName);
	        }

	        parameter.scopeId.setValue(parameter.data);
	      }
	    }
	  };

	  _proto.setLightmapped = function setLightmapped(value) {
	    if (value) {
	      this.mask = (this.mask | MASK_AFFECT_LIGHTMAPPED) & ~(MASK_AFFECT_DYNAMIC | MASK_BAKE);
	    } else {
	      this.setRealtimeLightmap(MeshInstance.lightmapParamNames[0], null);
	      this.setRealtimeLightmap(MeshInstance.lightmapParamNames[1], null);
	      this._shaderDefs &= ~(SHADERDEF_LM | SHADERDEF_DIRLM | SHADERDEF_LMAMBIENT);
	      this.mask = (this.mask | MASK_AFFECT_DYNAMIC) & ~(MASK_AFFECT_LIGHTMAPPED | MASK_BAKE);
	    }
	  };

	  _proto.setCustomAabb = function setCustomAabb(aabb) {
	    if (aabb) {
	      if (this._customAabb) {
	        this._customAabb.copy(aabb);
	      } else {
	        this._customAabb = aabb.clone();
	      }
	    } else {
	      this._customAabb = null;
	      this._aabbVer = -1;
	    }

	    this._setupSkinUpdate();
	  };

	  _proto._setupSkinUpdate = function _setupSkinUpdate() {
	    if (this._skinInstance) {
	      this._skinInstance._updateBeforeCull = !this._customAabb;
	    }
	  };

	  _createClass(MeshInstance, [{
	    key: "renderStyle",
	    get: function get() {
	      return this._renderStyle;
	    },
	    set: function set(renderStyle) {
	      this._renderStyle = renderStyle;
	      this.mesh.prepareRenderState(renderStyle);
	    }
	  }, {
	    key: "mesh",
	    get: function get() {
	      return this._mesh;
	    },
	    set: function set(mesh) {
	      if (mesh === this._mesh) return;

	      if (this._mesh) {
	        this._mesh.decRefCount();
	      }

	      this._mesh = mesh;

	      if (mesh) {
	        mesh.incRefCount();
	      }
	    }
	  }, {
	    key: "aabb",
	    get: function get() {
	      if (!this._updateAabb) {
	        return this._aabb;
	      }

	      if (this._updateAabbFunc) {
	        return this._updateAabbFunc(this._aabb);
	      }

	      var localAabb = this._customAabb;
	      var toWorldSpace = !!localAabb;

	      if (!localAabb) {
	        localAabb = _tmpAabb;

	        if (this.skinInstance) {
	          if (!this.mesh.boneAabb) {
	            var morphTargets = this._morphInstance ? this._morphInstance.morph._targets : null;

	            this.mesh._initBoneAabbs(morphTargets);
	          }

	          var boneUsed = this.mesh.boneUsed;
	          var first = true;

	          for (var i = 0; i < this.mesh.boneAabb.length; i++) {
	            if (boneUsed[i]) {
	              _tempBoneAabb.setFromTransformedAabb(this.mesh.boneAabb[i], this.skinInstance.matrices[i]);

	              if (first) {
	                first = false;
	                localAabb.center.copy(_tempBoneAabb.center);
	                localAabb.halfExtents.copy(_tempBoneAabb.halfExtents);
	              } else {
	                localAabb.add(_tempBoneAabb);
	              }
	            }
	          }

	          toWorldSpace = true;
	        } else if (this.node._aabbVer !== this._aabbVer) {
	          if (this.mesh) {
	            localAabb.center.copy(this.mesh.aabb.center);
	            localAabb.halfExtents.copy(this.mesh.aabb.halfExtents);
	          } else {
	            localAabb.center.set(0, 0, 0);
	            localAabb.halfExtents.set(0, 0, 0);
	          }

	          if (this.mesh && this.mesh.morph) {
	            localAabb._expand(this.mesh.morph.aabb.getMin(), this.mesh.morph.aabb.getMax());
	          }

	          toWorldSpace = true;
	          this._aabbVer = this.node._aabbVer;
	        }
	      }

	      if (toWorldSpace) {
	        this._aabb.setFromTransformedAabb(localAabb, this.node.getWorldTransform());
	      }

	      return this._aabb;
	    },
	    set: function set(aabb) {
	      this._aabb = aabb;
	    }
	  }, {
	    key: "material",
	    get: function get() {
	      return this._material;
	    },
	    set: function set(material) {
	      this.clearShaders();
	      var prevMat = this._material;

	      if (prevMat) {
	        prevMat.removeMeshInstanceRef(this);
	      }

	      this._material = material;

	      if (material) {
	        material.addMeshInstanceRef(this);
	        this.updateKey();
	        var prevBlend = prevMat && prevMat.transparent;

	        if (material.transparent !== prevBlend) {
	          var scene = this._material._scene || (prevMat == null ? void 0 : prevMat._scene);

	          if (scene) {
	            scene.layers._dirtyBlend = true;
	          } else {
	            material._dirtyBlend = true;
	          }
	        }
	      }
	    }
	  }, {
	    key: "layer",
	    get: function get() {
	      return this._layer;
	    },
	    set: function set(layer) {
	      this._layer = layer;
	      this.updateKey();
	    }
	  }, {
	    key: "calculateSortDistance",
	    get: function get() {
	      return this._calculateSortDistance;
	    },
	    set: function set(calculateSortDistance) {
	      this._calculateSortDistance = calculateSortDistance;
	    }
	  }, {
	    key: "receiveShadow",
	    get: function get() {
	      return this._receiveShadow;
	    },
	    set: function set(val) {
	      this._receiveShadow = val;
	      this._shaderDefs = val ? this._shaderDefs & ~SHADERDEF_NOSHADOW : this._shaderDefs | SHADERDEF_NOSHADOW;
	      this._shader[SHADER_FORWARD] = null;
	      this._shader[SHADER_FORWARDHDR] = null;
	    }
	  }, {
	    key: "skinInstance",
	    get: function get() {
	      return this._skinInstance;
	    },
	    set: function set(val) {
	      this._skinInstance = val;
	      this._shaderDefs = val ? this._shaderDefs | SHADERDEF_SKIN : this._shaderDefs & ~SHADERDEF_SKIN;

	      for (var i = 0; i < this._shader.length; i++) {
	        this._shader[i] = null;
	      }

	      this._setupSkinUpdate();
	    }
	  }, {
	    key: "morphInstance",
	    get: function get() {
	      return this._morphInstance;
	    },
	    set: function set(val) {
	      this._morphInstance = val;

	      if (this._morphInstance) {
	        this._morphInstance.meshInstance = this;
	      }

	      this._shaderDefs = val && val.morph.useTextureMorph ? this._shaderDefs | SHADERDEF_MORPH_TEXTURE_BASED : this._shaderDefs & ~SHADERDEF_MORPH_TEXTURE_BASED;
	      this._shaderDefs = val && val.morph.morphPositions ? this._shaderDefs | SHADERDEF_MORPH_POSITION : this._shaderDefs & ~SHADERDEF_MORPH_POSITION;
	      this._shaderDefs = val && val.morph.morphNormals ? this._shaderDefs | SHADERDEF_MORPH_NORMAL : this._shaderDefs & ~SHADERDEF_MORPH_NORMAL;

	      for (var i = 0; i < this._shader.length; i++) {
	        this._shader[i] = null;
	      }
	    }
	  }, {
	    key: "screenSpace",
	    get: function get() {
	      return this._screenSpace;
	    },
	    set: function set(val) {
	      this._screenSpace = val;
	      this._shaderDefs = val ? this._shaderDefs | SHADERDEF_SCREENSPACE : this._shaderDefs & ~SHADERDEF_SCREENSPACE;
	      this._shader[SHADER_FORWARD] = null;
	    }
	  }, {
	    key: "key",
	    get: function get() {
	      return this._key[SORTKEY_FORWARD];
	    },
	    set: function set(val) {
	      this._key[SORTKEY_FORWARD] = val;
	    }
	  }, {
	    key: "mask",
	    get: function get() {
	      return this._shaderDefs >> 16;
	    },
	    set: function set(val) {
	      var toggles = this._shaderDefs & 0x0000FFFF;
	      this._shaderDefs = toggles | val << 16;
	      this._shader[SHADER_FORWARD] = null;
	      this._shader[SHADER_FORWARDHDR] = null;
	    }
	  }, {
	    key: "instancingCount",
	    get: function get() {
	      return this.instancingData ? this.instancingData.count : 0;
	    },
	    set: function set(value) {
	      if (this.instancingData) this.instancingData.count = value;
	    }
	  }]);

	  return MeshInstance;
	}();

	MeshInstance.lightmapParamNames = ['texture_lightMap', 'texture_dirLightMap'];

	function getKey(layer, blendType, isCommand, materialId) {
	  return (layer & 0x0f) << 27 | (blendType === BLEND_NONE ? 1 : 0) << 26 | (isCommand ? 1 : 0) << 25 | (materialId & 0x1ffffff) << 0;
	}

	function paramsIdentical(a, b) {
	  if (a && !b) return false;
	  if (!a && b) return false;
	  a = a.data;
	  b = b.data;
	  if (a === b) return true;

	  if (a instanceof Float32Array && b instanceof Float32Array) {
	    if (a.length !== b.length) return false;

	    for (var i = 0; i < a.length; i++) {
	      if (a[i] !== b[i]) return false;
	    }

	    return true;
	  }

	  return false;
	}

	function equalParamSets(params1, params2) {
	  for (var param in params1) {
	    if (params1.hasOwnProperty(param) && !paramsIdentical(params1[param], params2[param])) return false;
	  }

	  for (var _param in params2) {
	    if (params2.hasOwnProperty(_param) && !paramsIdentical(params2[_param], params1[_param])) return false;
	  }

	  return true;
	}

	function equalLightLists(lightList1, lightList2) {
	  for (var k = 0; k < lightList1.length; k++) {
	    if (lightList2.indexOf(lightList1[k]) < 0) return false;
	  }

	  for (var _k = 0; _k < lightList2.length; _k++) {
	    if (lightList1.indexOf(lightList2[_k]) < 0) return false;
	  }

	  return true;
	}

	var mat3 = new Mat3();
	var worldMatX$1 = new Vec3();
	var worldMatY$1 = new Vec3();
	var worldMatZ$1 = new Vec3();

	function getScaleSign(mi) {
	  var wt = mi.node.worldTransform;
	  wt.getX(worldMatX$1);
	  wt.getY(worldMatY$1);
	  wt.getZ(worldMatZ$1);
	  worldMatX$1.cross(worldMatX$1, worldMatY$1);
	  return worldMatX$1.dot(worldMatZ$1) >= 0 ? 1 : -1;
	}

	var BatchManager = function () {
	  function BatchManager(device, root, scene) {
	    this.device = device;
	    this.rootNode = root;
	    this.scene = scene;
	    this._init = false;
	    this._batchGroups = {};
	    this._batchGroupCounter = 0;
	    this._batchList = [];
	    this._dirtyGroups = [];
	  }

	  var _proto = BatchManager.prototype;

	  _proto.destroy = function destroy() {
	    this.device = null;
	    this.rootNode = null;
	    this.scene = null;
	    this._batchGroups = {};
	    this._batchList = [];
	    this._dirtyGroups = [];
	  };

	  _proto.addGroup = function addGroup(name, dynamic, maxAabbSize, id, layers) {
	    if (id === undefined) {
	      id = this._batchGroupCounter;
	      this._batchGroupCounter++;
	    }

	    if (this._batchGroups[id]) {
	      return undefined;
	    }

	    var group = new BatchGroup(id, name, dynamic, maxAabbSize, layers);
	    this._batchGroups[id] = group;
	    return group;
	  };

	  _proto.removeGroup = function removeGroup(id) {
	    if (!this._batchGroups[id]) {
	      return;
	    }

	    var newBatchList = [];

	    for (var i = 0; i < this._batchList.length; i++) {
	      if (this._batchList[i].batchGroupId === id) {
	        this.destroyBatch(this._batchList[i]);
	      } else {
	        newBatchList.push(this._batchList[i]);
	      }
	    }

	    this._batchList = newBatchList;

	    this._removeModelsFromBatchGroup(this.rootNode, id);

	    delete this._batchGroups[id];
	  };

	  _proto.markGroupDirty = function markGroupDirty(id) {
	    if (this._dirtyGroups.indexOf(id) < 0) {
	      this._dirtyGroups.push(id);
	    }
	  };

	  _proto.getGroupByName = function getGroupByName(name) {
	    var groups = this._batchGroups;

	    for (var group in groups) {
	      if (!groups.hasOwnProperty(group)) continue;

	      if (groups[group].name === name) {
	        return groups[group];
	      }
	    }

	    return null;
	  };

	  _proto.getBatches = function getBatches(batchGroupId) {
	    var results = [];
	    var len = this._batchList.length;

	    for (var i = 0; i < len; i++) {
	      var batch = this._batchList[i];

	      if (batch.batchGroupId === batchGroupId) {
	        results.push(batch);
	      }
	    }

	    return results;
	  };

	  _proto._removeModelsFromBatchGroup = function _removeModelsFromBatchGroup(node, id) {
	    if (!node.enabled) return;

	    if (node.model && node.model.batchGroupId === id) {
	      node.model.batchGroupId = -1;
	    }

	    if (node.render && node.render.batchGroupId === id) {
	      node.render.batchGroupId = -1;
	    }

	    if (node.element && node.element.batchGroupId === id) {
	      node.element.batchGroupId = -1;
	    }

	    if (node.sprite && node.sprite.batchGroupId === id) {
	      node.sprite.batchGroupId = -1;
	    }

	    for (var i = 0; i < node._children.length; i++) {
	      this._removeModelsFromBatchGroup(node._children[i], id);
	    }
	  };

	  _proto.insert = function insert(type, groupId, node) {
	    var group = this._batchGroups[groupId];

	    if (group) {
	      if (group._obj[type].indexOf(node) < 0) {
	        group._obj[type].push(node);

	        this.markGroupDirty(groupId);
	      }
	    }
	  };

	  _proto.remove = function remove(type, groupId, node) {
	    var group = this._batchGroups[groupId];

	    if (group) {
	      var idx = group._obj[type].indexOf(node);

	      if (idx >= 0) {
	        group._obj[type].splice(idx, 1);

	        this.markGroupDirty(groupId);
	      }
	    }
	  };

	  _proto._extractRender = function _extractRender(node, arr, group, groupMeshInstances) {
	    if (node.render) {
	      if (node.render.isStatic) {
	        var drawCalls = this.scene.drawCalls;
	        var nodeMeshInstances = node.render.meshInstances;

	        for (var i = 0; i < drawCalls.length; i++) {
	          if (!drawCalls[i]._staticSource) continue;
	          if (nodeMeshInstances.indexOf(drawCalls[i]._staticSource) < 0) continue;
	          arr.push(drawCalls[i]);
	        }

	        for (var _i = 0; _i < nodeMeshInstances.length; _i++) {
	          if (drawCalls.indexOf(nodeMeshInstances[_i]) >= 0) {
	            arr.push(nodeMeshInstances[_i]);
	          }
	        }
	      } else {
	        arr = groupMeshInstances[node.render.batchGroupId] = arr.concat(node.render.meshInstances);
	      }

	      node.render.removeFromLayers();
	    }

	    return arr;
	  };

	  _proto._extractModel = function _extractModel(node, arr, group, groupMeshInstances) {
	    if (node.model && node.model.model) {
	      if (node.model.isStatic) {
	        var drawCalls = this.scene.drawCalls;
	        var nodeMeshInstances = node.model.meshInstances;

	        for (var i = 0; i < drawCalls.length; i++) {
	          if (!drawCalls[i]._staticSource) continue;
	          if (nodeMeshInstances.indexOf(drawCalls[i]._staticSource) < 0) continue;
	          arr.push(drawCalls[i]);
	        }

	        for (var _i2 = 0; _i2 < nodeMeshInstances.length; _i2++) {
	          if (drawCalls.indexOf(nodeMeshInstances[_i2]) >= 0) {
	            arr.push(nodeMeshInstances[_i2]);
	          }
	        }
	      } else {
	        arr = groupMeshInstances[node.model.batchGroupId] = arr.concat(node.model.meshInstances);
	      }

	      node.model.removeModelFromLayers();
	    }

	    return arr;
	  };

	  _proto._extractElement = function _extractElement(node, arr, group) {
	    if (!node.element) return;
	    var valid = false;

	    if (node.element._text && node.element._text._model.meshInstances.length > 0) {
	      arr.push(node.element._text._model.meshInstances[0]);
	      node.element.removeModelFromLayers(node.element._text._model);
	      valid = true;
	    } else if (node.element._image) {
	      arr.push(node.element._image._renderable.meshInstance);
	      node.element.removeModelFromLayers(node.element._image._renderable.model);

	      if (node.element._image._renderable.unmaskMeshInstance) {
	        arr.push(node.element._image._renderable.unmaskMeshInstance);

	        if (!node.element._image._renderable.unmaskMeshInstance.stencilFront || !node.element._image._renderable.unmaskMeshInstance.stencilBack) {
	          node.element._dirtifyMask();

	          node.element._onPrerender();
	        }
	      }

	      valid = true;
	    }

	    if (valid) {
	      group._ui = true;
	    }
	  };

	  _proto._collectAndRemoveMeshInstances = function _collectAndRemoveMeshInstances(groupMeshInstances, groupIds) {
	    for (var g = 0; g < groupIds.length; g++) {
	      var id = groupIds[g];
	      var group = this._batchGroups[id];
	      if (!group) continue;
	      var arr = groupMeshInstances[id];
	      if (!arr) arr = groupMeshInstances[id] = [];

	      for (var m = 0; m < group._obj.model.length; m++) {
	        arr = this._extractModel(group._obj.model[m], arr, group, groupMeshInstances);
	      }

	      for (var r = 0; r < group._obj.render.length; r++) {
	        arr = this._extractRender(group._obj.render[r], arr, group, groupMeshInstances);
	      }

	      for (var e = 0; e < group._obj.element.length; e++) {
	        this._extractElement(group._obj.element[e], arr, group);
	      }

	      for (var s = 0; s < group._obj.sprite.length; s++) {
	        var node = group._obj.sprite[s];

	        if (node.sprite && node.sprite._meshInstance && (group.dynamic || node.sprite.sprite._renderMode === SPRITE_RENDERMODE_SIMPLE)) {
	          arr.push(node.sprite._meshInstance);
	          node.sprite.removeModelFromLayers();
	          group._sprite = true;
	          node.sprite._batchGroup = group;
	        }
	      }
	    }
	  };

	  _proto.generate = function generate(groupIds) {
	    var groupMeshInstances = {};

	    if (!groupIds) {
	      groupIds = Object.keys(this._batchGroups);
	    }

	    var newBatchList = [];

	    for (var i = 0; i < this._batchList.length; i++) {
	      if (groupIds.indexOf(this._batchList[i].batchGroupId) < 0) {
	        newBatchList.push(this._batchList[i]);
	        continue;
	      }

	      this.destroyBatch(this._batchList[i]);
	    }

	    this._batchList = newBatchList;

	    this._collectAndRemoveMeshInstances(groupMeshInstances, groupIds);

	    if (groupIds === this._dirtyGroups) {
	      this._dirtyGroups.length = 0;
	    } else {
	      var newDirtyGroups = [];

	      for (var _i3 = 0; _i3 < this._dirtyGroups.length; _i3++) {
	        if (groupIds.indexOf(this._dirtyGroups[_i3]) < 0) newDirtyGroups.push(this._dirtyGroups[_i3]);
	      }

	      this._dirtyGroups = newDirtyGroups;
	    }

	    var group, lists, groupData, batch;

	    for (var groupId in groupMeshInstances) {
	      if (!groupMeshInstances.hasOwnProperty(groupId)) continue;
	      group = groupMeshInstances[groupId];
	      groupData = this._batchGroups[groupId];

	      if (!groupData) {
	        continue;
	      }

	      lists = this.prepare(group, groupData.dynamic, groupData.maxAabbSize, groupData._ui || groupData._sprite);

	      for (var _i4 = 0; _i4 < lists.length; _i4++) {
	        batch = this.create(lists[_i4], groupData.dynamic, parseInt(groupId, 10));

	        if (batch) {
	          batch.addToLayers(this.scene, groupData.layers);
	        }
	      }
	    }
	  };

	  _proto.prepare = function prepare(meshInstances, dynamic, maxAabbSize, translucent) {
	    if (maxAabbSize === void 0) {
	      maxAabbSize = Number.POSITIVE_INFINITY;
	    }

	    if (meshInstances.length === 0) return [];
	    var halfMaxAabbSize = maxAabbSize * 0.5;
	    var maxInstanceCount = this.device.supportsBoneTextures ? 1024 : this.device.boneLimit;
	    var maxNumVertices = this.device.extUintElement ? 0xffffffff : 0xffff;
	    var aabb = new BoundingBox();
	    var testAabb = new BoundingBox();
	    var skipTranslucentAabb = null;
	    var sf;
	    var lists = [];
	    var j = 0;

	    if (translucent) {
	      meshInstances.sort(function (a, b) {
	        return a.drawOrder - b.drawOrder;
	      });
	    }

	    var meshInstancesLeftA = meshInstances;
	    var meshInstancesLeftB;
	    var skipMesh = translucent ? function (mi) {
	      if (skipTranslucentAabb) {
	        skipTranslucentAabb.add(mi.aabb);
	      } else {
	        skipTranslucentAabb = mi.aabb.clone();
	      }

	      meshInstancesLeftB.push(mi);
	    } : function (mi) {
	      meshInstancesLeftB.push(mi);
	    };

	    while (meshInstancesLeftA.length > 0) {
	      lists[j] = [meshInstancesLeftA[0]];
	      meshInstancesLeftB = [];
	      var material = meshInstancesLeftA[0].material;
	      var layer = meshInstancesLeftA[0].layer;
	      var defs = meshInstancesLeftA[0]._shaderDefs;
	      var params = meshInstancesLeftA[0].parameters;
	      var stencil = meshInstancesLeftA[0].stencilFront;
	      var lightList = meshInstancesLeftA[0]._staticLightList;
	      var vertCount = meshInstancesLeftA[0].mesh.vertexBuffer.getNumVertices();
	      var drawOrder = meshInstancesLeftA[0].drawOrder;
	      aabb.copy(meshInstancesLeftA[0].aabb);
	      var scaleSign = getScaleSign(meshInstancesLeftA[0]);
	      var vertexFormatBatchingHash = meshInstancesLeftA[0].mesh.vertexBuffer.format.batchingHash;
	      var indexed = meshInstancesLeftA[0].mesh.primitive[0].indexed;
	      skipTranslucentAabb = null;

	      for (var i = 1; i < meshInstancesLeftA.length; i++) {
	        var mi = meshInstancesLeftA[i];

	        if (dynamic && lists[j].length >= maxInstanceCount) {
	          meshInstancesLeftB = meshInstancesLeftB.concat(meshInstancesLeftA.slice(i));
	          break;
	        }

	        if (material !== mi.material || layer !== mi.layer || vertexFormatBatchingHash !== mi.mesh.vertexBuffer.format.batchingHash || indexed !== mi.mesh.primitive[0].indexed || defs !== mi._shaderDefs || vertCount + mi.mesh.vertexBuffer.getNumVertices() > maxNumVertices) {
	          skipMesh(mi);
	          continue;
	        }

	        testAabb.copy(aabb);
	        testAabb.add(mi.aabb);

	        if (testAabb.halfExtents.x > halfMaxAabbSize || testAabb.halfExtents.y > halfMaxAabbSize || testAabb.halfExtents.z > halfMaxAabbSize) {
	          skipMesh(mi);
	          continue;
	        }

	        if (stencil) {
	          if (!(sf = mi.stencilFront) || stencil.func !== sf.func || stencil.zpass !== sf.zpass) {
	            skipMesh(mi);
	            continue;
	          }
	        }

	        if (scaleSign !== getScaleSign(mi)) {
	          skipMesh(mi);
	          continue;
	        }

	        if (!equalParamSets(params, mi.parameters)) {
	          skipMesh(mi);
	          continue;
	        }

	        var staticLights = mi._staticLightList;

	        if (lightList && staticLights) {
	          if (!equalLightLists(lightList, staticLights)) {
	            skipMesh(mi);
	            continue;
	          }
	        } else if (lightList || staticLights) {
	          skipMesh(mi);
	          continue;
	        }

	        if (translucent && skipTranslucentAabb && skipTranslucentAabb.intersects(mi.aabb) && mi.drawOrder !== drawOrder) {
	          skipMesh(mi);
	          continue;
	        }

	        aabb.add(mi.aabb);
	        vertCount += mi.mesh.vertexBuffer.getNumVertices();
	        lists[j].push(mi);
	      }

	      j++;
	      meshInstancesLeftA = meshInstancesLeftB;
	    }

	    return lists;
	  };

	  _proto.collectBatchedMeshData = function collectBatchedMeshData(meshInstances, dynamic) {
	    var streams = null;
	    var batchNumVerts = 0;
	    var batchNumIndices = 0;
	    var material = null;

	    for (var i = 0; i < meshInstances.length; i++) {
	      if (meshInstances[i].visible) {
	        var mesh = meshInstances[i].mesh;
	        var numVerts = mesh.vertexBuffer.numVertices;
	        batchNumVerts += numVerts;
	        batchNumIndices += mesh.primitive[0].indexed ? mesh.primitive[0].count : mesh.primitive[0].type === PRIMITIVE_TRIFAN && mesh.primitive[0].count === 4 ? 6 : 0;

	        if (!streams) {
	          material = meshInstances[i].material;
	          streams = {};
	          var elems = mesh.vertexBuffer.format.elements;

	          for (var j = 0; j < elems.length; j++) {
	            var semantic = elems[j].name;
	            streams[semantic] = {
	              numComponents: elems[j].numComponents,
	              dataType: elems[j].dataType,
	              normalize: elems[j].normalize,
	              count: 0
	            };
	          }

	          if (dynamic) {
	            streams[SEMANTIC_BLENDINDICES] = {
	              numComponents: 1,
	              dataType: TYPE_FLOAT32,
	              normalize: false,
	              count: 0
	            };
	          }
	        }
	      }
	    }

	    return {
	      streams: streams,
	      batchNumVerts: batchNumVerts,
	      batchNumIndices: batchNumIndices,
	      material: material
	    };
	  };

	  _proto.create = function create(meshInstances, dynamic, batchGroupId) {
	    if (!this._init) {
	      var boneLimit = '#define BONE_LIMIT ' + this.device.getBoneLimit() + '\n';
	      this.transformVS = boneLimit + '#define DYNAMICBATCH\n' + shaderChunks.transformVS;
	      this.skinTexVS = shaderChunks.skinBatchTexVS;
	      this.skinConstVS = shaderChunks.skinBatchConstVS;
	      this.vertexFormats = {};
	      this._init = true;
	    }

	    var stream = null;
	    var semantic;
	    var mesh, numVerts;
	    var batch = null;
	    var batchData = this.collectBatchedMeshData(meshInstances, dynamic);

	    if (batchData.streams) {
	      var streams = batchData.streams;
	      var material = batchData.material;
	      var batchNumVerts = batchData.batchNumVerts;
	      var batchNumIndices = batchData.batchNumIndices;
	      batch = new Batch(meshInstances, dynamic, batchGroupId);

	      this._batchList.push(batch);

	      var indexBase, numIndices, indexData;
	      var verticesOffset = 0;
	      var indexOffset = 0;
	      var transform;
	      var vec = new Vec3();
	      var indexArrayType = batchNumVerts <= 0xffff ? Uint16Array : Uint32Array;
	      var indices = new indexArrayType(batchNumIndices);

	      for (semantic in streams) {
	        stream = streams[semantic];
	        stream.typeArrayType = typedArrayTypes[stream.dataType];
	        stream.elementByteSize = typedArrayTypesByteSize[stream.dataType];
	        stream.buffer = new stream.typeArrayType(batchNumVerts * stream.numComponents);
	      }

	      for (var i = 0; i < meshInstances.length; i++) {
	        if (!meshInstances[i].visible) continue;
	        mesh = meshInstances[i].mesh;
	        numVerts = mesh.vertexBuffer.numVertices;

	        if (!dynamic) {
	          transform = meshInstances[i].node.getWorldTransform();
	        }

	        for (semantic in streams) {
	          if (semantic !== SEMANTIC_BLENDINDICES) {
	            stream = streams[semantic];
	            var subarray = new stream.typeArrayType(stream.buffer.buffer, stream.elementByteSize * stream.count);
	            var totalComponents = mesh.getVertexStream(semantic, subarray) * stream.numComponents;
	            stream.count += totalComponents;

	            if (!dynamic && stream.numComponents >= 3) {
	              if (semantic === SEMANTIC_POSITION) {
	                for (var j = 0; j < totalComponents; j += stream.numComponents) {
	                  vec.set(subarray[j], subarray[j + 1], subarray[j + 2]);
	                  transform.transformPoint(vec, vec);
	                  subarray[j] = vec.x;
	                  subarray[j + 1] = vec.y;
	                  subarray[j + 2] = vec.z;
	                }
	              } else if (semantic === SEMANTIC_NORMAL || semantic === SEMANTIC_TANGENT) {
	                transform.invertTo3x3(mat3);
	                mat3.transpose();

	                for (var _j = 0; _j < totalComponents; _j += stream.numComponents) {
	                  vec.set(subarray[_j], subarray[_j + 1], subarray[_j + 2]);
	                  mat3.transformVector(vec, vec);
	                  subarray[_j] = vec.x;
	                  subarray[_j + 1] = vec.y;
	                  subarray[_j + 2] = vec.z;
	                }
	              }
	            }
	          }
	        }

	        if (dynamic) {
	          stream = streams[SEMANTIC_BLENDINDICES];

	          for (var _j2 = 0; _j2 < numVerts; _j2++) {
	            stream.buffer[stream.count++] = i;
	          }
	        }

	        if (mesh.primitive[0].indexed) {
	          indexBase = mesh.primitive[0].base;
	          numIndices = mesh.primitive[0].count;
	          var srcFormat = mesh.indexBuffer[0].getFormat();
	          indexData = new typedArrayIndexFormats[srcFormat](mesh.indexBuffer[0].storage);
	        } else if (mesh.primitive[0].type === PRIMITIVE_TRIFAN && mesh.primitive[0].count === 4) {
	          indexBase = 0;
	          numIndices = 6;
	          indexData = [0, 1, 3, 2, 3, 1];
	        } else {
	          numIndices = 0;
	          continue;
	        }

	        for (var _j3 = 0; _j3 < numIndices; _j3++) {
	          indices[_j3 + indexOffset] = indexData[indexBase + _j3] + verticesOffset;
	        }

	        indexOffset += numIndices;
	        verticesOffset += numVerts;
	      }

	      mesh = new Mesh(this.device);

	      for (semantic in streams) {
	        stream = streams[semantic];
	        mesh.setVertexStream(semantic, stream.buffer, stream.numComponents, undefined, stream.dataType, stream.normalize);
	      }

	      if (indices.length > 0) mesh.setIndices(indices);
	      mesh.update(PRIMITIVE_TRIANGLES, false);

	      if (dynamic) {
	        material = material.clone();
	        material.chunks.transformVS = this.transformVS;
	        material.chunks.skinTexVS = this.skinTexVS;
	        material.chunks.skinConstVS = this.skinConstVS;
	        material.update();
	      }

	      var meshInstance = new MeshInstance(mesh, material, this.rootNode);
	      meshInstance.castShadow = batch.origMeshInstances[0].castShadow;
	      meshInstance.parameters = batch.origMeshInstances[0].parameters;
	      meshInstance.isStatic = batch.origMeshInstances[0].isStatic;
	      meshInstance.layer = batch.origMeshInstances[0].layer;
	      meshInstance._staticLightList = batch.origMeshInstances[0]._staticLightList;
	      meshInstance._shaderDefs = batch.origMeshInstances[0]._shaderDefs;
	      meshInstance.cull = batch.origMeshInstances[0].cull;
	      var batchGroup = this._batchGroups[batchGroupId];
	      if (batchGroup && batchGroup._ui) meshInstance.cull = false;

	      if (dynamic) {
	        var nodes = [];

	        for (var _i5 = 0; _i5 < batch.origMeshInstances.length; _i5++) {
	          nodes.push(batch.origMeshInstances[_i5].node);
	        }

	        meshInstance.skinInstance = new SkinBatchInstance(this.device, nodes, this.rootNode);
	      }

	      meshInstance._updateAabb = false;
	      meshInstance.drawOrder = batch.origMeshInstances[0].drawOrder;
	      meshInstance.stencilFront = batch.origMeshInstances[0].stencilFront;
	      meshInstance.stencilBack = batch.origMeshInstances[0].stencilBack;
	      meshInstance.flipFaces = getScaleSign(batch.origMeshInstances[0]) < 0;
	      meshInstance.castShadow = batch.origMeshInstances[0].castShadow;
	      batch.meshInstance = meshInstance;
	      batch.updateBoundingBox();
	    }

	    return batch;
	  };

	  _proto.updateAll = function updateAll() {
	    if (this._dirtyGroups.length > 0) {
	      this.generate(this._dirtyGroups);
	    }

	    for (var i = 0; i < this._batchList.length; i++) {
	      if (!this._batchList[i].dynamic) continue;

	      this._batchList[i].updateBoundingBox();
	    }
	  };

	  _proto.clone = function clone(batch, clonedMeshInstances) {
	    var batch2 = new Batch(clonedMeshInstances, batch.dynamic, batch.batchGroupId);

	    this._batchList.push(batch2);

	    var nodes = [];

	    for (var i = 0; i < clonedMeshInstances.length; i++) {
	      nodes.push(clonedMeshInstances[i].node);
	    }

	    batch2.meshInstance = new MeshInstance(batch.meshInstance.mesh, batch.meshInstance.material, batch.meshInstance.node);
	    batch2.meshInstance._updateAabb = false;
	    batch2.meshInstance.parameters = clonedMeshInstances[0].parameters;
	    batch2.meshInstance.isStatic = clonedMeshInstances[0].isStatic;
	    batch2.meshInstance.cull = clonedMeshInstances[0].cull;
	    batch2.meshInstance.layer = clonedMeshInstances[0].layer;
	    batch2.meshInstance._staticLightList = clonedMeshInstances[0]._staticLightList;

	    if (batch.dynamic) {
	      batch2.meshInstance.skinInstance = new SkinBatchInstance(this.device, nodes, this.rootNode);
	    }

	    batch2.meshInstance.castShadow = batch.meshInstance.castShadow;
	    batch2.meshInstance._shader = batch.meshInstance._shader.slice();
	    batch2.meshInstance.castShadow = batch.meshInstance.castShadow;
	    return batch2;
	  };

	  _proto.destroyBatch = function destroyBatch(batch) {
	    batch.destroy(this.scene, this._batchGroups[batch.batchGroupId].layers);
	  };

	  return BatchManager;
	}();

	var tempVec3 = new Vec3();
	var tempMin3 = new Vec3();
	var tempMax3 = new Vec3();
	var tempBox = new BoundingBox();
	var epsilon = 0.000001;

	var ClusterLight = function ClusterLight() {
	  this.light = null;
	  this.min = new Vec3();
	  this.max = new Vec3();
	};

	var WorldClusters = function () {
	  function WorldClusters(device) {
	    this.device = device;
	    this.name = 'Untitled';
	    this.reportCount = 0;
	    this.boundsMin = new Vec3();
	    this.boundsMax = new Vec3();
	    this.boundsDelta = new Vec3();
	    this._cells = new Vec3(1, 1, 1);
	    this._cellsLimit = new Vec3();
	    this.cells = this._cells;
	    this._maxCellLightCount = 0;
	    this._pixelsPerCellCount = 0;
	    this.maxCellLightCount = 4;
	    this._maxAttenuation = 0;
	    this._maxColorValue = 0;
	    this._usedLights = [];

	    this._usedLights.push(new ClusterLight());

	    this.lightsBuffer = new LightsBuffer(device);
	    this.registerUniforms(device);
	  }

	  var _proto = WorldClusters.prototype;

	  _proto.destroy = function destroy() {
	    this.lightsBuffer.destroy();
	    this.releaseClusterTexture();
	  };

	  _proto.releaseClusterTexture = function releaseClusterTexture() {
	    if (this.clusterTexture) {
	      this.clusterTexture.destroy();
	      this.clusterTexture = null;
	    }
	  };

	  _proto.registerUniforms = function registerUniforms(device) {
	    this._clusterWorldTextureId = device.scope.resolve('clusterWorldTexture');
	    this._clusterPixelsPerCellId = device.scope.resolve('clusterPixelsPerCell');
	    this._clusterTextureSizeId = device.scope.resolve('clusterTextureSize');
	    this._clusterTextureSizeData = new Float32Array(3);
	    this._clusterBoundsMinId = device.scope.resolve('clusterBoundsMin');
	    this._clusterBoundsMinData = new Float32Array(3);
	    this._clusterBoundsDeltaId = device.scope.resolve('clusterBoundsDelta');
	    this._clusterBoundsDeltaData = new Float32Array(3);
	    this._clusterCellsCountByBoundsSizeId = device.scope.resolve('clusterCellsCountByBoundsSize');
	    this._clusterCellsCountByBoundsSizeData = new Float32Array(3);
	    this._clusterCellsDotId = device.scope.resolve('clusterCellsDot');
	    this._clusterCellsDotData = new Float32Array(3);
	    this._clusterCellsMaxId = device.scope.resolve('clusterCellsMax');
	    this._clusterCellsMaxData = new Float32Array(3);
	    this._clusterCompressionLimit0Id = device.scope.resolve('clusterCompressionLimit0');
	    this._clusterCompressionLimit0Data = new Float32Array(2);
	  };

	  _proto.updateParams = function updateParams(lightingParams) {
	    if (lightingParams) {
	      this.cells = lightingParams.cells;
	      this.maxCellLightCount = lightingParams.maxLightsPerCell;
	      this.lightsBuffer.cookiesEnabled = lightingParams.cookiesEnabled;
	      this.lightsBuffer.shadowsEnabled = lightingParams.shadowsEnabled;
	      this.lightsBuffer.areaLightsEnabled = lightingParams.areaLightsEnabled;
	    }
	  };

	  _proto.updateCells = function updateCells() {
	    if (this._cellsDirty) {
	      this._cellsDirty = false;
	      var cx = this._cells.x;
	      var cy = this._cells.y;
	      var cz = this._cells.z;
	      var numCells = cx * cy * cz;
	      var totalPixels = this._pixelsPerCellCount * numCells;
	      var width = Math.ceil(Math.sqrt(totalPixels));
	      width = math.roundUp(width, this._pixelsPerCellCount);
	      var height = Math.ceil(totalPixels / width);
	      this._clusterCellsMaxData[0] = cx;
	      this._clusterCellsMaxData[1] = cy;
	      this._clusterCellsMaxData[2] = cz;
	      this._clusterCellsDotData[0] = this._pixelsPerCellCount;
	      this._clusterCellsDotData[1] = cx * cz * this._pixelsPerCellCount;
	      this._clusterCellsDotData[2] = cx * this._pixelsPerCellCount;
	      this.clusters = new Uint8ClampedArray(4 * totalPixels);
	      this.counts = new Int32Array(numCells);
	      this._clusterTextureSizeData[0] = width;
	      this._clusterTextureSizeData[1] = 1.0 / width;
	      this._clusterTextureSizeData[2] = 1.0 / height;
	      this.releaseClusterTexture();
	      this.clusterTexture = LightsBuffer.createTexture(this.device, width, height, PIXELFORMAT_R8_G8_B8_A8, 'ClusterTexture');
	    }
	  };

	  _proto.uploadTextures = function uploadTextures() {
	    this.clusterTexture.lock().set(this.clusters);
	    this.clusterTexture.unlock();
	    this.lightsBuffer.uploadTextures();
	  };

	  _proto.updateUniforms = function updateUniforms() {
	    this.lightsBuffer.updateUniforms();

	    this._clusterWorldTextureId.setValue(this.clusterTexture);

	    var boundsDelta = this.boundsDelta;
	    this._clusterCellsCountByBoundsSizeData[0] = this._cells.x / boundsDelta.x;
	    this._clusterCellsCountByBoundsSizeData[1] = this._cells.y / boundsDelta.y;
	    this._clusterCellsCountByBoundsSizeData[2] = this._cells.z / boundsDelta.z;

	    this._clusterCellsCountByBoundsSizeId.setValue(this._clusterCellsCountByBoundsSizeData);

	    this._clusterBoundsMinData[0] = this.boundsMin.x;
	    this._clusterBoundsMinData[1] = this.boundsMin.y;
	    this._clusterBoundsMinData[2] = this.boundsMin.z;
	    this._clusterBoundsDeltaData[0] = boundsDelta.x;
	    this._clusterBoundsDeltaData[1] = boundsDelta.y;
	    this._clusterBoundsDeltaData[2] = boundsDelta.z;
	    this._clusterCompressionLimit0Data[0] = this._maxAttenuation;
	    this._clusterCompressionLimit0Data[1] = this._maxColorValue;

	    this._clusterPixelsPerCellId.setValue(this._pixelsPerCellCount);

	    this._clusterTextureSizeId.setValue(this._clusterTextureSizeData);

	    this._clusterBoundsMinId.setValue(this._clusterBoundsMinData);

	    this._clusterBoundsDeltaId.setValue(this._clusterBoundsDeltaData);

	    this._clusterCellsDotId.setValue(this._clusterCellsDotData);

	    this._clusterCellsMaxId.setValue(this._clusterCellsMaxData);

	    this._clusterCompressionLimit0Id.setValue(this._clusterCompressionLimit0Data);
	  };

	  _proto.evalLightCellMinMax = function evalLightCellMinMax(clusteredLight, min, max) {
	    min.copy(clusteredLight.min);
	    min.sub(this.boundsMin);
	    min.div(this.boundsDelta);
	    min.mul2(min, this.cells);
	    min.floor();
	    max.copy(clusteredLight.max);
	    max.sub(this.boundsMin);
	    max.div(this.boundsDelta);
	    max.mul2(max, this.cells);
	    max.ceil();
	    min.max(Vec3.ZERO);
	    max.min(this._cellsLimit);
	  };

	  _proto.collectLights = function collectLights(lights) {
	    var maxLights = this.lightsBuffer.maxLights;
	    var usedLights = this._usedLights;
	    var lightIndex = 1;

	    for (var i = 0; i < lights.length; i++) {
	      var light = lights[i];
	      var runtimeLight = !!(light.mask & (MASK_AFFECT_DYNAMIC | MASK_AFFECT_LIGHTMAPPED));

	      if (light.enabled && light.type !== LIGHTTYPE_DIRECTIONAL && light.visibleThisFrame && light.intensity > 0 && runtimeLight) {
	        if (lightIndex < maxLights) {
	          var clusteredLight = void 0;

	          if (lightIndex < usedLights.length) {
	            clusteredLight = usedLights[lightIndex];
	          } else {
	            clusteredLight = new ClusterLight();
	            usedLights.push(clusteredLight);
	          }

	          clusteredLight.light = light;
	          light.getBoundingBox(tempBox);
	          clusteredLight.min.copy(tempBox.getMin());
	          clusteredLight.max.copy(tempBox.getMax());
	          lightIndex++;
	        } else {
	          console.warn("Clustered lighting: more than " + (maxLights - 1) + " lights in the frame, ignoring some.");
	          break;
	        }
	      }
	    }

	    usedLights.length = lightIndex;
	  };

	  _proto.evaluateBounds = function evaluateBounds() {
	    var usedLights = this._usedLights;
	    var min = this.boundsMin;
	    var max = this.boundsMax;

	    if (usedLights.length > 1) {
	      min.copy(usedLights[1].min);
	      max.copy(usedLights[1].max);

	      for (var i = 2; i < usedLights.length; i++) {
	        min.min(usedLights[i].min);
	        max.max(usedLights[i].max);
	      }
	    } else {
	      min.set(0, 0, 0);
	      max.set(1, 1, 1);
	    }

	    this.boundsDelta.sub2(max, min);
	    this.lightsBuffer.setBounds(min, this.boundsDelta);
	  };

	  _proto.evaluateCompressionLimits = function evaluateCompressionLimits(gammaCorrection) {
	    var maxAttenuation = 0;
	    var maxColorValue = 0;
	    var usedLights = this._usedLights;

	    for (var i = 1; i < usedLights.length; i++) {
	      var light = usedLights[i].light;
	      maxAttenuation = Math.max(light.attenuationEnd, maxAttenuation);
	      var color = gammaCorrection ? light._linearFinalColor : light._finalColor;
	      maxColorValue = Math.max(color[0], maxColorValue);
	      maxColorValue = Math.max(color[1], maxColorValue);
	      maxColorValue = Math.max(color[2], maxColorValue);
	    }

	    this._maxAttenuation = maxAttenuation + epsilon;
	    this._maxColorValue = maxColorValue + epsilon;
	    this.lightsBuffer.setCompressionRanges(this._maxAttenuation, this._maxColorValue);
	  };

	  _proto.updateClusters = function updateClusters(gammaCorrection) {
	    this.counts.fill(0);
	    this.clusters.fill(0);
	    var divX = this._cells.x;
	    var divZ = this._cells.z;
	    var counts = this.counts;
	    var limit = this._maxCellLightCount;
	    var clusters = this.clusters;
	    var pixelsPerCellCount = this._pixelsPerCellCount;
	    var usedLights = this._usedLights;

	    for (var i = 1; i < usedLights.length; i++) {
	      var clusteredLight = usedLights[i];
	      var light = clusteredLight.light;
	      this.lightsBuffer.addLightData(light, i, gammaCorrection);
	      this.evalLightCellMinMax(clusteredLight, tempMin3, tempMax3);
	      var xStart = tempMin3.x;
	      var xEnd = tempMax3.x;
	      var yStart = tempMin3.y;
	      var yEnd = tempMax3.y;
	      var zStart = tempMin3.z;
	      var zEnd = tempMax3.z;

	      for (var x = xStart; x <= xEnd; x++) {
	        for (var z = zStart; z <= zEnd; z++) {
	          for (var y = yStart; y <= yEnd; y++) {
	            var clusterIndex = x + divX * (z + y * divZ);
	            var count = counts[clusterIndex];

	            if (count < limit) {
	              clusters[pixelsPerCellCount * clusterIndex * 4 + count] = i;
	              counts[clusterIndex] = count + 1;
	            }
	          }
	        }
	      }
	    }
	  };

	  _proto.update = function update(lights, gammaCorrection, lightingParams) {
	    this.updateParams(lightingParams);
	    this.updateCells();
	    this.collectLights(lights);
	    this.evaluateBounds();
	    this.evaluateCompressionLimits(gammaCorrection);
	    this.updateClusters(gammaCorrection);
	    this.uploadTextures();
	  };

	  _proto.activate = function activate() {
	    this.updateUniforms();
	  };

	  _createClass(WorldClusters, [{
	    key: "maxCellLightCount",
	    get: function get() {
	      return this._maxCellLightCount;
	    },
	    set: function set(count) {
	      var maxCellLightCount = math.roundUp(count, 4);

	      if (maxCellLightCount !== this._maxCellLightCount) {
	        this._maxCellLightCount = maxCellLightCount;
	        this._pixelsPerCellCount = this._maxCellLightCount / 4;
	        this._cellsDirty = true;
	      }
	    }
	  }, {
	    key: "cells",
	    get: function get() {
	      return this._cells;
	    },
	    set: function set(value) {
	      tempVec3.copy(value).floor();

	      if (!this._cells.equals(tempVec3)) {
	        this._cells.copy(tempVec3);

	        this._cellsLimit.copy(tempVec3).sub(Vec3.ONE);

	        this._cellsDirty = true;
	      }
	    }
	  }]);

	  return WorldClusters;
	}();

	var uniformTypeToNumElements = [];
	uniformTypeToNumElements[UNIFORMTYPE_FLOAT] = 1;
	uniformTypeToNumElements[UNIFORMTYPE_VEC2] = 2;
	uniformTypeToNumElements[UNIFORMTYPE_VEC3] = 3;
	uniformTypeToNumElements[UNIFORMTYPE_VEC4] = 4;
	uniformTypeToNumElements[UNIFORMTYPE_INT] = 1;
	uniformTypeToNumElements[UNIFORMTYPE_IVEC2] = 2;
	uniformTypeToNumElements[UNIFORMTYPE_IVEC3] = 3;
	uniformTypeToNumElements[UNIFORMTYPE_IVEC4] = 4;
	uniformTypeToNumElements[UNIFORMTYPE_BOOL] = 1;
	uniformTypeToNumElements[UNIFORMTYPE_BVEC2] = 2;
	uniformTypeToNumElements[UNIFORMTYPE_BVEC3] = 3;
	uniformTypeToNumElements[UNIFORMTYPE_BVEC4] = 4;
	uniformTypeToNumElements[UNIFORMTYPE_MAT2] = 8;
	uniformTypeToNumElements[UNIFORMTYPE_MAT3] = 12;
	uniformTypeToNumElements[UNIFORMTYPE_MAT4] = 16;

	var UniformFormat = function () {
	  function UniformFormat(name, type, count) {
	    if (count === void 0) {
	      count = 1;
	    }

	    this.name = void 0;
	    this.type = void 0;
	    this.byteSize = void 0;
	    this.offset = void 0;
	    this.scopeId = void 0;
	    this.count = void 0;
	    this.name = name;
	    this.type = type;
	    this.count = count;
	    var elementSize = uniformTypeToNumElements[type];
	    this.byteSize = count * elementSize * 4;
	  }

	  var _proto = UniformFormat.prototype;

	  _proto.calculateOffset = function calculateOffset(offset) {
	    var alignment = this.byteSize <= 8 ? this.byteSize : 16;
	    offset = math.roundUp(offset, alignment);
	    this.offset = offset / 4;
	  };

	  return UniformFormat;
	}();

	var UniformBufferFormat = function () {
	  function UniformBufferFormat(graphicsDevice, uniforms) {
	    this.byteSize = 0;
	    this.map = new Map();
	    this.scope = graphicsDevice.scope;
	    this.uniforms = uniforms;
	    var offset = 0;

	    for (var i = 0; i < uniforms.length; i++) {
	      var uniform = uniforms[i];
	      uniform.calculateOffset(offset);
	      offset = uniform.offset * 4 + uniform.byteSize;
	      uniform.scopeId = this.scope.resolve(uniform.name);
	      this.map.set(uniform.name, uniform);
	    }

	    this.byteSize = math.roundUp(offset, 16);
	  }

	  var _proto2 = UniformBufferFormat.prototype;

	  _proto2.get = function get(name) {
	    return this.map.get(name);
	  };

	  _proto2.getShaderDeclaration = function getShaderDeclaration(bindGroup, bindIndex) {
	    var name = bindGroupNames[bindGroup];
	    var code = "layout(set = " + bindGroup + ", binding = " + bindIndex + ", std140) uniform ub_" + name + " {\n";
	    this.uniforms.forEach(function (uniform) {
	      var typeString = uniformTypeToName[uniform.type];
	      code += "    " + typeString + " " + uniform.name + ";\n";
	    });
	    return code + '};\n';
	  };

	  return UniformBufferFormat;
	}();

	var BindBufferFormat = function BindBufferFormat(name, visibility) {
	  this.name = name;
	  this.visibility = visibility;
	};

	var BindGroupFormat = function () {
	  function BindGroupFormat(graphicsDevice, bufferFormats, textureFormats) {
	    var _this = this;

	    this.device = graphicsDevice;
	    this.bufferFormats = bufferFormats;
	    this.bufferFormatsMap = new Map();
	    bufferFormats.forEach(function (bf, i) {
	      return _this.bufferFormatsMap.set(bf.name, i);
	    });
	    this.textureFormats = textureFormats;
	    var scope = graphicsDevice.scope;
	    this.textureFormatsMap = new Map();
	    textureFormats.forEach(function (tf, i) {
	      _this.textureFormatsMap.set(tf.name, i);

	      tf.scopeId = scope.resolve(tf.name);
	    });
	    this.impl = graphicsDevice.createBindGroupFormatImpl(this);
	  }

	  var _proto = BindGroupFormat.prototype;

	  _proto.destroy = function destroy() {
	    this.impl.destroy();
	  };

	  _proto.getTexture = function getTexture(name) {
	    var index = this.textureFormatsMap.get(name);

	    if (index !== undefined) {
	      return this.textureFormats[index];
	    }

	    return null;
	  };

	  _proto.getShaderDeclarationTextures = function getShaderDeclarationTextures(bindGroup) {
	    var code = '';
	    var bindIndex = this.bufferFormats.length;
	    this.textureFormats.forEach(function (format) {
	      code += "layout(set = " + bindGroup + ", binding = " + bindIndex++ + ") uniform texture2D " + format.name + ";\n" + ("layout(set = " + bindGroup + ", binding = " + bindIndex++ + ") uniform sampler " + format.name + "_sampler;\n");
	    });
	    return code;
	  };

	  _proto.loseContext = function loseContext() {};

	  return BindGroupFormat;
	}();

	var ColorAttachmentOps = function ColorAttachmentOps() {
	  this.clearValue = new Color(0, 0, 0, 1);
	  this.clear = false;
	  this.store = false;
	  this.resolve = true;
	  this.mipmaps = false;
	};

	var DepthStencilAttachmentOps = function DepthStencilAttachmentOps() {
	  this.clearDepthValue = 1;
	  this.clearStencilValue = 0;
	  this.clearDepth = false;
	  this.clearStencil = false;
	  this.storeDepth = false;
	  this.storeStencil = false;
	};

	var RenderPass = function () {
	  function RenderPass(graphicsDevice, execute) {
	    this.name = void 0;
	    this.renderTarget = void 0;
	    this.samples = 0;
	    this.colorOps = void 0;
	    this.depthStencilOps = void 0;
	    this.requiresCubemaps = true;
	    this.fullSizeClearRect = true;
	    this.device = graphicsDevice;
	    this.execute = execute;
	  }

	  var _proto = RenderPass.prototype;

	  _proto.init = function init(renderTarget) {
	    var _this$renderTarget, _this$renderTarget$co;

	    this.renderTarget = renderTarget || null;
	    this.colorOps = new ColorAttachmentOps();
	    this.depthStencilOps = new DepthStencilAttachmentOps();
	    this.samples = Math.max(this.renderTarget ? this.renderTarget.samples : this.device.samples, 1);

	    if (this.samples === 1) {
	      this.colorOps.store = true;
	      this.colorOps.resolve = false;
	    }

	    if ((_this$renderTarget = this.renderTarget) != null && (_this$renderTarget$co = _this$renderTarget.colorBuffer) != null && _this$renderTarget$co.mipmaps) {
	      this.colorOps.mipmaps = true;
	    }
	  };

	  _proto.setClearColor = function setClearColor(color) {
	    this.colorOps.clearValue.copy(color);
	    this.colorOps.clear = true;
	  };

	  _proto.setClearDepth = function setClearDepth(depthValue) {
	    this.depthStencilOps.clearDepthValue = depthValue;
	    this.depthStencilOps.clearDepth = true;
	  };

	  _proto.setClearStencil = function setClearStencil(stencilValue) {
	    this.depthStencilOps.clearStencilValue = stencilValue;
	    this.depthStencilOps.clearStencil = true;
	  };

	  _proto.render = function render() {
	    var device = this.device;
	    var realPass = this.renderTarget !== undefined;

	    if (realPass) {
	      device.startPass(this);
	    }

	    this.execute();

	    if (realPass) {
	      device.endPass(this);
	    }
	  };

	  return RenderPass;
	}();

	var textureBlitVertexShader = "\n    attribute vec2 vertex_position;\n    varying vec2 uv0;\n    void main(void) {\n        gl_Position = vec4(vertex_position, 0.5, 1.0);\n        uv0 = vertex_position.xy * 0.5 + 0.5;\n    }";
	var textureBlitFragmentShader = "\n    varying vec2 uv0;\n    uniform sampler2D blitTexture;\n    void main(void) {\n        gl_FragColor = texture2D(blitTexture, uv0);\n    }";
	var textureCubeBlitFragmentShader = "\n    varying vec2 uv0;\n    uniform samplerCube blitTexture;\n    uniform mat4 invViewProj;\n    void main(void) {\n        vec4 projPos = vec4(uv0 * 2.0 - 1.0, 0.5, 1.0);\n        vec4 worldPos = invViewProj * projPos;\n        gl_FragColor = textureCube(blitTexture, worldPos.xyz);\n    }";

	var _viewport$1 = new Vec4();

	var CookieRenderer = function () {
	  function CookieRenderer(device, lightTextureAtlas) {
	    this.device = device;
	    this.lightTextureAtlas = lightTextureAtlas;
	    this.blitShader2d = null;
	    this.blitShaderCube = null;
	    this.blitTextureId = null;
	    this.invViewProjId = null;
	  }

	  var _proto = CookieRenderer.prototype;

	  _proto.destroy = function destroy() {};

	  _proto.getShader = function getShader(shader, fragment) {
	    if (!this[shader]) this[shader] = createShaderFromCode(this.device, textureBlitVertexShader, fragment, "cookie_renderer_" + shader);
	    if (!this.blitTextureId) this.blitTextureId = this.device.scope.resolve('blitTexture');
	    if (!this.invViewProjId) this.invViewProjId = this.device.scope.resolve('invViewProj');
	    return this[shader];
	  };

	  CookieRenderer.createTexture = function createTexture(device, resolution) {
	    var texture = new Texture(device, {
	      name: 'CookieAtlas',
	      width: resolution,
	      height: resolution,
	      format: PIXELFORMAT_R8_G8_B8_A8,
	      cubemap: false,
	      mipmaps: false,
	      minFilter: FILTER_NEAREST,
	      magFilter: FILTER_NEAREST,
	      addressU: ADDRESS_CLAMP_TO_EDGE,
	      addressV: ADDRESS_CLAMP_TO_EDGE
	    });
	    return texture;
	  };

	  _proto.initInvViewProjMatrices = function initInvViewProjMatrices() {
	    if (!CookieRenderer._invViewProjMatrices) {
	      CookieRenderer._invViewProjMatrices = [];

	      for (var face = 0; face < 6; face++) {
	        var camera = LightCamera.create(null, LIGHTTYPE_OMNI, face);
	        var projMat = camera.projectionMatrix;
	        var viewMat = camera.node.getLocalTransform().clone().invert();
	        CookieRenderer._invViewProjMatrices[face] = new Mat4().mul2(projMat, viewMat).invert();
	      }
	    }
	  };

	  _proto.render = function render(light, renderTarget) {
	    if (light.enabled && light.cookie && light.visibleThisFrame) {
	      var faceCount = light.numShadowFaces;
	      var shader = faceCount > 1 ? this.shaderCube : this.shader2d;
	      var device = this.device;

	      if (faceCount > 1) {
	        this.initInvViewProjMatrices();
	      }

	      this.blitTextureId.setValue(light.cookie);

	      for (var face = 0; face < faceCount; face++) {
	        _viewport$1.copy(light.atlasViewport);

	        if (faceCount > 1) {
	          var smallSize = _viewport$1.z / 3;
	          var offset = this.lightTextureAtlas.cubeSlotsOffsets[face];
	          _viewport$1.x += smallSize * offset.x;
	          _viewport$1.y += smallSize * offset.y;
	          _viewport$1.z = smallSize;
	          _viewport$1.w = smallSize;
	          this.invViewProjId.setValue(CookieRenderer._invViewProjMatrices[face].data);
	        }

	        _viewport$1.mulScalar(renderTarget.colorBuffer.width);

	        drawQuadWithShader(device, renderTarget, shader, _viewport$1);
	      }
	    }
	  };

	  _createClass(CookieRenderer, [{
	    key: "shader2d",
	    get: function get() {
	      return this.getShader('blitShader2d', textureBlitFragmentShader);
	    }
	  }, {
	    key: "shaderCube",
	    get: function get() {
	      return this.getShader('blitShaderCube', textureCubeBlitFragmentShader);
	    }
	  }]);

	  return CookieRenderer;
	}();

	CookieRenderer._invViewProjMatrices = null;

	var ShadowMap = function () {
	  function ShadowMap(texture, targets) {
	    this.texture = texture;
	    this.cached = false;
	    this.renderTargets = targets;
	  }

	  var _proto = ShadowMap.prototype;

	  _proto.destroy = function destroy() {
	    if (this.texture) {
	      this.texture.destroy();
	      this.texture = null;
	    }

	    var targets = this.renderTargets;

	    for (var i = 0; i < targets.length; i++) {
	      targets[i].destroy();
	    }

	    this.renderTargets.length = 0;
	  };

	  ShadowMap.getShadowFormat = function getShadowFormat(device, shadowType) {
	    if (shadowType === SHADOW_VSM32) {
	      return PIXELFORMAT_RGBA32F;
	    } else if (shadowType === SHADOW_VSM16) {
	      return PIXELFORMAT_RGBA16F;
	    } else if (shadowType === SHADOW_PCF5) {
	      return PIXELFORMAT_DEPTH;
	    } else if (shadowType === SHADOW_PCF3 && device.webgl2) {
	      return PIXELFORMAT_DEPTH;
	    }

	    return PIXELFORMAT_R8_G8_B8_A8;
	  };

	  ShadowMap.getShadowFiltering = function getShadowFiltering(device, shadowType) {
	    if (shadowType === SHADOW_PCF3 && !device.webgl2) {
	      return FILTER_NEAREST;
	    } else if (shadowType === SHADOW_VSM32) {
	      return device.extTextureFloatLinear ? FILTER_LINEAR : FILTER_NEAREST;
	    } else if (shadowType === SHADOW_VSM16) {
	      return device.extTextureHalfFloatLinear ? FILTER_LINEAR : FILTER_NEAREST;
	    }

	    return FILTER_LINEAR;
	  };

	  ShadowMap.create = function create(device, light) {
	    var shadowMap = null;

	    if (light._type === LIGHTTYPE_OMNI) {
	      shadowMap = this.createCubemap(device, light._shadowResolution);
	    } else {
	      shadowMap = this.create2dMap(device, light._shadowResolution, light._shadowType);
	    }

	    return shadowMap;
	  };

	  ShadowMap.createAtlas = function createAtlas(device, resolution, shadowType) {
	    var shadowMap = this.create2dMap(device, resolution, shadowType);
	    var targets = shadowMap.renderTargets;
	    var rt = targets[0];

	    for (var i = 0; i < 5; i++) {
	      targets.push(rt);
	    }

	    return shadowMap;
	  };

	  ShadowMap.create2dMap = function create2dMap(device, size, shadowType) {
	    var format = this.getShadowFormat(device, shadowType);
	    var filter = this.getShadowFiltering(device, shadowType);
	    var texture = new Texture(device, {
	      format: format,
	      width: size,
	      height: size,
	      mipmaps: false,
	      minFilter: filter,
	      magFilter: filter,
	      addressU: ADDRESS_CLAMP_TO_EDGE,
	      addressV: ADDRESS_CLAMP_TO_EDGE,
	      name: 'ShadowMap2D'
	    });
	    var target = null;

	    if (shadowType === SHADOW_PCF5 || shadowType === SHADOW_PCF3 && device.webgl2) {
	      texture.compareOnRead = true;
	      texture.compareFunc = FUNC_LESS;
	      target = new RenderTarget({
	        depthBuffer: texture
	      });
	    } else {
	      target = new RenderTarget({
	        colorBuffer: texture,
	        depth: true
	      });
	    }

	    return new ShadowMap(texture, [target]);
	  };

	  ShadowMap.createCubemap = function createCubemap(device, size) {
	    var cubemap = new Texture(device, {
	      format: PIXELFORMAT_R8_G8_B8_A8,
	      width: size,
	      height: size,
	      cubemap: true,
	      mipmaps: false,
	      minFilter: FILTER_NEAREST,
	      magFilter: FILTER_NEAREST,
	      addressU: ADDRESS_CLAMP_TO_EDGE,
	      addressV: ADDRESS_CLAMP_TO_EDGE,
	      name: 'ShadowMapCube'
	    });
	    var targets = [];

	    for (var i = 0; i < 6; i++) {
	      var target = new RenderTarget({
	        colorBuffer: cubemap,
	        face: i,
	        depth: true
	      });
	      targets.push(target);
	    }

	    return new ShadowMap(cubemap, targets);
	  };

	  return ShadowMap;
	}();

	var _tempArray = [];
	var _tempArray2 = [];

	var _viewport = new Vec4();

	var _scissor = new Vec4();

	var Slot = function Slot(rect) {
	  this.size = Math.floor(rect.w * 1024);
	  this.used = false;
	  this.lightId = -1;
	  this.rect = rect;
	};

	var LightTextureAtlas = function () {
	  function LightTextureAtlas(device) {
	    this.device = device;
	    this.version = 1;
	    this.shadowAtlasResolution = 2048;
	    this.shadowAtlas = null;
	    this.shadowEdgePixels = 3;
	    this.cookieAtlasResolution = 2048;
	    this.cookieAtlas = null;
	    this.cookieRenderTarget = null;
	    this.slots = [];
	    this.atlasSplit = [];
	    this.cubeSlotsOffsets = [new Vec2(0, 0), new Vec2(0, 1), new Vec2(1, 0), new Vec2(1, 1), new Vec2(2, 0), new Vec2(2, 1)];
	    this.scissorVec = new Vec4();
	    this.allocateShadowAtlas(1);
	    this.allocateCookieAtlas(1);
	    this.allocateUniforms();
	  }

	  var _proto = LightTextureAtlas.prototype;

	  _proto.destroy = function destroy() {
	    this.destroyShadowAtlas();
	    this.destroyCookieAtlas();
	  };

	  _proto.destroyShadowAtlas = function destroyShadowAtlas() {
	    if (this.shadowAtlas) {
	      this.shadowAtlas.destroy();
	      this.shadowAtlas = null;
	    }
	  };

	  _proto.destroyCookieAtlas = function destroyCookieAtlas() {
	    if (this.cookieAtlas) {
	      this.cookieAtlas.destroy();
	      this.cookieAtlas = null;
	    }

	    if (this.cookieRenderTarget) {
	      this.cookieRenderTarget.destroy();
	      this.cookieRenderTarget = null;
	    }
	  };

	  _proto.allocateShadowAtlas = function allocateShadowAtlas(resolution) {
	    if (!this.shadowAtlas || this.shadowAtlas.texture.width !== resolution) {
	      this.version++;
	      this.destroyShadowAtlas();
	      this.shadowAtlas = ShadowMap.createAtlas(this.device, resolution, SHADOW_PCF3);
	      this.shadowAtlas.cached = true;
	      var scissorOffset = 4 / this.shadowAtlasResolution;
	      this.scissorVec.set(scissorOffset, scissorOffset, -2 * scissorOffset, -2 * scissorOffset);
	    }
	  };

	  _proto.allocateCookieAtlas = function allocateCookieAtlas(resolution) {
	    if (!this.cookieAtlas || this.cookieAtlas.width !== resolution) {
	      this.version++;
	      this.destroyCookieAtlas();
	      this.cookieAtlas = CookieRenderer.createTexture(this.device, resolution);
	      this.cookieRenderTarget = new RenderTarget({
	        colorBuffer: this.cookieAtlas,
	        depth: false,
	        flipY: true
	      });
	    }
	  };

	  _proto.allocateUniforms = function allocateUniforms() {
	    this._shadowAtlasTextureId = this.device.scope.resolve('shadowAtlasTexture');
	    this._shadowAtlasParamsId = this.device.scope.resolve('shadowAtlasParams');
	    this._shadowAtlasParams = new Float32Array(2);
	    this._cookieAtlasTextureId = this.device.scope.resolve('cookieAtlasTexture');
	  };

	  _proto.updateUniforms = function updateUniforms() {
	    var isShadowFilterPcf = true;
	    var rt = this.shadowAtlas.renderTargets[0];
	    var shadowBuffer = this.device.webgl2 && isShadowFilterPcf ? rt.depthBuffer : rt.colorBuffer;

	    this._shadowAtlasTextureId.setValue(shadowBuffer);

	    this._shadowAtlasParams[0] = this.shadowAtlasResolution;
	    this._shadowAtlasParams[1] = this.shadowEdgePixels;

	    this._shadowAtlasParamsId.setValue(this._shadowAtlasParams);

	    this._cookieAtlasTextureId.setValue(this.cookieAtlas);
	  };

	  _proto.subdivide = function subdivide(numLights, lightingParams) {
	    var atlasSplit = lightingParams.atlasSplit;

	    if (!atlasSplit) {
	      var gridSize = Math.ceil(Math.sqrt(numLights));
	      atlasSplit = _tempArray2;
	      atlasSplit[0] = gridSize;
	      atlasSplit.length = 1;
	    }

	    var arraysEqual = function arraysEqual(a, b) {
	      return a.length === b.length && a.every(function (v, i) {
	        return v === b[i];
	      });
	    };

	    if (!arraysEqual(atlasSplit, this.atlasSplit)) {
	      var _this$atlasSplit;

	      this.version++;
	      this.slots.length = 0;
	      this.atlasSplit.length = 0;

	      (_this$atlasSplit = this.atlasSplit).push.apply(_this$atlasSplit, atlasSplit);

	      var splitCount = this.atlasSplit[0];

	      if (splitCount > 1) {
	        var invSize = 1 / splitCount;

	        for (var i = 0; i < splitCount; i++) {
	          for (var j = 0; j < splitCount; j++) {
	            var rect = new Vec4(i * invSize, j * invSize, invSize, invSize);
	            var nextLevelSplit = this.atlasSplit[1 + i * splitCount + j];

	            if (nextLevelSplit > 1) {
	              for (var x = 0; x < nextLevelSplit; x++) {
	                for (var y = 0; y < nextLevelSplit; y++) {
	                  var invSizeNext = invSize / nextLevelSplit;
	                  var rectNext = new Vec4(rect.x + x * invSizeNext, rect.y + y * invSizeNext, invSizeNext, invSizeNext);
	                  this.slots.push(new Slot(rectNext));
	                }
	              }
	            } else {
	              this.slots.push(new Slot(rect));
	            }
	          }
	        }
	      } else {
	        this.slots.push(new Slot(new Vec4(0, 0, 1, 1)));
	      }

	      this.slots.sort(function (a, b) {
	        return b.size - a.size;
	      });
	    }
	  };

	  _proto.collectLights = function collectLights(spotLights, omniLights, lightingParams) {
	    var cookiesEnabled = lightingParams.cookiesEnabled;
	    var shadowsEnabled = lightingParams.shadowsEnabled;
	    var needsShadowAtlas = false;
	    var needsCookieAtlas = false;
	    var lights = _tempArray;
	    lights.length = 0;

	    var processLights = function processLights(list) {
	      for (var i = 0; i < list.length; i++) {
	        var light = list[i];

	        if (light.visibleThisFrame) {
	          var lightShadow = shadowsEnabled && light.castShadows;
	          var lightCookie = cookiesEnabled && !!light.cookie;
	          needsShadowAtlas || (needsShadowAtlas = lightShadow);
	          needsCookieAtlas || (needsCookieAtlas = lightCookie);

	          if (lightShadow || lightCookie) {
	            lights.push(light);
	          }
	        }
	      }
	    };

	    if (cookiesEnabled || shadowsEnabled) {
	      processLights(spotLights);
	      processLights(omniLights);
	    }

	    lights.sort(function (a, b) {
	      return b.maxScreenSize - a.maxScreenSize;
	    });

	    if (needsShadowAtlas) {
	      this.allocateShadowAtlas(this.shadowAtlasResolution);
	    }

	    if (needsCookieAtlas) {
	      this.allocateCookieAtlas(this.cookieAtlasResolution);
	    }

	    if (needsShadowAtlas || needsCookieAtlas) {
	      this.subdivide(lights.length, lightingParams);
	    }

	    return lights;
	  };

	  _proto.setupSlot = function setupSlot(light, rect) {
	    light.atlasViewport.copy(rect);
	    var faceCount = light.numShadowFaces;

	    for (var face = 0; face < faceCount; face++) {
	      if (light.castShadows || light._cookie) {
	        _viewport.copy(rect);

	        _scissor.copy(rect);

	        if (light._type === LIGHTTYPE_SPOT) {
	          _viewport.add(this.scissorVec);
	        }

	        if (light._type === LIGHTTYPE_OMNI) {
	          var smallSize = _viewport.z / 3;
	          var offset = this.cubeSlotsOffsets[face];
	          _viewport.x += smallSize * offset.x;
	          _viewport.y += smallSize * offset.y;
	          _viewport.z = smallSize;
	          _viewport.w = smallSize;

	          _scissor.copy(_viewport);
	        }

	        if (light.castShadows) {
	          var lightRenderData = light.getRenderData(null, face);
	          lightRenderData.shadowViewport.copy(_viewport);
	          lightRenderData.shadowScissor.copy(_scissor);
	        }
	      }
	    }
	  };

	  _proto.assignSlot = function assignSlot(light, slotIndex, slotReassigned) {
	    light.atlasViewportAllocated = true;
	    var slot = this.slots[slotIndex];
	    slot.lightId = light.id;
	    slot.used = true;

	    if (slotReassigned) {
	      light.atlasSlotUpdated = true;
	      light.atlasVersion = this.version;
	      light.atlasSlotIndex = slotIndex;
	    }
	  };

	  _proto.update = function update(spotLights, omniLights, lightingParams) {
	    this.shadowAtlasResolution = lightingParams.shadowAtlasResolution;
	    this.cookieAtlasResolution = lightingParams.cookieAtlasResolution;
	    var lights = this.collectLights(spotLights, omniLights, lightingParams);

	    if (lights.length > 0) {
	      var slots = this.slots;

	      for (var i = 0; i < slots.length; i++) {
	        slots[i].used = false;
	      }

	      var assignCount = Math.min(lights.length, slots.length);

	      for (var _i = 0; _i < assignCount; _i++) {
	        var light = lights[_i];
	        if (light.castShadows) light._shadowMap = this.shadowAtlas;
	        var previousSlot = slots[light.atlasSlotIndex];

	        if (light.atlasVersion === this.version && light.id === (previousSlot == null ? void 0 : previousSlot.lightId)) {
	          var _previousSlot = slots[light.atlasSlotIndex];

	          if (_previousSlot.size === slots[_i].size && !_previousSlot.used) {
	            this.assignSlot(light, light.atlasSlotIndex, false);
	          }
	        }
	      }

	      var usedCount = 0;

	      for (var _i2 = 0; _i2 < assignCount; _i2++) {
	        while (usedCount < slots.length && slots[usedCount].used) {
	          usedCount++;
	        }

	        var _light = lights[_i2];

	        if (!_light.atlasViewportAllocated) {
	          this.assignSlot(_light, usedCount, true);
	        }

	        var slot = slots[_light.atlasSlotIndex];
	        this.setupSlot(_light, slot.rect);
	      }
	    }

	    this.updateUniforms();
	  };

	  return LightTextureAtlas;
	}();

	var ShadowMapCache = function () {
	  function ShadowMapCache() {
	    this.shadowMapCache = new Map();
	  }

	  var _proto = ShadowMapCache.prototype;

	  _proto.destroy = function destroy() {
	    this.clear();
	    this.shadowMapCache = null;
	  };

	  _proto.clear = function clear() {
	    this.shadowMapCache.forEach(function (shadowMaps) {
	      shadowMaps.forEach(function (shadowMap) {
	        shadowMap.destroy();
	      });
	    });
	    this.shadowMapCache.clear();
	  };

	  _proto.getKey = function getKey(light) {
	    var isCubeMap = light._type === LIGHTTYPE_OMNI;
	    var shadowType = light._shadowType;
	    var resolution = light._shadowResolution;
	    return isCubeMap + "-" + shadowType + "-" + resolution;
	  };

	  _proto.get = function get(device, light) {
	    var key = this.getKey(light);
	    var shadowMaps = this.shadowMapCache.get(key);

	    if (shadowMaps && shadowMaps.length) {
	      return shadowMaps.pop();
	    }

	    var shadowMap = ShadowMap.create(device, light);
	    shadowMap.cached = true;
	    return shadowMap;
	  };

	  _proto.add = function add(light, shadowMap) {
	    var key = this.getKey(light);
	    var shadowMaps = this.shadowMapCache.get(key);

	    if (shadowMaps) {
	      shadowMaps.push(shadowMap);
	    } else {
	      this.shadowMapCache.set(key, [shadowMap]);
	    }
	  };

	  return ShadowMapCache;
	}();

	var aabbPoints = [new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3()];
	var _depthRange = {
	  min: 0,
	  max: 0
	};

	function getDepthRange(cameraViewMatrix, aabbMin, aabbMax) {
	  aabbPoints[0].x = aabbPoints[1].x = aabbPoints[2].x = aabbPoints[3].x = aabbMin.x;
	  aabbPoints[1].y = aabbPoints[3].y = aabbPoints[7].y = aabbPoints[5].y = aabbMin.y;
	  aabbPoints[2].z = aabbPoints[3].z = aabbPoints[6].z = aabbPoints[7].z = aabbMin.z;
	  aabbPoints[4].x = aabbPoints[5].x = aabbPoints[6].x = aabbPoints[7].x = aabbMax.x;
	  aabbPoints[0].y = aabbPoints[2].y = aabbPoints[4].y = aabbPoints[6].y = aabbMax.y;
	  aabbPoints[0].z = aabbPoints[1].z = aabbPoints[4].z = aabbPoints[5].z = aabbMax.z;
	  var minz = 9999999999;
	  var maxz = -9999999999;

	  for (var i = 0; i < 8; ++i) {
	    cameraViewMatrix.transformPoint(aabbPoints[i], aabbPoints[i]);
	    var z = aabbPoints[i].z;
	    if (z < minz) minz = z;
	    if (z > maxz) maxz = z;
	  }

	  _depthRange.min = minz;
	  _depthRange.max = maxz;
	  return _depthRange;
	}

	function gauss(x, sigma) {
	  return Math.exp(-(x * x) / (2.0 * sigma * sigma));
	}

	var maxBlurSize = 25;

	function gaussWeights(kernelSize) {
	  if (kernelSize > maxBlurSize) {
	    kernelSize = maxBlurSize;
	  }

	  var sigma = (kernelSize - 1) / (2 * 3);
	  var halfWidth = (kernelSize - 1) * 0.5;
	  var values = new Array(kernelSize);
	  var sum = 0.0;

	  for (var i = 0; i < kernelSize; ++i) {
	    values[i] = gauss(i - halfWidth, sigma);
	    sum += values[i];
	  }

	  for (var _i = 0; _i < kernelSize; ++_i) {
	    values[_i] /= sum;
	  }

	  return values;
	}

	var visibleSceneAabb = new BoundingBox();
	var shadowCamView = new Mat4();
	var shadowCamViewProj = new Mat4();
	var pixelOffset = new Float32Array(2);
	var blurScissorRect = new Vec4(1, 1, 0, 0);
	var opChanId = {
	  r: 1,
	  g: 2,
	  b: 3,
	  a: 4
	};
	var center = new Vec3();
	var viewportMatrix = new Mat4();

	function getDepthKey(meshInstance) {
	  var material = meshInstance.material;
	  var x = meshInstance.skinInstance ? 10 : 0;
	  var y = 0;

	  if (material.opacityMap) {
	    var opChan = material.opacityMapChannel;

	    if (opChan) {
	      y = opChanId[opChan];
	    }
	  }

	  return x + y;
	}

	var ShadowRenderer = function () {
	  function ShadowRenderer(forwardRenderer, lightTextureAtlas) {
	    this.device = forwardRenderer.device;
	    this.forwardRenderer = forwardRenderer;
	    this.lightTextureAtlas = lightTextureAtlas;
	    var scope = this.device.scope;
	    this.polygonOffsetId = scope.resolve('polygonOffset');
	    this.polygonOffset = new Float32Array(2);
	    this.sourceId = scope.resolve('source');
	    this.pixelOffsetId = scope.resolve('pixelOffset');
	    this.weightId = scope.resolve('weight[0]');
	    this.blurVsmShaderCode = [shaderChunks.blurVSMPS, '#define GAUSS\n' + shaderChunks.blurVSMPS];
	    var packed = '#define PACKED\n';
	    this.blurPackedVsmShaderCode = [packed + this.blurVsmShaderCode[0], packed + this.blurVsmShaderCode[1]];
	    this.blurVsmShader = [{}, {}];
	    this.blurPackedVsmShader = [{}, {}];
	    this.blurVsmWeights = {};
	    this.shadowMapLightRadiusId = scope.resolve('light_radius');
	    this.shadowMapCache = new ShadowMapCache();
	  }

	  var _proto = ShadowRenderer.prototype;

	  _proto.destroy = function destroy() {
	    this.shadowMapCache.destroy();
	    this.shadowMapCache = null;
	  };

	  ShadowRenderer.createShadowCamera = function createShadowCamera(device, shadowType, type, face) {
	    var shadowCam = LightCamera.create('ShadowCamera', type, face);

	    if (shadowType >= SHADOW_VSM8 && shadowType <= SHADOW_VSM32) {
	      shadowCam.clearColor = new Color(0, 0, 0, 0);
	    } else {
	      shadowCam.clearColor = new Color(1, 1, 1, 1);
	    }

	    shadowCam.clearDepthBuffer = true;
	    shadowCam.clearStencilBuffer = false;
	    return shadowCam;
	  };

	  ShadowRenderer.setShadowCameraSettings = function setShadowCameraSettings(shadowCam, device, shadowType, type, isClustered) {
	    var hwPcf = shadowType === SHADOW_PCF5 || shadowType === SHADOW_PCF3 && device.webgl2;

	    if (type === LIGHTTYPE_OMNI && !isClustered) {
	      hwPcf = false;
	    }

	    shadowCam.clearColorBuffer = !hwPcf;
	  };

	  _proto.cullShadowCasters = function cullShadowCasters(meshInstances, visible, camera) {
	    var count = 0;
	    var numInstances = meshInstances.length;

	    for (var i = 0; i < numInstances; i++) {
	      var meshInstance = meshInstances[i];

	      if (!meshInstance.cull || meshInstance._isVisible(camera)) {
	        meshInstance.visibleThisFrame = true;
	        visible[count] = meshInstance;
	        count++;
	      }
	    }

	    visible.length = count;
	    visible.sort(this.forwardRenderer.depthSortCompare);
	  };

	  _proto.cullLocal = function cullLocal(light, drawCalls) {
	    var isClustered = this.forwardRenderer.scene.clusteredLightingEnabled;
	    light.visibleThisFrame = true;

	    if (!isClustered) {
	      if (!light._shadowMap) {
	        light._shadowMap = ShadowMap.create(this.device, light);
	      }
	    }

	    var type = light._type;
	    var faceCount = type === LIGHTTYPE_SPOT ? 1 : 6;

	    for (var face = 0; face < faceCount; face++) {
	      var lightRenderData = light.getRenderData(null, face);
	      var shadowCam = lightRenderData.shadowCamera;
	      shadowCam.nearClip = light.attenuationEnd / 1000;
	      shadowCam.farClip = light.attenuationEnd;
	      var shadowCamNode = shadowCam._node;
	      var lightNode = light._node;
	      shadowCamNode.setPosition(lightNode.getPosition());

	      if (type === LIGHTTYPE_SPOT) {
	        shadowCam.fov = light._outerConeAngle * 2;
	        shadowCamNode.setRotation(lightNode.getRotation());
	        shadowCamNode.rotateLocal(-90, 0, 0);
	      } else if (type === LIGHTTYPE_OMNI) {
	        if (isClustered) {
	          var tileSize = this.lightTextureAtlas.shadowAtlasResolution * light.atlasViewport.z / 3;
	          var texelSize = 2 / tileSize;
	          var filterSize = texelSize * this.lightTextureAtlas.shadowEdgePixels;
	          shadowCam.fov = Math.atan(1 + filterSize) * math.RAD_TO_DEG * 2;
	        } else {
	          shadowCam.fov = 90;
	        }
	      }

	      this.forwardRenderer.updateCameraFrustum(shadowCam);
	      this.cullShadowCasters(drawCalls, lightRenderData.visibleCasters, shadowCam);
	    }
	  };

	  _proto.generateSplitDistances = function generateSplitDistances(light, nearDist, farDist) {
	    light._shadowCascadeDistances.fill(farDist);

	    for (var i = 1; i < light.numCascades; i++) {
	      var fraction = i / light.numCascades;
	      var linearDist = nearDist + (farDist - nearDist) * fraction;
	      var logDist = nearDist * Math.pow(farDist / nearDist, fraction);
	      var dist = math.lerp(linearDist, logDist, light.cascadeDistribution);
	      light._shadowCascadeDistances[i - 1] = dist;
	    }
	  };

	  _proto.cullDirectional = function cullDirectional(light, drawCalls, camera) {
	    light.visibleThisFrame = true;

	    if (!light._shadowMap) {
	      light._shadowMap = ShadowMap.create(this.device, light);
	    }

	    var nearDist = camera._nearClip;
	    this.generateSplitDistances(light, nearDist, light.shadowDistance);

	    for (var cascade = 0; cascade < light.numCascades; cascade++) {
	      var lightRenderData = light.getRenderData(camera, cascade);
	      var shadowCam = lightRenderData.shadowCamera;
	      shadowCam.renderTarget = light._shadowMap.renderTargets[0];
	      lightRenderData.shadowViewport.copy(light.cascades[cascade]);
	      lightRenderData.shadowScissor.copy(light.cascades[cascade]);
	      var shadowCamNode = shadowCam._node;
	      var lightNode = light._node;
	      shadowCamNode.setPosition(lightNode.getPosition());
	      shadowCamNode.setRotation(lightNode.getRotation());
	      shadowCamNode.rotateLocal(-90, 0, 0);
	      var frustumNearDist = cascade === 0 ? nearDist : light._shadowCascadeDistances[cascade - 1];
	      var frustumFarDist = light._shadowCascadeDistances[cascade];
	      var frustumPoints = Frustum.getPoints(camera, frustumNearDist, frustumFarDist);
	      center.set(0, 0, 0);
	      var cameraWorldMat = camera.node.getWorldTransform();

	      for (var i = 0; i < 8; i++) {
	        cameraWorldMat.transformPoint(frustumPoints[i], frustumPoints[i]);
	        center.add(frustumPoints[i]);
	      }

	      center.mulScalar(1 / 8);
	      var radius = 0;

	      for (var _i2 = 0; _i2 < 8; _i2++) {
	        var dist = frustumPoints[_i2].sub(center).length();

	        if (dist > radius) radius = dist;
	      }

	      var right = shadowCamNode.right;
	      var up = shadowCamNode.up;
	      var lightDir = shadowCamNode.forward;
	      var sizeRatio = 0.25 * light._shadowResolution / radius;
	      var x = Math.ceil(center.dot(up) * sizeRatio) / sizeRatio;
	      var y = Math.ceil(center.dot(right) * sizeRatio) / sizeRatio;
	      var scaledUp = up.mulScalar(x);
	      var scaledRight = right.mulScalar(y);
	      var dot = center.dot(lightDir);
	      var scaledDir = lightDir.mulScalar(dot);
	      center.add2(scaledUp, scaledRight).add(scaledDir);
	      shadowCamNode.setPosition(center);
	      shadowCamNode.translateLocal(0, 0, 1000000);
	      shadowCam.nearClip = 0;
	      shadowCam.farClip = 2000000;
	      shadowCam.orthoHeight = radius;
	      this.forwardRenderer.updateCameraFrustum(shadowCam);
	      this.cullShadowCasters(drawCalls, lightRenderData.visibleCasters, shadowCam);
	      var emptyAabb = true;
	      var visibleCasters = lightRenderData.visibleCasters;

	      for (var _i3 = 0; _i3 < visibleCasters.length; _i3++) {
	        var meshInstance = visibleCasters[_i3];

	        if (emptyAabb) {
	          emptyAabb = false;
	          visibleSceneAabb.copy(meshInstance.aabb);
	        } else {
	          visibleSceneAabb.add(meshInstance.aabb);
	        }
	      }

	      shadowCamView.copy(shadowCamNode.getWorldTransform()).invert();
	      var depthRange = getDepthRange(shadowCamView, visibleSceneAabb.getMin(), visibleSceneAabb.getMax());
	      shadowCamNode.translateLocal(0, 0, depthRange.max + 0.1);
	      shadowCam.farClip = depthRange.max - depthRange.min + 0.2;
	    }
	  };

	  _proto.setupRenderState = function setupRenderState(device, light) {
	    var isClustered = this.forwardRenderer.scene.clusteredLightingEnabled;

	    if (device.webgl2) {
	      if (light._type === LIGHTTYPE_OMNI && !isClustered) {
	        device.setDepthBias(false);
	      } else {
	        device.setDepthBias(true);
	        device.setDepthBiasValues(light.shadowBias * -1000.0, light.shadowBias * -1000.0);
	      }
	    } else if (device.extStandardDerivatives) {
	      if (light._type === LIGHTTYPE_OMNI) {
	        this.polygonOffset[0] = 0;
	        this.polygonOffset[1] = 0;
	        this.polygonOffsetId.setValue(this.polygonOffset);
	      } else {
	        this.polygonOffset[0] = light.shadowBias * -1000.0;
	        this.polygonOffset[1] = light.shadowBias * -1000.0;
	        this.polygonOffsetId.setValue(this.polygonOffset);
	      }
	    }

	    device.setBlending(false);
	    device.setDepthWrite(true);
	    device.setDepthTest(true);
	    device.setDepthFunc(FUNC_LESSEQUAL);
	    var useShadowSampler = isClustered ? light._isPcf && device.webgl2 : light._isPcf && device.webgl2 && light._type !== LIGHTTYPE_OMNI;

	    if (useShadowSampler) {
	      device.setColorWrite(false, false, false, false);
	    } else {
	      device.setColorWrite(true, true, true, true);
	    }
	  };

	  _proto.restoreRenderState = function restoreRenderState(device) {
	    if (device.webgl2) {
	      device.setDepthBias(false);
	    } else if (device.extStandardDerivatives) {
	      this.polygonOffset[0] = 0;
	      this.polygonOffset[1] = 0;
	      this.polygonOffsetId.setValue(this.polygonOffset);
	    }
	  };

	  _proto.dispatchUniforms = function dispatchUniforms(light, shadowCam, lightRenderData, face) {
	    var shadowCamNode = shadowCam._node;

	    if (light._type !== LIGHTTYPE_DIRECTIONAL) {
	      this.forwardRenderer.dispatchViewPos(shadowCamNode.getPosition());
	      this.shadowMapLightRadiusId.setValue(light.attenuationEnd);
	    }

	    shadowCamView.setTRS(shadowCamNode.getPosition(), shadowCamNode.getRotation(), Vec3.ONE).invert();
	    shadowCamViewProj.mul2(shadowCam.projectionMatrix, shadowCamView);
	    var rectViewport = lightRenderData.shadowViewport;
	    shadowCam.rect = rectViewport;
	    shadowCam.scissorRect = lightRenderData.shadowScissor;
	    viewportMatrix.setViewport(rectViewport.x, rectViewport.y, rectViewport.z, rectViewport.w);
	    lightRenderData.shadowMatrix.mul2(viewportMatrix, shadowCamViewProj);

	    if (light._type === LIGHTTYPE_DIRECTIONAL) {
	      light._shadowMatrixPalette.set(lightRenderData.shadowMatrix.data, face * 16);
	    }
	  };

	  _proto.submitCasters = function submitCasters(visibleCasters, light) {
	    var device = this.device;
	    var forwardRenderer = this.forwardRenderer;
	    var scene = forwardRenderer.scene;
	    var passFlags = 1 << SHADER_SHADOW;
	    var shadowPass = ShaderPass.getShadow(light._type, light._shadowType);
	    var count = visibleCasters.length;

	    for (var i = 0; i < count; i++) {
	      var meshInstance = visibleCasters[i];
	      var mesh = meshInstance.mesh;
	      meshInstance.ensureMaterial(device);
	      var material = meshInstance.material;
	      forwardRenderer.setBaseConstants(device, material);
	      forwardRenderer.setSkinning(device, meshInstance, material);

	      if (material.dirty) {
	        material.updateUniforms(device, scene);
	        material.dirty = false;
	      }

	      if (material.chunks) {
	        forwardRenderer.setCullMode(true, false, meshInstance);
	        material.setParameters(device);
	        meshInstance.setParameters(device, passFlags);
	      }

	      var shadowShader = meshInstance._shader[shadowPass];

	      if (!shadowShader) {
	        meshInstance.updatePassShader(scene, shadowPass);
	        shadowShader = meshInstance._shader[shadowPass];
	        meshInstance._key[SORTKEY_DEPTH] = getDepthKey(meshInstance);
	      }

	      if (!shadowShader.failed && !device.setShader(shadowShader)) ;

	      forwardRenderer.setVertexBuffers(device, mesh);
	      forwardRenderer.setMorphing(device, meshInstance.morphInstance);
	      var style = meshInstance.renderStyle;
	      device.setIndexBuffer(mesh.indexBuffer[style]);
	      forwardRenderer.drawInstance(device, meshInstance, mesh, style);
	      forwardRenderer._shadowDrawCalls++;
	    }
	  };

	  _proto.render = function render(light, camera) {
	    if (light.enabled && light.castShadows && light.shadowUpdateMode !== SHADOWUPDATE_NONE && light.visibleThisFrame) {
	      var device = this.device;

	      if (light.shadowUpdateMode === SHADOWUPDATE_THISFRAME) {
	        light.shadowUpdateMode = SHADOWUPDATE_NONE;
	      }

	      var type = light._type;
	      var shadowType = light._shadowType;
	      var faceCount = light.numShadowFaces;
	      var forwardRenderer = this.forwardRenderer;
	      forwardRenderer._shadowMapUpdates += faceCount;
	      var isClustered = forwardRenderer.scene.clusteredLightingEnabled;
	      this.setupRenderState(device, light);

	      for (var face = 0; face < faceCount; face++) {
	        var lightRenderData = light.getRenderData(type === LIGHTTYPE_DIRECTIONAL ? camera : null, face);
	        var shadowCam = lightRenderData.shadowCamera;
	        ShadowRenderer.setShadowCameraSettings(shadowCam, device, shadowType, type, isClustered);
	        var renderTargetIndex = type === LIGHTTYPE_DIRECTIONAL ? 0 : face;
	        shadowCam.renderTarget = light._shadowMap.renderTargets[renderTargetIndex];
	        this.dispatchUniforms(light, shadowCam, lightRenderData, face);
	        forwardRenderer.setCamera(shadowCam, shadowCam.renderTarget, true);
	        this.submitCasters(lightRenderData.visibleCasters, light);
	      }

	      if (light._isVsm && light._vsmBlurSize > 1) {
	        var _isClustered = this.forwardRenderer.scene.clusteredLightingEnabled;

	        if (!_isClustered || type === LIGHTTYPE_DIRECTIONAL) {
	          this.applyVsmBlur(light, camera);
	        }
	      }

	      this.restoreRenderState(device);
	    }
	  };

	  _proto.getVsmBlurShader = function getVsmBlurShader(isVsm8, blurMode, filterSize) {
	    var blurShader = (isVsm8 ? this.blurPackedVsmShader : this.blurVsmShader)[blurMode][filterSize];

	    if (!blurShader) {
	      this.blurVsmWeights[filterSize] = gaussWeights(filterSize);
	      var blurVS = shaderChunks.fullscreenQuadVS;
	      var blurFS = '#define SAMPLES ' + filterSize + '\n';

	      if (isVsm8) {
	        blurFS += this.blurPackedVsmShaderCode[blurMode];
	      } else {
	        blurFS += this.blurVsmShaderCode[blurMode];
	      }

	      var blurShaderName = 'blurVsm' + blurMode + '' + filterSize + '' + isVsm8;
	      blurShader = createShaderFromCode(this.device, blurVS, blurFS, blurShaderName);

	      if (isVsm8) {
	        this.blurPackedVsmShader[blurMode][filterSize] = blurShader;
	      } else {
	        this.blurVsmShader[blurMode][filterSize] = blurShader;
	      }
	    }

	    return blurShader;
	  };

	  _proto.applyVsmBlur = function applyVsmBlur(light, camera) {
	    var device = this.device;
	    var lightRenderData = light.getRenderData(light._type === LIGHTTYPE_DIRECTIONAL ? camera : null, 0);
	    var shadowCam = lightRenderData.shadowCamera;
	    var origShadowMap = shadowCam.renderTarget;
	    var tempShadowMap = this.shadowMapCache.get(device, light);
	    var tempRt = tempShadowMap.renderTargets[0];
	    var isVsm8 = light._shadowType === SHADOW_VSM8;
	    var blurMode = light.vsmBlurMode;
	    var filterSize = light._vsmBlurSize;
	    var blurShader = this.getVsmBlurShader(isVsm8, blurMode, filterSize);
	    blurScissorRect.z = light._shadowResolution - 2;
	    blurScissorRect.w = blurScissorRect.z;
	    this.sourceId.setValue(origShadowMap.colorBuffer);
	    pixelOffset[0] = 1 / light._shadowResolution;
	    pixelOffset[1] = 0;
	    this.pixelOffsetId.setValue(pixelOffset);
	    if (blurMode === BLUR_GAUSSIAN) this.weightId.setValue(this.blurVsmWeights[filterSize]);
	    drawQuadWithShader(device, tempRt, blurShader, null, blurScissorRect);
	    this.sourceId.setValue(tempRt.colorBuffer);
	    pixelOffset[1] = pixelOffset[0];
	    pixelOffset[0] = 0;
	    this.pixelOffsetId.setValue(pixelOffset);
	    drawQuadWithShader(device, origShadowMap, blurShader, null, blurScissorRect);
	    this.shadowMapCache.add(light, tempShadowMap);
	  };

	  return ShadowRenderer;
	}();

	var tempSphere$2 = new BoundingSphere();

	var StaticMeshes = function () {
	  function StaticMeshes() {}

	  StaticMeshes.lightCompare = function lightCompare(lightA, lightB) {
	    return lightA.key - lightB.key;
	  };

	  StaticMeshes.prepare = function prepare(device, scene, meshInstances, lights) {
	    var drawCalls = meshInstances;
	    var drawCallsCount = drawCalls.length;
	    var newDrawCalls = [];
	    var minVec = new Vec3();
	    var maxVec = new Vec3();
	    var localLightBounds = new BoundingBox();
	    var invMatrix = new Mat4();
	    var triLightComb = [];
	    var lightAabb = [];
	    var triBounds = [];
	    var staticLights = [];

	    for (var i = 0; i < drawCallsCount; i++) {
	      var drawCall = drawCalls[i];

	      if (!drawCall.isStatic) {
	        newDrawCalls.push(drawCall);
	      } else {
	        var aabb = drawCall.aabb;
	        staticLights.length = 0;

	        for (var lightTypePass = LIGHTTYPE_OMNI; lightTypePass <= LIGHTTYPE_SPOT; lightTypePass++) {
	          for (var j = 0; j < lights.length; j++) {
	            var light = lights[j];
	            if (light._type !== lightTypePass) continue;

	            if (light.enabled) {
	              if (light.mask & drawCall.mask) {
	                if (light.isStatic) {
	                  if (!lightAabb[j]) {
	                    lightAabb[j] = new BoundingBox();

	                    light._node.getWorldTransform();

	                    light.getBoundingSphere(tempSphere$2);
	                    lightAabb[j].center.copy(tempSphere$2.center);
	                    lightAabb[j].halfExtents.set(tempSphere$2.radius, tempSphere$2.radius, tempSphere$2.radius);
	                  }

	                  if (!lightAabb[j].intersects(aabb)) continue;
	                  staticLights.push(j);
	                }
	              }
	            }
	          }
	        }

	        if (staticLights.length === 0) {
	          newDrawCalls.push(drawCall);
	          continue;
	        }

	        var mesh = drawCall.mesh;
	        var vertexBuffer = mesh.vertexBuffer;
	        var indexBuffer = mesh.indexBuffer[drawCall.renderStyle];
	        var indices = indexBuffer.bytesPerIndex === 2 ? new Uint16Array(indexBuffer.lock()) : new Uint32Array(indexBuffer.lock());
	        var numTris = mesh.primitive[drawCall.renderStyle].count / 3;
	        var baseIndex = mesh.primitive[drawCall.renderStyle].base;
	        var elems = vertexBuffer.format.elements;
	        var vertSize = vertexBuffer.format.size / 4;
	        var verts = new Float32Array(vertexBuffer.storage);
	        var offsetP = void 0;

	        for (var k = 0; k < elems.length; k++) {
	          if (elems[k].name === SEMANTIC_POSITION) {
	            offsetP = elems[k].offset / 4;
	          }
	        }

	        triLightComb.length = numTris;

	        for (var _k = 0; _k < numTris; _k++) {
	          triLightComb[_k] = 0;
	        }

	        var triLightCombUsed = false;
	        triBounds.length = numTris * 6;

	        for (var _k2 = 0; _k2 < numTris; _k2++) {
	          var minx = Number.MAX_VALUE;
	          var miny = Number.MAX_VALUE;
	          var minz = Number.MAX_VALUE;
	          var maxx = -Number.MAX_VALUE;
	          var maxy = -Number.MAX_VALUE;
	          var maxz = -Number.MAX_VALUE;

	          for (var v = 0; v < 3; v++) {
	            var _index = indices[_k2 * 3 + v + baseIndex];
	            _index = _index * vertSize + offsetP;
	            var _x = verts[_index];
	            var _y = verts[_index + 1];
	            var _z = verts[_index + 2];
	            if (_x < minx) minx = _x;
	            if (_y < miny) miny = _y;
	            if (_z < minz) minz = _z;
	            if (_x > maxx) maxx = _x;
	            if (_y > maxy) maxy = _y;
	            if (_z > maxz) maxz = _z;
	          }

	          var index = _k2 * 6;
	          triBounds[index] = minx;
	          triBounds[index + 1] = miny;
	          triBounds[index + 2] = minz;
	          triBounds[index + 3] = maxx;
	          triBounds[index + 4] = maxy;
	          triBounds[index + 5] = maxz;
	        }

	        for (var s = 0; s < staticLights.length; s++) {
	          var _j = staticLights[s];
	          invMatrix.copy(drawCall.node.worldTransform).invert();
	          localLightBounds.setFromTransformedAabb(lightAabb[_j], invMatrix);
	          var minv = localLightBounds.getMin();
	          var maxv = localLightBounds.getMax();
	          var bit = 1 << s;

	          for (var _k3 = 0; _k3 < numTris; _k3++) {
	            var _index2 = _k3 * 6;

	            if (triBounds[_index2] <= maxv.x && triBounds[_index2 + 3] >= minv.x && triBounds[_index2 + 1] <= maxv.y && triBounds[_index2 + 4] >= minv.y && triBounds[_index2 + 2] <= maxv.z && triBounds[_index2 + 5] >= minv.z) {
	              triLightComb[_k3] |= bit;
	              triLightCombUsed = true;
	            }
	          }
	        }

	        if (triLightCombUsed) {
	          var combIndices = {};

	          for (var _k4 = 0; _k4 < numTris; _k4++) {
	            var _j2 = _k4 * 3 + baseIndex;

	            var combIbName = triLightComb[_k4];
	            if (!combIndices[combIbName]) combIndices[combIbName] = [];
	            var combIb = combIndices[combIbName];
	            combIb.push(indices[_j2]);
	            combIb.push(indices[_j2 + 1]);
	            combIb.push(indices[_j2 + 2]);
	          }

	          for (var _combIbName in combIndices) {
	            var _combIb = combIndices[_combIbName];
	            var ib = new IndexBuffer(device, indexBuffer.format, _combIb.length, indexBuffer.usage);
	            var ib2 = ib.bytesPerIndex === 2 ? new Uint16Array(ib.lock()) : new Uint32Array(ib.lock());
	            ib2.set(_combIb);
	            ib.unlock();
	            var _minx = Number.MAX_VALUE;
	            var _miny = Number.MAX_VALUE;
	            var _minz = Number.MAX_VALUE;

	            var _maxx = -Number.MAX_VALUE;

	            var _maxy = -Number.MAX_VALUE;

	            var _maxz = -Number.MAX_VALUE;

	            for (var _k5 = 0; _k5 < _combIb.length; _k5++) {
	              var _index3 = _combIb[_k5];
	              var _x2 = verts[_index3 * vertSize + offsetP];
	              var _y2 = verts[_index3 * vertSize + offsetP + 1];
	              var _z2 = verts[_index3 * vertSize + offsetP + 2];
	              if (_x2 < _minx) _minx = _x2;
	              if (_y2 < _miny) _miny = _y2;
	              if (_z2 < _minz) _minz = _z2;
	              if (_x2 > _maxx) _maxx = _x2;
	              if (_y2 > _maxy) _maxy = _y2;
	              if (_z2 > _maxz) _maxz = _z2;
	            }

	            minVec.set(_minx, _miny, _minz);
	            maxVec.set(_maxx, _maxy, _maxz);
	            var chunkAabb = new BoundingBox();
	            chunkAabb.setMinMax(minVec, maxVec);
	            var mesh2 = new Mesh(device);
	            mesh2.vertexBuffer = vertexBuffer;
	            mesh2.indexBuffer[0] = ib;
	            mesh2.primitive[0].type = PRIMITIVE_TRIANGLES;
	            mesh2.primitive[0].base = 0;
	            mesh2.primitive[0].count = _combIb.length;
	            mesh2.primitive[0].indexed = true;
	            mesh2.aabb = chunkAabb;
	            var instance = new MeshInstance(mesh2, drawCall.material, drawCall.node);
	            instance.isStatic = drawCall.isStatic;
	            instance.visible = drawCall.visible;
	            instance.layer = drawCall.layer;
	            instance.castShadow = drawCall.castShadow;
	            instance._receiveShadow = drawCall._receiveShadow;
	            instance.cull = drawCall.cull;
	            instance.pick = drawCall.pick;
	            instance.mask = drawCall.mask;
	            instance.parameters = drawCall.parameters;
	            instance._shaderDefs = drawCall._shaderDefs;
	            instance._staticSource = drawCall;

	            if (drawCall._staticLightList) {
	              instance._staticLightList = drawCall._staticLightList;
	            } else {
	              instance._staticLightList = [];
	            }

	            for (var _k6 = 0; _k6 < staticLights.length; _k6++) {
	              var _bit = 1 << _k6;

	              if (_combIbName & _bit) {
	                var lht = lights[staticLights[_k6]];

	                if (instance._staticLightList.indexOf(lht) < 0) {
	                  instance._staticLightList.push(lht);
	                }
	              }
	            }

	            instance._staticLightList.sort(StaticMeshes.lightCompare);

	            newDrawCalls.push(instance);
	          }
	        } else {
	          newDrawCalls.push(drawCall);
	        }
	      }
	    }

	    meshInstances.length = newDrawCalls.length;

	    for (var _i = 0; _i < newDrawCalls.length; _i++) {
	      meshInstances[_i] = newDrawCalls[_i];
	    }
	  };

	  StaticMeshes.revert = function revert(meshInstances) {
	    var drawCalls = meshInstances;
	    var drawCallsCount = drawCalls.length;
	    var newDrawCalls = [];
	    var prevStaticSource;

	    for (var i = 0; i < drawCallsCount; i++) {
	      var drawCall = drawCalls[i];

	      if (drawCall._staticSource) {
	        if (drawCall._staticSource !== prevStaticSource) {
	          newDrawCalls.push(drawCall._staticSource);
	          prevStaticSource = drawCall._staticSource;
	        }
	      } else {
	        newDrawCalls.push(drawCall);
	      }
	    }

	    meshInstances.length = newDrawCalls.length;

	    for (var _i2 = 0; _i2 < newDrawCalls.length; _i2++) {
	      meshInstances[_i2] = newDrawCalls[_i2];
	    }
	  };

	  return StaticMeshes;
	}();

	new Vec3(1, 1, 1);
	new Vec3(40, 0, 0);

	var viewInvMat = new Mat4();
	var viewMat = new Mat4();
	var viewMat3 = new Mat3();
	var viewProjMat = new Mat4();
	var projMat;
	var flipYMat = new Mat4().setScale(1, -1, 1);
	var flippedViewProjMat = new Mat4();
	var flippedSkyboxProjMat = new Mat4();
	var worldMatX = new Vec3();
	var worldMatY = new Vec3();
	var worldMatZ = new Vec3();
	var webgl1DepthClearColor = new Color(254.0 / 255, 254.0 / 255, 254.0 / 255, 254.0 / 255);
	var tempSphere$1 = new BoundingSphere();
	var boneTextureSize = [0, 0, 0, 0];
	var boneTexture, instancingData, modelMatrix, normalMatrix;
	var keyA$1, keyB$1;
	var _skinUpdateIndex = 0;
	var _drawCallList = {
	  drawCalls: [],
	  isNewMaterial: [],
	  lightMaskChanged: []
	};

	var _tempMaterialSet = new Set();

	var ForwardRenderer = function () {
	  function ForwardRenderer(graphicsDevice) {
	    this.clustersDebugRendered = false;
	    this.device = graphicsDevice;
	    this.scene = null;
	    this._shadowDrawCalls = 0;
	    this._forwardDrawCalls = 0;
	    this._skinDrawCalls = 0;
	    this._numDrawCallsCulled = 0;
	    this._instancedDrawCalls = 0;
	    this._camerasRendered = 0;
	    this._materialSwitches = 0;
	    this._shadowMapUpdates = 0;
	    this._shadowMapTime = 0;
	    this._depthMapTime = 0;
	    this._forwardTime = 0;
	    this._cullTime = 0;
	    this._sortTime = 0;
	    this._skinTime = 0;
	    this._morphTime = 0;
	    this._layerCompositionUpdateTime = 0;
	    this._lightClustersTime = 0;
	    this._lightClusters = 0;
	    var device = this.device;
	    this.library = device.getProgramLibrary();
	    this.lightTextureAtlas = new LightTextureAtlas(device);
	    this._shadowRenderer = new ShadowRenderer(this, this.lightTextureAtlas);
	    this._cookieRenderer = new CookieRenderer(device, this.lightTextureAtlas);
	    var scope = device.scope;
	    this.projId = scope.resolve('matrix_projection');
	    this.projSkyboxId = scope.resolve('matrix_projectionSkybox');
	    this.viewId = scope.resolve('matrix_view');
	    this.viewId3 = scope.resolve('matrix_view3');
	    this.viewInvId = scope.resolve('matrix_viewInverse');
	    this.viewProjId = scope.resolve('matrix_viewProjection');
	    this.flipYId = scope.resolve('projectionFlipY');
	    this.viewPos = new Float32Array(3);
	    this.viewPosId = scope.resolve('view_position');
	    this.nearClipId = scope.resolve('camera_near');
	    this.farClipId = scope.resolve('camera_far');
	    this.cameraParamsId = scope.resolve('camera_params');
	    this.tbnBasis = scope.resolve('tbnBasis');
	    this.fogColorId = scope.resolve('fog_color');
	    this.fogStartId = scope.resolve('fog_start');
	    this.fogEndId = scope.resolve('fog_end');
	    this.fogDensityId = scope.resolve('fog_density');
	    this.modelMatrixId = scope.resolve('matrix_model');
	    this.normalMatrixId = scope.resolve('matrix_normal');
	    this.poseMatrixId = scope.resolve('matrix_pose[0]');
	    this.boneTextureId = scope.resolve('texture_poseMap');
	    this.boneTextureSizeId = scope.resolve('texture_poseMapSize');
	    this.morphWeightsA = scope.resolve('morph_weights_a');
	    this.morphWeightsB = scope.resolve('morph_weights_b');
	    this.morphPositionTex = scope.resolve('morphPositionTex');
	    this.morphNormalTex = scope.resolve('morphNormalTex');
	    this.morphTexParams = scope.resolve('morph_tex_params');
	    this.alphaTestId = scope.resolve('alpha_ref');
	    this.opacityMapId = scope.resolve('texture_opacityMap');
	    this.ambientId = scope.resolve('light_globalAmbient');
	    this.exposureId = scope.resolve('exposure');
	    this.skyboxIntensityId = scope.resolve('skyboxIntensity');
	    this.lightColorId = [];
	    this.lightDir = [];
	    this.lightDirId = [];
	    this.lightShadowMapId = [];
	    this.lightShadowMatrixId = [];
	    this.lightShadowParamsId = [];
	    this.lightShadowIntensity = [];
	    this.lightRadiusId = [];
	    this.lightPos = [];
	    this.lightPosId = [];
	    this.lightWidth = [];
	    this.lightWidthId = [];
	    this.lightHeight = [];
	    this.lightHeightId = [];
	    this.lightInAngleId = [];
	    this.lightOutAngleId = [];
	    this.lightCookieId = [];
	    this.lightCookieIntId = [];
	    this.lightCookieMatrixId = [];
	    this.lightCookieOffsetId = [];
	    this.shadowMatrixPaletteId = [];
	    this.shadowCascadeDistancesId = [];
	    this.shadowCascadeCountId = [];
	    this.screenSizeId = scope.resolve('uScreenSize');
	    this._screenSize = new Float32Array(4);
	    this.twoSidedLightingNegScaleFactorId = scope.resolve('twoSidedLightingNegScaleFactor');
	    this.fogColor = new Float32Array(3);
	    this.ambientColor = new Float32Array(3);
	    this.cameraParams = new Float32Array(4);
	    this.viewUniformFormat = null;
	    this.viewBindGroupFormat = null;
	  }

	  var _proto = ForwardRenderer.prototype;

	  _proto.destroy = function destroy() {
	    this._shadowRenderer.destroy();

	    this._shadowRenderer = null;

	    this._cookieRenderer.destroy();

	    this._cookieRenderer = null;
	    this.lightTextureAtlas.destroy();
	    this.lightTextureAtlas = null;
	  };

	  _proto.sortCompare = function sortCompare(drawCallA, drawCallB) {
	    if (drawCallA.layer === drawCallB.layer) {
	      if (drawCallA.drawOrder && drawCallB.drawOrder) {
	        return drawCallA.drawOrder - drawCallB.drawOrder;
	      } else if (drawCallA.zdist && drawCallB.zdist) {
	        return drawCallB.zdist - drawCallA.zdist;
	      } else if (drawCallA.zdist2 && drawCallB.zdist2) {
	        return drawCallA.zdist2 - drawCallB.zdist2;
	      }
	    }

	    return drawCallB._key[SORTKEY_FORWARD] - drawCallA._key[SORTKEY_FORWARD];
	  };

	  _proto.sortCompareMesh = function sortCompareMesh(drawCallA, drawCallB) {
	    if (drawCallA.layer === drawCallB.layer) {
	      if (drawCallA.drawOrder && drawCallB.drawOrder) {
	        return drawCallA.drawOrder - drawCallB.drawOrder;
	      } else if (drawCallA.zdist && drawCallB.zdist) {
	        return drawCallB.zdist - drawCallA.zdist;
	      }
	    }

	    keyA$1 = drawCallA._key[SORTKEY_FORWARD];
	    keyB$1 = drawCallB._key[SORTKEY_FORWARD];

	    if (keyA$1 === keyB$1 && drawCallA.mesh && drawCallB.mesh) {
	      return drawCallB.mesh.id - drawCallA.mesh.id;
	    }

	    return keyB$1 - keyA$1;
	  };

	  _proto.depthSortCompare = function depthSortCompare(drawCallA, drawCallB) {
	    keyA$1 = drawCallA._key[SORTKEY_DEPTH];
	    keyB$1 = drawCallB._key[SORTKEY_DEPTH];

	    if (keyA$1 === keyB$1 && drawCallA.mesh && drawCallB.mesh) {
	      return drawCallB.mesh.id - drawCallA.mesh.id;
	    }

	    return keyB$1 - keyA$1;
	  };

	  _proto.updateCameraFrustum = function updateCameraFrustum(camera) {
	    if (camera.xr && camera.xr.views.length) {
	      var view = camera.xr.views[0];
	      viewProjMat.mul2(view.projMat, view.viewOffMat);
	      camera.frustum.setFromMat4(viewProjMat);
	      return;
	    }

	    projMat = camera.projectionMatrix;

	    if (camera.calculateProjection) {
	      camera.calculateProjection(projMat, VIEW_CENTER);
	    }

	    if (camera.calculateTransform) {
	      camera.calculateTransform(viewInvMat, VIEW_CENTER);
	    } else {
	      var pos = camera._node.getPosition();

	      var rot = camera._node.getRotation();

	      viewInvMat.setTRS(pos, rot, Vec3.ONE);
	      this.viewInvId.setValue(viewInvMat.data);
	    }

	    viewMat.copy(viewInvMat).invert();
	    viewProjMat.mul2(projMat, viewMat);
	    camera.frustum.setFromMat4(viewProjMat);
	  };

	  _proto.initViewBindGroupFormat = function initViewBindGroupFormat() {
	    if (this.device.supportsUniformBuffers && !this.viewUniformFormat) {
	      this.viewUniformFormat = new UniformBufferFormat(this.device, [new UniformFormat("matrix_viewProjection", UNIFORMTYPE_MAT4)]);
	      this.viewBindGroupFormat = new BindGroupFormat(this.device, [new BindBufferFormat(UNIFORM_BUFFER_DEFAULT_SLOT_NAME, SHADERSTAGE_VERTEX | SHADERSTAGE_FRAGMENT)], []);
	    }
	  };

	  _proto.setCameraUniforms = function setCameraUniforms(camera, target, renderAction) {
	    var transform;
	    var viewCount = 1;

	    if (camera.xr && camera.xr.session) {
	      var parent = camera._node.parent;
	      if (parent) transform = parent.getWorldTransform();
	      var views = camera.xr.views;
	      viewCount = views.length;

	      for (var v = 0; v < viewCount; v++) {
	        var view = views[v];

	        if (parent) {
	          view.viewInvOffMat.mul2(transform, view.viewInvMat);
	          view.viewOffMat.copy(view.viewInvOffMat).invert();
	        } else {
	          view.viewInvOffMat.copy(view.viewInvMat);
	          view.viewOffMat.copy(view.viewMat);
	        }

	        view.viewMat3.setFromMat4(view.viewOffMat);
	        view.projViewOffMat.mul2(view.projMat, view.viewOffMat);
	        view.position[0] = view.viewInvOffMat.data[12];
	        view.position[1] = view.viewInvOffMat.data[13];
	        view.position[2] = view.viewInvOffMat.data[14];
	        camera.frustum.setFromMat4(view.projViewOffMat);
	      }
	    } else {
	      projMat = camera.projectionMatrix;

	      if (camera.calculateProjection) {
	        camera.calculateProjection(projMat, VIEW_CENTER);
	      }

	      this.projId.setValue(projMat.data);
	      this.projSkyboxId.setValue(camera.getProjectionMatrixSkybox().data);

	      if (camera.calculateTransform) {
	        camera.calculateTransform(viewInvMat, VIEW_CENTER);
	      } else {
	        var pos = camera._node.getPosition();

	        var rot = camera._node.getRotation();

	        viewInvMat.setTRS(pos, rot, Vec3.ONE);
	      }

	      this.viewInvId.setValue(viewInvMat.data);
	      viewMat.copy(viewInvMat).invert();
	      this.viewId.setValue(viewMat.data);
	      viewMat3.setFromMat4(viewMat);
	      this.viewId3.setValue(viewMat3.data);
	      viewProjMat.mul2(projMat, viewMat);

	      if (target && target.flipY) {
	        flippedViewProjMat.mul2(flipYMat, viewProjMat);
	        flippedSkyboxProjMat.mul2(flipYMat, camera.getProjectionMatrixSkybox());
	        this.viewProjId.setValue(flippedViewProjMat.data);
	        this.projSkyboxId.setValue(flippedSkyboxProjMat.data);
	      } else {
	        this.viewProjId.setValue(viewProjMat.data);
	        this.projSkyboxId.setValue(camera.getProjectionMatrixSkybox().data);
	      }

	      this.flipYId.setValue(target != null && target.flipY ? -1 : 1);
	      this.dispatchViewPos(camera._node.getPosition());
	      camera.frustum.setFromMat4(viewProjMat);
	    }

	    this.tbnBasis.setValue(target && target.flipY ? -1 : 1);
	    this.nearClipId.setValue(camera._nearClip);
	    this.farClipId.setValue(camera._farClip);
	    var n = camera._nearClip;
	    var f = camera._farClip;
	    this.cameraParams[0] = 1 / f;
	    this.cameraParams[1] = f;
	    this.cameraParams[2] = n;
	    this.cameraParams[3] = camera.projection === PROJECTION_ORTHOGRAPHIC ? 1 : 0;
	    this.cameraParamsId.setValue(this.cameraParams);

	    if (this.device.supportsUniformBuffers) {
	      this.setupViewUniformBuffers(renderAction, viewCount);
	    }
	  };

	  _proto.setCamera = function setCamera(camera, target, clear, renderAction) {
	    if (renderAction === void 0) {
	      renderAction = null;
	    }

	    this.setCameraUniforms(camera, target, renderAction);
	    this.clearView(camera, target, clear, false);
	  };

	  _proto.setupViewUniformBuffers = function setupViewUniformBuffers(renderAction, viewCount) {
	    if (renderAction) {
	      var device = this.device;

	      while (renderAction.viewBindGroups.length < viewCount) {
	        var ub = new UniformBuffer(device, this.viewUniformFormat);
	        var bg = new BindGroup(device, this.viewBindGroupFormat, ub);
	        renderAction.viewBindGroups.push(bg);
	      }

	      var viewBindGroup = renderAction.viewBindGroups[0];
	      viewBindGroup.defaultUniformBuffer.update();
	      viewBindGroup.update();
	      device.setBindGroup(BINDGROUP_VIEW, viewBindGroup);
	    }
	  };

	  _proto.setupViewport = function setupViewport(camera, renderTarget) {
	    var device = this.device;
	    var pixelWidth = renderTarget ? renderTarget.width : device.width;
	    var pixelHeight = renderTarget ? renderTarget.height : device.height;
	    var rect = camera.rect;
	    var x = Math.floor(rect.x * pixelWidth);
	    var y = Math.floor(rect.y * pixelHeight);
	    var w = Math.floor(rect.z * pixelWidth);
	    var h = Math.floor(rect.w * pixelHeight);
	    device.setViewport(x, y, w, h);

	    if (camera._scissorRectClear) {
	      var scissorRect = camera.scissorRect;
	      x = Math.floor(scissorRect.x * pixelWidth);
	      y = Math.floor(scissorRect.y * pixelHeight);
	      w = Math.floor(scissorRect.z * pixelWidth);
	      h = Math.floor(scissorRect.w * pixelHeight);
	    }

	    device.setScissor(x, y, w, h);
	  };

	  _proto.clear = function clear(renderAction, camera) {
	    var device = this.device;
	    device.clear({
	      color: [camera._clearColor.r, camera._clearColor.g, camera._clearColor.b, camera._clearColor.a],
	      depth: camera._clearDepth,
	      stencil: camera._clearStencil,
	      flags: (renderAction.clearColor ? CLEARFLAG_COLOR : 0) | (renderAction.clearDepth ? CLEARFLAG_DEPTH : 0) | (renderAction.clearStencil ? CLEARFLAG_STENCIL : 0)
	    });
	  };

	  _proto.clearView = function clearView(camera, target, clear, forceWrite) {
	    var device = this.device;
	    device.setRenderTarget(target);
	    device.updateBegin();

	    if (forceWrite) {
	      device.setColorWrite(true, true, true, true);
	      device.setDepthWrite(true);
	    }

	    this.setupViewport(camera, target);

	    if (clear) {
	      var options = camera._clearOptions;
	      device.clear(options ? options : {
	        color: [camera._clearColor.r, camera._clearColor.g, camera._clearColor.b, camera._clearColor.a],
	        depth: camera._clearDepth,
	        flags: (camera._clearColorBuffer ? CLEARFLAG_COLOR : 0) | (camera._clearDepthBuffer ? CLEARFLAG_DEPTH : 0) | (camera._clearStencilBuffer ? CLEARFLAG_STENCIL : 0),
	        stencil: camera._clearStencil
	      });
	    }
	  };

	  _proto.dispatchGlobalLights = function dispatchGlobalLights(scene) {
	    this.ambientColor[0] = scene.ambientLight.r;
	    this.ambientColor[1] = scene.ambientLight.g;
	    this.ambientColor[2] = scene.ambientLight.b;

	    if (scene.gammaCorrection) {
	      for (var i = 0; i < 3; i++) {
	        this.ambientColor[i] = Math.pow(this.ambientColor[i], 2.2);
	      }
	    }

	    this.ambientId.setValue(this.ambientColor);
	    this.exposureId.setValue(scene.exposure);

	    if (scene.sky) {
	      this.skyboxIntensityId.setValue(scene.skyboxIntensity);
	    }
	  };

	  _proto._resolveLight = function _resolveLight(scope, i) {
	    var light = 'light' + i;
	    this.lightColorId[i] = scope.resolve(light + '_color');
	    this.lightDir[i] = new Float32Array(3);
	    this.lightDirId[i] = scope.resolve(light + '_direction');
	    this.lightShadowMapId[i] = scope.resolve(light + '_shadowMap');
	    this.lightShadowMatrixId[i] = scope.resolve(light + '_shadowMatrix');
	    this.lightShadowParamsId[i] = scope.resolve(light + '_shadowParams');
	    this.lightShadowIntensity[i] = scope.resolve(light + '_shadowIntensity');
	    this.lightRadiusId[i] = scope.resolve(light + '_radius');
	    this.lightPos[i] = new Float32Array(3);
	    this.lightPosId[i] = scope.resolve(light + '_position');
	    this.lightWidth[i] = new Float32Array(3);
	    this.lightWidthId[i] = scope.resolve(light + '_halfWidth');
	    this.lightHeight[i] = new Float32Array(3);
	    this.lightHeightId[i] = scope.resolve(light + '_halfHeight');
	    this.lightInAngleId[i] = scope.resolve(light + '_innerConeAngle');
	    this.lightOutAngleId[i] = scope.resolve(light + '_outerConeAngle');
	    this.lightCookieId[i] = scope.resolve(light + '_cookie');
	    this.lightCookieIntId[i] = scope.resolve(light + '_cookieIntensity');
	    this.lightCookieMatrixId[i] = scope.resolve(light + '_cookieMatrix');
	    this.lightCookieOffsetId[i] = scope.resolve(light + '_cookieOffset');
	    this.shadowMatrixPaletteId[i] = scope.resolve(light + '_shadowMatrixPalette[0]');
	    this.shadowCascadeDistancesId[i] = scope.resolve(light + '_shadowCascadeDistances[0]');
	    this.shadowCascadeCountId[i] = scope.resolve(light + '_shadowCascadeCount');
	  };

	  _proto.setLTCDirectionalLight = function setLTCDirectionalLight(wtm, cnt, dir, campos, far) {
	    this.lightPos[cnt][0] = campos.x - dir.x * far;
	    this.lightPos[cnt][1] = campos.y - dir.y * far;
	    this.lightPos[cnt][2] = campos.z - dir.z * far;
	    this.lightPosId[cnt].setValue(this.lightPos[cnt]);
	    var hWidth = wtm.transformVector(new Vec3(-0.5, 0, 0));
	    this.lightWidth[cnt][0] = hWidth.x * far;
	    this.lightWidth[cnt][1] = hWidth.y * far;
	    this.lightWidth[cnt][2] = hWidth.z * far;
	    this.lightWidthId[cnt].setValue(this.lightWidth[cnt]);
	    var hHeight = wtm.transformVector(new Vec3(0, 0, 0.5));
	    this.lightHeight[cnt][0] = hHeight.x * far;
	    this.lightHeight[cnt][1] = hHeight.y * far;
	    this.lightHeight[cnt][2] = hHeight.z * far;
	    this.lightHeightId[cnt].setValue(this.lightHeight[cnt]);
	  };

	  _proto.dispatchDirectLights = function dispatchDirectLights(dirs, scene, mask, camera) {
	    var cnt = 0;
	    var scope = this.device.scope;

	    for (var i = 0; i < dirs.length; i++) {
	      if (!(dirs[i].mask & mask)) continue;
	      var directional = dirs[i];

	      var wtm = directional._node.getWorldTransform();

	      if (!this.lightColorId[cnt]) {
	        this._resolveLight(scope, cnt);
	      }

	      this.lightColorId[cnt].setValue(scene.gammaCorrection ? directional._linearFinalColor : directional._finalColor);
	      wtm.getY(directional._direction).mulScalar(-1);

	      directional._direction.normalize();

	      this.lightDir[cnt][0] = directional._direction.x;
	      this.lightDir[cnt][1] = directional._direction.y;
	      this.lightDir[cnt][2] = directional._direction.z;
	      this.lightDirId[cnt].setValue(this.lightDir[cnt]);

	      if (directional.shape !== LIGHTSHAPE_PUNCTUAL) {
	        this.setLTCDirectionalLight(wtm, cnt, directional._direction, camera._node.getPosition(), camera.farClip);
	      }

	      if (directional.castShadows) {
	        var lightRenderData = directional.getRenderData(camera, 0);

	        var biases = directional._getUniformBiasValues(lightRenderData);

	        this.lightShadowMapId[cnt].setValue(lightRenderData.shadowBuffer);
	        this.lightShadowMatrixId[cnt].setValue(lightRenderData.shadowMatrix.data);
	        this.shadowMatrixPaletteId[cnt].setValue(directional._shadowMatrixPalette);
	        this.shadowCascadeDistancesId[cnt].setValue(directional._shadowCascadeDistances);
	        this.shadowCascadeCountId[cnt].setValue(directional.numCascades);
	        this.lightShadowIntensity[cnt].setValue(directional.shadowIntensity);
	        var params = directional._shadowRenderParams;
	        params.length = 3;
	        params[0] = directional._shadowResolution;
	        params[1] = biases.normalBias;
	        params[2] = biases.bias;
	        this.lightShadowParamsId[cnt].setValue(params);
	      }

	      cnt++;
	    }

	    return cnt;
	  };

	  _proto.setLTCPositionalLight = function setLTCPositionalLight(wtm, cnt) {
	    var hWidth = wtm.transformVector(new Vec3(-0.5, 0, 0));
	    this.lightWidth[cnt][0] = hWidth.x;
	    this.lightWidth[cnt][1] = hWidth.y;
	    this.lightWidth[cnt][2] = hWidth.z;
	    this.lightWidthId[cnt].setValue(this.lightWidth[cnt]);
	    var hHeight = wtm.transformVector(new Vec3(0, 0, 0.5));
	    this.lightHeight[cnt][0] = hHeight.x;
	    this.lightHeight[cnt][1] = hHeight.y;
	    this.lightHeight[cnt][2] = hHeight.z;
	    this.lightHeightId[cnt].setValue(this.lightHeight[cnt]);
	  };

	  _proto.dispatchOmniLight = function dispatchOmniLight(scene, scope, omni, cnt) {
	    var wtm = omni._node.getWorldTransform();

	    if (!this.lightColorId[cnt]) {
	      this._resolveLight(scope, cnt);
	    }

	    this.lightRadiusId[cnt].setValue(omni.attenuationEnd);
	    this.lightColorId[cnt].setValue(scene.gammaCorrection ? omni._linearFinalColor : omni._finalColor);
	    wtm.getTranslation(omni._position);
	    this.lightPos[cnt][0] = omni._position.x;
	    this.lightPos[cnt][1] = omni._position.y;
	    this.lightPos[cnt][2] = omni._position.z;
	    this.lightPosId[cnt].setValue(this.lightPos[cnt]);

	    if (omni.shape !== LIGHTSHAPE_PUNCTUAL) {
	      this.setLTCPositionalLight(wtm, cnt);
	    }

	    if (omni.castShadows) {
	      var lightRenderData = omni.getRenderData(null, 0);
	      this.lightShadowMapId[cnt].setValue(lightRenderData.shadowBuffer);

	      var biases = omni._getUniformBiasValues(lightRenderData);

	      var params = omni._shadowRenderParams;
	      params.length = 4;
	      params[0] = omni._shadowResolution;
	      params[1] = biases.normalBias;
	      params[2] = biases.bias;
	      params[3] = 1.0 / omni.attenuationEnd;
	      this.lightShadowParamsId[cnt].setValue(params);
	      this.lightShadowIntensity[cnt].setValue(omni.shadowIntensity);
	    }

	    if (omni._cookie) {
	      this.lightCookieId[cnt].setValue(omni._cookie);
	      this.lightShadowMatrixId[cnt].setValue(wtm.data);
	      this.lightCookieIntId[cnt].setValue(omni.cookieIntensity);
	    }
	  };

	  _proto.dispatchSpotLight = function dispatchSpotLight(scene, scope, spot, cnt) {
	    var wtm = spot._node.getWorldTransform();

	    if (!this.lightColorId[cnt]) {
	      this._resolveLight(scope, cnt);
	    }

	    this.lightInAngleId[cnt].setValue(spot._innerConeAngleCos);
	    this.lightOutAngleId[cnt].setValue(spot._outerConeAngleCos);
	    this.lightRadiusId[cnt].setValue(spot.attenuationEnd);
	    this.lightColorId[cnt].setValue(scene.gammaCorrection ? spot._linearFinalColor : spot._finalColor);
	    wtm.getTranslation(spot._position);
	    this.lightPos[cnt][0] = spot._position.x;
	    this.lightPos[cnt][1] = spot._position.y;
	    this.lightPos[cnt][2] = spot._position.z;
	    this.lightPosId[cnt].setValue(this.lightPos[cnt]);

	    if (spot.shape !== LIGHTSHAPE_PUNCTUAL) {
	      this.setLTCPositionalLight(wtm, cnt);
	    }

	    wtm.getY(spot._direction).mulScalar(-1);

	    spot._direction.normalize();

	    this.lightDir[cnt][0] = spot._direction.x;
	    this.lightDir[cnt][1] = spot._direction.y;
	    this.lightDir[cnt][2] = spot._direction.z;
	    this.lightDirId[cnt].setValue(this.lightDir[cnt]);

	    if (spot.castShadows) {
	      var lightRenderData = spot.getRenderData(null, 0);
	      this.lightShadowMapId[cnt].setValue(lightRenderData.shadowBuffer);
	      this.lightShadowMatrixId[cnt].setValue(lightRenderData.shadowMatrix.data);

	      var biases = spot._getUniformBiasValues(lightRenderData);

	      var params = spot._shadowRenderParams;
	      params.length = 4;
	      params[0] = spot._shadowResolution;
	      params[1] = biases.normalBias;
	      params[2] = biases.bias;
	      params[3] = 1.0 / spot.attenuationEnd;
	      this.lightShadowParamsId[cnt].setValue(params);
	      this.lightShadowIntensity[cnt].setValue(spot.shadowIntensity);
	    }

	    if (spot._cookie) {
	      if (!spot.castShadows) {
	        var cookieMatrix = LightCamera.evalSpotCookieMatrix(spot);
	        this.lightShadowMatrixId[cnt].setValue(cookieMatrix.data);
	      }

	      this.lightCookieId[cnt].setValue(spot._cookie);
	      this.lightCookieIntId[cnt].setValue(spot.cookieIntensity);

	      if (spot._cookieTransform) {
	        spot._cookieTransformUniform[0] = spot._cookieTransform.x;
	        spot._cookieTransformUniform[1] = spot._cookieTransform.y;
	        spot._cookieTransformUniform[2] = spot._cookieTransform.z;
	        spot._cookieTransformUniform[3] = spot._cookieTransform.w;
	        this.lightCookieMatrixId[cnt].setValue(spot._cookieTransformUniform);
	        spot._cookieOffsetUniform[0] = spot._cookieOffset.x;
	        spot._cookieOffsetUniform[1] = spot._cookieOffset.y;
	        this.lightCookieOffsetId[cnt].setValue(spot._cookieOffsetUniform);
	      }
	    }
	  };

	  _proto.dispatchLocalLights = function dispatchLocalLights(sortedLights, scene, mask, usedDirLights, staticLightList) {
	    var cnt = usedDirLights;
	    var scope = this.device.scope;
	    var omnis = sortedLights[LIGHTTYPE_OMNI];
	    var numOmnis = omnis.length;

	    for (var i = 0; i < numOmnis; i++) {
	      var omni = omnis[i];
	      if (!(omni.mask & mask)) continue;
	      if (omni.isStatic) continue;
	      this.dispatchOmniLight(scene, scope, omni, cnt);
	      cnt++;
	    }

	    var staticId = 0;

	    if (staticLightList) {
	      var _omni = staticLightList[staticId];

	      while (_omni && _omni._type === LIGHTTYPE_OMNI) {
	        this.dispatchOmniLight(scene, scope, _omni, cnt);
	        cnt++;
	        staticId++;
	        _omni = staticLightList[staticId];
	      }
	    }

	    var spts = sortedLights[LIGHTTYPE_SPOT];
	    var numSpts = spts.length;

	    for (var _i = 0; _i < numSpts; _i++) {
	      var spot = spts[_i];
	      if (!(spot.mask & mask)) continue;
	      if (spot.isStatic) continue;
	      this.dispatchSpotLight(scene, scope, spot, cnt);
	      cnt++;
	    }

	    if (staticLightList) {
	      var _spot = staticLightList[staticId];

	      while (_spot && _spot._type === LIGHTTYPE_SPOT) {
	        this.dispatchSpotLight(scene, scope, _spot, cnt);
	        cnt++;
	        staticId++;
	        _spot = staticLightList[staticId];
	      }
	    }
	  };

	  _proto.cull = function cull(camera, drawCalls, visibleList) {
	    var visibleLength = 0;
	    var drawCallsCount = drawCalls.length;
	    var cullingMask = camera.cullingMask || 0xFFFFFFFF;

	    if (!camera.frustumCulling) {
	      for (var i = 0; i < drawCallsCount; i++) {
	        var drawCall = drawCalls[i];
	        if (!drawCall.visible && !drawCall.command) continue;
	        if (drawCall.mask && (drawCall.mask & cullingMask) === 0) continue;
	        visibleList[visibleLength] = drawCall;
	        visibleLength++;
	        drawCall.visibleThisFrame = true;
	      }

	      return visibleLength;
	    }

	    for (var _i2 = 0; _i2 < drawCallsCount; _i2++) {
	      var _drawCall = drawCalls[_i2];

	      if (!_drawCall.command) {
	        if (!_drawCall.visible) continue;
	        var visible = true;
	        if (_drawCall.mask && (_drawCall.mask & cullingMask) === 0) continue;

	        if (_drawCall.cull) {
	          visible = _drawCall._isVisible(camera);
	        }

	        if (visible) {
	          visibleList[visibleLength] = _drawCall;
	          visibleLength++;
	          _drawCall.visibleThisFrame = true;
	        }
	      } else {
	        visibleList[visibleLength] = _drawCall;
	        visibleLength++;
	        _drawCall.visibleThisFrame = true;
	      }
	    }

	    return visibleLength;
	  };

	  _proto.cullLights = function cullLights(camera, lights) {
	    var clusteredLightingEnabled = this.scene.clusteredLightingEnabled;

	    for (var i = 0; i < lights.length; i++) {
	      var light = lights[i];

	      if (light.enabled) {
	        if (light._type !== LIGHTTYPE_DIRECTIONAL) {
	          light.getBoundingSphere(tempSphere$1);

	          if (camera.frustum.containsSphere(tempSphere$1)) {
	            light.visibleThisFrame = true;
	            var screenSize = camera.getScreenSize(tempSphere$1);
	            light.maxScreenSize = Math.max(light.maxScreenSize, screenSize);
	          } else {
	            if (!clusteredLightingEnabled) {
	              if (light.castShadows && !light.shadowMap) {
	                light.visibleThisFrame = true;
	              }
	            }
	          }
	        }
	      }
	    }
	  };

	  _proto.updateCpuSkinMatrices = function updateCpuSkinMatrices(drawCalls) {
	    _skinUpdateIndex++;
	    var drawCallsCount = drawCalls.length;
	    if (drawCallsCount === 0) return;

	    for (var i = 0; i < drawCallsCount; i++) {
	      var si = drawCalls[i].skinInstance;

	      if (si) {
	        si.updateMatrices(drawCalls[i].node, _skinUpdateIndex);
	        si._dirty = true;
	      }
	    }
	  };

	  _proto.updateGpuSkinMatrices = function updateGpuSkinMatrices(drawCalls) {
	    var drawCallsCount = drawCalls.length;

	    for (var i = 0; i < drawCallsCount; i++) {
	      if (!drawCalls[i].visibleThisFrame) continue;
	      var skin = drawCalls[i].skinInstance;

	      if (skin) {
	        if (skin._dirty) {
	          skin.updateMatrixPalette(drawCalls[i].node, _skinUpdateIndex);
	          skin._dirty = false;
	        }
	      }
	    }
	  };

	  _proto.updateMorphing = function updateMorphing(drawCalls) {
	    var drawCallsCount = drawCalls.length;

	    for (var i = 0; i < drawCallsCount; i++) {
	      var morphInst = drawCalls[i].morphInstance;

	      if (morphInst && morphInst._dirty && drawCalls[i].visibleThisFrame) {
	        morphInst.update();
	      }
	    }
	  };

	  _proto.setBaseConstants = function setBaseConstants(device, material) {
	    device.setCullMode(material.cull);

	    if (material.opacityMap) {
	      this.opacityMapId.setValue(material.opacityMap);
	      this.alphaTestId.setValue(material.alphaTest);
	    }
	  };

	  _proto.setSkinning = function setSkinning(device, meshInstance, material) {
	    if (meshInstance.skinInstance) {
	      this._skinDrawCalls++;

	      if (device.supportsBoneTextures) {
	        boneTexture = meshInstance.skinInstance.boneTexture;
	        this.boneTextureId.setValue(boneTexture);
	        boneTextureSize[0] = boneTexture.width;
	        boneTextureSize[1] = boneTexture.height;
	        boneTextureSize[2] = 1.0 / boneTexture.width;
	        boneTextureSize[3] = 1.0 / boneTexture.height;
	        this.boneTextureSizeId.setValue(boneTextureSize);
	      } else {
	        this.poseMatrixId.setValue(meshInstance.skinInstance.matrixPalette);
	      }
	    }
	  };

	  _proto.drawInstance = function drawInstance(device, meshInstance, mesh, style, normal) {
	    instancingData = meshInstance.instancingData;

	    if (instancingData) {
	      if (instancingData.count > 0) {
	        this._instancedDrawCalls++;
	        device.setVertexBuffer(instancingData.vertexBuffer);
	        device.draw(mesh.primitive[style], instancingData.count);
	      }
	    } else {
	      modelMatrix = meshInstance.node.worldTransform;
	      this.modelMatrixId.setValue(modelMatrix.data);

	      if (normal) {
	        normalMatrix = meshInstance.node.normalMatrix;

	        if (meshInstance.node._dirtyNormal) {
	          modelMatrix.invertTo3x3(normalMatrix);
	          normalMatrix.transpose();
	          meshInstance.node._dirtyNormal = false;
	        }

	        this.normalMatrixId.setValue(normalMatrix.data);
	      }

	      device.draw(mesh.primitive[style]);
	    }
	  };

	  _proto.drawInstance2 = function drawInstance2(device, meshInstance, mesh, style) {
	    instancingData = meshInstance.instancingData;

	    if (instancingData) {
	      if (instancingData.count > 0) {
	        this._instancedDrawCalls++;
	        device.draw(mesh.primitive[style], instancingData.count, true);
	      }
	    } else {
	      device.draw(mesh.primitive[style], undefined, true);
	    }
	  };

	  _proto.renderShadows = function renderShadows(lights, camera) {
	    var isClustered = this.scene.clusteredLightingEnabled;

	    for (var i = 0; i < lights.length; i++) {
	      var light = lights[i];

	      if (isClustered && light._type !== LIGHTTYPE_DIRECTIONAL) {
	        if (!light.atlasViewportAllocated) {
	          continue;
	        }

	        if (light.atlasSlotUpdated && light.shadowUpdateMode === SHADOWUPDATE_NONE) {
	          light.shadowUpdateMode = SHADOWUPDATE_THISFRAME;
	        }
	      }

	      this._shadowRenderer.render(light, camera);
	    }
	  };

	  _proto.renderCookies = function renderCookies(lights) {
	    var cookieRenderTarget = this.lightTextureAtlas.cookieRenderTarget;

	    for (var i = 0; i < lights.length; i++) {
	      var light = lights[i];
	      if (!light.atlasViewportAllocated) continue;
	      if (!light.atlasSlotUpdated) continue;

	      this._cookieRenderer.render(light, cookieRenderTarget);
	    }
	  };

	  _proto.setCullMode = function setCullMode(cullFaces, flip, drawCall) {
	    var material = drawCall.material;
	    var mode = CULLFACE_NONE;

	    if (cullFaces) {
	      var flipFaces = 1;

	      if (material.cull > CULLFACE_NONE && material.cull < CULLFACE_FRONTANDBACK) {
	        if (drawCall.flipFaces) flipFaces *= -1;
	        if (flip) flipFaces *= -1;
	        var wt = drawCall.node.worldTransform;
	        wt.getX(worldMatX);
	        wt.getY(worldMatY);
	        wt.getZ(worldMatZ);
	        worldMatX.cross(worldMatX, worldMatY);

	        if (worldMatX.dot(worldMatZ) < 0) {
	          flipFaces *= -1;
	        }
	      }

	      if (flipFaces < 0) {
	        mode = material.cull === CULLFACE_FRONT ? CULLFACE_BACK : CULLFACE_FRONT;
	      } else {
	        mode = material.cull;
	      }
	    }

	    this.device.setCullMode(mode);

	    if (mode === CULLFACE_NONE && material.cull === CULLFACE_NONE) {
	      var wt2 = drawCall.node.worldTransform;
	      wt2.getX(worldMatX);
	      wt2.getY(worldMatY);
	      wt2.getZ(worldMatZ);
	      worldMatX.cross(worldMatX, worldMatY);

	      if (worldMatX.dot(worldMatZ) < 0) {
	        this.twoSidedLightingNegScaleFactorId.setValue(-1.0);
	      } else {
	        this.twoSidedLightingNegScaleFactorId.setValue(1.0);
	      }
	    }
	  };

	  _proto.setVertexBuffers = function setVertexBuffers(device, mesh) {
	    device.setVertexBuffer(mesh.vertexBuffer);
	  };

	  _proto.setMorphing = function setMorphing(device, morphInstance) {
	    if (morphInstance) {
	      if (morphInstance.morph.useTextureMorph) {
	        device.setVertexBuffer(morphInstance.morph.vertexBufferIds);
	        this.morphPositionTex.setValue(morphInstance.texturePositions);
	        this.morphNormalTex.setValue(morphInstance.textureNormals);
	        this.morphTexParams.setValue(morphInstance._textureParams);
	      } else {
	        for (var t = 0; t < morphInstance._activeVertexBuffers.length; t++) {
	          var vb = morphInstance._activeVertexBuffers[t];

	          if (vb) {
	            var semantic = SEMANTIC_ATTR + (t + 8);
	            vb.format.elements[0].name = semantic;
	            vb.format.elements[0].scopeId = device.scope.resolve(semantic);
	            vb.format.update();
	            device.setVertexBuffer(vb);
	          }
	        }

	        this.morphWeightsA.setValue(morphInstance._shaderMorphWeightsA);
	        this.morphWeightsB.setValue(morphInstance._shaderMorphWeightsB);
	      }
	    }
	  };

	  _proto.dispatchViewPos = function dispatchViewPos(position) {
	    var vp = this.viewPos;
	    vp[0] = position.x;
	    vp[1] = position.y;
	    vp[2] = position.z;
	    this.viewPosId.setValue(vp);
	  };

	  _proto.renderForwardPrepareMaterials = function renderForwardPrepareMaterials(camera, drawCalls, drawCallsCount, sortedLights, cullingMask, layer, pass) {
	    var addCall = function addCall(drawCall, isNewMaterial, lightMaskChanged) {
	      _drawCallList.drawCalls.push(drawCall);

	      _drawCallList.isNewMaterial.push(isNewMaterial);

	      _drawCallList.lightMaskChanged.push(lightMaskChanged);
	    };

	    _drawCallList.drawCalls.length = 0;
	    _drawCallList.isNewMaterial.length = 0;
	    _drawCallList.lightMaskChanged.length = 0;
	    var device = this.device;
	    var scene = this.scene;
	    var lightHash = layer ? layer._lightHash : 0;
	    var prevMaterial = null,
	        prevObjDefs,
	        prevStatic,
	        prevLightMask;

	    for (var i = 0; i < drawCallsCount; i++) {
	      var drawCall = drawCalls[i];
	      if (cullingMask && drawCall.mask && !(cullingMask & drawCall.mask)) continue;

	      if (drawCall.command) {
	        addCall(drawCall, false, false);
	      } else {
	        drawCall.ensureMaterial(device);
	        var material = drawCall.material;
	        var objDefs = drawCall._shaderDefs;
	        var lightMask = drawCall.mask;

	        if (material && material === prevMaterial && objDefs !== prevObjDefs) {
	          prevMaterial = null;
	        }

	        if (drawCall.isStatic || prevStatic) {
	          prevMaterial = null;
	        }

	        if (material !== prevMaterial) {
	          this._materialSwitches++;
	          material._scene = scene;

	          if (material.dirty) {
	            material.updateUniforms(device, scene);
	            material.dirty = false;
	          }

	          if (material._dirtyBlend) {
	            scene.layers._dirtyBlend = true;
	          }

	          if (!drawCall._shader[pass] || drawCall._shaderDefs !== objDefs || drawCall._lightHash !== lightHash) {
	            if (!drawCall.isStatic) {
	              var variantKey = pass + '_' + objDefs + '_' + lightHash;
	              drawCall._shader[pass] = material.variants[variantKey];

	              if (!drawCall._shader[pass]) {
	                drawCall.updatePassShader(scene, pass, null, sortedLights, this.viewUniformFormat, this.viewBindGroupFormat);
	                material.variants[variantKey] = drawCall._shader[pass];
	              }
	            } else {
	              drawCall.updatePassShader(scene, pass, drawCall._staticLightList, sortedLights, this.viewUniformFormat, this.viewBindGroupFormat);
	            }

	            drawCall._lightHash = lightHash;
	          }
	        }

	        addCall(drawCall, material !== prevMaterial, !prevMaterial || lightMask !== prevLightMask);
	        prevMaterial = material;
	        prevObjDefs = objDefs;
	        prevLightMask = lightMask;
	        prevStatic = drawCall.isStatic;
	      }
	    }

	    return _drawCallList;
	  };

	  _proto.renderForwardInternal = function renderForwardInternal(camera, preparedCalls, sortedLights, pass, drawCallback, flipFaces) {
	    var device = this.device;
	    var supportsUniformBuffers = device.supportsUniformBuffers;
	    var scene = this.scene;
	    var passFlag = 1 << pass;
	    var preparedCallsCount = preparedCalls.drawCalls.length;

	    for (var i = 0; i < preparedCallsCount; i++) {
	      var drawCall = preparedCalls.drawCalls[i];

	      if (drawCall.command) {
	        drawCall.command();
	      } else {
	        var newMaterial = preparedCalls.isNewMaterial[i];
	        var lightMaskChanged = preparedCalls.lightMaskChanged[i];
	        var material = drawCall.material;
	        drawCall._shaderDefs;
	        var lightMask = drawCall.mask;

	        if (newMaterial) {
	          var shader = drawCall._shader[pass];

	          if (!shader.failed && !device.setShader(shader)) ;

	          material.setParameters(device);

	          if (lightMaskChanged) {
	            var usedDirLights = this.dispatchDirectLights(sortedLights[LIGHTTYPE_DIRECTIONAL], scene, lightMask, camera);
	            this.dispatchLocalLights(sortedLights, scene, lightMask, usedDirLights, drawCall._staticLightList);
	          }

	          this.alphaTestId.setValue(material.alphaTest);
	          device.setBlending(material.blend);

	          if (material.blend) {
	            if (material.separateAlphaBlend) {
	              device.setBlendFunctionSeparate(material.blendSrc, material.blendDst, material.blendSrcAlpha, material.blendDstAlpha);
	              device.setBlendEquationSeparate(material.blendEquation, material.blendAlphaEquation);
	            } else {
	              device.setBlendFunction(material.blendSrc, material.blendDst);
	              device.setBlendEquation(material.blendEquation);
	            }
	          }

	          device.setColorWrite(material.redWrite, material.greenWrite, material.blueWrite, material.alphaWrite);
	          device.setDepthWrite(material.depthWrite);

	          if (material.depthWrite && !material.depthTest) {
	            device.setDepthFunc(FUNC_ALWAYS);
	            device.setDepthTest(true);
	          } else {
	            device.setDepthFunc(material.depthFunc);
	            device.setDepthTest(material.depthTest);
	          }

	          device.setAlphaToCoverage(material.alphaToCoverage);

	          if (material.depthBias || material.slopeDepthBias) {
	            device.setDepthBias(true);
	            device.setDepthBiasValues(material.depthBias, material.slopeDepthBias);
	          } else {
	            device.setDepthBias(false);
	          }
	        }

	        this.setCullMode(camera._cullFaces, flipFaces, drawCall);
	        var stencilFront = drawCall.stencilFront || material.stencilFront;
	        var stencilBack = drawCall.stencilBack || material.stencilBack;

	        if (stencilFront || stencilBack) {
	          device.setStencilTest(true);

	          if (stencilFront === stencilBack) {
	            device.setStencilFunc(stencilFront.func, stencilFront.ref, stencilFront.readMask);
	            device.setStencilOperation(stencilFront.fail, stencilFront.zfail, stencilFront.zpass, stencilFront.writeMask);
	          } else {
	            if (stencilFront) {
	              device.setStencilFuncFront(stencilFront.func, stencilFront.ref, stencilFront.readMask);
	              device.setStencilOperationFront(stencilFront.fail, stencilFront.zfail, stencilFront.zpass, stencilFront.writeMask);
	            } else {
	              device.setStencilFuncFront(FUNC_ALWAYS, 0, 0xFF);
	              device.setStencilOperationFront(STENCILOP_KEEP, STENCILOP_KEEP, STENCILOP_KEEP, 0xFF);
	            }

	            if (stencilBack) {
	              device.setStencilFuncBack(stencilBack.func, stencilBack.ref, stencilBack.readMask);
	              device.setStencilOperationBack(stencilBack.fail, stencilBack.zfail, stencilBack.zpass, stencilBack.writeMask);
	            } else {
	              device.setStencilFuncBack(FUNC_ALWAYS, 0, 0xFF);
	              device.setStencilOperationBack(STENCILOP_KEEP, STENCILOP_KEEP, STENCILOP_KEEP, 0xFF);
	            }
	          }
	        } else {
	          device.setStencilTest(false);
	        }

	        var mesh = drawCall.mesh;
	        drawCall.setParameters(device, passFlag);
	        this.setVertexBuffers(device, mesh);
	        this.setMorphing(device, drawCall.morphInstance);
	        this.setSkinning(device, drawCall, material);

	        if (supportsUniformBuffers) {
	          this.modelMatrixId.setValue(drawCall.node.worldTransform.data);
	          var meshBindGroup = drawCall.getBindGroup(device, pass);
	          meshBindGroup.defaultUniformBuffer.update();
	          meshBindGroup.update();
	          device.setBindGroup(BINDGROUP_MESH, meshBindGroup);
	        }

	        var style = drawCall.renderStyle;
	        device.setIndexBuffer(mesh.indexBuffer[style]);

	        if (drawCallback) {
	          drawCallback(drawCall, i);
	        }

	        if (camera.xr && camera.xr.session && camera.xr.views.length) {
	          var views = camera.xr.views;

	          for (var v = 0; v < views.length; v++) {
	            var view = views[v];
	            device.setViewport(view.viewport.x, view.viewport.y, view.viewport.z, view.viewport.w);
	            this.projId.setValue(view.projMat.data);
	            this.projSkyboxId.setValue(view.projMat.data);
	            this.viewId.setValue(view.viewOffMat.data);
	            this.viewInvId.setValue(view.viewInvOffMat.data);
	            this.viewId3.setValue(view.viewMat3.data);
	            this.viewProjId.setValue(view.projViewOffMat.data);
	            this.viewPosId.setValue(view.position);

	            if (v === 0) {
	              this.drawInstance(device, drawCall, mesh, style, true);
	            } else {
	              this.drawInstance2(device, drawCall, mesh, style);
	            }

	            this._forwardDrawCalls++;
	          }
	        } else {
	          this.drawInstance(device, drawCall, mesh, style, true);
	          this._forwardDrawCalls++;
	        }

	        if (i < preparedCallsCount - 1 && !preparedCalls.isNewMaterial[i + 1]) {
	          material.setParameters(device, drawCall.parameters);
	        }
	      }
	    }
	  };

	  _proto.renderForward = function renderForward(camera, allDrawCalls, allDrawCallsCount, sortedLights, pass, cullingMask, drawCallback, layer, flipFaces) {
	    var preparedCalls = this.renderForwardPrepareMaterials(camera, allDrawCalls, allDrawCallsCount, sortedLights, cullingMask, layer, pass);
	    this.renderForwardInternal(camera, preparedCalls, sortedLights, pass, drawCallback, flipFaces);
	    _drawCallList.length = 0;
	  };

	  _proto.updateShaders = function updateShaders(drawCalls, onlyLitShaders) {
	    var count = drawCalls.length;

	    for (var i = 0; i < count; i++) {
	      var mat = drawCalls[i].material;

	      if (mat) {
	        if (!_tempMaterialSet.has(mat)) {
	          _tempMaterialSet.add(mat);

	          if (mat.getShaderVariant !== Material.prototype.getShaderVariant) {
	            if (onlyLitShaders) {
	              if (!mat.useLighting || mat.emitter && !mat.emitter.lighting) continue;
	            }

	            mat.clearVariants();
	          }
	        }
	      }
	    }

	    _tempMaterialSet.clear();
	  };

	  _proto.beginFrame = function beginFrame(comp, lightsChanged) {
	    var meshInstances = comp._meshInstances;
	    var scene = this.scene;

	    if (scene.updateShaders || lightsChanged) {
	      var onlyLitShaders = !scene.updateShaders && lightsChanged;
	      this.updateShaders(meshInstances, onlyLitShaders);
	      scene.updateShaders = false;
	      scene._shaderVersion++;
	    }

	    this.updateCpuSkinMatrices(meshInstances);
	    var miCount = meshInstances.length;

	    for (var i = 0; i < miCount; i++) {
	      meshInstances[i].visibleThisFrame = false;
	    }

	    var lights = comp._lights;
	    var lightCount = lights.length;

	    for (var _i3 = 0; _i3 < lightCount; _i3++) {
	      lights[_i3].beginFrame();
	    }
	  };

	  _proto.updateLayerComposition = function updateLayerComposition(comp, clusteredLightingEnabled) {
	    var len = comp.layerList.length;

	    for (var i = 0; i < len; i++) {
	      comp.layerList[i]._postRenderCounter = 0;
	    }

	    var scene = this.scene;
	    var shaderVersion = scene._shaderVersion;

	    for (var _i4 = 0; _i4 < len; _i4++) {
	      var layer = comp.layerList[_i4];
	      layer._shaderVersion = shaderVersion;
	      layer._preRenderCalledForCameras = 0;
	      layer._postRenderCalledForCameras = 0;
	      var transparent = comp.subLayerList[_i4];

	      if (transparent) {
	        layer._postRenderCounter |= 2;
	      } else {
	        layer._postRenderCounter |= 1;
	      }

	      layer._postRenderCounterMax = layer._postRenderCounter;

	      for (var j = 0; j < layer.cameras.length; j++) {
	        layer.instances.prepare(j);
	      }

	      if (layer._needsStaticPrepare && layer._staticLightHash && !this.scene.clusteredLightingEnabled) {
	        if (layer._staticPrepareDone) {
	          StaticMeshes.revert(layer.opaqueMeshInstances);
	          StaticMeshes.revert(layer.transparentMeshInstances);
	        }

	        StaticMeshes.prepare(this.device, scene, layer.opaqueMeshInstances, layer._lights);
	        StaticMeshes.prepare(this.device, scene, layer.transparentMeshInstances, layer._lights);
	        comp._dirty = true;
	        scene.updateShaders = true;
	        layer._needsStaticPrepare = false;
	        layer._staticPrepareDone = true;
	      }
	    }

	    var updated = comp._update(this.device, clusteredLightingEnabled);

	    return updated;
	  };

	  _proto.gpuUpdate = function gpuUpdate(drawCalls) {
	    this.updateGpuSkinMatrices(drawCalls);
	    this.updateMorphing(drawCalls);
	  };

	  _proto.setSceneConstants = function setSceneConstants() {
	    var scene = this.scene;
	    this.dispatchGlobalLights(scene);

	    if (scene.fog !== FOG_NONE) {
	      this.fogColor[0] = scene.fogColor.r;
	      this.fogColor[1] = scene.fogColor.g;
	      this.fogColor[2] = scene.fogColor.b;

	      if (scene.gammaCorrection) {
	        for (var i = 0; i < 3; i++) {
	          this.fogColor[i] = Math.pow(this.fogColor[i], 2.2);
	        }
	      }

	      this.fogColorId.setValue(this.fogColor);

	      if (scene.fog === FOG_LINEAR) {
	        this.fogStartId.setValue(scene.fogStart);
	        this.fogEndId.setValue(scene.fogEnd);
	      } else {
	        this.fogDensityId.setValue(scene.fogDensity);
	      }
	    }

	    var device = this.device;
	    this._screenSize[0] = device.width;
	    this._screenSize[1] = device.height;
	    this._screenSize[2] = 1 / device.width;
	    this._screenSize[3] = 1 / device.height;
	    this.screenSizeId.setValue(this._screenSize);
	  };

	  _proto.updateLightStats = function updateLightStats(comp, compUpdatedFlags) {};

	  _proto.cullShadowmaps = function cullShadowmaps(comp) {
	    for (var i = 0; i < comp._lights.length; i++) {
	      var light = comp._lights[i];

	      if (light._type !== LIGHTTYPE_DIRECTIONAL) {
	        if (light.visibleThisFrame && light.castShadows && light.shadowUpdateMode !== SHADOWUPDATE_NONE) {
	          var casters = comp._lightCompositionData[i].shadowCastersList;

	          this._shadowRenderer.cullLocal(light, casters);
	        }
	      }
	    }

	    var renderActions = comp._renderActions;

	    for (var _i5 = 0; _i5 < renderActions.length; _i5++) {
	      var renderAction = renderActions[_i5];
	      var count = renderAction.directionalLightsIndices.length;

	      for (var j = 0; j < count; j++) {
	        var lightIndex = renderAction.directionalLightsIndices[j];
	        var _light = comp._lights[lightIndex];
	        var _casters = comp._lightCompositionData[lightIndex].shadowCastersList;

	        this._shadowRenderer.cullDirectional(_light, _casters, renderAction.camera.camera);
	      }
	    }
	  };

	  _proto.cullComposition = function cullComposition(comp) {
	    var renderActions = comp._renderActions;

	    for (var i = 0; i < renderActions.length; i++) {
	      var renderAction = renderActions[i];
	      var layerIndex = renderAction.layerIndex;
	      var layer = comp.layerList[layerIndex];
	      if (!layer.enabled || !comp.subLayerEnabled[layerIndex]) continue;
	      var transparent = comp.subLayerList[layerIndex];
	      var cameraPass = renderAction.cameraIndex;
	      var camera = layer.cameras[cameraPass];

	      if (camera) {
	        camera.frameUpdate(renderAction.renderTarget);

	        if (renderAction.firstCameraUse) {
	          this.updateCameraFrustum(camera.camera);
	          this._camerasRendered++;
	        }

	        this.cullLights(camera.camera, layer._lights);
	        var objects = layer.instances;
	        var visible = transparent ? objects.visibleTransparent[cameraPass] : objects.visibleOpaque[cameraPass];

	        if (!visible.done) {
	          if (layer.onPreCull) {
	            layer.onPreCull(cameraPass);
	          }

	          var drawCalls = transparent ? layer.transparentMeshInstances : layer.opaqueMeshInstances;
	          visible.length = this.cull(camera.camera, drawCalls, visible.list);
	          visible.done = true;

	          if (layer.onPostCull) {
	            layer.onPostCull(cameraPass);
	          }
	        }
	      }
	    }

	    this.cullShadowmaps(comp);
	  };

	  _proto.updateLightTextureAtlas = function updateLightTextureAtlas(comp) {
	    this.lightTextureAtlas.update(comp._splitLights[LIGHTTYPE_SPOT], comp._splitLights[LIGHTTYPE_OMNI], this.scene.lighting);
	  };

	  _proto.updateClusters = function updateClusters(comp) {
	    for (var i = 0; i < comp._worldClusters.length; i++) {
	      var cluster = comp._worldClusters[i];
	      cluster.update(comp._lights, this.scene.gammaCorrection, this.scene.lighting);
	    }
	  };

	  _proto.buildFrameGraph = function buildFrameGraph(frameGraph, layerComposition) {
	    var _this = this;

	    frameGraph.reset();
	    this.update(layerComposition);
	    var clusteredLightingEnabled = this.scene.clusteredLightingEnabled;

	    if (clusteredLightingEnabled) {
	      this.updateLightTextureAtlas(layerComposition);

	      var _renderPass = new RenderPass(this.device, function () {
	        if (_this.scene.lighting.cookiesEnabled) {
	          _this.renderCookies(layerComposition._splitLights[LIGHTTYPE_SPOT]);

	          _this.renderCookies(layerComposition._splitLights[LIGHTTYPE_OMNI]);
	        }
	      });

	      _renderPass.requiresCubemaps = false;
	      frameGraph.addRenderPass(_renderPass);
	    }

	    var renderPass = new RenderPass(this.device, function () {
	      if (!clusteredLightingEnabled || clusteredLightingEnabled && _this.scene.lighting.shadowsEnabled) {
	        _this.renderShadows(layerComposition._splitLights[LIGHTTYPE_SPOT]);

	        _this.renderShadows(layerComposition._splitLights[LIGHTTYPE_OMNI]);
	      }

	      if (clusteredLightingEnabled) {
	        _this.updateClusters(layerComposition);
	      }
	    });
	    renderPass.requiresCubemaps = false;
	    frameGraph.addRenderPass(renderPass);
	    var startIndex = 0;
	    var newStart = true;
	    var renderTarget = null;
	    var renderActions = layerComposition._renderActions;

	    var _loop = function _loop(i) {
	      var renderAction = renderActions[i];
	      var layer = layerComposition.layerList[renderAction.layerIndex];
	      var camera = layer.cameras[renderAction.cameraIndex];

	      if (!renderAction.isLayerEnabled(layerComposition)) {
	        return "continue";
	      }

	      var isDepthLayer = layer.id === LAYERID_DEPTH;
	      var isGrabPass = isDepthLayer && (camera.renderSceneColorMap || camera.renderSceneDepthMap);

	      if (renderAction.hasDirectionalShadowLights && camera) {
	        var _renderPass2 = new RenderPass(_this.device, function () {
	          _this.renderPassDirectionalShadows(renderAction, layerComposition);
	        });

	        _renderPass2.requiresCubemaps = false;
	        frameGraph.addRenderPass(_renderPass2);
	      }

	      if (newStart) {
	        newStart = false;
	        startIndex = i;
	        renderTarget = renderAction.renderTarget;
	      }

	      var nextIndex = i + 1;

	      while (renderActions[nextIndex] && !renderActions[nextIndex].isLayerEnabled(layerComposition)) {
	        nextIndex++;
	      }

	      var nextRenderAction = renderActions[nextIndex];
	      var isNextLayerDepth = nextRenderAction ? layerComposition.layerList[nextRenderAction.layerIndex].id === LAYERID_DEPTH : false;
	      var isNextLayerGrabPass = isNextLayerDepth && (camera.renderSceneColorMap || camera.renderSceneDepthMap);

	      if (!nextRenderAction || nextRenderAction.renderTarget !== renderTarget || nextRenderAction.hasDirectionalShadowLights || isNextLayerGrabPass || isGrabPass) {
	        _this.addMainRenderPass(frameGraph, layerComposition, renderTarget, startIndex, i, isGrabPass);

	        if (renderAction.triggerPostprocess && camera != null && camera.onPostprocessing) {
	          var _renderPass3 = new RenderPass(_this.device, function () {
	            _this.renderPassPostprocessing(renderAction, layerComposition);
	          });

	          _renderPass3.requiresCubemaps = false;
	          frameGraph.addRenderPass(_renderPass3);
	        }

	        newStart = true;
	      }
	    };

	    for (var i = startIndex; i < renderActions.length; i++) {
	      var _ret = _loop(i);

	      if (_ret === "continue") continue;
	    }
	  };

	  _proto.addMainRenderPass = function addMainRenderPass(frameGraph, layerComposition, renderTarget, startIndex, endIndex, isGrabPass) {
	    var _this2 = this;

	    var range = {
	      start: startIndex,
	      end: endIndex
	    };
	    var renderPass = new RenderPass(this.device, function () {
	      _this2.renderPassRenderActions(layerComposition, range);
	    });
	    var renderActions = layerComposition._renderActions;
	    var startRenderAction = renderActions[startIndex];
	    var startLayer = layerComposition.layerList[startRenderAction.layerIndex];
	    var camera = startLayer.cameras[startRenderAction.cameraIndex];
	    var isWebgl1DepthGrabPass = isGrabPass && !this.device.webgl2 && camera.renderSceneDepthMap;
	    var isRealPass = !isGrabPass || isWebgl1DepthGrabPass;

	    if (isRealPass) {
	      renderPass.init(renderTarget);
	      renderPass.fullSizeClearRect = camera.camera.fullSizeClearRect;

	      if (isWebgl1DepthGrabPass) {
	        renderPass.setClearColor(webgl1DepthClearColor);
	        renderPass.setClearDepth(1.0);
	      } else if (renderPass.fullSizeClearRect) {
	        if (startRenderAction.clearColor) {
	          renderPass.setClearColor(camera.camera.clearColor);
	        }

	        if (startRenderAction.clearDepth) {
	          renderPass.setClearDepth(camera.camera.clearDepth);
	        }

	        if (startRenderAction.clearStencil) {
	          renderPass.setClearStencil(camera.camera.clearStencil);
	        }
	      }
	    }

	    frameGraph.addRenderPass(renderPass);
	  };

	  _proto.update = function update(comp) {
	    var clusteredLightingEnabled = this.scene.clusteredLightingEnabled;
	    this.clustersDebugRendered = false;
	    this.initViewBindGroupFormat();

	    this.scene._updateSky(this.device);

	    var updated = this.updateLayerComposition(comp, clusteredLightingEnabled);
	    var lightsChanged = (updated & COMPUPDATED_LIGHTS) !== 0;
	    this.updateLightStats(comp, updated);
	    this.beginFrame(comp, lightsChanged);
	    this.setSceneConstants();
	    this.cullComposition(comp);
	    this.gpuUpdate(comp._meshInstances);
	  };

	  _proto.renderPassDirectionalShadows = function renderPassDirectionalShadows(renderAction, layerComposition) {
	    var layer = layerComposition.layerList[renderAction.layerIndex];
	    var camera = layer.cameras[renderAction.cameraIndex];
	    this.renderShadows(renderAction.directionalLights, camera.camera);
	  };

	  _proto.renderPassPostprocessing = function renderPassPostprocessing(renderAction, layerComposition) {
	    var layer = layerComposition.layerList[renderAction.layerIndex];
	    var camera = layer.cameras[renderAction.cameraIndex];
	    camera.onPostprocessing();
	  };

	  _proto.renderPassRenderActions = function renderPassRenderActions(comp, range) {
	    var renderActions = comp._renderActions;

	    for (var i = range.start; i <= range.end; i++) {
	      this.renderRenderAction(comp, renderActions[i], i === range.start);
	    }
	  };

	  _proto.renderRenderAction = function renderRenderAction(comp, renderAction, firstRenderAction) {
	    var clusteredLightingEnabled = this.scene.clusteredLightingEnabled;
	    var device = this.device;
	    var layerIndex = renderAction.layerIndex;
	    var layer = comp.layerList[layerIndex];
	    var transparent = comp.subLayerList[layerIndex];
	    var cameraPass = renderAction.cameraIndex;
	    var camera = layer.cameras[cameraPass];

	    if (!renderAction.isLayerEnabled(comp)) {
	      return;
	    }

	    if (camera) {
	      if (renderAction.firstCameraUse && camera.onPreRender) {
	        camera.onPreRender();
	      }
	    }

	    if (!transparent && layer.onPreRenderOpaque) {
	      layer.onPreRenderOpaque(cameraPass);
	    } else if (transparent && layer.onPreRenderTransparent) {
	      layer.onPreRenderTransparent(cameraPass);
	    }

	    if (!(layer._preRenderCalledForCameras & 1 << cameraPass)) {
	      if (layer.onPreRender) {
	        layer.onPreRender(cameraPass);
	      }

	      layer._preRenderCalledForCameras |= 1 << cameraPass;
	    }

	    if (camera) {
	      var _renderAction$renderT;

	      this.setupViewport(camera.camera, renderAction.renderTarget);

	      if (!firstRenderAction || !camera.camera.fullSizeClearRect) {
	        this.clear(renderAction, camera.camera);
	      }

	      layer._sortVisible(transparent, camera.camera.node, cameraPass);

	      var objects = layer.instances;
	      var visible = transparent ? objects.visibleTransparent[cameraPass] : objects.visibleOpaque[cameraPass];
	      this.scene.immediate.onPreRenderLayer(layer, visible, transparent);
	      this.scene._activeCamera = camera.camera;
	      this.setCameraUniforms(camera.camera, renderAction.renderTarget, renderAction);

	      if (clusteredLightingEnabled && renderAction.lightClusters) {
	        renderAction.lightClusters.activate(this.lightTextureAtlas);

	        if (!this.clustersDebugRendered && this.scene.lighting.debugLayer === layer.id) {
	          this.clustersDebugRendered = true;
	        }
	      }

	      var flipFaces = !!(camera.camera._flipFaces ^ (renderAction == null ? void 0 : (_renderAction$renderT = renderAction.renderTarget) == null ? void 0 : _renderAction$renderT.flipY));
	      var draws = this._forwardDrawCalls;
	      this.renderForward(camera.camera, visible.list, visible.length, layer._splitLights, layer.shaderPass, layer.cullingMask, layer.onDrawCall, layer, flipFaces);
	      layer._forwardDrawCalls += this._forwardDrawCalls - draws;
	      device.setColorWrite(true, true, true, true);
	      device.setStencilTest(false);
	      device.setAlphaToCoverage(false);
	      device.setDepthBias(false);

	      if (renderAction.lastCameraUse && camera.onPostRender) {
	        camera.onPostRender();
	      }
	    }

	    if (!transparent && layer.onPostRenderOpaque) {
	      layer.onPostRenderOpaque(cameraPass);
	    } else if (transparent && layer.onPostRenderTransparent) {
	      layer.onPostRenderTransparent(cameraPass);
	    }

	    if (layer.onPostRender && !(layer._postRenderCalledForCameras & 1 << cameraPass)) {
	      layer._postRenderCounter &= ~(transparent ? 2 : 1);

	      if (layer._postRenderCounter === 0) {
	        layer.onPostRender(cameraPass);
	        layer._postRenderCalledForCameras |= 1 << cameraPass;
	        layer._postRenderCounter = layer._postRenderCounterMax;
	      }
	    }
	  };

	  return ForwardRenderer;
	}();

	var keyA, keyB, sortPos, sortDir;

	function sortManual(drawCallA, drawCallB) {
	  return drawCallA.drawOrder - drawCallB.drawOrder;
	}

	function sortMaterialMesh(drawCallA, drawCallB) {
	  keyA = drawCallA._key[SORTKEY_FORWARD];
	  keyB = drawCallB._key[SORTKEY_FORWARD];

	  if (keyA === keyB && drawCallA.mesh && drawCallB.mesh) {
	    return drawCallB.mesh.id - drawCallA.mesh.id;
	  }

	  return keyB - keyA;
	}

	function sortBackToFront(drawCallA, drawCallB) {
	  return drawCallB.zdist - drawCallA.zdist;
	}

	function sortFrontToBack(drawCallA, drawCallB) {
	  return drawCallA.zdist - drawCallB.zdist;
	}

	var sortCallbacks = [null, sortManual, sortMaterialMesh, sortBackToFront, sortFrontToBack];

	function sortLights(lightA, lightB) {
	  return lightB.key - lightA.key;
	}

	var layerCounter = 0;

	var VisibleInstanceList = function VisibleInstanceList() {
	  this.list = [];
	  this.length = 0;
	  this.done = false;
	};

	var InstanceList = function () {
	  function InstanceList() {
	    this.opaqueMeshInstances = [];
	    this.transparentMeshInstances = [];
	    this.shadowCasters = [];
	    this.visibleOpaque = [];
	    this.visibleTransparent = [];
	  }

	  var _proto = InstanceList.prototype;

	  _proto.prepare = function prepare(index) {
	    if (!this.visibleOpaque[index]) {
	      this.visibleOpaque[index] = new VisibleInstanceList();
	    }

	    if (!this.visibleTransparent[index]) {
	      this.visibleTransparent[index] = new VisibleInstanceList();
	    }

	    this.visibleOpaque[index].done = false;
	    this.visibleTransparent[index].done = false;
	  };

	  _proto.delete = function _delete(index) {
	    if (index < this.visibleOpaque.length) {
	      this.visibleOpaque.splice(index, 1);
	    }

	    if (index < this.visibleTransparent.length) {
	      this.visibleTransparent.splice(index, 1);
	    }
	  };

	  return InstanceList;
	}();

	var Layer = function () {
	  function Layer(options) {
	    if (options === void 0) {
	      options = {};
	    }

	    if (options.id !== undefined) {
	      this.id = options.id;
	      layerCounter = Math.max(this.id + 1, layerCounter);
	    } else {
	      this.id = layerCounter++;
	    }

	    this.name = options.name;
	    this._enabled = options.enabled === undefined ? true : options.enabled;
	    this._refCounter = this._enabled ? 1 : 0;
	    this.opaqueSortMode = options.opaqueSortMode === undefined ? SORTMODE_MATERIALMESH : options.opaqueSortMode;
	    this.transparentSortMode = options.transparentSortMode === undefined ? SORTMODE_BACK2FRONT : options.transparentSortMode;

	    if (options.renderTarget) {
	      this.renderTarget = options.renderTarget;
	    }

	    this.shaderPass = options.shaderPass === undefined ? SHADER_FORWARD : options.shaderPass;
	    this.passThrough = options.passThrough === undefined ? false : options.passThrough;
	    this._clearColorBuffer = !!options.clearColorBuffer;
	    this._clearDepthBuffer = !!options.clearDepthBuffer;
	    this._clearStencilBuffer = !!options.clearStencilBuffer;
	    this.onPreCull = options.onPreCull;
	    this.onPreRender = options.onPreRender;
	    this.onPreRenderOpaque = options.onPreRenderOpaque;
	    this.onPreRenderTransparent = options.onPreRenderTransparent;
	    this.onPostCull = options.onPostCull;
	    this.onPostRender = options.onPostRender;
	    this.onPostRenderOpaque = options.onPostRenderOpaque;
	    this.onPostRenderTransparent = options.onPostRenderTransparent;
	    this.onDrawCall = options.onDrawCall;
	    this.onEnable = options.onEnable;
	    this.onDisable = options.onDisable;

	    if (this._enabled && this.onEnable) {
	      this.onEnable();
	    }

	    this.layerReference = options.layerReference;
	    this.instances = options.layerReference ? options.layerReference.instances : new InstanceList();
	    this.cullingMask = options.cullingMask ? options.cullingMask : 0xFFFFFFFF;
	    this.opaqueMeshInstances = this.instances.opaqueMeshInstances;
	    this.transparentMeshInstances = this.instances.transparentMeshInstances;
	    this.shadowCasters = this.instances.shadowCasters;
	    this.customSortCallback = null;
	    this.customCalculateSortValues = null;
	    this._lights = [];
	    this._lightsSet = new Set();
	    this._clusteredLightsSet = new Set();
	    this._splitLights = [[], [], []];
	    this.cameras = [];
	    this._dirty = false;
	    this._dirtyLights = false;
	    this._dirtyCameras = false;
	    this._lightHash = 0;
	    this._staticLightHash = 0;
	    this._needsStaticPrepare = true;
	    this._staticPrepareDone = false;
	    this._shaderVersion = -1;
	    this._lightCube = null;
	  }

	  var _proto2 = Layer.prototype;

	  _proto2.incrementCounter = function incrementCounter() {
	    if (this._refCounter === 0) {
	      this._enabled = true;
	      if (this.onEnable) this.onEnable();
	    }

	    this._refCounter++;
	  };

	  _proto2.decrementCounter = function decrementCounter() {
	    if (this._refCounter === 1) {
	      this._enabled = false;
	      if (this.onDisable) this.onDisable();
	    } else if (this._refCounter === 0) {
	      return;
	    }

	    this._refCounter--;
	  };

	  _proto2.addMeshInstances = function addMeshInstances(meshInstances, skipShadowCasters) {
	    var sceneShaderVer = this._shaderVersion;
	    var casters = this.shadowCasters;

	    for (var i = 0; i < meshInstances.length; i++) {
	      var m = meshInstances[i];
	      var mat = m.material;
	      var arr = mat.blendType === BLEND_NONE ? this.opaqueMeshInstances : this.transparentMeshInstances;

	      if (this.opaqueMeshInstances.indexOf(m) < 0 && this.transparentMeshInstances.indexOf(m) < 0) {
	        arr.push(m);
	      }

	      if (!skipShadowCasters && m.castShadow && casters.indexOf(m) < 0) casters.push(m);

	      if (!this.passThrough && sceneShaderVer >= 0 && mat._shaderVersion !== sceneShaderVer) {
	        if (mat.getShaderVariant !== Material.prototype.getShaderVariant) {
	          mat.clearVariants();
	        }

	        mat._shaderVersion = sceneShaderVer;
	      }
	    }

	    if (!this.passThrough) this._dirty = true;
	  };

	  _proto2.removeMeshInstanceFromArray = function removeMeshInstanceFromArray(m, arr) {
	    var spliceOffset = -1;
	    var spliceCount = 0;
	    var len = arr.length;

	    for (var j = 0; j < len; j++) {
	      var drawCall = arr[j];

	      if (drawCall === m) {
	        spliceOffset = j;
	        spliceCount = 1;
	        break;
	      }

	      if (drawCall._staticSource === m) {
	        if (spliceOffset < 0) spliceOffset = j;
	        spliceCount++;
	      } else if (spliceOffset >= 0) {
	        break;
	      }
	    }

	    if (spliceOffset >= 0) {
	      arr.splice(spliceOffset, spliceCount);
	    }
	  };

	  _proto2.removeMeshInstances = function removeMeshInstances(meshInstances, skipShadowCasters) {
	    var opaque = this.opaqueMeshInstances;
	    var transparent = this.transparentMeshInstances;
	    var casters = this.shadowCasters;

	    for (var i = 0; i < meshInstances.length; i++) {
	      var m = meshInstances[i];
	      this.removeMeshInstanceFromArray(m, opaque);
	      this.removeMeshInstanceFromArray(m, transparent);

	      if (!skipShadowCasters) {
	        var j = casters.indexOf(m);
	        if (j >= 0) casters.splice(j, 1);
	      }
	    }

	    this._dirty = true;
	  };

	  _proto2.clearMeshInstances = function clearMeshInstances(skipShadowCasters) {
	    if (this.opaqueMeshInstances.length === 0 && this.transparentMeshInstances.length === 0) {
	      if (skipShadowCasters || this.shadowCasters.length === 0) return;
	    }

	    this.opaqueMeshInstances.length = 0;
	    this.transparentMeshInstances.length = 0;
	    if (!skipShadowCasters) this.shadowCasters.length = 0;
	    if (!this.passThrough) this._dirty = true;
	  };

	  _proto2.addLight = function addLight(light) {
	    var l = light.light;

	    if (!this._lightsSet.has(l)) {
	      this._lightsSet.add(l);

	      if (l.type !== LIGHTTYPE_DIRECTIONAL) {
	        this._clusteredLightsSet.add(l);
	      }

	      this._lights.push(l);

	      this._dirtyLights = true;

	      this._generateLightHash();
	    }
	  };

	  _proto2.removeLight = function removeLight(light) {
	    var l = light.light;

	    if (this._lightsSet.has(l)) {
	      this._lightsSet.delete(l);

	      if (l.type !== LIGHTTYPE_DIRECTIONAL) {
	        this._clusteredLightsSet.delete(l);
	      }

	      this._lights.splice(this._lights.indexOf(l), 1);

	      this._dirtyLights = true;

	      this._generateLightHash();
	    }
	  };

	  _proto2.clearLights = function clearLights() {
	    this._lightsSet.clear();

	    this._clusteredLightsSet.clear();

	    this._lights.length = 0;
	    this._dirtyLights = true;
	  };

	  _proto2.addShadowCasters = function addShadowCasters(meshInstances) {
	    var arr = this.shadowCasters;

	    for (var i = 0; i < meshInstances.length; i++) {
	      var m = meshInstances[i];
	      if (!m.castShadow) continue;
	      if (arr.indexOf(m) < 0) arr.push(m);
	    }

	    this._dirtyLights = true;
	  };

	  _proto2.removeShadowCasters = function removeShadowCasters(meshInstances) {
	    var arr = this.shadowCasters;

	    for (var i = 0; i < meshInstances.length; i++) {
	      var id = arr.indexOf(meshInstances[i]);
	      if (id >= 0) arr.splice(id, 1);
	    }

	    this._dirtyLights = true;
	  };

	  _proto2._generateLightHash = function _generateLightHash() {
	    if (this._lights.length > 0) {
	      this._lights.sort(sortLights);

	      var str = '';
	      var strStatic = '';

	      for (var i = 0; i < this._lights.length; i++) {
	        if (this._lights[i].isStatic) {
	          strStatic += this._lights[i].key;
	        } else {
	          str += this._lights[i].key;
	        }
	      }

	      if (str.length === 0) {
	        this._lightHash = 0;
	      } else {
	        this._lightHash = hashCode(str);
	      }

	      if (strStatic.length === 0) {
	        this._staticLightHash = 0;
	      } else {
	        this._staticLightHash = hashCode(strStatic);
	      }
	    } else {
	      this._lightHash = 0;
	      this._staticLightHash = 0;
	    }
	  };

	  _proto2.addCamera = function addCamera(camera) {
	    if (this.cameras.indexOf(camera) >= 0) return;
	    this.cameras.push(camera);
	    this._dirtyCameras = true;
	  };

	  _proto2.removeCamera = function removeCamera(camera) {
	    var index = this.cameras.indexOf(camera);

	    if (index >= 0) {
	      this.cameras.splice(index, 1);
	      this._dirtyCameras = true;
	      this.instances.delete(index);
	    }
	  };

	  _proto2.clearCameras = function clearCameras() {
	    this.cameras.length = 0;
	    this._dirtyCameras = true;
	  };

	  _proto2._calculateSortDistances = function _calculateSortDistances(drawCalls, drawCallsCount, camPos, camFwd) {
	    for (var i = 0; i < drawCallsCount; i++) {
	      var drawCall = drawCalls[i];
	      if (drawCall.command) continue;
	      if (drawCall.layer <= LAYER_FX) continue;

	      if (drawCall.calculateSortDistance) {
	        drawCall.zdist = drawCall.calculateSortDistance(drawCall, camPos, camFwd);
	        continue;
	      }

	      var meshPos = drawCall.aabb.center;
	      var tempx = meshPos.x - camPos.x;
	      var tempy = meshPos.y - camPos.y;
	      var tempz = meshPos.z - camPos.z;
	      drawCall.zdist = tempx * camFwd.x + tempy * camFwd.y + tempz * camFwd.z;
	    }
	  };

	  _proto2._sortVisible = function _sortVisible(transparent, cameraNode, cameraPass) {
	    var objects = this.instances;
	    var sortMode = transparent ? this.transparentSortMode : this.opaqueSortMode;
	    if (sortMode === SORTMODE_NONE) return;
	    var visible = transparent ? objects.visibleTransparent[cameraPass] : objects.visibleOpaque[cameraPass];

	    if (sortMode === SORTMODE_CUSTOM) {
	      sortPos = cameraNode.getPosition();
	      sortDir = cameraNode.forward;

	      if (this.customCalculateSortValues) {
	        this.customCalculateSortValues(visible.list, visible.length, sortPos, sortDir);
	      }

	      if (visible.list.length !== visible.length) {
	        visible.list.length = visible.length;
	      }

	      if (this.customSortCallback) {
	        visible.list.sort(this.customSortCallback);
	      }
	    } else {
	      if (sortMode === SORTMODE_BACK2FRONT || sortMode === SORTMODE_FRONT2BACK) {
	        sortPos = cameraNode.getPosition();
	        sortDir = cameraNode.forward;

	        this._calculateSortDistances(visible.list, visible.length, sortPos, sortDir);
	      }

	      if (visible.list.length !== visible.length) {
	        visible.list.length = visible.length;
	      }

	      visible.list.sort(sortCallbacks[sortMode]);
	    }
	  };

	  _createClass(Layer, [{
	    key: "hasClusteredLights",
	    get: function get() {
	      return this._clusteredLightsSet.size > 0;
	    }
	  }, {
	    key: "renderTarget",
	    get: function get() {
	      return this._renderTarget;
	    },
	    set: function set(rt) {
	      this._renderTarget = rt;
	      this._dirtyCameras = true;
	    }
	  }, {
	    key: "enabled",
	    get: function get() {
	      return this._enabled;
	    },
	    set: function set(val) {
	      if (val !== this._enabled) {
	        this._enabled = val;

	        if (val) {
	          this.incrementCounter();
	          if (this.onEnable) this.onEnable();
	        } else {
	          this.decrementCounter();
	          if (this.onDisable) this.onDisable();
	        }
	      }
	    }
	  }, {
	    key: "clearColorBuffer",
	    get: function get() {
	      return this._clearColorBuffer;
	    },
	    set: function set(val) {
	      this._clearColorBuffer = val;
	      this._dirtyCameras = true;
	    }
	  }, {
	    key: "clearDepthBuffer",
	    get: function get() {
	      return this._clearDepthBuffer;
	    },
	    set: function set(val) {
	      this._clearDepthBuffer = val;
	      this._dirtyCameras = true;
	    }
	  }, {
	    key: "clearStencilBuffer",
	    get: function get() {
	      return this._clearStencilBuffer;
	    },
	    set: function set(val) {
	      this._clearStencilBuffer = val;
	      this._dirtyCameras = true;
	    }
	  }, {
	    key: "clusteredLightsSet",
	    get: function get() {
	      return this._clusteredLightsSet;
	    }
	  }]);

	  return Layer;
	}();

	var set = {
	  equals: function equals(set1, set2) {
	    if (set1.size !== set2.size) {
	      return false;
	    }

	    for (var _iterator = _createForOfIteratorHelperLoose(set1), _step; !(_step = _iterator()).done;) {
	      var item = _step.value;

	      if (!set2.has(item)) {
	        return false;
	      }
	    }

	    return true;
	  }
	};

	var cmpPriority = function cmpPriority(a, b) {
	  return a.priority - b.priority;
	};

	var sortPriority = function sortPriority(arr) {
	  return arr.sort(cmpPriority);
	};

	var RenderAction = function () {
	  function RenderAction() {
	    this.layerIndex = 0;
	    this.cameraIndex = 0;
	    this.camera = null;
	    this.renderTarget = null;
	    this.lightClusters = null;
	    this.clearColor = false;
	    this.clearDepth = false;
	    this.clearStencil = false;
	    this.triggerPostprocess = false;
	    this.firstCameraUse = false;
	    this.lastCameraUse = false;
	    this.directionalLightsSet = new Set();
	    this.directionalLights = [];
	    this.directionalLightsIndices = [];
	    this.viewBindGroups = [];
	  }

	  var _proto = RenderAction.prototype;

	  _proto.destroy = function destroy() {
	    this.viewBindGroups.forEach(function (bg) {
	      bg.defaultUniformBuffer.destroy();
	      bg.destroy();
	    });
	    this.viewBindGroups.length = 0;
	  };

	  _proto.reset = function reset() {
	    this.lightClusters = null;
	    this.directionalLightsSet.clear();
	    this.directionalLights.length = 0;
	    this.directionalLightsIndices.length = 0;
	  };

	  _proto.isLayerEnabled = function isLayerEnabled(layerComposition) {
	    var layer = layerComposition.layerList[this.layerIndex];
	    return layer.enabled && layerComposition.subLayerEnabled[this.layerIndex];
	  };

	  _proto.collectDirectionalLights = function collectDirectionalLights(cameraLayers, dirLights, allLights) {
	    this.directionalLightsSet.clear();
	    this.directionalLights.length = 0;
	    this.directionalLightsIndices.length = 0;

	    for (var i = 0; i < dirLights.length; i++) {
	      var light = dirLights[i];

	      if (light.castShadows) {
	        for (var l = 0; l < cameraLayers.length; l++) {
	          if (cameraLayers[l]._splitLights[LIGHTTYPE_DIRECTIONAL].indexOf(light) >= 0) {
	            if (!this.directionalLightsSet.has(light)) {
	              this.directionalLightsSet.add(light);
	              this.directionalLights.push(light);
	              var lightIndex = allLights.indexOf(light);
	              this.directionalLightsIndices.push(lightIndex);
	            }
	          }
	        }
	      }
	    }
	  };

	  _createClass(RenderAction, [{
	    key: "hasDirectionalShadowLights",
	    get: function get() {
	      return this.directionalLights.length > 0;
	    }
	  }]);

	  return RenderAction;
	}();

	var LightCompositionData = function () {
	  function LightCompositionData() {
	    this.shadowCastersSet = new Set();
	    this.shadowCastersList = [];
	  }

	  var _proto = LightCompositionData.prototype;

	  _proto.clearShadowCasters = function clearShadowCasters() {
	    this.shadowCastersSet.clear();
	    this.shadowCastersList.length = 0;
	  };

	  _proto.addShadowCasters = function addShadowCasters(casters) {
	    for (var i = 0; i < casters.length; i++) {
	      var item = casters[i];

	      if (!this.shadowCastersSet.has(item)) {
	        this.shadowCastersSet.add(item);
	        this.shadowCastersList.push(item);
	      }
	    }
	  };

	  return LightCompositionData;
	}();

	var tempSet$1 = new Set();
	var tempClusterArray = [];

	var LayerComposition = function (_EventHandler) {
	  _inheritsLoose(LayerComposition, _EventHandler);

	  function LayerComposition(name) {
	    var _this;

	    if (name === void 0) {
	      name = 'Untitled';
	    }

	    _this = _EventHandler.call(this) || this;
	    _this.name = name;
	    _this.layerList = [];
	    _this.subLayerList = [];
	    _this.subLayerEnabled = [];
	    _this._opaqueOrder = {};
	    _this._transparentOrder = {};
	    _this._dirty = false;
	    _this._dirtyBlend = false;
	    _this._dirtyLights = false;
	    _this._dirtyCameras = false;
	    _this._meshInstances = [];
	    _this._meshInstancesSet = new Set();
	    _this._lights = [];
	    _this._lightsMap = new Map();
	    _this._lightCompositionData = [];
	    _this._splitLights = [[], [], []];
	    _this.cameras = [];
	    _this._renderActions = [];
	    _this._worldClusters = [];
	    _this._emptyWorldClusters = null;
	    return _this;
	  }

	  var _proto = LayerComposition.prototype;

	  _proto.destroy = function destroy() {
	    if (this._emptyWorldClusters) {
	      this._emptyWorldClusters.destroy();

	      this._emptyWorldClusters = null;
	    }

	    this._worldClusters.forEach(function (cluster) {
	      cluster.destroy();
	    });

	    this._worldClusters = null;

	    this._renderActions.forEach(function (ra) {
	      return ra.destroy();
	    });

	    this._renderActions = null;
	  };

	  _proto.getEmptyWorldClusters = function getEmptyWorldClusters(device) {
	    if (!this._emptyWorldClusters) {
	      this._emptyWorldClusters = new WorldClusters(device);
	      this._emptyWorldClusters.name = 'ClusterEmpty';

	      this._emptyWorldClusters.update([], false, null);
	    }

	    return this._emptyWorldClusters;
	  };

	  _proto._splitLightsArray = function _splitLightsArray(target) {
	    var lights = target._lights;
	    target._splitLights[LIGHTTYPE_DIRECTIONAL].length = 0;
	    target._splitLights[LIGHTTYPE_OMNI].length = 0;
	    target._splitLights[LIGHTTYPE_SPOT].length = 0;

	    for (var i = 0; i < lights.length; i++) {
	      var light = lights[i];

	      if (light.enabled) {
	        target._splitLights[light._type].push(light);
	      }
	    }
	  };

	  _proto._update = function _update(device, clusteredLightingEnabled) {
	    if (clusteredLightingEnabled === void 0) {
	      clusteredLightingEnabled = false;
	    }

	    var len = this.layerList.length;
	    var result = 0;

	    if (!this._dirty || !this._dirtyLights || !this._dirtyCameras) {
	      for (var i = 0; i < len; i++) {
	        var layer = this.layerList[i];

	        if (layer._dirty) {
	          this._dirty = true;
	        }

	        if (layer._dirtyLights) {
	          this._dirtyLights = true;
	        }

	        if (layer._dirtyCameras) {
	          this._dirtyCameras = true;
	        }
	      }
	    }

	    function addUniqueMeshInstance(destArray, destSet, srcArray) {
	      var dirtyBlend = false;
	      var srcLen = srcArray.length;

	      for (var s = 0; s < srcLen; s++) {
	        var meshInst = srcArray[s];

	        if (!destSet.has(meshInst)) {
	          destSet.add(meshInst);
	          destArray.push(meshInst);
	          var material = meshInst.material;

	          if (material && material._dirtyBlend) {
	            dirtyBlend = true;
	            material._dirtyBlend = false;
	          }
	        }
	      }

	      return dirtyBlend;
	    }

	    if (this._dirty) {
	      result |= COMPUPDATED_INSTANCES;
	      this._meshInstances.length = 0;

	      this._meshInstancesSet.clear();

	      for (var _i = 0; _i < len; _i++) {
	        var _layer = this.layerList[_i];

	        if (!_layer.passThrough) {
	          this._dirtyBlend = addUniqueMeshInstance(this._meshInstances, this._meshInstancesSet, _layer.opaqueMeshInstances) || this._dirtyBlend;
	          this._dirtyBlend = addUniqueMeshInstance(this._meshInstances, this._meshInstancesSet, _layer.transparentMeshInstances) || this._dirtyBlend;
	        }

	        _layer._dirty = false;
	      }

	      this._dirty = false;
	    }

	    function moveByBlendType(dest, src, moveTransparent) {
	      for (var s = 0; s < src.length;) {
	        var _src$s$material;

	        if (((_src$s$material = src[s].material) == null ? void 0 : _src$s$material.transparent) === moveTransparent) {
	          dest.push(src[s]);
	          src[s] = src[src.length - 1];
	          src.length--;
	        } else {
	          s++;
	        }
	      }
	    }

	    if (this._dirtyBlend) {
	      result |= COMPUPDATED_BLEND;

	      for (var _i2 = 0; _i2 < len; _i2++) {
	        var _layer2 = this.layerList[_i2];

	        if (!_layer2.passThrough) {
	          moveByBlendType(_layer2.opaqueMeshInstances, _layer2.transparentMeshInstances, false);
	          moveByBlendType(_layer2.transparentMeshInstances, _layer2.opaqueMeshInstances, true);
	        }
	      }

	      this._dirtyBlend = false;
	    }

	    if (this._dirtyLights) {
	      result |= COMPUPDATED_LIGHTS;
	      this._dirtyLights = false;
	      this.updateLights();
	    }

	    if (result) {
	      this.updateShadowCasters();
	    }

	    if (this._dirtyCameras || result & COMPUPDATED_LIGHTS) {
	      this._dirtyCameras = false;
	      result |= COMPUPDATED_CAMERAS;
	      this.cameras.length = 0;

	      for (var _i3 = 0; _i3 < len; _i3++) {
	        var _layer3 = this.layerList[_i3];
	        _layer3._dirtyCameras = false;

	        for (var j = 0; j < _layer3.cameras.length; j++) {
	          var camera = _layer3.cameras[j];
	          var index = this.cameras.indexOf(camera);

	          if (index < 0) {
	            this.cameras.push(camera);
	          }
	        }
	      }

	      if (this.cameras.length > 1) {
	        sortPriority(this.cameras);
	      }

	      var cameraLayers = [];
	      var renderActionCount = 0;

	      for (var _i4 = 0; _i4 < this.cameras.length; _i4++) {
	        var _camera = this.cameras[_i4];
	        cameraLayers.length = 0;
	        var cameraFirstRenderAction = true;
	        var cameraFirstRenderActionIndex = renderActionCount;
	        var lastRenderAction = null;
	        var postProcessMarked = false;

	        for (var _j = 0; _j < len; _j++) {
	          var _layer4 = this.layerList[_j];

	          if (_layer4) {
	            if (_layer4.cameras.length > 0) {
	              if (_camera.layers.indexOf(_layer4.id) >= 0) {
	                cameraLayers.push(_layer4);

	                if (!postProcessMarked && _layer4.id === _camera.disablePostEffectsLayer) {
	                  postProcessMarked = true;

	                  if (lastRenderAction) {
	                    lastRenderAction.triggerPostprocess = true;
	                  }
	                }

	                var cameraIndex = _layer4.cameras.indexOf(_camera);

	                if (cameraIndex >= 0) {
	                  lastRenderAction = this.addRenderAction(this._renderActions, renderActionCount, _layer4, _j, cameraIndex, cameraFirstRenderAction, postProcessMarked);
	                  renderActionCount++;
	                  cameraFirstRenderAction = false;
	                }
	              }
	            }
	          }
	        }

	        if (cameraFirstRenderActionIndex < renderActionCount) {
	          this._renderActions[cameraFirstRenderActionIndex].collectDirectionalLights(cameraLayers, this._splitLights[LIGHTTYPE_DIRECTIONAL], this._lights);

	          lastRenderAction.lastCameraUse = true;
	        }

	        if (!postProcessMarked && lastRenderAction) {
	          lastRenderAction.triggerPostprocess = true;
	        }

	        if (_camera.renderTarget && _camera.postEffectsEnabled) {
	          this.propagateRenderTarget(cameraFirstRenderActionIndex - 1, _camera);
	        }
	      }

	      for (var _i5 = renderActionCount; _i5 < this._renderActions.length; _i5++) {
	        this._renderActions[_i5].destroy();
	      }

	      this._renderActions.length = renderActionCount;
	    }

	    if (result & (COMPUPDATED_CAMERAS | COMPUPDATED_LIGHTS | COMPUPDATED_INSTANCES)) {
	      if (clusteredLightingEnabled) {
	        this.allocateLightClusters(device);
	      }
	    }

	    if (result & (COMPUPDATED_LIGHTS | COMPUPDATED_LIGHTS)) {
	      this._logRenderActions();
	    }

	    return result;
	  };

	  _proto.updateShadowCasters = function updateShadowCasters() {
	    var lightCount = this._lights.length;

	    for (var i = 0; i < lightCount; i++) {
	      this._lightCompositionData[i].clearShadowCasters();
	    }

	    var len = this.layerList.length;

	    for (var _i6 = 0; _i6 < len; _i6++) {
	      var layer = this.layerList[_i6];

	      if (!tempSet$1.has(layer)) {
	        tempSet$1.add(layer);
	        var lights = layer._lights;

	        for (var j = 0; j < lights.length; j++) {
	          if (lights[j].castShadows) {
	            var lightIndex = this._lightsMap.get(lights[j]);

	            var lightCompData = this._lightCompositionData[lightIndex];
	            lightCompData.addShadowCasters(layer.shadowCasters);
	          }
	        }
	      }
	    }

	    tempSet$1.clear();
	  };

	  _proto.updateLights = function updateLights() {
	    this._lights.length = 0;

	    this._lightsMap.clear();

	    var count = this.layerList.length;

	    for (var i = 0; i < count; i++) {
	      var layer = this.layerList[i];

	      if (!tempSet$1.has(layer)) {
	        tempSet$1.add(layer);
	        var lights = layer._lights;

	        for (var j = 0; j < lights.length; j++) {
	          var light = lights[j];

	          var lightIndex = this._lightsMap.get(light);

	          if (lightIndex === undefined) {
	            lightIndex = this._lights.length;

	            this._lightsMap.set(light, lightIndex);

	            this._lights.push(light);

	            var lightCompData = this._lightCompositionData[lightIndex];

	            if (!lightCompData) {
	              lightCompData = new LightCompositionData();
	              this._lightCompositionData[lightIndex] = lightCompData;
	            }
	          }
	        }
	      }

	      this._splitLightsArray(layer);

	      layer._dirtyLights = false;
	    }

	    tempSet$1.clear();

	    this._splitLightsArray(this);

	    var lightCount = this._lights.length;
	    this._lightCompositionData.length = lightCount;
	  };

	  _proto.findCompatibleCluster = function findCompatibleCluster(layer, renderActionCount, emptyWorldClusters) {
	    for (var i = 0; i < renderActionCount; i++) {
	      var ra = this._renderActions[i];
	      var raLayer = this.layerList[ra.layerIndex];

	      if (ra.lightClusters !== emptyWorldClusters) {
	        if (layer === raLayer) {
	          return ra.lightClusters;
	        }

	        if (ra.lightClusters) {
	          if (set.equals(layer._clusteredLightsSet, raLayer._clusteredLightsSet)) {
	            return ra.lightClusters;
	          }
	        }
	      }
	    }

	    return null;
	  };

	  _proto.allocateLightClusters = function allocateLightClusters(device) {
	    tempClusterArray.push.apply(tempClusterArray, this._worldClusters);
	    var emptyWorldClusters = this.getEmptyWorldClusters(device);
	    this._worldClusters.length = 0;
	    var count = this._renderActions.length;

	    for (var i = 0; i < count; i++) {
	      var ra = this._renderActions[i];
	      var layer = this.layerList[ra.layerIndex];

	      if (layer.hasClusteredLights) {
	        var transparent = this.subLayerList[ra.layerIndex];
	        var meshInstances = transparent ? layer.transparentMeshInstances : layer.opaqueMeshInstances;

	        if (meshInstances.length) {
	          var clusters = this.findCompatibleCluster(layer, i, emptyWorldClusters);

	          if (!clusters) {
	            if (tempClusterArray.length) {
	              clusters = tempClusterArray.pop();
	            }

	            if (!clusters) {
	              clusters = new WorldClusters(device);
	            }

	            clusters.name = 'Cluster-' + this._worldClusters.length;

	            this._worldClusters.push(clusters);
	          }

	          ra.lightClusters = clusters;
	        }
	      }

	      if (!ra.lightClusters) {
	        ra.lightClusters = emptyWorldClusters;
	      }
	    }

	    tempClusterArray.forEach(function (item) {
	      item.destroy();
	    });
	    tempClusterArray.length = 0;
	  };

	  _proto.addRenderAction = function addRenderAction(renderActions, renderActionIndex, layer, layerIndex, cameraIndex, cameraFirstRenderAction, postProcessMarked) {
	    var renderAction = renderActions[renderActionIndex];

	    if (!renderAction) {
	      renderAction = renderActions[renderActionIndex] = new RenderAction();
	    }

	    var rt = layer.renderTarget;
	    var camera = layer.cameras[cameraIndex];

	    if (camera && camera.renderTarget) {
	      if (layer.id !== LAYERID_DEPTH) {
	        rt = camera.renderTarget;
	      }
	    }

	    var used = false;

	    for (var i = renderActionIndex - 1; i >= 0; i--) {
	      if (renderActions[i].camera === camera && renderActions[i].renderTarget === rt) {
	        used = true;
	        break;
	      }
	    }

	    var needsClear = cameraFirstRenderAction || !used;
	    var clearColor = needsClear ? camera.clearColorBuffer : false;
	    var clearDepth = needsClear ? camera.clearDepthBuffer : false;
	    var clearStencil = needsClear ? camera.clearStencilBuffer : false;
	    clearColor || (clearColor = layer.clearColorBuffer);
	    clearDepth || (clearDepth = layer.clearDepthBuffer);
	    clearStencil || (clearStencil = layer.clearStencilBuffer);

	    if (postProcessMarked && camera.postEffectsEnabled) {
	      rt = null;
	    }

	    renderAction.reset();
	    renderAction.triggerPostprocess = false;
	    renderAction.layerIndex = layerIndex;
	    renderAction.cameraIndex = cameraIndex;
	    renderAction.camera = camera;
	    renderAction.renderTarget = rt;
	    renderAction.clearColor = clearColor;
	    renderAction.clearDepth = clearDepth;
	    renderAction.clearStencil = clearStencil;
	    renderAction.firstCameraUse = cameraFirstRenderAction;
	    renderAction.lastCameraUse = false;
	    return renderAction;
	  };

	  _proto.propagateRenderTarget = function propagateRenderTarget(startIndex, fromCamera) {
	    for (var a = startIndex; a >= 0; a--) {
	      var ra = this._renderActions[a];
	      var layer = this.layerList[ra.layerIndex];

	      if (ra.renderTarget && layer.id !== LAYERID_DEPTH) {
	        break;
	      }

	      if (layer.id === LAYERID_DEPTH) {
	        continue;
	      }

	      var thisCamera = ra == null ? void 0 : ra.camera.camera;

	      if (thisCamera) {
	        if (!fromCamera.camera.rect.equals(thisCamera.rect) || !fromCamera.camera.scissorRect.equals(thisCamera.scissorRect)) {
	          break;
	        }
	      }

	      ra.renderTarget = fromCamera.renderTarget;
	    }
	  };

	  _proto._logRenderActions = function _logRenderActions() {};

	  _proto._isLayerAdded = function _isLayerAdded(layer) {
	    if (this.layerList.indexOf(layer) >= 0) {
	      return true;
	    }

	    return false;
	  };

	  _proto._isSublayerAdded = function _isSublayerAdded(layer, transparent) {
	    for (var i = 0; i < this.layerList.length; i++) {
	      if (this.layerList[i] === layer && this.subLayerList[i] === transparent) {
	        return true;
	      }
	    }

	    return false;
	  };

	  _proto.push = function push(layer) {
	    if (this._isLayerAdded(layer)) return;
	    this.layerList.push(layer);
	    this.layerList.push(layer);
	    this._opaqueOrder[layer.id] = this.subLayerList.push(false) - 1;
	    this._transparentOrder[layer.id] = this.subLayerList.push(true) - 1;
	    this.subLayerEnabled.push(true);
	    this.subLayerEnabled.push(true);
	    this._dirty = true;
	    this._dirtyLights = true;
	    this._dirtyCameras = true;
	    this.fire('add', layer);
	  };

	  _proto.insert = function insert(layer, index) {
	    if (this._isLayerAdded(layer)) return;
	    this.layerList.splice(index, 0, layer, layer);
	    this.subLayerList.splice(index, 0, false, true);
	    var count = this.layerList.length;

	    this._updateOpaqueOrder(index, count - 1);

	    this._updateTransparentOrder(index, count - 1);

	    this.subLayerEnabled.splice(index, 0, true, true);
	    this._dirty = true;
	    this._dirtyLights = true;
	    this._dirtyCameras = true;
	    this.fire('add', layer);
	  };

	  _proto.remove = function remove(layer) {
	    var id = this.layerList.indexOf(layer);
	    delete this._opaqueOrder[id];
	    delete this._transparentOrder[id];

	    while (id >= 0) {
	      this.layerList.splice(id, 1);
	      this.subLayerList.splice(id, 1);
	      this.subLayerEnabled.splice(id, 1);
	      id = this.layerList.indexOf(layer);
	      this._dirty = true;
	      this._dirtyLights = true;
	      this._dirtyCameras = true;
	      this.fire('remove', layer);
	    }

	    var count = this.layerList.length;

	    this._updateOpaqueOrder(0, count - 1);

	    this._updateTransparentOrder(0, count - 1);
	  };

	  _proto.pushOpaque = function pushOpaque(layer) {
	    if (this._isSublayerAdded(layer, false)) return;
	    this.layerList.push(layer);
	    this._opaqueOrder[layer.id] = this.subLayerList.push(false) - 1;
	    this.subLayerEnabled.push(true);
	    this._dirty = true;
	    this._dirtyLights = true;
	    this._dirtyCameras = true;
	    this.fire('add', layer);
	  };

	  _proto.insertOpaque = function insertOpaque(layer, index) {
	    if (this._isSublayerAdded(layer, false)) return;
	    this.layerList.splice(index, 0, layer);
	    this.subLayerList.splice(index, 0, false);
	    var count = this.subLayerList.length;

	    this._updateOpaqueOrder(index, count - 1);

	    this.subLayerEnabled.splice(index, 0, true);
	    this._dirty = true;
	    this._dirtyLights = true;
	    this._dirtyCameras = true;
	    this.fire('add', layer);
	  };

	  _proto.removeOpaque = function removeOpaque(layer) {
	    for (var i = 0, len = this.layerList.length; i < len; i++) {
	      if (this.layerList[i] === layer && !this.subLayerList[i]) {
	        this.layerList.splice(i, 1);
	        this.subLayerList.splice(i, 1);
	        len--;

	        this._updateOpaqueOrder(i, len - 1);

	        this.subLayerEnabled.splice(i, 1);
	        this._dirty = true;
	        this._dirtyLights = true;
	        this._dirtyCameras = true;

	        if (this.layerList.indexOf(layer) < 0) {
	          this.fire('remove', layer);
	        }

	        return;
	      }
	    }
	  };

	  _proto.pushTransparent = function pushTransparent(layer) {
	    if (this._isSublayerAdded(layer, true)) return;
	    this.layerList.push(layer);
	    this._transparentOrder[layer.id] = this.subLayerList.push(true) - 1;
	    this.subLayerEnabled.push(true);
	    this._dirty = true;
	    this._dirtyLights = true;
	    this._dirtyCameras = true;
	    this.fire('add', layer);
	  };

	  _proto.insertTransparent = function insertTransparent(layer, index) {
	    if (this._isSublayerAdded(layer, true)) return;
	    this.layerList.splice(index, 0, layer);
	    this.subLayerList.splice(index, 0, true);
	    var count = this.subLayerList.length;

	    this._updateTransparentOrder(index, count - 1);

	    this.subLayerEnabled.splice(index, 0, true);
	    this._dirty = true;
	    this._dirtyLights = true;
	    this._dirtyCameras = true;
	    this.fire('add', layer);
	  };

	  _proto.removeTransparent = function removeTransparent(layer) {
	    for (var i = 0, len = this.layerList.length; i < len; i++) {
	      if (this.layerList[i] === layer && this.subLayerList[i]) {
	        this.layerList.splice(i, 1);
	        this.subLayerList.splice(i, 1);
	        len--;

	        this._updateTransparentOrder(i, len - 1);

	        this.subLayerEnabled.splice(i, 1);
	        this._dirty = true;
	        this._dirtyLights = true;
	        this._dirtyCameras = true;

	        if (this.layerList.indexOf(layer) < 0) {
	          this.fire('remove', layer);
	        }

	        return;
	      }
	    }
	  };

	  _proto._getSublayerIndex = function _getSublayerIndex(layer, transparent) {
	    var id = this.layerList.indexOf(layer);
	    if (id < 0) return -1;

	    if (this.subLayerList[id] !== transparent) {
	      id = this.layerList.indexOf(layer, id + 1);
	      if (id < 0) return -1;

	      if (this.subLayerList[id] !== transparent) {
	        return -1;
	      }
	    }

	    return id;
	  };

	  _proto.getOpaqueIndex = function getOpaqueIndex(layer) {
	    return this._getSublayerIndex(layer, false);
	  };

	  _proto.getTransparentIndex = function getTransparentIndex(layer) {
	    return this._getSublayerIndex(layer, true);
	  };

	  _proto.getLayerById = function getLayerById(id) {
	    for (var i = 0; i < this.layerList.length; i++) {
	      if (this.layerList[i].id === id) return this.layerList[i];
	    }

	    return null;
	  };

	  _proto.getLayerByName = function getLayerByName(name) {
	    for (var i = 0; i < this.layerList.length; i++) {
	      if (this.layerList[i].name === name) return this.layerList[i];
	    }

	    return null;
	  };

	  _proto._updateOpaqueOrder = function _updateOpaqueOrder(startIndex, endIndex) {
	    for (var i = startIndex; i <= endIndex; i++) {
	      if (this.subLayerList[i] === false) {
	        this._opaqueOrder[this.layerList[i].id] = i;
	      }
	    }
	  };

	  _proto._updateTransparentOrder = function _updateTransparentOrder(startIndex, endIndex) {
	    for (var i = startIndex; i <= endIndex; i++) {
	      if (this.subLayerList[i] === true) {
	        this._transparentOrder[this.layerList[i].id] = i;
	      }
	    }
	  };

	  _proto._sortLayersDescending = function _sortLayersDescending(layersA, layersB, order) {
	    var topLayerA = -1;
	    var topLayerB = -1;

	    for (var i = 0, len = layersA.length; i < len; i++) {
	      var id = layersA[i];

	      if (order.hasOwnProperty(id)) {
	        topLayerA = Math.max(topLayerA, order[id]);
	      }
	    }

	    for (var _i7 = 0, _len = layersB.length; _i7 < _len; _i7++) {
	      var _id = layersB[_i7];

	      if (order.hasOwnProperty(_id)) {
	        topLayerB = Math.max(topLayerB, order[_id]);
	      }
	    }

	    if (topLayerA === -1 && topLayerB !== -1) {
	      return 1;
	    } else if (topLayerB === -1 && topLayerA !== -1) {
	      return -1;
	    }

	    return topLayerB - topLayerA;
	  };

	  _proto.sortTransparentLayers = function sortTransparentLayers(layersA, layersB) {
	    return this._sortLayersDescending(layersA, layersB, this._transparentOrder);
	  };

	  _proto.sortOpaqueLayers = function sortOpaqueLayers(layersA, layersB) {
	    return this._sortLayersDescending(layersA, layersB, this._opaqueOrder);
	  };

	  return LayerComposition;
	}(EventHandler);

	var spotCenter = new Vec3();
	var spotEndPoint = new Vec3();
	var tmpVec = new Vec3();
	var tmpBiases = {
	  bias: 0,
	  normalBias: 0
	};
	var chanId = {
	  r: 0,
	  g: 1,
	  b: 2,
	  a: 3
	};
	var directionalCascades = [[new Vec4(0, 0, 1, 1)], [new Vec4(0, 0, 0.5, 0.5), new Vec4(0, 0.5, 0.5, 0.5)], [new Vec4(0, 0, 0.5, 0.5), new Vec4(0, 0.5, 0.5, 0.5), new Vec4(0.5, 0, 0.5, 0.5)], [new Vec4(0, 0, 0.5, 0.5), new Vec4(0, 0.5, 0.5, 0.5), new Vec4(0.5, 0, 0.5, 0.5), new Vec4(0.5, 0.5, 0.5, 0.5)]];
	var id = 0;

	var LightRenderData = function () {
	  function LightRenderData(device, camera, face, light) {
	    this.light = light;
	    this.camera = camera;
	    this.shadowCamera = ShadowRenderer.createShadowCamera(device, light._shadowType, light._type, face);
	    this.shadowMatrix = new Mat4();
	    this.shadowViewport = new Vec4(0, 0, 1, 1);
	    this.shadowScissor = new Vec4(0, 0, 1, 1);
	    this.face = face;
	    this.visibleCasters = [];
	  }

	  _createClass(LightRenderData, [{
	    key: "shadowBuffer",
	    get: function get() {
	      var rt = this.shadowCamera.renderTarget;

	      if (rt) {
	        var light = this.light;

	        if (light._type === LIGHTTYPE_OMNI) {
	          return rt.colorBuffer;
	        }

	        return light._isPcf && light.device.webgl2 ? rt.depthBuffer : rt.colorBuffer;
	      }

	      return null;
	    }
	  }]);

	  return LightRenderData;
	}();

	var Light = function () {
	  function Light(graphicsDevice) {
	    this.device = graphicsDevice;
	    this.id = id++;
	    this._type = LIGHTTYPE_DIRECTIONAL;
	    this._color = new Color(0.8, 0.8, 0.8);
	    this._intensity = 1;
	    this._castShadows = false;
	    this._enabled = false;
	    this.mask = MASK_AFFECT_DYNAMIC;
	    this.isStatic = false;
	    this.key = 0;
	    this.bakeDir = true;
	    this.bakeNumSamples = 1;
	    this.bakeArea = 0;
	    this.attenuationStart = 10;
	    this.attenuationEnd = 10;
	    this._falloffMode = LIGHTFALLOFF_LINEAR;
	    this._shadowType = SHADOW_PCF3;
	    this._vsmBlurSize = 11;
	    this.vsmBlurMode = BLUR_GAUSSIAN;
	    this.vsmBias = 0.01 * 0.25;
	    this._cookie = null;
	    this.cookieIntensity = 1;
	    this._cookieFalloff = true;
	    this._cookieChannel = 'rgb';
	    this._cookieTransform = null;
	    this._cookieTransformUniform = new Float32Array(4);
	    this._cookieOffset = null;
	    this._cookieOffsetUniform = new Float32Array(2);
	    this._cookieTransformSet = false;
	    this._cookieOffsetSet = false;
	    this._innerConeAngle = 40;
	    this._outerConeAngle = 45;
	    this.cascades = null;
	    this._shadowMatrixPalette = null;
	    this._shadowCascadeDistances = null;
	    this.numCascades = 1;
	    this.cascadeDistribution = 0.5;
	    this._shape = LIGHTSHAPE_PUNCTUAL;
	    this._finalColor = new Float32Array([0.8, 0.8, 0.8]);
	    var c = Math.pow(this._finalColor[0], 2.2);
	    this._linearFinalColor = new Float32Array([c, c, c]);
	    this._position = new Vec3(0, 0, 0);
	    this._direction = new Vec3(0, 0, 0);
	    this._innerConeAngleCos = Math.cos(this._innerConeAngle * Math.PI / 180);
	    this._outerConeAngleCos = Math.cos(this._outerConeAngle * Math.PI / 180);
	    this._shadowMap = null;
	    this._shadowRenderParams = [];
	    this.shadowDistance = 40;
	    this._shadowResolution = 1024;
	    this.shadowBias = -0.0005;
	    this.shadowIntensity = 1.0;
	    this._normalOffsetBias = 0.0;
	    this.shadowUpdateMode = SHADOWUPDATE_REALTIME;
	    this._isVsm = false;
	    this._isPcf = true;
	    this._cookieMatrix = null;
	    this._atlasViewport = null;
	    this.atlasViewportAllocated = false;
	    this.atlasVersion = 0;
	    this.atlasSlotIndex = 0;
	    this.atlasSlotUpdated = false;
	    this._scene = null;
	    this._node = null;
	    this._renderData = [];
	    this.visibleThisFrame = false;
	    this.maxScreenSize = 0;
	  }

	  var _proto = Light.prototype;

	  _proto.destroy = function destroy() {
	    this._destroyShadowMap();

	    this._renderData = null;
	  };

	  _proto.beginFrame = function beginFrame() {
	    this.visibleThisFrame = this._type === LIGHTTYPE_DIRECTIONAL && this._enabled;
	    this.maxScreenSize = 0;
	    this.atlasViewportAllocated = false;
	    this.atlasSlotUpdated = false;
	  };

	  _proto._destroyShadowMap = function _destroyShadowMap() {
	    if (this._renderData) {
	      this._renderData.length = 0;
	    }

	    if (this._shadowMap) {
	      if (!this._shadowMap.cached) {
	        this._shadowMap.destroy();
	      }

	      this._shadowMap = null;
	    }

	    if (this.shadowUpdateMode === SHADOWUPDATE_NONE) {
	      this.shadowUpdateMode = SHADOWUPDATE_THISFRAME;
	    }
	  };

	  _proto.getRenderData = function getRenderData(camera, face) {
	    for (var i = 0; i < this._renderData.length; i++) {
	      var current = this._renderData[i];

	      if (current.camera === camera && current.face === face) {
	        return current;
	      }
	    }

	    var rd = new LightRenderData(this.device, camera, face, this);

	    this._renderData.push(rd);

	    return rd;
	  };

	  _proto.clone = function clone() {
	    var clone = new Light(this.device);
	    clone.type = this._type;
	    clone.setColor(this._color);
	    clone.intensity = this._intensity;
	    clone.castShadows = this.castShadows;
	    clone._enabled = this._enabled;
	    clone.attenuationStart = this.attenuationStart;
	    clone.attenuationEnd = this.attenuationEnd;
	    clone.falloffMode = this._falloffMode;
	    clone.shadowType = this._shadowType;
	    clone.vsmBlurSize = this._vsmBlurSize;
	    clone.vsmBlurMode = this.vsmBlurMode;
	    clone.vsmBias = this.vsmBias;
	    clone.shadowUpdateMode = this.shadowUpdateMode;
	    clone.mask = this.mask;
	    clone.innerConeAngle = this._innerConeAngle;
	    clone.outerConeAngle = this._outerConeAngle;
	    clone.numCascades = this.numCascades;
	    clone.cascadeDistribution = this.cascadeDistribution;
	    clone.shape = this._shape;
	    clone.shadowBias = this.shadowBias;
	    clone.normalOffsetBias = this._normalOffsetBias;
	    clone.shadowResolution = this._shadowResolution;
	    clone.shadowDistance = this.shadowDistance;
	    clone.shadowIntensity = this.shadowIntensity;
	    return clone;
	  };

	  _proto._getUniformBiasValues = function _getUniformBiasValues(lightRenderData) {
	    var farClip = lightRenderData.shadowCamera._farClip;

	    switch (this._type) {
	      case LIGHTTYPE_OMNI:
	        tmpBiases.bias = this.shadowBias;
	        tmpBiases.normalBias = this._normalOffsetBias;
	        break;

	      case LIGHTTYPE_SPOT:
	        if (this._isVsm) {
	          tmpBiases.bias = -0.00001 * 20;
	        } else {
	          tmpBiases.bias = this.shadowBias * 20;
	          if (!this.device.webgl2 && this.device.extStandardDerivatives) tmpBiases.bias *= -100;
	        }

	        tmpBiases.normalBias = this._isVsm ? this.vsmBias / (this.attenuationEnd / 7.0) : this._normalOffsetBias;
	        break;

	      case LIGHTTYPE_DIRECTIONAL:
	        if (this._isVsm) {
	          tmpBiases.bias = -0.00001 * 20;
	        } else {
	          tmpBiases.bias = this.shadowBias / farClip * 100;
	          if (!this.device.webgl2 && this.device.extStandardDerivatives) tmpBiases.bias *= -100;
	        }

	        tmpBiases.normalBias = this._isVsm ? this.vsmBias / (farClip / 7.0) : this._normalOffsetBias;
	        break;
	    }

	    return tmpBiases;
	  };

	  _proto.getColor = function getColor() {
	    return this._color;
	  };

	  _proto.getBoundingSphere = function getBoundingSphere(sphere) {
	    if (this._type === LIGHTTYPE_SPOT) {
	      var range = this.attenuationEnd;
	      var angle = this._outerConeAngle;
	      var f = Math.cos(angle * math.DEG_TO_RAD);
	      var node = this._node;
	      spotCenter.copy(node.up);
	      spotCenter.mulScalar(-range * 0.5 * f);
	      spotCenter.add(node.getPosition());
	      sphere.center = spotCenter;
	      spotEndPoint.copy(node.up);
	      spotEndPoint.mulScalar(-range);
	      tmpVec.copy(node.right);
	      tmpVec.mulScalar(Math.sin(angle * math.DEG_TO_RAD) * range);
	      spotEndPoint.add(tmpVec);
	      sphere.radius = spotEndPoint.length() * 0.5;
	    } else if (this._type === LIGHTTYPE_OMNI) {
	      sphere.center = this._node.getPosition();
	      sphere.radius = this.attenuationEnd;
	    }
	  };

	  _proto.getBoundingBox = function getBoundingBox(box) {
	    if (this._type === LIGHTTYPE_SPOT) {
	      var range = this.attenuationEnd;
	      var angle = this._outerConeAngle;
	      var node = this._node;
	      var scl = Math.abs(Math.sin(angle * math.DEG_TO_RAD) * range);
	      box.center.set(0, -range * 0.5, 0);
	      box.halfExtents.set(scl, range * 0.5, scl);
	      box.setFromTransformedAabb(box, node.getWorldTransform(), true);
	    } else if (this._type === LIGHTTYPE_OMNI) {
	      box.center.copy(this._node.getPosition());
	      box.halfExtents.set(this.attenuationEnd, this.attenuationEnd, this.attenuationEnd);
	    }
	  };

	  _proto._updateFinalColor = function _updateFinalColor() {
	    var color = this._color;
	    var r = color.r;
	    var g = color.g;
	    var b = color.b;
	    var i = this._intensity;
	    var finalColor = this._finalColor;
	    var linearFinalColor = this._linearFinalColor;
	    finalColor[0] = r * i;
	    finalColor[1] = g * i;
	    finalColor[2] = b * i;

	    if (i >= 1) {
	      linearFinalColor[0] = Math.pow(r, 2.2) * i;
	      linearFinalColor[1] = Math.pow(g, 2.2) * i;
	      linearFinalColor[2] = Math.pow(b, 2.2) * i;
	    } else {
	      linearFinalColor[0] = Math.pow(finalColor[0], 2.2);
	      linearFinalColor[1] = Math.pow(finalColor[1], 2.2);
	      linearFinalColor[2] = Math.pow(finalColor[2], 2.2);
	    }
	  };

	  _proto.setColor = function setColor() {
	    if (arguments.length === 1) {
	      this._color.set(arguments[0].r, arguments[0].g, arguments[0].b);
	    } else if (arguments.length === 3) {
	      this._color.set(arguments[0], arguments[1], arguments[2]);
	    }

	    this._updateFinalColor();
	  };

	  _proto.updateShadow = function updateShadow() {
	    if (this.shadowUpdateMode !== SHADOWUPDATE_REALTIME) {
	      this.shadowUpdateMode = SHADOWUPDATE_THISFRAME;
	    }
	  };

	  _proto.layersDirty = function layersDirty() {
	    var _this$_scene;

	    if ((_this$_scene = this._scene) != null && _this$_scene.layers) {
	      this._scene.layers._dirtyLights = true;
	    }
	  };

	  _proto.updateKey = function updateKey() {
	    var key = this._type << 29 | (this._castShadows ? 1 : 0) << 28 | this._shadowType << 25 | this._falloffMode << 23 | (this._normalOffsetBias !== 0.0 ? 1 : 0) << 22 | (this._cookie ? 1 : 0) << 21 | (this._cookieFalloff ? 1 : 0) << 20 | chanId[this._cookieChannel.charAt(0)] << 18 | (this._cookieTransform ? 1 : 0) << 12 | this._shape << 10 | this.numCascades - 1 << 8;

	    if (this._cookieChannel.length === 3) {
	      key |= chanId[this._cookieChannel.charAt(1)] << 16;
	      key |= chanId[this._cookieChannel.charAt(2)] << 14;
	    }

	    if (key !== this.key && this._scene !== null) {
	      this.layersDirty();
	    }

	    this.key = key;
	  };

	  _createClass(Light, [{
	    key: "numCascades",
	    get: function get() {
	      return this.cascades.length;
	    },
	    set: function set(value) {
	      if (!this.cascades || this.numCascades !== value) {
	        this.cascades = directionalCascades[value - 1];
	        this._shadowMatrixPalette = new Float32Array(4 * 16);
	        this._shadowCascadeDistances = new Float32Array(4);

	        this._destroyShadowMap();

	        this.updateKey();
	      }
	    }
	  }, {
	    key: "shadowMap",
	    get: function get() {
	      return this._shadowMap;
	    },
	    set: function set(shadowMap) {
	      if (this._shadowMap !== shadowMap) {
	        this._destroyShadowMap();

	        this._shadowMap = shadowMap;
	      }
	    }
	  }, {
	    key: "numShadowFaces",
	    get: function get() {
	      var type = this._type;

	      if (type === LIGHTTYPE_DIRECTIONAL) {
	        return this.numCascades;
	      } else if (type === LIGHTTYPE_OMNI) {
	        return 6;
	      }

	      return 1;
	    }
	  }, {
	    key: "type",
	    get: function get() {
	      return this._type;
	    },
	    set: function set(value) {
	      if (this._type === value) return;
	      this._type = value;

	      this._destroyShadowMap();

	      this.updateKey();
	      var stype = this._shadowType;
	      this._shadowType = null;
	      this.shadowType = stype;
	    }
	  }, {
	    key: "shape",
	    get: function get() {
	      return this._shape;
	    },
	    set: function set(value) {
	      if (this._shape === value) return;
	      this._shape = value;

	      this._destroyShadowMap();

	      this.updateKey();
	      var stype = this._shadowType;
	      this._shadowType = null;
	      this.shadowType = stype;
	    }
	  }, {
	    key: "shadowType",
	    get: function get() {
	      return this._shadowType;
	    },
	    set: function set(value) {
	      if (this._shadowType === value) return;
	      var device = this.device;
	      if (this._type === LIGHTTYPE_OMNI) value = SHADOW_PCF3;

	      if (value === SHADOW_PCF5 && !device.webgl2) {
	        value = SHADOW_PCF3;
	      }

	      if (value === SHADOW_VSM32 && !device.textureFloatRenderable) value = SHADOW_VSM16;
	      if (value === SHADOW_VSM16 && !device.textureHalfFloatRenderable) value = SHADOW_VSM8;
	      this._isVsm = value >= SHADOW_VSM8 && value <= SHADOW_VSM32;
	      this._isPcf = value === SHADOW_PCF5 || value === SHADOW_PCF3;
	      this._shadowType = value;

	      this._destroyShadowMap();

	      this.updateKey();
	    }
	  }, {
	    key: "enabled",
	    get: function get() {
	      return this._enabled;
	    },
	    set: function set(value) {
	      if (this._enabled !== value) {
	        this._enabled = value;
	        this.layersDirty();
	      }
	    }
	  }, {
	    key: "castShadows",
	    get: function get() {
	      return this._castShadows && this.mask !== MASK_BAKE && this.mask !== 0;
	    },
	    set: function set(value) {
	      if (this._castShadows !== value) {
	        this._castShadows = value;

	        this._destroyShadowMap();

	        this.layersDirty();
	        this.updateKey();
	      }
	    }
	  }, {
	    key: "shadowResolution",
	    get: function get() {
	      return this._shadowResolution;
	    },
	    set: function set(value) {
	      if (this._shadowResolution !== value) {
	        if (this._type === LIGHTTYPE_OMNI) {
	          value = Math.min(value, this.device.maxCubeMapSize);
	        } else {
	          value = Math.min(value, this.device.maxTextureSize);
	        }

	        this._shadowResolution = value;

	        this._destroyShadowMap();
	      }
	    }
	  }, {
	    key: "vsmBlurSize",
	    get: function get() {
	      return this._vsmBlurSize;
	    },
	    set: function set(value) {
	      if (this._vsmBlurSize === value) return;
	      if (value % 2 === 0) value++;
	      this._vsmBlurSize = value;
	    }
	  }, {
	    key: "normalOffsetBias",
	    get: function get() {
	      return this._normalOffsetBias;
	    },
	    set: function set(value) {
	      if (this._normalOffsetBias === value) return;

	      if (!this._normalOffsetBias && value || this._normalOffsetBias && !value) {
	        this.updateKey();
	      }

	      this._normalOffsetBias = value;
	    }
	  }, {
	    key: "falloffMode",
	    get: function get() {
	      return this._falloffMode;
	    },
	    set: function set(value) {
	      if (this._falloffMode === value) return;
	      this._falloffMode = value;
	      this.updateKey();
	    }
	  }, {
	    key: "innerConeAngle",
	    get: function get() {
	      return this._innerConeAngle;
	    },
	    set: function set(value) {
	      if (this._innerConeAngle === value) return;
	      this._innerConeAngle = value;
	      this._innerConeAngleCos = Math.cos(value * Math.PI / 180);
	    }
	  }, {
	    key: "outerConeAngle",
	    get: function get() {
	      return this._outerConeAngle;
	    },
	    set: function set(value) {
	      if (this._outerConeAngle === value) return;
	      this._outerConeAngle = value;
	      this._outerConeAngleCos = Math.cos(value * Math.PI / 180);
	    }
	  }, {
	    key: "intensity",
	    get: function get() {
	      return this._intensity;
	    },
	    set: function set(value) {
	      if (this._intensity !== value) {
	        this._intensity = value;

	        this._updateFinalColor();
	      }
	    }
	  }, {
	    key: "cookieMatrix",
	    get: function get() {
	      if (!this._cookieMatrix) {
	        this._cookieMatrix = new Mat4();
	      }

	      return this._cookieMatrix;
	    }
	  }, {
	    key: "atlasViewport",
	    get: function get() {
	      if (!this._atlasViewport) {
	        this._atlasViewport = new Vec4(0, 0, 1, 1);
	      }

	      return this._atlasViewport;
	    }
	  }, {
	    key: "cookie",
	    get: function get() {
	      return this._cookie;
	    },
	    set: function set(value) {
	      if (this._cookie === value) return;
	      this._cookie = value;
	      this.updateKey();
	    }
	  }, {
	    key: "cookieFalloff",
	    get: function get() {
	      return this._cookieFalloff;
	    },
	    set: function set(value) {
	      if (this._cookieFalloff === value) return;
	      this._cookieFalloff = value;
	      this.updateKey();
	    }
	  }, {
	    key: "cookieChannel",
	    get: function get() {
	      return this._cookieChannel;
	    },
	    set: function set(value) {
	      if (this._cookieChannel === value) return;

	      if (value.length < 3) {
	        var chr = value.charAt(value.length - 1);
	        var addLen = 3 - value.length;

	        for (var i = 0; i < addLen; i++) {
	          value += chr;
	        }
	      }

	      this._cookieChannel = value;
	      this.updateKey();
	    }
	  }, {
	    key: "cookieTransform",
	    get: function get() {
	      return this._cookieTransform;
	    },
	    set: function set(value) {
	      if (this._cookieTransform === value) return;
	      this._cookieTransform = value;
	      this._cookieTransformSet = !!value;

	      if (value && !this._cookieOffset) {
	        this.cookieOffset = new Vec2();
	        this._cookieOffsetSet = false;
	      }

	      this.updateKey();
	    }
	  }, {
	    key: "cookieOffset",
	    get: function get() {
	      return this._cookieOffset;
	    },
	    set: function set(value) {
	      if (this._cookieOffset === value) return;
	      var xformNew = !!(this._cookieTransformSet || value);

	      if (xformNew && !value && this._cookieOffset) {
	        this._cookieOffset.set(0, 0);
	      } else {
	        this._cookieOffset = value;
	      }

	      this._cookieOffsetSet = !!value;

	      if (value && !this._cookieTransform) {
	        this.cookieTransform = new Vec4(1, 1, 0, 0);
	        this._cookieTransformSet = false;
	      }

	      this.updateKey();
	    }
	  }]);

	  return Light;
	}();

	var LightingParams = function () {
	  function LightingParams(supportsAreaLights, maxTextureSize, dirtyLightsFnc) {
	    this._maxTextureSize = maxTextureSize;
	    this._supportsAreaLights = supportsAreaLights;
	    this._dirtyLightsFnc = dirtyLightsFnc;
	    this._areaLightsEnabled = false;
	    this._cells = new Vec3(10, 3, 10);
	    this._maxLightsPerCell = 255;
	    this._shadowsEnabled = true;
	    this._shadowType = SHADOW_PCF3;
	    this._shadowAtlasResolution = 2048;
	    this._cookiesEnabled = false;
	    this._cookieAtlasResolution = 2048;
	    this.atlasSplit = null;
	    this.debugLayer = undefined;
	  }

	  var _proto = LightingParams.prototype;

	  _proto.applySettings = function applySettings(render) {
	    this.shadowsEnabled = render.lightingShadowsEnabled;
	    this.cookiesEnabled = render.lightingCookiesEnabled;
	    this.areaLightsEnabled = render.lightingAreaLightsEnabled;
	    this.shadowAtlasResolution = render.lightingShadowAtlasResolution;
	    this.cookieAtlasResolution = render.lightingCookieAtlasResolution;
	    this.maxLightsPerCell = render.lightingMaxLightsPerCell;
	    this.shadowType = render.lightingShadowType;
	    this.cell = new Vec3(render.lightingCells);
	  };

	  _createClass(LightingParams, [{
	    key: "cells",
	    get: function get() {
	      return this._cells;
	    },
	    set: function set(value) {
	      this._cells.copy(value);
	    }
	  }, {
	    key: "maxLightsPerCell",
	    get: function get() {
	      return this._maxLightsPerCell;
	    },
	    set: function set(value) {
	      this._maxLightsPerCell = math.clamp(value, 1, 255);
	    }
	  }, {
	    key: "cookieAtlasResolution",
	    get: function get() {
	      return this._cookieAtlasResolution;
	    },
	    set: function set(value) {
	      this._cookieAtlasResolution = math.clamp(value, 32, this._maxTextureSize);
	    }
	  }, {
	    key: "shadowAtlasResolution",
	    get: function get() {
	      return this._shadowAtlasResolution;
	    },
	    set: function set(value) {
	      this._shadowAtlasResolution = math.clamp(value, 32, this._maxTextureSize);
	    }
	  }, {
	    key: "shadowType",
	    get: function get() {
	      return this._shadowType;
	    },
	    set: function set(value) {
	      if (this._shadowType !== value) {
	        this._shadowType = value;

	        this._dirtyLightsFnc();
	      }
	    }
	  }, {
	    key: "cookiesEnabled",
	    get: function get() {
	      return this._cookiesEnabled;
	    },
	    set: function set(value) {
	      if (this._cookiesEnabled !== value) {
	        this._cookiesEnabled = value;

	        this._dirtyLightsFnc();
	      }
	    }
	  }, {
	    key: "areaLightsEnabled",
	    get: function get() {
	      return this._areaLightsEnabled;
	    },
	    set: function set(value) {
	      if (this._supportsAreaLights) {
	        if (this._areaLightsEnabled !== value) {
	          this._areaLightsEnabled = value;

	          this._dirtyLightsFnc();
	        }
	      }
	    }
	  }, {
	    key: "shadowsEnabled",
	    get: function get() {
	      return this._shadowsEnabled;
	    },
	    set: function set(value) {
	      if (this._shadowsEnabled !== value) {
	        this._shadowsEnabled = value;

	        this._dirtyLightsFnc();
	      }
	    }
	  }]);

	  return LightingParams;
	}();

	var bakeDirLmEndPS = "\n    vec4 dirLm = texture2D(texture_dirLightMap, vUv1);\n\n    if (bakeDir > 0.5) {\n        if (dAtten > 0.00001) {\n            dirLm.xyz = dirLm.xyz * 2.0 - vec3(1.0);\n            dAtten = saturate(dAtten);\n            gl_FragColor.rgb = normalize(dLightDirNormW.xyz*dAtten + dirLm.xyz*dirLm.w) * 0.5 + vec3(0.5);\n            gl_FragColor.a = dirLm.w + dAtten;\n            gl_FragColor.a = max(gl_FragColor.a, 1.0 / 255.0);\n        } else {\n            gl_FragColor = dirLm;\n        }\n    } else {\n        gl_FragColor.rgb = dirLm.xyz;\n        gl_FragColor.a = max(dirLm.w, dAtten > 0.00001? (1.0/255.0) : 0.0);\n    }\n";

	var bakeLmEndPS = "\n    gl_FragColor.rgb = dDiffuseLight;\n    gl_FragColor.rgb = pow(gl_FragColor.rgb, vec3(0.5));\n    gl_FragColor.rgb /= 8.0;\n    gl_FragColor.a = clamp( max( max( gl_FragColor.r, gl_FragColor.g ), max( gl_FragColor.b, 1.0 / 255.0 ) ), 0.0,1.0 );\n    gl_FragColor.a = ceil(gl_FragColor.a * 255.0) / 255.0;\n    gl_FragColor.rgb /= gl_FragColor.a;\n";

	var dilatePS = "\n#define SHADER_NAME Dilate\n\nvarying vec2 vUv0;\n\nuniform sampler2D source;\nuniform vec2 pixelOffset;\n\nvoid main(void) {\n    vec4 c = texture2D(source, vUv0);\n    c = c.a>0.0? c : texture2D(source, vUv0 - pixelOffset);\n    c = c.a>0.0? c : texture2D(source, vUv0 + vec2(0, -pixelOffset.y));\n    c = c.a>0.0? c : texture2D(source, vUv0 + vec2(pixelOffset.x, -pixelOffset.y));\n    c = c.a>0.0? c : texture2D(source, vUv0 + vec2(-pixelOffset.x, 0));\n    c = c.a>0.0? c : texture2D(source, vUv0 + vec2(pixelOffset.x, 0));\n    c = c.a>0.0? c : texture2D(source, vUv0 + vec2(-pixelOffset.x, pixelOffset.y));\n    c = c.a>0.0? c : texture2D(source, vUv0 + vec2(0, pixelOffset.y));\n    c = c.a>0.0? c : texture2D(source, vUv0 + pixelOffset);\n    gl_FragColor = c;\n}\n";

	var bilateralDeNoisePS = "\n// bilateral filter, based on https://www.shadertoy.com/view/4dfGDH# and\n// http://people.csail.mit.edu/sparis/bf_course/course_notes.pdf\n\n// A bilateral filter is a non-linear, edge-preserving, and noise-reducing smoothing filter for images.\n// It replaces the intensity of each pixel with a weighted average of intensity values from nearby pixels.\n// This weight can be based on a Gaussian distribution. Crucially, the weights depend not only on\n// Euclidean distance of pixels, but also on the radiometric differences (e.g., range differences, such\n// as color intensity, depth distance, etc.). This preserves sharp edges.\n\n#define SHADER_NAME BilateralDeNoise\n\nfloat normpdf3(in vec3 v, in float sigma) {\n    return 0.39894 * exp(-0.5 * dot(v, v) / (sigma * sigma)) / sigma;\n}\n\nvec3 decodeRGBM(vec4 rgbm) {\n    vec3 color = (8.0 * rgbm.a) * rgbm.rgb;\n    return color * color;\n}\n\nfloat saturate(float x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nvec4 encodeRGBM(vec3 color) { // modified RGBM\n    vec4 encoded;\n    encoded.rgb = pow(color.rgb, vec3(0.5));\n    encoded.rgb *= 1.0 / 8.0;\n\n    encoded.a = saturate( max( max( encoded.r, encoded.g ), max( encoded.b, 1.0 / 255.0 ) ) );\n    encoded.a = ceil(encoded.a * 255.0) / 255.0;\n\n    encoded.rgb /= encoded.a;\n    return encoded;\n}\n\n// filter size\n#define MSIZE 15\n\nvarying vec2 vUv0;\nuniform sampler2D source;\nuniform vec2 pixelOffset;\nuniform vec2 sigmas;\nuniform float bZnorm;\nuniform float kernel[MSIZE];\n\nvoid main(void) {\n    \n    vec4 pixelRgbm = texture2D(source, vUv0);\n\n    // lightmap specific optimization - skip pixels that were not baked\n    // this also allows dilate filter that work on the output of this to work correctly, as it depends on .a being zero\n    // to dilate, which the following blur filter would otherwise modify\n    if (pixelRgbm.a <= 0.0) {\n        gl_FragColor = pixelRgbm;\n        return ;\n    }\n\n    // range sigma - controls blurriness based on a pixel distance\n    float sigma = sigmas.x;\n\n    // domain sigma - controls blurriness based on a pixel similarity (to preserve edges)\n    float bSigma = sigmas.y;\n\n    vec3 pixelHdr = decodeRGBM(pixelRgbm);\n    vec3 accumulatedHdr = vec3(0.0);\n    float accumulatedFactor = 0.0;\n\n    // read out the texels\n    const int kSize = (MSIZE-1)/2;\n    for (int i = -kSize; i <= kSize; ++i) {\n        for (int j = -kSize; j <= kSize; ++j) {\n            \n            // sample the pixel with offset\n            vec2 coord = vUv0 + vec2(float(i), float(j)) * pixelOffset;\n            vec4 rgbm = texture2D(source, coord);\n\n            // lightmap - only use baked pixels\n            if (rgbm.a > 0.0) {\n                vec3 hdr = decodeRGBM(rgbm);\n\n                // bilateral factors\n                float factor = kernel[kSize + j] * kernel[kSize + i];\n                factor *= normpdf3(hdr - pixelHdr, bSigma) * bZnorm;\n\n                // accumulate\n                accumulatedHdr += factor * hdr;\n                accumulatedFactor += factor;\n            }\n        }\n    }\n\n    gl_FragColor = encodeRGBM(accumulatedHdr / accumulatedFactor);\n}\n";

	var shaderChunksLightmapper = {
	  bakeDirLmEndPS: bakeDirLmEndPS,
	  bakeLmEndPS: bakeLmEndPS,
	  dilatePS: dilatePS,
	  bilateralDeNoisePS: bilateralDeNoisePS
	};

	var tempSphere = new BoundingSphere();

	var BakeLight = function () {
	  function BakeLight(scene, light) {
	    this.scene = scene;
	    this.light = light;
	    this.store();
	    light.numCascades = 1;

	    if (light.type !== LIGHTTYPE_DIRECTIONAL) {
	      light._node.getWorldTransform();

	      light.getBoundingSphere(tempSphere);
	      this.lightBounds = new BoundingBox();
	      this.lightBounds.center.copy(tempSphere.center);
	      this.lightBounds.halfExtents.set(tempSphere.radius, tempSphere.radius, tempSphere.radius);
	    }
	  }

	  var _proto = BakeLight.prototype;

	  _proto.store = function store() {
	    this.mask = this.light.mask;
	    this.shadowUpdateMode = this.light.shadowUpdateMode;
	    this.enabled = this.light.enabled;
	    this.intensity = this.light.intensity;
	    this.rotation = this.light._node.getLocalRotation().clone();
	    this.numCascades = this.light.numCascades;
	  };

	  _proto.restore = function restore() {
	    var light = this.light;
	    light.mask = this.mask;
	    light.shadowUpdateMode = this.shadowUpdateMode;
	    light.enabled = this.enabled;
	    light.intensity = this.intensity;

	    light._node.setLocalRotation(this.rotation);

	    light.numCascades = this.numCascades;
	  };

	  _proto.startBake = function startBake() {
	    this.light.enabled = true;

	    this.light._destroyShadowMap();
	  };

	  _proto.endBake = function endBake(shadowMapCache) {
	    var light = this.light;
	    light.enabled = false;

	    if (light.shadowMap) {
	      if (light.shadowMap.cached) shadowMapCache.add(light, light.shadowMap);
	      light.shadowMap = null;
	    }
	  };

	  return BakeLight;
	}();

	var _tempPoint$1 = new Vec2();

	var BakeLightSimple = function (_BakeLight) {
	  _inheritsLoose(BakeLightSimple, _BakeLight);

	  function BakeLightSimple() {
	    return _BakeLight.apply(this, arguments) || this;
	  }

	  var _proto = BakeLightSimple.prototype;

	  _proto.prepareVirtualLight = function prepareVirtualLight(index, numVirtualLights) {
	    var light = this.light;

	    light._node.setLocalRotation(this.rotation);

	    if (index > 0) {
	      var directionalSpreadAngle = light.bakeArea;
	      random.circlePointDeterministic(_tempPoint$1, index, numVirtualLights);

	      _tempPoint$1.mulScalar(directionalSpreadAngle * 0.5);

	      light._node.rotateLocal(_tempPoint$1.x, 0, _tempPoint$1.y);
	    }

	    light._node.getWorldTransform();

	    var gamma = this.scene.gammaCorrection ? 2.2 : 1;
	    var linearIntensity = Math.pow(this.intensity, gamma);
	    light.intensity = Math.pow(linearIntensity / numVirtualLights, 1 / gamma);
	  };

	  _createClass(BakeLightSimple, [{
	    key: "numVirtualLights",
	    get: function get() {
	      if (this.light.type === LIGHTTYPE_DIRECTIONAL) {
	        return this.light.bakeNumSamples;
	      }

	      return 1;
	    }
	  }]);

	  return BakeLightSimple;
	}(BakeLight);

	var FrameGraph = function () {
	  function FrameGraph() {
	    this.renderPasses = [];
	    this.renderTargetMap = new Map();
	  }

	  var _proto = FrameGraph.prototype;

	  _proto.addRenderPass = function addRenderPass(renderPass) {
	    this.renderPasses.push(renderPass);
	  };

	  _proto.reset = function reset() {
	    this.renderPasses.length = 0;
	  };

	  _proto.compile = function compile() {
	    var renderTargetMap = this.renderTargetMap;
	    var renderPasses = this.renderPasses;

	    for (var i = 0; i < renderPasses.length; i++) {
	      var renderPass = renderPasses[i];
	      var renderTarget = renderPass.renderTarget;

	      if (renderTarget !== undefined) {
	        var prevPass = renderTargetMap.get(renderTarget);

	        if (prevPass) {
	          if (!renderPass.colorOps.clear) {
	            prevPass.colorOps.store = true;
	          }

	          if (!renderPass.depthStencilOps.clearDepth) {
	            prevPass.depthStencilOps.storeDepth = true;
	          }

	          if (!renderPass.depthStencilOps.clearStencil) {
	            prevPass.depthStencilOps.storeStencil = true;
	          }
	        }

	        renderTargetMap.set(renderTarget, renderPass);
	      }
	    }

	    var lastCubeTexture = null;
	    var lastCubeRenderPass = null;

	    for (var _i = 0; _i < renderPasses.length; _i++) {
	      var _renderPass = renderPasses[_i];
	      var _renderTarget = _renderPass.renderTarget;
	      var thisTexture = _renderTarget == null ? void 0 : _renderTarget.colorBuffer;

	      if (thisTexture != null && thisTexture.cubemap) {
	        if (lastCubeTexture === thisTexture) {
	          lastCubeRenderPass.colorOps.mipmaps = false;
	        }

	        lastCubeTexture = _renderTarget.colorBuffer;
	        lastCubeRenderPass = _renderPass;
	      } else if (_renderPass.requiresCubemaps) {
	        lastCubeTexture = null;
	        lastCubeRenderPass = null;
	      }
	    }

	    renderTargetMap.forEach(function (renderPass, renderTarget) {
	      if (renderTarget === null) {
	        renderPass.colorOps.store = true;
	        renderPass.colorOps.resolve = false;
	        renderPass.colorOps.mipmaps = false;
	      }
	    });
	    renderTargetMap.clear();
	    this.log();
	  };

	  _proto.render = function render() {
	    this.compile();
	    var renderPasses = this.renderPasses;

	    for (var i = 0; i < renderPasses.length; i++) {
	      renderPasses[i].render();
	    }
	  };

	  _proto.log = function log() {};

	  return FrameGraph;
	}();

	var AreaLightCacheEntry = function () {
	  function AreaLightCacheEntry(texture0, texture1) {
	    this.texture0 = texture0;
	    this.texture1 = texture1;
	  }

	  var _proto = AreaLightCacheEntry.prototype;

	  _proto.destroy = function destroy() {
	    var _this$texture, _this$texture2;

	    (_this$texture = this.texture0) == null ? void 0 : _this$texture.destroy();
	    (_this$texture2 = this.texture1) == null ? void 0 : _this$texture2.destroy();
	  };

	  return AreaLightCacheEntry;
	}();

	var deviceCache = new DeviceCache();

	var AreaLightLuts = function () {
	  function AreaLightLuts() {}

	  AreaLightLuts.createTexture = function createTexture(device, format, size, postfix) {
	    if (postfix === void 0) {
	      postfix = '';
	    }

	    var tex = new Texture(device, {
	      width: size,
	      height: size,
	      format: format,
	      addressU: ADDRESS_CLAMP_TO_EDGE,
	      addressV: ADDRESS_CLAMP_TO_EDGE,
	      type: TEXTURETYPE_DEFAULT,
	      magFilter: FILTER_LINEAR,
	      minFilter: FILTER_NEAREST,
	      anisotropy: 1,
	      name: "AreaLightLUT" + postfix
	    });
	    return tex;
	  };

	  AreaLightLuts.applyTextures = function applyTextures(device, texture1, texture2) {
	    deviceCache.remove(device);
	    deviceCache.get(device, function () {
	      return new AreaLightCacheEntry(texture1, texture1 === texture2 ? null : texture2);
	    });
	    device.scope.resolve('areaLightsLutTex1').setValue(texture1);
	    device.scope.resolve('areaLightsLutTex2').setValue(texture2);
	  };

	  AreaLightLuts.createPlaceholder = function createPlaceholder(device) {
	    var texture = AreaLightLuts.createTexture(device, PIXELFORMAT_R8_G8_B8_A8, 2, 'placeholder');
	    var pixels = texture.lock();
	    pixels.fill(0);
	    texture.unlock();
	    AreaLightLuts.applyTextures(device, texture, texture);
	  };

	  AreaLightLuts.set = function set(device, resource) {
	    function buildTexture(device, data, format) {
	      var texture = AreaLightLuts.createTexture(device, format, 64);
	      texture.lock().set(data);
	      texture.unlock();
	      texture.upload();
	      return texture;
	    }

	    function offsetScale(data, offset, scale) {
	      var count = data.length;
	      var ret = new Float32Array(count);

	      for (var i = 0; i < count; i++) {
	        var n = i % 4;
	        ret[i] = (data[i] + offset[n]) * scale[n];
	      }

	      return ret;
	    }

	    function convertToHalfFloat(data) {
	      var count = data.length;
	      var ret = new Uint16Array(count);
	      var float2Half = FloatPacking.float2Half;

	      for (var i = 0; i < count; i++) {
	        ret[i] = float2Half(data[i]);
	      }

	      return ret;
	    }

	    function convertToUint(data) {
	      var count = data.length;
	      var ret = new Uint8ClampedArray(count);

	      for (var i = 0; i < count; i++) {
	        ret[i] = data[i] * 255;
	      }

	      return ret;
	    }

	    var versions = new Int16Array(resource, 0, 2);
	    var majorVersion = versions[0];
	    var minorVersion = versions[1];

	    if (majorVersion !== 0 || minorVersion !== 1) ; else {
	      var srcData1 = new Float32Array(resource, 4, 16384);
	      var srcData2 = new Float32Array(resource, 4 + 16384 * 4, 16384);
	      var data1, data2;
	      var format = device.areaLightLutFormat;

	      if (format === PIXELFORMAT_RGBA32F) {
	        data1 = srcData1;
	        data2 = srcData2;
	      } else if (format === PIXELFORMAT_RGBA16F) {
	        data1 = convertToHalfFloat(srcData1);
	        data2 = convertToHalfFloat(srcData2);
	      } else {
	        var o1 = [0.0, 0.2976, 0.01381, 0.0];
	        var s1 = [0.999, 3.08737, 1.6546, 0.603249];
	        var o2 = [-0.306897, 0.0, 0.0, 0.0];
	        var s2 = [1.442787, 1.0, 1.0, 1.0];
	        data1 = convertToUint(offsetScale(srcData1, o1, s1));
	        data2 = convertToUint(offsetScale(srcData2, o2, s2));
	      }

	      var tex1 = buildTexture(device, data1, format);
	      var tex2 = buildTexture(device, data2, format);
	      AreaLightLuts.applyTextures(device, tex1, tex2);
	    }
	  };

	  return AreaLightLuts;
	}();

	var skybox = {
	  generateKey: function generateKey(options) {
	    return options.type === 'cubemap' ? "skybox-" + options.type + "-" + options.encoding + "-" + options.useIntensity + "-" + options.gamma + "-" + options.toneMapping + "-" + options.fixSeams + "-" + options.mip : "skybox-" + options.type + "-" + options.encoding + "-" + options.useIntensity + "-" + options.gamma + "-" + options.toneMapping;
	  },
	  createShaderDefinition: function createShaderDefinition(device, options) {
	    var fshader;

	    if (options.type === 'cubemap') {
	      var mip2size = [128, 64, 16, 8, 4, 2];
	      fshader = precisionCode(device);
	      fshader += options.mip ? shaderChunks.fixCubemapSeamsStretchPS : shaderChunks.fixCubemapSeamsNonePS;
	      fshader += options.useIntensity ? shaderChunks.envMultiplyPS : shaderChunks.envConstPS;
	      fshader += shaderChunks.decodePS;
	      fshader += gammaCode(options.gamma);
	      fshader += tonemapCode(options.toneMapping);
	      fshader += shaderChunks.skyboxHDRPS.replace(/\$DECODE/g, ChunkUtils.decodeFunc(options.encoding)).replace(/\$FIXCONST/g, 1 - 1 / mip2size[options.mip] + "");
	    } else {
	      fshader = precisionCode(device);
	      fshader += options.useIntensity ? shaderChunks.envMultiplyPS : shaderChunks.envConstPS;
	      fshader += shaderChunks.decodePS;
	      fshader += gammaCode(options.gamma);
	      fshader += tonemapCode(options.toneMapping);
	      fshader += shaderChunks.sphericalPS;
	      fshader += shaderChunks.envAtlasPS;
	      fshader += shaderChunks.skyboxEnvPS.replace(/\$DECODE/g, ChunkUtils.decodeFunc(options.encoding));
	    }

	    return {
	      attributes: {
	        aPosition: SEMANTIC_POSITION
	      },
	      vshader: shaderChunks.skyboxVS,
	      fshader: fshader
	    };
	  }
	};

	var _mat4;

	var Sky = function () {
	  function Sky(device, scene, texture) {
	    this.meshInstance = void 0;
	    this._rotationMat3 = void 0;
	    var material = new Material();

	    material.getShaderVariant = function (dev, sc, defs, staticLightList, pass, sortedLights, viewUniformFormat, viewBindGroupFormat) {
	      var library = device.getProgramLibrary();
	      library.register('skybox', skybox);

	      if (texture.cubemap) {
	        return library.getProgram('skybox', {
	          type: 'cubemap',
	          encoding: texture.encoding,
	          useIntensity: scene.skyboxIntensity !== 1,
	          mip: texture.fixCubemapSeams ? scene.skyboxMip : 0,
	          fixSeams: texture.fixCubemapSeams,
	          gamma: pass === SHADER_FORWARDHDR ? scene.gammaCorrection ? GAMMA_SRGBHDR : GAMMA_NONE : scene.gammaCorrection,
	          toneMapping: pass === SHADER_FORWARDHDR ? TONEMAP_LINEAR : scene.toneMapping
	        });
	      }

	      return library.getProgram('skybox', {
	        type: 'envAtlas',
	        encoding: texture.encoding,
	        useIntensity: scene.skyboxIntensity !== 1,
	        gamma: pass === SHADER_FORWARDHDR ? scene.gammaCorrection ? GAMMA_SRGBHDR : GAMMA_NONE : scene.gammaCorrection,
	        toneMapping: pass === SHADER_FORWARDHDR ? TONEMAP_LINEAR : scene.toneMapping
	      });
	    };

	    if (texture.cubemap) {
	      material.setParameter('texture_cubeMap', texture);
	    } else {
	      material.setParameter('texture_envAtlas', texture);
	      material.setParameter('mipLevel', scene._skyboxMip);
	    }

	    if (!scene.skyboxRotation.equals(Quat.IDENTITY)) {
	      _mat4 = _mat4 || new Mat4();
	      this._rotationMat3 = this._rotationMat3 || new Mat3();

	      _mat4.setTRS(Vec3.ZERO, scene._skyboxRotation, Vec3.ONE);

	      _mat4.invertTo3x3(this._rotationMat3);

	      material.setParameter('cubeMapRotationMatrix', this._rotationMat3.data);
	    } else {
	      material.setParameter('cubeMapRotationMatrix', Mat3.IDENTITY.data);
	    }

	    material.cull = CULLFACE_FRONT;
	    material.depthWrite = false;
	    var skyLayer = scene.layers.getLayerById(LAYERID_SKYBOX);

	    if (skyLayer) {
	      var node = new GraphNode('Skybox');
	      var mesh = createBox(device);
	      var meshInstance = new MeshInstance(mesh, material, node);
	      this.meshInstance = meshInstance;
	      meshInstance.cull = false;
	      meshInstance._noDepthDrawGl1 = true;
	      meshInstance.pick = false;
	      skyLayer.addMeshInstances([meshInstance]);
	      this.skyLayer = skyLayer;
	    }
	  }

	  var _proto = Sky.prototype;

	  _proto.destroy = function destroy() {
	    if (this.meshInstance) {
	      if (this.skyLayer) {
	        this.skyLayer.removeMeshInstances([this.meshInstance]);
	      }

	      this.meshInstance.destroy();
	      this.meshInstance = null;
	    }
	  };

	  return Sky;
	}();

	var identityGraphNode = new GraphNode();
	identityGraphNode.worldTransform = Mat4.IDENTITY;
	identityGraphNode._dirtyWorld = identityGraphNode._dirtyNormal = false;

	var ImmediateBatch = function () {
	  function ImmediateBatch(device, material, layer) {
	    this.material = material;
	    this.layer = layer;
	    this.positions = [];
	    this.colors = [];
	    this.mesh = new Mesh(device);
	    this.meshInstance = null;
	  }

	  var _proto = ImmediateBatch.prototype;

	  _proto.addLines = function addLines(positions, color) {
	    var destPos = this.positions;
	    var count = positions.length;

	    for (var i = 0; i < count; i++) {
	      var pos = positions[i];
	      destPos.push(pos.x, pos.y, pos.z);
	    }

	    var destCol = this.colors;

	    if (color.length) {
	      for (var _i = 0; _i < count; _i++) {
	        var col = color[_i];
	        destCol.push(col.r, col.g, col.b, col.a);
	      }
	    } else {
	      for (var _i2 = 0; _i2 < count; _i2++) {
	        destCol.push(color.r, color.g, color.b, color.a);
	      }
	    }
	  };

	  _proto.addLinesArrays = function addLinesArrays(positions, color) {
	    var destPos = this.positions;

	    for (var i = 0; i < positions.length; i += 3) {
	      destPos.push(positions[i], positions[i + 1], positions[i + 2]);
	    }

	    var destCol = this.colors;

	    if (color.length) {
	      for (var _i3 = 0; _i3 < color.length; _i3 += 4) {
	        destCol.push(color[_i3], color[_i3 + 1], color[_i3 + 2], color[_i3 + 3]);
	      }
	    } else {
	      var count = positions.length / 3;

	      for (var _i4 = 0; _i4 < count; _i4++) {
	        destCol.push(color.r, color.g, color.b, color.a);
	      }
	    }
	  };

	  _proto.onPreRender = function onPreRender(visibleList, transparent) {
	    if (this.positions.length > 0 && this.material.transparent === transparent) {
	      this.mesh.setPositions(this.positions);
	      this.mesh.setColors(this.colors);
	      this.mesh.update(PRIMITIVE_LINES, false);

	      if (!this.meshInstance) {
	        this.meshInstance = new MeshInstance(this.mesh, this.material, identityGraphNode);
	      }

	      this.positions.length = 0;
	      this.colors.length = 0;
	      visibleList.list.push(this.meshInstance);
	      visibleList.length++;
	    }
	  };

	  return ImmediateBatch;
	}();

	var ImmediateBatches = function () {
	  function ImmediateBatches(device) {
	    this.device = device;
	    this.map = new Map();
	  }

	  var _proto = ImmediateBatches.prototype;

	  _proto.getBatch = function getBatch(material, layer) {
	    var batch = this.map.get(material);

	    if (!batch) {
	      batch = new ImmediateBatch(this.device, material, layer);
	      this.map.set(material, batch);
	    }

	    return batch;
	  };

	  _proto.onPreRender = function onPreRender(visibleList, transparent) {
	    this.map.forEach(function (batch) {
	      batch.onPreRender(visibleList, transparent);
	    });
	  };

	  return ImmediateBatches;
	}();

	var tempPoints = [];

	var Immediate = function () {
	  function Immediate(device) {
	    this.device = device;
	    this.quadMesh = null;
	    this.textureShader = null;
	    this.depthTextureShader = null;
	    this.cubeLocalPos = null;
	    this.cubeWorldPos = null;
	    this.batchesMap = new Map();
	    this.allBatches = new Set();
	    this.updatedLayers = new Set();
	    this._materialDepth = null;
	    this._materialNoDepth = null;
	    this.layerMeshInstances = new Map();
	  }

	  var _proto = Immediate.prototype;

	  _proto.createMaterial = function createMaterial(depthTest) {
	    var material = new BasicMaterial();
	    material.vertexColors = true;
	    material.blend = true;
	    material.blendType = BLEND_NORMAL;
	    material.depthTest = depthTest;
	    material.update();
	    return material;
	  };

	  _proto.getBatch = function getBatch(layer, depthTest) {
	    var batches = this.batchesMap.get(layer);

	    if (!batches) {
	      batches = new ImmediateBatches(this.device);
	      this.batchesMap.set(layer, batches);
	    }

	    this.allBatches.add(batches);
	    var material = depthTest ? this.materialDepth : this.materialNoDepth;
	    return batches.getBatch(material, layer);
	  };

	  Immediate.getTextureVS = function getTextureVS() {
	    return "\n            attribute vec2 vertex_position;\n            uniform mat4 matrix_model;\n            varying vec2 uv0;\n            void main(void) {\n                gl_Position = matrix_model * vec4(vertex_position, 0, 1);\n                uv0 = vertex_position.xy + 0.5;\n            }\n        ";
	  };

	  _proto.getTextureShader = function getTextureShader() {
	    if (!this.textureShader) {
	      var fshader = "\n                varying vec2 uv0;\n                uniform sampler2D colorMap;\n                void main (void) {\n                    gl_FragColor = vec4(texture2D(colorMap, uv0).xyz, 1);\n                }\n            ";
	      this.textureShader = createShaderFromCode(this.device, Immediate.getTextureVS(), fshader, 'DebugTextureShader');
	    }

	    return this.textureShader;
	  };

	  _proto.getDepthTextureShader = function getDepthTextureShader() {
	    if (!this.depthTextureShader) {
	      var fshader = "\n                " + shaderChunks.screenDepthPS + "\n                varying vec2 uv0;\n                void main() {\n                    float depth = getLinearScreenDepth(uv0) * camera_params.x;\n                    gl_FragColor = vec4(vec3(depth), 1.0);\n                }\n            ";
	      this.depthTextureShader = createShaderFromCode(this.device, Immediate.getTextureVS(), fshader, 'DebugDepthTextureShader');
	    }

	    return this.depthTextureShader;
	  };

	  _proto.getQuadMesh = function getQuadMesh() {
	    if (!this.quadMesh) {
	      this.quadMesh = new Mesh(this.device);
	      this.quadMesh.setPositions([-0.5, -0.5, 0, 0.5, -0.5, 0, -0.5, 0.5, 0, 0.5, 0.5, 0]);
	      this.quadMesh.update(PRIMITIVE_TRISTRIP);
	    }

	    return this.quadMesh;
	  };

	  _proto.drawMesh = function drawMesh(material, matrix, mesh, meshInstance, layer) {
	    if (!meshInstance) {
	      var graphNode = this.getGraphNode(matrix);
	      meshInstance = new MeshInstance(mesh, material, graphNode);
	    }

	    var layerMeshInstances = this.layerMeshInstances.get(layer);

	    if (!layerMeshInstances) {
	      layerMeshInstances = [];
	      this.layerMeshInstances.set(layer, layerMeshInstances);
	    }

	    layerMeshInstances.push(meshInstance);
	  };

	  _proto.drawWireAlignedBox = function drawWireAlignedBox(min, max, color, depthTest, layer) {
	    tempPoints.push(min.x, min.y, min.z, min.x, max.y, min.z, min.x, max.y, min.z, max.x, max.y, min.z, max.x, max.y, min.z, max.x, min.y, min.z, max.x, min.y, min.z, min.x, min.y, min.z, min.x, min.y, max.z, min.x, max.y, max.z, min.x, max.y, max.z, max.x, max.y, max.z, max.x, max.y, max.z, max.x, min.y, max.z, max.x, min.y, max.z, min.x, min.y, max.z, min.x, min.y, min.z, min.x, min.y, max.z, min.x, max.y, min.z, min.x, max.y, max.z, max.x, max.y, min.z, max.x, max.y, max.z, max.x, min.y, min.z, max.x, min.y, max.z);
	    var batch = this.getBatch(layer, depthTest);
	    batch.addLinesArrays(tempPoints, color);
	    tempPoints.length = 0;
	  };

	  _proto.drawWireSphere = function drawWireSphere(center, radius, color, numSegments, depthTest, layer) {
	    var step = 2 * Math.PI / numSegments;
	    var angle = 0;

	    for (var i = 0; i < numSegments; i++) {
	      var sin0 = Math.sin(angle);
	      var cos0 = Math.cos(angle);
	      angle += step;
	      var sin1 = Math.sin(angle);
	      var cos1 = Math.cos(angle);
	      tempPoints.push(center.x + radius * sin0, center.y, center.z + radius * cos0);
	      tempPoints.push(center.x + radius * sin1, center.y, center.z + radius * cos1);
	      tempPoints.push(center.x + radius * sin0, center.y + radius * cos0, center.z);
	      tempPoints.push(center.x + radius * sin1, center.y + radius * cos1, center.z);
	      tempPoints.push(center.x, center.y + radius * sin0, center.z + radius * cos0);
	      tempPoints.push(center.x, center.y + radius * sin1, center.z + radius * cos1);
	    }

	    var batch = this.getBatch(layer, depthTest);
	    batch.addLinesArrays(tempPoints, color);
	    tempPoints.length = 0;
	  };

	  _proto.getGraphNode = function getGraphNode(matrix) {
	    var graphNode = new GraphNode('ImmediateDebug');
	    graphNode.worldTransform = matrix;
	    graphNode._dirtyWorld = graphNode._dirtyNormal = false;
	    return graphNode;
	  };

	  _proto.onPreRenderLayer = function onPreRenderLayer(layer, visibleList, transparent) {
	    this.batchesMap.forEach(function (batches, batchLayer) {
	      if (batchLayer === layer) {
	        batches.onPreRender(visibleList, transparent);
	      }
	    });

	    if (!this.updatedLayers.has(layer)) {
	      this.updatedLayers.add(layer);
	      var meshInstances = this.layerMeshInstances.get(layer);

	      if (meshInstances) {
	        for (var i = 0; i < meshInstances.length; i++) {
	          visibleList.list[visibleList.length + i] = meshInstances[i];
	        }

	        visibleList.length += meshInstances.length;
	        meshInstances.length = 0;
	      }
	    }
	  };

	  _proto.onPostRender = function onPostRender() {
	    this.allBatches.clear();
	    this.updatedLayers.clear();
	  };

	  _createClass(Immediate, [{
	    key: "materialDepth",
	    get: function get() {
	      if (!this._materialDepth) {
	        this._materialDepth = this.createMaterial(true);
	      }

	      return this._materialDepth;
	    }
	  }, {
	    key: "materialNoDepth",
	    get: function get() {
	      if (!this._materialNoDepth) {
	        this._materialNoDepth = this.createMaterial(false);
	      }

	      return this._materialNoDepth;
	    }
	  }]);

	  return Immediate;
	}();

	var Scene = function (_EventHandler) {
	  _inheritsLoose(Scene, _EventHandler);

	  function Scene(graphicsDevice) {
	    var _this;

	    _this = _EventHandler.call(this) || this;
	    _this.ambientBake = false;
	    _this.ambientBakeOcclusionBrightness = 0;
	    _this.ambientBakeOcclusionContrast = 0;
	    _this.ambientLight = new Color(0, 0, 0);
	    _this.exposure = 1;
	    _this.fogColor = new Color(0, 0, 0);
	    _this.fogDensity = 0;
	    _this.fogEnd = 1000;
	    _this.fogStart = 1;
	    _this.lightmapSizeMultiplier = 1;
	    _this.lightmapMaxResolution = 2048;
	    _this.lightmapMode = BAKE_COLORDIR;
	    _this.lightmapFilterEnabled = false;
	    _this.root = null;
	    _this.sky = null;
	    _this.device = graphicsDevice || getApplication().graphicsDevice;
	    _this._gravity = new Vec3(0, -9.8, 0);
	    _this._layers = null;
	    _this._fog = FOG_NONE;
	    _this._gammaCorrection = GAMMA_SRGB;
	    _this._toneMapping = 0;
	    _this._skyboxCubeMap = null;
	    _this._prefilteredCubemaps = [null, null, null, null, null, null];
	    _this._envAtlas = null;
	    _this._internalEnvAtlas = null;
	    _this._skyboxIntensity = 1;
	    _this._skyboxMip = 0;
	    _this._skyboxRotation = new Quat();
	    _this._skyboxRotationMat3 = null;
	    _this._skyboxRotationMat4 = null;
	    _this._ambientBakeNumSamples = 1;
	    _this._ambientBakeSpherePart = 0.4;
	    _this._lightmapFilterRange = 10;
	    _this._lightmapFilterSmoothness = 0.2;
	    _this._clusteredLightingEnabled = true;
	    _this._lightingParams = new LightingParams(_this.device.supportsAreaLights, _this.device.maxTextureSize, function () {
	      _this._layers._dirtyLights = true;
	    });
	    _this._stats = {
	      meshInstances: 0,
	      lights: 0,
	      dynamicLights: 0,
	      bakedLights: 0,
	      lastStaticPrepareFullTime: 0,
	      lastStaticPrepareSearchTime: 0,
	      lastStaticPrepareWriteTime: 0,
	      lastStaticPrepareTriAabbTime: 0,
	      lastStaticPrepareCombineTime: 0,
	      updateShadersTime: 0
	    };
	    _this.updateShaders = true;
	    _this._shaderVersion = 0;
	    _this._statsUpdated = false;
	    _this.immediate = new Immediate(_this.device);
	    return _this;
	  }

	  var _proto = Scene.prototype;

	  _proto.destroy = function destroy() {
	    this._resetSky();

	    this.root = null;
	    this.off();
	  };

	  _proto.drawLine = function drawLine(start, end, color, depthTest, layer) {
	    if (color === void 0) {
	      color = Color.WHITE;
	    }

	    if (depthTest === void 0) {
	      depthTest = true;
	    }

	    if (layer === void 0) {
	      layer = this.defaultDrawLayer;
	    }

	    var batch = this.immediate.getBatch(layer, depthTest);
	    batch.addLines([start, end], [color, color]);
	  };

	  _proto.drawLines = function drawLines(positions, colors, depthTest, layer) {
	    if (depthTest === void 0) {
	      depthTest = true;
	    }

	    if (layer === void 0) {
	      layer = this.defaultDrawLayer;
	    }

	    var batch = this.immediate.getBatch(layer, depthTest);
	    batch.addLines(positions, colors);
	  };

	  _proto.drawLineArrays = function drawLineArrays(positions, colors, depthTest, layer) {
	    if (depthTest === void 0) {
	      depthTest = true;
	    }

	    if (layer === void 0) {
	      layer = this.defaultDrawLayer;
	    }

	    var batch = this.immediate.getBatch(layer, depthTest);
	    batch.addLinesArrays(positions, colors);
	  };

	  _proto.applySettings = function applySettings(settings) {
	    var _this2 = this;

	    var physics = settings.physics;
	    var render = settings.render;

	    this._gravity.set(physics.gravity[0], physics.gravity[1], physics.gravity[2]);

	    this.ambientLight.set(render.global_ambient[0], render.global_ambient[1], render.global_ambient[2]);
	    this._fog = render.fog;
	    this.fogColor.set(render.fog_color[0], render.fog_color[1], render.fog_color[2]);
	    this.fogStart = render.fog_start;
	    this.fogEnd = render.fog_end;
	    this.fogDensity = render.fog_density;
	    this._gammaCorrection = render.gamma_correction;
	    this._toneMapping = render.tonemapping;
	    this.lightmapSizeMultiplier = render.lightmapSizeMultiplier;
	    this.lightmapMaxResolution = render.lightmapMaxResolution;
	    this.lightmapMode = render.lightmapMode;
	    this.exposure = render.exposure;
	    this._skyboxIntensity = render.skyboxIntensity === undefined ? 1 : render.skyboxIntensity;
	    this._skyboxMip = render.skyboxMip === undefined ? 0 : render.skyboxMip;

	    if (render.skyboxRotation) {
	      this._skyboxRotation.setFromEulerAngles(render.skyboxRotation[0], render.skyboxRotation[1], render.skyboxRotation[2]);
	    }

	    this.clusteredLightingEnabled = render.clusteredLightingEnabled;
	    this.lighting.applySettings(render);
	    ['lightmapFilterEnabled', 'lightmapFilterRange', 'lightmapFilterSmoothness', 'ambientBake', 'ambientBakeNumSamples', 'ambientBakeSpherePart', 'ambientBakeOcclusionBrightness', 'ambientBakeOcclusionContrast'].forEach(function (setting) {
	      if (render.hasOwnProperty(setting)) {
	        _this2[setting] = render[setting];
	      }
	    });

	    this._resetSky();
	  };

	  _proto._getSkyboxTex = function _getSkyboxTex() {
	    var cubemaps = this._prefilteredCubemaps;

	    if (this._skyboxMip) {
	      var skyboxMapping = [0, 1, 3, 4, 5, 6];
	      return cubemaps[skyboxMapping[this._skyboxMip]] || this._envAtlas || cubemaps[0] || this._skyboxCubeMap;
	    }

	    return this._skyboxCubeMap || cubemaps[0] || this._envAtlas;
	  };

	  _proto._updateSky = function _updateSky(device) {
	    if (!this.sky) {
	      var texture = this._getSkyboxTex();

	      if (texture) {
	        this.sky = new Sky(device, this, texture);
	        this.fire('set:skybox', texture);
	      }
	    }
	  };

	  _proto._resetSky = function _resetSky() {
	    var _this$sky;

	    (_this$sky = this.sky) == null ? void 0 : _this$sky.destroy();
	    this.sky = null;
	    this.updateShaders = true;
	  };

	  _proto.setSkybox = function setSkybox(cubemaps) {
	    if (!cubemaps) {
	      this.skybox = null;
	      this.prefilteredCubemaps = [null, null, null, null, null, null];
	    } else {
	      this.skybox = cubemaps[0] || null;
	      this.prefilteredCubemaps = cubemaps.slice(1);
	    }
	  };

	  _createClass(Scene, [{
	    key: "defaultDrawLayer",
	    get: function get() {
	      return this.layers.getLayerById(LAYERID_IMMEDIATE);
	    }
	  }, {
	    key: "ambientBakeNumSamples",
	    get: function get() {
	      return this._ambientBakeNumSamples;
	    },
	    set: function set(value) {
	      this._ambientBakeNumSamples = math.clamp(Math.floor(value), 1, 255);
	    }
	  }, {
	    key: "ambientBakeSpherePart",
	    get: function get() {
	      return this._ambientBakeSpherePart;
	    },
	    set: function set(value) {
	      this._ambientBakeSpherePart = math.clamp(value, 0.001, 1);
	    }
	  }, {
	    key: "clusteredLightingEnabled",
	    get: function get() {
	      return this._clusteredLightingEnabled;
	    },
	    set: function set(value) {
	      if (!this._clusteredLightingEnabled && value) {
	        console.error('Turning on disabled clustered lighting is not currently supported');
	        return;
	      }

	      this._clusteredLightingEnabled = value;
	    }
	  }, {
	    key: "drawCalls",
	    get: function get() {
	      var drawCalls = this.layers._meshInstances;

	      if (!drawCalls.length) {
	        this.layers._update(this.device, this.clusteredLightingEnabled);

	        drawCalls = this.layers._meshInstances;
	      }

	      return drawCalls;
	    },
	    set: function set(value) {}
	  }, {
	    key: "envAtlas",
	    get: function get() {
	      return this._envAtlas;
	    },
	    set: function set(value) {
	      if (value !== this._envAtlas) {
	        this._envAtlas = value;
	        this.updateShaders = true;
	      }
	    }
	  }, {
	    key: "fog",
	    get: function get() {
	      return this._fog;
	    },
	    set: function set(type) {
	      if (type !== this._fog) {
	        this._fog = type;
	        this.updateShaders = true;
	      }
	    }
	  }, {
	    key: "gammaCorrection",
	    get: function get() {
	      return this._gammaCorrection;
	    },
	    set: function set(value) {
	      if (value !== this._gammaCorrection) {
	        this._gammaCorrection = value;
	        this.updateShaders = true;
	      }
	    }
	  }, {
	    key: "layers",
	    get: function get() {
	      return this._layers;
	    },
	    set: function set(layers) {
	      var prev = this._layers;
	      this._layers = layers;
	      this.fire('set:layers', prev, layers);
	    }
	  }, {
	    key: "lighting",
	    get: function get() {
	      return this._lightingParams;
	    }
	  }, {
	    key: "lightmapFilterRange",
	    get: function get() {
	      return this._lightmapFilterRange;
	    },
	    set: function set(value) {
	      this._lightmapFilterRange = Math.max(value, 0.001);
	    }
	  }, {
	    key: "lightmapFilterSmoothness",
	    get: function get() {
	      return this._lightmapFilterSmoothness;
	    },
	    set: function set(value) {
	      this._lightmapFilterSmoothness = Math.max(value, 0.001);
	    }
	  }, {
	    key: "prefilteredCubemaps",
	    get: function get() {
	      return this._prefilteredCubemaps;
	    },
	    set: function set(value) {
	      var cubemaps = this._prefilteredCubemaps;
	      value = value || [];
	      var changed = false;
	      var complete = true;

	      for (var i = 0; i < 6; ++i) {
	        var v = value[i] || null;

	        if (cubemaps[i] !== v) {
	          cubemaps[i] = v;
	          changed = true;
	        }

	        complete = complete && !!cubemaps[i];
	      }

	      if (changed) {
	        this._resetSky();

	        if (complete) {
	          this._internalEnvAtlas = EnvLighting.generatePrefilteredAtlas(cubemaps, {
	            target: this._internalEnvAtlas
	          });

	          if (!this._envAtlas) {
	            this.envAtlas = this._internalEnvAtlas;
	          }
	        } else if (this._internalEnvAtlas) {
	          if (this._envAtlas === this._internalEnvAtlas) {
	            this.envAtlas = null;
	          }

	          this._internalEnvAtlas.destroy();

	          this._internalEnvAtlas = null;
	        }
	      }
	    }
	  }, {
	    key: "skybox",
	    get: function get() {
	      return this._skyboxCubeMap;
	    },
	    set: function set(value) {
	      if (value !== this._skyboxCubeMap) {
	        this._skyboxCubeMap = value;

	        this._resetSky();
	      }
	    }
	  }, {
	    key: "skyboxIntensity",
	    get: function get() {
	      return this._skyboxIntensity;
	    },
	    set: function set(value) {
	      if (value !== this._skyboxIntensity) {
	        this._skyboxIntensity = value;

	        this._resetSky();
	      }
	    }
	  }, {
	    key: "skyboxMip",
	    get: function get() {
	      return this._skyboxMip;
	    },
	    set: function set(value) {
	      if (value !== this._skyboxMip) {
	        this._skyboxMip = value;

	        this._resetSky();
	      }
	    }
	  }, {
	    key: "skyboxRotation",
	    get: function get() {
	      return this._skyboxRotation;
	    },
	    set: function set(value) {
	      if (!this._skyboxRotation.equals(value)) {
	        this._skyboxRotation.copy(value);

	        this._resetSky();
	      }
	    }
	  }, {
	    key: "toneMapping",
	    get: function get() {
	      return this._toneMapping;
	    },
	    set: function set(value) {
	      if (value !== this._toneMapping) {
	        this._toneMapping = value;
	        this.updateShaders = true;
	      }
	    }
	  }]);

	  return Scene;
	}(EventHandler);

	var Bundle = function () {
	  function Bundle(files) {
	    this._blobUrls = {};

	    for (var i = 0, len = files.length; i < len; i++) {
	      if (files[i].url) {
	        this._blobUrls[files[i].name] = files[i].url;
	      }
	    }
	  }

	  var _proto = Bundle.prototype;

	  _proto.hasBlobUrl = function hasBlobUrl(url) {
	    return !!this._blobUrls[url];
	  };

	  _proto.getBlobUrl = function getBlobUrl(url) {
	    return this._blobUrls[url];
	  };

	  _proto.destroy = function destroy() {
	    for (var key in this._blobUrls) {
	      URL.revokeObjectURL(this._blobUrls[key]);
	    }

	    this._blobUrls = null;
	  };

	  return Bundle;
	}();

	var Untar;

	function UntarScope(isWorker) {
	  var utfDecoder;
	  var asciiDecoder;

	  if (typeof TextDecoder !== 'undefined') {
	    try {
	      utfDecoder = new TextDecoder('utf-8');
	      asciiDecoder = new TextDecoder('windows-1252');
	    } catch (e) {
	      console.warn('TextDecoder not supported - pc.Untar module will not work');
	    }
	  } else {
	    console.warn('TextDecoder not supported - pc.Untar module will not work');
	  }

	  function PaxHeader(fields) {
	    this._fields = fields;
	  }

	  PaxHeader.parse = function (buffer, start, length) {
	    var paxArray = new Uint8Array(buffer, start, length);
	    var bytesRead = 0;
	    var fields = [];

	    while (bytesRead < length) {
	      var spaceIndex = void 0;

	      for (spaceIndex = bytesRead; spaceIndex < length; spaceIndex++) {
	        if (paxArray[spaceIndex] === 0x20) break;
	      }

	      if (spaceIndex >= length) {
	        throw new Error('Invalid PAX header data format.');
	      }

	      var fieldLength = parseInt(utfDecoder.decode(new Uint8Array(buffer, start + bytesRead, spaceIndex - bytesRead)), 10);
	      var fieldText = utfDecoder.decode(new Uint8Array(buffer, start + spaceIndex + 1, fieldLength - (spaceIndex - bytesRead) - 2));
	      var field = fieldText.split('=');

	      if (field.length !== 2) {
	        throw new Error('Invalid PAX header data format.');
	      }

	      if (field[1].length === 0) {
	        field[1] = null;
	      }

	      fields.push({
	        name: field[0],
	        value: field[1]
	      });
	      bytesRead += fieldLength;
	    }

	    return new PaxHeader(fields);
	  };

	  PaxHeader.prototype.applyHeader = function (file) {
	    for (var i = 0; i < this._fields.length; i++) {
	      var fieldName = this._fields[i].name;
	      var fieldValue = this._fields[i].value;

	      if (fieldName === 'path') {
	        fieldName = 'name';
	      }

	      if (fieldValue === null) {
	        delete file[fieldName];
	      } else {
	        file[fieldName] = fieldValue;
	      }
	    }
	  };

	  function UntarInternal(arrayBuffer) {
	    this._arrayBuffer = arrayBuffer || new ArrayBuffer(0);
	    this._bufferView = new DataView(this._arrayBuffer);
	    this._globalPaxHeader = null;
	    this._paxHeader = null;
	    this._bytesRead = 0;
	  }

	  if (!isWorker) {
	    Untar = UntarInternal;
	  }

	  UntarInternal.prototype._hasNext = function () {
	    return this._bytesRead + 4 < this._arrayBuffer.byteLength && this._bufferView.getUint32(this._bytesRead) !== 0;
	  };

	  UntarInternal.prototype._readNextFile = function () {
	    var headersDataView = new DataView(this._arrayBuffer, this._bytesRead, 512);
	    var headers = asciiDecoder.decode(headersDataView);
	    this._bytesRead += 512;
	    var name = headers.substring(0, 100).replace(/\0/g, '');
	    var ustarFormat = headers.substring(257, 263);
	    var size = parseInt(headers.substring(124, 136), 8);
	    var type = headers.substring(156, 157);
	    var start = this._bytesRead;
	    var url = null;
	    var normalFile = false;

	    switch (type) {
	      case '0':
	      case '':
	        normalFile = true;

	        if (!isWorker) {
	          var blob = new Blob([this._arrayBuffer.slice(this._bytesRead, this._bytesRead + size)]);
	          url = URL.createObjectURL(blob);
	        }

	        break;

	      case 'g':
	        this._globalPaxHeader = PaxHeader.parse(this._arrayBuffer, this._bytesRead, size);
	        break;

	      case 'x':
	        this._paxHeader = PaxHeader.parse(this._arrayBuffer, this._bytesRead, size);
	        break;
	    }

	    this._bytesRead += size;
	    var remainder = size % 512;

	    if (remainder !== 0) {
	      this._bytesRead += 512 - remainder;
	    }

	    if (!normalFile) {
	      return null;
	    }

	    if (ustarFormat.indexOf('ustar') !== -1) {
	      var namePrefix = headers.substring(345, 500).replace(/\0/g, '');

	      if (namePrefix.length > 0) {
	        name = namePrefix.trim() + name.trim();
	      }
	    }

	    var file = {
	      name: name,
	      start: start,
	      size: size,
	      url: url
	    };

	    if (this._globalPaxHeader) {
	      this._globalPaxHeader.applyHeader(file);
	    }

	    if (this._paxHeader) {
	      this._paxHeader.applyHeader(file);

	      this._paxHeader = null;
	    }

	    return file;
	  };

	  UntarInternal.prototype.untar = function (filenamePrefix) {
	    if (!utfDecoder) {
	      console.error('Cannot untar because TextDecoder interface is not available for this platform.');
	      return [];
	    }

	    var files = [];

	    while (this._hasNext()) {
	      var file = this._readNextFile();

	      if (!file) continue;

	      if (filenamePrefix && file.name) {
	        file.name = filenamePrefix + file.name;
	      }

	      files.push(file);
	    }

	    return files;
	  };

	  if (isWorker) {
	    self.onmessage = function (e) {
	      var id = e.data.id;

	      try {
	        var archive = new UntarInternal(e.data.arrayBuffer);
	        var files = archive.untar(e.data.prefix);
	        postMessage({
	          id: id,
	          files: files,
	          arrayBuffer: e.data.arrayBuffer
	        }, [e.data.arrayBuffer]);
	      } catch (err) {
	        postMessage({
	          id: id,
	          error: err.toString()
	        });
	      }
	    };
	  }
	}

	var workerUrl = null;

	function getWorkerUrl() {
	  if (!workerUrl) {
	    var code = '(' + UntarScope.toString() + ')(true)\n\n';
	    var blob = new Blob([code], {
	      type: 'application/javascript'
	    });
	    workerUrl = URL.createObjectURL(blob);
	  }

	  return workerUrl;
	}

	var UntarWorker = function () {
	  function UntarWorker(filenamePrefix) {
	    this._requestId = 0;
	    this._pendingRequests = {};
	    this._filenamePrefix = filenamePrefix;
	    this._worker = new Worker(getWorkerUrl());

	    this._worker.addEventListener('message', this._onMessage.bind(this));
	  }

	  var _proto = UntarWorker.prototype;

	  _proto._onMessage = function _onMessage(e) {
	    var id = e.data.id;
	    if (!this._pendingRequests[id]) return;
	    var callback = this._pendingRequests[id];
	    delete this._pendingRequests[id];

	    if (e.data.error) {
	      callback(e.data.error);
	    } else {
	      var arrayBuffer = e.data.arrayBuffer;

	      for (var i = 0, len = e.data.files.length; i < len; i++) {
	        var file = e.data.files[i];
	        var blob = new Blob([arrayBuffer.slice(file.start, file.start + file.size)]);
	        file.url = URL.createObjectURL(blob);
	      }

	      callback(null, e.data.files);
	    }
	  };

	  _proto.untar = function untar(arrayBuffer, callback) {
	    var id = this._requestId++;
	    this._pendingRequests[id] = callback;

	    this._worker.postMessage({
	      id: id,
	      prefix: this._filenamePrefix,
	      arrayBuffer: arrayBuffer
	    }, [arrayBuffer]);
	  };

	  _proto.hasPendingRequests = function hasPendingRequests() {
	    return Object.keys(this._pendingRequests).length > 0;
	  };

	  _proto.destroy = function destroy() {
	    if (this._worker) {
	      this._worker.terminate();

	      this._worker = null;
	      this._pendingRequests = null;
	    }
	  };

	  return UntarWorker;
	}();

	UntarScope();

	var BundleHandler = function () {
	  function BundleHandler(app) {
	    this.handlerType = "bundle";
	    this._assets = app.assets;
	    this._worker = null;
	    this.maxRetries = 0;
	  }

	  var _proto = BundleHandler.prototype;

	  _proto.load = function load(url, callback) {
	    if (typeof url === 'string') {
	      url = {
	        load: url,
	        original: url
	      };
	    }

	    var self = this;
	    http.get(url.load, {
	      responseType: Http.ResponseType.ARRAY_BUFFER,
	      retry: this.maxRetries > 0,
	      maxRetries: this.maxRetries
	    }, function (err, response) {
	      if (!err) {
	        try {
	          self._untar(response, callback);
	        } catch (ex) {
	          callback('Error loading bundle resource ' + url.original + ': ' + ex);
	        }
	      } else {
	        callback('Error loading bundle resource ' + url.original + ': ' + err);
	      }
	    });
	  };

	  _proto._untar = function _untar(response, callback) {
	    var self = this;

	    if (platform.workers) {
	      if (!self._worker) {
	        self._worker = new UntarWorker(self._assets.prefix);
	      }

	      self._worker.untar(response, function (err, files) {
	        callback(err, files);

	        if (!self._worker.hasPendingRequests()) {
	          self._worker.destroy();

	          self._worker = null;
	        }
	      });
	    } else {
	      var archive = new Untar(response);
	      var files = archive.untar(self._assets.prefix);
	      callback(null, files);
	    }
	  };

	  _proto.open = function open(url, data) {
	    return new Bundle(data);
	  };

	  _proto.patch = function patch(asset, assets) {};

	  return BundleHandler;
	}();

	var ResourceLoader = function () {
	  function ResourceLoader(app) {
	    this._handlers = {};
	    this._requests = {};
	    this._cache = {};
	    this._app = app;
	  }

	  var _proto = ResourceLoader.prototype;

	  _proto.addHandler = function addHandler(type, handler) {
	    this._handlers[type] = handler;
	    handler._loader = this;
	  };

	  _proto.removeHandler = function removeHandler(type) {
	    delete this._handlers[type];
	  };

	  _proto.getHandler = function getHandler(type) {
	    return this._handlers[type];
	  };

	  _proto.load = function load(url, type, callback, asset) {
	    var handler = this._handlers[type];

	    if (!handler) {
	      var err = "No resource handler for asset type: '" + type + "' when loading [" + url + "]";
	      callback(err);
	      return;
	    }

	    if (!url) {
	      this._loadNull(handler, callback, asset);

	      return;
	    }

	    var key = url + type;

	    if (this._cache[key] !== undefined) {
	      callback(null, this._cache[key]);
	    } else if (this._requests[key]) {
	      this._requests[key].push(callback);
	    } else {
	      this._requests[key] = [callback];
	      var self = this;

	      var handleLoad = function handleLoad(err, urlObj) {
	        if (err) {
	          self._onFailure(key, err);

	          return;
	        }

	        handler.load(urlObj, function (err, data, extra) {
	          if (!self._requests[key]) {
	            return;
	          }

	          if (err) {
	            self._onFailure(key, err);

	            return;
	          }

	          try {
	            self._onSuccess(key, handler.open(urlObj.original, data, asset), extra);
	          } catch (e) {
	            self._onFailure(key, e);
	          }
	        }, asset);
	      };

	      var normalizedUrl = url.split('?')[0];

	      if (this._app.enableBundles && this._app.bundles.hasUrl(normalizedUrl)) {
	        if (!this._app.bundles.canLoadUrl(normalizedUrl)) {
	          handleLoad("Bundle for " + url + " not loaded yet");
	          return;
	        }

	        this._app.bundles.loadUrl(normalizedUrl, function (err, fileUrlFromBundle) {
	          handleLoad(err, {
	            load: fileUrlFromBundle,
	            original: normalizedUrl
	          });
	        });
	      } else {
	        handleLoad(null, {
	          load: url,
	          original: asset && asset.file.filename || url
	        });
	      }
	    }
	  };

	  _proto._loadNull = function _loadNull(handler, callback, asset) {
	    var onLoad = function onLoad(err, data, extra) {
	      if (err) {
	        callback(err);
	      } else {
	        try {
	          callback(null, handler.open(null, data, asset), extra);
	        } catch (e) {
	          callback(e);
	        }
	      }
	    };

	    handler.load(null, onLoad, asset);
	  };

	  _proto._onSuccess = function _onSuccess(key, result, extra) {
	    this._cache[key] = result;

	    for (var i = 0; i < this._requests[key].length; i++) {
	      this._requests[key][i](null, result, extra);
	    }

	    delete this._requests[key];
	  };

	  _proto._onFailure = function _onFailure(key, err) {
	    console.error(err);

	    if (this._requests[key]) {
	      for (var i = 0; i < this._requests[key].length; i++) {
	        this._requests[key][i](err);
	      }

	      delete this._requests[key];
	    }
	  };

	  _proto.open = function open(type, data) {
	    var handler = this._handlers[type];

	    if (!handler) {
	      console.warn('No resource handler found for: ' + type);
	      return data;
	    }

	    return handler.open(null, data);
	  };

	  _proto.patch = function patch(asset, assets) {
	    var handler = this._handlers[asset.type];

	    if (!handler) {
	      console.warn('No resource handler found for: ' + asset.type);
	      return;
	    }

	    if (handler.patch) {
	      handler.patch(asset, assets);
	    }
	  };

	  _proto.clearCache = function clearCache(url, type) {
	    delete this._cache[url + type];
	  };

	  _proto.getFromCache = function getFromCache(url, type) {
	    if (this._cache[url + type]) {
	      return this._cache[url + type];
	    }

	    return undefined;
	  };

	  _proto.enableRetry = function enableRetry(maxRetries) {
	    if (maxRetries === void 0) {
	      maxRetries = 5;
	    }

	    maxRetries = Math.max(0, maxRetries) || 0;

	    for (var key in this._handlers) {
	      this._handlers[key].maxRetries = maxRetries;
	    }
	  };

	  _proto.disableRetry = function disableRetry() {
	    for (var key in this._handlers) {
	      this._handlers[key].maxRetries = 0;
	    }
	  };

	  _proto.destroy = function destroy() {
	    this._handlers = {};
	    this._requests = {};
	    this._cache = {};
	  };

	  return ResourceLoader;
	}();

	var DEFAULT_LOCALE = 'en-US';
	var DEFAULT_LOCALE_FALLBACKS = {
	  'en': 'en-US',
	  'es': 'en-ES',
	  'zh': 'zh-CN',
	  'zh-HK': 'zh-TW',
	  'zh-TW': 'zh-HK',
	  'zh-MO': 'zh-HK',
	  'fr': 'fr-FR',
	  'de': 'de-DE',
	  'it': 'it-IT',
	  'ru': 'ru-RU',
	  'ja': 'ja-JP'
	};

	var PLURALS = {};

	function definePluralFn(locales, fn) {
	  for (var i = 0, len = locales.length; i < len; i++) {
	    PLURALS[locales[i]] = fn;
	  }
	}

	function getLang(locale) {
	  var idx = locale.indexOf('-');

	  if (idx !== -1) {
	    return locale.substring(0, idx);
	  }

	  return locale;
	}

	function replaceLang(locale, desiredLang) {
	  var idx = locale.indexOf('-');

	  if (idx !== -1) {
	    return desiredLang + locale.substring(idx);
	  }

	  return desiredLang;
	}

	function findAvailableLocale(desiredLocale, availableLocales) {
	  if (availableLocales[desiredLocale]) {
	    return desiredLocale;
	  }

	  var fallback = DEFAULT_LOCALE_FALLBACKS[desiredLocale];

	  if (fallback && availableLocales[fallback]) {
	    return fallback;
	  }

	  var lang = getLang(desiredLocale);
	  fallback = DEFAULT_LOCALE_FALLBACKS[lang];

	  if (availableLocales[fallback]) {
	    return fallback;
	  }

	  if (availableLocales[lang]) {
	    return lang;
	  }

	  return DEFAULT_LOCALE;
	}

	definePluralFn(['ja', 'ko', 'th', 'vi', 'zh', 'id'], function (n) {
	  return 0;
	});
	definePluralFn(['fa', 'hi'], function (n) {
	  if (n >= 0 && n <= 1) {
	    return 0;
	  }

	  return 1;
	});
	definePluralFn(['fr', 'pt'], function (n) {
	  if (n >= 0 && n < 2) {
	    return 0;
	  }

	  return 1;
	});
	definePluralFn(['da'], function (n) {
	  if (n === 1 || !Number.isInteger(n) && n >= 0 && n <= 1) {
	    return 0;
	  }

	  return 1;
	});
	definePluralFn(['de', 'en', 'it', 'el', 'es', 'tr', 'fi', 'sv', 'nb', 'no', 'ur'], function (n) {
	  if (n === 1) {
	    return 0;
	  }

	  return 1;
	});
	definePluralFn(['ru', 'uk'], function (n) {
	  if (Number.isInteger(n)) {
	    var mod10 = n % 10;
	    var mod100 = n % 100;

	    if (mod10 === 1 && mod100 !== 11) {
	      return 0;
	    } else if (mod10 >= 2 && mod10 <= 4 && (mod100 < 12 || mod100 > 14)) {
	      return 1;
	    } else if (mod10 === 0 || mod10 >= 5 && mod10 <= 9 || mod100 >= 11 && mod100 <= 14) {
	      return 2;
	    }
	  }

	  return 3;
	});
	definePluralFn(['pl'], function (n) {
	  if (Number.isInteger(n)) {
	    if (n === 1) {
	      return 0;
	    }

	    var mod10 = n % 10;
	    var mod100 = n % 100;

	    if (mod10 >= 2 && mod10 <= 4 && (mod100 < 12 || mod100 > 14)) {
	      return 1;
	    } else if (mod10 >= 0 && mod10 <= 1 || mod10 >= 5 && mod10 <= 9 || mod100 >= 12 && mod100 <= 14) {
	      return 2;
	    }
	  }

	  return 3;
	});
	definePluralFn(['ar'], function (n) {
	  if (n === 0) {
	    return 0;
	  } else if (n === 1) {
	    return 1;
	  } else if (n === 2) {
	    return 2;
	  }

	  if (Number.isInteger(n)) {
	    var mod100 = n % 100;

	    if (mod100 >= 3 && mod100 <= 10) {
	      return 3;
	    } else if (mod100 >= 11 && mod100 <= 99) {
	      return 4;
	    }
	  }

	  return 5;
	});
	var DEFAULT_PLURAL_FN = PLURALS[getLang(DEFAULT_LOCALE)];

	function getPluralFn(lang) {
	  return PLURALS[lang] || DEFAULT_PLURAL_FN;
	}

	var ABSOLUTE_URL = new RegExp('^' + '\\s*' + '(?:' + '(?:' + '[a-z]+[a-z0-9\\-\\+\\.]*' + ':' + ')?' + '//' + '|' + 'data:' + '|blob:' + ')', 'i');
	var ASSET_ANIMATION = 'animation';
	var ASSET_AUDIO = 'audio';
	var ASSET_IMAGE = 'image';
	var ASSET_JSON = 'json';
	var ASSET_MODEL = 'model';
	var ASSET_MATERIAL = 'material';
	var ASSET_TEXT = 'text';
	var ASSET_TEXTURE = 'texture';
	var ASSET_CUBEMAP = 'cubemap';
	var ASSET_SHADER = 'shader';
	var ASSET_CSS = 'css';
	var ASSET_HTML = 'html';
	var ASSET_SCRIPT = 'script';
	var ASSET_CONTAINER = 'container';

	var AssetFile = function () {
	  function AssetFile(url, filename, hash, size, opt, contents) {
	    this.url = url || '';
	    this.filename = filename || '';
	    this.hash = hash === undefined ? null : hash;
	    this.size = size === undefined ? null : size;
	    this.opt = opt === undefined ? null : opt;
	    this.contents = contents || null;
	  }

	  var _proto = AssetFile.prototype;

	  _proto.equals = function equals(other) {
	    return this.url === other.url && this.filename === other.filename && this.hash === other.hash && this.size === other.size && this.opt === other.opt && this.contents === other.contents;
	  };

	  return AssetFile;
	}();

	var assetIdCounter = -1;
	var VARIANT_SUPPORT = {
	  pvr: 'extCompressedTexturePVRTC',
	  dxt: 'extCompressedTextureS3TC',
	  etc2: 'extCompressedTextureETC',
	  etc1: 'extCompressedTextureETC1',
	  basis: 'canvas'
	};
	var VARIANT_DEFAULT_PRIORITY = ['pvr', 'dxt', 'etc2', 'etc1', 'basis'];

	var Asset = function (_EventHandler) {
	  _inheritsLoose(Asset, _EventHandler);

	  function Asset(name, type, file, data, options) {
	    var _this;

	    _this = _EventHandler.call(this) || this;
	    _this._id = assetIdCounter--;
	    _this.name = name || '';
	    _this.type = type;
	    _this.tags = new Tags(_assertThisInitialized(_this));
	    _this._preload = false;
	    _this._file = null;
	    _this._data = data || {};
	    _this.options = options || {};
	    _this._resources = [];
	    _this._i18n = {};
	    _this.loaded = false;
	    _this.loading = false;
	    _this.registry = null;
	    if (file) _this.file = file;
	    return _this;
	  }

	  var _proto = Asset.prototype;

	  _proto.getFileUrl = function getFileUrl() {
	    var file = this.file;
	    if (!file || !file.url) return null;
	    var url = file.url;
	    if (this.registry && this.registry.prefix && !ABSOLUTE_URL.test(url)) url = this.registry.prefix + url;

	    if (this.type !== 'script' && file.hash) {
	      var separator = url.indexOf('?') !== -1 ? '&' : '?';
	      url += separator + 't=' + file.hash;
	    }

	    return url;
	  };

	  _proto.getAbsoluteUrl = function getAbsoluteUrl(relativePath) {
	    if (relativePath.startsWith('blob:') || relativePath.startsWith('data:')) {
	      return relativePath;
	    }

	    var base = path.getDirectory(this.file.url);
	    return path.join(base, relativePath);
	  };

	  _proto.getLocalizedAssetId = function getLocalizedAssetId(locale) {
	    locale = findAvailableLocale(locale, this._i18n);
	    return this._i18n[locale] || null;
	  };

	  _proto.addLocalizedAssetId = function addLocalizedAssetId(locale, assetId) {
	    this._i18n[locale] = assetId;
	    this.fire('add:localized', locale, assetId);
	  };

	  _proto.removeLocalizedAssetId = function removeLocalizedAssetId(locale) {
	    var assetId = this._i18n[locale];

	    if (assetId) {
	      delete this._i18n[locale];
	      this.fire('remove:localized', locale, assetId);
	    }
	  };

	  _proto.ready = function ready(callback, scope) {
	    scope = scope || this;

	    if (this.loaded) {
	      callback.call(scope, this);
	    } else {
	      this.once('load', function (asset) {
	        callback.call(scope, asset);
	      });
	    }
	  };

	  _proto.reload = function reload() {
	    if (this.loaded) {
	      this.loaded = false;
	      this.registry.load(this);
	    }
	  };

	  _proto.unload = function unload() {
	    if (!this.loaded && this._resources.length === 0) return;
	    this.fire('unload', this);
	    this.registry.fire('unload:' + this.id, this);
	    var old = this._resources;
	    this.resources = [];
	    this.loaded = false;

	    if (this.file) {
	      this.registry._loader.clearCache(this.getFileUrl(), this.type);
	    }

	    for (var i = 0; i < old.length; ++i) {
	      var resource = old[i];

	      if (resource && resource.destroy) {
	        resource.destroy();
	      }
	    }
	  };

	  Asset.fetchArrayBuffer = function fetchArrayBuffer(loadUrl, callback, asset, maxRetries) {
	    var _asset$file;

	    if (maxRetries === void 0) {
	      maxRetries = 0;
	    }

	    if (asset != null && (_asset$file = asset.file) != null && _asset$file.contents) {
	      setTimeout(function () {
	        callback(null, asset.file.contents);
	      });
	    } else {
	      http.get(loadUrl, {
	        cache: true,
	        responseType: 'arraybuffer',
	        retry: maxRetries > 0,
	        maxRetries: maxRetries
	      }, callback);
	    }
	  };

	  _createClass(Asset, [{
	    key: "id",
	    get: function get() {
	      return this._id;
	    },
	    set: function set(value) {
	      this._id = value;
	    }
	  }, {
	    key: "file",
	    get: function get() {
	      return this._file;
	    },
	    set: function set(value) {
	      var _this2 = this;

	      if (value && value.variants && ['texture', 'textureatlas', 'bundle'].indexOf(this.type) !== -1) {
	        var _this$registry, _this$registry$_loade;

	        var app = ((_this$registry = this.registry) == null ? void 0 : (_this$registry$_loade = _this$registry._loader) == null ? void 0 : _this$registry$_loade._app) || getApplication();
	        var device = app == null ? void 0 : app.graphicsDevice;

	        if (device) {
	          var _loop = function _loop(i, len) {
	            var variant = VARIANT_DEFAULT_PRIORITY[i];

	            if (value.variants[variant] && device[VARIANT_SUPPORT[variant]]) {
	              value = value.variants[variant];
	              return "break";
	            }

	            if (app.enableBundles) {
	              var bundles = app.bundles.listBundlesForAsset(_this2);

	              if (bundles && bundles.find(function (b) {
	                var _b$file;

	                return b == null ? void 0 : (_b$file = b.file) == null ? void 0 : _b$file.variants[variant];
	              })) {
	                return "break";
	              }
	            }
	          };

	          for (var i = 0, len = VARIANT_DEFAULT_PRIORITY.length; i < len; i++) {
	            var _ret = _loop(i, len);

	            if (_ret === "break") break;
	          }
	        }
	      }

	      var oldFile = this._file;
	      var newFile = value ? new AssetFile(value.url, value.filename, value.hash, value.size, value.opt, value.contents) : null;

	      if (!!newFile !== !!oldFile || newFile && !newFile.equals(oldFile)) {
	        this._file = newFile;
	        this.fire('change', this, 'file', newFile, oldFile);
	        this.reload();
	      }
	    }
	  }, {
	    key: "data",
	    get: function get() {
	      return this._data;
	    },
	    set: function set(value) {
	      var old = this._data;
	      this._data = value;

	      if (value !== old) {
	        this.fire('change', this, 'data', value, old);
	        if (this.loaded) this.registry._loader.patch(this, this.registry);
	      }
	    }
	  }, {
	    key: "resource",
	    get: function get() {
	      return this._resources[0];
	    },
	    set: function set(value) {
	      var _old = this._resources[0];
	      this._resources[0] = value;
	      this.fire('change', this, 'resource', value, _old);
	    }
	  }, {
	    key: "resources",
	    get: function get() {
	      return this._resources;
	    },
	    set: function set(value) {
	      var _old = this._resources;
	      this._resources = value;
	      this.fire('change', this, 'resources', value, _old);
	    }
	  }, {
	    key: "preload",
	    get: function get() {
	      return this._preload;
	    },
	    set: function set(value) {
	      value = !!value;
	      if (this._preload === value) return;
	      this._preload = value;
	      if (this._preload && !this.loaded && !this.loading && this.registry) this.registry.load(this);
	    }
	  }, {
	    key: "loadFaces",
	    get: function get() {
	      return this._loadFaces;
	    },
	    set: function set(value) {
	      value = !!value;

	      if (!this.hasOwnProperty('_loadFaces') || value !== this._loadFaces) {
	        this._loadFaces = value;
	        if (this.loaded) this.registry._loader.patch(this, this.registry);
	      }
	    }
	  }]);

	  return Asset;
	}(EventHandler);

	var TagsCache = function () {
	  function TagsCache(key) {
	    if (key === void 0) {
	      key = null;
	    }

	    this._index = {};
	    this._key = key;
	  }

	  var _proto = TagsCache.prototype;

	  _proto.addItem = function addItem(item) {
	    var tags = item.tags._list;

	    for (var _iterator = _createForOfIteratorHelperLoose(tags), _step; !(_step = _iterator()).done;) {
	      var tag = _step.value;
	      this.add(tag, item);
	    }
	  };

	  _proto.removeItem = function removeItem(item) {
	    var tags = item.tags._list;

	    for (var _iterator2 = _createForOfIteratorHelperLoose(tags), _step2; !(_step2 = _iterator2()).done;) {
	      var tag = _step2.value;
	      this.remove(tag, item);
	    }
	  };

	  _proto.add = function add(tag, item) {
	    if (this._index[tag] && this._index[tag].list.indexOf(item) !== -1) return;

	    if (!this._index[tag]) {
	      this._index[tag] = {
	        list: []
	      };
	      if (this._key) this._index[tag].keys = {};
	    }

	    this._index[tag].list.push(item);

	    if (this._key) this._index[tag].keys[item[this._key]] = item;
	  };

	  _proto.remove = function remove(tag, item) {
	    if (!this._index[tag]) return;

	    if (this._key) {
	      if (!this._index[tag].keys[item[this._key]]) return;
	    }

	    var ind = this._index[tag].list.indexOf(item);

	    if (ind === -1) return;

	    this._index[tag].list.splice(ind, 1);

	    if (this._key) delete this._index[tag].keys[item[this._key]];
	    if (this._index[tag].list.length === 0) delete this._index[tag];
	  };

	  _proto.find = function find(args) {
	    var _this = this;

	    var index = {};
	    var items = [];
	    var item, tag, tags, tagsRest, missingIndex;

	    var sort = function sort(a, b) {
	      return _this._index[a].list.length - _this._index[b].list.length;
	    };

	    for (var i = 0; i < args.length; i++) {
	      tag = args[i];

	      if (tag instanceof Array) {
	        if (tag.length === 0) continue;

	        if (tag.length === 1) {
	          tag = tag[0];
	        } else {
	          missingIndex = false;

	          for (var t = 0; t < tag.length; t++) {
	            if (!this._index[tag[t]]) {
	              missingIndex = true;
	              break;
	            }
	          }

	          if (missingIndex) continue;
	          tags = tag.slice(0).sort(sort);
	          tagsRest = tags.slice(1);
	          if (tagsRest.length === 1) tagsRest = tagsRest[0];

	          for (var n = 0; n < this._index[tags[0]].list.length; n++) {
	            item = this._index[tags[0]].list[n];

	            if ((this._key ? !index[item[this._key]] : items.indexOf(item) === -1) && item.tags.has(tagsRest)) {
	              if (this._key) index[item[this._key]] = true;
	              items.push(item);
	            }
	          }

	          continue;
	        }
	      }

	      if (tag && typeof tag === 'string' && this._index[tag]) {
	        for (var _n = 0; _n < this._index[tag].list.length; _n++) {
	          item = this._index[tag].list[_n];

	          if (this._key) {
	            if (!index[item[this._key]]) {
	              index[item[this._key]] = true;
	              items.push(item);
	            }
	          } else if (items.indexOf(item) === -1) {
	            items.push(item);
	          }
	        }
	      }
	    }

	    return items;
	  };

	  return TagsCache;
	}();

	var ScriptHandler = function () {
	  function ScriptHandler(app) {
	    this.handlerType = "script";
	    this._app = app;
	    this._scripts = {};
	    this._cache = {};
	  }

	  ScriptHandler._push = function _push(Type) {
	    if (script.legacy && ScriptHandler._types.length > 0) {
	      console.assert('Script Ordering Error. Contact support@playcanvas.com');
	    } else {
	      ScriptHandler._types.push(Type);
	    }
	  };

	  var _proto = ScriptHandler.prototype;

	  _proto.load = function load(url, callback) {
	    var _this = this;

	    if (typeof url === 'string') {
	      url = {
	        load: url,
	        original: url
	      };
	    }

	    var self = this;
	    script.app = this._app;

	    this._loadScript(url.load, function (err, url, extra) {
	      if (!err) {
	        if (script.legacy) {
	          var Type = null;

	          if (ScriptHandler._types.length) {
	            Type = ScriptHandler._types.pop();
	          }

	          if (Type) {
	            _this._scripts[url] = Type;
	          } else {
	            Type = null;
	          }

	          callback(null, Type, extra);
	        } else {
	          var obj = {};

	          for (var i = 0; i < ScriptHandler._types.length; i++) {
	            obj[ScriptHandler._types[i].name] = ScriptHandler._types[i];
	          }

	          ScriptHandler._types.length = 0;
	          callback(null, obj, extra);
	          delete self._loader._cache[url + 'script'];
	        }
	      } else {
	        callback(err);
	      }
	    });
	  };

	  _proto.open = function open(url, data) {
	    return data;
	  };

	  _proto.patch = function patch(asset, assets) {};

	  _proto._loadScript = function _loadScript(url, callback) {
	    var head = document.head;
	    var element = document.createElement('script');
	    this._cache[url] = element;
	    element.async = false;
	    element.addEventListener('error', function (e) {
	      callback("Script: " + e.target.src + " failed to load");
	    }, false);
	    var done = false;

	    element.onload = element.onreadystatechange = function () {
	      if (!done && (!this.readyState || this.readyState === 'loaded' || this.readyState === 'complete')) {
	        done = true;
	        callback(null, url, element);
	      }
	    };

	    element.src = url;
	    head.appendChild(element);
	  };

	  return ScriptHandler;
	}();

	ScriptHandler._types = [];

	var _legacy = false;
	var _createdLoadingScreen = false;
	var script = {
	  app: null,
	  create: function create(name, callback) {
	    if (!_legacy) return;
	    var ScriptType = callback(script.app);
	    ScriptType._pcScriptName = name;

	    ScriptHandler._push(ScriptType);

	    this.fire("created", name, callback);
	  },
	  attribute: function attribute(name, type, defaultValue, options) {},
	  createLoadingScreen: function createLoadingScreen(callback) {
	    if (_createdLoadingScreen) return;
	    _createdLoadingScreen = true;
	    var app = getApplication();
	    callback(app);
	  }
	};
	Object.defineProperty(script, 'legacy', {
	  get: function get() {
	    return _legacy;
	  },
	  set: function set(value) {
	    _legacy = value;
	  }
	});
	events.attach(script);

	var AssetRegistry = function (_EventHandler) {
	  _inheritsLoose(AssetRegistry, _EventHandler);

	  function AssetRegistry(loader) {
	    var _this;

	    _this = _EventHandler.call(this) || this;
	    _this._loader = loader;
	    _this._assets = [];
	    _this._cache = {};
	    _this._names = {};
	    _this._tags = new TagsCache('_id');
	    _this._urls = {};
	    _this.prefix = null;
	    return _this;
	  }

	  var _proto = AssetRegistry.prototype;

	  _proto.list = function list(filters) {
	    filters = filters || {};
	    return this._assets.filter(function (asset) {
	      var include = true;

	      if (filters.preload !== undefined) {
	        include = asset.preload === filters.preload;
	      }

	      return include;
	    });
	  };

	  _proto.add = function add(asset) {
	    var index = this._assets.push(asset) - 1;
	    var url;
	    this._cache[asset.id] = index;
	    if (!this._names[asset.name]) this._names[asset.name] = [];

	    this._names[asset.name].push(index);

	    if (asset.file) {
	      url = asset.file.url;
	      this._urls[url] = index;
	    }

	    asset.registry = this;

	    this._tags.addItem(asset);

	    asset.tags.on('add', this._onTagAdd, this);
	    asset.tags.on('remove', this._onTagRemove, this);
	    this.fire('add', asset);
	    this.fire('add:' + asset.id, asset);
	    if (url) this.fire('add:url:' + url, asset);
	    if (asset.preload) this.load(asset);
	  };

	  _proto.remove = function remove(asset) {
	    var idx = this._cache[asset.id];
	    var url = asset.file ? asset.file.url : null;

	    if (idx !== undefined) {
	      this._assets.splice(idx, 1);

	      delete this._cache[asset.id];
	      this._names = {};
	      this._urls = [];

	      for (var i = 0, l = this._assets.length; i < l; i++) {
	        var a = this._assets[i];
	        this._cache[a.id] = i;

	        if (!this._names[a.name]) {
	          this._names[a.name] = [];
	        }

	        this._names[a.name].push(i);

	        if (a.file) {
	          this._urls[a.file.url] = i;
	        }
	      }

	      this._tags.removeItem(asset);

	      asset.tags.off('add', this._onTagAdd, this);
	      asset.tags.off('remove', this._onTagRemove, this);
	      asset.fire('remove', asset);
	      this.fire('remove', asset);
	      this.fire('remove:' + asset.id, asset);
	      if (url) this.fire('remove:url:' + url, asset);
	      return true;
	    }

	    return false;
	  };

	  _proto.get = function get(id) {
	    var idx = this._cache[id];
	    return this._assets[idx];
	  };

	  _proto.getByUrl = function getByUrl(url) {
	    var idx = this._urls[url];
	    return this._assets[idx];
	  };

	  _proto.load = function load(asset) {
	    var _this2 = this;

	    if (asset.loading || asset.loaded) {
	      return;
	    }

	    var file = asset.file;

	    var _opened = function _opened(resource) {
	      if (resource instanceof Array) {
	        asset.resources = resource;
	      } else {
	        asset.resource = resource;
	      }

	      _this2._loader.patch(asset, _this2);

	      _this2.fire('load', asset);

	      _this2.fire('load:' + asset.id, asset);

	      if (file && file.url) _this2.fire('load:url:' + file.url, asset);
	      asset.fire('load', asset);
	    };

	    var _loaded = function _loaded(err, resource, extra) {
	      asset.loaded = true;
	      asset.loading = false;

	      if (err) {
	        _this2.fire('error', err, asset);

	        _this2.fire('error:' + asset.id, err, asset);

	        asset.fire('error', err, asset);
	      } else {
	        if (!script.legacy && asset.type === 'script') {
	          var handler = _this2._loader.getHandler('script');

	          if (handler._cache[asset.id] && handler._cache[asset.id].parentNode === document.head) {
	            document.head.removeChild(handler._cache[asset.id]);
	          }

	          handler._cache[asset.id] = extra;
	        }

	        _opened(resource);
	      }
	    };

	    if (file || asset.type === 'cubemap') {
	      this.fire('load:start', asset);
	      this.fire('load:' + asset.id + ':start', asset);
	      asset.loading = true;

	      this._loader.load(asset.getFileUrl(), asset.type, _loaded, asset);
	    } else {
	      var resource = this._loader.open(asset.type, asset.data);

	      asset.loaded = true;

	      _opened(resource);
	    }
	  };

	  _proto.loadFromUrl = function loadFromUrl(url, type, callback) {
	    this.loadFromUrlAndFilename(url, null, type, callback);
	  };

	  _proto.loadFromUrlAndFilename = function loadFromUrlAndFilename(url, filename, type, callback) {
	    var _this3 = this;

	    var name = path.getBasename(filename || url);
	    var file = {
	      filename: filename || name,
	      url: url
	    };
	    var asset = this.getByUrl(url);

	    if (!asset) {
	      asset = new Asset(name, type, file);
	      this.add(asset);
	    } else if (asset.loaded) {
	      callback(asset.loadFromUrlError || null, asset);
	      return;
	    }

	    var startLoad = function startLoad(asset) {
	      asset.once('load', function (loadedAsset) {
	        if (type === 'material') {
	          _this3._loadTextures(loadedAsset, function (err, textures) {
	            callback(err, loadedAsset);
	          });
	        } else {
	          callback(null, loadedAsset);
	        }
	      });
	      asset.once('error', function (err) {
	        if (err) {
	          _this3.loadFromUrlError = err;
	        }

	        callback(err, asset);
	      });

	      _this3.load(asset);
	    };

	    if (asset.resource) {
	      callback(null, asset);
	    } else if (type === 'model') {
	      this._loadModel(asset, startLoad);
	    } else {
	      startLoad(asset);
	    }
	  };

	  _proto._loadModel = function _loadModel(modelAsset, continuation) {
	    var _this4 = this;

	    var url = modelAsset.getFileUrl();
	    var ext = path.getExtension(url);

	    if (ext === '.json' || ext === '.glb') {
	      var dir = path.getDirectory(url);
	      var basename = path.getBasename(url);
	      var mappingUrl = path.join(dir, basename.replace(ext, '.mapping.json'));

	      this._loader.load(mappingUrl, 'json', function (err, data) {
	        if (err) {
	          modelAsset.data = {
	            mapping: []
	          };
	          continuation(modelAsset);
	        } else {
	          _this4._loadMaterials(modelAsset, data, function (e, materials) {
	            modelAsset.data = data;
	            continuation(modelAsset);
	          });
	        }
	      });
	    } else {
	      continuation(modelAsset);
	    }
	  };

	  _proto._loadMaterials = function _loadMaterials(modelAsset, mapping, callback) {
	    var _this5 = this;

	    var materials = [];
	    var count = 0;

	    var onMaterialLoaded = function onMaterialLoaded(err, materialAsset) {
	      _this5._loadTextures(materialAsset, function (err, textures) {
	        materials.push(materialAsset);

	        if (materials.length === count) {
	          callback(null, materials);
	        }
	      });
	    };

	    for (var i = 0; i < mapping.mapping.length; i++) {
	      var _path = mapping.mapping[i].path;

	      if (_path) {
	        count++;
	        var url = modelAsset.getAbsoluteUrl(_path);
	        this.loadFromUrl(url, 'material', onMaterialLoaded);
	      }
	    }

	    if (count === 0) {
	      callback(null, materials);
	    }
	  };

	  _proto._loadTextures = function _loadTextures(materialAsset, callback) {
	    var textures = [];
	    var count = 0;
	    var data = materialAsset.data;

	    if (data.mappingFormat !== 'path') {
	      callback(null, textures);
	      return;
	    }

	    var onTextureLoaded = function onTextureLoaded(err, texture) {
	      if (err) console.error(err);
	      textures.push(texture);

	      if (textures.length === count) {
	        callback(null, textures);
	      }
	    };

	    var texParams = standardMaterialTextureParameters;

	    for (var i = 0; i < texParams.length; i++) {
	      var _path2 = data[texParams[i]];

	      if (_path2 && typeof _path2 === 'string') {
	        count++;
	        var url = materialAsset.getAbsoluteUrl(_path2);
	        this.loadFromUrl(url, 'texture', onTextureLoaded);
	      }
	    }

	    if (count === 0) {
	      callback(null, textures);
	    }
	  };

	  _proto.findAll = function findAll(name, type) {
	    var _this6 = this;

	    var idxs = this._names[name];

	    if (idxs) {
	      var assets = idxs.map(function (idx) {
	        return _this6._assets[idx];
	      });

	      if (type) {
	        return assets.filter(function (asset) {
	          return asset.type === type;
	        });
	      }

	      return assets;
	    }

	    return [];
	  };

	  _proto._onTagAdd = function _onTagAdd(tag, asset) {
	    this._tags.add(tag, asset);
	  };

	  _proto._onTagRemove = function _onTagRemove(tag, asset) {
	    this._tags.remove(tag, asset);
	  };

	  _proto.findByTag = function findByTag() {
	    return this._tags.find(arguments);
	  };

	  _proto.filter = function filter(callback) {
	    return this._assets.filter(function (asset) {
	      return callback(asset);
	    });
	  };

	  _proto.find = function find(name, type) {
	    var asset = this.findAll(name, type);
	    return asset.length > 0 ? asset[0] : null;
	  };

	  return AssetRegistry;
	}(EventHandler);

	var BundleRegistry = function () {
	  function BundleRegistry(assets) {
	    this._assets = assets;
	    this._bundleAssets = {};
	    this._assetsInBundles = {};
	    this._urlsInBundles = {};
	    this._fileRequests = {};

	    this._assets.on('add', this._onAssetAdded, this);

	    this._assets.on('remove', this._onAssetRemoved, this);
	  }

	  var _proto = BundleRegistry.prototype;

	  _proto._onAssetAdded = function _onAssetAdded(asset) {
	    if (asset.type === 'bundle') {
	      this._bundleAssets[asset.id] = asset;

	      this._registerBundleEventListeners(asset.id);

	      for (var i = 0, len = asset.data.assets.length; i < len; i++) {
	        this._indexAssetInBundle(asset.data.assets[i], asset);
	      }
	    } else {
	      if (this._assetsInBundles[asset.id]) {
	        this._indexAssetFileUrls(asset);
	      }
	    }
	  };

	  _proto._registerBundleEventListeners = function _registerBundleEventListeners(bundleAssetId) {
	    this._assets.on('load:' + bundleAssetId, this._onBundleLoaded, this);

	    this._assets.on('error:' + bundleAssetId, this._onBundleError, this);
	  };

	  _proto._unregisterBundleEventListeners = function _unregisterBundleEventListeners(bundleAssetId) {
	    this._assets.off('load:' + bundleAssetId, this._onBundleLoaded, this);

	    this._assets.off('error:' + bundleAssetId, this._onBundleError, this);
	  };

	  _proto._indexAssetInBundle = function _indexAssetInBundle(assetId, bundleAsset) {
	    if (!this._assetsInBundles[assetId]) {
	      this._assetsInBundles[assetId] = [bundleAsset];
	    } else {
	      var bundles = this._assetsInBundles[assetId];
	      var idx = bundles.indexOf(bundleAsset);

	      if (idx === -1) {
	        bundles.push(bundleAsset);
	      }
	    }

	    var asset = this._assets.get(assetId);

	    if (asset) {
	      this._indexAssetFileUrls(asset);
	    }
	  };

	  _proto._indexAssetFileUrls = function _indexAssetFileUrls(asset) {
	    var urls = this._getAssetFileUrls(asset);

	    if (!urls) return;

	    for (var i = 0, len = urls.length; i < len; i++) {
	      var url = urls[i];
	      this._urlsInBundles[url] = this._assetsInBundles[asset.id];
	    }
	  };

	  _proto._getAssetFileUrls = function _getAssetFileUrls(asset) {
	    var url = asset.getFileUrl();
	    if (!url) return null;
	    url = this._normalizeUrl(url);
	    var urls = [url];

	    if (asset.type === 'font') {
	      var numFiles = asset.data.info.maps.length;

	      for (var i = 1; i < numFiles; i++) {
	        urls.push(url.replace('.png', i + '.png'));
	      }
	    }

	    return urls;
	  };

	  _proto._normalizeUrl = function _normalizeUrl(url) {
	    return url && url.split('?')[0];
	  };

	  _proto._onAssetRemoved = function _onAssetRemoved(asset) {
	    if (asset.type === 'bundle') {
	      delete this._bundleAssets[asset.id];

	      this._unregisterBundleEventListeners(asset.id);

	      for (var id in this._assetsInBundles) {
	        var array = this._assetsInBundles[id];
	        var idx = array.indexOf(asset);

	        if (idx !== -1) {
	          array.splice(idx, 1);

	          if (!array.length) {
	            delete this._assetsInBundles[id];

	            for (var url in this._urlsInBundles) {
	              if (this._urlsInBundles[url] === array) {
	                delete this._urlsInBundles[url];
	              }
	            }
	          }
	        }
	      }

	      this._onBundleError("Bundle " + asset.id + " was removed", asset);
	    } else if (this._assetsInBundles[asset.id]) {
	      delete this._assetsInBundles[asset.id];

	      var urls = this._getAssetFileUrls(asset);

	      for (var i = 0, len = urls.length; i < len; i++) {
	        delete this._urlsInBundles[urls[i]];
	      }
	    }
	  };

	  _proto._onBundleLoaded = function _onBundleLoaded(bundleAsset) {
	    var _this = this;

	    if (!bundleAsset.resource) {
	      this._onBundleError("Bundle " + bundleAsset.id + " failed to load", bundleAsset);

	      return;
	    }

	    requestAnimationFrame(function () {
	      if (!_this._fileRequests) {
	        return;
	      }

	      for (var url in _this._fileRequests) {
	        var bundles = _this._urlsInBundles[url];
	        if (!bundles || bundles.indexOf(bundleAsset) === -1) continue;
	        var decodedUrl = decodeURIComponent(url);
	        var err = null;

	        if (!bundleAsset.resource.hasBlobUrl(decodedUrl)) {
	          err = "Bundle " + bundleAsset.id + " does not contain URL " + url;
	        }

	        var requests = _this._fileRequests[url];

	        for (var i = 0, len = requests.length; i < len; i++) {
	          if (err) {
	            requests[i](err);
	          } else {
	            requests[i](null, bundleAsset.resource.getBlobUrl(decodedUrl));
	          }
	        }

	        delete _this._fileRequests[url];
	      }
	    });
	  };

	  _proto._onBundleError = function _onBundleError(err, bundleAsset) {
	    for (var url in this._fileRequests) {
	      var bundle = this._findLoadedOrLoadingBundleForUrl(url);

	      if (!bundle) {
	        var requests = this._fileRequests[url];

	        for (var i = 0, len = requests.length; i < len; i++) {
	          requests[i](err);
	        }

	        delete this._fileRequests[url];
	      }
	    }
	  };

	  _proto._findLoadedOrLoadingBundleForUrl = function _findLoadedOrLoadingBundleForUrl(url) {
	    var bundles = this._urlsInBundles[url];
	    if (!bundles) return null;
	    var len = bundles.length;

	    for (var i = 0; i < len; i++) {
	      if (bundles[i].loaded && bundles[i].resource) {
	        return bundles[i];
	      }
	    }

	    for (var _i = 0; _i < len; _i++) {
	      if (bundles[_i].loading) {
	        return bundles[_i];
	      }
	    }

	    return null;
	  };

	  _proto.listBundlesForAsset = function listBundlesForAsset(asset) {
	    return this._assetsInBundles[asset.id] || null;
	  };

	  _proto.list = function list() {
	    var result = [];

	    for (var id in this._bundleAssets) {
	      result.push(this._bundleAssets[id]);
	    }

	    return result;
	  };

	  _proto.hasUrl = function hasUrl(url) {
	    return !!this._urlsInBundles[url];
	  };

	  _proto.canLoadUrl = function canLoadUrl(url) {
	    return !!this._findLoadedOrLoadingBundleForUrl(url);
	  };

	  _proto.loadUrl = function loadUrl(url, callback) {
	    var bundle = this._findLoadedOrLoadingBundleForUrl(url);

	    if (!bundle) {
	      callback("URL " + url + " not found in any bundles");
	      return;
	    }

	    if (bundle.loaded) {
	      var decodedUrl = decodeURIComponent(url);

	      if (!bundle.resource.hasBlobUrl(decodedUrl)) {
	        callback("Bundle " + bundle.id + " does not contain URL " + url);
	        return;
	      }

	      callback(null, bundle.resource.getBlobUrl(decodedUrl));
	    } else if (this._fileRequests.hasOwnProperty(url)) {
	      this._fileRequests[url].push(callback);
	    } else {
	      this._fileRequests[url] = [callback];
	    }
	  };

	  _proto.destroy = function destroy() {
	    this._assets.off('add', this._onAssetAdded, this);

	    this._assets.off('remove', this._onAssetRemoved, this);

	    for (var id in this._bundleAssets) {
	      this._unregisterBundleEventListeners(id);
	    }

	    this._assets = null;
	    this._bundleAssets = null;
	    this._assetsInBundles = null;
	    this._urlsInBundles = null;
	    this._fileRequests = null;
	  };

	  return BundleRegistry;
	}();

	var components = ['x', 'y', 'z', 'w'];
	var vecLookup = [undefined, undefined, Vec2, Vec3, Vec4];

	function rawToValue(app, args, value, old) {
	  switch (args.type) {
	    case 'boolean':
	      return !!value;

	    case 'number':
	      if (typeof value === 'number') {
	        return value;
	      } else if (typeof value === 'string') {
	        var v = parseInt(value, 10);
	        if (isNaN(v)) return null;
	        return v;
	      } else if (typeof value === 'boolean') {
	        return 0 + value;
	      }

	      return null;

	    case 'json':
	      {
	        var result = {};

	        if (Array.isArray(args.schema)) {
	          if (!value || typeof value !== 'object') {
	            value = {};
	          }

	          for (var i = 0; i < args.schema.length; i++) {
	            var field = args.schema[i];
	            if (!field.name) continue;

	            if (field.array) {
	              result[field.name] = [];
	              var arr = Array.isArray(value[field.name]) ? value[field.name] : [];

	              for (var j = 0; j < arr.length; j++) {
	                result[field.name].push(rawToValue(app, field, arr[j]));
	              }
	            } else {
	              var val = value.hasOwnProperty(field.name) ? value[field.name] : field.default;
	              result[field.name] = rawToValue(app, field, val);
	            }
	          }
	        }

	        return result;
	      }

	    case 'asset':
	      if (value instanceof Asset) {
	        return value;
	      } else if (typeof value === 'number') {
	        return app.assets.get(value) || null;
	      } else if (typeof value === 'string') {
	        return app.assets.get(parseInt(value, 10)) || null;
	      }

	      return null;

	    case 'entity':
	      if (value instanceof GraphNode) {
	        return value;
	      } else if (typeof value === 'string') {
	        return app.getEntityFromIndex(value);
	      }

	      return null;

	    case 'rgb':
	    case 'rgba':
	      if (value instanceof Color) {
	        if (old instanceof Color) {
	          old.copy(value);
	          return old;
	        }

	        return value.clone();
	      } else if (value instanceof Array && value.length >= 3 && value.length <= 4) {
	        for (var _i = 0; _i < value.length; _i++) {
	          if (typeof value[_i] !== 'number') return null;
	        }

	        if (!old) old = new Color();
	        old.r = value[0];
	        old.g = value[1];
	        old.b = value[2];
	        old.a = value.length === 3 ? 1 : value[3];
	        return old;
	      } else if (typeof value === 'string' && /#([0-9abcdef]{2}){3,4}/i.test(value)) {
	        if (!old) old = new Color();
	        old.fromString(value);
	        return old;
	      }

	      return null;

	    case 'vec2':
	    case 'vec3':
	    case 'vec4':
	      {
	        var len = parseInt(args.type.slice(3), 10);
	        var vecType = vecLookup[len];

	        if (value instanceof vecType) {
	          if (old instanceof vecType) {
	            old.copy(value);
	            return old;
	          }

	          return value.clone();
	        } else if (value instanceof Array && value.length === len) {
	          for (var _i2 = 0; _i2 < value.length; _i2++) {
	            if (typeof value[_i2] !== 'number') return null;
	          }

	          if (!old) old = new vecType();

	          for (var _i3 = 0; _i3 < len; _i3++) {
	            old[components[_i3]] = value[_i3];
	          }

	          return old;
	        }

	        return null;
	      }

	    case 'curve':
	      if (value) {
	        var curve;

	        if (value instanceof Curve || value instanceof CurveSet) {
	          curve = value.clone();
	        } else {
	          var CurveType = value.keys[0] instanceof Array ? CurveSet : Curve;
	          curve = new CurveType(value.keys);
	          curve.type = value.type;
	        }

	        return curve;
	      }

	      break;
	  }

	  return value;
	}

	var ScriptAttributes = function () {
	  function ScriptAttributes(scriptType) {
	    this.scriptType = scriptType;
	    this.index = {};
	  }

	  var _proto = ScriptAttributes.prototype;

	  _proto.add = function add(name, args) {
	    if (this.index[name]) {
	      return;
	    } else if (ScriptAttributes.reservedNames.has(name)) {
	      return;
	    }

	    this.index[name] = args;
	    Object.defineProperty(this.scriptType.prototype, name, {
	      get: function get() {
	        return this.__attributes[name];
	      },
	      set: function set(raw) {
	        var evt = 'attr';
	        var evtName = 'attr:' + name;
	        var old = this.__attributes[name];
	        var oldCopy = old;

	        if (old && args.type !== 'json' && old.clone) {
	          if (this._callbacks[evt] || this._callbacks[evtName]) {
	            oldCopy = old.clone();
	          }
	        }

	        if (args.array) {
	          this.__attributes[name] = [];

	          if (raw) {
	            for (var i = 0, len = raw.length; i < len; i++) {
	              this.__attributes[name].push(rawToValue(this.app, args, raw[i], old ? old[i] : null));
	            }
	          }
	        } else {
	          this.__attributes[name] = rawToValue(this.app, args, raw, old);
	        }

	        this.fire(evt, name, this.__attributes[name], oldCopy);
	        this.fire(evtName, this.__attributes[name], oldCopy);
	      }
	    });
	  };

	  _proto.remove = function remove(name) {
	    if (!this.index[name]) return false;
	    delete this.index[name];
	    delete this.scriptType.prototype[name];
	    return true;
	  };

	  _proto.has = function has(name) {
	    return !!this.index[name];
	  };

	  _proto.get = function get(name) {
	    return this.index[name] || null;
	  };

	  return ScriptAttributes;
	}();

	ScriptAttributes.reservedNames = new Set(['app', 'entity', 'enabled', '_enabled', '_enabledOld', '_destroyed', '__attributes', '__attributesRaw', '__scriptType', '__executionOrder', '_callbacks', 'has', 'get', 'on', 'off', 'fire', 'once', 'hasEvent']);

	var Component = function (_EventHandler) {
	  _inheritsLoose(Component, _EventHandler);

	  function Component(system, entity) {
	    var _this;

	    _this = _EventHandler.call(this) || this;
	    _this.system = void 0;
	    _this.entity = void 0;
	    _this.system = system;
	    _this.entity = entity;

	    if (_this.system.schema && !_this._accessorsBuilt) {
	      _this.buildAccessors(_this.system.schema);
	    }

	    _this.on('set', function (name, oldValue, newValue) {
	      this.fire('set_' + name, name, oldValue, newValue);
	    });

	    _this.on('set_enabled', _this.onSetEnabled, _assertThisInitialized(_this));

	    return _this;
	  }

	  Component._buildAccessors = function _buildAccessors(obj, schema) {
	    schema.forEach(function (descriptor) {
	      var name = typeof descriptor === 'object' ? descriptor.name : descriptor;
	      Object.defineProperty(obj, name, {
	        get: function get() {
	          return this.data[name];
	        },
	        set: function set(value) {
	          var data = this.data;
	          var oldValue = data[name];
	          data[name] = value;
	          this.fire('set', name, oldValue, value);
	        },
	        configurable: true
	      });
	    });
	    obj._accessorsBuilt = true;
	  };

	  var _proto = Component.prototype;

	  _proto.buildAccessors = function buildAccessors(schema) {
	    Component._buildAccessors(this, schema);
	  };

	  _proto.onSetEnabled = function onSetEnabled(name, oldValue, newValue) {
	    if (oldValue !== newValue) {
	      if (this.entity.enabled) {
	        if (newValue) {
	          this.onEnable();
	        } else {
	          this.onDisable();
	        }
	      }
	    }
	  };

	  _proto.onEnable = function onEnable() {};

	  _proto.onDisable = function onDisable() {};

	  _proto.onPostStateChange = function onPostStateChange() {};

	  _createClass(Component, [{
	    key: "data",
	    get: function get() {
	      var record = this.system.store[this.entity.getGuid()];
	      return record ? record.data : null;
	    }
	  }]);

	  return Component;
	}(EventHandler);

	var ScriptComponent = function (_Component) {
	  _inheritsLoose(ScriptComponent, _Component);

	  function ScriptComponent(system, entity) {
	    var _this;

	    _this = _Component.call(this, system, entity) || this;
	    _this._scripts = [];
	    _this._updateList = new SortedLoopArray({
	      sortBy: '__executionOrder'
	    });
	    _this._postUpdateList = new SortedLoopArray({
	      sortBy: '__executionOrder'
	    });
	    _this._scriptsIndex = {};
	    _this._destroyedScripts = [];
	    _this._destroyed = false;
	    _this._scriptsData = null;
	    _this._oldState = true;
	    _this._enabled = true;
	    _this._beingEnabled = false;
	    _this._isLoopingThroughScripts = false;
	    _this._executionOrder = -1;

	    _this.on('set_enabled', _this._onSetEnabled, _assertThisInitialized(_this));

	    return _this;
	  }

	  var _proto = ScriptComponent.prototype;

	  _proto.onEnable = function onEnable() {
	    this._beingEnabled = true;

	    this._checkState();

	    if (!this.entity._beingEnabled) {
	      this.onPostStateChange();
	    }

	    this._beingEnabled = false;
	  };

	  _proto.onDisable = function onDisable() {
	    this._checkState();
	  };

	  _proto.onPostStateChange = function onPostStateChange() {
	    var wasLooping = this._beginLooping();

	    for (var i = 0, len = this.scripts.length; i < len; i++) {
	      var script = this.scripts[i];

	      if (script._initialized && !script._postInitialized && script.enabled) {
	        script._postInitialized = true;
	        if (script.postInitialize) this._scriptMethod(script, ScriptComponent.scriptMethods.postInitialize);
	      }
	    }

	    this._endLooping(wasLooping);
	  };

	  _proto._beginLooping = function _beginLooping() {
	    var looping = this._isLoopingThroughScripts;
	    this._isLoopingThroughScripts = true;
	    return looping;
	  };

	  _proto._endLooping = function _endLooping(wasLoopingBefore) {
	    this._isLoopingThroughScripts = wasLoopingBefore;

	    if (!this._isLoopingThroughScripts) {
	      this._removeDestroyedScripts();
	    }
	  };

	  _proto._onSetEnabled = function _onSetEnabled(prop, old, value) {
	    this._beingEnabled = true;

	    this._checkState();

	    this._beingEnabled = false;
	  };

	  _proto._checkState = function _checkState() {
	    var state = this.enabled && this.entity.enabled;
	    if (state === this._oldState) return;
	    this._oldState = state;
	    this.fire(state ? 'enable' : 'disable');
	    this.fire('state', state);

	    if (state) {
	      this.system._addComponentToEnabled(this);
	    } else {
	      this.system._removeComponentFromEnabled(this);
	    }

	    var wasLooping = this._beginLooping();

	    for (var i = 0, len = this.scripts.length; i < len; i++) {
	      var script = this.scripts[i];
	      script.enabled = script._enabled;
	    }

	    this._endLooping(wasLooping);
	  };

	  _proto._onBeforeRemove = function _onBeforeRemove() {
	    this.fire('remove');

	    var wasLooping = this._beginLooping();

	    for (var i = 0; i < this.scripts.length; i++) {
	      var script = this.scripts[i];
	      if (!script) continue;
	      this.destroy(script.__scriptType.__name);
	    }

	    this._endLooping(wasLooping);
	  };

	  _proto._removeDestroyedScripts = function _removeDestroyedScripts() {
	    var len = this._destroyedScripts.length;
	    if (!len) return;

	    for (var i = 0; i < len; i++) {
	      var script = this._destroyedScripts[i];

	      this._removeScriptInstance(script);
	    }

	    this._destroyedScripts.length = 0;

	    this._resetExecutionOrder(0, this._scripts.length);
	  };

	  _proto._onInitializeAttributes = function _onInitializeAttributes() {
	    for (var i = 0, len = this.scripts.length; i < len; i++) {
	      this.scripts[i].__initializeAttributes();
	    }
	  };

	  _proto._scriptMethod = function _scriptMethod(script, method, arg) {
	    script[method](arg);
	  };

	  _proto._onInitialize = function _onInitialize() {
	    var scripts = this._scripts;

	    var wasLooping = this._beginLooping();

	    for (var i = 0, len = scripts.length; i < len; i++) {
	      var script = scripts[i];

	      if (!script._initialized && script.enabled) {
	        script._initialized = true;
	        if (script.initialize) this._scriptMethod(script, ScriptComponent.scriptMethods.initialize);
	      }
	    }

	    this._endLooping(wasLooping);
	  };

	  _proto._onPostInitialize = function _onPostInitialize() {
	    this.onPostStateChange();
	  };

	  _proto._onUpdate = function _onUpdate(dt) {
	    var list = this._updateList;
	    if (!list.length) return;

	    var wasLooping = this._beginLooping();

	    for (list.loopIndex = 0; list.loopIndex < list.length; list.loopIndex++) {
	      var script = list.items[list.loopIndex];

	      if (script.enabled) {
	        this._scriptMethod(script, ScriptComponent.scriptMethods.update, dt);
	      }
	    }

	    this._endLooping(wasLooping);
	  };

	  _proto._onPostUpdate = function _onPostUpdate(dt) {
	    var list = this._postUpdateList;
	    if (!list.length) return;

	    var wasLooping = this._beginLooping();

	    for (list.loopIndex = 0; list.loopIndex < list.length; list.loopIndex++) {
	      var script = list.items[list.loopIndex];

	      if (script.enabled) {
	        this._scriptMethod(script, ScriptComponent.scriptMethods.postUpdate, dt);
	      }
	    }

	    this._endLooping(wasLooping);
	  };

	  _proto._insertScriptInstance = function _insertScriptInstance(scriptInstance, index, scriptsLength) {
	    if (index === -1) {
	      this._scripts.push(scriptInstance);

	      scriptInstance.__executionOrder = scriptsLength;

	      if (scriptInstance.update) {
	        this._updateList.append(scriptInstance);
	      }

	      if (scriptInstance.postUpdate) {
	        this._postUpdateList.append(scriptInstance);
	      }
	    } else {
	      this._scripts.splice(index, 0, scriptInstance);

	      scriptInstance.__executionOrder = index;

	      this._resetExecutionOrder(index + 1, scriptsLength + 1);

	      if (scriptInstance.update) {
	        this._updateList.insert(scriptInstance);
	      }

	      if (scriptInstance.postUpdate) {
	        this._postUpdateList.insert(scriptInstance);
	      }
	    }
	  };

	  _proto._removeScriptInstance = function _removeScriptInstance(scriptInstance) {
	    var idx = this._scripts.indexOf(scriptInstance);

	    if (idx === -1) return idx;

	    this._scripts.splice(idx, 1);

	    if (scriptInstance.update) {
	      this._updateList.remove(scriptInstance);
	    }

	    if (scriptInstance.postUpdate) {
	      this._postUpdateList.remove(scriptInstance);
	    }

	    return idx;
	  };

	  _proto._resetExecutionOrder = function _resetExecutionOrder(startIndex, scriptsLength) {
	    for (var i = startIndex; i < scriptsLength; i++) {
	      this._scripts[i].__executionOrder = i;
	    }
	  };

	  _proto._resolveEntityScriptAttribute = function _resolveEntityScriptAttribute(attribute, attributeName, oldValue, useGuid, newAttributes, duplicatedIdsMap) {
	    if (attribute.array) {
	      var len = oldValue.length;

	      if (!len) {
	        return;
	      }

	      var newGuidArray = oldValue.slice();

	      for (var i = 0; i < len; i++) {
	        var guid = newGuidArray[i] instanceof Entity ? newGuidArray[i].getGuid() : newGuidArray[i];

	        if (duplicatedIdsMap[guid]) {
	          newGuidArray[i] = useGuid ? duplicatedIdsMap[guid].getGuid() : duplicatedIdsMap[guid];
	        }
	      }

	      newAttributes[attributeName] = newGuidArray;
	    } else {
	      if (oldValue instanceof Entity) {
	        oldValue = oldValue.getGuid();
	      } else if (typeof oldValue !== 'string') {
	        return;
	      }

	      if (duplicatedIdsMap[oldValue]) {
	        newAttributes[attributeName] = duplicatedIdsMap[oldValue];
	      }
	    }
	  };

	  _proto.has = function has(nameOrType) {
	    if (typeof nameOrType === 'string') {
	      return !!this._scriptsIndex[nameOrType];
	    }

	    if (!nameOrType) return false;
	    var scriptType = nameOrType;
	    var scriptName = scriptType.__name;
	    var scriptData = this._scriptsIndex[scriptName];
	    var scriptInstance = scriptData && scriptData.instance;
	    return scriptInstance instanceof scriptType;
	  };

	  _proto.get = function get(nameOrType) {
	    if (typeof nameOrType === 'string') {
	      var data = this._scriptsIndex[nameOrType];
	      return data ? data.instance : null;
	    }

	    if (!nameOrType) return null;
	    var scriptType = nameOrType;
	    var scriptName = scriptType.__name;
	    var scriptData = this._scriptsIndex[scriptName];
	    var scriptInstance = scriptData && scriptData.instance;
	    return scriptInstance instanceof scriptType ? scriptInstance : null;
	  };

	  _proto.create = function create(nameOrType, args) {
	    if (args === void 0) {
	      args = {};
	    }

	    var self = this;
	    var scriptType = nameOrType;
	    var scriptName = nameOrType;

	    if (typeof scriptType === 'string') {
	      scriptType = this.system.app.scripts.get(scriptType);
	    } else if (scriptType) {
	      scriptName = scriptType.__name;
	    }

	    if (scriptType) {
	      if (!this._scriptsIndex[scriptName] || !this._scriptsIndex[scriptName].instance) {
	        var scriptInstance = new scriptType({
	          app: this.system.app,
	          entity: this.entity,
	          enabled: args.hasOwnProperty('enabled') ? args.enabled : true,
	          attributes: args.attributes
	        });
	        var len = this._scripts.length;
	        var ind = -1;
	        if (typeof args.ind === 'number' && args.ind !== -1 && len > args.ind) ind = args.ind;

	        this._insertScriptInstance(scriptInstance, ind, len);

	        this._scriptsIndex[scriptName] = {
	          instance: scriptInstance,
	          onSwap: function onSwap() {
	            self.swap(scriptName);
	          }
	        };
	        this[scriptName] = scriptInstance;
	        if (!args.preloading) scriptInstance.__initializeAttributes();
	        this.fire('create', scriptName, scriptInstance);
	        this.fire('create:' + scriptName, scriptInstance);
	        this.system.app.scripts.on('swap:' + scriptName, this._scriptsIndex[scriptName].onSwap);

	        if (!args.preloading) {
	          if (scriptInstance.enabled && !scriptInstance._initialized) {
	            scriptInstance._initialized = true;
	            if (scriptInstance.initialize) this._scriptMethod(scriptInstance, ScriptComponent.scriptMethods.initialize);
	          }

	          if (scriptInstance.enabled && !scriptInstance._postInitialized) {
	            scriptInstance._postInitialized = true;
	            if (scriptInstance.postInitialize) this._scriptMethod(scriptInstance, ScriptComponent.scriptMethods.postInitialize);
	          }
	        }

	        return scriptInstance;
	      }
	    } else {
	      this._scriptsIndex[scriptName] = {
	        awaiting: true,
	        ind: this._scripts.length
	      };
	    }

	    return null;
	  };

	  _proto.destroy = function destroy(nameOrType) {
	    var scriptName = nameOrType;
	    var scriptType = nameOrType;

	    if (typeof scriptType === 'string') {
	      scriptType = this.system.app.scripts.get(scriptType);
	    } else if (scriptType) {
	      scriptName = scriptType.__name;
	    }

	    var scriptData = this._scriptsIndex[scriptName];
	    delete this._scriptsIndex[scriptName];
	    if (!scriptData) return false;
	    var scriptInstance = scriptData.instance;

	    if (scriptInstance && !scriptInstance._destroyed) {
	      scriptInstance.enabled = false;
	      scriptInstance._destroyed = true;

	      if (!this._isLoopingThroughScripts) {
	        var ind = this._removeScriptInstance(scriptInstance);

	        if (ind >= 0) {
	          this._resetExecutionOrder(ind, this._scripts.length);
	        }
	      } else {
	        this._destroyedScripts.push(scriptInstance);
	      }
	    }

	    this.system.app.scripts.off('swap:' + scriptName, scriptData.onSwap);
	    delete this[scriptName];
	    this.fire('destroy', scriptName, scriptInstance || null);
	    this.fire('destroy:' + scriptName, scriptInstance || null);
	    if (scriptInstance) scriptInstance.fire('destroy');
	    return true;
	  };

	  _proto.swap = function swap(nameOrType) {
	    var scriptName = nameOrType;
	    var scriptType = nameOrType;

	    if (typeof scriptType === 'string') {
	      scriptType = this.system.app.scripts.get(scriptType);
	    } else if (scriptType) {
	      scriptName = scriptType.__name;
	    }

	    var old = this._scriptsIndex[scriptName];
	    if (!old || !old.instance) return false;
	    var scriptInstanceOld = old.instance;

	    var ind = this._scripts.indexOf(scriptInstanceOld);

	    var scriptInstance = new scriptType({
	      app: this.system.app,
	      entity: this.entity,
	      enabled: scriptInstanceOld.enabled,
	      attributes: scriptInstanceOld.__attributes
	    });
	    if (!scriptInstance.swap) return false;

	    scriptInstance.__initializeAttributes();

	    this._scripts[ind] = scriptInstance;
	    this._scriptsIndex[scriptName].instance = scriptInstance;
	    this[scriptName] = scriptInstance;
	    scriptInstance.__executionOrder = ind;

	    if (scriptInstanceOld.update) {
	      this._updateList.remove(scriptInstanceOld);
	    }

	    if (scriptInstanceOld.postUpdate) {
	      this._postUpdateList.remove(scriptInstanceOld);
	    }

	    if (scriptInstance.update) {
	      this._updateList.insert(scriptInstance);
	    }

	    if (scriptInstance.postUpdate) {
	      this._postUpdateList.insert(scriptInstance);
	    }

	    this._scriptMethod(scriptInstance, ScriptComponent.scriptMethods.swap, scriptInstanceOld);

	    this.fire('swap', scriptName, scriptInstance);
	    this.fire('swap:' + scriptName, scriptInstance);
	    return true;
	  };

	  _proto.resolveDuplicatedEntityReferenceProperties = function resolveDuplicatedEntityReferenceProperties(oldScriptComponent, duplicatedIdsMap) {
	    var newScriptComponent = this.entity.script;

	    for (var scriptName in oldScriptComponent._scriptsIndex) {
	      var scriptType = this.system.app.scripts.get(scriptName);

	      if (!scriptType) {
	        continue;
	      }

	      var script = oldScriptComponent._scriptsIndex[scriptName];

	      if (!script || !script.instance) {
	        continue;
	      }

	      var newAttributesRaw = newScriptComponent[scriptName].__attributesRaw;
	      var newAttributes = newScriptComponent[scriptName].__attributes;

	      if (!newAttributesRaw && !newAttributes) {
	        continue;
	      }

	      var useGuid = !!newAttributesRaw;
	      var oldAttributes = script.instance.__attributes;

	      for (var attributeName in oldAttributes) {
	        if (!oldAttributes[attributeName]) {
	          continue;
	        }

	        var attribute = scriptType.attributes.get(attributeName);

	        if (!attribute) {
	          continue;
	        }

	        if (attribute.type === 'entity') {
	          this._resolveEntityScriptAttribute(attribute, attributeName, oldAttributes[attributeName], useGuid, newAttributesRaw || newAttributes, duplicatedIdsMap);
	        } else if (attribute.type === 'json' && Array.isArray(attribute.schema)) {
	          var oldValue = oldAttributes[attributeName];
	          var newJsonValue = newAttributesRaw ? newAttributesRaw[attributeName] : newAttributes[attributeName];

	          for (var i = 0; i < attribute.schema.length; i++) {
	            var field = attribute.schema[i];

	            if (field.type !== 'entity') {
	              continue;
	            }

	            if (attribute.array) {
	              for (var j = 0; j < oldValue.length; j++) {
	                this._resolveEntityScriptAttribute(field, field.name, oldValue[j][field.name], useGuid, newJsonValue[j], duplicatedIdsMap);
	              }
	            } else {
	              this._resolveEntityScriptAttribute(field, field.name, oldValue[field.name], useGuid, newJsonValue, duplicatedIdsMap);
	            }
	          }
	        }
	      }
	    }
	  };

	  _proto.move = function move(nameOrType, ind) {
	    var len = this._scripts.length;
	    if (ind >= len || ind < 0) return false;
	    var scriptType = nameOrType;
	    var scriptName = nameOrType;

	    if (typeof scriptName !== 'string') {
	      scriptName = nameOrType.__name;
	    } else {
	      scriptType = null;
	    }

	    var scriptData = this._scriptsIndex[scriptName];
	    if (!scriptData || !scriptData.instance) return false;
	    var scriptInstance = scriptData.instance;
	    if (scriptType && !(scriptInstance instanceof scriptType)) return false;

	    var indOld = this._scripts.indexOf(scriptInstance);

	    if (indOld === -1 || indOld === ind) return false;

	    this._scripts.splice(ind, 0, this._scripts.splice(indOld, 1)[0]);

	    this._resetExecutionOrder(0, len);

	    this._updateList.sort();

	    this._postUpdateList.sort();

	    this.fire('move', scriptName, scriptInstance, ind, indOld);
	    this.fire('move:' + scriptName, scriptInstance, ind, indOld);
	    return true;
	  };

	  _createClass(ScriptComponent, [{
	    key: "scripts",
	    get: function get() {
	      return this._scripts;
	    },
	    set: function set(value) {
	      this._scriptsData = value;

	      for (var key in value) {
	        if (!value.hasOwnProperty(key)) continue;
	        var script = this._scriptsIndex[key];

	        if (script) {
	          if (typeof value[key].enabled === 'boolean') script.enabled = !!value[key].enabled;

	          if (typeof value[key].attributes === 'object') {
	            for (var attr in value[key].attributes) {
	              if (ScriptAttributes.reservedNames.has(attr)) continue;

	              if (!script.__attributes.hasOwnProperty(attr)) {
	                var scriptType = this.system.app.scripts.get(key);
	                if (scriptType) scriptType.attributes.add(attr, {});
	              }

	              script[attr] = value[key].attributes[attr];
	            }
	          }
	        } else {
	          console.log(this.order);
	        }
	      }
	    }
	  }, {
	    key: "enabled",
	    get: function get() {
	      return this._enabled;
	    },
	    set: function set(value) {
	      var oldValue = this._enabled;
	      this._enabled = value;
	      this.fire('set', 'enabled', oldValue, value);
	    }
	  }]);

	  return ScriptComponent;
	}(Component);

	ScriptComponent.scriptMethods = {
	  initialize: 'initialize',
	  postInitialize: 'postInitialize',
	  update: 'update',
	  postUpdate: 'postUpdate',
	  swap: 'swap'
	};

	var funcNameRegex = new RegExp('^\\s*function(?:\\s|\\s*\\/\\*.*\\*\\/\\s*)+([^\\(\\s\\/]*)\\s*');

	var ScriptType = function (_EventHandler) {
	  _inheritsLoose(ScriptType, _EventHandler);

	  function ScriptType(args) {
	    var _this;

	    _this = _EventHandler.call(this) || this;
	    _this.app = void 0;
	    _this.entity = void 0;
	    _this._enabled = void 0;
	    _this._enabledOld = void 0;
	    _this._initialized = void 0;
	    _this._postInitialized = void 0;
	    _this.__destroyed = void 0;
	    _this.__attributes = void 0;
	    _this.__attributesRaw = void 0;
	    _this.__scriptType = void 0;
	    _this.__executionOrder = void 0;

	    _this.initScriptType(args);

	    return _this;
	  }

	  var _proto = ScriptType.prototype;

	  _proto.initScriptType = function initScriptType(args) {
	    var script = this.constructor;
	    this.app = args.app;
	    this.entity = args.entity;
	    this._enabled = typeof args.enabled === 'boolean' ? args.enabled : true;
	    this._enabledOld = this.enabled;
	    this.__destroyed = false;
	    this.__attributes = {};
	    this.__attributesRaw = args.attributes || {};
	    this.__scriptType = script;
	    this.__executionOrder = -1;
	  };

	  ScriptType.__getScriptName = function __getScriptName(constructorFn) {
	    if (typeof constructorFn !== 'function') return undefined;
	    if ('name' in Function.prototype) return constructorFn.name;
	    if (constructorFn === Function || constructorFn === Function.prototype.constructor) return 'Function';
	    var match = ('' + constructorFn).match(funcNameRegex);
	    return match ? match[1] : undefined;
	  };

	  _proto.__initializeAttributes = function __initializeAttributes(force) {
	    if (!force && !this.__attributesRaw) return;

	    for (var key in this.__scriptType.attributes.index) {
	      if (this.__attributesRaw && this.__attributesRaw.hasOwnProperty(key)) {
	        this[key] = this.__attributesRaw[key];
	      } else if (!this.__attributes.hasOwnProperty(key)) {
	        if (this.__scriptType.attributes.index[key].hasOwnProperty('default')) {
	          this[key] = this.__scriptType.attributes.index[key].default;
	        } else {
	          this[key] = null;
	        }
	      }
	    }

	    this.__attributesRaw = null;
	  };

	  ScriptType.extend = function extend(methods) {
	    for (var key in methods) {
	      if (!methods.hasOwnProperty(key)) continue;
	      this.prototype[key] = methods[key];
	    }
	  };

	  _createClass(ScriptType, [{
	    key: "enabled",
	    get: function get() {
	      return this._enabled && !this._destroyed && this.entity.script.enabled && this.entity.enabled;
	    },
	    set: function set(value) {
	      this._enabled = !!value;
	      if (this.enabled === this._enabledOld) return;
	      this._enabledOld = this.enabled;
	      this.fire(this.enabled ? 'enable' : 'disable');
	      this.fire('state', this.enabled);

	      if (!this._initialized && this.enabled) {
	        this._initialized = true;

	        this.__initializeAttributes(true);

	        if (this.initialize) this.entity.script._scriptMethod(this, ScriptComponent.scriptMethods.initialize);
	      }

	      if (this._initialized && !this._postInitialized && this.enabled && !this.entity.script._beingEnabled) {
	        this._postInitialized = true;
	        if (this.postInitialize) this.entity.script._scriptMethod(this, ScriptComponent.scriptMethods.postInitialize);
	      }
	    }
	  }], [{
	    key: "scriptName",
	    get: function get() {
	      return this.__name;
	    }
	  }, {
	    key: "attributes",
	    get: function get() {
	      if (!this.hasOwnProperty('__attributes')) this.__attributes = new ScriptAttributes(this);
	      return this.__attributes;
	    }
	  }]);

	  return ScriptType;
	}(EventHandler);

	ScriptType.__name = null;

	var ScriptRegistry = function (_EventHandler) {
	  _inheritsLoose(ScriptRegistry, _EventHandler);

	  function ScriptRegistry(app) {
	    var _this;

	    _this = _EventHandler.call(this) || this;
	    _this.app = app;
	    _this._scripts = {};
	    _this._list = [];
	    return _this;
	  }

	  var _proto = ScriptRegistry.prototype;

	  _proto.destroy = function destroy() {
	    this.app = null;
	    this.off();
	  };

	  _proto.add = function add(script) {
	    var _this2 = this;

	    var scriptName = script.__name;

	    if (this._scripts.hasOwnProperty(scriptName)) {
	      setTimeout(function () {
	        if (script.prototype.swap) {
	          var old = _this2._scripts[scriptName];

	          var ind = _this2._list.indexOf(old);

	          _this2._list[ind] = script;
	          _this2._scripts[scriptName] = script;

	          _this2.fire('swap', scriptName, script);

	          _this2.fire('swap:' + scriptName, script);
	        } else {
	          console.warn("script registry already has '" + scriptName + "' script, define 'swap' method for new script type to enable code hot swapping");
	        }
	      });
	      return false;
	    }

	    this._scripts[scriptName] = script;

	    this._list.push(script);

	    this.fire('add', scriptName, script);
	    this.fire('add:' + scriptName, script);
	    setTimeout(function () {
	      if (!_this2._scripts.hasOwnProperty(scriptName)) return;

	      if (!_this2.app || !_this2.app.systems || !_this2.app.systems.script) {
	        return;
	      }

	      var components = _this2.app.systems.script._components;
	      var attributes;
	      var scriptInstances = [];
	      var scriptInstancesInitialized = [];

	      for (components.loopIndex = 0; components.loopIndex < components.length; components.loopIndex++) {
	        var component = components.items[components.loopIndex];

	        if (component._scriptsIndex[scriptName] && component._scriptsIndex[scriptName].awaiting) {
	          if (component._scriptsData && component._scriptsData[scriptName]) attributes = component._scriptsData[scriptName].attributes;
	          var scriptInstance = component.create(scriptName, {
	            preloading: true,
	            ind: component._scriptsIndex[scriptName].ind,
	            attributes: attributes
	          });
	          if (scriptInstance) scriptInstances.push(scriptInstance);
	        }
	      }

	      for (var i = 0; i < scriptInstances.length; i++) {
	        scriptInstances[i].__initializeAttributes();
	      }

	      for (var _i = 0; _i < scriptInstances.length; _i++) {
	        if (scriptInstances[_i].enabled) {
	          scriptInstances[_i]._initialized = true;
	          scriptInstancesInitialized.push(scriptInstances[_i]);
	          if (scriptInstances[_i].initialize) scriptInstances[_i].initialize();
	        }
	      }

	      for (var _i2 = 0; _i2 < scriptInstancesInitialized.length; _i2++) {
	        if (!scriptInstancesInitialized[_i2].enabled || scriptInstancesInitialized[_i2]._postInitialized) {
	          continue;
	        }

	        scriptInstancesInitialized[_i2]._postInitialized = true;
	        if (scriptInstancesInitialized[_i2].postInitialize) scriptInstancesInitialized[_i2].postInitialize();
	      }
	    });
	    return true;
	  };

	  _proto.remove = function remove(nameOrType) {
	    var scriptType = nameOrType;
	    var scriptName = nameOrType;

	    if (typeof scriptName !== 'string') {
	      scriptName = scriptType.__name;
	    } else {
	      scriptType = this.get(scriptName);
	    }

	    if (this.get(scriptName) !== scriptType) return false;
	    delete this._scripts[scriptName];

	    var ind = this._list.indexOf(scriptType);

	    this._list.splice(ind, 1);

	    this.fire('remove', scriptName, scriptType);
	    this.fire('remove:' + scriptName, scriptType);
	    return true;
	  };

	  _proto.get = function get(name) {
	    return this._scripts[name] || null;
	  };

	  _proto.has = function has(nameOrType) {
	    if (typeof nameOrType === 'string') {
	      return this._scripts.hasOwnProperty(nameOrType);
	    }

	    if (!nameOrType) return false;
	    var scriptName = nameOrType.__name;
	    return this._scripts[scriptName] === nameOrType;
	  };

	  _proto.list = function list() {
	    return this._list;
	  };

	  return ScriptRegistry;
	}(EventHandler);

	var I18nParser = function () {
	  function I18nParser() {}

	  var _proto = I18nParser.prototype;

	  _proto._validate = function _validate(data) {
	    if (!data.header) {
	      throw new Error('pc.I18n#addData: Missing "header" field');
	    }

	    if (!data.header.version) {
	      throw new Error('pc.I18n#addData: Missing "header.version" field');
	    }

	    if (data.header.version !== 1) {
	      throw new Error('pc.I18n#addData: Invalid "header.version" field');
	    }

	    if (!data.data) {
	      throw new Error('pc.I18n#addData: Missing "data" field');
	    } else if (!Array.isArray(data.data)) {
	      throw new Error('pc.I18n#addData: "data" field must be an array');
	    }

	    for (var i = 0, len = data.data.length; i < len; i++) {
	      var entry = data.data[i];

	      if (!entry.info) {
	        throw new Error("pc.I18n#addData: missing \"data[" + i + "].info\" field");
	      }

	      if (!entry.info.locale) {
	        throw new Error("pc.I18n#addData: missing \"data[" + i + "].info.locale\" field");
	      }

	      if (typeof entry.info.locale !== 'string') {
	        throw new Error("pc.I18n#addData: \"data[" + i + "].info.locale\" must be a string");
	      }

	      if (!entry.messages) {
	        throw new Error("pc.I18n#addData: missing \"data[" + i + "].messages\" field");
	      }
	    }
	  };

	  _proto.parse = function parse(data) {
	    return data.data;
	  };

	  return I18nParser;
	}();

	var I18n = function (_EventHandler) {
	  _inheritsLoose(I18n, _EventHandler);

	  function I18n(app) {
	    var _this;

	    _this = _EventHandler.call(this) || this;
	    _this.locale = DEFAULT_LOCALE;
	    _this._translations = {};
	    _this._availableLangs = {};
	    _this._app = app;
	    _this._assets = [];
	    _this._parser = new I18nParser();
	    return _this;
	  }

	  I18n.findAvailableLocale = function findAvailableLocale$1(desiredLocale, availableLocales) {
	    return findAvailableLocale(desiredLocale, availableLocales);
	  };

	  var _proto = I18n.prototype;

	  _proto.findAvailableLocale = function findAvailableLocale(desiredLocale) {
	    if (this._translations[desiredLocale]) {
	      return desiredLocale;
	    }

	    var lang = getLang(desiredLocale);
	    return this._findFallbackLocale(desiredLocale, lang);
	  };

	  _proto.getText = function getText(key, locale) {
	    var result = key;
	    var lang;

	    if (!locale) {
	      locale = this._locale;
	      lang = this._lang;
	    }

	    var translations = this._translations[locale];

	    if (!translations) {
	      if (!lang) {
	        lang = getLang(locale);
	      }

	      locale = this._findFallbackLocale(locale, lang);
	      translations = this._translations[locale];
	    }

	    if (translations && translations.hasOwnProperty(key)) {
	      result = translations[key];

	      if (Array.isArray(result)) {
	        result = result[0];
	      }

	      if (result === null || result === undefined) {
	        result = key;
	      }
	    }

	    return result;
	  };

	  _proto.getPluralText = function getPluralText(key, n, locale) {
	    var result = key;
	    var lang;
	    var pluralFn;

	    if (!locale) {
	      locale = this._locale;
	      lang = this._lang;
	      pluralFn = this._pluralFn;
	    } else {
	      lang = getLang(locale);
	      pluralFn = getPluralFn(lang);
	    }

	    var translations = this._translations[locale];

	    if (!translations) {
	      locale = this._findFallbackLocale(locale, lang);
	      lang = getLang(locale);
	      pluralFn = getPluralFn(lang);
	      translations = this._translations[locale];
	    }

	    if (translations && translations[key] && pluralFn) {
	      var index = pluralFn(n);
	      result = translations[key][index];

	      if (result === null || result === undefined) {
	        result = key;
	      }
	    }

	    return result;
	  };

	  _proto.addData = function addData(data) {
	    var parsed;

	    try {
	      parsed = this._parser.parse(data);
	    } catch (err) {
	      console.error(err);
	      return;
	    }

	    for (var i = 0, len = parsed.length; i < len; i++) {
	      var entry = parsed[i];
	      var locale = entry.info.locale;
	      var messages = entry.messages;

	      if (!this._translations[locale]) {
	        this._translations[locale] = {};
	        var lang = getLang(locale);

	        if (!this._availableLangs[lang]) {
	          this._availableLangs[lang] = locale;
	        }
	      }

	      Object.assign(this._translations[locale], messages);
	      this.fire('data:add', locale, messages);
	    }
	  };

	  _proto.removeData = function removeData(data) {
	    var parsed;

	    try {
	      parsed = this._parser.parse(data);
	    } catch (err) {
	      console.error(err);
	      return;
	    }

	    for (var i = 0, len = parsed.length; i < len; i++) {
	      var entry = parsed[i];
	      var locale = entry.info.locale;
	      var translations = this._translations[locale];
	      if (!translations) continue;
	      var messages = entry.messages;

	      for (var key in messages) {
	        delete translations[key];
	      }

	      if (Object.keys(translations).length === 0) {
	        delete this._translations[locale];
	        delete this._availableLangs[getLang(locale)];
	      }

	      this.fire('data:remove', locale, messages);
	    }
	  };

	  _proto.destroy = function destroy() {
	    this._translations = null;
	    this._availableLangs = null;
	    this._assets = null;
	    this._parser = null;
	    this.off();
	  };

	  _proto._findFallbackLocale = function _findFallbackLocale(locale, lang) {
	    var result = DEFAULT_LOCALE_FALLBACKS[locale];

	    if (result && this._translations[result]) {
	      return result;
	    }

	    result = DEFAULT_LOCALE_FALLBACKS[lang];

	    if (result && this._translations[result]) {
	      return result;
	    }

	    result = this._availableLangs[lang];

	    if (result && this._translations[result]) {
	      return result;
	    }

	    return DEFAULT_LOCALE;
	  };

	  _proto._onAssetAdd = function _onAssetAdd(asset) {
	    asset.on('load', this._onAssetLoad, this);
	    asset.on('change', this._onAssetChange, this);
	    asset.on('remove', this._onAssetRemove, this);
	    asset.on('unload', this._onAssetUnload, this);

	    if (asset.resource) {
	      this._onAssetLoad(asset);
	    }
	  };

	  _proto._onAssetLoad = function _onAssetLoad(asset) {
	    this.addData(asset.resource);
	  };

	  _proto._onAssetChange = function _onAssetChange(asset) {
	    if (asset.resource) {
	      this.addData(asset.resource);
	    }
	  };

	  _proto._onAssetRemove = function _onAssetRemove(asset) {
	    asset.off('load', this._onAssetLoad, this);
	    asset.off('change', this._onAssetChange, this);
	    asset.off('remove', this._onAssetRemove, this);
	    asset.off('unload', this._onAssetUnload, this);

	    if (asset.resource) {
	      this.removeData(asset.resource);
	    }

	    this._app.assets.once('add:' + asset.id, this._onAssetAdd, this);
	  };

	  _proto._onAssetUnload = function _onAssetUnload(asset) {
	    if (asset.resource) {
	      this.removeData(asset.resource);
	    }
	  };

	  _createClass(I18n, [{
	    key: "assets",
	    get: function get() {
	      return this._assets;
	    },
	    set: function set(value) {
	      var index = {};

	      for (var _i = 0, len = value.length; _i < len; _i++) {
	        var id = value[_i] instanceof Asset ? value[_i].id : value[_i];
	        index[id] = true;
	      }

	      var i = this._assets.length;

	      while (i--) {
	        var _id = this._assets[i];

	        if (!index[_id]) {
	          this._app.assets.off('add:' + _id, this._onAssetAdd, this);

	          var asset = this._app.assets.get(_id);

	          if (asset) {
	            this._onAssetRemove(asset);
	          }

	          this._assets.splice(i, 1);
	        }
	      }

	      for (var _id2 in index) {
	        var idNum = parseInt(_id2, 10);
	        if (this._assets.indexOf(idNum) !== -1) continue;

	        this._assets.push(idNum);

	        var _asset = this._app.assets.get(idNum);

	        if (!_asset) {
	          this._app.assets.once('add:' + idNum, this._onAssetAdd, this);
	        } else {
	          this._onAssetAdd(_asset);
	        }
	      }
	    }
	  }, {
	    key: "locale",
	    get: function get() {
	      return this._locale;
	    },
	    set: function set(value) {
	      if (this._locale === value) {
	        return;
	      }

	      var lang = getLang(value);

	      if (lang === 'in') {
	        lang = 'id';
	        value = replaceLang(value, lang);

	        if (this._locale === value) {
	          return;
	        }
	      }

	      var old = this._locale;
	      this._locale = value;
	      this._lang = lang;
	      this._pluralFn = getPluralFn(this._lang);
	      this.fire('set:locale', value, old);
	    }
	  }]);

	  return I18n;
	}(EventHandler);

	var ComponentSystemRegistry = function (_EventHandler) {
	  _inheritsLoose(ComponentSystemRegistry, _EventHandler);

	  function ComponentSystemRegistry() {
	    var _this;

	    _this = _EventHandler.call(this) || this;
	    _this.anim = void 0;
	    _this.animation = void 0;
	    _this.audiolistener = void 0;
	    _this.audiosource = void 0;
	    _this.button = void 0;
	    _this.camera = void 0;
	    _this.collision = void 0;
	    _this.element = void 0;
	    _this.joint = void 0;
	    _this.layoutchild = void 0;
	    _this.layoutgroup = void 0;
	    _this.light = void 0;
	    _this.model = void 0;
	    _this.particlesystem = void 0;
	    _this.render = void 0;
	    _this.rigidbody = void 0;
	    _this.screen = void 0;
	    _this.script = void 0;
	    _this.scrollbar = void 0;
	    _this.scrollview = void 0;
	    _this.sound = void 0;
	    _this.sprite = void 0;
	    _this.zone = void 0;
	    _this.list = [];
	    return _this;
	  }

	  var _proto = ComponentSystemRegistry.prototype;

	  _proto.add = function add(system) {
	    var id = system.id;

	    if (this[id]) {
	      throw new Error("ComponentSystem name '" + id + "' already registered or not allowed");
	    }

	    this[id] = system;
	    this.list.push(system);
	  };

	  _proto.remove = function remove(system) {
	    var id = system.id;

	    if (!this[id]) {
	      throw new Error("No ComponentSystem named '" + id + "' registered");
	    }

	    delete this[id];
	    var index = this.list.indexOf(this[id]);

	    if (index !== -1) {
	      this.list.splice(index, 1);
	    }
	  };

	  _proto.destroy = function destroy() {
	    this.off();

	    for (var i = 0; i < this.list.length; i++) {
	      this.list[i].destroy();
	    }
	  };

	  return ComponentSystemRegistry;
	}(EventHandler);

	var ApplicationStats = function () {
	  function ApplicationStats(device) {
	    this.frame = {
	      fps: 0,
	      ms: 0,
	      dt: 0,
	      updateStart: 0,
	      updateTime: 0,
	      renderStart: 0,
	      renderTime: 0,
	      physicsStart: 0,
	      physicsTime: 0,
	      cullTime: 0,
	      sortTime: 0,
	      skinTime: 0,
	      morphTime: 0,
	      instancingTime: 0,
	      triangles: 0,
	      otherPrimitives: 0,
	      shaders: 0,
	      materials: 0,
	      cameras: 0,
	      shadowMapUpdates: 0,
	      shadowMapTime: 0,
	      depthMapTime: 0,
	      forwardTime: 0,
	      lightClustersTime: 0,
	      lightClusters: 0,
	      _timeToCountFrames: 0,
	      _fpsAccum: 0
	    };
	    this.drawCalls = {
	      forward: 0,
	      depth: 0,
	      shadow: 0,
	      immediate: 0,
	      misc: 0,
	      total: 0,
	      skinned: 0,
	      instanced: 0,
	      removedByInstancing: 0
	    };
	    this.misc = {
	      renderTargetCreationTime: 0
	    };
	    this.particles = {
	      updatesPerFrame: 0,
	      _updatesPerFrame: 0,
	      frameTime: 0,
	      _frameTime: 0
	    };
	    this.shaders = device._shaderStats;
	    this.vram = device._vram;
	    Object.defineProperty(this.vram, 'totalUsed', {
	      get: function get() {
	        return this.tex + this.vb + this.ib;
	      }
	    });
	    Object.defineProperty(this.vram, 'geom', {
	      get: function get() {
	        return this.vb + this.ib;
	      }
	    });
	  }

	  _createClass(ApplicationStats, [{
	    key: "scene",
	    get: function get() {
	      return getApplication().scene._stats;
	    }
	  }, {
	    key: "lightmapper",
	    get: function get() {
	      var _getApplication$light;

	      return (_getApplication$light = getApplication().lightmapper) == null ? void 0 : _getApplication$light.stats;
	    }
	  }, {
	    key: "batcher",
	    get: function get() {
	      var batcher = getApplication()._batcher;

	      return batcher ? batcher._stats : null;
	    }
	  }]);

	  return ApplicationStats;
	}();

	var SceneRegistryItem = function () {
	  function SceneRegistryItem(name, url) {
	    this.name = name;
	    this.url = url;
	    this.data = null;
	    this._loading = false;
	    this._onLoadedCallbacks = [];
	  }

	  _createClass(SceneRegistryItem, [{
	    key: "loaded",
	    get: function get() {
	      return !!this.data;
	    }
	  }, {
	    key: "loading",
	    get: function get() {
	      return this._loading;
	    }
	  }]);

	  return SceneRegistryItem;
	}();

	var SceneRegistry = function () {
	  function SceneRegistry(app) {
	    this._app = app;
	    this._list = [];
	    this._index = {};
	    this._urlIndex = {};
	  }

	  var _proto = SceneRegistry.prototype;

	  _proto.destroy = function destroy() {
	    this._app = null;
	  };

	  _proto.list = function list() {
	    return this._list;
	  };

	  _proto.add = function add(name, url) {
	    if (this._index.hasOwnProperty(name)) {
	      return false;
	    }

	    var item = new SceneRegistryItem(name, url);

	    var i = this._list.push(item);

	    this._index[item.name] = i - 1;
	    this._urlIndex[item.url] = i - 1;
	    return true;
	  };

	  _proto.find = function find(name) {
	    if (this._index.hasOwnProperty(name)) {
	      return this._list[this._index[name]];
	    }

	    return null;
	  };

	  _proto.findByUrl = function findByUrl(url) {
	    if (this._urlIndex.hasOwnProperty(url)) {
	      return this._list[this._urlIndex[url]];
	    }

	    return null;
	  };

	  _proto.remove = function remove(name) {
	    if (this._index.hasOwnProperty(name)) {
	      var idx = this._index[name];
	      var item = this._list[idx];
	      delete this._urlIndex[item.url];
	      delete this._index[name];

	      this._list.splice(idx, 1);

	      for (var i = 0; i < this._list.length; i++) {
	        item = this._list[i];
	        this._index[item.name] = i;
	        this._urlIndex[item.url] = i;
	      }
	    }
	  };

	  _proto._loadSceneData = function _loadSceneData(sceneItem, storeInCache, callback) {
	    var url = sceneItem;

	    if (sceneItem instanceof SceneRegistryItem) {
	      url = sceneItem.url;
	    } else {
	      sceneItem = this.findByUrl(url);

	      if (!sceneItem) {
	        sceneItem = new SceneRegistryItem('Untitled', url);
	      }
	    }

	    if (!sceneItem.url) {
	      callback("URL or SceneRegistryItem is null when loading a scene");
	      return;
	    }

	    if (sceneItem.loaded) {
	      callback(null, sceneItem);
	      return;
	    }

	    var handler = this._app.loader.getHandler("hierarchy");

	    if (this._app.assets && this._app.assets.prefix && !ABSOLUTE_URL.test(url)) {
	      url = path.join(this._app.assets.prefix, url);
	    }

	    sceneItem._onLoadedCallbacks.push(callback);

	    if (!sceneItem._loading) {
	      handler.load(url, function (err, data) {
	        sceneItem.data = data;
	        sceneItem._loading = false;

	        for (var i = 0; i < sceneItem._onLoadedCallbacks.length; i++) {
	          sceneItem._onLoadedCallbacks[i](err, sceneItem);
	        }

	        if (!storeInCache) {
	          sceneItem.data = null;
	        }

	        sceneItem._onLoadedCallbacks.length = 0;
	      });
	    }

	    sceneItem._loading = true;
	  };

	  _proto.loadSceneData = function loadSceneData(sceneItem, callback) {
	    this._loadSceneData(sceneItem, true, callback);
	  };

	  _proto.unloadSceneData = function unloadSceneData(sceneItem) {
	    if (typeof sceneItem === 'string') {
	      sceneItem = this.findByUrl(sceneItem);
	    }

	    if (sceneItem) {
	      sceneItem.data = null;
	    }
	  };

	  _proto.loadSceneHierarchy = function loadSceneHierarchy(sceneItem, callback) {
	    var self = this;

	    var handler = this._app.loader.getHandler("hierarchy");

	    this._loadSceneData(sceneItem, false, function (err, sceneItem) {
	      if (err) {
	        if (callback) callback(err);
	        return;
	      }

	      var url = sceneItem.url;
	      var data = sceneItem.data;

	      var _loaded = function _loaded() {
	        self._app.systems.script.preloading = true;
	        var entity = handler.open(url, data);
	        self._app.systems.script.preloading = false;

	        self._app.loader.clearCache(url, "hierarchy");

	        self._app.root.addChild(entity);

	        self._app.systems.fire('initialize', entity);

	        self._app.systems.fire('postInitialize', entity);

	        self._app.systems.fire('postPostInitialize', entity);

	        if (callback) callback(err, entity);
	      };

	      self._app._preloadScripts(data, _loaded);
	    });
	  };

	  _proto.loadSceneSettings = function loadSceneSettings(sceneItem, callback) {
	    var self = this;

	    this._loadSceneData(sceneItem, false, function (err, sceneItem) {
	      if (!err) {
	        self._app.applySceneSettings(sceneItem.data.settings);

	        if (callback) {
	          callback(null);
	        }
	      } else {
	        if (callback) {
	          callback(err);
	        }
	      }
	    });
	  };

	  _proto.loadScene = function loadScene(url, callback) {
	    var self = this;

	    var handler = this._app.loader.getHandler("scene");

	    if (this._app.assets && this._app.assets.prefix && !ABSOLUTE_URL.test(url)) {
	      url = path.join(this._app.assets.prefix, url);
	    }

	    handler.load(url, function (err, data) {
	      if (!err) {
	        var _loaded = function _loaded() {
	          self._app.systems.script.preloading = true;
	          var scene = handler.open(url, data);
	          var sceneItem = self.findByUrl(url);

	          if (sceneItem && !sceneItem.loaded) {
	            sceneItem.data = data;
	          }

	          self._app.systems.script.preloading = false;

	          self._app.loader.clearCache(url, "scene");

	          self._app.loader.patch({
	            resource: scene,
	            type: "scene"
	          }, self._app.assets);

	          self._app.root.addChild(scene.root);

	          if (self._app.systems.rigidbody && typeof Ammo !== 'undefined') {
	            self._app.systems.rigidbody.gravity.set(scene._gravity.x, scene._gravity.y, scene._gravity.z);
	          }

	          if (callback) {
	            callback(null, scene);
	          }
	        };

	        self._app._preloadScripts(data, _loaded);
	      } else {
	        if (callback) {
	          callback(err);
	        }
	      }
	    });
	  };

	  return SceneRegistry;
	}();

	var _depthUniformNames = ['uSceneDepthMap', 'uDepthMap'];
	var _colorUniformNames = ['uSceneColorMap', 'texture_grabPass'];

	var SceneGrab = function () {
	  function SceneGrab(application) {
	    this.application = application;
	    this.device = application.graphicsDevice;
	    this.layer = null;
	    this.colorFormat = this.device.defaultFramebufferAlpha ? PIXELFORMAT_R8_G8_B8_A8 : PIXELFORMAT_R8_G8_B8;

	    if (this.device.webgl2) {
	      this.initWebGl2();
	    } else {
	      this.initWebGl1();
	    }
	  }

	  var _proto = SceneGrab.prototype;

	  _proto.setupUniform = function setupUniform(device, depth, buffer) {
	    var names = depth ? _depthUniformNames : _colorUniformNames;
	    names.forEach(function (name) {
	      return device.scope.resolve(name).setValue(buffer);
	    });
	  };

	  _proto.allocateTexture = function allocateTexture(device, source, name, format, isDepth, mipmaps) {
	    return new Texture(device, {
	      name: name,
	      format: format,
	      width: source ? source.colorBuffer.width : device.width,
	      height: source ? source.colorBuffer.height : device.height,
	      mipmaps: mipmaps,
	      minFilter: isDepth ? FILTER_NEAREST : mipmaps ? FILTER_LINEAR_MIPMAP_LINEAR : FILTER_LINEAR,
	      magFilter: isDepth ? FILTER_NEAREST : FILTER_LINEAR,
	      addressU: ADDRESS_CLAMP_TO_EDGE,
	      addressV: ADDRESS_CLAMP_TO_EDGE
	    });
	  };

	  _proto.resizeCondition = function resizeCondition(target, source, device) {
	    var width = (source == null ? void 0 : source.width) || device.width;
	    var height = (source == null ? void 0 : source.height) || device.height;
	    return !target || width !== target.width || height !== target.height;
	  };

	  _proto.allocateRenderTarget = function allocateRenderTarget(renderTarget, sourceRenderTarget, device, format, isDepth, mipmaps, isDepthUniforms) {
	    var names = isDepthUniforms ? _depthUniformNames : _colorUniformNames;
	    var buffer = this.allocateTexture(device, sourceRenderTarget, names[0], format, isDepth, mipmaps);

	    if (renderTarget) {
	      renderTarget.destroyFrameBuffers();

	      if (isDepth) {
	        renderTarget._depthBuffer = buffer;
	      } else {
	        renderTarget._colorBuffer = buffer;
	      }
	    } else {
	      renderTarget = new RenderTarget({
	        name: 'renderTargetSceneGrab',
	        colorBuffer: isDepth ? null : buffer,
	        depthBuffer: isDepth ? buffer : null,
	        depth: !isDepth,
	        stencil: device.supportsStencil,
	        autoResolve: false
	      });
	    }

	    return renderTarget;
	  };

	  _proto.releaseRenderTarget = function releaseRenderTarget(rt) {
	    if (rt) {
	      rt.destroyTextureBuffers();
	      rt.destroy();
	    }
	  };

	  _proto.initWebGl2 = function initWebGl2() {
	    var app = this.application;
	    var self = this;
	    this.layer = new Layer({
	      enabled: false,
	      name: "Depth",
	      id: LAYERID_DEPTH,
	      onDisable: function onDisable() {
	        self.releaseRenderTarget(this.depthRenderTarget);
	        this.depthRenderTarget = null;
	        self.releaseRenderTarget(this.colorRenderTarget);
	        this.colorRenderTarget = null;
	      },
	      onPreRenderOpaque: function onPreRenderOpaque(cameraPass) {
	        var device = app.graphicsDevice;
	        var camera = this.cameras[cameraPass];

	        if (camera.renderSceneColorMap) {
	          var _camera$renderTarget;

	          if (self.resizeCondition(this.colorRenderTarget, (_camera$renderTarget = camera.renderTarget) == null ? void 0 : _camera$renderTarget.colorBuffer, device)) {
	            self.releaseRenderTarget(this.colorRenderTarget);
	            this.colorRenderTarget = self.allocateRenderTarget(this.colorRenderTarget, camera.renderTarget, device, this.colorFormat, false, true, false);
	          }

	          device.copyRenderTarget(device.renderTarget, this.colorRenderTarget, true, false);
	          device.activeTexture(device.maxCombinedTextures - 1);
	          var colorBuffer = this.colorRenderTarget.colorBuffer;
	          device.bindTexture(colorBuffer);
	          device.gl.generateMipmap(colorBuffer.impl._glTarget);
	          self.setupUniform(device, false, colorBuffer);
	        }

	        if (camera.renderSceneDepthMap) {
	          var _camera$renderTarget2;

	          if (self.resizeCondition(this.depthRenderTarget, (_camera$renderTarget2 = camera.renderTarget) == null ? void 0 : _camera$renderTarget2.depthBuffer, device)) {
	            self.releaseRenderTarget(this.depthRenderTarget);
	            this.depthRenderTarget = self.allocateRenderTarget(this.depthRenderTarget, camera.renderTarget, device, PIXELFORMAT_DEPTHSTENCIL, true, false, true);
	          }

	          device.copyRenderTarget(device.renderTarget, this.depthRenderTarget, false, true);
	          self.setupUniform(device, true, this.depthRenderTarget.depthBuffer);
	        }
	      },
	      onPostRenderOpaque: function onPostRenderOpaque(cameraPass) {}
	    });
	  };

	  _proto.initWebGl1 = function initWebGl1() {
	    var app = this.application;
	    var self = this;
	    this.layer = new Layer({
	      enabled: false,
	      name: "Depth",
	      id: LAYERID_DEPTH,
	      shaderPass: SHADER_DEPTH,
	      onEnable: function onEnable() {
	        this.depthRenderTarget = new RenderTarget({
	          name: 'depthRenderTarget-webgl1',
	          depth: true,
	          stencil: app.graphicsDevice.supportsStencil,
	          autoResolve: false,
	          graphicsDevice: app.graphicsDevice
	        });
	        this.renderTarget = this.depthRenderTarget;
	      },
	      onDisable: function onDisable() {
	        this.depthRenderTarget.destroyTextureBuffers();
	        this.renderTarget = null;
	        self.releaseRenderTarget(this.colorRenderTarget);
	        this.colorRenderTarget = null;
	      },
	      onPostCull: function onPostCull(cameraPass) {
	        var device = app.graphicsDevice;
	        var camera = this.cameras[cameraPass];

	        if (camera.renderSceneDepthMap) {
	          var _camera$renderTarget3;

	          if (self.resizeCondition(this.depthRenderTarget, (_camera$renderTarget3 = camera.renderTarget) == null ? void 0 : _camera$renderTarget3.depthBuffer, device)) {
	            this.depthRenderTarget.destroyTextureBuffers();
	            this.depthRenderTarget = self.allocateRenderTarget(this.depthRenderTarget, camera.renderTarget, device, PIXELFORMAT_R8_G8_B8_A8, false, false, true);
	          }

	          var visibleObjects = this.instances.visibleOpaque[cameraPass];
	          var visibleList = visibleObjects.list;
	          var layerComposition = app.scene.layers;
	          var subLayerEnabled = layerComposition.subLayerEnabled;
	          var isTransparent = layerComposition.subLayerList;
	          var rt = app.scene.layers.getLayerById(LAYERID_WORLD).renderTarget;
	          var cam = this.cameras[cameraPass];
	          var visibleLength = 0;
	          var layers = layerComposition.layerList;

	          for (var i = 0; i < layers.length; i++) {
	            var layer = layers[i];
	            if (layer === this) break;
	            if (layer.renderTarget !== rt || !layer.enabled || !subLayerEnabled[i]) continue;
	            var layerCamId = layer.cameras.indexOf(cam);
	            if (layerCamId < 0) continue;
	            var transparent = isTransparent[i];
	            var layerVisibleList = transparent ? layer.instances.visibleTransparent[layerCamId] : layer.instances.visibleOpaque[layerCamId];
	            var layerVisibleListLength = layerVisibleList.length;
	            layerVisibleList = layerVisibleList.list;

	            for (var j = 0; j < layerVisibleListLength; j++) {
	              var drawCall = layerVisibleList[j];

	              if (drawCall.material && drawCall.material.depthWrite && !drawCall._noDepthDrawGl1) {
	                visibleList[visibleLength] = drawCall;
	                visibleLength++;
	              }
	            }
	          }

	          visibleObjects.length = visibleLength;
	        }
	      },
	      onPreRenderOpaque: function onPreRenderOpaque(cameraPass) {
	        var device = app.graphicsDevice;
	        var camera = this.cameras[cameraPass];

	        if (camera.renderSceneColorMap) {
	          var _camera$renderTarget4;

	          if (self.resizeCondition(this.colorRenderTarget, (_camera$renderTarget4 = camera.renderTarget) == null ? void 0 : _camera$renderTarget4.colorBuffer, device)) {
	            self.releaseRenderTarget(this.colorRenderTarget);
	            this.colorRenderTarget = self.allocateRenderTarget(this.colorRenderTarget, camera.renderTarget, device, this.colorFormat, false, false, false);
	          }

	          var colorBuffer = this.colorRenderTarget._colorBuffer;

	          if (!colorBuffer.impl._glTexture) {
	            colorBuffer.impl.initialize(device, colorBuffer);
	          }

	          device.bindTexture(colorBuffer);
	          var gl = device.gl;
	          gl.copyTexImage2D(gl.TEXTURE_2D, 0, colorBuffer.impl._glFormat, 0, 0, colorBuffer.width, colorBuffer.height, 0);
	          colorBuffer._needsUpload = false;
	          colorBuffer._needsMipmapsUpload = false;
	          self.setupUniform(device, false, colorBuffer);
	        }

	        if (camera.renderSceneDepthMap) {
	          self.setupUniform(device, true, this.depthRenderTarget.colorBuffer);
	        }
	      },
	      onDrawCall: function onDrawCall() {
	        app.graphicsDevice.setColorWrite(true, true, true, true);
	      },
	      onPostRenderOpaque: function onPostRenderOpaque(cameraPass) {
	        var camera = this.cameras[cameraPass];

	        if (camera.renderSceneDepthMap) {
	          var visibleObjects = this.instances.visibleOpaque[cameraPass];
	          visibleObjects.length = 0;
	        }
	      }
	    });
	  };

	  _proto.patch = function patch(layer) {
	    layer.onEnable = this.layer.onEnable;
	    layer.onDisable = this.layer.onDisable;
	    layer.onPreRenderOpaque = this.layer.onPreRenderOpaque;
	    layer.onPostRenderOpaque = this.layer.onPostRenderOpaque;
	    layer.shaderPass = this.layer.shaderPass;
	    layer.onPostCull = this.layer.onPostCull;
	    layer.onDrawCall = this.layer.onDrawCall;
	  };

	  return SceneGrab;
	}();

	var FILLMODE_NONE = 'NONE';
	var FILLMODE_FILL_WINDOW = 'FILL_WINDOW';
	var FILLMODE_KEEP_ASPECT = 'KEEP_ASPECT';
	var RESOLUTION_AUTO = 'AUTO';
	var RESOLUTION_FIXED = 'FIXED';

	var Progress = function () {
	  function Progress(length) {
	    this.length = length;
	    this.count = 0;
	  }

	  var _proto = Progress.prototype;

	  _proto.inc = function inc() {
	    this.count++;
	  };

	  _proto.done = function done() {
	    return this.count === this.length;
	  };

	  return Progress;
	}();

	exports.app = null;

	var AppBase = function (_EventHandler) {
	  _inheritsLoose(AppBase, _EventHandler);

	  function AppBase(canvas) {
	    var _this;

	    _this = _EventHandler.call(this) || this;
	    AppBase._applications[canvas.id] = _assertThisInitialized(_this);
	    setApplication(_assertThisInitialized(_this));
	    exports.app = _assertThisInitialized(_this);
	    _this._destroyRequested = false;
	    _this._inFrameUpdate = false;
	    _this._time = 0;
	    _this.timeScale = 1;
	    _this.maxDeltaTime = 0.1;
	    _this.frame = 0;
	    _this.autoRender = true;
	    _this.renderNextFrame = false;
	    _this.useLegacyScriptAttributeCloning = script.legacy;
	    _this._librariesLoaded = false;
	    _this._fillMode = FILLMODE_KEEP_ASPECT;
	    _this._resolutionMode = RESOLUTION_FIXED;
	    _this._allowResize = true;
	    _this.context = _assertThisInitialized(_this);
	    return _this;
	  }

	  var _proto2 = AppBase.prototype;

	  _proto2.init = function init(appOptions) {
	    var _this2 = this;

	    var device = appOptions.graphicsDevice;
	    this.graphicsDevice = device;

	    this._initDefaultMaterial();

	    this.stats = new ApplicationStats(device);
	    this._soundManager = appOptions.soundManager;
	    this.loader = new ResourceLoader(this);
	    LightsBuffer.init(device);
	    this._entityIndex = {};
	    this.scene = new Scene(device);

	    this._registerSceneImmediate(this.scene);

	    this.root = new Entity();
	    this.root._enabledInHierarchy = true;
	    this.assets = new AssetRegistry(this.loader);
	    if (appOptions.assetPrefix) this.assets.prefix = appOptions.assetPrefix;
	    this.bundles = new BundleRegistry(this.assets);
	    this.enableBundles = typeof TextDecoder !== 'undefined';
	    this.scriptsOrder = appOptions.scriptsOrder || [];
	    this.scripts = new ScriptRegistry(this);
	    this.i18n = new I18n(this);
	    this.scenes = new SceneRegistry(this);
	    var self = this;
	    this.defaultLayerWorld = new Layer({
	      name: "World",
	      id: LAYERID_WORLD
	    });
	    this.sceneGrab = new SceneGrab(this);
	    this.defaultLayerDepth = this.sceneGrab.layer;
	    this.defaultLayerSkybox = new Layer({
	      enabled: true,
	      name: "Skybox",
	      id: LAYERID_SKYBOX,
	      opaqueSortMode: SORTMODE_NONE
	    });
	    this.defaultLayerUi = new Layer({
	      enabled: true,
	      name: "UI",
	      id: LAYERID_UI,
	      transparentSortMode: SORTMODE_MANUAL,
	      passThrough: false
	    });
	    this.defaultLayerImmediate = new Layer({
	      enabled: true,
	      name: "Immediate",
	      id: LAYERID_IMMEDIATE,
	      opaqueSortMode: SORTMODE_NONE,
	      passThrough: true
	    });
	    var defaultLayerComposition = new LayerComposition("default");
	    defaultLayerComposition.pushOpaque(this.defaultLayerWorld);
	    defaultLayerComposition.pushOpaque(this.defaultLayerDepth);
	    defaultLayerComposition.pushOpaque(this.defaultLayerSkybox);
	    defaultLayerComposition.pushTransparent(this.defaultLayerWorld);
	    defaultLayerComposition.pushOpaque(this.defaultLayerImmediate);
	    defaultLayerComposition.pushTransparent(this.defaultLayerImmediate);
	    defaultLayerComposition.pushTransparent(this.defaultLayerUi);
	    this.scene.layers = defaultLayerComposition;
	    this.scene.on('set:layers', function (oldComp, newComp) {
	      var list = newComp.layerList;
	      var layer;

	      for (var i = 0; i < list.length; i++) {
	        layer = list[i];

	        switch (layer.id) {
	          case LAYERID_DEPTH:
	            self.sceneGrab.patch(layer);
	            break;

	          case LAYERID_UI:
	            layer.passThrough = self.defaultLayerUi.passThrough;
	            break;

	          case LAYERID_IMMEDIATE:
	            layer.passThrough = self.defaultLayerImmediate.passThrough;
	            break;
	        }
	      }
	    });
	    AreaLightLuts.createPlaceholder(device);
	    this.renderer = new ForwardRenderer(device);
	    this.renderer.scene = this.scene;
	    this.frameGraph = new FrameGraph();
	    this.lightmapper = null;

	    if (appOptions.lightmapper) {
	      this.lightmapper = new appOptions.lightmapper(device, this.root, this.scene, this.renderer, this.assets);
	      this.once('prerender', this._firstBake, this);
	    }

	    this._batcher = null;

	    if (appOptions.batchManager) {
	      this._batcher = new appOptions.batchManager(device, this.root, this.scene);
	      this.once('prerender', this._firstBatch, this);
	    }

	    this.keyboard = appOptions.keyboard || null;
	    this.mouse = appOptions.mouse || null;
	    this.touch = appOptions.touch || null;
	    this.gamepads = appOptions.gamepads || null;
	    this.elementInput = appOptions.elementInput || null;
	    if (this.elementInput) this.elementInput.app = this;
	    this.xr = appOptions.xr ? new appOptions.xr(this) : null;
	    if (this.elementInput) this.elementInput.attachSelectEvents();
	    this._inTools = false;
	    this._skyboxAsset = null;
	    this._scriptPrefix = appOptions.scriptPrefix || '';

	    if (this.enableBundles) {
	      this.loader.addHandler("bundle", new BundleHandler(this));
	    }

	    appOptions.resourceHandlers.forEach(function (resourceHandler) {
	      var handler = new resourceHandler(_this2);

	      _this2.loader.addHandler(handler.handlerType, handler);
	    });
	    this.systems = new ComponentSystemRegistry();
	    appOptions.componentSystems.forEach(function (componentSystem) {
	      _this2.systems.add(new componentSystem(_this2));
	    });
	    this._visibilityChangeHandler = this.onVisibilityChange.bind(this);

	    if (typeof document !== 'undefined') {
	      if (document.hidden !== undefined) {
	        this._hiddenAttr = 'hidden';
	        document.addEventListener('visibilitychange', this._visibilityChangeHandler, false);
	      } else if (document.mozHidden !== undefined) {
	        this._hiddenAttr = 'mozHidden';
	        document.addEventListener('mozvisibilitychange', this._visibilityChangeHandler, false);
	      } else if (document.msHidden !== undefined) {
	        this._hiddenAttr = 'msHidden';
	        document.addEventListener('msvisibilitychange', this._visibilityChangeHandler, false);
	      } else if (document.webkitHidden !== undefined) {
	        this._hiddenAttr = 'webkitHidden';
	        document.addEventListener('webkitvisibilitychange', this._visibilityChangeHandler, false);
	      }
	    }

	    this.tick = makeTick(this);
	  };

	  AppBase.getApplication = function getApplication$1(id) {
	    return id ? AppBase._applications[id] : getApplication();
	  };

	  _proto2._initDefaultMaterial = function _initDefaultMaterial() {
	    var material = new StandardMaterial();
	    material.name = "Default Material";
	    material.shadingModel = SPECULAR_BLINN;
	    setDefaultMaterial(this.graphicsDevice, material);
	  };

	  _proto2.configure = function configure(url, callback) {
	    var _this3 = this;

	    http.get(url, function (err, response) {
	      if (err) {
	        callback(err);
	        return;
	      }

	      var props = response.application_properties;
	      var scenes = response.scenes;
	      var assets = response.assets;

	      _this3._parseApplicationProperties(props, function (err) {
	        _this3._parseScenes(scenes);

	        _this3._parseAssets(assets);

	        if (!err) {
	          callback(null);
	        } else {
	          callback(err);
	        }
	      });
	    });
	  };

	  _proto2.preload = function preload(callback) {
	    var _this4 = this;

	    this.fire("preload:start");
	    var assets = this.assets.list({
	      preload: true
	    });
	    var progress = new Progress(assets.length);
	    var _done = false;

	    var done = function done() {
	      if (!_this4.graphicsDevice) {
	        return;
	      }

	      if (!_done && progress.done()) {
	        _done = true;

	        _this4.fire("preload:end");

	        callback();
	      }
	    };

	    var total = assets.length;

	    if (progress.length) {
	      var onAssetLoad = function onAssetLoad(asset) {
	        progress.inc();

	        _this4.fire('preload:progress', progress.count / total);

	        if (progress.done()) done();
	      };

	      var onAssetError = function onAssetError(err, asset) {
	        progress.inc();

	        _this4.fire('preload:progress', progress.count / total);

	        if (progress.done()) done();
	      };

	      for (var i = 0; i < assets.length; i++) {
	        if (!assets[i].loaded) {
	          assets[i].once('load', onAssetLoad);
	          assets[i].once('error', onAssetError);
	          this.assets.load(assets[i]);
	        } else {
	          progress.inc();
	          this.fire("preload:progress", progress.count / total);
	          if (progress.done()) done();
	        }
	      }
	    } else {
	      done();
	    }
	  };

	  _proto2._preloadScripts = function _preloadScripts(sceneData, callback) {
	    var _this5 = this;

	    if (!script.legacy) {
	      callback();
	      return;
	    }

	    this.systems.script.preloading = true;

	    var scripts = this._getScriptReferences(sceneData);

	    var l = scripts.length;
	    var progress = new Progress(l);
	    var regex = /^http(s)?:\/\//;

	    if (l) {
	      var onLoad = function onLoad(err, ScriptType) {
	        if (err) console.error(err);
	        progress.inc();

	        if (progress.done()) {
	          _this5.systems.script.preloading = false;
	          callback();
	        }
	      };

	      for (var i = 0; i < l; i++) {
	        var scriptUrl = scripts[i];
	        if (!regex.test(scriptUrl.toLowerCase()) && this._scriptPrefix) scriptUrl = path.join(this._scriptPrefix, scripts[i]);
	        this.loader.load(scriptUrl, 'script', onLoad);
	      }
	    } else {
	      this.systems.script.preloading = false;
	      callback();
	    }
	  };

	  _proto2._handleAreaLightDataProperty = function _handleAreaLightDataProperty(prop) {
	    var asset = this.assets.get(prop);

	    if (asset) {
	      this.setAreaLightLuts(asset);
	    } else {
	      this.assets.once('add:' + prop, this.setAreaLightLuts, this);
	    }
	  };

	  _proto2._parseApplicationProperties = function _parseApplicationProperties(props, callback) {
	    if (typeof props.maxAssetRetries === 'number' && props.maxAssetRetries > 0) {
	      this.loader.enableRetry(props.maxAssetRetries);
	    }

	    if (!props.useDevicePixelRatio) props.useDevicePixelRatio = props.use_device_pixel_ratio;
	    if (!props.resolutionMode) props.resolutionMode = props.resolution_mode;
	    if (!props.fillMode) props.fillMode = props.fill_mode;
	    this._width = props.width;
	    this._height = props.height;

	    if (props.useDevicePixelRatio) {
	      this.graphicsDevice.maxPixelRatio = window.devicePixelRatio;
	    }

	    this.setCanvasResolution(props.resolutionMode, this._width, this._height);
	    this.setCanvasFillMode(props.fillMode, this._width, this._height);

	    if (props.layers && props.layerOrder) {
	      var composition = new LayerComposition("application");
	      var layers = {};

	      for (var key in props.layers) {
	        var data = props.layers[key];
	        data.id = parseInt(key, 10);
	        data.enabled = data.id !== LAYERID_DEPTH;
	        layers[key] = new Layer(data);
	      }

	      for (var i = 0, len = props.layerOrder.length; i < len; i++) {
	        var sublayer = props.layerOrder[i];
	        var layer = layers[sublayer.layer];
	        if (!layer) continue;

	        if (sublayer.transparent) {
	          composition.pushTransparent(layer);
	        } else {
	          composition.pushOpaque(layer);
	        }

	        composition.subLayerEnabled[i] = sublayer.enabled;
	      }

	      this.scene.layers = composition;
	    }

	    if (props.batchGroups) {
	      var batcher = this.batcher;

	      if (batcher) {
	        for (var _i = 0, _len = props.batchGroups.length; _i < _len; _i++) {
	          var grp = props.batchGroups[_i];
	          batcher.addGroup(grp.name, grp.dynamic, grp.maxAabbSize, grp.id, grp.layers);
	        }
	      }
	    }

	    if (props.i18nAssets) {
	      this.i18n.assets = props.i18nAssets;
	    }

	    if (props.areaLightDataAsset) {
	      this._handleAreaLightDataProperty(props.areaLightDataAsset);
	    }

	    this._loadLibraries(props.libraries, callback);
	  };

	  _proto2._loadLibraries = function _loadLibraries(urls, callback) {
	    var _this6 = this;

	    var len = urls.length;
	    var count = len;
	    var regex = /^http(s)?:\/\//;

	    if (len) {
	      var onLoad = function onLoad(err, script) {
	        count--;

	        if (err) {
	          callback(err);
	        } else if (count === 0) {
	          _this6.onLibrariesLoaded();

	          callback(null);
	        }
	      };

	      for (var i = 0; i < len; ++i) {
	        var url = urls[i];
	        if (!regex.test(url.toLowerCase()) && this._scriptPrefix) url = path.join(this._scriptPrefix, url);
	        this.loader.load(url, 'script', onLoad);
	      }
	    } else {
	      this.onLibrariesLoaded();
	      callback(null);
	    }
	  };

	  _proto2._parseScenes = function _parseScenes(scenes) {
	    if (!scenes) return;

	    for (var i = 0; i < scenes.length; i++) {
	      this.scenes.add(scenes[i].name, scenes[i].url);
	    }
	  };

	  _proto2._parseAssets = function _parseAssets(assets) {
	    var list = [];
	    var scriptsIndex = {};
	    var bundlesIndex = {};

	    if (!script.legacy) {
	      for (var i = 0; i < this.scriptsOrder.length; i++) {
	        var id = this.scriptsOrder[i];
	        if (!assets[id]) continue;
	        scriptsIndex[id] = true;
	        list.push(assets[id]);
	      }

	      if (this.enableBundles) {
	        for (var _id in assets) {
	          if (assets[_id].type === 'bundle') {
	            bundlesIndex[_id] = true;
	            list.push(assets[_id]);
	          }
	        }
	      }

	      for (var _id2 in assets) {
	        if (scriptsIndex[_id2] || bundlesIndex[_id2]) continue;
	        list.push(assets[_id2]);
	      }
	    } else {
	      if (this.enableBundles) {
	        for (var _id3 in assets) {
	          if (assets[_id3].type === 'bundle') {
	            bundlesIndex[_id3] = true;
	            list.push(assets[_id3]);
	          }
	        }
	      }

	      for (var _id4 in assets) {
	        if (bundlesIndex[_id4]) continue;
	        list.push(assets[_id4]);
	      }
	    }

	    for (var _i2 = 0; _i2 < list.length; _i2++) {
	      var data = list[_i2];
	      var asset = new Asset(data.name, data.type, data.file, data.data);
	      asset.id = parseInt(data.id, 10);
	      asset.preload = data.preload ? data.preload : false;
	      asset.loaded = data.type === 'script' && data.data && data.data.loadingType > 0;
	      asset.tags.add(data.tags);

	      if (data.i18n) {
	        for (var locale in data.i18n) {
	          asset.addLocalizedAssetId(locale, data.i18n[locale]);
	        }
	      }

	      this.assets.add(asset);
	    }
	  };

	  _proto2._getScriptReferences = function _getScriptReferences(scene) {
	    var priorityScripts = [];

	    if (scene.settings.priority_scripts) {
	      priorityScripts = scene.settings.priority_scripts;
	    }

	    var _scripts = [];
	    var _index = {};

	    for (var i = 0; i < priorityScripts.length; i++) {
	      _scripts.push(priorityScripts[i]);

	      _index[priorityScripts[i]] = true;
	    }

	    var entities = scene.entities;

	    for (var key in entities) {
	      if (!entities[key].components.script) {
	        continue;
	      }

	      var scripts = entities[key].components.script.scripts;

	      for (var _i3 = 0; _i3 < scripts.length; _i3++) {
	        if (_index[scripts[_i3].url]) continue;

	        _scripts.push(scripts[_i3].url);

	        _index[scripts[_i3].url] = true;
	      }
	    }

	    return _scripts;
	  };

	  _proto2.start = function start() {
	    this.frame = 0;
	    this.fire("start", {
	      timestamp: now(),
	      target: this
	    });

	    if (!this._librariesLoaded) {
	      this.onLibrariesLoaded();
	    }

	    this.systems.fire('initialize', this.root);
	    this.fire('initialize');
	    this.systems.fire('postInitialize', this.root);
	    this.systems.fire('postPostInitialize', this.root);
	    this.fire('postinitialize');
	    this.tick();
	  };

	  _proto2.inputUpdate = function inputUpdate(dt) {
	    if (this.controller) {
	      this.controller.update(dt);
	    }

	    if (this.mouse) {
	      this.mouse.update();
	    }

	    if (this.keyboard) {
	      this.keyboard.update();
	    }

	    if (this.gamepads) {
	      this.gamepads.update();
	    }
	  };

	  _proto2.update = function update(dt) {
	    this.frame++;
	    this.graphicsDevice.updateClientRect();
	    if (script.legacy) this.systems.fire('fixedUpdate', 1.0 / 60.0);
	    this.systems.fire(this._inTools ? 'toolsUpdate' : 'update', dt);
	    this.systems.fire('animationUpdate', dt);
	    this.systems.fire('postUpdate', dt);
	    this.fire("update", dt);
	    this.inputUpdate(dt);
	  };

	  _proto2.render = function render() {
	    this.fire('prerender');
	    this.root.syncHierarchy();

	    if (this._batcher) {
	      this._batcher.updateAll();
	    }

	    this.renderComposition(this.scene.layers);
	    this.fire('postrender');
	  };

	  _proto2.renderComposition = function renderComposition(layerComposition) {
	    this.renderer.buildFrameGraph(this.frameGraph, layerComposition);
	    this.frameGraph.render();
	  };

	  _proto2._fillFrameStatsBasic = function _fillFrameStatsBasic(now, dt, ms) {
	    var stats = this.stats.frame;
	    stats.dt = dt;
	    stats.ms = ms;

	    if (now > stats._timeToCountFrames) {
	      stats.fps = stats._fpsAccum;
	      stats._fpsAccum = 0;
	      stats._timeToCountFrames = now + 1000;
	    } else {
	      stats._fpsAccum++;
	    }

	    this.stats.drawCalls.total = this.graphicsDevice._drawCallsPerFrame;
	    this.graphicsDevice._drawCallsPerFrame = 0;
	  };

	  _proto2._fillFrameStats = function _fillFrameStats() {
	    var stats = this.stats.frame;
	    stats.cameras = this.renderer._camerasRendered;
	    stats.materials = this.renderer._materialSwitches;
	    stats.shaders = this.graphicsDevice._shaderSwitchesPerFrame;
	    stats.shadowMapUpdates = this.renderer._shadowMapUpdates;
	    stats.shadowMapTime = this.renderer._shadowMapTime;
	    stats.depthMapTime = this.renderer._depthMapTime;
	    stats.forwardTime = this.renderer._forwardTime;
	    var prims = this.graphicsDevice._primsPerFrame;
	    stats.triangles = prims[PRIMITIVE_TRIANGLES] / 3 + Math.max(prims[PRIMITIVE_TRISTRIP] - 2, 0) + Math.max(prims[PRIMITIVE_TRIFAN] - 2, 0);
	    stats.cullTime = this.renderer._cullTime;
	    stats.sortTime = this.renderer._sortTime;
	    stats.skinTime = this.renderer._skinTime;
	    stats.morphTime = this.renderer._morphTime;
	    stats.lightClusters = this.renderer._lightClusters;
	    stats.lightClustersTime = this.renderer._lightClustersTime;
	    stats.otherPrimitives = 0;

	    for (var i = 0; i < prims.length; i++) {
	      if (i < PRIMITIVE_TRIANGLES) {
	        stats.otherPrimitives += prims[i];
	      }

	      prims[i] = 0;
	    }

	    this.renderer._camerasRendered = 0;
	    this.renderer._materialSwitches = 0;
	    this.renderer._shadowMapUpdates = 0;
	    this.graphicsDevice._shaderSwitchesPerFrame = 0;
	    this.renderer._cullTime = 0;
	    this.renderer._layerCompositionUpdateTime = 0;
	    this.renderer._lightClustersTime = 0;
	    this.renderer._sortTime = 0;
	    this.renderer._skinTime = 0;
	    this.renderer._morphTime = 0;
	    this.renderer._shadowMapTime = 0;
	    this.renderer._depthMapTime = 0;
	    this.renderer._forwardTime = 0;
	    stats = this.stats.drawCalls;
	    stats.forward = this.renderer._forwardDrawCalls;
	    stats.culled = this.renderer._numDrawCallsCulled;
	    stats.depth = 0;
	    stats.shadow = this.renderer._shadowDrawCalls;
	    stats.skinned = this.renderer._skinDrawCalls;
	    stats.immediate = 0;
	    stats.instanced = 0;
	    stats.removedByInstancing = 0;
	    stats.misc = stats.total - (stats.forward + stats.shadow);
	    this.renderer._depthDrawCalls = 0;
	    this.renderer._shadowDrawCalls = 0;
	    this.renderer._forwardDrawCalls = 0;
	    this.renderer._numDrawCallsCulled = 0;
	    this.renderer._skinDrawCalls = 0;
	    this.renderer._immediateRendered = 0;
	    this.renderer._instancedDrawCalls = 0;
	    this.stats.misc.renderTargetCreationTime = this.graphicsDevice.renderTargetCreationTime;
	    stats = this.stats.particles;
	    stats.updatesPerFrame = stats._updatesPerFrame;
	    stats.frameTime = stats._frameTime;
	    stats._updatesPerFrame = 0;
	    stats._frameTime = 0;
	  };

	  _proto2.setCanvasFillMode = function setCanvasFillMode(mode, width, height) {
	    this._fillMode = mode;
	    this.resizeCanvas(width, height);
	  };

	  _proto2.setCanvasResolution = function setCanvasResolution(mode, width, height) {
	    this._resolutionMode = mode;

	    if (mode === RESOLUTION_AUTO && width === undefined) {
	      width = this.graphicsDevice.canvas.clientWidth;
	      height = this.graphicsDevice.canvas.clientHeight;
	    }

	    this.graphicsDevice.resizeCanvas(width, height);
	  };

	  _proto2.isHidden = function isHidden() {
	    return document[this._hiddenAttr];
	  };

	  _proto2.onVisibilityChange = function onVisibilityChange() {
	    if (this.isHidden()) {
	      if (this._soundManager) {
	        this._soundManager.suspend();
	      }
	    } else {
	      if (this._soundManager) {
	        this._soundManager.resume();
	      }
	    }
	  };

	  _proto2.resizeCanvas = function resizeCanvas(width, height) {
	    if (!this._allowResize) return undefined;
	    if (this.xr && this.xr.session) return undefined;
	    var windowWidth = window.innerWidth;
	    var windowHeight = window.innerHeight;

	    if (this._fillMode === FILLMODE_KEEP_ASPECT) {
	      var r = this.graphicsDevice.canvas.width / this.graphicsDevice.canvas.height;
	      var winR = windowWidth / windowHeight;

	      if (r > winR) {
	        width = windowWidth;
	        height = width / r;
	      } else {
	        height = windowHeight;
	        width = height * r;
	      }
	    } else if (this._fillMode === FILLMODE_FILL_WINDOW) {
	      width = windowWidth;
	      height = windowHeight;
	    }

	    this.graphicsDevice.canvas.style.width = width + 'px';
	    this.graphicsDevice.canvas.style.height = height + 'px';
	    this.updateCanvasSize();
	    return {
	      width: width,
	      height: height
	    };
	  };

	  _proto2.updateCanvasSize = function updateCanvasSize() {
	    var _this$xr;

	    if (!this._allowResize || (_this$xr = this.xr) != null && _this$xr.active) {
	      return;
	    }

	    if (this._resolutionMode === RESOLUTION_AUTO) {
	      var canvas = this.graphicsDevice.canvas;
	      this.graphicsDevice.resizeCanvas(canvas.clientWidth, canvas.clientHeight);
	    }
	  };

	  _proto2.onLibrariesLoaded = function onLibrariesLoaded() {
	    this._librariesLoaded = true;

	    if (this.systems.rigidbody) {
	      this.systems.rigidbody.onLibraryLoaded();
	    }
	  };

	  _proto2.applySceneSettings = function applySceneSettings(settings) {
	    var asset;

	    if (this.systems.rigidbody && typeof Ammo !== 'undefined') {
	      var gravity = settings.physics.gravity;
	      this.systems.rigidbody.gravity.set(gravity[0], gravity[1], gravity[2]);
	    }

	    this.scene.applySettings(settings);

	    if (settings.render.hasOwnProperty('skybox')) {
	      if (settings.render.skybox) {
	        asset = this.assets.get(settings.render.skybox);

	        if (asset) {
	          this.setSkybox(asset);
	        } else {
	          this.assets.once('add:' + settings.render.skybox, this.setSkybox, this);
	        }
	      } else {
	        this.setSkybox(null);
	      }
	    }
	  };

	  _proto2.setAreaLightLuts = function setAreaLightLuts(asset) {
	    if (asset) {
	      var device = this.graphicsDevice;
	      asset.ready(function (asset) {
	        AreaLightLuts.set(device, asset.resource);
	      });
	      this.assets.load(asset);
	    }
	  };

	  _proto2.setSkybox = function setSkybox(asset) {
	    var _this7 = this;

	    if (asset !== this._skyboxAsset) {
	      var onSkyboxRemoved = function onSkyboxRemoved() {
	        _this7.setSkybox(null);
	      };

	      var onSkyboxChanged = function onSkyboxChanged() {
	        _this7.scene.setSkybox(_this7._skyboxAsset ? _this7._skyboxAsset.resources : null);
	      };

	      if (this._skyboxAsset) {
	        this.assets.off('load:' + this._skyboxAsset.id, onSkyboxChanged, this);
	        this.assets.off('remove:' + this._skyboxAsset.id, onSkyboxRemoved, this);

	        this._skyboxAsset.off('change', onSkyboxChanged, this);
	      }

	      this._skyboxAsset = asset;

	      if (this._skyboxAsset) {
	        this.assets.on('load:' + this._skyboxAsset.id, onSkyboxChanged, this);
	        this.assets.once('remove:' + this._skyboxAsset.id, onSkyboxRemoved, this);

	        this._skyboxAsset.on('change', onSkyboxChanged, this);

	        if (this.scene.skyboxMip === 0 && !this._skyboxAsset.loadFaces) {
	          this._skyboxAsset.loadFaces = true;
	        }

	        this.assets.load(this._skyboxAsset);
	      }

	      onSkyboxChanged();
	    }
	  };

	  _proto2._firstBake = function _firstBake() {
	    var _this$lightmapper;

	    (_this$lightmapper = this.lightmapper) == null ? void 0 : _this$lightmapper.bake(null, this.scene.lightmapMode);
	  };

	  _proto2._firstBatch = function _firstBatch() {
	    var _this$batcher;

	    (_this$batcher = this.batcher) == null ? void 0 : _this$batcher.generate();
	  };

	  _proto2._processTimestamp = function _processTimestamp(timestamp) {
	    return timestamp;
	  };

	  _proto2.drawLine = function drawLine(start, end, color, depthTest, layer) {
	    this.scene.drawLine(start, end, color, depthTest, layer);
	  };

	  _proto2.drawLines = function drawLines(positions, colors, depthTest, layer) {
	    if (depthTest === void 0) {
	      depthTest = true;
	    }

	    if (layer === void 0) {
	      layer = this.scene.defaultDrawLayer;
	    }

	    this.scene.drawLines(positions, colors, depthTest, layer);
	  };

	  _proto2.drawLineArrays = function drawLineArrays(positions, colors, depthTest, layer) {
	    if (depthTest === void 0) {
	      depthTest = true;
	    }

	    if (layer === void 0) {
	      layer = this.scene.defaultDrawLayer;
	    }

	    this.scene.drawLineArrays(positions, colors, depthTest, layer);
	  };

	  _proto2.drawWireSphere = function drawWireSphere(center, radius, color, segments, depthTest, layer) {
	    if (color === void 0) {
	      color = Color.WHITE;
	    }

	    if (segments === void 0) {
	      segments = 20;
	    }

	    if (depthTest === void 0) {
	      depthTest = true;
	    }

	    if (layer === void 0) {
	      layer = this.scene.defaultDrawLayer;
	    }

	    this.scene.immediate.drawWireSphere(center, radius, color, segments, depthTest, layer);
	  };

	  _proto2.drawWireAlignedBox = function drawWireAlignedBox(minPoint, maxPoint, color, depthTest, layer) {
	    if (color === void 0) {
	      color = Color.WHITE;
	    }

	    if (depthTest === void 0) {
	      depthTest = true;
	    }

	    if (layer === void 0) {
	      layer = this.scene.defaultDrawLayer;
	    }

	    this.scene.immediate.drawWireAlignedBox(minPoint, maxPoint, color, depthTest, layer);
	  };

	  _proto2.drawMeshInstance = function drawMeshInstance(meshInstance, layer) {
	    if (layer === void 0) {
	      layer = this.scene.defaultDrawLayer;
	    }

	    this.scene.immediate.drawMesh(null, null, null, meshInstance, layer);
	  };

	  _proto2.drawMesh = function drawMesh(mesh, material, matrix, layer) {
	    if (layer === void 0) {
	      layer = this.scene.defaultDrawLayer;
	    }

	    this.scene.immediate.drawMesh(material, matrix, mesh, null, layer);
	  };

	  _proto2.drawQuad = function drawQuad(matrix, material, layer) {
	    if (layer === void 0) {
	      layer = this.scene.defaultDrawLayer;
	    }

	    this.scene.immediate.drawMesh(material, matrix, this.scene.immediate.getQuadMesh(), null, layer);
	  };

	  _proto2.drawTexture = function drawTexture(x, y, width, height, texture, material, layer) {
	    if (layer === void 0) {
	      layer = this.scene.defaultDrawLayer;
	    }

	    var matrix = new Mat4();
	    matrix.setTRS(new Vec3(x, y, 0.0), Quat.IDENTITY, new Vec3(width, height, 0.0));

	    if (!material) {
	      material = new Material();
	      material.setParameter("colorMap", texture);
	      material.shader = this.scene.immediate.getTextureShader();
	      material.update();
	    }

	    this.drawQuad(matrix, material, layer);
	  };

	  _proto2.drawDepthTexture = function drawDepthTexture(x, y, width, height, layer) {
	    if (layer === void 0) {
	      layer = this.scene.defaultDrawLayer;
	    }

	    var material = new Material();
	    material.shader = this.scene.immediate.getDepthTextureShader();
	    material.update();
	    this.drawTexture(x, y, width, height, null, material, layer);
	  };

	  _proto2.destroy = function destroy() {
	    var _this$lightmapper2;

	    if (this._inFrameUpdate) {
	      this._destroyRequested = true;
	      return;
	    }

	    var canvasId = this.graphicsDevice.canvas.id;
	    this.off('librariesloaded');

	    if (typeof document !== 'undefined') {
	      document.removeEventListener('visibilitychange', this._visibilityChangeHandler, false);
	      document.removeEventListener('mozvisibilitychange', this._visibilityChangeHandler, false);
	      document.removeEventListener('msvisibilitychange', this._visibilityChangeHandler, false);
	      document.removeEventListener('webkitvisibilitychange', this._visibilityChangeHandler, false);
	    }

	    this._visibilityChangeHandler = null;
	    this.root.destroy();
	    this.root = null;

	    if (this.mouse) {
	      this.mouse.off();
	      this.mouse.detach();
	      this.mouse = null;
	    }

	    if (this.keyboard) {
	      this.keyboard.off();
	      this.keyboard.detach();
	      this.keyboard = null;
	    }

	    if (this.touch) {
	      this.touch.off();
	      this.touch.detach();
	      this.touch = null;
	    }

	    if (this.elementInput) {
	      this.elementInput.detach();
	      this.elementInput = null;
	    }

	    if (this.controller) {
	      this.controller = null;
	    }

	    this.systems.destroy();

	    if (this.scene.layers) {
	      this.scene.layers.destroy();
	    }

	    var assets = this.assets.list();

	    for (var i = 0; i < assets.length; i++) {
	      assets[i].unload();
	      assets[i].off();
	    }

	    this.assets.off();
	    this.bundles.destroy();
	    this.bundles = null;
	    this.i18n.destroy();
	    this.i18n = null;

	    for (var key in this.loader.getHandler('script')._cache) {
	      var element = this.loader.getHandler('script')._cache[key];

	      var parent = element.parentNode;
	      if (parent) parent.removeChild(element);
	    }

	    this.loader.getHandler('script')._cache = {};
	    this.loader.destroy();
	    this.loader = null;
	    this.scene.destroy();
	    this.scene = null;
	    this.systems = null;
	    this.context = null;
	    this.scripts.destroy();
	    this.scripts = null;
	    this.scenes.destroy();
	    this.scenes = null;
	    (_this$lightmapper2 = this.lightmapper) == null ? void 0 : _this$lightmapper2.destroy();
	    this.lightmapper = null;

	    if (this._batcher) {
	      this._batcher.destroy();

	      this._batcher = null;
	    }

	    this._entityIndex = {};
	    this.defaultLayerDepth.onPreRenderOpaque = null;
	    this.defaultLayerDepth.onPostRenderOpaque = null;
	    this.defaultLayerDepth.onDisable = null;
	    this.defaultLayerDepth.onEnable = null;
	    this.defaultLayerDepth = null;
	    this.defaultLayerWorld = null;
	    this == null ? void 0 : this.xr.end();
	    this == null ? void 0 : this.xr.destroy();
	    this.renderer.destroy();
	    this.renderer = null;
	    this.graphicsDevice.destroy();
	    this.graphicsDevice = null;
	    this.tick = null;
	    this.off();

	    if (this._soundManager) {
	      this._soundManager.destroy();

	      this._soundManager = null;
	    }

	    script.app = null;
	    AppBase._applications[canvasId] = null;

	    if (getApplication() === this) {
	      setApplication(null);
	    }
	  };

	  _proto2.getEntityFromIndex = function getEntityFromIndex(guid) {
	    return this._entityIndex[guid];
	  };

	  _proto2._registerSceneImmediate = function _registerSceneImmediate(scene) {
	    this.on('postrender', scene.immediate.onPostRender, scene.immediate);
	  };

	  _createClass(AppBase, [{
	    key: "soundManager",
	    get: function get() {
	      return this._soundManager;
	    }
	  }, {
	    key: "batcher",
	    get: function get() {
	      return this._batcher;
	    }
	  }, {
	    key: "fillMode",
	    get: function get() {
	      return this._fillMode;
	    }
	  }, {
	    key: "resolutionMode",
	    get: function get() {
	      return this._resolutionMode;
	    }
	  }]);

	  return AppBase;
	}(EventHandler);

	AppBase._applications = {};
	var _frameEndData = {};

	var makeTick = function makeTick(_app) {
	  var application = _app;
	  var frameRequest;
	  return function (timestamp, frame) {
	    var _application$xr;

	    if (!application.graphicsDevice) return;
	    setApplication(application);

	    if (frameRequest) {
	      window.cancelAnimationFrame(frameRequest);
	      frameRequest = null;
	    }

	    exports.app = application;
	    var currentTime = application._processTimestamp(timestamp) || now();
	    var ms = currentTime - (application._time || currentTime);
	    var dt = ms / 1000.0;
	    dt = math.clamp(dt, 0, application.maxDeltaTime);
	    dt *= application.timeScale;
	    application._time = currentTime;

	    if ((_application$xr = application.xr) != null && _application$xr.session) {
	      frameRequest = application.xr.session.requestAnimationFrame(application.tick);
	    } else {
	      frameRequest = platform.browser ? window.requestAnimationFrame(application.tick) : null;
	    }

	    if (application.graphicsDevice.contextLost) return;

	    application._fillFrameStatsBasic(currentTime, dt, ms);

	    application._inFrameUpdate = true;
	    application.fire("frameupdate", ms);

	    if (frame) {
	      var _application$xr2;

	      (_application$xr2 = application.xr) == null ? void 0 : _application$xr2.update(frame);
	      application.graphicsDevice.defaultFramebuffer = frame.session.renderState.baseLayer.framebuffer;
	    } else {
	      application.graphicsDevice.defaultFramebuffer = null;
	    }

	    application.update(dt);
	    application.fire("framerender");

	    if (application.autoRender || application.renderNextFrame) {
	      application.updateCanvasSize();
	      application.render();
	      application.renderNextFrame = false;
	    }

	    _frameEndData.timestamp = now();
	    _frameEndData.target = application;
	    application.fire("frameend", _frameEndData);
	    application._inFrameUpdate = false;

	    if (application._destroyRequested) {
	      application.destroy();
	    }
	  };
	};

	var _enableList = [];

	var Entity = function (_GraphNode) {
	  _inheritsLoose(Entity, _GraphNode);

	  function Entity(name, app) {
	    var _this;

	    _this = _GraphNode.call(this, name) || this;
	    _this.anim = void 0;
	    _this.animation = void 0;
	    _this.audiolistener = void 0;
	    _this.button = void 0;
	    _this.camera = void 0;
	    _this.collision = void 0;
	    _this.element = void 0;
	    _this.layoutchild = void 0;
	    _this.layoutgroup = void 0;
	    _this.light = void 0;
	    _this.model = void 0;
	    _this.particlesystem = void 0;
	    _this.render = void 0;
	    _this.rigidbody = void 0;
	    _this.screen = void 0;
	    _this.script = void 0;
	    _this.scrollbar = void 0;
	    _this.scrollview = void 0;
	    _this.sound = void 0;
	    _this.sprite = void 0;
	    _this.c = {};
	    _this._app = void 0;
	    _this._destroying = false;
	    _this._guid = null;
	    _this._template = false;
	    if (name instanceof AppBase) app = name;

	    if (!app) {
	      app = AppBase.getApplication();

	      if (!app) {
	        throw new Error("Couldn't find current application");
	      }
	    }

	    _this._app = app;
	    return _this;
	  }

	  var _proto = Entity.prototype;

	  _proto.addComponent = function addComponent(type, data) {
	    var system = this._app.systems[type];

	    if (!system) {
	      return null;
	    }

	    if (this.c[type]) {
	      return null;
	    }

	    return system.addComponent(this, data);
	  };

	  _proto.removeComponent = function removeComponent(type) {
	    var system = this._app.systems[type];

	    if (!system) {
	      return;
	    }

	    if (!this.c[type]) {
	      return;
	    }

	    system.removeComponent(this);
	  };

	  _proto.findComponent = function findComponent(type) {
	    var entity = this.findOne(function (node) {
	      return node.c && node.c[type];
	    });
	    return entity && entity.c[type];
	  };

	  _proto.findComponents = function findComponents(type) {
	    var entities = this.find(function (node) {
	      return node.c && node.c[type];
	    });
	    return entities.map(function (entity) {
	      return entity.c[type];
	    });
	  };

	  _proto.getGuid = function getGuid() {
	    if (!this._guid) {
	      this.setGuid(guid.create());
	    }

	    return this._guid;
	  };

	  _proto.setGuid = function setGuid(guid) {
	    var index = this._app._entityIndex;

	    if (this._guid) {
	      delete index[this._guid];
	    }

	    this._guid = guid;
	    index[this._guid] = this;
	  };

	  _proto._notifyHierarchyStateChanged = function _notifyHierarchyStateChanged(node, enabled) {
	    var enableFirst = false;
	    if (node === this && _enableList.length === 0) enableFirst = true;
	    node._beingEnabled = true;

	    node._onHierarchyStateChanged(enabled);

	    if (node._onHierarchyStatePostChanged) _enableList.push(node);
	    var c = node._children;

	    for (var i = 0, len = c.length; i < len; i++) {
	      if (c[i]._enabled) this._notifyHierarchyStateChanged(c[i], enabled);
	    }

	    node._beingEnabled = false;

	    if (enableFirst) {
	      for (var _i = 0; _i < _enableList.length; _i++) {
	        _enableList[_i]._onHierarchyStatePostChanged();
	      }

	      _enableList.length = 0;
	    }
	  };

	  _proto._onHierarchyStateChanged = function _onHierarchyStateChanged(enabled) {
	    _GraphNode.prototype._onHierarchyStateChanged.call(this, enabled);

	    var components = this.c;

	    for (var type in components) {
	      if (components.hasOwnProperty(type)) {
	        var component = components[type];

	        if (component.enabled) {
	          if (enabled) {
	            component.onEnable();
	          } else {
	            component.onDisable();
	          }
	        }
	      }
	    }
	  };

	  _proto._onHierarchyStatePostChanged = function _onHierarchyStatePostChanged() {
	    var components = this.c;

	    for (var type in components) {
	      if (components.hasOwnProperty(type)) components[type].onPostStateChange();
	    }
	  };

	  _proto.findByGuid = function findByGuid(guid) {
	    if (this._guid === guid) return this;
	    var e = this._app._entityIndex[guid];

	    if (e && (e === this || e.isDescendantOf(this))) {
	      return e;
	    }

	    return null;
	  };

	  _proto.destroy = function destroy() {
	    this._destroying = true;

	    for (var name in this.c) {
	      this.c[name].enabled = false;
	    }

	    for (var _name in this.c) {
	      this.c[_name].system.removeComponent(this);
	    }

	    if (this._parent) this._parent.removeChild(this);
	    var children = this._children;

	    while (children.length) {
	      var child = children.pop();
	      child._parent = null;

	      if (child instanceof Entity) {
	        child.destroy();
	      }
	    }

	    this.fire('destroy', this);
	    this.off();

	    if (this._guid) {
	      delete this._app._entityIndex[this._guid];
	    }

	    this._destroying = false;
	  };

	  _proto.clone = function clone() {
	    var duplicatedIdsMap = {};

	    var clone = this._cloneRecursively(duplicatedIdsMap);

	    duplicatedIdsMap[this.getGuid()] = clone;
	    resolveDuplicatedEntityReferenceProperties(this, this, clone, duplicatedIdsMap);
	    return clone;
	  };

	  _proto._cloneRecursively = function _cloneRecursively(duplicatedIdsMap) {
	    var clone = new this.constructor(this._app);

	    _GraphNode.prototype._cloneInternal.call(this, clone);

	    for (var type in this.c) {
	      var component = this.c[type];
	      component.system.cloneComponent(this, clone);
	    }

	    for (var i = 0; i < this._children.length; i++) {
	      var oldChild = this._children[i];

	      if (oldChild instanceof Entity) {
	        var newChild = oldChild._cloneRecursively(duplicatedIdsMap);

	        clone.addChild(newChild);
	        duplicatedIdsMap[oldChild.getGuid()] = newChild;
	      }
	    }

	    return clone;
	  };

	  return Entity;
	}(GraphNode);

	function resolveDuplicatedEntityReferenceProperties(oldSubtreeRoot, oldEntity, newEntity, duplicatedIdsMap) {
	  if (oldEntity instanceof Entity) {
	    var components = oldEntity.c;

	    for (var componentName in components) {
	      var component = components[componentName];
	      var entityProperties = component.system.getPropertiesOfType('entity');

	      for (var i = 0, len = entityProperties.length; i < len; i++) {
	        var propertyDescriptor = entityProperties[i];
	        var propertyName = propertyDescriptor.name;
	        var oldEntityReferenceId = component[propertyName];
	        var entityIsWithinOldSubtree = !!oldSubtreeRoot.findByGuid(oldEntityReferenceId);

	        if (entityIsWithinOldSubtree) {
	          var newEntityReferenceId = duplicatedIdsMap[oldEntityReferenceId].getGuid();

	          if (newEntityReferenceId) {
	            newEntity.c[componentName][propertyName] = newEntityReferenceId;
	          }
	        }
	      }
	    }

	    if (components.script && !newEntity._app.useLegacyScriptAttributeCloning) {
	      newEntity.script.resolveDuplicatedEntityReferenceProperties(components.script, duplicatedIdsMap);
	    }

	    if (components.render) {
	      newEntity.render.resolveDuplicatedEntityReferenceProperties(components.render, duplicatedIdsMap);
	    }

	    if (components.anim) {
	      newEntity.anim.resolveDuplicatedEntityReferenceProperties(components.anim, duplicatedIdsMap);
	    }

	    var _old = oldEntity.children.filter(function (e) {
	      return e instanceof Entity;
	    });

	    var _new = newEntity.children.filter(function (e) {
	      return e instanceof Entity;
	    });

	    for (var _i2 = 0, _len = _old.length; _i2 < _len; _i2++) {
	      resolveDuplicatedEntityReferenceProperties(oldSubtreeRoot, _old[_i2], _new[_i2], duplicatedIdsMap);
	    }
	  }
	}

	var _tempPoint = new Vec3();

	var BakeLightAmbient = function (_BakeLight) {
	  _inheritsLoose(BakeLightAmbient, _BakeLight);

	  function BakeLightAmbient(scene) {
	    var lightEntity = new Entity('AmbientLight');
	    lightEntity.addComponent('light', {
	      type: 'directional',
	      affectDynamic: true,
	      affectLightmapped: false,
	      bake: true,
	      bakeNumSamples: scene.ambientBakeNumSamples,
	      castShadows: true,
	      normalOffsetBias: 0.05,
	      shadowBias: 0.2,
	      shadowDistance: 1,
	      shadowResolution: 2048,
	      shadowType: SHADOW_PCF3,
	      color: Color.WHITE,
	      intensity: 1,
	      bakeDir: false
	    });
	    return _BakeLight.call(this, scene, lightEntity.light.light) || this;
	  }

	  var _proto = BakeLightAmbient.prototype;

	  _proto.prepareVirtualLight = function prepareVirtualLight(index, numVirtualLights) {
	    random.spherePointDeterministic(_tempPoint, index, numVirtualLights, 0, this.scene.ambientBakeSpherePart);

	    this.light._node.lookAt(_tempPoint.mulScalar(-1));

	    this.light._node.rotateLocal(90, 0, 0);

	    var gamma = this.scene.gammaCorrection ? 2.2 : 1;
	    var fullIntensity = 2 * Math.PI * this.scene.ambientBakeSpherePart;
	    var linearIntensity = Math.pow(fullIntensity, gamma);
	    this.light.intensity = Math.pow(linearIntensity / numVirtualLights, 1 / gamma);
	  };

	  _createClass(BakeLightAmbient, [{
	    key: "numVirtualLights",
	    get: function get() {
	      return this.light.bakeNumSamples;
	    }
	  }]);

	  return BakeLightAmbient;
	}(BakeLight);

	var BakeMeshNode = function () {
	  function BakeMeshNode(node, meshInstances) {
	    if (meshInstances === void 0) {
	      meshInstances = null;
	    }

	    this.node = node;
	    this.component = node.render || node.model;
	    meshInstances = meshInstances || this.component.meshInstances;
	    this.store();
	    this.meshInstances = meshInstances;
	    this.bounds = null;
	    this.renderTargets = [];
	  }

	  var _proto = BakeMeshNode.prototype;

	  _proto.store = function store() {
	    this.castShadows = this.component.castShadows;
	  };

	  _proto.restore = function restore() {
	    this.component.castShadows = this.castShadows;
	  };

	  return BakeMeshNode;
	}();

	var DENOISE_FILTER_SIZE = 15;

	var LightmapFilters = function () {
	  function LightmapFilters(device) {
	    this.device = device;
	    this.shaderDilate = createShaderFromCode(device, shaderChunks.fullscreenQuadVS, shaderChunksLightmapper.dilatePS, 'lmDilate');
	    this.constantTexSource = device.scope.resolve('source');
	    this.constantPixelOffset = device.scope.resolve('pixelOffset');
	    this.pixelOffset = new Float32Array(2);
	    this.shaderDenoise = null;
	    this.sigmas = null;
	    this.constantSigmas = null;
	    this.kernel = null;
	  }

	  var _proto = LightmapFilters.prototype;

	  _proto.setSourceTexture = function setSourceTexture(texture) {
	    this.constantTexSource.setValue(texture);
	  };

	  _proto.prepare = function prepare(textureWidth, textureHeight) {
	    this.pixelOffset[0] = 1 / textureWidth;
	    this.pixelOffset[1] = 1 / textureHeight;
	    this.constantPixelOffset.setValue(this.pixelOffset);
	  };

	  _proto.prepareDenoise = function prepareDenoise(filterRange, filterSmoothness) {
	    if (!this.shaderDenoise) {
	      this.shaderDenoise = createShaderFromCode(this.device, shaderChunks.fullscreenQuadVS, shaderChunksLightmapper.bilateralDeNoisePS, 'lmBilateralDeNoise');
	      this.sigmas = new Float32Array(2);
	      this.constantSigmas = this.device.scope.resolve('sigmas');
	      this.constantKernel = this.device.scope.resolve('kernel[0]');
	      this.bZnorm = this.device.scope.resolve('bZnorm');
	    }

	    this.sigmas[0] = filterRange;
	    this.sigmas[1] = filterSmoothness;
	    this.constantSigmas.setValue(this.sigmas);
	    this.evaluateDenoiseUniforms(filterRange, filterSmoothness);
	  };

	  _proto.evaluateDenoiseUniforms = function evaluateDenoiseUniforms(filterRange, filterSmoothness) {
	    function normpdf(x, sigma) {
	      return 0.39894 * Math.exp(-0.5 * x * x / (sigma * sigma)) / sigma;
	    }

	    this.kernel = this.kernel || new Float32Array(DENOISE_FILTER_SIZE);
	    var kernel = this.kernel;
	    var kSize = Math.floor((DENOISE_FILTER_SIZE - 1) / 2);

	    for (var j = 0; j <= kSize; ++j) {
	      var value = normpdf(j, filterRange);
	      kernel[kSize + j] = value;
	      kernel[kSize - j] = value;
	    }

	    this.constantKernel.setValue(this.kernel);
	    var bZnorm = 1 / normpdf(0.0, filterSmoothness);
	    this.bZnorm.setValue(bZnorm);
	  };

	  return LightmapFilters;
	}();

	var MAX_LIGHTMAP_SIZE = 2048;
	var PASS_COLOR = 0;
	var PASS_DIR = 1;
	var tempVec$1 = new Vec3();

	var Lightmapper = function () {
	  function Lightmapper(device, root, scene, renderer, assets) {
	    this.device = device;
	    this.root = root;
	    this.scene = scene;
	    this.renderer = renderer;
	    this.assets = assets;
	    this.shadowMapCache = renderer._shadowRenderer.shadowMapCache;
	    this._tempSet = new Set();
	    this._initCalled = false;
	    this.passMaterials = [];
	    this.ambientAOMaterial = null;
	    this.fog = '';
	    this.ambientLight = new Color();
	    this.renderTargets = new Map();
	    this.stats = {
	      renderPasses: 0,
	      lightmapCount: 0,
	      totalRenderTime: 0,
	      forwardTime: 0,
	      fboTime: 0,
	      shadowMapTime: 0,
	      compileTime: 0,
	      shadersLinked: 0
	    };
	  }

	  var _proto = Lightmapper.prototype;

	  _proto.destroy = function destroy() {
	    LightmapCache.decRef(this.blackTex);
	    this.blackTex = null;
	    LightmapCache.destroy();
	    this.device = null;
	    this.root = null;
	    this.scene = null;
	    this.renderer = null;
	    this.assets = null;
	  };

	  _proto.initBake = function initBake(device) {
	    if (!this._initCalled) {
	      this._initCalled = true;
	      this.lightmapFilters = new LightmapFilters(device);
	      this.constantBakeDir = device.scope.resolve('bakeDir');
	      this.materials = [];
	      this.blackTex = new Texture(this.device, {
	        width: 4,
	        height: 4,
	        format: PIXELFORMAT_R8_G8_B8_A8,
	        type: TEXTURETYPE_RGBM,
	        name: 'lightmapBlack'
	      });
	      LightmapCache.incRef(this.blackTex);
	      var camera = new Camera();
	      camera.clearColor.set(0, 0, 0, 0);
	      camera.clearColorBuffer = true;
	      camera.clearDepthBuffer = false;
	      camera.clearStencilBuffer = false;
	      camera.frustumCulling = false;
	      camera.projection = PROJECTION_ORTHOGRAPHIC;
	      camera.aspectRatio = 1;
	      camera.node = new GraphNode();
	      this.camera = camera;
	    }

	    if (this.scene.clusteredLightingEnabled) {
	      var lightingParams = new LightingParams(device.supportsAreaLights, device.maxTextureSize, function () {});
	      this.lightingParams = lightingParams;
	      var srcParams = this.scene.lighting;
	      lightingParams.shadowsEnabled = srcParams.shadowsEnabled;
	      lightingParams.shadowAtlasResolution = srcParams.shadowAtlasResolution;
	      lightingParams.cookiesEnabled = srcParams.cookiesEnabled;
	      lightingParams.cookieAtlasResolution = srcParams.cookieAtlasResolution;
	      lightingParams.areaLightsEnabled = srcParams.areaLightsEnabled;
	      lightingParams.cells = new Vec3(3, 3, 3);
	      lightingParams.maxLightsPerCell = 4;
	      this.worldClusters = new WorldClusters(device);
	      this.worldClusters.name = 'ClusterLightmapper';
	    }
	  };

	  _proto.finishBake = function finishBake(bakeNodes) {
	    this.materials = [];

	    function destroyRT(rt) {
	      LightmapCache.decRef(rt.colorBuffer);
	      rt.destroy();
	    }

	    this.renderTargets.forEach(function (rt) {
	      destroyRT(rt);
	    });
	    this.renderTargets.clear();
	    bakeNodes.forEach(function (node) {
	      node.renderTargets.forEach(function (rt) {
	        destroyRT(rt);
	      });
	      node.renderTargets.length = 0;
	    });
	    this.ambientAOMaterial = null;

	    if (this.worldClusters) {
	      this.worldClusters.destroy();
	      this.worldClusters = null;
	    }
	  };

	  _proto.createMaterialForPass = function createMaterialForPass(device, scene, pass, addAmbient) {
	    var material = new StandardMaterial();
	    material.name = "lmMaterial-pass:" + pass + "-ambient:" + addAmbient;
	    material.chunks.APIVersion = CHUNKAPI_1_55;
	    material.chunks.transformVS = '#define UV1LAYOUT\n' + shaderChunks.transformVS;

	    if (pass === PASS_COLOR) {
	      var bakeLmEndChunk = shaderChunksLightmapper.bakeLmEndPS;

	      if (addAmbient) {
	        bakeLmEndChunk = "\n                    dDiffuseLight = ((dDiffuseLight - 0.5) * max(" + scene.ambientBakeOcclusionContrast.toFixed(1) + " + 1.0, 0.0)) + 0.5;\n                    dDiffuseLight += vec3(" + scene.ambientBakeOcclusionBrightness.toFixed(1) + ");\n                    dDiffuseLight = saturate(dDiffuseLight);\n                    dDiffuseLight *= dAmbientLight;\n                " + bakeLmEndChunk;
	      } else {
	        material.ambient = new Color(0, 0, 0);
	        material.ambientTint = true;
	      }

	      material.chunks.endPS = bakeLmEndChunk;
	      material.lightMap = this.blackTex;
	    } else {
	      material.chunks.basePS = shaderChunks.basePS + '\nuniform sampler2D texture_dirLightMap;\nuniform float bakeDir;\n';
	      material.chunks.endPS = shaderChunksLightmapper.bakeDirLmEndPS;
	    }

	    material.chunks.outputAlphaPS = '\n';
	    material.chunks.outputAlphaOpaquePS = '\n';
	    material.chunks.outputAlphaPremulPS = '\n';
	    material.cull = CULLFACE_NONE;
	    material.forceUv1 = true;
	    material.update();
	    return material;
	  };

	  _proto.createMaterials = function createMaterials(device, scene, passCount) {
	    for (var pass = 0; pass < passCount; pass++) {
	      if (!this.passMaterials[pass]) {
	        this.passMaterials[pass] = this.createMaterialForPass(device, scene, pass, false);
	      }
	    }

	    if (!this.ambientAOMaterial) {
	      this.ambientAOMaterial = this.createMaterialForPass(device, scene, 0, true);

	      this.ambientAOMaterial.onUpdateShader = function (options) {
	        options.lightMapWithoutAmbient = true;
	        options.separateAmbient = true;
	        return options;
	      };
	    }
	  };

	  _proto.createTexture = function createTexture(size, type, name) {
	    return new Texture(this.device, {
	      width: size,
	      height: size,
	      format: PIXELFORMAT_R8_G8_B8_A8,
	      mipmaps: false,
	      type: type,
	      minFilter: FILTER_NEAREST,
	      magFilter: FILTER_NEAREST,
	      addressU: ADDRESS_CLAMP_TO_EDGE,
	      addressV: ADDRESS_CLAMP_TO_EDGE,
	      name: name
	    });
	  };

	  _proto.collectModels = function collectModels(node, bakeNodes, allNodes) {
	    var _node$model, _node$model2, _node$render;

	    if (!node.enabled) return;
	    var meshInstances;

	    if ((_node$model = node.model) != null && _node$model.model && (_node$model2 = node.model) != null && _node$model2.enabled) {
	      if (allNodes) allNodes.push(new BakeMeshNode(node));

	      if (node.model.lightmapped) {
	        if (bakeNodes) {
	          meshInstances = node.model.model.meshInstances;
	        }
	      }
	    }

	    if ((_node$render = node.render) != null && _node$render.enabled) {
	      if (allNodes) allNodes.push(new BakeMeshNode(node));

	      if (node.render.lightmapped) {
	        if (bakeNodes) {
	          meshInstances = node.render.meshInstances;
	        }
	      }
	    }

	    if (meshInstances) {
	      var hasUv1 = true;

	      for (var i = 0; i < meshInstances.length; i++) {
	        if (!meshInstances[i].mesh.vertexBuffer.format.hasUv1) {
	          hasUv1 = false;
	          break;
	        }
	      }

	      if (hasUv1) {
	        var notInstancedMeshInstances = [];

	        for (var _i = 0; _i < meshInstances.length; _i++) {
	          var mesh = meshInstances[_i].mesh;

	          if (this._tempSet.has(mesh)) {
	            bakeNodes.push(new BakeMeshNode(node, [meshInstances[_i]]));
	          } else {
	            notInstancedMeshInstances.push(meshInstances[_i]);
	          }

	          this._tempSet.add(mesh);
	        }

	        this._tempSet.clear();

	        if (notInstancedMeshInstances.length > 0) {
	          bakeNodes.push(new BakeMeshNode(node, notInstancedMeshInstances));
	        }
	      }
	    }

	    for (var _i2 = 0; _i2 < node._children.length; _i2++) {
	      this.collectModels(node._children[_i2], bakeNodes, allNodes);
	    }
	  };

	  _proto.prepareShadowCasters = function prepareShadowCasters(nodes) {
	    var casters = [];

	    for (var n = 0; n < nodes.length; n++) {
	      var component = nodes[n].component;
	      component.castShadows = component.castShadowsLightmap;

	      if (component.castShadowsLightmap) {
	        var meshes = nodes[n].meshInstances;

	        for (var i = 0; i < meshes.length; i++) {
	          meshes[i].visibleThisFrame = true;
	          casters.push(meshes[i]);
	        }
	      }
	    }

	    return casters;
	  };

	  _proto.updateTransforms = function updateTransforms(nodes) {
	    for (var i = 0; i < nodes.length; i++) {
	      var meshInstances = nodes[i].meshInstances;

	      for (var j = 0; j < meshInstances.length; j++) {
	        meshInstances[j].node.getWorldTransform();
	      }
	    }
	  };

	  _proto.calculateLightmapSize = function calculateLightmapSize(node) {
	    var data;
	    var sizeMult = this.scene.lightmapSizeMultiplier || 16;
	    var scale = tempVec$1;
	    var srcArea, lightmapSizeMultiplier;

	    if (node.model) {
	      lightmapSizeMultiplier = node.model.lightmapSizeMultiplier;

	      if (node.model.asset) {
	        data = this.assets.get(node.model.asset).data;

	        if (data.area) {
	          srcArea = data.area;
	        }
	      } else if (node.model._area) {
	        data = node.model;

	        if (data._area) {
	          srcArea = data._area;
	        }
	      }
	    } else if (node.render) {
	      lightmapSizeMultiplier = node.render.lightmapSizeMultiplier;

	      if (node.render.type !== 'asset') {
	        if (node.render._area) {
	          data = node.render;

	          if (data._area) {
	            srcArea = data._area;
	          }
	        }
	      }
	    }

	    var area = {
	      x: 1,
	      y: 1,
	      z: 1,
	      uv: 1
	    };

	    if (srcArea) {
	      area.x = srcArea.x;
	      area.y = srcArea.y;
	      area.z = srcArea.z;
	      area.uv = srcArea.uv;
	    }

	    var areaMult = lightmapSizeMultiplier || 1;
	    area.x *= areaMult;
	    area.y *= areaMult;
	    area.z *= areaMult;
	    var component = node.render || node.model;
	    var bounds = this.computeNodeBounds(component.meshInstances);
	    scale.copy(bounds.halfExtents);
	    var totalArea = area.x * scale.y * scale.z + area.y * scale.x * scale.z + area.z * scale.x * scale.y;
	    totalArea /= area.uv;
	    totalArea = Math.sqrt(totalArea);
	    var lightmapSize = Math.min(math.nextPowerOfTwo(totalArea * sizeMult), this.scene.lightmapMaxResolution || MAX_LIGHTMAP_SIZE);
	    return lightmapSize;
	  };

	  _proto.setLightmapping = function setLightmapping(nodes, value, passCount, shaderDefs) {
	    for (var i = 0; i < nodes.length; i++) {
	      var node = nodes[i];
	      var meshInstances = node.meshInstances;

	      for (var j = 0; j < meshInstances.length; j++) {
	        var meshInstance = meshInstances[j];
	        meshInstance.setLightmapped(value);

	        if (value) {
	          if (shaderDefs) {
	            meshInstance._shaderDefs |= shaderDefs;
	          }

	          meshInstance.mask = MASK_AFFECT_LIGHTMAPPED;

	          for (var pass = 0; pass < passCount; pass++) {
	            var tex = node.renderTargets[pass].colorBuffer;
	            tex.minFilter = FILTER_LINEAR;
	            tex.magFilter = FILTER_LINEAR;
	            meshInstance.setRealtimeLightmap(MeshInstance.lightmapParamNames[pass], tex);
	          }
	        }
	      }
	    }
	  };

	  _proto.bake = function bake(nodes, mode) {
	    if (mode === void 0) {
	      mode = BAKE_COLORDIR;
	    }

	    var device = this.device;
	    var startTime = now();

	    this.scene._updateSky(device);

	    this.stats.renderPasses = 0;
	    this.stats.shadowMapTime = 0;
	    this.stats.forwardTime = 0;
	    var startShaders = device._shaderStats.linked;
	    var startFboTime = device._renderTargetCreationTime;
	    var startCompileTime = device._shaderStats.compileTime;
	    var bakeNodes = [];
	    var allNodes = [];

	    if (nodes) {
	      for (var i = 0; i < nodes.length; i++) {
	        this.collectModels(nodes[i], bakeNodes, null);
	      }

	      this.collectModels(this.root, null, allNodes);
	    } else {
	      this.collectModels(this.root, bakeNodes, allNodes);
	    }

	    if (bakeNodes.length > 0) {
	      var passCount = mode === BAKE_COLORDIR ? 2 : 1;
	      this.setLightmapping(bakeNodes, false, passCount);
	      this.initBake(device);
	      this.bakeInternal(passCount, bakeNodes, allNodes);
	      var shaderDefs = SHADERDEF_LM;

	      if (mode === BAKE_COLORDIR) {
	        shaderDefs |= SHADERDEF_DIRLM;
	      }

	      if (this.scene.ambientBake) {
	        shaderDefs |= SHADERDEF_LMAMBIENT;
	      }

	      this.setLightmapping(bakeNodes, true, passCount, shaderDefs);
	      this.finishBake(bakeNodes);
	    }

	    var nowTime = now();
	    this.stats.totalRenderTime = nowTime - startTime;
	    this.stats.shadersLinked = device._shaderStats.linked - startShaders;
	    this.stats.compileTime = device._shaderStats.compileTime - startCompileTime;
	    this.stats.fboTime = device._renderTargetCreationTime - startFboTime;
	    this.stats.lightmapCount = bakeNodes.length;
	  };

	  _proto.allocateTextures = function allocateTextures(bakeNodes, passCount) {
	    for (var i = 0; i < bakeNodes.length; i++) {
	      var bakeNode = bakeNodes[i];
	      var size = this.calculateLightmapSize(bakeNode.node);

	      for (var pass = 0; pass < passCount; pass++) {
	        var tex = this.createTexture(size, TEXTURETYPE_DEFAULT, 'lightmapper_lightmap_' + i);
	        LightmapCache.incRef(tex);
	        bakeNode.renderTargets[pass] = new RenderTarget({
	          colorBuffer: tex,
	          depth: false
	        });
	      }

	      if (!this.renderTargets.has(size)) {
	        var _tex = this.createTexture(size, TEXTURETYPE_DEFAULT, 'lightmapper_temp_lightmap_' + size);

	        LightmapCache.incRef(_tex);
	        this.renderTargets.set(size, new RenderTarget({
	          colorBuffer: _tex,
	          depth: false
	        }));
	      }
	    }
	  };

	  _proto.prepareLightsToBake = function prepareLightsToBake(layerComposition, allLights, bakeLights) {
	    if (this.scene.ambientBake) {
	      var ambientLight = new BakeLightAmbient(this.scene);
	      bakeLights.push(ambientLight);
	    }

	    var sceneLights = layerComposition._lights;

	    for (var i = 0; i < sceneLights.length; i++) {
	      var light = sceneLights[i];
	      var bakeLight = new BakeLightSimple(this.scene, light);
	      allLights.push(bakeLight);

	      if (light.enabled && (light.mask & MASK_BAKE) !== 0) {
	        light.isStatic = false;
	        light.mask = 0xFFFFFFFF;
	        light.shadowUpdateMode = light.type === LIGHTTYPE_DIRECTIONAL ? SHADOWUPDATE_REALTIME : SHADOWUPDATE_THISFRAME;
	        bakeLights.push(bakeLight);
	      }
	    }

	    bakeLights.sort();
	  };

	  _proto.restoreLights = function restoreLights(allLights) {
	    for (var i = 0; i < allLights.length; i++) {
	      allLights[i].restore();
	    }
	  };

	  _proto.setupScene = function setupScene() {
	    this.revertStatic = false;

	    if (this.scene._needsStaticPrepare) {
	      this.scene._needsStaticPrepare = false;
	      this.revertStatic = true;
	    }

	    this.fog = this.scene.fog;
	    this.ambientLight.copy(this.scene.ambientLight);
	    this.scene.fog = FOG_NONE;

	    if (!this.scene.ambientBake) {
	      this.scene.ambientLight.set(0, 0, 0);
	    }

	    this.renderer.setSceneConstants();
	  };

	  _proto.restoreScene = function restoreScene() {
	    this.scene.fog = this.fog;
	    this.scene.ambientLight.copy(this.ambientLight);

	    if (this.revertStatic) {
	      this.scene._needsStaticPrepare = true;
	    }
	  };

	  _proto.computeNodeBounds = function computeNodeBounds(meshInstances) {
	    var bounds = new BoundingBox();

	    if (meshInstances.length > 0) {
	      bounds.copy(meshInstances[0].aabb);

	      for (var m = 1; m < meshInstances.length; m++) {
	        bounds.add(meshInstances[m].aabb);
	      }
	    }

	    return bounds;
	  };

	  _proto.computeNodesBounds = function computeNodesBounds(nodes) {
	    for (var i = 0; i < nodes.length; i++) {
	      var meshInstances = nodes[i].meshInstances;
	      nodes[i].bounds = this.computeNodeBounds(meshInstances);
	    }
	  };

	  _proto.computeBounds = function computeBounds(meshInstances) {
	    var bounds = new BoundingBox();

	    for (var i = 0; i < meshInstances.length; i++) {
	      bounds.copy(meshInstances[0].aabb);

	      for (var m = 1; m < meshInstances.length; m++) {
	        bounds.add(meshInstances[m].aabb);
	      }
	    }

	    return bounds;
	  };

	  _proto.backupMaterials = function backupMaterials(meshInstances) {
	    for (var i = 0; i < meshInstances.length; i++) {
	      this.materials[i] = meshInstances[i].material;
	    }
	  };

	  _proto.restoreMaterials = function restoreMaterials(meshInstances) {
	    for (var i = 0; i < meshInstances.length; i++) {
	      meshInstances[i].material = this.materials[i];
	    }
	  };

	  _proto.lightCameraPrepare = function lightCameraPrepare(device, bakeLight) {
	    var light = bakeLight.light;
	    var shadowCam;

	    if (light.type === LIGHTTYPE_SPOT) {
	      var lightRenderData = light.getRenderData(null, 0);
	      shadowCam = lightRenderData.shadowCamera;

	      shadowCam._node.setPosition(light._node.getPosition());

	      shadowCam._node.setRotation(light._node.getRotation());

	      shadowCam._node.rotateLocal(-90, 0, 0);

	      shadowCam.projection = PROJECTION_PERSPECTIVE;
	      shadowCam.nearClip = light.attenuationEnd / 1000;
	      shadowCam.farClip = light.attenuationEnd;
	      shadowCam.aspectRatio = 1;
	      shadowCam.fov = light._outerConeAngle * 2;
	      this.renderer.updateCameraFrustum(shadowCam);
	    }

	    return shadowCam;
	  };

	  _proto.lightCameraPrepareAndCull = function lightCameraPrepareAndCull(bakeLight, bakeNode, shadowCam, casterBounds) {
	    var light = bakeLight.light;
	    var lightAffectsNode = true;

	    if (light.type === LIGHTTYPE_DIRECTIONAL) {
	      tempVec$1.copy(casterBounds.center);
	      tempVec$1.y += casterBounds.halfExtents.y;
	      this.camera.node.setPosition(tempVec$1);
	      this.camera.node.setEulerAngles(-90, 0, 0);
	      this.camera.nearClip = 0;
	      this.camera.farClip = casterBounds.halfExtents.y * 2;
	      var frustumSize = Math.max(casterBounds.halfExtents.x, casterBounds.halfExtents.z);
	      this.camera.orthoHeight = frustumSize;
	    } else {
	      if (!bakeLight.lightBounds.intersects(bakeNode.bounds)) {
	        lightAffectsNode = false;
	      }
	    }

	    if (light.type === LIGHTTYPE_SPOT) {
	      var nodeVisible = false;
	      var meshInstances = bakeNode.meshInstances;

	      for (var i = 0; i < meshInstances.length; i++) {
	        if (meshInstances[i]._isVisible(shadowCam)) {
	          nodeVisible = true;
	          break;
	        }
	      }

	      if (!nodeVisible) {
	        lightAffectsNode = false;
	      }
	    }

	    return lightAffectsNode;
	  };

	  _proto.setupLightArray = function setupLightArray(lightArray, light) {
	    lightArray[LIGHTTYPE_DIRECTIONAL].length = 0;
	    lightArray[LIGHTTYPE_OMNI].length = 0;
	    lightArray[LIGHTTYPE_SPOT].length = 0;
	    lightArray[light.type][0] = light;
	    light.visibleThisFrame = true;
	  };

	  _proto.renderShadowMap = function renderShadowMap(shadowMapRendered, casters, lightArray, bakeLight) {
	    var light = bakeLight.light;

	    if (!shadowMapRendered && light.castShadows) {
	      if (!light.shadowMap && !this.scene.clusteredLightingEnabled) {
	        light.shadowMap = this.shadowMapCache.get(this.device, light);
	      }

	      if (light.type === LIGHTTYPE_DIRECTIONAL) {
	        this.renderer._shadowRenderer.cullDirectional(light, casters, this.camera);
	      } else {
	        this.renderer._shadowRenderer.cullLocal(light, casters);
	      }

	      this.renderer.renderShadows(lightArray[light.type], this.camera);
	    }

	    return true;
	  };

	  _proto.postprocessTextures = function postprocessTextures(device, bakeNodes, passCount) {
	    var numDilates2x = 1;
	    var dilateShader = this.lightmapFilters.shaderDilate;
	    var filterLightmap = this.scene.lightmapFilterEnabled;

	    if (filterLightmap) {
	      this.lightmapFilters.prepareDenoise(this.scene.lightmapFilterRange, this.scene.lightmapFilterSmoothness);
	    }

	    for (var node = 0; node < bakeNodes.length; node++) {
	      var bakeNode = bakeNodes[node];

	      for (var pass = 0; pass < passCount; pass++) {
	        var nodeRT = bakeNode.renderTargets[pass];
	        var lightmap = nodeRT.colorBuffer;
	        var tempRT = this.renderTargets.get(lightmap.width);
	        var tempTex = tempRT.colorBuffer;
	        this.lightmapFilters.prepare(lightmap.width, lightmap.height);

	        for (var i = 0; i < numDilates2x; i++) {
	          this.lightmapFilters.setSourceTexture(lightmap);
	          var bilateralFilterEnabled = filterLightmap && pass === 0 && i === 0;
	          drawQuadWithShader(device, tempRT, bilateralFilterEnabled ? this.lightmapFilters.shaderDenoise : dilateShader);
	          this.lightmapFilters.setSourceTexture(tempTex);
	          drawQuadWithShader(device, nodeRT, dilateShader);
	        }
	      }
	    }
	  };

	  _proto.bakeInternal = function bakeInternal(passCount, bakeNodes, allNodes) {
	    var scene = this.scene;
	    var device = this.device;
	    var clusteredLightingEnabled = scene.clusteredLightingEnabled;
	    this.createMaterials(device, scene, passCount);
	    this.setupScene();

	    scene.layers._update();

	    this.computeNodesBounds(bakeNodes);
	    this.allocateTextures(bakeNodes, passCount);
	    var allLights = [],
	        bakeLights = [];
	    this.prepareLightsToBake(scene.layers, allLights, bakeLights);
	    this.updateTransforms(allNodes);
	    var casters = this.prepareShadowCasters(allNodes);
	    this.renderer.updateCpuSkinMatrices(casters);
	    this.renderer.gpuUpdate(casters);
	    var casterBounds = this.computeBounds(casters);
	    var i, j, rcv, m;

	    for (i = 0; i < bakeNodes.length; i++) {
	      var bakeNode = bakeNodes[i];
	      rcv = bakeNode.meshInstances;

	      for (j = 0; j < rcv.length; j++) {
	        m = rcv[j];
	        m.setLightmapped(false);
	        m.mask = MASK_BAKE;
	        m.setRealtimeLightmap(MeshInstance.lightmapParamNames[0], m.material.lightMap ? m.material.lightMap : this.blackTex);
	        m.setRealtimeLightmap(MeshInstance.lightmapParamNames[1], this.blackTex);
	      }
	    }

	    for (j = 0; j < bakeLights.length; j++) {
	      bakeLights[j].light.enabled = false;
	    }

	    var lightArray = [[], [], []];
	    var pass, node;
	    var shadersUpdatedOn1stPass = false;

	    for (i = 0; i < bakeLights.length; i++) {
	      var bakeLight = bakeLights[i];
	      var isAmbientLight = bakeLight instanceof BakeLightAmbient;
	      var numVirtualLights = bakeLight.numVirtualLights;

	      if (passCount > 1 && numVirtualLights > 1 && bakeLight.light.bakeDir) {
	        numVirtualLights = 1;
	      }

	      for (var virtualLightIndex = 0; virtualLightIndex < numVirtualLights; virtualLightIndex++) {
	        if (numVirtualLights > 1) {
	          bakeLight.prepareVirtualLight(virtualLightIndex, numVirtualLights);
	        }

	        bakeLight.startBake();
	        var shadowMapRendered = false;
	        var shadowCam = this.lightCameraPrepare(device, bakeLight);

	        for (node = 0; node < bakeNodes.length; node++) {
	          var _bakeNode = bakeNodes[node];
	          rcv = _bakeNode.meshInstances;
	          var lightAffectsNode = this.lightCameraPrepareAndCull(bakeLight, _bakeNode, shadowCam, casterBounds);

	          if (!lightAffectsNode) {
	            continue;
	          }

	          this.setupLightArray(lightArray, bakeLight.light);

	          if (clusteredLightingEnabled) {
	            this.renderer.lightTextureAtlas.update(lightArray[LIGHTTYPE_SPOT], lightArray[LIGHTTYPE_OMNI], this.lightingParams);
	          }

	          shadowMapRendered = this.renderShadowMap(shadowMapRendered, casters, lightArray, bakeLight);

	          if (clusteredLightingEnabled) {
	            var clusterLights = lightArray[LIGHTTYPE_SPOT].concat(lightArray[LIGHTTYPE_OMNI]);
	            this.worldClusters.update(clusterLights, this.scene.gammaCorrection, this.lightingParams);
	          }

	          this.backupMaterials(rcv);

	          for (pass = 0; pass < passCount; pass++) {
	            if (pass > 0 && virtualLightIndex > 0) {
	              break;
	            }

	            if (isAmbientLight && pass > 0) {
	              break;
	            }

	            var nodeRT = _bakeNode.renderTargets[pass];
	            var lightmapSize = _bakeNode.renderTargets[pass].colorBuffer.width;
	            var tempRT = this.renderTargets.get(lightmapSize);
	            var tempTex = tempRT.colorBuffer;

	            if (pass === 0) {
	              shadersUpdatedOn1stPass = scene.updateShaders;
	            } else if (shadersUpdatedOn1stPass) {
	              scene.updateShaders = true;
	            }

	            var passMaterial = this.passMaterials[pass];

	            if (isAmbientLight) {
	              var lastVirtualLightForPass = virtualLightIndex + 1 === numVirtualLights;

	              if (lastVirtualLightForPass && pass === 0) {
	                passMaterial = this.ambientAOMaterial;
	              }
	            }

	            for (j = 0; j < rcv.length; j++) {
	              rcv[j].material = passMaterial;
	            }

	            this.renderer.updateShaders(rcv);
	            this.renderer.setCamera(this.camera, tempRT, true);

	            if (pass === PASS_DIR) {
	              this.constantBakeDir.setValue(bakeLight.light.bakeDir ? 1 : 0);
	            }

	            if (clusteredLightingEnabled) {
	              this.worldClusters.activate(this.renderer.lightTextureAtlas);
	            }

	            this.renderer._forwardTime = 0;
	            this.renderer._shadowMapTime = 0;
	            this.renderer.renderForward(this.camera, rcv, rcv.length, lightArray, SHADER_FORWARDHDR);
	            device.updateEnd();
	            _bakeNode.renderTargets[pass] = tempRT;
	            this.renderTargets.set(lightmapSize, nodeRT);

	            for (j = 0; j < rcv.length; j++) {
	              m = rcv[j];
	              m.setRealtimeLightmap(MeshInstance.lightmapParamNames[pass], tempTex);
	              m._shaderDefs |= SHADERDEF_LM;
	            }
	          }

	          this.restoreMaterials(rcv);
	        }

	        bakeLight.endBake(this.shadowMapCache);
	      }
	    }

	    this.postprocessTextures(device, bakeNodes, passCount);

	    for (node = 0; node < allNodes.length; node++) {
	      allNodes[node].restore();
	    }

	    this.restoreLights(allLights);
	    this.restoreScene();

	    if (!clusteredLightingEnabled) {
	      this.shadowMapCache.clear();
	    }
	  };

	  return Lightmapper;
	}();

	var _floatRounding = 0.2;

	var Morph = function (_RefCountedObject) {
	  _inheritsLoose(Morph, _RefCountedObject);

	  function Morph(targets, graphicsDevice) {
	    var _this;

	    _this = _RefCountedObject.call(this) || this;
	    _this.device = graphicsDevice || getApplication().graphicsDevice;
	    _this._targets = targets;

	    if (_this.device.supportsMorphTargetTexturesCore) {
	      if (_this.device.extTextureHalfFloat && _this.device.textureHalfFloatRenderable) {
	        _this._renderTextureFormat = Morph.FORMAT_HALF_FLOAT;
	      } else if (_this.device.extTextureFloat && _this.device.textureFloatRenderable) {
	        _this._renderTextureFormat = Morph.FORMAT_FLOAT;
	      }

	      if (_this.device.extTextureHalfFloat && _this.device.textureHalfFloatUpdatable) {
	        _this._textureFormat = Morph.FORMAT_HALF_FLOAT;
	      } else if (_this.device.extTextureFloat) {
	        _this._textureFormat = Morph.FORMAT_FLOAT;
	      }

	      if (_this._renderTextureFormat !== undefined && _this._textureFormat !== undefined) {
	        _this._useTextureMorph = true;
	      }
	    }

	    _this._init();

	    _this._updateMorphFlags();

	    _this._calculateAabb();

	    return _this;
	  }

	  var _proto = Morph.prototype;

	  _proto._init = function _init() {
	    if (this._useTextureMorph) {
	      this._useTextureMorph = this._initTextureBased();
	    }

	    if (!this._useTextureMorph) {
	      for (var i = 0; i < this._targets.length; i++) {
	        this._targets[i]._initVertexBuffers(this.device);
	      }
	    }

	    for (var _i = 0; _i < this._targets.length; _i++) {
	      this._targets[_i]._postInit();
	    }
	  };

	  _proto._initTextureBased = function _initTextureBased() {
	    var deltaArrays = [],
	        deltaInfos = [];

	    for (var i = 0; i < this._targets.length; i++) {
	      var target = this._targets[i];

	      if (target.options.deltaPositions) {
	        deltaArrays.push(target.options.deltaPositions);
	        deltaInfos.push({
	          target: target,
	          name: 'texturePositions'
	        });
	      }

	      if (target.options.deltaNormals) {
	        deltaArrays.push(target.options.deltaNormals);
	        deltaInfos.push({
	          target: target,
	          name: 'textureNormals'
	        });
	      }
	    }

	    var ids = [],
	        usedDataIndices = [];
	    var freeIndex = 1;
	    var dataCount = deltaArrays[0].length;

	    for (var v = 0; v < dataCount; v += 3) {
	      var vertexUsed = false;

	      for (var _i2 = 0; _i2 < deltaArrays.length; _i2++) {
	        var data = deltaArrays[_i2];

	        if (data[v] !== 0 || data[v + 1] !== 0 || data[v + 2] !== 0) {
	          vertexUsed = true;
	          break;
	        }
	      }

	      if (vertexUsed) {
	        ids.push(freeIndex + _floatRounding);
	        usedDataIndices.push(v / 3);
	        freeIndex++;
	      } else {
	        ids.push(0 + _floatRounding);
	      }
	    }

	    var maxTextureSize = Math.min(this.device.maxTextureSize, 4096);
	    var morphTextureWidth = Math.ceil(Math.sqrt(freeIndex));
	    morphTextureWidth = Math.min(morphTextureWidth, maxTextureSize);
	    var morphTextureHeight = Math.ceil(freeIndex / morphTextureWidth);

	    if (morphTextureHeight > maxTextureSize) {
	      return false;
	    }

	    this.morphTextureWidth = morphTextureWidth;
	    this.morphTextureHeight = morphTextureHeight;
	    var halfFloat = false;
	    var numComponents = 3;
	    var float2Half = FloatPacking.float2Half;

	    if (this._textureFormat === Morph.FORMAT_HALF_FLOAT) {
	      halfFloat = true;
	      numComponents = 4;
	    }

	    var arraySize = this.morphTextureWidth * this.morphTextureHeight * numComponents;
	    var packedDeltas = halfFloat ? new Uint16Array(arraySize) : new Float32Array(arraySize);

	    for (var _i3 = 0; _i3 < deltaArrays.length; _i3++) {
	      var _data = deltaArrays[_i3];

	      for (var _v = 0; _v < usedDataIndices.length; _v++) {
	        var index = usedDataIndices[_v];

	        if (halfFloat) {
	          packedDeltas[_v * numComponents + numComponents] = float2Half(_data[index * 3]);
	          packedDeltas[_v * numComponents + numComponents + 1] = float2Half(_data[index * 3 + 1]);
	          packedDeltas[_v * numComponents + numComponents + 2] = float2Half(_data[index * 3 + 2]);
	        } else {
	          packedDeltas[_v * numComponents + numComponents] = _data[index * 3];
	          packedDeltas[_v * numComponents + numComponents + 1] = _data[index * 3 + 1];
	          packedDeltas[_v * numComponents + numComponents + 2] = _data[index * 3 + 2];
	        }
	      }

	      var _target = deltaInfos[_i3].target;
	      var format = this._textureFormat === Morph.FORMAT_FLOAT ? PIXELFORMAT_RGB32F : PIXELFORMAT_RGBA16F;

	      _target._setTexture(deltaInfos[_i3].name, this._createTexture('MorphTarget', format, packedDeltas));
	    }

	    var formatDesc = [{
	      semantic: SEMANTIC_ATTR15,
	      components: 1,
	      type: TYPE_FLOAT32
	    }];
	    this.vertexBufferIds = new VertexBuffer(this.device, new VertexFormat(this.device, formatDesc), ids.length, BUFFER_STATIC, new Float32Array(ids));
	    return true;
	  };

	  _proto.destroy = function destroy() {
	    if (this.vertexBufferIds) {
	      this.vertexBufferIds.destroy();
	      this.vertexBufferIds = null;
	    }

	    for (var i = 0; i < this._targets.length; i++) {
	      this._targets[i].destroy();
	    }

	    this._targets.length = 0;
	  };

	  _proto._updateMorphFlags = function _updateMorphFlags() {
	    this._morphPositions = false;
	    this._morphNormals = false;

	    for (var i = 0; i < this._targets.length; i++) {
	      var target = this._targets[i];

	      if (target.morphPositions) {
	        this._morphPositions = true;
	      }

	      if (target.morphNormals) {
	        this._morphNormals = true;
	      }
	    }
	  };

	  _proto._calculateAabb = function _calculateAabb() {
	    var min = new Vec3();
	    var max = new Vec3();

	    for (var i = 0; i < this._targets.length; i++) {
	      var targetAabb = this._targets[i].aabb;
	      min.min(targetAabb.getMin());
	      max.max(targetAabb.getMax());
	    }

	    this.aabb = new BoundingBox();
	    this.aabb.setMinMax(min, max);
	  };

	  _proto._createTexture = function _createTexture(name, format, pixelData) {
	    var texture = new Texture(this.device, {
	      width: this.morphTextureWidth,
	      height: this.morphTextureHeight,
	      format: format,
	      cubemap: false,
	      mipmaps: false,
	      minFilter: FILTER_NEAREST,
	      magFilter: FILTER_NEAREST,
	      addressU: ADDRESS_CLAMP_TO_EDGE,
	      addressV: ADDRESS_CLAMP_TO_EDGE,
	      name: name
	    });

	    if (pixelData) {
	      texture.lock().set(pixelData);
	      texture.unlock();
	    }

	    return texture;
	  };

	  _createClass(Morph, [{
	    key: "morphPositions",
	    get: function get() {
	      return this._morphPositions;
	    }
	  }, {
	    key: "morphNormals",
	    get: function get() {
	      return this._morphNormals;
	    }
	  }, {
	    key: "maxActiveTargets",
	    get: function get() {
	      if (this._useTextureMorph) return this._targets.length;
	      return this._morphPositions && this._morphNormals ? 4 : 8;
	    }
	  }, {
	    key: "useTextureMorph",
	    get: function get() {
	      return this._useTextureMorph;
	    }
	  }, {
	    key: "targets",
	    get: function get() {
	      return this._targets;
	    }
	  }]);

	  return Morph;
	}(RefCountedObject);

	Morph.FORMAT_FLOAT = 0;
	Morph.FORMAT_HALF_FLOAT = 1;

	var textureMorphVertexShader = "\n    attribute vec2 vertex_position;\n    varying vec2 uv0;\n    void main(void) {\n        gl_Position = vec4(vertex_position, 0.5, 1.0);\n        uv0 = vertex_position.xy * 0.5 + 0.5;\n    }\n    ";

	var MorphInstance = function () {
	  function MorphInstance(morph) {
	    var _this = this;

	    this.morph = morph;
	    morph.incRefCount();
	    this.device = morph.device;
	    this.meshInstance = null;
	    this._weights = [];
	    this._weightMap = new Map();

	    for (var v = 0; v < morph._targets.length; v++) {
	      var target = morph._targets[v];

	      if (target.name) {
	        this._weightMap.set(target.name, v);
	      }

	      this.setWeight(v, target.defaultWeight);
	    }

	    this._activeTargets = [];

	    if (morph.useTextureMorph) {
	      this.shaderCache = {};
	      this.maxSubmitCount = this.device.maxTextures;
	      this._shaderMorphWeights = new Float32Array(this.maxSubmitCount);

	      var createRT = function createRT(name, textureVar) {
	        var format = morph._renderTextureFormat === Morph.FORMAT_FLOAT ? PIXELFORMAT_RGBA32F : PIXELFORMAT_RGBA16F;
	        _this[textureVar] = morph._createTexture(name, format);
	        return new RenderTarget({
	          colorBuffer: _this[textureVar],
	          depth: false
	        });
	      };

	      if (morph.morphPositions) {
	        this.rtPositions = createRT('MorphRTPos', 'texturePositions');
	      }

	      if (morph.morphNormals) {
	        this.rtNormals = createRT('MorphRTNrm', 'textureNormals');
	      }

	      this._textureParams = new Float32Array([morph.morphTextureWidth, morph.morphTextureHeight, 1 / morph.morphTextureWidth, 1 / morph.morphTextureHeight]);

	      for (var i = 0; i < this.maxSubmitCount; i++) {
	        this['morphBlendTex' + i] = this.device.scope.resolve('morphBlendTex' + i);
	      }

	      this.morphFactor = this.device.scope.resolve('morphFactor[0]');
	      this.zeroTextures = false;
	    } else {
	      this.maxSubmitCount = 8;
	      this._shaderMorphWeights = new Float32Array(this.maxSubmitCount);
	      this._shaderMorphWeightsA = new Float32Array(this._shaderMorphWeights.buffer, 0, 4);
	      this._shaderMorphWeightsB = new Float32Array(this._shaderMorphWeights.buffer, 4 * 4, 4);
	      this._activeVertexBuffers = new Array(this.maxSubmitCount);
	    }
	  }

	  var _proto = MorphInstance.prototype;

	  _proto.destroy = function destroy() {
	    this.meshInstance = null;
	    this.shader = null;
	    var morph = this.morph;

	    if (morph) {
	      this.morph = null;
	      morph.decRefCount();

	      if (morph.refCount < 1) {
	        morph.destroy();
	      }
	    }

	    if (this.rtPositions) {
	      this.rtPositions.destroy();
	      this.rtPositions = null;
	    }

	    if (this.texturePositions) {
	      this.texturePositions.destroy();
	      this.texturePositions = null;
	    }

	    if (this.rtNormals) {
	      this.rtNormals.destroy();
	      this.rtNormals = null;
	    }

	    if (this.textureNormals) {
	      this.textureNormals.destroy();
	      this.textureNormals = null;
	    }
	  };

	  _proto.clone = function clone() {
	    var clone = new MorphInstance(this.morph);
	    return clone;
	  };

	  _proto._getWeightIndex = function _getWeightIndex(key) {
	    if (typeof key === 'string') {
	      var index = this._weightMap.get(key);

	      return index;
	    }

	    return key;
	  };

	  _proto.getWeight = function getWeight(key) {
	    var index = this._getWeightIndex(key);

	    return this._weights[index];
	  };

	  _proto.setWeight = function setWeight(key, weight) {
	    var index = this._getWeightIndex(key);

	    this._weights[index] = weight;
	    this._dirty = true;
	  };

	  _proto._getFragmentShader = function _getFragmentShader(numTextures) {
	    var fragmentShader = '';

	    if (numTextures > 0) {
	      fragmentShader += 'varying vec2 uv0;\n' + 'uniform highp float morphFactor[' + numTextures + '];\n';
	    }

	    for (var i = 0; i < numTextures; i++) {
	      fragmentShader += 'uniform highp sampler2D morphBlendTex' + i + ';\n';
	    }

	    fragmentShader += 'void main (void) {\n' + '    highp vec4 color = vec4(0, 0, 0, 1);\n';

	    for (var _i = 0; _i < numTextures; _i++) {
	      fragmentShader += '    color.xyz += morphFactor[' + _i + '] * texture2D(morphBlendTex' + _i + ', uv0).xyz;\n';
	    }

	    fragmentShader += '    gl_FragColor = color;\n' + '}\n';
	    return fragmentShader;
	  };

	  _proto._getShader = function _getShader(count) {
	    var shader = this.shaderCache[count];

	    if (!shader) {
	      var fs = this._getFragmentShader(count);

	      shader = createShaderFromCode(this.device, textureMorphVertexShader, fs, 'textureMorph' + count);
	      this.shaderCache[count] = shader;
	    }

	    return shader;
	  };

	  _proto._updateTextureRenderTarget = function _updateTextureRenderTarget(renderTarget, srcTextureName) {
	    var _this2 = this;

	    var device = this.device;

	    var submitBatch = function submitBatch(usedCount, blending) {
	      _this2.morphFactor.setValue(_this2._shaderMorphWeights);

	      device.setBlending(blending);

	      if (blending) {
	        device.setBlendFunction(BLENDMODE_ONE, BLENDMODE_ONE);
	        device.setBlendEquation(BLENDEQUATION_ADD);
	      }

	      var shader = _this2._getShader(usedCount);

	      drawQuadWithShader(device, renderTarget, shader, undefined, undefined, blending);
	    };

	    var usedCount = 0;
	    var blending = false;
	    var count = this._activeTargets.length;

	    for (var i = 0; i < count; i++) {
	      var activeTarget = this._activeTargets[i];
	      var tex = activeTarget.target[srcTextureName];

	      if (tex) {
	        this['morphBlendTex' + usedCount].setValue(tex);
	        this._shaderMorphWeights[usedCount] = activeTarget.weight;
	        usedCount++;

	        if (usedCount >= this.maxSubmitCount) {
	          submitBatch(usedCount, blending);
	          usedCount = 0;
	          blending = true;
	        }
	      }
	    }

	    if (usedCount > 0 || count === 0 && !this.zeroTextures) {
	      submitBatch(usedCount, blending);
	    }
	  };

	  _proto._updateTextureMorph = function _updateTextureMorph() {
	    this.device;

	    if (this._activeTargets.length > 0 || !this.zeroTextures) {
	      this._updateTextureRenderTarget(this.rtPositions, 'texturePositions');

	      this._updateTextureRenderTarget(this.rtNormals, 'textureNormals');

	      this.zeroTextures = this._activeTargets.length === 0;
	    }
	  };

	  _proto._updateVertexMorph = function _updateVertexMorph() {
	    var count = this.maxSubmitCount;

	    for (var i = 0; i < count; i++) {
	      this._shaderMorphWeights[i] = 0;
	      this._activeVertexBuffers[i] = null;
	    }

	    var posIndex = 0;
	    var nrmIndex = this.morph.morphPositions ? 4 : 0;

	    for (var _i2 = 0; _i2 < this._activeTargets.length; _i2++) {
	      var target = this._activeTargets[_i2].target;

	      if (target._vertexBufferPositions) {
	        this._activeVertexBuffers[posIndex] = target._vertexBufferPositions;
	        this._shaderMorphWeights[posIndex] = this._activeTargets[_i2].weight;
	        posIndex++;
	      }

	      if (target._vertexBufferNormals) {
	        this._activeVertexBuffers[nrmIndex] = target._vertexBufferNormals;
	        this._shaderMorphWeights[nrmIndex] = this._activeTargets[_i2].weight;
	        nrmIndex++;
	      }
	    }
	  };

	  _proto.update = function update() {
	    this._dirty = false;
	    var targets = this.morph._targets;
	    var activeCount = 0;
	    var epsilon = 0.00001;

	    for (var i = 0; i < targets.length; i++) {
	      var absWeight = Math.abs(this.getWeight(i));

	      if (absWeight > epsilon) {
	        if (this._activeTargets.length <= activeCount) {
	          this._activeTargets[activeCount] = {};
	        }

	        var activeTarget = this._activeTargets[activeCount++];
	        activeTarget.absWeight = absWeight;
	        activeTarget.weight = this.getWeight(i);
	        activeTarget.target = targets[i];
	      }
	    }

	    this._activeTargets.length = activeCount;
	    var maxActiveTargets = this.morph.maxActiveTargets;

	    if (this._activeTargets.length > maxActiveTargets) {
	      this._activeTargets.sort(function (l, r) {
	        return l.absWeight < r.absWeight ? 1 : r.absWeight < l.absWeight ? -1 : 0;
	      });

	      this._activeTargets.length = maxActiveTargets;
	    }

	    if (this.morph.useTextureMorph) {
	      this._updateTextureMorph();
	    } else {
	      this._updateVertexMorph();
	    }
	  };

	  return MorphInstance;
	}();

	var Model = function () {
	  function Model() {
	    this.graph = null;
	    this.meshInstances = [];
	    this.skinInstances = [];
	    this.morphInstances = [];
	    this.cameras = [];
	    this.lights = [];
	    this._shadersVersion = 0;
	    this._immutable = false;
	  }

	  var _proto = Model.prototype;

	  _proto.getGraph = function getGraph() {
	    return this.graph;
	  };

	  _proto.setGraph = function setGraph(graph) {
	    this.graph = graph;
	  };

	  _proto.getCameras = function getCameras() {
	    return this.cameras;
	  };

	  _proto.setCameras = function setCameras(cameras) {
	    this.cameras = cameras;
	  };

	  _proto.getLights = function getLights() {
	    return this.lights;
	  };

	  _proto.setLights = function setLights(lights) {
	    this.lights = lights;
	  };

	  _proto.getMaterials = function getMaterials() {
	    var materials = [];

	    for (var i = 0; i < this.meshInstances.length; i++) {
	      var meshInstance = this.meshInstances[i];

	      if (materials.indexOf(meshInstance.material) === -1) {
	        materials.push(meshInstance.material);
	      }
	    }

	    return materials;
	  };

	  _proto.clone = function clone() {
	    var srcNodes = [];
	    var cloneNodes = [];

	    var _duplicate = function _duplicate(node) {
	      var newNode = node.clone();
	      srcNodes.push(node);
	      cloneNodes.push(newNode);

	      for (var idx = 0; idx < node._children.length; idx++) {
	        newNode.addChild(_duplicate(node._children[idx]));
	      }

	      return newNode;
	    };

	    var cloneGraph = _duplicate(this.graph);

	    var cloneMeshInstances = [];
	    var cloneSkinInstances = [];
	    var cloneMorphInstances = [];

	    for (var i = 0; i < this.skinInstances.length; i++) {
	      var skin = this.skinInstances[i].skin;
	      var cloneSkinInstance = new SkinInstance(skin);
	      var bones = [];

	      for (var j = 0; j < skin.boneNames.length; j++) {
	        var boneName = skin.boneNames[j];
	        var bone = cloneGraph.findByName(boneName);
	        bones.push(bone);
	      }

	      cloneSkinInstance.bones = bones;
	      cloneSkinInstances.push(cloneSkinInstance);
	    }

	    for (var _i = 0; _i < this.morphInstances.length; _i++) {
	      var morph = this.morphInstances[_i].morph;
	      var cloneMorphInstance = new MorphInstance(morph);
	      cloneMorphInstances.push(cloneMorphInstance);
	    }

	    for (var _i2 = 0; _i2 < this.meshInstances.length; _i2++) {
	      var meshInstance = this.meshInstances[_i2];
	      var nodeIndex = srcNodes.indexOf(meshInstance.node);
	      var cloneMeshInstance = new MeshInstance(meshInstance.mesh, meshInstance.material, cloneNodes[nodeIndex]);

	      if (meshInstance.skinInstance) {
	        var skinInstanceIndex = this.skinInstances.indexOf(meshInstance.skinInstance);
	        cloneMeshInstance.skinInstance = cloneSkinInstances[skinInstanceIndex];
	      }

	      if (meshInstance.morphInstance) {
	        var morphInstanceIndex = this.morphInstances.indexOf(meshInstance.morphInstance);
	        cloneMeshInstance.morphInstance = cloneMorphInstances[morphInstanceIndex];
	      }

	      cloneMeshInstances.push(cloneMeshInstance);
	    }

	    var clone = new Model();
	    clone.graph = cloneGraph;
	    clone.meshInstances = cloneMeshInstances;
	    clone.skinInstances = cloneSkinInstances;
	    clone.morphInstances = cloneMorphInstances;
	    clone.getGraph().syncHierarchy();
	    return clone;
	  };

	  _proto.destroy = function destroy() {
	    var meshInstances = this.meshInstances;

	    for (var i = 0; i < meshInstances.length; i++) {
	      meshInstances[i].destroy();
	    }

	    this.meshInstances.length = 0;
	  };

	  _proto.generateWireframe = function generateWireframe() {
	    MeshInstance._prepareRenderStyleForArray(this.meshInstances, RENDERSTYLE_WIREFRAME);
	  };

	  return Model;
	}();

	var MorphTarget = function () {
	  function MorphTarget(options) {
	    if (arguments.length === 2) {
	      options = arguments[1];
	    }

	    this.options = options;
	    this._name = options.name;
	    this._defaultWeight = options.defaultWeight || 0;
	    this.aabb = options.aabb;

	    if (!this.aabb) {
	      this.aabb = new BoundingBox();
	      if (options.deltaPositions) this.aabb.compute(options.deltaPositions);
	    }

	    this.deltaPositions = options.deltaPositions;
	  }

	  var _proto = MorphTarget.prototype;

	  _proto._postInit = function _postInit() {
	    this.options = null;
	  };

	  _proto._initVertexBuffers = function _initVertexBuffers(graphicsDevice) {
	    var options = this.options;
	    this._vertexBufferPositions = this._createVertexBuffer(graphicsDevice, options.deltaPositions, options.deltaPositionsType);
	    this._vertexBufferNormals = this._createVertexBuffer(graphicsDevice, options.deltaNormals, options.deltaNormalsType);

	    if (this._vertexBufferPositions) {
	      this.deltaPositions = this._vertexBufferPositions.lock();
	    }
	  };

	  _proto._createVertexBuffer = function _createVertexBuffer(device, data, dataType) {
	    if (dataType === void 0) {
	      dataType = TYPE_FLOAT32;
	    }

	    if (data) {
	      var formatDesc = [{
	        semantic: SEMANTIC_ATTR0,
	        components: 3,
	        type: dataType
	      }];
	      return new VertexBuffer(device, new VertexFormat(device, formatDesc), data.length / 3, BUFFER_STATIC, data);
	    }

	    return null;
	  };

	  _proto._setTexture = function _setTexture(name, texture) {
	    this[name] = texture;
	  };

	  _proto.destroy = function destroy() {
	    if (this._vertexBufferPositions) {
	      this._vertexBufferPositions.destroy();

	      this._vertexBufferPositions = null;
	    }

	    if (this._vertexBufferNormals) {
	      this._vertexBufferNormals.destroy();

	      this._vertexBufferNormals = null;
	    }

	    if (this.texturePositions) {
	      this.texturePositions.destroy();
	      this.texturePositions = null;
	    }

	    if (this.textureNormals) {
	      this.textureNormals.destroy();
	      this.textureNormals = null;
	    }
	  };

	  _createClass(MorphTarget, [{
	    key: "name",
	    get: function get() {
	      return this._name;
	    }
	  }, {
	    key: "defaultWeight",
	    get: function get() {
	      return this._defaultWeight;
	    }
	  }, {
	    key: "morphPositions",
	    get: function get() {
	      return !!this._vertexBufferPositions || !!this.texturePositions;
	    }
	  }, {
	    key: "morphNormals",
	    get: function get() {
	      return !!this._vertexBufferNormals || !!this.textureNormals;
	    }
	  }]);

	  return MorphTarget;
	}();

	var particle = {
	  generateKey: function generateKey(options) {
	    var key = "particle";

	    for (var prop in options) {
	      if (options.hasOwnProperty(prop)) {
	        key += options[prop];
	      }
	    }

	    return key;
	  },
	  _animTex: function _animTex(options) {
	    var vshader = "";
	    vshader += options.animTexLoop ? shaderChunks.particleAnimFrameLoopVS : shaderChunks.particleAnimFrameClampVS;
	    vshader += shaderChunks.particleAnimTexVS;
	    return vshader;
	  },
	  createShaderDefinition: function createShaderDefinition(device, options) {
	    var vshader = "";
	    var fshader = precisionCode(device) + "\n";
	    fshader += '#define PARTICLE\n';

	    if (device.webgl2) {
	      vshader += "#define GL2\n";
	      fshader += "#define GL2\n";
	    }

	    vshader += "#define VERTEXSHADER\n";
	    if (options.mesh) vshader += "#define USE_MESH\n";
	    if (options.localSpace) vshader += "#define LOCAL_SPACE\n";
	    if (options.screenSpace) vshader += "#define SCREEN_SPACE\n";
	    if (options.animTex) vshader += "\nuniform vec2 animTexTilesParams;\n";
	    if (options.animTex) vshader += "\nuniform vec4 animTexParams;\n";
	    if (options.animTex) vshader += "\nuniform vec2 animTexIndexParams;\n";
	    if (options.normal === 2) vshader += "\nvarying mat3 ParticleMat;\n";
	    if (options.normal === 1) vshader += "\nvarying vec3 Normal;\n";
	    if (options.soft) vshader += "\nvarying float vDepth;\n";
	    var faceVS = options.customFace ? shaderChunks.particle_customFaceVS : shaderChunks.particle_billboardVS;

	    if (!options.useCpu) {
	      vshader += shaderChunks.particle_initVS;
	      vshader += options.pack8 ? shaderChunks.particleInputRgba8PS : shaderChunks.particleInputFloatPS;
	      if (options.soft > 0) vshader += shaderChunks.screenDepthPS;
	      vshader += shaderChunks.particleVS;
	      if (options.localSpace) vshader += shaderChunks.particle_localShiftVS;
	      if (options.animTex) vshader += this._animTex(options);
	      if (options.wrap) vshader += shaderChunks.particle_wrapVS;
	      if (options.alignToMotion) vshader += shaderChunks.particle_pointAlongVS;
	      vshader += options.mesh ? shaderChunks.particle_meshVS : faceVS;
	      if (options.normal === 1) vshader += shaderChunks.particle_normalVS;
	      if (options.normal === 2) vshader += shaderChunks.particle_TBNVS;
	      if (options.stretch > 0.0) vshader += shaderChunks.particle_stretchVS;
	      vshader += shaderChunks.particle_endVS;
	      if (options.soft > 0) vshader += shaderChunks.particle_softVS;
	    } else {
	      if (options.soft > 0) vshader += shaderChunks.screenDepthPS;
	      vshader += shaderChunks.particle_cpuVS;
	      if (options.localSpace) vshader += shaderChunks.particle_localShiftVS;
	      if (options.animTex) vshader += this._animTex(options);
	      if (options.alignToMotion) vshader += shaderChunks.particle_pointAlongVS;
	      vshader += options.mesh ? shaderChunks.particle_meshVS : faceVS;
	      if (options.normal === 1) vshader += shaderChunks.particle_normalVS;
	      if (options.normal === 2) vshader += shaderChunks.particle_TBNVS;
	      if (options.stretch > 0.0) vshader += shaderChunks.particle_stretchVS;
	      vshader += shaderChunks.particle_cpu_endVS;
	      if (options.soft > 0) vshader += shaderChunks.particle_softVS;
	    }

	    vshader += "}\n";

	    if (options.normal > 0) {
	      if (options.normal === 1) {
	        fshader += "\nvarying vec3 Normal;\n";
	      } else if (options.normal === 2) {
	        fshader += "\nvarying mat3 ParticleMat;\n";
	      }

	      fshader += "\nuniform vec3 lightCube[6];\n";
	    }

	    if (options.soft) fshader += "\nvarying float vDepth;\n";
	    if (options.normal === 0 && options.fog === "none") options.srgb = false;
	    fshader += shaderChunks.decodePS;
	    fshader += gammaCode(options.gamma);
	    fshader += tonemapCode(options.toneMap);

	    if (options.fog === 'linear') {
	      fshader += shaderChunks.fogLinearPS;
	    } else if (options.fog === 'exp') {
	      fshader += shaderChunks.fogExpPS;
	    } else if (options.fog === 'exp2') {
	      fshader += shaderChunks.fogExp2PS;
	    } else {
	      fshader += shaderChunks.fogNonePS;
	    }

	    if (options.normal === 2) fshader += "\nuniform sampler2D normalMap;\n";
	    if (options.soft > 0) fshader += shaderChunks.screenDepthPS;
	    fshader += shaderChunks.particlePS;
	    if (options.soft > 0) fshader += shaderChunks.particle_softPS;
	    if (options.normal === 1) fshader += "\nvec3 normal = Normal;\n";
	    if (options.normal === 2) fshader += shaderChunks.particle_normalMapPS;
	    if (options.normal > 0) fshader += options.halflambert ? shaderChunks.particle_halflambertPS : shaderChunks.particle_lambertPS;
	    if (options.normal > 0) fshader += shaderChunks.particle_lightingPS;

	    if (options.blend === BLEND_NORMAL) {
	      fshader += shaderChunks.particle_blendNormalPS;
	    } else if (options.blend === BLEND_ADDITIVE) {
	      fshader += shaderChunks.particle_blendAddPS;
	    } else if (options.blend === BLEND_MULTIPLICATIVE) {
	      fshader += shaderChunks.particle_blendMultiplyPS;
	    }

	    fshader += shaderChunks.particle_endPS;
	    var attributes = collectAttribs(vshader);
	    return {
	      attributes: attributes,
	      vshader: vshader,
	      fshader: fshader
	    };
	  }
	};

	var nonUniformScale;
	var uniformScale = 1;
	var particleTexChannels$1 = 4;
	var rotMat = new Mat4();
	var rotMatInv = new Mat4();
	var randomPosTformed = new Vec3();
	var randomPos = new Vec3();
	var rndFactor3Vec = new Vec3();
	var particlePosPrev = new Vec3();
	var velocityVec = new Vec3();
	var localVelocityVec = new Vec3();
	var velocityVec2 = new Vec3();
	var localVelocityVec2 = new Vec3();
	var radialVelocityVec = new Vec3();
	var particlePos = new Vec3();
	var particleFinalPos = new Vec3();
	var moveDirVec = new Vec3();
	var tmpVec3$1 = new Vec3();

	function frac(f) {
	  return f - Math.floor(f);
	}

	function saturate$1(x) {
	  return Math.max(Math.min(x, 1), 0);
	}

	function glMod(x, y) {
	  return x - y * Math.floor(x / y);
	}

	function encodeFloatRGBA(v) {
	  var encX = frac(v);
	  var encY = frac(255.0 * v);
	  var encZ = frac(65025.0 * v);
	  var encW = frac(160581375.0 * v);
	  encX -= encY / 255.0;
	  encY -= encZ / 255.0;
	  encZ -= encW / 255.0;
	  encW -= encW / 255.0;
	  return [encX, encY, encZ, encW];
	}

	function encodeFloatRG(v) {
	  var encX = frac(v);
	  var encY = frac(255.0 * v);
	  encX -= encY / 255.0;
	  encY -= encY / 255.0;
	  return [encX, encY];
	}

	var ParticleCPUUpdater = function () {
	  function ParticleCPUUpdater(emitter) {
	    this._emitter = emitter;
	  }

	  var _proto = ParticleCPUUpdater.prototype;

	  _proto.calcSpawnPosition = function calcSpawnPosition(particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, i) {
	    var emitter = this._emitter;
	    var rX = Math.random();
	    var rY = Math.random();
	    var rZ = Math.random();
	    var rW = Math.random();

	    if (emitter.useCpu) {
	      particleTex[i * particleTexChannels$1 + 0 + emitter.numParticlesPot * 2 * particleTexChannels$1] = rX;
	      particleTex[i * particleTexChannels$1 + 1 + emitter.numParticlesPot * 2 * particleTexChannels$1] = rY;
	      particleTex[i * particleTexChannels$1 + 2 + emitter.numParticlesPot * 2 * particleTexChannels$1] = rZ;
	    }

	    randomPos.x = rX - 0.5;
	    randomPos.y = rY - 0.5;
	    randomPos.z = rZ - 0.5;

	    if (emitter.emitterShape === EMITTERSHAPE_BOX) {
	      var max = Math.max(Math.abs(randomPos.x), Math.max(Math.abs(randomPos.y), Math.abs(randomPos.z)));
	      var edgeX = max + (0.5 - max) * extentsInnerRatioUniform[0];
	      var edgeY = max + (0.5 - max) * extentsInnerRatioUniform[1];
	      var edgeZ = max + (0.5 - max) * extentsInnerRatioUniform[2];
	      randomPos.x = edgeX * (max === Math.abs(randomPos.x) ? Math.sign(randomPos.x) : 2 * randomPos.x);
	      randomPos.y = edgeY * (max === Math.abs(randomPos.y) ? Math.sign(randomPos.y) : 2 * randomPos.y);
	      randomPos.z = edgeZ * (max === Math.abs(randomPos.z) ? Math.sign(randomPos.z) : 2 * randomPos.z);
	      if (!emitter.localSpace) randomPosTformed.copy(emitterPos).add(spawnMatrix.transformPoint(randomPos));else randomPosTformed.copy(spawnMatrix.transformPoint(randomPos));
	    } else {
	      randomPos.normalize();
	      var spawnBoundsSphereInnerRatio = emitter.emitterRadius === 0 ? 0 : emitter.emitterRadiusInner / emitter.emitterRadius;
	      var r = rW * (1.0 - spawnBoundsSphereInnerRatio) + spawnBoundsSphereInnerRatio;
	      if (!emitter.localSpace) randomPosTformed.copy(emitterPos).add(randomPos.mulScalar(r * emitter.emitterRadius));else randomPosTformed.copy(randomPos.mulScalar(r * emitter.emitterRadius));
	    }

	    var particleRate = math.lerp(emitter.rate, emitter.rate2, rX);
	    var startSpawnTime = -particleRate * i;

	    if (emitter.pack8) {
	      var packX = (randomPosTformed.x - emitter.worldBounds.center.x) / emitter.worldBoundsSize.x + 0.5;
	      var packY = (randomPosTformed.y - emitter.worldBounds.center.y) / emitter.worldBoundsSize.y + 0.5;
	      var packZ = (randomPosTformed.z - emitter.worldBounds.center.z) / emitter.worldBoundsSize.z + 0.5;
	      var packA = math.lerp(emitter.startAngle * math.DEG_TO_RAD, emitter.startAngle2 * math.DEG_TO_RAD, rX);
	      packA = packA % (Math.PI * 2) / (Math.PI * 2);
	      var rg0 = encodeFloatRG(packX);
	      particleTex[i * particleTexChannels$1] = rg0[0];
	      particleTex[i * particleTexChannels$1 + 1] = rg0[1];
	      var ba0 = encodeFloatRG(packY);
	      particleTex[i * particleTexChannels$1 + 2] = ba0[0];
	      particleTex[i * particleTexChannels$1 + 3] = ba0[1];
	      var rg1 = encodeFloatRG(packZ);
	      particleTex[i * particleTexChannels$1 + 0 + emitter.numParticlesPot * particleTexChannels$1] = rg1[0];
	      particleTex[i * particleTexChannels$1 + 1 + emitter.numParticlesPot * particleTexChannels$1] = rg1[1];
	      var ba1 = encodeFloatRG(packA);
	      particleTex[i * particleTexChannels$1 + 2 + emitter.numParticlesPot * particleTexChannels$1] = ba1[0];
	      particleTex[i * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1] = ba1[1];
	      var a2 = 1.0;
	      particleTex[i * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1 * 2] = a2;
	      var maxNegLife = Math.max(emitter.lifetime, (emitter.numParticles - 1.0) * Math.max(emitter.rate, emitter.rate2));
	      var maxPosLife = emitter.lifetime + 1.0;
	      startSpawnTime = (startSpawnTime + maxNegLife) / (maxNegLife + maxPosLife);
	      var rgba3 = encodeFloatRGBA(startSpawnTime);
	      particleTex[i * particleTexChannels$1 + 0 + emitter.numParticlesPot * particleTexChannels$1 * 3] = rgba3[0];
	      particleTex[i * particleTexChannels$1 + 1 + emitter.numParticlesPot * particleTexChannels$1 * 3] = rgba3[1];
	      particleTex[i * particleTexChannels$1 + 2 + emitter.numParticlesPot * particleTexChannels$1 * 3] = rgba3[2];
	      particleTex[i * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1 * 3] = rgba3[3];
	    } else {
	      particleTex[i * particleTexChannels$1] = randomPosTformed.x;
	      particleTex[i * particleTexChannels$1 + 1] = randomPosTformed.y;
	      particleTex[i * particleTexChannels$1 + 2] = randomPosTformed.z;
	      particleTex[i * particleTexChannels$1 + 3] = math.lerp(emitter.startAngle * math.DEG_TO_RAD, emitter.startAngle2 * math.DEG_TO_RAD, rX);
	      particleTex[i * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1] = startSpawnTime;
	    }
	  };

	  _proto.update = function update(data, vbToSort, particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, delta, isOnStop) {
	    var a, b, c;
	    var emitter = this._emitter;

	    if (emitter.meshInstance.node) {
	      var fullMat = emitter.meshInstance.node.worldTransform;

	      for (var j = 0; j < 12; j++) {
	        rotMat.data[j] = fullMat.data[j];
	      }

	      rotMatInv.copy(rotMat);
	      rotMatInv.invert();
	      nonUniformScale = emitter.meshInstance.node.localScale;
	      uniformScale = Math.max(Math.max(nonUniformScale.x, nonUniformScale.y), nonUniformScale.z);
	    }

	    emitterPos = emitter.meshInstance.node === null || emitter.localSpace ? Vec3.ZERO : emitter.meshInstance.node.getPosition();
	    var posCam = emitter.camera ? emitter.camera._node.getPosition() : Vec3.ZERO;
	    var vertSize = !emitter.useMesh ? 15 : 17;
	    var cf, cc;
	    var rotSpeed, rotSpeed2, scale2, alpha, alpha2, radialSpeed, radialSpeed2;
	    var precision1 = emitter.precision - 1;

	    for (var i = 0; i < emitter.numParticles; i++) {
	      var id = Math.floor(emitter.vbCPU[i * emitter.numParticleVerts * (emitter.useMesh ? 6 : 4) + 3]);
	      var rndFactor = particleTex[id * particleTexChannels$1 + 0 + emitter.numParticlesPot * 2 * particleTexChannels$1];
	      rndFactor3Vec.x = rndFactor;
	      rndFactor3Vec.y = particleTex[id * particleTexChannels$1 + 1 + emitter.numParticlesPot * 2 * particleTexChannels$1];
	      rndFactor3Vec.z = particleTex[id * particleTexChannels$1 + 2 + emitter.numParticlesPot * 2 * particleTexChannels$1];
	      var particleRate = emitter.rate + (emitter.rate2 - emitter.rate) * rndFactor;
	      var particleLifetime = emitter.lifetime;
	      var life = particleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1] + delta;
	      var nlife = saturate$1(life / particleLifetime);
	      var scale = 0;
	      var alphaDiv = 0;
	      var angle = 0;
	      var respawn = life - delta <= 0.0 || life >= particleLifetime;

	      if (respawn) {
	        this.calcSpawnPosition(particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, id);
	      }

	      var particleEnabled = life > 0.0 && life < particleLifetime;

	      if (particleEnabled) {
	        c = nlife * precision1;
	        cf = Math.floor(c);
	        cc = Math.ceil(c);
	        c %= 1;
	        a = emitter.qRotSpeed[cf];
	        b = emitter.qRotSpeed[cc];
	        rotSpeed = a + (b - a) * c;
	        a = emitter.qRotSpeed2[cf];
	        b = emitter.qRotSpeed2[cc];
	        rotSpeed2 = a + (b - a) * c;
	        a = emitter.qScale[cf];
	        b = emitter.qScale[cc];
	        scale = a + (b - a) * c;
	        a = emitter.qScale2[cf];
	        b = emitter.qScale2[cc];
	        scale2 = a + (b - a) * c;
	        a = emitter.qAlpha[cf];
	        b = emitter.qAlpha[cc];
	        alpha = a + (b - a) * c;
	        a = emitter.qAlpha2[cf];
	        b = emitter.qAlpha2[cc];
	        alpha2 = a + (b - a) * c;
	        a = emitter.qRadialSpeed[cf];
	        b = emitter.qRadialSpeed[cc];
	        radialSpeed = a + (b - a) * c;
	        a = emitter.qRadialSpeed2[cf];
	        b = emitter.qRadialSpeed2[cc];
	        radialSpeed2 = a + (b - a) * c;
	        radialSpeed += (radialSpeed2 - radialSpeed) * (rndFactor * 100.0 % 1.0);
	        particlePosPrev.x = particleTex[id * particleTexChannels$1];
	        particlePosPrev.y = particleTex[id * particleTexChannels$1 + 1];
	        particlePosPrev.z = particleTex[id * particleTexChannels$1 + 2];
	        if (!emitter.localSpace) radialVelocityVec.copy(particlePosPrev).sub(emitterPos);else radialVelocityVec.copy(particlePosPrev);
	        radialVelocityVec.normalize().mulScalar(radialSpeed);
	        cf *= 3;
	        cc *= 3;
	        a = emitter.qLocalVelocity[cf];
	        b = emitter.qLocalVelocity[cc];
	        localVelocityVec.x = a + (b - a) * c;
	        a = emitter.qLocalVelocity[cf + 1];
	        b = emitter.qLocalVelocity[cc + 1];
	        localVelocityVec.y = a + (b - a) * c;
	        a = emitter.qLocalVelocity[cf + 2];
	        b = emitter.qLocalVelocity[cc + 2];
	        localVelocityVec.z = a + (b - a) * c;
	        a = emitter.qLocalVelocity2[cf];
	        b = emitter.qLocalVelocity2[cc];
	        localVelocityVec2.x = a + (b - a) * c;
	        a = emitter.qLocalVelocity2[cf + 1];
	        b = emitter.qLocalVelocity2[cc + 1];
	        localVelocityVec2.y = a + (b - a) * c;
	        a = emitter.qLocalVelocity2[cf + 2];
	        b = emitter.qLocalVelocity2[cc + 2];
	        localVelocityVec2.z = a + (b - a) * c;
	        a = emitter.qVelocity[cf];
	        b = emitter.qVelocity[cc];
	        velocityVec.x = a + (b - a) * c;
	        a = emitter.qVelocity[cf + 1];
	        b = emitter.qVelocity[cc + 1];
	        velocityVec.y = a + (b - a) * c;
	        a = emitter.qVelocity[cf + 2];
	        b = emitter.qVelocity[cc + 2];
	        velocityVec.z = a + (b - a) * c;
	        a = emitter.qVelocity2[cf];
	        b = emitter.qVelocity2[cc];
	        velocityVec2.x = a + (b - a) * c;
	        a = emitter.qVelocity2[cf + 1];
	        b = emitter.qVelocity2[cc + 1];
	        velocityVec2.y = a + (b - a) * c;
	        a = emitter.qVelocity2[cf + 2];
	        b = emitter.qVelocity2[cc + 2];
	        velocityVec2.z = a + (b - a) * c;
	        localVelocityVec.x += (localVelocityVec2.x - localVelocityVec.x) * rndFactor3Vec.x;
	        localVelocityVec.y += (localVelocityVec2.y - localVelocityVec.y) * rndFactor3Vec.y;
	        localVelocityVec.z += (localVelocityVec2.z - localVelocityVec.z) * rndFactor3Vec.z;

	        if (emitter.initialVelocity > 0) {
	          if (emitter.emitterShape === EMITTERSHAPE_SPHERE) {
	            randomPos.copy(rndFactor3Vec).mulScalar(2).sub(Vec3.ONE).normalize();
	            localVelocityVec.add(randomPos.mulScalar(emitter.initialVelocity));
	          } else {
	            localVelocityVec.add(Vec3.FORWARD.mulScalar(emitter.initialVelocity));
	          }
	        }

	        velocityVec.x += (velocityVec2.x - velocityVec.x) * rndFactor3Vec.x;
	        velocityVec.y += (velocityVec2.y - velocityVec.y) * rndFactor3Vec.y;
	        velocityVec.z += (velocityVec2.z - velocityVec.z) * rndFactor3Vec.z;
	        rotSpeed += (rotSpeed2 - rotSpeed) * rndFactor3Vec.y;
	        scale = (scale + (scale2 - scale) * (rndFactor * 10000.0 % 1.0)) * uniformScale;
	        alphaDiv = (alpha2 - alpha) * (rndFactor * 1000.0 % 1.0);

	        if (emitter.meshInstance.node) {
	          if (!emitter.localSpace) {
	            rotMat.transformPoint(localVelocityVec, localVelocityVec);
	          } else {
	            localVelocityVec.x /= nonUniformScale.x;
	            localVelocityVec.y /= nonUniformScale.y;
	            localVelocityVec.z /= nonUniformScale.z;
	          }
	        }

	        if (!emitter.localSpace) {
	          localVelocityVec.add(velocityVec.mul(nonUniformScale));
	          localVelocityVec.add(radialVelocityVec.mul(nonUniformScale));
	        } else {
	          rotMatInv.transformPoint(velocityVec, velocityVec);
	          localVelocityVec.add(velocityVec).add(radialVelocityVec);
	        }

	        moveDirVec.copy(localVelocityVec);
	        particlePos.copy(particlePosPrev).add(localVelocityVec.mulScalar(delta));
	        particleFinalPos.copy(particlePos);
	        particleTex[id * particleTexChannels$1] = particleFinalPos.x;
	        particleTex[id * particleTexChannels$1 + 1] = particleFinalPos.y;
	        particleTex[id * particleTexChannels$1 + 2] = particleFinalPos.z;
	        particleTex[id * particleTexChannels$1 + 3] += rotSpeed * delta;

	        if (emitter.wrap && emitter.wrapBounds) {
	          if (!emitter.localSpace) particleFinalPos.sub(emitterPos);
	          particleFinalPos.x = glMod(particleFinalPos.x, emitter.wrapBounds.x) - emitter.wrapBounds.x * 0.5;
	          particleFinalPos.y = glMod(particleFinalPos.y, emitter.wrapBounds.y) - emitter.wrapBounds.y * 0.5;
	          particleFinalPos.z = glMod(particleFinalPos.z, emitter.wrapBounds.z) - emitter.wrapBounds.z * 0.5;
	          if (!emitter.localSpace) particleFinalPos.add(emitterPos);
	        }

	        if (emitter.sort > 0) {
	          if (emitter.sort === 1) {
	            tmpVec3$1.copy(particleFinalPos).sub(posCam);
	            emitter.particleDistance[id] = -(tmpVec3$1.x * tmpVec3$1.x + tmpVec3$1.y * tmpVec3$1.y + tmpVec3$1.z * tmpVec3$1.z);
	          } else if (emitter.sort === 2) {
	            emitter.particleDistance[id] = life;
	          } else if (emitter.sort === 3) {
	            emitter.particleDistance[id] = -life;
	          }
	        }
	      }

	      if (isOnStop) {
	        if (life < 0) {
	          particleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * 2 * particleTexChannels$1] = -1;
	        }
	      } else {
	        if (life >= particleLifetime) {
	          life -= Math.max(particleLifetime, (emitter.numParticles - 1) * particleRate);
	          particleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * 2 * particleTexChannels$1] = emitter.loop ? 1 : -1;
	        }

	        if (life < 0 && emitter.loop) {
	          particleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * 2 * particleTexChannels$1] = 1;
	        }
	      }

	      if (particleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * 2 * particleTexChannels$1] < 0) particleEnabled = false;
	      particleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1] = life;

	      for (var v = 0; v < emitter.numParticleVerts; v++) {
	        var vbOffset = (i * emitter.numParticleVerts + v) * (emitter.useMesh ? 6 : 4);
	        var quadX = emitter.vbCPU[vbOffset];
	        var quadY = emitter.vbCPU[vbOffset + 1];
	        var quadZ = emitter.vbCPU[vbOffset + 2];

	        if (!particleEnabled) {
	          quadX = quadY = quadZ = 0;
	        }

	        var w = i * emitter.numParticleVerts * vertSize + v * vertSize;
	        data[w] = particleFinalPos.x;
	        data[w + 1] = particleFinalPos.y;
	        data[w + 2] = particleFinalPos.z;
	        data[w + 3] = nlife;
	        data[w + 4] = emitter.alignToMotion ? angle : particleTex[id * particleTexChannels$1 + 3];
	        data[w + 5] = scale;
	        data[w + 6] = alphaDiv;
	        data[w + 7] = moveDirVec.x;
	        data[w + 8] = quadX;
	        data[w + 9] = quadY;
	        data[w + 10] = quadZ;
	        data[w + 11] = moveDirVec.y;
	        data[w + 12] = id;
	        data[w + 13] = moveDirVec.z;
	        data[w + 14] = emitter.vbCPU[vbOffset + 3];

	        if (emitter.useMesh) {
	          data[w + 15] = emitter.vbCPU[vbOffset + 4];
	          data[w + 16] = emitter.vbCPU[vbOffset + 5];
	        }
	      }
	    }

	    if (emitter.sort > PARTICLESORT_NONE && emitter.camera) {
	      var vbStride = emitter.useMesh ? 6 : 4;
	      var particleDistance = emitter.particleDistance;

	      for (var _i = 0; _i < emitter.numParticles; _i++) {
	        vbToSort[_i][0] = _i;
	        vbToSort[_i][1] = particleDistance[Math.floor(emitter.vbCPU[_i * emitter.numParticleVerts * vbStride + 3])];
	      }

	      emitter.vbOld.set(emitter.vbCPU);
	      vbToSort.sort(function (p1, p2) {
	        return p1[1] - p2[1];
	      });

	      for (var _i2 = 0; _i2 < emitter.numParticles; _i2++) {
	        var src = vbToSort[_i2][0] * emitter.numParticleVerts * vbStride;
	        var dest = _i2 * emitter.numParticleVerts * vbStride;

	        for (var _j = 0; _j < emitter.numParticleVerts * vbStride; _j++) {
	          emitter.vbCPU[dest + _j] = emitter.vbOld[src + _j];
	        }
	      }
	    }
	  };

	  return ParticleCPUUpdater;
	}();

	var spawnMatrix3 = new Mat3();
	var emitterMatrix3 = new Mat3();
	var emitterMatrix3Inv = new Mat3();

	var ParticleGPUUpdater = function () {
	  function ParticleGPUUpdater(emitter, gd) {
	    this._emitter = emitter;
	    this.frameRandomUniform = new Float32Array(3);
	    this.emitterPosUniform = new Float32Array(3);
	    this.emitterScaleUniform = new Float32Array([1, 1, 1]);
	    this.worldBoundsMulUniform = new Float32Array(3);
	    this.worldBoundsAddUniform = new Float32Array(3);
	    this.inBoundsSizeUniform = new Float32Array(3);
	    this.inBoundsCenterUniform = new Float32Array(3);
	    this.constantParticleTexIN = gd.scope.resolve('particleTexIN');
	    this.constantParticleTexOUT = gd.scope.resolve('particleTexOUT');
	    this.constantEmitterPos = gd.scope.resolve('emitterPos');
	    this.constantEmitterScale = gd.scope.resolve('emitterScale');
	    this.constantSpawnBounds = gd.scope.resolve('spawnBounds');
	    this.constantSpawnPosInnerRatio = gd.scope.resolve('spawnPosInnerRatio');
	    this.constantSpawnBoundsSphere = gd.scope.resolve('spawnBoundsSphere');
	    this.constantSpawnBoundsSphereInnerRatio = gd.scope.resolve('spawnBoundsSphereInnerRatio');
	    this.constantInitialVelocity = gd.scope.resolve('initialVelocity');
	    this.constantFrameRandom = gd.scope.resolve('frameRandom');
	    this.constantDelta = gd.scope.resolve('delta');
	    this.constantRate = gd.scope.resolve('rate');
	    this.constantRateDiv = gd.scope.resolve('rateDiv');
	    this.constantLifetime = gd.scope.resolve('lifetime');
	    this.constantGraphSampleSize = gd.scope.resolve('graphSampleSize');
	    this.constantGraphNumSamples = gd.scope.resolve('graphNumSamples');
	    this.constantInternalTex0 = gd.scope.resolve('internalTex0');
	    this.constantInternalTex1 = gd.scope.resolve('internalTex1');
	    this.constantInternalTex2 = gd.scope.resolve('internalTex2');
	    this.constantInternalTex3 = gd.scope.resolve('internalTex3');
	    this.constantEmitterMatrix = gd.scope.resolve('emitterMatrix');
	    this.constantEmitterMatrixInv = gd.scope.resolve('emitterMatrixInv');
	    this.constantNumParticles = gd.scope.resolve('numParticles');
	    this.constantNumParticlesPot = gd.scope.resolve('numParticlesPot');
	    this.constantLocalVelocityDivMult = gd.scope.resolve('localVelocityDivMult');
	    this.constantVelocityDivMult = gd.scope.resolve('velocityDivMult');
	    this.constantRotSpeedDivMult = gd.scope.resolve('rotSpeedDivMult');
	    this.constantSeed = gd.scope.resolve('seed');
	    this.constantStartAngle = gd.scope.resolve('startAngle');
	    this.constantStartAngle2 = gd.scope.resolve('startAngle2');
	    this.constantOutBoundsMul = gd.scope.resolve('outBoundsMul');
	    this.constantOutBoundsAdd = gd.scope.resolve('outBoundsAdd');
	    this.constantInBoundsSize = gd.scope.resolve('inBoundsSize');
	    this.constantInBoundsCenter = gd.scope.resolve('inBoundsCenter');
	    this.constantMaxVel = gd.scope.resolve('maxVel');
	    this.constantFaceTangent = gd.scope.resolve('faceTangent');
	    this.constantFaceBinorm = gd.scope.resolve('faceBinorm');
	  }

	  var _proto = ParticleGPUUpdater.prototype;

	  _proto._setInputBounds = function _setInputBounds() {
	    this.inBoundsSizeUniform[0] = this._emitter.prevWorldBoundsSize.x;
	    this.inBoundsSizeUniform[1] = this._emitter.prevWorldBoundsSize.y;
	    this.inBoundsSizeUniform[2] = this._emitter.prevWorldBoundsSize.z;
	    this.constantInBoundsSize.setValue(this.inBoundsSizeUniform);
	    this.inBoundsCenterUniform[0] = this._emitter.prevWorldBoundsCenter.x;
	    this.inBoundsCenterUniform[1] = this._emitter.prevWorldBoundsCenter.y;
	    this.inBoundsCenterUniform[2] = this._emitter.prevWorldBoundsCenter.z;
	    this.constantInBoundsCenter.setValue(this.inBoundsCenterUniform);
	  };

	  _proto.randomize = function randomize() {
	    this.frameRandomUniform[0] = Math.random();
	    this.frameRandomUniform[1] = Math.random();
	    this.frameRandomUniform[2] = Math.random();
	  };

	  _proto.update = function update(device, spawnMatrix, extentsInnerRatioUniform, delta, isOnStop) {
	    var emitter = this._emitter;
	    device.setBlending(false);
	    device.setColorWrite(true, true, true, true);
	    device.setCullMode(CULLFACE_NONE);
	    device.setDepthTest(false);
	    device.setDepthWrite(false);
	    this.randomize();
	    this.constantGraphSampleSize.setValue(1.0 / emitter.precision);
	    this.constantGraphNumSamples.setValue(emitter.precision);
	    this.constantNumParticles.setValue(emitter.numParticles);
	    this.constantNumParticlesPot.setValue(emitter.numParticlesPot);
	    this.constantInternalTex0.setValue(emitter.internalTex0);
	    this.constantInternalTex1.setValue(emitter.internalTex1);
	    this.constantInternalTex2.setValue(emitter.internalTex2);
	    this.constantInternalTex3.setValue(emitter.internalTex3);
	    var node = emitter.meshInstance.node;
	    var emitterScale = node === null ? Vec3.ONE : node.localScale;

	    if (emitter.pack8) {
	      this.worldBoundsMulUniform[0] = emitter.worldBoundsMul.x;
	      this.worldBoundsMulUniform[1] = emitter.worldBoundsMul.y;
	      this.worldBoundsMulUniform[2] = emitter.worldBoundsMul.z;
	      this.constantOutBoundsMul.setValue(this.worldBoundsMulUniform);
	      this.worldBoundsAddUniform[0] = emitter.worldBoundsAdd.x;
	      this.worldBoundsAddUniform[1] = emitter.worldBoundsAdd.y;
	      this.worldBoundsAddUniform[2] = emitter.worldBoundsAdd.z;
	      this.constantOutBoundsAdd.setValue(this.worldBoundsAddUniform);

	      this._setInputBounds();

	      var maxVel = emitter.maxVel * Math.max(Math.max(emitterScale.x, emitterScale.y), emitterScale.z);
	      maxVel = Math.max(maxVel, 1);
	      this.constantMaxVel.setValue(maxVel);
	    }

	    var emitterPos = node === null || emitter.localSpace ? Vec3.ZERO : node.getPosition();
	    var emitterMatrix = node === null ? Mat4.IDENTITY : node.getWorldTransform();

	    if (emitter.emitterShape === EMITTERSHAPE_BOX) {
	      spawnMatrix3.setFromMat4(spawnMatrix);
	      this.constantSpawnBounds.setValue(spawnMatrix3.data);
	      this.constantSpawnPosInnerRatio.setValue(extentsInnerRatioUniform);
	    } else {
	      this.constantSpawnBoundsSphere.setValue(emitter.emitterRadius);
	      this.constantSpawnBoundsSphereInnerRatio.setValue(emitter.emitterRadius === 0 ? 0 : emitter.emitterRadiusInner / emitter.emitterRadius);
	    }

	    this.constantInitialVelocity.setValue(emitter.initialVelocity);
	    emitterMatrix3.setFromMat4(emitterMatrix);
	    emitterMatrix.invertTo3x3(emitterMatrix3Inv);
	    this.emitterPosUniform[0] = emitterPos.x;
	    this.emitterPosUniform[1] = emitterPos.y;
	    this.emitterPosUniform[2] = emitterPos.z;
	    this.constantEmitterPos.setValue(this.emitterPosUniform);
	    this.constantFrameRandom.setValue(this.frameRandomUniform);
	    this.constantDelta.setValue(delta);
	    this.constantRate.setValue(emitter.rate);
	    this.constantRateDiv.setValue(emitter.rate2 - emitter.rate);
	    this.constantStartAngle.setValue(emitter.startAngle * math.DEG_TO_RAD);
	    this.constantStartAngle2.setValue(emitter.startAngle2 * math.DEG_TO_RAD);
	    this.constantSeed.setValue(emitter.seed);
	    this.constantLifetime.setValue(emitter.lifetime);
	    this.emitterScaleUniform[0] = emitterScale.x;
	    this.emitterScaleUniform[1] = emitterScale.y;
	    this.emitterScaleUniform[2] = emitterScale.z;
	    this.constantEmitterScale.setValue(this.emitterScaleUniform);
	    this.constantEmitterMatrix.setValue(emitterMatrix3.data);
	    this.constantEmitterMatrixInv.setValue(emitterMatrix3Inv.data);
	    this.constantLocalVelocityDivMult.setValue(emitter.localVelocityUMax);
	    this.constantVelocityDivMult.setValue(emitter.velocityUMax);
	    this.constantRotSpeedDivMult.setValue(emitter.rotSpeedUMax[0]);
	    var texIN = emitter.swapTex ? emitter.particleTexOUT : emitter.particleTexIN;
	    texIN = emitter.beenReset ? emitter.particleTexStart : texIN;
	    var texOUT = emitter.swapTex ? emitter.particleTexIN : emitter.particleTexOUT;
	    this.constantParticleTexIN.setValue(texIN);
	    drawQuadWithShader(device, emitter.swapTex ? emitter.rtParticleTexIN : emitter.rtParticleTexOUT, !isOnStop ? emitter.loop ? emitter.shaderParticleUpdateRespawn : emitter.shaderParticleUpdateNoRespawn : emitter.shaderParticleUpdateOnStop);
	    emitter.material.setParameter('particleTexOUT', texIN);
	    emitter.material.setParameter('particleTexIN', texOUT);
	    emitter.beenReset = false;
	    emitter.swapTex = !emitter.swapTex;
	    device.setDepthTest(true);
	    device.setDepthWrite(true);
	    emitter.prevWorldBoundsSize.copy(emitter.worldBoundsSize);
	    emitter.prevWorldBoundsCenter.copy(emitter.worldBounds.center);
	    if (emitter.pack8) this._setInputBounds();
	  };

	  return ParticleGPUUpdater;
	}();

	var particleVerts = [[-1, -1], [1, -1], [1, 1], [-1, 1]];

	function _createTexture(device, width, height, pixelData, format, mult8Bit, filter) {
	  if (format === void 0) {
	    format = PIXELFORMAT_RGBA32F;
	  }

	  var mipFilter = FILTER_NEAREST;
	  if (filter && format === PIXELFORMAT_R8_G8_B8_A8) mipFilter = FILTER_LINEAR;
	  var texture = new Texture(device, {
	    width: width,
	    height: height,
	    format: format,
	    cubemap: false,
	    mipmaps: false,
	    minFilter: mipFilter,
	    magFilter: mipFilter,
	    addressU: ADDRESS_CLAMP_TO_EDGE,
	    addressV: ADDRESS_CLAMP_TO_EDGE,
	    name: 'ParticleSystemTexture'
	  });
	  var pixels = texture.lock();

	  if (format === PIXELFORMAT_R8_G8_B8_A8) {
	    var temp = new Uint8Array(pixelData.length);

	    for (var i = 0; i < pixelData.length; i++) {
	      temp[i] = pixelData[i] * mult8Bit * 255;
	    }

	    pixelData = temp;
	  }

	  pixels.set(pixelData);
	  texture.unlock();
	  return texture;
	}

	function saturate(x) {
	  return Math.max(Math.min(x, 1), 0);
	}

	var default0Curve = new Curve([0, 0, 1, 0]);
	var default1Curve = new Curve([0, 1, 1, 1]);
	var default0Curve3 = new CurveSet([0, 0, 1, 0], [0, 0, 1, 0], [0, 0, 1, 0]);
	var default1Curve3 = new CurveSet([0, 1, 1, 1], [0, 1, 1, 1], [0, 1, 1, 1]);
	var particleTexHeight = 2;
	var particleTexChannels = 4;
	var extentsInnerRatioUniform = new Float32Array(3);
	var spawnMatrix = new Mat4();
	var tmpVec3 = new Vec3();
	var bMin = new Vec3();
	var bMax = new Vec3();
	var setPropertyTarget;
	var setPropertyOptions;

	function setProperty(pName, defaultVal) {
	  if (setPropertyOptions[pName] !== undefined && setPropertyOptions[pName] !== null) {
	    setPropertyTarget[pName] = setPropertyOptions[pName];
	  } else {
	    setPropertyTarget[pName] = defaultVal;
	  }
	}

	function pack3NFloats(a, b, c) {
	  var packed = a * 255 << 16 | b * 255 << 8 | c * 255;
	  return packed / (1 << 24);
	}

	function packTextureXYZ_NXYZ(qXYZ, qXYZ2) {
	  var num = qXYZ.length / 3;
	  var colors = new Array(num * 4);

	  for (var i = 0; i < num; i++) {
	    colors[i * 4] = qXYZ[i * 3];
	    colors[i * 4 + 1] = qXYZ[i * 3 + 1];
	    colors[i * 4 + 2] = qXYZ[i * 3 + 2];
	    colors[i * 4 + 3] = pack3NFloats(qXYZ2[i * 3], qXYZ2[i * 3 + 1], qXYZ2[i * 3 + 2]);
	  }

	  return colors;
	}

	function packTextureRGBA(qRGB, qA) {
	  var colors = new Array(qA.length * 4);

	  for (var i = 0; i < qA.length; i++) {
	    colors[i * 4] = qRGB[i * 3];
	    colors[i * 4 + 1] = qRGB[i * 3 + 1];
	    colors[i * 4 + 2] = qRGB[i * 3 + 2];
	    colors[i * 4 + 3] = qA[i];
	  }

	  return colors;
	}

	function packTexture5Floats(qA, qB, qC, qD, qE) {
	  var colors = new Array(qA.length * 4);

	  for (var i = 0; i < qA.length; i++) {
	    colors[i * 4] = qA[i];
	    colors[i * 4 + 1] = qB[i];
	    colors[i * 4 + 2] = 0;
	    colors[i * 4 + 3] = pack3NFloats(qC[i], qD[i], qE[i]);
	  }

	  return colors;
	}

	function packTexture2Floats(qA, qB) {
	  var colors = new Array(qA.length * 4);

	  for (var i = 0; i < qA.length; i++) {
	    colors[i * 4] = qA[i];
	    colors[i * 4 + 1] = qB[i];
	    colors[i * 4 + 2] = 0;
	    colors[i * 4 + 3] = 0;
	  }

	  return colors;
	}

	function calcEndTime(emitter) {
	  var interval = Math.max(emitter.rate, emitter.rate2) * emitter.numParticles + emitter.lifetime;
	  return Date.now() + interval * 1000;
	}

	function subGraph(A, B) {
	  var r = new Float32Array(A.length);

	  for (var i = 0; i < A.length; i++) {
	    r[i] = A[i] - B[i];
	  }

	  return r;
	}

	function maxUnsignedGraphValue(A, outUMax) {
	  var chans = outUMax.length;
	  var values = A.length / chans;

	  for (var i = 0; i < values; i++) {
	    for (var j = 0; j < chans; j++) {
	      var a = Math.abs(A[i * chans + j]);
	      outUMax[j] = Math.max(outUMax[j], a);
	    }
	  }
	}

	function normalizeGraph(A, uMax) {
	  var chans = uMax.length;
	  var values = A.length / chans;

	  for (var i = 0; i < values; i++) {
	    for (var j = 0; j < chans; j++) {
	      A[i * chans + j] /= uMax[j] === 0 ? 1 : uMax[j];
	      A[i * chans + j] *= 0.5;
	      A[i * chans + j] += 0.5;
	    }
	  }
	}

	function divGraphFrom2Curves(curve1, curve2, outUMax) {
	  var sub = subGraph(curve2, curve1);
	  maxUnsignedGraphValue(sub, outUMax);
	  normalizeGraph(sub, outUMax);
	  return sub;
	}

	var particleEmitterDeviceCache = new DeviceCache();

	var ParticleEmitter = function () {
	  function ParticleEmitter(graphicsDevice, options) {
	    this.graphicsDevice = graphicsDevice;
	    var gd = graphicsDevice;
	    var precision = 32;
	    this.precision = precision;
	    this._addTimeTime = 0;
	    setPropertyTarget = this;
	    setPropertyOptions = options;
	    setProperty('numParticles', 1);

	    if (this.numParticles > graphicsDevice.maxTextureSize) {
	      this.numParticles = graphicsDevice.maxTextureSize;
	    }

	    setProperty('rate', 1);
	    setProperty('rate2', this.rate);
	    setProperty('lifetime', 50);
	    setProperty('emitterExtents', new Vec3(0, 0, 0));
	    setProperty('emitterExtentsInner', new Vec3(0, 0, 0));
	    setProperty('emitterRadius', 0);
	    setProperty('emitterRadiusInner', 0);
	    setProperty('emitterShape', EMITTERSHAPE_BOX);
	    setProperty('initialVelocity', 1);
	    setProperty('wrap', false);
	    setProperty('localSpace', false);
	    setProperty('screenSpace', false);
	    setProperty('wrapBounds', null);
	    setProperty('colorMap', this.defaultParamTexture);
	    setProperty('normalMap', null);
	    setProperty('loop', true);
	    setProperty('preWarm', false);
	    setProperty('sort', PARTICLESORT_NONE);
	    setProperty('mode', PARTICLEMODE_GPU);
	    setProperty('scene', null);
	    setProperty('lighting', false);
	    setProperty('halfLambert', false);
	    setProperty('intensity', 1.0);
	    setProperty('stretch', 0.0);
	    setProperty('alignToMotion', false);
	    setProperty('depthSoftening', 0);
	    setProperty('mesh', null);
	    setProperty('particleNormal', new Vec3(0, 1, 0));
	    setProperty('orientation', PARTICLEORIENTATION_SCREEN);
	    setProperty('depthWrite', false);
	    setProperty('noFog', false);
	    setProperty('blendType', BLEND_NORMAL);
	    setProperty('node', null);
	    setProperty('startAngle', 0);
	    setProperty('startAngle2', this.startAngle);
	    setProperty('animTilesX', 1);
	    setProperty('animTilesY', 1);
	    setProperty('animStartFrame', 0);
	    setProperty('animNumFrames', 1);
	    setProperty('animNumAnimations', 1);
	    setProperty('animIndex', 0);
	    setProperty('randomizeAnimIndex', false);
	    setProperty('animSpeed', 1);
	    setProperty('animLoop', true);
	    this._gpuUpdater = new ParticleGPUUpdater(this, gd);
	    this._cpuUpdater = new ParticleCPUUpdater(this);
	    this.constantLightCube = gd.scope.resolve('lightCube[0]');
	    this.emitterPosUniform = new Float32Array(3);
	    this.wrapBoundsUniform = new Float32Array(3);
	    this.emitterScaleUniform = new Float32Array([1, 1, 1]);
	    setProperty('colorGraph', default1Curve3);
	    setProperty('colorGraph2', this.colorGraph);
	    setProperty('scaleGraph', default1Curve);
	    setProperty('scaleGraph2', this.scaleGraph);
	    setProperty('alphaGraph', default1Curve);
	    setProperty('alphaGraph2', this.alphaGraph);
	    setProperty('localVelocityGraph', default0Curve3);
	    setProperty('localVelocityGraph2', this.localVelocityGraph);
	    setProperty('velocityGraph', default0Curve3);
	    setProperty('velocityGraph2', this.velocityGraph);
	    setProperty('rotationSpeedGraph', default0Curve);
	    setProperty('rotationSpeedGraph2', this.rotationSpeedGraph);
	    setProperty('radialSpeedGraph', default0Curve);
	    setProperty('radialSpeedGraph2', this.radialSpeedGraph);
	    this.lightCube = new Float32Array(6 * 3);
	    this.lightCubeDir = new Array(6);
	    this.lightCubeDir[0] = new Vec3(-1, 0, 0);
	    this.lightCubeDir[1] = new Vec3(1, 0, 0);
	    this.lightCubeDir[2] = new Vec3(0, -1, 0);
	    this.lightCubeDir[3] = new Vec3(0, 1, 0);
	    this.lightCubeDir[4] = new Vec3(0, 0, -1);
	    this.lightCubeDir[5] = new Vec3(0, 0, 1);
	    this.animTilesParams = new Float32Array(2);
	    this.animParams = new Float32Array(4);
	    this.animIndexParams = new Float32Array(2);
	    this.internalTex0 = null;
	    this.internalTex1 = null;
	    this.internalTex2 = null;
	    this.colorParam = null;
	    this.vbToSort = null;
	    this.vbOld = null;
	    this.particleDistance = null;
	    this.camera = null;
	    this.swapTex = false;
	    this.useMesh = true;
	    this.useCpu = !graphicsDevice.supportsGpuParticles;
	    this.pack8 = true;
	    this.localBounds = new BoundingBox();
	    this.worldBoundsNoTrail = new BoundingBox();
	    this.worldBoundsTrail = [new BoundingBox(), new BoundingBox()];
	    this.worldBounds = new BoundingBox();
	    this.worldBoundsSize = new Vec3();
	    this.prevWorldBoundsSize = new Vec3();
	    this.prevWorldBoundsCenter = new Vec3();
	    this.prevEmitterExtents = this.emitterExtents;
	    this.prevEmitterRadius = this.emitterRadius;
	    this.worldBoundsMul = new Vec3();
	    this.worldBoundsAdd = new Vec3();
	    this.timeToSwitchBounds = 0;
	    this.shaderParticleUpdateRespawn = null;
	    this.shaderParticleUpdateNoRespawn = null;
	    this.shaderParticleUpdateOnStop = null;
	    this.numParticleVerts = 0;
	    this.numParticleIndices = 0;
	    this.material = null;
	    this.meshInstance = null;
	    this.drawOrder = 0;
	    this.seed = Math.random();
	    this.fixedTimeStep = 1.0 / 60;
	    this.maxSubSteps = 10;
	    this.simTime = 0;
	    this.simTimeTotal = 0;
	    this.beenReset = false;
	    this._layer = null;
	    this.rebuild();
	  }

	  var _proto = ParticleEmitter.prototype;

	  _proto.onChangeCamera = function onChangeCamera() {
	    this.regenShader();
	    this.resetMaterial();
	  };

	  _proto.calculateBoundsMad = function calculateBoundsMad() {
	    this.worldBoundsMul.x = 1.0 / this.worldBoundsSize.x;
	    this.worldBoundsMul.y = 1.0 / this.worldBoundsSize.y;
	    this.worldBoundsMul.z = 1.0 / this.worldBoundsSize.z;
	    this.worldBoundsAdd.copy(this.worldBounds.center).mul(this.worldBoundsMul).mulScalar(-1);
	    this.worldBoundsAdd.x += 0.5;
	    this.worldBoundsAdd.y += 0.5;
	    this.worldBoundsAdd.z += 0.5;
	  };

	  _proto.calculateWorldBounds = function calculateWorldBounds() {
	    if (!this.node) return;
	    this.prevWorldBoundsSize.copy(this.worldBoundsSize);
	    this.prevWorldBoundsCenter.copy(this.worldBounds.center);

	    if (!this.useCpu) {
	      var recalculateLocalBounds = false;

	      if (this.emitterShape === EMITTERSHAPE_BOX) {
	        recalculateLocalBounds = !this.emitterExtents.equals(this.prevEmitterExtents);
	      } else {
	        recalculateLocalBounds = !(this.emitterRadius === this.prevEmitterRadius);
	      }

	      if (recalculateLocalBounds) {
	        this.calculateLocalBounds();
	      }
	    }

	    var nodeWT = this.node.getWorldTransform();

	    if (this.localSpace) {
	      this.worldBoundsNoTrail.copy(this.localBounds);
	    } else {
	      this.worldBoundsNoTrail.setFromTransformedAabb(this.localBounds, nodeWT);
	    }

	    this.worldBoundsTrail[0].add(this.worldBoundsNoTrail);
	    this.worldBoundsTrail[1].add(this.worldBoundsNoTrail);
	    var now = this.simTimeTotal;

	    if (now >= this.timeToSwitchBounds) {
	      this.worldBoundsTrail[0].copy(this.worldBoundsTrail[1]);
	      this.worldBoundsTrail[1].copy(this.worldBoundsNoTrail);
	      this.timeToSwitchBounds = now + this.lifetime;
	    }

	    this.worldBounds.copy(this.worldBoundsTrail[0]);
	    this.worldBoundsSize.copy(this.worldBounds.halfExtents).mulScalar(2);

	    if (this.localSpace) {
	      this.meshInstance.aabb.setFromTransformedAabb(this.worldBounds, nodeWT);
	      this.meshInstance.mesh.aabb.setFromTransformedAabb(this.worldBounds, nodeWT);
	    } else {
	      this.meshInstance.aabb.copy(this.worldBounds);
	      this.meshInstance.mesh.aabb.copy(this.worldBounds);
	    }

	    this.meshInstance._aabbVer = 1 - this.meshInstance._aabbVer;
	    if (this.pack8) this.calculateBoundsMad();
	  };

	  _proto.resetWorldBounds = function resetWorldBounds() {
	    if (!this.node) return;
	    this.worldBoundsNoTrail.setFromTransformedAabb(this.localBounds, this.localSpace ? Mat4.IDENTITY : this.node.getWorldTransform());
	    this.worldBoundsTrail[0].copy(this.worldBoundsNoTrail);
	    this.worldBoundsTrail[1].copy(this.worldBoundsNoTrail);
	    this.worldBounds.copy(this.worldBoundsTrail[0]);
	    this.worldBoundsSize.copy(this.worldBounds.halfExtents).mulScalar(2);
	    this.prevWorldBoundsSize.copy(this.worldBoundsSize);
	    this.prevWorldBoundsCenter.copy(this.worldBounds.center);
	    this.simTimeTotal = 0;
	    this.timeToSwitchBounds = 0;
	  };

	  _proto.calculateLocalBounds = function calculateLocalBounds() {
	    var minx = Number.MAX_VALUE;
	    var miny = Number.MAX_VALUE;
	    var minz = Number.MAX_VALUE;
	    var maxx = -Number.MAX_VALUE;
	    var maxy = -Number.MAX_VALUE;
	    var maxz = -Number.MAX_VALUE;
	    var maxR = 0;
	    var maxScale = 0;
	    var stepWeight = this.lifetime / this.precision;
	    var wVels = [this.qVelocity, this.qVelocity2];
	    var lVels = [this.qLocalVelocity, this.qLocalVelocity2];
	    var accumX = [0, 0];
	    var accumY = [0, 0];
	    var accumZ = [0, 0];
	    var accumR = [0, 0];
	    var accumW = [0, 0];
	    var x, y, z;

	    for (var i = 0; i < this.precision + 1; i++) {
	      var index = Math.min(i, this.precision - 1);

	      for (var j = 0; j < 2; j++) {
	        x = lVels[j][index * 3 + 0] * stepWeight + accumX[j];
	        y = lVels[j][index * 3 + 1] * stepWeight + accumY[j];
	        z = lVels[j][index * 3 + 2] * stepWeight + accumZ[j];
	        minx = Math.min(x, minx);
	        miny = Math.min(y, miny);
	        minz = Math.min(z, minz);
	        maxx = Math.max(x, maxx);
	        maxy = Math.max(y, maxy);
	        maxz = Math.max(z, maxz);
	        accumX[j] = x;
	        accumY[j] = y;
	        accumZ[j] = z;
	      }

	      for (var _j = 0; _j < 2; _j++) {
	        accumW[_j] += stepWeight * Math.sqrt(wVels[_j][index * 3 + 0] * wVels[_j][index * 3 + 0] + wVels[_j][index * 3 + 1] * wVels[_j][index * 3 + 1] + wVels[_j][index * 3 + 2] * wVels[_j][index * 3 + 2]);
	      }

	      accumR[0] += this.qRadialSpeed[index] * stepWeight;
	      accumR[1] += this.qRadialSpeed2[index] * stepWeight;
	      maxR = Math.max(maxR, Math.max(Math.abs(accumR[0]), Math.abs(accumR[1])));
	      maxScale = Math.max(maxScale, this.qScale[index]);
	    }

	    if (this.emitterShape === EMITTERSHAPE_BOX) {
	      x = this.emitterExtents.x * 0.5;
	      y = this.emitterExtents.y * 0.5;
	      z = this.emitterExtents.z * 0.5;
	    } else {
	      x = this.emitterRadius;
	      y = this.emitterRadius;
	      z = this.emitterRadius;
	    }

	    var w = Math.max(accumW[0], accumW[1]);
	    bMin.x = minx - maxScale - x - maxR - w;
	    bMin.y = miny - maxScale - y - maxR - w;
	    bMin.z = minz - maxScale - z - maxR - w;
	    bMax.x = maxx + maxScale + x + maxR + w;
	    bMax.y = maxy + maxScale + y + maxR + w;
	    bMax.z = maxz + maxScale + z + maxR + w;
	    this.localBounds.setMinMax(bMin, bMax);
	  };

	  _proto.rebuild = function rebuild() {
	    var gd = this.graphicsDevice;
	    if (this.colorMap === null) this.colorMap = this.defaultParamTexture;
	    this.spawnBounds = this.emitterShape === EMITTERSHAPE_BOX ? this.emitterExtents : this.emitterRadius;
	    this.useCpu = this.useCpu || this.sort > PARTICLESORT_NONE || gd.maxVertexTextures <= 1 || gd.fragmentUniformsCount < 64 || gd.forceCpuParticles || !gd.extTextureFloat;

	    this._destroyResources();

	    this.pack8 = (this.pack8 || !gd.textureFloatRenderable) && !this.useCpu;
	    particleTexHeight = this.useCpu || this.pack8 ? 4 : 2;
	    this.useMesh = false;

	    if (this.mesh) {
	      var totalVertCount = this.numParticles * this.mesh.vertexBuffer.numVertices;

	      if (totalVertCount > 65535) ; else {
	        this.useMesh = true;
	      }
	    }

	    this.numParticlesPot = math.nextPowerOfTwo(this.numParticles);
	    this.rebuildGraphs();
	    this.calculateLocalBounds();
	    this.resetWorldBounds();

	    if (this.node) {
	      this.worldBounds.setFromTransformedAabb(this.localBounds, this.localSpace ? Mat4.IDENTITY : this.node.getWorldTransform());
	      this.worldBoundsTrail[0].copy(this.worldBounds);
	      this.worldBoundsTrail[1].copy(this.worldBounds);
	      this.worldBoundsSize.copy(this.worldBounds.halfExtents).mulScalar(2);
	      this.prevWorldBoundsSize.copy(this.worldBoundsSize);
	      this.prevWorldBoundsCenter.copy(this.worldBounds.center);
	      if (this.pack8) this.calculateBoundsMad();
	    }

	    this.vbToSort = new Array(this.numParticles);

	    for (var iSort = 0; iSort < this.numParticles; iSort++) {
	      this.vbToSort[iSort] = [0, 0];
	    }

	    this.particleDistance = new Float32Array(this.numParticles);

	    this._gpuUpdater.randomize();

	    this.particleTex = new Float32Array(this.numParticlesPot * particleTexHeight * particleTexChannels);
	    var emitterPos = this.node === null || this.localSpace ? Vec3.ZERO : this.node.getPosition();

	    if (this.emitterShape === EMITTERSHAPE_BOX) {
	      if (this.node === null || this.localSpace) {
	        spawnMatrix.setTRS(Vec3.ZERO, Quat.IDENTITY, this.spawnBounds);
	      } else {
	        spawnMatrix.setTRS(Vec3.ZERO, this.node.getRotation(), tmpVec3.copy(this.spawnBounds).mul(this.node.localScale));
	      }

	      extentsInnerRatioUniform[0] = this.emitterExtents.x !== 0 ? this.emitterExtentsInner.x / this.emitterExtents.x : 0;
	      extentsInnerRatioUniform[1] = this.emitterExtents.y !== 0 ? this.emitterExtentsInner.y / this.emitterExtents.y : 0;
	      extentsInnerRatioUniform[2] = this.emitterExtents.z !== 0 ? this.emitterExtentsInner.z / this.emitterExtents.z : 0;
	    }

	    for (var i = 0; i < this.numParticles; i++) {
	      this._cpuUpdater.calcSpawnPosition(this.particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, i);

	      if (this.useCpu) this.particleTex[i * particleTexChannels + 3 + this.numParticlesPot * 2 * particleTexChannels] = 1;
	    }

	    this.particleTexStart = new Float32Array(this.numParticlesPot * particleTexHeight * particleTexChannels);

	    for (var _i = 0; _i < this.particleTexStart.length; _i++) {
	      this.particleTexStart[_i] = this.particleTex[_i];
	    }

	    if (!this.useCpu) {
	      if (this.pack8) {
	        this.particleTexIN = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex, PIXELFORMAT_R8_G8_B8_A8, 1, false);
	        this.particleTexOUT = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex, PIXELFORMAT_R8_G8_B8_A8, 1, false);
	        this.particleTexStart = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTexStart, PIXELFORMAT_R8_G8_B8_A8, 1, false);
	      } else {
	        this.particleTexIN = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex);
	        this.particleTexOUT = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex);
	        this.particleTexStart = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTexStart);
	      }

	      this.rtParticleTexIN = new RenderTarget({
	        colorBuffer: this.particleTexIN,
	        depth: false
	      });
	      this.rtParticleTexOUT = new RenderTarget({
	        colorBuffer: this.particleTexOUT,
	        depth: false
	      });
	      this.swapTex = false;
	    }

	    var shaderCodeStart = (this.localSpace ? '#define LOCAL_SPACE\n' : '') + shaderChunks.particleUpdaterInitPS + (this.pack8 ? shaderChunks.particleInputRgba8PS + shaderChunks.particleOutputRgba8PS : shaderChunks.particleInputFloatPS + shaderChunks.particleOutputFloatPS) + (this.emitterShape === EMITTERSHAPE_BOX ? shaderChunks.particleUpdaterAABBPS : shaderChunks.particleUpdaterSpherePS) + shaderChunks.particleUpdaterStartPS;
	    var shaderCodeRespawn = shaderCodeStart + shaderChunks.particleUpdaterRespawnPS + shaderChunks.particleUpdaterEndPS;
	    var shaderCodeNoRespawn = shaderCodeStart + shaderChunks.particleUpdaterNoRespawnPS + shaderChunks.particleUpdaterEndPS;
	    var shaderCodeOnStop = shaderCodeStart + shaderChunks.particleUpdaterOnStopPS + shaderChunks.particleUpdaterEndPS;
	    var params = this.emitterShape + '' + this.pack8 + '' + this.localSpace;
	    this.shaderParticleUpdateRespawn = createShaderFromCode(gd, shaderChunks.fullscreenQuadVS, shaderCodeRespawn, 'fsQuad0' + params);
	    this.shaderParticleUpdateNoRespawn = createShaderFromCode(gd, shaderChunks.fullscreenQuadVS, shaderCodeNoRespawn, 'fsQuad1' + params);
	    this.shaderParticleUpdateOnStop = createShaderFromCode(gd, shaderChunks.fullscreenQuadVS, shaderCodeOnStop, 'fsQuad2' + params);
	    this.numParticleVerts = this.useMesh ? this.mesh.vertexBuffer.numVertices : 4;
	    this.numParticleIndices = this.useMesh ? this.mesh.indexBuffer[0].numIndices : 6;

	    this._allocate(this.numParticles);

	    var mesh = new Mesh(gd);
	    mesh.vertexBuffer = this.vertexBuffer;
	    mesh.indexBuffer[0] = this.indexBuffer;
	    mesh.primitive[0].type = PRIMITIVE_TRIANGLES;
	    mesh.primitive[0].base = 0;
	    mesh.primitive[0].count = this.numParticles * this.numParticleIndices;
	    mesh.primitive[0].indexed = true;
	    this.material = new Material();
	    this.material.name = this.node.name;
	    this.material.cull = CULLFACE_NONE;
	    this.material.alphaWrite = false;
	    this.material.blend = true;
	    this.material.blendType = this.blendType;
	    this.material.depthWrite = this.depthWrite;
	    this.material.emitter = this;
	    this.regenShader();
	    this.resetMaterial();
	    var wasVisible = this.meshInstance ? this.meshInstance.visible : true;
	    this.meshInstance = new MeshInstance(mesh, this.material, this.node);
	    this.meshInstance.pick = false;
	    this.meshInstance.updateKey();
	    this.meshInstance.cull = true;
	    this.meshInstance._noDepthDrawGl1 = true;

	    if (this.localSpace) {
	      this.meshInstance.aabb.setFromTransformedAabb(this.worldBounds, this.node.getWorldTransform());
	    } else {
	      this.meshInstance.aabb.copy(this.worldBounds);
	    }

	    this.meshInstance._updateAabb = false;
	    this.meshInstance.visible = wasVisible;

	    this._initializeTextures();

	    this.resetTime();
	    this.addTime(0, false);
	    if (this.preWarm) this.prewarm(this.lifetime);
	  };

	  _proto._isAnimated = function _isAnimated() {
	    return this.animNumFrames >= 1 && (this.animTilesX > 1 || this.animTilesY > 1) && (this.colorMap && this.colorMap !== this.defaultParamTexture || this.normalMap);
	  };

	  _proto.rebuildGraphs = function rebuildGraphs() {
	    var precision = this.precision;
	    var gd = this.graphicsDevice;
	    this.qLocalVelocity = this.localVelocityGraph.quantize(precision);
	    this.qVelocity = this.velocityGraph.quantize(precision);
	    this.qColor = this.colorGraph.quantizeClamped(precision, 0, 1);
	    this.qRotSpeed = this.rotationSpeedGraph.quantize(precision);
	    this.qScale = this.scaleGraph.quantize(precision);
	    this.qAlpha = this.alphaGraph.quantize(precision);
	    this.qRadialSpeed = this.radialSpeedGraph.quantize(precision);
	    this.qLocalVelocity2 = this.localVelocityGraph2.quantize(precision);
	    this.qVelocity2 = this.velocityGraph2.quantize(precision);
	    this.qColor2 = this.colorGraph2.quantizeClamped(precision, 0, 1);
	    this.qRotSpeed2 = this.rotationSpeedGraph2.quantize(precision);
	    this.qScale2 = this.scaleGraph2.quantize(precision);
	    this.qAlpha2 = this.alphaGraph2.quantize(precision);
	    this.qRadialSpeed2 = this.radialSpeedGraph2.quantize(precision);

	    for (var i = 0; i < precision; i++) {
	      this.qRotSpeed[i] *= math.DEG_TO_RAD;
	      this.qRotSpeed2[i] *= math.DEG_TO_RAD;
	    }

	    this.localVelocityUMax = new Float32Array(3);
	    this.velocityUMax = new Float32Array(3);
	    this.colorUMax = new Float32Array(3);
	    this.rotSpeedUMax = [0];
	    this.scaleUMax = [0];
	    this.alphaUMax = [0];
	    this.radialSpeedUMax = [0];
	    this.qLocalVelocityDiv = divGraphFrom2Curves(this.qLocalVelocity, this.qLocalVelocity2, this.localVelocityUMax);
	    this.qVelocityDiv = divGraphFrom2Curves(this.qVelocity, this.qVelocity2, this.velocityUMax);
	    this.qColorDiv = divGraphFrom2Curves(this.qColor, this.qColor2, this.colorUMax);
	    this.qRotSpeedDiv = divGraphFrom2Curves(this.qRotSpeed, this.qRotSpeed2, this.rotSpeedUMax);
	    this.qScaleDiv = divGraphFrom2Curves(this.qScale, this.qScale2, this.scaleUMax);
	    this.qAlphaDiv = divGraphFrom2Curves(this.qAlpha, this.qAlpha2, this.alphaUMax);
	    this.qRadialSpeedDiv = divGraphFrom2Curves(this.qRadialSpeed, this.qRadialSpeed2, this.radialSpeedUMax);

	    if (this.pack8) {
	      var umax = [0, 0, 0];
	      maxUnsignedGraphValue(this.qVelocity, umax);
	      var umax2 = [0, 0, 0];
	      maxUnsignedGraphValue(this.qVelocity2, umax2);
	      var lumax = [0, 0, 0];
	      maxUnsignedGraphValue(this.qLocalVelocity, lumax);
	      var lumax2 = [0, 0, 0];
	      maxUnsignedGraphValue(this.qLocalVelocity2, lumax2);
	      var rumax = [0];
	      maxUnsignedGraphValue(this.qRadialSpeed, rumax);
	      var rumax2 = [0];
	      maxUnsignedGraphValue(this.qRadialSpeed2, rumax2);
	      var maxVel = Math.max(umax[0], umax2[0]);
	      maxVel = Math.max(maxVel, umax[1]);
	      maxVel = Math.max(maxVel, umax2[1]);
	      maxVel = Math.max(maxVel, umax[2]);
	      maxVel = Math.max(maxVel, umax2[2]);
	      var lmaxVel = Math.max(lumax[0], lumax2[0]);
	      lmaxVel = Math.max(lmaxVel, lumax[1]);
	      lmaxVel = Math.max(lmaxVel, lumax2[1]);
	      lmaxVel = Math.max(lmaxVel, lumax[2]);
	      lmaxVel = Math.max(lmaxVel, lumax2[2]);
	      var maxRad = Math.max(rumax[0], rumax2[0]);
	      this.maxVel = maxVel + lmaxVel + maxRad;
	    }

	    if (!this.useCpu) {
	      this.internalTex0 = _createTexture(gd, precision, 1, packTextureXYZ_NXYZ(this.qLocalVelocity, this.qLocalVelocityDiv));
	      this.internalTex1 = _createTexture(gd, precision, 1, packTextureXYZ_NXYZ(this.qVelocity, this.qVelocityDiv));
	      this.internalTex2 = _createTexture(gd, precision, 1, packTexture5Floats(this.qRotSpeed, this.qScale, this.qScaleDiv, this.qRotSpeedDiv, this.qAlphaDiv));
	      this.internalTex3 = _createTexture(gd, precision, 1, packTexture2Floats(this.qRadialSpeed, this.qRadialSpeedDiv));
	    }

	    this.colorParam = _createTexture(gd, precision, 1, packTextureRGBA(this.qColor, this.qAlpha), PIXELFORMAT_R8_G8_B8_A8, 1.0, true);
	  };

	  _proto._initializeTextures = function _initializeTextures() {
	    if (this.colorMap) {
	      this.material.setParameter('colorMap', this.colorMap);

	      if (this.lighting && this.normalMap) {
	        this.material.setParameter('normalMap', this.normalMap);
	      }
	    }
	  };

	  _proto.regenShader = function regenShader() {
	    var programLib = this.graphicsDevice.getProgramLibrary();
	    this.graphicsDevice.programLib.register('particle', particle);
	    var hasNormal = this.normalMap !== null;
	    this.normalOption = 0;

	    if (this.lighting) {
	      this.normalOption = hasNormal ? 2 : 1;
	    }

	    this.material.getShaderVariant = function (dev, sc, defs, staticLightList, pass, sortedLights, viewUniformFormat, viewBindGroupFormat) {
	      if (this.emitter.scene) {
	        if (this.emitter.camera !== this.emitter.scene._activeCamera) {
	          this.emitter.camera = this.emitter.scene._activeCamera;
	          this.emitter.onChangeCamera();
	        }
	      }

	      var inTools = this.emitter.inTools;
	      var shader = programLib.getProgram('particle', {
	        useCpu: this.emitter.useCpu,
	        normal: this.emitter.normalOption,
	        halflambert: this.emitter.halfLambert,
	        stretch: this.emitter.stretch,
	        alignToMotion: this.emitter.alignToMotion,
	        soft: this.emitter.depthSoftening,
	        mesh: this.emitter.useMesh,
	        gamma: this.emitter.scene ? this.emitter.scene.gammaCorrection : 0,
	        toneMap: this.emitter.scene ? this.emitter.scene.toneMapping : 0,
	        fog: this.emitter.scene && !this.emitter.noFog ? this.emitter.scene.fog : 'none',
	        wrap: this.emitter.wrap && this.emitter.wrapBounds,
	        localSpace: this.emitter.localSpace,
	        screenSpace: inTools ? false : this.emitter.screenSpace,
	        blend: this.blendType,
	        animTex: this.emitter._isAnimated(),
	        animTexLoop: this.emitter.animLoop,
	        pack8: this.emitter.pack8,
	        customFace: this.emitter.orientation !== PARTICLEORIENTATION_SCREEN
	      });
	      return shader;
	    };

	    this.material.shader = this.material.getShaderVariant();
	  };

	  _proto.resetMaterial = function resetMaterial() {
	    var material = this.material;
	    material.setParameter('stretch', this.stretch);

	    if (this._isAnimated()) {
	      material.setParameter('animTexTilesParams', this.animTilesParams);
	      material.setParameter('animTexParams', this.animParams);
	      material.setParameter('animTexIndexParams', this.animIndexParams);
	    }

	    material.setParameter('colorMult', this.intensity);

	    if (!this.useCpu) {
	      material.setParameter('internalTex0', this.internalTex0);
	      material.setParameter('internalTex1', this.internalTex1);
	      material.setParameter('internalTex2', this.internalTex2);
	      material.setParameter('internalTex3', this.internalTex3);
	    }

	    material.setParameter('colorParam', this.colorParam);
	    material.setParameter('numParticles', this.numParticles);
	    material.setParameter('numParticlesPot', this.numParticlesPot);
	    material.setParameter('lifetime', this.lifetime);
	    material.setParameter('rate', this.rate);
	    material.setParameter('rateDiv', this.rate2 - this.rate);
	    material.setParameter('seed', this.seed);
	    material.setParameter('scaleDivMult', this.scaleUMax[0]);
	    material.setParameter('alphaDivMult', this.alphaUMax[0]);
	    material.setParameter('radialSpeedDivMult', this.radialSpeedUMax[0]);
	    material.setParameter('graphNumSamples', this.precision);
	    material.setParameter('graphSampleSize', 1.0 / this.precision);
	    material.setParameter('emitterScale', new Float32Array([1, 1, 1]));

	    if (this.pack8) {
	      this._gpuUpdater._setInputBounds();

	      material.setParameter('inBoundsSize', this._gpuUpdater.inBoundsSizeUniform);
	      material.setParameter('inBoundsCenter', this._gpuUpdater.inBoundsCenterUniform);
	      material.setParameter('maxVel', this.maxVel);
	    }

	    if (this.wrap && this.wrapBounds) {
	      this.wrapBoundsUniform[0] = this.wrapBounds.x;
	      this.wrapBoundsUniform[1] = this.wrapBounds.y;
	      this.wrapBoundsUniform[2] = this.wrapBounds.z;
	      material.setParameter('wrapBounds', this.wrapBoundsUniform);
	    }

	    if (this.colorMap) {
	      material.setParameter('colorMap', this.colorMap);
	    }

	    if (this.lighting) {
	      if (this.normalMap) {
	        material.setParameter('normalMap', this.normalMap);
	      }
	    }

	    if (this.depthSoftening > 0) {
	      material.setParameter('softening', 1.0 / (this.depthSoftening * this.depthSoftening * 100));
	    }

	    if (this.stretch > 0.0) material.cull = CULLFACE_NONE;

	    this._compParticleFaceParams();
	  };

	  _proto._compParticleFaceParams = function _compParticleFaceParams() {
	    var tangent, binormal;

	    if (this.orientation === PARTICLEORIENTATION_SCREEN) {
	      tangent = new Float32Array([1, 0, 0]);
	      binormal = new Float32Array([0, 0, 1]);
	    } else {
	      var n;

	      if (this.orientation === PARTICLEORIENTATION_WORLD) {
	        n = this.particleNormal.normalize();
	      } else {
	        var emitterMat = this.node === null ? Mat4.IDENTITY : this.node.getWorldTransform();
	        n = emitterMat.transformVector(this.particleNormal).normalize();
	      }

	      var t = new Vec3(1, 0, 0);
	      if (Math.abs(t.dot(n)) === 1) t.set(0, 0, 1);
	      var b = new Vec3().cross(n, t).normalize();
	      t.cross(b, n).normalize();
	      tangent = new Float32Array([t.x, t.y, t.z]);
	      binormal = new Float32Array([b.x, b.y, b.z]);
	    }

	    this.material.setParameter('faceTangent', tangent);
	    this.material.setParameter('faceBinorm', binormal);
	  };

	  _proto._allocate = function _allocate(numParticles) {
	    var psysVertCount = numParticles * this.numParticleVerts;
	    var psysIndexCount = numParticles * this.numParticleIndices;

	    if (this.vertexBuffer === undefined || this.vertexBuffer.getNumVertices() !== psysVertCount) {
	      if (!this.useCpu) {
	        var elements = [{
	          semantic: SEMANTIC_ATTR0,
	          components: 4,
	          type: TYPE_FLOAT32
	        }];

	        if (this.useMesh) {
	          elements.push({
	            semantic: SEMANTIC_ATTR1,
	            components: 2,
	            type: TYPE_FLOAT32
	          });
	        }

	        var particleFormat = new VertexFormat(this.graphicsDevice, elements);
	        this.vertexBuffer = new VertexBuffer(this.graphicsDevice, particleFormat, psysVertCount, BUFFER_DYNAMIC);
	        this.indexBuffer = new IndexBuffer(this.graphicsDevice, INDEXFORMAT_UINT16, psysIndexCount);
	      } else {
	        var _elements = [{
	          semantic: SEMANTIC_ATTR0,
	          components: 4,
	          type: TYPE_FLOAT32
	        }, {
	          semantic: SEMANTIC_ATTR1,
	          components: 4,
	          type: TYPE_FLOAT32
	        }, {
	          semantic: SEMANTIC_ATTR2,
	          components: 4,
	          type: TYPE_FLOAT32
	        }, {
	          semantic: SEMANTIC_ATTR3,
	          components: 1,
	          type: TYPE_FLOAT32
	        }, {
	          semantic: SEMANTIC_ATTR4,
	          components: this.useMesh ? 4 : 2,
	          type: TYPE_FLOAT32
	        }];

	        var _particleFormat = new VertexFormat(this.graphicsDevice, _elements);

	        this.vertexBuffer = new VertexBuffer(this.graphicsDevice, _particleFormat, psysVertCount, BUFFER_DYNAMIC);
	        this.indexBuffer = new IndexBuffer(this.graphicsDevice, INDEXFORMAT_UINT16, psysIndexCount);
	      }

	      var data = new Float32Array(this.vertexBuffer.lock());
	      var meshData, stride, texCoordOffset;

	      if (this.useMesh) {
	        meshData = new Float32Array(this.mesh.vertexBuffer.lock());
	        stride = meshData.length / this.mesh.vertexBuffer.numVertices;

	        for (var elem = 0; elem < this.mesh.vertexBuffer.format.elements.length; elem++) {
	          if (this.mesh.vertexBuffer.format.elements[elem].name === SEMANTIC_TEXCOORD0) {
	            texCoordOffset = this.mesh.vertexBuffer.format.elements[elem].offset / 4;
	            break;
	          }
	        }
	      }

	      for (var i = 0; i < psysVertCount; i++) {
	        var id = Math.floor(i / this.numParticleVerts);

	        if (!this.useMesh) {
	          var vertID = i % 4;
	          data[i * 4] = particleVerts[vertID][0];
	          data[i * 4 + 1] = particleVerts[vertID][1];
	          data[i * 4 + 2] = 0;
	          data[i * 4 + 3] = id;
	        } else {
	          var vert = i % this.numParticleVerts;
	          data[i * 6] = meshData[vert * stride];
	          data[i * 6 + 1] = meshData[vert * stride + 1];
	          data[i * 6 + 2] = meshData[vert * stride + 2];
	          data[i * 6 + 3] = id;
	          data[i * 6 + 4] = meshData[vert * stride + texCoordOffset + 0];
	          data[i * 6 + 5] = 1.0 - meshData[vert * stride + texCoordOffset + 1];
	        }
	      }

	      if (this.useCpu) {
	        this.vbCPU = new Float32Array(data);
	        this.vbOld = new Float32Array(this.vbCPU.length);
	      }

	      this.vertexBuffer.unlock();

	      if (this.useMesh) {
	        this.mesh.vertexBuffer.unlock();
	      }

	      var dst = 0;
	      var indices = new Uint16Array(this.indexBuffer.lock());
	      if (this.useMesh) meshData = new Uint16Array(this.mesh.indexBuffer[0].lock());

	      for (var _i2 = 0; _i2 < numParticles; _i2++) {
	        if (!this.useMesh) {
	          var baseIndex = _i2 * 4;
	          indices[dst++] = baseIndex;
	          indices[dst++] = baseIndex + 1;
	          indices[dst++] = baseIndex + 2;
	          indices[dst++] = baseIndex;
	          indices[dst++] = baseIndex + 2;
	          indices[dst++] = baseIndex + 3;
	        } else {
	          for (var j = 0; j < this.numParticleIndices; j++) {
	            indices[_i2 * this.numParticleIndices + j] = meshData[j] + _i2 * this.numParticleVerts;
	          }
	        }
	      }

	      this.indexBuffer.unlock();
	      if (this.useMesh) this.mesh.indexBuffer[0].unlock();
	    }
	  };

	  _proto.reset = function reset() {
	    this.beenReset = true;
	    this.seed = Math.random();
	    this.material.setParameter('seed', this.seed);

	    if (this.useCpu) {
	      for (var i = 0; i < this.particleTexStart.length; i++) {
	        this.particleTex[i] = this.particleTexStart[i];
	      }
	    } else {
	      this._initializeTextures();
	    }

	    this.resetWorldBounds();
	    this.resetTime();
	    var origLoop = this.loop;
	    this.loop = true;
	    this.addTime(0, false);
	    this.loop = origLoop;

	    if (this.preWarm) {
	      this.prewarm(this.lifetime);
	    }
	  };

	  _proto.prewarm = function prewarm(time) {
	    var lifetimeFraction = time / this.lifetime;
	    var iterations = Math.min(Math.floor(lifetimeFraction * this.precision), this.precision);
	    var stepDelta = time / iterations;

	    for (var i = 0; i < iterations; i++) {
	      this.addTime(stepDelta, false);
	    }
	  };

	  _proto.resetTime = function resetTime() {
	    this.endTime = calcEndTime(this);
	  };

	  _proto.finishFrame = function finishFrame() {
	    if (this.useCpu) this.vertexBuffer.unlock();
	  };

	  _proto.addTime = function addTime(delta, isOnStop) {
	    var device = this.graphicsDevice;
	    this.simTimeTotal += delta;
	    this.calculateWorldBounds();

	    if (this._isAnimated()) {
	      var tilesParams = this.animTilesParams;
	      tilesParams[0] = 1.0 / this.animTilesX;
	      tilesParams[1] = 1.0 / this.animTilesY;
	      var params = this.animParams;
	      params[0] = this.animStartFrame;
	      params[1] = this.animNumFrames * this.animSpeed;
	      params[2] = this.animNumFrames - 1;
	      params[3] = this.animNumAnimations - 1;
	      var animIndexParams = this.animIndexParams;
	      animIndexParams[0] = this.animIndex;
	      animIndexParams[1] = this.randomizeAnimIndex;
	    }

	    if (this.scene) {
	      if (this.camera !== this.scene._activeCamera) {
	        this.camera = this.scene._activeCamera;
	        this.onChangeCamera();
	      }
	    }

	    if (this.emitterShape === EMITTERSHAPE_BOX) {
	      extentsInnerRatioUniform[0] = this.emitterExtents.x !== 0 ? this.emitterExtentsInner.x / this.emitterExtents.x : 0;
	      extentsInnerRatioUniform[1] = this.emitterExtents.y !== 0 ? this.emitterExtentsInner.y / this.emitterExtents.y : 0;
	      extentsInnerRatioUniform[2] = this.emitterExtents.z !== 0 ? this.emitterExtentsInner.z / this.emitterExtents.z : 0;

	      if (this.meshInstance.node === null) {
	        spawnMatrix.setTRS(Vec3.ZERO, Quat.IDENTITY, this.emitterExtents);
	      } else {
	        spawnMatrix.setTRS(Vec3.ZERO, this.meshInstance.node.getRotation(), tmpVec3.copy(this.emitterExtents).mul(this.meshInstance.node.localScale));
	      }
	    }

	    var emitterPos;
	    var emitterScale = this.meshInstance.node === null ? Vec3.ONE : this.meshInstance.node.localScale;
	    this.emitterScaleUniform[0] = emitterScale.x;
	    this.emitterScaleUniform[1] = emitterScale.y;
	    this.emitterScaleUniform[2] = emitterScale.z;
	    this.material.setParameter('emitterScale', this.emitterScaleUniform);

	    if (this.localSpace && this.meshInstance.node) {
	      emitterPos = this.meshInstance.node.getPosition();
	      this.emitterPosUniform[0] = emitterPos.x;
	      this.emitterPosUniform[1] = emitterPos.y;
	      this.emitterPosUniform[2] = emitterPos.z;
	      this.material.setParameter('emitterPos', this.emitterPosUniform);
	    }

	    this._compParticleFaceParams();

	    if (!this.useCpu) {
	      this._gpuUpdater.update(device, spawnMatrix, extentsInnerRatioUniform, delta, isOnStop);
	    } else {
	      var data = new Float32Array(this.vertexBuffer.lock());

	      this._cpuUpdater.update(data, this.vbToSort, this.particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, delta, isOnStop);
	    }

	    if (!this.loop) {
	      if (Date.now() > this.endTime) {
	        if (this.onFinished) this.onFinished();
	        this.meshInstance.visible = false;
	      }
	    }

	    if (this.meshInstance) {
	      this.meshInstance.drawOrder = this.drawOrder;
	    }
	  };

	  _proto._destroyResources = function _destroyResources() {
	    if (this.particleTexIN) {
	      this.particleTexIN.destroy();
	      this.particleTexIN = null;
	    }

	    if (this.particleTexOUT) {
	      this.particleTexOUT.destroy();
	      this.particleTexOUT = null;
	    }

	    if (this.particleTexStart && this.particleTexStart.destroy) {
	      this.particleTexStart.destroy();
	      this.particleTexStart = null;
	    }

	    if (this.rtParticleTexIN) {
	      this.rtParticleTexIN.destroy();
	      this.rtParticleTexIN = null;
	    }

	    if (this.rtParticleTexOUT) {
	      this.rtParticleTexOUT.destroy();
	      this.rtParticleTexOUT = null;
	    }

	    if (this.internalTex0) {
	      this.internalTex0.destroy();
	      this.internalTex0 = null;
	    }

	    if (this.internalTex1) {
	      this.internalTex1.destroy();
	      this.internalTex1 = null;
	    }

	    if (this.internalTex2) {
	      this.internalTex2.destroy();
	      this.internalTex2 = null;
	    }

	    if (this.internalTex3) {
	      this.internalTex3.destroy();
	      this.internalTex3 = null;
	    }

	    if (this.colorParam) {
	      this.colorParam.destroy();
	      this.colorParam = null;
	    }

	    if (this.vertexBuffer) {
	      this.vertexBuffer.destroy();
	      this.vertexBuffer = undefined;
	    }

	    if (this.indexBuffer) {
	      this.indexBuffer.destroy();
	      this.indexBuffer = undefined;
	    }

	    if (this.material) {
	      this.material.destroy();
	      this.material = null;
	    }
	  };

	  _proto.destroy = function destroy() {
	    this.camera = null;

	    this._destroyResources();
	  };

	  _createClass(ParticleEmitter, [{
	    key: "defaultParamTexture",
	    get: function get() {
	      var _this = this;

	      return particleEmitterDeviceCache.get(this.graphicsDevice, function () {
	        var resolution = 16;
	        var centerPoint = resolution * 0.5 + 0.5;
	        var dtex = new Float32Array(resolution * resolution * 4);

	        for (var y = 0; y < resolution; y++) {
	          for (var x = 0; x < resolution; x++) {
	            var xgrad = x + 1 - centerPoint;
	            var ygrad = y + 1 - centerPoint;
	            var c = saturate(1 - saturate(Math.sqrt(xgrad * xgrad + ygrad * ygrad) / resolution) - 0.5);
	            var p = y * resolution + x;
	            dtex[p * 4] = 1;
	            dtex[p * 4 + 1] = 1;
	            dtex[p * 4 + 2] = 1;
	            dtex[p * 4 + 3] = c;
	          }
	        }

	        var texture = _createTexture(_this.graphicsDevice, resolution, resolution, dtex, PIXELFORMAT_R8_G8_B8_A8, 1.0, true);

	        texture.minFilter = FILTER_LINEAR;
	        texture.magFilter = FILTER_LINEAR;
	        return texture;
	      });
	    }
	  }]);

	  return ParticleEmitter;
	}();

	var tempSet = new Set();
	var clearDepthOptions = {
	  depth: 1.0,
	  flags: CLEARFLAG_DEPTH
	};

	var Picker = function () {
	  function Picker(app, width, height) {
	    if (app instanceof GraphicsDevice) {
	      app = getApplication();
	    }

	    this.app = app;
	    this.device = app.graphicsDevice;
	    this.pickColor = new Float32Array(4);
	    this.pickColor[3] = 1;
	    this.mapping = [];
	    this.cameraEntity = null;
	    this.layer = null;
	    this.layerComp = null;
	    this.initLayerComposition();
	    this._renderTarget = null;
	    var device = this.device;
	    this.clearDepthCommand = new Command(0, 0, function () {
	      device.clear(clearDepthOptions);
	    });
	    this.width = 0;
	    this.height = 0;
	    this.resize(width, height);
	  }

	  var _proto = Picker.prototype;

	  _proto.getSelection = function getSelection(x, y, width, height) {
	    var device = this.device;

	    if (typeof x === 'object') {
	      var rect = x;
	      x = rect.x;
	      y = rect.y;
	      width = rect.width;
	      height = rect.height;
	    } else {
	      y = this.renderTarget.height - (y + (height || 1));
	    }

	    x = Math.floor(x);
	    y = Math.floor(y);
	    width = Math.floor(Math.max(width || 1, 1));
	    height = Math.floor(Math.max(height || 1, 1));
	    var origRenderTarget = device.renderTarget;
	    device.setRenderTarget(this.renderTarget);
	    device.updateBegin();
	    var pixels = new Uint8Array(4 * width * height);
	    device.readPixels(x, y, width, height, pixels);
	    device.updateEnd();
	    device.setRenderTarget(origRenderTarget);
	    var mapping = this.mapping;

	    for (var i = 0; i < width * height; i++) {
	      var r = pixels[4 * i + 0];
	      var g = pixels[4 * i + 1];
	      var b = pixels[4 * i + 2];
	      var index = r << 16 | g << 8 | b;

	      if (index !== 0xffffff) {
	        tempSet.add(mapping[index]);
	      }
	    }

	    var selection = [];
	    tempSet.forEach(function (meshInstance) {
	      return selection.push(meshInstance);
	    });
	    tempSet.clear();
	    return selection;
	  };

	  _proto.allocateRenderTarget = function allocateRenderTarget() {
	    var colorBuffer = new Texture(this.device, {
	      format: PIXELFORMAT_R8_G8_B8_A8,
	      width: this.width,
	      height: this.height,
	      mipmaps: false,
	      minFilter: FILTER_NEAREST,
	      magFilter: FILTER_NEAREST,
	      addressU: ADDRESS_CLAMP_TO_EDGE,
	      addressV: ADDRESS_CLAMP_TO_EDGE,
	      name: 'pick'
	    });
	    this.renderTarget = new RenderTarget({
	      colorBuffer: colorBuffer,
	      depth: true
	    });
	  };

	  _proto.releaseRenderTarget = function releaseRenderTarget() {
	    this.cameraEntity.camera.renderTarget = null;

	    if (this._renderTarget) {
	      this._renderTarget.destroyTextureBuffers();

	      this._renderTarget.destroy();

	      this._renderTarget = null;
	    }
	  };

	  _proto.initLayerComposition = function initLayerComposition() {
	    var device = this.device;
	    var self = this;
	    var pickColorId = device.scope.resolve('uColor');
	    this.cameraEntity = new Entity();
	    this.cameraEntity.addComponent('camera');
	    this.layer = new Layer({
	      name: 'Picker',
	      shaderPass: SHADER_PICK,
	      opaqueSortMode: SORTMODE_NONE,
	      onDrawCall: function onDrawCall(meshInstance, index) {
	        self.pickColor[0] = (index >> 16 & 0xff) / 255;
	        self.pickColor[1] = (index >> 8 & 0xff) / 255;
	        self.pickColor[2] = (index & 0xff) / 255;
	        pickColorId.setValue(self.pickColor);
	        device.setBlending(false);
	        self.mapping[index] = meshInstance;
	      }
	    });
	    this.layer.addCamera(this.cameraEntity.camera);
	    this.layerComp = new LayerComposition('picker');
	    this.layerComp.pushOpaque(this.layer);
	  };

	  _proto.prepare = function prepare(camera, scene, layers) {
	    if (camera instanceof Camera) {
	      camera = camera.node.camera;
	    }

	    if (layers instanceof Layer) {
	      layers = [layers];
	    }

	    this.layer.clearMeshInstances();
	    var destMeshInstances = this.layer.opaqueMeshInstances;
	    var srcLayers = scene.layers.layerList;
	    var subLayerEnabled = scene.layers.subLayerEnabled;
	    var isTransparent = scene.layers.subLayerList;

	    for (var i = 0; i < srcLayers.length; i++) {
	      var srcLayer = srcLayers[i];

	      if (layers && layers.indexOf(srcLayer) < 0) {
	        continue;
	      }

	      if (srcLayer.enabled && subLayerEnabled[i]) {
	        var layerCamId = srcLayer.cameras.indexOf(camera);

	        if (layerCamId >= 0) {
	          if (srcLayer._clearDepthBuffer) {
	            destMeshInstances.push(this.clearDepthCommand);
	          }

	          var meshInstances = isTransparent[i] ? srcLayer.instances.transparentMeshInstances : srcLayer.instances.opaqueMeshInstances;

	          for (var j = 0; j < meshInstances.length; j++) {
	            var meshInstance = meshInstances[j];

	            if (meshInstance.pick) {
	              destMeshInstances.push(meshInstance);
	            }
	          }
	        }
	      }
	    }

	    if (!this.renderTarget || this.width !== this.renderTarget.width || this.height !== this.renderTarget.height) {
	      this.releaseRenderTarget();
	      this.allocateRenderTarget();
	    }

	    this.updateCamera(camera);
	    this.mapping.length = 0;
	    this.app.renderComposition(this.layerComp);
	  };

	  _proto.updateCamera = function updateCamera(srcCamera) {
	    this.cameraEntity.copy(srcCamera.entity);
	    this.cameraEntity.name = 'PickerCamera';
	    var destCamera = this.cameraEntity.camera;
	    destCamera.copy(srcCamera);
	    destCamera.clearColorBuffer = true;
	    destCamera.clearDepthBuffer = true;
	    destCamera.clearStencilBuffer = true;
	    destCamera.clearColor = Color.WHITE;
	    destCamera.renderTarget = this.renderTarget;
	    this.layer.clearCameras();
	    this.layer.addCamera(destCamera);
	    destCamera.layers = [this.layer.id];
	  };

	  _proto.resize = function resize(width, height) {
	    this.width = Math.floor(width);
	    this.height = Math.floor(height);
	  };

	  return Picker;
	}();

	var Skin = function Skin(graphicsDevice, ibp, boneNames) {
	  this.device = graphicsDevice;
	  this.inverseBindPose = ibp;
	  this.boneNames = boneNames;
	};

	var spriteNormals = [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1];
	var spriteIndices = [0, 1, 3, 2, 3, 1];

	var Sprite = function (_EventHandler) {
	  _inheritsLoose(Sprite, _EventHandler);

	  function Sprite(device, options) {
	    var _this;

	    _this = _EventHandler.call(this) || this;
	    _this._device = device;
	    _this._pixelsPerUnit = options && options.pixelsPerUnit !== undefined ? options.pixelsPerUnit : 1;
	    _this._renderMode = options && options.renderMode !== undefined ? options.renderMode : SPRITE_RENDERMODE_SIMPLE;
	    _this._atlas = options && options.atlas !== undefined ? options.atlas : null;
	    _this._frameKeys = options && options.frameKeys !== undefined ? options.frameKeys : null;
	    _this._meshes = [];
	    _this._updatingProperties = false;
	    _this._meshesDirty = false;

	    if (_this._atlas && _this._frameKeys) {
	      _this._createMeshes();
	    }

	    return _this;
	  }

	  var _proto = Sprite.prototype;

	  _proto._createMeshes = function _createMeshes() {
	    var len = this._meshes.length;

	    for (var i = 0; i < len; i++) {
	      var mesh = this._meshes[i];

	      if (mesh) {
	        mesh.destroy();
	      }
	    }

	    var count = this._frameKeys.length;
	    this._meshes = new Array(count);
	    var createMeshFunc = this.renderMode === SPRITE_RENDERMODE_SLICED || this._renderMode === SPRITE_RENDERMODE_TILED ? this._create9SliceMesh : this._createSimpleMesh;

	    for (var _i = 0; _i < count; _i++) {
	      var frame = this._atlas.frames[this._frameKeys[_i]];
	      this._meshes[_i] = frame ? createMeshFunc.call(this, frame) : null;
	    }

	    this.fire('set:meshes');
	  };

	  _proto._createSimpleMesh = function _createSimpleMesh(frame) {
	    var rect = frame.rect;
	    var texWidth = this._atlas.texture.width;
	    var texHeight = this._atlas.texture.height;
	    var w = rect.z / this._pixelsPerUnit;
	    var h = rect.w / this._pixelsPerUnit;
	    var hp = frame.pivot.x;
	    var vp = frame.pivot.y;
	    var positions = [-hp * w, -vp * h, 0, (1 - hp) * w, -vp * h, 0, (1 - hp) * w, (1 - vp) * h, 0, -hp * w, (1 - vp) * h, 0];
	    var lu = rect.x / texWidth;
	    var bv = 1.0 - rect.y / texHeight;
	    var ru = (rect.x + rect.z) / texWidth;
	    var tv = 1.0 - (rect.y + rect.w) / texHeight;
	    var uvs = [lu, bv, ru, bv, ru, tv, lu, tv];
	    var mesh = createMesh$1(this._device, positions, {
	      uvs: uvs,
	      normals: spriteNormals,
	      indices: spriteIndices
	    });
	    return mesh;
	  };

	  _proto._create9SliceMesh = function _create9SliceMesh() {
	    var he = Vec2.ONE;
	    var ws = 3;
	    var ls = 3;
	    var positions = [];
	    var normals = [];
	    var uvs = [];
	    var indices = [];
	    var vcounter = 0;

	    for (var i = 0; i <= ws; i++) {
	      var u = i === 0 || i === ws ? 0 : 1;

	      for (var j = 0; j <= ls; j++) {
	        var x = -he.x + 2.0 * he.x * (i <= 1 ? 0 : 3) / ws;
	        var y = 0.0;
	        var z = -(-he.y + 2.0 * he.y * (j <= 1 ? 0 : 3) / ls);
	        var v = j === 0 || j === ls ? 0 : 1;
	        positions.push(-x, y, z);
	        normals.push(0.0, 1.0, 0.0);
	        uvs.push(u, v);

	        if (i < ws && j < ls) {
	          indices.push(vcounter + ls + 1, vcounter + 1, vcounter);
	          indices.push(vcounter + ls + 1, vcounter + ls + 2, vcounter + 1);
	        }

	        vcounter++;
	      }
	    }

	    var options = {
	      normals: normals,
	      uvs: uvs,
	      indices: indices
	    };
	    return createMesh$1(this._device, positions, options);
	  };

	  _proto._onSetFrames = function _onSetFrames(frames) {
	    if (this._updatingProperties) {
	      this._meshesDirty = true;
	    } else {
	      this._createMeshes();
	    }
	  };

	  _proto._onFrameChanged = function _onFrameChanged(frameKey, frame) {
	    var idx = this._frameKeys.indexOf(frameKey);

	    if (idx < 0) return;

	    if (frame) {
	      if (this.renderMode === SPRITE_RENDERMODE_SIMPLE) {
	        this._meshes[idx] = this._createSimpleMesh(frame);
	      }
	    } else {
	      this._meshes[idx] = null;
	    }

	    this.fire('set:meshes');
	  };

	  _proto._onFrameRemoved = function _onFrameRemoved(frameKey) {
	    var idx = this._frameKeys.indexOf(frameKey);

	    if (idx < 0) return;
	    this._meshes[idx] = null;
	    this.fire('set:meshes');
	  };

	  _proto.startUpdate = function startUpdate() {
	    this._updatingProperties = true;
	    this._meshesDirty = false;
	  };

	  _proto.endUpdate = function endUpdate() {
	    this._updatingProperties = false;

	    if (this._meshesDirty && this._atlas && this._frameKeys) {
	      this._createMeshes();
	    }

	    this._meshesDirty = false;
	  };

	  _proto.destroy = function destroy() {
	    for (var _iterator = _createForOfIteratorHelperLoose(this._meshes), _step; !(_step = _iterator()).done;) {
	      var mesh = _step.value;
	      if (mesh) mesh.destroy();
	    }

	    this._meshes.length = 0;
	  };

	  _createClass(Sprite, [{
	    key: "frameKeys",
	    get: function get() {
	      return this._frameKeys;
	    },
	    set: function set(value) {
	      this._frameKeys = value;

	      if (this._atlas && this._frameKeys) {
	        if (this._updatingProperties) {
	          this._meshesDirty = true;
	        } else {
	          this._createMeshes();
	        }
	      }

	      this.fire('set:frameKeys', value);
	    }
	  }, {
	    key: "atlas",
	    get: function get() {
	      return this._atlas;
	    },
	    set: function set(value) {
	      if (value === this._atlas) return;

	      if (this._atlas) {
	        this._atlas.off('set:frames', this._onSetFrames, this);

	        this._atlas.off('set:frame', this._onFrameChanged, this);

	        this._atlas.off('remove:frame', this._onFrameRemoved, this);
	      }

	      this._atlas = value;

	      if (this._atlas && this._frameKeys) {
	        this._atlas.on('set:frames', this._onSetFrames, this);

	        this._atlas.on('set:frame', this._onFrameChanged, this);

	        this._atlas.on('remove:frame', this._onFrameRemoved, this);

	        if (this._updatingProperties) {
	          this._meshesDirty = true;
	        } else {
	          this._createMeshes();
	        }
	      }

	      this.fire('set:atlas', value);
	    }
	  }, {
	    key: "pixelsPerUnit",
	    get: function get() {
	      return this._pixelsPerUnit;
	    },
	    set: function set(value) {
	      if (this._pixelsPerUnit === value) return;
	      this._pixelsPerUnit = value;
	      this.fire('set:pixelsPerUnit', value);

	      if (this._atlas && this._frameKeys && this.renderMode === SPRITE_RENDERMODE_SIMPLE) {
	        if (this._updatingProperties) {
	          this._meshesDirty = true;
	        } else {
	          this._createMeshes();
	        }
	      }
	    }
	  }, {
	    key: "renderMode",
	    get: function get() {
	      return this._renderMode;
	    },
	    set: function set(value) {
	      if (this._renderMode === value) return;
	      var prev = this._renderMode;
	      this._renderMode = value;
	      this.fire('set:renderMode', value);

	      if (prev === SPRITE_RENDERMODE_SIMPLE || value === SPRITE_RENDERMODE_SIMPLE) {
	        if (this._atlas && this._frameKeys) {
	          if (this._updatingProperties) {
	            this._meshesDirty = true;
	          } else {
	            this._createMeshes();
	          }
	        }
	      }
	    }
	  }, {
	    key: "meshes",
	    get: function get() {
	      return this._meshes;
	    }
	  }]);

	  return Sprite;
	}(EventHandler);

	var StencilParameters = function () {
	  function StencilParameters(options) {
	    this.func = options.func === undefined ? FUNC_ALWAYS : options.func;
	    this.ref = options.ref || 0;
	    this.readMask = options.readMask === undefined ? 0xFF : options.readMask;
	    this.writeMask = options.writeMask === undefined ? 0xFF : options.writeMask;
	    this.fail = options.fail || STENCILOP_KEEP;
	    this.zfail = options.zfail || STENCILOP_KEEP;
	    this.zpass = options.zpass || STENCILOP_KEEP;
	  }

	  var _proto = StencilParameters.prototype;

	  _proto.clone = function clone() {
	    return new StencilParameters({
	      func: this.func,
	      ref: this.ref,
	      readMask: this.readMask,
	      writeMask: this.writeMask,
	      fail: this.fail,
	      zfail: this.zfail,
	      zpass: this.zpass
	    });
	  };

	  return StencilParameters;
	}();

	var TextureAtlas = function (_EventHandler) {
	  _inheritsLoose(TextureAtlas, _EventHandler);

	  function TextureAtlas() {
	    var _this;

	    _this = _EventHandler.call(this) || this;
	    _this._texture = null;
	    _this._frames = null;
	    return _this;
	  }

	  var _proto = TextureAtlas.prototype;

	  _proto.setFrame = function setFrame(key, data) {
	    var frame = this._frames[key];

	    if (!frame) {
	      frame = {
	        rect: data.rect.clone(),
	        pivot: data.pivot.clone(),
	        border: data.border.clone()
	      };
	      this._frames[key] = frame;
	    } else {
	      frame.rect.copy(data.rect);
	      frame.pivot.copy(data.pivot);
	      frame.border.copy(data.border);
	    }

	    this.fire('set:frame', key.toString(), frame);
	  };

	  _proto.removeFrame = function removeFrame(key) {
	    var frame = this._frames[key];

	    if (frame) {
	      delete this._frames[key];
	      this.fire('remove:frame', key.toString(), frame);
	    }
	  };

	  _proto.destroy = function destroy() {
	    if (this._texture) {
	      this._texture.destroy();
	    }
	  };

	  _createClass(TextureAtlas, [{
	    key: "texture",
	    get: function get() {
	      return this._texture;
	    },
	    set: function set(value) {
	      this._texture = value;
	      this.fire('set:texture', value);
	    }
	  }, {
	    key: "frames",
	    get: function get() {
	      return this._frames;
	    },
	    set: function set(value) {
	      this._frames = value;
	      this.fire('set:frames', value);
	    }
	  }]);

	  return TextureAtlas;
	}(EventHandler);

	var Key = function Key(time, position, rotation, scale) {
	  this.time = time;
	  this.position = position;
	  this.rotation = rotation;
	  this.scale = scale;
	};

	var Node = function Node() {
	  this._name = '';
	  this._keys = [];
	};

	var Animation = function () {
	  function Animation() {
	    this.name = '';
	    this.duration = 0;
	    this._nodes = [];
	    this._nodeDict = {};
	  }

	  var _proto = Animation.prototype;

	  _proto.getNode = function getNode(name) {
	    return this._nodeDict[name];
	  };

	  _proto.addNode = function addNode(node) {
	    this._nodes.push(node);

	    this._nodeDict[node._name] = node;
	  };

	  _createClass(Animation, [{
	    key: "nodes",
	    get: function get() {
	      return this._nodes;
	    }
	  }]);

	  return Animation;
	}();

	var InterpolatedKey = function () {
	  function InterpolatedKey() {
	    this._written = false;
	    this._name = '';
	    this._keyFrames = [];
	    this._quat = new Quat();
	    this._pos = new Vec3();
	    this._scale = new Vec3();
	    this._targetNode = null;
	  }

	  var _proto = InterpolatedKey.prototype;

	  _proto.getTarget = function getTarget() {
	    return this._targetNode;
	  };

	  _proto.setTarget = function setTarget(node) {
	    this._targetNode = node;
	  };

	  return InterpolatedKey;
	}();

	var Skeleton = function () {
	  function Skeleton(graph) {
	    var _this = this;

	    this.looping = true;
	    this._animation = null;
	    this._time = 0;
	    this._interpolatedKeys = [];
	    this._interpolatedKeyDict = {};
	    this._currKeyIndices = {};
	    this.graph = null;

	    var addInterpolatedKeys = function addInterpolatedKeys(node) {
	      var interpKey = new InterpolatedKey();
	      interpKey._name = node.name;

	      _this._interpolatedKeys.push(interpKey);

	      _this._interpolatedKeyDict[node.name] = interpKey;
	      _this._currKeyIndices[node.name] = 0;

	      for (var i = 0; i < node._children.length; i++) {
	        addInterpolatedKeys(node._children[i]);
	      }
	    };

	    addInterpolatedKeys(graph);
	  }

	  var _proto2 = Skeleton.prototype;

	  _proto2.addTime = function addTime(delta) {
	    if (this._animation !== null) {
	      var nodes = this._animation._nodes;
	      var duration = this._animation.duration;

	      if (this._time === duration && !this.looping) {
	        return;
	      }

	      this._time += delta;

	      if (this._time > duration) {
	        this._time = this.looping ? 0.0 : duration;

	        for (var i = 0; i < nodes.length; i++) {
	          var node = nodes[i];
	          var nodeName = node._name;
	          this._currKeyIndices[nodeName] = 0;
	        }
	      } else if (this._time < 0) {
	        this._time = this.looping ? duration : 0.0;

	        for (var _i = 0; _i < nodes.length; _i++) {
	          var _node = nodes[_i];
	          var _nodeName = _node._name;
	          this._currKeyIndices[_nodeName] = _node._keys.length - 2;
	        }
	      }

	      var offset = delta >= 0 ? 1 : -1;

	      for (var _i2 = 0; _i2 < nodes.length; _i2++) {
	        var _node2 = nodes[_i2];
	        var _nodeName2 = _node2._name;
	        var keys = _node2._keys;
	        var interpKey = this._interpolatedKeyDict[_nodeName2];

	        if (interpKey === undefined) {
	          continue;
	        }

	        var foundKey = false;

	        if (keys.length !== 1) {
	          for (var currKeyIndex = this._currKeyIndices[_nodeName2]; currKeyIndex < keys.length - 1 && currKeyIndex >= 0; currKeyIndex += offset) {
	            var k1 = keys[currKeyIndex];
	            var k2 = keys[currKeyIndex + 1];

	            if (k1.time <= this._time && k2.time >= this._time) {
	              var alpha = (this._time - k1.time) / (k2.time - k1.time);

	              interpKey._pos.lerp(k1.position, k2.position, alpha);

	              interpKey._quat.slerp(k1.rotation, k2.rotation, alpha);

	              interpKey._scale.lerp(k1.scale, k2.scale, alpha);

	              interpKey._written = true;
	              this._currKeyIndices[_nodeName2] = currKeyIndex;
	              foundKey = true;
	              break;
	            }
	          }
	        }

	        if (keys.length === 1 || !foundKey && this._time === 0.0 && this.looping) {
	          interpKey._pos.copy(keys[0].position);

	          interpKey._quat.copy(keys[0].rotation);

	          interpKey._scale.copy(keys[0].scale);

	          interpKey._written = true;
	        }
	      }
	    }
	  };

	  _proto2.blend = function blend(skel1, skel2, alpha) {
	    var numNodes = this._interpolatedKeys.length;

	    for (var i = 0; i < numNodes; i++) {
	      var key1 = skel1._interpolatedKeys[i];
	      var key2 = skel2._interpolatedKeys[i];
	      var dstKey = this._interpolatedKeys[i];

	      if (key1._written && key2._written) {
	        dstKey._quat.slerp(key1._quat, skel2._interpolatedKeys[i]._quat, alpha);

	        dstKey._pos.lerp(key1._pos, skel2._interpolatedKeys[i]._pos, alpha);

	        dstKey._scale.lerp(key1._scale, key2._scale, alpha);

	        dstKey._written = true;
	      } else if (key1._written) {
	        dstKey._quat.copy(key1._quat);

	        dstKey._pos.copy(key1._pos);

	        dstKey._scale.copy(key1._scale);

	        dstKey._written = true;
	      } else if (key2._written) {
	        dstKey._quat.copy(key2._quat);

	        dstKey._pos.copy(key2._pos);

	        dstKey._scale.copy(key2._scale);

	        dstKey._written = true;
	      }
	    }
	  };

	  _proto2.setGraph = function setGraph(graph) {
	    this.graph = graph;

	    if (graph) {
	      for (var i = 0; i < this._interpolatedKeys.length; i++) {
	        var interpKey = this._interpolatedKeys[i];
	        var graphNode = graph.findByName(interpKey._name);

	        this._interpolatedKeys[i].setTarget(graphNode);
	      }
	    } else {
	      for (var _i3 = 0; _i3 < this._interpolatedKeys.length; _i3++) {
	        this._interpolatedKeys[_i3].setTarget(null);
	      }
	    }
	  };

	  _proto2.updateGraph = function updateGraph() {
	    if (this.graph) {
	      for (var i = 0; i < this._interpolatedKeys.length; i++) {
	        var interpKey = this._interpolatedKeys[i];

	        if (interpKey._written) {
	          var transform = interpKey.getTarget();
	          transform.localPosition.copy(interpKey._pos);
	          transform.localRotation.copy(interpKey._quat);
	          transform.localScale.copy(interpKey._scale);
	          if (!transform._dirtyLocal) transform._dirtifyLocal();
	          interpKey._written = false;
	        }
	      }
	    }
	  };

	  _createClass(Skeleton, [{
	    key: "animation",
	    get: function get() {
	      return this._animation;
	    },
	    set: function set(value) {
	      this._animation = value;
	      this.currentTime = 0;
	    }
	  }, {
	    key: "currentTime",
	    get: function get() {
	      return this._time;
	    },
	    set: function set(value) {
	      this._time = value;
	      var numNodes = this._interpolatedKeys.length;

	      for (var i = 0; i < numNodes; i++) {
	        var node = this._interpolatedKeys[i];
	        var nodeName = node._name;
	        this._currKeyIndices[nodeName] = 0;
	      }

	      this.addTime(0);
	      this.updateGraph();
	    }
	  }, {
	    key: "numNodes",
	    get: function get() {
	      return this._interpolatedKeys.length;
	    }
	  }]);

	  return Skeleton;
	}();

	var INTERPOLATION_STEP = 0;
	var INTERPOLATION_LINEAR = 1;
	var INTERPOLATION_CUBIC = 2;

	var AnimBinder = function () {
	  function AnimBinder() {}

	  AnimBinder.joinPath = function joinPath(pathSegments, character) {
	    character = character || '.';

	    var escape = function escape(string) {
	      return string.replace(/\\/g, '\\\\').replace(new RegExp('\\' + character, 'g'), '\\' + character);
	    };

	    return pathSegments.map(escape).join(character);
	  };

	  AnimBinder.splitPath = function splitPath(path, character) {
	    character = character || '.';
	    var result = [];
	    var curr = "";
	    var i = 0;

	    while (i < path.length) {
	      var c = path[i++];

	      if (c === '\\' && i < path.length) {
	        c = path[i++];

	        if (c === '\\' || c === character) {
	          curr += c;
	        } else {
	          curr += '\\' + c;
	        }
	      } else if (c === character) {
	        result.push(curr);
	        curr = '';
	      } else {
	        curr += c;
	      }
	    }

	    if (curr.length > 0) {
	      result.push(curr);
	    }

	    return result;
	  };

	  AnimBinder.encode = function encode(entityPath, component, propertyPath) {
	    return (Array.isArray(entityPath) ? entityPath.join('/') : entityPath) + "/" + component + "/" + (Array.isArray(propertyPath) ? propertyPath.join('/') : propertyPath);
	  };

	  var _proto = AnimBinder.prototype;

	  _proto.resolve = function resolve(path) {
	    return null;
	  };

	  _proto.unresolve = function unresolve(path) {};

	  _proto.update = function update(deltaTime) {};

	  return AnimBinder;
	}();

	var AnimCache = function () {
	  function AnimCache() {
	    this._left = Infinity;
	    this._right = -Infinity;
	    this._len = 0;
	    this._recip = 0;
	    this._p0 = 0;
	    this._p1 = 0;
	    this._t = 0;
	    this._hermite = {
	      valid: false,
	      p0: 0,
	      m0: 0,
	      p1: 0,
	      m1: 0
	    };
	  }

	  var _proto = AnimCache.prototype;

	  _proto.update = function update(time, input) {
	    if (time < this._left || time >= this._right) {
	      var len = input.length;

	      if (!len) {
	        this._left = -Infinity;
	        this._right = Infinity;
	        this._len = 0;
	        this._recip = 0;
	        this._p0 = this._p1 = 0;
	      } else {
	        if (time < input[0]) {
	          this._left = -Infinity;
	          this._right = input[0];
	          this._len = 0;
	          this._recip = 0;
	          this._p0 = this._p1 = 0;
	        } else if (time >= input[len - 1]) {
	          this._left = input[len - 1];
	          this._right = Infinity;
	          this._len = 0;
	          this._recip = 0;
	          this._p0 = this._p1 = len - 1;
	        } else {
	          var index = this._findKey(time, input);

	          this._left = input[index];
	          this._right = input[index + 1];
	          this._len = this._right - this._left;
	          var diff = 1.0 / this._len;
	          this._recip = isFinite(diff) ? diff : 0;
	          this._p0 = index;
	          this._p1 = index + 1;
	        }
	      }
	    }

	    this._t = this._recip === 0 ? 0 : (time - this._left) * this._recip;
	    this._hermite.valid = false;
	  };

	  _proto._findKey = function _findKey(time, input) {
	    var index = 0;

	    while (time >= input[index + 1]) {
	      index++;
	    }

	    return index;
	  };

	  _proto.eval = function _eval(result, interpolation, output) {
	    var data = output._data;
	    var comp = output._components;
	    var idx0 = this._p0 * comp;

	    if (interpolation === INTERPOLATION_STEP) {
	      for (var i = 0; i < comp; ++i) {
	        result[i] = data[idx0 + i];
	      }
	    } else {
	      var t = this._t;
	      var idx1 = this._p1 * comp;

	      switch (interpolation) {
	        case INTERPOLATION_LINEAR:
	          for (var _i = 0; _i < comp; ++_i) {
	            result[_i] = math.lerp(data[idx0 + _i], data[idx1 + _i], t);
	          }

	          break;

	        case INTERPOLATION_CUBIC:
	          {
	            var hermite = this._hermite;

	            if (!hermite.valid) {
	              var t2 = t * t;
	              var twot = t + t;
	              var omt = 1 - t;
	              var omt2 = omt * omt;
	              hermite.valid = true;
	              hermite.p0 = (1 + twot) * omt2;
	              hermite.m0 = t * omt2;
	              hermite.p1 = t2 * (3 - twot);
	              hermite.m1 = t2 * (t - 1);
	            }

	            var p0 = (this._p0 * 3 + 1) * comp;
	            var m0 = (this._p0 * 3 + 2) * comp;
	            var p1 = (this._p1 * 3 + 1) * comp;
	            var m1 = (this._p1 * 3 + 0) * comp;

	            for (var _i2 = 0; _i2 < comp; ++_i2) {
	              result[_i2] = hermite.p0 * data[p0 + _i2] + hermite.m0 * data[m0 + _i2] * this._len + hermite.p1 * data[p1 + _i2] + hermite.m1 * data[m1 + _i2] * this._len;
	            }

	            break;
	          }
	      }
	    }
	  };

	  return AnimCache;
	}();

	var AnimSnapshot = function AnimSnapshot(animTrack) {
	  this._name = animTrack.name + 'Snapshot';
	  this._time = -1;
	  this._cache = [];
	  this._results = [];

	  for (var i = 0; i < animTrack._inputs.length; ++i) {
	    this._cache[i] = new AnimCache();
	  }

	  var curves = animTrack._curves;
	  var outputs = animTrack._outputs;

	  for (var _i = 0; _i < curves.length; ++_i) {
	    var curve = curves[_i];
	    var output = outputs[curve._output];
	    var storage = [];

	    for (var j = 0; j < output._components; ++j) {
	      storage[j] = 0;
	    }

	    this._results[_i] = storage;
	  }
	};

	var AnimClip = function () {
	  function AnimClip(track, time, speed, playing, loop, eventHandler) {
	    this._name = track.name;
	    this._track = track;
	    this._snapshot = new AnimSnapshot(track);
	    this._playing = playing;
	    this._time = time;
	    this._speed = speed;
	    this._loop = loop;
	    this._blendWeight = 1.0;
	    this._blendOrder = 0.0;
	    this._eventHandler = eventHandler;
	    this._eventCursor = 0;

	    while (this._track.events[this._eventCursor] && this._track.events[this._eventCursor].time < this.time) {
	      this._eventCursor++;
	    }
	  }

	  var _proto = AnimClip.prototype;

	  _proto.activeEventsForFrame = function activeEventsForFrame(frameStartTime, frameEndTime) {
	    if (frameStartTime === 0) {
	      this.eventCursor = 0;
	    }

	    var clippedFrameDuration;

	    if (frameEndTime > this.track.duration) {
	      clippedFrameDuration = frameEndTime - this.track.duration;
	      frameEndTime = this.track.duration;
	    }

	    while (this.track.events[this.eventCursor] && this.track.events[this.eventCursor].time >= frameStartTime && (frameEndTime === this.track.duration ? this.track.events[this.eventCursor].time <= frameEndTime : this.track.events[this.eventCursor].time < frameEndTime)) {
	      var event = this.track.events[this.eventCursor];

	      this._eventHandler.fire(event.name, _extends({
	        track: this.track
	      }, event));

	      this.eventCursor++;
	    }

	    if (Number.isFinite(clippedFrameDuration)) {
	      this.activeEventsForFrame(0, clippedFrameDuration);
	    }
	  };

	  _proto._update = function _update(deltaTime) {
	    if (this._playing) {
	      var time = this._time;
	      var duration = this._track.duration;
	      var speed = this._speed;
	      var loop = this._loop;

	      if (this._track.events.length > 0 && duration > 0) {
	        this.activeEventsForFrame(time, time + speed * deltaTime);
	      }

	      time += speed * deltaTime;

	      if (speed >= 0) {
	        if (time > duration) {
	          if (loop) {
	            time = time % duration || 0;
	          } else {
	            time = this._track.duration;
	            this.pause();
	          }
	        }
	      } else {
	        if (time < 0) {
	          if (loop) {
	            time = duration + (time % duration || 0);
	          } else {
	            time = 0;
	            this.pause();
	          }
	        }
	      }

	      this._time = time;
	    }

	    if (this._time !== this._snapshot._time) {
	      this._track.eval(this._time, this._snapshot);
	    }
	  };

	  _proto.play = function play() {
	    this._playing = true;
	    this._time = 0;
	  };

	  _proto.stop = function stop() {
	    this._playing = false;
	    this._time = 0;
	  };

	  _proto.pause = function pause() {
	    this._playing = false;
	  };

	  _proto.resume = function resume() {
	    this._playing = true;
	  };

	  _proto.reset = function reset() {
	    this._time = 0;
	  };

	  _createClass(AnimClip, [{
	    key: "name",
	    get: function get() {
	      return this._name;
	    },
	    set: function set(name) {
	      this._name = name;
	    }
	  }, {
	    key: "track",
	    get: function get() {
	      return this._track;
	    }
	  }, {
	    key: "snapshot",
	    get: function get() {
	      return this._snapshot;
	    }
	  }, {
	    key: "time",
	    get: function get() {
	      return this._time;
	    },
	    set: function set(time) {
	      this._time = time;
	    }
	  }, {
	    key: "speed",
	    get: function get() {
	      return this._speed;
	    },
	    set: function set(speed) {
	      this._speed = speed;
	    }
	  }, {
	    key: "loop",
	    get: function get() {
	      return this._loop;
	    },
	    set: function set(loop) {
	      this._loop = loop;
	    }
	  }, {
	    key: "blendWeight",
	    get: function get() {
	      return this._blendWeight;
	    },
	    set: function set(blendWeight) {
	      this._blendWeight = blendWeight;
	    }
	  }, {
	    key: "blendOrder",
	    get: function get() {
	      return this._blendOrder;
	    },
	    set: function set(blendOrder) {
	      this._blendOrder = blendOrder;
	    }
	  }, {
	    key: "eventCursor",
	    get: function get() {
	      return this._eventCursor;
	    },
	    set: function set(value) {
	      this._eventCursor = value;
	    }
	  }]);

	  return AnimClip;
	}();

	var AnimCurve = function () {
	  function AnimCurve(paths, input, output, interpolation) {
	    this._paths = paths;
	    this._input = input;
	    this._output = output;
	    this._interpolation = interpolation;
	  }

	  _createClass(AnimCurve, [{
	    key: "paths",
	    get: function get() {
	      return this._paths;
	    }
	  }, {
	    key: "input",
	    get: function get() {
	      return this._input;
	    }
	  }, {
	    key: "output",
	    get: function get() {
	      return this._output;
	    }
	  }, {
	    key: "interpolation",
	    get: function get() {
	      return this._interpolation;
	    }
	  }]);

	  return AnimCurve;
	}();

	var AnimData = function () {
	  function AnimData(components, data) {
	    this._components = components;
	    this._data = data;
	  }

	  _createClass(AnimData, [{
	    key: "components",
	    get: function get() {
	      return this._components;
	    }
	  }, {
	    key: "data",
	    get: function get() {
	      return this._data;
	    }
	  }]);

	  return AnimData;
	}();

	var ANIM_INTERRUPTION_NONE = 'NONE';
	var ANIM_INTERRUPTION_PREV = 'PREV_STATE';
	var ANIM_INTERRUPTION_NEXT = 'NEXT_STATE';
	var ANIM_INTERRUPTION_PREV_NEXT = 'PREV_STATE_NEXT_STATE';
	var ANIM_INTERRUPTION_NEXT_PREV = 'NEXT_STATE_PREV_STATE';
	var ANIM_GREATER_THAN = 'GREATER_THAN';
	var ANIM_LESS_THAN = 'LESS_THAN';
	var ANIM_GREATER_THAN_EQUAL_TO = 'GREATER_THAN_EQUAL_TO';
	var ANIM_LESS_THAN_EQUAL_TO = 'LESS_THAN_EQUAL_TO';
	var ANIM_EQUAL_TO = 'EQUAL_TO';
	var ANIM_NOT_EQUAL_TO = 'NOT_EQUAL_TO';
	var ANIM_PARAMETER_INTEGER = 'INTEGER';
	var ANIM_PARAMETER_FLOAT = 'FLOAT';
	var ANIM_PARAMETER_BOOLEAN = 'BOOLEAN';
	var ANIM_PARAMETER_TRIGGER = 'TRIGGER';
	var ANIM_BLEND_1D = '1D';
	var ANIM_BLEND_2D_DIRECTIONAL = '2D_DIRECTIONAL';
	var ANIM_BLEND_2D_CARTESIAN = '2D_CARTESIAN';
	var ANIM_BLEND_DIRECT = 'DIRECT';
	var ANIM_STATE_START = 'START';
	var ANIM_STATE_END = 'END';
	var ANIM_STATE_ANY = 'ANY';
	var ANIM_CONTROL_STATES = [ANIM_STATE_START, ANIM_STATE_END, ANIM_STATE_ANY];
	var ANIM_LAYER_OVERWRITE = 'OVERWRITE';
	var ANIM_LAYER_ADDITIVE = 'ADDITIVE';

	var AnimTargetValue = function () {
	  function AnimTargetValue(component, type) {
	    this._component = component;
	    this.mask = new Int8Array(component.layers.length);
	    this.weights = new Float32Array(component.layers.length);
	    this.totalWeight = 0;
	    this.counter = 0;
	    this.layerCounter = 0;
	    this.valueType = type;
	    this.dirty = true;
	    this.value = type === AnimTargetValue.TYPE_QUAT ? [0, 0, 0, 1] : [0, 0, 0];
	    this.baseValue = null;
	    this.setter = null;
	  }

	  var _proto = AnimTargetValue.prototype;

	  _proto.getWeight = function getWeight(index) {
	    if (this.dirty) this.updateWeights();

	    if (this._normalizeWeights && this.totalWeight === 0 || !this.mask[index]) {
	      return 0;
	    } else if (this._normalizeWeights) {
	      return this.weights[index] / this.totalWeight;
	    }

	    return math.clamp(this.weights[index], 0, 1);
	  };

	  _proto._layerBlendType = function _layerBlendType(index) {
	    return this._component.layers[index].blendType;
	  };

	  _proto.setMask = function setMask(index, value) {
	    this.mask[index] = value;

	    if (this._normalizeWeights) {
	      if (this._component.layers[index].blendType === ANIM_LAYER_OVERWRITE) {
	        this.mask = this.mask.fill(0, 0, index);
	      }

	      this.dirty = true;
	    }
	  };

	  _proto.updateWeights = function updateWeights() {
	    this.totalWeight = 0;

	    for (var i = 0; i < this.weights.length; i++) {
	      this.weights[i] = this._component.layers[i].weight;
	      this.totalWeight += this.mask[i] * this.weights[i];
	    }

	    this.dirty = false;
	  };

	  _proto.updateValue = function updateValue(index, value) {
	    if (this.counter === 0) {
	      AnimEvaluator._set(this.value, AnimTargetValue.IDENTITY_QUAT_ARR, this.valueType);

	      if (!this._normalizeWeights) {
	        AnimEvaluator._blend(this.value, this.baseValue, 1, this.valueType);
	      }
	    }

	    if (!this.mask[index] || this.getWeight(index) === 0) return;

	    if (this._layerBlendType(index) === ANIM_LAYER_ADDITIVE && !this._normalizeWeights) {
	      if (this.valueType === AnimTargetValue.TYPE_QUAT) {
	        var v = AnimTargetValue.q1.set(this.value[0], this.value[1], this.value[2], this.value[3]);
	        var aV1 = AnimTargetValue.q2.set(this.baseValue[0], this.baseValue[1], this.baseValue[2], this.baseValue[3]);
	        var aV2 = AnimTargetValue.q3.set(value[0], value[1], value[2], value[3]);
	        var aV = aV1.invert().mul(aV2);
	        aV.slerp(Quat.IDENTITY, aV, this.getWeight(index));
	        v.mul(aV);
	        AnimTargetValue.quatArr[0] = v.x;
	        AnimTargetValue.quatArr[1] = v.y;
	        AnimTargetValue.quatArr[2] = v.z;
	        AnimTargetValue.quatArr[3] = v.w;

	        AnimEvaluator._set(this.value, AnimTargetValue.quatArr, this.valueType);
	      } else {
	        AnimTargetValue.vecArr[0] = value[0] - this.baseValue[0];
	        AnimTargetValue.vecArr[1] = value[1] - this.baseValue[1];
	        AnimTargetValue.vecArr[2] = value[2] - this.baseValue[2];

	        AnimEvaluator._blend(this.value, AnimTargetValue.vecArr, this.getWeight(index), this.valueType, true);
	      }
	    } else {
	      AnimEvaluator._blend(this.value, value, this.getWeight(index), this.valueType);
	    }

	    if (this.setter) this.setter(this.value);
	  };

	  _proto.unbind = function unbind() {
	    if (this.setter) {
	      this.setter(this.baseValue);
	    }
	  };

	  _createClass(AnimTargetValue, [{
	    key: "_normalizeWeights",
	    get: function get() {
	      return this._component.normalizeWeights;
	    }
	  }]);

	  return AnimTargetValue;
	}();

	AnimTargetValue.TYPE_QUAT = 'quaternion';
	AnimTargetValue.TYPE_VEC3 = 'vector3';
	AnimTargetValue.q1 = new Quat();
	AnimTargetValue.q2 = new Quat();
	AnimTargetValue.q3 = new Quat();
	AnimTargetValue.quatArr = [0, 0, 0, 1];
	AnimTargetValue.vecArr = [0, 0, 0];
	AnimTargetValue.IDENTITY_QUAT_ARR = [0, 0, 0, 1];

	var AnimEvaluator = function () {
	  function AnimEvaluator(binder) {
	    this._binder = binder;
	    this._clips = [];
	    this._inputs = [];
	    this._outputs = [];
	    this._targets = {};
	  }

	  AnimEvaluator._dot = function _dot(a, b) {
	    var len = a.length;
	    var result = 0;

	    for (var i = 0; i < len; ++i) {
	      result += a[i] * b[i];
	    }

	    return result;
	  };

	  AnimEvaluator._normalize = function _normalize(a) {
	    var l = AnimEvaluator._dot(a, a);

	    if (l > 0) {
	      l = 1.0 / Math.sqrt(l);
	      var len = a.length;

	      for (var i = 0; i < len; ++i) {
	        a[i] *= l;
	      }
	    }
	  };

	  AnimEvaluator._set = function _set(a, b, type) {
	    var len = a.length;

	    if (type === 'quaternion') {
	      var l = AnimEvaluator._dot(b, b);

	      if (l > 0) {
	        l = 1.0 / Math.sqrt(l);
	      }

	      for (var i = 0; i < len; ++i) {
	        a[i] = b[i] * l;
	      }
	    } else {
	      for (var _i = 0; _i < len; ++_i) {
	        a[_i] = b[_i];
	      }
	    }
	  };

	  AnimEvaluator._blendVec = function _blendVec(a, b, t, additive) {
	    var it = additive ? 1.0 : 1.0 - t;
	    var len = a.length;

	    for (var i = 0; i < len; ++i) {
	      a[i] = a[i] * it + b[i] * t;
	    }
	  };

	  AnimEvaluator._blendQuat = function _blendQuat(a, b, t, additive) {
	    var len = a.length;
	    var it = additive ? 1.0 : 1.0 - t;

	    if (AnimEvaluator._dot(a, b) < 0) {
	      t = -t;
	    }

	    for (var i = 0; i < len; ++i) {
	      a[i] = a[i] * it + b[i] * t;
	    }

	    if (!additive) {
	      AnimEvaluator._normalize(a);
	    }
	  };

	  AnimEvaluator._blend = function _blend(a, b, t, type, additive) {
	    if (type === 'quaternion') {
	      AnimEvaluator._blendQuat(a, b, t, additive);
	    } else {
	      AnimEvaluator._blendVec(a, b, t, additive);
	    }
	  };

	  AnimEvaluator._stableSort = function _stableSort(a, lessFunc) {
	    var len = a.length;

	    for (var i = 0; i < len - 1; ++i) {
	      for (var j = i + 1; j < len; ++j) {
	        if (lessFunc(a[j], a[i])) {
	          var tmp = a[i];
	          a[i] = a[j];
	          a[j] = tmp;
	        }
	      }
	    }
	  };

	  var _proto = AnimEvaluator.prototype;

	  _proto.addClip = function addClip(clip) {
	    var targets = this._targets;
	    var binder = this._binder;
	    var curves = clip.track.curves;
	    var snapshot = clip.snapshot;
	    var inputs = [];
	    var outputs = [];

	    for (var i = 0; i < curves.length; ++i) {
	      var curve = curves[i];
	      var paths = curve.paths;

	      for (var j = 0; j < paths.length; ++j) {
	        var path = paths[j];
	        var resolved = binder.resolve(path);
	        var target = targets[resolved && resolved.targetPath || null];

	        if (!target && resolved) {
	          target = {
	            target: resolved,
	            value: [],
	            curves: 0,
	            blendCounter: 0
	          };

	          for (var k = 0; k < target.target.components; ++k) {
	            target.value.push(0);
	          }

	          targets[resolved.targetPath] = target;

	          if (binder.animComponent) {
	            if (!binder.animComponent.targets[resolved.targetPath]) {
	              var type = void 0;

	              if (resolved.targetPath.substring(resolved.targetPath.length - 13) === 'localRotation') {
	                type = AnimTargetValue.TYPE_QUAT;
	              } else {
	                type = AnimTargetValue.TYPE_VEC3;
	              }

	              binder.animComponent.targets[resolved.targetPath] = new AnimTargetValue(binder.animComponent, type);
	            }

	            binder.animComponent.targets[resolved.targetPath].layerCounter++;
	            binder.animComponent.targets[resolved.targetPath].setMask(binder.layerIndex, 1);
	          }
	        }

	        if (target) {
	          target.curves++;
	          inputs.push(snapshot._results[i]);
	          outputs.push(target);
	        }
	      }
	    }

	    this._clips.push(clip);

	    this._inputs.push(inputs);

	    this._outputs.push(outputs);
	  };

	  _proto.removeClip = function removeClip(index) {
	    var targets = this._targets;
	    var binder = this._binder;
	    var clips = this._clips;
	    var clip = clips[index];
	    var curves = clip.track.curves;

	    for (var i = 0; i < curves.length; ++i) {
	      var curve = curves[i];
	      var paths = curve.paths;

	      for (var j = 0; j < paths.length; ++j) {
	        var path = paths[j];

	        var target = this._binder.resolve(path);

	        if (target) {
	          target.curves--;

	          if (target.curves === 0) {
	            binder.unresolve(path);
	            delete targets[target.targetPath];

	            if (binder.animComponent) {
	              binder.animComponent.targets[target.targetPath].layerCounter--;
	            }
	          }
	        }
	      }
	    }

	    clips.splice(index, 1);

	    this._inputs.splice(index, 1);

	    this._outputs.splice(index, 1);
	  };

	  _proto.removeClips = function removeClips() {
	    while (this._clips.length > 0) {
	      this.removeClip(0);
	    }
	  };

	  _proto.findClip = function findClip(name) {
	    var clips = this._clips;

	    for (var i = 0; i < clips.length; ++i) {
	      var clip = clips[i];

	      if (clip.name === name) {
	        return clip;
	      }
	    }

	    return null;
	  };

	  _proto.rebind = function rebind() {
	    var _this = this;

	    this._binder.rebind();

	    this._targets = {};
	    var clips = [].concat(this.clips);
	    this.removeClips();
	    clips.forEach(function (clip) {
	      _this.addClip(clip);
	    });
	  };

	  _proto.assignMask = function assignMask(mask) {
	    return this._binder.assignMask(mask);
	  };

	  _proto.update = function update(deltaTime) {
	    var clips = this._clips;
	    var order = clips.map(function (c, i) {
	      return i;
	    });

	    AnimEvaluator._stableSort(order, function (a, b) {
	      return clips[a].blendOrder < clips[b].blendOrder;
	    });

	    for (var i = 0; i < order.length; ++i) {
	      var index = order[i];
	      var clip = clips[index];
	      var inputs = this._inputs[index];
	      var outputs = this._outputs[index];
	      var blendWeight = clip.blendWeight;

	      if (blendWeight > 0.0) {
	        clip._update(deltaTime);
	      }

	      var input = void 0;
	      var output = void 0;
	      var value = void 0;

	      if (blendWeight >= 1.0) {
	        for (var j = 0; j < inputs.length; ++j) {
	          input = inputs[j];
	          output = outputs[j];
	          value = output.value;

	          AnimEvaluator._set(value, input, output.target.type);

	          output.blendCounter++;
	        }
	      } else if (blendWeight > 0.0) {
	        for (var _j = 0; _j < inputs.length; ++_j) {
	          input = inputs[_j];
	          output = outputs[_j];
	          value = output.value;

	          if (output.blendCounter === 0) {
	            AnimEvaluator._set(value, input, output.target.type);
	          } else {
	            AnimEvaluator._blend(value, input, blendWeight, output.target.type);
	          }

	          output.blendCounter++;
	        }
	      }
	    }

	    var targets = this._targets;
	    var binder = this._binder;

	    for (var path in targets) {
	      if (targets.hasOwnProperty(path)) {
	        var target = targets[path];

	        if (binder.animComponent && target.target.isTransform) {
	          var animTarget = binder.animComponent.targets[path];

	          if (animTarget.counter === animTarget.layerCounter) {
	            animTarget.counter = 0;
	          }

	          if (!animTarget.path) {
	            animTarget.path = path;
	            animTarget.baseValue = target.target.get();
	            animTarget.setter = target.target.set;
	          }

	          animTarget.updateValue(binder.layerIndex, target.value);
	          animTarget.counter++;
	        } else {
	          target.target.set(target.value);
	        }

	        target.blendCounter = 0;
	      }
	    }

	    binder.update(deltaTime);
	  };

	  _createClass(AnimEvaluator, [{
	    key: "clips",
	    get: function get() {
	      return this._clips;
	    }
	  }]);

	  return AnimEvaluator;
	}();

	var AnimTarget = function () {
	  function AnimTarget(func, type, components, targetPath) {
	    if (func.set) {
	      this._set = func.set;
	      this._get = func.get;
	    } else {
	      this._set = func;
	    }

	    this._type = type;
	    this._components = components;
	    this._targetPath = targetPath;
	    this._isTransform = this._targetPath.substring(this._targetPath.length - 13) === 'localRotation' || this._targetPath.substring(this._targetPath.length - 13) === 'localPosition' || this._targetPath.substring(this._targetPath.length - 10) === 'localScale';
	  }

	  _createClass(AnimTarget, [{
	    key: "set",
	    get: function get() {
	      return this._set;
	    }
	  }, {
	    key: "get",
	    get: function get() {
	      return this._get;
	    }
	  }, {
	    key: "type",
	    get: function get() {
	      return this._type;
	    }
	  }, {
	    key: "components",
	    get: function get() {
	      return this._components;
	    }
	  }, {
	    key: "targetPath",
	    get: function get() {
	      return this._targetPath;
	    }
	  }, {
	    key: "isTransform",
	    get: function get() {
	      return this._isTransform;
	    }
	  }]);

	  return AnimTarget;
	}();

	var AnimEvents = function () {
	  function AnimEvents(events) {
	    this._events = [].concat(events);

	    this._events.sort(function (a, b) {
	      return a.time - b.time;
	    });
	  }

	  _createClass(AnimEvents, [{
	    key: "events",
	    get: function get() {
	      return this._events;
	    }
	  }]);

	  return AnimEvents;
	}();

	var AnimTrack = function () {
	  function AnimTrack(name, duration, inputs, outputs, curves, animEvents) {
	    if (animEvents === void 0) {
	      animEvents = new AnimEvents([]);
	    }

	    this._name = name;
	    this._duration = duration;
	    this._inputs = inputs;
	    this._outputs = outputs;
	    this._curves = curves;
	    this._animEvents = animEvents;
	  }

	  var _proto = AnimTrack.prototype;

	  _proto.eval = function _eval(time, snapshot) {
	    snapshot._time = time;
	    var inputs = this._inputs;
	    var outputs = this._outputs;
	    var curves = this._curves;
	    var cache = snapshot._cache;
	    var results = snapshot._results;

	    for (var i = 0; i < inputs.length; ++i) {
	      cache[i].update(time, inputs[i]._data);
	    }

	    for (var _i = 0; _i < curves.length; ++_i) {
	      var curve = curves[_i];
	      var output = outputs[curve._output];
	      var result = results[_i];

	      cache[curve._input].eval(result, curve._interpolation, output);
	    }
	  };

	  _createClass(AnimTrack, [{
	    key: "name",
	    get: function get() {
	      return this._name;
	    }
	  }, {
	    key: "duration",
	    get: function get() {
	      return this._duration;
	    }
	  }, {
	    key: "inputs",
	    get: function get() {
	      return this._inputs;
	    }
	  }, {
	    key: "outputs",
	    get: function get() {
	      return this._outputs;
	    }
	  }, {
	    key: "curves",
	    get: function get() {
	      return this._curves;
	    }
	  }, {
	    key: "events",
	    get: function get() {
	      return this._animEvents.events;
	    },
	    set: function set(animEvents) {
	      this._animEvents = animEvents;
	    }
	  }]);

	  return AnimTrack;
	}();

	var DefaultAnimBinder = function () {
	  function DefaultAnimBinder(graph) {
	    var _this = this;

	    this._isPathInMask = function (path, checkMaskValue) {
	      var maskItem = _this._mask[path];
	      if (!maskItem) return false;else if (maskItem.children || checkMaskValue && maskItem.value !== false) return true;
	      return false;
	    };

	    this.graph = graph;
	    if (!graph) return;
	    this._mask = null;
	    var nodes = {};

	    var flatten = function flatten(node) {
	      nodes[node.name] = node;

	      for (var i = 0; i < node.children.length; ++i) {
	        flatten(node.children[i]);
	      }
	    };

	    flatten(graph);
	    this.nodes = nodes;
	    this.targetCache = {};

	    var findMeshInstances = function findMeshInstances(node) {
	      var object = node;

	      while (object && !(object instanceof Entity)) {
	        object = object.parent;
	      }

	      var meshInstances;

	      if (object) {
	        if (object.render) {
	          meshInstances = object.render.meshInstances;
	        } else if (object.model) {
	          meshInstances = object.model.meshInstances;
	        }
	      }

	      return meshInstances;
	    };

	    this.nodeCounts = {};
	    this.activeNodes = [];
	    this.handlers = {
	      'localPosition': function localPosition(node) {
	        var object = node.localPosition;

	        var func = function func(value) {
	          object.set.apply(object, value);
	        };

	        return DefaultAnimBinder.createAnimTarget(func, 'vector', 3, node, 'localPosition');
	      },
	      'localRotation': function localRotation(node) {
	        var object = node.localRotation;

	        var func = function func(value) {
	          object.set.apply(object, value);
	        };

	        return DefaultAnimBinder.createAnimTarget(func, 'quaternion', 4, node, 'localRotation');
	      },
	      'localScale': function localScale(node) {
	        var object = node.localScale;

	        var func = function func(value) {
	          object.set.apply(object, value);
	        };

	        return DefaultAnimBinder.createAnimTarget(func, 'vector', 3, node, 'localScale');
	      },
	      'weight': function weight(node, weightName) {
	        if (weightName.indexOf('name.') === 0) {
	          weightName = weightName.replace('name.', '');
	        } else {
	          weightName = Number(weightName);
	        }

	        var meshInstances = findMeshInstances(node);

	        if (meshInstances) {
	          for (var i = 0; i < meshInstances.length; ++i) {
	            if (meshInstances[i].node.name === node.name && meshInstances[i].morphInstance) {
	              var _ret = function () {
	                var morphInstance = meshInstances[i].morphInstance;

	                var func = function func(value) {
	                  morphInstance.setWeight(weightName, value[0]);
	                };

	                return {
	                  v: DefaultAnimBinder.createAnimTarget(func, 'number', 1, node, "weight." + weightName)
	                };
	              }();

	              if (typeof _ret === "object") return _ret.v;
	            }
	          }
	        }

	        return null;
	      },
	      'materialTexture': function materialTexture(node, textureName) {
	        var meshInstances = findMeshInstances(node);

	        if (meshInstances) {
	          var meshInstance;

	          for (var i = 0; i < meshInstances.length; ++i) {
	            if (meshInstances[i].node.name === node.name) {
	              meshInstance = meshInstances[i];
	              break;
	            }
	          }

	          if (meshInstance) {
	            var func = function func(value) {
	              var textureAsset = _this.animComponent.system.app.assets.get(value[0]);

	              if (textureAsset && textureAsset.resource && textureAsset.type === 'texture') {
	                meshInstance.material[textureName] = textureAsset.resource;
	                meshInstance.material.update();
	              }
	            };

	            return DefaultAnimBinder.createAnimTarget(func, 'vector', 1, node, 'materialTexture', 'material');
	          }
	        }

	        return null;
	      }
	    };
	  }

	  var _proto = DefaultAnimBinder.prototype;

	  _proto._isPathActive = function _isPathActive(path) {
	    if (!this._mask) return true;
	    var rootNodeNames = [path.entityPath[0], this.graph.name];

	    for (var j = 0; j < rootNodeNames.length; ++j) {
	      var currEntityPath = rootNodeNames[j];
	      if (this._isPathInMask(currEntityPath, path.entityPath.length === 1)) return true;

	      for (var i = 1; i < path.entityPath.length; i++) {
	        currEntityPath += '/' + path.entityPath[i];
	        if (this._isPathInMask(currEntityPath, i === path.entityPath.length - 1)) return true;
	      }
	    }

	    return false;
	  };

	  _proto.findNode = function findNode(path) {
	    if (!this._isPathActive(path)) {
	      return null;
	    }

	    var node;

	    if (this.graph) {
	      node = this.graph.findByPath(path.entityPath);

	      if (!node) {
	        node = this.graph.findByPath(path.entityPath.slice(1));
	      }
	    }

	    if (!node) {
	      node = this.nodes[path.entityPath[path.entityPath.length - 1] || ""];
	    }

	    return node;
	  };

	  DefaultAnimBinder.createAnimTarget = function createAnimTarget(func, type, valueCount, node, propertyPath, componentType) {
	    var targetPath = AnimBinder.encode(node.path, componentType ? componentType : 'entity', propertyPath);
	    return new AnimTarget(func, type, valueCount, targetPath);
	  };

	  _proto.resolve = function resolve(path) {
	    var encodedPath = AnimBinder.encode(path.entityPath, path.component, path.propertyPath);
	    var target = this.targetCache[encodedPath];
	    if (target) return target;
	    var node = this.findNode(path);

	    if (!node) {
	      return null;
	    }

	    var handler = this.handlers[path.propertyPath];

	    if (!handler) {
	      return null;
	    }

	    target = handler(node);

	    if (!target) {
	      return null;
	    }

	    this.targetCache[encodedPath] = target;

	    if (!this.nodeCounts[node.path]) {
	      this.activeNodes.push(node);
	      this.nodeCounts[node.path] = 1;
	    } else {
	      this.nodeCounts[node.path]++;
	    }

	    return target;
	  };

	  _proto.unresolve = function unresolve(path) {
	    if (path.component !== 'graph') return;
	    var node = this.nodes[path.entityPath[path.entityPath.length - 1] || ""];
	    this.nodeCounts[node.path]--;

	    if (this.nodeCounts[node.path] === 0) {
	      var activeNodes = this.activeNodes;
	      var i = activeNodes.indexOf(node.node);
	      var len = activeNodes.length;

	      if (i < len - 1) {
	        activeNodes[i] = activeNodes[len - 1];
	      }

	      activeNodes.pop();
	    }
	  };

	  _proto.update = function update(deltaTime) {
	    var activeNodes = this.activeNodes;

	    for (var i = 0; i < activeNodes.length; ++i) {
	      activeNodes[i]._dirtifyLocal();
	    }
	  };

	  _proto.assignMask = function assignMask(mask) {
	    if (mask !== this._mask) {
	      this._mask = mask;
	      return true;
	    }

	    return false;
	  };

	  return DefaultAnimBinder;
	}();

	var AnimNode = function () {
	  function AnimNode(state, parent, name, point, speed) {
	    if (speed === void 0) {
	      speed = 1;
	    }

	    this._state = state;
	    this._parent = parent;
	    this._name = name;

	    if (Array.isArray(point)) {
	      this._point = new Vec2(point[0], point[1]);
	      this._pointLength = this._point.length();
	    } else {
	      this._point = point;
	      this._pointLength = point;
	    }

	    this._speed = speed;
	    this._weightedSpeed = 1.0;
	    this._weight = 1.0;
	    this._animTrack = null;
	  }

	  _createClass(AnimNode, [{
	    key: "parent",
	    get: function get() {
	      return this._parent;
	    }
	  }, {
	    key: "name",
	    get: function get() {
	      return this._name;
	    }
	  }, {
	    key: "path",
	    get: function get() {
	      return this._parent ? this._parent.path + '.' + this._name : this._name;
	    }
	  }, {
	    key: "point",
	    get: function get() {
	      return this._point;
	    }
	  }, {
	    key: "pointLength",
	    get: function get() {
	      return this._pointLength;
	    }
	  }, {
	    key: "weight",
	    get: function get() {
	      return this._parent ? this._parent.weight * this._weight : this._weight;
	    },
	    set: function set(value) {
	      this._weight = value;
	    }
	  }, {
	    key: "normalizedWeight",
	    get: function get() {
	      var totalWeight = this._state.totalWeight;
	      if (totalWeight === 0.0) return 0.0;
	      return this.weight / totalWeight;
	    }
	  }, {
	    key: "speed",
	    get: function get() {
	      return this._weightedSpeed * this._speed;
	    }
	  }, {
	    key: "absoluteSpeed",
	    get: function get() {
	      return Math.abs(this._speed);
	    }
	  }, {
	    key: "weightedSpeed",
	    get: function get() {
	      return this._weightedSpeed;
	    },
	    set: function set(weightedSpeed) {
	      this._weightedSpeed = weightedSpeed;
	    }
	  }, {
	    key: "animTrack",
	    get: function get() {
	      return this._animTrack;
	    },
	    set: function set(value) {
	      this._animTrack = value;
	    }
	  }]);

	  return AnimNode;
	}();

	var AnimBlendTree = function (_AnimNode) {
	  _inheritsLoose(AnimBlendTree, _AnimNode);

	  function AnimBlendTree(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter) {
	    var _this;

	    _this = _AnimNode.call(this, state, parent, name, point) || this;
	    _this._parameters = parameters;
	    _this._parameterValues = new Array(parameters.length);
	    _this._children = [];
	    _this._findParameter = findParameter;
	    _this._syncAnimations = syncAnimations !== false;
	    _this._pointCache = {};

	    for (var i = 0; i < children.length; i++) {
	      var child = children[i];

	      if (child.children) {
	        _this._children.push(createTree(child.type, _assertThisInitialized(_this), null, name, 1.0, child.parameter ? [child.parameter] : child.parameters, child.children, createTree, findParameter));
	      } else {
	        _this._children.push(new AnimNode(state, _assertThisInitialized(_this), child.name, child.point, child.speed));
	      }
	    }

	    return _this;
	  }

	  var _proto = AnimBlendTree.prototype;

	  _proto.getChild = function getChild(name) {
	    for (var i = 0; i < this._children.length; i++) {
	      if (this._children[i].name === name) return this._children[i];
	    }

	    return null;
	  };

	  _proto.updateParameterValues = function updateParameterValues() {
	    var paramsEqual = true;

	    for (var i = 0; i < this._parameterValues.length; i++) {
	      var updatedParameter = this._findParameter(this._parameters[i]).value;

	      if (this._parameterValues[i] !== updatedParameter) {
	        this._parameterValues[i] = updatedParameter;
	        paramsEqual = false;
	      }
	    }

	    return paramsEqual;
	  };

	  _proto.getNodeWeightedDuration = function getNodeWeightedDuration(i) {
	    return this._children[i].animTrack.duration / this._children[i].speedMultiplier * this._children[i].weight;
	  };

	  _proto.getNodeCount = function getNodeCount() {
	    var count = 0;

	    for (var i = 0; i < this._children.length; i++) {
	      var child = this._children[i];

	      if (child.constructor === AnimBlendTree) {
	        count += this._children[i].getNodeCount();
	      } else {
	        count++;
	      }
	    }

	    return count;
	  };

	  _createClass(AnimBlendTree, [{
	    key: "weight",
	    get: function get() {
	      this.calculateWeights();
	      return this._parent ? this._parent.weight * this._weight : this._weight;
	    }
	  }, {
	    key: "syncAnimations",
	    get: function get() {
	      return this._syncAnimations;
	    }
	  }]);

	  return AnimBlendTree;
	}(AnimNode);

	var AnimBlendTree1D = function (_AnimBlendTree) {
	  _inheritsLoose(AnimBlendTree1D, _AnimBlendTree);

	  function AnimBlendTree1D(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter) {
	    children.sort(function (a, b) {
	      return a.point - b.point;
	    });
	    return _AnimBlendTree.call(this, state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter) || this;
	  }

	  var _proto = AnimBlendTree1D.prototype;

	  _proto.calculateWeights = function calculateWeights() {
	    if (this.updateParameterValues()) return;
	    var weightedDurationSum = 0.0;
	    this._children[0].weight = 0.0;

	    for (var i = 0; i < this._children.length; i++) {
	      var c1 = this._children[i];

	      if (i !== this._children.length - 1) {
	        var c2 = this._children[i + 1];

	        if (c1.point === c2.point) {
	          c1.weight = 0.5;
	          c2.weight = 0.5;
	        } else if (math.between(this._parameterValues[0], c1.point, c2.point, true)) {
	          var child2Distance = Math.abs(c1.point - c2.point);
	          var parameterDistance = Math.abs(c1.point - this._parameterValues[0]);
	          var weight = (child2Distance - parameterDistance) / child2Distance;
	          c1.weight = weight;
	          c2.weight = 1.0 - weight;
	        } else {
	          c2.weight = 0.0;
	        }
	      }

	      if (this._syncAnimations) {
	        weightedDurationSum += c1.animTrack.duration / c1.absoluteSpeed * c1.weight;
	      }
	    }

	    if (this._syncAnimations) {
	      for (var _i = 0; _i < this._children.length; _i++) {
	        var child = this._children[_i];
	        child.weightedSpeed = child.animTrack.duration / child.absoluteSpeed / weightedDurationSum;
	      }
	    }
	  };

	  return AnimBlendTree1D;
	}(AnimBlendTree);

	var AnimBlendTreeCartesian2D = function (_AnimBlendTree) {
	  _inheritsLoose(AnimBlendTreeCartesian2D, _AnimBlendTree);

	  function AnimBlendTreeCartesian2D() {
	    return _AnimBlendTree.apply(this, arguments) || this;
	  }

	  var _proto = AnimBlendTreeCartesian2D.prototype;

	  _proto.pointDistanceCache = function pointDistanceCache(i, j) {
	    var pointKey = "" + i + j;

	    if (!this._pointCache[pointKey]) {
	      this._pointCache[pointKey] = this._children[j].point.clone().sub(this._children[i].point);
	    }

	    return this._pointCache[pointKey];
	  };

	  _proto.calculateWeights = function calculateWeights() {
	    var _AnimBlendTreeCartesi;

	    if (this.updateParameterValues()) return;
	    var weightSum, weightedDurationSum;

	    (_AnimBlendTreeCartesi = AnimBlendTreeCartesian2D._p).set.apply(_AnimBlendTreeCartesi, this._parameterValues);

	    weightSum = 0.0;
	    weightedDurationSum = 0.0;

	    for (var i = 0; i < this._children.length; i++) {
	      var child = this._children[i];
	      var pi = child.point;

	      AnimBlendTreeCartesian2D._pip.set(AnimBlendTreeCartesian2D._p.x, AnimBlendTreeCartesian2D._p.y).sub(pi);

	      var minj = Number.MAX_VALUE;

	      for (var j = 0; j < this._children.length; j++) {
	        if (i === j) continue;
	        var pipj = this.pointDistanceCache(i, j);
	        var result = math.clamp(1.0 - AnimBlendTreeCartesian2D._pip.dot(pipj) / pipj.lengthSq(), 0.0, 1.0);
	        if (result < minj) minj = result;
	      }

	      child.weight = minj;
	      weightSum += minj;

	      if (this._syncAnimations) {
	        weightedDurationSum += child.animTrack.duration / child.absoluteSpeed * child.weight;
	      }
	    }

	    for (var _i = 0; _i < this._children.length; _i++) {
	      var _child = this._children[_i];
	      _child.weight = _child._weight / weightSum;

	      if (this._syncAnimations) {
	        _child.weightedSpeed = _child.animTrack.duration / _child.absoluteSpeed / weightedDurationSum;
	      }
	    }
	  };

	  return AnimBlendTreeCartesian2D;
	}(AnimBlendTree);

	AnimBlendTreeCartesian2D._p = new Vec2();
	AnimBlendTreeCartesian2D._pip = new Vec2();

	var AnimBlendTreeDirectional2D = function (_AnimBlendTree) {
	  _inheritsLoose(AnimBlendTreeDirectional2D, _AnimBlendTree);

	  function AnimBlendTreeDirectional2D() {
	    return _AnimBlendTree.apply(this, arguments) || this;
	  }

	  var _proto = AnimBlendTreeDirectional2D.prototype;

	  _proto.pointCache = function pointCache(i, j) {
	    var pointKey = "" + i + j;

	    if (!this._pointCache[pointKey]) {
	      this._pointCache[pointKey] = new Vec2((this._children[j].pointLength - this._children[i].pointLength) / ((this._children[j].pointLength + this._children[i].pointLength) / 2), Vec2.angleRad(this._children[i].point, this._children[j].point) * 2.0);
	    }

	    return this._pointCache[pointKey];
	  };

	  _proto.calculateWeights = function calculateWeights() {
	    var _AnimBlendTreeDirecti;

	    if (this.updateParameterValues()) return;
	    var weightSum, weightedDurationSum;

	    (_AnimBlendTreeDirecti = AnimBlendTreeDirectional2D._p).set.apply(_AnimBlendTreeDirecti, this._parameterValues);

	    var pLength = AnimBlendTreeDirectional2D._p.length();

	    weightSum = 0.0;
	    weightedDurationSum = 0.0;

	    for (var i = 0; i < this._children.length; i++) {
	      var child = this._children[i];
	      var pi = child.point;
	      var piLength = child.pointLength;
	      var minj = Number.MAX_VALUE;

	      for (var j = 0; j < this._children.length; j++) {
	        if (i === j) continue;
	        var pipj = this.pointCache(i, j);
	        var pjLength = this._children[j].pointLength;

	        AnimBlendTreeDirectional2D._pip.set((pLength - piLength) / ((pjLength + piLength) / 2), Vec2.angleRad(pi, AnimBlendTreeDirectional2D._p) * 2.0);

	        var result = math.clamp(1.0 - Math.abs(AnimBlendTreeDirectional2D._pip.dot(pipj) / pipj.lengthSq()), 0.0, 1.0);
	        if (result < minj) minj = result;
	      }

	      child.weight = minj;
	      weightSum += minj;

	      if (this._syncAnimations) {
	        weightedDurationSum += child.animTrack.duration / child.absoluteSpeed * child.weight;
	      }
	    }

	    for (var _i = 0; _i < this._children.length; _i++) {
	      var _child = this._children[_i];
	      _child.weight = _child._weight / weightSum;

	      if (this._syncAnimations) {
	        var weightedChildDuration = _child.animTrack.duration / weightedDurationSum * weightSum;
	        _child.weightedSpeed = _child.absoluteSpeed * weightedChildDuration;
	      }
	    }
	  };

	  return AnimBlendTreeDirectional2D;
	}(AnimBlendTree);

	AnimBlendTreeDirectional2D._p = new Vec2();
	AnimBlendTreeDirectional2D._pip = new Vec2();

	var AnimBlendTreeDirect = function (_AnimBlendTree) {
	  _inheritsLoose(AnimBlendTreeDirect, _AnimBlendTree);

	  function AnimBlendTreeDirect() {
	    return _AnimBlendTree.apply(this, arguments) || this;
	  }

	  var _proto = AnimBlendTreeDirect.prototype;

	  _proto.calculateWeights = function calculateWeights() {
	    if (this.updateParameterValues()) return;
	    var weightSum = 0.0;
	    var weightedDurationSum = 0.0;

	    for (var i = 0; i < this._children.length; i++) {
	      weightSum += Math.max(this._parameterValues[i], 0.0);

	      if (this._syncAnimations) {
	        var child = this._children[i];
	        weightedDurationSum += child.animTrack.duration / child.absoluteSpeed * child.weight;
	      }
	    }

	    for (var _i = 0; _i < this._children.length; _i++) {
	      var _child = this._children[_i];
	      var weight = Math.max(this._parameterValues[_i], 0.0);

	      if (weightSum) {
	        _child.weight = weight / weightSum;

	        if (this._syncAnimations) {
	          _child.weightedSpeed = _child.animTrack.duration / _child.absoluteSpeed / weightedDurationSum;
	        }
	      } else {
	        _child.weight = 0.0;

	        if (this._syncAnimations) {
	          _child.weightedSpeed = 0;
	        }
	      }
	    }
	  };

	  return AnimBlendTreeDirect;
	}(AnimBlendTree);

	var AnimState = function () {
	  function AnimState(controller, name, speed, loop, blendTree) {
	    this._controller = controller;
	    this._name = name;
	    this._animations = {};
	    this._animationList = [];
	    this._speed = speed || 1.0;
	    this._loop = loop === undefined ? true : loop;

	    var findParameter = this._controller.findParameter.bind(this._controller);

	    if (blendTree) {
	      this._blendTree = this._createTree(blendTree.type, this, null, name, 1.0, blendTree.parameter ? [blendTree.parameter] : blendTree.parameters, blendTree.children, blendTree.syncAnimations, this._createTree, findParameter);
	    } else {
	      this._blendTree = new AnimNode(this, null, name, 1.0, speed);
	    }
	  }

	  var _proto = AnimState.prototype;

	  _proto._createTree = function _createTree(type, state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter) {
	    switch (type) {
	      case ANIM_BLEND_1D:
	        return new AnimBlendTree1D(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);

	      case ANIM_BLEND_2D_CARTESIAN:
	        return new AnimBlendTreeCartesian2D(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);

	      case ANIM_BLEND_2D_DIRECTIONAL:
	        return new AnimBlendTreeDirectional2D(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);

	      case ANIM_BLEND_DIRECT:
	        return new AnimBlendTreeDirect(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);
	    }

	    return undefined;
	  };

	  _proto._getNodeFromPath = function _getNodeFromPath(path) {
	    var currNode = this._blendTree;

	    for (var i = 1; i < path.length; i++) {
	      currNode = currNode.getChild(path[i]);
	    }

	    return currNode;
	  };

	  _proto.addAnimation = function addAnimation(path, animTrack) {
	    var pathString = path.join('.');

	    var indexOfAnimation = this._animationList.findIndex(function (animation) {
	      return animation.path === pathString;
	    });

	    if (indexOfAnimation >= 0) {
	      this._animationList[indexOfAnimation].animTrack = animTrack;
	    } else {
	      var node = this._getNodeFromPath(path);

	      node.animTrack = animTrack;

	      this._animationList.push(node);
	    }
	  };

	  _createClass(AnimState, [{
	    key: "name",
	    get: function get() {
	      return this._name;
	    }
	  }, {
	    key: "animations",
	    get: function get() {
	      return this._animationList;
	    },
	    set: function set(value) {
	      this._animationList = value;
	    }
	  }, {
	    key: "speed",
	    get: function get() {
	      return this._speed;
	    },
	    set: function set(value) {
	      this._speed = value;
	    }
	  }, {
	    key: "loop",
	    get: function get() {
	      return this._loop;
	    },
	    set: function set(value) {
	      this._loop = value;
	    }
	  }, {
	    key: "nodeCount",
	    get: function get() {
	      if (!this._blendTree || this._blendTree.constructor === AnimNode) return 1;
	      return this._blendTree.getNodeCount();
	    }
	  }, {
	    key: "playable",
	    get: function get() {
	      return ANIM_CONTROL_STATES.indexOf(this.name) !== -1 || this.animations.length === this.nodeCount;
	    }
	  }, {
	    key: "looping",
	    get: function get() {
	      if (this.animations.length > 0) {
	        var trackClipName = this.name + '.' + this.animations[0].animTrack.name;

	        var trackClip = this._controller.animEvaluator.findClip(trackClipName);

	        if (trackClip) {
	          return trackClip.loop;
	        }
	      }

	      return false;
	    }
	  }, {
	    key: "totalWeight",
	    get: function get() {
	      var sum = 0;

	      for (var i = 0; i < this.animations.length; i++) {
	        sum += this.animations[i].weight;
	      }

	      return sum;
	    }
	  }, {
	    key: "timelineDuration",
	    get: function get() {
	      var duration = 0;

	      for (var i = 0; i < this.animations.length; i++) {
	        var animation = this.animations[i];

	        if (animation.animTrack.duration > duration) {
	          duration = animation.animTrack.duration;
	        }
	      }

	      return duration;
	    }
	  }]);

	  return AnimState;
	}();

	var AnimTransition = function () {
	  function AnimTransition(_ref) {
	    var from = _ref.from,
	        to = _ref.to,
	        _ref$time = _ref.time,
	        time = _ref$time === void 0 ? 0 : _ref$time,
	        _ref$priority = _ref.priority,
	        priority = _ref$priority === void 0 ? 0 : _ref$priority,
	        _ref$conditions = _ref.conditions,
	        conditions = _ref$conditions === void 0 ? [] : _ref$conditions,
	        _ref$exitTime = _ref.exitTime,
	        exitTime = _ref$exitTime === void 0 ? null : _ref$exitTime,
	        _ref$transitionOffset = _ref.transitionOffset,
	        transitionOffset = _ref$transitionOffset === void 0 ? null : _ref$transitionOffset,
	        _ref$interruptionSour = _ref.interruptionSource,
	        interruptionSource = _ref$interruptionSour === void 0 ? ANIM_INTERRUPTION_NONE : _ref$interruptionSour;
	    this._from = from;
	    this._to = to;
	    this._time = time;
	    this._priority = priority;
	    this._conditions = conditions;
	    this._exitTime = exitTime;
	    this._transitionOffset = transitionOffset;
	    this._interruptionSource = interruptionSource;
	  }

	  _createClass(AnimTransition, [{
	    key: "from",
	    get: function get() {
	      return this._from;
	    }
	  }, {
	    key: "to",
	    get: function get() {
	      return this._to;
	    },
	    set: function set(value) {
	      this._to = value;
	    }
	  }, {
	    key: "time",
	    get: function get() {
	      return this._time;
	    }
	  }, {
	    key: "priority",
	    get: function get() {
	      return this._priority;
	    }
	  }, {
	    key: "conditions",
	    get: function get() {
	      return this._conditions;
	    }
	  }, {
	    key: "exitTime",
	    get: function get() {
	      return this._exitTime;
	    }
	  }, {
	    key: "transitionOffset",
	    get: function get() {
	      return this._transitionOffset;
	    }
	  }, {
	    key: "interruptionSource",
	    get: function get() {
	      return this._interruptionSource;
	    }
	  }, {
	    key: "hasExitTime",
	    get: function get() {
	      return !!this.exitTime;
	    }
	  }]);

	  return AnimTransition;
	}();

	var AnimController = function () {
	  function AnimController(animEvaluator, states, transitions, parameters, activate, eventHandler, consumedTriggers) {
	    this._animEvaluator = animEvaluator;
	    this._states = {};
	    this._stateNames = [];
	    this._eventHandler = eventHandler;
	    this._consumedTriggers = consumedTriggers;

	    for (var i = 0; i < states.length; i++) {
	      this._states[states[i].name] = new AnimState(this, states[i].name, states[i].speed, states[i].loop, states[i].blendTree);

	      this._stateNames.push(states[i].name);
	    }

	    this._transitions = transitions.map(function (transition) {
	      return new AnimTransition(_extends({}, transition));
	    });
	    this._findTransitionsFromStateCache = {};
	    this._findTransitionsBetweenStatesCache = {};
	    this._parameters = parameters;
	    this._previousStateName = null;
	    this._activeStateName = ANIM_STATE_START;
	    this._playing = false;
	    this._activate = activate;
	    this._currTransitionTime = 1.0;
	    this._totalTransitionTime = 1.0;
	    this._isTransitioning = false;
	    this._transitionInterruptionSource = ANIM_INTERRUPTION_NONE;
	    this._transitionPreviousStates = [];
	    this._timeInState = 0;
	    this._timeInStateBefore = 0;
	  }

	  var _proto = AnimController.prototype;

	  _proto.assignMask = function assignMask(mask) {
	    return this._animEvaluator.assignMask(mask);
	  };

	  _proto._findState = function _findState(stateName) {
	    return this._states[stateName];
	  };

	  _proto._getActiveStateProgressForTime = function _getActiveStateProgressForTime(time) {
	    if (this.activeStateName === ANIM_STATE_START || this.activeStateName === ANIM_STATE_END || this.activeStateName === ANIM_STATE_ANY) return 1.0;

	    var activeClip = this._animEvaluator.findClip(this.activeStateAnimations[0].name);

	    if (activeClip) {
	      return time / activeClip.track.duration;
	    }

	    return null;
	  };

	  _proto._findTransitionsFromState = function _findTransitionsFromState(stateName) {
	    var transitions = this._findTransitionsFromStateCache[stateName];

	    if (!transitions) {
	      transitions = this._transitions.filter(function (transition) {
	        return transition.from === stateName;
	      });
	      sortPriority(transitions);
	      this._findTransitionsFromStateCache[stateName] = transitions;
	    }

	    return transitions;
	  };

	  _proto._findTransitionsBetweenStates = function _findTransitionsBetweenStates(sourceStateName, destinationStateName) {
	    var transitions = this._findTransitionsBetweenStatesCache[sourceStateName + '->' + destinationStateName];

	    if (!transitions) {
	      transitions = this._transitions.filter(function (transition) {
	        return transition.from === sourceStateName && transition.to === destinationStateName;
	      });
	      sortPriority(transitions);
	      this._findTransitionsBetweenStatesCache[sourceStateName + '->' + destinationStateName] = transitions;
	    }

	    return transitions;
	  };

	  _proto._transitionHasConditionsMet = function _transitionHasConditionsMet(transition) {
	    var conditions = transition.conditions;

	    for (var i = 0; i < conditions.length; i++) {
	      var condition = conditions[i];
	      var parameter = this.findParameter(condition.parameterName);

	      switch (condition.predicate) {
	        case ANIM_GREATER_THAN:
	          if (!(parameter.value > condition.value)) return false;
	          break;

	        case ANIM_LESS_THAN:
	          if (!(parameter.value < condition.value)) return false;
	          break;

	        case ANIM_GREATER_THAN_EQUAL_TO:
	          if (!(parameter.value >= condition.value)) return false;
	          break;

	        case ANIM_LESS_THAN_EQUAL_TO:
	          if (!(parameter.value <= condition.value)) return false;
	          break;

	        case ANIM_EQUAL_TO:
	          if (!(parameter.value === condition.value)) return false;
	          break;

	        case ANIM_NOT_EQUAL_TO:
	          if (!(parameter.value !== condition.value)) return false;
	          break;
	      }
	    }

	    return true;
	  };

	  _proto._findTransition = function _findTransition(from, to) {
	    var _this = this;

	    var transitions = [];

	    if (from && to) {
	      transitions = transitions.concat(this._findTransitionsBetweenStates(from, to));
	    } else {
	      if (!this._isTransitioning) {
	        transitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));
	        transitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));
	      } else {
	        switch (this._transitionInterruptionSource) {
	          case ANIM_INTERRUPTION_PREV:
	            transitions = transitions.concat(this._findTransitionsFromState(this._previousStateName));
	            transitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));
	            break;

	          case ANIM_INTERRUPTION_NEXT:
	            transitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));
	            transitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));
	            break;

	          case ANIM_INTERRUPTION_PREV_NEXT:
	            transitions = transitions.concat(this._findTransitionsFromState(this._previousStateName));
	            transitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));
	            transitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));
	            break;

	          case ANIM_INTERRUPTION_NEXT_PREV:
	            transitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));
	            transitions = transitions.concat(this._findTransitionsFromState(this._previousStateName));
	            transitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));
	            break;
	        }
	      }
	    }

	    transitions = transitions.filter(function (transition) {
	      if (transition.to === _this.activeStateName) {
	        return false;
	      }

	      if (transition.hasExitTime) {
	        var progressBefore = _this._getActiveStateProgressForTime(_this._timeInStateBefore);

	        var progress = _this._getActiveStateProgressForTime(_this._timeInState);

	        if (transition.exitTime < 1.0 && _this.activeState.loop) {
	          progressBefore -= Math.floor(progressBefore);
	          progress -= Math.floor(progress);
	        }

	        if (!(transition.exitTime > progressBefore && transition.exitTime <= progress)) {
	          return null;
	        }
	      }

	      return _this._transitionHasConditionsMet(transition);
	    });

	    if (transitions.length > 0) {
	      var transition = transitions[0];

	      if (transition.to === ANIM_STATE_END) {
	        var startTransition = this._findTransitionsFromState(ANIM_STATE_START)[0];

	        transition.to = startTransition.to;
	      }

	      return transition;
	    }

	    return null;
	  };

	  _proto.updateStateFromTransition = function updateStateFromTransition(transition) {
	    var state;
	    var animation;
	    var clip;
	    this.previousState = transition.from ? this.activeStateName : null;
	    this.activeState = transition.to;

	    for (var i = 0; i < transition.conditions.length; i++) {
	      var condition = transition.conditions[i];
	      var parameter = this.findParameter(condition.parameterName);

	      if (parameter.type === ANIM_PARAMETER_TRIGGER) {
	        this._consumedTriggers.add(condition.parameterName);
	      }
	    }

	    if (this.previousState) {
	      if (!this._isTransitioning) {
	        this._transitionPreviousStates = [];
	      }

	      this._transitionPreviousStates.push({
	        name: this._previousStateName,
	        weight: 1
	      });

	      var interpolatedTime = Math.min(this._totalTransitionTime !== 0 ? this._currTransitionTime / this._totalTransitionTime : 1, 1.0);

	      for (var _i = 0; _i < this._transitionPreviousStates.length; _i++) {
	        if (!this._isTransitioning) {
	          this._transitionPreviousStates[_i].weight = 1.0;
	        } else if (_i !== this._transitionPreviousStates.length - 1) {
	          this._transitionPreviousStates[_i].weight *= 1.0 - interpolatedTime;
	        } else {
	          this._transitionPreviousStates[_i].weight = interpolatedTime;
	        }

	        state = this._findState(this._transitionPreviousStates[_i].name);

	        for (var j = 0; j < state.animations.length; j++) {
	          animation = state.animations[j];
	          clip = this._animEvaluator.findClip(animation.name + '.previous.' + _i);

	          if (!clip) {
	            clip = this._animEvaluator.findClip(animation.name);
	            clip.name = animation.name + '.previous.' + _i;
	          }

	          if (_i !== this._transitionPreviousStates.length - 1) {
	            clip.pause();
	          }
	        }
	      }
	    }

	    this._isTransitioning = true;
	    this._totalTransitionTime = transition.time;
	    this._currTransitionTime = 0;
	    this._transitionInterruptionSource = transition.interruptionSource;
	    var activeState = this.activeState;
	    var hasTransitionOffset = transition.transitionOffset && transition.transitionOffset > 0.0 && transition.transitionOffset < 1.0;
	    var timeInState = 0;
	    var timeInStateBefore = 0;

	    if (hasTransitionOffset) {
	      var offsetTime = activeState.timelineDuration * transition.transitionOffset;
	      timeInState = offsetTime;
	      timeInStateBefore = offsetTime;
	    }

	    this._timeInState = timeInState;
	    this._timeInStateBefore = timeInStateBefore;

	    for (var _i2 = 0; _i2 < activeState.animations.length; _i2++) {
	      clip = this._animEvaluator.findClip(activeState.animations[_i2].name);

	      if (!clip) {
	        var speed = Number.isFinite(activeState.animations[_i2].speed) ? activeState.animations[_i2].speed : activeState.speed;
	        clip = new AnimClip(activeState.animations[_i2].animTrack, this._timeInState, speed, true, activeState.loop, this._eventHandler);
	        clip.name = activeState.animations[_i2].name;

	        this._animEvaluator.addClip(clip);
	      } else {
	        clip.reset();
	      }

	      if (transition.time > 0) {
	        clip.blendWeight = 0.0;
	      } else {
	        clip.blendWeight = activeState.animations[_i2].normalizedWeight;
	      }

	      clip.play();

	      if (hasTransitionOffset) {
	        clip.time = activeState.timelineDuration * transition.transitionOffset;
	      } else {
	        var startTime = activeState.speed >= 0 ? 0 : this.activeStateDuration;
	        clip.time = startTime;
	      }
	    }
	  };

	  _proto._transitionToState = function _transitionToState(newStateName) {
	    if (!this._findState(newStateName)) {
	      return;
	    }

	    var transition = this._findTransition(this._activeStateName, newStateName);

	    if (!transition) {
	      this._animEvaluator.removeClips();

	      transition = new AnimTransition({
	        from: null,
	        to: newStateName
	      });
	    }

	    this.updateStateFromTransition(transition);
	  };

	  _proto.assignAnimation = function assignAnimation(pathString, animTrack, speed, loop) {
	    var path = pathString.split('.');

	    var state = this._findState(path[0]);

	    if (!state) {
	      state = new AnimState(this, path[0], 1.0);
	      this._states[path[0]] = state;

	      this._stateNames.push(path[0]);
	    }

	    state.addAnimation(path, animTrack);

	    if (speed !== undefined) {
	      state.speed = speed;
	    }

	    if (loop !== undefined) {
	      state.loop = loop;
	    }

	    if (!this._playing && this._activate && this.playable) {
	      this.play();
	    }
	  };

	  _proto.removeNodeAnimations = function removeNodeAnimations(nodeName) {
	    if (ANIM_CONTROL_STATES.indexOf(nodeName) !== -1) {
	      return false;
	    }

	    var state = this._findState(nodeName);

	    if (!state) {
	      return false;
	    }

	    state.animations = [];
	    return true;
	  };

	  _proto.play = function play(stateName) {
	    if (stateName) {
	      this._transitionToState(stateName);
	    }

	    this._playing = true;
	  };

	  _proto.pause = function pause() {
	    this._playing = false;
	  };

	  _proto.reset = function reset() {
	    this._previousStateName = null;
	    this._activeStateName = ANIM_STATE_START;
	    this._playing = false;
	    this._currTransitionTime = 1.0;
	    this._totalTransitionTime = 1.0;
	    this._isTransitioning = false;
	    this._timeInState = 0;
	    this._timeInStateBefore = 0;

	    this._animEvaluator.removeClips();
	  };

	  _proto.rebind = function rebind() {
	    this._animEvaluator.rebind();
	  };

	  _proto.update = function update(dt) {
	    if (!this._playing) {
	      return;
	    }

	    var state;
	    var animation;
	    var clip;
	    this._timeInStateBefore = this._timeInState;
	    this._timeInState += dt;

	    var transition = this._findTransition(this._activeStateName);

	    if (transition) this.updateStateFromTransition(transition);

	    if (this._isTransitioning) {
	      this._currTransitionTime += dt;

	      if (this._currTransitionTime <= this._totalTransitionTime) {
	        var interpolatedTime = this._totalTransitionTime !== 0 ? this._currTransitionTime / this._totalTransitionTime : 1;

	        for (var i = 0; i < this._transitionPreviousStates.length; i++) {
	          state = this._findState(this._transitionPreviousStates[i].name);
	          var stateWeight = this._transitionPreviousStates[i].weight;

	          for (var j = 0; j < state.animations.length; j++) {
	            animation = state.animations[j];
	            clip = this._animEvaluator.findClip(animation.name + '.previous.' + i);

	            if (clip) {
	              clip.blendWeight = (1.0 - interpolatedTime) * animation.normalizedWeight * stateWeight;
	            }
	          }
	        }

	        state = this.activeState;

	        for (var _i3 = 0; _i3 < state.animations.length; _i3++) {
	          animation = state.animations[_i3];
	          this._animEvaluator.findClip(animation.name).blendWeight = interpolatedTime * animation.normalizedWeight;
	        }
	      } else {
	        this._isTransitioning = false;
	        var activeClips = this.activeStateAnimations.length;
	        var totalClips = this._animEvaluator.clips.length;

	        for (var _i4 = 0; _i4 < totalClips - activeClips; _i4++) {
	          this._animEvaluator.removeClip(0);
	        }

	        this._transitionPreviousStates = [];
	        state = this.activeState;

	        for (var _i5 = 0; _i5 < state.animations.length; _i5++) {
	          animation = state.animations[_i5];
	          clip = this._animEvaluator.findClip(animation.name);

	          if (clip) {
	            clip.blendWeight = animation.normalizedWeight;
	          }
	        }
	      }
	    } else {
	      if (this.activeState._blendTree.constructor !== AnimNode) {
	        state = this.activeState;

	        for (var _i6 = 0; _i6 < state.animations.length; _i6++) {
	          animation = state.animations[_i6];
	          clip = this._animEvaluator.findClip(animation.name);

	          if (clip) {
	            clip.blendWeight = animation.normalizedWeight;

	            if (animation.parent.syncAnimations) {
	              clip.speed = animation.speed;
	            }
	          }
	        }
	      }
	    }

	    this._animEvaluator.update(dt);
	  };

	  _proto.findParameter = function findParameter(name) {
	    return this._parameters[name];
	  };

	  _createClass(AnimController, [{
	    key: "animEvaluator",
	    get: function get() {
	      return this._animEvaluator;
	    }
	  }, {
	    key: "activeState",
	    get: function get() {
	      return this._findState(this._activeStateName);
	    },
	    set: function set(stateName) {
	      this._activeStateName = stateName;
	    }
	  }, {
	    key: "activeStateName",
	    get: function get() {
	      return this._activeStateName;
	    }
	  }, {
	    key: "activeStateAnimations",
	    get: function get() {
	      return this.activeState.animations;
	    }
	  }, {
	    key: "previousState",
	    get: function get() {
	      return this._findState(this._previousStateName);
	    },
	    set: function set(stateName) {
	      this._previousStateName = stateName;
	    }
	  }, {
	    key: "previousStateName",
	    get: function get() {
	      return this._previousStateName;
	    }
	  }, {
	    key: "playable",
	    get: function get() {
	      var playable = true;

	      for (var i = 0; i < this._stateNames.length; i++) {
	        if (!this._states[this._stateNames[i]].playable) {
	          playable = false;
	        }
	      }

	      return playable;
	    }
	  }, {
	    key: "playing",
	    get: function get() {
	      return this._playing;
	    },
	    set: function set(value) {
	      this._playing = value;
	    }
	  }, {
	    key: "activeStateProgress",
	    get: function get() {
	      return this._getActiveStateProgressForTime(this._timeInState);
	    }
	  }, {
	    key: "activeStateDuration",
	    get: function get() {
	      if (this.activeStateName === ANIM_STATE_START || this.activeStateName === ANIM_STATE_END) return 0.0;
	      var maxDuration = 0.0;

	      for (var i = 0; i < this.activeStateAnimations.length; i++) {
	        var activeClip = this._animEvaluator.findClip(this.activeStateAnimations[i].name);

	        if (activeClip) {
	          maxDuration = Math.max(maxDuration, activeClip.track.duration);
	        }
	      }

	      return maxDuration;
	    }
	  }, {
	    key: "activeStateCurrentTime",
	    get: function get() {
	      return this._timeInState;
	    },
	    set: function set(time) {
	      this._timeInStateBefore = time;
	      this._timeInState = time;

	      for (var i = 0; i < this.activeStateAnimations.length; i++) {
	        var clip = this.animEvaluator.findClip(this.activeStateAnimations[i].name);

	        if (clip) {
	          clip.time = time;
	        }
	      }
	    }
	  }, {
	    key: "transitioning",
	    get: function get() {
	      return this._isTransitioning;
	    }
	  }, {
	    key: "transitionProgress",
	    get: function get() {
	      return this._currTransitionTime / this._totalTransitionTime;
	    }
	  }, {
	    key: "states",
	    get: function get() {
	      return this._stateNames;
	    }
	  }]);

	  return AnimController;
	}();

	var AnimStateGraph = function () {
	  function AnimStateGraph(data) {
	    this._layers = [];
	    this._parameters = {};

	    if (!Array.isArray(data.layers)) {
	      for (var layerId in data.layers) {
	        var dataLayer = data.layers[layerId];
	        var layer = {
	          name: dataLayer.name,
	          blendType: dataLayer.blendType,
	          weight: dataLayer.weight,
	          states: [],
	          transitions: []
	        };

	        for (var i = 0; i < dataLayer.states.length; i++) {
	          layer.states.push(data.states[dataLayer.states[i]]);
	        }

	        for (var _i = 0; _i < dataLayer.transitions.length; _i++) {
	          var dataLayerTransition = data.transitions[dataLayer.transitions[_i]];

	          if (dataLayerTransition.conditions && !Array.isArray(dataLayerTransition.conditions)) {
	            var conditionKeys = Object.keys(dataLayerTransition.conditions);
	            var conditions = [];

	            for (var j = 0; j < conditionKeys.length; j++) {
	              var condition = dataLayerTransition.conditions[conditionKeys[j]];

	              if (condition.parameterName) {
	                conditions.push(condition);
	              }
	            }

	            dataLayerTransition.conditions = conditions;
	          }

	          if (Number.isInteger(dataLayerTransition.from)) {
	            dataLayerTransition.from = data.states[dataLayerTransition.from].name;
	          }

	          if (Number.isInteger(dataLayerTransition.to)) {
	            dataLayerTransition.to = data.states[dataLayerTransition.to].name;
	          }

	          layer.transitions.push(dataLayerTransition);
	        }

	        this._layers.push(layer);
	      }
	    } else {
	      this._layers = data.layers;
	    }

	    for (var paramId in data.parameters) {
	      var param = data.parameters[paramId];
	      this._parameters[param.name] = {
	        type: param.type,
	        value: param.value
	      };
	    }
	  }

	  _createClass(AnimStateGraph, [{
	    key: "parameters",
	    get: function get() {
	      return Object.assign({}, this._parameters);
	    }
	  }, {
	    key: "layers",
	    get: function get() {
	      return this._layers;
	    }
	  }]);

	  return AnimStateGraph;
	}();

	var FONT_MSDF = 'msdf';
	var FONT_BITMAP = 'bitmap';

	var Font = function () {
	  function Font(textures, data) {
	    this.type = data ? data.type || FONT_MSDF : FONT_MSDF;
	    this.em = 1;
	    this.textures = textures;
	    this.intensity = 0.0;
	    this._data = null;
	    this.data = data;
	  }

	  _createClass(Font, [{
	    key: "data",
	    get: function get() {
	      return this._data;
	    },
	    set: function set(value) {
	      this._data = value;
	      if (!value) return;

	      if (this._data.intensity !== undefined) {
	        this.intensity = this._data.intensity;
	      }

	      if (!this._data.info) this._data.info = {};

	      if (!this._data.version || this._data.version < 2) {
	        this._data.info.maps = [{
	          width: this._data.info.width,
	          height: this._data.info.height
	        }];

	        if (this._data.chars) {
	          for (var key in this._data.chars) {
	            this._data.chars[key].map = 0;
	          }
	        }
	      }
	    }
	  }]);

	  return Font;
	}();

	var MAX_TEXTURE_SIZE = 4096;
	var DEFAULT_TEXTURE_SIZE = 512;

	var CanvasFont = function (_EventHandler) {
	  _inheritsLoose(CanvasFont, _EventHandler);

	  function CanvasFont(app, options) {
	    var _this;

	    if (options === void 0) {
	      options = {};
	    }

	    _this = _EventHandler.call(this) || this;
	    _this.type = 'bitmap';
	    _this.app = app;
	    _this.intensity = 0;
	    _this.fontWeight = options.fontWeight || 'normal';
	    _this.fontSize = parseInt(options.fontSize, 10);
	    _this.glyphSize = _this.fontSize;
	    _this.fontName = options.fontName || 'Arial';
	    _this.color = options.color || new Color(1, 1, 1);
	    _this.padding = options.padding || 0;
	    var w = options.width > MAX_TEXTURE_SIZE ? MAX_TEXTURE_SIZE : options.width || DEFAULT_TEXTURE_SIZE;
	    var h = options.height > MAX_TEXTURE_SIZE ? MAX_TEXTURE_SIZE : options.height || DEFAULT_TEXTURE_SIZE;
	    var canvas = document.createElement('canvas');
	    canvas.height = h;
	    canvas.width = w;
	    var texture = new Texture(_this.app.graphicsDevice, {
	      name: 'font',
	      format: PIXELFORMAT_R8_G8_B8_A8,
	      minFilter: FILTER_LINEAR_MIPMAP_LINEAR,
	      magFilter: FILTER_LINEAR,
	      addressU: ADDRESS_CLAMP_TO_EDGE,
	      addressV: ADDRESS_CLAMP_TO_EDGE,
	      mipmaps: true
	    });
	    texture.setSource(canvas);
	    _this.textures = [texture];
	    _this.chars = '';
	    _this.data = {};
	    return _this;
	  }

	  var _proto = CanvasFont.prototype;

	  _proto.createTextures = function createTextures(text) {
	    var _chars = this._normalizeCharsSet(text);

	    if (_chars.length !== this.chars.length) {
	      this._renderAtlas(_chars);

	      return;
	    }

	    for (var i = 0; i < _chars.length; i++) {
	      if (_chars[i] !== this.chars[i]) {
	        this._renderAtlas(_chars);

	        return;
	      }
	    }
	  };

	  _proto.updateTextures = function updateTextures(text) {
	    var _chars = this._normalizeCharsSet(text);

	    var newCharsSet = [];

	    for (var i = 0; i < _chars.length; i++) {
	      var char = _chars[i];

	      if (!this.data.chars[char]) {
	        newCharsSet.push(char);
	      }
	    }

	    if (newCharsSet.length > 0) {
	      this._renderAtlas(this.chars.concat(newCharsSet));
	    }
	  };

	  _proto.destroy = function destroy() {
	    for (var i = 0; i < this.textures.length; i++) {
	      this.textures[i].destroy();
	    }

	    this.chars = null;
	    this.color = null;
	    this.data = null;
	    this.fontName = null;
	    this.fontSize = null;
	    this.glyphSize = null;
	    this.intensity = null;
	    this.textures = null;
	    this.type = null;
	    this.fontWeight = null;
	  };

	  _proto._getAndClearContext = function _getAndClearContext(canvas, clearColor) {
	    var w = canvas.width;
	    var h = canvas.height;
	    var ctx = canvas.getContext('2d', {
	      alpha: true
	    });
	    ctx.clearRect(0, 0, w, h);
	    ctx.fillStyle = clearColor;
	    ctx.fillRect(0, 0, w, h);
	    return ctx;
	  };

	  _proto._colorToRgbString = function _colorToRgbString(color, alpha) {
	    var str;
	    var r = Math.round(255 * color.r);
	    var g = Math.round(255 * color.g);
	    var b = Math.round(255 * color.b);

	    if (alpha) {
	      str = "rgba(" + r + ", " + g + ", " + b + ", " + color.a + ")";
	    } else {
	      str = "rgb(" + r + ", " + g + ", " + b + ")";
	    }

	    return str;
	  };

	  _proto.renderCharacter = function renderCharacter(context, char, x, y, color) {
	    context.fillStyle = color;
	    context.fillText(char, x, y);
	  };

	  _proto._renderAtlas = function _renderAtlas(charsArray) {
	    this.chars = charsArray;
	    var numTextures = 1;
	    var canvas = this.textures[numTextures - 1].getSource();
	    var w = canvas.width;
	    var h = canvas.height;

	    var color = this._colorToRgbString(this.color, false);

	    var a = this.color.a;
	    this.color.a = 1 / 255;

	    var transparent = this._colorToRgbString(this.color, true);

	    this.color.a = a;
	    var TEXT_ALIGN = 'center';
	    var TEXT_BASELINE = 'alphabetic';

	    var ctx = this._getAndClearContext(canvas, transparent);

	    ctx.font = this.fontWeight + ' ' + this.fontSize.toString() + 'px ' + this.fontName;
	    ctx.textAlign = TEXT_ALIGN;
	    ctx.textBaseline = TEXT_BASELINE;
	    this.data = this._createJson(this.chars, this.fontName, w, h);
	    var symbols = string.getSymbols(this.chars.join(''));
	    var prevNumTextures = this.textures.length;
	    var maxHeight = 0;
	    var maxDescent = 0;
	    var metrics = {};

	    for (var i = 0; i < symbols.length; i++) {
	      var ch = symbols[i];
	      metrics[ch] = this._getTextMetrics(ch);
	      maxHeight = Math.max(maxHeight, metrics[ch].height);
	      maxDescent = Math.max(maxDescent, metrics[ch].descent);
	    }

	    this.glyphSize = Math.max(this.glyphSize, maxHeight);
	    var sx = this.glyphSize + this.padding * 2;
	    var sy = this.glyphSize + this.padding * 2;

	    var _xOffset = this.glyphSize / 2 + this.padding;

	    var _yOffset = sy - maxDescent - this.padding;

	    var _x = 0;
	    var _y = 0;

	    for (var _i = 0; _i < symbols.length; _i++) {
	      var _ch = symbols[_i];
	      var code = string.getCodePoint(symbols[_i]);
	      var fs = this.fontSize;
	      ctx.font = this.fontWeight + ' ' + fs.toString() + 'px ' + this.fontName;
	      ctx.textAlign = TEXT_ALIGN;
	      ctx.textBaseline = TEXT_BASELINE;
	      var width = ctx.measureText(_ch).width;

	      if (width > fs) {
	        fs = this.fontSize * this.fontSize / width;
	        ctx.font = this.fontWeight + ' ' + fs.toString() + 'px ' + this.fontName;
	        width = this.fontSize;
	      }

	      this.renderCharacter(ctx, _ch, _x + _xOffset, _y + _yOffset, color);
	      var xoffset = this.padding + (this.glyphSize - width) / 2;
	      var yoffset = -this.padding + metrics[_ch].descent - maxDescent;
	      var xadvance = width;

	      this._addChar(this.data, _ch, code, _x, _y, sx, sy, xoffset, yoffset, xadvance, numTextures - 1, w, h);

	      _x += sx;

	      if (_x + sx > w) {
	        _x = 0;
	        _y += sy;

	        if (_y + sy > h) {
	          this.textures[numTextures - 1].upload();
	          numTextures++;
	          _y = 0;

	          if (numTextures > prevNumTextures) {
	            canvas = document.createElement('canvas');
	            canvas.height = h;
	            canvas.width = w;
	            ctx = this._getAndClearContext(canvas, transparent);
	            var texture = new Texture(this.app.graphicsDevice, {
	              format: PIXELFORMAT_R8_G8_B8_A8,
	              mipmaps: true,
	              name: 'font-atlas'
	            });
	            texture.setSource(canvas);
	            texture.minFilter = FILTER_LINEAR_MIPMAP_LINEAR;
	            texture.magFilter = FILTER_LINEAR;
	            texture.addressU = ADDRESS_CLAMP_TO_EDGE;
	            texture.addressV = ADDRESS_CLAMP_TO_EDGE;
	            this.textures.push(texture);
	          } else {
	            canvas = this.textures[numTextures - 1].getSource();
	            ctx = this._getAndClearContext(canvas, transparent);
	          }
	        }
	      }
	    }

	    this.textures[numTextures - 1].upload();

	    if (numTextures < prevNumTextures) {
	      for (var _i2 = numTextures; _i2 < prevNumTextures; _i2++) {
	        this.textures[_i2].destroy();
	      }

	      this.textures.splice(numTextures);
	    }

	    this.fire('render');
	  };

	  _proto._createJson = function _createJson(chars, fontName, width, height) {
	    var base = {
	      'version': 3,
	      'intensity': this.intensity,
	      'info': {
	        'face': fontName,
	        'width': width,
	        'height': height,
	        'maps': [{
	          'width': width,
	          'height': height
	        }]
	      },
	      'chars': {}
	    };
	    return base;
	  };

	  _proto._addChar = function _addChar(json, char, charCode, x, y, w, h, xoffset, yoffset, xadvance, mapNum, mapW, mapH) {
	    if (json.info.maps.length < mapNum + 1) {
	      json.info.maps.push({
	        'width': mapW,
	        'height': mapH
	      });
	    }

	    var scale = this.fontSize / 32;
	    json.chars[char] = {
	      'id': charCode,
	      'letter': char,
	      'x': x,
	      'y': y,
	      'width': w,
	      'height': h,
	      'xadvance': xadvance / scale,
	      'xoffset': xoffset / scale,
	      'yoffset': (yoffset + this.padding) / scale,
	      'scale': scale,
	      'range': 1,
	      'map': mapNum,
	      'bounds': [0, 0, w / scale, h / scale]
	    };
	  };

	  _proto._normalizeCharsSet = function _normalizeCharsSet(text) {
	    var unicodeConverterFunc = this.app.systems.element.getUnicodeConverter();

	    if (unicodeConverterFunc) {
	      text = unicodeConverterFunc(text);
	    }

	    var set = {};
	    var symbols = string.getSymbols(text);

	    for (var i = 0; i < symbols.length; i++) {
	      var ch = symbols[i];
	      if (set[ch]) continue;
	      set[ch] = ch;
	    }

	    var chars = Object.keys(set);
	    return chars.sort();
	  };

	  _proto._getTextMetrics = function _getTextMetrics(text) {
	    var textSpan = document.createElement('span');
	    textSpan.id = 'content-span';
	    textSpan.innerHTML = text;
	    var block = document.createElement('div');
	    block.id = 'content-block';
	    block.style.display = 'inline-block';
	    block.style.width = '1px';
	    block.style.height = '0px';
	    var div = document.createElement('div');
	    div.appendChild(textSpan);
	    div.appendChild(block);
	    div.style.font = this.fontSize + 'px ' + this.fontName;
	    var body = document.body;
	    body.appendChild(div);
	    var ascent = -1;
	    var descent = -1;
	    var height = -1;

	    try {
	      block.style['vertical-align'] = 'baseline';
	      ascent = block.offsetTop - textSpan.offsetTop;
	      block.style['vertical-align'] = 'bottom';
	      height = block.offsetTop - textSpan.offsetTop;
	      descent = height - ascent;
	    } finally {
	      document.body.removeChild(div);
	    }

	    return {
	      ascent: ascent,
	      descent: descent,
	      height: height
	    };
	  };

	  return CanvasFont;
	}(EventHandler);

	var DISTANCE_LINEAR = 'linear';
	var DISTANCE_INVERSE = 'inverse';
	var DISTANCE_EXPONENTIAL = 'exponential';

	function hasAudioContext() {
	  return !!(typeof AudioContext !== 'undefined' || typeof webkitAudioContext !== 'undefined');
	}

	var Channel = function () {
	  function Channel(manager, sound, options) {
	    if (options === void 0) {
	      options = {};
	    }

	    this.volume = options.volume === undefined ? 1 : options.volume;
	    this.loop = options.loop === undefined ? false : options.loop;
	    this.pitch = options.pitch === undefined ? 1 : options.pitch;
	    this.sound = sound;
	    this.paused = false;
	    this.suspended = false;
	    this.manager = manager;
	    this.source = null;

	    if (hasAudioContext()) {
	      this.startTime = 0;
	      this.startOffset = 0;
	      var context = manager.context;
	      this.gain = context.createGain();
	    } else if (sound.audio) {
	      this.source = sound.audio.cloneNode(false);
	      this.source.pause();
	    }
	  }

	  var _proto = Channel.prototype;

	  _proto.getVolume = function getVolume() {
	    return this.volume;
	  };

	  _proto.getLoop = function getLoop() {
	    return this.loop;
	  };

	  _proto.setLoop = function setLoop(loop) {
	    this.loop = loop;

	    if (this.source) {
	      this.source.loop = loop;
	    }
	  };

	  _proto.getPitch = function getPitch() {
	    return this.pitch;
	  };

	  _proto.onManagerVolumeChange = function onManagerVolumeChange() {
	    this.setVolume(this.getVolume());
	  };

	  _proto.onManagerSuspend = function onManagerSuspend() {
	    if (this.isPlaying() && !this.suspended) {
	      this.suspended = true;
	      this.pause();
	    }
	  };

	  _proto.onManagerResume = function onManagerResume() {
	    if (this.suspended) {
	      this.suspended = false;
	      this.unpause();
	    }
	  };

	  _proto.play = function play() {
	    if (this.source) {
	      throw new Error('Call stop() before calling play()');
	    }

	    this._createSource();

	    if (!this.source) {
	      return;
	    }

	    this.startTime = this.manager.context.currentTime;
	    this.source.start(0, this.startOffset % this.source.buffer.duration);
	    this.setVolume(this.volume);
	    this.setLoop(this.loop);
	    this.setPitch(this.pitch);
	    this.manager.on('volumechange', this.onManagerVolumeChange, this);
	    this.manager.on('suspend', this.onManagerSuspend, this);
	    this.manager.on('resume', this.onManagerResume, this);
	    if (this.manager.suspended) this.onManagerSuspend();
	  };

	  _proto.pause = function pause() {
	    if (this.source) {
	      this.paused = true;
	      this.startOffset += this.manager.context.currentTime - this.startTime;
	      this.source.stop(0);
	      this.source = null;
	    }
	  };

	  _proto.unpause = function unpause() {
	    if (this.source || !this.paused) {
	      console.warn('Call pause() before unpausing.');
	      return;
	    }

	    this._createSource();

	    if (!this.source) {
	      return;
	    }

	    this.startTime = this.manager.context.currentTime;
	    this.source.start(0, this.startOffset % this.source.buffer.duration);
	    this.setVolume(this.volume);
	    this.setLoop(this.loop);
	    this.setPitch(this.pitch);
	    this.paused = false;
	  };

	  _proto.stop = function stop() {
	    if (this.source) {
	      this.source.stop(0);
	      this.source = null;
	    }

	    this.manager.off('volumechange', this.onManagerVolumeChange, this);
	    this.manager.off('suspend', this.onManagerSuspend, this);
	    this.manager.off('resume', this.onManagerResume, this);
	  };

	  _proto.setVolume = function setVolume(volume) {
	    volume = math.clamp(volume, 0, 1);
	    this.volume = volume;

	    if (this.gain) {
	      this.gain.gain.value = volume * this.manager.volume;
	    }
	  };

	  _proto.setPitch = function setPitch(pitch) {
	    this.pitch = pitch;

	    if (this.source) {
	      this.source.playbackRate.value = pitch;
	    }
	  };

	  _proto.isPlaying = function isPlaying() {
	    return !this.paused && this.source.playbackState === this.source.PLAYING_STATE;
	  };

	  _proto.getDuration = function getDuration() {
	    return this.source ? this.source.buffer.duration : 0;
	  };

	  _proto._createSource = function _createSource() {
	    var context = this.manager.context;

	    if (this.sound.buffer) {
	      this.source = context.createBufferSource();
	      this.source.buffer = this.sound.buffer;
	      this.source.connect(this.gain);
	      this.gain.connect(context.destination);

	      if (!this.loop) {
	        this.source.onended = this.pause.bind(this);
	      }
	    }
	  };

	  return Channel;
	}();

	if (!hasAudioContext()) {
	  Object.assign(Channel.prototype, {
	    play: function play() {
	      if (this.source) {
	        this.paused = false;
	        this.setVolume(this.volume);
	        this.setLoop(this.loop);
	        this.setPitch(this.pitch);
	        this.source.play();
	      }

	      this.manager.on('volumechange', this.onManagerVolumeChange, this);
	      this.manager.on('suspend', this.onManagerSuspend, this);
	      this.manager.on('resume', this.onManagerResume, this);
	      if (this.manager.suspended) this.onManagerSuspend();
	    },
	    pause: function pause() {
	      if (this.source) {
	        this.paused = true;
	        this.source.pause();
	      }
	    },
	    unpause: function unpause() {
	      if (this.source) {
	        this.paused = false;
	        this.source.play();
	      }
	    },
	    stop: function stop() {
	      if (this.source) {
	        this.source.pause();
	      }

	      this.manager.off('volumechange', this.onManagerVolumeChange, this);
	      this.manager.off('suspend', this.onManagerSuspend, this);
	      this.manager.off('resume', this.onManagerResume, this);
	    },
	    setVolume: function setVolume(volume) {
	      volume = math.clamp(volume, 0, 1);
	      this.volume = volume;

	      if (this.source) {
	        this.source.volume = volume * this.manager.volume;
	      }
	    },
	    setPitch: function setPitch(pitch) {
	      this.pitch = pitch;

	      if (this.source) {
	        this.source.playbackRate = pitch;
	      }
	    },
	    getDuration: function getDuration() {
	      return this.source && !isNaN(this.source.duration) ? this.source.duration : 0;
	    },
	    isPlaying: function isPlaying() {
	      return !this.source.paused;
	    }
	  });
	}

	var MAX_DISTANCE$1 = 10000;

	var Channel3d = function (_Channel) {
	  _inheritsLoose(Channel3d, _Channel);

	  function Channel3d(manager, sound, options) {
	    var _this;

	    _this = _Channel.call(this, manager, sound, options) || this;
	    _this.position = new Vec3();
	    _this.velocity = new Vec3();

	    if (hasAudioContext()) {
	      _this.panner = manager.context.createPanner();
	    } else {
	      _this.maxDistance = MAX_DISTANCE$1;
	      _this.minDistance = 1;
	      _this.rollOffFactor = 1;
	      _this.distanceModel = DISTANCE_INVERSE;
	    }

	    return _this;
	  }

	  var _proto = Channel3d.prototype;

	  _proto.getPosition = function getPosition() {
	    return this.position;
	  };

	  _proto.setPosition = function setPosition(position) {
	    this.position.copy(position);
	    var panner = this.panner;

	    if ('positionX' in panner) {
	      panner.positionX.value = position.x;
	      panner.positionY.value = position.y;
	      panner.positionZ.value = position.z;
	    } else if (panner.setPosition) {
	      panner.setPosition(position.x, position.y, position.z);
	    }
	  };

	  _proto.getVelocity = function getVelocity() {
	    return this.velocity;
	  };

	  _proto.setVelocity = function setVelocity(velocity) {
	    this.velocity.copy(velocity);
	  };

	  _proto.getMaxDistance = function getMaxDistance() {
	    return this.panner.maxDistance;
	  };

	  _proto.setMaxDistance = function setMaxDistance(max) {
	    this.panner.maxDistance = max;
	  };

	  _proto.getMinDistance = function getMinDistance() {
	    return this.panner.refDistance;
	  };

	  _proto.setMinDistance = function setMinDistance(min) {
	    this.panner.refDistance = min;
	  };

	  _proto.getRollOffFactor = function getRollOffFactor() {
	    return this.panner.rolloffFactor;
	  };

	  _proto.setRollOffFactor = function setRollOffFactor(factor) {
	    this.panner.rolloffFactor = factor;
	  };

	  _proto.getDistanceModel = function getDistanceModel() {
	    return this.panner.distanceModel;
	  };

	  _proto.setDistanceModel = function setDistanceModel(distanceModel) {
	    this.panner.distanceModel = distanceModel;
	  };

	  _proto._createSource = function _createSource() {
	    var context = this.manager.context;
	    this.source = context.createBufferSource();
	    this.source.buffer = this.sound.buffer;
	    this.source.connect(this.panner);
	    this.panner.connect(this.gain);
	    this.gain.connect(context.destination);

	    if (!this.loop) {
	      this.source.onended = this.pause.bind(this);
	    }
	  };

	  return Channel3d;
	}(Channel);

	if (!hasAudioContext()) {
	  var offset$1 = new Vec3();

	  var fallOff$1 = function fallOff(posOne, posTwo, refDistance, maxDistance, rolloffFactor, distanceModel) {
	    offset$1 = offset$1.sub2(posOne, posTwo);
	    var distance = offset$1.length();

	    if (distance < refDistance) {
	      return 1;
	    } else if (distance > maxDistance) {
	      return 0;
	    }

	    var result = 0;

	    if (distanceModel === DISTANCE_LINEAR) {
	      result = 1 - rolloffFactor * (distance - refDistance) / (maxDistance - refDistance);
	    } else if (distanceModel === DISTANCE_INVERSE) {
	      result = refDistance / (refDistance + rolloffFactor * (distance - refDistance));
	    } else if (distanceModel === DISTANCE_EXPONENTIAL) {
	      result = Math.pow(distance / refDistance, -rolloffFactor);
	    }

	    return math.clamp(result, 0, 1);
	  };

	  Object.assign(Channel3d.prototype, {
	    setPosition: function setPosition(position) {
	      this.position.copy(position);

	      if (this.source) {
	        var listener = this.manager.listener;
	        var lpos = listener.getPosition();
	        var factor = fallOff$1(lpos, this.position, this.minDistance, this.maxDistance, this.rollOffFactor, this.distanceModel);
	        var v = this.getVolume();
	        this.source.volume = v * factor;
	      }
	    },
	    getMaxDistance: function getMaxDistance() {
	      return this.maxDistance;
	    },
	    setMaxDistance: function setMaxDistance(max) {
	      this.maxDistance = max;
	    },
	    getMinDistance: function getMinDistance() {
	      return this.minDistance;
	    },
	    setMinDistance: function setMinDistance(min) {
	      this.minDistance = min;
	    },
	    getRollOffFactor: function getRollOffFactor() {
	      return this.rollOffFactor;
	    },
	    setRollOffFactor: function setRollOffFactor(factor) {
	      this.rollOffFactor = factor;
	    },
	    getDistanceModel: function getDistanceModel() {
	      return this.distanceModel;
	    },
	    setDistanceModel: function setDistanceModel(distanceModel) {
	      this.distanceModel = distanceModel;
	    }
	  });
	}

	var Listener = function () {
	  function Listener(manager) {
	    this._manager = manager;
	    this.position = new Vec3();
	    this.velocity = new Vec3();
	    this.orientation = new Mat4();
	  }

	  var _proto = Listener.prototype;

	  _proto.getPosition = function getPosition() {
	    return this.position;
	  };

	  _proto.setPosition = function setPosition(position) {
	    this.position.copy(position);
	    var listener = this.listener;

	    if (listener) {
	      if ('positionX' in listener) {
	        listener.positionX.value = position.x;
	        listener.positionY.value = position.y;
	        listener.positionZ.value = position.z;
	      } else if (listener.setPosition) {
	        listener.setPosition(position.x, position.y, position.z);
	      }
	    }
	  };

	  _proto.getVelocity = function getVelocity() {
	    return this.velocity;
	  };

	  _proto.setVelocity = function setVelocity(velocity) {};

	  _proto.setOrientation = function setOrientation(orientation) {
	    this.orientation.copy(orientation);
	    var listener = this.listener;

	    if (listener) {
	      var m = orientation.data;

	      if ('forwardX' in listener) {
	        listener.forwardX.value = -m[8];
	        listener.forwardY.value = -m[9];
	        listener.forwardZ.value = -m[10];
	        listener.upX.value = m[4];
	        listener.upY.value = m[5];
	        listener.upZ.value = m[6];
	      } else if (listener.setOrientation) {
	        listener.setOrientation(-m[8], -m[9], -m[10], m[4], m[5], m[6]);
	      }
	    }
	  };

	  _proto.getOrientation = function getOrientation() {
	    return this.orientation;
	  };

	  _createClass(Listener, [{
	    key: "listener",
	    get: function get() {
	      var context = this._manager.context;
	      return context ? context.listener : null;
	    }
	  }]);

	  return Listener;
	}();

	var CONTEXT_STATE_RUNNING = 'running';
	var CONTEXT_STATE_INTERRUPTED = 'interrupted';
	var USER_INPUT_EVENTS = ['click', 'contextmenu', 'auxclick', 'dblclick', 'mousedown', 'mouseup', 'pointerup', 'touchend', 'keydown', 'keyup'];

	var SoundManager = function (_EventHandler) {
	  _inheritsLoose(SoundManager, _EventHandler);

	  function SoundManager(options) {
	    var _this;

	    _this = _EventHandler.call(this) || this;
	    _this._context = null;
	    _this._forceWebAudioApi = options.forceWebAudioApi;
	    _this._resumeContextCallback = null;
	    _this._selfSuspended = false;
	    _this._unlocked = false;
	    _this._unlocking = false;

	    if (!hasAudioContext() && !_this._forceWebAudioApi) ;

	    _this.listener = new Listener(_assertThisInitialized(_this));
	    _this._volume = 1;
	    return _this;
	  }

	  var _proto = SoundManager.prototype;

	  _proto.suspend = function suspend() {
	    this._selfSuspended = true;

	    if (this.suspended) {
	      return;
	    }

	    this.fire('suspend');
	  };

	  _proto.resume = function resume() {
	    var _this2 = this;

	    this._selfSuspended = false;

	    if (!this._context || !this._unlocked && !this._unlocking) {
	      return;
	    }

	    if (this._context.state === CONTEXT_STATE_INTERRUPTED) {
	      this._context.resume().then(function () {
	        _this2.fire('resume');
	      }, function (e) {}).catch(function (e) {});
	    } else {
	      this.fire('resume');
	    }
	  };

	  _proto.destroy = function destroy() {
	    this._removeUserInputListeners();

	    this.fire('destroy');

	    if (this._context && this._context.close) {
	      this._context.close();

	      this._context = null;
	    }
	  };

	  _proto.playSound = function playSound(sound, options) {
	    if (options === void 0) {
	      options = {};
	    }

	    var channel = null;

	    if (Channel) {
	      channel = new Channel(this, sound, options);
	      channel.play();
	    }

	    return channel;
	  };

	  _proto.playSound3d = function playSound3d(sound, position, options) {
	    if (options === void 0) {
	      options = {};
	    }

	    var channel = null;

	    if (Channel3d) {
	      channel = new Channel3d(this, sound, options);
	      channel.setPosition(position);

	      if (options.volume) {
	        channel.setVolume(options.volume);
	      }

	      if (options.loop) {
	        channel.setLoop(options.loop);
	      }

	      if (options.maxDistance) {
	        channel.setMaxDistance(options.maxDistance);
	      }

	      if (options.minDistance) {
	        channel.setMinDistance(options.minDistance);
	      }

	      if (options.rollOffFactor) {
	        channel.setRollOffFactor(options.rollOffFactor);
	      }

	      if (options.distanceModel) {
	        channel.setDistanceModel(options.distanceModel);
	      }

	      channel.play();
	    }

	    return channel;
	  };

	  _proto._addContextUnlockListeners = function _addContextUnlockListeners() {
	    var _this3 = this;

	    this._unlocking = false;

	    if (!this._resumeContextCallback) {
	      this._resumeContextCallback = function () {
	        if (!_this3._context || _this3._unlocked || _this3._unlocking) {
	          return;
	        }

	        _this3._unlocking = true;

	        _this3.resume();

	        var buffer = _this3._context.createBuffer(1, 1, _this3._context.sampleRate);

	        var source = _this3._context.createBufferSource();

	        source.buffer = buffer;
	        source.connect(_this3._context.destination);
	        source.start(0);

	        source.onended = function (event) {
	          source.disconnect(0);
	          _this3._unlocked = true;
	          _this3._unlocking = false;

	          _this3._removeUserInputListeners();
	        };
	      };
	    }

	    USER_INPUT_EVENTS.forEach(function (eventName) {
	      window.addEventListener(eventName, _this3._resumeContextCallback, false);
	    });
	  };

	  _proto._removeUserInputListeners = function _removeUserInputListeners() {
	    var _this4 = this;

	    if (!this._resumeContextCallback) {
	      return;
	    }

	    USER_INPUT_EVENTS.forEach(function (eventName) {
	      window.removeEventListener(eventName, _this4._resumeContextCallback, false);
	    });
	    this._resumeContextCallback = null;
	  };

	  _createClass(SoundManager, [{
	    key: "volume",
	    get: function get() {
	      return this._volume;
	    },
	    set: function set(volume) {
	      volume = math.clamp(volume, 0, 1);
	      this._volume = volume;
	      this.fire('volumechange', volume);
	    }
	  }, {
	    key: "suspended",
	    get: function get() {
	      return !this._context || !this._unlocked || this._context.state !== CONTEXT_STATE_RUNNING;
	    }
	  }, {
	    key: "context",
	    get: function get() {
	      if (!this._context) {
	        if (hasAudioContext() || this._forceWebAudioApi) {
	          if (typeof AudioContext !== 'undefined') {
	            this._context = new AudioContext();
	          } else if (typeof webkitAudioContext !== 'undefined') {
	            this._context = new webkitAudioContext();
	          }

	          if (this._context) {
	            this._unlocked = this._context.state === CONTEXT_STATE_RUNNING;

	            if (!this._unlocked) {
	              this._addContextUnlockListeners();
	            }

	            var self = this;

	            this._context.onstatechange = function () {
	              if (self._unlocked && !self._selfSuspended && self._context.state !== CONTEXT_STATE_RUNNING) {
	                self._context.resume().then(function () {}, function (e) {}).catch(function (e) {});
	              }
	            };
	          }
	        }
	      }

	      return this._context;
	    }
	  }]);

	  return SoundManager;
	}(EventHandler);

	var Sound = function () {
	  function Sound(resource) {
	    this.audio = void 0;
	    this.buffer = void 0;

	    if (resource instanceof Audio) {
	      this.audio = resource;
	    } else {
	      this.buffer = resource;
	    }
	  }

	  _createClass(Sound, [{
	    key: "duration",
	    get: function get() {
	      var duration = 0;

	      if (this.buffer) {
	        duration = this.buffer.duration;
	      } else if (this.audio) {
	        duration = this.audio.duration;
	      }

	      return duration || 0;
	    }
	  }]);

	  return Sound;
	}();

	var STATE_PLAYING = 0;
	var STATE_PAUSED = 1;
	var STATE_STOPPED = 2;

	function capTime(time, duration) {
	  return time % duration || 0;
	}

	var SoundInstance = function (_EventHandler) {
	  _inheritsLoose(SoundInstance, _EventHandler);

	  function SoundInstance(manager, sound, options) {
	    var _this;

	    _this = _EventHandler.call(this) || this;
	    _this.source = null;
	    _this._manager = manager;
	    _this._volume = options.volume !== undefined ? math.clamp(Number(options.volume) || 0, 0, 1) : 1;
	    _this._pitch = options.pitch !== undefined ? Math.max(0.01, Number(options.pitch) || 0) : 1;
	    _this._loop = !!(options.loop !== undefined ? options.loop : false);
	    _this._sound = sound;
	    _this._state = STATE_STOPPED;
	    _this._suspended = false;
	    _this._suspendEndEvent = 0;
	    _this._suspendInstanceEvents = false;
	    _this._playWhenLoaded = true;
	    _this._startTime = Math.max(0, Number(options.startTime) || 0);
	    _this._duration = Math.max(0, Number(options.duration) || 0);
	    _this._startOffset = null;
	    _this._onPlayCallback = options.onPlay;
	    _this._onPauseCallback = options.onPause;
	    _this._onResumeCallback = options.onResume;
	    _this._onStopCallback = options.onStop;
	    _this._onEndCallback = options.onEnd;

	    if (hasAudioContext()) {
	      _this._startedAt = 0;
	      _this._currentTime = 0;
	      _this._currentOffset = 0;
	      _this._inputNode = null;
	      _this._connectorNode = null;
	      _this._firstNode = null;
	      _this._lastNode = null;
	      _this._waitingContextSuspension = false;

	      _this._initializeNodes();

	      _this._endedHandler = _this._onEnded.bind(_assertThisInitialized(_this));
	    } else {
	      _this._isReady = false;
	      _this._loadedMetadataHandler = _this._onLoadedMetadata.bind(_assertThisInitialized(_this));
	      _this._timeUpdateHandler = _this._onTimeUpdate.bind(_assertThisInitialized(_this));
	      _this._endedHandler = _this._onEnded.bind(_assertThisInitialized(_this));

	      _this._createSource();
	    }

	    return _this;
	  }

	  var _proto = SoundInstance.prototype;

	  _proto._onPlay = function _onPlay() {
	    this.fire('play');
	    if (this._onPlayCallback) this._onPlayCallback(this);
	  };

	  _proto._onPause = function _onPause() {
	    this.fire('pause');
	    if (this._onPauseCallback) this._onPauseCallback(this);
	  };

	  _proto._onResume = function _onResume() {
	    this.fire('resume');
	    if (this._onResumeCallback) this._onResumeCallback(this);
	  };

	  _proto._onStop = function _onStop() {
	    this.fire('stop');
	    if (this._onStopCallback) this._onStopCallback(this);
	  };

	  _proto._onEnded = function _onEnded() {
	    if (this._suspendEndEvent > 0) {
	      this._suspendEndEvent--;
	      return;
	    }

	    this.fire('end');
	    if (this._onEndCallback) this._onEndCallback(this);
	    this.stop();
	  };

	  _proto._onManagerVolumeChange = function _onManagerVolumeChange() {
	    this.volume = this._volume;
	  };

	  _proto._onManagerSuspend = function _onManagerSuspend() {
	    if (this._state === STATE_PLAYING && !this._suspended) {
	      this._suspended = true;
	      this.pause();
	    }
	  };

	  _proto._onManagerResume = function _onManagerResume() {
	    if (this._suspended) {
	      this._suspended = false;
	      this.resume();
	    }
	  };

	  _proto._initializeNodes = function _initializeNodes() {
	    this.gain = this._manager.context.createGain();
	    this._inputNode = this.gain;
	    this._connectorNode = this.gain;

	    this._connectorNode.connect(this._manager.context.destination);
	  };

	  _proto.play = function play() {
	    if (this._state !== STATE_STOPPED) {
	      this.stop();
	    }

	    this._state = STATE_PLAYING;
	    this._playWhenLoaded = false;

	    if (this._waitingContextSuspension) {
	      return false;
	    }

	    if (this._manager.suspended) {
	      this._manager.once('resume', this._playAudioImmediate, this);

	      this._waitingContextSuspension = true;
	      return false;
	    }

	    this._playAudioImmediate();

	    return true;
	  };

	  _proto._playAudioImmediate = function _playAudioImmediate() {
	    this._waitingContextSuspension = false;

	    if (this._state !== STATE_PLAYING) {
	      return;
	    }

	    if (!this.source) {
	      this._createSource();
	    }

	    var offset = capTime(this._startOffset, this.duration);
	    offset = capTime(this._startTime + offset, this._sound.duration);
	    this._startOffset = null;

	    if (this._duration) {
	      this.source.start(0, offset, this._duration);
	    } else {
	      this.source.start(0, offset);
	    }

	    this._startedAt = this._manager.context.currentTime;
	    this._currentTime = 0;
	    this._currentOffset = offset;
	    this.volume = this._volume;
	    this.loop = this._loop;
	    this.pitch = this._pitch;

	    this._manager.on('volumechange', this._onManagerVolumeChange, this);

	    this._manager.on('suspend', this._onManagerSuspend, this);

	    this._manager.on('resume', this._onManagerResume, this);

	    this._manager.on('destroy', this._onManagerDestroy, this);

	    if (!this._suspendInstanceEvents) {
	      this._onPlay();
	    }
	  };

	  _proto.pause = function pause() {
	    this._playWhenLoaded = false;
	    if (this._state !== STATE_PLAYING) return false;
	    this._state = STATE_PAUSED;

	    if (this._waitingContextSuspension) {
	      return true;
	    }

	    this._updateCurrentTime();

	    this._suspendEndEvent++;
	    this.source.stop(0);
	    this.source = null;
	    this._startOffset = null;
	    if (!this._suspendInstanceEvents) this._onPause();
	    return true;
	  };

	  _proto.resume = function resume() {
	    if (this._state !== STATE_PAUSED) {
	      return false;
	    }

	    this._state = STATE_PLAYING;

	    if (this._waitingContextSuspension) {
	      return true;
	    }

	    if (!this.source) {
	      this._createSource();
	    }

	    var offset = this.currentTime;

	    if (this._startOffset !== null) {
	      offset = capTime(this._startOffset, this.duration);
	      offset = capTime(this._startTime + offset, this._sound.duration);
	      this._startOffset = null;
	    }

	    if (this._duration) {
	      this.source.start(0, offset, this._duration);
	    } else {
	      this.source.start(0, offset);
	    }

	    this._startedAt = this._manager.context.currentTime;
	    this._currentOffset = offset;
	    this.volume = this._volume;
	    this.loop = this._loop;
	    this.pitch = this._pitch;
	    this._playWhenLoaded = false;
	    if (!this._suspendInstanceEvents) this._onResume();
	    return true;
	  };

	  _proto.stop = function stop() {
	    this._playWhenLoaded = false;
	    if (this._state === STATE_STOPPED) return false;
	    var wasPlaying = this._state === STATE_PLAYING;
	    this._state = STATE_STOPPED;

	    if (this._waitingContextSuspension) {
	      return true;
	    }

	    this._manager.off('volumechange', this._onManagerVolumeChange, this);

	    this._manager.off('suspend', this._onManagerSuspend, this);

	    this._manager.off('resume', this._onManagerResume, this);

	    this._manager.off('destroy', this._onManagerDestroy, this);

	    this._startedAt = 0;
	    this._currentTime = 0;
	    this._currentOffset = 0;
	    this._startOffset = null;
	    this._suspendEndEvent++;

	    if (wasPlaying && this.source) {
	      this.source.stop(0);
	    }

	    this.source = null;
	    if (!this._suspendInstanceEvents) this._onStop();
	    return true;
	  };

	  _proto.setExternalNodes = function setExternalNodes(firstNode, lastNode) {
	    if (!firstNode) {
	      console.error('The firstNode must be a valid Audio Node');
	      return;
	    }

	    if (!lastNode) {
	      lastNode = firstNode;
	    }

	    var speakers = this._manager.context.destination;

	    if (this._firstNode !== firstNode) {
	      if (this._firstNode) {
	        this._connectorNode.disconnect(this._firstNode);
	      } else {
	        this._connectorNode.disconnect(speakers);
	      }

	      this._firstNode = firstNode;

	      this._connectorNode.connect(firstNode);
	    }

	    if (this._lastNode !== lastNode) {
	      if (this._lastNode) {
	        this._lastNode.disconnect(speakers);
	      }

	      this._lastNode = lastNode;

	      this._lastNode.connect(speakers);
	    }
	  };

	  _proto.clearExternalNodes = function clearExternalNodes() {
	    var speakers = this._manager.context.destination;

	    if (this._firstNode) {
	      this._connectorNode.disconnect(this._firstNode);

	      this._firstNode = null;
	    }

	    if (this._lastNode) {
	      this._lastNode.disconnect(speakers);

	      this._lastNode = null;
	    }

	    this._connectorNode.connect(speakers);
	  };

	  _proto.getExternalNodes = function getExternalNodes() {
	    return [this._firstNode, this._lastNode];
	  };

	  _proto._createSource = function _createSource() {
	    if (!this._sound) {
	      return null;
	    }

	    var context = this._manager.context;

	    if (this._sound.buffer) {
	      this.source = context.createBufferSource();
	      this.source.buffer = this._sound.buffer;
	      this.source.connect(this._inputNode);
	      this.source.onended = this._endedHandler;
	      this.source.loopStart = capTime(this._startTime, this.source.buffer.duration);

	      if (this._duration) {
	        this.source.loopEnd = Math.max(this.source.loopStart, capTime(this._startTime + this._duration, this.source.buffer.duration));
	      }
	    }

	    return this.source;
	  };

	  _proto._updateCurrentTime = function _updateCurrentTime() {
	    this._currentTime = capTime((this._manager.context.currentTime - this._startedAt) * this._pitch + this._currentOffset, this.duration);
	  };

	  _proto._onManagerDestroy = function _onManagerDestroy() {
	    if (this.source && this._state === STATE_PLAYING) {
	      this.source.stop(0);
	      this.source = null;
	    }
	  };

	  _createClass(SoundInstance, [{
	    key: "currentTime",
	    get: function get() {
	      if (this._startOffset !== null) {
	        return this._startOffset;
	      }

	      if (this._state === STATE_PAUSED) {
	        return this._currentTime;
	      }

	      if (this._state === STATE_STOPPED || !this.source) {
	        return 0;
	      }

	      this._updateCurrentTime();

	      return this._currentTime;
	    },
	    set: function set(value) {
	      if (value < 0) return;

	      if (this._state === STATE_PLAYING) {
	        var suspend = this._suspendInstanceEvents;
	        this._suspendInstanceEvents = true;
	        this.stop();
	        this._startOffset = value;
	        this.play();
	        this._suspendInstanceEvents = suspend;
	      } else {
	        this._startOffset = value;
	        this._currentTime = value;
	      }
	    }
	  }, {
	    key: "duration",
	    get: function get() {
	      if (!this._sound) {
	        return 0;
	      }

	      if (this._duration) {
	        return capTime(this._duration, this._sound.duration);
	      }

	      return this._sound.duration;
	    },
	    set: function set(value) {
	      this._duration = Math.max(0, Number(value) || 0);
	      var isPlaying = this._state === STATE_PLAYING;
	      this.stop();

	      if (isPlaying) {
	        this.play();
	      }
	    }
	  }, {
	    key: "isPaused",
	    get: function get() {
	      return this._state === STATE_PAUSED;
	    }
	  }, {
	    key: "isPlaying",
	    get: function get() {
	      return this._state === STATE_PLAYING;
	    }
	  }, {
	    key: "isStopped",
	    get: function get() {
	      return this._state === STATE_STOPPED;
	    }
	  }, {
	    key: "isSuspended",
	    get: function get() {
	      return this._suspended;
	    }
	  }, {
	    key: "loop",
	    get: function get() {
	      return this._loop;
	    },
	    set: function set(value) {
	      this._loop = !!value;

	      if (this.source) {
	        this.source.loop = this._loop;
	      }
	    }
	  }, {
	    key: "pitch",
	    get: function get() {
	      return this._pitch;
	    },
	    set: function set(pitch) {
	      this._currentOffset = this.currentTime;
	      this._startedAt = this._manager.context.currentTime;
	      this._pitch = Math.max(Number(pitch) || 0, 0.01);

	      if (this.source) {
	        this.source.playbackRate.value = this._pitch;
	      }
	    }
	  }, {
	    key: "sound",
	    get: function get() {
	      return this._sound;
	    },
	    set: function set(value) {
	      this._sound = value;

	      if (this._state !== STATE_STOPPED) {
	        this.stop();
	      } else {
	        this._createSource();
	      }
	    }
	  }, {
	    key: "startTime",
	    get: function get() {
	      return this._startTime;
	    },
	    set: function set(value) {
	      this._startTime = Math.max(0, Number(value) || 0);
	      var isPlaying = this._state === STATE_PLAYING;
	      this.stop();

	      if (isPlaying) {
	        this.play();
	      }
	    }
	  }, {
	    key: "volume",
	    get: function get() {
	      return this._volume;
	    },
	    set: function set(volume) {
	      volume = math.clamp(volume, 0, 1);
	      this._volume = volume;

	      if (this.gain) {
	        this.gain.gain.value = volume * this._manager.volume;
	      }
	    }
	  }]);

	  return SoundInstance;
	}(EventHandler);

	if (!hasAudioContext()) {
	  Object.assign(SoundInstance.prototype, {
	    play: function play() {
	      if (this._state !== STATE_STOPPED) {
	        this.stop();
	      }

	      if (!this.source) {
	        if (!this._createSource()) {
	          return false;
	        }
	      }

	      this.volume = this._volume;
	      this.pitch = this._pitch;
	      this.loop = this._loop;
	      this.source.play();
	      this._state = STATE_PLAYING;
	      this._playWhenLoaded = false;

	      this._manager.on('volumechange', this._onManagerVolumeChange, this);

	      this._manager.on('suspend', this._onManagerSuspend, this);

	      this._manager.on('resume', this._onManagerResume, this);

	      this._manager.on('destroy', this._onManagerDestroy, this);

	      if (this._manager.suspended) this._onManagerSuspend();
	      if (!this._suspendInstanceEvents) this._onPlay();
	      return true;
	    },
	    pause: function pause() {
	      if (!this.source || this._state !== STATE_PLAYING) return false;
	      this._suspendEndEvent++;
	      this.source.pause();
	      this._playWhenLoaded = false;
	      this._state = STATE_PAUSED;
	      this._startOffset = null;
	      if (!this._suspendInstanceEvents) this._onPause();
	      return true;
	    },
	    resume: function resume() {
	      if (!this.source || this._state !== STATE_PAUSED) return false;
	      this._state = STATE_PLAYING;
	      this._playWhenLoaded = false;

	      if (this.source.paused) {
	        this.source.play();
	        if (!this._suspendInstanceEvents) this._onResume();
	      }

	      return true;
	    },
	    stop: function stop() {
	      if (!this.source || this._state === STATE_STOPPED) return false;

	      this._manager.off('volumechange', this._onManagerVolumeChange, this);

	      this._manager.off('suspend', this._onManagerSuspend, this);

	      this._manager.off('resume', this._onManagerResume, this);

	      this._manager.off('destroy', this._onManagerDestroy, this);

	      this._suspendEndEvent++;
	      this.source.pause();
	      this._playWhenLoaded = false;
	      this._state = STATE_STOPPED;
	      this._startOffset = null;
	      if (!this._suspendInstanceEvents) this._onStop();
	      return true;
	    },
	    setExternalNodes: function setExternalNodes() {},
	    clearExternalNodes: function clearExternalNodes() {},
	    getExternalNodes: function getExternalNodes() {
	      return [null, null];
	    },
	    _onLoadedMetadata: function _onLoadedMetadata() {
	      this.source.removeEventListener('loadedmetadata', this._loadedMetadataHandler);
	      this._isReady = true;
	      var offset = capTime(this._startOffset, this.duration);
	      offset = capTime(this._startTime + offset, this._sound.duration);
	      this._startOffset = null;
	      this.source.currentTime = offset;
	    },
	    _createSource: function _createSource() {
	      if (this._sound && this._sound.audio) {
	        this._isReady = false;
	        this.source = this._sound.audio.cloneNode(true);
	        this.source.addEventListener('loadedmetadata', this._loadedMetadataHandler);
	        this.source.addEventListener('timeupdate', this._timeUpdateHandler);
	        this.source.onended = this._endedHandler;
	      }

	      return this.source;
	    },
	    _onTimeUpdate: function _onTimeUpdate() {
	      if (!this._duration) return;

	      if (this.source.currentTime > capTime(this._startTime + this._duration, this.source.duration)) {
	        if (this.loop) {
	          this.source.currentTime = capTime(this._startTime, this.source.duration);
	        } else {
	          this.source.removeEventListener('timeupdate', this._timeUpdateHandler);
	          this.source.pause();

	          this._onEnded();
	        }
	      }
	    },
	    _onManagerDestroy: function _onManagerDestroy() {
	      if (this.source) {
	        this.source.pause();
	      }
	    }
	  });
	  Object.defineProperty(SoundInstance.prototype, 'volume', {
	    get: function get() {
	      return this._volume;
	    },
	    set: function set(volume) {
	      volume = math.clamp(volume, 0, 1);
	      this._volume = volume;

	      if (this.source) {
	        this.source.volume = volume * this._manager.volume;
	      }
	    }
	  });
	  Object.defineProperty(SoundInstance.prototype, 'pitch', {
	    get: function get() {
	      return this._pitch;
	    },
	    set: function set(pitch) {
	      this._pitch = Math.max(Number(pitch) || 0, 0.01);

	      if (this.source) {
	        this.source.playbackRate = this._pitch;
	      }
	    }
	  });
	  Object.defineProperty(SoundInstance.prototype, 'sound', {
	    get: function get() {
	      return this._sound;
	    },
	    set: function set(value) {
	      this.stop();
	      this._sound = value;
	    }
	  });
	  Object.defineProperty(SoundInstance.prototype, 'currentTime', {
	    get: function get() {
	      if (this._startOffset !== null) {
	        return this._startOffset;
	      }

	      if (this._state === STATE_STOPPED || !this.source) {
	        return 0;
	      }

	      return this.source.currentTime - this._startTime;
	    },
	    set: function set(value) {
	      if (value < 0) return;
	      this._startOffset = value;

	      if (this.source && this._isReady) {
	        this.source.currentTime = capTime(this._startTime + capTime(value, this.duration), this._sound.duration);
	        this._startOffset = null;
	      }
	    }
	  });
	}

	var MAX_DISTANCE = 10000;

	var SoundInstance3d = function (_SoundInstance) {
	  _inheritsLoose(SoundInstance3d, _SoundInstance);

	  function SoundInstance3d(manager, sound, options) {
	    var _this;

	    if (options === void 0) {
	      options = {};
	    }

	    _this = _SoundInstance.call(this, manager, sound, options) || this;
	    _this._position = new Vec3();
	    _this._velocity = new Vec3();
	    if (options.position) _this.position = options.position;
	    _this.maxDistance = options.maxDistance !== undefined ? Number(options.maxDistance) : MAX_DISTANCE;
	    _this.refDistance = options.refDistance !== undefined ? Number(options.refDistance) : 1;
	    _this.rollOffFactor = options.rollOffFactor !== undefined ? Number(options.rollOffFactor) : 1;
	    _this.distanceModel = options.distanceModel !== undefined ? options.distanceModel : DISTANCE_LINEAR;
	    return _this;
	  }

	  var _proto = SoundInstance3d.prototype;

	  _proto._initializeNodes = function _initializeNodes() {
	    this.gain = this._manager.context.createGain();
	    this.panner = this._manager.context.createPanner();
	    this.panner.connect(this.gain);
	    this._inputNode = this.panner;
	    this._connectorNode = this.gain;

	    this._connectorNode.connect(this._manager.context.destination);
	  };

	  _createClass(SoundInstance3d, [{
	    key: "position",
	    get: function get() {
	      return this._position;
	    },
	    set: function set(value) {
	      this._position.copy(value);

	      var panner = this.panner;

	      if ('positionX' in panner) {
	        panner.positionX.value = value.x;
	        panner.positionY.value = value.y;
	        panner.positionZ.value = value.z;
	      } else if (panner.setPosition) {
	        panner.setPosition(value.x, value.y, value.z);
	      }
	    }
	  }, {
	    key: "velocity",
	    get: function get() {
	      return this._velocity;
	    },
	    set: function set(velocity) {
	      this._velocity.copy(velocity);
	    }
	  }, {
	    key: "maxDistance",
	    get: function get() {
	      return this.panner.maxDistance;
	    },
	    set: function set(value) {
	      this.panner.maxDistance = value;
	    }
	  }, {
	    key: "refDistance",
	    get: function get() {
	      return this.panner.refDistance;
	    },
	    set: function set(value) {
	      this.panner.refDistance = value;
	    }
	  }, {
	    key: "rollOffFactor",
	    get: function get() {
	      return this.panner.rolloffFactor;
	    },
	    set: function set(value) {
	      this.panner.rolloffFactor = value;
	    }
	  }, {
	    key: "distanceModel",
	    get: function get() {
	      return this.panner.distanceModel;
	    },
	    set: function set(value) {
	      this.panner.distanceModel = value;
	    }
	  }]);

	  return SoundInstance3d;
	}(SoundInstance);

	if (!hasAudioContext()) {
	  var offset = new Vec3();

	  var fallOff = function fallOff(posOne, posTwo, refDistance, maxDistance, rollOffFactor, distanceModel) {
	    offset = offset.sub2(posOne, posTwo);
	    var distance = offset.length();

	    if (distance < refDistance) {
	      return 1;
	    } else if (distance > maxDistance) {
	      return 0;
	    }

	    var result = 0;

	    if (distanceModel === DISTANCE_LINEAR) {
	      result = 1 - rollOffFactor * (distance - refDistance) / (maxDistance - refDistance);
	    } else if (distanceModel === DISTANCE_INVERSE) {
	      result = refDistance / (refDistance + rollOffFactor * (distance - refDistance));
	    } else if (distanceModel === DISTANCE_EXPONENTIAL) {
	      result = Math.pow(distance / refDistance, -rollOffFactor);
	    }

	    return math.clamp(result, 0, 1);
	  };

	  Object.defineProperty(SoundInstance3d.prototype, 'position', {
	    get: function get() {
	      return this._position;
	    },
	    set: function set(position) {
	      this._position.copy(position);

	      if (this.source) {
	        var listener = this._manager.listener;
	        var lpos = listener.getPosition();
	        var factor = fallOff(lpos, this._position, this.refDistance, this.maxDistance, this.rollOffFactor, this.distanceModel);
	        var v = this.volume;
	        this.source.volume = v * factor * this._manager.volume;
	      }
	    }
	  });
	  Object.defineProperty(SoundInstance3d.prototype, 'maxDistance', {
	    get: function get() {
	      return this._maxDistance;
	    },
	    set: function set(value) {
	      this._maxDistance = value;
	    }
	  });
	  Object.defineProperty(SoundInstance3d.prototype, 'refDistance', {
	    get: function get() {
	      return this._refDistance;
	    },
	    set: function set(value) {
	      this._refDistance = value;
	    }
	  });
	  Object.defineProperty(SoundInstance3d.prototype, 'rollOffFactor', {
	    get: function get() {
	      return this._rollOffFactor;
	    },
	    set: function set(value) {
	      this._rollOffFactor = value;
	    }
	  });
	  Object.defineProperty(SoundInstance3d.prototype, 'distanceModel', {
	    get: function get() {
	      return this._distanceModel;
	    },
	    set: function set(value) {
	      this._distanceModel = value;
	    }
	  });
	}

	function BasisWorker() {
	  var BASIS_FORMAT = {
	    cTFETC1: 0,
	    cTFETC2: 1,
	    cTFBC1: 2,
	    cTFBC3: 3,
	    cTFPVRTC1_4_RGB: 8,
	    cTFPVRTC1_4_RGBA: 9,
	    cTFASTC_4x4: 10,
	    cTFATC_RGB: 11,
	    cTFATC_RGBA_INTERPOLATED_ALPHA: 12,
	    cTFRGBA32: 13,
	    cTFRGB565: 14,
	    cTFRGBA4444: 16
	  };
	  var opaqueMapping = {
	    astc: BASIS_FORMAT.cTFASTC_4x4,
	    dxt: BASIS_FORMAT.cTFBC1,
	    etc1: BASIS_FORMAT.cTFETC1,
	    etc2: BASIS_FORMAT.cTFETC1,
	    pvr: BASIS_FORMAT.cTFPVRTC1_4_RGB,
	    atc: BASIS_FORMAT.cTFATC_RGB,
	    none: BASIS_FORMAT.cTFRGB565
	  };
	  var alphaMapping = {
	    astc: BASIS_FORMAT.cTFASTC_4x4,
	    dxt: BASIS_FORMAT.cTFBC3,
	    etc1: BASIS_FORMAT.cTFRGBA4444,
	    etc2: BASIS_FORMAT.cTFETC2,
	    pvr: BASIS_FORMAT.cTFPVRTC1_4_RGBA,
	    atc: BASIS_FORMAT.cTFATC_RGBA_INTERPOLATED_ALPHA,
	    none: BASIS_FORMAT.cTFRGBA4444
	  };
	  var PIXEL_FORMAT = {
	    ETC1: 21,
	    ETC2_RGB: 22,
	    ETC2_RGBA: 23,
	    DXT1: 8,
	    DXT5: 10,
	    PVRTC_4BPP_RGB_1: 26,
	    PVRTC_4BPP_RGBA_1: 27,
	    ASTC_4x4: 28,
	    ATC_RGB: 29,
	    ATC_RGBA: 30,
	    R8_G8_B8_A8: 7,
	    R5_G6_B5: 3,
	    R4_G4_B4_A4: 5
	  };

	  var basisToEngineMapping = function basisToEngineMapping(basisFormat, deviceDetails) {
	    switch (basisFormat) {
	      case BASIS_FORMAT.cTFETC1:
	        return deviceDetails.formats.etc1 ? PIXEL_FORMAT.ETC1 : PIXEL_FORMAT.ETC2_RGB;

	      case BASIS_FORMAT.cTFETC2:
	        return PIXEL_FORMAT.ETC2_RGBA;

	      case BASIS_FORMAT.cTFBC1:
	        return PIXEL_FORMAT.DXT1;

	      case BASIS_FORMAT.cTFBC3:
	        return PIXEL_FORMAT.DXT5;

	      case BASIS_FORMAT.cTFPVRTC1_4_RGB:
	        return PIXEL_FORMAT.PVRTC_4BPP_RGB_1;

	      case BASIS_FORMAT.cTFPVRTC1_4_RGBA:
	        return PIXEL_FORMAT.PVRTC_4BPP_RGBA_1;

	      case BASIS_FORMAT.cTFASTC_4x4:
	        return PIXEL_FORMAT.ASTC_4x4;

	      case BASIS_FORMAT.cTFATC_RGB:
	        return PIXEL_FORMAT.ATC_RGB;

	      case BASIS_FORMAT.cTFATC_RGBA_INTERPOLATED_ALPHA:
	        return PIXEL_FORMAT.ATC_RGBA;

	      case BASIS_FORMAT.cTFRGBA32:
	        return PIXEL_FORMAT.R8_G8_B8_A8;

	      case BASIS_FORMAT.cTFRGB565:
	        return PIXEL_FORMAT.R5_G6_B5;

	      case BASIS_FORMAT.cTFRGBA4444:
	        return PIXEL_FORMAT.R4_G4_B4_A4;
	    }
	  };

	  var unswizzleGGGR = function unswizzleGGGR(data) {
	    var genB = function genB(R, G) {
	      var r = R * (2.0 / 255.0) - 1.0;
	      var g = G * (2.0 / 255.0) - 1.0;
	      var b = Math.sqrt(1.0 - Math.min(1.0, r * r + g * g));
	      return Math.max(0, Math.min(255, Math.floor((b + 1.0) * 0.5 * 255.0)));
	    };

	    for (var offset = 0; offset < data.length; offset += 4) {
	      var R = data[offset + 3];
	      var G = data[offset + 1];
	      data[offset + 0] = R;
	      data[offset + 2] = genB(R, G);
	      data[offset + 3] = 255;
	    }

	    return data;
	  };

	  var pack565 = function pack565(data) {
	    var result = new Uint16Array(data.length / 4);

	    for (var offset = 0; offset < data.length; offset += 4) {
	      var R = data[offset + 0];
	      var G = data[offset + 1];
	      var B = data[offset + 2];
	      result[offset / 4] = (R & 0xf8) << 8 | (G & 0xfc) << 3 | B >> 3;
	    }

	    return result;
	  };

	  var isPOT = function isPOT(width, height) {
	    return (width & width - 1) === 0 && (height & height - 1) === 0;
	  };

	  var performanceNow = function performanceNow() {
	    return typeof performance !== 'undefined' ? performance.now() : 0;
	  };

	  var basis;
	  var rgbPriority;
	  var rgbaPriority;

	  var chooseTargetFormat = function chooseTargetFormat(deviceDetails, hasAlpha, isUASTC) {
	    if (isUASTC) {
	      if (deviceDetails.formats.astc) {
	        return 'astc';
	      }
	    } else {
	      if (hasAlpha) {
	        if (deviceDetails.formats.etc2) {
	          return 'etc2';
	        }
	      } else {
	        if (deviceDetails.formats.etc1 || deviceDetails.formats.etc2) {
	          return 'etc1';
	        }
	      }
	    }

	    var testInOrder = function testInOrder(priority) {
	      for (var i = 0; i < priority.length; ++i) {
	        var format = priority[i];

	        if (deviceDetails.formats[format]) {
	          return format;
	        }
	      }

	      return 'none';
	    };

	    return testInOrder(hasAlpha ? rgbaPriority : rgbPriority);
	  };

	  var dimensionsValid = function dimensionsValid(width, height, format, webgl2) {
	    switch (format) {
	      case BASIS_FORMAT.cTFETC1:
	      case BASIS_FORMAT.cTFETC2:
	        return true;

	      case BASIS_FORMAT.cTFBC1:
	      case BASIS_FORMAT.cTFBC3:
	        return (width & 0x3) === 0 && (height & 0x3) === 0;

	      case BASIS_FORMAT.cTFPVRTC1_4_RGB:
	      case BASIS_FORMAT.cTFPVRTC1_4_RGBA:
	        return isPOT(width, height) && (width === height || webgl2);

	      case BASIS_FORMAT.cTFASTC_4x4:
	        return true;

	      case BASIS_FORMAT.cTFATC_RGB:
	      case BASIS_FORMAT.cTFATC_RGBA_INTERPOLATED_ALPHA:
	        return true;
	    }
	  };

	  var transcodeKTX2 = function transcodeKTX2(url, data, options) {
	    if (!basis.KTX2File) {
	      throw new Error('Basis transcoder module does not include support for KTX2.');
	    }

	    var funcStart = performanceNow();
	    var basisFile = new basis.KTX2File(new Uint8Array(data));
	    var width = basisFile.getWidth();
	    var height = basisFile.getHeight();
	    var levels = basisFile.getLevels();
	    var hasAlpha = !!basisFile.getHasAlpha();
	    var isUASTC = basisFile.isUASTC && basisFile.isUASTC();

	    if (!width || !height || !levels) {
	      basisFile.close();
	      basisFile.delete();
	      throw new Error("Invalid image dimensions url=" + url + " width=" + width + " height=" + height + " levels=" + levels);
	    }

	    var format = chooseTargetFormat(options.deviceDetails, hasAlpha, isUASTC);
	    var unswizzle = !!options.isGGGR && format === 'pvr';
	    var basisFormat;

	    if (unswizzle) {
	      basisFormat = BASIS_FORMAT.cTFRGBA32;
	    } else {
	      basisFormat = hasAlpha ? alphaMapping[format] : opaqueMapping[format];

	      if (!dimensionsValid(width, height, basisFormat, options.deviceDetails.webgl2)) {
	        basisFormat = hasAlpha ? BASIS_FORMAT.cTFRGBA32 : BASIS_FORMAT.cTFRGB565;
	      }
	    }

	    if (!basisFile.startTranscoding()) {
	      basisFile.close();
	      basisFile.delete();
	      throw new Error('Failed to start transcoding url=' + url);
	    }

	    var i;
	    var levelData = [];

	    for (var mip = 0; mip < levels; ++mip) {
	      var dstSize = basisFile.getImageTranscodedSizeInBytes(mip, 0, 0, basisFormat);
	      var dst = new Uint8Array(dstSize);

	      if (!basisFile.transcodeImage(dst, mip, 0, 0, basisFormat, 0, -1, -1)) {
	        basisFile.close();
	        basisFile.delete();
	        throw new Error('Failed to transcode image url=' + url);
	      }

	      var is16BitFormat = basisFormat === BASIS_FORMAT.cTFRGB565 || basisFormat === BASIS_FORMAT.cTFRGBA4444;
	      levelData.push(is16BitFormat ? new Uint16Array(dst.buffer) : dst);
	    }

	    basisFile.close();
	    basisFile.delete();

	    if (unswizzle) {
	      basisFormat = BASIS_FORMAT.cTFRGB565;

	      for (i = 0; i < levelData.length; ++i) {
	        levelData[i] = pack565(unswizzleGGGR(levelData[i]));
	      }
	    }

	    return {
	      format: basisToEngineMapping(basisFormat, options.deviceDetails),
	      width: width,
	      height: height,
	      levels: levelData,
	      cubemap: false,
	      transcodeTime: performanceNow() - funcStart,
	      url: url,
	      unswizzledGGGR: unswizzle
	    };
	  };

	  var transcodeBasis = function transcodeBasis(url, data, options) {
	    var funcStart = performanceNow();
	    var basisFile = new basis.BasisFile(new Uint8Array(data));
	    var width = basisFile.getImageWidth(0, 0);
	    var height = basisFile.getImageHeight(0, 0);
	    var images = basisFile.getNumImages();
	    var levels = basisFile.getNumLevels(0);
	    var hasAlpha = !!basisFile.getHasAlpha();
	    var isUASTC = basisFile.isUASTC && basisFile.isUASTC();

	    if (!width || !height || !images || !levels) {
	      basisFile.close();
	      basisFile.delete();
	      throw new Error("Invalid image dimensions url=" + url + " width=" + width + " height=" + height + " images=" + images + " levels=" + levels);
	    }

	    var format = chooseTargetFormat(options.deviceDetails, hasAlpha, isUASTC);
	    var unswizzle = !!options.isGGGR && format === 'pvr';
	    var basisFormat;

	    if (unswizzle) {
	      basisFormat = BASIS_FORMAT.cTFRGBA32;
	    } else {
	      basisFormat = hasAlpha ? alphaMapping[format] : opaqueMapping[format];

	      if (!dimensionsValid(width, height, basisFormat, options.deviceDetails.webgl2)) {
	        basisFormat = hasAlpha ? BASIS_FORMAT.cTFRGBA32 : BASIS_FORMAT.cTFRGB565;
	      }
	    }

	    if (!basisFile.startTranscoding()) {
	      basisFile.close();
	      basisFile.delete();
	      throw new Error('Failed to start transcoding url=' + url);
	    }

	    var i;
	    var levelData = [];

	    for (var mip = 0; mip < levels; ++mip) {
	      var dstSize = basisFile.getImageTranscodedSizeInBytes(0, mip, basisFormat);
	      var dst = new Uint8Array(dstSize);

	      if (!basisFile.transcodeImage(dst, 0, mip, basisFormat, 0, 0)) {
	        basisFile.close();
	        basisFile.delete();
	        throw new Error('Failed to transcode image url=' + url);
	      }

	      var is16BitFormat = basisFormat === BASIS_FORMAT.cTFRGB565 || basisFormat === BASIS_FORMAT.cTFRGBA4444;
	      levelData.push(is16BitFormat ? new Uint16Array(dst.buffer) : dst);
	    }

	    basisFile.close();
	    basisFile.delete();

	    if (unswizzle) {
	      basisFormat = BASIS_FORMAT.cTFRGB565;

	      for (i = 0; i < levelData.length; ++i) {
	        levelData[i] = pack565(unswizzleGGGR(levelData[i]));
	      }
	    }

	    return {
	      format: basisToEngineMapping(basisFormat, options.deviceDetails),
	      width: width,
	      height: height,
	      levels: levelData,
	      cubemap: false,
	      transcodeTime: performanceNow() - funcStart,
	      url: url,
	      unswizzledGGGR: unswizzle
	    };
	  };

	  var transcode = function transcode(url, data, options) {
	    return options.isKTX2 ? transcodeKTX2(url, data, options) : transcodeBasis(url, data, options);
	  };

	  var workerTranscode = function workerTranscode(url, data, options) {
	    try {
	      var result = transcode(url, data, options);
	      result.levels = result.levels.map(function (v) {
	        return v.buffer;
	      });
	      self.postMessage({
	        url: url,
	        data: result
	      }, result.levels);
	    } catch (err) {
	      self.postMessage({
	        url: url,
	        err: err
	      }, null);
	    }
	  };

	  var workerInit = function workerInit(config, callback) {
	    self.importScripts(config.basisUrl);

	    var instantiateWasmFunc = function instantiateWasmFunc(imports, successCallback) {
	      WebAssembly.instantiate(config.module, imports).then(function (result) {
	        successCallback(result);
	      }).catch(function (reason) {
	        console.error('instantiate failed + ' + reason);
	      });
	      return {};
	    };

	    self.BASIS(config.module ? {
	      instantiateWasm: instantiateWasmFunc
	    } : null).then(function (instance) {
	      instance.initializeBasis();
	      basis = instance;
	      rgbPriority = config.rgbPriority;
	      rgbaPriority = config.rgbaPriority;
	      callback(null);
	    });
	  };

	  var queue = [];

	  self.onmessage = function (message) {
	    var data = message.data;

	    switch (data.type) {
	      case 'init':
	        workerInit(data.config, function () {
	          for (var i = 0; i < queue.length; ++i) {
	            workerTranscode(queue[i].url, queue[i].data, queue[i].options);
	          }

	          queue.length = 0;
	        });
	        break;

	      case 'transcode':
	        if (basis) {
	          workerTranscode(data.url, data.data, data.options);
	        } else {
	          queue.push(data);
	        }

	        break;
	    }
	  };
	}

	var getCompressionFormats = function getCompressionFormats(device) {
	  return {
	    astc: !!device.extCompressedTextureASTC,
	    atc: !!device.extCompressedTextureATC,
	    dxt: !!device.extCompressedTextureS3TC,
	    etc1: !!device.extCompressedTextureETC1,
	    etc2: !!device.extCompressedTextureETC,
	    pvr: !!device.extCompressedTexturePVRTC
	  };
	};

	var prepareWorkerModules = function prepareWorkerModules(config, callback) {
	  var getWorkerBlob = function getWorkerBlob() {
	    var code = '(' + BasisWorker.toString() + ')()\n\n';
	    return new Blob([code], {
	      type: 'application/javascript'
	    });
	  };

	  var wasmSupported = function wasmSupported() {
	    try {
	      if (typeof WebAssembly === 'object' && typeof WebAssembly.instantiate === 'function') {
	        var module = new WebAssembly.Module(Uint8Array.of(0x0, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00));
	        if (module instanceof WebAssembly.Module) return new WebAssembly.Instance(module) instanceof WebAssembly.Instance;
	      }
	    } catch (e) {}

	    return false;
	  };

	  var sendResponse = function sendResponse(basisCode, module) {
	    callback(null, {
	      workerUrl: URL.createObjectURL(getWorkerBlob()),
	      basisUrl: URL.createObjectURL(basisCode),
	      module: module,
	      rgbPriority: config.rgbPriority,
	      rgbaPriority: config.rgbaPriority
	    });
	  };

	  var options = {
	    responseType: 'blob',
	    retry: config.maxRetries > 0,
	    maxRetries: config.maxRetries
	  };

	  if (config.glueUrl && config.wasmUrl && wasmSupported()) {
	    var basisCode = null;
	    var module = null;
	    http.get(config.glueUrl, options, function (err, response) {
	      if (err) {
	        callback(err);
	      } else {
	        if (module) {
	          sendResponse(response, module);
	        } else {
	          basisCode = response;
	        }
	      }
	    });
	    var fetchPromise = fetch(config.wasmUrl);

	    var compileManual = function compileManual() {
	      fetchPromise.then(function (result) {
	        return result.arrayBuffer();
	      }).then(function (buffer) {
	        return WebAssembly.compile(buffer);
	      }).then(function (module_) {
	        if (basisCode) {
	          sendResponse(basisCode, module_);
	        } else {
	          module = module_;
	        }
	      }).catch(function (err) {
	        callback(err, null);
	      });
	    };

	    if (WebAssembly.compileStreaming) {
	      WebAssembly.compileStreaming(fetchPromise).then(function (module_) {
	        if (basisCode) {
	          sendResponse(basisCode, module_);
	        } else {
	          module = module_;
	        }
	      }).catch(function (err) {
	        compileManual();
	      });
	    } else {
	      compileManual();
	    }
	  } else {
	    http.get(config.fallbackUrl, options, function (err, response) {
	      if (err) {
	        callback(err, null);
	      } else {
	        sendResponse(response, null);
	      }
	    });
	  }
	};

	var BasisQueue = function () {
	  function BasisQueue() {
	    this.callbacks = {};
	    this.queue = [];
	    this.clients = [];
	  }

	  var _proto = BasisQueue.prototype;

	  _proto.enqueueJob = function enqueueJob(url, data, callback, options) {
	    if (this.callbacks.hasOwnProperty(url)) {
	      this.callbacks[url].push(callback);
	    } else {
	      this.callbacks[url] = [callback];
	      var job = {
	        url: url,
	        data: data,
	        options: options
	      };

	      if (this.clients.length > 0) {
	        this.clients.shift().run(job);
	      } else {
	        this.queue.push(job);
	      }
	    }
	  };

	  _proto.enqueueClient = function enqueueClient(client) {
	    if (this.queue.length > 0) {
	      client.run(this.queue.shift());
	    } else {
	      this.clients.push(client);
	    }
	  };

	  _proto.handleResponse = function handleResponse(url, err, data) {
	    var callback = this.callbacks[url];

	    if (err) {
	      for (var i = 0; i < callback.length; ++i) {
	        callback[i](err);
	      }
	    } else {
	      if (data.format === PIXELFORMAT_R5_G6_B5 || data.format === PIXELFORMAT_R4_G4_B4_A4) {
	        data.levels = data.levels.map(function (v) {
	          return new Uint16Array(v);
	        });
	      } else {
	        data.levels = data.levels.map(function (v) {
	          return new Uint8Array(v);
	        });
	      }

	      for (var _i = 0; _i < callback.length; ++_i) {
	        callback[_i](null, data);
	      }
	    }

	    delete this.callbacks[url];
	  };

	  return BasisQueue;
	}();

	var BasisClient = function () {
	  function BasisClient(queue, config, eager) {
	    var _this = this;

	    this.queue = queue;
	    this.worker = new Worker(config.workerUrl);
	    this.worker.addEventListener('message', function (message) {
	      var data = message.data;

	      _this.queue.handleResponse(data.url, data.err, data.data);

	      if (!_this.eager) {
	        _this.queue.enqueueClient(_this);
	      }
	    });
	    this.worker.postMessage({
	      type: 'init',
	      config: config
	    });
	    this.eager = eager;
	  }

	  var _proto2 = BasisClient.prototype;

	  _proto2.run = function run(job) {
	    var transfer = [];

	    if (job.data instanceof ArrayBuffer) {
	      transfer.push(job.data);
	    }

	    this.worker.postMessage({
	      type: 'transcode',
	      url: job.url,
	      format: job.format,
	      data: job.data,
	      options: job.options
	    }, transfer);

	    if (this.eager) {
	      this.queue.enqueueClient(this);
	    }
	  };

	  return BasisClient;
	}();

	var defaultNumWorkers = 1;
	var defaultRgbPriority = ['etc1', 'etc2', 'astc', 'dxt', 'pvr', 'atc'];
	var defaultRgbaPriority = ['astc', 'dxt', 'etc2', 'pvr', 'atc'];
	var defaultMaxRetries = 5;
	var queue = new BasisQueue();
	var lazyConfig = null;
	var initializing = false;

	function basisInitialize(config) {
	  if (initializing) {
	    return;
	  }

	  if (!config) {
	    config = lazyConfig || {};
	  } else if (config.lazyInit) {
	    lazyConfig = config;
	    return;
	  }

	  if (!config.glueUrl || !config.wasmUrl || !config.fallbackUrl) {
	    var modules = (window.config ? window.config.wasmModules : window.PRELOAD_MODULES) || [];
	    var wasmModule = modules.find(function (m) {
	      return m.moduleName === 'BASIS';
	    });

	    if (wasmModule) {
	      var urlBase = window.ASSET_PREFIX || '';

	      if (!config.glueUrl) {
	        config.glueUrl = urlBase + wasmModule.glueUrl;
	      }

	      if (!config.wasmUrl) {
	        config.wasmUrl = urlBase + wasmModule.wasmUrl;
	      }

	      if (!config.fallbackUrl) {
	        config.fallbackUrl = urlBase + wasmModule.fallbackUrl;
	      }
	    }
	  }

	  if (config.glueUrl || config.wasmUrl || config.fallbackUrl) {
	    initializing = true;
	    var numWorkers = Math.max(1, Math.min(16, config.numWorkers || defaultNumWorkers));
	    var eagerWorkers = config.numWorkers === 1 || (config.hasOwnProperty('eagerWorkers') ? config.eagerWorkers : true);
	    config.rgbPriority = config.rgbPriority || defaultRgbPriority;
	    config.rgbaPriority = config.rgbaPriority || defaultRgbaPriority;
	    config.maxRetries = config.hasOwnProperty('maxRetries') ? config.maxRetries : defaultMaxRetries;
	    prepareWorkerModules(config, function (err, clientConfig) {
	      if (err) {
	        console.error("failed to initialize basis worker: " + err);
	      } else {
	        for (var i = 0; i < numWorkers; ++i) {
	          queue.enqueueClient(new BasisClient(queue, clientConfig, eagerWorkers));
	        }
	      }
	    });
	  }
	}

	var deviceDetails = null;

	function basisTranscode(device, url, data, callback, options) {
	  basisInitialize();

	  if (!deviceDetails) {
	    deviceDetails = {
	      webgl2: device.webgl2,
	      formats: getCompressionFormats(device)
	    };
	  }

	  queue.enqueueJob(url, data, callback, {
	    deviceDetails: deviceDetails,
	    isGGGR: !!(options != null && options.isGGGR),
	    isKTX2: !!(options != null && options.isKTX2)
	  });
	  return initializing;
	}

	var AnimClipHandler = function () {
	  function AnimClipHandler(app) {
	    this.handlerType = "animclip";
	    this.maxRetries = 0;
	  }

	  var _proto = AnimClipHandler.prototype;

	  _proto.load = function load(url, callback) {
	    if (typeof url === 'string') {
	      url = {
	        load: url,
	        original: url
	      };
	    }

	    var options = {
	      retry: this.maxRetries > 0,
	      maxRetries: this.maxRetries
	    };

	    if (url.load.startsWith('blob:')) {
	      options.responseType = Http.ResponseType.JSON;
	    }

	    http.get(url.load, options, function (err, response) {
	      if (err) {
	        callback("Error loading animation clip resource: " + url.original + " [" + err + "]");
	      } else {
	        callback(null, response);
	      }
	    });
	  };

	  _proto.open = function open(url, data) {
	    var name = data.name;
	    var duration = data.duration;
	    var inputs = data.inputs.map(function (input) {
	      return new AnimData(1, input);
	    });
	    var outputs = data.outputs.map(function (output) {
	      return new AnimData(output.components, output.data);
	    });
	    var curves = data.curves.map(function (curve) {
	      return new AnimCurve([curve.path], curve.inputIndex, curve.outputIndex, curve.interpolation);
	    });
	    return new AnimTrack(name, duration, inputs, outputs, curves);
	  };

	  _proto.patch = function patch(asset, assets) {};

	  return AnimClipHandler;
	}();

	var AnimStateGraphHandler = function () {
	  function AnimStateGraphHandler(app) {
	    this.handlerType = "animstategraph";
	    this.maxRetries = 0;
	  }

	  var _proto = AnimStateGraphHandler.prototype;

	  _proto.load = function load(url, callback) {
	    if (typeof url === 'string') {
	      url = {
	        load: url,
	        original: url
	      };
	    }

	    var options = {
	      retry: this.maxRetries > 0,
	      maxRetries: this.maxRetries
	    };

	    if (url.load.startsWith('blob:')) {
	      options.responseType = Http.ResponseType.JSON;
	    }

	    http.get(url.load, options, function (err, response) {
	      if (err) {
	        callback("Error loading animation state graph resource: " + url.original + " [" + err + "]");
	      } else {
	        callback(null, response);
	      }
	    });
	  };

	  _proto.open = function open(url, data) {
	    return new AnimStateGraph(data);
	  };

	  _proto.patch = function patch(asset, assets) {};

	  return AnimStateGraphHandler;
	}();

	var Render = function (_EventHandler) {
	  _inheritsLoose(Render, _EventHandler);

	  function Render() {
	    var _this;

	    _this = _EventHandler.call(this) || this;
	    _this._meshes = null;
	    return _this;
	  }

	  var _proto = Render.prototype;

	  _proto.destroy = function destroy() {
	    this.meshes = null;
	  };

	  _proto.decRefMeshes = function decRefMeshes() {
	    if (this._meshes) {
	      var count = this._meshes.length;

	      for (var i = 0; i < count; i++) {
	        var mesh = this._meshes[i];

	        if (mesh) {
	          mesh.decRefCount();

	          if (mesh.refCount < 1) {
	            mesh.destroy();
	            this._meshes[i] = null;
	          }
	        }
	      }
	    }
	  };

	  _proto.incRefMeshes = function incRefMeshes() {
	    if (this._meshes) {
	      var count = this._meshes.length;

	      for (var i = 0; i < count; i++) {
	        if (this._meshes[i]) {
	          this._meshes[i].incRefCount();
	        }
	      }
	    }
	  };

	  _createClass(Render, [{
	    key: "meshes",
	    get: function get() {
	      return this._meshes;
	    },
	    set: function set(value) {
	      this.decRefMeshes();
	      this._meshes = value;
	      this.incRefMeshes();
	      this.fire('set:meshes', value);
	    }
	  }]);

	  return Render;
	}(EventHandler);

	var SkinInstanceCachedObject = function (_RefCountedObject) {
	  _inheritsLoose(SkinInstanceCachedObject, _RefCountedObject);

	  function SkinInstanceCachedObject(skin, skinInstance) {
	    var _this;

	    _this = _RefCountedObject.call(this) || this;
	    _this.skin = skin;
	    _this.skinInstance = skinInstance;
	    return _this;
	  }

	  return SkinInstanceCachedObject;
	}(RefCountedObject);

	var SkinInstanceCache = function () {
	  function SkinInstanceCache() {}

	  SkinInstanceCache.createCachedSkinInstance = function createCachedSkinInstance(skin, rootBone, entity) {
	    var skinInst = SkinInstanceCache.getCachedSkinInstance(skin, rootBone);

	    if (!skinInst) {
	      skinInst = new SkinInstance(skin);
	      skinInst.resolve(rootBone, entity);
	      SkinInstanceCache.addCachedSkinInstance(skin, rootBone, skinInst);
	    }

	    return skinInst;
	  };

	  SkinInstanceCache.getCachedSkinInstance = function getCachedSkinInstance(skin, rootBone) {
	    var skinInstance = null;

	    var cachedObjArray = SkinInstanceCache._skinInstanceCache.get(rootBone);

	    if (cachedObjArray) {
	      var cachedObj = cachedObjArray.find(function (element) {
	        return element.skin === skin;
	      });

	      if (cachedObj) {
	        cachedObj.incRefCount();
	        skinInstance = cachedObj.skinInstance;
	      }
	    }

	    return skinInstance;
	  };

	  SkinInstanceCache.addCachedSkinInstance = function addCachedSkinInstance(skin, rootBone, skinInstance) {
	    var cachedObjArray = SkinInstanceCache._skinInstanceCache.get(rootBone);

	    if (!cachedObjArray) {
	      cachedObjArray = [];

	      SkinInstanceCache._skinInstanceCache.set(rootBone, cachedObjArray);
	    }

	    var cachedObj = cachedObjArray.find(function (element) {
	      return element.skin === skin;
	    });

	    if (!cachedObj) {
	      cachedObj = new SkinInstanceCachedObject(skin, skinInstance);
	      cachedObjArray.push(cachedObj);
	    }

	    cachedObj.incRefCount();
	  };

	  SkinInstanceCache.removeCachedSkinInstance = function removeCachedSkinInstance(skinInstance) {
	    if (skinInstance) {
	      var rootBone = skinInstance.rootBone;

	      if (rootBone) {
	        var cachedObjArray = SkinInstanceCache._skinInstanceCache.get(rootBone);

	        if (cachedObjArray) {
	          var cachedObjIndex = cachedObjArray.findIndex(function (element) {
	            return element.skinInstance === skinInstance;
	          });

	          if (cachedObjIndex >= 0) {
	            var cachedObj = cachedObjArray[cachedObjIndex];
	            cachedObj.decRefCount();

	            if (cachedObj.refCount === 0) {
	              cachedObjArray.splice(cachedObjIndex, 1);

	              if (!cachedObjArray.length) {
	                SkinInstanceCache._skinInstanceCache.delete(rootBone);
	              }

	              if (skinInstance) {
	                skinInstance.destroy();
	                cachedObj.skinInstance = null;
	              }
	            }
	          }
	        }
	      }
	    }
	  };

	  return SkinInstanceCache;
	}();

	SkinInstanceCache._skinInstanceCache = new Map();

	var GlbContainerResource = function () {
	  function GlbContainerResource(data, asset, assets, defaultMaterial) {
	    var createAsset = function createAsset(type, resource, index) {
	      var subAsset = GlbContainerResource.createAsset(asset.name, type, resource, index);
	      assets.add(subAsset);
	      return subAsset;
	    };

	    var renders = [];

	    for (var i = 0; i < data.renders.length; ++i) {
	      renders.push(createAsset('render', data.renders[i], i));
	    }

	    var materials = [];

	    for (var _i = 0; _i < data.materials.length; ++_i) {
	      materials.push(createAsset('material', data.materials[_i], _i));
	    }

	    var animations = [];

	    for (var _i2 = 0; _i2 < data.animations.length; ++_i2) {
	      animations.push(createAsset('animation', data.animations[_i2], _i2));
	    }

	    this.data = data;
	    this._model = null;
	    this._assetName = asset.name;
	    this._assets = assets;
	    this._defaultMaterial = defaultMaterial;
	    this.renders = renders;
	    this.materials = materials;
	    this.textures = data.textures;
	    this.animations = animations;
	  }

	  GlbContainerResource.createAsset = function createAsset(assetName, type, resource, index) {
	    var subAsset = new Asset(assetName + '/' + type + '/' + index, type, {
	      url: ''
	    });
	    subAsset.resource = resource;
	    subAsset.loaded = true;
	    return subAsset;
	  };

	  var _proto = GlbContainerResource.prototype;

	  _proto.instantiateModelEntity = function instantiateModelEntity(options) {
	    var entity = new Entity();
	    entity.addComponent('model', Object.assign({
	      type: 'asset',
	      asset: this.model
	    }, options));
	    return entity;
	  };

	  _proto.instantiateRenderEntity = function instantiateRenderEntity(options) {
	    var _this = this;

	    var defaultMaterial = this._defaultMaterial;
	    var skinnedMeshInstances = [];

	    var createMeshInstance = function createMeshInstance(root, entity, mesh, materials, meshDefaultMaterials, skins, gltfNode) {
	      var materialIndex = meshDefaultMaterials[mesh.id];
	      var material = materialIndex === undefined ? defaultMaterial : materials[materialIndex];
	      var meshInstance = new MeshInstance(mesh, material);

	      if (mesh.morph) {
	        meshInstance.morphInstance = new MorphInstance(mesh.morph);
	      }

	      if (gltfNode.hasOwnProperty('skin')) {
	        skinnedMeshInstances.push({
	          meshInstance: meshInstance,
	          rootBone: root,
	          entity: entity
	        });
	      }

	      return meshInstance;
	    };

	    var cloneHierarchy = function cloneHierarchy(root, node, glb) {
	      var entity = new Entity();

	      node._cloneInternal(entity);

	      if (!root) root = entity;
	      var attachedMi = null;
	      var renderAsset = null;

	      for (var i = 0; i < glb.nodes.length; i++) {
	        var glbNode = glb.nodes[i];

	        if (glbNode === node) {
	          var gltfNode = glb.gltf.nodes[i];

	          if (gltfNode.hasOwnProperty('mesh')) {
	            var meshGroup = glb.renders[gltfNode.mesh].meshes;
	            renderAsset = _this.renders[gltfNode.mesh];

	            for (var mi = 0; mi < meshGroup.length; mi++) {
	              var mesh = meshGroup[mi];

	              if (mesh) {
	                var cloneMi = createMeshInstance(root, entity, mesh, glb.materials, glb.meshDefaultMaterials, glb.skins, gltfNode);

	                if (!attachedMi) {
	                  attachedMi = [];
	                }

	                attachedMi.push(cloneMi);
	              }
	            }
	          }

	          if (glb.lights) {
	            var lightEntity = glb.lights.get(gltfNode);

	            if (lightEntity) {
	              entity.addChild(lightEntity.clone());
	            }
	          }

	          if (glb.cameras) {
	            var cameraEntity = glb.cameras.get(gltfNode);

	            if (cameraEntity) {
	              cameraEntity.camera.system.cloneComponent(cameraEntity, entity);
	            }
	          }
	        }
	      }

	      if (attachedMi) {
	        entity.addComponent('render', Object.assign({
	          type: 'asset',
	          meshInstances: attachedMi,
	          rootBone: root
	        }, options));
	        entity.render.assignAsset(renderAsset);
	      }

	      var children = node.children;

	      for (var _i3 = 0; _i3 < children.length; _i3++) {
	        var childClone = cloneHierarchy(root, children[_i3], glb);
	        entity.addChild(childClone);
	      }

	      return entity;
	    };

	    var sceneClones = [];

	    for (var _iterator = _createForOfIteratorHelperLoose(this.data.scenes), _step; !(_step = _iterator()).done;) {
	      var scene = _step.value;
	      sceneClones.push(cloneHierarchy(null, scene, this.data));
	    }

	    skinnedMeshInstances.forEach(function (data) {
	      data.meshInstance.skinInstance = SkinInstanceCache.createCachedSkinInstance(data.meshInstance.mesh.skin, data.rootBone, data.entity);
	    });
	    return GlbContainerResource.createSceneHierarchy(sceneClones, 'Entity');
	  };

	  _proto.getMaterialVariants = function getMaterialVariants() {
	    return this.data.variants ? Object.keys(this.data.variants) : [];
	  };

	  _proto.applyMaterialVariant = function applyMaterialVariant(entity, name) {
	    var variant = name ? this.data.variants[name] : null;

	    if (variant === undefined) {
	      return;
	    }

	    var renders = entity.findComponents("render");

	    for (var i = 0; i < renders.length; i++) {
	      var renderComponent = renders[i];

	      this._applyMaterialVariant(variant, renderComponent.meshInstances);
	    }
	  };

	  _proto.applyMaterialVariantInstances = function applyMaterialVariantInstances(instances, name) {
	    var variant = name ? this.data.variants[name] : null;

	    if (variant === undefined) {
	      return;
	    }

	    this._applyMaterialVariant(variant, instances);
	  };

	  _proto._applyMaterialVariant = function _applyMaterialVariant(variant, instances) {
	    var _this2 = this;

	    instances.forEach(function (instance) {
	      if (variant === null) {
	        instance.material = _this2._defaultMaterial;
	      } else {
	        var meshVariants = _this2.data.meshVariants[instance.mesh.id];

	        if (meshVariants) {
	          instance.material = _this2.data.materials[meshVariants[variant]];
	        }
	      }
	    });
	  };

	  GlbContainerResource.createSceneHierarchy = function createSceneHierarchy(sceneNodes, nodeType) {
	    var root = null;

	    if (sceneNodes.length === 1) {
	      root = sceneNodes[0];
	    } else {
	      root = new nodeType('SceneGroup');

	      for (var _iterator2 = _createForOfIteratorHelperLoose(sceneNodes), _step2; !(_step2 = _iterator2()).done;) {
	        var scene = _step2.value;
	        root.addChild(scene);
	      }
	    }

	    return root;
	  };

	  GlbContainerResource.createModel = function createModel(glb, defaultMaterial) {
	    var createMeshInstance = function createMeshInstance(model, mesh, skins, skinInstances, materials, node, gltfNode) {
	      var materialIndex = glb.meshDefaultMaterials[mesh.id];
	      var material = materialIndex === undefined ? defaultMaterial : materials[materialIndex];
	      var meshInstance = new MeshInstance(mesh, material, node);

	      if (mesh.morph) {
	        var morphInstance = new MorphInstance(mesh.morph);
	        meshInstance.morphInstance = morphInstance;
	        model.morphInstances.push(morphInstance);
	      }

	      if (gltfNode.hasOwnProperty('skin')) {
	        var skinIndex = gltfNode.skin;
	        var skin = skins[skinIndex];
	        mesh.skin = skin;
	        var skinInstance = skinInstances[skinIndex];
	        meshInstance.skinInstance = skinInstance;
	        model.skinInstances.push(skinInstance);
	      }

	      model.meshInstances.push(meshInstance);
	    };

	    var model = new Model();
	    var skinInstances = [];

	    for (var _iterator3 = _createForOfIteratorHelperLoose(glb.skins), _step3; !(_step3 = _iterator3()).done;) {
	      var skin = _step3.value;
	      var skinInstance = new SkinInstance(skin);
	      skinInstance.bones = skin.bones;
	      skinInstances.push(skinInstance);
	    }

	    model.graph = GlbContainerResource.createSceneHierarchy(glb.scenes, 'GraphNode');

	    for (var i = 0; i < glb.nodes.length; i++) {
	      var node = glb.nodes[i];

	      if (node.root === model.graph) {
	        var gltfNode = glb.gltf.nodes[i];

	        if (gltfNode.hasOwnProperty('mesh')) {
	          var meshGroup = glb.renders[gltfNode.mesh].meshes;

	          for (var mi = 0; mi < meshGroup.length; mi++) {
	            var mesh = meshGroup[mi];

	            if (mesh) {
	              createMeshInstance(model, mesh, glb.skins, skinInstances, glb.materials, node, gltfNode);
	            }
	          }
	        }
	      }
	    }

	    return model;
	  };

	  _proto.destroy = function destroy() {
	    var registry = this._assets;

	    var destroyAsset = function destroyAsset(asset) {
	      registry.remove(asset);
	      asset.unload();
	    };

	    var destroyAssets = function destroyAssets(assets) {
	      assets.forEach(function (asset) {
	        destroyAsset(asset);
	      });
	    };

	    if (this.animations) {
	      destroyAssets(this.animations);
	      this.animations = null;
	    }

	    if (this.textures) {
	      destroyAssets(this.textures);
	      this.textures = null;
	    }

	    if (this.materials) {
	      destroyAssets(this.materials);
	      this.materials = null;
	    }

	    if (this.renders) {
	      destroyAssets(this.renders);
	      this.renders = null;
	    }

	    if (this._model) {
	      destroyAsset(this._model);
	      this._model = null;
	    }

	    this.data = null;
	    this.assets = null;
	  };

	  _createClass(GlbContainerResource, [{
	    key: "model",
	    get: function get() {
	      if (!this._model) {
	        var model = GlbContainerResource.createModel(this.data, this._defaultMaterial);
	        var modelAsset = GlbContainerResource.createAsset(this._assetName, 'model', model, 0);

	        this._assets.add(modelAsset);

	        this._model = modelAsset;
	      }

	      return this._model;
	    }
	  }]);

	  return GlbContainerResource;
	}();

	var dracoDecoderInstance = null;

	var getGlobalDracoDecoderModule = function getGlobalDracoDecoderModule() {
	  return typeof window !== 'undefined' && window.DracoDecoderModule;
	};

	var GlbResources = function () {
	  function GlbResources(gltf) {
	    this.gltf = gltf;
	    this.nodes = null;
	    this.scenes = null;
	    this.animations = null;
	    this.textures = null;
	    this.materials = null;
	    this.variants = null;
	    this.meshVariants = null;
	    this.meshDefaultMaterials = null;
	    this.renders = null;
	    this.skins = null;
	    this.lights = null;
	    this.cameras = null;
	  }

	  var _proto = GlbResources.prototype;

	  _proto.destroy = function destroy() {
	    if (this.renders) {
	      this.renders.forEach(function (render) {
	        render.meshes = null;
	      });
	    }
	  };

	  return GlbResources;
	}();

	var isDataURI = function isDataURI(uri) {
	  return /^data:.*,.*$/i.test(uri);
	};

	var getDataURIMimeType = function getDataURIMimeType(uri) {
	  return uri.substring(uri.indexOf(':') + 1, uri.indexOf(';'));
	};

	var getNumComponents = function getNumComponents(accessorType) {
	  switch (accessorType) {
	    case 'SCALAR':
	      return 1;

	    case 'VEC2':
	      return 2;

	    case 'VEC3':
	      return 3;

	    case 'VEC4':
	      return 4;

	    case 'MAT2':
	      return 4;

	    case 'MAT3':
	      return 9;

	    case 'MAT4':
	      return 16;

	    default:
	      return 3;
	  }
	};

	var getComponentType = function getComponentType(componentType) {
	  switch (componentType) {
	    case 5120:
	      return TYPE_INT8;

	    case 5121:
	      return TYPE_UINT8;

	    case 5122:
	      return TYPE_INT16;

	    case 5123:
	      return TYPE_UINT16;

	    case 5124:
	      return TYPE_INT32;

	    case 5125:
	      return TYPE_UINT32;

	    case 5126:
	      return TYPE_FLOAT32;

	    default:
	      return 0;
	  }
	};

	var getComponentSizeInBytes = function getComponentSizeInBytes(componentType) {
	  switch (componentType) {
	    case 5120:
	      return 1;

	    case 5121:
	      return 1;

	    case 5122:
	      return 2;

	    case 5123:
	      return 2;

	    case 5124:
	      return 4;

	    case 5125:
	      return 4;

	    case 5126:
	      return 4;

	    default:
	      return 0;
	  }
	};

	var getComponentDataType = function getComponentDataType(componentType) {
	  switch (componentType) {
	    case 5120:
	      return Int8Array;

	    case 5121:
	      return Uint8Array;

	    case 5122:
	      return Int16Array;

	    case 5123:
	      return Uint16Array;

	    case 5124:
	      return Int32Array;

	    case 5125:
	      return Uint32Array;

	    case 5126:
	      return Float32Array;

	    default:
	      return null;
	  }
	};

	var gltfToEngineSemanticMap = {
	  'POSITION': SEMANTIC_POSITION,
	  'NORMAL': SEMANTIC_NORMAL,
	  'TANGENT': SEMANTIC_TANGENT,
	  'COLOR_0': SEMANTIC_COLOR,
	  'JOINTS_0': SEMANTIC_BLENDINDICES,
	  'WEIGHTS_0': SEMANTIC_BLENDWEIGHT,
	  'TEXCOORD_0': SEMANTIC_TEXCOORD0,
	  'TEXCOORD_1': SEMANTIC_TEXCOORD1,
	  'TEXCOORD_2': SEMANTIC_TEXCOORD2,
	  'TEXCOORD_3': SEMANTIC_TEXCOORD3,
	  'TEXCOORD_4': SEMANTIC_TEXCOORD4,
	  'TEXCOORD_5': SEMANTIC_TEXCOORD5,
	  'TEXCOORD_6': SEMANTIC_TEXCOORD6,
	  'TEXCOORD_7': SEMANTIC_TEXCOORD7
	};

	var getDequantizeFunc = function getDequantizeFunc(srcType) {
	  switch (srcType) {
	    case TYPE_INT8:
	      return function (x) {
	        return Math.max(x / 127.0, -1.0);
	      };

	    case TYPE_UINT8:
	      return function (x) {
	        return x / 255.0;
	      };

	    case TYPE_INT16:
	      return function (x) {
	        return Math.max(x / 32767.0, -1.0);
	      };

	    case TYPE_UINT16:
	      return function (x) {
	        return x / 65535.0;
	      };

	    default:
	      return function (x) {
	        return x;
	      };
	  }
	};

	var dequantizeArray = function dequantizeArray(dstArray, srcArray, srcType) {
	  var convFunc = getDequantizeFunc(srcType);
	  var len = srcArray.length;

	  for (var i = 0; i < len; ++i) {
	    dstArray[i] = convFunc(srcArray[i]);
	  }

	  return dstArray;
	};

	var getAccessorData = function getAccessorData(gltfAccessor, bufferViews, flatten) {
	  if (flatten === void 0) {
	    flatten = false;
	  }

	  var numComponents = getNumComponents(gltfAccessor.type);
	  var dataType = getComponentDataType(gltfAccessor.componentType);

	  if (!dataType) {
	    return null;
	  }

	  var bufferView = bufferViews[gltfAccessor.bufferView];
	  var result;

	  if (gltfAccessor.sparse) {
	    var sparse = gltfAccessor.sparse;
	    var indicesAccessor = {
	      count: sparse.count,
	      type: 'SCALAR'
	    };
	    var indices = getAccessorData(Object.assign(indicesAccessor, sparse.indices), bufferViews, true);
	    var valuesAccessor = {
	      count: sparse.count,
	      type: gltfAccessor.scalar,
	      componentType: gltfAccessor.componentType
	    };
	    var values = getAccessorData(Object.assign(valuesAccessor, sparse.values), bufferViews, true);

	    if (gltfAccessor.hasOwnProperty('bufferView')) {
	      var baseAccessor = {
	        bufferView: gltfAccessor.bufferView,
	        byteOffset: gltfAccessor.byteOffset,
	        componentType: gltfAccessor.componentType,
	        count: gltfAccessor.count,
	        type: gltfAccessor.type
	      };
	      result = getAccessorData(baseAccessor, bufferViews, true).slice();
	    } else {
	      result = new dataType(gltfAccessor.count * numComponents);
	    }

	    for (var i = 0; i < sparse.count; ++i) {
	      var targetIndex = indices[i];

	      for (var j = 0; j < numComponents; ++j) {
	        result[targetIndex * numComponents + j] = values[i * numComponents + j];
	      }
	    }
	  } else if (flatten && bufferView.hasOwnProperty('byteStride')) {
	    var bytesPerElement = numComponents * dataType.BYTES_PER_ELEMENT;
	    var storage = new ArrayBuffer(gltfAccessor.count * bytesPerElement);
	    var tmpArray = new Uint8Array(storage);
	    var dstOffset = 0;

	    for (var _i = 0; _i < gltfAccessor.count; ++_i) {
	      var srcOffset = (gltfAccessor.byteOffset || 0) + _i * bufferView.byteStride;

	      for (var b = 0; b < bytesPerElement; ++b) {
	        tmpArray[dstOffset++] = bufferView[srcOffset++];
	      }
	    }

	    result = new dataType(storage);
	  } else {
	    result = new dataType(bufferView.buffer, bufferView.byteOffset + (gltfAccessor.byteOffset || 0), gltfAccessor.count * numComponents);
	  }

	  return result;
	};

	var getAccessorDataFloat32 = function getAccessorDataFloat32(gltfAccessor, bufferViews) {
	  var data = getAccessorData(gltfAccessor, bufferViews, true);

	  if (data instanceof Float32Array || !gltfAccessor.normalized) {
	    return data;
	  }

	  var float32Data = new Float32Array(data.length);
	  dequantizeArray(float32Data, data, getComponentType(gltfAccessor.componentType));
	  return float32Data;
	};

	var getAccessorBoundingBox = function getAccessorBoundingBox(gltfAccessor) {
	  var min = gltfAccessor.min;
	  var max = gltfAccessor.max;

	  if (!min || !max) {
	    return null;
	  }

	  if (gltfAccessor.normalized) {
	    var ctype = getComponentType(gltfAccessor.componentType);
	    min = dequantizeArray([], min, ctype);
	    max = dequantizeArray([], max, ctype);
	  }

	  return new BoundingBox(new Vec3((max[0] + min[0]) * 0.5, (max[1] + min[1]) * 0.5, (max[2] + min[2]) * 0.5), new Vec3((max[0] - min[0]) * 0.5, (max[1] - min[1]) * 0.5, (max[2] - min[2]) * 0.5));
	};

	var getPrimitiveType = function getPrimitiveType(primitive) {
	  if (!primitive.hasOwnProperty('mode')) {
	    return PRIMITIVE_TRIANGLES;
	  }

	  switch (primitive.mode) {
	    case 0:
	      return PRIMITIVE_POINTS;

	    case 1:
	      return PRIMITIVE_LINES;

	    case 2:
	      return PRIMITIVE_LINELOOP;

	    case 3:
	      return PRIMITIVE_LINESTRIP;

	    case 4:
	      return PRIMITIVE_TRIANGLES;

	    case 5:
	      return PRIMITIVE_TRISTRIP;

	    case 6:
	      return PRIMITIVE_TRIFAN;

	    default:
	      return PRIMITIVE_TRIANGLES;
	  }
	};

	var generateIndices = function generateIndices(numVertices) {
	  var dummyIndices = new Uint16Array(numVertices);

	  for (var i = 0; i < numVertices; i++) {
	    dummyIndices[i] = i;
	  }

	  return dummyIndices;
	};

	var generateNormals = function generateNormals(sourceDesc, indices) {
	  var p = sourceDesc[SEMANTIC_POSITION];

	  if (!p || p.components !== 3) {
	    return;
	  }

	  var positions;

	  if (p.size !== p.stride) {
	    var srcStride = p.stride / typedArrayTypesByteSize[p.type];
	    var src = new typedArrayTypes[p.type](p.buffer, p.offset, p.count * srcStride);
	    positions = new typedArrayTypes[p.type](p.count * 3);

	    for (var i = 0; i < p.count; ++i) {
	      positions[i * 3 + 0] = src[i * srcStride + 0];
	      positions[i * 3 + 1] = src[i * srcStride + 1];
	      positions[i * 3 + 2] = src[i * srcStride + 2];
	    }
	  } else {
	    positions = new typedArrayTypes[p.type](p.buffer, p.offset, p.count * 3);
	  }

	  var numVertices = p.count;

	  if (!indices) {
	    indices = generateIndices(numVertices);
	  }

	  var normalsTemp = calculateNormals(positions, indices);
	  var normals = new Float32Array(normalsTemp.length);
	  normals.set(normalsTemp);
	  sourceDesc[SEMANTIC_NORMAL] = {
	    buffer: normals.buffer,
	    size: 12,
	    offset: 0,
	    stride: 12,
	    count: numVertices,
	    components: 3,
	    type: TYPE_FLOAT32
	  };
	};

	var flipTexCoordVs = function flipTexCoordVs(vertexBuffer) {
	  var i, j;
	  var floatOffsets = [];
	  var shortOffsets = [];
	  var byteOffsets = [];

	  for (i = 0; i < vertexBuffer.format.elements.length; ++i) {
	    var element = vertexBuffer.format.elements[i];

	    if (element.name === SEMANTIC_TEXCOORD0 || element.name === SEMANTIC_TEXCOORD1) {
	      switch (element.dataType) {
	        case TYPE_FLOAT32:
	          floatOffsets.push({
	            offset: element.offset / 4 + 1,
	            stride: element.stride / 4
	          });
	          break;

	        case TYPE_UINT16:
	          shortOffsets.push({
	            offset: element.offset / 2 + 1,
	            stride: element.stride / 2
	          });
	          break;

	        case TYPE_UINT8:
	          byteOffsets.push({
	            offset: element.offset + 1,
	            stride: element.stride
	          });
	          break;
	      }
	    }
	  }

	  var flip = function flip(offsets, type, one) {
	    var typedArray = new type(vertexBuffer.storage);

	    for (i = 0; i < offsets.length; ++i) {
	      var index = offsets[i].offset;
	      var stride = offsets[i].stride;

	      for (j = 0; j < vertexBuffer.numVertices; ++j) {
	        typedArray[index] = one - typedArray[index];
	        index += stride;
	      }
	    }
	  };

	  if (floatOffsets.length > 0) {
	    flip(floatOffsets, Float32Array, 1.0);
	  }

	  if (shortOffsets.length > 0) {
	    flip(shortOffsets, Uint16Array, 65535);
	  }

	  if (byteOffsets.length > 0) {
	    flip(byteOffsets, Uint8Array, 255);
	  }
	};

	var cloneTexture = function cloneTexture(texture) {
	  var shallowCopyLevels = function shallowCopyLevels(texture) {
	    var result = [];

	    for (var mip = 0; mip < texture._levels.length; ++mip) {
	      var level = [];

	      if (texture.cubemap) {
	        for (var face = 0; face < 6; ++face) {
	          level.push(texture._levels[mip][face]);
	        }
	      } else {
	        level = texture._levels[mip];
	      }

	      result.push(level);
	    }

	    return result;
	  };

	  var result = new Texture(texture.device, texture);
	  result._levels = shallowCopyLevels(texture);
	  return result;
	};

	var cloneTextureAsset = function cloneTextureAsset(src) {
	  var result = new Asset(src.name + '_clone', src.type, src.file, src.data, src.options);
	  result.loaded = true;
	  result.resource = cloneTexture(src.resource);
	  src.registry.add(result);
	  return result;
	};

	var createVertexBufferInternal = function createVertexBufferInternal(device, sourceDesc, flipV) {
	  var positionDesc = sourceDesc[SEMANTIC_POSITION];

	  if (!positionDesc) {
	    return null;
	  }

	  var numVertices = positionDesc.count;
	  var vertexDesc = [];

	  for (var semantic in sourceDesc) {
	    if (sourceDesc.hasOwnProperty(semantic)) {
	      vertexDesc.push({
	        semantic: semantic,
	        components: sourceDesc[semantic].components,
	        type: sourceDesc[semantic].type,
	        normalize: !!sourceDesc[semantic].normalize
	      });
	    }
	  }

	  var elementOrder = [SEMANTIC_POSITION, SEMANTIC_NORMAL, SEMANTIC_TANGENT, SEMANTIC_COLOR, SEMANTIC_BLENDINDICES, SEMANTIC_BLENDWEIGHT, SEMANTIC_TEXCOORD0, SEMANTIC_TEXCOORD1];
	  vertexDesc.sort(function (lhs, rhs) {
	    var lhsOrder = elementOrder.indexOf(lhs.semantic);
	    var rhsOrder = elementOrder.indexOf(rhs.semantic);
	    return lhsOrder < rhsOrder ? -1 : rhsOrder < lhsOrder ? 1 : 0;
	  });
	  var i, j, k;
	  var source, target, sourceOffset;
	  var vertexFormat = new VertexFormat(device, vertexDesc);
	  var isCorrectlyInterleaved = true;

	  for (i = 0; i < vertexFormat.elements.length; ++i) {
	    target = vertexFormat.elements[i];
	    source = sourceDesc[target.name];
	    sourceOffset = source.offset - positionDesc.offset;

	    if (source.buffer !== positionDesc.buffer || source.stride !== target.stride || source.size !== target.size || sourceOffset !== target.offset) {
	      isCorrectlyInterleaved = false;
	      break;
	    }
	  }

	  var vertexBuffer = new VertexBuffer(device, vertexFormat, numVertices, BUFFER_STATIC);
	  var vertexData = vertexBuffer.lock();
	  var targetArray = new Uint32Array(vertexData);
	  var sourceArray;

	  if (isCorrectlyInterleaved) {
	    sourceArray = new Uint32Array(positionDesc.buffer, positionDesc.offset, numVertices * vertexBuffer.format.size / 4);
	    targetArray.set(sourceArray);
	  } else {
	    var targetStride, sourceStride;

	    for (i = 0; i < vertexBuffer.format.elements.length; ++i) {
	      target = vertexBuffer.format.elements[i];
	      targetStride = target.stride / 4;
	      source = sourceDesc[target.name];
	      sourceStride = source.stride / 4;
	      sourceArray = new Uint32Array(source.buffer, source.offset, (source.count - 1) * sourceStride + (source.size + 3) / 4);
	      var src = 0;
	      var dst = target.offset / 4;
	      var kend = Math.floor((source.size + 3) / 4);

	      for (j = 0; j < numVertices; ++j) {
	        for (k = 0; k < kend; ++k) {
	          targetArray[dst + k] = sourceArray[src + k];
	        }

	        src += sourceStride;
	        dst += targetStride;
	      }
	    }
	  }

	  if (flipV) {
	    flipTexCoordVs(vertexBuffer);
	  }

	  vertexBuffer.unlock();
	  return vertexBuffer;
	};

	var createVertexBuffer = function createVertexBuffer(device, attributes, indices, accessors, bufferViews, flipV, vertexBufferDict) {
	  var useAttributes = {};
	  var attribIds = [];

	  for (var attrib in attributes) {
	    if (attributes.hasOwnProperty(attrib) && gltfToEngineSemanticMap.hasOwnProperty(attrib)) {
	      useAttributes[attrib] = attributes[attrib];
	      attribIds.push(attrib + ':' + attributes[attrib]);
	    }
	  }

	  attribIds.sort();
	  var vbKey = attribIds.join();
	  var vb = vertexBufferDict[vbKey];

	  if (!vb) {
	    var sourceDesc = {};

	    for (var _attrib in useAttributes) {
	      var accessor = accessors[attributes[_attrib]];
	      var accessorData = getAccessorData(accessor, bufferViews);
	      var bufferView = bufferViews[accessor.bufferView];
	      var semantic = gltfToEngineSemanticMap[_attrib];
	      var size = getNumComponents(accessor.type) * getComponentSizeInBytes(accessor.componentType);
	      var stride = bufferView.hasOwnProperty('byteStride') ? bufferView.byteStride : size;
	      sourceDesc[semantic] = {
	        buffer: accessorData.buffer,
	        size: size,
	        offset: accessorData.byteOffset,
	        stride: stride,
	        count: accessor.count,
	        components: getNumComponents(accessor.type),
	        type: getComponentType(accessor.componentType),
	        normalize: accessor.normalized
	      };
	    }

	    if (!sourceDesc.hasOwnProperty(SEMANTIC_NORMAL)) {
	      generateNormals(sourceDesc, indices);
	    }

	    vb = createVertexBufferInternal(device, sourceDesc, flipV);
	    vertexBufferDict[vbKey] = vb;
	  }

	  return vb;
	};

	var createVertexBufferDraco = function createVertexBufferDraco(device, outputGeometry, extDraco, decoder, decoderModule, indices, flipV) {
	  var numPoints = outputGeometry.num_points();

	  var extractDracoAttributeInfo = function extractDracoAttributeInfo(uniqueId, semantic) {
	    var attribute = decoder.GetAttributeByUniqueId(outputGeometry, uniqueId);
	    var numValues = numPoints * attribute.num_components();
	    var dracoFormat = attribute.data_type();
	    var ptr, values, componentSizeInBytes, storageType;

	    switch (dracoFormat) {
	      case decoderModule.DT_UINT8:
	        storageType = TYPE_UINT8;
	        componentSizeInBytes = 1;
	        ptr = decoderModule._malloc(numValues * componentSizeInBytes);
	        decoder.GetAttributeDataArrayForAllPoints(outputGeometry, attribute, decoderModule.DT_UINT8, numValues * componentSizeInBytes, ptr);
	        values = new Uint8Array(decoderModule.HEAPU8.buffer, ptr, numValues).slice();
	        break;

	      case decoderModule.DT_UINT16:
	        storageType = TYPE_UINT16;
	        componentSizeInBytes = 2;
	        ptr = decoderModule._malloc(numValues * componentSizeInBytes);
	        decoder.GetAttributeDataArrayForAllPoints(outputGeometry, attribute, decoderModule.DT_UINT16, numValues * componentSizeInBytes, ptr);
	        values = new Uint16Array(decoderModule.HEAPU16.buffer, ptr, numValues).slice();
	        break;

	      case decoderModule.DT_FLOAT32:
	      default:
	        storageType = TYPE_FLOAT32;
	        componentSizeInBytes = 4;
	        ptr = decoderModule._malloc(numValues * componentSizeInBytes);
	        decoder.GetAttributeDataArrayForAllPoints(outputGeometry, attribute, decoderModule.DT_FLOAT32, numValues * componentSizeInBytes, ptr);
	        values = new Float32Array(decoderModule.HEAPF32.buffer, ptr, numValues).slice();
	        break;
	    }

	    decoderModule._free(ptr);

	    return {
	      values: values,
	      numComponents: attribute.num_components(),
	      componentSizeInBytes: componentSizeInBytes,
	      storageType: storageType,
	      normalized: semantic === SEMANTIC_COLOR && storageType === TYPE_UINT8 ? true : attribute.normalized()
	    };
	  };

	  var sourceDesc = {};
	  var attributes = extDraco.attributes;

	  for (var attrib in attributes) {
	    if (attributes.hasOwnProperty(attrib) && gltfToEngineSemanticMap.hasOwnProperty(attrib)) {
	      var semantic = gltfToEngineSemanticMap[attrib];
	      var attributeInfo = extractDracoAttributeInfo(attributes[attrib], semantic);
	      var size = attributeInfo.numComponents * attributeInfo.componentSizeInBytes;
	      sourceDesc[semantic] = {
	        values: attributeInfo.values,
	        buffer: attributeInfo.values.buffer,
	        size: size,
	        offset: 0,
	        stride: size,
	        count: numPoints,
	        components: attributeInfo.numComponents,
	        type: attributeInfo.storageType,
	        normalize: attributeInfo.normalized
	      };
	    }
	  }

	  if (!sourceDesc.hasOwnProperty(SEMANTIC_NORMAL)) {
	    generateNormals(sourceDesc, indices);
	  }

	  return createVertexBufferInternal(device, sourceDesc, flipV);
	};

	var createSkin = function createSkin(device, gltfSkin, accessors, bufferViews, nodes, glbSkins) {
	  var i, j, bindMatrix;
	  var joints = gltfSkin.joints;
	  var numJoints = joints.length;
	  var ibp = [];

	  if (gltfSkin.hasOwnProperty('inverseBindMatrices')) {
	    var inverseBindMatrices = gltfSkin.inverseBindMatrices;
	    var ibmData = getAccessorData(accessors[inverseBindMatrices], bufferViews, true);
	    var ibmValues = [];

	    for (i = 0; i < numJoints; i++) {
	      for (j = 0; j < 16; j++) {
	        ibmValues[j] = ibmData[i * 16 + j];
	      }

	      bindMatrix = new Mat4();
	      bindMatrix.set(ibmValues);
	      ibp.push(bindMatrix);
	    }
	  } else {
	    for (i = 0; i < numJoints; i++) {
	      bindMatrix = new Mat4();
	      ibp.push(bindMatrix);
	    }
	  }

	  var boneNames = [];

	  for (i = 0; i < numJoints; i++) {
	    boneNames[i] = nodes[joints[i]].name;
	  }

	  var key = boneNames.join('#');
	  var skin = glbSkins.get(key);

	  if (!skin) {
	    skin = new Skin(device, ibp, boneNames);
	    glbSkins.set(key, skin);
	  }

	  return skin;
	};

	var tempMat = new Mat4();
	var tempVec = new Vec3();

	var createMesh = function createMesh(device, gltfMesh, accessors, bufferViews, callback, flipV, vertexBufferDict, meshVariants, meshDefaultMaterials) {
	  var meshes = [];
	  gltfMesh.primitives.forEach(function (primitive) {
	    var primitiveType, vertexBuffer, numIndices;
	    var indices = null;
	    var canUseMorph = true;

	    if (primitive.hasOwnProperty('extensions')) {
	      var extensions = primitive.extensions;

	      if (extensions.hasOwnProperty('KHR_draco_mesh_compression')) {
	        var decoderModule = dracoDecoderInstance || getGlobalDracoDecoderModule();

	        if (decoderModule) {
	          var extDraco = extensions.KHR_draco_mesh_compression;

	          if (extDraco.hasOwnProperty('attributes')) {
	            var uint8Buffer = bufferViews[extDraco.bufferView];
	            var buffer = new decoderModule.DecoderBuffer();
	            buffer.Init(uint8Buffer, uint8Buffer.length);
	            var decoder = new decoderModule.Decoder();
	            var geometryType = decoder.GetEncodedGeometryType(buffer);
	            var outputGeometry, status;

	            switch (geometryType) {
	              case decoderModule.POINT_CLOUD:
	                primitiveType = PRIMITIVE_POINTS;
	                outputGeometry = new decoderModule.PointCloud();
	                status = decoder.DecodeBufferToPointCloud(buffer, outputGeometry);
	                break;

	              case decoderModule.TRIANGULAR_MESH:
	                primitiveType = PRIMITIVE_TRIANGLES;
	                outputGeometry = new decoderModule.Mesh();
	                status = decoder.DecodeBufferToMesh(buffer, outputGeometry);
	                break;

	              case decoderModule.INVALID_GEOMETRY_TYPE:
	            }

	            if (!status || !status.ok() || outputGeometry.ptr === 0) {
	              callback('Failed to decode draco compressed asset: ' + (status ? status.error_msg() : 'Mesh asset - invalid draco compressed geometry type: ' + geometryType));
	              return;
	            }

	            var numFaces = outputGeometry.num_faces();

	            if (geometryType === decoderModule.TRIANGULAR_MESH) {
	              var bit32 = outputGeometry.num_points() > 65535;
	              numIndices = numFaces * 3;
	              var dataSize = numIndices * (bit32 ? 4 : 2);

	              var ptr = decoderModule._malloc(dataSize);

	              if (bit32) {
	                decoder.GetTrianglesUInt32Array(outputGeometry, dataSize, ptr);
	                indices = new Uint32Array(decoderModule.HEAPU32.buffer, ptr, numIndices).slice();
	              } else {
	                decoder.GetTrianglesUInt16Array(outputGeometry, dataSize, ptr);
	                indices = new Uint16Array(decoderModule.HEAPU16.buffer, ptr, numIndices).slice();
	              }

	              decoderModule._free(ptr);
	            }

	            vertexBuffer = createVertexBufferDraco(device, outputGeometry, extDraco, decoder, decoderModule, indices, flipV);
	            decoderModule.destroy(outputGeometry);
	            decoderModule.destroy(decoder);
	            decoderModule.destroy(buffer);
	            canUseMorph = false;
	          }
	        }
	      }
	    }

	    if (!vertexBuffer) {
	      indices = primitive.hasOwnProperty('indices') ? getAccessorData(accessors[primitive.indices], bufferViews, true) : null;
	      vertexBuffer = createVertexBuffer(device, primitive.attributes, indices, accessors, bufferViews, flipV, vertexBufferDict);
	      primitiveType = getPrimitiveType(primitive);
	    }

	    var mesh = null;

	    if (vertexBuffer) {
	      mesh = new Mesh(device);
	      mesh.vertexBuffer = vertexBuffer;
	      mesh.primitive[0].type = primitiveType;
	      mesh.primitive[0].base = 0;
	      mesh.primitive[0].indexed = indices !== null;

	      if (indices !== null) {
	        var indexFormat;

	        if (indices instanceof Uint8Array) {
	          indexFormat = INDEXFORMAT_UINT8;
	        } else if (indices instanceof Uint16Array) {
	          indexFormat = INDEXFORMAT_UINT16;
	        } else {
	          indexFormat = INDEXFORMAT_UINT32;
	        }

	        if (indexFormat === INDEXFORMAT_UINT32 && !device.extUintElement) {
	          indexFormat = INDEXFORMAT_UINT16;
	          indices = new Uint16Array(indices);
	        }

	        var indexBuffer = new IndexBuffer(device, indexFormat, indices.length, BUFFER_STATIC, indices);
	        mesh.indexBuffer[0] = indexBuffer;
	        mesh.primitive[0].count = indices.length;
	      } else {
	        mesh.primitive[0].count = vertexBuffer.numVertices;
	      }

	      if (primitive.hasOwnProperty("extensions") && primitive.extensions.hasOwnProperty("KHR_materials_variants")) {
	        var variants = primitive.extensions.KHR_materials_variants;
	        var tempMapping = {};
	        variants.mappings.forEach(function (mapping) {
	          mapping.variants.forEach(function (variant) {
	            tempMapping[variant] = mapping.material;
	          });
	        });
	        meshVariants[mesh.id] = tempMapping;
	      }

	      meshDefaultMaterials[mesh.id] = primitive.material;
	      var accessor = accessors[primitive.attributes.POSITION];
	      mesh.aabb = getAccessorBoundingBox(accessor);

	      if (canUseMorph && primitive.hasOwnProperty('targets')) {
	        var targets = [];
	        primitive.targets.forEach(function (target, index) {
	          var options = {};

	          if (target.hasOwnProperty('POSITION')) {
	            accessor = accessors[target.POSITION];
	            options.deltaPositions = getAccessorDataFloat32(accessor, bufferViews);
	            options.deltaPositionsType = TYPE_FLOAT32;
	            options.aabb = getAccessorBoundingBox(accessor);
	          }

	          if (target.hasOwnProperty('NORMAL')) {
	            accessor = accessors[target.NORMAL];
	            options.deltaNormals = getAccessorDataFloat32(accessor, bufferViews);
	            options.deltaNormalsType = TYPE_FLOAT32;
	          }

	          if (gltfMesh.hasOwnProperty('extras') && gltfMesh.extras.hasOwnProperty('targetNames')) {
	            options.name = gltfMesh.extras.targetNames[index];
	          } else {
	            options.name = index.toString(10);
	          }

	          if (gltfMesh.hasOwnProperty('weights')) {
	            options.defaultWeight = gltfMesh.weights[index];
	          }

	          targets.push(new MorphTarget(options));
	        });
	        mesh.morph = new Morph(targets, device);
	      }
	    }

	    meshes.push(mesh);
	  });
	  return meshes;
	};

	var extractTextureTransform = function extractTextureTransform(source, material, maps) {
	  var _source$extensions;

	  var map;
	  var texCoord = source.texCoord;

	  if (texCoord) {
	    for (map = 0; map < maps.length; ++map) {
	      material[maps[map] + 'MapUv'] = texCoord;
	    }
	  }

	  var zeros = [0, 0];
	  var ones = [1, 1];
	  var textureTransform = (_source$extensions = source.extensions) == null ? void 0 : _source$extensions.KHR_texture_transform;

	  if (textureTransform) {
	    var offset = textureTransform.offset || zeros;
	    var scale = textureTransform.scale || ones;
	    var rotation = textureTransform.rotation ? -textureTransform.rotation * math.RAD_TO_DEG : 0;
	    var tilingVec = new Vec2(scale[0], scale[1]);
	    var offsetVec = new Vec2(offset[0], 1.0 - scale[1] - offset[1]);

	    for (map = 0; map < maps.length; ++map) {
	      material[maps[map] + "MapTiling"] = tilingVec;
	      material[maps[map] + "MapOffset"] = offsetVec;
	      material[maps[map] + "MapRotation"] = rotation;
	    }
	  }
	};

	var extensionPbrSpecGlossiness = function extensionPbrSpecGlossiness(data, material, textures) {
	  var color, texture;

	  if (data.hasOwnProperty('diffuseFactor')) {
	    color = data.diffuseFactor;
	    material.diffuse.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
	    material.opacity = color[3];
	  } else {
	    material.diffuse.set(1, 1, 1);
	    material.opacity = 1;
	  }

	  if (data.hasOwnProperty('diffuseTexture')) {
	    var diffuseTexture = data.diffuseTexture;
	    texture = textures[diffuseTexture.index];
	    material.diffuseMap = texture;
	    material.diffuseMapChannel = 'rgb';
	    material.opacityMap = texture;
	    material.opacityMapChannel = 'a';
	    extractTextureTransform(diffuseTexture, material, ['diffuse', 'opacity']);
	  }

	  material.useMetalness = false;

	  if (data.hasOwnProperty('specularFactor')) {
	    color = data.specularFactor;
	    material.specular.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
	  } else {
	    material.specular.set(1, 1, 1);
	  }

	  if (data.hasOwnProperty('glossinessFactor')) {
	    material.shininess = 100 * data.glossinessFactor;
	  } else {
	    material.shininess = 100;
	  }

	  if (data.hasOwnProperty('specularGlossinessTexture')) {
	    var specularGlossinessTexture = data.specularGlossinessTexture;
	    material.specularEncoding = 'srgb';
	    material.specularMap = material.glossMap = textures[specularGlossinessTexture.index];
	    material.specularMapChannel = 'rgb';
	    material.glossMapChannel = 'a';
	    extractTextureTransform(specularGlossinessTexture, material, ['gloss', 'metalness']);
	  }
	};

	var extensionClearCoat = function extensionClearCoat(data, material, textures) {
	  if (data.hasOwnProperty('clearcoatFactor')) {
	    material.clearCoat = data.clearcoatFactor * 0.25;
	  } else {
	    material.clearCoat = 0;
	  }

	  if (data.hasOwnProperty('clearcoatTexture')) {
	    var clearcoatTexture = data.clearcoatTexture;
	    material.clearCoatMap = textures[clearcoatTexture.index];
	    material.clearCoatMapChannel = 'r';
	    extractTextureTransform(clearcoatTexture, material, ['clearCoat']);
	  }

	  if (data.hasOwnProperty('clearcoatRoughnessFactor')) {
	    material.clearCoatGlossiness = data.clearcoatRoughnessFactor;
	  } else {
	    material.clearCoatGlossiness = 0;
	  }

	  if (data.hasOwnProperty('clearcoatRoughnessTexture')) {
	    var clearcoatRoughnessTexture = data.clearcoatRoughnessTexture;
	    material.clearCoatGlossMap = textures[clearcoatRoughnessTexture.index];
	    material.clearCoatGlossMapChannel = 'g';
	    extractTextureTransform(clearcoatRoughnessTexture, material, ['clearCoatGloss']);
	  }

	  if (data.hasOwnProperty('clearcoatNormalTexture')) {
	    var clearcoatNormalTexture = data.clearcoatNormalTexture;
	    material.clearCoatNormalMap = textures[clearcoatNormalTexture.index];
	    extractTextureTransform(clearcoatNormalTexture, material, ['clearCoatNormal']);

	    if (clearcoatNormalTexture.hasOwnProperty('scale')) {
	      material.clearCoatBumpiness = clearcoatNormalTexture.scale;
	    }
	  }

	  var clearCoatGlossChunk = "\n        #ifdef MAPFLOAT\n        uniform float material_clearCoatGlossiness;\n        #endif\n        \n        #ifdef MAPTEXTURE\n        uniform sampler2D texture_clearCoatGlossMap;\n        #endif\n        \n        void getClearCoatGlossiness() {\n            ccGlossiness = 1.0;\n        \n        #ifdef MAPFLOAT\n            ccGlossiness *= material_clearCoatGlossiness;\n        #endif\n        \n        #ifdef MAPTEXTURE\n            ccGlossiness *= texture2DBias(texture_clearCoatGlossMap, $UV, textureBias).$CH;\n        #endif\n        \n        #ifdef MAPVERTEX\n            ccGlossiness *= saturate(vVertexColor.$VC);\n        #endif\n        \n            ccGlossiness = 1.0 - ccGlossiness;\n        \n            ccGlossiness += 0.0000001;\n        }\n        ";
	  material.chunks.clearCoatGlossPS = clearCoatGlossChunk;
	};

	var extensionUnlit = function extensionUnlit(data, material, textures) {
	  material.useLighting = false;
	  material.emissive.copy(material.diffuse);
	  material.emissiveTint = material.diffuseTint;
	  material.emissiveMap = material.diffuseMap;
	  material.emissiveMapUv = material.diffuseMapUv;
	  material.emissiveMapTiling.copy(material.diffuseMapTiling);
	  material.emissiveMapOffset.copy(material.diffuseMapOffset);
	  material.emissiveMapRotation = material.diffuseMapRotation;
	  material.emissiveMapChannel = material.diffuseMapChannel;
	  material.emissiveVertexColor = material.diffuseVertexColor;
	  material.emissiveVertexColorChannel = material.diffuseVertexColorChannel;
	  material.diffuse.set(0, 0, 0);
	  material.diffuseTint = false;
	  material.diffuseMap = null;
	  material.diffuseVertexColor = false;
	};

	var extensionSpecular = function extensionSpecular(data, material, textures) {
	  material.useMetalnessSpecularColor = true;

	  if (data.hasOwnProperty('specularColorTexture')) {
	    material.specularEncoding = 'srgb';
	    material.specularMap = textures[data.specularColorTexture.index];
	    material.specularMapChannel = 'rgb';
	    extractTextureTransform(data.specularColorTexture, material, ['specular']);
	  }

	  if (data.hasOwnProperty('specularColorFactor')) {
	    var color = data.specularColorFactor;
	    material.specular.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
	  } else {
	    material.specular.set(1, 1, 1);
	  }

	  if (data.hasOwnProperty('specularFactor')) {
	    material.specularityFactor = data.specularFactor;
	  } else {
	    material.specularityFactor = 1;
	  }

	  if (data.hasOwnProperty('specularTexture')) {
	    material.specularityFactorMapChannel = 'a';
	    material.specularityFactorMap = textures[data.specularTexture.index];
	    extractTextureTransform(data.specularTexture, material, ['specularityFactor']);
	  }
	};

	var extensionIor = function extensionIor(data, material, textures) {
	  if (data.hasOwnProperty('ior')) {
	    material.refractionIndex = 1.0 / data.ior;
	  }
	};

	var extensionTransmission = function extensionTransmission(data, material, textures) {
	  material.blendType = BLEND_NORMAL;
	  material.useDynamicRefraction = true;

	  if (data.hasOwnProperty('transmissionFactor')) {
	    material.refraction = data.transmissionFactor;
	  }

	  if (data.hasOwnProperty('transmissionTexture')) {
	    material.refractionMapChannel = 'r';
	    material.refractionMap = textures[data.transmissionTexture.index];
	    extractTextureTransform(data.transmissionTexture, material, ['refraction']);
	  }
	};

	var extensionSheen = function extensionSheen(data, material, textures) {
	  material.useSheen = true;

	  if (data.hasOwnProperty('sheenColorFactor')) {
	    var color = data.sheenColorFactor;
	    material.sheen.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
	  } else {
	    material.sheen.set(1, 1, 1);
	  }

	  if (data.hasOwnProperty('sheenColorTexture')) {
	    material.sheenMap = textures[data.sheenColorTexture.index];
	    extractTextureTransform(data.sheenColorTexture, material, ['sheen']);
	  }

	  if (data.hasOwnProperty('sheenRoughnessFactor')) {
	    material.sheenGlossiness = data.sheenRoughnessFactor;
	  } else {
	    material.sheenGlossiness = 0.0;
	  }

	  if (data.hasOwnProperty('sheenRoughnessTexture')) {
	    material.sheenGlossinessMap = textures[data.sheenRoughnessTexture.index];
	    material.sheenGlossinessMapChannel = 'a';
	    extractTextureTransform(data.sheenRoughnessTexture, material, ['sheenGlossiness']);
	  }

	  var sheenGlossChunk = "\n    #ifdef MAPFLOAT\n    uniform float material_sheenGlossiness;\n    #endif\n\n    #ifdef MAPTEXTURE\n    uniform sampler2D texture_sheenGlossinessMap;\n    #endif\n\n    void getSheenGlossiness() {\n        float sheenGlossiness = 1.0;\n\n        #ifdef MAPFLOAT\n        sheenGlossiness *= material_sheenGlossiness;\n        #endif\n\n        #ifdef MAPTEXTURE\n        sheenGlossiness *= texture2DBias(texture_sheenGlossinessMap, $UV, textureBias).$CH;\n        #endif\n\n        #ifdef MAPVERTEX\n        sheenGlossiness *= saturate(vVertexColor.$VC);\n        #endif\n\n        sheenGlossiness = 1.0 - sheenGlossiness;\n        sheenGlossiness += 0.0000001;\n        sGlossiness = sheenGlossiness;\n    }\n    ";
	  material.chunks.sheenGlossPS = sheenGlossChunk;
	};

	var extensionVolume = function extensionVolume(data, material, textures) {
	  material.blendType = BLEND_NORMAL;
	  material.useDynamicRefraction = true;

	  if (data.hasOwnProperty('thicknessFactor')) {
	    material.thickness = data.thicknessFactor;
	  }

	  if (data.hasOwnProperty('thicknessTexture')) {
	    material.thicknessMap = textures[data.thicknessTexture.index];
	    extractTextureTransform(data.thicknessTexture, material, ['thickness']);
	  }

	  if (data.hasOwnProperty('attenuationDistance')) {
	    material.attenuationDistance = data.attenuationDistance;
	  }

	  if (data.hasOwnProperty('attenuationColor')) {
	    var color = data.attenuationColor;
	    material.attenuation.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
	  }
	};

	var extensionEmissiveStrength = function extensionEmissiveStrength(data, material, textures) {
	  if (data.hasOwnProperty('emissiveStrength')) {
	    material.emissiveIntensity = data.emissiveStrength;
	  }
	};

	var createMaterial = function createMaterial(gltfMaterial, textures, flipV) {
	  var glossChunk = "\n        #ifdef MAPFLOAT\n        uniform float material_shininess;\n        #endif\n        \n        #ifdef MAPTEXTURE\n        uniform sampler2D texture_glossMap;\n        #endif\n        \n        void getGlossiness() {\n            dGlossiness = 1.0;\n        \n        #ifdef MAPFLOAT\n            dGlossiness *= material_shininess;\n        #endif\n        \n        #ifdef MAPTEXTURE\n            dGlossiness *= texture2DBias(texture_glossMap, $UV, textureBias).$CH;\n        #endif\n        \n        #ifdef MAPVERTEX\n            dGlossiness *= saturate(vVertexColor.$VC);\n        #endif\n        \n            dGlossiness = 1.0 - dGlossiness;\n        \n            dGlossiness += 0.0000001;\n        }\n        ";
	  var material = new StandardMaterial();
	  material.occludeSpecular = SPECOCC_AO;
	  material.diffuseTint = true;
	  material.diffuseVertexColor = true;
	  material.specularTint = true;
	  material.specularVertexColor = true;

	  if (gltfMaterial.hasOwnProperty('name')) {
	    material.name = gltfMaterial.name;
	  }

	  var color, texture;

	  if (gltfMaterial.hasOwnProperty('pbrMetallicRoughness')) {
	    var pbrData = gltfMaterial.pbrMetallicRoughness;

	    if (pbrData.hasOwnProperty('baseColorFactor')) {
	      color = pbrData.baseColorFactor;
	      material.diffuse.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
	      material.opacity = color[3];
	    } else {
	      material.diffuse.set(1, 1, 1);
	      material.opacity = 1;
	    }

	    if (pbrData.hasOwnProperty('baseColorTexture')) {
	      var baseColorTexture = pbrData.baseColorTexture;
	      texture = textures[baseColorTexture.index];
	      material.diffuseMap = texture;
	      material.diffuseMapChannel = 'rgb';
	      material.opacityMap = texture;
	      material.opacityMapChannel = 'a';
	      extractTextureTransform(baseColorTexture, material, ['diffuse', 'opacity']);
	    }

	    material.useMetalness = true;
	    material.specular.set(1, 1, 1);

	    if (pbrData.hasOwnProperty('metallicFactor')) {
	      material.metalness = pbrData.metallicFactor;
	    } else {
	      material.metalness = 1;
	    }

	    if (pbrData.hasOwnProperty('roughnessFactor')) {
	      material.shininess = 100 * pbrData.roughnessFactor;
	    } else {
	      material.shininess = 100;
	    }

	    if (pbrData.hasOwnProperty('metallicRoughnessTexture')) {
	      var metallicRoughnessTexture = pbrData.metallicRoughnessTexture;
	      material.metalnessMap = material.glossMap = textures[metallicRoughnessTexture.index];
	      material.metalnessMapChannel = 'b';
	      material.glossMapChannel = 'g';
	      extractTextureTransform(metallicRoughnessTexture, material, ['gloss', 'metalness']);
	    }

	    material.chunks.glossPS = glossChunk;
	  }

	  if (gltfMaterial.hasOwnProperty('normalTexture')) {
	    var normalTexture = gltfMaterial.normalTexture;
	    material.normalMap = textures[normalTexture.index];
	    extractTextureTransform(normalTexture, material, ['normal']);

	    if (normalTexture.hasOwnProperty('scale')) {
	      material.bumpiness = normalTexture.scale;
	    }
	  }

	  if (gltfMaterial.hasOwnProperty('occlusionTexture')) {
	    var occlusionTexture = gltfMaterial.occlusionTexture;
	    material.aoMap = textures[occlusionTexture.index];
	    material.aoMapChannel = 'r';
	    extractTextureTransform(occlusionTexture, material, ['ao']);
	  }

	  if (gltfMaterial.hasOwnProperty('emissiveFactor')) {
	    color = gltfMaterial.emissiveFactor;
	    material.emissive.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
	    material.emissiveTint = true;
	  } else {
	    material.emissive.set(0, 0, 0);
	    material.emissiveTint = false;
	  }

	  if (gltfMaterial.hasOwnProperty('emissiveTexture')) {
	    var emissiveTexture = gltfMaterial.emissiveTexture;
	    material.emissiveMap = textures[emissiveTexture.index];
	    extractTextureTransform(emissiveTexture, material, ['emissive']);
	  }

	  if (gltfMaterial.hasOwnProperty('alphaMode')) {
	    switch (gltfMaterial.alphaMode) {
	      case 'MASK':
	        material.blendType = BLEND_NONE;

	        if (gltfMaterial.hasOwnProperty('alphaCutoff')) {
	          material.alphaTest = gltfMaterial.alphaCutoff;
	        } else {
	          material.alphaTest = 0.5;
	        }

	        break;

	      case 'BLEND':
	        material.blendType = BLEND_NORMAL;
	        material.depthWrite = false;
	        break;

	      default:
	      case 'OPAQUE':
	        material.blendType = BLEND_NONE;
	        break;
	    }
	  } else {
	    material.blendType = BLEND_NONE;
	  }

	  if (gltfMaterial.hasOwnProperty('doubleSided')) {
	    material.twoSidedLighting = gltfMaterial.doubleSided;
	    material.cull = gltfMaterial.doubleSided ? CULLFACE_NONE : CULLFACE_BACK;
	  } else {
	    material.twoSidedLighting = false;
	    material.cull = CULLFACE_BACK;
	  }

	  var extensions = {
	    "KHR_materials_clearcoat": extensionClearCoat,
	    "KHR_materials_emissive_strength": extensionEmissiveStrength,
	    "KHR_materials_ior": extensionIor,
	    "KHR_materials_pbrSpecularGlossiness": extensionPbrSpecGlossiness,
	    "KHR_materials_sheen": extensionSheen,
	    "KHR_materials_specular": extensionSpecular,
	    "KHR_materials_transmission": extensionTransmission,
	    "KHR_materials_unlit": extensionUnlit,
	    "KHR_materials_volume": extensionVolume
	  };

	  if (gltfMaterial.hasOwnProperty('extensions')) {
	    for (var key in gltfMaterial.extensions) {
	      var extensionFunc = extensions[key];

	      if (extensionFunc !== undefined) {
	        extensionFunc(gltfMaterial.extensions[key], material, textures);
	      }
	    }
	  }

	  material.update();
	  return material;
	};

	var createAnimation = function createAnimation(gltfAnimation, animationIndex, gltfAccessors, bufferViews, nodes, meshes) {
	  var createAnimData = function createAnimData(gltfAccessor) {
	    return new AnimData(getNumComponents(gltfAccessor.type), getAccessorDataFloat32(gltfAccessor, bufferViews));
	  };

	  var interpMap = {
	    'STEP': INTERPOLATION_STEP,
	    'LINEAR': INTERPOLATION_LINEAR,
	    'CUBICSPLINE': INTERPOLATION_CUBIC
	  };
	  var inputMap = {};
	  var outputMap = {};
	  var curveMap = {};
	  var outputCounter = 1;
	  var i;

	  for (i = 0; i < gltfAnimation.samplers.length; ++i) {
	    var sampler = gltfAnimation.samplers[i];

	    if (!inputMap.hasOwnProperty(sampler.input)) {
	      inputMap[sampler.input] = createAnimData(gltfAccessors[sampler.input]);
	    }

	    if (!outputMap.hasOwnProperty(sampler.output)) {
	      outputMap[sampler.output] = createAnimData(gltfAccessors[sampler.output]);
	    }

	    var interpolation = sampler.hasOwnProperty('interpolation') && interpMap.hasOwnProperty(sampler.interpolation) ? interpMap[sampler.interpolation] : INTERPOLATION_LINEAR;
	    var curve = {
	      paths: [],
	      input: sampler.input,
	      output: sampler.output,
	      interpolation: interpolation
	    };
	    curveMap[i] = curve;
	  }

	  var quatArrays = [];
	  var transformSchema = {
	    'translation': 'localPosition',
	    'rotation': 'localRotation',
	    'scale': 'localScale'
	  };

	  var constructNodePath = function constructNodePath(node) {
	    var path = [];

	    while (node) {
	      path.unshift(node.name);
	      node = node.parent;
	    }

	    return path;
	  };

	  var retrieveWeightName = function retrieveWeightName(nodeName, weightIndex) {
	    if (!meshes) return weightIndex;

	    for (var _i2 = 0; _i2 < meshes.length; _i2++) {
	      var mesh = meshes[_i2];

	      if (mesh.name === nodeName && mesh.hasOwnProperty('extras') && mesh.extras.hasOwnProperty('targetNames') && mesh.extras.targetNames[weightIndex]) {
	        return "name." + mesh.extras.targetNames[weightIndex];
	      }
	    }

	    return weightIndex;
	  };

	  var createMorphTargetCurves = function createMorphTargetCurves(curve, node, entityPath) {
	    if (!outputMap[curve.output]) {
	      return;
	    }

	    var morphTargetCount = outputMap[curve.output].data.length / inputMap[curve.input].data.length;
	    var keyframeCount = outputMap[curve.output].data.length / morphTargetCount;

	    for (var j = 0; j < morphTargetCount; j++) {
	      var morphTargetOutput = new Float32Array(keyframeCount);

	      for (var k = 0; k < keyframeCount; k++) {
	        morphTargetOutput[k] = outputMap[curve.output].data[k * morphTargetCount + j];
	      }

	      var output = new AnimData(1, morphTargetOutput);
	      outputMap[-outputCounter] = output;
	      var morphCurve = {
	        paths: [{
	          entityPath: entityPath,
	          component: 'graph',
	          propertyPath: ["weight." + retrieveWeightName(node.name, j)]
	        }],
	        input: curve.input,
	        output: -outputCounter,
	        interpolation: curve.interpolation
	      };
	      outputCounter++;
	      curveMap["morphCurve-" + i + "-" + j] = morphCurve;
	    }
	  };

	  for (i = 0; i < gltfAnimation.channels.length; ++i) {
	    var channel = gltfAnimation.channels[i];
	    var target = channel.target;
	    var _curve = curveMap[channel.sampler];
	    var node = nodes[target.node];
	    var entityPath = constructNodePath(node);

	    if (target.path.startsWith('weights')) {
	      createMorphTargetCurves(_curve, node, entityPath);
	      delete curveMap[channel.sampler];
	      delete outputMap[_curve.output];
	    } else {
	      _curve.paths.push({
	        entityPath: entityPath,
	        component: 'graph',
	        propertyPath: [transformSchema[target.path]]
	      });
	    }
	  }

	  var inputs = [];
	  var outputs = [];
	  var curves = [];

	  for (var inputKey in inputMap) {
	    inputs.push(inputMap[inputKey]);
	    inputMap[inputKey] = inputs.length - 1;
	  }

	  for (var outputKey in outputMap) {
	    outputs.push(outputMap[outputKey]);
	    outputMap[outputKey] = outputs.length - 1;
	  }

	  for (var curveKey in curveMap) {
	    var curveData = curveMap[curveKey];
	    curves.push(new AnimCurve(curveData.paths, inputMap[curveData.input], outputMap[curveData.output], curveData.interpolation));

	    if (curveData.paths[0].propertyPath[0] === 'localRotation' && curveData.interpolation !== INTERPOLATION_CUBIC) {
	      quatArrays.push(curves[curves.length - 1].output);
	    }
	  }

	  quatArrays.sort();
	  var prevIndex = null;
	  var data;

	  for (i = 0; i < quatArrays.length; ++i) {
	    var index = quatArrays[i];

	    if (i === 0 || index !== prevIndex) {
	      data = outputs[index];

	      if (data.components === 4) {
	        var d = data.data;
	        var len = d.length - 4;

	        for (var j = 0; j < len; j += 4) {
	          var dp = d[j + 0] * d[j + 4] + d[j + 1] * d[j + 5] + d[j + 2] * d[j + 6] + d[j + 3] * d[j + 7];

	          if (dp < 0) {
	            d[j + 4] *= -1;
	            d[j + 5] *= -1;
	            d[j + 6] *= -1;
	            d[j + 7] *= -1;
	          }
	        }
	      }

	      prevIndex = index;
	    }
	  }

	  var duration = 0;

	  for (i = 0; i < inputs.length; i++) {
	    data = inputs[i]._data;
	    duration = Math.max(duration, data.length === 0 ? 0 : data[data.length - 1]);
	  }

	  return new AnimTrack(gltfAnimation.hasOwnProperty('name') ? gltfAnimation.name : 'animation_' + animationIndex, duration, inputs, outputs, curves);
	};

	var createNode = function createNode(gltfNode, nodeIndex) {
	  var entity = new GraphNode();

	  if (gltfNode.hasOwnProperty('name') && gltfNode.name.length > 0) {
	    entity.name = gltfNode.name;
	  } else {
	    entity.name = 'node_' + nodeIndex;
	  }

	  if (gltfNode.hasOwnProperty('matrix')) {
	    tempMat.data.set(gltfNode.matrix);
	    tempMat.getTranslation(tempVec);
	    entity.setLocalPosition(tempVec);
	    tempMat.getEulerAngles(tempVec);
	    entity.setLocalEulerAngles(tempVec);
	    tempMat.getScale(tempVec);
	    entity.setLocalScale(tempVec);
	  }

	  if (gltfNode.hasOwnProperty('rotation')) {
	    var r = gltfNode.rotation;
	    entity.setLocalRotation(r[0], r[1], r[2], r[3]);
	  }

	  if (gltfNode.hasOwnProperty('translation')) {
	    var t = gltfNode.translation;
	    entity.setLocalPosition(t[0], t[1], t[2]);
	  }

	  if (gltfNode.hasOwnProperty('scale')) {
	    var s = gltfNode.scale;
	    entity.setLocalScale(s[0], s[1], s[2]);
	  }

	  return entity;
	};

	var createCamera = function createCamera(gltfCamera, node) {
	  var projection = gltfCamera.type === 'orthographic' ? PROJECTION_ORTHOGRAPHIC : PROJECTION_PERSPECTIVE;
	  var gltfProperties = projection === PROJECTION_ORTHOGRAPHIC ? gltfCamera.orthographic : gltfCamera.perspective;
	  var componentData = {
	    enabled: false,
	    projection: projection,
	    nearClip: gltfProperties.znear,
	    aspectRatioMode: ASPECT_AUTO
	  };

	  if (gltfProperties.zfar) {
	    componentData.farClip = gltfProperties.zfar;
	  }

	  if (projection === PROJECTION_ORTHOGRAPHIC) {
	    componentData.orthoHeight = 0.5 * gltfProperties.ymag;

	    if (gltfProperties.ymag) {
	      componentData.aspectRatioMode = ASPECT_MANUAL;
	      componentData.aspectRatio = gltfProperties.xmag / gltfProperties.ymag;
	    }
	  } else {
	    componentData.fov = gltfProperties.yfov * math.RAD_TO_DEG;

	    if (gltfProperties.aspectRatio) {
	      componentData.aspectRatioMode = ASPECT_MANUAL;
	      componentData.aspectRatio = gltfProperties.aspectRatio;
	    }
	  }

	  var cameraEntity = new Entity(gltfCamera.name);
	  cameraEntity.addComponent('camera', componentData);
	  return cameraEntity;
	};

	var createLight = function createLight(gltfLight, node) {
	  var lightProps = {
	    enabled: false,
	    type: gltfLight.type === 'point' ? 'omni' : gltfLight.type,
	    color: gltfLight.hasOwnProperty('color') ? new Color(gltfLight.color) : Color.WHITE,
	    range: gltfLight.hasOwnProperty('range') ? gltfLight.range : 9999,
	    falloffMode: LIGHTFALLOFF_INVERSESQUARED,
	    intensity: gltfLight.hasOwnProperty('intensity') ? math.clamp(gltfLight.intensity, 0, 2) : 1
	  };

	  if (gltfLight.hasOwnProperty('spot')) {
	    lightProps.innerConeAngle = gltfLight.spot.hasOwnProperty('innerConeAngle') ? gltfLight.spot.innerConeAngle * math.RAD_TO_DEG : 0;
	    lightProps.outerConeAngle = gltfLight.spot.hasOwnProperty('outerConeAngle') ? gltfLight.spot.outerConeAngle * math.RAD_TO_DEG : Math.PI / 4;
	  }

	  var lightEntity = new Entity(node.name);
	  lightEntity.rotateLocal(90, 0, 0);
	  lightEntity.addComponent('light', lightProps);
	  return lightEntity;
	};

	var createSkins = function createSkins(device, gltf, nodes, bufferViews) {
	  if (!gltf.hasOwnProperty('skins') || gltf.skins.length === 0) {
	    return [];
	  }

	  var glbSkins = new Map();
	  return gltf.skins.map(function (gltfSkin) {
	    return createSkin(device, gltfSkin, gltf.accessors, bufferViews, nodes, glbSkins);
	  });
	};

	var createMeshes = function createMeshes(device, gltf, bufferViews, callback, flipV, meshVariants, meshDefaultMaterials) {
	  if (!gltf.hasOwnProperty('meshes') || gltf.meshes.length === 0 || !gltf.hasOwnProperty('accessors') || gltf.accessors.length === 0 || !gltf.hasOwnProperty('bufferViews') || gltf.bufferViews.length === 0) {
	    return [];
	  }

	  var vertexBufferDict = {};
	  return gltf.meshes.map(function (gltfMesh) {
	    return createMesh(device, gltfMesh, gltf.accessors, bufferViews, callback, flipV, vertexBufferDict, meshVariants, meshDefaultMaterials);
	  });
	};

	var createMaterials = function createMaterials(gltf, textures, options, flipV) {
	  if (!gltf.hasOwnProperty('materials') || gltf.materials.length === 0) {
	    return [];
	  }

	  var preprocess = options && options.material && options.material.preprocess;
	  var process = options && options.material && options.material.process || createMaterial;
	  var postprocess = options && options.material && options.material.postprocess;
	  return gltf.materials.map(function (gltfMaterial) {
	    if (preprocess) {
	      preprocess(gltfMaterial);
	    }

	    var material = process(gltfMaterial, textures, flipV);

	    if (postprocess) {
	      postprocess(gltfMaterial, material);
	    }

	    return material;
	  });
	};

	var createVariants = function createVariants(gltf) {
	  if (!gltf.hasOwnProperty("extensions") || !gltf.extensions.hasOwnProperty("KHR_materials_variants")) return null;
	  var data = gltf.extensions.KHR_materials_variants.variants;
	  var variants = {};

	  for (var i = 0; i < data.length; i++) {
	    variants[data[i].name] = i;
	  }

	  return variants;
	};

	var createAnimations = function createAnimations(gltf, nodes, bufferViews, options) {
	  if (!gltf.hasOwnProperty('animations') || gltf.animations.length === 0) {
	    return [];
	  }

	  var preprocess = options && options.animation && options.animation.preprocess;
	  var postprocess = options && options.animation && options.animation.postprocess;
	  return gltf.animations.map(function (gltfAnimation, index) {
	    if (preprocess) {
	      preprocess(gltfAnimation);
	    }

	    var animation = createAnimation(gltfAnimation, index, gltf.accessors, bufferViews, nodes, gltf.meshes);

	    if (postprocess) {
	      postprocess(gltfAnimation, animation);
	    }

	    return animation;
	  });
	};

	var createNodes = function createNodes(gltf, options) {
	  if (!gltf.hasOwnProperty('nodes') || gltf.nodes.length === 0) {
	    return [];
	  }

	  var preprocess = options && options.node && options.node.preprocess;
	  var process = options && options.node && options.node.process || createNode;
	  var postprocess = options && options.node && options.node.postprocess;
	  var nodes = gltf.nodes.map(function (gltfNode, index) {
	    if (preprocess) {
	      preprocess(gltfNode);
	    }

	    var node = process(gltfNode, index);

	    if (postprocess) {
	      postprocess(gltfNode, node);
	    }

	    return node;
	  });

	  for (var i = 0; i < gltf.nodes.length; ++i) {
	    var gltfNode = gltf.nodes[i];

	    if (gltfNode.hasOwnProperty('children')) {
	      var parent = nodes[i];
	      var uniqueNames = {};

	      for (var j = 0; j < gltfNode.children.length; ++j) {
	        var child = nodes[gltfNode.children[j]];

	        if (!child.parent) {
	          if (uniqueNames.hasOwnProperty(child.name)) {
	            child.name += uniqueNames[child.name]++;
	          } else {
	            uniqueNames[child.name] = 1;
	          }

	          parent.addChild(child);
	        }
	      }
	    }
	  }

	  return nodes;
	};

	var createScenes = function createScenes(gltf, nodes) {
	  var _gltf$scenes$0$nodes;

	  var scenes = [];
	  var count = gltf.scenes.length;

	  if (count === 1 && ((_gltf$scenes$0$nodes = gltf.scenes[0].nodes) == null ? void 0 : _gltf$scenes$0$nodes.length) === 1) {
	    var nodeIndex = gltf.scenes[0].nodes[0];
	    scenes.push(nodes[nodeIndex]);
	  } else {
	    for (var i = 0; i < count; i++) {
	      var scene = gltf.scenes[i];

	      if (scene.nodes) {
	        var sceneRoot = new GraphNode(scene.name);

	        for (var n = 0; n < scene.nodes.length; n++) {
	          var childNode = nodes[scene.nodes[n]];
	          sceneRoot.addChild(childNode);
	        }

	        scenes.push(sceneRoot);
	      }
	    }
	  }

	  return scenes;
	};

	var createCameras = function createCameras(gltf, nodes, options) {
	  var cameras = null;

	  if (gltf.hasOwnProperty('nodes') && gltf.hasOwnProperty('cameras') && gltf.cameras.length > 0) {
	    var preprocess = options && options.camera && options.camera.preprocess;
	    var process = options && options.camera && options.camera.process || createCamera;
	    var postprocess = options && options.camera && options.camera.postprocess;
	    gltf.nodes.forEach(function (gltfNode, nodeIndex) {
	      if (gltfNode.hasOwnProperty('camera')) {
	        var gltfCamera = gltf.cameras[gltfNode.camera];

	        if (gltfCamera) {
	          if (preprocess) {
	            preprocess(gltfCamera);
	          }

	          var camera = process(gltfCamera, nodes[nodeIndex]);

	          if (postprocess) {
	            postprocess(gltfCamera, camera);
	          }

	          if (camera) {
	            if (!cameras) cameras = new Map();
	            cameras.set(gltfNode, camera);
	          }
	        }
	      }
	    });
	  }

	  return cameras;
	};

	var createLights = function createLights(gltf, nodes, options) {
	  var lights = null;

	  if (gltf.hasOwnProperty('nodes') && gltf.hasOwnProperty('extensions') && gltf.extensions.hasOwnProperty('KHR_lights_punctual') && gltf.extensions.KHR_lights_punctual.hasOwnProperty('lights')) {
	    var gltfLights = gltf.extensions.KHR_lights_punctual.lights;

	    if (gltfLights.length) {
	      var preprocess = options && options.light && options.light.preprocess;
	      var process = options && options.light && options.light.process || createLight;
	      var postprocess = options && options.light && options.light.postprocess;
	      gltf.nodes.forEach(function (gltfNode, nodeIndex) {
	        if (gltfNode.hasOwnProperty('extensions') && gltfNode.extensions.hasOwnProperty('KHR_lights_punctual') && gltfNode.extensions.KHR_lights_punctual.hasOwnProperty('light')) {
	          var lightIndex = gltfNode.extensions.KHR_lights_punctual.light;
	          var gltfLight = gltfLights[lightIndex];

	          if (gltfLight) {
	            if (preprocess) {
	              preprocess(gltfLight);
	            }

	            var light = process(gltfLight, nodes[nodeIndex]);

	            if (postprocess) {
	              postprocess(gltfLight, light);
	            }

	            if (light) {
	              if (!lights) lights = new Map();
	              lights.set(gltfNode, light);
	            }
	          }
	        }
	      });
	    }
	  }

	  return lights;
	};

	var linkSkins = function linkSkins(gltf, renders, skins) {
	  gltf.nodes.forEach(function (gltfNode) {
	    if (gltfNode.hasOwnProperty('mesh') && gltfNode.hasOwnProperty('skin')) {
	      var meshGroup = renders[gltfNode.mesh].meshes;
	      meshGroup.forEach(function (mesh) {
	        mesh.skin = skins[gltfNode.skin];
	      });
	    }
	  });
	};

	var createResources = function createResources(device, gltf, bufferViews, textureAssets, options, callback) {
	  var preprocess = options && options.global && options.global.preprocess;
	  var postprocess = options && options.global && options.global.postprocess;

	  if (preprocess) {
	    preprocess(gltf);
	  }

	  var flipV = gltf.asset && gltf.asset.generator === 'PlayCanvas';

	  var nodes = createNodes(gltf, options);
	  var scenes = createScenes(gltf, nodes);
	  var lights = createLights(gltf, nodes, options);
	  var cameras = createCameras(gltf, nodes, options);
	  var animations = createAnimations(gltf, nodes, bufferViews, options);
	  var materials = createMaterials(gltf, textureAssets.map(function (textureAsset) {
	    return textureAsset.resource;
	  }), options, flipV);
	  var variants = createVariants(gltf);
	  var meshVariants = {};
	  var meshDefaultMaterials = {};
	  var meshes = createMeshes(device, gltf, bufferViews, callback, flipV, meshVariants, meshDefaultMaterials);
	  var skins = createSkins(device, gltf, nodes, bufferViews);
	  var renders = [];

	  for (var i = 0; i < meshes.length; i++) {
	    renders[i] = new Render();
	    renders[i].meshes = meshes[i];
	  }

	  linkSkins(gltf, renders, skins);
	  var result = new GlbResources(gltf);
	  result.nodes = nodes;
	  result.scenes = scenes;
	  result.animations = animations;
	  result.textures = textureAssets;
	  result.materials = materials;
	  result.variants = variants;
	  result.meshVariants = meshVariants;
	  result.meshDefaultMaterials = meshDefaultMaterials;
	  result.renders = renders;
	  result.skins = skins;
	  result.lights = lights;
	  result.cameras = cameras;

	  if (postprocess) {
	    postprocess(gltf, result);
	  }

	  callback(null, result);
	};

	var applySampler = function applySampler(texture, gltfSampler) {
	  var getFilter = function getFilter(filter, defaultValue) {
	    switch (filter) {
	      case 9728:
	        return FILTER_NEAREST;

	      case 9729:
	        return FILTER_LINEAR;

	      case 9984:
	        return FILTER_NEAREST_MIPMAP_NEAREST;

	      case 9985:
	        return FILTER_LINEAR_MIPMAP_NEAREST;

	      case 9986:
	        return FILTER_NEAREST_MIPMAP_LINEAR;

	      case 9987:
	        return FILTER_LINEAR_MIPMAP_LINEAR;

	      default:
	        return defaultValue;
	    }
	  };

	  var getWrap = function getWrap(wrap, defaultValue) {
	    switch (wrap) {
	      case 33071:
	        return ADDRESS_CLAMP_TO_EDGE;

	      case 33648:
	        return ADDRESS_MIRRORED_REPEAT;

	      case 10497:
	        return ADDRESS_REPEAT;

	      default:
	        return defaultValue;
	    }
	  };

	  if (texture) {
	    gltfSampler = gltfSampler || {};
	    texture.minFilter = getFilter(gltfSampler.minFilter, FILTER_LINEAR_MIPMAP_LINEAR);
	    texture.magFilter = getFilter(gltfSampler.magFilter, FILTER_LINEAR);
	    texture.addressU = getWrap(gltfSampler.wrapS, ADDRESS_REPEAT);
	    texture.addressV = getWrap(gltfSampler.wrapT, ADDRESS_REPEAT);
	  }
	};

	var gltfTextureUniqueId = 0;

	var loadImageAsync = function loadImageAsync(gltfImage, index, bufferViews, urlBase, registry, options, callback) {
	  var preprocess = options && options.image && options.image.preprocess;

	  var processAsync = options && options.image && options.image.processAsync || function (gltfImage, callback) {
	    callback(null, null);
	  };

	  var postprocess = options && options.image && options.image.postprocess;

	  var onLoad = function onLoad(textureAsset) {
	    if (postprocess) {
	      postprocess(gltfImage, textureAsset);
	    }

	    callback(null, textureAsset);
	  };

	  var mimeTypeFileExtensions = {
	    'image/png': 'png',
	    'image/jpeg': 'jpg',
	    'image/basis': 'basis',
	    'image/ktx': 'ktx',
	    'image/ktx2': 'ktx2',
	    'image/vnd-ms.dds': 'dds'
	  };

	  var loadTexture = function loadTexture(url, bufferView, mimeType, options) {
	    var name = (gltfImage.name || 'gltf-texture') + '-' + gltfTextureUniqueId++;
	    var file = {
	      url: url || name
	    };

	    if (bufferView) {
	      file.contents = bufferView.slice(0).buffer;
	    }

	    if (mimeType) {
	      var extension = mimeTypeFileExtensions[mimeType];

	      if (extension) {
	        file.filename = file.url + '.' + extension;
	      }
	    }

	    var asset = new Asset(name, 'texture', file, null, options);
	    asset.on('load', onLoad);
	    asset.on('error', callback);
	    registry.add(asset);
	    registry.load(asset);
	  };

	  if (preprocess) {
	    preprocess(gltfImage);
	  }

	  processAsync(gltfImage, function (err, textureAsset) {
	    if (err) {
	      callback(err);
	    } else if (textureAsset) {
	      onLoad(textureAsset);
	    } else {
	      if (gltfImage.hasOwnProperty('uri')) {
	        if (isDataURI(gltfImage.uri)) {
	          loadTexture(gltfImage.uri, null, getDataURIMimeType(gltfImage.uri), null);
	        } else {
	          loadTexture(path.join(urlBase, gltfImage.uri), null, null, {
	            crossOrigin: 'anonymous'
	          });
	        }
	      } else if (gltfImage.hasOwnProperty('bufferView') && gltfImage.hasOwnProperty('mimeType')) {
	        loadTexture(null, bufferViews[gltfImage.bufferView], gltfImage.mimeType, null);
	      } else {
	        callback('Invalid image found in gltf (neither uri or bufferView found). index=' + index);
	      }
	    }
	  });
	};

	var loadTexturesAsync = function loadTexturesAsync(gltf, bufferViews, urlBase, registry, options, callback) {
	  if (!gltf.hasOwnProperty('images') || gltf.images.length === 0 || !gltf.hasOwnProperty('textures') || gltf.textures.length === 0) {
	    callback(null, []);
	    return;
	  }

	  var preprocess = options && options.texture && options.texture.preprocess;

	  var processAsync = options && options.texture && options.texture.processAsync || function (gltfTexture, gltfImages, callback) {
	    callback(null, null);
	  };

	  var postprocess = options && options.texture && options.texture.postprocess;
	  var assets = [];
	  var textures = [];
	  var remaining = gltf.textures.length;

	  var onLoad = function onLoad(textureIndex, imageIndex) {
	    if (!textures[imageIndex]) {
	      textures[imageIndex] = [];
	    }

	    textures[imageIndex].push(textureIndex);

	    if (--remaining === 0) {
	      var result = [];
	      textures.forEach(function (textureList, imageIndex) {
	        textureList.forEach(function (textureIndex, index) {
	          var textureAsset = index === 0 ? assets[imageIndex] : cloneTextureAsset(assets[imageIndex]);
	          applySampler(textureAsset.resource, (gltf.samplers || [])[gltf.textures[textureIndex].sampler]);
	          result[textureIndex] = textureAsset;

	          if (postprocess) {
	            postprocess(gltf.textures[textureIndex], textureAsset);
	          }
	        });
	      });
	      callback(null, result);
	    }
	  };

	  for (var i = 0; i < gltf.textures.length; ++i) {
	    var gltfTexture = gltf.textures[i];

	    if (preprocess) {
	      preprocess(gltfTexture);
	    }

	    processAsync(gltfTexture, gltf.images, function (i, gltfTexture, err, gltfImageIndex) {
	      if (err) {
	        callback(err);
	      } else {
	        if (gltfImageIndex === undefined || gltfImageIndex === null) {
	          var _gltfTexture$extensio, _gltfTexture$extensio2;

	          gltfImageIndex = gltfTexture == null ? void 0 : (_gltfTexture$extensio = gltfTexture.extensions) == null ? void 0 : (_gltfTexture$extensio2 = _gltfTexture$extensio.KHR_texture_basisu) == null ? void 0 : _gltfTexture$extensio2.source;

	          if (gltfImageIndex === undefined) {
	            gltfImageIndex = gltfTexture.source;
	          }
	        }

	        if (assets[gltfImageIndex]) {
	          onLoad(i, gltfImageIndex);
	        } else {
	          var gltfImage = gltf.images[gltfImageIndex];
	          loadImageAsync(gltfImage, i, bufferViews, urlBase, registry, options, function (err, textureAsset) {
	            if (err) {
	              callback(err);
	            } else {
	              assets[gltfImageIndex] = textureAsset;
	              onLoad(i, gltfImageIndex);
	            }
	          });
	        }
	      }
	    }.bind(null, i, gltfTexture));
	  }
	};

	var loadBuffersAsync = function loadBuffersAsync(gltf, binaryChunk, urlBase, options, callback) {
	  var result = [];

	  if (!gltf.buffers || gltf.buffers.length === 0) {
	    callback(null, result);
	    return;
	  }

	  var preprocess = options && options.buffer && options.buffer.preprocess;

	  var processAsync = options && options.buffer && options.buffer.processAsync || function (gltfBuffer, callback) {
	    callback(null, null);
	  };

	  var postprocess = options && options.buffer && options.buffer.postprocess;
	  var remaining = gltf.buffers.length;

	  var onLoad = function onLoad(index, buffer) {
	    result[index] = buffer;

	    if (postprocess) {
	      postprocess(gltf.buffers[index], buffer);
	    }

	    if (--remaining === 0) {
	      callback(null, result);
	    }
	  };

	  for (var i = 0; i < gltf.buffers.length; ++i) {
	    var gltfBuffer = gltf.buffers[i];

	    if (preprocess) {
	      preprocess(gltfBuffer);
	    }

	    processAsync(gltfBuffer, function (i, gltfBuffer, err, arrayBuffer) {
	      if (err) {
	        callback(err);
	      } else if (arrayBuffer) {
	        onLoad(i, new Uint8Array(arrayBuffer));
	      } else {
	        if (gltfBuffer.hasOwnProperty('uri')) {
	          if (isDataURI(gltfBuffer.uri)) {
	            var byteString = atob(gltfBuffer.uri.split(',')[1]);
	            var binaryArray = new Uint8Array(byteString.length);

	            for (var j = 0; j < byteString.length; j++) {
	              binaryArray[j] = byteString.charCodeAt(j);
	            }

	            onLoad(i, binaryArray);
	          } else {
	            http.get(path.join(urlBase, gltfBuffer.uri), {
	              cache: true,
	              responseType: 'arraybuffer',
	              retry: false
	            }, function (i, err, result) {
	              if (err) {
	                callback(err);
	              } else {
	                onLoad(i, new Uint8Array(result));
	              }
	            }.bind(null, i));
	          }
	        } else {
	          onLoad(i, binaryChunk);
	        }
	      }
	    }.bind(null, i, gltfBuffer));
	  }
	};

	var parseGltf = function parseGltf(gltfChunk, callback) {
	  var decodeBinaryUtf8 = function decodeBinaryUtf8(array) {
	    if (typeof TextDecoder !== 'undefined') {
	      return new TextDecoder().decode(array);
	    }

	    var str = '';

	    for (var i = 0; i < array.length; i++) {
	      str += String.fromCharCode(array[i]);
	    }

	    return decodeURIComponent(escape(str));
	  };

	  var gltf = JSON.parse(decodeBinaryUtf8(gltfChunk));

	  if (gltf.asset && gltf.asset.version && parseFloat(gltf.asset.version) < 2) {
	    callback("Invalid gltf version. Expected version 2.0 or above but found version '" + gltf.asset.version + "'.");
	    return;
	  }

	  var extensionsRequired = (gltf == null ? void 0 : gltf.extensionsRequired) || [];

	  if (!dracoDecoderInstance && !getGlobalDracoDecoderModule() && extensionsRequired.indexOf('KHR_draco_mesh_compression') !== -1) {
	    WasmModule.getInstance('DracoDecoderModule', function (instance) {
	      dracoDecoderInstance = instance;
	      callback(null, gltf);
	    });
	  } else {
	    callback(null, gltf);
	  }
	};

	var parseGlb = function parseGlb(glbData, callback) {
	  var data = glbData instanceof ArrayBuffer ? new DataView(glbData) : new DataView(glbData.buffer, glbData.byteOffset, glbData.byteLength);
	  var magic = data.getUint32(0, true);
	  var version = data.getUint32(4, true);
	  var length = data.getUint32(8, true);

	  if (magic !== 0x46546C67) {
	    callback('Invalid magic number found in glb header. Expected 0x46546C67, found 0x' + magic.toString(16));
	    return;
	  }

	  if (version !== 2) {
	    callback('Invalid version number found in glb header. Expected 2, found ' + version);
	    return;
	  }

	  if (length <= 0 || length > data.byteLength) {
	    callback('Invalid length found in glb header. Found ' + length);
	    return;
	  }

	  var chunks = [];
	  var offset = 12;

	  while (offset < length) {
	    var chunkLength = data.getUint32(offset, true);

	    if (offset + chunkLength + 8 > data.byteLength) {
	      throw new Error('Invalid chunk length found in glb. Found ' + chunkLength);
	    }

	    var chunkType = data.getUint32(offset + 4, true);
	    var chunkData = new Uint8Array(data.buffer, data.byteOffset + offset + 8, chunkLength);
	    chunks.push({
	      length: chunkLength,
	      type: chunkType,
	      data: chunkData
	    });
	    offset += chunkLength + 8;
	  }

	  if (chunks.length !== 1 && chunks.length !== 2) {
	    callback('Invalid number of chunks found in glb file.');
	    return;
	  }

	  if (chunks[0].type !== 0x4E4F534A) {
	    callback('Invalid chunk type found in glb file. Expected 0x4E4F534A, found 0x' + chunks[0].type.toString(16));
	    return;
	  }

	  if (chunks.length > 1 && chunks[1].type !== 0x004E4942) {
	    callback('Invalid chunk type found in glb file. Expected 0x004E4942, found 0x' + chunks[1].type.toString(16));
	    return;
	  }

	  callback(null, {
	    gltfChunk: chunks[0].data,
	    binaryChunk: chunks.length === 2 ? chunks[1].data : null
	  });
	};

	var parseChunk = function parseChunk(filename, data, callback) {
	  if (filename && filename.toLowerCase().endsWith('.glb')) {
	    parseGlb(data, callback);
	  } else {
	    callback(null, {
	      gltfChunk: data,
	      binaryChunk: null
	    });
	  }
	};

	var parseBufferViewsAsync = function parseBufferViewsAsync(gltf, buffers, options, callback) {
	  var result = [];
	  var preprocess = options && options.bufferView && options.bufferView.preprocess;

	  var processAsync = options && options.bufferView && options.bufferView.processAsync || function (gltfBufferView, buffers, callback) {
	    callback(null, null);
	  };

	  var postprocess = options && options.bufferView && options.bufferView.postprocess;
	  var remaining = gltf.bufferViews ? gltf.bufferViews.length : 0;

	  if (!remaining) {
	    callback(null, null);
	    return;
	  }

	  var onLoad = function onLoad(index, bufferView) {
	    var gltfBufferView = gltf.bufferViews[index];

	    if (gltfBufferView.hasOwnProperty('byteStride')) {
	      bufferView.byteStride = gltfBufferView.byteStride;
	    }

	    result[index] = bufferView;

	    if (postprocess) {
	      postprocess(gltfBufferView, bufferView);
	    }

	    if (--remaining === 0) {
	      callback(null, result);
	    }
	  };

	  for (var i = 0; i < gltf.bufferViews.length; ++i) {
	    var gltfBufferView = gltf.bufferViews[i];

	    if (preprocess) {
	      preprocess(gltfBufferView);
	    }

	    processAsync(gltfBufferView, buffers, function (i, gltfBufferView, err, result) {
	      if (err) {
	        callback(err);
	      } else if (result) {
	        onLoad(i, result);
	      } else {
	        var buffer = buffers[gltfBufferView.buffer];
	        var typedArray = new Uint8Array(buffer.buffer, buffer.byteOffset + (gltfBufferView.byteOffset || 0), gltfBufferView.byteLength);
	        onLoad(i, typedArray);
	      }
	    }.bind(null, i, gltfBufferView));
	  }
	};

	var GlbParser = function () {
	  GlbParser.parseAsync = function parseAsync(filename, urlBase, data, device, registry, options, callback) {
	    parseChunk(filename, data, function (err, chunks) {
	      if (err) {
	        callback(err);
	        return;
	      }

	      parseGltf(chunks.gltfChunk, function (err, gltf) {
	        if (err) {
	          callback(err);
	          return;
	        }

	        loadBuffersAsync(gltf, chunks.binaryChunk, urlBase, options, function (err, buffers) {
	          if (err) {
	            callback(err);
	            return;
	          }

	          parseBufferViewsAsync(gltf, buffers, options, function (err, bufferViews) {
	            if (err) {
	              callback(err);
	              return;
	            }

	            loadTexturesAsync(gltf, bufferViews, urlBase, registry, options, function (err, textureAssets) {
	              if (err) {
	                callback(err);
	                return;
	              }

	              createResources(device, gltf, bufferViews, textureAssets, options, callback);
	            });
	          });
	        });
	      });
	    });
	  };

	  GlbParser.parse = function parse(filename, data, device, options) {
	    var result = null;
	    options = options || {};
	    parseChunk(filename, data, function (err, chunks) {
	      if (err) {
	        console.error(err);
	      } else {
	        parseGltf(chunks.gltfChunk, function (err, gltf) {
	          if (err) {
	            console.error(err);
	          } else {
	            parseBufferViewsAsync(gltf, [chunks.binaryChunk], options, function (err, bufferViews) {
	              if (err) {
	                console.error(err);
	              } else {
	                createResources(device, gltf, bufferViews, [], options, function (err, result_) {
	                  if (err) {
	                    console.error(err);
	                  } else {
	                    result = result_;
	                  }
	                });
	              }
	            });
	          }
	        });
	      }
	    });
	    return result;
	  };

	  function GlbParser(device, assets, maxRetries) {
	    this._device = device;
	    this._assets = assets;
	    this._defaultMaterial = createMaterial({
	      name: 'defaultGlbMaterial'
	    }, []);
	    this.maxRetries = maxRetries;
	  }

	  var _proto2 = GlbParser.prototype;

	  _proto2._getUrlWithoutParams = function _getUrlWithoutParams(url) {
	    return url.indexOf('?') >= 0 ? url.split('?')[0] : url;
	  };

	  _proto2.load = function load(url, callback, asset) {
	    var _this = this;

	    Asset.fetchArrayBuffer(url.load, function (err, result) {
	      if (err) {
	        callback(err);
	      } else {
	        GlbParser.parseAsync(_this._getUrlWithoutParams(url.original), path.extractPath(url.load), result, _this._device, asset.registry, asset.options, function (err, result) {
	          if (err) {
	            callback(err);
	          } else {
	            callback(null, new GlbContainerResource(result, asset, _this._assets, _this._defaultMaterial));
	          }
	        });
	      }
	    }, asset, this.maxRetries);
	  };

	  _proto2.open = function open(url, data, asset) {
	    return data;
	  };

	  _proto2.patch = function patch(asset, assets) {};

	  return GlbParser;
	}();

	var AnimationHandler = function () {
	  function AnimationHandler(app) {
	    this.handlerType = "animation";
	    this.maxRetries = 0;
	  }

	  var _proto = AnimationHandler.prototype;

	  _proto.load = function load(url, callback) {
	    if (typeof url === 'string') {
	      url = {
	        load: url,
	        original: url
	      };
	    }

	    var options = {
	      retry: this.maxRetries > 0,
	      maxRetries: this.maxRetries
	    };

	    if (url.load.startsWith('blob:') || url.load.startsWith('data:')) {
	      if (path.getExtension(url.original).toLowerCase() === '.glb') {
	        options.responseType = Http.ResponseType.ARRAY_BUFFER;
	      } else {
	        options.responseType = Http.ResponseType.JSON;
	      }
	    }

	    http.get(url.load, options, function (err, response) {
	      if (err) {
	        callback("Error loading animation resource: " + url.original + " [" + err + "]");
	      } else {
	        callback(null, response);
	      }
	    });
	  };

	  _proto.open = function open(url, data, asset) {
	    if (path.getExtension(url).toLowerCase() === '.glb') {
	      var glbResources = GlbParser.parse('filename.glb', data, null);

	      if (glbResources) {
	        var _asset$data;

	        var animations = glbResources.animations;

	        if (asset != null && (_asset$data = asset.data) != null && _asset$data.events) {
	          for (var i = 0; i < animations.length; i++) {
	            animations[i].events = new AnimEvents(Object.values(asset.data.events));
	          }
	        }

	        glbResources.destroy();
	        return animations;
	      }

	      return null;
	    }

	    return this['_parseAnimationV' + data.animation.version](data);
	  };

	  _proto.patch = function patch(asset, assets) {};

	  _proto._parseAnimationV3 = function _parseAnimationV3(data) {
	    var animData = data.animation;
	    var anim = new Animation();
	    anim.name = animData.name;
	    anim.duration = animData.duration;

	    for (var i = 0; i < animData.nodes.length; i++) {
	      var node = new Node();
	      var n = animData.nodes[i];
	      node._name = n.name;

	      for (var j = 0; j < n.keys.length; j++) {
	        var k = n.keys[j];
	        var t = k.time;
	        var p = k.pos;
	        var r = k.rot;
	        var s = k.scale;
	        var pos = new Vec3(p[0], p[1], p[2]);
	        var rot = new Quat().setFromEulerAngles(r[0], r[1], r[2]);
	        var scl = new Vec3(s[0], s[1], s[2]);
	        var key = new Key(t, pos, rot, scl);

	        node._keys.push(key);
	      }

	      anim.addNode(node);
	    }

	    return anim;
	  };

	  _proto._parseAnimationV4 = function _parseAnimationV4(data) {
	    var animData = data.animation;
	    var anim = new Animation();
	    anim.name = animData.name;
	    anim.duration = animData.duration;

	    for (var i = 0; i < animData.nodes.length; i++) {
	      var node = new Node();
	      var n = animData.nodes[i];
	      node._name = n.name;
	      var defPos = n.defaults.p;
	      var defRot = n.defaults.r;
	      var defScl = n.defaults.s;

	      for (var j = 0; j < n.keys.length; j++) {
	        var k = n.keys[j];
	        var t = k.t;
	        var p = defPos ? defPos : k.p;
	        var r = defRot ? defRot : k.r;
	        var s = defScl ? defScl : k.s;
	        var pos = new Vec3(p[0], p[1], p[2]);
	        var rot = new Quat().setFromEulerAngles(r[0], r[1], r[2]);
	        var scl = new Vec3(s[0], s[1], s[2]);
	        var key = new Key(t, pos, rot, scl);

	        node._keys.push(key);
	      }

	      anim.addNode(node);
	    }

	    return anim;
	  };

	  return AnimationHandler;
	}();

	var ie = function () {
	  if (typeof window === 'undefined') {
	    return false;
	  }

	  var ua = window.navigator.userAgent;
	  var msie = ua.indexOf('MSIE ');

	  if (msie > 0) {
	    return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
	  }

	  var trident = ua.indexOf('Trident/');

	  if (trident > 0) {
	    var rv = ua.indexOf('rv:');
	    return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
	  }

	  return false;
	}();

	var supportedExtensions = ['.ogg', '.mp3', '.wav', '.mp4a', '.m4a', '.mp4', '.aac', '.opus'];

	var AudioHandler = function () {
	  function AudioHandler(app) {
	    this.handlerType = "audio";
	    this.manager = app.soundManager;
	    this.maxRetries = 0;
	  }

	  var _proto = AudioHandler.prototype;

	  _proto._isSupported = function _isSupported(url) {
	    var ext = path.getExtension(url);
	    return supportedExtensions.indexOf(ext) > -1;
	  };

	  _proto.load = function load(url, callback) {
	    if (typeof url === 'string') {
	      url = {
	        load: url,
	        original: url
	      };
	    }

	    var success = function success(resource) {
	      callback(null, new Sound(resource));
	    };

	    var error = function error(err) {
	      var msg = 'Error loading audio url: ' + url.original;

	      if (err) {
	        msg += ': ' + (err.message || err);
	      }

	      console.warn(msg);
	      callback(msg);
	    };

	    if (this._createSound) {
	      if (!this._isSupported(url.original)) {
	        error("Audio format for " + url.original + " not supported");
	        return;
	      }

	      this._createSound(url.load, success, error);
	    } else {
	      error(null);
	    }
	  };

	  _proto.open = function open(url, data) {
	    return data;
	  };

	  _proto.patch = function patch(asset, assets) {};

	  _proto._createSound = function _createSound(url, success, error) {
	    if (hasAudioContext()) {
	      var manager = this.manager;

	      if (!manager.context) {
	        error('Audio manager has no audio context');
	        return;
	      }

	      var options = {
	        retry: this.maxRetries > 0,
	        maxRetries: this.maxRetries
	      };

	      if (url.startsWith('blob:') || url.startsWith('data:')) {
	        options.responseType = Http.ResponseType.ARRAY_BUFFER;
	      }

	      http.get(url, options, function (err, response) {
	        if (err) {
	          error(err);
	          return;
	        }

	        manager.context.decodeAudioData(response, success, error);
	      });
	    } else {
	      var audio = null;

	      try {
	        audio = new Audio();
	      } catch (e) {
	        error('No support for Audio element');
	        return;
	      }

	      if (ie) {
	        document.body.appendChild(audio);
	      }

	      var onReady = function onReady() {
	        audio.removeEventListener('canplaythrough', onReady);

	        if (ie) {
	          document.body.removeChild(audio);
	        }

	        success(audio);
	      };

	      audio.onerror = function () {
	        audio.onerror = null;

	        if (ie) {
	          document.body.removeChild(audio);
	        }

	        error();
	      };

	      audio.addEventListener('canplaythrough', onReady);
	      audio.src = url;
	    }
	  };

	  return AudioHandler;
	}();

	var BinaryHandler = function () {
	  function BinaryHandler(app) {
	    this.handlerType = "binary";
	    this.maxRetries = 0;
	  }

	  var _proto = BinaryHandler.prototype;

	  _proto.load = function load(url, callback) {
	    if (typeof url === 'string') {
	      url = {
	        load: url,
	        original: url
	      };
	    }

	    http.get(url.load, {
	      responseType: Http.ResponseType.ARRAY_BUFFER,
	      retry: this.maxRetries > 0,
	      maxRetries: this.maxRetries
	    }, function (err, response) {
	      if (!err) {
	        callback(null, response);
	      } else {
	        callback("Error loading binary resource: " + url.original + " [" + err + "]");
	      }
	    });
	  };

	  _proto.open = function open(url, data) {
	    return data;
	  };

	  _proto.patch = function patch(asset, assets) {};

	  return BinaryHandler;
	}();

	var ContainerResource = function () {
	  function ContainerResource() {}

	  var _proto = ContainerResource.prototype;

	  _proto.instantiateModelEntity = function instantiateModelEntity(options) {
	    return null;
	  };

	  _proto.instantiateRenderEntity = function instantiateRenderEntity(options) {
	    return null;
	  };

	  _proto.getMaterialVariants = function getMaterialVariants() {
	    return null;
	  };

	  _proto.applyMaterialVariant = function applyMaterialVariant(entity, name) {};

	  _proto.applyMaterialVariantInstances = function applyMaterialVariantInstances(instances, name) {};

	  return ContainerResource;
	}();

	var ContainerHandler = function () {
	  function ContainerHandler(app) {
	    this.handlerType = "container";
	    this.glbParser = new GlbParser(app.graphicsDevice, app.assets, 0);
	    this.parsers = {};
	  }

	  var _proto2 = ContainerHandler.prototype;

	  _proto2._getUrlWithoutParams = function _getUrlWithoutParams(url) {
	    return url.indexOf('?') >= 0 ? url.split('?')[0] : url;
	  };

	  _proto2._getParser = function _getParser(url) {
	    var ext = url ? path.getExtension(this._getUrlWithoutParams(url)).toLowerCase().replace('.', '') : null;
	    return this.parsers[ext] || this.glbParser;
	  };

	  _proto2.load = function load(url, callback, asset) {
	    if (typeof url === 'string') {
	      url = {
	        load: url,
	        original: url
	      };
	    }

	    this._getParser(url.original).load(url, callback, asset);
	  };

	  _proto2.open = function open(url, data, asset) {
	    return this._getParser(url).open(url, data, asset);
	  };

	  _proto2.patch = function patch(asset, assets) {};

	  _createClass(ContainerHandler, [{
	    key: "maxRetries",
	    get: function get() {
	      return this.glbParser.maxRetries;
	    },
	    set: function set(value) {
	      this.glbParser.maxRetries = value;

	      for (var parser in this.parsers) {
	        if (this.parsers.hasOwnProperty(parser)) {
	          this.parsers[parser].maxRetries = value;
	        }
	      }
	    }
	  }]);

	  return ContainerHandler;
	}();

	var CssHandler = function () {
	  function CssHandler(app) {
	    this.handlerType = "css";
	    this.maxRetries = 0;
	  }

	  var _proto = CssHandler.prototype;

	  _proto.load = function load(url, callback) {
	    if (typeof url === 'string') {
	      url = {
	        load: url,
	        original: url
	      };
	    }

	    http.get(url.load, {
	      retry: this.maxRetries > 0,
	      maxRetries: this.maxRetries
	    }, function (err, response) {
	      if (!err) {
	        callback(null, response);
	      } else {
	        callback("Error loading css resource: " + url.original + " [" + err + "]");
	      }
	    });
	  };

	  _proto.open = function open(url, data) {
	    return data;
	  };

	  _proto.patch = function patch(asset, assets) {};

	  return CssHandler;
	}();

	function createStyle(cssString) {
	  var result = document.createElement('style');
	  result.type = 'text/css';

	  if (result.styleSheet) {
	    result.styleSheet.cssText = cssString;
	  } else {
	    result.appendChild(document.createTextNode(cssString));
	  }

	  return result;
	}

	var CubemapHandler = function () {
	  function CubemapHandler(app) {
	    this.handlerType = "cubemap";
	    this._device = app.graphicsDevice;
	    this._registry = app.assets;
	    this._loader = app.loader;
	  }

	  var _proto = CubemapHandler.prototype;

	  _proto.load = function load(url, callback, asset) {
	    this.loadAssets(asset, callback);
	  };

	  _proto.open = function open(url, data, asset) {
	    return asset ? asset.resource : null;
	  };

	  _proto.patch = function patch(asset, registry) {
	    this.loadAssets(asset, function (err, result) {
	      if (err) {
	        registry.fire('error', asset);
	        registry.fire('error:' + asset.id, err, asset);
	        asset.fire('error', asset);
	      }
	    });
	  };

	  _proto.getAssetIds = function getAssetIds(cubemapAsset) {
	    var result = [];
	    result[0] = cubemapAsset.file;

	    if ((cubemapAsset.loadFaces || !cubemapAsset.file) && cubemapAsset.data && cubemapAsset.data.textures) {
	      for (var i = 0; i < 6; ++i) {
	        result[i + 1] = cubemapAsset.data.textures[i];
	      }
	    } else {
	      result[1] = result[2] = result[3] = result[4] = result[5] = result[6] = null;
	    }

	    return result;
	  };

	  _proto.compareAssetIds = function compareAssetIds(assetIdA, assetIdB) {
	    if (assetIdA && assetIdB) {
	      if (parseInt(assetIdA, 10) === assetIdA || typeof assetIdA === 'string') {
	        return assetIdA === assetIdB;
	      }

	      return assetIdA.url === assetIdB.url;
	    }

	    return assetIdA !== null === (assetIdB !== null);
	  };

	  _proto.update = function update(cubemapAsset, assetIds, assets) {
	    var assetData = cubemapAsset.data || {};
	    var oldAssets = cubemapAsset._handlerState.assets;
	    var oldResources = cubemapAsset._resources;
	    var tex, mip, i;
	    var resources = [null, null, null, null, null, null, null];

	    var getType = function getType() {
	      if (assetData.hasOwnProperty('type')) {
	        return assetData.type;
	      }

	      if (assetData.hasOwnProperty('rgbm')) {
	        return assetData.rgbm ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT;
	      }

	      return null;
	    };

	    if (!cubemapAsset.loaded || assets[0] !== oldAssets[0]) {
	      if (assets[0]) {
	        tex = assets[0].resource;

	        for (i = 0; i < 6; ++i) {
	          resources[i + 1] = new Texture(this._device, {
	            name: cubemapAsset.name + '_prelitCubemap' + (tex.width >> i),
	            cubemap: true,
	            type: getType() || tex.type,
	            width: tex.width >> i,
	            height: tex.height >> i,
	            format: tex.format,
	            levels: [tex._levels[i]],
	            fixCubemapSeams: true,
	            addressU: ADDRESS_CLAMP_TO_EDGE,
	            addressV: ADDRESS_CLAMP_TO_EDGE,
	            mipmaps: i === 0
	          });
	        }
	      }
	    } else {
	      resources[1] = oldResources[1] || null;
	      resources[2] = oldResources[2] || null;
	      resources[3] = oldResources[3] || null;
	      resources[4] = oldResources[4] || null;
	      resources[5] = oldResources[5] || null;
	      resources[6] = oldResources[6] || null;
	    }

	    var faceAssets = assets.slice(1);

	    if (!cubemapAsset.loaded || !this.cmpArrays(faceAssets, oldAssets.slice(1))) {
	      if (faceAssets.indexOf(null) === -1) {
	        var faceTextures = faceAssets.map(function (asset) {
	          return asset.resource;
	        });
	        var faceLevels = [];

	        for (mip = 0; mip < faceTextures[0]._levels.length; ++mip) {
	          faceLevels.push(faceTextures.map(function (faceTexture) {
	            return faceTexture._levels[mip];
	          }));
	        }

	        var format = faceTextures[0].format;
	        var faces = new Texture(this._device, {
	          name: cubemapAsset.name + '_faces',
	          cubemap: true,
	          type: getType() || faceTextures[0].type,
	          width: faceTextures[0].width,
	          height: faceTextures[0].height,
	          format: format === PIXELFORMAT_R8_G8_B8 ? PIXELFORMAT_R8_G8_B8_A8 : format,
	          levels: faceLevels,
	          minFilter: assetData.hasOwnProperty('minFilter') ? assetData.minFilter : faceTextures[0].minFilter,
	          magFilter: assetData.hasOwnProperty('magFilter') ? assetData.magFilter : faceTextures[0].magFilter,
	          anisotropy: assetData.hasOwnProperty('anisotropy') ? assetData.anisotropy : 1,
	          addressU: ADDRESS_CLAMP_TO_EDGE,
	          addressV: ADDRESS_CLAMP_TO_EDGE,
	          fixCubemapSeams: !!assets[0]
	        });
	        resources[0] = faces;
	      }
	    } else {
	      resources[0] = oldResources[0] || null;
	    }

	    if (!this.cmpArrays(resources, oldResources)) {
	      cubemapAsset.resources = resources;
	      cubemapAsset._handlerState.assetIds = assetIds;
	      cubemapAsset._handlerState.assets = assets;

	      for (i = 0; i < oldResources.length; ++i) {
	        if (oldResources[i] !== null && resources.indexOf(oldResources[i]) === -1) {
	          oldResources[i].destroy();
	        }
	      }
	    }

	    for (i = 0; i < oldAssets.length; ++i) {
	      if (oldAssets[i] !== null && assets.indexOf(oldAssets[i]) === -1) {
	        oldAssets[i].unload();
	      }
	    }
	  };

	  _proto.cmpArrays = function cmpArrays(arr1, arr2) {
	    if (arr1.length !== arr2.length) {
	      return false;
	    }

	    for (var i = 0; i < arr1.length; ++i) {
	      if (arr1[i] !== arr2[i]) {
	        return false;
	      }
	    }

	    return true;
	  };

	  _proto.resolveId = function resolveId(value) {
	    var valueInt = parseInt(value, 10);
	    return valueInt === value || valueInt.toString() === value ? valueInt : value;
	  };

	  _proto.loadAssets = function loadAssets(cubemapAsset, callback) {
	    if (!cubemapAsset.hasOwnProperty('_handlerState')) {
	      cubemapAsset._handlerState = {
	        assetIds: [null, null, null, null, null, null, null],
	        assets: [null, null, null, null, null, null, null]
	      };
	    }

	    var self = this;
	    var assetIds = self.getAssetIds(cubemapAsset);
	    var assets = [null, null, null, null, null, null, null];
	    var loadedAssetIds = cubemapAsset._handlerState.assetIds;
	    var loadedAssets = cubemapAsset._handlerState.assets;
	    var registry = self._registry;
	    var awaiting = 7;

	    var onLoad = function onLoad(index, asset) {
	      assets[index] = asset;
	      awaiting--;

	      if (awaiting === 0) {
	        self.update(cubemapAsset, assetIds, assets);
	        callback(null, cubemapAsset.resources);
	      }
	    };

	    var onError = function onError(index, err, asset) {
	      callback(err);
	    };

	    var processTexAsset = function processTexAsset(index, texAsset) {
	      if (texAsset.loaded) {
	        onLoad(index, texAsset);
	      } else {
	        registry.once('load:' + texAsset.id, onLoad.bind(self, index));
	        registry.once('error:' + texAsset.id, onError.bind(self, index));

	        if (!texAsset.loading) {
	          registry.load(texAsset);
	        }
	      }
	    };

	    var texAsset;

	    for (var i = 0; i < 7; ++i) {
	      var assetId = this.resolveId(assetIds[i]);

	      if (!assetId) {
	        onLoad(i, null);
	      } else if (self.compareAssetIds(assetId, loadedAssetIds[i])) {
	        onLoad(i, loadedAssets[i]);
	      } else if (parseInt(assetId, 10) === assetId) {
	        texAsset = registry.get(assetId);

	        if (texAsset) {
	          processTexAsset(i, texAsset);
	        } else {
	          setTimeout(function (index, assetId_) {
	            var texAsset = registry.get(assetId_);

	            if (texAsset) {
	              processTexAsset(index, texAsset);
	            } else {
	              onError(index, 'failed to find dependent cubemap asset=' + assetId_);
	            }
	          }.bind(null, i, assetId));
	        }
	      } else {
	        var file = typeof assetId === 'string' ? {
	          url: assetId,
	          filename: assetId
	        } : assetId;
	        texAsset = new Asset(cubemapAsset.name + '_part_' + i, 'texture', file);
	        registry.add(texAsset);
	        registry.once('load:' + texAsset.id, onLoad.bind(self, i));
	        registry.once('error:' + texAsset.id, onError.bind(self, i));
	        registry.load(texAsset);
	      }
	    }
	  };

	  return CubemapHandler;
	}();

	var FolderHandler = function () {
	  function FolderHandler() {
	    this.handlerType = "folder";
	  }

	  var _proto = FolderHandler.prototype;

	  _proto.load = function load(url, callback) {
	    callback(null, null);
	  };

	  _proto.open = function open(url, data) {
	    return data;
	  };

	  return FolderHandler;
	}();

	function upgradeDataSchema(data) {
	  if (data.version < 3) {
	    if (data.version < 2) {
	      data.info.maps = data.info.maps || [{
	        width: data.info.width,
	        height: data.info.height
	      }];
	    }

	    data.chars = Object.keys(data.chars || {}).reduce(function (newChars, key) {
	      var existing = data.chars[key];
	      var newKey = existing.letter !== undefined ? existing.letter : string.fromCodePoint(key);

	      if (data.version < 2) {
	        existing.map = existing.map || 0;
	      }

	      newChars[newKey] = existing;
	      return newChars;
	    }, {});
	    data.version = 3;
	  }

	  return data;
	}

	var FontHandler = function () {
	  function FontHandler(app) {
	    this.handlerType = "font";
	    this._loader = app.loader;
	    this.maxRetries = 0;
	  }

	  var _proto = FontHandler.prototype;

	  _proto.load = function load(url, callback, asset) {
	    if (typeof url === 'string') {
	      url = {
	        load: url,
	        original: url
	      };
	    }

	    var self = this;

	    if (path.getExtension(url.original) === '.json') {
	      http.get(url.load, {
	        retry: this.maxRetries > 0,
	        maxRetries: this.maxRetries
	      }, function (err, response) {
	        if (!err) {
	          var data = upgradeDataSchema(response);

	          self._loadTextures(url.load.replace('.json', '.png'), data, function (err, textures) {
	            if (err) return callback(err);
	            callback(null, {
	              data: data,
	              textures: textures
	            });
	          });
	        } else {
	          callback("Error loading font resource: " + url.original + " [" + err + "]");
	        }
	      });
	    } else {
	      if (asset && asset.data) {
	        asset.data = upgradeDataSchema(asset.data);
	      }

	      this._loadTextures(url.load, asset && asset.data, callback);
	    }
	  };

	  _proto._loadTextures = function _loadTextures(url, data, callback) {
	    var numTextures = data.info.maps.length;
	    var numLoaded = 0;
	    var error = null;
	    var textures = new Array(numTextures);
	    var loader = this._loader;

	    var loadTexture = function loadTexture(index) {
	      var onLoaded = function onLoaded(err, texture) {
	        if (error) return;

	        if (err) {
	          error = err;
	          return callback(err);
	        }

	        texture.upload();
	        textures[index] = texture;
	        numLoaded++;

	        if (numLoaded === numTextures) {
	          callback(null, textures);
	        }
	      };

	      if (index === 0) {
	        loader.load(url, 'texture', onLoaded);
	      } else {
	        loader.load(url.replace('.png', index + '.png'), 'texture', onLoaded);
	      }
	    };

	    for (var i = 0; i < numTextures; i++) {
	      loadTexture(i);
	    }
	  };

	  _proto.open = function open(url, data, asset) {
	    var font;

	    if (data.textures) {
	      font = new Font(data.textures, data.data);
	    } else {
	      font = new Font(data, null);
	    }

	    return font;
	  };

	  _proto.patch = function patch(asset, assets) {
	    var font = asset.resource;

	    if (!font.data && asset.data) {
	      font.data = asset.data;
	    } else if (!asset.data && font.data) {
	      asset.data = font.data;
	    }

	    if (asset.data) {
	      asset.data = upgradeDataSchema(asset.data);
	    }
	  };

	  return FontHandler;
	}();

	var CompressUtils = {
	  setCompressedPRS: function setCompressedPRS(entity, data, compressed) {
	    var a = compressed.singleVecs;
	    var b, i;
	    var v = data.___1;

	    if (!v) {
	      b = compressed.tripleVecs;
	      i = data.___2;
	    }

	    var n = v ? v[0] : b[i];
	    entity.setLocalPosition(a[n], a[n + 1], a[n + 2]);
	    n = v ? v[1] : b[i + 1];
	    entity.setLocalEulerAngles(a[n], a[n + 1], a[n + 2]);
	    n = v ? v[2] : b[i + 2];
	    entity.setLocalScale(a[n], a[n + 1], a[n + 2]);
	  },
	  oneCharToKey: function oneCharToKey(s, data) {
	    var i = s.charCodeAt(0) - data.fieldFirstCode;
	    return data.fieldArray[i];
	  },
	  multCharToKey: function multCharToKey(s, data) {
	    var ind = 0;

	    for (var i = 0; i < s.length; i++) {
	      ind = ind * data.fieldCodeBase + s.charCodeAt(i) - data.fieldFirstCode;
	    }

	    return data.fieldArray[ind];
	  }
	};

	var Decompress = function () {
	  function Decompress(node, data) {
	    this._node = node;
	    this._data = data;
	  }

	  var _proto = Decompress.prototype;

	  _proto.run = function run() {
	    var type = Object.prototype.toString.call(this._node);

	    if (type === '[object Object]') {
	      this._handleMap();
	    } else if (type === '[object Array]') {
	      this._handleArray();
	    } else {
	      this._result = this._node;
	    }

	    return this._result;
	  };

	  _proto._handleMap = function _handleMap() {
	    this._result = {};
	    var a = Object.keys(this._node);
	    a.forEach(this._handleKey, this);
	  };

	  _proto._handleKey = function _handleKey(origKey) {
	    var newKey = origKey;
	    var len = origKey.length;

	    if (len === 1) {
	      newKey = CompressUtils.oneCharToKey(origKey, this._data);
	    } else if (len === 2) {
	      newKey = CompressUtils.multCharToKey(origKey, this._data);
	    }

	    this._result[newKey] = new Decompress(this._node[origKey], this._data).run();
	  };

	  _proto._handleArray = function _handleArray() {
	    this._result = [];

	    this._node.forEach(this._handleArElt, this);
	  };

	  _proto._handleArElt = function _handleArElt(elt) {
	    var v = new Decompress(elt, this._data).run();

	    this._result.push(v);
	  };

	  return Decompress;
	}();

	var SceneParser = function () {
	  function SceneParser(app, isTemplate) {
	    this._app = app;
	    this._isTemplate = isTemplate;
	  }

	  var _proto = SceneParser.prototype;

	  _proto.parse = function parse(data) {
	    var entities = {};
	    var parent = null;
	    var compressed = data.compressedFormat;

	    if (compressed && !data.entDecompressed) {
	      data.entDecompressed = true;
	      data.entities = new Decompress(data.entities, compressed).run();
	    }

	    for (var id in data.entities) {
	      var curData = data.entities[id];

	      var curEnt = this._createEntity(curData, compressed);

	      entities[id] = curEnt;

	      if (curData.parent === null) {
	        parent = curEnt;
	      }
	    }

	    for (var _id in data.entities) {
	      var _curEnt = entities[_id];
	      var children = data.entities[_id].children;
	      var len = children.length;

	      for (var i = 0; i < len; i++) {
	        var childEnt = entities[children[i]];

	        if (childEnt) {
	          _curEnt.addChild(childEnt);
	        }
	      }
	    }

	    this._openComponentData(parent, data.entities);

	    return parent;
	  };

	  _proto._createEntity = function _createEntity(data, compressed) {
	    var entity = new Entity(data.name, this._app);
	    entity.setGuid(data.resource_id);

	    this._setPosRotScale(entity, data, compressed);

	    entity._enabled = data.enabled !== undefined ? data.enabled : true;

	    if (this._isTemplate) {
	      entity._template = true;
	    } else {
	      entity._enabledInHierarchy = entity._enabled;
	    }

	    entity.template = data.template;

	    if (data.tags) {
	      for (var i = 0; i < data.tags.length; i++) {
	        entity.tags.add(data.tags[i]);
	      }
	    }

	    if (data.labels) {
	      data.labels.forEach(function (label) {
	        entity.addLabel(label);
	      });
	    }

	    return entity;
	  };

	  _proto._setPosRotScale = function _setPosRotScale(entity, data, compressed) {
	    if (compressed) {
	      CompressUtils.setCompressedPRS(entity, data, compressed);
	    } else {
	      var p = data.position;
	      var r = data.rotation;
	      var s = data.scale;
	      entity.setLocalPosition(p[0], p[1], p[2]);
	      entity.setLocalEulerAngles(r[0], r[1], r[2]);
	      entity.setLocalScale(s[0], s[1], s[2]);
	    }
	  };

	  _proto._openComponentData = function _openComponentData(entity, entities) {
	    var systemsList = this._app.systems.list;
	    var len = systemsList.length;
	    var entityData = entities[entity.getGuid()];

	    for (var i = 0; i < len; i++) {
	      var system = systemsList[i];
	      var componentData = entityData.components[system.id];

	      if (componentData) {
	        system.addComponent(entity, componentData);
	      }
	    }

	    len = entityData.children.length;
	    var children = entity._children;

	    for (var _i = 0; _i < len; _i++) {
	      children[_i] = this._openComponentData(children[_i], entities);
	    }

	    return entity;
	  };

	  return SceneParser;
	}();

	var SceneUtils = {
	  load: function load(url, maxRetries, callback) {
	    if (typeof url === 'string') {
	      url = {
	        load: url,
	        original: url
	      };
	    }

	    http.get(url.load, {
	      retry: maxRetries > 0,
	      maxRetries: maxRetries
	    }, function (err, response) {
	      if (!err) {
	        callback(err, response);
	      } else {
	        var errMsg = 'Error while loading scene JSON ' + url.original;

	        if (err.message) {
	          errMsg += ': ' + err.message;

	          if (err.stack) {
	            errMsg += '\n' + err.stack;
	          }
	        } else {
	          errMsg += ': ' + err;
	        }

	        callback(errMsg);
	      }
	    });
	  }
	};

	var HierarchyHandler = function () {
	  function HierarchyHandler(app) {
	    this.handlerType = "hierarchy";
	    this._app = app;
	    this.maxRetries = 0;
	  }

	  var _proto = HierarchyHandler.prototype;

	  _proto.load = function load(url, callback) {
	    SceneUtils.load(url, this.maxRetries, callback);
	  };

	  _proto.open = function open(url, data) {
	    this._app.systems.script.preloading = true;
	    var parser = new SceneParser(this._app, false);
	    var parent = parser.parse(data);
	    this._app.systems.script.preloading = false;
	    return parent;
	  };

	  return HierarchyHandler;
	}();

	var HtmlHandler = function () {
	  function HtmlHandler(app) {
	    this.handlerType = "html";
	    this.maxRetries = 0;
	  }

	  var _proto = HtmlHandler.prototype;

	  _proto.load = function load(url, callback) {
	    if (typeof url === 'string') {
	      url = {
	        load: url,
	        original: url
	      };
	    }

	    http.get(url.load, {
	      retry: this.maxRetries > 0,
	      maxRetries: this.maxRetries
	    }, function (err, response) {
	      if (!err) {
	        callback(null, response);
	      } else {
	        callback("Error loading html resource: " + url.original + " [" + err + "]");
	      }
	    });
	  };

	  _proto.open = function open(url, data) {
	    return data;
	  };

	  _proto.patch = function patch(asset, assets) {};

	  return HtmlHandler;
	}();

	var JsonHandler = function () {
	  function JsonHandler(app) {
	    this.handlerType = "json";
	    this.maxRetries = 0;
	  }

	  var _proto = JsonHandler.prototype;

	  _proto.load = function load(url, callback) {
	    if (typeof url === 'string') {
	      url = {
	        load: url,
	        original: url
	      };
	    }

	    var options = {
	      retry: this.maxRetries > 0,
	      maxRetries: this.maxRetries
	    };

	    if (url.load.startsWith('blob:')) {
	      options.responseType = Http.ResponseType.JSON;
	    }

	    http.get(url.load, options, function (err, response) {
	      if (!err) {
	        callback(null, response);
	      } else {
	        callback("Error loading JSON resource: " + url.original + " [" + err + "]");
	      }
	    });
	  };

	  _proto.open = function open(url, data) {
	    return data;
	  };

	  _proto.patch = function patch(asset, assets) {};

	  return JsonHandler;
	}();

	var StandardMaterialValidator = function () {
	  function StandardMaterialValidator() {
	    this.removeInvalid = true;
	    this.valid = true;
	    this.enumValidators = {
	      occludeSpecular: this._createEnumValidator([SPECOCC_NONE, SPECOCC_AO, SPECOCC_GLOSSDEPENDENT]),
	      cull: this._createEnumValidator([CULLFACE_NONE, CULLFACE_BACK, CULLFACE_FRONT, CULLFACE_FRONTANDBACK]),
	      blendType: this._createEnumValidator([BLEND_SUBTRACTIVE, BLEND_ADDITIVE, BLEND_NORMAL, BLEND_NONE, BLEND_PREMULTIPLIED, BLEND_MULTIPLICATIVE, BLEND_ADDITIVEALPHA, BLEND_MULTIPLICATIVE2X, BLEND_SCREEN, BLEND_MIN, BLEND_MAX]),
	      depthFunc: this._createEnumValidator([FUNC_NEVER, FUNC_LESS, FUNC_EQUAL, FUNC_LESSEQUAL, FUNC_GREATER, FUNC_NOTEQUAL, FUNC_GREATEREQUAL, FUNC_ALWAYS]),
	      shadingModel: this._createEnumValidator([SPECULAR_PHONG, SPECULAR_BLINN])
	    };
	  }

	  var _proto = StandardMaterialValidator.prototype;

	  _proto.setInvalid = function setInvalid(key, data) {
	    this.valid = false;

	    if (this.removeInvalid) {
	      delete data[key];
	    }
	  };

	  _proto.validate = function validate(data) {
	    var TYPES = standardMaterialParameterTypes;
	    var REMOVED = standardMaterialRemovedParameters;
	    var pathMapping = data.mappingFormat === 'path';

	    for (var key in data) {
	      var type = TYPES[key];

	      if (!type) {
	        if (REMOVED[key]) {
	          delete data[key];
	        } else {
	          this.valid = false;
	        }

	        continue;
	      }

	      if (type.startsWith('enum')) {
	        var enumType = type.split(':')[1];

	        if (this.enumValidators[enumType]) {
	          if (!this.enumValidators[enumType](data[key])) {
	            this.setInvalid(key, data);
	          }
	        }
	      } else if (type === 'number') {
	        if (typeof data[key] !== 'number') {
	          this.setInvalid(key, data);
	        }
	      } else if (type === 'boolean') {
	        if (typeof data[key] !== 'boolean') {
	          this.setInvalid(key, data);
	        }
	      } else if (type === 'string') {
	        if (typeof data[key] !== 'string') {
	          this.setInvalid(key, data);
	        }
	      } else if (type === 'vec2') {
	        if (!(data[key] instanceof Array && data[key].length === 2)) {
	          this.setInvalid(key, data);
	        }
	      } else if (type === 'rgb') {
	        if (!(data[key] instanceof Array && data[key].length === 3)) {
	          this.setInvalid(key, data);
	        }
	      } else if (type === 'texture') {
	        if (!pathMapping) {
	          if (!(typeof data[key] === 'number' || data[key] === null)) {
	            if (!(data[key] instanceof Texture)) {
	              this.setInvalid(key, data);
	            }
	          }
	        } else {
	          if (!(typeof data[key] === 'string' || data[key] === null)) {
	            if (!(data[key] instanceof Texture)) {
	              this.setInvalid(key, data);
	            }
	          }
	        }
	      } else if (type === 'boundingbox') {
	        if (!(data[key].center && data[key].center instanceof Array && data[key].center.length === 3)) {
	          this.setInvalid(key, data);
	        }

	        if (!(data[key].halfExtents && data[key].halfExtents instanceof Array && data[key].halfExtents.length === 3)) {
	          this.setInvalid(key, data);
	        }
	      } else if (type === 'cubemap') {
	        if (!(typeof data[key] === 'number' || data[key] === null || data[key] === undefined)) {
	          if (!(data[key] instanceof Texture && data[key].cubemap)) {
	            this.setInvalid(key, data);
	          }
	        }
	      } else if (type === 'chunks') {
	        var chunkNames = Object.keys(data[key]);

	        for (var i = 0; i < chunkNames.length; i++) {
	          if (typeof data[key][chunkNames[i]] !== 'string') {
	            this.setInvalid(chunkNames[i], data[key]);
	          }
	        }
	      } else {
	        console.error('Unknown material type: ' + type);
	      }
	    }

	    data.validated = true;
	    return this.valid;
	  };

	  _proto._createEnumValidator = function _createEnumValidator(values) {
	    return function (value) {
	      return values.indexOf(value) >= 0;
	    };
	  };

	  return StandardMaterialValidator;
	}();

	var JsonStandardMaterialParser = function () {
	  function JsonStandardMaterialParser() {
	    this._validator = null;
	  }

	  var _proto = JsonStandardMaterialParser.prototype;

	  _proto.parse = function parse(input) {
	    var migrated = this.migrate(input);

	    var validated = this._validate(migrated);

	    var material = new StandardMaterial();
	    this.initialize(material, validated);
	    return material;
	  };

	  _proto.initialize = function initialize(material, data) {
	    if (!data.validated) {
	      data = this._validate(data);
	    }

	    if (data.chunks) {
	      material.chunks = _extends({}, data.chunks);
	    }

	    for (var key in data) {
	      var type = standardMaterialParameterTypes[key];
	      var value = data[key];

	      if (type === 'vec2') {
	        material[key] = new Vec2(value[0], value[1]);
	      } else if (type === 'rgb') {
	        material[key] = new Color(value[0], value[1], value[2]);
	      } else if (type === 'texture') {
	        if (value instanceof Texture) {
	          material[key] = value;
	        } else if (!(material[key] instanceof Texture && typeof value === 'number' && value > 0)) {
	          material[key] = null;
	        }
	      } else if (type === 'cubemap') {
	        if (value instanceof Texture) {
	          material[key] = value;
	        } else if (!(material[key] instanceof Texture && typeof value === 'number' && value > 0)) {
	          material[key] = null;
	        }

	        if (key === 'cubeMap' && !value) {
	          material.prefilteredCubemaps = null;
	        }
	      } else if (type === 'boundingbox') {
	        var center = new Vec3(value.center[0], value.center[1], value.center[2]);
	        var halfExtents = new Vec3(value.halfExtents[0], value.halfExtents[1], value.halfExtents[2]);
	        material[key] = new BoundingBox(center, halfExtents);
	      } else {
	        material[key] = data[key];
	      }
	    }

	    material.update();
	  };

	  _proto.migrate = function migrate(data) {
	    if (data.shadingModel === undefined) {
	      if (data.shader === 'blinn') {
	        data.shadingModel = SPECULAR_BLINN;
	      } else {
	        data.shadingModel = SPECULAR_PHONG;
	      }
	    }

	    if (data.shader) delete data.shader;

	    if (data.mapping_format) {
	      data.mappingFormat = data.mapping_format;
	      delete data.mapping_format;
	    }

	    var i;
	    var RENAMED_PROPERTIES = [['bumpMapFactor', 'bumpiness'], ['aoUvSet', 'aoMapUv'], ['aoMapVertexColor', 'aoVertexColor'], ['diffuseMapVertexColor', 'diffuseVertexColor'], ['emissiveMapVertexColor', 'emissiveVertexColor'], ['specularMapVertexColor', 'specularVertexColor'], ['metalnessMapVertexColor', 'metalnessVertexColor'], ['opacityMapVertexColor', 'opacityVertexColor'], ['glossMapVertexColor', 'glossVertexColor'], ['lightMapVertexColor', 'lightVertexColor'], ['diffuseMapTint', 'diffuseTint'], ['specularMapTint', 'specularTint'], ['emissiveMapTint', 'emissiveTint'], ['metalnessMapTint', 'metalnessTint']];

	    for (i = 0; i < RENAMED_PROPERTIES.length; i++) {
	      var _old = RENAMED_PROPERTIES[i][0];
	      var _new = RENAMED_PROPERTIES[i][1];

	      if (data[_old] !== undefined && !(data[_new] !== undefined)) {
	        data[_new] = data[_old];
	        delete data[_old];
	      }
	    }

	    var DEPRECATED_PROPERTIES = ['fresnelFactor', 'shadowSampleType'];

	    for (i = 0; i < DEPRECATED_PROPERTIES.length; i++) {
	      var name = DEPRECATED_PROPERTIES[i];

	      if (data.hasOwnProperty(name)) {
	        delete data[name];
	      }
	    }

	    return data;
	  };

	  _proto._validate = function _validate(data) {
	    if (!data.validated) {
	      if (!this._validator) {
	        this._validator = new StandardMaterialValidator();
	      }

	      this._validator.validate(data);
	    }

	    return data;
	  };

	  return JsonStandardMaterialParser;
	}();

	var AssetReference = function () {
	  function AssetReference(propertyName, parent, registry, callbacks, scope) {
	    this.propertyName = propertyName;
	    this.parent = parent;
	    this._scope = scope;
	    this._registry = registry;
	    this.id = null;
	    this.url = null;
	    this.asset = null;
	    this._onAssetLoad = callbacks.load;
	    this._onAssetAdd = callbacks.add;
	    this._onAssetRemove = callbacks.remove;
	    this._onAssetUnload = callbacks.unload;
	  }

	  var _proto = AssetReference.prototype;

	  _proto._bind = function _bind() {
	    if (this.id) {
	      if (this._onAssetLoad) this._registry.on('load:' + this.id, this._onLoad, this);
	      if (this._onAssetAdd) this._registry.once('add:' + this.id, this._onAdd, this);
	      if (this._onAssetRemove) this._registry.on('remove:' + this.id, this._onRemove, this);
	      if (this._onAssetUnload) this._registry.on('unload:' + this.id, this._onUnload, this);
	    }

	    if (this.url) {
	      if (this._onAssetLoad) this._registry.on('load:url:' + this.url, this._onLoad, this);
	      if (this._onAssetAdd) this._registry.once('add:url:' + this.url, this._onAdd, this);
	      if (this._onAssetRemove) this._registry.on('remove:url:' + this.url, this._onRemove, this);
	    }
	  };

	  _proto._unbind = function _unbind() {
	    if (this.id) {
	      if (this._onAssetLoad) this._registry.off('load:' + this.id, this._onLoad, this);
	      if (this._onAssetAdd) this._registry.off('add:' + this.id, this._onAdd, this);
	      if (this._onAssetRemove) this._registry.off('remove:' + this.id, this._onRemove, this);
	      if (this._onAssetUnload) this._registry.off('unload:' + this.id, this._onUnload, this);
	    }

	    if (this.url) {
	      if (this._onAssetLoad) this._registry.off('load:' + this.url, this._onLoad, this);
	      if (this._onAssetAdd) this._registry.off('add:' + this.url, this._onAdd, this);
	      if (this._onAssetRemove) this._registry.off('remove:' + this.url, this._onRemove, this);
	    }
	  };

	  _proto._onLoad = function _onLoad(asset) {
	    this._onAssetLoad.call(this._scope, this.propertyName, this.parent, asset);
	  };

	  _proto._onAdd = function _onAdd(asset) {
	    this.asset = asset;

	    this._onAssetAdd.call(this._scope, this.propertyName, this.parent, asset);
	  };

	  _proto._onRemove = function _onRemove(asset) {
	    this._onAssetRemove.call(this._scope, this.propertyName, this.parent, asset);

	    this.asset = null;
	  };

	  _proto._onUnload = function _onUnload(asset) {
	    this._onAssetUnload.call(this._scope, this.propertyName, this.parent, asset);
	  };

	  _createClass(AssetReference, [{
	    key: "id",
	    get: function get() {
	      return this._id;
	    },
	    set: function set(value) {
	      if (this.url) throw Error('Can\'t set id and url');

	      this._unbind();

	      this._id = value;
	      this.asset = this._registry.get(this._id);

	      this._bind();
	    }
	  }, {
	    key: "url",
	    get: function get() {
	      return this._url;
	    },
	    set: function set(value) {
	      if (this.id) throw Error('Can\'t set id and url');

	      this._unbind();

	      this._url = value;
	      this.asset = this._registry.getByUrl(this._url);

	      this._bind();
	    }
	  }]);

	  return AssetReference;
	}();

	var PLACEHOLDER_MAP = {
	  aoMap: 'white',
	  diffuseMap: 'gray',
	  specularMap: 'gray',
	  specularityFactorMap: 'white',
	  metalnessMap: 'black',
	  glossMap: 'gray',
	  sheenMap: 'black',
	  sheenGlossinessMap: 'gray',
	  clearCoatMap: 'black',
	  clearCoatGlossMap: 'gray',
	  clearCoatNormalMap: 'normal',
	  refractionMap: 'white',
	  emissiveMap: 'gray',
	  normalMap: 'normal',
	  heightMap: 'gray',
	  opacityMap: 'gray',
	  sphereMap: 'gray',
	  lightMap: 'white'
	};

	var MaterialHandler = function () {
	  function MaterialHandler(app) {
	    this.handlerType = "material";
	    this._assets = app.assets;
	    this._device = app.graphicsDevice;
	    this._placeholderTextures = null;
	    this._parser = new JsonStandardMaterialParser();
	    this.maxRetries = 0;
	  }

	  var _proto = MaterialHandler.prototype;

	  _proto.load = function load(url, callback) {
	    if (typeof url === 'string') {
	      url = {
	        load: url,
	        original: url
	      };
	    }

	    http.get(url.load, {
	      retry: this.maxRetries > 0,
	      maxRetries: this.maxRetries
	    }, function (err, response) {
	      if (!err) {
	        if (callback) {
	          response._engine = true;
	          callback(null, response);
	        }
	      } else {
	        if (callback) {
	          callback("Error loading material: " + url.original + " [" + err + "]");
	        }
	      }
	    });
	  };

	  _proto.open = function open(url, data) {
	    var material = this._parser.parse(data);

	    if (data._engine) {
	      material._data = data;
	      delete data._engine;
	    }

	    return material;
	  };

	  _proto._createPlaceholders = function _createPlaceholders() {
	    this._placeholderTextures = {};
	    var textures = {
	      white: [255, 255, 255, 255],
	      gray: [128, 128, 128, 255],
	      black: [0, 0, 0, 255],
	      normal: [128, 128, 255, 255]
	    };

	    for (var key in textures) {
	      if (!textures.hasOwnProperty(key)) continue;
	      this._placeholderTextures[key] = new Texture(this._device, {
	        width: 2,
	        height: 2,
	        format: PIXELFORMAT_R8_G8_B8_A8,
	        name: 'material_placeholder'
	      });

	      var pixels = this._placeholderTextures[key].lock();

	      for (var i = 0; i < 4; i++) {
	        for (var c = 0; c < 4; c++) {
	          pixels[i * 4 + c] = textures[key][c];
	        }
	      }

	      this._placeholderTextures[key].unlock();
	    }
	  };

	  _proto.patch = function patch(asset, assets) {
	    if (asset.resource._data) {
	      asset._data = asset.resource._data;
	      delete asset.resource._data;
	    }

	    asset.data.name = asset.name;
	    asset.resource.name = asset.name;

	    this._bindAndAssignAssets(asset, assets);

	    asset.off('unload', this._onAssetUnload, this);
	    asset.on('unload', this._onAssetUnload, this);
	  };

	  _proto._onAssetUnload = function _onAssetUnload(asset) {
	    delete asset.data.parameters;
	    delete asset.data.chunks;
	    delete asset.data.name;
	  };

	  _proto._assignTexture = function _assignTexture(parameterName, materialAsset, texture) {
	    materialAsset.resource[parameterName] = texture;
	  };

	  _proto._getPlaceholderTexture = function _getPlaceholderTexture(parameterName) {
	    if (!this._placeholderTextures) {
	      this._createPlaceholders();
	    }

	    var placeholder = PLACEHOLDER_MAP[parameterName];
	    var texture = this._placeholderTextures[placeholder];
	    return texture;
	  };

	  _proto._assignPlaceholderTexture = function _assignPlaceholderTexture(parameterName, materialAsset) {
	    materialAsset.resource[parameterName] = this._getPlaceholderTexture(parameterName);
	  };

	  _proto._onTextureLoad = function _onTextureLoad(parameterName, materialAsset, textureAsset) {
	    this._assignTexture(parameterName, materialAsset, textureAsset.resource);

	    materialAsset.resource.update();
	  };

	  _proto._onTextureAdd = function _onTextureAdd(parameterName, materialAsset, textureAsset) {
	    this._assets.load(textureAsset);
	  };

	  _proto._onTextureRemoveOrUnload = function _onTextureRemoveOrUnload(parameterName, materialAsset, textureAsset) {
	    var material = materialAsset.resource;

	    if (material) {
	      if (materialAsset.resource[parameterName] === textureAsset.resource) {
	        this._assignPlaceholderTexture(parameterName, materialAsset);

	        material.update();
	      }
	    }
	  };

	  _proto._assignCubemap = function _assignCubemap(parameterName, materialAsset, textures) {
	    materialAsset.resource[parameterName] = textures[0];

	    if (parameterName === 'cubeMap') {
	      materialAsset.resource.prefilteredCubemaps = textures.slice(1);
	    }
	  };

	  _proto._onCubemapLoad = function _onCubemapLoad(parameterName, materialAsset, cubemapAsset) {
	    this._assignCubemap(parameterName, materialAsset, cubemapAsset.resources);

	    this._parser.initialize(materialAsset.resource, materialAsset.data);
	  };

	  _proto._onCubemapAdd = function _onCubemapAdd(parameterName, materialAsset, cubemapAsset) {
	    if (materialAsset.data.shadingModel === SPECULAR_PHONG) {
	      materialAsset.loadFaces = true;
	    }

	    this._assets.load(cubemapAsset);
	  };

	  _proto._onCubemapRemoveOrUnload = function _onCubemapRemoveOrUnload(parameterName, materialAsset, cubemapAsset) {
	    var material = materialAsset.resource;

	    if (materialAsset.data.prefilteredCubeMap128 === cubemapAsset.resources[1]) {
	      this._assignCubemap(parameterName, materialAsset, [null, null, null, null, null, null, null]);

	      material.update();
	    }
	  };

	  _proto._bindAndAssignAssets = function _bindAndAssignAssets(materialAsset, assets) {
	    var data = this._parser.migrate(materialAsset.data);

	    var material = materialAsset.resource;
	    var pathMapping = data.mappingFormat === 'path';
	    var TEXTURES = standardMaterialTextureParameters;
	    var i, name, assetReference;

	    for (i = 0; i < TEXTURES.length; i++) {
	      name = TEXTURES[i];
	      assetReference = material._assetReferences[name];
	      var dataAssetId = data[name];
	      var materialTexture = material[name];

	      var isPlaceHolderTexture = materialTexture === this._getPlaceholderTexture(name);

	      var dataValidated = data.validated;

	      if (dataAssetId && (!materialTexture || !dataValidated || isPlaceHolderTexture)) {
	        if (!assetReference) {
	          assetReference = new AssetReference(name, materialAsset, assets, {
	            load: this._onTextureLoad,
	            add: this._onTextureAdd,
	            remove: this._onTextureRemoveOrUnload,
	            unload: this._onTextureRemoveOrUnload
	          }, this);
	          material._assetReferences[name] = assetReference;
	        }

	        if (pathMapping) {
	          assetReference.url = materialAsset.getAbsoluteUrl(dataAssetId);
	        } else {
	          assetReference.id = dataAssetId;
	        }

	        if (assetReference.asset) {
	          if (assetReference.asset.resource) {
	            this._assignTexture(name, materialAsset, assetReference.asset.resource);
	          } else {
	            this._assignPlaceholderTexture(name, materialAsset);
	          }

	          assets.load(assetReference.asset);
	        }
	      } else {
	        if (assetReference) {
	          if (pathMapping) {
	            assetReference.url = null;
	          } else {
	            assetReference.id = null;
	          }
	        }
	      }
	    }

	    var CUBEMAPS = standardMaterialCubemapParameters;

	    for (i = 0; i < CUBEMAPS.length; i++) {
	      name = CUBEMAPS[i];
	      assetReference = material._assetReferences[name];

	      if (data[name] && !materialAsset.data.prefilteredCubeMap128) {
	        if (!assetReference) {
	          assetReference = new AssetReference(name, materialAsset, assets, {
	            load: this._onCubemapLoad,
	            add: this._onCubemapAdd,
	            remove: this._onCubemapRemoveOrUnload,
	            unload: this._onCubemapRemoveOrUnload
	          }, this);
	          material._assetReferences[name] = assetReference;
	        }

	        if (pathMapping) {
	          assetReference.url = data[name];
	        } else {
	          assetReference.id = data[name];
	        }

	        if (assetReference.asset) {
	          if (assetReference.asset.loaded) {
	            this._assignCubemap(name, materialAsset, assetReference.asset.resources);
	          }

	          assets.load(assetReference.asset);
	        }
	      }
	    }

	    this._parser.initialize(material, data);
	  };

	  return MaterialHandler;
	}();

	var GlbModelParser = function () {
	  function GlbModelParser(device, defaultMaterial) {
	    this._device = device;
	    this._defaultMaterial = defaultMaterial;
	  }

	  var _proto = GlbModelParser.prototype;

	  _proto.parse = function parse(data) {
	    var glbResources = GlbParser.parse('filename.glb', data, this._device);

	    if (glbResources) {
	      var model = GlbContainerResource.createModel(glbResources, this._defaultMaterial);
	      glbResources.destroy();
	      return model;
	    }

	    return null;
	  };

	  return GlbModelParser;
	}();

	var PartitionedVertex = function PartitionedVertex() {
	  this.index = 0;
	  this.boneIndices = [0, 0, 0, 0];
	};

	var SkinPartition = function () {
	  function SkinPartition() {
	    this.partition = 0;
	    this.vertexStart = 0;
	    this.vertexCount = 0;
	    this.indexStart = 0;
	    this.indexCount = 0;
	    this.boneIndices = [];
	    this.vertices = [];
	    this.indices = [];
	    this.indexMap = {};
	    this.originalMesh = null;
	  }

	  var _proto = SkinPartition.prototype;

	  _proto.addVertex = function addVertex(vertex, idx, vertexArray) {
	    var remappedIndex = -1;

	    if (this.indexMap[idx] !== undefined) {
	      remappedIndex = this.indexMap[idx];
	      this.indices.push(remappedIndex);
	    } else {
	      for (var influence = 0; influence < 4; influence++) {
	        if (vertexArray.blendWeight.data[idx * 4 + influence] === 0) continue;
	        var originalBoneIndex = vertexArray.blendIndices.data[vertex.index * 4 + influence];
	        vertex.boneIndices[influence] = this.getBoneRemap(originalBoneIndex);
	      }

	      remappedIndex = this.vertices.length;
	      this.indices.push(remappedIndex);
	      this.vertices.push(vertex);
	      this.indexMap[idx] = remappedIndex;
	    }
	  };

	  _proto.addPrimitive = function addPrimitive(vertices, vertexIndices, vertexArray, boneLimit) {
	    var bonesToAdd = [];
	    var bonesToAddCount = 0;
	    var vertexCount = vertices.length;

	    for (var i = 0; i < vertexCount; i++) {
	      var vertex = vertices[i];
	      var idx = vertex.index;

	      for (var influence = 0; influence < 4; influence++) {
	        if (vertexArray.blendWeight.data[idx * 4 + influence] > 0) {
	          var boneIndex = vertexArray.blendIndices.data[idx * 4 + influence];
	          var needToAdd = true;

	          for (var j = 0; j < bonesToAddCount; j++) {
	            if (bonesToAdd[j] === boneIndex) {
	              needToAdd = false;
	              break;
	            }
	          }

	          if (needToAdd) {
	            bonesToAdd[bonesToAddCount] = boneIndex;
	            var boneRemap = this.getBoneRemap(boneIndex);
	            bonesToAddCount += boneRemap === -1 ? 1 : 0;
	          }
	        }
	      }
	    }

	    if (this.boneIndices.length + bonesToAddCount > boneLimit) {
	      return false;
	    }

	    for (var _i = 0; _i < bonesToAddCount; _i++) {
	      this.boneIndices.push(bonesToAdd[_i]);
	    }

	    for (var _i2 = 0; _i2 < vertexCount; _i2++) {
	      this.addVertex(vertices[_i2], vertexIndices[_i2], vertexArray);
	    }

	    return true;
	  };

	  _proto.getBoneRemap = function getBoneRemap(boneIndex) {
	    for (var i = 0; i < this.boneIndices.length; i++) {
	      if (this.boneIndices[i] === boneIndex) {
	        return i;
	      }
	    }

	    return -1;
	  };

	  return SkinPartition;
	}();

	function indicesToReferences(model) {
	  var vertices = model.vertices;
	  var skins = model.skins;
	  var meshes = model.meshes;
	  var meshInstances = model.meshInstances;

	  for (var i = 0; i < meshes.length; i++) {
	    meshes[i].vertices = vertices[meshes[i].vertices];

	    if (meshes[i].skin !== undefined) {
	      meshes[i].skin = skins[meshes[i].skin];
	    }
	  }

	  for (var _i3 = 0; _i3 < meshInstances.length; _i3++) {
	    meshInstances[_i3].mesh = meshes[meshInstances[_i3].mesh];
	  }
	}

	function referencesToIndices(model) {
	  var vertices = model.vertices;
	  var skins = model.skins;
	  var meshes = model.meshes;
	  var meshInstances = model.meshInstances;

	  for (var i = 0; i < meshes.length; i++) {
	    meshes[i].vertices = vertices.indexOf(meshes[i].vertices);

	    if (meshes[i].skin !== undefined) {
	      meshes[i].skin = skins.indexOf(meshes[i].skin);
	    }
	  }

	  for (var _i4 = 0; _i4 < meshInstances.length; _i4++) {
	    meshInstances[_i4].mesh = meshes.indexOf(meshInstances[_i4].mesh);
	  }
	}

	function partitionSkin(model, materialMappings, boneLimit) {
	  var i, j, k, index;
	  indicesToReferences(model);
	  var vertexArrays = model.vertices;
	  var skins = model.skins;
	  var mesh;
	  var meshes = model.meshes;
	  var meshInstances = model.meshInstances;

	  var getVertex = function getVertex(idx) {
	    var vert = new PartitionedVertex();
	    vert.index = idx;
	    return vert;
	  };

	  for (i = skins.length - 1; i >= 0; i--) {
	    if (skins[i].boneNames.length > boneLimit) {
	      var skin = skins.splice(i, 1)[0];
	      var meshesToSplit = [];

	      for (j = 0; j < meshes.length; j++) {
	        if (meshes[j].skin === skin) {
	          meshesToSplit.push(meshes[j]);
	        }
	      }

	      for (j = 0; j < meshesToSplit.length; j++) {
	        index = meshes.indexOf(meshesToSplit[j]);

	        if (index !== -1) {
	          meshes.splice(index, 1);
	        }
	      }

	      if (meshesToSplit.length === 0) {
	        throw new Error('partitionSkin: There should be at least one mesh that references a skin');
	      }

	      var vertexArray = meshesToSplit[0].vertices;

	      for (j = 1; j < meshesToSplit.length; j++) {
	        if (meshesToSplit[j].vertices !== vertexArray) {
	          throw new Error('partitionSkin: All meshes that share a skin should also share the same vertex buffer');
	        }
	      }

	      var partition = void 0;
	      var partitions = [];
	      var primitiveVertices = [];
	      var primitiveIndices = [];
	      var basePartition = 0;

	      for (j = 0; j < meshesToSplit.length; j++) {
	        mesh = meshesToSplit[j];
	        var indices = mesh.indices;

	        for (var iIndex = mesh.base; iIndex < mesh.base + mesh.count;) {
	          index = indices[iIndex++];
	          primitiveVertices[0] = getVertex(index);
	          primitiveIndices[0] = index;
	          index = indices[iIndex++];
	          primitiveVertices[1] = getVertex(index);
	          primitiveIndices[1] = index;
	          index = indices[iIndex++];
	          primitiveVertices[2] = getVertex(index);
	          primitiveIndices[2] = index;
	          var added = false;

	          for (var iBonePartition = basePartition; iBonePartition < partitions.length; iBonePartition++) {
	            partition = partitions[iBonePartition];

	            if (partition.addPrimitive(primitiveVertices, primitiveIndices, vertexArray, boneLimit)) {
	              added = true;
	              break;
	            }
	          }

	          if (!added) {
	            partition = new SkinPartition();
	            partition.originalMesh = mesh;
	            partition.addPrimitive(primitiveVertices, primitiveIndices, vertexArray, boneLimit);
	            partitions.push(partition);
	          }
	        }

	        basePartition = partitions.length;
	      }

	      var partitionedVertices = [];
	      var partitionedIndices = [];

	      for (j = 0; j < partitions.length; j++) {
	        partition = partitions[j];

	        if (partition.vertices.length && partition.indices.length) {
	          var vertexStart = partitionedVertices.length;
	          var vertexCount = partition.vertices.length;
	          var indexStart = partitionedIndices.length;
	          var indexCount = partition.indices.length;
	          partition.partition = j;
	          partition.vertexStart = vertexStart;
	          partition.vertexCount = vertexCount;
	          partition.indexStart = indexStart;
	          partition.indexCount = indexCount;
	          var iSour = void 0;
	          var iDest = void 0;
	          iSour = 0;
	          iDest = vertexStart;

	          while (iSour < vertexCount) {
	            partitionedVertices[iDest++] = partition.vertices[iSour++];
	          }

	          iSour = 0;
	          iDest = indexStart;

	          while (iSour < indexCount) {
	            partitionedIndices[iDest++] = partition.indices[iSour++] + vertexStart;
	          }
	        }
	      }

	      var splitSkins = [];

	      for (j = 0; j < partitions.length; j++) {
	        partition = partitions[j];
	        var ibp = [];
	        var boneNames = [];

	        for (k = 0; k < partition.boneIndices.length; k++) {
	          ibp.push(skin.inverseBindMatrices[partition.boneIndices[k]]);
	          boneNames.push(skin.boneNames[partition.boneIndices[k]]);
	        }

	        var splitSkin = {
	          inverseBindMatrices: ibp,
	          boneNames: boneNames
	        };
	        splitSkins.push(splitSkin);
	        skins.push(splitSkin);
	      }

	      var attrib = void 0,
	          attribName = void 0,
	          data = void 0,
	          components = void 0;
	      var splitVertexArray = {};

	      for (attribName in vertexArray) {
	        splitVertexArray[attribName] = {
	          components: vertexArray[attribName].components,
	          data: [],
	          type: vertexArray[attribName].type
	        };
	      }

	      for (attribName in vertexArray) {
	        if (attribName === 'blendIndices') {
	          var dstBoneIndices = splitVertexArray[attribName].data;

	          for (j = 0; j < partitionedVertices.length; j++) {
	            var srcBoneIndices = partitionedVertices[j].boneIndices;
	            dstBoneIndices.push(srcBoneIndices[0], srcBoneIndices[1], srcBoneIndices[2], srcBoneIndices[3]);
	          }
	        } else {
	          attrib = vertexArray[attribName];
	          data = attrib.data;
	          components = attrib.components;

	          for (j = 0; j < partitionedVertices.length; j++) {
	            index = partitionedVertices[j].index;

	            for (k = 0; k < components; k++) {
	              splitVertexArray[attribName].data.push(data[index * components + k]);
	            }
	          }
	        }
	      }

	      vertexArrays[vertexArrays.indexOf(vertexArray)] = splitVertexArray;

	      for (j = 0; j < partitions.length; j++) {
	        partition = partitions[j];
	        mesh = {
	          aabb: {
	            min: [0, 0, 0],
	            max: [0, 0, 0]
	          },
	          vertices: splitVertexArray,
	          skin: splitSkins[j],
	          indices: partitionedIndices.splice(0, partition.indexCount),
	          type: 'triangles',
	          base: 0,
	          count: partition.indexCount
	        };
	        meshes.push(mesh);

	        for (k = meshInstances.length - 1; k >= 0; k--) {
	          if (meshInstances[k].mesh === partition.originalMesh) {
	            meshInstances.push({
	              mesh: mesh,
	              node: meshInstances[k].node
	            });

	            if (materialMappings) {
	              materialMappings.push({
	                material: materialMappings[k].material,
	                path: materialMappings[k].path
	              });
	            }
	          }
	        }
	      }

	      for (j = 0; j < partitions.length; j++) {
	        partition = partitions[j];

	        for (k = meshInstances.length - 1; k >= 0; k--) {
	          if (meshInstances[k].mesh === partition.originalMesh) {
	            meshInstances.splice(k, 1);

	            if (materialMappings) {
	              materialMappings.splice(k, 1);
	            }
	          }
	        }
	      }
	    }
	  }

	  referencesToIndices(model);
	}

	var JSON_PRIMITIVE_TYPE = {
	  'points': PRIMITIVE_POINTS,
	  'lines': PRIMITIVE_LINES,
	  'lineloop': PRIMITIVE_LINELOOP,
	  'linestrip': PRIMITIVE_LINESTRIP,
	  'triangles': PRIMITIVE_TRIANGLES,
	  'trianglestrip': PRIMITIVE_TRISTRIP,
	  'trianglefan': PRIMITIVE_TRIFAN
	};
	var JSON_VERTEX_ELEMENT_TYPE = {
	  'int8': TYPE_INT8,
	  'uint8': TYPE_UINT8,
	  'int16': TYPE_INT16,
	  'uint16': TYPE_UINT16,
	  'int32': TYPE_INT32,
	  'uint32': TYPE_UINT32,
	  'float32': TYPE_FLOAT32
	};

	var JsonModelParser = function () {
	  function JsonModelParser(device, defaultMaterial) {
	    this._device = device;
	    this._defaultMaterial = defaultMaterial;
	  }

	  var _proto = JsonModelParser.prototype;

	  _proto.parse = function parse(data) {
	    var modelData = data.model;

	    if (!modelData) {
	      return null;
	    }

	    if (modelData.version <= 1) {
	      return null;
	    }

	    var nodes = this._parseNodes(data);

	    var skins = this._parseSkins(data, nodes);

	    var vertexBuffers = this._parseVertexBuffers(data);

	    var indices = this._parseIndexBuffers(data, vertexBuffers);

	    var morphs = this._parseMorphs(data, nodes, vertexBuffers);

	    var meshes = this._parseMeshes(data, skins.skins, morphs.morphs, vertexBuffers, indices.buffer, indices.data);

	    var meshInstances = this._parseMeshInstances(data, nodes, meshes, skins.skins, skins.instances, morphs.morphs, morphs.instances);

	    var model = new Model();
	    model.graph = nodes[0];
	    model.meshInstances = meshInstances;
	    model.skinInstances = skins.instances;
	    model.morphInstances = morphs.instances;
	    model.getGraph().syncHierarchy();
	    return model;
	  };

	  _proto._parseNodes = function _parseNodes(data) {
	    var modelData = data.model;
	    var nodes = [];
	    var i;

	    for (i = 0; i < modelData.nodes.length; i++) {
	      var nodeData = modelData.nodes[i];
	      var node = new GraphNode(nodeData.name);
	      node.setLocalPosition(nodeData.position[0], nodeData.position[1], nodeData.position[2]);
	      node.setLocalEulerAngles(nodeData.rotation[0], nodeData.rotation[1], nodeData.rotation[2]);
	      node.setLocalScale(nodeData.scale[0], nodeData.scale[1], nodeData.scale[2]);
	      node.scaleCompensation = !!nodeData.scaleCompensation;
	      nodes.push(node);
	    }

	    for (i = 1; i < modelData.parents.length; i++) {
	      nodes[modelData.parents[i]].addChild(nodes[i]);
	    }

	    return nodes;
	  };

	  _proto._parseSkins = function _parseSkins(data, nodes) {
	    var modelData = data.model;
	    var skins = [];
	    var skinInstances = [];
	    var i, j;

	    if (!this._device.supportsBoneTextures && modelData.skins.length > 0) {
	      var boneLimit = this._device.getBoneLimit();

	      partitionSkin(modelData, null, boneLimit);
	    }

	    for (i = 0; i < modelData.skins.length; i++) {
	      var skinData = modelData.skins[i];
	      var inverseBindMatrices = [];

	      for (j = 0; j < skinData.inverseBindMatrices.length; j++) {
	        var ibm = skinData.inverseBindMatrices[j];
	        inverseBindMatrices[j] = new Mat4().set(ibm);
	      }

	      var skin = new Skin(this._device, inverseBindMatrices, skinData.boneNames);
	      skins.push(skin);
	      var skinInstance = new SkinInstance(skin);
	      var bones = [];

	      for (j = 0; j < skin.boneNames.length; j++) {
	        var boneName = skin.boneNames[j];
	        var bone = nodes[0].findByName(boneName);
	        bones.push(bone);
	      }

	      skinInstance.bones = bones;
	      skinInstances.push(skinInstance);
	    }

	    return {
	      skins: skins,
	      instances: skinInstances
	    };
	  };

	  _proto._getMorphVertexCount = function _getMorphVertexCount(modelData, morphIndex, vertexBuffers) {
	    for (var i = 0; i < modelData.meshes.length; i++) {
	      var meshData = modelData.meshes[i];

	      if (meshData.morph === morphIndex) {
	        var vertexBuffer = vertexBuffers[meshData.vertices];
	        return vertexBuffer.numVertices;
	      }
	    }

	    return undefined;
	  };

	  _proto._parseMorphs = function _parseMorphs(data, nodes, vertexBuffers) {
	    var modelData = data.model;
	    var morphs = [];
	    var morphInstances = [];
	    var i, j, vertexCount;
	    var targets, morphTarget, morphTargetArray;

	    if (modelData.morphs) {
	      var sparseToFull = function sparseToFull(data, indices, totalCount) {
	        var full = new Float32Array(totalCount * 3);

	        for (var s = 0; s < indices.length; s++) {
	          var dstIndex = indices[s] * 3;
	          full[dstIndex] = data[s * 3];
	          full[dstIndex + 1] = data[s * 3 + 1];
	          full[dstIndex + 2] = data[s * 3 + 2];
	        }

	        return full;
	      };

	      for (i = 0; i < modelData.morphs.length; i++) {
	        targets = modelData.morphs[i].targets;
	        morphTargetArray = [];
	        vertexCount = this._getMorphVertexCount(modelData, i, vertexBuffers);

	        for (j = 0; j < targets.length; j++) {
	          var targetAabb = targets[j].aabb;
	          var min = targetAabb.min;
	          var max = targetAabb.max;
	          var aabb = new BoundingBox(new Vec3((max[0] + min[0]) * 0.5, (max[1] + min[1]) * 0.5, (max[2] + min[2]) * 0.5), new Vec3((max[0] - min[0]) * 0.5, (max[1] - min[1]) * 0.5, (max[2] - min[2]) * 0.5));
	          var indices = targets[j].indices;
	          var deltaPositions = targets[j].deltaPositions;
	          var deltaNormals = targets[j].deltaNormals;

	          if (indices) {
	            deltaPositions = sparseToFull(deltaPositions, indices, vertexCount);
	            deltaNormals = sparseToFull(deltaNormals, indices, vertexCount);
	          }

	          morphTarget = new MorphTarget({
	            deltaPositions: deltaPositions,
	            deltaNormals: deltaNormals,
	            name: targets[j].name,
	            aabb: aabb
	          });
	          morphTargetArray.push(morphTarget);
	        }

	        var morph = new Morph(morphTargetArray, this._device);
	        morphs.push(morph);
	        var morphInstance = new MorphInstance(morph);
	        morphInstances.push(morphInstance);
	      }
	    }

	    return {
	      morphs: morphs,
	      instances: morphInstances
	    };
	  };

	  _proto._parseVertexBuffers = function _parseVertexBuffers(data) {
	    var modelData = data.model;
	    var vertexBuffers = [];
	    var attributeMap = {
	      position: SEMANTIC_POSITION,
	      normal: SEMANTIC_NORMAL,
	      tangent: SEMANTIC_TANGENT,
	      blendWeight: SEMANTIC_BLENDWEIGHT,
	      blendIndices: SEMANTIC_BLENDINDICES,
	      color: SEMANTIC_COLOR,
	      texCoord0: SEMANTIC_TEXCOORD0,
	      texCoord1: SEMANTIC_TEXCOORD1,
	      texCoord2: SEMANTIC_TEXCOORD2,
	      texCoord3: SEMANTIC_TEXCOORD3,
	      texCoord4: SEMANTIC_TEXCOORD4,
	      texCoord5: SEMANTIC_TEXCOORD5,
	      texCoord6: SEMANTIC_TEXCOORD6,
	      texCoord7: SEMANTIC_TEXCOORD7
	    };

	    for (var i = 0; i < modelData.vertices.length; i++) {
	      var vertexData = modelData.vertices[i];
	      var formatDesc = [];

	      for (var attributeName in vertexData) {
	        var attribute = vertexData[attributeName];
	        formatDesc.push({
	          semantic: attributeMap[attributeName],
	          components: attribute.components,
	          type: JSON_VERTEX_ELEMENT_TYPE[attribute.type],
	          normalize: attributeMap[attributeName] === SEMANTIC_COLOR
	        });
	      }

	      var vertexFormat = new VertexFormat(this._device, formatDesc);
	      var numVertices = vertexData.position.data.length / vertexData.position.components;
	      var vertexBuffer = new VertexBuffer(this._device, vertexFormat, numVertices);
	      var iterator = new VertexIterator(vertexBuffer);

	      for (var j = 0; j < numVertices; j++) {
	        for (var _attributeName in vertexData) {
	          var _attribute = vertexData[_attributeName];

	          switch (_attribute.components) {
	            case 1:
	              iterator.element[attributeMap[_attributeName]].set(_attribute.data[j]);

	              break;

	            case 2:
	              iterator.element[attributeMap[_attributeName]].set(_attribute.data[j * 2], 1.0 - _attribute.data[j * 2 + 1]);

	              break;

	            case 3:
	              iterator.element[attributeMap[_attributeName]].set(_attribute.data[j * 3], _attribute.data[j * 3 + 1], _attribute.data[j * 3 + 2]);

	              break;

	            case 4:
	              iterator.element[attributeMap[_attributeName]].set(_attribute.data[j * 4], _attribute.data[j * 4 + 1], _attribute.data[j * 4 + 2], _attribute.data[j * 4 + 3]);

	              break;
	          }
	        }

	        iterator.next();
	      }

	      iterator.end();
	      vertexBuffers.push(vertexBuffer);
	    }

	    return vertexBuffers;
	  };

	  _proto._parseIndexBuffers = function _parseIndexBuffers(data, vertexBuffers) {
	    var modelData = data.model;
	    var indexBuffer = null;
	    var indexData = null;
	    var i;
	    var numIndices = 0;

	    for (i = 0; i < modelData.meshes.length; i++) {
	      var meshData = modelData.meshes[i];

	      if (meshData.indices !== undefined) {
	        numIndices += meshData.indices.length;
	      }
	    }

	    var maxVerts = 0;

	    for (i = 0; i < vertexBuffers.length; i++) {
	      maxVerts = Math.max(maxVerts, vertexBuffers[i].numVertices);
	    }

	    if (numIndices > 0) {
	      if (maxVerts > 0xFFFF && this._device.extUintElement) {
	        indexBuffer = new IndexBuffer(this._device, INDEXFORMAT_UINT32, numIndices);
	        indexData = new Uint32Array(indexBuffer.lock());
	      } else {
	        indexBuffer = new IndexBuffer(this._device, INDEXFORMAT_UINT16, numIndices);
	        indexData = new Uint16Array(indexBuffer.lock());
	      }
	    }

	    return {
	      buffer: indexBuffer,
	      data: indexData
	    };
	  };

	  _proto._parseMeshes = function _parseMeshes(data, skins, morphs, vertexBuffers, indexBuffer, indexData) {
	    var modelData = data.model;
	    var meshes = [];
	    var indexBase = 0;

	    for (var i = 0; i < modelData.meshes.length; i++) {
	      var meshData = modelData.meshes[i];
	      var meshAabb = meshData.aabb;
	      var min = meshAabb.min;
	      var max = meshAabb.max;
	      var aabb = new BoundingBox(new Vec3((max[0] + min[0]) * 0.5, (max[1] + min[1]) * 0.5, (max[2] + min[2]) * 0.5), new Vec3((max[0] - min[0]) * 0.5, (max[1] - min[1]) * 0.5, (max[2] - min[2]) * 0.5));
	      var indexed = meshData.indices !== undefined;
	      var mesh = new Mesh(this._device);
	      mesh.vertexBuffer = vertexBuffers[meshData.vertices];
	      mesh.indexBuffer[0] = indexed ? indexBuffer : null;
	      mesh.primitive[0].type = JSON_PRIMITIVE_TYPE[meshData.type];
	      mesh.primitive[0].base = indexed ? meshData.base + indexBase : meshData.base;
	      mesh.primitive[0].count = meshData.count;
	      mesh.primitive[0].indexed = indexed;
	      mesh.skin = meshData.skin !== undefined ? skins[meshData.skin] : null;
	      mesh.morph = meshData.morph !== undefined ? morphs[meshData.morph] : null;
	      mesh.aabb = aabb;

	      if (indexed) {
	        indexData.set(meshData.indices, indexBase);
	        indexBase += meshData.indices.length;
	      }

	      meshes.push(mesh);
	    }

	    if (indexBuffer !== null) {
	      indexBuffer.unlock();
	    }

	    return meshes;
	  };

	  _proto._parseMeshInstances = function _parseMeshInstances(data, nodes, meshes, skins, skinInstances, morphs, morphInstances) {
	    var modelData = data.model;
	    var meshInstances = [];
	    var i;

	    for (i = 0; i < modelData.meshInstances.length; i++) {
	      var meshInstanceData = modelData.meshInstances[i];
	      var node = nodes[meshInstanceData.node];
	      var mesh = meshes[meshInstanceData.mesh];
	      var meshInstance = new MeshInstance(mesh, this._defaultMaterial, node);

	      if (mesh.skin) {
	        var skinIndex = skins.indexOf(mesh.skin);
	        meshInstance.skinInstance = skinInstances[skinIndex];
	      }

	      if (mesh.morph) {
	        var morphIndex = morphs.indexOf(mesh.morph);
	        meshInstance.morphInstance = morphInstances[morphIndex];
	      }

	      meshInstances.push(meshInstance);
	    }

	    return meshInstances;
	  };

	  return JsonModelParser;
	}();

	var ModelHandler = function () {
	  function ModelHandler(app) {
	    this.handlerType = "model";
	    this._device = app.graphicsDevice;
	    this._parsers = [];
	    this._defaultMaterial = getDefaultMaterial(this._device);
	    this.maxRetries = 0;
	    this.addParser(new JsonModelParser(this._device, this._defaultMaterial), function (url, data) {
	      return path.getExtension(url) === '.json';
	    });
	    this.addParser(new GlbModelParser(this._device, this._defaultMaterial), function (url, data) {
	      return path.getExtension(url) === '.glb';
	    });
	  }

	  var _proto = ModelHandler.prototype;

	  _proto.load = function load(url, callback) {
	    if (typeof url === 'string') {
	      url = {
	        load: url,
	        original: url
	      };
	    }

	    var options = {
	      retry: this.maxRetries > 0,
	      maxRetries: this.maxRetries
	    };

	    if (url.load.startsWith('blob:') || url.load.startsWith('data:')) {
	      if (path.getExtension(url.original).toLowerCase() === '.glb') {
	        options.responseType = Http.ResponseType.ARRAY_BUFFER;
	      } else {
	        options.responseType = Http.ResponseType.JSON;
	      }
	    }

	    http.get(url.load, options, function (err, response) {
	      if (!callback) return;

	      if (!err) {
	        callback(null, response);
	      } else {
	        callback("Error loading model: " + url.original + " [" + err + "]");
	      }
	    });
	  };

	  _proto.open = function open(url, data) {
	    for (var i = 0; i < this._parsers.length; i++) {
	      var p = this._parsers[i];

	      if (p.decider(url, data)) {
	        return p.parser.parse(data);
	      }
	    }

	    return null;
	  };

	  _proto.patch = function patch(asset, assets) {
	    if (!asset.resource) return;
	    var data = asset.data;
	    var self = this;
	    asset.resource.meshInstances.forEach(function (meshInstance, i) {
	      if (data.mapping) {
	        var handleMaterial = function handleMaterial(asset) {
	          if (asset.resource) {
	            meshInstance.material = asset.resource;
	          } else {
	            asset.once('load', handleMaterial);
	            assets.load(asset);
	          }

	          asset.once('remove', function (asset) {
	            if (meshInstance.material === asset.resource) {
	              meshInstance.material = self._defaultMaterial;
	            }
	          });
	        };

	        if (!data.mapping[i]) {
	          meshInstance.material = self._defaultMaterial;
	          return;
	        }

	        var id = data.mapping[i].material;
	        var url = data.mapping[i].path;
	        var material;

	        if (id !== undefined) {
	          if (!id) {
	            meshInstance.material = self._defaultMaterial;
	          } else {
	            material = assets.get(id);

	            if (material) {
	              handleMaterial(material);
	            } else {
	              assets.once('add:' + id, handleMaterial);
	            }
	          }
	        } else if (url) {
	          var _path = asset.getAbsoluteUrl(data.mapping[i].path);

	          material = assets.getByUrl(_path);

	          if (material) {
	            handleMaterial(material);
	          } else {
	            assets.once('add:url:' + _path, handleMaterial);
	          }
	        }
	      }
	    });
	  };

	  _proto.addParser = function addParser(parser, decider) {
	    this._parsers.push({
	      parser: parser,
	      decider: decider
	    });
	  };

	  return ModelHandler;
	}();

	function onContainerAssetLoaded(containerAsset) {
	  var renderAsset = this;
	  if (!renderAsset.resource) return;
	  var containerResource = containerAsset.resource;
	  var render = containerResource.renders && containerResource.renders[renderAsset.data.renderIndex];

	  if (render) {
	    renderAsset.resource.meshes = render.resource.meshes;
	  }
	}

	function onContainerAssetAdded(containerAsset) {
	  var renderAsset = this;
	  renderAsset.registry.off('load:' + containerAsset.id, onContainerAssetLoaded, renderAsset);
	  renderAsset.registry.on('load:' + containerAsset.id, onContainerAssetLoaded, renderAsset);
	  renderAsset.registry.off('remove:' + containerAsset.id, onContainerAssetRemoved, renderAsset);
	  renderAsset.registry.once('remove:' + containerAsset.id, onContainerAssetRemoved, renderAsset);

	  if (!containerAsset.resource) {
	    renderAsset.registry.load(containerAsset);
	  } else {
	    onContainerAssetLoaded.call(renderAsset, containerAsset);
	  }
	}

	function onContainerAssetRemoved(containerAsset) {
	  var renderAsset = this;
	  renderAsset.registry.off('load:' + containerAsset.id, onContainerAssetLoaded, renderAsset);

	  if (renderAsset.resource) {
	    renderAsset.resource.destroy();
	  }
	}

	var RenderHandler = function () {
	  function RenderHandler(app) {
	    this.handlerType = "render";
	    this._registry = app.assets;
	  }

	  var _proto = RenderHandler.prototype;

	  _proto.load = function load(url, callback, asset) {};

	  _proto.open = function open(url, data) {
	    return new Render();
	  };

	  _proto.patch = function patch(asset, registry) {
	    if (!asset.data.containerAsset) return;
	    var containerAsset = registry.get(asset.data.containerAsset);

	    if (!containerAsset) {
	      registry.once('add:' + asset.data.containerAsset, onContainerAssetAdded, asset);
	      return;
	    }

	    onContainerAssetAdded.call(asset, containerAsset);
	  };

	  return RenderHandler;
	}();

	var ResourceHandler = function () {
	  function ResourceHandler() {}

	  var _proto = ResourceHandler.prototype;

	  _proto.load = function load(url, callback, asset) {
	    throw new Error('not implemented');
	  };

	  _proto.open = function open(url, data, asset) {
	    throw new Error('not implemented');
	  };

	  _proto.patch = function patch(asset, assets) {};

	  return ResourceHandler;
	}();

	var SceneHandler = function () {
	  function SceneHandler(app) {
	    this.handlerType = "scene";
	    this._app = app;
	    this.maxRetries = 0;
	  }

	  var _proto = SceneHandler.prototype;

	  _proto.load = function load(url, callback) {
	    SceneUtils.load(url, this.maxRetries, callback);
	  };

	  _proto.open = function open(url, data) {
	    this._app.systems.script.preloading = true;
	    var parser = new SceneParser(this._app, false);
	    var parent = parser.parse(data);
	    var scene = this._app.scene;
	    scene.root = parent;

	    this._app.applySceneSettings(data.settings);

	    this._app.systems.script.preloading = false;
	    return scene;
	  };

	  _proto.patch = function patch(asset, assets) {};

	  return SceneHandler;
	}();

	var SceneSettingsHandler = function () {
	  function SceneSettingsHandler(app) {
	    this._app = app;
	    this.maxRetries = 0;
	  }

	  var _proto = SceneSettingsHandler.prototype;

	  _proto.load = function load(url, callback) {
	    SceneUtils.load(url, this.maxRetries, callback);
	  };

	  _proto.open = function open(url, data) {
	    return data.settings;
	  };

	  return SceneSettingsHandler;
	}();

	var ShaderHandler = function () {
	  function ShaderHandler(app) {
	    this.handlerType = "shader";
	    this.maxRetries = 0;
	  }

	  var _proto = ShaderHandler.prototype;

	  _proto.load = function load(url, callback) {
	    if (typeof url === 'string') {
	      url = {
	        load: url,
	        original: url
	      };
	    }

	    http.get(url.load, {
	      retry: this.maxRetries > 0,
	      maxRetries: this.maxRetries
	    }, function (err, response) {
	      if (!err) {
	        callback(null, response);
	      } else {
	        callback("Error loading shader resource: " + url.original + " [" + err + "]");
	      }
	    });
	  };

	  _proto.open = function open(url, data) {
	    return data;
	  };

	  _proto.patch = function patch(asset, assets) {};

	  return ShaderHandler;
	}();

	function onTextureAtlasLoaded(atlasAsset) {
	  var spriteAsset = this;

	  if (spriteAsset.resource) {
	    spriteAsset.resource.atlas = atlasAsset.resource;
	  }
	}

	function onTextureAtlasAdded(atlasAsset) {
	  var spriteAsset = this;
	  spriteAsset.registry.load(atlasAsset);
	}

	var SpriteHandler = function () {
	  function SpriteHandler(app) {
	    this.handlerType = "sprite";
	    this._assets = app.assets;
	    this._device = app.graphicsDevice;
	    this.maxRetries = 0;
	  }

	  var _proto = SpriteHandler.prototype;

	  _proto.load = function load(url, callback) {
	    if (typeof url === 'string') {
	      url = {
	        load: url,
	        original: url
	      };
	    }

	    if (path.getExtension(url.original) === '.json') {
	      http.get(url.load, {
	        retry: this.maxRetries > 0,
	        maxRetries: this.maxRetries
	      }, function (err, response) {
	        if (!err) {
	          callback(null, response);
	        } else {
	          callback(err);
	        }
	      });
	    }
	  };

	  _proto.open = function open(url, data) {
	    var sprite = new Sprite(this._device);

	    if (url) {
	      sprite.__data = data;
	    }

	    return sprite;
	  };

	  _proto.patch = function patch(asset, assets) {
	    var sprite = asset.resource;

	    if (sprite.__data) {
	      asset.data.pixelsPerUnit = sprite.__data.pixelsPerUnit;
	      asset.data.renderMode = sprite.__data.renderMode;
	      asset.data.frameKeys = sprite.__data.frameKeys;

	      if (sprite.__data.textureAtlasAsset) {
	        var atlas = assets.getByUrl(sprite.__data.textureAtlasAsset);

	        if (atlas) {
	          asset.data.textureAtlasAsset = atlas.id;
	        } else {
	          console.warn('Could not find textureatlas with url: ' + sprite.__data.textureAtlasAsset);
	        }
	      }
	    }

	    sprite.startUpdate();
	    sprite.renderMode = asset.data.renderMode;
	    sprite.pixelsPerUnit = asset.data.pixelsPerUnit;
	    sprite.frameKeys = asset.data.frameKeys;

	    this._updateAtlas(asset);

	    sprite.endUpdate();
	    asset.off('change', this._onAssetChange, this);
	    asset.on('change', this._onAssetChange, this);
	  };

	  _proto._updateAtlas = function _updateAtlas(asset) {
	    var sprite = asset.resource;

	    if (!asset.data.textureAtlasAsset) {
	      sprite.atlas = null;
	      return;
	    }

	    this._assets.off('load:' + asset.data.textureAtlasAsset, onTextureAtlasLoaded, asset);

	    this._assets.on('load:' + asset.data.textureAtlasAsset, onTextureAtlasLoaded, asset);

	    var atlasAsset = this._assets.get(asset.data.textureAtlasAsset);

	    if (atlasAsset && atlasAsset.resource) {
	      sprite.atlas = atlasAsset.resource;
	    } else {
	      if (!atlasAsset) {
	        this._assets.off('add:' + asset.data.textureAtlasAsset, onTextureAtlasAdded, asset);

	        this._assets.on('add:' + asset.data.textureAtlasAsset, onTextureAtlasAdded, asset);
	      } else {
	        this._assets.load(atlasAsset);
	      }
	    }
	  };

	  _proto._onAssetChange = function _onAssetChange(asset, attribute, value, oldValue) {
	    if (attribute === 'data') {
	      if (value && value.textureAtlasAsset && oldValue && value.textureAtlasAsset !== oldValue.textureAtlasAsset) {
	        this._assets.off('load:' + oldValue.textureAtlasAsset, onTextureAtlasLoaded, asset);

	        this._assets.off('add:' + oldValue.textureAtlasAsset, onTextureAtlasAdded, asset);
	      }
	    }
	  };

	  return SpriteHandler;
	}();

	var Template = function () {
	  function Template(app, data) {
	    this._app = app;
	    this._data = data;
	    this._templateRoot = null;
	  }

	  var _proto = Template.prototype;

	  _proto.instantiate = function instantiate() {
	    if (!this._templateRoot) {
	      this._parseTemplate();
	    }

	    return this._templateRoot.clone();
	  };

	  _proto._parseTemplate = function _parseTemplate() {
	    var parser = new SceneParser(this._app, true);
	    this._templateRoot = parser.parse(this._data);
	  };

	  return Template;
	}();

	var TemplateHandler = function () {
	  function TemplateHandler(app) {
	    this.handlerType = "template";
	    this._app = app;
	    this.maxRetries = 0;
	  }

	  var _proto = TemplateHandler.prototype;

	  _proto.load = function load(url, callback) {
	    if (typeof url === 'string') {
	      url = {
	        load: url,
	        original: url
	      };
	    }

	    var options = {
	      retry: this.maxRetries > 0,
	      maxRetries: this.maxRetries
	    };
	    http.get(url.load, options, function (err, response) {
	      if (err) {
	        callback('Error requesting template: ' + url.original);
	      } else {
	        callback(err, response);
	      }
	    });
	  };

	  _proto.open = function open(url, data) {
	    return new Template(this._app, data);
	  };

	  return TemplateHandler;
	}();

	var TextHandler = function () {
	  function TextHandler(app) {
	    this.handlerType = "text";
	    this.maxRetries = 0;
	  }

	  var _proto = TextHandler.prototype;

	  _proto.load = function load(url, callback) {
	    if (typeof url === 'string') {
	      url = {
	        load: url,
	        original: url
	      };
	    }

	    http.get(url.load, {
	      retry: this.maxRetries > 0,
	      maxRetries: this.maxRetries
	    }, function (err, response) {
	      if (!err) {
	        callback(null, response);
	      } else {
	        callback("Error loading text resource: " + url.original + " [" + err + "]");
	      }
	    });
	  };

	  _proto.open = function open(url, data) {
	    return data;
	  };

	  _proto.patch = function patch(asset, assets) {};

	  return TextHandler;
	}();

	var BasisParser = function () {
	  function BasisParser(registry, device) {
	    this.device = device;
	    this.maxRetries = 0;
	  }

	  var _proto = BasisParser.prototype;

	  _proto.load = function load(url, callback, asset) {
	    var device = this.device;

	    var transcode = function transcode(data) {
	      var _asset$file, _asset$file$variants, _asset$file$variants$;

	      var basisModuleFound = basisTranscode(device, url.load, data, callback, {
	        isGGGR: ((asset == null ? void 0 : (_asset$file = asset.file) == null ? void 0 : (_asset$file$variants = _asset$file.variants) == null ? void 0 : (_asset$file$variants$ = _asset$file$variants.basis) == null ? void 0 : _asset$file$variants$.opt) & 8) !== 0
	      });

	      if (!basisModuleFound) {
	        callback("Basis module not found. Asset '" + asset.name + "' basis texture variant will not be loaded.");
	      }
	    };

	    Asset.fetchArrayBuffer(url.load, function (err, result) {
	      if (err) {
	        callback(err);
	      } else {
	        transcode(result);
	      }
	    }, asset, this.maxRetries);
	  };

	  _proto.open = function open(url, data, device) {
	    var texture = new Texture(device, {
	      name: url,
	      addressU: data.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
	      addressV: data.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
	      width: data.width,
	      height: data.height,
	      format: data.format,
	      cubemap: data.cubemap,
	      levels: data.levels
	    });
	    texture.upload();
	    return texture;
	  };

	  return BasisParser;
	}();

	var ImgParser = function () {
	  function ImgParser(registry) {
	    var _registry$_loader, _registry$_loader$_ap, _registry$_loader$_ap2;

	    this.crossOrigin = registry.prefix ? 'anonymous' : null;
	    this.maxRetries = 0;
	    var isWebGPU = (registry == null ? void 0 : (_registry$_loader = registry._loader) == null ? void 0 : (_registry$_loader$_ap = _registry$_loader._app) == null ? void 0 : (_registry$_loader$_ap2 = _registry$_loader$_ap.graphicsDevice) == null ? void 0 : _registry$_loader$_ap2.deviceType) === DEVICETYPE_WEBGPU;
	    this.useImageBitmap = isWebGPU;
	  }

	  var _proto = ImgParser.prototype;

	  _proto.load = function load(url, callback, asset) {
	    var _asset$file;

	    var hasContents = !!(asset != null && (_asset$file = asset.file) != null && _asset$file.contents);

	    if (hasContents) {
	      url = {
	        load: URL.createObjectURL(new Blob([asset.file.contents])),
	        original: url.original
	      };
	    }

	    var handler = function handler(err, result) {
	      if (hasContents) {
	        URL.revokeObjectURL(url.load);
	      }

	      callback(err, result);
	    };

	    var crossOrigin;

	    if (asset && asset.options && asset.options.hasOwnProperty('crossOrigin')) {
	      crossOrigin = asset.options.crossOrigin;
	    } else if (ABSOLUTE_URL.test(url.load)) {
	      crossOrigin = this.crossOrigin;
	    }

	    if (this.useImageBitmap) {
	      this._loadImageBitmap(url.load, url.original, crossOrigin, handler);
	    } else {
	      this._loadImage(url.load, url.original, crossOrigin, handler);
	    }
	  };

	  _proto.open = function open(url, data, device) {
	    var ext = path.getExtension(url).toLowerCase();
	    var format = ext === '.jpg' || ext === '.jpeg' ? PIXELFORMAT_R8_G8_B8 : PIXELFORMAT_R8_G8_B8_A8;
	    var texture = new Texture(device, {
	      name: url,
	      width: data.width,
	      height: data.height,
	      format: format
	    });
	    texture.setSource(data);
	    return texture;
	  };

	  _proto._loadImage = function _loadImage(url, originalUrl, crossOrigin, callback) {
	    var image = new Image();

	    if (crossOrigin) {
	      image.crossOrigin = crossOrigin;
	    }

	    var retries = 0;
	    var maxRetries = this.maxRetries;
	    var retryTimeout;

	    image.onload = function () {
	      callback(null, image);
	    };

	    image.onerror = function () {
	      if (retryTimeout) return;

	      if (maxRetries > 0 && ++retries <= maxRetries) {
	        var retryDelay = Math.pow(2, retries) * 100;
	        console.log("Error loading Texture from: '" + originalUrl + "' - Retrying in " + retryDelay + "ms...");
	        var idx = url.indexOf('?');
	        var separator = idx >= 0 ? '&' : '?';
	        retryTimeout = setTimeout(function () {
	          image.src = url + separator + 'retry=' + Date.now();
	          retryTimeout = null;
	        }, retryDelay);
	      } else {
	        callback("Error loading Texture from: '" + originalUrl + "'");
	      }
	    };

	    image.src = url;
	  };

	  _proto._loadImageBitmap = function _loadImageBitmap(url, originalUrl, crossOrigin, callback) {
	    var options = {
	      cache: true,
	      responseType: 'blob',
	      retry: this.maxRetries > 0,
	      maxRetries: this.maxRetries
	    };
	    http.get(url, options, function (err, blob) {
	      if (err) {
	        callback(err);
	      } else {
	        createImageBitmap(blob, {
	          premultiplyAlpha: 'none'
	        }).then(function (imageBitmap) {
	          return callback(null, imageBitmap);
	        }).catch(function (e) {
	          return callback(e);
	        });
	      }
	    });
	  };

	  return ImgParser;
	}();

	var IDENTIFIER = [0x58544BAB, 0xBB313120, 0x0A1A0A0D];
	var KNOWN_FORMATS = {
	  0x83F0: PIXELFORMAT_DXT1,
	  0x83F2: PIXELFORMAT_DXT3,
	  0x83F3: PIXELFORMAT_DXT5,
	  0x8D64: PIXELFORMAT_ETC1,
	  0x9274: PIXELFORMAT_ETC2_RGB,
	  0x9278: PIXELFORMAT_ETC2_RGBA,
	  0x8C00: PIXELFORMAT_PVRTC_4BPP_RGB_1,
	  0x8C01: PIXELFORMAT_PVRTC_2BPP_RGB_1,
	  0x8C02: PIXELFORMAT_PVRTC_4BPP_RGBA_1,
	  0x8C03: PIXELFORMAT_PVRTC_2BPP_RGBA_1,
	  0x8051: PIXELFORMAT_R8_G8_B8,
	  0x8058: PIXELFORMAT_R8_G8_B8_A8,
	  0x8C41: PIXELFORMAT_SRGB,
	  0x8C43: PIXELFORMAT_SRGBA,
	  0x8C3A: PIXELFORMAT_111110F,
	  0x881B: PIXELFORMAT_RGB16F,
	  0x881A: PIXELFORMAT_RGBA16F
	};

	function createContainer(pixelFormat, buffer, byteOffset, byteSize) {
	  return pixelFormat === PIXELFORMAT_111110F ? new Uint32Array(buffer, byteOffset, byteSize / 4) : new Uint8Array(buffer, byteOffset, byteSize);
	}

	var KtxParser = function () {
	  function KtxParser(registry) {
	    this.maxRetries = 0;
	  }

	  var _proto = KtxParser.prototype;

	  _proto.load = function load(url, callback, asset) {
	    Asset.fetchArrayBuffer(url.load, callback, asset, this.maxRetries);
	  };

	  _proto.open = function open(url, data, device) {
	    var textureData = this.parse(data);

	    if (!textureData) {
	      return null;
	    }

	    var texture = new Texture(device, {
	      name: url,
	      addressU: textureData.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
	      addressV: textureData.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
	      width: textureData.width,
	      height: textureData.height,
	      format: textureData.format,
	      cubemap: textureData.cubemap,
	      levels: textureData.levels
	    });
	    texture.upload();
	    return texture;
	  };

	  _proto.parse = function parse(data) {
	    var dataU32 = new Uint32Array(data);

	    if (IDENTIFIER[0] !== dataU32[0] || IDENTIFIER[1] !== dataU32[1] || IDENTIFIER[2] !== dataU32[2]) {
	      return null;
	    }

	    var header = {
	      endianness: dataU32[3],
	      glType: dataU32[4],
	      glTypeSize: dataU32[5],
	      glFormat: dataU32[6],
	      glInternalFormat: dataU32[7],
	      glBaseInternalFormat: dataU32[8],
	      pixelWidth: dataU32[9],
	      pixelHeight: dataU32[10],
	      pixelDepth: dataU32[11],
	      numberOfArrayElements: dataU32[12],
	      numberOfFaces: dataU32[13],
	      numberOfMipmapLevels: dataU32[14],
	      bytesOfKeyValueData: dataU32[15]
	    };

	    if (header.pixelDepth > 1) {
	      return null;
	    }

	    if (header.numberOfArrayElements !== 0) {
	      return null;
	    }

	    var format = KNOWN_FORMATS[header.glInternalFormat];

	    if (format === undefined) {
	      return null;
	    }

	    var offset = 16 + header.bytesOfKeyValueData / 4;
	    var isCubemap = header.numberOfFaces > 1;
	    var levels = [];

	    for (var mipmapLevel = 0; mipmapLevel < (header.numberOfMipmapLevels || 1); mipmapLevel++) {
	      var imageSizeInBytes = dataU32[offset++];

	      if (isCubemap) {
	        levels.push([]);
	      }

	      var target = isCubemap ? levels[mipmapLevel] : levels;

	      for (var face = 0; face < (isCubemap ? 6 : 1); ++face) {
	        target.push(createContainer(format, data, offset * 4, imageSizeInBytes));
	        offset += imageSizeInBytes + 3 >> 2;
	      }
	    }

	    return {
	      format: format,
	      width: header.pixelWidth,
	      height: header.pixelHeight,
	      levels: levels,
	      cubemap: isCubemap
	    };
	  };

	  return KtxParser;
	}();

	var KHRConstants = {
	  KHR_DF_MODEL_ETC1S: 163,
	  KHR_DF_MODEL_UASTC: 166
	};

	var Ktx2Parser = function () {
	  function Ktx2Parser(registry, device) {
	    this.maxRetries = 0;
	    this.device = device;
	  }

	  var _proto = Ktx2Parser.prototype;

	  _proto.load = function load(url, callback, asset) {
	    var _this = this;

	    Asset.fetchArrayBuffer(url.load, function (err, result) {
	      if (err) {
	        callback(err, result);
	      } else {
	        _this.parse(result, url, callback, asset);
	      }
	    }, asset, this.maxRetries);
	  };

	  _proto.open = function open(url, data, device) {
	    var texture = new Texture(device, {
	      name: url,
	      addressU: data.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
	      addressV: data.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
	      width: data.width,
	      height: data.height,
	      format: data.format,
	      cubemap: data.cubemap,
	      levels: data.levels
	    });
	    texture.upload();
	    return texture;
	  };

	  _proto.parse = function parse(arraybuffer, url, callback, asset) {
	    var rs = new ReadStream(arraybuffer);
	    var magic = [rs.readU32be(), rs.readU32be(), rs.readU32be()];

	    if (magic[0] !== 0xAB4B5458 || magic[1] !== 0x203230BB || magic[2] !== 0x0D0A1A0A) {
	      return null;
	    }

	    var header = {
	      vkFormat: rs.readU32(),
	      typeSize: rs.readU32(),
	      pixelWidth: rs.readU32(),
	      pixelHeight: rs.readU32(),
	      pixelDepth: rs.readU32(),
	      layerCount: rs.readU32(),
	      faceCount: rs.readU32(),
	      levelCount: rs.readU32(),
	      supercompressionScheme: rs.readU32()
	    };
	    var index = {
	      dfdByteOffset: rs.readU32(),
	      dfdByteLength: rs.readU32(),
	      kvdByteOffset: rs.readU32(),
	      kvdByteLength: rs.readU32(),
	      sgdByteOffset: rs.readU64(),
	      sgdByteLength: rs.readU64()
	    };
	    var levels = [];

	    for (var i = 0; i < Math.max(1, header.levelCount); ++i) {
	      levels.push({
	        byteOffset: rs.readU64(),
	        byteLength: rs.readU64(),
	        uncompressedByteLength: rs.readU64()
	      });
	    }

	    var dfdTotalSize = rs.readU32();

	    if (dfdTotalSize !== index.kvdByteOffset - index.dfdByteOffset) {
	      return null;
	    }

	    rs.skip(8);
	    var colorModel = rs.readU8();
	    rs.skip(index.dfdByteLength - 9);
	    rs.skip(index.kvdByteLength);

	    if (header.supercompressionScheme === 1 || colorModel === KHRConstants.KHR_DF_MODEL_UASTC) {
	      var _asset$file, _asset$file$variants, _asset$file$variants$;

	      var basisModuleFound = basisTranscode(this.device, url.load, arraybuffer, callback, {
	        isGGGR: ((asset == null ? void 0 : (_asset$file = asset.file) == null ? void 0 : (_asset$file$variants = _asset$file.variants) == null ? void 0 : (_asset$file$variants$ = _asset$file$variants.basis) == null ? void 0 : _asset$file$variants$.opt) & 8) !== 0,
	        isKTX2: true
	      });

	      if (!basisModuleFound) {
	        callback('Basis module not found. Asset "' + asset.name + '" basis texture variant will not be loaded.');
	      }
	    } else {
	      callback('unsupported KTX2 pixel format');
	    }
	  };

	  return Ktx2Parser;
	}();

	var DdsParser = function () {
	  function DdsParser(registry) {
	    this.maxRetries = 0;
	  }

	  var _proto = DdsParser.prototype;

	  _proto.load = function load(url, callback, asset) {
	    Asset.fetchArrayBuffer(url.load, callback, asset, this.maxRetries);
	  };

	  _proto.open = function open(url, data, device) {
	    var header = new Uint32Array(data, 0, 128 / 4);
	    var width = header[4];
	    var height = header[3];
	    var mips = Math.max(header[7], 1);
	    var isFourCc = header[20] === 4;
	    var fcc = header[21];
	    var bpp = header[22];
	    var isCubemap = header[28] === 65024;
	    var FCC_DXT1 = 827611204;
	    var FCC_DXT5 = 894720068;
	    var FCC_FP16 = 113;
	    var FCC_FP32 = 116;
	    var FCC_ETC1 = 826496069;
	    var FCC_PVRTC_2BPP_RGB_1 = 825438800;
	    var FCC_PVRTC_2BPP_RGBA_1 = 825504336;
	    var FCC_PVRTC_4BPP_RGB_1 = 825439312;
	    var FCC_PVRTC_4BPP_RGBA_1 = 825504848;
	    var compressed = false;
	    var etc1 = false;
	    var pvrtc2 = false;
	    var pvrtc4 = false;
	    var format = null;
	    var componentSize = 1;
	    var texture;

	    if (isFourCc) {
	      if (fcc === FCC_DXT1) {
	        format = PIXELFORMAT_DXT1;
	        compressed = true;
	      } else if (fcc === FCC_DXT5) {
	        format = PIXELFORMAT_DXT5;
	        compressed = true;
	      } else if (fcc === FCC_FP16) {
	        format = PIXELFORMAT_RGBA16F;
	        componentSize = 2;
	      } else if (fcc === FCC_FP32) {
	        format = PIXELFORMAT_RGBA32F;
	        componentSize = 4;
	      } else if (fcc === FCC_ETC1) {
	        format = PIXELFORMAT_ETC1;
	        compressed = true;
	        etc1 = true;
	      } else if (fcc === FCC_PVRTC_2BPP_RGB_1 || fcc === FCC_PVRTC_2BPP_RGBA_1) {
	        format = fcc === FCC_PVRTC_2BPP_RGB_1 ? PIXELFORMAT_PVRTC_2BPP_RGB_1 : PIXELFORMAT_PVRTC_2BPP_RGBA_1;
	        compressed = true;
	        pvrtc2 = true;
	      } else if (fcc === FCC_PVRTC_4BPP_RGB_1 || fcc === FCC_PVRTC_4BPP_RGBA_1) {
	        format = fcc === FCC_PVRTC_4BPP_RGB_1 ? PIXELFORMAT_PVRTC_4BPP_RGB_1 : PIXELFORMAT_PVRTC_4BPP_RGBA_1;
	        compressed = true;
	        pvrtc4 = true;
	      }
	    } else {
	      if (bpp === 32) {
	        format = PIXELFORMAT_R8_G8_B8_A8;
	      }
	    }

	    if (!format) {
	      texture = new Texture(device, {
	        width: 4,
	        height: 4,
	        format: PIXELFORMAT_R8_G8_B8,
	        name: 'dds-legacy-empty'
	      });
	      return texture;
	    }

	    texture = new Texture(device, {
	      name: url,
	      addressU: isCubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
	      addressV: isCubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
	      width: width,
	      height: height,
	      format: format,
	      cubemap: isCubemap,
	      mipmaps: mips > 1
	    });
	    var offset = 128;
	    var faces = isCubemap ? 6 : 1;
	    var mipSize;
	    var DXT_BLOCK_WIDTH = 4;
	    var DXT_BLOCK_HEIGHT = 4;
	    var blockSize = fcc === FCC_DXT1 ? 8 : 16;
	    var numBlocksAcross, numBlocksDown, numBlocks;

	    for (var face = 0; face < faces; face++) {
	      var mipWidth = width;
	      var mipHeight = height;

	      for (var i = 0; i < mips; i++) {
	        if (compressed) {
	          if (etc1) {
	            mipSize = Math.floor((mipWidth + 3) / 4) * Math.floor((mipHeight + 3) / 4) * 8;
	          } else if (pvrtc2) {
	            mipSize = Math.max(mipWidth, 16) * Math.max(mipHeight, 8) / 4;
	          } else if (pvrtc4) {
	            mipSize = Math.max(mipWidth, 8) * Math.max(mipHeight, 8) / 2;
	          } else {
	            numBlocksAcross = Math.floor((mipWidth + DXT_BLOCK_WIDTH - 1) / DXT_BLOCK_WIDTH);
	            numBlocksDown = Math.floor((mipHeight + DXT_BLOCK_HEIGHT - 1) / DXT_BLOCK_HEIGHT);
	            numBlocks = numBlocksAcross * numBlocksDown;
	            mipSize = numBlocks * blockSize;
	          }
	        } else {
	          mipSize = mipWidth * mipHeight * 4;
	        }

	        var mipBuff = format === PIXELFORMAT_RGBA32F ? new Float32Array(data, offset, mipSize) : format === PIXELFORMAT_RGBA16F ? new Uint16Array(data, offset, mipSize) : new Uint8Array(data, offset, mipSize);

	        if (!isCubemap) {
	          texture._levels[i] = mipBuff;
	        } else {
	          if (!texture._levels[i]) texture._levels[i] = [];
	          texture._levels[i][face] = mipBuff;
	        }

	        offset += mipSize * componentSize;
	        mipWidth = Math.max(mipWidth * 0.5, 1);
	        mipHeight = Math.max(mipHeight * 0.5, 1);
	      }
	    }

	    texture.upload();
	    return texture;
	  };

	  return DdsParser;
	}();

	var HdrParser = function () {
	  function HdrParser(registry) {
	    this.maxRetries = 0;
	  }

	  var _proto = HdrParser.prototype;

	  _proto.load = function load(url, callback, asset) {
	    Asset.fetchArrayBuffer(url.load, callback, asset, this.maxRetries);
	  };

	  _proto.open = function open(url, data, device) {
	    var textureData = this.parse(data);

	    if (!textureData) {
	      return null;
	    }

	    var texture = new Texture(device, {
	      name: url,
	      addressU: ADDRESS_REPEAT,
	      addressV: ADDRESS_CLAMP_TO_EDGE,
	      minFilter: FILTER_NEAREST,
	      magFilter: FILTER_NEAREST,
	      width: textureData.width,
	      height: textureData.height,
	      levels: textureData.levels,
	      format: PIXELFORMAT_R8_G8_B8_A8,
	      type: TEXTURETYPE_RGBE,
	      mipmaps: false
	    });
	    texture.upload();
	    return texture;
	  };

	  _proto.parse = function parse(data) {
	    var readStream = new ReadStream(data);
	    var magic = readStream.readLine();

	    if (!magic.startsWith('#?RADIANCE')) {
	      return null;
	    }

	    var variables = {};

	    while (true) {
	      var line = readStream.readLine();

	      if (line.length === 0) {
	        break;
	      } else {
	        var parts = line.split('=');

	        if (parts.length === 2) {
	          variables[parts[0]] = parts[1];
	        }
	      }
	    }

	    if (!variables.hasOwnProperty('FORMAT')) {
	      return null;
	    }

	    var resolution = readStream.readLine().split(' ');

	    if (resolution.length !== 4) {
	      return null;
	    }

	    var height = parseInt(resolution[1], 10);
	    var width = parseInt(resolution[3], 10);

	    var pixels = this._readPixels(readStream, width, height, resolution[0] === '-Y');

	    if (!pixels) {
	      return null;
	    }

	    return {
	      width: width,
	      height: height,
	      levels: [pixels]
	    };
	  };

	  _proto._readPixels = function _readPixels(readStream, width, height, flipY) {
	    if (width < 8 || width > 0x7fff) {
	      return this._readPixelsFlat(readStream, width, height);
	    }

	    var rgbe = [0, 0, 0, 0];
	    readStream.readArray(rgbe);

	    if (rgbe[0] !== 2 || rgbe[1] !== 2 || (rgbe[2] & 0x80) !== 0) {
	      readStream.skip(-4);
	      return this._readPixelsFlat(readStream, width, height);
	    }

	    var buffer = new ArrayBuffer(width * height * 4);
	    var view = new Uint8Array(buffer);
	    var scanstart = flipY ? 0 : width * 4 * (height - 1);
	    var x, y, i, channel, count, value;

	    for (y = 0; y < height; ++y) {
	      if (y) {
	        readStream.readArray(rgbe);
	      }

	      if ((rgbe[2] << 8) + rgbe[3] !== width) {
	        return null;
	      }

	      for (channel = 0; channel < 4; ++channel) {
	        x = 0;

	        while (x < width) {
	          count = readStream.readU8();

	          if (count > 128) {
	            count -= 128;

	            if (x + count > width) {
	              return null;
	            }

	            value = readStream.readU8();

	            for (i = 0; i < count; ++i) {
	              view[scanstart + channel + 4 * x++] = value;
	            }
	          } else {
	            if (count === 0 || x + count > width) {
	              return null;
	            }

	            for (i = 0; i < count; ++i) {
	              view[scanstart + channel + 4 * x++] = readStream.readU8();
	            }
	          }
	        }
	      }

	      scanstart += width * 4 * (flipY ? 1 : -1);
	    }

	    return view;
	  };

	  _proto._readPixelsFlat = function _readPixelsFlat(readStream, width, height) {
	    return readStream.remainingBytes === width * height * 4 ? new Uint8Array(readStream.arraybuffer, readStream.offset) : null;
	  };

	  return HdrParser;
	}();

	var JSON_ADDRESS_MODE$1 = {
	  'repeat': ADDRESS_REPEAT,
	  'clamp': ADDRESS_CLAMP_TO_EDGE,
	  'mirror': ADDRESS_MIRRORED_REPEAT
	};
	var JSON_FILTER_MODE$1 = {
	  'nearest': FILTER_NEAREST,
	  'linear': FILTER_LINEAR,
	  'nearest_mip_nearest': FILTER_NEAREST_MIPMAP_NEAREST,
	  'linear_mip_nearest': FILTER_LINEAR_MIPMAP_NEAREST,
	  'nearest_mip_linear': FILTER_NEAREST_MIPMAP_LINEAR,
	  'linear_mip_linear': FILTER_LINEAR_MIPMAP_LINEAR
	};
	var JSON_TEXTURE_TYPE = {
	  'default': TEXTURETYPE_DEFAULT,
	  'rgbm': TEXTURETYPE_RGBM,
	  'rgbe': TEXTURETYPE_RGBE,
	  'rgbp': TEXTURETYPE_RGBP,
	  'swizzleGGGR': TEXTURETYPE_SWIZZLEGGGR
	};

	var TextureParser = function () {
	  function TextureParser() {}

	  var _proto = TextureParser.prototype;

	  _proto.load = function load(url, callback, asset) {
	    throw new Error('not implemented');
	  };

	  _proto.open = function open(url, data, device) {
	    throw new Error('not implemented');
	  };

	  return TextureParser;
	}();

	var _completePartialMipmapChain = function _completePartialMipmapChain(texture) {
	  var requiredMipLevels = Math.log2(Math.max(texture._width, texture._height)) + 1;

	  var isHtmlElement = function isHtmlElement(object) {
	    return object instanceof HTMLCanvasElement || object instanceof HTMLImageElement || object instanceof HTMLVideoElement;
	  };

	  if (!(texture._format === PIXELFORMAT_R8_G8_B8_A8 || texture._format === PIXELFORMAT_RGBA32F) || texture._volume || texture._compressed || texture._levels.length === 1 || texture._levels.length === requiredMipLevels || isHtmlElement(texture._cubemap ? texture._levels[0][0] : texture._levels[0])) {
	    return;
	  }

	  var downsample = function downsample(width, height, data) {
	    var sampledWidth = Math.max(1, width >> 1);
	    var sampledHeight = Math.max(1, height >> 1);
	    var sampledData = new data.constructor(sampledWidth * sampledHeight * 4);
	    var xs = Math.floor(width / sampledWidth);
	    var ys = Math.floor(height / sampledHeight);
	    var xsys = xs * ys;

	    for (var y = 0; y < sampledHeight; ++y) {
	      for (var x = 0; x < sampledWidth; ++x) {
	        for (var e = 0; e < 4; ++e) {
	          var sum = 0;

	          for (var sy = 0; sy < ys; ++sy) {
	            for (var sx = 0; sx < xs; ++sx) {
	              sum += data[(x * xs + sx + (y * ys + sy) * width) * 4 + e];
	            }
	          }

	          sampledData[(x + y * sampledWidth) * 4 + e] = sum / xsys;
	        }
	      }
	    }

	    return sampledData;
	  };

	  for (var level = texture._levels.length; level < requiredMipLevels; ++level) {
	    var width = Math.max(1, texture._width >> level - 1);
	    var height = Math.max(1, texture._height >> level - 1);

	    if (texture._cubemap) {
	      var mips = [];

	      for (var face = 0; face < 6; ++face) {
	        mips.push(downsample(width, height, texture._levels[level - 1][face]));
	      }

	      texture._levels.push(mips);
	    } else {
	      texture._levels.push(downsample(width, height, texture._levels[level - 1]));
	    }
	  }

	  texture._levelsUpdated = texture._cubemap ? [[true, true, true, true, true, true]] : [true];
	};

	var TextureHandler = function () {
	  function TextureHandler(app) {
	    this.handlerType = "texture";
	    var assets = app.assets;
	    var device = app.graphicsDevice;
	    this._device = device;
	    this._assets = assets;
	    this._loader = app.loader;
	    this.imgParser = new ImgParser(assets);
	    this.parsers = {
	      dds: new DdsParser(assets),
	      ktx: new KtxParser(assets),
	      ktx2: new Ktx2Parser(assets, device),
	      basis: new BasisParser(assets, device),
	      hdr: new HdrParser(assets)
	    };
	  }

	  var _proto2 = TextureHandler.prototype;

	  _proto2._getUrlWithoutParams = function _getUrlWithoutParams(url) {
	    return url.indexOf('?') >= 0 ? url.split('?')[0] : url;
	  };

	  _proto2._getParser = function _getParser(url) {
	    var ext = path.getExtension(this._getUrlWithoutParams(url)).toLowerCase().replace('.', '');
	    return this.parsers[ext] || this.imgParser;
	  };

	  _proto2.load = function load(url, callback, asset) {
	    if (typeof url === 'string') {
	      url = {
	        load: url,
	        original: url
	      };
	    }

	    this._getParser(url.original).load(url, callback, asset);
	  };

	  _proto2.open = function open(url, data, asset) {
	    if (!url) return undefined;

	    var texture = this._getParser(url).open(url, data, this._device);

	    if (texture === null) {
	      texture = new Texture(this._device, {
	        width: 4,
	        height: 4,
	        format: PIXELFORMAT_R8_G8_B8
	      });
	    } else {
	      _completePartialMipmapChain(texture);

	      if (data.unswizzledGGGR) {
	        asset.file.variants.basis.opt &= ~8;
	      }
	    }

	    return texture;
	  };

	  _proto2.patch = function patch(asset, assets) {
	    var texture = asset.resource;

	    if (!texture) {
	      return;
	    }

	    if (asset.name && asset.name.length > 0) {
	      texture.name = asset.name;
	    }

	    var assetData = asset.data;

	    if (assetData.hasOwnProperty('minfilter')) {
	      texture.minFilter = JSON_FILTER_MODE$1[assetData.minfilter];
	    }

	    if (assetData.hasOwnProperty('magfilter')) {
	      texture.magFilter = JSON_FILTER_MODE$1[assetData.magfilter];
	    }

	    if (!texture.cubemap) {
	      if (assetData.hasOwnProperty('addressu')) {
	        texture.addressU = JSON_ADDRESS_MODE$1[assetData.addressu];
	      }

	      if (assetData.hasOwnProperty('addressv')) {
	        texture.addressV = JSON_ADDRESS_MODE$1[assetData.addressv];
	      }
	    }

	    if (assetData.hasOwnProperty('mipmaps')) {
	      texture.mipmaps = assetData.mipmaps;
	    }

	    if (assetData.hasOwnProperty('anisotropy')) {
	      texture.anisotropy = assetData.anisotropy;
	    }

	    if (assetData.hasOwnProperty('flipY')) {
	      texture.flipY = !!assetData.flipY;
	    }

	    if (assetData.hasOwnProperty('type')) {
	      texture.type = JSON_TEXTURE_TYPE[assetData.type];
	    } else if (assetData.hasOwnProperty('rgbm') && assetData.rgbm) {
	      texture.type = TEXTURETYPE_RGBM;
	    } else if (asset.file && (asset.file.opt & 8) !== 0) {
	      texture.type = TEXTURETYPE_SWIZZLEGGGR;
	    }
	  };

	  _createClass(TextureHandler, [{
	    key: "crossOrigin",
	    get: function get() {
	      return this.imgParser.crossOrigin;
	    },
	    set: function set(value) {
	      this.imgParser.crossOrigin = value;
	    }
	  }, {
	    key: "maxRetries",
	    get: function get() {
	      return this.imgParser.maxRetries;
	    },
	    set: function set(value) {
	      this.imgParser.maxRetries = value;

	      for (var parser in this.parsers) {
	        if (this.parsers.hasOwnProperty(parser)) {
	          this.parsers[parser].maxRetries = value;
	        }
	      }
	    }
	  }]);

	  return TextureHandler;
	}();

	var JSON_ADDRESS_MODE = {
	  'repeat': ADDRESS_REPEAT,
	  'clamp': ADDRESS_CLAMP_TO_EDGE,
	  'mirror': ADDRESS_MIRRORED_REPEAT
	};
	var JSON_FILTER_MODE = {
	  'nearest': FILTER_NEAREST,
	  'linear': FILTER_LINEAR,
	  'nearest_mip_nearest': FILTER_NEAREST_MIPMAP_NEAREST,
	  'linear_mip_nearest': FILTER_LINEAR_MIPMAP_NEAREST,
	  'nearest_mip_linear': FILTER_NEAREST_MIPMAP_LINEAR,
	  'linear_mip_linear': FILTER_LINEAR_MIPMAP_LINEAR
	};
	var regexFrame = /^data\.frames\.(\d+)$/;

	var TextureAtlasHandler = function () {
	  function TextureAtlasHandler(app) {
	    this.handlerType = "textureatlas";
	    this._loader = app.loader;
	    this.maxRetries = 0;
	  }

	  var _proto = TextureAtlasHandler.prototype;

	  _proto.load = function load(url, callback) {
	    if (typeof url === 'string') {
	      url = {
	        load: url,
	        original: url
	      };
	    }

	    var self = this;

	    var handler = this._loader.getHandler('texture');

	    if (path.getExtension(url.original) === '.json') {
	      http.get(url.load, {
	        retry: this.maxRetries > 0,
	        maxRetries: this.maxRetries
	      }, function (err, response) {
	        if (!err) {
	          var textureUrl = url.original.replace('.json', '.png');

	          self._loader.load(textureUrl, 'texture', function (err, texture) {
	            if (err) {
	              callback(err);
	            } else {
	              callback(null, {
	                data: response,
	                texture: texture
	              });
	            }
	          });
	        } else {
	          callback(err);
	        }
	      });
	    } else {
	      return handler.load(url, callback);
	    }
	  };

	  _proto.open = function open(url, data) {
	    var resource = new TextureAtlas();

	    if (data.texture && data.data) {
	      resource.texture = data.texture;
	      resource.__data = data.data;
	    } else {
	      var handler = this._loader.getHandler('texture');

	      var texture = handler.open(url, data);
	      if (!texture) return null;
	      resource.texture = texture;
	    }

	    return resource;
	  };

	  _proto.patch = function patch(asset, assets) {
	    if (!asset.resource) {
	      return;
	    }

	    if (asset.resource.__data) {
	      if (asset.resource.__data.minfilter !== undefined) asset.data.minfilter = asset.resource.__data.minfilter;
	      if (asset.resource.__data.magfilter !== undefined) asset.data.magfilter = asset.resource.__data.magfilter;
	      if (asset.resource.__data.addressu !== undefined) asset.data.addressu = asset.resource.__data.addressu;
	      if (asset.resource.__data.addressv !== undefined) asset.data.addressv = asset.resource.__data.addressv;
	      if (asset.resource.__data.mipmaps !== undefined) asset.data.mipmaps = asset.resource.__data.mipmaps;
	      if (asset.resource.__data.anisotropy !== undefined) asset.data.anisotropy = asset.resource.__data.anisotropy;
	      if (asset.resource.__data.rgbm !== undefined) asset.data.rgbm = !!asset.resource.__data.rgbm;
	      asset.data.frames = asset.resource.__data.frames;
	      delete asset.resource.__data;
	    }

	    var texture = asset.resource.texture;

	    if (texture) {
	      texture.name = asset.name;
	      if (asset.data.hasOwnProperty('minfilter') && texture.minFilter !== JSON_FILTER_MODE[asset.data.minfilter]) texture.minFilter = JSON_FILTER_MODE[asset.data.minfilter];
	      if (asset.data.hasOwnProperty('magfilter') && texture.magFilter !== JSON_FILTER_MODE[asset.data.magfilter]) texture.magFilter = JSON_FILTER_MODE[asset.data.magfilter];
	      if (asset.data.hasOwnProperty('addressu') && texture.addressU !== JSON_ADDRESS_MODE[asset.data.addressu]) texture.addressU = JSON_ADDRESS_MODE[asset.data.addressu];
	      if (asset.data.hasOwnProperty('addressv') && texture.addressV !== JSON_ADDRESS_MODE[asset.data.addressv]) texture.addressV = JSON_ADDRESS_MODE[asset.data.addressv];
	      if (asset.data.hasOwnProperty('mipmaps') && texture.mipmaps !== asset.data.mipmaps) texture.mipmaps = asset.data.mipmaps;
	      if (asset.data.hasOwnProperty('anisotropy') && texture.anisotropy !== asset.data.anisotropy) texture.anisotropy = asset.data.anisotropy;

	      if (asset.data.hasOwnProperty('rgbm')) {
	        var type = asset.data.rgbm ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT;

	        if (texture.type !== type) {
	          texture.type = type;
	        }
	      }
	    }

	    asset.resource.texture = texture;
	    var frames = {};

	    for (var key in asset.data.frames) {
	      var frame = asset.data.frames[key];
	      frames[key] = {
	        rect: new Vec4(frame.rect),
	        pivot: new Vec2(frame.pivot),
	        border: new Vec4(frame.border)
	      };
	    }

	    asset.resource.frames = frames;
	    asset.off('change', this._onAssetChange, this);
	    asset.on('change', this._onAssetChange, this);
	  };

	  _proto._onAssetChange = function _onAssetChange(asset, attribute, value) {
	    var frame;

	    if (attribute === 'data' || attribute === 'data.frames') {
	      var frames = {};

	      for (var key in value.frames) {
	        frame = value.frames[key];
	        frames[key] = {
	          rect: new Vec4(frame.rect),
	          pivot: new Vec2(frame.pivot),
	          border: new Vec4(frame.border)
	        };
	      }

	      asset.resource.frames = frames;
	    } else {
	      var match = attribute.match(regexFrame);

	      if (match) {
	        var frameKey = match[1];

	        if (value) {
	          if (!asset.resource.frames[frameKey]) {
	            asset.resource.frames[frameKey] = {
	              rect: new Vec4(value.rect),
	              pivot: new Vec2(value.pivot),
	              border: new Vec4(value.border)
	            };
	          } else {
	            frame = asset.resource.frames[frameKey];
	            frame.rect.set(value.rect[0], value.rect[1], value.rect[2], value.rect[3]);
	            frame.pivot.set(value.pivot[0], value.pivot[1]);
	            frame.border.set(value.border[0], value.border[1], value.border[2], value.border[3]);
	          }

	          asset.resource.fire('set:frame', frameKey, asset.resource.frames[frameKey]);
	        } else {
	          if (asset.resource.frames[frameKey]) {
	            delete asset.resource.frames[frameKey];
	            asset.resource.fire('remove:frame', frameKey);
	          }
	        }
	      }
	    }
	  };

	  return TextureAtlasHandler;
	}();

	var AssetListLoader = function (_EventHandler) {
	  _inheritsLoose(AssetListLoader, _EventHandler);

	  function AssetListLoader(assetList, assetRegistry) {
	    var _this;

	    _this = _EventHandler.call(this) || this;
	    _this._assets = new Set();
	    _this._loadingAssets = new Set();
	    _this._waitingAssets = new Set();
	    _this._registry = assetRegistry;
	    _this._loading = false;
	    _this._loaded = false;
	    _this._failed = [];
	    assetList.forEach(function (a) {
	      if (a instanceof Asset) {
	        if (!a.registry) {
	          a.registry = assetRegistry;
	        }

	        _this._assets.add(a);
	      } else {
	        var asset = assetRegistry.get(a);

	        if (asset) {
	          _this._assets.add(asset);
	        } else {
	          _this._waitForAsset(a);
	        }
	      }
	    });
	    return _this;
	  }

	  var _proto = AssetListLoader.prototype;

	  _proto.destroy = function destroy() {
	    var self = this;

	    this._registry.off("load", this._onLoad);

	    this._registry.off("error", this._onError);

	    this._waitingAssets.forEach(function (id) {
	      self._registry.off("add:" + id, this._onAddAsset);
	    });

	    this.off("progress");
	    this.off("load");
	  };

	  _proto._assetHasDependencies = function _assetHasDependencies(asset) {
	    var _asset$file;

	    return asset.type === 'model' && ((_asset$file = asset.file) == null ? void 0 : _asset$file.url) && asset.file.url && asset.file.url.match(/.json$/g);
	  };

	  _proto.load = function load(done, scope) {
	    var _this2 = this;

	    if (this._loading) {
	      return;
	    }

	    this._loading = true;
	    this._callback = done;
	    this._scope = scope;

	    this._registry.on("load", this._onLoad, this);

	    this._registry.on("error", this._onError, this);

	    var loadingAssets = false;

	    this._assets.forEach(function (asset) {
	      if (!asset.loaded) {
	        loadingAssets = true;

	        if (_this2._assetHasDependencies(asset)) {
	          _this2._registry.loadFromUrl(asset.file.url, asset.type, function (err, loadedAsset) {
	            if (err) {
	              _this2._onError(err, asset);

	              return;
	            }

	            _this2._onLoad(asset);
	          });
	        }

	        _this2._loadingAssets.add(asset);

	        _this2._registry.add(asset);
	      }
	    });

	    this._loadingAssets.forEach(function (asset) {
	      if (!_this2._assetHasDependencies(asset)) {
	        _this2._registry.load(asset);
	      }
	    });

	    if (!loadingAssets && this._waitingAssets.size === 0) {
	      this._loadingComplete();
	    }
	  };

	  _proto.ready = function ready(done, scope) {
	    if (scope === void 0) {
	      scope = this;
	    }

	    if (this._loaded) {
	      done.call(scope, Array.from(this._assets));
	    } else {
	      this.once("load", function (assets) {
	        done.call(scope, assets);
	      });
	    }
	  };

	  _proto._loadingComplete = function _loadingComplete() {
	    if (this._loaded) return;
	    this._loaded = true;

	    this._registry.off("load", this._onLoad, this);

	    this._registry.off("error", this._onError, this);

	    if (this._failed.length) {
	      if (this._callback) {
	        this._callback.call(this._scope, "Failed to load some assets", this._failed);
	      }

	      this.fire("error", this._failed);
	    } else {
	      if (this._callback) {
	        this._callback.call(this._scope);
	      }

	      this.fire("load", Array.from(this._assets));
	    }
	  };

	  _proto._onLoad = function _onLoad(asset) {
	    var _this3 = this;

	    if (this._loadingAssets.has(asset)) {
	      this.fire("progress", asset);

	      this._loadingAssets.delete(asset);
	    }

	    if (this._loadingAssets.size === 0) {
	      setTimeout(function () {
	        _this3._loadingComplete(_this3._failed);
	      }, 0);
	    }
	  };

	  _proto._onError = function _onError(err, asset) {
	    var _this4 = this;

	    if (this._loadingAssets.has(asset)) {
	      this._failed.push(asset);

	      this._loadingAssets.delete(asset);
	    }

	    if (this._loadingAssets.size === 0) {
	      setTimeout(function () {
	        _this4._loadingComplete(_this4._failed);
	      }, 0);
	    }
	  };

	  _proto._onAddAsset = function _onAddAsset(asset) {
	    this._waitingAssets.delete(asset);

	    this._assets.add(asset);

	    if (!asset.loaded) {
	      this._loadingAssets.add(asset);

	      this._registry.load(asset);
	    }
	  };

	  _proto._waitForAsset = function _waitForAsset(assetId) {
	    this._waitingAssets.add(assetId);

	    this._registry.once('add:' + assetId, this._onAddAsset, this);
	  };

	  return AssetListLoader;
	}(EventHandler);

	var LocalizedAsset = function (_EventHandler) {
	  _inheritsLoose(LocalizedAsset, _EventHandler);

	  function LocalizedAsset(app) {
	    var _this;

	    _this = _EventHandler.call(this) || this;
	    _this._app = app;
	    app.i18n.on('set:locale', _this._onSetLocale, _assertThisInitialized(_this));
	    _this._autoLoad = false;
	    _this._disableLocalization = false;
	    _this._defaultAsset = null;
	    _this._localizedAsset = null;
	    return _this;
	  }

	  var _proto = LocalizedAsset.prototype;

	  _proto._bindDefaultAsset = function _bindDefaultAsset() {
	    var asset = this._app.assets.get(this._defaultAsset);

	    if (!asset) {
	      this._app.assets.once('add:' + this._defaultAsset, this._onDefaultAssetAdd, this);
	    } else {
	      this._onDefaultAssetAdd(asset);
	    }
	  };

	  _proto._unbindDefaultAsset = function _unbindDefaultAsset() {
	    if (!this._defaultAsset) return;

	    this._app.assets.off('add:' + this._defaultAsset, this._onDefaultAssetAdd, this);

	    var asset = this._app.assets.get(this._defaultAsset);

	    if (!asset) return;
	    asset.off('add:localized', this._onLocaleAdd, this);
	    asset.off('remove:localized', this._onLocaleRemove, this);
	    asset.off('remove', this._onDefaultAssetRemove, this);
	  };

	  _proto._onDefaultAssetAdd = function _onDefaultAssetAdd(asset) {
	    if (this._defaultAsset !== asset.id) return;
	    asset.on('add:localized', this._onLocaleAdd, this);
	    asset.on('remove:localized', this._onLocaleRemove, this);
	    asset.once('remove', this._onDefaultAssetRemove, this);
	  };

	  _proto._onDefaultAssetRemove = function _onDefaultAssetRemove(asset) {
	    if (this._defaultAsset !== asset.id) return;
	    asset.off('add:localized', this._onLocaleAdd, this);
	    asset.off('remove:localized', this._onLocaleAdd, this);

	    this._app.assets.once('add:' + this._defaultAsset, this._onDefaultAssetAdd, this);
	  };

	  _proto._bindLocalizedAsset = function _bindLocalizedAsset() {
	    if (!this._autoLoad) return;

	    var asset = this._app.assets.get(this._localizedAsset);

	    if (!asset) return;
	    asset.on('load', this._onLocalizedAssetLoad, this);
	    asset.on('change', this._onLocalizedAssetChange, this);
	    asset.on('remove', this._onLocalizedAssetRemove, this);

	    if (asset.resource) {
	      this._onLocalizedAssetLoad(asset);
	    } else {
	      this._app.assets.load(asset);
	    }
	  };

	  _proto._unbindLocalizedAsset = function _unbindLocalizedAsset() {
	    var asset = this._app.assets.get(this._localizedAsset);

	    if (!asset) return;
	    asset.off('load', this._onLocalizedAssetLoad, this);
	    asset.off('change', this._onLocalizedAssetChange, this);
	    asset.off('remove', this._onLocalizedAssetRemove, this);
	  };

	  _proto._onLocalizedAssetAdd = function _onLocalizedAssetAdd(asset) {
	    if (this._localizedAsset !== asset.id) return;

	    this._bindLocalizedAsset();
	  };

	  _proto._onLocalizedAssetLoad = function _onLocalizedAssetLoad(asset) {
	    this.fire('load', asset);
	  };

	  _proto._onLocalizedAssetChange = function _onLocalizedAssetChange(asset, name, newValue, oldValue) {
	    this.fire('change', asset, name, newValue, oldValue);
	  };

	  _proto._onLocalizedAssetRemove = function _onLocalizedAssetRemove(asset) {
	    if (this._localizedAsset === asset.id) {
	      this.localizedAsset = this._defaultAsset;
	    }

	    this.fire('remove', asset);
	  };

	  _proto._onLocaleAdd = function _onLocaleAdd(locale, assetId) {
	    if (this._app.i18n.locale !== locale) return;

	    this._onSetLocale(locale);
	  };

	  _proto._onLocaleRemove = function _onLocaleRemove(locale, assetId) {
	    if (this._app.i18n.locale !== locale) return;

	    this._onSetLocale(locale);
	  };

	  _proto._onSetLocale = function _onSetLocale(locale) {
	    if (!this._defaultAsset) {
	      this.localizedAsset = null;
	      return;
	    }

	    var asset = this._app.assets.get(this._defaultAsset);

	    if (!asset || this._disableLocalization) {
	      this.localizedAsset = this._defaultAsset;
	      return;
	    }

	    var localizedAssetId = asset.getLocalizedAssetId(locale);

	    if (!localizedAssetId) {
	      this.localizedAsset = this._defaultAsset;
	      return;
	    }

	    this.localizedAsset = localizedAssetId;
	  };

	  _proto.destroy = function destroy() {
	    this.defaultAsset = null;

	    this._app.i18n.off('set:locale', this._onSetLocale, this);

	    this.off();
	  };

	  _createClass(LocalizedAsset, [{
	    key: "defaultAsset",
	    get: function get() {
	      return this._defaultAsset;
	    },
	    set: function set(value) {
	      var id = value instanceof Asset ? value.id : value;
	      if (this._defaultAsset === id) return;

	      if (this._defaultAsset) {
	        this._unbindDefaultAsset();
	      }

	      this._defaultAsset = id;

	      if (this._defaultAsset) {
	        this._bindDefaultAsset();
	      }

	      this._onSetLocale(this._app.i18n.locale);
	    }
	  }, {
	    key: "localizedAsset",
	    get: function get() {
	      return this._localizedAsset;
	    },
	    set: function set(value) {
	      var id = value instanceof Asset ? value.id : value;

	      if (this._localizedAsset === id) {
	        return;
	      }

	      if (this._localizedAsset) {
	        this._app.assets.off('add:' + this._localizedAsset, this._onLocalizedAssetAdd, this);

	        this._unbindLocalizedAsset();

	        this._localizedAsset = null;
	      }

	      this._localizedAsset = id;

	      if (this._localizedAsset) {
	        var asset = this._app.assets.get(this._localizedAsset);

	        if (!asset) {
	          this._app.assets.once('add:' + this._localizedAsset, this._onLocalizedAssetAdd, this);
	        } else {
	          this._bindLocalizedAsset();
	        }
	      }
	    }
	  }, {
	    key: "autoLoad",
	    get: function get() {
	      return this._autoLoad;
	    },
	    set: function set(value) {
	      if (this._autoLoad === value) return;
	      this._autoLoad = value;

	      if (this._autoLoad && this._localizedAsset) {
	        this._unbindLocalizedAsset();

	        this._bindLocalizedAsset();
	      }
	    }
	  }, {
	    key: "disableLocalization",
	    get: function get() {
	      return this._disableLocalization;
	    },
	    set: function set(value) {
	      if (this._disableLocalization === value) return;
	      this._disableLocalization = value;

	      this._onSetLocale(this._app.i18n.locale);
	    }
	  }]);

	  return LocalizedAsset;
	}(EventHandler);

	var reservedScriptNames = new Set(['system', 'entity', 'create', 'destroy', 'swap', 'move', 'scripts', '_scripts', '_scriptsIndex', '_scriptsData', 'enabled', '_oldState', 'onEnable', 'onDisable', 'onPostStateChange', '_onSetEnabled', '_checkState', '_onBeforeRemove', '_onInitializeAttributes', '_onInitialize', '_onPostInitialize', '_onUpdate', '_onPostUpdate', '_callbacks', 'has', 'get', 'on', 'off', 'fire', 'once', 'hasEvent']);

	function createScript(name, app) {
	  if (script.legacy) {
	    return null;
	  }

	  if (reservedScriptNames.has(name)) throw new Error("script name: '" + name + "' is reserved, please change script name");

	  var scriptType = function scriptType(args) {
	    EventHandler.prototype.initEventHandler.call(this);
	    ScriptType.prototype.initScriptType.call(this, args);
	  };

	  scriptType.prototype = Object.create(ScriptType.prototype);
	  scriptType.prototype.constructor = scriptType;
	  scriptType.extend = ScriptType.extend;
	  scriptType.attributes = new ScriptAttributes(scriptType);
	  registerScript(scriptType, name, app);
	  return scriptType;
	}

	var reservedAttributes = {};
	ScriptAttributes.reservedNames.forEach(function (value, value2, set) {
	  reservedAttributes[value] = 1;
	});
	createScript.reservedAttributes = reservedAttributes;

	function registerScript(script, name, app) {
	  if (script.legacy) {
	    return;
	  }

	  if (typeof script !== 'function') throw new Error("script class: '" + script + "' must be a constructor function (i.e. class).");
	  if (!(script.prototype instanceof ScriptType)) throw new Error("script class: '" + ScriptType.__getScriptName(script) + "' does not extend pc.ScriptType.");
	  name = name || script.__name || ScriptType.__getScriptName(script);
	  if (reservedScriptNames.has(name)) throw new Error("script name: '" + name + "' is reserved, please change script name");
	  script.__name = name;
	  var registry = app ? app.scripts : AppBase.getApplication().scripts;
	  registry.add(script);

	  ScriptHandler._push(script);
	}

	var ACTION_MOUSE = 'mouse';
	var ACTION_KEYBOARD = 'keyboard';
	var ACTION_GAMEPAD = 'gamepad';
	var AXIS_MOUSE_X = 'mousex';
	var AXIS_MOUSE_Y = 'mousey';
	var AXIS_PAD_L_X = 'padlx';
	var AXIS_PAD_L_Y = 'padly';
	var AXIS_PAD_R_X = 'padrx';
	var AXIS_PAD_R_Y = 'padry';
	var AXIS_KEY = 'key';
	var EVENT_KEYDOWN = 'keydown';
	var EVENT_KEYUP = 'keyup';
	var EVENT_MOUSEDOWN = 'mousedown';
	var EVENT_MOUSEMOVE = 'mousemove';
	var EVENT_MOUSEUP = 'mouseup';
	var EVENT_MOUSEWHEEL = 'mousewheel';
	var EVENT_TOUCHSTART = 'touchstart';
	var EVENT_TOUCHEND = 'touchend';
	var EVENT_TOUCHMOVE = 'touchmove';
	var EVENT_TOUCHCANCEL = 'touchcancel';
	var EVENT_SELECT = 'select';
	var EVENT_SELECTSTART = 'selectstart';
	var EVENT_SELECTEND = 'selectend';
	var KEY_BACKSPACE = 8;
	var KEY_TAB = 9;
	var KEY_RETURN = 13;
	var KEY_ENTER = 13;
	var KEY_SHIFT = 16;
	var KEY_CONTROL = 17;
	var KEY_ALT = 18;
	var KEY_PAUSE = 19;
	var KEY_CAPS_LOCK = 20;
	var KEY_ESCAPE = 27;
	var KEY_SPACE = 32;
	var KEY_PAGE_UP = 33;
	var KEY_PAGE_DOWN = 34;
	var KEY_END = 35;
	var KEY_HOME = 36;
	var KEY_LEFT = 37;
	var KEY_UP = 38;
	var KEY_RIGHT = 39;
	var KEY_DOWN = 40;
	var KEY_PRINT_SCREEN = 44;
	var KEY_INSERT = 45;
	var KEY_DELETE = 46;
	var KEY_0 = 48;
	var KEY_1 = 49;
	var KEY_2 = 50;
	var KEY_3 = 51;
	var KEY_4 = 52;
	var KEY_5 = 53;
	var KEY_6 = 54;
	var KEY_7 = 55;
	var KEY_8 = 56;
	var KEY_9 = 57;
	var KEY_SEMICOLON = 59;
	var KEY_EQUAL = 61;
	var KEY_A = 65;
	var KEY_B = 66;
	var KEY_C = 67;
	var KEY_D = 68;
	var KEY_E = 69;
	var KEY_F = 70;
	var KEY_G = 71;
	var KEY_H = 72;
	var KEY_I = 73;
	var KEY_J = 74;
	var KEY_K = 75;
	var KEY_L = 76;
	var KEY_M = 77;
	var KEY_N = 78;
	var KEY_O = 79;
	var KEY_P = 80;
	var KEY_Q = 81;
	var KEY_R = 82;
	var KEY_S = 83;
	var KEY_T = 84;
	var KEY_U = 85;
	var KEY_V = 86;
	var KEY_W = 87;
	var KEY_X = 88;
	var KEY_Y = 89;
	var KEY_Z = 90;
	var KEY_WINDOWS = 91;
	var KEY_CONTEXT_MENU = 93;
	var KEY_NUMPAD_0 = 96;
	var KEY_NUMPAD_1 = 97;
	var KEY_NUMPAD_2 = 98;
	var KEY_NUMPAD_3 = 99;
	var KEY_NUMPAD_4 = 100;
	var KEY_NUMPAD_5 = 101;
	var KEY_NUMPAD_6 = 102;
	var KEY_NUMPAD_7 = 103;
	var KEY_NUMPAD_8 = 104;
	var KEY_NUMPAD_9 = 105;
	var KEY_MULTIPLY = 106;
	var KEY_ADD = 107;
	var KEY_SEPARATOR = 108;
	var KEY_SUBTRACT = 109;
	var KEY_DECIMAL = 110;
	var KEY_DIVIDE = 111;
	var KEY_F1 = 112;
	var KEY_F2 = 113;
	var KEY_F3 = 114;
	var KEY_F4 = 115;
	var KEY_F5 = 116;
	var KEY_F6 = 117;
	var KEY_F7 = 118;
	var KEY_F8 = 119;
	var KEY_F9 = 120;
	var KEY_F10 = 121;
	var KEY_F11 = 122;
	var KEY_F12 = 123;
	var KEY_COMMA = 188;
	var KEY_PERIOD = 190;
	var KEY_SLASH = 191;
	var KEY_OPEN_BRACKET = 219;
	var KEY_BACK_SLASH = 220;
	var KEY_CLOSE_BRACKET = 221;
	var KEY_META = 224;
	var MOUSEBUTTON_NONE = -1;
	var MOUSEBUTTON_LEFT = 0;
	var MOUSEBUTTON_MIDDLE = 1;
	var MOUSEBUTTON_RIGHT = 2;
	var PAD_1 = 0;
	var PAD_2 = 1;
	var PAD_3 = 2;
	var PAD_4 = 3;
	var PAD_FACE_1 = 0;
	var PAD_FACE_2 = 1;
	var PAD_FACE_3 = 2;
	var PAD_FACE_4 = 3;
	var PAD_L_SHOULDER_1 = 4;
	var PAD_R_SHOULDER_1 = 5;
	var PAD_L_SHOULDER_2 = 6;
	var PAD_R_SHOULDER_2 = 7;
	var PAD_SELECT = 8;
	var PAD_START = 9;
	var PAD_L_STICK_BUTTON = 10;
	var PAD_R_STICK_BUTTON = 11;
	var PAD_UP = 12;
	var PAD_DOWN = 13;
	var PAD_LEFT = 14;
	var PAD_RIGHT = 15;
	var PAD_VENDOR = 16;
	var PAD_L_STICK_X = 0;
	var PAD_L_STICK_Y = 1;
	var PAD_R_STICK_X = 2;
	var PAD_R_STICK_Y = 3;

	var KeyboardEvent = function KeyboardEvent(keyboard, event) {
	  if (event) {
	    this.key = event.keyCode;
	    this.element = event.target;
	    this.event = event;
	  } else {
	    this.key = null;
	    this.element = null;
	    this.event = null;
	  }
	};

	var _keyboardEvent = new KeyboardEvent();

	function makeKeyboardEvent(event) {
	  _keyboardEvent.key = event.keyCode;
	  _keyboardEvent.element = event.target;
	  _keyboardEvent.event = event;
	  return _keyboardEvent;
	}

	function toKeyCode(s) {
	  if (typeof s === 'string') {
	    return s.toUpperCase().charCodeAt(0);
	  }

	  return s;
	}

	var _keyCodeToKeyIdentifier = {
	  '9': 'Tab',
	  '13': 'Enter',
	  '16': 'Shift',
	  '17': 'Control',
	  '18': 'Alt',
	  '27': 'Escape',
	  '37': 'Left',
	  '38': 'Up',
	  '39': 'Right',
	  '40': 'Down',
	  '46': 'Delete',
	  '91': 'Win'
	};

	var Keyboard = function (_EventHandler) {
	  _inheritsLoose(Keyboard, _EventHandler);

	  function Keyboard(element, options) {
	    var _this;

	    if (options === void 0) {
	      options = {};
	    }

	    _this = _EventHandler.call(this) || this;
	    _this._element = null;
	    _this._keyDownHandler = _this._handleKeyDown.bind(_assertThisInitialized(_this));
	    _this._keyUpHandler = _this._handleKeyUp.bind(_assertThisInitialized(_this));
	    _this._keyPressHandler = _this._handleKeyPress.bind(_assertThisInitialized(_this));
	    _this._visibilityChangeHandler = _this._handleVisibilityChange.bind(_assertThisInitialized(_this));
	    _this._windowBlurHandler = _this._handleWindowBlur.bind(_assertThisInitialized(_this));
	    _this._keymap = {};
	    _this._lastmap = {};

	    if (element) {
	      _this.attach(element);
	    }

	    _this.preventDefault = options.preventDefault || false;
	    _this.stopPropagation = options.stopPropagation || false;
	    return _this;
	  }

	  var _proto = Keyboard.prototype;

	  _proto.attach = function attach(element) {
	    if (this._element) {
	      this.detach();
	    }

	    this._element = element;

	    this._element.addEventListener('keydown', this._keyDownHandler, false);

	    this._element.addEventListener('keypress', this._keyPressHandler, false);

	    this._element.addEventListener('keyup', this._keyUpHandler, false);

	    document.addEventListener('visibilitychange', this._visibilityChangeHandler, false);
	    window.addEventListener('blur', this._windowBlurHandler, false);
	  };

	  _proto.detach = function detach() {
	    if (!this._element) {
	      return;
	    }

	    this._element.removeEventListener('keydown', this._keyDownHandler);

	    this._element.removeEventListener('keypress', this._keyPressHandler);

	    this._element.removeEventListener('keyup', this._keyUpHandler);

	    this._element = null;
	    document.removeEventListener('visibilitychange', this._visibilityChangeHandler, false);
	    window.removeEventListener('blur', this._windowBlurHandler, false);
	  };

	  _proto.toKeyIdentifier = function toKeyIdentifier(keyCode) {
	    keyCode = toKeyCode(keyCode);

	    var id = _keyCodeToKeyIdentifier[keyCode.toString()];

	    if (id) {
	      return id;
	    }

	    var hex = keyCode.toString(16).toUpperCase();
	    var length = hex.length;

	    for (var count = 0; count < 4 - length; count++) {
	      hex = '0' + hex;
	    }

	    return 'U+' + hex;
	  };

	  _proto._handleKeyDown = function _handleKeyDown(event) {
	    var code = event.keyCode || event.charCode;
	    if (code === undefined) return;
	    var id = this.toKeyIdentifier(code);
	    this._keymap[id] = true;
	    this.fire('keydown', makeKeyboardEvent(event));

	    if (this.preventDefault) {
	      event.preventDefault();
	    }

	    if (this.stopPropagation) {
	      event.stopPropagation();
	    }
	  };

	  _proto._handleKeyUp = function _handleKeyUp(event) {
	    var code = event.keyCode || event.charCode;
	    if (code === undefined) return;
	    var id = this.toKeyIdentifier(code);
	    delete this._keymap[id];
	    this.fire('keyup', makeKeyboardEvent(event));

	    if (this.preventDefault) {
	      event.preventDefault();
	    }

	    if (this.stopPropagation) {
	      event.stopPropagation();
	    }
	  };

	  _proto._handleKeyPress = function _handleKeyPress(event) {
	    this.fire('keypress', makeKeyboardEvent(event));

	    if (this.preventDefault) {
	      event.preventDefault();
	    }

	    if (this.stopPropagation) {
	      event.stopPropagation();
	    }
	  };

	  _proto._handleVisibilityChange = function _handleVisibilityChange() {
	    if (document.visibilityState === 'hidden') {
	      this._handleWindowBlur();
	    }
	  };

	  _proto._handleWindowBlur = function _handleWindowBlur() {
	    this._keymap = {};
	    this._lastmap = {};
	  };

	  _proto.update = function update() {
	    for (var prop in this._lastmap) {
	      delete this._lastmap[prop];
	    }

	    for (var _prop in this._keymap) {
	      if (this._keymap.hasOwnProperty(_prop)) {
	        this._lastmap[_prop] = this._keymap[_prop];
	      }
	    }
	  };

	  _proto.isPressed = function isPressed(key) {
	    var keyCode = toKeyCode(key);
	    var id = this.toKeyIdentifier(keyCode);
	    return !!this._keymap[id];
	  };

	  _proto.wasPressed = function wasPressed(key) {
	    var keyCode = toKeyCode(key);
	    var id = this.toKeyIdentifier(keyCode);
	    return !!this._keymap[id] && !!!this._lastmap[id];
	  };

	  _proto.wasReleased = function wasReleased(key) {
	    var keyCode = toKeyCode(key);
	    var id = this.toKeyIdentifier(keyCode);
	    return !!!this._keymap[id] && !!this._lastmap[id];
	  };

	  return Keyboard;
	}(EventHandler);

	function isMousePointerLocked() {
	  return !!(document.pointerLockElement || document.mozPointerLockElement || document.webkitPointerLockElement);
	}

	var MouseEvent = function MouseEvent(mouse, event) {
	  var coords = {
	    x: 0,
	    y: 0
	  };

	  if (event) {
	    if (event instanceof MouseEvent) {
	      throw Error('Expected MouseEvent');
	    }

	    coords = mouse._getTargetCoords(event);
	  } else {
	    event = {};
	  }

	  if (coords) {
	    this.x = coords.x;
	    this.y = coords.y;
	  } else if (isMousePointerLocked()) {
	    this.x = 0;
	    this.y = 0;
	  } else {
	    return;
	  }

	  this.wheelDelta = 0;

	  if (event.type === 'wheel') {
	    if (event.deltaY > 0) {
	      this.wheelDelta = 1;
	    } else if (event.deltaY < 0) {
	      this.wheelDelta = -1;
	    }
	  }

	  if (isMousePointerLocked()) {
	    this.dx = event.movementX || event.webkitMovementX || event.mozMovementX || 0;
	    this.dy = event.movementY || event.webkitMovementY || event.mozMovementY || 0;
	  } else {
	    this.dx = this.x - mouse._lastX;
	    this.dy = this.y - mouse._lastY;
	  }

	  if (event.type === 'mousedown' || event.type === 'mouseup') {
	    this.button = event.button;
	  } else {
	    this.button = MOUSEBUTTON_NONE;
	  }

	  this.buttons = mouse._buttons.slice(0);
	  this.element = event.target;
	  this.ctrlKey = event.ctrlKey || false;
	  this.altKey = event.altKey || false;
	  this.shiftKey = event.shiftKey || false;
	  this.metaKey = event.metaKey || false;
	  this.event = event;
	};

	var Mouse = function (_EventHandler) {
	  _inheritsLoose(Mouse, _EventHandler);

	  function Mouse(element) {
	    var _this;

	    _this = _EventHandler.call(this) || this;
	    _this._lastX = 0;
	    _this._lastY = 0;
	    _this._buttons = [false, false, false];
	    _this._lastbuttons = [false, false, false];
	    _this._upHandler = _this._handleUp.bind(_assertThisInitialized(_this));
	    _this._downHandler = _this._handleDown.bind(_assertThisInitialized(_this));
	    _this._moveHandler = _this._handleMove.bind(_assertThisInitialized(_this));
	    _this._wheelHandler = _this._handleWheel.bind(_assertThisInitialized(_this));

	    _this._contextMenuHandler = function (event) {
	      event.preventDefault();
	    };

	    _this._target = null;
	    _this._attached = false;

	    _this.attach(element);

	    return _this;
	  }

	  Mouse.isPointerLocked = function isPointerLocked() {
	    return isMousePointerLocked();
	  };

	  var _proto = Mouse.prototype;

	  _proto.attach = function attach(element) {
	    this._target = element;
	    if (this._attached) return;
	    this._attached = true;
	    var opts = platform.passiveEvents ? {
	      passive: false
	    } : false;
	    window.addEventListener('mouseup', this._upHandler, opts);
	    window.addEventListener('mousedown', this._downHandler, opts);
	    window.addEventListener('mousemove', this._moveHandler, opts);
	    window.addEventListener('wheel', this._wheelHandler, opts);
	  };

	  _proto.detach = function detach() {
	    if (!this._attached) return;
	    this._attached = false;
	    this._target = null;
	    var opts = platform.passiveEvents ? {
	      passive: false
	    } : false;
	    window.removeEventListener('mouseup', this._upHandler, opts);
	    window.removeEventListener('mousedown', this._downHandler, opts);
	    window.removeEventListener('mousemove', this._moveHandler, opts);
	    window.removeEventListener('wheel', this._wheelHandler, opts);
	  };

	  _proto.disableContextMenu = function disableContextMenu() {
	    if (!this._target) return;

	    this._target.addEventListener('contextmenu', this._contextMenuHandler);
	  };

	  _proto.enableContextMenu = function enableContextMenu() {
	    if (!this._target) return;

	    this._target.removeEventListener('contextmenu', this._contextMenuHandler);
	  };

	  _proto.enablePointerLock = function enablePointerLock(success, error) {
	    if (!document.body.requestPointerLock) {
	      if (error) error();
	      return;
	    }

	    var s = function s() {
	      success();
	      document.removeEventListener('pointerlockchange', s);
	    };

	    var e = function e() {
	      error();
	      document.removeEventListener('pointerlockerror', e);
	    };

	    if (success) {
	      document.addEventListener('pointerlockchange', s, false);
	    }

	    if (error) {
	      document.addEventListener('pointerlockerror', e, false);
	    }

	    document.body.requestPointerLock();
	  };

	  _proto.disablePointerLock = function disablePointerLock(success) {
	    if (!document.exitPointerLock) {
	      return;
	    }

	    var s = function s() {
	      success();
	      document.removeEventListener('pointerlockchange', s);
	    };

	    if (success) {
	      document.addEventListener('pointerlockchange', s, false);
	    }

	    document.exitPointerLock();
	  };

	  _proto.update = function update() {
	    this._lastbuttons[0] = this._buttons[0];
	    this._lastbuttons[1] = this._buttons[1];
	    this._lastbuttons[2] = this._buttons[2];
	  };

	  _proto.isPressed = function isPressed(button) {
	    return this._buttons[button];
	  };

	  _proto.wasPressed = function wasPressed(button) {
	    return this._buttons[button] && !this._lastbuttons[button];
	  };

	  _proto.wasReleased = function wasReleased(button) {
	    return !this._buttons[button] && this._lastbuttons[button];
	  };

	  _proto._handleUp = function _handleUp(event) {
	    this._buttons[event.button] = false;
	    var e = new MouseEvent(this, event);
	    if (!e.event) return;
	    this.fire(EVENT_MOUSEUP, e);
	  };

	  _proto._handleDown = function _handleDown(event) {
	    this._buttons[event.button] = true;
	    var e = new MouseEvent(this, event);
	    if (!e.event) return;
	    this.fire(EVENT_MOUSEDOWN, e);
	  };

	  _proto._handleMove = function _handleMove(event) {
	    var e = new MouseEvent(this, event);
	    if (!e.event) return;
	    this.fire(EVENT_MOUSEMOVE, e);
	    this._lastX = e.x;
	    this._lastY = e.y;
	  };

	  _proto._handleWheel = function _handleWheel(event) {
	    var e = new MouseEvent(this, event);
	    if (!e.event) return;
	    this.fire(EVENT_MOUSEWHEEL, e);
	  };

	  _proto._getTargetCoords = function _getTargetCoords(event) {
	    var rect = this._target.getBoundingClientRect();

	    var left = Math.floor(rect.left);
	    var top = Math.floor(rect.top);

	    if (event.clientX < left || event.clientX >= left + this._target.clientWidth || event.clientY < top || event.clientY >= top + this._target.clientHeight) {
	      return null;
	    }

	    return {
	      x: event.clientX - left,
	      y: event.clientY - top
	    };
	  };

	  return Mouse;
	}(EventHandler);

	var Controller = function () {
	  function Controller(element, options) {
	    if (options === void 0) {
	      options = {};
	    }

	    this._keyboard = options.keyboard || null;
	    this._mouse = options.mouse || null;
	    this._gamepads = options.gamepads || null;
	    this._element = null;
	    this._actions = {};
	    this._axes = {};
	    this._axesValues = {};

	    if (element) {
	      this.attach(element);
	    }
	  }

	  var _proto = Controller.prototype;

	  _proto.attach = function attach(element) {
	    this._element = element;

	    if (this._keyboard) {
	      this._keyboard.attach(element);
	    }

	    if (this._mouse) {
	      this._mouse.attach(element);
	    }
	  };

	  _proto.detach = function detach() {
	    if (this._keyboard) {
	      this._keyboard.detach();
	    }

	    if (this._mouse) {
	      this._mouse.detach();
	    }

	    this._element = null;
	  };

	  _proto.disableContextMenu = function disableContextMenu() {
	    if (!this._mouse) {
	      this._enableMouse();
	    }

	    this._mouse.disableContextMenu();
	  };

	  _proto.enableContextMenu = function enableContextMenu() {
	    if (!this._mouse) {
	      this._enableMouse();
	    }

	    this._mouse.enableContextMenu();
	  };

	  _proto.update = function update(dt) {
	    if (this._keyboard) {
	      this._keyboard.update();
	    }

	    if (this._mouse) {
	      this._mouse.update();
	    }

	    if (this._gamepads) {
	      this._gamepads.update();
	    }

	    this._axesValues = {};

	    for (var key in this._axes) {
	      this._axesValues[key] = [];
	    }
	  };

	  _proto.appendAction = function appendAction(action_name, action) {
	    this._actions[action_name] = this._actions[action_name] || [];

	    this._actions[action_name].push(action);
	  };

	  _proto.registerKeys = function registerKeys(action, keys) {
	    if (!this._keyboard) {
	      this._enableKeyboard();
	    }

	    if (this._actions[action]) {
	      throw new Error("Action: " + action + " already registered");
	    }

	    if (keys === undefined) {
	      throw new Error('Invalid button');
	    }

	    if (!keys.length) {
	      keys = [keys];
	    }

	    this.appendAction(action, {
	      type: ACTION_KEYBOARD,
	      keys: keys
	    });
	  };

	  _proto.registerMouse = function registerMouse(action, button) {
	    if (!this._mouse) {
	      this._enableMouse();
	    }

	    if (button === undefined) {
	      throw new Error('Invalid button');
	    }

	    this.appendAction(action, {
	      type: ACTION_MOUSE,
	      button: button
	    });
	  };

	  _proto.registerPadButton = function registerPadButton(action, pad, button) {
	    if (button === undefined) {
	      throw new Error('Invalid button');
	    }

	    this.appendAction(action, {
	      type: ACTION_GAMEPAD,
	      button: button,
	      pad: pad
	    });
	  };

	  _proto.registerAxis = function registerAxis(options) {
	    var name = options.name;

	    if (!this._axes[name]) {
	      this._axes[name] = [];
	    }

	    var i = this._axes[name].push(name);

	    options = options || {};
	    options.pad = options.pad || PAD_1;

	    var bind = function bind(controller, source, value, key) {
	      switch (source) {
	        case 'mousex':
	          controller._mouse.on(EVENT_MOUSEMOVE, function (e) {
	            controller._axesValues[name][i] = e.dx / 10;
	          });

	          break;

	        case 'mousey':
	          controller._mouse.on(EVENT_MOUSEMOVE, function (e) {
	            controller._axesValues[name][i] = e.dy / 10;
	          });

	          break;

	        case 'key':
	          controller._axes[name].push(function () {
	            return controller._keyboard.isPressed(key) ? value : 0;
	          });

	          break;

	        case 'padrx':
	          controller._axes[name].push(function () {
	            return controller._gamepads.getAxis(options.pad, PAD_R_STICK_X);
	          });

	          break;

	        case 'padry':
	          controller._axes[name].push(function () {
	            return controller._gamepads.getAxis(options.pad, PAD_R_STICK_Y);
	          });

	          break;

	        case 'padlx':
	          controller._axes[name].push(function () {
	            return controller._gamepads.getAxis(options.pad, PAD_L_STICK_X);
	          });

	          break;

	        case 'padly':
	          controller._axes[name].push(function () {
	            return controller._gamepads.getAxis(options.pad, PAD_L_STICK_Y);
	          });

	          break;

	        default:
	          throw new Error('Unknown axis');
	      }
	    };

	    bind(this, options.positive, 1, options.positiveKey);

	    if (options.negativeKey || options.negative !== options.positive) {
	      bind(this, options.negative, -1, options.negativeKey);
	    }
	  };

	  _proto.isPressed = function isPressed(actionName) {
	    if (!this._actions[actionName]) {
	      return false;
	    }

	    var length = this._actions[actionName].length;

	    for (var index = 0; index < length; ++index) {
	      var action = this._actions[actionName][index];

	      switch (action.type) {
	        case ACTION_KEYBOARD:
	          if (this._keyboard) {
	            var len = action.keys.length;

	            for (var i = 0; i < len; i++) {
	              if (this._keyboard.isPressed(action.keys[i])) {
	                return true;
	              }
	            }
	          }

	          break;

	        case ACTION_MOUSE:
	          if (this._mouse && this._mouse.isPressed(action.button)) {
	            return true;
	          }

	          break;

	        case ACTION_GAMEPAD:
	          if (this._gamepads && this._gamepads.isPressed(action.pad, action.button)) {
	            return true;
	          }

	          break;
	      }
	    }

	    return false;
	  };

	  _proto.wasPressed = function wasPressed(actionName) {
	    if (!this._actions[actionName]) {
	      return false;
	    }

	    var length = this._actions[actionName].length;

	    for (var index = 0; index < length; ++index) {
	      var action = this._actions[actionName][index];

	      switch (action.type) {
	        case ACTION_KEYBOARD:
	          if (this._keyboard) {
	            var len = action.keys.length;

	            for (var i = 0; i < len; i++) {
	              if (this._keyboard.wasPressed(action.keys[i])) {
	                return true;
	              }
	            }
	          }

	          break;

	        case ACTION_MOUSE:
	          if (this._mouse && this._mouse.wasPressed(action.button)) {
	            return true;
	          }

	          break;

	        case ACTION_GAMEPAD:
	          if (this._gamepads && this._gamepads.wasPressed(action.pad, action.button)) {
	            return true;
	          }

	          break;
	      }
	    }

	    return false;
	  };

	  _proto.getAxis = function getAxis(name) {
	    var value = 0;

	    if (this._axes[name]) {
	      var len = this._axes[name].length;

	      for (var i = 0; i < len; i++) {
	        if (type$1(this._axes[name][i]) === 'function') {
	          var v = this._axes[name][i]();

	          if (Math.abs(v) > Math.abs(value)) {
	            value = v;
	          }
	        } else if (this._axesValues[name]) {
	          if (Math.abs(this._axesValues[name][i]) > Math.abs(value)) {
	            value = this._axesValues[name][i];
	          }
	        }
	      }
	    }

	    return value;
	  };

	  _proto._enableMouse = function _enableMouse() {
	    this._mouse = new Mouse();

	    if (!this._element) {
	      throw new Error('Controller must be attached to an Element');
	    }

	    this._mouse.attach(this._element);
	  };

	  _proto._enableKeyboard = function _enableKeyboard() {
	    this._keyboard = new Keyboard();

	    if (!this._element) {
	      throw new Error('Controller must be attached to an Element');
	    }

	    this._keyboard.attach(this._element);
	  };

	  return Controller;
	}();

	var targetX, targetY;
	var vecA$2 = new Vec3();
	var vecB$2 = new Vec3();
	var rayA = new Ray();
	var rayB = new Ray();
	var rayC = new Ray();
	rayA.end = new Vec3();
	rayB.end = new Vec3();
	rayC.end = new Vec3();

	var _pq = new Vec3();

	var _pa = new Vec3();

	var _pb = new Vec3();

	var _pc = new Vec3();

	var _pd = new Vec3();

	var _m = new Vec3();

	var _au = new Vec3();

	var _bv = new Vec3();

	var _cw = new Vec3();

	var _ir = new Vec3();

	var _sct = new Vec3();

	var _accumulatedScale = new Vec3();

	var _paddingTop = new Vec3();

	var _paddingBottom = new Vec3();

	var _paddingLeft = new Vec3();

	var _paddingRight = new Vec3();

	var _cornerBottomLeft = new Vec3();

	var _cornerBottomRight = new Vec3();

	var _cornerTopRight = new Vec3();

	var _cornerTopLeft = new Vec3();

	var ZERO_VEC4 = new Vec4();

	function scalarTriple(p1, p2, p3) {
	  return _sct.cross(p1, p2).dot(p3);
	}

	function intersectLineQuad(p, q, corners) {
	  _pq.sub2(q, p);

	  _pa.sub2(corners[0], p);

	  _pb.sub2(corners[1], p);

	  _pc.sub2(corners[2], p);

	  _m.cross(_pc, _pq);

	  var v = _pa.dot(_m);

	  var u;
	  var w;

	  if (v >= 0) {
	    u = -_pb.dot(_m);
	    if (u < 0) return -1;
	    w = scalarTriple(_pq, _pb, _pa);
	    if (w < 0) return -1;
	    var denom = 1.0 / (u + v + w);

	    _au.copy(corners[0]).mulScalar(u * denom);

	    _bv.copy(corners[1]).mulScalar(v * denom);

	    _cw.copy(corners[2]).mulScalar(w * denom);

	    _ir.copy(_au).add(_bv).add(_cw);
	  } else {
	    _pd.sub2(corners[3], p);

	    u = _pd.dot(_m);
	    if (u < 0) return -1;
	    w = scalarTriple(_pq, _pa, _pd);
	    if (w < 0) return -1;
	    v = -v;

	    var _denom = 1.0 / (u + v + w);

	    _au.copy(corners[0]).mulScalar(u * _denom);

	    _bv.copy(corners[3]).mulScalar(v * _denom);

	    _cw.copy(corners[2]).mulScalar(w * _denom);

	    _ir.copy(_au).add(_bv).add(_cw);
	  }

	  if (_pq.sub2(corners[0], corners[2]).lengthSq() < 0.0001 * 0.0001) return -1;
	  if (_pq.sub2(corners[1], corners[3]).lengthSq() < 0.0001 * 0.0001) return -1;
	  return _ir.sub(p).lengthSq();
	}

	var ElementInputEvent = function () {
	  function ElementInputEvent(event, element, camera) {
	    this.event = event;
	    this.element = element;
	    this.camera = camera;
	    this._stopPropagation = false;
	  }

	  var _proto = ElementInputEvent.prototype;

	  _proto.stopPropagation = function stopPropagation() {
	    this._stopPropagation = true;

	    if (this.event) {
	      this.event.stopImmediatePropagation();
	      this.event.stopPropagation();
	    }
	  };

	  return ElementInputEvent;
	}();

	var ElementMouseEvent = function (_ElementInputEvent) {
	  _inheritsLoose(ElementMouseEvent, _ElementInputEvent);

	  function ElementMouseEvent(event, element, camera, x, y, lastX, lastY) {
	    var _this;

	    _this = _ElementInputEvent.call(this, event, element, camera) || this;
	    _this.x = x;
	    _this.y = y;
	    _this.ctrlKey = event.ctrlKey || false;
	    _this.altKey = event.altKey || false;
	    _this.shiftKey = event.shiftKey || false;
	    _this.metaKey = event.metaKey || false;
	    _this.button = event.button;

	    if (Mouse.isPointerLocked()) {
	      _this.dx = event.movementX || event.webkitMovementX || event.mozMovementX || 0;
	      _this.dy = event.movementY || event.webkitMovementY || event.mozMovementY || 0;
	    } else {
	      _this.dx = x - lastX;
	      _this.dy = y - lastY;
	    }

	    _this.wheelDelta = 0;

	    if (event.type === 'wheel') {
	      if (event.deltaY > 0) {
	        _this.wheelDelta = 1;
	      } else if (event.deltaY < 0) {
	        _this.wheelDelta = -1;
	      }
	    }

	    return _this;
	  }

	  return ElementMouseEvent;
	}(ElementInputEvent);

	var ElementTouchEvent = function (_ElementInputEvent2) {
	  _inheritsLoose(ElementTouchEvent, _ElementInputEvent2);

	  function ElementTouchEvent(event, element, camera, x, y, touch) {
	    var _this2;

	    _this2 = _ElementInputEvent2.call(this, event, element, camera) || this;
	    _this2.touches = event.touches;
	    _this2.changedTouches = event.changedTouches;
	    _this2.x = x;
	    _this2.y = y;
	    _this2.touch = touch;
	    return _this2;
	  }

	  return ElementTouchEvent;
	}(ElementInputEvent);

	var ElementSelectEvent = function (_ElementInputEvent3) {
	  _inheritsLoose(ElementSelectEvent, _ElementInputEvent3);

	  function ElementSelectEvent(event, element, camera, inputSource) {
	    var _this3;

	    _this3 = _ElementInputEvent3.call(this, event, element, camera) || this;
	    _this3.inputSource = inputSource;
	    return _this3;
	  }

	  return ElementSelectEvent;
	}(ElementInputEvent);

	var ElementInput = function () {
	  function ElementInput(domElement, options) {
	    this._app = null;
	    this._attached = false;
	    this._target = null;
	    this._enabled = true;
	    this._lastX = 0;
	    this._lastY = 0;
	    this._upHandler = this._handleUp.bind(this);
	    this._downHandler = this._handleDown.bind(this);
	    this._moveHandler = this._handleMove.bind(this);
	    this._wheelHandler = this._handleWheel.bind(this);
	    this._touchstartHandler = this._handleTouchStart.bind(this);
	    this._touchendHandler = this._handleTouchEnd.bind(this);
	    this._touchcancelHandler = this._touchendHandler;
	    this._touchmoveHandler = this._handleTouchMove.bind(this);
	    this._sortHandler = this._sortElements.bind(this);
	    this._elements = [];
	    this._hoveredElement = null;
	    this._pressedElement = null;
	    this._touchedElements = {};
	    this._touchesForWhichTouchLeaveHasFired = {};
	    this._selectedElements = {};
	    this._selectedPressedElements = {};
	    this._useMouse = !options || options.useMouse !== false;
	    this._useTouch = !options || options.useTouch !== false;
	    this._useXr = !options || options.useXr !== false;
	    this._selectEventsAttached = false;
	    if (platform.touch) this._clickedEntities = {};
	    this.attach(domElement);
	  }

	  var _proto2 = ElementInput.prototype;

	  _proto2.attach = function attach(domElement) {
	    if (this._attached) {
	      this._attached = false;
	      this.detach();
	    }

	    this._target = domElement;
	    this._attached = true;
	    var opts = platform.passiveEvents ? {
	      passive: true
	    } : false;

	    if (this._useMouse) {
	      window.addEventListener('mouseup', this._upHandler, opts);
	      window.addEventListener('mousedown', this._downHandler, opts);
	      window.addEventListener('mousemove', this._moveHandler, opts);
	      window.addEventListener('wheel', this._wheelHandler, opts);
	    }

	    if (this._useTouch && platform.touch) {
	      this._target.addEventListener('touchstart', this._touchstartHandler, opts);

	      this._target.addEventListener('touchend', this._touchendHandler, false);

	      this._target.addEventListener('touchmove', this._touchmoveHandler, false);

	      this._target.addEventListener('touchcancel', this._touchcancelHandler, false);
	    }

	    this.attachSelectEvents();
	  };

	  _proto2.attachSelectEvents = function attachSelectEvents() {
	    if (!this._selectEventsAttached && this._useXr && this.app && this.app.xr && this.app.xr.supported) {
	      if (!this._clickedEntities) this._clickedEntities = {};
	      this._selectEventsAttached = true;
	      this.app.xr.on('start', this._onXrStart, this);
	    }
	  };

	  _proto2.detach = function detach() {
	    if (!this._attached) return;
	    this._attached = false;
	    var opts = platform.passiveEvents ? {
	      passive: true
	    } : false;

	    if (this._useMouse) {
	      window.removeEventListener('mouseup', this._upHandler, opts);
	      window.removeEventListener('mousedown', this._downHandler, opts);
	      window.removeEventListener('mousemove', this._moveHandler, opts);
	      window.removeEventListener('wheel', this._wheelHandler, opts);
	    }

	    if (this._useTouch) {
	      this._target.removeEventListener('touchstart', this._touchstartHandler, opts);

	      this._target.removeEventListener('touchend', this._touchendHandler, false);

	      this._target.removeEventListener('touchmove', this._touchmoveHandler, false);

	      this._target.removeEventListener('touchcancel', this._touchcancelHandler, false);
	    }

	    if (this._selectEventsAttached) {
	      this._selectEventsAttached = false;
	      this.app.xr.off('start', this._onXrStart, this);
	      this.app.xr.off('end', this._onXrEnd, this);
	      this.app.xr.off('update', this._onXrUpdate, this);
	      this.app.xr.input.off('selectstart', this._onSelectStart, this);
	      this.app.xr.input.off('selectend', this._onSelectEnd, this);
	      this.app.xr.input.off('remove', this._onXrInputRemove, this);
	    }

	    this._target = null;
	  };

	  _proto2.addElement = function addElement(element) {
	    if (this._elements.indexOf(element) === -1) this._elements.push(element);
	  };

	  _proto2.removeElement = function removeElement(element) {
	    var idx = this._elements.indexOf(element);

	    if (idx !== -1) this._elements.splice(idx, 1);
	  };

	  _proto2._handleUp = function _handleUp(event) {
	    if (!this._enabled) return;
	    if (Mouse.isPointerLocked()) return;

	    this._calcMouseCoords(event);

	    this._onElementMouseEvent('mouseup', event);
	  };

	  _proto2._handleDown = function _handleDown(event) {
	    if (!this._enabled) return;
	    if (Mouse.isPointerLocked()) return;

	    this._calcMouseCoords(event);

	    this._onElementMouseEvent('mousedown', event);
	  };

	  _proto2._handleMove = function _handleMove(event) {
	    if (!this._enabled) return;

	    this._calcMouseCoords(event);

	    this._onElementMouseEvent('mousemove', event);

	    this._lastX = targetX;
	    this._lastY = targetY;
	  };

	  _proto2._handleWheel = function _handleWheel(event) {
	    if (!this._enabled) return;

	    this._calcMouseCoords(event);

	    this._onElementMouseEvent('mousewheel', event);
	  };

	  _proto2._determineTouchedElements = function _determineTouchedElements(event) {
	    var touchedElements = {};
	    var cameras = this.app.systems.camera.cameras;

	    for (var i = cameras.length - 1; i >= 0; i--) {
	      var camera = cameras[i];
	      var done = 0;
	      var len = event.changedTouches.length;

	      for (var j = 0; j < len; j++) {
	        if (touchedElements[event.changedTouches[j].identifier]) {
	          done++;
	          continue;
	        }

	        var coords = this._calcTouchCoords(event.changedTouches[j]);

	        var element = this._getTargetElement(camera, coords.x, coords.y);

	        if (element) {
	          done++;
	          touchedElements[event.changedTouches[j].identifier] = {
	            element: element,
	            camera: camera,
	            x: coords.x,
	            y: coords.y
	          };
	        }
	      }

	      if (done === len) {
	        break;
	      }
	    }

	    return touchedElements;
	  };

	  _proto2._handleTouchStart = function _handleTouchStart(event) {
	    if (!this._enabled) return;

	    var newTouchedElements = this._determineTouchedElements(event);

	    for (var i = 0, len = event.changedTouches.length; i < len; i++) {
	      var touch = event.changedTouches[i];
	      var newTouchInfo = newTouchedElements[touch.identifier];
	      var oldTouchInfo = this._touchedElements[touch.identifier];

	      if (newTouchInfo && (!oldTouchInfo || newTouchInfo.element !== oldTouchInfo.element)) {
	        this._fireEvent(event.type, new ElementTouchEvent(event, newTouchInfo.element, newTouchInfo.camera, newTouchInfo.x, newTouchInfo.y, touch));

	        this._touchesForWhichTouchLeaveHasFired[touch.identifier] = false;
	      }
	    }

	    for (var touchId in newTouchedElements) {
	      this._touchedElements[touchId] = newTouchedElements[touchId];
	    }
	  };

	  _proto2._handleTouchEnd = function _handleTouchEnd(event) {
	    if (!this._enabled) return;
	    var cameras = this.app.systems.camera.cameras;

	    for (var key in this._clickedEntities) {
	      delete this._clickedEntities[key];
	    }

	    for (var i = 0, len = event.changedTouches.length; i < len; i++) {
	      var touch = event.changedTouches[i];
	      var touchInfo = this._touchedElements[touch.identifier];
	      if (!touchInfo) continue;
	      var element = touchInfo.element;
	      var camera = touchInfo.camera;
	      var x = touchInfo.x;
	      var y = touchInfo.y;
	      delete this._touchedElements[touch.identifier];
	      delete this._touchesForWhichTouchLeaveHasFired[touch.identifier];

	      this._fireEvent(event.type, new ElementTouchEvent(event, element, camera, x, y, touch));

	      var coords = this._calcTouchCoords(touch);

	      for (var c = cameras.length - 1; c >= 0; c--) {
	        var hovered = this._getTargetElement(cameras[c], coords.x, coords.y);

	        if (hovered === element) {
	          if (!this._clickedEntities[element.entity.getGuid()]) {
	            this._fireEvent('click', new ElementTouchEvent(event, element, camera, x, y, touch));

	            this._clickedEntities[element.entity.getGuid()] = true;
	          }
	        }
	      }
	    }
	  };

	  _proto2._handleTouchMove = function _handleTouchMove(event) {
	    event.preventDefault();
	    if (!this._enabled) return;

	    var newTouchedElements = this._determineTouchedElements(event);

	    for (var i = 0, len = event.changedTouches.length; i < len; i++) {
	      var touch = event.changedTouches[i];
	      var newTouchInfo = newTouchedElements[touch.identifier];
	      var oldTouchInfo = this._touchedElements[touch.identifier];

	      if (oldTouchInfo) {
	        var coords = this._calcTouchCoords(touch);

	        if ((!newTouchInfo || newTouchInfo.element !== oldTouchInfo.element) && !this._touchesForWhichTouchLeaveHasFired[touch.identifier]) {
	          this._fireEvent('touchleave', new ElementTouchEvent(event, oldTouchInfo.element, oldTouchInfo.camera, coords.x, coords.y, touch));

	          this._touchesForWhichTouchLeaveHasFired[touch.identifier] = true;
	        }

	        this._fireEvent('touchmove', new ElementTouchEvent(event, oldTouchInfo.element, oldTouchInfo.camera, coords.x, coords.y, touch));
	      }
	    }
	  };

	  _proto2._onElementMouseEvent = function _onElementMouseEvent(eventType, event) {
	    var element = null;
	    var lastHovered = this._hoveredElement;
	    this._hoveredElement = null;
	    var cameras = this.app.systems.camera.cameras;
	    var camera;

	    for (var i = cameras.length - 1; i >= 0; i--) {
	      camera = cameras[i];
	      element = this._getTargetElement(camera, targetX, targetY);
	      if (element) break;
	    }

	    this._hoveredElement = element;

	    if ((eventType === 'mousemove' || eventType === 'mouseup') && this._pressedElement) {
	      this._fireEvent(eventType, new ElementMouseEvent(event, this._pressedElement, camera, targetX, targetY, this._lastX, this._lastY));
	    } else if (element) {
	      this._fireEvent(eventType, new ElementMouseEvent(event, element, camera, targetX, targetY, this._lastX, this._lastY));

	      if (eventType === 'mousedown') {
	        this._pressedElement = element;
	      }
	    }

	    if (lastHovered !== this._hoveredElement) {
	      if (lastHovered) {
	        this._fireEvent('mouseleave', new ElementMouseEvent(event, lastHovered, camera, targetX, targetY, this._lastX, this._lastY));
	      }

	      if (this._hoveredElement) {
	        this._fireEvent('mouseenter', new ElementMouseEvent(event, this._hoveredElement, camera, targetX, targetY, this._lastX, this._lastY));
	      }
	    }

	    if (eventType === 'mouseup' && this._pressedElement) {
	      if (this._pressedElement === this._hoveredElement) {
	        this._pressedElement = null;

	        if (!this._clickedEntities || !this._clickedEntities[this._hoveredElement.entity.getGuid()]) {
	          this._fireEvent('click', new ElementMouseEvent(event, this._hoveredElement, camera, targetX, targetY, this._lastX, this._lastY));
	        }
	      } else {
	        this._pressedElement = null;
	      }
	    }
	  };

	  _proto2._onXrStart = function _onXrStart() {
	    this.app.xr.on('end', this._onXrEnd, this);
	    this.app.xr.on('update', this._onXrUpdate, this);
	    this.app.xr.input.on('selectstart', this._onSelectStart, this);
	    this.app.xr.input.on('selectend', this._onSelectEnd, this);
	    this.app.xr.input.on('remove', this._onXrInputRemove, this);
	  };

	  _proto2._onXrEnd = function _onXrEnd() {
	    this.app.xr.off('update', this._onXrUpdate, this);
	    this.app.xr.input.off('selectstart', this._onSelectStart, this);
	    this.app.xr.input.off('selectend', this._onSelectEnd, this);
	    this.app.xr.input.off('remove', this._onXrInputRemove, this);
	  };

	  _proto2._onXrUpdate = function _onXrUpdate() {
	    if (!this._enabled) return;
	    var inputSources = this.app.xr.input.inputSources;

	    for (var i = 0; i < inputSources.length; i++) {
	      this._onElementSelectEvent('selectmove', inputSources[i], null);
	    }
	  };

	  _proto2._onXrInputRemove = function _onXrInputRemove(inputSource) {
	    var hovered = this._selectedElements[inputSource.id];

	    if (hovered) {
	      inputSource._elementEntity = null;

	      this._fireEvent('selectleave', new ElementSelectEvent(null, hovered, null, inputSource));
	    }

	    delete this._selectedElements[inputSource.id];
	    delete this._selectedPressedElements[inputSource.id];
	  };

	  _proto2._onSelectStart = function _onSelectStart(inputSource, event) {
	    if (!this._enabled) return;

	    this._onElementSelectEvent('selectstart', inputSource, event);
	  };

	  _proto2._onSelectEnd = function _onSelectEnd(inputSource, event) {
	    if (!this._enabled) return;

	    this._onElementSelectEvent('selectend', inputSource, event);
	  };

	  _proto2._onElementSelectEvent = function _onElementSelectEvent(eventType, inputSource, event) {
	    var element;
	    var hoveredBefore = this._selectedElements[inputSource.id];
	    var hoveredNow;
	    var cameras = this.app.systems.camera.cameras;
	    var camera;

	    if (inputSource.elementInput) {
	      rayC.set(inputSource.getOrigin(), inputSource.getDirection());

	      for (var i = cameras.length - 1; i >= 0; i--) {
	        camera = cameras[i];
	        element = this._getTargetElementByRay(rayC, camera);
	        if (element) break;
	      }
	    }

	    inputSource._elementEntity = element || null;

	    if (element) {
	      this._selectedElements[inputSource.id] = element;
	      hoveredNow = element;
	    } else {
	      delete this._selectedElements[inputSource.id];
	    }

	    if (hoveredBefore !== hoveredNow) {
	      if (hoveredBefore) this._fireEvent('selectleave', new ElementSelectEvent(event, hoveredBefore, camera, inputSource));
	      if (hoveredNow) this._fireEvent('selectenter', new ElementSelectEvent(event, hoveredNow, camera, inputSource));
	    }

	    if (eventType === 'selectstart') {
	      this._selectedPressedElements[inputSource.id] = hoveredNow;
	      if (hoveredNow) this._fireEvent('selectstart', new ElementSelectEvent(event, hoveredNow, camera, inputSource));
	    }

	    var pressed = this._selectedPressedElements[inputSource.id];

	    if (!inputSource.elementInput && pressed) {
	      delete this._selectedPressedElements[inputSource.id];
	      if (hoveredBefore) this._fireEvent('selectend', new ElementSelectEvent(event, hoveredBefore, camera, inputSource));
	    }

	    if (eventType === 'selectend' && inputSource.elementInput) {
	      delete this._selectedPressedElements[inputSource.id];
	      if (hoveredBefore) this._fireEvent('selectend', new ElementSelectEvent(event, hoveredBefore, camera, inputSource));

	      if (pressed && pressed === hoveredBefore) {
	        this._fireEvent('click', new ElementSelectEvent(event, pressed, camera, inputSource));
	      }
	    }
	  };

	  _proto2._fireEvent = function _fireEvent(name, evt) {
	    var element = evt.element;

	    while (true) {
	      element.fire(name, evt);
	      if (evt._stopPropagation) break;
	      if (!element.entity.parent) break;
	      element = element.entity.parent.element;
	      if (!element) break;
	    }
	  };

	  _proto2._calcMouseCoords = function _calcMouseCoords(event) {
	    var rect = this._target.getBoundingClientRect();

	    var left = Math.floor(rect.left);
	    var top = Math.floor(rect.top);
	    targetX = event.clientX - left;
	    targetY = event.clientY - top;
	  };

	  _proto2._calcTouchCoords = function _calcTouchCoords(touch) {
	    var totalOffsetX = 0;
	    var totalOffsetY = 0;
	    var target = touch.target;

	    while (!(target instanceof HTMLElement)) {
	      target = target.parentNode;
	    }

	    var currentElement = target;

	    do {
	      totalOffsetX += currentElement.offsetLeft - currentElement.scrollLeft;
	      totalOffsetY += currentElement.offsetTop - currentElement.scrollTop;
	      currentElement = currentElement.offsetParent;
	    } while (currentElement);

	    return {
	      x: touch.pageX - totalOffsetX,
	      y: touch.pageY - totalOffsetY
	    };
	  };

	  _proto2._sortElements = function _sortElements(a, b) {
	    var layerOrder = this.app.scene.layers.sortTransparentLayers(a.layers, b.layers);
	    if (layerOrder !== 0) return layerOrder;
	    if (a.screen && !b.screen) return -1;
	    if (!a.screen && b.screen) return 1;
	    if (!a.screen && !b.screen) return 0;
	    if (a.screen.screen.screenSpace && !b.screen.screen.screenSpace) return -1;
	    if (b.screen.screen.screenSpace && !a.screen.screen.screenSpace) return 1;
	    return b.drawOrder - a.drawOrder;
	  };

	  _proto2._getTargetElement = function _getTargetElement(camera, x, y) {
	    var result = null;
	    var closestDistance3d = Infinity;

	    this._elements.sort(this._sortHandler);

	    var rayScreen, ray3d;

	    for (var i = 0, len = this._elements.length; i < len; i++) {
	      var element = this._elements[i];

	      if (!element.layers.some(function (v) {
	        return camera.layersSet.has(v);
	      })) {
	        continue;
	      }

	      if (element.screen && element.screen.screen.screenSpace) {
	        if (rayScreen === undefined) {
	          rayScreen = this._calculateRayScreen(x, y, camera, rayA) ? rayA : null;
	        }

	        if (!rayScreen) continue;

	        var currentDistance = this._checkElement(rayScreen, element, true);

	        if (currentDistance >= 0) {
	          result = element;
	          break;
	        }
	      } else {
	        if (ray3d === undefined) {
	          ray3d = this._calculateRay3d(x, y, camera, rayB) ? rayB : null;
	        }

	        if (!ray3d) continue;

	        var _currentDistance = this._checkElement(ray3d, element, false);

	        if (_currentDistance >= 0) {
	          if (_currentDistance < closestDistance3d) {
	            result = element;
	            closestDistance3d = _currentDistance;
	          }

	          if (element.screen) {
	            result = element;
	            break;
	          }
	        }
	      }
	    }

	    return result;
	  };

	  _proto2._getTargetElementByRay = function _getTargetElementByRay(ray, camera) {
	    var result = null;
	    rayA.origin.copy(ray.origin);
	    rayA.direction.copy(ray.direction);
	    rayA.end.copy(rayA.direction).mulScalar(camera.farClip * 2).add(rayA.origin);

	    this._elements.sort(this._sortHandler);

	    for (var i = 0, len = this._elements.length; i < len; i++) {
	      var element = this._elements[i];

	      if (!element.layers.some(function (v) {
	        return camera.layersSet.has(v);
	      })) {
	        continue;
	      }

	      if (!element.screen || !element.screen.screen.screenSpace) {
	        if (this._checkElement(rayA, element, false) >= 0) {
	          result = element;
	          break;
	        }
	      }
	    }

	    return result;
	  };

	  _proto2._buildHitCorners = function _buildHitCorners(element, screenOrWorldCorners, scaleX, scaleY, scaleZ) {
	    var hitCorners = screenOrWorldCorners;
	    var button = element.entity && element.entity.button;

	    if (button) {
	      var hitPadding = element.entity.button.hitPadding || ZERO_VEC4;

	      _paddingTop.copy(element.entity.up);

	      _paddingBottom.copy(_paddingTop).mulScalar(-1);

	      _paddingRight.copy(element.entity.right);

	      _paddingLeft.copy(_paddingRight).mulScalar(-1);

	      _paddingTop.mulScalar(hitPadding.w * scaleY);

	      _paddingBottom.mulScalar(hitPadding.y * scaleY);

	      _paddingRight.mulScalar(hitPadding.z * scaleX);

	      _paddingLeft.mulScalar(hitPadding.x * scaleX);

	      _cornerBottomLeft.copy(hitCorners[0]).add(_paddingBottom).add(_paddingLeft);

	      _cornerBottomRight.copy(hitCorners[1]).add(_paddingBottom).add(_paddingRight);

	      _cornerTopRight.copy(hitCorners[2]).add(_paddingTop).add(_paddingRight);

	      _cornerTopLeft.copy(hitCorners[3]).add(_paddingTop).add(_paddingLeft);

	      hitCorners = [_cornerBottomLeft, _cornerBottomRight, _cornerTopRight, _cornerTopLeft];
	    }

	    if (scaleX < 0) {
	      var left = hitCorners[2].x;
	      var right = hitCorners[0].x;
	      hitCorners[0].x = left;
	      hitCorners[1].x = right;
	      hitCorners[2].x = right;
	      hitCorners[3].x = left;
	    }

	    if (scaleY < 0) {
	      var bottom = hitCorners[2].y;
	      var top = hitCorners[0].y;
	      hitCorners[0].y = bottom;
	      hitCorners[1].y = bottom;
	      hitCorners[2].y = top;
	      hitCorners[3].y = top;
	    }

	    if (scaleZ < 0) {
	      var x = hitCorners[2].x;
	      var y = hitCorners[2].y;
	      var z = hitCorners[2].z;
	      hitCorners[2].x = hitCorners[0].x;
	      hitCorners[2].y = hitCorners[0].y;
	      hitCorners[2].z = hitCorners[0].z;
	      hitCorners[0].x = x;
	      hitCorners[0].y = y;
	      hitCorners[0].z = z;
	    }

	    return hitCorners;
	  };

	  _proto2._calculateScaleToScreen = function _calculateScaleToScreen(element) {
	    var current = element.entity;
	    var screenScale = element.screen.screen.scale;

	    _accumulatedScale.set(screenScale, screenScale, screenScale);

	    while (current && !current.screen) {
	      _accumulatedScale.mul(current.getLocalScale());

	      current = current.parent;
	    }

	    return _accumulatedScale;
	  };

	  _proto2._calculateScaleToWorld = function _calculateScaleToWorld(element) {
	    var current = element.entity;

	    _accumulatedScale.set(1, 1, 1);

	    while (current) {
	      _accumulatedScale.mul(current.getLocalScale());

	      current = current.parent;
	    }

	    return _accumulatedScale;
	  };

	  _proto2._calculateRayScreen = function _calculateRayScreen(x, y, camera, ray) {
	    var sw = this.app.graphicsDevice.width;
	    var sh = this.app.graphicsDevice.height;
	    var cameraWidth = camera.rect.z * sw;
	    var cameraHeight = camera.rect.w * sh;
	    var cameraLeft = camera.rect.x * sw;
	    var cameraRight = cameraLeft + cameraWidth;
	    var cameraBottom = (1 - camera.rect.y) * sh;
	    var cameraTop = cameraBottom - cameraHeight;

	    var _x = x * sw / this._target.clientWidth;

	    var _y = y * sh / this._target.clientHeight;

	    if (_x >= cameraLeft && _x <= cameraRight && _y <= cameraBottom && _y >= cameraTop) {
	      _x = sw * (_x - cameraLeft) / cameraWidth;
	      _y = sh * (_y - cameraTop) / cameraHeight;
	      _y = sh - _y;
	      ray.origin.set(_x, _y, 1);
	      ray.direction.set(0, 0, -1);
	      ray.end.copy(ray.direction).mulScalar(2).add(ray.origin);
	      return true;
	    }

	    return false;
	  };

	  _proto2._calculateRay3d = function _calculateRay3d(x, y, camera, ray) {
	    var sw = this._target.clientWidth;
	    var sh = this._target.clientHeight;
	    var cameraWidth = camera.rect.z * sw;
	    var cameraHeight = camera.rect.w * sh;
	    var cameraLeft = camera.rect.x * sw;
	    var cameraRight = cameraLeft + cameraWidth;
	    var cameraBottom = (1 - camera.rect.y) * sh;
	    var cameraTop = cameraBottom - cameraHeight;
	    var _x = x;
	    var _y = y;

	    if (x >= cameraLeft && x <= cameraRight && y <= cameraBottom && _y >= cameraTop) {
	      _x = sw * (_x - cameraLeft) / cameraWidth;
	      _y = sh * (_y - cameraTop) / cameraHeight;
	      camera.screenToWorld(_x, _y, camera.nearClip, vecA$2);
	      camera.screenToWorld(_x, _y, camera.farClip, vecB$2);
	      ray.origin.copy(vecA$2);
	      ray.direction.set(0, 0, -1);
	      ray.end.copy(vecB$2);
	      return true;
	    }

	    return false;
	  };

	  _proto2._checkElement = function _checkElement(ray, element, screen) {
	    if (element.maskedBy) {
	      if (this._checkElement(ray, element.maskedBy.element, screen) < 0) {
	        return -1;
	      }
	    }

	    var scale;

	    if (screen) {
	      scale = this._calculateScaleToScreen(element);
	    } else {
	      scale = this._calculateScaleToWorld(element);
	    }

	    var corners = this._buildHitCorners(element, screen ? element.screenCorners : element.worldCorners, scale.x, scale.y, scale.z);

	    return intersectLineQuad(ray.origin, ray.end, corners);
	  };

	  _createClass(ElementInput, [{
	    key: "enabled",
	    get: function get() {
	      return this._enabled;
	    },
	    set: function set(value) {
	      this._enabled = value;
	    }
	  }, {
	    key: "app",
	    get: function get() {
	      return this._app || getApplication();
	    },
	    set: function set(value) {
	      this._app = value;
	    }
	  }]);

	  return ElementInput;
	}();

	var MAPS = {
	  DEFAULT: {
	    buttons: ['PAD_FACE_1', 'PAD_FACE_2', 'PAD_FACE_3', 'PAD_FACE_4', 'PAD_L_SHOULDER_1', 'PAD_R_SHOULDER_1', 'PAD_L_SHOULDER_2', 'PAD_R_SHOULDER_2', 'PAD_SELECT', 'PAD_START', 'PAD_L_STICK_BUTTON', 'PAD_R_STICK_BUTTON', 'PAD_UP', 'PAD_DOWN', 'PAD_LEFT', 'PAD_RIGHT', 'PAD_VENDOR'],
	    axes: ['PAD_L_STICK_X', 'PAD_L_STICK_Y', 'PAD_R_STICK_X', 'PAD_R_STICK_Y']
	  },
	  PS3: {
	    buttons: ['PAD_FACE_1', 'PAD_FACE_2', 'PAD_FACE_4', 'PAD_FACE_3', 'PAD_L_SHOULDER_1', 'PAD_R_SHOULDER_1', 'PAD_L_SHOULDER_2', 'PAD_R_SHOULDER_2', 'PAD_SELECT', 'PAD_START', 'PAD_L_STICK_BUTTON', 'PAD_R_STICK_BUTTON', 'PAD_UP', 'PAD_DOWN', 'PAD_LEFT', 'PAD_RIGHT', 'PAD_VENDOR'],
	    axes: ['PAD_L_STICK_X', 'PAD_L_STICK_Y', 'PAD_R_STICK_X', 'PAD_R_STICK_Y']
	  }
	};
	var PRODUCT_CODES = {
	  'Product: 0268': 'PS3'
	};

	var GamePads = function () {
	  function GamePads() {
	    this.gamepadsSupported = !!navigator.getGamepads || !!navigator.webkitGetGamepads;
	    this.current = [];
	    this.previous = [];
	    this.deadZone = 0.25;
	  }

	  var _proto = GamePads.prototype;

	  _proto.update = function update() {
	    for (var i = 0, l = this.current.length; i < l; i++) {
	      var buttons = this.current[i].pad.buttons;
	      var buttonsLen = buttons.length;

	      for (var j = 0; j < buttonsLen; j++) {
	        if (this.previous[i] === undefined) {
	          this.previous[i] = [];
	        }

	        this.previous[i][j] = buttons[j].pressed;
	      }
	    }

	    this.poll(this.current);
	  };

	  _proto.poll = function poll(pads) {
	    if (pads === void 0) {
	      pads = [];
	    }

	    if (pads.length > 0) {
	      pads.length = 0;
	    }

	    if (this.gamepadsSupported) {
	      var padDevices = navigator.getGamepads ? navigator.getGamepads() : navigator.webkitGetGamepads();

	      for (var i = 0, len = padDevices.length; i < len; i++) {
	        if (padDevices[i]) {
	          pads.push({
	            map: this.getMap(padDevices[i]),
	            pad: padDevices[i]
	          });
	        }
	      }
	    }

	    return pads;
	  };

	  _proto.getMap = function getMap(pad) {
	    for (var code in PRODUCT_CODES) {
	      if (pad.id.indexOf(code) >= 0) {
	        return MAPS[PRODUCT_CODES[code]];
	      }
	    }

	    return MAPS.DEFAULT;
	  };

	  _proto.isPressed = function isPressed(index, button) {
	    if (!this.current[index]) {
	      return false;
	    }

	    var key = this.current[index].map.buttons[button];
	    return this.current[index].pad.buttons[pc[key]].pressed;
	  };

	  _proto.wasPressed = function wasPressed(index, button) {
	    if (!this.current[index]) {
	      return false;
	    }

	    var key = this.current[index].map.buttons[button];
	    var i = pc[key];
	    return this.current[index].pad.buttons[i].pressed && !(this.previous[index] && this.previous[index][i]);
	  };

	  _proto.wasReleased = function wasReleased(index, button) {
	    if (!this.current[index]) {
	      return false;
	    }

	    var key = this.current[index].map.buttons[button];
	    var i = pc[key];
	    return !this.current[index].pad.buttons[i].pressed && this.previous[index] && this.previous[index][i];
	  };

	  _proto.getAxis = function getAxis(index, axes) {
	    if (!this.current[index]) {
	      return 0;
	    }

	    var key = this.current[index].map.axes[axes];
	    var value = this.current[index].pad.axes[pc[key]];

	    if (Math.abs(value) < this.deadZone) {
	      value = 0;
	    }

	    return value;
	  };

	  return GamePads;
	}();

	function getTouchTargetCoords(touch) {
	  var totalOffsetX = 0;
	  var totalOffsetY = 0;
	  var target = touch.target;

	  while (!(target instanceof HTMLElement)) {
	    target = target.parentNode;
	  }

	  var currentElement = target;

	  do {
	    totalOffsetX += currentElement.offsetLeft - currentElement.scrollLeft;
	    totalOffsetY += currentElement.offsetTop - currentElement.scrollTop;
	    currentElement = currentElement.offsetParent;
	  } while (currentElement);

	  return {
	    x: touch.pageX - totalOffsetX,
	    y: touch.pageY - totalOffsetY
	  };
	}

	var Touch = function Touch(touch) {
	  var coords = getTouchTargetCoords(touch);
	  this.id = touch.identifier;
	  this.x = coords.x;
	  this.y = coords.y;
	  this.target = touch.target;
	  this.touch = touch;
	};

	var TouchEvent = function () {
	  function TouchEvent(device, event) {
	    this.element = event.target;
	    this.event = event;
	    this.touches = [];
	    this.changedTouches = [];

	    if (event) {
	      for (var i = 0, l = event.touches.length; i < l; i++) {
	        this.touches.push(new Touch(event.touches[i]));
	      }

	      for (var _i = 0, _l = event.changedTouches.length; _i < _l; _i++) {
	        this.changedTouches.push(new Touch(event.changedTouches[_i]));
	      }
	    }
	  }

	  var _proto = TouchEvent.prototype;

	  _proto.getTouchById = function getTouchById(id, list) {
	    for (var i = 0, l = list.length; i < l; i++) {
	      if (list[i].id === id) {
	        return list[i];
	      }
	    }

	    return null;
	  };

	  return TouchEvent;
	}();

	var TouchDevice = function (_EventHandler) {
	  _inheritsLoose(TouchDevice, _EventHandler);

	  function TouchDevice(element) {
	    var _this;

	    _this = _EventHandler.call(this) || this;
	    _this._element = null;
	    _this._startHandler = _this._handleTouchStart.bind(_assertThisInitialized(_this));
	    _this._endHandler = _this._handleTouchEnd.bind(_assertThisInitialized(_this));
	    _this._moveHandler = _this._handleTouchMove.bind(_assertThisInitialized(_this));
	    _this._cancelHandler = _this._handleTouchCancel.bind(_assertThisInitialized(_this));

	    _this.attach(element);

	    return _this;
	  }

	  var _proto = TouchDevice.prototype;

	  _proto.attach = function attach(element) {
	    if (this._element) {
	      this.detach();
	    }

	    this._element = element;

	    this._element.addEventListener('touchstart', this._startHandler, false);

	    this._element.addEventListener('touchend', this._endHandler, false);

	    this._element.addEventListener('touchmove', this._moveHandler, false);

	    this._element.addEventListener('touchcancel', this._cancelHandler, false);
	  };

	  _proto.detach = function detach() {
	    if (this._element) {
	      this._element.removeEventListener('touchstart', this._startHandler, false);

	      this._element.removeEventListener('touchend', this._endHandler, false);

	      this._element.removeEventListener('touchmove', this._moveHandler, false);

	      this._element.removeEventListener('touchcancel', this._cancelHandler, false);
	    }

	    this._element = null;
	  };

	  _proto._handleTouchStart = function _handleTouchStart(e) {
	    this.fire('touchstart', new TouchEvent(this, e));
	  };

	  _proto._handleTouchEnd = function _handleTouchEnd(e) {
	    this.fire('touchend', new TouchEvent(this, e));
	  };

	  _proto._handleTouchMove = function _handleTouchMove(e) {
	    e.preventDefault();
	    this.fire('touchmove', new TouchEvent(this, e));
	  };

	  _proto._handleTouchCancel = function _handleTouchCancel(e) {
	    this.fire('touchcancel', new TouchEvent(this, e));
	  };

	  return TouchDevice;
	}(EventHandler);

	var AppOptions = function AppOptions() {
	  this.elementInput = void 0;
	  this.keyboard = void 0;
	  this.mouse = void 0;
	  this.touch = void 0;
	  this.gamepads = void 0;
	  this.scriptPrefix = void 0;
	  this.assetPrefix = void 0;
	  this.scriptsOrder = void 0;
	  this.soundManager = void 0;
	  this.graphicsDevice = void 0;
	  this.lightmapper = void 0;
	  this.batchManager = void 0;
	  this.xr = void 0;
	  this.componentSystems = [];
	  this.resourceHandlers = [];
	};

	var ComponentSystem = function (_EventHandler) {
	  _inheritsLoose(ComponentSystem, _EventHandler);

	  function ComponentSystem(app) {
	    var _this;

	    _this = _EventHandler.call(this) || this;
	    _this.app = app;
	    _this.store = {};
	    _this.schema = [];
	    return _this;
	  }

	  var _proto = ComponentSystem.prototype;

	  _proto.addComponent = function addComponent(entity, data) {
	    if (data === void 0) {
	      data = {};
	    }

	    var component = new this.ComponentType(this, entity);
	    var componentData = new this.DataType();
	    this.store[entity.getGuid()] = {
	      entity: entity,
	      data: componentData
	    };
	    entity[this.id] = component;
	    entity.c[this.id] = component;
	    this.initializeComponentData(component, data, []);
	    this.fire('add', entity, component);
	    return component;
	  };

	  _proto.removeComponent = function removeComponent(entity) {
	    var record = this.store[entity.getGuid()];
	    var component = entity.c[this.id];
	    this.fire('beforeremove', entity, component);
	    delete this.store[entity.getGuid()];
	    entity[this.id] = undefined;
	    delete entity.c[this.id];
	    this.fire('remove', entity, record.data);
	  };

	  _proto.cloneComponent = function cloneComponent(entity, clone) {
	    var src = this.store[entity.getGuid()];
	    return this.addComponent(clone, src.data);
	  };

	  _proto.initializeComponentData = function initializeComponentData(component, data, properties) {
	    if (data === void 0) {
	      data = {};
	    }

	    for (var i = 0, len = properties.length; i < len; i++) {
	      var descriptor = properties[i];
	      var name = void 0,
	          type = void 0;

	      if (typeof descriptor === 'object') {
	        name = descriptor.name;
	        type = descriptor.type;
	      } else {
	        name = descriptor;
	        type = undefined;
	      }

	      var value = data[name];

	      if (value !== undefined) {
	        if (type !== undefined) {
	          value = convertValue(value, type);
	        }

	        component[name] = value;
	      } else {
	        component[name] = component.data[name];
	      }
	    }

	    if (component.enabled && component.entity.enabled) {
	      component.onEnable();
	    }
	  };

	  _proto.getPropertiesOfType = function getPropertiesOfType(type) {
	    var matchingProperties = [];
	    var schema = this.schema || [];
	    schema.forEach(function (descriptor) {
	      if (descriptor && typeof descriptor === 'object' && descriptor.type === type) {
	        matchingProperties.push(descriptor);
	      }
	    });
	    return matchingProperties;
	  };

	  _proto.destroy = function destroy() {
	    this.off();
	  };

	  return ComponentSystem;
	}(EventHandler);

	function convertValue(value, type) {
	  if (!value) {
	    return value;
	  }

	  switch (type) {
	    case 'rgb':
	      if (value instanceof Color) {
	        return value.clone();
	      }

	      return new Color(value[0], value[1], value[2]);

	    case 'rgba':
	      if (value instanceof Color) {
	        return value.clone();
	      }

	      return new Color(value[0], value[1], value[2], value[3]);

	    case 'vec2':
	      if (value instanceof Vec2) {
	        return value.clone();
	      }

	      return new Vec2(value[0], value[1]);

	    case 'vec3':
	      if (value instanceof Vec3) {
	        return value.clone();
	      }

	      return new Vec3(value[0], value[1], value[2]);

	    case 'vec4':
	      if (value instanceof Vec4) {
	        return value.clone();
	      }

	      return new Vec4(value[0], value[1], value[2], value[3]);

	    case 'boolean':
	    case 'number':
	    case 'string':
	      return value;

	    case 'entity':
	      return value;

	    default:
	      throw new Error('Could not convert unhandled type: ' + type);
	  }
	}

	var AnimationComponent = function (_Component) {
	  _inheritsLoose(AnimationComponent, _Component);

	  function AnimationComponent(system, entity) {
	    var _this;

	    _this = _Component.call(this, system, entity) || this;
	    _this._animations = {};
	    _this._assets = [];
	    _this._loop = true;
	    _this.animEvaluator = null;
	    _this.model = null;
	    _this.skeleton = null;
	    _this.fromSkel = null;
	    _this.toSkel = null;
	    _this.animationsIndex = {};
	    _this.prevAnim = null;
	    _this.currAnim = null;
	    _this.blend = 0;
	    _this.blending = false;
	    _this.blendSpeed = 0;
	    _this.activate = true;
	    _this.speed = 1;
	    return _this;
	  }

	  var _proto = AnimationComponent.prototype;

	  _proto.play = function play(name, blendTime) {
	    if (blendTime === void 0) {
	      blendTime = 0;
	    }

	    if (!this.enabled || !this.entity.enabled) {
	      return;
	    }

	    if (!this.animations[name]) {
	      return;
	    }

	    this.prevAnim = this.currAnim;
	    this.currAnim = name;

	    if (this.model) {
	      if (!this.skeleton && !this.animEvaluator) {
	        this._createAnimationController();
	      }

	      var prevAnim = this.animations[this.prevAnim];
	      var currAnim = this.animations[this.currAnim];
	      this.blending = blendTime > 0 && !!this.prevAnim;

	      if (this.blending) {
	        this.blend = 0;
	        this.blendSpeed = 1 / blendTime;
	      }

	      if (this.skeleton) {
	        if (this.blending) {
	          this.fromSkel.animation = prevAnim;
	          this.fromSkel.addTime(this.skeleton._time);
	          this.toSkel.animation = currAnim;
	        } else {
	          this.skeleton.animation = currAnim;
	        }
	      }

	      if (this.animEvaluator) {
	        var animEvaluator = this.animEvaluator;

	        if (this.blending) {
	          while (animEvaluator.clips.length > 1) {
	            animEvaluator.removeClip(0);
	          }
	        } else {
	          this.animEvaluator.removeClips();
	        }

	        var clip = new AnimClip(this.animations[this.currAnim], 0, 1.0, true, this.loop);
	        clip.name = this.currAnim;
	        clip.blendWeight = this.blending ? 0 : 1;
	        clip.reset();
	        this.animEvaluator.addClip(clip);
	      }
	    }

	    this.playing = true;
	  };

	  _proto.getAnimation = function getAnimation(name) {
	    return this.animations[name];
	  };

	  _proto.setModel = function setModel(model) {
	    if (model !== this.model) {
	      this._resetAnimationController();

	      this.model = model;

	      if (this.animations && this.currAnim && this.animations[this.currAnim]) {
	        this.play(this.currAnim);
	      }
	    }
	  };

	  _proto.onSetAnimations = function onSetAnimations() {
	    var modelComponent = this.entity.model;

	    if (modelComponent) {
	      var m = modelComponent.model;

	      if (m && m !== this.model) {
	        this.setModel(m);
	      }
	    }

	    if (!this.currAnim && this.activate && this.enabled && this.entity.enabled) {
	      var animationNames = Object.keys(this._animations);

	      if (animationNames.length > 0) {
	        this.play(animationNames[0]);
	      }
	    }
	  };

	  _proto._resetAnimationController = function _resetAnimationController() {
	    this.skeleton = null;
	    this.fromSkel = null;
	    this.toSkel = null;
	    this.animEvaluator = null;
	  };

	  _proto._createAnimationController = function _createAnimationController() {
	    var model = this.model;
	    var animations = this.animations;
	    var hasJson = false;
	    var hasGlb = false;

	    for (var animation in animations) {
	      if (animations.hasOwnProperty(animation)) {
	        var anim = animations[animation];

	        if (anim.constructor === AnimTrack) {
	          hasGlb = true;
	        } else {
	          hasJson = true;
	        }
	      }
	    }

	    var graph = model.getGraph();

	    if (hasJson) {
	      this.fromSkel = new Skeleton(graph);
	      this.toSkel = new Skeleton(graph);
	      this.skeleton = new Skeleton(graph);
	      this.skeleton.looping = this.loop;
	      this.skeleton.setGraph(graph);
	    } else if (hasGlb) {
	      this.animEvaluator = new AnimEvaluator(new DefaultAnimBinder(this.entity));
	    }
	  };

	  _proto.loadAnimationAssets = function loadAnimationAssets(ids) {
	    var _this2 = this;

	    if (!ids || !ids.length) return;
	    var assets = this.system.app.assets;

	    var onAssetReady = function onAssetReady(asset) {
	      if (asset.resources.length > 1) {
	        for (var i = 0; i < asset.resources.length; i++) {
	          _this2.animations[asset.resources[i].name] = asset.resources[i];
	          _this2.animationsIndex[asset.id] = asset.resources[i].name;
	        }
	      } else {
	        _this2.animations[asset.name] = asset.resource;
	        _this2.animationsIndex[asset.id] = asset.name;
	      }

	      _this2.animations = _this2.animations;
	    };

	    var onAssetAdd = function onAssetAdd(asset) {
	      asset.off('change', _this2.onAssetChanged, _this2);
	      asset.on('change', _this2.onAssetChanged, _this2);
	      asset.off('remove', _this2.onAssetRemoved, _this2);
	      asset.on('remove', _this2.onAssetRemoved, _this2);

	      if (asset.resource) {
	        onAssetReady(asset);
	      } else {
	        asset.once('load', onAssetReady, _this2);
	        if (_this2.enabled && _this2.entity.enabled) assets.load(asset);
	      }
	    };

	    for (var i = 0, l = ids.length; i < l; i++) {
	      var asset = assets.get(ids[i]);

	      if (asset) {
	        onAssetAdd(asset);
	      } else {
	        assets.on('add:' + ids[i], onAssetAdd);
	      }
	    }
	  };

	  _proto.onAssetChanged = function onAssetChanged(asset, attribute, newValue, oldValue) {
	    if (attribute === 'resource' || attribute === 'resources') {
	      if (attribute === 'resources' && newValue && newValue.length === 0) {
	        newValue = null;
	      }

	      if (newValue) {
	        var restarted = false;

	        if (newValue.length > 1) {
	          if (oldValue && oldValue.length > 1) {
	            for (var i = 0; i < oldValue.length; i++) {
	              delete this.animations[oldValue[i].name];
	            }
	          } else {
	            delete this.animations[asset.name];
	          }

	          restarted = false;

	          for (var _i = 0; _i < newValue.length; _i++) {
	            this.animations[newValue[_i].name] = newValue[_i];

	            if (!restarted && this.currAnim === newValue[_i].name) {
	              if (this.playing && this.enabled && this.entity.enabled) {
	                restarted = true;
	                this.play(newValue[_i].name);
	              }
	            }
	          }

	          if (!restarted) {
	            this._stopCurrentAnimation();

	            this.onSetAnimations();
	          }
	        } else {
	          if (oldValue && oldValue.length > 1) {
	            for (var _i2 = 0; _i2 < oldValue.length; _i2++) {
	              delete this.animations[oldValue[_i2].name];
	            }
	          }

	          this.animations[asset.name] = newValue[0] || newValue;
	          restarted = false;

	          if (this.currAnim === asset.name) {
	            if (this.playing && this.enabled && this.entity.enabled) {
	              restarted = true;
	              this.play(asset.name);
	            }
	          }

	          if (!restarted) {
	            this._stopCurrentAnimation();

	            this.onSetAnimations();
	          }
	        }

	        this.animationsIndex[asset.id] = asset.name;
	      } else {
	        if (oldValue.length > 1) {
	          for (var _i3 = 0; _i3 < oldValue.length; _i3++) {
	            delete this.animations[oldValue[_i3].name];

	            if (this.currAnim === oldValue[_i3].name) {
	              this._stopCurrentAnimation();
	            }
	          }
	        } else {
	          delete this.animations[asset.name];

	          if (this.currAnim === asset.name) {
	            this._stopCurrentAnimation();
	          }
	        }

	        delete this.animationsIndex[asset.id];
	      }
	    }
	  };

	  _proto.onAssetRemoved = function onAssetRemoved(asset) {
	    asset.off('remove', this.onAssetRemoved, this);

	    if (this.animations) {
	      if (asset.resources.length > 1) {
	        for (var i = 0; i < asset.resources.length; i++) {
	          delete this.animations[asset.resources[i].name];
	          if (this.currAnim === asset.resources[i].name) this._stopCurrentAnimation();
	        }
	      } else {
	        delete this.animations[asset.name];
	        if (this.currAnim === asset.name) this._stopCurrentAnimation();
	      }

	      delete this.animationsIndex[asset.id];
	    }
	  };

	  _proto._stopCurrentAnimation = function _stopCurrentAnimation() {
	    this.currAnim = null;
	    this.playing = false;

	    if (this.skeleton) {
	      this.skeleton.currentTime = 0;
	      this.skeleton.animation = null;
	    }

	    if (this.animEvaluator) {
	      for (var i = 0; i < this.animEvaluator.clips.length; ++i) {
	        this.animEvaluator.clips[i].stop();
	      }

	      this.animEvaluator.update(0);
	      this.animEvaluator.removeClips();
	    }
	  };

	  _proto.onEnable = function onEnable() {
	    _Component.prototype.onEnable.call(this);

	    var assets = this.assets;
	    var registry = this.system.app.assets;

	    if (assets) {
	      for (var i = 0, len = assets.length; i < len; i++) {
	        var asset = assets[i];
	        if (!(asset instanceof Asset)) asset = registry.get(asset);
	        if (asset && !asset.resource) registry.load(asset);
	      }
	    }

	    if (this.activate && !this.currAnim) {
	      var animationNames = Object.keys(this.animations);

	      if (animationNames.length > 0) {
	        this.play(animationNames[0]);
	      }
	    }
	  };

	  _proto.onBeforeRemove = function onBeforeRemove() {
	    for (var i = 0; i < this.assets.length; i++) {
	      var asset = this.assets[i];

	      if (typeof asset === 'number') {
	        asset = this.system.app.assets.get(asset);
	      }

	      if (!asset) continue;
	      asset.off('change', this.onAssetChanged, this);
	      asset.off('remove', this.onAssetRemoved, this);
	    }

	    this.skeleton = null;
	    this.fromSkel = null;
	    this.toSkel = null;
	    this.animEvaluator = null;
	  };

	  _proto.update = function update(dt) {
	    if (this.blending) {
	      this.blend += dt * this.blendSpeed;

	      if (this.blend >= 1) {
	        this.blend = 1;
	      }
	    }

	    if (this.playing) {
	      var skeleton = this.skeleton;

	      if (skeleton !== null && this.model !== null) {
	        if (this.blending) {
	          skeleton.blend(this.fromSkel, this.toSkel, this.blend);
	        } else {
	          var delta = dt * this.speed;
	          skeleton.addTime(delta);

	          if (this.speed > 0 && skeleton._time === skeleton.animation.duration && !this.loop) {
	            this.playing = false;
	          } else if (this.speed < 0 && skeleton._time === 0 && !this.loop) {
	            this.playing = false;
	          }
	        }

	        if (this.blending && this.blend === 1) {
	          skeleton.animation = this.toSkel.animation;
	        }

	        skeleton.updateGraph();
	      }
	    }

	    var animEvaluator = this.animEvaluator;

	    if (animEvaluator) {
	      for (var i = 0; i < animEvaluator.clips.length; ++i) {
	        var clip = animEvaluator.clips[i];
	        clip.speed = this.speed;

	        if (!this.playing) {
	          clip.pause();
	        } else {
	          clip.resume();
	        }
	      }

	      if (this.blending && animEvaluator.clips.length > 1) {
	        animEvaluator.clips[1].blendWeight = this.blend;
	      }

	      animEvaluator.update(dt);
	    }

	    if (this.blending && this.blend === 1) {
	      this.blending = false;
	    }
	  };

	  _createClass(AnimationComponent, [{
	    key: "animations",
	    get: function get() {
	      return this._animations;
	    },
	    set: function set(value) {
	      this._animations = value;
	      this.onSetAnimations();
	    }
	  }, {
	    key: "assets",
	    get: function get() {
	      return this._assets;
	    },
	    set: function set(value) {
	      var assets = this._assets;

	      if (assets && assets.length) {
	        for (var i = 0; i < assets.length; i++) {
	          if (assets[i]) {
	            var asset = this.system.app.assets.get(assets[i]);

	            if (asset) {
	              asset.off('change', this.onAssetChanged, this);
	              asset.off('remove', this.onAssetRemoved, this);
	              var animName = this.animationsIndex[asset.id];
	              if (this.currAnim === animName) this._stopCurrentAnimation();
	              delete this.animations[animName];
	              delete this.animationsIndex[asset.id];
	            }
	          }
	        }
	      }

	      this._assets = value;
	      var assetIds = value.map(function (value) {
	        return value instanceof Asset ? value.id : value;
	      });
	      this.loadAnimationAssets(assetIds);
	    }
	  }, {
	    key: "currentTime",
	    get: function get() {
	      if (this.skeleton) {
	        return this.skeleton._time;
	      }

	      if (this.animEvaluator) {
	        var clips = this.animEvaluator.clips;

	        if (clips.length > 0) {
	          return clips[clips.length - 1].time;
	        }
	      }

	      return 0;
	    },
	    set: function set(currentTime) {
	      if (this.skeleton) {
	        this.skeleton.currentTime = currentTime;
	        this.skeleton.addTime(0);
	        this.skeleton.updateGraph();
	      }

	      if (this.animEvaluator) {
	        var clips = this.animEvaluator.clips;

	        for (var i = 0; i < clips.length; ++i) {
	          clips[i].time = currentTime;
	        }
	      }
	    }
	  }, {
	    key: "duration",
	    get: function get() {
	      return this.animations[this.currAnim].duration;
	    }
	  }, {
	    key: "loop",
	    get: function get() {
	      return this._loop;
	    },
	    set: function set(value) {
	      this._loop = value;

	      if (this.skeleton) {
	        this.skeleton.looping = value;
	      }

	      if (this.animEvaluator) {
	        for (var i = 0; i < this.animEvaluator.clips.length; ++i) {
	          this.animEvaluator.clips[i].loop = value;
	        }
	      }
	    }
	  }]);

	  return AnimationComponent;
	}(Component);

	var AnimationComponentData = function AnimationComponentData() {
	  this.enabled = true;
	};

	var _schema$l = ['enabled'];

	var AnimationComponentSystem = function (_ComponentSystem) {
	  _inheritsLoose(AnimationComponentSystem, _ComponentSystem);

	  function AnimationComponentSystem(app) {
	    var _this;

	    _this = _ComponentSystem.call(this, app) || this;
	    _this.id = 'animation';
	    _this.ComponentType = AnimationComponent;
	    _this.DataType = AnimationComponentData;
	    _this.schema = _schema$l;

	    _this.on('beforeremove', _this.onBeforeRemove, _assertThisInitialized(_this));

	    _this.app.systems.on('update', _this.onUpdate, _assertThisInitialized(_this));

	    return _this;
	  }

	  var _proto = AnimationComponentSystem.prototype;

	  _proto.initializeComponentData = function initializeComponentData(component, data, properties) {
	    for (var property in data) {
	      if (data.hasOwnProperty(property)) {
	        component[property] = data[property];
	      }
	    }

	    _ComponentSystem.prototype.initializeComponentData.call(this, component, data, _schema$l);
	  };

	  _proto.cloneComponent = function cloneComponent(entity, clone) {
	    this.addComponent(clone, {});
	    clone.animation.assets = entity.animation.assets.slice();
	    clone.animation.speed = entity.animation.speed;
	    clone.animation.loop = entity.animation.loop;
	    clone.animation.activate = entity.animation.activate;
	    clone.animation.enabled = entity.animation.enabled;
	    var clonedAnimations = {};
	    var animations = entity.animation.animations;

	    for (var key in animations) {
	      if (animations.hasOwnProperty(key)) {
	        clonedAnimations[key] = animations[key];
	      }
	    }

	    clone.animation.animations = clonedAnimations;
	    var clonedAnimationsIndex = {};
	    var animationsIndex = entity.animation.animationsIndex;

	    for (var _key in animationsIndex) {
	      if (animationsIndex.hasOwnProperty(_key)) {
	        clonedAnimationsIndex[_key] = animationsIndex[_key];
	      }
	    }

	    clone.animation.animationsIndex = clonedAnimationsIndex;
	    return clone.animation;
	  };

	  _proto.onBeforeRemove = function onBeforeRemove(entity, component) {
	    component.onBeforeRemove();
	  };

	  _proto.onUpdate = function onUpdate(dt) {
	    var components = this.store;

	    for (var id in components) {
	      if (components.hasOwnProperty(id)) {
	        var component = components[id];

	        if (component.data.enabled && component.entity.enabled) {
	          component.entity.animation.update(dt);
	        }
	      }
	    }
	  };

	  _proto.destroy = function destroy() {
	    _ComponentSystem.prototype.destroy.call(this);

	    this.app.systems.off('update', this.onUpdate, this);
	  };

	  return AnimationComponentSystem;
	}(ComponentSystem);

	Component._buildAccessors(AnimationComponent.prototype, _schema$l);

	var v2 = new Vec2();
	var v3 = new Vec3();
	var v4 = new Vec4();
	var c = new Color();
	var q = new Quat();

	var AnimComponentBinder = function (_DefaultAnimBinder) {
	  _inheritsLoose(AnimComponentBinder, _DefaultAnimBinder);

	  function AnimComponentBinder(animComponent, graph, layerName, mask, layerIndex) {
	    var _this;

	    _this = _DefaultAnimBinder.call(this, graph) || this;
	    _this.animComponent = animComponent;
	    _this._mask = mask;
	    _this.layerName = layerName;
	    _this.layerIndex = layerIndex;
	    return _this;
	  }

	  AnimComponentBinder._packFloat = function _packFloat(values) {
	    return values[0];
	  };

	  AnimComponentBinder._packBoolean = function _packBoolean(values) {
	    return !!values[0];
	  };

	  AnimComponentBinder._packVec2 = function _packVec2(values) {
	    v2.x = values[0];
	    v2.y = values[1];
	    return v2;
	  };

	  AnimComponentBinder._packVec3 = function _packVec3(values) {
	    v3.x = values[0];
	    v3.y = values[1];
	    v3.z = values[2];
	    return v3;
	  };

	  AnimComponentBinder._packVec4 = function _packVec4(values) {
	    v4.x = values[0];
	    v4.y = values[1];
	    v4.z = values[2];
	    v4.w = values[3];
	    return v4;
	  };

	  AnimComponentBinder._packColor = function _packColor(values) {
	    c.r = values[0];
	    c.g = values[1];
	    c.b = values[2];
	    c.a = values[3];
	    return c;
	  };

	  AnimComponentBinder._packQuat = function _packQuat(values) {
	    q.x = values[0];
	    q.y = values[1];
	    q.z = values[2];
	    q.w = values[3];
	    return q;
	  };

	  var _proto = AnimComponentBinder.prototype;

	  _proto.resolve = function resolve(path) {
	    var encodedPath = AnimBinder.encode(path.entityPath, path.component, path.propertyPath);
	    var target = this.targetCache[encodedPath];
	    if (target) return target;
	    var entity;
	    var propertyComponent;
	    var targetPath;

	    switch (path.component) {
	      case 'entity':
	        entity = this._getEntityFromHierarchy(path.entityPath);
	        targetPath = AnimBinder.encode(entity.path, 'entity', path.propertyPath);
	        propertyComponent = entity;
	        break;

	      case 'graph':
	        propertyComponent = this.findNode(path);
	        if (!propertyComponent) return null;
	        targetPath = AnimBinder.encode(propertyComponent.path, 'graph', path.propertyPath);
	        break;

	      default:
	        entity = this._getEntityFromHierarchy(path.entityPath);
	        propertyComponent = entity.findComponent(path.component);
	        if (!propertyComponent) return null;
	        targetPath = AnimBinder.encode(entity.path, path.component, path.propertyPath);
	        break;
	    }

	    target = this._createAnimTargetForProperty(propertyComponent, path.propertyPath, targetPath);
	    this.targetCache[encodedPath] = target;
	    return target;
	  };

	  _proto.update = function update(deltaTime) {
	    var activeNodes = this.activeNodes;

	    if (activeNodes) {
	      for (var i = 0; i < activeNodes.length; i++) {
	        activeNodes[i]._dirtifyLocal();
	      }
	    }
	  };

	  _proto._getEntityFromHierarchy = function _getEntityFromHierarchy(entityHierarchy) {
	    if (!this.animComponent.entity.name === entityHierarchy[0]) {
	      return null;
	    }

	    var currEntity = this.animComponent.entity;

	    if (entityHierarchy.length === 1) {
	      return currEntity;
	    }

	    return currEntity._parent.findByPath(entityHierarchy);
	  };

	  _proto._resolvePath = function _resolvePath(object, path, resolveLeaf) {
	    var steps = path.length - (resolveLeaf ? 0 : 1);

	    for (var i = 0; i < steps; i++) {
	      object = object[path[i]];
	    }

	    return object;
	  };

	  _proto._setter = function _setter(object, path, packFunc) {
	    var obj = this._resolvePath(object, path);

	    var key = path[path.length - 1];
	    var setterFuncName = 'set' + key.substring(0, 1).toUpperCase() + key.substring(1);

	    if (obj[setterFuncName]) {
	      var getterFunc = obj['get' + key.substring(0, 1).toUpperCase() + key.substring(1)].bind(obj);
	      var baseValues = getterFunc();
	      baseValues = [baseValues.x, baseValues.y, baseValues.z, baseValues.w];
	      var setterFunc = obj[setterFuncName].bind(obj);
	      return {
	        set: function set(values) {
	          setterFunc(packFunc(values));
	        },
	        get: function get() {
	          return baseValues;
	        }
	      };
	    }

	    var prop = obj[key];

	    if (typeof prop === 'object' && prop.hasOwnProperty('copy')) {
	      return function (values) {
	        prop.copy(packFunc(values));
	      };
	    }

	    if ([Vec2, Vec3, Vec4, Color, Quat].indexOf(obj.constructor) !== -1 && path.length > 1) {
	      var parent = path.length > 2 ? this._resolvePath(object, path.slice(0, -1)) : object;
	      var objKey = path[path.length - 2];
	      return function (values) {
	        obj[key] = packFunc(values);
	        parent[objKey] = obj;
	      };
	    }

	    return function (values) {
	      obj[key] = packFunc(values);
	    };
	  };

	  _proto._createAnimTargetForProperty = function _createAnimTargetForProperty(propertyComponent, propertyHierarchy, targetPath) {
	    if (this.handlers && propertyHierarchy[0].startsWith('weight.')) {
	      return this.handlers.weight(propertyComponent, propertyHierarchy[0].replace('weight.', ''));
	    } else if (this.handlers && propertyHierarchy[0] === 'material' && propertyHierarchy.length === 2) {
	      var materialPropertyName = propertyHierarchy[1];

	      if (materialPropertyName.endsWith('Map')) {
	        return this.handlers.materialTexture(propertyComponent, materialPropertyName);
	      }
	    }

	    var property = this._resolvePath(propertyComponent, propertyHierarchy, true);

	    if (typeof property === 'undefined') return null;
	    var setter;
	    var animDataType;
	    var animDataComponents;

	    if (typeof property === 'number') {
	      setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packFloat);
	      animDataType = 'vector';
	      animDataComponents = 1;
	    } else if (typeof property === 'boolean') {
	      setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packBoolean);
	      animDataType = 'vector';
	      animDataComponents = 1;
	    } else if (typeof property === 'object') {
	      switch (property.constructor) {
	        case Vec2:
	          setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packVec2);
	          animDataType = 'vector';
	          animDataComponents = 2;
	          break;

	        case Vec3:
	          setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packVec3);
	          animDataType = 'vector';
	          animDataComponents = 3;
	          break;

	        case Vec4:
	          setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packVec4);
	          animDataType = 'vector';
	          animDataComponents = 4;
	          break;

	        case Color:
	          setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packColor);
	          animDataType = 'vector';
	          animDataComponents = 4;
	          break;

	        case Quat:
	          setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packQuat);
	          animDataType = 'quaternion';
	          animDataComponents = 4;
	          break;

	        default:
	          return null;
	      }
	    }

	    if (propertyHierarchy.indexOf('material') !== -1) {
	      return new AnimTarget(function (values) {
	        setter(values);
	        propertyComponent.material.update();
	      }, animDataType, animDataComponents, targetPath);
	    }

	    return new AnimTarget(setter, animDataType, animDataComponents, targetPath);
	  };

	  _proto.rebind = function rebind() {
	    this.targetCache = {};

	    if (this.animComponent.rootBone) {
	      this.graph = this.animComponent.rootBone;
	    } else {
	      this.graph = this.animComponent.entity;
	    }

	    var nodes = {};

	    var flatten = function flatten(node) {
	      nodes[node.name] = node;

	      for (var i = 0; i < node.children.length; ++i) {
	        flatten(node.children[i]);
	      }
	    };

	    flatten(this.graph);
	    this.nodes = nodes;
	  };

	  return AnimComponentBinder;
	}(DefaultAnimBinder);

	var AnimComponentLayer = function () {
	  function AnimComponentLayer(name, controller, component, weight, blendType, normalizedWeight) {
	    if (weight === void 0) {
	      weight = 1;
	    }

	    if (blendType === void 0) {
	      blendType = ANIM_LAYER_OVERWRITE;
	    }

	    if (normalizedWeight === void 0) {
	      normalizedWeight = true;
	    }

	    this._name = name;
	    this._controller = controller;
	    this._component = component;
	    this._weight = weight;
	    this._blendType = blendType;
	    this._normalizedWeight = normalizedWeight;
	    this._mask = null;
	    this._blendTime = 0;
	    this._blendTimeElapsed = 0;
	    this._startingWeight = 0;
	    this._targetWeight = 0;
	  }

	  var _proto = AnimComponentLayer.prototype;

	  _proto.play = function play(name) {
	    this._controller.play(name);
	  };

	  _proto.pause = function pause() {
	    this._controller.pause();
	  };

	  _proto.reset = function reset() {
	    this._controller.reset();
	  };

	  _proto.rebind = function rebind() {
	    this._controller.rebind();
	  };

	  _proto.update = function update(dt) {
	    if (this._blendTime) {
	      if (this._blendTimeElapsed < this._blendTime) {
	        this.weight = math.lerp(this._startingWeight, this._targetWeight, this._blendTimeElapsed / this._blendTime);
	        this._blendTimeElapsed += dt;
	      } else {
	        this.weight = this._targetWeight;
	        this._blendTime = 0;
	        this._blendTimeElapsed = 0;
	        this._startingWeight = 0;
	        this._targetWeight = 0;
	      }
	    }

	    this._controller.update(dt);
	  };

	  _proto.blendToWeight = function blendToWeight(weight, time) {
	    this._startingWeight = this.weight;
	    this._targetWeight = weight;
	    this._blendTime = Math.max(0, time);
	    this._blendTimeElapsed = 0;
	  };

	  _proto.assignMask = function assignMask(mask) {
	    if (this._controller.assignMask(mask)) {
	      this._component.rebind();
	    }

	    this._mask = mask;
	  };

	  _proto.assignAnimation = function assignAnimation(nodePath, animTrack, speed, loop) {
	    if (animTrack.constructor !== AnimTrack) {
	      return;
	    }

	    this._controller.assignAnimation(nodePath, animTrack, speed, loop);

	    if (this._controller._transitions.length === 0) {
	      this._controller._transitions.push(new AnimTransition({
	        from: 'START',
	        to: nodePath
	      }));
	    }

	    if (this._component.activate && this._component.playable) {
	      this._component.playing = true;
	    }
	  };

	  _proto.removeNodeAnimations = function removeNodeAnimations(nodeName) {
	    if (this._controller.removeNodeAnimations(nodeName)) {
	      this._component.playing = false;
	    }
	  };

	  _proto.getAnimationAsset = function getAnimationAsset(stateName) {
	    return this._component.animationAssets[this.name + ":" + stateName];
	  };

	  _proto.transition = function transition(to, time, transitionOffset) {
	    if (time === void 0) {
	      time = 0;
	    }

	    if (transitionOffset === void 0) {
	      transitionOffset = null;
	    }

	    this._controller.updateStateFromTransition(new AnimTransition({
	      from: this._controller.activeStateName,
	      to: to,
	      time: time,
	      transitionOffset: transitionOffset
	    }));
	  };

	  _createClass(AnimComponentLayer, [{
	    key: "name",
	    get: function get() {
	      return this._name;
	    }
	  }, {
	    key: "playing",
	    get: function get() {
	      return this._controller.playing;
	    },
	    set: function set(value) {
	      this._controller.playing = value;
	    }
	  }, {
	    key: "playable",
	    get: function get() {
	      return this._controller.playable;
	    }
	  }, {
	    key: "activeState",
	    get: function get() {
	      return this._controller.activeStateName;
	    }
	  }, {
	    key: "previousState",
	    get: function get() {
	      return this._controller.previousStateName;
	    }
	  }, {
	    key: "activeStateProgress",
	    get: function get() {
	      return this._controller.activeStateProgress;
	    }
	  }, {
	    key: "activeStateDuration",
	    get: function get() {
	      return this._controller.activeStateDuration;
	    }
	  }, {
	    key: "activeStateCurrentTime",
	    get: function get() {
	      return this._controller.activeStateCurrentTime;
	    },
	    set: function set(time) {
	      var controller = this._controller;
	      var layerPlaying = controller.playing;
	      controller.playing = true;
	      controller.activeStateCurrentTime = time;

	      if (!layerPlaying) {
	        controller.update(0);
	      }

	      controller.playing = layerPlaying;
	    }
	  }, {
	    key: "transitioning",
	    get: function get() {
	      return this._controller.transitioning;
	    }
	  }, {
	    key: "transitionProgress",
	    get: function get() {
	      if (this.transitioning) {
	        return this._controller.transitionProgress;
	      }

	      return null;
	    }
	  }, {
	    key: "states",
	    get: function get() {
	      return this._controller.states;
	    }
	  }, {
	    key: "weight",
	    get: function get() {
	      return this._weight;
	    },
	    set: function set(value) {
	      this._weight = value;

	      this._component.dirtifyTargets();
	    }
	  }, {
	    key: "blendType",
	    get: function get() {
	      return this._blendType;
	    },
	    set: function set(value) {
	      if (value !== this._blendType) {
	        this._blendType = value;

	        if (this._controller.normalizeWeights) {
	          this._component.rebind();
	        }
	      }
	    }
	  }, {
	    key: "mask",
	    get: function get() {
	      return this._mask;
	    },
	    set: function set(value) {
	      if (this._controller.assignMask(value)) {
	        this._component.rebind();
	      }

	      this._mask = value;
	    }
	  }]);

	  return AnimComponentLayer;
	}();

	var AnimComponent = function (_Component) {
	  _inheritsLoose(AnimComponent, _Component);

	  function AnimComponent(system, entity) {
	    var _this;

	    _this = _Component.call(this, system, entity) || this;
	    _this._stateGraphAsset = null;
	    _this._animationAssets = {};
	    _this._speed = 1.0;
	    _this._activate = true;
	    _this._playing = false;
	    _this._rootBone = null;
	    _this._stateGraph = null;
	    _this._layers = [];
	    _this._layerIndices = {};
	    _this._parameters = {};
	    _this._targets = {};
	    _this._consumedTriggers = new Set();
	    _this._normalizeWeights = false;
	    return _this;
	  }

	  var _proto = AnimComponent.prototype;

	  _proto._onStateGraphAssetChangeEvent = function _onStateGraphAssetChangeEvent(asset) {
	    var prevAnimationAssets = this.animationAssets;
	    var prevMasks = this.layers.map(function (layer) {
	      return layer.mask;
	    });
	    this.removeStateGraph();
	    this._stateGraph = new AnimStateGraph(asset._data);
	    this.loadStateGraph(this._stateGraph);
	    this.animationAssets = prevAnimationAssets;
	    this.loadAnimationAssets();
	    this.layers.forEach(function (layer, i) {
	      layer.mask = prevMasks[i];
	    });
	    this.rebind();
	  };

	  _proto.dirtifyTargets = function dirtifyTargets() {
	    var targets = Object.values(this._targets);

	    for (var i = 0; i < targets.length; i++) {
	      targets[i].dirty = true;
	    }
	  };

	  _proto._addLayer = function _addLayer(_ref) {
	    var name = _ref.name,
	        states = _ref.states,
	        transitions = _ref.transitions,
	        weight = _ref.weight,
	        mask = _ref.mask,
	        blendType = _ref.blendType;
	    var graph;

	    if (this.rootBone) {
	      graph = this.rootBone;
	    } else {
	      graph = this.entity;
	    }

	    var layerIndex = this._layers.length;
	    var animBinder = new AnimComponentBinder(this, graph, name, mask, layerIndex);
	    var animEvaluator = new AnimEvaluator(animBinder);
	    var controller = new AnimController(animEvaluator, states, transitions, this._parameters, this._activate, this, this._consumedTriggers);

	    this._layers.push(new AnimComponentLayer(name, controller, this, weight, blendType));

	    this._layerIndices[name] = layerIndex;
	    return this._layers[layerIndex];
	  };

	  _proto.addLayer = function addLayer(name, weight, mask, blendType) {
	    var layer = this.findAnimationLayer(name);
	    if (layer) return layer;
	    var states = [{
	      'name': 'START',
	      'speed': 1
	    }];
	    var transitions = [];
	    return this._addLayer({
	      name: name,
	      states: states,
	      transitions: transitions,
	      weight: weight,
	      mask: mask,
	      blendType: blendType
	    });
	  };

	  _proto.loadStateGraph = function loadStateGraph(stateGraph) {
	    this._stateGraph = stateGraph;
	    this._parameters = {};
	    var paramKeys = Object.keys(stateGraph.parameters);

	    for (var i = 0; i < paramKeys.length; i++) {
	      var paramKey = paramKeys[i];
	      this._parameters[paramKey] = {
	        type: stateGraph.parameters[paramKey].type,
	        value: stateGraph.parameters[paramKey].value
	      };
	    }

	    this._layers = [];

	    for (var _i = 0; _i < stateGraph.layers.length; _i++) {
	      var layer = stateGraph.layers[_i];

	      this._addLayer.bind(this)(_extends({}, layer));
	    }

	    this.setupAnimationAssets();
	  };

	  _proto.setupAnimationAssets = function setupAnimationAssets() {
	    for (var i = 0; i < this._layers.length; i++) {
	      var layer = this._layers[i];
	      var layerName = layer.name;

	      for (var j = 0; j < layer.states.length; j++) {
	        var stateName = layer.states[j];

	        if (ANIM_CONTROL_STATES.indexOf(stateName) === -1) {
	          var stateKey = layerName + ':' + stateName;

	          if (!this._animationAssets[stateKey]) {
	            this._animationAssets[stateKey] = {
	              asset: null
	            };
	          }
	        }
	      }
	    }

	    this.loadAnimationAssets();
	  };

	  _proto.loadAnimationAssets = function loadAnimationAssets() {
	    for (var i = 0; i < this._layers.length; i++) {
	      var layer = this._layers[i];

	      for (var j = 0; j < layer.states.length; j++) {
	        var stateName = layer.states[j];
	        if (ANIM_CONTROL_STATES.indexOf(stateName) !== -1) continue;
	        var animationAsset = this._animationAssets[layer.name + ':' + stateName];

	        if (!animationAsset || !animationAsset.asset) {
	          this.removeNodeAnimations(stateName, layer.name);
	          continue;
	        }

	        var assetId = animationAsset.asset;
	        var asset = this.system.app.assets.get(assetId);

	        if (asset) {
	          if (asset.resource) {
	            this.onAnimationAssetLoaded(layer.name, stateName, asset);
	          } else {
	            asset.once('load', function (layerName, stateName) {
	              return function (asset) {
	                this.onAnimationAssetLoaded(layerName, stateName, asset);
	              }.bind(this);
	            }.bind(this)(layer.name, stateName));
	            this.system.app.assets.load(asset);
	          }
	        }
	      }
	    }
	  };

	  _proto.onAnimationAssetLoaded = function onAnimationAssetLoaded(layerName, stateName, asset) {
	    this.findAnimationLayer(layerName).assignAnimation(stateName, asset.resource);
	  };

	  _proto.removeStateGraph = function removeStateGraph() {
	    this._stateGraph = null;
	    this._stateGraphAsset = null;
	    this._animationAssets = {};
	    this._layers = [];
	    this._layerIndices = {};
	    this._parameters = {};
	    this._playing = false;
	    this.unbind();
	    this._targets = {};
	  };

	  _proto.reset = function reset() {
	    this._parameters = Object.assign({}, this._stateGraph.parameters);

	    for (var i = 0; i < this._layers.length; i++) {
	      var layerPlaying = this._layers[i].playing;

	      this._layers[i].reset();

	      this._layers[i].playing = layerPlaying;
	    }
	  };

	  _proto.unbind = function unbind() {
	    var _this2 = this;

	    if (!this._normalizeWeights) {
	      Object.keys(this._targets).forEach(function (targetKey) {
	        _this2._targets[targetKey].unbind();
	      });
	    }
	  };

	  _proto.rebind = function rebind() {
	    this._targets = {};

	    for (var i = 0; i < this._layers.length; i++) {
	      this._layers[i].rebind();
	    }
	  };

	  _proto.findAnimationLayer = function findAnimationLayer(name) {
	    var layerIndex = this._layerIndices[name];
	    return this._layers[layerIndex] || null;
	  };

	  _proto.addAnimationState = function addAnimationState(nodeName, animTrack, speed, loop, layerName) {
	    if (speed === void 0) {
	      speed = 1;
	    }

	    if (loop === void 0) {
	      loop = true;
	    }

	    if (layerName === void 0) {
	      layerName = 'Base';
	    }

	    if (!this._stateGraph) {
	      this.loadStateGraph(new AnimStateGraph({
	        'layers': [{
	          'name': layerName,
	          'states': [{
	            'name': 'START',
	            'speed': 1
	          }, {
	            'name': nodeName,
	            'speed': speed,
	            'loop': loop,
	            'defaultState': true
	          }],
	          'transitions': [{
	            'from': 'START',
	            'to': nodeName
	          }]
	        }],
	        'parameters': {}
	      }));
	    }

	    var layer = this.findAnimationLayer(layerName);

	    if (layer) {
	      layer.assignAnimation(nodeName, animTrack, speed, loop);
	    } else {
	      var _this$addLayer;

	      (_this$addLayer = this.addLayer(layerName)) == null ? void 0 : _this$addLayer.assignAnimation(nodeName, animTrack, speed, loop);
	    }
	  };

	  _proto.assignAnimation = function assignAnimation(nodePath, animTrack, layerName, speed, loop) {
	    if (speed === void 0) {
	      speed = 1;
	    }

	    if (loop === void 0) {
	      loop = true;
	    }

	    if (!this._stateGraph && nodePath.indexOf('.') === -1) {
	      this.loadStateGraph(new AnimStateGraph({
	        'layers': [{
	          'name': 'Base',
	          'states': [{
	            'name': 'START',
	            'speed': 1
	          }, {
	            'name': nodePath,
	            'speed': speed,
	            'loop': loop,
	            'defaultState': true
	          }],
	          'transitions': [{
	            'from': 'START',
	            'to': nodePath
	          }]
	        }],
	        'parameters': {}
	      }));
	      this.baseLayer.assignAnimation(nodePath, animTrack);
	      return;
	    }

	    var layer = layerName ? this.findAnimationLayer(layerName) : this.baseLayer;

	    if (!layer) {
	      return;
	    }

	    layer.assignAnimation(nodePath, animTrack, speed, loop);
	  };

	  _proto.removeNodeAnimations = function removeNodeAnimations(nodeName, layerName) {
	    var layer = layerName ? this.findAnimationLayer(layerName) : this.baseLayer;

	    if (!layer) {
	      return;
	    }

	    layer.removeNodeAnimations(nodeName);
	  };

	  _proto.getParameterValue = function getParameterValue(name, type) {
	    var param = this._parameters[name];

	    if (param && param.type === type) {
	      return param.value;
	    }

	    return undefined;
	  };

	  _proto.setParameterValue = function setParameterValue(name, type, value) {
	    var param = this._parameters[name];

	    if (param && param.type === type) {
	      param.value = value;
	      return;
	    }
	  };

	  _proto.getFloat = function getFloat(name) {
	    return this.getParameterValue(name, ANIM_PARAMETER_FLOAT);
	  };

	  _proto.setFloat = function setFloat(name, value) {
	    this.setParameterValue(name, ANIM_PARAMETER_FLOAT, value);
	  };

	  _proto.getInteger = function getInteger(name) {
	    return this.getParameterValue(name, ANIM_PARAMETER_INTEGER);
	  };

	  _proto.setInteger = function setInteger(name, value) {
	    if (typeof value === 'number' && value % 1 === 0) {
	      this.setParameterValue(name, ANIM_PARAMETER_INTEGER, value);
	    }
	  };

	  _proto.getBoolean = function getBoolean(name) {
	    return this.getParameterValue(name, ANIM_PARAMETER_BOOLEAN);
	  };

	  _proto.setBoolean = function setBoolean(name, value) {
	    this.setParameterValue(name, ANIM_PARAMETER_BOOLEAN, !!value);
	  };

	  _proto.getTrigger = function getTrigger(name) {
	    return this.getParameterValue(name, ANIM_PARAMETER_TRIGGER);
	  };

	  _proto.setTrigger = function setTrigger(name, singleFrame) {
	    if (singleFrame === void 0) {
	      singleFrame = false;
	    }

	    this.setParameterValue(name, ANIM_PARAMETER_TRIGGER, true);

	    if (singleFrame) {
	      this._consumedTriggers.add(name);
	    }
	  };

	  _proto.resetTrigger = function resetTrigger(name) {
	    this.setParameterValue(name, ANIM_PARAMETER_TRIGGER, false);
	  };

	  _proto.onBeforeRemove = function onBeforeRemove() {
	    if (Number.isFinite(this._stateGraphAsset)) {
	      var stateGraphAsset = this.system.app.assets.get(this._stateGraphAsset);
	      stateGraphAsset.off('change', this._onStateGraphAssetChangeEvent, this);
	    }
	  };

	  _proto.update = function update(dt) {
	    var _this3 = this;

	    for (var i = 0; i < this.layers.length; i++) {
	      this.layers[i].update(dt * this.speed);
	    }

	    this._consumedTriggers.forEach(function (trigger) {
	      _this3.parameters[trigger].value = false;
	    });

	    this._consumedTriggers.clear();
	  };

	  _proto.resolveDuplicatedEntityReferenceProperties = function resolveDuplicatedEntityReferenceProperties(oldAnim, duplicatedIdsMap) {
	    if (oldAnim.rootBone && duplicatedIdsMap[oldAnim.rootBone.getGuid()]) {
	      this.rootBone = duplicatedIdsMap[oldAnim.rootBone.getGuid()];
	    } else {
	      this.rebind();
	    }
	  };

	  _createClass(AnimComponent, [{
	    key: "stateGraphAsset",
	    get: function get() {
	      return this._stateGraphAsset;
	    },
	    set: function set(value) {
	      var _this4 = this;

	      if (value === null) {
	        this.removeStateGraph();
	        return;
	      }

	      if (this._stateGraphAsset) {
	        var stateGraphAsset = this.system.app.assets.get(this._stateGraphAsset);
	        stateGraphAsset.off('change', this._onStateGraphAssetChangeEvent, this);
	      }

	      var _id;

	      var _asset;

	      if (value instanceof Asset) {
	        _id = value.id;
	        _asset = this.system.app.assets.get(_id);

	        if (!_asset) {
	          this.system.app.assets.add(value);
	          _asset = this.system.app.assets.get(_id);
	        }
	      } else {
	        _id = value;
	        _asset = this.system.app.assets.get(_id);
	      }

	      if (!_asset || this._stateGraphAsset === _id) {
	        return;
	      }

	      if (_asset.resource) {
	        this._stateGraph = _asset.resource;
	        this.loadStateGraph(this._stateGraph);

	        _asset.on('change', this._onStateGraphAssetChangeEvent, this);
	      } else {
	        _asset.once('load', function (asset) {
	          _this4._stateGraph = asset.resource;

	          _this4.loadStateGraph(_this4._stateGraph);
	        });

	        _asset.on('change', this._onStateGraphAssetChangeEvent, this);

	        this.system.app.assets.load(_asset);
	      }

	      this._stateGraphAsset = _id;
	    }
	  }, {
	    key: "normalizeWeights",
	    get: function get() {
	      return this._normalizeWeights;
	    },
	    set: function set(value) {
	      this._normalizeWeights = value;
	      this.unbind();
	    }
	  }, {
	    key: "animationAssets",
	    get: function get() {
	      return this._animationAssets;
	    },
	    set: function set(value) {
	      this._animationAssets = value;
	      this.loadAnimationAssets();
	    }
	  }, {
	    key: "speed",
	    get: function get() {
	      return this._speed;
	    },
	    set: function set(value) {
	      this._speed = value;
	    }
	  }, {
	    key: "activate",
	    get: function get() {
	      return this._activate;
	    },
	    set: function set(value) {
	      this._activate = value;
	    }
	  }, {
	    key: "playing",
	    get: function get() {
	      return this._playing;
	    },
	    set: function set(value) {
	      this._playing = value;
	    }
	  }, {
	    key: "rootBone",
	    get: function get() {
	      return this._rootBone;
	    },
	    set: function set(value) {
	      if (typeof value === 'string') {
	        var entity = this.entity.root.findByGuid(value);
	        this._rootBone = entity;
	      } else if (value instanceof Entity) {
	        this._rootBone = value;
	      } else {
	        this._rootBone = null;
	      }

	      this.rebind();
	    }
	  }, {
	    key: "stateGraph",
	    get: function get() {
	      return this._stateGraph;
	    },
	    set: function set(value) {
	      this._stateGraph = value;
	    }
	  }, {
	    key: "layers",
	    get: function get() {
	      return this._layers;
	    }
	  }, {
	    key: "layerIndices",
	    get: function get() {
	      return this._layerIndices;
	    },
	    set: function set(value) {
	      this._layerIndices = value;
	    }
	  }, {
	    key: "parameters",
	    get: function get() {
	      return this._parameters;
	    },
	    set: function set(value) {
	      this._parameters = value;
	    }
	  }, {
	    key: "targets",
	    get: function get() {
	      return this._targets;
	    },
	    set: function set(value) {
	      this._targets = value;
	    }
	  }, {
	    key: "playable",
	    get: function get() {
	      for (var i = 0; i < this._layers.length; i++) {
	        if (!this._layers[i].playable) {
	          return false;
	        }
	      }

	      return true;
	    }
	  }, {
	    key: "baseLayer",
	    get: function get() {
	      if (this._layers.length > 0) {
	        return this._layers[0];
	      }

	      return null;
	    }
	  }]);

	  return AnimComponent;
	}(Component);

	var AnimComponentData = function AnimComponentData() {
	  this.enabled = true;
	};

	var _schema$k = ['enabled'];

	var AnimComponentSystem = function (_ComponentSystem) {
	  _inheritsLoose(AnimComponentSystem, _ComponentSystem);

	  function AnimComponentSystem(app) {
	    var _this;

	    _this = _ComponentSystem.call(this, app) || this;
	    _this.id = 'anim';
	    _this.ComponentType = AnimComponent;
	    _this.DataType = AnimComponentData;
	    _this.schema = _schema$k;

	    _this.on('beforeremove', _this.onBeforeRemove, _assertThisInitialized(_this));

	    _this.app.systems.on('animationUpdate', _this.onAnimationUpdate, _assertThisInitialized(_this));

	    return _this;
	  }

	  var _proto = AnimComponentSystem.prototype;

	  _proto.initializeComponentData = function initializeComponentData(component, data, properties) {
	    _ComponentSystem.prototype.initializeComponentData.call(this, component, data, _schema$k);

	    var complexProperties = ['animationAssets', 'stateGraph', 'layers', 'masks'];
	    Object.keys(data).forEach(function (key) {
	      if (complexProperties.includes(key)) return;
	      component[key] = data[key];
	    });

	    if (data.stateGraph) {
	      component.stateGraph = data.stateGraph;
	      component.loadStateGraph(component.stateGraph);
	    }

	    if (data.layers) {
	      data.layers.forEach(function (layer, i) {
	        layer._controller.states.forEach(function (stateKey) {
	          layer._controller._states[stateKey]._animationList.forEach(function (node) {
	            component.layers[i].assignAnimation(node.name, node.animTrack);
	          });
	        });
	      });
	    } else if (data.animationAssets) {
	      component.animationAssets = Object.assign(component.animationAssets, data.animationAssets);
	    }

	    if (data.masks) {
	      Object.keys(data.masks).forEach(function (key) {
	        if (component.layers[key]) {
	          var maskData = data.masks[key].mask;
	          var mask = {};
	          Object.keys(maskData).forEach(function (maskKey) {
	            mask[decodeURI(maskKey)] = maskData[maskKey];
	          });
	          component.layers[key].mask = mask;
	        }
	      });
	    }
	  };

	  _proto.onAnimationUpdate = function onAnimationUpdate(dt) {
	    var components = this.store;

	    for (var id in components) {
	      if (components.hasOwnProperty(id)) {
	        var component = components[id].entity.anim;
	        var componentData = component.data;

	        if (componentData.enabled && component.entity.enabled && component.playing) {
	          component.update(dt);
	        }
	      }
	    }
	  };

	  _proto.cloneComponent = function cloneComponent(entity, clone) {
	    var masks;

	    if (!entity.anim.rootBone || entity.anim.rootBone === entity) {
	      masks = {};
	      entity.anim.layers.forEach(function (layer, i) {
	        if (layer.mask) {
	          var mask = {};
	          Object.keys(layer.mask).forEach(function (path) {
	            var pathArr = path.split('/');
	            pathArr.shift();
	            var clonePath = [clone.name].concat(pathArr).join('/');
	            mask[clonePath] = layer.mask[path];
	          });
	          masks[i] = {
	            mask: mask
	          };
	        }
	      });
	    }

	    var data = {
	      stateGraphAsset: entity.anim.stateGraphAsset,
	      animationAssets: entity.anim.animationAssets,
	      speed: entity.anim.speed,
	      activate: entity.anim.activate,
	      playing: entity.anim.playing,
	      rootBone: entity.anim.rootBone,
	      stateGraph: entity.anim.stateGraph,
	      layers: entity.anim.layers,
	      layerIndices: entity.anim.layerIndices,
	      parameters: entity.anim.parameters,
	      normalizeWeights: entity.anim.normalizeWeights,
	      masks: masks
	    };
	    return this.addComponent(clone, data);
	  };

	  _proto.onBeforeRemove = function onBeforeRemove(entity, component) {
	    component.onBeforeRemove();
	  };

	  _proto.destroy = function destroy() {
	    _ComponentSystem.prototype.destroy.call(this);

	    this.app.systems.off('animationUpdate', this.onAnimationUpdate, this);
	  };

	  return AnimComponentSystem;
	}(ComponentSystem);

	Component._buildAccessors(AnimComponent.prototype, _schema$k);

	var AudioListenerComponent = function (_Component) {
	  _inheritsLoose(AudioListenerComponent, _Component);

	  function AudioListenerComponent(system, entity) {
	    return _Component.call(this, system, entity) || this;
	  }

	  var _proto = AudioListenerComponent.prototype;

	  _proto.setCurrentListener = function setCurrentListener() {
	    if (this.enabled && this.entity.audiolistener && this.entity.enabled) {
	      this.system.current = this.entity;
	      var position = this.system.current.getPosition();
	      this.system.manager.listener.setPosition(position);
	    }
	  };

	  _proto.onEnable = function onEnable() {
	    this.setCurrentListener();
	  };

	  _proto.onDisable = function onDisable() {
	    if (this.system.current === this.entity) {
	      this.system.current = null;
	    }
	  };

	  return AudioListenerComponent;
	}(Component);

	var AudioListenerComponentData = function AudioListenerComponentData() {
	  this.enabled = true;
	};

	var _schema$j = ['enabled'];

	var AudioListenerComponentSystem = function (_ComponentSystem) {
	  _inheritsLoose(AudioListenerComponentSystem, _ComponentSystem);

	  function AudioListenerComponentSystem(app) {
	    var _this;

	    _this = _ComponentSystem.call(this, app) || this;
	    _this.id = 'audiolistener';
	    _this.ComponentType = AudioListenerComponent;
	    _this.DataType = AudioListenerComponentData;
	    _this.schema = _schema$j;
	    _this.manager = app.soundManager;
	    _this.current = null;

	    _this.app.systems.on('update', _this.onUpdate, _assertThisInitialized(_this));

	    return _this;
	  }

	  var _proto = AudioListenerComponentSystem.prototype;

	  _proto.initializeComponentData = function initializeComponentData(component, data, properties) {
	    properties = ['enabled'];

	    _ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
	  };

	  _proto.onUpdate = function onUpdate(dt) {
	    if (this.current) {
	      var position = this.current.getPosition();
	      this.manager.listener.setPosition(position);
	      var wtm = this.current.getWorldTransform();
	      this.manager.listener.setOrientation(wtm);
	    }
	  };

	  _proto.destroy = function destroy() {
	    _ComponentSystem.prototype.destroy.call(this);

	    this.app.systems.off('update', this.onUpdate, this);
	  };

	  return AudioListenerComponentSystem;
	}(ComponentSystem);

	Component._buildAccessors(AudioListenerComponent.prototype, _schema$j);

	var AudioSourceComponent = function (_Component) {
	  _inheritsLoose(AudioSourceComponent, _Component);

	  function AudioSourceComponent(system, entity) {
	    var _this;

	    _this = _Component.call(this, system, entity) || this;

	    _this.on('set_assets', _this.onSetAssets, _assertThisInitialized(_this));

	    _this.on('set_loop', _this.onSetLoop, _assertThisInitialized(_this));

	    _this.on('set_volume', _this.onSetVolume, _assertThisInitialized(_this));

	    _this.on('set_pitch', _this.onSetPitch, _assertThisInitialized(_this));

	    _this.on('set_minDistance', _this.onSetMinDistance, _assertThisInitialized(_this));

	    _this.on('set_maxDistance', _this.onSetMaxDistance, _assertThisInitialized(_this));

	    _this.on('set_rollOffFactor', _this.onSetRollOffFactor, _assertThisInitialized(_this));

	    _this.on('set_distanceModel', _this.onSetDistanceModel, _assertThisInitialized(_this));

	    _this.on('set_3d', _this.onSet3d, _assertThisInitialized(_this));

	    return _this;
	  }

	  var _proto = AudioSourceComponent.prototype;

	  _proto.play = function play(name) {
	    if (!this.enabled || !this.entity.enabled) {
	      return;
	    }

	    if (this.channel) {
	      this.stop();
	    }

	    var channel;
	    var componentData = this.data;

	    if (componentData.sources[name]) {
	      if (!componentData['3d']) {
	        channel = this.system.manager.playSound(componentData.sources[name], componentData);
	        componentData.currentSource = name;
	        componentData.channel = channel;
	      } else {
	        var pos = this.entity.getPosition();
	        channel = this.system.manager.playSound3d(componentData.sources[name], pos, componentData);
	        componentData.currentSource = name;
	        componentData.channel = channel;
	      }
	    }
	  };

	  _proto.pause = function pause() {
	    if (this.channel) {
	      this.channel.pause();
	    }
	  };

	  _proto.unpause = function unpause() {
	    if (this.channel && this.channel.paused) {
	      this.channel.unpause();
	    }
	  };

	  _proto.stop = function stop() {
	    if (this.channel) {
	      this.channel.stop();
	      this.channel = null;
	    }
	  };

	  _proto.onSetAssets = function onSetAssets(name, oldValue, newValue) {
	    var newAssets = [];
	    var len = newValue.length;

	    if (oldValue && oldValue.length) {
	      for (var i = 0; i < oldValue.length; i++) {
	        if (oldValue[i]) {
	          var asset = this.system.app.assets.get(oldValue[i]);

	          if (asset) {
	            asset.off('change', this.onAssetChanged, this);
	            asset.off('remove', this.onAssetRemoved, this);

	            if (this.currentSource === asset.name) {
	              this.stop();
	            }
	          }
	        }
	      }
	    }

	    if (len) {
	      for (var _i = 0; _i < len; _i++) {
	        if (oldValue.indexOf(newValue[_i]) < 0) {
	          if (newValue[_i] instanceof Asset) {
	            newAssets.push(newValue[_i].id);
	          } else {
	            newAssets.push(newValue[_i]);
	          }
	        }
	      }
	    }

	    if (!this.system._inTools && newAssets.length) {
	      this.loadAudioSourceAssets(newAssets);
	    }
	  };

	  _proto.onAssetChanged = function onAssetChanged(asset, attribute, newValue, oldValue) {
	    if (attribute === 'resource') {
	      var sources = this.data.sources;

	      if (sources) {
	        this.data.sources[asset.name] = newValue;

	        if (this.data.currentSource === asset.name) {
	          if (this.channel) {
	            if (this.channel.paused) {
	              this.play(asset.name);
	              this.pause();
	            } else {
	              this.play(asset.name);
	            }
	          }
	        }
	      }
	    }
	  };

	  _proto.onAssetRemoved = function onAssetRemoved(asset) {
	    asset.off('remove', this.onAssetRemoved, this);

	    if (this.data.sources[asset.name]) {
	      delete this.data.sources[asset.name];

	      if (this.data.currentSource === asset.name) {
	        this.stop();
	        this.data.currentSource = null;
	      }
	    }
	  };

	  _proto.onSetLoop = function onSetLoop(name, oldValue, newValue) {
	    if (oldValue !== newValue) {
	      if (this.channel) {
	        this.channel.setLoop(newValue);
	      }
	    }
	  };

	  _proto.onSetVolume = function onSetVolume(name, oldValue, newValue) {
	    if (oldValue !== newValue) {
	      if (this.channel) {
	        this.channel.setVolume(newValue);
	      }
	    }
	  };

	  _proto.onSetPitch = function onSetPitch(name, oldValue, newValue) {
	    if (oldValue !== newValue) {
	      if (this.channel) {
	        this.channel.setPitch(newValue);
	      }
	    }
	  };

	  _proto.onSetMaxDistance = function onSetMaxDistance(name, oldValue, newValue) {
	    if (oldValue !== newValue) {
	      if (this.channel instanceof Channel3d) {
	        this.channel.setMaxDistance(newValue);
	      }
	    }
	  };

	  _proto.onSetMinDistance = function onSetMinDistance(name, oldValue, newValue) {
	    if (oldValue !== newValue) {
	      if (this.channel instanceof Channel3d) {
	        this.channel.setMinDistance(newValue);
	      }
	    }
	  };

	  _proto.onSetRollOffFactor = function onSetRollOffFactor(name, oldValue, newValue) {
	    if (oldValue !== newValue) {
	      if (this.channel instanceof Channel3d) {
	        this.channel.setRollOffFactor(newValue);
	      }
	    }
	  };

	  _proto.onSetDistanceModel = function onSetDistanceModel(name, oldValue, newValue) {
	    if (oldValue !== newValue) {
	      if (this.channel instanceof Channel3d) {
	        this.channel.setDistanceModel(newValue);
	      }
	    }
	  };

	  _proto.onSet3d = function onSet3d(name, oldValue, newValue) {
	    if (oldValue !== newValue) {
	      if (this.system.initialized && this.currentSource) {
	        var paused = false;
	        var suspended = false;

	        if (this.channel) {
	          paused = this.channel.paused;
	          suspended = this.channel.suspended;
	        }

	        this.play(this.currentSource);

	        if (this.channel) {
	          this.channel.paused = paused;
	          this.channel.suspended = suspended;
	        }
	      }
	    }
	  };

	  _proto.onEnable = function onEnable() {
	    var assets = this.data.assets;

	    if (assets) {
	      var registry = this.system.app.assets;

	      for (var i = 0, len = assets.length; i < len; i++) {
	        var asset = assets[i];
	        if (!(asset instanceof Asset)) asset = registry.get(asset);

	        if (asset && !asset.resource) {
	          registry.load(asset);
	        }
	      }
	    }

	    if (this.system.initialized) {
	      if (this.data.activate && !this.channel) {
	        this.play(this.currentSource);
	      } else {
	        this.unpause();
	      }
	    }
	  };

	  _proto.onDisable = function onDisable() {
	    this.pause();
	  };

	  _proto.loadAudioSourceAssets = function loadAudioSourceAssets(ids) {
	    var _this2 = this;

	    var assets = ids.map(function (id) {
	      return _this2.system.app.assets.get(id);
	    });
	    var sources = {};
	    var currentSource = null;
	    var count = assets.length;

	    var _error = function _error(e) {
	      count--;
	    };

	    var _done = function _done() {
	      _this2.data.sources = sources;
	      _this2.data.currentSource = currentSource;

	      if (_this2.enabled && _this2.activate && currentSource) {
	        _this2.onEnable();
	      }
	    };

	    assets.forEach(function (asset, index) {
	      if (asset) {
	        currentSource = currentSource || asset.name;
	        asset.off('change', _this2.onAssetChanged, _this2);
	        asset.on('change', _this2.onAssetChanged, _this2);
	        asset.off('remove', _this2.onAssetRemoved, _this2);
	        asset.on('remove', _this2.onAssetRemoved, _this2);
	        asset.off('error', _error, _this2);
	        asset.on('error', _error, _this2);
	        asset.ready(function (asset) {
	          sources[asset.name] = asset.resource;
	          count--;

	          if (count === 0) {
	            _done();
	          }
	        });
	        if (!asset.resource && _this2.enabled && _this2.entity.enabled) _this2.system.app.assets.load(asset);
	      } else {
	        count--;

	        if (count === 0) {
	          _done();
	        }

	        _this2.system.app.assets.on('add:' + ids[index], function (asset) {
	          asset.ready(function (asset) {
	            _this2.data.sources[asset.name] = asset.resource;
	          });
	          if (!asset.resource) _this2.system.app.assets.load(asset);
	        });
	      }
	    });
	  };

	  return AudioSourceComponent;
	}(Component);

	var AudioSourceComponentData = function AudioSourceComponentData() {
	  this.enabled = true;
	  this.assets = [];
	  this.activate = true;
	  this.volume = 1;
	  this.pitch = 1;
	  this.loop = false;
	  this['3d'] = true;
	  this.minDistance = 1;
	  this.maxDistance = 10000;
	  this.rollOffFactor = 1;
	  this.distanceModel = DISTANCE_INVERSE;
	  this.paused = true;
	  this.sources = {};
	  this.currentSource = null;
	  this.channel = null;
	};

	var _schema$i = ['enabled', 'assets', 'volume', 'pitch', 'loop', 'activate', '3d', 'minDistance', 'maxDistance', 'rollOffFactor', 'distanceModel', 'sources', 'currentSource', 'channel'];

	var AudioSourceComponentSystem = function (_ComponentSystem) {
	  _inheritsLoose(AudioSourceComponentSystem, _ComponentSystem);

	  function AudioSourceComponentSystem(app) {
	    var _this;

	    _this = _ComponentSystem.call(this, app) || this;
	    _this.id = 'audiosource';
	    _this.ComponentType = AudioSourceComponent;
	    _this.DataType = AudioSourceComponentData;
	    _this.schema = _schema$i;
	    _this.manager = app.soundManager;
	    _this.initialized = false;

	    _this.app.systems.on('initialize', _this.onInitialize, _assertThisInitialized(_this));

	    _this.app.systems.on('update', _this.onUpdate, _assertThisInitialized(_this));

	    _this.on('remove', _this.onRemove, _assertThisInitialized(_this));

	    return _this;
	  }

	  var _proto = AudioSourceComponentSystem.prototype;

	  _proto.initializeComponentData = function initializeComponentData(component, data, properties) {
	    properties = ['activate', 'volume', 'pitch', 'loop', '3d', 'minDistance', 'maxDistance', 'rollOffFactor', 'distanceModel', 'enabled', 'assets'];

	    _ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);

	    component.paused = !(component.enabled && component.activate);
	  };

	  _proto.onInitialize = function onInitialize(root) {
	    if (root.audiosource && root.enabled && root.audiosource.enabled && root.audiosource.activate) {
	      root.audiosource.play(root.audiosource.currentSource);
	    }

	    var children = root._children;

	    for (var i = 0, len = children.length; i < len; i++) {
	      if (children[i] instanceof Entity) {
	        this.onInitialize(children[i]);
	      }
	    }

	    this.initialized = true;
	  };

	  _proto.onUpdate = function onUpdate(dt) {
	    var components = this.store;

	    for (var id in components) {
	      if (components.hasOwnProperty(id)) {
	        var component = components[id];
	        var entity = component.entity;
	        var componentData = component.data;

	        if (componentData.enabled && entity.enabled && componentData.channel instanceof Channel3d) {
	          var pos = entity.getPosition();
	          componentData.channel.setPosition(pos);
	        }
	      }
	    }
	  };

	  _proto.onRemove = function onRemove(entity, data) {
	    if (data.channel) {
	      data.channel.stop();
	      data.channel = null;
	    }
	  };

	  _proto.setVolume = function setVolume(volume) {
	    this.manager.setVolume(volume);
	  };

	  _proto.destroy = function destroy() {
	    _ComponentSystem.prototype.destroy.call(this);

	    this.app.systems.off('initialize', this.onInitialize, this);
	    this.app.systems.off('update', this.onUpdate, this);
	  };

	  return AudioSourceComponentSystem;
	}(ComponentSystem);

	Component._buildAccessors(AudioSourceComponent.prototype, _schema$i);

	var EntityReference = function (_EventHandler) {
	  _inheritsLoose(EntityReference, _EventHandler);

	  function EntityReference(parentComponent, entityPropertyName, eventConfig) {
	    var _this;

	    _this = _EventHandler.call(this) || this;

	    if (!parentComponent || !(parentComponent instanceof Component)) {
	      throw new Error('The parentComponent argument is required and must be a Component');
	    } else if (!entityPropertyName || typeof entityPropertyName !== 'string') {
	      throw new Error('The propertyName argument is required and must be a string');
	    } else if (eventConfig && typeof eventConfig !== 'object') {
	      throw new Error('If provided, the eventConfig argument must be an object');
	    }

	    _this._parentComponent = parentComponent;
	    _this._entityPropertyName = entityPropertyName;
	    _this._entity = null;
	    _this._app = parentComponent.system.app;

	    _this._configureEventListeners(eventConfig || {}, {
	      'entity#destroy': _this._onEntityDestroy
	    });

	    _this._toggleLifecycleListeners('on');

	    return _this;
	  }

	  var _proto = EntityReference.prototype;

	  _proto._configureEventListeners = function _configureEventListeners(externalEventConfig, internalEventConfig) {
	    var externalEventListenerConfigs = this._parseEventListenerConfig(externalEventConfig, 'external', this._parentComponent);

	    var internalEventListenerConfigs = this._parseEventListenerConfig(internalEventConfig, 'internal', this);

	    this._eventListenerConfigs = externalEventListenerConfigs.concat(internalEventListenerConfigs);
	    this._listenerStatusFlags = {};
	    this._gainListeners = {};
	    this._loseListeners = {};
	  };

	  _proto._parseEventListenerConfig = function _parseEventListenerConfig(eventConfig, prefix, scope) {
	    return Object.keys(eventConfig).map(function (listenerDescription, index) {
	      var listenerDescriptionParts = listenerDescription.split('#');
	      var sourceName = listenerDescriptionParts[0];
	      var eventName = listenerDescriptionParts[1];
	      var callback = eventConfig[listenerDescription];

	      if (listenerDescriptionParts.length !== 2 || typeof sourceName !== 'string' || sourceName.length === 0 || typeof eventName !== 'string' || eventName.length === 0) {
	        throw new Error('Invalid event listener description: `' + listenerDescription + '`');
	      }

	      if (typeof callback !== 'function') {
	        throw new Error('Invalid or missing callback for event listener `' + listenerDescription + '`');
	      }

	      return {
	        id: prefix + '_' + index + '_' + listenerDescription,
	        sourceName: sourceName,
	        eventName: eventName,
	        callback: callback,
	        scope: scope
	      };
	    }, this);
	  };

	  _proto._toggleLifecycleListeners = function _toggleLifecycleListeners(onOrOff) {
	    this._parentComponent[onOrOff]('set_' + this._entityPropertyName, this._onSetEntity, this);

	    this._parentComponent.system[onOrOff]('beforeremove', this._onParentComponentRemove, this);

	    this._app.systems[onOrOff]('postPostInitialize', this._updateEntityReference, this);

	    this._app[onOrOff]('tools:sceneloaded', this._onSceneLoaded, this);

	    var allComponentSystems = [];

	    for (var i = 0; i < this._eventListenerConfigs.length; ++i) {
	      var config = this._eventListenerConfigs[i];
	      var componentSystem = this._app.systems[config.sourceName];

	      if (componentSystem) {
	        if (allComponentSystems.indexOf(componentSystem) === -1) {
	          allComponentSystems.push(componentSystem);
	        }

	        if (componentSystem && config.eventName === 'gain') {
	          this._gainListeners[config.sourceName] = config;
	        }

	        if (componentSystem && config.eventName === 'lose') {
	          this._loseListeners[config.sourceName] = config;
	        }
	      }
	    }

	    for (var _i = 0; _i < allComponentSystems.length; ++_i) {
	      allComponentSystems[_i][onOrOff]('add', this._onComponentAdd, this);

	      allComponentSystems[_i][onOrOff]('beforeremove', this._onComponentRemove, this);
	    }
	  };

	  _proto._onSetEntity = function _onSetEntity(name, oldValue, newValue) {
	    if (newValue instanceof Entity) {
	      this._updateEntityReference();
	    } else {
	      if (newValue !== null && newValue !== undefined && typeof newValue !== 'string') {
	        console.warn("Entity field `" + this._entityPropertyName + "` was set to unexpected type '" + typeof newValue + "'");
	        return;
	      }

	      if (oldValue !== newValue) {
	        this._updateEntityReference();
	      }
	    }
	  };

	  _proto.onParentComponentEnable = function onParentComponentEnable() {
	    if (!this._entity) {
	      this._updateEntityReference();
	    }
	  };

	  _proto._onSceneLoaded = function _onSceneLoaded() {
	    this._updateEntityReference();
	  };

	  _proto._updateEntityReference = function _updateEntityReference() {
	    var nextEntityGuid = this._parentComponent.data[this._entityPropertyName];
	    var nextEntity;

	    if (nextEntityGuid instanceof Entity) {
	      nextEntity = nextEntityGuid;
	      nextEntityGuid = nextEntity.getGuid();
	      this._parentComponent.data[this._entityPropertyName] = nextEntityGuid;
	    } else {
	      var root = this._parentComponent.system.app.root;

	      var isOnSceneGraph = this._parentComponent.entity.isDescendantOf(root);

	      nextEntity = isOnSceneGraph && nextEntityGuid ? root.findByGuid(nextEntityGuid) : null;
	    }

	    var hasChanged = this._entity !== nextEntity;

	    if (hasChanged) {
	      if (this._entity) {
	        this._onBeforeEntityChange();
	      }

	      this._entity = nextEntity;

	      if (this._entity) {
	        this._onAfterEntityChange();
	      }

	      this.fire('set:entity', this._entity);
	    }
	  };

	  _proto._onBeforeEntityChange = function _onBeforeEntityChange() {
	    this._toggleEntityListeners('off');

	    this._callAllGainOrLoseListeners(this._loseListeners);
	  };

	  _proto._onAfterEntityChange = function _onAfterEntityChange() {
	    this._toggleEntityListeners('on');

	    this._callAllGainOrLoseListeners(this._gainListeners);
	  };

	  _proto._onComponentAdd = function _onComponentAdd(entity, component) {
	    var componentName = component.system.id;

	    if (entity === this._entity) {
	      this._callGainOrLoseListener(componentName, this._gainListeners);

	      this._toggleComponentListeners('on', componentName);
	    }
	  };

	  _proto._onComponentRemove = function _onComponentRemove(entity, component) {
	    var componentName = component.system.id;

	    if (entity === this._entity) {
	      this._callGainOrLoseListener(componentName, this._loseListeners);

	      this._toggleComponentListeners('off', componentName, true);
	    }
	  };

	  _proto._callAllGainOrLoseListeners = function _callAllGainOrLoseListeners(listenerMap) {
	    for (var componentName in this._entity.c) {
	      this._callGainOrLoseListener(componentName, listenerMap);
	    }
	  };

	  _proto._callGainOrLoseListener = function _callGainOrLoseListener(componentName, listenerMap) {
	    if (this._entity.c.hasOwnProperty(componentName) && listenerMap[componentName]) {
	      var config = listenerMap[componentName];
	      config.callback.call(config.scope);
	    }
	  };

	  _proto._toggleEntityListeners = function _toggleEntityListeners(onOrOff, isDestroying) {
	    if (this._entity) {
	      for (var i = 0; i < this._eventListenerConfigs.length; ++i) {
	        this._safeToggleListener(onOrOff, this._eventListenerConfigs[i], isDestroying);
	      }
	    }
	  };

	  _proto._toggleComponentListeners = function _toggleComponentListeners(onOrOff, componentName, isDestroying) {
	    for (var i = 0; i < this._eventListenerConfigs.length; ++i) {
	      var config = this._eventListenerConfigs[i];

	      if (config.sourceName === componentName) {
	        this._safeToggleListener(onOrOff, config, isDestroying);
	      }
	    }
	  };

	  _proto._safeToggleListener = function _safeToggleListener(onOrOff, config, isDestroying) {
	    var isAdding = onOrOff === 'on';

	    if (isAdding && this._listenerStatusFlags[config.id]) {
	      return;
	    }

	    var source = this._getEventSource(config.sourceName, isDestroying);

	    if (source) {
	      source[onOrOff](config.eventName, config.callback, config.scope);
	      this._listenerStatusFlags[config.id] = isAdding;
	    }
	  };

	  _proto._getEventSource = function _getEventSource(sourceName, isDestroying) {
	    if (sourceName === 'entity') {
	      return this._entity;
	    }

	    var component = this._entity[sourceName];

	    if (component) {
	      return component;
	    }

	    if (!isDestroying) {
	      console.warn('Entity has no component with name ' + sourceName);
	    }

	    return null;
	  };

	  _proto._onEntityDestroy = function _onEntityDestroy(entity) {
	    if (this._entity === entity) {
	      this._toggleEntityListeners('off', true);

	      this._entity = null;
	    }
	  };

	  _proto._onParentComponentRemove = function _onParentComponentRemove(entity, component) {
	    if (component === this._parentComponent) {
	      this._toggleLifecycleListeners('off');

	      this._toggleEntityListeners('off', true);
	    }
	  };

	  _proto.hasComponent = function hasComponent(componentName) {
	    return this._entity && this._entity.c ? !!this._entity.c[componentName] : false;
	  };

	  _createClass(EntityReference, [{
	    key: "entity",
	    get: function get() {
	      return this._entity;
	    }
	  }]);

	  return EntityReference;
	}(EventHandler);

	var BUTTON_TRANSITION_MODE_TINT = 0;
	var BUTTON_TRANSITION_MODE_SPRITE_CHANGE = 1;

	var ELEMENTTYPE_GROUP = 'group';
	var ELEMENTTYPE_IMAGE = 'image';
	var ELEMENTTYPE_TEXT = 'text';
	var FITMODE_STRETCH = 'stretch';
	var FITMODE_CONTAIN = 'contain';
	var FITMODE_COVER = 'cover';

	var VisualState = {
	  DEFAULT: 'DEFAULT',
	  HOVER: 'HOVER',
	  PRESSED: 'PRESSED',
	  INACTIVE: 'INACTIVE'
	};
	var STATES_TO_TINT_NAMES = {};
	STATES_TO_TINT_NAMES[VisualState.DEFAULT] = '_defaultTint';
	STATES_TO_TINT_NAMES[VisualState.HOVER] = 'hoverTint';
	STATES_TO_TINT_NAMES[VisualState.PRESSED] = 'pressedTint';
	STATES_TO_TINT_NAMES[VisualState.INACTIVE] = 'inactiveTint';
	var STATES_TO_SPRITE_ASSET_NAMES = {};
	STATES_TO_SPRITE_ASSET_NAMES[VisualState.DEFAULT] = '_defaultSpriteAsset';
	STATES_TO_SPRITE_ASSET_NAMES[VisualState.HOVER] = 'hoverSpriteAsset';
	STATES_TO_SPRITE_ASSET_NAMES[VisualState.PRESSED] = 'pressedSpriteAsset';
	STATES_TO_SPRITE_ASSET_NAMES[VisualState.INACTIVE] = 'inactiveSpriteAsset';
	var STATES_TO_SPRITE_FRAME_NAMES = {};
	STATES_TO_SPRITE_FRAME_NAMES[VisualState.DEFAULT] = '_defaultSpriteFrame';
	STATES_TO_SPRITE_FRAME_NAMES[VisualState.HOVER] = 'hoverSpriteFrame';
	STATES_TO_SPRITE_FRAME_NAMES[VisualState.PRESSED] = 'pressedSpriteFrame';
	STATES_TO_SPRITE_FRAME_NAMES[VisualState.INACTIVE] = 'inactiveSpriteFrame';

	var ButtonComponent = function (_Component) {
	  _inheritsLoose(ButtonComponent, _Component);

	  function ButtonComponent(system, entity) {
	    var _this;

	    _this = _Component.call(this, system, entity) || this;
	    _this._visualState = VisualState.DEFAULT;
	    _this._isHovering = false;
	    _this._hoveringCounter = 0;
	    _this._isPressed = false;
	    _this._defaultTint = new Color(1, 1, 1, 1);
	    _this._defaultSpriteAsset = null;
	    _this._defaultSpriteFrame = 0;
	    _this._imageReference = new EntityReference(_assertThisInitialized(_this), 'imageEntity', {
	      'element#gain': _this._onImageElementGain,
	      'element#lose': _this._onImageElementLose,
	      'element#set:color': _this._onSetColor,
	      'element#set:opacity': _this._onSetOpacity,
	      'element#set:spriteAsset': _this._onSetSpriteAsset,
	      'element#set:spriteFrame': _this._onSetSpriteFrame
	    });

	    _this._toggleLifecycleListeners('on', system);

	    return _this;
	  }

	  var _proto = ButtonComponent.prototype;

	  _proto._toggleLifecycleListeners = function _toggleLifecycleListeners(onOrOff, system) {
	    this[onOrOff]('set_active', this._onSetActive, this);
	    this[onOrOff]('set_transitionMode', this._onSetTransitionMode, this);
	    this[onOrOff]('set_hoverTint', this._onSetTransitionValue, this);
	    this[onOrOff]('set_pressedTint', this._onSetTransitionValue, this);
	    this[onOrOff]('set_inactiveTint', this._onSetTransitionValue, this);
	    this[onOrOff]('set_hoverSpriteAsset', this._onSetTransitionValue, this);
	    this[onOrOff]('set_hoverSpriteFrame', this._onSetTransitionValue, this);
	    this[onOrOff]('set_pressedSpriteAsset', this._onSetTransitionValue, this);
	    this[onOrOff]('set_pressedSpriteFrame', this._onSetTransitionValue, this);
	    this[onOrOff]('set_inactiveSpriteAsset', this._onSetTransitionValue, this);
	    this[onOrOff]('set_inactiveSpriteFrame', this._onSetTransitionValue, this);
	    system.app.systems.element[onOrOff]('add', this._onElementComponentAdd, this);
	    system.app.systems.element[onOrOff]('beforeremove', this._onElementComponentRemove, this);
	  };

	  _proto._onSetActive = function _onSetActive(name, oldValue, newValue) {
	    if (oldValue !== newValue) {
	      this._updateVisualState();
	    }
	  };

	  _proto._onSetTransitionMode = function _onSetTransitionMode(name, oldValue, newValue) {
	    if (oldValue !== newValue) {
	      this._cancelTween();

	      this._resetToDefaultVisualState(oldValue);

	      this._forceReapplyVisualState();
	    }
	  };

	  _proto._onSetTransitionValue = function _onSetTransitionValue(name, oldValue, newValue) {
	    if (oldValue !== newValue) {
	      this._forceReapplyVisualState();
	    }
	  };

	  _proto._onElementComponentRemove = function _onElementComponentRemove(entity) {
	    if (this.entity === entity) {
	      this._toggleHitElementListeners('off');
	    }
	  };

	  _proto._onElementComponentAdd = function _onElementComponentAdd(entity) {
	    if (this.entity === entity) {
	      this._toggleHitElementListeners('on');
	    }
	  };

	  _proto._onImageElementLose = function _onImageElementLose() {
	    this._cancelTween();

	    this._resetToDefaultVisualState(this.transitionMode);
	  };

	  _proto._onImageElementGain = function _onImageElementGain() {
	    this._storeDefaultVisualState();

	    this._forceReapplyVisualState();
	  };

	  _proto._toggleHitElementListeners = function _toggleHitElementListeners(onOrOff) {
	    if (this.entity.element) {
	      var isAdding = onOrOff === 'on';

	      if (isAdding && this._hasHitElementListeners) {
	        return;
	      }

	      this.entity.element[onOrOff]('mouseenter', this._onMouseEnter, this);
	      this.entity.element[onOrOff]('mouseleave', this._onMouseLeave, this);
	      this.entity.element[onOrOff]('mousedown', this._onMouseDown, this);
	      this.entity.element[onOrOff]('mouseup', this._onMouseUp, this);
	      this.entity.element[onOrOff]('touchstart', this._onTouchStart, this);
	      this.entity.element[onOrOff]('touchend', this._onTouchEnd, this);
	      this.entity.element[onOrOff]('touchleave', this._onTouchLeave, this);
	      this.entity.element[onOrOff]('touchcancel', this._onTouchCancel, this);
	      this.entity.element[onOrOff]('selectstart', this._onSelectStart, this);
	      this.entity.element[onOrOff]('selectend', this._onSelectEnd, this);
	      this.entity.element[onOrOff]('selectenter', this._onSelectEnter, this);
	      this.entity.element[onOrOff]('selectleave', this._onSelectLeave, this);
	      this.entity.element[onOrOff]('click', this._onClick, this);
	      this._hasHitElementListeners = isAdding;
	    }
	  };

	  _proto._storeDefaultVisualState = function _storeDefaultVisualState() {
	    if (this._imageReference.hasComponent('element')) {
	      var element = this._imageReference.entity.element;

	      if (element.type !== ELEMENTTYPE_GROUP) {
	        this._storeDefaultColor(element.color);

	        this._storeDefaultOpacity(element.opacity);

	        this._storeDefaultSpriteAsset(element.spriteAsset);

	        this._storeDefaultSpriteFrame(element.spriteFrame);
	      }
	    }
	  };

	  _proto._storeDefaultColor = function _storeDefaultColor(color) {
	    this._defaultTint.r = color.r;
	    this._defaultTint.g = color.g;
	    this._defaultTint.b = color.b;
	  };

	  _proto._storeDefaultOpacity = function _storeDefaultOpacity(opacity) {
	    this._defaultTint.a = opacity;
	  };

	  _proto._storeDefaultSpriteAsset = function _storeDefaultSpriteAsset(spriteAsset) {
	    this._defaultSpriteAsset = spriteAsset;
	  };

	  _proto._storeDefaultSpriteFrame = function _storeDefaultSpriteFrame(spriteFrame) {
	    this._defaultSpriteFrame = spriteFrame;
	  };

	  _proto._onSetColor = function _onSetColor(color) {
	    if (!this._isApplyingTint) {
	      this._storeDefaultColor(color);

	      this._forceReapplyVisualState();
	    }
	  };

	  _proto._onSetOpacity = function _onSetOpacity(opacity) {
	    if (!this._isApplyingTint) {
	      this._storeDefaultOpacity(opacity);

	      this._forceReapplyVisualState();
	    }
	  };

	  _proto._onSetSpriteAsset = function _onSetSpriteAsset(spriteAsset) {
	    if (!this._isApplyingSprite) {
	      this._storeDefaultSpriteAsset(spriteAsset);

	      this._forceReapplyVisualState();
	    }
	  };

	  _proto._onSetSpriteFrame = function _onSetSpriteFrame(spriteFrame) {
	    if (!this._isApplyingSprite) {
	      this._storeDefaultSpriteFrame(spriteFrame);

	      this._forceReapplyVisualState();
	    }
	  };

	  _proto._onMouseEnter = function _onMouseEnter(event) {
	    this._isHovering = true;

	    this._updateVisualState();

	    this._fireIfActive('mouseenter', event);
	  };

	  _proto._onMouseLeave = function _onMouseLeave(event) {
	    this._isHovering = false;
	    this._isPressed = false;

	    this._updateVisualState();

	    this._fireIfActive('mouseleave', event);
	  };

	  _proto._onMouseDown = function _onMouseDown(event) {
	    this._isPressed = true;

	    this._updateVisualState();

	    this._fireIfActive('mousedown', event);
	  };

	  _proto._onMouseUp = function _onMouseUp(event) {
	    this._isPressed = false;

	    this._updateVisualState();

	    this._fireIfActive('mouseup', event);
	  };

	  _proto._onTouchStart = function _onTouchStart(event) {
	    this._isPressed = true;

	    this._updateVisualState();

	    this._fireIfActive('touchstart', event);
	  };

	  _proto._onTouchEnd = function _onTouchEnd(event) {
	    event.event.preventDefault();
	    this._isPressed = false;

	    this._updateVisualState();

	    this._fireIfActive('touchend', event);
	  };

	  _proto._onTouchLeave = function _onTouchLeave(event) {
	    this._isPressed = false;

	    this._updateVisualState();

	    this._fireIfActive('touchleave', event);
	  };

	  _proto._onTouchCancel = function _onTouchCancel(event) {
	    this._isPressed = false;

	    this._updateVisualState();

	    this._fireIfActive('touchcancel', event);
	  };

	  _proto._onSelectStart = function _onSelectStart(event) {
	    this._isPressed = true;

	    this._updateVisualState();

	    this._fireIfActive('selectstart', event);
	  };

	  _proto._onSelectEnd = function _onSelectEnd(event) {
	    this._isPressed = false;

	    this._updateVisualState();

	    this._fireIfActive('selectend', event);
	  };

	  _proto._onSelectEnter = function _onSelectEnter(event) {
	    this._hoveringCounter++;

	    if (this._hoveringCounter === 1) {
	      this._isHovering = true;

	      this._updateVisualState();
	    }

	    this._fireIfActive('selectenter', event);
	  };

	  _proto._onSelectLeave = function _onSelectLeave(event) {
	    this._hoveringCounter--;

	    if (this._hoveringCounter === 0) {
	      this._isHovering = false;
	      this._isPressed = false;

	      this._updateVisualState();
	    }

	    this._fireIfActive('selectleave', event);
	  };

	  _proto._onClick = function _onClick(event) {
	    this._fireIfActive('click', event);
	  };

	  _proto._fireIfActive = function _fireIfActive(name, event) {
	    if (this.data.active) {
	      this.fire(name, event);
	    }
	  };

	  _proto._updateVisualState = function _updateVisualState(force) {
	    var oldVisualState = this._visualState;

	    var newVisualState = this._determineVisualState();

	    if ((oldVisualState !== newVisualState || force) && this.enabled) {
	      this._visualState = newVisualState;

	      if (oldVisualState === VisualState.HOVER) {
	        this._fireIfActive('hoverend');
	      }

	      if (oldVisualState === VisualState.PRESSED) {
	        this._fireIfActive('pressedend');
	      }

	      if (newVisualState === VisualState.HOVER) {
	        this._fireIfActive('hoverstart');
	      }

	      if (newVisualState === VisualState.PRESSED) {
	        this._fireIfActive('pressedstart');
	      }

	      switch (this.transitionMode) {
	        case BUTTON_TRANSITION_MODE_TINT:
	          {
	            var tintName = STATES_TO_TINT_NAMES[this._visualState];
	            var tintColor = this[tintName];

	            this._applyTint(tintColor);

	            break;
	          }

	        case BUTTON_TRANSITION_MODE_SPRITE_CHANGE:
	          {
	            var spriteAssetName = STATES_TO_SPRITE_ASSET_NAMES[this._visualState];
	            var spriteFrameName = STATES_TO_SPRITE_FRAME_NAMES[this._visualState];
	            var spriteAsset = this[spriteAssetName];
	            var spriteFrame = this[spriteFrameName];

	            this._applySprite(spriteAsset, spriteFrame);

	            break;
	          }
	      }
	    }
	  };

	  _proto._forceReapplyVisualState = function _forceReapplyVisualState() {
	    this._updateVisualState(true);
	  };

	  _proto._resetToDefaultVisualState = function _resetToDefaultVisualState(transitionMode) {
	    if (this._imageReference.hasComponent('element')) {
	      switch (transitionMode) {
	        case BUTTON_TRANSITION_MODE_TINT:
	          this._cancelTween();

	          this._applyTintImmediately(this._defaultTint);

	          break;

	        case BUTTON_TRANSITION_MODE_SPRITE_CHANGE:
	          this._applySprite(this._defaultSpriteAsset, this._defaultSpriteFrame);

	          break;
	      }
	    }
	  };

	  _proto._determineVisualState = function _determineVisualState() {
	    if (!this.active) {
	      return VisualState.INACTIVE;
	    } else if (this._isPressed) {
	      return VisualState.PRESSED;
	    } else if (this._isHovering) {
	      return VisualState.HOVER;
	    }

	    return VisualState.DEFAULT;
	  };

	  _proto._applySprite = function _applySprite(spriteAsset, spriteFrame) {
	    spriteFrame = spriteFrame || 0;

	    if (this._imageReference.hasComponent('element')) {
	      this._isApplyingSprite = true;

	      if (this._imageReference.entity.element.spriteAsset !== spriteAsset) {
	        this._imageReference.entity.element.spriteAsset = spriteAsset;
	      }

	      if (this._imageReference.entity.element.spriteFrame !== spriteFrame) {
	        this._imageReference.entity.element.spriteFrame = spriteFrame;
	      }

	      this._isApplyingSprite = false;
	    }
	  };

	  _proto._applyTint = function _applyTint(tintColor) {
	    this._cancelTween();

	    if (this.fadeDuration === 0) {
	      this._applyTintImmediately(tintColor);
	    } else {
	      this._applyTintWithTween(tintColor);
	    }
	  };

	  _proto._applyTintImmediately = function _applyTintImmediately(tintColor) {
	    if (!tintColor || !this._imageReference.hasComponent('element') || this._imageReference.entity.element.type === ELEMENTTYPE_GROUP) return;
	    var color3 = toColor3(tintColor);
	    this._isApplyingTint = true;
	    if (!color3.equals(this._imageReference.entity.element.color)) this._imageReference.entity.element.color = color3;
	    if (this._imageReference.entity.element.opacity !== tintColor.a) this._imageReference.entity.element.opacity = tintColor.a;
	    this._isApplyingTint = false;
	  };

	  _proto._applyTintWithTween = function _applyTintWithTween(tintColor) {
	    if (!tintColor || !this._imageReference.hasComponent('element') || this._imageReference.entity.element.type === ELEMENTTYPE_GROUP) return;
	    var color3 = toColor3(tintColor);
	    var color = this._imageReference.entity.element.color;
	    var opacity = this._imageReference.entity.element.opacity;
	    if (color3.equals(color) && tintColor.a === opacity) return;
	    this._tweenInfo = {
	      startTime: now(),
	      from: new Color(color.r, color.g, color.b, opacity),
	      to: tintColor.clone(),
	      lerpColor: new Color()
	    };
	  };

	  _proto._updateTintTween = function _updateTintTween() {
	    var elapsedTime = now() - this._tweenInfo.startTime;

	    var elapsedProportion = this.fadeDuration === 0 ? 1 : elapsedTime / this.fadeDuration;
	    elapsedProportion = math.clamp(elapsedProportion, 0, 1);

	    if (Math.abs(elapsedProportion - 1) > 1e-5) {
	      var lerpColor = this._tweenInfo.lerpColor;
	      lerpColor.lerp(this._tweenInfo.from, this._tweenInfo.to, elapsedProportion);

	      this._applyTintImmediately(new Color(lerpColor.r, lerpColor.g, lerpColor.b, lerpColor.a));
	    } else {
	      this._applyTintImmediately(this._tweenInfo.to);

	      this._cancelTween();
	    }
	  };

	  _proto._cancelTween = function _cancelTween() {
	    delete this._tweenInfo;
	  };

	  _proto.onUpdate = function onUpdate() {
	    if (this._tweenInfo) {
	      this._updateTintTween();
	    }
	  };

	  _proto.onEnable = function onEnable() {
	    this._isHovering = false;
	    this._hoveringCounter = 0;
	    this._isPressed = false;

	    this._imageReference.onParentComponentEnable();

	    this._toggleHitElementListeners('on');

	    this._forceReapplyVisualState();
	  };

	  _proto.onDisable = function onDisable() {
	    this._toggleHitElementListeners('off');

	    this._resetToDefaultVisualState(this.transitionMode);
	  };

	  _proto.onRemove = function onRemove() {
	    this._toggleLifecycleListeners('off', this.system);

	    this.onDisable();
	  };

	  return ButtonComponent;
	}(Component);

	function toColor3(color4) {
	  return new Color(color4.r, color4.g, color4.b);
	}

	var ButtonComponentData = function ButtonComponentData() {
	  this.enabled = true;
	  this.active = true;
	  this.imageEntity = null;
	  this.hitPadding = new Vec4();
	  this.transitionMode = BUTTON_TRANSITION_MODE_TINT;
	  this.hoverTint = new Color(0.75, 0.75, 0.75);
	  this.pressedTint = new Color(0.5, 0.5, 0.5);
	  this.inactiveTint = new Color(0.25, 0.25, 0.25);
	  this.fadeDuration = 0;
	  this.hoverSpriteAsset = null;
	  this.hoverSpriteFrame = 0;
	  this.pressedSpriteAsset = null;
	  this.pressedSpriteFrame = 0;
	  this.inactiveSpriteAsset = null;
	  this.inactiveSpriteFrame = 0;
	};

	var _schema$h = ['enabled', 'active', {
	  name: 'imageEntity',
	  type: 'entity'
	}, {
	  name: 'hitPadding',
	  type: 'vec4'
	}, 'transitionMode', {
	  name: 'hoverTint',
	  type: 'rgba'
	}, {
	  name: 'pressedTint',
	  type: 'rgba'
	}, {
	  name: 'inactiveTint',
	  type: 'rgba'
	}, 'fadeDuration', 'hoverSpriteAsset', 'hoverSpriteFrame', 'pressedSpriteAsset', 'pressedSpriteFrame', 'inactiveSpriteAsset', 'inactiveSpriteFrame'];

	var ButtonComponentSystem = function (_ComponentSystem) {
	  _inheritsLoose(ButtonComponentSystem, _ComponentSystem);

	  function ButtonComponentSystem(app) {
	    var _this;

	    _this = _ComponentSystem.call(this, app) || this;
	    _this.id = 'button';
	    _this.ComponentType = ButtonComponent;
	    _this.DataType = ButtonComponentData;
	    _this.schema = _schema$h;

	    _this.on('beforeremove', _this._onRemoveComponent, _assertThisInitialized(_this));

	    _this.app.systems.on('update', _this.onUpdate, _assertThisInitialized(_this));

	    return _this;
	  }

	  var _proto = ButtonComponentSystem.prototype;

	  _proto.initializeComponentData = function initializeComponentData(component, data, properties) {
	    _ComponentSystem.prototype.initializeComponentData.call(this, component, data, _schema$h);
	  };

	  _proto.onUpdate = function onUpdate(dt) {
	    var components = this.store;

	    for (var id in components) {
	      var entity = components[id].entity;
	      var component = entity.button;

	      if (component.enabled && entity.enabled) {
	        component.onUpdate();
	      }
	    }
	  };

	  _proto._onRemoveComponent = function _onRemoveComponent(entity, component) {
	    component.onRemove();
	  };

	  _proto.destroy = function destroy() {
	    _ComponentSystem.prototype.destroy.call(this);

	    this.app.systems.off('update', this.onUpdate, this);
	  };

	  return ButtonComponentSystem;
	}(ComponentSystem);

	Component._buildAccessors(ButtonComponent.prototype, _schema$h);

	var CollisionComponent = function (_Component) {
	  _inheritsLoose(CollisionComponent, _Component);

	  function CollisionComponent(system, entity) {
	    var _this;

	    _this = _Component.call(this, system, entity) || this;
	    _this._compoundParent = null;

	    _this.entity.on('insert', _this._onInsert, _assertThisInitialized(_this));

	    _this.on('set_type', _this.onSetType, _assertThisInitialized(_this));

	    _this.on('set_halfExtents', _this.onSetHalfExtents, _assertThisInitialized(_this));

	    _this.on('set_radius', _this.onSetRadius, _assertThisInitialized(_this));

	    _this.on('set_height', _this.onSetHeight, _assertThisInitialized(_this));

	    _this.on('set_axis', _this.onSetAxis, _assertThisInitialized(_this));

	    _this.on('set_asset', _this.onSetAsset, _assertThisInitialized(_this));

	    _this.on('set_renderAsset', _this.onSetRenderAsset, _assertThisInitialized(_this));

	    _this.on('set_model', _this.onSetModel, _assertThisInitialized(_this));

	    _this.on('set_render', _this.onSetRender, _assertThisInitialized(_this));

	    return _this;
	  }

	  var _proto = CollisionComponent.prototype;

	  _proto.onSetType = function onSetType(name, oldValue, newValue) {
	    if (oldValue !== newValue) {
	      this.system.changeType(this, oldValue, newValue);
	    }
	  };

	  _proto.onSetHalfExtents = function onSetHalfExtents(name, oldValue, newValue) {
	    var t = this.data.type;

	    if (this.data.initialized && t === 'box') {
	      this.system.recreatePhysicalShapes(this);
	    }
	  };

	  _proto.onSetRadius = function onSetRadius(name, oldValue, newValue) {
	    var t = this.data.type;

	    if (this.data.initialized && (t === 'sphere' || t === 'capsule' || t === 'cylinder' || t === 'cone')) {
	      this.system.recreatePhysicalShapes(this);
	    }
	  };

	  _proto.onSetHeight = function onSetHeight(name, oldValue, newValue) {
	    var t = this.data.type;

	    if (this.data.initialized && (t === 'capsule' || t === 'cylinder' || t === 'cone')) {
	      this.system.recreatePhysicalShapes(this);
	    }
	  };

	  _proto.onSetAxis = function onSetAxis(name, oldValue, newValue) {
	    var t = this.data.type;

	    if (this.data.initialized && (t === 'capsule' || t === 'cylinder' || t === 'cone')) {
	      this.system.recreatePhysicalShapes(this);
	    }
	  };

	  _proto.onSetAsset = function onSetAsset(name, oldValue, newValue) {
	    var assets = this.system.app.assets;

	    if (oldValue) {
	      var asset = assets.get(oldValue);

	      if (asset) {
	        asset.off('remove', this.onAssetRemoved, this);
	      }
	    }

	    if (newValue) {
	      if (newValue instanceof Asset) {
	        this.data.asset = newValue.id;
	      }

	      var _asset = assets.get(this.data.asset);

	      if (_asset) {
	        _asset.off('remove', this.onAssetRemoved, this);

	        _asset.on('remove', this.onAssetRemoved, this);
	      }
	    }

	    if (this.data.initialized && this.data.type === 'mesh') {
	      if (!newValue) {
	        this.data.model = null;
	      }

	      this.system.recreatePhysicalShapes(this);
	    }
	  };

	  _proto.onSetRenderAsset = function onSetRenderAsset(name, oldValue, newValue) {
	    var assets = this.system.app.assets;

	    if (oldValue) {
	      var asset = assets.get(oldValue);

	      if (asset) {
	        asset.off('remove', this.onRenderAssetRemoved, this);
	      }
	    }

	    if (newValue) {
	      if (newValue instanceof Asset) {
	        this.data.renderAsset = newValue.id;
	      }

	      var _asset2 = assets.get(this.data.renderAsset);

	      if (_asset2) {
	        _asset2.off('remove', this.onRenderAssetRemoved, this);

	        _asset2.on('remove', this.onRenderAssetRemoved, this);
	      }
	    }

	    if (this.data.initialized && this.data.type === 'mesh') {
	      if (!newValue) {
	        this.data.render = null;
	      }

	      this.system.recreatePhysicalShapes(this);
	    }
	  };

	  _proto.onSetModel = function onSetModel(name, oldValue, newValue) {
	    if (this.data.initialized && this.data.type === 'mesh') {
	      this.system.implementations.mesh.doRecreatePhysicalShape(this);
	    }
	  };

	  _proto.onSetRender = function onSetRender(name, oldValue, newValue) {
	    this.onSetModel(name, oldValue, newValue);
	  };

	  _proto.onAssetRemoved = function onAssetRemoved(asset) {
	    asset.off('remove', this.onAssetRemoved, this);

	    if (this.data.asset === asset.id) {
	      this.asset = null;
	    }
	  };

	  _proto.onRenderAssetRemoved = function onRenderAssetRemoved(asset) {
	    asset.off('remove', this.onRenderAssetRemoved, this);

	    if (this.data.renderAsset === asset.id) {
	      this.renderAsset = null;
	    }
	  };

	  _proto._getCompoundChildShapeIndex = function _getCompoundChildShapeIndex(shape) {
	    var compound = this.data.shape;
	    var shapes = compound.getNumChildShapes();

	    for (var i = 0; i < shapes; i++) {
	      var childShape = compound.getChildShape(i);

	      if (childShape.ptr === shape.ptr) {
	        return i;
	      }
	    }

	    return null;
	  };

	  _proto._onInsert = function _onInsert(parent) {
	    if (typeof Ammo === 'undefined') return;

	    if (this._compoundParent) {
	      this.system.recreatePhysicalShapes(this);
	    } else if (!this.entity.rigidbody) {
	      var ancestor = this.entity.parent;

	      while (ancestor) {
	        if (ancestor.collision && ancestor.collision.type === 'compound') {
	          if (ancestor.collision.shape.getNumChildShapes() === 0) {
	            this.system.recreatePhysicalShapes(ancestor.collision);
	          } else {
	            this.system.recreatePhysicalShapes(this);
	          }

	          break;
	        }

	        ancestor = ancestor.parent;
	      }
	    }
	  };

	  _proto._updateCompound = function _updateCompound() {
	    var entity = this.entity;

	    if (entity._dirtyWorld) {
	      var dirty = entity._dirtyLocal;
	      var parent = entity;

	      while (parent && !dirty) {
	        if (parent.collision && parent.collision === this._compoundParent) break;
	        if (parent._dirtyLocal) dirty = true;
	        parent = parent.parent;
	      }

	      if (dirty) {
	        entity.forEach(this.system.implementations.compound._updateEachDescendantTransform, entity);
	        var bodyComponent = this._compoundParent.entity.rigidbody;
	        if (bodyComponent) bodyComponent.activate();
	      }
	    }
	  };

	  _proto.onEnable = function onEnable() {
	    if (this.data.type === 'mesh' && (this.data.asset || this.data.renderAsset) && this.data.initialized) {
	      var asset = this.system.app.assets.get(this.data.asset || this.data.renderAsset);

	      if (asset && (!asset.resource || !this.data.shape)) {
	        this.system.recreatePhysicalShapes(this);
	        return;
	      }
	    }

	    if (this.entity.rigidbody) {
	      if (this.entity.rigidbody.enabled) {
	        this.entity.rigidbody.enableSimulation();
	      }
	    } else if (this._compoundParent && this !== this._compoundParent) {
	      if (this._compoundParent.shape.getNumChildShapes() === 0) {
	        this.system.recreatePhysicalShapes(this._compoundParent);
	      } else {
	        var transform = this.system._getNodeTransform(this.entity, this._compoundParent.entity);

	        this._compoundParent.shape.addChildShape(transform, this.data.shape);

	        Ammo.destroy(transform);
	        if (this._compoundParent.entity.rigidbody) this._compoundParent.entity.rigidbody.activate();
	      }
	    } else if (this.entity.trigger) {
	      this.entity.trigger.enable();
	    }
	  };

	  _proto.onDisable = function onDisable() {
	    if (this.entity.rigidbody) {
	      this.entity.rigidbody.disableSimulation();
	    } else if (this._compoundParent && this !== this._compoundParent) {
	      if (!this._compoundParent.entity._destroying) {
	        this.system._removeCompoundChild(this._compoundParent, this.data.shape);

	        if (this._compoundParent.entity.rigidbody) this._compoundParent.entity.rigidbody.activate();
	      }
	    } else if (this.entity.trigger) {
	      this.entity.trigger.disable();
	    }
	  };

	  _proto.onBeforeRemove = function onBeforeRemove() {
	    if (this.asset) {
	      this.asset = null;
	    }

	    if (this.renderAsset) {
	      this.renderAsset = null;
	    }

	    this.entity.off('insert', this._onInsert, this);
	    this.off();
	  };

	  return CollisionComponent;
	}(Component);

	var CollisionComponentData = function CollisionComponentData() {
	  this.enabled = true;
	  this.type = 'box';
	  this.halfExtents = new Vec3(0.5, 0.5, 0.5);
	  this.radius = 0.5;
	  this.axis = 1;
	  this.height = 2;
	  this.asset = null;
	  this.renderAsset = null;
	  this.shape = null;
	  this.model = null;
	  this.render = null;
	  this.initialized = false;
	};

	var BODYTYPE_STATIC = 'static';
	var BODYTYPE_DYNAMIC = 'dynamic';
	var BODYTYPE_KINEMATIC = 'kinematic';
	var BODYFLAG_STATIC_OBJECT = 1;
	var BODYFLAG_KINEMATIC_OBJECT = 2;
	var BODYFLAG_NORESPONSE_OBJECT = 4;
	var BODYSTATE_ACTIVE_TAG = 1;
	var BODYSTATE_ISLAND_SLEEPING = 2;
	var BODYSTATE_WANTS_DEACTIVATION = 3;
	var BODYSTATE_DISABLE_DEACTIVATION = 4;
	var BODYSTATE_DISABLE_SIMULATION = 5;
	var BODYGROUP_NONE = 0;
	var BODYGROUP_DEFAULT = 1;
	var BODYGROUP_DYNAMIC = 1;
	var BODYGROUP_STATIC = 2;
	var BODYGROUP_KINEMATIC = 4;
	var BODYGROUP_ENGINE_1 = 8;
	var BODYGROUP_TRIGGER = 16;
	var BODYGROUP_ENGINE_2 = 32;
	var BODYGROUP_ENGINE_3 = 64;
	var BODYGROUP_USER_1 = 128;
	var BODYGROUP_USER_2 = 256;
	var BODYGROUP_USER_3 = 512;
	var BODYGROUP_USER_4 = 1024;
	var BODYGROUP_USER_5 = 2048;
	var BODYGROUP_USER_6 = 4096;
	var BODYGROUP_USER_7 = 8192;
	var BODYGROUP_USER_8 = 16384;
	var BODYMASK_NONE = 0;
	var BODYMASK_ALL = 65535;
	var BODYMASK_STATIC = 2;
	var BODYMASK_NOT_STATIC = 65535 ^ 2;
	var BODYMASK_NOT_STATIC_KINEMATIC = 65535 ^ (2 | 4);

	var ammoVec1$1, ammoQuat$1, ammoTransform$1;

	var Trigger = function () {
	  function Trigger(app, component, data) {
	    this.entity = component.entity;
	    this.component = component;
	    this.app = app;

	    if (typeof Ammo !== 'undefined' && !ammoVec1$1) {
	      ammoVec1$1 = new Ammo.btVector3();
	      ammoQuat$1 = new Ammo.btQuaternion();
	      ammoTransform$1 = new Ammo.btTransform();
	    }

	    this.initialize(data);
	  }

	  var _proto = Trigger.prototype;

	  _proto.initialize = function initialize(data) {
	    var entity = this.entity;
	    var shape = data.shape;

	    if (shape && typeof Ammo !== 'undefined') {
	      if (entity.trigger) {
	        entity.trigger.destroy();
	      }

	      var mass = 1;
	      var pos = entity.getPosition();
	      var rot = entity.getRotation();
	      ammoVec1$1.setValue(pos.x, pos.y, pos.z);
	      ammoQuat$1.setValue(rot.x, rot.y, rot.z, rot.w);
	      ammoTransform$1.setOrigin(ammoVec1$1);
	      ammoTransform$1.setRotation(ammoQuat$1);
	      var body = this.app.systems.rigidbody.createBody(mass, shape, ammoTransform$1);
	      body.setRestitution(0);
	      body.setFriction(0);
	      body.setDamping(0, 0);
	      ammoVec1$1.setValue(0, 0, 0);
	      body.setLinearFactor(ammoVec1$1);
	      body.setAngularFactor(ammoVec1$1);
	      body.setCollisionFlags(body.getCollisionFlags() | BODYFLAG_NORESPONSE_OBJECT);
	      body.entity = entity;
	      this.body = body;

	      if (this.component.enabled && entity.enabled) {
	        this.enable();
	      }
	    }
	  };

	  _proto.destroy = function destroy() {
	    var body = this.body;
	    if (!body) return;
	    this.disable();
	    this.app.systems.rigidbody.destroyBody(body);
	  };

	  _proto._getEntityTransform = function _getEntityTransform(transform) {
	    var pos = this.entity.getPosition();
	    var rot = this.entity.getRotation();
	    ammoVec1$1.setValue(pos.x, pos.y, pos.z);
	    ammoQuat$1.setValue(rot.x, rot.y, rot.z, rot.w);
	    transform.setOrigin(ammoVec1$1);
	    transform.setRotation(ammoQuat$1);
	  };

	  _proto.updateTransform = function updateTransform() {
	    this._getEntityTransform(ammoTransform$1);

	    var body = this.body;
	    body.setWorldTransform(ammoTransform$1);
	    body.activate();
	  };

	  _proto.enable = function enable() {
	    var body = this.body;
	    if (!body) return;
	    var systems = this.app.systems;
	    systems.rigidbody.addBody(body, BODYGROUP_TRIGGER, BODYMASK_NOT_STATIC ^ BODYGROUP_TRIGGER);

	    systems.rigidbody._triggers.push(this);

	    body.forceActivationState(BODYSTATE_ACTIVE_TAG);
	    this.updateTransform();
	  };

	  _proto.disable = function disable() {
	    var body = this.body;
	    if (!body) return;
	    var systems = this.app.systems;

	    var idx = systems.rigidbody._triggers.indexOf(this);

	    if (idx > -1) {
	      systems.rigidbody._triggers.splice(idx, 1);
	    }

	    systems.rigidbody.removeBody(body);
	    body.forceActivationState(BODYSTATE_DISABLE_SIMULATION);
	  };

	  return Trigger;
	}();

	var mat4 = new Mat4();
	var vec3 = new Vec3();
	var quat$1 = new Quat();
	var tempGraphNode = new GraphNode();
	var _schema$g = ['enabled', 'type', 'halfExtents', 'radius', 'axis', 'height', 'asset', 'renderAsset', 'shape', 'model', 'render'];

	var CollisionSystemImpl = function () {
	  function CollisionSystemImpl(system) {
	    this.system = system;
	  }

	  var _proto = CollisionSystemImpl.prototype;

	  _proto.beforeInitialize = function beforeInitialize(component, data) {
	    data.shape = null;
	    data.model = new Model();
	    data.model.graph = new GraphNode();
	  };

	  _proto.afterInitialize = function afterInitialize(component, data) {
	    this.recreatePhysicalShapes(component);
	    component.data.initialized = true;
	  };

	  _proto.reset = function reset(component, data) {
	    this.beforeInitialize(component, data);
	    this.afterInitialize(component, data);
	  };

	  _proto.recreatePhysicalShapes = function recreatePhysicalShapes(component) {
	    var entity = component.entity;
	    var data = component.data;

	    if (typeof Ammo !== 'undefined') {
	      if (entity.trigger) {
	        entity.trigger.destroy();
	        delete entity.trigger;
	      }

	      if (data.shape) {
	        if (component._compoundParent) {
	          this.system._removeCompoundChild(component._compoundParent, data.shape);

	          if (component._compoundParent.entity.rigidbody) component._compoundParent.entity.rigidbody.activate();
	        }

	        Ammo.destroy(data.shape);
	        data.shape = null;
	      }

	      data.shape = this.createPhysicalShape(component.entity, data);
	      var firstCompoundChild = !component._compoundParent;

	      if (data.type === 'compound' && (!component._compoundParent || component === component._compoundParent)) {
	        component._compoundParent = component;
	        entity.forEach(this._addEachDescendant, component);
	      } else if (data.type !== 'compound') {
	        if (component._compoundParent && component === component._compoundParent) {
	          entity.forEach(this.system.implementations.compound._updateEachDescendant, component);
	        }

	        if (!component.rigidbody) {
	          component._compoundParent = null;
	          var parent = entity.parent;

	          while (parent) {
	            if (parent.collision && parent.collision.type === 'compound') {
	              component._compoundParent = parent.collision;
	              break;
	            }

	            parent = parent.parent;
	          }
	        }
	      }

	      if (component._compoundParent) {
	        if (component !== component._compoundParent) {
	          if (firstCompoundChild && component._compoundParent.shape.getNumChildShapes() === 0) {
	            this.system.recreatePhysicalShapes(component._compoundParent);
	          } else {
	            this.system.updateCompoundChildTransform(entity);
	            if (component._compoundParent.entity.rigidbody) component._compoundParent.entity.rigidbody.activate();
	          }
	        }
	      }

	      if (entity.rigidbody) {
	        entity.rigidbody.disableSimulation();
	        entity.rigidbody.createBody();

	        if (entity.enabled && entity.rigidbody.enabled) {
	          entity.rigidbody.enableSimulation();
	        }
	      } else if (!component._compoundParent) {
	        if (!entity.trigger) {
	          entity.trigger = new Trigger(this.system.app, component, data);
	        } else {
	          entity.trigger.initialize(data);
	        }
	      }
	    }
	  };

	  _proto.createPhysicalShape = function createPhysicalShape(entity, data) {
	    return undefined;
	  };

	  _proto.updateTransform = function updateTransform(component, position, rotation, scale) {
	    if (component.entity.trigger) {
	      component.entity.trigger.updateTransform();
	    }
	  };

	  _proto.beforeRemove = function beforeRemove(entity, component) {
	    if (component.data.shape) {
	      if (component._compoundParent && !component._compoundParent.entity._destroying) {
	        this.system._removeCompoundChild(component._compoundParent, component.data.shape);

	        if (component._compoundParent.entity.rigidbody) component._compoundParent.entity.rigidbody.activate();
	      }

	      component._compoundParent = null;
	      Ammo.destroy(component.data.shape);
	      component.data.shape = null;
	    }
	  };

	  _proto.remove = function remove(entity, data) {
	    if (entity.rigidbody && entity.rigidbody.body) {
	      entity.rigidbody.disableSimulation();
	    }

	    if (entity.trigger) {
	      entity.trigger.destroy();
	      delete entity.trigger;
	    }
	  };

	  _proto.clone = function clone(entity, _clone) {
	    var src = this.system.store[entity.getGuid()];
	    var data = {
	      enabled: src.data.enabled,
	      type: src.data.type,
	      halfExtents: [src.data.halfExtents.x, src.data.halfExtents.y, src.data.halfExtents.z],
	      radius: src.data.radius,
	      axis: src.data.axis,
	      height: src.data.height,
	      asset: src.data.asset,
	      renderAsset: src.data.renderAsset,
	      model: src.data.model,
	      render: src.data.render
	    };
	    return this.system.addComponent(_clone, data);
	  };

	  return CollisionSystemImpl;
	}();

	var CollisionBoxSystemImpl = function (_CollisionSystemImpl) {
	  _inheritsLoose(CollisionBoxSystemImpl, _CollisionSystemImpl);

	  function CollisionBoxSystemImpl() {
	    return _CollisionSystemImpl.apply(this, arguments) || this;
	  }

	  var _proto2 = CollisionBoxSystemImpl.prototype;

	  _proto2.createPhysicalShape = function createPhysicalShape(entity, data) {
	    if (typeof Ammo !== 'undefined') {
	      var he = data.halfExtents;
	      var ammoHe = new Ammo.btVector3(he ? he.x : 0.5, he ? he.y : 0.5, he ? he.z : 0.5);
	      var shape = new Ammo.btBoxShape(ammoHe);
	      Ammo.destroy(ammoHe);
	      return shape;
	    }

	    return undefined;
	  };

	  return CollisionBoxSystemImpl;
	}(CollisionSystemImpl);

	var CollisionSphereSystemImpl = function (_CollisionSystemImpl2) {
	  _inheritsLoose(CollisionSphereSystemImpl, _CollisionSystemImpl2);

	  function CollisionSphereSystemImpl() {
	    return _CollisionSystemImpl2.apply(this, arguments) || this;
	  }

	  var _proto3 = CollisionSphereSystemImpl.prototype;

	  _proto3.createPhysicalShape = function createPhysicalShape(entity, data) {
	    if (typeof Ammo !== 'undefined') {
	      return new Ammo.btSphereShape(data.radius);
	    }

	    return undefined;
	  };

	  return CollisionSphereSystemImpl;
	}(CollisionSystemImpl);

	var CollisionCapsuleSystemImpl = function (_CollisionSystemImpl3) {
	  _inheritsLoose(CollisionCapsuleSystemImpl, _CollisionSystemImpl3);

	  function CollisionCapsuleSystemImpl() {
	    return _CollisionSystemImpl3.apply(this, arguments) || this;
	  }

	  var _proto4 = CollisionCapsuleSystemImpl.prototype;

	  _proto4.createPhysicalShape = function createPhysicalShape(entity, data) {
	    var axis = data.axis !== undefined ? data.axis : 1;
	    var radius = data.radius || 0.5;
	    var height = Math.max((data.height || 2) - 2 * radius, 0);
	    var shape = null;

	    if (typeof Ammo !== 'undefined') {
	      switch (axis) {
	        case 0:
	          shape = new Ammo.btCapsuleShapeX(radius, height);
	          break;

	        case 1:
	          shape = new Ammo.btCapsuleShape(radius, height);
	          break;

	        case 2:
	          shape = new Ammo.btCapsuleShapeZ(radius, height);
	          break;
	      }
	    }

	    return shape;
	  };

	  return CollisionCapsuleSystemImpl;
	}(CollisionSystemImpl);

	var CollisionCylinderSystemImpl = function (_CollisionSystemImpl4) {
	  _inheritsLoose(CollisionCylinderSystemImpl, _CollisionSystemImpl4);

	  function CollisionCylinderSystemImpl() {
	    return _CollisionSystemImpl4.apply(this, arguments) || this;
	  }

	  var _proto5 = CollisionCylinderSystemImpl.prototype;

	  _proto5.createPhysicalShape = function createPhysicalShape(entity, data) {
	    var axis = data.axis !== undefined ? data.axis : 1;
	    var radius = data.radius !== undefined ? data.radius : 0.5;
	    var height = data.height !== undefined ? data.height : 1;
	    var halfExtents = null;
	    var shape = null;

	    if (typeof Ammo !== 'undefined') {
	      switch (axis) {
	        case 0:
	          halfExtents = new Ammo.btVector3(height * 0.5, radius, radius);
	          shape = new Ammo.btCylinderShapeX(halfExtents);
	          break;

	        case 1:
	          halfExtents = new Ammo.btVector3(radius, height * 0.5, radius);
	          shape = new Ammo.btCylinderShape(halfExtents);
	          break;

	        case 2:
	          halfExtents = new Ammo.btVector3(radius, radius, height * 0.5);
	          shape = new Ammo.btCylinderShapeZ(halfExtents);
	          break;
	      }
	    }

	    if (halfExtents) Ammo.destroy(halfExtents);
	    return shape;
	  };

	  return CollisionCylinderSystemImpl;
	}(CollisionSystemImpl);

	var CollisionConeSystemImpl = function (_CollisionSystemImpl5) {
	  _inheritsLoose(CollisionConeSystemImpl, _CollisionSystemImpl5);

	  function CollisionConeSystemImpl() {
	    return _CollisionSystemImpl5.apply(this, arguments) || this;
	  }

	  var _proto6 = CollisionConeSystemImpl.prototype;

	  _proto6.createPhysicalShape = function createPhysicalShape(entity, data) {
	    var axis = data.axis !== undefined ? data.axis : 1;
	    var radius = data.radius !== undefined ? data.radius : 0.5;
	    var height = data.height !== undefined ? data.height : 1;
	    var shape = null;

	    if (typeof Ammo !== 'undefined') {
	      switch (axis) {
	        case 0:
	          shape = new Ammo.btConeShapeX(radius, height);
	          break;

	        case 1:
	          shape = new Ammo.btConeShape(radius, height);
	          break;

	        case 2:
	          shape = new Ammo.btConeShapeZ(radius, height);
	          break;
	      }
	    }

	    return shape;
	  };

	  return CollisionConeSystemImpl;
	}(CollisionSystemImpl);

	var CollisionMeshSystemImpl = function (_CollisionSystemImpl6) {
	  _inheritsLoose(CollisionMeshSystemImpl, _CollisionSystemImpl6);

	  function CollisionMeshSystemImpl() {
	    return _CollisionSystemImpl6.apply(this, arguments) || this;
	  }

	  var _proto7 = CollisionMeshSystemImpl.prototype;

	  _proto7.beforeInitialize = function beforeInitialize(component, data) {};

	  _proto7.createAmmoMesh = function createAmmoMesh(mesh, node, shape) {
	    var triMesh;

	    if (this.system._triMeshCache[mesh.id]) {
	      triMesh = this.system._triMeshCache[mesh.id];
	    } else {
	      var vb = mesh.vertexBuffer;
	      var format = vb.getFormat();
	      var stride;
	      var positions;

	      for (var i = 0; i < format.elements.length; i++) {
	        var element = format.elements[i];

	        if (element.name === SEMANTIC_POSITION) {
	          positions = new Float32Array(vb.lock(), element.offset);
	          stride = element.stride / 4;
	          break;
	        }
	      }

	      var indices = [];
	      mesh.getIndices(indices);
	      var numTriangles = mesh.primitive[0].count / 3;
	      var v1 = new Ammo.btVector3();
	      var v2 = new Ammo.btVector3();
	      var v3 = new Ammo.btVector3();
	      var i1, i2, i3;
	      var base = mesh.primitive[0].base;
	      triMesh = new Ammo.btTriangleMesh();
	      this.system._triMeshCache[mesh.id] = triMesh;

	      for (var _i = 0; _i < numTriangles; _i++) {
	        i1 = indices[base + _i * 3] * stride;
	        i2 = indices[base + _i * 3 + 1] * stride;
	        i3 = indices[base + _i * 3 + 2] * stride;
	        v1.setValue(positions[i1], positions[i1 + 1], positions[i1 + 2]);
	        v2.setValue(positions[i2], positions[i2 + 1], positions[i2 + 2]);
	        v3.setValue(positions[i3], positions[i3 + 1], positions[i3 + 2]);
	        triMesh.addTriangle(v1, v2, v3, true);
	      }

	      Ammo.destroy(v1);
	      Ammo.destroy(v2);
	      Ammo.destroy(v3);
	    }

	    var useQuantizedAabbCompression = true;
	    var triMeshShape = new Ammo.btBvhTriangleMeshShape(triMesh, useQuantizedAabbCompression);

	    var scaling = this.system._getNodeScaling(node);

	    triMeshShape.setLocalScaling(scaling);
	    Ammo.destroy(scaling);

	    var transform = this.system._getNodeTransform(node);

	    shape.addChildShape(transform, triMeshShape);
	    Ammo.destroy(transform);
	  };

	  _proto7.createPhysicalShape = function createPhysicalShape(entity, data) {
	    if (typeof Ammo === 'undefined') return undefined;

	    if (data.model || data.render) {
	      var shape = new Ammo.btCompoundShape();

	      if (data.model) {
	        var meshInstances = data.model.meshInstances;

	        for (var i = 0; i < meshInstances.length; i++) {
	          this.createAmmoMesh(meshInstances[i].mesh, meshInstances[i].node, shape);
	        }
	      } else if (data.render) {
	        var meshes = data.render.meshes;

	        for (var _i2 = 0; _i2 < meshes.length; _i2++) {
	          this.createAmmoMesh(meshes[_i2], tempGraphNode, shape);
	        }
	      }

	      var entityTransform = entity.getWorldTransform();
	      var scale = entityTransform.getScale();
	      var vec = new Ammo.btVector3(scale.x, scale.y, scale.z);
	      shape.setLocalScaling(vec);
	      Ammo.destroy(vec);
	      return shape;
	    }

	    return undefined;
	  };

	  _proto7.recreatePhysicalShapes = function recreatePhysicalShapes(component) {
	    var data = component.data;

	    if (data.renderAsset || data.asset) {
	      if (component.enabled && component.entity.enabled) {
	        this.loadAsset(component, data.renderAsset || data.asset, data.renderAsset ? 'render' : 'model');
	        return;
	      }
	    }

	    this.doRecreatePhysicalShape(component);
	  };

	  _proto7.loadAsset = function loadAsset(component, id, property) {
	    var _this = this;

	    var data = component.data;
	    var assets = this.system.app.assets;
	    var asset = assets.get(id);

	    if (asset) {
	      asset.ready(function (asset) {
	        data[property] = asset.resource;

	        _this.doRecreatePhysicalShape(component);
	      });
	      assets.load(asset);
	    } else {
	      assets.once('add:' + id, function (asset) {
	        asset.ready(function (asset) {
	          data[property] = asset.resource;

	          _this.doRecreatePhysicalShape(component);
	        });
	        assets.load(asset);
	      });
	    }
	  };

	  _proto7.doRecreatePhysicalShape = function doRecreatePhysicalShape(component) {
	    var entity = component.entity;
	    var data = component.data;

	    if (data.model || data.render) {
	      this.destroyShape(data);
	      data.shape = this.createPhysicalShape(entity, data);

	      if (entity.rigidbody) {
	        entity.rigidbody.disableSimulation();
	        entity.rigidbody.createBody();

	        if (entity.enabled && entity.rigidbody.enabled) {
	          entity.rigidbody.enableSimulation();
	        }
	      } else {
	        if (!entity.trigger) {
	          entity.trigger = new Trigger(this.system.app, component, data);
	        } else {
	          entity.trigger.initialize(data);
	        }
	      }
	    } else {
	      this.beforeRemove(entity, component);
	      this.remove(entity, data);
	    }
	  };

	  _proto7.updateTransform = function updateTransform(component, position, rotation, scale) {
	    if (component.shape) {
	      var entityTransform = component.entity.getWorldTransform();
	      var worldScale = entityTransform.getScale();
	      var previousScale = component.shape.getLocalScaling();

	      if (worldScale.x !== previousScale.x() || worldScale.y !== previousScale.y() || worldScale.z !== previousScale.z()) {
	        this.doRecreatePhysicalShape(component);
	      }
	    }

	    _CollisionSystemImpl6.prototype.updateTransform.call(this, component, position, rotation, scale);
	  };

	  _proto7.destroyShape = function destroyShape(data) {
	    if (!data.shape) return;
	    var numShapes = data.shape.getNumChildShapes();

	    for (var i = 0; i < numShapes; i++) {
	      var shape = data.shape.getChildShape(i);
	      Ammo.destroy(shape);
	    }

	    Ammo.destroy(data.shape);
	    data.shape = null;
	  };

	  _proto7.remove = function remove(entity, data) {
	    this.destroyShape(data);

	    _CollisionSystemImpl6.prototype.remove.call(this, entity, data);
	  };

	  return CollisionMeshSystemImpl;
	}(CollisionSystemImpl);

	var CollisionCompoundSystemImpl = function (_CollisionSystemImpl7) {
	  _inheritsLoose(CollisionCompoundSystemImpl, _CollisionSystemImpl7);

	  function CollisionCompoundSystemImpl() {
	    return _CollisionSystemImpl7.apply(this, arguments) || this;
	  }

	  var _proto8 = CollisionCompoundSystemImpl.prototype;

	  _proto8.createPhysicalShape = function createPhysicalShape(entity, data) {
	    if (typeof Ammo !== 'undefined') {
	      return new Ammo.btCompoundShape();
	    }

	    return undefined;
	  };

	  _proto8._addEachDescendant = function _addEachDescendant(entity) {
	    if (!entity.collision || entity.rigidbody) return;
	    entity.collision._compoundParent = this;

	    if (entity !== this.entity) {
	      entity.collision.system.recreatePhysicalShapes(entity.collision);
	    }
	  };

	  _proto8._updateEachDescendant = function _updateEachDescendant(entity) {
	    if (!entity.collision) return;
	    if (entity.collision._compoundParent !== this) return;
	    entity.collision._compoundParent = null;

	    if (entity !== this.entity && !entity.rigidbody) {
	      entity.collision.system.recreatePhysicalShapes(entity.collision);
	    }
	  };

	  _proto8._updateEachDescendantTransform = function _updateEachDescendantTransform(entity) {
	    if (!entity.collision || entity.collision._compoundParent !== this.collision._compoundParent) return;
	    this.collision.system.updateCompoundChildTransform(entity);
	  };

	  return CollisionCompoundSystemImpl;
	}(CollisionSystemImpl);

	var CollisionComponentSystem = function (_ComponentSystem) {
	  _inheritsLoose(CollisionComponentSystem, _ComponentSystem);

	  function CollisionComponentSystem(app) {
	    var _this2;

	    _this2 = _ComponentSystem.call(this, app) || this;
	    _this2.id = 'collision';
	    _this2.ComponentType = CollisionComponent;
	    _this2.DataType = CollisionComponentData;
	    _this2.schema = _schema$g;
	    _this2.implementations = {};
	    _this2._triMeshCache = {};

	    _this2.on('beforeremove', _this2.onBeforeRemove, _assertThisInitialized(_this2));

	    _this2.on('remove', _this2.onRemove, _assertThisInitialized(_this2));

	    return _this2;
	  }

	  var _proto9 = CollisionComponentSystem.prototype;

	  _proto9.initializeComponentData = function initializeComponentData(component, _data, properties) {
	    properties = ['type', 'halfExtents', 'radius', 'axis', 'height', 'shape', 'model', 'asset', 'render', 'renderAsset', 'enabled'];
	    var data = {};

	    for (var i = 0, len = properties.length; i < len; i++) {
	      var property = properties[i];
	      data[property] = _data[property];
	    }

	    var idx;

	    if (_data.hasOwnProperty('asset')) {
	      idx = properties.indexOf('model');

	      if (idx !== -1) {
	        properties.splice(idx, 1);
	      }

	      idx = properties.indexOf('render');

	      if (idx !== -1) {
	        properties.splice(idx, 1);
	      }
	    } else if (_data.hasOwnProperty('model')) {
	      idx = properties.indexOf('asset');

	      if (idx !== -1) {
	        properties.splice(idx, 1);
	      }
	    }

	    if (!data.type) {
	      data.type = component.data.type;
	    }

	    component.data.type = data.type;

	    if (data.halfExtents && Array.isArray(data.halfExtents)) {
	      data.halfExtents = new Vec3(data.halfExtents[0], data.halfExtents[1], data.halfExtents[2]);
	    }

	    var impl = this._createImplementation(data.type);

	    impl.beforeInitialize(component, data);

	    _ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);

	    impl.afterInitialize(component, data);
	  };

	  _proto9._createImplementation = function _createImplementation(type) {
	    if (this.implementations[type] === undefined) {
	      var impl;

	      switch (type) {
	        case 'box':
	          impl = new CollisionBoxSystemImpl(this);
	          break;

	        case 'sphere':
	          impl = new CollisionSphereSystemImpl(this);
	          break;

	        case 'capsule':
	          impl = new CollisionCapsuleSystemImpl(this);
	          break;

	        case 'cylinder':
	          impl = new CollisionCylinderSystemImpl(this);
	          break;

	        case 'cone':
	          impl = new CollisionConeSystemImpl(this);
	          break;

	        case 'mesh':
	          impl = new CollisionMeshSystemImpl(this);
	          break;

	        case 'compound':
	          impl = new CollisionCompoundSystemImpl(this);
	          break;
	      }

	      this.implementations[type] = impl;
	    }

	    return this.implementations[type];
	  };

	  _proto9._getImplementation = function _getImplementation(entity) {
	    return this.implementations[entity.collision.data.type];
	  };

	  _proto9.cloneComponent = function cloneComponent(entity, clone) {
	    return this._getImplementation(entity).clone(entity, clone);
	  };

	  _proto9.onBeforeRemove = function onBeforeRemove(entity, component) {
	    this.implementations[component.data.type].beforeRemove(entity, component);
	    component.onBeforeRemove();
	  };

	  _proto9.onRemove = function onRemove(entity, data) {
	    this.implementations[data.type].remove(entity, data);
	  };

	  _proto9.updateCompoundChildTransform = function updateCompoundChildTransform(entity) {
	    this._removeCompoundChild(entity.collision._compoundParent, entity.collision.data.shape);

	    if (entity.enabled && entity.collision.enabled) {
	      var transform = this._getNodeTransform(entity, entity.collision._compoundParent.entity);

	      entity.collision._compoundParent.shape.addChildShape(transform, entity.collision.data.shape);

	      Ammo.destroy(transform);
	    }
	  };

	  _proto9._removeCompoundChild = function _removeCompoundChild(collision, shape) {
	    if (collision.shape.removeChildShape) {
	      collision.shape.removeChildShape(shape);
	    } else {
	      var ind = collision._getCompoundChildShapeIndex(shape);

	      if (ind !== null) {
	        collision.shape.removeChildShapeByIndex(ind);
	      }
	    }
	  };

	  _proto9.onTransformChanged = function onTransformChanged(component, position, rotation, scale) {
	    this.implementations[component.data.type].updateTransform(component, position, rotation, scale);
	  };

	  _proto9.changeType = function changeType(component, previousType, newType) {
	    this.implementations[previousType].beforeRemove(component.entity, component);
	    this.implementations[previousType].remove(component.entity, component.data);

	    this._createImplementation(newType).reset(component, component.data);
	  };

	  _proto9.recreatePhysicalShapes = function recreatePhysicalShapes(component) {
	    this.implementations[component.data.type].recreatePhysicalShapes(component);
	  };

	  _proto9._calculateNodeRelativeTransform = function _calculateNodeRelativeTransform(node, relative) {
	    if (node === relative) {
	      var scale = node.getWorldTransform().getScale();
	      mat4.setScale(scale.x, scale.y, scale.z);
	    } else {
	      this._calculateNodeRelativeTransform(node.parent, relative);

	      mat4.mul(node.getLocalTransform());
	    }
	  };

	  _proto9._getNodeScaling = function _getNodeScaling(node) {
	    var wtm = node.getWorldTransform();
	    var scl = wtm.getScale();
	    return new Ammo.btVector3(scl.x, scl.y, scl.z);
	  };

	  _proto9._getNodeTransform = function _getNodeTransform(node, relative) {
	    var pos, rot;

	    if (relative) {
	      this._calculateNodeRelativeTransform(node, relative);

	      pos = vec3;
	      rot = quat$1;
	      mat4.getTranslation(pos);
	      rot.setFromMat4(mat4);
	    } else {
	      pos = node.getPosition();
	      rot = node.getRotation();
	    }

	    var transform = new Ammo.btTransform();
	    transform.setIdentity();
	    var origin = transform.getOrigin();
	    origin.setValue(pos.x, pos.y, pos.z);
	    var ammoQuat = new Ammo.btQuaternion();
	    ammoQuat.setValue(rot.x, rot.y, rot.z, rot.w);
	    transform.setRotation(ammoQuat);
	    Ammo.destroy(ammoQuat);
	    Ammo.destroy(origin);
	    return transform;
	  };

	  _proto9.destroy = function destroy() {
	    for (var key in this._triMeshCache) {
	      Ammo.destroy(this._triMeshCache[key]);
	    }

	    this._triMeshCache = null;

	    _ComponentSystem.prototype.destroy.call(this);
	  };

	  return CollisionComponentSystem;
	}(ComponentSystem);

	Component._buildAccessors(CollisionComponent.prototype, _schema$g);

	var ImageRenderable = function () {
	  function ImageRenderable(entity, mesh, material) {
	    this._entity = entity;
	    this._element = entity.element;
	    this.model = new Model();
	    this.node = new GraphNode();
	    this.model.graph = this.node;
	    this.mesh = mesh;
	    this.meshInstance = new MeshInstance(this.mesh, material, this.node);
	    this.meshInstance.name = 'ImageElement: ' + entity.name;
	    this.meshInstance.castShadow = false;
	    this.meshInstance.receiveShadow = false;
	    this._meshDirty = false;
	    this.model.meshInstances.push(this.meshInstance);

	    this._entity.addChild(this.model.graph);

	    this.model._entity = this._entity;
	    this.unmaskMeshInstance = null;
	  }

	  var _proto = ImageRenderable.prototype;

	  _proto.destroy = function destroy() {
	    this.setMaterial(null);

	    this._element.removeModelFromLayers(this.model);

	    this.model.destroy();
	    this.model = null;
	    this.node = null;
	    this.mesh = null;
	    this.meshInstance = null;
	    this._entity = null;
	    this._element = null;
	  };

	  _proto.setMesh = function setMesh(mesh) {
	    if (!this.meshInstance) return;
	    this.mesh = mesh;
	    this.meshInstance.mesh = mesh;
	    this.meshInstance.visible = !!mesh;

	    if (this.unmaskMeshInstance) {
	      this.unmaskMeshInstance.mesh = mesh;
	    }

	    this.forceUpdateAabb();
	  };

	  _proto.setMask = function setMask(mask) {
	    if (!this.meshInstance) return;

	    if (mask) {
	      this.unmaskMeshInstance = new MeshInstance(this.mesh, this.meshInstance.material, this.node);
	      this.unmaskMeshInstance.name = 'Unmask: ' + this._entity.name;
	      this.unmaskMeshInstance.castShadow = false;
	      this.unmaskMeshInstance.receiveShadow = false;
	      this.unmaskMeshInstance.pick = false;
	      this.model.meshInstances.push(this.unmaskMeshInstance);

	      for (var name in this.meshInstance.parameters) {
	        this.unmaskMeshInstance.setParameter(name, this.meshInstance.parameters[name].data);
	      }
	    } else {
	      var idx = this.model.meshInstances.indexOf(this.unmaskMeshInstance);

	      if (idx >= 0) {
	        this.model.meshInstances.splice(idx, 1);
	      }

	      this.unmaskMeshInstance = null;
	    }

	    if (this._entity.enabled && this._element.enabled) {
	      this._element.removeModelFromLayers(this.model);

	      this._element.addModelToLayers(this.model);
	    }
	  };

	  _proto.setMaterial = function setMaterial(material) {
	    if (!this.meshInstance) return;
	    this.meshInstance.material = material;

	    if (this.unmaskMeshInstance) {
	      this.unmaskMeshInstance.material = material;
	    }
	  };

	  _proto.setParameter = function setParameter(name, value) {
	    if (!this.meshInstance) return;
	    this.meshInstance.setParameter(name, value);

	    if (this.unmaskMeshInstance) {
	      this.unmaskMeshInstance.setParameter(name, value);
	    }
	  };

	  _proto.deleteParameter = function deleteParameter(name) {
	    if (!this.meshInstance) return;
	    this.meshInstance.deleteParameter(name);

	    if (this.unmaskMeshInstance) {
	      this.unmaskMeshInstance.deleteParameter(name);
	    }
	  };

	  _proto.setUnmaskDrawOrder = function setUnmaskDrawOrder() {
	    if (!this.meshInstance) return;

	    var getLastChild = function getLastChild(e) {
	      var last;
	      var c = e.children;
	      var l = c.length;

	      if (l) {
	        for (var i = 0; i < l; i++) {
	          if (c[i].element) {
	            last = c[i];
	          }
	        }

	        if (!last) return null;
	        var child = getLastChild(last);

	        if (child) {
	          return child;
	        }

	        return last;
	      }

	      return null;
	    };

	    if (this.unmaskMeshInstance) {
	      var lastChild = getLastChild(this._entity);

	      if (lastChild && lastChild.element) {
	        this.unmaskMeshInstance.drawOrder = lastChild.element.drawOrder + lastChild.element.getMaskOffset();
	      } else {
	        this.unmaskMeshInstance.drawOrder = this.meshInstance.drawOrder + this._element.getMaskOffset();
	      }
	    }
	  };

	  _proto.setDrawOrder = function setDrawOrder(drawOrder) {
	    if (!this.meshInstance) return;
	    this.meshInstance.drawOrder = drawOrder;
	  };

	  _proto.setCull = function setCull(cull) {
	    if (!this.meshInstance) return;
	    var element = this._element;
	    var visibleFn = null;

	    if (cull && element._isScreenSpace()) {
	      visibleFn = function visibleFn(camera) {
	        return element.isVisibleForCamera(camera);
	      };
	    }

	    this.meshInstance.cull = cull;
	    this.meshInstance.isVisibleFunc = visibleFn;

	    if (this.unmaskMeshInstance) {
	      this.unmaskMeshInstance.cull = cull;
	      this.unmaskMeshInstance.isVisibleFunc = visibleFn;
	    }
	  };

	  _proto.setScreenSpace = function setScreenSpace(screenSpace) {
	    if (!this.meshInstance) return;
	    this.meshInstance.screenSpace = screenSpace;

	    if (this.unmaskMeshInstance) {
	      this.unmaskMeshInstance.screenSpace = screenSpace;
	    }
	  };

	  _proto.setLayer = function setLayer(layer) {
	    if (!this.meshInstance) return;
	    this.meshInstance.layer = layer;

	    if (this.unmaskMeshInstance) {
	      this.unmaskMeshInstance.layer = layer;
	    }
	  };

	  _proto.forceUpdateAabb = function forceUpdateAabb(mask) {
	    if (!this.meshInstance) return;
	    this.meshInstance._aabbVer = -1;

	    if (this.unmaskMeshInstance) {
	      this.unmaskMeshInstance._aabbVer = -1;
	    }
	  };

	  _proto.setAabbFunc = function setAabbFunc(fn) {
	    if (!this.meshInstance) return;
	    this.meshInstance._updateAabbFunc = fn;

	    if (this.unmaskMeshInstance) {
	      this.unmaskMeshInstance._updateAabbFunc = fn;
	    }
	  };

	  return ImageRenderable;
	}();

	var ImageElement = function () {
	  function ImageElement(element) {
	    this._element = element;
	    this._entity = element.entity;
	    this._system = element.system;
	    this._textureAsset = null;
	    this._texture = null;
	    this._materialAsset = null;
	    this._material = null;
	    this._spriteAsset = null;
	    this._sprite = null;
	    this._spriteFrame = 0;
	    this._pixelsPerUnit = null;
	    this._targetAspectRatio = -1;
	    this._rect = new Vec4(0, 0, 1, 1);
	    this._mask = false;
	    this._maskRef = 0;
	    this._outerScale = new Vec2();
	    this._outerScaleUniform = new Float32Array(2);
	    this._innerOffset = new Vec4();
	    this._innerOffsetUniform = new Float32Array(4);
	    this._atlasRect = new Vec4();
	    this._atlasRectUniform = new Float32Array(4);
	    this._defaultMesh = this._createMesh();
	    this._renderable = new ImageRenderable(this._entity, this._defaultMesh, this._material);
	    this._color = new Color(1, 1, 1, 1);
	    this._colorUniform = new Float32Array([1, 1, 1]);

	    this._renderable.setParameter('material_emissive', this._colorUniform);

	    this._renderable.setParameter('material_opacity', 1);

	    this._updateAabbFunc = this._updateAabb.bind(this);

	    this._onScreenChange(this._element.screen);

	    this._element.on('resize', this._onParentResizeOrPivotChange, this);

	    this._element.on('set:pivot', this._onParentResizeOrPivotChange, this);

	    this._element.on('screen:set:screenspace', this._onScreenSpaceChange, this);

	    this._element.on('set:screen', this._onScreenChange, this);

	    this._element.on('set:draworder', this._onDrawOrderChange, this);

	    this._element.on('screen:set:resolution', this._onResolutionChange, this);
	  }

	  var _proto2 = ImageElement.prototype;

	  _proto2.destroy = function destroy() {
	    this.textureAsset = null;
	    this.spriteAsset = null;
	    this.materialAsset = null;

	    this._renderable.setMesh(this._defaultMesh);

	    this._renderable.destroy();

	    this._defaultMesh = null;

	    this._element.off('resize', this._onParentResizeOrPivotChange, this);

	    this._element.off('set:pivot', this._onParentResizeOrPivotChange, this);

	    this._element.off('screen:set:screenspace', this._onScreenSpaceChange, this);

	    this._element.off('set:screen', this._onScreenChange, this);

	    this._element.off('set:draworder', this._onDrawOrderChange, this);

	    this._element.off('screen:set:resolution', this._onResolutionChange, this);
	  };

	  _proto2._onResolutionChange = function _onResolutionChange(res) {};

	  _proto2._onParentResizeOrPivotChange = function _onParentResizeOrPivotChange() {
	    if (this._renderable.mesh) {
	      this._updateMesh(this._renderable.mesh);
	    }
	  };

	  _proto2._onScreenSpaceChange = function _onScreenSpaceChange(value) {
	    this._updateMaterial(value);
	  };

	  _proto2._onScreenChange = function _onScreenChange(screen, previous) {
	    if (screen) {
	      this._updateMaterial(screen.screen.screenSpace);
	    } else {
	      this._updateMaterial(false);
	    }
	  };

	  _proto2._onDrawOrderChange = function _onDrawOrderChange(order) {
	    this._renderable.setDrawOrder(order);

	    if (this.mask && this._element.screen) {
	      this._element.screen.screen.once('syncdraworder', function () {
	        this._renderable.setUnmaskDrawOrder();
	      }, this);
	    }
	  };

	  _proto2._hasUserMaterial = function _hasUserMaterial() {
	    return !!this._materialAsset || !!this._material && this._system.defaultImageMaterials.indexOf(this._material) === -1;
	  };

	  _proto2._use9Slicing = function _use9Slicing() {
	    return this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED);
	  };

	  _proto2._updateMaterial = function _updateMaterial(screenSpace) {
	    var mask = !!this._mask;
	    var nineSliced = !!(this.sprite && this.sprite.renderMode === SPRITE_RENDERMODE_SLICED);
	    var nineTiled = !!(this.sprite && this.sprite.renderMode === SPRITE_RENDERMODE_TILED);

	    if (!this._hasUserMaterial()) {
	      this._material = this._system.getImageElementMaterial(screenSpace, mask, nineSliced, nineTiled);
	    }

	    if (this._renderable) {
	      this._renderable.setCull(!this._element._isScreenSpace() || this._element._isScreenCulled());

	      this._renderable.setMaterial(this._material);

	      this._renderable.setScreenSpace(screenSpace);

	      this._renderable.setLayer(screenSpace ? LAYER_HUD : LAYER_WORLD);
	    }
	  };

	  _proto2._createMesh = function _createMesh() {
	    var element = this._element;
	    var w = element.calculatedWidth;
	    var h = element.calculatedHeight;
	    var r = this._rect;
	    var vertexData = new ArrayBuffer(4 * 8 * 4);
	    var vertexDataF32 = new Float32Array(vertexData);
	    vertexDataF32[5] = 1;
	    vertexDataF32[6] = r.x;
	    vertexDataF32[7] = 1.0 - r.y;
	    vertexDataF32[8] = w;
	    vertexDataF32[13] = 1;
	    vertexDataF32[14] = r.x + r.z;
	    vertexDataF32[15] = 1.0 - r.y;
	    vertexDataF32[16] = w;
	    vertexDataF32[17] = h;
	    vertexDataF32[21] = 1;
	    vertexDataF32[22] = r.x + r.z;
	    vertexDataF32[23] = 1.0 - (r.y + r.w);
	    vertexDataF32[25] = h;
	    vertexDataF32[29] = 1;
	    vertexDataF32[30] = r.x;
	    vertexDataF32[31] = 1.0 - (r.y + r.w);
	    var vertexDesc = [{
	      semantic: SEMANTIC_POSITION,
	      components: 3,
	      type: TYPE_FLOAT32
	    }, {
	      semantic: SEMANTIC_NORMAL,
	      components: 3,
	      type: TYPE_FLOAT32
	    }, {
	      semantic: SEMANTIC_TEXCOORD0,
	      components: 2,
	      type: TYPE_FLOAT32
	    }];
	    var device = this._system.app.graphicsDevice;
	    var vertexFormat = new VertexFormat(device, vertexDesc);
	    var vertexBuffer = new VertexBuffer(device, vertexFormat, 4, BUFFER_STATIC, vertexData);
	    var mesh = new Mesh(device);
	    mesh.vertexBuffer = vertexBuffer;
	    mesh.primitive[0].type = PRIMITIVE_TRIFAN;
	    mesh.primitive[0].base = 0;
	    mesh.primitive[0].count = 4;
	    mesh.primitive[0].indexed = false;
	    mesh.aabb.setMinMax(Vec3.ZERO, new Vec3(w, h, 0));

	    this._updateMesh(mesh);

	    return mesh;
	  };

	  _proto2._updateMesh = function _updateMesh(mesh) {
	    var element = this._element;
	    var w = element.calculatedWidth;
	    var h = element.calculatedHeight;

	    if (element.fitMode !== FITMODE_STRETCH && this._targetAspectRatio > 0) {
	      var actualRatio = element.calculatedWidth / element.calculatedHeight;

	      if (element.fitMode === FITMODE_CONTAIN && actualRatio > this._targetAspectRatio || element.fitMode === FITMODE_COVER && actualRatio < this._targetAspectRatio) {
	        w = element.calculatedHeight * this._targetAspectRatio;
	      } else {
	        h = element.calculatedWidth / this._targetAspectRatio;
	      }
	    }

	    var screenSpace = element._isScreenSpace();

	    this._updateMaterial(screenSpace);

	    if (this._renderable) this._renderable.forceUpdateAabb();

	    if (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED)) {
	      var frameData = this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]];
	      var borderWidthScale = 2 / frameData.rect.z;
	      var borderHeightScale = 2 / frameData.rect.w;

	      this._innerOffset.set(frameData.border.x * borderWidthScale, frameData.border.y * borderHeightScale, frameData.border.z * borderWidthScale, frameData.border.w * borderHeightScale);

	      var tex = this.sprite.atlas.texture;

	      this._atlasRect.set(frameData.rect.x / tex.width, frameData.rect.y / tex.height, frameData.rect.z / tex.width, frameData.rect.w / tex.height);

	      var ppu = this._pixelsPerUnit !== null ? this._pixelsPerUnit : this.sprite.pixelsPerUnit;
	      var scaleMulX = frameData.rect.z / ppu;
	      var scaleMulY = frameData.rect.w / ppu;

	      this._outerScale.set(Math.max(w, this._innerOffset.x * scaleMulX), Math.max(h, this._innerOffset.y * scaleMulY));

	      var scaleX = scaleMulX;
	      var scaleY = scaleMulY;
	      this._outerScale.x /= scaleMulX;
	      this._outerScale.y /= scaleMulY;
	      scaleX *= math.clamp(w / (this._innerOffset.x * scaleMulX), 0.0001, 1);
	      scaleY *= math.clamp(h / (this._innerOffset.y * scaleMulY), 0.0001, 1);

	      if (this._renderable) {
	        this._innerOffsetUniform[0] = this._innerOffset.x;
	        this._innerOffsetUniform[1] = this._innerOffset.y;
	        this._innerOffsetUniform[2] = this._innerOffset.z;
	        this._innerOffsetUniform[3] = this._innerOffset.w;

	        this._renderable.setParameter('innerOffset', this._innerOffsetUniform);

	        this._atlasRectUniform[0] = this._atlasRect.x;
	        this._atlasRectUniform[1] = this._atlasRect.y;
	        this._atlasRectUniform[2] = this._atlasRect.z;
	        this._atlasRectUniform[3] = this._atlasRect.w;

	        this._renderable.setParameter('atlasRect', this._atlasRectUniform);

	        this._outerScaleUniform[0] = this._outerScale.x;
	        this._outerScaleUniform[1] = this._outerScale.y;

	        this._renderable.setParameter('outerScale', this._outerScaleUniform);

	        this._renderable.setAabbFunc(this._updateAabbFunc);

	        this._renderable.node.setLocalScale(scaleX, scaleY, 1);

	        this._renderable.node.setLocalPosition((0.5 - element.pivot.x) * w, (0.5 - element.pivot.y) * h, 0);
	      }
	    } else {
	      var vb = mesh.vertexBuffer;
	      var vertexDataF32 = new Float32Array(vb.lock());
	      var hp = element.pivot.x;
	      var vp = element.pivot.y;
	      vertexDataF32[0] = 0 - hp * w;
	      vertexDataF32[1] = 0 - vp * h;
	      vertexDataF32[8] = w - hp * w;
	      vertexDataF32[9] = 0 - vp * h;
	      vertexDataF32[16] = w - hp * w;
	      vertexDataF32[17] = h - vp * h;
	      vertexDataF32[24] = 0 - hp * w;
	      vertexDataF32[25] = h - vp * h;
	      var atlasTextureWidth = 1;
	      var atlasTextureHeight = 1;
	      var rect = this._rect;

	      if (this._sprite && this._sprite.frameKeys[this._spriteFrame] && this._sprite.atlas) {
	        var frame = this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]];

	        if (frame) {
	          rect = frame.rect;
	          atlasTextureWidth = this._sprite.atlas.texture.width;
	          atlasTextureHeight = this._sprite.atlas.texture.height;
	        }
	      }

	      vertexDataF32[6] = rect.x / atlasTextureWidth;
	      vertexDataF32[7] = 1.0 - rect.y / atlasTextureHeight;
	      vertexDataF32[14] = (rect.x + rect.z) / atlasTextureWidth;
	      vertexDataF32[15] = 1.0 - rect.y / atlasTextureHeight;
	      vertexDataF32[22] = (rect.x + rect.z) / atlasTextureWidth;
	      vertexDataF32[23] = 1.0 - (rect.y + rect.w) / atlasTextureHeight;
	      vertexDataF32[30] = rect.x / atlasTextureWidth;
	      vertexDataF32[31] = 1.0 - (rect.y + rect.w) / atlasTextureHeight;
	      vb.unlock();
	      var min = new Vec3(0 - hp * w, 0 - vp * h, 0);
	      var max = new Vec3(w - hp * w, h - vp * h, 0);
	      mesh.aabb.setMinMax(min, max);

	      if (this._renderable) {
	        this._renderable.node.setLocalScale(1, 1, 1);

	        this._renderable.node.setLocalPosition(0, 0, 0);

	        this._renderable.setAabbFunc(null);
	      }
	    }

	    this._meshDirty = false;
	  };

	  _proto2._updateSprite = function _updateSprite() {
	    var nineSlice = false;
	    var mesh = null;
	    this._targetAspectRatio = -1;

	    if (this._sprite && this._sprite.atlas) {
	      mesh = this._sprite.meshes[this.spriteFrame];
	      nineSlice = this._sprite.renderMode === SPRITE_RENDERMODE_SLICED || this._sprite.renderMode === SPRITE_RENDERMODE_TILED;
	      var frameData = this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]];

	      if ((frameData == null ? void 0 : frameData.rect.w) > 0) {
	        this._targetAspectRatio = frameData.rect.z / frameData.rect.w;
	      }
	    }

	    this.mesh = nineSlice ? mesh : this._defaultMesh;
	    this.refreshMesh();
	  };

	  _proto2.refreshMesh = function refreshMesh() {
	    if (this.mesh) {
	      if (!this._element._beingInitialized) {
	        this._updateMesh(this.mesh);
	      } else {
	        this._meshDirty = true;
	      }
	    }
	  };

	  _proto2._updateAabb = function _updateAabb(aabb) {
	    aabb.center.set(0, 0, 0);
	    aabb.halfExtents.set(this._outerScale.x * 0.5, this._outerScale.y * 0.5, 0.001);
	    aabb.setFromTransformedAabb(aabb, this._renderable.node.getWorldTransform());
	    return aabb;
	  };

	  _proto2._toggleMask = function _toggleMask() {
	    this._element._dirtifyMask();

	    var screenSpace = this._element._isScreenSpace();

	    this._updateMaterial(screenSpace);

	    this._renderable.setMask(!!this._mask);
	  };

	  _proto2._onMaterialLoad = function _onMaterialLoad(asset) {
	    this.material = asset.resource;
	  };

	  _proto2._onMaterialAdded = function _onMaterialAdded(asset) {
	    this._system.app.assets.off('add:' + asset.id, this._onMaterialAdded, this);

	    if (this._materialAsset === asset.id) {
	      this._bindMaterialAsset(asset);
	    }
	  };

	  _proto2._bindMaterialAsset = function _bindMaterialAsset(asset) {
	    if (!this._entity.enabled) return;
	    asset.on('load', this._onMaterialLoad, this);
	    asset.on('change', this._onMaterialChange, this);
	    asset.on('remove', this._onMaterialRemove, this);

	    if (asset.resource) {
	      this._onMaterialLoad(asset);
	    } else {
	      this._system.app.assets.load(asset);
	    }
	  };

	  _proto2._unbindMaterialAsset = function _unbindMaterialAsset(asset) {
	    asset.off('load', this._onMaterialLoad, this);
	    asset.off('change', this._onMaterialChange, this);
	    asset.off('remove', this._onMaterialRemove, this);
	  };

	  _proto2._onMaterialChange = function _onMaterialChange() {};

	  _proto2._onMaterialRemove = function _onMaterialRemove() {};

	  _proto2._onTextureAdded = function _onTextureAdded(asset) {
	    this._system.app.assets.off('add:' + asset.id, this._onTextureAdded, this);

	    if (this._textureAsset === asset.id) {
	      this._bindTextureAsset(asset);
	    }
	  };

	  _proto2._bindTextureAsset = function _bindTextureAsset(asset) {
	    if (!this._entity.enabled) return;
	    asset.on('load', this._onTextureLoad, this);
	    asset.on('change', this._onTextureChange, this);
	    asset.on('remove', this._onTextureRemove, this);

	    if (asset.resource) {
	      this._onTextureLoad(asset);
	    } else {
	      this._system.app.assets.load(asset);
	    }
	  };

	  _proto2._unbindTextureAsset = function _unbindTextureAsset(asset) {
	    asset.off('load', this._onTextureLoad, this);
	    asset.off('change', this._onTextureChange, this);
	    asset.off('remove', this._onTextureRemove, this);
	  };

	  _proto2._onTextureLoad = function _onTextureLoad(asset) {
	    this.texture = asset.resource;
	  };

	  _proto2._onTextureChange = function _onTextureChange(asset) {};

	  _proto2._onTextureRemove = function _onTextureRemove(asset) {};

	  _proto2._onSpriteAssetAdded = function _onSpriteAssetAdded(asset) {
	    this._system.app.assets.off('add:' + asset.id, this._onSpriteAssetAdded, this);

	    if (this._spriteAsset === asset.id) {
	      this._bindSpriteAsset(asset);
	    }
	  };

	  _proto2._bindSpriteAsset = function _bindSpriteAsset(asset) {
	    if (!this._entity.enabled) return;
	    asset.on('load', this._onSpriteAssetLoad, this);
	    asset.on('change', this._onSpriteAssetChange, this);
	    asset.on('remove', this._onSpriteAssetRemove, this);

	    if (asset.resource) {
	      this._onSpriteAssetLoad(asset);
	    } else {
	      this._system.app.assets.load(asset);
	    }
	  };

	  _proto2._unbindSpriteAsset = function _unbindSpriteAsset(asset) {
	    asset.off('load', this._onSpriteAssetLoad, this);
	    asset.off('change', this._onSpriteAssetChange, this);
	    asset.off('remove', this._onSpriteAssetRemove, this);

	    if (asset.data.textureAtlasAsset) {
	      this._system.app.assets.off('load:' + asset.data.textureAtlasAsset, this._onTextureAtlasLoad, this);
	    }
	  };

	  _proto2._onSpriteAssetLoad = function _onSpriteAssetLoad(asset) {
	    if (!asset || !asset.resource) {
	      this.sprite = null;
	    } else {
	      if (!asset.resource.atlas) {
	        var atlasAssetId = asset.data.textureAtlasAsset;

	        if (atlasAssetId) {
	          var assets = this._system.app.assets;
	          assets.off('load:' + atlasAssetId, this._onTextureAtlasLoad, this);
	          assets.once('load:' + atlasAssetId, this._onTextureAtlasLoad, this);
	        }
	      } else {
	        this.sprite = asset.resource;
	      }
	    }
	  };

	  _proto2._onSpriteAssetChange = function _onSpriteAssetChange(asset) {
	    this._onSpriteAssetLoad(asset);
	  };

	  _proto2._onSpriteAssetRemove = function _onSpriteAssetRemove(asset) {};

	  _proto2._bindSprite = function _bindSprite(sprite) {
	    sprite.on('set:meshes', this._onSpriteMeshesChange, this);
	    sprite.on('set:pixelsPerUnit', this._onSpritePpuChange, this);
	    sprite.on('set:atlas', this._onAtlasTextureChange, this);

	    if (sprite.atlas) {
	      sprite.atlas.on('set:texture', this._onAtlasTextureChange, this);
	    }
	  };

	  _proto2._unbindSprite = function _unbindSprite(sprite) {
	    sprite.off('set:meshes', this._onSpriteMeshesChange, this);
	    sprite.off('set:pixelsPerUnit', this._onSpritePpuChange, this);
	    sprite.off('set:atlas', this._onAtlasTextureChange, this);

	    if (sprite.atlas) {
	      sprite.atlas.off('set:texture', this._onAtlasTextureChange, this);
	    }
	  };

	  _proto2._onSpriteMeshesChange = function _onSpriteMeshesChange() {
	    if (this._sprite) {
	      this._spriteFrame = math.clamp(this._spriteFrame, 0, this._sprite.frameKeys.length - 1);
	    }

	    this._updateSprite();
	  };

	  _proto2._onSpritePpuChange = function _onSpritePpuChange() {
	    if (this.sprite.renderMode !== SPRITE_RENDERMODE_SIMPLE && this._pixelsPerUnit === null) {
	      this._updateSprite();
	    }
	  };

	  _proto2._onAtlasTextureChange = function _onAtlasTextureChange() {
	    if (this.sprite && this.sprite.atlas && this.sprite.atlas.texture) {
	      this._renderable.setParameter('texture_emissiveMap', this._sprite.atlas.texture);

	      this._renderable.setParameter('texture_opacityMap', this._sprite.atlas.texture);
	    } else {
	      this._renderable.deleteParameter('texture_emissiveMap');

	      this._renderable.deleteParameter('texture_opacityMap');
	    }
	  };

	  _proto2._onTextureAtlasLoad = function _onTextureAtlasLoad(atlasAsset) {
	    var spriteAsset = this._spriteAsset;

	    if (spriteAsset instanceof Asset) {
	      this._onSpriteAssetLoad(spriteAsset);
	    } else {
	      this._onSpriteAssetLoad(this._system.app.assets.get(spriteAsset));
	    }
	  };

	  _proto2.onEnable = function onEnable() {
	    if (this._materialAsset) {
	      var asset = this._system.app.assets.get(this._materialAsset);

	      if (asset && asset.resource !== this._material) {
	        this._bindMaterialAsset(asset);
	      }
	    }

	    if (this._textureAsset) {
	      var _asset = this._system.app.assets.get(this._textureAsset);

	      if (_asset && _asset.resource !== this._texture) {
	        this._bindTextureAsset(_asset);
	      }
	    }

	    if (this._spriteAsset) {
	      var _asset2 = this._system.app.assets.get(this._spriteAsset);

	      if (_asset2 && _asset2.resource !== this._sprite) {
	        this._bindSpriteAsset(_asset2);
	      }
	    }

	    this._element.addModelToLayers(this._renderable.model);
	  };

	  _proto2.onDisable = function onDisable() {
	    this._element.removeModelFromLayers(this._renderable.model);
	  };

	  _proto2._setStencil = function _setStencil(stencilParams) {
	    this._renderable.meshInstance.stencilFront = stencilParams;
	    this._renderable.meshInstance.stencilBack = stencilParams;
	    var ref = 0;

	    if (this._element.maskedBy) {
	      ref = this._element.maskedBy.element._image._maskRef;
	    }

	    if (this._renderable.unmaskMeshInstance) {
	      var sp = new StencilParameters({
	        ref: ref + 1,
	        func: FUNC_EQUAL,
	        zpass: STENCILOP_DECREMENT
	      });
	      this._renderable.unmaskMeshInstance.stencilFront = sp;
	      this._renderable.unmaskMeshInstance.stencilBack = sp;
	    }
	  };

	  _createClass(ImageElement, [{
	    key: "color",
	    get: function get() {
	      return this._color;
	    },
	    set: function set(value) {
	      var r = value.r;
	      var g = value.g;
	      var b = value.b;

	      if (this._color.r !== r || this._color.g !== g || this._color.b !== b) {
	        this._color.r = r;
	        this._color.g = g;
	        this._color.b = b;
	        this._colorUniform[0] = r;
	        this._colorUniform[1] = g;
	        this._colorUniform[2] = b;

	        this._renderable.setParameter('material_emissive', this._colorUniform);
	      }

	      if (this._element) {
	        this._element.fire('set:color', this._color);
	      }
	    }
	  }, {
	    key: "opacity",
	    get: function get() {
	      return this._color.a;
	    },
	    set: function set(value) {
	      if (value !== this._color.a) {
	        this._color.a = value;

	        this._renderable.setParameter('material_opacity', value);
	      }

	      if (this._element) {
	        this._element.fire('set:opacity', value);
	      }
	    }
	  }, {
	    key: "rect",
	    get: function get() {
	      return this._rect;
	    },
	    set: function set(value) {
	      var x, y, z, w;

	      if (value instanceof Vec4) {
	        x = value.x;
	        y = value.y;
	        z = value.z;
	        w = value.w;
	      } else {
	        x = value[0];
	        y = value[1];
	        z = value[2];
	        w = value[3];
	      }

	      if (x === this._rect.x && y === this._rect.y && z === this._rect.z && w === this._rect.w) {
	        return;
	      }

	      this._rect.set(x, y, z, w);

	      if (this._renderable.mesh) {
	        if (!this._element._beingInitialized) {
	          this._updateMesh(this._renderable.mesh);
	        } else {
	          this._meshDirty = true;
	        }
	      }
	    }
	  }, {
	    key: "material",
	    get: function get() {
	      return this._material;
	    },
	    set: function set(value) {
	      if (this._material === value) return;

	      if (!value) {
	        var screenSpace = this._element._isScreenSpace();

	        if (this.mask) {
	          value = screenSpace ? this._system.defaultScreenSpaceImageMaskMaterial : this._system.defaultImageMaskMaterial;
	        } else {
	          value = screenSpace ? this._system.defaultScreenSpaceImageMaterial : this._system.defaultImageMaterial;
	        }
	      }

	      this._material = value;

	      if (value) {
	        this._renderable.setMaterial(value);

	        if (this._hasUserMaterial()) {
	          this._renderable.deleteParameter('material_opacity');

	          this._renderable.deleteParameter('material_emissive');
	        } else {
	          this._colorUniform[0] = this._color.r;
	          this._colorUniform[1] = this._color.g;
	          this._colorUniform[2] = this._color.b;

	          this._renderable.setParameter('material_emissive', this._colorUniform);

	          this._renderable.setParameter('material_opacity', this._color.a);
	        }
	      }
	    }
	  }, {
	    key: "materialAsset",
	    get: function get() {
	      return this._materialAsset;
	    },
	    set: function set(value) {
	      var assets = this._system.app.assets;
	      var _id = value;

	      if (value instanceof Asset) {
	        _id = value.id;
	      }

	      if (this._materialAsset !== _id) {
	        if (this._materialAsset) {
	          assets.off('add:' + this._materialAsset, this._onMaterialAdded, this);

	          var _prev = assets.get(this._materialAsset);

	          if (_prev) {
	            _prev.off('load', this._onMaterialLoad, this);

	            _prev.off('change', this._onMaterialChange, this);

	            _prev.off('remove', this._onMaterialRemove, this);
	          }
	        }

	        this._materialAsset = _id;

	        if (this._materialAsset) {
	          var asset = assets.get(this._materialAsset);

	          if (!asset) {
	            this.material = null;
	            assets.on('add:' + this._materialAsset, this._onMaterialAdded, this);
	          } else {
	            this._bindMaterialAsset(asset);
	          }
	        } else {
	          this.material = null;
	        }
	      }
	    }
	  }, {
	    key: "texture",
	    get: function get() {
	      return this._texture;
	    },
	    set: function set(value) {
	      if (this._texture === value) return;

	      if (this._textureAsset) {
	        var textureAsset = this._system.app.assets.get(this._textureAsset);

	        if (textureAsset && textureAsset.resource !== value) {
	          this.textureAsset = null;
	        }
	      }

	      this._texture = value;

	      if (value) {
	        if (this._spriteAsset) {
	          this.spriteAsset = null;
	        }

	        this._renderable.setParameter('texture_emissiveMap', this._texture);

	        this._renderable.setParameter('texture_opacityMap', this._texture);

	        this._colorUniform[0] = this._color.r;
	        this._colorUniform[1] = this._color.g;
	        this._colorUniform[2] = this._color.b;

	        this._renderable.setParameter('material_emissive', this._colorUniform);

	        this._renderable.setParameter('material_opacity', this._color.a);

	        var newAspectRatio = this._texture.width / this._texture.height;

	        if (newAspectRatio !== this._targetAspectRatio) {
	          this._targetAspectRatio = newAspectRatio;

	          if (this._element.fitMode !== FITMODE_STRETCH) {
	            this.refreshMesh();
	          }
	        }
	      } else {
	        this._renderable.deleteParameter('texture_emissiveMap');

	        this._renderable.deleteParameter('texture_opacityMap');

	        this._targetAspectRatio = -1;

	        if (this._element.fitMode !== FITMODE_STRETCH) {
	          this.refreshMesh();
	        }
	      }
	    }
	  }, {
	    key: "textureAsset",
	    get: function get() {
	      return this._textureAsset;
	    },
	    set: function set(value) {
	      var assets = this._system.app.assets;
	      var _id = value;

	      if (value instanceof Asset) {
	        _id = value.id;
	      }

	      if (this._textureAsset !== _id) {
	        if (this._textureAsset) {
	          assets.off('add:' + this._textureAsset, this._onTextureAdded, this);

	          var _prev = assets.get(this._textureAsset);

	          if (_prev) {
	            _prev.off('load', this._onTextureLoad, this);

	            _prev.off('change', this._onTextureChange, this);

	            _prev.off('remove', this._onTextureRemove, this);
	          }
	        }

	        this._textureAsset = _id;

	        if (this._textureAsset) {
	          var asset = assets.get(this._textureAsset);

	          if (!asset) {
	            this.texture = null;
	            assets.on('add:' + this._textureAsset, this._onTextureAdded, this);
	          } else {
	            this._bindTextureAsset(asset);
	          }
	        } else {
	          this.texture = null;
	        }
	      }
	    }
	  }, {
	    key: "spriteAsset",
	    get: function get() {
	      return this._spriteAsset;
	    },
	    set: function set(value) {
	      var assets = this._system.app.assets;
	      var _id = value;

	      if (value instanceof Asset) {
	        _id = value.id;
	      }

	      if (this._spriteAsset !== _id) {
	        if (this._spriteAsset) {
	          assets.off('add:' + this._spriteAsset, this._onSpriteAssetAdded, this);

	          var _prev = assets.get(this._spriteAsset);

	          if (_prev) {
	            this._unbindSpriteAsset(_prev);
	          }
	        }

	        this._spriteAsset = _id;

	        if (this._spriteAsset) {
	          var asset = assets.get(this._spriteAsset);

	          if (!asset) {
	            this.sprite = null;
	            assets.on('add:' + this._spriteAsset, this._onSpriteAssetAdded, this);
	          } else {
	            this._bindSpriteAsset(asset);
	          }
	        } else {
	          this.sprite = null;
	        }
	      }

	      if (this._element) {
	        this._element.fire('set:spriteAsset', _id);
	      }
	    }
	  }, {
	    key: "sprite",
	    get: function get() {
	      return this._sprite;
	    },
	    set: function set(value) {
	      if (this._sprite === value) return;

	      if (this._sprite) {
	        this._unbindSprite(this._sprite);
	      }

	      if (this._spriteAsset) {
	        var spriteAsset = this._system.app.assets.get(this._spriteAsset);

	        if (spriteAsset && spriteAsset.resource !== value) {
	          this.spriteAsset = null;
	        }
	      }

	      this._sprite = value;

	      if (this._sprite) {
	        this._bindSprite(this._sprite);

	        if (this._textureAsset) {
	          this.textureAsset = null;
	        }
	      }

	      if (this._sprite && this._sprite.atlas && this._sprite.atlas.texture) {
	        this._renderable.setParameter('texture_emissiveMap', this._sprite.atlas.texture);

	        this._renderable.setParameter('texture_opacityMap', this._sprite.atlas.texture);
	      } else {
	        this._renderable.deleteParameter('texture_emissiveMap');

	        this._renderable.deleteParameter('texture_opacityMap');
	      }

	      if (this._sprite) {
	        this._spriteFrame = math.clamp(this._spriteFrame, 0, this._sprite.frameKeys.length - 1);
	      }

	      this._updateSprite();
	    }
	  }, {
	    key: "spriteFrame",
	    get: function get() {
	      return this._spriteFrame;
	    },
	    set: function set(value) {
	      var oldValue = this._spriteFrame;

	      if (this._sprite) {
	        this._spriteFrame = math.clamp(value, 0, this._sprite.frameKeys.length - 1);
	      } else {
	        this._spriteFrame = value;
	      }

	      if (this._spriteFrame !== oldValue) {
	        this._updateSprite();
	      }

	      if (this._element) {
	        this._element.fire('set:spriteFrame', value);
	      }
	    }
	  }, {
	    key: "mesh",
	    get: function get() {
	      return this._renderable.mesh;
	    },
	    set: function set(value) {
	      this._renderable.setMesh(value);

	      if (this._defaultMesh === value) {
	        this._renderable.setAabbFunc(null);
	      } else {
	        this._renderable.setAabbFunc(this._updateAabbFunc);
	      }
	    }
	  }, {
	    key: "mask",
	    get: function get() {
	      return this._mask;
	    },
	    set: function set(value) {
	      if (this._mask !== value) {
	        this._mask = value;

	        this._toggleMask();
	      }
	    }
	  }, {
	    key: "pixelsPerUnit",
	    get: function get() {
	      return this._pixelsPerUnit;
	    },
	    set: function set(value) {
	      if (this._pixelsPerUnit === value) return;
	      this._pixelsPerUnit = value;

	      if (this._sprite && (this._sprite.renderMode === SPRITE_RENDERMODE_SLICED || this._sprite.renderMode === SPRITE_RENDERMODE_TILED)) {
	        this._updateSprite();
	      }
	    }
	  }, {
	    key: "aabb",
	    get: function get() {
	      if (this._renderable.meshInstance) {
	        return this._renderable.meshInstance.aabb;
	      }

	      return null;
	    }
	  }]);

	  return ImageElement;
	}();

	var EOF_TOKEN = 0;
	var ERROR_TOKEN = 1;
	var TEXT_TOKEN = 2;
	var OPEN_BRACKET_TOKEN = 3;
	var CLOSE_BRACKET_TOKEN = 4;
	var EQUALS_TOKEN = 5;
	var STRING_TOKEN = 6;
	var IDENTIFIER_TOKEN = 7;
	var WHITESPACE_TOKEN = 8;
	var WHITESPACE_CHARS = ' \t\n\r\v\f';
	var IDENTIFIER_REGEX = /[A-Z|a-z|0-9|_|-|/]/;

	var Scanner = function () {
	  function Scanner(symbols) {
	    this._symbols = symbols;
	    this._index = 0;
	    this._last = 0;
	    this._cur = this._symbols.length > 0 ? this._symbols[0] : null;
	    this._buf = [];
	    this._mode = 'text';
	    this._error = null;
	  }

	  var _proto = Scanner.prototype;

	  _proto.read = function read() {
	    var token = this._read();

	    while (token === WHITESPACE_TOKEN) {
	      token = this._read();
	    }

	    if (token !== EOF_TOKEN && token !== ERROR_TOKEN) {
	      this._last = this._index;
	    }

	    return token;
	  };

	  _proto.buf = function buf() {
	    return this._buf;
	  };

	  _proto.last = function last() {
	    return this._last;
	  };

	  _proto.error = function error() {
	    return this._error;
	  };

	  _proto.debugPrint = function debugPrint() {
	    var tokenStrings = ['EOF', 'ERROR', 'TEXT', 'OPEN_BRACKET', 'CLOSE_BRACKET', 'EQUALS', 'STRING', 'IDENTIFIER', 'WHITESPACE'];
	    var token = this.read();
	    var result = '';

	    while (true) {
	      result += (result.length > 0 ? '\n' : '') + tokenStrings[token] + ' \'' + this.buf().join('') + '\'';

	      if (token === EOF_TOKEN || token === ERROR_TOKEN) {
	        break;
	      }

	      token = this.read();
	    }

	    return result;
	  };

	  _proto._read = function _read() {
	    this._buf = [];

	    if (this._eof()) {
	      return EOF_TOKEN;
	    }

	    return this._mode === 'text' ? this._text() : this._tag();
	  };

	  _proto._text = function _text() {
	    while (true) {
	      switch (this._cur) {
	        case null:
	          return this._buf.length > 0 ? TEXT_TOKEN : EOF_TOKEN;

	        case '[':
	          this._mode = 'tag';
	          return this._buf.length > 0 ? TEXT_TOKEN : this._tag();

	        case '\\':
	          this._next();

	          switch (this._cur) {
	            case '[':
	              this._store();

	              break;

	            default:
	              this._output('\\');

	              break;
	          }

	          break;

	        default:
	          this._store();

	          break;
	      }
	    }
	  };

	  _proto._tag = function _tag() {
	    switch (this._cur) {
	      case null:
	        this._error = 'unexpected end of input reading tag';
	        return ERROR_TOKEN;

	      case '[':
	        this._store();

	        return OPEN_BRACKET_TOKEN;

	      case ']':
	        this._store();

	        this._mode = 'text';
	        return CLOSE_BRACKET_TOKEN;

	      case '=':
	        this._store();

	        return EQUALS_TOKEN;

	      case ' ':
	      case '\t':
	      case '\n':
	      case '\r':
	      case '\v':
	      case '\f':
	        return this._whitespace();

	      case '"':
	        return this._string();

	      default:
	        if (!this._isIdentifierSymbol(this._cur)) {
	          this._error = 'unrecognized character';
	          return ERROR_TOKEN;
	        }

	        return this._identifier();
	    }
	  };

	  _proto._whitespace = function _whitespace() {
	    this._store();

	    while (WHITESPACE_CHARS.indexOf(this._cur) !== -1) {
	      this._store();
	    }

	    return WHITESPACE_TOKEN;
	  };

	  _proto._string = function _string() {
	    this._next();

	    while (true) {
	      switch (this._cur) {
	        case null:
	          this._error = 'unexpected end of input reading string';
	          return ERROR_TOKEN;

	        case '"':
	          this._next();

	          return STRING_TOKEN;

	        default:
	          this._store();

	          break;
	      }
	    }
	  };

	  _proto._identifier = function _identifier() {
	    this._store();

	    while (this._cur !== null && this._isIdentifierSymbol(this._cur)) {
	      this._store();
	    }

	    return IDENTIFIER_TOKEN;
	  };

	  _proto._isIdentifierSymbol = function _isIdentifierSymbol(s) {
	    return s.length === 1 && s.match(IDENTIFIER_REGEX) !== null;
	  };

	  _proto._eof = function _eof() {
	    return this._cur === null;
	  };

	  _proto._next = function _next() {
	    if (!this._eof()) {
	      this._index++;
	      this._cur = this._index < this._symbols.length ? this._symbols[this._index] : null;
	    }

	    return this._cur;
	  };

	  _proto._store = function _store() {
	    this._buf.push(this._cur);

	    return this._next();
	  };

	  _proto._output = function _output(c) {
	    this._buf.push(c);
	  };

	  return Scanner;
	}();

	var Parser = function () {
	  function Parser(symbols) {
	    this._scanner = new Scanner(symbols);
	    this._error = null;
	  }

	  var _proto2 = Parser.prototype;

	  _proto2.parse = function parse(symbols, tags) {
	    while (true) {
	      var token = this._scanner.read();

	      switch (token) {
	        case EOF_TOKEN:
	          return true;

	        case ERROR_TOKEN:
	          return false;

	        case TEXT_TOKEN:
	          Array.prototype.push.apply(symbols, this._scanner.buf());
	          break;

	        case OPEN_BRACKET_TOKEN:
	          if (!this._parseTag(symbols, tags)) {
	            return false;
	          }

	          break;

	        default:
	          return false;
	      }
	    }
	  };

	  _proto2.error = function error() {
	    return 'Error evaluating markup at #' + this._scanner.last().toString() + ' (' + (this._scanner.error() || this._error) + ')';
	  };

	  _proto2._parseTag = function _parseTag(symbols, tags) {
	    var token = this._scanner.read();

	    if (token !== IDENTIFIER_TOKEN) {
	      this._error = 'expected identifier';
	      return false;
	    }

	    var name = this._scanner.buf().join('');

	    if (name[0] === '/') {
	      for (var index = tags.length - 1; index >= 0; --index) {
	        if (name === '/' + tags[index].name && tags[index].end === null) {
	          tags[index].end = symbols.length;
	          token = this._scanner.read();

	          if (token !== CLOSE_BRACKET_TOKEN) {
	            this._error = 'expected close bracket';
	            return false;
	          }

	          return true;
	        }
	      }

	      this._error = 'failed to find matching tag';
	      return false;
	    }

	    var tag = {
	      name: name,
	      value: null,
	      attributes: {},
	      start: symbols.length,
	      end: null
	    };
	    token = this._scanner.read();

	    if (token === EQUALS_TOKEN) {
	      token = this._scanner.read();

	      if (token !== STRING_TOKEN) {
	        this._error = 'expected string';
	        return false;
	      }

	      tag.value = this._scanner.buf().join('');
	      token = this._scanner.read();
	    }

	    while (true) {
	      switch (token) {
	        case CLOSE_BRACKET_TOKEN:
	          tags.push(tag);
	          return true;

	        case IDENTIFIER_TOKEN:
	          {
	            var identifier = this._scanner.buf().join('');

	            token = this._scanner.read();

	            if (token !== EQUALS_TOKEN) {
	              this._error = 'expected equals';
	              return false;
	            }

	            token = this._scanner.read();

	            if (token !== STRING_TOKEN) {
	              this._error = 'expected string';
	              return false;
	            }

	            var value = this._scanner.buf().join('');

	            tag.attributes[identifier] = value;
	            break;
	          }

	        default:
	          this._error = 'expected close bracket or identifier';
	          return false;
	      }

	      token = this._scanner.read();
	    }
	  };

	  return Parser;
	}();

	function merge(target, source) {
	  for (var key in source) {
	    if (!source.hasOwnProperty(key)) {
	      continue;
	    }

	    var value = source[key];

	    if (value instanceof Object) {
	      if (!target.hasOwnProperty(key)) {
	        target[key] = {};
	      }

	      merge(target[key], source[key]);
	    } else {
	      target[key] = value;
	    }
	  }
	}

	function combineTags(tags) {
	  if (tags.length === 0) {
	    return null;
	  }

	  var result = {};

	  for (var index = 0; index < tags.length; ++index) {
	    var tag = tags[index];
	    var tmp = {};
	    tmp[tag.name] = {
	      value: tag.value,
	      attributes: tag.attributes
	    };
	    merge(result, tmp);
	  }

	  return result;
	}

	function resolveMarkupTags(tags, numSymbols) {
	  if (tags.length === 0) {
	    return null;
	  }

	  var edges = {};

	  for (var index = 0; index < tags.length; ++index) {
	    var tag = tags[index];

	    if (!edges.hasOwnProperty(tag.start)) {
	      edges[tag.start] = {
	        open: [tag],
	        close: null
	      };
	    } else {
	      if (edges[tag.start].open === null) {
	        edges[tag.start].open = [tag];
	      } else {
	        edges[tag.start].open.push(tag);
	      }
	    }

	    if (!edges.hasOwnProperty(tag.end)) {
	      edges[tag.end] = {
	        open: null,
	        close: [tag]
	      };
	    } else {
	      if (edges[tag.end].close === null) {
	        edges[tag.end].close = [tag];
	      } else {
	        edges[tag.end].close.push(tag);
	      }
	    }
	  }

	  var tagStack = [];

	  function removeTags(tags) {
	    tagStack = tagStack.filter(function (tag) {
	      return tags.find(function (t) {
	        return t === tag;
	      }) === undefined;
	    });
	  }

	  function addTags(tags) {
	    for (var _index = 0; _index < tags.length; ++_index) {
	      tagStack.push(tags[_index]);
	    }
	  }

	  var edgeKeys = Object.keys(edges).sort(function (a, b) {
	    return a - b;
	  });
	  var resolvedTags = [];

	  for (var _index2 = 0; _index2 < edgeKeys.length; ++_index2) {
	    var edge = edges[edgeKeys[_index2]];

	    if (edge.close !== null) {
	      removeTags(edge.close);
	    }

	    if (edge.open !== null) {
	      addTags(edge.open);
	    }

	    resolvedTags.push({
	      start: edgeKeys[_index2],
	      tags: combineTags(tagStack)
	    });
	  }

	  var result = [];
	  var prevTag = null;

	  for (var _index3 = 0; _index3 < resolvedTags.length; ++_index3) {
	    var resolvedTag = resolvedTags[_index3];

	    while (result.length < resolvedTag.start) {
	      result.push(prevTag ? prevTag.tags : null);
	    }

	    prevTag = resolvedTag;
	  }

	  while (result.length < numSymbols) {
	    result.push(null);
	  }

	  return result;
	}

	function evaluateMarkup(symbols) {
	  var parser = new Parser(symbols);
	  var stripped_symbols = [];
	  var tags = [];

	  if (!parser.parse(stripped_symbols, tags)) {
	    console.warn(parser.error());
	    return {
	      symbols: symbols,
	      tags: null
	    };
	  }

	  var invalidTag = tags.find(function (t) {
	    return t.end === null;
	  });

	  if (invalidTag) {
	    console.warn("Markup error: found unclosed tag='" + invalidTag.name + "'");
	    return {
	      symbols: symbols,
	      tags: null
	    };
	  }

	  var resolved_tags = resolveMarkupTags(tags, stripped_symbols.length);
	  return {
	    symbols: stripped_symbols,
	    tags: resolved_tags
	  };
	}

	var Markup = function () {
	  function Markup() {}

	  Markup.evaluate = function evaluate(symbols) {
	    return evaluateMarkup(symbols);
	  };

	  return Markup;
	}();

	var MeshInfo = function MeshInfo() {
	  this.count = 0;
	  this.quad = 0;
	  this.lines = {};
	  this.positions = [];
	  this.normals = [];
	  this.uvs = [];
	  this.colors = [];
	  this.indices = [];
	  this.outlines = [];
	  this.shadows = [];
	  this.meshInstance = null;
	};

	function createTextMesh(device, meshInfo) {
	  var mesh = new Mesh(device);
	  mesh.setPositions(meshInfo.positions);
	  mesh.setNormals(meshInfo.normals);
	  mesh.setColors32(meshInfo.colors);
	  mesh.setUvs(0, meshInfo.uvs);
	  mesh.setIndices(meshInfo.indices);
	  mesh.setVertexStream(SEMANTIC_ATTR8, meshInfo.outlines, 3, undefined, TYPE_FLOAT32, false);
	  mesh.setVertexStream(SEMANTIC_ATTR9, meshInfo.shadows, 3, undefined, TYPE_FLOAT32, false);
	  mesh.update();
	  return mesh;
	}

	var LINE_BREAK_CHAR = /^[\r\n]$/;
	var WHITESPACE_CHAR = /^[ \t]$/;
	var WORD_BOUNDARY_CHAR = /^[ \t\-]|[\u200b]$/;
	var ALPHANUMERIC_CHAR = /^[a-z0-9]$/i;
	var CJK_CHAR = /^[\u1100-\u11ff]|[\u3000-\u9fff]|[\ua960-\ua97f]|[\uac00-\ud7ff]$/;
	var NO_LINE_BREAK_CJK_CHAR = /^[〕〉》」』】〙〗〟ヽヾーァィゥェォッャュョヮヵヶぁぃぅぇぉっゃゅょゎゕゖㇰㇱㇲㇳㇴㇵㇶㇷㇸㇹㇺㇻㇼㇽㇾㇿ々〻]$/;
	var CONTROL_CHARS = ["\u200B", "\u061C", "\u200E", "\u200F", "\u202A", "\u202B", "\u202C", "\u202D", "\u202E", "\u2066", "\u2067", "\u2068", "\u2069"];
	var CONTROL_GLYPH_DATA = {
	  width: 0,
	  height: 0,
	  xadvance: 0,
	  xoffset: 0,
	  yoffset: 0
	};
	var colorTmp = new Color();
	var vec2Tmp = new Vec2();

	var TextElement = function () {
	  function TextElement(element) {
	    this._element = element;
	    this._system = element.system;
	    this._entity = element.entity;
	    this._text = '';
	    this._symbols = [];
	    this._colorPalette = [];
	    this._outlinePalette = [];
	    this._shadowPalette = [];
	    this._symbolColors = null;
	    this._symbolOutlineParams = null;
	    this._symbolShadowParams = null;
	    this._i18nKey = null;
	    this._fontAsset = new LocalizedAsset(this._system.app);
	    this._fontAsset.disableLocalization = true;

	    this._fontAsset.on('load', this._onFontLoad, this);

	    this._fontAsset.on('change', this._onFontChange, this);

	    this._fontAsset.on('remove', this._onFontRemove, this);

	    this._font = null;
	    this._color = new Color(1, 1, 1, 1);
	    this._colorUniform = new Float32Array(3);
	    this._spacing = 1;
	    this._fontSize = 32;
	    this._fontMinY = 0;
	    this._fontMaxY = 0;
	    this._originalFontSize = 32;
	    this._maxFontSize = 32;
	    this._minFontSize = 8;
	    this._autoFitWidth = false;
	    this._autoFitHeight = false;
	    this._maxLines = -1;
	    this._lineHeight = 32;
	    this._scaledLineHeight = 32;
	    this._wrapLines = false;
	    this._drawOrder = 0;
	    this._alignment = new Vec2(0.5, 0.5);
	    this._autoWidth = true;
	    this._autoHeight = true;
	    this.width = 0;
	    this.height = 0;
	    this._node = new GraphNode();
	    this._model = new Model();
	    this._model.graph = this._node;

	    this._entity.addChild(this._node);

	    this._meshInfo = [];
	    this._material = null;
	    this._aabbDirty = true;
	    this._aabb = new BoundingBox();
	    this._noResize = false;
	    this._currentMaterialType = null;
	    this._maskedMaterialSrc = null;
	    this._rtlReorder = false;
	    this._unicodeConverter = false;
	    this._rtl = false;
	    this._outlineColor = new Color(0, 0, 0, 1);
	    this._outlineColorUniform = new Float32Array(4);
	    this._outlineThicknessScale = 0.2;
	    this._outlineThickness = 0.0;
	    this._shadowColor = new Color(0, 0, 0, 1);
	    this._shadowColorUniform = new Float32Array(4);
	    this._shadowOffsetScale = 0.005;
	    this._shadowOffset = new Vec2(0, 0);
	    this._shadowOffsetUniform = new Float32Array(2);
	    this._enableMarkup = false;

	    this._onScreenChange(this._element.screen);

	    element.on('resize', this._onParentResize, this);
	    element.on('set:screen', this._onScreenChange, this);
	    element.on('screen:set:screenspace', this._onScreenSpaceChange, this);
	    element.on('set:draworder', this._onDrawOrderChange, this);
	    element.on('set:pivot', this._onPivotChange, this);

	    this._system.app.i18n.on('set:locale', this._onLocaleSet, this);

	    this._system.app.i18n.on('data:add', this._onLocalizationData, this);

	    this._system.app.i18n.on('data:remove', this._onLocalizationData, this);

	    this._rangeStart = 0;
	    this._rangeEnd = 0;
	  }

	  var _proto = TextElement.prototype;

	  _proto.destroy = function destroy() {
	    this._setMaterial(null);

	    if (this._model) {
	      this._element.removeModelFromLayers(this._model);

	      this._model.destroy();

	      this._model = null;
	    }

	    this._fontAsset.destroy();

	    this.font = null;

	    this._element.off('resize', this._onParentResize, this);

	    this._element.off('set:screen', this._onScreenChange, this);

	    this._element.off('screen:set:screenspace', this._onScreenSpaceChange, this);

	    this._element.off('set:draworder', this._onDrawOrderChange, this);

	    this._element.off('set:pivot', this._onPivotChange, this);

	    this._system.app.i18n.off('set:locale', this._onLocaleSet, this);

	    this._system.app.i18n.off('data:add', this._onLocalizationData, this);

	    this._system.app.i18n.off('data:remove', this._onLocalizationData, this);
	  };

	  _proto._onParentResize = function _onParentResize(width, height) {
	    if (this._noResize) return;
	    if (this._font) this._updateText();
	  };

	  _proto._onScreenChange = function _onScreenChange(screen) {
	    if (screen) {
	      this._updateMaterial(screen.screen.screenSpace);
	    } else {
	      this._updateMaterial(false);
	    }
	  };

	  _proto._onScreenSpaceChange = function _onScreenSpaceChange(value) {
	    this._updateMaterial(value);
	  };

	  _proto._onDrawOrderChange = function _onDrawOrderChange(order) {
	    this._drawOrder = order;

	    if (this._model) {
	      for (var i = 0, len = this._model.meshInstances.length; i < len; i++) {
	        this._model.meshInstances[i].drawOrder = order;
	      }
	    }
	  };

	  _proto._onPivotChange = function _onPivotChange(pivot) {
	    if (this._font) this._updateText();
	  };

	  _proto._onLocaleSet = function _onLocaleSet(locale) {
	    if (!this._i18nKey) return;

	    if (this.fontAsset) {
	      var asset = this._system.app.assets.get(this.fontAsset);

	      if (!asset || !asset.resource || asset.resource !== this._font) {
	        this.font = null;
	      }
	    }

	    this._resetLocalizedText();
	  };

	  _proto._onLocalizationData = function _onLocalizationData(locale, messages) {
	    if (this._i18nKey && messages[this._i18nKey]) {
	      this._resetLocalizedText();
	    }
	  };

	  _proto._resetLocalizedText = function _resetLocalizedText() {
	    this._setText(this._system.app.i18n.getText(this._i18nKey));
	  };

	  _proto._setText = function _setText(text) {
	    if (this.unicodeConverter) {
	      var unicodeConverterFunc = this._system.getUnicodeConverter();

	      if (unicodeConverterFunc) {
	        text = unicodeConverterFunc(text);
	      } else {
	        console.warn('Element created with unicodeConverter option but no unicodeConverter function registered');
	      }
	    }

	    if (this._text !== text) {
	      if (this._font) {
	        this._updateText(text);
	      }

	      this._text = text;
	    }
	  };

	  _proto._updateText = function _updateText(text) {
	    var tags;
	    if (text === undefined) text = this._text;
	    this._symbols = string.getSymbols(text.normalize ? text.normalize('NFC') : text);

	    if (this._symbols.length === 0) {
	      this._symbols = [' '];
	    }

	    if (this._enableMarkup) {
	      var results = Markup.evaluate(this._symbols);
	      this._symbols = results.symbols;
	      tags = results.tags || [];
	    }

	    if (this._rtlReorder) {
	      var rtlReorderFunc = this._system.app.systems.element.getRtlReorder();

	      if (rtlReorderFunc) {
	        var _results = rtlReorderFunc(this._symbols);

	        this._rtl = _results.rtl;
	        this._symbols = _results.mapping.map(function (v) {
	          return this._symbols[v];
	        }, this);

	        if (tags) {
	          tags = _results.mapping.map(function (v) {
	            return tags[v];
	          });
	        }
	      } else {
	        console.warn('Element created with rtlReorder option but no rtlReorder function registered');
	      }
	    } else {
	      this._rtl = false;
	    }

	    var getColorThicknessHash = function getColorThicknessHash(color, thickness) {
	      return color.toString(true).toLowerCase() + ":" + thickness.toFixed(2);
	    };

	    var getColorOffsetHash = function getColorOffsetHash(color, offset) {
	      return color.toString(true).toLowerCase() + ":" + offset.x.toFixed(2) + ":" + offset.y.toFixed(2);
	    };

	    if (tags) {
	      var paletteMap = {};
	      var outlinePaletteMap = {};
	      var shadowPaletteMap = {};
	      this._colorPalette = [Math.round(this._color.r * 255), Math.round(this._color.g * 255), Math.round(this._color.b * 255)];
	      this._outlinePalette = [Math.round(this._outlineColor.r * 255), Math.round(this._outlineColor.g * 255), Math.round(this._outlineColor.b * 255), Math.round(this._outlineColor.a * 255), Math.round(this._outlineThickness * 255)];
	      this._shadowPalette = [Math.round(this._shadowColor.r * 255), Math.round(this._shadowColor.g * 255), Math.round(this._shadowColor.b * 255), Math.round(this._shadowColor.a * 255), Math.round(this._shadowOffset.x * 127), Math.round(this._shadowOffset.y * 127)];
	      this._symbolColors = [];
	      this._symbolOutlineParams = [];
	      this._symbolShadowParams = [];
	      paletteMap[this._color.toString(false).toLowerCase()] = 0;
	      outlinePaletteMap[getColorThicknessHash(this._outlineColor, this._outlineThickness)] = 0;
	      shadowPaletteMap[getColorOffsetHash(this._shadowColor, this._shadowOffset)] = 0;

	      for (var i = 0, len = this._symbols.length; i < len; ++i) {
	        var tag = tags[i];
	        var color = 0;

	        if (tag && tag.color && tag.color.value) {
	          var c = tag.color.value;

	          if (c.length === 7 && c[0] === '#') {
	            var hex = c.substring(1).toLowerCase();

	            if (paletteMap.hasOwnProperty(hex)) {
	              color = paletteMap[hex];
	            } else {
	              if (/^([0-9a-f]{2}){3}$/.test(hex)) {
	                color = this._colorPalette.length / 3;
	                paletteMap[hex] = color;

	                this._colorPalette.push(parseInt(hex.substring(0, 2), 16));

	                this._colorPalette.push(parseInt(hex.substring(2, 4), 16));

	                this._colorPalette.push(parseInt(hex.substring(4, 6), 16));
	              }
	            }
	          }
	        }

	        this._symbolColors.push(color);

	        var outline = 0;

	        if (tag && tag.outline && (tag.outline.attributes.color || tag.outline.attributes.thickness)) {
	          var _color = tag.outline.attributes.color ? colorTmp.fromString(tag.outline.attributes.color) : this._outlineColor;

	          var thickness = Number(tag.outline.attributes.thickness);

	          if (Number.isNaN(_color.r) || Number.isNaN(_color.g) || Number.isNaN(_color.b) || Number.isNaN(_color.a)) {
	            _color = this._outlineColor;
	          }

	          if (Number.isNaN(thickness)) {
	            thickness = this._outlineThickness;
	          }

	          var outlineHash = getColorThicknessHash(_color, thickness);

	          if (outlinePaletteMap.hasOwnProperty(outlineHash)) {
	            outline = outlinePaletteMap[outlineHash];
	          } else {
	            outline = this._outlinePalette.length / 5;
	            outlinePaletteMap[outlineHash] = outline;

	            this._outlinePalette.push(Math.round(_color.r * 255), Math.round(_color.g * 255), Math.round(_color.b * 255), Math.round(_color.a * 255), Math.round(thickness * 255));
	          }
	        }

	        this._symbolOutlineParams.push(outline);

	        var shadow = 0;

	        if (tag && tag.shadow && (tag.shadow.attributes.color || tag.shadow.attributes.offset || tag.shadow.attributes.offsetX || tag.shadow.attributes.offsetY)) {
	          var _color2 = tag.shadow.attributes.color ? colorTmp.fromString(tag.shadow.attributes.color) : this._shadowColor;

	          var off = Number(tag.shadow.attributes.offset);
	          var offX = Number(tag.shadow.attributes.offsetX);
	          var offY = Number(tag.shadow.attributes.offsetY);

	          if (Number.isNaN(_color2.r) || Number.isNaN(_color2.g) || Number.isNaN(_color2.b) || Number.isNaN(_color2.a)) {
	            _color2 = this._shadowColor;
	          }

	          var offset = vec2Tmp.set(!Number.isNaN(offX) ? offX : !Number.isNaN(off) ? off : this._shadowOffset.x, !Number.isNaN(offY) ? offY : !Number.isNaN(off) ? off : this._shadowOffset.y);
	          var shadowHash = getColorOffsetHash(_color2, offset);

	          if (shadowPaletteMap.hasOwnProperty(shadowHash)) {
	            shadow = shadowPaletteMap[shadowHash];
	          } else {
	            shadow = this._shadowPalette.length / 6;
	            shadowPaletteMap[shadowHash] = shadow;

	            this._shadowPalette.push(Math.round(_color2.r * 255), Math.round(_color2.g * 255), Math.round(_color2.b * 255), Math.round(_color2.a * 255), Math.round(offset.x * 127), Math.round(offset.y * 127));
	          }
	        }

	        this._symbolShadowParams.push(shadow);
	      }
	    } else {
	      this._colorPalette = [];
	      this._symbolColors = null;
	      this._symbolOutlineParams = null;
	      this._symbolShadowParams = null;
	    }

	    this._updateMaterialEmissive();

	    this._updateMaterialOutline();

	    this._updateMaterialShadow();

	    var charactersPerTexture = this._calculateCharsPerTexture();

	    var removedModel = false;
	    var element = this._element;

	    var screenSpace = element._isScreenSpace();

	    var screenCulled = element._isScreenCulled();

	    var visibleFn = function visibleFn(camera) {
	      return element.isVisibleForCamera(camera);
	    };

	    for (var _i = 0, _len = this._meshInfo.length; _i < _len; _i++) {
	      var l = charactersPerTexture[_i] || 0;
	      var meshInfo = this._meshInfo[_i];

	      if (meshInfo.count !== l) {
	        if (!removedModel) {
	          element.removeModelFromLayers(this._model);
	          removedModel = true;
	        }

	        meshInfo.count = l;
	        meshInfo.positions.length = meshInfo.normals.length = l * 3 * 4;
	        meshInfo.indices.length = l * 3 * 2;
	        meshInfo.uvs.length = l * 2 * 4;
	        meshInfo.colors.length = l * 4 * 4;
	        meshInfo.outlines.length = l * 4 * 3;
	        meshInfo.shadows.length = l * 4 * 3;

	        if (meshInfo.meshInstance) {
	          this._removeMeshInstance(meshInfo.meshInstance);
	        }

	        if (l === 0) {
	          meshInfo.meshInstance = null;
	          continue;
	        }

	        for (var v = 0; v < l; v++) {
	          meshInfo.indices[v * 3 * 2 + 0] = v * 4;
	          meshInfo.indices[v * 3 * 2 + 1] = v * 4 + 1;
	          meshInfo.indices[v * 3 * 2 + 2] = v * 4 + 3;
	          meshInfo.indices[v * 3 * 2 + 3] = v * 4 + 2;
	          meshInfo.indices[v * 3 * 2 + 4] = v * 4 + 3;
	          meshInfo.indices[v * 3 * 2 + 5] = v * 4 + 1;
	          meshInfo.normals[v * 4 * 3 + 0] = 0;
	          meshInfo.normals[v * 4 * 3 + 1] = 0;
	          meshInfo.normals[v * 4 * 3 + 2] = -1;
	          meshInfo.normals[v * 4 * 3 + 3] = 0;
	          meshInfo.normals[v * 4 * 3 + 4] = 0;
	          meshInfo.normals[v * 4 * 3 + 5] = -1;
	          meshInfo.normals[v * 4 * 3 + 6] = 0;
	          meshInfo.normals[v * 4 * 3 + 7] = 0;
	          meshInfo.normals[v * 4 * 3 + 8] = -1;
	          meshInfo.normals[v * 4 * 3 + 9] = 0;
	          meshInfo.normals[v * 4 * 3 + 10] = 0;
	          meshInfo.normals[v * 4 * 3 + 11] = -1;
	        }

	        var mesh = createTextMesh(this._system.app.graphicsDevice, meshInfo);
	        var mi = new MeshInstance(mesh, this._material, this._node);
	        mi.name = 'Text Element: ' + this._entity.name;
	        mi.castShadow = false;
	        mi.receiveShadow = false;
	        mi.cull = !screenSpace;
	        mi.screenSpace = screenSpace;
	        mi.drawOrder = this._drawOrder;

	        if (screenCulled) {
	          mi.cull = true;
	          mi.isVisibleFunc = visibleFn;
	        }

	        this._setTextureParams(mi, this._font.textures[_i]);

	        mi.setParameter('material_emissive', this._colorUniform);
	        mi.setParameter('material_opacity', this._color.a);
	        mi.setParameter('font_sdfIntensity', this._font.intensity);
	        mi.setParameter('font_pxrange', this._getPxRange(this._font));
	        mi.setParameter('font_textureWidth', this._font.data.info.maps[_i].width);
	        mi.setParameter('outline_color', this._outlineColorUniform);
	        mi.setParameter('outline_thickness', this._outlineThicknessScale * this._outlineThickness);
	        mi.setParameter('shadow_color', this._shadowColorUniform);

	        if (this._symbolShadowParams) {
	          this._shadowOffsetUniform[0] = 0;
	          this._shadowOffsetUniform[1] = 0;
	        } else {
	          var ratio = -this._font.data.info.maps[_i].width / this._font.data.info.maps[_i].height;
	          this._shadowOffsetUniform[0] = this._shadowOffsetScale * this._shadowOffset.x;
	          this._shadowOffsetUniform[1] = ratio * this._shadowOffsetScale * this._shadowOffset.y;
	        }

	        mi.setParameter('shadow_offset', this._shadowOffsetUniform);
	        meshInfo.meshInstance = mi;

	        this._model.meshInstances.push(mi);
	      }
	    }

	    if (this._element.maskedBy) {
	      this._element._setMaskedBy(this._element.maskedBy);
	    }

	    if (removedModel && this._element.enabled && this._entity.enabled) {
	      this._element.addModelToLayers(this._model);
	    }

	    this._updateMeshes();

	    this._rangeStart = 0;
	    this._rangeEnd = this._symbols.length;

	    this._updateRenderRange();
	  };

	  _proto._removeMeshInstance = function _removeMeshInstance(meshInstance) {
	    meshInstance.destroy();

	    var idx = this._model.meshInstances.indexOf(meshInstance);

	    if (idx !== -1) this._model.meshInstances.splice(idx, 1);
	  };

	  _proto._setMaterial = function _setMaterial(material) {
	    this._material = material;

	    if (this._model) {
	      for (var i = 0, len = this._model.meshInstances.length; i < len; i++) {
	        var mi = this._model.meshInstances[i];
	        mi.material = material;
	      }
	    }
	  };

	  _proto._updateMaterial = function _updateMaterial(screenSpace) {
	    var element = this._element;

	    var screenCulled = element._isScreenCulled();

	    var visibleFn = function visibleFn(camera) {
	      return element.isVisibleForCamera(camera);
	    };

	    var msdf = this._font && this._font.type === FONT_MSDF;
	    this._material = this._system.getTextElementMaterial(screenSpace, msdf, this._enableMarkup);

	    if (this._model) {
	      for (var i = 0, len = this._model.meshInstances.length; i < len; i++) {
	        var mi = this._model.meshInstances[i];
	        mi.cull = !screenSpace;
	        mi.material = this._material;
	        mi.screenSpace = screenSpace;

	        if (screenCulled) {
	          mi.cull = true;
	          mi.isVisibleFunc = visibleFn;
	        } else {
	          mi.isVisibleFunc = null;
	        }
	      }
	    }
	  };

	  _proto._updateMaterialEmissive = function _updateMaterialEmissive() {
	    if (this._symbolColors) {
	      this._colorUniform[0] = 1;
	      this._colorUniform[1] = 1;
	      this._colorUniform[2] = 1;
	    } else {
	      this._colorUniform[0] = this._color.r;
	      this._colorUniform[1] = this._color.g;
	      this._colorUniform[2] = this._color.b;
	    }
	  };

	  _proto._updateMaterialOutline = function _updateMaterialOutline() {
	    if (this._symbolOutlineParams) {
	      this._outlineColorUniform[0] = 0;
	      this._outlineColorUniform[1] = 0;
	      this._outlineColorUniform[2] = 0;
	      this._outlineColorUniform[3] = 1;
	    } else {
	      this._outlineColorUniform[0] = this._outlineColor.r;
	      this._outlineColorUniform[1] = this._outlineColor.g;
	      this._outlineColorUniform[2] = this._outlineColor.b;
	      this._outlineColorUniform[3] = this._outlineColor.a;
	    }
	  };

	  _proto._updateMaterialShadow = function _updateMaterialShadow() {
	    if (this._symbolOutlineParams) {
	      this._shadowColorUniform[0] = 0;
	      this._shadowColorUniform[1] = 0;
	      this._shadowColorUniform[2] = 0;
	      this._shadowColorUniform[3] = 0;
	    } else {
	      this._shadowColorUniform[0] = this._shadowColor.r;
	      this._shadowColorUniform[1] = this._shadowColor.g;
	      this._shadowColorUniform[2] = this._shadowColor.b;
	      this._shadowColorUniform[3] = this._shadowColor.a;
	    }
	  };

	  _proto._isWordBoundary = function _isWordBoundary(char) {
	    return WORD_BOUNDARY_CHAR.test(char);
	  };

	  _proto._isValidNextChar = function _isValidNextChar(nextchar) {
	    return nextchar !== null && !NO_LINE_BREAK_CJK_CHAR.test(nextchar);
	  };

	  _proto._isNextCJKBoundary = function _isNextCJKBoundary(char, nextchar) {
	    return CJK_CHAR.test(char) && (WORD_BOUNDARY_CHAR.test(nextchar) || ALPHANUMERIC_CHAR.test(nextchar));
	  };

	  _proto._isNextCJKWholeWord = function _isNextCJKWholeWord(nextchar) {
	    return CJK_CHAR.test(nextchar);
	  };

	  _proto._updateMeshes = function _updateMeshes() {
	    var json = this._font.data;
	    var self = this;
	    var minFont = Math.min(this._minFontSize, this._maxFontSize);
	    var maxFont = this._maxFontSize;

	    var autoFit = this._shouldAutoFit();

	    if (autoFit) {
	      this._fontSize = this._maxFontSize;
	    }

	    var MAGIC = 32;
	    var l = this._symbols.length;
	    var _x = 0;
	    var _y = 0;
	    var _z = 0;
	    var _xMinusTrailingWhitespace = 0;
	    var lines = 1;
	    var wordStartX = 0;
	    var wordStartIndex = 0;
	    var lineStartIndex = 0;
	    var numWordsThisLine = 0;
	    var numCharsThisLine = 0;
	    var numBreaksThisLine = 0;
	    var splitHorizontalAnchors = Math.abs(this._element.anchor.x - this._element.anchor.z) >= 0.0001;
	    var maxLineWidth = this._element.calculatedWidth;

	    if (this.autoWidth && !splitHorizontalAnchors || !this._wrapLines) {
	      maxLineWidth = Number.POSITIVE_INFINITY;
	    }

	    var fontMinY = 0;
	    var fontMaxY = 0;
	    var char, data, quad, nextchar;

	    function breakLine(symbols, lineBreakIndex, lineBreakX) {
	      self._lineWidths.push(Math.abs(lineBreakX));

	      var sliceStart = lineStartIndex > lineBreakIndex ? lineBreakIndex + 1 : lineStartIndex;
	      var sliceEnd = lineStartIndex > lineBreakIndex ? lineStartIndex + 1 : lineBreakIndex;
	      var chars = symbols.slice(sliceStart, sliceEnd);

	      if (numBreaksThisLine) {
	        var i = chars.length;

	        while (i-- && numBreaksThisLine > 0) {
	          if (LINE_BREAK_CHAR.test(chars[i])) {
	            chars.splice(i, 1);
	            numBreaksThisLine--;
	          }
	        }
	      }

	      self._lineContents.push(chars.join(''));

	      _x = 0;
	      _y -= self._scaledLineHeight;
	      lines++;
	      numWordsThisLine = 0;
	      numCharsThisLine = 0;
	      numBreaksThisLine = 0;
	      wordStartX = 0;
	      lineStartIndex = lineBreakIndex;
	    }

	    var retryUpdateMeshes = true;

	    while (retryUpdateMeshes) {
	      retryUpdateMeshes = false;

	      if (autoFit) {
	        this._scaledLineHeight = this._lineHeight * this._fontSize / (this._maxFontSize || 0.0001);
	      } else {
	        this._scaledLineHeight = this._lineHeight;
	      }

	      this.width = 0;
	      this.height = 0;
	      this._lineWidths = [];
	      this._lineContents = [];
	      _x = 0;
	      _y = 0;
	      _z = 0;
	      _xMinusTrailingWhitespace = 0;
	      lines = 1;
	      wordStartX = 0;
	      wordStartIndex = 0;
	      lineStartIndex = 0;
	      numWordsThisLine = 0;
	      numCharsThisLine = 0;
	      numBreaksThisLine = 0;
	      var scale = this._fontSize / MAGIC;
	      fontMinY = this._fontMinY * scale;
	      fontMaxY = this._fontMaxY * scale;

	      for (var i = 0; i < this._meshInfo.length; i++) {
	        this._meshInfo[i].quad = 0;
	        this._meshInfo[i].lines = {};
	      }

	      var color_r = 255;
	      var color_g = 255;
	      var color_b = 255;
	      var outline_color_rg = 255 + 255 * 256;
	      var outline_color_ba = 255 + 255 * 256;
	      var outline_thickness = 0;
	      var shadow_color_rg = 255 + 255 * 256;
	      var shadow_color_ba = 255 + 255 * 256;
	      var shadow_offset_xy = 127 + 127 * 256;

	      for (var _i2 = 0; _i2 < l; _i2++) {
	        char = this._symbols[_i2];
	        nextchar = _i2 + 1 >= l ? null : this._symbols[_i2 + 1];
	        var isLineBreak = LINE_BREAK_CHAR.test(char);

	        if (isLineBreak) {
	          numBreaksThisLine++;

	          if (!this._wrapLines || this._maxLines < 0 || lines < this._maxLines) {
	            breakLine(this._symbols, _i2, _xMinusTrailingWhitespace);
	            wordStartIndex = _i2 + 1;
	            lineStartIndex = _i2 + 1;
	          }

	          continue;
	        }

	        var x = 0;
	        var y = 0;
	        var advance = 0;
	        var quadsize = 1;
	        var dataScale = void 0,
	            size = void 0;
	        data = json.chars[char];

	        if (!data) {
	          if (CONTROL_CHARS.indexOf(char) !== -1) {
	            data = CONTROL_GLYPH_DATA;
	          } else {
	            if (json.chars[' ']) {
	              data = json.chars[' '];
	            } else {
	              for (var key in json.chars) {
	                data = json.chars[key];
	                break;
	              }
	            }
	          }
	        }

	        if (data) {
	          var kerning = 0;

	          if (numCharsThisLine > 0) {
	            var kernTable = this._font.data.kerning;

	            if (kernTable) {
	              var kernLeft = kernTable[string.getCodePoint(this._symbols[_i2 - 1]) || 0];

	              if (kernLeft) {
	                kerning = kernLeft[string.getCodePoint(this._symbols[_i2]) || 0] || 0;
	              }
	            }
	          }

	          dataScale = data.scale || 1;
	          size = (data.width + data.height) / 2;
	          quadsize = scale * size / dataScale;
	          advance = (data.xadvance + kerning) * scale;
	          x = (data.xoffset - kerning) * scale;
	          y = data.yoffset * scale;
	        } else {
	          console.error("Couldn't substitute missing character: '" + char + "'");
	        }

	        var isWhitespace = WHITESPACE_CHAR.test(char);
	        var meshInfoId = data && data.map || 0;
	        var ratio = -this._font.data.info.maps[meshInfoId].width / this._font.data.info.maps[meshInfoId].height;
	        var meshInfo = this._meshInfo[meshInfoId];
	        var candidateLineWidth = _x + this._spacing * advance;

	        if (candidateLineWidth > maxLineWidth && numCharsThisLine > 0 && !isWhitespace) {
	          if (this._maxLines < 0 || lines < this._maxLines) {
	            if (numWordsThisLine === 0) {
	              wordStartIndex = _i2;
	              breakLine(this._symbols, _i2, _xMinusTrailingWhitespace);
	            } else {
	              var backtrack = Math.max(_i2 - wordStartIndex, 0);

	              if (this._meshInfo.length <= 1) {
	                meshInfo.lines[lines - 1] -= backtrack;
	                meshInfo.quad -= backtrack;
	              } else {
	                var backtrackStart = wordStartIndex;
	                var backtrackEnd = _i2;

	                for (var j = backtrackStart; j < backtrackEnd; j++) {
	                  var backChar = this._symbols[j];
	                  var backCharData = json.chars[backChar];
	                  var backMeshInfo = this._meshInfo[backCharData && backCharData.map || 0];
	                  backMeshInfo.lines[lines - 1] -= 1;
	                  backMeshInfo.quad -= 1;
	                }
	              }

	              _i2 -= backtrack + 1;
	              breakLine(this._symbols, wordStartIndex, wordStartX);
	              continue;
	            }
	          }
	        }

	        quad = meshInfo.quad;
	        meshInfo.lines[lines - 1] = quad;
	        var left = _x - x;
	        var right = left + quadsize;
	        var bottom = _y - y;
	        var top = bottom + quadsize;

	        if (this._rtl) {
	          var shift = quadsize - x - this._spacing * advance - x;
	          left -= shift;
	          right -= shift;
	        }

	        meshInfo.positions[quad * 4 * 3 + 0] = left;
	        meshInfo.positions[quad * 4 * 3 + 1] = bottom;
	        meshInfo.positions[quad * 4 * 3 + 2] = _z;
	        meshInfo.positions[quad * 4 * 3 + 3] = right;
	        meshInfo.positions[quad * 4 * 3 + 4] = bottom;
	        meshInfo.positions[quad * 4 * 3 + 5] = _z;
	        meshInfo.positions[quad * 4 * 3 + 6] = right;
	        meshInfo.positions[quad * 4 * 3 + 7] = top;
	        meshInfo.positions[quad * 4 * 3 + 8] = _z;
	        meshInfo.positions[quad * 4 * 3 + 9] = left;
	        meshInfo.positions[quad * 4 * 3 + 10] = top;
	        meshInfo.positions[quad * 4 * 3 + 11] = _z;
	        this.width = Math.max(this.width, candidateLineWidth);
	        var fontSize = void 0;

	        if (this._shouldAutoFitWidth() && this.width > this._element.calculatedWidth) {
	          fontSize = Math.floor(this._element.fontSize * this._element.calculatedWidth / (this.width || 0.0001));
	          fontSize = math.clamp(fontSize, minFont, maxFont);

	          if (fontSize !== this._element.fontSize) {
	            this._fontSize = fontSize;
	            retryUpdateMeshes = true;
	            break;
	          }
	        }

	        this.height = Math.max(this.height, fontMaxY - (_y + fontMinY));

	        if (this._shouldAutoFitHeight() && this.height > this._element.calculatedHeight) {
	          fontSize = math.clamp(this._fontSize - 1, minFont, maxFont);

	          if (fontSize !== this._element.fontSize) {
	            this._fontSize = fontSize;
	            retryUpdateMeshes = true;
	            break;
	          }
	        }

	        _x += this._spacing * advance;

	        if (!isWhitespace) {
	          _xMinusTrailingWhitespace = _x;
	        }

	        if (this._isWordBoundary(char) || this._isValidNextChar(nextchar) && (this._isNextCJKBoundary(char, nextchar) || this._isNextCJKWholeWord(nextchar))) {
	          numWordsThisLine++;
	          wordStartX = _xMinusTrailingWhitespace;
	          wordStartIndex = _i2 + 1;
	        }

	        numCharsThisLine++;

	        var uv = this._getUv(char);

	        meshInfo.uvs[quad * 4 * 2 + 0] = uv[0];
	        meshInfo.uvs[quad * 4 * 2 + 1] = 1.0 - uv[1];
	        meshInfo.uvs[quad * 4 * 2 + 2] = uv[2];
	        meshInfo.uvs[quad * 4 * 2 + 3] = 1.0 - uv[1];
	        meshInfo.uvs[quad * 4 * 2 + 4] = uv[2];
	        meshInfo.uvs[quad * 4 * 2 + 5] = 1.0 - uv[3];
	        meshInfo.uvs[quad * 4 * 2 + 6] = uv[0];
	        meshInfo.uvs[quad * 4 * 2 + 7] = 1.0 - uv[3];

	        if (this._symbolColors) {
	          var colorIdx = this._symbolColors[_i2] * 3;
	          color_r = this._colorPalette[colorIdx];
	          color_g = this._colorPalette[colorIdx + 1];
	          color_b = this._colorPalette[colorIdx + 2];
	        }

	        meshInfo.colors[quad * 4 * 4 + 0] = color_r;
	        meshInfo.colors[quad * 4 * 4 + 1] = color_g;
	        meshInfo.colors[quad * 4 * 4 + 2] = color_b;
	        meshInfo.colors[quad * 4 * 4 + 3] = 255;
	        meshInfo.colors[quad * 4 * 4 + 4] = color_r;
	        meshInfo.colors[quad * 4 * 4 + 5] = color_g;
	        meshInfo.colors[quad * 4 * 4 + 6] = color_b;
	        meshInfo.colors[quad * 4 * 4 + 7] = 255;
	        meshInfo.colors[quad * 4 * 4 + 8] = color_r;
	        meshInfo.colors[quad * 4 * 4 + 9] = color_g;
	        meshInfo.colors[quad * 4 * 4 + 10] = color_b;
	        meshInfo.colors[quad * 4 * 4 + 11] = 255;
	        meshInfo.colors[quad * 4 * 4 + 12] = color_r;
	        meshInfo.colors[quad * 4 * 4 + 13] = color_g;
	        meshInfo.colors[quad * 4 * 4 + 14] = color_b;
	        meshInfo.colors[quad * 4 * 4 + 15] = 255;

	        if (this._symbolOutlineParams) {
	          var outlineIdx = this._symbolOutlineParams[_i2] * 5;
	          outline_color_rg = this._outlinePalette[outlineIdx] + this._outlinePalette[outlineIdx + 1] * 256;
	          outline_color_ba = this._outlinePalette[outlineIdx + 2] + this._outlinePalette[outlineIdx + 3] * 256;
	          outline_thickness = this._outlinePalette[outlineIdx + 4];
	        }

	        meshInfo.outlines[quad * 4 * 3 + 0] = outline_color_rg;
	        meshInfo.outlines[quad * 4 * 3 + 1] = outline_color_ba;
	        meshInfo.outlines[quad * 4 * 3 + 2] = outline_thickness;
	        meshInfo.outlines[quad * 4 * 3 + 3] = outline_color_rg;
	        meshInfo.outlines[quad * 4 * 3 + 4] = outline_color_ba;
	        meshInfo.outlines[quad * 4 * 3 + 5] = outline_thickness;
	        meshInfo.outlines[quad * 4 * 3 + 6] = outline_color_rg;
	        meshInfo.outlines[quad * 4 * 3 + 7] = outline_color_ba;
	        meshInfo.outlines[quad * 4 * 3 + 8] = outline_thickness;
	        meshInfo.outlines[quad * 4 * 3 + 9] = outline_color_rg;
	        meshInfo.outlines[quad * 4 * 3 + 10] = outline_color_ba;
	        meshInfo.outlines[quad * 4 * 3 + 11] = outline_thickness;

	        if (this._symbolShadowParams) {
	          var shadowIdx = this._symbolShadowParams[_i2] * 6;
	          shadow_color_rg = this._shadowPalette[shadowIdx] + this._shadowPalette[shadowIdx + 1] * 256;
	          shadow_color_ba = this._shadowPalette[shadowIdx + 2] + this._shadowPalette[shadowIdx + 3] * 256;
	          shadow_offset_xy = this._shadowPalette[shadowIdx + 4] + 127 + Math.round(ratio * this._shadowPalette[shadowIdx + 5] + 127) * 256;
	        }

	        meshInfo.shadows[quad * 4 * 3 + 0] = shadow_color_rg;
	        meshInfo.shadows[quad * 4 * 3 + 1] = shadow_color_ba;
	        meshInfo.shadows[quad * 4 * 3 + 2] = shadow_offset_xy;
	        meshInfo.shadows[quad * 4 * 3 + 3] = shadow_color_rg;
	        meshInfo.shadows[quad * 4 * 3 + 4] = shadow_color_ba;
	        meshInfo.shadows[quad * 4 * 3 + 5] = shadow_offset_xy;
	        meshInfo.shadows[quad * 4 * 3 + 6] = shadow_color_rg;
	        meshInfo.shadows[quad * 4 * 3 + 7] = shadow_color_ba;
	        meshInfo.shadows[quad * 4 * 3 + 8] = shadow_offset_xy;
	        meshInfo.shadows[quad * 4 * 3 + 9] = shadow_color_rg;
	        meshInfo.shadows[quad * 4 * 3 + 10] = shadow_color_ba;
	        meshInfo.shadows[quad * 4 * 3 + 11] = shadow_offset_xy;
	        meshInfo.quad++;
	      }

	      if (retryUpdateMeshes) {
	        continue;
	      }

	      if (lineStartIndex < l) {
	        breakLine(this._symbols, l, _x);
	      }
	    }

	    this._noResize = true;
	    this.autoWidth = this._autoWidth;
	    this.autoHeight = this._autoHeight;
	    this._noResize = false;
	    var hp = this._element.pivot.x;
	    var vp = this._element.pivot.y;
	    var ha = this._alignment.x;
	    var va = this._alignment.y;

	    for (var _i3 = 0; _i3 < this._meshInfo.length; _i3++) {
	      if (this._meshInfo[_i3].count === 0) continue;
	      var prevQuad = 0;

	      for (var line in this._meshInfo[_i3].lines) {
	        var index = this._meshInfo[_i3].lines[line];

	        var lw = this._lineWidths[parseInt(line, 10)];

	        var hoffset = -hp * this._element.calculatedWidth + ha * (this._element.calculatedWidth - lw) * (this._rtl ? -1 : 1);
	        var voffset = (1 - vp) * this._element.calculatedHeight - fontMaxY - (1 - va) * (this._element.calculatedHeight - this.height);

	        for (var _quad = prevQuad; _quad <= index; _quad++) {
	          this._meshInfo[_i3].positions[_quad * 4 * 3] += hoffset;
	          this._meshInfo[_i3].positions[_quad * 4 * 3 + 3] += hoffset;
	          this._meshInfo[_i3].positions[_quad * 4 * 3 + 6] += hoffset;
	          this._meshInfo[_i3].positions[_quad * 4 * 3 + 9] += hoffset;
	          this._meshInfo[_i3].positions[_quad * 4 * 3 + 1] += voffset;
	          this._meshInfo[_i3].positions[_quad * 4 * 3 + 4] += voffset;
	          this._meshInfo[_i3].positions[_quad * 4 * 3 + 7] += voffset;
	          this._meshInfo[_i3].positions[_quad * 4 * 3 + 10] += voffset;
	        }

	        if (this._rtl) {
	          for (var _quad2 = prevQuad; _quad2 <= index; _quad2++) {
	            var idx = _quad2 * 4 * 3;

	            for (var vert = 0; vert < 4; ++vert) {
	              this._meshInfo[_i3].positions[idx + vert * 3] = this._element.calculatedWidth - this._meshInfo[_i3].positions[idx + vert * 3] + hoffset * 2;
	            }

	            var tmp0 = this._meshInfo[_i3].positions[idx + 3];
	            var tmp1 = this._meshInfo[_i3].positions[idx + 6];
	            this._meshInfo[_i3].positions[idx + 3] = this._meshInfo[_i3].positions[idx + 0];
	            this._meshInfo[_i3].positions[idx + 6] = this._meshInfo[_i3].positions[idx + 9];
	            this._meshInfo[_i3].positions[idx + 0] = tmp0;
	            this._meshInfo[_i3].positions[idx + 9] = tmp1;
	          }
	        }

	        prevQuad = index + 1;
	      }

	      var numVertices = this._meshInfo[_i3].count * 4;
	      var vertMax = this._meshInfo[_i3].quad * 4;
	      var it = new VertexIterator(this._meshInfo[_i3].meshInstance.mesh.vertexBuffer);

	      for (var v = 0; v < numVertices; v++) {
	        if (v >= vertMax) {
	          it.element[SEMANTIC_POSITION].set(0, 0, 0);
	          it.element[SEMANTIC_TEXCOORD0].set(0, 0);
	          it.element[SEMANTIC_COLOR].set(0, 0, 0, 0);
	          it.element[SEMANTIC_ATTR8].set(0, 0, 0, 0);
	          it.element[SEMANTIC_ATTR9].set(0, 0, 0, 0);
	        } else {
	          it.element[SEMANTIC_POSITION].set(this._meshInfo[_i3].positions[v * 3 + 0], this._meshInfo[_i3].positions[v * 3 + 1], this._meshInfo[_i3].positions[v * 3 + 2]);
	          it.element[SEMANTIC_TEXCOORD0].set(this._meshInfo[_i3].uvs[v * 2 + 0], this._meshInfo[_i3].uvs[v * 2 + 1]);
	          it.element[SEMANTIC_COLOR].set(this._meshInfo[_i3].colors[v * 4 + 0], this._meshInfo[_i3].colors[v * 4 + 1], this._meshInfo[_i3].colors[v * 4 + 2], this._meshInfo[_i3].colors[v * 4 + 3]);
	          it.element[SEMANTIC_ATTR8].set(this._meshInfo[_i3].outlines[v * 3 + 0], this._meshInfo[_i3].outlines[v * 3 + 1], this._meshInfo[_i3].outlines[v * 3 + 2]);
	          it.element[SEMANTIC_ATTR9].set(this._meshInfo[_i3].shadows[v * 3 + 0], this._meshInfo[_i3].shadows[v * 3 + 1], this._meshInfo[_i3].shadows[v * 3 + 2]);
	        }

	        it.next();
	      }

	      it.end();

	      this._meshInfo[_i3].meshInstance.mesh.aabb.compute(this._meshInfo[_i3].positions);

	      this._meshInfo[_i3].meshInstance._aabbVer = -1;
	    }

	    this._aabbDirty = true;
	  };

	  _proto._onFontRender = function _onFontRender() {
	    this.font = this._font;
	  };

	  _proto._onFontLoad = function _onFontLoad(asset) {
	    if (this.font !== asset.resource) {
	      this.font = asset.resource;
	    }
	  };

	  _proto._onFontChange = function _onFontChange(asset, name, _new, _old) {
	    if (name === 'data') {
	      this._font.data = _new;
	      var maps = this._font.data.info.maps.length;

	      for (var i = 0; i < maps; i++) {
	        if (!this._meshInfo[i]) continue;
	        var mi = this._meshInfo[i].meshInstance;

	        if (mi) {
	          mi.setParameter('font_sdfIntensity', this._font.intensity);
	          mi.setParameter('font_pxrange', this._getPxRange(this._font));
	          mi.setParameter('font_textureWidth', this._font.data.info.maps[i].width);
	        }
	      }
	    }
	  };

	  _proto._onFontRemove = function _onFontRemove(asset) {};

	  _proto._setTextureParams = function _setTextureParams(mi, texture) {
	    if (this._font) {
	      if (this._font.type === FONT_MSDF) {
	        mi.deleteParameter('texture_emissiveMap');
	        mi.deleteParameter('texture_opacityMap');
	        mi.setParameter('texture_msdfMap', texture);
	      } else if (this._font.type === FONT_BITMAP) {
	        mi.deleteParameter('texture_msdfMap');
	        mi.setParameter('texture_emissiveMap', texture);
	        mi.setParameter('texture_opacityMap', texture);
	      }
	    }
	  };

	  _proto._getPxRange = function _getPxRange(font) {
	    var keys = Object.keys(this._font.data.chars);

	    for (var i = 0; i < keys.length; i++) {
	      var char = this._font.data.chars[keys[i]];

	      if (char.range) {
	        return (char.scale || 1) * char.range;
	      }
	    }

	    return 2;
	  };

	  _proto._getUv = function _getUv(char) {
	    var data = this._font.data;

	    if (!data.chars[char]) {
	      var space = ' ';

	      if (data.chars[space]) {
	        return this._getUv(space);
	      }

	      return [0, 0, 0, 0];
	    }

	    var map = data.chars[char].map;
	    var width = data.info.maps[map].width;
	    var height = data.info.maps[map].height;
	    var x = data.chars[char].x;
	    var y = data.chars[char].y;
	    var x1 = x;
	    var y1 = y;
	    var x2 = x + data.chars[char].width;
	    var y2 = y - data.chars[char].height;
	    var edge = 1 - data.chars[char].height / height;
	    return [x1 / width, edge - y1 / height, x2 / width, edge - y2 / height];
	  };

	  _proto.onEnable = function onEnable() {
	    this._fontAsset.autoLoad = true;

	    if (this._model) {
	      this._element.addModelToLayers(this._model);
	    }
	  };

	  _proto.onDisable = function onDisable() {
	    this._fontAsset.autoLoad = false;

	    if (this._model) {
	      this._element.removeModelFromLayers(this._model);
	    }
	  };

	  _proto._setStencil = function _setStencil(stencilParams) {
	    if (this._model) {
	      var instances = this._model.meshInstances;

	      for (var i = 0; i < instances.length; i++) {
	        instances[i].stencilFront = stencilParams;
	        instances[i].stencilBack = stencilParams;
	      }
	    }
	  };

	  _proto._shouldAutoFitWidth = function _shouldAutoFitWidth() {
	    return this._autoFitWidth && !this._autoWidth;
	  };

	  _proto._shouldAutoFitHeight = function _shouldAutoFitHeight() {
	    return this._autoFitHeight && !this._autoHeight;
	  };

	  _proto._shouldAutoFit = function _shouldAutoFit() {
	    return this._autoFitWidth && !this._autoWidth || this._autoFitHeight && !this._autoHeight;
	  };

	  _proto._calculateCharsPerTexture = function _calculateCharsPerTexture(symbolIndex) {
	    var charactersPerTexture = {};

	    if (symbolIndex === undefined) {
	      symbolIndex = this._symbols.length;
	    }

	    for (var i = 0, len = symbolIndex; i < len; i++) {
	      var char = this._symbols[i];
	      var info = this._font.data.chars[char];

	      if (!info) {
	        info = this._font.data.chars[' '];

	        if (!info) {
	          info = this._font.data.chars[Object.keys(this._font.data.chars)[0]];
	        }
	      }

	      var map = info.map;

	      if (!charactersPerTexture[map]) {
	        charactersPerTexture[map] = 1;
	      } else {
	        charactersPerTexture[map]++;
	      }
	    }

	    return charactersPerTexture;
	  };

	  _proto._updateRenderRange = function _updateRenderRange() {
	    var startChars = this._rangeStart === 0 ? 0 : this._calculateCharsPerTexture(this._rangeStart);
	    var endChars = this._rangeEnd === 0 ? 0 : this._calculateCharsPerTexture(this._rangeEnd);

	    for (var i = 0, len = this._meshInfo.length; i < len; i++) {
	      var start = startChars[i] || 0;
	      var end = endChars[i] || 0;
	      var instance = this._meshInfo[i].meshInstance;

	      if (instance) {
	        var mesh = instance.mesh;

	        if (mesh) {
	          mesh.primitive[0].base = start * 3 * 2;
	          mesh.primitive[0].count = (end - start) * 3 * 2;
	        }
	      }
	    }
	  };

	  _createClass(TextElement, [{
	    key: "text",
	    get: function get() {
	      return this._text;
	    },
	    set: function set(value) {
	      this._i18nKey = null;
	      var str = value != null && value.toString() || '';

	      this._setText(str);
	    }
	  }, {
	    key: "key",
	    get: function get() {
	      return this._i18nKey;
	    },
	    set: function set(value) {
	      var str = value !== null ? value.toString() : null;

	      if (this._i18nKey === str) {
	        return;
	      }

	      this._i18nKey = str;

	      if (str) {
	        this._fontAsset.disableLocalization = false;

	        this._resetLocalizedText();
	      } else {
	        this._fontAsset.disableLocalization = true;
	      }
	    }
	  }, {
	    key: "color",
	    get: function get() {
	      return this._color;
	    },
	    set: function set(value) {
	      var r = value.r;
	      var g = value.g;
	      var b = value.b;

	      if (this._color.r === r && this._color.g === g && this._color.b === b) {
	        return;
	      }

	      this._color.r = r;
	      this._color.g = g;
	      this._color.b = b;

	      if (!this._model) {
	        return;
	      }

	      if (this._symbolColors) {
	        if (this._font) {
	          this._updateText();
	        }
	      } else {
	        this._colorUniform[0] = this._color.r;
	        this._colorUniform[1] = this._color.g;
	        this._colorUniform[2] = this._color.b;

	        for (var i = 0, len = this._model.meshInstances.length; i < len; i++) {
	          var mi = this._model.meshInstances[i];
	          mi.setParameter('material_emissive', this._colorUniform);
	        }
	      }

	      if (this._element) {
	        this._element.fire('set:color', this._color);
	      }
	    }
	  }, {
	    key: "opacity",
	    get: function get() {
	      return this._color.a;
	    },
	    set: function set(value) {
	      if (this._color.a !== value) {
	        this._color.a = value;

	        if (this._model) {
	          for (var i = 0, len = this._model.meshInstances.length; i < len; i++) {
	            var mi = this._model.meshInstances[i];
	            mi.setParameter('material_opacity', value);
	          }
	        }
	      }

	      if (this._element) {
	        this._element.fire('set:opacity', value);
	      }
	    }
	  }, {
	    key: "lineHeight",
	    get: function get() {
	      return this._lineHeight;
	    },
	    set: function set(value) {
	      var _prev = this._lineHeight;
	      this._lineHeight = value;
	      this._scaledLineHeight = value;

	      if (_prev !== value && this._font) {
	        this._updateText();
	      }
	    }
	  }, {
	    key: "wrapLines",
	    get: function get() {
	      return this._wrapLines;
	    },
	    set: function set(value) {
	      var _prev = this._wrapLines;
	      this._wrapLines = value;

	      if (_prev !== value && this._font) {
	        this._updateText();
	      }
	    }
	  }, {
	    key: "lines",
	    get: function get() {
	      return this._lineContents;
	    }
	  }, {
	    key: "spacing",
	    get: function get() {
	      return this._spacing;
	    },
	    set: function set(value) {
	      var _prev = this._spacing;
	      this._spacing = value;

	      if (_prev !== value && this._font) {
	        this._updateText();
	      }
	    }
	  }, {
	    key: "fontSize",
	    get: function get() {
	      return this._fontSize;
	    },
	    set: function set(value) {
	      var _prev = this._fontSize;
	      this._fontSize = value;
	      this._originalFontSize = value;

	      if (_prev !== value && this._font) {
	        this._updateText();
	      }
	    }
	  }, {
	    key: "fontAsset",
	    get: function get() {
	      return this._fontAsset.localizedAsset;
	    },
	    set: function set(value) {
	      this._fontAsset.defaultAsset = value;
	    }
	  }, {
	    key: "font",
	    get: function get() {
	      return this._font;
	    },
	    set: function set(value) {
	      var previousFontType;

	      if (this._font) {
	        previousFontType = this._font.type;
	        if (this._font.off) this._font.off('render', this._onFontRender, this);
	      }

	      this._font = value;
	      this._fontMinY = 0;
	      this._fontMaxY = 0;
	      if (!value) return;
	      var json = this._font.data;

	      for (var charId in json.chars) {
	        var data = json.chars[charId];

	        if (data.bounds) {
	          this._fontMinY = Math.min(this._fontMinY, data.bounds[1]);
	          this._fontMaxY = Math.max(this._fontMaxY, data.bounds[3]);
	        }
	      }

	      if (this._font.on) this._font.on('render', this._onFontRender, this);

	      if (this._fontAsset.localizedAsset) {
	        var asset = this._system.app.assets.get(this._fontAsset.localizedAsset);

	        if (asset.resource !== this._font) {
	          this._fontAsset.defaultAsset = null;
	        }
	      }

	      if (value.type !== previousFontType) {
	        var screenSpace = this._element._isScreenSpace();

	        this._updateMaterial(screenSpace);
	      }

	      for (var i = 0, len = this._font.textures.length; i < len; i++) {
	        if (!this._meshInfo[i]) {
	          this._meshInfo[i] = new MeshInfo();
	        } else {
	          var mi = this._meshInfo[i].meshInstance;

	          if (mi) {
	            mi.setParameter('font_sdfIntensity', this._font.intensity);
	            mi.setParameter('font_pxrange', this._getPxRange(this._font));
	            mi.setParameter('font_textureWidth', this._font.data.info.maps[i].width);

	            this._setTextureParams(mi, this._font.textures[i]);
	          }
	        }
	      }

	      var removedModel = false;

	      for (var _i4 = this._font.textures.length; _i4 < this._meshInfo.length; _i4++) {
	        if (this._meshInfo[_i4].meshInstance) {
	          if (!removedModel) {
	            this._element.removeModelFromLayers(this._model);

	            removedModel = true;
	          }

	          this._removeMeshInstance(this._meshInfo[_i4].meshInstance);
	        }
	      }

	      if (this._meshInfo.length > this._font.textures.length) this._meshInfo.length = this._font.textures.length;

	      this._updateText();
	    }
	  }, {
	    key: "alignment",
	    get: function get() {
	      return this._alignment;
	    },
	    set: function set(value) {
	      if (value instanceof Vec2) {
	        this._alignment.set(value.x, value.y);
	      } else {
	        this._alignment.set(value[0], value[1]);
	      }

	      if (this._font) this._updateText();
	    }
	  }, {
	    key: "autoWidth",
	    get: function get() {
	      return this._autoWidth;
	    },
	    set: function set(value) {
	      var old = this._autoWidth;
	      this._autoWidth = value;

	      if (value && Math.abs(this._element.anchor.x - this._element.anchor.z) < 0.0001) {
	        this._element.width = this.width;
	      }

	      if (old !== value) {
	        var newFontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;

	        if (newFontSize !== this._fontSize) {
	          this._fontSize = newFontSize;

	          if (this._font) {
	            this._updateText();
	          }
	        }
	      }
	    }
	  }, {
	    key: "autoHeight",
	    get: function get() {
	      return this._autoHeight;
	    },
	    set: function set(value) {
	      var old = this._autoHeight;
	      this._autoHeight = value;

	      if (value && Math.abs(this._element.anchor.y - this._element.anchor.w) < 0.0001) {
	        this._element.height = this.height;
	      }

	      if (old !== value) {
	        var newFontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;

	        if (newFontSize !== this._fontSize) {
	          this._fontSize = newFontSize;

	          if (this._font) {
	            this._updateText();
	          }
	        }
	      }
	    }
	  }, {
	    key: "rtlReorder",
	    get: function get() {
	      return this._rtlReorder;
	    },
	    set: function set(value) {
	      if (this._rtlReorder !== value) {
	        this._rtlReorder = value;

	        if (this._font) {
	          this._updateText();
	        }
	      }
	    }
	  }, {
	    key: "unicodeConverter",
	    get: function get() {
	      return this._unicodeConverter;
	    },
	    set: function set(value) {
	      if (this._unicodeConverter !== value) {
	        this._unicodeConverter = value;

	        this._setText(this._text);
	      }
	    }
	  }, {
	    key: "aabb",
	    get: function get() {
	      if (this._aabbDirty) {
	        var initialized = false;

	        for (var i = 0; i < this._meshInfo.length; i++) {
	          if (!this._meshInfo[i].meshInstance) continue;

	          if (!initialized) {
	            this._aabb.copy(this._meshInfo[i].meshInstance.aabb);

	            initialized = true;
	          } else {
	            this._aabb.add(this._meshInfo[i].meshInstance.aabb);
	          }
	        }

	        this._aabbDirty = false;
	      }

	      return this._aabb;
	    }
	  }, {
	    key: "outlineColor",
	    get: function get() {
	      return this._outlineColor;
	    },
	    set: function set(value) {
	      var r = value instanceof Color ? value.r : value[0];
	      var g = value instanceof Color ? value.g : value[1];
	      var b = value instanceof Color ? value.b : value[2];
	      var a = value instanceof Color ? value.a : value[3];

	      if (this._outlineColor.r === r && this._outlineColor.g === g && this._outlineColor.b === b && this._outlineColor.a === a) {
	        return;
	      }

	      this._outlineColor.r = r;
	      this._outlineColor.g = g;
	      this._outlineColor.b = b;
	      this._outlineColor.a = a;

	      if (!this._model) {
	        return;
	      }

	      if (this._symbolOutlineParams) {
	        if (this._font) {
	          this._updateText();
	        }
	      } else {
	        this._outlineColorUniform[0] = this._outlineColor.r;
	        this._outlineColorUniform[1] = this._outlineColor.g;
	        this._outlineColorUniform[2] = this._outlineColor.b;
	        this._outlineColorUniform[3] = this._outlineColor.a;

	        for (var i = 0, len = this._model.meshInstances.length; i < len; i++) {
	          var mi = this._model.meshInstances[i];
	          mi.setParameter('outline_color', this._outlineColorUniform);
	        }
	      }

	      if (this._element) {
	        this._element.fire('set:outline', this._color);
	      }
	    }
	  }, {
	    key: "outlineThickness",
	    get: function get() {
	      return this._outlineThickness;
	    },
	    set: function set(value) {
	      var _prev = this._outlineThickness;
	      this._outlineThickness = value;

	      if (_prev !== value && this._font) {
	        if (!this._model) {
	          return;
	        }

	        if (this._symbolOutlineParams) {
	          if (this._font) {
	            this._updateText();
	          }
	        } else {
	          for (var i = 0, len = this._model.meshInstances.length; i < len; i++) {
	            var mi = this._model.meshInstances[i];
	            mi.setParameter('outline_thickness', this._outlineThicknessScale * this._outlineThickness);
	          }
	        }
	      }
	    }
	  }, {
	    key: "shadowColor",
	    get: function get() {
	      return this._shadowColor;
	    },
	    set: function set(value) {
	      var r = value instanceof Color ? value.r : value[0];
	      var g = value instanceof Color ? value.g : value[1];
	      var b = value instanceof Color ? value.b : value[2];
	      var a = value instanceof Color ? value.a : value[3];

	      if (this._shadowColor.r === r && this._shadowColor.g === g && this._shadowColor.b === b && this._shadowColor.a === a) {
	        return;
	      }

	      this._shadowColor.r = r;
	      this._shadowColor.g = g;
	      this._shadowColor.b = b;
	      this._shadowColor.a = a;

	      if (!this._model) {
	        return;
	      }

	      if (this._symbolShadowParams) {
	        if (this._font) {
	          this._updateText();
	        }
	      } else {
	        this._shadowColorUniform[0] = this._shadowColor.r;
	        this._shadowColorUniform[1] = this._shadowColor.g;
	        this._shadowColorUniform[2] = this._shadowColor.b;
	        this._shadowColorUniform[3] = this._shadowColor.a;

	        for (var i = 0, len = this._model.meshInstances.length; i < len; i++) {
	          var mi = this._model.meshInstances[i];
	          mi.setParameter('shadow_color', this._shadowColorUniform);
	        }
	      }
	    }
	  }, {
	    key: "shadowOffset",
	    get: function get() {
	      return this._shadowOffset;
	    },
	    set: function set(value) {
	      var x = value instanceof Vec2 ? value.x : value[0],
	          y = value instanceof Vec2 ? value.y : value[1];

	      if (this._shadowOffset.x === x && this._shadowOffset.y === y) {
	        return;
	      }

	      this._shadowOffset.set(x, y);

	      if (this._font && this._model) {
	        if (this._symbolShadowParams) {
	          this._updateText();
	        } else {
	          for (var i = 0, len = this._model.meshInstances.length; i < len; i++) {
	            var ratio = -this._font.data.info.maps[i].width / this._font.data.info.maps[i].height;
	            this._shadowOffsetUniform[0] = this._shadowOffsetScale * this._shadowOffset.x;
	            this._shadowOffsetUniform[1] = ratio * this._shadowOffsetScale * this._shadowOffset.y;
	            var mi = this._model.meshInstances[i];
	            mi.setParameter('shadow_offset', this._shadowOffsetUniform);
	          }
	        }
	      }
	    }
	  }, {
	    key: "minFontSize",
	    get: function get() {
	      return this._minFontSize;
	    },
	    set: function set(value) {
	      if (this._minFontSize === value) return;
	      this._minFontSize = value;

	      if (this.font && this._shouldAutoFit()) {
	        this._updateText();
	      }
	    }
	  }, {
	    key: "maxFontSize",
	    get: function get() {
	      return this._maxFontSize;
	    },
	    set: function set(value) {
	      if (this._maxFontSize === value) return;
	      this._maxFontSize = value;

	      if (this.font && this._shouldAutoFit()) {
	        this._updateText();
	      }
	    }
	  }, {
	    key: "autoFitWidth",
	    get: function get() {
	      return this._autoFitWidth;
	    },
	    set: function set(value) {
	      if (this._autoFitWidth === value) return;
	      this._autoFitWidth = value;
	      this._fontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;

	      if (this.font) {
	        this._updateText();
	      }
	    }
	  }, {
	    key: "autoFitHeight",
	    get: function get() {
	      return this._autoFitHeight;
	    },
	    set: function set(value) {
	      if (this._autoFitHeight === value) return;
	      this._autoFitHeight = value;
	      this._fontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;

	      if (this.font) {
	        this._updateText();
	      }
	    }
	  }, {
	    key: "maxLines",
	    get: function get() {
	      return this._maxLines;
	    },
	    set: function set(value) {
	      if (this._maxLines === value) return;
	      if (value === null && this._maxLines === -1) return;
	      this._maxLines = value === null ? -1 : value;

	      if (this.font && this._wrapLines) {
	        this._updateText();
	      }
	    }
	  }, {
	    key: "enableMarkup",
	    get: function get() {
	      return this._enableMarkup;
	    },
	    set: function set(value) {
	      value = !!value;
	      if (this._enableMarkup === value) return;
	      this._enableMarkup = value;

	      if (this.font) {
	        this._updateText();
	      }

	      var screenSpace = this._element._isScreenSpace();

	      this._updateMaterial(screenSpace);
	    }
	  }, {
	    key: "symbols",
	    get: function get() {
	      return this._symbols;
	    }
	  }, {
	    key: "symbolColors",
	    get: function get() {
	      if (this._symbolColors === null) {
	        return null;
	      }

	      return this._symbolColors.map(function (c) {
	        return this._colorPalette.slice(c * 3, c * 3 + 3);
	      }, this);
	    }
	  }, {
	    key: "symbolOutlineParams",
	    get: function get() {
	      if (this._symbolOutlineParams === null) {
	        return null;
	      }

	      return this._symbolOutlineParams.map(function (paramId) {
	        return this._outlinePalette.slice(paramId * 5, paramId * 5 + 5);
	      }, this);
	    }
	  }, {
	    key: "symbolShadowParams",
	    get: function get() {
	      if (this._symbolShadowParams === null) {
	        return null;
	      }

	      return this._symbolShadowParams.map(function (paramId) {
	        return this._shadowPalette.slice(paramId * 6, paramId * 6 + 6);
	      }, this);
	    }
	  }, {
	    key: "rtl",
	    get: function get() {
	      return this._rtl;
	    }
	  }, {
	    key: "rangeStart",
	    get: function get() {
	      return this._rangeStart;
	    },
	    set: function set(rangeStart) {
	      rangeStart = Math.max(0, Math.min(rangeStart, this._symbols.length));

	      if (rangeStart !== this._rangeStart) {
	        this._rangeStart = rangeStart;

	        this._updateRenderRange();
	      }
	    }
	  }, {
	    key: "rangeEnd",
	    get: function get() {
	      return this._rangeEnd;
	    },
	    set: function set(rangeEnd) {
	      rangeEnd = Math.max(this._rangeStart, Math.min(rangeEnd, this._symbols.length));

	      if (rangeEnd !== this._rangeEnd) {
	        this._rangeEnd = rangeEnd;

	        this._updateRenderRange();
	      }
	    }
	  }]);

	  return TextElement;
	}();

	var position = new Vec3();
	var invParentWtm = new Mat4();
	var vecA$1 = new Vec3();
	var vecB$1 = new Vec3();
	var matA = new Mat4();
	var matB = new Mat4();
	var matC = new Mat4();
	var matD = new Mat4();

	var ElementComponent = function (_Component) {
	  _inheritsLoose(ElementComponent, _Component);

	  function ElementComponent(system, entity) {
	    var _this;

	    _this = _Component.call(this, system, entity) || this;
	    _this._beingInitialized = false;
	    _this._anchor = new Vec4();
	    _this._localAnchor = new Vec4();
	    _this._pivot = new Vec2();
	    _this._width = _this._calculatedWidth = 32;
	    _this._height = _this._calculatedHeight = 32;
	    _this._margin = new Vec4(0, 0, -32, -32);
	    _this._modelTransform = new Mat4();
	    _this._screenToWorld = new Mat4();
	    _this._anchorTransform = new Mat4();
	    _this._anchorDirty = true;
	    _this._parentWorldTransform = new Mat4();
	    _this._screenTransform = new Mat4();
	    _this._screenCorners = [new Vec3(), new Vec3(), new Vec3(), new Vec3()];
	    _this._canvasCorners = [new Vec2(), new Vec2(), new Vec2(), new Vec2()];
	    _this._worldCorners = [new Vec3(), new Vec3(), new Vec3(), new Vec3()];
	    _this._cornersDirty = true;
	    _this._canvasCornersDirty = true;
	    _this._worldCornersDirty = true;

	    _this.entity.on('insert', _this._onInsert, _assertThisInitialized(_this));

	    _this._patch();

	    _this.screen = null;
	    _this._type = ELEMENTTYPE_GROUP;
	    _this._image = null;
	    _this._text = null;
	    _this._group = null;
	    _this._drawOrder = 0;
	    _this._fitMode = FITMODE_STRETCH;
	    _this._useInput = false;
	    _this._layers = [LAYERID_UI];
	    _this._addedModels = [];
	    _this._batchGroupId = -1;
	    _this._offsetReadAt = 0;
	    _this._maskOffset = 0.5;
	    _this._maskedBy = null;
	    return _this;
	  }

	  var _proto = ElementComponent.prototype;

	  _proto._patch = function _patch() {
	    this.entity._sync = this._sync;
	    this.entity.setPosition = this._setPosition;
	    this.entity.setLocalPosition = this._setLocalPosition;
	  };

	  _proto._unpatch = function _unpatch() {
	    this.entity._sync = Entity.prototype._sync;
	    this.entity.setPosition = Entity.prototype.setPosition;
	    this.entity.setLocalPosition = Entity.prototype.setLocalPosition;
	  };

	  _proto._setPosition = function _setPosition(x, y, z) {
	    if (!this.element.screen) return Entity.prototype.setPosition.call(this, x, y, z);

	    if (x instanceof Vec3) {
	      position.copy(x);
	    } else {
	      position.set(x, y, z);
	    }

	    this.getWorldTransform();
	    invParentWtm.copy(this.element._screenToWorld).invert();
	    invParentWtm.transformPoint(position, this.localPosition);
	    if (!this._dirtyLocal) this._dirtifyLocal();
	  };

	  _proto._setLocalPosition = function _setLocalPosition(x, y, z) {
	    if (x instanceof Vec3) {
	      this.localPosition.copy(x);
	    } else {
	      this.localPosition.set(x, y, z);
	    }

	    var element = this.element;
	    var p = this.localPosition;
	    var pvt = element._pivot;
	    element._margin.x = p.x - element._calculatedWidth * pvt.x;
	    element._margin.z = element._localAnchor.z - element._localAnchor.x - element._calculatedWidth - element._margin.x;
	    element._margin.y = p.y - element._calculatedHeight * pvt.y;
	    element._margin.w = element._localAnchor.w - element._localAnchor.y - element._calculatedHeight - element._margin.y;
	    if (!this._dirtyLocal) this._dirtifyLocal();
	  };

	  _proto._sync = function _sync() {
	    var element = this.element;
	    var screen = element.screen;

	    if (screen) {
	      if (element._anchorDirty) {
	        var resx = 0;
	        var resy = 0;
	        var px = 0;
	        var py = 1;

	        if (this._parent && this._parent.element) {
	          resx = this._parent.element.calculatedWidth;
	          resy = this._parent.element.calculatedHeight;
	          px = this._parent.element.pivot.x;
	          py = this._parent.element.pivot.y;
	        } else {
	          var resolution = screen.screen.resolution;
	          resx = resolution.x / screen.screen.scale;
	          resy = resolution.y / screen.screen.scale;
	        }

	        element._anchorTransform.setTranslate(resx * (element.anchor.x - px), -(resy * (py - element.anchor.y)), 0);

	        element._anchorDirty = false;

	        element._calculateLocalAnchors();
	      }

	      if (element._sizeDirty) {
	        element._calculateSize(false, false);
	      }
	    }

	    if (this._dirtyLocal) {
	      this.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale);
	      var p = this.localPosition;
	      var pvt = element._pivot;
	      element._margin.x = p.x - element._calculatedWidth * pvt.x;
	      element._margin.z = element._localAnchor.z - element._localAnchor.x - element._calculatedWidth - element._margin.x;
	      element._margin.y = p.y - element._calculatedHeight * pvt.y;
	      element._margin.w = element._localAnchor.w - element._localAnchor.y - element._calculatedHeight - element._margin.y;
	      this._dirtyLocal = false;
	    }

	    if (!screen) {
	      if (this._dirtyWorld) {
	        element._cornersDirty = true;
	        element._canvasCornersDirty = true;
	        element._worldCornersDirty = true;
	      }

	      return Entity.prototype._sync.call(this);
	    }

	    if (this._dirtyWorld) {
	      if (this._parent === null) {
	        this.worldTransform.copy(this.localTransform);
	      } else {
	        if (this._parent.element) {
	          element._screenToWorld.mul2(this._parent.element._modelTransform, element._anchorTransform);
	        } else {
	          element._screenToWorld.copy(element._anchorTransform);
	        }

	        element._modelTransform.mul2(element._screenToWorld, this.localTransform);

	        if (screen) {
	          element._screenToWorld.mul2(screen.screen._screenMatrix, element._screenToWorld);

	          if (!screen.screen.screenSpace) {
	            element._screenToWorld.mul2(screen.worldTransform, element._screenToWorld);
	          }

	          this.worldTransform.mul2(element._screenToWorld, this.localTransform);
	          var parentWorldTransform = element._parentWorldTransform;
	          parentWorldTransform.setIdentity();
	          var parent = this._parent;

	          if (parent && parent.element && parent !== screen) {
	            matA.setTRS(Vec3.ZERO, parent.getLocalRotation(), parent.getLocalScale());
	            parentWorldTransform.mul2(parent.element._parentWorldTransform, matA);
	          }

	          var depthOffset = vecA$1;
	          depthOffset.set(0, 0, this.localPosition.z);
	          var pivotOffset = vecB$1;
	          pivotOffset.set(element._absLeft + element._pivot.x * element.calculatedWidth, element._absBottom + element._pivot.y * element.calculatedHeight, 0);
	          matA.setTranslate(-pivotOffset.x, -pivotOffset.y, -pivotOffset.z);
	          matB.setTRS(depthOffset, this.getLocalRotation(), this.getLocalScale());
	          matC.setTranslate(pivotOffset.x, pivotOffset.y, pivotOffset.z);

	          element._screenTransform.mul2(element._parentWorldTransform, matC).mul(matB).mul(matA);

	          element._cornersDirty = true;
	          element._canvasCornersDirty = true;
	          element._worldCornersDirty = true;
	        } else {
	          this.worldTransform.copy(element._modelTransform);
	        }
	      }

	      this._dirtyWorld = false;
	    }
	  };

	  _proto._onInsert = function _onInsert(parent) {
	    var result = this._parseUpToScreen();

	    this.entity._dirtifyWorld();

	    this._updateScreen(result.screen);

	    this._dirtifyMask();
	  };

	  _proto._dirtifyMask = function _dirtifyMask() {
	    var current = this.entity;

	    while (current) {
	      var next = current.parent;

	      if ((next === null || next.screen) && current.element) {
	        if (!this.system._prerender || !this.system._prerender.length) {
	          this.system._prerender = [];
	          this.system.app.once('prerender', this._onPrerender, this);
	        }

	        var i = this.system._prerender.indexOf(this.entity);

	        if (i >= 0) {
	          this.system._prerender.splice(i, 1);
	        }

	        var j = this.system._prerender.indexOf(current);

	        if (j < 0) {
	          this.system._prerender.push(current);
	        }
	      }

	      current = next;
	    }
	  };

	  _proto._onPrerender = function _onPrerender() {
	    for (var i = 0; i < this.system._prerender.length; i++) {
	      var mask = this.system._prerender[i];

	      if (mask.element) {
	        var depth = 1;
	        mask.element.syncMask(depth);
	      }
	    }

	    this.system._prerender.length = 0;
	  };

	  _proto._bindScreen = function _bindScreen(screen) {
	    screen._bindElement(this);
	  };

	  _proto._unbindScreen = function _unbindScreen(screen) {
	    screen._unbindElement(this);
	  };

	  _proto._updateScreen = function _updateScreen(screen) {
	    if (this.screen && this.screen !== screen) {
	      this._unbindScreen(this.screen.screen);
	    }

	    var previousScreen = this.screen;
	    this.screen = screen;

	    if (this.screen) {
	      this._bindScreen(this.screen.screen);
	    }

	    this._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY);

	    this.fire('set:screen', this.screen, previousScreen);
	    this._anchorDirty = true;
	    var children = this.entity.children;

	    for (var i = 0, l = children.length; i < l; i++) {
	      if (children[i].element) children[i].element._updateScreen(screen);
	    }

	    if (this.screen) this.screen.screen.syncDrawOrder();
	  };

	  _proto.syncMask = function syncMask(depth) {
	    var result = this._parseUpToScreen();

	    this._updateMask(result.mask, depth);
	  };

	  _proto._setMaskedBy = function _setMaskedBy(mask) {
	    var renderableElement = this._image || this._text;

	    if (mask) {
	      var ref = mask.element._image._maskRef;
	      var sp = new StencilParameters({
	        ref: ref,
	        func: FUNC_EQUAL
	      });

	      if (renderableElement && renderableElement._setStencil) {
	        renderableElement._setStencil(sp);
	      }

	      this._maskedBy = mask;
	    } else {
	      if (renderableElement && renderableElement._setStencil) {
	        renderableElement._setStencil(null);
	      }

	      this._maskedBy = null;
	    }
	  };

	  _proto._updateMask = function _updateMask(currentMask, depth) {
	    if (currentMask) {
	      this._setMaskedBy(currentMask);

	      if (this.mask) {
	        var ref = currentMask.element._image._maskRef;
	        var sp = new StencilParameters({
	          ref: ref,
	          func: FUNC_EQUAL,
	          zpass: STENCILOP_INCREMENT
	        });

	        this._image._setStencil(sp);

	        this._image._maskRef = depth;
	        depth++;
	        currentMask = this.entity;
	      }

	      var children = this.entity.children;

	      for (var i = 0, l = children.length; i < l; i++) {
	        if (children[i].element) {
	          children[i].element._updateMask(currentMask, depth);
	        }
	      }

	      if (this.mask) depth--;
	    } else {
	      this._setMaskedBy(null);

	      if (this.mask) {
	        var _sp = new StencilParameters({
	          ref: depth,
	          func: FUNC_ALWAYS,
	          zpass: STENCILOP_REPLACE
	        });

	        this._image._setStencil(_sp);

	        this._image._maskRef = depth;
	        depth++;
	        currentMask = this.entity;
	      }

	      var _children = this.entity.children;

	      for (var _i = 0, _l = _children.length; _i < _l; _i++) {
	        if (_children[_i].element) {
	          _children[_i].element._updateMask(currentMask, depth);
	        }
	      }

	      if (this.mask) depth--;
	    }
	  };

	  _proto._parseUpToScreen = function _parseUpToScreen() {
	    var result = {
	      screen: null,
	      mask: null
	    };
	    var parent = this.entity._parent;

	    while (parent && !parent.screen) {
	      if (parent.element && parent.element.mask) {
	        if (!result.mask) result.mask = parent;
	      }

	      parent = parent.parent;
	    }

	    if (parent && parent.screen) result.screen = parent;
	    return result;
	  };

	  _proto._onScreenResize = function _onScreenResize(res) {
	    this._anchorDirty = true;
	    this._cornersDirty = true;
	    this._worldCornersDirty = true;

	    this._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY);

	    this.fire('screen:set:resolution', res);
	  };

	  _proto._onScreenSpaceChange = function _onScreenSpaceChange() {
	    this.fire('screen:set:screenspace', this.screen.screen.screenSpace);
	  };

	  _proto._onScreenRemove = function _onScreenRemove() {
	    if (this.screen) {
	      if (this.screen._destroying) {
	        this.screen = null;
	      } else {
	        this._updateScreen(null);
	      }
	    }
	  };

	  _proto._calculateLocalAnchors = function _calculateLocalAnchors() {
	    var resx = 1000;
	    var resy = 1000;
	    var parent = this.entity._parent;

	    if (parent && parent.element) {
	      resx = parent.element.calculatedWidth;
	      resy = parent.element.calculatedHeight;
	    } else if (this.screen) {
	      var res = this.screen.screen.resolution;
	      var scale = this.screen.screen.scale;
	      resx = res.x / scale;
	      resy = res.y / scale;
	    }

	    this._localAnchor.set(this._anchor.x * resx, this._anchor.y * resy, this._anchor.z * resx, this._anchor.w * resy);
	  };

	  _proto.getOffsetPosition = function getOffsetPosition(x, y) {
	    var p = this.entity.getLocalPosition().clone();
	    p.x += x;
	    p.y += y;

	    this._screenToWorld.transformPoint(p, p);

	    return p;
	  };

	  _proto.onLayersChanged = function onLayersChanged(oldComp, newComp) {
	    this.addModelToLayers(this._image ? this._image._renderable.model : this._text._model);
	    oldComp.off('add', this.onLayerAdded, this);
	    oldComp.off('remove', this.onLayerRemoved, this);
	    newComp.on('add', this.onLayerAdded, this);
	    newComp.on('remove', this.onLayerRemoved, this);
	  };

	  _proto.onLayerAdded = function onLayerAdded(layer) {
	    var index = this.layers.indexOf(layer.id);
	    if (index < 0) return;

	    if (this._image) {
	      layer.addMeshInstances(this._image._renderable.model.meshInstances);
	    } else if (this._text) {
	      layer.addMeshInstances(this._text._model.meshInstances);
	    }
	  };

	  _proto.onLayerRemoved = function onLayerRemoved(layer) {
	    var index = this.layers.indexOf(layer.id);
	    if (index < 0) return;

	    if (this._image) {
	      layer.removeMeshInstances(this._image._renderable.model.meshInstances);
	    } else if (this._text) {
	      layer.removeMeshInstances(this._text._model.meshInstances);
	    }
	  };

	  _proto.onEnable = function onEnable() {
	    if (this._image) this._image.onEnable();
	    if (this._text) this._text.onEnable();
	    if (this._group) this._group.onEnable();

	    if (this.useInput && this.system.app.elementInput) {
	      this.system.app.elementInput.addElement(this);
	    }

	    this.system.app.scene.on('set:layers', this.onLayersChanged, this);

	    if (this.system.app.scene.layers) {
	      this.system.app.scene.layers.on('add', this.onLayerAdded, this);
	      this.system.app.scene.layers.on('remove', this.onLayerRemoved, this);
	    }

	    if (this._batchGroupId >= 0) {
	      var _this$system$app$batc;

	      (_this$system$app$batc = this.system.app.batcher) == null ? void 0 : _this$system$app$batc.insert(BatchGroup.ELEMENT, this.batchGroupId, this.entity);
	    }

	    this.fire('enableelement');
	  };

	  _proto.onDisable = function onDisable() {
	    this.system.app.scene.off('set:layers', this.onLayersChanged, this);

	    if (this.system.app.scene.layers) {
	      this.system.app.scene.layers.off('add', this.onLayerAdded, this);
	      this.system.app.scene.layers.off('remove', this.onLayerRemoved, this);
	    }

	    if (this._image) this._image.onDisable();
	    if (this._text) this._text.onDisable();
	    if (this._group) this._group.onDisable();

	    if (this.system.app.elementInput && this.useInput) {
	      this.system.app.elementInput.removeElement(this);
	    }

	    if (this._batchGroupId >= 0) {
	      var _this$system$app$batc2;

	      (_this$system$app$batc2 = this.system.app.batcher) == null ? void 0 : _this$system$app$batc2.remove(BatchGroup.ELEMENT, this.batchGroupId, this.entity);
	    }

	    this.fire('disableelement');
	  };

	  _proto.onRemove = function onRemove() {
	    this.entity.off('insert', this._onInsert, this);

	    this._unpatch();

	    if (this._image) this._image.destroy();
	    if (this._text) this._text.destroy();

	    if (this.system.app.elementInput && this.useInput) {
	      this.system.app.elementInput.removeElement(this);
	    }

	    if (this.screen && this.screen.screen) {
	      this._unbindScreen(this.screen.screen);

	      this.screen.screen.syncDrawOrder();
	    }

	    this.off();
	  };

	  _proto._calculateSize = function _calculateSize(propagateCalculatedWidth, propagateCalculatedHeight) {
	    if (!this.entity._parent && !this.screen) return;

	    this._calculateLocalAnchors();

	    var newWidth = this._absRight - this._absLeft;
	    var newHeight = this._absTop - this._absBottom;

	    if (propagateCalculatedWidth) {
	      this._setWidth(newWidth);
	    } else {
	      this._setCalculatedWidth(newWidth, false);
	    }

	    if (propagateCalculatedHeight) {
	      this._setHeight(newHeight);
	    } else {
	      this._setCalculatedHeight(newHeight, false);
	    }

	    var p = this.entity.getLocalPosition();
	    p.x = this._margin.x + this._calculatedWidth * this._pivot.x;
	    p.y = this._margin.y + this._calculatedHeight * this._pivot.y;
	    this.entity.setLocalPosition(p);
	    this._sizeDirty = false;
	  };

	  _proto._setWidth = function _setWidth(w) {
	    this._width = w;

	    this._setCalculatedWidth(w, false);

	    this.fire('set:width', this._width);
	  };

	  _proto._setHeight = function _setHeight(h) {
	    this._height = h;

	    this._setCalculatedHeight(h, false);

	    this.fire('set:height', this._height);
	  };

	  _proto._setCalculatedWidth = function _setCalculatedWidth(value, updateMargins) {
	    if (Math.abs(value - this._calculatedWidth) <= 1e-4) return;
	    this._calculatedWidth = value;

	    this.entity._dirtifyLocal();

	    if (updateMargins) {
	      var p = this.entity.getLocalPosition();
	      var pvt = this._pivot;
	      this._margin.x = p.x - this._calculatedWidth * pvt.x;
	      this._margin.z = this._localAnchor.z - this._localAnchor.x - this._calculatedWidth - this._margin.x;
	    }

	    this._flagChildrenAsDirty();

	    this.fire('set:calculatedWidth', this._calculatedWidth);
	    this.fire('resize', this._calculatedWidth, this._calculatedHeight);
	  };

	  _proto._setCalculatedHeight = function _setCalculatedHeight(value, updateMargins) {
	    if (Math.abs(value - this._calculatedHeight) <= 1e-4) return;
	    this._calculatedHeight = value;

	    this.entity._dirtifyLocal();

	    if (updateMargins) {
	      var p = this.entity.getLocalPosition();
	      var pvt = this._pivot;
	      this._margin.y = p.y - this._calculatedHeight * pvt.y;
	      this._margin.w = this._localAnchor.w - this._localAnchor.y - this._calculatedHeight - this._margin.y;
	    }

	    this._flagChildrenAsDirty();

	    this.fire('set:calculatedHeight', this._calculatedHeight);
	    this.fire('resize', this._calculatedWidth, this._calculatedHeight);
	  };

	  _proto._flagChildrenAsDirty = function _flagChildrenAsDirty() {
	    var c = this.entity._children;

	    for (var i = 0, l = c.length; i < l; i++) {
	      if (c[i].element) {
	        c[i].element._anchorDirty = true;
	        c[i].element._sizeDirty = true;
	      }
	    }
	  };

	  _proto.addModelToLayers = function addModelToLayers(model) {
	    this._addedModels.push(model);

	    for (var i = 0; i < this.layers.length; i++) {
	      var layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
	      if (!layer) continue;
	      layer.addMeshInstances(model.meshInstances);
	    }
	  };

	  _proto.removeModelFromLayers = function removeModelFromLayers(model) {
	    var idx = this._addedModels.indexOf(model);

	    if (idx >= 0) {
	      this._addedModels.splice(idx, 1);
	    }

	    for (var i = 0; i < this.layers.length; i++) {
	      var layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
	      if (!layer) continue;
	      layer.removeMeshInstances(model.meshInstances);
	    }
	  };

	  _proto.getMaskOffset = function getMaskOffset() {
	    var frame = this.system.app.frame;

	    if (this._offsetReadAt !== frame) {
	      this._maskOffset = 0.5;
	      this._offsetReadAt = frame;
	    }

	    var mo = this._maskOffset;
	    this._maskOffset -= 0.001;
	    return mo;
	  };

	  _proto.isVisibleForCamera = function isVisibleForCamera(camera) {
	    var clipL, clipR, clipT, clipB;

	    if (this.maskedBy) {
	      var corners = this.maskedBy.element.screenCorners;
	      clipL = Math.min(Math.min(corners[0].x, corners[1].x), Math.min(corners[2].x, corners[3].x));
	      clipR = Math.max(Math.max(corners[0].x, corners[1].x), Math.max(corners[2].x, corners[3].x));
	      clipB = Math.min(Math.min(corners[0].y, corners[1].y), Math.min(corners[2].y, corners[3].y));
	      clipT = Math.max(Math.max(corners[0].y, corners[1].y), Math.max(corners[2].y, corners[3].y));
	    } else {
	      var sw = this.system.app.graphicsDevice.width;
	      var sh = this.system.app.graphicsDevice.height;
	      var cameraWidth = camera._rect.z * sw;
	      var cameraHeight = camera._rect.w * sh;
	      clipL = camera._rect.x * sw;
	      clipR = clipL + cameraWidth;
	      clipT = (1 - camera._rect.y) * sh;
	      clipB = clipT - cameraHeight;
	    }

	    var hitCorners = this.screenCorners;
	    var left = Math.min(Math.min(hitCorners[0].x, hitCorners[1].x), Math.min(hitCorners[2].x, hitCorners[3].x));
	    var right = Math.max(Math.max(hitCorners[0].x, hitCorners[1].x), Math.max(hitCorners[2].x, hitCorners[3].x));
	    var bottom = Math.min(Math.min(hitCorners[0].y, hitCorners[1].y), Math.min(hitCorners[2].y, hitCorners[3].y));
	    var top = Math.max(Math.max(hitCorners[0].y, hitCorners[1].y), Math.max(hitCorners[2].y, hitCorners[3].y));

	    if (right < clipL || left > clipR || bottom > clipT || top < clipB) {
	      return false;
	    }

	    return true;
	  };

	  _proto._isScreenSpace = function _isScreenSpace() {
	    if (this.screen && this.screen.screen) {
	      return this.screen.screen.screenSpace;
	    }

	    return false;
	  };

	  _proto._isScreenCulled = function _isScreenCulled() {
	    if (this.screen && this.screen.screen) {
	      return this.screen.screen.cull;
	    }

	    return false;
	  };

	  _proto._dirtyBatch = function _dirtyBatch() {
	    if (this.batchGroupId !== -1) {
	      var _this$system$app$batc3;

	      (_this$system$app$batc3 = this.system.app.batcher) == null ? void 0 : _this$system$app$batc3.markGroupDirty(this.batchGroupId);
	    }
	  };

	  _createClass(ElementComponent, [{
	    key: "_absLeft",
	    get: function get() {
	      return this._localAnchor.x + this._margin.x;
	    }
	  }, {
	    key: "_absRight",
	    get: function get() {
	      return this._localAnchor.z - this._margin.z;
	    }
	  }, {
	    key: "_absTop",
	    get: function get() {
	      return this._localAnchor.w - this._margin.w;
	    }
	  }, {
	    key: "_absBottom",
	    get: function get() {
	      return this._localAnchor.y + this._margin.y;
	    }
	  }, {
	    key: "_hasSplitAnchorsX",
	    get: function get() {
	      return Math.abs(this._anchor.x - this._anchor.z) > 0.001;
	    }
	  }, {
	    key: "_hasSplitAnchorsY",
	    get: function get() {
	      return Math.abs(this._anchor.y - this._anchor.w) > 0.001;
	    }
	  }, {
	    key: "aabb",
	    get: function get() {
	      if (this._image) return this._image.aabb;
	      if (this._text) return this._text.aabb;
	      return null;
	    }
	  }, {
	    key: "anchor",
	    get: function get() {
	      return this._anchor;
	    },
	    set: function set(value) {
	      if (value instanceof Vec4) {
	        this._anchor.set(value.x, value.y, value.z, value.w);
	      } else {
	        this._anchor.set(value[0], value[1], value[2], value[3]);
	      }

	      if (!this.entity._parent && !this.screen) {
	        this._calculateLocalAnchors();
	      } else {
	        this._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY);
	      }

	      this._anchorDirty = true;
	      if (!this.entity._dirtyLocal) this.entity._dirtifyLocal();
	      this.fire('set:anchor', this._anchor);
	    }
	  }, {
	    key: "batchGroupId",
	    get: function get() {
	      return this._batchGroupId;
	    },
	    set: function set(value) {
	      if (this._batchGroupId === value) return;

	      if (this.entity.enabled && this._batchGroupId >= 0) {
	        var _this$system$app$batc4;

	        (_this$system$app$batc4 = this.system.app.batcher) == null ? void 0 : _this$system$app$batc4.remove(BatchGroup.ELEMENT, this.batchGroupId, this.entity);
	      }

	      if (this.entity.enabled && value >= 0) {
	        var _this$system$app$batc5;

	        (_this$system$app$batc5 = this.system.app.batcher) == null ? void 0 : _this$system$app$batc5.insert(BatchGroup.ELEMENT, value, this.entity);
	      }

	      if (value < 0 && this._batchGroupId >= 0 && this.enabled && this.entity.enabled) {
	        if (this._image && this._image._renderable.model) {
	          this.addModelToLayers(this._image._renderable.model);
	        } else if (this._text && this._text._model) {
	          this.addModelToLayers(this._text._model);
	        }
	      }

	      this._batchGroupId = value;
	    }
	  }, {
	    key: "bottom",
	    get: function get() {
	      return this._margin.y;
	    },
	    set: function set(value) {
	      this._margin.y = value;
	      var p = this.entity.getLocalPosition();
	      var wt = this._absTop;
	      var wb = this._localAnchor.y + value;

	      this._setHeight(wt - wb);

	      p.y = value + this._calculatedHeight * this._pivot.y;
	      this.entity.setLocalPosition(p);
	    }
	  }, {
	    key: "calculatedWidth",
	    get: function get() {
	      return this._calculatedWidth;
	    },
	    set: function set(value) {
	      this._setCalculatedWidth(value, true);
	    }
	  }, {
	    key: "calculatedHeight",
	    get: function get() {
	      return this._calculatedHeight;
	    },
	    set: function set(value) {
	      this._setCalculatedHeight(value, true);
	    }
	  }, {
	    key: "canvasCorners",
	    get: function get() {
	      if (!this._canvasCornersDirty || !this.screen || !this.screen.screen.screenSpace) return this._canvasCorners;
	      var device = this.system.app.graphicsDevice;
	      var screenCorners = this.screenCorners;
	      var sx = device.canvas.clientWidth / device.width;
	      var sy = device.canvas.clientHeight / device.height;

	      for (var i = 0; i < 4; i++) {
	        this._canvasCorners[i].set(screenCorners[i].x * sx, (device.height - screenCorners[i].y) * sy);
	      }

	      this._canvasCornersDirty = false;
	      return this._canvasCorners;
	    }
	  }, {
	    key: "drawOrder",
	    get: function get() {
	      return this._drawOrder;
	    },
	    set: function set(value) {
	      var priority = 0;

	      if (this.screen) {
	        priority = this.screen.screen.priority;
	      }

	      if (value > 0xFFFFFF) {
	        value = 0xFFFFFF;
	      }

	      this._drawOrder = (priority << 24) + value;
	      this.fire('set:draworder', this._drawOrder);
	    }
	  }, {
	    key: "height",
	    get: function get() {
	      return this._height;
	    },
	    set: function set(value) {
	      this._height = value;

	      if (!this._hasSplitAnchorsY) {
	        this._setCalculatedHeight(value, true);
	      }

	      this.fire('set:height', this._height);
	    }
	  }, {
	    key: "layers",
	    get: function get() {
	      return this._layers;
	    },
	    set: function set(value) {
	      if (this._addedModels.length) {
	        for (var i = 0; i < this._layers.length; i++) {
	          var layer = this.system.app.scene.layers.getLayerById(this._layers[i]);

	          if (layer) {
	            for (var j = 0; j < this._addedModels.length; j++) {
	              layer.removeMeshInstances(this._addedModels[j].meshInstances);
	            }
	          }
	        }
	      }

	      this._layers = value;
	      if (!this.enabled || !this.entity.enabled || !this._addedModels.length) return;

	      for (var _i2 = 0; _i2 < this._layers.length; _i2++) {
	        var _layer = this.system.app.scene.layers.getLayerById(this._layers[_i2]);

	        if (_layer) {
	          for (var _j = 0; _j < this._addedModels.length; _j++) {
	            _layer.addMeshInstances(this._addedModels[_j].meshInstances);
	          }
	        }
	      }
	    }
	  }, {
	    key: "left",
	    get: function get() {
	      return this._margin.x;
	    },
	    set: function set(value) {
	      this._margin.x = value;
	      var p = this.entity.getLocalPosition();
	      var wr = this._absRight;
	      var wl = this._localAnchor.x + value;

	      this._setWidth(wr - wl);

	      p.x = value + this._calculatedWidth * this._pivot.x;
	      this.entity.setLocalPosition(p);
	    }
	  }, {
	    key: "margin",
	    get: function get() {
	      return this._margin;
	    },
	    set: function set(value) {
	      this._margin.copy(value);

	      this._calculateSize(true, true);

	      this.fire('set:margin', this._margin);
	    }
	  }, {
	    key: "maskedBy",
	    get: function get() {
	      return this._maskedBy;
	    }
	  }, {
	    key: "pivot",
	    get: function get() {
	      return this._pivot;
	    },
	    set: function set(value) {
	      var prevX = this._pivot.x;
	      var prevY = this._pivot.y;

	      if (value instanceof Vec2) {
	        this._pivot.set(value.x, value.y);
	      } else {
	        this._pivot.set(value[0], value[1]);
	      }

	      var mx = this._margin.x + this._margin.z;
	      var dx = this._pivot.x - prevX;
	      this._margin.x += mx * dx;
	      this._margin.z -= mx * dx;
	      var my = this._margin.y + this._margin.w;
	      var dy = this._pivot.y - prevY;
	      this._margin.y += my * dy;
	      this._margin.w -= my * dy;
	      this._anchorDirty = true;
	      this._cornersDirty = true;
	      this._worldCornersDirty = true;

	      this._calculateSize(false, false);

	      this._flagChildrenAsDirty();

	      this.fire('set:pivot', this._pivot);
	    }
	  }, {
	    key: "right",
	    get: function get() {
	      return this._margin.z;
	    },
	    set: function set(value) {
	      this._margin.z = value;
	      var p = this.entity.getLocalPosition();
	      var wl = this._absLeft;
	      var wr = this._localAnchor.z - value;

	      this._setWidth(wr - wl);

	      p.x = this._localAnchor.z - this._localAnchor.x - value - this._calculatedWidth * (1 - this._pivot.x);
	      this.entity.setLocalPosition(p);
	    }
	  }, {
	    key: "screenCorners",
	    get: function get() {
	      if (!this._cornersDirty || !this.screen) return this._screenCorners;
	      var parentBottomLeft = this.entity.parent && this.entity.parent.element && this.entity.parent.element.screenCorners[0];

	      this._screenCorners[0].set(this._absLeft, this._absBottom, 0);

	      this._screenCorners[1].set(this._absRight, this._absBottom, 0);

	      this._screenCorners[2].set(this._absRight, this._absTop, 0);

	      this._screenCorners[3].set(this._absLeft, this._absTop, 0);

	      var screenSpace = this.screen.screen.screenSpace;

	      for (var i = 0; i < 4; i++) {
	        this._screenTransform.transformPoint(this._screenCorners[i], this._screenCorners[i]);

	        if (screenSpace) this._screenCorners[i].mulScalar(this.screen.screen.scale);

	        if (parentBottomLeft) {
	          this._screenCorners[i].add(parentBottomLeft);
	        }
	      }

	      this._cornersDirty = false;
	      this._canvasCornersDirty = true;
	      this._worldCornersDirty = true;
	      return this._screenCorners;
	    }
	  }, {
	    key: "textWidth",
	    get: function get() {
	      return this._text ? this._text.width : 0;
	    }
	  }, {
	    key: "textHeight",
	    get: function get() {
	      return this._text ? this._text.height : 0;
	    }
	  }, {
	    key: "top",
	    get: function get() {
	      return this._margin.w;
	    },
	    set: function set(value) {
	      this._margin.w = value;
	      var p = this.entity.getLocalPosition();
	      var wb = this._absBottom;
	      var wt = this._localAnchor.w - value;

	      this._setHeight(wt - wb);

	      p.y = this._localAnchor.w - this._localAnchor.y - value - this._calculatedHeight * (1 - this._pivot.y);
	      this.entity.setLocalPosition(p);
	    }
	  }, {
	    key: "type",
	    get: function get() {
	      return this._type;
	    },
	    set: function set(value) {
	      if (value !== this._type) {
	        this._type = value;

	        if (this._image) {
	          this._image.destroy();

	          this._image = null;
	        }

	        if (this._text) {
	          this._text.destroy();

	          this._text = null;
	        }

	        if (value === ELEMENTTYPE_IMAGE) {
	          this._image = new ImageElement(this);
	        } else if (value === ELEMENTTYPE_TEXT) {
	          this._text = new TextElement(this);
	        }
	      }
	    }
	  }, {
	    key: "useInput",
	    get: function get() {
	      return this._useInput;
	    },
	    set: function set(value) {
	      if (this._useInput === value) return;
	      this._useInput = value;

	      if (this.system.app.elementInput) {
	        if (value) {
	          if (this.enabled && this.entity.enabled) {
	            this.system.app.elementInput.addElement(this);
	          }
	        } else {
	          this.system.app.elementInput.removeElement(this);
	        }
	      } else {
	        if (this._useInput === true) ;
	      }

	      this.fire('set:useInput', value);
	    }
	  }, {
	    key: "fitMode",
	    get: function get() {
	      return this._fitMode;
	    },
	    set: function set(value) {
	      this._fitMode = value;

	      this._calculateSize(true, true);

	      if (this._image) {
	        this._image.refreshMesh();
	      }
	    }
	  }, {
	    key: "width",
	    get: function get() {
	      return this._width;
	    },
	    set: function set(value) {
	      this._width = value;

	      if (!this._hasSplitAnchorsX) {
	        this._setCalculatedWidth(value, true);
	      }

	      this.fire('set:width', this._width);
	    }
	  }, {
	    key: "worldCorners",
	    get: function get() {
	      if (!this._worldCornersDirty) {
	        return this._worldCorners;
	      }

	      if (this.screen) {
	        var screenCorners = this.screenCorners;

	        if (!this.screen.screen.screenSpace) {
	          matA.copy(this.screen.screen._screenMatrix);
	          matA.data[13] = -matA.data[13];
	          matA.mul2(this.screen.getWorldTransform(), matA);

	          for (var i = 0; i < 4; i++) {
	            matA.transformPoint(screenCorners[i], this._worldCorners[i]);
	          }
	        }
	      } else {
	        var localPos = this.entity.getLocalPosition();
	        matA.setTranslate(-localPos.x, -localPos.y, -localPos.z);
	        matB.setTRS(Vec3.ZERO, this.entity.getLocalRotation(), this.entity.getLocalScale());
	        matC.setTranslate(localPos.x, localPos.y, localPos.z);
	        var entity = this.entity.parent ? this.entity.parent : this.entity;
	        matD.copy(entity.getWorldTransform());
	        matD.mul(matC).mul(matB).mul(matA);
	        vecA$1.set(localPos.x - this.pivot.x * this.calculatedWidth, localPos.y - this.pivot.y * this.calculatedHeight, localPos.z);
	        matD.transformPoint(vecA$1, this._worldCorners[0]);
	        vecA$1.set(localPos.x + (1 - this.pivot.x) * this.calculatedWidth, localPos.y - this.pivot.y * this.calculatedHeight, localPos.z);
	        matD.transformPoint(vecA$1, this._worldCorners[1]);
	        vecA$1.set(localPos.x + (1 - this.pivot.x) * this.calculatedWidth, localPos.y + (1 - this.pivot.y) * this.calculatedHeight, localPos.z);
	        matD.transformPoint(vecA$1, this._worldCorners[2]);
	        vecA$1.set(localPos.x - this.pivot.x * this.calculatedWidth, localPos.y + (1 - this.pivot.y) * this.calculatedHeight, localPos.z);
	        matD.transformPoint(vecA$1, this._worldCorners[3]);
	      }

	      this._worldCornersDirty = false;
	      return this._worldCorners;
	    }
	  }]);

	  return ElementComponent;
	}(Component);

	function _define(name) {
	  Object.defineProperty(ElementComponent.prototype, name, {
	    get: function get() {
	      if (this._text) {
	        return this._text[name];
	      } else if (this._image) {
	        return this._image[name];
	      }

	      return null;
	    },
	    set: function set(value) {
	      if (this._text) {
	        if (this._text[name] !== value) {
	          this._dirtyBatch();
	        }

	        this._text[name] = value;
	      } else if (this._image) {
	        if (this._image[name] !== value) {
	          this._dirtyBatch();
	        }

	        this._image[name] = value;
	      }
	    }
	  });
	}

	_define('fontSize');

	_define('minFontSize');

	_define('maxFontSize');

	_define('maxLines');

	_define('autoFitWidth');

	_define('autoFitHeight');

	_define('color');

	_define('font');

	_define('fontAsset');

	_define('spacing');

	_define('lineHeight');

	_define('wrapLines');

	_define('lines');

	_define('alignment');

	_define('autoWidth');

	_define('autoHeight');

	_define('rtlReorder');

	_define('unicodeConverter');

	_define('text');

	_define('key');

	_define('texture');

	_define('textureAsset');

	_define('material');

	_define('materialAsset');

	_define('sprite');

	_define('spriteAsset');

	_define('spriteFrame');

	_define('pixelsPerUnit');

	_define('opacity');

	_define('rect');

	_define('mask');

	_define('outlineColor');

	_define('outlineThickness');

	_define('shadowColor');

	_define('shadowOffset');

	_define('enableMarkup');

	_define('rangeStart');

	_define('rangeEnd');

	var ElementComponentData = function ElementComponentData() {
	  this.enabled = true;
	};

	var _schema$f = ['enabled'];

	var ElementComponentSystem = function (_ComponentSystem) {
	  _inheritsLoose(ElementComponentSystem, _ComponentSystem);

	  function ElementComponentSystem(app) {
	    var _this;

	    _this = _ComponentSystem.call(this, app) || this;
	    _this.id = 'element';
	    _this.ComponentType = ElementComponent;
	    _this.DataType = ElementComponentData;
	    _this.schema = _schema$f;
	    _this._unicodeConverter = null;
	    _this._rtlReorder = null;
	    _this._defaultTexture = new Texture(app.graphicsDevice, {
	      width: 1,
	      height: 1,
	      format: PIXELFORMAT_R8_G8_B8_A8,
	      name: 'element-system'
	    });

	    var pixels = _this._defaultTexture.lock();

	    var pixelData = new Uint8Array(4);
	    pixelData[0] = 255.0;
	    pixelData[1] = 255.0;
	    pixelData[2] = 255.0;
	    pixelData[3] = 255.0;
	    pixels.set(pixelData);

	    _this._defaultTexture.unlock();

	    _this.defaultImageMaterial = null;
	    _this.defaultImage9SlicedMaterial = null;
	    _this.defaultImage9TiledMaterial = null;
	    _this.defaultImageMaskMaterial = null;
	    _this.defaultImage9SlicedMaskMaterial = null;
	    _this.defaultImage9TiledMaskMaterial = null;
	    _this.defaultScreenSpaceImageMaterial = null;
	    _this.defaultScreenSpaceImage9SlicedMaterial = null;
	    _this.defaultScreenSpaceImage9TiledMaterial = null;
	    _this.defaultScreenSpaceImageMask9SlicedMaterial = null;
	    _this.defaultScreenSpaceImageMask9TiledMaterial = null;
	    _this.defaultScreenSpaceImageMaskMaterial = null;
	    _this._defaultTextMaterials = {};
	    _this.defaultImageMaterials = [];

	    _this.on('beforeremove', _this.onRemoveComponent, _assertThisInitialized(_this));

	    return _this;
	  }

	  var _proto = ElementComponentSystem.prototype;

	  _proto.destroy = function destroy() {
	    _ComponentSystem.prototype.destroy.call(this);

	    this._defaultTexture.destroy();
	  };

	  _proto.initializeComponentData = function initializeComponentData(component, data, properties) {
	    component._beingInitialized = true;

	    if (data.anchor !== undefined) {
	      if (data.anchor instanceof Vec4) {
	        component.anchor.copy(data.anchor);
	      } else {
	        component.anchor.set(data.anchor[0], data.anchor[1], data.anchor[2], data.anchor[3]);
	      }
	    }

	    if (data.pivot !== undefined) {
	      if (data.pivot instanceof Vec2) {
	        component.pivot.copy(data.pivot);
	      } else {
	        component.pivot.set(data.pivot[0], data.pivot[1]);
	      }
	    }

	    var splitHorAnchors = Math.abs(component.anchor.x - component.anchor.z) > 0.001;
	    var splitVerAnchors = Math.abs(component.anchor.y - component.anchor.w) > 0.001;
	    var _marginChange = false;
	    var color;

	    if (data.margin !== undefined) {
	      if (data.margin instanceof Vec4) {
	        component.margin.copy(data.margin);
	      } else {
	        component._margin.set(data.margin[0], data.margin[1], data.margin[2], data.margin[3]);
	      }

	      _marginChange = true;
	    }

	    if (data.left !== undefined) {
	      component._margin.x = data.left;
	      _marginChange = true;
	    }

	    if (data.bottom !== undefined) {
	      component._margin.y = data.bottom;
	      _marginChange = true;
	    }

	    if (data.right !== undefined) {
	      component._margin.z = data.right;
	      _marginChange = true;
	    }

	    if (data.top !== undefined) {
	      component._margin.w = data.top;
	      _marginChange = true;
	    }

	    if (_marginChange) {
	      component.margin = component._margin;
	    }

	    var shouldForceSetAnchor = false;

	    if (data.width !== undefined && !splitHorAnchors) {
	      component.width = data.width;
	    } else if (splitHorAnchors) {
	      shouldForceSetAnchor = true;
	    }

	    if (data.height !== undefined && !splitVerAnchors) {
	      component.height = data.height;
	    } else if (splitVerAnchors) {
	      shouldForceSetAnchor = true;
	    }

	    if (shouldForceSetAnchor) {
	      component.anchor = component.anchor;
	    }

	    if (data.enabled !== undefined) {
	      component.enabled = data.enabled;
	    }

	    if (data.useInput !== undefined) {
	      component.useInput = data.useInput;
	    }

	    if (data.fitMode !== undefined) {
	      component.fitMode = data.fitMode;
	    }

	    component.batchGroupId = data.batchGroupId === undefined || data.batchGroupId === null ? -1 : data.batchGroupId;

	    if (data.layers && Array.isArray(data.layers)) {
	      component.layers = data.layers.slice(0);
	    }

	    if (data.type !== undefined) {
	      component.type = data.type;
	    }

	    if (component.type === ELEMENTTYPE_IMAGE) {
	      if (data.rect !== undefined) {
	        component.rect = data.rect;
	      }

	      if (data.color !== undefined) {
	        color = data.color;

	        if (!(color instanceof Color)) {
	          color = new Color(data.color[0], data.color[1], data.color[2]);
	        }

	        component.color = color;
	      }

	      if (data.opacity !== undefined) component.opacity = data.opacity;
	      if (data.textureAsset !== undefined) component.textureAsset = data.textureAsset;
	      if (data.texture) component.texture = data.texture;
	      if (data.spriteAsset !== undefined) component.spriteAsset = data.spriteAsset;
	      if (data.sprite) component.sprite = data.sprite;
	      if (data.spriteFrame !== undefined) component.spriteFrame = data.spriteFrame;
	      if (data.pixelsPerUnit !== undefined && data.pixelsPerUnit !== null) component.pixelsPerUnit = data.pixelsPerUnit;
	      if (data.materialAsset !== undefined) component.materialAsset = data.materialAsset;
	      if (data.material) component.material = data.material;

	      if (data.mask !== undefined) {
	        component.mask = data.mask;
	      }
	    } else if (component.type === ELEMENTTYPE_TEXT) {
	      if (data.autoWidth !== undefined) component.autoWidth = data.autoWidth;
	      if (data.autoHeight !== undefined) component.autoHeight = data.autoHeight;
	      if (data.rtlReorder !== undefined) component.rtlReorder = data.rtlReorder;
	      if (data.unicodeConverter !== undefined) component.unicodeConverter = data.unicodeConverter;

	      if (data.text !== null && data.text !== undefined) {
	        component.text = data.text;
	      } else if (data.key !== null && data.key !== undefined) {
	        component.key = data.key;
	      }

	      if (data.color !== undefined) {
	        color = data.color;

	        if (!(color instanceof Color)) {
	          color = new Color(color[0], color[1], color[2]);
	        }

	        component.color = color;
	      }

	      if (data.opacity !== undefined) {
	        component.opacity = data.opacity;
	      }

	      if (data.spacing !== undefined) component.spacing = data.spacing;

	      if (data.fontSize !== undefined) {
	        component.fontSize = data.fontSize;
	        if (!data.lineHeight) component.lineHeight = data.fontSize;
	      }

	      if (data.lineHeight !== undefined) component.lineHeight = data.lineHeight;
	      if (data.maxLines !== undefined) component.maxLines = data.maxLines;
	      if (data.wrapLines !== undefined) component.wrapLines = data.wrapLines;
	      if (data.minFontSize !== undefined) component.minFontSize = data.minFontSize;
	      if (data.maxFontSize !== undefined) component.maxFontSize = data.maxFontSize;
	      if (data.autoFitWidth) component.autoFitWidth = data.autoFitWidth;
	      if (data.autoFitHeight) component.autoFitHeight = data.autoFitHeight;
	      if (data.fontAsset !== undefined) component.fontAsset = data.fontAsset;
	      if (data.font !== undefined) component.font = data.font;
	      if (data.alignment !== undefined) component.alignment = data.alignment;
	      if (data.outlineColor !== undefined) component.outlineColor = data.outlineColor;
	      if (data.outlineThickness !== undefined) component.outlineThickness = data.outlineThickness;
	      if (data.shadowColor !== undefined) component.shadowColor = data.shadowColor;
	      if (data.shadowOffset !== undefined) component.shadowOffset = data.shadowOffset;
	      if (data.enableMarkup !== undefined) component.enableMarkup = data.enableMarkup;
	    }

	    var result = component._parseUpToScreen();

	    if (result.screen) {
	      component._updateScreen(result.screen);
	    }

	    _ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);

	    component._beingInitialized = false;

	    if (component.type === ELEMENTTYPE_IMAGE && component._image._meshDirty) {
	      component._image._updateMesh(component._image.mesh);
	    }
	  };

	  _proto.onRemoveComponent = function onRemoveComponent(entity, component) {
	    component.onRemove();
	  };

	  _proto.cloneComponent = function cloneComponent(entity, clone) {
	    var source = entity.element;
	    var data = {
	      enabled: source.enabled,
	      width: source.width,
	      height: source.height,
	      anchor: source.anchor.clone(),
	      pivot: source.pivot.clone(),
	      margin: source.margin.clone(),
	      alignment: source.alignment && source.alignment.clone() || source.alignment,
	      autoWidth: source.autoWidth,
	      autoHeight: source.autoHeight,
	      type: source.type,
	      rect: source.rect && source.rect.clone() || source.rect,
	      rtlReorder: source.rtlReorder,
	      unicodeConverter: source.unicodeConverter,
	      materialAsset: source.materialAsset,
	      material: source.material,
	      color: source.color && source.color.clone() || source.color,
	      opacity: source.opacity,
	      textureAsset: source.textureAsset,
	      texture: source.texture,
	      spriteAsset: source.spriteAsset,
	      sprite: source.sprite,
	      spriteFrame: source.spriteFrame,
	      pixelsPerUnit: source.pixelsPerUnit,
	      spacing: source.spacing,
	      lineHeight: source.lineHeight,
	      wrapLines: source.wrapLines,
	      layers: source.layers,
	      fontSize: source.fontSize,
	      minFontSize: source.minFontSize,
	      maxFontSize: source.maxFontSize,
	      autoFitWidth: source.autoFitWidth,
	      autoFitHeight: source.autoFitHeight,
	      maxLines: source.maxLines,
	      fontAsset: source.fontAsset,
	      font: source.font,
	      useInput: source.useInput,
	      fitMode: source.fitMode,
	      batchGroupId: source.batchGroupId,
	      mask: source.mask,
	      outlineColor: source.outlineColor && source.outlineColor.clone() || source.outlineColor,
	      outlineThickness: source.outlineThickness,
	      shadowColor: source.shadowColor && source.shadowColor.clone() || source.shadowColor,
	      shadowOffset: source.shadowOffset && source.shadowOffset.clone() || source.shadowOffset,
	      enableMarkup: source.enableMarkup
	    };

	    if (source.key !== undefined && source.key !== null) {
	      data.key = source.key;
	    } else {
	      data.text = source.text;
	    }

	    return this.addComponent(clone, data);
	  };

	  _proto.getTextElementMaterial = function getTextElementMaterial(screenSpace, msdf, textAttibutes) {
	    var hash = (screenSpace && 1 << 0) | (msdf && 1 << 1) | (textAttibutes && 1 << 2);
	    var material = this._defaultTextMaterials[hash];

	    if (material) {
	      return material;
	    }

	    var name = "TextMaterial";
	    material = new StandardMaterial();

	    if (msdf) {
	      material.msdfMap = this._defaultTexture;
	      material.msdfTextAttribute = textAttibutes;
	      material.emissive.set(1, 1, 1);
	    } else {
	      name = "Bitmap" + name;
	      material.emissive.set(0.5, 0.5, 0.5);
	      material.emissiveMap = this._defaultTexture;
	      material.emissiveTint = true;
	      material.opacityMap = this._defaultTexture;
	      material.opacityMapChannel = 'a';
	    }

	    if (screenSpace) {
	      name = 'ScreenSpace' + name;
	      material.depthTest = false;
	    }

	    material.name = 'default' + name;
	    material.useLighting = false;
	    material.useGammaTonemap = false;
	    material.useFog = false;
	    material.useSkybox = false;
	    material.diffuse.set(0, 0, 0);
	    material.opacity = 0.5;
	    material.blendType = BLEND_PREMULTIPLIED;
	    material.depthWrite = false;
	    material.emissiveVertexColor = true;
	    material.update();
	    this._defaultTextMaterials[hash] = material;
	    return material;
	  };

	  _proto._createBaseImageMaterial = function _createBaseImageMaterial() {
	    var material = new StandardMaterial();
	    material.diffuse.set(0, 0, 0);
	    material.emissive.set(0.5, 0.5, 0.5);
	    material.emissiveMap = this._defaultTexture;
	    material.emissiveTint = true;
	    material.opacityMap = this._defaultTexture;
	    material.opacityMapChannel = 'a';
	    material.opacityTint = true;
	    material.opacity = 0;
	    material.useLighting = false;
	    material.useGammaTonemap = false;
	    material.useFog = false;
	    material.useSkybox = false;
	    material.blendType = BLEND_PREMULTIPLIED;
	    material.depthWrite = false;
	    return material;
	  };

	  _proto.getImageElementMaterial = function getImageElementMaterial(screenSpace, mask, nineSliced, nineSliceTiled) {
	    if (screenSpace) {
	      if (mask) {
	        if (nineSliced) {
	          if (!this.defaultScreenSpaceImageMask9SlicedMaterial) {
	            this.defaultScreenSpaceImageMask9SlicedMaterial = this._createBaseImageMaterial();
	            this.defaultScreenSpaceImageMask9SlicedMaterial.name = 'defaultScreenSpaceImageMask9SlicedMaterial';
	            this.defaultScreenSpaceImageMask9SlicedMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;
	            this.defaultScreenSpaceImageMask9SlicedMaterial.depthTest = false;
	            this.defaultScreenSpaceImageMask9SlicedMaterial.alphaTest = 1;
	            this.defaultScreenSpaceImageMask9SlicedMaterial.redWrite = false;
	            this.defaultScreenSpaceImageMask9SlicedMaterial.greenWrite = false;
	            this.defaultScreenSpaceImageMask9SlicedMaterial.blueWrite = false;
	            this.defaultScreenSpaceImageMask9SlicedMaterial.alphaWrite = false;
	            this.defaultScreenSpaceImageMask9SlicedMaterial.update();
	            this.defaultImageMaterials.push(this.defaultScreenSpaceImageMask9SlicedMaterial);
	          }

	          return this.defaultScreenSpaceImageMask9SlicedMaterial;
	        } else if (nineSliceTiled) {
	          if (!this.defaultScreenSpaceImageMask9TiledMaterial) {
	            this.defaultScreenSpaceImageMask9TiledMaterial = this.defaultScreenSpaceImage9TiledMaterial.clone();
	            this.defaultScreenSpaceImageMask9TiledMaterial.name = 'defaultScreenSpaceImageMask9TiledMaterial';
	            this.defaultScreenSpaceImageMask9TiledMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;
	            this.defaultScreenSpaceImageMask9TiledMaterial.depthTest = false;
	            this.defaultScreenSpaceImageMask9TiledMaterial.alphaTest = 1;
	            this.defaultScreenSpaceImageMask9TiledMaterial.redWrite = false;
	            this.defaultScreenSpaceImageMask9TiledMaterial.greenWrite = false;
	            this.defaultScreenSpaceImageMask9TiledMaterial.blueWrite = false;
	            this.defaultScreenSpaceImageMask9TiledMaterial.alphaWrite = false;
	            this.defaultScreenSpaceImageMask9TiledMaterial.update();
	            this.defaultImageMaterials.push(this.defaultScreenSpaceImageMask9TiledMaterial);
	          }

	          return this.defaultScreenSpaceImageMask9TiledMaterial;
	        } else {
	          if (!this.defaultScreenSpaceImageMaskMaterial) {
	            this.defaultScreenSpaceImageMaskMaterial = this._createBaseImageMaterial();
	            this.defaultScreenSpaceImageMaskMaterial.name = 'defaultScreenSpaceImageMaskMaterial';
	            this.defaultScreenSpaceImageMaskMaterial.depthTest = false;
	            this.defaultScreenSpaceImageMaskMaterial.alphaTest = 1;
	            this.defaultScreenSpaceImageMaskMaterial.redWrite = false;
	            this.defaultScreenSpaceImageMaskMaterial.greenWrite = false;
	            this.defaultScreenSpaceImageMaskMaterial.blueWrite = false;
	            this.defaultScreenSpaceImageMaskMaterial.alphaWrite = false;
	            this.defaultScreenSpaceImageMaskMaterial.update();
	            this.defaultImageMaterials.push(this.defaultScreenSpaceImageMaskMaterial);
	          }

	          return this.defaultScreenSpaceImageMaskMaterial;
	        }
	      } else {
	        if (nineSliced) {
	          if (!this.defaultScreenSpaceImage9SlicedMaterial) {
	            this.defaultScreenSpaceImage9SlicedMaterial = this._createBaseImageMaterial();
	            this.defaultScreenSpaceImage9SlicedMaterial.name = 'defaultScreenSpaceImage9SlicedMaterial';
	            this.defaultScreenSpaceImage9SlicedMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;
	            this.defaultScreenSpaceImage9SlicedMaterial.depthTest = false;
	            this.defaultScreenSpaceImage9SlicedMaterial.update();
	            this.defaultImageMaterials.push(this.defaultScreenSpaceImage9SlicedMaterial);
	          }

	          return this.defaultScreenSpaceImage9SlicedMaterial;
	        } else if (nineSliceTiled) {
	          if (!this.defaultScreenSpaceImage9TiledMaterial) {
	            this.defaultScreenSpaceImage9TiledMaterial = this._createBaseImageMaterial();
	            this.defaultScreenSpaceImage9TiledMaterial.name = 'defaultScreenSpaceImage9TiledMaterial';
	            this.defaultScreenSpaceImage9TiledMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;
	            this.defaultScreenSpaceImage9TiledMaterial.depthTest = false;
	            this.defaultScreenSpaceImage9TiledMaterial.update();
	            this.defaultImageMaterials.push(this.defaultScreenSpaceImage9TiledMaterial);
	          }

	          return this.defaultScreenSpaceImage9TiledMaterial;
	        } else {
	          if (!this.defaultScreenSpaceImageMaterial) {
	            this.defaultScreenSpaceImageMaterial = this._createBaseImageMaterial();
	            this.defaultScreenSpaceImageMaterial.name = 'defaultScreenSpaceImageMaterial';
	            this.defaultScreenSpaceImageMaterial.depthTest = false;
	            this.defaultScreenSpaceImageMaterial.update();
	            this.defaultImageMaterials.push(this.defaultScreenSpaceImageMaterial);
	          }

	          return this.defaultScreenSpaceImageMaterial;
	        }
	      }
	    } else {
	      if (mask) {
	        if (nineSliced) {
	          if (!this.defaultImage9SlicedMaskMaterial) {
	            this.defaultImage9SlicedMaskMaterial = this._createBaseImageMaterial();
	            this.defaultImage9SlicedMaskMaterial.name = 'defaultImage9SlicedMaskMaterial';
	            this.defaultImage9SlicedMaskMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;
	            this.defaultImage9SlicedMaskMaterial.alphaTest = 1;
	            this.defaultImage9SlicedMaskMaterial.redWrite = false;
	            this.defaultImage9SlicedMaskMaterial.greenWrite = false;
	            this.defaultImage9SlicedMaskMaterial.blueWrite = false;
	            this.defaultImage9SlicedMaskMaterial.alphaWrite = false;
	            this.defaultImage9SlicedMaskMaterial.update();
	            this.defaultImageMaterials.push(this.defaultImage9SlicedMaskMaterial);
	          }

	          return this.defaultImage9SlicedMaskMaterial;
	        } else if (nineSliceTiled) {
	          if (!this.defaultImage9TiledMaskMaterial) {
	            this.defaultImage9TiledMaskMaterial = this._createBaseImageMaterial();
	            this.defaultImage9TiledMaskMaterial.name = 'defaultImage9TiledMaskMaterial';
	            this.defaultImage9TiledMaskMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;
	            this.defaultImage9TiledMaskMaterial.alphaTest = 1;
	            this.defaultImage9TiledMaskMaterial.redWrite = false;
	            this.defaultImage9TiledMaskMaterial.greenWrite = false;
	            this.defaultImage9TiledMaskMaterial.blueWrite = false;
	            this.defaultImage9TiledMaskMaterial.alphaWrite = false;
	            this.defaultImage9TiledMaskMaterial.update();
	            this.defaultImageMaterials.push(this.defaultImage9TiledMaskMaterial);
	          }

	          return this.defaultImage9TiledMaskMaterial;
	        } else {
	          if (!this.defaultImageMaskMaterial) {
	            this.defaultImageMaskMaterial = this._createBaseImageMaterial();
	            this.defaultImageMaskMaterial.name = 'defaultImageMaskMaterial';
	            this.defaultImageMaskMaterial.alphaTest = 1;
	            this.defaultImageMaskMaterial.redWrite = false;
	            this.defaultImageMaskMaterial.greenWrite = false;
	            this.defaultImageMaskMaterial.blueWrite = false;
	            this.defaultImageMaskMaterial.alphaWrite = false;
	            this.defaultImageMaskMaterial.update();
	            this.defaultImageMaterials.push(this.defaultImageMaskMaterial);
	          }

	          return this.defaultImageMaskMaterial;
	        }
	      } else {
	        if (nineSliced) {
	          if (!this.defaultImage9SlicedMaterial) {
	            this.defaultImage9SlicedMaterial = this._createBaseImageMaterial();
	            this.defaultImage9SlicedMaterial.name = 'defaultImage9SlicedMaterial';
	            this.defaultImage9SlicedMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;
	            this.defaultImage9SlicedMaterial.update();
	            this.defaultImageMaterials.push(this.defaultImage9SlicedMaterial);
	          }

	          return this.defaultImage9SlicedMaterial;
	        } else if (nineSliceTiled) {
	          if (!this.defaultImage9TiledMaterial) {
	            this.defaultImage9TiledMaterial = this._createBaseImageMaterial();
	            this.defaultImage9TiledMaterial.name = 'defaultImage9TiledMaterial';
	            this.defaultImage9TiledMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;
	            this.defaultImage9TiledMaterial.update();
	            this.defaultImageMaterials.push(this.defaultImage9TiledMaterial);
	          }

	          return this.defaultImage9TiledMaterial;
	        } else {
	          if (!this.defaultImageMaterial) {
	            this.defaultImageMaterial = this._createBaseImageMaterial();
	            this.defaultImageMaterial.name = 'defaultImageMaterial';
	            this.defaultImageMaterial.update();
	            this.defaultImageMaterials.push(this.defaultImageMaterial);
	          }

	          return this.defaultImageMaterial;
	        }
	      }
	    }
	  };

	  _proto.registerUnicodeConverter = function registerUnicodeConverter(func) {
	    this._unicodeConverter = func;
	  };

	  _proto.registerRtlReorder = function registerRtlReorder(func) {
	    this._rtlReorder = func;
	  };

	  _proto.getUnicodeConverter = function getUnicodeConverter() {
	    return this._unicodeConverter;
	  };

	  _proto.getRtlReorder = function getRtlReorder() {
	    return this._rtlReorder;
	  };

	  return ElementComponentSystem;
	}(ComponentSystem);

	Component._buildAccessors(ElementComponent.prototype, _schema$f);

	var MOTION_FREE = 'free';
	var MOTION_LIMITED = 'limited';
	var MOTION_LOCKED = 'locked';

	var properties$1 = ['angularDampingX', 'angularDampingY', 'angularDampingZ', 'angularEquilibriumX', 'angularEquilibriumY', 'angularEquilibriumZ', 'angularLimitsX', 'angularLimitsY', 'angularLimitsZ', 'angularMotionX', 'angularMotionY', 'angularMotionZ', 'angularSpringX', 'angularSpringY', 'angularSpringZ', 'angularStiffnessX', 'angularStiffnessY', 'angularStiffnessZ', 'breakForce', 'enableCollision', 'enabled', 'entityA', 'entityB', 'linearDampingX', 'linearDampingY', 'linearDampingZ', 'linearEquilibriumX', 'linearEquilibriumY', 'linearEquilibriumZ', 'linearLimitsX', 'linearLimitsY', 'linearLimitsZ', 'linearMotionX', 'linearMotionY', 'linearMotionZ', 'linearSpringX', 'linearSpringY', 'linearSpringZ', 'linearStiffnessX', 'linearStiffnessY', 'linearStiffnessZ'];

	var JointComponent = function (_Component) {
	  _inheritsLoose(JointComponent, _Component);

	  function JointComponent(system, entity) {
	    var _this;

	    _this = _Component.call(this, system, entity) || this;
	    _this._constraint = null;
	    _this._entityA = null;
	    _this._entityB = null;
	    _this._breakForce = 3.4e+38;
	    _this._enableCollision = true;
	    _this._linearMotionX = MOTION_LOCKED;
	    _this._linearLimitsX = new Vec2(0, 0);
	    _this._linearSpringX = false;
	    _this._linearStiffnessX = 0;
	    _this._linearDampingX = 1;
	    _this._linearEquilibriumX = 0;
	    _this._linearMotionY = MOTION_LOCKED;
	    _this._linearLimitsY = new Vec2(0, 0);
	    _this._linearSpringY = false;
	    _this._linearStiffnessY = 0;
	    _this._linearDampingY = 1;
	    _this._linearEquilibriumY = 0;
	    _this._linearMotionZ = MOTION_LOCKED;
	    _this._linearLimitsZ = new Vec2(0, 0);
	    _this._linearSpringZ = false;
	    _this._linearStiffnessZ = 0;
	    _this._linearDampingZ = 1;
	    _this._linearEquilibriumZ = 0;
	    _this._angularMotionX = MOTION_LOCKED;
	    _this._angularLimitsX = new Vec2(0, 0);
	    _this._angularSpringX = false;
	    _this._angularStiffnessX = 0;
	    _this._angularDampingX = 1;
	    _this._angularEquilibriumX = 0;
	    _this._angularMotionY = MOTION_LOCKED;
	    _this._angularLimitsY = new Vec2(0, 0);
	    _this._angularSpringY = false;
	    _this._angularStiffnessY = 0;
	    _this._angularDampingY = 1;
	    _this._angularEquilibriumY = 0;
	    _this._angularMotionZ = MOTION_LOCKED;
	    _this._angularLimitsZ = new Vec2(0, 0);
	    _this._angularSpringZ = false;
	    _this._angularEquilibriumZ = 0;
	    _this._angularDampingZ = 1;
	    _this._angularStiffnessZ = 0;

	    _this.on('set_enabled', _this._onSetEnabled, _assertThisInitialized(_this));

	    return _this;
	  }

	  var _proto = JointComponent.prototype;

	  _proto._convertTransform = function _convertTransform(pcTransform, ammoTransform) {
	    var pos = pcTransform.getTranslation();
	    var rot = new Quat();
	    rot.setFromMat4(pcTransform);
	    var ammoVec = new Ammo.btVector3(pos.x, pos.y, pos.z);
	    var ammoQuat = new Ammo.btQuaternion(rot.x, rot.y, rot.z, rot.w);
	    ammoTransform.setOrigin(ammoVec);
	    ammoTransform.setRotation(ammoQuat);
	    Ammo.destroy(ammoVec);
	    Ammo.destroy(ammoQuat);
	  };

	  _proto._updateAngularLimits = function _updateAngularLimits() {
	    var constraint = this._constraint;

	    if (constraint) {
	      var lx, ly, lz, ux, uy, uz;

	      if (this._angularMotionX === MOTION_LIMITED) {
	        lx = this._angularLimitsX.x * math.DEG_TO_RAD;
	        ux = this._angularLimitsX.y * math.DEG_TO_RAD;
	      } else if (this._angularMotionX === MOTION_FREE) {
	        lx = 1;
	        ux = 0;
	      } else {
	        lx = ux = 0;
	      }

	      if (this._angularMotionY === MOTION_LIMITED) {
	        ly = this._angularLimitsY.x * math.DEG_TO_RAD;
	        uy = this._angularLimitsY.y * math.DEG_TO_RAD;
	      } else if (this._angularMotionY === MOTION_FREE) {
	        ly = 1;
	        uy = 0;
	      } else {
	        ly = uy = 0;
	      }

	      if (this._angularMotionZ === MOTION_LIMITED) {
	        lz = this._angularLimitsZ.x * math.DEG_TO_RAD;
	        uz = this._angularLimitsZ.y * math.DEG_TO_RAD;
	      } else if (this._angularMotionZ === MOTION_FREE) {
	        lz = 1;
	        uz = 0;
	      } else {
	        lz = uz = 0;
	      }

	      var limits = new Ammo.btVector3(lx, ly, lz);
	      constraint.setAngularLowerLimit(limits);
	      limits.setValue(ux, uy, uz);
	      constraint.setAngularUpperLimit(limits);
	      Ammo.destroy(limits);
	    }
	  };

	  _proto._updateLinearLimits = function _updateLinearLimits() {
	    var constraint = this._constraint;

	    if (constraint) {
	      var lx, ly, lz, ux, uy, uz;

	      if (this._linearMotionX === MOTION_LIMITED) {
	        lx = this._linearLimitsX.x;
	        ux = this._linearLimitsX.y;
	      } else if (this._linearMotionX === MOTION_FREE) {
	        lx = 1;
	        ux = 0;
	      } else {
	        lx = ux = 0;
	      }

	      if (this._linearMotionY === MOTION_LIMITED) {
	        ly = this._linearLimitsY.x;
	        uy = this._linearLimitsY.y;
	      } else if (this._linearMotionY === MOTION_FREE) {
	        ly = 1;
	        uy = 0;
	      } else {
	        ly = uy = 0;
	      }

	      if (this._linearMotionZ === MOTION_LIMITED) {
	        lz = this._linearLimitsZ.x;
	        uz = this._linearLimitsZ.y;
	      } else if (this._linearMotionZ === MOTION_FREE) {
	        lz = 1;
	        uz = 0;
	      } else {
	        lz = uz = 0;
	      }

	      var limits = new Ammo.btVector3(lx, ly, lz);
	      constraint.setLinearLowerLimit(limits);
	      limits.setValue(ux, uy, uz);
	      constraint.setLinearUpperLimit(limits);
	      Ammo.destroy(limits);
	    }
	  };

	  _proto._createConstraint = function _createConstraint() {
	    if (this._entityA && this._entityA.rigidbody) {
	      this._destroyConstraint();

	      var mat = new Mat4();
	      var bodyA = this._entityA.rigidbody.body;
	      bodyA.activate();
	      var jointWtm = this.entity.getWorldTransform();

	      var entityAWtm = this._entityA.getWorldTransform();

	      var invEntityAWtm = entityAWtm.clone().invert();
	      mat.mul2(invEntityAWtm, jointWtm);
	      var frameA = new Ammo.btTransform();

	      this._convertTransform(mat, frameA);

	      if (this._entityB && this._entityB.rigidbody) {
	        var bodyB = this._entityB.rigidbody.body;
	        bodyB.activate();

	        var entityBWtm = this._entityB.getWorldTransform();

	        var invEntityBWtm = entityBWtm.clone().invert();
	        mat.mul2(invEntityBWtm, jointWtm);
	        var frameB = new Ammo.btTransform();

	        this._convertTransform(mat, frameB);

	        this._constraint = new Ammo.btGeneric6DofSpringConstraint(bodyA, bodyB, frameA, frameB, !this._enableCollision);
	        Ammo.destroy(frameB);
	      } else {
	        this._constraint = new Ammo.btGeneric6DofSpringConstraint(bodyA, frameA, !this._enableCollision);
	      }

	      Ammo.destroy(frameA);
	      var axis = ['X', 'Y', 'Z', 'X', 'Y', 'Z'];

	      for (var i = 0; i < 6; i++) {
	        var type = i < 3 ? '_linear' : '_angular';

	        this._constraint.enableSpring(i, this[type + 'Spring' + axis[i]]);

	        this._constraint.setDamping(i, this[type + 'Damping' + axis[i]]);

	        this._constraint.setEquilibriumPoint(i, this[type + 'Equilibrium' + axis[i]]);

	        this._constraint.setStiffness(i, this[type + 'Stiffness' + axis[i]]);
	      }

	      this._constraint.setBreakingImpulseThreshold(this._breakForce);

	      this._updateLinearLimits();

	      this._updateAngularLimits();

	      var app = this.system.app;
	      var dynamicsWorld = app.systems.rigidbody.dynamicsWorld;
	      dynamicsWorld.addConstraint(this._constraint, !this._enableCollision);
	    }
	  };

	  _proto._destroyConstraint = function _destroyConstraint() {
	    if (this._constraint) {
	      var app = this.system.app;
	      var dynamicsWorld = app.systems.rigidbody.dynamicsWorld;
	      dynamicsWorld.removeConstraint(this._constraint);
	      Ammo.destroy(this._constraint);
	      this._constraint = null;
	    }
	  };

	  _proto.initFromData = function initFromData(data) {
	    for (var _iterator = _createForOfIteratorHelperLoose(properties$1), _step; !(_step = _iterator()).done;) {
	      var prop = _step.value;

	      if (data.hasOwnProperty(prop)) {
	        if (data[prop] instanceof Vec2) {
	          this['_' + prop].copy(data[prop]);
	        } else {
	          this['_' + prop] = data[prop];
	        }
	      }
	    }

	    this._createConstraint();
	  };

	  _proto.onEnable = function onEnable() {
	    this._createConstraint();
	  };

	  _proto.onDisable = function onDisable() {
	    this._destroyConstraint();
	  };

	  _proto._onSetEnabled = function _onSetEnabled(prop, old, value) {};

	  _proto._onBeforeRemove = function _onBeforeRemove() {
	    this.fire('remove');
	  };

	  _createClass(JointComponent, [{
	    key: "entityA",
	    get: function get() {
	      return this._entityA;
	    },
	    set: function set(body) {
	      this._destroyConstraint();

	      this._entityA = body;

	      this._createConstraint();
	    }
	  }, {
	    key: "entityB",
	    get: function get() {
	      return this._entityB;
	    },
	    set: function set(body) {
	      this._destroyConstraint();

	      this._entityB = body;

	      this._createConstraint();
	    }
	  }, {
	    key: "breakForce",
	    get: function get() {
	      return this._breakForce;
	    },
	    set: function set(force) {
	      if (this._constraint && this._breakForce !== force) {
	        this._constraint.setBreakingImpulseThreshold(force);

	        this._breakForce = force;
	      }
	    }
	  }, {
	    key: "enableCollision",
	    get: function get() {
	      return this._enableCollision;
	    },
	    set: function set(enableCollision) {
	      this._destroyConstraint();

	      this._enableCollision = enableCollision;

	      this._createConstraint();
	    }
	  }, {
	    key: "angularLimitsX",
	    get: function get() {
	      return this._angularLimitsX;
	    },
	    set: function set(limits) {
	      if (!this._angularLimitsX.equals(limits)) {
	        this._angularLimitsX.copy(limits);

	        this._updateAngularLimits();
	      }
	    }
	  }, {
	    key: "angularMotionX",
	    get: function get() {
	      return this._angularMotionX;
	    },
	    set: function set(value) {
	      if (this._angularMotionX !== value) {
	        this._angularMotionX = value;

	        this._updateAngularLimits();
	      }
	    }
	  }, {
	    key: "angularLimitsY",
	    get: function get() {
	      return this._angularLimitsY;
	    },
	    set: function set(limits) {
	      if (!this._angularLimitsY.equals(limits)) {
	        this._angularLimitsY.copy(limits);

	        this._updateAngularLimits();
	      }
	    }
	  }, {
	    key: "angularMotionY",
	    get: function get() {
	      return this._angularMotionY;
	    },
	    set: function set(value) {
	      if (this._angularMotionY !== value) {
	        this._angularMotionY = value;

	        this._updateAngularLimits();
	      }
	    }
	  }, {
	    key: "angularLimitsZ",
	    get: function get() {
	      return this._angularLimitsZ;
	    },
	    set: function set(limits) {
	      if (!this._angularLimitsZ.equals(limits)) {
	        this._angularLimitsZ.copy(limits);

	        this._updateAngularLimits();
	      }
	    }
	  }, {
	    key: "angularMotionZ",
	    get: function get() {
	      return this._angularMotionZ;
	    },
	    set: function set(value) {
	      if (this._angularMotionZ !== value) {
	        this._angularMotionZ = value;

	        this._updateAngularLimits();
	      }
	    }
	  }, {
	    key: "linearLimitsX",
	    get: function get() {
	      return this._linearLimitsX;
	    },
	    set: function set(limits) {
	      if (!this._linearLimitsX.equals(limits)) {
	        this._linearLimitsX.copy(limits);

	        this._updateLinearLimits();
	      }
	    }
	  }, {
	    key: "linearMotionX",
	    get: function get() {
	      return this._linearMotionX;
	    },
	    set: function set(value) {
	      if (this._linearMotionX !== value) {
	        this._linearMotionX = value;

	        this._updateLinearLimits();
	      }
	    }
	  }, {
	    key: "linearLimitsY",
	    get: function get() {
	      return this._linearLimitsY;
	    },
	    set: function set(limits) {
	      if (!this._linearLimitsY.equals(limits)) {
	        this._linearLimitsY.copy(limits);

	        this._updateLinearLimits();
	      }
	    }
	  }, {
	    key: "linearMotionY",
	    get: function get() {
	      return this._linearMotionY;
	    },
	    set: function set(value) {
	      if (this._linearMotionY !== value) {
	        this._linearMotionY = value;

	        this._updateLinearLimits();
	      }
	    }
	  }, {
	    key: "linearLimitsZ",
	    get: function get() {
	      return this._linearLimitsZ;
	    },
	    set: function set(limits) {
	      if (!this._linearLimitsZ.equals(limits)) {
	        this._linearLimitsZ.copy(limits);

	        this._updateLinearLimits();
	      }
	    }
	  }, {
	    key: "linearMotionZ",
	    get: function get() {
	      return this._linearMotionZ;
	    },
	    set: function set(value) {
	      if (this._linearMotionZ !== value) {
	        this._linearMotionZ = value;

	        this._updateLinearLimits();
	      }
	    }
	  }]);

	  return JointComponent;
	}(Component);

	var functionMap = {
	  Damping: 'setDamping',
	  Equilibrium: 'setEquilibriumPoint',
	  Spring: 'enableSpring',
	  Stiffness: 'setStiffness'
	};
	['linear', 'angular'].forEach(function (type) {
	  ['Damping', 'Equilibrium', 'Spring', 'Stiffness'].forEach(function (name) {
	    ['X', 'Y', 'Z'].forEach(function (axis) {
	      var prop = type + name + axis;
	      var propInternal = '_' + prop;
	      var index = type === 'linear' ? 0 : 3;
	      if (axis === 'Y') index += 1;
	      if (axis === 'Z') index += 2;
	      Object.defineProperty(JointComponent.prototype, prop, {
	        get: function get() {
	          return this[propInternal];
	        },
	        set: function set(value) {
	          if (this[propInternal] !== value) {
	            this[propInternal] = value;

	            this._constraint[functionMap[name]](index, value);
	          }
	        }
	      });
	    });
	  });
	});

	var JointComponentData = function JointComponentData() {
	  this.enabled = true;
	};

	var _schema$e = ['enabled'];

	var JointComponentSystem = function (_ComponentSystem) {
	  _inheritsLoose(JointComponentSystem, _ComponentSystem);

	  function JointComponentSystem(app) {
	    var _this;

	    _this = _ComponentSystem.call(this, app) || this;
	    _this.id = 'joint';
	    _this.app = app;
	    _this.ComponentType = JointComponent;
	    _this.DataType = JointComponentData;
	    _this.schema = _schema$e;
	    return _this;
	  }

	  var _proto = JointComponentSystem.prototype;

	  _proto.initializeComponentData = function initializeComponentData(component, data, properties) {
	    component.initFromData(data);
	  };

	  return JointComponentSystem;
	}(ComponentSystem);

	Component._buildAccessors(JointComponent.prototype, _schema$e);

	var LayoutChildComponent = function (_Component) {
	  _inheritsLoose(LayoutChildComponent, _Component);

	  function LayoutChildComponent(system, entity) {
	    var _this;

	    _this = _Component.call(this, system, entity) || this;
	    _this._minWidth = 0;
	    _this._minHeight = 0;
	    _this._maxWidth = null;
	    _this._maxHeight = null;
	    _this._fitWidthProportion = 0;
	    _this._fitHeightProportion = 0;
	    _this._excludeFromLayout = false;
	    return _this;
	  }

	  _createClass(LayoutChildComponent, [{
	    key: "minWidth",
	    get: function get() {
	      return this._minWidth;
	    },
	    set: function set(value) {
	      if (value !== this._minWidth) {
	        this._minWidth = value;
	        this.fire('resize');
	      }
	    }
	  }, {
	    key: "minHeight",
	    get: function get() {
	      return this._minHeight;
	    },
	    set: function set(value) {
	      if (value !== this._minHeight) {
	        this._minHeight = value;
	        this.fire('resize');
	      }
	    }
	  }, {
	    key: "maxWidth",
	    get: function get() {
	      return this._maxWidth;
	    },
	    set: function set(value) {
	      if (value !== this._maxWidth) {
	        this._maxWidth = value;
	        this.fire('resize');
	      }
	    }
	  }, {
	    key: "maxHeight",
	    get: function get() {
	      return this._maxHeight;
	    },
	    set: function set(value) {
	      if (value !== this._maxHeight) {
	        this._maxHeight = value;
	        this.fire('resize');
	      }
	    }
	  }, {
	    key: "fitWidthProportion",
	    get: function get() {
	      return this._fitWidthProportion;
	    },
	    set: function set(value) {
	      if (value !== this._fitWidthProportion) {
	        this._fitWidthProportion = value;
	        this.fire('resize');
	      }
	    }
	  }, {
	    key: "fitHeightProportion",
	    get: function get() {
	      return this._fitHeightProportion;
	    },
	    set: function set(value) {
	      if (value !== this._fitHeightProportion) {
	        this._fitHeightProportion = value;
	        this.fire('resize');
	      }
	    }
	  }, {
	    key: "excludeFromLayout",
	    get: function get() {
	      return this._excludeFromLayout;
	    },
	    set: function set(value) {
	      if (value !== this._excludeFromLayout) {
	        this._excludeFromLayout = value;
	        this.fire('resize');
	      }
	    }
	  }]);

	  return LayoutChildComponent;
	}(Component);

	var LayoutChildComponentData = function LayoutChildComponentData() {
	  this.enabled = true;
	};

	var _schema$d = ['enabled'];

	var LayoutChildComponentSystem = function (_ComponentSystem) {
	  _inheritsLoose(LayoutChildComponentSystem, _ComponentSystem);

	  function LayoutChildComponentSystem(app) {
	    var _this;

	    _this = _ComponentSystem.call(this, app) || this;
	    _this.id = 'layoutchild';
	    _this.ComponentType = LayoutChildComponent;
	    _this.DataType = LayoutChildComponentData;
	    _this.schema = _schema$d;
	    return _this;
	  }

	  var _proto = LayoutChildComponentSystem.prototype;

	  _proto.initializeComponentData = function initializeComponentData(component, data, properties) {
	    if (data.enabled !== undefined) component.enabled = data.enabled;
	    if (data.minWidth !== undefined) component.minWidth = data.minWidth;
	    if (data.minHeight !== undefined) component.minHeight = data.minHeight;
	    if (data.maxWidth !== undefined) component.maxWidth = data.maxWidth;
	    if (data.maxHeight !== undefined) component.maxHeight = data.maxHeight;
	    if (data.fitWidthProportion !== undefined) component.fitWidthProportion = data.fitWidthProportion;
	    if (data.fitHeightProportion !== undefined) component.fitHeightProportion = data.fitHeightProportion;
	    if (data.excludeFromLayout !== undefined) component.excludeFromLayout = data.excludeFromLayout;

	    _ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
	  };

	  _proto.cloneComponent = function cloneComponent(entity, clone) {
	    var layoutChild = entity.layoutchild;
	    return this.addComponent(clone, {
	      enabled: layoutChild.enabled,
	      minWidth: layoutChild.minWidth,
	      minHeight: layoutChild.minHeight,
	      maxWidth: layoutChild.maxWidth,
	      maxHeight: layoutChild.maxHeight,
	      fitWidthProportion: layoutChild.fitWidthProportion,
	      fitHeightProportion: layoutChild.fitHeightProportion,
	      excludeFromLayout: layoutChild.excludeFromLayout
	    });
	  };

	  return LayoutChildComponentSystem;
	}(ComponentSystem);

	Component._buildAccessors(LayoutChildComponent.prototype, _schema$d);

	var FITTING_NONE = 0;
	var FITTING_STRETCH = 1;
	var FITTING_SHRINK = 2;
	var FITTING_BOTH = 3;

	var AXIS_MAPPINGS = {};
	AXIS_MAPPINGS[ORIENTATION_HORIZONTAL] = {
	  axis: 'x',
	  size: 'width',
	  calculatedSize: 'calculatedWidth',
	  minSize: 'minWidth',
	  maxSize: 'maxWidth',
	  fitting: 'widthFitting',
	  fittingProportion: 'fitWidthProportion'
	};
	AXIS_MAPPINGS[ORIENTATION_VERTICAL] = {
	  axis: 'y',
	  size: 'height',
	  calculatedSize: 'calculatedHeight',
	  minSize: 'minHeight',
	  maxSize: 'maxHeight',
	  fitting: 'heightFitting',
	  fittingProportion: 'fitHeightProportion'
	};
	var OPPOSITE_ORIENTATION = {};
	OPPOSITE_ORIENTATION[ORIENTATION_HORIZONTAL] = ORIENTATION_VERTICAL;
	OPPOSITE_ORIENTATION[ORIENTATION_VERTICAL] = ORIENTATION_HORIZONTAL;
	var PROPERTY_DEFAULTS = {
	  minWidth: 0,
	  minHeight: 0,
	  maxWidth: Number.POSITIVE_INFINITY,
	  maxHeight: Number.POSITIVE_INFINITY,
	  width: null,
	  height: null,
	  fitWidthProportion: 0,
	  fitHeightProportion: 0
	};
	var FITTING_ACTION = {
	  NONE: 'NONE',
	  APPLY_STRETCHING: 'APPLY_STRETCHING',
	  APPLY_SHRINKING: 'APPLY_SHRINKING'
	};
	var availableSpace = new Vec2();

	function createCalculator(orientation) {
	  var options;
	  var a = AXIS_MAPPINGS[orientation];
	  var b = AXIS_MAPPINGS[OPPOSITE_ORIENTATION[orientation]];

	  function minExtentA(element, size) {
	    return -size[a.size] * element.pivot[a.axis];
	  }

	  function minExtentB(element, size) {
	    return -size[b.size] * element.pivot[b.axis];
	  }

	  function maxExtentA(element, size) {
	    return size[a.size] * (1 - element.pivot[a.axis]);
	  }

	  function calculateAll(allElements, layoutOptions) {
	    allElements = allElements.filter(shouldIncludeInLayout);
	    options = layoutOptions;
	    availableSpace.x = options.containerSize.x - options.padding.x - options.padding.z;
	    availableSpace.y = options.containerSize.y - options.padding.y - options.padding.w;
	    resetAnchors(allElements);
	    var lines = reverseLinesIfRequired(splitLines(allElements));
	    var sizes = calculateSizesOnAxisB(lines, calculateSizesOnAxisA(lines));
	    var positions = calculateBasePositions(lines, sizes);
	    applyAlignmentAndPadding(lines, sizes, positions);
	    applySizesAndPositions(lines, sizes, positions);
	    return createLayoutInfo(lines);
	  }

	  function shouldIncludeInLayout(element) {
	    var layoutChildComponent = element.entity.layoutchild;
	    return !layoutChildComponent || !layoutChildComponent.enabled || !layoutChildComponent.excludeFromLayout;
	  }

	  function resetAnchors(allElements) {
	    for (var i = 0; i < allElements.length; ++i) {
	      var element = allElements[i];
	      var anchor = element.anchor;

	      if (anchor.x !== 0 || anchor.y !== 0 || anchor.z !== 0 || anchor.w !== 0) {
	        element.anchor = Vec4.ZERO;
	      }
	    }
	  }

	  function splitLines(allElements) {
	    if (!options.wrap) {
	      return [allElements];
	    }

	    var lines = [[]];
	    var sizes = getElementSizeProperties(allElements);
	    var runningSize = 0;
	    var allowOverrun = options[a.fitting] === FITTING_SHRINK;

	    for (var i = 0; i < allElements.length; ++i) {
	      if (lines[lines.length - 1].length > 0) {
	        runningSize += options.spacing[a.axis];
	      }

	      var idealElementSize = sizes[i][a.size];
	      runningSize += idealElementSize;

	      if (!allowOverrun && runningSize > availableSpace[a.axis] && lines[lines.length - 1].length !== 0) {
	        runningSize = idealElementSize;
	        lines.push([]);
	      }

	      lines[lines.length - 1].push(allElements[i]);

	      if (allowOverrun && runningSize > availableSpace[a.axis] && i !== allElements.length - 1) {
	        runningSize = 0;
	        lines.push([]);
	      }
	    }

	    return lines;
	  }

	  function reverseLinesIfRequired(lines) {
	    var reverseAxisA = options.orientation === ORIENTATION_HORIZONTAL && options.reverseX || options.orientation === ORIENTATION_VERTICAL && options.reverseY;
	    var reverseAxisB = options.orientation === ORIENTATION_HORIZONTAL && options.reverseY || options.orientation === ORIENTATION_VERTICAL && options.reverseX;

	    if (reverseAxisA) {
	      for (var lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
	        if (reverseAxisA) {
	          lines[lineIndex].reverse();
	        }
	      }
	    }

	    if (reverseAxisB) {
	      lines.reverse();
	    }

	    return lines;
	  }

	  function calculateSizesOnAxisA(lines) {
	    var sizesAllLines = [];

	    for (var lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
	      var line = lines[lineIndex];
	      var sizesThisLine = getElementSizeProperties(line);
	      var idealRequiredSpace = calculateTotalSpace(sizesThisLine, a);
	      var fittingAction = determineFittingAction(options[a.fitting], idealRequiredSpace, availableSpace[a.axis]);

	      if (fittingAction === FITTING_ACTION.APPLY_STRETCHING) {
	        stretchSizesToFitContainer(sizesThisLine, idealRequiredSpace, a);
	      } else if (fittingAction === FITTING_ACTION.APPLY_SHRINKING) {
	        shrinkSizesToFitContainer(sizesThisLine, idealRequiredSpace, a);
	      }

	      sizesAllLines.push(sizesThisLine);
	    }

	    return sizesAllLines;
	  }

	  function calculateSizesOnAxisB(lines, sizesAllLines) {
	    var largestElementsForEachLine = [];
	    var largestSizesForEachLine = [];

	    for (var lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
	      var line = lines[lineIndex];
	      line.largestElement = null;
	      line.largestSize = {
	        width: Number.NEGATIVE_INFINITY,
	        height: Number.NEGATIVE_INFINITY
	      };

	      for (var elementIndex = 0; elementIndex < line.length; ++elementIndex) {
	        var sizesThisElement = sizesAllLines[lineIndex][elementIndex];

	        if (sizesThisElement[b.size] > line.largestSize[b.size]) {
	          line.largestElement = line[elementIndex];
	          line.largestSize = sizesThisElement;
	        }
	      }

	      largestElementsForEachLine.push(line.largestElement);
	      largestSizesForEachLine.push(line.largestSize);
	    }

	    var idealRequiredSpace = calculateTotalSpace(largestSizesForEachLine, b);
	    var fittingAction = determineFittingAction(options[b.fitting], idealRequiredSpace, availableSpace[b.axis]);

	    if (fittingAction === FITTING_ACTION.APPLY_STRETCHING) {
	      stretchSizesToFitContainer(largestSizesForEachLine, idealRequiredSpace, b);
	    } else if (fittingAction === FITTING_ACTION.APPLY_SHRINKING) {
	      shrinkSizesToFitContainer(largestSizesForEachLine, idealRequiredSpace, b);
	    }

	    for (var _lineIndex = 0; _lineIndex < lines.length; ++_lineIndex) {
	      var _line = lines[_lineIndex];

	      for (var _elementIndex = 0; _elementIndex < _line.length; ++_elementIndex) {
	        var sizesForThisElement = sizesAllLines[_lineIndex][_elementIndex];
	        var currentSize = sizesForThisElement[b.size];
	        var availableSize = lines.length === 1 ? availableSpace[b.axis] : _line.largestSize[b.size];
	        var elementFittingAction = determineFittingAction(options[b.fitting], currentSize, availableSize);

	        if (elementFittingAction === FITTING_ACTION.APPLY_STRETCHING) {
	          sizesForThisElement[b.size] = Math.min(availableSize, sizesForThisElement[b.maxSize]);
	        } else if (elementFittingAction === FITTING_ACTION.APPLY_SHRINKING) {
	          sizesForThisElement[b.size] = Math.max(availableSize, sizesForThisElement[b.minSize]);
	        }
	      }
	    }

	    return sizesAllLines;
	  }

	  function determineFittingAction(fittingMode, currentSize, availableSize) {
	    switch (fittingMode) {
	      case FITTING_NONE:
	        return FITTING_ACTION.NONE;

	      case FITTING_STRETCH:
	        if (currentSize < availableSize) {
	          return FITTING_ACTION.APPLY_STRETCHING;
	        }

	        return FITTING_ACTION.NONE;

	      case FITTING_SHRINK:
	        if (currentSize >= availableSize) {
	          return FITTING_ACTION.APPLY_SHRINKING;
	        }

	        return FITTING_ACTION.NONE;

	      case FITTING_BOTH:
	        if (currentSize < availableSize) {
	          return FITTING_ACTION.APPLY_STRETCHING;
	        }

	        return FITTING_ACTION.APPLY_SHRINKING;

	      default:
	        throw new Error("Unrecognized fitting mode: " + fittingMode);
	    }
	  }

	  function calculateTotalSpace(sizes, axis) {
	    var totalSizes = sumValues(sizes, axis.size);
	    var totalSpacing = (sizes.length - 1) * options.spacing[axis.axis];
	    return totalSizes + totalSpacing;
	  }

	  function stretchSizesToFitContainer(sizesThisLine, idealRequiredSpace, axis) {
	    var ascendingMaxSizeOrder = getTraversalOrder(sizesThisLine, axis.maxSize);
	    var fittingProportions = getNormalizedValues(sizesThisLine, axis.fittingProportion);
	    var fittingProportionSums = createSumArray(fittingProportions, ascendingMaxSizeOrder);
	    var remainingUndershoot = availableSpace[axis.axis] - idealRequiredSpace;

	    for (var i = 0; i < sizesThisLine.length; ++i) {
	      var index = ascendingMaxSizeOrder[i];
	      var targetIncrease = calculateAdjustment(index, remainingUndershoot, fittingProportions, fittingProportionSums);
	      var targetSize = sizesThisLine[index][axis.size] + targetIncrease;
	      var maxSize = sizesThisLine[index][axis.maxSize];
	      var actualSize = Math.min(targetSize, maxSize);
	      sizesThisLine[index][axis.size] = actualSize;
	      var actualIncrease = Math.max(targetSize - actualSize, 0);
	      var appliedIncrease = targetIncrease - actualIncrease;
	      remainingUndershoot -= appliedIncrease;
	    }
	  }

	  function shrinkSizesToFitContainer(sizesThisLine, idealRequiredSpace, axis) {
	    var descendingMinSizeOrder = getTraversalOrder(sizesThisLine, axis.minSize, true);
	    var fittingProportions = getNormalizedValues(sizesThisLine, axis.fittingProportion);
	    var inverseFittingProportions = invertNormalizedValues(fittingProportions);
	    var inverseFittingProportionSums = createSumArray(inverseFittingProportions, descendingMinSizeOrder);
	    var remainingOvershoot = idealRequiredSpace - availableSpace[axis.axis];

	    for (var i = 0; i < sizesThisLine.length; ++i) {
	      var index = descendingMinSizeOrder[i];
	      var targetReduction = calculateAdjustment(index, remainingOvershoot, inverseFittingProportions, inverseFittingProportionSums);
	      var targetSize = sizesThisLine[index][axis.size] - targetReduction;
	      var minSize = sizesThisLine[index][axis.minSize];
	      var actualSize = Math.max(targetSize, minSize);
	      sizesThisLine[index][axis.size] = actualSize;
	      var actualReduction = Math.max(actualSize - targetSize, 0);
	      var appliedReduction = targetReduction - actualReduction;
	      remainingOvershoot -= appliedReduction;
	    }
	  }

	  function calculateAdjustment(index, remainingAdjustment, fittingProportions, fittingProportionSums) {
	    var proportion = fittingProportions[index];
	    var sumOfRemainingProportions = fittingProportionSums[index];

	    if (Math.abs(proportion) < 1e-5 && Math.abs(sumOfRemainingProportions) < 1e-5) {
	      return remainingAdjustment;
	    }

	    return remainingAdjustment * proportion / sumOfRemainingProportions;
	  }

	  function calculateBasePositions(lines, sizes) {
	    var cursor = {};
	    cursor[a.axis] = 0;
	    cursor[b.axis] = 0;
	    lines[a.size] = Number.NEGATIVE_INFINITY;
	    var positionsAllLines = [];

	    for (var lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
	      var line = lines[lineIndex];

	      if (line.length === 0) {
	        positionsAllLines.push([]);
	        continue;
	      }

	      var positionsThisLine = [];
	      var sizesThisLine = sizes[lineIndex];

	      for (var elementIndex = 0; elementIndex < line.length; ++elementIndex) {
	        var element = line[elementIndex];
	        var sizesThisElement = sizesThisLine[elementIndex];
	        cursor[b.axis] -= minExtentB(element, sizesThisElement);
	        cursor[a.axis] -= minExtentA(element, sizesThisElement);
	        positionsThisLine[elementIndex] = {};
	        positionsThisLine[elementIndex][a.axis] = cursor[a.axis];
	        positionsThisLine[elementIndex][b.axis] = cursor[b.axis];
	        cursor[b.axis] += minExtentB(element, sizesThisElement);
	        cursor[a.axis] += maxExtentA(element, sizesThisElement) + options.spacing[a.axis];
	      }

	      line[a.size] = cursor[a.axis] - options.spacing[a.axis];
	      line[b.size] = line.largestSize[b.size];
	      lines[a.size] = Math.max(lines[a.size], line[a.size]);
	      cursor[a.axis] = 0;
	      cursor[b.axis] += line[b.size] + options.spacing[b.axis];
	      positionsAllLines.push(positionsThisLine);
	    }

	    lines[b.size] = cursor[b.axis] - options.spacing[b.axis];
	    return positionsAllLines;
	  }

	  function applyAlignmentAndPadding(lines, sizes, positions) {
	    var alignmentA = options.alignment[a.axis];
	    var alignmentB = options.alignment[b.axis];
	    var paddingA = options.padding[a.axis];
	    var paddingB = options.padding[b.axis];

	    for (var lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
	      var line = lines[lineIndex];
	      var sizesThisLine = sizes[lineIndex];
	      var positionsThisLine = positions[lineIndex];
	      var axisAOffset = (availableSpace[a.axis] - line[a.size]) * alignmentA + paddingA;
	      var axisBOffset = (availableSpace[b.axis] - lines[b.size]) * alignmentB + paddingB;

	      for (var elementIndex = 0; elementIndex < line.length; ++elementIndex) {
	        var withinLineAxisBOffset = (line[b.size] - sizesThisLine[elementIndex][b.size]) * options.alignment[b.axis];
	        positionsThisLine[elementIndex][a.axis] += axisAOffset;
	        positionsThisLine[elementIndex][b.axis] += axisBOffset + withinLineAxisBOffset;
	      }
	    }
	  }

	  function applySizesAndPositions(lines, sizes, positions) {
	    for (var lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
	      var line = lines[lineIndex];
	      var sizesThisLine = sizes[lineIndex];
	      var positionsThisLine = positions[lineIndex];

	      for (var elementIndex = 0; elementIndex < line.length; ++elementIndex) {
	        var element = line[elementIndex];
	        element[a.calculatedSize] = sizesThisLine[elementIndex][a.size];
	        element[b.calculatedSize] = sizesThisLine[elementIndex][b.size];

	        if (options.orientation === ORIENTATION_HORIZONTAL) {
	          element.entity.setLocalPosition(positionsThisLine[elementIndex][a.axis], positionsThisLine[elementIndex][b.axis], element.entity.getLocalPosition().z);
	        } else {
	          element.entity.setLocalPosition(positionsThisLine[elementIndex][b.axis], positionsThisLine[elementIndex][a.axis], element.entity.getLocalPosition().z);
	        }
	      }
	    }
	  }

	  function createLayoutInfo(lines) {
	    var layoutWidth = lines.width;
	    var layoutHeight = lines.height;
	    var xOffset = (availableSpace.x - layoutWidth) * options.alignment.x + options.padding.x;
	    var yOffset = (availableSpace.y - layoutHeight) * options.alignment.y + options.padding.y;
	    return {
	      bounds: new Vec4(xOffset, yOffset, layoutWidth, layoutHeight)
	    };
	  }

	  function getElementSizeProperties(elements) {
	    var sizeProperties = [];

	    for (var i = 0; i < elements.length; ++i) {
	      var element = elements[i];
	      var minWidth = Math.max(getProperty(element, 'minWidth'), 0);
	      var minHeight = Math.max(getProperty(element, 'minHeight'), 0);
	      var maxWidth = Math.max(getProperty(element, 'maxWidth'), minWidth);
	      var maxHeight = Math.max(getProperty(element, 'maxHeight'), minHeight);
	      var width = clamp(getProperty(element, 'width'), minWidth, maxWidth);
	      var height = clamp(getProperty(element, 'height'), minHeight, maxHeight);
	      var fitWidthProportion = getProperty(element, 'fitWidthProportion');
	      var fitHeightProportion = getProperty(element, 'fitHeightProportion');
	      sizeProperties.push({
	        minWidth: minWidth,
	        minHeight: minHeight,
	        maxWidth: maxWidth,
	        maxHeight: maxHeight,
	        width: width,
	        height: height,
	        fitWidthProportion: fitWidthProportion,
	        fitHeightProportion: fitHeightProportion
	      });
	    }

	    return sizeProperties;
	  }

	  function getProperty(element, propertyName) {
	    var layoutChildComponent = element.entity.layoutchild;

	    if (layoutChildComponent && layoutChildComponent.enabled && layoutChildComponent[propertyName] !== undefined && layoutChildComponent[propertyName] !== null) {
	      return layoutChildComponent[propertyName];
	    } else if (element[propertyName] !== undefined) {
	      return element[propertyName];
	    }

	    return PROPERTY_DEFAULTS[propertyName];
	  }

	  function clamp(value, min, max) {
	    return Math.min(Math.max(value, min), max);
	  }

	  function sumValues(items, propertyName) {
	    return items.reduce(function (accumulator, current) {
	      return accumulator + current[propertyName];
	    }, 0);
	  }

	  function getNormalizedValues(items, propertyName) {
	    var sum = sumValues(items, propertyName);
	    var normalizedValues = [];
	    var numItems = items.length;

	    if (sum === 0) {
	      for (var i = 0; i < numItems; ++i) {
	        normalizedValues.push(1 / numItems);
	      }
	    } else {
	      for (var _i = 0; _i < numItems; ++_i) {
	        normalizedValues.push(items[_i][propertyName] / sum);
	      }
	    }

	    return normalizedValues;
	  }

	  function invertNormalizedValues(values) {
	    if (values.length === 1) {
	      return [1];
	    }

	    var invertedValues = [];
	    var numValues = values.length;

	    for (var i = 0; i < numValues; ++i) {
	      invertedValues.push((1 - values[i]) / (numValues - 1));
	    }

	    return invertedValues;
	  }

	  function getTraversalOrder(items, orderBy, descending) {
	    items.forEach(assignIndex);
	    return items.slice().sort(function (itemA, itemB) {
	      return descending ? itemB[orderBy] - itemA[orderBy] : itemA[orderBy] - itemB[orderBy];
	    }).map(getIndex);
	  }

	  function assignIndex(item, index) {
	    item.index = index;
	  }

	  function getIndex(item) {
	    return item.index;
	  }

	  function createSumArray(values, order) {
	    var sumArray = [];
	    sumArray[order[values.length - 1]] = values[order[values.length - 1]];

	    for (var i = values.length - 2; i >= 0; --i) {
	      sumArray[order[i]] = sumArray[order[i + 1]] + values[order[i]];
	    }

	    return sumArray;
	  }

	  return calculateAll;
	}

	var CALCULATE_FNS = {};
	CALCULATE_FNS[ORIENTATION_HORIZONTAL] = createCalculator(ORIENTATION_HORIZONTAL);
	CALCULATE_FNS[ORIENTATION_VERTICAL] = createCalculator(ORIENTATION_VERTICAL);

	var LayoutCalculator = function () {
	  function LayoutCalculator() {}

	  var _proto = LayoutCalculator.prototype;

	  _proto.calculateLayout = function calculateLayout(elements, options) {
	    var calculateFn = CALCULATE_FNS[options.orientation];

	    if (!calculateFn) {
	      throw new Error('Unrecognized orientation value: ' + options.orientation);
	    } else {
	      return calculateFn(elements, options);
	    }
	  };

	  return LayoutCalculator;
	}();

	function getElement(entity) {
	  return entity.element;
	}

	function isEnabledAndHasEnabledElement(entity) {
	  return entity.enabled && entity.element && entity.element.enabled;
	}

	var LayoutGroupComponent = function (_Component) {
	  _inheritsLoose(LayoutGroupComponent, _Component);

	  function LayoutGroupComponent(system, entity) {
	    var _this;

	    _this = _Component.call(this, system, entity) || this;
	    _this._orientation = ORIENTATION_HORIZONTAL;
	    _this._reverseX = false;
	    _this._reverseY = true;
	    _this._alignment = new Vec2(0, 1);
	    _this._padding = new Vec4();
	    _this._spacing = new Vec2();
	    _this._widthFitting = FITTING_NONE;
	    _this._heightFitting = FITTING_NONE;
	    _this._wrap = false;
	    _this._layoutCalculator = new LayoutCalculator();

	    _this._listenForReflowEvents(_this.entity, 'on');

	    _this.entity.children.forEach(function (child) {
	      _this._listenForReflowEvents(child, 'on');
	    });

	    _this.entity.on('childinsert', _this._onChildInsert, _assertThisInitialized(_this));

	    _this.entity.on('childremove', _this._onChildRemove, _assertThisInitialized(_this));

	    system.app.systems.element.on('add', _this._onElementOrLayoutComponentAdd, _assertThisInitialized(_this));
	    system.app.systems.element.on('beforeremove', _this._onElementOrLayoutComponentRemove, _assertThisInitialized(_this));
	    system.app.systems.layoutchild.on('add', _this._onElementOrLayoutComponentAdd, _assertThisInitialized(_this));
	    system.app.systems.layoutchild.on('beforeremove', _this._onElementOrLayoutComponentRemove, _assertThisInitialized(_this));
	    return _this;
	  }

	  var _proto = LayoutGroupComponent.prototype;

	  _proto._isSelfOrChild = function _isSelfOrChild(entity) {
	    return entity === this.entity || this.entity.children.indexOf(entity) !== -1;
	  };

	  _proto._listenForReflowEvents = function _listenForReflowEvents(target, onOff) {
	    if (target.element) {
	      target.element[onOff]('enableelement', this._scheduleReflow, this);
	      target.element[onOff]('disableelement', this._scheduleReflow, this);
	      target.element[onOff]('resize', this._scheduleReflow, this);
	      target.element[onOff]('set:pivot', this._scheduleReflow, this);
	    }

	    if (target.layoutchild) {
	      target.layoutchild[onOff]('set_enabled', this._scheduleReflow, this);
	      target.layoutchild[onOff]('resize', this._scheduleReflow, this);
	    }
	  };

	  _proto._onElementOrLayoutComponentAdd = function _onElementOrLayoutComponentAdd(entity) {
	    if (this._isSelfOrChild(entity)) {
	      this._listenForReflowEvents(entity, 'on');

	      this._scheduleReflow();
	    }
	  };

	  _proto._onElementOrLayoutComponentRemove = function _onElementOrLayoutComponentRemove(entity) {
	    if (this._isSelfOrChild(entity)) {
	      this._listenForReflowEvents(entity, 'off');

	      this._scheduleReflow();
	    }
	  };

	  _proto._onChildInsert = function _onChildInsert(child) {
	    this._listenForReflowEvents(child, 'on');

	    this._scheduleReflow();
	  };

	  _proto._onChildRemove = function _onChildRemove(child) {
	    this._listenForReflowEvents(child, 'off');

	    this._scheduleReflow();
	  };

	  _proto._scheduleReflow = function _scheduleReflow() {
	    if (this.enabled && this.entity && this.entity.enabled && !this._isPerformingReflow) {
	      this.system.scheduleReflow(this);
	    }
	  };

	  _proto.reflow = function reflow() {
	    var container = getElement(this.entity);
	    var elements = this.entity.children.filter(isEnabledAndHasEnabledElement).map(getElement);

	    if (!container || elements.length === 0) {
	      return;
	    }

	    var containerWidth = Math.max(container.calculatedWidth, 0);
	    var containerHeight = Math.max(container.calculatedHeight, 0);
	    var options = {
	      orientation: this._orientation,
	      reverseX: this._reverseX,
	      reverseY: this._reverseY,
	      alignment: this._alignment,
	      padding: this._padding,
	      spacing: this._spacing,
	      widthFitting: this._widthFitting,
	      heightFitting: this._heightFitting,
	      wrap: this._wrap,
	      containerSize: new Vec2(containerWidth, containerHeight)
	    };
	    this._isPerformingReflow = true;

	    var layoutInfo = this._layoutCalculator.calculateLayout(elements, options);

	    this._isPerformingReflow = false;
	    this.fire('reflow', layoutInfo);
	  };

	  _proto.onEnable = function onEnable() {
	    this._scheduleReflow();
	  };

	  _proto.onRemove = function onRemove() {
	    var _this2 = this;

	    this.entity.off('childinsert', this._onChildInsert, this);
	    this.entity.off('childremove', this._onChildRemove, this);

	    this._listenForReflowEvents(this.entity, 'off');

	    this.entity.children.forEach(function (child) {
	      _this2._listenForReflowEvents(child, 'off');
	    });
	    this.system.app.systems.element.off('add', this._onElementOrLayoutComponentAdd, this);
	    this.system.app.systems.element.off('beforeremove', this._onElementOrLayoutComponentRemove, this);
	    this.system.app.systems.layoutchild.off('add', this._onElementOrLayoutComponentAdd, this);
	    this.system.app.systems.layoutchild.off('beforeremove', this._onElementOrLayoutComponentRemove, this);
	  };

	  _createClass(LayoutGroupComponent, [{
	    key: "orientation",
	    get: function get() {
	      return this._orientation;
	    },
	    set: function set(value) {
	      if (value !== this._orientation) {
	        this._orientation = value;

	        this._scheduleReflow();
	      }
	    }
	  }, {
	    key: "reverseX",
	    get: function get() {
	      return this._reverseX;
	    },
	    set: function set(value) {
	      if (value !== this._reverseX) {
	        this._reverseX = value;

	        this._scheduleReflow();
	      }
	    }
	  }, {
	    key: "reverseY",
	    get: function get() {
	      return this._reverseY;
	    },
	    set: function set(value) {
	      if (value !== this._reverseY) {
	        this._reverseY = value;

	        this._scheduleReflow();
	      }
	    }
	  }, {
	    key: "alignment",
	    get: function get() {
	      return this._alignment;
	    },
	    set: function set(value) {
	      if (!value.equals(this._alignment)) {
	        this._alignment.copy(value);

	        this._scheduleReflow();
	      }
	    }
	  }, {
	    key: "padding",
	    get: function get() {
	      return this._padding;
	    },
	    set: function set(value) {
	      if (!value.equals(this._padding)) {
	        this._padding.copy(value);

	        this._scheduleReflow();
	      }
	    }
	  }, {
	    key: "spacing",
	    get: function get() {
	      return this._spacing;
	    },
	    set: function set(value) {
	      if (!value.equals(this._spacing)) {
	        this._spacing.copy(value);

	        this._scheduleReflow();
	      }
	    }
	  }, {
	    key: "widthFitting",
	    get: function get() {
	      return this._widthFitting;
	    },
	    set: function set(value) {
	      if (value !== this._widthFitting) {
	        this._widthFitting = value;

	        this._scheduleReflow();
	      }
	    }
	  }, {
	    key: "heightFitting",
	    get: function get() {
	      return this._heightFitting;
	    },
	    set: function set(value) {
	      if (value !== this._heightFitting) {
	        this._heightFitting = value;

	        this._scheduleReflow();
	      }
	    }
	  }, {
	    key: "wrap",
	    get: function get() {
	      return this._wrap;
	    },
	    set: function set(value) {
	      if (value !== this._wrap) {
	        this._wrap = value;

	        this._scheduleReflow();
	      }
	    }
	  }]);

	  return LayoutGroupComponent;
	}(Component);

	var LayoutGroupComponentData = function LayoutGroupComponentData() {
	  this.enabled = true;
	};

	var _schema$c = ['enabled'];
	var MAX_ITERATIONS = 100;

	var LayoutGroupComponentSystem = function (_ComponentSystem) {
	  _inheritsLoose(LayoutGroupComponentSystem, _ComponentSystem);

	  function LayoutGroupComponentSystem(app) {
	    var _this;

	    _this = _ComponentSystem.call(this, app) || this;
	    _this.id = 'layoutgroup';
	    _this.ComponentType = LayoutGroupComponent;
	    _this.DataType = LayoutGroupComponentData;
	    _this.schema = _schema$c;
	    _this._reflowQueue = [];

	    _this.on('beforeremove', _this._onRemoveComponent, _assertThisInitialized(_this));

	    _this.app.systems.on('postUpdate', _this._onPostUpdate, _assertThisInitialized(_this));

	    return _this;
	  }

	  var _proto = LayoutGroupComponentSystem.prototype;

	  _proto.initializeComponentData = function initializeComponentData(component, data, properties) {
	    if (data.enabled !== undefined) component.enabled = data.enabled;
	    if (data.orientation !== undefined) component.orientation = data.orientation;
	    if (data.reverseX !== undefined) component.reverseX = data.reverseX;
	    if (data.reverseY !== undefined) component.reverseY = data.reverseY;

	    if (data.alignment !== undefined) {
	      component.alignment = Array.isArray(data.alignment) ? new Vec2(data.alignment) : data.alignment;
	    }

	    if (data.padding !== undefined) {
	      component.padding = Array.isArray(data.padding) ? new Vec4(data.padding) : data.padding;
	    }

	    if (data.spacing !== undefined) {
	      component.spacing = Array.isArray(data.spacing) ? new Vec2(data.spacing) : data.spacing;
	    }

	    if (data.widthFitting !== undefined) component.widthFitting = data.widthFitting;
	    if (data.heightFitting !== undefined) component.heightFitting = data.heightFitting;
	    if (data.wrap !== undefined) component.wrap = data.wrap;

	    _ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
	  };

	  _proto.cloneComponent = function cloneComponent(entity, clone) {
	    var layoutGroup = entity.layoutgroup;
	    return this.addComponent(clone, {
	      enabled: layoutGroup.enabled,
	      orientation: layoutGroup.orientation,
	      reverseX: layoutGroup.reverseX,
	      reverseY: layoutGroup.reverseY,
	      alignment: layoutGroup.alignment,
	      padding: layoutGroup.padding,
	      spacing: layoutGroup.spacing,
	      widthFitting: layoutGroup.widthFitting,
	      heightFitting: layoutGroup.heightFitting,
	      wrap: layoutGroup.wrap
	    });
	  };

	  _proto.scheduleReflow = function scheduleReflow(component) {
	    if (this._reflowQueue.indexOf(component) === -1) {
	      this._reflowQueue.push(component);
	    }
	  };

	  _proto._onPostUpdate = function _onPostUpdate() {
	    this._processReflowQueue();
	  };

	  _proto._processReflowQueue = function _processReflowQueue() {
	    if (this._reflowQueue.length === 0) {
	      return;
	    }

	    var iterationCount = 0;

	    while (this._reflowQueue.length > 0) {
	      var queue = this._reflowQueue.slice();

	      this._reflowQueue.length = 0;
	      queue.sort(function (componentA, componentB) {
	        return componentA.entity.graphDepth - componentB.entity.graphDepth;
	      });

	      for (var i = 0; i < queue.length; ++i) {
	        queue[i].reflow();
	      }

	      if (++iterationCount >= MAX_ITERATIONS) {
	        console.warn('Max reflow iterations limit reached, bailing.');
	        break;
	      }
	    }
	  };

	  _proto._onRemoveComponent = function _onRemoveComponent(entity, component) {
	    component.onRemove();
	  };

	  _proto.destroy = function destroy() {
	    _ComponentSystem.prototype.destroy.call(this);

	    this.app.systems.off('postUpdate', this._onPostUpdate, this);
	  };

	  return LayoutGroupComponentSystem;
	}(ComponentSystem);

	Component._buildAccessors(LayoutGroupComponent.prototype, _schema$c);

	var ModelComponent = function (_Component) {
	  _inheritsLoose(ModelComponent, _Component);

	  function ModelComponent(system, entity) {
	    var _this;

	    _this = _Component.call(this, system, entity) || this;
	    _this._type = 'asset';
	    _this._asset = null;
	    _this._model = null;
	    _this._mapping = {};
	    _this._castShadows = true;
	    _this._receiveShadows = true;
	    _this._materialAsset = null;
	    _this._material = void 0;
	    _this._castShadowsLightmap = true;
	    _this._lightmapped = false;
	    _this._lightmapSizeMultiplier = 1;
	    _this._isStatic = false;
	    _this._layers = [LAYERID_WORLD];
	    _this._batchGroupId = -1;
	    _this._customAabb = null;
	    _this._area = null;
	    _this._materialEvents = null;
	    _this._clonedModel = false;
	    _this._material = system.defaultMaterial;
	    entity.on('remove', _this.onRemoveChild, _assertThisInitialized(_this));
	    entity.on('removehierarchy', _this.onRemoveChild, _assertThisInitialized(_this));
	    entity.on('insert', _this.onInsertChild, _assertThisInitialized(_this));
	    entity.on('inserthierarchy', _this.onInsertChild, _assertThisInitialized(_this));
	    return _this;
	  }

	  var _proto = ModelComponent.prototype;

	  _proto.addModelToLayers = function addModelToLayers() {
	    var layers = this.system.app.scene.layers;

	    for (var i = 0; i < this._layers.length; i++) {
	      var layer = layers.getLayerById(this._layers[i]);

	      if (layer) {
	        layer.addMeshInstances(this.meshInstances);
	      }
	    }
	  };

	  _proto.removeModelFromLayers = function removeModelFromLayers() {
	    var layers = this.system.app.scene.layers;

	    for (var i = 0; i < this._layers.length; i++) {
	      var layer = layers.getLayerById(this._layers[i]);
	      if (!layer) continue;
	      layer.removeMeshInstances(this.meshInstances);
	    }
	  };

	  _proto.onRemoveChild = function onRemoveChild() {
	    if (this._model) this.removeModelFromLayers();
	  };

	  _proto.onInsertChild = function onInsertChild() {
	    if (this._model && this.enabled && this.entity.enabled) this.addModelToLayers();
	  };

	  _proto.onRemove = function onRemove() {
	    this.asset = null;
	    this.model = null;
	    this.materialAsset = null;

	    this._unsetMaterialEvents();

	    this.entity.off('remove', this.onRemoveChild, this);
	    this.entity.off('insert', this.onInsertChild, this);
	  };

	  _proto.onLayersChanged = function onLayersChanged(oldComp, newComp) {
	    this.addModelToLayers();
	    oldComp.off('add', this.onLayerAdded, this);
	    oldComp.off('remove', this.onLayerRemoved, this);
	    newComp.on('add', this.onLayerAdded, this);
	    newComp.on('remove', this.onLayerRemoved, this);
	  };

	  _proto.onLayerAdded = function onLayerAdded(layer) {
	    var index = this.layers.indexOf(layer.id);
	    if (index < 0) return;
	    layer.addMeshInstances(this.meshInstances);
	  };

	  _proto.onLayerRemoved = function onLayerRemoved(layer) {
	    var index = this.layers.indexOf(layer.id);
	    if (index < 0) return;
	    layer.removeMeshInstances(this.meshInstances);
	  };

	  _proto._setMaterialEvent = function _setMaterialEvent(index, event, id, handler) {
	    var evt = event + ':' + id;
	    this.system.app.assets.on(evt, handler, this);
	    if (!this._materialEvents) this._materialEvents = [];
	    if (!this._materialEvents[index]) this._materialEvents[index] = {};
	    this._materialEvents[index][evt] = {
	      id: id,
	      handler: handler
	    };
	  };

	  _proto._unsetMaterialEvents = function _unsetMaterialEvents() {
	    var assets = this.system.app.assets;
	    var events = this._materialEvents;
	    if (!events) return;

	    for (var i = 0, len = events.length; i < len; i++) {
	      if (!events[i]) continue;
	      var evt = events[i];

	      for (var key in evt) {
	        assets.off(key, evt[key].handler, this);
	      }
	    }

	    this._materialEvents = null;
	  };

	  _proto._getAssetByIdOrPath = function _getAssetByIdOrPath(idOrPath) {
	    var asset = null;
	    var isPath = isNaN(parseInt(idOrPath, 10));

	    if (!isPath) {
	      asset = this.system.app.assets.get(idOrPath);
	    } else if (this.asset) {
	      var url = this._getMaterialAssetUrl(idOrPath);

	      if (url) asset = this.system.app.assets.getByUrl(url);
	    }

	    return asset;
	  };

	  _proto._getMaterialAssetUrl = function _getMaterialAssetUrl(path) {
	    if (!this.asset) return null;
	    var modelAsset = this.system.app.assets.get(this.asset);
	    return modelAsset ? modelAsset.getAbsoluteUrl(path) : null;
	  };

	  _proto._loadAndSetMeshInstanceMaterial = function _loadAndSetMeshInstanceMaterial(materialAsset, meshInstance, index) {
	    var assets = this.system.app.assets;
	    if (!materialAsset) return;

	    if (materialAsset.resource) {
	      meshInstance.material = materialAsset.resource;

	      this._setMaterialEvent(index, 'remove', materialAsset.id, function () {
	        meshInstance.material = this.system.defaultMaterial;
	      });
	    } else {
	      this._setMaterialEvent(index, 'load', materialAsset.id, function (asset) {
	        meshInstance.material = asset.resource;

	        this._setMaterialEvent(index, 'remove', materialAsset.id, function () {
	          meshInstance.material = this.system.defaultMaterial;
	        });
	      });

	      if (this.enabled && this.entity.enabled) assets.load(materialAsset);
	    }
	  };

	  _proto.onEnable = function onEnable() {
	    var app = this.system.app;
	    var scene = app.scene;
	    scene.on('set:layers', this.onLayersChanged, this);

	    if (scene.layers) {
	      scene.layers.on('add', this.onLayerAdded, this);
	      scene.layers.on('remove', this.onLayerRemoved, this);
	    }

	    var isAsset = this._type === 'asset';
	    var asset;

	    if (this._model) {
	      this.addModelToLayers();
	    } else if (isAsset && this._asset) {
	      asset = app.assets.get(this._asset);

	      if (asset && asset.resource !== this._model) {
	        this._bindModelAsset(asset);
	      }
	    }

	    if (this._materialAsset) {
	      asset = app.assets.get(this._materialAsset);

	      if (asset && asset.resource !== this._material) {
	        this._bindMaterialAsset(asset);
	      }
	    }

	    if (isAsset) {
	      if (this._mapping) {
	        for (var index in this._mapping) {
	          if (this._mapping[index]) {
	            asset = this._getAssetByIdOrPath(this._mapping[index]);

	            if (asset && !asset.resource) {
	              app.assets.load(asset);
	            }
	          }
	        }
	      }
	    }

	    if (this._batchGroupId >= 0) {
	      var _app$batcher;

	      (_app$batcher = app.batcher) == null ? void 0 : _app$batcher.insert(BatchGroup.MODEL, this.batchGroupId, this.entity);
	    }
	  };

	  _proto.onDisable = function onDisable() {
	    var app = this.system.app;
	    var scene = app.scene;
	    scene.off('set:layers', this.onLayersChanged, this);

	    if (scene.layers) {
	      scene.layers.off('add', this.onLayerAdded, this);
	      scene.layers.off('remove', this.onLayerRemoved, this);
	    }

	    if (this._batchGroupId >= 0) {
	      var _app$batcher2;

	      (_app$batcher2 = app.batcher) == null ? void 0 : _app$batcher2.remove(BatchGroup.MODEL, this.batchGroupId, this.entity);
	    }

	    if (this._model) {
	      this.removeModelFromLayers();
	    }
	  };

	  _proto.hide = function hide() {
	    if (this._model) {
	      var instances = this._model.meshInstances;

	      for (var i = 0, l = instances.length; i < l; i++) {
	        instances[i].visible = false;
	      }
	    }
	  };

	  _proto.show = function show() {
	    if (this._model) {
	      var instances = this._model.meshInstances;

	      for (var i = 0, l = instances.length; i < l; i++) {
	        instances[i].visible = true;
	      }
	    }
	  };

	  _proto._bindMaterialAsset = function _bindMaterialAsset(asset) {
	    asset.on('load', this._onMaterialAssetLoad, this);
	    asset.on('unload', this._onMaterialAssetUnload, this);
	    asset.on('remove', this._onMaterialAssetRemove, this);
	    asset.on('change', this._onMaterialAssetChange, this);

	    if (asset.resource) {
	      this._onMaterialAssetLoad(asset);
	    } else {
	      if (!this.enabled || !this.entity.enabled) return;
	      this.system.app.assets.load(asset);
	    }
	  };

	  _proto._unbindMaterialAsset = function _unbindMaterialAsset(asset) {
	    asset.off('load', this._onMaterialAssetLoad, this);
	    asset.off('unload', this._onMaterialAssetUnload, this);
	    asset.off('remove', this._onMaterialAssetRemove, this);
	    asset.off('change', this._onMaterialAssetChange, this);
	  };

	  _proto._onMaterialAssetAdd = function _onMaterialAssetAdd(asset) {
	    this.system.app.assets.off('add:' + asset.id, this._onMaterialAssetAdd, this);

	    if (this._materialAsset === asset.id) {
	      this._bindMaterialAsset(asset);
	    }
	  };

	  _proto._onMaterialAssetLoad = function _onMaterialAssetLoad(asset) {
	    this._setMaterial(asset.resource);
	  };

	  _proto._onMaterialAssetUnload = function _onMaterialAssetUnload(asset) {
	    this._setMaterial(this.system.defaultMaterial);
	  };

	  _proto._onMaterialAssetRemove = function _onMaterialAssetRemove(asset) {
	    this._onMaterialAssetUnload(asset);
	  };

	  _proto._onMaterialAssetChange = function _onMaterialAssetChange(asset) {};

	  _proto._bindModelAsset = function _bindModelAsset(asset) {
	    this._unbindModelAsset(asset);

	    asset.on('load', this._onModelAssetLoad, this);
	    asset.on('unload', this._onModelAssetUnload, this);
	    asset.on('change', this._onModelAssetChange, this);
	    asset.on('remove', this._onModelAssetRemove, this);

	    if (asset.resource) {
	      this._onModelAssetLoad(asset);
	    } else {
	      if (!this.enabled || !this.entity.enabled) return;
	      this.system.app.assets.load(asset);
	    }
	  };

	  _proto._unbindModelAsset = function _unbindModelAsset(asset) {
	    asset.off('load', this._onModelAssetLoad, this);
	    asset.off('unload', this._onModelAssetUnload, this);
	    asset.off('change', this._onModelAssetChange, this);
	    asset.off('remove', this._onModelAssetRemove, this);
	  };

	  _proto._onModelAssetAdded = function _onModelAssetAdded(asset) {
	    this.system.app.assets.off('add:' + asset.id, this._onModelAssetAdded, this);

	    if (asset.id === this._asset) {
	      this._bindModelAsset(asset);
	    }
	  };

	  _proto._onModelAssetLoad = function _onModelAssetLoad(asset) {
	    this.model = asset.resource.clone();
	    this._clonedModel = true;
	  };

	  _proto._onModelAssetUnload = function _onModelAssetUnload(asset) {
	    this.model = null;
	  };

	  _proto._onModelAssetChange = function _onModelAssetChange(asset, attr, _new, _old) {
	    if (attr === 'data') {
	      this.mapping = this._mapping;
	    }
	  };

	  _proto._onModelAssetRemove = function _onModelAssetRemove(asset) {
	    this.model = null;
	  };

	  _proto._setMaterial = function _setMaterial(material) {
	    if (this._material === material) return;
	    this._material = material;
	    var model = this._model;

	    if (model && this._type !== 'asset') {
	      var meshInstances = model.meshInstances;

	      for (var i = 0, len = meshInstances.length; i < len; i++) {
	        meshInstances[i].material = material;
	      }
	    }
	  };

	  _createClass(ModelComponent, [{
	    key: "meshInstances",
	    get: function get() {
	      if (!this._model) return null;
	      return this._model.meshInstances;
	    },
	    set: function set(value) {
	      if (!this._model) return;
	      this._model.meshInstances = value;
	    }
	  }, {
	    key: "customAabb",
	    get: function get() {
	      return this._customAabb;
	    },
	    set: function set(value) {
	      this._customAabb = value;

	      if (this._model) {
	        var mi = this._model.meshInstances;

	        if (mi) {
	          for (var i = 0; i < mi.length; i++) {
	            mi[i].setCustomAabb(this._customAabb);
	          }
	        }
	      }
	    }
	  }, {
	    key: "type",
	    get: function get() {
	      return this._type;
	    },
	    set: function set(value) {
	      if (this._type === value) return;
	      this._area = null;
	      this._type = value;

	      if (value === 'asset') {
	        if (this._asset !== null) {
	          this._bindModelAsset(this._asset);
	        } else {
	          this.model = null;
	        }
	      } else {
	        var primData = getShapePrimitive(this.system.app.graphicsDevice, value);
	        this._area = primData.area;
	        var mesh = primData.mesh;
	        var node = new GraphNode();
	        var model = new Model();
	        model.graph = node;
	        model.meshInstances = [new MeshInstance(mesh, this._material, node)];
	        this.model = model;
	        this._asset = null;
	      }
	    }
	  }, {
	    key: "asset",
	    get: function get() {
	      return this._asset;
	    },
	    set: function set(value) {
	      var assets = this.system.app.assets;
	      var _id = value;

	      if (value instanceof Asset) {
	        _id = value.id;
	      }

	      if (this._asset !== _id) {
	        if (this._asset) {
	          assets.off('add:' + this._asset, this._onModelAssetAdded, this);

	          var _prev = assets.get(this._asset);

	          if (_prev) {
	            this._unbindModelAsset(_prev);
	          }
	        }

	        this._asset = _id;

	        if (this._asset) {
	          var asset = assets.get(this._asset);

	          if (!asset) {
	            this.model = null;
	            assets.on('add:' + this._asset, this._onModelAssetAdded, this);
	          } else {
	            this._bindModelAsset(asset);
	          }
	        } else {
	          this.model = null;
	        }
	      }
	    }
	  }, {
	    key: "model",
	    get: function get() {
	      return this._model;
	    },
	    set: function set(value) {
	      if (this._model === value) return;

	      if (value && value._immutable) {
	        return;
	      }

	      if (this._model) {
	        this._model._immutable = false;
	        this.removeModelFromLayers();
	        this.entity.removeChild(this._model.getGraph());
	        delete this._model._entity;

	        if (this._clonedModel) {
	          this._model.destroy();

	          this._clonedModel = false;
	        }
	      }

	      this._model = value;

	      if (this._model) {
	        this._model._immutable = true;
	        var meshInstances = this._model.meshInstances;

	        for (var i = 0; i < meshInstances.length; i++) {
	          meshInstances[i].castShadow = this._castShadows;
	          meshInstances[i].receiveShadow = this._receiveShadows;
	          meshInstances[i].isStatic = this._isStatic;
	          meshInstances[i].setCustomAabb(this._customAabb);
	        }

	        this.lightmapped = this._lightmapped;
	        this.entity.addChild(this._model.graph);

	        if (this.enabled && this.entity.enabled) {
	          this.addModelToLayers();
	        }

	        this._model._entity = this.entity;
	        if (this.entity.animation) this.entity.animation.setModel(this._model);

	        if (this.entity.anim) {
	          this.entity.anim.rebind();
	        }

	        if (this.type === 'asset') {
	          this.mapping = this._mapping;
	        } else {
	          this._unsetMaterialEvents();
	        }
	      }
	    }
	  }, {
	    key: "lightmapped",
	    get: function get() {
	      return this._lightmapped;
	    },
	    set: function set(value) {
	      if (value !== this._lightmapped) {
	        this._lightmapped = value;

	        if (this._model) {
	          var mi = this._model.meshInstances;

	          for (var i = 0; i < mi.length; i++) {
	            mi[i].setLightmapped(value);
	          }
	        }
	      }
	    }
	  }, {
	    key: "castShadows",
	    get: function get() {
	      return this._castShadows;
	    },
	    set: function set(value) {
	      if (this._castShadows === value) return;
	      var model = this._model;

	      if (model) {
	        var layers = this.layers;
	        var scene = this.system.app.scene;

	        if (this._castShadows && !value) {
	          for (var i = 0; i < layers.length; i++) {
	            var layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
	            if (!layer) continue;
	            layer.removeShadowCasters(model.meshInstances);
	          }
	        }

	        var meshInstances = model.meshInstances;

	        for (var _i = 0; _i < meshInstances.length; _i++) {
	          meshInstances[_i].castShadow = value;
	        }

	        if (!this._castShadows && value) {
	          for (var _i2 = 0; _i2 < layers.length; _i2++) {
	            var _layer = scene.layers.getLayerById(layers[_i2]);

	            if (!_layer) continue;

	            _layer.addShadowCasters(model.meshInstances);
	          }
	        }
	      }

	      this._castShadows = value;
	    }
	  }, {
	    key: "receiveShadows",
	    get: function get() {
	      return this._receiveShadows;
	    },
	    set: function set(value) {
	      if (this._receiveShadows === value) return;
	      this._receiveShadows = value;

	      if (this._model) {
	        var meshInstances = this._model.meshInstances;

	        for (var i = 0, len = meshInstances.length; i < len; i++) {
	          meshInstances[i].receiveShadow = value;
	        }
	      }
	    }
	  }, {
	    key: "castShadowsLightmap",
	    get: function get() {
	      return this._castShadowsLightmap;
	    },
	    set: function set(value) {
	      this._castShadowsLightmap = value;
	    }
	  }, {
	    key: "lightmapSizeMultiplier",
	    get: function get() {
	      return this._lightmapSizeMultiplier;
	    },
	    set: function set(value) {
	      this._lightmapSizeMultiplier = value;
	    }
	  }, {
	    key: "isStatic",
	    get: function get() {
	      return this._isStatic;
	    },
	    set: function set(value) {
	      if (this._isStatic === value) return;
	      this._isStatic = value;

	      if (this._model) {
	        var rcv = this._model.meshInstances;

	        for (var i = 0; i < rcv.length; i++) {
	          var m = rcv[i];
	          m.isStatic = value;
	        }
	      }
	    }
	  }, {
	    key: "layers",
	    get: function get() {
	      return this._layers;
	    },
	    set: function set(value) {
	      var layers = this.system.app.scene.layers;

	      if (this.meshInstances) {
	        for (var i = 0; i < this._layers.length; i++) {
	          var layer = layers.getLayerById(this._layers[i]);
	          if (!layer) continue;
	          layer.removeMeshInstances(this.meshInstances);
	        }
	      }

	      this._layers.length = 0;

	      for (var _i3 = 0; _i3 < value.length; _i3++) {
	        this._layers[_i3] = value[_i3];
	      }

	      if (!this.enabled || !this.entity.enabled || !this.meshInstances) return;

	      for (var _i4 = 0; _i4 < this._layers.length; _i4++) {
	        var _layer2 = layers.getLayerById(this._layers[_i4]);

	        if (!_layer2) continue;

	        _layer2.addMeshInstances(this.meshInstances);
	      }
	    }
	  }, {
	    key: "batchGroupId",
	    get: function get() {
	      return this._batchGroupId;
	    },
	    set: function set(value) {
	      if (this._batchGroupId === value) return;

	      if (this.entity.enabled && this._batchGroupId >= 0) {
	        var _this$system$app$batc;

	        (_this$system$app$batc = this.system.app.batcher) == null ? void 0 : _this$system$app$batc.remove(BatchGroup.MODEL, this.batchGroupId, this.entity);
	      }

	      if (this.entity.enabled && value >= 0) {
	        var _this$system$app$batc2;

	        (_this$system$app$batc2 = this.system.app.batcher) == null ? void 0 : _this$system$app$batc2.insert(BatchGroup.MODEL, value, this.entity);
	      }

	      if (value < 0 && this._batchGroupId >= 0 && this.enabled && this.entity.enabled) {
	        this.addModelToLayers();
	      }

	      this._batchGroupId = value;
	    }
	  }, {
	    key: "materialAsset",
	    get: function get() {
	      return this._materialAsset;
	    },
	    set: function set(value) {
	      var _id = value;

	      if (value instanceof Asset) {
	        _id = value.id;
	      }

	      var assets = this.system.app.assets;

	      if (_id !== this._materialAsset) {
	        if (this._materialAsset) {
	          assets.off('add:' + this._materialAsset, this._onMaterialAssetAdd, this);

	          var _prev = assets.get(this._materialAsset);

	          if (_prev) {
	            this._unbindMaterialAsset(_prev);
	          }
	        }

	        this._materialAsset = _id;

	        if (this._materialAsset) {
	          var asset = assets.get(this._materialAsset);

	          if (!asset) {
	            this._setMaterial(this.system.defaultMaterial);

	            assets.on('add:' + this._materialAsset, this._onMaterialAssetAdd, this);
	          } else {
	            this._bindMaterialAsset(asset);
	          }
	        } else {
	          this._setMaterial(this.system.defaultMaterial);
	        }
	      }
	    }
	  }, {
	    key: "material",
	    get: function get() {
	      return this._material;
	    },
	    set: function set(value) {
	      if (this._material === value) return;
	      this.materialAsset = null;

	      this._setMaterial(value);
	    }
	  }, {
	    key: "mapping",
	    get: function get() {
	      return this._mapping;
	    },
	    set: function set(value) {
	      if (this._type !== 'asset') return;

	      this._unsetMaterialEvents();

	      if (!value) value = {};
	      this._mapping = value;
	      if (!this._model) return;
	      var meshInstances = this._model.meshInstances;
	      var modelAsset = this.asset ? this.system.app.assets.get(this.asset) : null;
	      var assetMapping = modelAsset ? modelAsset.data.mapping : null;
	      var asset = null;

	      for (var i = 0, len = meshInstances.length; i < len; i++) {
	        if (value[i] !== undefined) {
	          if (value[i]) {
	            asset = this.system.app.assets.get(value[i]);

	            this._loadAndSetMeshInstanceMaterial(asset, meshInstances[i], i);
	          } else {
	            meshInstances[i].material = this.system.defaultMaterial;
	          }
	        } else if (assetMapping) {
	          if (assetMapping[i] && (assetMapping[i].material || assetMapping[i].path)) {
	            if (assetMapping[i].material !== undefined) {
	              asset = this.system.app.assets.get(assetMapping[i].material);
	            } else if (assetMapping[i].path !== undefined) {
	              var url = this._getMaterialAssetUrl(assetMapping[i].path);

	              if (url) {
	                asset = this.system.app.assets.getByUrl(url);
	              }
	            }

	            this._loadAndSetMeshInstanceMaterial(asset, meshInstances[i], i);
	          } else {
	            meshInstances[i].material = this.system.defaultMaterial;
	          }
	        }
	      }
	    }
	  }]);

	  return ModelComponent;
	}(Component);

	var ModelComponentData = function ModelComponentData() {
	  this.enabled = true;
	};

	var _schema$b = ['enabled'];

	var ModelComponentSystem = function (_ComponentSystem) {
	  _inheritsLoose(ModelComponentSystem, _ComponentSystem);

	  function ModelComponentSystem(app) {
	    var _this;

	    _this = _ComponentSystem.call(this, app) || this;
	    _this.id = 'model';
	    _this.ComponentType = ModelComponent;
	    _this.DataType = ModelComponentData;
	    _this.schema = _schema$b;
	    _this.defaultMaterial = getDefaultMaterial(app.graphicsDevice);

	    _this.on('beforeremove', _this.onRemove, _assertThisInitialized(_this));

	    return _this;
	  }

	  var _proto = ModelComponentSystem.prototype;

	  _proto.initializeComponentData = function initializeComponentData(component, _data, properties) {
	    properties = ['material', 'materialAsset', 'asset', 'castShadows', 'receiveShadows', 'castShadowsLightmap', 'lightmapped', 'lightmapSizeMultiplier', 'type', 'mapping', 'layers', 'isStatic', 'batchGroupId'];

	    if (_data.batchGroupId === null || _data.batchGroupId === undefined) {
	      _data.batchGroupId = -1;
	    }

	    if (_data.layers && _data.layers.length) {
	      _data.layers = _data.layers.slice(0);
	    }

	    for (var i = 0; i < properties.length; i++) {
	      if (_data.hasOwnProperty(properties[i])) {
	        component[properties[i]] = _data[properties[i]];
	      }
	    }

	    if (_data.aabbCenter && _data.aabbHalfExtents) {
	      component.customAabb = new BoundingBox(new Vec3(_data.aabbCenter), new Vec3(_data.aabbHalfExtents));
	    }

	    _ComponentSystem.prototype.initializeComponentData.call(this, component, _data, ['enabled']);
	  };

	  _proto.cloneComponent = function cloneComponent(entity, clone) {
	    var data = {
	      type: entity.model.type,
	      asset: entity.model.asset,
	      castShadows: entity.model.castShadows,
	      receiveShadows: entity.model.receiveShadows,
	      castShadowsLightmap: entity.model.castShadowsLightmap,
	      lightmapped: entity.model.lightmapped,
	      lightmapSizeMultiplier: entity.model.lightmapSizeMultiplier,
	      isStatic: entity.model.isStatic,
	      enabled: entity.model.enabled,
	      layers: entity.model.layers,
	      batchGroupId: entity.model.batchGroupId,
	      mapping: extend({}, entity.model.mapping)
	    };
	    var materialAsset = entity.model.materialAsset;

	    if (!(materialAsset instanceof Asset) && materialAsset != null) {
	      materialAsset = this.app.assets.get(materialAsset);
	    }

	    var material = entity.model.material;

	    if (!material || material === this.defaultMaterial || !materialAsset || material === materialAsset.resource) {
	      data.materialAsset = materialAsset;
	    }

	    var component = this.addComponent(clone, data);

	    if (entity.model.model && entity.model.type === 'asset' && !entity.model.asset) {
	      component.model = entity.model.model.clone();
	      component._clonedModel = true;
	    }

	    if (!data.materialAsset) component.material = material;

	    if (entity.model.model) {
	      var meshInstances = entity.model.model.meshInstances;
	      var meshInstancesClone = component.model.meshInstances;

	      for (var i = 0; i < meshInstances.length; i++) {
	        meshInstancesClone[i].mask = meshInstances[i].mask;
	        meshInstancesClone[i].material = meshInstances[i].material;
	        meshInstancesClone[i].layer = meshInstances[i].layer;
	        meshInstancesClone[i].receiveShadow = meshInstances[i].receiveShadow;
	      }
	    }

	    if (entity.model.customAabb) {
	      component.customAabb = entity.model.customAabb.clone();
	    }

	    return component;
	  };

	  _proto.onRemove = function onRemove(entity, component) {
	    component.onRemove();
	  };

	  return ModelComponentSystem;
	}(ComponentSystem);

	Component._buildAccessors(ModelComponent.prototype, _schema$b);

	var SIMPLE_PROPERTIES = ['emitterExtents', 'emitterRadius', 'emitterExtentsInner', 'emitterRadiusInner', 'loop', 'initialVelocity', 'animSpeed', 'normalMap', 'particleNormal'];
	var COMPLEX_PROPERTIES = ['numParticles', 'lifetime', 'rate', 'rate2', 'startAngle', 'startAngle2', 'lighting', 'halfLambert', 'intensity', 'wrap', 'wrapBounds', 'depthWrite', 'noFog', 'sort', 'stretch', 'alignToMotion', 'preWarm', 'emitterShape', 'animTilesX', 'animTilesY', 'animStartFrame', 'animNumFrames', 'animNumAnimations', 'animIndex', 'randomizeAnimIndex', 'animLoop', 'colorMap', 'localSpace', 'screenSpace', 'orientation'];
	var GRAPH_PROPERTIES = ['scaleGraph', 'scaleGraph2', 'colorGraph', 'colorGraph2', 'alphaGraph', 'alphaGraph2', 'velocityGraph', 'velocityGraph2', 'localVelocityGraph', 'localVelocityGraph2', 'rotationSpeedGraph', 'rotationSpeedGraph2', 'radialSpeedGraph', 'radialSpeedGraph2'];
	var ASSET_PROPERTIES = ['colorMapAsset', 'normalMapAsset', 'meshAsset', 'renderAsset'];
	var depthLayer;

	var ParticleSystemComponent = function (_Component) {
	  _inheritsLoose(ParticleSystemComponent, _Component);

	  function ParticleSystemComponent(system, entity) {
	    var _this;

	    _this = _Component.call(this, system, entity) || this;
	    _this._requestedDepth = false;
	    _this._drawOrder = 0;

	    _this.on('set_colorMapAsset', _this.onSetColorMapAsset, _assertThisInitialized(_this));

	    _this.on('set_normalMapAsset', _this.onSetNormalMapAsset, _assertThisInitialized(_this));

	    _this.on('set_meshAsset', _this.onSetMeshAsset, _assertThisInitialized(_this));

	    _this.on('set_mesh', _this.onSetMesh, _assertThisInitialized(_this));

	    _this.on('set_renderAsset', _this.onSetRenderAsset, _assertThisInitialized(_this));

	    _this.on('set_loop', _this.onSetLoop, _assertThisInitialized(_this));

	    _this.on('set_blendType', _this.onSetBlendType, _assertThisInitialized(_this));

	    _this.on('set_depthSoftening', _this.onSetDepthSoftening, _assertThisInitialized(_this));

	    _this.on('set_layers', _this.onSetLayers, _assertThisInitialized(_this));

	    SIMPLE_PROPERTIES.forEach(function (prop) {
	      _this.on("set_" + prop, _this.onSetSimpleProperty, _assertThisInitialized(_this));
	    });
	    COMPLEX_PROPERTIES.forEach(function (prop) {
	      _this.on("set_" + prop, _this.onSetComplexProperty, _assertThisInitialized(_this));
	    });
	    GRAPH_PROPERTIES.forEach(function (prop) {
	      _this.on("set_" + prop, _this.onSetGraphProperty, _assertThisInitialized(_this));
	    });
	    return _this;
	  }

	  var _proto = ParticleSystemComponent.prototype;

	  _proto.addMeshInstanceToLayers = function addMeshInstanceToLayers() {
	    if (!this.emitter) return;

	    for (var i = 0; i < this.layers.length; i++) {
	      var layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
	      if (!layer) continue;
	      layer.addMeshInstances([this.emitter.meshInstance]);
	      this.emitter._layer = layer;
	    }
	  };

	  _proto.removeMeshInstanceFromLayers = function removeMeshInstanceFromLayers() {
	    if (!this.emitter) return;

	    for (var i = 0; i < this.layers.length; i++) {
	      var layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
	      if (!layer) continue;
	      layer.removeMeshInstances([this.emitter.meshInstance]);
	    }
	  };

	  _proto.onSetLayers = function onSetLayers(name, oldValue, newValue) {
	    if (!this.emitter) return;

	    for (var i = 0; i < oldValue.length; i++) {
	      var layer = this.system.app.scene.layers.getLayerById(oldValue[i]);
	      if (!layer) continue;
	      layer.removeMeshInstances([this.emitter.meshInstance]);
	    }

	    if (!this.enabled || !this.entity.enabled) return;

	    for (var _i = 0; _i < newValue.length; _i++) {
	      var _layer = this.system.app.scene.layers.getLayerById(newValue[_i]);

	      if (!_layer) continue;

	      _layer.addMeshInstances([this.emitter.meshInstance]);
	    }
	  };

	  _proto.onLayersChanged = function onLayersChanged(oldComp, newComp) {
	    this.addMeshInstanceToLayers();
	    oldComp.off('add', this.onLayerAdded, this);
	    oldComp.off('remove', this.onLayerRemoved, this);
	    newComp.on('add', this.onLayerAdded, this);
	    newComp.on('remove', this.onLayerRemoved, this);
	  };

	  _proto.onLayerAdded = function onLayerAdded(layer) {
	    if (!this.emitter) return;
	    var index = this.layers.indexOf(layer.id);
	    if (index < 0) return;
	    layer.addMeshInstances([this.emitter.meshInstance]);
	  };

	  _proto.onLayerRemoved = function onLayerRemoved(layer) {
	    if (!this.emitter) return;
	    var index = this.layers.indexOf(layer.id);
	    if (index < 0) return;
	    layer.removeMeshInstances([this.emitter.meshInstance]);
	  };

	  _proto._bindColorMapAsset = function _bindColorMapAsset(asset) {
	    asset.on('load', this._onColorMapAssetLoad, this);
	    asset.on('unload', this._onColorMapAssetUnload, this);
	    asset.on('remove', this._onColorMapAssetRemove, this);
	    asset.on('change', this._onColorMapAssetChange, this);

	    if (asset.resource) {
	      this._onColorMapAssetLoad(asset);
	    } else {
	      if (!this.enabled || !this.entity.enabled) return;
	      this.system.app.assets.load(asset);
	    }
	  };

	  _proto._unbindColorMapAsset = function _unbindColorMapAsset(asset) {
	    asset.off('load', this._onColorMapAssetLoad, this);
	    asset.off('unload', this._onColorMapAssetUnload, this);
	    asset.off('remove', this._onColorMapAssetRemove, this);
	    asset.off('change', this._onColorMapAssetChange, this);
	  };

	  _proto._onColorMapAssetLoad = function _onColorMapAssetLoad(asset) {
	    this.colorMap = asset.resource;
	  };

	  _proto._onColorMapAssetUnload = function _onColorMapAssetUnload(asset) {
	    this.colorMap = null;
	  };

	  _proto._onColorMapAssetRemove = function _onColorMapAssetRemove(asset) {
	    this._onColorMapAssetUnload(asset);
	  };

	  _proto._onColorMapAssetChange = function _onColorMapAssetChange(asset) {};

	  _proto.onSetColorMapAsset = function onSetColorMapAsset(name, oldValue, newValue) {
	    var _this2 = this;

	    var assets = this.system.app.assets;

	    if (oldValue) {
	      var asset = assets.get(oldValue);

	      if (asset) {
	        this._unbindColorMapAsset(asset);
	      }
	    }

	    if (newValue) {
	      if (newValue instanceof Asset) {
	        this.data.colorMapAsset = newValue.id;
	        newValue = newValue.id;
	      }

	      var _asset = assets.get(newValue);

	      if (_asset) {
	        this._bindColorMapAsset(_asset);
	      } else {
	        assets.once('add:' + newValue, function (asset) {
	          _this2._bindColorMapAsset(asset);
	        });
	      }
	    } else {
	      this.colorMap = null;
	    }
	  };

	  _proto._bindNormalMapAsset = function _bindNormalMapAsset(asset) {
	    asset.on('load', this._onNormalMapAssetLoad, this);
	    asset.on('unload', this._onNormalMapAssetUnload, this);
	    asset.on('remove', this._onNormalMapAssetRemove, this);
	    asset.on('change', this._onNormalMapAssetChange, this);

	    if (asset.resource) {
	      this._onNormalMapAssetLoad(asset);
	    } else {
	      if (!this.enabled || !this.entity.enabled) return;
	      this.system.app.assets.load(asset);
	    }
	  };

	  _proto._unbindNormalMapAsset = function _unbindNormalMapAsset(asset) {
	    asset.off('load', this._onNormalMapAssetLoad, this);
	    asset.off('unload', this._onNormalMapAssetUnload, this);
	    asset.off('remove', this._onNormalMapAssetRemove, this);
	    asset.off('change', this._onNormalMapAssetChange, this);
	  };

	  _proto._onNormalMapAssetLoad = function _onNormalMapAssetLoad(asset) {
	    this.normalMap = asset.resource;
	  };

	  _proto._onNormalMapAssetUnload = function _onNormalMapAssetUnload(asset) {
	    this.normalMap = null;
	  };

	  _proto._onNormalMapAssetRemove = function _onNormalMapAssetRemove(asset) {
	    this._onNormalMapAssetUnload(asset);
	  };

	  _proto._onNormalMapAssetChange = function _onNormalMapAssetChange(asset) {};

	  _proto.onSetNormalMapAsset = function onSetNormalMapAsset(name, oldValue, newValue) {
	    var _this3 = this;

	    var assets = this.system.app.assets;

	    if (oldValue) {
	      var asset = assets.get(oldValue);

	      if (asset) {
	        this._unbindNormalMapAsset(asset);
	      }
	    }

	    if (newValue) {
	      if (newValue instanceof Asset) {
	        this.data.normalMapAsset = newValue.id;
	        newValue = newValue.id;
	      }

	      var _asset2 = assets.get(newValue);

	      if (_asset2) {
	        this._bindNormalMapAsset(_asset2);
	      } else {
	        assets.once('add:' + newValue, function (asset) {
	          _this3._bindNormalMapAsset(asset);
	        });
	      }
	    } else {
	      this.normalMap = null;
	    }
	  };

	  _proto._bindMeshAsset = function _bindMeshAsset(asset) {
	    asset.on('load', this._onMeshAssetLoad, this);
	    asset.on('unload', this._onMeshAssetUnload, this);
	    asset.on('remove', this._onMeshAssetRemove, this);
	    asset.on('change', this._onMeshAssetChange, this);

	    if (asset.resource) {
	      this._onMeshAssetLoad(asset);
	    } else {
	      if (!this.enabled || !this.entity.enabled) return;
	      this.system.app.assets.load(asset);
	    }
	  };

	  _proto._unbindMeshAsset = function _unbindMeshAsset(asset) {
	    asset.off('load', this._onMeshAssetLoad, this);
	    asset.off('unload', this._onMeshAssetUnload, this);
	    asset.off('remove', this._onMeshAssetRemove, this);
	    asset.off('change', this._onMeshAssetChange, this);
	  };

	  _proto._onMeshAssetLoad = function _onMeshAssetLoad(asset) {
	    this._onMeshChanged(asset.resource);
	  };

	  _proto._onMeshAssetUnload = function _onMeshAssetUnload(asset) {
	    this.mesh = null;
	  };

	  _proto._onMeshAssetRemove = function _onMeshAssetRemove(asset) {
	    this._onMeshAssetUnload(asset);
	  };

	  _proto._onMeshAssetChange = function _onMeshAssetChange(asset) {};

	  _proto.onSetMeshAsset = function onSetMeshAsset(name, oldValue, newValue) {
	    var assets = this.system.app.assets;

	    if (oldValue) {
	      var asset = assets.get(oldValue);

	      if (asset) {
	        this._unbindMeshAsset(asset);
	      }
	    }

	    if (newValue) {
	      if (newValue instanceof Asset) {
	        this.data.meshAsset = newValue.id;
	        newValue = newValue.id;
	      }

	      var _asset3 = assets.get(newValue);

	      if (_asset3) {
	        this._bindMeshAsset(_asset3);
	      }
	    } else {
	      this._onMeshChanged(null);
	    }
	  };

	  _proto.onSetMesh = function onSetMesh(name, oldValue, newValue) {
	    if (!newValue || newValue instanceof Asset || typeof newValue === 'number') {
	      this.meshAsset = newValue;
	    } else {
	      this._onMeshChanged(newValue);
	    }
	  };

	  _proto._onMeshChanged = function _onMeshChanged(mesh) {
	    if (mesh && !(mesh instanceof Mesh)) {
	      if (mesh.meshInstances[0]) {
	        mesh = mesh.meshInstances[0].mesh;
	      } else {
	        mesh = null;
	      }
	    }

	    this.data.mesh = mesh;

	    if (this.emitter) {
	      this.emitter.mesh = mesh;
	      this.emitter.resetMaterial();
	      this.rebuild();
	    }
	  };

	  _proto.onSetRenderAsset = function onSetRenderAsset(name, oldValue, newValue) {
	    var assets = this.system.app.assets;

	    if (oldValue) {
	      var asset = assets.get(oldValue);

	      if (asset) {
	        this._unbindRenderAsset(asset);
	      }
	    }

	    if (newValue) {
	      if (newValue instanceof Asset) {
	        this.data.renderAsset = newValue.id;
	        newValue = newValue.id;
	      }

	      var _asset4 = assets.get(newValue);

	      if (_asset4) {
	        this._bindRenderAsset(_asset4);
	      }
	    } else {
	      this._onRenderChanged(null);
	    }
	  };

	  _proto._bindRenderAsset = function _bindRenderAsset(asset) {
	    asset.on('load', this._onRenderAssetLoad, this);
	    asset.on('unload', this._onRenderAssetUnload, this);
	    asset.on('remove', this._onRenderAssetRemove, this);

	    if (asset.resource) {
	      this._onRenderAssetLoad(asset);
	    } else {
	      if (!this.enabled || !this.entity.enabled) return;
	      this.system.app.assets.load(asset);
	    }
	  };

	  _proto._unbindRenderAsset = function _unbindRenderAsset(asset) {
	    asset.off('load', this._onRenderAssetLoad, this);
	    asset.off('unload', this._onRenderAssetUnload, this);
	    asset.off('remove', this._onRenderAssetRemove, this);

	    if (asset.resource) {
	      asset.resource.off('set:meshes', this._onRenderSetMeshes, this);
	    }
	  };

	  _proto._onRenderAssetLoad = function _onRenderAssetLoad(asset) {
	    this._onRenderChanged(asset.resource);
	  };

	  _proto._onRenderAssetUnload = function _onRenderAssetUnload(asset) {
	    this._onRenderChanged(null);
	  };

	  _proto._onRenderAssetRemove = function _onRenderAssetRemove(asset) {
	    this._onRenderAssetUnload(asset);
	  };

	  _proto._onRenderChanged = function _onRenderChanged(render) {
	    if (!render) {
	      this._onMeshChanged(null);

	      return;
	    }

	    render.off('set:meshes', this._onRenderSetMeshes, this);
	    render.on('set:meshes', this._onRenderSetMeshes, this);

	    if (render.meshes) {
	      this._onRenderSetMeshes(render.meshes);
	    }
	  };

	  _proto._onRenderSetMeshes = function _onRenderSetMeshes(meshes) {
	    this._onMeshChanged(meshes && meshes[0]);
	  };

	  _proto.onSetLoop = function onSetLoop(name, oldValue, newValue) {
	    if (this.emitter) {
	      this.emitter[name] = newValue;
	      this.emitter.resetTime();
	    }
	  };

	  _proto.onSetBlendType = function onSetBlendType(name, oldValue, newValue) {
	    if (this.emitter) {
	      this.emitter[name] = newValue;
	      this.emitter.material.blendType = newValue;
	      this.emitter.resetMaterial();
	      this.rebuild();
	    }
	  };

	  _proto._requestDepth = function _requestDepth() {
	    if (this._requestedDepth) return;
	    if (!depthLayer) depthLayer = this.system.app.scene.layers.getLayerById(LAYERID_DEPTH);

	    if (depthLayer) {
	      depthLayer.incrementCounter();
	      this._requestedDepth = true;
	    }
	  };

	  _proto._releaseDepth = function _releaseDepth() {
	    if (!this._requestedDepth) return;

	    if (depthLayer) {
	      depthLayer.decrementCounter();
	      this._requestedDepth = false;
	    }
	  };

	  _proto.onSetDepthSoftening = function onSetDepthSoftening(name, oldValue, newValue) {
	    if (oldValue !== newValue) {
	      if (newValue) {
	        if (this.enabled && this.entity.enabled) this._requestDepth();
	        if (this.emitter) this.emitter[name] = newValue;
	      } else {
	        if (this.enabled && this.entity.enabled) this._releaseDepth();
	        if (this.emitter) this.emitter[name] = newValue;
	      }

	      if (this.emitter) {
	        this.reset();
	        this.emitter.resetMaterial();
	        this.rebuild();
	      }
	    }
	  };

	  _proto.onSetSimpleProperty = function onSetSimpleProperty(name, oldValue, newValue) {
	    if (this.emitter) {
	      this.emitter[name] = newValue;
	      this.emitter.resetMaterial();
	    }
	  };

	  _proto.onSetComplexProperty = function onSetComplexProperty(name, oldValue, newValue) {
	    if (this.emitter) {
	      this.emitter[name] = newValue;
	      this.emitter.resetMaterial();
	      this.rebuild();
	      this.reset();
	    }
	  };

	  _proto.onSetGraphProperty = function onSetGraphProperty(name, oldValue, newValue) {
	    if (this.emitter) {
	      this.emitter[name] = newValue;
	      this.emitter.rebuildGraphs();
	      this.emitter.resetMaterial();
	    }
	  };

	  _proto.onEnable = function onEnable() {
	    var data = this.data;

	    for (var i = 0, len = ASSET_PROPERTIES.length; i < len; i++) {
	      var asset = data[ASSET_PROPERTIES[i]];

	      if (asset) {
	        if (!(asset instanceof Asset)) {
	          var id = parseInt(asset, 10);

	          if (id >= 0) {
	            asset = this.system.app.assets.get(asset);
	          } else {
	            continue;
	          }
	        }

	        if (asset && !asset.resource) {
	          this.system.app.assets.load(asset);
	        }
	      }
	    }

	    if (!this.emitter) {
	      var mesh = data.mesh;
	      if (!(mesh instanceof Mesh)) mesh = null;
	      this.emitter = new ParticleEmitter(this.system.app.graphicsDevice, {
	        numParticles: data.numParticles,
	        emitterExtents: data.emitterExtents,
	        emitterExtentsInner: data.emitterExtentsInner,
	        emitterRadius: data.emitterRadius,
	        emitterRadiusInner: data.emitterRadiusInner,
	        emitterShape: data.emitterShape,
	        initialVelocity: data.initialVelocity,
	        wrap: data.wrap,
	        localSpace: data.localSpace,
	        screenSpace: data.screenSpace,
	        wrapBounds: data.wrapBounds,
	        lifetime: data.lifetime,
	        rate: data.rate,
	        rate2: data.rate2,
	        orientation: data.orientation,
	        particleNormal: data.particleNormal,
	        animTilesX: data.animTilesX,
	        animTilesY: data.animTilesY,
	        animStartFrame: data.animStartFrame,
	        animNumFrames: data.animNumFrames,
	        animNumAnimations: data.animNumAnimations,
	        animIndex: data.animIndex,
	        randomizeAnimIndex: data.randomizeAnimIndex,
	        animSpeed: data.animSpeed,
	        animLoop: data.animLoop,
	        startAngle: data.startAngle,
	        startAngle2: data.startAngle2,
	        scaleGraph: data.scaleGraph,
	        scaleGraph2: data.scaleGraph2,
	        colorGraph: data.colorGraph,
	        colorGraph2: data.colorGraph2,
	        alphaGraph: data.alphaGraph,
	        alphaGraph2: data.alphaGraph2,
	        localVelocityGraph: data.localVelocityGraph,
	        localVelocityGraph2: data.localVelocityGraph2,
	        velocityGraph: data.velocityGraph,
	        velocityGraph2: data.velocityGraph2,
	        rotationSpeedGraph: data.rotationSpeedGraph,
	        rotationSpeedGraph2: data.rotationSpeedGraph2,
	        radialSpeedGraph: data.radialSpeedGraph,
	        radialSpeedGraph2: data.radialSpeedGraph2,
	        colorMap: data.colorMap,
	        normalMap: data.normalMap,
	        loop: data.loop,
	        preWarm: data.preWarm,
	        sort: data.sort,
	        stretch: data.stretch,
	        alignToMotion: data.alignToMotion,
	        lighting: data.lighting,
	        halfLambert: data.halfLambert,
	        intensity: data.intensity,
	        depthSoftening: data.depthSoftening,
	        scene: this.system.app.scene,
	        mesh: mesh,
	        depthWrite: data.depthWrite,
	        noFog: data.noFog,
	        node: this.entity,
	        blendType: data.blendType
	      });
	      this.emitter.meshInstance.node = this.entity;
	      this.emitter.drawOrder = this.drawOrder;

	      if (!data.autoPlay) {
	        this.pause();
	        this.emitter.meshInstance.visible = false;
	      }
	    }

	    if (this.emitter.colorMap) {
	      this.addMeshInstanceToLayers();
	    }

	    this.system.app.scene.on('set:layers', this.onLayersChanged, this);

	    if (this.system.app.scene.layers) {
	      this.system.app.scene.layers.on('add', this.onLayerAdded, this);
	      this.system.app.scene.layers.on('remove', this.onLayerRemoved, this);
	    }

	    if (this.enabled && this.entity.enabled && data.depthSoftening) {
	      this._requestDepth();
	    }
	  };

	  _proto.onDisable = function onDisable() {
	    this.system.app.scene.off('set:layers', this.onLayersChanged, this);

	    if (this.system.app.scene.layers) {
	      this.system.app.scene.layers.off('add', this.onLayerAdded, this);
	      this.system.app.scene.layers.off('remove', this.onLayerRemoved, this);
	    }

	    if (this.emitter) {
	      this.removeMeshInstanceFromLayers();
	      if (this.data.depthSoftening) this._releaseDepth();
	      this.emitter.camera = null;
	    }
	  };

	  _proto.onBeforeRemove = function onBeforeRemove() {
	    if (this.enabled) {
	      this.enabled = false;
	    }

	    if (this.emitter) {
	      this.emitter.destroy();
	      this.emitter = null;
	    }

	    for (var i = 0; i < ASSET_PROPERTIES.length; i++) {
	      var prop = ASSET_PROPERTIES[i];

	      if (this.data[prop]) {
	        this[prop] = null;
	      }
	    }

	    this.off();
	  };

	  _proto.reset = function reset() {
	    if (this.emitter) {
	      this.emitter.reset();
	    }
	  };

	  _proto.stop = function stop() {
	    if (this.emitter) {
	      this.emitter.loop = false;
	      this.emitter.resetTime();
	      this.emitter.addTime(0, true);
	    }
	  };

	  _proto.pause = function pause() {
	    this.data.paused = true;
	  };

	  _proto.unpause = function unpause() {
	    this.data.paused = false;
	  };

	  _proto.play = function play() {
	    this.data.paused = false;

	    if (this.emitter) {
	      this.emitter.meshInstance.visible = true;
	      this.emitter.loop = this.data.loop;
	      this.emitter.resetTime();
	    }
	  };

	  _proto.isPlaying = function isPlaying() {
	    if (this.data.paused) {
	      return false;
	    }

	    if (this.emitter && this.emitter.loop) {
	      return true;
	    }

	    return Date.now() <= this.emitter.endTime;
	  };

	  _proto.rebuild = function rebuild() {
	    var enabled = this.enabled;
	    this.enabled = false;

	    if (this.emitter) {
	      this.emitter.rebuild();
	      this.emitter.meshInstance.node = this.entity;
	    }

	    this.enabled = enabled;
	  };

	  _createClass(ParticleSystemComponent, [{
	    key: "drawOrder",
	    get: function get() {
	      return this._drawOrder;
	    },
	    set: function set(drawOrder) {
	      this._drawOrder = drawOrder;

	      if (this.emitter) {
	        this.emitter.drawOrder = drawOrder;
	      }
	    }
	  }]);

	  return ParticleSystemComponent;
	}(Component);

	var ParticleSystemComponentData = function ParticleSystemComponentData() {
	  this.numParticles = 1;
	  this.rate = 1;
	  this.rate2 = null;
	  this.startAngle = 0;
	  this.startAngle2 = null;
	  this.lifetime = 50;
	  this.emitterExtents = new Vec3();
	  this.emitterExtentsInner = new Vec3();
	  this.emitterRadius = 0;
	  this.emitterRadiusInner = 0;
	  this.emitterShape = EMITTERSHAPE_BOX;
	  this.initialVelocity = 0;
	  this.wrapBounds = new Vec3();
	  this.localSpace = false;
	  this.screenSpace = false;
	  this.colorMap = null;
	  this.colorMapAsset = null;
	  this.normalMap = null;
	  this.normalMapAsset = null;
	  this.loop = true;
	  this.preWarm = false;
	  this.sort = 0;
	  this.mode = PARTICLEMODE_GPU;
	  this.scene = null;
	  this.lighting = false;
	  this.halfLambert = false;
	  this.intensity = 1;
	  this.stretch = 0.0;
	  this.alignToMotion = false;
	  this.depthSoftening = 0;
	  this.meshAsset = null;
	  this.mesh = null;
	  this.depthWrite = false;
	  this.noFog = false;
	  this.orientation = PARTICLEORIENTATION_SCREEN;
	  this.particleNormal = new Vec3(0, 1, 0);
	  this.animTilesX = 1;
	  this.animTilesY = 1;
	  this.animStartFrame = 0;
	  this.animNumFrames = 1;
	  this.animNumAnimations = 1;
	  this.animIndex = 0;
	  this.randomizeAnimIndex = false;
	  this.animSpeed = 1;
	  this.animLoop = true;
	  this.scaleGraph = null;
	  this.scaleGraph2 = null;
	  this.colorGraph = null;
	  this.colorGraph2 = null;
	  this.alphaGraph = null;
	  this.alphaGraph2 = null;
	  this.localVelocityGraph = null;
	  this.localVelocityGraph2 = null;
	  this.velocityGraph = null;
	  this.velocityGraph2 = null;
	  this.rotationSpeedGraph = null;
	  this.rotationSpeedGraph2 = null;
	  this.radialSpeedGraph = null;
	  this.radialSpeedGraph2 = null;
	  this.blendType = BLEND_NORMAL;
	  this.enabled = true;
	  this.paused = false;
	  this.autoPlay = true;
	  this.layers = [LAYERID_WORLD];
	};

	var _schema$a = ['enabled', 'autoPlay', 'numParticles', 'lifetime', 'rate', 'rate2', 'startAngle', 'startAngle2', 'loop', 'preWarm', 'lighting', 'halfLambert', 'intensity', 'depthWrite', 'noFog', 'depthSoftening', 'sort', 'blendType', 'stretch', 'alignToMotion', 'emitterShape', 'emitterExtents', 'emitterExtentsInner', 'emitterRadius', 'emitterRadiusInner', 'initialVelocity', 'wrap', 'wrapBounds', 'localSpace', 'screenSpace', 'colorMapAsset', 'normalMapAsset', 'mesh', 'meshAsset', 'renderAsset', 'orientation', 'particleNormal', 'localVelocityGraph', 'localVelocityGraph2', 'velocityGraph', 'velocityGraph2', 'rotationSpeedGraph', 'rotationSpeedGraph2', 'radialSpeedGraph', 'radialSpeedGraph2', 'scaleGraph', 'scaleGraph2', 'colorGraph', 'colorGraph2', 'alphaGraph', 'alphaGraph2', 'colorMap', 'normalMap', 'animTilesX', 'animTilesY', 'animStartFrame', 'animNumFrames', 'animNumAnimations', 'animIndex', 'randomizeAnimIndex', 'animSpeed', 'animLoop', 'layers'];

	var ParticleSystemComponentSystem = function (_ComponentSystem) {
	  _inheritsLoose(ParticleSystemComponentSystem, _ComponentSystem);

	  function ParticleSystemComponentSystem(app) {
	    var _this;

	    _this = _ComponentSystem.call(this, app) || this;
	    _this.id = 'particlesystem';
	    _this.ComponentType = ParticleSystemComponent;
	    _this.DataType = ParticleSystemComponentData;
	    _this.schema = _schema$a;
	    _this.propertyTypes = {
	      emitterExtents: 'vec3',
	      emitterExtentsInner: 'vec3',
	      particleNormal: 'vec3',
	      wrapBounds: 'vec3',
	      localVelocityGraph: 'curveset',
	      localVelocityGraph2: 'curveset',
	      velocityGraph: 'curveset',
	      velocityGraph2: 'curveset',
	      colorGraph: 'curveset',
	      colorGraph2: 'curveset',
	      alphaGraph: 'curve',
	      alphaGraph2: 'curve',
	      rotationSpeedGraph: 'curve',
	      rotationSpeedGraph2: 'curve',
	      radialSpeedGraph: 'curve',
	      radialSpeedGraph2: 'curve',
	      scaleGraph: 'curve',
	      scaleGraph2: 'curve'
	    };

	    _this.on('beforeremove', _this.onBeforeRemove, _assertThisInitialized(_this));

	    _this.app.systems.on('update', _this.onUpdate, _assertThisInitialized(_this));

	    return _this;
	  }

	  var _proto = ParticleSystemComponentSystem.prototype;

	  _proto.initializeComponentData = function initializeComponentData(component, _data, properties) {
	    var data = {};
	    properties = [];
	    var types = this.propertyTypes;

	    if (_data.mesh instanceof Asset || typeof _data.mesh === 'number') {
	      _data.meshAsset = _data.mesh;
	      delete _data.mesh;
	    }

	    for (var prop in _data) {
	      if (_data.hasOwnProperty(prop)) {
	        properties.push(prop);
	        data[prop] = _data[prop];
	      }

	      if (types[prop] === 'vec3') {
	        if (Array.isArray(data[prop])) {
	          data[prop] = new Vec3(data[prop][0], data[prop][1], data[prop][2]);
	        }
	      } else if (types[prop] === 'curve') {
	        if (!(data[prop] instanceof Curve)) {
	          var t = data[prop].type;
	          data[prop] = new Curve(data[prop].keys);
	          data[prop].type = t;
	        }
	      } else if (types[prop] === 'curveset') {
	        if (!(data[prop] instanceof CurveSet)) {
	          var _t = data[prop].type;
	          data[prop] = new CurveSet(data[prop].keys);
	          data[prop].type = _t;
	        }
	      }

	      if (data.layers && Array.isArray(data.layers)) {
	        data.layers = data.layers.slice(0);
	      }
	    }

	    _ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
	  };

	  _proto.cloneComponent = function cloneComponent(entity, clone) {
	    var source = entity.particlesystem.data;
	    var schema = this.schema;
	    var data = {};

	    for (var i = 0, len = schema.length; i < len; i++) {
	      var prop = schema[i];
	      var sourceProp = source[prop];

	      if (sourceProp instanceof Vec3 || sourceProp instanceof Curve || sourceProp instanceof CurveSet) {
	        sourceProp = sourceProp.clone();
	        data[prop] = sourceProp;
	      } else if (prop === 'layers') {
	        data.layers = source.layers.slice(0);
	      } else {
	        if (sourceProp !== null && sourceProp !== undefined) {
	          data[prop] = sourceProp;
	        }
	      }
	    }

	    return this.addComponent(clone, data);
	  };

	  _proto.onUpdate = function onUpdate(dt) {
	    var components = this.store;
	    var numSteps;
	    var stats = this.app.stats.particles;

	    for (var id in components) {
	      if (components.hasOwnProperty(id)) {
	        var component = components[id];
	        var entity = component.entity;
	        var data = component.data;

	        if (data.enabled && entity.enabled) {
	          var emitter = entity.particlesystem.emitter;
	          if (!emitter.meshInstance.visible) continue;

	          if (emitter.lighting) {
	            var layers = data.layers;
	            var lightCube = void 0;

	            for (var i = 0; i < layers.length; i++) {
	              var layer = this.app.scene.layers.getLayerById(layers[i]);
	              if (!layer) continue;

	              if (!layer._lightCube) {
	                layer._lightCube = new Float32Array(6 * 3);
	              }

	              lightCube = layer._lightCube;

	              for (var j = 0; j < 6; j++) {
	                lightCube[j * 3] = this.app.scene.ambientLight.r;
	                lightCube[j * 3 + 1] = this.app.scene.ambientLight.g;
	                lightCube[j * 3 + 2] = this.app.scene.ambientLight.b;
	              }

	              var dirs = layer._splitLights[LIGHTTYPE_DIRECTIONAL];

	              for (var _j = 0; _j < dirs.length; _j++) {
	                for (var c = 0; c < 6; c++) {
	                  var weight = Math.max(emitter.lightCubeDir[c].dot(dirs[_j]._direction), 0) * dirs[_j]._intensity;

	                  lightCube[c * 3] += dirs[_j]._color.r * weight;
	                  lightCube[c * 3 + 1] += dirs[_j]._color.g * weight;
	                  lightCube[c * 3 + 2] += dirs[_j]._color.b * weight;
	                }
	              }
	            }

	            emitter.constantLightCube.setValue(lightCube);
	          }

	          if (!data.paused) {
	            emitter.simTime += dt;

	            if (emitter.simTime > emitter.fixedTimeStep) {
	              numSteps = Math.floor(emitter.simTime / emitter.fixedTimeStep);
	              emitter.simTime -= numSteps * emitter.fixedTimeStep;
	            }

	            if (numSteps) {
	              numSteps = Math.min(numSteps, emitter.maxSubSteps);

	              for (var _i = 0; _i < numSteps; _i++) {
	                emitter.addTime(emitter.fixedTimeStep, false);
	              }

	              stats._updatesPerFrame += numSteps;
	              stats._frameTime += emitter._addTimeTime;
	              emitter._addTimeTime = 0;
	            }

	            emitter.finishFrame();
	          }
	        }
	      }
	    }
	  };

	  _proto.onBeforeRemove = function onBeforeRemove(entity, component) {
	    component.onBeforeRemove();
	  };

	  _proto.destroy = function destroy() {
	    _ComponentSystem.prototype.destroy.call(this);

	    this.app.systems.off('update', this.onUpdate, this);
	  };

	  return ParticleSystemComponentSystem;
	}(ComponentSystem);

	Component._buildAccessors(ParticleSystemComponent.prototype, _schema$a);

	var RenderComponent = function (_Component) {
	  _inheritsLoose(RenderComponent, _Component);

	  function RenderComponent(system, entity) {
	    var _this;

	    _this = _Component.call(this, system, entity) || this;
	    _this._type = 'asset';
	    _this._castShadows = true;
	    _this._receiveShadows = true;
	    _this._castShadowsLightmap = true;
	    _this._lightmapped = false;
	    _this._lightmapSizeMultiplier = 1;
	    _this._isStatic = false;
	    _this._batchGroupId = -1;
	    _this._layers = [LAYERID_WORLD];
	    _this._renderStyle = RENDERSTYLE_SOLID;
	    _this._meshInstances = [];
	    _this._customAabb = null;
	    _this._area = null;
	    _this._assetReference = [];
	    _this._materialReferences = [];
	    _this._material = void 0;
	    _this._rootBone = void 0;
	    _this._rootBone = new EntityReference(_assertThisInitialized(_this), 'rootBone');

	    _this._rootBone.on('set:entity', _this._onSetRootBone, _assertThisInitialized(_this));

	    _this._assetReference = new AssetReference('asset', _assertThisInitialized(_this), system.app.assets, {
	      add: _this._onRenderAssetAdded,
	      load: _this._onRenderAssetLoad,
	      remove: _this._onRenderAssetRemove,
	      unload: _this._onRenderAssetUnload
	    }, _assertThisInitialized(_this));
	    _this._material = system.defaultMaterial;
	    entity.on('remove', _this.onRemoveChild, _assertThisInitialized(_this));
	    entity.on('removehierarchy', _this.onRemoveChild, _assertThisInitialized(_this));
	    entity.on('insert', _this.onInsertChild, _assertThisInitialized(_this));
	    entity.on('inserthierarchy', _this.onInsertChild, _assertThisInitialized(_this));
	    return _this;
	  }

	  var _proto = RenderComponent.prototype;

	  _proto.assignAsset = function assignAsset(asset) {
	    var id = asset instanceof Asset ? asset.id : asset;
	    this._assetReference.id = id;
	  };

	  _proto._onSetRootBone = function _onSetRootBone(entity) {
	    if (entity) {
	      this._onRootBoneChanged();
	    }
	  };

	  _proto._onRootBoneChanged = function _onRootBoneChanged() {
	    this._clearSkinInstances();

	    if (this.enabled && this.entity.enabled) {
	      this._cloneSkinInstances();
	    }
	  };

	  _proto.destroyMeshInstances = function destroyMeshInstances() {
	    var meshInstances = this._meshInstances;

	    if (meshInstances) {
	      this.removeFromLayers();

	      this._clearSkinInstances();

	      for (var i = 0; i < meshInstances.length; i++) {
	        meshInstances[i].destroy();
	      }

	      this._meshInstances.length = 0;
	    }
	  };

	  _proto.addToLayers = function addToLayers() {
	    var layers = this.system.app.scene.layers;

	    for (var i = 0; i < this._layers.length; i++) {
	      var layer = layers.getLayerById(this._layers[i]);

	      if (layer) {
	        layer.addMeshInstances(this._meshInstances);
	      }
	    }
	  };

	  _proto.removeFromLayers = function removeFromLayers() {
	    if (this._meshInstances && this._meshInstances.length) {
	      var layers = this.system.app.scene.layers;

	      for (var i = 0; i < this._layers.length; i++) {
	        var layer = layers.getLayerById(this._layers[i]);

	        if (layer) {
	          layer.removeMeshInstances(this._meshInstances);
	        }
	      }
	    }
	  };

	  _proto.onRemoveChild = function onRemoveChild() {
	    this.removeFromLayers();
	  };

	  _proto.onInsertChild = function onInsertChild() {
	    if (this._meshInstances && this.enabled && this.entity.enabled) {
	      this.addToLayers();
	    }
	  };

	  _proto.onRemove = function onRemove() {
	    this.destroyMeshInstances();
	    this.asset = null;
	    this.materialAsset = null;
	    this._assetReference.id = null;

	    for (var i = 0; i < this._materialReferences.length; i++) {
	      this._materialReferences[i].id = null;
	    }

	    this.entity.off('remove', this.onRemoveChild, this);
	    this.entity.off('insert', this.onInsertChild, this);
	  };

	  _proto.onLayersChanged = function onLayersChanged(oldComp, newComp) {
	    this.addToLayers();
	    oldComp.off('add', this.onLayerAdded, this);
	    oldComp.off('remove', this.onLayerRemoved, this);
	    newComp.on('add', this.onLayerAdded, this);
	    newComp.on('remove', this.onLayerRemoved, this);
	  };

	  _proto.onLayerAdded = function onLayerAdded(layer) {
	    var index = this.layers.indexOf(layer.id);
	    if (index < 0) return;
	    layer.addMeshInstances(this._meshInstances);
	  };

	  _proto.onLayerRemoved = function onLayerRemoved(layer) {
	    var index = this.layers.indexOf(layer.id);
	    if (index < 0) return;
	    layer.removeMeshInstances(this._meshInstances);
	  };

	  _proto.onEnable = function onEnable() {
	    var app = this.system.app;
	    var scene = app.scene;

	    this._rootBone.onParentComponentEnable();

	    this._cloneSkinInstances();

	    scene.on('set:layers', this.onLayersChanged, this);

	    if (scene.layers) {
	      scene.layers.on('add', this.onLayerAdded, this);
	      scene.layers.on('remove', this.onLayerRemoved, this);
	    }

	    var isAsset = this._type === 'asset';

	    if (this._meshInstances && this._meshInstances.length) {
	      this.addToLayers();
	    } else if (isAsset && this.asset) {
	      this._onRenderAssetAdded();
	    }

	    for (var i = 0; i < this._materialReferences.length; i++) {
	      if (this._materialReferences[i].asset) {
	        this.system.app.assets.load(this._materialReferences[i].asset);
	      }
	    }

	    if (this._batchGroupId >= 0) {
	      var _app$batcher;

	      (_app$batcher = app.batcher) == null ? void 0 : _app$batcher.insert(BatchGroup.RENDER, this.batchGroupId, this.entity);
	    }
	  };

	  _proto.onDisable = function onDisable() {
	    var app = this.system.app;
	    var scene = app.scene;
	    scene.off('set:layers', this.onLayersChanged, this);

	    if (scene.layers) {
	      scene.layers.off('add', this.onLayerAdded, this);
	      scene.layers.off('remove', this.onLayerRemoved, this);
	    }

	    if (this._batchGroupId >= 0) {
	      var _app$batcher2;

	      (_app$batcher2 = app.batcher) == null ? void 0 : _app$batcher2.remove(BatchGroup.RENDER, this.batchGroupId, this.entity);
	    }

	    this.removeFromLayers();
	  };

	  _proto.hide = function hide() {
	    if (this._meshInstances) {
	      for (var i = 0; i < this._meshInstances.length; i++) {
	        this._meshInstances[i].visible = false;
	      }
	    }
	  };

	  _proto.show = function show() {
	    if (this._meshInstances) {
	      for (var i = 0; i < this._meshInstances.length; i++) {
	        this._meshInstances[i].visible = true;
	      }
	    }
	  };

	  _proto._onRenderAssetAdded = function _onRenderAssetAdded() {
	    if (!this._assetReference.asset) return;

	    if (this._assetReference.asset.resource) {
	      this._onRenderAssetLoad();
	    } else if (this.enabled && this.entity.enabled) {
	      this.system.app.assets.load(this._assetReference.asset);
	    }
	  };

	  _proto._onRenderAssetLoad = function _onRenderAssetLoad() {
	    this.destroyMeshInstances();

	    if (this._assetReference.asset) {
	      var render = this._assetReference.asset.resource;
	      render.off('set:meshes', this._onSetMeshes, this);
	      render.on('set:meshes', this._onSetMeshes, this);

	      if (render.meshes) {
	        this._onSetMeshes(render.meshes);
	      }
	    }
	  };

	  _proto._onSetMeshes = function _onSetMeshes(meshes) {
	    this._cloneMeshes(meshes);
	  };

	  _proto._clearSkinInstances = function _clearSkinInstances() {
	    for (var i = 0; i < this._meshInstances.length; i++) {
	      var meshInstance = this._meshInstances[i];
	      SkinInstanceCache.removeCachedSkinInstance(meshInstance.skinInstance);
	      meshInstance.skinInstance = null;
	    }
	  };

	  _proto._cloneSkinInstances = function _cloneSkinInstances() {
	    if (this._meshInstances.length && this._rootBone.entity instanceof GraphNode) {
	      for (var i = 0; i < this._meshInstances.length; i++) {
	        var meshInstance = this._meshInstances[i];
	        var mesh = meshInstance.mesh;

	        if (mesh.skin && !mesh.skinInstance) {
	          meshInstance.skinInstance = SkinInstanceCache.createCachedSkinInstance(mesh.skin, this._rootBone.entity, this.entity);
	        }
	      }
	    }
	  };

	  _proto._cloneMeshes = function _cloneMeshes(meshes) {
	    if (meshes && meshes.length) {
	      var meshInstances = [];

	      for (var i = 0; i < meshes.length; i++) {
	        var mesh = meshes[i];
	        var material = this._materialReferences[i] && this._materialReferences[i].asset && this._materialReferences[i].asset.resource;
	        var meshInst = new MeshInstance(mesh, material || this.system.defaultMaterial, this.entity);
	        meshInstances.push(meshInst);

	        if (mesh.morph) {
	          meshInst.morphInstance = new MorphInstance(mesh.morph);
	        }
	      }

	      this.meshInstances = meshInstances;

	      this._cloneSkinInstances();
	    }
	  };

	  _proto._onRenderAssetUnload = function _onRenderAssetUnload() {
	    if (this._type === 'asset') {
	      this.destroyMeshInstances();
	    }
	  };

	  _proto._onRenderAssetRemove = function _onRenderAssetRemove() {
	    if (this._assetReference.asset && this._assetReference.asset.resource) {
	      this._assetReference.asset.resource.off('set:meshes', this._onSetMeshes, this);
	    }

	    this._onRenderAssetUnload();
	  };

	  _proto._onMaterialAdded = function _onMaterialAdded(index, component, asset) {
	    if (asset.resource) {
	      this._onMaterialLoad(index, component, asset);
	    } else {
	      if (this.enabled && this.entity.enabled) {
	        this.system.app.assets.load(asset);
	      }
	    }
	  };

	  _proto._updateMainMaterial = function _updateMainMaterial(index, material) {
	    if (index === 0) {
	      this.material = material;
	    }
	  };

	  _proto._onMaterialLoad = function _onMaterialLoad(index, component, asset) {
	    if (this._meshInstances[index]) {
	      this._meshInstances[index].material = asset.resource;
	    }

	    this._updateMainMaterial(index, asset.resource);
	  };

	  _proto._onMaterialRemove = function _onMaterialRemove(index, component, asset) {
	    if (this._meshInstances[index]) {
	      this._meshInstances[index].material = this.system.defaultMaterial;
	    }

	    this._updateMainMaterial(index, this.system.defaultMaterial);
	  };

	  _proto._onMaterialUnload = function _onMaterialUnload(index, component, asset) {
	    if (this._meshInstances[index]) {
	      this._meshInstances[index].material = this.system.defaultMaterial;
	    }

	    this._updateMainMaterial(index, this.system.defaultMaterial);
	  };

	  _proto.resolveDuplicatedEntityReferenceProperties = function resolveDuplicatedEntityReferenceProperties(oldRender, duplicatedIdsMap) {
	    if (oldRender.rootBone && duplicatedIdsMap[oldRender.rootBone]) {
	      this.rootBone = duplicatedIdsMap[oldRender.rootBone];
	    }

	    this._clearSkinInstances();
	  };

	  _createClass(RenderComponent, [{
	    key: "renderStyle",
	    get: function get() {
	      return this._renderStyle;
	    },
	    set: function set(renderStyle) {
	      if (this._renderStyle !== renderStyle) {
	        this._renderStyle = renderStyle;

	        MeshInstance._prepareRenderStyleForArray(this._meshInstances, renderStyle);
	      }
	    }
	  }, {
	    key: "customAabb",
	    get: function get() {
	      return this._customAabb;
	    },
	    set: function set(value) {
	      this._customAabb = value;
	      var mi = this._meshInstances;

	      if (mi) {
	        for (var i = 0; i < mi.length; i++) {
	          mi[i].setCustomAabb(this._customAabb);
	        }
	      }
	    }
	  }, {
	    key: "type",
	    get: function get() {
	      return this._type;
	    },
	    set: function set(value) {
	      if (this._type !== value) {
	        this._area = null;
	        this._type = value;
	        this.destroyMeshInstances();

	        if (value !== 'asset') {
	          var material = this._material;

	          if (!material || material === this.system.defaultMaterial) {
	            material = this._materialReferences[0] && this._materialReferences[0].asset && this._materialReferences[0].asset.resource;
	          }

	          var primData = getShapePrimitive(this.system.app.graphicsDevice, value);
	          this._area = primData.area;
	          this.meshInstances = [new MeshInstance(primData.mesh, material || this.system.defaultMaterial, this.entity)];
	        }
	      }
	    }
	  }, {
	    key: "meshInstances",
	    get: function get() {
	      return this._meshInstances;
	    },
	    set: function set(value) {
	      this.destroyMeshInstances();
	      this._meshInstances = value;

	      if (this._meshInstances) {
	        var mi = this._meshInstances;

	        for (var i = 0; i < mi.length; i++) {
	          if (!mi[i].node) {
	            mi[i].node = this.entity;
	          }

	          mi[i].castShadow = this._castShadows;
	          mi[i].receiveShadow = this._receiveShadows;
	          mi[i].isStatic = this._isStatic;
	          mi[i].renderStyle = this._renderStyle;
	          mi[i].setLightmapped(this._lightmapped);
	          mi[i].setCustomAabb(this._customAabb);
	        }

	        if (this.enabled && this.entity.enabled) {
	          this.addToLayers();
	        }
	      }
	    }
	  }, {
	    key: "lightmapped",
	    get: function get() {
	      return this._lightmapped;
	    },
	    set: function set(value) {
	      if (value !== this._lightmapped) {
	        this._lightmapped = value;
	        var mi = this._meshInstances;

	        if (mi) {
	          for (var i = 0; i < mi.length; i++) {
	            mi[i].setLightmapped(value);
	          }
	        }
	      }
	    }
	  }, {
	    key: "castShadows",
	    get: function get() {
	      return this._castShadows;
	    },
	    set: function set(value) {
	      if (this._castShadows !== value) {
	        var mi = this._meshInstances;

	        if (mi) {
	          var layers = this.layers;
	          var scene = this.system.app.scene;

	          if (this._castShadows && !value) {
	            for (var i = 0; i < layers.length; i++) {
	              var layer = scene.layers.getLayerById(this.layers[i]);

	              if (layer) {
	                layer.removeShadowCasters(mi);
	              }
	            }
	          }

	          for (var _i = 0; _i < mi.length; _i++) {
	            mi[_i].castShadow = value;
	          }

	          if (!this._castShadows && value) {
	            for (var _i2 = 0; _i2 < layers.length; _i2++) {
	              var _layer = scene.layers.getLayerById(layers[_i2]);

	              if (_layer) {
	                _layer.addShadowCasters(mi);
	              }
	            }
	          }
	        }

	        this._castShadows = value;
	      }
	    }
	  }, {
	    key: "receiveShadows",
	    get: function get() {
	      return this._receiveShadows;
	    },
	    set: function set(value) {
	      if (this._receiveShadows !== value) {
	        this._receiveShadows = value;
	        var mi = this._meshInstances;

	        if (mi) {
	          for (var i = 0; i < mi.length; i++) {
	            mi[i].receiveShadow = value;
	          }
	        }
	      }
	    }
	  }, {
	    key: "castShadowsLightmap",
	    get: function get() {
	      return this._castShadowsLightmap;
	    },
	    set: function set(value) {
	      this._castShadowsLightmap = value;
	    }
	  }, {
	    key: "lightmapSizeMultiplier",
	    get: function get() {
	      return this._lightmapSizeMultiplier;
	    },
	    set: function set(value) {
	      this._lightmapSizeMultiplier = value;
	    }
	  }, {
	    key: "isStatic",
	    get: function get() {
	      return this._isStatic;
	    },
	    set: function set(value) {
	      if (this._isStatic !== value) {
	        this._isStatic = value;
	        var mi = this._meshInstances;

	        if (mi) {
	          for (var i = 0; i < mi.length; i++) {
	            mi[i].isStatic = value;
	          }
	        }
	      }
	    }
	  }, {
	    key: "layers",
	    get: function get() {
	      return this._layers;
	    },
	    set: function set(value) {
	      var layers = this.system.app.scene.layers;
	      var layer;

	      if (this._meshInstances) {
	        for (var i = 0; i < this._layers.length; i++) {
	          layer = layers.getLayerById(this._layers[i]);

	          if (layer) {
	            layer.removeMeshInstances(this._meshInstances);
	          }
	        }
	      }

	      this._layers.length = 0;

	      for (var _i3 = 0; _i3 < value.length; _i3++) {
	        this._layers[_i3] = value[_i3];
	      }

	      if (!this.enabled || !this.entity.enabled || !this._meshInstances) return;

	      for (var _i4 = 0; _i4 < this._layers.length; _i4++) {
	        layer = layers.getLayerById(this._layers[_i4]);

	        if (layer) {
	          layer.addMeshInstances(this._meshInstances);
	        }
	      }
	    }
	  }, {
	    key: "batchGroupId",
	    get: function get() {
	      return this._batchGroupId;
	    },
	    set: function set(value) {
	      if (this._batchGroupId !== value) {
	        if (this.entity.enabled && this._batchGroupId >= 0) {
	          var _this$system$app$batc;

	          (_this$system$app$batc = this.system.app.batcher) == null ? void 0 : _this$system$app$batc.remove(BatchGroup.RENDER, this.batchGroupId, this.entity);
	        }

	        if (this.entity.enabled && value >= 0) {
	          var _this$system$app$batc2;

	          (_this$system$app$batc2 = this.system.app.batcher) == null ? void 0 : _this$system$app$batc2.insert(BatchGroup.RENDER, value, this.entity);
	        }

	        if (value < 0 && this._batchGroupId >= 0 && this.enabled && this.entity.enabled) {
	          this.addToLayers();
	        }

	        this._batchGroupId = value;
	      }
	    }
	  }, {
	    key: "material",
	    get: function get() {
	      return this._material;
	    },
	    set: function set(value) {
	      if (this._material !== value) {
	        this._material = value;

	        if (this._meshInstances && this._type !== 'asset') {
	          for (var i = 0; i < this._meshInstances.length; i++) {
	            this._meshInstances[i].material = value;
	          }
	        }
	      }
	    }
	  }, {
	    key: "materialAssets",
	    get: function get() {
	      return this._materialReferences.map(function (ref) {
	        return ref.id;
	      });
	    },
	    set: function set(value) {
	      if (value === void 0) {
	        value = [];
	      }

	      if (this._materialReferences.length > value.length) {
	        for (var i = value.length; i < this._materialReferences.length; i++) {
	          this._materialReferences[i].id = null;
	        }

	        this._materialReferences.length = value.length;
	      }

	      for (var _i5 = 0; _i5 < value.length; _i5++) {
	        if (!this._materialReferences[_i5]) {
	          this._materialReferences.push(new AssetReference(_i5, this, this.system.app.assets, {
	            add: this._onMaterialAdded,
	            load: this._onMaterialLoad,
	            remove: this._onMaterialRemove,
	            unload: this._onMaterialUnload
	          }, this));
	        }

	        if (value[_i5]) {
	          var id = value[_i5] instanceof Asset ? value[_i5].id : value[_i5];

	          if (this._materialReferences[_i5].id !== id) {
	            this._materialReferences[_i5].id = id;
	          }

	          if (this._materialReferences[_i5].asset) {
	            this._onMaterialAdded(_i5, this, this._materialReferences[_i5].asset);
	          }
	        } else {
	          this._materialReferences[_i5].id = null;

	          if (this._meshInstances[_i5]) {
	            this._meshInstances[_i5].material = this.system.defaultMaterial;
	          }
	        }
	      }
	    }
	  }, {
	    key: "asset",
	    get: function get() {
	      return this._assetReference.id;
	    },
	    set: function set(value) {
	      var id = value instanceof Asset ? value.id : value;
	      if (this._assetReference.id === id) return;

	      if (this._assetReference.asset && this._assetReference.asset.resource) {
	        this._onRenderAssetRemove();
	      }

	      this._assetReference.id = id;

	      if (this._assetReference.asset) {
	        this._onRenderAssetAdded();
	      }
	    }
	  }]);

	  return RenderComponent;
	}(Component);

	var RenderComponentData = function RenderComponentData() {
	  this.enabled = true;
	  this.rootBone = null;
	};

	var _schema$9 = [{
	  name: 'rootBone',
	  type: 'entity'
	}, 'enabled'];
	var _properties = ['material', 'meshInstances', 'asset', 'materialAssets', 'castShadows', 'receiveShadows', 'castShadowsLightmap', 'lightmapped', 'lightmapSizeMultiplier', 'renderStyle', 'type', 'layers', 'isStatic', 'batchGroupId'];

	var RenderComponentSystem = function (_ComponentSystem) {
	  _inheritsLoose(RenderComponentSystem, _ComponentSystem);

	  function RenderComponentSystem(app) {
	    var _this;

	    _this = _ComponentSystem.call(this, app) || this;
	    _this.id = 'render';
	    _this.ComponentType = RenderComponent;
	    _this.DataType = RenderComponentData;
	    _this.schema = _schema$9;
	    _this.defaultMaterial = getDefaultMaterial(app.graphicsDevice);

	    _this.on('beforeremove', _this.onRemove, _assertThisInitialized(_this));

	    return _this;
	  }

	  var _proto = RenderComponentSystem.prototype;

	  _proto.initializeComponentData = function initializeComponentData(component, _data, properties) {
	    if (_data.batchGroupId === null || _data.batchGroupId === undefined) {
	      _data.batchGroupId = -1;
	    }

	    if (_data.layers && _data.layers.length) {
	      _data.layers = _data.layers.slice(0);
	    }

	    for (var i = 0; i < _properties.length; i++) {
	      if (_data.hasOwnProperty(_properties[i])) {
	        component[_properties[i]] = _data[_properties[i]];
	      }
	    }

	    if (_data.aabbCenter && _data.aabbHalfExtents) {
	      component.customAabb = new BoundingBox(new Vec3(_data.aabbCenter), new Vec3(_data.aabbHalfExtents));
	    }

	    _ComponentSystem.prototype.initializeComponentData.call(this, component, _data, _schema$9);
	  };

	  _proto.cloneComponent = function cloneComponent(entity, clone) {
	    var data = {};

	    for (var i = 0; i < _properties.length; i++) {
	      data[_properties[i]] = entity.render[_properties[i]];
	    }

	    data.enabled = entity.render.enabled;
	    delete data.meshInstances;
	    var component = this.addComponent(clone, data);
	    var srcMeshInstances = entity.render.meshInstances;
	    var meshes = srcMeshInstances.map(function (mi) {
	      return mi.mesh;
	    });

	    component._onSetMeshes(meshes);

	    for (var m = 0; m < srcMeshInstances.length; m++) {
	      component.meshInstances[m].material = srcMeshInstances[m].material;
	    }

	    if (entity.render.customAabb) {
	      component.customAabb = entity.render.customAabb.clone();
	    }

	    return component;
	  };

	  _proto.onRemove = function onRemove(entity, component) {
	    component.onRemove();
	  };

	  return RenderComponentSystem;
	}(ComponentSystem);

	Component._buildAccessors(RenderComponent.prototype, _schema$9);

	var ObjectPool = function () {
	  function ObjectPool(constructorFunc, size) {
	    this._constructor = constructorFunc;
	    this._pool = [];
	    this._count = 0;

	    this._resize(size);
	  }

	  var _proto = ObjectPool.prototype;

	  _proto._resize = function _resize(size) {
	    if (size > this._pool.length) {
	      for (var i = this._pool.length; i < size; i++) {
	        this._pool[i] = new this._constructor();
	      }
	    }
	  };

	  _proto.allocate = function allocate() {
	    if (this._count >= this._pool.length) {
	      this._resize(this._pool.length * 2);
	    }

	    return this._pool[this._count++];
	  };

	  _proto.freeAll = function freeAll() {
	    this._count = 0;
	  };

	  return ObjectPool;
	}();

	var ammoTransform;
	var ammoVec1, ammoVec2, ammoQuat, ammoOrigin;

	var RigidBodyComponent = function (_Component) {
	  _inheritsLoose(RigidBodyComponent, _Component);

	  function RigidBodyComponent(system, entity) {
	    var _this;

	    _this = _Component.call(this, system, entity) || this;
	    _this._angularDamping = 0;
	    _this._angularFactor = new Vec3(1, 1, 1);
	    _this._angularVelocity = new Vec3();
	    _this._body = null;
	    _this._friction = 0.5;
	    _this._group = BODYGROUP_STATIC;
	    _this._linearDamping = 0;
	    _this._linearFactor = new Vec3(1, 1, 1);
	    _this._linearVelocity = new Vec3();
	    _this._mask = BODYMASK_NOT_STATIC;
	    _this._mass = 1;
	    _this._restitution = 0;
	    _this._rollingFriction = 0;
	    _this._simulationEnabled = false;
	    _this._type = BODYTYPE_STATIC;
	    return _this;
	  }

	  RigidBodyComponent.onLibraryLoaded = function onLibraryLoaded() {
	    if (typeof Ammo !== 'undefined') {
	      ammoTransform = new Ammo.btTransform();
	      ammoVec1 = new Ammo.btVector3();
	      ammoVec2 = new Ammo.btVector3();
	      ammoQuat = new Ammo.btQuaternion();
	      ammoOrigin = new Ammo.btVector3(0, 0, 0);
	    }
	  };

	  var _proto = RigidBodyComponent.prototype;

	  _proto.createBody = function createBody() {
	    var entity = this.entity;
	    var shape;

	    if (entity.collision) {
	      shape = entity.collision.shape;

	      if (entity.trigger) {
	        entity.trigger.destroy();
	        delete entity.trigger;
	      }
	    }

	    if (shape) {
	      if (this._body) this.system.onRemove(entity, this);
	      var mass = this._type === BODYTYPE_DYNAMIC ? this._mass : 0;

	      this._getEntityTransform(ammoTransform);

	      var body = this.system.createBody(mass, shape, ammoTransform);
	      body.setRestitution(this._restitution);
	      body.setFriction(this._friction);
	      body.setRollingFriction(this._rollingFriction);
	      body.setDamping(this._linearDamping, this._angularDamping);

	      if (this._type === BODYTYPE_DYNAMIC) {
	        var linearFactor = this._linearFactor;
	        ammoVec1.setValue(linearFactor.x, linearFactor.y, linearFactor.z);
	        body.setLinearFactor(ammoVec1);
	        var angularFactor = this._angularFactor;
	        ammoVec1.setValue(angularFactor.x, angularFactor.y, angularFactor.z);
	        body.setAngularFactor(ammoVec1);
	      } else if (this._type === BODYTYPE_KINEMATIC) {
	        body.setCollisionFlags(body.getCollisionFlags() | BODYFLAG_KINEMATIC_OBJECT);
	        body.setActivationState(BODYSTATE_DISABLE_DEACTIVATION);
	      }

	      body.entity = entity;
	      this.body = body;

	      if (this.enabled && entity.enabled) {
	        this.enableSimulation();
	      }
	    }
	  };

	  _proto.isActive = function isActive() {
	    return this._body ? this._body.isActive() : false;
	  };

	  _proto.activate = function activate() {
	    if (this._body) {
	      this._body.activate();
	    }
	  };

	  _proto.enableSimulation = function enableSimulation() {
	    var entity = this.entity;

	    if (entity.collision && entity.collision.enabled && !this._simulationEnabled) {
	      var body = this._body;

	      if (body) {
	        this.system.addBody(body, this._group, this._mask);

	        switch (this._type) {
	          case BODYTYPE_DYNAMIC:
	            this.system._dynamic.push(this);

	            body.forceActivationState(BODYSTATE_ACTIVE_TAG);
	            this.syncEntityToBody();
	            break;

	          case BODYTYPE_KINEMATIC:
	            this.system._kinematic.push(this);

	            body.forceActivationState(BODYSTATE_DISABLE_DEACTIVATION);
	            break;

	          case BODYTYPE_STATIC:
	            body.forceActivationState(BODYSTATE_ACTIVE_TAG);
	            this.syncEntityToBody();
	            break;
	        }

	        if (entity.collision.type === 'compound') {
	          this.system._compounds.push(entity.collision);
	        }

	        body.activate();
	        this._simulationEnabled = true;
	      }
	    }
	  };

	  _proto.disableSimulation = function disableSimulation() {
	    var body = this._body;

	    if (body && this._simulationEnabled) {
	      var system = this.system;

	      var idx = system._compounds.indexOf(this.entity.collision);

	      if (idx > -1) {
	        system._compounds.splice(idx, 1);
	      }

	      idx = system._dynamic.indexOf(this);

	      if (idx > -1) {
	        system._dynamic.splice(idx, 1);
	      }

	      idx = system._kinematic.indexOf(this);

	      if (idx > -1) {
	        system._kinematic.splice(idx, 1);
	      }

	      system.removeBody(body);
	      body.forceActivationState(BODYSTATE_DISABLE_SIMULATION);
	      this._simulationEnabled = false;
	    }
	  };

	  _proto.applyForce = function applyForce() {
	    var x, y, z;
	    var px, py, pz;

	    switch (arguments.length) {
	      case 1:
	        x = arguments[0].x;
	        y = arguments[0].y;
	        z = arguments[0].z;
	        break;

	      case 2:
	        x = arguments[0].x;
	        y = arguments[0].y;
	        z = arguments[0].z;
	        px = arguments[1].x;
	        py = arguments[1].y;
	        pz = arguments[1].z;
	        break;

	      case 3:
	        x = arguments[0];
	        y = arguments[1];
	        z = arguments[2];
	        break;

	      case 6:
	        x = arguments[0];
	        y = arguments[1];
	        z = arguments[2];
	        px = arguments[3];
	        py = arguments[4];
	        pz = arguments[5];
	        break;
	    }

	    var body = this._body;

	    if (body) {
	      body.activate();
	      ammoVec1.setValue(x, y, z);

	      if (px !== undefined) {
	        ammoVec2.setValue(px, py, pz);
	        body.applyForce(ammoVec1, ammoVec2);
	      } else {
	        body.applyForce(ammoVec1, ammoOrigin);
	      }
	    }
	  };

	  _proto.applyTorque = function applyTorque() {
	    var x, y, z;

	    switch (arguments.length) {
	      case 1:
	        x = arguments[0].x;
	        y = arguments[0].y;
	        z = arguments[0].z;
	        break;

	      case 3:
	        x = arguments[0];
	        y = arguments[1];
	        z = arguments[2];
	        break;

	      default:
	        return;
	    }

	    var body = this._body;

	    if (body) {
	      body.activate();
	      ammoVec1.setValue(x, y, z);
	      body.applyTorque(ammoVec1);
	    }
	  };

	  _proto.applyImpulse = function applyImpulse() {
	    var x, y, z;
	    var px, py, pz;

	    switch (arguments.length) {
	      case 1:
	        x = arguments[0].x;
	        y = arguments[0].y;
	        z = arguments[0].z;
	        break;

	      case 2:
	        x = arguments[0].x;
	        y = arguments[0].y;
	        z = arguments[0].z;
	        px = arguments[1].x;
	        py = arguments[1].y;
	        pz = arguments[1].z;
	        break;

	      case 3:
	        x = arguments[0];
	        y = arguments[1];
	        z = arguments[2];
	        break;

	      case 6:
	        x = arguments[0];
	        y = arguments[1];
	        z = arguments[2];
	        px = arguments[3];
	        py = arguments[4];
	        pz = arguments[5];
	        break;

	      default:
	        return;
	    }

	    var body = this._body;

	    if (body) {
	      body.activate();
	      ammoVec1.setValue(x, y, z);

	      if (px !== undefined) {
	        ammoVec2.setValue(px, py, pz);
	        body.applyImpulse(ammoVec1, ammoVec2);
	      } else {
	        body.applyImpulse(ammoVec1, ammoOrigin);
	      }
	    }
	  };

	  _proto.applyTorqueImpulse = function applyTorqueImpulse() {
	    var x, y, z;

	    switch (arguments.length) {
	      case 1:
	        x = arguments[0].x;
	        y = arguments[0].y;
	        z = arguments[0].z;
	        break;

	      case 3:
	        x = arguments[0];
	        y = arguments[1];
	        z = arguments[2];
	        break;

	      default:
	        return;
	    }

	    var body = this._body;

	    if (body) {
	      body.activate();
	      ammoVec1.setValue(x, y, z);
	      body.applyTorqueImpulse(ammoVec1);
	    }
	  };

	  _proto.isStatic = function isStatic() {
	    return this._type === BODYTYPE_STATIC;
	  };

	  _proto.isStaticOrKinematic = function isStaticOrKinematic() {
	    return this._type === BODYTYPE_STATIC || this._type === BODYTYPE_KINEMATIC;
	  };

	  _proto.isKinematic = function isKinematic() {
	    return this._type === BODYTYPE_KINEMATIC;
	  };

	  _proto._getEntityTransform = function _getEntityTransform(transform) {
	    var entity = this.entity;
	    var pos = entity.getPosition();
	    var rot = entity.getRotation();
	    ammoVec1.setValue(pos.x, pos.y, pos.z);
	    ammoQuat.setValue(rot.x, rot.y, rot.z, rot.w);
	    transform.setOrigin(ammoVec1);
	    transform.setRotation(ammoQuat);
	  };

	  _proto.syncEntityToBody = function syncEntityToBody() {
	    var body = this._body;

	    if (body) {
	      this._getEntityTransform(ammoTransform);

	      body.setWorldTransform(ammoTransform);

	      if (this._type === BODYTYPE_KINEMATIC) {
	        var motionState = body.getMotionState();

	        if (motionState) {
	          motionState.setWorldTransform(ammoTransform);
	        }
	      }

	      body.activate();
	    }
	  };

	  _proto._updateDynamic = function _updateDynamic() {
	    var body = this._body;

	    if (body.isActive()) {
	      var motionState = body.getMotionState();

	      if (motionState) {
	        motionState.getWorldTransform(ammoTransform);
	        var p = ammoTransform.getOrigin();
	        var q = ammoTransform.getRotation();
	        this.entity.setPosition(p.x(), p.y(), p.z());
	        this.entity.setRotation(q.x(), q.y(), q.z(), q.w());
	      }
	    }
	  };

	  _proto._updateKinematic = function _updateKinematic() {
	    var motionState = this._body.getMotionState();

	    if (motionState) {
	      this._getEntityTransform(ammoTransform);

	      motionState.setWorldTransform(ammoTransform);
	    }
	  };

	  _proto.teleport = function teleport() {
	    if (arguments.length < 3) {
	      if (arguments[0]) {
	        this.entity.setPosition(arguments[0]);
	      }

	      if (arguments[1]) {
	        if (arguments[1] instanceof Quat) {
	          this.entity.setRotation(arguments[1]);
	        } else {
	          this.entity.setEulerAngles(arguments[1]);
	        }
	      }
	    } else {
	      if (arguments.length === 6) {
	        this.entity.setEulerAngles(arguments[3], arguments[4], arguments[5]);
	      }

	      this.entity.setPosition(arguments[0], arguments[1], arguments[2]);
	    }

	    this.syncEntityToBody();
	  };

	  _proto.onEnable = function onEnable() {
	    if (!this._body) {
	      this.createBody();
	    }

	    this.enableSimulation();
	  };

	  _proto.onDisable = function onDisable() {
	    this.disableSimulation();
	  };

	  _createClass(RigidBodyComponent, [{
	    key: "angularDamping",
	    get: function get() {
	      return this._angularDamping;
	    },
	    set: function set(damping) {
	      if (this._angularDamping !== damping) {
	        this._angularDamping = damping;

	        if (this._body) {
	          this._body.setDamping(this._linearDamping, damping);
	        }
	      }
	    }
	  }, {
	    key: "angularFactor",
	    get: function get() {
	      return this._angularFactor;
	    },
	    set: function set(factor) {
	      if (!this._angularFactor.equals(factor)) {
	        this._angularFactor.copy(factor);

	        if (this._body && this._type === BODYTYPE_DYNAMIC) {
	          ammoVec1.setValue(factor.x, factor.y, factor.z);

	          this._body.setAngularFactor(ammoVec1);
	        }
	      }
	    }
	  }, {
	    key: "angularVelocity",
	    get: function get() {
	      if (this._body && this._type === BODYTYPE_DYNAMIC) {
	        var velocity = this._body.getAngularVelocity();

	        this._angularVelocity.set(velocity.x(), velocity.y(), velocity.z());
	      }

	      return this._angularVelocity;
	    },
	    set: function set(velocity) {
	      if (this._body && this._type === BODYTYPE_DYNAMIC) {
	        this._body.activate();

	        ammoVec1.setValue(velocity.x, velocity.y, velocity.z);

	        this._body.setAngularVelocity(ammoVec1);

	        this._angularVelocity.copy(velocity);
	      }
	    }
	  }, {
	    key: "body",
	    get: function get() {
	      return this._body;
	    },
	    set: function set(body) {
	      if (this._body !== body) {
	        this._body = body;

	        if (body && this._simulationEnabled) {
	          body.activate();
	        }
	      }
	    }
	  }, {
	    key: "friction",
	    get: function get() {
	      return this._friction;
	    },
	    set: function set(friction) {
	      if (this._friction !== friction) {
	        this._friction = friction;

	        if (this._body) {
	          this._body.setFriction(friction);
	        }
	      }
	    }
	  }, {
	    key: "group",
	    get: function get() {
	      return this._group;
	    },
	    set: function set(group) {
	      if (this._group !== group) {
	        this._group = group;

	        if (this.enabled && this.entity.enabled) {
	          this.disableSimulation();
	          this.enableSimulation();
	        }
	      }
	    }
	  }, {
	    key: "linearDamping",
	    get: function get() {
	      return this._linearDamping;
	    },
	    set: function set(damping) {
	      if (this._linearDamping !== damping) {
	        this._linearDamping = damping;

	        if (this._body) {
	          this._body.setDamping(damping, this._angularDamping);
	        }
	      }
	    }
	  }, {
	    key: "linearFactor",
	    get: function get() {
	      return this._linearFactor;
	    },
	    set: function set(factor) {
	      if (!this._linearFactor.equals(factor)) {
	        this._linearFactor.copy(factor);

	        if (this._body && this._type === BODYTYPE_DYNAMIC) {
	          ammoVec1.setValue(factor.x, factor.y, factor.z);

	          this._body.setLinearFactor(ammoVec1);
	        }
	      }
	    }
	  }, {
	    key: "linearVelocity",
	    get: function get() {
	      if (this._body && this._type === BODYTYPE_DYNAMIC) {
	        var velocity = this._body.getLinearVelocity();

	        this._linearVelocity.set(velocity.x(), velocity.y(), velocity.z());
	      }

	      return this._linearVelocity;
	    },
	    set: function set(velocity) {
	      if (this._body && this._type === BODYTYPE_DYNAMIC) {
	        this._body.activate();

	        ammoVec1.setValue(velocity.x, velocity.y, velocity.z);

	        this._body.setLinearVelocity(ammoVec1);

	        this._linearVelocity.copy(velocity);
	      }
	    }
	  }, {
	    key: "mask",
	    get: function get() {
	      return this._mask;
	    },
	    set: function set(mask) {
	      if (this._mask !== mask) {
	        this._mask = mask;

	        if (this.enabled && this.entity.enabled) {
	          this.disableSimulation();
	          this.enableSimulation();
	        }
	      }
	    }
	  }, {
	    key: "mass",
	    get: function get() {
	      return this._mass;
	    },
	    set: function set(mass) {
	      if (this._mass !== mass) {
	        this._mass = mass;

	        if (this._body && this._type === BODYTYPE_DYNAMIC) {
	          var enabled = this.enabled && this.entity.enabled;

	          if (enabled) {
	            this.disableSimulation();
	          }

	          this._body.getCollisionShape().calculateLocalInertia(mass, ammoVec1);

	          this._body.setMassProps(mass, ammoVec1);

	          this._body.updateInertiaTensor();

	          if (enabled) {
	            this.enableSimulation();
	          }
	        }
	      }
	    }
	  }, {
	    key: "restitution",
	    get: function get() {
	      return this._restitution;
	    },
	    set: function set(restitution) {
	      if (this._restitution !== restitution) {
	        this._restitution = restitution;

	        if (this._body) {
	          this._body.setRestitution(restitution);
	        }
	      }
	    }
	  }, {
	    key: "rollingFriction",
	    get: function get() {
	      return this._rollingFriction;
	    },
	    set: function set(friction) {
	      if (this._rollingFriction !== friction) {
	        this._rollingFriction = friction;

	        if (this._body) {
	          this._body.setRollingFriction(friction);
	        }
	      }
	    }
	  }, {
	    key: "type",
	    get: function get() {
	      return this._type;
	    },
	    set: function set(type) {
	      if (this._type !== type) {
	        this._type = type;
	        this.disableSimulation();

	        switch (type) {
	          case BODYTYPE_DYNAMIC:
	            this._group = BODYGROUP_DYNAMIC;
	            this._mask = BODYMASK_ALL;
	            break;

	          case BODYTYPE_KINEMATIC:
	            this._group = BODYGROUP_KINEMATIC;
	            this._mask = BODYMASK_ALL;
	            break;

	          case BODYTYPE_STATIC:
	          default:
	            this._group = BODYGROUP_STATIC;
	            this._mask = BODYMASK_NOT_STATIC;
	            break;
	        }

	        this.createBody();
	      }
	    }
	  }]);

	  return RigidBodyComponent;
	}(Component);

	var RigidBodyComponentData = function RigidBodyComponentData() {
	  this.enabled = true;
	};

	var ammoRayStart, ammoRayEnd;

	var RaycastResult = function RaycastResult(entity, point, normal) {
	  this.entity = entity;
	  this.point = point;
	  this.normal = normal;
	};

	var SingleContactResult = function SingleContactResult(a, b, contactPoint) {
	  if (arguments.length === 0) {
	    this.a = null;
	    this.b = null;
	    this.impulse = 0;
	    this.localPointA = new Vec3();
	    this.localPointB = new Vec3();
	    this.pointA = new Vec3();
	    this.pointB = new Vec3();
	    this.normal = new Vec3();
	  } else {
	    this.a = a;
	    this.b = b;
	    this.impulse = contactPoint.impulse;
	    this.localPointA = contactPoint.localPoint;
	    this.localPointB = contactPoint.localPointOther;
	    this.pointA = contactPoint.point;
	    this.pointB = contactPoint.pointOther;
	    this.normal = contactPoint.normal;
	  }
	};

	var ContactPoint = function ContactPoint(localPoint, localPointOther, point, pointOther, normal, impulse) {
	  if (localPoint === void 0) {
	    localPoint = new Vec3();
	  }

	  if (localPointOther === void 0) {
	    localPointOther = new Vec3();
	  }

	  if (point === void 0) {
	    point = new Vec3();
	  }

	  if (pointOther === void 0) {
	    pointOther = new Vec3();
	  }

	  if (normal === void 0) {
	    normal = new Vec3();
	  }

	  if (impulse === void 0) {
	    impulse = 0;
	  }

	  this.localPoint = localPoint;
	  this.localPointOther = localPointOther;
	  this.point = point;
	  this.pointOther = pointOther;
	  this.normal = normal;
	  this.impulse = impulse;
	};

	var ContactResult = function ContactResult(other, contacts) {
	  this.other = other;
	  this.contacts = contacts;
	};

	var _schema$8 = ['enabled'];

	var RigidBodyComponentSystem = function (_ComponentSystem) {
	  _inheritsLoose(RigidBodyComponentSystem, _ComponentSystem);

	  function RigidBodyComponentSystem(app) {
	    var _this;

	    _this = _ComponentSystem.call(this, app) || this;
	    _this.maxSubSteps = 10;
	    _this.fixedTimeStep = 1 / 60;
	    _this.gravity = new Vec3(0, -9.81, 0);
	    _this._dynamic = [];
	    _this._kinematic = [];
	    _this._triggers = [];
	    _this._compounds = [];
	    _this.id = 'rigidbody';
	    _this._stats = app.stats.frame;
	    _this.ComponentType = RigidBodyComponent;
	    _this.DataType = RigidBodyComponentData;
	    _this.contactPointPool = null;
	    _this.contactResultPool = null;
	    _this.singleContactResultPool = null;
	    _this.schema = _schema$8;
	    _this.collisions = {};
	    _this.frameCollisions = {};

	    _this.on('beforeremove', _this.onBeforeRemove, _assertThisInitialized(_this));

	    _this.on('remove', _this.onRemove, _assertThisInitialized(_this));

	    return _this;
	  }

	  var _proto = RigidBodyComponentSystem.prototype;

	  _proto.onLibraryLoaded = function onLibraryLoaded() {
	    if (typeof Ammo !== 'undefined') {
	      this.collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
	      this.dispatcher = new Ammo.btCollisionDispatcher(this.collisionConfiguration);
	      this.overlappingPairCache = new Ammo.btDbvtBroadphase();
	      this.solver = new Ammo.btSequentialImpulseConstraintSolver();
	      this.dynamicsWorld = new Ammo.btDiscreteDynamicsWorld(this.dispatcher, this.overlappingPairCache, this.solver, this.collisionConfiguration);

	      if (this.dynamicsWorld.setInternalTickCallback) {
	        var checkForCollisionsPointer = Ammo.addFunction(this._checkForCollisions.bind(this), 'vif');
	        this.dynamicsWorld.setInternalTickCallback(checkForCollisionsPointer);
	      }

	      ammoRayStart = new Ammo.btVector3();
	      ammoRayEnd = new Ammo.btVector3();
	      RigidBodyComponent.onLibraryLoaded();
	      this.contactPointPool = new ObjectPool(ContactPoint, 1);
	      this.contactResultPool = new ObjectPool(ContactResult, 1);
	      this.singleContactResultPool = new ObjectPool(SingleContactResult, 1);
	      this.app.systems.on('update', this.onUpdate, this);
	    } else {
	      this.app.systems.off('update', this.onUpdate, this);
	    }
	  };

	  _proto.initializeComponentData = function initializeComponentData(component, data, properties) {
	    var props = ['mass', 'linearDamping', 'angularDamping', 'linearFactor', 'angularFactor', 'friction', 'rollingFriction', 'restitution', 'type', 'group', 'mask'];

	    for (var _i = 0, _props = props; _i < _props.length; _i++) {
	      var property = _props[_i];

	      if (data.hasOwnProperty(property)) {
	        var value = data[property];

	        if (Array.isArray(value)) {
	          component[property] = new Vec3(value[0], value[1], value[2]);
	        } else {
	          component[property] = value;
	        }
	      }
	    }

	    _ComponentSystem.prototype.initializeComponentData.call(this, component, data, ['enabled']);
	  };

	  _proto.cloneComponent = function cloneComponent(entity, clone) {
	    var rigidbody = entity.rigidbody;
	    var data = {
	      enabled: rigidbody.enabled,
	      mass: rigidbody.mass,
	      linearDamping: rigidbody.linearDamping,
	      angularDamping: rigidbody.angularDamping,
	      linearFactor: [rigidbody.linearFactor.x, rigidbody.linearFactor.y, rigidbody.linearFactor.z],
	      angularFactor: [rigidbody.angularFactor.x, rigidbody.angularFactor.y, rigidbody.angularFactor.z],
	      friction: rigidbody.friction,
	      rollingFriction: rigidbody.rollingFriction,
	      restitution: rigidbody.restitution,
	      type: rigidbody.type,
	      group: rigidbody.group,
	      mask: rigidbody.mask
	    };
	    return this.addComponent(clone, data);
	  };

	  _proto.onBeforeRemove = function onBeforeRemove(entity, component) {
	    if (component.enabled) {
	      component.enabled = false;
	    }
	  };

	  _proto.onRemove = function onRemove(entity, component) {
	    var body = component.body;

	    if (body) {
	      this.removeBody(body);
	      this.destroyBody(body);
	      component.body = null;
	    }
	  };

	  _proto.addBody = function addBody(body, group, mask) {
	    if (group !== undefined && mask !== undefined) {
	      this.dynamicsWorld.addRigidBody(body, group, mask);
	    } else {
	      this.dynamicsWorld.addRigidBody(body);
	    }
	  };

	  _proto.removeBody = function removeBody(body) {
	    this.dynamicsWorld.removeRigidBody(body);
	  };

	  _proto.createBody = function createBody(mass, shape, transform) {
	    var localInertia = new Ammo.btVector3(0, 0, 0);

	    if (mass !== 0) {
	      shape.calculateLocalInertia(mass, localInertia);
	    }

	    var motionState = new Ammo.btDefaultMotionState(transform);
	    var bodyInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);
	    var body = new Ammo.btRigidBody(bodyInfo);
	    Ammo.destroy(bodyInfo);
	    Ammo.destroy(localInertia);
	    return body;
	  };

	  _proto.destroyBody = function destroyBody(body) {
	    var motionState = body.getMotionState();

	    if (motionState) {
	      Ammo.destroy(motionState);
	    }

	    Ammo.destroy(body);
	  };

	  _proto.raycastFirst = function raycastFirst(start, end) {
	    var result = null;
	    ammoRayStart.setValue(start.x, start.y, start.z);
	    ammoRayEnd.setValue(end.x, end.y, end.z);
	    var rayCallback = new Ammo.ClosestRayResultCallback(ammoRayStart, ammoRayEnd);
	    this.dynamicsWorld.rayTest(ammoRayStart, ammoRayEnd, rayCallback);

	    if (rayCallback.hasHit()) {
	      var collisionObj = rayCallback.get_m_collisionObject();
	      var body = Ammo.castObject(collisionObj, Ammo.btRigidBody);

	      if (body) {
	        var point = rayCallback.get_m_hitPointWorld();
	        var normal = rayCallback.get_m_hitNormalWorld();
	        result = new RaycastResult(body.entity, new Vec3(point.x(), point.y(), point.z()), new Vec3(normal.x(), normal.y(), normal.z()));

	        if (arguments.length > 2) {
	          var callback = arguments[2];
	          callback(result);
	        }
	      }
	    }

	    Ammo.destroy(rayCallback);
	    return result;
	  };

	  _proto.raycastAll = function raycastAll(start, end) {
	    var results = [];
	    ammoRayStart.setValue(start.x, start.y, start.z);
	    ammoRayEnd.setValue(end.x, end.y, end.z);
	    var rayCallback = new Ammo.AllHitsRayResultCallback(ammoRayStart, ammoRayEnd);
	    this.dynamicsWorld.rayTest(ammoRayStart, ammoRayEnd, rayCallback);

	    if (rayCallback.hasHit()) {
	      var collisionObjs = rayCallback.get_m_collisionObjects();
	      var points = rayCallback.get_m_hitPointWorld();
	      var normals = rayCallback.get_m_hitNormalWorld();
	      var numHits = collisionObjs.size();

	      for (var i = 0; i < numHits; i++) {
	        var body = Ammo.castObject(collisionObjs.at(i), Ammo.btRigidBody);

	        if (body) {
	          var point = points.at(i);
	          var normal = normals.at(i);
	          var result = new RaycastResult(body.entity, new Vec3(point.x(), point.y(), point.z()), new Vec3(normal.x(), normal.y(), normal.z()));
	          results.push(result);
	        }
	      }
	    }

	    Ammo.destroy(rayCallback);
	    return results;
	  };

	  _proto._storeCollision = function _storeCollision(entity, other) {
	    var isNewCollision = false;
	    var guid = entity.getGuid();
	    this.collisions[guid] = this.collisions[guid] || {
	      others: [],
	      entity: entity
	    };

	    if (this.collisions[guid].others.indexOf(other) < 0) {
	      this.collisions[guid].others.push(other);
	      isNewCollision = true;
	    }

	    this.frameCollisions[guid] = this.frameCollisions[guid] || {
	      others: [],
	      entity: entity
	    };
	    this.frameCollisions[guid].others.push(other);
	    return isNewCollision;
	  };

	  _proto._createContactPointFromAmmo = function _createContactPointFromAmmo(contactPoint) {
	    var localPointA = contactPoint.get_m_localPointA();
	    var localPointB = contactPoint.get_m_localPointB();
	    var positionWorldOnA = contactPoint.getPositionWorldOnA();
	    var positionWorldOnB = contactPoint.getPositionWorldOnB();
	    var normalWorldOnB = contactPoint.get_m_normalWorldOnB();
	    var contact = this.contactPointPool.allocate();
	    contact.localPoint.set(localPointA.x(), localPointA.y(), localPointA.z());
	    contact.localPointOther.set(localPointB.x(), localPointB.y(), localPointB.z());
	    contact.point.set(positionWorldOnA.x(), positionWorldOnA.y(), positionWorldOnA.z());
	    contact.pointOther.set(positionWorldOnB.x(), positionWorldOnB.y(), positionWorldOnB.z());
	    contact.normal.set(normalWorldOnB.x(), normalWorldOnB.y(), normalWorldOnB.z());
	    contact.impulse = contactPoint.getAppliedImpulse();
	    return contact;
	  };

	  _proto._createReverseContactPointFromAmmo = function _createReverseContactPointFromAmmo(contactPoint) {
	    var localPointA = contactPoint.get_m_localPointA();
	    var localPointB = contactPoint.get_m_localPointB();
	    var positionWorldOnA = contactPoint.getPositionWorldOnA();
	    var positionWorldOnB = contactPoint.getPositionWorldOnB();
	    var normalWorldOnB = contactPoint.get_m_normalWorldOnB();
	    var contact = this.contactPointPool.allocate();
	    contact.localPointOther.set(localPointA.x(), localPointA.y(), localPointA.z());
	    contact.localPoint.set(localPointB.x(), localPointB.y(), localPointB.z());
	    contact.pointOther.set(positionWorldOnA.x(), positionWorldOnA.y(), positionWorldOnA.z());
	    contact.point.set(positionWorldOnB.x(), positionWorldOnB.y(), positionWorldOnB.z());
	    contact.normal.set(normalWorldOnB.x(), normalWorldOnB.y(), normalWorldOnB.z());
	    contact.impulse = contactPoint.getAppliedImpulse();
	    return contact;
	  };

	  _proto._createSingleContactResult = function _createSingleContactResult(a, b, contactPoint) {
	    var result = this.singleContactResultPool.allocate();
	    result.a = a;
	    result.b = b;
	    result.localPointA = contactPoint.localPoint;
	    result.localPointB = contactPoint.localPointOther;
	    result.pointA = contactPoint.point;
	    result.pointB = contactPoint.pointOther;
	    result.normal = contactPoint.normal;
	    result.impulse = contactPoint.impulse;
	    return result;
	  };

	  _proto._createContactResult = function _createContactResult(other, contacts) {
	    var result = this.contactResultPool.allocate();
	    result.other = other;
	    result.contacts = contacts;
	    return result;
	  };

	  _proto._cleanOldCollisions = function _cleanOldCollisions() {
	    for (var guid in this.collisions) {
	      if (this.collisions.hasOwnProperty(guid)) {
	        var frameCollision = this.frameCollisions[guid];
	        var collision = this.collisions[guid];
	        var entity = collision.entity;
	        var entityCollision = entity.collision;
	        var entityRigidbody = entity.rigidbody;
	        var others = collision.others;
	        var length = others.length;
	        var i = length;

	        while (i--) {
	          var other = others[i];

	          if (!frameCollision || frameCollision.others.indexOf(other) < 0) {
	            others.splice(i, 1);

	            if (entity.trigger) {
	              if (entityCollision) {
	                entityCollision.fire('triggerleave', other);
	              }

	              if (other.rigidbody) {
	                other.rigidbody.fire('triggerleave', entity);
	              }
	            } else if (!other.trigger) {
	              if (entityRigidbody) {
	                entityRigidbody.fire('collisionend', other);
	              }

	              if (entityCollision) {
	                entityCollision.fire('collisionend', other);
	              }
	            }
	          }
	        }

	        if (others.length === 0) {
	          delete this.collisions[guid];
	        }
	      }
	    }
	  };

	  _proto._hasContactEvent = function _hasContactEvent(entity) {
	    var c = entity.collision;

	    if (c && (c.hasEvent('collisionstart') || c.hasEvent('collisionend') || c.hasEvent('contact'))) {
	      return true;
	    }

	    var r = entity.rigidbody;
	    return r && (r.hasEvent('collisionstart') || r.hasEvent('collisionend') || r.hasEvent('contact'));
	  };

	  _proto._checkForCollisions = function _checkForCollisions(world, timeStep) {
	    var dynamicsWorld = Ammo.wrapPointer(world, Ammo.btDynamicsWorld);
	    var dispatcher = dynamicsWorld.getDispatcher();
	    var numManifolds = dispatcher.getNumManifolds();
	    this.frameCollisions = {};

	    for (var i = 0; i < numManifolds; i++) {
	      var manifold = dispatcher.getManifoldByIndexInternal(i);
	      var body0 = manifold.getBody0();
	      var body1 = manifold.getBody1();
	      var wb0 = Ammo.castObject(body0, Ammo.btRigidBody);
	      var wb1 = Ammo.castObject(body1, Ammo.btRigidBody);
	      var e0 = wb0.entity;
	      var e1 = wb1.entity;

	      if (!e0 || !e1) {
	        continue;
	      }

	      var flags0 = wb0.getCollisionFlags();
	      var flags1 = wb1.getCollisionFlags();
	      var numContacts = manifold.getNumContacts();
	      var forwardContacts = [];
	      var reverseContacts = [];
	      var newCollision = void 0;

	      if (numContacts > 0) {
	        if (flags0 & BODYFLAG_NORESPONSE_OBJECT || flags1 & BODYFLAG_NORESPONSE_OBJECT) {
	          var e0Events = e0.collision && (e0.collision.hasEvent('triggerenter') || e0.collision.hasEvent('triggerleave'));
	          var e1Events = e1.collision && (e1.collision.hasEvent('triggerenter') || e1.collision.hasEvent('triggerleave'));
	          var e0BodyEvents = e0.rigidbody && (e0.rigidbody.hasEvent('triggerenter') || e0.rigidbody.hasEvent('triggerleave'));
	          var e1BodyEvents = e1.rigidbody && (e1.rigidbody.hasEvent('triggerenter') || e1.rigidbody.hasEvent('triggerleave'));

	          if (e0Events) {
	            newCollision = this._storeCollision(e0, e1);

	            if (newCollision && !(flags1 & BODYFLAG_NORESPONSE_OBJECT)) {
	              e0.collision.fire('triggerenter', e1);
	            }
	          }

	          if (e1Events) {
	            newCollision = this._storeCollision(e1, e0);

	            if (newCollision && !(flags0 & BODYFLAG_NORESPONSE_OBJECT)) {
	              e1.collision.fire('triggerenter', e0);
	            }
	          }

	          if (e0BodyEvents) {
	            if (!newCollision) {
	              newCollision = this._storeCollision(e1, e0);
	            }

	            if (newCollision) {
	              e0.rigidbody.fire('triggerenter', e1);
	            }
	          }

	          if (e1BodyEvents) {
	            if (!newCollision) {
	              newCollision = this._storeCollision(e0, e1);
	            }

	            if (newCollision) {
	              e1.rigidbody.fire('triggerenter', e0);
	            }
	          }
	        } else {
	          var _e0Events = this._hasContactEvent(e0);

	          var _e1Events = this._hasContactEvent(e1);

	          var globalEvents = this.hasEvent('contact');

	          if (globalEvents || _e0Events || _e1Events) {
	            for (var j = 0; j < numContacts; j++) {
	              var btContactPoint = manifold.getContactPoint(j);

	              var contactPoint = this._createContactPointFromAmmo(btContactPoint);

	              if (_e0Events || _e1Events) {
	                forwardContacts.push(contactPoint);

	                var reverseContactPoint = this._createReverseContactPointFromAmmo(btContactPoint);

	                reverseContacts.push(reverseContactPoint);
	              }

	              if (globalEvents) {
	                var result = this._createSingleContactResult(e0, e1, contactPoint);

	                this.fire('contact', result);
	              }
	            }

	            if (_e0Events) {
	              var forwardResult = this._createContactResult(e1, forwardContacts);

	              newCollision = this._storeCollision(e0, e1);

	              if (e0.collision) {
	                e0.collision.fire('contact', forwardResult);

	                if (newCollision) {
	                  e0.collision.fire('collisionstart', forwardResult);
	                }
	              }

	              if (e0.rigidbody) {
	                e0.rigidbody.fire('contact', forwardResult);

	                if (newCollision) {
	                  e0.rigidbody.fire('collisionstart', forwardResult);
	                }
	              }
	            }

	            if (_e1Events) {
	              var reverseResult = this._createContactResult(e0, reverseContacts);

	              newCollision = this._storeCollision(e1, e0);

	              if (e1.collision) {
	                e1.collision.fire('contact', reverseResult);

	                if (newCollision) {
	                  e1.collision.fire('collisionstart', reverseResult);
	                }
	              }

	              if (e1.rigidbody) {
	                e1.rigidbody.fire('contact', reverseResult);

	                if (newCollision) {
	                  e1.rigidbody.fire('collisionstart', reverseResult);
	                }
	              }
	            }
	          }
	        }
	      }
	    }

	    this._cleanOldCollisions();

	    this.contactPointPool.freeAll();
	    this.contactResultPool.freeAll();
	    this.singleContactResultPool.freeAll();
	  };

	  _proto.onUpdate = function onUpdate(dt) {
	    var i, len;
	    var gravity = this.dynamicsWorld.getGravity();

	    if (gravity.x() !== this.gravity.x || gravity.y() !== this.gravity.y || gravity.z() !== this.gravity.z) {
	      gravity.setValue(this.gravity.x, this.gravity.y, this.gravity.z);
	      this.dynamicsWorld.setGravity(gravity);
	    }

	    var triggers = this._triggers;

	    for (i = 0, len = triggers.length; i < len; i++) {
	      triggers[i].updateTransform();
	    }

	    var compounds = this._compounds;

	    for (i = 0, len = compounds.length; i < len; i++) {
	      compounds[i]._updateCompound();
	    }

	    var kinematic = this._kinematic;

	    for (i = 0, len = kinematic.length; i < len; i++) {
	      kinematic[i]._updateKinematic();
	    }

	    this.dynamicsWorld.stepSimulation(dt, this.maxSubSteps, this.fixedTimeStep);
	    var dynamic = this._dynamic;

	    for (i = 0, len = dynamic.length; i < len; i++) {
	      dynamic[i]._updateDynamic();
	    }

	    if (!this.dynamicsWorld.setInternalTickCallback) this._checkForCollisions(Ammo.getPointer(this.dynamicsWorld), dt);
	  };

	  _proto.destroy = function destroy() {
	    _ComponentSystem.prototype.destroy.call(this);

	    this.app.systems.off('update', this.onUpdate, this);

	    if (typeof Ammo !== 'undefined') {
	      Ammo.destroy(this.dynamicsWorld);
	      Ammo.destroy(this.solver);
	      Ammo.destroy(this.overlappingPairCache);
	      Ammo.destroy(this.dispatcher);
	      Ammo.destroy(this.collisionConfiguration);
	      this.dynamicsWorld = null;
	      this.solver = null;
	      this.overlappingPairCache = null;
	      this.dispatcher = null;
	      this.collisionConfiguration = null;
	    }
	  };

	  return RigidBodyComponentSystem;
	}(ComponentSystem);

	Component._buildAccessors(RigidBodyComponent.prototype, _schema$8);

	var SCALEMODE_NONE = 'none';
	var SCALEMODE_BLEND = 'blend';

	var _transform = new Mat4();

	var ScreenComponent = function (_Component) {
	  _inheritsLoose(ScreenComponent, _Component);

	  function ScreenComponent(system, entity) {
	    var _this;

	    _this = _Component.call(this, system, entity) || this;
	    _this._resolution = new Vec2(640, 320);
	    _this._referenceResolution = new Vec2(640, 320);
	    _this._scaleMode = SCALEMODE_NONE;
	    _this.scale = 1;
	    _this._scaleBlend = 0.5;
	    _this._priority = 0;
	    _this._screenSpace = false;
	    _this.cull = _this._screenSpace;
	    _this._screenMatrix = new Mat4();
	    _this._elements = new Set();
	    system.app.graphicsDevice.on('resizecanvas', _this._onResize, _assertThisInitialized(_this));
	    return _this;
	  }

	  var _proto = ScreenComponent.prototype;

	  _proto.syncDrawOrder = function syncDrawOrder() {
	    this.system.queueDrawOrderSync(this.entity.getGuid(), this._processDrawOrderSync, this);
	  };

	  _proto._recurseDrawOrderSync = function _recurseDrawOrderSync(e, i) {
	    if (!(e instanceof Entity)) {
	      return i;
	    }

	    if (e.element) {
	      var prevDrawOrder = e.element.drawOrder;
	      e.element.drawOrder = i++;

	      if (e.element._batchGroupId >= 0 && prevDrawOrder !== e.element.drawOrder) {
	        var _this$system$app$batc;

	        (_this$system$app$batc = this.system.app.batcher) == null ? void 0 : _this$system$app$batc.markGroupDirty(e.element._batchGroupId);
	      }
	    }

	    if (e.particlesystem) {
	      e.particlesystem.drawOrder = i++;
	    }

	    var children = e.children;

	    for (var j = 0; j < children.length; j++) {
	      i = this._recurseDrawOrderSync(children[j], i);
	    }

	    return i;
	  };

	  _proto._processDrawOrderSync = function _processDrawOrderSync() {
	    var i = 1;

	    this._recurseDrawOrderSync(this.entity, i);

	    this.fire('syncdraworder');
	  };

	  _proto._calcProjectionMatrix = function _calcProjectionMatrix() {
	    var w = this._resolution.x / this.scale;
	    var h = this._resolution.y / this.scale;
	    var left = 0;
	    var right = w;
	    var bottom = -h;
	    var top = 0;
	    var near = 1;
	    var far = -1;

	    this._screenMatrix.setOrtho(left, right, bottom, top, near, far);

	    if (!this._screenSpace) {
	      _transform.setScale(0.5 * w, 0.5 * h, 1);

	      this._screenMatrix.mul2(_transform, this._screenMatrix);
	    }
	  };

	  _proto._updateScale = function _updateScale() {
	    this.scale = this._calcScale(this._resolution, this.referenceResolution);
	  };

	  _proto._calcScale = function _calcScale(resolution, referenceResolution) {
	    var lx = Math.log2(resolution.x / referenceResolution.x);
	    var ly = Math.log2(resolution.y / referenceResolution.y);
	    return Math.pow(2, lx * (1 - this._scaleBlend) + ly * this._scaleBlend);
	  };

	  _proto._onResize = function _onResize(width, height) {
	    if (this._screenSpace) {
	      this._resolution.set(width, height);

	      this.resolution = this._resolution;
	    }
	  };

	  _proto._bindElement = function _bindElement(element) {
	    this._elements.add(element);
	  };

	  _proto._unbindElement = function _unbindElement(element) {
	    this._elements.delete(element);
	  };

	  _proto.onRemove = function onRemove() {
	    this.system.app.graphicsDevice.off('resizecanvas', this._onResize, this);
	    this.fire('remove');

	    this._elements.forEach(function (element) {
	      return element._onScreenRemove();
	    });

	    this._elements.clear();

	    this.off();
	  };

	  _createClass(ScreenComponent, [{
	    key: "resolution",
	    get: function get() {
	      return this._resolution;
	    },
	    set: function set(value) {
	      var _this2 = this;

	      if (!this._screenSpace) {
	        this._resolution.set(value.x, value.y);
	      } else {
	        this._resolution.set(this.system.app.graphicsDevice.width, this.system.app.graphicsDevice.height);
	      }

	      this._updateScale();

	      this._calcProjectionMatrix();

	      if (!this.entity._dirtyLocal) this.entity._dirtifyLocal();
	      this.fire('set:resolution', this._resolution);

	      this._elements.forEach(function (element) {
	        return element._onScreenResize(_this2._resolution);
	      });
	    }
	  }, {
	    key: "referenceResolution",
	    get: function get() {
	      if (this._scaleMode === SCALEMODE_NONE) {
	        return this._resolution;
	      }

	      return this._referenceResolution;
	    },
	    set: function set(value) {
	      var _this3 = this;

	      this._referenceResolution.set(value.x, value.y);

	      this._updateScale();

	      this._calcProjectionMatrix();

	      if (!this.entity._dirtyLocal) this.entity._dirtifyLocal();
	      this.fire('set:referenceresolution', this._resolution);

	      this._elements.forEach(function (element) {
	        return element._onScreenResize(_this3._resolution);
	      });
	    }
	  }, {
	    key: "screenSpace",
	    get: function get() {
	      return this._screenSpace;
	    },
	    set: function set(value) {
	      this._screenSpace = value;

	      if (this._screenSpace) {
	        this._resolution.set(this.system.app.graphicsDevice.width, this.system.app.graphicsDevice.height);
	      }

	      this.resolution = this._resolution;
	      if (!this.entity._dirtyLocal) this.entity._dirtifyLocal();
	      this.fire('set:screenspace', this._screenSpace);

	      this._elements.forEach(function (element) {
	        return element._onScreenSpaceChange();
	      });
	    }
	  }, {
	    key: "scaleMode",
	    get: function get() {
	      return this._scaleMode;
	    },
	    set: function set(value) {
	      if (value !== SCALEMODE_NONE && value !== SCALEMODE_BLEND) {
	        value = SCALEMODE_NONE;
	      }

	      if (!this._screenSpace && value !== SCALEMODE_NONE) {
	        value = SCALEMODE_NONE;
	      }

	      this._scaleMode = value;
	      this.resolution = this._resolution;
	      this.fire('set:scalemode', this._scaleMode);
	    }
	  }, {
	    key: "scaleBlend",
	    get: function get() {
	      return this._scaleBlend;
	    },
	    set: function set(value) {
	      var _this4 = this;

	      this._scaleBlend = value;

	      this._updateScale();

	      this._calcProjectionMatrix();

	      if (!this.entity._dirtyLocal) this.entity._dirtifyLocal();
	      this.fire('set:scaleblend', this._scaleBlend);

	      this._elements.forEach(function (element) {
	        return element._onScreenResize(_this4._resolution);
	      });
	    }
	  }, {
	    key: "priority",
	    get: function get() {
	      return this._priority;
	    },
	    set: function set(value) {
	      if (value > 0xFF) {
	        value = 0xFF;
	      }

	      if (this._priority === value) {
	        return;
	      }

	      this._priority = value;
	      this.syncDrawOrder();
	    }
	  }]);

	  return ScreenComponent;
	}(Component);

	var ScreenComponentData = function ScreenComponentData() {
	  this.enabled = true;
	};

	var _schema$7 = ['enabled'];

	var ScreenComponentSystem = function (_ComponentSystem) {
	  _inheritsLoose(ScreenComponentSystem, _ComponentSystem);

	  function ScreenComponentSystem(app) {
	    var _this;

	    _this = _ComponentSystem.call(this, app) || this;
	    _this.id = 'screen';
	    _this.ComponentType = ScreenComponent;
	    _this.DataType = ScreenComponentData;
	    _this.schema = _schema$7;
	    _this.windowResolution = new Vec2();
	    _this._drawOrderSyncQueue = new IndexedList();

	    _this.app.graphicsDevice.on('resizecanvas', _this._onResize, _assertThisInitialized(_this));

	    _this.app.systems.on('update', _this._onUpdate, _assertThisInitialized(_this));

	    _this.on('beforeremove', _this.onRemoveComponent, _assertThisInitialized(_this));

	    return _this;
	  }

	  var _proto = ScreenComponentSystem.prototype;

	  _proto.initializeComponentData = function initializeComponentData(component, data, properties) {
	    if (data.priority !== undefined) component.priority = data.priority;
	    if (data.screenSpace !== undefined) component.screenSpace = data.screenSpace;
	    component.cull = component.screenSpace;
	    if (data.scaleMode !== undefined) component.scaleMode = data.scaleMode;
	    if (data.scaleBlend !== undefined) component.scaleBlend = data.scaleBlend;

	    if (data.resolution !== undefined) {
	      if (data.resolution instanceof Vec2) {
	        component._resolution.copy(data.resolution);
	      } else {
	        component._resolution.set(data.resolution[0], data.resolution[1]);
	      }

	      component.resolution = component._resolution;
	    }

	    if (data.referenceResolution !== undefined) {
	      if (data.referenceResolution instanceof Vec2) {
	        component._referenceResolution.copy(data.referenceResolution);
	      } else {
	        component._referenceResolution.set(data.referenceResolution[0], data.referenceResolution[1]);
	      }

	      component.referenceResolution = component._referenceResolution;
	    }

	    component.syncDrawOrder();

	    _ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
	  };

	  _proto.destroy = function destroy() {
	    _ComponentSystem.prototype.destroy.call(this);

	    this.app.graphicsDevice.off('resizecanvas', this._onResize, this);
	    this.app.systems.off('update', this._onUpdate, this);
	  };

	  _proto._onUpdate = function _onUpdate(dt) {
	    var components = this.store;

	    for (var id in components) {
	      if (components[id].entity.screen.update) components[id].entity.screen.update(dt);
	    }
	  };

	  _proto._onResize = function _onResize(width, height) {
	    this.windowResolution.x = width;
	    this.windowResolution.y = height;
	  };

	  _proto.cloneComponent = function cloneComponent(entity, clone) {
	    var screen = entity.screen;
	    return this.addComponent(clone, {
	      enabled: screen.enabled,
	      screenSpace: screen.screenSpace,
	      scaleMode: screen.scaleMode,
	      resolution: screen.resolution.clone(),
	      referenceResolution: screen.referenceResolution.clone()
	    });
	  };

	  _proto.onRemoveComponent = function onRemoveComponent(entity, component) {
	    component.onRemove();
	  };

	  _proto.processDrawOrderSyncQueue = function processDrawOrderSyncQueue() {
	    var list = this._drawOrderSyncQueue.list();

	    for (var i = 0; i < list.length; i++) {
	      var item = list[i];
	      item.callback.call(item.scope);
	    }

	    this._drawOrderSyncQueue.clear();
	  };

	  _proto.queueDrawOrderSync = function queueDrawOrderSync(id, fn, scope) {
	    if (!this._drawOrderSyncQueue.list().length) {
	      this.app.once('prerender', this.processDrawOrderSyncQueue, this);
	    }

	    if (!this._drawOrderSyncQueue.has(id)) {
	      this._drawOrderSyncQueue.push(id, {
	        callback: fn,
	        scope: scope
	      });
	    }
	  };

	  return ScreenComponentSystem;
	}(ComponentSystem);

	Component._buildAccessors(ScreenComponent.prototype, _schema$7);

	var ScriptLegacyComponent = function (_Component) {
	  _inheritsLoose(ScriptLegacyComponent, _Component);

	  function ScriptLegacyComponent(system, entity) {
	    var _this;

	    _this = _Component.call(this, system, entity) || this;

	    _this.on('set_scripts', _this.onSetScripts, _assertThisInitialized(_this));

	    return _this;
	  }

	  var _proto = ScriptLegacyComponent.prototype;

	  _proto.send = function send(name, functionName) {
	    var args = Array.prototype.slice.call(arguments, 2);
	    var instances = this.entity.script.instances;
	    var fn;

	    if (instances && instances[name]) {
	      fn = instances[name].instance[functionName];

	      if (fn) {
	        return fn.apply(instances[name].instance, args);
	      }
	    }

	    return undefined;
	  };

	  _proto.onEnable = function onEnable() {
	    if (this.data.areScriptsLoaded && !this.system.preloading) {
	      if (!this.data.initialized) {
	        this.system._initializeScriptComponent(this);
	      } else {
	        this.system._enableScriptComponent(this);
	      }

	      if (!this.data.postInitialized) {
	        this.system._postInitializeScriptComponent(this);
	      }
	    }
	  };

	  _proto.onDisable = function onDisable() {
	    this.system._disableScriptComponent(this);
	  };

	  _proto.onSetScripts = function onSetScripts(name, oldValue, newValue) {
	    if (!this.system._inTools || this.runInTools) {
	      if (this._updateScriptAttributes(oldValue, newValue)) {
	        return;
	      }

	      if (this.enabled) {
	        this.system._disableScriptComponent(this);
	      }

	      this.system._destroyScriptComponent(this);

	      this.data.areScriptsLoaded = false;
	      var scripts = newValue;
	      var urls = scripts.map(function (s) {
	        return s.url;
	      });

	      if (this._loadFromCache(urls)) {
	        return;
	      }

	      this._loadScripts(urls);
	    }
	  };

	  _proto._updateScriptAttributes = function _updateScriptAttributes(oldValue, newValue) {
	    var onlyUpdateAttributes = true;

	    if (oldValue.length !== newValue.length) {
	      onlyUpdateAttributes = false;
	    } else {
	      for (var i = 0, len = newValue.length; i < len; i++) {
	        if (oldValue[i].url !== newValue[i].url) {
	          onlyUpdateAttributes = false;
	          break;
	        }
	      }
	    }

	    if (onlyUpdateAttributes) {
	      for (var key in this.instances) {
	        if (this.instances.hasOwnProperty(key)) {
	          this.system._updateAccessors(this.entity, this.instances[key]);
	        }
	      }
	    }

	    return onlyUpdateAttributes;
	  };

	  _proto._loadFromCache = function _loadFromCache(urls) {
	    var cached = [];
	    var prefix = this.system.app._scriptPrefix || '';
	    var regex = /^http(s)?:\/\//i;

	    for (var i = 0, len = urls.length; i < len; i++) {
	      var url = urls[i];

	      if (!regex.test(url)) {
	        url = path.join(prefix, url);
	      }

	      var type = this.system.app.loader.getFromCache(url, 'script');

	      if (!type) {
	        return false;
	      }

	      cached.push(type);
	    }

	    for (var _i = 0, _len = cached.length; _i < _len; _i++) {
	      var ScriptType = cached[_i];

	      if (ScriptType === true) {
	        continue;
	      }

	      if (ScriptType && this.entity.script) {
	        if (!this.entity.script.instances[ScriptType._pcScriptName]) {
	          var instance = new ScriptType(this.entity);

	          this.system._preRegisterInstance(this.entity, urls[_i], ScriptType._pcScriptName, instance);
	        }
	      }
	    }

	    if (this.data) {
	      this.data.areScriptsLoaded = true;
	    }

	    if (!this.system.preloading) {
	      this.system.onInitialize(this.entity);
	      this.system.onPostInitialize(this.entity);
	    }

	    return true;
	  };

	  _proto._loadScripts = function _loadScripts(urls) {
	    var _this2 = this;

	    var count = urls.length;
	    var prefix = this.system.app._scriptPrefix || '';
	    urls.forEach(function (url) {
	      var _url = null;
	      var _unprefixed = null;

	      if (url.toLowerCase().startsWith('http://') || url.toLowerCase().startsWith('https://')) {
	        _unprefixed = url;
	        _url = url;
	      } else {
	        _unprefixed = url;
	        _url = path.join(prefix, url);
	      }

	      _this2.system.app.loader.load(_url, 'script', function (err, ScriptType) {
	        count--;

	        if (!err) {
	          if (ScriptType && _this2.entity.script) {
	            if (!_this2.entity.script.instances[ScriptType._pcScriptName]) {
	              var instance = new ScriptType(_this2.entity);

	              _this2.system._preRegisterInstance(_this2.entity, _unprefixed, ScriptType._pcScriptName, instance);
	            }
	          }
	        } else {
	          console.error(err);
	        }

	        if (count === 0) {
	          _this2.data.areScriptsLoaded = true;

	          if (!_this2.system.preloading) {
	            _this2.system.onInitialize(_this2.entity);

	            _this2.system.onPostInitialize(_this2.entity);
	          }
	        }
	      });
	    });
	  };

	  return ScriptLegacyComponent;
	}(Component);

	var ScriptLegacyComponentData = function ScriptLegacyComponentData() {
	  this.scripts = [];
	  this.enabled = true;
	  this.instances = {};
	  this._instances = {};
	  this.runInTools = false;
	  this.attributes = {};
	  this.initialized = false;
	  this.postInitialized = false;
	  this.areScriptsLoaded = false;
	};

	var _schema$6 = ['enabled', 'scripts', 'instances', 'runInTools'];
	var INITIALIZE = 'initialize';
	var POST_INITIALIZE = 'postInitialize';
	var UPDATE = 'update';
	var POST_UPDATE = 'postUpdate';
	var FIXED_UPDATE = 'fixedUpdate';
	var TOOLS_UPDATE = 'toolsUpdate';
	var ON_ENABLE = 'onEnable';
	var ON_DISABLE = 'onDisable';

	var ScriptLegacyComponentSystem = function (_ComponentSystem) {
	  _inheritsLoose(ScriptLegacyComponentSystem, _ComponentSystem);

	  function ScriptLegacyComponentSystem(app) {
	    var _this;

	    _this = _ComponentSystem.call(this, app) || this;
	    _this.id = 'script';
	    _this.ComponentType = ScriptLegacyComponent;
	    _this.DataType = ScriptLegacyComponentData;
	    _this.schema = _schema$6;
	    _this.preloading = false;
	    _this.instancesWithUpdate = [];
	    _this.instancesWithFixedUpdate = [];
	    _this.instancesWithPostUpdate = [];
	    _this.instancesWithToolsUpdate = [];

	    _this.on('beforeremove', _this.onBeforeRemove, _assertThisInitialized(_this));

	    _this.app.systems.on(INITIALIZE, _this.onInitialize, _assertThisInitialized(_this));

	    _this.app.systems.on(POST_INITIALIZE, _this.onPostInitialize, _assertThisInitialized(_this));

	    _this.app.systems.on(UPDATE, _this.onUpdate, _assertThisInitialized(_this));

	    _this.app.systems.on(FIXED_UPDATE, _this.onFixedUpdate, _assertThisInitialized(_this));

	    _this.app.systems.on(POST_UPDATE, _this.onPostUpdate, _assertThisInitialized(_this));

	    _this.app.systems.on(TOOLS_UPDATE, _this.onToolsUpdate, _assertThisInitialized(_this));

	    return _this;
	  }

	  var _proto = ScriptLegacyComponentSystem.prototype;

	  _proto.initializeComponentData = function initializeComponentData(component, data, properties) {
	    properties = ['runInTools', 'enabled', 'scripts'];

	    if (data.scripts && data.scripts.length) {
	      data.scripts.forEach(function (script) {
	        if (script.attributes && Array.isArray(script.attributes)) {
	          var dict = {};

	          for (var i = 0; i < script.attributes.length; i++) {
	            dict[script.attributes[i].name] = script.attributes[i];
	          }

	          script.attributes = dict;
	        }
	      });
	    }

	    _ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
	  };

	  _proto.cloneComponent = function cloneComponent(entity, clone) {
	    var src = this.store[entity.getGuid()];
	    var data = {
	      runInTools: src.data.runInTools,
	      scripts: [],
	      enabled: src.data.enabled
	    };
	    var scripts = src.data.scripts;

	    for (var i = 0, len = scripts.length; i < len; i++) {
	      var attributes = scripts[i].attributes;

	      if (attributes) {
	        delete scripts[i].attributes;
	      }

	      data.scripts.push(extend({}, scripts[i]));

	      if (attributes) {
	        data.scripts[i].attributes = this._cloneAttributes(attributes);
	        scripts[i].attributes = attributes;
	      }
	    }

	    return this.addComponent(clone, data);
	  };

	  _proto.onBeforeRemove = function onBeforeRemove(entity, component) {
	    if (component.enabled) {
	      this._disableScriptComponent(component);
	    }

	    this._destroyScriptComponent(component);
	  };

	  _proto.onInitialize = function onInitialize(root) {
	    this._registerInstances(root);

	    if (root.enabled) {
	      if (root.script && root.script.enabled) {
	        this._initializeScriptComponent(root.script);
	      }

	      var children = root._children;

	      for (var i = 0, len = children.length; i < len; i++) {
	        if (children[i] instanceof Entity) {
	          this.onInitialize(children[i]);
	        }
	      }
	    }
	  };

	  _proto.onPostInitialize = function onPostInitialize(root) {
	    if (root.enabled) {
	      if (root.script && root.script.enabled) {
	        this._postInitializeScriptComponent(root.script);
	      }

	      var children = root._children;

	      for (var i = 0, len = children.length; i < len; i++) {
	        if (children[i] instanceof Entity) {
	          this.onPostInitialize(children[i]);
	        }
	      }
	    }
	  };

	  _proto._callInstancesMethod = function _callInstancesMethod(script, method) {
	    var instances = script.data.instances;

	    for (var name in instances) {
	      if (instances.hasOwnProperty(name)) {
	        var instance = instances[name].instance;

	        if (instance[method]) {
	          instance[method]();
	        }
	      }
	    }
	  };

	  _proto._initializeScriptComponent = function _initializeScriptComponent(script) {
	    this._callInstancesMethod(script, INITIALIZE);

	    script.data.initialized = true;

	    if (script.enabled && script.entity.enabled) {
	      this._enableScriptComponent(script);
	    }
	  };

	  _proto._enableScriptComponent = function _enableScriptComponent(script) {
	    this._callInstancesMethod(script, ON_ENABLE);
	  };

	  _proto._disableScriptComponent = function _disableScriptComponent(script) {
	    this._callInstancesMethod(script, ON_DISABLE);
	  };

	  _proto._destroyScriptComponent = function _destroyScriptComponent(script) {
	    var instances = script.data.instances;

	    for (var name in instances) {
	      if (instances.hasOwnProperty(name)) {
	        var instance = instances[name].instance;

	        if (instance.destroy) {
	          instance.destroy();
	        }

	        if (instance.update) {
	          var index = this.instancesWithUpdate.indexOf(instance);

	          if (index >= 0) {
	            this.instancesWithUpdate.splice(index, 1);
	          }
	        }

	        if (instance.fixedUpdate) {
	          var _index = this.instancesWithFixedUpdate.indexOf(instance);

	          if (_index >= 0) {
	            this.instancesWithFixedUpdate.splice(_index, 1);
	          }
	        }

	        if (instance.postUpdate) {
	          var _index2 = this.instancesWithPostUpdate.indexOf(instance);

	          if (_index2 >= 0) {
	            this.instancesWithPostUpdate.splice(_index2, 1);
	          }
	        }

	        if (instance.toolsUpdate) {
	          var _index3 = this.instancesWithToolsUpdate.indexOf(instance);

	          if (_index3 >= 0) {
	            this.instancesWithToolsUpdate.splice(_index3, 1);
	          }
	        }

	        if (script.instances[name].instance === script[name]) {
	          delete script[name];
	        }

	        delete script.instances[name];
	      }
	    }
	  };

	  _proto._postInitializeScriptComponent = function _postInitializeScriptComponent(script) {
	    this._callInstancesMethod(script, POST_INITIALIZE);

	    script.data.postInitialized = true;
	  };

	  _proto._updateInstances = function _updateInstances(method, updateList, dt) {
	    for (var i = 0, len = updateList.length; i < len; i++) {
	      var item = updateList[i];

	      if (item && item.entity && item.entity.enabled && item.entity.script.enabled) {
	        item[method](dt);
	      }
	    }
	  };

	  _proto.onUpdate = function onUpdate(dt) {
	    this._updateInstances(UPDATE, this.instancesWithUpdate, dt);
	  };

	  _proto.onFixedUpdate = function onFixedUpdate(dt) {
	    this._updateInstances(FIXED_UPDATE, this.instancesWithFixedUpdate, dt);
	  };

	  _proto.onPostUpdate = function onPostUpdate(dt) {
	    this._updateInstances(POST_UPDATE, this.instancesWithPostUpdate, dt);
	  };

	  _proto.onToolsUpdate = function onToolsUpdate(dt) {
	    this._updateInstances(TOOLS_UPDATE, this.instancesWithToolsUpdate, dt);
	  };

	  _proto.broadcast = function broadcast(name, functionName) {
	    var args = Array.prototype.slice.call(arguments, 2);
	    var dataStore = this.store;

	    for (var id in dataStore) {
	      if (dataStore.hasOwnProperty(id)) {
	        var data = dataStore[id].data;

	        if (data.instances[name]) {
	          var fn = data.instances[name].instance[functionName];

	          if (fn) {
	            fn.apply(data.instances[name].instance, args);
	          }
	        }
	      }
	    }
	  };

	  _proto._preRegisterInstance = function _preRegisterInstance(entity, url, name, instance) {
	    if (entity.script) {
	      entity.script.data._instances = entity.script.data._instances || {};

	      if (entity.script.data._instances[name]) {
	        throw Error("Script name collision '" + name + "'. Scripts from '" + url + "' and '" + entity.script.data._instances[name].url + "' {" + entity.getGuid() + "}");
	      }

	      entity.script.data._instances[name] = {
	        url: url,
	        name: name,
	        instance: instance
	      };
	    }
	  };

	  _proto._registerInstances = function _registerInstances(entity) {
	    if (entity.script) {
	      if (entity.script.data._instances) {
	        entity.script.instances = entity.script.data._instances;

	        for (var instanceName in entity.script.instances) {
	          var preRegistered = entity.script.instances[instanceName];
	          var instance = preRegistered.instance;
	          events.attach(instance);

	          if (instance.update) {
	            this.instancesWithUpdate.push(instance);
	          }

	          if (instance.fixedUpdate) {
	            this.instancesWithFixedUpdate.push(instance);
	          }

	          if (instance.postUpdate) {
	            this.instancesWithPostUpdate.push(instance);
	          }

	          if (instance.toolsUpdate) {
	            this.instancesWithToolsUpdate.push(instance);
	          }

	          if (entity.script.scripts) {
	            this._createAccessors(entity, preRegistered);
	          }

	          if (entity.script[instanceName]) {
	            throw Error("Script with name '" + instanceName + "' is already attached to Script Component");
	          } else {
	            entity.script[instanceName] = instance;
	          }
	        }

	        delete entity.script.data._instances;
	      }
	    }

	    var children = entity._children;

	    for (var i = 0, len = children.length; i < len; i++) {
	      if (children[i] instanceof Entity) {
	        this._registerInstances(children[i]);
	      }
	    }
	  };

	  _proto._cloneAttributes = function _cloneAttributes(attributes) {
	    var result = {};

	    for (var key in attributes) {
	      if (!attributes.hasOwnProperty(key)) continue;

	      if (attributes[key].type !== 'entity') {
	        result[key] = extend({}, attributes[key]);
	      } else {
	        var val = attributes[key].value;
	        delete attributes[key].value;
	        result[key] = extend({}, attributes[key]);
	        result[key].value = val;
	        attributes[key].value = val;
	      }
	    }

	    return result;
	  };

	  _proto._createAccessors = function _createAccessors(entity, instance) {
	    var len = entity.script.scripts.length;
	    var url = instance.url;

	    for (var i = 0; i < len; i++) {
	      var script = entity.script.scripts[i];

	      if (script.url === url) {
	        var attributes = script.attributes;

	        if (script.name && attributes) {
	          for (var key in attributes) {
	            if (attributes.hasOwnProperty(key)) {
	              this._createAccessor(attributes[key], instance);
	            }
	          }

	          entity.script.data.attributes[script.name] = this._cloneAttributes(attributes);
	        }

	        break;
	      }
	    }
	  };

	  _proto._createAccessor = function _createAccessor(attribute, instance) {
	    var self = this;
	    attribute = {
	      name: attribute.name,
	      value: attribute.value,
	      type: attribute.type
	    };

	    this._convertAttributeValue(attribute);

	    Object.defineProperty(instance.instance, attribute.name, {
	      get: function get() {
	        return attribute.value;
	      },
	      set: function set(value) {
	        var oldValue = attribute.value;
	        attribute.value = value;

	        self._convertAttributeValue(attribute);

	        instance.instance.fire('set', attribute.name, oldValue, attribute.value);
	      },
	      configurable: true
	    });
	  };

	  _proto._updateAccessors = function _updateAccessors(entity, instance) {
	    var len = entity.script.scripts.length;
	    var url = instance.url;

	    for (var i = 0; i < len; i++) {
	      var scriptComponent = entity.script;
	      var script = scriptComponent.scripts[i];

	      if (script.url === url) {
	        var name = script.name;
	        var attributes = script.attributes;

	        if (name) {
	          if (attributes) {
	            for (var key in attributes) {
	              if (attributes.hasOwnProperty(key)) {
	                this._createAccessor(attributes[key], instance);
	              }
	            }
	          }

	          var previousAttributes = scriptComponent.data.attributes[name];

	          if (previousAttributes) {
	            for (var _key in previousAttributes) {
	              var oldAttribute = previousAttributes[_key];

	              if (!(_key in attributes)) {
	                delete instance.instance[oldAttribute.name];
	              } else {
	                if (attributes[_key].value !== oldAttribute.value) {
	                  if (instance.instance.onAttributeChanged) {
	                    instance.instance.onAttributeChanged(oldAttribute.name, oldAttribute.value, attributes[_key].value);
	                  }
	                }
	              }
	            }
	          }

	          if (attributes) {
	            scriptComponent.data.attributes[name] = this._cloneAttributes(attributes);
	          } else {
	            delete scriptComponent.data.attributes[name];
	          }
	        }

	        break;
	      }
	    }
	  };

	  _proto._convertAttributeValue = function _convertAttributeValue(attribute) {
	    if (attribute.type === 'rgb' || attribute.type === 'rgba') {
	      if (Array.isArray(attribute.value)) {
	        attribute.value = attribute.value.length === 3 ? new Color(attribute.value[0], attribute.value[1], attribute.value[2]) : new Color(attribute.value[0], attribute.value[1], attribute.value[2], attribute.value[3]);
	      }
	    } else if (attribute.type === 'vec2') {
	      if (Array.isArray(attribute.value)) attribute.value = new Vec2(attribute.value[0], attribute.value[1]);
	    } else if (attribute.type === 'vec3' || attribute.type === 'vector') {
	      if (Array.isArray(attribute.value)) attribute.value = new Vec3(attribute.value[0], attribute.value[1], attribute.value[2]);
	    } else if (attribute.type === 'vec4') {
	      if (Array.isArray(attribute.value)) attribute.value = new Vec4(attribute.value[0], attribute.value[1], attribute.value[2], attribute.value[3]);
	    } else if (attribute.type === 'entity') {
	      if (attribute.value !== null && typeof attribute.value === 'string') attribute.value = this.app.root.findByGuid(attribute.value);
	    } else if (attribute.type === 'curve' || attribute.type === 'colorcurve') {
	      var curveType = attribute.value.keys[0] instanceof Array ? CurveSet : Curve;
	      attribute.value = new curveType(attribute.value.keys);
	      attribute.value.type = attribute.value.type;
	    }
	  };

	  _proto.destroy = function destroy() {
	    _ComponentSystem.prototype.destroy.call(this);

	    this.app.systems.off(INITIALIZE, this.onInitialize, this);
	    this.app.systems.off(POST_INITIALIZE, this.onPostInitialize, this);
	    this.app.systems.off(UPDATE, this.onUpdate, this);
	    this.app.systems.off(FIXED_UPDATE, this.onFixedUpdate, this);
	    this.app.systems.off(POST_UPDATE, this.onPostUpdate, this);
	    this.app.systems.off(TOOLS_UPDATE, this.onToolsUpdate, this);
	  };

	  return ScriptLegacyComponentSystem;
	}(ComponentSystem);

	Component._buildAccessors(ScriptLegacyComponent.prototype, _schema$6);

	var _inputScreenPosition = new Vec2();

	var _inputWorldPosition = new Vec3();

	var _rayOrigin = new Vec3();

	var _rayDirection = new Vec3();

	var _planeOrigin = new Vec3();

	var _planeNormal = new Vec3();

	var _entityRotation = new Quat();

	var OPPOSITE_AXIS = {
	  x: 'y',
	  y: 'x'
	};

	var ElementDragHelper = function (_EventHandler) {
	  _inheritsLoose(ElementDragHelper, _EventHandler);

	  function ElementDragHelper(element, axis) {
	    var _this;

	    _this = _EventHandler.call(this) || this;

	    if (!element || !(element instanceof ElementComponent)) {
	      throw new Error('Element was null or not an ElementComponent');
	    }

	    if (axis && axis !== 'x' && axis !== 'y') {
	      throw new Error('Unrecognized axis: ' + axis);
	    }

	    _this._element = element;
	    _this._app = element.system.app;
	    _this._axis = axis || null;
	    _this._enabled = true;
	    _this._dragScale = new Vec3();
	    _this._dragStartMousePosition = new Vec3();
	    _this._dragStartHandlePosition = new Vec3();
	    _this._deltaMousePosition = new Vec3();
	    _this._deltaHandlePosition = new Vec3();
	    _this._isDragging = false;

	    _this._toggleLifecycleListeners('on');

	    return _this;
	  }

	  var _proto = ElementDragHelper.prototype;

	  _proto._toggleLifecycleListeners = function _toggleLifecycleListeners(onOrOff) {
	    this._element[onOrOff]('mousedown', this._onMouseDownOrTouchStart, this);

	    this._element[onOrOff]('touchstart', this._onMouseDownOrTouchStart, this);
	  };

	  _proto._toggleDragListeners = function _toggleDragListeners(onOrOff) {
	    var isOn = onOrOff === 'on';

	    if (this._hasDragListeners && isOn) {
	      return;
	    }

	    if (!this._handleMouseUpOrTouchEnd) {
	      this._handleMouseUpOrTouchEnd = this._onMouseUpOrTouchEnd.bind(this);
	    }

	    if (this._app.mouse) {
	      this._element[onOrOff]('mousemove', this._onMove, this);

	      this._element[onOrOff]('mouseup', this._handleMouseUpOrTouchEnd, false);
	    }

	    if (platform.touch) {
	      this._element[onOrOff]('touchmove', this._onMove, this);

	      this._element[onOrOff]('touchend', this._handleMouseUpOrTouchEnd, this);

	      this._element[onOrOff]('touchcancel', this._handleMouseUpOrTouchEnd, this);
	    }

	    this._hasDragListeners = isOn;
	  };

	  _proto._onMouseDownOrTouchStart = function _onMouseDownOrTouchStart(event) {
	    if (this._element && !this._isDragging && this.enabled) {
	      this._dragCamera = event.camera;

	      this._calculateDragScale();

	      var currentMousePosition = this._screenToLocal(event);

	      if (currentMousePosition) {
	        this._toggleDragListeners('on');

	        this._isDragging = true;

	        this._dragStartMousePosition.copy(currentMousePosition);

	        this._dragStartHandlePosition.copy(this._element.entity.getLocalPosition());

	        this.fire('drag:start');
	      }
	    }
	  };

	  _proto._onMouseUpOrTouchEnd = function _onMouseUpOrTouchEnd() {
	    if (this._isDragging) {
	      this._isDragging = false;

	      this._toggleDragListeners('off');

	      this.fire('drag:end');
	    }
	  };

	  _proto._screenToLocal = function _screenToLocal(event) {
	    this._determineInputPosition(event);

	    this._chooseRayOriginAndDirection();

	    _planeOrigin.copy(this._element.entity.getPosition());

	    _planeNormal.copy(this._element.entity.forward).mulScalar(-1);

	    var denominator = _planeNormal.dot(_rayDirection);

	    if (Math.abs(denominator) > 0) {
	      var rayOriginToPlaneOrigin = _planeOrigin.sub(_rayOrigin);

	      var collisionDistance = rayOriginToPlaneOrigin.dot(_planeNormal) / denominator;

	      var position = _rayOrigin.add(_rayDirection.mulScalar(collisionDistance));

	      _entityRotation.copy(this._element.entity.getRotation()).invert().transformVector(position, position);

	      position.mul(this._dragScale);
	      return position;
	    }

	    return null;
	  };

	  _proto._determineInputPosition = function _determineInputPosition(event) {
	    var devicePixelRatio = this._app.graphicsDevice.maxPixelRatio;

	    if (typeof event.x !== 'undefined' && typeof event.y !== 'undefined') {
	      _inputScreenPosition.x = event.x * devicePixelRatio;
	      _inputScreenPosition.y = event.y * devicePixelRatio;
	    } else if (event.changedTouches) {
	      _inputScreenPosition.x = event.changedTouches[0].x * devicePixelRatio;
	      _inputScreenPosition.y = event.changedTouches[0].y * devicePixelRatio;
	    } else {
	      console.warn('Could not determine position from input event');
	    }
	  };

	  _proto._chooseRayOriginAndDirection = function _chooseRayOriginAndDirection() {
	    if (this._element.screen && this._element.screen.screen.screenSpace) {
	      _rayOrigin.set(_inputScreenPosition.x, -_inputScreenPosition.y, 0);

	      _rayDirection.set(0, 0, -1);
	    } else {
	      _inputWorldPosition.copy(this._dragCamera.screenToWorld(_inputScreenPosition.x, _inputScreenPosition.y, 1));

	      _rayOrigin.copy(this._dragCamera.entity.getPosition());

	      _rayDirection.copy(_inputWorldPosition).sub(_rayOrigin).normalize();
	    }
	  };

	  _proto._calculateDragScale = function _calculateDragScale() {
	    var current = this._element.entity.parent;
	    var screen = this._element.screen && this._element.screen.screen;
	    var isWithin2DScreen = screen && screen.screenSpace;
	    var screenScale = isWithin2DScreen ? screen.scale : 1;
	    var dragScale = this._dragScale;
	    dragScale.set(screenScale, screenScale, screenScale);

	    while (current) {
	      dragScale.mul(current.getLocalScale());
	      current = current.parent;

	      if (isWithin2DScreen && current.screen) {
	        break;
	      }
	    }

	    dragScale.x = 1 / dragScale.x;
	    dragScale.y = 1 / dragScale.y;
	    dragScale.z = 1 / dragScale.z;
	  };

	  _proto._onMove = function _onMove(event) {
	    if (this._element && this._isDragging && this.enabled && this._element.enabled && this._element.entity.enabled) {
	      var currentMousePosition = this._screenToLocal(event);

	      if (this._dragStartMousePosition && currentMousePosition) {
	        this._deltaMousePosition.copy(currentMousePosition).sub(this._dragStartMousePosition);

	        this._deltaHandlePosition.copy(this._dragStartHandlePosition).add(this._deltaMousePosition);

	        if (this._axis) {
	          var currentPosition = this._element.entity.getLocalPosition();

	          var constrainedAxis = OPPOSITE_AXIS[this._axis];
	          this._deltaHandlePosition[constrainedAxis] = currentPosition[constrainedAxis];
	        }

	        this._element.entity.setLocalPosition(this._deltaHandlePosition);

	        this.fire('drag:move', this._deltaHandlePosition);
	      }
	    }
	  };

	  _proto.destroy = function destroy() {
	    this._toggleLifecycleListeners('off');

	    this._toggleDragListeners('off');
	  };

	  _createClass(ElementDragHelper, [{
	    key: "enabled",
	    get: function get() {
	      return this._enabled;
	    },
	    set: function set(value) {
	      this._enabled = value;
	    }
	  }, {
	    key: "isDragging",
	    get: function get() {
	      return this._isDragging;
	    }
	  }]);

	  return ElementDragHelper;
	}(EventHandler);

	var SCROLL_MODE_CLAMP = 0;
	var SCROLL_MODE_BOUNCE = 1;
	var SCROLL_MODE_INFINITE = 2;
	var SCROLLBAR_VISIBILITY_SHOW_ALWAYS = 0;
	var SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED = 1;

	var _tempScrollValue = new Vec2();

	var ScrollViewComponent = function (_Component) {
	  _inheritsLoose(ScrollViewComponent, _Component);

	  function ScrollViewComponent(system, entity) {
	    var _this;

	    _this = _Component.call(this, system, entity) || this;
	    _this._viewportReference = new EntityReference(_assertThisInitialized(_this), 'viewportEntity', {
	      'element#gain': _this._onViewportElementGain,
	      'element#resize': _this._onSetContentOrViewportSize
	    });
	    _this._contentReference = new EntityReference(_assertThisInitialized(_this), 'contentEntity', {
	      'element#gain': _this._onContentElementGain,
	      'element#lose': _this._onContentElementLose,
	      'element#resize': _this._onSetContentOrViewportSize
	    });
	    _this._scrollbarUpdateFlags = {};
	    _this._scrollbarReferences = {};
	    _this._scrollbarReferences[ORIENTATION_HORIZONTAL] = new EntityReference(_assertThisInitialized(_this), 'horizontalScrollbarEntity', {
	      'scrollbar#set:value': _this._onSetHorizontalScrollbarValue,
	      'scrollbar#gain': _this._onHorizontalScrollbarGain
	    });
	    _this._scrollbarReferences[ORIENTATION_VERTICAL] = new EntityReference(_assertThisInitialized(_this), 'verticalScrollbarEntity', {
	      'scrollbar#set:value': _this._onSetVerticalScrollbarValue,
	      'scrollbar#gain': _this._onVerticalScrollbarGain
	    });
	    _this._prevContentSizes = {};
	    _this._prevContentSizes[ORIENTATION_HORIZONTAL] = null;
	    _this._prevContentSizes[ORIENTATION_VERTICAL] = null;
	    _this._scroll = new Vec2();
	    _this._velocity = new Vec3();
	    _this._dragStartPosition = new Vec3();
	    _this._disabledContentInput = false;
	    _this._disabledContentInputEntities = [];

	    _this._toggleLifecycleListeners('on', system);

	    _this._toggleElementListeners('on');

	    return _this;
	  }

	  var _proto = ScrollViewComponent.prototype;

	  _proto._toggleLifecycleListeners = function _toggleLifecycleListeners(onOrOff, system) {
	    this[onOrOff]('set_horizontal', this._onSetHorizontalScrollingEnabled, this);
	    this[onOrOff]('set_vertical', this._onSetVerticalScrollingEnabled, this);
	    system.app.systems.element[onOrOff]('add', this._onElementComponentAdd, this);
	    system.app.systems.element[onOrOff]('beforeremove', this._onElementComponentRemove, this);
	  };

	  _proto._toggleElementListeners = function _toggleElementListeners(onOrOff) {
	    if (this.entity.element) {
	      if (onOrOff === 'on' && this._hasElementListeners) {
	        return;
	      }

	      this.entity.element[onOrOff]('resize', this._onSetContentOrViewportSize, this);
	      this.entity.element[onOrOff](EVENT_MOUSEWHEEL, this._onMouseWheel, this);
	      this._hasElementListeners = onOrOff === 'on';
	    }
	  };

	  _proto._onElementComponentAdd = function _onElementComponentAdd(entity) {
	    if (this.entity === entity) {
	      this._toggleElementListeners('on');
	    }
	  };

	  _proto._onElementComponentRemove = function _onElementComponentRemove(entity) {
	    if (this.entity === entity) {
	      this._toggleElementListeners('off');
	    }
	  };

	  _proto._onViewportElementGain = function _onViewportElementGain() {
	    this._syncAll();
	  };

	  _proto._onContentElementGain = function _onContentElementGain() {
	    this._destroyDragHelper();

	    this._contentDragHelper = new ElementDragHelper(this._contentReference.entity.element);

	    this._contentDragHelper.on('drag:start', this._onContentDragStart, this);

	    this._contentDragHelper.on('drag:end', this._onContentDragEnd, this);

	    this._contentDragHelper.on('drag:move', this._onContentDragMove, this);

	    this._prevContentSizes[ORIENTATION_HORIZONTAL] = null;
	    this._prevContentSizes[ORIENTATION_VERTICAL] = null;

	    this._syncAll();
	  };

	  _proto._onContentElementLose = function _onContentElementLose() {
	    this._destroyDragHelper();
	  };

	  _proto._onContentDragStart = function _onContentDragStart() {
	    if (this._contentReference.entity && this.enabled && this.entity.enabled) {
	      this._dragStartPosition.copy(this._contentReference.entity.getLocalPosition());
	    }
	  };

	  _proto._onContentDragEnd = function _onContentDragEnd() {
	    this._prevContentDragPosition = null;

	    this._enableContentInput();
	  };

	  _proto._onContentDragMove = function _onContentDragMove(position) {
	    if (this._contentReference.entity && this.enabled && this.entity.enabled) {
	      this._wasDragged = true;

	      this._setScrollFromContentPosition(position);

	      this._setVelocityFromContentPositionDelta(position);

	      if (!this._disabledContentInput) {
	        var dx = position.x - this._dragStartPosition.x;
	        var dy = position.y - this._dragStartPosition.y;

	        if (Math.abs(dx) > this.dragThreshold || Math.abs(dy) > this.dragThreshold) {
	          this._disableContentInput();
	        }
	      }
	    }
	  };

	  _proto._onSetContentOrViewportSize = function _onSetContentOrViewportSize() {
	    this._syncAll();
	  };

	  _proto._onSetHorizontalScrollbarValue = function _onSetHorizontalScrollbarValue(scrollValueX) {
	    if (!this._scrollbarUpdateFlags[ORIENTATION_HORIZONTAL] && this.enabled && this.entity.enabled) {
	      this._onSetScroll(scrollValueX, null);
	    }
	  };

	  _proto._onSetVerticalScrollbarValue = function _onSetVerticalScrollbarValue(scrollValueY) {
	    if (!this._scrollbarUpdateFlags[ORIENTATION_VERTICAL] && this.enabled && this.entity.enabled) {
	      this._onSetScroll(null, scrollValueY);
	    }
	  };

	  _proto._onSetHorizontalScrollingEnabled = function _onSetHorizontalScrollingEnabled() {
	    this._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);
	  };

	  _proto._onSetVerticalScrollingEnabled = function _onSetVerticalScrollingEnabled() {
	    this._syncScrollbarEnabledState(ORIENTATION_VERTICAL);
	  };

	  _proto._onHorizontalScrollbarGain = function _onHorizontalScrollbarGain() {
	    this._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);

	    this._syncScrollbarPosition(ORIENTATION_HORIZONTAL);
	  };

	  _proto._onVerticalScrollbarGain = function _onVerticalScrollbarGain() {
	    this._syncScrollbarEnabledState(ORIENTATION_VERTICAL);

	    this._syncScrollbarPosition(ORIENTATION_VERTICAL);
	  };

	  _proto._onSetScroll = function _onSetScroll(x, y, resetVelocity) {
	    if (resetVelocity !== false) {
	      this._velocity.set(0, 0, 0);
	    }

	    var xChanged = this._updateAxis(x, 'x', ORIENTATION_HORIZONTAL);

	    var yChanged = this._updateAxis(y, 'y', ORIENTATION_VERTICAL);

	    if (xChanged || yChanged) {
	      this.fire('set:scroll', this._scroll);
	    }
	  };

	  _proto._updateAxis = function _updateAxis(scrollValue, axis, orientation) {
	    var hasChanged = scrollValue !== null && Math.abs(scrollValue - this._scroll[axis]) > 1e-5;

	    if (hasChanged || this._isDragging() || scrollValue === 0) {
	      this._scroll[axis] = this._determineNewScrollValue(scrollValue, axis, orientation);

	      this._syncContentPosition(orientation);

	      this._syncScrollbarPosition(orientation);
	    }

	    return hasChanged;
	  };

	  _proto._determineNewScrollValue = function _determineNewScrollValue(scrollValue, axis, orientation) {
	    if (!this._getScrollingEnabled(orientation)) {
	      return this._scroll[axis];
	    }

	    switch (this.scrollMode) {
	      case SCROLL_MODE_CLAMP:
	        return math.clamp(scrollValue, 0, this._getMaxScrollValue(orientation));

	      case SCROLL_MODE_BOUNCE:
	        this._setVelocityFromOvershoot(scrollValue, axis, orientation);

	        return scrollValue;

	      case SCROLL_MODE_INFINITE:
	        return scrollValue;

	      default:
	        console.warn('Unhandled scroll mode:' + this.scrollMode);
	        return scrollValue;
	    }
	  };

	  _proto._syncAll = function _syncAll() {
	    this._syncContentPosition(ORIENTATION_HORIZONTAL);

	    this._syncContentPosition(ORIENTATION_VERTICAL);

	    this._syncScrollbarPosition(ORIENTATION_HORIZONTAL);

	    this._syncScrollbarPosition(ORIENTATION_VERTICAL);

	    this._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);

	    this._syncScrollbarEnabledState(ORIENTATION_VERTICAL);
	  };

	  _proto._syncContentPosition = function _syncContentPosition(orientation) {
	    var axis = this._getAxis(orientation);

	    var sign = this._getSign(orientation);

	    var contentEntity = this._contentReference.entity;

	    if (contentEntity) {
	      var prevContentSize = this._prevContentSizes[orientation];

	      var currContentSize = this._getContentSize(orientation);

	      if (prevContentSize !== null && Math.abs(prevContentSize - currContentSize) > 1e-4) {
	        var prevMaxOffset = this._getMaxOffset(orientation, prevContentSize);

	        var currMaxOffset = this._getMaxOffset(orientation, currContentSize);

	        if (currMaxOffset === 0) {
	          this._scroll[axis] = 1;
	        } else {
	          this._scroll[axis] = math.clamp(this._scroll[axis] * prevMaxOffset / currMaxOffset, 0, 1);
	        }
	      }

	      var offset = this._scroll[axis] * this._getMaxOffset(orientation);

	      var contentPosition = contentEntity.getLocalPosition();
	      contentPosition[axis] = offset * sign;
	      contentEntity.setLocalPosition(contentPosition);
	      this._prevContentSizes[orientation] = currContentSize;
	    }
	  };

	  _proto._syncScrollbarPosition = function _syncScrollbarPosition(orientation) {
	    var axis = this._getAxis(orientation);

	    var scrollbarEntity = this._scrollbarReferences[orientation].entity;

	    if (scrollbarEntity && scrollbarEntity.scrollbar) {
	      this._scrollbarUpdateFlags[orientation] = true;
	      scrollbarEntity.scrollbar.value = this._scroll[axis];
	      scrollbarEntity.scrollbar.handleSize = this._getScrollbarHandleSize(axis, orientation);
	      this._scrollbarUpdateFlags[orientation] = false;
	    }
	  };

	  _proto._syncScrollbarEnabledState = function _syncScrollbarEnabledState(orientation) {
	    var entity = this._scrollbarReferences[orientation].entity;

	    if (entity) {
	      var isScrollingEnabled = this._getScrollingEnabled(orientation);

	      var requestedVisibility = this._getScrollbarVisibility(orientation);

	      switch (requestedVisibility) {
	        case SCROLLBAR_VISIBILITY_SHOW_ALWAYS:
	          entity.enabled = isScrollingEnabled;
	          return;

	        case SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED:
	          entity.enabled = isScrollingEnabled && this._contentIsLargerThanViewport(orientation);
	          return;

	        default:
	          console.warn('Unhandled scrollbar visibility:' + requestedVisibility);
	          entity.enabled = isScrollingEnabled;
	      }
	    }
	  };

	  _proto._contentIsLargerThanViewport = function _contentIsLargerThanViewport(orientation) {
	    return this._getContentSize(orientation) > this._getViewportSize(orientation);
	  };

	  _proto._contentPositionToScrollValue = function _contentPositionToScrollValue(contentPosition) {
	    var maxOffsetH = this._getMaxOffset(ORIENTATION_HORIZONTAL);

	    var maxOffsetV = this._getMaxOffset(ORIENTATION_VERTICAL);

	    if (maxOffsetH === 0) {
	      _tempScrollValue.x = 0;
	    } else {
	      _tempScrollValue.x = contentPosition.x / maxOffsetH;
	    }

	    if (maxOffsetV === 0) {
	      _tempScrollValue.y = 0;
	    } else {
	      _tempScrollValue.y = contentPosition.y / -maxOffsetV;
	    }

	    return _tempScrollValue;
	  };

	  _proto._getMaxOffset = function _getMaxOffset(orientation, contentSize) {
	    contentSize = contentSize === undefined ? this._getContentSize(orientation) : contentSize;

	    var viewportSize = this._getViewportSize(orientation);

	    if (contentSize < viewportSize) {
	      return -this._getViewportSize(orientation);
	    }

	    return viewportSize - contentSize;
	  };

	  _proto._getMaxScrollValue = function _getMaxScrollValue(orientation) {
	    return this._contentIsLargerThanViewport(orientation) ? 1 : 0;
	  };

	  _proto._getScrollbarHandleSize = function _getScrollbarHandleSize(axis, orientation) {
	    var viewportSize = this._getViewportSize(orientation);

	    var contentSize = this._getContentSize(orientation);

	    if (Math.abs(contentSize) < 0.001) {
	      return 1;
	    }

	    var handleSize = Math.min(viewportSize / contentSize, 1);

	    var overshoot = this._toOvershoot(this._scroll[axis], orientation);

	    if (overshoot === 0) {
	      return handleSize;
	    }

	    return handleSize / (1 + Math.abs(overshoot));
	  };

	  _proto._getViewportSize = function _getViewportSize(orientation) {
	    return this._getSize(orientation, this._viewportReference);
	  };

	  _proto._getContentSize = function _getContentSize(orientation) {
	    return this._getSize(orientation, this._contentReference);
	  };

	  _proto._getSize = function _getSize(orientation, entityReference) {
	    if (entityReference.entity && entityReference.entity.element) {
	      return entityReference.entity.element[this._getCalculatedDimension(orientation)];
	    }

	    return 0;
	  };

	  _proto._getScrollingEnabled = function _getScrollingEnabled(orientation) {
	    if (orientation === ORIENTATION_HORIZONTAL) {
	      return this.horizontal;
	    } else if (orientation === ORIENTATION_VERTICAL) {
	      return this.vertical;
	    }

	    return undefined;
	  };

	  _proto._getScrollbarVisibility = function _getScrollbarVisibility(orientation) {
	    if (orientation === ORIENTATION_HORIZONTAL) {
	      return this.horizontalScrollbarVisibility;
	    } else if (orientation === ORIENTATION_VERTICAL) {
	      return this.verticalScrollbarVisibility;
	    }

	    return undefined;
	  };

	  _proto._getSign = function _getSign(orientation) {
	    return orientation === ORIENTATION_HORIZONTAL ? 1 : -1;
	  };

	  _proto._getAxis = function _getAxis(orientation) {
	    return orientation === ORIENTATION_HORIZONTAL ? 'x' : 'y';
	  };

	  _proto._getCalculatedDimension = function _getCalculatedDimension(orientation) {
	    return orientation === ORIENTATION_HORIZONTAL ? 'calculatedWidth' : 'calculatedHeight';
	  };

	  _proto._destroyDragHelper = function _destroyDragHelper() {
	    if (this._contentDragHelper) {
	      this._contentDragHelper.destroy();
	    }
	  };

	  _proto.onUpdate = function onUpdate() {
	    if (this._contentReference.entity) {
	      this._updateVelocity();

	      this._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);

	      this._syncScrollbarEnabledState(ORIENTATION_VERTICAL);
	    }
	  };

	  _proto._updateVelocity = function _updateVelocity() {
	    if (!this._isDragging()) {
	      if (this.scrollMode === SCROLL_MODE_BOUNCE) {
	        if (this._hasOvershoot('x', ORIENTATION_HORIZONTAL)) {
	          this._setVelocityFromOvershoot(this.scroll.x, 'x', ORIENTATION_HORIZONTAL);
	        }

	        if (this._hasOvershoot('y', ORIENTATION_VERTICAL)) {
	          this._setVelocityFromOvershoot(this.scroll.y, 'y', ORIENTATION_VERTICAL);
	        }
	      }

	      if (Math.abs(this._velocity.x) > 1e-4 || Math.abs(this._velocity.y) > 1e-4) {
	        var position = this._contentReference.entity.getLocalPosition();

	        position.x += this._velocity.x;
	        position.y += this._velocity.y;

	        this._contentReference.entity.setLocalPosition(position);

	        this._setScrollFromContentPosition(position);
	      }

	      this._velocity.x *= 1 - this.friction;
	      this._velocity.y *= 1 - this.friction;
	    }
	  };

	  _proto._hasOvershoot = function _hasOvershoot(axis, orientation) {
	    return Math.abs(this._toOvershoot(this.scroll[axis], orientation)) > 0.001;
	  };

	  _proto._toOvershoot = function _toOvershoot(scrollValue, orientation) {
	    var maxScrollValue = this._getMaxScrollValue(orientation);

	    if (scrollValue < 0) {
	      return scrollValue;
	    } else if (scrollValue > maxScrollValue) {
	      return scrollValue - maxScrollValue;
	    }

	    return 0;
	  };

	  _proto._setVelocityFromOvershoot = function _setVelocityFromOvershoot(scrollValue, axis, orientation) {
	    var overshootValue = this._toOvershoot(scrollValue, orientation);

	    var overshootPixels = overshootValue * this._getMaxOffset(orientation) * this._getSign(orientation);

	    if (Math.abs(overshootPixels) > 0) {
	      this._velocity[axis] = -overshootPixels / (this.bounceAmount * 50 + 1);
	    }
	  };

	  _proto._setVelocityFromContentPositionDelta = function _setVelocityFromContentPositionDelta(position) {
	    if (this._prevContentDragPosition) {
	      this._velocity.sub2(position, this._prevContentDragPosition);

	      this._prevContentDragPosition.copy(position);
	    } else {
	      this._velocity.set(0, 0, 0);

	      this._prevContentDragPosition = position.clone();
	    }
	  };

	  _proto._setScrollFromContentPosition = function _setScrollFromContentPosition(position) {
	    var scrollValue = this._contentPositionToScrollValue(position);

	    if (this._isDragging()) {
	      scrollValue = this._applyScrollValueTension(scrollValue);
	    }

	    this._onSetScroll(scrollValue.x, scrollValue.y, false);
	  };

	  _proto._applyScrollValueTension = function _applyScrollValueTension(scrollValue) {
	    var factor = 1;

	    var max = this._getMaxScrollValue(ORIENTATION_HORIZONTAL);

	    var overshoot = this._toOvershoot(scrollValue.x, ORIENTATION_HORIZONTAL);

	    if (overshoot > 0) {
	      scrollValue.x = max + factor * Math.log10(1 + overshoot);
	    } else if (overshoot < 0) {
	      scrollValue.x = -factor * Math.log10(1 - overshoot);
	    }

	    max = this._getMaxScrollValue(ORIENTATION_VERTICAL);
	    overshoot = this._toOvershoot(scrollValue.y, ORIENTATION_VERTICAL);

	    if (overshoot > 0) {
	      scrollValue.y = max + factor * Math.log10(1 + overshoot);
	    } else if (overshoot < 0) {
	      scrollValue.y = -factor * Math.log10(1 - overshoot);
	    }

	    return scrollValue;
	  };

	  _proto._isDragging = function _isDragging() {
	    return this._contentDragHelper && this._contentDragHelper.isDragging;
	  };

	  _proto._setScrollbarComponentsEnabled = function _setScrollbarComponentsEnabled(enabled) {
	    if (this._scrollbarReferences[ORIENTATION_HORIZONTAL].hasComponent('scrollbar')) {
	      this._scrollbarReferences[ORIENTATION_HORIZONTAL].entity.scrollbar.enabled = enabled;
	    }

	    if (this._scrollbarReferences[ORIENTATION_VERTICAL].hasComponent('scrollbar')) {
	      this._scrollbarReferences[ORIENTATION_VERTICAL].entity.scrollbar.enabled = enabled;
	    }
	  };

	  _proto._setContentDraggingEnabled = function _setContentDraggingEnabled(enabled) {
	    if (this._contentDragHelper) {
	      this._contentDragHelper.enabled = enabled;
	    }
	  };

	  _proto._onMouseWheel = function _onMouseWheel(event) {
	    if (this.useMouseWheel) {
	      var wheelEvent = event.event;
	      var normalizedDeltaX = wheelEvent.deltaX / this._contentReference.entity.element.calculatedWidth * this.mouseWheelSensitivity.x;
	      var normalizedDeltaY = wheelEvent.deltaY / this._contentReference.entity.element.calculatedHeight * this.mouseWheelSensitivity.y;
	      var scrollX = math.clamp(this._scroll.x + normalizedDeltaX, 0, this._getMaxScrollValue(ORIENTATION_HORIZONTAL));
	      var scrollY = math.clamp(this._scroll.y + normalizedDeltaY, 0, this._getMaxScrollValue(ORIENTATION_VERTICAL));
	      this.scroll = new Vec2(scrollX, scrollY);
	    }
	  };

	  _proto._enableContentInput = function _enableContentInput() {
	    while (this._disabledContentInputEntities.length) {
	      var e = this._disabledContentInputEntities.pop();

	      if (e.element) {
	        e.element.useInput = true;
	      }
	    }

	    this._disabledContentInput = false;
	  };

	  _proto._disableContentInput = function _disableContentInput() {
	    var _this2 = this;

	    var _disableInput = function _disableInput(e) {
	      if (e.element && e.element.useInput) {
	        _this2._disabledContentInputEntities.push(e);

	        e.element.useInput = false;
	      }

	      var children = e.children;

	      for (var i = 0, l = children.length; i < l; i++) {
	        _disableInput(children[i]);
	      }
	    };

	    var contentEntity = this._contentReference.entity;

	    if (contentEntity) {
	      var children = contentEntity.children;

	      for (var i = 0, l = children.length; i < l; i++) {
	        _disableInput(children[i]);
	      }
	    }

	    this._disabledContentInput = true;
	  };

	  _proto.onEnable = function onEnable() {
	    this._viewportReference.onParentComponentEnable();

	    this._contentReference.onParentComponentEnable();

	    this._scrollbarReferences[ORIENTATION_HORIZONTAL].onParentComponentEnable();

	    this._scrollbarReferences[ORIENTATION_VERTICAL].onParentComponentEnable();

	    this._setScrollbarComponentsEnabled(true);

	    this._setContentDraggingEnabled(true);

	    this._syncAll();
	  };

	  _proto.onDisable = function onDisable() {
	    this._setScrollbarComponentsEnabled(false);

	    this._setContentDraggingEnabled(false);
	  };

	  _proto.onRemove = function onRemove() {
	    this._toggleLifecycleListeners('off', this.system);

	    this._toggleElementListeners('off');

	    this._destroyDragHelper();
	  };

	  _createClass(ScrollViewComponent, [{
	    key: "scroll",
	    get: function get() {
	      return this._scroll;
	    },
	    set: function set(value) {
	      this._onSetScroll(value.x, value.y);
	    }
	  }]);

	  return ScrollViewComponent;
	}(Component);

	var ScrollViewComponentData = function ScrollViewComponentData() {
	  this.enabled = true;
	};

	var _schema$5 = [{
	  name: 'enabled',
	  type: 'boolean'
	}, {
	  name: 'horizontal',
	  type: 'boolean'
	}, {
	  name: 'vertical',
	  type: 'boolean'
	}, {
	  name: 'scrollMode',
	  type: 'number'
	}, {
	  name: 'bounceAmount',
	  type: 'number'
	}, {
	  name: 'friction',
	  type: 'number'
	}, {
	  name: 'dragThreshold',
	  type: 'number'
	}, {
	  name: 'useMouseWheel',
	  type: 'boolean'
	}, {
	  name: 'mouseWheelSensitivity',
	  type: 'vec2'
	}, {
	  name: 'horizontalScrollbarVisibility',
	  type: 'number'
	}, {
	  name: 'verticalScrollbarVisibility',
	  type: 'number'
	}, {
	  name: 'viewportEntity',
	  type: 'entity'
	}, {
	  name: 'contentEntity',
	  type: 'entity'
	}, {
	  name: 'horizontalScrollbarEntity',
	  type: 'entity'
	}, {
	  name: 'verticalScrollbarEntity',
	  type: 'entity'
	}];
	var DEFAULT_DRAG_THRESHOLD = 10;

	var ScrollViewComponentSystem = function (_ComponentSystem) {
	  _inheritsLoose(ScrollViewComponentSystem, _ComponentSystem);

	  function ScrollViewComponentSystem(app) {
	    var _this;

	    _this = _ComponentSystem.call(this, app) || this;
	    _this.id = 'scrollview';
	    _this.ComponentType = ScrollViewComponent;
	    _this.DataType = ScrollViewComponentData;
	    _this.schema = _schema$5;

	    _this.on('beforeremove', _this._onRemoveComponent, _assertThisInitialized(_this));

	    _this.app.systems.on('update', _this.onUpdate, _assertThisInitialized(_this));

	    return _this;
	  }

	  var _proto = ScrollViewComponentSystem.prototype;

	  _proto.initializeComponentData = function initializeComponentData(component, data, properties) {
	    if (data.dragThreshold === undefined) {
	      data.dragThreshold = DEFAULT_DRAG_THRESHOLD;
	    }

	    if (data.useMouseWheel === undefined) {
	      data.useMouseWheel = true;
	    }

	    if (data.mouseWheelSensitivity === undefined) {
	      data.mouseWheelSensitivity = new Vec2(1, 1);
	    }

	    _ComponentSystem.prototype.initializeComponentData.call(this, component, data, _schema$5);
	  };

	  _proto.onUpdate = function onUpdate(dt) {
	    var components = this.store;

	    for (var id in components) {
	      var entity = components[id].entity;
	      var component = entity.scrollview;

	      if (component.enabled && entity.enabled) {
	        component.onUpdate();
	      }
	    }
	  };

	  _proto._onRemoveComponent = function _onRemoveComponent(entity, component) {
	    component.onRemove();
	  };

	  _proto.destroy = function destroy() {
	    _ComponentSystem.prototype.destroy.call(this);

	    this.app.systems.off('update', this.onUpdate, this);
	  };

	  return ScrollViewComponentSystem;
	}(ComponentSystem);

	Component._buildAccessors(ScrollViewComponent.prototype, _schema$5);

	var ScrollbarComponent = function (_Component) {
	  _inheritsLoose(ScrollbarComponent, _Component);

	  function ScrollbarComponent(system, entity) {
	    var _this;

	    _this = _Component.call(this, system, entity) || this;
	    _this._handleReference = new EntityReference(_assertThisInitialized(_this), 'handleEntity', {
	      'element#gain': _this._onHandleElementGain,
	      'element#lose': _this._onHandleElementLose,
	      'element#set:anchor': _this._onSetHandleAlignment,
	      'element#set:margin': _this._onSetHandleAlignment,
	      'element#set:pivot': _this._onSetHandleAlignment
	    });

	    _this._toggleLifecycleListeners('on');

	    return _this;
	  }

	  var _proto = ScrollbarComponent.prototype;

	  _proto._toggleLifecycleListeners = function _toggleLifecycleListeners(onOrOff) {
	    this[onOrOff]('set_value', this._onSetValue, this);
	    this[onOrOff]('set_handleSize', this._onSetHandleSize, this);
	    this[onOrOff]('set_orientation', this._onSetOrientation, this);
	  };

	  _proto._onHandleElementGain = function _onHandleElementGain() {
	    this._destroyDragHelper();

	    this._handleDragHelper = new ElementDragHelper(this._handleReference.entity.element, this._getAxis());

	    this._handleDragHelper.on('drag:move', this._onHandleDrag, this);

	    this._updateHandlePositionAndSize();
	  };

	  _proto._onHandleElementLose = function _onHandleElementLose() {
	    this._destroyDragHelper();
	  };

	  _proto._onHandleDrag = function _onHandleDrag(position) {
	    if (this._handleReference.entity && this.enabled && this.entity.enabled) {
	      this.value = this._handlePositionToScrollValue(position[this._getAxis()]);
	    }
	  };

	  _proto._onSetValue = function _onSetValue(name, oldValue, newValue) {
	    if (Math.abs(newValue - oldValue) > 1e-5) {
	      this.data.value = math.clamp(newValue, 0, 1);

	      this._updateHandlePositionAndSize();

	      this.fire('set:value', this.data.value);
	    }
	  };

	  _proto._onSetHandleSize = function _onSetHandleSize(name, oldValue, newValue) {
	    if (Math.abs(newValue - oldValue) > 1e-5) {
	      this.data.handleSize = math.clamp(newValue, 0, 1);

	      this._updateHandlePositionAndSize();
	    }
	  };

	  _proto._onSetHandleAlignment = function _onSetHandleAlignment() {
	    this._updateHandlePositionAndSize();
	  };

	  _proto._onSetOrientation = function _onSetOrientation(name, oldValue, newValue) {
	    if (newValue !== oldValue && this._handleReference.hasComponent('element')) {
	      this._handleReference.entity.element[this._getOppositeDimension()] = 0;
	    }
	  };

	  _proto._updateHandlePositionAndSize = function _updateHandlePositionAndSize() {
	    var handleEntity = this._handleReference.entity;
	    var handleElement = handleEntity && handleEntity.element;

	    if (handleEntity) {
	      var position = handleEntity.getLocalPosition();
	      position[this._getAxis()] = this._getHandlePosition();

	      this._handleReference.entity.setLocalPosition(position);
	    }

	    if (handleElement) {
	      handleElement[this._getDimension()] = this._getHandleLength();
	    }
	  };

	  _proto._handlePositionToScrollValue = function _handlePositionToScrollValue(handlePosition) {
	    return handlePosition * this._getSign() / this._getUsableTrackLength();
	  };

	  _proto._scrollValueToHandlePosition = function _scrollValueToHandlePosition(value) {
	    return value * this._getSign() * this._getUsableTrackLength();
	  };

	  _proto._getUsableTrackLength = function _getUsableTrackLength() {
	    return Math.max(this._getTrackLength() - this._getHandleLength(), 0.001);
	  };

	  _proto._getTrackLength = function _getTrackLength() {
	    if (this.entity.element) {
	      return this.orientation === ORIENTATION_HORIZONTAL ? this.entity.element.calculatedWidth : this.entity.element.calculatedHeight;
	    }

	    return 0;
	  };

	  _proto._getHandleLength = function _getHandleLength() {
	    return this._getTrackLength() * this.handleSize;
	  };

	  _proto._getHandlePosition = function _getHandlePosition() {
	    return this._scrollValueToHandlePosition(this.value);
	  };

	  _proto._getSign = function _getSign() {
	    return this.orientation === ORIENTATION_HORIZONTAL ? 1 : -1;
	  };

	  _proto._getAxis = function _getAxis() {
	    return this.orientation === ORIENTATION_HORIZONTAL ? 'x' : 'y';
	  };

	  _proto._getDimension = function _getDimension() {
	    return this.orientation === ORIENTATION_HORIZONTAL ? 'width' : 'height';
	  };

	  _proto._getOppositeDimension = function _getOppositeDimension() {
	    return this.orientation === ORIENTATION_HORIZONTAL ? 'height' : 'width';
	  };

	  _proto._destroyDragHelper = function _destroyDragHelper() {
	    if (this._handleDragHelper) {
	      this._handleDragHelper.destroy();
	    }
	  };

	  _proto._setHandleDraggingEnabled = function _setHandleDraggingEnabled(enabled) {
	    if (this._handleDragHelper) {
	      this._handleDragHelper.enabled = enabled;
	    }
	  };

	  _proto.onEnable = function onEnable() {
	    this._handleReference.onParentComponentEnable();

	    this._setHandleDraggingEnabled(true);
	  };

	  _proto.onDisable = function onDisable() {
	    this._setHandleDraggingEnabled(false);
	  };

	  _proto.onRemove = function onRemove() {
	    this._destroyDragHelper();

	    this._toggleLifecycleListeners('off');
	  };

	  return ScrollbarComponent;
	}(Component);

	var ScrollbarComponentData = function ScrollbarComponentData() {
	  this.enabled = true;
	};

	var _schema$4 = [{
	  name: 'enabled',
	  type: 'boolean'
	}, {
	  name: 'orientation',
	  type: 'number'
	}, {
	  name: 'value',
	  type: 'number'
	}, {
	  name: 'handleSize',
	  type: 'number'
	}, {
	  name: 'handleEntity',
	  type: 'entity'
	}];

	var ScrollbarComponentSystem = function (_ComponentSystem) {
	  _inheritsLoose(ScrollbarComponentSystem, _ComponentSystem);

	  function ScrollbarComponentSystem(app) {
	    var _this;

	    _this = _ComponentSystem.call(this, app) || this;
	    _this.id = 'scrollbar';
	    _this.ComponentType = ScrollbarComponent;
	    _this.DataType = ScrollbarComponentData;
	    _this.schema = _schema$4;

	    _this.on('beforeremove', _this._onRemoveComponent, _assertThisInitialized(_this));

	    return _this;
	  }

	  var _proto = ScrollbarComponentSystem.prototype;

	  _proto.initializeComponentData = function initializeComponentData(component, data, properties) {
	    _ComponentSystem.prototype.initializeComponentData.call(this, component, data, _schema$4);
	  };

	  _proto._onRemoveComponent = function _onRemoveComponent(entity, component) {
	    component.onRemove();
	  };

	  return ScrollbarComponentSystem;
	}(ComponentSystem);

	Component._buildAccessors(ScrollbarComponent.prototype, _schema$4);

	var instanceOptions = {
	  volume: 0,
	  pitch: 0,
	  loop: false,
	  startTime: 0,
	  duration: 0,
	  position: new Vec3(),
	  maxDistance: 0,
	  refDistance: 0,
	  rollOffFactor: 0,
	  distanceModel: 0,
	  onPlay: null,
	  onPause: null,
	  onResume: null,
	  onStop: null,
	  onEnd: null
	};

	var SoundSlot = function (_EventHandler) {
	  _inheritsLoose(SoundSlot, _EventHandler);

	  function SoundSlot(component, name, options) {
	    var _this;

	    if (name === void 0) {
	      name = 'Untitled';
	    }

	    if (options === void 0) {
	      options = {};
	    }

	    _this = _EventHandler.call(this) || this;
	    _this.name = void 0;
	    _this.instances = [];
	    _this._component = component;
	    _this._assets = component.system.app.assets;
	    _this._manager = component.system.manager;
	    _this.name = name;
	    _this._volume = options.volume !== undefined ? math.clamp(Number(options.volume) || 0, 0, 1) : 1;
	    _this._pitch = options.pitch !== undefined ? Math.max(0.01, Number(options.pitch) || 0) : 1;
	    _this._loop = !!(options.loop !== undefined ? options.loop : false);
	    _this._duration = options.duration > 0 ? options.duration : null;
	    _this._startTime = Math.max(0, Number(options.startTime) || 0);
	    _this._overlap = !!options.overlap;
	    _this._autoPlay = !!options.autoPlay;
	    _this._firstNode = null;
	    _this._lastNode = null;
	    _this._asset = options.asset;

	    if (_this._asset instanceof Asset) {
	      _this._asset = _this._asset.id;
	    }

	    _this._onInstancePlayHandler = _this._onInstancePlay.bind(_assertThisInitialized(_this));
	    _this._onInstancePauseHandler = _this._onInstancePause.bind(_assertThisInitialized(_this));
	    _this._onInstanceResumeHandler = _this._onInstanceResume.bind(_assertThisInitialized(_this));
	    _this._onInstanceStopHandler = _this._onInstanceStop.bind(_assertThisInitialized(_this));
	    _this._onInstanceEndHandler = _this._onInstanceEnd.bind(_assertThisInitialized(_this));
	    return _this;
	  }

	  var _proto = SoundSlot.prototype;

	  _proto.play = function play() {
	    if (!this.overlap) {
	      this.stop();
	    }

	    if (!this.isLoaded && !this._hasAsset()) {
	      return undefined;
	    }

	    var instance = this._createInstance();

	    this.instances.push(instance);

	    if (!this.isLoaded) {
	      var onLoad = function onLoad(sound) {
	        var playWhenLoaded = instance._playWhenLoaded;
	        instance.sound = sound;

	        if (playWhenLoaded) {
	          instance.play();
	        }
	      };

	      this.off('load', onLoad);
	      this.once('load', onLoad);
	      this.load();
	    } else {
	      instance.play();
	    }

	    return instance;
	  };

	  _proto.pause = function pause() {
	    var paused = false;
	    var instances = this.instances;

	    for (var i = 0, len = instances.length; i < len; i++) {
	      if (instances[i].pause()) {
	        paused = true;
	      }
	    }

	    return paused;
	  };

	  _proto.resume = function resume() {
	    var resumed = false;
	    var instances = this.instances;

	    for (var i = 0, len = instances.length; i < len; i++) {
	      if (instances[i].resume()) resumed = true;
	    }

	    return resumed;
	  };

	  _proto.stop = function stop() {
	    var stopped = false;
	    var instances = this.instances;
	    var i = instances.length;

	    while (i--) {
	      instances[i].stop();
	      stopped = true;
	    }

	    instances.length = 0;
	    return stopped;
	  };

	  _proto.load = function load() {
	    if (!this._hasAsset()) return;

	    var asset = this._assets.get(this._asset);

	    if (!asset) {
	      this._assets.off('add:' + this._asset, this._onAssetAdd, this);

	      this._assets.once('add:' + this._asset, this._onAssetAdd, this);

	      return;
	    }

	    asset.off('remove', this._onAssetRemoved, this);
	    asset.on('remove', this._onAssetRemoved, this);

	    if (!asset.resource) {
	      asset.off('load', this._onAssetLoad, this);
	      asset.once('load', this._onAssetLoad, this);

	      this._assets.load(asset);

	      return;
	    }

	    this.fire('load', asset.resource);
	  };

	  _proto.setExternalNodes = function setExternalNodes(firstNode, lastNode) {
	    if (!firstNode) {
	      console.error('The firstNode must have a valid AudioNode');
	      return;
	    }

	    if (!lastNode) {
	      lastNode = firstNode;
	    }

	    this._firstNode = firstNode;
	    this._lastNode = lastNode;

	    if (!this._overlap) {
	      var instances = this.instances;

	      for (var i = 0, len = instances.length; i < len; i++) {
	        instances[i].setExternalNodes(firstNode, lastNode);
	      }
	    }
	  };

	  _proto.clearExternalNodes = function clearExternalNodes() {
	    this._firstNode = null;
	    this._lastNode = null;

	    if (!this._overlap) {
	      var instances = this.instances;

	      for (var i = 0, len = instances.length; i < len; i++) {
	        instances[i].clearExternalNodes();
	      }
	    }
	  };

	  _proto.getExternalNodes = function getExternalNodes() {
	    return [this._firstNode, this._lastNode];
	  };

	  _proto._hasAsset = function _hasAsset() {
	    return this._asset != null;
	  };

	  _proto._createInstance = function _createInstance() {
	    var instance = null;
	    var component = this._component;
	    var sound = null;

	    if (this._hasAsset()) {
	      var asset = this._assets.get(this._asset);

	      if (asset) {
	        sound = asset.resource;
	      }
	    }

	    var data = instanceOptions;
	    data.volume = this._volume * component.volume;
	    data.pitch = this._pitch * component.pitch;
	    data.loop = this._loop;
	    data.startTime = this._startTime;
	    data.duration = this._duration;
	    data.onPlay = this._onInstancePlayHandler;
	    data.onPause = this._onInstancePauseHandler;
	    data.onResume = this._onInstanceResumeHandler;
	    data.onStop = this._onInstanceStopHandler;
	    data.onEnd = this._onInstanceEndHandler;

	    if (component.positional) {
	      data.position.copy(component.entity.getPosition());
	      data.maxDistance = component.maxDistance;
	      data.refDistance = component.refDistance;
	      data.rollOffFactor = component.rollOffFactor;
	      data.distanceModel = component.distanceModel;
	      instance = new SoundInstance3d(this._manager, sound, data);
	    } else {
	      instance = new SoundInstance(this._manager, sound, data);
	    }

	    if (this._firstNode) {
	      instance.setExternalNodes(this._firstNode, this._lastNode);
	    }

	    return instance;
	  };

	  _proto._onInstancePlay = function _onInstancePlay(instance) {
	    this.fire('play', instance);

	    this._component.fire('play', this, instance);
	  };

	  _proto._onInstancePause = function _onInstancePause(instance) {
	    this.fire('pause', instance);

	    this._component.fire('pause', this, instance);
	  };

	  _proto._onInstanceResume = function _onInstanceResume(instance) {
	    this.fire('resume', instance);

	    this._component.fire('resume', this, instance);
	  };

	  _proto._onInstanceStop = function _onInstanceStop(instance) {
	    var idx = this.instances.indexOf(instance);

	    if (idx !== -1) {
	      this.instances.splice(idx, 1);
	    }

	    this.fire('stop', instance);

	    this._component.fire('stop', this, instance);
	  };

	  _proto._onInstanceEnd = function _onInstanceEnd(instance) {
	    var idx = this.instances.indexOf(instance);

	    if (idx !== -1) {
	      this.instances.splice(idx, 1);
	    }

	    this.fire('end', instance);

	    this._component.fire('end', this, instance);
	  };

	  _proto._onAssetAdd = function _onAssetAdd(asset) {
	    this.load();
	  };

	  _proto._onAssetLoad = function _onAssetLoad(asset) {
	    this.load();
	  };

	  _proto._onAssetRemoved = function _onAssetRemoved(asset) {
	    asset.off('remove', this._onAssetRemoved, this);

	    this._assets.off('add:' + asset.id, this._onAssetAdd, this);

	    this.stop();
	  };

	  _proto.updatePosition = function updatePosition(position) {
	    var instances = this.instances;

	    for (var i = 0, len = instances.length; i < len; i++) {
	      instances[i].position = position;
	    }
	  };

	  _createClass(SoundSlot, [{
	    key: "asset",
	    get: function get() {
	      return this._asset;
	    },
	    set: function set(value) {
	      var old = this._asset;

	      if (old) {
	        this._assets.off('add:' + old, this._onAssetAdd, this);

	        var oldAsset = this._assets.get(old);

	        if (oldAsset) {
	          oldAsset.off('remove', this._onAssetRemoved, this);
	        }
	      }

	      this._asset = value;

	      if (this._asset instanceof Asset) {
	        this._asset = this._asset.id;
	      }

	      if (this._hasAsset() && this._component.enabled && this._component.entity.enabled) {
	        this.load();
	      }
	    }
	  }, {
	    key: "autoPlay",
	    get: function get() {
	      return this._autoPlay;
	    },
	    set: function set(value) {
	      this._autoPlay = !!value;
	    }
	  }, {
	    key: "duration",
	    get: function get() {
	      var assetDuration = 0;

	      if (this._hasAsset()) {
	        var asset = this._assets.get(this._asset);

	        assetDuration = asset != null && asset.resource ? asset.resource.duration : 0;
	      }

	      if (this._duration != null) {
	        return this._duration % (assetDuration || 1);
	      }

	      return assetDuration;
	    },
	    set: function set(value) {
	      this._duration = Math.max(0, Number(value) || 0) || null;

	      if (!this._overlap) {
	        var instances = this.instances;

	        for (var i = 0, len = instances.length; i < len; i++) {
	          instances[i].duration = this._duration;
	        }
	      }
	    }
	  }, {
	    key: "isLoaded",
	    get: function get() {
	      if (this._hasAsset()) {
	        var asset = this._assets.get(this._asset);

	        if (asset) {
	          return !!asset.resource;
	        }
	      }

	      return false;
	    }
	  }, {
	    key: "isPaused",
	    get: function get() {
	      var instances = this.instances;
	      var len = instances.length;
	      if (len === 0) return false;

	      for (var i = 0; i < len; i++) {
	        if (!instances[i].isPaused) return false;
	      }

	      return true;
	    }
	  }, {
	    key: "isPlaying",
	    get: function get() {
	      var instances = this.instances;

	      for (var i = 0, len = instances.length; i < len; i++) {
	        if (instances[i].isPlaying) return true;
	      }

	      return false;
	    }
	  }, {
	    key: "isStopped",
	    get: function get() {
	      var instances = this.instances;

	      for (var i = 0, len = instances.length; i < len; i++) {
	        if (!instances[i].isStopped) return false;
	      }

	      return true;
	    }
	  }, {
	    key: "loop",
	    get: function get() {
	      return this._loop;
	    },
	    set: function set(value) {
	      this._loop = !!value;
	      var instances = this.instances;

	      for (var i = 0, len = instances.length; i < len; i++) {
	        instances[i].loop = this._loop;
	      }
	    }
	  }, {
	    key: "overlap",
	    get: function get() {
	      return this._overlap;
	    },
	    set: function set(value) {
	      this._overlap = !!value;
	    }
	  }, {
	    key: "pitch",
	    get: function get() {
	      return this._pitch;
	    },
	    set: function set(value) {
	      this._pitch = Math.max(Number(value) || 0, 0.01);

	      if (!this._overlap) {
	        var instances = this.instances;

	        for (var i = 0, len = instances.length; i < len; i++) {
	          instances[i].pitch = this.pitch * this._component.pitch;
	        }
	      }
	    }
	  }, {
	    key: "startTime",
	    get: function get() {
	      return this._startTime;
	    },
	    set: function set(value) {
	      this._startTime = Math.max(0, Number(value) || 0);

	      if (!this._overlap) {
	        var instances = this.instances;

	        for (var i = 0, len = instances.length; i < len; i++) {
	          instances[i].startTime = this._startTime;
	        }
	      }
	    }
	  }, {
	    key: "volume",
	    get: function get() {
	      return this._volume;
	    },
	    set: function set(value) {
	      this._volume = math.clamp(Number(value) || 0, 0, 1);

	      if (!this._overlap) {
	        var instances = this.instances;

	        for (var i = 0, len = instances.length; i < len; i++) {
	          instances[i].volume = this._volume * this._component.volume;
	        }
	      }
	    }
	  }]);

	  return SoundSlot;
	}(EventHandler);

	var SoundComponent = function (_Component) {
	  _inheritsLoose(SoundComponent, _Component);

	  function SoundComponent(system, entity) {
	    var _this;

	    _this = _Component.call(this, system, entity) || this;
	    _this._volume = 1;
	    _this._pitch = 1;
	    _this._positional = true;
	    _this._refDistance = 1;
	    _this._maxDistance = 10000;
	    _this._rollOffFactor = 1;
	    _this._distanceModel = DISTANCE_LINEAR;
	    _this._slots = {};
	    _this._playingBeforeDisable = {};
	    return _this;
	  }

	  var _proto = SoundComponent.prototype;

	  _proto._updateSoundInstances = function _updateSoundInstances(property, value, isFactor) {
	    var slots = this._slots;

	    for (var key in slots) {
	      var slot = slots[key];

	      if (!slot.overlap) {
	        var instances = slot.instances;

	        for (var i = 0, len = instances.length; i < len; i++) {
	          instances[i][property] = isFactor ? slot[property] * value : value;
	        }
	      }
	    }
	  };

	  _proto.onEnable = function onEnable() {
	    if (this.system._inTools) {
	      return;
	    }

	    var slots = this._slots;
	    var playingBeforeDisable = this._playingBeforeDisable;

	    for (var key in slots) {
	      var slot = slots[key];

	      if (slot.autoPlay && slot.isStopped) {
	        slot.play();
	      } else if (playingBeforeDisable[key]) {
	        slot.resume();
	      } else if (!slot.isLoaded) {
	        slot.load();
	      }
	    }
	  };

	  _proto.onDisable = function onDisable() {
	    var slots = this._slots;
	    var playingBeforeDisable = {};

	    for (var key in slots) {
	      if (!slots[key].overlap) {
	        if (slots[key].isPlaying) {
	          slots[key].pause();
	          playingBeforeDisable[key] = true;
	        }
	      }
	    }

	    this._playingBeforeDisable = playingBeforeDisable;
	  };

	  _proto.onRemove = function onRemove() {
	    this.off();
	  };

	  _proto.addSlot = function addSlot(name, options) {
	    var slots = this._slots;

	    if (slots[name]) {
	      return null;
	    }

	    var slot = new SoundSlot(this, name, options);
	    slots[name] = slot;

	    if (slot.autoPlay && this.enabled && this.entity.enabled) {
	      slot.play();
	    }

	    return slot;
	  };

	  _proto.removeSlot = function removeSlot(name) {
	    var slots = this._slots;

	    if (slots[name]) {
	      slots[name].stop();
	      delete slots[name];
	    }
	  };

	  _proto.slot = function slot(name) {
	    return this._slots[name];
	  };

	  _proto.play = function play(name) {
	    if (!this.enabled || !this.entity.enabled) {
	      return null;
	    }

	    var slot = this._slots[name];

	    if (!slot) {
	      return null;
	    }

	    return slot.play();
	  };

	  _proto.pause = function pause(name) {
	    var slots = this._slots;

	    if (name) {
	      var slot = slots[name];

	      if (!slot) {
	        return;
	      }

	      slot.pause();
	    } else {
	      for (var key in slots) {
	        slots[key].pause();
	      }
	    }
	  };

	  _proto.resume = function resume(name) {
	    var slots = this._slots;

	    if (name) {
	      var slot = slots[name];

	      if (!slot) {
	        return;
	      }

	      if (slot.isPaused) {
	        slot.resume();
	      }
	    } else {
	      for (var key in slots) {
	        slots[key].resume();
	      }
	    }
	  };

	  _proto.stop = function stop(name) {
	    var slots = this._slots;

	    if (name) {
	      var slot = slots[name];

	      if (!slot) {
	        return;
	      }

	      slot.stop();
	    } else {
	      for (var key in slots) {
	        slots[key].stop();
	      }
	    }
	  };

	  _createClass(SoundComponent, [{
	    key: "distanceModel",
	    get: function get() {
	      return this._distanceModel;
	    },
	    set: function set(value) {
	      this._distanceModel = value;

	      this._updateSoundInstances('distanceModel', value, false);
	    }
	  }, {
	    key: "maxDistance",
	    get: function get() {
	      return this._maxDistance;
	    },
	    set: function set(value) {
	      this._maxDistance = value;

	      this._updateSoundInstances('maxDistance', value, false);
	    }
	  }, {
	    key: "refDistance",
	    get: function get() {
	      return this._refDistance;
	    },
	    set: function set(value) {
	      this._refDistance = value;

	      this._updateSoundInstances('refDistance', value, false);
	    }
	  }, {
	    key: "rollOffFactor",
	    get: function get() {
	      return this._rollOffFactor;
	    },
	    set: function set(value) {
	      this._rollOffFactor = value;

	      this._updateSoundInstances('rollOffFactor', value, false);
	    }
	  }, {
	    key: "pitch",
	    get: function get() {
	      return this._pitch;
	    },
	    set: function set(value) {
	      this._pitch = value;

	      this._updateSoundInstances('pitch', value, true);
	    }
	  }, {
	    key: "volume",
	    get: function get() {
	      return this._volume;
	    },
	    set: function set(value) {
	      this._volume = value;

	      this._updateSoundInstances('volume', value, true);
	    }
	  }, {
	    key: "positional",
	    get: function get() {
	      return this._positional;
	    },
	    set: function set(newValue) {
	      this._positional = newValue;
	      var slots = this._slots;

	      for (var key in slots) {
	        var slot = slots[key];

	        if (!slot.overlap) {
	          var instances = slot.instances;
	          var oldLength = instances.length;

	          for (var i = oldLength - 1; i >= 0; i--) {
	            var isPlaying = instances[i].isPlaying || instances[i].isSuspended;
	            var currentTime = instances[i].currentTime;
	            if (isPlaying) instances[i].stop();

	            var instance = slot._createInstance();

	            if (isPlaying) {
	              instance.play();
	              instance.currentTime = currentTime;
	            }

	            instances.push(instance);
	          }
	        }
	      }
	    }
	  }, {
	    key: "slots",
	    get: function get() {
	      return this._slots;
	    },
	    set: function set(newValue) {
	      var oldValue = this._slots;

	      if (oldValue) {
	        for (var key in oldValue) {
	          oldValue[key].stop();
	        }
	      }

	      var slots = {};

	      for (var _key in newValue) {
	        if (!(newValue[_key] instanceof SoundSlot)) {
	          if (newValue[_key].name) {
	            slots[newValue[_key].name] = new SoundSlot(this, newValue[_key].name, newValue[_key]);
	          }
	        } else {
	          slots[newValue[_key].name] = newValue[_key];
	        }
	      }

	      this._slots = slots;
	      if (this.enabled && this.entity.enabled) this.onEnable();
	    }
	  }]);

	  return SoundComponent;
	}(Component);

	var SoundComponentData = function SoundComponentData() {
	  this.enabled = true;
	};

	var _schema$3 = ['enabled'];

	var SoundComponentSystem = function (_ComponentSystem) {
	  _inheritsLoose(SoundComponentSystem, _ComponentSystem);

	  function SoundComponentSystem(app) {
	    var _this;

	    _this = _ComponentSystem.call(this, app) || this;
	    _this.id = 'sound';
	    _this.ComponentType = SoundComponent;
	    _this.DataType = SoundComponentData;
	    _this.schema = _schema$3;
	    _this.manager = app.soundManager;

	    _this.app.systems.on('update', _this.onUpdate, _assertThisInitialized(_this));

	    _this.on('beforeremove', _this.onBeforeRemove, _assertThisInitialized(_this));

	    return _this;
	  }

	  var _proto = SoundComponentSystem.prototype;

	  _proto.initializeComponentData = function initializeComponentData(component, data, properties) {
	    properties = ['volume', 'pitch', 'positional', 'refDistance', 'maxDistance', 'rollOffFactor', 'distanceModel', 'slots'];

	    for (var i = 0; i < properties.length; i++) {
	      if (data.hasOwnProperty(properties[i])) {
	        component[properties[i]] = data[properties[i]];
	      }
	    }

	    _ComponentSystem.prototype.initializeComponentData.call(this, component, data, ['enabled']);
	  };

	  _proto.cloneComponent = function cloneComponent(entity, clone) {
	    var srcComponent = entity.sound;
	    var srcSlots = srcComponent.slots;
	    var slots = {};

	    for (var key in srcSlots) {
	      var srcSlot = srcSlots[key];
	      slots[key] = {
	        name: srcSlot.name,
	        volume: srcSlot.volume,
	        pitch: srcSlot.pitch,
	        loop: srcSlot.loop,
	        duration: srcSlot.duration,
	        startTime: srcSlot.startTime,
	        overlap: srcSlot.overlap,
	        autoPlay: srcSlot.autoPlay,
	        asset: srcSlot.asset
	      };
	    }

	    var cloneData = {
	      distanceModel: srcComponent.distanceModel,
	      enabled: srcComponent.enabled,
	      maxDistance: srcComponent.maxDistance,
	      pitch: srcComponent.pitch,
	      positional: srcComponent.positional,
	      refDistance: srcComponent.refDistance,
	      rollOffFactor: srcComponent.rollOffFactor,
	      slots: slots,
	      volume: srcComponent.volume
	    };
	    return this.addComponent(clone, cloneData);
	  };

	  _proto.onUpdate = function onUpdate(dt) {
	    var store = this.store;

	    for (var id in store) {
	      if (store.hasOwnProperty(id)) {
	        var item = store[id];
	        var entity = item.entity;

	        if (entity.enabled) {
	          var component = entity.sound;

	          if (component.enabled && component.positional) {
	            var position = entity.getPosition();
	            var slots = component.slots;

	            for (var key in slots) {
	              slots[key].updatePosition(position);
	            }
	          }
	        }
	      }
	    }
	  };

	  _proto.onBeforeRemove = function onBeforeRemove(entity, component) {
	    var slots = component.slots;

	    for (var key in slots) {
	      if (!slots[key].overlap) {
	        slots[key].stop();
	      }
	    }

	    component.onRemove();
	  };

	  _proto.destroy = function destroy() {
	    _ComponentSystem.prototype.destroy.call(this);

	    this.app.systems.off('update', this.onUpdate, this);
	  };

	  _createClass(SoundComponentSystem, [{
	    key: "volume",
	    get: function get() {
	      return this.manager.volume;
	    },
	    set: function set(volume) {
	      this.manager.volume = volume;
	    }
	  }, {
	    key: "context",
	    get: function get() {
	      if (!hasAudioContext()) {
	        return null;
	      }

	      return this.manager.context;
	    }
	  }]);

	  return SoundComponentSystem;
	}(ComponentSystem);

	Component._buildAccessors(SoundComponent.prototype, _schema$3);

	var SPRITETYPE_SIMPLE = 'simple';
	var SPRITETYPE_ANIMATED = 'animated';

	var SpriteAnimationClip = function (_EventHandler) {
	  _inheritsLoose(SpriteAnimationClip, _EventHandler);

	  function SpriteAnimationClip(component, data) {
	    var _this;

	    _this = _EventHandler.call(this) || this;
	    _this._component = component;
	    _this._frame = 0;
	    _this._sprite = null;
	    _this._spriteAsset = null;
	    _this.spriteAsset = data.spriteAsset;
	    _this.name = data.name;
	    _this.fps = data.fps || 0;
	    _this.loop = data.loop || false;
	    _this._playing = false;
	    _this._paused = false;
	    _this._time = 0;
	    return _this;
	  }

	  var _proto = SpriteAnimationClip.prototype;

	  _proto._onSpriteAssetAdded = function _onSpriteAssetAdded(asset) {
	    this._component.system.app.assets.off('add:' + asset.id, this._onSpriteAssetAdded, this);

	    if (this._spriteAsset === asset.id) {
	      this._bindSpriteAsset(asset);
	    }
	  };

	  _proto._bindSpriteAsset = function _bindSpriteAsset(asset) {
	    asset.on('load', this._onSpriteAssetLoad, this);
	    asset.on('remove', this._onSpriteAssetRemove, this);

	    if (asset.resource) {
	      this._onSpriteAssetLoad(asset);
	    } else {
	      this._component.system.app.assets.load(asset);
	    }
	  };

	  _proto._unbindSpriteAsset = function _unbindSpriteAsset(asset) {
	    asset.off('load', this._onSpriteAssetLoad, this);
	    asset.off('remove', this._onSpriteAssetRemove, this);

	    if (asset.resource && asset.resource.atlas) {
	      this._component.system.app.assets.off('load:' + asset.data.textureAtlasAsset, this._onTextureAtlasLoad, this);
	    }
	  };

	  _proto._onSpriteAssetLoad = function _onSpriteAssetLoad(asset) {
	    if (!asset.resource) {
	      this.sprite = null;
	    } else {
	      if (!asset.resource.atlas) {
	        var atlasAssetId = asset.data.textureAtlasAsset;
	        var assets = this._component.system.app.assets;
	        assets.off('load:' + atlasAssetId, this._onTextureAtlasLoad, this);
	        assets.once('load:' + atlasAssetId, this._onTextureAtlasLoad, this);
	      } else {
	        this.sprite = asset.resource;
	      }
	    }
	  };

	  _proto._onTextureAtlasLoad = function _onTextureAtlasLoad(atlasAsset) {
	    var spriteAsset = this._spriteAsset;

	    if (spriteAsset instanceof Asset) {
	      this._onSpriteAssetLoad(spriteAsset);
	    } else {
	      this._onSpriteAssetLoad(this._component.system.app.assets.get(spriteAsset));
	    }
	  };

	  _proto._onSpriteAssetRemove = function _onSpriteAssetRemove(asset) {
	    this.sprite = null;
	  };

	  _proto._onSpriteMeshesChange = function _onSpriteMeshesChange() {
	    if (this._component.currentClip === this) {
	      this._component._showFrame(this.frame);
	    }
	  };

	  _proto._onSpritePpuChanged = function _onSpritePpuChanged() {
	    if (this._component.currentClip === this) {
	      if (this.sprite.renderMode !== SPRITE_RENDERMODE_SIMPLE) {
	        this._component._showFrame(this.frame);
	      }
	    }
	  };

	  _proto._update = function _update(dt) {
	    if (this.fps === 0) return;
	    if (!this._playing || this._paused || !this._sprite) return;
	    var dir = this.fps < 0 ? -1 : 1;
	    var time = this._time + dt * this._component.speed * dir;
	    var duration = this.duration;
	    var end = time > duration || time < 0;

	    this._setTime(time);

	    var frame = this.frame;

	    if (this._sprite) {
	      frame = Math.floor(this._sprite.frameKeys.length * this._time / duration);
	    } else {
	      frame = 0;
	    }

	    if (frame !== this._frame) {
	      this._setFrame(frame);
	    }

	    if (end) {
	      if (this.loop) {
	        this.fire('loop');

	        this._component.fire('loop', this);
	      } else {
	        this._playing = false;
	        this._paused = false;
	        this.fire('end');

	        this._component.fire('end', this);
	      }
	    }
	  };

	  _proto._setTime = function _setTime(value) {
	    this._time = value;
	    var duration = this.duration;

	    if (this._time < 0) {
	      if (this.loop) {
	        this._time = this._time % duration + duration;
	      } else {
	        this._time = 0;
	      }
	    } else if (this._time > duration) {
	      if (this.loop) {
	        this._time %= duration;
	      } else {
	        this._time = duration;
	      }
	    }
	  };

	  _proto._setFrame = function _setFrame(value) {
	    if (this._sprite) {
	      this._frame = math.clamp(value, 0, this._sprite.frameKeys.length - 1);
	    } else {
	      this._frame = value;
	    }

	    if (this._component.currentClip === this) {
	      this._component._showFrame(this._frame);
	    }
	  };

	  _proto._destroy = function _destroy() {
	    if (this._sprite) {
	      this.sprite = null;
	    }

	    if (this._spriteAsset) {
	      this.spriteAsset = null;
	    }
	  };

	  _proto.play = function play() {
	    if (this._playing) return;
	    this._playing = true;
	    this._paused = false;
	    this.frame = 0;
	    this.fire('play');

	    this._component.fire('play', this);
	  };

	  _proto.pause = function pause() {
	    if (!this._playing || this._paused) return;
	    this._paused = true;
	    this.fire('pause');

	    this._component.fire('pause', this);
	  };

	  _proto.resume = function resume() {
	    if (!this._paused) return;
	    this._paused = false;
	    this.fire('resume');

	    this._component.fire('resume', this);
	  };

	  _proto.stop = function stop() {
	    if (!this._playing) return;
	    this._playing = false;
	    this._paused = false;
	    this._time = 0;
	    this.frame = 0;
	    this.fire('stop');

	    this._component.fire('stop', this);
	  };

	  _createClass(SpriteAnimationClip, [{
	    key: "duration",
	    get: function get() {
	      if (this._sprite) {
	        var fps = this.fps || Number.MIN_VALUE;
	        return this._sprite.frameKeys.length / Math.abs(fps);
	      }

	      return 0;
	    }
	  }, {
	    key: "frame",
	    get: function get() {
	      return this._frame;
	    },
	    set: function set(value) {
	      this._setFrame(value);

	      var fps = this.fps || Number.MIN_VALUE;

	      this._setTime(this._frame / fps);
	    }
	  }, {
	    key: "isPaused",
	    get: function get() {
	      return this._paused;
	    }
	  }, {
	    key: "isPlaying",
	    get: function get() {
	      return this._playing;
	    }
	  }, {
	    key: "sprite",
	    get: function get() {
	      return this._sprite;
	    },
	    set: function set(value) {
	      if (this._sprite) {
	        this._sprite.off('set:meshes', this._onSpriteMeshesChange, this);

	        this._sprite.off('set:pixelsPerUnit', this._onSpritePpuChanged, this);

	        this._sprite.off('set:atlas', this._onSpriteMeshesChange, this);

	        if (this._sprite.atlas) {
	          this._sprite.atlas.off('set:texture', this._onSpriteMeshesChange, this);
	        }
	      }

	      this._sprite = value;

	      if (this._sprite) {
	        this._sprite.on('set:meshes', this._onSpriteMeshesChange, this);

	        this._sprite.on('set:pixelsPerUnit', this._onSpritePpuChanged, this);

	        this._sprite.on('set:atlas', this._onSpriteMeshesChange, this);

	        if (this._sprite.atlas) {
	          this._sprite.atlas.on('set:texture', this._onSpriteMeshesChange, this);
	        }
	      }

	      if (this._component.currentClip === this) {
	        var mi;

	        if (!value || !value.atlas) {
	          mi = this._component._meshInstance;

	          if (mi) {
	            mi.deleteParameter('texture_emissiveMap');
	            mi.deleteParameter('texture_opacityMap');
	          }

	          this._component._hideModel();
	        } else {
	          if (value.atlas.texture) {
	            mi = this._component._meshInstance;

	            if (mi) {
	              mi.setParameter('texture_emissiveMap', value.atlas.texture);
	              mi.setParameter('texture_opacityMap', value.atlas.texture);
	            }

	            if (this._component.enabled && this._component.entity.enabled) {
	              this._component._showModel();
	            }
	          }

	          if (this.time && this.fps) {
	            this.time = this.time;
	          } else {
	            this.frame = this.frame;
	          }
	        }
	      }
	    }
	  }, {
	    key: "spriteAsset",
	    get: function get() {
	      return this._spriteAsset;
	    },
	    set: function set(value) {
	      var assets = this._component.system.app.assets;
	      var id = value;

	      if (value instanceof Asset) {
	        id = value.id;
	      }

	      if (this._spriteAsset !== id) {
	        if (this._spriteAsset) {
	          var prev = assets.get(this._spriteAsset);

	          if (prev) {
	            this._unbindSpriteAsset(prev);
	          }
	        }

	        this._spriteAsset = id;

	        if (this._spriteAsset) {
	          var asset = assets.get(this._spriteAsset);

	          if (!asset) {
	            this.sprite = null;
	            assets.on('add:' + this._spriteAsset, this._onSpriteAssetAdded, this);
	          } else {
	            this._bindSpriteAsset(asset);
	          }
	        } else {
	          this.sprite = null;
	        }
	      }
	    }
	  }, {
	    key: "time",
	    get: function get() {
	      return this._time;
	    },
	    set: function set(value) {
	      this._setTime(value);

	      if (this._sprite) {
	        this.frame = Math.min(this._sprite.frameKeys.length - 1, Math.floor(this._time * Math.abs(this.fps)));
	      } else {
	        this.frame = 0;
	      }
	    }
	  }]);

	  return SpriteAnimationClip;
	}(EventHandler);

	var PARAM_EMISSIVE_MAP = 'texture_emissiveMap';
	var PARAM_OPACITY_MAP = 'texture_opacityMap';
	var PARAM_EMISSIVE = 'material_emissive';
	var PARAM_OPACITY = 'material_opacity';
	var PARAM_INNER_OFFSET = 'innerOffset';
	var PARAM_OUTER_SCALE = 'outerScale';
	var PARAM_ATLAS_RECT = 'atlasRect';

	var SpriteComponent = function (_Component) {
	  _inheritsLoose(SpriteComponent, _Component);

	  function SpriteComponent(system, entity) {
	    var _this;

	    _this = _Component.call(this, system, entity) || this;
	    _this._type = SPRITETYPE_SIMPLE;
	    _this._material = system.defaultMaterial;
	    _this._color = new Color(1, 1, 1, 1);
	    _this._colorUniform = new Float32Array(3);
	    _this._speed = 1;
	    _this._flipX = false;
	    _this._flipY = false;
	    _this._width = 1;
	    _this._height = 1;
	    _this._drawOrder = 0;
	    _this._layers = [LAYERID_WORLD];
	    _this._outerScale = new Vec2(1, 1);
	    _this._outerScaleUniform = new Float32Array(2);
	    _this._innerOffset = new Vec4();
	    _this._innerOffsetUniform = new Float32Array(4);
	    _this._atlasRect = new Vec4();
	    _this._atlasRectUniform = new Float32Array(4);
	    _this._batchGroupId = -1;
	    _this._batchGroup = null;
	    _this._node = new GraphNode();
	    _this._model = new Model();
	    _this._model.graph = _this._node;
	    _this._meshInstance = null;
	    entity.addChild(_this._model.graph);
	    _this._model._entity = entity;
	    _this._updateAabbFunc = _this._updateAabb.bind(_assertThisInitialized(_this));
	    _this._addedModel = false;
	    _this._autoPlayClip = null;
	    _this._clips = {};
	    _this._defaultClip = new SpriteAnimationClip(_assertThisInitialized(_this), {
	      name: _this.entity.name,
	      fps: 0,
	      loop: false,
	      spriteAsset: null
	    });
	    _this._currentClip = _this._defaultClip;
	    return _this;
	  }

	  var _proto = SpriteComponent.prototype;

	  _proto.onEnable = function onEnable() {
	    var app = this.system.app;
	    var scene = app.scene;
	    scene.on('set:layers', this._onLayersChanged, this);

	    if (scene.layers) {
	      scene.layers.on('add', this._onLayerAdded, this);
	      scene.layers.on('remove', this._onLayerRemoved, this);
	    }

	    this._showModel();

	    if (this._autoPlayClip) this._tryAutoPlay();

	    if (this._batchGroupId >= 0) {
	      var _app$batcher;

	      (_app$batcher = app.batcher) == null ? void 0 : _app$batcher.insert(BatchGroup.SPRITE, this._batchGroupId, this.entity);
	    }
	  };

	  _proto.onDisable = function onDisable() {
	    var app = this.system.app;
	    var scene = app.scene;
	    scene.off('set:layers', this._onLayersChanged, this);

	    if (scene.layers) {
	      scene.layers.off('add', this._onLayerAdded, this);
	      scene.layers.off('remove', this._onLayerRemoved, this);
	    }

	    this.stop();

	    this._hideModel();

	    if (this._batchGroupId >= 0) {
	      var _app$batcher2;

	      (_app$batcher2 = app.batcher) == null ? void 0 : _app$batcher2.remove(BatchGroup.SPRITE, this._batchGroupId, this.entity);
	    }
	  };

	  _proto.onDestroy = function onDestroy() {
	    this._currentClip = null;

	    if (this._defaultClip) {
	      this._defaultClip._destroy();

	      this._defaultClip = null;
	    }

	    for (var key in this._clips) {
	      this._clips[key]._destroy();
	    }

	    this._clips = null;

	    this._hideModel();

	    this._model = null;

	    if (this._node) {
	      if (this._node.parent) this._node.parent.removeChild(this._node);
	      this._node = null;
	    }

	    if (this._meshInstance) {
	      this._meshInstance.material = null;
	      this._meshInstance.mesh = null;
	      this._meshInstance = null;
	    }
	  };

	  _proto._showModel = function _showModel() {
	    if (this._addedModel) return;
	    if (!this._meshInstance) return;
	    var meshInstances = [this._meshInstance];

	    for (var i = 0, len = this._layers.length; i < len; i++) {
	      var layer = this.system.app.scene.layers.getLayerById(this._layers[i]);

	      if (layer) {
	        layer.addMeshInstances(meshInstances);
	      }
	    }

	    this._addedModel = true;
	  };

	  _proto._hideModel = function _hideModel() {
	    if (!this._addedModel || !this._meshInstance) return;
	    var meshInstances = [this._meshInstance];

	    for (var i = 0, len = this._layers.length; i < len; i++) {
	      var layer = this.system.app.scene.layers.getLayerById(this._layers[i]);

	      if (layer) {
	        layer.removeMeshInstances(meshInstances);
	      }
	    }

	    this._addedModel = false;
	  };

	  _proto._showFrame = function _showFrame(frame) {
	    if (!this.sprite) return;
	    var mesh = this.sprite.meshes[frame];

	    if (!mesh) {
	      if (this._meshInstance) {
	        this._meshInstance.mesh = null;
	        this._meshInstance.visible = false;
	      }

	      return;
	    }

	    var material;

	    if (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED) {
	      material = this.system.default9SlicedMaterialSlicedMode;
	    } else if (this.sprite.renderMode === SPRITE_RENDERMODE_TILED) {
	      material = this.system.default9SlicedMaterialTiledMode;
	    } else {
	      material = this.system.defaultMaterial;
	    }

	    if (!this._meshInstance) {
	      this._meshInstance = new MeshInstance(mesh, this._material, this._node);
	      this._meshInstance.castShadow = false;
	      this._meshInstance.receiveShadow = false;
	      this._meshInstance.drawOrder = this._drawOrder;

	      this._model.meshInstances.push(this._meshInstance);

	      this._colorUniform[0] = this._color.r;
	      this._colorUniform[1] = this._color.g;
	      this._colorUniform[2] = this._color.b;

	      this._meshInstance.setParameter(PARAM_EMISSIVE, this._colorUniform);

	      this._meshInstance.setParameter(PARAM_OPACITY, this._color.a);

	      if (this.enabled && this.entity.enabled) {
	        this._showModel();
	      }
	    }

	    if (this._meshInstance.material !== material) {
	      this._meshInstance.material = material;
	    }

	    if (this._meshInstance.mesh !== mesh) {
	      this._meshInstance.mesh = mesh;
	      this._meshInstance.visible = true;
	      this._meshInstance._aabbVer = -1;
	    }

	    if (this.sprite.atlas && this.sprite.atlas.texture) {
	      this._meshInstance.setParameter(PARAM_EMISSIVE_MAP, this.sprite.atlas.texture);

	      this._meshInstance.setParameter(PARAM_OPACITY_MAP, this.sprite.atlas.texture);
	    } else {
	      this._meshInstance.deleteParameter(PARAM_EMISSIVE_MAP);

	      this._meshInstance.deleteParameter(PARAM_OPACITY_MAP);
	    }

	    if (this.sprite.atlas && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED)) {
	      this._meshInstance._updateAabbFunc = this._updateAabbFunc;
	      var frameData = this.sprite.atlas.frames[this.sprite.frameKeys[frame]];

	      if (frameData) {
	        var borderWidthScale = 2 / frameData.rect.z;
	        var borderHeightScale = 2 / frameData.rect.w;

	        this._innerOffset.set(frameData.border.x * borderWidthScale, frameData.border.y * borderHeightScale, frameData.border.z * borderWidthScale, frameData.border.w * borderHeightScale);

	        var tex = this.sprite.atlas.texture;

	        this._atlasRect.set(frameData.rect.x / tex.width, frameData.rect.y / tex.height, frameData.rect.z / tex.width, frameData.rect.w / tex.height);
	      } else {
	        this._innerOffset.set(0, 0, 0, 0);
	      }

	      this._innerOffsetUniform[0] = this._innerOffset.x;
	      this._innerOffsetUniform[1] = this._innerOffset.y;
	      this._innerOffsetUniform[2] = this._innerOffset.z;
	      this._innerOffsetUniform[3] = this._innerOffset.w;

	      this._meshInstance.setParameter(PARAM_INNER_OFFSET, this._innerOffsetUniform);

	      this._atlasRectUniform[0] = this._atlasRect.x;
	      this._atlasRectUniform[1] = this._atlasRect.y;
	      this._atlasRectUniform[2] = this._atlasRect.z;
	      this._atlasRectUniform[3] = this._atlasRect.w;

	      this._meshInstance.setParameter(PARAM_ATLAS_RECT, this._atlasRectUniform);
	    } else {
	      this._meshInstance._updateAabbFunc = null;
	    }

	    this._updateTransform();
	  };

	  _proto._updateTransform = function _updateTransform() {
	    var scaleX = this.flipX ? -1 : 1;
	    var scaleY = this.flipY ? -1 : 1;
	    var posX = 0;
	    var posY = 0;

	    if (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED)) {
	      var w = 1;
	      var h = 1;

	      if (this.sprite.atlas) {
	        var frameData = this.sprite.atlas.frames[this.sprite.frameKeys[this.frame]];

	        if (frameData) {
	          w = frameData.rect.z;
	          h = frameData.rect.w;
	          posX = (0.5 - frameData.pivot.x) * this._width;
	          posY = (0.5 - frameData.pivot.y) * this._height;
	        }
	      }

	      var scaleMulX = w / this.sprite.pixelsPerUnit;
	      var scaleMulY = h / this.sprite.pixelsPerUnit;

	      this._outerScale.set(Math.max(this._width, this._innerOffset.x * scaleMulX), Math.max(this._height, this._innerOffset.y * scaleMulY));

	      scaleX *= scaleMulX;
	      scaleY *= scaleMulY;
	      this._outerScale.x /= scaleMulX;
	      this._outerScale.y /= scaleMulY;
	      scaleX *= math.clamp(this._width / (this._innerOffset.x * scaleMulX), 0.0001, 1);
	      scaleY *= math.clamp(this._height / (this._innerOffset.y * scaleMulY), 0.0001, 1);

	      if (this._meshInstance) {
	        this._outerScaleUniform[0] = this._outerScale.x;
	        this._outerScaleUniform[1] = this._outerScale.y;

	        this._meshInstance.setParameter(PARAM_OUTER_SCALE, this._outerScaleUniform);
	      }
	    }

	    this._node.setLocalScale(scaleX, scaleY, 1);

	    this._node.setLocalPosition(posX, posY, 0);
	  };

	  _proto._updateAabb = function _updateAabb(aabb) {
	    aabb.center.set(0, 0, 0);
	    aabb.halfExtents.set(this._outerScale.x * 0.5, this._outerScale.y * 0.5, 0.001);
	    aabb.setFromTransformedAabb(aabb, this._node.getWorldTransform());
	    return aabb;
	  };

	  _proto._tryAutoPlay = function _tryAutoPlay() {
	    if (!this._autoPlayClip) return;
	    if (this.type !== SPRITETYPE_ANIMATED) return;
	    var clip = this._clips[this._autoPlayClip];

	    if (clip && !clip.isPlaying && (!this._currentClip || !this._currentClip.isPlaying)) {
	      if (this.enabled && this.entity.enabled) {
	        this.play(clip.name);
	      }
	    }
	  };

	  _proto._onLayersChanged = function _onLayersChanged(oldComp, newComp) {
	    oldComp.off('add', this.onLayerAdded, this);
	    oldComp.off('remove', this.onLayerRemoved, this);
	    newComp.on('add', this.onLayerAdded, this);
	    newComp.on('remove', this.onLayerRemoved, this);

	    if (this.enabled && this.entity.enabled) {
	      this._showModel();
	    }
	  };

	  _proto._onLayerAdded = function _onLayerAdded(layer) {
	    var index = this.layers.indexOf(layer.id);
	    if (index < 0) return;

	    if (this._addedModel && this.enabled && this.entity.enabled && this._meshInstance) {
	      layer.addMeshInstances([this._meshInstance]);
	    }
	  };

	  _proto._onLayerRemoved = function _onLayerRemoved(layer) {
	    if (!this._meshInstance) return;
	    var index = this.layers.indexOf(layer.id);
	    if (index < 0) return;
	    layer.removeMeshInstances([this._meshInstance]);
	  };

	  _proto.removeModelFromLayers = function removeModelFromLayers() {
	    for (var i = 0; i < this.layers.length; i++) {
	      var layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
	      if (!layer) continue;
	      layer.removeMeshInstances([this._meshInstance]);
	    }
	  };

	  _proto.addClip = function addClip(data) {
	    var clip = new SpriteAnimationClip(this, {
	      name: data.name,
	      fps: data.fps,
	      loop: data.loop,
	      spriteAsset: data.spriteAsset
	    });
	    this._clips[data.name] = clip;
	    if (clip.name && clip.name === this._autoPlayClip) this._tryAutoPlay();
	    return clip;
	  };

	  _proto.removeClip = function removeClip(name) {
	    delete this._clips[name];
	  };

	  _proto.clip = function clip(name) {
	    return this._clips[name];
	  };

	  _proto.play = function play(name) {
	    var clip = this._clips[name];
	    var current = this._currentClip;

	    if (current && current !== clip) {
	      current._playing = false;
	    }

	    this._currentClip = clip;

	    if (this._currentClip) {
	      this._currentClip = clip;

	      this._currentClip.play();
	    }

	    return clip;
	  };

	  _proto.pause = function pause() {
	    if (this._currentClip === this._defaultClip) return;

	    if (this._currentClip.isPlaying) {
	      this._currentClip.pause();
	    }
	  };

	  _proto.resume = function resume() {
	    if (this._currentClip === this._defaultClip) return;

	    if (this._currentClip.isPaused) {
	      this._currentClip.resume();
	    }
	  };

	  _proto.stop = function stop() {
	    if (this._currentClip === this._defaultClip) return;

	    this._currentClip.stop();
	  };

	  _createClass(SpriteComponent, [{
	    key: "type",
	    get: function get() {
	      return this._type;
	    },
	    set: function set(value) {
	      if (this._type === value) return;
	      this._type = value;

	      if (this._type === SPRITETYPE_SIMPLE) {
	        this.stop();
	        this._currentClip = this._defaultClip;

	        if (this.enabled && this.entity.enabled) {
	          this._currentClip.frame = this.frame;

	          if (this._currentClip.sprite) {
	            this._showModel();
	          } else {
	            this._hideModel();
	          }
	        }
	      } else if (this._type === SPRITETYPE_ANIMATED) {
	        this.stop();

	        if (this._autoPlayClip) {
	          this._tryAutoPlay();
	        }

	        if (this._currentClip && this._currentClip.isPlaying && this.enabled && this.entity.enabled) {
	          this._showModel();
	        } else {
	          this._hideModel();
	        }
	      }
	    }
	  }, {
	    key: "frame",
	    get: function get() {
	      return this._currentClip.frame;
	    },
	    set: function set(value) {
	      this._currentClip.frame = value;
	    }
	  }, {
	    key: "spriteAsset",
	    get: function get() {
	      return this._defaultClip._spriteAsset;
	    },
	    set: function set(value) {
	      this._defaultClip.spriteAsset = value;
	    }
	  }, {
	    key: "sprite",
	    get: function get() {
	      return this._currentClip.sprite;
	    },
	    set: function set(value) {
	      this._currentClip.sprite = value;
	    }
	  }, {
	    key: "material",
	    get: function get() {
	      return this._material;
	    },
	    set: function set(value) {
	      this._material = value;

	      if (this._meshInstance) {
	        this._meshInstance.material = value;
	      }
	    }
	  }, {
	    key: "color",
	    get: function get() {
	      return this._color;
	    },
	    set: function set(value) {
	      this._color.r = value.r;
	      this._color.g = value.g;
	      this._color.b = value.b;

	      if (this._meshInstance) {
	        this._colorUniform[0] = this._color.r;
	        this._colorUniform[1] = this._color.g;
	        this._colorUniform[2] = this._color.b;

	        this._meshInstance.setParameter(PARAM_EMISSIVE, this._colorUniform);
	      }
	    }
	  }, {
	    key: "opacity",
	    get: function get() {
	      return this._color.a;
	    },
	    set: function set(value) {
	      this._color.a = value;

	      if (this._meshInstance) {
	        this._meshInstance.setParameter(PARAM_OPACITY, value);
	      }
	    }
	  }, {
	    key: "clips",
	    get: function get() {
	      return this._clips;
	    },
	    set: function set(value) {
	      if (!value) {
	        for (var name in this._clips) {
	          this.removeClip(name);
	        }

	        return;
	      }

	      for (var _name in this._clips) {
	        var found = false;

	        for (var key in value) {
	          if (value[key].name === _name) {
	            found = true;
	            this._clips[_name].fps = value[key].fps;
	            this._clips[_name].loop = value[key].loop;

	            if (value[key].hasOwnProperty('sprite')) {
	              this._clips[_name].sprite = value[key].sprite;
	            } else if (value[key].hasOwnProperty('spriteAsset')) {
	              this._clips[_name].spriteAsset = value[key].spriteAsset;
	            }

	            break;
	          }
	        }

	        if (!found) {
	          this.removeClip(_name);
	        }
	      }

	      for (var _key in value) {
	        if (this._clips[value[_key].name]) continue;
	        this.addClip(value[_key]);
	      }

	      if (this._autoPlayClip) {
	        this._tryAutoPlay();
	      }

	      if (!this._currentClip || !this._currentClip.sprite) {
	        this._hideModel();
	      }
	    }
	  }, {
	    key: "currentClip",
	    get: function get() {
	      return this._currentClip;
	    }
	  }, {
	    key: "speed",
	    get: function get() {
	      return this._speed;
	    },
	    set: function set(value) {
	      this._speed = value;
	    }
	  }, {
	    key: "flipX",
	    get: function get() {
	      return this._flipX;
	    },
	    set: function set(value) {
	      if (this._flipX === value) return;
	      this._flipX = value;

	      this._updateTransform();
	    }
	  }, {
	    key: "flipY",
	    get: function get() {
	      return this._flipY;
	    },
	    set: function set(value) {
	      if (this._flipY === value) return;
	      this._flipY = value;

	      this._updateTransform();
	    }
	  }, {
	    key: "width",
	    get: function get() {
	      return this._width;
	    },
	    set: function set(value) {
	      if (value === this._width) return;
	      this._width = value;
	      this._outerScale.x = this._width;

	      if (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_TILED || this.sprite.renderMode === SPRITE_RENDERMODE_SLICED)) {
	        this._updateTransform();
	      }
	    }
	  }, {
	    key: "height",
	    get: function get() {
	      return this._height;
	    },
	    set: function set(value) {
	      if (value === this._height) return;
	      this._height = value;
	      this._outerScale.y = this.height;

	      if (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_TILED || this.sprite.renderMode === SPRITE_RENDERMODE_SLICED)) {
	        this._updateTransform();
	      }
	    }
	  }, {
	    key: "batchGroupId",
	    get: function get() {
	      return this._batchGroupId;
	    },
	    set: function set(value) {
	      if (this._batchGroupId === value) return;
	      var prev = this._batchGroupId;
	      this._batchGroupId = value;

	      if (this.entity.enabled && prev >= 0) {
	        var _this$system$app$batc;

	        (_this$system$app$batc = this.system.app.batcher) == null ? void 0 : _this$system$app$batc.remove(BatchGroup.SPRITE, prev, this.entity);
	      }

	      if (this.entity.enabled && value >= 0) {
	        var _this$system$app$batc2;

	        (_this$system$app$batc2 = this.system.app.batcher) == null ? void 0 : _this$system$app$batc2.insert(BatchGroup.SPRITE, value, this.entity);
	      } else {
	        if (prev >= 0) {
	          if (this._currentClip && this._currentClip.sprite && this.enabled && this.entity.enabled) {
	            this._showModel();
	          }
	        }
	      }
	    }
	  }, {
	    key: "autoPlayClip",
	    get: function get() {
	      return this._autoPlayClip;
	    },
	    set: function set(value) {
	      this._autoPlayClip = value instanceof SpriteAnimationClip ? value.name : value;

	      this._tryAutoPlay();
	    }
	  }, {
	    key: "drawOrder",
	    get: function get() {
	      return this._drawOrder;
	    },
	    set: function set(value) {
	      this._drawOrder = value;

	      if (this._meshInstance) {
	        this._meshInstance.drawOrder = value;
	      }
	    }
	  }, {
	    key: "layers",
	    get: function get() {
	      return this._layers;
	    },
	    set: function set(value) {
	      if (this._addedModel) {
	        this._hideModel();
	      }

	      this._layers = value;

	      if (!this._meshInstance) {
	        return;
	      }

	      if (this.enabled && this.entity.enabled) {
	        this._showModel();
	      }
	    }
	  }, {
	    key: "aabb",
	    get: function get() {
	      if (this._meshInstance) {
	        return this._meshInstance.aabb;
	      }

	      return null;
	    }
	  }]);

	  return SpriteComponent;
	}(Component);

	var SpriteComponentData = function SpriteComponentData() {
	  this.enabled = true;
	};

	var _schema$2 = ['enabled'];

	var SpriteComponentSystem = function (_ComponentSystem) {
	  _inheritsLoose(SpriteComponentSystem, _ComponentSystem);

	  function SpriteComponentSystem(app) {
	    var _this;

	    _this = _ComponentSystem.call(this, app) || this;
	    _this.id = 'sprite';
	    _this.ComponentType = SpriteComponent;
	    _this.DataType = SpriteComponentData;
	    _this.schema = _schema$2;
	    _this._defaultTexture = null;
	    _this._defaultMaterial = null;
	    _this._default9SlicedMaterialSlicedMode = null;
	    _this._default9SlicedMaterialTiledMode = null;

	    _this.app.systems.on('update', _this.onUpdate, _assertThisInitialized(_this));

	    _this.on('beforeremove', _this.onBeforeRemove, _assertThisInitialized(_this));

	    return _this;
	  }

	  var _proto = SpriteComponentSystem.prototype;

	  _proto.destroy = function destroy() {
	    _ComponentSystem.prototype.destroy.call(this);

	    this.app.systems.off('update', this.onUpdate, this);

	    if (this._defaultTexture) {
	      this._defaultTexture.destroy();

	      this._defaultTexture = null;
	    }
	  };

	  _proto.initializeComponentData = function initializeComponentData(component, data, properties) {
	    if (data.enabled !== undefined) {
	      component.enabled = data.enabled;
	    }

	    component.type = data.type;

	    if (data.layers && Array.isArray(data.layers)) {
	      component.layers = data.layers.slice(0);
	    }

	    if (data.drawOrder !== undefined) {
	      component.drawOrder = data.drawOrder;
	    }

	    if (data.color !== undefined) {
	      if (data.color instanceof Color) {
	        component.color.set(data.color.r, data.color.g, data.color.b, data.opacity !== undefined ? data.opacity : 1);
	      } else {
	        component.color.set(data.color[0], data.color[1], data.color[2], data.opacity !== undefined ? data.opacity : 1);
	      }

	      component.color = component.color;
	    }

	    if (data.opacity !== undefined) {
	      component.opacity = data.opacity;
	    }

	    if (data.flipX !== undefined) {
	      component.flipX = data.flipX;
	    }

	    if (data.flipY !== undefined) {
	      component.flipY = data.flipY;
	    }

	    if (data.width !== undefined) {
	      component.width = data.width;
	    }

	    if (data.height !== undefined) {
	      component.height = data.height;
	    }

	    if (data.spriteAsset !== undefined) {
	      component.spriteAsset = data.spriteAsset;
	    }

	    if (data.sprite) {
	      component.sprite = data.sprite;
	    }

	    if (data.frame !== undefined) {
	      component.frame = data.frame;
	    }

	    if (data.clips) {
	      for (var name in data.clips) {
	        component.addClip(data.clips[name]);
	      }
	    }

	    if (data.speed !== undefined) {
	      component.speed = data.speed;
	    }

	    if (data.autoPlayClip) {
	      component.autoPlayClip = data.autoPlayClip;
	    }

	    component.batchGroupId = data.batchGroupId === undefined || data.batchGroupId === null ? -1 : data.batchGroupId;

	    _ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
	  };

	  _proto.cloneComponent = function cloneComponent(entity, clone) {
	    var source = entity.sprite;
	    return this.addComponent(clone, {
	      enabled: source.enabled,
	      type: source.type,
	      spriteAsset: source.spriteAsset,
	      sprite: source.sprite,
	      frame: source.frame,
	      color: source.color.clone(),
	      opacity: source.opacity,
	      flipX: source.flipX,
	      flipY: source.flipY,
	      speed: source.speed,
	      clips: source.clips,
	      autoPlayClip: source.autoPlayClip,
	      batchGroupId: source.batchGroupId,
	      drawOrder: source.drawOrder,
	      layers: source.layers.slice(0)
	    });
	  };

	  _proto.onUpdate = function onUpdate(dt) {
	    var components = this.store;

	    for (var id in components) {
	      if (components.hasOwnProperty(id)) {
	        var component = components[id];

	        if (component.data.enabled && component.entity.enabled) {
	          var sprite = component.entity.sprite;

	          if (sprite._currentClip) {
	            sprite._currentClip._update(dt);
	          }
	        }
	      }
	    }
	  };

	  _proto.onBeforeRemove = function onBeforeRemove(entity, component) {
	    component.onDestroy();
	  };

	  _createClass(SpriteComponentSystem, [{
	    key: "defaultMaterial",
	    get: function get() {
	      if (!this._defaultMaterial) {
	        var texture = new Texture(this.app.graphicsDevice, {
	          width: 1,
	          height: 1,
	          format: PIXELFORMAT_R8_G8_B8_A8,
	          name: 'sprite'
	        });
	        var pixels = new Uint8Array(texture.lock());
	        pixels[0] = pixels[1] = pixels[2] = pixels[3] = 255;
	        texture.unlock();
	        var material = new StandardMaterial();
	        material.diffuse.set(0, 0, 0);
	        material.emissive.set(0.5, 0.5, 0.5);
	        material.emissiveMap = texture;
	        material.emissiveTint = true;
	        material.opacityMap = texture;
	        material.opacityMapChannel = 'a';
	        material.opacityTint = true;
	        material.opacity = 0;
	        material.useLighting = false;
	        material.useGammaTonemap = false;
	        material.useFog = false;
	        material.useSkybox = false;
	        material.blendType = BLEND_PREMULTIPLIED;
	        material.depthWrite = false;
	        material.pixelSnap = false;
	        material.cull = CULLFACE_NONE;
	        material.update();
	        this._defaultTexture = texture;
	        this._defaultMaterial = material;
	      }

	      return this._defaultMaterial;
	    },
	    set: function set(material) {
	      this._defaultMaterial = material;
	    }
	  }, {
	    key: "default9SlicedMaterialSlicedMode",
	    get: function get() {
	      if (!this._default9SlicedMaterialSlicedMode) {
	        var material = this.defaultMaterial.clone();
	        material.nineSlicedMode = SPRITE_RENDERMODE_SLICED;
	        material.update();
	        this._default9SlicedMaterialSlicedMode = material;
	      }

	      return this._default9SlicedMaterialSlicedMode;
	    },
	    set: function set(material) {
	      this._default9SlicedMaterialSlicedMode = material;
	    }
	  }, {
	    key: "default9SlicedMaterialTiledMode",
	    get: function get() {
	      if (!this._default9SlicedMaterialTiledMode) {
	        var material = this.defaultMaterial.clone();
	        material.nineSlicedMode = SPRITE_RENDERMODE_TILED;
	        material.update();
	        this._default9SlicedMaterialTiledMode = material;
	      }

	      return this._default9SlicedMaterialTiledMode;
	    },
	    set: function set(material) {
	      this._default9SlicedMaterialTiledMode = material;
	    }
	  }]);

	  return SpriteComponentSystem;
	}(ComponentSystem);

	Component._buildAccessors(SpriteComponent.prototype, _schema$2);

	var ZoneComponent = function (_Component) {
	  _inheritsLoose(ZoneComponent, _Component);

	  function ZoneComponent(system, entity) {
	    var _this;

	    _this = _Component.call(this, system, entity) || this;
	    _this._oldState = true;
	    _this._size = new Vec3();

	    _this.on('set_enabled', _this._onSetEnabled, _assertThisInitialized(_this));

	    return _this;
	  }

	  var _proto = ZoneComponent.prototype;

	  _proto.onEnable = function onEnable() {
	    this._checkState();
	  };

	  _proto.onDisable = function onDisable() {
	    this._checkState();
	  };

	  _proto._onSetEnabled = function _onSetEnabled(prop, old, value) {
	    this._checkState();
	  };

	  _proto._checkState = function _checkState() {
	    var state = this.enabled && this.entity.enabled;
	    if (state === this._oldState) return;
	    this._oldState = state;
	    this.fire('enable');
	    this.fire('state', this.enabled);
	  };

	  _proto._onBeforeRemove = function _onBeforeRemove() {
	    this.fire('remove');
	  };

	  _createClass(ZoneComponent, [{
	    key: "size",
	    get: function get() {
	      return this._size;
	    },
	    set: function set(data) {
	      if (data instanceof Vec3) {
	        this._size.copy(data);
	      } else if (data instanceof Array && data.length >= 3) {
	        this.size.set(data[0], data[1], data[2]);
	      }
	    }
	  }]);

	  return ZoneComponent;
	}(Component);

	var ZoneComponentData = function ZoneComponentData() {
	  this.enabled = true;
	};

	var _schema$1 = ['enabled'];

	var ZoneComponentSystem = function (_ComponentSystem) {
	  _inheritsLoose(ZoneComponentSystem, _ComponentSystem);

	  function ZoneComponentSystem(app) {
	    var _this;

	    _this = _ComponentSystem.call(this, app) || this;
	    _this.id = 'zone';
	    _this.ComponentType = ZoneComponent;
	    _this.DataType = ZoneComponentData;
	    _this.schema = _schema$1;

	    _this.on('beforeremove', _this._onBeforeRemove, _assertThisInitialized(_this));

	    return _this;
	  }

	  var _proto = ZoneComponentSystem.prototype;

	  _proto.initializeComponentData = function initializeComponentData(component, data, properties) {
	    component.enabled = data.hasOwnProperty('enabled') ? !!data.enabled : true;

	    if (data.size) {
	      if (data.size instanceof Vec3) {
	        component.size.copy(data.size);
	      } else if (data.size instanceof Array && data.size.length >= 3) {
	        component.size.set(data.size[0], data.size[1], data.size[2]);
	      }
	    }
	  };

	  _proto.cloneComponent = function cloneComponent(entity, clone) {
	    var data = {
	      size: entity.zone.size
	    };
	    return this.addComponent(clone, data);
	  };

	  _proto._onBeforeRemove = function _onBeforeRemove(entity, component) {
	    component._onBeforeRemove();
	  };

	  return ZoneComponentSystem;
	}(ComponentSystem);

	Component._buildAccessors(ZoneComponent.prototype, _schema$1);

	var PostEffect = function PostEffect(effect, inputTarget) {
	  this.effect = effect;
	  this.inputTarget = inputTarget;
	  this.outputTarget = null;
	  this.name = effect.constructor.name;
	};

	var PostEffectQueue = function () {
	  function PostEffectQueue(app, camera) {
	    this.app = app;
	    this.camera = camera;
	    this.destinationRenderTarget = null;
	    this.effects = [];
	    this.enabled = false;
	    this.depthTarget = null;
	    camera.on('set:rect', this.onCameraRectChanged, this);
	  }

	  var _proto = PostEffectQueue.prototype;

	  _proto._allocateColorBuffer = function _allocateColorBuffer(format, name) {
	    var rect = this.camera.rect;
	    var width = Math.floor(rect.z * this.app.graphicsDevice.width);
	    var height = Math.floor(rect.w * this.app.graphicsDevice.height);
	    var colorBuffer = new Texture(this.app.graphicsDevice, {
	      name: name,
	      format: format,
	      width: width,
	      height: height,
	      mipmaps: false,
	      minFilter: FILTER_NEAREST,
	      magFilter: FILTER_NEAREST,
	      addressU: ADDRESS_CLAMP_TO_EDGE,
	      addressV: ADDRESS_CLAMP_TO_EDGE
	    });
	    return colorBuffer;
	  };

	  _proto._createOffscreenTarget = function _createOffscreenTarget(useDepth, hdr) {
	    var device = this.app.graphicsDevice;
	    var format = hdr ? device.getHdrFormat() : PIXELFORMAT_R8_G8_B8_A8;
	    var name = this.camera.entity.name + '-posteffect-' + this.effects.length;

	    var colorBuffer = this._allocateColorBuffer(format, name);

	    return new RenderTarget({
	      colorBuffer: colorBuffer,
	      depth: useDepth,
	      stencil: useDepth && this.app.graphicsDevice.supportsStencil,
	      samples: useDepth ? device.samples : 1
	    });
	  };

	  _proto._resizeOffscreenTarget = function _resizeOffscreenTarget(rt) {
	    var format = rt.colorBuffer.format;
	    var name = rt.colorBuffer.name;
	    rt.destroyFrameBuffers();
	    rt.destroyTextureBuffers();
	    rt._colorBuffer = this._allocateColorBuffer(format, name);
	  };

	  _proto._destroyOffscreenTarget = function _destroyOffscreenTarget(rt) {
	    rt.destroyTextureBuffers();
	    rt.destroy();
	  };

	  _proto.addEffect = function addEffect(effect) {
	    var effects = this.effects;
	    var isFirstEffect = effects.length === 0;

	    var inputTarget = this._createOffscreenTarget(isFirstEffect, effect.hdr);

	    var newEntry = new PostEffect(effect, inputTarget);
	    effects.push(newEntry);
	    this._sourceTarget = newEntry.inputTarget;

	    if (effects.length > 1) {
	      effects[effects.length - 2].outputTarget = newEntry.inputTarget;
	    }

	    this._newPostEffect = effect;

	    if (effect.needsDepthBuffer) {
	      this._requestDepthMap();
	    }

	    this.enable();
	    this._newPostEffect = undefined;
	  };

	  _proto.removeEffect = function removeEffect(effect) {
	    var index = -1;

	    for (var i = 0, len = this.effects.length; i < len; i++) {
	      if (this.effects[i].effect === effect) {
	        index = i;
	        break;
	      }
	    }

	    if (index >= 0) {
	      if (index > 0) {
	        this.effects[index - 1].outputTarget = index + 1 < this.effects.length ? this.effects[index + 1].inputTarget : null;
	      } else {
	        if (this.effects.length > 1) {
	          if (!this.effects[1].inputTarget._depth) {
	            this._destroyOffscreenTarget(this.effects[1].inputTarget);

	            this.effects[1].inputTarget = this._createOffscreenTarget(true, this.effects[1].hdr);
	            this._sourceTarget = this.effects[1].inputTarget;
	          }

	          this.camera.renderTarget = this.effects[1].inputTarget;
	        }
	      }

	      this._destroyOffscreenTarget(this.effects[index].inputTarget);

	      this.effects.splice(index, 1);
	    }

	    if (this.enabled) {
	      if (effect.needsDepthBuffer) {
	        this._releaseDepthMap();
	      }
	    }

	    if (this.effects.length === 0) {
	      this.disable();
	    }
	  };

	  _proto._requestDepthMaps = function _requestDepthMaps() {
	    for (var i = 0, len = this.effects.length; i < len; i++) {
	      var effect = this.effects[i].effect;
	      if (this._newPostEffect === effect) continue;

	      if (effect.needsDepthBuffer) {
	        this._requestDepthMap();
	      }
	    }
	  };

	  _proto._releaseDepthMaps = function _releaseDepthMaps() {
	    for (var i = 0, len = this.effects.length; i < len; i++) {
	      var effect = this.effects[i].effect;

	      if (effect.needsDepthBuffer) {
	        this._releaseDepthMap();
	      }
	    }
	  };

	  _proto._requestDepthMap = function _requestDepthMap() {
	    var depthLayer = this.app.scene.layers.getLayerById(LAYERID_DEPTH);

	    if (depthLayer) {
	      depthLayer.incrementCounter();
	      this.camera.requestSceneDepthMap(true);
	    }
	  };

	  _proto._releaseDepthMap = function _releaseDepthMap() {
	    var depthLayer = this.app.scene.layers.getLayerById(LAYERID_DEPTH);

	    if (depthLayer) {
	      depthLayer.decrementCounter();
	      this.camera.requestSceneDepthMap(false);
	    }
	  };

	  _proto.destroy = function destroy() {
	    for (var i = 0, len = this.effects.length; i < len; i++) {
	      this.effects[i].inputTarget.destroy();
	    }

	    this.effects.length = 0;
	    this.disable();
	  };

	  _proto.enable = function enable() {
	    var _this = this;

	    if (!this.enabled && this.effects.length) {
	      this.enabled = true;

	      this._requestDepthMaps();

	      this.app.graphicsDevice.on('resizecanvas', this._onCanvasResized, this);
	      this.destinationRenderTarget = this.camera.renderTarget;
	      this.camera.renderTarget = this.effects[0].inputTarget;

	      this.camera.onPostprocessing = function () {
	        if (_this.enabled) {
	          var rect = null;
	          var len = _this.effects.length;

	          if (len) {
	            for (var i = 0; i < len; i++) {
	              var fx = _this.effects[i];
	              var destTarget = fx.outputTarget;

	              if (i === len - 1) {
	                rect = _this.camera.rect;

	                if (_this.destinationRenderTarget) {
	                  destTarget = _this.destinationRenderTarget;
	                }
	              }

	              fx.effect.render(fx.inputTarget, destTarget, rect);
	            }
	          }
	        }
	      };
	    }
	  };

	  _proto.disable = function disable() {
	    if (this.enabled) {
	      this.enabled = false;
	      this.app.graphicsDevice.off('resizecanvas', this._onCanvasResized, this);

	      this._releaseDepthMaps();

	      this._destroyOffscreenTarget(this._sourceTarget);

	      this.camera.renderTarget = null;
	      this.camera.onPostprocessing = null;
	    }
	  };

	  _proto._onCanvasResized = function _onCanvasResized(width, height) {
	    var rect = this.camera.rect;
	    var device = this.app.graphicsDevice;
	    this.camera.camera.aspectRatio = device.width * rect.z / (device.height * rect.w);
	    this.resizeRenderTargets();
	  };

	  _proto.resizeRenderTargets = function resizeRenderTargets() {
	    var rect = this.camera.rect;
	    var desiredWidth = Math.floor(rect.z * this.app.graphicsDevice.width);
	    var desiredHeight = Math.floor(rect.w * this.app.graphicsDevice.height);
	    var effects = this.effects;

	    for (var i = 0, len = effects.length; i < len; i++) {
	      var fx = effects[i];

	      if (fx.inputTarget.width !== desiredWidth || fx.inputTarget.height !== desiredHeight) {
	        this._resizeOffscreenTarget(fx.inputTarget);
	      }
	    }
	  };

	  _proto.onCameraRectChanged = function onCameraRectChanged(name, oldValue, newValue) {
	    if (this.enabled) {
	      this.resizeRenderTargets();
	    }
	  };

	  return PostEffectQueue;
	}();

	var properties = [{
	  name: 'aspectRatio',
	  readonly: false
	}, {
	  name: 'aspectRatioMode',
	  readonly: false
	}, {
	  name: 'calculateProjection',
	  readonly: false
	}, {
	  name: 'calculateTransform',
	  readonly: false
	}, {
	  name: 'clearColor',
	  readonly: false
	}, {
	  name: 'cullFaces',
	  readonly: false
	}, {
	  name: 'farClip',
	  readonly: false
	}, {
	  name: 'flipFaces',
	  readonly: false
	}, {
	  name: 'fov',
	  readonly: false
	}, {
	  name: 'frustumCulling',
	  readonly: false
	}, {
	  name: 'horizontalFov',
	  readonly: false
	}, {
	  name: 'nearClip',
	  readonly: false
	}, {
	  name: 'orthoHeight',
	  readonly: false
	}, {
	  name: 'projection',
	  readonly: false
	}, {
	  name: 'scissorRect',
	  readonly: false
	}];

	var CameraComponent = function (_Component) {
	  _inheritsLoose(CameraComponent, _Component);

	  function CameraComponent(system, entity) {
	    var _this;

	    _this = _Component.call(this, system, entity) || this;
	    _this.onPostprocessing = null;
	    _this.onPreRender = null;
	    _this.onPostRender = null;
	    _this._renderSceneDepthMap = 0;
	    _this._renderSceneColorMap = 0;
	    _this._camera = new Camera();
	    _this._camera.node = entity;
	    _this._priority = 0;
	    _this._disablePostEffectsLayer = LAYERID_UI;
	    _this._postEffects = new PostEffectQueue(system.app, _assertThisInitialized(_this));
	    return _this;
	  }

	  var _proto = CameraComponent.prototype;

	  _proto._enableDepthLayer = function _enableDepthLayer(value) {
	    var hasDepthLayer = this.layers.find(function (layerId) {
	      return layerId === LAYERID_DEPTH;
	    });

	    if (hasDepthLayer) {
	      var depthLayer = this.system.app.scene.layers.getLayerById(LAYERID_DEPTH);

	      if (value) {
	        depthLayer == null ? void 0 : depthLayer.incrementCounter();
	      } else {
	        depthLayer == null ? void 0 : depthLayer.decrementCounter();
	      }
	    } else if (value) {
	      return false;
	    }

	    return true;
	  };

	  _proto.requestSceneColorMap = function requestSceneColorMap(enabled) {
	    this._renderSceneColorMap += enabled ? 1 : -1;

	    this._enableDepthLayer(enabled);
	  };

	  _proto.requestSceneDepthMap = function requestSceneDepthMap(enabled) {
	    this._renderSceneDepthMap += enabled ? 1 : -1;

	    this._enableDepthLayer(enabled);
	  };

	  _proto.dirtyLayerCompositionCameras = function dirtyLayerCompositionCameras() {
	    var layerComp = this.system.app.scene.layers;
	    layerComp._dirtyCameras = true;
	  };

	  _proto.screenToWorld = function screenToWorld(screenx, screeny, cameraz, worldCoord) {
	    var device = this.system.app.graphicsDevice;
	    var w = device.clientRect.width;
	    var h = device.clientRect.height;
	    return this._camera.screenToWorld(screenx, screeny, cameraz, w, h, worldCoord);
	  };

	  _proto.worldToScreen = function worldToScreen(worldCoord, screenCoord) {
	    var device = this.system.app.graphicsDevice;
	    var w = device.clientRect.width;
	    var h = device.clientRect.height;
	    return this._camera.worldToScreen(worldCoord, w, h, screenCoord);
	  };

	  _proto.onAppPrerender = function onAppPrerender() {
	    this._camera._viewMatDirty = true;
	    this._camera._viewProjMatDirty = true;
	  };

	  _proto.addCameraToLayers = function addCameraToLayers() {
	    var layers = this.layers;

	    for (var i = 0; i < layers.length; i++) {
	      var layer = this.system.app.scene.layers.getLayerById(layers[i]);

	      if (layer) {
	        layer.addCamera(this);
	      }
	    }
	  };

	  _proto.removeCameraFromLayers = function removeCameraFromLayers() {
	    var layers = this.layers;

	    for (var i = 0; i < layers.length; i++) {
	      var layer = this.system.app.scene.layers.getLayerById(layers[i]);

	      if (layer) {
	        layer.removeCamera(this);
	      }
	    }
	  };

	  _proto.onLayersChanged = function onLayersChanged(oldComp, newComp) {
	    this.addCameraToLayers();
	    oldComp.off('add', this.onLayerAdded, this);
	    oldComp.off('remove', this.onLayerRemoved, this);
	    newComp.on('add', this.onLayerAdded, this);
	    newComp.on('remove', this.onLayerRemoved, this);
	  };

	  _proto.onLayerAdded = function onLayerAdded(layer) {
	    var index = this.layers.indexOf(layer.id);
	    if (index < 0) return;
	    layer.addCamera(this);
	  };

	  _proto.onLayerRemoved = function onLayerRemoved(layer) {
	    var index = this.layers.indexOf(layer.id);
	    if (index < 0) return;
	    layer.removeCamera(this);
	  };

	  _proto.onEnable = function onEnable() {
	    var system = this.system;
	    var scene = system.app.scene;
	    var layers = scene.layers;
	    system.addCamera(this);
	    scene.on('set:layers', this.onLayersChanged, this);

	    if (layers) {
	      layers.on('add', this.onLayerAdded, this);
	      layers.on('remove', this.onLayerRemoved, this);
	    }

	    if (this.enabled && this.entity.enabled) {
	      this.addCameraToLayers();
	    }

	    this.postEffects.enable();
	  };

	  _proto.onDisable = function onDisable() {
	    var system = this.system;
	    var scene = system.app.scene;
	    var layers = scene.layers;
	    this.postEffects.disable();
	    this.removeCameraFromLayers();
	    scene.off('set:layers', this.onLayersChanged, this);

	    if (layers) {
	      layers.off('add', this.onLayerAdded, this);
	      layers.off('remove', this.onLayerRemoved, this);
	    }

	    system.removeCamera(this);
	  };

	  _proto.onRemove = function onRemove() {
	    this.onDisable();
	    this.off();
	  };

	  _proto.calculateAspectRatio = function calculateAspectRatio(rt) {
	    var device = this.system.app.graphicsDevice;
	    var width = rt ? rt.width : device.width;
	    var height = rt ? rt.height : device.height;
	    return width * this.rect.z / (height * this.rect.w);
	  };

	  _proto.frameUpdate = function frameUpdate(rt) {
	    if (this.aspectRatioMode === ASPECT_AUTO) {
	      this.aspectRatio = this.calculateAspectRatio(rt);
	    }
	  };

	  _proto.startXr = function startXr(type, spaceType, options) {
	    this.system.app.xr.start(this, type, spaceType, options);
	  };

	  _proto.endXr = function endXr(callback) {
	    if (!this._camera.xr) {
	      if (callback) callback(new Error('Camera is not in XR'));
	      return;
	    }

	    this._camera.xr.end(callback);
	  };

	  _proto.copy = function copy(source) {
	    var _this2 = this;

	    properties.forEach(function (property) {
	      if (!property.readonly) {
	        var name = property.name;
	        _this2[name] = source[name];
	      }
	    });
	    this.clearColorBuffer = source.clearColorBuffer;
	    this.clearDepthBuffer = source.clearDepthBuffer;
	    this.clearStencilBuffer = source.clearStencilBuffer;
	    this.disablePostEffectsLayer = source.disablePostEffectsLayer;
	    this.layers = source.layers;
	    this.priority = source.priority;
	    this.renderTarget = source.renderTarget;
	    this.rect = source.rect;
	  };

	  _createClass(CameraComponent, [{
	    key: "camera",
	    get: function get() {
	      return this._camera;
	    }
	  }, {
	    key: "clearColorBuffer",
	    get: function get() {
	      return this._camera.clearColorBuffer;
	    },
	    set: function set(value) {
	      this._camera.clearColorBuffer = value;
	      this.dirtyLayerCompositionCameras();
	    }
	  }, {
	    key: "clearDepthBuffer",
	    get: function get() {
	      return this._camera.clearDepthBuffer;
	    },
	    set: function set(value) {
	      this._camera.clearDepthBuffer = value;
	      this.dirtyLayerCompositionCameras();
	    }
	  }, {
	    key: "clearStencilBuffer",
	    get: function get() {
	      return this._camera.clearStencilBuffer;
	    },
	    set: function set(value) {
	      this._camera.clearStencilBuffer = value;
	      this.dirtyLayerCompositionCameras();
	    }
	  }, {
	    key: "disablePostEffectsLayer",
	    get: function get() {
	      return this._disablePostEffectsLayer;
	    },
	    set: function set(layer) {
	      this._disablePostEffectsLayer = layer;
	      this.dirtyLayerCompositionCameras();
	    }
	  }, {
	    key: "renderSceneColorMap",
	    get: function get() {
	      return this._renderSceneColorMap > 0;
	    }
	  }, {
	    key: "renderSceneDepthMap",
	    get: function get() {
	      return this._renderSceneDepthMap > 0;
	    }
	  }, {
	    key: "frustum",
	    get: function get() {
	      return this._camera.frustum;
	    }
	  }, {
	    key: "layers",
	    get: function get() {
	      return this._camera.layers;
	    },
	    set: function set(newValue) {
	      var layers = this._camera.layers;

	      for (var i = 0; i < layers.length; i++) {
	        var layer = this.system.app.scene.layers.getLayerById(layers[i]);
	        if (!layer) continue;
	        layer.removeCamera(this);
	      }

	      this._camera.layers = newValue;
	      if (!this.enabled || !this.entity.enabled) return;

	      for (var _i = 0; _i < newValue.length; _i++) {
	        var _layer = this.system.app.scene.layers.getLayerById(newValue[_i]);

	        if (!_layer) continue;

	        _layer.addCamera(this);
	      }
	    }
	  }, {
	    key: "layersSet",
	    get: function get() {
	      return this._camera.layersSet;
	    }
	  }, {
	    key: "postEffectsEnabled",
	    get: function get() {
	      return this._postEffects.enabled;
	    }
	  }, {
	    key: "postEffects",
	    get: function get() {
	      return this._postEffects;
	    }
	  }, {
	    key: "priority",
	    get: function get() {
	      return this._priority;
	    },
	    set: function set(newValue) {
	      this._priority = newValue;
	      this.dirtyLayerCompositionCameras();
	    }
	  }, {
	    key: "projectionMatrix",
	    get: function get() {
	      return this._camera.projectionMatrix;
	    }
	  }, {
	    key: "rect",
	    get: function get() {
	      return this._camera.rect;
	    },
	    set: function set(value) {
	      this._camera.rect = value;
	      this.fire('set:rect', this._camera.rect);
	    }
	  }, {
	    key: "renderTarget",
	    get: function get() {
	      return this._camera.renderTarget;
	    },
	    set: function set(value) {
	      this._camera.renderTarget = value;
	      this.dirtyLayerCompositionCameras();
	    }
	  }, {
	    key: "viewMatrix",
	    get: function get() {
	      return this._camera.viewMatrix;
	    }
	  }]);

	  return CameraComponent;
	}(Component);

	properties.forEach(function (property) {
	  var name = property.name;
	  var options = {};

	  options.get = function () {
	    return this._camera[name];
	  };

	  if (!property.readonly) {
	    options.set = function (newValue) {
	      this._camera[name] = newValue;
	    };
	  }

	  Object.defineProperty(CameraComponent.prototype, name, options);
	});

	var CameraComponentData = function CameraComponentData() {
	  this.enabled = true;
	};

	var _schema = ['enabled'];

	var CameraComponentSystem = function (_ComponentSystem) {
	  _inheritsLoose(CameraComponentSystem, _ComponentSystem);

	  function CameraComponentSystem(app) {
	    var _this;

	    _this = _ComponentSystem.call(this, app) || this;
	    _this.cameras = [];
	    _this.id = 'camera';
	    _this.ComponentType = CameraComponent;
	    _this.DataType = CameraComponentData;
	    _this.schema = _schema;

	    _this.on('beforeremove', _this.onBeforeRemove, _assertThisInitialized(_this));

	    _this.app.on('prerender', _this.onAppPrerender, _assertThisInitialized(_this));

	    _this.app.systems.on('update', _this.onUpdate, _assertThisInitialized(_this));

	    return _this;
	  }

	  var _proto = CameraComponentSystem.prototype;

	  _proto.initializeComponentData = function initializeComponentData(component, data, properties) {
	    properties = ['aspectRatio', 'aspectRatioMode', 'calculateProjection', 'calculateTransform', 'clearColor', 'clearColorBuffer', 'clearDepthBuffer', 'clearStencilBuffer', 'cullFaces', 'farClip', 'flipFaces', 'fov', 'frustumCulling', 'horizontalFov', 'layers', 'renderTarget', 'nearClip', 'orthoHeight', 'projection', 'priority', 'rect', 'scissorRect'];

	    for (var i = 0; i < properties.length; i++) {
	      var property = properties[i];

	      if (data.hasOwnProperty(property)) {
	        var value = data[property];

	        switch (property) {
	          case 'rect':
	          case 'scissorRect':
	            if (Array.isArray(value)) {
	              component[property] = new Vec4(value[0], value[1], value[2], value[3]);
	            } else {
	              component[property] = value;
	            }

	            break;

	          case 'clearColor':
	            if (Array.isArray(value)) {
	              component[property] = new Color(value[0], value[1], value[2], value[3]);
	            } else {
	              component[property] = value;
	            }

	            break;

	          default:
	            component[property] = value;
	            break;
	        }
	      }
	    }

	    _ComponentSystem.prototype.initializeComponentData.call(this, component, data, ['enabled']);
	  };

	  _proto.cloneComponent = function cloneComponent(entity, clone) {
	    var c = entity.camera;
	    return this.addComponent(clone, {
	      aspectRatio: c.aspectRatio,
	      aspectRatioMode: c.aspectRatioMode,
	      calculateProjection: c.calculateProjection,
	      calculateTransform: c.calculateTransform,
	      clearColor: c.clearColor,
	      clearColorBuffer: c.clearColorBuffer,
	      clearDepthBuffer: c.clearDepthBuffer,
	      clearStencilBuffer: c.clearStencilBuffer,
	      cullFaces: c.cullFaces,
	      enabled: c.enabled,
	      farClip: c.farClip,
	      flipFaces: c.flipFaces,
	      fov: c.fov,
	      frustumCulling: c.frustumCulling,
	      horizontalFov: c.horizontalFov,
	      layers: c.layers,
	      renderTarget: c.renderTarget,
	      nearClip: c.nearClip,
	      orthoHeight: c.orthoHeight,
	      projection: c.projection,
	      priority: c.priority,
	      rect: c.rect,
	      scissorRect: c.scissorRect
	    });
	  };

	  _proto.onBeforeRemove = function onBeforeRemove(entity, component) {
	    this.removeCamera(component);
	  };

	  _proto.onUpdate = function onUpdate(dt) {};

	  _proto.onAppPrerender = function onAppPrerender() {
	    for (var i = 0, len = this.cameras.length; i < len; i++) {
	      this.cameras[i].onAppPrerender();
	    }
	  };

	  _proto.addCamera = function addCamera(camera) {
	    this.cameras.push(camera);
	    sortPriority(this.cameras);
	  };

	  _proto.removeCamera = function removeCamera(camera) {
	    var index = this.cameras.indexOf(camera);

	    if (index >= 0) {
	      this.cameras.splice(index, 1);
	      sortPriority(this.cameras);
	    }
	  };

	  _proto.destroy = function destroy() {
	    _ComponentSystem.prototype.destroy.call(this);

	    this.app.systems.off('update', this.onUpdate, this);
	  };

	  return CameraComponentSystem;
	}(ComponentSystem);

	Component._buildAccessors(CameraComponent.prototype, _schema);

	var _lightProps = [];
	var _lightPropsDefault = [];

	var LightComponent = function (_Component) {
	  _inheritsLoose(LightComponent, _Component);

	  function LightComponent(system, entity) {
	    var _this;

	    _this = _Component.call(this, system, entity) || this;
	    _this._cookieAsset = null;
	    _this._cookieAssetId = null;
	    _this._cookieAssetAdd = false;
	    _this._cookieMatrix = null;
	    return _this;
	  }

	  var _proto = LightComponent.prototype;

	  _proto.addLightToLayers = function addLightToLayers() {
	    for (var i = 0; i < this.layers.length; i++) {
	      var layer = this.system.app.scene.layers.getLayerById(this.layers[i]);

	      if (layer) {
	        layer.addLight(this);
	      }
	    }
	  };

	  _proto.removeLightFromLayers = function removeLightFromLayers() {
	    for (var i = 0; i < this.layers.length; i++) {
	      var layer = this.system.app.scene.layers.getLayerById(this.layers[i]);

	      if (layer) {
	        layer.removeLight(this);
	      }
	    }
	  };

	  _proto.onLayersChanged = function onLayersChanged(oldComp, newComp) {
	    if (this.enabled && this.entity.enabled) {
	      this.addLightToLayers();
	    }

	    oldComp.off('add', this.onLayerAdded, this);
	    oldComp.off('remove', this.onLayerRemoved, this);
	    newComp.on('add', this.onLayerAdded, this);
	    newComp.on('remove', this.onLayerRemoved, this);
	  };

	  _proto.onLayerAdded = function onLayerAdded(layer) {
	    var index = this.layers.indexOf(layer.id);

	    if (index >= 0 && this.enabled && this.entity.enabled) {
	      layer.addLight(this);
	    }
	  };

	  _proto.onLayerRemoved = function onLayerRemoved(layer) {
	    var index = this.layers.indexOf(layer.id);

	    if (index >= 0) {
	      layer.removeLight(this);
	    }
	  };

	  _proto.refreshProperties = function refreshProperties() {
	    for (var i = 0; i < _lightProps.length; i++) {
	      var name = _lightProps[i];
	      this[name] = this[name];
	    }

	    if (this.enabled && this.entity.enabled) this.onEnable();
	  };

	  _proto.updateShadow = function updateShadow() {
	    this.light.updateShadow();
	  };

	  _proto.onCookieAssetSet = function onCookieAssetSet() {
	    var forceLoad = false;

	    if (this._cookieAsset.type === 'cubemap' && !this._cookieAsset.loadFaces) {
	      this._cookieAsset.loadFaces = true;
	      forceLoad = true;
	    }

	    if (!this._cookieAsset.resource || forceLoad) this.system.app.assets.load(this._cookieAsset);
	    if (this._cookieAsset.resource) this.onCookieAssetLoad();
	  };

	  _proto.onCookieAssetAdd = function onCookieAssetAdd(asset) {
	    if (this._cookieAssetId !== asset.id) return;
	    this._cookieAsset = asset;
	    if (this.light.enabled) this.onCookieAssetSet();

	    this._cookieAsset.on('load', this.onCookieAssetLoad, this);

	    this._cookieAsset.on('remove', this.onCookieAssetRemove, this);
	  };

	  _proto.onCookieAssetLoad = function onCookieAssetLoad() {
	    if (!this._cookieAsset || !this._cookieAsset.resource) return;
	    this.cookie = this._cookieAsset.resource;
	  };

	  _proto.onCookieAssetRemove = function onCookieAssetRemove() {
	    if (!this._cookieAssetId) return;

	    if (this._cookieAssetAdd) {
	      this.system.app.assets.off('add:' + this._cookieAssetId, this.onCookieAssetAdd, this);
	      this._cookieAssetAdd = false;
	    }

	    if (this._cookieAsset) {
	      this._cookieAsset.off('load', this.onCookieAssetLoad, this);

	      this._cookieAsset.off('remove', this.onCookieAssetRemove, this);

	      this._cookieAsset = null;
	    }

	    this.cookie = null;
	  };

	  _proto.onEnable = function onEnable() {
	    this.light.enabled = true;
	    this.system.app.scene.on('set:layers', this.onLayersChanged, this);

	    if (this.system.app.scene.layers) {
	      this.system.app.scene.layers.on('add', this.onLayerAdded, this);
	      this.system.app.scene.layers.on('remove', this.onLayerRemoved, this);
	    }

	    if (this.enabled && this.entity.enabled) {
	      this.addLightToLayers();
	    }

	    if (this._cookieAsset && !this.cookie) this.onCookieAssetSet();
	  };

	  _proto.onDisable = function onDisable() {
	    this.light.enabled = false;
	    this.system.app.scene.off('set:layers', this.onLayersChanged, this);

	    if (this.system.app.scene.layers) {
	      this.system.app.scene.layers.off('add', this.onLayerAdded, this);
	      this.system.app.scene.layers.off('remove', this.onLayerRemoved, this);
	    }

	    this.removeLightFromLayers();
	  };

	  _proto.onRemove = function onRemove() {
	    this.onDisable();
	    this.light.destroy();
	    this.cookieAsset = null;
	  };

	  return LightComponent;
	}(Component);

	function _defineProperty(name, defaultValue, setFunc, skipEqualsCheck) {
	  var c = LightComponent.prototype;

	  _lightProps.push(name);

	  _lightPropsDefault.push(defaultValue);

	  Object.defineProperty(c, name, {
	    get: function get() {
	      return this.data[name];
	    },
	    set: function set(value) {
	      var data = this.data;
	      var oldValue = data[name];
	      if (!skipEqualsCheck && oldValue === value) return;
	      data[name] = value;
	      if (setFunc) setFunc.call(this, value, oldValue);
	    },
	    configurable: true
	  });
	}

	function _defineProps() {
	  _defineProperty('enabled', true, function (newValue, oldValue) {
	    this.onSetEnabled(null, oldValue, newValue);
	  });

	  _defineProperty('light', null);

	  _defineProperty('type', 'directional', function (newValue, oldValue) {
	    this.system.changeType(this, oldValue, newValue);
	    this.refreshProperties();
	  });

	  _defineProperty('color', new Color(1, 1, 1), function (newValue, oldValue) {
	    this.light.setColor(newValue);
	  }, true);

	  _defineProperty('intensity', 1, function (newValue, oldValue) {
	    this.light.intensity = newValue;
	  });

	  _defineProperty('shape', LIGHTSHAPE_PUNCTUAL, function (newValue, oldValue) {
	    this.light.shape = newValue;
	  });

	  _defineProperty('castShadows', false, function (newValue, oldValue) {
	    this.light.castShadows = newValue;
	  });

	  _defineProperty('shadowDistance', 40, function (newValue, oldValue) {
	    this.light.shadowDistance = newValue;
	  });

	  _defineProperty('shadowIntensity', 1, function (newValue, oldValue) {
	    this.light.shadowIntensity = newValue;
	  });

	  _defineProperty('shadowResolution', 1024, function (newValue, oldValue) {
	    this.light.shadowResolution = newValue;
	  });

	  _defineProperty('shadowBias', 0.05, function (newValue, oldValue) {
	    this.light.shadowBias = -0.01 * math.clamp(newValue, 0, 1);
	  });

	  _defineProperty('numCascades', 1, function (newValue, oldValue) {
	    this.light.numCascades = math.clamp(Math.floor(newValue), 1, 4);
	  });

	  _defineProperty('bakeNumSamples', 1, function (newValue, oldValue) {
	    this.light.bakeNumSamples = math.clamp(Math.floor(newValue), 1, 255);
	  });

	  _defineProperty('bakeArea', 0, function (newValue, oldValue) {
	    this.light.bakeArea = math.clamp(newValue, 0, 180);
	  });

	  _defineProperty('cascadeDistribution', 0.5, function (newValue, oldValue) {
	    this.light.cascadeDistribution = math.clamp(newValue, 0, 1);
	  });

	  _defineProperty('normalOffsetBias', 0, function (newValue, oldValue) {
	    this.light.normalOffsetBias = math.clamp(newValue, 0, 1);
	  });

	  _defineProperty('range', 10, function (newValue, oldValue) {
	    this.light.attenuationEnd = newValue;
	  });

	  _defineProperty('innerConeAngle', 40, function (newValue, oldValue) {
	    this.light.innerConeAngle = newValue;
	  });

	  _defineProperty('outerConeAngle', 45, function (newValue, oldValue) {
	    this.light.outerConeAngle = newValue;
	  });

	  _defineProperty('falloffMode', LIGHTFALLOFF_LINEAR, function (newValue, oldValue) {
	    this.light.falloffMode = newValue;
	  });

	  _defineProperty('shadowType', SHADOW_PCF3, function (newValue, oldValue) {
	    this.light.shadowType = newValue;
	  });

	  _defineProperty('vsmBlurSize', 11, function (newValue, oldValue) {
	    this.light.vsmBlurSize = newValue;
	  });

	  _defineProperty('vsmBlurMode', BLUR_GAUSSIAN, function (newValue, oldValue) {
	    this.light.vsmBlurMode = newValue;
	  });

	  _defineProperty('vsmBias', 0.01 * 0.25, function (newValue, oldValue) {
	    this.light.vsmBias = math.clamp(newValue, 0, 1);
	  });

	  _defineProperty('cookieAsset', null, function (newValue, oldValue) {
	    if (this._cookieAssetId && (newValue instanceof Asset && newValue.id === this._cookieAssetId || newValue === this._cookieAssetId)) return;
	    this.onCookieAssetRemove();
	    this._cookieAssetId = null;

	    if (newValue instanceof Asset) {
	      this.data.cookieAsset = newValue.id;
	      this._cookieAssetId = newValue.id;
	      this.onCookieAssetAdd(newValue);
	    } else if (typeof newValue === 'number') {
	      this._cookieAssetId = newValue;
	      var asset = this.system.app.assets.get(newValue);

	      if (asset) {
	        this.onCookieAssetAdd(asset);
	      } else {
	        this._cookieAssetAdd = true;
	        this.system.app.assets.on('add:' + this._cookieAssetId, this.onCookieAssetAdd, this);
	      }
	    }
	  });

	  _defineProperty('cookie', null, function (newValue, oldValue) {
	    this.light.cookie = newValue;
	  });

	  _defineProperty('cookieIntensity', 1, function (newValue, oldValue) {
	    this.light.cookieIntensity = math.clamp(newValue, 0, 1);
	  });

	  _defineProperty('cookieFalloff', true, function (newValue, oldValue) {
	    this.light.cookieFalloff = newValue;
	  });

	  _defineProperty('cookieChannel', 'rgb', function (newValue, oldValue) {
	    this.light.cookieChannel = newValue;
	  });

	  _defineProperty('cookieAngle', 0, function (newValue, oldValue) {
	    if (newValue !== 0 || this.cookieScale !== null) {
	      if (!this._cookieMatrix) this._cookieMatrix = new Vec4();
	      var scx = 1;
	      var scy = 1;

	      if (this.cookieScale) {
	        scx = this.cookieScale.x;
	        scy = this.cookieScale.y;
	      }

	      var c = Math.cos(newValue * math.DEG_TO_RAD);
	      var s = Math.sin(newValue * math.DEG_TO_RAD);

	      this._cookieMatrix.set(c / scx, -s / scx, s / scy, c / scy);

	      this.light.cookieTransform = this._cookieMatrix;
	    } else {
	      this.light.cookieTransform = null;
	    }
	  });

	  _defineProperty('cookieScale', null, function (newValue, oldValue) {
	    if (newValue !== null || this.cookieAngle !== 0) {
	      if (!this._cookieMatrix) this._cookieMatrix = new Vec4();
	      var scx = newValue.x;
	      var scy = newValue.y;
	      var c = Math.cos(this.cookieAngle * math.DEG_TO_RAD);
	      var s = Math.sin(this.cookieAngle * math.DEG_TO_RAD);

	      this._cookieMatrix.set(c / scx, -s / scx, s / scy, c / scy);

	      this.light.cookieTransform = this._cookieMatrix;
	    } else {
	      this.light.cookieTransform = null;
	    }
	  }, true);

	  _defineProperty('cookieOffset', null, function (newValue, oldValue) {
	    this.light.cookieOffset = newValue;
	  }, true);

	  _defineProperty('shadowUpdateMode', SHADOWUPDATE_REALTIME, function (newValue, oldValue) {
	    this.light.shadowUpdateMode = newValue;
	  }, true);

	  _defineProperty('mask', 1, function (newValue, oldValue) {
	    this.light.mask = newValue;
	  });

	  _defineProperty('affectDynamic', true, function (newValue, oldValue) {
	    if (newValue) {
	      this.light.mask |= MASK_AFFECT_DYNAMIC;
	    } else {
	      this.light.mask &= ~MASK_AFFECT_DYNAMIC;
	    }

	    this.light.layersDirty();
	  });

	  _defineProperty('affectLightmapped', false, function (newValue, oldValue) {
	    if (newValue) {
	      this.light.mask |= MASK_AFFECT_LIGHTMAPPED;
	      if (this.bake) this.light.mask &= ~MASK_BAKE;
	    } else {
	      this.light.mask &= ~MASK_AFFECT_LIGHTMAPPED;
	      if (this.bake) this.light.mask |= MASK_BAKE;
	    }
	  });

	  _defineProperty('bake', false, function (newValue, oldValue) {
	    if (newValue) {
	      this.light.mask |= MASK_BAKE;
	      if (this.affectLightmapped) this.light.mask &= ~MASK_AFFECT_LIGHTMAPPED;
	    } else {
	      this.light.mask &= ~MASK_BAKE;
	      if (this.affectLightmapped) this.light.mask |= MASK_AFFECT_LIGHTMAPPED;
	    }

	    this.light.layersDirty();
	  });

	  _defineProperty('bakeDir', true, function (newValue, oldValue) {
	    this.light.bakeDir = newValue;
	  });

	  _defineProperty('isStatic', false, function (newValue, oldValue) {
	    this.light.isStatic = newValue;
	  });

	  _defineProperty('layers', [LAYERID_WORLD], function (newValue, oldValue) {
	    for (var i = 0; i < oldValue.length; i++) {
	      var layer = this.system.app.scene.layers.getLayerById(oldValue[i]);
	      if (!layer) continue;
	      layer.removeLight(this);
	    }

	    for (var _i = 0; _i < newValue.length; _i++) {
	      var _layer = this.system.app.scene.layers.getLayerById(newValue[_i]);

	      if (!_layer) continue;

	      if (this.enabled && this.entity.enabled) {
	        _layer.addLight(this);
	      }
	    }
	  });
	}

	_defineProps();

	var LightComponentData = function LightComponentData() {
	  var _props = _lightProps;
	  var _propsDefault = _lightPropsDefault;

	  for (var i = 0; i < _props.length; i++) {
	    var value = _propsDefault[i];

	    if (value && value.clone) {
	      this[_props[i]] = value.clone();
	    } else {
	      this[_props[i]] = value;
	    }
	  }
	};

	var lightTypes = {
	  'directional': LIGHTTYPE_DIRECTIONAL,
	  'omni': LIGHTTYPE_OMNI,
	  'point': LIGHTTYPE_OMNI,
	  'spot': LIGHTTYPE_SPOT
	};

	var LightComponentSystem = function (_ComponentSystem) {
	  _inheritsLoose(LightComponentSystem, _ComponentSystem);

	  function LightComponentSystem(app) {
	    var _this;

	    _this = _ComponentSystem.call(this, app) || this;
	    _this.id = 'light';
	    _this.ComponentType = LightComponent;
	    _this.DataType = LightComponentData;

	    _this.on('beforeremove', _this._onRemoveComponent, _assertThisInitialized(_this));

	    return _this;
	  }

	  var _proto = LightComponentSystem.prototype;

	  _proto.initializeComponentData = function initializeComponentData(component, _data) {
	    var properties = _lightProps;
	    var data = {};

	    for (var i = 0, len = properties.length; i < len; i++) {
	      var property = properties[i];
	      data[property] = _data[property];
	    }

	    if (!data.type) data.type = component.data.type;
	    component.data.type = data.type;

	    if (data.layers && Array.isArray(data.layers)) {
	      data.layers = data.layers.slice(0);
	    }

	    if (data.color && Array.isArray(data.color)) data.color = new Color(data.color[0], data.color[1], data.color[2]);
	    if (data.cookieOffset && data.cookieOffset instanceof Array) data.cookieOffset = new Vec2(data.cookieOffset[0], data.cookieOffset[1]);
	    if (data.cookieScale && data.cookieScale instanceof Array) data.cookieScale = new Vec2(data.cookieScale[0], data.cookieScale[1]);

	    if (data.enable) {
	      console.warn('WARNING: enable: Property is deprecated. Set enabled property instead.');
	      data.enabled = data.enable;
	    }

	    if (!data.shape) {
	      data.shape = LIGHTSHAPE_PUNCTUAL;
	    }

	    var light = new Light(this.app.graphicsDevice);
	    light.type = lightTypes[data.type];
	    light._node = component.entity;
	    light._scene = this.app.scene;
	    component.data.light = light;

	    _ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
	  };

	  _proto._onRemoveComponent = function _onRemoveComponent(entity, component) {
	    component.onRemove();
	  };

	  _proto.cloneComponent = function cloneComponent(entity, clone) {
	    var light = entity.light;
	    var data = [];
	    var name;
	    var _props = _lightProps;

	    for (var i = 0; i < _props.length; i++) {
	      name = _props[i];
	      if (name === 'light') continue;

	      if (light[name] && light[name].clone) {
	        data[name] = light[name].clone();
	      } else {
	        data[name] = light[name];
	      }
	    }

	    return this.addComponent(clone, data);
	  };

	  _proto.changeType = function changeType(component, oldValue, newValue) {
	    if (oldValue !== newValue) {
	      component.light.type = lightTypes[newValue];
	    }
	  };

	  return LightComponentSystem;
	}(ComponentSystem);

	var ScriptComponentData = function ScriptComponentData() {
	  this.enabled = true;
	};

	var METHOD_INITIALIZE_ATTRIBUTES = '_onInitializeAttributes';
	var METHOD_INITIALIZE = '_onInitialize';
	var METHOD_POST_INITIALIZE = '_onPostInitialize';
	var METHOD_UPDATE = '_onUpdate';
	var METHOD_POST_UPDATE = '_onPostUpdate';
	var executionOrderCounter = 0;

	var ScriptComponentSystem = function (_ComponentSystem) {
	  _inheritsLoose(ScriptComponentSystem, _ComponentSystem);

	  function ScriptComponentSystem(app) {
	    var _this;

	    _this = _ComponentSystem.call(this, app) || this;
	    _this.id = 'script';
	    _this.ComponentType = ScriptComponent;
	    _this.DataType = ScriptComponentData;
	    _this._components = new SortedLoopArray({
	      sortBy: '_executionOrder'
	    });
	    _this._enabledComponents = new SortedLoopArray({
	      sortBy: '_executionOrder'
	    });
	    _this.preloading = true;

	    _this.on('beforeremove', _this._onBeforeRemove, _assertThisInitialized(_this));

	    _this.app.systems.on('initialize', _this._onInitialize, _assertThisInitialized(_this));

	    _this.app.systems.on('postInitialize', _this._onPostInitialize, _assertThisInitialized(_this));

	    _this.app.systems.on('update', _this._onUpdate, _assertThisInitialized(_this));

	    _this.app.systems.on('postUpdate', _this._onPostUpdate, _assertThisInitialized(_this));

	    return _this;
	  }

	  var _proto = ScriptComponentSystem.prototype;

	  _proto.initializeComponentData = function initializeComponentData(component, data) {
	    component._executionOrder = executionOrderCounter++;

	    this._components.append(component);

	    if (executionOrderCounter > Number.MAX_SAFE_INTEGER) {
	      this._resetExecutionOrder();
	    }

	    component.enabled = data.hasOwnProperty('enabled') ? !!data.enabled : true;

	    if (component.enabled && component.entity.enabled) {
	      this._enabledComponents.append(component);
	    }

	    if (data.hasOwnProperty('order') && data.hasOwnProperty('scripts')) {
	      component._scriptsData = data.scripts;

	      for (var i = 0; i < data.order.length; i++) {
	        component.create(data.order[i], {
	          enabled: data.scripts[data.order[i]].enabled,
	          attributes: data.scripts[data.order[i]].attributes,
	          preloading: this.preloading
	        });
	      }
	    }
	  };

	  _proto.cloneComponent = function cloneComponent(entity, clone) {
	    var order = [];
	    var scripts = {};

	    for (var i = 0; i < entity.script._scripts.length; i++) {
	      var scriptInstance = entity.script._scripts[i];
	      var scriptName = scriptInstance.__scriptType.__name;
	      order.push(scriptName);
	      var attributes = {};

	      for (var key in scriptInstance.__attributes) {
	        attributes[key] = scriptInstance.__attributes[key];
	      }

	      scripts[scriptName] = {
	        enabled: scriptInstance._enabled,
	        attributes: attributes
	      };
	    }

	    for (var _key in entity.script._scriptsIndex) {
	      if (_key.awaiting) {
	        order.splice(_key.ind, 0, _key);
	      }
	    }

	    var data = {
	      enabled: entity.script.enabled,
	      order: order,
	      scripts: scripts
	    };
	    return this.addComponent(clone, data);
	  };

	  _proto._resetExecutionOrder = function _resetExecutionOrder() {
	    executionOrderCounter = 0;

	    for (var i = 0, len = this._components.length; i < len; i++) {
	      this._components.items[i]._executionOrder = executionOrderCounter++;
	    }
	  };

	  _proto._callComponentMethod = function _callComponentMethod(components, name, dt) {
	    for (components.loopIndex = 0; components.loopIndex < components.length; components.loopIndex++) {
	      components.items[components.loopIndex][name](dt);
	    }
	  };

	  _proto._onInitialize = function _onInitialize() {
	    this.preloading = false;

	    this._callComponentMethod(this._components, METHOD_INITIALIZE_ATTRIBUTES);

	    this._callComponentMethod(this._enabledComponents, METHOD_INITIALIZE);
	  };

	  _proto._onPostInitialize = function _onPostInitialize() {
	    this._callComponentMethod(this._enabledComponents, METHOD_POST_INITIALIZE);
	  };

	  _proto._onUpdate = function _onUpdate(dt) {
	    this._callComponentMethod(this._enabledComponents, METHOD_UPDATE, dt);
	  };

	  _proto._onPostUpdate = function _onPostUpdate(dt) {
	    this._callComponentMethod(this._enabledComponents, METHOD_POST_UPDATE, dt);
	  };

	  _proto._addComponentToEnabled = function _addComponentToEnabled(component) {
	    this._enabledComponents.insert(component);
	  };

	  _proto._removeComponentFromEnabled = function _removeComponentFromEnabled(component) {
	    this._enabledComponents.remove(component);
	  };

	  _proto._onBeforeRemove = function _onBeforeRemove(entity, component) {
	    var ind = this._components.items.indexOf(component);

	    if (ind >= 0) {
	      component._onBeforeRemove();
	    }

	    this._removeComponentFromEnabled(component);

	    this._components.remove(component);
	  };

	  _proto.destroy = function destroy() {
	    _ComponentSystem.prototype.destroy.call(this);

	    this.app.systems.off('initialize', this._onInitialize, this);
	    this.app.systems.off('postInitialize', this._onPostInitialize, this);
	    this.app.systems.off('update', this._onUpdate, this);
	    this.app.systems.off('postUpdate', this._onPostUpdate, this);
	  };

	  return ScriptComponentSystem;
	}(ComponentSystem);

	var XRTYPE_INLINE = 'inline';
	var XRTYPE_VR = 'immersive-vr';
	var XRTYPE_AR = 'immersive-ar';
	var XRSPACE_VIEWER = 'viewer';
	var XRSPACE_LOCAL = 'local';
	var XRSPACE_LOCALFLOOR = 'local-floor';
	var XRSPACE_BOUNDEDFLOOR = 'bounded-floor';
	var XRSPACE_UNBOUNDED = 'unbounded';
	var XRTARGETRAY_GAZE = 'gaze';
	var XRTARGETRAY_SCREEN = 'screen';
	var XRTARGETRAY_POINTER = 'tracked-pointer';
	var XRHAND_NONE = 'none';
	var XRHAND_LEFT = 'left';
	var XRHAND_RIGHT = 'right';
	var XRTRACKABLE_POINT = 'point';
	var XRTRACKABLE_PLANE = 'plane';
	var XRTRACKABLE_MESH = 'mesh';
	var XRDEPTHSENSINGUSAGE_CPU = 'cpu-optimized';
	var XRDEPTHSENSINGUSAGE_GPU = 'gpu-optimized';
	var XRDEPTHSENSINGFORMAT_L8A8 = 'luminance-alpha';
	var XRDEPTHSENSINGFORMAT_F32 = 'float32';

	var poolVec3 = [];
	var poolQuat = [];

	var XrHitTestSource = function (_EventHandler) {
	  _inheritsLoose(XrHitTestSource, _EventHandler);

	  function XrHitTestSource(manager, xrHitTestSource, transient) {
	    var _this;

	    _this = _EventHandler.call(this) || this;
	    _this.manager = void 0;
	    _this._xrHitTestSource = void 0;
	    _this._transient = void 0;
	    _this.manager = manager;
	    _this._xrHitTestSource = xrHitTestSource;
	    _this._transient = transient;
	    return _this;
	  }

	  var _proto = XrHitTestSource.prototype;

	  _proto.remove = function remove() {
	    if (!this._xrHitTestSource) return;
	    var sources = this.manager.hitTest.sources;
	    var ind = sources.indexOf(this);
	    if (ind !== -1) sources.splice(ind, 1);
	    this.onStop();
	  };

	  _proto.onStop = function onStop() {
	    this._xrHitTestSource.cancel();

	    this._xrHitTestSource = null;
	    this.fire('remove');
	    this.manager.hitTest.fire('remove', this);
	  };

	  _proto.update = function update(frame) {
	    if (this._transient) {
	      var transientResults = frame.getHitTestResultsForTransientInput(this._xrHitTestSource);

	      for (var i = 0; i < transientResults.length; i++) {
	        var transientResult = transientResults[i];
	        var inputSource = void 0;
	        if (transientResult.inputSource) inputSource = this.manager.input._getByInputSource(transientResult.inputSource);
	        this.updateHitResults(transientResult.results, inputSource);
	      }
	    } else {
	      this.updateHitResults(frame.getHitTestResults(this._xrHitTestSource));
	    }
	  };

	  _proto.updateHitResults = function updateHitResults(results, inputSource) {
	    for (var i = 0; i < results.length; i++) {
	      var pose = results[i].getPose(this.manager._referenceSpace);
	      var position = poolVec3.pop();
	      if (!position) position = new Vec3();
	      position.copy(pose.transform.position);
	      var rotation = poolQuat.pop();
	      if (!rotation) rotation = new Quat();
	      rotation.copy(pose.transform.orientation);
	      this.fire('result', position, rotation, inputSource);
	      this.manager.hitTest.fire('result', this, position, rotation, inputSource);
	      poolVec3.push(position);
	      poolQuat.push(rotation);
	    }
	  };

	  return XrHitTestSource;
	}(EventHandler);

	var XrHitTest = function (_EventHandler) {
	  _inheritsLoose(XrHitTest, _EventHandler);

	  function XrHitTest(manager) {
	    var _this;

	    _this = _EventHandler.call(this) || this;
	    _this.manager = void 0;
	    _this._supported = platform.browser && !!(window.XRSession && window.XRSession.prototype.requestHitTestSource);
	    _this._session = null;
	    _this.sources = [];
	    _this.manager = manager;

	    if (_this._supported) {
	      _this.manager.on('start', _this._onSessionStart, _assertThisInitialized(_this));

	      _this.manager.on('end', _this._onSessionEnd, _assertThisInitialized(_this));
	    }

	    return _this;
	  }

	  var _proto = XrHitTest.prototype;

	  _proto._onSessionStart = function _onSessionStart() {
	    if (this.manager.type !== XRTYPE_AR) return;
	    this._session = this.manager.session;
	  };

	  _proto._onSessionEnd = function _onSessionEnd() {
	    if (!this._session) return;
	    this._session = null;

	    for (var i = 0; i < this.sources.length; i++) {
	      this.sources[i].onStop();
	    }

	    this.sources = [];
	  };

	  _proto.isAvailable = function isAvailable(callback, fireError) {
	    var err;
	    if (!this._supported) err = new Error('XR HitTest is not supported');
	    if (!this._session) err = new Error('XR Session is not started (1)');
	    if (this.manager.type !== XRTYPE_AR) err = new Error('XR HitTest is available only for AR');

	    if (err) {
	      if (callback) callback(err);
	      if (fireError) fireError.fire('error', err);
	      return false;
	    }

	    return true;
	  };

	  _proto.start = function start(options) {
	    var _this2 = this;

	    if (options === void 0) {
	      options = {};
	    }

	    if (!this.isAvailable(options.callback, this)) return;
	    if (!options.profile && !options.spaceType) options.spaceType = XRSPACE_VIEWER;
	    var xrRay;
	    var offsetRay = options.offsetRay;

	    if (offsetRay) {
	      var origin = new DOMPoint(offsetRay.origin.x, offsetRay.origin.y, offsetRay.origin.z, 1.0);
	      var direction = new DOMPoint(offsetRay.direction.x, offsetRay.direction.y, offsetRay.direction.z, 0.0);
	      xrRay = new XRRay(origin, direction);
	    }

	    var callback = options.callback;

	    if (options.spaceType) {
	      this._session.requestReferenceSpace(options.spaceType).then(function (referenceSpace) {
	        if (!_this2._session) {
	          var err = new Error('XR Session is not started (2)');
	          if (callback) callback(err);

	          _this2.fire('error', err);

	          return;
	        }

	        _this2._session.requestHitTestSource({
	          space: referenceSpace,
	          entityTypes: options.entityTypes || undefined,
	          offsetRay: xrRay
	        }).then(function (xrHitTestSource) {
	          _this2._onHitTestSource(xrHitTestSource, false, callback);
	        }).catch(function (ex) {
	          if (callback) callback(ex);

	          _this2.fire('error', ex);
	        });
	      }).catch(function (ex) {
	        if (callback) callback(ex);

	        _this2.fire('error', ex);
	      });
	    } else {
	      this._session.requestHitTestSourceForTransientInput({
	        profile: options.profile,
	        entityTypes: options.entityTypes || undefined,
	        offsetRay: xrRay
	      }).then(function (xrHitTestSource) {
	        _this2._onHitTestSource(xrHitTestSource, true, callback);
	      }).catch(function (ex) {
	        if (callback) callback(ex);

	        _this2.fire('error', ex);
	      });
	    }
	  };

	  _proto._onHitTestSource = function _onHitTestSource(xrHitTestSource, transient, callback) {
	    if (!this._session) {
	      xrHitTestSource.cancel();
	      var err = new Error('XR Session is not started (3)');
	      if (callback) callback(err);
	      this.fire('error', err);
	      return;
	    }

	    var hitTestSource = new XrHitTestSource(this.manager, xrHitTestSource, transient);
	    this.sources.push(hitTestSource);
	    if (callback) callback(null, hitTestSource);
	    this.fire('add', hitTestSource);
	  };

	  _proto.update = function update(frame) {
	    for (var i = 0; i < this.sources.length; i++) {
	      this.sources[i].update(frame);
	    }
	  };

	  _createClass(XrHitTest, [{
	    key: "supported",
	    get: function get() {
	      return this._supported;
	    }
	  }]);

	  return XrHitTest;
	}(EventHandler);

	var XrFinger = function () {
	  function XrFinger(index, hand) {
	    this._index = void 0;
	    this._hand = void 0;
	    this._joints = [];
	    this._tip = null;
	    this._index = index;
	    this._hand = hand;

	    this._hand._fingers.push(this);
	  }

	  _createClass(XrFinger, [{
	    key: "index",
	    get: function get() {
	      return this._index;
	    }
	  }, {
	    key: "hand",
	    get: function get() {
	      return this._hand;
	    }
	  }, {
	    key: "joints",
	    get: function get() {
	      return this._joints;
	    }
	  }, {
	    key: "tip",
	    get: function get() {
	      return this._tip;
	    }
	  }]);

	  return XrFinger;
	}();

	var tipJointIds = platform.browser && window.XRHand ? ['thumb-tip', 'index-finger-tip', 'middle-finger-tip', 'ring-finger-tip', 'pinky-finger-tip'] : [];
	var tipJointIdsIndex = {};

	for (var i = 0; i < tipJointIds.length; i++) {
	  tipJointIdsIndex[tipJointIds[i]] = true;
	}

	var XrJoint = function () {
	  function XrJoint(index, id, hand, finger) {
	    if (finger === void 0) {
	      finger = null;
	    }

	    this._index = void 0;
	    this._id = void 0;
	    this._hand = void 0;
	    this._finger = void 0;
	    this._wrist = void 0;
	    this._tip = void 0;
	    this._radius = null;
	    this._localTransform = new Mat4();
	    this._worldTransform = new Mat4();
	    this._localPosition = new Vec3();
	    this._localRotation = new Quat();
	    this._position = new Vec3();
	    this._rotation = new Quat();
	    this._dirtyLocal = true;
	    this._index = index;
	    this._id = id;
	    this._hand = hand;
	    this._finger = finger;
	    this._wrist = id === 'wrist';
	    this._tip = this._finger && !!tipJointIdsIndex[id];
	  }

	  var _proto = XrJoint.prototype;

	  _proto.update = function update(pose) {
	    this._dirtyLocal = true;
	    this._radius = pose.radius;

	    this._localPosition.copy(pose.transform.position);

	    this._localRotation.copy(pose.transform.orientation);
	  };

	  _proto._updateTransforms = function _updateTransforms() {
	    if (this._dirtyLocal) {
	      this._dirtyLocal = false;

	      this._localTransform.setTRS(this._localPosition, this._localRotation, Vec3.ONE);
	    }

	    var manager = this._hand._manager;
	    var parent = manager.camera.parent;

	    if (parent) {
	      this._worldTransform.mul2(parent.getWorldTransform(), this._localTransform);
	    } else {
	      this._worldTransform.copy(this._localTransform);
	    }
	  };

	  _proto.getPosition = function getPosition() {
	    this._updateTransforms();

	    this._worldTransform.getTranslation(this._position);

	    return this._position;
	  };

	  _proto.getRotation = function getRotation() {
	    this._updateTransforms();

	    this._rotation.setFromMat4(this._worldTransform);

	    return this._rotation;
	  };

	  _createClass(XrJoint, [{
	    key: "index",
	    get: function get() {
	      return this._index;
	    }
	  }, {
	    key: "hand",
	    get: function get() {
	      return this._hand;
	    }
	  }, {
	    key: "finger",
	    get: function get() {
	      return this._finger;
	    }
	  }, {
	    key: "wrist",
	    get: function get() {
	      return this._wrist;
	    }
	  }, {
	    key: "tip",
	    get: function get() {
	      return this._tip;
	    }
	  }, {
	    key: "radius",
	    get: function get() {
	      return this._radius || 0.005;
	    }
	  }]);

	  return XrJoint;
	}();

	var fingerJointIds = [];
	var vecA = new Vec3();
	var vecB = new Vec3();
	var vecC = new Vec3();

	if (platform.browser && window.XRHand) {
	  fingerJointIds = [['thumb-metacarpal', 'thumb-phalanx-proximal', 'thumb-phalanx-distal', 'thumb-tip'], ['index-finger-metacarpal', 'index-finger-phalanx-proximal', 'index-finger-phalanx-intermediate', 'index-finger-phalanx-distal', 'index-finger-tip'], ['middle-finger-metacarpal', 'middle-finger-phalanx-proximal', 'middle-finger-phalanx-intermediate', 'middle-finger-phalanx-distal', 'middle-finger-tip'], ['ring-finger-metacarpal', 'ring-finger-phalanx-proximal', 'ring-finger-phalanx-intermediate', 'ring-finger-phalanx-distal', 'ring-finger-tip'], ['pinky-finger-metacarpal', 'pinky-finger-phalanx-proximal', 'pinky-finger-phalanx-intermediate', 'pinky-finger-phalanx-distal', 'pinky-finger-tip']];
	}

	var XrHand = function (_EventHandler) {
	  _inheritsLoose(XrHand, _EventHandler);

	  function XrHand(inputSource) {
	    var _this;

	    _this = _EventHandler.call(this) || this;
	    _this._manager = void 0;
	    _this._inputSource = void 0;
	    _this._tracking = false;
	    _this._fingers = [];
	    _this._joints = [];
	    _this._jointsById = {};
	    _this._tips = [];
	    _this._wrist = null;
	    var xrHand = inputSource._xrInputSource.hand;
	    _this._manager = inputSource._manager;
	    _this._inputSource = inputSource;

	    if (xrHand.get('wrist')) {
	      var joint = new XrJoint(0, 'wrist', _assertThisInitialized(_this), null);
	      _this._wrist = joint;

	      _this._joints.push(joint);

	      _this._jointsById.wrist = joint;
	    }

	    for (var f = 0; f < fingerJointIds.length; f++) {
	      var finger = new XrFinger(f, _assertThisInitialized(_this));

	      for (var j = 0; j < fingerJointIds[f].length; j++) {
	        var jointId = fingerJointIds[f][j];
	        if (!xrHand.get(jointId)) continue;

	        var _joint = new XrJoint(j, jointId, _assertThisInitialized(_this), finger);

	        _this._joints.push(_joint);

	        _this._jointsById[jointId] = _joint;

	        if (_joint.tip) {
	          _this._tips.push(_joint);

	          finger._tip = _joint;
	        }

	        finger._joints.push(_joint);
	      }
	    }

	    return _this;
	  }

	  var _proto = XrHand.prototype;

	  _proto.update = function update(frame) {
	    var xrInputSource = this._inputSource._xrInputSource;

	    for (var j = 0; j < this._joints.length; j++) {
	      var joint = this._joints[j];
	      var jointSpace = xrInputSource.hand.get(joint._id);

	      if (jointSpace) {
	        var pose = void 0;
	        if (frame.session.visibilityState !== 'hidden') pose = frame.getJointPose(jointSpace, this._manager._referenceSpace);

	        if (pose) {
	          joint.update(pose);

	          if (joint.wrist && !this._tracking) {
	            this._tracking = true;
	            this.fire('tracking');
	          }
	        } else if (joint.wrist) {
	          if (this._tracking) {
	            this._tracking = false;
	            this.fire('trackinglost');
	          }

	          break;
	        }
	      }
	    }

	    var j1 = this._jointsById['thumb-metacarpal'];
	    var j4 = this._jointsById['thumb-tip'];
	    var j6 = this._jointsById['index-finger-phalanx-proximal'];
	    var j9 = this._jointsById['index-finger-tip'];
	    var j16 = this._jointsById['ring-finger-phalanx-proximal'];
	    var j21 = this._jointsById['pinky-finger-phalanx-proximal'];

	    if (j1 && j4 && j6 && j9 && j16 && j21) {
	      this._inputSource._dirtyRay = true;

	      this._inputSource._rayLocal.origin.lerp(j4._localPosition, j9._localPosition, 0.5);

	      var jointL = j1;
	      var jointR = j21;

	      if (this._inputSource.handedness === XRHAND_LEFT) {
	        var t = jointL;
	        jointL = jointR;
	        jointR = t;
	      }

	      vecA.sub2(jointL._localPosition, this._wrist._localPosition);
	      vecB.sub2(jointR._localPosition, this._wrist._localPosition);
	      vecC.cross(vecA, vecB).normalize();
	      vecA.lerp(j6._localPosition, j16._localPosition, 0.5);
	      vecA.sub(this._wrist._localPosition).normalize();

	      this._inputSource._rayLocal.direction.lerp(vecC, vecA, 0.5).normalize();
	    }

	    var squeezing = this._fingerIsClosed(1) && this._fingerIsClosed(2) && this._fingerIsClosed(3) && this._fingerIsClosed(4);

	    if (squeezing) {
	      if (!this._inputSource._squeezing) {
	        this._inputSource._squeezing = true;

	        this._inputSource.fire('squeezestart');

	        this._manager.input.fire('squeezestart', this._inputSource);
	      }
	    } else {
	      if (this._inputSource._squeezing) {
	        this._inputSource._squeezing = false;

	        this._inputSource.fire('squeeze');

	        this._manager.input.fire('squeeze', this._inputSource);

	        this._inputSource.fire('squeezeend');

	        this._manager.input.fire('squeezeend', this._inputSource);
	      }
	    }
	  };

	  _proto._fingerIsClosed = function _fingerIsClosed(index) {
	    var finger = this._fingers[index];
	    vecA.sub2(finger.joints[0]._localPosition, finger.joints[1]._localPosition).normalize();
	    vecB.sub2(finger.joints[2]._localPosition, finger.joints[3]._localPosition).normalize();
	    return vecA.dot(vecB) < -0.8;
	  };

	  _proto.getJointById = function getJointById(id) {
	    return this._jointsById[id] || null;
	  };

	  _createClass(XrHand, [{
	    key: "fingers",
	    get: function get() {
	      return this._fingers;
	    }
	  }, {
	    key: "joints",
	    get: function get() {
	      return this._joints;
	    }
	  }, {
	    key: "tips",
	    get: function get() {
	      return this._tips;
	    }
	  }, {
	    key: "wrist",
	    get: function get() {
	      return this._wrist;
	    }
	  }, {
	    key: "tracking",
	    get: function get() {
	      return this._tracking;
	    }
	  }]);

	  return XrHand;
	}(EventHandler);

	var quat = new Quat();
	var ids$1 = 0;

	var XrInputSource = function (_EventHandler) {
	  _inheritsLoose(XrInputSource, _EventHandler);

	  function XrInputSource(manager, xrInputSource) {
	    var _this;

	    _this = _EventHandler.call(this) || this;
	    _this._id = void 0;
	    _this._manager = void 0;
	    _this._xrInputSource = void 0;
	    _this._ray = new Ray();
	    _this._rayLocal = new Ray();
	    _this._grip = false;
	    _this._hand = null;
	    _this._localTransform = null;
	    _this._worldTransform = null;
	    _this._position = new Vec3();
	    _this._rotation = new Quat();
	    _this._localPosition = null;
	    _this._localRotation = null;
	    _this._dirtyLocal = true;
	    _this._dirtyRay = false;
	    _this._selecting = false;
	    _this._squeezing = false;
	    _this._elementInput = true;
	    _this._elementEntity = null;
	    _this._hitTestSources = [];
	    _this._id = ++ids$1;
	    _this._manager = manager;
	    _this._xrInputSource = xrInputSource;
	    if (xrInputSource.hand) _this._hand = new XrHand(_assertThisInitialized(_this));
	    return _this;
	  }

	  var _proto = XrInputSource.prototype;

	  _proto.update = function update(frame) {
	    if (this._hand) {
	      this._hand.update(frame);
	    } else {
	      if (this._xrInputSource.gripSpace) {
	        var gripPose = frame.getPose(this._xrInputSource.gripSpace, this._manager._referenceSpace);

	        if (gripPose) {
	          if (!this._grip) {
	            this._grip = true;
	            this._localTransform = new Mat4();
	            this._worldTransform = new Mat4();
	            this._localPosition = new Vec3();
	            this._localRotation = new Quat();
	          }

	          this._dirtyLocal = true;

	          this._localPosition.copy(gripPose.transform.position);

	          this._localRotation.copy(gripPose.transform.orientation);
	        }
	      }

	      var targetRayPose = frame.getPose(this._xrInputSource.targetRaySpace, this._manager._referenceSpace);

	      if (targetRayPose) {
	        this._dirtyRay = true;

	        this._rayLocal.origin.copy(targetRayPose.transform.position);

	        this._rayLocal.direction.set(0, 0, -1);

	        quat.copy(targetRayPose.transform.orientation);
	        quat.transformVector(this._rayLocal.direction, this._rayLocal.direction);
	      }
	    }
	  };

	  _proto._updateTransforms = function _updateTransforms() {
	    if (this._dirtyLocal) {
	      this._dirtyLocal = false;

	      this._localTransform.setTRS(this._localPosition, this._localRotation, Vec3.ONE);
	    }

	    var parent = this._manager.camera.parent;

	    if (parent) {
	      this._worldTransform.mul2(parent.getWorldTransform(), this._localTransform);
	    } else {
	      this._worldTransform.copy(this._localTransform);
	    }
	  };

	  _proto._updateRayTransforms = function _updateRayTransforms() {
	    var dirty = this._dirtyRay;
	    this._dirtyRay = false;
	    var parent = this._manager.camera.parent;

	    if (parent) {
	      var parentTransform = this._manager.camera.parent.getWorldTransform();

	      parentTransform.getTranslation(this._position);

	      this._rotation.setFromMat4(parentTransform);

	      this._rotation.transformVector(this._rayLocal.origin, this._ray.origin);

	      this._ray.origin.add(this._position);

	      this._rotation.transformVector(this._rayLocal.direction, this._ray.direction);
	    } else if (dirty) {
	      this._ray.origin.copy(this._rayLocal.origin);

	      this._ray.direction.copy(this._rayLocal.direction);
	    }
	  };

	  _proto.getPosition = function getPosition() {
	    if (!this._position) return null;

	    this._updateTransforms();

	    this._worldTransform.getTranslation(this._position);

	    return this._position;
	  };

	  _proto.getLocalPosition = function getLocalPosition() {
	    return this._localPosition;
	  };

	  _proto.getRotation = function getRotation() {
	    if (!this._rotation) return null;

	    this._updateTransforms();

	    this._rotation.setFromMat4(this._worldTransform);

	    return this._rotation;
	  };

	  _proto.getLocalRotation = function getLocalRotation() {
	    return this._localRotation;
	  };

	  _proto.getOrigin = function getOrigin() {
	    this._updateRayTransforms();

	    return this._ray.origin;
	  };

	  _proto.getDirection = function getDirection() {
	    this._updateRayTransforms();

	    return this._ray.direction;
	  };

	  _proto.hitTestStart = function hitTestStart(options) {
	    var _this2 = this;

	    if (options === void 0) {
	      options = {};
	    }

	    options.profile = this._xrInputSource.profiles[0];
	    var callback = options.callback;

	    options.callback = function (err, hitTestSource) {
	      if (hitTestSource) _this2.onHitTestSourceAdd(hitTestSource);
	      if (callback) callback(err, hitTestSource);
	    };

	    this._manager.hitTest.start(options);
	  };

	  _proto.onHitTestSourceAdd = function onHitTestSourceAdd(hitTestSource) {
	    this._hitTestSources.push(hitTestSource);

	    this.fire('hittest:add', hitTestSource);
	    hitTestSource.on('result', function (position, rotation, inputSource) {
	      if (inputSource !== this) return;
	      this.fire('hittest:result', hitTestSource, position, rotation);
	    }, this);
	    hitTestSource.once('remove', function () {
	      this.onHitTestSourceRemove(hitTestSource);
	      this.fire('hittest:remove', hitTestSource);
	    }, this);
	  };

	  _proto.onHitTestSourceRemove = function onHitTestSourceRemove(hitTestSource) {
	    var ind = this._hitTestSources.indexOf(hitTestSource);

	    if (ind !== -1) this._hitTestSources.splice(ind, 1);
	  };

	  _createClass(XrInputSource, [{
	    key: "id",
	    get: function get() {
	      return this._id;
	    }
	  }, {
	    key: "inputSource",
	    get: function get() {
	      return this._xrInputSource;
	    }
	  }, {
	    key: "targetRayMode",
	    get: function get() {
	      return this._xrInputSource.targetRayMode;
	    }
	  }, {
	    key: "handedness",
	    get: function get() {
	      return this._xrInputSource.handedness;
	    }
	  }, {
	    key: "profiles",
	    get: function get() {
	      return this._xrInputSource.profiles;
	    }
	  }, {
	    key: "grip",
	    get: function get() {
	      return this._grip;
	    }
	  }, {
	    key: "hand",
	    get: function get() {
	      return this._hand;
	    }
	  }, {
	    key: "gamepad",
	    get: function get() {
	      return this._xrInputSource.gamepad || null;
	    }
	  }, {
	    key: "selecting",
	    get: function get() {
	      return this._selecting;
	    }
	  }, {
	    key: "squeezing",
	    get: function get() {
	      return this._squeezing;
	    }
	  }, {
	    key: "elementInput",
	    get: function get() {
	      return this._elementInput;
	    },
	    set: function set(value) {
	      if (this._elementInput === value) return;
	      this._elementInput = value;
	      if (!this._elementInput) this._elementEntity = null;
	    }
	  }, {
	    key: "elementEntity",
	    get: function get() {
	      return this._elementEntity;
	    }
	  }, {
	    key: "hitTestSources",
	    get: function get() {
	      return this._hitTestSources;
	    }
	  }]);

	  return XrInputSource;
	}(EventHandler);

	var XrInput = function (_EventHandler) {
	  _inheritsLoose(XrInput, _EventHandler);

	  function XrInput(manager) {
	    var _this;

	    _this = _EventHandler.call(this) || this;
	    _this.manager = void 0;
	    _this._inputSources = [];
	    _this._onInputSourcesChangeEvt = void 0;
	    _this.manager = manager;

	    _this._onInputSourcesChangeEvt = function (evt) {
	      _this._onInputSourcesChange(evt);
	    };

	    _this.manager.on('start', _this._onSessionStart, _assertThisInitialized(_this));

	    _this.manager.on('end', _this._onSessionEnd, _assertThisInitialized(_this));

	    return _this;
	  }

	  var _proto = XrInput.prototype;

	  _proto._onSessionStart = function _onSessionStart() {
	    var _this2 = this;

	    var session = this.manager.session;
	    session.addEventListener('inputsourceschange', this._onInputSourcesChangeEvt);
	    session.addEventListener('select', function (evt) {
	      var inputSource = _this2._getByInputSource(evt.inputSource);

	      inputSource.update(evt.frame);
	      inputSource.fire('select', evt);

	      _this2.fire('select', inputSource, evt);
	    });
	    session.addEventListener('selectstart', function (evt) {
	      var inputSource = _this2._getByInputSource(evt.inputSource);

	      inputSource.update(evt.frame);
	      inputSource._selecting = true;
	      inputSource.fire('selectstart', evt);

	      _this2.fire('selectstart', inputSource, evt);
	    });
	    session.addEventListener('selectend', function (evt) {
	      var inputSource = _this2._getByInputSource(evt.inputSource);

	      inputSource.update(evt.frame);
	      inputSource._selecting = false;
	      inputSource.fire('selectend', evt);

	      _this2.fire('selectend', inputSource, evt);
	    });
	    session.addEventListener('squeeze', function (evt) {
	      var inputSource = _this2._getByInputSource(evt.inputSource);

	      inputSource.update(evt.frame);
	      inputSource.fire('squeeze', evt);

	      _this2.fire('squeeze', inputSource, evt);
	    });
	    session.addEventListener('squeezestart', function (evt) {
	      var inputSource = _this2._getByInputSource(evt.inputSource);

	      inputSource.update(evt.frame);
	      inputSource._squeezing = true;
	      inputSource.fire('squeezestart', evt);

	      _this2.fire('squeezestart', inputSource, evt);
	    });
	    session.addEventListener('squeezeend', function (evt) {
	      var inputSource = _this2._getByInputSource(evt.inputSource);

	      inputSource.update(evt.frame);
	      inputSource._squeezing = false;
	      inputSource.fire('squeezeend', evt);

	      _this2.fire('squeezeend', inputSource, evt);
	    });
	    var inputSources = session.inputSources;

	    for (var i = 0; i < inputSources.length; i++) {
	      this._addInputSource(inputSources[i]);
	    }
	  };

	  _proto._onSessionEnd = function _onSessionEnd() {
	    var i = this._inputSources.length;

	    while (i--) {
	      var inputSource = this._inputSources[i];

	      this._inputSources.splice(i, 1);

	      inputSource.fire('remove');
	      this.fire('remove', inputSource);
	    }

	    var session = this.manager.session;
	    session.removeEventListener('inputsourceschange', this._onInputSourcesChangeEvt);
	  };

	  _proto._onInputSourcesChange = function _onInputSourcesChange(evt) {
	    for (var i = 0; i < evt.removed.length; i++) {
	      this._removeInputSource(evt.removed[i]);
	    }

	    for (var _i = 0; _i < evt.added.length; _i++) {
	      this._addInputSource(evt.added[_i]);
	    }
	  };

	  _proto._getByInputSource = function _getByInputSource(xrInputSource) {
	    for (var i = 0; i < this._inputSources.length; i++) {
	      if (this._inputSources[i].inputSource === xrInputSource) {
	        return this._inputSources[i];
	      }
	    }

	    return null;
	  };

	  _proto._addInputSource = function _addInputSource(xrInputSource) {
	    if (this._getByInputSource(xrInputSource)) return;
	    var inputSource = new XrInputSource(this.manager, xrInputSource);

	    this._inputSources.push(inputSource);

	    this.fire('add', inputSource);
	  };

	  _proto._removeInputSource = function _removeInputSource(xrInputSource) {
	    for (var i = 0; i < this._inputSources.length; i++) {
	      if (this._inputSources[i].inputSource !== xrInputSource) continue;
	      var inputSource = this._inputSources[i];

	      this._inputSources.splice(i, 1);

	      var h = inputSource.hitTestSources.length;

	      while (h--) {
	        inputSource.hitTestSources[h].remove();
	      }

	      inputSource.fire('remove');
	      this.fire('remove', inputSource);
	      return;
	    }
	  };

	  _proto.update = function update(frame) {
	    for (var i = 0; i < this._inputSources.length; i++) {
	      this._inputSources[i].update(frame);
	    }
	  };

	  _createClass(XrInput, [{
	    key: "inputSources",
	    get: function get() {
	      return this._inputSources;
	    }
	  }]);

	  return XrInput;
	}(EventHandler);

	var vec3A = new Vec3();
	var vec3B = new Vec3();
	var mat4A = new Mat4();
	var mat4B = new Mat4();

	var XrLightEstimation = function (_EventHandler) {
	  _inheritsLoose(XrLightEstimation, _EventHandler);

	  function XrLightEstimation(manager) {
	    var _this;

	    _this = _EventHandler.call(this) || this;
	    _this._manager = void 0;
	    _this._supported = false;
	    _this._available = false;
	    _this._lightProbeRequested = false;
	    _this._lightProbe = null;
	    _this._intensity = 0;
	    _this._rotation = new Quat();
	    _this._color = new Color();
	    _this._sphericalHarmonics = new Float32Array(27);
	    _this._manager = manager;

	    _this._manager.on('start', _this._onSessionStart, _assertThisInitialized(_this));

	    _this._manager.on('end', _this._onSessionEnd, _assertThisInitialized(_this));

	    return _this;
	  }

	  var _proto = XrLightEstimation.prototype;

	  _proto._onSessionStart = function _onSessionStart() {
	    var supported = !!this._manager.session.requestLightProbe;
	    if (!supported) return;
	    this._supported = true;
	  };

	  _proto._onSessionEnd = function _onSessionEnd() {
	    this._supported = false;
	    this._available = false;
	    this._lightProbeRequested = false;
	    this._lightProbe = null;
	  };

	  _proto.start = function start() {
	    var _this2 = this;

	    var err;
	    if (!this._manager.session) err = new Error('XR session is not running');
	    if (!err && this._manager.type !== XRTYPE_AR) err = new Error('XR session type is not AR');
	    if (!err && !this._supported) err = new Error('light-estimation is not supported');
	    if (!err && this._lightProbe || this._lightProbeRequested) err = new Error('light estimation is already requested');

	    if (err) {
	      this.fire('error', err);
	      return;
	    }

	    this._lightProbeRequested = true;

	    this._manager.session.requestLightProbe().then(function (lightProbe) {
	      var wasRequested = _this2._lightProbeRequested;
	      _this2._lightProbeRequested = false;

	      if (_this2._manager.active) {
	        if (wasRequested) {
	          _this2._lightProbe = lightProbe;
	        }
	      } else {
	        _this2.fire('error', new Error('XR session is not active'));
	      }
	    }).catch(function (ex) {
	      _this2._lightProbeRequested = false;

	      _this2.fire('error', ex);
	    });
	  };

	  _proto.end = function end() {
	    this._lightProbeRequested = false;
	    this._lightProbe = null;
	    this._available = false;
	  };

	  _proto.update = function update(frame) {
	    if (!this._lightProbe) return;
	    var lightEstimate = frame.getLightEstimate(this._lightProbe);
	    if (!lightEstimate) return;

	    if (!this._available) {
	      this._available = true;
	      this.fire('available');
	    }

	    var pli = lightEstimate.primaryLightIntensity;
	    this._intensity = Math.max(1.0, Math.max(pli.x, Math.max(pli.y, pli.z)));
	    vec3A.copy(pli).mulScalar(1 / this._intensity);

	    this._color.set(vec3A.x, vec3A.y, vec3A.z);

	    vec3A.set(0, 0, 0);
	    vec3B.copy(lightEstimate.primaryLightDirection);
	    mat4A.setLookAt(vec3B, vec3A, Vec3.UP);
	    mat4B.setFromAxisAngle(Vec3.RIGHT, 90);
	    mat4A.mul(mat4B);

	    this._rotation.setFromMat4(mat4A);

	    this._sphericalHarmonics.set(lightEstimate.sphericalHarmonicsCoefficients);
	  };

	  _createClass(XrLightEstimation, [{
	    key: "supported",
	    get: function get() {
	      return this._supported;
	    }
	  }, {
	    key: "available",
	    get: function get() {
	      return this._available;
	    }
	  }, {
	    key: "intensity",
	    get: function get() {
	      return this._available ? this._intensity : null;
	    }
	  }, {
	    key: "color",
	    get: function get() {
	      return this._available ? this._color : null;
	    }
	  }, {
	    key: "rotation",
	    get: function get() {
	      return this._available ? this._rotation : null;
	    }
	  }, {
	    key: "sphericalHarmonics",
	    get: function get() {
	      return this._available ? this._sphericalHarmonics : null;
	    }
	  }]);

	  return XrLightEstimation;
	}(EventHandler);

	var XrTrackedImage = function (_EventHandler) {
	  _inheritsLoose(XrTrackedImage, _EventHandler);

	  function XrTrackedImage(image, width) {
	    var _this;

	    _this = _EventHandler.call(this) || this;
	    _this._image = void 0;
	    _this._width = void 0;
	    _this._bitmap = null;
	    _this._measuredWidth = 0;
	    _this._trackable = false;
	    _this._tracking = false;
	    _this._emulated = false;
	    _this._pose = null;
	    _this._position = new Vec3();
	    _this._rotation = new Quat();
	    _this._image = image;
	    _this._width = width;
	    return _this;
	  }

	  var _proto = XrTrackedImage.prototype;

	  _proto.prepare = function prepare() {
	    var _this2 = this;

	    if (this._bitmap) {
	      return {
	        image: this._bitmap,
	        widthInMeters: this._width
	      };
	    }

	    return createImageBitmap(this._image).then(function (bitmap) {
	      _this2._bitmap = bitmap;
	      return {
	        image: _this2._bitmap,
	        widthInMeters: _this2._width
	      };
	    });
	  };

	  _proto.destroy = function destroy() {
	    this._image = null;
	    this._pose = null;

	    if (this._bitmap) {
	      this._bitmap.close();

	      this._bitmap = null;
	    }
	  };

	  _proto.getPosition = function getPosition() {
	    if (this._pose) this._position.copy(this._pose.transform.position);
	    return this._position;
	  };

	  _proto.getRotation = function getRotation() {
	    if (this._pose) this._rotation.copy(this._pose.transform.orientation);
	    return this._rotation;
	  };

	  _createClass(XrTrackedImage, [{
	    key: "image",
	    get: function get() {
	      return this._image;
	    }
	  }, {
	    key: "width",
	    get: function get() {
	      return this._width;
	    },
	    set: function set(value) {
	      this._width = value;
	    }
	  }, {
	    key: "trackable",
	    get: function get() {
	      return this._trackable;
	    }
	  }, {
	    key: "tracking",
	    get: function get() {
	      return this._tracking;
	    }
	  }, {
	    key: "emulated",
	    get: function get() {
	      return this._emulated;
	    }
	  }]);

	  return XrTrackedImage;
	}(EventHandler);

	var XrImageTracking = function (_EventHandler) {
	  _inheritsLoose(XrImageTracking, _EventHandler);

	  function XrImageTracking(manager) {
	    var _this;

	    _this = _EventHandler.call(this) || this;
	    _this._manager = void 0;
	    _this._supported = platform.browser && !!window.XRImageTrackingResult;
	    _this._available = false;
	    _this._images = [];
	    _this._manager = manager;

	    if (_this._supported) {
	      _this._manager.on('start', _this._onSessionStart, _assertThisInitialized(_this));

	      _this._manager.on('end', _this._onSessionEnd, _assertThisInitialized(_this));
	    }

	    return _this;
	  }

	  var _proto = XrImageTracking.prototype;

	  _proto.add = function add(image, width) {
	    if (!this._supported || this._manager.active) return null;
	    var trackedImage = new XrTrackedImage(image, width);

	    this._images.push(trackedImage);

	    return trackedImage;
	  };

	  _proto.remove = function remove(trackedImage) {
	    if (this._manager.active) return;

	    var ind = this._images.indexOf(trackedImage);

	    if (ind !== -1) {
	      trackedImage.destroy();

	      this._images.splice(ind, 1);
	    }
	  };

	  _proto._onSessionStart = function _onSessionStart() {
	    var _this2 = this;

	    this._manager.session.getTrackedImageScores().then(function (images) {
	      _this2._available = true;

	      for (var i = 0; i < images.length; i++) {
	        _this2._images[i]._trackable = images[i] === 'trackable';
	      }
	    }).catch(function (err) {
	      _this2._available = false;

	      _this2.fire('error', err);
	    });
	  };

	  _proto._onSessionEnd = function _onSessionEnd() {
	    this._available = false;

	    for (var i = 0; i < this._images.length; i++) {
	      var image = this._images[i];
	      image._pose = null;
	      image._measuredWidth = 0;

	      if (image._tracking) {
	        image._tracking = false;
	        image.fire('untracked');
	      }
	    }
	  };

	  _proto.prepareImages = function prepareImages(callback) {
	    if (this._images.length) {
	      Promise.all(this._images.map(function (trackedImage) {
	        return trackedImage.prepare();
	      })).then(function (bitmaps) {
	        callback(null, bitmaps);
	      }).catch(function (err) {
	        callback(err, null);
	      });
	    } else {
	      callback(null, null);
	    }
	  };

	  _proto.update = function update(frame) {
	    if (!this._available) return;
	    var results = frame.getImageTrackingResults();
	    var index = {};

	    for (var i = 0; i < results.length; i++) {
	      index[results[i].index] = results[i];
	      var trackedImage = this._images[results[i].index];
	      trackedImage._emulated = results[i].trackingState === 'emulated';
	      trackedImage._measuredWidth = results[i].measuredWidthInMeters;
	      trackedImage._pose = frame.getPose(results[i].imageSpace, this._manager._referenceSpace);
	    }

	    for (var _i = 0; _i < this._images.length; _i++) {
	      if (this._images[_i]._tracking && !index[_i]) {
	        this._images[_i]._tracking = false;

	        this._images[_i].fire('untracked');
	      } else if (!this._images[_i]._tracking && index[_i]) {
	        this._images[_i]._tracking = true;

	        this._images[_i].fire('tracked');
	      }
	    }
	  };

	  _createClass(XrImageTracking, [{
	    key: "supported",
	    get: function get() {
	      return this._supported;
	    }
	  }, {
	    key: "available",
	    get: function get() {
	      return this._available;
	    }
	  }, {
	    key: "images",
	    get: function get() {
	      return this._images;
	    }
	  }]);

	  return XrImageTracking;
	}(EventHandler);

	var XrDomOverlay = function () {
	  function XrDomOverlay(manager) {
	    this._manager = void 0;
	    this._supported = platform.browser && !!window.XRDOMOverlayState;
	    this._root = null;
	    this._manager = manager;
	  }

	  _createClass(XrDomOverlay, [{
	    key: "supported",
	    get: function get() {
	      return this._supported;
	    }
	  }, {
	    key: "available",
	    get: function get() {
	      return this._supported && this._manager.active && this._manager._session.domOverlayState !== null;
	    }
	  }, {
	    key: "state",
	    get: function get() {
	      if (!this._supported || !this._manager.active || !this._manager._session.domOverlayState) return null;
	      return this._manager._session.domOverlayState.type;
	    }
	  }, {
	    key: "root",
	    get: function get() {
	      return this._root;
	    },
	    set: function set(value) {
	      if (!this._supported || this._manager.active) return;
	      this._root = value;
	    }
	  }]);

	  return XrDomOverlay;
	}();

	var XrDepthSensing = function (_EventHandler) {
	  _inheritsLoose(XrDepthSensing, _EventHandler);

	  function XrDepthSensing(manager) {
	    var _this;

	    _this = _EventHandler.call(this) || this;
	    _this._manager = void 0;
	    _this._available = false;
	    _this._depthInfoCpu = null;
	    _this._depthInfoGpu = null;
	    _this._usage = null;
	    _this._dataFormat = null;
	    _this._matrixDirty = false;
	    _this._matrix = new Mat4();
	    _this._emptyBuffer = new Uint8Array(32);
	    _this._depthBuffer = null;
	    _this._texture = void 0;
	    _this._manager = manager;
	    _this._texture = new Texture(_this._manager.app.graphicsDevice, {
	      format: PIXELFORMAT_L8_A8,
	      mipmaps: false,
	      addressU: ADDRESS_CLAMP_TO_EDGE,
	      addressV: ADDRESS_CLAMP_TO_EDGE,
	      minFilter: FILTER_LINEAR,
	      magFilter: FILTER_LINEAR,
	      name: 'XRDepthSensing'
	    });

	    if (_this.supported) {
	      _this._manager.on('start', _this._onSessionStart, _assertThisInitialized(_this));

	      _this._manager.on('end', _this._onSessionEnd, _assertThisInitialized(_this));
	    }

	    return _this;
	  }

	  var _proto = XrDepthSensing.prototype;

	  _proto.destroy = function destroy() {
	    this._texture.destroy();

	    this._texture = null;
	  };

	  _proto._onSessionStart = function _onSessionStart() {
	    var session = this._manager.session;

	    try {
	      this._usage = session.depthUsage;
	      this._dataFormat = session.depthDataFormat;
	    } catch (ex) {
	      this._usage = null;
	      this._dataFormat = null;
	      this._available = false;
	      this.fire('error', ex);
	    }
	  };

	  _proto._onSessionEnd = function _onSessionEnd() {
	    this._depthInfoCpu = null;
	    this._depthInfoGpu = null;
	    this._usage = null;
	    this._dataFormat = null;

	    if (this._available) {
	      this._available = false;
	      this.fire('unavailable');
	    }

	    this._depthBuffer = null;
	    this._texture._width = 4;
	    this._texture._height = 4;
	    this._texture._levels[0] = this._emptyBuffer;

	    this._texture.upload();
	  };

	  _proto._updateTexture = function _updateTexture() {
	    var depthInfo = this._depthInfoCpu || this._depthInfoGpu;

	    if (depthInfo) {
	      var resized = false;

	      if (depthInfo.width !== this._texture.width || depthInfo.height !== this._texture.height) {
	        this._texture._width = depthInfo.width;
	        this._texture._height = depthInfo.height;
	        this._matrixDirty = true;
	        resized = true;
	      }

	      if (this._depthInfoCpu) {
	        var dataBuffer = this._depthInfoCpu.data;
	        this._depthBuffer = new Uint8Array(dataBuffer);
	        this._texture._levels[0] = this._depthBuffer;

	        this._texture.upload();
	      } else if (this._depthInfoGpu) {
	        this._texture._levels[0] = this._depthInfoGpu.texture;

	        this._texture.upload();
	      }

	      if (resized) this.fire('resize', depthInfo.width, depthInfo.height);
	    } else if (this._depthBuffer) {
	      this._depthBuffer = null;
	      this._texture._width = 4;
	      this._texture._height = 4;
	      this._texture._levels[0] = this._emptyBuffer;

	      this._texture.upload();
	    }
	  };

	  _proto.update = function update(frame, view) {
	    if (!this._usage) return;
	    var depthInfoCpu = null;
	    var depthInfoGpu = null;

	    if (this._usage === XRDEPTHSENSINGUSAGE_CPU && view) {
	      depthInfoCpu = frame.getDepthInformation(view);
	    } else if (this._usage === XRDEPTHSENSINGUSAGE_GPU && view) {
	      depthInfoGpu = frame.getDepthInformation(view);
	    }

	    if (this._depthInfoCpu && !depthInfoCpu || !this._depthInfoCpu && depthInfoCpu || this.depthInfoGpu && !depthInfoGpu || !this._depthInfoGpu && depthInfoGpu) {
	      this._matrixDirty = true;
	    }

	    this._depthInfoCpu = depthInfoCpu;
	    this._depthInfoGpu = depthInfoGpu;

	    this._updateTexture();

	    if (this._matrixDirty) {
	      this._matrixDirty = false;
	      var depthInfo = this._depthInfoCpu || this._depthInfoGpu;

	      if (depthInfo) {
	        this._matrix.data.set(depthInfo.normDepthBufferFromNormView.matrix);
	      } else {
	        this._matrix.setIdentity();
	      }
	    }

	    if ((this._depthInfoCpu || this._depthInfoGpu) && !this._available) {
	      this._available = true;
	      this.fire('available');
	    } else if (!this._depthInfoCpu && !this._depthInfoGpu && this._available) {
	      this._available = false;
	      this.fire('unavailable');
	    }
	  };

	  _proto.getDepth = function getDepth(u, v) {
	    if (!this._depthInfoCpu) return null;
	    return this._depthInfoCpu.getDepthInMeters(u, v);
	  };

	  _createClass(XrDepthSensing, [{
	    key: "supported",
	    get: function get() {
	      return platform.browser && !!window.XRDepthInformation;
	    }
	  }, {
	    key: "available",
	    get: function get() {
	      return this._available;
	    }
	  }, {
	    key: "usage",
	    get: function get() {
	      return this._usage;
	    }
	  }, {
	    key: "dataFormat",
	    get: function get() {
	      return this._dataFormat;
	    }
	  }, {
	    key: "width",
	    get: function get() {
	      var depthInfo = this._depthInfoCpu || this._depthInfoGpu;
	      return depthInfo && depthInfo.width || 0;
	    }
	  }, {
	    key: "height",
	    get: function get() {
	      var depthInfo = this._depthInfoCpu || this._depthInfoGpu;
	      return depthInfo && depthInfo.height || 0;
	    }
	  }, {
	    key: "texture",
	    get: function get() {
	      return this._texture;
	    }
	  }, {
	    key: "uvMatrix",
	    get: function get() {
	      return this._matrix;
	    }
	  }, {
	    key: "rawValueToMeters",
	    get: function get() {
	      var depthInfo = this._depthInfoCpu || this._depthInfoGpu;
	      return depthInfo && depthInfo.rawValueToMeters || 0;
	    }
	  }]);

	  return XrDepthSensing;
	}(EventHandler);

	var ids = 0;

	var XrPlane = function (_EventHandler) {
	  _inheritsLoose(XrPlane, _EventHandler);

	  function XrPlane(planeDetection, xrPlane) {
	    var _this;

	    _this = _EventHandler.call(this) || this;
	    _this._id = void 0;
	    _this._planeDetection = void 0;
	    _this._xrPlane = void 0;
	    _this._lastChangedTime = void 0;
	    _this._orientation = void 0;
	    _this._position = new Vec3();
	    _this._rotation = new Quat();
	    _this._id = ++ids;
	    _this._planeDetection = planeDetection;
	    _this._xrPlane = xrPlane;
	    _this._lastChangedTime = xrPlane.lastChangedTime;
	    _this._orientation = xrPlane.orientation;
	    return _this;
	  }

	  var _proto = XrPlane.prototype;

	  _proto.destroy = function destroy() {
	    this.fire('remove');
	  };

	  _proto.update = function update(frame) {
	    var manager = this._planeDetection._manager;
	    var pose = frame.getPose(this._xrPlane.planeSpace, manager._referenceSpace);

	    if (pose) {
	      this._position.copy(pose.transform.position);

	      this._rotation.copy(pose.transform.orientation);
	    }

	    if (this._lastChangedTime !== this._xrPlane.lastChangedTime) {
	      this._lastChangedTime = this._xrPlane.lastChangedTime;
	      this.fire('change');
	    }
	  };

	  _proto.getPosition = function getPosition() {
	    return this._position;
	  };

	  _proto.getRotation = function getRotation() {
	    return this._rotation;
	  };

	  _createClass(XrPlane, [{
	    key: "id",
	    get: function get() {
	      return this._id;
	    }
	  }, {
	    key: "orientation",
	    get: function get() {
	      return this._orientation;
	    }
	  }, {
	    key: "points",
	    get: function get() {
	      return this._xrPlane.polygon;
	    }
	  }]);

	  return XrPlane;
	}(EventHandler);

	var XrPlaneDetection = function (_EventHandler) {
	  _inheritsLoose(XrPlaneDetection, _EventHandler);

	  function XrPlaneDetection(manager) {
	    var _this;

	    _this = _EventHandler.call(this) || this;
	    _this._manager = void 0;
	    _this._supported = platform.browser && !!window.XRPlane;
	    _this._available = false;
	    _this._planesIndex = new Map();
	    _this._planes = null;
	    _this._manager = manager;

	    if (_this._supported) {
	      _this._manager.on('end', _this._onSessionEnd, _assertThisInitialized(_this));
	    }

	    return _this;
	  }

	  var _proto = XrPlaneDetection.prototype;

	  _proto._onSessionEnd = function _onSessionEnd() {
	    if (this._planes) {
	      for (var i = 0; i < this._planes.length; i++) {
	        this._planes[i].destroy();
	      }
	    }

	    this._planesIndex.clear();

	    this._planes = null;

	    if (this._available) {
	      this._available = false;
	      this.fire('unavailable');
	    }
	  };

	  _proto.update = function update(frame) {
	    var detectedPlanes;

	    if (!this._available) {
	      try {
	        detectedPlanes = frame.detectedPlanes;
	        this._planes = [];
	        this._available = true;
	        this.fire('available');
	      } catch (ex) {
	        return;
	      }
	    } else {
	      detectedPlanes = frame.detectedPlanes;
	    }

	    for (var _iterator = _createForOfIteratorHelperLoose(this._planesIndex), _step; !(_step = _iterator()).done;) {
	      var _step$value = _step.value,
	          xrPlane = _step$value[0],
	          plane = _step$value[1];
	      if (detectedPlanes.has(xrPlane)) continue;

	      this._planesIndex.delete(xrPlane);

	      this._planes.splice(this._planes.indexOf(plane), 1);

	      plane.destroy();
	      this.fire('remove', plane);
	    }

	    for (var _iterator2 = _createForOfIteratorHelperLoose(detectedPlanes), _step2; !(_step2 = _iterator2()).done;) {
	      var _xrPlane = _step2.value;

	      var _plane = this._planesIndex.get(_xrPlane);

	      if (!_plane) {
	        _plane = new XrPlane(this, _xrPlane);

	        this._planesIndex.set(_xrPlane, _plane);

	        this._planes.push(_plane);

	        _plane.update(frame);

	        this.fire('add', _plane);
	      } else {
	        _plane.update(frame);
	      }
	    }
	  };

	  _createClass(XrPlaneDetection, [{
	    key: "supported",
	    get: function get() {
	      return this._supported;
	    }
	  }, {
	    key: "available",
	    get: function get() {
	      return this._available;
	    }
	  }, {
	    key: "planes",
	    get: function get() {
	      return this._planes;
	    }
	  }]);

	  return XrPlaneDetection;
	}(EventHandler);

	var XrManager = function (_EventHandler) {
	  _inheritsLoose(XrManager, _EventHandler);

	  function XrManager(app) {
	    var _this;

	    _this = _EventHandler.call(this) || this;
	    _this.app = void 0;
	    _this._supported = platform.browser && !!navigator.xr;
	    _this._available = {};
	    _this._type = null;
	    _this._spaceType = null;
	    _this._session = null;
	    _this._baseLayer = null;
	    _this._referenceSpace = null;
	    _this.depthSensing = void 0;
	    _this.domOverlay = void 0;
	    _this.hitTest = void 0;
	    _this.imageTracking = void 0;
	    _this.planeDetection = void 0;
	    _this.input = void 0;
	    _this.lightEstimation = void 0;
	    _this._camera = null;
	    _this.views = [];
	    _this.viewsPool = [];
	    _this._localPosition = new Vec3();
	    _this._localRotation = new Quat();
	    _this._depthNear = 0.1;
	    _this._depthFar = 1000;
	    _this._width = 0;
	    _this._height = 0;
	    _this.app = app;
	    _this._available[XRTYPE_INLINE] = false;
	    _this._available[XRTYPE_VR] = false;
	    _this._available[XRTYPE_AR] = false;
	    _this.depthSensing = new XrDepthSensing(_assertThisInitialized(_this));
	    _this.domOverlay = new XrDomOverlay(_assertThisInitialized(_this));
	    _this.hitTest = new XrHitTest(_assertThisInitialized(_this));
	    _this.imageTracking = new XrImageTracking(_assertThisInitialized(_this));
	    _this.planeDetection = new XrPlaneDetection(_assertThisInitialized(_this));
	    _this.input = new XrInput(_assertThisInitialized(_this));
	    _this.lightEstimation = new XrLightEstimation(_assertThisInitialized(_this));

	    if (_this._supported) {
	      navigator.xr.addEventListener('devicechange', function () {
	        _this._deviceAvailabilityCheck();
	      });

	      _this._deviceAvailabilityCheck();
	    }

	    return _this;
	  }

	  var _proto = XrManager.prototype;

	  _proto.destroy = function destroy() {
	    this.depthSensing.destroy();
	    this.depthSensing = null;
	  };

	  _proto.start = function start(camera, type, spaceType, options) {
	    var _this2 = this;

	    var callback = options;
	    if (typeof options === 'object') callback = options.callback;

	    if (!this._available[type]) {
	      if (callback) callback(new Error('XR is not available'));
	      return;
	    }

	    if (this._session) {
	      if (callback) callback(new Error('XR session is already started'));
	      return;
	    }

	    this._camera = camera;
	    this._camera.camera.xr = this;
	    this._type = type;
	    this._spaceType = spaceType;

	    this._setClipPlanes(camera.nearClip, camera.farClip);

	    var opts = {
	      requiredFeatures: [spaceType],
	      optionalFeatures: []
	    };

	    if (type === XRTYPE_AR) {
	      opts.optionalFeatures.push('light-estimation');
	      opts.optionalFeatures.push('hit-test');

	      if (options) {
	        if (options.imageTracking && this.imageTracking.supported) opts.optionalFeatures.push('image-tracking');
	        if (options.planeDetection) opts.optionalFeatures.push('plane-detection');
	      }

	      if (this.domOverlay.supported && this.domOverlay.root) {
	        opts.optionalFeatures.push('dom-overlay');
	        opts.domOverlay = {
	          root: this.domOverlay.root
	        };
	      }

	      if (options && options.depthSensing && this.depthSensing.supported) {
	        opts.optionalFeatures.push('depth-sensing');
	        var usagePreference = [XRDEPTHSENSINGUSAGE_CPU];
	        var dataFormatPreference = [XRDEPTHSENSINGFORMAT_L8A8];

	        if (options.depthSensing.usagePreference) {
	          var ind = usagePreference.indexOf(options.depthSensing.usagePreference);
	          if (ind !== -1) usagePreference.splice(ind, 1);
	          usagePreference.unshift(options.depthSensing.usagePreference);
	        }

	        if (options.depthSensing.dataFormatPreference) {
	          var _ind = dataFormatPreference.indexOf(options.depthSensing.dataFormatPreference);

	          if (_ind !== -1) dataFormatPreference.splice(_ind, 1);
	          dataFormatPreference.unshift(options.depthSensing.dataFormatPreference);
	        }

	        opts.depthSensing = {
	          usagePreference: usagePreference,
	          dataFormatPreference: dataFormatPreference
	        };
	      }
	    } else if (type === XRTYPE_VR) {
	      opts.optionalFeatures.push('hand-tracking');
	    }

	    if (options && options.optionalFeatures) opts.optionalFeatures = opts.optionalFeatures.concat(options.optionalFeatures);

	    if (this.imageTracking.supported && this.imageTracking.images.length) {
	      this.imageTracking.prepareImages(function (err, trackedImages) {
	        if (err) {
	          if (callback) callback(err);

	          _this2.fire('error', err);

	          return;
	        }

	        if (trackedImages !== null) opts.trackedImages = trackedImages;

	        _this2._onStartOptionsReady(type, spaceType, opts, callback);
	      });
	    } else {
	      this._onStartOptionsReady(type, spaceType, opts, callback);
	    }
	  };

	  _proto._onStartOptionsReady = function _onStartOptionsReady(type, spaceType, options, callback) {
	    var _this3 = this;

	    navigator.xr.requestSession(type, options).then(function (session) {
	      _this3._onSessionStart(session, spaceType, callback);
	    }).catch(function (ex) {
	      _this3._camera.camera.xr = null;
	      _this3._camera = null;
	      _this3._type = null;
	      _this3._spaceType = null;
	      if (callback) callback(ex);

	      _this3.fire('error', ex);
	    });
	  };

	  _proto.end = function end(callback) {
	    if (!this._session) {
	      if (callback) callback(new Error('XR Session is not initialized'));
	      return;
	    }

	    if (callback) this.once('end', callback);

	    this._session.end();
	  };

	  _proto.isAvailable = function isAvailable(type) {
	    return this._available[type];
	  };

	  _proto._deviceAvailabilityCheck = function _deviceAvailabilityCheck() {
	    for (var key in this._available) {
	      this._sessionSupportCheck(key);
	    }
	  };

	  _proto._sessionSupportCheck = function _sessionSupportCheck(type) {
	    var _this4 = this;

	    navigator.xr.isSessionSupported(type).then(function (available) {
	      if (_this4._available[type] === available) return;
	      _this4._available[type] = available;

	      _this4.fire('available', type, available);

	      _this4.fire('available:' + type, available);
	    }).catch(function (ex) {
	      _this4.fire('error', ex);
	    });
	  };

	  _proto._onSessionStart = function _onSessionStart(session, spaceType, callback) {
	    var _this5 = this;

	    var failed = false;
	    this._session = session;

	    var onVisibilityChange = function onVisibilityChange() {
	      _this5.fire('visibility:change', session.visibilityState);
	    };

	    var onClipPlanesChange = function onClipPlanesChange() {
	      _this5._setClipPlanes(_this5._camera.nearClip, _this5._camera.farClip);
	    };

	    var onEnd = function onEnd() {
	      if (_this5._camera) {
	        _this5._camera.off('set_nearClip', onClipPlanesChange);

	        _this5._camera.off('set_farClip', onClipPlanesChange);

	        _this5._camera.camera.xr = null;
	        _this5._camera = null;
	      }

	      session.removeEventListener('end', onEnd);
	      session.removeEventListener('visibilitychange', onVisibilityChange);
	      if (!failed) _this5.fire('end');
	      _this5._session = null;
	      _this5._referenceSpace = null;
	      _this5.views = [];
	      _this5._width = 0;
	      _this5._height = 0;
	      _this5._type = null;
	      _this5._spaceType = null;

	      _this5.app.tick();
	    };

	    session.addEventListener('end', onEnd);
	    session.addEventListener('visibilitychange', onVisibilityChange);

	    this._camera.on('set_nearClip', onClipPlanesChange);

	    this._camera.on('set_farClip', onClipPlanesChange);

	    this._baseLayer = new XRWebGLLayer(session, this.app.graphicsDevice.gl, {
	      alpha: true,
	      depth: true,
	      stencil: true
	    });
	    session.updateRenderState({
	      baseLayer: this._baseLayer,
	      depthNear: this._depthNear,
	      depthFar: this._depthFar
	    });
	    session.requestReferenceSpace(spaceType).then(function (referenceSpace) {
	      _this5._referenceSpace = referenceSpace;

	      _this5.app.tick();

	      if (callback) callback(null);

	      _this5.fire('start');
	    }).catch(function (ex) {
	      failed = true;
	      session.end();
	      if (callback) callback(ex);

	      _this5.fire('error', ex);
	    });
	  };

	  _proto._setClipPlanes = function _setClipPlanes(near, far) {
	    if (this._depthNear === near && this._depthFar === far) return;
	    this._depthNear = near;
	    this._depthFar = far;
	    if (!this._session) return;

	    this._session.updateRenderState({
	      depthNear: this._depthNear,
	      depthFar: this._depthFar
	    });
	  };

	  _proto.update = function update(frame) {
	    if (!this._session) return;
	    var width = frame.session.renderState.baseLayer.framebufferWidth;
	    var height = frame.session.renderState.baseLayer.framebufferHeight;

	    if (this._width !== width || this._height !== height) {
	      this._width = width;
	      this._height = height;
	      this.app.graphicsDevice.setResolution(width, height);
	    }

	    var pose = frame.getViewerPose(this._referenceSpace);
	    var lengthNew = pose ? pose.views.length : 0;

	    if (lengthNew > this.views.length) {
	      for (var i = 0; i <= lengthNew - this.views.length; i++) {
	        var view = this.viewsPool.pop();

	        if (!view) {
	          view = {
	            viewport: new Vec4(),
	            projMat: new Mat4(),
	            viewMat: new Mat4(),
	            viewOffMat: new Mat4(),
	            viewInvMat: new Mat4(),
	            viewInvOffMat: new Mat4(),
	            projViewOffMat: new Mat4(),
	            viewMat3: new Mat3(),
	            position: new Float32Array(3),
	            rotation: new Quat()
	          };
	        }

	        this.views.push(view);
	      }
	    } else if (lengthNew <= this.views.length) {
	      for (var _i = 0; _i < this.views.length - lengthNew; _i++) {
	        this.viewsPool.push(this.views.pop());
	      }
	    }

	    if (pose) {
	      var posePosition = pose.transform.position;
	      var poseOrientation = pose.transform.orientation;

	      this._localPosition.set(posePosition.x, posePosition.y, posePosition.z);

	      this._localRotation.set(poseOrientation.x, poseOrientation.y, poseOrientation.z, poseOrientation.w);

	      var layer = frame.session.renderState.baseLayer;

	      for (var _i2 = 0; _i2 < pose.views.length; _i2++) {
	        var viewRaw = pose.views[_i2];
	        var _view = this.views[_i2];
	        var viewport = layer.getViewport(viewRaw);
	        _view.viewport.x = viewport.x;
	        _view.viewport.y = viewport.y;
	        _view.viewport.z = viewport.width;
	        _view.viewport.w = viewport.height;

	        _view.projMat.set(viewRaw.projectionMatrix);

	        _view.viewMat.set(viewRaw.transform.inverse.matrix);

	        _view.viewInvMat.set(viewRaw.transform.matrix);
	      }
	    }

	    this._camera.camera._node.setLocalPosition(this._localPosition);

	    this._camera.camera._node.setLocalRotation(this._localRotation);

	    this.input.update(frame);

	    if (this._type === XRTYPE_AR) {
	      if (this.hitTest.supported) this.hitTest.update(frame);
	      if (this.lightEstimation.supported) this.lightEstimation.update(frame);
	      if (this.depthSensing.supported) this.depthSensing.update(frame, pose && pose.views[0]);
	      if (this.imageTracking.supported) this.imageTracking.update(frame);
	      if (this.planeDetection.supported) this.planeDetection.update(frame);
	    }

	    this.fire('update', frame);
	  };

	  _createClass(XrManager, [{
	    key: "supported",
	    get: function get() {
	      return this._supported;
	    }
	  }, {
	    key: "active",
	    get: function get() {
	      return !!this._session;
	    }
	  }, {
	    key: "type",
	    get: function get() {
	      return this._type;
	    }
	  }, {
	    key: "spaceType",
	    get: function get() {
	      return this._spaceType;
	    }
	  }, {
	    key: "session",
	    get: function get() {
	      return this._session;
	    }
	  }, {
	    key: "camera",
	    get: function get() {
	      return this._camera ? this._camera.entity : null;
	    }
	  }, {
	    key: "visibilityState",
	    get: function get() {
	      if (!this._session) return null;
	      return this._session.visibilityState;
	    }
	  }]);

	  return XrManager;
	}(EventHandler);

	var Application = function (_AppBase) {
	  _inheritsLoose(Application, _AppBase);

	  function Application(canvas, options) {
	    var _this;

	    if (options === void 0) {
	      options = {};
	    }

	    _this = _AppBase.call(this, canvas) || this;
	    var appOptions = new AppOptions();
	    appOptions.graphicsDevice = _this.createDevice(canvas, options);

	    _this.addComponentSystems(appOptions);

	    _this.addResourceHandles(appOptions);

	    appOptions.elementInput = options.elementInput;
	    appOptions.keyboard = options.keyboard;
	    appOptions.mouse = options.mouse;
	    appOptions.touch = options.touch;
	    appOptions.gamepads = options.gamepads;
	    appOptions.scriptPrefix = options.scriptPrefix;
	    appOptions.assetPrefix = options.assetPrefix;
	    appOptions.scriptsOrder = options.scriptsOrder;
	    appOptions.soundManager = new SoundManager(options);
	    appOptions.lightmapper = Lightmapper;
	    appOptions.batchManager = BatchManager;
	    appOptions.xr = XrManager;

	    _this.init(appOptions);

	    return _this;
	  }

	  var _proto = Application.prototype;

	  _proto.createDevice = function createDevice(canvas, options) {
	    if (!options.graphicsDeviceOptions) {
	      options.graphicsDeviceOptions = {};
	    }

	    if (platform.browser && !!navigator.xr) {
	      options.graphicsDeviceOptions.xrCompatible = true;
	    }

	    options.graphicsDeviceOptions.alpha = options.graphicsDeviceOptions.alpha || false;
	    return new WebglGraphicsDevice(canvas, options.graphicsDeviceOptions);
	  };

	  _proto.addComponentSystems = function addComponentSystems(appOptions) {
	    appOptions.componentSystems = [RigidBodyComponentSystem, CollisionComponentSystem, JointComponentSystem, AnimationComponentSystem, AnimComponentSystem, ModelComponentSystem, RenderComponentSystem, CameraComponentSystem, LightComponentSystem, script.legacy ? ScriptLegacyComponentSystem : ScriptComponentSystem, AudioSourceComponentSystem, SoundComponentSystem, AudioListenerComponentSystem, ParticleSystemComponentSystem, ScreenComponentSystem, ElementComponentSystem, ButtonComponentSystem, ScrollViewComponentSystem, ScrollbarComponentSystem, SpriteComponentSystem, LayoutGroupComponentSystem, LayoutChildComponentSystem, ZoneComponentSystem];
	  };

	  _proto.addResourceHandles = function addResourceHandles(appOptions) {
	    appOptions.resourceHandlers = [RenderHandler, AnimationHandler, AnimClipHandler, AnimStateGraphHandler, ModelHandler, MaterialHandler, TextureHandler, TextHandler, JsonHandler, AudioHandler, ScriptHandler, SceneHandler, CubemapHandler, HtmlHandler, CssHandler, ShaderHandler, HierarchyHandler, FolderHandler, FontHandler, BinaryHandler, TextureAtlasHandler, SpriteHandler, TemplateHandler, ContainerHandler];
	  };

	  return Application;
	}(AppBase);

	var log = {
	  write: function write(text) {
	    console.log(text);
	  },
	  open: function open() {
	    log.write('Powered by PlayCanvas ' + version + ' ' + revision);
	  },
	  info: function info(text) {
	    console.info('INFO:    ' + text);
	  },
	  debug: function debug(text) {
	    console.debug('DEBUG:   ' + text);
	  },
	  error: function error(text) {
	    console.error('ERROR:   ' + text);
	  },
	  warning: function warning(text) {
	    console.warn('WARNING: ' + text);
	  },
	  alert: function (_alert) {
	    function alert(_x) {
	      return _alert.apply(this, arguments);
	    }

	    alert.toString = function () {
	      return _alert.toString();
	    };

	    return alert;
	  }(function (text) {
	    log.write('ALERT:   ' + text);
	    alert(text);
	  }),
	  assert: function assert(condition, text) {
	    if (condition === false) {
	      log.write('ASSERT:  ' + text);
	    }
	  }
	};

	string.endsWith = function (s, subs) {
	  return s.endsWith(subs);
	};

	string.startsWith = function (s, subs) {
	  return s.startsWith(subs);
	};

	var time = {
	  now: now,
	  Timer: Timer
	};
	Object.defineProperty(Color.prototype, 'data', {
	  get: function get() {
	    if (!this._data) {
	      this._data = new Float32Array(4);
	    }

	    this._data[0] = this.r;
	    this._data[1] = this.g;
	    this._data[2] = this.b;
	    this._data[3] = this.a;
	    return this._data;
	  }
	});
	Object.defineProperty(Color.prototype, 'data3', {
	  get: function get() {
	    if (!this._data3) {
	      this._data3 = new Float32Array(3);
	    }

	    this._data3[0] = this.r;
	    this._data3[1] = this.g;
	    this._data3[2] = this.b;
	    return this._data3;
	  }
	});
	function inherits(Self, Super) {
	  var Temp = function Temp() {};

	  var Func = function Func(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {
	    Super.call(this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
	    Self.call(this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
	  };

	  Func._super = Super.prototype;
	  Temp.prototype = Super.prototype;
	  Func.prototype = new Temp();
	  return Func;
	}
	function makeArray(arr) {
	  return Array.prototype.slice.call(arr);
	}
	math.INV_LOG2 = Math.LOG2E;
	math.intToBytes = math.intToBytes32;
	math.bytesToInt = math.bytesToInt32;
	Object.defineProperty(Vec2.prototype, 'data', {
	  get: function get() {
	    if (!this._data) {
	      this._data = new Float32Array(2);
	    }

	    this._data[0] = this.x;
	    this._data[1] = this.y;
	    return this._data;
	  }
	});
	Vec2.prototype.scale = Vec2.prototype.mulScalar;
	Object.defineProperty(Vec3.prototype, 'data', {
	  get: function get() {
	    if (!this._data) {
	      this._data = new Float32Array(3);
	    }

	    this._data[0] = this.x;
	    this._data[1] = this.y;
	    this._data[2] = this.z;
	    return this._data;
	  }
	});
	Vec3.prototype.scale = Vec3.prototype.mulScalar;
	Object.defineProperty(Vec4.prototype, 'data', {
	  get: function get() {
	    if (!this._data) {
	      this._data = new Float32Array(4);
	    }

	    this._data[0] = this.x;
	    this._data[1] = this.y;
	    this._data[2] = this.z;
	    this._data[3] = this.w;
	    return this._data;
	  }
	});
	Vec4.prototype.scale = Vec4.prototype.mulScalar;
	var shape = {
	  Aabb: BoundingBox,
	  Sphere: BoundingSphere,
	  Plane: Plane
	};
	BoundingSphere.prototype.intersectRay = BoundingSphere.prototype.intersectsRay;

	Frustum.prototype.update = function (projectionMatrix, viewMatrix) {
	  var viewProj = new Mat4();
	  viewProj.mul2(projectionMatrix, viewMatrix);
	  this.setFromMat4(viewProj);
	};

	var ELEMENTTYPE_INT8 = TYPE_INT8;
	var ELEMENTTYPE_UINT8 = TYPE_UINT8;
	var ELEMENTTYPE_INT16 = TYPE_INT16;
	var ELEMENTTYPE_UINT16 = TYPE_UINT16;
	var ELEMENTTYPE_INT32 = TYPE_INT32;
	var ELEMENTTYPE_UINT32 = TYPE_UINT32;
	var ELEMENTTYPE_FLOAT32 = TYPE_FLOAT32;
	function UnsupportedBrowserError(message) {
	  this.name = 'UnsupportedBrowserError';
	  this.message = message || '';
	}
	UnsupportedBrowserError.prototype = Error.prototype;
	function ContextCreationError(message) {
	  this.name = 'ContextCreationError';
	  this.message = message || '';
	}
	ContextCreationError.prototype = Error.prototype;
	var programlib = {
	  begin: begin,
	  dummyFragmentCode: dummyFragmentCode,
	  end: end,
	  fogCode: fogCode,
	  gammaCode: gammaCode,
	  precisionCode: precisionCode,
	  skinCode: skinCode,
	  tonemapCode: tonemapCode,
	  versionCode: versionCode
	};
	var gfx = {
	  ADDRESS_CLAMP_TO_EDGE: ADDRESS_CLAMP_TO_EDGE,
	  ADDRESS_MIRRORED_REPEAT: ADDRESS_MIRRORED_REPEAT,
	  ADDRESS_REPEAT: ADDRESS_REPEAT,
	  BLENDMODE_ZERO: BLENDMODE_ZERO,
	  BLENDMODE_ONE: BLENDMODE_ONE,
	  BLENDMODE_SRC_COLOR: BLENDMODE_SRC_COLOR,
	  BLENDMODE_ONE_MINUS_SRC_COLOR: BLENDMODE_ONE_MINUS_SRC_COLOR,
	  BLENDMODE_DST_COLOR: BLENDMODE_DST_COLOR,
	  BLENDMODE_ONE_MINUS_DST_COLOR: BLENDMODE_ONE_MINUS_DST_COLOR,
	  BLENDMODE_SRC_ALPHA: BLENDMODE_SRC_ALPHA,
	  BLENDMODE_SRC_ALPHA_SATURATE: BLENDMODE_SRC_ALPHA_SATURATE,
	  BLENDMODE_ONE_MINUS_SRC_ALPHA: BLENDMODE_ONE_MINUS_SRC_ALPHA,
	  BLENDMODE_DST_ALPHA: BLENDMODE_DST_ALPHA,
	  BLENDMODE_ONE_MINUS_DST_ALPHA: BLENDMODE_ONE_MINUS_DST_ALPHA,
	  BUFFER_STATIC: BUFFER_STATIC,
	  BUFFER_DYNAMIC: BUFFER_DYNAMIC,
	  BUFFER_STREAM: BUFFER_STREAM,
	  CULLFACE_NONE: CULLFACE_NONE,
	  CULLFACE_BACK: CULLFACE_BACK,
	  CULLFACE_FRONT: CULLFACE_FRONT,
	  CULLFACE_FRONTANDBACK: CULLFACE_FRONTANDBACK,
	  ELEMENTTYPE_INT8: TYPE_INT8,
	  ELEMENTTYPE_UINT8: TYPE_UINT8,
	  ELEMENTTYPE_INT16: TYPE_INT16,
	  ELEMENTTYPE_UINT16: TYPE_UINT16,
	  ELEMENTTYPE_INT32: TYPE_INT32,
	  ELEMENTTYPE_UINT32: TYPE_UINT32,
	  ELEMENTTYPE_FLOAT32: TYPE_FLOAT32,
	  FILTER_NEAREST: FILTER_NEAREST,
	  FILTER_LINEAR: FILTER_LINEAR,
	  FILTER_NEAREST_MIPMAP_NEAREST: FILTER_NEAREST_MIPMAP_NEAREST,
	  FILTER_NEAREST_MIPMAP_LINEAR: FILTER_NEAREST_MIPMAP_LINEAR,
	  FILTER_LINEAR_MIPMAP_NEAREST: FILTER_LINEAR_MIPMAP_NEAREST,
	  FILTER_LINEAR_MIPMAP_LINEAR: FILTER_LINEAR_MIPMAP_LINEAR,
	  INDEXFORMAT_UINT8: INDEXFORMAT_UINT8,
	  INDEXFORMAT_UINT16: INDEXFORMAT_UINT16,
	  INDEXFORMAT_UINT32: INDEXFORMAT_UINT32,
	  PIXELFORMAT_R5_G6_B5: PIXELFORMAT_R5_G6_B5,
	  PIXELFORMAT_R8_G8_B8: PIXELFORMAT_R8_G8_B8,
	  PIXELFORMAT_R8_G8_B8_A8: PIXELFORMAT_R8_G8_B8_A8,
	  PRIMITIVE_POINTS: PRIMITIVE_POINTS,
	  PRIMITIVE_LINES: PRIMITIVE_LINES,
	  PRIMITIVE_LINELOOP: PRIMITIVE_LINELOOP,
	  PRIMITIVE_LINESTRIP: PRIMITIVE_LINESTRIP,
	  PRIMITIVE_TRIANGLES: PRIMITIVE_TRIANGLES,
	  PRIMITIVE_TRISTRIP: PRIMITIVE_TRISTRIP,
	  PRIMITIVE_TRIFAN: PRIMITIVE_TRIFAN,
	  SEMANTIC_POSITION: SEMANTIC_POSITION,
	  SEMANTIC_NORMAL: SEMANTIC_NORMAL,
	  SEMANTIC_COLOR: SEMANTIC_COLOR,
	  SEMANTIC_TEXCOORD: SEMANTIC_TEXCOORD,
	  SEMANTIC_TEXCOORD0: SEMANTIC_TEXCOORD0,
	  SEMANTIC_TEXCOORD1: SEMANTIC_TEXCOORD1,
	  SEMANTIC_ATTR0: SEMANTIC_ATTR0,
	  SEMANTIC_ATTR1: SEMANTIC_ATTR1,
	  SEMANTIC_ATTR2: SEMANTIC_ATTR2,
	  SEMANTIC_ATTR3: SEMANTIC_ATTR3,
	  TEXTURELOCK_READ: TEXTURELOCK_READ,
	  TEXTURELOCK_WRITE: TEXTURELOCK_WRITE,
	  drawQuadWithShader: drawQuadWithShader,
	  programlib: programlib,
	  shaderChunks: shaderChunks,
	  ContextCreationError: ContextCreationError,
	  Device: GraphicsDevice,
	  IndexBuffer: IndexBuffer,
	  ProgramLibrary: ProgramLibrary,
	  RenderTarget: RenderTarget,
	  ScopeId: ScopeId,
	  Shader: Shader,
	  ShaderInput: ShaderInput,
	  Texture: Texture,
	  UnsupportedBrowserError: UnsupportedBrowserError,
	  VertexBuffer: VertexBuffer,
	  VertexFormat: VertexFormat,
	  VertexIterator: VertexIterator
	};
	var posteffect = {
	  createFullscreenQuad: createFullscreenQuad,
	  drawFullscreenQuad: drawFullscreenQuad,
	  PostEffect: PostEffect$1,
	  PostEffectQueue: PostEffectQueue
	};
	Object.defineProperty(shaderChunks, 'transformSkinnedVS', {
	  get: function get() {
	    return '#define SKIN\n' + shaderChunks.transformVS;
	  }
	});
	var deprecatedChunks = {
	  'ambientPrefilteredCube.frag': 'ambientEnv.frag',
	  'ambientPrefilteredCubeLod.frag': 'ambientEnv.frag',
	  'dpAtlasQuad.frag': null,
	  'genParaboloid.frag': null,
	  'prefilterCubemap.frag': null,
	  'reflectionDpAtlas.frag': 'reflectionEnv.frag',
	  'reflectionPrefilteredCube.frag': 'reflectionEnv.frag',
	  'reflectionPrefilteredCubeLod.frag': 'reflectionEnv.frag'
	};
	Object.keys(deprecatedChunks).forEach(function (chunkName) {
	  deprecatedChunks[chunkName];
	  Object.defineProperty(shaderChunks, chunkName, {
	    get: function get() {
	      return null;
	    },
	    set: function set() {}
	  });
	});
	Object.defineProperties(RenderTarget.prototype, {
	  _glFrameBuffer: {
	    get: function get() {
	      return this.impl._glFrameBuffer;
	    },
	    set: function set(rgbm) {}
	  }
	});

	VertexFormat.prototype.update = function () {};

	Object.defineProperties(Texture.prototype, {
	  rgbm: {
	    get: function get() {
	      return this.type === TEXTURETYPE_RGBM;
	    },
	    set: function set(rgbm) {
	      this.type = rgbm ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT;
	    }
	  },
	  swizzleGGGR: {
	    get: function get() {
	      return this.type === TEXTURETYPE_SWIZZLEGGGR;
	    },
	    set: function set(swizzleGGGR) {
	      this.type = swizzleGGGR ? TEXTURETYPE_SWIZZLEGGGR : TEXTURETYPE_DEFAULT;
	    }
	  },
	  _glTexture: {
	    get: function get() {
	      return this.impl._glTexture;
	    }
	  }
	});
	var PhongMaterial = StandardMaterial;
	var scene = {
	  partitionSkin: partitionSkin,
	  procedural: {
	    calculateTangents: calculateTangents,
	    createMesh: createMesh$1,
	    createTorus: createTorus,
	    createCylinder: createCylinder,
	    createCapsule: createCapsule,
	    createCone: createCone,
	    createSphere: createSphere,
	    createPlane: createPlane,
	    createBox: createBox
	  },
	  BasicMaterial: BasicMaterial,
	  Command: Command,
	  ForwardRenderer: ForwardRenderer,
	  GraphNode: GraphNode,
	  Material: Material,
	  Mesh: Mesh,
	  MeshInstance: MeshInstance,
	  Model: Model,
	  ParticleEmitter: ParticleEmitter,
	  PhongMaterial: StandardMaterial,
	  Picker: Picker,
	  Projection: {
	    ORTHOGRAPHIC: PROJECTION_ORTHOGRAPHIC,
	    PERSPECTIVE: PROJECTION_PERSPECTIVE
	  },
	  Scene: Scene,
	  Skin: Skin,
	  SkinInstance: SkinInstance
	};
	Object.defineProperty(Scene.prototype, 'defaultMaterial', {
	  get: function get() {
	    return getDefaultMaterial(getApplication().graphicsDevice);
	  }
	});
	['128', '64', '32', '16', '8', '4'].forEach(function (size, index) {
	  Object.defineProperty(Scene.prototype, "skyboxPrefiltered" + size, {
	    get: function get() {
	      return this._prefilteredCubemaps[index];
	    },
	    set: function set(value) {
	      this._prefilteredCubemaps[index] = value;
	      this.updateShaders = true;
	    }
	  });
	});
	Object.defineProperty(Scene.prototype, 'models', {
	  get: function get() {
	    if (!this._models) {
	      this._models = [];
	    }

	    return this._models;
	  }
	});

	Scene.prototype._updateSkybox = function (device) {
	  this._updateSky(device);
	};

	Scene.prototype.addModel = function (model) {
	  if (this.containsModel(model)) return;
	  var layer = this.layers.getLayerById(LAYERID_WORLD);
	  if (!layer) return;
	  layer.addMeshInstances(model.meshInstances);
	  this.models.push(model);
	};

	Scene.prototype.addShadowCaster = function (model) {
	  var layer = this.layers.getLayerById(LAYERID_WORLD);
	  if (!layer) return;
	  layer.addShadowCasters(model.meshInstances);
	};

	Scene.prototype.removeModel = function (model) {
	  var index = this.models.indexOf(model);

	  if (index !== -1) {
	    var layer = this.layers.getLayerById(LAYERID_WORLD);
	    if (!layer) return;
	    layer.removeMeshInstances(model.meshInstances);
	    this.models.splice(index, 1);
	  }
	};

	Scene.prototype.removeShadowCasters = function (model) {
	  var layer = this.layers.getLayerById(LAYERID_WORLD);
	  if (!layer) return;
	  layer.removeShadowCasters(model.meshInstances);
	};

	Scene.prototype.containsModel = function (model) {
	  return this.models.indexOf(model) >= 0;
	};

	Scene.prototype.getModels = function (model) {
	  return this.models;
	};

	Object.defineProperty(Batch.prototype, 'model', {
	  get: function get() {
	    return null;
	  }
	});

	ForwardRenderer.prototype.renderComposition = function (comp) {
	  getApplication().renderComposition(comp);
	};

	ForwardRenderer.prototype.updateShader = function (meshInstance, objDefs, staticLightList, pass, sortedLights) {
	  var scene = meshInstance.material._scene || getApplication().scene;
	  return meshInstance.updatePassShader(scene, pass, staticLightList, sortedLights);
	};

	MeshInstance.prototype.syncAabb = function () {};

	Morph.prototype.getTarget = function (index) {
	  return this.targets[index];
	};

	GraphNode.prototype._dirtify = function (local) {
	  if (local) this._dirtifyLocal();else this._dirtifyWorld();
	};

	GraphNode.prototype.addLabel = function (label) {
	  this._labels[label] = true;
	};

	GraphNode.prototype.getLabels = function () {
	  return Object.keys(this._labels);
	};

	GraphNode.prototype.hasLabel = function (label) {
	  return !!this._labels[label];
	};

	GraphNode.prototype.removeLabel = function (label) {
	  delete this._labels[label];
	};

	GraphNode.prototype.findByLabel = function (label, results) {
	  if (results === void 0) {
	    results = [];
	  }

	  if (this.hasLabel(label)) {
	    results.push(this);
	  }

	  for (var i = 0; i < this._children.length; ++i) {
	    results = this._children[i].findByLabel(label, results);
	  }

	  return results;
	};

	GraphNode.prototype.getChildren = function () {
	  return this.children;
	};

	GraphNode.prototype.getName = function () {
	  return this.name;
	};

	GraphNode.prototype.getPath = function () {
	  return this.path;
	};

	GraphNode.prototype.getRoot = function () {
	  return this.root;
	};

	GraphNode.prototype.getParent = function () {
	  return this.parent;
	};

	GraphNode.prototype.setName = function (name) {
	  this.name = name;
	};

	Material.prototype.getName = function () {
	  return this.name;
	};

	Material.prototype.setName = function (name) {
	  this.name = name;
	};

	Material.prototype.getShader = function () {
	  return this.shader;
	};

	Material.prototype.setShader = function (shader) {
	  this.shader = shader;
	};

	function _defineAlias(newName, oldName) {
	  Object.defineProperty(StandardMaterial.prototype, oldName, {
	    get: function get() {
	      return this[newName];
	    },
	    set: function set(value) {
	      this[newName] = value;
	    }
	  });
	}

	_defineAlias('diffuseTint', 'diffuseMapTint');

	_defineAlias('specularTint', 'specularMapTint');

	_defineAlias('emissiveTint', 'emissiveMapTint');

	_defineAlias('aoVertexColor', 'aoMapVertexColor');

	_defineAlias('diffuseVertexColor', 'diffuseMapVertexColor');

	_defineAlias('specularVertexColor', 'specularMapVertexColor');

	_defineAlias('emissiveVertexColor', 'emissiveMapVertexColor');

	_defineAlias('metalnessVertexColor', 'metalnessMapVertexColor');

	_defineAlias('glossVertexColor', 'glossMapVertexColor');

	_defineAlias('opacityVertexColor', 'opacityMapVertexColor');

	_defineAlias('lightVertexColor', 'lightMapVertexColor');

	var anim = {
	  Animation: Animation,
	  Key: Key,
	  Node: Node,
	  Skeleton: Skeleton
	};

	Animation.prototype.getDuration = function () {
	  return this.duration;
	};

	Animation.prototype.getName = function () {
	  return this.name;
	};

	Animation.prototype.getNodes = function () {
	  return this.nodes;
	};

	Animation.prototype.setDuration = function (duration) {
	  this.duration = duration;
	};

	Animation.prototype.setName = function (name) {
	  this.name = name;
	};

	Skeleton.prototype.getAnimation = function () {
	  return this.animation;
	};

	Skeleton.prototype.getCurrentTime = function () {
	  return this.currentTime;
	};

	Skeleton.prototype.getLooping = function () {
	  return this.looping;
	};

	Skeleton.prototype.getNumNodes = function () {
	  return this.numNodes;
	};

	Skeleton.prototype.setAnimation = function (animation) {
	  this.animation = animation;
	};

	Skeleton.prototype.setCurrentTime = function (time) {
	  this.currentTime = time;
	};

	Skeleton.prototype.setLooping = function (looping) {
	  this.looping = looping;
	};

	var audio = {
	  AudioManager: SoundManager,
	  Channel: Channel,
	  Channel3d: Channel3d,
	  Listener: Listener,
	  Sound: Sound
	};

	SoundManager.prototype.getListener = function () {
	  return this.listener;
	};

	SoundManager.prototype.getVolume = function () {
	  return this.volume;
	};

	SoundManager.prototype.setVolume = function (volume) {
	  this.volume = volume;
	};

	var asset = {
	  ASSET_ANIMATION: 'animation',
	  ASSET_AUDIO: 'audio',
	  ASSET_IMAGE: 'image',
	  ASSET_JSON: 'json',
	  ASSET_MODEL: 'model',
	  ASSET_MATERIAL: 'material',
	  ASSET_TEXT: 'text',
	  ASSET_TEXTURE: 'texture',
	  ASSET_CUBEMAP: 'cubemap',
	  ASSET_SCRIPT: 'script'
	};

	AssetRegistry.prototype.getAssetById = function (id) {
	  return this.get(id);
	};

	Object.defineProperty(XrInputSource.prototype, 'ray', {
	  get: function get() {
	    return this._rayLocal;
	  }
	});
	Object.defineProperty(XrInputSource.prototype, 'position', {
	  get: function get() {
	    return this._localPosition;
	  }
	});
	Object.defineProperty(XrInputSource.prototype, 'rotation', {
	  get: function get() {
	    return this._localRotation;
	  }
	});
	var input = {
	  getTouchTargetCoords: getTouchTargetCoords,
	  Controller: Controller,
	  GamePads: GamePads,
	  Keyboard: Keyboard,
	  KeyboardEvent: KeyboardEvent,
	  Mouse: Mouse,
	  MouseEvent: MouseEvent,
	  Touch: Touch,
	  TouchDevice: TouchDevice,
	  TouchEvent: TouchEvent
	};
	Object.defineProperty(ElementInput.prototype, 'wheel', {
	  get: function get() {
	    return this.wheelDelta * -2;
	  }
	});
	Object.defineProperty(MouseEvent.prototype, 'wheel', {
	  get: function get() {
	    return this.wheelDelta * -2;
	  }
	});
	var RIGIDBODY_TYPE_STATIC = BODYTYPE_STATIC;
	var RIGIDBODY_TYPE_DYNAMIC = BODYTYPE_DYNAMIC;
	var RIGIDBODY_TYPE_KINEMATIC = BODYTYPE_KINEMATIC;
	var RIGIDBODY_CF_STATIC_OBJECT = BODYFLAG_STATIC_OBJECT;
	var RIGIDBODY_CF_KINEMATIC_OBJECT = BODYFLAG_KINEMATIC_OBJECT;
	var RIGIDBODY_CF_NORESPONSE_OBJECT = BODYFLAG_NORESPONSE_OBJECT;
	var RIGIDBODY_ACTIVE_TAG = BODYSTATE_ACTIVE_TAG;
	var RIGIDBODY_ISLAND_SLEEPING = BODYSTATE_ISLAND_SLEEPING;
	var RIGIDBODY_WANTS_DEACTIVATION = BODYSTATE_WANTS_DEACTIVATION;
	var RIGIDBODY_DISABLE_DEACTIVATION = BODYSTATE_DISABLE_DEACTIVATION;
	var RIGIDBODY_DISABLE_SIMULATION = BODYSTATE_DISABLE_SIMULATION;
	var fw = {
	  Application: Application,
	  Component: Component,
	  ComponentSystem: ComponentSystem,
	  Entity: Entity,
	  FillMode: {
	    NONE: FILLMODE_NONE,
	    FILL_WINDOW: FILLMODE_FILL_WINDOW,
	    KEEP_ASPECT: FILLMODE_KEEP_ASPECT
	  },
	  ResolutionMode: {
	    AUTO: RESOLUTION_AUTO,
	    FIXED: RESOLUTION_FIXED
	  }
	};

	Application.prototype.isFullscreen = function () {
	  return !!document.fullscreenElement;
	};

	Application.prototype.enableFullscreen = function (element, success, error) {
	  element = element || this.graphicsDevice.canvas;

	  var s = function s() {
	    success();
	    document.removeEventListener('fullscreenchange', s);
	  };

	  var e = function e() {
	    error();
	    document.removeEventListener('fullscreenerror', e);
	  };

	  if (success) {
	    document.addEventListener('fullscreenchange', s, false);
	  }

	  if (error) {
	    document.addEventListener('fullscreenerror', e, false);
	  }

	  if (element.requestFullscreen) {
	    element.requestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
	  } else {
	    error();
	  }
	};

	Application.prototype.disableFullscreen = function (success) {
	  var s = function s() {
	    success();
	    document.removeEventListener('fullscreenchange', s);
	  };

	  if (success) {
	    document.addEventListener('fullscreenchange', s, false);
	  }

	  document.exitFullscreen();
	};

	Application.prototype.getSceneUrl = function (name) {
	  var entry = this.scenes.find(name);

	  if (entry) {
	    return entry.url;
	  }

	  return null;
	};

	Application.prototype.loadScene = function (url, callback) {
	  this.scenes.loadScene(url, callback);
	};

	Application.prototype.loadSceneHierarchy = function (url, callback) {
	  this.scenes.loadSceneHierarchy(url, callback);
	};

	Application.prototype.loadSceneSettings = function (url, callback) {
	  this.scenes.loadSceneSettings(url, callback);
	};

	Application.prototype.renderMeshInstance = function (meshInstance, options) {
	  var layer = options != null && options.layer ? options.layer : this.scene.defaultDrawLayer;
	  this.scene.immediate.drawMesh(null, null, null, meshInstance, layer);
	};

	Application.prototype.renderMesh = function (mesh, material, matrix, options) {
	  var layer = options != null && options.layer ? options.layer : this.scene.defaultDrawLayer;
	  this.scene.immediate.drawMesh(material, matrix, mesh, null, layer);
	};

	Application.prototype._addLines = function (positions, colors, options) {
	  var layer = options && options.layer ? options.layer : this.scene.layers.getLayerById(LAYERID_IMMEDIATE);
	  var depthTest = options && options.depthTest !== undefined ? options.depthTest : true;
	  var batch = this.scene.immediate.getBatch(layer, depthTest);
	  batch.addLines(positions, colors);
	};

	Application.prototype.renderLine = function (start, end, color) {
	  var endColor = color;
	  var options;
	  var arg3 = arguments[3];
	  var arg4 = arguments[4];

	  if (arg3 instanceof Color) {
	    endColor = arg3;

	    if (typeof arg4 === 'number') {
	      if (arg4 === LINEBATCH_OVERLAY) {
	        options = {
	          layer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),
	          depthTest: false
	        };
	      } else {
	        options = {
	          layer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),
	          depthTest: true
	        };
	      }
	    } else {
	      options = arg4;
	    }
	  } else if (typeof arg3 === 'number') {
	    endColor = color;

	    if (arg3 === LINEBATCH_OVERLAY) {
	      options = {
	        layer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),
	        depthTest: false
	      };
	    } else {
	      options = {
	        layer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),
	        depthTest: true
	      };
	    }
	  } else if (arg3) {
	    options = arg3;
	  }

	  this._addLines([start, end], [color, endColor], options);
	};

	Application.prototype.renderLines = function (position, color, options) {
	  if (!options) {
	    options = {
	      layer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),
	      depthTest: true
	    };
	  } else if (typeof options === 'number') {
	    if (options === LINEBATCH_OVERLAY) {
	      options = {
	        layer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),
	        depthTest: false
	      };
	    } else {
	      options = {
	        layer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),
	        depthTest: true
	      };
	    }
	  }

	  var multiColor = !!color.length;

	  if (multiColor) {
	    if (position.length !== color.length) {
	      console.error('renderLines: position/color arrays have different lengths');
	      return;
	    }
	  }

	  if (position.length % 2 !== 0) {
	    console.error('renderLines: array length is not divisible by 2');
	    return;
	  }

	  this._addLines(position, color, options);
	};

	Application.prototype.enableVr = function () {};

	Object.defineProperty(CameraComponent.prototype, 'node', {
	  get: function get() {
	    return this.entity;
	  }
	});
	Object.defineProperty(LightComponent.prototype, 'enable', {
	  get: function get() {
	    return this.enabled;
	  },
	  set: function set(value) {
	    this.enabled = value;
	  }
	});

	ModelComponent.prototype.setVisible = function (visible) {
	  this.enabled = visible;
	};

	Object.defineProperty(ModelComponent.prototype, 'aabb', {
	  get: function get() {
	    return null;
	  },
	  set: function set(type) {}
	});
	Object.defineProperty(RenderComponent.prototype, 'aabb', {
	  get: function get() {
	    return null;
	  },
	  set: function set(type) {}
	});
	Object.defineProperty(RigidBodyComponent.prototype, 'bodyType', {
	  get: function get() {
	    return this.type;
	  },
	  set: function set(type) {
	    this.type = type;
	  }
	});

	RigidBodyComponent.prototype.syncBodyToEntity = function () {
	  this._updateDynamic();
	};

	RigidBodyComponentSystem.prototype.setGravity = function () {
	  if (arguments.length === 1) {
	    this.gravity.copy(arguments[0]);
	  } else {
	    this.gravity.set(arguments[0], arguments[1], arguments[2]);
	  }
	};

	function basisSetDownloadConfig(glueUrl, wasmUrl, fallbackUrl) {
	  basisInitialize({
	    glueUrl: glueUrl,
	    wasmUrl: wasmUrl,
	    fallbackUrl: fallbackUrl,
	    lazyInit: true
	  });
	}
	function prefilterCubemap(options) {}

	exports.ABSOLUTE_URL = ABSOLUTE_URL;
	exports.ACTION_GAMEPAD = ACTION_GAMEPAD;
	exports.ACTION_KEYBOARD = ACTION_KEYBOARD;
	exports.ACTION_MOUSE = ACTION_MOUSE;
	exports.ADDRESS_CLAMP_TO_EDGE = ADDRESS_CLAMP_TO_EDGE;
	exports.ADDRESS_MIRRORED_REPEAT = ADDRESS_MIRRORED_REPEAT;
	exports.ADDRESS_REPEAT = ADDRESS_REPEAT;
	exports.ANIM_BLEND_1D = ANIM_BLEND_1D;
	exports.ANIM_BLEND_2D_CARTESIAN = ANIM_BLEND_2D_CARTESIAN;
	exports.ANIM_BLEND_2D_DIRECTIONAL = ANIM_BLEND_2D_DIRECTIONAL;
	exports.ANIM_BLEND_DIRECT = ANIM_BLEND_DIRECT;
	exports.ANIM_CONTROL_STATES = ANIM_CONTROL_STATES;
	exports.ANIM_EQUAL_TO = ANIM_EQUAL_TO;
	exports.ANIM_GREATER_THAN = ANIM_GREATER_THAN;
	exports.ANIM_GREATER_THAN_EQUAL_TO = ANIM_GREATER_THAN_EQUAL_TO;
	exports.ANIM_INTERRUPTION_NEXT = ANIM_INTERRUPTION_NEXT;
	exports.ANIM_INTERRUPTION_NEXT_PREV = ANIM_INTERRUPTION_NEXT_PREV;
	exports.ANIM_INTERRUPTION_NONE = ANIM_INTERRUPTION_NONE;
	exports.ANIM_INTERRUPTION_PREV = ANIM_INTERRUPTION_PREV;
	exports.ANIM_INTERRUPTION_PREV_NEXT = ANIM_INTERRUPTION_PREV_NEXT;
	exports.ANIM_LAYER_ADDITIVE = ANIM_LAYER_ADDITIVE;
	exports.ANIM_LAYER_OVERWRITE = ANIM_LAYER_OVERWRITE;
	exports.ANIM_LESS_THAN = ANIM_LESS_THAN;
	exports.ANIM_LESS_THAN_EQUAL_TO = ANIM_LESS_THAN_EQUAL_TO;
	exports.ANIM_NOT_EQUAL_TO = ANIM_NOT_EQUAL_TO;
	exports.ANIM_PARAMETER_BOOLEAN = ANIM_PARAMETER_BOOLEAN;
	exports.ANIM_PARAMETER_FLOAT = ANIM_PARAMETER_FLOAT;
	exports.ANIM_PARAMETER_INTEGER = ANIM_PARAMETER_INTEGER;
	exports.ANIM_PARAMETER_TRIGGER = ANIM_PARAMETER_TRIGGER;
	exports.ANIM_STATE_ANY = ANIM_STATE_ANY;
	exports.ANIM_STATE_END = ANIM_STATE_END;
	exports.ANIM_STATE_START = ANIM_STATE_START;
	exports.ASPECT_AUTO = ASPECT_AUTO;
	exports.ASPECT_MANUAL = ASPECT_MANUAL;
	exports.ASSET_ANIMATION = ASSET_ANIMATION;
	exports.ASSET_AUDIO = ASSET_AUDIO;
	exports.ASSET_CONTAINER = ASSET_CONTAINER;
	exports.ASSET_CSS = ASSET_CSS;
	exports.ASSET_CUBEMAP = ASSET_CUBEMAP;
	exports.ASSET_HTML = ASSET_HTML;
	exports.ASSET_IMAGE = ASSET_IMAGE;
	exports.ASSET_JSON = ASSET_JSON;
	exports.ASSET_MATERIAL = ASSET_MATERIAL;
	exports.ASSET_MODEL = ASSET_MODEL;
	exports.ASSET_SCRIPT = ASSET_SCRIPT;
	exports.ASSET_SHADER = ASSET_SHADER;
	exports.ASSET_TEXT = ASSET_TEXT;
	exports.ASSET_TEXTURE = ASSET_TEXTURE;
	exports.AXIS_KEY = AXIS_KEY;
	exports.AXIS_MOUSE_X = AXIS_MOUSE_X;
	exports.AXIS_MOUSE_Y = AXIS_MOUSE_Y;
	exports.AXIS_PAD_L_X = AXIS_PAD_L_X;
	exports.AXIS_PAD_L_Y = AXIS_PAD_L_Y;
	exports.AXIS_PAD_R_X = AXIS_PAD_R_X;
	exports.AXIS_PAD_R_Y = AXIS_PAD_R_Y;
	exports.AnimBinder = AnimBinder;
	exports.AnimClip = AnimClip;
	exports.AnimClipHandler = AnimClipHandler;
	exports.AnimComponent = AnimComponent;
	exports.AnimComponentLayer = AnimComponentLayer;
	exports.AnimComponentSystem = AnimComponentSystem;
	exports.AnimController = AnimController;
	exports.AnimCurve = AnimCurve;
	exports.AnimData = AnimData;
	exports.AnimEvaluator = AnimEvaluator;
	exports.AnimEvents = AnimEvents;
	exports.AnimSnapshot = AnimSnapshot;
	exports.AnimStateGraph = AnimStateGraph;
	exports.AnimStateGraphHandler = AnimStateGraphHandler;
	exports.AnimTarget = AnimTarget;
	exports.AnimTrack = AnimTrack;
	exports.Animation = Animation;
	exports.AnimationComponent = AnimationComponent;
	exports.AnimationComponentSystem = AnimationComponentSystem;
	exports.AnimationHandler = AnimationHandler;
	exports.AppBase = AppBase;
	exports.AppOptions = AppOptions;
	exports.Application = Application;
	exports.Asset = Asset;
	exports.AssetListLoader = AssetListLoader;
	exports.AssetReference = AssetReference;
	exports.AssetRegistry = AssetRegistry;
	exports.AudioHandler = AudioHandler;
	exports.AudioListenerComponent = AudioListenerComponent;
	exports.AudioListenerComponentSystem = AudioListenerComponentSystem;
	exports.AudioSourceComponent = AudioSourceComponent;
	exports.AudioSourceComponentSystem = AudioSourceComponentSystem;
	exports.BAKE_COLOR = BAKE_COLOR;
	exports.BAKE_COLORDIR = BAKE_COLORDIR;
	exports.BINDGROUP_MESH = BINDGROUP_MESH;
	exports.BINDGROUP_VIEW = BINDGROUP_VIEW;
	exports.BLENDEQUATION_ADD = BLENDEQUATION_ADD;
	exports.BLENDEQUATION_MAX = BLENDEQUATION_MAX;
	exports.BLENDEQUATION_MIN = BLENDEQUATION_MIN;
	exports.BLENDEQUATION_REVERSE_SUBTRACT = BLENDEQUATION_REVERSE_SUBTRACT;
	exports.BLENDEQUATION_SUBTRACT = BLENDEQUATION_SUBTRACT;
	exports.BLENDMODE_CONSTANT_ALPHA = BLENDMODE_CONSTANT_ALPHA;
	exports.BLENDMODE_CONSTANT_COLOR = BLENDMODE_CONSTANT_COLOR;
	exports.BLENDMODE_DST_ALPHA = BLENDMODE_DST_ALPHA;
	exports.BLENDMODE_DST_COLOR = BLENDMODE_DST_COLOR;
	exports.BLENDMODE_ONE = BLENDMODE_ONE;
	exports.BLENDMODE_ONE_MINUS_CONSTANT_ALPHA = BLENDMODE_ONE_MINUS_CONSTANT_ALPHA;
	exports.BLENDMODE_ONE_MINUS_CONSTANT_COLOR = BLENDMODE_ONE_MINUS_CONSTANT_COLOR;
	exports.BLENDMODE_ONE_MINUS_DST_ALPHA = BLENDMODE_ONE_MINUS_DST_ALPHA;
	exports.BLENDMODE_ONE_MINUS_DST_COLOR = BLENDMODE_ONE_MINUS_DST_COLOR;
	exports.BLENDMODE_ONE_MINUS_SRC_ALPHA = BLENDMODE_ONE_MINUS_SRC_ALPHA;
	exports.BLENDMODE_ONE_MINUS_SRC_COLOR = BLENDMODE_ONE_MINUS_SRC_COLOR;
	exports.BLENDMODE_SRC_ALPHA = BLENDMODE_SRC_ALPHA;
	exports.BLENDMODE_SRC_ALPHA_SATURATE = BLENDMODE_SRC_ALPHA_SATURATE;
	exports.BLENDMODE_SRC_COLOR = BLENDMODE_SRC_COLOR;
	exports.BLENDMODE_ZERO = BLENDMODE_ZERO;
	exports.BLEND_ADDITIVE = BLEND_ADDITIVE;
	exports.BLEND_ADDITIVEALPHA = BLEND_ADDITIVEALPHA;
	exports.BLEND_MAX = BLEND_MAX;
	exports.BLEND_MIN = BLEND_MIN;
	exports.BLEND_MULTIPLICATIVE = BLEND_MULTIPLICATIVE;
	exports.BLEND_MULTIPLICATIVE2X = BLEND_MULTIPLICATIVE2X;
	exports.BLEND_NONE = BLEND_NONE;
	exports.BLEND_NORMAL = BLEND_NORMAL;
	exports.BLEND_PREMULTIPLIED = BLEND_PREMULTIPLIED;
	exports.BLEND_SCREEN = BLEND_SCREEN;
	exports.BLEND_SUBTRACTIVE = BLEND_SUBTRACTIVE;
	exports.BLUR_BOX = BLUR_BOX;
	exports.BLUR_GAUSSIAN = BLUR_GAUSSIAN;
	exports.BODYFLAG_KINEMATIC_OBJECT = BODYFLAG_KINEMATIC_OBJECT;
	exports.BODYFLAG_NORESPONSE_OBJECT = BODYFLAG_NORESPONSE_OBJECT;
	exports.BODYFLAG_STATIC_OBJECT = BODYFLAG_STATIC_OBJECT;
	exports.BODYGROUP_DEFAULT = BODYGROUP_DEFAULT;
	exports.BODYGROUP_DYNAMIC = BODYGROUP_DYNAMIC;
	exports.BODYGROUP_ENGINE_1 = BODYGROUP_ENGINE_1;
	exports.BODYGROUP_ENGINE_2 = BODYGROUP_ENGINE_2;
	exports.BODYGROUP_ENGINE_3 = BODYGROUP_ENGINE_3;
	exports.BODYGROUP_KINEMATIC = BODYGROUP_KINEMATIC;
	exports.BODYGROUP_NONE = BODYGROUP_NONE;
	exports.BODYGROUP_STATIC = BODYGROUP_STATIC;
	exports.BODYGROUP_TRIGGER = BODYGROUP_TRIGGER;
	exports.BODYGROUP_USER_1 = BODYGROUP_USER_1;
	exports.BODYGROUP_USER_2 = BODYGROUP_USER_2;
	exports.BODYGROUP_USER_3 = BODYGROUP_USER_3;
	exports.BODYGROUP_USER_4 = BODYGROUP_USER_4;
	exports.BODYGROUP_USER_5 = BODYGROUP_USER_5;
	exports.BODYGROUP_USER_6 = BODYGROUP_USER_6;
	exports.BODYGROUP_USER_7 = BODYGROUP_USER_7;
	exports.BODYGROUP_USER_8 = BODYGROUP_USER_8;
	exports.BODYMASK_ALL = BODYMASK_ALL;
	exports.BODYMASK_NONE = BODYMASK_NONE;
	exports.BODYMASK_NOT_STATIC = BODYMASK_NOT_STATIC;
	exports.BODYMASK_NOT_STATIC_KINEMATIC = BODYMASK_NOT_STATIC_KINEMATIC;
	exports.BODYMASK_STATIC = BODYMASK_STATIC;
	exports.BODYSTATE_ACTIVE_TAG = BODYSTATE_ACTIVE_TAG;
	exports.BODYSTATE_DISABLE_DEACTIVATION = BODYSTATE_DISABLE_DEACTIVATION;
	exports.BODYSTATE_DISABLE_SIMULATION = BODYSTATE_DISABLE_SIMULATION;
	exports.BODYSTATE_ISLAND_SLEEPING = BODYSTATE_ISLAND_SLEEPING;
	exports.BODYSTATE_WANTS_DEACTIVATION = BODYSTATE_WANTS_DEACTIVATION;
	exports.BODYTYPE_DYNAMIC = BODYTYPE_DYNAMIC;
	exports.BODYTYPE_KINEMATIC = BODYTYPE_KINEMATIC;
	exports.BODYTYPE_STATIC = BODYTYPE_STATIC;
	exports.BUFFER_DYNAMIC = BUFFER_DYNAMIC;
	exports.BUFFER_GPUDYNAMIC = BUFFER_GPUDYNAMIC;
	exports.BUFFER_STATIC = BUFFER_STATIC;
	exports.BUFFER_STREAM = BUFFER_STREAM;
	exports.BUTTON_TRANSITION_MODE_SPRITE_CHANGE = BUTTON_TRANSITION_MODE_SPRITE_CHANGE;
	exports.BUTTON_TRANSITION_MODE_TINT = BUTTON_TRANSITION_MODE_TINT;
	exports.BasicMaterial = BasicMaterial;
	exports.Batch = Batch;
	exports.BatchGroup = BatchGroup;
	exports.BatchManager = BatchManager;
	exports.BinaryHandler = BinaryHandler;
	exports.BoundingBox = BoundingBox;
	exports.BoundingSphere = BoundingSphere;
	exports.Bundle = Bundle;
	exports.BundleHandler = BundleHandler;
	exports.BundleRegistry = BundleRegistry;
	exports.ButtonComponent = ButtonComponent;
	exports.ButtonComponentSystem = ButtonComponentSystem;
	exports.CHUNKAPI_1_51 = CHUNKAPI_1_51;
	exports.CHUNKAPI_1_55 = CHUNKAPI_1_55;
	exports.CHUNKAPI_1_56 = CHUNKAPI_1_56;
	exports.CLEARFLAG_COLOR = CLEARFLAG_COLOR;
	exports.CLEARFLAG_DEPTH = CLEARFLAG_DEPTH;
	exports.CLEARFLAG_STENCIL = CLEARFLAG_STENCIL;
	exports.COMPUPDATED_BLEND = COMPUPDATED_BLEND;
	exports.COMPUPDATED_CAMERAS = COMPUPDATED_CAMERAS;
	exports.COMPUPDATED_INSTANCES = COMPUPDATED_INSTANCES;
	exports.COMPUPDATED_LIGHTS = COMPUPDATED_LIGHTS;
	exports.CUBEFACE_NEGX = CUBEFACE_NEGX;
	exports.CUBEFACE_NEGY = CUBEFACE_NEGY;
	exports.CUBEFACE_NEGZ = CUBEFACE_NEGZ;
	exports.CUBEFACE_POSX = CUBEFACE_POSX;
	exports.CUBEFACE_POSY = CUBEFACE_POSY;
	exports.CUBEFACE_POSZ = CUBEFACE_POSZ;
	exports.CUBEPROJ_BOX = CUBEPROJ_BOX;
	exports.CUBEPROJ_NONE = CUBEPROJ_NONE;
	exports.CULLFACE_BACK = CULLFACE_BACK;
	exports.CULLFACE_FRONT = CULLFACE_FRONT;
	exports.CULLFACE_FRONTANDBACK = CULLFACE_FRONTANDBACK;
	exports.CULLFACE_NONE = CULLFACE_NONE;
	exports.CURVE_CARDINAL = CURVE_CARDINAL;
	exports.CURVE_CATMULL = CURVE_CATMULL;
	exports.CURVE_LINEAR = CURVE_LINEAR;
	exports.CURVE_SMOOTHSTEP = CURVE_SMOOTHSTEP;
	exports.CURVE_SPLINE = CURVE_SPLINE;
	exports.CURVE_STEP = CURVE_STEP;
	exports.Camera = Camera;
	exports.CameraComponent = CameraComponent;
	exports.CameraComponentSystem = CameraComponentSystem;
	exports.CanvasFont = CanvasFont;
	exports.CollisionComponent = CollisionComponent;
	exports.CollisionComponentSystem = CollisionComponentSystem;
	exports.Color = Color;
	exports.Command = Command;
	exports.Component = Component;
	exports.ComponentSystem = ComponentSystem;
	exports.ComponentSystemRegistry = ComponentSystemRegistry;
	exports.ContactPoint = ContactPoint;
	exports.ContactResult = ContactResult;
	exports.ContainerHandler = ContainerHandler;
	exports.ContainerResource = ContainerResource;
	exports.ContextCreationError = ContextCreationError;
	exports.Controller = Controller;
	exports.CssHandler = CssHandler;
	exports.CubemapHandler = CubemapHandler;
	exports.Curve = Curve;
	exports.CurveSet = CurveSet;
	exports.DETAILMODE_ADD = DETAILMODE_ADD;
	exports.DETAILMODE_MAX = DETAILMODE_MAX;
	exports.DETAILMODE_MIN = DETAILMODE_MIN;
	exports.DETAILMODE_MUL = DETAILMODE_MUL;
	exports.DETAILMODE_OVERLAY = DETAILMODE_OVERLAY;
	exports.DETAILMODE_SCREEN = DETAILMODE_SCREEN;
	exports.DEVICETYPE_WEBGL = DEVICETYPE_WEBGL;
	exports.DEVICETYPE_WEBGPU = DEVICETYPE_WEBGPU;
	exports.DISTANCE_EXPONENTIAL = DISTANCE_EXPONENTIAL;
	exports.DISTANCE_INVERSE = DISTANCE_INVERSE;
	exports.DISTANCE_LINEAR = DISTANCE_LINEAR;
	exports.DefaultAnimBinder = DefaultAnimBinder;
	exports.ELEMENTTYPE_FLOAT32 = ELEMENTTYPE_FLOAT32;
	exports.ELEMENTTYPE_GROUP = ELEMENTTYPE_GROUP;
	exports.ELEMENTTYPE_IMAGE = ELEMENTTYPE_IMAGE;
	exports.ELEMENTTYPE_INT16 = ELEMENTTYPE_INT16;
	exports.ELEMENTTYPE_INT32 = ELEMENTTYPE_INT32;
	exports.ELEMENTTYPE_INT8 = ELEMENTTYPE_INT8;
	exports.ELEMENTTYPE_TEXT = ELEMENTTYPE_TEXT;
	exports.ELEMENTTYPE_UINT16 = ELEMENTTYPE_UINT16;
	exports.ELEMENTTYPE_UINT32 = ELEMENTTYPE_UINT32;
	exports.ELEMENTTYPE_UINT8 = ELEMENTTYPE_UINT8;
	exports.EMITTERSHAPE_BOX = EMITTERSHAPE_BOX;
	exports.EMITTERSHAPE_SPHERE = EMITTERSHAPE_SPHERE;
	exports.EVENT_KEYDOWN = EVENT_KEYDOWN;
	exports.EVENT_KEYUP = EVENT_KEYUP;
	exports.EVENT_MOUSEDOWN = EVENT_MOUSEDOWN;
	exports.EVENT_MOUSEMOVE = EVENT_MOUSEMOVE;
	exports.EVENT_MOUSEUP = EVENT_MOUSEUP;
	exports.EVENT_MOUSEWHEEL = EVENT_MOUSEWHEEL;
	exports.EVENT_SELECT = EVENT_SELECT;
	exports.EVENT_SELECTEND = EVENT_SELECTEND;
	exports.EVENT_SELECTSTART = EVENT_SELECTSTART;
	exports.EVENT_TOUCHCANCEL = EVENT_TOUCHCANCEL;
	exports.EVENT_TOUCHEND = EVENT_TOUCHEND;
	exports.EVENT_TOUCHMOVE = EVENT_TOUCHMOVE;
	exports.EVENT_TOUCHSTART = EVENT_TOUCHSTART;
	exports.ElementComponent = ElementComponent;
	exports.ElementComponentSystem = ElementComponentSystem;
	exports.ElementDragHelper = ElementDragHelper;
	exports.ElementInput = ElementInput;
	exports.ElementInputEvent = ElementInputEvent;
	exports.ElementMouseEvent = ElementMouseEvent;
	exports.ElementSelectEvent = ElementSelectEvent;
	exports.ElementTouchEvent = ElementTouchEvent;
	exports.Entity = Entity;
	exports.EntityReference = EntityReference;
	exports.EnvLighting = EnvLighting;
	exports.EventHandler = EventHandler;
	exports.FILLMODE_FILL_WINDOW = FILLMODE_FILL_WINDOW;
	exports.FILLMODE_KEEP_ASPECT = FILLMODE_KEEP_ASPECT;
	exports.FILLMODE_NONE = FILLMODE_NONE;
	exports.FILTER_LINEAR = FILTER_LINEAR;
	exports.FILTER_LINEAR_MIPMAP_LINEAR = FILTER_LINEAR_MIPMAP_LINEAR;
	exports.FILTER_LINEAR_MIPMAP_NEAREST = FILTER_LINEAR_MIPMAP_NEAREST;
	exports.FILTER_NEAREST = FILTER_NEAREST;
	exports.FILTER_NEAREST_MIPMAP_LINEAR = FILTER_NEAREST_MIPMAP_LINEAR;
	exports.FILTER_NEAREST_MIPMAP_NEAREST = FILTER_NEAREST_MIPMAP_NEAREST;
	exports.FITMODE_CONTAIN = FITMODE_CONTAIN;
	exports.FITMODE_COVER = FITMODE_COVER;
	exports.FITMODE_STRETCH = FITMODE_STRETCH;
	exports.FITTING_BOTH = FITTING_BOTH;
	exports.FITTING_NONE = FITTING_NONE;
	exports.FITTING_SHRINK = FITTING_SHRINK;
	exports.FITTING_STRETCH = FITTING_STRETCH;
	exports.FOG_EXP = FOG_EXP;
	exports.FOG_EXP2 = FOG_EXP2;
	exports.FOG_LINEAR = FOG_LINEAR;
	exports.FOG_NONE = FOG_NONE;
	exports.FONT_BITMAP = FONT_BITMAP;
	exports.FONT_MSDF = FONT_MSDF;
	exports.FRESNEL_NONE = FRESNEL_NONE;
	exports.FRESNEL_SCHLICK = FRESNEL_SCHLICK;
	exports.FUNC_ALWAYS = FUNC_ALWAYS;
	exports.FUNC_EQUAL = FUNC_EQUAL;
	exports.FUNC_GREATER = FUNC_GREATER;
	exports.FUNC_GREATEREQUAL = FUNC_GREATEREQUAL;
	exports.FUNC_LESS = FUNC_LESS;
	exports.FUNC_LESSEQUAL = FUNC_LESSEQUAL;
	exports.FUNC_NEVER = FUNC_NEVER;
	exports.FUNC_NOTEQUAL = FUNC_NOTEQUAL;
	exports.FolderHandler = FolderHandler;
	exports.Font = Font;
	exports.FontHandler = FontHandler;
	exports.ForwardRenderer = ForwardRenderer;
	exports.Frustum = Frustum;
	exports.GAMMA_NONE = GAMMA_NONE;
	exports.GAMMA_SRGB = GAMMA_SRGB;
	exports.GAMMA_SRGBFAST = GAMMA_SRGBFAST;
	exports.GAMMA_SRGBHDR = GAMMA_SRGBHDR;
	exports.GamePads = GamePads;
	exports.GraphNode = GraphNode;
	exports.GraphicsDevice = GraphicsDevice;
	exports.HierarchyHandler = HierarchyHandler;
	exports.HtmlHandler = HtmlHandler;
	exports.Http = Http;
	exports.I18n = I18n;
	exports.INDEXFORMAT_UINT16 = INDEXFORMAT_UINT16;
	exports.INDEXFORMAT_UINT32 = INDEXFORMAT_UINT32;
	exports.INDEXFORMAT_UINT8 = INDEXFORMAT_UINT8;
	exports.INTERPOLATION_CUBIC = INTERPOLATION_CUBIC;
	exports.INTERPOLATION_LINEAR = INTERPOLATION_LINEAR;
	exports.INTERPOLATION_STEP = INTERPOLATION_STEP;
	exports.ImageElement = ImageElement;
	exports.IndexBuffer = IndexBuffer;
	exports.IndexedList = IndexedList;
	exports.JointComponent = JointComponent;
	exports.JointComponentSystem = JointComponentSystem;
	exports.JsonHandler = JsonHandler;
	exports.JsonStandardMaterialParser = JsonStandardMaterialParser;
	exports.KEY_0 = KEY_0;
	exports.KEY_1 = KEY_1;
	exports.KEY_2 = KEY_2;
	exports.KEY_3 = KEY_3;
	exports.KEY_4 = KEY_4;
	exports.KEY_5 = KEY_5;
	exports.KEY_6 = KEY_6;
	exports.KEY_7 = KEY_7;
	exports.KEY_8 = KEY_8;
	exports.KEY_9 = KEY_9;
	exports.KEY_A = KEY_A;
	exports.KEY_ADD = KEY_ADD;
	exports.KEY_ALT = KEY_ALT;
	exports.KEY_B = KEY_B;
	exports.KEY_BACKSPACE = KEY_BACKSPACE;
	exports.KEY_BACK_SLASH = KEY_BACK_SLASH;
	exports.KEY_C = KEY_C;
	exports.KEY_CAPS_LOCK = KEY_CAPS_LOCK;
	exports.KEY_CLOSE_BRACKET = KEY_CLOSE_BRACKET;
	exports.KEY_COMMA = KEY_COMMA;
	exports.KEY_CONTEXT_MENU = KEY_CONTEXT_MENU;
	exports.KEY_CONTROL = KEY_CONTROL;
	exports.KEY_D = KEY_D;
	exports.KEY_DECIMAL = KEY_DECIMAL;
	exports.KEY_DELETE = KEY_DELETE;
	exports.KEY_DIVIDE = KEY_DIVIDE;
	exports.KEY_DOWN = KEY_DOWN;
	exports.KEY_E = KEY_E;
	exports.KEY_END = KEY_END;
	exports.KEY_ENTER = KEY_ENTER;
	exports.KEY_EQUAL = KEY_EQUAL;
	exports.KEY_ESCAPE = KEY_ESCAPE;
	exports.KEY_F = KEY_F;
	exports.KEY_F1 = KEY_F1;
	exports.KEY_F10 = KEY_F10;
	exports.KEY_F11 = KEY_F11;
	exports.KEY_F12 = KEY_F12;
	exports.KEY_F2 = KEY_F2;
	exports.KEY_F3 = KEY_F3;
	exports.KEY_F4 = KEY_F4;
	exports.KEY_F5 = KEY_F5;
	exports.KEY_F6 = KEY_F6;
	exports.KEY_F7 = KEY_F7;
	exports.KEY_F8 = KEY_F8;
	exports.KEY_F9 = KEY_F9;
	exports.KEY_G = KEY_G;
	exports.KEY_H = KEY_H;
	exports.KEY_HOME = KEY_HOME;
	exports.KEY_I = KEY_I;
	exports.KEY_INSERT = KEY_INSERT;
	exports.KEY_J = KEY_J;
	exports.KEY_K = KEY_K;
	exports.KEY_L = KEY_L;
	exports.KEY_LEFT = KEY_LEFT;
	exports.KEY_M = KEY_M;
	exports.KEY_META = KEY_META;
	exports.KEY_MULTIPLY = KEY_MULTIPLY;
	exports.KEY_N = KEY_N;
	exports.KEY_NUMPAD_0 = KEY_NUMPAD_0;
	exports.KEY_NUMPAD_1 = KEY_NUMPAD_1;
	exports.KEY_NUMPAD_2 = KEY_NUMPAD_2;
	exports.KEY_NUMPAD_3 = KEY_NUMPAD_3;
	exports.KEY_NUMPAD_4 = KEY_NUMPAD_4;
	exports.KEY_NUMPAD_5 = KEY_NUMPAD_5;
	exports.KEY_NUMPAD_6 = KEY_NUMPAD_6;
	exports.KEY_NUMPAD_7 = KEY_NUMPAD_7;
	exports.KEY_NUMPAD_8 = KEY_NUMPAD_8;
	exports.KEY_NUMPAD_9 = KEY_NUMPAD_9;
	exports.KEY_O = KEY_O;
	exports.KEY_OPEN_BRACKET = KEY_OPEN_BRACKET;
	exports.KEY_P = KEY_P;
	exports.KEY_PAGE_DOWN = KEY_PAGE_DOWN;
	exports.KEY_PAGE_UP = KEY_PAGE_UP;
	exports.KEY_PAUSE = KEY_PAUSE;
	exports.KEY_PERIOD = KEY_PERIOD;
	exports.KEY_PRINT_SCREEN = KEY_PRINT_SCREEN;
	exports.KEY_Q = KEY_Q;
	exports.KEY_R = KEY_R;
	exports.KEY_RETURN = KEY_RETURN;
	exports.KEY_RIGHT = KEY_RIGHT;
	exports.KEY_S = KEY_S;
	exports.KEY_SEMICOLON = KEY_SEMICOLON;
	exports.KEY_SEPARATOR = KEY_SEPARATOR;
	exports.KEY_SHIFT = KEY_SHIFT;
	exports.KEY_SLASH = KEY_SLASH;
	exports.KEY_SPACE = KEY_SPACE;
	exports.KEY_SUBTRACT = KEY_SUBTRACT;
	exports.KEY_T = KEY_T;
	exports.KEY_TAB = KEY_TAB;
	exports.KEY_U = KEY_U;
	exports.KEY_UP = KEY_UP;
	exports.KEY_V = KEY_V;
	exports.KEY_W = KEY_W;
	exports.KEY_WINDOWS = KEY_WINDOWS;
	exports.KEY_X = KEY_X;
	exports.KEY_Y = KEY_Y;
	exports.KEY_Z = KEY_Z;
	exports.Key = Key;
	exports.Keyboard = Keyboard;
	exports.KeyboardEvent = KeyboardEvent;
	exports.LAYERID_DEPTH = LAYERID_DEPTH;
	exports.LAYERID_IMMEDIATE = LAYERID_IMMEDIATE;
	exports.LAYERID_SKYBOX = LAYERID_SKYBOX;
	exports.LAYERID_UI = LAYERID_UI;
	exports.LAYERID_WORLD = LAYERID_WORLD;
	exports.LAYER_FX = LAYER_FX;
	exports.LAYER_GIZMO = LAYER_GIZMO;
	exports.LAYER_HUD = LAYER_HUD;
	exports.LAYER_WORLD = LAYER_WORLD;
	exports.LIGHTFALLOFF_INVERSESQUARED = LIGHTFALLOFF_INVERSESQUARED;
	exports.LIGHTFALLOFF_LINEAR = LIGHTFALLOFF_LINEAR;
	exports.LIGHTSHAPE_DISK = LIGHTSHAPE_DISK;
	exports.LIGHTSHAPE_PUNCTUAL = LIGHTSHAPE_PUNCTUAL;
	exports.LIGHTSHAPE_RECT = LIGHTSHAPE_RECT;
	exports.LIGHTSHAPE_SPHERE = LIGHTSHAPE_SPHERE;
	exports.LIGHTTYPE_COUNT = LIGHTTYPE_COUNT;
	exports.LIGHTTYPE_DIRECTIONAL = LIGHTTYPE_DIRECTIONAL;
	exports.LIGHTTYPE_OMNI = LIGHTTYPE_OMNI;
	exports.LIGHTTYPE_POINT = LIGHTTYPE_POINT;
	exports.LIGHTTYPE_SPOT = LIGHTTYPE_SPOT;
	exports.LINEBATCH_GIZMO = LINEBATCH_GIZMO;
	exports.LINEBATCH_OVERLAY = LINEBATCH_OVERLAY;
	exports.LINEBATCH_WORLD = LINEBATCH_WORLD;
	exports.Layer = Layer;
	exports.LayerComposition = LayerComposition;
	exports.LayoutCalculator = LayoutCalculator;
	exports.LayoutChildComponent = LayoutChildComponent;
	exports.LayoutChildComponentSystem = LayoutChildComponentSystem;
	exports.LayoutGroupComponent = LayoutGroupComponent;
	exports.LayoutGroupComponentSystem = LayoutGroupComponentSystem;
	exports.Light = Light;
	exports.LightComponent = LightComponent;
	exports.LightComponentSystem = LightComponentSystem;
	exports.LightingParams = LightingParams;
	exports.Lightmapper = Lightmapper;
	exports.LocalizedAsset = LocalizedAsset;
	exports.MASK_AFFECT_DYNAMIC = MASK_AFFECT_DYNAMIC;
	exports.MASK_AFFECT_LIGHTMAPPED = MASK_AFFECT_LIGHTMAPPED;
	exports.MASK_BAKE = MASK_BAKE;
	exports.MOTION_FREE = MOTION_FREE;
	exports.MOTION_LIMITED = MOTION_LIMITED;
	exports.MOTION_LOCKED = MOTION_LOCKED;
	exports.MOUSEBUTTON_LEFT = MOUSEBUTTON_LEFT;
	exports.MOUSEBUTTON_MIDDLE = MOUSEBUTTON_MIDDLE;
	exports.MOUSEBUTTON_NONE = MOUSEBUTTON_NONE;
	exports.MOUSEBUTTON_RIGHT = MOUSEBUTTON_RIGHT;
	exports.Mat3 = Mat3;
	exports.Mat4 = Mat4;
	exports.Material = Material;
	exports.MaterialHandler = MaterialHandler;
	exports.Mesh = Mesh;
	exports.MeshInstance = MeshInstance;
	exports.Model = Model;
	exports.ModelComponent = ModelComponent;
	exports.ModelComponentSystem = ModelComponentSystem;
	exports.ModelHandler = ModelHandler;
	exports.Morph = Morph;
	exports.MorphInstance = MorphInstance;
	exports.MorphTarget = MorphTarget;
	exports.Mouse = Mouse;
	exports.MouseEvent = MouseEvent;
	exports.Node = Node;
	exports.ORIENTATION_HORIZONTAL = ORIENTATION_HORIZONTAL;
	exports.ORIENTATION_VERTICAL = ORIENTATION_VERTICAL;
	exports.OrientedBox = OrientedBox;
	exports.PAD_1 = PAD_1;
	exports.PAD_2 = PAD_2;
	exports.PAD_3 = PAD_3;
	exports.PAD_4 = PAD_4;
	exports.PAD_DOWN = PAD_DOWN;
	exports.PAD_FACE_1 = PAD_FACE_1;
	exports.PAD_FACE_2 = PAD_FACE_2;
	exports.PAD_FACE_3 = PAD_FACE_3;
	exports.PAD_FACE_4 = PAD_FACE_4;
	exports.PAD_LEFT = PAD_LEFT;
	exports.PAD_L_SHOULDER_1 = PAD_L_SHOULDER_1;
	exports.PAD_L_SHOULDER_2 = PAD_L_SHOULDER_2;
	exports.PAD_L_STICK_BUTTON = PAD_L_STICK_BUTTON;
	exports.PAD_L_STICK_X = PAD_L_STICK_X;
	exports.PAD_L_STICK_Y = PAD_L_STICK_Y;
	exports.PAD_RIGHT = PAD_RIGHT;
	exports.PAD_R_SHOULDER_1 = PAD_R_SHOULDER_1;
	exports.PAD_R_SHOULDER_2 = PAD_R_SHOULDER_2;
	exports.PAD_R_STICK_BUTTON = PAD_R_STICK_BUTTON;
	exports.PAD_R_STICK_X = PAD_R_STICK_X;
	exports.PAD_R_STICK_Y = PAD_R_STICK_Y;
	exports.PAD_SELECT = PAD_SELECT;
	exports.PAD_START = PAD_START;
	exports.PAD_UP = PAD_UP;
	exports.PAD_VENDOR = PAD_VENDOR;
	exports.PARTICLEMODE_CPU = PARTICLEMODE_CPU;
	exports.PARTICLEMODE_GPU = PARTICLEMODE_GPU;
	exports.PARTICLEORIENTATION_EMITTER = PARTICLEORIENTATION_EMITTER;
	exports.PARTICLEORIENTATION_SCREEN = PARTICLEORIENTATION_SCREEN;
	exports.PARTICLEORIENTATION_WORLD = PARTICLEORIENTATION_WORLD;
	exports.PARTICLESORT_DISTANCE = PARTICLESORT_DISTANCE;
	exports.PARTICLESORT_NEWER_FIRST = PARTICLESORT_NEWER_FIRST;
	exports.PARTICLESORT_NONE = PARTICLESORT_NONE;
	exports.PARTICLESORT_OLDER_FIRST = PARTICLESORT_OLDER_FIRST;
	exports.PIXELFORMAT_111110F = PIXELFORMAT_111110F;
	exports.PIXELFORMAT_A8 = PIXELFORMAT_A8;
	exports.PIXELFORMAT_ASTC_4x4 = PIXELFORMAT_ASTC_4x4;
	exports.PIXELFORMAT_ATC_RGB = PIXELFORMAT_ATC_RGB;
	exports.PIXELFORMAT_ATC_RGBA = PIXELFORMAT_ATC_RGBA;
	exports.PIXELFORMAT_DEPTH = PIXELFORMAT_DEPTH;
	exports.PIXELFORMAT_DEPTHSTENCIL = PIXELFORMAT_DEPTHSTENCIL;
	exports.PIXELFORMAT_DXT1 = PIXELFORMAT_DXT1;
	exports.PIXELFORMAT_DXT3 = PIXELFORMAT_DXT3;
	exports.PIXELFORMAT_DXT5 = PIXELFORMAT_DXT5;
	exports.PIXELFORMAT_ETC1 = PIXELFORMAT_ETC1;
	exports.PIXELFORMAT_ETC2_RGB = PIXELFORMAT_ETC2_RGB;
	exports.PIXELFORMAT_ETC2_RGBA = PIXELFORMAT_ETC2_RGBA;
	exports.PIXELFORMAT_L8 = PIXELFORMAT_L8;
	exports.PIXELFORMAT_L8_A8 = PIXELFORMAT_L8_A8;
	exports.PIXELFORMAT_PVRTC_2BPP_RGBA_1 = PIXELFORMAT_PVRTC_2BPP_RGBA_1;
	exports.PIXELFORMAT_PVRTC_2BPP_RGB_1 = PIXELFORMAT_PVRTC_2BPP_RGB_1;
	exports.PIXELFORMAT_PVRTC_4BPP_RGBA_1 = PIXELFORMAT_PVRTC_4BPP_RGBA_1;
	exports.PIXELFORMAT_PVRTC_4BPP_RGB_1 = PIXELFORMAT_PVRTC_4BPP_RGB_1;
	exports.PIXELFORMAT_R32F = PIXELFORMAT_R32F;
	exports.PIXELFORMAT_R4_G4_B4_A4 = PIXELFORMAT_R4_G4_B4_A4;
	exports.PIXELFORMAT_R5_G5_B5_A1 = PIXELFORMAT_R5_G5_B5_A1;
	exports.PIXELFORMAT_R5_G6_B5 = PIXELFORMAT_R5_G6_B5;
	exports.PIXELFORMAT_R8_G8_B8 = PIXELFORMAT_R8_G8_B8;
	exports.PIXELFORMAT_R8_G8_B8_A8 = PIXELFORMAT_R8_G8_B8_A8;
	exports.PIXELFORMAT_RGB16F = PIXELFORMAT_RGB16F;
	exports.PIXELFORMAT_RGB32F = PIXELFORMAT_RGB32F;
	exports.PIXELFORMAT_RGBA16F = PIXELFORMAT_RGBA16F;
	exports.PIXELFORMAT_RGBA32F = PIXELFORMAT_RGBA32F;
	exports.PIXELFORMAT_SRGB = PIXELFORMAT_SRGB;
	exports.PIXELFORMAT_SRGBA = PIXELFORMAT_SRGBA;
	exports.PRIMITIVE_LINELOOP = PRIMITIVE_LINELOOP;
	exports.PRIMITIVE_LINES = PRIMITIVE_LINES;
	exports.PRIMITIVE_LINESTRIP = PRIMITIVE_LINESTRIP;
	exports.PRIMITIVE_POINTS = PRIMITIVE_POINTS;
	exports.PRIMITIVE_TRIANGLES = PRIMITIVE_TRIANGLES;
	exports.PRIMITIVE_TRIFAN = PRIMITIVE_TRIFAN;
	exports.PRIMITIVE_TRISTRIP = PRIMITIVE_TRISTRIP;
	exports.PROJECTION_ORTHOGRAPHIC = PROJECTION_ORTHOGRAPHIC;
	exports.PROJECTION_PERSPECTIVE = PROJECTION_PERSPECTIVE;
	exports.ParticleEmitter = ParticleEmitter;
	exports.ParticleSystemComponent = ParticleSystemComponent;
	exports.ParticleSystemComponentSystem = ParticleSystemComponentSystem;
	exports.PhongMaterial = PhongMaterial;
	exports.Picker = Picker;
	exports.Plane = Plane;
	exports.PostEffect = PostEffect$1;
	exports.PostEffectQueue = PostEffectQueue;
	exports.ProgramLibrary = ProgramLibrary;
	exports.Quat = Quat;
	exports.RENDERSTYLE_POINTS = RENDERSTYLE_POINTS;
	exports.RENDERSTYLE_SOLID = RENDERSTYLE_SOLID;
	exports.RENDERSTYLE_WIREFRAME = RENDERSTYLE_WIREFRAME;
	exports.RESOLUTION_AUTO = RESOLUTION_AUTO;
	exports.RESOLUTION_FIXED = RESOLUTION_FIXED;
	exports.RIGIDBODY_ACTIVE_TAG = RIGIDBODY_ACTIVE_TAG;
	exports.RIGIDBODY_CF_KINEMATIC_OBJECT = RIGIDBODY_CF_KINEMATIC_OBJECT;
	exports.RIGIDBODY_CF_NORESPONSE_OBJECT = RIGIDBODY_CF_NORESPONSE_OBJECT;
	exports.RIGIDBODY_CF_STATIC_OBJECT = RIGIDBODY_CF_STATIC_OBJECT;
	exports.RIGIDBODY_DISABLE_DEACTIVATION = RIGIDBODY_DISABLE_DEACTIVATION;
	exports.RIGIDBODY_DISABLE_SIMULATION = RIGIDBODY_DISABLE_SIMULATION;
	exports.RIGIDBODY_ISLAND_SLEEPING = RIGIDBODY_ISLAND_SLEEPING;
	exports.RIGIDBODY_TYPE_DYNAMIC = RIGIDBODY_TYPE_DYNAMIC;
	exports.RIGIDBODY_TYPE_KINEMATIC = RIGIDBODY_TYPE_KINEMATIC;
	exports.RIGIDBODY_TYPE_STATIC = RIGIDBODY_TYPE_STATIC;
	exports.RIGIDBODY_WANTS_DEACTIVATION = RIGIDBODY_WANTS_DEACTIVATION;
	exports.Ray = Ray;
	exports.RaycastResult = RaycastResult;
	exports.ReadStream = ReadStream;
	exports.RenderComponent = RenderComponent;
	exports.RenderComponentSystem = RenderComponentSystem;
	exports.RenderHandler = RenderHandler;
	exports.RenderTarget = RenderTarget;
	exports.ResourceHandler = ResourceHandler;
	exports.ResourceLoader = ResourceLoader;
	exports.RigidBodyComponent = RigidBodyComponent;
	exports.RigidBodyComponentSystem = RigidBodyComponentSystem;
	exports.SCALEMODE_BLEND = SCALEMODE_BLEND;
	exports.SCALEMODE_NONE = SCALEMODE_NONE;
	exports.SCROLLBAR_VISIBILITY_SHOW_ALWAYS = SCROLLBAR_VISIBILITY_SHOW_ALWAYS;
	exports.SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED = SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED;
	exports.SCROLL_MODE_BOUNCE = SCROLL_MODE_BOUNCE;
	exports.SCROLL_MODE_CLAMP = SCROLL_MODE_CLAMP;
	exports.SCROLL_MODE_INFINITE = SCROLL_MODE_INFINITE;
	exports.SEMANTIC_ATTR = SEMANTIC_ATTR;
	exports.SEMANTIC_ATTR0 = SEMANTIC_ATTR0;
	exports.SEMANTIC_ATTR1 = SEMANTIC_ATTR1;
	exports.SEMANTIC_ATTR10 = SEMANTIC_ATTR10;
	exports.SEMANTIC_ATTR11 = SEMANTIC_ATTR11;
	exports.SEMANTIC_ATTR12 = SEMANTIC_ATTR12;
	exports.SEMANTIC_ATTR13 = SEMANTIC_ATTR13;
	exports.SEMANTIC_ATTR14 = SEMANTIC_ATTR14;
	exports.SEMANTIC_ATTR15 = SEMANTIC_ATTR15;
	exports.SEMANTIC_ATTR2 = SEMANTIC_ATTR2;
	exports.SEMANTIC_ATTR3 = SEMANTIC_ATTR3;
	exports.SEMANTIC_ATTR4 = SEMANTIC_ATTR4;
	exports.SEMANTIC_ATTR5 = SEMANTIC_ATTR5;
	exports.SEMANTIC_ATTR6 = SEMANTIC_ATTR6;
	exports.SEMANTIC_ATTR7 = SEMANTIC_ATTR7;
	exports.SEMANTIC_ATTR8 = SEMANTIC_ATTR8;
	exports.SEMANTIC_ATTR9 = SEMANTIC_ATTR9;
	exports.SEMANTIC_BLENDINDICES = SEMANTIC_BLENDINDICES;
	exports.SEMANTIC_BLENDWEIGHT = SEMANTIC_BLENDWEIGHT;
	exports.SEMANTIC_COLOR = SEMANTIC_COLOR;
	exports.SEMANTIC_NORMAL = SEMANTIC_NORMAL;
	exports.SEMANTIC_POSITION = SEMANTIC_POSITION;
	exports.SEMANTIC_TANGENT = SEMANTIC_TANGENT;
	exports.SEMANTIC_TEXCOORD = SEMANTIC_TEXCOORD;
	exports.SEMANTIC_TEXCOORD0 = SEMANTIC_TEXCOORD0;
	exports.SEMANTIC_TEXCOORD1 = SEMANTIC_TEXCOORD1;
	exports.SEMANTIC_TEXCOORD2 = SEMANTIC_TEXCOORD2;
	exports.SEMANTIC_TEXCOORD3 = SEMANTIC_TEXCOORD3;
	exports.SEMANTIC_TEXCOORD4 = SEMANTIC_TEXCOORD4;
	exports.SEMANTIC_TEXCOORD5 = SEMANTIC_TEXCOORD5;
	exports.SEMANTIC_TEXCOORD6 = SEMANTIC_TEXCOORD6;
	exports.SEMANTIC_TEXCOORD7 = SEMANTIC_TEXCOORD7;
	exports.SHADERDEF_DIRLM = SHADERDEF_DIRLM;
	exports.SHADERDEF_INSTANCING = SHADERDEF_INSTANCING;
	exports.SHADERDEF_LM = SHADERDEF_LM;
	exports.SHADERDEF_LMAMBIENT = SHADERDEF_LMAMBIENT;
	exports.SHADERDEF_MORPH_NORMAL = SHADERDEF_MORPH_NORMAL;
	exports.SHADERDEF_MORPH_POSITION = SHADERDEF_MORPH_POSITION;
	exports.SHADERDEF_MORPH_TEXTURE_BASED = SHADERDEF_MORPH_TEXTURE_BASED;
	exports.SHADERDEF_NOSHADOW = SHADERDEF_NOSHADOW;
	exports.SHADERDEF_SCREENSPACE = SHADERDEF_SCREENSPACE;
	exports.SHADERDEF_SKIN = SHADERDEF_SKIN;
	exports.SHADERDEF_TANGENTS = SHADERDEF_TANGENTS;
	exports.SHADERDEF_UV0 = SHADERDEF_UV0;
	exports.SHADERDEF_UV1 = SHADERDEF_UV1;
	exports.SHADERDEF_VCOLOR = SHADERDEF_VCOLOR;
	exports.SHADERSTAGE_COMPUTE = SHADERSTAGE_COMPUTE;
	exports.SHADERSTAGE_FRAGMENT = SHADERSTAGE_FRAGMENT;
	exports.SHADERSTAGE_VERTEX = SHADERSTAGE_VERTEX;
	exports.SHADERTAG_MATERIAL = SHADERTAG_MATERIAL;
	exports.SHADERTYPE_DEPTH = SHADERTYPE_DEPTH;
	exports.SHADERTYPE_FORWARD = SHADERTYPE_FORWARD;
	exports.SHADERTYPE_PICK = SHADERTYPE_PICK;
	exports.SHADERTYPE_SHADOW = SHADERTYPE_SHADOW;
	exports.SHADER_DEPTH = SHADER_DEPTH;
	exports.SHADER_FORWARD = SHADER_FORWARD;
	exports.SHADER_FORWARDHDR = SHADER_FORWARDHDR;
	exports.SHADER_PICK = SHADER_PICK;
	exports.SHADER_SHADOW = SHADER_SHADOW;
	exports.SHADOWUPDATE_NONE = SHADOWUPDATE_NONE;
	exports.SHADOWUPDATE_REALTIME = SHADOWUPDATE_REALTIME;
	exports.SHADOWUPDATE_THISFRAME = SHADOWUPDATE_THISFRAME;
	exports.SHADOW_COUNT = SHADOW_COUNT;
	exports.SHADOW_DEPTH = SHADOW_DEPTH;
	exports.SHADOW_PCF1 = SHADOW_PCF1;
	exports.SHADOW_PCF3 = SHADOW_PCF3;
	exports.SHADOW_PCF5 = SHADOW_PCF5;
	exports.SHADOW_VSM16 = SHADOW_VSM16;
	exports.SHADOW_VSM32 = SHADOW_VSM32;
	exports.SHADOW_VSM8 = SHADOW_VSM8;
	exports.SORTKEY_DEPTH = SORTKEY_DEPTH;
	exports.SORTKEY_FORWARD = SORTKEY_FORWARD;
	exports.SORTMODE_BACK2FRONT = SORTMODE_BACK2FRONT;
	exports.SORTMODE_CUSTOM = SORTMODE_CUSTOM;
	exports.SORTMODE_FRONT2BACK = SORTMODE_FRONT2BACK;
	exports.SORTMODE_MANUAL = SORTMODE_MANUAL;
	exports.SORTMODE_MATERIALMESH = SORTMODE_MATERIALMESH;
	exports.SORTMODE_NONE = SORTMODE_NONE;
	exports.SPECOCC_AO = SPECOCC_AO;
	exports.SPECOCC_GLOSSDEPENDENT = SPECOCC_GLOSSDEPENDENT;
	exports.SPECOCC_NONE = SPECOCC_NONE;
	exports.SPECULAR_BLINN = SPECULAR_BLINN;
	exports.SPECULAR_PHONG = SPECULAR_PHONG;
	exports.SPRITETYPE_ANIMATED = SPRITETYPE_ANIMATED;
	exports.SPRITETYPE_SIMPLE = SPRITETYPE_SIMPLE;
	exports.SPRITE_RENDERMODE_SIMPLE = SPRITE_RENDERMODE_SIMPLE;
	exports.SPRITE_RENDERMODE_SLICED = SPRITE_RENDERMODE_SLICED;
	exports.SPRITE_RENDERMODE_TILED = SPRITE_RENDERMODE_TILED;
	exports.STENCILOP_DECREMENT = STENCILOP_DECREMENT;
	exports.STENCILOP_DECREMENTWRAP = STENCILOP_DECREMENTWRAP;
	exports.STENCILOP_INCREMENT = STENCILOP_INCREMENT;
	exports.STENCILOP_INCREMENTWRAP = STENCILOP_INCREMENTWRAP;
	exports.STENCILOP_INVERT = STENCILOP_INVERT;
	exports.STENCILOP_KEEP = STENCILOP_KEEP;
	exports.STENCILOP_REPLACE = STENCILOP_REPLACE;
	exports.STENCILOP_ZERO = STENCILOP_ZERO;
	exports.Scene = Scene;
	exports.SceneHandler = SceneHandler;
	exports.SceneRegistry = SceneRegistry;
	exports.SceneRegistryItem = SceneRegistryItem;
	exports.SceneSettingsHandler = SceneSettingsHandler;
	exports.ScopeId = ScopeId;
	exports.ScopeSpace = ScopeSpace;
	exports.ScreenComponent = ScreenComponent;
	exports.ScreenComponentSystem = ScreenComponentSystem;
	exports.ScriptAttributes = ScriptAttributes;
	exports.ScriptComponent = ScriptComponent;
	exports.ScriptComponentSystem = ScriptComponentSystem;
	exports.ScriptHandler = ScriptHandler;
	exports.ScriptLegacyComponent = ScriptLegacyComponent;
	exports.ScriptLegacyComponentSystem = ScriptLegacyComponentSystem;
	exports.ScriptRegistry = ScriptRegistry;
	exports.ScriptType = ScriptType;
	exports.ScrollViewComponent = ScrollViewComponent;
	exports.ScrollViewComponentSystem = ScrollViewComponentSystem;
	exports.ScrollbarComponent = ScrollbarComponent;
	exports.ScrollbarComponentSystem = ScrollbarComponentSystem;
	exports.Shader = Shader;
	exports.ShaderHandler = ShaderHandler;
	exports.SingleContactResult = SingleContactResult;
	exports.Skeleton = Skeleton;
	exports.Skin = Skin;
	exports.SkinBatchInstance = SkinBatchInstance;
	exports.SkinInstance = SkinInstance;
	exports.SortedLoopArray = SortedLoopArray;
	exports.Sound = Sound;
	exports.SoundComponent = SoundComponent;
	exports.SoundComponentSystem = SoundComponentSystem;
	exports.SoundInstance = SoundInstance;
	exports.SoundInstance3d = SoundInstance3d;
	exports.SoundManager = SoundManager;
	exports.SoundSlot = SoundSlot;
	exports.Sprite = Sprite;
	exports.SpriteAnimationClip = SpriteAnimationClip;
	exports.SpriteComponent = SpriteComponent;
	exports.SpriteComponentSystem = SpriteComponentSystem;
	exports.SpriteHandler = SpriteHandler;
	exports.StandardMaterial = StandardMaterial;
	exports.StencilParameters = StencilParameters;
	exports.TEXHINT_ASSET = TEXHINT_ASSET;
	exports.TEXHINT_LIGHTMAP = TEXHINT_LIGHTMAP;
	exports.TEXHINT_NONE = TEXHINT_NONE;
	exports.TEXHINT_SHADOWMAP = TEXHINT_SHADOWMAP;
	exports.TEXTURELOCK_READ = TEXTURELOCK_READ;
	exports.TEXTURELOCK_WRITE = TEXTURELOCK_WRITE;
	exports.TEXTUREPROJECTION_CUBE = TEXTUREPROJECTION_CUBE;
	exports.TEXTUREPROJECTION_EQUIRECT = TEXTUREPROJECTION_EQUIRECT;
	exports.TEXTUREPROJECTION_NONE = TEXTUREPROJECTION_NONE;
	exports.TEXTUREPROJECTION_OCTAHEDRAL = TEXTUREPROJECTION_OCTAHEDRAL;
	exports.TEXTURETYPE_DEFAULT = TEXTURETYPE_DEFAULT;
	exports.TEXTURETYPE_RGBE = TEXTURETYPE_RGBE;
	exports.TEXTURETYPE_RGBM = TEXTURETYPE_RGBM;
	exports.TEXTURETYPE_RGBP = TEXTURETYPE_RGBP;
	exports.TEXTURETYPE_SWIZZLEGGGR = TEXTURETYPE_SWIZZLEGGGR;
	exports.TONEMAP_ACES = TONEMAP_ACES;
	exports.TONEMAP_ACES2 = TONEMAP_ACES2;
	exports.TONEMAP_FILMIC = TONEMAP_FILMIC;
	exports.TONEMAP_HEJL = TONEMAP_HEJL;
	exports.TONEMAP_LINEAR = TONEMAP_LINEAR;
	exports.TRACEID_RENDER_ACTION = TRACEID_RENDER_ACTION;
	exports.TRACEID_RENDER_FRAME = TRACEID_RENDER_FRAME;
	exports.TRACEID_RENDER_PASS = TRACEID_RENDER_PASS;
	exports.TRACEID_RENDER_PASS_DETAIL = TRACEID_RENDER_PASS_DETAIL;
	exports.TRACEID_RENDER_TARGET_ALLOC = TRACEID_RENDER_TARGET_ALLOC;
	exports.TRACEID_SHADER_ALLOC = TRACEID_SHADER_ALLOC;
	exports.TRACEID_TEXTURE_ALLOC = TRACEID_TEXTURE_ALLOC;
	exports.TRACEID_VRAM_IB = TRACEID_VRAM_IB;
	exports.TRACEID_VRAM_TEXTURE = TRACEID_VRAM_TEXTURE;
	exports.TRACEID_VRAM_VB = TRACEID_VRAM_VB;
	exports.TYPE_FLOAT32 = TYPE_FLOAT32;
	exports.TYPE_INT16 = TYPE_INT16;
	exports.TYPE_INT32 = TYPE_INT32;
	exports.TYPE_INT8 = TYPE_INT8;
	exports.TYPE_UINT16 = TYPE_UINT16;
	exports.TYPE_UINT32 = TYPE_UINT32;
	exports.TYPE_UINT8 = TYPE_UINT8;
	exports.Tags = Tags;
	exports.Template = Template;
	exports.TemplateHandler = TemplateHandler;
	exports.TextElement = TextElement;
	exports.TextHandler = TextHandler;
	exports.Texture = Texture;
	exports.TextureAtlas = TextureAtlas;
	exports.TextureAtlasHandler = TextureAtlasHandler;
	exports.TextureHandler = TextureHandler;
	exports.TextureParser = TextureParser;
	exports.Timer = Timer;
	exports.Touch = Touch;
	exports.TouchDevice = TouchDevice;
	exports.TouchEvent = TouchEvent;
	exports.Tracing = Tracing;
	exports.TransformFeedback = TransformFeedback;
	exports.UNIFORMTYPE_BOOL = UNIFORMTYPE_BOOL;
	exports.UNIFORMTYPE_BVEC2 = UNIFORMTYPE_BVEC2;
	exports.UNIFORMTYPE_BVEC3 = UNIFORMTYPE_BVEC3;
	exports.UNIFORMTYPE_BVEC4 = UNIFORMTYPE_BVEC4;
	exports.UNIFORMTYPE_FLOAT = UNIFORMTYPE_FLOAT;
	exports.UNIFORMTYPE_FLOATARRAY = UNIFORMTYPE_FLOATARRAY;
	exports.UNIFORMTYPE_INT = UNIFORMTYPE_INT;
	exports.UNIFORMTYPE_IVEC2 = UNIFORMTYPE_IVEC2;
	exports.UNIFORMTYPE_IVEC3 = UNIFORMTYPE_IVEC3;
	exports.UNIFORMTYPE_IVEC4 = UNIFORMTYPE_IVEC4;
	exports.UNIFORMTYPE_MAT2 = UNIFORMTYPE_MAT2;
	exports.UNIFORMTYPE_MAT3 = UNIFORMTYPE_MAT3;
	exports.UNIFORMTYPE_MAT4 = UNIFORMTYPE_MAT4;
	exports.UNIFORMTYPE_TEXTURE2D = UNIFORMTYPE_TEXTURE2D;
	exports.UNIFORMTYPE_TEXTURE2D_SHADOW = UNIFORMTYPE_TEXTURE2D_SHADOW;
	exports.UNIFORMTYPE_TEXTURE3D = UNIFORMTYPE_TEXTURE3D;
	exports.UNIFORMTYPE_TEXTURECUBE = UNIFORMTYPE_TEXTURECUBE;
	exports.UNIFORMTYPE_TEXTURECUBE_SHADOW = UNIFORMTYPE_TEXTURECUBE_SHADOW;
	exports.UNIFORMTYPE_VEC2 = UNIFORMTYPE_VEC2;
	exports.UNIFORMTYPE_VEC2ARRAY = UNIFORMTYPE_VEC2ARRAY;
	exports.UNIFORMTYPE_VEC3 = UNIFORMTYPE_VEC3;
	exports.UNIFORMTYPE_VEC3ARRAY = UNIFORMTYPE_VEC3ARRAY;
	exports.UNIFORMTYPE_VEC4 = UNIFORMTYPE_VEC4;
	exports.UNIFORMTYPE_VEC4ARRAY = UNIFORMTYPE_VEC4ARRAY;
	exports.UNIFORM_BUFFER_DEFAULT_SLOT_NAME = UNIFORM_BUFFER_DEFAULT_SLOT_NAME;
	exports.URI = URI;
	exports.UnsupportedBrowserError = UnsupportedBrowserError;
	exports.VIEW_CENTER = VIEW_CENTER;
	exports.VIEW_LEFT = VIEW_LEFT;
	exports.VIEW_RIGHT = VIEW_RIGHT;
	exports.Vec2 = Vec2;
	exports.Vec3 = Vec3;
	exports.Vec4 = Vec4;
	exports.VertexBuffer = VertexBuffer;
	exports.VertexFormat = VertexFormat;
	exports.VertexIterator = VertexIterator;
	exports.WasmModule = WasmModule;
	exports.WebglGraphicsDevice = WebglGraphicsDevice;
	exports.WorldClusters = WorldClusters;
	exports.XRDEPTHSENSINGFORMAT_F32 = XRDEPTHSENSINGFORMAT_F32;
	exports.XRDEPTHSENSINGFORMAT_L8A8 = XRDEPTHSENSINGFORMAT_L8A8;
	exports.XRDEPTHSENSINGUSAGE_CPU = XRDEPTHSENSINGUSAGE_CPU;
	exports.XRDEPTHSENSINGUSAGE_GPU = XRDEPTHSENSINGUSAGE_GPU;
	exports.XRHAND_LEFT = XRHAND_LEFT;
	exports.XRHAND_NONE = XRHAND_NONE;
	exports.XRHAND_RIGHT = XRHAND_RIGHT;
	exports.XRSPACE_BOUNDEDFLOOR = XRSPACE_BOUNDEDFLOOR;
	exports.XRSPACE_LOCAL = XRSPACE_LOCAL;
	exports.XRSPACE_LOCALFLOOR = XRSPACE_LOCALFLOOR;
	exports.XRSPACE_UNBOUNDED = XRSPACE_UNBOUNDED;
	exports.XRSPACE_VIEWER = XRSPACE_VIEWER;
	exports.XRTARGETRAY_GAZE = XRTARGETRAY_GAZE;
	exports.XRTARGETRAY_POINTER = XRTARGETRAY_POINTER;
	exports.XRTARGETRAY_SCREEN = XRTARGETRAY_SCREEN;
	exports.XRTRACKABLE_MESH = XRTRACKABLE_MESH;
	exports.XRTRACKABLE_PLANE = XRTRACKABLE_PLANE;
	exports.XRTRACKABLE_POINT = XRTRACKABLE_POINT;
	exports.XRTYPE_AR = XRTYPE_AR;
	exports.XRTYPE_INLINE = XRTYPE_INLINE;
	exports.XRTYPE_VR = XRTYPE_VR;
	exports.XrDepthSensing = XrDepthSensing;
	exports.XrDomOverlay = XrDomOverlay;
	exports.XrHitTest = XrHitTest;
	exports.XrHitTestSource = XrHitTestSource;
	exports.XrImageTracking = XrImageTracking;
	exports.XrInput = XrInput;
	exports.XrInputSource = XrInputSource;
	exports.XrLightEstimation = XrLightEstimation;
	exports.XrManager = XrManager;
	exports.XrPlane = XrPlane;
	exports.XrPlaneDetection = XrPlaneDetection;
	exports.XrTrackedImage = XrTrackedImage;
	exports.ZoneComponent = ZoneComponent;
	exports.ZoneComponentSystem = ZoneComponentSystem;
	exports.anim = anim;
	exports.apps = apps;
	exports.asset = asset;
	exports.audio = audio;
	exports.basisInitialize = basisInitialize;
	exports.basisSetDownloadConfig = basisSetDownloadConfig;
	exports.basisTranscode = basisTranscode;
	exports.bindGroupNames = bindGroupNames;
	exports.calculateNormals = calculateNormals;
	exports.calculateTangents = calculateTangents;
	exports.common = common;
	exports.config = config;
	exports.createBox = createBox;
	exports.createCapsule = createCapsule;
	exports.createCone = createCone;
	exports.createCylinder = createCylinder;
	exports.createMesh = createMesh$1;
	exports.createPlane = createPlane;
	exports.createScript = createScript;
	exports.createShader = createShader;
	exports.createShaderFromCode = createShaderFromCode;
	exports.createSphere = createSphere;
	exports.createStyle = createStyle;
	exports.createTorus = createTorus;
	exports.createURI = createURI;
	exports.data = data;
	exports.drawFullscreenQuad = drawFullscreenQuad;
	exports.drawQuadWithShader = drawQuadWithShader;
	exports.drawTexture = drawTexture;
	exports.events = events;
	exports.extend = extend;
	exports.fw = fw;
	exports.getTouchTargetCoords = getTouchTargetCoords;
	exports.gfx = gfx;
	exports.guid = guid;
	exports.http = http;
	exports.inherits = inherits;
	exports.input = input;
	exports.isDefined = isDefined;
	exports.log = log;
	exports.makeArray = makeArray;
	exports.math = math;
	exports.now = now;
	exports.path = path;
	exports.platform = platform;
	exports.posteffect = posteffect;
	exports.prefilterCubemap = prefilterCubemap;
	exports.programlib = programlib;
	exports.registerScript = registerScript;
	exports.reprojectTexture = reprojectTexture;
	exports.revision = revision;
	exports.scene = scene;
	exports.script = script;
	exports.semanticToLocation = semanticToLocation;
	exports.shFromCubemap = shFromCubemap;
	exports.shaderChunks = shaderChunks;
	exports.shadowTypeToString = shadowTypeToString;
	exports.shape = shape;
	exports.string = string;
	exports.time = time;
	exports.type = type$1;
	exports.typedArrayIndexFormats = typedArrayIndexFormats;
	exports.typedArrayIndexFormatsByteSize = typedArrayIndexFormatsByteSize;
	exports.typedArrayToType = typedArrayToType;
	exports.typedArrayTypes = typedArrayTypes;
	exports.typedArrayTypesByteSize = typedArrayTypesByteSize;
	exports.uniformTypeToName = uniformTypeToName;
	exports.version = version;

	Object.defineProperty(exports, '__esModule', { value: true });

}));
