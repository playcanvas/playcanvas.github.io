import"../../core/tracing.js";import"../../core/time.js";import{ShaderInput as e}from"../shader-input.js";import{semanticToLocation as t}from"../constants.js";const r=["gl_VertexID","gl_InstanceID","gl_DrawID","gl_BaseVertex","gl_BaseInstance"];class s{constructor(e){this.init(),this.compileAndLink(e.device,e),e.device.shaders.push(e)}destroy(e){const t=e.device,r=t.shaders.indexOf(e);-1!==r&&t.shaders.splice(r,1),this.glProgram&&(t.gl.deleteProgram(this.glProgram),this.glProgram=null,t.removeShaderFromCache(e))}init(){this.uniforms=[],this.samplers=[],this.attributes=[],this.glProgram=null,this.glVertexShader=null,this.glFragmentShader=null}loseContext(){this.init()}restoreContext(e,t){this.compileAndLink(e,t)}compileAndLink(e,r){const s=r.definition,i=this._compileShaderSource(e,s.vshader,!0),o=this._compileShaderSource(e,s.fshader,!1),n=e.gl,a=n.createProgram();n.attachShader(a,i),n.attachShader(a,o);const h=s.attributes;if(e.webgl2&&s.useTransformFeedback){const e=[];for(const t in h)h.hasOwnProperty(t)&&e.push("out_"+t);n.transformFeedbackVaryings(a,e,n.INTERLEAVED_ATTRIBS)}for(const e in h)if(h.hasOwnProperty(e)){const r=h[e],s=t[r];n.bindAttribLocation(a,s,e)}n.linkProgram(a),this.glVertexShader=i,this.glFragmentShader=o,this.glProgram=a}_compileShaderSource(e,t,r){const s=e.gl,i=r?e.vertexShaderCache:e.fragmentShaderCache;let o=i[t];return o||(o=s.createShader(r?s.VERTEX_SHADER:s.FRAGMENT_SHADER),s.shaderSource(o,t),s.compileShader(o),i[t]=o),o}postLink(t,s){const i=t.gl,o=this.glProgram,n=s.definition;if(!this._isCompiled(t,s,this.glVertexShader,n.vshader,"vertex"))return!1;if(!this._isCompiled(t,s,this.glFragmentShader,n.fshader,"fragment"))return!1;if(!i.getProgramParameter(o,i.LINK_STATUS)){const e="Failed to link shader program. Error: "+i.getProgramInfoLog(o);return console.error(e),!1}let a=0;const h=i.getProgramParameter(o,i.ACTIVE_ATTRIBUTES);for(;a<h;){const s=i.getActiveAttrib(o,a++),h=i.getAttribLocation(o,s.name);if(-1!==r.indexOf(s.name))continue;void 0===n.attributes[s.name]&&console.error(`Vertex shader attribute "${s.name}" is not mapped to a semantic in shader definition.`);const c=new e(t,n.attributes[s.name],t.pcUniformType[s.type],h);this.attributes.push(c)}a=0;const c=i.getProgramParameter(o,i.ACTIVE_UNIFORMS);for(;a<c;){const r=i.getActiveUniform(o,a++),s=i.getUniformLocation(o,r.name),n=new e(t,r.name,t.pcUniformType[r.type],s);r.type===i.SAMPLER_2D||r.type===i.SAMPLER_CUBE||t.webgl2&&(r.type===i.SAMPLER_2D_SHADOW||r.type===i.SAMPLER_CUBE_SHADOW||r.type===i.SAMPLER_3D)?this.samplers.push(n):this.uniforms.push(n)}return s.ready=!0,!0}_isCompiled(e,t,r,s,i){const o=e.gl;if(!o.getShaderParameter(r,o.COMPILE_STATUS)){const e=o.getShaderInfoLog(r),[t,n]=this._processError(s,e),a=`Failed to compile ${i} shader:\n\n${e}\n${t}`;return console.error(a),!1}return!0}_processError(e,t){const r={};let s="";if(e){const i=e.split("\n");let o=0,n=i.length;if(t&&t.startsWith("ERROR:")){const e=t.match(/^ERROR:\s([0-9]+):([0-9]+):\s*(.+)/);e&&(r.message=e[3],r.line=parseInt(e[2],10),o=Math.max(0,r.line-6),n=Math.min(i.length,r.line+5))}for(let e=o;e<n;e++)s+=e+1+":\t"+i[e]+"\n";r.source=e}return[s,r]}}export{s as WebglShader};
