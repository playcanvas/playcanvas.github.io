import"../../core/tracing.js";import"../../core/time.js";import{Color as e}from"../../core/math/color.js";import{Mat4 as t}from"../../core/math/mat4.js";import{Vec3 as s}from"../../core/math/vec3.js";import{Vec4 as r}from"../../core/math/vec4.js";import{UNIFORMTYPE_MAT4 as i,UNIFORM_BUFFER_DEFAULT_SLOT_NAME as a,SHADERSTAGE_VERTEX as o,SHADERSTAGE_FRAGMENT as n}from"../../platform/graphics/constants.js";import{drawQuadWithShader as h}from"../graphics/quad-render-utils.js";import{SHADOW_VSM8 as d,SHADOW_VSM32 as l,SHADOW_PCF5 as p,SHADOW_PCF3 as c,LIGHTTYPE_OMNI as u,LIGHTTYPE_DIRECTIONAL as m,SORTKEY_DEPTH as f,SHADOWUPDATE_NONE as w,SHADOWUPDATE_THISFRAME as g,BLUR_GAUSSIAN as S,SHADER_SHADOW as V}from"../constants.js";import{ShaderPass as b}from"../shader-pass.js";import{shaderChunks as y}from"../shader-lib/chunks/chunks.js";import{createShaderFromCode as v}from"../shader-lib/utils.js";import{LightCamera as B}from"./light-camera.js";import{UniformBufferFormat as C,UniformFormat as _}from"../../platform/graphics/uniform-buffer-format.js";import{BindGroupFormat as O,BindBufferFormat as M}from"../../platform/graphics/bind-group-format.js";import{BlendState as D}from"../../platform/graphics/blend-state.js";import{DepthState as F}from"../../platform/graphics/depth-state.js";function U(e,t){return Math.exp(-e*e/(2*t*t))}const P=new t,j=new t,R=new Float32Array(2),x=new r(1,1,0,0),I={r:1,g:2,b:3,a:4},T=new t;function k(e){const t=e.material,s=e.skinInstance?10:0;let r=0;if(t.opacityMap){const e=t.opacityMapChannel;e&&(r=I[e])}return s+r}class L{constructor(e,t){this.device=e.device,this.renderer=e,this.lightTextureAtlas=t;const s=this.device.scope;this.polygonOffsetId=s.resolve("polygonOffset"),this.polygonOffset=new Float32Array(2),this.sourceId=s.resolve("source"),this.pixelOffsetId=s.resolve("pixelOffset"),this.weightId=s.resolve("weight[0]"),this.blurVsmShaderCode=[y.blurVSMPS,"#define GAUSS\n"+y.blurVSMPS];const r="#define PACKED\n";this.blurPackedVsmShaderCode=[r+this.blurVsmShaderCode[0],r+this.blurVsmShaderCode[1]],this.blurVsmShader=[{},{}],this.blurPackedVsmShader=[{},{}],this.blurVsmWeights={},this.shadowMapLightRadiusId=s.resolve("light_radius"),this.viewUniformFormat=null,this.viewBindGroupFormat=null,this.blendStateWrite=new D,this.blendStateNoWrite=new D,this.blendStateNoWrite.setColorWrite(!1,!1,!1,!1)}static createShadowCamera(t,s,r,i){const a=B.create("ShadowCamera",r,i);return a.clearColor=s>=d&&s<=l?new e(0,0,0,0):new e(1,1,1,1),a.clearDepthBuffer=!0,a.clearStencilBuffer=!1,a}static setShadowCameraSettings(e,t,s,r,i){let a=s===p||s===c&&t.supportsDepthShadow;r!==u||i||(a=!1),e.clearColorBuffer=!a}cullShadowCasters(e,t,s){let r=0;const i=e.length;for(let a=0;a<i;a++){const i=e[a];i.castShadow&&(i.cull&&!i._isVisible(s)||(i.visibleThisFrame=!0,t[r]=i,r++))}t.length=r,t.sort(this.renderer.sortCompareDepth)}setupRenderState(e,t){const s=this.renderer.scene.clusteredLightingEnabled;e.webgl2||e.isWebGPU?t._type!==u||s?(e.setDepthBias(!0),e.setDepthBiasValues(-1e3*t.shadowBias,-1e3*t.shadowBias)):e.setDepthBias(!1):e.extStandardDerivatives&&(t._type===u?(this.polygonOffset[0]=0,this.polygonOffset[1]=0,this.polygonOffsetId.setValue(this.polygonOffset)):(this.polygonOffset[0]=-1e3*t.shadowBias,this.polygonOffset[1]=-1e3*t.shadowBias,this.polygonOffsetId.setValue(this.polygonOffset)));const r=s?t._isPcf&&e.webgl2:t._isPcf&&e.webgl2&&t._type!==u;e.setBlendState(r?this.blendStateNoWrite:this.blendStateWrite),e.setDepthState(F.DEFAULT)}restoreRenderState(e){e.webgl2?e.setDepthBias(!1):e.extStandardDerivatives&&(this.polygonOffset[0]=0,this.polygonOffset[1]=0,this.polygonOffsetId.setValue(this.polygonOffset))}dispatchUniforms(e,t,r,i){const a=t._node;e._type!==m&&(this.renderer.dispatchViewPos(a.getPosition()),this.shadowMapLightRadiusId.setValue(e.attenuationEnd)),P.setTRS(a.getPosition(),a.getRotation(),s.ONE).invert(),j.mul2(t.projectionMatrix,P);const o=r.shadowViewport;t.rect=o,t.scissorRect=r.shadowScissor,T.setViewport(o.x,o.y,o.z,o.w),r.shadowMatrix.mul2(T,j),e._type===m&&e._shadowMatrixPalette.set(r.shadowMatrix.data,16*i)}submitCasters(e,t){const s=this.device,r=this.renderer,i=r.scene,a=1<<V,o=b.getShadow(t._type,t._shadowType),n=e.length;for(let t=0;t<n;t++){const n=e[t],h=n.mesh;n.ensureMaterial(s);const d=n.material;r.setBaseConstants(s,d),r.setSkinning(s,n),d.dirty&&(d.updateUniforms(s,i),d.dirty=!1),d.chunks&&(r.setCullMode(!0,!1,n),d.setParameters(s),n.setParameters(s,a));let l=n._shader[o];l||(n.updatePassShader(i,o,null,null,this.viewUniformFormat,this.viewBindGroupFormat),l=n._shader[o],n._key[f]=k(n)),!l.failed&&s.setShader(l),r.setVertexBuffers(s,h),r.setMorphing(s,n.morphInstance),this.renderer.setupMeshUniformBuffers(n,o);const p=n.renderStyle;s.setIndexBuffer(h.indexBuffer[p]),r.drawInstance(s,n,h,p),r._shadowDrawCalls++}}needsShadowRendering(e){const t=e.enabled&&e.castShadows&&e.shadowUpdateMode!==w&&e.visibleThisFrame;return e.shadowUpdateMode===g&&(e.shadowUpdateMode=w),t&&(this.renderer._shadowMapUpdates+=e.numShadowFaces),t}getLightRenderData(e,t,s){return e.getRenderData(e._type===m?t:null,s)}setupRenderPass(e,t,s){const r=t.renderTarget;e.init(r),e.depthStencilOps.clearDepthValue=1,e.depthStencilOps.clearDepth=s,r.depthBuffer?e.depthStencilOps.storeDepth=!0:(e.colorOps.clearValue.copy(t.clearColor),e.colorOps.clear=s,e.depthStencilOps.storeDepth=!1),e.requiresCubemaps=!1}prepareFace(e,t,s){const r=e._type,i=e._shadowType,a=this.renderer.scene.clusteredLightingEnabled,o=this.getLightRenderData(e,t,s).shadowCamera;L.setShadowCameraSettings(o,this.device,i,r,a);const n=r===m?0:s;return o.renderTarget=e._shadowMap.renderTargets[n],o}renderFace(e,t,s,r,i=!0){const a=this.device,o=this.getLightRenderData(e,t,s),n=o.shadowCamera;this.dispatchUniforms(e,n,o,s);const h=n.renderTarget,d=this.renderer;d.setCameraUniforms(n,h),a.supportsUniformBuffers&&d.setupViewUniformBuffers(o.viewBindGroups,this.viewUniformFormat,this.viewBindGroupFormat,1),i?(d.setupViewport(n,h),r&&d.clear(n)):d.clearView(n,h,!0,!1),this.setupRenderState(a,e),this.submitCasters(o.visibleCasters,e),this.restoreRenderState(a)}render(e,t,s=!0){if(this.needsShadowRendering(e)){const r=e.numShadowFaces;for(let i=0;i<r;i++)this.prepareFace(e,t,i),this.renderFace(e,t,i,!0,s);this.renderVms(e,t)}}renderVms(e,t){if(e._isVsm&&e._vsmBlurSize>1){this.renderer.scene.clusteredLightingEnabled&&e._type!==m||this.applyVsmBlur(e,t)}}getVsmBlurShader(e,t,s){let r=(e?this.blurPackedVsmShader:this.blurVsmShader)[t][s];if(!r){this.blurVsmWeights[s]=function(e){const t=(e-1)/6,s=.5*(e-1),r=new Array(e);let i=0;for(let a=0;a<e;++a)r[a]=U(a-s,t),i+=r[a];for(let t=0;t<e;++t)r[t]/=i;return r}(s);const i=y.fullscreenQuadVS;let a="#define SAMPLES "+s+"\n";a+=e?this.blurPackedVsmShaderCode[t]:this.blurVsmShaderCode[t];const o="blurVsm"+t+s+e;r=v(this.device,i,a,o),e?this.blurPackedVsmShader[t][s]=r:this.blurVsmShader[t][s]=r}return r}applyVsmBlur(e,t){const s=this.device;s.setBlendState(D.DEFAULT);const r=e.getRenderData(e._type===m?t:null,0).shadowCamera.renderTarget,i=this.renderer.shadowMapCache.get(s,e),a=i.renderTargets[0],o=e._shadowType===d,n=e.vsmBlurMode,l=e._vsmBlurSize,p=this.getVsmBlurShader(o,n,l);x.z=e._shadowResolution-2,x.w=x.z,this.sourceId.setValue(r.colorBuffer),R[0]=1/e._shadowResolution,R[1]=0,this.pixelOffsetId.setValue(R),n===S&&this.weightId.setValue(this.blurVsmWeights[l]),h(s,a,p,null,x),this.sourceId.setValue(a.colorBuffer),R[1]=R[0],R[0]=0,this.pixelOffsetId.setValue(R),h(s,r,p,null,x),this.renderer.shadowMapCache.add(e,i)}initViewBindGroupFormat(){this.device.supportsUniformBuffers&&!this.viewUniformFormat&&(this.viewUniformFormat=new C(this.device,[new _("matrix_viewProjection",i)]),this.viewBindGroupFormat=new O(this.device,[new M(a,o|n)],[]))}frameUpdate(){this.initViewBindGroupFormat()}}export{L as ShadowRenderer};
