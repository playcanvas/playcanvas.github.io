import { Debug } from '../core/debug.js';
import { SHADER_DEPTH, SHADER_PICK, SHADER_FORWARD, SHADER_FORWARDHDR, SHADER_SHADOW } from './constants.js';
import { DeviceCache } from '../platform/graphics/device-cache.js';

// device cache storing shader pass data per device
const shaderPassDeviceCache = new DeviceCache();

/**
 * Info about a shader pass. Shader pass is represented by a unique index and a name, and the
 * index is used to access the shader required for the pass, from an array stored in the
 * material or mesh instance.
 *
 * @ignore
 */
class ShaderPassInfo {
  constructor(name, index, options = {}) {
    /** @type {number} */
    this.index = void 0;
    /** @type {string} */
    this.name = void 0;
    /** @type {string} */
    this.shaderDefine = void 0;
    Debug.assert(/^[a-zA-Z][_a-zA-Z0-9]*$/.test(name), `ShaderPass name can only contain letters, numbers and underscores and start with a letter: ${name}`);
    this.name = name;
    this.index = index;

    // assign options as properties to this object
    Object.assign(this, options);
    this.initShaderDefines();
  }
  initShaderDefines() {
    let keyword;
    if (this.isShadow) {
      keyword = 'SHADOW';
    } else if (this.isForward) {
      keyword = 'FORWARD';
    } else if (this.index === SHADER_DEPTH) {
      keyword = 'DEPTH';
    } else if (this.index === SHADER_PICK) {
      keyword = 'PICK';
    }

    // define based on on the options based name
    const define1 = keyword ? `#define ${keyword}_PASS\n` : '';

    // define based on the name
    const define2 = `#define ${this.name.toUpperCase()}_PASS\n`;
    this.shaderDefines = define1 + define2;
  }
}

/**
 * Class responsible for management of shader passes, associated with a device.
 *
 * @ignore
 */
class ShaderPass {
  constructor() {
    /**
     * Allocated shader passes, map of a shader pass name to info.
     *
     * @type {Map<string, ShaderPassInfo>}
     */
    this.passesNamed = new Map();
    /**
     * Allocated shader passes, indexed by their index.
     *
     * @type {Array<ShaderPassInfo>}
     */
    this.passesIndexed = [];
    /** Next available index */
    this.nextIndex = 0;
    const add = (name, index, options) => {
      const info = this.allocate(name, options);
      Debug.assert(info.index === index);
    };

    // add default passes in the required order, to match the constants
    add('forward', SHADER_FORWARD, {
      isForward: true
    });
    add('forward_hdr', SHADER_FORWARDHDR, {
      isForward: true
    });
    add('depth', SHADER_DEPTH);
    add('pick', SHADER_PICK);
    add('shadow', SHADER_SHADOW);
  }

  /**
   * Get access to the shader pass instance for the specified device.
   *
   * @param {import('../platform/graphics/graphics-device.js').GraphicsDevice} device - The
   * graphics device.
   * @returns { ShaderPass } The shader pass instance for the specified device.
   */
  static get(device) {
    Debug.assert(device);
    return shaderPassDeviceCache.get(device, () => {
      return new ShaderPass();
    });
  }

  /**
   * Allocates a shader pass with the specified name and options.
   *
   * @param {string} name - A name of the shader pass.
   * @param {object} options - Options for the shader pass, which are added as properties to the
   * shader pass info.
   * @returns {ShaderPassInfo} The allocated shader pass info.
   */
  allocate(name, options) {
    let info = this.passesNamed.get(name);
    if (info === undefined) {
      info = new ShaderPassInfo(name, this.nextIndex, options);
      this.passesNamed.set(info.name, info);
      this.passesIndexed[info.index] = info;
      this.nextIndex++;
    }
    return info;
  }

  /**
   * Return the shader pass info for the specified index.
   *
   * @param {number} index - The shader pass index.
   * @returns {ShaderPassInfo} - The shader pass info.
   */
  getByIndex(index) {
    const info = this.passesIndexed[index];
    Debug.assert(info);
    return info;
  }
  getByName(name) {
    return this.passesNamed.get(name);
  }
}

export { ShaderPass, ShaderPassInfo };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2hhZGVyLXBhc3MuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9zY2VuZS9zaGFkZXItcGFzcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEZWJ1ZyB9IGZyb20gJy4uL2NvcmUvZGVidWcuanMnO1xuaW1wb3J0IHtcbiAgICBTSEFERVJfRk9SV0FSRCwgU0hBREVSX0ZPUldBUkRIRFIsIFNIQURFUl9ERVBUSCwgU0hBREVSX1BJQ0ssIFNIQURFUl9TSEFET1dcbn0gZnJvbSAnLi9jb25zdGFudHMuanMnO1xuXG5pbXBvcnQgeyBEZXZpY2VDYWNoZSB9IGZyb20gJy4uL3BsYXRmb3JtL2dyYXBoaWNzL2RldmljZS1jYWNoZS5qcyc7XG5cbi8vIGRldmljZSBjYWNoZSBzdG9yaW5nIHNoYWRlciBwYXNzIGRhdGEgcGVyIGRldmljZVxuY29uc3Qgc2hhZGVyUGFzc0RldmljZUNhY2hlID0gbmV3IERldmljZUNhY2hlKCk7XG5cbi8qKlxuICogSW5mbyBhYm91dCBhIHNoYWRlciBwYXNzLiBTaGFkZXIgcGFzcyBpcyByZXByZXNlbnRlZCBieSBhIHVuaXF1ZSBpbmRleCBhbmQgYSBuYW1lLCBhbmQgdGhlXG4gKiBpbmRleCBpcyB1c2VkIHRvIGFjY2VzcyB0aGUgc2hhZGVyIHJlcXVpcmVkIGZvciB0aGUgcGFzcywgZnJvbSBhbiBhcnJheSBzdG9yZWQgaW4gdGhlXG4gKiBtYXRlcmlhbCBvciBtZXNoIGluc3RhbmNlLlxuICpcbiAqIEBpZ25vcmVcbiAqL1xuY2xhc3MgU2hhZGVyUGFzc0luZm8ge1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIGluZGV4O1xuXG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgbmFtZTtcblxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIHNoYWRlckRlZmluZTtcblxuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGluZGV4LCBvcHRpb25zID0ge30pIHtcblxuICAgICAgICBEZWJ1Zy5hc3NlcnQoL15bYS16QS1aXVtfYS16QS1aMC05XSokLy50ZXN0KG5hbWUpLCBgU2hhZGVyUGFzcyBuYW1lIGNhbiBvbmx5IGNvbnRhaW4gbGV0dGVycywgbnVtYmVycyBhbmQgdW5kZXJzY29yZXMgYW5kIHN0YXJ0IHdpdGggYSBsZXR0ZXI6ICR7bmFtZX1gKTtcblxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG5cbiAgICAgICAgLy8gYXNzaWduIG9wdGlvbnMgYXMgcHJvcGVydGllcyB0byB0aGlzIG9iamVjdFxuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXMuaW5pdFNoYWRlckRlZmluZXMoKTtcbiAgICB9XG5cbiAgICBpbml0U2hhZGVyRGVmaW5lcygpIHtcblxuICAgICAgICBsZXQga2V5d29yZDtcbiAgICAgICAgaWYgKHRoaXMuaXNTaGFkb3cpIHtcbiAgICAgICAgICAgIGtleXdvcmQgPSAnU0hBRE9XJztcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzRm9yd2FyZCkge1xuICAgICAgICAgICAga2V5d29yZCA9ICdGT1JXQVJEJztcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmluZGV4ID09PSBTSEFERVJfREVQVEgpIHtcbiAgICAgICAgICAgIGtleXdvcmQgPSAnREVQVEgnO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaW5kZXggPT09IFNIQURFUl9QSUNLKSB7XG4gICAgICAgICAgICBrZXl3b3JkID0gJ1BJQ0snO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGVmaW5lIGJhc2VkIG9uIG9uIHRoZSBvcHRpb25zIGJhc2VkIG5hbWVcbiAgICAgICAgY29uc3QgZGVmaW5lMSA9IGtleXdvcmQgPyBgI2RlZmluZSAke2tleXdvcmR9X1BBU1NcXG5gIDogJyc7XG5cbiAgICAgICAgLy8gZGVmaW5lIGJhc2VkIG9uIHRoZSBuYW1lXG4gICAgICAgIGNvbnN0IGRlZmluZTIgPSBgI2RlZmluZSAke3RoaXMubmFtZS50b1VwcGVyQ2FzZSgpfV9QQVNTXFxuYDtcblxuICAgICAgICB0aGlzLnNoYWRlckRlZmluZXMgPSBkZWZpbmUxICsgZGVmaW5lMjtcbiAgICB9XG59XG5cbi8qKlxuICogQ2xhc3MgcmVzcG9uc2libGUgZm9yIG1hbmFnZW1lbnQgb2Ygc2hhZGVyIHBhc3NlcywgYXNzb2NpYXRlZCB3aXRoIGEgZGV2aWNlLlxuICpcbiAqIEBpZ25vcmVcbiAqL1xuY2xhc3MgU2hhZGVyUGFzcyB7XG4gICAgLyoqXG4gICAgICogQWxsb2NhdGVkIHNoYWRlciBwYXNzZXMsIG1hcCBvZiBhIHNoYWRlciBwYXNzIG5hbWUgdG8gaW5mby5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtNYXA8c3RyaW5nLCBTaGFkZXJQYXNzSW5mbz59XG4gICAgICovXG4gICAgcGFzc2VzTmFtZWQgPSBuZXcgTWFwKCk7XG5cbiAgICAvKipcbiAgICAgKiBBbGxvY2F0ZWQgc2hhZGVyIHBhc3NlcywgaW5kZXhlZCBieSB0aGVpciBpbmRleC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtBcnJheTxTaGFkZXJQYXNzSW5mbz59XG4gICAgICovXG4gICAgcGFzc2VzSW5kZXhlZCA9IFtdO1xuXG4gICAgLyoqIE5leHQgYXZhaWxhYmxlIGluZGV4ICovXG4gICAgbmV4dEluZGV4ID0gMDtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuXG4gICAgICAgIGNvbnN0IGFkZCA9IChuYW1lLCBpbmRleCwgb3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5mbyA9IHRoaXMuYWxsb2NhdGUobmFtZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBEZWJ1Zy5hc3NlcnQoaW5mby5pbmRleCA9PT0gaW5kZXgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGFkZCBkZWZhdWx0IHBhc3NlcyBpbiB0aGUgcmVxdWlyZWQgb3JkZXIsIHRvIG1hdGNoIHRoZSBjb25zdGFudHNcbiAgICAgICAgYWRkKCdmb3J3YXJkJywgU0hBREVSX0ZPUldBUkQsIHsgaXNGb3J3YXJkOiB0cnVlIH0pO1xuICAgICAgICBhZGQoJ2ZvcndhcmRfaGRyJywgU0hBREVSX0ZPUldBUkRIRFIsIHsgaXNGb3J3YXJkOiB0cnVlIH0pO1xuICAgICAgICBhZGQoJ2RlcHRoJywgU0hBREVSX0RFUFRIKTtcbiAgICAgICAgYWRkKCdwaWNrJywgU0hBREVSX1BJQ0spO1xuICAgICAgICBhZGQoJ3NoYWRvdycsIFNIQURFUl9TSEFET1cpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhY2Nlc3MgdG8gdGhlIHNoYWRlciBwYXNzIGluc3RhbmNlIGZvciB0aGUgc3BlY2lmaWVkIGRldmljZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KCcuLi9wbGF0Zm9ybS9ncmFwaGljcy9ncmFwaGljcy1kZXZpY2UuanMnKS5HcmFwaGljc0RldmljZX0gZGV2aWNlIC0gVGhlXG4gICAgICogZ3JhcGhpY3MgZGV2aWNlLlxuICAgICAqIEByZXR1cm5zIHsgU2hhZGVyUGFzcyB9IFRoZSBzaGFkZXIgcGFzcyBpbnN0YW5jZSBmb3IgdGhlIHNwZWNpZmllZCBkZXZpY2UuXG4gICAgICovXG4gICAgc3RhdGljIGdldChkZXZpY2UpIHtcbiAgICAgICAgRGVidWcuYXNzZXJ0KGRldmljZSk7XG5cbiAgICAgICAgcmV0dXJuIHNoYWRlclBhc3NEZXZpY2VDYWNoZS5nZXQoZGV2aWNlLCAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNoYWRlclBhc3MoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWxsb2NhdGVzIGEgc2hhZGVyIHBhc3Mgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWUgYW5kIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIEEgbmFtZSBvZiB0aGUgc2hhZGVyIHBhc3MuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgc2hhZGVyIHBhc3MsIHdoaWNoIGFyZSBhZGRlZCBhcyBwcm9wZXJ0aWVzIHRvIHRoZVxuICAgICAqIHNoYWRlciBwYXNzIGluZm8uXG4gICAgICogQHJldHVybnMge1NoYWRlclBhc3NJbmZvfSBUaGUgYWxsb2NhdGVkIHNoYWRlciBwYXNzIGluZm8uXG4gICAgICovXG4gICAgYWxsb2NhdGUobmFtZSwgb3B0aW9ucykge1xuICAgICAgICBsZXQgaW5mbyA9IHRoaXMucGFzc2VzTmFtZWQuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAoaW5mbyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmZvID0gbmV3IFNoYWRlclBhc3NJbmZvKG5hbWUsIHRoaXMubmV4dEluZGV4LCBvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMucGFzc2VzTmFtZWQuc2V0KGluZm8ubmFtZSwgaW5mbyk7XG4gICAgICAgICAgICB0aGlzLnBhc3Nlc0luZGV4ZWRbaW5mby5pbmRleF0gPSBpbmZvO1xuICAgICAgICAgICAgdGhpcy5uZXh0SW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHNoYWRlciBwYXNzIGluZm8gZm9yIHRoZSBzcGVjaWZpZWQgaW5kZXguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBUaGUgc2hhZGVyIHBhc3MgaW5kZXguXG4gICAgICogQHJldHVybnMge1NoYWRlclBhc3NJbmZvfSAtIFRoZSBzaGFkZXIgcGFzcyBpbmZvLlxuICAgICAqL1xuICAgIGdldEJ5SW5kZXgoaW5kZXgpIHtcbiAgICAgICAgY29uc3QgaW5mbyA9IHRoaXMucGFzc2VzSW5kZXhlZFtpbmRleF07XG4gICAgICAgIERlYnVnLmFzc2VydChpbmZvKTtcbiAgICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuXG4gICAgZ2V0QnlOYW1lKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFzc2VzTmFtZWQuZ2V0KG5hbWUpO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgU2hhZGVyUGFzcywgU2hhZGVyUGFzc0luZm8gfTtcbiJdLCJuYW1lcyI6WyJzaGFkZXJQYXNzRGV2aWNlQ2FjaGUiLCJEZXZpY2VDYWNoZSIsIlNoYWRlclBhc3NJbmZvIiwiY29uc3RydWN0b3IiLCJuYW1lIiwiaW5kZXgiLCJvcHRpb25zIiwic2hhZGVyRGVmaW5lIiwiRGVidWciLCJhc3NlcnQiLCJ0ZXN0IiwiT2JqZWN0IiwiYXNzaWduIiwiaW5pdFNoYWRlckRlZmluZXMiLCJrZXl3b3JkIiwiaXNTaGFkb3ciLCJpc0ZvcndhcmQiLCJTSEFERVJfREVQVEgiLCJTSEFERVJfUElDSyIsImRlZmluZTEiLCJkZWZpbmUyIiwidG9VcHBlckNhc2UiLCJzaGFkZXJEZWZpbmVzIiwiU2hhZGVyUGFzcyIsInBhc3Nlc05hbWVkIiwiTWFwIiwicGFzc2VzSW5kZXhlZCIsIm5leHRJbmRleCIsImFkZCIsImluZm8iLCJhbGxvY2F0ZSIsIlNIQURFUl9GT1JXQVJEIiwiU0hBREVSX0ZPUldBUkRIRFIiLCJTSEFERVJfU0hBRE9XIiwiZ2V0IiwiZGV2aWNlIiwidW5kZWZpbmVkIiwic2V0IiwiZ2V0QnlJbmRleCIsImdldEJ5TmFtZSJdLCJtYXBwaW5ncyI6Ijs7OztBQU9BO0FBQ0EsTUFBTUEscUJBQXFCLEdBQUcsSUFBSUMsV0FBVyxFQUFFLENBQUE7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTUMsY0FBYyxDQUFDO0VBVWpCQyxXQUFXQSxDQUFDQyxJQUFJLEVBQUVDLEtBQUssRUFBRUMsT0FBTyxHQUFHLEVBQUUsRUFBRTtBQVR2QztBQUFBLElBQUEsSUFBQSxDQUNBRCxLQUFLLEdBQUEsS0FBQSxDQUFBLENBQUE7QUFFTDtBQUFBLElBQUEsSUFBQSxDQUNBRCxJQUFJLEdBQUEsS0FBQSxDQUFBLENBQUE7QUFFSjtBQUFBLElBQUEsSUFBQSxDQUNBRyxZQUFZLEdBQUEsS0FBQSxDQUFBLENBQUE7QUFJ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
