import"../../core/debug.js";import{uniformTypeToName as t,SHADERSTAGE_VERTEX as e,SHADERSTAGE_FRAGMENT as s,BINDGROUP_MESH as r,semanticToLocation as n,TYPE_FLOAT32 as a,TEXTUREDIMENSION_2D as o,TEXTUREDIMENSION_3D as i,TEXTUREDIMENSION_CUBE as c,TEXTUREDIMENSION_2D_ARRAY as u,UNIFORM_BUFFER_DEFAULT_SLOT_NAME as p,SAMPLETYPE_FLOAT as m,SAMPLETYPE_UNFILTERABLE_FLOAT as h,SAMPLETYPE_DEPTH as l,TYPE_INT8 as f,TYPE_INT16 as d,TYPE_INT32 as b}from"./constants.js";import{UniformFormat as g,UniformBufferFormat as y}from"./uniform-buffer-format.js";import{BindTextureFormat as w,BindGroupFormat as x,BindBufferFormat as S}from"./bind-group-format.js";const $=/[ \t]*(\battribute\b|\bvarying\b|\buniform\b)/g,v=/(\battribute\b|\bvarying\b|\bout\b|\buniform\b)[ \t]*([^;]+)([;]+)/g,D="@@@",E=/([\w-]+)\[(.*?)\]/,O=new Set(["highp","mediump","lowp"]),T=new Set(["sampler2DShadow","samplerCubeShadow"]),F={sampler2D:o,sampler3D:i,samplerCube:c,samplerCubeShadow:c,sampler2DShadow:o,sampler2DArray:u,sampler2DArrayShadow:u};class B{constructor(t,e){this.line=t;const s=t.trim().split(/\s+/);if(O.has(s[0])&&(this.precision=s.shift()),this.type=s.shift(),t.includes(","),t.includes("[")){const t=s.join(" "),r=E.exec(t);this.name=r[1],this.arraySize=Number(r[2]),isNaN(this.arraySize)&&(e.failed=!0)}else this.name=s.shift(),this.arraySize=0;this.isSampler=-1!==this.type.indexOf("sampler")}}class U{static run(t,e,s){const r=new Map,n=U.extract(e.vshader),a=U.extract(e.fshader),o=U.processAttributes(n.attributes,e.attributes,e.processingOptions),i=U.processVaryings(n.varyings,r,!0),c=U.processVaryings(a.varyings,r,!1),u=U.processOuts(a.outs),p=n.uniforms.concat(a.uniforms),m=Array.from(new Set(p)).map((t=>new B(t,s))),h=U.processUniforms(t,m,e.processingOptions,s),l=o+"\n"+i+"\n"+h.code,f=n.src.replace(D,l),d=c+"\n"+u+"\n"+h.code;return{vshader:f,fshader:a.src.replace(D,d),meshUniformBufferFormat:h.meshUniformBufferFormat,meshBindGroupFormat:h.meshBindGroupFormat}}static extract(t){const e=[],s=[],r=[],n=[];let a,o=`${D}\n`;for(;null!==(a=$.exec(t));){const i=a[1];switch(i){case"attribute":case"varying":case"uniform":case"out":{v.lastIndex=a.index;const c=v.exec(t);"attribute"===i?e.push(c[2]):"varying"===i?s.push(c[2]):"out"===i?r.push(c[2]):"uniform"===i&&n.push(c[2]),t=U.cutOut(t,a.index,v.lastIndex,o),$.lastIndex=a.index+o.length,o="";break}}}return{src:t,attributes:e,varyings:s,outs:r,uniforms:n}}static processUniforms(n,a,o,i){const c=[],u=[];a.forEach((t=>{t.isSampler?c.push(t):u.push(t)}));const f=[];u.forEach((e=>{if(!o.hasUniform(e.name)){const s=t.indexOf(e.type),r=new g(e.name,s,e.arraySize);f.push(r)}}));const d=f.length?new y(n,f):null,b=[];d&&b.push(new S(p,e|s));const $=[];c.forEach((t=>{if(!o.hasTexture(t.name)){let r=m;"highp"===t.precision&&(r=h),T.has(t.type)&&(r=l);const n=F[t.type];$.push(new w(t.name,e|s,n,r))}}));const v=new x(n,b,$);let D="";return o.uniformFormats.forEach(((t,e)=>{t&&(D+=t.getShaderDeclaration(e,0))})),d&&(D+=d.getShaderDeclaration(r,0)),o.bindGroupFormats.forEach(((t,e)=>{t&&(D+=t.getShaderDeclarationTextures(e))})),D+=v.getShaderDeclarationTextures(r),{code:D,meshUniformBufferFormat:d,meshBindGroupFormat:v}}static processVaryings(t,e,s){let r="";const n=s?"out":"in";return t.forEach(((t,a)=>{const o=U.splitToWords(t),i=o[0],c=o[1];s?e.set(c,a):a=e.get(c),r+=`layout(location = ${a}) ${n} ${i} ${c};\n`})),r}static processOuts(t){let e="";return t.forEach(((t,s)=>{e+=`layout(location = ${s}) out ${t};\n`})),e}static getTypeCount(t){const e=t.substring(t.length-1),s=parseInt(e,10);return isNaN(s)?1:s}static processAttributes(t,e,s){let r="";return t.forEach((t=>{const o=U.splitToWords(t);let i=o[0],c=o[1];if(e.hasOwnProperty(c)){const t=e[c],o=n[t];let u;const p=s.getVertexElement(t);if(p){const t=p.dataType;if(t!==a&&!p.normalize){const e=U.getTypeCount(i),s=`_private_${c}`;u=`vec${e} ${c} = vec${e}(${s});\n`,c=s;const r=t===f||t===d||t===b;i=1===e?r?"int":"uint":r?`ivec${e}`:`uvec${e}`}}r+=`layout(location = ${o}) in ${i} ${c};\n`,u&&(r+=u)}})),r}static splitToWords(t){return(t=t.replace(/\s+/g," ").trim()).split(" ")}static cutOut(t,e,s,r){return t.substring(0,e)+r+t.substring(s)}}export{U as ShaderProcessor};
