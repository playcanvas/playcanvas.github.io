import"../../core/tracing.js";import{now as e}from"../../core/time.js";import{Color as t}from"../../core/math/color.js";import{math as s}from"../../core/math/math.js";import{Vec3 as a}from"../../core/math/vec3.js";import{BoundingBox as r}from"../../core/shape/bounding-box.js";import{PIXELFORMAT_RGBA8 as i,TEXTURETYPE_RGBM as n,CHUNKAPI_1_62 as h,CULLFACE_NONE as o,TEXTURETYPE_DEFAULT as l,FILTER_NEAREST as c,ADDRESS_CLAMP_TO_EDGE as m,FILTER_LINEAR as d}from"../../platform/graphics/constants.js";import{RenderTarget as p}from"../../platform/graphics/render-target.js";import{drawQuadWithShader as g}from"../../scene/graphics/quad-render-utils.js";import{Texture as u}from"../../platform/graphics/texture.js";import{MeshInstance as f}from"../../scene/mesh-instance.js";import{LightingParams as b}from"../../scene/lighting/lighting-params.js";import{WorldClusters as w}from"../../scene/lighting/world-clusters.js";import{shaderChunks as k}from"../../scene/shader-lib/chunks/chunks.js";import{shaderChunksLightmapper as T}from"../../scene/shader-lib/chunks/chunks-lightmapper.js";import{PROJECTION_ORTHOGRAPHIC as S,MASK_AFFECT_LIGHTMAPPED as M,BAKE_COLORDIR as L,MASK_BAKE as x,LIGHTTYPE_DIRECTIONAL as _,SHADOWUPDATE_REALTIME as C,SHADOWUPDATE_THISFRAME as P,FOG_NONE as B,LIGHTTYPE_SPOT as y,PROJECTION_PERSPECTIVE as j,LIGHTTYPE_OMNI as A,SHADER_FORWARDHDR as F,SHADERDEF_LM as E,SHADERDEF_DIRLM as R,SHADERDEF_LMAMBIENT as v}from"../../scene/constants.js";import{Camera as D}from"../../scene/camera.js";import{GraphNode as z}from"../../scene/graph-node.js";import{StandardMaterial as I}from"../../scene/materials/standard-material.js";import{BakeLightSimple as O}from"./bake-light-simple.js";import{BakeLightAmbient as N}from"./bake-light-ambient.js";import{BakeMeshNode as U}from"./bake-mesh-node.js";import{LightmapCache as V}from"../../scene/graphics/lightmap-cache.js";import{LightmapFilters as $}from"./lightmap-filters.js";import{BlendState as q}from"../../platform/graphics/blend-state.js";import{DepthState as H}from"../../platform/graphics/depth-state.js";const G=new a;class W{constructor(e,s,a,r,i){this.device=e,this.root=s,this.scene=a,this.renderer=r,this.assets=i,this.shadowMapCache=r.shadowMapCache,this._tempSet=new Set,this._initCalled=!1,this.passMaterials=[],this.ambientAOMaterial=null,this.fog="",this.ambientLight=new t,this.renderTargets=new Map,this.stats={renderPasses:0,lightmapCount:0,totalRenderTime:0,forwardTime:0,fboTime:0,shadowMapTime:0,compileTime:0,shadersLinked:0}}destroy(){V.decRef(this.blackTex),this.blackTex=null,V.destroy(),this.device=null,this.root=null,this.scene=null,this.renderer=null,this.assets=null}initBake(e){if(!this._initCalled){this._initCalled=!0,this.lightmapFilters=new $(e),this.constantBakeDir=e.scope.resolve("bakeDir"),this.materials=[],this.blackTex=new u(this.device,{width:4,height:4,format:i,type:n,name:"lightmapBlack"}),V.incRef(this.blackTex);const t=new D;t.clearColor.set(0,0,0,0),t.clearColorBuffer=!0,t.clearDepthBuffer=!1,t.clearStencilBuffer=!1,t.frustumCulling=!1,t.projection=S,t.aspectRatio=1,t.node=new z,this.camera=t}if(this.scene.clusteredLightingEnabled){const t=new b(e.supportsAreaLights,e.maxTextureSize,(()=>{}));this.lightingParams=t;const s=this.scene.lighting;t.shadowsEnabled=s.shadowsEnabled,t.shadowAtlasResolution=s.shadowAtlasResolution,t.cookiesEnabled=s.cookiesEnabled,t.cookieAtlasResolution=s.cookieAtlasResolution,t.areaLightsEnabled=s.areaLightsEnabled,t.cells=new a(3,3,3),t.maxLightsPerCell=4,this.worldClusters=new w(e),this.worldClusters.name="ClusterLightmapper"}}finishBake(e){function t(e){V.decRef(e.colorBuffer),e.destroy()}this.materials=[],this.renderTargets.forEach((e=>{t(e)})),this.renderTargets.clear(),e.forEach((e=>{e.renderTargets.forEach((e=>{t(e)})),e.renderTargets.length=0})),this.ambientAOMaterial=null,this.worldClusters&&(this.worldClusters.destroy(),this.worldClusters=null)}createMaterialForPass(e,s,a,r){const n=new I;if(n.name=`lmMaterial-pass:${a}-ambient:${r}`,n.chunks.APIVersion=h,n.chunks.transformVS="#define UV1LAYOUT\n"+k.transformVS,0===a){let e=T.bakeLmEndPS;r?e=`\n\t\t\t\t\t\t\t\t\t\tdDiffuseLight = ((dDiffuseLight - 0.5) * max(${s.ambientBakeOcclusionContrast.toFixed(1)} + 1.0, 0.0)) + 0.5;\n\t\t\t\t\t\t\t\t\t\tdDiffuseLight += vec3(${s.ambientBakeOcclusionBrightness.toFixed(1)});\n\t\t\t\t\t\t\t\t\t\tdDiffuseLight = saturate(dDiffuseLight);\n\t\t\t\t\t\t\t\t\t\tdDiffuseLight *= dAmbientLight;\n\t\t\t\t\t\t\t\t`+e:(n.ambient=new t(0,0,0),n.ambientTint=!0),n.chunks.basePS=k.basePS+(s.lightmapPixelFormat===i?"\n#define LIGHTMAP_RGBM\n":""),n.chunks.endPS=e,n.lightMap=this.blackTex}else n.chunks.basePS=k.basePS+"\nuniform sampler2D texture_dirLightMap;\nuniform float bakeDir;\n",n.chunks.endPS=T.bakeDirLmEndPS;return n.chunks.outputAlphaPS="\n",n.chunks.outputAlphaOpaquePS="\n",n.chunks.outputAlphaPremulPS="\n",n.cull=o,n.forceUv1=!0,n.update(),n}createMaterials(e,t,s){for(let a=0;a<s;a++)this.passMaterials[a]||(this.passMaterials[a]=this.createMaterialForPass(e,t,a,!1));this.ambientAOMaterial||(this.ambientAOMaterial=this.createMaterialForPass(e,t,0,!0),this.ambientAOMaterial.onUpdateShader=function(e){return e.litOptions.lightMapWithoutAmbient=!0,e.litOptions.separateAmbient=!0,e})}createTexture(e,t){return new u(this.device,{width:e,height:e,format:this.scene.lightmapPixelFormat,mipmaps:!1,type:this.scene.lightmapPixelFormat===i?n:l,minFilter:c,magFilter:c,addressU:m,addressV:m,name:t})}collectModels(e,t,s){var a,r,i;if(!e.enabled)return;let n;if(null!=(a=e.model)&&a.model&&null!=(r=e.model)&&r.enabled&&(s&&s.push(new U(e)),e.model.lightmapped&&t&&(n=e.model.model.meshInstances)),null!=(i=e.render)&&i.enabled&&(s&&s.push(new U(e)),e.render.lightmapped&&t&&(n=e.render.meshInstances)),n){let s=!0;for(let e=0;e<n.length;e++)if(!n[e].mesh.vertexBuffer.format.hasUv1){s=!1;break}if(s){const s=[];for(let a=0;a<n.length;a++){const r=n[a].mesh;this._tempSet.has(r)?t.push(new U(e,[n[a]])):s.push(n[a]),this._tempSet.add(r)}this._tempSet.clear(),s.length>0&&t.push(new U(e,s))}}for(let a=0;a<e._children.length;a++)this.collectModels(e._children[a],t,s)}prepareShadowCasters(e){const t=[];for(let s=0;s<e.length;s++){const a=e[s].component;if(a.castShadows=a.castShadowsLightmap,a.castShadowsLightmap){const a=e[s].meshInstances;for(let e=0;e<a.length;e++)a[e].visibleThisFrame=!0,t.push(a[e])}}return t}updateTransforms(e){for(let t=0;t<e.length;t++){const s=e[t].meshInstances;for(let e=0;e<s.length;e++)s[e].node.getWorldTransform()}}calculateLightmapSize(e){let t;const a=this.scene.lightmapSizeMultiplier||16,r=G;let i,n;e.model?(n=e.model.lightmapSizeMultiplier,e.model.asset?(t=this.assets.get(e.model.asset).data,t.area&&(i=t.area)):e.model._area&&(t=e.model,t._area&&(i=t._area))):e.render&&(n=e.render.lightmapSizeMultiplier,"asset"!==e.render.type&&e.render._area&&(t=e.render,t._area&&(i=t._area)));const h={x:1,y:1,z:1,uv:1};i&&(h.x=i.x,h.y=i.y,h.z=i.z,h.uv=i.uv);const o=n||1;h.x*=o,h.y*=o,h.z*=o;const l=e.render||e.model,c=this.computeNodeBounds(l.meshInstances);r.copy(c.halfExtents);let m=h.x*r.y*r.z+h.y*r.x*r.z+h.z*r.x*r.y;m/=h.uv,m=Math.sqrt(m);return Math.min(s.nextPowerOfTwo(m*a),this.scene.lightmapMaxResolution||2048)}setLightmapping(e,t,s,a){for(let r=0;r<e.length;r++){const i=e[r],n=i.meshInstances;for(let e=0;e<n.length;e++){const r=n[e];if(r.setLightmapped(t),t){a&&(r._shaderDefs|=a),r.mask=M;for(let e=0;e<s;e++){const t=i.renderTargets[e].colorBuffer;t.minFilter=d,t.magFilter=d,r.setRealtimeLightmap(f.lightmapParamNames[e],t)}}}}}bake(t,s=L){const a=this.device,r=e();this.scene._updateSky(a),this.stats.renderPasses=0,this.stats.shadowMapTime=0,this.stats.forwardTime=0;const i=a._shaderStats.linked,n=a._renderTargetCreationTime,h=a._shaderStats.compileTime,o=[],l=[];if(t){for(let e=0;e<t.length;e++)this.collectModels(t[e],o,null);this.collectModels(this.root,null,l)}else this.collectModels(this.root,o,l);if(o.length>0){const e=s===L?2:1;this.setLightmapping(o,!1,e),this.initBake(a),this.bakeInternal(e,o,l);let t=E;s===L&&(t|=R),this.scene.ambientBake&&(t|=v),this.setLightmapping(o,!0,e,t),this.finishBake(o)}const c=e();this.stats.totalRenderTime=c-r,this.stats.shadersLinked=a._shaderStats.linked-i,this.stats.compileTime=a._shaderStats.compileTime-h,this.stats.fboTime=a._renderTargetCreationTime-n,this.stats.lightmapCount=o.length}allocateTextures(e,t){for(let s=0;s<e.length;s++){const a=e[s],r=this.calculateLightmapSize(a.node);for(let e=0;e<t;e++){const t=this.createTexture(r,"lightmapper_lightmap_"+s);V.incRef(t),a.renderTargets[e]=new p({colorBuffer:t,depth:!1})}if(!this.renderTargets.has(r)){const e=this.createTexture(r,"lightmapper_temp_lightmap_"+r);V.incRef(e),this.renderTargets.set(r,new p({colorBuffer:e,depth:!1}))}}}prepareLightsToBake(e,t,s){if(this.scene.ambientBake){const e=new N(this.scene);s.push(e)}const a=e._lights;for(let e=0;e<a.length;e++){const r=a[e],i=new O(this.scene,r);t.push(i),r.enabled&&0!=(r.mask&x)&&(r.isStatic=!1,r.mask=4294967295,r.shadowUpdateMode=r.type===_?C:P,s.push(i))}s.sort()}restoreLights(e){for(let t=0;t<e.length;t++)e[t].restore()}setupScene(){this.revertStatic=!1,this.scene._needsStaticPrepare&&(this.scene._needsStaticPrepare=!1,this.revertStatic=!0),this.fog=this.scene.fog,this.ambientLight.copy(this.scene.ambientLight),this.scene.fog=B,this.scene.ambientBake||this.scene.ambientLight.set(0,0,0),this.renderer.setSceneConstants()}restoreScene(){this.scene.fog=this.fog,this.scene.ambientLight.copy(this.ambientLight),this.revertStatic&&(this.scene._needsStaticPrepare=!0)}computeNodeBounds(e){const t=new r;if(e.length>0){t.copy(e[0].aabb);for(let s=1;s<e.length;s++)t.add(e[s].aabb)}return t}computeNodesBounds(e){for(let t=0;t<e.length;t++){const s=e[t].meshInstances;e[t].bounds=this.computeNodeBounds(s)}}computeBounds(e){const t=new r;for(let s=0;s<e.length;s++){t.copy(e[0].aabb);for(let s=1;s<e.length;s++)t.add(e[s].aabb)}return t}backupMaterials(e){for(let t=0;t<e.length;t++)this.materials[t]=e[t].material}restoreMaterials(e){for(let t=0;t<e.length;t++)e[t].material=this.materials[t]}lightCameraPrepare(e,t){const s=t.light;let a;if(s.type===y){a=s.getRenderData(null,0).shadowCamera,a._node.setPosition(s._node.getPosition()),a._node.setRotation(s._node.getRotation()),a._node.rotateLocal(-90,0,0),a.projection=j,a.nearClip=s.attenuationEnd/1e3,a.farClip=s.attenuationEnd,a.aspectRatio=1,a.fov=2*s._outerConeAngle,this.renderer.updateCameraFrustum(a)}return a}lightCameraPrepareAndCull(e,t,s,a){const r=e.light;let i=!0;if(r.type===_){G.copy(a.center),G.y+=a.halfExtents.y,this.camera.node.setPosition(G),this.camera.node.setEulerAngles(-90,0,0),this.camera.nearClip=0,this.camera.farClip=2*a.halfExtents.y;const e=Math.max(a.halfExtents.x,a.halfExtents.z);this.camera.orthoHeight=e}else e.lightBounds.intersects(t.bounds)||(i=!1);if(r.type===y){let e=!1;const a=t.meshInstances;for(let t=0;t<a.length;t++)if(a[t]._isVisible(s)){e=!0;break}e||(i=!1)}return i}setupLightArray(e,t){e[_].length=0,e[A].length=0,e[y].length=0,e[t.type][0]=t,t.visibleThisFrame=!0}renderShadowMap(e,t,s){const a=s.light,r=this.scene.clusteredLightingEnabled;if(!e&&a.castShadows){a.shadowMap||r||(a.shadowMap=this.shadowMapCache.get(this.device,a)),a.type===_?this.renderer._shadowRendererDirectional.cull(a,t,this.camera):this.renderer._shadowRendererLocal.cull(a,t);const e=!1;this.renderer.shadowRenderer.render(a,this.camera,e)}return!0}postprocessTextures(e,t,s){const a=this.lightmapFilters.shaderDilate,r=this.scene.lightmapFilterEnabled;r&&this.lightmapFilters.prepareDenoise(this.scene.lightmapFilterRange,this.scene.lightmapFilterSmoothness),e.setBlendState(q.DEFAULT),e.setDepthState(H.NODEPTH);for(let i=0;i<t.length;i++){const n=t[i];for(let t=0;t<s;t++){const s=n.renderTargets[t],i=s.colorBuffer,h=this.renderTargets.get(i.width),o=h.colorBuffer;this.lightmapFilters.prepare(i.width,i.height);for(let n=0;n<1;n++){this.lightmapFilters.setSourceTexture(i);g(e,h,r&&0===t&&0===n?this.lightmapFilters.shaderDenoise:a),this.lightmapFilters.setSourceTexture(o),g(e,s,a)}}}}bakeInternal(e,t,s){const a=this.scene,r=this.device,i=a.clusteredLightingEnabled;this.createMaterials(r,a,e),this.setupScene(),a.layers._update(),this.computeNodesBounds(t),this.allocateTextures(t,e);const n=[],h=[];this.prepareLightsToBake(a.layers,n,h),this.updateTransforms(s);const o=this.prepareShadowCasters(s);this.renderer.updateCpuSkinMatrices(o),this.renderer.gpuUpdate(o);const l=this.computeBounds(o);let c,m,d,p;for(c=0;c<t.length;c++){for(d=t[c].meshInstances,m=0;m<d.length;m++)p=d[m],p.setLightmapped(!1),p.mask=x,p.setRealtimeLightmap(f.lightmapParamNames[0],p.material.lightMap?p.material.lightMap:this.blackTex),p.setRealtimeLightmap(f.lightmapParamNames[1],this.blackTex)}for(m=0;m<h.length;m++)h[m].light.enabled=!1;const g=[[],[],[]];let u,b,w=!1;for(c=0;c<h.length;c++){const s=h[c],n=s instanceof N;let k=s.numVirtualLights;e>1&&k>1&&s.light.bakeDir&&(k=1);for(let h=0;h<k;h++){k>1&&s.prepareVirtualLight(h,k),s.startBake();let c=!1;const T=this.lightCameraPrepare(r,s);for(b=0;b<t.length;b++){const S=t[b];d=S.meshInstances;if(this.lightCameraPrepareAndCull(s,S,T,l)){if(this.setupLightArray(g,s.light),i&&this.renderer.lightTextureAtlas.update(g[y],g[A],this.lightingParams),c=this.renderShadowMap(c,o,s),i){const e=g[y].concat(g[A]);this.worldClusters.update(e,this.scene.gammaCorrection,this.lightingParams)}for(this.backupMaterials(d),u=0;u<e&&!(u>0&&h>0)&&!(n&&u>0);u++){const e=S.renderTargets[u],t=S.renderTargets[u].colorBuffer.width,o=this.renderTargets.get(t),l=o.colorBuffer;0===u?w=a.updateShaders:w&&(a.updateShaders=!0);let c=this.passMaterials[u];if(n){h+1===k&&0===u&&(c=this.ambientAOMaterial)}for(m=0;m<d.length;m++)d[m].material=c;for(this.renderer.updateShaders(d),this.renderer.setCamera(this.camera,o,!0),1===u&&this.constantBakeDir.setValue(s.light.bakeDir?1:0),i&&this.worldClusters.activate(),this.renderer._forwardTime=0,this.renderer._shadowMapTime=0,this.renderer.renderForward(this.camera,d,d.length,g,F),r.updateEnd(),S.renderTargets[u]=o,this.renderTargets.set(t,e),m=0;m<d.length;m++)p=d[m],p.setRealtimeLightmap(f.lightmapParamNames[u],l),p._shaderDefs|=E}this.restoreMaterials(d)}}s.endBake(this.shadowMapCache)}}for(this.postprocessTextures(r,t,e),b=0;b<s.length;b++)s[b].restore();this.restoreLights(n),this.restoreScene(),i||this.shadowMapCache.clear()}}export{W as Lightmapper};
