import"../../../core/tracing.js";import{PIXELFORMAT_DEPTHSTENCIL as e,SAMPLETYPE_DEPTH as t,SAMPLETYPE_UNFILTERABLE_FLOAT as r,PIXELFORMAT_RGBA32F as a,PIXELFORMAT_RGBA16F as s,pixelFormatByteSizes as i,PIXELFORMAT_A8 as o,PIXELFORMAT_L8 as l,PIXELFORMAT_LA8 as n,PIXELFORMAT_RGB565 as u,PIXELFORMAT_RGBA5551 as p,PIXELFORMAT_RGBA4 as m,PIXELFORMAT_RGB8 as d,PIXELFORMAT_RGBA8 as h,PIXELFORMAT_DXT1 as c,PIXELFORMAT_DXT3 as g,PIXELFORMAT_DXT5 as f,PIXELFORMAT_RGB16F as x,PIXELFORMAT_RGB32F as v,PIXELFORMAT_R32F as y,PIXELFORMAT_DEPTH as T,PIXELFORMAT_111110F as w,PIXELFORMAT_SRGB as L,PIXELFORMAT_SRGBA as b,PIXELFORMAT_ETC1 as U,PIXELFORMAT_ETC2_RGB as C,PIXELFORMAT_ETC2_RGBA as E,PIXELFORMAT_PVRTC_2BPP_RGB_1 as I,PIXELFORMAT_PVRTC_2BPP_RGBA_1 as M,PIXELFORMAT_PVRTC_4BPP_RGB_1 as A,PIXELFORMAT_PVRTC_4BPP_RGBA_1 as _,PIXELFORMAT_ASTC_4x4 as F,PIXELFORMAT_ATC_RGB as O,PIXELFORMAT_ATC_RGBA as P,PIXELFORMAT_BGRA8 as V,ADDRESS_REPEAT as D,ADDRESS_CLAMP_TO_EDGE as R,ADDRESS_MIRRORED_REPEAT as G}from"../constants.js";const q=[];q[o]="",q[l]="r8unorm",q[n]="rg8unorm",q[u]="",q[p]="",q[m]="",q[d]="rgba8unorm",q[h]="rgba8unorm",q[c]="",q[g]="",q[f]="",q[x]="",q[s]="rgba16float",q[v]="",q[a]="rgba32float",q[y]="r32float",q[T]="depth32float",q[e]="depth24plus-stencil8",q[w]="rg11b10ufloat",q[L]="",q[b]="",q[U]="",q[C]="",q[E]="",q[I]="",q[M]="",q[A]="",q[_]="",q[F]="",q[O]="",q[P]="",q[V]="bgra8unorm";const N=[];N[D]="repeat",N[R]="clamp-to-edge",N[G]="mirror-repeat";class S{constructor(e){this.gpuTexture=void 0,this.view=void 0,this.samplers=[],this.descr=void 0,this.format=void 0,this.texture=e,this.format=q[e.format],this.create(e.device)}create(t){const r=this.texture,a=t.wgpu,s=r.requiredMipLevels;let i;this.descr={size:{width:r.width,height:r.height,depthOrArrayLayers:r.cubemap?6:1},format:this.format,mipLevelCount:s,sampleCount:1,dimension:r.volume?"3d":"2d",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC},this.gpuTexture=a.createTexture(this.descr),this.texture.format===e&&(i={format:"depth24plus",aspect:"depth-only"}),this.view=this.createView(i)}destroy(e){}getView(e){return this.uploadImmediate(e,this.texture),this.view}createView(e){var t,r,a,s,i,o,l;const n=null!=e?e:{},u=this.descr,p=this.texture,m={format:null!=(t=n.format)?t:u.format,dimension:null!=(r=n.dimension)?r:p.cubemap?"cube":p.volume?"3d":"2d",aspect:null!=(a=n.aspect)?a:"all",baseMipLevel:null!=(s=n.baseMipLevel)?s:0,mipLevelCount:null!=(i=n.mipLevelCount)?i:u.mipLevelCount,baseArrayLayer:null!=(o=n.baseArrayLayer)?o:0,arrayLayerCount:null!=(l=n.arrayLayerCount)?l:u.depthOrArrayLayers};return this.gpuTexture.createView(m)}getSampler(i,o){let l=this.samplers[o];if(!l){const n=this.texture,u={addressModeU:N[n.addressU],addressModeV:N[n.addressV],addressModeW:N[n.addressW]};!o&&n.compareOnRead&&(o=t),o===t?(u.compare="less",u.magFilter="linear",u.minFilter="linear"):o===r||this.texture.format===a||this.texture.format===e||this.texture.format===s?(u.magFilter="nearest",u.minFilter="nearest",u.mipmapFilter="nearest"):(u.magFilter="linear",u.minFilter="linear",u.mipmapFilter="linear"),l=i.wgpu.createSampler(u),this.samplers[o]=l}return l}loseContext(){}uploadImmediate(e,t){(t._needsUpload||t._needsMipmapsUpload)&&(this.uploadData(e),t._needsUpload=!1,t._needsMipmapsUpload=!1)}uploadData(e){const t=this.texture;if(t._levels){const r=e.wgpu;let a=!1;const s=t.requiredMipLevels;for(let i=0;i<s;i++){const s=t._levels[i];if(s)if(t.cubemap)for(let t=0;t<6;t++){const r=s[t];r&&this.isExternalImage(r)&&(this.uploadExternalImage(e,r,i,t),a=!0)}else t._volume||(this.isExternalImage(s)?(this.uploadExternalImage(e,s,i,0),a=!0):ArrayBuffer.isView(s)&&(this.uploadTypedArrayData(r,s),a=!0))}a&&t.mipmaps&&e.mipmapRenderer.generate(this)}}isExternalImage(e){return e instanceof ImageBitmap||e instanceof HTMLVideoElement||e instanceof HTMLCanvasElement||e instanceof OffscreenCanvas}uploadExternalImage(e,t,r,a){const s={source:t,origin:[0,0],flipY:!1},i={texture:this.gpuTexture,mipLevel:r,origin:[0,0,a],aspect:"all"},o={width:this.descr.size.width,height:this.descr.size.height,depthOrArrayLayers:1};e.wgpu.queue.copyExternalImageToTexture(s,i,o)}uploadTypedArrayData(e,t){var r;const a=this.texture,s={texture:this.gpuTexture,mipLevel:0},o=null!=(r=i[a.format])?r:0,l=a.width*o;a.height;const n={offset:0,bytesPerRow:l,rowsPerImage:a.height},u={width:a.width,height:a.height,depthOrArrayLayers:1};e.queue.writeTexture(s,t,n,u)}}export{S as WebgpuTexture};
