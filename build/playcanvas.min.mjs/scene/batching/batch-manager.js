import"../../core/debug.js";import"../../core/time.js";import{Mat3 as e}from"../../core/math/mat3.js";import{Vec3 as t}from"../../core/math/vec3.js";import{BoundingBox as s}from"../../core/shape/bounding-box.js";import{PRIMITIVE_TRIFAN as n,PRIMITIVE_TRISTRIP as r,SEMANTIC_BLENDINDICES as i,TYPE_FLOAT32 as o,typedArrayTypes as a,typedArrayTypesByteSize as c,SEMANTIC_POSITION as h,SEMANTIC_NORMAL as l,SEMANTIC_TANGENT as m,typedArrayIndexFormats as u,PRIMITIVE_TRIANGLES as d}from"../../platform/graphics/constants.js";import{SPRITE_RENDERMODE_SIMPLE as p}from"../constants.js";import{Mesh as f}from"../mesh.js";import{MeshInstance as _}from"../mesh-instance.js";import{shaderChunks as b}from"../shader-lib/chunks/chunks.js";import{Batch as g}from"./batch.js";import{BatchGroup as I}from"./batch-group.js";import{SkinBatchInstance as y}from"./skin-batch-instance.js";function x(e,t){if(e&&!t)return!1;if(!e&&t)return!1;if((e=e.data)===(t=t.data))return!0;if(e instanceof Float32Array&&t instanceof Float32Array){if(e.length!==t.length)return!1;for(let s=0;s<e.length;s++)if(e[s]!==t[s])return!1;return!0}return!1}function G(e,t){for(const s in e)if(e.hasOwnProperty(s)&&!x(e[s],t[s]))return!1;for(const s in t)if(t.hasOwnProperty(s)&&!x(t[s],e[s]))return!1;return!0}function v(e,t){for(let s=0;s<e.length;s++)if(t.indexOf(e[s])<0)return!1;for(let s=0;s<t.length;s++)if(e.indexOf(t[s])<0)return!1;return!0}const L=[0,1,3,2,3,1],w=[0,1,3,0,3,2],S=new e;function B(e){return e.node.worldTransform.scaleSign}class M{constructor(e,t,s){this.device=e,this.rootNode=t,this.scene=s,this._init=!1,this._batchGroups={},this._batchGroupCounter=0,this._batchList=[],this._dirtyGroups=[]}destroy(){this.device=null,this.rootNode=null,this.scene=null,this._batchGroups={},this._batchList=[],this._dirtyGroups=[]}addGroup(e,t,s,n,r){if(void 0===n&&(n=this._batchGroupCounter,this._batchGroupCounter++),this._batchGroups[n])return;const i=new I(n,e,t,s,r);return this._batchGroups[n]=i,i}removeGroup(e){if(!this._batchGroups[e])return;const t=[];for(let s=0;s<this._batchList.length;s++)this._batchList[s].batchGroupId===e?this.destroyBatch(this._batchList[s]):t.push(this._batchList[s]);this._batchList=t,this._removeModelsFromBatchGroup(this.rootNode,e),delete this._batchGroups[e]}markGroupDirty(e){this._dirtyGroups.indexOf(e)<0&&this._dirtyGroups.push(e)}getGroupByName(e){const t=this._batchGroups;for(const s in t)if(t.hasOwnProperty(s)&&t[s].name===e)return t[s];return null}getBatches(e){const t=[],s=this._batchList.length;for(let n=0;n<s;n++){const s=this._batchList[n];s.batchGroupId===e&&t.push(s)}return t}_removeModelsFromBatchGroup(e,t){if(e.enabled){e.model&&e.model.batchGroupId===t&&(e.model.batchGroupId=-1),e.render&&e.render.batchGroupId===t&&(e.render.batchGroupId=-1),e.element&&e.element.batchGroupId===t&&(e.element.batchGroupId=-1),e.sprite&&e.sprite.batchGroupId===t&&(e.sprite.batchGroupId=-1);for(let s=0;s<e._children.length;s++)this._removeModelsFromBatchGroup(e._children[s],t)}}insert(e,t,s){const n=this._batchGroups[t];n&&n._obj[e].indexOf(s)<0&&(n._obj[e].push(s),this.markGroupDirty(t))}remove(e,t,s){const n=this._batchGroups[t];if(n){const r=n._obj[e].indexOf(s);r>=0&&(n._obj[e].splice(r,1),this.markGroupDirty(t))}}_extractRender(e,t,s,n){if(e.render){if(e.render.isStatic){const s=this.scene.drawCalls,n=e.render.meshInstances;for(let e=0;e<s.length;e++)s[e]._staticSource&&(n.indexOf(s[e]._staticSource)<0||t.push(s[e]));for(let e=0;e<n.length;e++)s.indexOf(n[e])>=0&&t.push(n[e])}else t=n[e.render.batchGroupId]=t.concat(e.render.meshInstances);e.render.removeFromLayers()}return t}_extractModel(e,t,s,n){if(e.model&&e.model.model){if(e.model.isStatic){const s=this.scene.drawCalls,n=e.model.meshInstances;for(let e=0;e<s.length;e++)s[e]._staticSource&&(n.indexOf(s[e]._staticSource)<0||t.push(s[e]));for(let e=0;e<n.length;e++)s.indexOf(n[e])>=0&&t.push(n[e])}else t=n[e.model.batchGroupId]=t.concat(e.model.meshInstances);e.model.removeModelFromLayers()}return t}_extractElement(e,t,s){if(!e.element)return;let n=!1;e.element._text&&e.element._text._model.meshInstances.length>0?(t.push(e.element._text._model.meshInstances[0]),e.element.removeModelFromLayers(e.element._text._model),n=!0):e.element._image&&(t.push(e.element._image._renderable.meshInstance),e.element.removeModelFromLayers(e.element._image._renderable.model),e.element._image._renderable.unmaskMeshInstance&&(t.push(e.element._image._renderable.unmaskMeshInstance),e.element._image._renderable.unmaskMeshInstance.stencilFront&&e.element._image._renderable.unmaskMeshInstance.stencilBack||(e.element._dirtifyMask(),e.element._onPrerender())),n=!0),n&&(s._ui=!0)}_collectAndRemoveMeshInstances(e,t){for(let s=0;s<t.length;s++){const n=t[s],r=this._batchGroups[n];if(!r)continue;let i=e[n];i||(i=e[n]=[]);for(let t=0;t<r._obj.model.length;t++)i=this._extractModel(r._obj.model[t],i,r,e);for(let t=0;t<r._obj.render.length;t++)i=this._extractRender(r._obj.render[t],i,r,e);for(let e=0;e<r._obj.element.length;e++)this._extractElement(r._obj.element[e],i,r);for(let e=0;e<r._obj.sprite.length;e++){const t=r._obj.sprite[e];t.sprite&&t.sprite._meshInstance&&(r.dynamic||t.sprite.sprite._renderMode===p)&&(i.push(t.sprite._meshInstance),t.sprite.removeModelFromLayers(),r._sprite=!0,t.sprite._batchGroup=r)}}}generate(e){const t={};e||(e=Object.keys(this._batchGroups));const s=[];for(let t=0;t<this._batchList.length;t++)e.indexOf(this._batchList[t].batchGroupId)<0?s.push(this._batchList[t]):this.destroyBatch(this._batchList[t]);if(this._batchList=s,this._collectAndRemoveMeshInstances(t,e),e===this._dirtyGroups)this._dirtyGroups.length=0;else{const t=[];for(let s=0;s<this._dirtyGroups.length;s++)e.indexOf(this._dirtyGroups[s])<0&&t.push(this._dirtyGroups[s]);this._dirtyGroups=t}let n,r,i,o;for(const e in t)if(t.hasOwnProperty(e)&&(n=t[e],i=this._batchGroups[e],i)){r=this.prepare(n,i.dynamic,i.maxAabbSize,i._ui||i._sprite);for(let t=0;t<r.length;t++)o=this.create(r[t],i.dynamic,parseInt(e,10)),o&&o.addToLayers(this.scene,i.layers)}}prepare(e,t,n=Number.POSITIVE_INFINITY,r){if(0===e.length)return[];const i=.5*n,o=this.device.supportsBoneTextures?1024:this.device.boneLimit,a=this.device.extUintElement?4294967295:65535,c=new s,h=new s;let l,m=null;const u=[];let d=0;r&&e.sort((function(e,t){return e.drawOrder-t.drawOrder}));let p,f=e;const _=r?function(e){m?m.add(e.aabb):m=e.aabb.clone(),p.push(e)}:function(e){p.push(e)};for(;f.length>0;){u[d]=[f[0]],p=[];const e=f[0].material,s=f[0].layer,n=f[0]._shaderDefs,b=f[0].parameters,g=f[0].stencilFront,I=f[0]._staticLightList;let y=f[0].mesh.vertexBuffer.getNumVertices();const x=f[0].drawOrder;c.copy(f[0].aabb);const L=B(f[0]),w=f[0].mesh.vertexBuffer.format.batchingHash,S=f[0].mesh.primitive[0].indexed;m=null;for(let M=1;M<f.length;M++){const k=f[M];if(t&&u[d].length>=o){p=p.concat(f.slice(M));break}if(e!==k.material||s!==k.layer||w!==k.mesh.vertexBuffer.format.batchingHash||S!==k.mesh.primitive[0].indexed||n!==k._shaderDefs||y+k.mesh.vertexBuffer.getNumVertices()>a){_(k);continue}if(h.copy(c),h.add(k.aabb),h.halfExtents.x>i||h.halfExtents.y>i||h.halfExtents.z>i){_(k);continue}if(g&&(!(l=k.stencilFront)||g.func!==l.func||g.zpass!==l.zpass)){_(k);continue}if(L!==B(k)){_(k);continue}if(!G(b,k.parameters)){_(k);continue}const j=k._staticLightList;if(I&&j){if(!v(I,j)){_(k);continue}}else if(I||j){_(k);continue}r&&m&&m.intersects(k.aabb)&&k.drawOrder!==x?_(k):(c.add(k.aabb),y+=k.mesh.vertexBuffer.getNumVertices(),u[d].push(k))}d++,f=p}return u}collectBatchedMeshData(e,t){let s=null,a=0,c=0,h=null;for(let l=0;l<e.length;l++)if(e[l].visible){const m=e[l].mesh;if(a+=m.vertexBuffer.numVertices,m.primitive[0].indexed)c+=m.primitive[0].count;else{const e=m.primitive[0].type;e!==n&&e!==r||4===m.primitive[0].count&&(c+=6)}if(!s){h=e[l].material,s={};const n=m.vertexBuffer.format.elements;for(let e=0;e<n.length;e++){s[n[e].name]={numComponents:n[e].numComponents,dataType:n[e].dataType,normalize:n[e].normalize,count:0}}t&&(s[i]={numComponents:1,dataType:o,normalize:!1,count:0})}}return{streams:s,batchNumVerts:a,batchNumIndices:c,material:h}}create(e,s,o){if(!this._init){const e="#define BONE_LIMIT "+this.device.getBoneLimit()+"\n";this.transformVS=e+"#define DYNAMICBATCH\n"+b.transformVS,this.skinTexVS=b.skinBatchTexVS,this.skinConstVS=b.skinBatchConstVS,this.vertexFormats={},this._init=!0}let p,I,x,G=null,v=null;const M=this.collectBatchedMeshData(e,s);if(M.streams){const b=M.streams;let k=M.material;const j=M.batchNumVerts,O=M.batchNumIndices;let V,T,C;v=new g(e,s,o),this._batchList.push(v);let F,N=0,A=0;const z=new t,D=new(j<=65535?Uint16Array:Uint32Array)(O);for(p in b)G=b[p],G.typeArrayType=a[G.dataType],G.elementByteSize=c[G.dataType],G.buffer=new G.typeArrayType(j*G.numComponents);for(let t=0;t<e.length;t++)if(e[t].visible){for(p in I=e[t].mesh,x=I.vertexBuffer.numVertices,s||(F=e[t].node.getWorldTransform()),b)if(p!==i){G=b[p];const e=new G.typeArrayType(G.buffer.buffer,G.elementByteSize*G.count),t=I.getVertexStream(p,e)*G.numComponents;if(G.count+=t,!s&&G.numComponents>=3)if(p===h)for(let s=0;s<t;s+=G.numComponents)z.set(e[s],e[s+1],e[s+2]),F.transformPoint(z,z),e[s]=z.x,e[s+1]=z.y,e[s+2]=z.z;else if(p===l||p===m){F.invertTo3x3(S),S.transpose();for(let s=0;s<t;s+=G.numComponents)z.set(e[s],e[s+1],e[s+2]),S.transformVector(z,z),e[s]=z.x,e[s+1]=z.y,e[s+2]=z.z}}if(s){G=b[i];for(let e=0;e<x;e++)G.buffer[G.count++]=t}if(I.primitive[0].indexed){V=I.primitive[0].base,T=I.primitive[0].count;const e=I.indexBuffer[0].getFormat();C=new u[e](I.indexBuffer[0].storage)}else{const e=I.primitive[0].type;if(e===n||e===r){if(4!==I.primitive[0].count){T=0;continue}V=0,T=6,C=e===n?L:w}}for(let e=0;e<T;e++)D[e+A]=C[V+e]+N;A+=T,N+=x}for(p in I=new f(this.device),b)G=b[p],I.setVertexStream(p,G.buffer,G.numComponents,void 0,G.dataType,G.normalize);D.length>0&&I.setIndices(D),I.update(d,!1),s&&(k=k.clone(),k.chunks.transformVS=this.transformVS,k.chunks.skinTexVS=this.skinTexVS,k.chunks.skinConstVS=this.skinConstVS,k.update());const E=new _(I,k,this.rootNode);E.castShadow=v.origMeshInstances[0].castShadow,E.parameters=v.origMeshInstances[0].parameters,E.isStatic=v.origMeshInstances[0].isStatic,E.layer=v.origMeshInstances[0].layer,E._staticLightList=v.origMeshInstances[0]._staticLightList,E._shaderDefs=v.origMeshInstances[0]._shaderDefs,E.cull=v.origMeshInstances[0].cull;const P=this._batchGroups[o];if(P&&P._ui&&(E.cull=!1),s){const e=[];for(let t=0;t<v.origMeshInstances.length;t++)e.push(v.origMeshInstances[t].node);E.skinInstance=new y(this.device,e,this.rootNode)}E._updateAabb=!1,E.drawOrder=v.origMeshInstances[0].drawOrder,E.stencilFront=v.origMeshInstances[0].stencilFront,E.stencilBack=v.origMeshInstances[0].stencilBack,E.flipFacesFactor=B(v.origMeshInstances[0]),E.castShadow=v.origMeshInstances[0].castShadow,v.meshInstance=E,v.updateBoundingBox()}return v}updateAll(){this._dirtyGroups.length>0&&this.generate(this._dirtyGroups);for(let e=0;e<this._batchList.length;e++)this._batchList[e].dynamic&&this._batchList[e].updateBoundingBox()}clone(e,t){const s=new g(t,e.dynamic,e.batchGroupId);this._batchList.push(s);const n=[];for(let e=0;e<t.length;e++)n.push(t[e].node);return s.meshInstance=new _(e.meshInstance.mesh,e.meshInstance.material,e.meshInstance.node),s.meshInstance._updateAabb=!1,s.meshInstance.parameters=t[0].parameters,s.meshInstance.isStatic=t[0].isStatic,s.meshInstance.cull=t[0].cull,s.meshInstance.layer=t[0].layer,s.meshInstance._staticLightList=t[0]._staticLightList,e.dynamic&&(s.meshInstance.skinInstance=new y(this.device,n,this.rootNode)),s.meshInstance.castShadow=e.meshInstance.castShadow,s.meshInstance._shader=e.meshInstance._shader.slice(),s.meshInstance.castShadow=e.meshInstance.castShadow,s}destroyBatch(e){e.destroy(this.scene,this._batchGroups[e.batchGroupId].layers)}}export{M as BatchManager};
