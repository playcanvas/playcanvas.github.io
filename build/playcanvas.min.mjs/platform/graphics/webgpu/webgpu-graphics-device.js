import"../../../core/tracing.js";import{Vec2 as e}from"../../../core/math/vec2.js";import{DEVICETYPE_WEBGPU as t,PIXELFORMAT_RGBA32F as s,PIXELFORMAT_RGBA8 as r,PIXELFORMAT_BGRA8 as i}from"../constants.js";import{GraphicsDevice as n}from"../graphics-device.js";import{RenderTarget as a}from"../render-target.js";import{WebgpuBindGroup as h}from"./webgpu-bind-group.js";import{WebgpuBindGroupFormat as o}from"./webgpu-bind-group-format.js";import{WebgpuIndexBuffer as p}from"./webgpu-index-buffer.js";import{WebgpuRenderPipeline as u}from"./webgpu-render-pipeline.js";import{WebgpuRenderTarget as d}from"./webgpu-render-target.js";import{WebgpuShader as m}from"./webgpu-shader.js";import{WebgpuTexture as l}from"./webgpu-texture.js";import{WebgpuUniformBuffer as c}from"./webgpu-uniform-buffer.js";import{WebgpuVertexBuffer as f}from"./webgpu-vertex-buffer.js";import{WebgpuClearRenderer as g}from"./webgpu-clear-renderer.js";import{WebgpuMipmapRenderer as x}from"./webgpu-mipmap-renderer.js";import{StencilParameters as w}from"../stencil-parameters.js";class b extends n{constructor(e,s={}){super(e,s),this.frameBuffer=void 0,this.renderPipeline=new u(this),this.clearRenderer=void 0,this.mipmapRenderer=void 0,this.pipeline=void 0,this.bindGroupFormats=[],this.commandEncoder=void 0,s=this.initOptions,this.isWebGPU=!0,this._deviceType=t,this.samples=s.antialias?4:1,this.setupPassEncoderDefaults()}destroy(){super.destroy()}initDeviceCaps(){this.disableParticleSystem=!0;const e=this.gpuAdapter.limits;this.precision="highp",this.maxPrecision="highp",this.maxSamples=4,this.maxTextures=16,this.maxTextureSize=e.maxTextureDimension2D,this.maxCubeMapSize=e.maxTextureDimension2D,this.maxVolumeSize=e.maxTextureDimension3D,this.maxPixelRatio=1,this.supportsInstancing=!0,this.supportsUniformBuffers=!0,this.supportsBoneTextures=!0,this.supportsMorphTargetTexturesCore=!0,this.supportsAreaLights=!0,this.supportsDepthShadow=!0,this.supportsGpuParticles=!1,this.extUintElement=!0,this.extTextureFloat=!0,this.textureFloatRenderable=!0,this.extTextureHalfFloat=!0,this.textureHalfFloatRenderable=!0,this.textureHalfFloatUpdatable=!0,this.boneLimit=1024,this.supportsImageBitmap=!0,this.extStandardDerivatives=!0,this.extBlendMinmax=!0,this.areaLightLutFormat=this.floatFilterable?s:r,this.supportsTextureFetch=!0}async initWebGpu(e,t){if(!window.navigator.gpu)throw new Error("Unable to retrieve GPU. Ensure you are using a browser that supports WebGPU rendering.");const s=e=>new Promise((function(t,s){const r=document.createElement("script");r.src=e,r.async=!1,r.onload=function(){t(e)},r.onerror=function(){s(new Error(`Failed to download script ${e}`))},document.body.appendChild(r)}));await s(e),await s(t),this.glslang=await glslang();const n=t.replace(".js",".wasm");this.twgsl=await twgsl(n),this.gpuAdapter=await window.navigator.gpu.requestAdapter();const a=[];this.floatFilterable=(e=>!!this.gpuAdapter.features.has(e)&&(a.push(e),!0))("float32-filterable"),this.wgpu=await this.gpuAdapter.requestDevice({requiredFeatures:a,requiredLimits:{}}),this.initDeviceCaps(),this.setResolution(window.innerWidth,window.innerHeight),this.gpuContext=this.canvas.getContext("webgpu");const h=navigator.gpu.getPreferredCanvasFormat();return this.framebufferFormat="rgba8unorm"===h?r:i,this.canvasConfig={device:this.wgpu,colorSpace:"srgb",alphaMode:"opaque",format:h,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST,viewFormats:[]},this.gpuContext.configure(this.canvasConfig),this.createFramebuffer(),this.clearRenderer=new g(this),this.mipmapRenderer=new x(this),this.postInit(),this}createFramebuffer(){this.supportsStencil=this.initOptions.stencil,this.frameBufferDimensions=new e,this.frameBuffer=new a({name:"WebgpuFramebuffer",graphicsDevice:this,depth:this.initOptions.depth,stencil:this.supportsStencil,samples:this.samples})}resizeCanvas(e,t){this._width=e,this._height=t,this.canvas.width===e&&this.canvas.height===t||(this.canvas.width=e,this.canvas.height=t,this.fire(n.EVENT_RESIZE,e,t))}frameStart(){super.frameStart();const e=this.gpuContext.getCurrentTexture();this.frameBufferDimensions.x===e.width&&this.frameBufferDimensions.y===e.height||(this.frameBufferDimensions.set(e.width,e.height),this.frameBuffer.destroy(),this.frameBuffer=null,this.createFramebuffer());const t=this.frameBuffer,s=t.impl;s.colorFormat=e.format,this.initRenderTarget(t),s.assignColorTexture(e)}createUniformBufferImpl(e){return new c(e)}createVertexBufferImpl(e,t){return new f(e,t)}createIndexBufferImpl(e){return new p(e)}createShaderImpl(e){return new m(e)}createTextureImpl(e){return new l(e)}createRenderTargetImpl(e){return new d(e)}createBindGroupFormatImpl(e){return new o(e)}createBindGroupImpl(e){return new h}setBindGroup(e,t){this.passEncoder&&(this.passEncoder.setBindGroup(e,t.impl.bindGroup),this.bindGroupFormats[e]=t.format.impl)}submitVertexBuffer(e,t){const s=e.format,r=s.elements.length,i=e.impl.buffer;for(let e=0;e<r;e++){const r=s.elements[e];this.passEncoder.setVertexBuffer(t+e,i,r.offset)}return r}draw(e,t=1,s){if(this.shader.ready&&!this.shader.failed){const s=this.passEncoder,r=this.vertexBuffers[0],i=this.vertexBuffers[1];if(this.vertexBuffers.length=0,r){const e=this.submitVertexBuffer(r,0);i&&this.submitVertexBuffer(i,e)}const n=this.renderPipeline.get(e,null==r?void 0:r.format,null==i?void 0:i.format,this.shader,this.renderTarget,this.bindGroupFormats,this.blendState,this.depthState,this.cullMode,this.stencilEnabled,this.stencilFront,this.stencilBack);this.pipeline!==n&&(this.pipeline=n,s.setPipeline(n));const a=this.indexBuffer;a?(this.indexBuffer=null,s.setIndexBuffer(a.impl.buffer,a.impl.format),s.drawIndexed(e.count,t,0,0,0)):s.draw(e.count,t,0,0)}}setShader(e){return this.shader=e,!0}setBlendState(e){this.blendState.copy(e)}setDepthState(e){this.depthState.copy(e)}setStencilState(e,t){if(e||t){this.stencilEnabled=!0,this.stencilFront.copy(null!=e?e:w.DEFAULT),this.stencilBack.copy(null!=t?t:w.DEFAULT);const s=this.stencilFront.ref;this.stencilRef!==s&&(this.stencilRef=s,this.passEncoder.setStencilReference(s))}else this.stencilEnabled=!1}setBlendColor(e,t,s,r){}setCullMode(e){this.cullMode=e}setAlphaToCoverage(e){}initializeContextCaches(){super.initializeContextCaches()}setupPassEncoderDefaults(){this.stencilRef=0}startPass(e){const t=e.renderTarget||this.frameBuffer;this.renderTarget=t;const s=t.impl;t!==this.frameBuffer&&this.initRenderTarget(t),s.setupForRenderPass(e),this.commandEncoder=this.wgpu.createCommandEncoder(),this.pipeline=null,this.passEncoder=this.commandEncoder.beginRenderPass(s.renderPassDescriptor),this.setupPassEncoderDefaults();const{width:r,height:i}=t;this.setViewport(0,0,r,i),this.setScissor(0,0,r,i),this.insideRenderPass=!0}endPass(e){this.passEncoder.end(),this.passEncoder=null,this.wgpu.queue.submit([this.commandEncoder.finish()]),this.commandEncoder=null,this.bindGroupFormats.length=0,this.insideRenderPass=!1,e.colorOps.mipmaps&&this.mipmapRenderer.generate(e.renderTarget.colorBuffer.impl)}clear(e){e.flags&&this.clearRenderer.clear(this,this.renderTarget,e,this.defaultClearOptions)}get width(){return this._width}get height(){return this._height}setDepthBias(e){}setDepthBiasValues(e,t){}setViewport(e,t,s,r){this.passEncoder&&(this.renderTarget.flipY||(t=this.renderTarget.height-t-r),this.vx=e,this.vy=t,this.vw=s,this.vh=r,this.passEncoder.setViewport(e,t,s,r,0,1))}setScissor(e,t,s,r){this.passEncoder&&(this.renderTarget.flipY||(t=this.renderTarget.height-t-r),this.sx=e,this.sy=t,this.sw=s,this.sh=r,this.passEncoder.setScissorRect(e,t,s,r))}copyRenderTarget(e,t,s,r){var i;const n={width:e?e.width:t.width,height:e?e.height:t.height,depthOrArrayLayers:1},a=null!=(i=this.commandEncoder)?i:this.wgpu.createCommandEncoder();if(s){const s={texture:e?e.colorBuffer.impl.gpuTexture:this.renderTarget.impl.assignedColorTexture,mipLevel:0},r={texture:t?t.colorBuffer.impl.gpuTexture:this.renderTarget.impl.assignedColorTexture,mipLevel:0};a.copyTextureToTexture(s,r,n)}if(r){const s={texture:(e||this.renderTarget).impl.depthTexture,mipLevel:0},r={texture:t?t.depthBuffer.impl.gpuTexture:this.renderTarget.impl.depthTexture,mipLevel:0};a.copyTextureToTexture(s,r,n)}return this.commandEncoder||this.wgpu.queue.submit([a.finish()]),!0}}export{b as WebgpuGraphicsDevice};
