import"../../core/time.js";import"../../core/tracing.js";import{Vec3 as t}from"../../core/math/vec3.js";import{Color as e}from"../../core/math/color.js";import{FUNC_ALWAYS as s,STENCILOP_KEEP as i}from"../../platform/graphics/constants.js";import{RenderPass as a}from"../../platform/graphics/render-pass.js";import{LIGHTSHAPE_PUNCTUAL as o,LIGHTTYPE_OMNI as r,LIGHTTYPE_SPOT as h,LIGHTTYPE_DIRECTIONAL as n,FOG_NONE as l,FOG_LINEAR as d,LAYERID_DEPTH as c,COMPUPDATED_LIGHTS as g}from"../constants.js";import{Renderer as f}from"./renderer.js";import{LightCamera as p}from"./light-camera.js";import"../lighting/world-clusters-debug.js";import{SceneGrab as u}from"../graphics/scene-grab.js";import{BlendState as m}from"../../platform/graphics/blend-state.js";const _=new e(254/255,254/255,254/255,254/255),w={drawCalls:[],isNewMaterial:[],lightMaskChanged:[]};class C extends f{constructor(t){super(t);const e=this.device;this._forwardDrawCalls=0,this._materialSwitches=0,this._depthMapTime=0,this._forwardTime=0,this._sortTime=0;const s=e.scope;this.fogColorId=s.resolve("fog_color"),this.fogStartId=s.resolve("fog_start"),this.fogEndId=s.resolve("fog_end"),this.fogDensityId=s.resolve("fog_density"),this.ambientId=s.resolve("light_globalAmbient"),this.skyboxIntensityId=s.resolve("skyboxIntensity"),this.cubeMapRotationMatrixId=s.resolve("cubeMapRotationMatrix"),this.lightColorId=[],this.lightDir=[],this.lightDirId=[],this.lightShadowMapId=[],this.lightShadowMatrixId=[],this.lightShadowParamsId=[],this.lightShadowIntensity=[],this.lightRadiusId=[],this.lightPos=[],this.lightPosId=[],this.lightWidth=[],this.lightWidthId=[],this.lightHeight=[],this.lightHeightId=[],this.lightInAngleId=[],this.lightOutAngleId=[],this.lightCookieId=[],this.lightCookieIntId=[],this.lightCookieMatrixId=[],this.lightCookieOffsetId=[],this.shadowMatrixPaletteId=[],this.shadowCascadeDistancesId=[],this.shadowCascadeCountId=[],this.screenSizeId=s.resolve("uScreenSize"),this._screenSize=new Float32Array(4),this.fogColor=new Float32Array(3),this.ambientColor=new Float32Array(3)}destroy(){super.destroy()}dispatchGlobalLights(t){if(this.ambientColor[0]=t.ambientLight.r,this.ambientColor[1]=t.ambientLight.g,this.ambientColor[2]=t.ambientLight.b,t.gammaCorrection)for(let t=0;t<3;t++)this.ambientColor[t]=Math.pow(this.ambientColor[t],2.2);if(t.physicalUnits)for(let e=0;e<3;e++)this.ambientColor[e]*=t.ambientLuminance;this.ambientId.setValue(this.ambientColor),this.skyboxIntensityId.setValue(t.physicalUnits?t.skyboxLuminance:t.skyboxIntensity),this.cubeMapRotationMatrixId.setValue(t._skyboxRotationMat3.data)}_resolveLight(t,e){const s="light"+e;this.lightColorId[e]=t.resolve(s+"_color"),this.lightDir[e]=new Float32Array(3),this.lightDirId[e]=t.resolve(s+"_direction"),this.lightShadowMapId[e]=t.resolve(s+"_shadowMap"),this.lightShadowMatrixId[e]=t.resolve(s+"_shadowMatrix"),this.lightShadowParamsId[e]=t.resolve(s+"_shadowParams"),this.lightShadowIntensity[e]=t.resolve(s+"_shadowIntensity"),this.lightRadiusId[e]=t.resolve(s+"_radius"),this.lightPos[e]=new Float32Array(3),this.lightPosId[e]=t.resolve(s+"_position"),this.lightWidth[e]=new Float32Array(3),this.lightWidthId[e]=t.resolve(s+"_halfWidth"),this.lightHeight[e]=new Float32Array(3),this.lightHeightId[e]=t.resolve(s+"_halfHeight"),this.lightInAngleId[e]=t.resolve(s+"_innerConeAngle"),this.lightOutAngleId[e]=t.resolve(s+"_outerConeAngle"),this.lightCookieId[e]=t.resolve(s+"_cookie"),this.lightCookieIntId[e]=t.resolve(s+"_cookieIntensity"),this.lightCookieMatrixId[e]=t.resolve(s+"_cookieMatrix"),this.lightCookieOffsetId[e]=t.resolve(s+"_cookieOffset"),this.shadowMatrixPaletteId[e]=t.resolve(s+"_shadowMatrixPalette[0]"),this.shadowCascadeDistancesId[e]=t.resolve(s+"_shadowCascadeDistances[0]"),this.shadowCascadeCountId[e]=t.resolve(s+"_shadowCascadeCount")}setLTCDirectionalLight(e,s,i,a,o){this.lightPos[s][0]=a.x-i.x*o,this.lightPos[s][1]=a.y-i.y*o,this.lightPos[s][2]=a.z-i.z*o,this.lightPosId[s].setValue(this.lightPos[s]);const r=e.transformVector(new t(-.5,0,0));this.lightWidth[s][0]=r.x*o,this.lightWidth[s][1]=r.y*o,this.lightWidth[s][2]=r.z*o,this.lightWidthId[s].setValue(this.lightWidth[s]);const h=e.transformVector(new t(0,0,.5));this.lightHeight[s][0]=h.x*o,this.lightHeight[s][1]=h.y*o,this.lightHeight[s][2]=h.z*o,this.lightHeightId[s].setValue(this.lightHeight[s])}dispatchDirectLights(t,e,s,i){let a=0;const r=this.device.scope;for(let h=0;h<t.length;h++){if(!(t[h].mask&s))continue;const n=t[h],l=n._node.getWorldTransform();if(this.lightColorId[a]||this._resolveLight(r,a),this.lightColorId[a].setValue(e.gammaCorrection?n._linearFinalColor:n._finalColor),l.getY(n._direction).mulScalar(-1),n._direction.normalize(),this.lightDir[a][0]=n._direction.x,this.lightDir[a][1]=n._direction.y,this.lightDir[a][2]=n._direction.z,this.lightDirId[a].setValue(this.lightDir[a]),n.shape!==o&&this.setLTCDirectionalLight(l,a,n._direction,i._node.getPosition(),i.farClip),n.castShadows){const t=n.getRenderData(i,0),e=n._getUniformBiasValues(t);this.lightShadowMapId[a].setValue(t.shadowBuffer),this.lightShadowMatrixId[a].setValue(t.shadowMatrix.data),this.shadowMatrixPaletteId[a].setValue(n._shadowMatrixPalette),this.shadowCascadeDistancesId[a].setValue(n._shadowCascadeDistances),this.shadowCascadeCountId[a].setValue(n.numCascades),this.lightShadowIntensity[a].setValue(n.shadowIntensity);const s=n._shadowRenderParams;s.length=3,s[0]=n._shadowResolution,s[1]=e.normalBias,s[2]=e.bias,this.lightShadowParamsId[a].setValue(s)}a++}return a}setLTCPositionalLight(e,s){const i=e.transformVector(new t(-.5,0,0));this.lightWidth[s][0]=i.x,this.lightWidth[s][1]=i.y,this.lightWidth[s][2]=i.z,this.lightWidthId[s].setValue(this.lightWidth[s]);const a=e.transformVector(new t(0,0,.5));this.lightHeight[s][0]=a.x,this.lightHeight[s][1]=a.y,this.lightHeight[s][2]=a.z,this.lightHeightId[s].setValue(this.lightHeight[s])}dispatchOmniLight(t,e,s,i){const a=s._node.getWorldTransform();if(this.lightColorId[i]||this._resolveLight(e,i),this.lightRadiusId[i].setValue(s.attenuationEnd),this.lightColorId[i].setValue(t.gammaCorrection?s._linearFinalColor:s._finalColor),a.getTranslation(s._position),this.lightPos[i][0]=s._position.x,this.lightPos[i][1]=s._position.y,this.lightPos[i][2]=s._position.z,this.lightPosId[i].setValue(this.lightPos[i]),s.shape!==o&&this.setLTCPositionalLight(a,i),s.castShadows){const t=s.getRenderData(null,0);this.lightShadowMapId[i].setValue(t.shadowBuffer);const e=s._getUniformBiasValues(t),a=s._shadowRenderParams;a.length=4,a[0]=s._shadowResolution,a[1]=e.normalBias,a[2]=e.bias,a[3]=1/s.attenuationEnd,this.lightShadowParamsId[i].setValue(a),this.lightShadowIntensity[i].setValue(s.shadowIntensity)}s._cookie&&(this.lightCookieId[i].setValue(s._cookie),this.lightShadowMatrixId[i].setValue(a.data),this.lightCookieIntId[i].setValue(s.cookieIntensity))}dispatchSpotLight(t,e,s,i){const a=s._node.getWorldTransform();if(this.lightColorId[i]||this._resolveLight(e,i),this.lightInAngleId[i].setValue(s._innerConeAngleCos),this.lightOutAngleId[i].setValue(s._outerConeAngleCos),this.lightRadiusId[i].setValue(s.attenuationEnd),this.lightColorId[i].setValue(t.gammaCorrection?s._linearFinalColor:s._finalColor),a.getTranslation(s._position),this.lightPos[i][0]=s._position.x,this.lightPos[i][1]=s._position.y,this.lightPos[i][2]=s._position.z,this.lightPosId[i].setValue(this.lightPos[i]),s.shape!==o&&this.setLTCPositionalLight(a,i),a.getY(s._direction).mulScalar(-1),s._direction.normalize(),this.lightDir[i][0]=s._direction.x,this.lightDir[i][1]=s._direction.y,this.lightDir[i][2]=s._direction.z,this.lightDirId[i].setValue(this.lightDir[i]),s.castShadows){const t=s.getRenderData(null,0);this.lightShadowMapId[i].setValue(t.shadowBuffer),this.lightShadowMatrixId[i].setValue(t.shadowMatrix.data);const e=s._getUniformBiasValues(t),a=s._shadowRenderParams;a.length=4,a[0]=s._shadowResolution,a[1]=e.normalBias,a[2]=e.bias,a[3]=1/s.attenuationEnd,this.lightShadowParamsId[i].setValue(a),this.lightShadowIntensity[i].setValue(s.shadowIntensity)}if(s._cookie){if(!s.castShadows){const t=p.evalSpotCookieMatrix(s);this.lightShadowMatrixId[i].setValue(t.data)}this.lightCookieId[i].setValue(s._cookie),this.lightCookieIntId[i].setValue(s.cookieIntensity),s._cookieTransform&&(s._cookieTransformUniform[0]=s._cookieTransform.x,s._cookieTransformUniform[1]=s._cookieTransform.y,s._cookieTransformUniform[2]=s._cookieTransform.z,s._cookieTransformUniform[3]=s._cookieTransform.w,this.lightCookieMatrixId[i].setValue(s._cookieTransformUniform),s._cookieOffsetUniform[0]=s._cookieOffset.x,s._cookieOffsetUniform[1]=s._cookieOffset.y,this.lightCookieOffsetId[i].setValue(s._cookieOffsetUniform))}}dispatchLocalLights(t,e,s,i,a){let o=i;const n=this.device.scope,l=t[r],d=l.length;for(let t=0;t<d;t++){const i=l[t];i.mask&s&&(i.isStatic||(this.dispatchOmniLight(e,n,i,o),o++))}let c=0;if(a){let t=a[c];for(;t&&t._type===r;)this.dispatchOmniLight(e,n,t,o),o++,c++,t=a[c]}const g=t[h],f=g.length;for(let t=0;t<f;t++){const i=g[t];i.mask&s&&(i.isStatic||(this.dispatchSpotLight(e,n,i,o),o++))}if(a){let t=a[c];for(;t&&t._type===h;)this.dispatchSpotLight(e,n,t,o),o++,c++,t=a[c]}}renderForwardPrepareMaterials(t,e,s,i,a,o,r){const h=(t,e,s)=>{w.drawCalls.push(t),w.isNewMaterial.push(e),w.lightMaskChanged.push(s)};w.drawCalls.length=0,w.isNewMaterial.length=0,w.lightMaskChanged.length=0;const n=this.device,l=this.scene,d=o?o._lightHash:0;let c,g,f,p=null;for(let t=0;t<s;t++){const s=e[t];if(!a||!s.mask||a&s.mask)if(s.command)h(s,!1,!1);else{s.ensureMaterial(n);const t=s.material,e=s._shaderDefs,a=s.mask;if(t&&t===p&&e!==c&&(p=null),(s.isStatic||g)&&(p=null),t!==p&&(this._materialSwitches++,t._scene=l,t.dirty&&(t.updateUniforms(n,l),t.dirty=!1),t._dirtyBlend&&(l.layers._dirtyBlend=!0)),!s._shader[r]||s._shaderDefs!==e||s._lightHash!==d){if(s.isStatic)s.updatePassShader(l,r,s._staticLightList,i,this.viewUniformFormat,this.viewBindGroupFormat);else{const a=r+"_"+e+"_"+d;s._shader[r]=t.variants[a],s._shader[r]||(s.updatePassShader(l,r,null,i,this.viewUniformFormat,this.viewBindGroupFormat),t.variants[a]=s._shader[r])}s._lightHash=d}h(s,t!==p,!p||a!==f),p=t,c=e,f=a,g=s.isStatic}}return null==n.endShaderBatch||n.endShaderBatch(),w}renderForwardInternal(t,e,a,o,r,h){const l=this.device,d=this.scene,c=1<<o;let g=!1;const f=e.drawCalls.length;for(let p=0;p<f;p++){const u=e.drawCalls[p];if(u.command)u.command();else{const m=e.isNewMaterial[p],_=e.lightMaskChanged[p],w=u.material;u._shaderDefs;const C=u.mask;if(m){const e=u._shader[o];if(!e.failed&&l.setShader(e),g=e.failed,g)break;if(w.setParameters(l),_){const e=this.dispatchDirectLights(a[n],d,C,t);this.dispatchLocalLights(a,d,C,e,u._staticLightList)}this.alphaTestId.setValue(w.alphaTest),l.setBlendState(w.blendState),l.setDepthState(w.depthState),l.setAlphaToCoverage(w.alphaToCoverage),w.depthBias||w.slopeDepthBias?(l.setDepthBias(!0),l.setDepthBiasValues(w.depthBias,w.slopeDepthBias)):l.setDepthBias(!1)}this.setCullMode(t._cullFaces,h,u);const I=u.stencilFront||w.stencilFront,S=u.stencilBack||w.stencilBack;I||S?(l.setStencilTest(!0),I===S?(l.setStencilFunc(I.func,I.ref,I.readMask),l.setStencilOperation(I.fail,I.zfail,I.zpass,I.writeMask)):(I?(l.setStencilFuncFront(I.func,I.ref,I.readMask),l.setStencilOperationFront(I.fail,I.zfail,I.zpass,I.writeMask)):(l.setStencilFuncFront(s,0,255),l.setStencilOperationFront(i,i,i,255)),S?(l.setStencilFuncBack(S.func,S.ref,S.readMask),l.setStencilOperationBack(S.fail,S.zfail,S.zpass,S.writeMask)):(l.setStencilFuncBack(s,0,255),l.setStencilOperationBack(i,i,i,255)))):l.setStencilTest(!1);const P=u.mesh;u.setParameters(l,c),this.setVertexBuffers(l,P),this.setMorphing(l,u.morphInstance),this.setSkinning(l,u),this.setupMeshUniformBuffers(u,o);const v=u.renderStyle;if(l.setIndexBuffer(P.indexBuffer[v]),r&&r(u,p),t.xr&&t.xr.session&&t.xr.views.length){const e=t.xr.views;for(let t=0;t<e.length;t++){const s=e[t];l.setViewport(s.viewport.x,s.viewport.y,s.viewport.z,s.viewport.w),this.projId.setValue(s.projMat.data),this.projSkyboxId.setValue(s.projMat.data),this.viewId.setValue(s.viewOffMat.data),this.viewInvId.setValue(s.viewInvOffMat.data),this.viewId3.setValue(s.viewMat3.data),this.viewProjId.setValue(s.projViewOffMat.data),this.viewPosId.setValue(s.position),0===t?this.drawInstance(l,u,P,v,!0):this.drawInstance2(l,u,P,v),this._forwardDrawCalls++}}else this.drawInstance(l,u,P,v,!0),this._forwardDrawCalls++;p<f-1&&!e.isNewMaterial[p+1]&&w.setParameters(l,u.parameters)}}}renderForward(t,e,s,i,a,o,r,h,n){const l=this.renderForwardPrepareMaterials(t,e,s,i,o,h,a);this.renderForwardInternal(t,l,i,a,r,n),w.length=0}setSceneConstants(){const t=this.scene;if(this.dispatchGlobalLights(t),t.fog!==l){if(this.fogColor[0]=t.fogColor.r,this.fogColor[1]=t.fogColor.g,this.fogColor[2]=t.fogColor.b,t.gammaCorrection)for(let t=0;t<3;t++)this.fogColor[t]=Math.pow(this.fogColor[t],2.2);this.fogColorId.setValue(this.fogColor),t.fog===d?(this.fogStartId.setValue(t.fogStart),this.fogEndId.setValue(t.fogEnd)):this.fogDensityId.setValue(t.fogDensity)}const e=this.device;this._screenSize[0]=e.width,this._screenSize[1]=e.height,this._screenSize[2]=1/e.width,this._screenSize[3]=1/e.height,this.screenSizeId.setValue(this._screenSize)}updateLightStats(t,e){}buildFrameGraph(t,e){const s=this.scene.clusteredLightingEnabled;if(t.reset(),this.update(e),s){{const s=new a(this.device,(()=>{this.scene.lighting.cookiesEnabled&&(this.renderCookies(e._splitLights[h]),this.renderCookies(e._splitLights[r]))}));s.requiresCubemaps=!1,t.addRenderPass(s)}{const s=new a(this.device);if(s.requiresCubemaps=!1,t.addRenderPass(s),this.scene.lighting.shadowsEnabled){const t=e._splitLights;this._shadowRendererLocal.prepareClusteredRenderPass(s,t[h],t[r])}s.after=()=>{this.updateClusters(e)}}}else{const s=e._splitLights;this._shadowRendererLocal.buildNonClusteredRenderPasses(t,s[h],s[r])}let i=0,o=!0,n=null;const l=e._renderActions;for(let s=i;s<l.length;s++){const r=l[s],h=e.layerList[r.layerIndex],d=h.cameras[r.cameraIndex];if(!r.isLayerEnabled(e))continue;const g=h.id===c&&(d.renderSceneColorMap||d.renderSceneDepthMap);r.hasDirectionalShadowLights&&d&&this._shadowRendererDirectional.buildFrameGraph(t,r,d),o&&(o=!1,i=s,n=r.renderTarget);let f=s+1;for(;l[f]&&!l[f].isLayerEnabled(e);)f++;const p=l[f],u=!!p&&e.layerList[p.layerIndex].id===c&&(d.renderSceneColorMap||d.renderSceneDepthMap);if(!p||p.renderTarget!==n||p.hasDirectionalShadowLights||u||g){if(this.addMainRenderPass(t,e,n,i,s,g),r.triggerPostprocess&&null!=d&&d.onPostprocessing){const s=new a(this.device,(()=>{this.renderPassPostprocessing(r,e)}));s.requiresCubemaps=!1,t.addRenderPass(s)}o=!0}}}addMainRenderPass(t,e,s,i,o,r){const h={start:i,end:o},n=new a(this.device,(()=>{this.renderPassRenderActions(e,h)})),l=e._renderActions,d=l[i],c=l[o],g=e.layerList[d.layerIndex].cameras[d.cameraIndex];g&&(d.firstCameraUse&&g.onPreRender&&(n.before=()=>{g.onPreRender()}),c.lastCameraUse&&g.onPostRender&&(n.after=()=>{g.onPostRender()}));const f=r&&u.requiresRenderPass(this.device,g);(!r||f)&&(n.init(s),n.fullSizeClearRect=g.camera.fullSizeClearRect,f?(n.setClearColor(_),n.setClearDepth(1)):n.fullSizeClearRect&&(d.clearColor&&n.setClearColor(g.camera.clearColor),d.clearDepth&&n.setClearDepth(g.camera.clearDepth),d.clearStencil&&n.setClearStencil(g.camera.clearStencil))),t.addRenderPass(n)}update(t){this.frameUpdate(),this.shadowRenderer.frameUpdate();const e=this.scene.clusteredLightingEnabled;this.scene._updateSky(this.device);const s=this.updateLayerComposition(t,e),i=0!=(s&g);this.updateLightStats(t,s),this.beginFrame(t,i),this.setSceneConstants(),this.cullComposition(t),this.gpuUpdate(t._meshInstances)}renderPassPostprocessing(t,e){e.layerList[t.layerIndex].cameras[t.cameraIndex].onPostprocessing()}renderPassRenderActions(t,e){const s=t._renderActions;for(let i=e.start;i<=e.end;i++)this.renderRenderAction(t,s[i],i===e.start)}renderRenderAction(t,e,s){const i=this.scene.clusteredLightingEnabled,a=this.device,o=e.layerIndex,r=t.layerList[o],h=t.subLayerList[o],n=e.cameraIndex,l=r.cameras[n];if(e.isLayerEnabled(t)){if(!h&&r.onPreRenderOpaque?r.onPreRenderOpaque(n):h&&r.onPreRenderTransparent&&r.onPreRenderTransparent(n),r._preRenderCalledForCameras&1<<n||(r.onPreRender&&r.onPreRender(n),r._preRenderCalledForCameras|=1<<n),l){var d;this.setupViewport(l.camera,e.renderTarget),s&&l.camera.fullSizeClearRect||this.clear(l.camera,e.clearColor,e.clearDepth,e.clearStencil),r._sortVisible(h,l.camera.node,n);const t=r.instances,o=h?t.visibleTransparent[n]:t.visibleOpaque[n];this.scene.immediate.onPreRenderLayer(r,o,h),i&&e.lightClusters&&(e.lightClusters.activate(this.lightTextureAtlas),this.clustersDebugRendered||this.scene.lighting.debugLayer!==r.id||(this.clustersDebugRendered=!0)),this.scene._activeCamera=l.camera;const c=this.setCameraUniforms(l.camera,e.renderTarget);a.supportsUniformBuffers&&this.setupViewUniformBuffers(e.viewBindGroups,this.viewUniformFormat,this.viewBindGroupFormat,c);const g=!!(l.camera._flipFaces^(null==e||null==(d=e.renderTarget)?void 0:d.flipY)),f=this._forwardDrawCalls;this.renderForward(l.camera,o.list,o.length,r._splitLights,r.shaderPass,r.cullingMask,r.onDrawCall,r,g),r._forwardDrawCalls+=this._forwardDrawCalls-f,a.setBlendState(m.DEFAULT),a.setStencilTest(!1),a.setAlphaToCoverage(!1),a.setDepthBias(!1)}!h&&r.onPostRenderOpaque?r.onPostRenderOpaque(n):h&&r.onPostRenderTransparent&&r.onPostRenderTransparent(n),!r.onPostRender||r._postRenderCalledForCameras&1<<n||(r._postRenderCounter&=~(h?2:1),0===r._postRenderCounter&&(r.onPostRender(n),r._postRenderCalledForCameras|=1<<n,r._postRenderCounter=r._postRenderCounterMax))}}}export{C as ForwardRenderer};
