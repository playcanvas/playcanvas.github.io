class e{constructor(){this.renderPasses=[],this.renderTargetMap=new Map}addRenderPass(e){this.renderPasses.push(e)}reset(){this.renderPasses.length=0}compile(){const e=this.renderTargetMap,r=this.renderPasses;for(let s=0;s<r.length;s++){const t=r[s],l=t.renderTarget;if(void 0!==l){const r=e.get(l);r&&(t.colorOps.clear||(r.colorOps.store=!0),t.depthStencilOps.clearDepth||(r.depthStencilOps.storeDepth=!0),t.depthStencilOps.clearStencil||(r.depthStencilOps.storeStencil=!0)),e.set(l,t)}}let s=null,t=null;for(let e=0;e<r.length;e++){const l=r[e],o=l.renderTarget,n=null==o?void 0:o.colorBuffer;null!=n&&n.cubemap?(s===n&&(t.colorOps.mipmaps=!1),s=o.colorBuffer,t=l):l.requiresCubemaps&&(s=null,t=null)}e.forEach(((e,r)=>{null===r&&(e.colorOps.store=!0,e.colorOps.resolve=!1,e.colorOps.mipmaps=!1)})),e.clear()}render(e){this.compile();const r=this.renderPasses;for(let e=0;e<r.length;e++)r[e].render()}}export{e as FrameGraph};
