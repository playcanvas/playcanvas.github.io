import{Vec2 as t}from"../math/vec2.js";import{Vec3 as e}from"../math/vec3.js";import"../core/tracing.js";import{SEMANTIC_TANGENT as s,SEMANTIC_BLENDINDICES as n,TYPE_UINT8 as a,SEMANTIC_BLENDWEIGHT as o}from"../graphics/constants.js";import{Mesh as i}from"./mesh.js";const h=[];function u(t,s){const n=s.length/3,a=t.length/3,o=new e,i=new e,h=new e,u=new e,c=new e,r=new e,l=[];for(let e=0;e<t.length;e++)l[e]=0;for(let e=0;e<n;e++){const n=s[3*e],a=s[3*e+1],d=s[3*e+2];o.set(t[3*n],t[3*n+1],t[3*n+2]),i.set(t[3*a],t[3*a+1],t[3*a+2]),h.set(t[3*d],t[3*d+1],t[3*d+2]),u.sub2(i,o),c.sub2(h,o),r.cross(u,c).normalize(),l[3*n]+=r.x,l[3*n+1]+=r.y,l[3*n+2]+=r.z,l[3*a]+=r.x,l[3*a+1]+=r.y,l[3*a+2]+=r.z,l[3*d]+=r.x,l[3*d+1]+=r.y,l[3*d+2]+=r.z}for(let t=0;t<a;t++){const e=l[3*t],s=l[3*t+1],n=l[3*t+2],a=1/Math.sqrt(e*e+s*s+n*n);l[3*t]*=a,l[3*t+1]*=a,l[3*t+2]*=a}return l}function c(s,n,a,o){const i=o.length/3,h=s.length/3,u=new e,c=new e,r=new e,l=new t,d=new t,g=new t,p=new e,v=new e,M=new Float32Array(3*h),f=new Float32Array(3*h),m=[];for(let t=0;t<i;t++){const e=o[3*t],n=o[3*t+1],i=o[3*t+2];u.set(s[3*e],s[3*e+1],s[3*e+2]),c.set(s[3*n],s[3*n+1],s[3*n+2]),r.set(s[3*i],s[3*i+1],s[3*i+2]),l.set(a[2*e],a[2*e+1]),d.set(a[2*n],a[2*n+1]),g.set(a[2*i],a[2*i+1]);const h=c.x-u.x,m=r.x-u.x,w=c.y-u.y,x=r.y-u.y,y=c.z-u.z,I=r.z-u.z,z=d.x-l.x,P=g.x-l.x,S=d.y-l.y,b=g.y-l.y,R=z*b-P*S;if(0===R)p.set(0,1,0),v.set(1,0,0);else{const t=1/R;p.set((b*h-S*m)*t,(b*w-S*x)*t,(b*y-S*I)*t),v.set((z*m-P*h)*t,(z*x-P*w)*t,(z*I-P*y)*t)}M[3*e+0]+=p.x,M[3*e+1]+=p.y,M[3*e+2]+=p.z,M[3*n+0]+=p.x,M[3*n+1]+=p.y,M[3*n+2]+=p.z,M[3*i+0]+=p.x,M[3*i+1]+=p.y,M[3*i+2]+=p.z,f[3*e+0]+=v.x,f[3*e+1]+=v.y,f[3*e+2]+=v.z,f[3*n+0]+=v.x,f[3*n+1]+=v.y,f[3*n+2]+=v.z,f[3*i+0]+=v.x,f[3*i+1]+=v.y,f[3*i+2]+=v.z}const w=new e,x=new e,y=new e,I=new e;for(let t=0;t<h;t++){y.set(n[3*t],n[3*t+1],n[3*t+2]),w.set(M[3*t],M[3*t+1],M[3*t+2]),x.set(f[3*t],f[3*t+1],f[3*t+2]);const e=y.dot(w);I.copy(y).mulScalar(e),I.sub2(w,I).normalize(),m[4*t]=I.x,m[4*t+1]=I.y,m[4*t+2]=I.z,I.cross(y,w),m[4*t+3]=I.dot(x)<0?-1:1}return m}function r(t,e,h){const u=new i(t);return u.setPositions(e),h&&(h.normals&&u.setNormals(h.normals),h.tangents&&u.setVertexStream(s,h.tangents,4),h.colors&&u.setColors32(h.colors),h.uvs&&u.setUvs(0,h.uvs),h.uvs1&&u.setUvs(1,h.uvs1),h.blendIndices&&u.setVertexStream(n,h.blendIndices,4,h.blendIndices.length/4,a),h.blendWeights&&u.setVertexStream(o,h.blendWeights,4),h.indices&&u.setIndices(h.indices)),u.update(),u}function l(t,e){const s=e&&void 0!==e.tubeRadius?e.tubeRadius:.2,n=e&&void 0!==e.ringRadius?e.ringRadius:.3,a=e&&void 0!==e.segments?e.segments:30,o=e&&void 0!==e.sides?e.sides:20,i=!(!e||void 0===e.calculateTangents)&&e.calculateTangents,h=[],u=[],l=[],d=[];for(let t=0;t<=o;t++)for(let e=0;e<=a;e++){const i=Math.cos(2*Math.PI*e/a)*(n+s*Math.cos(2*Math.PI*t/o)),c=Math.sin(2*Math.PI*t/o)*s,r=Math.sin(2*Math.PI*e/a)*(n+s*Math.cos(2*Math.PI*t/o)),g=Math.cos(2*Math.PI*e/a)*Math.cos(2*Math.PI*t/o),p=Math.sin(2*Math.PI*t/o),v=Math.sin(2*Math.PI*e/a)*Math.cos(2*Math.PI*t/o),M=t/o,f=1-e/a;if(h.push(i,c,r),u.push(g,p,v),l.push(M,1-f),t<o&&e<a){const s=t*(a+1)+e,n=(t+1)*(a+1)+e,o=t*(a+1)+(e+1),i=(t+1)*(a+1)+(e+1);d.push(s,n,o),d.push(n,i,o)}}const g={normals:u,uvs:l,uvs1:l,indices:d};return i&&(g.tangents=c(h,u,l,d)),r(t,h,g)}function d(t,s,n,a,o,i){const h=new e,u=new e,c=new e,r=new e,l=new e,d=new e,g=[],p=[],v=[],M=[],f=[];let m;if(n>0)for(let e=0;e<=a;e++)for(let i=0;i<=o;i++){const m=i/o*2*Math.PI-Math.PI,w=Math.sin(m),x=Math.cos(m);l.set(w*t,-n/2,x*t),r.set(w*s,n/2,x*s),h.lerp(l,r,e/a),u.sub2(r,l).normalize(),d.set(x,0,-w),c.cross(d,u).normalize(),g.push(h.x,h.y,h.z),p.push(c.x,c.y,c.z);let y=i/o,I=e/a;v.push(y,1-I);const z=I;if(I=y,y=z,y=.875*y+.0625,I=.875*I+.0625,y/=3,M.push(y,1-I),e<a&&i<o){const t=e*(o+1)+i,s=e*(o+1)+(i+1),n=(e+1)*(o+1)+i,a=(e+1)*(o+1)+(i+1);f.push(t,s,n),f.push(s,a,n)}}if(i){const t=Math.floor(o/2),e=o,i=n/2;for(let n=0;n<=t;n++){const a=n*Math.PI*.5/t,o=Math.sin(a),h=Math.cos(a);for(let a=0;a<=e;a++){const u=2*a*Math.PI/e-Math.PI/2,c=Math.sin(u),r=Math.cos(u)*o,l=h,d=c*o;let f=1-a/e,m=1-n/t;g.push(r*s,l*s+i,d*s),p.push(r,l,d),v.push(f,1-m),f=.875*f+.0625,m=.875*m+.0625,f/=3,m/=3,f+=1/3,M.push(f,1-m)}}m=(a+1)*(o+1);for(let s=0;s<t;++s)for(let t=0;t<e;++t){const n=s*(e+1)+t,a=n+e+1;f.push(m+n+1,m+a,m+n),f.push(m+n+1,m+a+1,m+a)}for(let n=0;n<=t;n++){const a=.5*Math.PI+n*Math.PI*.5/t,o=Math.sin(a),h=Math.cos(a);for(let a=0;a<=e;a++){const u=2*a*Math.PI/e-Math.PI/2,c=Math.sin(u),r=Math.cos(u)*o,l=h,d=c*o;let f=1-a/e,m=1-n/t;g.push(r*s,l*s-i,d*s),p.push(r,l,d),v.push(f,1-m),f=.875*f+.0625,m=.875*m+.0625,f/=3,m/=3,f+=2/3,M.push(f,1-m)}}m=(a+1)*(o+1)+(e+1)*(t+1);for(let s=0;s<t;++s)for(let t=0;t<e;++t){const n=s*(e+1)+t,a=n+e+1;f.push(m+n+1,m+a,m+n),f.push(m+n+1,m+a+1,m+a)}}else{if(m=(a+1)*(o+1),t>0)for(let e=0;e<o;e++){const s=e/o*2*Math.PI,a=Math.sin(s),i=-n/2,h=Math.cos(s);let u=1-(a+1)/2,c=(h+1)/2;g.push(a*t,i,h*t),p.push(0,-1,0),v.push(u,1-c),u=.875*u+.0625,c=.875*c+.0625,u/=3,c/=3,u+=1/3,M.push(u,1-c),e>1&&f.push(m,m+e,m+e-1)}if(m+=o,s>0)for(let t=0;t<o;t++){const e=t/o*2*Math.PI,a=Math.sin(e),i=n/2,h=Math.cos(e);let u=1-(a+1)/2,c=(h+1)/2;g.push(a*s,i,h*s),p.push(0,1,0),v.push(u,1-c),u=.875*u+.0625,c=.875*c+.0625,u/=3,c/=3,u+=2/3,M.push(u,1-c),t>1&&f.push(m,m+t-1,m+t)}}return{positions:g,normals:p,uvs:v,uvs1:M,indices:f}}function g(t,e){let s=e&&(e.radius||e.baseRadius);s=void 0!==s?s:.5;const n=e&&void 0!==e.height?e.height:1,a=e&&void 0!==e.heightSegments?e.heightSegments:5,o=e&&void 0!==e.capSegments?e.capSegments:20,i=!(!e||void 0===e.calculateTangents)&&e.calculateTangents,h=d(s,s,n,a,o,!1);return i&&(h.tangents=c(h.positions,h.normals,h.uvs,h.indices)),r(t,h.positions,h)}function p(t,e){const s=e&&void 0!==e.radius?e.radius:.3,n=e&&void 0!==e.height?e.height:1,a=e&&void 0!==e.heightSegments?e.heightSegments:1,o=e&&void 0!==e.sides?e.sides:20,i=!(!e||void 0===e.calculateTangents)&&e.calculateTangents,h=d(s,s,n-2*s,a,o,!0);return i&&(h.tangents=c(h.positions,h.normals,h.uvs,h.indices)),r(t,h.positions,h)}function v(t,e){const s=e&&void 0!==e.baseRadius?e.baseRadius:.5,n=e&&void 0!==e.peakRadius?e.peakRadius:0,a=e&&void 0!==e.height?e.height:1,o=e&&void 0!==e.heightSegments?e.heightSegments:5,i=e&&void 0!==e.capSegments?e.capSegments:18,h=!(!e||void 0===e.calculateTangents)&&e.calculateTangents,u=d(s,n,a,o,i,!1);return h&&(u.tangents=c(u.positions,u.normals,u.uvs,u.indices)),r(t,u.positions,u)}function M(t,e){const s=e&&void 0!==e.radius?e.radius:.5,n=e&&void 0!==e.latitudeBands?e.latitudeBands:16,a=e&&void 0!==e.longitudeBands?e.longitudeBands:16,o=!(!e||void 0===e.calculateTangents)&&e.calculateTangents,i=[],h=[],u=[],l=[];for(let t=0;t<=n;t++){const e=t*Math.PI/n,o=Math.sin(e),c=Math.cos(e);for(let e=0;e<=a;e++){const r=2*e*Math.PI/a-Math.PI/2,l=Math.sin(r),d=Math.cos(r)*o,g=c,p=l*o,v=1-e/a,M=1-t/n;i.push(d*s,g*s,p*s),h.push(d,g,p),u.push(v,1-M)}}for(let t=0;t<n;++t)for(let e=0;e<a;++e){const s=t*(a+1)+e,n=s+a+1;l.push(s+1,n,s),l.push(s+1,n+1,n)}const d={normals:h,uvs:u,uvs1:u,indices:l};return o&&(d.tangents=c(i,h,u,l)),r(t,i,d)}function f(e,s){const n=s&&void 0!==s.halfExtents?s.halfExtents:new t(.5,.5),a=s&&void 0!==s.widthSegments?s.widthSegments:5,o=s&&void 0!==s.lengthSegments?s.lengthSegments:5,i=!(!s||void 0===s.calculateTangents)&&s.calculateTangents,h=[],u=[],l=[],d=[];let g=0;for(let t=0;t<=a;t++)for(let e=0;e<=o;e++){const s=-n.x+2*n.x*t/a,i=0,c=-(-n.y+2*n.y*e/o),r=t/a,p=e/o;h.push(s,i,c),u.push(0,1,0),l.push(r,1-p),t<a&&e<o&&(d.push(g+o+1,g+1,g),d.push(g+o+1,g+o+2,g+1)),g++}const p={normals:u,uvs:l,uvs1:l,indices:d};return i&&(p.tangents=c(h,u,l,d)),r(e,h,p)}function m(t,s){const n=s&&void 0!==s.halfExtents?s.halfExtents:new e(.5,.5,.5),a=s&&void 0!==s.widthSegments?s.widthSegments:1,o=s&&void 0!==s.lengthSegments?s.lengthSegments:1,i=s&&void 0!==s.heightSegments?s.heightSegments:1,h=!(!s||void 0===s.calculateTangents)&&s.calculateTangents,u=[new e(-n.x,-n.y,n.z),new e(n.x,-n.y,n.z),new e(n.x,n.y,n.z),new e(-n.x,n.y,n.z),new e(n.x,-n.y,-n.z),new e(-n.x,-n.y,-n.z),new e(-n.x,n.y,-n.z),new e(n.x,n.y,-n.z)],l=[[0,1,3],[4,5,7],[3,2,6],[1,0,4],[1,4,2],[5,0,6]],d=[[0,0,1],[0,0,-1],[0,1,0],[0,-1,0],[1,0,0],[-1,0,0]],g=1,p=2,v=3,M=4,f=5,m=[],w=[],x=[],y=[],I=[];let z=0;const P=(t,s,n)=>{const a=new e,o=new e,i=new e,h=new e;for(let e=0;e<=s;e++)for(let c=0;c<=n;c++){a.lerp(u[l[t][0]],u[l[t][1]],e/s),o.lerp(u[l[t][0]],u[l[t][2]],c/n),i.sub2(o,u[l[t][0]]),h.add2(a,i);let r=e/s,g=c/n;m.push(h.x,h.y,h.z),w.push(d[t][0],d[t][1],d[t][2]),x.push(r,1-g),r=.875*r+.0625,g=.875*g+.0625,r/=3,g/=3,r+=t%3/3,g+=Math.floor(t/3)/3,y.push(r,1-g),e<s&&c<n&&(I.push(z+n+1,z+1,z),I.push(z+n+1,z+n+2,z+1)),z++}};P(0,a,i),P(g,a,i),P(p,a,o),P(v,a,o),P(M,o,i),P(f,o,i);const S={normals:w,uvs:x,uvs1:y,indices:I};return h&&(S.tangents=c(m,w,x,I)),r(t,m,S)}function w(s,n){let a=null;for(let t=0;t<h.length;t++)h[t].type===n&&h[t].device===s&&(a=h[t].primData);if(!a){let o,i;switch(n){case"box":o=m(s,{halfExtents:new e(.5,.5,.5)}),i={x:2,y:2,z:2,uv:2/3};break;case"capsule":o=p(s,{radius:.5,height:2}),i={x:2*Math.PI,y:Math.PI,z:2*Math.PI,uv:1/3+1/3/3*2};break;case"cone":o=v(s,{baseRadius:.5,peakRadius:0,height:1}),i={x:2.54,y:2.54,z:2.54,uv:1/3+1/3/3};break;case"cylinder":o=g(s,{radius:.5,height:1}),i={x:Math.PI,y:1.58,z:Math.PI,uv:1/3+1/3/3*2};break;case"plane":o=f(s,{halfExtents:new t(.5,.5),widthSegments:1,lengthSegments:1}),i={x:0,y:1,z:0,uv:1};break;case"sphere":o=M(s,{radius:.5}),i={x:Math.PI,y:Math.PI,z:Math.PI,uv:1};break;case"torus":o=l(s,{tubeRadius:.2,ringRadius:.3}),i={x:.5*Math.PI*.5-.1*Math.PI*.1,y:.4,z:.4,uv:1};break;default:throw new Error("Invalid primitive type: "+n)}o.incRefCount(),a={mesh:o,area:i},h.push({type:n,device:s,primData:a})}return a}export{u as calculateNormals,c as calculateTangents,m as createBox,p as createCapsule,v as createCone,g as createCylinder,r as createMesh,f as createPlane,M as createSphere,l as createTorus,w as getShapePrimitive};
