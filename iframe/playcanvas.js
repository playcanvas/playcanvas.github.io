/**
 * @license
 * PlayCanvas Engine v1.67.0 revision ea736291a (RELEASE)
 * Copyright 2011-2023 PlayCanvas Ltd. All rights reserved.
 */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.pc = {}));
})(this, (function (exports) { 'use strict';

	function defineProtoFunc(cls, name, func) {
		if (!cls.prototype[name]) {
			Object.defineProperty(cls.prototype, name, {
				value: func,
				configurable: true,
				enumerable: false,
				writable: true
			});
		}
	}

	defineProtoFunc(Array, 'fill', function (value) {
		if (this == null) {
			throw new TypeError('this is null or not defined');
		}
		var O = Object(this);
		var len = O.length >>> 0;
		var start = arguments[1];
		var relativeStart = start >> 0;
		var k = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);
		var end = arguments[2];
		var relativeEnd = end === undefined ? len : end >> 0;
		var finalValue = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len);
		while (k < finalValue) {
			O[k] = value;
			k++;
		}
		return O;
	});

	defineProtoFunc(Array, 'find', function (predicate) {
		if (this == null) {
			throw TypeError('"this" is null or not defined');
		}
		var o = Object(this);
		var len = o.length >>> 0;
		if (typeof predicate !== 'function') {
			throw TypeError('predicate must be a function');
		}
		var thisArg = arguments[1];
		var k = 0;
		while (k < len) {
			var kValue = o[k];
			if (predicate.call(thisArg, kValue, k, o)) {
				return kValue;
			}
			k++;
		}
		return undefined;
	});

	defineProtoFunc(Array, 'findIndex', function (predicate) {
		if (this == null) {
			throw new TypeError('"this" is null or not defined');
		}
		var o = Object(this);
		var len = o.length >>> 0;
		if (typeof predicate !== 'function') {
			throw new TypeError('predicate must be a function');
		}
		var thisArg = arguments[1];
		var k = 0;
		while (k < len) {
			var kValue = o[k];
			if (predicate.call(thisArg, kValue, k, o)) {
				return k;
			}
			k++;
		}
		return -1;
	});

	Math.log2 = Math.log2 || function (x) {
		return Math.log(x) * Math.LOG2E;
	};

	if (!Math.sign) {
		Math.sign = function (x) {
			return (x > 0) - (x < 0) || +x;
		};
	}

	if (Number.isFinite === undefined) Number.isFinite = function (value) {
		return typeof value === 'number' && isFinite(value);
	};

	if (typeof Object.assign != 'function') {
		Object.defineProperty(Object, "assign", {
			value: function assign(target, varArgs) {

				if (target == null) {
					throw new TypeError('Cannot convert undefined or null to object');
				}
				var to = Object(target);
				for (var index = 1; index < arguments.length; index++) {
					var nextSource = arguments[index];
					if (nextSource != null) {
						for (var nextKey in nextSource) {
							if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
								to[nextKey] = nextSource[nextKey];
							}
						}
					}
				}
				return to;
			},
			writable: true,
			configurable: true
		});
	}

	Object.values = Object.values || function (object) {
		return Object.keys(object).map(function (key) {
			return object[key];
		});
	};

	(function () {
		if (typeof navigator === 'undefined' || typeof document === 'undefined') {
			return;
		}
		navigator.pointer = navigator.pointer || navigator.webkitPointer || navigator.mozPointer;
		var pointerlockchange = function pointerlockchange() {
			var e = document.createEvent('CustomEvent');
			e.initCustomEvent('pointerlockchange', true, false, null);
			document.dispatchEvent(e);
		};
		var pointerlockerror = function pointerlockerror() {
			var e = document.createEvent('CustomEvent');
			e.initCustomEvent('pointerlockerror', true, false, null);
			document.dispatchEvent(e);
		};
		document.addEventListener('webkitpointerlockchange', pointerlockchange, false);
		document.addEventListener('webkitpointerlocklost', pointerlockchange, false);
		document.addEventListener('mozpointerlockchange', pointerlockchange, false);
		document.addEventListener('mozpointerlocklost', pointerlockchange, false);
		document.addEventListener('webkitpointerlockerror', pointerlockerror, false);
		document.addEventListener('mozpointerlockerror', pointerlockerror, false);
		if (Element.prototype.mozRequestPointerLock) {
			Element.prototype.requestPointerLock = function () {
				this.mozRequestPointerLock();
			};
		} else {
			Element.prototype.requestPointerLock = Element.prototype.requestPointerLock || Element.prototype.webkitRequestPointerLock || Element.prototype.mozRequestPointerLock;
		}
		if (!Element.prototype.requestPointerLock && navigator.pointer) {
			Element.prototype.requestPointerLock = function () {
				var el = this;
				document.pointerLockElement = el;
				navigator.pointer.lock(el, pointerlockchange, pointerlockerror);
			};
		}
		document.exitPointerLock = document.exitPointerLock || document.webkitExitPointerLock || document.mozExitPointerLock;
		if (!document.exitPointerLock) {
			document.exitPointerLock = function () {
				if (navigator.pointer) {
					document.pointerLockElement = null;
					navigator.pointer.unlock();
				}
			};
		}
	})();

	defineProtoFunc(String, 'endsWith', function (search, this_len) {
		if (this_len === undefined || this_len > this.length) {
			this_len = this.length;
		}
		return this.substring(this_len - search.length, this_len) === search;
	});
	defineProtoFunc(String, 'includes', function (search, start) {

		if (typeof start !== 'number') {
			start = 0;
		}
		if (start + search.length > this.length) {
			return false;
		} else {
			return this.indexOf(search, start) !== -1;
		}
	});
	defineProtoFunc(String, 'startsWith', function (search, rawPos) {
		var pos = rawPos > 0 ? rawPos | 0 : 0;
		return this.substring(pos, pos + search.length) === search;
	});
	defineProtoFunc(String, 'trimEnd', function () {
		return this.replace(new RegExp(/[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]+/.source + '$', 'g'), '');
	});

	var typedArrays = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array];
	for (var _i = 0, _typedArrays = typedArrays; _i < _typedArrays.length; _i++) {
		var typedArray = _typedArrays[_i];
		defineProtoFunc(typedArray, "fill", Array.prototype.fill);
		defineProtoFunc(typedArray, "join", Array.prototype.join);
	}

	var glErrorShadow = {};
	function error(msg) {
		if (window.console && window.console.error) {
			window.console.error(msg);
		}
	}
	function log$1(msg) {
		if (window.console && window.console.log) {
			window.console.log(msg);
		}
	}
	function synthesizeGLError(err, opt_msg) {
		glErrorShadow[err] = true;
		if (opt_msg !== undefined) {
			error(opt_msg);
		}
	}
	function wrapGLError(gl) {
		var f = gl.getError;
		gl.getError = function () {
			var err;
			do {
				err = f.apply(gl);
				if (err != gl.NO_ERROR) {
					glErrorShadow[err] = true;
				}
			} while (err != gl.NO_ERROR);
			for (var err in glErrorShadow) {
				if (glErrorShadow[err]) {
					delete glErrorShadow[err];
					return parseInt(err);
				}
			}
			return gl.NO_ERROR;
		};
	}
	var WebGLVertexArrayObjectOES = function WebGLVertexArrayObjectOES(ext) {
		var gl = ext.gl;
		this.ext = ext;
		this.isAlive = true;
		this.hasBeenBound = false;
		this.elementArrayBuffer = null;
		this.attribs = new Array(ext.maxVertexAttribs);
		for (var n = 0; n < this.attribs.length; n++) {
			var attrib = new WebGLVertexArrayObjectOES.VertexAttrib(gl);
			this.attribs[n] = attrib;
		}
		this.maxAttrib = 0;
	};
	WebGLVertexArrayObjectOES.VertexAttrib = function VertexAttrib(gl) {
		this.enabled = false;
		this.buffer = null;
		this.size = 4;
		this.type = gl.FLOAT;
		this.normalized = false;
		this.stride = 16;
		this.offset = 0;
		this.cached = "";
		this.recache();
	};
	WebGLVertexArrayObjectOES.VertexAttrib.prototype.recache = function recache() {
		this.cached = [this.size, this.type, this.normalized, this.stride, this.offset].join(":");
	};
	var OESVertexArrayObject = function OESVertexArrayObject(gl) {
		var self = this;
		this.gl = gl;
		wrapGLError(gl);
		var original = this.original = {
			getParameter: gl.getParameter,
			enableVertexAttribArray: gl.enableVertexAttribArray,
			disableVertexAttribArray: gl.disableVertexAttribArray,
			bindBuffer: gl.bindBuffer,
			getVertexAttrib: gl.getVertexAttrib,
			vertexAttribPointer: gl.vertexAttribPointer
		};
		gl.getParameter = function getParameter(pname) {
			if (pname == self.VERTEX_ARRAY_BINDING_OES) {
				if (self.currentVertexArrayObject == self.defaultVertexArrayObject) {
					return null;
				} else {
					return self.currentVertexArrayObject;
				}
			}
			return original.getParameter.apply(this, arguments);
		};
		gl.enableVertexAttribArray = function enableVertexAttribArray(index) {
			var vao = self.currentVertexArrayObject;
			vao.maxAttrib = Math.max(vao.maxAttrib, index);
			var attrib = vao.attribs[index];
			attrib.enabled = true;
			return original.enableVertexAttribArray.apply(this, arguments);
		};
		gl.disableVertexAttribArray = function disableVertexAttribArray(index) {
			var vao = self.currentVertexArrayObject;
			vao.maxAttrib = Math.max(vao.maxAttrib, index);
			var attrib = vao.attribs[index];
			attrib.enabled = false;
			return original.disableVertexAttribArray.apply(this, arguments);
		};
		gl.bindBuffer = function bindBuffer(target, buffer) {
			switch (target) {
				case gl.ARRAY_BUFFER:
					self.currentArrayBuffer = buffer;
					break;
				case gl.ELEMENT_ARRAY_BUFFER:
					self.currentVertexArrayObject.elementArrayBuffer = buffer;
					break;
			}
			return original.bindBuffer.apply(this, arguments);
		};
		gl.getVertexAttrib = function getVertexAttrib(index, pname) {
			var vao = self.currentVertexArrayObject;
			var attrib = vao.attribs[index];
			switch (pname) {
				case gl.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:
					return attrib.buffer;
				case gl.VERTEX_ATTRIB_ARRAY_ENABLED:
					return attrib.enabled;
				case gl.VERTEX_ATTRIB_ARRAY_SIZE:
					return attrib.size;
				case gl.VERTEX_ATTRIB_ARRAY_STRIDE:
					return attrib.stride;
				case gl.VERTEX_ATTRIB_ARRAY_TYPE:
					return attrib.type;
				case gl.VERTEX_ATTRIB_ARRAY_NORMALIZED:
					return attrib.normalized;
				default:
					return original.getVertexAttrib.apply(this, arguments);
			}
		};
		gl.vertexAttribPointer = function vertexAttribPointer(indx, size, type, normalized, stride, offset) {
			var vao = self.currentVertexArrayObject;
			vao.maxAttrib = Math.max(vao.maxAttrib, indx);
			var attrib = vao.attribs[indx];
			attrib.buffer = self.currentArrayBuffer;
			attrib.size = size;
			attrib.type = type;
			attrib.normalized = normalized;
			attrib.stride = stride;
			attrib.offset = offset;
			attrib.recache();
			return original.vertexAttribPointer.apply(this, arguments);
		};
		if (gl.instrumentExtension) {
			gl.instrumentExtension(this, "OES_vertex_array_object");
		}
		gl.canvas.addEventListener('webglcontextrestored', function () {
			log$1("OESVertexArrayObject emulation library context restored");
			self.reset_();
		}, true);
		this.reset_();
	};
	OESVertexArrayObject.prototype.VERTEX_ARRAY_BINDING_OES = 0x85B5;
	OESVertexArrayObject.prototype.reset_ = function reset_() {
		var contextWasLost = this.vertexArrayObjects !== undefined;
		if (contextWasLost) {
			for (var ii = 0; ii < this.vertexArrayObjects.length; ++ii) {
				this.vertexArrayObjects.isAlive = false;
			}
		}
		var gl = this.gl;
		this.maxVertexAttribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
		this.defaultVertexArrayObject = new WebGLVertexArrayObjectOES(this);
		this.currentVertexArrayObject = null;
		this.currentArrayBuffer = null;
		this.vertexArrayObjects = [this.defaultVertexArrayObject];
		this.bindVertexArrayOES(null);
	};
	OESVertexArrayObject.prototype.createVertexArrayOES = function createVertexArrayOES() {
		var arrayObject = new WebGLVertexArrayObjectOES(this);
		this.vertexArrayObjects.push(arrayObject);
		return arrayObject;
	};
	OESVertexArrayObject.prototype.deleteVertexArrayOES = function deleteVertexArrayOES(arrayObject) {
		arrayObject.isAlive = false;
		this.vertexArrayObjects.splice(this.vertexArrayObjects.indexOf(arrayObject), 1);
		if (this.currentVertexArrayObject == arrayObject) {
			this.bindVertexArrayOES(null);
		}
	};
	OESVertexArrayObject.prototype.isVertexArrayOES = function isVertexArrayOES(arrayObject) {
		if (arrayObject && arrayObject instanceof WebGLVertexArrayObjectOES) {
			if (arrayObject.hasBeenBound && arrayObject.ext == this) {
				return true;
			}
		}
		return false;
	};
	OESVertexArrayObject.prototype.bindVertexArrayOES = function bindVertexArrayOES(arrayObject) {
		var gl = this.gl;
		if (arrayObject && !arrayObject.isAlive) {
			synthesizeGLError(gl.INVALID_OPERATION, "bindVertexArrayOES: attempt to bind deleted arrayObject");
			return;
		}
		var original = this.original;
		var oldVAO = this.currentVertexArrayObject;
		this.currentVertexArrayObject = arrayObject || this.defaultVertexArrayObject;
		this.currentVertexArrayObject.hasBeenBound = true;
		var newVAO = this.currentVertexArrayObject;
		if (oldVAO == newVAO) {
			return;
		}
		if (!oldVAO || newVAO.elementArrayBuffer != oldVAO.elementArrayBuffer) {
			original.bindBuffer.call(gl, gl.ELEMENT_ARRAY_BUFFER, newVAO.elementArrayBuffer);
		}
		var currentBinding = this.currentArrayBuffer;
		var maxAttrib = Math.max(oldVAO ? oldVAO.maxAttrib : 0, newVAO.maxAttrib);
		for (var n = 0; n <= maxAttrib; n++) {
			var attrib = newVAO.attribs[n];
			var oldAttrib = oldVAO ? oldVAO.attribs[n] : null;
			if (!oldVAO || attrib.enabled != oldAttrib.enabled) {
				if (attrib.enabled) {
					original.enableVertexAttribArray.call(gl, n);
				} else {
					original.disableVertexAttribArray.call(gl, n);
				}
			}
			if (attrib.enabled) {
				var bufferChanged = false;
				if (!oldVAO || attrib.buffer != oldAttrib.buffer) {
					if (currentBinding != attrib.buffer) {
						original.bindBuffer.call(gl, gl.ARRAY_BUFFER, attrib.buffer);
						currentBinding = attrib.buffer;
					}
					bufferChanged = true;
				}
				if (bufferChanged || attrib.cached != oldAttrib.cached) {
					original.vertexAttribPointer.call(gl, n, attrib.size, attrib.type, attrib.normalized, attrib.stride, attrib.offset);
				}
			}
		}
		if (this.currentArrayBuffer != currentBinding) {
			original.bindBuffer.call(gl, gl.ARRAY_BUFFER, this.currentArrayBuffer);
		}
	};
	var setupVertexArrayObject = function setupVertexArrayObject(gl) {
		if (gl.getSupportedExtensions) {
			var exts = gl.getSupportedExtensions();
			if (exts.indexOf("OES_vertex_array_object") != -1) {
				return;
			}
		} else if (gl.getExtension) {
			var vao = gl.getExtension("OES_vertex_array_object");
			if (vao) {
				return;
			}
		}
		if (gl.getSupportedExtensions) {
			var original_getSupportedExtensions = gl.getSupportedExtensions;
			gl.getSupportedExtensions = function getSupportedExtensions() {
				var list = original_getSupportedExtensions.call(this) || [];
				list.push("OES_vertex_array_object");
				return list;
			};
		}
		var original_getExtension = gl.getExtension;
		gl.getExtension = function getExtension(name) {
			if (name == "OES_vertex_array_object") {
				if (!gl.__OESVertexArrayObject) {
					gl.__OESVertexArrayObject = new OESVertexArrayObject(gl);
				}
				return gl.__OESVertexArrayObject;
			}
			if (original_getExtension) {
				return original_getExtension.call(this, name);
			} else {
				return null;
			}
		};
	};

	var TRACEID_RENDER_FRAME = 'RenderFrame';
	var TRACEID_RENDER_FRAME_TIME = 'RenderFrameTime';
	var TRACEID_RENDER_PASS = 'RenderPass';
	var TRACEID_RENDER_PASS_DETAIL = 'RenderPassDetail';
	var TRACEID_RENDER_ACTION = 'RenderAction';
	var TRACEID_RENDER_TARGET_ALLOC = 'RenderTargetAlloc';
	var TRACEID_TEXTURE_ALLOC = 'TextureAlloc';
	var TRACEID_SHADER_ALLOC = 'ShaderAlloc';
	var TRACEID_SHADER_COMPILE = 'ShaderCompile';
	var TRACEID_VRAM_TEXTURE = 'VRAM.Texture';
	var TRACEID_VRAM_VB = 'VRAM.Vb';
	var TRACEID_VRAM_IB = 'VRAM.Ib';
	var TRACEID_BINDGROUP_ALLOC = 'BindGroupAlloc';
	var TRACEID_BINDGROUPFORMAT_ALLOC = 'BindGroupFormatAlloc';
	var TRACEID_RENDERPIPELINE_ALLOC = 'RenderPipelineAlloc';
	var TRACEID_COMPUTEPIPELINE_ALLOC = 'ComputePipelineAlloc';
	var TRACEID_PIPELINELAYOUT_ALLOC = 'PipelineLayoutAlloc';
	var TRACE_ID_ELEMENT = "Element";
	var TRACEID_TEXTURES = 'Textures';
	var TRACEID_RENDER_QUEUE = 'RenderQueue';
	var TRACEID_GPU_TIMINGS = 'GpuTimings';

	var version = '1.67.0';
	var revision = 'ea736291a';
	var config = {};
	var common = {};
	var apps = {};
	var data = {};
	var _typeLookup = function () {
		var result = {};
		var names = ['Array', 'Object', 'Function', 'Date', 'RegExp', 'Float32Array'];
		for (var i = 0; i < names.length; i++) result['[object ' + names[i] + ']'] = names[i].toLowerCase();
		return result;
	}();
	function type$1(obj) {
		if (obj === null) {
			return 'null';
		}
		var type = typeof obj;
		if (type === 'undefined' || type === 'number' || type === 'string' || type === 'boolean') {
			return type;
		}
		return _typeLookup[Object.prototype.toString.call(obj)];
	}
	function extend(target, ex) {
		for (var prop in ex) {
			var copy = ex[prop];
			if (type$1(copy) === 'object') {
				target[prop] = extend({}, copy);
			} else if (type$1(copy) === 'array') {
				target[prop] = extend([], copy);
			} else {
				target[prop] = copy;
			}
		}
		return target;
	}

	function _regeneratorRuntime() {
	  _regeneratorRuntime = function () {
	    return e;
	  };
	  var t,
	    e = {},
	    r = Object.prototype,
	    n = r.hasOwnProperty,
	    o = Object.defineProperty || function (t, e, r) {
	      t[e] = r.value;
	    },
	    i = "function" == typeof Symbol ? Symbol : {},
	    a = i.iterator || "@@iterator",
	    c = i.asyncIterator || "@@asyncIterator",
	    u = i.toStringTag || "@@toStringTag";
	  function define(t, e, r) {
	    return Object.defineProperty(t, e, {
	      value: r,
	      enumerable: !0,
	      configurable: !0,
	      writable: !0
	    }), t[e];
	  }
	  try {
	    define({}, "");
	  } catch (t) {
	    define = function (t, e, r) {
	      return t[e] = r;
	    };
	  }
	  function wrap(t, e, r, n) {
	    var i = e && e.prototype instanceof Generator ? e : Generator,
	      a = Object.create(i.prototype),
	      c = new Context(n || []);
	    return o(a, "_invoke", {
	      value: makeInvokeMethod(t, r, c)
	    }), a;
	  }
	  function tryCatch(t, e, r) {
	    try {
	      return {
	        type: "normal",
	        arg: t.call(e, r)
	      };
	    } catch (t) {
	      return {
	        type: "throw",
	        arg: t
	      };
	    }
	  }
	  e.wrap = wrap;
	  var h = "suspendedStart",
	    l = "suspendedYield",
	    f = "executing",
	    s = "completed",
	    y = {};
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}
	  var p = {};
	  define(p, a, function () {
	    return this;
	  });
	  var d = Object.getPrototypeOf,
	    v = d && d(d(values([])));
	  v && v !== r && n.call(v, a) && (p = v);
	  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
	  function defineIteratorMethods(t) {
	    ["next", "throw", "return"].forEach(function (e) {
	      define(t, e, function (t) {
	        return this._invoke(e, t);
	      });
	    });
	  }
	  function AsyncIterator(t, e) {
	    function invoke(r, o, i, a) {
	      var c = tryCatch(t[r], t, o);
	      if ("throw" !== c.type) {
	        var u = c.arg,
	          h = u.value;
	        return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
	          invoke("next", t, i, a);
	        }, function (t) {
	          invoke("throw", t, i, a);
	        }) : e.resolve(h).then(function (t) {
	          u.value = t, i(u);
	        }, function (t) {
	          return invoke("throw", t, i, a);
	        });
	      }
	      a(c.arg);
	    }
	    var r;
	    o(this, "_invoke", {
	      value: function (t, n) {
	        function callInvokeWithMethodAndArg() {
	          return new e(function (e, r) {
	            invoke(t, n, e, r);
	          });
	        }
	        return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
	      }
	    });
	  }
	  function makeInvokeMethod(e, r, n) {
	    var o = h;
	    return function (i, a) {
	      if (o === f) throw new Error("Generator is already running");
	      if (o === s) {
	        if ("throw" === i) throw a;
	        return {
	          value: t,
	          done: !0
	        };
	      }
	      for (n.method = i, n.arg = a;;) {
	        var c = n.delegate;
	        if (c) {
	          var u = maybeInvokeDelegate(c, n);
	          if (u) {
	            if (u === y) continue;
	            return u;
	          }
	        }
	        if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
	          if (o === h) throw o = s, n.arg;
	          n.dispatchException(n.arg);
	        } else "return" === n.method && n.abrupt("return", n.arg);
	        o = f;
	        var p = tryCatch(e, r, n);
	        if ("normal" === p.type) {
	          if (o = n.done ? s : l, p.arg === y) continue;
	          return {
	            value: p.arg,
	            done: n.done
	          };
	        }
	        "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
	      }
	    };
	  }
	  function maybeInvokeDelegate(e, r) {
	    var n = r.method,
	      o = e.iterator[n];
	    if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
	    var i = tryCatch(o, e.iterator, r.arg);
	    if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
	    var a = i.arg;
	    return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
	  }
	  function pushTryEntry(t) {
	    var e = {
	      tryLoc: t[0]
	    };
	    1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
	  }
	  function resetTryEntry(t) {
	    var e = t.completion || {};
	    e.type = "normal", delete e.arg, t.completion = e;
	  }
	  function Context(t) {
	    this.tryEntries = [{
	      tryLoc: "root"
	    }], t.forEach(pushTryEntry, this), this.reset(!0);
	  }
	  function values(e) {
	    if (e || "" === e) {
	      var r = e[a];
	      if (r) return r.call(e);
	      if ("function" == typeof e.next) return e;
	      if (!isNaN(e.length)) {
	        var o = -1,
	          i = function next() {
	            for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
	            return next.value = t, next.done = !0, next;
	          };
	        return i.next = i;
	      }
	    }
	    throw new TypeError(typeof e + " is not iterable");
	  }
	  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
	    value: GeneratorFunctionPrototype,
	    configurable: !0
	  }), o(GeneratorFunctionPrototype, "constructor", {
	    value: GeneratorFunction,
	    configurable: !0
	  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
	    var e = "function" == typeof t && t.constructor;
	    return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
	  }, e.mark = function (t) {
	    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
	  }, e.awrap = function (t) {
	    return {
	      __await: t
	    };
	  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
	    return this;
	  }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
	    void 0 === i && (i = Promise);
	    var a = new AsyncIterator(wrap(t, r, n, o), i);
	    return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
	      return t.done ? t.value : a.next();
	    });
	  }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
	    return this;
	  }), define(g, "toString", function () {
	    return "[object Generator]";
	  }), e.keys = function (t) {
	    var e = Object(t),
	      r = [];
	    for (var n in e) r.push(n);
	    return r.reverse(), function next() {
	      for (; r.length;) {
	        var t = r.pop();
	        if (t in e) return next.value = t, next.done = !1, next;
	      }
	      return next.done = !0, next;
	    };
	  }, e.values = values, Context.prototype = {
	    constructor: Context,
	    reset: function (e) {
	      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
	    },
	    stop: function () {
	      this.done = !0;
	      var t = this.tryEntries[0].completion;
	      if ("throw" === t.type) throw t.arg;
	      return this.rval;
	    },
	    dispatchException: function (e) {
	      if (this.done) throw e;
	      var r = this;
	      function handle(n, o) {
	        return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
	      }
	      for (var o = this.tryEntries.length - 1; o >= 0; --o) {
	        var i = this.tryEntries[o],
	          a = i.completion;
	        if ("root" === i.tryLoc) return handle("end");
	        if (i.tryLoc <= this.prev) {
	          var c = n.call(i, "catchLoc"),
	            u = n.call(i, "finallyLoc");
	          if (c && u) {
	            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
	            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
	          } else if (c) {
	            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
	          } else {
	            if (!u) throw new Error("try statement without catch or finally");
	            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
	          }
	        }
	      }
	    },
	    abrupt: function (t, e) {
	      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
	        var o = this.tryEntries[r];
	        if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
	          var i = o;
	          break;
	        }
	      }
	      i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
	      var a = i ? i.completion : {};
	      return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
	    },
	    complete: function (t, e) {
	      if ("throw" === t.type) throw t.arg;
	      return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
	    },
	    finish: function (t) {
	      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
	        var r = this.tryEntries[e];
	        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
	      }
	    },
	    catch: function (t) {
	      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
	        var r = this.tryEntries[e];
	        if (r.tryLoc === t) {
	          var n = r.completion;
	          if ("throw" === n.type) {
	            var o = n.arg;
	            resetTryEntry(r);
	          }
	          return o;
	        }
	      }
	      throw new Error("illegal catch attempt");
	    },
	    delegateYield: function (e, r, n) {
	      return this.delegate = {
	        iterator: values(e),
	        resultName: r,
	        nextLoc: n
	      }, "next" === this.method && (this.arg = t), y;
	    }
	  }, e;
	}
	function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
	  try {
	    var info = gen[key](arg);
	    var value = info.value;
	  } catch (error) {
	    reject(error);
	    return;
	  }
	  if (info.done) {
	    resolve(value);
	  } else {
	    Promise.resolve(value).then(_next, _throw);
	  }
	}
	function _asyncToGenerator(fn) {
	  return function () {
	    var self = this,
	      args = arguments;
	    return new Promise(function (resolve, reject) {
	      var gen = fn.apply(self, args);
	      function _next(value) {
	        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
	      }
	      function _throw(err) {
	        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
	      }
	      _next(undefined);
	    });
	  };
	}
	function _defineProperties(target, props) {
	  for (var i = 0; i < props.length; i++) {
	    var descriptor = props[i];
	    descriptor.enumerable = descriptor.enumerable || false;
	    descriptor.configurable = true;
	    if ("value" in descriptor) descriptor.writable = true;
	    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
	  }
	}
	function _createClass(Constructor, protoProps, staticProps) {
	  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
	  if (staticProps) _defineProperties(Constructor, staticProps);
	  Object.defineProperty(Constructor, "prototype", {
	    writable: false
	  });
	  return Constructor;
	}
	function _extends() {
	  _extends = Object.assign ? Object.assign.bind() : function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  return _extends.apply(this, arguments);
	}
	function _inheritsLoose(subClass, superClass) {
	  subClass.prototype = Object.create(superClass.prototype);
	  subClass.prototype.constructor = subClass;
	  _setPrototypeOf(subClass, superClass);
	}
	function _setPrototypeOf(o, p) {
	  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
	    o.__proto__ = p;
	    return o;
	  };
	  return _setPrototypeOf(o, p);
	}
	function _assertThisInitialized(self) {
	  if (self === void 0) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }
	  return self;
	}
	function _unsupportedIterableToArray(o, minLen) {
	  if (!o) return;
	  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
	  var n = Object.prototype.toString.call(o).slice(8, -1);
	  if (n === "Object" && o.constructor) n = o.constructor.name;
	  if (n === "Map" || n === "Set") return Array.from(o);
	  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
	}
	function _arrayLikeToArray(arr, len) {
	  if (len == null || len > arr.length) len = arr.length;
	  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	  return arr2;
	}
	function _createForOfIteratorHelperLoose(o, allowArrayLike) {
	  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
	  if (it) return (it = it.call(o)).next.bind(it);
	  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
	    if (it) o = it;
	    var i = 0;
	    return function () {
	      if (i >= o.length) return {
	        done: true
	      };
	      return {
	        done: false,
	        value: o[i++]
	      };
	    };
	  }
	  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	}
	function _toPrimitive(input, hint) {
	  if (typeof input !== "object" || input === null) return input;
	  var prim = input[Symbol.toPrimitive];
	  if (prim !== undefined) {
	    var res = prim.call(input, hint || "default");
	    if (typeof res !== "object") return res;
	    throw new TypeError("@@toPrimitive must return a primitive value.");
	  }
	  return (hint === "string" ? String : Number)(input);
	}
	function _toPropertyKey(arg) {
	  var key = _toPrimitive(arg, "string");
	  return typeof key === "symbol" ? key : String(key);
	}

	var Tracing = function () {
		function Tracing() {}
		Tracing.set = function set(channel, enabled) {
		};
		Tracing.get = function get(channel) {
			return Tracing._traceChannels.has(channel);
		};
		return Tracing;
	}();
	Tracing._traceChannels = new Set();
	Tracing.stack = false;

	var EventHandle = function () {
		function EventHandle(handler, name, callback, scope, once) {
			if (once === void 0) {
				once = false;
			}
			this.handler = void 0;
			this.name = void 0;
			this.callback = void 0;
			this.scope = void 0;
			this._once = void 0;
			this._removed = false;
			this.handler = handler;
			this.name = name;
			this.callback = callback;
			this.scope = scope;
			this._once = once;
		}
		var _proto = EventHandle.prototype;
		_proto.off = function off() {
			if (this._removed) return;
			this.handler.off(this.name, this.callback, this.scope);
		};
		_proto.on = function on(name, callback, scope) {
			if (scope === void 0) {
				scope = this;
			}
			return this.handler._addCallback(name, callback, scope, false);
		};
		_proto.once = function once(name, callback, scope) {
			if (scope === void 0) {
				scope = this;
			}
			return this.handler._addCallback(name, callback, scope, true);
		};
		_createClass(EventHandle, [{
			key: "removed",
			get: function get() {
				return this._removed;
			},
			set: function set(value) {
				if (!value) return;
				this._removed = true;
			}
		}]);
		return EventHandle;
	}();

	var EventHandler = function () {
		function EventHandler() {
			this._callbacks = new Map();
			this._callbackActive = new Map();
		}
		var _proto = EventHandler.prototype;
		_proto.initEventHandler = function initEventHandler() {
			this._callbacks = new Map();
			this._callbackActive = new Map();
		};
		_proto._addCallback = function _addCallback(name, callback, scope, once) {
			if (!this._callbacks.has(name)) this._callbacks.set(name, []);
			if (this._callbackActive.has(name)) {
				var callbackActive = this._callbackActive.get(name);
				if (callbackActive && callbackActive === this._callbacks.get(name)) {
					this._callbackActive.set(name, callbackActive.slice());
				}
			}
			var evt = new EventHandle(this, name, callback, scope, once);
			this._callbacks.get(name).push(evt);
			return evt;
		};
		_proto.on = function on(name, callback, scope) {
			if (scope === void 0) {
				scope = this;
			}
			return this._addCallback(name, callback, scope, false);
		};
		_proto.once = function once(name, callback, scope) {
			if (scope === void 0) {
				scope = this;
			}
			return this._addCallback(name, callback, scope, true);
		};
		_proto.off = function off(name, callback, scope) {
			if (name) {
				if (this._callbackActive.has(name) && this._callbackActive.get(name) === this._callbacks.get(name)) this._callbackActive.set(name, this._callbackActive.get(name).slice());
			} else {
				for (var _iterator = _createForOfIteratorHelperLoose(this._callbackActive), _step; !(_step = _iterator()).done;) {
					var _step$value = _step.value,
						key = _step$value[0],
						callbacks = _step$value[1];
					if (!this._callbacks.has(key)) continue;
					if (this._callbacks.get(key) !== callbacks) continue;
					this._callbackActive.set(key, callbacks.slice());
				}
			}
			if (!name) {
				for (var _iterator2 = _createForOfIteratorHelperLoose(this._callbacks.values()), _step2; !(_step2 = _iterator2()).done;) {
					var _callbacks = _step2.value;
					for (var i = 0; i < _callbacks.length; i++) {
						_callbacks[i].removed = true;
					}
				}
				this._callbacks.clear();
			} else if (!callback) {
				var _callbacks2 = this._callbacks.get(name);
				if (_callbacks2) {
					for (var _i = 0; _i < _callbacks2.length; _i++) {
						_callbacks2[_i].removed = true;
					}
					this._callbacks.delete(name);
				}
			} else {
				var _callbacks3 = this._callbacks.get(name);
				if (!_callbacks3) return this;
				for (var _i2 = 0; _i2 < _callbacks3.length; _i2++) {
					if (_callbacks3[_i2].callback !== callback) continue;
					if (scope && _callbacks3[_i2].scope !== scope) continue;
					_callbacks3[_i2].removed = true;
					_callbacks3.splice(_i2, 1);
					_i2--;
				}
				if (_callbacks3.length === 0) this._callbacks.delete(name);
			}
			return this;
		};
		_proto.fire = function fire(name, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {
			if (!name) return this;
			var callbacksInitial = this._callbacks.get(name);
			if (!callbacksInitial) return this;
			var callbacks;
			if (!this._callbackActive.has(name)) {
				this._callbackActive.set(name, callbacksInitial);
			} else if (this._callbackActive.get(name) !== callbacksInitial) {
				callbacks = callbacksInitial.slice();
			}
			for (var i = 0; (callbacks || this._callbackActive.get(name)) && i < (callbacks || this._callbackActive.get(name)).length; i++) {
				var evt = (callbacks || this._callbackActive.get(name))[i];
				if (!evt.callback) continue;
				evt.callback.call(evt.scope, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
				if (evt._once) {
					var existingCallback = this._callbacks.get(name);
					var ind = existingCallback ? existingCallback.indexOf(evt) : -1;
					if (ind !== -1) {
						if (this._callbackActive.get(name) === existingCallback) this._callbackActive.set(name, this._callbackActive.get(name).slice());
						var _callbacks4 = this._callbacks.get(name);
						if (!_callbacks4) continue;
						_callbacks4[ind].removed = true;
						_callbacks4.splice(ind, 1);
						if (_callbacks4.length === 0) this._callbacks.delete(name);
					}
				}
			}
			if (!callbacks) this._callbackActive.delete(name);
			return this;
		};
		_proto.hasEvent = function hasEvent(name) {
			var _this$_callbacks$get;
			return !!((_this$_callbacks$get = this._callbacks.get(name)) != null && _this$_callbacks$get.length);
		};
		return EventHandler;
	}();

	var events = {
		attach: function attach(target) {
			var ev = events;
			target._addCallback = ev._addCallback;
			target.on = ev.on;
			target.off = ev.off;
			target.fire = ev.fire;
			target.once = ev.once;
			target.hasEvent = ev.hasEvent;
			EventHandler.prototype.initEventHandler.call(target);
			return target;
		},
		_addCallback: EventHandler.prototype._addCallback,
		on: EventHandler.prototype.on,
		off: EventHandler.prototype.off,
		fire: EventHandler.prototype.fire,
		once: EventHandler.prototype.once,
		hasEvent: EventHandler.prototype.hasEvent
	};

	var guid = {
		create: function create() {
			return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
				var r = Math.random() * 16 | 0;
				var v = c === 'x' ? r : r & 0x3 | 0x8;
				return v.toString(16);
			});
		}
	};

	var path = {
		delimiter: '/',
		join: function join() {
			var num = arguments.length;
			var result = arguments[0];
			for (var index = 0; index < num - 1; ++index) {
				var one = arguments[index];
				var two = arguments[index + 1];
				if (two[0] === path.delimiter) {
					result = two;
					continue;
				}
				if (one && two && one[one.length - 1] !== path.delimiter && two[0] !== path.delimiter) {
					result += path.delimiter + two;
				} else {
					result += two;
				}
			}
			return result;
		},
		normalize: function normalize(pathname) {
			var lead = pathname.startsWith(path.delimiter);
			var trail = pathname.endsWith(path.delimiter);
			var parts = pathname.split('/');
			var result = '';
			var cleaned = [];
			for (var i = 0; i < parts.length; i++) {
				if (parts[i] === '') continue;
				if (parts[i] === '.') continue;
				if (parts[i] === '..' && cleaned.length > 0) {
					cleaned = cleaned.slice(0, cleaned.length - 2);
					continue;
				}
				if (i > 0) cleaned.push(path.delimiter);
				cleaned.push(parts[i]);
			}
			result = cleaned.join('');
			if (!lead && result[0] === path.delimiter) {
				result = result.slice(1);
			}
			if (trail && result[result.length - 1] !== path.delimiter) {
				result += path.delimiter;
			}
			return result;
		},
		split: function split(pathname) {
			var lastDelimiterIndex = pathname.lastIndexOf(path.delimiter);
			if (lastDelimiterIndex !== -1) {
				return [pathname.substring(0, lastDelimiterIndex), pathname.substring(lastDelimiterIndex + 1)];
			}
			return ["", pathname];
		},
		getBasename: function getBasename(pathname) {
			return path.split(pathname)[1];
		},
		getDirectory: function getDirectory(pathname) {
			return path.split(pathname)[0];
		},
		getExtension: function getExtension(pathname) {
			var ext = pathname.split('?')[0].split('.').pop();
			if (ext !== pathname) {
				return '.' + ext;
			}
			return '';
		},
		isRelativePath: function isRelativePath(pathname) {
			return pathname.charAt(0) !== '/' && pathname.match(/:\/\//) === null;
		},
		extractPath: function extractPath(pathname) {
			var result = '';
			var parts = pathname.split('/');
			var i = 0;
			if (parts.length > 1) {
				if (path.isRelativePath(pathname)) {
					if (parts[0] === '.') {
						for (i = 0; i < parts.length - 1; ++i) {
							result += i === 0 ? parts[i] : '/' + parts[i];
						}
					} else if (parts[0] === '..') {
						for (i = 0; i < parts.length - 1; ++i) {
							result += i === 0 ? parts[i] : '/' + parts[i];
						}
					} else {
						result = '.';
						for (i = 0; i < parts.length - 1; ++i) {
							result += '/' + parts[i];
						}
					}
				} else {
					for (i = 0; i < parts.length - 1; ++i) {
						result += i === 0 ? parts[i] : '/' + parts[i];
					}
				}
			}
			return result;
		}
	};

	var detectPassiveEvents = function detectPassiveEvents() {
		var result = false;
		try {
			var opts = Object.defineProperty({}, 'passive', {
				get: function get() {
					result = true;
					return false;
				}
			});
			window.addEventListener('testpassive', null, opts);
			window.removeEventListener('testpassive', null, opts);
		} catch (e) {}
		return result;
	};
	var ua = typeof navigator !== 'undefined' ? navigator.userAgent : '';
	var environment = typeof window !== 'undefined' ? 'browser' : 'node';
	var platformName = /android/i.test(ua) ? 'android' : /ip([ao]d|hone)/i.test(ua) ? 'ios' : /windows/i.test(ua) ? 'windows' : /mac os/i.test(ua) ? 'osx' : /linux/i.test(ua) ? 'linux' : /cros/i.test(ua) ? 'cros' : null;
	var browserName = environment !== 'browser' ? null : /(Chrome\/|Chromium\/|Edg.*\/)/.test(ua) ? 'chrome' : /Safari\//.test(ua) ? 'safari' : /Firefox\//.test(ua) ? 'firefox' : 'other';
	var xbox = /xbox/i.test(ua);
	var touch = environment === 'browser' && ('ontouchstart' in window || 'maxTouchPoints' in navigator && navigator.maxTouchPoints > 0);
	var gamepads = environment === 'browser' && (!!navigator.getGamepads || !!navigator.webkitGetGamepads);
	var workers = typeof Worker !== 'undefined';
	var passiveEvents = detectPassiveEvents();
	var platform = {
		environment: environment,
		global: environment === 'browser' ? window : global,
		browser: environment === 'browser',
		desktop: ['windows', 'osx', 'linux', 'cros'].includes(platformName),
		mobile: ['android', 'ios'].includes(platformName),
		ios: platformName === 'ios',
		android: platformName === 'android',
		xbox: xbox,
		gamepads: gamepads,
		touch: touch,
		workers: workers,
		passiveEvents: passiveEvents,
		browserName: browserName
	};

	var ASCII_LOWERCASE = 'abcdefghijklmnopqrstuvwxyz';
	var ASCII_UPPERCASE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
	var ASCII_LETTERS = ASCII_LOWERCASE + ASCII_UPPERCASE;
	var HIGH_SURROGATE_BEGIN = 0xD800;
	var HIGH_SURROGATE_END = 0xDBFF;
	var LOW_SURROGATE_BEGIN = 0xDC00;
	var LOW_SURROGATE_END = 0xDFFF;
	var ZERO_WIDTH_JOINER = 0x200D;
	var REGIONAL_INDICATOR_BEGIN = 0x1F1E6;
	var REGIONAL_INDICATOR_END = 0x1F1FF;
	var FITZPATRICK_MODIFIER_BEGIN = 0x1F3FB;
	var FITZPATRICK_MODIFIER_END = 0x1F3FF;
	var DIACRITICAL_MARKS_BEGIN = 0x20D0;
	var DIACRITICAL_MARKS_END = 0x20FF;
	var VARIATION_MODIFIER_BEGIN = 0xFE00;
	var VARIATION_MODIFIER_END = 0xFE0F;
	function getCodePointData(string, i) {
		if (i === void 0) {
			i = 0;
		}
		var size = string.length;
		if (i < 0 || i >= size) {
			return null;
		}
		var first = string.charCodeAt(i);
		if (size > 1 && first >= HIGH_SURROGATE_BEGIN && first <= HIGH_SURROGATE_END) {
			var second = string.charCodeAt(i + 1);
			if (second >= LOW_SURROGATE_BEGIN && second <= LOW_SURROGATE_END) {
				return {
					code: (first - HIGH_SURROGATE_BEGIN) * 0x400 + second - LOW_SURROGATE_BEGIN + 0x10000,
					long: true
				};
			}
		}
		return {
			code: first,
			long: false
		};
	}
	function isCodeBetween(string, begin, end) {
		if (!string) return false;
		var codeData = getCodePointData(string);
		if (codeData) {
			var code = codeData.code;
			return code >= begin && code <= end;
		}
		return false;
	}
	function numCharsToTakeForNextSymbol(string, index) {
		if (index === string.length - 1) {
			return 1;
		}
		if (isCodeBetween(string[index], HIGH_SURROGATE_BEGIN, HIGH_SURROGATE_END)) {
			var first = string.substring(index, index + 2);
			var second = string.substring(index + 2, index + 4);
			if (isCodeBetween(second, FITZPATRICK_MODIFIER_BEGIN, FITZPATRICK_MODIFIER_END) || isCodeBetween(first, REGIONAL_INDICATOR_BEGIN, REGIONAL_INDICATOR_END) && isCodeBetween(second, REGIONAL_INDICATOR_BEGIN, REGIONAL_INDICATOR_END)) {
				return 4;
			}
			if (isCodeBetween(second, VARIATION_MODIFIER_BEGIN, VARIATION_MODIFIER_END)) {
				return 3;
			}
			return 2;
		}
		if (isCodeBetween(string[index + 1], VARIATION_MODIFIER_BEGIN, VARIATION_MODIFIER_END)) {
			return 2;
		}
		return 1;
	}
	var string = {
		ASCII_LOWERCASE: ASCII_LOWERCASE,
		ASCII_UPPERCASE: ASCII_UPPERCASE,
		ASCII_LETTERS: ASCII_LETTERS,
		format: function format(s) {
			for (var i = 0; i < (arguments.length <= 1 ? 0 : arguments.length - 1); i++) {
				s = s.replace("{" + i + "}", i + 1 < 1 || arguments.length <= i + 1 ? undefined : arguments[i + 1]);
			}
			return s;
		},
		getCodePoint: function getCodePoint(string, i) {
			var codePointData = getCodePointData(string, i);
			return codePointData && codePointData.code;
		},
		getCodePoints: function getCodePoints(string) {
			if (typeof string !== 'string') {
				throw new TypeError('Not a string');
			}
			var i = 0;
			var arr = [];
			var codePoint;
			while (!!(codePoint = getCodePointData(string, i))) {
				arr.push(codePoint.code);
				i += codePoint.long ? 2 : 1;
			}
			return arr;
		},
		getSymbols: function getSymbols(string) {
			if (typeof string !== 'string') {
				throw new TypeError('Not a string');
			}
			var index = 0;
			var length = string.length;
			var output = [];
			var take = 0;
			var ch;
			while (index < length) {
				take += numCharsToTakeForNextSymbol(string, index + take);
				ch = string[index + take];
				if (isCodeBetween(ch, DIACRITICAL_MARKS_BEGIN, DIACRITICAL_MARKS_END)) {
					ch = string[index + take++];
				}
				if (isCodeBetween(ch, VARIATION_MODIFIER_BEGIN, VARIATION_MODIFIER_END)) {
					ch = string[index + take++];
				}
				if (ch && ch.charCodeAt(0) === ZERO_WIDTH_JOINER) {
					ch = string[index + take++];
					continue;
				}
				var char = string.substring(index, index + take);
				output.push(char);
				index += take;
				take = 0;
			}
			return output;
		},
		fromCodePoint: function fromCodePoint() {
			var chars = [];
			var current;
			var codePoint;
			var units;
			for (var i = 0; i < arguments.length; ++i) {
				current = Number(arguments[i]);
				codePoint = current - 0x10000;
				units = current > 0xFFFF ? [(codePoint >> 10) + 0xD800, codePoint % 0x400 + 0xDC00] : [current];
				chars.push(String.fromCharCode.apply(null, units));
			}
			return chars.join('');
		}
	};

	var IndexedList = function () {
		function IndexedList() {
			this._list = [];
			this._index = {};
		}
		var _proto = IndexedList.prototype;
		_proto.push = function push(key, item) {
			if (this._index[key]) {
				throw Error('Key already in index ' + key);
			}
			var location = this._list.push(item) - 1;
			this._index[key] = location;
		};
		_proto.has = function has(key) {
			return this._index[key] !== undefined;
		};
		_proto.get = function get(key) {
			var location = this._index[key];
			if (location !== undefined) {
				return this._list[location];
			}
			return null;
		};
		_proto.remove = function remove(key) {
			var location = this._index[key];
			if (location !== undefined) {
				this._list.splice(location, 1);
				delete this._index[key];
				for (key in this._index) {
					var idx = this._index[key];
					if (idx > location) {
						this._index[key] = idx - 1;
					}
				}
				return true;
			}
			return false;
		};
		_proto.list = function list() {
			return this._list;
		};
		_proto.clear = function clear() {
			this._list.length = 0;
			for (var prop in this._index) {
				delete this._index[prop];
			}
		};
		return IndexedList;
	}();

	var cachedResult = function cachedResult(func) {
		var uninitToken = {};
		var result = uninitToken;
		return function () {
			if (result === uninitToken) {
				result = func();
			}
			return result;
		};
	};
	var Impl = function () {
		function Impl() {}
		Impl.loadScript = function loadScript(url, callback) {
			var s = document.createElement('script');
			s.setAttribute('src', url);
			s.onload = function () {
				callback(null);
			};
			s.onerror = function () {
				callback("Failed to load script='" + url + "'");
			};
			document.body.appendChild(s);
		};
		Impl.loadWasm = function loadWasm(moduleName, config, callback) {
			var loadUrl = Impl.wasmSupported() && config.glueUrl && config.wasmUrl ? config.glueUrl : config.fallbackUrl;
			if (loadUrl) {
				Impl.loadScript(loadUrl, function (err) {
					if (err) {
						callback(err, null);
					} else {
						var module = window[moduleName];
						window[moduleName] = undefined;
						module({
							locateFile: function locateFile() {
								return config.wasmUrl;
							},
							onAbort: function onAbort() {
								callback('wasm module aborted.');
							}
						}).then(function (instance) {
							callback(null, instance);
						});
					}
				});
			} else {
				callback('No supported wasm modules found.', null);
			}
		};
		Impl.getModule = function getModule(name) {
			if (!Impl.modules.hasOwnProperty(name)) {
				Impl.modules[name] = {
					config: null,
					initializing: false,
					instance: null,
					callbacks: []
				};
			}
			return Impl.modules[name];
		};
		Impl.initialize = function initialize(moduleName, module) {
			if (module.initializing) {
				return;
			}
			var config = module.config;
			if (config.glueUrl || config.wasmUrl || config.fallbackUrl) {
				module.initializing = true;
				Impl.loadWasm(moduleName, config, function (err, instance) {
					if (err) {
						if (config.errorHandler) {
							config.errorHandler(err);
						} else {
							console.error("failed to initialize module=" + moduleName + " error=" + err);
						}
					} else {
						module.instance = instance;
						module.callbacks.forEach(function (callback) {
							callback(instance);
						});
					}
				});
			}
		};
		return Impl;
	}();
	Impl.modules = {};
	Impl.wasmSupported = cachedResult(function () {
		try {
			if (typeof WebAssembly === "object" && typeof WebAssembly.instantiate === "function") {
				var module = new WebAssembly.Module(Uint8Array.of(0x0, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00));
				if (module instanceof WebAssembly.Module) return new WebAssembly.Instance(module) instanceof WebAssembly.Instance;
			}
		} catch (e) {}
		return false;
	});
	var WasmModule = function () {
		function WasmModule() {}
		WasmModule.setConfig = function setConfig(moduleName, config) {
			var module = Impl.getModule(moduleName);
			module.config = config;
			if (module.callbacks.length > 0) {
				Impl.initialize(moduleName, module);
			}
		};
		WasmModule.getConfig = function getConfig(moduleName) {
			var _Impl$modules;
			return (_Impl$modules = Impl.modules) == null || (_Impl$modules = _Impl$modules[moduleName]) == null ? void 0 : _Impl$modules.config;
		};
		WasmModule.getInstance = function getInstance(moduleName, callback) {
			var module = Impl.getModule(moduleName);
			if (module.instance) {
				callback(module.instance);
			} else {
				module.callbacks.push(callback);
				if (module.config) {
					Impl.initialize(moduleName, module);
				}
			}
		};
		return WasmModule;
	}();

	var ReadStream = function () {
		function ReadStream(arraybuffer) {
			this.arraybuffer = arraybuffer;
			this.dataView = new DataView(arraybuffer);
			this.offset = 0;
			this.stack = [];
		}
		var _proto = ReadStream.prototype;
		_proto.reset = function reset(offset) {
			if (offset === void 0) {
				offset = 0;
			}
			this.offset = offset;
		};
		_proto.skip = function skip(bytes) {
			this.offset += bytes;
		};
		_proto.align = function align(bytes) {
			this.offset = this.offset + bytes - 1 & ~(bytes - 1);
		};
		_proto._inc = function _inc(amount) {
			this.offset += amount;
			return this.offset - amount;
		};
		_proto.readChar = function readChar() {
			return String.fromCharCode(this.dataView.getUint8(this.offset++));
		};
		_proto.readChars = function readChars(numChars) {
			var result = '';
			for (var i = 0; i < numChars; ++i) {
				result += this.readChar();
			}
			return result;
		};
		_proto.readU8 = function readU8() {
			return this.dataView.getUint8(this.offset++);
		};
		_proto.readU16 = function readU16() {
			return this.dataView.getUint16(this._inc(2), true);
		};
		_proto.readU32 = function readU32() {
			return this.dataView.getUint32(this._inc(4), true);
		};
		_proto.readU64 = function readU64() {
			return this.readU32() + Math.pow(2, 32) * this.readU32();
		};
		_proto.readU32be = function readU32be() {
			return this.dataView.getUint32(this._inc(4), false);
		};
		_proto.readArray = function readArray(result) {
			for (var i = 0; i < result.length; ++i) {
				result[i] = this.readU8();
			}
		};
		_proto.readLine = function readLine() {
			var view = this.dataView;
			var result = '';
			while (true) {
				if (this.offset >= view.byteLength) {
					break;
				}
				var c = String.fromCharCode(this.readU8());
				if (c === '\n') {
					break;
				}
				result += c;
			}
			return result;
		};
		_createClass(ReadStream, [{
			key: "remainingBytes",
			get: function get() {
				return this.dataView.byteLength - this.offset;
			}
		}]);
		return ReadStream;
	}();

	var SortedLoopArray = function () {
		function SortedLoopArray(args) {
			this.items = [];
			this.length = 0;
			this.loopIndex = -1;
			this._sortBy = void 0;
			this._sortHandler = void 0;
			this._sortBy = args.sortBy;
			this._sortHandler = this._doSort.bind(this);
		}
		var _proto = SortedLoopArray.prototype;
		_proto._binarySearch = function _binarySearch(item) {
			var left = 0;
			var right = this.items.length - 1;
			var search = item[this._sortBy];
			var middle;
			var current;
			while (left <= right) {
				middle = Math.floor((left + right) / 2);
				current = this.items[middle][this._sortBy];
				if (current <= search) {
					left = middle + 1;
				} else if (current > search) {
					right = middle - 1;
				}
			}
			return left;
		};
		_proto._doSort = function _doSort(a, b) {
			var sortBy = this._sortBy;
			return a[sortBy] - b[sortBy];
		};
		_proto.insert = function insert(item) {
			var index = this._binarySearch(item);
			this.items.splice(index, 0, item);
			this.length++;
			if (this.loopIndex >= index) {
				this.loopIndex++;
			}
		};
		_proto.append = function append(item) {
			this.items.push(item);
			this.length++;
		};
		_proto.remove = function remove(item) {
			var idx = this.items.indexOf(item);
			if (idx < 0) return;
			this.items.splice(idx, 1);
			this.length--;
			if (this.loopIndex >= idx) {
				this.loopIndex--;
			}
		};
		_proto.sort = function sort() {
			var current = this.loopIndex >= 0 ? this.items[this.loopIndex] : null;
			this.items.sort(this._sortHandler);
			if (current !== null) {
				this.loopIndex = this.items.indexOf(current);
			}
		};
		return SortedLoopArray;
	}();

	var Tags = function (_EventHandler) {
		_inheritsLoose(Tags, _EventHandler);
		function Tags(parent) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this._index = {};
			_this._list = [];
			_this._parent = parent;
			return _this;
		}
		var _proto = Tags.prototype;
		_proto.add = function add() {
			var changed = false;
			var tags = this._processArguments(arguments, true);
			if (!tags.length) return changed;
			for (var i = 0; i < tags.length; i++) {
				if (this._index[tags[i]]) continue;
				changed = true;
				this._index[tags[i]] = true;
				this._list.push(tags[i]);
				this.fire('add', tags[i], this._parent);
			}
			if (changed) this.fire('change', this._parent);
			return changed;
		};
		_proto.remove = function remove() {
			var changed = false;
			if (!this._list.length) return changed;
			var tags = this._processArguments(arguments, true);
			if (!tags.length) return changed;
			for (var i = 0; i < tags.length; i++) {
				if (!this._index[tags[i]]) continue;
				changed = true;
				delete this._index[tags[i]];
				this._list.splice(this._list.indexOf(tags[i]), 1);
				this.fire('remove', tags[i], this._parent);
			}
			if (changed) this.fire('change', this._parent);
			return changed;
		};
		_proto.clear = function clear() {
			if (!this._list.length) return;
			var tags = this._list.slice(0);
			this._list = [];
			this._index = {};
			for (var i = 0; i < tags.length; i++) this.fire('remove', tags[i], this._parent);
			this.fire('change', this._parent);
		};
		_proto.has = function has() {
			if (!this._list.length) return false;
			return this._has(this._processArguments(arguments));
		};
		_proto._has = function _has(tags) {
			if (!this._list.length || !tags.length) return false;
			for (var i = 0; i < tags.length; i++) {
				if (tags[i].length === 1) {
					if (this._index[tags[i][0]]) return true;
				} else {
					var multiple = true;
					for (var t = 0; t < tags[i].length; t++) {
						if (this._index[tags[i][t]]) continue;
						multiple = false;
						break;
					}
					if (multiple) return true;
				}
			}
			return false;
		};
		_proto.list = function list() {
			return this._list.slice(0);
		};
		_proto._processArguments = function _processArguments(args, flat) {
			var tags = [];
			var tmp = [];
			if (!args || !args.length) return tags;
			for (var i = 0; i < args.length; i++) {
				if (args[i] instanceof Array) {
					if (!flat) tmp = [];
					for (var t = 0; t < args[i].length; t++) {
						if (typeof args[i][t] !== 'string') continue;
						if (flat) {
							tags.push(args[i][t]);
						} else {
							tmp.push(args[i][t]);
						}
					}
					if (!flat && tmp.length) tags.push(tmp);
				} else if (typeof args[i] === 'string') {
					if (flat) {
						tags.push(args[i]);
					} else {
						tags.push([args[i]]);
					}
				}
			}
			return tags;
		};
		_createClass(Tags, [{
			key: "size",
			get: function get() {
				return this._list.length;
			}
		}]);
		return Tags;
	}(EventHandler);

	var now = typeof window !== 'undefined' && window.performance && window.performance.now ? performance.now.bind(performance) : Date.now;

	function createURI(options) {
		var s = '';
		if ((options.authority || options.scheme) && (options.host || options.hostpath)) {
			throw new Error('Can\'t have \'scheme\' or \'authority\' and \'host\' or \'hostpath\' option');
		}
		if (options.host && options.hostpath) {
			throw new Error('Can\'t have \'host\' and \'hostpath\' option');
		}
		if (options.path && options.hostpath) {
			throw new Error('Can\'t have \'path\' and \'hostpath\' option');
		}
		if (options.scheme) {
			s += options.scheme + ':';
		}
		if (options.authority) {
			s += '//' + options.authority;
		}
		if (options.host) {
			s += options.host;
		}
		if (options.path) {
			s += options.path;
		}
		if (options.hostpath) {
			s += options.hostpath;
		}
		if (options.query) {
			s += '?' + options.query;
		}
		if (options.fragment) {
			s += '#' + options.fragment;
		}
		return s;
	}
	var re = /^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
	var URI = function () {
		function URI(uri) {
			this.scheme = void 0;
			this.authority = void 0;
			this.path = void 0;
			this.query = void 0;
			this.fragment = void 0;
			var result = uri.match(re);
			this.scheme = result[2];
			this.authority = result[4];
			this.path = result[5];
			this.query = result[7];
			this.fragment = result[9];
		}
		var _proto = URI.prototype;
		_proto.toString = function toString() {
			var s = '';
			if (this.scheme) {
				s += this.scheme + ':';
			}
			if (this.authority) {
				s += '//' + this.authority;
			}
			s += this.path;
			if (this.query) {
				s += '?' + this.query;
			}
			if (this.fragment) {
				s += '#' + this.fragment;
			}
			return s;
		};
		_proto.getQuery = function getQuery() {
			var result = {};
			if (this.query) {
				var queryParams = decodeURIComponent(this.query).split('&');
				for (var _iterator = _createForOfIteratorHelperLoose(queryParams), _step; !(_step = _iterator()).done;) {
					var queryParam = _step.value;
					var pair = queryParam.split('=');
					result[pair[0]] = pair[1];
				}
			}
			return result;
		};
		_proto.setQuery = function setQuery(params) {
			var q = '';
			for (var key in params) {
				if (params.hasOwnProperty(key)) {
					if (q !== '') {
						q += '&';
					}
					q += encodeURIComponent(key) + '=' + encodeURIComponent(params[key]);
				}
			}
			this.query = q;
		};
		return URI;
	}();

	var CURVE_LINEAR = 0;
	var CURVE_SMOOTHSTEP = 1;
	var CURVE_CATMULL = 2;
	var CURVE_CARDINAL = 3;
	var CURVE_SPLINE = 4;
	var CURVE_STEP = 5;

	var math = {
		DEG_TO_RAD: Math.PI / 180,
		RAD_TO_DEG: 180 / Math.PI,
		clamp: function clamp(value, min, max) {
			if (value >= max) return max;
			if (value <= min) return min;
			return value;
		},
		intToBytes24: function intToBytes24(i) {
			var r = i >> 16 & 0xff;
			var g = i >> 8 & 0xff;
			var b = i & 0xff;
			return [r, g, b];
		},
		intToBytes32: function intToBytes32(i) {
			var r = i >> 24 & 0xff;
			var g = i >> 16 & 0xff;
			var b = i >> 8 & 0xff;
			var a = i & 0xff;
			return [r, g, b, a];
		},
		bytesToInt24: function bytesToInt24(r, g, b) {
			if (r.length) {
				b = r[2];
				g = r[1];
				r = r[0];
			}
			return r << 16 | g << 8 | b;
		},
		bytesToInt32: function bytesToInt32(r, g, b, a) {
			if (r.length) {
				a = r[3];
				b = r[2];
				g = r[1];
				r = r[0];
			}
			return (r << 24 | g << 16 | b << 8 | a) >>> 0;
		},
		lerp: function lerp(a, b, alpha) {
			return a + (b - a) * math.clamp(alpha, 0, 1);
		},
		lerpAngle: function lerpAngle(a, b, alpha) {
			if (b - a > 180) {
				b -= 360;
			}
			if (b - a < -180) {
				b += 360;
			}
			return math.lerp(a, b, math.clamp(alpha, 0, 1));
		},
		powerOfTwo: function powerOfTwo(x) {
			return x !== 0 && !(x & x - 1);
		},
		nextPowerOfTwo: function nextPowerOfTwo(val) {
			val--;
			val |= val >> 1;
			val |= val >> 2;
			val |= val >> 4;
			val |= val >> 8;
			val |= val >> 16;
			val++;
			return val;
		},
		nearestPowerOfTwo: function nearestPowerOfTwo(val) {
			return Math.pow(2, Math.round(Math.log(val) / Math.log(2)));
		},
		random: function random(min, max) {
			var diff = max - min;
			return Math.random() * diff + min;
		},
		smoothstep: function smoothstep(min, max, x) {
			if (x <= min) return 0;
			if (x >= max) return 1;
			x = (x - min) / (max - min);
			return x * x * (3 - 2 * x);
		},
		smootherstep: function smootherstep(min, max, x) {
			if (x <= min) return 0;
			if (x >= max) return 1;
			x = (x - min) / (max - min);
			return x * x * x * (x * (x * 6 - 15) + 10);
		},
		roundUp: function roundUp(numToRound, multiple) {
			if (multiple === 0) return numToRound;
			return Math.ceil(numToRound / multiple) * multiple;
		},
		between: function between(num, a, b, inclusive) {
			var min = Math.min(a, b);
			var max = Math.max(a, b);
			return inclusive ? num >= min && num <= max : num > min && num < max;
		}
	};

	var _class$b;
	var Color = function () {
		function Color(r, g, b, a) {
			if (r === void 0) {
				r = 0;
			}
			if (g === void 0) {
				g = 0;
			}
			if (b === void 0) {
				b = 0;
			}
			if (a === void 0) {
				a = 1;
			}
			this.r = void 0;
			this.g = void 0;
			this.b = void 0;
			this.a = void 0;
			var length = r.length;
			if (length === 3 || length === 4) {
				this.r = r[0];
				this.g = r[1];
				this.b = r[2];
				this.a = r[3] !== undefined ? r[3] : 1;
			} else {
				this.r = r;
				this.g = g;
				this.b = b;
				this.a = a;
			}
		}
		var _proto = Color.prototype;
		_proto.clone = function clone() {
			var cstr = this.constructor;
			return new cstr(this.r, this.g, this.b, this.a);
		};
		_proto.copy = function copy(rhs) {
			this.r = rhs.r;
			this.g = rhs.g;
			this.b = rhs.b;
			this.a = rhs.a;
			return this;
		};
		_proto.equals = function equals(rhs) {
			return this.r === rhs.r && this.g === rhs.g && this.b === rhs.b && this.a === rhs.a;
		};
		_proto.set = function set(r, g, b, a) {
			if (a === void 0) {
				a = 1;
			}
			this.r = r;
			this.g = g;
			this.b = b;
			this.a = a;
			return this;
		};
		_proto.lerp = function lerp(lhs, rhs, alpha) {
			this.r = lhs.r + alpha * (rhs.r - lhs.r);
			this.g = lhs.g + alpha * (rhs.g - lhs.g);
			this.b = lhs.b + alpha * (rhs.b - lhs.b);
			this.a = lhs.a + alpha * (rhs.a - lhs.a);
			return this;
		};
		_proto.fromString = function fromString(hex) {
			var i = parseInt(hex.replace('#', '0x'), 16);
			var bytes;
			if (hex.length > 7) {
				bytes = math.intToBytes32(i);
			} else {
				bytes = math.intToBytes24(i);
				bytes[3] = 255;
			}
			this.set(bytes[0] / 255, bytes[1] / 255, bytes[2] / 255, bytes[3] / 255);
			return this;
		};
		_proto.toString = function toString(alpha) {
			var s = '#' + ((1 << 24) + (Math.round(this.r * 255) << 16) + (Math.round(this.g * 255) << 8) + Math.round(this.b * 255)).toString(16).slice(1);
			if (alpha === true) {
				var a = Math.round(this.a * 255).toString(16);
				if (this.a < 16 / 255) {
					s += '0' + a;
				} else {
					s += a;
				}
			}
			return s;
		};
		return Color;
	}();
	_class$b = Color;
	Color.BLACK = Object.freeze(new _class$b(0, 0, 0, 1));
	Color.BLUE = Object.freeze(new _class$b(0, 0, 1, 1));
	Color.CYAN = Object.freeze(new _class$b(0, 1, 1, 1));
	Color.GRAY = Object.freeze(new _class$b(0.5, 0.5, 0.5, 1));
	Color.GREEN = Object.freeze(new _class$b(0, 1, 0, 1));
	Color.MAGENTA = Object.freeze(new _class$b(1, 0, 1, 1));
	Color.RED = Object.freeze(new _class$b(1, 0, 0, 1));
	Color.WHITE = Object.freeze(new _class$b(1, 1, 1, 1));
	Color.YELLOW = Object.freeze(new _class$b(1, 1, 0, 1));

	var CurveEvaluator = function () {
		function CurveEvaluator(curve, time) {
			if (time === void 0) {
				time = 0;
			}
			this._curve = void 0;
			this._left = -Infinity;
			this._right = Infinity;
			this._recip = 0;
			this._p0 = 0;
			this._p1 = 0;
			this._m0 = 0;
			this._m1 = 0;
			this._curve = curve;
			this._reset(time);
		}
		var _proto = CurveEvaluator.prototype;
		_proto.evaluate = function evaluate(time, forceReset) {
			if (forceReset === void 0) {
				forceReset = false;
			}
			if (forceReset || time < this._left || time >= this._right) {
				this._reset(time);
			}
			var result;
			var type = this._curve.type;
			if (type === CURVE_STEP) {
				result = this._p0;
			} else {
				var t = this._recip === 0 ? 0 : (time - this._left) * this._recip;
				if (type === CURVE_LINEAR) {
					result = math.lerp(this._p0, this._p1, t);
				} else if (type === CURVE_SMOOTHSTEP) {
					result = math.lerp(this._p0, this._p1, t * t * (3 - 2 * t));
				} else {
					result = this._evaluateHermite(this._p0, this._p1, this._m0, this._m1, t);
				}
			}
			return result;
		};
		_proto._reset = function _reset(time) {
			var keys = this._curve.keys;
			var len = keys.length;
			if (!len) {
				this._left = -Infinity;
				this._right = Infinity;
				this._recip = 0;
				this._p0 = this._p1 = this._m0 = this._m1 = 0;
			} else {
				if (time < keys[0][0]) {
					this._left = -Infinity;
					this._right = keys[0][0];
					this._recip = 0;
					this._p0 = this._p1 = keys[0][1];
					this._m0 = this._m1 = 0;
				} else if (time >= keys[len - 1][0]) {
					this._left = keys[len - 1][0];
					this._right = Infinity;
					this._recip = 0;
					this._p0 = this._p1 = keys[len - 1][1];
					this._m0 = this._m1 = 0;
				} else {
					var index = 0;
					while (time >= keys[index + 1][0]) {
						index++;
					}
					this._left = keys[index][0];
					this._right = keys[index + 1][0];
					var diff = 1.0 / (this._right - this._left);
					this._recip = isFinite(diff) ? diff : 0;
					this._p0 = keys[index][1];
					this._p1 = keys[index + 1][1];
					if (this._isHermite()) {
						this._calcTangents(keys, index);
					}
				}
			}
		};
		_proto._isHermite = function _isHermite() {
			return this._curve.type === CURVE_CATMULL || this._curve.type === CURVE_CARDINAL || this._curve.type === CURVE_SPLINE;
		};
		_proto._calcTangents = function _calcTangents(keys, index) {
			var a;
			var b = keys[index];
			var c = keys[index + 1];
			var d;
			if (index === 0) {
				a = [keys[0][0] + (keys[0][0] - keys[1][0]), keys[0][1] + (keys[0][1] - keys[1][1])];
			} else {
				a = keys[index - 1];
			}
			if (index === keys.length - 2) {
				d = [keys[index + 1][0] + (keys[index + 1][0] - keys[index][0]), keys[index + 1][1] + (keys[index + 1][1] - keys[index][1])];
			} else {
				d = keys[index + 2];
			}
			if (this._curve.type === CURVE_SPLINE) {
				var s1_ = 2 * (c[0] - b[0]) / (c[0] - a[0]);
				var s2_ = 2 * (c[0] - b[0]) / (d[0] - b[0]);
				this._m0 = this._curve.tension * (isFinite(s1_) ? s1_ : 0) * (c[1] - a[1]);
				this._m1 = this._curve.tension * (isFinite(s2_) ? s2_ : 0) * (d[1] - b[1]);
			} else {
				var s1 = (c[0] - b[0]) / (b[0] - a[0]);
				var s2 = (c[0] - b[0]) / (d[0] - c[0]);
				var a_ = b[1] + (a[1] - b[1]) * (isFinite(s1) ? s1 : 0);
				var d_ = c[1] + (d[1] - c[1]) * (isFinite(s2) ? s2 : 0);
				var tension = this._curve.type === CURVE_CATMULL ? 0.5 : this._curve.tension;
				this._m0 = tension * (c[1] - a_);
				this._m1 = tension * (d_ - b[1]);
			}
		};
		_proto._evaluateHermite = function _evaluateHermite(p0, p1, m0, m1, t) {
			var t2 = t * t;
			var twot = t + t;
			var omt = 1 - t;
			var omt2 = omt * omt;
			return p0 * ((1 + twot) * omt2) + m0 * (t * omt2) + p1 * (t2 * (3 - twot)) + m1 * (t2 * (t - 1));
		};
		return CurveEvaluator;
	}();

	var Curve = function () {
		function Curve(data) {
			this.keys = [];
			this.type = CURVE_SMOOTHSTEP;
			this.tension = 0.5;
			this._eval = new CurveEvaluator(this);
			if (data) {
				for (var i = 0; i < data.length - 1; i += 2) {
					this.keys.push([data[i], data[i + 1]]);
				}
			}
			this.sort();
		}
		var _proto = Curve.prototype;
		_proto.add = function add(time, value) {
			var keys = this.keys;
			var len = keys.length;
			var i = 0;
			for (; i < len; i++) {
				if (keys[i][0] > time) {
					break;
				}
			}
			var key = [time, value];
			this.keys.splice(i, 0, key);
			return key;
		};
		_proto.get = function get(index) {
			return this.keys[index];
		};
		_proto.sort = function sort() {
			this.keys.sort(function (a, b) {
				return a[0] - b[0];
			});
		};
		_proto.value = function value(time) {
			return this._eval.evaluate(time, true);
		};
		_proto.closest = function closest(time) {
			var keys = this.keys;
			var length = keys.length;
			var min = 2;
			var result = null;
			for (var i = 0; i < length; i++) {
				var diff = Math.abs(time - keys[i][0]);
				if (min >= diff) {
					min = diff;
					result = keys[i];
				} else {
					break;
				}
			}
			return result;
		};
		_proto.clone = function clone() {
			var result = new this.constructor();
			result.keys = extend(result.keys, this.keys);
			result.type = this.type;
			result.tension = this.tension;
			return result;
		};
		_proto.quantize = function quantize(precision) {
			precision = Math.max(precision, 2);
			var values = new Float32Array(precision);
			var step = 1.0 / (precision - 1);
			values[0] = this._eval.evaluate(0, true);
			for (var i = 1; i < precision; i++) {
				values[i] = this._eval.evaluate(step * i);
			}
			return values;
		};
		_proto.quantizeClamped = function quantizeClamped(precision, min, max) {
			var result = this.quantize(precision);
			for (var i = 0; i < result.length; ++i) {
				result[i] = Math.min(max, Math.max(min, result[i]));
			}
			return result;
		};
		_createClass(Curve, [{
			key: "length",
			get: function get() {
				return this.keys.length;
			}
		}]);
		return Curve;
	}();

	var CurveSet = function () {
		function CurveSet() {
			this.curves = [];
			this._type = CURVE_SMOOTHSTEP;
			if (arguments.length > 1) {
				for (var i = 0; i < arguments.length; i++) {
					this.curves.push(new Curve(arguments[i]));
				}
			} else {
				if (arguments.length === 0) {
					this.curves.push(new Curve());
				} else {
					var arg = arguments[0];
					if (typeof arg === 'number') {
						for (var _i = 0; _i < arg; _i++) {
							this.curves.push(new Curve());
						}
					} else {
						for (var _i2 = 0; _i2 < arg.length; _i2++) {
							this.curves.push(new Curve(arg[_i2]));
						}
					}
				}
			}
		}
		var _proto = CurveSet.prototype;
		_proto.get = function get(index) {
			return this.curves[index];
		};
		_proto.value = function value(time, result) {
			if (result === void 0) {
				result = [];
			}
			var length = this.curves.length;
			result.length = length;
			for (var i = 0; i < length; i++) {
				result[i] = this.curves[i].value(time);
			}
			return result;
		};
		_proto.clone = function clone() {
			var result = new this.constructor();
			result.curves = [];
			for (var i = 0; i < this.curves.length; i++) {
				result.curves.push(this.curves[i].clone());
			}
			result._type = this._type;
			return result;
		};
		_proto.quantize = function quantize(precision) {
			precision = Math.max(precision, 2);
			var numCurves = this.curves.length;
			var values = new Float32Array(precision * numCurves);
			var step = 1.0 / (precision - 1);
			for (var c = 0; c < numCurves; c++) {
				var ev = new CurveEvaluator(this.curves[c]);
				for (var i = 0; i < precision; i++) {
					values[i * numCurves + c] = ev.evaluate(step * i);
				}
			}
			return values;
		};
		_proto.quantizeClamped = function quantizeClamped(precision, min, max) {
			var result = this.quantize(precision);
			for (var i = 0; i < result.length; ++i) {
				result[i] = Math.min(max, Math.max(min, result[i]));
			}
			return result;
		};
		_createClass(CurveSet, [{
			key: "length",
			get: function get() {
				return this.curves.length;
			}
		}, {
			key: "type",
			get: function get() {
				return this._type;
			},
			set: function set(value) {
				this._type = value;
				for (var i = 0; i < this.curves.length; i++) {
					this.curves[i].type = value;
				}
			}
		}]);
		return CurveSet;
	}();

	var oneDiv255 = 1 / 255;
	var floatView = new Float32Array(1);
	var int32View = new Int32Array(floatView.buffer);
	var FloatPacking = function () {
		function FloatPacking() {}
		FloatPacking.float2Half = function float2Half(value) {
			floatView[0] = value;
			var x = int32View[0];
			var bits = x >> 16 & 0x8000;
			var m = x >> 12 & 0x07ff;
			var e = x >> 23 & 0xff;
			if (e < 103) {
				return bits;
			}
			if (e > 142) {
				bits |= 0x7c00;
				bits |= (e === 255 ? 0 : 1) && x & 0x007fffff;
				return bits;
			}
			if (e < 113) {
				m |= 0x0800;
				bits |= (m >> 114 - e) + (m >> 113 - e & 1);
				return bits;
			}
			bits |= e - 112 << 10 | m >> 1;
			bits += m & 1;
			return bits;
		};
		FloatPacking.float2Bytes = function float2Bytes(value, array, offset, numBytes) {
			var enc1 = 255.0 * value % 1;
			array[offset + 0] = Math.round((value % 1 - oneDiv255 * enc1) * 255);
			if (numBytes > 1) {
				var enc2 = 65025.0 * value % 1;
				array[offset + 1] = Math.round((enc1 - oneDiv255 * enc2) * 255);
				if (numBytes > 2) {
					var enc3 = 16581375.0 * value % 1;
					array[offset + 2] = Math.round((enc2 - oneDiv255 * enc3) * 255);
					if (numBytes > 3) {
						array[offset + 3] = Math.round(enc3 * 255);
					}
				}
			}
		};
		FloatPacking.float2BytesRange = function float2BytesRange(value, array, offset, min, max, numBytes) {
			value = math.clamp((value - min) / (max - min), 0, 1);
			FloatPacking.float2Bytes(value, array, offset, numBytes);
		};
		FloatPacking.float2MantissaExponent = function float2MantissaExponent(value, array, offset, numBytes) {
			var exponent = Math.floor(Math.log2(Math.abs(value))) + 1;
			value /= Math.pow(2, exponent);
			FloatPacking.float2BytesRange(value, array, offset, -1, 1, numBytes - 1);
			array[offset + numBytes - 1] = Math.round(exponent + 127);
		};
		return FloatPacking;
	}();

	var _class$a;
	var Vec3 = function () {
		function Vec3(x, y, z) {
			if (x === void 0) {
				x = 0;
			}
			if (y === void 0) {
				y = 0;
			}
			if (z === void 0) {
				z = 0;
			}
			this.x = void 0;
			this.y = void 0;
			this.z = void 0;
			if (x.length === 3) {
				this.x = x[0];
				this.y = x[1];
				this.z = x[2];
			} else {
				this.x = x;
				this.y = y;
				this.z = z;
			}
		}
		var _proto = Vec3.prototype;
		_proto.add = function add(rhs) {
			this.x += rhs.x;
			this.y += rhs.y;
			this.z += rhs.z;
			return this;
		};
		_proto.add2 = function add2(lhs, rhs) {
			this.x = lhs.x + rhs.x;
			this.y = lhs.y + rhs.y;
			this.z = lhs.z + rhs.z;
			return this;
		};
		_proto.addScalar = function addScalar(scalar) {
			this.x += scalar;
			this.y += scalar;
			this.z += scalar;
			return this;
		};
		_proto.addScaled = function addScaled(rhs, scalar) {
			this.x += rhs.x * scalar;
			this.y += rhs.y * scalar;
			this.z += rhs.z * scalar;
			return this;
		};
		_proto.clone = function clone() {
			var cstr = this.constructor;
			return new cstr(this.x, this.y, this.z);
		};
		_proto.copy = function copy(rhs) {
			this.x = rhs.x;
			this.y = rhs.y;
			this.z = rhs.z;
			return this;
		};
		_proto.cross = function cross(lhs, rhs) {
			var lx = lhs.x;
			var ly = lhs.y;
			var lz = lhs.z;
			var rx = rhs.x;
			var ry = rhs.y;
			var rz = rhs.z;
			this.x = ly * rz - ry * lz;
			this.y = lz * rx - rz * lx;
			this.z = lx * ry - rx * ly;
			return this;
		};
		_proto.distance = function distance(rhs) {
			var x = this.x - rhs.x;
			var y = this.y - rhs.y;
			var z = this.z - rhs.z;
			return Math.sqrt(x * x + y * y + z * z);
		};
		_proto.div = function div(rhs) {
			this.x /= rhs.x;
			this.y /= rhs.y;
			this.z /= rhs.z;
			return this;
		};
		_proto.div2 = function div2(lhs, rhs) {
			this.x = lhs.x / rhs.x;
			this.y = lhs.y / rhs.y;
			this.z = lhs.z / rhs.z;
			return this;
		};
		_proto.divScalar = function divScalar(scalar) {
			this.x /= scalar;
			this.y /= scalar;
			this.z /= scalar;
			return this;
		};
		_proto.dot = function dot(rhs) {
			return this.x * rhs.x + this.y * rhs.y + this.z * rhs.z;
		};
		_proto.equals = function equals(rhs) {
			return this.x === rhs.x && this.y === rhs.y && this.z === rhs.z;
		};
		_proto.equalsApprox = function equalsApprox(rhs, epsilon) {
			if (epsilon === void 0) {
				epsilon = 1e-6;
			}
			return Math.abs(this.x - rhs.x) < epsilon && Math.abs(this.y - rhs.y) < epsilon && Math.abs(this.z - rhs.z) < epsilon;
		};
		_proto.length = function length() {
			return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
		};
		_proto.lengthSq = function lengthSq() {
			return this.x * this.x + this.y * this.y + this.z * this.z;
		};
		_proto.lerp = function lerp(lhs, rhs, alpha) {
			this.x = lhs.x + alpha * (rhs.x - lhs.x);
			this.y = lhs.y + alpha * (rhs.y - lhs.y);
			this.z = lhs.z + alpha * (rhs.z - lhs.z);
			return this;
		};
		_proto.mul = function mul(rhs) {
			this.x *= rhs.x;
			this.y *= rhs.y;
			this.z *= rhs.z;
			return this;
		};
		_proto.mul2 = function mul2(lhs, rhs) {
			this.x = lhs.x * rhs.x;
			this.y = lhs.y * rhs.y;
			this.z = lhs.z * rhs.z;
			return this;
		};
		_proto.mulScalar = function mulScalar(scalar) {
			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			return this;
		};
		_proto.normalize = function normalize(src) {
			if (src === void 0) {
				src = this;
			}
			var lengthSq = src.x * src.x + src.y * src.y + src.z * src.z;
			if (lengthSq > 0) {
				var invLength = 1 / Math.sqrt(lengthSq);
				this.x = src.x * invLength;
				this.y = src.y * invLength;
				this.z = src.z * invLength;
			}
			return this;
		};
		_proto.floor = function floor(src) {
			if (src === void 0) {
				src = this;
			}
			this.x = Math.floor(src.x);
			this.y = Math.floor(src.y);
			this.z = Math.floor(src.z);
			return this;
		};
		_proto.ceil = function ceil(src) {
			if (src === void 0) {
				src = this;
			}
			this.x = Math.ceil(src.x);
			this.y = Math.ceil(src.y);
			this.z = Math.ceil(src.z);
			return this;
		};
		_proto.round = function round(src) {
			if (src === void 0) {
				src = this;
			}
			this.x = Math.round(src.x);
			this.y = Math.round(src.y);
			this.z = Math.round(src.z);
			return this;
		};
		_proto.min = function min(rhs) {
			if (rhs.x < this.x) this.x = rhs.x;
			if (rhs.y < this.y) this.y = rhs.y;
			if (rhs.z < this.z) this.z = rhs.z;
			return this;
		};
		_proto.max = function max(rhs) {
			if (rhs.x > this.x) this.x = rhs.x;
			if (rhs.y > this.y) this.y = rhs.y;
			if (rhs.z > this.z) this.z = rhs.z;
			return this;
		};
		_proto.project = function project(rhs) {
			var a_dot_b = this.x * rhs.x + this.y * rhs.y + this.z * rhs.z;
			var b_dot_b = rhs.x * rhs.x + rhs.y * rhs.y + rhs.z * rhs.z;
			var s = a_dot_b / b_dot_b;
			this.x = rhs.x * s;
			this.y = rhs.y * s;
			this.z = rhs.z * s;
			return this;
		};
		_proto.set = function set(x, y, z) {
			this.x = x;
			this.y = y;
			this.z = z;
			return this;
		};
		_proto.sub = function sub(rhs) {
			this.x -= rhs.x;
			this.y -= rhs.y;
			this.z -= rhs.z;
			return this;
		};
		_proto.sub2 = function sub2(lhs, rhs) {
			this.x = lhs.x - rhs.x;
			this.y = lhs.y - rhs.y;
			this.z = lhs.z - rhs.z;
			return this;
		};
		_proto.subScalar = function subScalar(scalar) {
			this.x -= scalar;
			this.y -= scalar;
			this.z -= scalar;
			return this;
		};
		_proto.toString = function toString() {
			return "[" + this.x + ", " + this.y + ", " + this.z + "]";
		};
		return Vec3;
	}();
	_class$a = Vec3;
	Vec3.ZERO = Object.freeze(new _class$a(0, 0, 0));
	Vec3.ONE = Object.freeze(new _class$a(1, 1, 1));
	Vec3.UP = Object.freeze(new _class$a(0, 1, 0));
	Vec3.DOWN = Object.freeze(new _class$a(0, -1, 0));
	Vec3.RIGHT = Object.freeze(new _class$a(1, 0, 0));
	Vec3.LEFT = Object.freeze(new _class$a(-1, 0, 0));
	Vec3.FORWARD = Object.freeze(new _class$a(0, 0, -1));
	Vec3.BACK = Object.freeze(new _class$a(0, 0, 1));

	var _class$9;
	var Mat3 = function () {
		function Mat3() {
			this.data = new Float32Array(9);
			this.data[0] = this.data[4] = this.data[8] = 1;
		}
		var _proto = Mat3.prototype;
		_proto.clone = function clone() {
			var cstr = this.constructor;
			return new cstr().copy(this);
		};
		_proto.copy = function copy(rhs) {
			var src = rhs.data;
			var dst = this.data;
			dst[0] = src[0];
			dst[1] = src[1];
			dst[2] = src[2];
			dst[3] = src[3];
			dst[4] = src[4];
			dst[5] = src[5];
			dst[6] = src[6];
			dst[7] = src[7];
			dst[8] = src[8];
			return this;
		};
		_proto.set = function set(src) {
			var dst = this.data;
			dst[0] = src[0];
			dst[1] = src[1];
			dst[2] = src[2];
			dst[3] = src[3];
			dst[4] = src[4];
			dst[5] = src[5];
			dst[6] = src[6];
			dst[7] = src[7];
			dst[8] = src[8];
			return this;
		};
		_proto.equals = function equals(rhs) {
			var l = this.data;
			var r = rhs.data;
			return l[0] === r[0] && l[1] === r[1] && l[2] === r[2] && l[3] === r[3] && l[4] === r[4] && l[5] === r[5] && l[6] === r[6] && l[7] === r[7] && l[8] === r[8];
		};
		_proto.isIdentity = function isIdentity() {
			var m = this.data;
			return m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 0 && m[4] === 1 && m[5] === 0 && m[6] === 0 && m[7] === 0 && m[8] === 1;
		};
		_proto.setIdentity = function setIdentity() {
			var m = this.data;
			m[0] = 1;
			m[1] = 0;
			m[2] = 0;
			m[3] = 0;
			m[4] = 1;
			m[5] = 0;
			m[6] = 0;
			m[7] = 0;
			m[8] = 1;
			return this;
		};
		_proto.toString = function toString() {
			return '[' + this.data.join(', ') + ']';
		};
		_proto.transpose = function transpose(src) {
			if (src === void 0) {
				src = this;
			}
			var s = src.data;
			var t = this.data;
			if (s === t) {
				var tmp;
				tmp = s[1];
				t[1] = s[3];
				t[3] = tmp;
				tmp = s[2];
				t[2] = s[6];
				t[6] = tmp;
				tmp = s[5];
				t[5] = s[7];
				t[7] = tmp;
			} else {
				t[0] = s[0];
				t[1] = s[3];
				t[2] = s[6];
				t[3] = s[1];
				t[4] = s[4];
				t[5] = s[7];
				t[6] = s[2];
				t[7] = s[5];
				t[8] = s[8];
			}
			return this;
		};
		_proto.setFromMat4 = function setFromMat4(m) {
			var src = m.data;
			var dst = this.data;
			dst[0] = src[0];
			dst[1] = src[1];
			dst[2] = src[2];
			dst[3] = src[4];
			dst[4] = src[5];
			dst[5] = src[6];
			dst[6] = src[8];
			dst[7] = src[9];
			dst[8] = src[10];
			return this;
		};
		_proto.invertMat4 = function invertMat4(src) {
			var s = src.data;
			var a0 = s[0];
			var a1 = s[1];
			var a2 = s[2];
			var a4 = s[4];
			var a5 = s[5];
			var a6 = s[6];
			var a8 = s[8];
			var a9 = s[9];
			var a10 = s[10];
			var b11 = a10 * a5 - a6 * a9;
			var b21 = -a10 * a1 + a2 * a9;
			var b31 = a6 * a1 - a2 * a5;
			var b12 = -a10 * a4 + a6 * a8;
			var b22 = a10 * a0 - a2 * a8;
			var b32 = -a6 * a0 + a2 * a4;
			var b13 = a9 * a4 - a5 * a8;
			var b23 = -a9 * a0 + a1 * a8;
			var b33 = a5 * a0 - a1 * a4;
			var det = a0 * b11 + a1 * b12 + a2 * b13;
			if (det === 0) {
				this.setIdentity();
			} else {
				var invDet = 1 / det;
				var t = this.data;
				t[0] = b11 * invDet;
				t[1] = b21 * invDet;
				t[2] = b31 * invDet;
				t[3] = b12 * invDet;
				t[4] = b22 * invDet;
				t[5] = b32 * invDet;
				t[6] = b13 * invDet;
				t[7] = b23 * invDet;
				t[8] = b33 * invDet;
			}
			return this;
		};
		_proto.transformVector = function transformVector(vec, res) {
			if (res === void 0) {
				res = new Vec3();
			}
			var m = this.data;
			var x = vec.x;
			var y = vec.y;
			var z = vec.z;
			res.x = x * m[0] + y * m[3] + z * m[6];
			res.y = x * m[1] + y * m[4] + z * m[7];
			res.z = x * m[2] + y * m[5] + z * m[8];
			return res;
		};
		return Mat3;
	}();
	_class$9 = Mat3;
	Mat3.IDENTITY = Object.freeze(new _class$9());
	Mat3.ZERO = Object.freeze(new _class$9().set([0, 0, 0, 0, 0, 0, 0, 0, 0]));

	var _class$8;
	var Vec2 = function () {
		function Vec2(x, y) {
			if (x === void 0) {
				x = 0;
			}
			if (y === void 0) {
				y = 0;
			}
			this.x = void 0;
			this.y = void 0;
			if (x.length === 2) {
				this.x = x[0];
				this.y = x[1];
			} else {
				this.x = x;
				this.y = y;
			}
		}
		var _proto = Vec2.prototype;
		_proto.add = function add(rhs) {
			this.x += rhs.x;
			this.y += rhs.y;
			return this;
		};
		_proto.add2 = function add2(lhs, rhs) {
			this.x = lhs.x + rhs.x;
			this.y = lhs.y + rhs.y;
			return this;
		};
		_proto.addScalar = function addScalar(scalar) {
			this.x += scalar;
			this.y += scalar;
			return this;
		};
		_proto.addScaled = function addScaled(rhs, scalar) {
			this.x += rhs.x * scalar;
			this.y += rhs.y * scalar;
			return this;
		};
		_proto.clone = function clone() {
			var cstr = this.constructor;
			return new cstr(this.x, this.y);
		};
		_proto.copy = function copy(rhs) {
			this.x = rhs.x;
			this.y = rhs.y;
			return this;
		};
		_proto.cross = function cross(rhs) {
			return this.x * rhs.y - this.y * rhs.x;
		};
		_proto.distance = function distance(rhs) {
			var x = this.x - rhs.x;
			var y = this.y - rhs.y;
			return Math.sqrt(x * x + y * y);
		};
		_proto.div = function div(rhs) {
			this.x /= rhs.x;
			this.y /= rhs.y;
			return this;
		};
		_proto.div2 = function div2(lhs, rhs) {
			this.x = lhs.x / rhs.x;
			this.y = lhs.y / rhs.y;
			return this;
		};
		_proto.divScalar = function divScalar(scalar) {
			this.x /= scalar;
			this.y /= scalar;
			return this;
		};
		_proto.dot = function dot(rhs) {
			return this.x * rhs.x + this.y * rhs.y;
		};
		_proto.equals = function equals(rhs) {
			return this.x === rhs.x && this.y === rhs.y;
		};
		_proto.equalsApprox = function equalsApprox(rhs, epsilon) {
			if (epsilon === void 0) {
				epsilon = 1e-6;
			}
			return Math.abs(this.x - rhs.x) < epsilon && Math.abs(this.y - rhs.y) < epsilon;
		};
		_proto.length = function length() {
			return Math.sqrt(this.x * this.x + this.y * this.y);
		};
		_proto.lengthSq = function lengthSq() {
			return this.x * this.x + this.y * this.y;
		};
		_proto.lerp = function lerp(lhs, rhs, alpha) {
			this.x = lhs.x + alpha * (rhs.x - lhs.x);
			this.y = lhs.y + alpha * (rhs.y - lhs.y);
			return this;
		};
		_proto.mul = function mul(rhs) {
			this.x *= rhs.x;
			this.y *= rhs.y;
			return this;
		};
		_proto.mul2 = function mul2(lhs, rhs) {
			this.x = lhs.x * rhs.x;
			this.y = lhs.y * rhs.y;
			return this;
		};
		_proto.mulScalar = function mulScalar(scalar) {
			this.x *= scalar;
			this.y *= scalar;
			return this;
		};
		_proto.normalize = function normalize(src) {
			if (src === void 0) {
				src = this;
			}
			var lengthSq = src.x * src.x + src.y * src.y;
			if (lengthSq > 0) {
				var invLength = 1 / Math.sqrt(lengthSq);
				this.x = src.x * invLength;
				this.y = src.y * invLength;
			}
			return this;
		};
		_proto.rotate = function rotate(degrees) {
			var angle = Math.atan2(this.x, this.y) + degrees * math.DEG_TO_RAD;
			var len = Math.sqrt(this.x * this.x + this.y * this.y);
			this.x = Math.sin(angle) * len;
			this.y = Math.cos(angle) * len;
			return this;
		};
		_proto.angle = function angle() {
			return Math.atan2(this.x, this.y) * math.RAD_TO_DEG;
		};
		_proto.angleTo = function angleTo(rhs) {
			return Math.atan2(this.x * rhs.y + this.y * rhs.x, this.x * rhs.x + this.y * rhs.y) * math.RAD_TO_DEG;
		};
		_proto.floor = function floor(src) {
			if (src === void 0) {
				src = this;
			}
			this.x = Math.floor(src.x);
			this.y = Math.floor(src.y);
			return this;
		};
		_proto.ceil = function ceil(src) {
			if (src === void 0) {
				src = this;
			}
			this.x = Math.ceil(src.x);
			this.y = Math.ceil(src.y);
			return this;
		};
		_proto.round = function round(src) {
			if (src === void 0) {
				src = this;
			}
			this.x = Math.round(src.x);
			this.y = Math.round(src.y);
			return this;
		};
		_proto.min = function min(rhs) {
			if (rhs.x < this.x) this.x = rhs.x;
			if (rhs.y < this.y) this.y = rhs.y;
			return this;
		};
		_proto.max = function max(rhs) {
			if (rhs.x > this.x) this.x = rhs.x;
			if (rhs.y > this.y) this.y = rhs.y;
			return this;
		};
		_proto.set = function set(x, y) {
			this.x = x;
			this.y = y;
			return this;
		};
		_proto.sub = function sub(rhs) {
			this.x -= rhs.x;
			this.y -= rhs.y;
			return this;
		};
		_proto.sub2 = function sub2(lhs, rhs) {
			this.x = lhs.x - rhs.x;
			this.y = lhs.y - rhs.y;
			return this;
		};
		_proto.subScalar = function subScalar(scalar) {
			this.x -= scalar;
			this.y -= scalar;
			return this;
		};
		_proto.toString = function toString() {
			return "[" + this.x + ", " + this.y + "]";
		};
		Vec2.angleRad = function angleRad(lhs, rhs) {
			return Math.atan2(lhs.x * rhs.y - lhs.y * rhs.x, lhs.x * rhs.x + lhs.y * rhs.y);
		};
		return Vec2;
	}();
	_class$8 = Vec2;
	Vec2.ZERO = Object.freeze(new _class$8(0, 0));
	Vec2.ONE = Object.freeze(new _class$8(1, 1));
	Vec2.UP = Object.freeze(new _class$8(0, 1));
	Vec2.DOWN = Object.freeze(new _class$8(0, -1));
	Vec2.RIGHT = Object.freeze(new _class$8(1, 0));
	Vec2.LEFT = Object.freeze(new _class$8(-1, 0));

	var _class$7;
	var Vec4 = function () {
		function Vec4(x, y, z, w) {
			if (x === void 0) {
				x = 0;
			}
			if (y === void 0) {
				y = 0;
			}
			if (z === void 0) {
				z = 0;
			}
			if (w === void 0) {
				w = 0;
			}
			this.x = void 0;
			this.y = void 0;
			this.z = void 0;
			this.w = void 0;
			if (x.length === 4) {
				this.x = x[0];
				this.y = x[1];
				this.z = x[2];
				this.w = x[3];
			} else {
				this.x = x;
				this.y = y;
				this.z = z;
				this.w = w;
			}
		}
		var _proto = Vec4.prototype;
		_proto.add = function add(rhs) {
			this.x += rhs.x;
			this.y += rhs.y;
			this.z += rhs.z;
			this.w += rhs.w;
			return this;
		};
		_proto.add2 = function add2(lhs, rhs) {
			this.x = lhs.x + rhs.x;
			this.y = lhs.y + rhs.y;
			this.z = lhs.z + rhs.z;
			this.w = lhs.w + rhs.w;
			return this;
		};
		_proto.addScalar = function addScalar(scalar) {
			this.x += scalar;
			this.y += scalar;
			this.z += scalar;
			this.w += scalar;
			return this;
		};
		_proto.addScaled = function addScaled(rhs, scalar) {
			this.x += rhs.x * scalar;
			this.y += rhs.y * scalar;
			this.z += rhs.z * scalar;
			this.w += rhs.w * scalar;
			return this;
		};
		_proto.clone = function clone() {
			var cstr = this.constructor;
			return new cstr(this.x, this.y, this.z, this.w);
		};
		_proto.copy = function copy(rhs) {
			this.x = rhs.x;
			this.y = rhs.y;
			this.z = rhs.z;
			this.w = rhs.w;
			return this;
		};
		_proto.div = function div(rhs) {
			this.x /= rhs.x;
			this.y /= rhs.y;
			this.z /= rhs.z;
			this.w /= rhs.w;
			return this;
		};
		_proto.div2 = function div2(lhs, rhs) {
			this.x = lhs.x / rhs.x;
			this.y = lhs.y / rhs.y;
			this.z = lhs.z / rhs.z;
			this.w = lhs.w / rhs.w;
			return this;
		};
		_proto.divScalar = function divScalar(scalar) {
			this.x /= scalar;
			this.y /= scalar;
			this.z /= scalar;
			this.w /= scalar;
			return this;
		};
		_proto.dot = function dot(rhs) {
			return this.x * rhs.x + this.y * rhs.y + this.z * rhs.z + this.w * rhs.w;
		};
		_proto.equals = function equals(rhs) {
			return this.x === rhs.x && this.y === rhs.y && this.z === rhs.z && this.w === rhs.w;
		};
		_proto.equalsApprox = function equalsApprox(rhs, epsilon) {
			if (epsilon === void 0) {
				epsilon = 1e-6;
			}
			return Math.abs(this.x - rhs.x) < epsilon && Math.abs(this.y - rhs.y) < epsilon && Math.abs(this.z - rhs.z) < epsilon && Math.abs(this.w - rhs.w) < epsilon;
		};
		_proto.length = function length() {
			return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
		};
		_proto.lengthSq = function lengthSq() {
			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
		};
		_proto.lerp = function lerp(lhs, rhs, alpha) {
			this.x = lhs.x + alpha * (rhs.x - lhs.x);
			this.y = lhs.y + alpha * (rhs.y - lhs.y);
			this.z = lhs.z + alpha * (rhs.z - lhs.z);
			this.w = lhs.w + alpha * (rhs.w - lhs.w);
			return this;
		};
		_proto.mul = function mul(rhs) {
			this.x *= rhs.x;
			this.y *= rhs.y;
			this.z *= rhs.z;
			this.w *= rhs.w;
			return this;
		};
		_proto.mul2 = function mul2(lhs, rhs) {
			this.x = lhs.x * rhs.x;
			this.y = lhs.y * rhs.y;
			this.z = lhs.z * rhs.z;
			this.w = lhs.w * rhs.w;
			return this;
		};
		_proto.mulScalar = function mulScalar(scalar) {
			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			this.w *= scalar;
			return this;
		};
		_proto.normalize = function normalize(src) {
			if (src === void 0) {
				src = this;
			}
			var lengthSq = src.x * src.x + src.y * src.y + src.z * src.z + src.w * src.w;
			if (lengthSq > 0) {
				var invLength = 1 / Math.sqrt(lengthSq);
				this.x = src.x * invLength;
				this.y = src.y * invLength;
				this.z = src.z * invLength;
				this.w = src.w * invLength;
			}
			return this;
		};
		_proto.floor = function floor(src) {
			if (src === void 0) {
				src = this;
			}
			this.x = Math.floor(src.x);
			this.y = Math.floor(src.y);
			this.z = Math.floor(src.z);
			this.w = Math.floor(src.w);
			return this;
		};
		_proto.ceil = function ceil(src) {
			if (src === void 0) {
				src = this;
			}
			this.x = Math.ceil(src.x);
			this.y = Math.ceil(src.y);
			this.z = Math.ceil(src.z);
			this.w = Math.ceil(src.w);
			return this;
		};
		_proto.round = function round(src) {
			if (src === void 0) {
				src = this;
			}
			this.x = Math.round(src.x);
			this.y = Math.round(src.y);
			this.z = Math.round(src.z);
			this.w = Math.round(src.w);
			return this;
		};
		_proto.min = function min(rhs) {
			if (rhs.x < this.x) this.x = rhs.x;
			if (rhs.y < this.y) this.y = rhs.y;
			if (rhs.z < this.z) this.z = rhs.z;
			if (rhs.w < this.w) this.w = rhs.w;
			return this;
		};
		_proto.max = function max(rhs) {
			if (rhs.x > this.x) this.x = rhs.x;
			if (rhs.y > this.y) this.y = rhs.y;
			if (rhs.z > this.z) this.z = rhs.z;
			if (rhs.w > this.w) this.w = rhs.w;
			return this;
		};
		_proto.set = function set(x, y, z, w) {
			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;
			return this;
		};
		_proto.sub = function sub(rhs) {
			this.x -= rhs.x;
			this.y -= rhs.y;
			this.z -= rhs.z;
			this.w -= rhs.w;
			return this;
		};
		_proto.sub2 = function sub2(lhs, rhs) {
			this.x = lhs.x - rhs.x;
			this.y = lhs.y - rhs.y;
			this.z = lhs.z - rhs.z;
			this.w = lhs.w - rhs.w;
			return this;
		};
		_proto.subScalar = function subScalar(scalar) {
			this.x -= scalar;
			this.y -= scalar;
			this.z -= scalar;
			this.w -= scalar;
			return this;
		};
		_proto.toString = function toString() {
			return "[" + this.x + ", " + this.y + ", " + this.z + ", " + this.w + "]";
		};
		return Vec4;
	}();
	_class$7 = Vec4;
	Vec4.ZERO = Object.freeze(new _class$7(0, 0, 0, 0));
	Vec4.ONE = Object.freeze(new _class$7(1, 1, 1, 1));

	var _class$6;
	var _halfSize$1 = new Vec2();
	var x = new Vec3();
	var y = new Vec3();
	var z = new Vec3();
	var scale = new Vec3();
	var Mat4 = function () {
		function Mat4() {
			this.data = new Float32Array(16);
			this.data[0] = this.data[5] = this.data[10] = this.data[15] = 1;
		}
		Mat4._getPerspectiveHalfSize = function _getPerspectiveHalfSize(halfSize, fov, aspect, znear, fovIsHorizontal) {
			if (fovIsHorizontal) {
				halfSize.x = znear * Math.tan(fov * Math.PI / 360);
				halfSize.y = halfSize.x / aspect;
			} else {
				halfSize.y = znear * Math.tan(fov * Math.PI / 360);
				halfSize.x = halfSize.y * aspect;
			}
		};
		var _proto = Mat4.prototype;
		_proto.add2 = function add2(lhs, rhs) {
			var a = lhs.data,
				b = rhs.data,
				r = this.data;
			r[0] = a[0] + b[0];
			r[1] = a[1] + b[1];
			r[2] = a[2] + b[2];
			r[3] = a[3] + b[3];
			r[4] = a[4] + b[4];
			r[5] = a[5] + b[5];
			r[6] = a[6] + b[6];
			r[7] = a[7] + b[7];
			r[8] = a[8] + b[8];
			r[9] = a[9] + b[9];
			r[10] = a[10] + b[10];
			r[11] = a[11] + b[11];
			r[12] = a[12] + b[12];
			r[13] = a[13] + b[13];
			r[14] = a[14] + b[14];
			r[15] = a[15] + b[15];
			return this;
		};
		_proto.add = function add(rhs) {
			return this.add2(this, rhs);
		};
		_proto.clone = function clone() {
			var cstr = this.constructor;
			return new cstr().copy(this);
		};
		_proto.copy = function copy(rhs) {
			var src = rhs.data,
				dst = this.data;
			dst[0] = src[0];
			dst[1] = src[1];
			dst[2] = src[2];
			dst[3] = src[3];
			dst[4] = src[4];
			dst[5] = src[5];
			dst[6] = src[6];
			dst[7] = src[7];
			dst[8] = src[8];
			dst[9] = src[9];
			dst[10] = src[10];
			dst[11] = src[11];
			dst[12] = src[12];
			dst[13] = src[13];
			dst[14] = src[14];
			dst[15] = src[15];
			return this;
		};
		_proto.equals = function equals(rhs) {
			var l = this.data,
				r = rhs.data;
			return l[0] === r[0] && l[1] === r[1] && l[2] === r[2] && l[3] === r[3] && l[4] === r[4] && l[5] === r[5] && l[6] === r[6] && l[7] === r[7] && l[8] === r[8] && l[9] === r[9] && l[10] === r[10] && l[11] === r[11] && l[12] === r[12] && l[13] === r[13] && l[14] === r[14] && l[15] === r[15];
		};
		_proto.isIdentity = function isIdentity() {
			var m = this.data;
			return m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 0 && m[4] === 0 && m[5] === 1 && m[6] === 0 && m[7] === 0 && m[8] === 0 && m[9] === 0 && m[10] === 1 && m[11] === 0 && m[12] === 0 && m[13] === 0 && m[14] === 0 && m[15] === 1;
		};
		_proto.mul2 = function mul2(lhs, rhs) {
			var a = lhs.data;
			var b = rhs.data;
			var r = this.data;
			var a00 = a[0];
			var a01 = a[1];
			var a02 = a[2];
			var a03 = a[3];
			var a10 = a[4];
			var a11 = a[5];
			var a12 = a[6];
			var a13 = a[7];
			var a20 = a[8];
			var a21 = a[9];
			var a22 = a[10];
			var a23 = a[11];
			var a30 = a[12];
			var a31 = a[13];
			var a32 = a[14];
			var a33 = a[15];
			var b0, b1, b2, b3;
			b0 = b[0];
			b1 = b[1];
			b2 = b[2];
			b3 = b[3];
			r[0] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
			r[1] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
			r[2] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
			r[3] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;
			b0 = b[4];
			b1 = b[5];
			b2 = b[6];
			b3 = b[7];
			r[4] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
			r[5] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
			r[6] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
			r[7] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;
			b0 = b[8];
			b1 = b[9];
			b2 = b[10];
			b3 = b[11];
			r[8] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
			r[9] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
			r[10] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
			r[11] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;
			b0 = b[12];
			b1 = b[13];
			b2 = b[14];
			b3 = b[15];
			r[12] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
			r[13] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
			r[14] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
			r[15] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;
			return this;
		};
		_proto.mulAffine2 = function mulAffine2(lhs, rhs) {
			var a = lhs.data;
			var b = rhs.data;
			var r = this.data;
			var a00 = a[0];
			var a01 = a[1];
			var a02 = a[2];
			var a10 = a[4];
			var a11 = a[5];
			var a12 = a[6];
			var a20 = a[8];
			var a21 = a[9];
			var a22 = a[10];
			var a30 = a[12];
			var a31 = a[13];
			var a32 = a[14];
			var b0, b1, b2;
			b0 = b[0];
			b1 = b[1];
			b2 = b[2];
			r[0] = a00 * b0 + a10 * b1 + a20 * b2;
			r[1] = a01 * b0 + a11 * b1 + a21 * b2;
			r[2] = a02 * b0 + a12 * b1 + a22 * b2;
			r[3] = 0;
			b0 = b[4];
			b1 = b[5];
			b2 = b[6];
			r[4] = a00 * b0 + a10 * b1 + a20 * b2;
			r[5] = a01 * b0 + a11 * b1 + a21 * b2;
			r[6] = a02 * b0 + a12 * b1 + a22 * b2;
			r[7] = 0;
			b0 = b[8];
			b1 = b[9];
			b2 = b[10];
			r[8] = a00 * b0 + a10 * b1 + a20 * b2;
			r[9] = a01 * b0 + a11 * b1 + a21 * b2;
			r[10] = a02 * b0 + a12 * b1 + a22 * b2;
			r[11] = 0;
			b0 = b[12];
			b1 = b[13];
			b2 = b[14];
			r[12] = a00 * b0 + a10 * b1 + a20 * b2 + a30;
			r[13] = a01 * b0 + a11 * b1 + a21 * b2 + a31;
			r[14] = a02 * b0 + a12 * b1 + a22 * b2 + a32;
			r[15] = 1;
			return this;
		};
		_proto.mul = function mul(rhs) {
			return this.mul2(this, rhs);
		};
		_proto.transformPoint = function transformPoint(vec, res) {
			if (res === void 0) {
				res = new Vec3();
			}
			var m = this.data;
			var x = vec.x;
			var y = vec.y;
			var z = vec.z;
			res.x = x * m[0] + y * m[4] + z * m[8] + m[12];
			res.y = x * m[1] + y * m[5] + z * m[9] + m[13];
			res.z = x * m[2] + y * m[6] + z * m[10] + m[14];
			return res;
		};
		_proto.transformVector = function transformVector(vec, res) {
			if (res === void 0) {
				res = new Vec3();
			}
			var m = this.data;
			var x = vec.x;
			var y = vec.y;
			var z = vec.z;
			res.x = x * m[0] + y * m[4] + z * m[8];
			res.y = x * m[1] + y * m[5] + z * m[9];
			res.z = x * m[2] + y * m[6] + z * m[10];
			return res;
		};
		_proto.transformVec4 = function transformVec4(vec, res) {
			if (res === void 0) {
				res = new Vec4();
			}
			var m = this.data;
			var x = vec.x;
			var y = vec.y;
			var z = vec.z;
			var w = vec.w;
			res.x = x * m[0] + y * m[4] + z * m[8] + w * m[12];
			res.y = x * m[1] + y * m[5] + z * m[9] + w * m[13];
			res.z = x * m[2] + y * m[6] + z * m[10] + w * m[14];
			res.w = x * m[3] + y * m[7] + z * m[11] + w * m[15];
			return res;
		};
		_proto.setLookAt = function setLookAt(position, target, up) {
			z.sub2(position, target).normalize();
			y.copy(up).normalize();
			x.cross(y, z).normalize();
			y.cross(z, x);
			var r = this.data;
			r[0] = x.x;
			r[1] = x.y;
			r[2] = x.z;
			r[3] = 0;
			r[4] = y.x;
			r[5] = y.y;
			r[6] = y.z;
			r[7] = 0;
			r[8] = z.x;
			r[9] = z.y;
			r[10] = z.z;
			r[11] = 0;
			r[12] = position.x;
			r[13] = position.y;
			r[14] = position.z;
			r[15] = 1;
			return this;
		};
		_proto.setFrustum = function setFrustum(left, right, bottom, top, znear, zfar) {
			var temp1 = 2 * znear;
			var temp2 = right - left;
			var temp3 = top - bottom;
			var temp4 = zfar - znear;
			var r = this.data;
			r[0] = temp1 / temp2;
			r[1] = 0;
			r[2] = 0;
			r[3] = 0;
			r[4] = 0;
			r[5] = temp1 / temp3;
			r[6] = 0;
			r[7] = 0;
			r[8] = (right + left) / temp2;
			r[9] = (top + bottom) / temp3;
			r[10] = (-zfar - znear) / temp4;
			r[11] = -1;
			r[12] = 0;
			r[13] = 0;
			r[14] = -temp1 * zfar / temp4;
			r[15] = 0;
			return this;
		};
		_proto.setPerspective = function setPerspective(fov, aspect, znear, zfar, fovIsHorizontal) {
			Mat4._getPerspectiveHalfSize(_halfSize$1, fov, aspect, znear, fovIsHorizontal);
			return this.setFrustum(-_halfSize$1.x, _halfSize$1.x, -_halfSize$1.y, _halfSize$1.y, znear, zfar);
		};
		_proto.setOrtho = function setOrtho(left, right, bottom, top, near, far) {
			var r = this.data;
			r[0] = 2 / (right - left);
			r[1] = 0;
			r[2] = 0;
			r[3] = 0;
			r[4] = 0;
			r[5] = 2 / (top - bottom);
			r[6] = 0;
			r[7] = 0;
			r[8] = 0;
			r[9] = 0;
			r[10] = -2 / (far - near);
			r[11] = 0;
			r[12] = -(right + left) / (right - left);
			r[13] = -(top + bottom) / (top - bottom);
			r[14] = -(far + near) / (far - near);
			r[15] = 1;
			return this;
		};
		_proto.setFromAxisAngle = function setFromAxisAngle(axis, angle) {
			angle *= math.DEG_TO_RAD;
			var x = axis.x;
			var y = axis.y;
			var z = axis.z;
			var c = Math.cos(angle);
			var s = Math.sin(angle);
			var t = 1 - c;
			var tx = t * x;
			var ty = t * y;
			var m = this.data;
			m[0] = tx * x + c;
			m[1] = tx * y + s * z;
			m[2] = tx * z - s * y;
			m[3] = 0;
			m[4] = tx * y - s * z;
			m[5] = ty * y + c;
			m[6] = ty * z + s * x;
			m[7] = 0;
			m[8] = tx * z + s * y;
			m[9] = ty * z - x * s;
			m[10] = t * z * z + c;
			m[11] = 0;
			m[12] = 0;
			m[13] = 0;
			m[14] = 0;
			m[15] = 1;
			return this;
		};
		_proto.setTranslate = function setTranslate(x, y, z) {
			var m = this.data;
			m[0] = 1;
			m[1] = 0;
			m[2] = 0;
			m[3] = 0;
			m[4] = 0;
			m[5] = 1;
			m[6] = 0;
			m[7] = 0;
			m[8] = 0;
			m[9] = 0;
			m[10] = 1;
			m[11] = 0;
			m[12] = x;
			m[13] = y;
			m[14] = z;
			m[15] = 1;
			return this;
		};
		_proto.setScale = function setScale(x, y, z) {
			var m = this.data;
			m[0] = x;
			m[1] = 0;
			m[2] = 0;
			m[3] = 0;
			m[4] = 0;
			m[5] = y;
			m[6] = 0;
			m[7] = 0;
			m[8] = 0;
			m[9] = 0;
			m[10] = z;
			m[11] = 0;
			m[12] = 0;
			m[13] = 0;
			m[14] = 0;
			m[15] = 1;
			return this;
		};
		_proto.setViewport = function setViewport(x, y, width, height) {
			var m = this.data;
			m[0] = width * 0.5;
			m[1] = 0;
			m[2] = 0;
			m[3] = 0;
			m[4] = 0;
			m[5] = height * 0.5;
			m[6] = 0;
			m[7] = 0;
			m[8] = 0;
			m[9] = 0;
			m[10] = 0.5;
			m[11] = 0;
			m[12] = x + width * 0.5;
			m[13] = y + height * 0.5;
			m[14] = 0.5;
			m[15] = 1;
			return this;
		};
		_proto.setReflection = function setReflection(normal, distance) {
			var a = normal.x;
			var b = normal.y;
			var c = normal.z;
			var data = this.data;
			data[0] = 1.0 - 2 * a * a;
			data[1] = -2 * a * b;
			data[2] = -2 * a * c;
			data[3] = 0;
			data[4] = -2 * a * b;
			data[5] = 1.0 - 2 * b * b;
			data[6] = -2 * b * c;
			data[7] = 0;
			data[8] = -2 * a * c;
			data[9] = -2 * b * c;
			data[10] = 1.0 - 2 * c * c;
			data[11] = 0;
			data[12] = -2 * a * distance;
			data[13] = -2 * b * distance;
			data[14] = -2 * c * distance;
			data[15] = 1;
			return this;
		};
		_proto.invert = function invert(src) {
			if (src === void 0) {
				src = this;
			}
			var s = src.data;
			var a00 = s[0];
			var a01 = s[1];
			var a02 = s[2];
			var a03 = s[3];
			var a10 = s[4];
			var a11 = s[5];
			var a12 = s[6];
			var a13 = s[7];
			var a20 = s[8];
			var a21 = s[9];
			var a22 = s[10];
			var a23 = s[11];
			var a30 = s[12];
			var a31 = s[13];
			var a32 = s[14];
			var a33 = s[15];
			var b00 = a00 * a11 - a01 * a10;
			var b01 = a00 * a12 - a02 * a10;
			var b02 = a00 * a13 - a03 * a10;
			var b03 = a01 * a12 - a02 * a11;
			var b04 = a01 * a13 - a03 * a11;
			var b05 = a02 * a13 - a03 * a12;
			var b06 = a20 * a31 - a21 * a30;
			var b07 = a20 * a32 - a22 * a30;
			var b08 = a20 * a33 - a23 * a30;
			var b09 = a21 * a32 - a22 * a31;
			var b10 = a21 * a33 - a23 * a31;
			var b11 = a22 * a33 - a23 * a32;
			var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
			if (det === 0) {
				this.setIdentity();
			} else {
				var invDet = 1 / det;
				var t = this.data;
				t[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;
				t[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;
				t[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;
				t[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;
				t[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * invDet;
				t[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;
				t[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * invDet;
				t[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;
				t[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;
				t[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;
				t[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;
				t[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;
				t[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet;
				t[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;
				t[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet;
				t[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;
			}
			return this;
		};
		_proto.set = function set(src) {
			var dst = this.data;
			dst[0] = src[0];
			dst[1] = src[1];
			dst[2] = src[2];
			dst[3] = src[3];
			dst[4] = src[4];
			dst[5] = src[5];
			dst[6] = src[6];
			dst[7] = src[7];
			dst[8] = src[8];
			dst[9] = src[9];
			dst[10] = src[10];
			dst[11] = src[11];
			dst[12] = src[12];
			dst[13] = src[13];
			dst[14] = src[14];
			dst[15] = src[15];
			return this;
		};
		_proto.setIdentity = function setIdentity() {
			var m = this.data;
			m[0] = 1;
			m[1] = 0;
			m[2] = 0;
			m[3] = 0;
			m[4] = 0;
			m[5] = 1;
			m[6] = 0;
			m[7] = 0;
			m[8] = 0;
			m[9] = 0;
			m[10] = 1;
			m[11] = 0;
			m[12] = 0;
			m[13] = 0;
			m[14] = 0;
			m[15] = 1;
			return this;
		};
		_proto.setTRS = function setTRS(t, r, s) {
			var qx = r.x;
			var qy = r.y;
			var qz = r.z;
			var qw = r.w;
			var sx = s.x;
			var sy = s.y;
			var sz = s.z;
			var x2 = qx + qx;
			var y2 = qy + qy;
			var z2 = qz + qz;
			var xx = qx * x2;
			var xy = qx * y2;
			var xz = qx * z2;
			var yy = qy * y2;
			var yz = qy * z2;
			var zz = qz * z2;
			var wx = qw * x2;
			var wy = qw * y2;
			var wz = qw * z2;
			var m = this.data;
			m[0] = (1 - (yy + zz)) * sx;
			m[1] = (xy + wz) * sx;
			m[2] = (xz - wy) * sx;
			m[3] = 0;
			m[4] = (xy - wz) * sy;
			m[5] = (1 - (xx + zz)) * sy;
			m[6] = (yz + wx) * sy;
			m[7] = 0;
			m[8] = (xz + wy) * sz;
			m[9] = (yz - wx) * sz;
			m[10] = (1 - (xx + yy)) * sz;
			m[11] = 0;
			m[12] = t.x;
			m[13] = t.y;
			m[14] = t.z;
			m[15] = 1;
			return this;
		};
		_proto.transpose = function transpose(src) {
			if (src === void 0) {
				src = this;
			}
			var s = src.data;
			var t = this.data;
			if (s === t) {
				var tmp;
				tmp = s[1];
				t[1] = s[4];
				t[4] = tmp;
				tmp = s[2];
				t[2] = s[8];
				t[8] = tmp;
				tmp = s[3];
				t[3] = s[12];
				t[12] = tmp;
				tmp = s[6];
				t[6] = s[9];
				t[9] = tmp;
				tmp = s[7];
				t[7] = s[13];
				t[13] = tmp;
				tmp = s[11];
				t[11] = s[14];
				t[14] = tmp;
			} else {
				t[0] = s[0];
				t[1] = s[4];
				t[2] = s[8];
				t[3] = s[12];
				t[4] = s[1];
				t[5] = s[5];
				t[6] = s[9];
				t[7] = s[13];
				t[8] = s[2];
				t[9] = s[6];
				t[10] = s[10];
				t[11] = s[14];
				t[12] = s[3];
				t[13] = s[7];
				t[14] = s[11];
				t[15] = s[15];
			}
			return this;
		};
		_proto.getTranslation = function getTranslation(t) {
			if (t === void 0) {
				t = new Vec3();
			}
			return t.set(this.data[12], this.data[13], this.data[14]);
		};
		_proto.getX = function getX(x) {
			if (x === void 0) {
				x = new Vec3();
			}
			return x.set(this.data[0], this.data[1], this.data[2]);
		};
		_proto.getY = function getY(y) {
			if (y === void 0) {
				y = new Vec3();
			}
			return y.set(this.data[4], this.data[5], this.data[6]);
		};
		_proto.getZ = function getZ(z) {
			if (z === void 0) {
				z = new Vec3();
			}
			return z.set(this.data[8], this.data[9], this.data[10]);
		};
		_proto.getScale = function getScale(scale) {
			if (scale === void 0) {
				scale = new Vec3();
			}
			this.getX(x);
			this.getY(y);
			this.getZ(z);
			scale.set(x.length(), y.length(), z.length());
			return scale;
		};
		_proto.setFromEulerAngles = function setFromEulerAngles(ex, ey, ez) {
			ex *= math.DEG_TO_RAD;
			ey *= math.DEG_TO_RAD;
			ez *= math.DEG_TO_RAD;
			var s1 = Math.sin(-ex);
			var c1 = Math.cos(-ex);
			var s2 = Math.sin(-ey);
			var c2 = Math.cos(-ey);
			var s3 = Math.sin(-ez);
			var c3 = Math.cos(-ez);
			var m = this.data;
			m[0] = c2 * c3;
			m[1] = -c2 * s3;
			m[2] = s2;
			m[3] = 0;
			m[4] = c1 * s3 + c3 * s1 * s2;
			m[5] = c1 * c3 - s1 * s2 * s3;
			m[6] = -c2 * s1;
			m[7] = 0;
			m[8] = s1 * s3 - c1 * c3 * s2;
			m[9] = c3 * s1 + c1 * s2 * s3;
			m[10] = c1 * c2;
			m[11] = 0;
			m[12] = 0;
			m[13] = 0;
			m[14] = 0;
			m[15] = 1;
			return this;
		};
		_proto.getEulerAngles = function getEulerAngles(eulers) {
			if (eulers === void 0) {
				eulers = new Vec3();
			}
			this.getScale(scale);
			var sx = scale.x;
			var sy = scale.y;
			var sz = scale.z;
			if (sx === 0 || sy === 0 || sz === 0) return eulers.set(0, 0, 0);
			var m = this.data;
			var y = Math.asin(-m[2] / sx);
			var halfPi = Math.PI * 0.5;
			var x, z;
			if (y < halfPi) {
				if (y > -halfPi) {
					x = Math.atan2(m[6] / sy, m[10] / sz);
					z = Math.atan2(m[1] / sx, m[0] / sx);
				} else {
					z = 0;
					x = -Math.atan2(m[4] / sy, m[5] / sy);
				}
			} else {
				z = 0;
				x = Math.atan2(m[4] / sy, m[5] / sy);
			}
			return eulers.set(x, y, z).mulScalar(math.RAD_TO_DEG);
		};
		_proto.toString = function toString() {
			return '[' + this.data.join(', ') + ']';
		};
		_createClass(Mat4, [{
			key: "scaleSign",
			get: function get() {
				this.getX(x);
				this.getY(y);
				this.getZ(z);
				x.cross(x, y);
				return x.dot(z) < 0 ? -1 : 1;
			}
		}]);
		return Mat4;
	}();
	_class$6 = Mat4;
	Mat4.IDENTITY = Object.freeze(new _class$6());
	Mat4.ZERO = Object.freeze(new _class$6().set([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]));

	var _class$5;
	var Quat = function () {
		function Quat(x, y, z, w) {
			if (x === void 0) {
				x = 0;
			}
			if (y === void 0) {
				y = 0;
			}
			if (z === void 0) {
				z = 0;
			}
			if (w === void 0) {
				w = 1;
			}
			this.x = void 0;
			this.y = void 0;
			this.z = void 0;
			this.w = void 0;
			if (x.length === 4) {
				this.x = x[0];
				this.y = x[1];
				this.z = x[2];
				this.w = x[3];
			} else {
				this.x = x;
				this.y = y;
				this.z = z;
				this.w = w;
			}
		}
		var _proto = Quat.prototype;
		_proto.clone = function clone() {
			var cstr = this.constructor;
			return new cstr(this.x, this.y, this.z, this.w);
		};
		_proto.conjugate = function conjugate(src) {
			if (src === void 0) {
				src = this;
			}
			this.x = src.x * -1;
			this.y = src.y * -1;
			this.z = src.z * -1;
			this.w = src.w;
			return this;
		};
		_proto.copy = function copy(rhs) {
			this.x = rhs.x;
			this.y = rhs.y;
			this.z = rhs.z;
			this.w = rhs.w;
			return this;
		};
		_proto.equals = function equals(rhs) {
			return this.x === rhs.x && this.y === rhs.y && this.z === rhs.z && this.w === rhs.w;
		};
		_proto.equalsApprox = function equalsApprox(rhs, epsilon) {
			if (epsilon === void 0) {
				epsilon = 1e-6;
			}
			return Math.abs(this.x - rhs.x) < epsilon && Math.abs(this.y - rhs.y) < epsilon && Math.abs(this.z - rhs.z) < epsilon && Math.abs(this.w - rhs.w) < epsilon;
		};
		_proto.getAxisAngle = function getAxisAngle(axis) {
			var rad = Math.acos(this.w) * 2;
			var s = Math.sin(rad / 2);
			if (s !== 0) {
				axis.x = this.x / s;
				axis.y = this.y / s;
				axis.z = this.z / s;
				if (axis.x < 0 || axis.y < 0 || axis.z < 0) {
					axis.x *= -1;
					axis.y *= -1;
					axis.z *= -1;
					rad *= -1;
				}
			} else {
				axis.x = 1;
				axis.y = 0;
				axis.z = 0;
			}
			return rad * math.RAD_TO_DEG;
		};
		_proto.getEulerAngles = function getEulerAngles(eulers) {
			if (eulers === void 0) {
				eulers = new Vec3();
			}
			var x, y, z;
			var qx = this.x;
			var qy = this.y;
			var qz = this.z;
			var qw = this.w;
			var a2 = 2 * (qw * qy - qx * qz);
			if (a2 <= -0.99999) {
				x = 2 * Math.atan2(qx, qw);
				y = -Math.PI / 2;
				z = 0;
			} else if (a2 >= 0.99999) {
				x = 2 * Math.atan2(qx, qw);
				y = Math.PI / 2;
				z = 0;
			} else {
				x = Math.atan2(2 * (qw * qx + qy * qz), 1 - 2 * (qx * qx + qy * qy));
				y = Math.asin(a2);
				z = Math.atan2(2 * (qw * qz + qx * qy), 1 - 2 * (qy * qy + qz * qz));
			}
			return eulers.set(x, y, z).mulScalar(math.RAD_TO_DEG);
		};
		_proto.invert = function invert(src) {
			if (src === void 0) {
				src = this;
			}
			return this.conjugate(src).normalize();
		};
		_proto.length = function length() {
			return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
		};
		_proto.lengthSq = function lengthSq() {
			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
		};
		_proto.mul = function mul(rhs) {
			var q1x = this.x;
			var q1y = this.y;
			var q1z = this.z;
			var q1w = this.w;
			var q2x = rhs.x;
			var q2y = rhs.y;
			var q2z = rhs.z;
			var q2w = rhs.w;
			this.x = q1w * q2x + q1x * q2w + q1y * q2z - q1z * q2y;
			this.y = q1w * q2y + q1y * q2w + q1z * q2x - q1x * q2z;
			this.z = q1w * q2z + q1z * q2w + q1x * q2y - q1y * q2x;
			this.w = q1w * q2w - q1x * q2x - q1y * q2y - q1z * q2z;
			return this;
		};
		_proto.mul2 = function mul2(lhs, rhs) {
			var q1x = lhs.x;
			var q1y = lhs.y;
			var q1z = lhs.z;
			var q1w = lhs.w;
			var q2x = rhs.x;
			var q2y = rhs.y;
			var q2z = rhs.z;
			var q2w = rhs.w;
			this.x = q1w * q2x + q1x * q2w + q1y * q2z - q1z * q2y;
			this.y = q1w * q2y + q1y * q2w + q1z * q2x - q1x * q2z;
			this.z = q1w * q2z + q1z * q2w + q1x * q2y - q1y * q2x;
			this.w = q1w * q2w - q1x * q2x - q1y * q2y - q1z * q2z;
			return this;
		};
		_proto.normalize = function normalize(src) {
			if (src === void 0) {
				src = this;
			}
			var len = src.length();
			if (len === 0) {
				this.x = this.y = this.z = 0;
				this.w = 1;
			} else {
				len = 1 / len;
				this.x = src.x * len;
				this.y = src.y * len;
				this.z = src.z * len;
				this.w = src.w * len;
			}
			return this;
		};
		_proto.set = function set(x, y, z, w) {
			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;
			return this;
		};
		_proto.setFromAxisAngle = function setFromAxisAngle(axis, angle) {
			angle *= 0.5 * math.DEG_TO_RAD;
			var sa = Math.sin(angle);
			var ca = Math.cos(angle);
			this.x = sa * axis.x;
			this.y = sa * axis.y;
			this.z = sa * axis.z;
			this.w = ca;
			return this;
		};
		_proto.setFromEulerAngles = function setFromEulerAngles(ex, ey, ez) {
			if (ex instanceof Vec3) {
				var vec = ex;
				ex = vec.x;
				ey = vec.y;
				ez = vec.z;
			}
			var halfToRad = 0.5 * math.DEG_TO_RAD;
			ex *= halfToRad;
			ey *= halfToRad;
			ez *= halfToRad;
			var sx = Math.sin(ex);
			var cx = Math.cos(ex);
			var sy = Math.sin(ey);
			var cy = Math.cos(ey);
			var sz = Math.sin(ez);
			var cz = Math.cos(ez);
			this.x = sx * cy * cz - cx * sy * sz;
			this.y = cx * sy * cz + sx * cy * sz;
			this.z = cx * cy * sz - sx * sy * cz;
			this.w = cx * cy * cz + sx * sy * sz;
			return this;
		};
		_proto.setFromMat4 = function setFromMat4(m) {
			var m00, m01, m02, m10, m11, m12, m20, m21, m22, s, rs, lx, ly, lz;
			m = m.data;
			m00 = m[0];
			m01 = m[1];
			m02 = m[2];
			m10 = m[4];
			m11 = m[5];
			m12 = m[6];
			m20 = m[8];
			m21 = m[9];
			m22 = m[10];
			lx = m00 * m00 + m01 * m01 + m02 * m02;
			if (lx === 0) return this;
			lx = 1 / Math.sqrt(lx);
			ly = m10 * m10 + m11 * m11 + m12 * m12;
			if (ly === 0) return this;
			ly = 1 / Math.sqrt(ly);
			lz = m20 * m20 + m21 * m21 + m22 * m22;
			if (lz === 0) return this;
			lz = 1 / Math.sqrt(lz);
			m00 *= lx;
			m01 *= lx;
			m02 *= lx;
			m10 *= ly;
			m11 *= ly;
			m12 *= ly;
			m20 *= lz;
			m21 *= lz;
			m22 *= lz;
			var tr = m00 + m11 + m22;
			if (tr >= 0) {
				s = Math.sqrt(tr + 1);
				this.w = s * 0.5;
				s = 0.5 / s;
				this.x = (m12 - m21) * s;
				this.y = (m20 - m02) * s;
				this.z = (m01 - m10) * s;
			} else {
				if (m00 > m11) {
					if (m00 > m22) {
						rs = m00 - (m11 + m22) + 1;
						rs = Math.sqrt(rs);
						this.x = rs * 0.5;
						rs = 0.5 / rs;
						this.w = (m12 - m21) * rs;
						this.y = (m01 + m10) * rs;
						this.z = (m02 + m20) * rs;
					} else {
						rs = m22 - (m00 + m11) + 1;
						rs = Math.sqrt(rs);
						this.z = rs * 0.5;
						rs = 0.5 / rs;
						this.w = (m01 - m10) * rs;
						this.x = (m20 + m02) * rs;
						this.y = (m21 + m12) * rs;
					}
				} else if (m11 > m22) {
					rs = m11 - (m22 + m00) + 1;
					rs = Math.sqrt(rs);
					this.y = rs * 0.5;
					rs = 0.5 / rs;
					this.w = (m20 - m02) * rs;
					this.z = (m12 + m21) * rs;
					this.x = (m10 + m01) * rs;
				} else {
					rs = m22 - (m00 + m11) + 1;
					rs = Math.sqrt(rs);
					this.z = rs * 0.5;
					rs = 0.5 / rs;
					this.w = (m01 - m10) * rs;
					this.x = (m20 + m02) * rs;
					this.y = (m21 + m12) * rs;
				}
			}
			return this;
		};
		_proto.setFromDirections = function setFromDirections(from, to) {
			var dotProduct = 1 + from.dot(to);
			if (dotProduct < Number.EPSILON) {
				if (Math.abs(from.x) > Math.abs(from.y)) {
					this.x = -from.z;
					this.y = 0;
					this.z = from.x;
					this.w = 0;
				} else {
					this.x = 0;
					this.y = -from.z;
					this.z = from.y;
					this.w = 0;
				}
			} else {
				this.x = from.y * to.z - from.z * to.y;
				this.y = from.z * to.x - from.x * to.z;
				this.z = from.x * to.y - from.y * to.x;
				this.w = dotProduct;
			}
			return this.normalize();
		};
		_proto.slerp = function slerp(lhs, rhs, alpha) {
			var lx = lhs.x;
			var ly = lhs.y;
			var lz = lhs.z;
			var lw = lhs.w;
			var rx = rhs.x;
			var ry = rhs.y;
			var rz = rhs.z;
			var rw = rhs.w;
			var cosHalfTheta = lw * rw + lx * rx + ly * ry + lz * rz;
			if (cosHalfTheta < 0) {
				rw = -rw;
				rx = -rx;
				ry = -ry;
				rz = -rz;
				cosHalfTheta = -cosHalfTheta;
			}
			if (Math.abs(cosHalfTheta) >= 1) {
				this.w = lw;
				this.x = lx;
				this.y = ly;
				this.z = lz;
				return this;
			}
			var halfTheta = Math.acos(cosHalfTheta);
			var sinHalfTheta = Math.sqrt(1 - cosHalfTheta * cosHalfTheta);
			if (Math.abs(sinHalfTheta) < 0.001) {
				this.w = lw * 0.5 + rw * 0.5;
				this.x = lx * 0.5 + rx * 0.5;
				this.y = ly * 0.5 + ry * 0.5;
				this.z = lz * 0.5 + rz * 0.5;
				return this;
			}
			var ratioA = Math.sin((1 - alpha) * halfTheta) / sinHalfTheta;
			var ratioB = Math.sin(alpha * halfTheta) / sinHalfTheta;
			this.w = lw * ratioA + rw * ratioB;
			this.x = lx * ratioA + rx * ratioB;
			this.y = ly * ratioA + ry * ratioB;
			this.z = lz * ratioA + rz * ratioB;
			return this;
		};
		_proto.transformVector = function transformVector(vec, res) {
			if (res === void 0) {
				res = new Vec3();
			}
			var x = vec.x,
				y = vec.y,
				z = vec.z;
			var qx = this.x,
				qy = this.y,
				qz = this.z,
				qw = this.w;
			var ix = qw * x + qy * z - qz * y;
			var iy = qw * y + qz * x - qx * z;
			var iz = qw * z + qx * y - qy * x;
			var iw = -qx * x - qy * y - qz * z;
			res.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
			res.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
			res.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
			return res;
		};
		_proto.toString = function toString() {
			return "[" + this.x + ", " + this.y + ", " + this.z + ", " + this.w + "]";
		};
		return Quat;
	}();
	_class$5 = Quat;
	Quat.IDENTITY = Object.freeze(new _class$5(0, 0, 0, 1));
	Quat.ZERO = Object.freeze(new _class$5(0, 0, 0, 0));

	var tmpVecA$1 = new Vec3();
	var tmpVecB$1 = new Vec3();
	var tmpVecC = new Vec3();
	var tmpVecD = new Vec3();
	var tmpVecE = new Vec3();
	var BoundingBox = function () {
		function BoundingBox(center, halfExtents) {
			if (center === void 0) {
				center = new Vec3();
			}
			if (halfExtents === void 0) {
				halfExtents = new Vec3(0.5, 0.5, 0.5);
			}
			this.center = void 0;
			this.halfExtents = void 0;
			this._min = new Vec3();
			this._max = new Vec3();
			this.center = center;
			this.halfExtents = halfExtents;
		}
		var _proto = BoundingBox.prototype;
		_proto.add = function add(other) {
			var tc = this.center;
			var tcx = tc.x;
			var tcy = tc.y;
			var tcz = tc.z;
			var th = this.halfExtents;
			var thx = th.x;
			var thy = th.y;
			var thz = th.z;
			var tminx = tcx - thx;
			var tmaxx = tcx + thx;
			var tminy = tcy - thy;
			var tmaxy = tcy + thy;
			var tminz = tcz - thz;
			var tmaxz = tcz + thz;
			var oc = other.center;
			var ocx = oc.x;
			var ocy = oc.y;
			var ocz = oc.z;
			var oh = other.halfExtents;
			var ohx = oh.x;
			var ohy = oh.y;
			var ohz = oh.z;
			var ominx = ocx - ohx;
			var omaxx = ocx + ohx;
			var ominy = ocy - ohy;
			var omaxy = ocy + ohy;
			var ominz = ocz - ohz;
			var omaxz = ocz + ohz;
			if (ominx < tminx) tminx = ominx;
			if (omaxx > tmaxx) tmaxx = omaxx;
			if (ominy < tminy) tminy = ominy;
			if (omaxy > tmaxy) tmaxy = omaxy;
			if (ominz < tminz) tminz = ominz;
			if (omaxz > tmaxz) tmaxz = omaxz;
			tc.x = (tminx + tmaxx) * 0.5;
			tc.y = (tminy + tmaxy) * 0.5;
			tc.z = (tminz + tmaxz) * 0.5;
			th.x = (tmaxx - tminx) * 0.5;
			th.y = (tmaxy - tminy) * 0.5;
			th.z = (tmaxz - tminz) * 0.5;
		};
		_proto.copy = function copy(src) {
			this.center.copy(src.center);
			this.halfExtents.copy(src.halfExtents);
		};
		_proto.clone = function clone() {
			return new BoundingBox(this.center.clone(), this.halfExtents.clone());
		};
		_proto.intersects = function intersects(other) {
			var aMax = this.getMax();
			var aMin = this.getMin();
			var bMax = other.getMax();
			var bMin = other.getMin();
			return aMin.x <= bMax.x && aMax.x >= bMin.x && aMin.y <= bMax.y && aMax.y >= bMin.y && aMin.z <= bMax.z && aMax.z >= bMin.z;
		};
		_proto._intersectsRay = function _intersectsRay(ray, point) {
			var tMin = tmpVecA$1.copy(this.getMin()).sub(ray.origin);
			var tMax = tmpVecB$1.copy(this.getMax()).sub(ray.origin);
			var dir = ray.direction;
			if (dir.x === 0) {
				tMin.x = tMin.x < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
				tMax.x = tMax.x < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
			} else {
				tMin.x /= dir.x;
				tMax.x /= dir.x;
			}
			if (dir.y === 0) {
				tMin.y = tMin.y < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
				tMax.y = tMax.y < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
			} else {
				tMin.y /= dir.y;
				tMax.y /= dir.y;
			}
			if (dir.z === 0) {
				tMin.z = tMin.z < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
				tMax.z = tMax.z < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
			} else {
				tMin.z /= dir.z;
				tMax.z /= dir.z;
			}
			var realMin = tmpVecC.set(Math.min(tMin.x, tMax.x), Math.min(tMin.y, tMax.y), Math.min(tMin.z, tMax.z));
			var realMax = tmpVecD.set(Math.max(tMin.x, tMax.x), Math.max(tMin.y, tMax.y), Math.max(tMin.z, tMax.z));
			var minMax = Math.min(Math.min(realMax.x, realMax.y), realMax.z);
			var maxMin = Math.max(Math.max(realMin.x, realMin.y), realMin.z);
			var intersects = minMax >= maxMin && maxMin >= 0;
			if (intersects) point.copy(ray.direction).mulScalar(maxMin).add(ray.origin);
			return intersects;
		};
		_proto._fastIntersectsRay = function _fastIntersectsRay(ray) {
			var diff = tmpVecA$1;
			var cross = tmpVecB$1;
			var prod = tmpVecC;
			var absDiff = tmpVecD;
			var absDir = tmpVecE;
			var rayDir = ray.direction;
			diff.sub2(ray.origin, this.center);
			absDiff.set(Math.abs(diff.x), Math.abs(diff.y), Math.abs(diff.z));
			prod.mul2(diff, rayDir);
			if (absDiff.x > this.halfExtents.x && prod.x >= 0) return false;
			if (absDiff.y > this.halfExtents.y && prod.y >= 0) return false;
			if (absDiff.z > this.halfExtents.z && prod.z >= 0) return false;
			absDir.set(Math.abs(rayDir.x), Math.abs(rayDir.y), Math.abs(rayDir.z));
			cross.cross(rayDir, diff);
			cross.set(Math.abs(cross.x), Math.abs(cross.y), Math.abs(cross.z));
			if (cross.x > this.halfExtents.y * absDir.z + this.halfExtents.z * absDir.y) return false;
			if (cross.y > this.halfExtents.x * absDir.z + this.halfExtents.z * absDir.x) return false;
			if (cross.z > this.halfExtents.x * absDir.y + this.halfExtents.y * absDir.x) return false;
			return true;
		};
		_proto.intersectsRay = function intersectsRay(ray, point) {
			if (point) {
				return this._intersectsRay(ray, point);
			}
			return this._fastIntersectsRay(ray);
		};
		_proto.setMinMax = function setMinMax(min, max) {
			this.center.add2(max, min).mulScalar(0.5);
			this.halfExtents.sub2(max, min).mulScalar(0.5);
		};
		_proto.getMin = function getMin() {
			return this._min.copy(this.center).sub(this.halfExtents);
		};
		_proto.getMax = function getMax() {
			return this._max.copy(this.center).add(this.halfExtents);
		};
		_proto.containsPoint = function containsPoint(point) {
			var min = this.getMin();
			var max = this.getMax();
			if (point.x < min.x || point.x > max.x || point.y < min.y || point.y > max.y || point.z < min.z || point.z > max.z) {
				return false;
			}
			return true;
		};
		_proto.setFromTransformedAabb = function setFromTransformedAabb(aabb, m, ignoreScale) {
			if (ignoreScale === void 0) {
				ignoreScale = false;
			}
			var ac = aabb.center;
			var ar = aabb.halfExtents;
			var d = m.data;
			var mx0 = d[0];
			var mx1 = d[4];
			var mx2 = d[8];
			var my0 = d[1];
			var my1 = d[5];
			var my2 = d[9];
			var mz0 = d[2];
			var mz1 = d[6];
			var mz2 = d[10];
			if (ignoreScale) {
				var lengthSq = mx0 * mx0 + mx1 * mx1 + mx2 * mx2;
				if (lengthSq > 0) {
					var invLength = 1 / Math.sqrt(lengthSq);
					mx0 *= invLength;
					mx1 *= invLength;
					mx2 *= invLength;
				}
				lengthSq = my0 * my0 + my1 * my1 + my2 * my2;
				if (lengthSq > 0) {
					var _invLength = 1 / Math.sqrt(lengthSq);
					my0 *= _invLength;
					my1 *= _invLength;
					my2 *= _invLength;
				}
				lengthSq = mz0 * mz0 + mz1 * mz1 + mz2 * mz2;
				if (lengthSq > 0) {
					var _invLength2 = 1 / Math.sqrt(lengthSq);
					mz0 *= _invLength2;
					mz1 *= _invLength2;
					mz2 *= _invLength2;
				}
			}
			this.center.set(d[12] + mx0 * ac.x + mx1 * ac.y + mx2 * ac.z, d[13] + my0 * ac.x + my1 * ac.y + my2 * ac.z, d[14] + mz0 * ac.x + mz1 * ac.y + mz2 * ac.z);
			this.halfExtents.set(Math.abs(mx0) * ar.x + Math.abs(mx1) * ar.y + Math.abs(mx2) * ar.z, Math.abs(my0) * ar.x + Math.abs(my1) * ar.y + Math.abs(my2) * ar.z, Math.abs(mz0) * ar.x + Math.abs(mz1) * ar.y + Math.abs(mz2) * ar.z);
		};
		BoundingBox.computeMinMax = function computeMinMax(vertices, min, max, numVerts) {
			if (numVerts === void 0) {
				numVerts = vertices.length / 3;
			}
			if (numVerts > 0) {
				var minx = vertices[0];
				var miny = vertices[1];
				var minz = vertices[2];
				var maxx = minx;
				var maxy = miny;
				var maxz = minz;
				var n = numVerts * 3;
				for (var i = 3; i < n; i += 3) {
					var x = vertices[i];
					var y = vertices[i + 1];
					var z = vertices[i + 2];
					if (x < minx) minx = x;
					if (y < miny) miny = y;
					if (z < minz) minz = z;
					if (x > maxx) maxx = x;
					if (y > maxy) maxy = y;
					if (z > maxz) maxz = z;
				}
				min.set(minx, miny, minz);
				max.set(maxx, maxy, maxz);
			}
		};
		_proto.compute = function compute(vertices, numVerts) {
			BoundingBox.computeMinMax(vertices, tmpVecA$1, tmpVecB$1, numVerts);
			this.setMinMax(tmpVecA$1, tmpVecB$1);
		};
		_proto.intersectsBoundingSphere = function intersectsBoundingSphere(sphere) {
			var sq = this._distanceToBoundingSphereSq(sphere);
			if (sq <= sphere.radius * sphere.radius) {
				return true;
			}
			return false;
		};
		_proto._distanceToBoundingSphereSq = function _distanceToBoundingSphereSq(sphere) {
			var boxMin = this.getMin();
			var boxMax = this.getMax();
			var sq = 0;
			var axis = ['x', 'y', 'z'];
			for (var i = 0; i < 3; ++i) {
				var out = 0;
				var pn = sphere.center[axis[i]];
				var bMin = boxMin[axis[i]];
				var bMax = boxMax[axis[i]];
				var val = 0;
				if (pn < bMin) {
					val = bMin - pn;
					out += val * val;
				}
				if (pn > bMax) {
					val = pn - bMax;
					out += val * val;
				}
				sq += out;
			}
			return sq;
		};
		_proto._expand = function _expand(expandMin, expandMax) {
			tmpVecA$1.add2(this.getMin(), expandMin);
			tmpVecB$1.add2(this.getMax(), expandMax);
			this.setMinMax(tmpVecA$1, tmpVecB$1);
		};
		return BoundingBox;
	}();

	var tmpVecA = new Vec3();
	var tmpVecB = new Vec3();
	var BoundingSphere = function () {
		function BoundingSphere(center, radius) {
			if (center === void 0) {
				center = new Vec3();
			}
			if (radius === void 0) {
				radius = 0.5;
			}
			this.center = void 0;
			this.radius = void 0;
			this.center = center;
			this.radius = radius;
		}
		var _proto = BoundingSphere.prototype;
		_proto.containsPoint = function containsPoint(point) {
			var lenSq = tmpVecA.sub2(point, this.center).lengthSq();
			var r = this.radius;
			return lenSq < r * r;
		};
		_proto.intersectsRay = function intersectsRay(ray, point) {
			var m = tmpVecA.copy(ray.origin).sub(this.center);
			var b = m.dot(tmpVecB.copy(ray.direction).normalize());
			var c = m.dot(m) - this.radius * this.radius;
			if (c > 0 && b > 0) return false;
			var discr = b * b - c;
			if (discr < 0) return false;
			var t = Math.abs(-b - Math.sqrt(discr));
			if (point) point.copy(ray.direction).mulScalar(t).add(ray.origin);
			return true;
		};
		_proto.intersectsBoundingSphere = function intersectsBoundingSphere(sphere) {
			tmpVecA.sub2(sphere.center, this.center);
			var totalRadius = sphere.radius + this.radius;
			if (tmpVecA.lengthSq() <= totalRadius * totalRadius) {
				return true;
			}
			return false;
		};
		return BoundingSphere;
	}();

	var Frustum = function () {
		function Frustum() {
			this.planes = [];
			for (var i = 0; i < 6; i++) this.planes[i] = [];
		}
		var _proto = Frustum.prototype;
		_proto.setFromMat4 = function setFromMat4(matrix) {
			var vpm = matrix.data;
			var plane;
			var planes = this.planes;
			plane = planes[0];
			plane[0] = vpm[3] - vpm[0];
			plane[1] = vpm[7] - vpm[4];
			plane[2] = vpm[11] - vpm[8];
			plane[3] = vpm[15] - vpm[12];
			var t = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);
			plane[0] /= t;
			plane[1] /= t;
			plane[2] /= t;
			plane[3] /= t;
			plane = planes[1];
			plane[0] = vpm[3] + vpm[0];
			plane[1] = vpm[7] + vpm[4];
			plane[2] = vpm[11] + vpm[8];
			plane[3] = vpm[15] + vpm[12];
			t = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);
			plane[0] /= t;
			plane[1] /= t;
			plane[2] /= t;
			plane[3] /= t;
			plane = planes[2];
			plane[0] = vpm[3] + vpm[1];
			plane[1] = vpm[7] + vpm[5];
			plane[2] = vpm[11] + vpm[9];
			plane[3] = vpm[15] + vpm[13];
			t = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);
			plane[0] /= t;
			plane[1] /= t;
			plane[2] /= t;
			plane[3] /= t;
			plane = planes[3];
			plane[0] = vpm[3] - vpm[1];
			plane[1] = vpm[7] - vpm[5];
			plane[2] = vpm[11] - vpm[9];
			plane[3] = vpm[15] - vpm[13];
			t = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);
			plane[0] /= t;
			plane[1] /= t;
			plane[2] /= t;
			plane[3] /= t;
			plane = planes[4];
			plane[0] = vpm[3] - vpm[2];
			plane[1] = vpm[7] - vpm[6];
			plane[2] = vpm[11] - vpm[10];
			plane[3] = vpm[15] - vpm[14];
			t = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);
			plane[0] /= t;
			plane[1] /= t;
			plane[2] /= t;
			plane[3] /= t;
			plane = planes[5];
			plane[0] = vpm[3] + vpm[2];
			plane[1] = vpm[7] + vpm[6];
			plane[2] = vpm[11] + vpm[10];
			plane[3] = vpm[15] + vpm[14];
			t = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);
			plane[0] /= t;
			plane[1] /= t;
			plane[2] /= t;
			plane[3] /= t;
		};
		_proto.containsPoint = function containsPoint(point) {
			var p, plane;
			for (p = 0; p < 6; p++) {
				plane = this.planes[p];
				if (plane[0] * point.x + plane[1] * point.y + plane[2] * point.z + plane[3] <= 0) {
					return false;
				}
			}
			return true;
		};
		_proto.containsSphere = function containsSphere(sphere) {
			var c = 0;
			var d;
			var p;
			var sr = sphere.radius;
			var sc = sphere.center;
			var scx = sc.x;
			var scy = sc.y;
			var scz = sc.z;
			var planes = this.planes;
			var plane;
			for (p = 0; p < 6; p++) {
				plane = planes[p];
				d = plane[0] * scx + plane[1] * scy + plane[2] * scz + plane[3];
				if (d <= -sr) return 0;
				if (d > sr) c++;
			}
			return c === 6 ? 2 : 1;
		};
		return Frustum;
	}();

	var Ray = function () {
		function Ray(origin, direction) {
			this.origin = new Vec3();
			this.direction = Vec3.FORWARD.clone();
			if (origin) {
				this.origin.copy(origin);
			}
			if (direction) {
				this.direction.copy(direction);
			}
		}
		var _proto = Ray.prototype;
		_proto.set = function set(origin, direction) {
			this.origin.copy(origin);
			this.direction.copy(direction);
			return this;
		};
		_proto.copy = function copy(src) {
			return this.set(src.origin, src.direction);
		};
		_proto.clone = function clone() {
			return new this.constructor(this.origin, this.direction);
		};
		return Ray;
	}();

	var tmpRay = new Ray();
	var tmpVec3$2 = new Vec3();
	var tmpSphere = new BoundingSphere();
	var tmpMat4$1 = new Mat4();
	var OrientedBox = function () {
		function OrientedBox(worldTransform, halfExtents) {
			if (worldTransform === void 0) {
				worldTransform = new Mat4();
			}
			if (halfExtents === void 0) {
				halfExtents = new Vec3(0.5, 0.5, 0.5);
			}
			this.halfExtents = void 0;
			this._modelTransform = void 0;
			this._worldTransform = void 0;
			this._aabb = void 0;
			this.halfExtents = halfExtents;
			this._modelTransform = worldTransform.clone().invert();
			this._worldTransform = worldTransform.clone();
			this._aabb = new BoundingBox(new Vec3(), this.halfExtents);
		}
		var _proto = OrientedBox.prototype;
		_proto.intersectsRay = function intersectsRay(ray, point) {
			this._modelTransform.transformPoint(ray.origin, tmpRay.origin);
			this._modelTransform.transformVector(ray.direction, tmpRay.direction);
			if (point) {
				var result = this._aabb._intersectsRay(tmpRay, point);
				tmpMat4$1.copy(this._modelTransform).invert().transformPoint(point, point);
				return result;
			}
			return this._aabb._fastIntersectsRay(tmpRay);
		};
		_proto.containsPoint = function containsPoint(point) {
			this._modelTransform.transformPoint(point, tmpVec3$2);
			return this._aabb.containsPoint(tmpVec3$2);
		};
		_proto.intersectsBoundingSphere = function intersectsBoundingSphere(sphere) {
			this._modelTransform.transformPoint(sphere.center, tmpSphere.center);
			tmpSphere.radius = sphere.radius;
			if (this._aabb.intersectsBoundingSphere(tmpSphere)) {
				return true;
			}
			return false;
		};
		_createClass(OrientedBox, [{
			key: "worldTransform",
			get: function get() {
				return this._worldTransform;
			},
			set: function set(value) {
				this._worldTransform.copy(value);
				this._modelTransform.copy(value).invert();
			}
		}]);
		return OrientedBox;
	}();

	var Plane = function () {
		function Plane(normal, distance) {
			if (normal === void 0) {
				normal = Vec3.UP;
			}
			if (distance === void 0) {
				distance = 0;
			}
			this.normal = new Vec3();
			this.distance = void 0;
			this.normal.copy(normal);
			this.distance = distance;
		}
		var _proto = Plane.prototype;
		_proto.setFromPointNormal = function setFromPointNormal(point, normal) {
			this.normal.copy(normal);
			this.distance = -this.normal.dot(point);
			return this;
		};
		_proto.intersectsLine = function intersectsLine(start, end, point) {
			var d = this.distance;
			var d0 = this.normal.dot(start) + d;
			var d1 = this.normal.dot(end) + d;
			var t = d0 / (d0 - d1);
			var intersects = t >= 0 && t <= 1;
			if (intersects && point) point.lerp(start, end, t);
			return intersects;
		};
		_proto.intersectsRay = function intersectsRay(ray, point) {
			var denominator = this.normal.dot(ray.direction);
			if (denominator === 0) return false;
			var t = -(this.normal.dot(ray.origin) + this.distance) / denominator;
			if (t >= 0 && point) {
				point.copy(ray.direction).mulScalar(t).add(ray.origin);
			}
			return t >= 0;
		};
		_proto.copy = function copy(src) {
			this.normal.copy(src.normal);
			this.distance = src.distance;
			return this;
		};
		_proto.clone = function clone() {
			var cstr = this.constructor;
			return new cstr().copy(this);
		};
		return Plane;
	}();

	var DISTANCE_LINEAR = 'linear';
	var DISTANCE_INVERSE = 'inverse';
	var DISTANCE_EXPONENTIAL = 'exponential';

	var ADDRESS_REPEAT = 0;
	var ADDRESS_CLAMP_TO_EDGE = 1;
	var ADDRESS_MIRRORED_REPEAT = 2;
	var BLENDMODE_ZERO = 0;
	var BLENDMODE_ONE = 1;
	var BLENDMODE_SRC_COLOR = 2;
	var BLENDMODE_ONE_MINUS_SRC_COLOR = 3;
	var BLENDMODE_DST_COLOR = 4;
	var BLENDMODE_ONE_MINUS_DST_COLOR = 5;
	var BLENDMODE_SRC_ALPHA = 6;
	var BLENDMODE_SRC_ALPHA_SATURATE = 7;
	var BLENDMODE_ONE_MINUS_SRC_ALPHA = 8;
	var BLENDMODE_DST_ALPHA = 9;
	var BLENDMODE_ONE_MINUS_DST_ALPHA = 10;
	var BLENDMODE_CONSTANT = 11;
	var BLENDMODE_ONE_MINUS_CONSTANT = 12;
	var BLENDEQUATION_ADD = 0;
	var BLENDEQUATION_SUBTRACT = 1;
	var BLENDEQUATION_REVERSE_SUBTRACT = 2;
	var BLENDEQUATION_MIN = 3;
	var BLENDEQUATION_MAX = 4;
	var BUFFER_STATIC = 0;
	var BUFFER_DYNAMIC = 1;
	var BUFFER_STREAM = 2;
	var BUFFER_GPUDYNAMIC = 3;
	var CLEARFLAG_COLOR = 1;
	var CLEARFLAG_DEPTH = 2;
	var CLEARFLAG_STENCIL = 4;
	var CUBEFACE_POSX = 0;
	var CUBEFACE_NEGX = 1;
	var CUBEFACE_POSY = 2;
	var CUBEFACE_NEGY = 3;
	var CUBEFACE_POSZ = 4;
	var CUBEFACE_NEGZ = 5;
	var CULLFACE_NONE = 0;
	var CULLFACE_BACK = 1;
	var CULLFACE_FRONT = 2;
	var CULLFACE_FRONTANDBACK = 3;
	var FILTER_NEAREST = 0;
	var FILTER_LINEAR = 1;
	var FILTER_NEAREST_MIPMAP_NEAREST = 2;
	var FILTER_NEAREST_MIPMAP_LINEAR = 3;
	var FILTER_LINEAR_MIPMAP_NEAREST = 4;
	var FILTER_LINEAR_MIPMAP_LINEAR = 5;
	var FUNC_NEVER = 0;
	var FUNC_LESS = 1;
	var FUNC_EQUAL = 2;
	var FUNC_LESSEQUAL = 3;
	var FUNC_GREATER = 4;
	var FUNC_NOTEQUAL = 5;
	var FUNC_GREATEREQUAL = 6;
	var FUNC_ALWAYS = 7;
	var INDEXFORMAT_UINT8 = 0;
	var INDEXFORMAT_UINT16 = 1;
	var INDEXFORMAT_UINT32 = 2;
	var PIXELFORMAT_A8 = 0;
	var PIXELFORMAT_L8 = 1;
	var PIXELFORMAT_LA8 = 2;
	var PIXELFORMAT_RGB565 = 3;
	var PIXELFORMAT_RGBA5551 = 4;
	var PIXELFORMAT_RGBA4 = 5;
	var PIXELFORMAT_RGB8 = 6;
	var PIXELFORMAT_RGBA8 = 7;
	var PIXELFORMAT_DXT1 = 8;
	var PIXELFORMAT_DXT3 = 9;
	var PIXELFORMAT_DXT5 = 10;
	var PIXELFORMAT_RGB16F = 11;
	var PIXELFORMAT_RGBA16F = 12;
	var PIXELFORMAT_RGB32F = 13;
	var PIXELFORMAT_RGBA32F = 14;
	var PIXELFORMAT_R32F = 15;
	var PIXELFORMAT_DEPTH = 16;
	var PIXELFORMAT_DEPTHSTENCIL = 17;
	var PIXELFORMAT_111110F = 18;
	var PIXELFORMAT_SRGB = 19;
	var PIXELFORMAT_SRGBA = 20;
	var PIXELFORMAT_ETC1 = 21;
	var PIXELFORMAT_ETC2_RGB = 22;
	var PIXELFORMAT_ETC2_RGBA = 23;
	var PIXELFORMAT_PVRTC_2BPP_RGB_1 = 24;
	var PIXELFORMAT_PVRTC_2BPP_RGBA_1 = 25;
	var PIXELFORMAT_PVRTC_4BPP_RGB_1 = 26;
	var PIXELFORMAT_PVRTC_4BPP_RGBA_1 = 27;
	var PIXELFORMAT_ASTC_4x4 = 28;
	var PIXELFORMAT_ATC_RGB = 29;
	var PIXELFORMAT_ATC_RGBA = 30;
	var PIXELFORMAT_BGRA8 = 31;
	var pixelFormatInfo = new Map([[PIXELFORMAT_A8, {
		name: 'A8',
		size: 1
	}], [PIXELFORMAT_L8, {
		name: 'L8',
		size: 1
	}], [PIXELFORMAT_LA8, {
		name: 'LA8',
		size: 2
	}], [PIXELFORMAT_RGB565, {
		name: 'RGB565',
		size: 2
	}], [PIXELFORMAT_RGBA5551, {
		name: 'RGBA5551',
		size: 2
	}], [PIXELFORMAT_RGBA4, {
		name: 'RGBA4',
		size: 2
	}], [PIXELFORMAT_RGB8, {
		name: 'RGB8',
		size: 4
	}], [PIXELFORMAT_RGBA8, {
		name: 'RGBA8',
		size: 4
	}], [PIXELFORMAT_RGB16F, {
		name: 'RGB16F',
		size: 8
	}], [PIXELFORMAT_RGBA16F, {
		name: 'RGBA16F',
		size: 8
	}], [PIXELFORMAT_RGB32F, {
		name: 'RGB32F',
		size: 16
	}], [PIXELFORMAT_RGBA32F, {
		name: 'RGBA32F',
		size: 16
	}], [PIXELFORMAT_R32F, {
		name: 'R32F',
		size: 4
	}], [PIXELFORMAT_DEPTH, {
		name: 'DEPTH',
		size: 4
	}], [PIXELFORMAT_DEPTHSTENCIL, {
		name: 'DEPTHSTENCIL',
		size: 4
	}], [PIXELFORMAT_111110F, {
		name: '111110F',
		size: 4
	}], [PIXELFORMAT_SRGB, {
		name: 'SRGB',
		size: 4
	}], [PIXELFORMAT_SRGBA, {
		name: 'SRGBA',
		size: 4
	}], [PIXELFORMAT_BGRA8, {
		name: 'BGRA8',
		size: 4
	}], [PIXELFORMAT_DXT1, {
		name: 'DXT1',
		blockSize: 8
	}], [PIXELFORMAT_DXT3, {
		name: 'DXT3',
		blockSize: 16
	}], [PIXELFORMAT_DXT5, {
		name: 'DXT5',
		blockSize: 16
	}], [PIXELFORMAT_ETC1, {
		name: 'ETC1',
		blockSize: 8
	}], [PIXELFORMAT_ETC2_RGB, {
		name: 'ETC2_RGB',
		blockSize: 8
	}], [PIXELFORMAT_ETC2_RGBA, {
		name: 'ETC2_RGBA',
		blockSize: 16
	}], [PIXELFORMAT_PVRTC_2BPP_RGB_1, {
		name: 'PVRTC_2BPP_RGB_1',
		blockSize: 8
	}], [PIXELFORMAT_PVRTC_2BPP_RGBA_1, {
		name: 'PVRTC_2BPP_RGBA_1',
		blockSize: 8
	}], [PIXELFORMAT_PVRTC_4BPP_RGB_1, {
		name: 'PVRTC_4BPP_RGB_1',
		blockSize: 8
	}], [PIXELFORMAT_PVRTC_4BPP_RGBA_1, {
		name: 'PVRTC_4BPP_RGBA_1',
		blockSize: 8
	}], [PIXELFORMAT_ASTC_4x4, {
		name: 'ASTC_4x4',
		blockSize: 16
	}], [PIXELFORMAT_ATC_RGB, {
		name: 'ATC_RGB',
		blockSize: 8
	}], [PIXELFORMAT_ATC_RGBA, {
		name: 'ATC_RGBA',
		blockSize: 16
	}]]);
	var isCompressedPixelFormat = function isCompressedPixelFormat(format) {
		return pixelFormatInfo.get(format).blockSize !== undefined;
	};
	var getPixelFormatArrayType = function getPixelFormatArrayType(format) {
		switch (format) {
			case PIXELFORMAT_RGB32F:
			case PIXELFORMAT_RGBA32F:
				return Float32Array;
			case PIXELFORMAT_RGB565:
			case PIXELFORMAT_RGBA5551:
			case PIXELFORMAT_RGBA4:
			case PIXELFORMAT_RGB16F:
			case PIXELFORMAT_RGBA16F:
				return Uint16Array;
			default:
				return Uint8Array;
		}
	};
	var PRIMITIVE_POINTS = 0;
	var PRIMITIVE_LINES = 1;
	var PRIMITIVE_LINELOOP = 2;
	var PRIMITIVE_LINESTRIP = 3;
	var PRIMITIVE_TRIANGLES = 4;
	var PRIMITIVE_TRISTRIP = 5;
	var PRIMITIVE_TRIFAN = 6;
	var SEMANTIC_POSITION = "POSITION";
	var SEMANTIC_NORMAL = "NORMAL";
	var SEMANTIC_TANGENT = "TANGENT";
	var SEMANTIC_BLENDWEIGHT = "BLENDWEIGHT";
	var SEMANTIC_BLENDINDICES = "BLENDINDICES";
	var SEMANTIC_COLOR = "COLOR";
	var SEMANTIC_TEXCOORD = "TEXCOORD";
	var SEMANTIC_TEXCOORD0 = "TEXCOORD0";
	var SEMANTIC_TEXCOORD1 = "TEXCOORD1";
	var SEMANTIC_TEXCOORD2 = "TEXCOORD2";
	var SEMANTIC_TEXCOORD3 = "TEXCOORD3";
	var SEMANTIC_TEXCOORD4 = "TEXCOORD4";
	var SEMANTIC_TEXCOORD5 = "TEXCOORD5";
	var SEMANTIC_TEXCOORD6 = "TEXCOORD6";
	var SEMANTIC_TEXCOORD7 = "TEXCOORD7";
	var SEMANTIC_ATTR = "ATTR";
	var SEMANTIC_ATTR0 = "ATTR0";
	var SEMANTIC_ATTR1 = "ATTR1";
	var SEMANTIC_ATTR2 = "ATTR2";
	var SEMANTIC_ATTR3 = "ATTR3";
	var SEMANTIC_ATTR4 = "ATTR4";
	var SEMANTIC_ATTR5 = "ATTR5";
	var SEMANTIC_ATTR6 = "ATTR6";
	var SEMANTIC_ATTR7 = "ATTR7";
	var SEMANTIC_ATTR8 = "ATTR8";
	var SEMANTIC_ATTR9 = "ATTR9";
	var SEMANTIC_ATTR10 = "ATTR10";
	var SEMANTIC_ATTR11 = "ATTR11";
	var SEMANTIC_ATTR12 = "ATTR12";
	var SEMANTIC_ATTR13 = "ATTR13";
	var SEMANTIC_ATTR14 = "ATTR14";
	var SEMANTIC_ATTR15 = "ATTR15";
	var SHADERTAG_MATERIAL = 1;
	var STENCILOP_KEEP = 0;
	var STENCILOP_ZERO = 1;
	var STENCILOP_REPLACE = 2;
	var STENCILOP_INCREMENT = 3;
	var STENCILOP_INCREMENTWRAP = 4;
	var STENCILOP_DECREMENT = 5;
	var STENCILOP_DECREMENTWRAP = 6;
	var STENCILOP_INVERT = 7;
	var TEXTURELOCK_READ = 1;
	var TEXTURELOCK_WRITE = 2;
	var TEXTURETYPE_DEFAULT = 'default';
	var TEXTURETYPE_RGBM = 'rgbm';
	var TEXTURETYPE_RGBE = 'rgbe';
	var TEXTURETYPE_RGBP = 'rgbp';
	var TEXTURETYPE_SWIZZLEGGGR = 'swizzleGGGR';
	var TEXHINT_NONE = 0;
	var TEXHINT_SHADOWMAP = 1;
	var TEXHINT_ASSET = 2;
	var TEXHINT_LIGHTMAP = 3;
	var TEXTUREDIMENSION_1D = '1d';
	var TEXTUREDIMENSION_2D = '2d';
	var TEXTUREDIMENSION_2D_ARRAY = '2d-array';
	var TEXTUREDIMENSION_CUBE = 'cube';
	var TEXTUREDIMENSION_CUBE_ARRAY = 'cube-array';
	var TEXTUREDIMENSION_3D = '3d';
	var SAMPLETYPE_FLOAT = 0;
	var SAMPLETYPE_UNFILTERABLE_FLOAT = 1;
	var SAMPLETYPE_DEPTH = 2;
	var TEXTUREPROJECTION_NONE = "none";
	var TEXTUREPROJECTION_CUBE = "cube";
	var TEXTUREPROJECTION_EQUIRECT = "equirect";
	var TEXTUREPROJECTION_OCTAHEDRAL = "octahedral";
	var SHADERLANGUAGE_GLSL = 'glsl';
	var SHADERLANGUAGE_WGSL = 'wgsl';
	var TYPE_INT8 = 0;
	var TYPE_UINT8 = 1;
	var TYPE_INT16 = 2;
	var TYPE_UINT16 = 3;
	var TYPE_INT32 = 4;
	var TYPE_UINT32 = 5;
	var TYPE_FLOAT32 = 6;
	var TYPE_FLOAT16 = 7;
	var UNIFORMTYPE_BOOL = 0;
	var UNIFORMTYPE_INT = 1;
	var UNIFORMTYPE_FLOAT = 2;
	var UNIFORMTYPE_VEC2 = 3;
	var UNIFORMTYPE_VEC3 = 4;
	var UNIFORMTYPE_VEC4 = 5;
	var UNIFORMTYPE_IVEC2 = 6;
	var UNIFORMTYPE_IVEC3 = 7;
	var UNIFORMTYPE_IVEC4 = 8;
	var UNIFORMTYPE_BVEC2 = 9;
	var UNIFORMTYPE_BVEC3 = 10;
	var UNIFORMTYPE_BVEC4 = 11;
	var UNIFORMTYPE_MAT2 = 12;
	var UNIFORMTYPE_MAT3 = 13;
	var UNIFORMTYPE_MAT4 = 14;
	var UNIFORMTYPE_TEXTURE2D = 15;
	var UNIFORMTYPE_TEXTURECUBE = 16;
	var UNIFORMTYPE_FLOATARRAY = 17;
	var UNIFORMTYPE_TEXTURE2D_SHADOW = 18;
	var UNIFORMTYPE_TEXTURECUBE_SHADOW = 19;
	var UNIFORMTYPE_TEXTURE3D = 20;
	var UNIFORMTYPE_VEC2ARRAY = 21;
	var UNIFORMTYPE_VEC3ARRAY = 22;
	var UNIFORMTYPE_VEC4ARRAY = 23;
	var UNIFORMTYPE_MAT4ARRAY = 24;
	var UNIFORMTYPE_TEXTURE2D_ARRAY = 25;
	var uniformTypeToName = ['bool', 'int', 'float', 'vec2', 'vec3', 'vec4', 'ivec2', 'ivec3', 'ivec4', 'bec2', 'bec3', 'bec4', 'mat2', 'mat3', 'mat4', 'sampler2D', 'samplerCube', '', 'sampler2DShadow', 'samplerCubeShadow', 'sampler3D', '', '', ''];
	var DEVICETYPE_WEBGL1 = 'webgl1';
	var DEVICETYPE_WEBGL2 = 'webgl2';
	var DEVICETYPE_WEBGPU = 'webgpu';
	var DEVICETYPE_NULL = 'null';
	var SHADERSTAGE_VERTEX = 1;
	var SHADERSTAGE_FRAGMENT = 2;
	var SHADERSTAGE_COMPUTE = 4;
	var BINDGROUP_MESH = 0;
	var BINDGROUP_VIEW = 1;
	var bindGroupNames = ['mesh', 'view'];
	var UNIFORM_BUFFER_DEFAULT_SLOT_NAME = 'default';
	var typedArrayTypes = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Uint16Array];
	var typedArrayTypesByteSize = [1, 1, 2, 2, 4, 4, 4, 2];
	var vertexTypesNames = ['INT8', 'UINT8', 'INT16', 'UINT16', 'INT32', 'UINT32', 'FLOAT32', 'FLOAT16'];
	var typedArrayToType = {
		"Int8Array": TYPE_INT8,
		"Uint8Array": TYPE_UINT8,
		"Int16Array": TYPE_INT16,
		"Uint16Array": TYPE_UINT16,
		"Int32Array": TYPE_INT32,
		"Uint32Array": TYPE_UINT32,
		"Float32Array": TYPE_FLOAT32
	};
	var typedArrayIndexFormats = [Uint8Array, Uint16Array, Uint32Array];
	var typedArrayIndexFormatsByteSize = [1, 2, 4];
	var semanticToLocation = {};
	semanticToLocation[SEMANTIC_POSITION] = 0;
	semanticToLocation[SEMANTIC_NORMAL] = 1;
	semanticToLocation[SEMANTIC_BLENDWEIGHT] = 2;
	semanticToLocation[SEMANTIC_BLENDINDICES] = 3;
	semanticToLocation[SEMANTIC_COLOR] = 4;
	semanticToLocation[SEMANTIC_TEXCOORD0] = 5;
	semanticToLocation[SEMANTIC_TEXCOORD1] = 6;
	semanticToLocation[SEMANTIC_TEXCOORD2] = 7;
	semanticToLocation[SEMANTIC_TEXCOORD3] = 8;
	semanticToLocation[SEMANTIC_TEXCOORD4] = 9;
	semanticToLocation[SEMANTIC_TEXCOORD5] = 10;
	semanticToLocation[SEMANTIC_TEXCOORD6] = 11;
	semanticToLocation[SEMANTIC_TEXCOORD7] = 12;
	semanticToLocation[SEMANTIC_TANGENT] = 13;
	semanticToLocation[SEMANTIC_ATTR0] = 0;
	semanticToLocation[SEMANTIC_ATTR1] = 1;
	semanticToLocation[SEMANTIC_ATTR2] = 2;
	semanticToLocation[SEMANTIC_ATTR3] = 3;
	semanticToLocation[SEMANTIC_ATTR4] = 4;
	semanticToLocation[SEMANTIC_ATTR5] = 5;
	semanticToLocation[SEMANTIC_ATTR6] = 6;
	semanticToLocation[SEMANTIC_ATTR7] = 7;
	semanticToLocation[SEMANTIC_ATTR8] = 8;
	semanticToLocation[SEMANTIC_ATTR9] = 9;
	semanticToLocation[SEMANTIC_ATTR10] = 10;
	semanticToLocation[SEMANTIC_ATTR11] = 11;
	semanticToLocation[SEMANTIC_ATTR12] = 12;
	semanticToLocation[SEMANTIC_ATTR13] = 13;
	semanticToLocation[SEMANTIC_ATTR14] = 14;
	semanticToLocation[SEMANTIC_ATTR15] = 15;
	var CHUNKAPI_1_51 = '1.51';
	var CHUNKAPI_1_55 = '1.55';
	var CHUNKAPI_1_56 = '1.56';
	var CHUNKAPI_1_57 = '1.57';
	var CHUNKAPI_1_58 = '1.58';
	var CHUNKAPI_1_60 = '1.60';
	var CHUNKAPI_1_62 = '1.62';
	var CHUNKAPI_1_65 = '1.65';

	var BitPacking = {
		set: function set(storage, value, shift, mask) {
			if (mask === void 0) {
				mask = 1;
			}
			var data = storage & ~(mask << shift);
			return data | value << shift;
		},
		get: function get(storage, shift, mask) {
			if (mask === void 0) {
				mask = 1;
			}
			return storage >> shift & mask;
		},
		all: function all(storage, shift, mask) {
			if (mask === void 0) {
				mask = 1;
			}
			var shifted = mask << shift;
			return (storage & shifted) === shifted;
		},
		any: function any(storage, shift, mask) {
			if (mask === void 0) {
				mask = 1;
			}
			return (storage & mask << shift) !== 0;
		}
	};

	var _class$4;
	var opMask = 7;
	var factorMask = 15;
	var colorOpShift = 0;
	var colorSrcFactorShift = 3;
	var colorDstFactorShift = 7;
	var alphaOpShift = 11;
	var alphaSrcFactorShift = 14;
	var alphaDstFactorShift = 18;
	var redWriteShift = 22;
	var greenWriteShift = 23;
	var blueWriteShift = 24;
	var alphaWriteShift = 25;
	var blendShift = 26;
	var allWriteMasks = 15;
	var allWriteShift = redWriteShift;
	var BlendState = function () {
		function BlendState(blend, colorOp, colorSrcFactor, colorDstFactor, alphaOp, alphaSrcFactor, alphaDstFactor, redWrite, greenWrite, blueWrite, alphaWrite) {
			if (blend === void 0) {
				blend = false;
			}
			if (colorOp === void 0) {
				colorOp = BLENDEQUATION_ADD;
			}
			if (colorSrcFactor === void 0) {
				colorSrcFactor = BLENDMODE_ONE;
			}
			if (colorDstFactor === void 0) {
				colorDstFactor = BLENDMODE_ZERO;
			}
			if (redWrite === void 0) {
				redWrite = true;
			}
			if (greenWrite === void 0) {
				greenWrite = true;
			}
			if (blueWrite === void 0) {
				blueWrite = true;
			}
			if (alphaWrite === void 0) {
				alphaWrite = true;
			}
			this.target0 = 0;
			this.setColorBlend(colorOp, colorSrcFactor, colorDstFactor);
			this.setAlphaBlend(alphaOp != null ? alphaOp : colorOp, alphaSrcFactor != null ? alphaSrcFactor : colorSrcFactor, alphaDstFactor != null ? alphaDstFactor : colorDstFactor);
			this.setColorWrite(redWrite, greenWrite, blueWrite, alphaWrite);
			this.blend = blend;
		}
		var _proto = BlendState.prototype;
		_proto.setColorBlend = function setColorBlend(op, srcFactor, dstFactor) {
			this.target0 = BitPacking.set(this.target0, op, colorOpShift, opMask);
			this.target0 = BitPacking.set(this.target0, srcFactor, colorSrcFactorShift, factorMask);
			this.target0 = BitPacking.set(this.target0, dstFactor, colorDstFactorShift, factorMask);
		};
		_proto.setAlphaBlend = function setAlphaBlend(op, srcFactor, dstFactor) {
			this.target0 = BitPacking.set(this.target0, op, alphaOpShift, opMask);
			this.target0 = BitPacking.set(this.target0, srcFactor, alphaSrcFactorShift, factorMask);
			this.target0 = BitPacking.set(this.target0, dstFactor, alphaDstFactorShift, factorMask);
		};
		_proto.setColorWrite = function setColorWrite(redWrite, greenWrite, blueWrite, alphaWrite) {
			this.redWrite = redWrite;
			this.greenWrite = greenWrite;
			this.blueWrite = blueWrite;
			this.alphaWrite = alphaWrite;
		};
		_proto.copy = function copy(rhs) {
			this.target0 = rhs.target0;
			return this;
		};
		_proto.clone = function clone() {
			var clone = new this.constructor();
			return clone.copy(this);
		};
		_proto.equals = function equals(rhs) {
			return this.target0 === rhs.target0;
		};
		_createClass(BlendState, [{
			key: "blend",
			get: function get() {
				return BitPacking.all(this.target0, blendShift);
			},
			set: function set(value) {
				this.target0 = BitPacking.set(this.target0, value ? 1 : 0, blendShift);
			}
		}, {
			key: "colorOp",
			get: function get() {
				return BitPacking.get(this.target0, colorOpShift, opMask);
			}
		}, {
			key: "colorSrcFactor",
			get: function get() {
				return BitPacking.get(this.target0, colorSrcFactorShift, factorMask);
			}
		}, {
			key: "colorDstFactor",
			get: function get() {
				return BitPacking.get(this.target0, colorDstFactorShift, factorMask);
			}
		}, {
			key: "alphaOp",
			get: function get() {
				return BitPacking.get(this.target0, alphaOpShift, opMask);
			}
		}, {
			key: "alphaSrcFactor",
			get: function get() {
				return BitPacking.get(this.target0, alphaSrcFactorShift, factorMask);
			}
		}, {
			key: "alphaDstFactor",
			get: function get() {
				return BitPacking.get(this.target0, alphaDstFactorShift, factorMask);
			}
		}, {
			key: "redWrite",
			get: function get() {
				return BitPacking.all(this.target0, redWriteShift);
			},
			set: function set(value) {
				this.target0 = BitPacking.set(this.target0, value ? 1 : 0, redWriteShift);
			}
		}, {
			key: "greenWrite",
			get: function get() {
				return BitPacking.all(this.target0, greenWriteShift);
			},
			set: function set(value) {
				this.target0 = BitPacking.set(this.target0, value ? 1 : 0, greenWriteShift);
			}
		}, {
			key: "blueWrite",
			get: function get() {
				return BitPacking.all(this.target0, blueWriteShift);
			},
			set: function set(value) {
				this.target0 = BitPacking.set(this.target0, value ? 1 : 0, blueWriteShift);
			}
		}, {
			key: "alphaWrite",
			get: function get() {
				return BitPacking.all(this.target0, alphaWriteShift);
			},
			set: function set(value) {
				this.target0 = BitPacking.set(this.target0, value ? 1 : 0, alphaWriteShift);
			}
		}, {
			key: "allWrite",
			get: function get() {
				return BitPacking.get(this.target0, allWriteShift, allWriteMasks);
			}
		}, {
			key: "key",
			get: function get() {
				return this.target0;
			}
		}]);
		return BlendState;
	}();
	_class$4 = BlendState;
	BlendState.NOBLEND = Object.freeze(new _class$4());
	BlendState.NOWRITE = Object.freeze(new _class$4(undefined, undefined, undefined, undefined, undefined, undefined, undefined, false, false, false, false));
	BlendState.ALPHABLEND = Object.freeze(new _class$4(true, BLENDEQUATION_ADD, BLENDMODE_SRC_ALPHA, BLENDMODE_ONE_MINUS_SRC_ALPHA));
	BlendState.ADDBLEND = Object.freeze(new _class$4(true, BLENDEQUATION_ADD, BLENDMODE_ONE, BLENDMODE_ONE));

	var _class$3;
	var funcMask = 7;
	var funcShift = 0;
	var writeShift = 3;
	var DepthState = function () {
		function DepthState(func, write) {
			if (func === void 0) {
				func = FUNC_LESSEQUAL;
			}
			if (write === void 0) {
				write = true;
			}
			this.data = 0;
			this.func = func;
			this.write = write;
		}
		var _proto = DepthState.prototype;
		_proto.copy = function copy(rhs) {
			this.data = rhs.data;
			return this;
		};
		_proto.clone = function clone() {
			var clone = new this.constructor();
			return clone.copy(this);
		};
		_proto.equals = function equals(rhs) {
			return this.data === rhs.data;
		};
		_createClass(DepthState, [{
			key: "test",
			get: function get() {
				return this.func !== FUNC_ALWAYS;
			},
			set: function set(value) {
				this.func = value ? FUNC_LESSEQUAL : FUNC_ALWAYS;
			}
		}, {
			key: "write",
			get: function get() {
				return BitPacking.all(this.data, writeShift);
			},
			set: function set(value) {
				this.data = BitPacking.set(this.data, value ? 1 : 0, writeShift);
			}
		}, {
			key: "func",
			get: function get() {
				return BitPacking.get(this.data, funcShift, funcMask);
			},
			set: function set(value) {
				this.data = BitPacking.set(this.data, value, funcShift, funcMask);
			}
		}, {
			key: "key",
			get: function get() {
				return this.data;
			}
		}]);
		return DepthState;
	}();
	_class$3 = DepthState;
	DepthState.DEFAULT = Object.freeze(new _class$3());
	DepthState.NODEPTH = Object.freeze(new _class$3(FUNC_ALWAYS, false));
	DepthState.WRITEDEPTH = Object.freeze(new _class$3(FUNC_ALWAYS, true));

	var Version = function () {
		function Version() {
			this.globalId = 0;
			this.revision = 0;
		}
		var _proto = Version.prototype;
		_proto.equals = function equals(other) {
			return this.globalId === other.globalId && this.revision === other.revision;
		};
		_proto.copy = function copy(other) {
			this.globalId = other.globalId;
			this.revision = other.revision;
		};
		_proto.reset = function reset() {
			this.globalId = 0;
			this.revision = 0;
		};
		return Version;
	}();

	var idCounter = 0;
	var VersionedObject = function () {
		function VersionedObject() {
			idCounter++;
			this.version = new Version();
			this.version.globalId = idCounter;
		}
		var _proto = VersionedObject.prototype;
		_proto.increment = function increment() {
			this.version.revision++;
		};
		return VersionedObject;
	}();

	var ScopeId = function () {
		function ScopeId(name) {
			this.name = name;
			this.value = null;
			this.versionObject = new VersionedObject();
		}
		var _proto = ScopeId.prototype;
		_proto.toJSON = function toJSON(key) {
			return undefined;
		};
		_proto.setValue = function setValue(value) {
			this.value = value;
			this.versionObject.increment();
		};
		_proto.getValue = function getValue() {
			return this.value;
		};
		return ScopeId;
	}();

	var ScopeSpace = function () {
		function ScopeSpace(name) {
			this.name = name;
			this.variables = new Map();
		}
		var _proto = ScopeSpace.prototype;
		_proto.resolve = function resolve(name) {
			if (!this.variables.has(name)) {
				this.variables.set(name, new ScopeId(name));
			}
			return this.variables.get(name);
		};
		_proto.removeValue = function removeValue(value) {
			for (var uniformName in this.variables) {
				var uniform = this.variables[uniformName];
				if (uniform.value === value) {
					uniform.value = null;
				}
			}
		};
		return ScopeSpace;
	}();

	var id$a = 0;
	var VertexBuffer = function () {
		function VertexBuffer(graphicsDevice, format, numVertices, usage, initialData) {
			if (usage === void 0) {
				usage = BUFFER_STATIC;
			}
			this.device = graphicsDevice;
			this.format = format;
			this.numVertices = numVertices;
			this.usage = usage;
			this.id = id$a++;
			this.impl = graphicsDevice.createVertexBufferImpl(this, format);
			this.numBytes = format.verticesByteSize ? format.verticesByteSize : format.size * numVertices;
			this.adjustVramSizeTracking(graphicsDevice._vram, this.numBytes);
			if (initialData) {
				this.setData(initialData);
			} else {
				this.storage = new ArrayBuffer(this.numBytes);
			}
			this.device.buffers.push(this);
		}
		var _proto = VertexBuffer.prototype;
		_proto.destroy = function destroy() {
			var device = this.device;
			var idx = device.buffers.indexOf(this);
			if (idx !== -1) {
				device.buffers.splice(idx, 1);
			}
			if (this.impl.initialized) {
				this.impl.destroy(device);
				this.adjustVramSizeTracking(device._vram, -this.storage.byteLength);
			}
		};
		_proto.adjustVramSizeTracking = function adjustVramSizeTracking(vram, size) {
			vram.vb += size;
		};
		_proto.loseContext = function loseContext() {
			this.impl.loseContext();
		};
		_proto.getFormat = function getFormat() {
			return this.format;
		};
		_proto.getUsage = function getUsage() {
			return this.usage;
		};
		_proto.getNumVertices = function getNumVertices() {
			return this.numVertices;
		};
		_proto.lock = function lock() {
			return this.storage;
		};
		_proto.unlock = function unlock() {
			this.impl.unlock(this);
		};
		_proto.setData = function setData(data) {
			if (data.byteLength !== this.numBytes) {
				return false;
			}
			this.storage = data;
			this.unlock();
			return true;
		};
		return VertexBuffer;
	}();

	function hashCode(str) {
		var hash = 0;
		for (var i = 0, len = str.length; i < len; i++) {
			hash = (hash << 5) - hash + str.charCodeAt(i);
			hash |= 0;
		}
		return hash;
	}
	function hash32Fnv1a(array) {
		var prime = 16777619;
		var hash = 2166136261;
		for (var i = 0; i < array.length; i++) {
			hash ^= array[i];
			hash *= prime;
		}
		return hash >>> 0;
	}

	var StringIds = function () {
		function StringIds() {
			this.map = new Map();
			this.id = 0;
		}
		var _proto = StringIds.prototype;
		_proto.get = function get(name) {
			var value = this.map.get(name);
			if (value === undefined) {
				value = this.id++;
				this.map.set(name, value);
			}
			return value;
		};
		return StringIds;
	}();

	var stringIds$3 = new StringIds();
	var webgpuValidElementSizes = [2, 4, 8, 12, 16];
	var VertexFormat = function () {
		function VertexFormat(graphicsDevice, description, vertexCount) {
			this.device = graphicsDevice;
			this._elements = [];
			this.hasUv0 = false;
			this.hasUv1 = false;
			this.hasColor = false;
			this.hasTangents = false;
			this.verticesByteSize = 0;
			this.vertexCount = vertexCount;
			this.interleaved = vertexCount === undefined;
			this.instancing = false;
			this.size = description.reduce(function (total, desc) {
				return total + Math.ceil(desc.components * typedArrayTypesByteSize[desc.type] / 4) * 4;
			}, 0);
			var offset = 0,
				elementSize;
			for (var i = 0, len = description.length; i < len; i++) {
				var _elementDesc$asInt, _elementDesc$normaliz;
				var elementDesc = description[i];
				elementSize = elementDesc.components * typedArrayTypesByteSize[elementDesc.type];
				if (vertexCount) {
					offset = math.roundUp(offset, elementSize);
				}
				var asInt = (_elementDesc$asInt = elementDesc.asInt) != null ? _elementDesc$asInt : false;
				var normalize = asInt ? false : (_elementDesc$normaliz = elementDesc.normalize) != null ? _elementDesc$normaliz : false;
				var element = {
					name: elementDesc.semantic,
					offset: vertexCount ? offset : elementDesc.hasOwnProperty('offset') ? elementDesc.offset : offset,
					stride: vertexCount ? elementSize : elementDesc.hasOwnProperty('stride') ? elementDesc.stride : this.size,
					dataType: elementDesc.type,
					numComponents: elementDesc.components,
					normalize: normalize,
					size: elementSize,
					asInt: asInt
				};
				this._elements.push(element);
				if (vertexCount) {
					offset += elementSize * vertexCount;
				} else {
					offset += Math.ceil(elementSize / 4) * 4;
				}
				if (elementDesc.semantic === SEMANTIC_TEXCOORD0) {
					this.hasUv0 = true;
				} else if (elementDesc.semantic === SEMANTIC_TEXCOORD1) {
					this.hasUv1 = true;
				} else if (elementDesc.semantic === SEMANTIC_COLOR) {
					this.hasColor = true;
				} else if (elementDesc.semantic === SEMANTIC_TANGENT) {
					this.hasTangents = true;
				}
			}
			if (vertexCount) {
				this.verticesByteSize = offset;
			}
			this._evaluateHash();
		}
		VertexFormat.getDefaultInstancingFormat = function getDefaultInstancingFormat(graphicsDevice) {
			if (!VertexFormat._defaultInstancingFormat) {
				VertexFormat._defaultInstancingFormat = new VertexFormat(graphicsDevice, [{
					semantic: SEMANTIC_ATTR12,
					components: 4,
					type: TYPE_FLOAT32
				}, {
					semantic: SEMANTIC_ATTR13,
					components: 4,
					type: TYPE_FLOAT32
				}, {
					semantic: SEMANTIC_ATTR14,
					components: 4,
					type: TYPE_FLOAT32
				}, {
					semantic: SEMANTIC_ATTR15,
					components: 4,
					type: TYPE_FLOAT32
				}]);
			}
			return VertexFormat._defaultInstancingFormat;
		};
		VertexFormat.isElementValid = function isElementValid(graphicsDevice, elementDesc) {
			var elementSize = elementDesc.components * typedArrayTypesByteSize[elementDesc.type];
			if (graphicsDevice.isWebGPU && !webgpuValidElementSizes.includes(elementSize)) return false;
			return true;
		};
		var _proto = VertexFormat.prototype;
		_proto.update = function update() {
			this._evaluateHash();
		};
		_proto._evaluateHash = function _evaluateHash() {
			var stringElementBatch;
			var stringElementsBatch = [];
			var stringElementRender;
			var stringElementsRender = [];
			var len = this._elements.length;
			for (var i = 0; i < len; i++) {
				var element = this._elements[i];
				stringElementBatch = element.name;
				stringElementBatch += element.dataType;
				stringElementBatch += element.numComponents;
				stringElementBatch += element.normalize;
				stringElementsBatch.push(stringElementBatch);
				stringElementRender = stringElementBatch;
				stringElementRender += element.offset;
				stringElementRender += element.stride;
				stringElementRender += element.size;
				stringElementsRender.push(stringElementRender);
			}
			stringElementsBatch.sort();
			this.batchingHash = hashCode(stringElementsBatch.join());
			this.renderingHashString = stringElementsRender.join('_');
			this.renderingHash = stringIds$3.get(this.renderingHashString);
		};
		_createClass(VertexFormat, [{
			key: "elements",
			get: function get() {
				return this._elements;
			}
		}]);
		return VertexFormat;
	}();
	VertexFormat._defaultInstancingFormat = null;

	var _class$2;
	var stringIds$2 = new StringIds();
	var StencilParameters = function () {
		function StencilParameters(options) {
			var _options$func, _options$ref, _options$readMask, _options$writeMask, _options$fail, _options$zfail, _options$zpass;
			if (options === void 0) {
				options = {};
			}
			this._func = void 0;
			this._ref = void 0;
			this._fail = void 0;
			this._zfail = void 0;
			this._zpass = void 0;
			this._readMask = void 0;
			this._writeMask = void 0;
			this._dirty = true;
			this._key = void 0;
			this._func = (_options$func = options.func) != null ? _options$func : FUNC_ALWAYS;
			this._ref = (_options$ref = options.ref) != null ? _options$ref : 0;
			this._readMask = (_options$readMask = options.readMask) != null ? _options$readMask : 0xFF;
			this._writeMask = (_options$writeMask = options.writeMask) != null ? _options$writeMask : 0xFF;
			this._fail = (_options$fail = options.fail) != null ? _options$fail : STENCILOP_KEEP;
			this._zfail = (_options$zfail = options.zfail) != null ? _options$zfail : STENCILOP_KEEP;
			this._zpass = (_options$zpass = options.zpass) != null ? _options$zpass : STENCILOP_KEEP;
			this._evalKey();
		}
		var _proto = StencilParameters.prototype;
		_proto._evalKey = function _evalKey() {
			var _func = this._func,
				_ref = this._ref,
				_fail = this._fail,
				_zfail = this._zfail,
				_zpass = this._zpass,
				_readMask = this._readMask,
				_writeMask = this._writeMask;
			var key = _func + "," + _ref + "," + _fail + "," + _zfail + "," + _zpass + "," + _readMask + "," + _writeMask;
			this._key = stringIds$2.get(key);
			this._dirty = false;
		};
		_proto.copy = function copy(rhs) {
			this._func = rhs._func;
			this._ref = rhs._ref;
			this._readMask = rhs._readMask;
			this._writeMask = rhs._writeMask;
			this._fail = rhs._fail;
			this._zfail = rhs._zfail;
			this._zpass = rhs._zpass;
			this._dirty = rhs._dirty;
			this._key = rhs._key;
			return this;
		};
		_proto.clone = function clone() {
			var clone = new this.constructor();
			return clone.copy(this);
		};
		_createClass(StencilParameters, [{
			key: "func",
			get: function get() {
				return this._func;
			},
			set: function set(value) {
				this._func = value;
				this._dirty = true;
			}
		}, {
			key: "ref",
			get: function get() {
				return this._ref;
			},
			set: function set(value) {
				this._ref = value;
				this._dirty = true;
			}
		}, {
			key: "fail",
			get: function get() {
				return this._fail;
			},
			set: function set(value) {
				this._fail = value;
				this._dirty = true;
			}
		}, {
			key: "zfail",
			get: function get() {
				return this._zfail;
			},
			set: function set(value) {
				this._zfail = value;
				this._dirty = true;
			}
		}, {
			key: "zpass",
			get: function get() {
				return this._zpass;
			},
			set: function set(value) {
				this._zpass = value;
				this._dirty = true;
			}
		}, {
			key: "readMask",
			get: function get() {
				return this._readMask;
			},
			set: function set(value) {
				this._readMask = value;
				this._dirty = true;
			}
		}, {
			key: "writeMask",
			get: function get() {
				return this._writeMask;
			},
			set: function set(value) {
				this._writeMask = value;
				this._dirty = true;
			}
		}, {
			key: "key",
			get: function get() {
				if (this._dirty) {
					this._evalKey();
				}
				return this._key;
			}
		}]);
		return StencilParameters;
	}();
	_class$2 = StencilParameters;
	StencilParameters.DEFAULT = Object.freeze(new _class$2());

	var GraphicsDevice = function (_EventHandler) {
		_inheritsLoose(GraphicsDevice, _EventHandler);
		function GraphicsDevice(canvas, options) {
			var _this$initOptions, _this$initOptions$dep, _this$initOptions2, _this$initOptions2$st, _this$initOptions3, _this$initOptions3$an, _this$initOptions4, _this$initOptions4$po;
			var _this;
			_this = _EventHandler.call(this) || this;
			_this.canvas = void 0;
			_this.backBuffer = null;
			_this.backBufferSize = new Vec2();
			_this.backBufferFormat = void 0;
			_this.backBufferAntialias = false;
			_this.isWebGPU = false;
			_this.isWebGL1 = false;
			_this.isWebGL2 = false;
			_this.scope = void 0;
			_this.boneLimit = void 0;
			_this.maxAnisotropy = void 0;
			_this.maxCubeMapSize = void 0;
			_this.maxTextureSize = void 0;
			_this.maxVolumeSize = void 0;
			_this.maxColorAttachments = 1;
			_this.precision = void 0;
			_this.samples = void 0;
			_this.supportsStencil = void 0;
			_this.supportsMrt = false;
			_this.supportsVolumeTextures = false;
			_this.supportsCompute = false;
			_this.renderTarget = null;
			_this.shaders = [];
			_this.textures = [];
			_this.targets = new Set();
			_this.renderVersion = 0;
			_this.renderPassIndex = void 0;
			_this.insideRenderPass = false;
			_this.supportsInstancing = void 0;
			_this.supportsUniformBuffers = false;
			_this.textureFloatRenderable = void 0;
			_this.textureHalfFloatRenderable = void 0;
			_this.textureFloatFilterable = false;
			_this.textureHalfFloatFilterable = false;
			_this.quadVertexBuffer = void 0;
			_this.blendState = new BlendState();
			_this.depthState = new DepthState();
			_this.stencilEnabled = false;
			_this.stencilFront = new StencilParameters();
			_this.stencilBack = new StencilParameters();
			_this.dynamicBuffers = void 0;
			_this.gpuProfiler = void 0;
			_this.defaultClearOptions = {
				color: [0, 0, 0, 1],
				depth: 1,
				stencil: 0,
				flags: CLEARFLAG_COLOR | CLEARFLAG_DEPTH
			};
			_this.canvas = canvas;
			_this.initOptions = _extends({}, options);
			(_this$initOptions$dep = (_this$initOptions = _this.initOptions).depth) != null ? _this$initOptions$dep : _this$initOptions.depth = true;
			(_this$initOptions2$st = (_this$initOptions2 = _this.initOptions).stencil) != null ? _this$initOptions2$st : _this$initOptions2.stencil = true;
			(_this$initOptions3$an = (_this$initOptions3 = _this.initOptions).antialias) != null ? _this$initOptions3$an : _this$initOptions3.antialias = true;
			(_this$initOptions4$po = (_this$initOptions4 = _this.initOptions).powerPreference) != null ? _this$initOptions4$po : _this$initOptions4.powerPreference = 'high-performance';
			_this._maxPixelRatio = platform.browser ? Math.min(1, window.devicePixelRatio) : 1;
			_this.buffers = [];
			_this._vram = {
				tex: 0,
				vb: 0,
				ib: 0,
				ub: 0
			};
			_this._shaderStats = {
				vsCompiled: 0,
				fsCompiled: 0,
				linked: 0,
				materialShaders: 0,
				compileTime: 0
			};
			_this.initializeContextCaches();
			_this._drawCallsPerFrame = 0;
			_this._shaderSwitchesPerFrame = 0;
			_this._primsPerFrame = [];
			for (var i = PRIMITIVE_POINTS; i <= PRIMITIVE_TRIFAN; i++) {
				_this._primsPerFrame[i] = 0;
			}
			_this._renderTargetCreationTime = 0;
			_this.scope = new ScopeSpace("Device");
			_this.textureBias = _this.scope.resolve("textureBias");
			_this.textureBias.setValue(0.0);
			return _this;
		}
		var _proto = GraphicsDevice.prototype;
		_proto.postInit = function postInit() {
			var vertexFormat = new VertexFormat(this, [{
				semantic: SEMANTIC_POSITION,
				components: 2,
				type: TYPE_FLOAT32
			}]);
			var positions = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
			this.quadVertexBuffer = new VertexBuffer(this, vertexFormat, 4, BUFFER_STATIC, positions);
		};
		_proto.destroy = function destroy() {
			var _this$quadVertexBuffe, _this$dynamicBuffers, _this$gpuProfiler;
			this.fire('destroy');
			(_this$quadVertexBuffe = this.quadVertexBuffer) == null || _this$quadVertexBuffe.destroy();
			this.quadVertexBuffer = null;
			(_this$dynamicBuffers = this.dynamicBuffers) == null || _this$dynamicBuffers.destroy();
			this.dynamicBuffers = null;
			(_this$gpuProfiler = this.gpuProfiler) == null || _this$gpuProfiler.destroy();
			this.gpuProfiler = null;
		};
		_proto.onDestroyShader = function onDestroyShader(shader) {
			this.fire('destroy:shader', shader);
			var idx = this.shaders.indexOf(shader);
			if (idx !== -1) {
				this.shaders.splice(idx, 1);
			}
		};
		_proto.postDestroy = function postDestroy() {
			this.scope = null;
			this.canvas = null;
		};
		_proto.toJSON = function toJSON(key) {
			return undefined;
		};
		_proto.initializeContextCaches = function initializeContextCaches() {
			this.indexBuffer = null;
			this.vertexBuffers = [];
			this.shader = null;
			this.renderTarget = null;
		};
		_proto.initializeRenderState = function initializeRenderState() {
			this.blendState = new BlendState();
			this.depthState = new DepthState();
			this.cullMode = CULLFACE_BACK;
			this.vx = this.vy = this.vw = this.vh = 0;
			this.sx = this.sy = this.sw = this.sh = 0;
		};
		_proto.setStencilState = function setStencilState(stencilFront, stencilBack) {};
		_proto.setBlendState = function setBlendState(blendState) {};
		_proto.setDepthState = function setDepthState(depthState) {};
		_proto.setCullMode = function setCullMode(cullMode) {};
		_proto.setRenderTarget = function setRenderTarget(renderTarget) {
			this.renderTarget = renderTarget;
		};
		_proto.setIndexBuffer = function setIndexBuffer(indexBuffer) {
			this.indexBuffer = indexBuffer;
		};
		_proto.setVertexBuffer = function setVertexBuffer(vertexBuffer) {
			if (vertexBuffer) {
				this.vertexBuffers.push(vertexBuffer);
			}
		};
		_proto.getRenderTarget = function getRenderTarget() {
			return this.renderTarget;
		};
		_proto.initRenderTarget = function initRenderTarget(target) {
			if (target.initialized) return;
			target.init();
			this.targets.add(target);
		};
		_proto._isBrowserInterface = function _isBrowserInterface(texture) {
			return this._isImageBrowserInterface(texture) || this._isImageCanvasInterface(texture) || this._isImageVideoInterface(texture);
		};
		_proto._isImageBrowserInterface = function _isImageBrowserInterface(texture) {
			return typeof ImageBitmap !== 'undefined' && texture instanceof ImageBitmap || typeof HTMLImageElement !== 'undefined' && texture instanceof HTMLImageElement;
		};
		_proto._isImageCanvasInterface = function _isImageCanvasInterface(texture) {
			return typeof HTMLCanvasElement !== 'undefined' && texture instanceof HTMLCanvasElement;
		};
		_proto._isImageVideoInterface = function _isImageVideoInterface(texture) {
			return typeof HTMLVideoElement !== 'undefined' && texture instanceof HTMLVideoElement;
		};
		_proto.resizeCanvas = function resizeCanvas(width, height) {
			var pixelRatio = Math.min(this._maxPixelRatio, platform.browser ? window.devicePixelRatio : 1);
			var w = Math.floor(width * pixelRatio);
			var h = Math.floor(height * pixelRatio);
			if (w !== this.canvas.width || h !== this.canvas.height) {
				this.setResolution(w, h);
			}
		};
		_proto.setResolution = function setResolution(width, height) {
			this.canvas.width = width;
			this.canvas.height = height;
			this.fire(GraphicsDevice.EVENT_RESIZE, width, height);
		};
		_proto.updateClientRect = function updateClientRect() {
			this.clientRect = this.canvas.getBoundingClientRect();
		};
		_proto.getBoneLimit = function getBoneLimit() {
			return this.boneLimit;
		};
		_proto.setBoneLimit = function setBoneLimit(maxBones) {
			this.boneLimit = maxBones;
		};
		_proto.startRenderPass = function startRenderPass(renderPass) {};
		_proto.endRenderPass = function endRenderPass(renderPass) {};
		_proto.startComputePass = function startComputePass() {};
		_proto.endComputePass = function endComputePass() {};
		_proto.frameStart = function frameStart() {
			this.renderPassIndex = 0;
			this.renderVersion++;
		};
		_proto.frameEnd = function frameEnd() {};
		_proto.getRenderableHdrFormat = function getRenderableHdrFormat(formats, filterable) {
			if (formats === void 0) {
				formats = [PIXELFORMAT_111110F, PIXELFORMAT_RGBA16F, PIXELFORMAT_RGBA32F];
			}
			if (filterable === void 0) {
				filterable = true;
			}
			for (var i = 0; i < formats.length; i++) {
				var format = formats[i];
				switch (format) {
					case PIXELFORMAT_111110F:
						{
							if (this.textureRG11B10Renderable) return format;
							break;
						}
					case PIXELFORMAT_RGBA16F:
						if (this.textureHalfFloatRenderable && (!filterable || this.textureHalfFloatFilterable)) {
							return format;
						}
						break;
					case PIXELFORMAT_RGBA32F:
						if (this.textureFloatRenderable && (!filterable || this.textureFloatFilterable)) {
							return format;
						}
						break;
				}
			}
			return undefined;
		};
		_createClass(GraphicsDevice, [{
			key: "width",
			get: function get() {
				return this.canvas.width;
			}
		}, {
			key: "height",
			get: function get() {
				return this.canvas.height;
			}
		}, {
			key: "fullscreen",
			get: function get() {
				return false;
			},
			set: function set(fullscreen) {}
		}, {
			key: "maxPixelRatio",
			get: function get() {
				return this._maxPixelRatio;
			},
			set: function set(ratio) {
				this._maxPixelRatio = ratio;
			}
		}, {
			key: "deviceType",
			get: function get() {
				return this._deviceType;
			}
		}]);
		return GraphicsDevice;
	}(EventHandler);
	GraphicsDevice.EVENT_RESIZE = 'resizecanvas';

	var id$9 = 0;
	var RenderTarget = function () {
		function RenderTarget(options) {
			var _options$face, _this$_colorBuffer, _this$_depthBuffer, _this$_colorBuffers, _options$samples, _options$autoResolve, _options$flipY;
			if (options === void 0) {
				options = {};
			}
			this.name = void 0;
			this._device = void 0;
			this._colorBuffer = void 0;
			this._colorBuffers = void 0;
			this._depthBuffer = void 0;
			this._depth = void 0;
			this._stencil = void 0;
			this._samples = void 0;
			this.autoResolve = void 0;
			this._face = void 0;
			this.flipY = void 0;
			this.id = id$9++;
			var _arg2 = arguments[1];
			var _arg3 = arguments[2];
			if (options instanceof GraphicsDevice) {
				this._colorBuffer = _arg2;
				options = _arg3;
			} else {
				this._colorBuffer = options.colorBuffer;
			}
			if (this._colorBuffer) {
				this._colorBuffers = [this._colorBuffer];
			}
			this._depthBuffer = options.depthBuffer;
			this._face = (_options$face = options.face) != null ? _options$face : 0;
			if (this._depthBuffer) {
				var format = this._depthBuffer._format;
				if (format === PIXELFORMAT_DEPTH) {
					this._depth = true;
					this._stencil = false;
				} else if (format === PIXELFORMAT_DEPTHSTENCIL) {
					this._depth = true;
					this._stencil = true;
				} else {
					this._depth = false;
					this._stencil = false;
				}
			} else {
				var _options$depth, _options$stencil;
				this._depth = (_options$depth = options.depth) != null ? _options$depth : true;
				this._stencil = (_options$stencil = options.stencil) != null ? _options$stencil : false;
			}
			if (options.colorBuffers) {
				if (!this._colorBuffers) {
					this._colorBuffers = [].concat(options.colorBuffers);
					this._colorBuffer = options.colorBuffers[0];
				}
			}
			var device = ((_this$_colorBuffer = this._colorBuffer) == null ? void 0 : _this$_colorBuffer.device) || ((_this$_depthBuffer = this._depthBuffer) == null ? void 0 : _this$_depthBuffer.device) || options.graphicsDevice;
			this._device = device;
			(_this$_colorBuffers = this._colorBuffers) == null || _this$_colorBuffers.forEach(function (colorBuffer) {
				colorBuffer._isRenderTarget = true;
			});
			var maxSamples = this._device.maxSamples;
			this._samples = Math.min((_options$samples = options.samples) != null ? _options$samples : 1, maxSamples);
			if (device.isWebGPU) {
				this._samples = this._samples > 1 ? maxSamples : 1;
			}
			this.autoResolve = (_options$autoResolve = options.autoResolve) != null ? _options$autoResolve : true;
			this.name = options.name;
			if (!this.name) {
				var _this$_colorBuffer2;
				this.name = (_this$_colorBuffer2 = this._colorBuffer) == null ? void 0 : _this$_colorBuffer2.name;
			}
			if (!this.name) {
				var _this$_depthBuffer2;
				this.name = (_this$_depthBuffer2 = this._depthBuffer) == null ? void 0 : _this$_depthBuffer2.name;
			}
			if (!this.name) {
				this.name = "Untitled";
			}
			this.flipY = (_options$flipY = options.flipY) != null ? _options$flipY : false;
			this.validateMrt();
			this.impl = device.createRenderTargetImpl(this);
		}
		var _proto = RenderTarget.prototype;
		_proto.destroy = function destroy() {
			var device = this._device;
			if (device) {
				device.targets.delete(this);
				if (device.renderTarget === this) {
					device.setRenderTarget(null);
				}
				this.destroyFrameBuffers();
			}
		};
		_proto.destroyFrameBuffers = function destroyFrameBuffers() {
			var device = this._device;
			if (device) {
				this.impl.destroy(device);
			}
		};
		_proto.destroyTextureBuffers = function destroyTextureBuffers() {
			var _this$_depthBuffer3, _this$_colorBuffers2;
			(_this$_depthBuffer3 = this._depthBuffer) == null || _this$_depthBuffer3.destroy();
			this._depthBuffer = null;
			(_this$_colorBuffers2 = this._colorBuffers) == null || _this$_colorBuffers2.forEach(function (colorBuffer) {
				colorBuffer.destroy();
			});
			this._colorBuffers = null;
			this._colorBuffer = null;
		};
		_proto.resize = function resize(width, height) {
			if (this.width !== width || this.height !== height) {
				var _this$_depthBuffer4, _this$_colorBuffers3;
				var device = this._device;
				this.destroyFrameBuffers();
				if (device.renderTarget === this) {
					device.setRenderTarget(null);
				}
				(_this$_depthBuffer4 = this._depthBuffer) == null || _this$_depthBuffer4.resize(width, height);
				(_this$_colorBuffers3 = this._colorBuffers) == null || _this$_colorBuffers3.forEach(function (colorBuffer) {
					colorBuffer.resize(width, height);
				});
				this.validateMrt();
				this.impl = device.createRenderTargetImpl(this);
			}
		};
		_proto.validateMrt = function validateMrt() {};
		_proto.init = function init() {
			this.impl.init(this._device, this);
		};
		_proto.loseContext = function loseContext() {
			this.impl.loseContext();
		};
		_proto.resolve = function resolve(color, depth) {
			if (color === void 0) {
				color = true;
			}
			if (depth === void 0) {
				depth = !!this._depthBuffer;
			}
			if (this._device && this._samples > 1) {
				this.impl.resolve(this._device, this, color, depth);
			}
		};
		_proto.copy = function copy(source, color, depth) {
			if (!this._device) {
				if (source._device) {
					this._device = source._device;
				} else {
					return false;
				}
			}
			var success = this._device.copyRenderTarget(source, this, color, depth);
			return success;
		};
		_proto.getColorBuffer = function getColorBuffer(index) {
			var _this$_colorBuffers4;
			return (_this$_colorBuffers4 = this._colorBuffers) == null ? void 0 : _this$_colorBuffers4[index];
		};
		_createClass(RenderTarget, [{
			key: "initialized",
			get: function get() {
				return this.impl.initialized;
			}
		}, {
			key: "device",
			get: function get() {
				return this._device;
			}
		}, {
			key: "samples",
			get: function get() {
				return this._samples;
			}
		}, {
			key: "depth",
			get: function get() {
				return this._depth;
			}
		}, {
			key: "stencil",
			get: function get() {
				return this._stencil;
			}
		}, {
			key: "colorBuffer",
			get: function get() {
				return this._colorBuffer;
			}
		}, {
			key: "depthBuffer",
			get: function get() {
				return this._depthBuffer;
			}
		}, {
			key: "face",
			get: function get() {
				return this._face;
			}
		}, {
			key: "width",
			get: function get() {
				var _this$_colorBuffer3, _this$_depthBuffer5;
				return ((_this$_colorBuffer3 = this._colorBuffer) == null ? void 0 : _this$_colorBuffer3.width) || ((_this$_depthBuffer5 = this._depthBuffer) == null ? void 0 : _this$_depthBuffer5.width) || this._device.width;
			}
		}, {
			key: "height",
			get: function get() {
				var _this$_colorBuffer4, _this$_depthBuffer6;
				return ((_this$_colorBuffer4 = this._colorBuffer) == null ? void 0 : _this$_colorBuffer4.height) || ((_this$_depthBuffer6 = this._depthBuffer) == null ? void 0 : _this$_depthBuffer6.height) || this._device.height;
			}
		}]);
		return RenderTarget;
	}();

	var WebgpuBindGroup = function () {
		function WebgpuBindGroup() {
			this.bindGroup = void 0;
		}
		var _proto = WebgpuBindGroup.prototype;
		_proto.update = function update(bindGroup) {
			this.destroy();
			var device = bindGroup.device;
			var descr = this.createDescriptor(device, bindGroup);
			this.bindGroup = device.wgpu.createBindGroup(descr);
		};
		_proto.destroy = function destroy() {
			this.bindGroup = null;
		};
		_proto.createDescriptor = function createDescriptor(device, bindGroup) {
			var entries = [];
			var format = bindGroup.format;
			var index = 0;
			bindGroup.uniformBuffers.forEach(function (ub) {
				var buffer = ub.persistent ? ub.impl.buffer : ub.allocation.gpuBuffer.buffer;
				entries.push({
					binding: index++,
					resource: {
						buffer: buffer,
						offset: 0,
						size: ub.format.byteSize
					}
				});
			});
			bindGroup.textures.forEach(function (tex, textureIndex) {
				var wgpuTexture = tex.impl;
				var textureFormat = format.textureFormats[textureIndex];
				var view = wgpuTexture.getView(device);
				entries.push({
					binding: index++,
					resource: view
				});
				var sampler = wgpuTexture.getSampler(device, textureFormat.sampleType);
				entries.push({
					binding: index++,
					resource: sampler
				});
			});
			bindGroup.storageTextures.forEach(function (tex, textureIndex) {
				var wgpuTexture = tex.impl;
				var view = wgpuTexture.getView(device);
				entries.push({
					binding: index++,
					resource: view
				});
			});
			var descr = {
				layout: bindGroup.format.impl.bindGroupLayout,
				entries: entries
			};
			return descr;
		};
		return WebgpuBindGroup;
	}();

	var WebgpuUtils = function () {
		function WebgpuUtils() {}
		WebgpuUtils.shaderStage = function shaderStage(stage) {
			var ret = 0;
			if (stage & SHADERSTAGE_VERTEX) ret |= GPUShaderStage.VERTEX;
			if (stage & SHADERSTAGE_FRAGMENT) ret |= GPUShaderStage.FRAGMENT;
			if (stage & SHADERSTAGE_COMPUTE) ret |= GPUShaderStage.COMPUTE;
			return ret;
		};
		return WebgpuUtils;
	}();

	var gpuTextureFormats = [];
	gpuTextureFormats[PIXELFORMAT_A8] = '';
	gpuTextureFormats[PIXELFORMAT_L8] = 'r8unorm';
	gpuTextureFormats[PIXELFORMAT_LA8] = 'rg8unorm';
	gpuTextureFormats[PIXELFORMAT_RGB565] = '';
	gpuTextureFormats[PIXELFORMAT_RGBA5551] = '';
	gpuTextureFormats[PIXELFORMAT_RGBA4] = '';
	gpuTextureFormats[PIXELFORMAT_RGB8] = 'rgba8unorm';
	gpuTextureFormats[PIXELFORMAT_RGBA8] = 'rgba8unorm';
	gpuTextureFormats[PIXELFORMAT_DXT1] = 'bc1-rgba-unorm';
	gpuTextureFormats[PIXELFORMAT_DXT3] = 'bc2-rgba-unorm';
	gpuTextureFormats[PIXELFORMAT_DXT5] = 'bc3-rgba-unorm';
	gpuTextureFormats[PIXELFORMAT_RGB16F] = '';
	gpuTextureFormats[PIXELFORMAT_RGBA16F] = 'rgba16float';
	gpuTextureFormats[PIXELFORMAT_RGB32F] = '';
	gpuTextureFormats[PIXELFORMAT_RGBA32F] = 'rgba32float';
	gpuTextureFormats[PIXELFORMAT_R32F] = 'r32float';
	gpuTextureFormats[PIXELFORMAT_DEPTH] = 'depth32float';
	gpuTextureFormats[PIXELFORMAT_DEPTHSTENCIL] = 'depth24plus-stencil8';
	gpuTextureFormats[PIXELFORMAT_111110F] = 'rg11b10ufloat';
	gpuTextureFormats[PIXELFORMAT_SRGB] = '';
	gpuTextureFormats[PIXELFORMAT_SRGBA] = '';
	gpuTextureFormats[PIXELFORMAT_ETC1] = '';
	gpuTextureFormats[PIXELFORMAT_ETC2_RGB] = 'etc2-rgb8unorm';
	gpuTextureFormats[PIXELFORMAT_ETC2_RGBA] = 'etc2-rgba8unorm';
	gpuTextureFormats[PIXELFORMAT_PVRTC_2BPP_RGB_1] = '';
	gpuTextureFormats[PIXELFORMAT_PVRTC_2BPP_RGBA_1] = '';
	gpuTextureFormats[PIXELFORMAT_PVRTC_4BPP_RGB_1] = '';
	gpuTextureFormats[PIXELFORMAT_PVRTC_4BPP_RGBA_1] = '';
	gpuTextureFormats[PIXELFORMAT_ASTC_4x4] = 'astc-4x4-unorm';
	gpuTextureFormats[PIXELFORMAT_ATC_RGB] = '';
	gpuTextureFormats[PIXELFORMAT_ATC_RGBA] = '';
	gpuTextureFormats[PIXELFORMAT_BGRA8] = 'bgra8unorm';

	var samplerTypes = [];
	samplerTypes[SAMPLETYPE_FLOAT] = 'filtering';
	samplerTypes[SAMPLETYPE_UNFILTERABLE_FLOAT] = 'non-filtering';
	samplerTypes[SAMPLETYPE_DEPTH] = 'comparison';
	var sampleTypes = [];
	sampleTypes[SAMPLETYPE_FLOAT] = 'float';
	sampleTypes[SAMPLETYPE_UNFILTERABLE_FLOAT] = 'unfilterable-float';
	sampleTypes[SAMPLETYPE_DEPTH] = 'depth';
	var stringIds$1 = new StringIds();
	var WebgpuBindGroupFormat = function () {
		function WebgpuBindGroupFormat(bindGroupFormat) {
			var device = bindGroupFormat.device;
			var _this$createDescripto = this.createDescriptor(bindGroupFormat),
				key = _this$createDescripto.key,
				descr = _this$createDescripto.descr;
			this.key = stringIds$1.get(key);
			this.bindGroupLayout = device.wgpu.createBindGroupLayout(descr);
		}
		var _proto = WebgpuBindGroupFormat.prototype;
		_proto.destroy = function destroy() {
			this.bindGroupLayout = null;
		};
		_proto.loseContext = function loseContext() {};
		_proto.getTextureSlot = function getTextureSlot(bindGroupFormat, index) {
			return bindGroupFormat.bufferFormats.length + index * 2;
		};
		_proto.createDescriptor = function createDescriptor(bindGroupFormat) {
			var entries = [];
			var key = '';
			var index = 0;
			bindGroupFormat.bufferFormats.forEach(function (bufferFormat) {
				var visibility = WebgpuUtils.shaderStage(bufferFormat.visibility);
				key += "#" + index + "U:" + visibility;
				entries.push({
					binding: index++,
					visibility: visibility,
					buffer: {
						type: 'uniform',
						hasDynamicOffset: true
					}
				});
			});
			bindGroupFormat.textureFormats.forEach(function (textureFormat) {
				var visibility = WebgpuUtils.shaderStage(textureFormat.visibility);
				var sampleType = textureFormat.sampleType;
				var viewDimension = textureFormat.textureDimension;
				var multisampled = false;
				var gpuSampleType = sampleTypes[sampleType];
				key += "#" + index + "T:" + visibility + "-" + gpuSampleType + "-" + viewDimension + "-" + multisampled;
				entries.push({
					binding: index++,
					visibility: visibility,
					texture: {
						sampleType: gpuSampleType,
						viewDimension: viewDimension,
						multisampled: multisampled
					}
				});
				var gpuSamplerType = samplerTypes[sampleType];
				key += "#" + index + "S:" + visibility + "-" + gpuSamplerType;
				entries.push({
					binding: index++,
					visibility: visibility,
					sampler: {
						type: gpuSamplerType
					}
				});
			});
			bindGroupFormat.storageTextureFormats.forEach(function (textureFormat) {
				var format = textureFormat.format,
					textureDimension = textureFormat.textureDimension;
				key += "#" + index + "ST:" + format + "-" + textureDimension;
				entries.push({
					binding: index++,
					visibility: GPUShaderStage.COMPUTE,
					storageTexture: {
						access: 'write-only',
						format: gpuTextureFormats[format],
						viewDimension: textureDimension
					}
				});
			});
			var descr = {
				entries: entries
			};
			return {
				key: key,
				descr: descr
			};
		};
		return WebgpuBindGroupFormat;
	}();

	var WebgpuBuffer = function () {
		function WebgpuBuffer() {
			this.buffer = null;
		}
		var _proto = WebgpuBuffer.prototype;
		_proto.destroy = function destroy(device) {
			if (this.buffer) {
				this.buffer.destroy();
				this.buffer = null;
			}
		};
		_proto.loseContext = function loseContext() {};
		_proto.unlock = function unlock(device, usage, target, storage) {
			var _storage$byteOffset, _storage$buffer;
			var wgpu = device.wgpu;
			if (!this.buffer) {
				var size = storage.byteLength + 3 & ~3;
				this.buffer = device.wgpu.createBuffer({
					size: size,
					usage: target | GPUBufferUsage.COPY_DST
				});
			}
			var srcOffset = (_storage$byteOffset = storage.byteOffset) != null ? _storage$byteOffset : 0;
			var srcData = new Uint8Array((_storage$buffer = storage.buffer) != null ? _storage$buffer : storage, srcOffset, storage.byteLength);
			var data = new Uint8Array(this.buffer.size);
			data.set(srcData);
			wgpu.queue.writeBuffer(this.buffer, 0, data, 0, data.length);
		};
		_createClass(WebgpuBuffer, [{
			key: "initialized",
			get: function get() {
				return !!this.buffer;
			}
		}]);
		return WebgpuBuffer;
	}();

	var WebgpuIndexBuffer = function (_WebgpuBuffer) {
		_inheritsLoose(WebgpuIndexBuffer, _WebgpuBuffer);
		function WebgpuIndexBuffer(indexBuffer) {
			var _this;
			_this = _WebgpuBuffer.call(this) || this;
			_this.format = null;
			_this.format = indexBuffer.format === INDEXFORMAT_UINT16 ? "uint16" : "uint32";
			return _this;
		}
		var _proto = WebgpuIndexBuffer.prototype;
		_proto.unlock = function unlock(indexBuffer) {
			var device = indexBuffer.device;
			_WebgpuBuffer.prototype.unlock.call(this, device, indexBuffer.usage, GPUBufferUsage.INDEX, indexBuffer.storage);
		};
		return WebgpuIndexBuffer;
	}(WebgpuBuffer);

	var array = {
		equals: function equals(arr1, arr2) {
			if (arr1.size !== arr2.size) {
				return false;
			}
			for (var i = 0; i < arr1.length; i++) {
				if (arr1[i] !== arr2[i]) {
					return false;
				}
			}
			return true;
		}
	};

	var gpuVertexFormats = [];
	gpuVertexFormats[TYPE_INT8] = 'sint8';
	gpuVertexFormats[TYPE_UINT8] = 'uint8';
	gpuVertexFormats[TYPE_INT16] = 'sint16';
	gpuVertexFormats[TYPE_UINT16] = 'uint16';
	gpuVertexFormats[TYPE_INT32] = 'sint32';
	gpuVertexFormats[TYPE_UINT32] = 'uint32';
	gpuVertexFormats[TYPE_FLOAT32] = 'float32';
	gpuVertexFormats[TYPE_FLOAT16] = 'float16';
	var gpuVertexFormatsNormalized = [];
	gpuVertexFormatsNormalized[TYPE_INT8] = 'snorm8';
	gpuVertexFormatsNormalized[TYPE_UINT8] = 'unorm8';
	gpuVertexFormatsNormalized[TYPE_INT16] = 'snorm16';
	gpuVertexFormatsNormalized[TYPE_UINT16] = 'unorm16';
	gpuVertexFormatsNormalized[TYPE_INT32] = 'sint32';
	gpuVertexFormatsNormalized[TYPE_UINT32] = 'uint32';
	gpuVertexFormatsNormalized[TYPE_FLOAT32] = 'float32';
	gpuVertexFormatsNormalized[TYPE_FLOAT16] = 'float16';
	var WebgpuVertexBufferLayout = function () {
		function WebgpuVertexBufferLayout() {
			this.cache = new Map();
		}
		var _proto = WebgpuVertexBufferLayout.prototype;
		_proto.get = function get(vertexFormat0, vertexFormat1) {
			if (vertexFormat1 === void 0) {
				vertexFormat1 = null;
			}
			var key = this.getKey(vertexFormat0, vertexFormat1);
			var layout = this.cache.get(key);
			if (!layout) {
				layout = this.create(vertexFormat0, vertexFormat1);
				this.cache.set(key, layout);
			}
			return layout;
		};
		_proto.getKey = function getKey(vertexFormat0, vertexFormat1) {
			var _vertexFormat;
			if (vertexFormat1 === void 0) {
				vertexFormat1 = null;
			}
			return (vertexFormat0 == null ? void 0 : vertexFormat0.renderingHashString) + "-" + ((_vertexFormat = vertexFormat1) == null ? void 0 : _vertexFormat.renderingHashString);
		};
		_proto.create = function create(vertexFormat0, vertexFormat1) {
			var layout = [];
			var addFormat = function addFormat(format) {
				var interleaved = format.interleaved;
				var stepMode = format.instancing ? 'instance' : 'vertex';
				var attributes = [];
				var elementCount = format.elements.length;
				for (var i = 0; i < elementCount; i++) {
					var element = format.elements[i];
					var location = semanticToLocation[element.name];
					var formatTable = element.normalize ? gpuVertexFormatsNormalized : gpuVertexFormats;
					attributes.push({
						shaderLocation: location,
						offset: interleaved ? element.offset : 0,
						format: "" + formatTable[element.dataType] + (element.numComponents > 1 ? 'x' + element.numComponents : '')
					});
					if (!interleaved || i === elementCount - 1) {
						layout.push({
							attributes: attributes,
							arrayStride: element.stride,
							stepMode: stepMode
						});
						attributes = [];
					}
				}
			};
			if (vertexFormat0) addFormat(vertexFormat0);
			if (vertexFormat1) addFormat(vertexFormat1);
			return layout;
		};
		return WebgpuVertexBufferLayout;
	}();

	var WebgpuPipeline = function () {
		function WebgpuPipeline(device) {
			this.device = device;
		}
		var _proto = WebgpuPipeline.prototype;
		_proto.getPipelineLayout = function getPipelineLayout(bindGroupFormats) {
			var bindGroupLayouts = [];
			bindGroupFormats.forEach(function (format) {
				bindGroupLayouts.push(format.bindGroupLayout);
			});
			var descr = {
				bindGroupLayouts: bindGroupLayouts
			};
			var pipelineLayout = this.device.wgpu.createPipelineLayout(descr);
			return pipelineLayout;
		};
		return WebgpuPipeline;
	}();

	var _primitiveTopology = ['point-list', 'line-list', undefined, 'line-strip', 'triangle-list', 'triangle-strip', undefined];
	var _blendOperation = ['add', 'subtract', 'reverse-subtract', 'min', 'max'];
	var _blendFactor = ['zero', 'one', 'src', 'one-minus-src', 'dst', 'one-minus-dst', 'src-alpha', 'src-alpha-saturated', 'one-minus-src-alpha', 'dst-alpha', 'one-minus-dst-alpha', 'constant', 'one-minus-constant'];
	var _compareFunction = ['never', 'less', 'equal', 'less-equal', 'greater', 'not-equal', 'greater-equal', 'always'];
	var _cullModes = ['none', 'back', 'front'];
	var _stencilOps = ['keep', 'zero', 'replace', 'increment-clamp', 'increment-wrap', 'decrement-clamp', 'decrement-wrap', 'invert'];
	var CacheEntry = function CacheEntry() {
		this.pipeline = void 0;
		this.hashes = void 0;
	};
	var WebgpuRenderPipeline = function (_WebgpuPipeline) {
		_inheritsLoose(WebgpuRenderPipeline, _WebgpuPipeline);
		function WebgpuRenderPipeline(device) {
			var _this;
			_this = _WebgpuPipeline.call(this, device) || this;
			_this.lookupHashes = new Uint32Array(13);
			_this.vertexBufferLayout = new WebgpuVertexBufferLayout();
			_this.cache = new Map();
			return _this;
		}
		var _proto = WebgpuRenderPipeline.prototype;
		_proto.get = function get(primitive, vertexFormat0, vertexFormat1, shader, renderTarget, bindGroupFormats, blendState, depthState, cullMode, stencilEnabled, stencilFront, stencilBack) {
			var _vertexFormat0$render, _vertexFormat1$render, _bindGroupFormats$0$k, _bindGroupFormats$, _bindGroupFormats$1$k, _bindGroupFormats$2, _bindGroupFormats$2$k, _bindGroupFormats$3;
			var lookupHashes = this.lookupHashes;
			lookupHashes[0] = primitive.type;
			lookupHashes[1] = shader.id;
			lookupHashes[2] = cullMode;
			lookupHashes[3] = depthState.key;
			lookupHashes[4] = blendState.key;
			lookupHashes[5] = (_vertexFormat0$render = vertexFormat0 == null ? void 0 : vertexFormat0.renderingHash) != null ? _vertexFormat0$render : 0;
			lookupHashes[6] = (_vertexFormat1$render = vertexFormat1 == null ? void 0 : vertexFormat1.renderingHash) != null ? _vertexFormat1$render : 0;
			lookupHashes[7] = renderTarget.impl.key;
			lookupHashes[8] = (_bindGroupFormats$0$k = (_bindGroupFormats$ = bindGroupFormats[0]) == null ? void 0 : _bindGroupFormats$.key) != null ? _bindGroupFormats$0$k : 0;
			lookupHashes[9] = (_bindGroupFormats$1$k = (_bindGroupFormats$2 = bindGroupFormats[1]) == null ? void 0 : _bindGroupFormats$2.key) != null ? _bindGroupFormats$1$k : 0;
			lookupHashes[10] = (_bindGroupFormats$2$k = (_bindGroupFormats$3 = bindGroupFormats[2]) == null ? void 0 : _bindGroupFormats$3.key) != null ? _bindGroupFormats$2$k : 0;
			lookupHashes[11] = stencilEnabled ? stencilFront.key : 0;
			lookupHashes[12] = stencilEnabled ? stencilBack.key : 0;
			var hash = hash32Fnv1a(lookupHashes);
			var cacheEntries = this.cache.get(hash);
			if (cacheEntries) {
				for (var i = 0; i < cacheEntries.length; i++) {
					var entry = cacheEntries[i];
					if (array.equals(entry.hashes, lookupHashes)) {
						return entry.pipeline;
					}
				}
			}
			var primitiveTopology = _primitiveTopology[primitive.type];
			var pipelineLayout = this.getPipelineLayout(bindGroupFormats);
			var vertexBufferLayout = this.vertexBufferLayout.get(vertexFormat0, vertexFormat1);
			var cacheEntry = new CacheEntry();
			cacheEntry.hashes = new Uint32Array(lookupHashes);
			cacheEntry.pipeline = this.create(primitiveTopology, shader, renderTarget, pipelineLayout, blendState, depthState, vertexBufferLayout, cullMode, stencilEnabled, stencilFront, stencilBack);
			if (cacheEntries) {
				cacheEntries.push(cacheEntry);
			} else {
				cacheEntries = [cacheEntry];
			}
			this.cache.set(hash, cacheEntries);
			return cacheEntry.pipeline;
		};
		_proto.getBlend = function getBlend(blendState) {
			var blend;
			if (blendState.blend) {
				blend = {
					color: {
						operation: _blendOperation[blendState.colorOp],
						srcFactor: _blendFactor[blendState.colorSrcFactor],
						dstFactor: _blendFactor[blendState.colorDstFactor]
					},
					alpha: {
						operation: _blendOperation[blendState.alphaOp],
						srcFactor: _blendFactor[blendState.alphaSrcFactor],
						dstFactor: _blendFactor[blendState.alphaDstFactor]
					}
				};
			}
			return blend;
		};
		_proto.getDepthStencil = function getDepthStencil(depthState, renderTarget, stencilEnabled, stencilFront, stencilBack) {
			var depthStencil;
			var depth = renderTarget.depth,
				stencil = renderTarget.stencil;
			if (depth || stencil) {
				depthStencil = {
					format: renderTarget.impl.depthFormat
				};
				if (depth) {
					depthStencil.depthWriteEnabled = depthState.write;
					depthStencil.depthCompare = _compareFunction[depthState.func];
				} else {
					depthStencil.depthWriteEnabled = false;
					depthStencil.depthCompare = 'always';
				}
				if (stencil && stencilEnabled) {
					depthStencil.stencilReadMas = stencilFront.readMask;
					depthStencil.stencilWriteMask = stencilFront.writeMask;
					depthStencil.stencilFront = {
						compare: _compareFunction[stencilFront.func],
						failOp: _stencilOps[stencilFront.fail],
						passOp: _stencilOps[stencilFront.zpass],
						depthFailOp: _stencilOps[stencilFront.zfail]
					};
					depthStencil.stencilBack = {
						compare: _compareFunction[stencilBack.func],
						failOp: _stencilOps[stencilBack.fail],
						passOp: _stencilOps[stencilBack.zpass],
						depthFailOp: _stencilOps[stencilBack.zfail]
					};
				}
			}
			return depthStencil;
		};
		_proto.create = function create(primitiveTopology, shader, renderTarget, pipelineLayout, blendState, depthState, vertexBufferLayout, cullMode, stencilEnabled, stencilFront, stencilBack) {
			var wgpu = this.device.wgpu;
			var webgpuShader = shader.impl;
			var descr = {
				vertex: {
					module: webgpuShader.getVertexShaderModule(),
					entryPoint: webgpuShader.vertexEntryPoint,
					buffers: vertexBufferLayout
				},
				primitive: {
					topology: primitiveTopology,
					frontFace: 'ccw',
					cullMode: _cullModes[cullMode]
				},
				depthStencil: this.getDepthStencil(depthState, renderTarget, stencilEnabled, stencilFront, stencilBack),
				multisample: {
					count: renderTarget.samples
				},
				layout: pipelineLayout
			};
			var colorAttachments = renderTarget.impl.colorAttachments;
			if (colorAttachments.length > 0) {
				descr.fragment = {
					module: webgpuShader.getFragmentShaderModule(),
					entryPoint: webgpuShader.fragmentEntryPoint,
					targets: []
				};
				var writeMask = 0;
				if (blendState.redWrite) writeMask |= GPUColorWrite.RED;
				if (blendState.greenWrite) writeMask |= GPUColorWrite.GREEN;
				if (blendState.blueWrite) writeMask |= GPUColorWrite.BLUE;
				if (blendState.alphaWrite) writeMask |= GPUColorWrite.ALPHA;
				var blend = this.getBlend(blendState);
				colorAttachments.forEach(function (attachment) {
					descr.fragment.targets.push({
						format: attachment.format,
						writeMask: writeMask,
						blend: blend
					});
				});
			}
			var pipeline = wgpu.createRenderPipeline(descr);
			return pipeline;
		};
		return WebgpuRenderPipeline;
	}(WebgpuPipeline);

	var WebgpuComputePipeline = function (_WebgpuPipeline) {
		_inheritsLoose(WebgpuComputePipeline, _WebgpuPipeline);
		function WebgpuComputePipeline() {
			return _WebgpuPipeline.apply(this, arguments) || this;
		}
		var _proto = WebgpuComputePipeline.prototype;
		_proto.get = function get(shader, bindGroupFormat) {
			var pipelineLayout = this.getPipelineLayout([bindGroupFormat.impl]);
			var pipeline = this.create(shader, pipelineLayout);
			return pipeline;
		};
		_proto.create = function create(shader, pipelineLayout) {
			var wgpu = this.device.wgpu;
			var webgpuShader = shader.impl;
			var descr = {
				compute: {
					module: webgpuShader.getComputeShaderModule(),
					entryPoint: webgpuShader.computeEntryPoint
				},
				layout: pipelineLayout
			};
			var pipeline = wgpu.createComputePipeline(descr);
			return pipeline;
		};
		return WebgpuComputePipeline;
	}(WebgpuPipeline);

	var stringIds = new StringIds();
	var ColorAttachment = function () {
		function ColorAttachment() {
			this.format = void 0;
			this.multisampledBuffer = void 0;
		}
		var _proto = ColorAttachment.prototype;
		_proto.destroy = function destroy() {
			var _this$multisampledBuf;
			(_this$multisampledBuf = this.multisampledBuffer) == null || _this$multisampledBuf.destroy();
			this.multisampledBuffer = null;
		};
		return ColorAttachment;
	}();
	var WebgpuRenderTarget = function () {
		function WebgpuRenderTarget(renderTarget) {
			var _this = this;
			this.initialized = false;
			this.key = void 0;
			this.colorAttachments = [];
			this.depthFormat = void 0;
			this.hasStencil = void 0;
			this.depthTexture = null;
			this.depthTextureInternal = false;
			this.assignedColorTexture = null;
			this.renderPassDescriptor = {};
			this.renderTarget = renderTarget;
			if (renderTarget._colorBuffers) {
				renderTarget._colorBuffers.forEach(function (colorBuffer, index) {
					_this.setColorAttachment(index, undefined, colorBuffer.impl.format);
				});
			}
			this.updateKey();
		}
		var _proto2 = WebgpuRenderTarget.prototype;
		_proto2.destroy = function destroy(device) {
			this.initialized = false;
			if (this.depthTextureInternal) {
				var _this$depthTexture;
				(_this$depthTexture = this.depthTexture) == null || _this$depthTexture.destroy();
				this.depthTexture = null;
			}
			this.assignedColorTexture = null;
			this.colorAttachments.forEach(function (colorAttachment) {
				colorAttachment.destroy();
			});
			this.colorAttachments.length = 0;
		};
		_proto2.updateKey = function updateKey() {
			var rt = this.renderTarget;
			var key = rt.samples + ":" + (rt.depth ? this.depthFormat : 'nodepth');
			this.colorAttachments.forEach(function (colorAttachment) {
				key += ":" + colorAttachment.format;
			});
			this.key = stringIds.get(key);
		};
		_proto2.setDepthFormat = function setDepthFormat(depthFormat) {
			this.depthFormat = depthFormat;
			this.hasStencil = depthFormat === 'depth24plus-stencil8';
		};
		_proto2.assignColorTexture = function assignColorTexture(gpuTexture) {
			this.assignedColorTexture = gpuTexture;
			var view = gpuTexture.createView();
			var colorAttachment = this.renderPassDescriptor.colorAttachments[0];
			var samples = this.renderTarget.samples;
			if (samples > 1) {
				colorAttachment.resolveTarget = view;
			} else {
				colorAttachment.view = view;
			}
			this.setColorAttachment(0, undefined, gpuTexture.format);
			this.updateKey();
		};
		_proto2.setColorAttachment = function setColorAttachment(index, multisampledBuffer, format) {
			if (!this.colorAttachments[index]) {
				this.colorAttachments[index] = new ColorAttachment();
			}
			if (multisampledBuffer) {
				this.colorAttachments[index].multisampledBuffer = multisampledBuffer;
			}
			if (format) {
				this.colorAttachments[index].format = format;
			}
		};
		_proto2.init = function init(device, renderTarget) {
			var _renderTarget$_colorB, _renderTarget$_colorB2;
			var wgpu = device.wgpu;
			this.initDepthStencil(wgpu, renderTarget);
			this.renderPassDescriptor.colorAttachments = [];
			var count = (_renderTarget$_colorB = (_renderTarget$_colorB2 = renderTarget._colorBuffers) == null ? void 0 : _renderTarget$_colorB2.length) != null ? _renderTarget$_colorB : 1;
			for (var i = 0; i < count; ++i) {
				var _this$colorAttachment;
				var colorAttachment = this.initColor(wgpu, renderTarget, i);
				var isDefaultFramebuffer = i === 0 && ((_this$colorAttachment = this.colorAttachments[0]) == null ? void 0 : _this$colorAttachment.format);
				if (colorAttachment.view || isDefaultFramebuffer) {
					this.renderPassDescriptor.colorAttachments.push(colorAttachment);
				}
			}
			this.initialized = true;
		};
		_proto2.initDepthStencil = function initDepthStencil(wgpu, renderTarget) {
			var samples = renderTarget.samples,
				width = renderTarget.width,
				height = renderTarget.height,
				depth = renderTarget.depth,
				depthBuffer = renderTarget.depthBuffer;
			if (depth || depthBuffer) {
				if (!depthBuffer) {
					this.setDepthFormat('depth24plus-stencil8');
					var depthTextureDesc = {
						size: [width, height, 1],
						dimension: '2d',
						sampleCount: samples,
						format: this.depthFormat,
						usage: GPUTextureUsage.RENDER_ATTACHMENT
					};
					if (samples > 1) {
						depthTextureDesc.usage |= GPUTextureUsage.TEXTURE_BINDING;
					} else {
						depthTextureDesc.usage |= GPUTextureUsage.COPY_SRC;
					}
					this.depthTexture = wgpu.createTexture(depthTextureDesc);
					this.depthTextureInternal = true;
				} else {
					this.depthTexture = depthBuffer.impl.gpuTexture;
					this.setDepthFormat(depthBuffer.impl.format);
				}
				this.renderPassDescriptor.depthStencilAttachment = {
					view: this.depthTexture.createView()
				};
			}
		};
		_proto2.initColor = function initColor(wgpu, renderTarget, index) {
			var colorAttachment = {};
			var samples = renderTarget.samples,
				width = renderTarget.width,
				height = renderTarget.height;
			var colorBuffer = renderTarget.getColorBuffer(index);
			var colorView = null;
			if (colorBuffer) {
				var mipLevelCount = 1;
				if (colorBuffer.cubemap) {
					colorView = colorBuffer.impl.createView({
						dimension: '2d',
						baseArrayLayer: renderTarget.face,
						arrayLayerCount: 1,
						mipLevelCount: mipLevelCount
					});
				} else {
					colorView = colorBuffer.impl.createView({
						mipLevelCount: mipLevelCount
					});
				}
			}
			if (samples > 1) {
				var _this$colorAttachment2, _this$colorAttachment3;
				var multisampledTextureDesc = {
					size: [width, height, 1],
					dimension: '2d',
					sampleCount: samples,
					format: (_this$colorAttachment2 = (_this$colorAttachment3 = this.colorAttachments[index]) == null ? void 0 : _this$colorAttachment3.format) != null ? _this$colorAttachment2 : colorBuffer.impl.format,
					usage: GPUTextureUsage.RENDER_ATTACHMENT
				};
				var multisampledColorBuffer = wgpu.createTexture(multisampledTextureDesc);
				this.setColorAttachment(index, multisampledColorBuffer, multisampledTextureDesc.format);
				colorAttachment.view = multisampledColorBuffer.createView();
				colorAttachment.resolveTarget = colorView;
			} else {
				colorAttachment.view = colorView;
			}
			return colorAttachment;
		};
		_proto2.setupForRenderPass = function setupForRenderPass(renderPass) {
			var _this$renderPassDescr, _this$renderPassDescr2;
			var count = (_this$renderPassDescr = (_this$renderPassDescr2 = this.renderPassDescriptor.colorAttachments) == null ? void 0 : _this$renderPassDescr2.length) != null ? _this$renderPassDescr : 0;
			for (var i = 0; i < count; ++i) {
				var colorAttachment = this.renderPassDescriptor.colorAttachments[i];
				var colorOps = renderPass.colorArrayOps[i];
				colorAttachment.clearValue = colorOps.clearValue;
				colorAttachment.loadOp = colorOps.clear ? 'clear' : 'load';
				colorAttachment.storeOp = colorOps.store ? 'store' : 'discard';
			}
			var depthAttachment = this.renderPassDescriptor.depthStencilAttachment;
			if (depthAttachment) {
				depthAttachment.depthClearValue = renderPass.depthStencilOps.clearDepthValue;
				depthAttachment.depthLoadOp = renderPass.depthStencilOps.clearDepth ? 'clear' : 'load';
				depthAttachment.depthStoreOp = renderPass.depthStencilOps.storeDepth ? 'store' : 'discard';
				depthAttachment.depthReadOnly = false;
				if (this.hasStencil) {
					depthAttachment.stencilClearValue = renderPass.depthStencilOps.clearStencilValue;
					depthAttachment.stencilLoadOp = renderPass.depthStencilOps.clearStencil ? 'clear' : 'load';
					depthAttachment.stencilStoreOp = renderPass.depthStencilOps.storeStencil ? 'store' : 'discard';
					depthAttachment.stencilReadOnly = false;
				}
			}
		};
		_proto2.loseContext = function loseContext() {
			this.initialized = false;
		};
		_proto2.resolve = function resolve(device, target, color, depth) {};
		return WebgpuRenderTarget;
	}();

	var uniformTypeToNumElements = [];
	uniformTypeToNumElements[UNIFORMTYPE_FLOAT] = 1;
	uniformTypeToNumElements[UNIFORMTYPE_VEC2] = 2;
	uniformTypeToNumElements[UNIFORMTYPE_VEC3] = 3;
	uniformTypeToNumElements[UNIFORMTYPE_VEC4] = 4;
	uniformTypeToNumElements[UNIFORMTYPE_INT] = 1;
	uniformTypeToNumElements[UNIFORMTYPE_IVEC2] = 2;
	uniformTypeToNumElements[UNIFORMTYPE_IVEC3] = 3;
	uniformTypeToNumElements[UNIFORMTYPE_IVEC4] = 4;
	uniformTypeToNumElements[UNIFORMTYPE_BOOL] = 1;
	uniformTypeToNumElements[UNIFORMTYPE_BVEC2] = 2;
	uniformTypeToNumElements[UNIFORMTYPE_BVEC3] = 3;
	uniformTypeToNumElements[UNIFORMTYPE_BVEC4] = 4;
	uniformTypeToNumElements[UNIFORMTYPE_MAT2] = 8;
	uniformTypeToNumElements[UNIFORMTYPE_MAT3] = 12;
	uniformTypeToNumElements[UNIFORMTYPE_MAT4] = 16;
	var UniformFormat = function () {
		function UniformFormat(name, type, count) {
			if (count === void 0) {
				count = 0;
			}
			this.name = void 0;
			this.type = void 0;
			this.byteSize = void 0;
			this.offset = void 0;
			this.scopeId = void 0;
			this.count = void 0;
			this.shortName = name;
			this.name = count ? name + "[0]" : name;
			this.type = type;
			this.updateType = type;
			if (count) {
				switch (type) {
					case UNIFORMTYPE_FLOAT:
						this.updateType = UNIFORMTYPE_FLOATARRAY;
						break;
					case UNIFORMTYPE_VEC2:
						this.updateType = UNIFORMTYPE_VEC2ARRAY;
						break;
					case UNIFORMTYPE_VEC3:
						this.updateType = UNIFORMTYPE_VEC3ARRAY;
						break;
					case UNIFORMTYPE_VEC4:
						this.updateType = UNIFORMTYPE_VEC4ARRAY;
						break;
					case UNIFORMTYPE_MAT4:
						this.updateType = UNIFORMTYPE_MAT4ARRAY;
						break;
				}
			}
			this.count = count;
			var elementSize = uniformTypeToNumElements[type];
			if (count) elementSize = math.roundUp(elementSize, 4);
			this.byteSize = elementSize * 4;
			if (count) this.byteSize *= count;
		}
		var _proto = UniformFormat.prototype;
		_proto.calculateOffset = function calculateOffset(offset) {
			var alignment = this.byteSize <= 8 ? this.byteSize : 16;
			if (this.count) alignment = 16;
			offset = math.roundUp(offset, alignment);
			this.offset = offset / 4;
		};
		return UniformFormat;
	}();
	var UniformBufferFormat = function () {
		function UniformBufferFormat(graphicsDevice, uniforms) {
			this.byteSize = 0;
			this.map = new Map();
			this.scope = graphicsDevice.scope;
			this.uniforms = uniforms;
			var offset = 0;
			for (var i = 0; i < uniforms.length; i++) {
				var uniform = uniforms[i];
				uniform.calculateOffset(offset);
				offset = uniform.offset * 4 + uniform.byteSize;
				uniform.scopeId = this.scope.resolve(uniform.name);
				this.map.set(uniform.name, uniform);
			}
			this.byteSize = math.roundUp(offset, 16);
		}
		var _proto2 = UniformBufferFormat.prototype;
		_proto2.get = function get(name) {
			return this.map.get(name);
		};
		_proto2.getShaderDeclaration = function getShaderDeclaration(bindGroup, bindIndex) {
			var name = bindGroupNames[bindGroup];
			var code = "layout(set = " + bindGroup + ", binding = " + bindIndex + ", std140) uniform ub_" + name + " {\n";
			this.uniforms.forEach(function (uniform) {
				var typeString = uniformTypeToName[uniform.type];
				code += "    " + typeString + " " + uniform.shortName + (uniform.count ? "[" + uniform.count + "]" : '') + ";\n";
			});
			return code + '};\n';
		};
		return UniformBufferFormat;
	}();

	var _textureDimensionInfo;
	var id$8 = 0;
	var textureDimensionInfo = (_textureDimensionInfo = {}, _textureDimensionInfo[TEXTUREDIMENSION_2D] = 'texture2D', _textureDimensionInfo[TEXTUREDIMENSION_CUBE] = 'textureCube', _textureDimensionInfo[TEXTUREDIMENSION_3D] = 'texture3D', _textureDimensionInfo);
	var BindBufferFormat = function BindBufferFormat(name, visibility) {
		this.name = name;
		this.visibility = visibility;
	};
	var BindTextureFormat = function BindTextureFormat(name, visibility, textureDimension, sampleType) {
		if (textureDimension === void 0) {
			textureDimension = TEXTUREDIMENSION_2D;
		}
		if (sampleType === void 0) {
			sampleType = SAMPLETYPE_FLOAT;
		}
		this.scopeId = void 0;
		this.name = name;
		this.visibility = visibility;
		this.textureDimension = textureDimension;
		this.sampleType = sampleType;
	};
	var BindStorageTextureFormat = function BindStorageTextureFormat(name, format, textureDimension) {
		if (format === void 0) {
			format = PIXELFORMAT_RGBA8;
		}
		if (textureDimension === void 0) {
			textureDimension = TEXTUREDIMENSION_2D;
		}
		this.scopeId = void 0;
		this.name = name;
		this.format = format;
		this.textureDimension = textureDimension;
	};
	var BindGroupFormat = function () {
		function BindGroupFormat(graphicsDevice, bufferFormats, textureFormats, storageTextureFormats, options) {
			var _options$compute,
				_this = this;
			if (bufferFormats === void 0) {
				bufferFormats = [];
			}
			if (textureFormats === void 0) {
				textureFormats = [];
			}
			if (storageTextureFormats === void 0) {
				storageTextureFormats = [];
			}
			if (options === void 0) {
				options = {};
			}
			this.compute = false;
			this.id = id$8++;
			this.compute = (_options$compute = options.compute) != null ? _options$compute : false;
			this.device = graphicsDevice;
			var scope = graphicsDevice.scope;
			this.bufferFormats = bufferFormats;
			this.bufferFormatsMap = new Map();
			bufferFormats.forEach(function (bf, i) {
				return _this.bufferFormatsMap.set(bf.name, i);
			});
			this.textureFormats = textureFormats;
			this.textureFormatsMap = new Map();
			textureFormats.forEach(function (tf, i) {
				_this.textureFormatsMap.set(tf.name, i);
				tf.scopeId = scope.resolve(tf.name);
			});
			this.storageTextureFormats = storageTextureFormats;
			this.storageTextureFormatsMap = new Map();
			storageTextureFormats.forEach(function (tf, i) {
				_this.storageTextureFormatsMap.set(tf.name, i);
				tf.scopeId = scope.resolve(tf.name);
			});
			this.impl = graphicsDevice.createBindGroupFormatImpl(this);
		}
		var _proto = BindGroupFormat.prototype;
		_proto.destroy = function destroy() {
			this.impl.destroy();
		};
		_proto.getTexture = function getTexture(name) {
			var index = this.textureFormatsMap.get(name);
			if (index !== undefined) {
				return this.textureFormats[index];
			}
			return null;
		};
		_proto.getStorageTexture = function getStorageTexture(name) {
			var index = this.storageTextureFormatsMap.get(name);
			if (index !== undefined) {
				return this.storageTextureFormats[index];
			}
			return null;
		};
		_proto.getShaderDeclarationTextures = function getShaderDeclarationTextures(bindGroup) {
			var code = '';
			var bindIndex = this.bufferFormats.length;
			this.textureFormats.forEach(function (format) {
				var textureType = textureDimensionInfo[format.textureDimension];
				code += "layout(set = " + bindGroup + ", binding = " + bindIndex++ + ") uniform " + textureType + " " + format.name + ";\n" + ("layout(set = " + bindGroup + ", binding = " + bindIndex++ + ") uniform sampler " + format.name + "_sampler;\n");
			});
			return code;
		};
		_proto.loseContext = function loseContext() {};
		return BindGroupFormat;
	}();

	var KEYWORD$1 = /[ \t]*(\battribute\b|\bvarying\b|\buniform\b)/g;
	var KEYWORD_LINE = /(\battribute\b|\bvarying\b|\bout\b|\buniform\b)[ \t]*([^;]+)([;]+)/g;
	var MARKER = '@@@';
	var ARRAY_IDENTIFIER = /([\w-]+)\[(.*?)\]/;
	var precisionQualifiers = new Set(['highp', 'mediump', 'lowp']);
	var shadowSamplers = new Set(['sampler2DShadow', 'samplerCubeShadow']);
	var textureDimensions = {
		sampler2D: TEXTUREDIMENSION_2D,
		sampler3D: TEXTUREDIMENSION_3D,
		samplerCube: TEXTUREDIMENSION_CUBE,
		samplerCubeShadow: TEXTUREDIMENSION_CUBE,
		sampler2DShadow: TEXTUREDIMENSION_2D,
		sampler2DArray: TEXTUREDIMENSION_2D_ARRAY,
		sampler2DArrayShadow: TEXTUREDIMENSION_2D_ARRAY
	};
	var UniformLine = function UniformLine(line, shader) {
		this.line = line;
		var words = line.trim().split(/\s+/);
		if (precisionQualifiers.has(words[0])) {
			this.precision = words.shift();
		}
		this.type = words.shift();
		if (line.includes(',')) ;
		if (line.includes('[')) {
			var rest = words.join(' ');
			var match = ARRAY_IDENTIFIER.exec(rest);
			this.name = match[1];
			this.arraySize = Number(match[2]);
			if (isNaN(this.arraySize)) {
				shader.failed = true;
			}
		} else {
			this.name = words.shift();
			this.arraySize = 0;
		}
		this.isSampler = this.type.indexOf('sampler') !== -1;
	};
	var ShaderProcessor = function () {
		function ShaderProcessor() {}
		ShaderProcessor.run = function run(device, shaderDefinition, shader) {
			var varyingMap = new Map();
			var vertexExtracted = ShaderProcessor.extract(shaderDefinition.vshader);
			var fragmentExtracted = ShaderProcessor.extract(shaderDefinition.fshader);
			var attributesBlock = ShaderProcessor.processAttributes(vertexExtracted.attributes, shaderDefinition.attributes, shaderDefinition.processingOptions);
			var vertexVaryingsBlock = ShaderProcessor.processVaryings(vertexExtracted.varyings, varyingMap, true);
			var fragmentVaryingsBlock = ShaderProcessor.processVaryings(fragmentExtracted.varyings, varyingMap, false);
			var outBlock = ShaderProcessor.processOuts(fragmentExtracted.outs);
			var concatUniforms = vertexExtracted.uniforms.concat(fragmentExtracted.uniforms);
			var uniforms = Array.from(new Set(concatUniforms));
			var parsedUniforms = uniforms.map(function (line) {
				return new UniformLine(line, shader);
			});
			var uniformsData = ShaderProcessor.processUniforms(device, parsedUniforms, shaderDefinition.processingOptions, shader);
			var vBlock = attributesBlock + '\n' + vertexVaryingsBlock + '\n' + uniformsData.code;
			var vshader = vertexExtracted.src.replace(MARKER, vBlock);
			var fBlock = fragmentVaryingsBlock + '\n' + outBlock + '\n' + uniformsData.code;
			var fshader = fragmentExtracted.src.replace(MARKER, fBlock);
			return {
				vshader: vshader,
				fshader: fshader,
				meshUniformBufferFormat: uniformsData.meshUniformBufferFormat,
				meshBindGroupFormat: uniformsData.meshBindGroupFormat
			};
		};
		ShaderProcessor.extract = function extract(src) {
			var attributes = [];
			var varyings = [];
			var outs = [];
			var uniforms = [];
			var replacement = MARKER + "\n";
			var match;
			while ((match = KEYWORD$1.exec(src)) !== null) {
				var keyword = match[1];
				switch (keyword) {
					case 'attribute':
					case 'varying':
					case 'uniform':
					case 'out':
						{
							KEYWORD_LINE.lastIndex = match.index;
							var lineMatch = KEYWORD_LINE.exec(src);
							if (keyword === 'attribute') {
								attributes.push(lineMatch[2]);
							} else if (keyword === 'varying') {
								varyings.push(lineMatch[2]);
							} else if (keyword === 'out') {
								outs.push(lineMatch[2]);
							} else if (keyword === 'uniform') {
								uniforms.push(lineMatch[2]);
							}
							src = ShaderProcessor.cutOut(src, match.index, KEYWORD_LINE.lastIndex, replacement);
							KEYWORD$1.lastIndex = match.index + replacement.length;
							replacement = '';
							break;
						}
				}
			}
			return {
				src: src,
				attributes: attributes,
				varyings: varyings,
				outs: outs,
				uniforms: uniforms
			};
		};
		ShaderProcessor.processUniforms = function processUniforms(device, uniforms, processingOptions, shader) {
			var uniformLinesSamplers = [];
			var uniformLinesNonSamplers = [];
			uniforms.forEach(function (uniform) {
				if (uniform.isSampler) {
					uniformLinesSamplers.push(uniform);
				} else {
					uniformLinesNonSamplers.push(uniform);
				}
			});
			var meshUniforms = [];
			uniformLinesNonSamplers.forEach(function (uniform) {
				if (!processingOptions.hasUniform(uniform.name)) {
					var uniformType = uniformTypeToName.indexOf(uniform.type);
					var uniformFormat = new UniformFormat(uniform.name, uniformType, uniform.arraySize);
					meshUniforms.push(uniformFormat);
				}
			});
			var meshUniformBufferFormat = meshUniforms.length ? new UniformBufferFormat(device, meshUniforms) : null;
			var bufferFormats = [];
			if (meshUniformBufferFormat) {
				bufferFormats.push(new BindBufferFormat(UNIFORM_BUFFER_DEFAULT_SLOT_NAME, SHADERSTAGE_VERTEX | SHADERSTAGE_FRAGMENT));
			}
			var textureFormats = [];
			uniformLinesSamplers.forEach(function (uniform) {
				if (!processingOptions.hasTexture(uniform.name)) {
					var sampleType = SAMPLETYPE_FLOAT;
					if (uniform.precision === 'highp') sampleType = SAMPLETYPE_UNFILTERABLE_FLOAT;
					if (shadowSamplers.has(uniform.type)) sampleType = SAMPLETYPE_DEPTH;
					var dimension = textureDimensions[uniform.type];
					textureFormats.push(new BindTextureFormat(uniform.name, SHADERSTAGE_VERTEX | SHADERSTAGE_FRAGMENT, dimension, sampleType));
				}
			});
			var meshBindGroupFormat = new BindGroupFormat(device, bufferFormats, textureFormats);
			var code = '';
			processingOptions.uniformFormats.forEach(function (format, bindGroupIndex) {
				if (format) {
					code += format.getShaderDeclaration(bindGroupIndex, 0);
				}
			});
			if (meshUniformBufferFormat) {
				code += meshUniformBufferFormat.getShaderDeclaration(BINDGROUP_MESH, 0);
			}
			processingOptions.bindGroupFormats.forEach(function (format, bindGroupIndex) {
				if (format) {
					code += format.getShaderDeclarationTextures(bindGroupIndex);
				}
			});
			code += meshBindGroupFormat.getShaderDeclarationTextures(BINDGROUP_MESH);
			return {
				code: code,
				meshUniformBufferFormat: meshUniformBufferFormat,
				meshBindGroupFormat: meshBindGroupFormat
			};
		};
		ShaderProcessor.processVaryings = function processVaryings(varyingLines, varyingMap, isVertex) {
			var block = '';
			var op = isVertex ? 'out' : 'in';
			varyingLines.forEach(function (line, index) {
				var words = ShaderProcessor.splitToWords(line);
				var type = words[0];
				var name = words[1];
				if (isVertex) {
					varyingMap.set(name, index);
				} else {
					index = varyingMap.get(name);
				}
				block += "layout(location = " + index + ") " + op + " " + type + " " + name + ";\n";
			});
			return block;
		};
		ShaderProcessor.processOuts = function processOuts(outsLines) {
			var block = '';
			outsLines.forEach(function (line, index) {
				block += "layout(location = " + index + ") out " + line + ";\n";
			});
			return block;
		};
		ShaderProcessor.getTypeCount = function getTypeCount(type) {
			var lastChar = type.substring(type.length - 1);
			var num = parseInt(lastChar, 10);
			return isNaN(num) ? 1 : num;
		};
		ShaderProcessor.processAttributes = function processAttributes(attributeLines, shaderDefinitionAttributes, processingOptions) {
			var block = '';
			attributeLines.forEach(function (line) {
				var words = ShaderProcessor.splitToWords(line);
				var type = words[0];
				var name = words[1];
				if (shaderDefinitionAttributes.hasOwnProperty(name)) {
					var semantic = shaderDefinitionAttributes[name];
					var location = semanticToLocation[semantic];
					var copyCode;
					var element = processingOptions.getVertexElement(semantic);
					if (element) {
						var dataType = element.dataType;
						if (dataType !== TYPE_FLOAT32 && dataType !== TYPE_FLOAT16 && !element.normalize && !element.asInt) {
							var attribNumElements = ShaderProcessor.getTypeCount(type);
							var newName = "_private_" + name;
							copyCode = "vec" + attribNumElements + " " + name + " = vec" + attribNumElements + "(" + newName + ");\n";
							name = newName;
							var isSignedType = dataType === TYPE_INT8 || dataType === TYPE_INT16 || dataType === TYPE_INT32;
							if (attribNumElements === 1) {
								type = isSignedType ? 'int' : 'uint';
							} else {
								type = isSignedType ? "ivec" + attribNumElements : "uvec" + attribNumElements;
							}
						}
					}
					block += "layout(location = " + location + ") in " + type + " " + name + ";\n";
					if (copyCode) {
						block += copyCode;
					}
				}
			});
			return block;
		};
		ShaderProcessor.splitToWords = function splitToWords(line) {
			line = line.replace(/\s+/g, ' ').trim();
			return line.split(' ');
		};
		ShaderProcessor.cutOut = function cutOut(src, start, end, replacement) {
			return src.substring(0, start) + replacement + src.substring(end);
		};
		return ShaderProcessor;
	}();

	var WebgpuShader = function () {
		function WebgpuShader(shader) {
			this._vertexCode = null;
			this._fragmentCode = null;
			this._computeCode = null;
			this.vertexEntryPoint = 'main';
			this.fragmentEntryPoint = 'main';
			this.computeEntryPoint = 'main';
			this.shader = shader;
			var definition = shader.definition;
			if (definition.shaderLanguage === SHADERLANGUAGE_WGSL) {
				var _definition$vshader, _definition$fshader, _definition$cshader;
				this._vertexCode = (_definition$vshader = definition.vshader) != null ? _definition$vshader : null;
				this._fragmentCode = (_definition$fshader = definition.fshader) != null ? _definition$fshader : null;
				this._computeCode = (_definition$cshader = definition.cshader) != null ? _definition$cshader : null;
				this.vertexEntryPoint = 'vertexMain';
				this.fragmentEntryPoint = 'fragmentMain';
				shader.ready = true;
			} else {
				if (definition.processingOptions) {
					this.process();
				}
			}
		}
		var _proto = WebgpuShader.prototype;
		_proto.destroy = function destroy(shader) {
			this._vertexCode = null;
			this._fragmentCode = null;
		};
		_proto.createShaderModule = function createShaderModule(code, shaderType) {
			var device = this.shader.device;
			var wgpu = device.wgpu;
			var shaderModule = wgpu.createShaderModule({
				code: code
			});
			return shaderModule;
		};
		_proto.getVertexShaderModule = function getVertexShaderModule() {
			return this.createShaderModule(this._vertexCode, 'Vertex');
		};
		_proto.getFragmentShaderModule = function getFragmentShaderModule() {
			return this.createShaderModule(this._fragmentCode, 'Fragment');
		};
		_proto.getComputeShaderModule = function getComputeShaderModule() {
			return this.createShaderModule(this._computeCode, 'Compute');
		};
		_proto.process = function process() {
			var shader = this.shader;
			var processed = ShaderProcessor.run(shader.device, shader.definition, shader);
			this._vertexCode = this.transpile(processed.vshader, 'vertex', shader.definition.vshader);
			this._fragmentCode = this.transpile(processed.fshader, 'fragment', shader.definition.fshader);
			if (!(this._vertexCode && this._fragmentCode)) {
				shader.failed = true;
			} else {
				shader.ready = true;
			}
			shader.meshUniformBufferFormat = processed.meshUniformBufferFormat;
			shader.meshBindGroupFormat = processed.meshBindGroupFormat;
		};
		_proto.transpile = function transpile(src, shaderType, originalSrc) {
			try {
				var spirv = this.shader.device.glslang.compileGLSL(src, shaderType);
				return this.shader.device.twgsl.convertSpirV2WGSL(spirv);
			} catch (err) {
				console.error("Failed to transpile webgl " + shaderType + " shader [" + this.shader.label + "] to WebGPU: [" + err.message + "]", {
					processed: src,
					original: originalSrc,
					shader: this.shader
				});
			}
		};
		_proto.loseContext = function loseContext() {};
		_proto.restoreContext = function restoreContext(device, shader) {};
		_createClass(WebgpuShader, [{
			key: "vertexCode",
			get: function get() {
				return this._vertexCode;
			}
		}, {
			key: "fragmentCode",
			get: function get() {
				return this._fragmentCode;
			}
		}]);
		return WebgpuShader;
	}();

	var TextureUtils = function () {
		function TextureUtils() {}
		TextureUtils.calcLevelDimension = function calcLevelDimension(dimension, mipLevel) {
			return Math.max(dimension >> mipLevel, 1);
		};
		TextureUtils.calcMipLevelsCount = function calcMipLevelsCount(width, height, depth) {
			if (depth === void 0) {
				depth = 1;
			}
			return 1 + Math.floor(Math.log2(Math.max(width, height, depth)));
		};
		TextureUtils.calcLevelGpuSize = function calcLevelGpuSize(width, height, depth, format) {
			var _pixelFormatInfo$get$, _pixelFormatInfo$get, _formatInfo$blockSize;
			var formatInfo = pixelFormatInfo.get(format);
			var pixelSize = (_pixelFormatInfo$get$ = (_pixelFormatInfo$get = pixelFormatInfo.get(format)) == null ? void 0 : _pixelFormatInfo$get.size) != null ? _pixelFormatInfo$get$ : 0;
			if (pixelSize > 0) {
				return width * height * depth * pixelSize;
			}
			var blockSize = (_formatInfo$blockSize = formatInfo.blockSize) != null ? _formatInfo$blockSize : 0;
			var blockWidth = Math.floor((width + 3) / 4);
			var blockHeight = Math.floor((height + 3) / 4);
			var blockDepth = Math.floor((depth + 3) / 4);
			if (format === PIXELFORMAT_PVRTC_2BPP_RGB_1 || format === PIXELFORMAT_PVRTC_2BPP_RGBA_1) {
				blockWidth = Math.max(Math.floor(blockWidth / 2), 1);
			}
			return blockWidth * blockHeight * blockDepth * blockSize;
		};
		TextureUtils.calcGpuSize = function calcGpuSize(width, height, depth, format, mipmaps, cubemap) {
			var result = 0;
			while (1) {
				result += TextureUtils.calcLevelGpuSize(width, height, depth, format);
				if (!mipmaps || width === 1 && height === 1 && depth === 1) {
					break;
				}
				width = Math.max(width >> 1, 1);
				height = Math.max(height >> 1, 1);
				depth = Math.max(depth >> 1, 1);
			}
			return result * (cubemap ? 6 : 1);
		};
		return TextureUtils;
	}();

	var gpuAddressModes = [];
	gpuAddressModes[ADDRESS_REPEAT] = 'repeat';
	gpuAddressModes[ADDRESS_CLAMP_TO_EDGE] = 'clamp-to-edge';
	gpuAddressModes[ADDRESS_MIRRORED_REPEAT] = 'mirror-repeat';
	var gpuFilterModes = [];
	gpuFilterModes[FILTER_NEAREST] = {
		level: 'nearest',
		mip: 'nearest'
	};
	gpuFilterModes[FILTER_LINEAR] = {
		level: 'linear',
		mip: 'nearest'
	};
	gpuFilterModes[FILTER_NEAREST_MIPMAP_NEAREST] = {
		level: 'nearest',
		mip: 'nearest'
	};
	gpuFilterModes[FILTER_NEAREST_MIPMAP_LINEAR] = {
		level: 'nearest',
		mip: 'linear'
	};
	gpuFilterModes[FILTER_LINEAR_MIPMAP_NEAREST] = {
		level: 'linear',
		mip: 'nearest'
	};
	gpuFilterModes[FILTER_LINEAR_MIPMAP_LINEAR] = {
		level: 'linear',
		mip: 'linear'
	};
	var dummyUse = function dummyUse(thingOne) {};
	var WebgpuTexture = function () {
		function WebgpuTexture(texture) {
			this.gpuTexture = void 0;
			this.view = void 0;
			this.samplers = [];
			this.descr = void 0;
			this.format = void 0;
			this.texture = texture;
			this.format = gpuTextureFormats[texture.format];
			this.create(texture.device);
		}
		var _proto = WebgpuTexture.prototype;
		_proto.create = function create(device) {
			var texture = this.texture;
			var wgpu = device.wgpu;
			var mipLevelCount = texture.requiredMipLevels;
			this.descr = {
				size: {
					width: texture.width,
					height: texture.height,
					depthOrArrayLayers: texture.cubemap ? 6 : 1
				},
				format: this.format,
				mipLevelCount: mipLevelCount,
				sampleCount: 1,
				dimension: texture.volume ? '3d' : '2d',
				usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | (isCompressedPixelFormat(texture.format) ? 0 : GPUTextureUsage.RENDER_ATTACHMENT) | (texture.storage ? GPUTextureUsage.STORAGE_BINDING : 0)
			};
			this.gpuTexture = wgpu.createTexture(this.descr);
			var viewDescr;
			if (this.texture.format === PIXELFORMAT_DEPTHSTENCIL) {
				viewDescr = {
					format: 'depth24plus',
					aspect: 'depth-only'
				};
			}
			this.view = this.createView(viewDescr);
		};
		_proto.destroy = function destroy(device) {};
		_proto.propertyChanged = function propertyChanged(flag) {
			this.samplers.length = 0;
		};
		_proto.getView = function getView(device) {
			this.uploadImmediate(device, this.texture);
			return this.view;
		};
		_proto.createView = function createView(viewDescr) {
			var _options$format, _options$dimension, _options$aspect, _options$baseMipLevel, _options$mipLevelCoun, _options$baseArrayLay, _options$arrayLayerCo;
			var options = viewDescr != null ? viewDescr : {};
			var textureDescr = this.descr;
			var texture = this.texture;
			var defaultViewDimension = function defaultViewDimension() {
				if (texture.cubemap) return 'cube';
				if (texture.volume) return '3d';
				return '2d';
			};
			var descr = {
				format: (_options$format = options.format) != null ? _options$format : textureDescr.format,
				dimension: (_options$dimension = options.dimension) != null ? _options$dimension : defaultViewDimension(),
				aspect: (_options$aspect = options.aspect) != null ? _options$aspect : 'all',
				baseMipLevel: (_options$baseMipLevel = options.baseMipLevel) != null ? _options$baseMipLevel : 0,
				mipLevelCount: (_options$mipLevelCoun = options.mipLevelCount) != null ? _options$mipLevelCoun : textureDescr.mipLevelCount,
				baseArrayLayer: (_options$baseArrayLay = options.baseArrayLayer) != null ? _options$baseArrayLay : 0,
				arrayLayerCount: (_options$arrayLayerCo = options.arrayLayerCount) != null ? _options$arrayLayerCo : textureDescr.depthOrArrayLayers
			};
			var view = this.gpuTexture.createView(descr);
			return view;
		};
		_proto.getSampler = function getSampler(device, sampleType) {
			var sampler = this.samplers[sampleType];
			if (!sampler) {
				var texture = this.texture;
				var descr = {
					addressModeU: gpuAddressModes[texture.addressU],
					addressModeV: gpuAddressModes[texture.addressV],
					addressModeW: gpuAddressModes[texture.addressW]
				};
				if (!sampleType && texture.compareOnRead) {
					sampleType = SAMPLETYPE_DEPTH;
				}
				if (sampleType === SAMPLETYPE_DEPTH) {
					descr.compare = 'less';
					descr.magFilter = 'linear';
					descr.minFilter = 'linear';
				} else if (sampleType === SAMPLETYPE_UNFILTERABLE_FLOAT) {
					descr.magFilter = 'nearest';
					descr.minFilter = 'nearest';
					descr.mipmapFilter = 'nearest';
				} else {
					if (this.texture.format === PIXELFORMAT_RGBA32F || this.texture.format === PIXELFORMAT_DEPTHSTENCIL || this.texture.format === PIXELFORMAT_RGBA16F) {
						descr.magFilter = 'nearest';
						descr.minFilter = 'nearest';
						descr.mipmapFilter = 'nearest';
					} else {
						descr.magFilter = gpuFilterModes[texture.magFilter].level;
						descr.minFilter = gpuFilterModes[texture.minFilter].level;
						descr.mipmapFilter = gpuFilterModes[texture.minFilter].mip;
					}
				}
				var allLinear = descr.minFilter === 'linear' && descr.magFilter === 'linear' && descr.mipmapFilter === 'linear';
				descr.maxAnisotropy = allLinear ? math.clamp(Math.round(texture._anisotropy), 1, device.maxTextureAnisotropy) : 1;
				sampler = device.wgpu.createSampler(descr);
				this.samplers[sampleType] = sampler;
			}
			return sampler;
		};
		_proto.loseContext = function loseContext() {};
		_proto.uploadImmediate = function uploadImmediate(device, texture) {
			if (texture._needsUpload || texture._needsMipmapsUpload) {
				this.uploadData(device);
				texture._needsUpload = false;
				texture._needsMipmapsUpload = false;
			}
		};
		_proto.uploadData = function uploadData(device) {
			var texture = this.texture;
			if (texture._levels) {
				var anyUploads = false;
				var requiredMipLevels = texture.requiredMipLevels;
				for (var mipLevel = 0; mipLevel < requiredMipLevels; mipLevel++) {
					var mipObject = texture._levels[mipLevel];
					if (mipObject) {
						if (texture.cubemap) {
							for (var face = 0; face < 6; face++) {
								var faceSource = mipObject[face];
								if (faceSource) {
									if (this.isExternalImage(faceSource)) {
										this.uploadExternalImage(device, faceSource, mipLevel, face);
										anyUploads = true;
									} else if (ArrayBuffer.isView(faceSource)) {
										this.uploadTypedArrayData(device, faceSource, mipLevel, face);
										anyUploads = true;
									} else ;
								}
							}
						} else if (texture._volume) ; else {
							if (this.isExternalImage(mipObject)) {
								this.uploadExternalImage(device, mipObject, mipLevel, 0);
								anyUploads = true;
							} else if (ArrayBuffer.isView(mipObject)) {
								this.uploadTypedArrayData(device, mipObject, mipLevel, 0);
								anyUploads = true;
							} else ;
						}
					}
				}
				if (anyUploads && texture.mipmaps && !isCompressedPixelFormat(texture.format)) {
					device.mipmapRenderer.generate(this);
				}
			}
		};
		_proto.isExternalImage = function isExternalImage(image) {
			return image instanceof ImageBitmap || image instanceof HTMLVideoElement || image instanceof HTMLCanvasElement || image instanceof OffscreenCanvas;
		};
		_proto.uploadExternalImage = function uploadExternalImage(device, image, mipLevel, face) {
			var src = {
				source: image,
				origin: [0, 0],
				flipY: false
			};
			var dst = {
				texture: this.gpuTexture,
				mipLevel: mipLevel,
				origin: [0, 0, face],
				aspect: 'all'
			};
			var copySize = {
				width: this.descr.size.width,
				height: this.descr.size.height,
				depthOrArrayLayers: 1
			};
			device.submit();
			dummyUse(image instanceof HTMLCanvasElement && image.getContext('2d'));
			device.wgpu.queue.copyExternalImageToTexture(src, dst, copySize);
		};
		_proto.uploadTypedArrayData = function uploadTypedArrayData(device, data, mipLevel, face) {
			var texture = this.texture;
			var wgpu = device.wgpu;
			var dest = {
				texture: this.gpuTexture,
				origin: [0, 0, face],
				mipLevel: mipLevel
			};
			var width = TextureUtils.calcLevelDimension(texture.width, mipLevel);
			var height = TextureUtils.calcLevelDimension(texture.height, mipLevel);
			TextureUtils.calcLevelGpuSize(width, height, 1, texture.format);
			var formatInfo = pixelFormatInfo.get(texture.format);
			var dataLayout;
			var size;
			if (formatInfo.size) {
				dataLayout = {
					offset: 0,
					bytesPerRow: formatInfo.size * width,
					rowsPerImage: height
				};
				size = {
					width: width,
					height: height
				};
			} else if (formatInfo.blockSize) {
				var blockDim = function blockDim(size) {
					return Math.floor((size + 3) / 4);
				};
				dataLayout = {
					offset: 0,
					bytesPerRow: formatInfo.blockSize * blockDim(width),
					rowsPerImage: blockDim(height)
				};
				size = {
					width: Math.max(4, width),
					height: Math.max(4, height)
				};
			} else ;
			device.submit();
			wgpu.queue.writeTexture(dest, data, dataLayout, size);
		};
		return WebgpuTexture;
	}();

	var WebgpuUniformBuffer = function (_WebgpuBuffer) {
		_inheritsLoose(WebgpuUniformBuffer, _WebgpuBuffer);
		function WebgpuUniformBuffer(uniformBuffer) {
			return _WebgpuBuffer.call(this) || this;
		}
		var _proto = WebgpuUniformBuffer.prototype;
		_proto.destroy = function destroy(device) {
			_WebgpuBuffer.prototype.destroy.call(this, device);
		};
		_proto.unlock = function unlock(uniformBuffer) {
			var device = uniformBuffer.device;
			_WebgpuBuffer.prototype.unlock.call(this, device, undefined, GPUBufferUsage.UNIFORM, uniformBuffer.storage);
		};
		return WebgpuUniformBuffer;
	}(WebgpuBuffer);

	var WebgpuVertexBuffer = function (_WebgpuBuffer) {
		_inheritsLoose(WebgpuVertexBuffer, _WebgpuBuffer);
		function WebgpuVertexBuffer(vertexBuffer, format) {
			return _WebgpuBuffer.call(this) || this;
		}
		var _proto = WebgpuVertexBuffer.prototype;
		_proto.destroy = function destroy(device) {
			_WebgpuBuffer.prototype.destroy.call(this, device);
		};
		_proto.unlock = function unlock(vertexBuffer) {
			var device = vertexBuffer.device;
			_WebgpuBuffer.prototype.unlock.call(this, device, vertexBuffer.usage, GPUBufferUsage.VERTEX, vertexBuffer.storage);
		};
		return WebgpuVertexBuffer;
	}(WebgpuBuffer);

	var KEYWORD = /[ \t]*#(ifn?def|if|endif|else|elif|define|undef|extension)/g;
	var DEFINE = /define[ \t]+([^\n]+)\r?(?:\n|$)/g;
	var EXTENSION = /extension[ \t]+([\w-]+)[ \t]*:[ \t]*(enable|require)/g;
	var UNDEF = /undef[ \t]+([^\n]+)\r?(?:\n|$)/g;
	var IF = /(ifdef|ifndef|if)[ \t]*([^\r\n]+)\r?\n/g;
	var ENDIF = /(endif|else|elif)([ \t]+[^\r\n]+)?\r?(?:\n|$)/g;
	var IDENTIFIER$1 = /([\w-]+)/;
	var DEFINED = /(!|\s)?defined\(([\w-]+)\)/;
	var INVALID = /[><=|&+-]/g;
	var Preprocessor = function () {
		function Preprocessor() {}
		Preprocessor.run = function run(source, stripUnusedColorAttachments) {
			if (stripUnusedColorAttachments === void 0) {
				stripUnusedColorAttachments = false;
			}
			source = source.replace(/\/\*[\s\S]*?\*\/|([^\\:]|^)\/\/.*$/gm, '$1');
			source = source.split(/\r?\n/).map(function (line) {
				return line.trimEnd();
			}).join('\n');
			var defines = new Map();
			if (stripUnusedColorAttachments) {
				var counts = new Map();
				var regex = /(pcFragColor[1-8])\b/g;
				var matches = source.match(regex);
				matches == null || matches.forEach(function (match) {
					var _counts$get;
					var index = parseInt(match.charAt(match.length - 1), 10);
					counts.set(index, ((_counts$get = counts.get(index)) != null ? _counts$get : 0) + 1);
				});
				counts.forEach(function (count, index) {
					if (count === 1) {
						defines.set("REMOVE_COLOR_ATTACHMENT_" + index, '');
					}
				});
			}
			source = this._preprocess(source, defines);
			var intDefines = new Map();
			defines.forEach(function (value, key) {
				if (Number.isInteger(parseFloat(value)) && !value.includes('.')) {
					intDefines.set(key, value);
				}
			});
			if (source !== null) {
				source = source.split(/\r?\n/).map(function (line) {
					return line.trim() === '' ? '' : line;
				}).map(function (line) {
					intDefines.forEach(function (value, key) {
						line = line.replace(new RegExp("\\[" + key + "\\]", 'g'), "[" + value + "]");
					});
					return line;
				}).join('\n');
				source = source.replace(/(\n\n){3,}/gm, '\n\n');
			}
			return source;
		};
		Preprocessor._preprocess = function _preprocess(source, defines) {
			if (defines === void 0) {
				defines = new Map();
			}
			var originalSource = source;
			var stack = [];
			var error = false;
			var match;
			while ((match = KEYWORD.exec(source)) !== null) {
				var keyword = match[1];
				switch (keyword) {
					case 'define':
						{
							DEFINE.lastIndex = match.index;
							var define = DEFINE.exec(source);
							error || (error = define === null);
							var expression = define[1];
							IDENTIFIER$1.lastIndex = define.index;
							var identifierValue = IDENTIFIER$1.exec(expression);
							var identifier = identifierValue[1];
							var value = expression.substring(identifier.length).trim();
							if (value === "") value = "true";
							var keep = Preprocessor._keep(stack);
							if (keep) {
								defines.set(identifier, value);
							}
							KEYWORD.lastIndex = define.index + define[0].length;
							break;
						}
					case 'undef':
						{
							UNDEF.lastIndex = match.index;
							var undef = UNDEF.exec(source);
							var _identifier = undef[1].trim();
							var _keep2 = Preprocessor._keep(stack);
							if (_keep2) {
								defines.delete(_identifier);
							}
							KEYWORD.lastIndex = undef.index + undef[0].length;
							break;
						}
					case 'extension':
						{
							EXTENSION.lastIndex = match.index;
							var extension = EXTENSION.exec(source);
							error || (error = extension === null);
							if (extension) {
								var _identifier2 = extension[1];
								var _keep3 = Preprocessor._keep(stack);
								if (_keep3) {
									defines.set(_identifier2, "true");
								}
							}
							KEYWORD.lastIndex = extension.index + extension[0].length;
							break;
						}
					case 'ifdef':
					case 'ifndef':
					case 'if':
						{
							IF.lastIndex = match.index;
							var iff = IF.exec(source);
							var _expression = iff[2];
							var evaluated = Preprocessor.evaluate(_expression, defines);
							error || (error = evaluated.error);
							var result = evaluated.result;
							if (keyword === 'ifndef') {
								result = !result;
							}
							stack.push({
								anyKeep: result,
								keep: result,
								start: match.index,
								end: IF.lastIndex
							});
							KEYWORD.lastIndex = iff.index + iff[0].length;
							break;
						}
					case 'endif':
					case 'else':
					case 'elif':
						{
							ENDIF.lastIndex = match.index;
							var endif = ENDIF.exec(source);
							var blockInfo = stack.pop();
							var blockCode = blockInfo.keep ? source.substring(blockInfo.end, match.index) : "";
							source = source.substring(0, blockInfo.start) + blockCode + source.substring(ENDIF.lastIndex);
							KEYWORD.lastIndex = blockInfo.start + blockCode.length;
							var endifCommand = endif[1];
							if (endifCommand === 'else' || endifCommand === 'elif') {
								var _result = false;
								if (!blockInfo.anyKeep) {
									if (endifCommand === 'else') {
										_result = !blockInfo.keep;
									} else {
										var _evaluated = Preprocessor.evaluate(endif[2], defines);
										_result = _evaluated.result;
										error || (error = _evaluated.error);
									}
								}
								stack.push({
									anyKeep: blockInfo.anyKeep || _result,
									keep: _result,
									start: KEYWORD.lastIndex,
									end: KEYWORD.lastIndex
								});
							}
							break;
						}
				}
			}
			if (error) {
				console.warn("Failed to preprocess shader: ", {
					source: originalSource
				});
				return originalSource;
			}
			return source;
		};
		Preprocessor._keep = function _keep(stack) {
			for (var i = 0; i < stack.length; i++) {
				if (!stack[i].keep) return false;
			}
			return true;
		};
		Preprocessor.evaluate = function evaluate(expression, defines) {
			var correct = INVALID.exec(expression) === null;
			var invert = false;
			var defined = DEFINED.exec(expression);
			if (defined) {
				invert = defined[1] === '!';
				expression = defined[2];
			}
			expression = expression.trim();
			var exists = defines.has(expression);
			if (invert) {
				exists = !exists;
			}
			return {
				result: exists,
				error: !correct
			};
		};
		return Preprocessor;
	}();

	var id$7 = 0;
	var Shader = function () {
		function Shader(graphicsDevice, definition) {
			this.meshUniformBufferFormat = void 0;
			this.meshBindGroupFormat = void 0;
			this.id = id$7++;
			this.device = graphicsDevice;
			this.definition = definition;
			this.name = definition.name || 'Untitled';
			this.init();
			if (definition.cshader) ; else {
				definition.vshader = Preprocessor.run(definition.vshader);
				definition.fshader = Preprocessor.run(definition.fshader, graphicsDevice.isWebGL2);
			}
			this.impl = graphicsDevice.createShaderImpl(this);
		}
		var _proto = Shader.prototype;
		_proto.init = function init() {
			this.ready = false;
			this.failed = false;
		};
		_proto.destroy = function destroy() {
			this.device.onDestroyShader(this);
			this.impl.destroy(this);
		};
		_proto.loseContext = function loseContext() {
			this.init();
			this.impl.loseContext();
		};
		_proto.restoreContext = function restoreContext() {
			this.impl.restoreContext(this.device, this);
		};
		_createClass(Shader, [{
			key: "label",
			get: function get() {
				return "Shader Id " + this.id + " " + this.name;
			}
		}]);
		return Shader;
	}();

	var id$6 = 0;
	var BindGroup = function () {
		function BindGroup(graphicsDevice, format, defaultUniformBuffer) {
			this.renderVersionUpdated = -1;
			this.uniformBuffers = void 0;
			this.uniformBufferOffsets = [];
			this.id = id$6++;
			this.device = graphicsDevice;
			this.format = format;
			this.dirty = true;
			this.impl = graphicsDevice.createBindGroupImpl(this);
			this.textures = [];
			this.storageTextures = [];
			this.uniformBuffers = [];
			this.defaultUniformBuffer = defaultUniformBuffer;
			if (defaultUniformBuffer) {
				this.setUniformBuffer(UNIFORM_BUFFER_DEFAULT_SLOT_NAME, defaultUniformBuffer);
			}
		}
		var _proto = BindGroup.prototype;
		_proto.destroy = function destroy() {
			this.impl.destroy();
			this.impl = null;
			this.format = null;
			this.defaultUniformBuffer = null;
		};
		_proto.setUniformBuffer = function setUniformBuffer(name, uniformBuffer) {
			var index = this.format.bufferFormatsMap.get(name);
			if (this.uniformBuffers[index] !== uniformBuffer) {
				this.uniformBuffers[index] = uniformBuffer;
				this.dirty = true;
			}
		};
		_proto.setTexture = function setTexture(name, texture) {
			var index = this.format.textureFormatsMap.get(name);
			if (this.textures[index] !== texture) {
				this.textures[index] = texture;
				this.dirty = true;
			} else if (this.renderVersionUpdated < texture.renderVersionDirty) {
				this.dirty = true;
			}
		};
		_proto.setStorageTexture = function setStorageTexture(name, texture) {
			var index = this.format.storageTextureFormatsMap.get(name);
			if (this.storageTextures[index] !== texture) {
				this.storageTextures[index] = texture;
				this.dirty = true;
			} else if (this.renderVersionUpdated < texture.renderVersionDirty) {
				this.dirty = true;
			}
		};
		_proto.update = function update() {
			var _this$format = this.format,
				textureFormats = _this$format.textureFormats,
				storageTextureFormats = _this$format.storageTextureFormats;
			for (var i = 0; i < textureFormats.length; i++) {
				var textureFormat = textureFormats[i];
				var value = textureFormat.scopeId.value;
				this.setTexture(textureFormat.name, value);
			}
			for (var _i = 0; _i < storageTextureFormats.length; _i++) {
				var storageTextureFormat = storageTextureFormats[_i];
				var _value = storageTextureFormat.scopeId.value;
				this.setStorageTexture(storageTextureFormat.name, _value);
			}
			this.uniformBufferOffsets.length = this.uniformBuffers.length;
			for (var _i2 = 0; _i2 < this.uniformBuffers.length; _i2++) {
				var uniformBuffer = this.uniformBuffers[_i2];
				this.uniformBufferOffsets[_i2] = uniformBuffer.offset;
				if (this.renderVersionUpdated < uniformBuffer.renderVersionDirty) {
					this.dirty = true;
				}
			}
			if (this.dirty) {
				this.dirty = false;
				this.renderVersionUpdated = this.device.renderVersion;
				this.impl.update(this);
			}
		};
		return BindGroup;
	}();

	var DynamicBuffer = function DynamicBuffer(device) {
		this.device = void 0;
		this.device = device;
	};
	var UsedBuffer = function UsedBuffer() {
		this.gpuBuffer = void 0;
		this.stagingBuffer = void 0;
		this.offset = void 0;
		this.size = void 0;
	};
	var DynamicBufferAllocation = function DynamicBufferAllocation() {
		this.storage = void 0;
		this.gpuBuffer = void 0;
		this.offset = void 0;
	};
	var DynamicBuffers = function () {
		function DynamicBuffers(device, bufferSize, bufferAlignment) {
			this.bufferSize = void 0;
			this.gpuBuffers = [];
			this.stagingBuffers = [];
			this.usedBuffers = [];
			this.activeBuffer = null;
			this.device = device;
			this.bufferSize = bufferSize;
			this.bufferAlignment = bufferAlignment;
		}
		var _proto = DynamicBuffers.prototype;
		_proto.destroy = function destroy() {
			var _this = this;
			this.gpuBuffers.forEach(function (gpuBuffer) {
				gpuBuffer.destroy(_this.device);
			});
			this.gpuBuffers = null;
			this.stagingBuffers.forEach(function (stagingBuffer) {
				stagingBuffer.destroy(_this.device);
			});
			this.stagingBuffers = null;
			this.usedBuffers = null;
			this.activeBuffer = null;
		};
		_proto.alloc = function alloc(allocation, size) {
			if (this.activeBuffer) {
				var _alignedStart = math.roundUp(this.activeBuffer.size, this.bufferAlignment);
				var space = this.bufferSize - _alignedStart;
				if (space < size) {
					this.scheduleSubmit();
				}
			}
			if (!this.activeBuffer) {
				var gpuBuffer = this.gpuBuffers.pop();
				if (!gpuBuffer) {
					gpuBuffer = this.createBuffer(this.device, this.bufferSize, false);
				}
				var stagingBuffer = this.stagingBuffers.pop();
				if (!stagingBuffer) {
					stagingBuffer = this.createBuffer(this.device, this.bufferSize, true);
				}
				this.activeBuffer = new UsedBuffer();
				this.activeBuffer.stagingBuffer = stagingBuffer;
				this.activeBuffer.gpuBuffer = gpuBuffer;
				this.activeBuffer.offset = 0;
				this.activeBuffer.size = 0;
			}
			var activeBuffer = this.activeBuffer;
			var alignedStart = math.roundUp(activeBuffer.size, this.bufferAlignment);
			allocation.gpuBuffer = activeBuffer.gpuBuffer;
			allocation.offset = alignedStart;
			allocation.storage = activeBuffer.stagingBuffer.alloc(alignedStart, size);
			activeBuffer.size = alignedStart + size;
		};
		_proto.scheduleSubmit = function scheduleSubmit() {
			if (this.activeBuffer) {
				this.usedBuffers.push(this.activeBuffer);
				this.activeBuffer = null;
			}
		};
		_proto.submit = function submit() {
			this.scheduleSubmit();
		};
		return DynamicBuffers;
	}();

	var _updateFunctions = [];
	_updateFunctions[UNIFORMTYPE_FLOAT] = function (uniformBuffer, value, offset) {
		var dst = uniformBuffer.storageFloat32;
		dst[offset] = value;
	};
	_updateFunctions[UNIFORMTYPE_VEC2] = function (uniformBuffer, value, offset) {
		var dst = uniformBuffer.storageFloat32;
		dst[offset] = value[0];
		dst[offset + 1] = value[1];
	};
	_updateFunctions[UNIFORMTYPE_VEC3] = function (uniformBuffer, value, offset) {
		var dst = uniformBuffer.storageFloat32;
		dst[offset] = value[0];
		dst[offset + 1] = value[1];
		dst[offset + 2] = value[2];
	};
	_updateFunctions[UNIFORMTYPE_VEC4] = function (uniformBuffer, value, offset) {
		var dst = uniformBuffer.storageFloat32;
		dst[offset] = value[0];
		dst[offset + 1] = value[1];
		dst[offset + 2] = value[2];
		dst[offset + 3] = value[3];
	};
	_updateFunctions[UNIFORMTYPE_INT] = function (uniformBuffer, value, offset) {
		var dst = uniformBuffer.storageInt32;
		dst[offset] = value;
	};
	_updateFunctions[UNIFORMTYPE_IVEC2] = function (uniformBuffer, value, offset) {
		var dst = uniformBuffer.storageInt32;
		dst[offset] = value[0];
		dst[offset + 1] = value[1];
	};
	_updateFunctions[UNIFORMTYPE_IVEC3] = function (uniformBuffer, value, offset) {
		var dst = uniformBuffer.storageInt32;
		dst[offset] = value[0];
		dst[offset + 1] = value[1];
		dst[offset + 2] = value[2];
	};
	_updateFunctions[UNIFORMTYPE_IVEC4] = function (uniformBuffer, value, offset) {
		var dst = uniformBuffer.storageInt32;
		dst[offset] = value[0];
		dst[offset + 1] = value[1];
		dst[offset + 2] = value[2];
		dst[offset + 3] = value[3];
	};
	_updateFunctions[UNIFORMTYPE_MAT2] = function (uniformBuffer, value, offset) {
		var dst = uniformBuffer.storageFloat32;
		dst[offset] = value[0];
		dst[offset + 1] = value[1];
		dst[offset + 4] = value[2];
		dst[offset + 5] = value[3];
		dst[offset + 8] = value[4];
		dst[offset + 9] = value[5];
	};
	_updateFunctions[UNIFORMTYPE_MAT3] = function (uniformBuffer, value, offset) {
		var dst = uniformBuffer.storageFloat32;
		dst[offset] = value[0];
		dst[offset + 1] = value[1];
		dst[offset + 2] = value[2];
		dst[offset + 4] = value[3];
		dst[offset + 5] = value[4];
		dst[offset + 6] = value[5];
		dst[offset + 8] = value[6];
		dst[offset + 9] = value[7];
		dst[offset + 10] = value[8];
	};
	_updateFunctions[UNIFORMTYPE_FLOATARRAY] = function (uniformBuffer, value, offset, count) {
		var dst = uniformBuffer.storageFloat32;
		for (var i = 0; i < count; i++) {
			dst[offset + i * 4] = value[i];
		}
	};
	_updateFunctions[UNIFORMTYPE_VEC2ARRAY] = function (uniformBuffer, value, offset, count) {
		var dst = uniformBuffer.storageFloat32;
		for (var i = 0; i < count; i++) {
			dst[offset + i * 4] = value[i * 2];
			dst[offset + i * 4 + 1] = value[i * 2 + 1];
		}
	};
	_updateFunctions[UNIFORMTYPE_VEC3ARRAY] = function (uniformBuffer, value, offset, count) {
		var dst = uniformBuffer.storageFloat32;
		for (var i = 0; i < count; i++) {
			dst[offset + i * 4] = value[i * 3];
			dst[offset + i * 4 + 1] = value[i * 3 + 1];
			dst[offset + i * 4 + 2] = value[i * 3 + 2];
		}
	};
	var UniformBuffer = function () {
		function UniformBuffer(graphicsDevice, format, persistent) {
			if (persistent === void 0) {
				persistent = true;
			}
			this.device = void 0;
			this.persistent = void 0;
			this.allocation = void 0;
			this.storageFloat32 = void 0;
			this.storageInt32 = void 0;
			this.renderVersionDirty = 0;
			this.device = graphicsDevice;
			this.format = format;
			this.persistent = persistent;
			if (persistent) {
				this.impl = graphicsDevice.createUniformBufferImpl(this);
				var storage = new ArrayBuffer(format.byteSize);
				this.assignStorage(new Int32Array(storage));
				graphicsDevice._vram.ub += this.format.byteSize;
			} else {
				this.allocation = new DynamicBufferAllocation();
			}
		}
		var _proto = UniformBuffer.prototype;
		_proto.destroy = function destroy() {
			if (this.persistent) {
				var device = this.device;
				this.impl.destroy(device);
				device._vram.ub -= this.format.byteSize;
			}
		};
		_proto.assignStorage = function assignStorage(storage) {
			this.storageInt32 = storage;
			this.storageFloat32 = new Float32Array(storage.buffer, storage.byteOffset, storage.byteLength / 4);
		};
		_proto.loseContext = function loseContext() {
			var _this$impl;
			(_this$impl = this.impl) == null || _this$impl.loseContext();
		};
		_proto.setUniform = function setUniform(uniformFormat) {
			var offset = uniformFormat.offset;
			var value = uniformFormat.scopeId.value;
			if (value !== null && value !== undefined) {
				var updateFunction = _updateFunctions[uniformFormat.updateType];
				if (updateFunction) {
					updateFunction(this, value, offset, uniformFormat.count);
				} else {
					this.storageFloat32.set(value, offset);
				}
			}
		};
		_proto.set = function set(name) {
			var uniformFormat = this.format.map.get(name);
			if (uniformFormat) {
				this.setUniform(uniformFormat);
			}
		};
		_proto.update = function update() {
			var persistent = this.persistent;
			if (!persistent) {
				var allocation = this.allocation;
				var oldGpuBuffer = allocation.gpuBuffer;
				this.device.dynamicBuffers.alloc(allocation, this.format.byteSize);
				this.assignStorage(allocation.storage);
				if (oldGpuBuffer !== allocation.gpuBuffer) {
					this.renderVersionDirty = this.device.renderVersion;
				}
			}
			var uniforms = this.format.uniforms;
			for (var i = 0; i < uniforms.length; i++) {
				this.setUniform(uniforms[i]);
			}
			if (persistent) {
				this.impl.unlock(this);
			} else {
				this.storageFloat32 = null;
				this.storageInt32 = null;
			}
		};
		_createClass(UniformBuffer, [{
			key: "offset",
			get: function get() {
				return this.persistent ? 0 : this.allocation.offset;
			}
		}]);
		return UniformBuffer;
	}();

	var primitive = {
		type: PRIMITIVE_TRISTRIP,
		base: 0,
		count: 4,
		indexed: false
	};
	var WebgpuClearRenderer = function () {
		function WebgpuClearRenderer(device) {
			var code = "\n\n            struct ub_mesh {\n                color : vec4f,\n                depth: f32\n            }\n\n            @group(0) @binding(0) var<uniform> ubMesh : ub_mesh;\n\n            var<private> pos : array<vec2f, 4> = array<vec2f, 4>(\n                vec2(-1.0, 1.0), vec2(1.0, 1.0),\n                vec2(-1.0, -1.0), vec2(1.0, -1.0)\n            );\n\n            struct VertexOutput {\n                @builtin(position) position : vec4f\n            }\n\n            @vertex\n            fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {\n                var output : VertexOutput;\n                output.position = vec4(pos[vertexIndex], ubMesh.depth, 1.0);\n                return output;\n            }\n\n            @fragment\n            fn fragmentMain() -> @location(0) vec4f {\n                return ubMesh.color;\n            }\n        ";
			this.shader = new Shader(device, {
				name: 'WebGPUClearRendererShader',
				shaderLanguage: SHADERLANGUAGE_WGSL,
				vshader: code,
				fshader: code
			});
			this.uniformBuffer = new UniformBuffer(device, new UniformBufferFormat(device, [new UniformFormat('color', UNIFORMTYPE_VEC4), new UniformFormat('depth', UNIFORMTYPE_FLOAT)]), false);
			var bindGroupFormat = new BindGroupFormat(device, [new BindBufferFormat(UNIFORM_BUFFER_DEFAULT_SLOT_NAME, SHADERSTAGE_VERTEX | SHADERSTAGE_FRAGMENT)]);
			this.bindGroup = new BindGroup(device, bindGroupFormat, this.uniformBuffer);
			this.colorData = new Float32Array(4);
			this.colorId = device.scope.resolve('color');
			this.depthId = device.scope.resolve('depth');
		}
		var _proto = WebgpuClearRenderer.prototype;
		_proto.destroy = function destroy() {
			this.shader.destroy();
			this.shader = null;
			this.uniformBuffer.destroy();
			this.uniformBuffer = null;
			this.bindGroup.destroy();
			this.bindGroup = null;
		};
		_proto.clear = function clear(device, renderTarget, options, defaultOptions) {
			var _options$flags;
			options = options || defaultOptions;
			var flags = (_options$flags = options.flags) != null ? _options$flags : defaultOptions.flags;
			if (flags !== 0) {
				if (flags & CLEARFLAG_COLOR && renderTarget.colorBuffer) {
					var _options$color;
					var color = (_options$color = options.color) != null ? _options$color : defaultOptions.color;
					this.colorData.set(color);
					device.setBlendState(BlendState.NOBLEND);
				} else {
					device.setBlendState(BlendState.NOWRITE);
				}
				this.colorId.setValue(this.colorData);
				if (flags & CLEARFLAG_DEPTH && renderTarget.depth) {
					var _options$depth;
					var depth = (_options$depth = options.depth) != null ? _options$depth : defaultOptions.depth;
					this.depthId.setValue(depth);
					device.setDepthState(DepthState.WRITEDEPTH);
				} else {
					this.depthId.setValue(1);
					device.setDepthState(DepthState.NODEPTH);
				}
				if (flags & CLEARFLAG_STENCIL && renderTarget.stencil) ;
				device.setCullMode(CULLFACE_NONE);
				device.setShader(this.shader);
				var bindGroup = this.bindGroup;
				bindGroup.defaultUniformBuffer.update();
				bindGroup.update();
				device.setBindGroup(BINDGROUP_MESH, bindGroup);
				device.draw(primitive);
			}
		};
		return WebgpuClearRenderer;
	}();

	var WebgpuMipmapRenderer = function () {
		function WebgpuMipmapRenderer(device) {
			this.device = void 0;
			this.device = device;
			var code = "\n \n            var<private> pos : array<vec2f, 4> = array<vec2f, 4>(\n                vec2(-1.0, 1.0), vec2(1.0, 1.0),\n                vec2(-1.0, -1.0), vec2(1.0, -1.0)\n            );\n\n            struct VertexOutput {\n                @builtin(position) position : vec4f,\n                @location(0) texCoord : vec2f\n            };\n\n            @vertex\n            fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {\n              var output : VertexOutput;\n              output.texCoord = pos[vertexIndex] * vec2f(0.5, -0.5) + vec2f(0.5);\n              output.position = vec4f(pos[vertexIndex], 0, 1);\n              return output;\n            }\n\n            @group(0) @binding(0) var imgSampler : sampler;\n            @group(0) @binding(1) var img : texture_2d<f32>;\n\n            @fragment\n            fn fragmentMain(@location(0) texCoord : vec2f) -> @location(0) vec4f {\n              return textureSample(img, imgSampler, texCoord);\n            }\n        ";
			this.shader = new Shader(device, {
				name: 'WebGPUMipmapRendererShader',
				shaderLanguage: SHADERLANGUAGE_WGSL,
				vshader: code,
				fshader: code
			});
			this.minSampler = device.wgpu.createSampler({
				minFilter: 'linear'
			});
		}
		var _proto = WebgpuMipmapRenderer.prototype;
		_proto.destroy = function destroy() {
			this.shader.destroy();
			this.shader = null;
		};
		_proto.generate = function generate(webgpuTexture) {
			var _device$commandEncode;
			var textureDescr = webgpuTexture.descr;
			if (textureDescr.mipLevelCount <= 1) {
				return;
			}
			if (webgpuTexture.texture.volume) {
				return;
			}
			var device = this.device;
			var wgpu = device.wgpu;
			var webgpuShader = this.shader.impl;
			var pipeline = wgpu.createRenderPipeline({
				layout: 'auto',
				vertex: {
					module: webgpuShader.getVertexShaderModule(),
					entryPoint: webgpuShader.vertexEntryPoint
				},
				fragment: {
					module: webgpuShader.getFragmentShaderModule(),
					entryPoint: webgpuShader.fragmentEntryPoint,
					targets: [{
						format: textureDescr.format
					}]
				},
				primitive: {
					topology: 'triangle-strip'
				}
			});
			var numFaces = webgpuTexture.texture.cubemap ? 6 : 1;
			var srcViews = [];
			for (var face = 0; face < numFaces; face++) {
				srcViews.push(webgpuTexture.createView({
					dimension: '2d',
					baseMipLevel: 0,
					mipLevelCount: 1,
					baseArrayLayer: face
				}));
			}
			var commandEncoder = (_device$commandEncode = device.commandEncoder) != null ? _device$commandEncode : wgpu.createCommandEncoder();
			for (var i = 1; i < textureDescr.mipLevelCount; i++) {
				for (var _face = 0; _face < numFaces; _face++) {
					var dstView = webgpuTexture.createView({
						dimension: '2d',
						baseMipLevel: i,
						mipLevelCount: 1,
						baseArrayLayer: _face
					});
					var passEncoder = commandEncoder.beginRenderPass({
						colorAttachments: [{
							view: dstView,
							loadOp: 'clear',
							storeOp: 'store'
						}]
					});
					var bindGroup = wgpu.createBindGroup({
						layout: pipeline.getBindGroupLayout(0),
						entries: [{
							binding: 0,
							resource: this.minSampler
						}, {
							binding: 1,
							resource: srcViews[_face]
						}]
					});
					passEncoder.setPipeline(pipeline);
					passEncoder.setBindGroup(0, bindGroup);
					passEncoder.draw(4);
					passEncoder.end();
					srcViews[_face] = dstView;
				}
			}
			if (!device.commandEncoder) {
				var cb = commandEncoder.finish();
				device.addCommandBuffer(cb);
			}
			device.pipeline = null;
		};
		return WebgpuMipmapRenderer;
	}();

	var WebgpuDynamicBuffer = function (_DynamicBuffer) {
		_inheritsLoose(WebgpuDynamicBuffer, _DynamicBuffer);
		function WebgpuDynamicBuffer(device, size, isStaging) {
			var _this;
			_this = _DynamicBuffer.call(this, device) || this;
			_this.buffer = null;
			_this.mappedRange = null;
			_this.buffer = device.wgpu.createBuffer({
				size: size,
				usage: isStaging ? GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC : GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
				mappedAtCreation: isStaging
			});
			if (isStaging) {
				_this.onAvailable();
			}
			device._vram.ub += size;
			return _this;
		}
		var _proto = WebgpuDynamicBuffer.prototype;
		_proto.destroy = function destroy(device) {
			device._vram.ub -= this.buffer.size;
			this.buffer.destroy();
			this.buffer = null;
		};
		_proto.onAvailable = function onAvailable() {
			this.mappedRange = this.buffer.getMappedRange();
		};
		_proto.alloc = function alloc(offset, size) {
			return new Int32Array(this.mappedRange, offset, size / 4);
		};
		return WebgpuDynamicBuffer;
	}(DynamicBuffer);

	var WebgpuDynamicBuffers = function (_DynamicBuffers) {
		_inheritsLoose(WebgpuDynamicBuffers, _DynamicBuffers);
		function WebgpuDynamicBuffers() {
			var _this;
			for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}
			_this = _DynamicBuffers.call.apply(_DynamicBuffers, [this].concat(args)) || this;
			_this.pendingStagingBuffers = [];
			return _this;
		}
		var _proto = WebgpuDynamicBuffers.prototype;
		_proto.createBuffer = function createBuffer(device, size, isStaging) {
			return new WebgpuDynamicBuffer(device, size, isStaging);
		};
		_proto.submit = function submit() {
			_DynamicBuffers.prototype.submit.call(this);
			var count = this.usedBuffers.length;
			if (count) {
				var device = this.device;
				var gpuBuffers = this.gpuBuffers;
				var commandEncoder = device.wgpu.createCommandEncoder();
				for (var i = count - 1; i >= 0; i--) {
					var usedBuffer = this.usedBuffers[i];
					var stagingBuffer = usedBuffer.stagingBuffer,
						gpuBuffer = usedBuffer.gpuBuffer,
						offset = usedBuffer.offset,
						size = usedBuffer.size;
					var src = stagingBuffer.buffer;
					src.unmap();
					commandEncoder.copyBufferToBuffer(src, offset, gpuBuffer.buffer, offset, size);
					gpuBuffers.push(gpuBuffer);
				}
				var cb = commandEncoder.finish();
				device.addCommandBuffer(cb, true);
				for (var _i = 0; _i < count; _i++) {
					var _stagingBuffer = this.usedBuffers[_i].stagingBuffer;
					this.pendingStagingBuffers.push(_stagingBuffer);
				}
				this.usedBuffers.length = 0;
			}
		};
		_proto.onCommandBuffersSubmitted = function onCommandBuffersSubmitted() {
			var _this2 = this;
			var count = this.pendingStagingBuffers.length;
			if (count) {
				var _loop = function _loop() {
					var stagingBuffer = _this2.pendingStagingBuffers[i];
					stagingBuffer.buffer.mapAsync(GPUMapMode.WRITE).then(function () {
						if (_this2.stagingBuffers) {
							stagingBuffer.onAvailable();
							_this2.stagingBuffers.push(stagingBuffer);
						}
					});
				};
				for (var i = 0; i < count; i++) {
					_loop();
				}
				this.pendingStagingBuffers.length = 0;
			}
		};
		return WebgpuDynamicBuffers;
	}(DynamicBuffers);

	var GpuProfiler = function () {
		function GpuProfiler() {
			this.frameAllocations = [];
			this.pastFrameAllocations = new Map();
			this._enabled = false;
			this._enableRequest = false;
			this._frameTime = 0;
		}
		var _proto = GpuProfiler.prototype;
		_proto.loseContext = function loseContext() {
			this.pastFrameAllocations.clear();
		};
		_proto.processEnableRequest = function processEnableRequest() {
			if (this._enableRequest !== this._enabled) {
				this._enabled = this._enableRequest;
				if (!this._enabled) {
					this._frameTime = 0;
				}
			}
		};
		_proto.request = function request(renderVersion) {
			this.pastFrameAllocations.set(renderVersion, this.frameAllocations);
			this.frameAllocations = [];
		};
		_proto.report = function report(renderVersion, timings) {
			if (timings) {
				var allocations = this.pastFrameAllocations.get(renderVersion);
				if (timings.length > 0) {
					this._frameTime = timings[0];
				}
				if (Tracing.get(TRACEID_GPU_TIMINGS)) {
					for (var i = 0; i < allocations.length; ++i) {
						allocations[i];
					}
				}
			}
			this.pastFrameAllocations.delete(renderVersion);
		};
		_proto.getSlot = function getSlot(name) {
			var slot = this.frameAllocations.length;
			this.frameAllocations.push(name);
			return slot;
		};
		_createClass(GpuProfiler, [{
			key: "enabled",
			get: function get() {
				return this._enableRequest;
			},
			set: function set(value) {
				this._enableRequest = value;
			}
		}, {
			key: "slotCount",
			get: function get() {
				return this.frameAllocations.length;
			}
		}]);
		return GpuProfiler;
	}();

	var WebgpuQuerySet = function () {
		function WebgpuQuerySet(device, isTimestamp, capacity) {
			this.querySet = void 0;
			this.stagingBuffers = [];
			this.activeStagingBuffer = null;
			this.bytesPerSlot = void 0;
			this.device = device;
			this.capacity = capacity;
			this.bytesPerSlot = isTimestamp ? 8 : 4;
			var wgpu = device.wgpu;
			this.querySet = wgpu.createQuerySet({
				type: isTimestamp ? 'timestamp' : 'occlusion',
				count: capacity
			});
			this.queryBuffer = wgpu.createBuffer({
				size: this.bytesPerSlot * capacity,
				usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST
			});
		}
		var _proto = WebgpuQuerySet.prototype;
		_proto.destroy = function destroy() {
			var _this$querySet, _this$queryBuffer;
			(_this$querySet = this.querySet) == null || _this$querySet.destroy();
			this.querySet = null;
			(_this$queryBuffer = this.queryBuffer) == null || _this$queryBuffer.destroy();
			this.queryBuffer = null;
			this.activeStagingBuffer = null;
			this.stagingBuffers.forEach(function (stagingBuffer) {
				stagingBuffer.destroy();
			});
			this.stagingBuffers = null;
		};
		_proto.getStagingBuffer = function getStagingBuffer() {
			var stagingBuffer = this.stagingBuffers.pop();
			if (!stagingBuffer) {
				stagingBuffer = this.device.wgpu.createBuffer({
					size: this.queryBuffer.size,
					usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
				});
			}
			return stagingBuffer;
		};
		_proto.resolve = function resolve(count) {
			var device = this.device;
			var commandEncoder = device.wgpu.createCommandEncoder();
			commandEncoder.resolveQuerySet(this.querySet, 0, count, this.queryBuffer, 0);
			var activeStagingBuffer = this.getStagingBuffer();
			this.activeStagingBuffer = activeStagingBuffer;
			commandEncoder.copyBufferToBuffer(this.queryBuffer, 0, activeStagingBuffer, 0, this.bytesPerSlot * count);
			var cb = commandEncoder.finish();
			device.addCommandBuffer(cb);
		};
		_proto.request = function request(count, renderVersion) {
			var _this = this;
			var stagingBuffer = this.activeStagingBuffer;
			this.activeStagingBuffer = null;
			return stagingBuffer.mapAsync(GPUMapMode.READ).then(function () {
				var srcTimings = new BigInt64Array(stagingBuffer.getMappedRange());
				var timings = [];
				for (var i = 0; i < count; i++) {
					timings.push(Number(srcTimings[i * 2 + 1] - srcTimings[i * 2]) * 0.000001);
				}
				stagingBuffer.unmap();
				_this.stagingBuffers.push(stagingBuffer);
				return {
					renderVersion: renderVersion,
					timings: timings
				};
			});
		};
		return WebgpuQuerySet;
	}();

	var WebgpuGpuProfiler = function (_GpuProfiler) {
		_inheritsLoose(WebgpuGpuProfiler, _GpuProfiler);
		function WebgpuGpuProfiler(device) {
			var _this;
			_this = _GpuProfiler.call(this) || this;
			_this.device = void 0;
			_this.frameGPUMarkerSlot = void 0;
			_this.device = device;
			_this.timestampQueriesSet = device.supportsTimestampQuery ? new WebgpuQuerySet(device, true, 512) : null;
			return _this;
		}
		var _proto = WebgpuGpuProfiler.prototype;
		_proto.destroy = function destroy() {
			var _this$timestampQuerie;
			(_this$timestampQuerie = this.timestampQueriesSet) == null || _this$timestampQuerie.destroy();
			this.timestampQueriesSet = null;
		};
		_proto.frameMarker = function frameMarker(isStart) {
			if (this.timestampQueriesSet) {
				var commandEncoder = this.device.wgpu.createCommandEncoder();
				this.frameGPUMarkerSlot = isStart ? this.getSlot('GpuFrame') : this.frameGPUMarkerSlot;
				commandEncoder.writeTimestamp(this.timestampQueriesSet.querySet, this.frameGPUMarkerSlot * 2 + (isStart ? 0 : 1));
				var cb = commandEncoder.finish();
				this.device.addCommandBuffer(cb, isStart);
			}
		};
		_proto.frameStart = function frameStart() {
			this.processEnableRequest();
			if (this._enabled) {
				this.frameMarker(true);
			}
		};
		_proto.frameEnd = function frameEnd() {
			if (this._enabled) {
				var _this$timestampQuerie2;
				this.frameMarker(false);
				(_this$timestampQuerie2 = this.timestampQueriesSet) == null || _this$timestampQuerie2.resolve(this.slotCount * 2);
			}
		};
		_proto.request = function request() {
			var _this2 = this;
			if (this._enabled) {
				var _this$timestampQuerie3;
				var renderVersion = this.device.renderVersion;
				(_this$timestampQuerie3 = this.timestampQueriesSet) == null || _this$timestampQuerie3.request(this.slotCount, renderVersion).then(function (results) {
					_this2.report(results.renderVersion, results.timings);
				});
				_GpuProfiler.prototype.request.call(this, renderVersion);
			}
		};
		return WebgpuGpuProfiler;
	}(GpuProfiler);

	var WebgpuResolver = function () {
		function WebgpuResolver(device) {
			this.device = void 0;
			this.pipelineCache = new Map();
			this.device = device;
			var code = "\n \n            var<private> pos : array<vec2f, 4> = array<vec2f, 4>(\n                vec2(-1.0, 1.0), vec2(1.0, 1.0), vec2(-1.0, -1.0), vec2(1.0, -1.0)\n            );\n\n            struct VertexOutput {\n                @builtin(position) position : vec4f,\n            };\n\n            @vertex\n            fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {\n              var output : VertexOutput;\n              output.position = vec4f(pos[vertexIndex], 0, 1);\n              return output;\n            }\n\n            @group(0) @binding(0) var img : texture_depth_multisampled_2d;\n\n            @fragment\n            fn fragmentMain(@builtin(position) fragColor: vec4f) -> @location(0) vec4f {\n                // load th depth value from sample index 0\n                var depth = textureLoad(img, vec2i(fragColor.xy), 0u);\n                return vec4<f32>(depth, 0.0, 0.0, 0.0);\n            }\n        ";
			this.shader = new Shader(device, {
				name: 'WebGPUResolverDepthShader',
				shaderLanguage: SHADERLANGUAGE_WGSL,
				vshader: code,
				fshader: code
			});
		}
		var _proto = WebgpuResolver.prototype;
		_proto.destroy = function destroy() {
			this.shader.destroy();
			this.shader = null;
			this.pipelineCache = null;
		};
		_proto.getPipeline = function getPipeline(format) {
			var pipeline = this.pipelineCache.get(format);
			if (!pipeline) {
				pipeline = this.createPipeline(format);
				this.pipelineCache.set(format, pipeline);
			}
			return pipeline;
		};
		_proto.createPipeline = function createPipeline(format) {
			var webgpuShader = this.shader.impl;
			var pipeline = this.device.wgpu.createRenderPipeline({
				layout: 'auto',
				vertex: {
					module: webgpuShader.getVertexShaderModule(),
					entryPoint: webgpuShader.vertexEntryPoint
				},
				fragment: {
					module: webgpuShader.getFragmentShaderModule(),
					entryPoint: webgpuShader.fragmentEntryPoint,
					targets: [{
						format: format
					}]
				},
				primitive: {
					topology: 'triangle-strip'
				}
			});
			return pipeline;
		};
		_proto.resolveDepth = function resolveDepth(commandEncoder, sourceTexture, destinationTexture) {
			var device = this.device;
			var wgpu = device.wgpu;
			var pipeline = this.getPipeline(destinationTexture.format);
			var numFaces = sourceTexture.depthOrArrayLayers;
			for (var face = 0; face < numFaces; face++) {
				var srcView = sourceTexture.createView({
					dimension: '2d',
					aspect: 'depth-only',
					baseMipLevel: 0,
					mipLevelCount: 1,
					baseArrayLayer: face
				});
				var dstView = destinationTexture.createView({
					dimension: '2d',
					baseMipLevel: 0,
					mipLevelCount: 1,
					baseArrayLayer: face
				});
				var passEncoder = commandEncoder.beginRenderPass({
					colorAttachments: [{
						view: dstView,
						loadOp: 'clear',
						storeOp: 'store'
					}]
				});
				var bindGroup = wgpu.createBindGroup({
					layout: pipeline.getBindGroupLayout(0),
					entries: [{
						binding: 0,
						resource: srcView
					}]
				});
				passEncoder.setPipeline(pipeline);
				passEncoder.setBindGroup(0, bindGroup);
				passEncoder.draw(4);
				passEncoder.end();
			}
			device.pipeline = null;
		};
		return WebgpuResolver;
	}();

	var WebgpuCompute = function () {
		function WebgpuCompute(compute) {
			this.compute = compute;
			var device = compute.device,
				shader = compute.shader;
			var computeBindGroupFormat = shader.impl.computeBindGroupFormat;
			this.bindGroup = new BindGroup(device, computeBindGroupFormat);
			this.pipeline = device.computePipeline.get(shader, computeBindGroupFormat);
		}
		var _proto = WebgpuCompute.prototype;
		_proto.dispatch = function dispatch(x, y, z) {
			var device = this.compute.device;
			device.startComputePass();
			var bindGroup = this.bindGroup;
			bindGroup.update();
			device.setBindGroup(0, bindGroup);
			var passEncoder = device.passEncoder;
			passEncoder.setPipeline(this.pipeline);
			passEncoder.dispatchWorkgroups(x, y, z);
			device.endComputePass();
		};
		return WebgpuCompute;
	}();

	var WebgpuGraphicsDevice = function (_GraphicsDevice) {
		_inheritsLoose(WebgpuGraphicsDevice, _GraphicsDevice);
		function WebgpuGraphicsDevice(canvas, options) {
			var _options$alpha, _options$antialias;
			var _this;
			if (options === void 0) {
				options = {};
			}
			_this = _GraphicsDevice.call(this, canvas, options) || this;
			_this.renderPipeline = new WebgpuRenderPipeline(_assertThisInitialized(_this));
			_this.computePipeline = new WebgpuComputePipeline(_assertThisInitialized(_this));
			_this.clearRenderer = void 0;
			_this.mipmapRenderer = void 0;
			_this.pipeline = void 0;
			_this.bindGroupFormats = [];
			_this.commandEncoder = null;
			_this.commandBuffers = [];
			_this.limits = void 0;
			options = _this.initOptions;
			options.alpha = (_options$alpha = options.alpha) != null ? _options$alpha : true;
			_this.backBufferAntialias = (_options$antialias = options.antialias) != null ? _options$antialias : false;
			_this.isWebGPU = true;
			_this._deviceType = DEVICETYPE_WEBGPU;
			_this.setupPassEncoderDefaults();
			return _this;
		}
		var _proto = WebgpuGraphicsDevice.prototype;
		_proto.destroy = function destroy() {
			this.clearRenderer.destroy();
			this.clearRenderer = null;
			this.mipmapRenderer.destroy();
			this.mipmapRenderer = null;
			this.resolver.destroy();
			this.resolver = null;
			_GraphicsDevice.prototype.destroy.call(this);
		};
		_proto.initDeviceCaps = function initDeviceCaps() {
			this.disableParticleSystem = true;
			var limits = this.gpuAdapter.limits;
			this.limits = limits;
			this.precision = 'highp';
			this.maxPrecision = 'highp';
			this.maxSamples = 4;
			this.maxTextures = 16;
			this.maxTextureSize = limits.maxTextureDimension2D;
			this.maxCubeMapSize = limits.maxTextureDimension2D;
			this.maxVolumeSize = limits.maxTextureDimension3D;
			this.maxColorAttachments = limits.maxColorAttachments;
			this.maxPixelRatio = 1;
			this.maxAnisotropy = 16;
			this.supportsInstancing = true;
			this.supportsUniformBuffers = true;
			this.supportsVolumeTextures = true;
			this.supportsBoneTextures = true;
			this.supportsMorphTargetTexturesCore = true;
			this.supportsAreaLights = true;
			this.supportsDepthShadow = true;
			this.supportsGpuParticles = false;
			this.supportsMrt = true;
			this.supportsCompute = true;
			this.extUintElement = true;
			this.extTextureFloat = true;
			this.textureFloatRenderable = true;
			this.textureHalfFloatFilterable = true;
			this.extTextureHalfFloat = true;
			this.textureHalfFloatRenderable = true;
			this.textureHalfFloatUpdatable = true;
			this.boneLimit = 1024;
			this.supportsImageBitmap = true;
			this.extStandardDerivatives = true;
			this.extBlendMinmax = true;
			this.areaLightLutFormat = this.textureFloatFilterable ? PIXELFORMAT_RGBA32F : PIXELFORMAT_RGBA8;
			this.supportsTextureFetch = true;
			this.samples = this.backBufferAntialias ? 4 : 1;
		};
		_proto.initWebGpu = function () {
			var _initWebGpu = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(glslangUrl, twgslUrl) {
				var _this2 = this;
				var buildUrl, results, adapterOptions, requiredFeatures, requireFeature, deviceDescr, preferredCanvasFormat;
				return _regeneratorRuntime().wrap(function _callee$(_context) {
					while (1) switch (_context.prev = _context.next) {
						case 0:
							if (window.navigator.gpu) {
								_context.next = 2;
								break;
							}
							throw new Error('Unable to retrieve GPU. Ensure you are using a browser that supports WebGPU rendering.');
						case 2:
							buildUrl = function buildUrl(relativePath) {
								var url = new URL(window.location.href);
								url.pathname = relativePath;
								url.search = '';
								return url.toString();
							};
							_context.next = 5;
							return Promise.all([import("" + buildUrl(twgslUrl)).then(function (module) {
								return twgsl(twgslUrl.replace('.js', '.wasm'));
							}), import("" + buildUrl(glslangUrl)).then(function (module) {
								return module.default();
							})]);
						case 5:
							results = _context.sent;
							this.twgsl = results[0];
							this.glslang = results[1];
							adapterOptions = {
								powerPreference: this.initOptions.powerPreference !== 'default' ? this.initOptions.powerPreference : undefined
							};
							_context.next = 11;
							return window.navigator.gpu.requestAdapter(adapterOptions);
						case 11:
							this.gpuAdapter = _context.sent;
							requiredFeatures = [];
							requireFeature = function requireFeature(feature) {
								var supported = _this2.gpuAdapter.features.has(feature);
								if (supported) {
									requiredFeatures.push(feature);
								}
								return supported;
							};
							this.textureFloatFilterable = requireFeature('float32-filterable');
							this.extCompressedTextureS3TC = requireFeature('texture-compression-bc');
							this.extCompressedTextureETC = requireFeature('texture-compression-etc2');
							this.extCompressedTextureASTC = requireFeature('texture-compression-astc');
							this.supportsTimestampQuery = requireFeature('timestamp-query');
							this.textureRG11B10Renderable = requireFeature('rg11b10ufloat-renderable');
							deviceDescr = {
								requiredFeatures: requiredFeatures,
								requiredLimits: {},
								defaultQueue: {
									label: 'Default Queue'
								}
							};
							_context.next = 23;
							return this.gpuAdapter.requestDevice(deviceDescr);
						case 23:
							this.wgpu = _context.sent;
							this.initDeviceCaps();
							this.gpuContext = this.canvas.getContext('webgpu');
							preferredCanvasFormat = navigator.gpu.getPreferredCanvasFormat();
							this.backBufferFormat = preferredCanvasFormat === 'rgba8unorm' ? PIXELFORMAT_RGBA8 : PIXELFORMAT_BGRA8;
							this.canvasConfig = {
								device: this.wgpu,
								colorSpace: 'srgb',
								alphaMode: this.initOptions.alpha ? 'premultiplied' : 'opaque',
								format: preferredCanvasFormat,
								usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,
								viewFormats: []
							};
							this.gpuContext.configure(this.canvasConfig);
							this.createBackbuffer();
							this.clearRenderer = new WebgpuClearRenderer(this);
							this.mipmapRenderer = new WebgpuMipmapRenderer(this);
							this.resolver = new WebgpuResolver(this);
							this.postInit();
							return _context.abrupt("return", this);
						case 36:
						case "end":
							return _context.stop();
					}
				}, _callee, this);
			}));
			function initWebGpu(_x, _x2) {
				return _initWebGpu.apply(this, arguments);
			}
			return initWebGpu;
		}();
		_proto.postInit = function postInit() {
			_GraphicsDevice.prototype.postInit.call(this);
			this.gpuProfiler = new WebgpuGpuProfiler(this);
			this.dynamicBuffers = new WebgpuDynamicBuffers(this, 1024 * 1024, this.limits.minUniformBufferOffsetAlignment);
		};
		_proto.createBackbuffer = function createBackbuffer() {
			this.supportsStencil = this.initOptions.stencil;
			this.backBuffer = new RenderTarget({
				name: 'WebgpuFramebuffer',
				graphicsDevice: this,
				depth: this.initOptions.depth,
				stencil: this.supportsStencil,
				samples: this.samples
			});
		};
		_proto.frameStart = function frameStart() {
			_GraphicsDevice.prototype.frameStart.call(this);
			this.gpuProfiler.frameStart();
			this.submit();
			var outColorBuffer = this.gpuContext.getCurrentTexture();
			if (this.backBufferSize.x !== outColorBuffer.width || this.backBufferSize.y !== outColorBuffer.height) {
				this.backBufferSize.set(outColorBuffer.width, outColorBuffer.height);
				this.backBuffer.destroy();
				this.backBuffer = null;
				this.createBackbuffer();
			}
			var rt = this.backBuffer;
			var wrt = rt.impl;
			wrt.setColorAttachment(0, undefined, outColorBuffer.format);
			this.initRenderTarget(rt);
			wrt.assignColorTexture(outColorBuffer);
		};
		_proto.frameEnd = function frameEnd() {
			_GraphicsDevice.prototype.frameEnd.call(this);
			this.gpuProfiler.frameEnd();
			this.submit();
			this.gpuProfiler.request();
		};
		_proto.createUniformBufferImpl = function createUniformBufferImpl(uniformBuffer) {
			return new WebgpuUniformBuffer(uniformBuffer);
		};
		_proto.createVertexBufferImpl = function createVertexBufferImpl(vertexBuffer, format) {
			return new WebgpuVertexBuffer(vertexBuffer, format);
		};
		_proto.createIndexBufferImpl = function createIndexBufferImpl(indexBuffer) {
			return new WebgpuIndexBuffer(indexBuffer);
		};
		_proto.createShaderImpl = function createShaderImpl(shader) {
			return new WebgpuShader(shader);
		};
		_proto.createTextureImpl = function createTextureImpl(texture) {
			return new WebgpuTexture(texture);
		};
		_proto.createRenderTargetImpl = function createRenderTargetImpl(renderTarget) {
			return new WebgpuRenderTarget(renderTarget);
		};
		_proto.createBindGroupFormatImpl = function createBindGroupFormatImpl(bindGroupFormat) {
			return new WebgpuBindGroupFormat(bindGroupFormat);
		};
		_proto.createBindGroupImpl = function createBindGroupImpl(bindGroup) {
			return new WebgpuBindGroup();
		};
		_proto.createComputeImpl = function createComputeImpl(compute) {
			return new WebgpuCompute(compute);
		};
		_proto.setBindGroup = function setBindGroup(index, bindGroup) {
			if (this.passEncoder) {
				this.passEncoder.setBindGroup(index, bindGroup.impl.bindGroup, bindGroup.uniformBufferOffsets);
				this.bindGroupFormats[index] = bindGroup.format.impl;
			}
		};
		_proto.submitVertexBuffer = function submitVertexBuffer(vertexBuffer, slot) {
			var elements = vertexBuffer.format.elements;
			var elementCount = elements.length;
			var vbBuffer = vertexBuffer.impl.buffer;
			for (var i = 0; i < elementCount; i++) {
				this.passEncoder.setVertexBuffer(slot + i, vbBuffer, elements[i].offset);
			}
			return elementCount;
		};
		_proto.draw = function draw(primitive, numInstances, keepBuffers) {
			if (numInstances === void 0) {
				numInstances = 1;
			}
			if (this.shader.ready && !this.shader.failed) {
				var passEncoder = this.passEncoder;
				var vb0 = this.vertexBuffers[0];
				var vb1 = this.vertexBuffers[1];
				this.vertexBuffers.length = 0;
				if (vb0) {
					var vbSlot = this.submitVertexBuffer(vb0, 0);
					if (vb1) {
						this.submitVertexBuffer(vb1, vbSlot);
					}
				}
				var pipeline = this.renderPipeline.get(primitive, vb0 == null ? void 0 : vb0.format, vb1 == null ? void 0 : vb1.format, this.shader, this.renderTarget, this.bindGroupFormats, this.blendState, this.depthState, this.cullMode, this.stencilEnabled, this.stencilFront, this.stencilBack);
				if (this.pipeline !== pipeline) {
					this.pipeline = pipeline;
					passEncoder.setPipeline(pipeline);
				}
				var ib = this.indexBuffer;
				if (ib) {
					this.indexBuffer = null;
					passEncoder.setIndexBuffer(ib.impl.buffer, ib.impl.format);
					passEncoder.drawIndexed(primitive.count, numInstances, 0, 0, 0);
				} else {
					passEncoder.draw(primitive.count, numInstances, 0, 0);
				}
			}
		};
		_proto.setShader = function setShader(shader) {
			this.shader = shader;
			return true;
		};
		_proto.setBlendState = function setBlendState(blendState) {
			this.blendState.copy(blendState);
		};
		_proto.setDepthState = function setDepthState(depthState) {
			this.depthState.copy(depthState);
		};
		_proto.setStencilState = function setStencilState(stencilFront, stencilBack) {
			if (stencilFront || stencilBack) {
				this.stencilEnabled = true;
				this.stencilFront.copy(stencilFront != null ? stencilFront : StencilParameters.DEFAULT);
				this.stencilBack.copy(stencilBack != null ? stencilBack : StencilParameters.DEFAULT);
				var ref = this.stencilFront.ref;
				if (this.stencilRef !== ref) {
					this.stencilRef = ref;
					this.passEncoder.setStencilReference(ref);
				}
			} else {
				this.stencilEnabled = false;
			}
		};
		_proto.setBlendColor = function setBlendColor(r, g, b, a) {};
		_proto.setCullMode = function setCullMode(cullMode) {
			this.cullMode = cullMode;
		};
		_proto.setAlphaToCoverage = function setAlphaToCoverage(state) {};
		_proto.initializeContextCaches = function initializeContextCaches() {
			_GraphicsDevice.prototype.initializeContextCaches.call(this);
		};
		_proto.setupPassEncoderDefaults = function setupPassEncoderDefaults() {
			this.stencilRef = 0;
		};
		_proto._uploadDirtyTextures = function _uploadDirtyTextures() {
			this.textures.forEach(function (texture) {
				if (texture._needsUpload || texture._needsMipmaps) {
					texture.upload();
				}
			});
		};
		_proto.startRenderPass = function startRenderPass(renderPass) {
			this._uploadDirtyTextures();
			var rt = renderPass.renderTarget || this.backBuffer;
			this.renderTarget = rt;
			var wrt = rt.impl;
			this.commandEncoder = this.wgpu.createCommandEncoder();
			if (rt !== this.backBuffer) {
				this.initRenderTarget(rt);
			}
			wrt.setupForRenderPass(renderPass);
			this.pipeline = null;
			var renderPassDesc = wrt.renderPassDescriptor;
			if (this.gpuProfiler._enabled) {
				if (this.gpuProfiler.timestampQueriesSet) {
					var slot = this.gpuProfiler.getSlot(renderPass.name);
					renderPassDesc.timestampWrites = {
						querySet: this.gpuProfiler.timestampQueriesSet.querySet,
						beginningOfPassWriteIndex: slot * 2,
						endOfPassWriteIndex: slot * 2 + 1
					};
				}
			}
			this.passEncoder = this.commandEncoder.beginRenderPass(renderPassDesc);
			this.setupPassEncoderDefaults();
			var width = rt.width,
				height = rt.height;
			this.setViewport(0, 0, width, height);
			this.setScissor(0, 0, width, height);
			this.insideRenderPass = true;
		};
		_proto.endRenderPass = function endRenderPass(renderPass) {
			this.passEncoder.end();
			this.passEncoder = null;
			this.insideRenderPass = false;
			this.bindGroupFormats.length = 0;
			for (var i = 0; i < renderPass.colorArrayOps.length; i++) {
				var colorOps = renderPass.colorArrayOps[i];
				if (colorOps.mipmaps) {
					this.mipmapRenderer.generate(renderPass.renderTarget._colorBuffers[i].impl);
				}
			}
			var cb = this.commandEncoder.finish();
			this.addCommandBuffer(cb);
			this.commandEncoder = null;
		};
		_proto.startComputePass = function startComputePass() {
			this.commandEncoder = this.wgpu.createCommandEncoder();
			this.pipeline = null;
			this.passEncoder = this.commandEncoder.beginComputePass();
			this.insideRenderPass = true;
		};
		_proto.endComputePass = function endComputePass() {
			this.passEncoder.end();
			this.passEncoder = null;
			this.insideRenderPass = false;
			this.bindGroupFormats.length = 0;
			var cb = this.commandEncoder.finish();
			this.addCommandBuffer(cb);
			this.commandEncoder = null;
		};
		_proto.addCommandBuffer = function addCommandBuffer(commandBuffer, front) {
			if (front === void 0) {
				front = false;
			}
			if (front) {
				this.commandBuffers.unshift(commandBuffer);
			} else {
				this.commandBuffers.push(commandBuffer);
			}
		};
		_proto.submit = function submit() {
			if (this.commandBuffers.length > 0) {
				this.dynamicBuffers.submit();
				this.wgpu.queue.submit(this.commandBuffers);
				this.commandBuffers.length = 0;
				this.dynamicBuffers.onCommandBuffersSubmitted();
			}
		};
		_proto.clear = function clear(options) {
			if (options.flags) {
				this.clearRenderer.clear(this, this.renderTarget, options, this.defaultClearOptions);
			}
		};
		_proto.setDepthBias = function setDepthBias(on) {};
		_proto.setDepthBiasValues = function setDepthBiasValues(constBias, slopeBias) {};
		_proto.setViewport = function setViewport(x, y, w, h) {
			if (this.passEncoder) {
				if (!this.renderTarget.flipY) {
					y = this.renderTarget.height - y - h;
				}
				this.vx = x;
				this.vy = y;
				this.vw = w;
				this.vh = h;
				this.passEncoder.setViewport(x, y, w, h, 0, 1);
			}
		};
		_proto.setScissor = function setScissor(x, y, w, h) {
			if (this.passEncoder) {
				if (!this.renderTarget.flipY) {
					y = this.renderTarget.height - y - h;
				}
				this.sx = x;
				this.sy = y;
				this.sw = w;
				this.sh = h;
				this.passEncoder.setScissorRect(x, y, w, h);
			}
		};
		_proto.copyRenderTarget = function copyRenderTarget(source, dest, color, depth) {
			var _this$commandEncoder;
			var copySize = {
				width: source ? source.width : dest.width,
				height: source ? source.height : dest.height,
				depthOrArrayLayers: 1
			};
			var commandEncoder = (_this$commandEncoder = this.commandEncoder) != null ? _this$commandEncoder : this.wgpu.createCommandEncoder();
			if (color) {
				var copySrc = {
					texture: source ? source.colorBuffer.impl.gpuTexture : this.renderTarget.impl.assignedColorTexture,
					mipLevel: 0
				};
				var copyDst = {
					texture: dest ? dest.colorBuffer.impl.gpuTexture : this.renderTarget.impl.assignedColorTexture,
					mipLevel: 0
				};
				commandEncoder.copyTextureToTexture(copySrc, copyDst, copySize);
			}
			if (depth) {
				var sourceRT = source ? source : this.renderTarget;
				var sourceTexture = sourceRT.impl.depthTexture;
				if (source.samples > 1) {
					var destTexture = dest.colorBuffer.impl.gpuTexture;
					this.resolver.resolveDepth(commandEncoder, sourceTexture, destTexture);
				} else {
					var _destTexture = dest ? dest.depthBuffer.impl.gpuTexture : this.renderTarget.impl.depthTexture;
					var _copySrc = {
						texture: sourceTexture,
						mipLevel: 0
					};
					var _copyDst = {
						texture: _destTexture,
						mipLevel: 0
					};
					commandEncoder.copyTextureToTexture(_copySrc, _copyDst, copySize);
				}
			}
			if (!this.commandEncoder) {
				var cb = commandEncoder.finish();
				this.addCommandBuffer(cb);
			}
			return true;
		};
		return WebgpuGraphicsDevice;
	}(GraphicsDevice);

	var id$5 = 0;
	var Texture = function () {
		function Texture(graphicsDevice, options) {
			var _options$name, _options$width, _options$height, _options$format, _options$storage, _options$cubemap, _options$fixCubemapSe, _options$flipY, _options$premultiplyA, _ref, _options$mipmaps, _options$minFilter, _options$magFilter, _options$anisotropy, _options$addressU, _options$addressV, _options$addressW, _options$compareOnRea, _options$compareFunc;
			if (options === void 0) {
				options = {};
			}
			this.name = void 0;
			this._isRenderTarget = false;
			this._gpuSize = 0;
			this.id = id$5++;
			this._invalid = false;
			this._lockedLevel = -1;
			this.renderVersionDirty = 0;
			this._storage = false;
			this.device = graphicsDevice;
			this.name = (_options$name = options.name) != null ? _options$name : '';
			this._width = Math.floor((_options$width = options.width) != null ? _options$width : 4);
			this._height = Math.floor((_options$height = options.height) != null ? _options$height : 4);
			this._format = (_options$format = options.format) != null ? _options$format : PIXELFORMAT_RGBA8;
			this._compressed = isCompressedPixelFormat(this._format);
			if (graphicsDevice.supportsVolumeTextures) {
				var _options$volume, _options$depth, _options$arrayLength;
				this._volume = (_options$volume = options.volume) != null ? _options$volume : false;
				this._depth = Math.floor((_options$depth = options.depth) != null ? _options$depth : 1);
				this._arrayLength = Math.floor((_options$arrayLength = options.arrayLength) != null ? _options$arrayLength : 0);
			} else {
				this._volume = false;
				this._depth = 1;
				this._arrayLength = 0;
			}
			this._storage = (_options$storage = options.storage) != null ? _options$storage : false;
			this._cubemap = (_options$cubemap = options.cubemap) != null ? _options$cubemap : false;
			this.fixCubemapSeams = (_options$fixCubemapSe = options.fixCubemapSeams) != null ? _options$fixCubemapSe : false;
			this._flipY = (_options$flipY = options.flipY) != null ? _options$flipY : false;
			this._premultiplyAlpha = (_options$premultiplyA = options.premultiplyAlpha) != null ? _options$premultiplyA : false;
			this._mipmaps = (_ref = (_options$mipmaps = options.mipmaps) != null ? _options$mipmaps : options.autoMipmap) != null ? _ref : true;
			this._minFilter = (_options$minFilter = options.minFilter) != null ? _options$minFilter : FILTER_LINEAR_MIPMAP_LINEAR;
			this._magFilter = (_options$magFilter = options.magFilter) != null ? _options$magFilter : FILTER_LINEAR;
			this._anisotropy = (_options$anisotropy = options.anisotropy) != null ? _options$anisotropy : 1;
			this._addressU = (_options$addressU = options.addressU) != null ? _options$addressU : ADDRESS_REPEAT;
			this._addressV = (_options$addressV = options.addressV) != null ? _options$addressV : ADDRESS_REPEAT;
			this._addressW = (_options$addressW = options.addressW) != null ? _options$addressW : ADDRESS_REPEAT;
			this._compareOnRead = (_options$compareOnRea = options.compareOnRead) != null ? _options$compareOnRea : false;
			this._compareFunc = (_options$compareFunc = options.compareFunc) != null ? _options$compareFunc : FUNC_LESS;
			this.type = TEXTURETYPE_DEFAULT;
			if (options.hasOwnProperty('type')) {
				this.type = options.type;
			} else if (options.hasOwnProperty('rgbm')) {
				this.type = options.rgbm ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT;
			} else if (options.hasOwnProperty('swizzleGGGR')) {
				this.type = options.swizzleGGGR ? TEXTURETYPE_SWIZZLEGGGR : TEXTURETYPE_DEFAULT;
			}
			this.projection = TEXTUREPROJECTION_NONE;
			if (this._cubemap) {
				this.projection = TEXTUREPROJECTION_CUBE;
			} else if (options.projection && options.projection !== TEXTUREPROJECTION_CUBE) {
				this.projection = options.projection;
			}
			this.impl = graphicsDevice.createTextureImpl(this);
			this.dirtyAll();
			this._levels = options.levels;
			if (this._levels) {
				this.upload();
			} else {
				this._levels = this._cubemap ? [[null, null, null, null, null, null]] : [null];
			}
			graphicsDevice.textures.push(this);
		}
		var _proto = Texture.prototype;
		_proto.destroy = function destroy() {
			var device = this.device;
			if (device) {
				var idx = device.textures.indexOf(this);
				if (idx !== -1) {
					device.textures.splice(idx, 1);
				}
				device.scope.removeValue(this);
				this.impl.destroy(device);
				this.adjustVramSizeTracking(device._vram, -this._gpuSize);
				this._levels = null;
				this.device = null;
			}
		};
		_proto.resize = function resize(width, height, depth) {
			if (depth === void 0) {
				depth = 1;
			}
			var device = this.device;
			this.adjustVramSizeTracking(device._vram, -this._gpuSize);
			this.impl.destroy(device);
			this._width = Math.floor(width);
			this._height = Math.floor(height);
			this._depth = Math.floor(depth);
			this.impl = device.createTextureImpl(this);
			this.dirtyAll();
		};
		_proto.loseContext = function loseContext() {
			this.impl.loseContext();
			this.dirtyAll();
		};
		_proto.adjustVramSizeTracking = function adjustVramSizeTracking(vram, size) {
			vram.tex += size;
		};
		_proto.propertyChanged = function propertyChanged(flag) {
			this.impl.propertyChanged(flag);
			this.renderVersionDirty = this.device.renderVersion;
		};
		_proto.dirtyAll = function dirtyAll() {
			this._levelsUpdated = this._cubemap ? [[true, true, true, true, true, true]] : [true];
			this._needsUpload = true;
			this._needsMipmapsUpload = this._mipmaps;
			this._mipmapsUploaded = false;
			this.propertyChanged(255);
		};
		_proto.lock = function lock(options) {
			if (options === void 0) {
				options = {};
			}
			if (options.level === undefined) {
				options.level = 0;
			}
			if (options.face === undefined) {
				options.face = 0;
			}
			if (options.mode === undefined) {
				options.mode = TEXTURELOCK_WRITE;
			}
			this._lockedLevel = options.level;
			var levels = this.cubemap ? this._levels[options.face] : this._levels;
			if (levels[options.level] === null) {
				var width = Math.max(1, this._width >> options.level);
				var height = Math.max(1, this._height >> options.level);
				var depth = Math.max(1, this._depth >> options.level);
				var data = new ArrayBuffer(TextureUtils.calcLevelGpuSize(width, height, depth, this._format));
				levels[options.level] = new (getPixelFormatArrayType(this._format))(data);
			}
			return levels[options.level];
		};
		_proto.setSource = function setSource(source, mipLevel) {
			if (mipLevel === void 0) {
				mipLevel = 0;
			}
			var invalid = false;
			var width, height;
			if (this._cubemap) {
				if (source[0]) {
					width = source[0].width || 0;
					height = source[0].height || 0;
					for (var i = 0; i < 6; i++) {
						var face = source[i];
						if (!face || face.width !== width || face.height !== height || !this.device._isBrowserInterface(face)) {
							invalid = true;
							break;
						}
					}
				} else {
					invalid = true;
				}
				if (!invalid) {
					for (var _i = 0; _i < 6; _i++) {
						if (this._levels[mipLevel][_i] !== source[_i]) this._levelsUpdated[mipLevel][_i] = true;
					}
				}
			} else {
				if (!this.device._isBrowserInterface(source)) invalid = true;
				if (!invalid) {
					if (source !== this._levels[mipLevel]) this._levelsUpdated[mipLevel] = true;
					width = source.width;
					height = source.height;
				}
			}
			if (invalid) {
				this._width = 4;
				this._height = 4;
				if (this._cubemap) {
					for (var _i2 = 0; _i2 < 6; _i2++) {
						this._levels[mipLevel][_i2] = null;
						this._levelsUpdated[mipLevel][_i2] = true;
					}
				} else {
					this._levels[mipLevel] = null;
					this._levelsUpdated[mipLevel] = true;
				}
			} else {
				if (mipLevel === 0) {
					this._width = width;
					this._height = height;
				}
				this._levels[mipLevel] = source;
			}
			if (this._invalid !== invalid || !invalid) {
				this._invalid = invalid;
				this.upload();
			}
		};
		_proto.getSource = function getSource(mipLevel) {
			if (mipLevel === void 0) {
				mipLevel = 0;
			}
			return this._levels[mipLevel];
		};
		_proto.unlock = function unlock() {
			if (this._lockedLevel === -1) ;
			this.upload();
			this._lockedLevel = -1;
		};
		_proto.upload = function upload() {
			var _this$impl$uploadImme, _this$impl;
			this._needsUpload = true;
			this._needsMipmapsUpload = this._mipmaps;
			(_this$impl$uploadImme = (_this$impl = this.impl).uploadImmediate) == null || _this$impl$uploadImme.call(_this$impl, this.device, this);
		};
		_proto.downloadAsync = function () {
			var _downloadAsync = _asyncToGenerator(_regeneratorRuntime().mark(function _callee() {
				var _this = this;
				var promises, _loop, i;
				return _regeneratorRuntime().wrap(function _callee$(_context2) {
					while (1) switch (_context2.prev = _context2.next) {
						case 0:
							promises = [];
							_loop = _regeneratorRuntime().mark(function _loop() {
								var renderTarget, levels, level, promise;
								return _regeneratorRuntime().wrap(function _loop$(_context) {
									while (1) switch (_context.prev = _context.next) {
										case 0:
											renderTarget = new RenderTarget({
												colorBuffer: _this,
												depth: false,
												face: i
											});
											_this.device.setRenderTarget(renderTarget);
											_this.device.initRenderTarget(renderTarget);
											levels = _this.cubemap ? _this._levels[i] : _this._levels;
											level = levels[0];
											if (levels[0] && _this.device._isBrowserInterface(levels[0])) {
												levels[0] = null;
											}
											level = _this.lock({
												face: i
											});
											promise = _this.device.readPixelsAsync == null ? void 0 : _this.device.readPixelsAsync(0, 0, _this.width, _this.height, level).then(function () {
												return renderTarget.destroy();
											});
											promises.push(promise);
										case 9:
										case "end":
											return _context.stop();
									}
								}, _loop);
							});
							i = 0;
						case 3:
							if (!(i < (this.cubemap ? 6 : 1))) {
								_context2.next = 8;
								break;
							}
							return _context2.delegateYield(_loop(), "t0", 5);
						case 5:
							i++;
							_context2.next = 3;
							break;
						case 8:
							_context2.next = 10;
							return Promise.all(promises);
						case 10:
						case "end":
							return _context2.stop();
					}
				}, _callee, this);
			}));
			function downloadAsync() {
				return _downloadAsync.apply(this, arguments);
			}
			return downloadAsync;
		}();
		_createClass(Texture, [{
			key: "requiredMipLevels",
			get: function get() {
				return this.mipmaps ? TextureUtils.calcMipLevelsCount(this.width, this.height) : 1;
			}
		}, {
			key: "minFilter",
			get: function get() {
				return this._minFilter;
			},
			set: function set(v) {
				if (this._minFilter !== v) {
					this._minFilter = v;
					this.propertyChanged(1);
				}
			}
		}, {
			key: "magFilter",
			get: function get() {
				return this._magFilter;
			},
			set: function set(v) {
				if (this._magFilter !== v) {
					this._magFilter = v;
					this.propertyChanged(2);
				}
			}
		}, {
			key: "addressU",
			get: function get() {
				return this._addressU;
			},
			set: function set(v) {
				if (this._addressU !== v) {
					this._addressU = v;
					this.propertyChanged(4);
				}
			}
		}, {
			key: "addressV",
			get: function get() {
				return this._addressV;
			},
			set: function set(v) {
				if (this._addressV !== v) {
					this._addressV = v;
					this.propertyChanged(8);
				}
			}
		}, {
			key: "addressW",
			get: function get() {
				return this._addressW;
			},
			set: function set(addressW) {
				if (!this.device.supportsVolumeTextures) return;
				if (!this._volume) {
					return;
				}
				if (addressW !== this._addressW) {
					this._addressW = addressW;
					this.propertyChanged(16);
				}
			}
		}, {
			key: "compareOnRead",
			get: function get() {
				return this._compareOnRead;
			},
			set: function set(v) {
				if (this._compareOnRead !== v) {
					this._compareOnRead = v;
					this.propertyChanged(32);
				}
			}
		}, {
			key: "compareFunc",
			get: function get() {
				return this._compareFunc;
			},
			set: function set(v) {
				if (this._compareFunc !== v) {
					this._compareFunc = v;
					this.propertyChanged(64);
				}
			}
		}, {
			key: "anisotropy",
			get: function get() {
				return this._anisotropy;
			},
			set: function set(v) {
				if (this._anisotropy !== v) {
					this._anisotropy = v;
					this.propertyChanged(128);
				}
			}
		}, {
			key: "mipmaps",
			get: function get() {
				return this._mipmaps;
			},
			set: function set(v) {
				if (this._mipmaps !== v) {
					this._mipmaps = v;
					if (this.device.isWebGPU) ;
					if (v) this._needsMipmapsUpload = true;
				}
			}
		}, {
			key: "storage",
			get: function get() {
				return this._storage;
			}
		}, {
			key: "width",
			get: function get() {
				return this._width;
			}
		}, {
			key: "height",
			get: function get() {
				return this._height;
			}
		}, {
			key: "depth",
			get: function get() {
				return this._depth;
			}
		}, {
			key: "format",
			get: function get() {
				return this._format;
			}
		}, {
			key: "cubemap",
			get: function get() {
				return this._cubemap;
			}
		}, {
			key: "gpuSize",
			get: function get() {
				var mips = this.pot && this._mipmaps && !(this._compressed && this._levels.length === 1);
				return TextureUtils.calcGpuSize(this._width, this._height, this._depth, this._format, mips, this._cubemap);
			}
		}, {
			key: "array",
			get: function get() {
				return this._arrayLength > 0;
			}
		}, {
			key: "arrayLength",
			get: function get() {
				return this._arrayLength;
			}
		}, {
			key: "volume",
			get: function get() {
				return this._volume;
			}
		}, {
			key: "flipY",
			get: function get() {
				return this._flipY;
			},
			set: function set(flipY) {
				if (this._flipY !== flipY) {
					this._flipY = flipY;
					this._needsUpload = true;
				}
			}
		}, {
			key: "premultiplyAlpha",
			get: function get() {
				return this._premultiplyAlpha;
			},
			set: function set(premultiplyAlpha) {
				if (this._premultiplyAlpha !== premultiplyAlpha) {
					this._premultiplyAlpha = premultiplyAlpha;
					this._needsUpload = true;
				}
			}
		}, {
			key: "pot",
			get: function get() {
				return math.powerOfTwo(this._width) && math.powerOfTwo(this._height);
			}
		}, {
			key: "encoding",
			get: function get() {
				switch (this.type) {
					case TEXTURETYPE_RGBM:
						return 'rgbm';
					case TEXTURETYPE_RGBE:
						return 'rgbe';
					case TEXTURETYPE_RGBP:
						return 'rgbp';
					default:
						return this.format === PIXELFORMAT_RGB16F || this.format === PIXELFORMAT_RGB32F || this.format === PIXELFORMAT_RGBA16F || this.format === PIXELFORMAT_RGBA32F ? 'linear' : 'srgb';
				}
			}
		}]);
		return Texture;
	}();

	var WebglBuffer = function () {
		function WebglBuffer() {
			this.bufferId = null;
		}
		var _proto = WebglBuffer.prototype;
		_proto.destroy = function destroy(device) {
			if (this.bufferId) {
				device.gl.deleteBuffer(this.bufferId);
				this.bufferId = null;
			}
		};
		_proto.loseContext = function loseContext() {
			this.bufferId = null;
		};
		_proto.unlock = function unlock(device, usage, target, storage) {
			var gl = device.gl;
			if (!this.bufferId) {
				var glUsage;
				switch (usage) {
					case BUFFER_STATIC:
						glUsage = gl.STATIC_DRAW;
						break;
					case BUFFER_DYNAMIC:
						glUsage = gl.DYNAMIC_DRAW;
						break;
					case BUFFER_STREAM:
						glUsage = gl.STREAM_DRAW;
						break;
					case BUFFER_GPUDYNAMIC:
						glUsage = device.isWebGL2 ? gl.DYNAMIC_COPY : gl.STATIC_DRAW;
						break;
				}
				this.bufferId = gl.createBuffer();
				gl.bindBuffer(target, this.bufferId);
				gl.bufferData(target, storage, glUsage);
			} else {
				gl.bindBuffer(target, this.bufferId);
				gl.bufferSubData(target, 0, storage);
			}
		};
		_createClass(WebglBuffer, [{
			key: "initialized",
			get: function get() {
				return !!this.bufferId;
			}
		}]);
		return WebglBuffer;
	}();

	var WebglVertexBuffer = function (_WebglBuffer) {
		_inheritsLoose(WebglVertexBuffer, _WebglBuffer);
		function WebglVertexBuffer() {
			var _this;
			for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}
			_this = _WebglBuffer.call.apply(_WebglBuffer, [this].concat(args)) || this;
			_this.vao = null;
			return _this;
		}
		var _proto = WebglVertexBuffer.prototype;
		_proto.destroy = function destroy(device) {
			_WebglBuffer.prototype.destroy.call(this, device);
			device.boundVao = null;
			device.gl.bindVertexArray(null);
		};
		_proto.loseContext = function loseContext() {
			_WebglBuffer.prototype.loseContext.call(this);
			this.vao = null;
		};
		_proto.unlock = function unlock(vertexBuffer) {
			var device = vertexBuffer.device;
			_WebglBuffer.prototype.unlock.call(this, device, vertexBuffer.usage, device.gl.ARRAY_BUFFER, vertexBuffer.storage);
		};
		return WebglVertexBuffer;
	}(WebglBuffer);

	var WebglIndexBuffer = function (_WebglBuffer) {
		_inheritsLoose(WebglIndexBuffer, _WebglBuffer);
		function WebglIndexBuffer(indexBuffer) {
			var _this;
			_this = _WebglBuffer.call(this) || this;
			var gl = indexBuffer.device.gl;
			var format = indexBuffer.format;
			if (format === INDEXFORMAT_UINT8) {
				_this.glFormat = gl.UNSIGNED_BYTE;
			} else if (format === INDEXFORMAT_UINT16) {
				_this.glFormat = gl.UNSIGNED_SHORT;
			} else if (format === INDEXFORMAT_UINT32) {
				_this.glFormat = gl.UNSIGNED_INT;
			}
			return _this;
		}
		var _proto = WebglIndexBuffer.prototype;
		_proto.unlock = function unlock(indexBuffer) {
			var device = indexBuffer.device;
			_WebglBuffer.prototype.unlock.call(this, device, indexBuffer.usage, device.gl.ELEMENT_ARRAY_BUFFER, indexBuffer.storage);
		};
		return WebglIndexBuffer;
	}(WebglBuffer);

	var WebglShaderInput = function WebglShaderInput(graphicsDevice, name, type, locationId) {
		this.locationId = locationId;
		this.scopeId = graphicsDevice.scope.resolve(name);
		this.version = new Version();
		if (name.substring(name.length - 3) === "[0]") {
			switch (type) {
				case UNIFORMTYPE_FLOAT:
					type = UNIFORMTYPE_FLOATARRAY;
					break;
				case UNIFORMTYPE_VEC2:
					type = UNIFORMTYPE_VEC2ARRAY;
					break;
				case UNIFORMTYPE_VEC3:
					type = UNIFORMTYPE_VEC3ARRAY;
					break;
				case UNIFORMTYPE_VEC4:
					type = UNIFORMTYPE_VEC4ARRAY;
					break;
			}
		}
		this.dataType = type;
		this.value = [null, null, null, null];
		this.array = [];
	};

	var DeviceCache = function () {
		function DeviceCache() {
			this._cache = new Map();
		}
		var _proto = DeviceCache.prototype;
		_proto.get = function get(device, onCreate) {
			var _this = this;
			if (!this._cache.has(device)) {
				this._cache.set(device, onCreate());
				device.on('destroy', function () {
					_this.remove(device);
				});
				device.on('devicelost', function () {
					var _this$_cache$get;
					(_this$_cache$get = _this._cache.get(device)) == null || _this$_cache$get.loseContext == null || _this$_cache$get.loseContext(device);
				});
			}
			return this._cache.get(device);
		};
		_proto.remove = function remove(device) {
			var _this$_cache$get2;
			(_this$_cache$get2 = this._cache.get(device)) == null || _this$_cache$get2.destroy == null || _this$_cache$get2.destroy(device);
			this._cache.delete(device);
		};
		return DeviceCache;
	}();

	var _vertexShaderBuiltins = ['gl_VertexID', 'gl_InstanceID', 'gl_DrawID', 'gl_BaseVertex', 'gl_BaseInstance'];
	var CompiledShaderCache = function () {
		function CompiledShaderCache() {
			this.map = new Map();
		}
		var _proto = CompiledShaderCache.prototype;
		_proto.destroy = function destroy(device) {
			this.map.forEach(function (shader) {
				device.gl.deleteShader(shader);
			});
		};
		_proto.loseContext = function loseContext(device) {
			this.map.clear();
		};
		return CompiledShaderCache;
	}();
	var ShaderBatchCache = function () {
		function ShaderBatchCache() {
			this.shaders = [];
		}
		var _proto2 = ShaderBatchCache.prototype;
		_proto2.loseContext = function loseContext(device) {
			this.shaders = [];
		};
		return ShaderBatchCache;
	}();
	var _vertexShaderCache = new DeviceCache();
	var _fragmentShaderCache = new DeviceCache();
	var _shaderBatchCache = new DeviceCache();
	var WebglShader = function () {
		function WebglShader(shader) {
			this.compileDuration = 0;
			this.init();
			this.compile(shader.device, shader);
			WebglShader.getBatchShaders(shader.device).push(shader);
			shader.device.shaders.push(shader);
		}
		var _proto3 = WebglShader.prototype;
		_proto3.destroy = function destroy(shader) {
			if (this.glProgram) {
				shader.device.gl.deleteProgram(this.glProgram);
				this.glProgram = null;
			}
		};
		_proto3.init = function init() {
			this.uniforms = [];
			this.samplers = [];
			this.attributes = [];
			this.glProgram = null;
			this.glVertexShader = null;
			this.glFragmentShader = null;
		};
		WebglShader.getBatchShaders = function getBatchShaders(device) {
			var batchCache = _shaderBatchCache.get(device, function () {
				return new ShaderBatchCache();
			});
			return batchCache.shaders;
		};
		WebglShader.endShaderBatch = function endShaderBatch(device) {
			var shaders = WebglShader.getBatchShaders(device);
			shaders.forEach(function (shader) {
				return shader.impl.link(device, shader);
			});
			shaders.length = 0;
		};
		_proto3.loseContext = function loseContext() {
			this.init();
		};
		_proto3.restoreContext = function restoreContext(device, shader) {
			this.compile(device, shader);
		};
		_proto3.compile = function compile(device, shader) {
			var definition = shader.definition;
			this.glVertexShader = this._compileShaderSource(device, definition.vshader, true);
			this.glFragmentShader = this._compileShaderSource(device, definition.fshader, false);
		};
		_proto3.link = function link(device, shader) {
			if (this.glProgram) return;
			var gl = device.gl;
			if (gl.isContextLost()) {
				return;
			}
			var glProgram = gl.createProgram();
			this.glProgram = glProgram;
			gl.attachShader(glProgram, this.glVertexShader);
			gl.attachShader(glProgram, this.glFragmentShader);
			var definition = shader.definition;
			var attrs = definition.attributes;
			if (device.isWebGL2 && definition.useTransformFeedback) {
				var outNames = [];
				for (var attr in attrs) {
					if (attrs.hasOwnProperty(attr)) {
						outNames.push("out_" + attr);
					}
				}
				gl.transformFeedbackVaryings(glProgram, outNames, gl.INTERLEAVED_ATTRIBS);
			}
			for (var _attr in attrs) {
				if (attrs.hasOwnProperty(_attr)) {
					var semantic = attrs[_attr];
					var loc = semanticToLocation[semantic];
					gl.bindAttribLocation(glProgram, loc, _attr);
				}
			}
			gl.linkProgram(glProgram);
		};
		_proto3._compileShaderSource = function _compileShaderSource(device, src, isVertexShader) {
			var gl = device.gl;
			var shaderDeviceCache = isVertexShader ? _vertexShaderCache : _fragmentShaderCache;
			var shaderCache = shaderDeviceCache.get(device, function () {
				return new CompiledShaderCache();
			});
			var glShader = shaderCache.map.get(src);
			if (!glShader) {
				glShader = gl.createShader(isVertexShader ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER);
				if (!glShader && gl.isContextLost()) {
					return glShader;
				}
				gl.shaderSource(glShader, src);
				gl.compileShader(glShader);
				shaderCache.map.set(src, glShader);
			}
			return glShader;
		};
		_proto3.finalize = function finalize(device, shader) {
			var gl = device.gl;
			if (gl.isContextLost()) {
				return true;
			}
			if (!this.glProgram) this.link(device, shader);
			var glProgram = this.glProgram;
			var definition = shader.definition;
			var linkStatus = gl.getProgramParameter(glProgram, gl.LINK_STATUS);
			if (!linkStatus) {
				if (!this._isCompiled(device, shader, this.glVertexShader, definition.vshader, "vertex")) return false;
				if (!this._isCompiled(device, shader, this.glFragmentShader, definition.fshader, "fragment")) return false;
				var message = "Failed to link shader program. Error: " + gl.getProgramInfoLog(glProgram);
				console.error(message);
				return false;
			}
			var i = 0;
			var numAttributes = gl.getProgramParameter(glProgram, gl.ACTIVE_ATTRIBUTES);
			while (i < numAttributes) {
				var info = gl.getActiveAttrib(glProgram, i++);
				var location = gl.getAttribLocation(glProgram, info.name);
				if (_vertexShaderBuiltins.indexOf(info.name) !== -1) continue;
				if (definition.attributes[info.name] === undefined) {
					console.error("Vertex shader attribute \"" + info.name + "\" is not mapped to a semantic in shader definition, shader [" + shader.label + "]", shader);
					shader.failed = true;
				} else {
					var shaderInput = new WebglShaderInput(device, definition.attributes[info.name], device.pcUniformType[info.type], location);
					this.attributes.push(shaderInput);
				}
			}
			i = 0;
			var numUniforms = gl.getProgramParameter(glProgram, gl.ACTIVE_UNIFORMS);
			while (i < numUniforms) {
				var _info = gl.getActiveUniform(glProgram, i++);
				var _location = gl.getUniformLocation(glProgram, _info.name);
				var _shaderInput = new WebglShaderInput(device, _info.name, device.pcUniformType[_info.type], _location);
				if (_info.type === gl.SAMPLER_2D || _info.type === gl.SAMPLER_CUBE || device.isWebGL2 && (_info.type === gl.SAMPLER_2D_SHADOW || _info.type === gl.SAMPLER_CUBE_SHADOW || _info.type === gl.SAMPLER_3D || _info.type === gl.SAMPLER_2D_ARRAY)) {
					this.samplers.push(_shaderInput);
				} else {
					this.uniforms.push(_shaderInput);
				}
			}
			shader.ready = true;
			return true;
		};
		_proto3._isCompiled = function _isCompiled(device, shader, glShader, source, shaderType) {
			var gl = device.gl;
			if (!gl.getShaderParameter(glShader, gl.COMPILE_STATUS)) {
				var infoLog = gl.getShaderInfoLog(glShader);
				var _this$_processError = this._processError(source, infoLog),
					code = _this$_processError[0];
					_this$_processError[1];
				var message = "Failed to compile " + shaderType + " shader:\n\n" + infoLog + "\n" + code;
				console.error(message);
				return false;
			}
			return true;
		};
		_proto3._processError = function _processError(src, infoLog) {
			var error = {};
			var code = '';
			if (src) {
				var lines = src.split('\n');
				var from = 0;
				var to = lines.length;
				if (infoLog && infoLog.startsWith('ERROR:')) {
					var match = infoLog.match(/^ERROR:\s([0-9]+):([0-9]+):\s*(.+)/);
					if (match) {
						error.message = match[3];
						error.line = parseInt(match[2], 10);
						from = Math.max(0, error.line - 6);
						to = Math.min(lines.length, error.line + 5);
					}
				}
				for (var i = from; i < to; i++) {
					code += i + 1 + ":\t" + lines[i] + '\n';
				}
				error.source = src;
			}
			return [code, error];
		};
		return WebglShader;
	}();

	function downsampleImage(image, size) {
		var srcW = image.width;
		var srcH = image.height;
		if (srcW > size || srcH > size) {
			var scale = size / Math.max(srcW, srcH);
			var dstW = Math.floor(srcW * scale);
			var dstH = Math.floor(srcH * scale);
			var canvas = document.createElement('canvas');
			canvas.width = dstW;
			canvas.height = dstH;
			var context = canvas.getContext('2d');
			context.drawImage(image, 0, 0, srcW, srcH, 0, 0, dstW, dstH);
			return canvas;
		}
		return image;
	}
	var WebglTexture = function () {
		function WebglTexture() {
			this._glTexture = null;
			this._glTarget = void 0;
			this._glFormat = void 0;
			this._glInternalFormat = void 0;
			this._glPixelType = void 0;
			this._glCreated = void 0;
			this.dirtyParameterFlags = 0;
		}
		var _proto = WebglTexture.prototype;
		_proto.destroy = function destroy(device) {
			if (this._glTexture) {
				for (var i = 0; i < device.textureUnits.length; i++) {
					var textureUnit = device.textureUnits[i];
					for (var j = 0; j < textureUnit.length; j++) {
						if (textureUnit[j] === this._glTexture) {
							textureUnit[j] = null;
						}
					}
				}
				device.gl.deleteTexture(this._glTexture);
				this._glTexture = null;
			}
		};
		_proto.loseContext = function loseContext() {
			this._glTexture = null;
		};
		_proto.propertyChanged = function propertyChanged(flag) {
			this.dirtyParameterFlags |= flag;
		};
		_proto.initialize = function initialize(device, texture) {
			var gl = device.gl;
			this._glTexture = gl.createTexture();
			this._glTarget = texture._cubemap ? gl.TEXTURE_CUBE_MAP : texture._volume ? gl.TEXTURE_3D : texture.array ? gl.TEXTURE_2D_ARRAY : gl.TEXTURE_2D;
			switch (texture._format) {
				case PIXELFORMAT_A8:
					this._glFormat = gl.ALPHA;
					this._glInternalFormat = gl.ALPHA;
					this._glPixelType = gl.UNSIGNED_BYTE;
					break;
				case PIXELFORMAT_L8:
					this._glFormat = gl.LUMINANCE;
					this._glInternalFormat = gl.LUMINANCE;
					this._glPixelType = gl.UNSIGNED_BYTE;
					break;
				case PIXELFORMAT_LA8:
					this._glFormat = gl.LUMINANCE_ALPHA;
					this._glInternalFormat = gl.LUMINANCE_ALPHA;
					this._glPixelType = gl.UNSIGNED_BYTE;
					break;
				case PIXELFORMAT_RGB565:
					this._glFormat = gl.RGB;
					this._glInternalFormat = gl.RGB;
					this._glPixelType = gl.UNSIGNED_SHORT_5_6_5;
					break;
				case PIXELFORMAT_RGBA5551:
					this._glFormat = gl.RGBA;
					this._glInternalFormat = gl.RGBA;
					this._glPixelType = gl.UNSIGNED_SHORT_5_5_5_1;
					break;
				case PIXELFORMAT_RGBA4:
					this._glFormat = gl.RGBA;
					this._glInternalFormat = gl.RGBA;
					this._glPixelType = gl.UNSIGNED_SHORT_4_4_4_4;
					break;
				case PIXELFORMAT_RGB8:
					this._glFormat = gl.RGB;
					this._glInternalFormat = device.isWebGL2 ? gl.RGB8 : gl.RGB;
					this._glPixelType = gl.UNSIGNED_BYTE;
					break;
				case PIXELFORMAT_RGBA8:
					this._glFormat = gl.RGBA;
					this._glInternalFormat = device.isWebGL2 ? gl.RGBA8 : gl.RGBA;
					this._glPixelType = gl.UNSIGNED_BYTE;
					break;
				case PIXELFORMAT_DXT1:
					this._glFormat = gl.RGB;
					this._glInternalFormat = device.extCompressedTextureS3TC.COMPRESSED_RGB_S3TC_DXT1_EXT;
					break;
				case PIXELFORMAT_DXT3:
					this._glFormat = gl.RGBA;
					this._glInternalFormat = device.extCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT3_EXT;
					break;
				case PIXELFORMAT_DXT5:
					this._glFormat = gl.RGBA;
					this._glInternalFormat = device.extCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT5_EXT;
					break;
				case PIXELFORMAT_ETC1:
					this._glFormat = gl.RGB;
					this._glInternalFormat = device.extCompressedTextureETC1.COMPRESSED_RGB_ETC1_WEBGL;
					break;
				case PIXELFORMAT_PVRTC_2BPP_RGB_1:
					this._glFormat = gl.RGB;
					this._glInternalFormat = device.extCompressedTexturePVRTC.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
					break;
				case PIXELFORMAT_PVRTC_2BPP_RGBA_1:
					this._glFormat = gl.RGBA;
					this._glInternalFormat = device.extCompressedTexturePVRTC.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
					break;
				case PIXELFORMAT_PVRTC_4BPP_RGB_1:
					this._glFormat = gl.RGB;
					this._glInternalFormat = device.extCompressedTexturePVRTC.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
					break;
				case PIXELFORMAT_PVRTC_4BPP_RGBA_1:
					this._glFormat = gl.RGBA;
					this._glInternalFormat = device.extCompressedTexturePVRTC.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
					break;
				case PIXELFORMAT_ETC2_RGB:
					this._glFormat = gl.RGB;
					this._glInternalFormat = device.extCompressedTextureETC.COMPRESSED_RGB8_ETC2;
					break;
				case PIXELFORMAT_ETC2_RGBA:
					this._glFormat = gl.RGBA;
					this._glInternalFormat = device.extCompressedTextureETC.COMPRESSED_RGBA8_ETC2_EAC;
					break;
				case PIXELFORMAT_ASTC_4x4:
					this._glFormat = gl.RGBA;
					this._glInternalFormat = device.extCompressedTextureASTC.COMPRESSED_RGBA_ASTC_4x4_KHR;
					break;
				case PIXELFORMAT_ATC_RGB:
					this._glFormat = gl.RGB;
					this._glInternalFormat = device.extCompressedTextureATC.COMPRESSED_RGB_ATC_WEBGL;
					break;
				case PIXELFORMAT_ATC_RGBA:
					this._glFormat = gl.RGBA;
					this._glInternalFormat = device.extCompressedTextureATC.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL;
					break;
				case PIXELFORMAT_RGB16F:
					this._glFormat = gl.RGB;
					if (device.isWebGL2) {
						this._glInternalFormat = gl.RGB16F;
						this._glPixelType = gl.HALF_FLOAT;
					} else {
						this._glInternalFormat = gl.RGB;
						this._glPixelType = device.extTextureHalfFloat.HALF_FLOAT_OES;
					}
					break;
				case PIXELFORMAT_RGBA16F:
					this._glFormat = gl.RGBA;
					if (device.isWebGL2) {
						this._glInternalFormat = gl.RGBA16F;
						this._glPixelType = gl.HALF_FLOAT;
					} else {
						this._glInternalFormat = gl.RGBA;
						this._glPixelType = device.extTextureHalfFloat.HALF_FLOAT_OES;
					}
					break;
				case PIXELFORMAT_RGB32F:
					this._glFormat = gl.RGB;
					if (device.isWebGL2) {
						this._glInternalFormat = gl.RGB32F;
					} else {
						this._glInternalFormat = gl.RGB;
					}
					this._glPixelType = gl.FLOAT;
					break;
				case PIXELFORMAT_RGBA32F:
					this._glFormat = gl.RGBA;
					if (device.isWebGL2) {
						this._glInternalFormat = gl.RGBA32F;
					} else {
						this._glInternalFormat = gl.RGBA;
					}
					this._glPixelType = gl.FLOAT;
					break;
				case PIXELFORMAT_R32F:
					this._glFormat = gl.RED;
					this._glInternalFormat = gl.R32F;
					this._glPixelType = gl.FLOAT;
					break;
				case PIXELFORMAT_DEPTH:
					if (device.isWebGL2) {
						this._glFormat = gl.DEPTH_COMPONENT;
						this._glInternalFormat = gl.DEPTH_COMPONENT32F;
						this._glPixelType = gl.FLOAT;
					} else {
						this._glFormat = gl.DEPTH_COMPONENT;
						this._glInternalFormat = gl.DEPTH_COMPONENT;
						this._glPixelType = gl.UNSIGNED_SHORT;
					}
					break;
				case PIXELFORMAT_DEPTHSTENCIL:
					this._glFormat = gl.DEPTH_STENCIL;
					if (device.isWebGL2) {
						this._glInternalFormat = gl.DEPTH24_STENCIL8;
						this._glPixelType = gl.UNSIGNED_INT_24_8;
					} else {
						this._glInternalFormat = gl.DEPTH_STENCIL;
						this._glPixelType = device.extDepthTexture.UNSIGNED_INT_24_8_WEBGL;
					}
					break;
				case PIXELFORMAT_111110F:
					this._glFormat = gl.RGB;
					this._glInternalFormat = gl.R11F_G11F_B10F;
					this._glPixelType = gl.UNSIGNED_INT_10F_11F_11F_REV;
					break;
				case PIXELFORMAT_SRGB:
					this._glFormat = gl.RGB;
					this._glInternalFormat = gl.SRGB8;
					this._glPixelType = gl.UNSIGNED_BYTE;
					break;
				case PIXELFORMAT_SRGBA:
					this._glFormat = gl.RGBA;
					this._glInternalFormat = gl.SRGB8_ALPHA8;
					this._glPixelType = gl.UNSIGNED_BYTE;
					break;
			}
			this._glCreated = false;
		};
		_proto.upload = function upload(device, texture) {
			var gl = device.gl;
			if (!texture._needsUpload && (texture._needsMipmapsUpload && texture._mipmapsUploaded || !texture.pot)) return;
			var mipLevel = 0;
			var mipObject;
			var resMult;
			var requiredMipLevels = texture.requiredMipLevels;
			if (texture.array) {
				gl.texStorage3D(gl.TEXTURE_2D_ARRAY, requiredMipLevels, this._glInternalFormat, texture._width, texture._height, texture._arrayLength);
			}
			while (texture._levels[mipLevel] || mipLevel === 0) {
				if (!texture._needsUpload && mipLevel === 0) {
					mipLevel++;
					continue;
				} else if (mipLevel && (!texture._needsMipmapsUpload || !texture._mipmaps)) {
					break;
				}
				mipObject = texture._levels[mipLevel];
				resMult = 1 / Math.pow(2, mipLevel);
				if (mipLevel === 1 && !texture._compressed && texture._levels.length < requiredMipLevels) {
					gl.generateMipmap(this._glTarget);
					texture._mipmapsUploaded = true;
				}
				if (texture._cubemap) {
					var face = void 0;
					if (device._isBrowserInterface(mipObject[0])) {
						for (face = 0; face < 6; face++) {
							if (!texture._levelsUpdated[0][face]) continue;
							var src = mipObject[face];
							if (device._isImageBrowserInterface(src)) {
								if (src.width > device.maxCubeMapSize || src.height > device.maxCubeMapSize) {
									src = downsampleImage(src, device.maxCubeMapSize);
									if (mipLevel === 0) {
										texture._width = src.width;
										texture._height = src.height;
									}
								}
							}
							device.setUnpackFlipY(false);
							device.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
							if (this._glCreated) {
								gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, 0, 0, this._glFormat, this._glPixelType, src);
							} else {
								gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, this._glInternalFormat, this._glFormat, this._glPixelType, src);
							}
						}
					} else {
						resMult = 1 / Math.pow(2, mipLevel);
						for (face = 0; face < 6; face++) {
							if (!texture._levelsUpdated[0][face]) continue;
							var texData = mipObject[face];
							if (texture._compressed) {
								if (this._glCreated && texData) {
									gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, 0, 0, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), this._glInternalFormat, texData);
								} else {
									gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, this._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), 0, texData);
								}
							} else {
								device.setUnpackFlipY(false);
								device.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
								if (this._glCreated && texData) {
									gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, 0, 0, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), this._glFormat, this._glPixelType, texData);
								} else {
									gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, this._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), 0, this._glFormat, this._glPixelType, texData);
								}
							}
						}
					}
				} else if (texture._volume) {
					if (texture._compressed) {
						gl.compressedTexImage3D(gl.TEXTURE_3D, mipLevel, this._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), Math.max(texture._depth * resMult, 1), 0, mipObject);
					} else {
						device.setUnpackFlipY(false);
						device.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
						gl.texImage3D(gl.TEXTURE_3D, mipLevel, this._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), Math.max(texture._depth * resMult, 1), 0, this._glFormat, this._glPixelType, mipObject);
					}
				} else if (texture.array && typeof mipObject === "object") {
					if (texture._arrayLength === mipObject.length) {
						if (texture._compressed) {
							for (var index = 0; index < texture._arrayLength; index++) {
								gl.compressedTexSubImage3D(gl.TEXTURE_2D_ARRAY, mipLevel, 0, 0, index, Math.max(Math.floor(texture._width * resMult), 1), Math.max(Math.floor(texture._height * resMult), 1), 1, this._glFormat, mipObject[index]);
							}
						} else {
							for (var _index = 0; _index < texture._arrayLength; _index++) {
								gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, mipLevel, 0, 0, _index, Math.max(Math.floor(texture._width * resMult), 1), Math.max(Math.floor(texture._height * resMult), 1), 1, this._glFormat, this._glPixelType, mipObject[_index]);
							}
						}
					}
				} else {
					if (device._isBrowserInterface(mipObject)) {
						if (device._isImageBrowserInterface(mipObject)) {
							if (mipObject.width > device.maxTextureSize || mipObject.height > device.maxTextureSize) {
								mipObject = downsampleImage(mipObject, device.maxTextureSize);
								if (mipLevel === 0) {
									texture._width = mipObject.width;
									texture._height = mipObject.height;
								}
							}
						}
						var w = mipObject.width || mipObject.videoWidth;
						var h = mipObject.height || mipObject.videoHeight;
						device.setUnpackFlipY(texture._flipY);
						device.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
						if (this._glCreated && texture._width === w && texture._height === h) {
							gl.texSubImage2D(gl.TEXTURE_2D, mipLevel, 0, 0, this._glFormat, this._glPixelType, mipObject);
						} else {
							gl.texImage2D(gl.TEXTURE_2D, mipLevel, this._glInternalFormat, this._glFormat, this._glPixelType, mipObject);
							if (mipLevel === 0) {
								texture._width = w;
								texture._height = h;
							}
						}
					} else {
						resMult = 1 / Math.pow(2, mipLevel);
						if (texture._compressed) {
							if (this._glCreated && mipObject) {
								gl.compressedTexSubImage2D(gl.TEXTURE_2D, mipLevel, 0, 0, Math.max(Math.floor(texture._width * resMult), 1), Math.max(Math.floor(texture._height * resMult), 1), this._glInternalFormat, mipObject);
							} else {
								gl.compressedTexImage2D(gl.TEXTURE_2D, mipLevel, this._glInternalFormat, Math.max(Math.floor(texture._width * resMult), 1), Math.max(Math.floor(texture._height * resMult), 1), 0, mipObject);
							}
						} else {
							device.setUnpackFlipY(false);
							device.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
							if (this._glCreated && mipObject) {
								gl.texSubImage2D(gl.TEXTURE_2D, mipLevel, 0, 0, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), this._glFormat, this._glPixelType, mipObject);
							} else {
								gl.texImage2D(gl.TEXTURE_2D, mipLevel, this._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), 0, this._glFormat, this._glPixelType, mipObject);
							}
						}
					}
					if (mipLevel === 0) {
						texture._mipmapsUploaded = false;
					} else {
						texture._mipmapsUploaded = true;
					}
				}
				mipLevel++;
			}
			if (texture._needsUpload) {
				if (texture._cubemap) {
					for (var i = 0; i < 6; i++) texture._levelsUpdated[0][i] = false;
				} else {
					texture._levelsUpdated[0] = false;
				}
			}
			if (!texture._compressed && texture._mipmaps && texture._needsMipmapsUpload && (texture.pot || device.isWebGL2) && texture._levels.length === 1) {
				gl.generateMipmap(this._glTarget);
				texture._mipmapsUploaded = true;
			}
			if (texture._gpuSize) {
				texture.adjustVramSizeTracking(device._vram, -texture._gpuSize);
			}
			texture._gpuSize = texture.gpuSize;
			texture.adjustVramSizeTracking(device._vram, texture._gpuSize);
			this._glCreated = true;
		};
		return WebglTexture;
	}();

	var FramebufferPair = function () {
		function FramebufferPair(msaaFB, resolveFB) {
			this.msaaFB = void 0;
			this.resolveFB = void 0;
			this.msaaFB = msaaFB;
			this.resolveFB = resolveFB;
		}
		var _proto = FramebufferPair.prototype;
		_proto.destroy = function destroy(gl) {
			if (this.msaaFB) {
				gl.deleteRenderbuffer(this.msaaFB);
				this.msaaFB = null;
			}
			if (this.resolveFB) {
				gl.deleteRenderbuffer(this.resolveFB);
				this.resolveFB = null;
			}
		};
		return FramebufferPair;
	}();
	var WebglRenderTarget = function () {
		function WebglRenderTarget() {
			this._glFrameBuffer = null;
			this._glDepthBuffer = null;
			this._glResolveFrameBuffer = null;
			this.colorMrtFramebuffers = null;
			this._glMsaaColorBuffers = [];
			this._glMsaaDepthBuffer = null;
			this.suppliedColorFramebuffer = void 0;
			this._isInitialized = false;
		}
		var _proto2 = WebglRenderTarget.prototype;
		_proto2.destroy = function destroy(device) {
			var _this$colorMrtFramebu;
			var gl = device.gl;
			this._isInitialized = false;
			if (this._glFrameBuffer) {
				if (this._glFrameBuffer !== this.suppliedColorFramebuffer) gl.deleteFramebuffer(this._glFrameBuffer);
				this._glFrameBuffer = null;
			}
			if (this._glDepthBuffer) {
				gl.deleteRenderbuffer(this._glDepthBuffer);
				this._glDepthBuffer = null;
			}
			if (this._glResolveFrameBuffer) {
				if (this._glResolveFrameBuffer !== this.suppliedColorFramebuffer) gl.deleteFramebuffer(this._glResolveFrameBuffer);
				this._glResolveFrameBuffer = null;
			}
			this._glMsaaColorBuffers.forEach(function (buffer) {
				gl.deleteRenderbuffer(buffer);
			});
			this._glMsaaColorBuffers.length = 0;
			(_this$colorMrtFramebu = this.colorMrtFramebuffers) == null || _this$colorMrtFramebu.forEach(function (framebuffer) {
				framebuffer.destroy(gl);
			});
			this.colorMrtFramebuffers = null;
			if (this._glMsaaDepthBuffer) {
				gl.deleteRenderbuffer(this._glMsaaDepthBuffer);
				this._glMsaaDepthBuffer = null;
			}
			this.suppliedColorFramebuffer = undefined;
		};
		_proto2.init = function init(device, target) {
			var gl = device.gl;
			this._isInitialized = true;
			var buffers = [];
			if (this.suppliedColorFramebuffer !== undefined) {
				this._glFrameBuffer = this.suppliedColorFramebuffer;
			} else {
				var _target$_colorBuffers, _target$_colorBuffers2, _device$extDrawBuffer, _device$extDrawBuffer2;
				this._glFrameBuffer = gl.createFramebuffer();
				device.setFramebuffer(this._glFrameBuffer);
				var colorBufferCount = (_target$_colorBuffers = (_target$_colorBuffers2 = target._colorBuffers) == null ? void 0 : _target$_colorBuffers2.length) != null ? _target$_colorBuffers : 0;
				var attachmentBaseConstant = device.isWebGL2 ? gl.COLOR_ATTACHMENT0 : (_device$extDrawBuffer = (_device$extDrawBuffer2 = device.extDrawBuffers) == null ? void 0 : _device$extDrawBuffer2.COLOR_ATTACHMENT0_WEBGL) != null ? _device$extDrawBuffer : gl.COLOR_ATTACHMENT0;
				for (var i = 0; i < colorBufferCount; ++i) {
					var colorBuffer = target.getColorBuffer(i);
					if (colorBuffer) {
						if (!colorBuffer.impl._glTexture) {
							colorBuffer._width = Math.min(colorBuffer.width, device.maxRenderBufferSize);
							colorBuffer._height = Math.min(colorBuffer.height, device.maxRenderBufferSize);
							device.setTexture(colorBuffer, 0);
						}
						gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentBaseConstant + i, colorBuffer._cubemap ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + target._face : gl.TEXTURE_2D, colorBuffer.impl._glTexture, 0);
						buffers.push(attachmentBaseConstant + i);
					}
				}
				if (device.drawBuffers) {
					device.drawBuffers(buffers);
				}
				var depthBuffer = target._depthBuffer;
				if (depthBuffer) {
					if (!depthBuffer.impl._glTexture) {
						depthBuffer._width = Math.min(depthBuffer.width, device.maxRenderBufferSize);
						depthBuffer._height = Math.min(depthBuffer.height, device.maxRenderBufferSize);
						device.setTexture(depthBuffer, 0);
					}
					if (target._stencil) {
						gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, depthBuffer._cubemap ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + target._face : gl.TEXTURE_2D, target._depthBuffer.impl._glTexture, 0);
					} else {
						gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, depthBuffer._cubemap ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + target._face : gl.TEXTURE_2D, target._depthBuffer.impl._glTexture, 0);
					}
				} else if (target._depth) {
					var willRenderMsaa = target._samples > 1 && device.isWebGL2;
					if (!willRenderMsaa) {
						if (!this._glDepthBuffer) {
							this._glDepthBuffer = gl.createRenderbuffer();
						}
						gl.bindRenderbuffer(gl.RENDERBUFFER, this._glDepthBuffer);
						if (target._stencil) {
							gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, target.width, target.height);
							gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, this._glDepthBuffer);
						} else {
							var depthFormat = device.isWebGL2 ? gl.DEPTH_COMPONENT32F : gl.DEPTH_COMPONENT16;
							gl.renderbufferStorage(gl.RENDERBUFFER, depthFormat, target.width, target.height);
							gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this._glDepthBuffer);
						}
						gl.bindRenderbuffer(gl.RENDERBUFFER, null);
					}
				}
			}
			if (device.isWebGL2 && target._samples > 1) {
				var _target$_colorBuffers3, _target$_colorBuffers4;
				this._glResolveFrameBuffer = this._glFrameBuffer;
				this._glFrameBuffer = gl.createFramebuffer();
				device.setFramebuffer(this._glFrameBuffer);
				var _colorBufferCount = (_target$_colorBuffers3 = (_target$_colorBuffers4 = target._colorBuffers) == null ? void 0 : _target$_colorBuffers4.length) != null ? _target$_colorBuffers3 : 0;
				if (this.suppliedColorFramebuffer !== undefined) {
					var buffer = gl.createRenderbuffer();
					this._glMsaaColorBuffers.push(buffer);
					var internalFormat = device.backBufferFormat === PIXELFORMAT_RGBA8 ? gl.RGBA8 : gl.RGB8;
					gl.bindRenderbuffer(gl.RENDERBUFFER, buffer);
					gl.renderbufferStorageMultisample(gl.RENDERBUFFER, target._samples, internalFormat, target.width, target.height);
					gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, buffer);
				} else {
					for (var _i = 0; _i < _colorBufferCount; ++_i) {
						var _colorBuffer = target.getColorBuffer(_i);
						if (_colorBuffer) {
							var _buffer = gl.createRenderbuffer();
							this._glMsaaColorBuffers.push(_buffer);
							gl.bindRenderbuffer(gl.RENDERBUFFER, _buffer);
							gl.renderbufferStorageMultisample(gl.RENDERBUFFER, target._samples, _colorBuffer.impl._glInternalFormat, target.width, target.height);
							gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + _i, gl.RENDERBUFFER, _buffer);
						}
					}
				}
				if (target._depth) {
					if (!this._glMsaaDepthBuffer) {
						this._glMsaaDepthBuffer = gl.createRenderbuffer();
					}
					gl.bindRenderbuffer(gl.RENDERBUFFER, this._glMsaaDepthBuffer);
					if (target._stencil) {
						gl.renderbufferStorageMultisample(gl.RENDERBUFFER, target._samples, gl.DEPTH24_STENCIL8, target.width, target.height);
						gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, this._glMsaaDepthBuffer);
					} else {
						gl.renderbufferStorageMultisample(gl.RENDERBUFFER, target._samples, gl.DEPTH_COMPONENT32F, target.width, target.height);
						gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this._glMsaaDepthBuffer);
					}
				}
				if (_colorBufferCount > 1) {
					this._createMsaaMrtFramebuffers(device, target, _colorBufferCount);
					device.setFramebuffer(this._glFrameBuffer);
					device.drawBuffers(buffers);
				}
			}
		};
		_proto2._createMsaaMrtFramebuffers = function _createMsaaMrtFramebuffers(device, target, colorBufferCount) {
			var gl = device.gl;
			this.colorMrtFramebuffers = [];
			for (var i = 0; i < colorBufferCount; ++i) {
				var colorBuffer = target.getColorBuffer(i);
				var srcFramebuffer = gl.createFramebuffer();
				device.setFramebuffer(srcFramebuffer);
				var buffer = this._glMsaaColorBuffers[i];
				gl.bindRenderbuffer(gl.RENDERBUFFER, buffer);
				gl.renderbufferStorageMultisample(gl.RENDERBUFFER, target._samples, colorBuffer.impl._glInternalFormat, target.width, target.height);
				gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, buffer);
				device.drawBuffers([gl.COLOR_ATTACHMENT0]);
				var dstFramebuffer = gl.createFramebuffer();
				device.setFramebuffer(dstFramebuffer);
				gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, colorBuffer._cubemap ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + target._face : gl.TEXTURE_2D, colorBuffer.impl._glTexture, 0);
				this.colorMrtFramebuffers[i] = new FramebufferPair(srcFramebuffer, dstFramebuffer);
			}
		};
		_proto2._checkFbo = function _checkFbo(device, target, type) {
			var gl = device.gl;
			var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
			switch (status) {
				case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
					break;
				case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
					break;
				case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
					break;
				case gl.FRAMEBUFFER_UNSUPPORTED:
					break;
			}
		};
		_proto2.loseContext = function loseContext() {
			this._glFrameBuffer = null;
			this._glDepthBuffer = null;
			this._glResolveFrameBuffer = null;
			this._glMsaaColorBuffers.length = 0;
			this._glMsaaDepthBuffer = null;
			this.colorMrtFramebuffers = null;
			this.suppliedColorFramebuffer = undefined;
			this._isInitialized = false;
		};
		_proto2.internalResolve = function internalResolve(device, src, dst, target, mask) {
			device.setScissor(0, 0, target.width, target.height);
			var gl = device.gl;
			gl.bindFramebuffer(gl.READ_FRAMEBUFFER, src);
			gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, dst);
			gl.blitFramebuffer(0, 0, target.width, target.height, 0, 0, target.width, target.height, mask, gl.NEAREST);
		};
		_proto2.resolve = function resolve(device, target, color, depth) {
			if (device.isWebGL2) {
				var gl = device.gl;
				if (this.colorMrtFramebuffers) {
					if (color) {
						for (var i = 0; i < this.colorMrtFramebuffers.length; i++) {
							var fbPair = this.colorMrtFramebuffers[i];
							this.internalResolve(device, fbPair.msaaFB, fbPair.resolveFB, target, gl.COLOR_BUFFER_BIT);
						}
					}
					if (depth) {
						this.internalResolve(device, this._glFrameBuffer, this._glResolveFrameBuffer, target, gl.DEPTH_BUFFER_BIT);
					}
				} else {
					this.internalResolve(device, this._glFrameBuffer, this._glResolveFrameBuffer, target, (color ? gl.COLOR_BUFFER_BIT : 0) | (depth ? gl.DEPTH_BUFFER_BIT : 0));
				}
				gl.bindFramebuffer(gl.FRAMEBUFFER, this._glFrameBuffer);
			}
		};
		_createClass(WebglRenderTarget, [{
			key: "initialized",
			get: function get() {
				return this._isInitialized;
			}
		}]);
		return WebglRenderTarget;
	}();

	var gles2PS = "\n#define pcFragColor0 gl_FragData[0]\n#if COLOR_ATTACHMENT_1\n#define pcFragColor1 gl_FragData[1]\n#endif\n#if COLOR_ATTACHMENT_2\n#define pcFragColor2 gl_FragData[2]\n#endif\n#if COLOR_ATTACHMENT_3\n#define pcFragColor3 gl_FragData[3]\n#endif\n#if COLOR_ATTACHMENT_4\n#define pcFragColor4 gl_FragData[4]\n#endif\n#if COLOR_ATTACHMENT_5\n#define pcFragColor5 gl_FragData[5]\n#endif\n#if COLOR_ATTACHMENT_6\n#define pcFragColor6 gl_FragData[6]\n#endif\n#if COLOR_ATTACHMENT_7\n#define pcFragColor7 gl_FragData[7]\n#endif\n#define texture2DBias texture2D\n#define SHADOWMAP_PASS(name) name\n#define SHADOWMAP_ACCEPT(name) sampler2D name\n#define TEXTURE_PASS(name) name\n#define TEXTURE_ACCEPT(name) sampler2D name\n#ifndef SUPPORTS_TEXLOD\n\t#define texture2DLodEXT texture2D\n\t#define texture2DProjLodEXT textureProj\n\t#define textureCubeLodEXT textureCube\n\t#define textureShadow texture2D\n#else\n\t#define textureShadow(res, uv) texture2DGradEXT(res, uv, vec2(1, 1), vec2(1, 1))\n#endif\n#ifdef SUPPORTS_MRT\n\t#define gl_FragColor pcFragColor0\n#endif\n";

	var gles3PS = "\nlayout(location = 0) out highp vec4 pc_fragColor;\n#ifndef REMOVE_COLOR_ATTACHMENT_1\n#if COLOR_ATTACHMENT_1\nlayout(location = 1) out highp vec4 pc_fragColor1;\n#endif\n#endif\n#ifndef REMOVE_COLOR_ATTACHMENT_2\n#if COLOR_ATTACHMENT_2\nlayout(location = 2) out highp vec4 pc_fragColor2;\n#endif\n#endif\n#ifndef REMOVE_COLOR_ATTACHMENT_3\n#if COLOR_ATTACHMENT_3\nlayout(location = 3) out highp vec4 pc_fragColor3;\n#endif\n#endif\n#ifndef REMOVE_COLOR_ATTACHMENT_4\n#if COLOR_ATTACHMENT_4\nlayout(location = 4) out highp vec4 pc_fragColor4;\n#endif\n#endif\n#ifndef REMOVE_COLOR_ATTACHMENT_5\n#if COLOR_ATTACHMENT_5\nlayout(location = 5) out highp vec4 pc_fragColor5;\n#endif\n#endif\n#ifndef REMOVE_COLOR_ATTACHMENT_6\n#if COLOR_ATTACHMENT_6\nlayout(location = 6) out highp vec4 pc_fragColor6;\n#endif\n#endif\n#ifndef REMOVE_COLOR_ATTACHMENT_7\n#if COLOR_ATTACHMENT_7\nlayout(location = 7) out highp vec4 pc_fragColor7;\n#endif\n#endif\n#define gl_FragColor pc_fragColor\n#define pcFragColor0 pc_fragColor\n#define pcFragColor1 pc_fragColor1\n#define pcFragColor2 pc_fragColor2\n#define pcFragColor3 pc_fragColor3\n#define pcFragColor4 pc_fragColor4\n#define pcFragColor5 pc_fragColor5\n#define pcFragColor6 pc_fragColor6\n#define pcFragColor7 pc_fragColor7\n#define varying in\n#define texture2D texture\n#define texture2DBias texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\n#define textureShadow(res, uv) textureGrad(res, uv, vec2(1, 1), vec2(1, 1))\n#define SHADOWMAP_PASS(name) name\n#define SHADOWMAP_ACCEPT(name) sampler2DShadow name\n#define TEXTURE_PASS(name) name\n#define TEXTURE_ACCEPT(name) sampler2D name\n#define GL2\n#define SUPPORTS_TEXLOD\n#define SUPPORTS_MRT\n";

	var gles3VS = "\n#define attribute in\n#define varying out\n#define texture2D texture\n#define GL2\n#define VERTEXSHADER\n";

	var webgpuPS = "\n#extension GL_EXT_samplerless_texture_functions : require\nlayout(location = 0) out highp vec4 pc_fragColor;\nlayout(location = 1) out highp vec4 pc_fragColor1;\nlayout(location = 2) out highp vec4 pc_fragColor2;\nlayout(location = 3) out highp vec4 pc_fragColor3;\nlayout(location = 4) out highp vec4 pc_fragColor4;\nlayout(location = 5) out highp vec4 pc_fragColor5;\nlayout(location = 6) out highp vec4 pc_fragColor6;\nlayout(location = 7) out highp vec4 pc_fragColor7;\n#define gl_FragColor pc_fragColor\n#define pcFragColor0 pc_fragColor\n#define pcFragColor1 pc_fragColor1\n#define pcFragColor2 pc_fragColor2\n#define pcFragColor3 pc_fragColor3\n#define pcFragColor4 pc_fragColor4\n#define pcFragColor5 pc_fragColor5\n#define pcFragColor6 pc_fragColor6\n#define pcFragColor7 pc_fragColor7\n#define texture2D(res, uv) texture(sampler2D(res, res ## _sampler), uv)\n#define texture2DBias(res, uv, bias) texture(sampler2D(res, res ## _sampler), uv, bias)\n#define texture2DLodEXT(res, uv, lod) textureLod(sampler2D(res, res ## _sampler), uv, lod)\n#define textureCube(res, uv) texture(samplerCube(res, res ## _sampler), uv)\n#define textureCubeLodEXT(res, uv, lod) textureLod(samplerCube(res, res ## _sampler), uv, lod)\n#define textureShadow(res, uv) textureLod(sampler2DShadow(res, res ## _sampler), uv, 0.0)\n#define SHADOWMAP_PASS(name) name, name ## _sampler\n#define SHADOWMAP_ACCEPT(name) texture2D name, sampler name ## _sampler\n#define TEXTURE_PASS(name) name, name ## _sampler\n#define TEXTURE_ACCEPT(name) texture2D name, sampler name ## _sampler\n#define GL2\n#define WEBGPU\n#define SUPPORTS_TEXLOD\n#define SUPPORTS_MRT\n";

	var webgpuVS = "\n#extension GL_EXT_samplerless_texture_functions : require\n#define texture2D(res, uv) texture(sampler2D(res, res ## _sampler), uv)\n#define GL2\n#define WEBGPU\n#define VERTEXSHADER\n";

	var sharedFS = "\nvec2 getGrabScreenPos(vec4 clipPos) {\n\tvec2 uv = (clipPos.xy / clipPos.w) * 0.5 + 0.5;\n\t#ifdef WEBGPU\n\t\tuv.y = 1.0 - uv.y;\n\t#endif\n\treturn uv;\n}\nvec2 getImageEffectUV(vec2 uv) {\n\t#ifdef WEBGPU\n\t\tuv.y = 1.0 - uv.y;\n\t#endif\n\treturn uv;\n}\n";

	var _attrib2Semantic = {
		vertex_position: SEMANTIC_POSITION,
		vertex_normal: SEMANTIC_NORMAL,
		vertex_tangent: SEMANTIC_TANGENT,
		vertex_texCoord0: SEMANTIC_TEXCOORD0,
		vertex_texCoord1: SEMANTIC_TEXCOORD1,
		vertex_texCoord2: SEMANTIC_TEXCOORD2,
		vertex_texCoord3: SEMANTIC_TEXCOORD3,
		vertex_texCoord4: SEMANTIC_TEXCOORD4,
		vertex_texCoord5: SEMANTIC_TEXCOORD5,
		vertex_texCoord6: SEMANTIC_TEXCOORD6,
		vertex_texCoord7: SEMANTIC_TEXCOORD7,
		vertex_color: SEMANTIC_COLOR,
		vertex_boneIndices: SEMANTIC_BLENDINDICES,
		vertex_boneWeights: SEMANTIC_BLENDWEIGHT
	};
	var ShaderUtils = function () {
		function ShaderUtils() {}
		ShaderUtils.createDefinition = function createDefinition(device, options) {
			var _options$name, _options$attributes;
			var getDefines = function getDefines(gpu, gl2, gl1, isVertex) {
				var deviceIntro = device.isWebGPU ? gpu : device.isWebGL2 ? gl2 : ShaderUtils.gl1Extensions(device, options) + gl1;
				var attachmentsDefine = '';
				for (var i = 0; i < device.maxColorAttachments; i++) {
					attachmentsDefine += "#define COLOR_ATTACHMENT_" + i + "\n";
				}
				return attachmentsDefine + deviceIntro;
			};
			var name = (_options$name = options.name) != null ? _options$name : 'Untitled';
			var vertDefines = options.vertexDefines || getDefines(webgpuVS, gles3VS, '');
			var vertCode = ShaderUtils.versionCode(device) + vertDefines + sharedFS + ShaderUtils.getShaderNameCode(name) + options.vertexCode;
			var fragDefines = options.fragmentDefines || getDefines(webgpuPS, gles3PS, gles2PS);
			var fragCode = (options.fragmentPreamble || '') + ShaderUtils.versionCode(device) + fragDefines + ShaderUtils.precisionCode(device) + '\n' + sharedFS + ShaderUtils.getShaderNameCode(name) + (options.fragmentCode || ShaderUtils.dummyFragmentCode());
			var attribs = (_options$attributes = options.attributes) != null ? _options$attributes : ShaderUtils.collectAttributes(options.vertexCode);
			return {
				name: name,
				attributes: attribs,
				vshader: vertCode,
				fshader: fragCode,
				useTransformFeedback: options.useTransformFeedback
			};
		};
		ShaderUtils.getShaderNameCode = function getShaderNameCode(name) {
			return "#define SHADER_NAME " + name + "\n";
		};
		ShaderUtils.gl1Extensions = function gl1Extensions(device, options, isVertex) {
			var code;
			if (isVertex) {
				code = options.vertexExtensions ? options.vertexExtensions + "\n" : '';
			} else {
				code = options.fragmentExtensions ? options.fragmentExtensions + "\n" : '';
				if (device.extStandardDerivatives) {
					code += "#extension GL_OES_standard_derivatives : enable\n";
				}
				if (device.extTextureLod) {
					code += "#extension GL_EXT_shader_texture_lod : enable\n";
					code += "#define SUPPORTS_TEXLOD\n";
				}
				if (device.extDrawBuffers) {
					code += "#extension GL_EXT_draw_buffers : require\n";
					code += "#define SUPPORTS_MRT\n";
				}
			}
			return code;
		};
		ShaderUtils.dummyFragmentCode = function dummyFragmentCode() {
			return "void main(void) {gl_FragColor = vec4(0.0);}";
		};
		ShaderUtils.versionCode = function versionCode(device) {
			if (device.isWebGPU) {
				return '#version 450\n';
			}
			return device.isWebGL2 ? "#version 300 es\n" : "";
		};
		ShaderUtils.precisionCode = function precisionCode(device, forcePrecision) {
			var code = '';
			if (forcePrecision && forcePrecision !== 'highp' && forcePrecision !== 'mediump' && forcePrecision !== 'lowp') {
				forcePrecision = null;
			}
			if (forcePrecision) {
				if (forcePrecision === 'highp' && device.maxPrecision !== 'highp') {
					forcePrecision = 'mediump';
				}
				if (forcePrecision === 'mediump' && device.maxPrecision === 'lowp') {
					forcePrecision = 'lowp';
				}
			}
			var precision = forcePrecision ? forcePrecision : device.precision;
			if (!device.isWebGPU) {
				code = "precision " + precision + " float;\n";
				if (device.isWebGL2) {
					code += "precision " + precision + " sampler2DShadow;\n";
				}
			} else {
				code = "precision " + precision + " float;\nprecision " + precision + " int;\n";
			}
			return code;
		};
		ShaderUtils.collectAttributes = function collectAttributes(vsCode) {
			var attribs = {};
			var attrs = 0;
			var found = vsCode.indexOf("attribute");
			while (found >= 0) {
				if (found > 0 && vsCode[found - 1] === "/") break;
				var endOfLine = vsCode.indexOf(';', found);
				var startOfAttribName = vsCode.lastIndexOf(' ', endOfLine);
				var attribName = vsCode.substring(startOfAttribName + 1, endOfLine);
				var semantic = _attrib2Semantic[attribName];
				if (semantic !== undefined) {
					attribs[attribName] = semantic;
				} else {
					attribs[attribName] = "ATTR" + attrs;
					attrs++;
				}
				found = vsCode.indexOf("attribute", found + 1);
			}
			return attribs;
		};
		return ShaderUtils;
	}();

	var FrameQueriesInfo = function () {
		function FrameQueriesInfo() {
			this.renderVersion = void 0;
			this.queries = [];
		}
		var _proto = FrameQueriesInfo.prototype;
		_proto.destroy = function destroy(gl) {
			this.queries.forEach(function (query) {
				return gl.deleteQuery(query);
			});
			this.queries = null;
		};
		return FrameQueriesInfo;
	}();
	var WebglGpuProfiler = function (_GpuProfiler) {
		_inheritsLoose(WebglGpuProfiler, _GpuProfiler);
		function WebglGpuProfiler(device) {
			var _this;
			_this = _GpuProfiler.call(this) || this;
			_this.device = void 0;
			_this.freeQueries = [];
			_this.frameQueries = [];
			_this.previousFrameQueries = [];
			_this.timings = [];
			_this.device = device;
			_this.ext = device.extDisjointTimerQuery;
			return _this;
		}
		var _proto2 = WebglGpuProfiler.prototype;
		_proto2.destroy = function destroy() {
			var _this2 = this;
			this.freeQueries.forEach(function (query) {
				return _this2.device.gl.deleteQuery(query);
			});
			this.frameQueries.forEach(function (query) {
				return _this2.device.gl.deleteQuery(query);
			});
			this.previousFrameQueries.forEach(function (frameQueriesInfo) {
				return frameQueriesInfo.destroy(_this2.device.gl);
			});
			this.freeQueries = null;
			this.frameQueries = null;
			this.previousFrameQueries = null;
		};
		_proto2.loseContext = function loseContext() {
			_GpuProfiler.prototype.loseContext.call(this);
			this.freeQueries = [];
			this.frameQueries = [];
			this.previousFrameQueries = [];
		};
		_proto2.restoreContext = function restoreContext() {
			this.ext = this.device.extDisjointTimerQuery;
		};
		_proto2.getQuery = function getQuery() {
			var _this$freeQueries$pop;
			return (_this$freeQueries$pop = this.freeQueries.pop()) != null ? _this$freeQueries$pop : this.device.gl.createQuery();
		};
		_proto2.start = function start(name) {
			if (this.ext) {
				var slot = this.getSlot(name);
				var query = this.getQuery();
				this.frameQueries[slot] = query;
				this.device.gl.beginQuery(this.ext.TIME_ELAPSED_EXT, query);
				return slot;
			}
			return undefined;
		};
		_proto2.end = function end(slot) {
			if (slot !== undefined) {
				this.device.gl.endQuery(this.ext.TIME_ELAPSED_EXT);
			}
		};
		_proto2.frameStart = function frameStart() {
			this.processEnableRequest();
			if (this._enabled) {
				this.frameGPUMarkerSlot = this.start('GpuFrame');
			}
		};
		_proto2.frameEnd = function frameEnd() {
			if (this._enabled) {
				this.end(this.frameGPUMarkerSlot);
			}
		};
		_proto2.request = function request() {
			var _this3 = this;
			if (this._enabled) {
				var ext = this.ext;
				var gl = this.device.gl;
				var renderVersion = this.device.renderVersion;
				var frameQueries = this.frameQueries;
				if (frameQueries.length > 0) {
					this.frameQueries = [];
					var frameQueriesInfo = new FrameQueriesInfo();
					frameQueriesInfo.queries = frameQueries;
					frameQueriesInfo.renderVersion = renderVersion;
					this.previousFrameQueries.push(frameQueriesInfo);
				}
				if (this.previousFrameQueries.length > 0) {
					var previousQueriesInfo = this.previousFrameQueries[0];
					var previousQueries = previousQueriesInfo.queries;
					var lastQuery = previousQueries[previousQueries.length - 1];
					var available = gl.getQueryParameter(lastQuery, gl.QUERY_RESULT_AVAILABLE);
					var disjoint = gl.getParameter(ext.GPU_DISJOINT_EXT);
					if (available && !disjoint) {
						this.previousFrameQueries.shift();
						var timings = this.timings;
						timings.length = 0;
						for (var i = 0; i < previousQueries.length; i++) {
							var query = previousQueries[i];
							var duration = gl.getQueryParameter(query, gl.QUERY_RESULT);
							timings[i] = duration * 0.000001;
							this.freeQueries.push(query);
						}
						this.report(previousQueriesInfo.renderVersion, timings);
					}
					if (disjoint) {
						this.previousFrameQueries.forEach(function (frameQueriesInfo) {
							_this3.report(frameQueriesInfo.renderVersion, null);
							frameQueriesInfo.destroy(gl);
						});
						this.previousFrameQueries.length = 0;
					}
				}
				_GpuProfiler.prototype.request.call(this, renderVersion);
			}
		};
		return WebglGpuProfiler;
	}(GpuProfiler);

	var invalidateAttachments = [];
	var _fullScreenQuadVS = "\nattribute vec2 vertex_position;\nvarying vec2 vUv0;\nvoid main(void)\n{\n\tgl_Position = vec4(vertex_position, 0.5, 1.0);\n\tvUv0 = vertex_position.xy*0.5+0.5;\n}\n";
	var _precisionTest1PS = "\nvoid main(void) { \n\tgl_FragColor = vec4(2147483648.0);\n}\n";
	var _precisionTest2PS = "\nuniform sampler2D source;\nvec4 packFloat(float depth) {\n\tconst vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);\n\tconst vec4 bit_mask  = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\n\tvec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);\n\tres -= res.xxyz * bit_mask;\n\treturn res;\n}\nvoid main(void) {\n\tfloat c = texture2D(source, vec2(0.0)).r;\n\tfloat diff = abs(c - 2147483648.0) / 2147483648.0;\n\tgl_FragColor = packFloat(diff);\n}\n";
	var _outputTexture2D = "\nvarying vec2 vUv0;\nuniform sampler2D source;\nvoid main(void) {\n\tgl_FragColor = texture2D(source, vUv0);\n}\n";
	function quadWithShader(device, target, shader) {
		var oldRt = device.renderTarget;
		device.setRenderTarget(target);
		device.updateBegin();
		device.setCullMode(CULLFACE_NONE);
		device.setBlendState(BlendState.NOBLEND);
		device.setDepthState(DepthState.NODEPTH);
		device.setStencilState(null, null);
		device.setVertexBuffer(device.quadVertexBuffer, 0);
		device.setShader(shader);
		device.draw({
			type: PRIMITIVE_TRISTRIP,
			base: 0,
			count: 4,
			indexed: false
		});
		device.updateEnd();
		device.setRenderTarget(oldRt);
		device.updateBegin();
	}
	function testRenderable(gl, pixelFormat) {
		var result = true;
		var texture = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, texture);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, pixelFormat, null);
		var framebuffer = gl.createFramebuffer();
		gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
		gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
		if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) {
			result = false;
		}
		gl.bindTexture(gl.TEXTURE_2D, null);
		gl.deleteTexture(texture);
		gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		gl.deleteFramebuffer(framebuffer);
		return result;
	}
	function testTextureHalfFloatUpdatable(gl, pixelFormat) {
		var result = true;
		var texture = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, texture);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		var data = new Uint16Array(4 * 2 * 2);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, pixelFormat, data);
		if (gl.getError() !== gl.NO_ERROR) {
			result = false;
			console.log("Above error related to HALF_FLOAT_OES can be ignored, it was triggered by testing half float texture support");
		}
		gl.bindTexture(gl.TEXTURE_2D, null);
		gl.deleteTexture(texture);
		return result;
	}
	function testTextureFloatHighPrecision(device) {
		if (!device.textureFloatRenderable) return false;
		var shader1 = new Shader(device, ShaderUtils.createDefinition(device, {
			name: 'ptest1',
			vertexCode: _fullScreenQuadVS,
			fragmentCode: _precisionTest1PS
		}));
		var shader2 = new Shader(device, ShaderUtils.createDefinition(device, {
			name: 'ptest2',
			vertexCode: _fullScreenQuadVS,
			fragmentCode: _precisionTest2PS
		}));
		var textureOptions = {
			format: PIXELFORMAT_RGBA32F,
			width: 1,
			height: 1,
			mipmaps: false,
			minFilter: FILTER_NEAREST,
			magFilter: FILTER_NEAREST,
			name: 'testFHP'
		};
		var tex1 = new Texture(device, textureOptions);
		var targ1 = new RenderTarget({
			colorBuffer: tex1,
			depth: false
		});
		quadWithShader(device, targ1, shader1);
		textureOptions.format = PIXELFORMAT_RGBA8;
		var tex2 = new Texture(device, textureOptions);
		var targ2 = new RenderTarget({
			colorBuffer: tex2,
			depth: false
		});
		device.constantTexSource.setValue(tex1);
		quadWithShader(device, targ2, shader2);
		var prevFramebuffer = device.activeFramebuffer;
		device.setFramebuffer(targ2.impl._glFrameBuffer);
		var pixels = new Uint8Array(4);
		device.readPixels(0, 0, 1, 1, pixels);
		device.setFramebuffer(prevFramebuffer);
		var x = pixels[0] / 255;
		var y = pixels[1] / 255;
		var z = pixels[2] / 255;
		var w = pixels[3] / 255;
		var f = x / (256 * 256 * 256) + y / (256 * 256) + z / 256 + w;
		tex1.destroy();
		targ1.destroy();
		tex2.destroy();
		targ2.destroy();
		shader1.destroy();
		shader2.destroy();
		return f === 0;
	}
	var WebglGraphicsDevice = function (_GraphicsDevice) {
		_inheritsLoose(WebglGraphicsDevice, _GraphicsDevice);
		function WebglGraphicsDevice(canvas, options) {
			var _options$antialias;
			var _this;
			if (options === void 0) {
				options = {};
			}
			_this = _GraphicsDevice.call(this, canvas, options) || this;
			_this.gl = void 0;
			_this._defaultFramebuffer = null;
			_this._defaultFramebufferChanged = false;
			options = _this.initOptions;
			_this.updateClientRect();
			_this.initTextureUnits();
			_this.contextLost = false;
			_this._contextLostHandler = function (event) {
				event.preventDefault();
				_this.contextLost = true;
				_this.loseContext();
				_this.fire('devicelost');
			};
			_this._contextRestoredHandler = function () {
				_this.contextLost = false;
				_this.restoreContext();
				_this.fire('devicerestored');
			};
			var ua = typeof navigator !== 'undefined' && navigator.userAgent;
			_this.forceDisableMultisampling = ua && ua.includes('AppleWebKit') && (ua.includes('15.4') || ua.includes('15_4'));
			if (_this.forceDisableMultisampling) {
				options.antialias = false;
			}
			var gl = null;
			_this.backBufferAntialias = (_options$antialias = options.antialias) != null ? _options$antialias : false;
			options.antialias = false;
			if (options.gl) {
				gl = options.gl;
			} else {
				var preferWebGl2 = options.preferWebGl2 !== undefined ? options.preferWebGl2 : true;
				var names = preferWebGl2 ? ["webgl2", "webgl", "experimental-webgl"] : ["webgl", "experimental-webgl"];
				for (var i = 0; i < names.length; i++) {
					gl = canvas.getContext(names[i], options);
					if (gl) {
						break;
					}
				}
			}
			if (!gl) {
				throw new Error("WebGL not supported");
			}
			_this.gl = gl;
			_this.isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext;
			_this.isWebGL1 = !_this.isWebGL2;
			_this._deviceType = _this.isWebGL2 ? DEVICETYPE_WEBGL2 : DEVICETYPE_WEBGL1;
			_this.updateBackbufferFormat(null);
			var isChrome = platform.browserName === 'chrome';
			var isSafari = platform.browserName === 'safari';
			var isMac = platform.browser && navigator.appVersion.indexOf("Mac") !== -1;
			_this._tempEnableSafariTextureUnitWorkaround = isSafari;
			_this._tempMacChromeBlitFramebufferWorkaround = isMac && isChrome && !options.alpha;
			if (!_this.isWebGL2) {
				setupVertexArrayObject(gl);
			}
			canvas.addEventListener("webglcontextlost", _this._contextLostHandler, false);
			canvas.addEventListener("webglcontextrestored", _this._contextRestoredHandler, false);
			_this.initializeExtensions();
			_this.initializeCapabilities();
			_this.initializeRenderState();
			_this.initializeContextCaches();
			_this.createBackbuffer(null);
			_this.supportsImageBitmap = !isSafari && typeof ImageBitmap !== 'undefined';
			_this.glAddress = [gl.REPEAT, gl.CLAMP_TO_EDGE, gl.MIRRORED_REPEAT];
			_this.glBlendEquation = [gl.FUNC_ADD, gl.FUNC_SUBTRACT, gl.FUNC_REVERSE_SUBTRACT, _this.isWebGL2 ? gl.MIN : _this.extBlendMinmax ? _this.extBlendMinmax.MIN_EXT : gl.FUNC_ADD, _this.isWebGL2 ? gl.MAX : _this.extBlendMinmax ? _this.extBlendMinmax.MAX_EXT : gl.FUNC_ADD];
			_this.glBlendFunctionColor = [gl.ZERO, gl.ONE, gl.SRC_COLOR, gl.ONE_MINUS_SRC_COLOR, gl.DST_COLOR, gl.ONE_MINUS_DST_COLOR, gl.SRC_ALPHA, gl.SRC_ALPHA_SATURATE, gl.ONE_MINUS_SRC_ALPHA, gl.DST_ALPHA, gl.ONE_MINUS_DST_ALPHA, gl.CONSTANT_COLOR, gl.ONE_MINUS_CONSTANT_COLOR];
			_this.glBlendFunctionAlpha = [gl.ZERO, gl.ONE, gl.SRC_COLOR, gl.ONE_MINUS_SRC_COLOR, gl.DST_COLOR, gl.ONE_MINUS_DST_COLOR, gl.SRC_ALPHA, gl.SRC_ALPHA_SATURATE, gl.ONE_MINUS_SRC_ALPHA, gl.DST_ALPHA, gl.ONE_MINUS_DST_ALPHA, gl.CONSTANT_ALPHA, gl.ONE_MINUS_CONSTANT_ALPHA];
			_this.glComparison = [gl.NEVER, gl.LESS, gl.EQUAL, gl.LEQUAL, gl.GREATER, gl.NOTEQUAL, gl.GEQUAL, gl.ALWAYS];
			_this.glStencilOp = [gl.KEEP, gl.ZERO, gl.REPLACE, gl.INCR, gl.INCR_WRAP, gl.DECR, gl.DECR_WRAP, gl.INVERT];
			_this.glClearFlag = [0, gl.COLOR_BUFFER_BIT, gl.DEPTH_BUFFER_BIT, gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT, gl.STENCIL_BUFFER_BIT, gl.STENCIL_BUFFER_BIT | gl.COLOR_BUFFER_BIT, gl.STENCIL_BUFFER_BIT | gl.DEPTH_BUFFER_BIT, gl.STENCIL_BUFFER_BIT | gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT];
			_this.glCull = [0, gl.BACK, gl.FRONT, gl.FRONT_AND_BACK];
			_this.glFilter = [gl.NEAREST, gl.LINEAR, gl.NEAREST_MIPMAP_NEAREST, gl.NEAREST_MIPMAP_LINEAR, gl.LINEAR_MIPMAP_NEAREST, gl.LINEAR_MIPMAP_LINEAR];
			_this.glPrimitive = [gl.POINTS, gl.LINES, gl.LINE_LOOP, gl.LINE_STRIP, gl.TRIANGLES, gl.TRIANGLE_STRIP, gl.TRIANGLE_FAN];
			_this.glType = [gl.BYTE, gl.UNSIGNED_BYTE, gl.SHORT, gl.UNSIGNED_SHORT, gl.INT, gl.UNSIGNED_INT, gl.FLOAT, gl.HALF_FLOAT];
			_this.pcUniformType = {};
			_this.pcUniformType[gl.BOOL] = UNIFORMTYPE_BOOL;
			_this.pcUniformType[gl.INT] = UNIFORMTYPE_INT;
			_this.pcUniformType[gl.FLOAT] = UNIFORMTYPE_FLOAT;
			_this.pcUniformType[gl.FLOAT_VEC2] = UNIFORMTYPE_VEC2;
			_this.pcUniformType[gl.FLOAT_VEC3] = UNIFORMTYPE_VEC3;
			_this.pcUniformType[gl.FLOAT_VEC4] = UNIFORMTYPE_VEC4;
			_this.pcUniformType[gl.INT_VEC2] = UNIFORMTYPE_IVEC2;
			_this.pcUniformType[gl.INT_VEC3] = UNIFORMTYPE_IVEC3;
			_this.pcUniformType[gl.INT_VEC4] = UNIFORMTYPE_IVEC4;
			_this.pcUniformType[gl.BOOL_VEC2] = UNIFORMTYPE_BVEC2;
			_this.pcUniformType[gl.BOOL_VEC3] = UNIFORMTYPE_BVEC3;
			_this.pcUniformType[gl.BOOL_VEC4] = UNIFORMTYPE_BVEC4;
			_this.pcUniformType[gl.FLOAT_MAT2] = UNIFORMTYPE_MAT2;
			_this.pcUniformType[gl.FLOAT_MAT3] = UNIFORMTYPE_MAT3;
			_this.pcUniformType[gl.FLOAT_MAT4] = UNIFORMTYPE_MAT4;
			_this.pcUniformType[gl.SAMPLER_2D] = UNIFORMTYPE_TEXTURE2D;
			_this.pcUniformType[gl.SAMPLER_CUBE] = UNIFORMTYPE_TEXTURECUBE;
			if (_this.isWebGL2) {
				_this.pcUniformType[gl.SAMPLER_2D_SHADOW] = UNIFORMTYPE_TEXTURE2D_SHADOW;
				_this.pcUniformType[gl.SAMPLER_CUBE_SHADOW] = UNIFORMTYPE_TEXTURECUBE_SHADOW;
				_this.pcUniformType[gl.SAMPLER_2D_ARRAY] = UNIFORMTYPE_TEXTURE2D_ARRAY;
				_this.pcUniformType[gl.SAMPLER_3D] = UNIFORMTYPE_TEXTURE3D;
			}
			_this.targetToSlot = {};
			_this.targetToSlot[gl.TEXTURE_2D] = 0;
			_this.targetToSlot[gl.TEXTURE_CUBE_MAP] = 1;
			_this.targetToSlot[gl.TEXTURE_3D] = 2;
			var scopeX, scopeY, scopeZ, scopeW;
			var uniformValue;
			_this.commitFunction = [];
			_this.commitFunction[UNIFORMTYPE_BOOL] = function (uniform, value) {
				if (uniform.value !== value) {
					gl.uniform1i(uniform.locationId, value);
					uniform.value = value;
				}
			};
			_this.commitFunction[UNIFORMTYPE_INT] = _this.commitFunction[UNIFORMTYPE_BOOL];
			_this.commitFunction[UNIFORMTYPE_FLOAT] = function (uniform, value) {
				if (uniform.value !== value) {
					gl.uniform1f(uniform.locationId, value);
					uniform.value = value;
				}
			};
			_this.commitFunction[UNIFORMTYPE_VEC2] = function (uniform, value) {
				uniformValue = uniform.value;
				scopeX = value[0];
				scopeY = value[1];
				if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY) {
					gl.uniform2fv(uniform.locationId, value);
					uniformValue[0] = scopeX;
					uniformValue[1] = scopeY;
				}
			};
			_this.commitFunction[UNIFORMTYPE_VEC3] = function (uniform, value) {
				uniformValue = uniform.value;
				scopeX = value[0];
				scopeY = value[1];
				scopeZ = value[2];
				if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ) {
					gl.uniform3fv(uniform.locationId, value);
					uniformValue[0] = scopeX;
					uniformValue[1] = scopeY;
					uniformValue[2] = scopeZ;
				}
			};
			_this.commitFunction[UNIFORMTYPE_VEC4] = function (uniform, value) {
				uniformValue = uniform.value;
				scopeX = value[0];
				scopeY = value[1];
				scopeZ = value[2];
				scopeW = value[3];
				if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ || uniformValue[3] !== scopeW) {
					gl.uniform4fv(uniform.locationId, value);
					uniformValue[0] = scopeX;
					uniformValue[1] = scopeY;
					uniformValue[2] = scopeZ;
					uniformValue[3] = scopeW;
				}
			};
			_this.commitFunction[UNIFORMTYPE_IVEC2] = function (uniform, value) {
				uniformValue = uniform.value;
				scopeX = value[0];
				scopeY = value[1];
				if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY) {
					gl.uniform2iv(uniform.locationId, value);
					uniformValue[0] = scopeX;
					uniformValue[1] = scopeY;
				}
			};
			_this.commitFunction[UNIFORMTYPE_BVEC2] = _this.commitFunction[UNIFORMTYPE_IVEC2];
			_this.commitFunction[UNIFORMTYPE_IVEC3] = function (uniform, value) {
				uniformValue = uniform.value;
				scopeX = value[0];
				scopeY = value[1];
				scopeZ = value[2];
				if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ) {
					gl.uniform3iv(uniform.locationId, value);
					uniformValue[0] = scopeX;
					uniformValue[1] = scopeY;
					uniformValue[2] = scopeZ;
				}
			};
			_this.commitFunction[UNIFORMTYPE_BVEC3] = _this.commitFunction[UNIFORMTYPE_IVEC3];
			_this.commitFunction[UNIFORMTYPE_IVEC4] = function (uniform, value) {
				uniformValue = uniform.value;
				scopeX = value[0];
				scopeY = value[1];
				scopeZ = value[2];
				scopeW = value[3];
				if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ || uniformValue[3] !== scopeW) {
					gl.uniform4iv(uniform.locationId, value);
					uniformValue[0] = scopeX;
					uniformValue[1] = scopeY;
					uniformValue[2] = scopeZ;
					uniformValue[3] = scopeW;
				}
			};
			_this.commitFunction[UNIFORMTYPE_BVEC4] = _this.commitFunction[UNIFORMTYPE_IVEC4];
			_this.commitFunction[UNIFORMTYPE_MAT2] = function (uniform, value) {
				gl.uniformMatrix2fv(uniform.locationId, false, value);
			};
			_this.commitFunction[UNIFORMTYPE_MAT3] = function (uniform, value) {
				gl.uniformMatrix3fv(uniform.locationId, false, value);
			};
			_this.commitFunction[UNIFORMTYPE_MAT4] = function (uniform, value) {
				gl.uniformMatrix4fv(uniform.locationId, false, value);
			};
			_this.commitFunction[UNIFORMTYPE_FLOATARRAY] = function (uniform, value) {
				gl.uniform1fv(uniform.locationId, value);
			};
			_this.commitFunction[UNIFORMTYPE_VEC2ARRAY] = function (uniform, value) {
				gl.uniform2fv(uniform.locationId, value);
			};
			_this.commitFunction[UNIFORMTYPE_VEC3ARRAY] = function (uniform, value) {
				gl.uniform3fv(uniform.locationId, value);
			};
			_this.commitFunction[UNIFORMTYPE_VEC4ARRAY] = function (uniform, value) {
				gl.uniform4fv(uniform.locationId, value);
			};
			_this.supportsBoneTextures = _this.extTextureFloat && _this.maxVertexTextures > 0;
			var numUniforms = _this.vertexUniformsCount;
			numUniforms -= 4 * 4;
			numUniforms -= 8;
			numUniforms -= 1;
			numUniforms -= 4 * 4;
			_this.boneLimit = Math.floor(numUniforms / 3);
			_this.boneLimit = Math.min(_this.boneLimit, 128);
			if (_this.unmaskedRenderer === 'Mali-450 MP') {
				_this.boneLimit = 34;
			}
			_this.constantTexSource = _this.scope.resolve("source");
			if (_this.extTextureFloat) {
				if (_this.isWebGL2) {
					_this.textureFloatRenderable = !!_this.extColorBufferFloat;
				} else {
					_this.textureFloatRenderable = testRenderable(gl, gl.FLOAT);
				}
			} else {
				_this.textureFloatRenderable = false;
			}
			if (_this.extColorBufferHalfFloat) {
				_this.textureHalfFloatRenderable = !!_this.extColorBufferHalfFloat;
			} else if (_this.extTextureHalfFloat) {
				if (_this.isWebGL2) {
					_this.textureHalfFloatRenderable = !!_this.extColorBufferFloat;
				} else {
					_this.textureHalfFloatRenderable = testRenderable(gl, _this.extTextureHalfFloat.HALF_FLOAT_OES);
				}
			} else {
				_this.textureHalfFloatRenderable = false;
			}
			_this.supportsMorphTargetTexturesCore = _this.maxPrecision === "highp" && _this.maxVertexTextures >= 2;
			_this.supportsDepthShadow = _this.isWebGL2;
			_this._textureFloatHighPrecision = undefined;
			_this._textureHalfFloatUpdatable = undefined;
			_this.areaLightLutFormat = PIXELFORMAT_RGBA8;
			if (_this.extTextureHalfFloat && _this.textureHalfFloatUpdatable && _this.extTextureHalfFloatLinear) {
				_this.areaLightLutFormat = PIXELFORMAT_RGBA16F;
			} else if (_this.extTextureFloat && _this.extTextureFloatLinear) {
				_this.areaLightLutFormat = PIXELFORMAT_RGBA32F;
			}
			_this.postInit();
			return _this;
		}
		var _proto = WebglGraphicsDevice.prototype;
		_proto.postInit = function postInit() {
			_GraphicsDevice.prototype.postInit.call(this);
			this.gpuProfiler = new WebglGpuProfiler(this);
		};
		_proto.destroy = function destroy() {
			_GraphicsDevice.prototype.destroy.call(this);
			var gl = this.gl;
			if (this.isWebGL2 && this.feedback) {
				gl.deleteTransformFeedback(this.feedback);
			}
			this.clearVertexArrayObjectCache();
			this.canvas.removeEventListener('webglcontextlost', this._contextLostHandler, false);
			this.canvas.removeEventListener('webglcontextrestored', this._contextRestoredHandler, false);
			this._contextLostHandler = null;
			this._contextRestoredHandler = null;
			this.gl = null;
			_GraphicsDevice.prototype.postDestroy.call(this);
		};
		_proto.createBackbuffer = function createBackbuffer(frameBuffer) {
			this.supportsStencil = this.initOptions.stencil;
			this.backBuffer = new RenderTarget({
				name: 'WebglFramebuffer',
				graphicsDevice: this,
				depth: this.initOptions.depth,
				stencil: this.supportsStencil,
				samples: this.samples
			});
			this.backBuffer.impl.suppliedColorFramebuffer = frameBuffer;
		};
		_proto.updateBackbufferFormat = function updateBackbufferFormat(framebuffer) {
			var gl = this.gl;
			gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
			var alphaBits = this.gl.getParameter(this.gl.ALPHA_BITS);
			this.backBufferFormat = alphaBits ? PIXELFORMAT_RGBA8 : PIXELFORMAT_RGB8;
		};
		_proto.updateBackbuffer = function updateBackbuffer() {
			var resolutionChanged = this.canvas.width !== this.backBufferSize.x || this.canvas.height !== this.backBufferSize.y;
			if (this._defaultFramebufferChanged || resolutionChanged) {
				if (this._defaultFramebufferChanged) {
					this.updateBackbufferFormat(this._defaultFramebuffer);
				}
				this._defaultFramebufferChanged = false;
				this.backBufferSize.set(this.canvas.width, this.canvas.height);
				this.backBuffer.destroy();
				this.createBackbuffer(this._defaultFramebuffer);
			}
		};
		_proto.createVertexBufferImpl = function createVertexBufferImpl(vertexBuffer, format) {
			return new WebglVertexBuffer();
		};
		_proto.createIndexBufferImpl = function createIndexBufferImpl(indexBuffer) {
			return new WebglIndexBuffer(indexBuffer);
		};
		_proto.createShaderImpl = function createShaderImpl(shader) {
			return new WebglShader(shader);
		};
		_proto.createTextureImpl = function createTextureImpl(texture) {
			return new WebglTexture();
		};
		_proto.createRenderTargetImpl = function createRenderTargetImpl(renderTarget) {
			return new WebglRenderTarget();
		};
		_proto.getPrecision = function getPrecision() {
			var gl = this.gl;
			var precision = "highp";
			if (gl.getShaderPrecisionFormat) {
				var vertexShaderPrecisionHighpFloat = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT);
				var vertexShaderPrecisionMediumpFloat = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT);
				var fragmentShaderPrecisionHighpFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
				var fragmentShaderPrecisionMediumpFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT);
				if (vertexShaderPrecisionHighpFloat && vertexShaderPrecisionMediumpFloat && fragmentShaderPrecisionHighpFloat && fragmentShaderPrecisionMediumpFloat) {
					var highpAvailable = vertexShaderPrecisionHighpFloat.precision > 0 && fragmentShaderPrecisionHighpFloat.precision > 0;
					var mediumpAvailable = vertexShaderPrecisionMediumpFloat.precision > 0 && fragmentShaderPrecisionMediumpFloat.precision > 0;
					if (!highpAvailable) {
						if (mediumpAvailable) {
							precision = "mediump";
						} else {
							precision = "lowp";
						}
					}
				}
			}
			return precision;
		};
		_proto.getExtension = function getExtension() {
			for (var i = 0; i < arguments.length; i++) {
				if (this.supportedExtensions.indexOf(arguments[i]) !== -1) {
					return this.gl.getExtension(arguments[i]);
				}
			}
			return null;
		};
		_proto.initializeExtensions = function initializeExtensions() {
			var _gl$getSupportedExten;
			var gl = this.gl;
			this.supportedExtensions = (_gl$getSupportedExten = gl.getSupportedExtensions()) != null ? _gl$getSupportedExten : [];
			this._extDisjointTimerQuery = null;
			if (this.isWebGL2) {
				this.extBlendMinmax = true;
				this.extDrawBuffers = true;
				this.drawBuffers = gl.drawBuffers.bind(gl);
				this.extInstancing = true;
				this.extStandardDerivatives = true;
				this.extTextureFloat = true;
				this.extTextureHalfFloat = true;
				this.textureHalfFloatFilterable = true;
				this.extTextureLod = true;
				this.extUintElement = true;
				this.extVertexArrayObject = true;
				this.extColorBufferFloat = this.getExtension('EXT_color_buffer_float');
				this.extDepthTexture = true;
				this.textureRG11B10Renderable = true;
			} else {
				var _this$extDrawBuffers;
				this.extBlendMinmax = this.getExtension("EXT_blend_minmax");
				this.extDrawBuffers = this.getExtension('WEBGL_draw_buffers');
				this.extInstancing = this.getExtension("ANGLE_instanced_arrays");
				this.drawBuffers = (_this$extDrawBuffers = this.extDrawBuffers) == null ? void 0 : _this$extDrawBuffers.drawBuffersWEBGL.bind(this.extDrawBuffers);
				if (this.extInstancing) {
					var ext = this.extInstancing;
					gl.drawArraysInstanced = ext.drawArraysInstancedANGLE.bind(ext);
					gl.drawElementsInstanced = ext.drawElementsInstancedANGLE.bind(ext);
					gl.vertexAttribDivisor = ext.vertexAttribDivisorANGLE.bind(ext);
				}
				this.extStandardDerivatives = this.getExtension("OES_standard_derivatives");
				this.extTextureFloat = this.getExtension("OES_texture_float");
				this.extTextureLod = this.getExtension('EXT_shader_texture_lod');
				this.extUintElement = this.getExtension("OES_element_index_uint");
				this.extVertexArrayObject = this.getExtension("OES_vertex_array_object");
				if (this.extVertexArrayObject) {
					var _ext = this.extVertexArrayObject;
					gl.createVertexArray = _ext.createVertexArrayOES.bind(_ext);
					gl.deleteVertexArray = _ext.deleteVertexArrayOES.bind(_ext);
					gl.isVertexArray = _ext.isVertexArrayOES.bind(_ext);
					gl.bindVertexArray = _ext.bindVertexArrayOES.bind(_ext);
				}
				this.extColorBufferFloat = null;
				this.extDepthTexture = gl.getExtension('WEBGL_depth_texture');
				this.extTextureHalfFloat = this.getExtension("OES_texture_half_float");
				this.extTextureHalfFloatLinear = this.getExtension("OES_texture_half_float_linear");
				this.textureHalfFloatFilterable = !!this.extTextureHalfFloatLinear;
			}
			this.extDebugRendererInfo = this.getExtension('WEBGL_debug_renderer_info');
			this.extTextureFloatLinear = this.getExtension("OES_texture_float_linear");
			this.textureFloatFilterable = !!this.extTextureFloatLinear;
			this.extFloatBlend = this.getExtension("EXT_float_blend");
			this.extTextureFilterAnisotropic = this.getExtension('EXT_texture_filter_anisotropic', 'WEBKIT_EXT_texture_filter_anisotropic');
			this.extCompressedTextureETC1 = this.getExtension('WEBGL_compressed_texture_etc1');
			this.extCompressedTextureETC = this.getExtension('WEBGL_compressed_texture_etc');
			this.extCompressedTexturePVRTC = this.getExtension('WEBGL_compressed_texture_pvrtc', 'WEBKIT_WEBGL_compressed_texture_pvrtc');
			this.extCompressedTextureS3TC = this.getExtension('WEBGL_compressed_texture_s3tc', 'WEBKIT_WEBGL_compressed_texture_s3tc');
			this.extCompressedTextureATC = this.getExtension('WEBGL_compressed_texture_atc');
			this.extCompressedTextureASTC = this.getExtension('WEBGL_compressed_texture_astc');
			this.extParallelShaderCompile = this.getExtension('KHR_parallel_shader_compile');
			this.extColorBufferHalfFloat = this.getExtension("EXT_color_buffer_half_float");
		};
		_proto.initializeCapabilities = function initializeCapabilities() {
			var _contextAttribs$antia, _contextAttribs$stenc;
			var gl = this.gl;
			var ext;
			var userAgent = typeof navigator !== 'undefined' ? navigator.userAgent : "";
			this.maxPrecision = this.precision = this.getPrecision();
			var contextAttribs = gl.getContextAttributes();
			this.supportsMsaa = (_contextAttribs$antia = contextAttribs == null ? void 0 : contextAttribs.antialias) != null ? _contextAttribs$antia : false;
			this.supportsStencil = (_contextAttribs$stenc = contextAttribs == null ? void 0 : contextAttribs.stencil) != null ? _contextAttribs$stenc : false;
			this.supportsInstancing = !!this.extInstancing;
			this.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
			this.maxCubeMapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
			this.maxRenderBufferSize = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);
			this.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
			this.maxCombinedTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
			this.maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
			this.vertexUniformsCount = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
			this.fragmentUniformsCount = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
			if (this.isWebGL2) {
				this.maxDrawBuffers = gl.getParameter(gl.MAX_DRAW_BUFFERS);
				this.maxColorAttachments = gl.getParameter(gl.MAX_COLOR_ATTACHMENTS);
				this.maxVolumeSize = gl.getParameter(gl.MAX_3D_TEXTURE_SIZE);
				this.supportsMrt = true;
				this.supportsVolumeTextures = true;
			} else {
				ext = this.extDrawBuffers;
				this.supportsMrt = !!ext;
				this.maxDrawBuffers = ext ? gl.getParameter(ext.MAX_DRAW_BUFFERS_WEBGL) : 1;
				this.maxColorAttachments = ext ? gl.getParameter(ext.MAX_COLOR_ATTACHMENTS_WEBGL) : 1;
				this.maxVolumeSize = 1;
			}
			ext = this.extDebugRendererInfo;
			this.unmaskedRenderer = ext ? gl.getParameter(ext.UNMASKED_RENDERER_WEBGL) : '';
			this.unmaskedVendor = ext ? gl.getParameter(ext.UNMASKED_VENDOR_WEBGL) : '';
			var maliRendererRegex = /\bMali-G52+/;
			var samsungModelRegex = /SM-[a-zA-Z0-9]+/;
			this.supportsGpuParticles = !(this.unmaskedVendor === 'ARM' && userAgent.match(samsungModelRegex)) && !this.unmaskedRenderer.match(maliRendererRegex);
			ext = this.extTextureFilterAnisotropic;
			this.maxAnisotropy = ext ? gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1;
			var antialiasSupported = this.isWebGL2 && !this.forceDisableMultisampling;
			this.maxSamples = antialiasSupported ? gl.getParameter(gl.MAX_SAMPLES) : 1;
			this.maxSamples = Math.min(this.maxSamples, 4);
			this.samples = antialiasSupported && this.backBufferAntialias ? this.maxSamples : 1;
			this.supportsAreaLights = this.isWebGL2 || !platform.android;
			this.supportsTextureFetch = this.isWebGL2;
			if (this.maxTextures <= 8) {
				this.supportsAreaLights = false;
			}
		};
		_proto.initializeRenderState = function initializeRenderState() {
			_GraphicsDevice.prototype.initializeRenderState.call(this);
			var gl = this.gl;
			gl.disable(gl.BLEND);
			gl.blendFunc(gl.ONE, gl.ZERO);
			gl.blendEquation(gl.FUNC_ADD);
			gl.colorMask(true, true, true, true);
			this.blendColor = new Color(0, 0, 0, 0);
			gl.blendColor(0, 0, 0, 0);
			gl.enable(gl.CULL_FACE);
			gl.cullFace(gl.BACK);
			gl.enable(gl.DEPTH_TEST);
			gl.depthFunc(gl.LEQUAL);
			gl.depthMask(true);
			this.stencil = false;
			gl.disable(gl.STENCIL_TEST);
			this.stencilFuncFront = this.stencilFuncBack = FUNC_ALWAYS;
			this.stencilRefFront = this.stencilRefBack = 0;
			this.stencilMaskFront = this.stencilMaskBack = 0xFF;
			gl.stencilFunc(gl.ALWAYS, 0, 0xFF);
			this.stencilFailFront = this.stencilFailBack = STENCILOP_KEEP;
			this.stencilZfailFront = this.stencilZfailBack = STENCILOP_KEEP;
			this.stencilZpassFront = this.stencilZpassBack = STENCILOP_KEEP;
			this.stencilWriteMaskFront = 0xFF;
			this.stencilWriteMaskBack = 0xFF;
			gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
			gl.stencilMask(0xFF);
			this.alphaToCoverage = false;
			this.raster = true;
			if (this.isWebGL2) {
				gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
				gl.disable(gl.RASTERIZER_DISCARD);
			}
			this.depthBiasEnabled = false;
			gl.disable(gl.POLYGON_OFFSET_FILL);
			this.clearDepth = 1;
			gl.clearDepth(1);
			this.clearColor = new Color(0, 0, 0, 0);
			gl.clearColor(0, 0, 0, 0);
			this.clearStencil = 0;
			gl.clearStencil(0);
			if (this.isWebGL2) {
				gl.hint(gl.FRAGMENT_SHADER_DERIVATIVE_HINT, gl.NICEST);
			} else {
				if (this.extStandardDerivatives) {
					gl.hint(this.extStandardDerivatives.FRAGMENT_SHADER_DERIVATIVE_HINT_OES, gl.NICEST);
				}
			}
			gl.enable(gl.SCISSOR_TEST);
			gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
			this.unpackFlipY = false;
			gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
			this.unpackPremultiplyAlpha = false;
			gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
			gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
		};
		_proto.initTextureUnits = function initTextureUnits(count) {
			if (count === void 0) {
				count = 16;
			}
			this.textureUnits = [];
			for (var i = 0; i < count; i++) {
				this.textureUnits.push([null, null, null]);
			}
		};
		_proto.initializeContextCaches = function initializeContextCaches() {
			_GraphicsDevice.prototype.initializeContextCaches.call(this);
			this._vaoMap = new Map();
			this.boundVao = null;
			this.activeFramebuffer = null;
			this.feedback = null;
			this.transformFeedbackBuffer = null;
			this.textureUnit = 0;
			this.initTextureUnits(this.maxCombinedTextures);
		};
		_proto.loseContext = function loseContext() {
			var _this$gpuProfiler;
			this.backBufferSize.set(-1, -1);
			for (var _iterator = _createForOfIteratorHelperLoose(this.shaders), _step; !(_step = _iterator()).done;) {
				var shader = _step.value;
				shader.loseContext();
			}
			for (var _iterator2 = _createForOfIteratorHelperLoose(this.textures), _step2; !(_step2 = _iterator2()).done;) {
				var texture = _step2.value;
				texture.loseContext();
			}
			for (var _iterator3 = _createForOfIteratorHelperLoose(this.buffers), _step3; !(_step3 = _iterator3()).done;) {
				var buffer = _step3.value;
				buffer.loseContext();
			}
			for (var _iterator4 = _createForOfIteratorHelperLoose(this.targets), _step4; !(_step4 = _iterator4()).done;) {
				var target = _step4.value;
				target.loseContext();
			}
			(_this$gpuProfiler = this.gpuProfiler) == null || _this$gpuProfiler.loseContext();
		};
		_proto.restoreContext = function restoreContext() {
			var _this$gpuProfiler2;
			this.initializeExtensions();
			this.initializeCapabilities();
			this.initializeRenderState();
			this.initializeContextCaches();
			for (var _iterator5 = _createForOfIteratorHelperLoose(this.shaders), _step5; !(_step5 = _iterator5()).done;) {
				var shader = _step5.value;
				shader.restoreContext();
			}
			for (var _iterator6 = _createForOfIteratorHelperLoose(this.buffers), _step6; !(_step6 = _iterator6()).done;) {
				var buffer = _step6.value;
				buffer.unlock();
			}
			(_this$gpuProfiler2 = this.gpuProfiler) == null || _this$gpuProfiler2.restoreContext();
		};
		_proto.endShaderBatch = function endShaderBatch() {
			WebglShader.endShaderBatch(this);
		};
		_proto.setViewport = function setViewport(x, y, w, h) {
			if (this.vx !== x || this.vy !== y || this.vw !== w || this.vh !== h) {
				this.gl.viewport(x, y, w, h);
				this.vx = x;
				this.vy = y;
				this.vw = w;
				this.vh = h;
			}
		};
		_proto.setScissor = function setScissor(x, y, w, h) {
			if (this.sx !== x || this.sy !== y || this.sw !== w || this.sh !== h) {
				this.gl.scissor(x, y, w, h);
				this.sx = x;
				this.sy = y;
				this.sw = w;
				this.sh = h;
			}
		};
		_proto.setFramebuffer = function setFramebuffer(fb) {
			if (this.activeFramebuffer !== fb) {
				var gl = this.gl;
				gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
				this.activeFramebuffer = fb;
			}
		};
		_proto.copyRenderTarget = function copyRenderTarget(source, dest, color, depth) {
			var gl = this.gl;
			if (source === this.backBuffer) {
				source = null;
			}
			if (!this.isWebGL2 && depth) {
				return false;
			}
			if (color) {
				if (!dest) {
					if (!source._colorBuffer) {
						return false;
					}
				} else if (source) {
					if (!source._colorBuffer || !dest._colorBuffer) {
						return false;
					}
					if (source._colorBuffer._format !== dest._colorBuffer._format) {
						return false;
					}
				}
			}
			if (depth && source) {
				if (!source._depth) {
					if (!source._depthBuffer || !dest._depthBuffer) {
						return false;
					}
					if (source._depthBuffer._format !== dest._depthBuffer._format) {
						return false;
					}
				}
			}
			if (this.isWebGL2 && dest) {
				var _this$backBuffer;
				var prevRt = this.renderTarget;
				this.renderTarget = dest;
				this.updateBegin();
				var src = source ? source.impl._glFrameBuffer : (_this$backBuffer = this.backBuffer) == null ? void 0 : _this$backBuffer.impl._glFrameBuffer;
				var dst = dest.impl._glFrameBuffer;
				gl.bindFramebuffer(gl.READ_FRAMEBUFFER, src);
				gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, dst);
				var w = source ? source.width : dest.width;
				var h = source ? source.height : dest.height;
				gl.blitFramebuffer(0, 0, w, h, 0, 0, w, h, (color ? gl.COLOR_BUFFER_BIT : 0) | (depth ? gl.DEPTH_BUFFER_BIT : 0), gl.NEAREST);
				this.renderTarget = prevRt;
				gl.bindFramebuffer(gl.FRAMEBUFFER, prevRt ? prevRt.impl._glFrameBuffer : null);
			} else {
				var shader = this.getCopyShader();
				this.constantTexSource.setValue(source._colorBuffer);
				quadWithShader(this, dest, shader);
			}
			return true;
		};
		_proto.getCopyShader = function getCopyShader() {
			if (!this._copyShader) {
				this._copyShader = new Shader(this, ShaderUtils.createDefinition(this, {
					name: 'outputTex2D',
					vertexCode: _fullScreenQuadVS,
					fragmentCode: _outputTexture2D
				}));
			}
			return this._copyShader;
		};
		_proto.frameStart = function frameStart() {
			_GraphicsDevice.prototype.frameStart.call(this);
			this.updateBackbuffer();
			this.gpuProfiler.frameStart();
		};
		_proto.frameEnd = function frameEnd() {
			_GraphicsDevice.prototype.frameEnd.call(this);
			this.gpuProfiler.frameEnd();
			this.gpuProfiler.request();
		};
		_proto.startRenderPass = function startRenderPass(renderPass) {
			var _renderPass$renderTar;
			var rt = (_renderPass$renderTar = renderPass.renderTarget) != null ? _renderPass$renderTar : this.backBuffer;
			this.renderTarget = rt;
			this.updateBegin();
			var width = rt.width,
				height = rt.height;
			this.setViewport(0, 0, width, height);
			this.setScissor(0, 0, width, height);
			var colorOps = renderPass.colorOps;
			var depthStencilOps = renderPass.depthStencilOps;
			if (colorOps != null && colorOps.clear || depthStencilOps.clearDepth || depthStencilOps.clearStencil) {
				var clearFlags = 0;
				var clearOptions = {};
				if (colorOps != null && colorOps.clear) {
					clearFlags |= CLEARFLAG_COLOR;
					clearOptions.color = [colorOps.clearValue.r, colorOps.clearValue.g, colorOps.clearValue.b, colorOps.clearValue.a];
				}
				if (depthStencilOps.clearDepth) {
					clearFlags |= CLEARFLAG_DEPTH;
					clearOptions.depth = depthStencilOps.clearDepthValue;
				}
				if (depthStencilOps.clearStencil) {
					clearFlags |= CLEARFLAG_STENCIL;
					clearOptions.stencil = depthStencilOps.clearStencilValue;
				}
				clearOptions.flags = clearFlags;
				this.clear(clearOptions);
			}
			this.insideRenderPass = true;
		};
		_proto.endRenderPass = function endRenderPass(renderPass) {
			this.unbindVertexArray();
			var target = this.renderTarget;
			var colorBufferCount = renderPass.colorArrayOps.length;
			if (target) {
				var _renderPass$colorOps;
				if (this.isWebGL2) {
					invalidateAttachments.length = 0;
					var gl = this.gl;
					for (var i = 0; i < colorBufferCount; i++) {
						var colorOps = renderPass.colorArrayOps[i];
						if (!(colorOps.store || colorOps.resolve)) {
							invalidateAttachments.push(gl.COLOR_ATTACHMENT0 + i);
						}
					}
					if (target !== this.backBuffer) {
						if (!renderPass.depthStencilOps.storeDepth) {
							invalidateAttachments.push(gl.DEPTH_ATTACHMENT);
						}
						if (!renderPass.depthStencilOps.storeStencil) {
							invalidateAttachments.push(gl.STENCIL_ATTACHMENT);
						}
					}
					if (invalidateAttachments.length > 0) {
						if (renderPass.fullSizeClearRect) {
							gl.invalidateFramebuffer(gl.DRAW_FRAMEBUFFER, invalidateAttachments);
						}
					}
				}
				if ((_renderPass$colorOps = renderPass.colorOps) != null && _renderPass$colorOps.resolve) {
					if (this.isWebGL2 && renderPass.samples > 1 && target.autoResolve) {
						target.resolve(true, false);
					}
				}
				for (var _i = 0; _i < colorBufferCount; _i++) {
					var _colorOps = renderPass.colorArrayOps[_i];
					if (_colorOps.mipmaps) {
						var colorBuffer = target._colorBuffers[_i];
						if (colorBuffer && colorBuffer.impl._glTexture && colorBuffer.mipmaps && (colorBuffer.pot || this.isWebGL2)) {
							this.activeTexture(this.maxCombinedTextures - 1);
							this.bindTexture(colorBuffer);
							this.gl.generateMipmap(colorBuffer.impl._glTarget);
						}
					}
				}
			}
			this.insideRenderPass = false;
		};
		_proto.updateBegin = function updateBegin() {
			var _this$renderTarget;
			this.boundVao = null;
			if (this._tempEnableSafariTextureUnitWorkaround) {
				for (var unit = 0; unit < this.textureUnits.length; ++unit) {
					for (var slot = 0; slot < 3; ++slot) {
						this.textureUnits[unit][slot] = null;
					}
				}
			}
			var target = (_this$renderTarget = this.renderTarget) != null ? _this$renderTarget : this.backBuffer;
			var targetImpl = target.impl;
			if (!targetImpl.initialized) {
				this.initRenderTarget(target);
			}
			this.setFramebuffer(targetImpl._glFrameBuffer);
		};
		_proto.updateEnd = function updateEnd() {
			this.unbindVertexArray();
			var target = this.renderTarget;
			if (target && target !== this.backBuffer) {
				if (this.isWebGL2 && target._samples > 1 && target.autoResolve) {
					target.resolve();
				}
				var colorBuffer = target._colorBuffer;
				if (colorBuffer && colorBuffer.impl._glTexture && colorBuffer.mipmaps && (colorBuffer.pot || this.isWebGL2)) {
					this.activeTexture(this.maxCombinedTextures - 1);
					this.bindTexture(colorBuffer);
					this.gl.generateMipmap(colorBuffer.impl._glTarget);
				}
			}
		};
		_proto.setUnpackFlipY = function setUnpackFlipY(flipY) {
			if (this.unpackFlipY !== flipY) {
				this.unpackFlipY = flipY;
				var gl = this.gl;
				gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
			}
		};
		_proto.setUnpackPremultiplyAlpha = function setUnpackPremultiplyAlpha(premultiplyAlpha) {
			if (this.unpackPremultiplyAlpha !== premultiplyAlpha) {
				this.unpackPremultiplyAlpha = premultiplyAlpha;
				var gl = this.gl;
				gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiplyAlpha);
			}
		};
		_proto.activeTexture = function activeTexture(textureUnit) {
			if (this.textureUnit !== textureUnit) {
				this.gl.activeTexture(this.gl.TEXTURE0 + textureUnit);
				this.textureUnit = textureUnit;
			}
		};
		_proto.bindTexture = function bindTexture(texture) {
			var impl = texture.impl;
			var textureTarget = impl._glTarget;
			var textureObject = impl._glTexture;
			var textureUnit = this.textureUnit;
			var slot = this.targetToSlot[textureTarget];
			if (this.textureUnits[textureUnit][slot] !== textureObject) {
				this.gl.bindTexture(textureTarget, textureObject);
				this.textureUnits[textureUnit][slot] = textureObject;
			}
		};
		_proto.bindTextureOnUnit = function bindTextureOnUnit(texture, textureUnit) {
			var impl = texture.impl;
			var textureTarget = impl._glTarget;
			var textureObject = impl._glTexture;
			var slot = this.targetToSlot[textureTarget];
			if (this.textureUnits[textureUnit][slot] !== textureObject) {
				this.activeTexture(textureUnit);
				this.gl.bindTexture(textureTarget, textureObject);
				this.textureUnits[textureUnit][slot] = textureObject;
			}
		};
		_proto.setTextureParameters = function setTextureParameters(texture) {
			var gl = this.gl;
			var flags = texture.impl.dirtyParameterFlags;
			var target = texture.impl._glTarget;
			if (flags & 1) {
				var filter = texture._minFilter;
				if (!texture.pot && !this.isWebGL2 || !texture._mipmaps || texture._compressed && texture._levels.length === 1) {
					if (filter === FILTER_NEAREST_MIPMAP_NEAREST || filter === FILTER_NEAREST_MIPMAP_LINEAR) {
						filter = FILTER_NEAREST;
					} else if (filter === FILTER_LINEAR_MIPMAP_NEAREST || filter === FILTER_LINEAR_MIPMAP_LINEAR) {
						filter = FILTER_LINEAR;
					}
				}
				gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, this.glFilter[filter]);
			}
			if (flags & 2) {
				gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, this.glFilter[texture._magFilter]);
			}
			if (flags & 4) {
				if (this.isWebGL2) {
					gl.texParameteri(target, gl.TEXTURE_WRAP_S, this.glAddress[texture._addressU]);
				} else {
					gl.texParameteri(target, gl.TEXTURE_WRAP_S, this.glAddress[texture.pot ? texture._addressU : ADDRESS_CLAMP_TO_EDGE]);
				}
			}
			if (flags & 8) {
				if (this.isWebGL2) {
					gl.texParameteri(target, gl.TEXTURE_WRAP_T, this.glAddress[texture._addressV]);
				} else {
					gl.texParameteri(target, gl.TEXTURE_WRAP_T, this.glAddress[texture.pot ? texture._addressV : ADDRESS_CLAMP_TO_EDGE]);
				}
			}
			if (flags & 16) {
				if (this.isWebGL2) {
					gl.texParameteri(target, gl.TEXTURE_WRAP_R, this.glAddress[texture._addressW]);
				}
			}
			if (flags & 32) {
				if (this.isWebGL2) {
					gl.texParameteri(target, gl.TEXTURE_COMPARE_MODE, texture._compareOnRead ? gl.COMPARE_REF_TO_TEXTURE : gl.NONE);
				}
			}
			if (flags & 64) {
				if (this.isWebGL2) {
					gl.texParameteri(target, gl.TEXTURE_COMPARE_FUNC, this.glComparison[texture._compareFunc]);
				}
			}
			if (flags & 128) {
				var ext = this.extTextureFilterAnisotropic;
				if (ext) {
					gl.texParameterf(target, ext.TEXTURE_MAX_ANISOTROPY_EXT, math.clamp(Math.round(texture._anisotropy), 1, this.maxAnisotropy));
				}
			}
		};
		_proto.setTexture = function setTexture(texture, textureUnit) {
			var impl = texture.impl;
			if (!impl._glTexture) impl.initialize(this, texture);
			if (impl.dirtyParameterFlags > 0 || texture._needsUpload || texture._needsMipmapsUpload) {
				this.activeTexture(textureUnit);
				this.bindTexture(texture);
				if (impl.dirtyParameterFlags) {
					this.setTextureParameters(texture);
					impl.dirtyParameterFlags = 0;
				}
				if (texture._needsUpload || texture._needsMipmapsUpload) {
					impl.upload(this, texture);
					texture._needsUpload = false;
					texture._needsMipmapsUpload = false;
				}
			} else {
				this.bindTextureOnUnit(texture, textureUnit);
			}
		};
		_proto.createVertexArray = function createVertexArray(vertexBuffers) {
			var key, vao;
			var useCache = vertexBuffers.length > 1;
			if (useCache) {
				key = "";
				for (var i = 0; i < vertexBuffers.length; i++) {
					var vertexBuffer = vertexBuffers[i];
					key += vertexBuffer.id + vertexBuffer.format.renderingHash;
				}
				vao = this._vaoMap.get(key);
			}
			if (!vao) {
				var gl = this.gl;
				vao = gl.createVertexArray();
				gl.bindVertexArray(vao);
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
				for (var _i2 = 0; _i2 < vertexBuffers.length; _i2++) {
					var _vertexBuffer = vertexBuffers[_i2];
					gl.bindBuffer(gl.ARRAY_BUFFER, _vertexBuffer.impl.bufferId);
					var elements = _vertexBuffer.format.elements;
					for (var j = 0; j < elements.length; j++) {
						var e = elements[j];
						var loc = semanticToLocation[e.name];
						if (e.asInt) {
							gl.vertexAttribIPointer(loc, e.numComponents, this.glType[e.dataType], e.stride, e.offset);
						} else {
							gl.vertexAttribPointer(loc, e.numComponents, this.glType[e.dataType], e.normalize, e.stride, e.offset);
						}
						gl.enableVertexAttribArray(loc);
						if (_vertexBuffer.format.instancing) {
							gl.vertexAttribDivisor(loc, 1);
						}
					}
				}
				gl.bindVertexArray(null);
				gl.bindBuffer(gl.ARRAY_BUFFER, null);
				if (useCache) {
					this._vaoMap.set(key, vao);
				}
			}
			return vao;
		};
		_proto.unbindVertexArray = function unbindVertexArray() {
			if (this.boundVao) {
				this.boundVao = null;
				this.gl.bindVertexArray(null);
			}
		};
		_proto.setBuffers = function setBuffers() {
			var gl = this.gl;
			var vao;
			if (this.vertexBuffers.length === 1) {
				var vertexBuffer = this.vertexBuffers[0];
				if (!vertexBuffer.impl.vao) {
					vertexBuffer.impl.vao = this.createVertexArray(this.vertexBuffers);
				}
				vao = vertexBuffer.impl.vao;
			} else {
				vao = this.createVertexArray(this.vertexBuffers);
			}
			if (this.boundVao !== vao) {
				this.boundVao = vao;
				gl.bindVertexArray(vao);
			}
			this.vertexBuffers.length = 0;
			var bufferId = this.indexBuffer ? this.indexBuffer.impl.bufferId : null;
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufferId);
		};
		_proto.draw = function draw(primitive, numInstances, keepBuffers) {
			var gl = this.gl;
			var sampler, samplerValue, texture, numTextures;
			var uniform, scopeId, uniformVersion, programVersion;
			var shader = this.shader;
			if (!shader) return;
			var samplers = shader.impl.samplers;
			var uniforms = shader.impl.uniforms;
			if (!keepBuffers) {
				this.setBuffers();
			}
			var textureUnit = 0;
			for (var i = 0, len = samplers.length; i < len; i++) {
				sampler = samplers[i];
				samplerValue = sampler.scopeId.value;
				if (!samplerValue) {
					return;
				}
				if (samplerValue instanceof Texture) {
					texture = samplerValue;
					this.setTexture(texture, textureUnit);
					if (sampler.slot !== textureUnit) {
						gl.uniform1i(sampler.locationId, textureUnit);
						sampler.slot = textureUnit;
					}
					textureUnit++;
				} else {
					sampler.array.length = 0;
					numTextures = samplerValue.length;
					for (var j = 0; j < numTextures; j++) {
						texture = samplerValue[j];
						this.setTexture(texture, textureUnit);
						sampler.array[j] = textureUnit;
						textureUnit++;
					}
					gl.uniform1iv(sampler.locationId, sampler.array);
				}
			}
			for (var _i3 = 0, _len = uniforms.length; _i3 < _len; _i3++) {
				uniform = uniforms[_i3];
				scopeId = uniform.scopeId;
				uniformVersion = uniform.version;
				programVersion = scopeId.versionObject.version;
				if (uniformVersion.globalId !== programVersion.globalId || uniformVersion.revision !== programVersion.revision) {
					uniformVersion.globalId = programVersion.globalId;
					uniformVersion.revision = programVersion.revision;
					if (scopeId.value !== null) {
						this.commitFunction[uniform.dataType](uniform, scopeId.value);
					}
				}
			}
			if (this.isWebGL2 && this.transformFeedbackBuffer) {
				gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, this.transformFeedbackBuffer.impl.bufferId);
				gl.beginTransformFeedback(gl.POINTS);
			}
			var mode = this.glPrimitive[primitive.type];
			var count = primitive.count;
			if (primitive.indexed) {
				var indexBuffer = this.indexBuffer;
				var format = indexBuffer.impl.glFormat;
				var offset = primitive.base * indexBuffer.bytesPerIndex;
				if (numInstances > 0) {
					gl.drawElementsInstanced(mode, count, format, offset, numInstances);
				} else {
					gl.drawElements(mode, count, format, offset);
				}
			} else {
				var first = primitive.base;
				if (numInstances > 0) {
					gl.drawArraysInstanced(mode, first, count, numInstances);
				} else {
					gl.drawArrays(mode, first, count);
				}
			}
			if (this.isWebGL2 && this.transformFeedbackBuffer) {
				gl.endTransformFeedback();
				gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, null);
			}
			this._drawCallsPerFrame++;
		};
		_proto.clear = function clear(options) {
			var _options$flags;
			var defaultOptions = this.defaultClearOptions;
			options = options || defaultOptions;
			var flags = (_options$flags = options.flags) != null ? _options$flags : defaultOptions.flags;
			if (flags !== 0) {
				var gl = this.gl;
				if (flags & CLEARFLAG_COLOR) {
					var _options$color;
					var color = (_options$color = options.color) != null ? _options$color : defaultOptions.color;
					var r = color[0];
					var g = color[1];
					var b = color[2];
					var a = color[3];
					var c = this.clearColor;
					if (r !== c.r || g !== c.g || b !== c.b || a !== c.a) {
						this.gl.clearColor(r, g, b, a);
						this.clearColor.set(r, g, b, a);
					}
					this.setBlendState(BlendState.NOBLEND);
				}
				if (flags & CLEARFLAG_DEPTH) {
					var _options$depth;
					var depth = (_options$depth = options.depth) != null ? _options$depth : defaultOptions.depth;
					if (depth !== this.clearDepth) {
						this.gl.clearDepth(depth);
						this.clearDepth = depth;
					}
					this.setDepthState(DepthState.WRITEDEPTH);
				}
				if (flags & CLEARFLAG_STENCIL) {
					var _options$stencil;
					var stencil = (_options$stencil = options.stencil) != null ? _options$stencil : defaultOptions.stencil;
					if (stencil !== this.clearStencil) {
						this.gl.clearStencil(stencil);
						this.clearStencil = stencil;
					}
				}
				gl.clear(this.glClearFlag[flags]);
			}
		};
		_proto.submit = function submit() {
			this.gl.flush();
		};
		_proto.readPixels = function readPixels(x, y, w, h, pixels) {
			var gl = this.gl;
			gl.readPixels(x, y, w, h, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
		};
		_proto.readPixelsAsync = function () {
			var _readPixelsAsync = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(x, y, w, h, pixels) {
				var _this2 = this,
					_this$renderTarget$co,
					_impl$_glFormat,
					_impl$_glPixelType;
				var gl, clientWaitAsync, impl, format, pixelType, buf;
				return _regeneratorRuntime().wrap(function _callee$(_context) {
					while (1) switch (_context.prev = _context.next) {
						case 0:
							gl = this.gl;
							if (this.isWebGL2) {
								_context.next = 4;
								break;
							}
							this.readPixels(x, y, w, h, pixels);
							return _context.abrupt("return");
						case 4:
							clientWaitAsync = function clientWaitAsync(flags, interval_ms) {
								var sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
								_this2.submit();
								return new Promise(function (resolve, reject) {
									function test() {
										var res = gl.clientWaitSync(sync, flags, 0);
										if (res === gl.WAIT_FAILED) {
											gl.deleteSync(sync);
											reject(new Error('webgl clientWaitSync sync failed'));
										} else if (res === gl.TIMEOUT_EXPIRED) {
											setTimeout(test, interval_ms);
										} else {
											gl.deleteSync(sync);
											resolve();
										}
									}
									test();
								});
							};
							impl = (_this$renderTarget$co = this.renderTarget.colorBuffer) == null ? void 0 : _this$renderTarget$co.impl;
							format = (_impl$_glFormat = impl == null ? void 0 : impl._glFormat) != null ? _impl$_glFormat : gl.RGBA;
							pixelType = (_impl$_glPixelType = impl == null ? void 0 : impl._glPixelType) != null ? _impl$_glPixelType : gl.UNSIGNED_BYTE;
							buf = gl.createBuffer();
							gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buf);
							gl.bufferData(gl.PIXEL_PACK_BUFFER, pixels.byteLength, gl.STREAM_READ);
							gl.readPixels(x, y, w, h, format, pixelType, 0);
							gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
							_context.next = 15;
							return clientWaitAsync(0, 20);
						case 15:
							gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buf);
							gl.getBufferSubData(gl.PIXEL_PACK_BUFFER, 0, pixels);
							gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
							gl.deleteBuffer(buf);
						case 19:
						case "end":
							return _context.stop();
					}
				}, _callee, this);
			}));
			function readPixelsAsync(_x, _x2, _x3, _x4, _x5) {
				return _readPixelsAsync.apply(this, arguments);
			}
			return readPixelsAsync;
		}();
		_proto.setAlphaToCoverage = function setAlphaToCoverage(state) {
			if (this.isWebGL1) return;
			if (this.alphaToCoverage === state) return;
			this.alphaToCoverage = state;
			if (state) {
				this.gl.enable(this.gl.SAMPLE_ALPHA_TO_COVERAGE);
			} else {
				this.gl.disable(this.gl.SAMPLE_ALPHA_TO_COVERAGE);
			}
		};
		_proto.setTransformFeedbackBuffer = function setTransformFeedbackBuffer(tf) {
			if (this.transformFeedbackBuffer === tf) return;
			this.transformFeedbackBuffer = tf;
			if (this.isWebGL2) {
				var _gl = this.gl;
				if (tf) {
					if (!this.feedback) {
						this.feedback = _gl.createTransformFeedback();
					}
					_gl.bindTransformFeedback(_gl.TRANSFORM_FEEDBACK, this.feedback);
				} else {
					_gl.bindTransformFeedback(_gl.TRANSFORM_FEEDBACK, null);
				}
			}
		};
		_proto.setRaster = function setRaster(on) {
			if (this.raster === on) return;
			this.raster = on;
			if (this.isWebGL2) {
				if (on) {
					this.gl.disable(this.gl.RASTERIZER_DISCARD);
				} else {
					this.gl.enable(this.gl.RASTERIZER_DISCARD);
				}
			}
		};
		_proto.setDepthBias = function setDepthBias(on) {
			if (this.depthBiasEnabled === on) return;
			this.depthBiasEnabled = on;
			if (on) {
				this.gl.enable(this.gl.POLYGON_OFFSET_FILL);
			} else {
				this.gl.disable(this.gl.POLYGON_OFFSET_FILL);
			}
		};
		_proto.setDepthBiasValues = function setDepthBiasValues(constBias, slopeBias) {
			this.gl.polygonOffset(slopeBias, constBias);
		};
		_proto.setStencilTest = function setStencilTest(enable) {
			if (this.stencil !== enable) {
				var _gl2 = this.gl;
				if (enable) {
					_gl2.enable(_gl2.STENCIL_TEST);
				} else {
					_gl2.disable(_gl2.STENCIL_TEST);
				}
				this.stencil = enable;
			}
		};
		_proto.setStencilFunc = function setStencilFunc(func, ref, mask) {
			if (this.stencilFuncFront !== func || this.stencilRefFront !== ref || this.stencilMaskFront !== mask || this.stencilFuncBack !== func || this.stencilRefBack !== ref || this.stencilMaskBack !== mask) {
				this.gl.stencilFunc(this.glComparison[func], ref, mask);
				this.stencilFuncFront = this.stencilFuncBack = func;
				this.stencilRefFront = this.stencilRefBack = ref;
				this.stencilMaskFront = this.stencilMaskBack = mask;
			}
		};
		_proto.setStencilFuncFront = function setStencilFuncFront(func, ref, mask) {
			if (this.stencilFuncFront !== func || this.stencilRefFront !== ref || this.stencilMaskFront !== mask) {
				var _gl3 = this.gl;
				_gl3.stencilFuncSeparate(_gl3.FRONT, this.glComparison[func], ref, mask);
				this.stencilFuncFront = func;
				this.stencilRefFront = ref;
				this.stencilMaskFront = mask;
			}
		};
		_proto.setStencilFuncBack = function setStencilFuncBack(func, ref, mask) {
			if (this.stencilFuncBack !== func || this.stencilRefBack !== ref || this.stencilMaskBack !== mask) {
				var _gl4 = this.gl;
				_gl4.stencilFuncSeparate(_gl4.BACK, this.glComparison[func], ref, mask);
				this.stencilFuncBack = func;
				this.stencilRefBack = ref;
				this.stencilMaskBack = mask;
			}
		};
		_proto.setStencilOperation = function setStencilOperation(fail, zfail, zpass, writeMask) {
			if (this.stencilFailFront !== fail || this.stencilZfailFront !== zfail || this.stencilZpassFront !== zpass || this.stencilFailBack !== fail || this.stencilZfailBack !== zfail || this.stencilZpassBack !== zpass) {
				this.gl.stencilOp(this.glStencilOp[fail], this.glStencilOp[zfail], this.glStencilOp[zpass]);
				this.stencilFailFront = this.stencilFailBack = fail;
				this.stencilZfailFront = this.stencilZfailBack = zfail;
				this.stencilZpassFront = this.stencilZpassBack = zpass;
			}
			if (this.stencilWriteMaskFront !== writeMask || this.stencilWriteMaskBack !== writeMask) {
				this.gl.stencilMask(writeMask);
				this.stencilWriteMaskFront = writeMask;
				this.stencilWriteMaskBack = writeMask;
			}
		};
		_proto.setStencilOperationFront = function setStencilOperationFront(fail, zfail, zpass, writeMask) {
			if (this.stencilFailFront !== fail || this.stencilZfailFront !== zfail || this.stencilZpassFront !== zpass) {
				this.gl.stencilOpSeparate(this.gl.FRONT, this.glStencilOp[fail], this.glStencilOp[zfail], this.glStencilOp[zpass]);
				this.stencilFailFront = fail;
				this.stencilZfailFront = zfail;
				this.stencilZpassFront = zpass;
			}
			if (this.stencilWriteMaskFront !== writeMask) {
				this.gl.stencilMaskSeparate(this.gl.FRONT, writeMask);
				this.stencilWriteMaskFront = writeMask;
			}
		};
		_proto.setStencilOperationBack = function setStencilOperationBack(fail, zfail, zpass, writeMask) {
			if (this.stencilFailBack !== fail || this.stencilZfailBack !== zfail || this.stencilZpassBack !== zpass) {
				this.gl.stencilOpSeparate(this.gl.BACK, this.glStencilOp[fail], this.glStencilOp[zfail], this.glStencilOp[zpass]);
				this.stencilFailBack = fail;
				this.stencilZfailBack = zfail;
				this.stencilZpassBack = zpass;
			}
			if (this.stencilWriteMaskBack !== writeMask) {
				this.gl.stencilMaskSeparate(this.gl.BACK, writeMask);
				this.stencilWriteMaskBack = writeMask;
			}
		};
		_proto.setBlendState = function setBlendState(blendState) {
			var currentBlendState = this.blendState;
			if (!currentBlendState.equals(blendState)) {
				var _gl5 = this.gl;
				var blend = blendState.blend,
					colorOp = blendState.colorOp,
					alphaOp = blendState.alphaOp,
					colorSrcFactor = blendState.colorSrcFactor,
					colorDstFactor = blendState.colorDstFactor,
					alphaSrcFactor = blendState.alphaSrcFactor,
					alphaDstFactor = blendState.alphaDstFactor;
				if (currentBlendState.blend !== blend) {
					if (blend) {
						_gl5.enable(_gl5.BLEND);
					} else {
						_gl5.disable(_gl5.BLEND);
					}
				}
				if (currentBlendState.colorOp !== colorOp || currentBlendState.alphaOp !== alphaOp) {
					var glBlendEquation = this.glBlendEquation;
					_gl5.blendEquationSeparate(glBlendEquation[colorOp], glBlendEquation[alphaOp]);
				}
				if (currentBlendState.colorSrcFactor !== colorSrcFactor || currentBlendState.colorDstFactor !== colorDstFactor || currentBlendState.alphaSrcFactor !== alphaSrcFactor || currentBlendState.alphaDstFactor !== alphaDstFactor) {
					_gl5.blendFuncSeparate(this.glBlendFunctionColor[colorSrcFactor], this.glBlendFunctionColor[colorDstFactor], this.glBlendFunctionAlpha[alphaSrcFactor], this.glBlendFunctionAlpha[alphaDstFactor]);
				}
				if (currentBlendState.allWrite !== blendState.allWrite) {
					this.gl.colorMask(blendState.redWrite, blendState.greenWrite, blendState.blueWrite, blendState.alphaWrite);
				}
				currentBlendState.copy(blendState);
			}
		};
		_proto.setBlendColor = function setBlendColor(r, g, b, a) {
			var c = this.blendColor;
			if (r !== c.r || g !== c.g || b !== c.b || a !== c.a) {
				this.gl.blendColor(r, g, b, a);
				c.set(r, g, b, a);
			}
		};
		_proto.setStencilState = function setStencilState(stencilFront, stencilBack) {
			if (stencilFront || stencilBack) {
				this.setStencilTest(true);
				if (stencilFront === stencilBack) {
					this.setStencilFunc(stencilFront.func, stencilFront.ref, stencilFront.readMask);
					this.setStencilOperation(stencilFront.fail, stencilFront.zfail, stencilFront.zpass, stencilFront.writeMask);
				} else {
					var _stencilFront, _stencilBack;
					(_stencilFront = stencilFront) != null ? _stencilFront : stencilFront = StencilParameters.DEFAULT;
					this.setStencilFuncFront(stencilFront.func, stencilFront.ref, stencilFront.readMask);
					this.setStencilOperationFront(stencilFront.fail, stencilFront.zfail, stencilFront.zpass, stencilFront.writeMask);
					(_stencilBack = stencilBack) != null ? _stencilBack : stencilBack = StencilParameters.DEFAULT;
					this.setStencilFuncBack(stencilBack.func, stencilBack.ref, stencilBack.readMask);
					this.setStencilOperationBack(stencilBack.fail, stencilBack.zfail, stencilBack.zpass, stencilBack.writeMask);
				}
			} else {
				this.setStencilTest(false);
			}
		};
		_proto.setDepthState = function setDepthState(depthState) {
			var currentDepthState = this.depthState;
			if (!currentDepthState.equals(depthState)) {
				var _gl6 = this.gl;
				var write = depthState.write;
				if (currentDepthState.write !== write) {
					_gl6.depthMask(write);
				}
				var func = depthState.func,
					test = depthState.test;
				if (!test && write) {
					test = true;
					func = FUNC_ALWAYS;
				}
				if (currentDepthState.func !== func) {
					_gl6.depthFunc(this.glComparison[func]);
				}
				if (currentDepthState.test !== test) {
					if (test) {
						_gl6.enable(_gl6.DEPTH_TEST);
					} else {
						_gl6.disable(_gl6.DEPTH_TEST);
					}
				}
				currentDepthState.copy(depthState);
			}
		};
		_proto.setCullMode = function setCullMode(cullMode) {
			if (this.cullMode !== cullMode) {
				if (cullMode === CULLFACE_NONE) {
					this.gl.disable(this.gl.CULL_FACE);
				} else {
					if (this.cullMode === CULLFACE_NONE) {
						this.gl.enable(this.gl.CULL_FACE);
					}
					var mode = this.glCull[cullMode];
					if (this.cullFace !== mode) {
						this.gl.cullFace(mode);
						this.cullFace = mode;
					}
				}
				this.cullMode = cullMode;
			}
		};
		_proto.setShader = function setShader(shader) {
			if (shader !== this.shader) {
				if (shader.failed) {
					return false;
				} else if (!shader.ready && !shader.impl.finalize(this, shader)) {
					shader.failed = true;
					return false;
				}
				this.shader = shader;
				this.gl.useProgram(shader.impl.glProgram);
				this.attributesInvalidated = true;
			}
			return true;
		};
		_proto.clearVertexArrayObjectCache = function clearVertexArrayObjectCache() {
			var gl = this.gl;
			this._vaoMap.forEach(function (item, key, mapObj) {
				gl.deleteVertexArray(item);
			});
			this._vaoMap.clear();
		};
		_createClass(WebglGraphicsDevice, [{
			key: "extDisjointTimerQuery",
			get: function get() {
				if (!this._extDisjointTimerQuery) {
					if (this.isWebGL2) {
						this._extDisjointTimerQuery = this.getExtension('EXT_disjoint_timer_query_webgl2', 'EXT_disjoint_timer_query');
					}
				}
				return this._extDisjointTimerQuery;
			}
		}, {
			key: "defaultFramebuffer",
			get: function get() {
				return this._defaultFramebuffer;
			},
			set: function set(value) {
				if (this._defaultFramebuffer !== value) {
					this._defaultFramebuffer = value;
					this._defaultFramebufferChanged = true;
				}
			}
		}, {
			key: "fullscreen",
			get: function get() {
				return !!document.fullscreenElement;
			},
			set: function set(fullscreen) {
				if (fullscreen) {
					var canvas = this.gl.canvas;
					canvas.requestFullscreen();
				} else {
					document.exitFullscreen();
				}
			}
		}, {
			key: "textureFloatHighPrecision",
			get: function get() {
				if (this._textureFloatHighPrecision === undefined) {
					this._textureFloatHighPrecision = testTextureFloatHighPrecision(this);
				}
				return this._textureFloatHighPrecision;
			}
		}, {
			key: "textureHalfFloatUpdatable",
			get: function get() {
				if (this._textureHalfFloatUpdatable === undefined) {
					if (this.isWebGL2) {
						this._textureHalfFloatUpdatable = true;
					} else {
						this._textureHalfFloatUpdatable = testTextureHalfFloatUpdatable(this.gl, this.extTextureHalfFloat.HALF_FLOAT_OES);
					}
				}
				return this._textureHalfFloatUpdatable;
			}
		}]);
		return WebglGraphicsDevice;
	}(GraphicsDevice);

	var NullIndexBuffer = function () {
		function NullIndexBuffer() {}
		var _proto = NullIndexBuffer.prototype;
		_proto.unlock = function unlock(indexBuffer) {};
		return NullIndexBuffer;
	}();

	var NullRenderTarget = function () {
		function NullRenderTarget() {}
		var _proto = NullRenderTarget.prototype;
		_proto.destroy = function destroy(device) {};
		_proto.init = function init(device, renderTarget) {};
		_proto.loseContext = function loseContext() {};
		_proto.resolve = function resolve(device, target, color, depth) {};
		return NullRenderTarget;
	}();

	var NullShader = function () {
		function NullShader() {}
		var _proto = NullShader.prototype;
		_proto.destroy = function destroy(shader) {};
		_proto.loseContext = function loseContext() {};
		_proto.restoreContext = function restoreContext(device, shader) {};
		return NullShader;
	}();

	var NullTexture = function () {
		function NullTexture() {}
		var _proto = NullTexture.prototype;
		_proto.destroy = function destroy(device) {};
		_proto.propertyChanged = function propertyChanged(flag) {};
		_proto.loseContext = function loseContext() {};
		return NullTexture;
	}();

	var NullVertexBuffer = function () {
		function NullVertexBuffer() {}
		var _proto = NullVertexBuffer.prototype;
		_proto.destroy = function destroy(device) {};
		_proto.unlock = function unlock(vertexBuffer) {};
		return NullVertexBuffer;
	}();

	var NullGraphicsDevice = function (_GraphicsDevice) {
		_inheritsLoose(NullGraphicsDevice, _GraphicsDevice);
		function NullGraphicsDevice(canvas, options) {
			var _this;
			if (options === void 0) {
				options = {};
			}
			_this = _GraphicsDevice.call(this, canvas, options) || this;
			options = _this.initOptions;
			_this.isNull = true;
			_this._deviceType = DEVICETYPE_NULL;
			_this.samples = 1;
			return _this;
		}
		var _proto = NullGraphicsDevice.prototype;
		_proto.destroy = function destroy() {
			_GraphicsDevice.prototype.destroy.call(this);
		};
		_proto.initDeviceCaps = function initDeviceCaps() {
			this.disableParticleSystem = true;
			this.precision = 'highp';
			this.maxPrecision = 'highp';
			this.maxSamples = 4;
			this.maxTextures = 16;
			this.maxTextureSize = 4096;
			this.maxCubeMapSize = 4096;
			this.maxVolumeSize = 4096;
			this.maxColorAttachments = 8;
			this.maxPixelRatio = 1;
			this.maxAnisotropy = 16;
			this.supportsInstancing = true;
			this.supportsUniformBuffers = false;
			this.supportsVolumeTextures = true;
			this.supportsBoneTextures = true;
			this.supportsMorphTargetTexturesCore = true;
			this.supportsAreaLights = true;
			this.supportsDepthShadow = true;
			this.supportsGpuParticles = false;
			this.supportsMrt = true;
			this.extUintElement = true;
			this.extTextureFloat = true;
			this.textureFloatRenderable = true;
			this.extTextureHalfFloat = true;
			this.textureHalfFloatRenderable = true;
			this.textureHalfFloatUpdatable = true;
			this.boneLimit = 1024;
			this.supportsImageBitmap = true;
			this.extStandardDerivatives = true;
			this.extBlendMinmax = true;
			this.areaLightLutFormat = PIXELFORMAT_RGBA8;
			this.supportsTextureFetch = true;
		};
		_proto.postInit = function postInit() {
			_GraphicsDevice.prototype.postInit.call(this);
		};
		_proto.frameStart = function frameStart() {
			_GraphicsDevice.prototype.frameStart.call(this);
		};
		_proto.frameEnd = function frameEnd() {
			_GraphicsDevice.prototype.frameEnd.call(this);
		};
		_proto.createVertexBufferImpl = function createVertexBufferImpl(vertexBuffer, format) {
			return new NullVertexBuffer(vertexBuffer, format);
		};
		_proto.createIndexBufferImpl = function createIndexBufferImpl(indexBuffer) {
			return new NullIndexBuffer(indexBuffer);
		};
		_proto.createShaderImpl = function createShaderImpl(shader) {
			return new NullShader(shader);
		};
		_proto.createTextureImpl = function createTextureImpl(texture) {
			return new NullTexture(texture);
		};
		_proto.createRenderTargetImpl = function createRenderTargetImpl(renderTarget) {
			return new NullRenderTarget(renderTarget);
		};
		_proto.draw = function draw(primitive, numInstances, keepBuffers) {
		};
		_proto.setShader = function setShader(shader) {
			return true;
		};
		_proto.setBlendState = function setBlendState(blendState) {};
		_proto.setDepthState = function setDepthState(depthState) {};
		_proto.setStencilState = function setStencilState(stencilFront, stencilBack) {};
		_proto.setBlendColor = function setBlendColor(r, g, b, a) {};
		_proto.setCullMode = function setCullMode(cullMode) {};
		_proto.setAlphaToCoverage = function setAlphaToCoverage(state) {};
		_proto.initializeContextCaches = function initializeContextCaches() {
			_GraphicsDevice.prototype.initializeContextCaches.call(this);
		};
		_proto.clear = function clear(options) {};
		_proto.setDepthBias = function setDepthBias(on) {};
		_proto.setDepthBiasValues = function setDepthBiasValues(constBias, slopeBias) {};
		_proto.setViewport = function setViewport(x, y, w, h) {};
		_proto.setScissor = function setScissor(x, y, w, h) {};
		_proto.copyRenderTarget = function copyRenderTarget(source, dest, color, depth) {
			return true;
		};
		return NullGraphicsDevice;
	}(GraphicsDevice);

	function createGraphicsDevice(canvas, options) {
		var _options$deviceTypes;
		if (options === void 0) {
			options = {};
		}
		var deviceTypes = (_options$deviceTypes = options.deviceTypes) != null ? _options$deviceTypes : [];
		if (!deviceTypes.includes(DEVICETYPE_WEBGL2)) {
			deviceTypes.push(DEVICETYPE_WEBGL2);
		}
		if (!deviceTypes.includes(DEVICETYPE_WEBGL1)) {
			deviceTypes.push(DEVICETYPE_WEBGL1);
		}
		if (!deviceTypes.includes(DEVICETYPE_NULL)) {
			deviceTypes.push(DEVICETYPE_NULL);
		}
		if (platform.browser && !!navigator.xr) {
			var _options, _options$xrCompatible;
			(_options$xrCompatible = (_options = options).xrCompatible) != null ? _options$xrCompatible : _options.xrCompatible = true;
		}
		var deviceCreateFuncs = [];
		var _loop = function _loop() {
			var _window;
			var deviceType = deviceTypes[i];
			if (deviceType === DEVICETYPE_WEBGPU && (_window = window) != null && (_window = _window.navigator) != null && _window.gpu) {
				deviceCreateFuncs.push(function () {
					var device = new WebgpuGraphicsDevice(canvas, options);
					return device.initWebGpu(options.glslangUrl, options.twgslUrl);
				});
			}
			if (deviceType === DEVICETYPE_WEBGL1 || deviceType === DEVICETYPE_WEBGL2) {
				deviceCreateFuncs.push(function () {
					options.preferWebGl2 = deviceType === DEVICETYPE_WEBGL2;
					return new WebglGraphicsDevice(canvas, options);
				});
			}
			if (deviceType === DEVICETYPE_NULL) {
				deviceCreateFuncs.push(function () {
					return new NullGraphicsDevice(canvas, options);
				});
			}
		};
		for (var i = 0; i < deviceTypes.length; i++) {
			_loop();
		}
		return new Promise(function (resolve, reject) {
			var attempt = 0;
			var next = function next() {
				if (attempt >= deviceCreateFuncs.length) {
					reject(new Error('Failed to create a graphics device'));
				} else {
					Promise.resolve(deviceCreateFuncs[attempt++]()).then(function (device) {
						if (device) {
							resolve(device);
						} else {
							next();
						}
					}).catch(function (err) {
						console.log(err);
						next();
					});
				}
			};
			next();
		});
	}

	var Compute = function () {
		function Compute(graphicsDevice, shader) {
			this.shader = null;
			this.device = graphicsDevice;
			this.shader = shader;
			if (graphicsDevice.supportsCompute) {
				this.impl = graphicsDevice.createComputeImpl(this);
			}
		}
		var _proto = Compute.prototype;
		_proto.dispatch = function dispatch(x, y, z) {
			var _this$impl;
			(_this$impl = this.impl) == null || _this$impl.dispatch(x, y, z);
		};
		return Compute;
	}();

	var id$4 = 0;
	var IndexBuffer = function () {
		function IndexBuffer(graphicsDevice, format, numIndices, usage, initialData) {
			if (usage === void 0) {
				usage = BUFFER_STATIC;
			}
			this.device = graphicsDevice;
			this.format = format;
			this.numIndices = numIndices;
			this.usage = usage;
			this.id = id$4++;
			this.impl = graphicsDevice.createIndexBufferImpl(this);
			var bytesPerIndex = typedArrayIndexFormatsByteSize[format];
			this.bytesPerIndex = bytesPerIndex;
			this.numBytes = this.numIndices * bytesPerIndex;
			if (initialData) {
				this.setData(initialData);
			} else {
				this.storage = new ArrayBuffer(this.numBytes);
			}
			this.adjustVramSizeTracking(graphicsDevice._vram, this.numBytes);
			this.device.buffers.push(this);
		}
		var _proto = IndexBuffer.prototype;
		_proto.destroy = function destroy() {
			var device = this.device;
			var idx = device.buffers.indexOf(this);
			if (idx !== -1) {
				device.buffers.splice(idx, 1);
			}
			if (this.device.indexBuffer === this) {
				this.device.indexBuffer = null;
			}
			if (this.impl.initialized) {
				this.impl.destroy(device);
				this.adjustVramSizeTracking(device._vram, -this.storage.byteLength);
			}
		};
		_proto.adjustVramSizeTracking = function adjustVramSizeTracking(vram, size) {
			vram.ib += size;
		};
		_proto.loseContext = function loseContext() {
			this.impl.loseContext();
		};
		_proto.getFormat = function getFormat() {
			return this.format;
		};
		_proto.getNumIndices = function getNumIndices() {
			return this.numIndices;
		};
		_proto.lock = function lock() {
			return this.storage;
		};
		_proto.unlock = function unlock() {
			this.impl.unlock(this);
		};
		_proto.setData = function setData(data) {
			if (data.byteLength !== this.numBytes) {
				return false;
			}
			this.storage = data;
			this.unlock();
			return true;
		};
		_proto._lockTypedArray = function _lockTypedArray() {
			var lock = this.lock();
			var indices = this.format === INDEXFORMAT_UINT32 ? new Uint32Array(lock) : this.format === INDEXFORMAT_UINT16 ? new Uint16Array(lock) : new Uint8Array(lock);
			return indices;
		};
		_proto.writeData = function writeData(data, count) {
			var indices = this._lockTypedArray();
			if (data.length > count) {
				if (ArrayBuffer.isView(data)) {
					data = data.subarray(0, count);
					indices.set(data);
				} else {
					for (var i = 0; i < count; i++) indices[i] = data[i];
				}
			} else {
				indices.set(data);
			}
			this.unlock();
		};
		_proto.readData = function readData(data) {
			var indices = this._lockTypedArray();
			var count = this.numIndices;
			if (ArrayBuffer.isView(data)) {
				data.set(indices);
			} else {
				data.length = 0;
				for (var i = 0; i < count; i++) data[i] = indices[i];
			}
			return count;
		};
		return IndexBuffer;
	}();

	var ColorAttachmentOps = function ColorAttachmentOps() {
		this.clearValue = new Color(0, 0, 0, 1);
		this.clear = false;
		this.store = false;
		this.resolve = true;
		this.mipmaps = false;
	};
	var DepthStencilAttachmentOps = function DepthStencilAttachmentOps() {
		this.clearDepthValue = 1;
		this.clearStencilValue = 0;
		this.clearDepth = false;
		this.clearStencil = false;
		this.storeDepth = false;
		this.storeStencil = false;
	};
	var RenderPass = function () {
		function RenderPass(graphicsDevice) {
			this.name = '';
			this.enabled = true;
			this.executeEnabled = true;
			this.renderTarget = void 0;
			this.options = void 0;
			this.samples = 0;
			this.colorArrayOps = [];
			this.depthStencilOps = void 0;
			this.requiresCubemaps = true;
			this.fullSizeClearRect = true;
			this.beforePasses = [];
			this.afterPasses = [];
			this.device = graphicsDevice;
		}
		var _proto = RenderPass.prototype;
		_proto.init = function init(renderTarget, options) {
			var _renderTarget$_colorB;
			if (renderTarget === void 0) {
				renderTarget = null;
			}
			if (options === void 0) {
				options = null;
			}
			this.options = options;
			if (options) {
				var _this$options$scaleX, _this$options$scaleY;
				this.options.scaleX = (_this$options$scaleX = this.options.scaleX) != null ? _this$options$scaleX : 1;
				this.options.scaleY = (_this$options$scaleY = this.options.scaleY) != null ? _this$options$scaleY : 1;
			}
			this.renderTarget = renderTarget;
			this.samples = Math.max(this.renderTarget ? this.renderTarget.samples : this.device.samples, 1);
			this.depthStencilOps = new DepthStencilAttachmentOps();
			var numColorOps = renderTarget ? (_renderTarget$_colorB = renderTarget._colorBuffers) == null ? void 0 : _renderTarget$_colorB.length : 1;
			for (var i = 0; i < numColorOps; i++) {
				var _this$renderTarget;
				var colorOps = new ColorAttachmentOps();
				this.colorArrayOps[i] = colorOps;
				if (this.samples === 1) {
					colorOps.store = true;
					colorOps.resolve = false;
				}
				if ((_this$renderTarget = this.renderTarget) != null && (_this$renderTarget = _this$renderTarget._colorBuffers) != null && _this$renderTarget[i].mipmaps) {
					colorOps.mipmaps = true;
				}
			}
			this.postInit();
		};
		_proto.destroy = function destroy() {};
		_proto.postInit = function postInit() {};
		_proto.frameUpdate = function frameUpdate() {
			if (this.options && this.renderTarget) {
				var _this$options$resizeS;
				var resizeSource = (_this$options$resizeS = this.options.resizeSource) != null ? _this$options$resizeS : this.device.backBuffer;
				var width = Math.floor(resizeSource.width * this.options.scaleX);
				var height = Math.floor(resizeSource.height * this.options.scaleY);
				this.renderTarget.resize(width, height);
			}
		};
		_proto.before = function before() {};
		_proto.execute = function execute() {};
		_proto.after = function after() {};
		_proto.setClearColor = function setClearColor(color) {
			var count = this.colorArrayOps.length;
			for (var i = 0; i < count; i++) {
				var colorOps = this.colorArrayOps[i];
				colorOps.clearValue.copy(color);
				colorOps.clear = true;
			}
		};
		_proto.setClearDepth = function setClearDepth(depthValue) {
			this.depthStencilOps.clearDepthValue = depthValue;
			this.depthStencilOps.clearDepth = true;
		};
		_proto.setClearStencil = function setClearStencil(stencilValue) {
			this.depthStencilOps.clearStencilValue = stencilValue;
			this.depthStencilOps.clearStencil = true;
		};
		_proto.render = function render() {
			if (this.enabled) {
				var device = this.device;
				var realPass = this.renderTarget !== undefined;
				this.before();
				if (this.executeEnabled) {
					if (realPass) {
						device.startRenderPass(this);
					}
					this.execute();
					if (realPass) {
						device.endRenderPass(this);
					}
				}
				this.after();
				device.renderPassIndex++;
			}
		};
		_createClass(RenderPass, [{
			key: "colorOps",
			get: function get() {
				return this.colorArrayOps[0];
			}
		}]);
		return RenderPass;
	}();

	var TransformFeedback = function () {
		function TransformFeedback(inputBuffer, usage) {
			if (usage === void 0) {
				usage = BUFFER_GPUDYNAMIC;
			}
			this.device = inputBuffer.device;
			var gl = this.device.gl;
			this._inputBuffer = inputBuffer;
			if (usage === BUFFER_GPUDYNAMIC && inputBuffer.usage !== usage) {
				gl.bindBuffer(gl.ARRAY_BUFFER, inputBuffer.impl.bufferId);
				gl.bufferData(gl.ARRAY_BUFFER, inputBuffer.storage, gl.DYNAMIC_COPY);
			}
			this._outputBuffer = new VertexBuffer(inputBuffer.device, inputBuffer.format, inputBuffer.numVertices, usage, inputBuffer.storage);
		}
		TransformFeedback.createShader = function createShader(graphicsDevice, vertexCode, name) {
			return new Shader(graphicsDevice, ShaderUtils.createDefinition(graphicsDevice, {
				name: name,
				vertexCode: vertexCode,
				useTransformFeedback: true
			}));
		};
		var _proto = TransformFeedback.prototype;
		_proto.destroy = function destroy() {
			this._outputBuffer.destroy();
		};
		_proto.process = function process(shader, swap) {
			if (swap === void 0) {
				swap = true;
			}
			var device = this.device;
			var oldRt = device.getRenderTarget();
			device.setRenderTarget(null);
			device.updateBegin();
			device.setVertexBuffer(this._inputBuffer, 0);
			device.setRaster(false);
			device.setTransformFeedbackBuffer(this._outputBuffer);
			device.setShader(shader);
			device.draw({
				type: PRIMITIVE_POINTS,
				base: 0,
				count: this._inputBuffer.numVertices,
				indexed: false
			});
			device.setTransformFeedbackBuffer(null);
			device.setRaster(true);
			device.updateEnd();
			device.setRenderTarget(oldRt);
			if (swap) {
				var tmp = this._inputBuffer.impl.bufferId;
				this._inputBuffer.impl.bufferId = this._outputBuffer.impl.bufferId;
				this._outputBuffer.impl.bufferId = tmp;
				tmp = this._inputBuffer.impl.vao;
				this._inputBuffer.impl.vao = this._outputBuffer.impl.vao;
				this._outputBuffer.impl.vao = tmp;
			}
		};
		_createClass(TransformFeedback, [{
			key: "inputBuffer",
			get: function get() {
				return this._inputBuffer;
			}
		}, {
			key: "outputBuffer",
			get: function get() {
				return this._outputBuffer;
			}
		}]);
		return TransformFeedback;
	}();

	function set1(a) {
		this.array[this.index] = a;
	}
	function set2(a, b) {
		this.array[this.index] = a;
		this.array[this.index + 1] = b;
	}
	function set3(a, b, c) {
		this.array[this.index] = a;
		this.array[this.index + 1] = b;
		this.array[this.index + 2] = c;
	}
	function set4(a, b, c, d) {
		this.array[this.index] = a;
		this.array[this.index + 1] = b;
		this.array[this.index + 2] = c;
		this.array[this.index + 3] = d;
	}
	function arraySet1(index, inputArray, inputIndex) {
		this.array[index] = inputArray[inputIndex];
	}
	function arraySet2(index, inputArray, inputIndex) {
		this.array[index] = inputArray[inputIndex];
		this.array[index + 1] = inputArray[inputIndex + 1];
	}
	function arraySet3(index, inputArray, inputIndex) {
		this.array[index] = inputArray[inputIndex];
		this.array[index + 1] = inputArray[inputIndex + 1];
		this.array[index + 2] = inputArray[inputIndex + 2];
	}
	function arraySet4(index, inputArray, inputIndex) {
		this.array[index] = inputArray[inputIndex];
		this.array[index + 1] = inputArray[inputIndex + 1];
		this.array[index + 2] = inputArray[inputIndex + 2];
		this.array[index + 3] = inputArray[inputIndex + 3];
	}
	function arrayGet1(offset, outputArray, outputIndex) {
		outputArray[outputIndex] = this.array[offset];
	}
	function arrayGet2(offset, outputArray, outputIndex) {
		outputArray[outputIndex] = this.array[offset];
		outputArray[outputIndex + 1] = this.array[offset + 1];
	}
	function arrayGet3(offset, outputArray, outputIndex) {
		outputArray[outputIndex] = this.array[offset];
		outputArray[outputIndex + 1] = this.array[offset + 1];
		outputArray[outputIndex + 2] = this.array[offset + 2];
	}
	function arrayGet4(offset, outputArray, outputIndex) {
		outputArray[outputIndex] = this.array[offset];
		outputArray[outputIndex + 1] = this.array[offset + 1];
		outputArray[outputIndex + 2] = this.array[offset + 2];
		outputArray[outputIndex + 3] = this.array[offset + 3];
	}
	var VertexIteratorAccessor = function () {
		function VertexIteratorAccessor(buffer, vertexElement, vertexFormat) {
			this.index = 0;
			this.numComponents = vertexElement.numComponents;
			if (vertexFormat.interleaved) {
				this.array = new typedArrayTypes[vertexElement.dataType](buffer, vertexElement.offset);
			} else {
				this.array = new typedArrayTypes[vertexElement.dataType](buffer, vertexElement.offset, vertexFormat.vertexCount * vertexElement.numComponents);
			}
			this.stride = vertexElement.stride / this.array.constructor.BYTES_PER_ELEMENT;
			switch (vertexElement.numComponents) {
				case 1:
					this.set = set1;
					this.getToArray = arrayGet1;
					this.setFromArray = arraySet1;
					break;
				case 2:
					this.set = set2;
					this.getToArray = arrayGet2;
					this.setFromArray = arraySet2;
					break;
				case 3:
					this.set = set3;
					this.getToArray = arrayGet3;
					this.setFromArray = arraySet3;
					break;
				case 4:
					this.set = set4;
					this.getToArray = arrayGet4;
					this.setFromArray = arraySet4;
					break;
			}
		}
		var _proto = VertexIteratorAccessor.prototype;
		_proto.get = function get(offset) {
			return this.array[this.index + offset];
		};
		_proto.set = function set(a, b, c, d) {};
		_proto.getToArray = function getToArray(offset, outputArray, outputIndex) {};
		_proto.setFromArray = function setFromArray(index, inputArray, inputIndex) {};
		return VertexIteratorAccessor;
	}();
	var VertexIterator = function () {
		function VertexIterator(vertexBuffer) {
			this.vertexBuffer = vertexBuffer;
			this.vertexFormatSize = vertexBuffer.getFormat().size;
			this.buffer = this.vertexBuffer.lock();
			this.accessors = [];
			this.element = {};
			var vertexFormat = this.vertexBuffer.getFormat();
			for (var i = 0; i < vertexFormat.elements.length; i++) {
				var vertexElement = vertexFormat.elements[i];
				this.accessors[i] = new VertexIteratorAccessor(this.buffer, vertexElement, vertexFormat);
				this.element[vertexElement.name] = this.accessors[i];
			}
		}
		var _proto2 = VertexIterator.prototype;
		_proto2.next = function next(count) {
			if (count === void 0) {
				count = 1;
			}
			var i = 0;
			var accessors = this.accessors;
			var numAccessors = this.accessors.length;
			while (i < numAccessors) {
				var accessor = accessors[i++];
				accessor.index += count * accessor.stride;
			}
		};
		_proto2.end = function end() {
			this.vertexBuffer.unlock();
		};
		_proto2.writeData = function writeData(semantic, data, numVertices) {
			var element = this.element[semantic];
			if (element) {
				if (numVertices > this.vertexBuffer.numVertices) {
					numVertices = this.vertexBuffer.numVertices;
				}
				var numComponents = element.numComponents;
				if (this.vertexBuffer.getFormat().interleaved) {
					var index = 0;
					for (var i = 0; i < numVertices; i++) {
						element.setFromArray(index, data, i * numComponents);
						index += element.stride;
					}
				} else {
					if (data.length > numVertices * numComponents) {
						var copyCount = numVertices * numComponents;
						if (ArrayBuffer.isView(data)) {
							data = data.subarray(0, copyCount);
							element.array.set(data);
						} else {
							for (var _i = 0; _i < copyCount; _i++) element.array[_i] = data[_i];
						}
					} else {
						element.array.set(data);
					}
				}
			}
		};
		_proto2.readData = function readData(semantic, data) {
			var element = this.element[semantic];
			var count = 0;
			if (element) {
				count = this.vertexBuffer.numVertices;
				var i;
				var numComponents = element.numComponents;
				if (this.vertexBuffer.getFormat().interleaved) {
					if (Array.isArray(data)) data.length = 0;
					element.index = 0;
					var offset = 0;
					for (i = 0; i < count; i++) {
						element.getToArray(offset, data, i * numComponents);
						offset += element.stride;
					}
				} else {
					if (ArrayBuffer.isView(data)) {
						data.set(element.array);
					} else {
						data.length = 0;
						var copyCount = count * numComponents;
						for (i = 0; i < copyCount; i++) data[i] = element.array[i];
					}
				}
			}
			return count;
		};
		return VertexIterator;
	}();

	var ACTION_MOUSE = 'mouse';
	var ACTION_KEYBOARD = 'keyboard';
	var ACTION_GAMEPAD = 'gamepad';
	var AXIS_MOUSE_X = 'mousex';
	var AXIS_MOUSE_Y = 'mousey';
	var AXIS_PAD_L_X = 'padlx';
	var AXIS_PAD_L_Y = 'padly';
	var AXIS_PAD_R_X = 'padrx';
	var AXIS_PAD_R_Y = 'padry';
	var AXIS_KEY = 'key';
	var EVENT_KEYDOWN = 'keydown';
	var EVENT_KEYUP = 'keyup';
	var EVENT_MOUSEDOWN = 'mousedown';
	var EVENT_MOUSEMOVE = 'mousemove';
	var EVENT_MOUSEUP = 'mouseup';
	var EVENT_MOUSEWHEEL = 'mousewheel';
	var EVENT_TOUCHSTART = 'touchstart';
	var EVENT_TOUCHEND = 'touchend';
	var EVENT_TOUCHMOVE = 'touchmove';
	var EVENT_TOUCHCANCEL = 'touchcancel';
	var EVENT_SELECT = 'select';
	var EVENT_SELECTSTART = 'selectstart';
	var EVENT_SELECTEND = 'selectend';
	var KEY_BACKSPACE = 8;
	var KEY_TAB = 9;
	var KEY_RETURN = 13;
	var KEY_ENTER = 13;
	var KEY_SHIFT = 16;
	var KEY_CONTROL = 17;
	var KEY_ALT = 18;
	var KEY_PAUSE = 19;
	var KEY_CAPS_LOCK = 20;
	var KEY_ESCAPE = 27;
	var KEY_SPACE = 32;
	var KEY_PAGE_UP = 33;
	var KEY_PAGE_DOWN = 34;
	var KEY_END = 35;
	var KEY_HOME = 36;
	var KEY_LEFT = 37;
	var KEY_UP = 38;
	var KEY_RIGHT = 39;
	var KEY_DOWN = 40;
	var KEY_PRINT_SCREEN = 44;
	var KEY_INSERT = 45;
	var KEY_DELETE = 46;
	var KEY_0 = 48;
	var KEY_1 = 49;
	var KEY_2 = 50;
	var KEY_3 = 51;
	var KEY_4 = 52;
	var KEY_5 = 53;
	var KEY_6 = 54;
	var KEY_7 = 55;
	var KEY_8 = 56;
	var KEY_9 = 57;
	var KEY_SEMICOLON = 59;
	var KEY_EQUAL = 61;
	var KEY_A = 65;
	var KEY_B = 66;
	var KEY_C = 67;
	var KEY_D = 68;
	var KEY_E = 69;
	var KEY_F = 70;
	var KEY_G = 71;
	var KEY_H = 72;
	var KEY_I = 73;
	var KEY_J = 74;
	var KEY_K = 75;
	var KEY_L = 76;
	var KEY_M = 77;
	var KEY_N = 78;
	var KEY_O = 79;
	var KEY_P = 80;
	var KEY_Q = 81;
	var KEY_R = 82;
	var KEY_S = 83;
	var KEY_T = 84;
	var KEY_U = 85;
	var KEY_V = 86;
	var KEY_W = 87;
	var KEY_X = 88;
	var KEY_Y = 89;
	var KEY_Z = 90;
	var KEY_WINDOWS = 91;
	var KEY_CONTEXT_MENU = 93;
	var KEY_NUMPAD_0 = 96;
	var KEY_NUMPAD_1 = 97;
	var KEY_NUMPAD_2 = 98;
	var KEY_NUMPAD_3 = 99;
	var KEY_NUMPAD_4 = 100;
	var KEY_NUMPAD_5 = 101;
	var KEY_NUMPAD_6 = 102;
	var KEY_NUMPAD_7 = 103;
	var KEY_NUMPAD_8 = 104;
	var KEY_NUMPAD_9 = 105;
	var KEY_MULTIPLY = 106;
	var KEY_ADD = 107;
	var KEY_SEPARATOR = 108;
	var KEY_SUBTRACT = 109;
	var KEY_DECIMAL = 110;
	var KEY_DIVIDE = 111;
	var KEY_F1 = 112;
	var KEY_F2 = 113;
	var KEY_F3 = 114;
	var KEY_F4 = 115;
	var KEY_F5 = 116;
	var KEY_F6 = 117;
	var KEY_F7 = 118;
	var KEY_F8 = 119;
	var KEY_F9 = 120;
	var KEY_F10 = 121;
	var KEY_F11 = 122;
	var KEY_F12 = 123;
	var KEY_COMMA = 188;
	var KEY_PERIOD = 190;
	var KEY_SLASH = 191;
	var KEY_OPEN_BRACKET = 219;
	var KEY_BACK_SLASH = 220;
	var KEY_CLOSE_BRACKET = 221;
	var KEY_META = 224;
	var MOUSEBUTTON_NONE = -1;
	var MOUSEBUTTON_LEFT = 0;
	var MOUSEBUTTON_MIDDLE = 1;
	var MOUSEBUTTON_RIGHT = 2;
	var PAD_1 = 0;
	var PAD_2 = 1;
	var PAD_3 = 2;
	var PAD_4 = 3;
	var PAD_FACE_1 = 0;
	var PAD_FACE_2 = 1;
	var PAD_FACE_3 = 2;
	var PAD_FACE_4 = 3;
	var PAD_L_SHOULDER_1 = 4;
	var PAD_R_SHOULDER_1 = 5;
	var PAD_L_SHOULDER_2 = 6;
	var PAD_R_SHOULDER_2 = 7;
	var PAD_SELECT = 8;
	var PAD_START = 9;
	var PAD_L_STICK_BUTTON = 10;
	var PAD_R_STICK_BUTTON = 11;
	var PAD_UP = 12;
	var PAD_DOWN = 13;
	var PAD_LEFT = 14;
	var PAD_RIGHT = 15;
	var PAD_VENDOR = 16;
	var PAD_L_STICK_X = 0;
	var PAD_L_STICK_Y = 1;
	var PAD_R_STICK_X = 2;
	var PAD_R_STICK_Y = 3;
	var EVENT_GAMEPADCONNECTED = 'gamepadconnected';
	var EVENT_GAMEPADDISCONNECTED = 'gamepaddisconnected';
	var XRPAD_TOUCHPAD_X = 0;
	var XRPAD_TOUCHPAD_Y = 1;
	var XRPAD_STICK_X = 2;
	var XRPAD_STICK_Y = 3;
	var XRPAD_TOUCHPAD_BUTTON = 2;
	var XRPAD_TRIGGER = 0;
	var XRPAD_SQUEEZE = 1;
	var XRPAD_STICK_BUTTON = 3;
	var XRPAD_A = 4;
	var XRPAD_B = 5;

	var KeyboardEvent = function KeyboardEvent(keyboard, event) {
		if (event) {
			this.key = event.keyCode;
			this.element = event.target;
			this.event = event;
		} else {
			this.key = null;
			this.element = null;
			this.event = null;
		}
	};

	var _keyboardEvent = new KeyboardEvent();
	function makeKeyboardEvent(event) {
		_keyboardEvent.key = event.keyCode;
		_keyboardEvent.element = event.target;
		_keyboardEvent.event = event;
		return _keyboardEvent;
	}
	function toKeyCode(s) {
		if (typeof s === 'string') {
			return s.toUpperCase().charCodeAt(0);
		}
		return s;
	}
	var _keyCodeToKeyIdentifier = {
		'9': 'Tab',
		'13': 'Enter',
		'16': 'Shift',
		'17': 'Control',
		'18': 'Alt',
		'27': 'Escape',
		'37': 'Left',
		'38': 'Up',
		'39': 'Right',
		'40': 'Down',
		'46': 'Delete',
		'91': 'Win'
	};
	var Keyboard = function (_EventHandler) {
		_inheritsLoose(Keyboard, _EventHandler);
		function Keyboard(element, options) {
			var _this;
			if (options === void 0) {
				options = {};
			}
			_this = _EventHandler.call(this) || this;
			_this._element = null;
			_this._keyDownHandler = _this._handleKeyDown.bind(_assertThisInitialized(_this));
			_this._keyUpHandler = _this._handleKeyUp.bind(_assertThisInitialized(_this));
			_this._keyPressHandler = _this._handleKeyPress.bind(_assertThisInitialized(_this));
			_this._visibilityChangeHandler = _this._handleVisibilityChange.bind(_assertThisInitialized(_this));
			_this._windowBlurHandler = _this._handleWindowBlur.bind(_assertThisInitialized(_this));
			_this._keymap = {};
			_this._lastmap = {};
			if (element) {
				_this.attach(element);
			}
			_this.preventDefault = options.preventDefault || false;
			_this.stopPropagation = options.stopPropagation || false;
			return _this;
		}
		var _proto = Keyboard.prototype;
		_proto.attach = function attach(element) {
			if (this._element) {
				this.detach();
			}
			this._element = element;
			this._element.addEventListener('keydown', this._keyDownHandler, false);
			this._element.addEventListener('keypress', this._keyPressHandler, false);
			this._element.addEventListener('keyup', this._keyUpHandler, false);
			document.addEventListener('visibilitychange', this._visibilityChangeHandler, false);
			window.addEventListener('blur', this._windowBlurHandler, false);
		};
		_proto.detach = function detach() {
			if (!this._element) {
				return;
			}
			this._element.removeEventListener('keydown', this._keyDownHandler);
			this._element.removeEventListener('keypress', this._keyPressHandler);
			this._element.removeEventListener('keyup', this._keyUpHandler);
			this._element = null;
			document.removeEventListener('visibilitychange', this._visibilityChangeHandler, false);
			window.removeEventListener('blur', this._windowBlurHandler, false);
		};
		_proto.toKeyIdentifier = function toKeyIdentifier(keyCode) {
			keyCode = toKeyCode(keyCode);
			var id = _keyCodeToKeyIdentifier[keyCode.toString()];
			if (id) {
				return id;
			}
			var hex = keyCode.toString(16).toUpperCase();
			var length = hex.length;
			for (var count = 0; count < 4 - length; count++) {
				hex = '0' + hex;
			}
			return 'U+' + hex;
		};
		_proto._handleKeyDown = function _handleKeyDown(event) {
			var code = event.keyCode || event.charCode;
			if (code === undefined) return;
			var id = this.toKeyIdentifier(code);
			this._keymap[id] = true;
			this.fire('keydown', makeKeyboardEvent(event));
			if (this.preventDefault) {
				event.preventDefault();
			}
			if (this.stopPropagation) {
				event.stopPropagation();
			}
		};
		_proto._handleKeyUp = function _handleKeyUp(event) {
			var code = event.keyCode || event.charCode;
			if (code === undefined) return;
			var id = this.toKeyIdentifier(code);
			delete this._keymap[id];
			this.fire('keyup', makeKeyboardEvent(event));
			if (this.preventDefault) {
				event.preventDefault();
			}
			if (this.stopPropagation) {
				event.stopPropagation();
			}
		};
		_proto._handleKeyPress = function _handleKeyPress(event) {
			this.fire('keypress', makeKeyboardEvent(event));
			if (this.preventDefault) {
				event.preventDefault();
			}
			if (this.stopPropagation) {
				event.stopPropagation();
			}
		};
		_proto._handleVisibilityChange = function _handleVisibilityChange() {
			if (document.visibilityState === 'hidden') {
				this._handleWindowBlur();
			}
		};
		_proto._handleWindowBlur = function _handleWindowBlur() {
			this._keymap = {};
			this._lastmap = {};
		};
		_proto.update = function update() {
			for (var prop in this._lastmap) {
				delete this._lastmap[prop];
			}
			for (var _prop in this._keymap) {
				if (this._keymap.hasOwnProperty(_prop)) {
					this._lastmap[_prop] = this._keymap[_prop];
				}
			}
		};
		_proto.isPressed = function isPressed(key) {
			var keyCode = toKeyCode(key);
			var id = this.toKeyIdentifier(keyCode);
			return !!this._keymap[id];
		};
		_proto.wasPressed = function wasPressed(key) {
			var keyCode = toKeyCode(key);
			var id = this.toKeyIdentifier(keyCode);
			return !!this._keymap[id] && !!!this._lastmap[id];
		};
		_proto.wasReleased = function wasReleased(key) {
			var keyCode = toKeyCode(key);
			var id = this.toKeyIdentifier(keyCode);
			return !!!this._keymap[id] && !!this._lastmap[id];
		};
		return Keyboard;
	}(EventHandler);

	function isMousePointerLocked() {
		return !!(document.pointerLockElement || document.mozPointerLockElement || document.webkitPointerLockElement);
	}
	var MouseEvent = function MouseEvent(mouse, event) {
		var coords = {
			x: 0,
			y: 0
		};
		if (event) {
			if (event instanceof MouseEvent) {
				throw Error('Expected MouseEvent');
			}
			coords = mouse._getTargetCoords(event);
		} else {
			event = {};
		}
		if (coords) {
			this.x = coords.x;
			this.y = coords.y;
		} else if (isMousePointerLocked()) {
			this.x = 0;
			this.y = 0;
		} else {
			return;
		}
		this.wheelDelta = 0;
		if (event.type === 'wheel') {
			if (event.deltaY > 0) {
				this.wheelDelta = 1;
			} else if (event.deltaY < 0) {
				this.wheelDelta = -1;
			}
		}
		if (isMousePointerLocked()) {
			this.dx = event.movementX || event.webkitMovementX || event.mozMovementX || 0;
			this.dy = event.movementY || event.webkitMovementY || event.mozMovementY || 0;
		} else {
			this.dx = this.x - mouse._lastX;
			this.dy = this.y - mouse._lastY;
		}
		if (event.type === 'mousedown' || event.type === 'mouseup') {
			this.button = event.button;
		} else {
			this.button = MOUSEBUTTON_NONE;
		}
		this.buttons = mouse._buttons.slice(0);
		this.element = event.target;
		this.ctrlKey = event.ctrlKey || false;
		this.altKey = event.altKey || false;
		this.shiftKey = event.shiftKey || false;
		this.metaKey = event.metaKey || false;
		this.event = event;
	};

	var Mouse = function (_EventHandler) {
		_inheritsLoose(Mouse, _EventHandler);
		function Mouse(element) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this._lastX = 0;
			_this._lastY = 0;
			_this._buttons = [false, false, false];
			_this._lastbuttons = [false, false, false];
			_this._upHandler = _this._handleUp.bind(_assertThisInitialized(_this));
			_this._downHandler = _this._handleDown.bind(_assertThisInitialized(_this));
			_this._moveHandler = _this._handleMove.bind(_assertThisInitialized(_this));
			_this._wheelHandler = _this._handleWheel.bind(_assertThisInitialized(_this));
			_this._contextMenuHandler = function (event) {
				event.preventDefault();
			};
			_this._target = null;
			_this._attached = false;
			_this.attach(element);
			return _this;
		}
		Mouse.isPointerLocked = function isPointerLocked() {
			return isMousePointerLocked();
		};
		var _proto = Mouse.prototype;
		_proto.attach = function attach(element) {
			this._target = element;
			if (this._attached) return;
			this._attached = true;
			var opts = platform.passiveEvents ? {
				passive: false
			} : false;
			window.addEventListener('mouseup', this._upHandler, opts);
			window.addEventListener('mousedown', this._downHandler, opts);
			window.addEventListener('mousemove', this._moveHandler, opts);
			window.addEventListener('wheel', this._wheelHandler, opts);
		};
		_proto.detach = function detach() {
			if (!this._attached) return;
			this._attached = false;
			this._target = null;
			var opts = platform.passiveEvents ? {
				passive: false
			} : false;
			window.removeEventListener('mouseup', this._upHandler, opts);
			window.removeEventListener('mousedown', this._downHandler, opts);
			window.removeEventListener('mousemove', this._moveHandler, opts);
			window.removeEventListener('wheel', this._wheelHandler, opts);
		};
		_proto.disableContextMenu = function disableContextMenu() {
			if (!this._target) return;
			this._target.addEventListener('contextmenu', this._contextMenuHandler);
		};
		_proto.enableContextMenu = function enableContextMenu() {
			if (!this._target) return;
			this._target.removeEventListener('contextmenu', this._contextMenuHandler);
		};
		_proto.enablePointerLock = function enablePointerLock(success, error) {
			if (!document.body.requestPointerLock) {
				if (error) error();
				return;
			}
			var s = function s() {
				success();
				document.removeEventListener('pointerlockchange', s);
			};
			var e = function e() {
				error();
				document.removeEventListener('pointerlockerror', e);
			};
			if (success) {
				document.addEventListener('pointerlockchange', s, false);
			}
			if (error) {
				document.addEventListener('pointerlockerror', e, false);
			}
			document.body.requestPointerLock();
		};
		_proto.disablePointerLock = function disablePointerLock(success) {
			if (!document.exitPointerLock) {
				return;
			}
			var s = function s() {
				success();
				document.removeEventListener('pointerlockchange', s);
			};
			if (success) {
				document.addEventListener('pointerlockchange', s, false);
			}
			document.exitPointerLock();
		};
		_proto.update = function update() {
			this._lastbuttons[0] = this._buttons[0];
			this._lastbuttons[1] = this._buttons[1];
			this._lastbuttons[2] = this._buttons[2];
		};
		_proto.isPressed = function isPressed(button) {
			return this._buttons[button];
		};
		_proto.wasPressed = function wasPressed(button) {
			return this._buttons[button] && !this._lastbuttons[button];
		};
		_proto.wasReleased = function wasReleased(button) {
			return !this._buttons[button] && this._lastbuttons[button];
		};
		_proto._handleUp = function _handleUp(event) {
			this._buttons[event.button] = false;
			var e = new MouseEvent(this, event);
			if (!e.event) return;
			this.fire(EVENT_MOUSEUP, e);
		};
		_proto._handleDown = function _handleDown(event) {
			this._buttons[event.button] = true;
			var e = new MouseEvent(this, event);
			if (!e.event) return;
			this.fire(EVENT_MOUSEDOWN, e);
		};
		_proto._handleMove = function _handleMove(event) {
			var e = new MouseEvent(this, event);
			if (!e.event) return;
			this.fire(EVENT_MOUSEMOVE, e);
			this._lastX = e.x;
			this._lastY = e.y;
		};
		_proto._handleWheel = function _handleWheel(event) {
			var e = new MouseEvent(this, event);
			if (!e.event) return;
			this.fire(EVENT_MOUSEWHEEL, e);
		};
		_proto._getTargetCoords = function _getTargetCoords(event) {
			var rect = this._target.getBoundingClientRect();
			var left = Math.floor(rect.left);
			var top = Math.floor(rect.top);
			if (event.clientX < left || event.clientX >= left + this._target.clientWidth || event.clientY < top || event.clientY >= top + this._target.clientHeight) {
				return null;
			}
			return {
				x: event.clientX - left,
				y: event.clientY - top
			};
		};
		return Mouse;
	}(EventHandler);

	var Controller = function () {
		function Controller(element, options) {
			if (options === void 0) {
				options = {};
			}
			this._keyboard = options.keyboard || null;
			this._mouse = options.mouse || null;
			this._gamepads = options.gamepads || null;
			this._element = null;
			this._actions = {};
			this._axes = {};
			this._axesValues = {};
			if (element) {
				this.attach(element);
			}
		}
		var _proto = Controller.prototype;
		_proto.attach = function attach(element) {
			this._element = element;
			if (this._keyboard) {
				this._keyboard.attach(element);
			}
			if (this._mouse) {
				this._mouse.attach(element);
			}
		};
		_proto.detach = function detach() {
			if (this._keyboard) {
				this._keyboard.detach();
			}
			if (this._mouse) {
				this._mouse.detach();
			}
			this._element = null;
		};
		_proto.disableContextMenu = function disableContextMenu() {
			if (!this._mouse) {
				this._enableMouse();
			}
			this._mouse.disableContextMenu();
		};
		_proto.enableContextMenu = function enableContextMenu() {
			if (!this._mouse) {
				this._enableMouse();
			}
			this._mouse.enableContextMenu();
		};
		_proto.update = function update(dt) {
			if (this._keyboard) {
				this._keyboard.update();
			}
			if (this._mouse) {
				this._mouse.update();
			}
			if (this._gamepads) {
				this._gamepads.update();
			}
			this._axesValues = {};
			for (var key in this._axes) {
				this._axesValues[key] = [];
			}
		};
		_proto.appendAction = function appendAction(action_name, action) {
			this._actions[action_name] = this._actions[action_name] || [];
			this._actions[action_name].push(action);
		};
		_proto.registerKeys = function registerKeys(action, keys) {
			if (!this._keyboard) {
				this._enableKeyboard();
			}
			if (this._actions[action]) {
				throw new Error("Action: " + action + " already registered");
			}
			if (keys === undefined) {
				throw new Error('Invalid button');
			}
			if (!keys.length) {
				keys = [keys];
			}
			this.appendAction(action, {
				type: ACTION_KEYBOARD,
				keys: keys
			});
		};
		_proto.registerMouse = function registerMouse(action, button) {
			if (!this._mouse) {
				this._enableMouse();
			}
			if (button === undefined) {
				throw new Error('Invalid button');
			}
			this.appendAction(action, {
				type: ACTION_MOUSE,
				button: button
			});
		};
		_proto.registerPadButton = function registerPadButton(action, pad, button) {
			if (button === undefined) {
				throw new Error('Invalid button');
			}
			this.appendAction(action, {
				type: ACTION_GAMEPAD,
				button: button,
				pad: pad
			});
		};
		_proto.registerAxis = function registerAxis(options) {
			var name = options.name;
			if (!this._axes[name]) {
				this._axes[name] = [];
			}
			var i = this._axes[name].push(name);
			options = options || {};
			options.pad = options.pad || PAD_1;
			var bind = function bind(controller, source, value, key) {
				switch (source) {
					case 'mousex':
						controller._mouse.on(EVENT_MOUSEMOVE, function (e) {
							controller._axesValues[name][i] = e.dx / 10;
						});
						break;
					case 'mousey':
						controller._mouse.on(EVENT_MOUSEMOVE, function (e) {
							controller._axesValues[name][i] = e.dy / 10;
						});
						break;
					case 'key':
						controller._axes[name].push(function () {
							return controller._keyboard.isPressed(key) ? value : 0;
						});
						break;
					case 'padrx':
						controller._axes[name].push(function () {
							return controller._gamepads.getAxis(options.pad, PAD_R_STICK_X);
						});
						break;
					case 'padry':
						controller._axes[name].push(function () {
							return controller._gamepads.getAxis(options.pad, PAD_R_STICK_Y);
						});
						break;
					case 'padlx':
						controller._axes[name].push(function () {
							return controller._gamepads.getAxis(options.pad, PAD_L_STICK_X);
						});
						break;
					case 'padly':
						controller._axes[name].push(function () {
							return controller._gamepads.getAxis(options.pad, PAD_L_STICK_Y);
						});
						break;
					default:
						throw new Error('Unknown axis');
				}
			};
			bind(this, options.positive, 1, options.positiveKey);
			if (options.negativeKey || options.negative !== options.positive) {
				bind(this, options.negative, -1, options.negativeKey);
			}
		};
		_proto.isPressed = function isPressed(actionName) {
			if (!this._actions[actionName]) {
				return false;
			}
			var length = this._actions[actionName].length;
			for (var index = 0; index < length; ++index) {
				var action = this._actions[actionName][index];
				switch (action.type) {
					case ACTION_KEYBOARD:
						if (this._keyboard) {
							var len = action.keys.length;
							for (var i = 0; i < len; i++) {
								if (this._keyboard.isPressed(action.keys[i])) {
									return true;
								}
							}
						}
						break;
					case ACTION_MOUSE:
						if (this._mouse && this._mouse.isPressed(action.button)) {
							return true;
						}
						break;
					case ACTION_GAMEPAD:
						if (this._gamepads && this._gamepads.isPressed(action.pad, action.button)) {
							return true;
						}
						break;
				}
			}
			return false;
		};
		_proto.wasPressed = function wasPressed(actionName) {
			if (!this._actions[actionName]) {
				return false;
			}
			var length = this._actions[actionName].length;
			for (var index = 0; index < length; ++index) {
				var action = this._actions[actionName][index];
				switch (action.type) {
					case ACTION_KEYBOARD:
						if (this._keyboard) {
							var len = action.keys.length;
							for (var i = 0; i < len; i++) {
								if (this._keyboard.wasPressed(action.keys[i])) {
									return true;
								}
							}
						}
						break;
					case ACTION_MOUSE:
						if (this._mouse && this._mouse.wasPressed(action.button)) {
							return true;
						}
						break;
					case ACTION_GAMEPAD:
						if (this._gamepads && this._gamepads.wasPressed(action.pad, action.button)) {
							return true;
						}
						break;
				}
			}
			return false;
		};
		_proto.getAxis = function getAxis(name) {
			var value = 0;
			if (this._axes[name]) {
				var len = this._axes[name].length;
				for (var i = 0; i < len; i++) {
					if (type$1(this._axes[name][i]) === 'function') {
						var v = this._axes[name][i]();
						if (Math.abs(v) > Math.abs(value)) {
							value = v;
						}
					} else if (this._axesValues[name]) {
						if (Math.abs(this._axesValues[name][i]) > Math.abs(value)) {
							value = this._axesValues[name][i];
						}
					}
				}
			}
			return value;
		};
		_proto._enableMouse = function _enableMouse() {
			this._mouse = new Mouse();
			if (!this._element) {
				throw new Error('Controller must be attached to an Element');
			}
			this._mouse.attach(this._element);
		};
		_proto._enableKeyboard = function _enableKeyboard() {
			this._keyboard = new Keyboard();
			if (!this._element) {
				throw new Error('Controller must be attached to an Element');
			}
			this._keyboard.attach(this._element);
		};
		return Controller;
	}();

	var dummyArray = Object.freeze([]);
	var getGamepads = function getGamepads() {
		return dummyArray;
	};
	if (typeof navigator !== 'undefined') {
		getGamepads = (navigator.getGamepads || navigator.webkitGetGamepads || getGamepads).bind(navigator);
	}
	var MAPS_INDEXES = {
		buttons: {
			PAD_FACE_1: PAD_FACE_1,
			PAD_FACE_2: PAD_FACE_2,
			PAD_FACE_3: PAD_FACE_3,
			PAD_FACE_4: PAD_FACE_4,
			PAD_L_SHOULDER_1: PAD_L_SHOULDER_1,
			PAD_R_SHOULDER_1: PAD_R_SHOULDER_1,
			PAD_L_SHOULDER_2: PAD_L_SHOULDER_2,
			PAD_R_SHOULDER_2: PAD_R_SHOULDER_2,
			PAD_SELECT: PAD_SELECT,
			PAD_START: PAD_START,
			PAD_L_STICK_BUTTON: PAD_L_STICK_BUTTON,
			PAD_R_STICK_BUTTON: PAD_R_STICK_BUTTON,
			PAD_UP: PAD_UP,
			PAD_DOWN: PAD_DOWN,
			PAD_LEFT: PAD_LEFT,
			PAD_RIGHT: PAD_RIGHT,
			PAD_VENDOR: PAD_VENDOR,
			XRPAD_TRIGGER: XRPAD_TRIGGER,
			XRPAD_SQUEEZE: XRPAD_SQUEEZE,
			XRPAD_TOUCHPAD_BUTTON: XRPAD_TOUCHPAD_BUTTON,
			XRPAD_STICK_BUTTON: XRPAD_STICK_BUTTON,
			XRPAD_A: XRPAD_A,
			XRPAD_B: XRPAD_B
		},
		axes: {
			PAD_L_STICK_X: PAD_L_STICK_X,
			PAD_L_STICK_Y: PAD_L_STICK_Y,
			PAD_R_STICK_X: PAD_R_STICK_X,
			PAD_R_STICK_Y: PAD_R_STICK_Y,
			XRPAD_TOUCHPAD_X: XRPAD_TOUCHPAD_X,
			XRPAD_TOUCHPAD_Y: XRPAD_TOUCHPAD_Y,
			XRPAD_STICK_X: XRPAD_STICK_X,
			XRPAD_STICK_Y: XRPAD_STICK_Y
		}
	};
	var MAPS = {
		DEFAULT: {
			buttons: ['PAD_FACE_1', 'PAD_FACE_2', 'PAD_FACE_3', 'PAD_FACE_4', 'PAD_L_SHOULDER_1', 'PAD_R_SHOULDER_1', 'PAD_L_SHOULDER_2', 'PAD_R_SHOULDER_2', 'PAD_SELECT', 'PAD_START', 'PAD_L_STICK_BUTTON', 'PAD_R_STICK_BUTTON', 'PAD_UP', 'PAD_DOWN', 'PAD_LEFT', 'PAD_RIGHT', 'PAD_VENDOR'],
			axes: ['PAD_L_STICK_X', 'PAD_L_STICK_Y', 'PAD_R_STICK_X', 'PAD_R_STICK_Y']
		},
		DEFAULT_DUAL: {
			buttons: ['PAD_FACE_1', 'PAD_FACE_2', 'PAD_FACE_3', 'PAD_FACE_4', 'PAD_L_SHOULDER_1', 'PAD_R_SHOULDER_1', 'PAD_L_SHOULDER_2', 'PAD_R_SHOULDER_2', 'PAD_SELECT', 'PAD_START', 'PAD_L_STICK_BUTTON', 'PAD_R_STICK_BUTTON', 'PAD_VENDOR'],
			axes: ['PAD_L_STICK_X', 'PAD_L_STICK_Y', 'PAD_R_STICK_X', 'PAD_R_STICK_Y'],
			synthesizedButtons: {
				PAD_UP: {
					axis: 0,
					min: 0,
					max: 1
				},
				PAD_DOWN: {
					axis: 0,
					min: -1,
					max: 0
				},
				PAD_LEFT: {
					axis: 0,
					min: -1,
					max: 0
				},
				PAD_RIGHT: {
					axis: 0,
					min: 0,
					max: 1
				}
			}
		},
		PS3: {
			buttons: ['PAD_FACE_1', 'PAD_FACE_2', 'PAD_FACE_4', 'PAD_FACE_3', 'PAD_L_SHOULDER_1', 'PAD_R_SHOULDER_1', 'PAD_L_SHOULDER_2', 'PAD_R_SHOULDER_2', 'PAD_SELECT', 'PAD_START', 'PAD_L_STICK_BUTTON', 'PAD_R_STICK_BUTTON', 'PAD_UP', 'PAD_DOWN', 'PAD_LEFT', 'PAD_RIGHT', 'PAD_VENDOR'],
			axes: ['PAD_L_STICK_X', 'PAD_L_STICK_Y', 'PAD_R_STICK_X', 'PAD_R_STICK_Y'],
			mapping: 'standard'
		},
		DEFAULT_XR: {
			buttons: ['XRPAD_TRIGGER', 'XRPAD_SQUEEZE', 'XRPAD_TOUCHPAD_BUTTON', 'XRPAD_STICK_BUTTON', 'XRPAD_A', 'XRPAD_B'],
			axes: ['XRPAD_TOUCHPAD_X', 'XRPAD_TOUCHPAD_Y', 'XRPAD_STICK_X', 'XRPAD_STICK_Y'],
			mapping: 'xr-standard'
		}
	};
	var PRODUCT_CODES = {
		'Product: 0268': 'PS3'
	};
	var custom_maps = {};
	function _getMap(pad) {
		var custom = custom_maps[pad.id];
		if (custom) {
			return custom;
		}
		for (var code in PRODUCT_CODES) {
			if (pad.id.indexOf(code) !== -1) {
				var product = PRODUCT_CODES[code];
				if (!pad.mapping) {
					var raw = MAPS['RAW_' + product];
					if (raw) {
						return raw;
					}
				}
				return MAPS[product];
			}
		}
		if (pad.mapping === 'xr-standard') {
			return MAPS.DEFAULT_XR;
		}
		var defaultmap = MAPS.DEFAULT;
		var map = pad.buttons.length < defaultmap.buttons.length ? MAPS.DEFAULT_DUAL : defaultmap;
		map.mapping = pad.mapping;
		return map;
	}
	var deadZone = 0.25;
	function sleep(ms) {
		return new Promise(function (resolve) {
			setTimeout(resolve, ms);
		});
	}
	var GamePadButton = function () {
		function GamePadButton(current, previous) {
			this.value = 0;
			this.pressed = false;
			this.touched = false;
			this.wasPressed = false;
			this.wasReleased = false;
			this.wasTouched = false;
			if (typeof current === 'number') {
				this.value = current;
				this.pressed = current === 1;
				this.touched = current > 0;
			} else {
				var _current$touched;
				this.value = current.value;
				this.pressed = current.pressed;
				this.touched = (_current$touched = current.touched) != null ? _current$touched : current.value > 0;
			}
			if (previous) {
				if (typeof previous === 'number') {
					this.wasPressed = previous !== 1 && this.pressed;
					this.wasReleased = previous === 1 && !this.pressed;
					this.wasTouched = previous === 0 && this.touched;
				} else {
					var _previous$touched;
					this.wasPressed = !previous.pressed && this.pressed;
					this.wasReleased = previous.pressed && !this.pressed;
					this.wasTouched = !((_previous$touched = previous.touched) != null ? _previous$touched : previous.value > 0) && this.touched;
				}
			}
		}
		var _proto = GamePadButton.prototype;
		_proto.update = function update(button) {
			var _button$touched;
			var value = button.value,
				pressed = button.pressed;
			var touched = (_button$touched = button.touched) != null ? _button$touched : value > 0;
			this.wasPressed = !this.pressed && pressed;
			this.wasReleased = this.pressed && !pressed;
			this.wasTouched = !this.touched && touched;
			this.value = value;
			this.pressed = pressed;
			this.touched = touched;
		};
		return GamePadButton;
	}();
	var dummyButton = Object.freeze(new GamePadButton(0));
	var GamePad = function () {
		function GamePad(gamepad, map) {
			this._compiledMapping = {
				buttons: [],
				axes: []
			};
			this.id = gamepad.id;
			this.index = gamepad.index;
			this._buttons = gamepad.buttons.map(function (b) {
				return new GamePadButton(b);
			});
			this._axes = [].concat(gamepad.axes);
			this._previousAxes = [].concat(gamepad.axes);
			this.mapping = map.mapping;
			this.map = map;
			this.hand = gamepad.hand || 'none';
			this.pad = gamepad;
			this._compileMapping();
		}
		var _proto2 = GamePad.prototype;
		_proto2._compileMapping = function _compileMapping() {
			var _this = this;
			var _this$_compiledMappin = this._compiledMapping,
				axes = _this$_compiledMappin.axes,
				buttons = _this$_compiledMappin.buttons;
			var axesIndexes = MAPS_INDEXES.axes;
			var buttonsIndexes = MAPS_INDEXES.buttons;
			axes.length = 0;
			buttons.length = 0;
			var axesMap = this.map.axes;
			if (axesMap) {
				this.map.axes.forEach(function (axis, i) {
					axes[axesIndexes[axis]] = function () {
						return _this.pad.axes[i] || 0;
					};
				});
			}
			for (var i = 0, l = axes.length; i < l; i++) {
				if (!axes[i]) {
					axes[i] = function () {
						return 0;
					};
				}
			}
			var buttonsMap = this.map.buttons;
			if (buttonsMap) {
				buttonsMap.forEach(function (button, i) {
					buttons[buttonsIndexes[button]] = function () {
						return _this._buttons[i] || dummyButton;
					};
				});
			}
			var synthesizedButtonsMap = this.map.synthesizedButtons;
			if (synthesizedButtonsMap) {
				Object.entries(synthesizedButtonsMap).forEach(function (button) {
					var _button$ = button[1],
						axis = _button$.axis,
						max = _button$.max,
						min = _button$.min;
					buttons[buttonsIndexes[button[0]]] = function () {
						var _this$_axes$axis, _this$_previousAxes$a;
						return new GamePadButton(Math.abs(math.clamp((_this$_axes$axis = _this._axes[axis]) != null ? _this$_axes$axis : 0, min, max)), Math.abs(math.clamp((_this$_previousAxes$a = _this._previousAxes[axis]) != null ? _this$_previousAxes$a : 0, min, max)));
					};
				});
			}
			for (var _i = 0, _l = buttons.length; _i < _l; _i++) {
				if (!buttons[_i]) {
					buttons[_i] = function () {
						return dummyButton;
					};
				}
			}
		};
		_proto2.update = function update(gamepad) {
			this.pad = gamepad;
			var previousAxes = this._previousAxes;
			var axes = this._axes;
			previousAxes.length = 0;
			previousAxes.push.apply(previousAxes, axes);
			axes.length = 0;
			axes.push.apply(axes, gamepad.axes);
			var buttons = this._buttons;
			for (var i = 0, l = buttons.length; i < l; i++) {
				buttons[i].update(gamepad.buttons[i]);
			}
			return this;
		};
		_proto2.updateMap = function updateMap(map) {
			map.mapping = 'custom';
			custom_maps[this.id] = map;
			this.map = map;
			this.mapping = 'custom';
			this._compileMapping();
		};
		_proto2.resetMap = function resetMap() {
			if (custom_maps[this.id]) {
				delete custom_maps[this.id];
				var map = _getMap(this.pad);
				this.map = map;
				this.mapping = map.mapping;
				this._compileMapping();
			}
		};
		_proto2.pulse = function () {
			var _pulse = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2(intensity, duration, options) {
				var actuators, _options$startDelay, _options$strongMagnit, _options$weakMagnitud, startDelay, strongMagnitude, weakMagnitude, results;
				return _regeneratorRuntime().wrap(function _callee2$(_context2) {
					while (1) switch (_context2.prev = _context2.next) {
						case 0:
							actuators = this.pad.vibrationActuator ? [this.pad.vibrationActuator] : this.pad.hapticActuators || dummyArray;
							if (!actuators.length) {
								_context2.next = 9;
								break;
							}
							startDelay = (_options$startDelay = options == null ? void 0 : options.startDelay) != null ? _options$startDelay : 0;
							strongMagnitude = (_options$strongMagnit = options == null ? void 0 : options.strongMagnitude) != null ? _options$strongMagnit : intensity;
							weakMagnitude = (_options$weakMagnitud = options == null ? void 0 : options.weakMagnitude) != null ? _options$weakMagnitud : intensity;
							_context2.next = 7;
							return Promise.all(actuators.map(function () {
								var _ref = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(actuator) {
									return _regeneratorRuntime().wrap(function _callee$(_context) {
										while (1) switch (_context.prev = _context.next) {
											case 0:
												if (actuator) {
													_context.next = 2;
													break;
												}
												return _context.abrupt("return", true);
											case 2:
												if (!actuator.playEffect) {
													_context.next = 6;
													break;
												}
												return _context.abrupt("return", actuator.playEffect(actuator.type, {
													duration: duration,
													startDelay: startDelay,
													strongMagnitude: strongMagnitude,
													weakMagnitude: weakMagnitude
												}));
											case 6:
												if (!actuator.pulse) {
													_context.next = 10;
													break;
												}
												_context.next = 9;
												return sleep(startDelay);
											case 9:
												return _context.abrupt("return", actuator.pulse(intensity, duration));
											case 10:
												return _context.abrupt("return", false);
											case 11:
											case "end":
												return _context.stop();
										}
									}, _callee);
								}));
								return function (_x4) {
									return _ref.apply(this, arguments);
								};
							}()));
						case 7:
							results = _context2.sent;
							return _context2.abrupt("return", results.some(function (r) {
								return r === true || r === 'complete';
							}));
						case 9:
							return _context2.abrupt("return", false);
						case 10:
						case "end":
							return _context2.stop();
					}
				}, _callee2, this);
			}));
			function pulse(_x, _x2, _x3) {
				return _pulse.apply(this, arguments);
			}
			return pulse;
		}();
		_proto2.getButton = function getButton(index) {
			var button = this._compiledMapping.buttons[index];
			return button ? button() : dummyButton;
		};
		_proto2.isPressed = function isPressed(button) {
			return this.getButton(button).pressed;
		};
		_proto2.wasPressed = function wasPressed(button) {
			return this.getButton(button).wasPressed;
		};
		_proto2.wasReleased = function wasReleased(button) {
			return this.getButton(button).wasReleased;
		};
		_proto2.isTouched = function isTouched(button) {
			return this.getButton(button).touched;
		};
		_proto2.wasTouched = function wasTouched(button) {
			return this.getButton(button).wasTouched;
		};
		_proto2.getValue = function getValue(button) {
			return this.getButton(button).value;
		};
		_proto2.getAxis = function getAxis(axis) {
			var a = this.axes[axis];
			return a && Math.abs(a) > deadZone ? a : 0;
		};
		_createClass(GamePad, [{
			key: "connected",
			get: function get() {
				return this.pad.connected;
			}
		}, {
			key: "axes",
			get: function get() {
				return this._compiledMapping.axes.map(function (a) {
					return a();
				});
			}
		}, {
			key: "buttons",
			get: function get() {
				return this._compiledMapping.buttons.map(function (b) {
					return b();
				});
			}
		}]);
		return GamePad;
	}();
	var GamePads = function (_EventHandler) {
		_inheritsLoose(GamePads, _EventHandler);
		function GamePads() {
			var _this2;
			_this2 = _EventHandler.call(this) || this;
			_this2.gamepadsSupported = platform.gamepads;
			_this2.current = [];
			_this2._previous = [];
			_this2._ongamepadconnectedHandler = _this2._ongamepadconnected.bind(_assertThisInitialized(_this2));
			_this2._ongamepaddisconnectedHandler = _this2._ongamepaddisconnected.bind(_assertThisInitialized(_this2));
			window.addEventListener('gamepadconnected', _this2._ongamepadconnectedHandler, false);
			window.addEventListener('gamepaddisconnected', _this2._ongamepaddisconnectedHandler, false);
			_this2.poll();
			return _this2;
		}
		var _proto3 = GamePads.prototype;
		_proto3._ongamepadconnected = function _ongamepadconnected(event) {
			var pad = new GamePad(event.gamepad, this.getMap(event.gamepad));
			var current = this.current;
			var padIndex = current.findIndex(function (gp) {
				return gp.index === pad.index;
			});
			while (padIndex !== -1) {
				current.splice(padIndex, 1);
				padIndex = current.findIndex(function (gp) {
					return gp.index === pad.index;
				});
			}
			current.push(pad);
			this.fire(EVENT_GAMEPADCONNECTED, pad);
		};
		_proto3._ongamepaddisconnected = function _ongamepaddisconnected(event) {
			var current = this.current;
			var padIndex = current.findIndex(function (gp) {
				return gp.index === event.gamepad.index;
			});
			if (padIndex !== -1) {
				this.fire(EVENT_GAMEPADDISCONNECTED, current[padIndex]);
				current.splice(padIndex, 1);
			}
		};
		_proto3.update = function update() {
			this.poll();
		};
		_proto3.poll = function poll(pads) {
			if (pads === void 0) {
				pads = [];
			}
			if (pads.length > 0) {
				pads.length = 0;
			}
			var padDevices = getGamepads();
			for (var i = 0, len = padDevices.length; i < len; i++) {
				if (padDevices[i]) {
					var pad = this.findByIndex(padDevices[i].index);
					if (pad) {
						pads.push(pad.update(padDevices[i]));
					} else {
						var nPad = new GamePad(padDevices[i], this.getMap(padDevices[i]));
						this.current.push(nPad);
						pads.push(nPad);
					}
				}
			}
			return pads;
		};
		_proto3.destroy = function destroy() {
			window.removeEventListener('gamepadconnected', this._ongamepadconnectedHandler, false);
			window.removeEventListener('gamepaddisconnected', this._ongamepaddisconnectedHandler, false);
		};
		_proto3.getMap = function getMap(pad) {
			return _getMap(pad);
		};
		_proto3.isPressed = function isPressed(orderIndex, button) {
			var _this$current$orderIn;
			return ((_this$current$orderIn = this.current[orderIndex]) == null ? void 0 : _this$current$orderIn.isPressed(button)) || false;
		};
		_proto3.wasPressed = function wasPressed(orderIndex, button) {
			var _this$current$orderIn2;
			return ((_this$current$orderIn2 = this.current[orderIndex]) == null ? void 0 : _this$current$orderIn2.wasPressed(button)) || false;
		};
		_proto3.wasReleased = function wasReleased(orderIndex, button) {
			var _this$current$orderIn3;
			return ((_this$current$orderIn3 = this.current[orderIndex]) == null ? void 0 : _this$current$orderIn3.wasReleased(button)) || false;
		};
		_proto3.getAxis = function getAxis(orderIndex, axis) {
			var _this$current$orderIn4;
			return ((_this$current$orderIn4 = this.current[orderIndex]) == null ? void 0 : _this$current$orderIn4.getAxis(axis)) || 0;
		};
		_proto3.pulse = function pulse(orderIndex, intensity, duration, options) {
			var pad = this.current[orderIndex];
			return pad ? pad.pulse(intensity, duration, options) : Promise.resolve(false);
		};
		_proto3.pulseAll = function pulseAll(intensity, duration, options) {
			return Promise.all(this.current.map(function (pad) {
				return pad.pulse(intensity, duration, options);
			}));
		};
		_proto3.findById = function findById(id) {
			return this.current.find(function (gp) {
				return gp && gp.id === id;
			}) || null;
		};
		_proto3.findByIndex = function findByIndex(index) {
			return this.current.find(function (gp) {
				return gp && gp.index === index;
			}) || null;
		};
		_createClass(GamePads, [{
			key: "deadZone",
			get: function get() {
				return deadZone;
			},
			set: function set(value) {
				deadZone = value;
			}
		}, {
			key: "previous",
			get: function get() {
				var current = this.current;
				for (var i = 0, l = current.length; i < l; i++) {
					var buttons = current[i]._buttons;
					if (!this._previous[i]) {
						this._previous[i] = [];
					}
					for (var j = 0, m = buttons.length; j < m; j++) {
						var button = buttons[i];
						this.previous[i][j] = button ? !button.wasPressed && button.pressed || button.wasReleased : false;
					}
				}
				this._previous.length = this.current.length;
				return this._previous;
			}
		}]);
		return GamePads;
	}(EventHandler);

	function getTouchTargetCoords(touch) {
		var totalOffsetX = 0;
		var totalOffsetY = 0;
		var target = touch.target;
		while (!(target instanceof HTMLElement)) {
			target = target.parentNode;
		}
		var currentElement = target;
		do {
			totalOffsetX += currentElement.offsetLeft - currentElement.scrollLeft;
			totalOffsetY += currentElement.offsetTop - currentElement.scrollTop;
			currentElement = currentElement.offsetParent;
		} while (currentElement);
		return {
			x: touch.pageX - totalOffsetX,
			y: touch.pageY - totalOffsetY
		};
	}
	var Touch = function Touch(touch) {
		var coords = getTouchTargetCoords(touch);
		this.id = touch.identifier;
		this.x = coords.x;
		this.y = coords.y;
		this.target = touch.target;
		this.touch = touch;
	};
	var TouchEvent = function () {
		function TouchEvent(device, event) {
			this.element = event.target;
			this.event = event;
			this.touches = [];
			this.changedTouches = [];
			if (event) {
				for (var i = 0, l = event.touches.length; i < l; i++) {
					this.touches.push(new Touch(event.touches[i]));
				}
				for (var _i = 0, _l = event.changedTouches.length; _i < _l; _i++) {
					this.changedTouches.push(new Touch(event.changedTouches[_i]));
				}
			}
		}
		var _proto = TouchEvent.prototype;
		_proto.getTouchById = function getTouchById(id, list) {
			for (var i = 0, l = list.length; i < l; i++) {
				if (list[i].id === id) {
					return list[i];
				}
			}
			return null;
		};
		return TouchEvent;
	}();

	var TouchDevice = function (_EventHandler) {
		_inheritsLoose(TouchDevice, _EventHandler);
		function TouchDevice(element) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this._element = null;
			_this._startHandler = _this._handleTouchStart.bind(_assertThisInitialized(_this));
			_this._endHandler = _this._handleTouchEnd.bind(_assertThisInitialized(_this));
			_this._moveHandler = _this._handleTouchMove.bind(_assertThisInitialized(_this));
			_this._cancelHandler = _this._handleTouchCancel.bind(_assertThisInitialized(_this));
			_this.attach(element);
			return _this;
		}
		var _proto = TouchDevice.prototype;
		_proto.attach = function attach(element) {
			if (this._element) {
				this.detach();
			}
			this._element = element;
			this._element.addEventListener('touchstart', this._startHandler, false);
			this._element.addEventListener('touchend', this._endHandler, false);
			this._element.addEventListener('touchmove', this._moveHandler, false);
			this._element.addEventListener('touchcancel', this._cancelHandler, false);
		};
		_proto.detach = function detach() {
			if (this._element) {
				this._element.removeEventListener('touchstart', this._startHandler, false);
				this._element.removeEventListener('touchend', this._endHandler, false);
				this._element.removeEventListener('touchmove', this._moveHandler, false);
				this._element.removeEventListener('touchcancel', this._cancelHandler, false);
			}
			this._element = null;
		};
		_proto._handleTouchStart = function _handleTouchStart(e) {
			this.fire('touchstart', new TouchEvent(this, e));
		};
		_proto._handleTouchEnd = function _handleTouchEnd(e) {
			this.fire('touchend', new TouchEvent(this, e));
		};
		_proto._handleTouchMove = function _handleTouchMove(e) {
			e.preventDefault();
			this.fire('touchmove', new TouchEvent(this, e));
		};
		_proto._handleTouchCancel = function _handleTouchCancel(e) {
			this.fire('touchcancel', new TouchEvent(this, e));
		};
		return TouchDevice;
	}(EventHandler);

	var Http = function () {
		function Http() {}
		var _proto = Http.prototype;
		_proto.get = function get(url, options, callback) {
			if (typeof options === 'function') {
				callback = options;
				options = {};
			}
			return this.request('GET', url, options, callback);
		};
		_proto.post = function post(url, data, options, callback) {
			if (typeof options === 'function') {
				callback = options;
				options = {};
			}
			options.postdata = data;
			return this.request('POST', url, options, callback);
		};
		_proto.put = function put(url, data, options, callback) {
			if (typeof options === 'function') {
				callback = options;
				options = {};
			}
			options.postdata = data;
			return this.request('PUT', url, options, callback);
		};
		_proto.del = function del(url, options, callback) {
			if (typeof options === 'function') {
				callback = options;
				options = {};
			}
			return this.request('DELETE', url, options, callback);
		};
		_proto.request = function request(method, url, options, callback) {
			var _this = this;
			var uri, query, postdata;
			var errored = false;
			if (typeof options === 'function') {
				callback = options;
				options = {};
			}
			if (options.retry) {
				options = Object.assign({
					retries: 0,
					maxRetries: 5
				}, options);
			}
			options.callback = callback;
			if (options.async == null) {
				options.async = true;
			}
			if (options.headers == null) {
				options.headers = {};
			}
			if (options.postdata != null) {
				if (options.postdata instanceof Document) {
					postdata = options.postdata;
				} else if (options.postdata instanceof FormData) {
					postdata = options.postdata;
				} else if (options.postdata instanceof Object) {
					var contentType = options.headers['Content-Type'];
					if (contentType === undefined) {
						options.headers['Content-Type'] = Http.ContentType.FORM_URLENCODED;
						contentType = options.headers['Content-Type'];
					}
					switch (contentType) {
						case Http.ContentType.FORM_URLENCODED:
							{
								postdata = '';
								var bFirstItem = true;
								for (var key in options.postdata) {
									if (options.postdata.hasOwnProperty(key)) {
										if (bFirstItem) {
											bFirstItem = false;
										} else {
											postdata += '&';
										}
										var encodedKey = encodeURIComponent(key);
										var encodedValue = encodeURIComponent(options.postdata[key]);
										postdata += encodedKey + "=" + encodedValue;
									}
								}
								break;
							}
						default:
						case Http.ContentType.JSON:
							if (contentType == null) {
								options.headers['Content-Type'] = Http.ContentType.JSON;
							}
							postdata = JSON.stringify(options.postdata);
							break;
					}
				} else {
					postdata = options.postdata;
				}
			}
			if (options.cache === false) {
				var timestamp = now();
				uri = new URI(url);
				if (!uri.query) {
					uri.query = 'ts=' + timestamp;
				} else {
					uri.query = uri.query + '&ts=' + timestamp;
				}
				url = uri.toString();
			}
			if (options.query) {
				uri = new URI(url);
				query = extend(uri.getQuery(), options.query);
				uri.setQuery(query);
				url = uri.toString();
			}
			var xhr = new XMLHttpRequest();
			xhr.open(method, url, options.async);
			xhr.withCredentials = options.withCredentials !== undefined ? options.withCredentials : false;
			xhr.responseType = options.responseType || this._guessResponseType(url);
			for (var header in options.headers) {
				if (options.headers.hasOwnProperty(header)) {
					xhr.setRequestHeader(header, options.headers[header]);
				}
			}
			xhr.onreadystatechange = function () {
				_this._onReadyStateChange(method, url, options, xhr);
			};
			xhr.onerror = function () {
				_this._onError(method, url, options, xhr);
				errored = true;
			};
			try {
				xhr.send(postdata);
			} catch (e) {
				if (!errored) {
					options.error(xhr.status, xhr, e);
				}
			}
			return xhr;
		};
		_proto._guessResponseType = function _guessResponseType(url) {
			var uri = new URI(url);
			var ext = path.getExtension(uri.path).toLowerCase();
			if (Http.binaryExtensions.indexOf(ext) >= 0) {
				return Http.ResponseType.ARRAY_BUFFER;
			} else if (ext === '.json') {
				return Http.ResponseType.JSON;
			} else if (ext === '.xml') {
				return Http.ResponseType.DOCUMENT;
			}
			return Http.ResponseType.TEXT;
		};
		_proto._isBinaryContentType = function _isBinaryContentType(contentType) {
			var binTypes = [Http.ContentType.BASIS, Http.ContentType.BIN, Http.ContentType.DDS, Http.ContentType.GLB, Http.ContentType.MP3, Http.ContentType.MP4, Http.ContentType.OGG, Http.ContentType.OPUS, Http.ContentType.WAV];
			if (binTypes.indexOf(contentType) >= 0) {
				return true;
			}
			return false;
		};
		_proto._isBinaryResponseType = function _isBinaryResponseType(responseType) {
			return responseType === Http.ResponseType.ARRAY_BUFFER || responseType === Http.ResponseType.BLOB || responseType === Http.ResponseType.JSON;
		};
		_proto._onReadyStateChange = function _onReadyStateChange(method, url, options, xhr) {
			if (xhr.readyState === 4) {
				switch (xhr.status) {
					case 0:
						{
							if (xhr.responseURL && xhr.responseURL.startsWith('file:///')) {
								this._onSuccess(method, url, options, xhr);
							} else {
								this._onError(method, url, options, xhr);
							}
							break;
						}
					case 200:
					case 201:
					case 206:
					case 304:
						{
							this._onSuccess(method, url, options, xhr);
							break;
						}
					default:
						{
							this._onError(method, url, options, xhr);
							break;
						}
				}
			}
		};
		_proto._onSuccess = function _onSuccess(method, url, options, xhr) {
			var response;
			var contentType;
			var header = xhr.getResponseHeader('Content-Type');
			if (header) {
				var parts = header.split(';');
				contentType = parts[0].trim();
			}
			try {
				if (this._isBinaryContentType(contentType) || this._isBinaryResponseType(xhr.responseType)) {
					response = xhr.response;
				} else if (contentType === Http.ContentType.JSON || url.split('?')[0].endsWith('.json')) {
					response = JSON.parse(xhr.responseText);
				} else if (xhr.responseType === Http.ResponseType.DOCUMENT || contentType === Http.ContentType.XML) {
					response = xhr.responseXML;
				} else {
					response = xhr.responseText;
				}
				options.callback(null, response);
			} catch (err) {
				options.callback(err);
			}
		};
		_proto._onError = function _onError(method, url, options, xhr) {
			var _this2 = this;
			if (options.retrying) {
				return;
			}
			if (options.retry && options.retries < options.maxRetries) {
				options.retries++;
				options.retrying = true;
				var retryDelay = math.clamp(Math.pow(2, options.retries) * Http.retryDelay, 0, options.maxRetryDelay || 5000);
				console.log(method + ": " + url + " - Error " + xhr.status + ". Retrying in " + retryDelay + " ms");
				setTimeout(function () {
					options.retrying = false;
					_this2.request(method, url, options, options.callback);
				}, retryDelay);
			} else {
				options.callback(xhr.status === 0 ? 'Network error' : xhr.status, null);
			}
		};
		return Http;
	}();
	Http.ContentType = {
		AAC: 'audio/aac',
		BASIS: 'image/basis',
		BIN: 'application/octet-stream',
		DDS: 'image/dds',
		FORM_URLENCODED: 'application/x-www-form-urlencoded',
		GIF: 'image/gif',
		GLB: 'model/gltf-binary',
		JPEG: 'image/jpeg',
		JSON: 'application/json',
		MP3: 'audio/mpeg',
		MP4: 'audio/mp4',
		OGG: 'audio/ogg',
		OPUS: 'audio/ogg; codecs="opus"',
		PNG: 'image/png',
		TEXT: 'text/plain',
		WAV: 'audio/x-wav',
		XML: 'application/xml'
	};
	Http.ResponseType = {
		TEXT: 'text',
		ARRAY_BUFFER: 'arraybuffer',
		BLOB: 'blob',
		DOCUMENT: 'document',
		JSON: 'json'
	};
	Http.binaryExtensions = ['.model', '.wav', '.ogg', '.mp3', '.mp4', '.m4a', '.aac', '.dds', '.basis', '.glb', '.opus'];
	Http.retryDelay = 100;
	var http = new Http();

	function hasAudioContext() {
		return !!(typeof AudioContext !== 'undefined' || typeof webkitAudioContext !== 'undefined');
	}

	var Channel = function () {
		function Channel(manager, sound, options) {
			var _options$volume, _options$loop, _options$pitch;
			if (options === void 0) {
				options = {};
			}
			this.volume = (_options$volume = options.volume) != null ? _options$volume : 1;
			this.loop = (_options$loop = options.loop) != null ? _options$loop : false;
			this.pitch = (_options$pitch = options.pitch) != null ? _options$pitch : 1;
			this.sound = sound;
			this.paused = false;
			this.suspended = false;
			this.manager = manager;
			this.source = null;
			if (hasAudioContext()) {
				this.startTime = 0;
				this.startOffset = 0;
				var context = manager.context;
				this.gain = context.createGain();
			} else if (sound.audio) {
				this.source = sound.audio.cloneNode(false);
				this.source.pause();
			}
		}
		var _proto = Channel.prototype;
		_proto.getVolume = function getVolume() {
			return this.volume;
		};
		_proto.getLoop = function getLoop() {
			return this.loop;
		};
		_proto.setLoop = function setLoop(loop) {
			this.loop = loop;
			if (this.source) {
				this.source.loop = loop;
			}
		};
		_proto.getPitch = function getPitch() {
			return this.pitch;
		};
		_proto.onManagerVolumeChange = function onManagerVolumeChange() {
			this.setVolume(this.getVolume());
		};
		_proto.onManagerSuspend = function onManagerSuspend() {
			if (this.isPlaying() && !this.suspended) {
				this.suspended = true;
				this.pause();
			}
		};
		_proto.onManagerResume = function onManagerResume() {
			if (this.suspended) {
				this.suspended = false;
				this.unpause();
			}
		};
		_proto.play = function play() {
			if (this.source) {
				throw new Error('Call stop() before calling play()');
			}
			this._createSource();
			if (!this.source) {
				return;
			}
			this.startTime = this.manager.context.currentTime;
			this.source.start(0, this.startOffset % this.source.buffer.duration);
			this.setVolume(this.volume);
			this.setLoop(this.loop);
			this.setPitch(this.pitch);
			this.manager.on('volumechange', this.onManagerVolumeChange, this);
			this.manager.on('suspend', this.onManagerSuspend, this);
			this.manager.on('resume', this.onManagerResume, this);
			if (this.manager.suspended) this.onManagerSuspend();
		};
		_proto.pause = function pause() {
			if (this.source) {
				this.paused = true;
				this.startOffset += this.manager.context.currentTime - this.startTime;
				this.source.stop(0);
				this.source = null;
			}
		};
		_proto.unpause = function unpause() {
			if (this.source || !this.paused) {
				console.warn('Call pause() before unpausing.');
				return;
			}
			this._createSource();
			if (!this.source) {
				return;
			}
			this.startTime = this.manager.context.currentTime;
			this.source.start(0, this.startOffset % this.source.buffer.duration);
			this.setVolume(this.volume);
			this.setLoop(this.loop);
			this.setPitch(this.pitch);
			this.paused = false;
		};
		_proto.stop = function stop() {
			if (this.source) {
				this.source.stop(0);
				this.source = null;
			}
			this.manager.off('volumechange', this.onManagerVolumeChange, this);
			this.manager.off('suspend', this.onManagerSuspend, this);
			this.manager.off('resume', this.onManagerResume, this);
		};
		_proto.setVolume = function setVolume(volume) {
			volume = math.clamp(volume, 0, 1);
			this.volume = volume;
			if (this.gain) {
				this.gain.gain.value = volume * this.manager.volume;
			}
		};
		_proto.setPitch = function setPitch(pitch) {
			this.pitch = pitch;
			if (this.source) {
				this.source.playbackRate.value = pitch;
			}
		};
		_proto.isPlaying = function isPlaying() {
			return !this.paused && this.source.playbackState === this.source.PLAYING_STATE;
		};
		_proto.getDuration = function getDuration() {
			return this.source ? this.source.buffer.duration : 0;
		};
		_proto._createSource = function _createSource() {
			var context = this.manager.context;
			if (this.sound.buffer) {
				this.source = context.createBufferSource();
				this.source.buffer = this.sound.buffer;
				this.source.connect(this.gain);
				this.gain.connect(context.destination);
				if (!this.loop) {
					this.source.onended = this.pause.bind(this);
				}
			}
		};
		return Channel;
	}();
	if (!hasAudioContext()) {
		Object.assign(Channel.prototype, {
			play: function play() {
				if (this.source) {
					this.paused = false;
					this.setVolume(this.volume);
					this.setLoop(this.loop);
					this.setPitch(this.pitch);
					this.source.play();
				}
				this.manager.on('volumechange', this.onManagerVolumeChange, this);
				this.manager.on('suspend', this.onManagerSuspend, this);
				this.manager.on('resume', this.onManagerResume, this);
				if (this.manager.suspended) this.onManagerSuspend();
			},
			pause: function pause() {
				if (this.source) {
					this.paused = true;
					this.source.pause();
				}
			},
			unpause: function unpause() {
				if (this.source) {
					this.paused = false;
					this.source.play();
				}
			},
			stop: function stop() {
				if (this.source) {
					this.source.pause();
				}
				this.manager.off('volumechange', this.onManagerVolumeChange, this);
				this.manager.off('suspend', this.onManagerSuspend, this);
				this.manager.off('resume', this.onManagerResume, this);
			},
			setVolume: function setVolume(volume) {
				volume = math.clamp(volume, 0, 1);
				this.volume = volume;
				if (this.source) {
					this.source.volume = volume * this.manager.volume;
				}
			},
			setPitch: function setPitch(pitch) {
				this.pitch = pitch;
				if (this.source) {
					this.source.playbackRate = pitch;
				}
			},
			getDuration: function getDuration() {
				return this.source && !isNaN(this.source.duration) ? this.source.duration : 0;
			},
			isPlaying: function isPlaying() {
				return !this.source.paused;
			}
		});
	}

	var MAX_DISTANCE$1 = 10000;
	var Channel3d = function (_Channel) {
		_inheritsLoose(Channel3d, _Channel);
		function Channel3d(manager, sound, options) {
			var _this;
			_this = _Channel.call(this, manager, sound, options) || this;
			_this.position = new Vec3();
			_this.velocity = new Vec3();
			if (hasAudioContext()) {
				_this.panner = manager.context.createPanner();
			} else {
				_this.maxDistance = MAX_DISTANCE$1;
				_this.minDistance = 1;
				_this.rollOffFactor = 1;
				_this.distanceModel = DISTANCE_INVERSE;
			}
			return _this;
		}
		var _proto = Channel3d.prototype;
		_proto.getPosition = function getPosition() {
			return this.position;
		};
		_proto.setPosition = function setPosition(position) {
			this.position.copy(position);
			var panner = this.panner;
			if ('positionX' in panner) {
				panner.positionX.value = position.x;
				panner.positionY.value = position.y;
				panner.positionZ.value = position.z;
			} else if (panner.setPosition) {
				panner.setPosition(position.x, position.y, position.z);
			}
		};
		_proto.getVelocity = function getVelocity() {
			return this.velocity;
		};
		_proto.setVelocity = function setVelocity(velocity) {
			this.velocity.copy(velocity);
		};
		_proto.getMaxDistance = function getMaxDistance() {
			return this.panner.maxDistance;
		};
		_proto.setMaxDistance = function setMaxDistance(max) {
			this.panner.maxDistance = max;
		};
		_proto.getMinDistance = function getMinDistance() {
			return this.panner.refDistance;
		};
		_proto.setMinDistance = function setMinDistance(min) {
			this.panner.refDistance = min;
		};
		_proto.getRollOffFactor = function getRollOffFactor() {
			return this.panner.rolloffFactor;
		};
		_proto.setRollOffFactor = function setRollOffFactor(factor) {
			this.panner.rolloffFactor = factor;
		};
		_proto.getDistanceModel = function getDistanceModel() {
			return this.panner.distanceModel;
		};
		_proto.setDistanceModel = function setDistanceModel(distanceModel) {
			this.panner.distanceModel = distanceModel;
		};
		_proto._createSource = function _createSource() {
			var context = this.manager.context;
			this.source = context.createBufferSource();
			this.source.buffer = this.sound.buffer;
			this.source.connect(this.panner);
			this.panner.connect(this.gain);
			this.gain.connect(context.destination);
			if (!this.loop) {
				this.source.onended = this.pause.bind(this);
			}
		};
		return Channel3d;
	}(Channel);
	if (!hasAudioContext()) {
		var offset$1 = new Vec3();
		var fallOff$1 = function fallOff(posOne, posTwo, refDistance, maxDistance, rolloffFactor, distanceModel) {
			offset$1 = offset$1.sub2(posOne, posTwo);
			var distance = offset$1.length();
			if (distance < refDistance) {
				return 1;
			} else if (distance > maxDistance) {
				return 0;
			}
			var result = 0;
			if (distanceModel === DISTANCE_LINEAR) {
				result = 1 - rolloffFactor * (distance - refDistance) / (maxDistance - refDistance);
			} else if (distanceModel === DISTANCE_INVERSE) {
				result = refDistance / (refDistance + rolloffFactor * (distance - refDistance));
			} else if (distanceModel === DISTANCE_EXPONENTIAL) {
				result = Math.pow(distance / refDistance, -rolloffFactor);
			}
			return math.clamp(result, 0, 1);
		};
		Object.assign(Channel3d.prototype, {
			setPosition: function setPosition(position) {
				this.position.copy(position);
				if (this.source) {
					var listener = this.manager.listener;
					var lpos = listener.getPosition();
					var factor = fallOff$1(lpos, this.position, this.minDistance, this.maxDistance, this.rollOffFactor, this.distanceModel);
					var v = this.getVolume();
					this.source.volume = v * factor;
				}
			},
			getMaxDistance: function getMaxDistance() {
				return this.maxDistance;
			},
			setMaxDistance: function setMaxDistance(max) {
				this.maxDistance = max;
			},
			getMinDistance: function getMinDistance() {
				return this.minDistance;
			},
			setMinDistance: function setMinDistance(min) {
				this.minDistance = min;
			},
			getRollOffFactor: function getRollOffFactor() {
				return this.rollOffFactor;
			},
			setRollOffFactor: function setRollOffFactor(factor) {
				this.rollOffFactor = factor;
			},
			getDistanceModel: function getDistanceModel() {
				return this.distanceModel;
			},
			setDistanceModel: function setDistanceModel(distanceModel) {
				this.distanceModel = distanceModel;
			}
		});
	}

	var Listener = function () {
		function Listener(manager) {
			this._manager = manager;
			this.position = new Vec3();
			this.velocity = new Vec3();
			this.orientation = new Mat4();
		}
		var _proto = Listener.prototype;
		_proto.getPosition = function getPosition() {
			return this.position;
		};
		_proto.setPosition = function setPosition(position) {
			this.position.copy(position);
			var listener = this.listener;
			if (listener) {
				if ('positionX' in listener) {
					listener.positionX.value = position.x;
					listener.positionY.value = position.y;
					listener.positionZ.value = position.z;
				} else if (listener.setPosition) {
					listener.setPosition(position.x, position.y, position.z);
				}
			}
		};
		_proto.getVelocity = function getVelocity() {
			return this.velocity;
		};
		_proto.setVelocity = function setVelocity(velocity) {};
		_proto.setOrientation = function setOrientation(orientation) {
			this.orientation.copy(orientation);
			var listener = this.listener;
			if (listener) {
				var m = orientation.data;
				if ('forwardX' in listener) {
					listener.forwardX.value = -m[8];
					listener.forwardY.value = -m[9];
					listener.forwardZ.value = -m[10];
					listener.upX.value = m[4];
					listener.upY.value = m[5];
					listener.upZ.value = m[6];
				} else if (listener.setOrientation) {
					listener.setOrientation(-m[8], -m[9], -m[10], m[4], m[5], m[6]);
				}
			}
		};
		_proto.getOrientation = function getOrientation() {
			return this.orientation;
		};
		_createClass(Listener, [{
			key: "listener",
			get: function get() {
				var context = this._manager.context;
				return context ? context.listener : null;
			}
		}]);
		return Listener;
	}();

	var CONTEXT_STATE_RUNNING = 'running';
	var USER_INPUT_EVENTS = ['click', 'touchstart', 'mousedown'];
	var SoundManager = function (_EventHandler) {
		_inheritsLoose(SoundManager, _EventHandler);
		function SoundManager() {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this._context = null;
			_this.AudioContext = typeof AudioContext !== 'undefined' && AudioContext || typeof webkitAudioContext !== 'undefined' && webkitAudioContext;
			if (!_this.AudioContext) ;
			_this._unlockHandlerFunc = _this._unlockHandler.bind(_assertThisInitialized(_this));
			_this._userSuspended = false;
			_this.listener = new Listener(_assertThisInitialized(_this));
			_this._volume = 1;
			return _this;
		}
		var _proto = SoundManager.prototype;
		_proto.suspend = function suspend() {
			if (!this._userSuspended) {
				this._userSuspended = true;
				if (this._context && this._context.state === CONTEXT_STATE_RUNNING) {
					this._suspend();
				}
			}
		};
		_proto.resume = function resume() {
			if (this._userSuspended) {
				this._userSuspended = false;
				if (this._context && this._context.state !== CONTEXT_STATE_RUNNING) {
					this._resume();
				}
			}
		};
		_proto.destroy = function destroy() {
			this.fire('destroy');
			if (this._context) {
				var _this$_context;
				this._removeUnlockListeners();
				(_this$_context = this._context) == null || _this$_context.close();
				this._context = null;
			}
		};
		_proto.playSound = function playSound(sound, options) {
			if (options === void 0) {
				options = {};
			}
			var channel = null;
			if (Channel) {
				channel = new Channel(this, sound, options);
				channel.play();
			}
			return channel;
		};
		_proto.playSound3d = function playSound3d(sound, position, options) {
			if (options === void 0) {
				options = {};
			}
			var channel = null;
			if (Channel3d) {
				channel = new Channel3d(this, sound, options);
				channel.setPosition(position);
				if (options.volume) {
					channel.setVolume(options.volume);
				}
				if (options.loop) {
					channel.setLoop(options.loop);
				}
				if (options.maxDistance) {
					channel.setMaxDistance(options.maxDistance);
				}
				if (options.minDistance) {
					channel.setMinDistance(options.minDistance);
				}
				if (options.rollOffFactor) {
					channel.setRollOffFactor(options.rollOffFactor);
				}
				if (options.distanceModel) {
					channel.setDistanceModel(options.distanceModel);
				}
				channel.play();
			}
			return channel;
		};
		_proto._resume = function _resume() {
			var _this2 = this;
			this._context.resume().then(function () {
				var source = _this2._context.createBufferSource();
				source.buffer = _this2._context.createBuffer(1, 1, _this2._context.sampleRate);
				source.connect(_this2._context.destination);
				source.start(0);
				source.onended = function (event) {
					source.disconnect(0);
					_this2.fire('resume');
				};
			}, function (e) {}).catch(function (e) {});
		};
		_proto._suspend = function _suspend() {
			var _this3 = this;
			this._context.suspend().then(function () {
				_this3.fire('suspend');
			}, function (e) {}).catch(function (e) {});
		};
		_proto._unlockHandler = function _unlockHandler() {
			this._removeUnlockListeners();
			if (!this._userSuspended && this._context.state !== CONTEXT_STATE_RUNNING) {
				this._resume();
			}
		};
		_proto._registerUnlockListeners = function _registerUnlockListeners() {
			var _this4 = this;
			USER_INPUT_EVENTS.forEach(function (eventName) {
				window.addEventListener(eventName, _this4._unlockHandlerFunc, false);
			});
		};
		_proto._removeUnlockListeners = function _removeUnlockListeners() {
			var _this5 = this;
			USER_INPUT_EVENTS.forEach(function (eventName) {
				window.removeEventListener(eventName, _this5._unlockHandlerFunc, false);
			});
		};
		_createClass(SoundManager, [{
			key: "volume",
			get: function get() {
				return this._volume;
			},
			set: function set(volume) {
				volume = math.clamp(volume, 0, 1);
				this._volume = volume;
				this.fire('volumechange', volume);
			}
		}, {
			key: "suspended",
			get: function get() {
				return this._userSuspended;
			}
		}, {
			key: "context",
			get: function get() {
				if (!this._context && this.AudioContext) {
					this._context = new this.AudioContext();
					if (this._context.state !== CONTEXT_STATE_RUNNING) {
						this._registerUnlockListeners();
					}
				}
				return this._context;
			}
		}]);
		return SoundManager;
	}(EventHandler);

	var Sound = function () {
		function Sound(resource) {
			this.audio = void 0;
			this.buffer = void 0;
			if (resource instanceof Audio) {
				this.audio = resource;
			} else {
				this.buffer = resource;
			}
		}
		_createClass(Sound, [{
			key: "duration",
			get: function get() {
				var duration = 0;
				if (this.buffer) {
					duration = this.buffer.duration;
				} else if (this.audio) {
					duration = this.audio.duration;
				}
				return duration || 0;
			}
		}]);
		return Sound;
	}();

	var STATE_PLAYING = 0;
	var STATE_PAUSED = 1;
	var STATE_STOPPED = 2;
	function capTime(time, duration) {
		return time % duration || 0;
	}
	var SoundInstance = function (_EventHandler) {
		_inheritsLoose(SoundInstance, _EventHandler);
		function SoundInstance(manager, sound, options) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this.source = null;
			_this._manager = manager;
			_this._volume = options.volume !== undefined ? math.clamp(Number(options.volume) || 0, 0, 1) : 1;
			_this._pitch = options.pitch !== undefined ? Math.max(0.01, Number(options.pitch) || 0) : 1;
			_this._loop = !!(options.loop !== undefined ? options.loop : false);
			_this._sound = sound;
			_this._state = STATE_STOPPED;
			_this._suspended = false;
			_this._suspendEndEvent = 0;
			_this._suspendInstanceEvents = false;
			_this._playWhenLoaded = true;
			_this._startTime = Math.max(0, Number(options.startTime) || 0);
			_this._duration = Math.max(0, Number(options.duration) || 0);
			_this._startOffset = null;
			_this._onPlayCallback = options.onPlay;
			_this._onPauseCallback = options.onPause;
			_this._onResumeCallback = options.onResume;
			_this._onStopCallback = options.onStop;
			_this._onEndCallback = options.onEnd;
			if (hasAudioContext()) {
				_this._startedAt = 0;
				_this._currentTime = 0;
				_this._currentOffset = 0;
				_this._inputNode = null;
				_this._connectorNode = null;
				_this._firstNode = null;
				_this._lastNode = null;
				_this._waitingContextSuspension = false;
				_this._initializeNodes();
				_this._endedHandler = _this._onEnded.bind(_assertThisInitialized(_this));
			} else {
				_this._isReady = false;
				_this._loadedMetadataHandler = _this._onLoadedMetadata.bind(_assertThisInitialized(_this));
				_this._timeUpdateHandler = _this._onTimeUpdate.bind(_assertThisInitialized(_this));
				_this._endedHandler = _this._onEnded.bind(_assertThisInitialized(_this));
				_this._createSource();
			}
			return _this;
		}
		var _proto = SoundInstance.prototype;
		_proto._onPlay = function _onPlay() {
			this.fire('play');
			if (this._onPlayCallback) this._onPlayCallback(this);
		};
		_proto._onPause = function _onPause() {
			this.fire('pause');
			if (this._onPauseCallback) this._onPauseCallback(this);
		};
		_proto._onResume = function _onResume() {
			this.fire('resume');
			if (this._onResumeCallback) this._onResumeCallback(this);
		};
		_proto._onStop = function _onStop() {
			this.fire('stop');
			if (this._onStopCallback) this._onStopCallback(this);
		};
		_proto._onEnded = function _onEnded() {
			if (this._suspendEndEvent > 0) {
				this._suspendEndEvent--;
				return;
			}
			this.fire('end');
			if (this._onEndCallback) this._onEndCallback(this);
			this.stop();
		};
		_proto._onManagerVolumeChange = function _onManagerVolumeChange() {
			this.volume = this._volume;
		};
		_proto._onManagerSuspend = function _onManagerSuspend() {
			if (this._state === STATE_PLAYING && !this._suspended) {
				this._suspended = true;
				this.pause();
			}
		};
		_proto._onManagerResume = function _onManagerResume() {
			if (this._suspended) {
				this._suspended = false;
				this.resume();
			}
		};
		_proto._initializeNodes = function _initializeNodes() {
			this.gain = this._manager.context.createGain();
			this._inputNode = this.gain;
			this._connectorNode = this.gain;
			this._connectorNode.connect(this._manager.context.destination);
		};
		_proto.play = function play() {
			if (this._state !== STATE_STOPPED) {
				this.stop();
			}
			this._state = STATE_PLAYING;
			this._playWhenLoaded = false;
			if (this._waitingContextSuspension) {
				return false;
			}
			if (this._manager.suspended) {
				this._manager.once('resume', this._playAudioImmediate, this);
				this._waitingContextSuspension = true;
				return false;
			}
			this._playAudioImmediate();
			return true;
		};
		_proto._playAudioImmediate = function _playAudioImmediate() {
			this._waitingContextSuspension = false;
			if (this._state !== STATE_PLAYING) {
				return;
			}
			if (!this.source) {
				this._createSource();
			}
			var offset = capTime(this._startOffset, this.duration);
			offset = capTime(this._startTime + offset, this._sound.duration);
			this._startOffset = null;
			if (this._duration) {
				this.source.start(0, offset, this._duration);
			} else {
				this.source.start(0, offset);
			}
			this._startedAt = this._manager.context.currentTime;
			this._currentTime = 0;
			this._currentOffset = offset;
			this.volume = this._volume;
			this.loop = this._loop;
			this.pitch = this._pitch;
			this._manager.on('volumechange', this._onManagerVolumeChange, this);
			this._manager.on('suspend', this._onManagerSuspend, this);
			this._manager.on('resume', this._onManagerResume, this);
			this._manager.on('destroy', this._onManagerDestroy, this);
			if (!this._suspendInstanceEvents) {
				this._onPlay();
			}
		};
		_proto.pause = function pause() {
			this._playWhenLoaded = false;
			if (this._state !== STATE_PLAYING) return false;
			this._state = STATE_PAUSED;
			if (this._waitingContextSuspension) {
				return true;
			}
			this._updateCurrentTime();
			this._suspendEndEvent++;
			this.source.stop(0);
			this.source = null;
			this._startOffset = null;
			if (!this._suspendInstanceEvents) this._onPause();
			return true;
		};
		_proto.resume = function resume() {
			if (this._state !== STATE_PAUSED) {
				return false;
			}
			var offset = this.currentTime;
			this._state = STATE_PLAYING;
			if (this._waitingContextSuspension) {
				return true;
			}
			if (!this.source) {
				this._createSource();
			}
			if (this._startOffset !== null) {
				offset = capTime(this._startOffset, this.duration);
				offset = capTime(this._startTime + offset, this._sound.duration);
				this._startOffset = null;
			}
			if (this._duration) {
				this.source.start(0, offset, this._duration);
			} else {
				this.source.start(0, offset);
			}
			this._startedAt = this._manager.context.currentTime;
			this._currentOffset = offset;
			this.volume = this._volume;
			this.loop = this._loop;
			this.pitch = this._pitch;
			this._playWhenLoaded = false;
			if (!this._suspendInstanceEvents) this._onResume();
			return true;
		};
		_proto.stop = function stop() {
			this._playWhenLoaded = false;
			if (this._state === STATE_STOPPED) return false;
			var wasPlaying = this._state === STATE_PLAYING;
			this._state = STATE_STOPPED;
			if (this._waitingContextSuspension) {
				return true;
			}
			this._manager.off('volumechange', this._onManagerVolumeChange, this);
			this._manager.off('suspend', this._onManagerSuspend, this);
			this._manager.off('resume', this._onManagerResume, this);
			this._manager.off('destroy', this._onManagerDestroy, this);
			this._startedAt = 0;
			this._currentTime = 0;
			this._currentOffset = 0;
			this._startOffset = null;
			this._suspendEndEvent++;
			if (wasPlaying && this.source) {
				this.source.stop(0);
			}
			this.source = null;
			if (!this._suspendInstanceEvents) this._onStop();
			return true;
		};
		_proto.setExternalNodes = function setExternalNodes(firstNode, lastNode) {
			if (!firstNode) {
				console.error('The firstNode must be a valid Audio Node');
				return;
			}
			if (!lastNode) {
				lastNode = firstNode;
			}
			var speakers = this._manager.context.destination;
			if (this._firstNode !== firstNode) {
				if (this._firstNode) {
					this._connectorNode.disconnect(this._firstNode);
				} else {
					this._connectorNode.disconnect(speakers);
				}
				this._firstNode = firstNode;
				this._connectorNode.connect(firstNode);
			}
			if (this._lastNode !== lastNode) {
				if (this._lastNode) {
					this._lastNode.disconnect(speakers);
				}
				this._lastNode = lastNode;
				this._lastNode.connect(speakers);
			}
		};
		_proto.clearExternalNodes = function clearExternalNodes() {
			var speakers = this._manager.context.destination;
			if (this._firstNode) {
				this._connectorNode.disconnect(this._firstNode);
				this._firstNode = null;
			}
			if (this._lastNode) {
				this._lastNode.disconnect(speakers);
				this._lastNode = null;
			}
			this._connectorNode.connect(speakers);
		};
		_proto.getExternalNodes = function getExternalNodes() {
			return [this._firstNode, this._lastNode];
		};
		_proto._createSource = function _createSource() {
			if (!this._sound) {
				return null;
			}
			var context = this._manager.context;
			if (this._sound.buffer) {
				this.source = context.createBufferSource();
				this.source.buffer = this._sound.buffer;
				this.source.connect(this._inputNode);
				this.source.onended = this._endedHandler;
				this.source.loopStart = capTime(this._startTime, this.source.buffer.duration);
				if (this._duration) {
					this.source.loopEnd = Math.max(this.source.loopStart, capTime(this._startTime + this._duration, this.source.buffer.duration));
				}
			}
			return this.source;
		};
		_proto._updateCurrentTime = function _updateCurrentTime() {
			this._currentTime = capTime((this._manager.context.currentTime - this._startedAt) * this._pitch + this._currentOffset, this.duration);
		};
		_proto._onManagerDestroy = function _onManagerDestroy() {
			if (this.source && this._state === STATE_PLAYING) {
				this.source.stop(0);
				this.source = null;
			}
		};
		_createClass(SoundInstance, [{
			key: "currentTime",
			get: function get() {
				if (this._startOffset !== null) {
					return this._startOffset;
				}
				if (this._state === STATE_PAUSED) {
					return this._currentTime;
				}
				if (this._state === STATE_STOPPED || !this.source) {
					return 0;
				}
				this._updateCurrentTime();
				return this._currentTime;
			},
			set: function set(value) {
				if (value < 0) return;
				if (this._state === STATE_PLAYING) {
					var suspend = this._suspendInstanceEvents;
					this._suspendInstanceEvents = true;
					this.stop();
					this._startOffset = value;
					this.play();
					this._suspendInstanceEvents = suspend;
				} else {
					this._startOffset = value;
					this._currentTime = value;
				}
			}
		}, {
			key: "duration",
			get: function get() {
				if (!this._sound) {
					return 0;
				}
				if (this._duration) {
					return capTime(this._duration, this._sound.duration);
				}
				return this._sound.duration;
			},
			set: function set(value) {
				this._duration = Math.max(0, Number(value) || 0);
				var isPlaying = this._state === STATE_PLAYING;
				this.stop();
				if (isPlaying) {
					this.play();
				}
			}
		}, {
			key: "isPaused",
			get: function get() {
				return this._state === STATE_PAUSED;
			}
		}, {
			key: "isPlaying",
			get: function get() {
				return this._state === STATE_PLAYING;
			}
		}, {
			key: "isStopped",
			get: function get() {
				return this._state === STATE_STOPPED;
			}
		}, {
			key: "isSuspended",
			get: function get() {
				return this._suspended;
			}
		}, {
			key: "loop",
			get: function get() {
				return this._loop;
			},
			set: function set(value) {
				this._loop = !!value;
				if (this.source) {
					this.source.loop = this._loop;
				}
			}
		}, {
			key: "pitch",
			get: function get() {
				return this._pitch;
			},
			set: function set(pitch) {
				this._currentOffset = this.currentTime;
				this._startedAt = this._manager.context.currentTime;
				this._pitch = Math.max(Number(pitch) || 0, 0.01);
				if (this.source) {
					this.source.playbackRate.value = this._pitch;
				}
			}
		}, {
			key: "sound",
			get: function get() {
				return this._sound;
			},
			set: function set(value) {
				this._sound = value;
				if (this._state !== STATE_STOPPED) {
					this.stop();
				} else {
					this._createSource();
				}
			}
		}, {
			key: "startTime",
			get: function get() {
				return this._startTime;
			},
			set: function set(value) {
				this._startTime = Math.max(0, Number(value) || 0);
				var isPlaying = this._state === STATE_PLAYING;
				this.stop();
				if (isPlaying) {
					this.play();
				}
			}
		}, {
			key: "volume",
			get: function get() {
				return this._volume;
			},
			set: function set(volume) {
				volume = math.clamp(volume, 0, 1);
				this._volume = volume;
				if (this.gain) {
					this.gain.gain.value = volume * this._manager.volume;
				}
			}
		}]);
		return SoundInstance;
	}(EventHandler);
	if (!hasAudioContext()) {
		Object.assign(SoundInstance.prototype, {
			play: function play() {
				if (this._state !== STATE_STOPPED) {
					this.stop();
				}
				if (!this.source) {
					if (!this._createSource()) {
						return false;
					}
				}
				this.volume = this._volume;
				this.pitch = this._pitch;
				this.loop = this._loop;
				this.source.play();
				this._state = STATE_PLAYING;
				this._playWhenLoaded = false;
				this._manager.on('volumechange', this._onManagerVolumeChange, this);
				this._manager.on('suspend', this._onManagerSuspend, this);
				this._manager.on('resume', this._onManagerResume, this);
				this._manager.on('destroy', this._onManagerDestroy, this);
				if (this._manager.suspended) this._onManagerSuspend();
				if (!this._suspendInstanceEvents) this._onPlay();
				return true;
			},
			pause: function pause() {
				if (!this.source || this._state !== STATE_PLAYING) return false;
				this._suspendEndEvent++;
				this.source.pause();
				this._playWhenLoaded = false;
				this._state = STATE_PAUSED;
				this._startOffset = null;
				if (!this._suspendInstanceEvents) this._onPause();
				return true;
			},
			resume: function resume() {
				if (!this.source || this._state !== STATE_PAUSED) return false;
				this._state = STATE_PLAYING;
				this._playWhenLoaded = false;
				if (this.source.paused) {
					this.source.play();
					if (!this._suspendInstanceEvents) this._onResume();
				}
				return true;
			},
			stop: function stop() {
				if (!this.source || this._state === STATE_STOPPED) return false;
				this._manager.off('volumechange', this._onManagerVolumeChange, this);
				this._manager.off('suspend', this._onManagerSuspend, this);
				this._manager.off('resume', this._onManagerResume, this);
				this._manager.off('destroy', this._onManagerDestroy, this);
				this._suspendEndEvent++;
				this.source.pause();
				this._playWhenLoaded = false;
				this._state = STATE_STOPPED;
				this._startOffset = null;
				if (!this._suspendInstanceEvents) this._onStop();
				return true;
			},
			setExternalNodes: function setExternalNodes() {},
			clearExternalNodes: function clearExternalNodes() {},
			getExternalNodes: function getExternalNodes() {
				return [null, null];
			},
			_onLoadedMetadata: function _onLoadedMetadata() {
				this.source.removeEventListener('loadedmetadata', this._loadedMetadataHandler);
				this._isReady = true;
				var offset = capTime(this._startOffset, this.duration);
				offset = capTime(this._startTime + offset, this._sound.duration);
				this._startOffset = null;
				this.source.currentTime = offset;
			},
			_createSource: function _createSource() {
				if (this._sound && this._sound.audio) {
					this._isReady = false;
					this.source = this._sound.audio.cloneNode(true);
					this.source.addEventListener('loadedmetadata', this._loadedMetadataHandler);
					this.source.addEventListener('timeupdate', this._timeUpdateHandler);
					this.source.onended = this._endedHandler;
				}
				return this.source;
			},
			_onTimeUpdate: function _onTimeUpdate() {
				if (!this._duration) return;
				if (this.source.currentTime > capTime(this._startTime + this._duration, this.source.duration)) {
					if (this.loop) {
						this.source.currentTime = capTime(this._startTime, this.source.duration);
					} else {
						this.source.removeEventListener('timeupdate', this._timeUpdateHandler);
						this.source.pause();
						this._onEnded();
					}
				}
			},
			_onManagerDestroy: function _onManagerDestroy() {
				if (this.source) {
					this.source.pause();
				}
			}
		});
		Object.defineProperty(SoundInstance.prototype, 'volume', {
			get: function get() {
				return this._volume;
			},
			set: function set(volume) {
				volume = math.clamp(volume, 0, 1);
				this._volume = volume;
				if (this.source) {
					this.source.volume = volume * this._manager.volume;
				}
			}
		});
		Object.defineProperty(SoundInstance.prototype, 'pitch', {
			get: function get() {
				return this._pitch;
			},
			set: function set(pitch) {
				this._pitch = Math.max(Number(pitch) || 0, 0.01);
				if (this.source) {
					this.source.playbackRate = this._pitch;
				}
			}
		});
		Object.defineProperty(SoundInstance.prototype, 'sound', {
			get: function get() {
				return this._sound;
			},
			set: function set(value) {
				this.stop();
				this._sound = value;
			}
		});
		Object.defineProperty(SoundInstance.prototype, 'currentTime', {
			get: function get() {
				if (this._startOffset !== null) {
					return this._startOffset;
				}
				if (this._state === STATE_STOPPED || !this.source) {
					return 0;
				}
				return this.source.currentTime - this._startTime;
			},
			set: function set(value) {
				if (value < 0) return;
				this._startOffset = value;
				if (this.source && this._isReady) {
					this.source.currentTime = capTime(this._startTime + capTime(value, this.duration), this._sound.duration);
					this._startOffset = null;
				}
			}
		});
	}

	var MAX_DISTANCE = 10000;
	var SoundInstance3d = function (_SoundInstance) {
		_inheritsLoose(SoundInstance3d, _SoundInstance);
		function SoundInstance3d(manager, sound, options) {
			var _this;
			if (options === void 0) {
				options = {};
			}
			_this = _SoundInstance.call(this, manager, sound, options) || this;
			_this._position = new Vec3();
			_this._velocity = new Vec3();
			if (options.position) _this.position = options.position;
			_this.maxDistance = options.maxDistance !== undefined ? Number(options.maxDistance) : MAX_DISTANCE;
			_this.refDistance = options.refDistance !== undefined ? Number(options.refDistance) : 1;
			_this.rollOffFactor = options.rollOffFactor !== undefined ? Number(options.rollOffFactor) : 1;
			_this.distanceModel = options.distanceModel !== undefined ? options.distanceModel : DISTANCE_LINEAR;
			return _this;
		}
		var _proto = SoundInstance3d.prototype;
		_proto._initializeNodes = function _initializeNodes() {
			this.gain = this._manager.context.createGain();
			this.panner = this._manager.context.createPanner();
			this.panner.connect(this.gain);
			this._inputNode = this.panner;
			this._connectorNode = this.gain;
			this._connectorNode.connect(this._manager.context.destination);
		};
		_createClass(SoundInstance3d, [{
			key: "position",
			get: function get() {
				return this._position;
			},
			set: function set(value) {
				this._position.copy(value);
				var panner = this.panner;
				if ('positionX' in panner) {
					panner.positionX.value = value.x;
					panner.positionY.value = value.y;
					panner.positionZ.value = value.z;
				} else if (panner.setPosition) {
					panner.setPosition(value.x, value.y, value.z);
				}
			}
		}, {
			key: "velocity",
			get: function get() {
				return this._velocity;
			},
			set: function set(velocity) {
				this._velocity.copy(velocity);
			}
		}, {
			key: "maxDistance",
			get: function get() {
				return this.panner.maxDistance;
			},
			set: function set(value) {
				this.panner.maxDistance = value;
			}
		}, {
			key: "refDistance",
			get: function get() {
				return this.panner.refDistance;
			},
			set: function set(value) {
				this.panner.refDistance = value;
			}
		}, {
			key: "rollOffFactor",
			get: function get() {
				return this.panner.rolloffFactor;
			},
			set: function set(value) {
				this.panner.rolloffFactor = value;
			}
		}, {
			key: "distanceModel",
			get: function get() {
				return this.panner.distanceModel;
			},
			set: function set(value) {
				this.panner.distanceModel = value;
			}
		}]);
		return SoundInstance3d;
	}(SoundInstance);
	if (!hasAudioContext()) {
		var offset = new Vec3();
		var fallOff = function fallOff(posOne, posTwo, refDistance, maxDistance, rollOffFactor, distanceModel) {
			offset = offset.sub2(posOne, posTwo);
			var distance = offset.length();
			if (distance < refDistance) {
				return 1;
			} else if (distance > maxDistance) {
				return 0;
			}
			var result = 0;
			if (distanceModel === DISTANCE_LINEAR) {
				result = 1 - rollOffFactor * (distance - refDistance) / (maxDistance - refDistance);
			} else if (distanceModel === DISTANCE_INVERSE) {
				result = refDistance / (refDistance + rollOffFactor * (distance - refDistance));
			} else if (distanceModel === DISTANCE_EXPONENTIAL) {
				result = Math.pow(distance / refDistance, -rollOffFactor);
			}
			return math.clamp(result, 0, 1);
		};
		Object.defineProperty(SoundInstance3d.prototype, 'position', {
			get: function get() {
				return this._position;
			},
			set: function set(position) {
				this._position.copy(position);
				if (this.source) {
					var listener = this._manager.listener;
					var lpos = listener.getPosition();
					var factor = fallOff(lpos, this._position, this.refDistance, this.maxDistance, this.rollOffFactor, this.distanceModel);
					var v = this.volume;
					this.source.volume = v * factor * this._manager.volume;
				}
			}
		});
		Object.defineProperty(SoundInstance3d.prototype, 'maxDistance', {
			get: function get() {
				return this._maxDistance;
			},
			set: function set(value) {
				this._maxDistance = value;
			}
		});
		Object.defineProperty(SoundInstance3d.prototype, 'refDistance', {
			get: function get() {
				return this._refDistance;
			},
			set: function set(value) {
				this._refDistance = value;
			}
		});
		Object.defineProperty(SoundInstance3d.prototype, 'rollOffFactor', {
			get: function get() {
				return this._rollOffFactor;
			},
			set: function set(value) {
				this._rollOffFactor = value;
			}
		});
		Object.defineProperty(SoundInstance3d.prototype, 'distanceModel', {
			get: function get() {
				return this._distanceModel;
			},
			set: function set(value) {
				this._distanceModel = value;
			}
		});
	}

	var BLEND_SUBTRACTIVE = 0;
	var BLEND_ADDITIVE = 1;
	var BLEND_NORMAL = 2;
	var BLEND_NONE = 3;
	var BLEND_PREMULTIPLIED = 4;
	var BLEND_MULTIPLICATIVE = 5;
	var BLEND_ADDITIVEALPHA = 6;
	var BLEND_MULTIPLICATIVE2X = 7;
	var BLEND_SCREEN = 8;
	var BLEND_MIN = 9;
	var BLEND_MAX = 10;
	var FOG_NONE = 'none';
	var FOG_LINEAR = 'linear';
	var FOG_EXP = 'exp';
	var FOG_EXP2 = 'exp2';
	var FRESNEL_NONE = 0;
	var FRESNEL_SCHLICK = 2;
	var LAYER_HUD = 0;
	var LAYER_GIZMO = 1;
	var LAYER_FX = 2;
	var LAYER_WORLD = 15;
	var LAYERID_WORLD = 0;
	var LAYERID_DEPTH = 1;
	var LAYERID_SKYBOX = 2;
	var LAYERID_IMMEDIATE = 3;
	var LAYERID_UI = 4;
	var LIGHTTYPE_DIRECTIONAL = 0;
	var LIGHTTYPE_OMNI = 1;
	var LIGHTTYPE_POINT = LIGHTTYPE_OMNI;
	var LIGHTTYPE_SPOT = 2;
	var LIGHTTYPE_COUNT = 3;
	var LIGHTSHAPE_PUNCTUAL = 0;
	var LIGHTSHAPE_RECT = 1;
	var LIGHTSHAPE_DISK = 2;
	var LIGHTSHAPE_SPHERE = 3;
	var LIGHTFALLOFF_LINEAR = 0;
	var LIGHTFALLOFF_INVERSESQUARED = 1;
	var SHADOW_PCF3 = 0;
	var SHADOW_DEPTH = 0;
	var SHADOW_VSM8 = 1;
	var SHADOW_VSM16 = 2;
	var SHADOW_VSM32 = 3;
	var SHADOW_PCF5 = 4;
	var SHADOW_PCF1 = 5;
	var SHADOW_PCSS = 6;
	var shadowTypeToString = {};
	shadowTypeToString[SHADOW_PCF3] = 'PCF3';
	shadowTypeToString[SHADOW_VSM8] = 'VSM8';
	shadowTypeToString[SHADOW_VSM16] = 'VSM16';
	shadowTypeToString[SHADOW_VSM32] = 'VSM32';
	shadowTypeToString[SHADOW_PCF5] = 'PCF5';
	shadowTypeToString[SHADOW_PCF1] = 'PCF1';
	shadowTypeToString[SHADOW_PCSS] = 'PCSS';
	var BLUR_BOX = 0;
	var BLUR_GAUSSIAN = 1;
	var PARTICLESORT_NONE = 0;
	var PARTICLESORT_DISTANCE = 1;
	var PARTICLESORT_NEWER_FIRST = 2;
	var PARTICLESORT_OLDER_FIRST = 3;
	var PARTICLEMODE_GPU = 0;
	var PARTICLEMODE_CPU = 1;
	var EMITTERSHAPE_BOX = 0;
	var EMITTERSHAPE_SPHERE = 1;
	var PARTICLEORIENTATION_SCREEN = 0;
	var PARTICLEORIENTATION_WORLD = 1;
	var PARTICLEORIENTATION_EMITTER = 2;
	var PROJECTION_PERSPECTIVE = 0;
	var PROJECTION_ORTHOGRAPHIC = 1;
	var RENDERSTYLE_SOLID = 0;
	var RENDERSTYLE_WIREFRAME = 1;
	var RENDERSTYLE_POINTS = 2;
	var CUBEPROJ_NONE = 0;
	var CUBEPROJ_BOX = 1;
	var SPECULAR_PHONG = 0;
	var SPECULAR_BLINN = 1;
	var DETAILMODE_MUL = 'mul';
	var DETAILMODE_ADD = 'add';
	var DETAILMODE_SCREEN = 'screen';
	var DETAILMODE_OVERLAY = 'overlay';
	var DETAILMODE_MIN = 'min';
	var DETAILMODE_MAX = 'max';
	var GAMMA_NONE = 0;
	var GAMMA_SRGB = 1;
	var GAMMA_SRGBFAST = 2;
	var GAMMA_SRGBHDR = 3;
	var TONEMAP_LINEAR = 0;
	var TONEMAP_FILMIC = 1;
	var TONEMAP_HEJL = 2;
	var TONEMAP_ACES = 3;
	var TONEMAP_ACES2 = 4;
	var SPECOCC_NONE = 0;
	var SPECOCC_AO = 1;
	var SPECOCC_GLOSSDEPENDENT = 2;
	var SHADERDEF_NOSHADOW = 1;
	var SHADERDEF_SKIN = 2;
	var SHADERDEF_UV0 = 4;
	var SHADERDEF_UV1 = 8;
	var SHADERDEF_VCOLOR = 16;
	var SHADERDEF_INSTANCING = 32;
	var SHADERDEF_LM = 64;
	var SHADERDEF_DIRLM = 128;
	var SHADERDEF_SCREENSPACE = 256;
	var SHADERDEF_TANGENTS = 512;
	var SHADERDEF_MORPH_POSITION = 1024;
	var SHADERDEF_MORPH_NORMAL = 2048;
	var SHADERDEF_MORPH_TEXTURE_BASED = 4096;
	var SHADERDEF_LMAMBIENT = 8192;
	var LINEBATCH_WORLD = 0;
	var LINEBATCH_OVERLAY = 1;
	var LINEBATCH_GIZMO = 2;
	var SHADOWUPDATE_NONE = 0;
	var SHADOWUPDATE_THISFRAME = 1;
	var SHADOWUPDATE_REALTIME = 2;
	var SORTKEY_FORWARD = 0;
	var SORTKEY_DEPTH = 1;
	var MASK_AFFECT_DYNAMIC = 1;
	var MASK_AFFECT_LIGHTMAPPED = 2;
	var MASK_BAKE = 4;
	var SHADER_FORWARD = 0;
	var SHADER_FORWARDHDR = 1;
	var SHADER_DEPTH = 2;
	var SHADER_PICK = 3;
	var SHADER_SHADOW = 4;
	var SHADERPASS_FORWARD = 'forward';
	var SHADERPASS_ALBEDO = 'debug_albedo';
	var SHADERPASS_WORLDNORMAL = 'debug_world_normal';
	var SHADERPASS_OPACITY = 'debug_opacity';
	var SHADERPASS_SPECULARITY = 'debug_specularity';
	var SHADERPASS_GLOSS = 'debug_gloss';
	var SHADERPASS_METALNESS = 'debug_metalness';
	var SHADERPASS_AO = 'debug_ao';
	var SHADERPASS_EMISSION = 'debug_emission';
	var SHADERPASS_LIGHTING = 'debug_lighting';
	var SHADERPASS_UV0 = 'debug_uv0';
	var SPRITE_RENDERMODE_SIMPLE = 0;
	var SPRITE_RENDERMODE_SLICED = 1;
	var SPRITE_RENDERMODE_TILED = 2;
	var BAKE_COLOR = 0;
	var BAKE_COLORDIR = 1;
	var VIEW_CENTER = 0;
	var VIEW_LEFT = 1;
	var VIEW_RIGHT = 2;
	var SORTMODE_NONE = 0;
	var SORTMODE_MANUAL = 1;
	var SORTMODE_MATERIALMESH = 2;
	var SORTMODE_BACK2FRONT = 3;
	var SORTMODE_FRONT2BACK = 4;
	var SORTMODE_CUSTOM = 5;
	var ASPECT_AUTO = 0;
	var ASPECT_MANUAL = 1;
	var ORIENTATION_HORIZONTAL = 0;
	var ORIENTATION_VERTICAL = 1;

	var RefCountedObject = function () {
		function RefCountedObject() {
			this._refCount = 0;
		}
		var _proto = RefCountedObject.prototype;
		_proto.incRefCount = function incRefCount() {
			this._refCount++;
		};
		_proto.decRefCount = function decRefCount() {
			this._refCount--;
		};
		_createClass(RefCountedObject, [{
			key: "refCount",
			get: function get() {
				return this._refCount;
			}
		}]);
		return RefCountedObject;
	}();

	var GraphicsDeviceAccess = function () {
		function GraphicsDeviceAccess() {}
		GraphicsDeviceAccess.set = function set(graphicsDevice) {
			GraphicsDeviceAccess._graphicsDevice = graphicsDevice;
		};
		GraphicsDeviceAccess.get = function get() {
			return GraphicsDeviceAccess._graphicsDevice;
		};
		return GraphicsDeviceAccess;
	}();
	GraphicsDeviceAccess._graphicsDevice = null;

	var id$3 = 0;
	var GeometryData = function () {
		function GeometryData() {
			this.initDefaults();
		}
		var _proto = GeometryData.prototype;
		_proto.initDefaults = function initDefaults() {
			this.recreate = false;
			this.verticesUsage = BUFFER_STATIC;
			this.indicesUsage = BUFFER_STATIC;
			this.maxVertices = 0;
			this.maxIndices = 0;
			this.vertexCount = 0;
			this.indexCount = 0;
			this.vertexStreamsUpdated = false;
			this.indexStreamUpdated = false;
			this.vertexStreamDictionary = {};
			this.indices = null;
		};
		_proto._changeVertexCount = function _changeVertexCount(count, semantic) {
			if (!this.vertexCount) {
				this.vertexCount = count;
			}
		};
		return GeometryData;
	}();
	GeometryData.DEFAULT_COMPONENTS_POSITION = 3;
	GeometryData.DEFAULT_COMPONENTS_NORMAL = 3;
	GeometryData.DEFAULT_COMPONENTS_UV = 2;
	GeometryData.DEFAULT_COMPONENTS_COLORS = 4;
	var GeometryVertexStream = function GeometryVertexStream(data, componentCount, dataType, dataTypeNormalize) {
		this.data = data;
		this.componentCount = componentCount;
		this.dataType = dataType;
		this.dataTypeNormalize = dataTypeNormalize;
	};
	var Mesh = function (_RefCountedObject) {
		_inheritsLoose(Mesh, _RefCountedObject);
		function Mesh(graphicsDevice) {
			var _this;
			_this = _RefCountedObject.call(this) || this;
			_this._aabbVer = 0;
			_this._aabb = new BoundingBox();
			_this.id = id$3++;
			_this.device = graphicsDevice || GraphicsDeviceAccess.get();
			_this.vertexBuffer = null;
			_this.indexBuffer = [null];
			_this.primitive = [{
				type: 0,
				base: 0,
				count: 0
			}];
			_this.skin = null;
			_this._morph = null;
			_this._geometryData = null;
			_this.boneAabb = null;
			return _this;
		}
		var _proto2 = Mesh.prototype;
		_proto2.destroy = function destroy() {
			var morph = this.morph;
			if (morph) {
				this.morph = null;
				if (morph.refCount < 1) {
					morph.destroy();
				}
			}
			if (this.vertexBuffer) {
				this.vertexBuffer.destroy();
				this.vertexBuffer = null;
			}
			for (var j = 0; j < this.indexBuffer.length; j++) {
				this._destroyIndexBuffer(j);
			}
			this.indexBuffer.length = 0;
			this._geometryData = null;
		};
		_proto2._destroyIndexBuffer = function _destroyIndexBuffer(index) {
			if (this.indexBuffer[index]) {
				this.indexBuffer[index].destroy();
				this.indexBuffer[index] = null;
			}
		};
		_proto2._initBoneAabbs = function _initBoneAabbs(morphTargets) {
			this.boneAabb = [];
			this.boneUsed = [];
			var x, y, z;
			var bMax, bMin;
			var boneMin = [];
			var boneMax = [];
			var boneUsed = this.boneUsed;
			var numBones = this.skin.boneNames.length;
			var maxMorphX, maxMorphY, maxMorphZ;
			for (var i = 0; i < numBones; i++) {
				boneMin[i] = new Vec3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
				boneMax[i] = new Vec3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
			}
			var iterator = new VertexIterator(this.vertexBuffer);
			var posElement = iterator.element[SEMANTIC_POSITION];
			var weightsElement = iterator.element[SEMANTIC_BLENDWEIGHT];
			var indicesElement = iterator.element[SEMANTIC_BLENDINDICES];
			var numVerts = this.vertexBuffer.numVertices;
			for (var j = 0; j < numVerts; j++) {
				for (var k = 0; k < 4; k++) {
					var boneWeight = weightsElement.array[weightsElement.index + k];
					if (boneWeight > 0) {
						var boneIndex = indicesElement.array[indicesElement.index + k];
						boneUsed[boneIndex] = true;
						x = posElement.array[posElement.index];
						y = posElement.array[posElement.index + 1];
						z = posElement.array[posElement.index + 2];
						bMax = boneMax[boneIndex];
						bMin = boneMin[boneIndex];
						if (bMin.x > x) bMin.x = x;
						if (bMin.y > y) bMin.y = y;
						if (bMin.z > z) bMin.z = z;
						if (bMax.x < x) bMax.x = x;
						if (bMax.y < y) bMax.y = y;
						if (bMax.z < z) bMax.z = z;
						if (morphTargets) {
							var minMorphX = maxMorphX = x;
							var minMorphY = maxMorphY = y;
							var minMorphZ = maxMorphZ = z;
							for (var l = 0; l < morphTargets.length; l++) {
								var target = morphTargets[l];
								var dx = target.deltaPositions[j * 3];
								var dy = target.deltaPositions[j * 3 + 1];
								var dz = target.deltaPositions[j * 3 + 2];
								if (dx < 0) {
									minMorphX += dx;
								} else {
									maxMorphX += dx;
								}
								if (dy < 0) {
									minMorphY += dy;
								} else {
									maxMorphY += dy;
								}
								if (dz < 0) {
									minMorphZ += dz;
								} else {
									maxMorphZ += dz;
								}
							}
							if (bMin.x > minMorphX) bMin.x = minMorphX;
							if (bMin.y > minMorphY) bMin.y = minMorphY;
							if (bMin.z > minMorphZ) bMin.z = minMorphZ;
							if (bMax.x < maxMorphX) bMax.x = maxMorphX;
							if (bMax.y < maxMorphY) bMax.y = maxMorphY;
							if (bMax.z < maxMorphZ) bMax.z = maxMorphZ;
						}
					}
				}
				iterator.next();
			}
			var positionElement = this.vertexBuffer.getFormat().elements.find(function (e) {
				return e.name === SEMANTIC_POSITION;
			});
			if (positionElement && positionElement.normalize) {
				var func = function () {
					switch (positionElement.dataType) {
						case TYPE_INT8:
							return function (x) {
								return Math.max(x / 127.0, -1.0);
							};
						case TYPE_UINT8:
							return function (x) {
								return x / 255.0;
							};
						case TYPE_INT16:
							return function (x) {
								return Math.max(x / 32767.0, -1.0);
							};
						case TYPE_UINT16:
							return function (x) {
								return x / 65535.0;
							};
						default:
							return function (x) {
								return x;
							};
					}
				}();
				for (var _i = 0; _i < numBones; _i++) {
					if (boneUsed[_i]) {
						var min = boneMin[_i];
						var max = boneMax[_i];
						min.set(func(min.x), func(min.y), func(min.z));
						max.set(func(max.x), func(max.y), func(max.z));
					}
				}
			}
			for (var _i2 = 0; _i2 < numBones; _i2++) {
				var aabb = new BoundingBox();
				aabb.setMinMax(boneMin[_i2], boneMax[_i2]);
				this.boneAabb.push(aabb);
			}
		};
		_proto2._initGeometryData = function _initGeometryData() {
			if (!this._geometryData) {
				this._geometryData = new GeometryData();
				if (this.vertexBuffer) {
					this._geometryData.vertexCount = this.vertexBuffer.numVertices;
					this._geometryData.maxVertices = this.vertexBuffer.numVertices;
				}
				if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
					this._geometryData.indexCount = this.indexBuffer[0].numIndices;
					this._geometryData.maxIndices = this.indexBuffer[0].numIndices;
				}
			}
		};
		_proto2.clear = function clear(verticesDynamic, indicesDynamic, maxVertices, maxIndices) {
			if (maxVertices === void 0) {
				maxVertices = 0;
			}
			if (maxIndices === void 0) {
				maxIndices = 0;
			}
			this._initGeometryData();
			this._geometryData.initDefaults();
			this._geometryData.recreate = true;
			this._geometryData.maxVertices = maxVertices;
			this._geometryData.maxIndices = maxIndices;
			this._geometryData.verticesUsage = verticesDynamic ? BUFFER_STATIC : BUFFER_DYNAMIC;
			this._geometryData.indicesUsage = indicesDynamic ? BUFFER_STATIC : BUFFER_DYNAMIC;
		};
		_proto2.setVertexStream = function setVertexStream(semantic, data, componentCount, numVertices, dataType, dataTypeNormalize) {
			if (dataType === void 0) {
				dataType = TYPE_FLOAT32;
			}
			if (dataTypeNormalize === void 0) {
				dataTypeNormalize = false;
			}
			this._initGeometryData();
			var vertexCount = numVertices || data.length / componentCount;
			this._geometryData._changeVertexCount(vertexCount, semantic);
			this._geometryData.vertexStreamsUpdated = true;
			this._geometryData.vertexStreamDictionary[semantic] = new GeometryVertexStream(data, componentCount, dataType, dataTypeNormalize);
		};
		_proto2.getVertexStream = function getVertexStream(semantic, data) {
			var count = 0;
			var done = false;
			if (this._geometryData) {
				var stream = this._geometryData.vertexStreamDictionary[semantic];
				if (stream) {
					done = true;
					count = this._geometryData.vertexCount;
					if (ArrayBuffer.isView(data)) {
						data.set(stream.data);
					} else {
						data.length = 0;
						data.push(stream.data);
					}
				}
			}
			if (!done) {
				if (this.vertexBuffer) {
					var iterator = new VertexIterator(this.vertexBuffer);
					count = iterator.readData(semantic, data);
				}
			}
			return count;
		};
		_proto2.setPositions = function setPositions(positions, componentCount, numVertices) {
			if (componentCount === void 0) {
				componentCount = GeometryData.DEFAULT_COMPONENTS_POSITION;
			}
			this.setVertexStream(SEMANTIC_POSITION, positions, componentCount, numVertices, TYPE_FLOAT32, false);
		};
		_proto2.setNormals = function setNormals(normals, componentCount, numVertices) {
			if (componentCount === void 0) {
				componentCount = GeometryData.DEFAULT_COMPONENTS_NORMAL;
			}
			this.setVertexStream(SEMANTIC_NORMAL, normals, componentCount, numVertices, TYPE_FLOAT32, false);
		};
		_proto2.setUvs = function setUvs(channel, uvs, componentCount, numVertices) {
			if (componentCount === void 0) {
				componentCount = GeometryData.DEFAULT_COMPONENTS_UV;
			}
			this.setVertexStream(SEMANTIC_TEXCOORD + channel, uvs, componentCount, numVertices, TYPE_FLOAT32, false);
		};
		_proto2.setColors = function setColors(colors, componentCount, numVertices) {
			if (componentCount === void 0) {
				componentCount = GeometryData.DEFAULT_COMPONENTS_COLORS;
			}
			this.setVertexStream(SEMANTIC_COLOR, colors, componentCount, numVertices, TYPE_FLOAT32, false);
		};
		_proto2.setColors32 = function setColors32(colors, numVertices) {
			this.setVertexStream(SEMANTIC_COLOR, colors, GeometryData.DEFAULT_COMPONENTS_COLORS, numVertices, TYPE_UINT8, true);
		};
		_proto2.setIndices = function setIndices(indices, numIndices) {
			this._initGeometryData();
			this._geometryData.indexStreamUpdated = true;
			this._geometryData.indices = indices;
			this._geometryData.indexCount = numIndices || indices.length;
		};
		_proto2.getPositions = function getPositions(positions) {
			return this.getVertexStream(SEMANTIC_POSITION, positions);
		};
		_proto2.getNormals = function getNormals(normals) {
			return this.getVertexStream(SEMANTIC_NORMAL, normals);
		};
		_proto2.getUvs = function getUvs(channel, uvs) {
			return this.getVertexStream(SEMANTIC_TEXCOORD + channel, uvs);
		};
		_proto2.getColors = function getColors(colors) {
			return this.getVertexStream(SEMANTIC_COLOR, colors);
		};
		_proto2.getIndices = function getIndices(indices) {
			var count = 0;
			if (this._geometryData && this._geometryData.indices) {
				var streamIndices = this._geometryData.indices;
				count = this._geometryData.indexCount;
				if (ArrayBuffer.isView(indices)) {
					indices.set(streamIndices);
				} else {
					indices.length = 0;
					for (var i = 0, il = streamIndices.length; i < il; i++) {
						indices.push(streamIndices[i]);
					}
				}
			} else {
				if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
					var indexBuffer = this.indexBuffer[0];
					count = indexBuffer.readData(indices);
				}
			}
			return count;
		};
		_proto2.update = function update(primitiveType, updateBoundingBox) {
			if (primitiveType === void 0) {
				primitiveType = PRIMITIVE_TRIANGLES;
			}
			if (updateBoundingBox === void 0) {
				updateBoundingBox = true;
			}
			if (this._geometryData) {
				if (updateBoundingBox) {
					var stream = this._geometryData.vertexStreamDictionary[SEMANTIC_POSITION];
					if (stream) {
						if (stream.componentCount === 3) {
							this._aabb.compute(stream.data, this._geometryData.vertexCount);
							this._aabbVer++;
						}
					}
				}
				var destroyVB = this._geometryData.recreate;
				if (this._geometryData.vertexCount > this._geometryData.maxVertices) {
					destroyVB = true;
					this._geometryData.maxVertices = this._geometryData.vertexCount;
				}
				if (destroyVB) {
					if (this.vertexBuffer) {
						this.vertexBuffer.destroy();
						this.vertexBuffer = null;
					}
				}
				var destroyIB = this._geometryData.recreate;
				if (this._geometryData.indexCount > this._geometryData.maxIndices) {
					destroyIB = true;
					this._geometryData.maxIndices = this._geometryData.indexCount;
				}
				if (destroyIB) {
					if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
						this.indexBuffer[0].destroy();
						this.indexBuffer[0] = null;
					}
				}
				if (this._geometryData.vertexStreamsUpdated) {
					this._updateVertexBuffer();
				}
				if (this._geometryData.indexStreamUpdated) {
					this._updateIndexBuffer();
				}
				this.primitive[0].type = primitiveType;
				if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
					if (this._geometryData.indexStreamUpdated) {
						this.primitive[0].count = this._geometryData.indexCount;
						this.primitive[0].indexed = true;
					}
				} else {
					if (this._geometryData.vertexStreamsUpdated) {
						this.primitive[0].count = this._geometryData.vertexCount;
						this.primitive[0].indexed = false;
					}
				}
				this._geometryData.vertexCount = 0;
				this._geometryData.indexCount = 0;
				this._geometryData.vertexStreamsUpdated = false;
				this._geometryData.indexStreamUpdated = false;
				this._geometryData.recreate = false;
				this.updateRenderStates();
			}
		};
		_proto2._buildVertexFormat = function _buildVertexFormat(vertexCount) {
			var vertexDesc = [];
			for (var semantic in this._geometryData.vertexStreamDictionary) {
				var stream = this._geometryData.vertexStreamDictionary[semantic];
				vertexDesc.push({
					semantic: semantic,
					components: stream.componentCount,
					type: stream.dataType,
					normalize: stream.dataTypeNormalize
				});
			}
			return new VertexFormat(this.device, vertexDesc, vertexCount);
		};
		_proto2._updateVertexBuffer = function _updateVertexBuffer() {
			if (!this.vertexBuffer) {
				var allocateVertexCount = this._geometryData.maxVertices;
				var format = this._buildVertexFormat(allocateVertexCount);
				this.vertexBuffer = new VertexBuffer(this.device, format, allocateVertexCount, this._geometryData.verticesUsage);
			}
			var iterator = new VertexIterator(this.vertexBuffer);
			var numVertices = this._geometryData.vertexCount;
			for (var semantic in this._geometryData.vertexStreamDictionary) {
				var stream = this._geometryData.vertexStreamDictionary[semantic];
				iterator.writeData(semantic, stream.data, numVertices);
				delete this._geometryData.vertexStreamDictionary[semantic];
			}
			iterator.end();
		};
		_proto2._updateIndexBuffer = function _updateIndexBuffer() {
			if (this.indexBuffer.length <= 0 || !this.indexBuffer[0]) {
				var createFormat = this._geometryData.maxVertices > 0xffff ? INDEXFORMAT_UINT32 : INDEXFORMAT_UINT16;
				this.indexBuffer[0] = new IndexBuffer(this.device, createFormat, this._geometryData.maxIndices, this._geometryData.indicesUsage);
			}
			var srcIndices = this._geometryData.indices;
			if (srcIndices) {
				var indexBuffer = this.indexBuffer[0];
				indexBuffer.writeData(srcIndices, this._geometryData.indexCount);
				this._geometryData.indices = null;
			}
		};
		_proto2.prepareRenderState = function prepareRenderState(renderStyle) {
			if (renderStyle === RENDERSTYLE_WIREFRAME) {
				this.generateWireframe();
			} else if (renderStyle === RENDERSTYLE_POINTS) {
				this.primitive[RENDERSTYLE_POINTS] = {
					type: PRIMITIVE_POINTS,
					base: 0,
					count: this.vertexBuffer ? this.vertexBuffer.numVertices : 0,
					indexed: false
				};
			}
		};
		_proto2.updateRenderStates = function updateRenderStates() {
			if (this.primitive[RENDERSTYLE_POINTS]) {
				this.prepareRenderState(RENDERSTYLE_POINTS);
			}
			if (this.primitive[RENDERSTYLE_WIREFRAME]) {
				this.prepareRenderState(RENDERSTYLE_WIREFRAME);
			}
		};
		_proto2.generateWireframe = function generateWireframe() {
			this._destroyIndexBuffer(RENDERSTYLE_WIREFRAME);
			var numVertices = this.vertexBuffer.numVertices;
			var lines = [];
			var format;
			if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
				var offsets = [[0, 1], [1, 2], [2, 0]];
				var base = this.primitive[RENDERSTYLE_SOLID].base;
				var count = this.primitive[RENDERSTYLE_SOLID].count;
				var indexBuffer = this.indexBuffer[RENDERSTYLE_SOLID];
				var srcIndices = new typedArrayIndexFormats[indexBuffer.format](indexBuffer.storage);
				var seen = new Set();
				for (var j = base; j < base + count; j += 3) {
					for (var k = 0; k < 3; k++) {
						var i1 = srcIndices[j + offsets[k][0]];
						var i2 = srcIndices[j + offsets[k][1]];
						var hash = i1 > i2 ? i2 * numVertices + i1 : i1 * numVertices + i2;
						if (!seen.has(hash)) {
							seen.add(hash);
							lines.push(i1, i2);
						}
					}
				}
				format = indexBuffer.format;
			} else {
				for (var i = 0; i < numVertices; i += 3) {
					lines.push(i, i + 1, i + 1, i + 2, i + 2, i);
				}
				format = lines.length > 65535 ? INDEXFORMAT_UINT32 : INDEXFORMAT_UINT16;
			}
			var wireBuffer = new IndexBuffer(this.vertexBuffer.device, format, lines.length);
			var dstIndices = new typedArrayIndexFormats[wireBuffer.format](wireBuffer.storage);
			dstIndices.set(lines);
			wireBuffer.unlock();
			this.primitive[RENDERSTYLE_WIREFRAME] = {
				type: PRIMITIVE_LINES,
				base: 0,
				count: lines.length,
				indexed: true
			};
			this.indexBuffer[RENDERSTYLE_WIREFRAME] = wireBuffer;
		};
		_createClass(Mesh, [{
			key: "morph",
			get: function get() {
				return this._morph;
			},
			set: function set(morph) {
				if (morph !== this._morph) {
					if (this._morph) {
						this._morph.decRefCount();
					}
					this._morph = morph;
					if (morph) {
						morph.incRefCount();
					}
				}
			}
		}, {
			key: "aabb",
			get: function get() {
				return this._aabb;
			},
			set: function set(aabb) {
				this._aabb = aabb;
				this._aabbVer++;
			}
		}]);
		return Mesh;
	}(RefCountedObject);

	var primitiveUv1Padding = 4.0 / 64;
	var primitiveUv1PaddingScale = 1.0 - primitiveUv1Padding * 2;
	var shapePrimitives = [];
	function calculateNormals(positions, indices) {
		var triangleCount = indices.length / 3;
		var vertexCount = positions.length / 3;
		var p1 = new Vec3();
		var p2 = new Vec3();
		var p3 = new Vec3();
		var p1p2 = new Vec3();
		var p1p3 = new Vec3();
		var faceNormal = new Vec3();
		var normals = [];
		for (var i = 0; i < positions.length; i++) {
			normals[i] = 0;
		}
		for (var _i = 0; _i < triangleCount; _i++) {
			var i1 = indices[_i * 3];
			var i2 = indices[_i * 3 + 1];
			var i3 = indices[_i * 3 + 2];
			p1.set(positions[i1 * 3], positions[i1 * 3 + 1], positions[i1 * 3 + 2]);
			p2.set(positions[i2 * 3], positions[i2 * 3 + 1], positions[i2 * 3 + 2]);
			p3.set(positions[i3 * 3], positions[i3 * 3 + 1], positions[i3 * 3 + 2]);
			p1p2.sub2(p2, p1);
			p1p3.sub2(p3, p1);
			faceNormal.cross(p1p2, p1p3).normalize();
			normals[i1 * 3] += faceNormal.x;
			normals[i1 * 3 + 1] += faceNormal.y;
			normals[i1 * 3 + 2] += faceNormal.z;
			normals[i2 * 3] += faceNormal.x;
			normals[i2 * 3 + 1] += faceNormal.y;
			normals[i2 * 3 + 2] += faceNormal.z;
			normals[i3 * 3] += faceNormal.x;
			normals[i3 * 3 + 1] += faceNormal.y;
			normals[i3 * 3 + 2] += faceNormal.z;
		}
		for (var _i2 = 0; _i2 < vertexCount; _i2++) {
			var nx = normals[_i2 * 3];
			var ny = normals[_i2 * 3 + 1];
			var nz = normals[_i2 * 3 + 2];
			var invLen = 1 / Math.sqrt(nx * nx + ny * ny + nz * nz);
			normals[_i2 * 3] *= invLen;
			normals[_i2 * 3 + 1] *= invLen;
			normals[_i2 * 3 + 2] *= invLen;
		}
		return normals;
	}
	function calculateTangents(positions, normals, uvs, indices) {
		var triangleCount = indices.length / 3;
		var vertexCount = positions.length / 3;
		var v1 = new Vec3();
		var v2 = new Vec3();
		var v3 = new Vec3();
		var w1 = new Vec2();
		var w2 = new Vec2();
		var w3 = new Vec2();
		var sdir = new Vec3();
		var tdir = new Vec3();
		var tan1 = new Float32Array(vertexCount * 3);
		var tan2 = new Float32Array(vertexCount * 3);
		var tangents = [];
		for (var i = 0; i < triangleCount; i++) {
			var i1 = indices[i * 3];
			var i2 = indices[i * 3 + 1];
			var i3 = indices[i * 3 + 2];
			v1.set(positions[i1 * 3], positions[i1 * 3 + 1], positions[i1 * 3 + 2]);
			v2.set(positions[i2 * 3], positions[i2 * 3 + 1], positions[i2 * 3 + 2]);
			v3.set(positions[i3 * 3], positions[i3 * 3 + 1], positions[i3 * 3 + 2]);
			w1.set(uvs[i1 * 2], uvs[i1 * 2 + 1]);
			w2.set(uvs[i2 * 2], uvs[i2 * 2 + 1]);
			w3.set(uvs[i3 * 2], uvs[i3 * 2 + 1]);
			var x1 = v2.x - v1.x;
			var x2 = v3.x - v1.x;
			var y1 = v2.y - v1.y;
			var y2 = v3.y - v1.y;
			var z1 = v2.z - v1.z;
			var z2 = v3.z - v1.z;
			var s1 = w2.x - w1.x;
			var s2 = w3.x - w1.x;
			var _t = w2.y - w1.y;
			var _t2 = w3.y - w1.y;
			var area = s1 * _t2 - s2 * _t;
			if (area === 0) {
				sdir.set(0, 1, 0);
				tdir.set(1, 0, 0);
			} else {
				var r = 1 / area;
				sdir.set((_t2 * x1 - _t * x2) * r, (_t2 * y1 - _t * y2) * r, (_t2 * z1 - _t * z2) * r);
				tdir.set((s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r, (s1 * z2 - s2 * z1) * r);
			}
			tan1[i1 * 3 + 0] += sdir.x;
			tan1[i1 * 3 + 1] += sdir.y;
			tan1[i1 * 3 + 2] += sdir.z;
			tan1[i2 * 3 + 0] += sdir.x;
			tan1[i2 * 3 + 1] += sdir.y;
			tan1[i2 * 3 + 2] += sdir.z;
			tan1[i3 * 3 + 0] += sdir.x;
			tan1[i3 * 3 + 1] += sdir.y;
			tan1[i3 * 3 + 2] += sdir.z;
			tan2[i1 * 3 + 0] += tdir.x;
			tan2[i1 * 3 + 1] += tdir.y;
			tan2[i1 * 3 + 2] += tdir.z;
			tan2[i2 * 3 + 0] += tdir.x;
			tan2[i2 * 3 + 1] += tdir.y;
			tan2[i2 * 3 + 2] += tdir.z;
			tan2[i3 * 3 + 0] += tdir.x;
			tan2[i3 * 3 + 1] += tdir.y;
			tan2[i3 * 3 + 2] += tdir.z;
		}
		var t1 = new Vec3();
		var t2 = new Vec3();
		var n = new Vec3();
		var temp = new Vec3();
		for (var _i3 = 0; _i3 < vertexCount; _i3++) {
			n.set(normals[_i3 * 3], normals[_i3 * 3 + 1], normals[_i3 * 3 + 2]);
			t1.set(tan1[_i3 * 3], tan1[_i3 * 3 + 1], tan1[_i3 * 3 + 2]);
			t2.set(tan2[_i3 * 3], tan2[_i3 * 3 + 1], tan2[_i3 * 3 + 2]);
			var ndott = n.dot(t1);
			temp.copy(n).mulScalar(ndott);
			temp.sub2(t1, temp).normalize();
			tangents[_i3 * 4] = temp.x;
			tangents[_i3 * 4 + 1] = temp.y;
			tangents[_i3 * 4 + 2] = temp.z;
			temp.cross(n, t1);
			tangents[_i3 * 4 + 3] = temp.dot(t2) < 0.0 ? -1.0 : 1.0;
		}
		return tangents;
	}
	function createMesh$1(device, positions, opts) {
		var mesh = new Mesh(device);
		mesh.setPositions(positions);
		if (opts) {
			if (opts.normals) {
				mesh.setNormals(opts.normals);
			}
			if (opts.tangents) {
				mesh.setVertexStream(SEMANTIC_TANGENT, opts.tangents, 4);
			}
			if (opts.colors) {
				mesh.setColors32(opts.colors);
			}
			if (opts.uvs) {
				mesh.setUvs(0, opts.uvs);
			}
			if (opts.uvs1) {
				mesh.setUvs(1, opts.uvs1);
			}
			if (opts.blendIndices) {
				mesh.setVertexStream(SEMANTIC_BLENDINDICES, opts.blendIndices, 4, opts.blendIndices.length / 4, TYPE_UINT8);
			}
			if (opts.blendWeights) {
				mesh.setVertexStream(SEMANTIC_BLENDWEIGHT, opts.blendWeights, 4);
			}
			if (opts.indices) {
				mesh.setIndices(opts.indices);
			}
		}
		mesh.update();
		return mesh;
	}
	function createTorus(device, opts) {
		var _opts$tubeRadius, _opts$ringRadius, _opts$segments, _opts$sides, _opts$calculateTangen;
		if (opts === void 0) {
			opts = {};
		}
		var rc = (_opts$tubeRadius = opts.tubeRadius) != null ? _opts$tubeRadius : 0.2;
		var rt = (_opts$ringRadius = opts.ringRadius) != null ? _opts$ringRadius : 0.3;
		var segments = (_opts$segments = opts.segments) != null ? _opts$segments : 30;
		var sides = (_opts$sides = opts.sides) != null ? _opts$sides : 20;
		var calcTangents = (_opts$calculateTangen = opts.calculateTangents) != null ? _opts$calculateTangen : false;
		var positions = [];
		var normals = [];
		var uvs = [];
		var indices = [];
		for (var i = 0; i <= sides; i++) {
			for (var j = 0; j <= segments; j++) {
				var x = Math.cos(2 * Math.PI * j / segments) * (rt + rc * Math.cos(2 * Math.PI * i / sides));
				var y = Math.sin(2 * Math.PI * i / sides) * rc;
				var z = Math.sin(2 * Math.PI * j / segments) * (rt + rc * Math.cos(2 * Math.PI * i / sides));
				var nx = Math.cos(2 * Math.PI * j / segments) * Math.cos(2 * Math.PI * i / sides);
				var ny = Math.sin(2 * Math.PI * i / sides);
				var nz = Math.sin(2 * Math.PI * j / segments) * Math.cos(2 * Math.PI * i / sides);
				var u = i / sides;
				var v = 1 - j / segments;
				positions.push(x, y, z);
				normals.push(nx, ny, nz);
				uvs.push(u, 1.0 - v);
				if (i < sides && j < segments) {
					var first = i * (segments + 1) + j;
					var second = (i + 1) * (segments + 1) + j;
					var third = i * (segments + 1) + (j + 1);
					var fourth = (i + 1) * (segments + 1) + (j + 1);
					indices.push(first, second, third);
					indices.push(second, fourth, third);
				}
			}
		}
		var options = {
			normals: normals,
			uvs: uvs,
			uvs1: uvs,
			indices: indices
		};
		if (calcTangents) {
			options.tangents = calculateTangents(positions, normals, uvs, indices);
		}
		return createMesh$1(device, positions, options);
	}
	function _createConeData(baseRadius, peakRadius, height, heightSegments, capSegments, roundedCaps) {
		var pos = new Vec3();
		var bottomToTop = new Vec3();
		var norm = new Vec3();
		var top = new Vec3();
		var bottom = new Vec3();
		var tangent = new Vec3();
		var positions = [];
		var normals = [];
		var uvs = [];
		var uvs1 = [];
		var indices = [];
		var offset;
		if (height > 0) {
			for (var i = 0; i <= heightSegments; i++) {
				for (var j = 0; j <= capSegments; j++) {
					var theta = j / capSegments * 2 * Math.PI - Math.PI;
					var sinTheta = Math.sin(theta);
					var cosTheta = Math.cos(theta);
					bottom.set(sinTheta * baseRadius, -height / 2, cosTheta * baseRadius);
					top.set(sinTheta * peakRadius, height / 2, cosTheta * peakRadius);
					pos.lerp(bottom, top, i / heightSegments);
					bottomToTop.sub2(top, bottom).normalize();
					tangent.set(cosTheta, 0, -sinTheta);
					norm.cross(tangent, bottomToTop).normalize();
					positions.push(pos.x, pos.y, pos.z);
					normals.push(norm.x, norm.y, norm.z);
					var u = j / capSegments;
					var v = i / heightSegments;
					uvs.push(u, 1 - v);
					var _v = v;
					v = u;
					u = _v;
					u = u * primitiveUv1PaddingScale + primitiveUv1Padding;
					v = v * primitiveUv1PaddingScale + primitiveUv1Padding;
					u /= 3;
					uvs1.push(u, 1 - v);
					if (i < heightSegments && j < capSegments) {
						var first = i * (capSegments + 1) + j;
						var second = i * (capSegments + 1) + (j + 1);
						var third = (i + 1) * (capSegments + 1) + j;
						var fourth = (i + 1) * (capSegments + 1) + (j + 1);
						indices.push(first, second, third);
						indices.push(second, fourth, third);
					}
				}
			}
		}
		if (roundedCaps) {
			var latitudeBands = Math.floor(capSegments / 2);
			var longitudeBands = capSegments;
			var capOffset = height / 2;
			for (var lat = 0; lat <= latitudeBands; lat++) {
				var _theta = lat * Math.PI * 0.5 / latitudeBands;
				var _sinTheta = Math.sin(_theta);
				var _cosTheta = Math.cos(_theta);
				for (var lon = 0; lon <= longitudeBands; lon++) {
					var phi = lon * 2 * Math.PI / longitudeBands - Math.PI / 2;
					var sinPhi = Math.sin(phi);
					var cosPhi = Math.cos(phi);
					var x = cosPhi * _sinTheta;
					var y = _cosTheta;
					var z = sinPhi * _sinTheta;
					var _u = 1 - lon / longitudeBands;
					var _v2 = 1 - lat / latitudeBands;
					positions.push(x * peakRadius, y * peakRadius + capOffset, z * peakRadius);
					normals.push(x, y, z);
					uvs.push(_u, 1 - _v2);
					_u = _u * primitiveUv1PaddingScale + primitiveUv1Padding;
					_v2 = _v2 * primitiveUv1PaddingScale + primitiveUv1Padding;
					_u /= 3;
					_v2 /= 3;
					_u += 1.0 / 3;
					uvs1.push(_u, 1 - _v2);
				}
			}
			offset = (heightSegments + 1) * (capSegments + 1);
			for (var _lat = 0; _lat < latitudeBands; ++_lat) {
				for (var _lon = 0; _lon < longitudeBands; ++_lon) {
					var _first = _lat * (longitudeBands + 1) + _lon;
					var _second = _first + longitudeBands + 1;
					indices.push(offset + _first + 1, offset + _second, offset + _first);
					indices.push(offset + _first + 1, offset + _second + 1, offset + _second);
				}
			}
			for (var _lat2 = 0; _lat2 <= latitudeBands; _lat2++) {
				var _theta2 = Math.PI * 0.5 + _lat2 * Math.PI * 0.5 / latitudeBands;
				var _sinTheta2 = Math.sin(_theta2);
				var _cosTheta2 = Math.cos(_theta2);
				for (var _lon2 = 0; _lon2 <= longitudeBands; _lon2++) {
					var _phi = _lon2 * 2 * Math.PI / longitudeBands - Math.PI / 2;
					var _sinPhi = Math.sin(_phi);
					var _cosPhi = Math.cos(_phi);
					var _x = _cosPhi * _sinTheta2;
					var _y = _cosTheta2;
					var _z = _sinPhi * _sinTheta2;
					var _u2 = 1 - _lon2 / longitudeBands;
					var _v3 = 1 - _lat2 / latitudeBands;
					positions.push(_x * peakRadius, _y * peakRadius - capOffset, _z * peakRadius);
					normals.push(_x, _y, _z);
					uvs.push(_u2, 1 - _v3);
					_u2 = _u2 * primitiveUv1PaddingScale + primitiveUv1Padding;
					_v3 = _v3 * primitiveUv1PaddingScale + primitiveUv1Padding;
					_u2 /= 3;
					_v3 /= 3;
					_u2 += 2.0 / 3;
					uvs1.push(_u2, 1 - _v3);
				}
			}
			offset = (heightSegments + 1) * (capSegments + 1) + (longitudeBands + 1) * (latitudeBands + 1);
			for (var _lat3 = 0; _lat3 < latitudeBands; ++_lat3) {
				for (var _lon3 = 0; _lon3 < longitudeBands; ++_lon3) {
					var _first2 = _lat3 * (longitudeBands + 1) + _lon3;
					var _second2 = _first2 + longitudeBands + 1;
					indices.push(offset + _first2 + 1, offset + _second2, offset + _first2);
					indices.push(offset + _first2 + 1, offset + _second2 + 1, offset + _second2);
				}
			}
		} else {
			offset = (heightSegments + 1) * (capSegments + 1);
			if (baseRadius > 0) {
				for (var _i4 = 0; _i4 < capSegments; _i4++) {
					var _theta3 = _i4 / capSegments * 2 * Math.PI;
					var _x2 = Math.sin(_theta3);
					var _y2 = -height / 2;
					var _z2 = Math.cos(_theta3);
					var _u3 = 1 - (_x2 + 1) / 2;
					var _v4 = (_z2 + 1) / 2;
					positions.push(_x2 * baseRadius, _y2, _z2 * baseRadius);
					normals.push(0, -1, 0);
					uvs.push(_u3, 1 - _v4);
					_u3 = _u3 * primitiveUv1PaddingScale + primitiveUv1Padding;
					_v4 = _v4 * primitiveUv1PaddingScale + primitiveUv1Padding;
					_u3 /= 3;
					_v4 /= 3;
					_u3 += 1 / 3;
					uvs1.push(_u3, 1 - _v4);
					if (_i4 > 1) {
						indices.push(offset, offset + _i4, offset + _i4 - 1);
					}
				}
			}
			offset += capSegments;
			if (peakRadius > 0) {
				for (var _i5 = 0; _i5 < capSegments; _i5++) {
					var _theta4 = _i5 / capSegments * 2 * Math.PI;
					var _x3 = Math.sin(_theta4);
					var _y3 = height / 2;
					var _z3 = Math.cos(_theta4);
					var _u4 = 1 - (_x3 + 1) / 2;
					var _v5 = (_z3 + 1) / 2;
					positions.push(_x3 * peakRadius, _y3, _z3 * peakRadius);
					normals.push(0, 1, 0);
					uvs.push(_u4, 1 - _v5);
					_u4 = _u4 * primitiveUv1PaddingScale + primitiveUv1Padding;
					_v5 = _v5 * primitiveUv1PaddingScale + primitiveUv1Padding;
					_u4 /= 3;
					_v5 /= 3;
					_u4 += 2 / 3;
					uvs1.push(_u4, 1 - _v5);
					if (_i5 > 1) {
						indices.push(offset, offset + _i5 - 1, offset + _i5);
					}
				}
			}
		}
		return {
			positions: positions,
			normals: normals,
			uvs: uvs,
			uvs1: uvs1,
			indices: indices
		};
	}
	function createCylinder(device, opts) {
		var _opts$radius, _opts$height, _opts$heightSegments, _opts$capSegments, _opts$calculateTangen2;
		if (opts === void 0) {
			opts = {};
		}
		var radius = (_opts$radius = opts.radius) != null ? _opts$radius : 0.5;
		var height = (_opts$height = opts.height) != null ? _opts$height : 1;
		var heightSegments = (_opts$heightSegments = opts.heightSegments) != null ? _opts$heightSegments : 5;
		var capSegments = (_opts$capSegments = opts.capSegments) != null ? _opts$capSegments : 20;
		var calcTangents = (_opts$calculateTangen2 = opts.calculateTangents) != null ? _opts$calculateTangen2 : false;
		var options = _createConeData(radius, radius, height, heightSegments, capSegments, false);
		if (calcTangents) {
			options.tangents = calculateTangents(options.positions, options.normals, options.uvs, options.indices);
		}
		return createMesh$1(device, options.positions, options);
	}
	function createCapsule(device, opts) {
		var _opts$radius2, _opts$height2, _opts$heightSegments2, _opts$sides2, _opts$calculateTangen3;
		if (opts === void 0) {
			opts = {};
		}
		var radius = (_opts$radius2 = opts.radius) != null ? _opts$radius2 : 0.3;
		var height = (_opts$height2 = opts.height) != null ? _opts$height2 : 1;
		var heightSegments = (_opts$heightSegments2 = opts.heightSegments) != null ? _opts$heightSegments2 : 1;
		var sides = (_opts$sides2 = opts.sides) != null ? _opts$sides2 : 20;
		var calcTangents = (_opts$calculateTangen3 = opts.calculateTangents) != null ? _opts$calculateTangen3 : false;
		var options = _createConeData(radius, radius, height - 2 * radius, heightSegments, sides, true);
		if (calcTangents) {
			options.tangents = calculateTangents(options.positions, options.normals, options.uvs, options.indices);
		}
		return createMesh$1(device, options.positions, options);
	}
	function createCone(device, opts) {
		var _opts$baseRadius, _opts$peakRadius, _opts$height3, _opts$heightSegments3, _opts$capSegments2, _opts$calculateTangen4;
		if (opts === void 0) {
			opts = {};
		}
		var baseRadius = (_opts$baseRadius = opts.baseRadius) != null ? _opts$baseRadius : 0.5;
		var peakRadius = (_opts$peakRadius = opts.peakRadius) != null ? _opts$peakRadius : 0;
		var height = (_opts$height3 = opts.height) != null ? _opts$height3 : 1;
		var heightSegments = (_opts$heightSegments3 = opts.heightSegments) != null ? _opts$heightSegments3 : 5;
		var capSegments = (_opts$capSegments2 = opts.capSegments) != null ? _opts$capSegments2 : 18;
		var calcTangents = (_opts$calculateTangen4 = opts.calculateTangents) != null ? _opts$calculateTangen4 : false;
		var options = _createConeData(baseRadius, peakRadius, height, heightSegments, capSegments, false);
		if (calcTangents) {
			options.tangents = calculateTangents(options.positions, options.normals, options.uvs, options.indices);
		}
		return createMesh$1(device, options.positions, options);
	}
	function createSphere(device, opts) {
		var _opts$radius3, _opts$latitudeBands, _opts$longitudeBands, _opts$calculateTangen5;
		if (opts === void 0) {
			opts = {};
		}
		var radius = (_opts$radius3 = opts.radius) != null ? _opts$radius3 : 0.5;
		var latitudeBands = (_opts$latitudeBands = opts.latitudeBands) != null ? _opts$latitudeBands : 16;
		var longitudeBands = (_opts$longitudeBands = opts.longitudeBands) != null ? _opts$longitudeBands : 16;
		var calcTangents = (_opts$calculateTangen5 = opts.calculateTangents) != null ? _opts$calculateTangen5 : false;
		var positions = [];
		var normals = [];
		var uvs = [];
		var indices = [];
		for (var lat = 0; lat <= latitudeBands; lat++) {
			var theta = lat * Math.PI / latitudeBands;
			var sinTheta = Math.sin(theta);
			var cosTheta = Math.cos(theta);
			for (var lon = 0; lon <= longitudeBands; lon++) {
				var phi = lon * 2 * Math.PI / longitudeBands - Math.PI / 2;
				var sinPhi = Math.sin(phi);
				var cosPhi = Math.cos(phi);
				var x = cosPhi * sinTheta;
				var y = cosTheta;
				var z = sinPhi * sinTheta;
				var u = 1 - lon / longitudeBands;
				var v = 1 - lat / latitudeBands;
				positions.push(x * radius, y * radius, z * radius);
				normals.push(x, y, z);
				uvs.push(u, 1 - v);
			}
		}
		for (var _lat4 = 0; _lat4 < latitudeBands; ++_lat4) {
			for (var _lon4 = 0; _lon4 < longitudeBands; ++_lon4) {
				var first = _lat4 * (longitudeBands + 1) + _lon4;
				var second = first + longitudeBands + 1;
				indices.push(first + 1, second, first);
				indices.push(first + 1, second + 1, second);
			}
		}
		var options = {
			normals: normals,
			uvs: uvs,
			uvs1: uvs,
			indices: indices
		};
		if (calcTangents) {
			options.tangents = calculateTangents(positions, normals, uvs, indices);
		}
		return createMesh$1(device, positions, options);
	}
	function createPlane(device, opts) {
		var _opts$halfExtents, _opts$widthSegments, _opts$lengthSegments, _opts$calculateTangen6;
		if (opts === void 0) {
			opts = {};
		}
		var he = (_opts$halfExtents = opts.halfExtents) != null ? _opts$halfExtents : new Vec2(0.5, 0.5);
		var ws = (_opts$widthSegments = opts.widthSegments) != null ? _opts$widthSegments : 5;
		var ls = (_opts$lengthSegments = opts.lengthSegments) != null ? _opts$lengthSegments : 5;
		var calcTangents = (_opts$calculateTangen6 = opts.calculateTangents) != null ? _opts$calculateTangen6 : false;
		var positions = [];
		var normals = [];
		var uvs = [];
		var indices = [];
		var vcounter = 0;
		for (var i = 0; i <= ws; i++) {
			for (var j = 0; j <= ls; j++) {
				var x = -he.x + 2 * he.x * i / ws;
				var y = 0.0;
				var z = -(-he.y + 2 * he.y * j / ls);
				var u = i / ws;
				var v = j / ls;
				positions.push(x, y, z);
				normals.push(0, 1, 0);
				uvs.push(u, 1 - v);
				if (i < ws && j < ls) {
					indices.push(vcounter + ls + 1, vcounter + 1, vcounter);
					indices.push(vcounter + ls + 1, vcounter + ls + 2, vcounter + 1);
				}
				vcounter++;
			}
		}
		var options = {
			normals: normals,
			uvs: uvs,
			uvs1: uvs,
			indices: indices
		};
		if (calcTangents) {
			options.tangents = calculateTangents(positions, normals, uvs, indices);
		}
		return createMesh$1(device, positions, options);
	}
	function createBox(device, opts) {
		var _opts$halfExtents2, _opts$widthSegments2, _opts$lengthSegments2, _opts$heightSegments4, _opts$calculateTangen7;
		if (opts === void 0) {
			opts = {};
		}
		var he = (_opts$halfExtents2 = opts.halfExtents) != null ? _opts$halfExtents2 : new Vec3(0.5, 0.5, 0.5);
		var ws = (_opts$widthSegments2 = opts.widthSegments) != null ? _opts$widthSegments2 : 1;
		var ls = (_opts$lengthSegments2 = opts.lengthSegments) != null ? _opts$lengthSegments2 : 1;
		var hs = (_opts$heightSegments4 = opts.heightSegments) != null ? _opts$heightSegments4 : 1;
		var calcTangents = (_opts$calculateTangen7 = opts.calculateTangents) != null ? _opts$calculateTangen7 : false;
		var corners = [new Vec3(-he.x, -he.y, he.z), new Vec3(he.x, -he.y, he.z), new Vec3(he.x, he.y, he.z), new Vec3(-he.x, he.y, he.z), new Vec3(he.x, -he.y, -he.z), new Vec3(-he.x, -he.y, -he.z), new Vec3(-he.x, he.y, -he.z), new Vec3(he.x, he.y, -he.z)];
		var faceAxes = [[0, 1, 3], [4, 5, 7], [3, 2, 6], [1, 0, 4], [1, 4, 2], [5, 0, 6]];
		var faceNormals = [[0, 0, 1], [0, 0, -1], [0, 1, 0], [0, -1, 0], [1, 0, 0], [-1, 0, 0]];
		var sides = {
			FRONT: 0,
			BACK: 1,
			TOP: 2,
			BOTTOM: 3,
			RIGHT: 4,
			LEFT: 5
		};
		var positions = [];
		var normals = [];
		var uvs = [];
		var uvs1 = [];
		var indices = [];
		var vcounter = 0;
		var generateFace = function generateFace(side, uSegments, vSegments) {
			var temp1 = new Vec3();
			var temp2 = new Vec3();
			var temp3 = new Vec3();
			var r = new Vec3();
			for (var i = 0; i <= uSegments; i++) {
				for (var j = 0; j <= vSegments; j++) {
					temp1.lerp(corners[faceAxes[side][0]], corners[faceAxes[side][1]], i / uSegments);
					temp2.lerp(corners[faceAxes[side][0]], corners[faceAxes[side][2]], j / vSegments);
					temp3.sub2(temp2, corners[faceAxes[side][0]]);
					r.add2(temp1, temp3);
					var u = i / uSegments;
					var v = j / vSegments;
					positions.push(r.x, r.y, r.z);
					normals.push(faceNormals[side][0], faceNormals[side][1], faceNormals[side][2]);
					uvs.push(u, 1 - v);
					u = u * primitiveUv1PaddingScale + primitiveUv1Padding;
					v = v * primitiveUv1PaddingScale + primitiveUv1Padding;
					u /= 3;
					v /= 3;
					u += side % 3 / 3;
					v += Math.floor(side / 3) / 3;
					uvs1.push(u, 1 - v);
					if (i < uSegments && j < vSegments) {
						indices.push(vcounter + vSegments + 1, vcounter + 1, vcounter);
						indices.push(vcounter + vSegments + 1, vcounter + vSegments + 2, vcounter + 1);
					}
					vcounter++;
				}
			}
		};
		generateFace(sides.FRONT, ws, hs);
		generateFace(sides.BACK, ws, hs);
		generateFace(sides.TOP, ws, ls);
		generateFace(sides.BOTTOM, ws, ls);
		generateFace(sides.RIGHT, ls, hs);
		generateFace(sides.LEFT, ls, hs);
		var options = {
			normals: normals,
			uvs: uvs,
			uvs1: uvs1,
			indices: indices
		};
		if (calcTangents) {
			options.tangents = calculateTangents(positions, normals, uvs, indices);
		}
		return createMesh$1(device, positions, options);
	}
	function getShapePrimitive(device, type) {
		var primData = null;
		for (var i = 0; i < shapePrimitives.length; i++) {
			if (shapePrimitives[i].type === type && shapePrimitives[i].device === device) {
				primData = shapePrimitives[i].primData;
			}
		}
		if (!primData) {
			var mesh, area;
			switch (type) {
				case 'box':
					mesh = createBox(device);
					area = {
						x: 2,
						y: 2,
						z: 2,
						uv: 2.0 / 3
					};
					break;
				case 'capsule':
					mesh = createCapsule(device, {
						radius: 0.5,
						height: 2
					});
					area = {
						x: Math.PI * 2,
						y: Math.PI,
						z: Math.PI * 2,
						uv: 1.0 / 3 + 1.0 / 3 / 3 * 2
					};
					break;
				case 'cone':
					mesh = createCone(device, {
						baseRadius: 0.5,
						peakRadius: 0,
						height: 1
					});
					area = {
						x: 2.54,
						y: 2.54,
						z: 2.54,
						uv: 1.0 / 3 + 1.0 / 3 / 3
					};
					break;
				case 'cylinder':
					mesh = createCylinder(device, {
						radius: 0.5,
						height: 1
					});
					area = {
						x: Math.PI,
						y: 0.79 * 2,
						z: Math.PI,
						uv: 1.0 / 3 + 1.0 / 3 / 3 * 2
					};
					break;
				case 'plane':
					mesh = createPlane(device, {
						halfExtents: new Vec2(0.5, 0.5),
						widthSegments: 1,
						lengthSegments: 1
					});
					area = {
						x: 0,
						y: 1,
						z: 0,
						uv: 1
					};
					break;
				case 'sphere':
					mesh = createSphere(device, {
						radius: 0.5
					});
					area = {
						x: Math.PI,
						y: Math.PI,
						z: Math.PI,
						uv: 1
					};
					break;
				case 'torus':
					mesh = createTorus(device, {
						tubeRadius: 0.2,
						ringRadius: 0.3
					});
					area = {
						x: Math.PI * 0.5 * 0.5 - Math.PI * 0.1 * 0.1,
						y: 0.4,
						z: 0.4,
						uv: 1
					};
					break;
				default:
					throw new Error('Invalid primitive type: ' + type);
			}
			mesh.incRefCount();
			primData = {
				mesh: mesh,
				area: area
			};
			shapePrimitives.push({
				type: type,
				device: device,
				primData: primData
			});
		}
		return primData;
	}

	var ShaderProcessorOptions = function () {
		function ShaderProcessorOptions(viewUniformFormat, viewBindGroupFormat, vertexFormat) {
			this.uniformFormats = [];
			this.bindGroupFormats = [];
			this.vertexFormat = void 0;
			this.uniformFormats[BINDGROUP_VIEW] = viewUniformFormat;
			this.bindGroupFormats[BINDGROUP_VIEW] = viewBindGroupFormat;
			this.vertexFormat = vertexFormat;
		}
		var _proto = ShaderProcessorOptions.prototype;
		_proto.hasUniform = function hasUniform(name) {
			for (var i = 0; i < this.uniformFormats.length; i++) {
				var uniformFormat = this.uniformFormats[i];
				if (uniformFormat != null && uniformFormat.get(name)) {
					return true;
				}
			}
			return false;
		};
		_proto.hasTexture = function hasTexture(name) {
			for (var i = 0; i < this.bindGroupFormats.length; i++) {
				var groupFormat = this.bindGroupFormats[i];
				if (groupFormat != null && groupFormat.getTexture(name)) {
					return true;
				}
			}
			return false;
		};
		_proto.getVertexElement = function getVertexElement(semantic) {
			var _this$vertexFormat;
			return (_this$vertexFormat = this.vertexFormat) == null ? void 0 : _this$vertexFormat.elements.find(function (element) {
				return element.name === semantic;
			});
		};
		_proto.generateKey = function generateKey(device) {
			var key = JSON.stringify(this.uniformFormats) + JSON.stringify(this.bindGroupFormats);
			if (device.isWebGPU) {
				var _this$vertexFormat2;
				key += (_this$vertexFormat2 = this.vertexFormat) == null ? void 0 : _this$vertexFormat2.renderingHashString;
			}
			return key;
		};
		return ShaderProcessorOptions;
	}();

	var alphaTestPS = "\nuniform float alpha_ref;\nvoid alphaTest(float a) {\n\tif (a < alpha_ref) discard;\n}\n";

	var ambientConstantPS = "\nvoid addAmbient(vec3 worldNormal) {\n\tdDiffuseLight += light_globalAmbient;\n}\n";

	var ambientEnvPS = "\n#ifndef ENV_ATLAS\n#define ENV_ATLAS\nuniform sampler2D texture_envAtlas;\n#endif\nvoid addAmbient(vec3 worldNormal) {\n\tvec3 dir = normalize(cubeMapRotate(worldNormal) * vec3(-1.0, 1.0, 1.0));\n\tvec2 uv = mapUv(toSphericalUv(dir), vec4(128.0, 256.0 + 128.0, 64.0, 32.0) / atlasSize);\n\tvec4 raw = texture2D(texture_envAtlas, uv);\n\tvec3 linear = $DECODE(raw);\n\tdDiffuseLight += processEnvironment(linear);\n}\n";

	var ambientSHPS = "\nuniform vec3 ambientSH[9];\nvoid addAmbient(vec3 worldNormal) {\n\tvec3 n = cubeMapRotate(worldNormal);\n\tvec3 color =\n\t\tambientSH[0] +\n\t\tambientSH[1] * n.x +\n\t\tambientSH[2] * n.y +\n\t\tambientSH[3] * n.z +\n\t\tambientSH[4] * n.x * n.z +\n\t\tambientSH[5] * n.z * n.y +\n\t\tambientSH[6] * n.y * n.x +\n\t\tambientSH[7] * (3.0 * n.z * n.z - 1.0) +\n\t\tambientSH[8] * (n.x * n.x - n.y * n.y);\n\tdDiffuseLight += processEnvironment(max(color, vec3(0.0)));\n}\n";

	var aoPS = "\nvoid getAO() {\n\tdAo = 1.0;\n\t#ifdef MAPTEXTURE\n\tfloat aoBase = texture2DBias($SAMPLER, $UV, textureBias).$CH;\n\tdAo *= addAoDetail(aoBase);\n\t#endif\n\t#ifdef MAPVERTEX\n\tdAo *= saturate(vVertexColor.$VC);\n\t#endif\n}\n";

	var aoDetailMapPS = "\nfloat addAoDetail(float ao) {\n#ifdef MAPTEXTURE\n\tfloat aoDetail = texture2DBias($SAMPLER, $UV, textureBias).$CH;\n\treturn detailMode_$DETAILMODE(vec3(ao), vec3(aoDetail)).r;\n#else\n\treturn ao;\n#endif\n}\n";

	var aoDiffuseOccPS = "\nvoid occludeDiffuse(float ao) {\n\tdDiffuseLight *= ao;\n}\n";

	var aoSpecOccPS = "\nuniform float material_occludeSpecularIntensity;\nvoid occludeSpecular(float gloss, float ao, vec3 worldNormal, vec3 viewDir) {\n\tfloat specPow = exp2(gloss * 11.0);\n\tfloat specOcc = saturate(pow(dot(worldNormal, viewDir) + ao, 0.01*specPow) - 1.0 + ao);\n\tspecOcc = mix(1.0, specOcc, material_occludeSpecularIntensity);\n\tdSpecularLight *= specOcc;\n\tdReflection *= specOcc;\n\t\n#ifdef LIT_SHEEN\n\tsSpecularLight *= specOcc;\n\tsReflection *= specOcc;\n#endif\n}\n";

	var aoSpecOccConstPS = "\nvoid occludeSpecular(float gloss, float ao, vec3 worldNormal, vec3 viewDir) {\n\tfloat specPow = exp2(gloss * 11.0);\n\tfloat specOcc = saturate(pow(dot(worldNormal, viewDir) + ao, 0.01*specPow) - 1.0 + ao);\n\tdSpecularLight *= specOcc;\n\tdReflection *= specOcc;\n\t\n#ifdef LIT_SHEEN\n\tsSpecularLight *= specOcc;\n\tsReflection *= specOcc;\n#endif\n}\n";

	var aoSpecOccConstSimplePS = "\nvoid occludeSpecular(float gloss, float ao, vec3 worldNormal, vec3 viewDir) {\n\tdSpecularLight *= ao;\n\tdReflection *= ao;\n#ifdef LIT_SHEEN\n\tsSpecularLight *= ao;\n\tsReflection *= ao;\n#endif\n}\n";

	var aoSpecOccSimplePS = "\nuniform float material_occludeSpecularIntensity;\nvoid occludeSpecular(float gloss, float ao, vec3 worldNormal, vec3 viewDir) {\n\tfloat specOcc = mix(1.0, ao, material_occludeSpecularIntensity);\n\tdSpecularLight *= specOcc;\n\tdReflection *= specOcc;\n#ifdef LIT_SHEEN\n\tsSpecularLight *= specOcc;\n\tsReflection *= specOcc;\n#endif\n}\n";

	var basePS = "\nuniform vec3 view_position;\nuniform vec3 light_globalAmbient;\nfloat square(float x) {\n\treturn x*x;\n}\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\nvec3 saturate(vec3 x) {\n\treturn clamp(x, vec3(0.0), vec3(1.0));\n}\n";

	var baseVS = "\nattribute vec3 vertex_position;\nattribute vec3 vertex_normal;\nattribute vec4 vertex_tangent;\nattribute vec2 vertex_texCoord0;\nattribute vec2 vertex_texCoord1;\nattribute vec4 vertex_color;\nuniform mat4 matrix_viewProjection;\nuniform mat4 matrix_model;\nuniform mat3 matrix_normal;\nvec3 dPositionW;\nmat4 dModelMatrix;\nmat3 dNormalMatrix;\n";

	var baseNineSlicedPS = "\n#define NINESLICED\nvarying vec2 vMask;\nvarying vec2 vTiledUv;\nuniform mediump vec4 innerOffset;\nuniform mediump vec2 outerScale;\nuniform mediump vec4 atlasRect;\nvec2 nineSlicedUv;\n";

	var baseNineSlicedVS = "\n#define NINESLICED\nvarying vec2 vMask;\nvarying vec2 vTiledUv;\nuniform mediump vec4 innerOffset;\nuniform mediump vec2 outerScale;\nuniform mediump vec4 atlasRect;\n";

	var baseNineSlicedTiledPS = "\n#define NINESLICED\n#define NINESLICETILED\nvarying vec2 vMask;\nvarying vec2 vTiledUv;\nuniform mediump vec4 innerOffset;\nuniform mediump vec2 outerScale;\nuniform mediump vec4 atlasRect;\nvec2 nineSlicedUv;\n";

	var biasConstPS = "\n#define SHADOWBIAS\n#define SHADOW_SAMPLE_Z_BIAS\nfloat getShadowBias(float resolution, float maxBias) {\n\treturn maxBias;\n}\n";

	var blurVSMPS = "\nvarying vec2 vUv0;\nuniform sampler2D source;\nuniform vec2 pixelOffset;\n#ifdef GAUSS\nuniform float weight[SAMPLES];\n#endif\n#ifdef PACKED\nfloat decodeFloatRG(vec2 rg) {\n\treturn rg.y*(1.0/255.0) + rg.x;\n}\nvec2 encodeFloatRG( float v ) {\n\tvec2 enc = vec2(1.0, 255.0) * v;\n\tenc = fract(enc);\n\tenc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\n\treturn enc;\n}\n#endif\nvoid main(void) {\n\tvec3 moments = vec3(0.0);\n\tvec2 uv = vUv0 - pixelOffset * (float(SAMPLES) * 0.5);\n\tfor (int i=0; i<SAMPLES; i++) {\n\t\tvec4 c = texture2D(source, uv + pixelOffset * float(i));\n\t\t#ifdef PACKED\n\t\tc.xy = vec2(decodeFloatRG(c.xy), decodeFloatRG(c.zw));\n\t\t#endif\n\t\t#ifdef GAUSS\n\t\tmoments += c.xyz * weight[i];\n\t\t#else\n\t\tmoments += c.xyz;\n\t\t#endif\n\t}\n\t#ifndef GAUSS\n\tmoments /= float(SAMPLES);\n\t#endif\n\t#ifdef PACKED\n\tgl_FragColor = vec4(encodeFloatRG(moments.x), encodeFloatRG(moments.y));\n\t#else\n\tgl_FragColor = vec4(moments.x, moments.y, moments.z, 1.0);\n\t#endif\n}\n";

	var clearCoatPS = "\n#ifdef MAPFLOAT\nuniform float material_clearCoat;\n#endif\nvoid getClearCoat() {\n\tccSpecularity = 1.0;\n\t#ifdef MAPFLOAT\n\tccSpecularity *= material_clearCoat;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tccSpecularity *= texture2DBias($SAMPLER, $UV, textureBias).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tccSpecularity *= saturate(vVertexColor.$VC);\n\t#endif\n}\n";

	var clearCoatGlossPS = "\n#ifdef MAPFLOAT\nuniform float material_clearCoatGloss;\n#endif\nvoid getClearCoatGlossiness() {\n\tccGlossiness = 1.0;\n\t#ifdef MAPFLOAT\n\tccGlossiness *= material_clearCoatGloss;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tccGlossiness *= texture2DBias($SAMPLER, $UV, textureBias).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tccGlossiness *= saturate(vVertexColor.$VC);\n\t#endif\n\t#ifdef MAPINVERT\n\tccGlossiness = 1.0 - ccGlossiness;\n\t#endif\n\tccGlossiness += 0.0000001;\n}\n";

	var clearCoatNormalPS = "\n#ifdef MAPTEXTURE\nuniform float material_clearCoatBumpiness;\n#endif\nvoid getClearCoatNormal() {\n#ifdef MAPTEXTURE\n\tvec3 normalMap = unpackNormal(texture2DBias($SAMPLER, $UV, textureBias));\n\tnormalMap = mix(vec3(0.0, 0.0, 1.0), normalMap, material_clearCoatBumpiness);\n\tccNormalW = normalize(dTBN * normalMap);\n#else\n\tccNormalW = dVertexNormalW;\n#endif\n}\n";

	var clusteredLightUtilsPS = "\nvec2 getCubemapFaceCoordinates(const vec3 dir, out float faceIndex, out vec2 tileOffset)\n{\n\tvec3 vAbs = abs(dir);\n\tfloat ma;\n\tvec2 uv;\n\tif (vAbs.z >= vAbs.x && vAbs.z >= vAbs.y) {\n\t\tfaceIndex = dir.z < 0.0 ? 5.0 : 4.0;\n\t\tma = 0.5 / vAbs.z;\n\t\tuv = vec2(dir.z < 0.0 ? -dir.x : dir.x, -dir.y);\n\t\ttileOffset.x = 2.0;\n\t\ttileOffset.y = dir.z < 0.0 ? 1.0 : 0.0;\n\t} else if(vAbs.y >= vAbs.x) {\n\t\tfaceIndex = dir.y < 0.0 ? 3.0 : 2.0;\n\t\tma = 0.5 / vAbs.y;\n\t\tuv = vec2(dir.x, dir.y < 0.0 ? -dir.z : dir.z);\n\t\ttileOffset.x = 1.0;\n\t\ttileOffset.y = dir.y < 0.0 ? 1.0 : 0.0;\n\t} else {\n\t\tfaceIndex = dir.x < 0.0 ? 1.0 : 0.0;\n\t\tma = 0.5 / vAbs.x;\n\t\tuv = vec2(dir.x < 0.0 ? dir.z : -dir.z, -dir.y);\n\t\ttileOffset.x = 0.0;\n\t\ttileOffset.y = dir.x < 0.0 ? 1.0 : 0.0;\n\t}\n\treturn uv * ma + 0.5;\n}\nvec2 getCubemapAtlasCoordinates(const vec3 omniAtlasViewport, float shadowEdgePixels, float shadowTextureResolution, const vec3 dir) {\n\tfloat faceIndex;\n\tvec2 tileOffset;\n\tvec2 uv = getCubemapFaceCoordinates(dir, faceIndex, tileOffset);\n\tfloat atlasFaceSize = omniAtlasViewport.z;\n\tfloat tileSize = shadowTextureResolution * atlasFaceSize;\n\tfloat offset = shadowEdgePixels / tileSize;\n\tuv = uv * vec2(1.0 - offset * 2.0) + vec2(offset * 1.0);\n\tuv *= atlasFaceSize;\n\tuv += tileOffset * atlasFaceSize;\n\tuv += omniAtlasViewport.xy;\n\treturn uv;\n}\n";

	var clusteredLightCookiesPS = "\nvec3 _getCookieClustered(TEXTURE_ACCEPT(tex), vec2 uv, float intensity, bool isRgb, vec4 cookieChannel) {\n\tvec4 pixel = mix(vec4(1.0), texture2DLodEXT(tex, uv, 0.0), intensity);\n\treturn isRgb == true ? pixel.rgb : vec3(dot(pixel, cookieChannel));\n}\nvec3 getCookie2DClustered(TEXTURE_ACCEPT(tex), mat4 transform, vec3 worldPosition, float intensity, bool isRgb, vec4 cookieChannel) {\n\tvec4 projPos = transform * vec4(worldPosition, 1.0);\n\treturn _getCookieClustered(TEXTURE_PASS(tex), projPos.xy / projPos.w, intensity, isRgb, cookieChannel);\n}\nvec3 getCookieCubeClustered(TEXTURE_ACCEPT(tex), vec3 dir, float intensity, bool isRgb, vec4 cookieChannel, float shadowTextureResolution, float shadowEdgePixels, vec3 omniAtlasViewport) {\n\tvec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);\n\treturn _getCookieClustered(TEXTURE_PASS(tex), uv, intensity, isRgb, cookieChannel);\n}\n";

	var clusteredLightShadowsPS = "\nvoid _getShadowCoordPerspZbuffer(mat4 shadowMatrix, vec4 shadowParams, vec3 wPos) {\n\tvec4 projPos = shadowMatrix * vec4(wPos, 1.0);\n\tprojPos.xyz /= projPos.w;\n\tdShadowCoord = projPos.xyz;\n}\nvoid getShadowCoordPerspZbufferNormalOffset(mat4 shadowMatrix, vec4 shadowParams, vec3 normal) {\n\tvec3 wPos = vPositionW + normal * shadowParams.y;\n\t_getShadowCoordPerspZbuffer(shadowMatrix, shadowParams, wPos);\n}\nvec3 normalOffsetPointShadow(vec4 shadowParams, vec3 lightPos, inout vec3 lightDir, vec3 lightDirNorm, vec3 normal) {\n\tfloat distScale = length(lightDir);\n\tvec3 wPos = vPositionW + normal * shadowParams.y * clamp(1.0 - dot(normal, -lightDirNorm), 0.0, 1.0) * distScale;\n\tvec3 dir = wPos - lightPos;\n\treturn dir;\n}\n#ifdef GL2\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF1)\n\tfloat getShadowOmniClusteredPCF1(SHADOWMAP_ACCEPT(shadowMap), vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 lightDir) {\n\t\tfloat shadowTextureResolution = shadowParams.x;\n\t\tvec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);\n\t\tfloat shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;\n\t\treturn textureShadow(shadowMap, vec3(uv, shadowZ));\n\t}\n\t#endif\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF3)\n\tfloat getShadowOmniClusteredPCF3(SHADOWMAP_ACCEPT(shadowMap), vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 lightDir) {\n\t\tfloat shadowTextureResolution = shadowParams.x;\n\t\tvec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);\n\t\tfloat shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;\n\t\tvec3 shadowCoord = vec3(uv, shadowZ);\n\t\treturn getShadowPCF3x3(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams);\n\t}\n\t#endif\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF5)\n\tfloat getShadowOmniClusteredPCF5(SHADOWMAP_ACCEPT(shadowMap), vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 lightDir) {\n\t\tfloat shadowTextureResolution = shadowParams.x;\n\t\tvec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);\n\t\tfloat shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;\n\t\tvec3 shadowCoord = vec3(uv, shadowZ);\n\t\treturn getShadowPCF5x5(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams);\n\t}\n\t#endif\n#else\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF1)\n\tfloat getShadowOmniClusteredPCF1(sampler2D shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 lightDir) {\n\t\tfloat shadowTextureResolution = shadowParams.x;\n\t\tvec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);\n\t\tfloat depth = unpackFloat(textureShadow(shadowMap, uv));\n\t\tfloat shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;\n\t\treturn depth > shadowZ ? 1.0 : 0.0;\n\t}\n\t#endif\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF3)\n\tfloat getShadowOmniClusteredPCF3(sampler2D shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 lightDir) {\n\t\tfloat shadowTextureResolution = shadowParams.x;\n\t\tvec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);\n\t\tfloat shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;\n\t\tvec3 shadowCoord = vec3(uv, shadowZ);\n\t\treturn getShadowPCF3x3(shadowMap, shadowCoord, shadowParams);\n\t}\n\t#endif\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF5)\n\tfloat getShadowOmniClusteredPCF5(sampler2D shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 lightDir) {\n\t\tfloat shadowTextureResolution = shadowParams.x;\n\t\tvec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);\n\t\tfloat shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;\n\t\tvec3 shadowCoord = vec3(uv, shadowZ);\n\t\treturn getShadowPCF3x3(shadowMap, shadowCoord, shadowParams);\n\t}\n\t#endif\n#endif\n#ifdef GL2\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF1)\n\tfloat getShadowSpotClusteredPCF1(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {\n\t\treturn textureShadow(shadowMap, shadowCoord);\n\t}\n\t#endif\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF3)\n\tfloat getShadowSpotClusteredPCF3(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {\n\t\treturn getShadowSpotPCF3x3(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams);\n\t}\n\t#endif\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF5)\n\tfloat getShadowSpotClusteredPCF5(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {\n\t\treturn getShadowPCF5x5(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams);\n\t}\n\t#endif\n#else\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF1)\n\tfloat getShadowSpotClusteredPCF1(sampler2D shadowMap, vec3 shadowCoord, vec4 shadowParams) {\n\t\tfloat depth = unpackFloat(textureShadow(shadowMap, shadowCoord.xy));\n\t\treturn depth > shadowCoord.z ? 1.0 : 0.0;\n\t}\n\t#endif\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF3)\n\tfloat getShadowSpotClusteredPCF3(sampler2D shadowMap, vec3 shadowCoord, vec4 shadowParams) {\n\t\treturn getShadowSpotPCF3x3(shadowMap, shadowCoord, shadowParams);\n\t}\n\t#endif\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF5)\n\tfloat getShadowSpotClusteredPCF5(sampler2D shadowMap, vec3 shadowCoord, vec4 shadowParams) {\n\t\treturn getShadowSpotPCF3x3(shadowMap, shadowCoord, shadowParams);\n\t}\n\t#endif\n#endif\n";

	var clusteredLightPS = "\nuniform highp sampler2D clusterWorldTexture;\nuniform highp sampler2D lightsTexture8;\nuniform highp sampler2D lightsTextureFloat;\n#if defined(CLUSTER_COOKIES)\n\t#define CLUSTER_COOKIES_OR_SHADOWS\n#endif\n#if defined(CLUSTER_SHADOWS)\n\t#define CLUSTER_COOKIES_OR_SHADOWS\n#endif\n#ifdef CLUSTER_SHADOWS\n\t#ifdef GL2\n\t\tuniform sampler2DShadow shadowAtlasTexture;\n\t#else\n\t\tuniform sampler2D shadowAtlasTexture;\n\t#endif\n#endif\n#ifdef CLUSTER_COOKIES\n\tuniform sampler2D cookieAtlasTexture;\n#endif\n#ifdef GL2\n\tuniform int clusterMaxCells;\n#else\n\tuniform float clusterMaxCells;\n\tuniform vec4 lightsTextureInvSize;\n#endif\nuniform float clusterSkip;\nuniform vec3 clusterCellsCountByBoundsSize;\nuniform vec3 clusterTextureSize;\nuniform vec3 clusterBoundsMin;\nuniform vec3 clusterBoundsDelta;\nuniform vec3 clusterCellsDot;\nuniform vec3 clusterCellsMax;\nuniform vec2 clusterCompressionLimit0;\nuniform vec2 shadowAtlasParams;\nstruct ClusterLightData {\n\tvec3 halfWidth;\n\tfloat lightType;\n\tvec3 halfHeight;\n\t#ifdef GL2\n\t\tint lightIndex;\n\t#else\n\t\tfloat lightV;\n\t#endif\n\tvec3 position;\n\tfloat shape;\n\tvec3 direction;\n\tfloat falloffMode;\n\tvec3 color;\n\tfloat shadowIntensity;\n\tvec3 omniAtlasViewport;\n\tfloat range;\n\tvec4 cookieChannelMask;\n\tfloat shadowBias;\n\tfloat shadowNormalBias;\n\tfloat innerConeAngleCos;\n\tfloat outerConeAngleCos;\n\tfloat cookie;\n\tfloat cookieRgb;\n\tfloat cookieIntensity;\n\tfloat mask;\n};\nmat4 lightProjectionMatrix;\n#define isClusteredLightCastShadow(light) ( light.shadowIntensity > 0.0 )\n#define isClusteredLightCookie(light) (light.cookie > 0.5 )\n#define isClusteredLightCookieRgb(light) (light.cookieRgb > 0.5 )\n#define isClusteredLightSpot(light) ( light.lightType > 0.5 )\n#define isClusteredLightFalloffLinear(light) ( light.falloffMode < 0.5 )\n#define isClusteredLightArea(light) ( light.shape > 0.1 )\n#define isClusteredLightRect(light) ( light.shape < 0.3 )\n#define isClusteredLightDisk(light) ( light.shape < 0.6 )\n#ifdef CLUSTER_MESH_DYNAMIC_LIGHTS\n\t#define acceptLightMask(light) ( light.mask < 0.75)\n#else\n\t#define acceptLightMask(light) ( light.mask > 0.25)\n#endif\nvec4 decodeClusterLowRange4Vec4(vec4 d0, vec4 d1, vec4 d2, vec4 d3) {\n\treturn vec4(\n\t\tbytes2floatRange4(d0, -2.0, 2.0),\n\t\tbytes2floatRange4(d1, -2.0, 2.0),\n\t\tbytes2floatRange4(d2, -2.0, 2.0),\n\t\tbytes2floatRange4(d3, -2.0, 2.0)\n\t);\n}\n#ifdef GL2\n\tvec4 sampleLightsTexture8(const ClusterLightData clusterLightData, int index) {\n\t\treturn texelFetch(lightsTexture8, ivec2(index, clusterLightData.lightIndex), 0);\n\t}\n\tvec4 sampleLightTextureF(const ClusterLightData clusterLightData, int index) {\n\t\treturn texelFetch(lightsTextureFloat, ivec2(index, clusterLightData.lightIndex), 0);\n\t}\n#else\n\tvec4 sampleLightsTexture8(const ClusterLightData clusterLightData, float index) {\n\t\treturn texture2DLodEXT(lightsTexture8, vec2(index * lightsTextureInvSize.z, clusterLightData.lightV), 0.0);\n\t}\n\tvec4 sampleLightTextureF(const ClusterLightData clusterLightData, float index) {\n\t\treturn texture2DLodEXT(lightsTextureFloat, vec2(index * lightsTextureInvSize.x, clusterLightData.lightV), 0.0);\n\t}\n#endif\nvoid decodeClusterLightCore(inout ClusterLightData clusterLightData, float lightIndex) {\n\t#ifdef GL2\n\t\tclusterLightData.lightIndex = int(lightIndex);\n\t#else\n\t\tclusterLightData.lightV = (lightIndex + 0.5) * lightsTextureInvSize.w;\n\t#endif\n\tvec4 lightInfo = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_FLAGS);\n\tclusterLightData.lightType = lightInfo.x;\n\tclusterLightData.shape = lightInfo.y;\n\tclusterLightData.falloffMode = lightInfo.z;\n\tclusterLightData.shadowIntensity = lightInfo.w;\n\tvec4 colorA = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COLOR_A);\n\tvec4 colorB = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COLOR_B);\n\tclusterLightData.color = vec3(bytes2float2(colorA.xy), bytes2float2(colorA.zw), bytes2float2(colorB.xy)) * clusterCompressionLimit0.y;\n\tclusterLightData.cookie = colorB.z;\n\tclusterLightData.mask = colorB.w;\n\t#ifdef CLUSTER_TEXTURE_FLOAT\n\t\tvec4 lightPosRange = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_POSITION_RANGE);\n\t\tclusterLightData.position = lightPosRange.xyz;\n\t\tclusterLightData.range = lightPosRange.w;\n\t\tvec4 lightDir_Unused = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_SPOT_DIRECTION);\n\t\tclusterLightData.direction = lightDir_Unused.xyz;\n\t#else\n\t\tvec4 encPosX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_POSITION_X);\n\t\tvec4 encPosY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_POSITION_Y);\n\t\tvec4 encPosZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_POSITION_Z);\n\t\tclusterLightData.position = vec3(bytes2float4(encPosX), bytes2float4(encPosY), bytes2float4(encPosZ)) * clusterBoundsDelta + clusterBoundsMin;\n\t\tvec4 encRange = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_RANGE);\n\t\tclusterLightData.range = bytes2float4(encRange) * clusterCompressionLimit0.x;\n\t\tvec4 encDirX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_DIRECTION_X);\n\t\tvec4 encDirY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_DIRECTION_Y);\n\t\tvec4 encDirZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_DIRECTION_Z);\n\t\tclusterLightData.direction = vec3(bytes2float4(encDirX), bytes2float4(encDirY), bytes2float4(encDirZ)) * 2.0 - 1.0;\n\t#endif\n}\nvoid decodeClusterLightSpot(inout ClusterLightData clusterLightData) {\n\tvec4 coneAngle = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_ANGLES);\n\tclusterLightData.innerConeAngleCos = bytes2float2(coneAngle.xy) * 2.0 - 1.0;\n\tclusterLightData.outerConeAngleCos = bytes2float2(coneAngle.zw) * 2.0 - 1.0;\n}\nvoid decodeClusterLightOmniAtlasViewport(inout ClusterLightData clusterLightData) {\n\t#ifdef CLUSTER_TEXTURE_FLOAT\n\t\tclusterLightData.omniAtlasViewport = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_0).xyz;\n\t#else\n\t\tvec4 viewportA = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_ATLAS_VIEWPORT_A);\n\t\tvec4 viewportB = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_ATLAS_VIEWPORT_B);\n\t\tclusterLightData.omniAtlasViewport = vec3(bytes2float2(viewportA.xy), bytes2float2(viewportA.zw), bytes2float2(viewportB.xy));\n\t#endif\n}\nvoid decodeClusterLightAreaData(inout ClusterLightData clusterLightData) {\n\t#ifdef CLUSTER_TEXTURE_FLOAT\n\t\tclusterLightData.halfWidth = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_AREA_DATA_WIDTH).xyz;\n\t\tclusterLightData.halfHeight = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_AREA_DATA_HEIGHT).xyz;\n\t#else\n\t\tvec4 areaWidthX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_WIDTH_X);\n\t\tvec4 areaWidthY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_WIDTH_Y);\n\t\tvec4 areaWidthZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_WIDTH_Z);\n\t\tclusterLightData.halfWidth = vec3(mantissaExponent2Float(areaWidthX), mantissaExponent2Float(areaWidthY), mantissaExponent2Float(areaWidthZ));\n\t\tvec4 areaHeightX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_HEIGHT_X);\n\t\tvec4 areaHeightY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_HEIGHT_Y);\n\t\tvec4 areaHeightZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_HEIGHT_Z);\n\t\tclusterLightData.halfHeight = vec3(mantissaExponent2Float(areaHeightX), mantissaExponent2Float(areaHeightY), mantissaExponent2Float(areaHeightZ));\n\t#endif\n}\nvoid decodeClusterLightProjectionMatrixData(inout ClusterLightData clusterLightData) {\n\t\n\t#ifdef CLUSTER_TEXTURE_FLOAT\n\t\tvec4 m0 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_0);\n\t\tvec4 m1 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_1);\n\t\tvec4 m2 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_2);\n\t\tvec4 m3 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_3);\n\t#else\n\t\tvec4 m00 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_00);\n\t\tvec4 m01 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_01);\n\t\tvec4 m02 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_02);\n\t\tvec4 m03 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_03);\n\t\tvec4 m0 = decodeClusterLowRange4Vec4(m00, m01, m02, m03);\n\t\tvec4 m10 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_10);\n\t\tvec4 m11 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_11);\n\t\tvec4 m12 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_12);\n\t\tvec4 m13 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_13);\n\t\tvec4 m1 = decodeClusterLowRange4Vec4(m10, m11, m12, m13);\n\t\tvec4 m20 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_20);\n\t\tvec4 m21 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_21);\n\t\tvec4 m22 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_22);\n\t\tvec4 m23 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_23);\n\t\tvec4 m2 = decodeClusterLowRange4Vec4(m20, m21, m22, m23);\n\t\tvec4 m30 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_30);\n\t\tvec4 m31 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_31);\n\t\tvec4 m32 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_32);\n\t\tvec4 m33 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_33);\n\t\tvec4 m3 = vec4(mantissaExponent2Float(m30), mantissaExponent2Float(m31), mantissaExponent2Float(m32), mantissaExponent2Float(m33));\n\t#endif\n\t\n\tlightProjectionMatrix = mat4(m0, m1, m2, m3);\n}\nvoid decodeClusterLightShadowData(inout ClusterLightData clusterLightData) {\n\t\n\tvec4 biases = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SHADOW_BIAS);\n\tclusterLightData.shadowBias = bytes2floatRange2(biases.xy, -1.0, 20.0),\n\tclusterLightData.shadowNormalBias = bytes2float2(biases.zw);\n}\nvoid decodeClusterLightCookieData(inout ClusterLightData clusterLightData) {\n\tvec4 cookieA = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COOKIE_A);\n\tclusterLightData.cookieIntensity = cookieA.x;\n\tclusterLightData.cookieRgb = cookieA.y;\n\tclusterLightData.cookieChannelMask = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COOKIE_B);\n}\nvoid evaluateLight(\n\tClusterLightData light, \n\tvec3 worldNormal, \n\tvec3 viewDir, \n\tvec3 reflectionDir,\n#if defined(LIT_CLEARCOAT)\n\tvec3 clearcoatReflectionDir,\n#endif\n\tfloat gloss, \n\tvec3 specularity, \n\tvec3 geometricNormal, \n\tmat3 tbn, \n#if defined(LIT_IRIDESCENCE)\n\tvec3 iridescenceFresnel,\n#endif\n\tvec3 clearcoat_worldNormal,\n\tfloat clearcoat_gloss,\n\tfloat sheen_gloss,\n\tfloat iridescence_intensity\n) {\n\tvec3 cookieAttenuation = vec3(1.0);\n\tfloat diffuseAttenuation = 1.0;\n\tfloat falloffAttenuation = 1.0;\n\tgetLightDirPoint(light.position);\n\t#ifdef CLUSTER_AREALIGHTS\n\tif (isClusteredLightArea(light)) {\n\t\tdecodeClusterLightAreaData(light);\n\t\tif (isClusteredLightRect(light)) {\n\t\t\tcalcRectLightValues(light.position, light.halfWidth, light.halfHeight);\n\t\t} else if (isClusteredLightDisk(light)) {\n\t\t\tcalcDiskLightValues(light.position, light.halfWidth, light.halfHeight);\n\t\t} else {\n\t\t\tcalcSphereLightValues(light.position, light.halfWidth, light.halfHeight);\n\t\t}\n\t\tfalloffAttenuation = getFalloffWindow(light.range, dLightDirW);\n\t} else\n\t#endif\n\t{\n\t\tif (isClusteredLightFalloffLinear(light))\n\t\t\tfalloffAttenuation = getFalloffLinear(light.range, dLightDirW);\n\t\telse\n\t\t\tfalloffAttenuation = getFalloffInvSquared(light.range, dLightDirW);\n\t}\n\tif (falloffAttenuation > 0.00001) {\n\t\t#ifdef CLUSTER_AREALIGHTS\n\t\tif (isClusteredLightArea(light)) {\n\t\t\tif (isClusteredLightRect(light)) {\n\t\t\t\tdiffuseAttenuation = getRectLightDiffuse(worldNormal, viewDir, dLightDirW, dLightDirNormW) * 16.0;\n\t\t\t} else if (isClusteredLightDisk(light)) {\n\t\t\t\tdiffuseAttenuation = getDiskLightDiffuse(worldNormal, viewDir, dLightDirW, dLightDirNormW) * 16.0;\n\t\t\t} else {\n\t\t\t\tdiffuseAttenuation = getSphereLightDiffuse(worldNormal, viewDir, dLightDirW, dLightDirNormW) * 16.0;\n\t\t\t}\n\t\t} else\n\t\t#endif\n\t\t{\n\t\t\tfalloffAttenuation *= getLightDiffuse(worldNormal, viewDir, dLightDirW, dLightDirNormW); \n\t\t}\n\t\tif (isClusteredLightSpot(light)) {\n\t\t\tdecodeClusterLightSpot(light);\n\t\t\tfalloffAttenuation *= getSpotEffect(light.direction, light.innerConeAngleCos, light.outerConeAngleCos, dLightDirNormW);\n\t\t}\n\t\t#if defined(CLUSTER_COOKIES_OR_SHADOWS)\n\t\tif (falloffAttenuation > 0.00001) {\n\t\t\tif (isClusteredLightCastShadow(light) || isClusteredLightCookie(light)) {\n\t\t\t\tif (isClusteredLightSpot(light)) {\n\t\t\t\t\tdecodeClusterLightProjectionMatrixData(light);\n\t\t\t\t} else {\n\t\t\t\t\tdecodeClusterLightOmniAtlasViewport(light);\n\t\t\t\t}\n\t\t\t\tfloat shadowTextureResolution = shadowAtlasParams.x;\n\t\t\t\tfloat shadowEdgePixels = shadowAtlasParams.y;\n\t\t\t\t#ifdef CLUSTER_COOKIES\n\t\t\t\tif (isClusteredLightCookie(light)) {\n\t\t\t\t\tdecodeClusterLightCookieData(light);\n\t\t\t\t\tif (isClusteredLightSpot(light)) {\n\t\t\t\t\t\tcookieAttenuation = getCookie2DClustered(TEXTURE_PASS(cookieAtlasTexture), lightProjectionMatrix, vPositionW, light.cookieIntensity, isClusteredLightCookieRgb(light), light.cookieChannelMask);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcookieAttenuation = getCookieCubeClustered(TEXTURE_PASS(cookieAtlasTexture), dLightDirW, light.cookieIntensity, isClusteredLightCookieRgb(light), light.cookieChannelMask, shadowTextureResolution, shadowEdgePixels, light.omniAtlasViewport);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t#endif\n\t\t\t\t#ifdef CLUSTER_SHADOWS\n\t\t\t\tif (isClusteredLightCastShadow(light)) {\n\t\t\t\t\tdecodeClusterLightShadowData(light);\n\t\t\t\t\tvec4 shadowParams = vec4(shadowTextureResolution, light.shadowNormalBias, light.shadowBias, 1.0 / light.range);\n\t\t\t\t\tif (isClusteredLightSpot(light)) {\n\t\t\t\t\t\tgetShadowCoordPerspZbufferNormalOffset(lightProjectionMatrix, shadowParams, geometricNormal);\n\t\t\t\t\t\t\n\t\t\t\t\t\t#if defined(CLUSTER_SHADOW_TYPE_PCF1)\n\t\t\t\t\t\t\tfloat shadow = getShadowSpotClusteredPCF1(SHADOWMAP_PASS(shadowAtlasTexture), dShadowCoord, shadowParams);\n\t\t\t\t\t\t#elif defined(CLUSTER_SHADOW_TYPE_PCF3)\n\t\t\t\t\t\t\tfloat shadow = getShadowSpotClusteredPCF3(SHADOWMAP_PASS(shadowAtlasTexture), dShadowCoord, shadowParams);\n\t\t\t\t\t\t#elif defined(CLUSTER_SHADOW_TYPE_PCF5)\n\t\t\t\t\t\t\tfloat shadow = getShadowSpotClusteredPCF5(SHADOWMAP_PASS(shadowAtlasTexture), dShadowCoord, shadowParams);\n\t\t\t\t\t\t#elif defined(CLUSTER_SHADOW_TYPE_PCSS)\n\t\t\t\t\t\t\tfloat shadow = getShadowSpotClusteredPCSS(SHADOWMAP_PASS(shadowAtlasTexture), dShadowCoord, shadowParams);\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\tfalloffAttenuation *= mix(1.0, shadow, light.shadowIntensity);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvec3 dir = normalOffsetPointShadow(shadowParams, dLightPosW, dLightDirW, dLightDirNormW, geometricNormal);\n\t\t\t\t\t\t#if defined(CLUSTER_SHADOW_TYPE_PCF1)\n\t\t\t\t\t\t\tfloat shadow = getShadowOmniClusteredPCF1(SHADOWMAP_PASS(shadowAtlasTexture), shadowParams, light.omniAtlasViewport, shadowEdgePixels, dir);\n\t\t\t\t\t\t#elif defined(CLUSTER_SHADOW_TYPE_PCF3)\n\t\t\t\t\t\t\tfloat shadow = getShadowOmniClusteredPCF3(SHADOWMAP_PASS(shadowAtlasTexture), shadowParams, light.omniAtlasViewport, shadowEdgePixels, dir);\n\t\t\t\t\t\t#elif defined(CLUSTER_SHADOW_TYPE_PCF5)\n\t\t\t\t\t\t\tfloat shadow = getShadowOmniClusteredPCF5(SHADOWMAP_PASS(shadowAtlasTexture), shadowParams, light.omniAtlasViewport, shadowEdgePixels, dir);\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\tfalloffAttenuation *= mix(1.0, shadow, light.shadowIntensity);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t#endif\n\t\t\t}\n\t\t}\n\t\t#endif\n\t\t#ifdef CLUSTER_AREALIGHTS\n\t\tif (isClusteredLightArea(light)) {\n\t\t\t{\n\t\t\t\tvec3 areaDiffuse = (diffuseAttenuation * falloffAttenuation) * light.color * cookieAttenuation;\n\t\t\t\t#if defined(LIT_SPECULAR)\n\t\t\t\t\t#if defined(LIT_CONSERVE_ENERGY)\n\t\t\t\t\t\tareaDiffuse = mix(areaDiffuse, vec3(0), dLTCSpecFres);\n\t\t\t\t\t#endif\n\t\t\t\t#endif\n\t\t\t\tdDiffuseLight += areaDiffuse;\n\t\t\t}\n\t\t\t#ifdef LIT_SPECULAR\n\t\t\t\tfloat areaLightSpecular;\n\t\t\t\tif (isClusteredLightRect(light)) {\n\t\t\t\t\tareaLightSpecular = getRectLightSpecular(worldNormal, viewDir);\n\t\t\t\t} else if (isClusteredLightDisk(light)) {\n\t\t\t\t\tareaLightSpecular = getDiskLightSpecular(worldNormal, viewDir);\n\t\t\t\t} else {\n\t\t\t\t\tareaLightSpecular = getSphereLightSpecular(worldNormal, viewDir);\n\t\t\t\t}\n\t\t\t\tdSpecularLight += dLTCSpecFres * areaLightSpecular * falloffAttenuation * light.color * cookieAttenuation;\n\t\t\t\t#ifdef LIT_CLEARCOAT\n\t\t\t\t\tfloat areaLightSpecularCC;\n\t\t\t\t\tif (isClusteredLightRect(light)) {\n\t\t\t\t\t\tareaLightSpecularCC = getRectLightSpecular(clearcoat_worldNormal, viewDir);\n\t\t\t\t\t} else if (isClusteredLightDisk(light)) {\n\t\t\t\t\t\tareaLightSpecularCC = getDiskLightSpecular(clearcoat_worldNormal, viewDir);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tareaLightSpecularCC = getSphereLightSpecular(clearcoat_worldNormal, viewDir);\n\t\t\t\t\t}\n\t\t\t\t\tccSpecularLight += ccLTCSpecFres * areaLightSpecularCC * falloffAttenuation * light.color  * cookieAttenuation;\n\t\t\t\t#endif\n\t\t\t#endif\n\t\t} else\n\t\t#endif\n\t\t{\n\t\t\t{\n\t\t\t\tvec3 punctualDiffuse = falloffAttenuation * light.color * cookieAttenuation;\n\t\t\t\t#if defined(CLUSTER_AREALIGHTS)\n\t\t\t\t#if defined(LIT_SPECULAR)\n\t\t\t\t#if defined(LIT_CONSERVE_ENERGY)\n\t\t\t\t\tpunctualDiffuse = mix(punctualDiffuse, vec3(0), specularity);\n\t\t\t\t#endif\n\t\t\t\t#endif\n\t\t\t\t#endif\n\t\t\t\tdDiffuseLight += punctualDiffuse;\n\t\t\t}\n   \n\t\t\t#ifdef LIT_SPECULAR\n\t\t\t\tvec3 halfDir = normalize(-dLightDirNormW + viewDir);\n\t\t\t\t\n\t\t\t\t#ifdef LIT_SPECULAR_FRESNEL\n\t\t\t\t\tdSpecularLight += \n\t\t\t\t\t\tgetLightSpecular(halfDir, reflectionDir, worldNormal, viewDir, dLightDirNormW, gloss, tbn) * falloffAttenuation * light.color * cookieAttenuation * \n\t\t\t\t\t\tgetFresnel(\n\t\t\t\t\t\t\tdot(viewDir, halfDir), \n\t\t\t\t\t\t\tgloss, \n\t\t\t\t\t\t\tspecularity\n\t\t\t\t\t\t#if defined(LIT_IRIDESCENCE)\n\t\t\t\t\t\t\t, iridescenceFresnel,\n\t\t\t\t\t\t\tiridescence_intensity\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\t);\n\t\t\t\t#else\n\t\t\t\t\tdSpecularLight += getLightSpecular(halfDir, reflectionDir, worldNormal, viewDir, dLightDirNormW, gloss, tbn) * falloffAttenuation * light.color * cookieAttenuation * specularity;\n\t\t\t\t#endif\n\t\t\t\t#ifdef LIT_CLEARCOAT\n\t\t\t\t\t#ifdef LIT_SPECULAR_FRESNEL\n\t\t\t\t\t\tccSpecularLight += getLightSpecular(halfDir, clearcoatReflectionDir, clearcoat_worldNormal, viewDir, dLightDirNormW, clearcoat_gloss, tbn) * falloffAttenuation * light.color * cookieAttenuation * getFresnelCC(dot(viewDir, halfDir));\n\t\t\t\t\t#else\n\t\t\t\t\t\tccSpecularLight += getLightSpecular(halfDir, clearcoatReflectionDir, clearcoat_worldNormal, viewDir, dLightDirNormW, clearcoat_gloss, tbn) * falloffAttenuation * light.color * cookieAttenuation; \n\t\t\t\t\t#endif\n\t\t\t\t#endif\n\t\t\t\t#ifdef LIT_SHEEN\n\t\t\t\t\tsSpecularLight += getLightSpecularSheen(halfDir, worldNormal, viewDir, dLightDirNormW, sheen_gloss) * falloffAttenuation * light.color * cookieAttenuation;\n\t\t\t\t#endif\n\t\t\t#endif\n\t\t}\n\t}\n\tdAtten = falloffAttenuation;\n\tdAttenD = diffuseAttenuation;\n\tdAtten3 = cookieAttenuation;\n}\nvoid evaluateClusterLight(\n\tfloat lightIndex, \n\tvec3 worldNormal, \n\tvec3 viewDir, \n\tvec3 reflectionDir, \n#if defined(LIT_CLEARCOAT)\n\tvec3 clearcoatReflectionDir,\n#endif\n\tfloat gloss, \n\tvec3 specularity, \n\tvec3 geometricNormal, \n\tmat3 tbn, \n#if defined(LIT_IRIDESCENCE)\n\tvec3 iridescenceFresnel,\n#endif\n\tvec3 clearcoat_worldNormal,\n\tfloat clearcoat_gloss,\n\tfloat sheen_gloss,\n\tfloat iridescence_intensity\n) {\n\tClusterLightData clusterLightData;\n\tdecodeClusterLightCore(clusterLightData, lightIndex);\n\tif (acceptLightMask(clusterLightData))\n\t\tevaluateLight(\n\t\t\tclusterLightData, \n\t\t\tworldNormal, \n\t\t\tviewDir, \n\t\t\treflectionDir, \n#if defined(LIT_CLEARCOAT)\n\t\t\tclearcoatReflectionDir, \n#endif\n\t\t\tgloss, \n\t\t\tspecularity, \n\t\t\tgeometricNormal, \n\t\t\ttbn, \n#if defined(LIT_IRIDESCENCE)\n\t\t\tiridescenceFresnel,\n#endif\n\t\t\tclearcoat_worldNormal,\n\t\t\tclearcoat_gloss,\n\t\t\tsheen_gloss,\n\t\t\tiridescence_intensity\n\t\t);\n}\nvoid addClusteredLights(\n\tvec3 worldNormal, \n\tvec3 viewDir, \n\tvec3 reflectionDir, \n#if defined(LIT_CLEARCOAT)\n\tvec3 clearcoatReflectionDir,\n#endif\n\tfloat gloss, \n\tvec3 specularity, \n\tvec3 geometricNormal, \n\tmat3 tbn, \n#if defined(LIT_IRIDESCENCE)\n\tvec3 iridescenceFresnel,\n#endif\n\tvec3 clearcoat_worldNormal,\n\tfloat clearcoat_gloss,\n\tfloat sheen_gloss,\n\tfloat iridescence_intensity\n) {\n\tif (clusterSkip > 0.5)\n\t\treturn;\n\tvec3 cellCoords = floor((vPositionW - clusterBoundsMin) * clusterCellsCountByBoundsSize);\n\tif (!(any(lessThan(cellCoords, vec3(0.0))) || any(greaterThanEqual(cellCoords, clusterCellsMax)))) {\n\t\tfloat cellIndex = dot(clusterCellsDot, cellCoords);\n\t\tfloat clusterV = floor(cellIndex * clusterTextureSize.y);\n\t\tfloat clusterU = cellIndex - (clusterV * clusterTextureSize.x);\n\t\t#ifdef GL2\n\t\t\tfor (int lightCellIndex = 0; lightCellIndex < clusterMaxCells; lightCellIndex++) {\n\t\t\t\tfloat lightIndex = texelFetch(clusterWorldTexture, ivec2(int(clusterU) + lightCellIndex, clusterV), 0).x;\n\t\t\t\tif (lightIndex <= 0.0)\n\t\t\t\t\t\treturn;\n\t\t\t\tevaluateClusterLight(\n\t\t\t\t\tlightIndex * 255.0, \n\t\t\t\t\tworldNormal, \n\t\t\t\t\tviewDir, \n\t\t\t\t\treflectionDir,\n#if defined(LIT_CLEARCOAT)\n\t\t\t\t\tclearcoatReflectionDir,\n#endif\n\t\t\t\t\tgloss, \n\t\t\t\t\tspecularity, \n\t\t\t\t\tgeometricNormal, \n\t\t\t\t\ttbn, \n#if defined(LIT_IRIDESCENCE)\n\t\t\t\t\tiridescenceFresnel,\n#endif\n\t\t\t\t\tclearcoat_worldNormal,\n\t\t\t\t\tclearcoat_gloss,\n\t\t\t\t\tsheen_gloss,\n\t\t\t\t\tiridescence_intensity\n\t\t\t\t); \n\t\t\t}\n\t\t#else\n\t\t\tclusterV = (clusterV + 0.5) * clusterTextureSize.z;\n\t\t\tconst float maxLightCells = 256.0;\n\t\t\tfor (float lightCellIndex = 0.5; lightCellIndex < maxLightCells; lightCellIndex++) {\n\t\t\t\tfloat lightIndex = texture2DLodEXT(clusterWorldTexture, vec2(clusterTextureSize.y * (clusterU + lightCellIndex), clusterV), 0.0).x;\n\t\t\t\tif (lightIndex <= 0.0)\n\t\t\t\t\treturn;\n\t\t\t\t\n\t\t\t\tevaluateClusterLight(\n\t\t\t\t\tlightIndex * 255.0, \n\t\t\t\t\tworldNormal, \n\t\t\t\t\tviewDir, \n\t\t\t\t\treflectionDir,\n#if defined(LIT_CLEARCOAT)\n\t\t\t\t\tclearcoatReflectionDir,\n#endif\n\t\t\t\t\tgloss, \n\t\t\t\t\tspecularity, \n\t\t\t\t\tgeometricNormal, \n\t\t\t\t\ttbn, \n#if defined(LIT_IRIDESCENCE)\n\t\t\t\t\tiridescenceFresnel,\n#endif\n\t\t\t\t\tclearcoat_worldNormal,\n\t\t\t\t\tclearcoat_gloss,\n\t\t\t\t\tsheen_gloss,\n\t\t\t\t\tiridescence_intensity\n\t\t\t\t); \n\t\t\t\tif (lightCellIndex >= clusterMaxCells) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t#endif\n\t}\n}\n";

	var combinePS = "\nvec3 combineColor(vec3 albedo, vec3 sheenSpecularity, float clearcoatSpecularity) {\n\tvec3 ret = vec3(0);\n#ifdef LIT_OLD_AMBIENT\n\tret += (dDiffuseLight - light_globalAmbient) * albedo + material_ambient * light_globalAmbient;\n#else\n\tret += albedo * dDiffuseLight;\n#endif\n#ifdef LIT_SPECULAR\n\tret += dSpecularLight;\n#endif\n#ifdef LIT_REFLECTIONS\n\tret += dReflection.rgb * dReflection.a;\n#endif\n#ifdef LIT_SHEEN\n\tfloat sheenScaling = 1.0 - max(max(sheenSpecularity.r, sheenSpecularity.g), sheenSpecularity.b) * 0.157;\n\tret = ret * sheenScaling + (sSpecularLight + sReflection.rgb) * sheenSpecularity;\n#endif\n#ifdef LIT_CLEARCOAT\n\tfloat clearCoatScaling = 1.0 - ccFresnel * clearcoatSpecularity;\n\tret = ret * clearCoatScaling + (ccSpecularLight + ccReflection.rgb) * clearcoatSpecularity;\n#endif\n\treturn ret;\n}\n";

	var cookiePS = "\nvec4 getCookie2D(sampler2D tex, mat4 transform, float intensity) {\n\tvec4 projPos = transform * vec4(vPositionW, 1.0);\n\tprojPos.xy /= projPos.w;\n\treturn mix(vec4(1.0), texture2D(tex, projPos.xy), intensity);\n}\nvec4 getCookie2DClip(sampler2D tex, mat4 transform, float intensity) {\n\tvec4 projPos = transform * vec4(vPositionW, 1.0);\n\tprojPos.xy /= projPos.w;\n\tif (projPos.x < 0.0 || projPos.x > 1.0 || projPos.y < 0.0 || projPos.y > 1.0 || projPos.z < 0.0) return vec4(0.0);\n\treturn mix(vec4(1.0), texture2D(tex, projPos.xy), intensity);\n}\nvec4 getCookie2DXform(sampler2D tex, mat4 transform, float intensity, vec4 cookieMatrix, vec2 cookieOffset) {\n\tvec4 projPos = transform * vec4(vPositionW, 1.0);\n\tprojPos.xy /= projPos.w;\n\tprojPos.xy += cookieOffset;\n\tvec2 uv = mat2(cookieMatrix) * (projPos.xy-vec2(0.5)) + vec2(0.5);\n\treturn mix(vec4(1.0), texture2D(tex, uv), intensity);\n}\nvec4 getCookie2DClipXform(sampler2D tex, mat4 transform, float intensity, vec4 cookieMatrix, vec2 cookieOffset) {\n\tvec4 projPos = transform * vec4(vPositionW, 1.0);\n\tprojPos.xy /= projPos.w;\n\tprojPos.xy += cookieOffset;\n\tif (projPos.x < 0.0 || projPos.x > 1.0 || projPos.y < 0.0 || projPos.y > 1.0 || projPos.z < 0.0) return vec4(0.0);\n\tvec2 uv = mat2(cookieMatrix) * (projPos.xy-vec2(0.5)) + vec2(0.5);\n\treturn mix(vec4(1.0), texture2D(tex, uv), intensity);\n}\nvec4 getCookieCube(samplerCube tex, mat4 transform, float intensity) {\n\treturn mix(vec4(1.0), textureCube(tex, dLightDirNormW * mat3(transform)), intensity);\n}\n";

	var cubeMapProjectBoxPS = "\nuniform vec3 envBoxMin;\nuniform vec3 envBoxMax;\nvec3 cubeMapProject(vec3 nrdir) {\n\tnrdir = cubeMapRotate(nrdir);\n\tvec3 rbmax = (envBoxMax - vPositionW) / nrdir;\n\tvec3 rbmin = (envBoxMin - vPositionW) / nrdir;\n\tvec3 rbminmax;\n\trbminmax.x = nrdir.x>0.0? rbmax.x : rbmin.x;\n\trbminmax.y = nrdir.y>0.0? rbmax.y : rbmin.y;\n\trbminmax.z = nrdir.z>0.0? rbmax.z : rbmin.z;\n\tfloat fa = min(min(rbminmax.x, rbminmax.y), rbminmax.z);\n\tvec3 posonbox = vPositionW + nrdir * fa;\n\tvec3 envBoxPos = (envBoxMin + envBoxMax) * 0.5;\n\treturn normalize(posonbox - envBoxPos);\n}\n";

	var cubeMapProjectNonePS = "\nvec3 cubeMapProject(vec3 dir) {\n\treturn cubeMapRotate(dir);\n}\n";

	var cubeMapRotatePS = "\n#ifdef CUBEMAP_ROTATION\nuniform mat3 cubeMapRotationMatrix;\n#endif\nvec3 cubeMapRotate(vec3 refDir) {\n#ifdef CUBEMAP_ROTATION\n\treturn refDir * cubeMapRotationMatrix;\n#else\n\treturn refDir;\n#endif\n}\n";

	var debugOutputPS = "\n#ifdef DEBUG_ALBEDO_PASS\ngl_FragColor = vec4(gammaCorrectOutput(litArgs_albedo), 1.0);\n#endif\n#ifdef DEBUG_UV0_PASS\ngl_FragColor = vec4(litArgs_albedo , 1.0);\n#endif\n#ifdef DEBUG_WORLD_NORMAL_PASS\ngl_FragColor = vec4(litArgs_worldNormal * 0.5 + 0.5, 1.0);\n#endif\n#ifdef DEBUG_OPACITY_PASS\ngl_FragColor = vec4(vec3(litArgs_opacity) , 1.0);\n#endif\n#ifdef DEBUG_SPECULARITY_PASS\ngl_FragColor = vec4(litArgs_specularity, 1.0);\n#endif\n#ifdef DEBUG_GLOSS_PASS\ngl_FragColor = vec4(vec3(litArgs_gloss) , 1.0);\n#endif\n#ifdef DEBUG_METALNESS_PASS\ngl_FragColor = vec4(vec3(litArgs_metalness) , 1.0);\n#endif\n#ifdef DEBUG_AO_PASS\ngl_FragColor = vec4(vec3(litArgs_ao) , 1.0);\n#endif\n#ifdef DEBUG_EMISSION_PASS\ngl_FragColor = vec4(gammaCorrectOutput(litArgs_emission), 1.0);\n#endif\n";

	var debugProcessFrontendPS = "\n#ifdef DEBUG_LIGHTING_PASS\nlitArgs_albedo = vec3(0.5);\n#endif\n#ifdef DEBUG_UV0_PASS\n#ifdef VARYING_VUV0\nlitArgs_albedo = vec3(vUv0, 0);\n#else\nlitArgs_albedo = vec3(0);\n#endif\n#endif\n";

	var decodePS = "\nvec3 decodeLinear(vec4 raw) {\n\treturn raw.rgb;\n}\nfloat decodeGamma(float raw) {\n\treturn pow(raw, 2.2);\n}\nvec3 decodeGamma(vec3 raw) {\n\treturn pow(raw, vec3(2.2));\n}\nvec3 decodeGamma(vec4 raw) {\n\treturn pow(raw.xyz, vec3(2.2));\n}\nvec3 decodeRGBM(vec4 raw) {\n\tvec3 color = (8.0 * raw.a) * raw.rgb;\n\treturn color * color;\n}\nvec3 decodeRGBP(vec4 raw) {\n\tvec3 color = raw.rgb * (-raw.a * 7.0 + 8.0);\n\treturn color * color;\n}\nvec3 decodeRGBE(vec4 raw) {\n\tif (raw.a == 0.0) {\n\t\treturn vec3(0.0, 0.0, 0.0);\n\t} else {\n\t\treturn raw.xyz * pow(2.0, raw.w * 255.0 - 128.0);\n\t}\n}\nvec4 passThrough(vec4 raw) {\n\treturn raw;\n}\n";

	var detailModesPS = "\nvec3 detailMode_mul(vec3 c1, vec3 c2) {\n\treturn c1 * c2;\n}\nvec3 detailMode_add(vec3 c1, vec3 c2) {\n\treturn c1 + c2;\n}\nvec3 detailMode_screen(vec3 c1, vec3 c2) {\n\treturn 1.0 - (1.0 - c1)*(1.0 - c2);\n}\nvec3 detailMode_overlay(vec3 c1, vec3 c2) {\n\treturn mix(1.0 - 2.0*(1.0 - c1)*(1.0 - c2), 2.0*c1*c2, step(c1, vec3(0.5)));\n}\nvec3 detailMode_min(vec3 c1, vec3 c2) {\n\treturn min(c1, c2);\n}\nvec3 detailMode_max(vec3 c1, vec3 c2) {\n\treturn max(c1, c2);\n}\n";

	var diffusePS = "\n#ifdef MAPCOLOR\nuniform vec3 material_diffuse;\n#endif\nvoid getAlbedo() {\n\tdAlbedo = vec3(1.0);\n#ifdef MAPCOLOR\n\tdAlbedo *= material_diffuse.rgb;\n#endif\n#ifdef MAPTEXTURE\n\tvec3 albedoBase = $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;\n\tdAlbedo *= addAlbedoDetail(albedoBase);\n#endif\n#ifdef MAPVERTEX\n\tdAlbedo *= gammaCorrectInput(saturate(vVertexColor.$VC));\n#endif\n}\n";

	var diffuseDetailMapPS = "\nvec3 addAlbedoDetail(vec3 albedo) {\n#ifdef MAPTEXTURE\n\tvec3 albedoDetail = $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;\n\treturn detailMode_$DETAILMODE(albedo, albedoDetail);\n#else\n\treturn albedo;\n#endif\n}\n";

	var emissivePS = "\n#ifdef MAPCOLOR\nuniform vec3 material_emissive;\n#endif\n#ifdef MAPFLOAT\nuniform float material_emissiveIntensity;\n#endif\nvoid getEmission() {\n\tdEmission = vec3(1.0);\n\t#ifdef MAPFLOAT\n\tdEmission *= material_emissiveIntensity;\n\t#endif\n\t#ifdef MAPCOLOR\n\tdEmission *= material_emissive;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tdEmission *= $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tdEmission *= gammaCorrectInput(saturate(vVertexColor.$VC));\n\t#endif\n}\n";

	var encodePS = "\nvec4 encodeLinear(vec3 source) {\n\treturn vec4(source, 1.0);\n}\nvec4 encodeGamma(vec3 source) {\n\treturn vec4(pow(source + 0.0000001, vec3(1.0 / 2.2)), 1.0);\n}\nvec4 encodeRGBM(vec3 source) {\n\tvec4 result;\n\tresult.rgb = pow(source.rgb, vec3(0.5));\n\tresult.rgb *= 1.0 / 8.0;\n\tresult.a = saturate( max( max( result.r, result.g ), max( result.b, 1.0 / 255.0 ) ) );\n\tresult.a = ceil(result.a * 255.0) / 255.0;\n\tresult.rgb /= result.a;\n\treturn result;\n}\nvec4 encodeRGBP(vec3 source) {\n\tvec3 gamma = pow(source, vec3(0.5));\n\tfloat maxVal = min(8.0, max(1.0, max(gamma.x, max(gamma.y, gamma.z))));\n\tfloat v = 1.0 - ((maxVal - 1.0) / 7.0);\n\tv = ceil(v * 255.0) / 255.0;\n\treturn vec4(gamma / (-v * 7.0 + 8.0), v);\t\n}\nvec4 encodeRGBE(vec3 source) {\n\tfloat maxVal = max(source.x, max(source.y, source.z));\n\tif (maxVal < 1e-32) {\n\t\treturn vec4(0, 0, 0, 0);\n\t} else {\n\t\tfloat e = ceil(log2(maxVal));\n\t\treturn vec4(source / pow(2.0, e), (e + 128.0) / 255.0);\n\t}\n}\n";

	var endPS = "\n\tgl_FragColor.rgb = combineColor(litArgs_albedo, litArgs_sheen_specularity, litArgs_clearcoat_specularity);\n\tgl_FragColor.rgb += litArgs_emission;\n\tgl_FragColor.rgb = addFog(gl_FragColor.rgb);\n\t#ifndef HDR\n\tgl_FragColor.rgb = toneMap(gl_FragColor.rgb);\n\tgl_FragColor.rgb = gammaCorrectOutput(gl_FragColor.rgb);\n\t#endif\n";

	var endVS = "\n";

	var envAtlasPS = "\nconst float atlasSize = 512.0;\nconst float seamSize = 1.0 / atlasSize;\nvec2 mapUv(vec2 uv, vec4 rect) {\n\treturn vec2(mix(rect.x + seamSize, rect.x + rect.z - seamSize, uv.x),\n\t\t\t\tmix(rect.y + seamSize, rect.y + rect.w - seamSize, uv.y));\n}\nvec2 mapRoughnessUv(vec2 uv, float level) {\n\tfloat t = 1.0 / exp2(level);\n\treturn mapUv(uv, vec4(0, 1.0 - t, t, t * 0.5));\n}\nvec2 mapShinyUv(vec2 uv, float level) {\n\tfloat t = 1.0 / exp2(level);\n\treturn mapUv(uv, vec4(1.0 - t, 1.0 - t, t, t * 0.5));\n}\n";

	var envConstPS = "\nvec3 processEnvironment(vec3 color) {\n\treturn color;\n}\n";

	var envMultiplyPS = "\nuniform float skyboxIntensity;\nvec3 processEnvironment(vec3 color) {\n\treturn color * skyboxIntensity;\n}\n";

	var extensionPS = "\n";

	var extensionVS = "\n";

	var falloffInvSquaredPS = "\nfloat getFalloffWindow(float lightRadius, vec3 lightDir) {\n\tfloat sqrDist = dot(lightDir, lightDir);\n\tfloat invRadius = 1.0 / lightRadius;\n\treturn square( saturate( 1.0 - square( sqrDist * square(invRadius) ) ) );\n}\nfloat getFalloffInvSquared(float lightRadius, vec3 lightDir) {\n\tfloat sqrDist = dot(lightDir, lightDir);\n\tfloat falloff = 1.0 / (sqrDist + 1.0);\n\tfloat invRadius = 1.0 / lightRadius;\n\tfalloff *= 16.0;\n\tfalloff *= square( saturate( 1.0 - square( sqrDist * square(invRadius) ) ) );\n\treturn falloff;\n}\n";

	var falloffLinearPS = "\nfloat getFalloffLinear(float lightRadius, vec3 lightDir) {\n\tfloat d = length(lightDir);\n\treturn max(((lightRadius - d) / lightRadius), 0.0);\n}\n";

	var fixCubemapSeamsNonePS = "\nvec3 fixSeams(vec3 vec, float mipmapIndex) {\n\treturn vec;\n}\nvec3 fixSeams(vec3 vec) {\n\treturn vec;\n}\nvec3 fixSeamsStatic(vec3 vec, float invRecMipSize) {\n\treturn vec;\n}\nvec3 calcSeam(vec3 vec) {\n\treturn vec3(0);\n}\nvec3 applySeam(vec3 vec, vec3 seam, float scale) {\n\treturn vec;\n}\n";

	var fixCubemapSeamsStretchPS = "\nvec3 fixSeams(vec3 vec, float mipmapIndex) {\n\tvec3 avec = abs(vec);\n\tfloat scale = 1.0 - exp2(mipmapIndex) / 128.0;\n\tfloat M = max(max(avec.x, avec.y), avec.z);\n\tif (avec.x != M) vec.x *= scale;\n\tif (avec.y != M) vec.y *= scale;\n\tif (avec.z != M) vec.z *= scale;\n\treturn vec;\n}\nvec3 fixSeams(vec3 vec) {\n\tvec3 avec = abs(vec);\n\tfloat scale = 1.0 - 1.0 / 128.0;\n\tfloat M = max(max(avec.x, avec.y), avec.z);\n\tif (avec.x != M) vec.x *= scale;\n\tif (avec.y != M) vec.y *= scale;\n\tif (avec.z != M) vec.z *= scale;\n\treturn vec;\n}\nvec3 fixSeamsStatic(vec3 vec, float invRecMipSize) {\n\tvec3 avec = abs(vec);\n\tfloat scale = invRecMipSize;\n\tfloat M = max(max(avec.x, avec.y), avec.z);\n\tif (avec.x != M) vec.x *= scale;\n\tif (avec.y != M) vec.y *= scale;\n\tif (avec.z != M) vec.z *= scale;\n\treturn vec;\n}\nvec3 calcSeam(vec3 vec) {\n\tvec3 avec = abs(vec);\n\tfloat M = max(avec.x, max(avec.y, avec.z));\n\treturn vec3(avec.x != M ? 1.0 : 0.0,\n\t\t\t\tavec.y != M ? 1.0 : 0.0,\n\t\t\t\tavec.z != M ? 1.0 : 0.0);\n}\nvec3 applySeam(vec3 vec, vec3 seam, float scale) {\n\treturn vec * (seam * -scale + vec3(1.0));\n}\n";

	var floatUnpackingPS = "\nfloat bytes2float2(vec2 data) {\n\treturn dot(data, vec2(1.0, 1.0 / 255.0));\n}\nfloat bytes2float3(vec3 data) {\n\treturn dot(data, vec3(1.0, 1.0 / 255.0, 1.0 / 65025.0));\n}\nfloat bytes2float4(vec4 data) {\n\treturn dot(data, vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n}\nfloat bytes2floatRange2(vec2 data, float min, float max) {\n\treturn mix(min, max, bytes2float2(data));\n}\nfloat bytes2floatRange3(vec3 data, float min, float max) {\n\treturn mix(min, max, bytes2float3(data));\n}\nfloat bytes2floatRange4(vec4 data, float min, float max) {\n\treturn mix(min, max, bytes2float4(data));\n}\nfloat mantissaExponent2Float(vec4 pack)\n{\n\tfloat value = bytes2floatRange3(pack.xyz, -1.0, 1.0);\n\tfloat exponent = floor(pack.w * 255.0 - 127.0);\n\treturn value * exp2(exponent);\n}\n";

	var fogExpPS = "\nuniform vec3 fog_color;\nuniform float fog_density;\nfloat dBlendModeFogFactor = 1.0;\nvec3 addFog(vec3 color) {\n\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\tfloat fogFactor = exp(-depth * fog_density);\n\tfogFactor = clamp(fogFactor, 0.0, 1.0);\n\treturn mix(fog_color * dBlendModeFogFactor, color, fogFactor);\n}\n";

	var fogExp2PS = "\nuniform vec3 fog_color;\nuniform float fog_density;\nfloat dBlendModeFogFactor = 1.0;\nvec3 addFog(vec3 color) {\n\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\tfloat fogFactor = exp(-depth * depth * fog_density * fog_density);\n\tfogFactor = clamp(fogFactor, 0.0, 1.0);\n\treturn mix(fog_color * dBlendModeFogFactor, color, fogFactor);\n}\n";

	var fogLinearPS = "\nuniform vec3 fog_color;\nuniform float fog_start;\nuniform float fog_end;\nfloat dBlendModeFogFactor = 1.0;\nvec3 addFog(vec3 color) {\n\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\tfloat fogFactor = (fog_end - depth) / (fog_end - fog_start);\n\tfogFactor = clamp(fogFactor, 0.0, 1.0);\n\treturn mix(fog_color * dBlendModeFogFactor, color, fogFactor);\n}\n";

	var fogNonePS = "\nfloat dBlendModeFogFactor = 1.0;\nvec3 addFog(vec3 color) {\n\treturn color;\n}\n";

	var fresnelSchlickPS = "\nvec3 getFresnel(\n\t\tfloat cosTheta, \n\t\tfloat gloss, \n\t\tvec3 specularity\n#if defined(LIT_IRIDESCENCE)\n\t\t, vec3 iridescenceFresnel, \n\t\tfloat iridescenceIntensity\n#endif\n\t) {\n\tfloat fresnel = pow(1.0 - max(cosTheta, 0.0), 5.0);\n\tfloat glossSq = gloss * gloss;\n\tvec3 ret = specularity + (max(vec3(glossSq), specularity) - specularity) * fresnel;\n#if defined(LIT_IRIDESCENCE)\n\treturn mix(ret, iridescenceFresnel, iridescenceIntensity);\n#else\n\treturn ret;\n#endif\t\n}\nfloat getFresnelCC(float cosTheta) {\n\tfloat fresnel = pow(1.0 - max(cosTheta, 0.0), 5.0);\n\treturn 0.04 + (1.0 - 0.04) * fresnel;\n}\n";

	var fullscreenQuadPS = "\nvarying vec2 vUv0;\nuniform sampler2D source;\nvoid main(void) {\n\tgl_FragColor = texture2D(source, vUv0);\n}\n";

	var fullscreenQuadVS = "\nattribute vec2 vertex_position;\nvarying vec2 vUv0;\nvoid main(void)\n{\n\tgl_Position = vec4(vertex_position, 0.5, 1.0);\n\tvUv0 = vertex_position.xy*0.5+0.5;\n}\n";

	var gamma1_0PS = "\nfloat gammaCorrectInput(float color) {\n\treturn color;\n}\nvec3 gammaCorrectInput(vec3 color) {\n\treturn color;\n}\nvec4 gammaCorrectInput(vec4 color) {\n\treturn color;\n}\nvec3 gammaCorrectOutput(vec3 color) {\n\treturn color;\n}\n";

	var gamma2_2PS = "\nfloat gammaCorrectInput(float color) {\n\treturn decodeGamma(color);\n}\nvec3 gammaCorrectInput(vec3 color) {\n\treturn decodeGamma(color);\n}\nvec4 gammaCorrectInput(vec4 color) {\n\treturn vec4(decodeGamma(color.xyz), color.w);\n}\nvec3 gammaCorrectOutput(vec3 color) {\n#ifdef HDR\n\treturn color;\n#else\n\treturn pow(color + 0.0000001, vec3(1.0 / 2.2));\n#endif\n}\n";

	var glossPS = "\n#ifdef MAPFLOAT\nuniform float material_gloss;\n#endif\nvoid getGlossiness() {\n\tdGlossiness = 1.0;\n\t#ifdef MAPFLOAT\n\tdGlossiness *= material_gloss;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tdGlossiness *= texture2DBias($SAMPLER, $UV, textureBias).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tdGlossiness *= saturate(vVertexColor.$VC);\n\t#endif\n\t#ifdef MAPINVERT\n\tdGlossiness = 1.0 - dGlossiness;\n\t#endif\n\tdGlossiness += 0.0000001;\n}\n";

	var iridescenceDiffractionPS = "\nuniform float material_iridescenceRefractionIndex;\n#ifndef PI\n#define PI 3.14159265\n#endif\nfloat iridescence_iorToFresnel(float transmittedIor, float incidentIor) {\n\treturn pow((transmittedIor - incidentIor) / (transmittedIor + incidentIor), 2.0);\n}\nvec3 iridescence_iorToFresnel(vec3 transmittedIor, float incidentIor) {\n\treturn pow((transmittedIor - vec3(incidentIor)) / (transmittedIor + vec3(incidentIor)), vec3(2.0));\n}\nvec3 iridescence_fresnelToIor(vec3 f0) {\n\tvec3 sqrtF0 = sqrt(f0);\n\treturn (vec3(1.0) + sqrtF0) / (vec3(1.0) - sqrtF0);\n}\nvec3 iridescence_sensitivity(float opd, vec3 shift) {\n\tfloat phase = 2.0 * PI * opd * 1.0e-9;\n\tconst vec3 val = vec3(5.4856e-13, 4.4201e-13, 5.2481e-13);\n\tconst vec3 pos = vec3(1.6810e+06, 1.7953e+06, 2.2084e+06);\n\tconst vec3 var = vec3(4.3278e+09, 9.3046e+09, 6.6121e+09);\n\tvec3 xyz = val * sqrt(2.0 * PI * var) * cos(pos * phase + shift) * exp(-pow(phase, 2.0) * var);\n\txyz.x += 9.7470e-14 * sqrt(2.0 * PI * 4.5282e+09) * cos(2.2399e+06 * phase + shift[0]) * exp(-4.5282e+09 * pow(phase, 2.0));\n\txyz /= vec3(1.0685e-07);\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t3.2404542, -0.9692660,  0.0556434,\n\t   -1.5371385,  1.8760108, -0.2040259,\n\t   -0.4985314,  0.0415560,  1.0572252\n\t);\n\treturn XYZ_TO_REC709 * xyz;\n}\nfloat iridescence_fresnel(float cosTheta, float f0) {\n\tfloat x = clamp(1.0 - cosTheta, 0.0, 1.0);\n\tfloat x2 = x * x;\n\tfloat x5 = x * x2 * x2;\n\treturn f0 + (1.0 - f0) * x5;\n} \nvec3 iridescence_fresnel(float cosTheta, vec3 f0) {\n\tfloat x = clamp(1.0 - cosTheta, 0.0, 1.0);\n\tfloat x2 = x * x;\n\tfloat x5 = x * x2 * x2; \n\treturn f0 + (vec3(1.0) - f0) * x5;\n}\nvec3 calcIridescence(float outsideIor, float cosTheta, vec3 base_f0, float iridescenceThickness) {\n\tfloat iridescenceIor = mix(outsideIor, material_iridescenceRefractionIndex, smoothstep(0.0, 0.03, iridescenceThickness));\n\tfloat sinTheta2Sq = pow(outsideIor / iridescenceIor, 2.0) * (1.0 - pow(cosTheta, 2.0));\n\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\tif (cosTheta2Sq < 0.0) {\n\t\treturn vec3(1.0);\n\t}\n\tfloat cosTheta2 = sqrt(cosTheta2Sq);\n\tfloat r0 = iridescence_iorToFresnel(iridescenceIor, outsideIor);\n\tfloat r12 = iridescence_fresnel(cosTheta, r0);\n\tfloat r21 = r12;\n\tfloat t121 = 1.0 - r12;\n\tfloat phi12 = iridescenceIor < outsideIor ? PI : 0.0;\n\tfloat phi21 = PI - phi12;\n\tvec3 baseIor = iridescence_fresnelToIor(base_f0 + vec3(0.0001));\n\tvec3 r1 = iridescence_iorToFresnel(baseIor, iridescenceIor);\n\tvec3 r23 = iridescence_fresnel(cosTheta2, r1);\n\tvec3 phi23 = vec3(0.0);\n\tif (baseIor[0] < iridescenceIor) phi23[0] = PI;\n\tif (baseIor[1] < iridescenceIor) phi23[1] = PI;\n\tif (baseIor[2] < iridescenceIor) phi23[2] = PI;\n\tfloat opd = 2.0 * iridescenceIor * iridescenceThickness * cosTheta2;\n\tvec3 phi = vec3(phi21) + phi23; \n\tvec3 r123Sq = clamp(r12 * r23, 1e-5, 0.9999);\n\tvec3 r123 = sqrt(r123Sq);\n\tvec3 rs = pow(t121, 2.0) * r23 / (1.0 - r123Sq);\n\tvec3 c0 = r12 + rs;\n\tvec3 i = c0;\n\tvec3 cm = rs - t121;\n\tfor (int m = 1; m <= 2; m++) {\n\t\tcm *= r123;\n\t\tvec3 sm = 2.0 * iridescence_sensitivity(float(m) * opd, float(m) * phi);\n\t\ti += cm * sm;\n\t}\n\treturn max(i, vec3(0.0));\n}\nvec3 getIridescence(float cosTheta, vec3 specularity, float iridescenceThickness) {\n\treturn calcIridescence(1.0, cosTheta, specularity, iridescenceThickness);\n}\n";

	var iridescencePS = "\n#ifdef MAPFLOAT\nuniform float material_iridescence;\n#endif\nvoid getIridescence() {\n\tfloat iridescence = 1.0;\n\t#ifdef MAPFLOAT\n\tiridescence *= material_iridescence;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tiridescence *= texture2DBias($SAMPLER, $UV, textureBias).$CH;\n\t#endif\n\tdIridescence = iridescence; \n}\n";

	var iridescenceThicknessPS = "\nuniform float material_iridescenceThicknessMax;\n#ifdef MAPTEXTURE\nuniform float material_iridescenceThicknessMin;\n#endif\nvoid getIridescenceThickness() {\n\t#ifdef MAPTEXTURE\n\tfloat blend = texture2DBias($SAMPLER, $UV, textureBias).$CH;\n\tfloat iridescenceThickness = mix(material_iridescenceThicknessMin, material_iridescenceThicknessMax, blend);\n\t#else\n\tfloat iridescenceThickness = material_iridescenceThicknessMax;\n\t#endif\n\tdIridescenceThickness = iridescenceThickness; \n}\n";

	var instancingVS = "\nattribute vec4 instance_line1;\nattribute vec4 instance_line2;\nattribute vec4 instance_line3;\nattribute vec4 instance_line4;\n";

	var iorPS = "\n#ifdef MAPFLOAT\nuniform float material_refractionIndex;\n#endif\nvoid getIor() {\n#ifdef MAPFLOAT\n\tdIor = material_refractionIndex;\n#else\n\tdIor = 1.0 / 1.5;\n#endif\n}\n";

	var lightDiffuseLambertPS = "\nfloat getLightDiffuse(vec3 worldNormal, vec3 viewDir, vec3 lightDir, vec3 lightDirNorm) {\n\treturn max(dot(worldNormal, -lightDirNorm), 0.0);\n}\n";

	var lightDirPointPS = "\nvoid getLightDirPoint(vec3 lightPosW) {\n\tdLightDirW = vPositionW - lightPosW;\n\tdLightDirNormW = normalize(dLightDirW);\n\tdLightPosW = lightPosW;\n}\n";

	var lightmapAddPS = "\nvoid addLightMap(\n\tvec3 lightmap, \n\tvec3 dir, \n\tvec3 worldNormal, \n\tvec3 viewDir, \n\tvec3 reflectionDir, \n\tfloat gloss, \n\tvec3 specularity, \n\tvec3 vertexNormal, \n\tmat3 tbn\n#if defined(LIT_IRIDESCENCE)\n\tvec3 iridescenceFresnel, \n\tfloat iridescenceIntensity\n#endif\n) {\n\tdDiffuseLight += lightmap;\n}\n";

	var lightmapDirAddPS = "\nvoid addLightMap(\n\tvec3 lightmap, \n\tvec3 dir, \n\tvec3 worldNormal, \n\tvec3 viewDir, \n\tvec3 reflectionDir, \n\tfloat gloss, \n\tvec3 specularity, \n\tvec3 vertexNormal, \n\tmat3 tbn\n#if defined(LIT_IRIDESCENCE)\n\tvec3 iridescenceFresnel, \n\tfloat iridescenceIntensity\n#endif\n) {\n\tif (dot(dir, dir) < 0.0001) {\n\t\tdDiffuseLight += lightmap;\n\t} else {\n\t\tfloat vlight = saturate(dot(dir, -vertexNormal));\n\t\tfloat flight = saturate(dot(dir, -worldNormal));\n\t\tfloat nlight = (flight / max(vlight, 0.01)) * 0.5;\n\t\tdDiffuseLight += lightmap * nlight * 2.0;\n\t\tvec3 halfDir = normalize(-dir + viewDir);\n\t\tvec3 specularLight = lightmap * getLightSpecular(halfDir, reflectionDir, worldNormal, viewDir, dir, gloss, tbn);\n#ifdef LIT_SPECULAR_FRESNEL\n\t\tspecularLight *= \n\t\t\tgetFresnel(dot(viewDir, halfDir), \n\t\t\tgloss, \n\t\t\tspecularity\n\t\t#if defined(LIT_IRIDESCENCE)\n\t\t\t, iridescenceFresnel,\n\t\t\tiridescenceIntensity\n\t\t#endif\n\t\t\t);\n#endif\n\t\tdSpecularLight += specularLight;\n\t}\n}\n";

	var lightmapDirPS = "\nuniform sampler2D texture_lightMap;\nuniform sampler2D texture_dirLightMap;\nvoid getLightMap() {\n\tdLightmap = $DECODE(texture2DBias(texture_lightMap, $UV, textureBias)).$CH;\n\tvec3 dir = texture2DBias(texture_dirLightMap, $UV, textureBias).xyz * 2.0 - 1.0;\n\tfloat dirDot = dot(dir, dir);\n\tdLightmapDir = (dirDot > 0.001) ? dir / sqrt(dirDot) : vec3(0.0);\n}\n";

	var lightmapSinglePS = "\nvoid getLightMap() {\n\tdLightmap = vec3(1.0);\n\t#ifdef MAPTEXTURE\n\tdLightmap *= $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tdLightmap *= saturate(vVertexColor.$VC);\n\t#endif\n}\n";

	var lightSpecularAnisoGGXPS = "\nfloat calcLightSpecular(float gloss, vec3 worldNormal, vec3 viewDir, vec3 h, vec3 lightDirNorm, mat3 tbn) {\n\tfloat PI = 3.141592653589793;\n\tfloat roughness = max((1.0 - gloss) * (1.0 - gloss), 0.001);\n\tfloat anisotropy = material_anisotropy * roughness;\n \n\tfloat at = max((roughness + anisotropy), roughness / 4.0);\n\tfloat ab = max((roughness - anisotropy), roughness / 4.0);\n\tfloat NoH = dot(worldNormal, h);\n\tfloat ToH = dot(tbn[0], h);\n\tfloat BoH = dot(tbn[1], h);\n\tfloat a2 = at * ab;\n\tvec3 v = vec3(ab * ToH, at * BoH, a2 * NoH);\n\tfloat v2 = dot(v, v);\n\tfloat w2 = a2 / v2;\n\tfloat D = a2 * w2 * w2 * (1.0 / PI);\n\tfloat ToV = dot(tbn[0], viewDir);\n\tfloat BoV = dot(tbn[1], viewDir);\n\tfloat ToL = dot(tbn[0], -lightDirNorm);\n\tfloat BoL = dot(tbn[1], -lightDirNorm);\n\tfloat NoV = dot(worldNormal, viewDir);\n\tfloat NoL = dot(worldNormal, -lightDirNorm);\n\tfloat lambdaV = NoL * length(vec3(at * ToV, ab * BoV, NoV));\n\tfloat lambdaL = NoV * length(vec3(at * ToL, ab * BoL, NoL));\n\tfloat G = 0.5 / (lambdaV + lambdaL);\n\treturn D * G;\n}\nfloat getLightSpecular(vec3 h, vec3 reflDir, vec3 worldNormal, vec3 viewDir, vec3 lightDirNorm, float gloss, mat3 tbn) {\n\treturn calcLightSpecular(gloss, worldNormal, viewDir, h, lightDirNorm, tbn);\n}\n";

	var lightSpecularBlinnPS = "\nfloat calcLightSpecular(float gloss, vec3 worldNormal, vec3 h) {\n\tfloat nh = max( dot( h, worldNormal ), 0.0 );\n\tfloat specPow = exp2(gloss * 11.0);\n\tspecPow = max(specPow, 0.0001);\n\treturn pow(nh, specPow) * (specPow + 2.0) / 8.0;\n}\nfloat getLightSpecular(vec3 h, vec3 reflDir, vec3 worldNormal, vec3 viewDir, vec3 lightDirNorm, float gloss, mat3 tbn) {\n\treturn calcLightSpecular(gloss, worldNormal, h);\n}\n";

	var lightSpecularPhongPS = "\nfloat calcLightSpecular(float gloss, vec3 reflDir, vec3 lightDirNorm) {\n\tfloat specPow = gloss;\n\treturn pow(max(dot(reflDir, -lightDirNorm), 0.0), specPow + 0.0001);\n}\nfloat getLightSpecular(vec3 h, vec3 reflDir, vec3 worldNormal, vec3 viewDir, vec3 lightDirNorm, float gloss, mat3 tbn) {\n\treturn calcLightSpecular(gloss, reflDir, lightDirNorm);\n}\n";

	var lightSheenPS = "\nfloat sheenD(vec3 normal, vec3 h, float roughness) {\n\tfloat invR = 1.0 / (roughness * roughness);\n\tfloat cos2h = max(dot(normal, h), 0.0);\n\tcos2h *= cos2h;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\n\treturn (2.0 + invR) * pow(sin2h, invR * 0.5) / (2.0 * PI);\n}\nfloat sheenV(vec3 normal, vec3 viewDir, vec3 light) {\n\tfloat NoV = max(dot(normal, viewDir), 0.000001);\n\tfloat NoL = max(dot(normal, light), 0.000001);\n\treturn 1.0 / (4.0 * (NoL + NoV - NoL * NoV));\n}\nfloat getLightSpecularSheen(vec3 h, vec3 worldNormal, vec3 viewDir, vec3 lightDirNorm, float sheenGloss) {\n\tfloat D = sheenD(worldNormal, h, sheenGloss);\n\tfloat V = sheenV(worldNormal, viewDir, -lightDirNorm);\n\treturn D * V;\n}\n";

	var linearizeDepthPS = "\n#ifndef LINEARIZE_DEPTH\n#define LINEARIZE_DEPTH\nfloat linearizeDepth(float z, vec4 cameraParams) {\n\tif (cameraParams.w == 0.0)\n\t\treturn (cameraParams.z * cameraParams.y) / (cameraParams.y + z * (cameraParams.z - cameraParams.y));\n\telse\n\t\treturn cameraParams.z + z * (cameraParams.y - cameraParams.z);\n}\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params;\n#endif\n#ifdef GL2\nfloat linearizeDepth(float z) {\n\treturn linearizeDepth(z, camera_params);\n}\n#else\n#ifndef UNPACKFLOAT\n#define UNPACKFLOAT\nfloat unpackFloat(vec4 rgbaDepth) {\n\tconst vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n\treturn dot(rgbaDepth, bitShift);\n}\n#endif\n#endif\n#endif\n";

	var litShaderArgsPS = "\nvec3 litArgs_albedo;\nfloat litArgs_opacity;\nvec3 litArgs_emission;\nvec3 litArgs_worldNormal;\nfloat litArgs_ao;\nvec3 litArgs_lightmap;\nvec3 litArgs_lightmapDir;\nfloat litArgs_metalness;\nvec3 litArgs_specularity;\nfloat litArgs_specularityFactor;\nfloat litArgs_gloss;\nfloat litArgs_sheen_gloss;\nvec3 litArgs_sheen_specularity;\nfloat litArgs_transmission;\nfloat litArgs_thickness;\nfloat litArgs_ior;\nfloat litArgs_iridescence_intensity;\nfloat litArgs_iridescence_thickness;\nvec3 litArgs_clearcoat_worldNormal;\nfloat litArgs_clearcoat_specularity;\nfloat litArgs_clearcoat_gloss;\n";

	var ltcPS = "\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nstruct Coords {\n\tvec3 coord0;\n\tvec3 coord1;\n\tvec3 coord2;\n\tvec3 coord3;\n};\nfloat LTC_EvaluateRect( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in Coords rectCoords) {\n\tvec3 v1 = rectCoords.coord1 - rectCoords.coord0;\n\tvec3 v2 = rectCoords.coord3 - rectCoords.coord0;\n\t\n\tvec3 lightNormal = cross( v1, v2 );\n\tfloat factor = sign(-dot( lightNormal, P - rectCoords.coord0 ));\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 =  factor * cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords.coord0 - P );\n\tcoords[ 1 ] = mat * ( rectCoords.coord1 - P );\n\tcoords[ 2 ] = mat * ( rectCoords.coord2 - P );\n\tcoords[ 3 ] = mat * ( rectCoords.coord3 - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn result;\n}\nCoords dLTCCoords;\nCoords getLTCLightCoords(vec3 lightPos, vec3 halfWidth, vec3 halfHeight){\n\tCoords coords;\n\tcoords.coord0 = lightPos + halfWidth - halfHeight;\n\tcoords.coord1 = lightPos - halfWidth - halfHeight;\n\tcoords.coord2 = lightPos - halfWidth + halfHeight;\n\tcoords.coord3 = lightPos + halfWidth + halfHeight;\n\treturn coords;\n}\nfloat dSphereRadius;\nCoords getSphereLightCoords(vec3 lightPos, vec3 halfWidth, vec3 halfHeight){\n\tdSphereRadius = max(length(halfWidth), length(halfHeight));\n\tvec3 f = reflect(normalize(lightPos - view_position), vNormalW);\n\tvec3 w = normalize(cross(f, halfHeight));\n\tvec3 h = normalize(cross(f, w));\n\treturn getLTCLightCoords(lightPos, w * dSphereRadius, h * dSphereRadius);\n}\nvec2 dLTCUV;\n#ifdef LIT_CLEARCOAT\nvec2 ccLTCUV;\n#endif\nvec2 getLTCLightUV(float gloss, vec3 worldNormal, vec3 viewDir)\n{\n\tfloat roughness = max((1.0 - gloss) * (1.0 - gloss), 0.001);\n\treturn LTC_Uv( worldNormal, viewDir, roughness );\n}\nvec3 dLTCSpecFres;\n#ifdef LIT_CLEARCOAT\nvec3 ccLTCSpecFres;\n#endif\nvec3 getLTCLightSpecFres(vec2 uv, vec3 specularity)\n{\n\tvec4 t2 = texture2DLodEXT(areaLightsLutTex2, uv, 0.0);\n\t#ifdef AREA_R8_G8_B8_A8_LUTS\n\tt2 *= vec4(0.693103,1,1,1);\n\tt2 += vec4(0.306897,0,0,0);\n\t#endif\n\treturn specularity * t2.x + ( vec3( 1.0 ) - specularity) * t2.y;\n}\nvoid calcLTCLightValues(float gloss, vec3 worldNormal, vec3 viewDir, vec3 specularity, float clearcoatGloss, vec3 clearcoatWorldNormal, float clearcoatSpecularity)\n{\n\tdLTCUV = getLTCLightUV(gloss, worldNormal, viewDir);\n\tdLTCSpecFres = getLTCLightSpecFres(dLTCUV, specularity); \n#ifdef LIT_CLEARCOAT\n\tccLTCUV = getLTCLightUV(clearcoatGloss, clearcoatWorldNormal, viewDir);\n\tccLTCSpecFres = getLTCLightSpecFres(ccLTCUV, vec3(clearcoatSpecularity));\n#endif\n}\nvoid calcRectLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)\n{\n\tdLTCCoords = getLTCLightCoords(lightPos, halfWidth, halfHeight);\n}\nvoid calcDiskLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)\n{\n\tcalcRectLightValues(lightPos, halfWidth, halfHeight);\n}\nvoid calcSphereLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)\n{\n\tdLTCCoords = getSphereLightCoords(lightPos, halfWidth, halfHeight);\n}\nvec3 SolveCubic(vec4 Coefficient)\n{\n\tfloat pi = 3.14159;\n\tCoefficient.xyz /= Coefficient.w;\n\tCoefficient.yz /= 3.0;\n\tfloat A = Coefficient.w;\n\tfloat B = Coefficient.z;\n\tfloat C = Coefficient.y;\n\tfloat D = Coefficient.x;\n\tvec3 Delta = vec3(\n\t\t-Coefficient.z * Coefficient.z + Coefficient.y,\n\t\t-Coefficient.y * Coefficient.z + Coefficient.x,\n\t\tdot(vec2(Coefficient.z, -Coefficient.y), Coefficient.xy)\n\t);\n\tfloat Discriminant = dot(vec2(4.0 * Delta.x, -Delta.y), Delta.zy);\n\tvec3 RootsA, RootsD;\n\tvec2 xlc, xsc;\n\t{\n\t\tfloat A_a = 1.0;\n\t\tfloat C_a = Delta.x;\n\t\tfloat D_a = -2.0 * B * Delta.x + Delta.y;\n\t\tfloat Theta = atan(sqrt(Discriminant), -D_a) / 3.0;\n\t\tfloat x_1a = 2.0 * sqrt(-C_a) * cos(Theta);\n\t\tfloat x_3a = 2.0 * sqrt(-C_a) * cos(Theta + (2.0 / 3.0) * pi);\n\t\tfloat xl;\n\t\tif ((x_1a + x_3a) > 2.0 * B)\n\t\t\txl = x_1a;\n\t\telse\n\t\t\txl = x_3a;\n\t\txlc = vec2(xl - B, A);\n\t}\n\t{\n\t\tfloat A_d = D;\n\t\tfloat C_d = Delta.z;\n\t\tfloat D_d = -D * Delta.y + 2.0 * C * Delta.z;\n\t\tfloat Theta = atan(D * sqrt(Discriminant), -D_d) / 3.0;\n\t\tfloat x_1d = 2.0 * sqrt(-C_d) * cos(Theta);\n\t\tfloat x_3d = 2.0 * sqrt(-C_d) * cos(Theta + (2.0 / 3.0) * pi);\n\t\tfloat xs;\n\t\tif (x_1d + x_3d < 2.0 * C)\n\t\t\txs = x_1d;\n\t\telse\n\t\t\txs = x_3d;\n\t\txsc = vec2(-D, xs + C);\n\t}\n\tfloat E =  xlc.y * xsc.y;\n\tfloat F = -xlc.x * xsc.y - xlc.y * xsc.x;\n\tfloat G =  xlc.x * xsc.x;\n\tvec2 xmc = vec2(C * F - B * G, -B * F + C * E);\n\tvec3 Root = vec3(xsc.x / xsc.y, xmc.x / xmc.y, xlc.x / xlc.y);\n\tif (Root.x < Root.y && Root.x < Root.z)\n\t\tRoot.xyz = Root.yxz;\n\telse if (Root.z < Root.x && Root.z < Root.y)\n\t\tRoot.xyz = Root.xzy;\n\treturn Root;\n}\nfloat LTC_EvaluateDisk(vec3 N, vec3 V, vec3 P, mat3 Minv, Coords points)\n{\n\tvec3 T1, T2;\n\tT1 = normalize(V - N * dot(V, N));\n\tT2 = cross(N, T1);\n\tmat3 R = transposeMat3( mat3( T1, T2, N ) );\n\tvec3 L_[ 3 ];\n\tL_[ 0 ] = R * ( points.coord0 - P );\n\tL_[ 1 ] = R * ( points.coord1 - P );\n\tL_[ 2 ] = R * ( points.coord2 - P );\n\tvec3 Lo_i = vec3(0);\n\tvec3 C  = 0.5 * (L_[0] + L_[2]);\n\tvec3 V1 = 0.5 * (L_[1] - L_[2]);\n\tvec3 V2 = 0.5 * (L_[1] - L_[0]);\n\tC  = Minv * C;\n\tV1 = Minv * V1;\n\tV2 = Minv * V2;\n\tfloat a, b;\n\tfloat d11 = dot(V1, V1);\n\tfloat d22 = dot(V2, V2);\n\tfloat d12 = dot(V1, V2);\n\tif (abs(d12) / sqrt(d11 * d22) > 0.0001)\n\t{\n\t\tfloat tr = d11 + d22;\n\t\tfloat det = -d12 * d12 + d11 * d22;\n\t\tdet = sqrt(det);\n\t\tfloat u = 0.5 * sqrt(tr - 2.0 * det);\n\t\tfloat v = 0.5 * sqrt(tr + 2.0 * det);\n\t\tfloat e_max = (u + v) * (u + v);\n\t\tfloat e_min = (u - v) * (u - v);\n\t\tvec3 V1_, V2_;\n\t\tif (d11 > d22)\n\t\t{\n\t\t\tV1_ = d12 * V1 + (e_max - d11) * V2;\n\t\t\tV2_ = d12 * V1 + (e_min - d11) * V2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tV1_ = d12*V2 + (e_max - d22)*V1;\n\t\t\tV2_ = d12*V2 + (e_min - d22)*V1;\n\t\t}\n\t\ta = 1.0 / e_max;\n\t\tb = 1.0 / e_min;\n\t\tV1 = normalize(V1_);\n\t\tV2 = normalize(V2_);\n\t}\n\telse\n\t{\n\t\ta = 1.0 / dot(V1, V1);\n\t\tb = 1.0 / dot(V2, V2);\n\t\tV1 *= sqrt(a);\n\t\tV2 *= sqrt(b);\n\t}\n\tvec3 V3 = cross(V1, V2);\n\tif (dot(C, V3) < 0.0)\n\t\tV3 *= -1.0;\n\tfloat L  = dot(V3, C);\n\tfloat x0 = dot(V1, C) / L;\n\tfloat y0 = dot(V2, C) / L;\n\tfloat E1 = inversesqrt(a);\n\tfloat E2 = inversesqrt(b);\n\ta *= L * L;\n\tb *= L * L;\n\tfloat c0 = a * b;\n\tfloat c1 = a * b * (1.0 + x0 * x0 + y0 * y0) - a - b;\n\tfloat c2 = 1.0 - a * (1.0 + x0 * x0) - b * (1.0 + y0 * y0);\n\tfloat c3 = 1.0;\n\tvec3 roots = SolveCubic(vec4(c0, c1, c2, c3));\n\tfloat e1 = roots.x;\n\tfloat e2 = roots.y;\n\tfloat e3 = roots.z;\n\tvec3 avgDir = vec3(a * x0 / (a - e2), b * y0 / (b - e2), 1.0);\n\tmat3 rotate = mat3(V1, V2, V3);\n\tavgDir = rotate * avgDir;\n\tavgDir = normalize(avgDir);\n\tfloat L1 = sqrt(-e2 / e3);\n\tfloat L2 = sqrt(-e2 / e1);\n\tfloat formFactor = L1 * L2 * inversesqrt((1.0 + L1 * L1) * (1.0 + L2 * L2));\n\t\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tvec2 uv = vec2(avgDir.z * 0.5 + 0.5, formFactor);\n\tuv = uv*LUT_SCALE + LUT_BIAS;\n\tfloat scale = texture2DLodEXT(areaLightsLutTex2, uv, 0.0).w;\n\treturn formFactor*scale;\n}\nfloat getRectLightDiffuse(vec3 worldNormal, vec3 viewDir, vec3 lightDir, vec3 lightDirNorm) {\n\treturn LTC_EvaluateRect( worldNormal, viewDir, vPositionW, mat3( 1.0 ), dLTCCoords );\n}\nfloat getDiskLightDiffuse(vec3 worldNormal, vec3 viewDir, vec3 lightDir, vec3 lightDirNorm) {\n\treturn LTC_EvaluateDisk( worldNormal, viewDir, vPositionW, mat3( 1.0 ), dLTCCoords );\n}\nfloat getSphereLightDiffuse(vec3 worldNormal, vec3 viewDir, vec3 lightDir, vec3 lightDirNorm) {\n\tfloat falloff = dSphereRadius / (dot(lightDir, lightDir) + dSphereRadius);\n\treturn getLightDiffuse(worldNormal, viewDir, lightDir, lightDirNorm) * falloff;\n}\nmat3 getLTCLightInvMat(vec2 uv)\n{\n\tvec4 t1 = texture2DLodEXT(areaLightsLutTex1, uv, 0.0);\n\t#ifdef AREA_R8_G8_B8_A8_LUTS\n\tt1 *= vec4(1.001, 0.3239, 0.60437568, 1.0);\n\tt1 += vec4(0.0, -0.2976, -0.01381, 0.0);\n\t#endif\n\treturn mat3(\n\t\tvec3( t1.x, 0, t1.y ),\n\t\tvec3(\t0, 1,\t0 ),\n\t\tvec3( t1.z, 0, t1.w )\n\t);\n}\nfloat calcRectLightSpecular(vec3 worldNormal, vec3 viewDir, vec2 uv) {\n\tmat3 mInv = getLTCLightInvMat(uv);\n\treturn LTC_EvaluateRect( worldNormal, viewDir, vPositionW, mInv, dLTCCoords );\n}\nfloat getRectLightSpecular(vec3 worldNormal, vec3 viewDir) {\n\treturn calcRectLightSpecular(worldNormal, viewDir, dLTCUV);\n}\nfloat calcDiskLightSpecular(vec3 worldNormal, vec3 viewDir, vec2 uv) {\n\tmat3 mInv = getLTCLightInvMat(uv);\n\treturn LTC_EvaluateDisk( worldNormal, viewDir, vPositionW, mInv, dLTCCoords );\n}\nfloat getDiskLightSpecular(vec3 worldNormal, vec3 viewDir) {\n\treturn calcDiskLightSpecular(worldNormal, viewDir, dLTCUV);\n}\nfloat getSphereLightSpecular(vec3 worldNormal, vec3 viewDir) {\n\treturn calcDiskLightSpecular(worldNormal, viewDir, dLTCUV);\n}\n";

	var metalnessPS = "\n#ifdef MAPFLOAT\nuniform float material_metalness;\n#endif\nvoid getMetalness() {\n\tfloat metalness = 1.0;\n\t#ifdef MAPFLOAT\n\tmetalness *= material_metalness;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tmetalness *= texture2DBias($SAMPLER, $UV, textureBias).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tmetalness *= saturate(vVertexColor.$VC);\n\t#endif\n\tdMetalness = metalness;\n}\n";

	var msdfPS = "\nuniform sampler2D texture_msdfMap;\n#ifdef GL_OES_standard_derivatives\n#define USE_FWIDTH\n#endif\n#ifdef GL2\n#define USE_FWIDTH\n#endif\nfloat median(float r, float g, float b) {\n\treturn max(min(r, g), min(max(r, g), b));\n}\nfloat map (float min, float max, float v) {\n\treturn (v - min) / (max - min);\n}\nuniform float font_sdfIntensity;\nuniform float font_pxrange;\nuniform float font_textureWidth;\n#ifdef UNIFORM_TEXT_PARAMETERS\nuniform vec4 outline_color;\nuniform float outline_thickness;\nuniform vec4 shadow_color;\nuniform vec2 shadow_offset;\n#else\nvarying vec4 outline_color;\nvarying float outline_thickness;\nvarying vec4 shadow_color;\nvarying vec2 shadow_offset;\n#endif\nvec4 applyMsdf(vec4 color) {\n\tvec3 tsample = texture2D(texture_msdfMap, vUv0).rgb;\n\tvec2 uvShdw = vUv0 - shadow_offset;\n\tvec3 ssample = texture2D(texture_msdfMap, uvShdw).rgb;\n\tfloat sigDist = median(tsample.r, tsample.g, tsample.b);\n\tfloat sigDistShdw = median(ssample.r, ssample.g, ssample.b);\n\tfloat smoothingMax = 0.2;\n\t#ifdef USE_FWIDTH\n\tvec2 w = fwidth(vUv0);\n\tfloat smoothing = clamp(w.x * font_textureWidth / font_pxrange, 0.0, smoothingMax);\n\t#else\n\tfloat font_size = 16.0;\n\tfloat smoothing = clamp(font_pxrange / font_size, 0.0, smoothingMax);\n\t#endif\n\tfloat mapMin = 0.05;\n\tfloat mapMax = clamp(1.0 - font_sdfIntensity, mapMin, 1.0);\n\tfloat sigDistInner = map(mapMin, mapMax, sigDist);\n\tfloat sigDistOutline = map(mapMin, mapMax, sigDist + outline_thickness);\n\tsigDistShdw = map(mapMin, mapMax, sigDistShdw + outline_thickness);\n\tfloat center = 0.5;\n\tfloat inside = smoothstep(center-smoothing, center+smoothing, sigDistInner);\n\tfloat outline = smoothstep(center-smoothing, center+smoothing, sigDistOutline);\n\tfloat shadow = smoothstep(center-smoothing, center+smoothing, sigDistShdw);\n\tvec4 tcolor = (outline > inside) ? outline * vec4(outline_color.a * outline_color.rgb, outline_color.a) : vec4(0.0);\n\ttcolor = mix(tcolor, color, inside);\n\tvec4 scolor = (shadow > outline) ? shadow * vec4(shadow_color.a * shadow_color.rgb, shadow_color.a) : tcolor;\n\ttcolor = mix(scolor, tcolor, outline);\n\t\n\treturn tcolor;\n}\n";

	var metalnessModulatePS = "\nvec3 getSpecularModulate(in vec3 specularity, in vec3 albedo, in float metalness, in float f0) {\n\tvec3 dielectricF0 = f0 * specularity;\n\treturn mix(dielectricF0, albedo, metalness);\n}\nvec3 getAlbedoModulate(in vec3 albedo, in float metalness) {\n\treturn albedo * (1.0 - metalness);\n}\n";

	var msdfVS = "\nattribute vec3 vertex_outlineParameters;\nattribute vec3 vertex_shadowParameters;\nvarying vec4 outline_color;\nvarying float outline_thickness;\nvarying vec4 shadow_color;\nvarying vec2 shadow_offset;\nvoid unpackMsdfParams() {\n\tvec3 little = mod(vertex_outlineParameters, 256.);\n\tvec3 big = (vertex_outlineParameters - little) / 256.;\n\toutline_color.rb = little.xy / 255.;\n\toutline_color.ga = big.xy / 255.;\n\toutline_thickness = little.z / 255. * 0.2;\n\tlittle = mod(vertex_shadowParameters, 256.);\n\tbig = (vertex_shadowParameters - little) / 256.;\n\tshadow_color.rb = little.xy / 255.;\n\tshadow_color.ga = big.xy / 255.;\n\tshadow_offset = (vec2(little.z, big.z) / 127. - 1.) * 0.005;\n}\n";

	var normalVS = "\n#ifdef MORPHING_TEXTURE_BASED_NORMAL\nuniform highp sampler2D morphNormalTex;\n#endif\nvec3 getNormal() {\n\t#ifdef SKIN\n\tdNormalMatrix = mat3(dModelMatrix[0].xyz, dModelMatrix[1].xyz, dModelMatrix[2].xyz);\n\t#elif defined(INSTANCING)\n\tdNormalMatrix = mat3(instance_line1.xyz, instance_line2.xyz, instance_line3.xyz);\n\t#else\n\tdNormalMatrix = matrix_normal;\n\t#endif\n\tvec3 tempNormal = vertex_normal;\n\t#ifdef MORPHING\n\t#ifdef MORPHING_NRM03\n\ttempNormal += morph_weights_a[0] * morph_nrm0;\n\ttempNormal += morph_weights_a[1] * morph_nrm1;\n\ttempNormal += morph_weights_a[2] * morph_nrm2;\n\ttempNormal += morph_weights_a[3] * morph_nrm3;\n\t#endif\n\t#ifdef MORPHING_NRM47\n\ttempNormal += morph_weights_b[0] * morph_nrm4;\n\ttempNormal += morph_weights_b[1] * morph_nrm5;\n\ttempNormal += morph_weights_b[2] * morph_nrm6;\n\ttempNormal += morph_weights_b[3] * morph_nrm7;\n\t#endif\n\t#endif\n\t#ifdef MORPHING_TEXTURE_BASED_NORMAL\n\t\t#ifdef WEBGPU\n\t\t\tivec2 morphUV = getTextureMorphCoords();\n\t\t\tvec3 morphNormal = texelFetch(morphNormalTex, ivec2(morphUV), 0).xyz;\n\t\t#else\n\t\t\tvec2 morphUV = getTextureMorphCoords();\n\t\t\tvec3 morphNormal = texture2D(morphNormalTex, morphUV).xyz;\n\t\t#endif\n\ttempNormal += morphNormal;\n\t#endif\n\treturn normalize(dNormalMatrix * tempNormal);\n}\n";

	var normalDetailMapPS = "\n#ifdef MAPTEXTURE\nuniform float material_normalDetailMapBumpiness;\nvec3 blendNormals(vec3 n1, vec3 n2) {\n\tn1 += vec3(0, 0, 1);\n\tn2 *= vec3(-1, -1, 1);\n\treturn n1 * dot(n1, n2) / n1.z - n2;\n}\n#endif\nvec3 addNormalDetail(vec3 normalMap) {\n#ifdef MAPTEXTURE\n\tvec3 normalDetailMap = unpackNormal(texture2DBias($SAMPLER, $UV, textureBias));\n\tnormalDetailMap = mix(vec3(0.0, 0.0, 1.0), normalDetailMap, material_normalDetailMapBumpiness);\n\treturn blendNormals(normalMap, normalDetailMap);\n#else\n\treturn normalMap;\n#endif\n}\n";

	var normalInstancedVS = "\nvec3 getNormal() {\n\tdNormalMatrix = mat3(instance_line1.xyz, instance_line2.xyz, instance_line3.xyz);\n\treturn normalize(dNormalMatrix * vertex_normal);\n}\n";

	var normalMapPS = "\n#ifdef MAPTEXTURE\nuniform float material_bumpiness;\n#endif\nvoid getNormal() {\n#ifdef MAPTEXTURE\n\tvec3 normalMap = unpackNormal(texture2DBias($SAMPLER, $UV, textureBias));\n\tnormalMap = mix(vec3(0.0, 0.0, 1.0), normalMap, material_bumpiness);\n\tdNormalW = normalize(dTBN * addNormalDetail(normalMap));\n#else\n\tdNormalW = dVertexNormalW;\n#endif\n}\n";

	var normalSkinnedVS = "\nvec3 getNormal() {\n\tdNormalMatrix = mat3(dModelMatrix[0].xyz, dModelMatrix[1].xyz, dModelMatrix[2].xyz);\n\treturn normalize(dNormalMatrix * vertex_normal);\n}\n";

	var normalXYPS = "\nvec3 unpackNormal(vec4 nmap) {\n\tvec3 normal;\n\tnormal.xy = nmap.wy * 2.0 - 1.0;\n\tnormal.z = sqrt(1.0 - saturate(dot(normal.xy, normal.xy)));\n\treturn normal;\n}\n";

	var normalXYZPS = "\nvec3 unpackNormal(vec4 nmap) {\n\treturn nmap.xyz * 2.0 - 1.0;\n}\n";

	var opacityPS = "\n#ifdef MAPFLOAT\nuniform float material_opacity;\n#endif\nvoid getOpacity() {\n\tdAlpha = 1.0;\n\t#ifdef MAPFLOAT\n\tdAlpha *= material_opacity;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tdAlpha *= texture2DBias($SAMPLER, $UV, textureBias).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tdAlpha *= clamp(vVertexColor.$VC, 0.0, 1.0);\n\t#endif\n}\n";

	var outputPS = "\n";

	var outputAlphaPS = "\ngl_FragColor.a = litArgs_opacity;\n";

	var outputAlphaOpaquePS = "\n\tgl_FragColor.a = 1.0;\n";

	var outputAlphaPremulPS = "\ngl_FragColor.rgb *= litArgs_opacity;\ngl_FragColor.a = litArgs_opacity;\n";

	var outputTex2DPS = "\nvarying vec2 vUv0;\nuniform sampler2D source;\nvoid main(void) {\n\tgl_FragColor = texture2D(source, vUv0);\n}\n";

	var packDepthPS = "\nvec4 packFloat(float depth) {\n\tconst vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);\n\tconst vec4 bit_mask  = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\n\tvec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);\n\tres -= res.xxyz * bit_mask;\n\treturn res;\n}\n";

	var sheenPS = "\n#ifdef MAPCOLOR\nuniform vec3 material_sheen;\n#endif\nvoid getSheen() {\n\tvec3 sheenColor = vec3(1, 1, 1);\n\t#ifdef MAPCOLOR\n\tsheenColor *= material_sheen;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tsheenColor *= $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tsheenColor *= saturate(vVertexColor.$VC);\n\t#endif\n\tsSpecularity = sheenColor;\n}\n";

	var sheenGlossPS = "\n#ifdef MAPFLOAT\nuniform float material_sheenGloss;\n#endif\nvoid getSheenGlossiness() {\n\tfloat sheenGlossiness = 1.0;\n\t#ifdef MAPFLOAT\n\tsheenGlossiness *= material_sheenGloss;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tsheenGlossiness *= texture2DBias($SAMPLER, $UV, textureBias).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tsheenGlossiness *= saturate(vVertexColor.$VC);\n\t#endif\n\t#ifdef MAPINVERT\n\tsheenGlossiness = 1.0 - sheenGlossiness;\n\t#endif\n\tsheenGlossiness += 0.0000001;\n\tsGlossiness = sheenGlossiness;\n}\n";

	var parallaxPS = "\nuniform float material_heightMapFactor;\nvoid getParallax() {\n\tfloat parallaxScale = material_heightMapFactor;\n\tfloat height = texture2DBias($SAMPLER, $UV, textureBias).$CH;\n\theight = height * parallaxScale - parallaxScale*0.5;\n\tvec3 viewDirT = dViewDirW * dTBN;\n\tviewDirT.z += 0.42;\n\tdUvOffset = height * (viewDirT.xy / viewDirT.z);\n}\n";

	var particlePS = "\nvarying vec4 texCoordsAlphaLife;\nuniform sampler2D colorMap;\nuniform sampler2D colorParam;\nuniform float graphSampleSize;\nuniform float graphNumSamples;\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params;\n#endif\nuniform float softening;\nuniform float colorMult;\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\n#ifndef UNPACKFLOAT\n#define UNPACKFLOAT\nfloat unpackFloat(vec4 rgbaDepth) {\n\tconst vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n\tfloat depth = dot(rgbaDepth, bitShift);\n\treturn depth;\n}\n#endif\nvoid main(void) {\n\tvec4 tex  = gammaCorrectInput(texture2D(colorMap, vec2(texCoordsAlphaLife.x, 1.0 - texCoordsAlphaLife.y)));\n\tvec4 ramp = gammaCorrectInput(texture2D(colorParam, vec2(texCoordsAlphaLife.w, 0.0)));\n\tramp.rgb *= colorMult;\n\tramp.a += texCoordsAlphaLife.z;\n\tvec3 rgb = tex.rgb * ramp.rgb;\n\tfloat a  = tex.a * ramp.a;\n";

	var particleVS = "\nvec3 unpack3NFloats(float src) {\n\tfloat r = fract(src);\n\tfloat g = fract(src * 256.0);\n\tfloat b = fract(src * 65536.0);\n\treturn vec3(r, g, b);\n}\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\nvec4 tex1Dlod_lerp(highp sampler2D tex, vec2 tc) {\n\treturn mix( texture2D(tex,tc), texture2D(tex,tc + graphSampleSize), fract(tc.x*graphNumSamples) );\n}\nvec4 tex1Dlod_lerp(highp sampler2D tex, vec2 tc, out vec3 w) {\n\tvec4 a = texture2D(tex,tc);\n\tvec4 b = texture2D(tex,tc + graphSampleSize);\n\tfloat c = fract(tc.x*graphNumSamples);\n\tvec3 unpackedA = unpack3NFloats(a.w);\n\tvec3 unpackedB = unpack3NFloats(b.w);\n\tw = mix(unpackedA, unpackedB, c);\n\treturn mix(a, b, c);\n}\nvec2 rotate(vec2 quadXY, float pRotation, out mat2 rotMatrix) {\n\tfloat c = cos(pRotation);\n\tfloat s = sin(pRotation);\n\tmat2 m = mat2(c, -s, s, c);\n\trotMatrix = m;\n\treturn m * quadXY;\n}\nvec3 billboard(vec3 InstanceCoords, vec2 quadXY) {\n\t#ifdef SCREEN_SPACE\n\t\tvec3 pos = vec3(-1, 0, 0) * quadXY.x + vec3(0, -1, 0) * quadXY.y;\n\t#else\n\t\tvec3 pos = -matrix_viewInverse[0].xyz * quadXY.x + -matrix_viewInverse[1].xyz * quadXY.y;\n\t#endif\n\treturn pos;\n}\nvec3 customFace(vec3 InstanceCoords, vec2 quadXY) {\n\tvec3 pos = faceTangent * quadXY.x + faceBinorm * quadXY.y;\n\treturn pos;\n}\nvec2 safeNormalize(vec2 v) {\n\tfloat l = length(v);\n\treturn (l > 1e-06) ? v / l : v;\n}\nvoid main(void) {\n\tvec3 meshLocalPos = particle_vertexData.xyz;\n\tfloat id = floor(particle_vertexData.w);\n\tfloat rndFactor = fract(sin(id + 1.0 + seed));\n\tvec3 rndFactor3 = vec3(rndFactor, fract(rndFactor*10.0), fract(rndFactor*100.0));\n\tfloat uv = id / numParticlesPot;\n\treadInput(uv);\n#ifdef LOCAL_SPACE\n\tinVel = mat3(matrix_model) * inVel;\n#endif\n\tvec2 velocityV = safeNormalize((mat3(matrix_view) * inVel).xy);\n\tfloat particleLifetime = lifetime;\n\tif (inLife <= 0.0 || inLife > particleLifetime || !inShow) meshLocalPos = vec3(0.0);\n\tvec2 quadXY = meshLocalPos.xy;\n\tfloat nlife = clamp(inLife / particleLifetime, 0.0, 1.0);\n\tvec3 paramDiv;\n\tvec4 params = tex1Dlod_lerp(internalTex2, vec2(nlife, 0), paramDiv);\n\tfloat scale = params.y;\n\tfloat scaleDiv = paramDiv.x;\n\tfloat alphaDiv = paramDiv.z;\n\tscale += (scaleDiv * 2.0 - 1.0) * scaleDivMult * fract(rndFactor*10000.0);\n#ifndef USE_MESH\n\ttexCoordsAlphaLife = vec4(quadXY * -0.5 + 0.5, (alphaDiv * 2.0 - 1.0) * alphaDivMult * fract(rndFactor*1000.0), nlife);\n#else\n\ttexCoordsAlphaLife = vec4(particle_uv, (alphaDiv * 2.0 - 1.0) * alphaDivMult * fract(rndFactor*1000.0), nlife);\n#endif\n\tvec3 particlePos = inPos;\n\tvec3 particlePosMoved = vec3(0.0);\n\tmat2 rotMatrix;\n";

	var particleAnimFrameClampVS = "\n\tfloat animFrame = min(floor(texCoordsAlphaLife.w * animTexParams.y) + animTexParams.x, animTexParams.z);\n";

	var particleAnimFrameLoopVS = "\n\tfloat animFrame = floor(mod(texCoordsAlphaLife.w * animTexParams.y + animTexParams.x, animTexParams.z + 1.0));\n";

	var particleAnimTexVS = "\n\tfloat animationIndex;\n\tif (animTexIndexParams.y == 1.0) {\n\t\tanimationIndex = floor((animTexParams.w + 1.0) * rndFactor3.z) * (animTexParams.z + 1.0);\n\t} else {\n\t\tanimationIndex = animTexIndexParams.x * (animTexParams.z + 1.0);\n\t}\n\tfloat atlasX = (animationIndex + animFrame) * animTexTilesParams.x;\n\tfloat atlasY = 1.0 - floor(atlasX + 1.0) * animTexTilesParams.y;\n\tatlasX = fract(atlasX);\n\ttexCoordsAlphaLife.xy *= animTexTilesParams.xy;\n\ttexCoordsAlphaLife.xy += vec2(atlasX, atlasY);\n";

	var particleInputFloatPS = "\nvoid readInput(float uv) {\n\tvec4 tex = texture2D(particleTexIN, vec2(uv, 0.25));\n\tvec4 tex2 = texture2D(particleTexIN, vec2(uv, 0.75));\n\tinPos = tex.xyz;\n\tinVel = tex2.xyz;\n\tinAngle = (tex.w < 0.0? -tex.w : tex.w) - 1000.0;\n\tinShow = tex.w >= 0.0;\n\tinLife = tex2.w;\n}\n";

	var particleInputRgba8PS = "\n#define PI2 6.283185307179586\nuniform vec3 inBoundsSize;\nuniform vec3 inBoundsCenter;\nuniform float maxVel;\nfloat decodeFloatRG(vec2 rg) {\n\treturn rg.y*(1.0/255.0) + rg.x;\n}\nfloat decodeFloatRGBA( vec4 rgba ) {\n  return dot( rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/160581375.0) );\n}\nvoid readInput(float uv) {\n\tvec4 tex0 = texture2D(particleTexIN, vec2(uv, 0.125));\n\tvec4 tex1 = texture2D(particleTexIN, vec2(uv, 0.375));\n\tvec4 tex2 = texture2D(particleTexIN, vec2(uv, 0.625));\n\tvec4 tex3 = texture2D(particleTexIN, vec2(uv, 0.875));\n\tinPos = vec3(decodeFloatRG(tex0.rg), decodeFloatRG(tex0.ba), decodeFloatRG(tex1.rg));\n\tinPos = (inPos - vec3(0.5)) * inBoundsSize + inBoundsCenter;\n\tinVel = tex2.xyz;\n\tinVel = (inVel - vec3(0.5)) * maxVel;\n\tinAngle = decodeFloatRG(tex1.ba) * PI2;\n\tinShow = tex2.a > 0.5;\n\tinLife = decodeFloatRGBA(tex3);\n\tfloat maxNegLife = max(lifetime, (numParticles - 1.0) * (rate+rateDiv));\n\tfloat maxPosLife = lifetime+1.0;\n\tinLife = inLife * (maxNegLife + maxPosLife) - maxNegLife;\n}\n";

	var particleOutputFloatPS = "\nvoid writeOutput() {\n\tif (gl_FragCoord.y<1.0) {\n\t\tgl_FragColor = vec4(outPos, (outAngle + 1000.0) * visMode);\n\t} else {\n\t\tgl_FragColor = vec4(outVel, outLife);\n\t}\n}\n";

	var particleOutputRgba8PS = "\nuniform vec3 outBoundsMul;\nuniform vec3 outBoundsAdd;\nvec2 encodeFloatRG( float v ) {\n\tvec2 enc = vec2(1.0, 255.0) * v;\n\tenc = fract(enc);\n\tenc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\n\treturn enc;\n}\nvec4 encodeFloatRGBA( float v ) {\n\tvec4 enc = vec4(1.0, 255.0, 65025.0, 160581375.0) * v;\n\tenc = fract(enc);\n\tenc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);\n\treturn enc;\n}\nvoid writeOutput() {\n\toutPos = outPos * outBoundsMul + outBoundsAdd;\n\toutAngle = fract(outAngle / PI2);\n\toutVel = (outVel / maxVel) + vec3(0.5);\n\tfloat maxNegLife = max(lifetime, (numParticles - 1.0) * (rate+rateDiv));\n\tfloat maxPosLife = lifetime+1.0;\n\toutLife = (outLife + maxNegLife) / (maxNegLife + maxPosLife);\n\tif (gl_FragCoord.y < 1.0) {\n\t\tgl_FragColor = vec4(encodeFloatRG(outPos.x), encodeFloatRG(outPos.y));\n\t} else if (gl_FragCoord.y < 2.0) {\n\t\tgl_FragColor = vec4(encodeFloatRG(outPos.z), encodeFloatRG(outAngle));\n\t} else if (gl_FragCoord.y < 3.0) {\n\t\tgl_FragColor = vec4(outVel, visMode*0.5+0.5);\n\t} else {\n\t\tgl_FragColor = encodeFloatRGBA(outLife);\n\t}\n}\n";

	var particleUpdaterAABBPS = "\nuniform mat3 spawnBounds;\nuniform vec3 spawnPosInnerRatio;\nvec3 calcSpawnPosition(vec3 inBounds, float rndFactor) {\n\tvec3 pos = inBounds - vec3(0.5);\n\tvec3 posAbs = abs(pos);\n\tvec3 maxPos = vec3(max(posAbs.x, max(posAbs.y, posAbs.z)));\n\tvec3 edge = maxPos + (vec3(0.5) - maxPos) * spawnPosInnerRatio;\n\tpos.x = edge.x * (maxPos.x == posAbs.x ? sign(pos.x) : 2.0 * pos.x);\n\tpos.y = edge.y * (maxPos.y == posAbs.y ? sign(pos.y) : 2.0 * pos.y);\n\tpos.z = edge.z * (maxPos.z == posAbs.z ? sign(pos.z) : 2.0 * pos.z);\n#ifndef LOCAL_SPACE\n\treturn emitterPos + spawnBounds * pos;\n#else\n\treturn spawnBounds * pos;\n#endif\n}\nvoid addInitialVelocity(inout vec3 localVelocity, vec3 inBounds) {\n\tlocalVelocity -= vec3(0, 0, initialVelocity);\n}\n";

	var particleUpdaterEndPS = "\n\twriteOutput();\n}\n";

	var particleUpdaterInitPS = "\nvarying vec2 vUv0;\nuniform highp sampler2D particleTexIN;\nuniform highp sampler2D internalTex0;\nuniform highp sampler2D internalTex1;\nuniform highp sampler2D internalTex2;\nuniform highp sampler2D internalTex3;\nuniform mat3 emitterMatrix, emitterMatrixInv;\nuniform vec3 emitterScale;\nuniform vec3 emitterPos, frameRandom, localVelocityDivMult, velocityDivMult;\nuniform float delta, rate, rateDiv, lifetime, numParticles, rotSpeedDivMult, radialSpeedDivMult, seed;\nuniform float startAngle, startAngle2;\nuniform float initialVelocity;\nuniform float graphSampleSize;\nuniform float graphNumSamples;\nvec3 inPos;\nvec3 inVel;\nfloat inAngle;\nbool inShow;\nfloat inLife;\nfloat visMode;\nvec3 outPos;\nvec3 outVel;\nfloat outAngle;\nbool outShow;\nfloat outLife;\n";

	var particleUpdaterNoRespawnPS = "\n\tif (outLife >= lifetime) {\n\t\toutLife -= max(lifetime, (numParticles - 1.0) * particleRate);\n\t\tvisMode = -1.0;\n\t}\n";

	var particleUpdaterOnStopPS = "\n\tvisMode = outLife < 0.0? -1.0: visMode;\n";

	var particleUpdaterRespawnPS = "\n\tif (outLife >= lifetime) {\n\t\toutLife -= max(lifetime, (numParticles - 1.0) * particleRate);\n\t\tvisMode = 1.0;\n\t}\n\tvisMode = outLife < 0.0? 1.0: visMode;\n";

	var particleUpdaterSpherePS = "\nuniform float spawnBoundsSphere;\nuniform float spawnBoundsSphereInnerRatio;\nvec3 calcSpawnPosition(vec3 inBounds, float rndFactor) {\n\tfloat rnd4 = fract(rndFactor * 1000.0);\n\tvec3 norm = normalize(inBounds.xyz - vec3(0.5));\n\tfloat r = rnd4 * (1.0 - spawnBoundsSphereInnerRatio) + spawnBoundsSphereInnerRatio;\n#ifndef LOCAL_SPACE\n\treturn emitterPos + norm * r * spawnBoundsSphere;\n#else\n\treturn norm * r * spawnBoundsSphere;\n#endif\n}\nvoid addInitialVelocity(inout vec3 localVelocity, vec3 inBounds) {\n\tlocalVelocity += normalize(inBounds - vec3(0.5)) * initialVelocity;\n}\n";

	var particleUpdaterStartPS = "\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\nvec3 unpack3NFloats(float src) {\n\tfloat r = fract(src);\n\tfloat g = fract(src * 256.0);\n\tfloat b = fract(src * 65536.0);\n\treturn vec3(r, g, b);\n}\nvec3 tex1Dlod_lerp(highp sampler2D tex, vec2 tc, out vec3 w) {\n\tvec4 a = texture2D(tex, tc);\n\tvec4 b = texture2D(tex, tc + graphSampleSize);\n\tfloat c = fract(tc.x * graphNumSamples);\n\tvec3 unpackedA = unpack3NFloats(a.w);\n\tvec3 unpackedB = unpack3NFloats(b.w);\n\tw = mix(unpackedA, unpackedB, c);\n\treturn mix(a.xyz, b.xyz, c);\n}\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\nvec4 hash41(float p) {\n\tvec4 p4 = fract(vec4(p) * HASHSCALE4);\n\tp4 += dot(p4, p4.wzxy+19.19);\n\treturn fract(vec4((p4.x + p4.y)*p4.z, (p4.x + p4.z)*p4.y, (p4.y + p4.z)*p4.w, (p4.z + p4.w)*p4.x));\n}\nvoid main(void) {\n\tif (gl_FragCoord.x > numParticles) discard;\n\treadInput(vUv0.x);\n\tvisMode = inShow? 1.0 : -1.0;\n\tvec4 rndFactor = hash41(gl_FragCoord.x + seed);\n\tfloat particleRate = rate + rateDiv * rndFactor.x;\n\toutLife = inLife + delta;\n\tfloat nlife = clamp(outLife / lifetime, 0.0, 1.0);\n\tvec3 localVelocityDiv;\n\tvec3 velocityDiv;\n\tvec3 paramDiv;\n\tvec3 localVelocity = tex1Dlod_lerp(internalTex0, vec2(nlife, 0), localVelocityDiv);\n\tvec3 velocity =\t  tex1Dlod_lerp(internalTex1, vec2(nlife, 0), velocityDiv);\n\tvec3 params =\t\ttex1Dlod_lerp(internalTex2, vec2(nlife, 0), paramDiv);\n\tfloat rotSpeed = params.x;\n\tfloat rotSpeedDiv = paramDiv.y;\n\tvec3 radialParams = tex1Dlod_lerp(internalTex3, vec2(nlife, 0), paramDiv);\n\tfloat radialSpeed = radialParams.x;\n\tfloat radialSpeedDiv = radialParams.y;\n\tbool respawn = inLife <= 0.0 || outLife >= lifetime;\n\tinPos = respawn ? calcSpawnPosition(rndFactor.xyz, rndFactor.x) : inPos;\n\tinAngle = respawn ? mix(startAngle, startAngle2, rndFactor.x) : inAngle;\n#ifndef LOCAL_SPACE\n\tvec3 radialVel = inPos - emitterPos;\n#else\n\tvec3 radialVel = inPos;\n#endif\n\tradialVel = (dot(radialVel, radialVel) > 1.0E-8) ? radialSpeed * normalize(radialVel) : vec3(0.0);\n\tradialVel += (radialSpeedDiv * vec3(2.0) - vec3(1.0)) * radialSpeedDivMult * rndFactor.xyz;\n\tlocalVelocity +=\t(localVelocityDiv * vec3(2.0) - vec3(1.0)) * localVelocityDivMult * rndFactor.xyz;\n\tvelocity +=\t\t (velocityDiv * vec3(2.0) - vec3(1.0)) * velocityDivMult * rndFactor.xyz;\n\trotSpeed +=\t\t (rotSpeedDiv * 2.0 - 1.0) * rotSpeedDivMult * rndFactor.y;\n\taddInitialVelocity(localVelocity, rndFactor.xyz);\n#ifndef LOCAL_SPACE\n\toutVel = emitterMatrix * localVelocity + (radialVel + velocity) * emitterScale;\n#else\n\toutVel = (localVelocity + radialVel) / emitterScale + emitterMatrixInv * velocity;\n#endif\n\toutPos = inPos + outVel * delta;\n\toutAngle = inAngle + rotSpeed * delta;\n";

	var particle_billboardVS = "\n\tquadXY = rotate(quadXY, inAngle, rotMatrix);\n\tvec3 localPos = billboard(particlePos, quadXY);\n";

	var particle_blendAddPS = "\n\tdBlendModeFogFactor = 0.0;\n\trgb *= saturate(gammaCorrectInput(max(a, 0.0)));\n\tif ((rgb.r + rgb.g + rgb.b) < 0.000001) discard;\n";

	var particle_blendMultiplyPS = "\n\trgb = mix(vec3(1.0), rgb, vec3(a));\n\tif (rgb.r + rgb.g + rgb.b > 2.99) discard;\n";

	var particle_blendNormalPS = "\n\tif (a < 0.01) discard;\n";

	var particle_cpuVS = "\nattribute vec4 particle_vertexData;\nattribute vec4 particle_vertexData2;\nattribute vec4 particle_vertexData3;\nattribute float particle_vertexData4;\n#ifndef USE_MESH\nattribute vec2 particle_vertexData5;\n#else\nattribute vec4 particle_vertexData5;\n#endif\nuniform mat4 matrix_viewProjection;\nuniform mat4 matrix_model;\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform mat3 matrix_normal;\nuniform mat4 matrix_viewInverse;\nuniform float numParticles;\nuniform float lifetime;\nuniform float stretch;\nuniform float seed;\nuniform vec3 wrapBounds;\nuniform vec3 emitterScale;\nuniform vec3 faceTangent;\nuniform vec3 faceBinorm;\nuniform highp sampler2D internalTex0;\nuniform highp sampler2D internalTex1;\nuniform highp sampler2D internalTex2;\nuniform vec3 emitterPos;\nvarying vec4 texCoordsAlphaLife;\nvec2 rotate(vec2 quadXY, float pRotation, out mat2 rotMatrix)\n{\n\tfloat c = cos(pRotation);\n\tfloat s = sin(pRotation);\n\tmat2 m = mat2(c, -s, s, c);\n\trotMatrix = m;\n\treturn m * quadXY;\n}\nvec3 billboard(vec3 InstanceCoords, vec2 quadXY)\n{\n\tvec3 pos = -matrix_viewInverse[0].xyz * quadXY.x + -matrix_viewInverse[1].xyz * quadXY.y;\n\treturn pos;\n}\nvec3 customFace(vec3 InstanceCoords, vec2 quadXY)\n{\n\tvec3 pos = faceTangent * quadXY.x + faceBinorm * quadXY.y;\n\treturn pos;\n}\nvoid main(void)\n{\n\tvec3 particlePos = particle_vertexData.xyz;\n\tvec3 inPos = particlePos;\n\tvec3 vertPos = particle_vertexData3.xyz;\n\tvec3 inVel = vec3(particle_vertexData2.w, particle_vertexData3.w, particle_vertexData5.x);\n\tfloat id = floor(particle_vertexData4);\n\tfloat rndFactor = fract(sin(id + 1.0 + seed));\n\tvec3 rndFactor3 = vec3(rndFactor, fract(rndFactor*10.0), fract(rndFactor*100.0));\n#ifdef LOCAL_SPACE\n\tinVel = mat3(matrix_model) * inVel;\n#endif\n\tvec2 velocityV = normalize((mat3(matrix_view) * inVel).xy);\n\tvec2 quadXY = vertPos.xy;\n#ifdef USE_MESH\n\ttexCoordsAlphaLife = vec4(particle_vertexData5.zw, particle_vertexData2.z, particle_vertexData.w);\n#else\n\ttexCoordsAlphaLife = vec4(quadXY * -0.5 + 0.5, particle_vertexData2.z, particle_vertexData.w);\n#endif\n\tmat2 rotMatrix;\n\tfloat inAngle = particle_vertexData2.x;\n\tvec3 particlePosMoved = vec3(0.0);\n\tvec3 meshLocalPos = particle_vertexData3.xyz;\n";

	var particle_cpu_endVS = "\n\tlocalPos *= particle_vertexData2.y * emitterScale;\n\tlocalPos += particlePos;\n\tgl_Position = matrix_viewProjection * vec4(localPos, 1.0);\n";

	var particle_customFaceVS = "\n\tquadXY = rotate(quadXY, inAngle, rotMatrix);\n\tvec3 localPos = customFace(particlePos, quadXY);\n";

	var particle_endPS = "\n\trgb = addFog(rgb);\n\trgb = toneMap(rgb);\n\trgb = gammaCorrectOutput(rgb);\n\tgl_FragColor = vec4(rgb, a);\n}\n";

	var particle_endVS = "\n\tlocalPos *= scale * emitterScale;\n\tlocalPos += particlePos;\n\t#ifdef SCREEN_SPACE\n\tgl_Position = vec4(localPos.x, localPos.y, 0.0, 1.0);\n\t#else\n\tgl_Position = matrix_viewProjection * vec4(localPos.xyz, 1.0);\n\t#endif\n";

	var particle_halflambertPS = "\n\tvec3 negNormal = normal*0.5+0.5;\n\tvec3 posNormal = -normal*0.5+0.5;\n\tnegNormal *= negNormal;\n\tposNormal *= posNormal;\n";

	var particle_initVS = "\nattribute vec4 particle_vertexData;\n#ifdef USE_MESH\nattribute vec2 particle_uv;\n#endif\nuniform mat4 matrix_viewProjection;\nuniform mat4 matrix_model;\nuniform mat3 matrix_normal;\nuniform mat4 matrix_viewInverse;\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform float numParticles, numParticlesPot;\nuniform float graphSampleSize;\nuniform float graphNumSamples;\nuniform float stretch;\nuniform vec3 wrapBounds;\nuniform vec3 emitterScale, emitterPos, faceTangent, faceBinorm;\nuniform float rate, rateDiv, lifetime, deltaRandomnessStatic, scaleDivMult, alphaDivMult, seed, delta;\nuniform sampler2D particleTexOUT, particleTexIN;\nuniform highp sampler2D internalTex0;\nuniform highp sampler2D internalTex1;\nuniform highp sampler2D internalTex2;\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params;\n#endif\nvarying vec4 texCoordsAlphaLife;\nvec3 inPos;\nvec3 inVel;\nfloat inAngle;\nbool inShow;\nfloat inLife;\n";

	var particle_lambertPS = "\n\tvec3 negNormal = max(normal, vec3(0.0));\n\tvec3 posNormal = max(-normal, vec3(0.0));\n";

	var particle_lightingPS = "\n\tvec3 light = negNormal.x*lightCube[0] + posNormal.x*lightCube[1] +\n\t\t\t\t\t\tnegNormal.y*lightCube[2] + posNormal.y*lightCube[3] +\n\t\t\t\t\t\tnegNormal.z*lightCube[4] + posNormal.z*lightCube[5];\n\trgb *= light;\n";

	var particle_localShiftVS = "\n\tparticlePos = (matrix_model * vec4(particlePos, 1.0)).xyz;\n";

	var particle_meshVS = "\n\tvec3 localPos = meshLocalPos;\n\tlocalPos.xy = rotate(localPos.xy, inAngle, rotMatrix);\n\tlocalPos.yz = rotate(localPos.yz, inAngle, rotMatrix);\n\tbillboard(particlePos, quadXY);\n";

	var particle_normalVS = "\n\tNormal = normalize(localPos + matrix_viewInverse[2].xyz);\n";

	var particle_normalMapPS = "\n\tvec3 normalMap = normalize(texture2D(normalMap, vec2(texCoordsAlphaLife.x, 1.0 - texCoordsAlphaLife.y)).xyz * 2.0 - 1.0);\n\tvec3 normal = ParticleMat * normalMap;\n";

	var particle_pointAlongVS = "\n\tinAngle = atan(velocityV.x, velocityV.y);\n";

	var particle_softPS = "\n\tfloat depth = getLinearScreenDepth();\n\tfloat particleDepth = vDepth;\n\tfloat depthDiff = saturate(abs(particleDepth - depth) * softening);\n\ta *= depthDiff;\n";

	var particle_softVS = "\n\tvDepth = getLinearDepth(localPos);\n";

	var particle_stretchVS = "\n\tvec3 moveDir = inVel * stretch;\n\tvec3 posPrev = particlePos - moveDir;\n\tposPrev += particlePosMoved;\n\tvec2 centerToVertexV = normalize((mat3(matrix_view) * localPos).xy);\n\tfloat interpolation = dot(-velocityV, centerToVertexV) * 0.5 + 0.5;\n\tparticlePos = mix(particlePos, posPrev, interpolation);\n";

	var particle_TBNVS = "\n\tmat3 rot3 = mat3(rotMatrix[0][0], rotMatrix[0][1], 0.0, rotMatrix[1][0], rotMatrix[1][1], 0.0, 0.0, 0.0, 1.0);\n\tParticleMat = mat3(-matrix_viewInverse[0].xyz, -matrix_viewInverse[1].xyz, matrix_viewInverse[2].xyz) * rot3;\n";

	var particle_wrapVS = "\n\tvec3 origParticlePos = particlePos;\n\tparticlePos -= matrix_model[3].xyz;\n\tparticlePos = mod(particlePos, wrapBounds) - wrapBounds * 0.5;\n\tparticlePos += matrix_model[3].xyz;\n\tparticlePosMoved = particlePos - origParticlePos;\n";

	var reflDirPS = "\nvoid getReflDir(vec3 worldNormal, vec3 viewDir, float gloss, mat3 tbn) {\n\tdReflDirW = normalize(-reflect(viewDir, worldNormal));\n}\n";

	var reflDirAnisoPS = "\nvoid getReflDir(vec3 worldNormal, vec3 viewDir, float gloss, mat3 tbn) {\n\tfloat roughness = sqrt(1.0 - min(gloss, 1.0));\n\tfloat anisotropy = material_anisotropy * roughness;\n\tvec3 anisotropicDirection = anisotropy >= 0.0 ? tbn[1] : tbn[0];\n\tvec3 anisotropicTangent = cross(anisotropicDirection, viewDir);\n\tvec3 anisotropicNormal = cross(anisotropicTangent, anisotropicDirection);\n\tvec3 bentNormal = normalize(mix(normalize(worldNormal), normalize(anisotropicNormal), anisotropy));\n\tdReflDirW = reflect(-viewDir, bentNormal);\n}\n";

	var reflectionCCPS = "\n#ifdef LIT_CLEARCOAT\nvoid addReflectionCC(vec3 reflDir, float gloss) {\n\tccReflection += calcReflection(reflDir, gloss);\n}\n#endif\n";

	var reflectionCubePS = "\nuniform samplerCube texture_cubeMap;\nuniform float material_reflectivity;\nvec3 calcReflection(vec3 reflDir, float gloss) {\n\tvec3 lookupVec = fixSeams(cubeMapProject(reflDir));\n\tlookupVec.x *= -1.0;\n\treturn $DECODE(textureCube(texture_cubeMap, lookupVec));\n}\nvoid addReflection(vec3 reflDir, float gloss) {   \n\tdReflection += vec4(calcReflection(reflDir, gloss), material_reflectivity);\n}\n";

	var reflectionEnvHQPS = "\n#ifndef ENV_ATLAS\n#define ENV_ATLAS\nuniform sampler2D texture_envAtlas;\n#endif\nuniform samplerCube texture_cubeMap;\nuniform float material_reflectivity;\nvec3 calcReflection(vec3 reflDir, float gloss) {\n\tvec3 dir = cubeMapProject(reflDir) * vec3(-1.0, 1.0, 1.0);\n\tvec2 uv = toSphericalUv(dir);\n\tfloat level = saturate(1.0 - gloss) * 5.0;\n\tfloat ilevel = floor(level);\n\tfloat flevel = level - ilevel;\n\tvec3 sharp = $DECODE_CUBEMAP(textureCube(texture_cubeMap, fixSeams(dir)));\n\tvec3 roughA = $DECODE(texture2D(texture_envAtlas, mapRoughnessUv(uv, ilevel)));\n\tvec3 roughB = $DECODE(texture2D(texture_envAtlas, mapRoughnessUv(uv, ilevel + 1.0)));\n\treturn processEnvironment(mix(sharp, mix(roughA, roughB, flevel), min(level, 1.0)));\n}\nvoid addReflection(vec3 reflDir, float gloss) {   \n\tdReflection += vec4(calcReflection(reflDir, gloss), material_reflectivity);\n}\n";

	var reflectionEnvPS = "\n#ifndef ENV_ATLAS\n#define ENV_ATLAS\nuniform sampler2D texture_envAtlas;\n#endif\nuniform float material_reflectivity;\nfloat shinyMipLevel(vec2 uv) {\n\tvec2 dx = dFdx(uv);\n\tvec2 dy = dFdy(uv);\n\tvec2 uv2 = vec2(fract(uv.x + 0.5), uv.y);\n\tvec2 dx2 = dFdx(uv2);\n\tvec2 dy2 = dFdy(uv2);\n\tfloat maxd = min(max(dot(dx, dx), dot(dy, dy)), max(dot(dx2, dx2), dot(dy2, dy2)));\n\treturn clamp(0.5 * log2(maxd) - 1.0 + textureBias, 0.0, 5.0);\n}\nvec3 calcReflection(vec3 reflDir, float gloss) {\n\tvec3 dir = cubeMapProject(reflDir) * vec3(-1.0, 1.0, 1.0);\n\tvec2 uv = toSphericalUv(dir);\n\tfloat level = saturate(1.0 - gloss) * 5.0;\n\tfloat ilevel = floor(level);\n\tfloat level2 = shinyMipLevel(uv * atlasSize);\n\tfloat ilevel2 = floor(level2);\n\tvec2 uv0, uv1;\n\tfloat weight;\n\tif (ilevel == 0.0) {\n\t\tuv0 = mapShinyUv(uv, ilevel2);\n\t\tuv1 = mapShinyUv(uv, ilevel2 + 1.0);\n\t\tweight = level2 - ilevel2;\n\t} else {\n\t\tuv0 = uv1 = mapRoughnessUv(uv, ilevel);\n\t\tweight = 0.0;\n\t}\n\tvec3 linearA = $DECODE(texture2D(texture_envAtlas, uv0));\n\tvec3 linearB = $DECODE(texture2D(texture_envAtlas, uv1));\n\tvec3 linear0 = mix(linearA, linearB, weight);\n\tvec3 linear1 = $DECODE(texture2D(texture_envAtlas, mapRoughnessUv(uv, ilevel + 1.0)));\n\treturn processEnvironment(mix(linear0, linear1, level - ilevel));\n}\nvoid addReflection(vec3 reflDir, float gloss) {   \n\tdReflection += vec4(calcReflection(reflDir, gloss), material_reflectivity);\n}\n";

	var reflectionSpherePS = "\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform sampler2D texture_sphereMap;\nuniform float material_reflectivity;\nvec3 calcReflection(vec3 reflDir, float gloss) {\n\tvec3 reflDirV = (mat3(matrix_view) * reflDir).xyz;\n\tfloat m = 2.0 * sqrt( dot(reflDirV.xy, reflDirV.xy) + (reflDirV.z+1.0)*(reflDirV.z+1.0) );\n\tvec2 sphereMapUv = reflDirV.xy / m + 0.5;\n\treturn $DECODE(texture2D(texture_sphereMap, sphereMapUv));\n}\nvoid addReflection(vec3 reflDir, float gloss) {   \n\tdReflection += vec4(calcReflection(reflDir, gloss), material_reflectivity);\n}\n";

	var reflectionSphereLowPS = "\nuniform sampler2D texture_sphereMap;\nuniform float material_reflectivity;\nvec3 calcReflection(vec3 reflDir, float gloss) {\n\tvec3 reflDirV = vNormalV;\n\tvec2 sphereMapUv = reflDirV.xy * 0.5 + 0.5;\n\treturn $DECODE(texture2D(texture_sphereMap, sphereMapUv));\n}\nvoid addReflection(vec3 reflDir, float gloss) {   \n\tdReflection += vec4(calcReflection(reflDir, gloss), material_reflectivity);\n}\n";

	var reflectionSheenPS = "\nvoid addReflectionSheen(vec3 worldNormal, vec3 viewDir, float gloss) {\n\tfloat NoV = dot(worldNormal, viewDir);\n\tfloat alphaG = gloss * gloss;\n\tfloat a = gloss < 0.25 ? -339.2 * alphaG + 161.4 * gloss - 25.9 : -8.48 * alphaG + 14.3 * gloss - 9.95;\n\tfloat b = gloss < 0.25 ? 44.0 * alphaG - 23.7 * gloss + 3.26 : 1.97 * alphaG - 3.27 * gloss + 0.72;\n\tfloat DG = exp( a * NoV + b ) + ( gloss < 0.25 ? 0.0 : 0.1 * ( gloss - 0.25 ) );\n\tsReflection += calcReflection(worldNormal, 0.0) * saturate(DG);\n}\n";

	var refractionCubePS = "\nvec3 refract2(vec3 viewVec, vec3 normal, float IOR) {\n\tfloat vn = dot(viewVec, normal);\n\tfloat k = 1.0 - IOR * IOR * (1.0 - vn * vn);\n\tvec3 refrVec = IOR * viewVec - (IOR * vn + sqrt(k)) * normal;\n\treturn refrVec;\n}\nvoid addRefraction(\n\tvec3 worldNormal, \n\tvec3 viewDir, \n\tfloat thickness, \n\tfloat gloss, \n\tvec3 specularity, \n\tvec3 albedo, \n\tfloat transmission,\n\tfloat refractionIndex\n#if defined(LIT_IRIDESCENCE)\n\t, vec3 iridescenceFresnel,\n\tfloat iridescenceIntensity\n#endif \n) {\n\tvec4 tmpRefl = dReflection;\n\tvec3 reflectionDir = refract2(-viewDir, worldNormal, refractionIndex);\n\tdReflection = vec4(0);\n\taddReflection(reflectionDir, gloss);\n\tdDiffuseLight = mix(dDiffuseLight, dReflection.rgb * albedo, transmission);\n\tdReflection = tmpRefl;\n}\n";

	var refractionDynamicPS = "\nuniform float material_invAttenuationDistance;\nuniform vec3 material_attenuation;\nvoid addRefraction(\n\tvec3 worldNormal, \n\tvec3 viewDir, \n\tfloat thickness, \n\tfloat gloss, \n\tvec3 specularity, \n\tvec3 albedo, \n\tfloat transmission,\n\tfloat refractionIndex\n#if defined(LIT_IRIDESCENCE)\n\t, vec3 iridescenceFresnel,\n\tfloat iridescenceIntensity\n#endif\n) {\n\tvec3 modelScale;\n\tmodelScale.x = length(vec3(matrix_model[0].xyz));\n\tmodelScale.y = length(vec3(matrix_model[1].xyz));\n\tmodelScale.z = length(vec3(matrix_model[2].xyz));\n\tvec3 refractionVector = normalize(refract(-viewDir, worldNormal, refractionIndex)) * thickness * modelScale;\n\tvec4 pointOfRefraction = vec4(vPositionW + refractionVector, 1.0);\n\tvec4 projectionPoint = matrix_viewProjection * pointOfRefraction;\n\tvec2 uv = getGrabScreenPos(projectionPoint);\n\t#ifdef SUPPORTS_TEXLOD\n\t\tfloat iorToRoughness = (1.0 - gloss) * clamp((1.0 / refractionIndex) * 2.0 - 2.0, 0.0, 1.0);\n\t\tfloat refractionLod = log2(uScreenSize.x) * iorToRoughness;\n\t\tvec3 refraction = texture2DLodEXT(uSceneColorMap, uv, refractionLod).rgb;\n\t#else\n\t\tvec3 refraction = texture2D(uSceneColorMap, uv).rgb;\n\t#endif\n\tvec3 transmittance;\n\tif (material_invAttenuationDistance != 0.0)\n\t{\n\t\tvec3 attenuation = -log(material_attenuation) * material_invAttenuationDistance;\n\t\ttransmittance = exp(-attenuation * length(refractionVector));\n\t}\n\telse\n\t{\n\t\ttransmittance = refraction;\n\t}\n\tvec3 fresnel = vec3(1.0) - \n\t\tgetFresnel(\n\t\t\tdot(viewDir, worldNormal), \n\t\t\tgloss, \n\t\t\tspecularity\n\t\t#if defined(LIT_IRIDESCENCE)\n\t\t\t, iridescenceFresnel,\n\t\t\tiridescenceIntensity\n\t\t#endif\n\t\t);\n\tdDiffuseLight = mix(dDiffuseLight, refraction * transmittance * fresnel, transmission);\n}\n";

	var reprojectPS = "\nvarying vec2 vUv0;\n#ifdef CUBEMAP_SOURCE\n\tuniform samplerCube sourceCube;\n#else\n\tuniform sampler2D sourceTex;\n#endif\n#ifdef USE_SAMPLES_TEX\n\tuniform sampler2D samplesTex;\n\tuniform vec2 samplesTexInverseSize;\n#endif\nuniform vec4 params;\nuniform vec2 params2;\nfloat targetFace() { return params.x; }\nfloat specularPower() { return params.y; }\nfloat sourceCubeSeamScale() { return params.z; }\nfloat targetCubeSeamScale() { return params.w; }\nfloat targetTotalPixels() { return params2.x; }\nfloat sourceTotalPixels() { return params2.y; }\nfloat PI = 3.141592653589793;\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\n" + decodePS + "\n" + encodePS + "\nvec3 modifySeams(vec3 dir, float scale) {\n\tvec3 adir = abs(dir);\n\tfloat M = max(max(adir.x, adir.y), adir.z);\n\treturn dir / M * vec3(\n\t\tadir.x == M ? 1.0 : scale,\n\t\tadir.y == M ? 1.0 : scale,\n\t\tadir.z == M ? 1.0 : scale\n\t);\n}\nvec2 toSpherical(vec3 dir) {\n\treturn vec2(dir.xz == vec2(0.0) ? 0.0 : atan(dir.x, dir.z), asin(dir.y));\n}\nvec3 fromSpherical(vec2 uv) {\n\treturn vec3(cos(uv.y) * sin(uv.x),\n\t\t\t\tsin(uv.y),\n\t\t\t\tcos(uv.y) * cos(uv.x));\n}\nvec3 getDirectionEquirect() {\n\treturn fromSpherical((vec2(vUv0.x, 1.0 - vUv0.y) * 2.0 - 1.0) * vec2(PI, PI * 0.5));\n}\nfloat signNotZero(float k){\n\treturn(k >= 0.0) ? 1.0 : -1.0;\n}\nvec2 signNotZero(vec2 v) {\n\treturn vec2(signNotZero(v.x), signNotZero(v.y));\n}\nvec3 octDecode(vec2 o) {\n\tvec3 v = vec3(o.x, 1.0 - abs(o.x) - abs(o.y), o.y);\n\tif (v.y < 0.0) {\n\t\tv.xz = (1.0 - abs(v.zx)) * signNotZero(v.xz);\n\t}\n\treturn normalize(v);\n}\nvec3 getDirectionOctahedral() {\n\treturn octDecode(vec2(vUv0.x, 1.0 - vUv0.y) * 2.0 - 1.0);\n}\nvec2 octEncode(in vec3 v) {\n\tfloat l1norm = abs(v.x) + abs(v.y) + abs(v.z);\n\tvec2 result = v.xz * (1.0 / l1norm);\n\tif (v.y < 0.0) {\n\t\tresult = (1.0 - abs(result.yx)) * signNotZero(result.xy);\n\t}\n\treturn result;\n}\n#ifdef CUBEMAP_SOURCE\n\tvec4 sampleCubemap(vec3 dir) {\n\t\treturn textureCube(sourceCube, modifySeams(dir, 1.0 - sourceCubeSeamScale()));\n\t}\n\tvec4 sampleCubemap(vec2 sph) {\n\treturn sampleCubemap(fromSpherical(sph));\n}\n\tvec4 sampleCubemap(vec3 dir, float mipLevel) {\n\t\treturn textureCubeLodEXT(sourceCube, modifySeams(dir, 1.0 - exp2(mipLevel) * sourceCubeSeamScale()), mipLevel);\n\t}\n\tvec4 sampleCubemap(vec2 sph, float mipLevel) {\n\t\treturn sampleCubemap(fromSpherical(sph), mipLevel);\n\t}\n#else\n\tvec4 sampleEquirect(vec2 sph) {\n\t\tvec2 uv = sph / vec2(PI * 2.0, PI) + 0.5;\n\t\treturn texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));\n\t}\n\tvec4 sampleEquirect(vec3 dir) {\n\t\treturn sampleEquirect(toSpherical(dir));\n\t}\n\tvec4 sampleEquirect(vec2 sph, float mipLevel) {\n\t\tvec2 uv = sph / vec2(PI * 2.0, PI) + 0.5;\n\t\treturn texture2DLodEXT(sourceTex, vec2(uv.x, 1.0 - uv.y), mipLevel);\n\t}\n\tvec4 sampleEquirect(vec3 dir, float mipLevel) {\n\t\treturn sampleEquirect(toSpherical(dir), mipLevel);\n\t}\n\tvec4 sampleOctahedral(vec3 dir) {\n\t\tvec2 uv = octEncode(dir) * 0.5 + 0.5;\n\t\treturn texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));\n\t}\n\tvec4 sampleOctahedral(vec2 sph) {\n\t\treturn sampleOctahedral(fromSpherical(sph));\n\t}\n\tvec4 sampleOctahedral(vec3 dir, float mipLevel) {\n\t\tvec2 uv = octEncode(dir) * 0.5 + 0.5;\n\t\treturn texture2DLodEXT(sourceTex, vec2(uv.x, 1.0 - uv.y), mipLevel);\n\t}\n\tvec4 sampleOctahedral(vec2 sph, float mipLevel) {\n\t\treturn sampleOctahedral(fromSpherical(sph), mipLevel);\n\t}\n#endif\nvec3 getDirectionCubemap() {\n\tvec2 st = vUv0 * 2.0 - 1.0;\n\tfloat face = targetFace();\n\tvec3 vec;\n\tif (face == 0.0) {\n\t\tvec = vec3(1, -st.y, -st.x);\n\t} else if (face == 1.0) {\n\t\tvec = vec3(-1, -st.y, st.x);\n\t} else if (face == 2.0) {\n\t\tvec = vec3(st.x, 1, st.y);\n\t} else if (face == 3.0) {\n\t\tvec = vec3(st.x, -1, -st.y);\n\t} else if (face == 4.0) {\n\t\tvec = vec3(st.x, -st.y, 1);\n\t} else {\n\t\tvec = vec3(-st.x, -st.y, -1);\n\t}\n\treturn normalize(modifySeams(vec, 1.0 / (1.0 - targetCubeSeamScale())));\n}\nmat3 matrixFromVector(vec3 n) {\n\tfloat a = 1.0 / (1.0 + n.z);\n\tfloat b = -n.x * n.y * a;\n\tvec3 b1 = vec3(1.0 - n.x * n.x * a, b, -n.x);\n\tvec3 b2 = vec3(b, 1.0 - n.y * n.y * a, -n.y);\n\treturn mat3(b1, b2, n);\n}\nmat3 matrixFromVectorSlow(vec3 n) {\n\tvec3 up = (1.0 - abs(n.y) <= 0.0000001) ? vec3(0.0, 0.0, n.y > 0.0 ? 1.0 : -1.0) : vec3(0.0, 1.0, 0.0);\n\tvec3 x = normalize(cross(up, n));\n\tvec3 y = cross(n, x);\n\treturn mat3(x, y, n);\n}\nvec4 reproject() {\n\tif (NUM_SAMPLES <= 1) {\n\t\treturn ENCODE_FUNC(DECODE_FUNC(SOURCE_FUNC(TARGET_FUNC())));\n\t} else {\n\t\tvec3 t = TARGET_FUNC();\n\t\tvec3 tu = dFdx(t);\n\t\tvec3 tv = dFdy(t);\n\t\tvec3 result = vec3(0.0);\n\t\tfor (float u = 0.0; u < NUM_SAMPLES_SQRT; ++u) {\n\t\t\tfor (float v = 0.0; v < NUM_SAMPLES_SQRT; ++v) {\n\t\t\t\tresult += DECODE_FUNC(SOURCE_FUNC(normalize(t +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttu * (u / NUM_SAMPLES_SQRT - 0.5) +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttv * (v / NUM_SAMPLES_SQRT - 0.5))));\n\t\t\t}\n\t\t}\n\t\treturn ENCODE_FUNC(result / (NUM_SAMPLES_SQRT * NUM_SAMPLES_SQRT));\n\t}\n}\nvec4 unpackFloat = vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0);\n#ifdef USE_SAMPLES_TEX\n\tvoid unpackSample(int i, out vec3 L, out float mipLevel) {\n\t\tfloat u = (float(i * 4) + 0.5) * samplesTexInverseSize.x;\n\t\tfloat v = (floor(u) + 0.5) * samplesTexInverseSize.y;\n\t\tvec4 raw;\n\t\traw.x = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;\n\t\traw.y = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;\n\t\traw.z = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;\n\t\traw.w = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat);\n\t\tL.xyz = raw.xyz * 2.0 - 1.0;\n\t\tmipLevel = raw.w * 8.0;\n\t}\n\tvec4 prefilterSamples() {\n\t\tmat3 vecSpace = matrixFromVectorSlow(TARGET_FUNC());\n\t\tvec3 L;\n\t\tfloat mipLevel;\n\t\tvec3 result = vec3(0.0);\n\t\tfloat totalWeight = 0.0;\n\t\tfor (int i = 0; i < NUM_SAMPLES; ++i) {\n\t\t\tunpackSample(i, L, mipLevel);\n\t\t\tresult += DECODE_FUNC(SOURCE_FUNC(vecSpace * L, mipLevel)) * L.z;\n\t\t\ttotalWeight += L.z;\n\t\t}\n\t\treturn ENCODE_FUNC(result / totalWeight);\n\t}\n\tvec4 prefilterSamplesUnweighted() {\n\t\tmat3 vecSpace = matrixFromVectorSlow(TARGET_FUNC());\n\t\tvec3 L;\n\t\tfloat mipLevel;\n\t\tvec3 result = vec3(0.0);\n\t\tfloat totalWeight = 0.0;\n\t\tfor (int i = 0; i < NUM_SAMPLES; ++i) {\n\t\t\tunpackSample(i, L, mipLevel);\n\t\t\tresult += DECODE_FUNC(SOURCE_FUNC(vecSpace * L, mipLevel));\n\t\t}\n\t\treturn ENCODE_FUNC(result / float(NUM_SAMPLES));\n\t}\n#endif\nvoid main(void) {\n\tgl_FragColor = PROCESS_FUNC();\n}\n";

	var screenDepthPS = "\nuniform highp sampler2D uSceneDepthMap;\n#ifndef SCREENSIZE\n#define SCREENSIZE\nuniform vec4 uScreenSize;\n#endif\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\n#ifndef LINEARIZE_DEPTH\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params;\n#endif\n#define LINEARIZE_DEPTH\n#ifdef GL2\nfloat linearizeDepth(float z) {\n\tif (camera_params.w == 0.0)\n\t\treturn (camera_params.z * camera_params.y) / (camera_params.y + z * (camera_params.z - camera_params.y));\n\telse\n\t\treturn camera_params.z + z * (camera_params.y - camera_params.z);\n}\n#else\n#ifndef UNPACKFLOAT\n#define UNPACKFLOAT\nfloat unpackFloat(vec4 rgbaDepth) {\n\tconst vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n\treturn dot(rgbaDepth, bitShift);\n}\n#endif\n#endif\n#endif\nfloat getLinearScreenDepth(vec2 uv) {\n\t#ifdef GL2\n\t\treturn linearizeDepth(texture2D(uSceneDepthMap, uv).r);\n\t#else\n\t\treturn unpackFloat(texture2D(uSceneDepthMap, uv)) * camera_params.y;\n\t#endif\n}\n#ifndef VERTEXSHADER\nfloat getLinearScreenDepth() {\n\tvec2 uv = gl_FragCoord.xy * uScreenSize.zw;\n\treturn getLinearScreenDepth(uv);\n}\n#endif\nfloat getLinearDepth(vec3 pos) {\n\treturn -(matrix_view * vec4(pos, 1.0)).z;\n}\n";

	var shadowCascadesPS = "\nconst float maxCascades = 4.0;\nmat4 cascadeShadowMat;\nvoid getShadowCascadeMatrix(mat4 shadowMatrixPalette[4], float shadowCascadeDistances[4], float shadowCascadeCount) {\n\tfloat depth = 1.0 / gl_FragCoord.w;\n\tfloat cascadeIndex = 0.0;\n\tfor (float i = 0.0; i < maxCascades; i++) {\n\t\tif (depth < shadowCascadeDistances[int(i)]) {\n\t\t\tcascadeIndex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcascadeIndex = min(cascadeIndex, shadowCascadeCount - 1.0);\n\t#ifdef GL2\n\t\tcascadeShadowMat = shadowMatrixPalette[int(cascadeIndex)];\n\t#else\n\t\tif (cascadeIndex == 0.0) {\n\t\t\tcascadeShadowMat = shadowMatrixPalette[0];\n\t\t}\n\t\telse if (cascadeIndex == 1.0) {\n\t\t\tcascadeShadowMat = shadowMatrixPalette[1];\n\t\t}\n\t\telse if (cascadeIndex == 2.0) {\n\t\t\tcascadeShadowMat = shadowMatrixPalette[2];\n\t\t}\n\t\telse {\n\t\t\tcascadeShadowMat = shadowMatrixPalette[3];\n\t\t}\n\t#endif\n}\nvoid fadeShadow(float shadowCascadeDistances[4]) {\t\t\t\t  \n\tfloat depth = 1.0 / gl_FragCoord.w;\n\tif (depth > shadowCascadeDistances[int(maxCascades - 1.0)]) {\n\t\tdShadowCoord.z = -9999999.0;\n\t}\n}\n";

	var shadowEVSMPS = "\nfloat VSM$(sampler2D tex, vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {\n\tvec3 moments = texture2D(tex, texCoords).xyz;\n\treturn calculateEVSM(moments, Z, vsmBias, exponent);\n}\nfloat getShadowVSM$(sampler2D shadowMap, vec3 shadowCoord, vec4 shadowParams, float exponent, vec3 lightDir) {\n\treturn VSM$(shadowMap, shadowCoord.xy, shadowParams.x, shadowCoord.z, shadowParams.y, exponent);\n}\nfloat getShadowSpotVSM$(sampler2D shadowMap, vec3 shadowCoord, vec4 shadowParams, float exponent, vec3 lightDir) {\n\treturn VSM$(shadowMap, shadowCoord.xy, shadowParams.x, length(lightDir) * shadowParams.w + shadowParams.z, shadowParams.y, exponent);\n}\n";

	var shadowEVSMnPS = "\nfloat VSM$(TEXTURE_ACCEPT(tex), vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {\n\tfloat pixelSize = 1.0 / resolution;\n\ttexCoords -= vec2(pixelSize);\n\tvec3 s00 = texture2D(tex, texCoords).xyz;\n\tvec3 s10 = texture2D(tex, texCoords + vec2(pixelSize, 0)).xyz;\n\tvec3 s01 = texture2D(tex, texCoords + vec2(0, pixelSize)).xyz;\n\tvec3 s11 = texture2D(tex, texCoords + vec2(pixelSize)).xyz;\n\tvec2 fr = fract(texCoords * resolution);\n\tvec3 h0 = mix(s00, s10, fr.x);\n\tvec3 h1 = mix(s01, s11, fr.x);\n\tvec3 moments = mix(h0, h1, fr.y);\n\treturn calculateEVSM(moments, Z, vsmBias, exponent);\n}\nfloat getShadowVSM$(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, float exponent, vec3 lightDir) {\n\treturn VSM$(TEXTURE_PASS(shadowMap), shadowCoord.xy, shadowParams.x, shadowCoord.z, shadowParams.y, exponent);\n}\nfloat getShadowSpotVSM$(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, float exponent, vec3 lightDir) {\n\treturn VSM$(TEXTURE_PASS(shadowMap), shadowCoord.xy, shadowParams.x, length(lightDir) * shadowParams.w + shadowParams.z, shadowParams.y, exponent);\n}\n";

	var shadowPCSSPS = "\n#define PCSS_SAMPLE_COUNT 16\nuniform float pcssDiskSamples[PCSS_SAMPLE_COUNT];\nuniform float pcssSphereSamples[PCSS_SAMPLE_COUNT];\nvec2 vogelDisk(int sampleIndex, float count, float phi, float r) {\n\tconst float GoldenAngle = 2.4;\n\tfloat theta = float(sampleIndex) * GoldenAngle + phi;\n\tfloat sine = sin(theta);\n\tfloat cosine = cos(theta);\n\treturn vec2(r * cosine, r * sine);\n}\nvec3 vogelSphere(int sampleIndex, float count, float phi, float r) {\n\tconst float GoldenAngle = 2.4;\n\tfloat theta = float(sampleIndex) * GoldenAngle + phi;\n\tfloat weight = float(sampleIndex) / count;\n\treturn vec3(cos(theta) * r, weight, sin(theta) * r);\n}\nfloat noise(vec2 screenPos) {\n\tconst float PHI = 1.61803398874989484820459;\n\treturn fract(sin(dot(screenPos * PHI, screenPos)) * screenPos.x);\n}\n#ifndef UNPACKFLOAT\n#define UNPACKFLOAT\nfloat unpackFloat(vec4 rgbaDepth) {\n\tconst vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n\treturn dot(rgbaDepth, bitShift);\n}\n#endif\nfloat viewSpaceDepth(float depth, mat4 invProjection) {\n\tfloat z = depth * 2.0 - 1.0;\n\tvec4 clipSpace = vec4(0.0, 0.0, z, 1.0);\n\tvec4 viewSpace = invProjection * clipSpace;\n\treturn viewSpace.z;\n}\nfloat PCSSBlockerDistance(TEXTURE_ACCEPT(shadowMap), vec2 sampleCoords[PCSS_SAMPLE_COUNT], vec2 shadowCoords, vec2 searchSize, float z) {\n\tfloat blockers = 0.0;\n\tfloat averageBlocker = 0.0;\n\tfor (int i = 0; i < PCSS_SAMPLE_COUNT; i++) {\n\t\tvec2 offset = sampleCoords[i] * searchSize;\n\t\tvec2 sampleUV = shadowCoords + offset;\n\t#ifdef GL2\n\t\tfloat blocker = textureLod(shadowMap, sampleUV, 0.0).r;\n\t#else\n\t\tfloat blocker = unpackFloat(texture2D(shadowMap, sampleUV));\n\t#endif\t\t\n\t\tfloat isBlocking = step(blocker, z);\n\t\tblockers += isBlocking;\n\t\taverageBlocker += blocker * isBlocking;\n\t}\n\tif (blockers > 0.0)\n\t\treturn averageBlocker /= blockers;\n\treturn -1.0;\n}\nfloat PCSS(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoords, vec4 cameraParams, vec2 shadowSearchArea) {\n\tfloat receiverDepth = shadowCoords.z;\n#ifndef GL2\n\treceiverDepth *= 1.0 / (cameraParams.y - cameraParams.z);\n#endif\n\tvec2 samplePoints[PCSS_SAMPLE_COUNT];\n\tfloat noise = noise( gl_FragCoord.xy ) * 2.0 * PI;\n\tfor (int i = 0; i < PCSS_SAMPLE_COUNT; i++) {\n\t\tfloat pcssPresample = pcssDiskSamples[i];\n\t\tsamplePoints[i] = vogelDisk(i, float(PCSS_SAMPLE_COUNT), noise, pcssPresample);\n\t}\n\tfloat averageBlocker = PCSSBlockerDistance(TEXTURE_PASS(shadowMap), samplePoints, shadowCoords.xy, shadowSearchArea, receiverDepth);\n\tif (averageBlocker == -1.0) {\n\t\treturn 1.0;\n\t} else {\n\t\tvec2 filterRadius = ((receiverDepth - averageBlocker) / averageBlocker) * shadowSearchArea * cameraParams.x;\n\t\tfloat shadow = 0.0;\n\t\tfor (int i = 0; i < PCSS_SAMPLE_COUNT; i ++)\n\t\t{\n\t\t\tvec2 sampleUV = samplePoints[i] * filterRadius;\n\t\t\tsampleUV = shadowCoords.xy + sampleUV;\n\t\t#ifdef GL2\n\t\t\tfloat depth = textureLod(shadowMap, sampleUV, 0.0).r;\n\t\t#else\n\t\t\tfloat depth = unpackFloat(texture2D(shadowMap, sampleUV));\n\t\t#endif\n\t\t\tshadow += step(receiverDepth, depth);\n\t\t}\n\t\treturn shadow / float(PCSS_SAMPLE_COUNT);\n\t} \n}\nfloat PCSSCubeBlockerDistance(samplerCube shadowMap, vec3 lightDirNorm, vec3 samplePoints[PCSS_SAMPLE_COUNT], float z, float shadowSearchArea) {\n\tfloat blockers = 0.0;\n\tfloat averageBlocker = 0.0;\n\tfor (int i = 0; i < PCSS_SAMPLE_COUNT; i++) {\n\t\tvec3 sampleDir = lightDirNorm + samplePoints[i] * shadowSearchArea;\n\t\tsampleDir = normalize(sampleDir);\n\t#ifdef GL2\n\t\tfloat blocker = textureCubeLodEXT(shadowMap, sampleDir, 0.0).r;\n\t#else\n\t\tfloat blocker = unpackFloat(textureCube(shadowMap, sampleDir));\n\t#endif\n\t\tfloat isBlocking = step(blocker, z);\n\t\tblockers += isBlocking;\n\t\taverageBlocker += blocker * isBlocking;\n\t}\n\tif (blockers > 0.0)\n\t\treturn averageBlocker /= float(blockers);\n\treturn -1.0;\n}\nfloat PCSSCube(samplerCube shadowMap, vec4 shadowParams, vec3 shadowCoords, vec4 cameraParams, float shadowSearchArea, vec3 lightDir) {\n\t\n\tvec3 samplePoints[PCSS_SAMPLE_COUNT];\n\tfloat noise = noise( gl_FragCoord.xy ) * 2.0 * PI;\n\tfor (int i = 0; i < PCSS_SAMPLE_COUNT; i++) {\n\t\tfloat r = pcssSphereSamples[i];\n\t\tsamplePoints[i] = vogelSphere(i, float(PCSS_SAMPLE_COUNT), noise, r);\n\t}\n\tfloat receiverDepth = length(lightDir) * shadowParams.w + shadowParams.z;\n\tvec3 lightDirNorm = normalize(lightDir);\n\t\n\tfloat averageBlocker = PCSSCubeBlockerDistance(shadowMap, lightDirNorm, samplePoints, receiverDepth, shadowSearchArea);\n\tif (averageBlocker == -1.0) {\n\t\treturn 1.0;\n\t} else {\n\t\tfloat filterRadius = ((receiverDepth - averageBlocker) / averageBlocker) * shadowSearchArea;\n\t\tfloat shadow = 0.0;\n\t\tfor (int i = 0; i < PCSS_SAMPLE_COUNT; i++)\n\t\t{\n\t\t\tvec3 offset = samplePoints[i] * filterRadius;\n\t\t\tvec3 sampleDir = lightDirNorm + offset;\n\t\t\tsampleDir = normalize(sampleDir);\n\t\t\t#ifdef GL2\n\t\t\t\tfloat depth = textureCubeLodEXT(shadowMap, sampleDir, 0.0).r;\n\t\t\t#else\n\t\t\t\tfloat depth = unpackFloat(textureCube(shadowMap, sampleDir));\n\t\t\t#endif\n\t\t\tshadow += step(receiverDepth, depth);\n\t\t}\n\t\treturn shadow / float(PCSS_SAMPLE_COUNT);\n\t}\n}\nfloat getShadowPointPCSS(samplerCube shadowMap, vec3 shadowCoord, vec4 shadowParams, vec4 cameraParams, vec2 shadowSearchArea, vec3 lightDir) {\n\treturn PCSSCube(shadowMap, shadowParams, shadowCoord, cameraParams, shadowSearchArea.x, lightDir);\n}\nfloat getShadowSpotPCSS(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, vec4 cameraParams, vec2 shadowSearchArea, vec3 lightDir) {\n\treturn PCSS(TEXTURE_PASS(shadowMap), shadowCoord, cameraParams, shadowSearchArea);\n}\nfloat getShadowPCSS(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, vec4 cameraParams, vec2 shadowSearchArea, vec3 lightDir) {\n\treturn PCSS(TEXTURE_PASS(shadowMap), shadowCoord, cameraParams, shadowSearchArea);\n}\n";

	var shadowSampleCoordPS = "\nvec3 getShadowSampleCoord$LIGHT(mat4 shadowTransform, vec4 shadowParams, vec3 worldPosition, vec3 lightPos, inout vec3 lightDir, vec3 lightDirNorm, vec3 normal) {\n\tvec3 surfacePosition = worldPosition;\n#ifdef SHADOW_SAMPLE_POINT\n\t#ifdef SHADOW_SAMPLE_NORMAL_OFFSET\n\t\tfloat distScale = length(lightDir);\n\t\tsurfacePosition = worldPosition + normal * shadowParams.y * clamp(1.0 - dot(normal, -lightDirNorm), 0.0, 1.0) * distScale;\n\t\tlightDir = surfacePosition - lightPos;\n\t\treturn lightDir;\n\t#endif\n#else\n\t#ifdef SHADOW_SAMPLE_SOURCE_ZBUFFER\n\t\t#ifdef SHADOW_SAMPLE_NORMAL_OFFSET\n\t\t\tsurfacePosition = worldPosition + normal * shadowParams.y;\n\t\t#endif\n\t#else\n\t\t#ifdef SHADOW_SAMPLE_NORMAL_OFFSET\n\t\t\t#ifdef SHADOW_SAMPLE_ORTHO\n\t\t\t\tfloat distScale = 1.0;\n\t\t\t#else\n\t\t\t\tfloat distScale = abs(dot(vPositionW - lightPos, lightDirNorm));\n\t\t\t#endif\n\t\t\tsurfacePosition = worldPosition + normal * shadowParams.y * clamp(1.0 - dot(normal, -lightDirNorm), 0.0, 1.0) * distScale;\n\t\t#endif\n\t#endif\n\tvec4 positionInShadowSpace = shadowTransform * vec4(surfacePosition, 1.0);\n\t#ifdef SHADOW_SAMPLE_ORTHO\n\t\tpositionInShadowSpace.z = saturate(positionInShadowSpace.z) - 0.0001;\n\t#else\n\t\t#ifdef SHADOW_SAMPLE_SOURCE_ZBUFFER\n\t\t\tpositionInShadowSpace.xyz /= positionInShadowSpace.w;\n\t\t#else\n\t\t\tpositionInShadowSpace.xy /= positionInShadowSpace.w;\n\t\t\tpositionInShadowSpace.z = length(lightDir) * shadowParams.w;\n\t\t#endif\n\t#endif\n\t#ifdef SHADOW_SAMPLE_Z_BIAS\n\t\tpositionInShadowSpace.z += getShadowBias(shadowParams.x, shadowParams.z);\n\t#endif\n\tsurfacePosition = positionInShadowSpace.xyz;\n#endif\n\treturn surfacePosition;\n}\n";

	var shadowStandardPS = "\nvec3 lessThan2(vec3 a, vec3 b) {\n\treturn clamp((b - a)*1000.0, 0.0, 1.0);\n}\n#ifndef UNPACKFLOAT\n#define UNPACKFLOAT\n\tfloat unpackFloat(vec4 rgbaDepth) {\n\t\tconst vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n\t\treturn dot(rgbaDepth, bitShift);\n\t}\n#endif\n#ifdef GL2\nfloat _getShadowPCF3x3(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec3 shadowParams) {\n\tfloat z = shadowCoord.z;\n\tvec2 uv = shadowCoord.xy * shadowParams.x;\n\tfloat shadowMapSizeInv = 1.0 / shadowParams.x;\n\tvec2 base_uv = floor(uv + 0.5);\n\tfloat s = (uv.x + 0.5 - base_uv.x);\n\tfloat t = (uv.y + 0.5 - base_uv.y);\n\tbase_uv -= vec2(0.5);\n\tbase_uv *= shadowMapSizeInv;\n\tfloat sum = 0.0;\n\tfloat uw0 = (3.0 - 2.0 * s);\n\tfloat uw1 = (1.0 + 2.0 * s);\n\tfloat u0 = (2.0 - s) / uw0 - 1.0;\n\tfloat u1 = s / uw1 + 1.0;\n\tfloat vw0 = (3.0 - 2.0 * t);\n\tfloat vw1 = (1.0 + 2.0 * t);\n\tfloat v0 = (2.0 - t) / vw0 - 1.0;\n\tfloat v1 = t / vw1 + 1.0;\n\tu0 = u0 * shadowMapSizeInv + base_uv.x;\n\tv0 = v0 * shadowMapSizeInv + base_uv.y;\n\tu1 = u1 * shadowMapSizeInv + base_uv.x;\n\tv1 = v1 * shadowMapSizeInv + base_uv.y;\n\tsum += uw0 * vw0 * textureShadow(shadowMap, vec3(u0, v0, z));\n\tsum += uw1 * vw0 * textureShadow(shadowMap, vec3(u1, v0, z));\n\tsum += uw0 * vw1 * textureShadow(shadowMap, vec3(u0, v1, z));\n\tsum += uw1 * vw1 * textureShadow(shadowMap, vec3(u1, v1, z));\n\tsum *= 1.0f / 16.0;\n\treturn sum;\n}\nfloat getShadowPCF3x3(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {\n\treturn _getShadowPCF3x3(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams.xyz);\n}\nfloat getShadowSpotPCF3x3(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {\n\treturn _getShadowPCF3x3(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams.xyz);\n}\nfloat getShadowPCF1x1(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {\n\treturn textureShadow(shadowMap, shadowCoord);\n}\nfloat getShadowSpotPCF1x1(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {\n\treturn textureShadow(shadowMap, shadowCoord);\n}\n#else\nfloat _xgetShadowPCF3x3(mat3 depthKernel, vec3 shadowCoord, sampler2D shadowMap, vec3 shadowParams) {\n\tmat3 shadowKernel;\n\tvec3 shadowZ = vec3(shadowCoord.z);\n\tshadowKernel[0] = vec3(greaterThan(depthKernel[0], shadowZ));\n\tshadowKernel[1] = vec3(greaterThan(depthKernel[1], shadowZ));\n\tshadowKernel[2] = vec3(greaterThan(depthKernel[2], shadowZ));\n\tvec2 fractionalCoord = fract( shadowCoord.xy * shadowParams.x );\n\tshadowKernel[0] = mix(shadowKernel[0], shadowKernel[1], fractionalCoord.x);\n\tshadowKernel[1] = mix(shadowKernel[1], shadowKernel[2], fractionalCoord.x);\n\tvec4 shadowValues;\n\tshadowValues.x = mix(shadowKernel[0][0], shadowKernel[0][1], fractionalCoord.y);\n\tshadowValues.y = mix(shadowKernel[0][1], shadowKernel[0][2], fractionalCoord.y);\n\tshadowValues.z = mix(shadowKernel[1][0], shadowKernel[1][1], fractionalCoord.y);\n\tshadowValues.w = mix(shadowKernel[1][1], shadowKernel[1][2], fractionalCoord.y);\n\treturn dot( shadowValues, vec4( 1.0 ) ) * 0.25;\n}\nfloat _getShadowPCF3x3(sampler2D shadowMap, vec3 shadowCoord, vec3 shadowParams) {\n\tfloat xoffset = 1.0 / shadowParams.x;\n\tfloat dx0 = -xoffset;\n\tfloat dx1 = xoffset;\n\tmat3 depthKernel;\n\tdepthKernel[0][0] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(dx0, dx0)));\n\tdepthKernel[0][1] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(dx0, 0.0)));\n\tdepthKernel[0][2] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(dx0, dx1)));\n\tdepthKernel[1][0] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(0.0, dx0)));\n\tdepthKernel[1][1] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy));\n\tdepthKernel[1][2] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(0.0, dx1)));\n\tdepthKernel[2][0] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(dx1, dx0)));\n\tdepthKernel[2][1] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(dx1, 0.0)));\n\tdepthKernel[2][2] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(dx1, dx1)));\n\treturn _xgetShadowPCF3x3(depthKernel, shadowCoord, shadowMap, shadowParams);\n}\nfloat getShadowPCF3x3(sampler2D shadowMap, vec3 shadowCoord, vec4 shadowParams) {\n\treturn _getShadowPCF3x3(shadowMap, shadowCoord, shadowParams.xyz);\n}\nfloat getShadowSpotPCF3x3(sampler2D shadowMap, vec3 shadowCoord, vec4 shadowParams) {\n\treturn _getShadowPCF3x3(shadowMap, shadowCoord, shadowParams.xyz);\n}\nfloat _getShadowPCF1x1(sampler2D shadowMap, vec3 shadowCoord) {\n\tfloat shadowSample = unpackFloat(textureShadow(shadowMap, shadowCoord.xy));\n\treturn shadowSample > shadowCoord.z ? 1.0 : 0.0;\n}\nfloat getShadowPCF1x1(sampler2D shadowMap, vec3 shadowCoord, vec4 shadowParams) {\n\treturn _getShadowPCF1x1(shadowMap, shadowCoord);\n}\nfloat getShadowSpotPCF1x1(sampler2D shadowMap, vec3 shadowCoord, vec4 shadowParams) {\n\treturn _getShadowPCF1x1(shadowMap, shadowCoord);\n}\n#endif\n#ifndef WEBGPU\nfloat _getShadowPoint(samplerCube shadowMap, vec4 shadowParams, vec3 dir) {\n\tvec3 tc = normalize(dir);\n\tvec3 tcAbs = abs(tc);\n\tvec4 dirX = vec4(1,0,0, tc.x);\n\tvec4 dirY = vec4(0,1,0, tc.y);\n\tfloat majorAxisLength = tc.z;\n\tif ((tcAbs.x > tcAbs.y) && (tcAbs.x > tcAbs.z)) {\n\t\tdirX = vec4(0,0,1, tc.z);\n\t\tdirY = vec4(0,1,0, tc.y);\n\t\tmajorAxisLength = tc.x;\n\t} else if ((tcAbs.y > tcAbs.x) && (tcAbs.y > tcAbs.z)) {\n\t\tdirX = vec4(1,0,0, tc.x);\n\t\tdirY = vec4(0,0,1, tc.z);\n\t\tmajorAxisLength = tc.y;\n\t}\n\tfloat shadowParamsInFaceSpace = ((1.0/shadowParams.x) * 2.0) * abs(majorAxisLength);\n\tvec3 xoffset = (dirX.xyz * shadowParamsInFaceSpace);\n\tvec3 yoffset = (dirY.xyz * shadowParamsInFaceSpace);\n\tvec3 dx0 = -xoffset;\n\tvec3 dy0 = -yoffset;\n\tvec3 dx1 = xoffset;\n\tvec3 dy1 = yoffset;\n\tmat3 shadowKernel;\n\tmat3 depthKernel;\n\tdepthKernel[0][0] = unpackFloat(textureCube(shadowMap, tc + dx0 + dy0));\n\tdepthKernel[0][1] = unpackFloat(textureCube(shadowMap, tc + dx0));\n\tdepthKernel[0][2] = unpackFloat(textureCube(shadowMap, tc + dx0 + dy1));\n\tdepthKernel[1][0] = unpackFloat(textureCube(shadowMap, tc + dy0));\n\tdepthKernel[1][1] = unpackFloat(textureCube(shadowMap, tc));\n\tdepthKernel[1][2] = unpackFloat(textureCube(shadowMap, tc + dy1));\n\tdepthKernel[2][0] = unpackFloat(textureCube(shadowMap, tc + dx1 + dy0));\n\tdepthKernel[2][1] = unpackFloat(textureCube(shadowMap, tc + dx1));\n\tdepthKernel[2][2] = unpackFloat(textureCube(shadowMap, tc + dx1 + dy1));\n\tvec3 shadowZ = vec3(length(dir) * shadowParams.w + shadowParams.z);\n\tshadowKernel[0] = vec3(lessThan2(depthKernel[0], shadowZ));\n\tshadowKernel[1] = vec3(lessThan2(depthKernel[1], shadowZ));\n\tshadowKernel[2] = vec3(lessThan2(depthKernel[2], shadowZ));\n\tvec2 uv = (vec2(dirX.w, dirY.w) / abs(majorAxisLength)) * 0.5;\n\tvec2 fractionalCoord = fract( uv * shadowParams.x );\n\tshadowKernel[0] = mix(shadowKernel[0], shadowKernel[1], fractionalCoord.x);\n\tshadowKernel[1] = mix(shadowKernel[1], shadowKernel[2], fractionalCoord.x);\n\tvec4 shadowValues;\n\tshadowValues.x = mix(shadowKernel[0][0], shadowKernel[0][1], fractionalCoord.y);\n\tshadowValues.y = mix(shadowKernel[0][1], shadowKernel[0][2], fractionalCoord.y);\n\tshadowValues.z = mix(shadowKernel[1][0], shadowKernel[1][1], fractionalCoord.y);\n\tshadowValues.w = mix(shadowKernel[1][1], shadowKernel[1][2], fractionalCoord.y);\n\treturn 1.0 - dot( shadowValues, vec4( 1.0 ) ) * 0.25;\n}\nfloat getShadowPointPCF3x3(samplerCube shadowMap, vec3 shadowCoord, vec4 shadowParams, vec3 lightDir) {\n\treturn _getShadowPoint(shadowMap, shadowParams, lightDir);\n}\n#endif\n";

	var shadowStandardGL2PS = "\nfloat _getShadowPCF5x5(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec3 shadowParams) {\n\tfloat z = shadowCoord.z;\n\tvec2 uv = shadowCoord.xy * shadowParams.x;\n\tfloat shadowMapSizeInv = 1.0 / shadowParams.x;\n\tvec2 base_uv = floor(uv + 0.5);\n\tfloat s = (uv.x + 0.5 - base_uv.x);\n\tfloat t = (uv.y + 0.5 - base_uv.y);\n\tbase_uv -= vec2(0.5);\n\tbase_uv *= shadowMapSizeInv;\n\tfloat uw0 = (4.0 - 3.0 * s);\n\tfloat uw1 = 7.0;\n\tfloat uw2 = (1.0 + 3.0 * s);\n\tfloat u0 = (3.0 - 2.0 * s) / uw0 - 2.0;\n\tfloat u1 = (3.0 + s) / uw1;\n\tfloat u2 = s / uw2 + 2.0;\n\tfloat vw0 = (4.0 - 3.0 * t);\n\tfloat vw1 = 7.0;\n\tfloat vw2 = (1.0 + 3.0 * t);\n\tfloat v0 = (3.0 - 2.0 * t) / vw0 - 2.0;\n\tfloat v1 = (3.0 + t) / vw1;\n\tfloat v2 = t / vw2 + 2.0;\n\tfloat sum = 0.0;\n\tu0 = u0 * shadowMapSizeInv + base_uv.x;\n\tv0 = v0 * shadowMapSizeInv + base_uv.y;\n\tu1 = u1 * shadowMapSizeInv + base_uv.x;\n\tv1 = v1 * shadowMapSizeInv + base_uv.y;\n\tu2 = u2 * shadowMapSizeInv + base_uv.x;\n\tv2 = v2 * shadowMapSizeInv + base_uv.y;\n\tsum += uw0 * vw0 * textureShadow(shadowMap, vec3(u0, v0, z));\n\tsum += uw1 * vw0 * textureShadow(shadowMap, vec3(u1, v0, z));\n\tsum += uw2 * vw0 * textureShadow(shadowMap, vec3(u2, v0, z));\n\tsum += uw0 * vw1 * textureShadow(shadowMap, vec3(u0, v1, z));\n\tsum += uw1 * vw1 * textureShadow(shadowMap, vec3(u1, v1, z));\n\tsum += uw2 * vw1 * textureShadow(shadowMap, vec3(u2, v1, z));\n\tsum += uw0 * vw2 * textureShadow(shadowMap, vec3(u0, v2, z));\n\tsum += uw1 * vw2 * textureShadow(shadowMap, vec3(u1, v2, z));\n\tsum += uw2 * vw2 * textureShadow(shadowMap, vec3(u2, v2, z));\n\tsum *= 1.0f / 144.0;\n\tsum = saturate(sum);\n\treturn sum;\n}\nfloat getShadowPCF5x5(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {\n\treturn _getShadowPCF5x5(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams.xyz);\n}\nfloat getShadowSpotPCF5x5(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {\n\treturn _getShadowPCF5x5(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams.xyz);\n}\n";

	var shadowVSM8PS = "\nfloat calculateVSM8(vec3 moments, float Z, float vsmBias) {\n\tfloat VSMBias = vsmBias;\n\tfloat depthScale = VSMBias * Z;\n\tfloat minVariance1 = depthScale * depthScale;\n\treturn chebyshevUpperBound(moments.xy, Z, minVariance1, 0.1);\n}\nfloat decodeFloatRG(vec2 rg) {\n\treturn rg.y*(1.0/255.0) + rg.x;\n}\nfloat VSM8(TEXTURE_ACCEPT(tex), vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {\n\tvec4 c = texture2D(tex, texCoords);\n\tvec3 moments = vec3(decodeFloatRG(c.xy), decodeFloatRG(c.zw), 0.0);\n\treturn calculateVSM8(moments, Z, vsmBias);\n}\nfloat getShadowVSM8(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, float exponent, vec3 lightDir) {\n\treturn VSM8(TEXTURE_PASS(shadowMap), shadowCoord.xy, shadowParams.x, shadowCoord.z, shadowParams.y, 0.0);\n}\nfloat getShadowSpotVSM8(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, float exponent, vec3 lightDir) {\n\treturn VSM8(TEXTURE_PASS(shadowMap), shadowCoord.xy, shadowParams.x, length(lightDir) * shadowParams.w + shadowParams.z, shadowParams.y, 0.0);\n}\n";

	var shadowVSM_commonPS = "\nfloat linstep(float a, float b, float v) {\n\treturn saturate((v - a) / (b - a));\n}\nfloat reduceLightBleeding(float pMax, float amount) {\n   return linstep(amount, 1.0, pMax);\n}\nfloat chebyshevUpperBound(vec2 moments, float mean, float minVariance, float lightBleedingReduction) {\n\tfloat variance = moments.y - (moments.x * moments.x);\n\tvariance = max(variance, minVariance);\n\tfloat d = mean - moments.x;\n\tfloat pMax = variance / (variance + (d * d));\n\tpMax = reduceLightBleeding(pMax, lightBleedingReduction);\n\treturn (mean <= moments.x ? 1.0 : pMax);\n}\nfloat calculateEVSM(vec3 moments, float Z, float vsmBias, float exponent) {\n\tZ = 2.0 * Z - 1.0;\n\tfloat warpedDepth = exp(exponent * Z);\n\tmoments.xy += vec2(warpedDepth, warpedDepth*warpedDepth) * (1.0 - moments.z);\n\tfloat VSMBias = vsmBias;\n\tfloat depthScale = VSMBias * exponent * warpedDepth;\n\tfloat minVariance1 = depthScale * depthScale;\n\treturn chebyshevUpperBound(moments.xy, warpedDepth, minVariance1, 0.1);\n}\n";

	var skinBatchConstVS = "\nattribute float vertex_boneIndices;\nuniform vec4 matrix_pose[BONE_LIMIT * 3];\nmat4 getBoneMatrix(const in float i) {\n\tvec4 v1 = matrix_pose[int(3.0 * i)];\n\tvec4 v2 = matrix_pose[int(3.0 * i + 1.0)];\n\tvec4 v3 = matrix_pose[int(3.0 * i + 2.0)];\n\treturn mat4(\n\t\tv1.x, v2.x, v3.x, 0,\n\t\tv1.y, v2.y, v3.y, 0,\n\t\tv1.z, v2.z, v3.z, 0,\n\t\tv1.w, v2.w, v3.w, 1\n\t);\n}\n";

	var skinBatchTexVS = "\nattribute float vertex_boneIndices;\nuniform highp sampler2D texture_poseMap;\nuniform vec4 texture_poseMapSize;\nmat4 getBoneMatrix(const in float i) {\n\tfloat j = i * 3.0;\n\tfloat dx = texture_poseMapSize.z;\n\tfloat dy = texture_poseMapSize.w;\n\tfloat y = floor(j * dx);\n\tfloat x = j - (y * texture_poseMapSize.x);\n\ty = dy * (y + 0.5);\n\tvec4 v1 = texture2D(texture_poseMap, vec2(dx * (x + 0.5), y));\n\tvec4 v2 = texture2D(texture_poseMap, vec2(dx * (x + 1.5), y));\n\tvec4 v3 = texture2D(texture_poseMap, vec2(dx * (x + 2.5), y));\n\treturn mat4(\n\t\tv1.x, v2.x, v3.x, 0,\n\t\tv1.y, v2.y, v3.y, 0,\n\t\tv1.z, v2.z, v3.z, 0,\n\t\tv1.w, v2.w, v3.w, 1\n\t);\n}\n";

	var skinConstVS = "\nattribute vec4 vertex_boneWeights;\nattribute vec4 vertex_boneIndices;\nuniform vec4 matrix_pose[BONE_LIMIT * 3];\nvoid getBoneMatrix(const in float i, out vec4 v1, out vec4 v2, out vec4 v3) {\n\tv1 = matrix_pose[int(3.0 * i)];\n\tv2 = matrix_pose[int(3.0 * i + 1.0)];\n\tv3 = matrix_pose[int(3.0 * i + 2.0)];\n}\nmat4 getSkinMatrix(const in vec4 indices, const in vec4 weights) {\n\tvec4 a1, a2, a3;\n\tgetBoneMatrix(indices.x, a1, a2, a3);\n\tvec4 b1, b2, b3;\n\tgetBoneMatrix(indices.y, b1, b2, b3);\n\tvec4 c1, c2, c3;\n\tgetBoneMatrix(indices.z, c1, c2, c3);\n\tvec4 d1, d2, d3;\n\tgetBoneMatrix(indices.w, d1, d2, d3);\n\tvec4 v1 = a1 * weights.x + b1 * weights.y + c1 * weights.z + d1 * weights.w;\n\tvec4 v2 = a2 * weights.x + b2 * weights.y + c2 * weights.z + d2 * weights.w;\n\tvec4 v3 = a3 * weights.x + b3 * weights.y + c3 * weights.z + d3 * weights.w;\n\tfloat one = dot(weights, vec4(1.0));\n\treturn mat4(\n\t\tv1.x, v2.x, v3.x, 0,\n\t\tv1.y, v2.y, v3.y, 0,\n\t\tv1.z, v2.z, v3.z, 0,\n\t\tv1.w, v2.w, v3.w, one\n\t);\n}\n";

	var skinTexVS = "\nattribute vec4 vertex_boneWeights;\nattribute vec4 vertex_boneIndices;\nuniform highp sampler2D texture_poseMap;\nuniform vec4 texture_poseMapSize;\nvoid getBoneMatrix(const in float index, out vec4 v1, out vec4 v2, out vec4 v3) {\n\tfloat i = float(index);\n\tfloat j = i * 3.0;\n\tfloat dx = texture_poseMapSize.z;\n\tfloat dy = texture_poseMapSize.w;\n\t\n\tfloat y = floor(j * dx);\n\tfloat x = j - (y * texture_poseMapSize.x);\n\ty = dy * (y + 0.5);\n\tv1 = texture2D(texture_poseMap, vec2(dx * (x + 0.5), y));\n\tv2 = texture2D(texture_poseMap, vec2(dx * (x + 1.5), y));\n\tv3 = texture2D(texture_poseMap, vec2(dx * (x + 2.5), y));\n}\nmat4 getSkinMatrix(const in vec4 indices, const in vec4 weights) {\n\tvec4 a1, a2, a3;\n\tgetBoneMatrix(indices.x, a1, a2, a3);\n\tvec4 b1, b2, b3;\n\tgetBoneMatrix(indices.y, b1, b2, b3);\n\tvec4 c1, c2, c3;\n\tgetBoneMatrix(indices.z, c1, c2, c3);\n\tvec4 d1, d2, d3;\n\tgetBoneMatrix(indices.w, d1, d2, d3);\n\tvec4 v1 = a1 * weights.x + b1 * weights.y + c1 * weights.z + d1 * weights.w;\n\tvec4 v2 = a2 * weights.x + b2 * weights.y + c2 * weights.z + d2 * weights.w;\n\tvec4 v3 = a3 * weights.x + b3 * weights.y + c3 * weights.z + d3 * weights.w;\n\tfloat one = dot(weights, vec4(1.0));\n\treturn mat4(\n\t\tv1.x, v2.x, v3.x, 0,\n\t\tv1.y, v2.y, v3.y, 0,\n\t\tv1.z, v2.z, v3.z, 0,\n\t\tv1.w, v2.w, v3.w, one\n\t);\n}\n";

	var skyboxEnvPS = "\nvarying vec3 vViewDir;\nuniform sampler2D texture_envAtlas;\nuniform float mipLevel;\nvoid main(void) {\n\tvec3 dir = vViewDir * vec3(-1.0, 1.0, 1.0);\n\tvec2 uv = toSphericalUv(normalize(dir));\n\tvec3 linear = $DECODE(texture2D(texture_envAtlas, mapRoughnessUv(uv, mipLevel)));\n\tgl_FragColor = vec4(gammaCorrectOutput(toneMap(processEnvironment(linear))), 1.0);\n}\n";

	var skyboxHDRPS = "\nvarying vec3 vViewDir;\nuniform samplerCube texture_cubeMap;\nvoid main(void) {\n\tvec3 dir=vViewDir;\n\tdir.x *= -1.0;\n\tvec3 linear = $DECODE(textureCube(texture_cubeMap, fixSeamsStatic(dir, $FIXCONST)));\n\tgl_FragColor = vec4(gammaCorrectOutput(toneMap(processEnvironment(linear))), 1.0);\n}\n";

	var skyboxVS = "\nattribute vec3 aPosition;\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform mat4 matrix_projectionSkybox;\nuniform mat3 cubeMapRotationMatrix;\nvarying vec3 vViewDir;\nvoid main(void) {\n\tmat4 view = matrix_view;\n\tview[3][0] = view[3][1] = view[3][2] = 0.0;\n\tgl_Position = matrix_projectionSkybox * view * vec4(aPosition, 1.0);\n\tgl_Position.z = gl_Position.w - 0.00001;\n\tvViewDir = aPosition * cubeMapRotationMatrix;\n}\n";

	var specularPS = "\n#ifdef MAPCOLOR\nuniform vec3 material_specular;\n#endif\nvoid getSpecularity() {\n\tvec3 specularColor = vec3(1,1,1);\n\t#ifdef MAPCOLOR\n\tspecularColor *= material_specular;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tspecularColor *= $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tspecularColor *= saturate(vVertexColor.$VC);\n\t#endif\n\tdSpecularity = specularColor;\n}\n";

	var sphericalPS = "\nconst float PI = 3.141592653589793;\nvec2 toSpherical(vec3 dir) {\n\treturn vec2(dir.xz == vec2(0.0) ? 0.0 : atan(dir.x, dir.z), asin(dir.y));\n}\nvec2 toSphericalUv(vec3 dir) {\n\tvec2 uv = toSpherical(dir) / vec2(PI * 2.0, PI) + 0.5;\n\treturn vec2(uv.x, 1.0 - uv.y);\n}\n";

	var specularityFactorPS = "\n#ifdef MAPFLOAT\nuniform float material_specularityFactor;\n#endif\nvoid getSpecularityFactor() {\n\tfloat specularityFactor = 1.0;\n\t#ifdef MAPFLOAT\n\tspecularityFactor *= material_specularityFactor;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tspecularityFactor *= texture2DBias($SAMPLER, $UV, textureBias).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tspecularityFactor *= saturate(vVertexColor.$VC);\n\t#endif\n\tdSpecularityFactor = specularityFactor;\n}\n";

	var spotPS = "\nfloat getSpotEffect(vec3 lightSpotDir, float lightInnerConeAngle, float lightOuterConeAngle, vec3 lightDirNorm) {\n\tfloat cosAngle = dot(lightDirNorm, lightSpotDir);\n\treturn smoothstep(lightOuterConeAngle, lightInnerConeAngle, cosAngle);\n}\n";

	var startPS = "\nvoid main(void) {\n\tdReflection = vec4(0);\n\t#ifdef LIT_CLEARCOAT\n\tccSpecularLight = vec3(0);\n\tccReflection = vec3(0);\n\t#endif\n";

	var startVS = "\nvoid main(void) {\n\tgl_Position = getPosition();\n";

	var startNineSlicedPS = "\n\tnineSlicedUv = vUv0;\n\tnineSlicedUv.y = 1.0 - nineSlicedUv.y;\n";

	var startNineSlicedTiledPS = "\n\tvec2 tileMask = step(vMask, vec2(0.99999));\n\tvec2 tileSize = 0.5 * (innerOffset.xy + innerOffset.zw);\n\tvec2 tileScale = vec2(1.0) / (vec2(1.0) - tileSize);\n\tvec2 clampedUv = mix(innerOffset.xy * 0.5, vec2(1.0) - innerOffset.zw * 0.5, fract((vTiledUv - tileSize) * tileScale));\n\tclampedUv = clampedUv * atlasRect.zw + atlasRect.xy;\n\tnineSlicedUv = vUv0 * tileMask + clampedUv * (vec2(1.0) - tileMask);\n\tnineSlicedUv.y = 1.0 - nineSlicedUv.y;\n\t\n";

	var storeEVSMPS = "\nfloat exponent = VSM_EXPONENT;\ndepth = 2.0 * depth - 1.0;\ndepth =  exp(exponent * depth);\ngl_FragColor = vec4(depth, depth*depth, 1.0, 1.0);\n";

	var tangentBinormalVS = "\nvec3 getTangent() {\n\treturn normalize(dNormalMatrix * vertex_tangent.xyz);\n}\nvec3 getBinormal() {\n\treturn cross(vNormalW, vTangentW) * vertex_tangent.w;\n}\n";

	var TBNPS = "\nvoid getTBN(vec3 tangent, vec3 binormal, vec3 normal) {\n\tdTBN = mat3(normalize(tangent), normalize(binormal), normalize(normal));\n}\n";

	var TBNderivativePS = "\nuniform float tbnBasis;\nvoid getTBN(vec3 tangent, vec3 binormal, vec3 normal) {\n\tvec2 uv = $UV;\n\tvec3 dp1 = dFdx( vPositionW );\n\tvec3 dp2 = dFdy( vPositionW );\n\tvec2 duv1 = dFdx( uv );\n\tvec2 duv2 = dFdy( uv );\n\tvec3 dp2perp = cross( dp2, normal );\n\tvec3 dp1perp = cross( normal, dp1 );\n\tvec3 T = dp2perp * duv1.x + dp1perp * duv2.x;\n\tvec3 B = dp2perp * duv1.y + dp1perp * duv2.y;\n\tfloat denom = max( dot(T,T), dot(B,B) );\n\tfloat invmax = (denom == 0.0) ? 0.0 : tbnBasis / sqrt( denom );\n\tdTBN = mat3(T * invmax, -B * invmax, normal );\n}\n";

	var TBNfastPS = "\nvoid getTBN(vec3 tangent, vec3 binormal, vec3 normal) {\n\tdTBN = mat3(tangent, binormal, normal);\n}\n";

	var TBNObjectSpacePS = "\nvoid getTBN(vec3 tangent, vec3 binormal, vec3 normal) {\n\tvec3 B = cross(normal, vObjectSpaceUpW);\n\tvec3 T = cross(normal, B);\n\tif (dot(B,B)==0.0)\n\t{\n\t\tfloat major=max(max(normal.x, normal.y), normal.z);\n\t\tif (normal.x == major)\n\t\t{\n\t\t\tB=cross(normal, vec3(0,1,0));\n\t\t\tT=cross(normal, B);\n\t\t}\n\t\telse if (normal.y == major)\n\t\t{\n\t\t\tB=cross(normal, vec3(0,0,1));\n\t\t\tT=cross(normal, B);\n\t\t}\n\t\telse if (normal.z == major)\n\t\t{\n\t\t\tB=cross(normal, vec3(1,0,0));\n\t\t\tT=cross(normal, B);\n\t\t}\n\t}\n\tdTBN = mat3(normalize(T), normalize(B), normalize(normal));\n}\n";

	var textureSamplePS = "\nvec4 texture2DSRGB(sampler2D tex, vec2 uv) {\n\treturn gammaCorrectInput(texture2D(tex, uv));\n}\nvec4 texture2DSRGB(sampler2D tex, vec2 uv, float bias) {\n\treturn gammaCorrectInput(texture2D(tex, uv, bias));\n}\nvec3 texture2DRGBM(sampler2D tex, vec2 uv) {\n\treturn decodeRGBM(texture2D(tex, uv));\n}\nvec3 texture2DRGBM(sampler2D tex, vec2 uv, float bias) {\n\treturn decodeRGBM(texture2D(tex, uv, bias));\n}\nvec3 texture2DRGBE(sampler2D tex, vec2 uv) {\n\treturn decodeRGBM(texture2D(tex, uv));\n}\nvec3 texture2DRGBE(sampler2D tex, vec2 uv, float bias) {\n\treturn decodeRGBM(texture2D(tex, uv, bias));\n}\n";

	var thicknessPS = "\n#ifdef MAPFLOAT\nuniform float material_thickness;\n#endif\nvoid getThickness() {\n\tdThickness = 1.0;\n\t#ifdef MAPFLOAT\n\tdThickness *= material_thickness;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tdThickness *= texture2DBias($SAMPLER, $UV, textureBias).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tdThickness *= saturate(vVertexColor.$VC);\n\t#endif\n}\n";

	var tonemappingAcesPS = "\nuniform float exposure;\nvec3 toneMap(vec3 color) {\n\tfloat tA = 2.51;\n\tfloat tB = 0.03;\n\tfloat tC = 2.43;\n\tfloat tD = 0.59;\n\tfloat tE = 0.14;\n\tvec3 x = color * exposure;\n\treturn (x*(tA*x+tB))/(x*(tC*x+tD)+tE);\n}\n";

	var tonemappingAces2PS = "\nuniform float exposure;\nconst mat3 ACESInputMat = mat3(\n\t0.59719, 0.35458, 0.04823,\n\t0.07600, 0.90834, 0.01566,\n\t0.02840, 0.13383, 0.83777\n);\nconst mat3 ACESOutputMat = mat3(\n\t 1.60475, -0.53108, -0.07367,\n\t-0.10208,  1.10813, -0.00605,\n\t-0.00327, -0.07276,  1.07602\n);\nvec3 RRTAndODTFit(vec3 v) {\n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn a / b;\n}\nvec3 toneMap(vec3 color) {\n\tcolor *= exposure / 0.6;\n\tcolor = color * ACESInputMat;\n\tcolor = RRTAndODTFit(color);\n\tcolor = color * ACESOutputMat;\n\tcolor = clamp(color, 0.0, 1.0);\n\treturn color;\n}\n";

	var tonemappingFilmicPS = "\nconst float A =  0.15;\nconst float B =  0.50;\nconst float C =  0.10;\nconst float D =  0.20;\nconst float E =  0.02;\nconst float F =  0.30;\nconst float W =  11.2;\nuniform float exposure;\nvec3 uncharted2Tonemap(vec3 x) {\n   return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n}\nvec3 toneMap(vec3 color) {\n\tcolor = uncharted2Tonemap(color * exposure);\n\tvec3 whiteScale = 1.0 / uncharted2Tonemap(vec3(W,W,W));\n\tcolor = color * whiteScale;\n\treturn color;\n}\n";

	var tonemappingHejlPS = "\nuniform float exposure;\nvec3 toneMap(vec3 color) {\n\tcolor *= exposure;\n\tconst float  A = 0.22, B = 0.3, C = .1, D = 0.2, E = .01, F = 0.3;\n\tconst float Scl = 1.25;\n\tvec3 h = max( vec3(0.0), color - vec3(0.004) );\n\treturn (h*((Scl*A)*h+Scl*vec3(C*B,C*B,C*B))+Scl*vec3(D*E,D*E,D*E)) / (h*(A*h+vec3(B,B,B))+vec3(D*F,D*F,D*F)) - Scl*vec3(E/F,E/F,E/F);\n}\n";

	var tonemappingLinearPS = "\nuniform float exposure;\nvec3 toneMap(vec3 color) {\n\treturn color * exposure;\n}\n";

	var tonemappingNonePS = "\nvec3 toneMap(vec3 color) {\n\treturn color;\n}\n";

	var transformVS = "\n#ifdef PIXELSNAP\nuniform vec4 uScreenSize;\n#endif\n#ifdef SCREENSPACE\nuniform float projectionFlipY;\n#endif\n#ifdef MORPHING\nuniform vec4 morph_weights_a;\nuniform vec4 morph_weights_b;\n#endif\n#ifdef MORPHING_TEXTURE_BASED\n\tuniform vec4 morph_tex_params;\n\t#ifdef WEBGPU\n\t\tivec2 getTextureMorphCoords() {\n\t\t\tivec2 textureSize = ivec2(morph_tex_params.xy);\n\t\t\tint morphGridV = int(morph_vertex_id / textureSize.x);\n\t\t\tint morphGridU = int(morph_vertex_id - (morphGridV * textureSize.x));\n\t\t\tmorphGridV = textureSize.y - morphGridV - 1;\n\t\t\treturn ivec2(morphGridU, morphGridV);\n\t\t}\n\t#else\n\t\tvec2 getTextureMorphCoords() {\n\t\t\tvec2 textureSize = morph_tex_params.xy;\n\t\t\tvec2 invTextureSize = morph_tex_params.zw;\n\t\t\tfloat morphGridV = floor(morph_vertex_id * invTextureSize.x);\n\t\t\tfloat morphGridU = morph_vertex_id - (morphGridV * textureSize.x);\n\t\t\treturn vec2(morphGridU, morphGridV) * invTextureSize + (0.5 * invTextureSize);\n\t\t}\n\t#endif\n#endif\n#ifdef MORPHING_TEXTURE_BASED_POSITION\nuniform highp sampler2D morphPositionTex;\n#endif\nmat4 getModelMatrix() {\n\t#ifdef DYNAMICBATCH\n\treturn getBoneMatrix(vertex_boneIndices);\n\t#elif defined(SKIN)\n\treturn matrix_model * getSkinMatrix(vertex_boneIndices, vertex_boneWeights);\n\t#elif defined(INSTANCING)\n\treturn mat4(instance_line1, instance_line2, instance_line3, instance_line4);\n\t#else\n\treturn matrix_model;\n\t#endif\n}\nvec4 getPosition() {\n\tdModelMatrix = getModelMatrix();\n\tvec3 localPos = vertex_position;\n\t#ifdef NINESLICED\n\tlocalPos.xz *= outerScale;\n\tvec2 positiveUnitOffset = clamp(vertex_position.xz, vec2(0.0), vec2(1.0));\n\tvec2 negativeUnitOffset = clamp(-vertex_position.xz, vec2(0.0), vec2(1.0));\n\tlocalPos.xz += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;\n\tvTiledUv = (localPos.xz - outerScale + innerOffset.xy) * -0.5 + 1.0;\n\tlocalPos.xz *= -0.5;\n\tlocalPos = localPos.xzy;\n\t#endif\n\t#ifdef MORPHING\n\t#ifdef MORPHING_POS03\n\tlocalPos.xyz += morph_weights_a[0] * morph_pos0;\n\tlocalPos.xyz += morph_weights_a[1] * morph_pos1;\n\tlocalPos.xyz += morph_weights_a[2] * morph_pos2;\n\tlocalPos.xyz += morph_weights_a[3] * morph_pos3;\n\t#endif\n\t#ifdef MORPHING_POS47\n\tlocalPos.xyz += morph_weights_b[0] * morph_pos4;\n\tlocalPos.xyz += morph_weights_b[1] * morph_pos5;\n\tlocalPos.xyz += morph_weights_b[2] * morph_pos6;\n\tlocalPos.xyz += morph_weights_b[3] * morph_pos7;\n\t#endif\n\t#endif\n\t#ifdef MORPHING_TEXTURE_BASED_POSITION\n\t\t#ifdef WEBGPU\n\t\t\tivec2 morphUV = getTextureMorphCoords();\n\t\t\tvec3 morphPos = texelFetch(morphPositionTex, ivec2(morphUV), 0).xyz;\n\t\t#else\n\t\t\tvec2 morphUV = getTextureMorphCoords();\n\t\t\tvec3 morphPos = texture2D(morphPositionTex, morphUV).xyz;\n\t\t#endif\n\t\tlocalPos += morphPos;\n\t#endif\n\tvec4 posW = dModelMatrix * vec4(localPos, 1.0);\n\t#ifdef SCREENSPACE\n\tposW.zw = vec2(0.0, 1.0);\n\t#endif\n\tdPositionW = posW.xyz;\n\tvec4 screenPos;\n\t#ifdef UV1LAYOUT\n\tscreenPos = vec4(vertex_texCoord1.xy * 2.0 - 1.0, 0.5, 1);\n\t#else\n\t#ifdef SCREENSPACE\n\tscreenPos = posW;\n\tscreenPos.y *= projectionFlipY;\n\t#else\n\tscreenPos = matrix_viewProjection * posW;\n\t#endif\n\t#ifdef PIXELSNAP\n\tscreenPos.xy = (screenPos.xy * 0.5) + 0.5;\n\tscreenPos.xy *= uScreenSize.xy;\n\tscreenPos.xy = floor(screenPos.xy);\n\tscreenPos.xy *= uScreenSize.zw;\n\tscreenPos.xy = (screenPos.xy * 2.0) - 1.0;\n\t#endif\n\t#endif\n\treturn screenPos;\n}\nvec3 getWorldPosition() {\n\treturn dPositionW;\n}\n";

	var transformDeclVS = "\nattribute vec3 vertex_position;\nuniform mat4 matrix_model;\nuniform mat4 matrix_viewProjection;\nvec3 dPositionW;\nmat4 dModelMatrix;\n";

	var transmissionPS = "\n#ifdef MAPFLOAT\nuniform float material_refraction;\n#endif\nvoid getRefraction() {\n\tfloat refraction = 1.0;\n\t#ifdef MAPFLOAT\n\trefraction = material_refraction;\n\t#endif\n\t#ifdef MAPTEXTURE\n\trefraction *= texture2DBias($SAMPLER, $UV, textureBias).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\trefraction *= saturate(vVertexColor.$VC);\n\t#endif\n\tdTransmission = refraction;\n}\n";

	var uv0VS = "\n#ifdef NINESLICED\nvec2 getUv0() {\n\tvec2 uv = vertex_position.xz;\n\tvec2 positiveUnitOffset = clamp(vertex_position.xz, vec2(0.0), vec2(1.0));\n\tvec2 negativeUnitOffset = clamp(-vertex_position.xz, vec2(0.0), vec2(1.0));\n\tuv += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;\n\tuv = uv * -0.5 + 0.5;\n\tuv = uv * atlasRect.zw + atlasRect.xy;\n\tvMask = vertex_texCoord0.xy;\n\treturn uv;\n}\n#else\nvec2 getUv0() {\n\treturn vertex_texCoord0;\n}\n#endif\n";

	var uv1VS = "\nvec2 getUv1() {\n\treturn vertex_texCoord1;\n}\n";

	var viewDirPS = "\nvoid getViewDir() {\n\tdViewDirW = normalize(view_position - vPositionW);\n}\n";

	var viewNormalVS = "\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nvec3 getViewNormal() {\n\treturn mat3(matrix_view) * vNormalW;\n}\n";

	var shaderChunks = {
		alphaTestPS: alphaTestPS,
		ambientConstantPS: ambientConstantPS,
		ambientEnvPS: ambientEnvPS,
		ambientSHPS: ambientSHPS,
		aoPS: aoPS,
		aoDetailMapPS: aoDetailMapPS,
		aoDiffuseOccPS: aoDiffuseOccPS,
		aoSpecOccPS: aoSpecOccPS,
		aoSpecOccConstPS: aoSpecOccConstPS,
		aoSpecOccConstSimplePS: aoSpecOccConstSimplePS,
		aoSpecOccSimplePS: aoSpecOccSimplePS,
		basePS: basePS,
		baseVS: baseVS,
		baseNineSlicedPS: baseNineSlicedPS,
		baseNineSlicedVS: baseNineSlicedVS,
		baseNineSlicedTiledPS: baseNineSlicedTiledPS,
		biasConstPS: biasConstPS,
		blurVSMPS: blurVSMPS,
		clearCoatPS: clearCoatPS,
		clearCoatGlossPS: clearCoatGlossPS,
		clearCoatNormalPS: clearCoatNormalPS,
		clusteredLightCookiesPS: clusteredLightCookiesPS,
		clusteredLightShadowsPS: clusteredLightShadowsPS,
		clusteredLightUtilsPS: clusteredLightUtilsPS,
		clusteredLightPS: clusteredLightPS,
		combinePS: combinePS,
		cookiePS: cookiePS,
		cubeMapProjectBoxPS: cubeMapProjectBoxPS,
		cubeMapProjectNonePS: cubeMapProjectNonePS,
		cubeMapRotatePS: cubeMapRotatePS,
		debugOutputPS: debugOutputPS,
		debugProcessFrontendPS: debugProcessFrontendPS,
		detailModesPS: detailModesPS,
		diffusePS: diffusePS,
		diffuseDetailMapPS: diffuseDetailMapPS,
		decodePS: decodePS,
		emissivePS: emissivePS,
		encodePS: encodePS,
		endPS: endPS,
		endVS: endVS,
		envAtlasPS: envAtlasPS,
		envConstPS: envConstPS,
		envMultiplyPS: envMultiplyPS,
		extensionPS: extensionPS,
		extensionVS: extensionVS,
		falloffInvSquaredPS: falloffInvSquaredPS,
		falloffLinearPS: falloffLinearPS,
		fixCubemapSeamsNonePS: fixCubemapSeamsNonePS,
		fixCubemapSeamsStretchPS: fixCubemapSeamsStretchPS,
		floatUnpackingPS: floatUnpackingPS,
		fogExpPS: fogExpPS,
		fogExp2PS: fogExp2PS,
		fogLinearPS: fogLinearPS,
		fogNonePS: fogNonePS,
		fresnelSchlickPS: fresnelSchlickPS,
		fullscreenQuadPS: fullscreenQuadPS,
		fullscreenQuadVS: fullscreenQuadVS,
		gamma1_0PS: gamma1_0PS,
		gamma2_2PS: gamma2_2PS,
		gles2PS: gles2PS,
		gles3PS: gles3PS,
		gles3VS: gles3VS,
		glossPS: glossPS,
		iridescenceDiffractionPS: iridescenceDiffractionPS,
		iridescencePS: iridescencePS,
		iridescenceThicknessPS: iridescenceThicknessPS,
		instancingVS: instancingVS,
		iorPS: iorPS,
		lightDiffuseLambertPS: lightDiffuseLambertPS,
		lightDirPointPS: lightDirPointPS,
		lightmapAddPS: lightmapAddPS,
		lightmapDirAddPS: lightmapDirAddPS,
		lightmapDirPS: lightmapDirPS,
		lightmapSinglePS: lightmapSinglePS,
		lightSpecularAnisoGGXPS: lightSpecularAnisoGGXPS,
		lightSpecularBlinnPS: lightSpecularBlinnPS,
		lightSpecularPhongPS: lightSpecularPhongPS,
		lightSheenPS: lightSheenPS,
		linearizeDepthPS: linearizeDepthPS,
		litShaderArgsPS: litShaderArgsPS,
		ltcPS: ltcPS,
		metalnessPS: metalnessPS,
		metalnessModulatePS: metalnessModulatePS,
		msdfPS: msdfPS,
		msdfVS: msdfVS,
		normalVS: normalVS,
		normalDetailMapPS: normalDetailMapPS,
		normalInstancedVS: normalInstancedVS,
		normalMapPS: normalMapPS,
		normalSkinnedVS: normalSkinnedVS,
		normalXYPS: normalXYPS,
		normalXYZPS: normalXYZPS,
		opacityPS: opacityPS,
		outputPS: outputPS,
		outputAlphaPS: outputAlphaPS,
		outputAlphaOpaquePS: outputAlphaOpaquePS,
		outputAlphaPremulPS: outputAlphaPremulPS,
		outputTex2DPS: outputTex2DPS,
		packDepthPS: packDepthPS,
		sheenPS: sheenPS,
		sheenGlossPS: sheenGlossPS,
		parallaxPS: parallaxPS,
		particlePS: particlePS,
		particleVS: particleVS,
		particleAnimFrameClampVS: particleAnimFrameClampVS,
		particleAnimFrameLoopVS: particleAnimFrameLoopVS,
		particleAnimTexVS: particleAnimTexVS,
		particleInputFloatPS: particleInputFloatPS,
		particleInputRgba8PS: particleInputRgba8PS,
		particleOutputFloatPS: particleOutputFloatPS,
		particleOutputRgba8PS: particleOutputRgba8PS,
		particleUpdaterAABBPS: particleUpdaterAABBPS,
		particleUpdaterEndPS: particleUpdaterEndPS,
		particleUpdaterInitPS: particleUpdaterInitPS,
		particleUpdaterNoRespawnPS: particleUpdaterNoRespawnPS,
		particleUpdaterOnStopPS: particleUpdaterOnStopPS,
		particleUpdaterRespawnPS: particleUpdaterRespawnPS,
		particleUpdaterSpherePS: particleUpdaterSpherePS,
		particleUpdaterStartPS: particleUpdaterStartPS,
		particle_billboardVS: particle_billboardVS,
		particle_blendAddPS: particle_blendAddPS,
		particle_blendMultiplyPS: particle_blendMultiplyPS,
		particle_blendNormalPS: particle_blendNormalPS,
		particle_cpuVS: particle_cpuVS,
		particle_cpu_endVS: particle_cpu_endVS,
		particle_customFaceVS: particle_customFaceVS,
		particle_endPS: particle_endPS,
		particle_endVS: particle_endVS,
		particle_halflambertPS: particle_halflambertPS,
		particle_initVS: particle_initVS,
		particle_lambertPS: particle_lambertPS,
		particle_lightingPS: particle_lightingPS,
		particle_localShiftVS: particle_localShiftVS,
		particle_meshVS: particle_meshVS,
		particle_normalVS: particle_normalVS,
		particle_normalMapPS: particle_normalMapPS,
		particle_pointAlongVS: particle_pointAlongVS,
		particle_softPS: particle_softPS,
		particle_softVS: particle_softVS,
		particle_stretchVS: particle_stretchVS,
		particle_TBNVS: particle_TBNVS,
		particle_wrapVS: particle_wrapVS,
		reflDirPS: reflDirPS,
		reflDirAnisoPS: reflDirAnisoPS,
		reflectionCCPS: reflectionCCPS,
		reflectionCubePS: reflectionCubePS,
		reflectionEnvHQPS: reflectionEnvHQPS,
		reflectionEnvPS: reflectionEnvPS,
		reflectionSpherePS: reflectionSpherePS,
		reflectionSphereLowPS: reflectionSphereLowPS,
		reflectionSheenPS: reflectionSheenPS,
		refractionCubePS: refractionCubePS,
		refractionDynamicPS: refractionDynamicPS,
		reprojectPS: reprojectPS,
		screenDepthPS: screenDepthPS,
		shadowCascadesPS: shadowCascadesPS,
		shadowEVSMPS: shadowEVSMPS,
		shadowEVSMnPS: shadowEVSMnPS,
		shadowPCSSPS: shadowPCSSPS,
		shadowSampleCoordPS: shadowSampleCoordPS,
		shadowStandardPS: shadowStandardPS,
		shadowStandardGL2PS: shadowStandardGL2PS,
		shadowVSM8PS: shadowVSM8PS,
		shadowVSM_commonPS: shadowVSM_commonPS,
		skinBatchConstVS: skinBatchConstVS,
		skinBatchTexVS: skinBatchTexVS,
		skinConstVS: skinConstVS,
		skinTexVS: skinTexVS,
		skyboxEnvPS: skyboxEnvPS,
		skyboxHDRPS: skyboxHDRPS,
		skyboxVS: skyboxVS,
		specularPS: specularPS,
		sphericalPS: sphericalPS,
		specularityFactorPS: specularityFactorPS,
		spotPS: spotPS,
		startPS: startPS,
		startVS: startVS,
		startNineSlicedPS: startNineSlicedPS,
		startNineSlicedTiledPS: startNineSlicedTiledPS,
		storeEVSMPS: storeEVSMPS,
		tangentBinormalVS: tangentBinormalVS,
		TBNPS: TBNPS,
		TBNderivativePS: TBNderivativePS,
		TBNfastPS: TBNfastPS,
		TBNObjectSpacePS: TBNObjectSpacePS,
		textureSamplePS: textureSamplePS,
		thicknessPS: thicknessPS,
		tonemappingAcesPS: tonemappingAcesPS,
		tonemappingAces2PS: tonemappingAces2PS,
		tonemappingFilmicPS: tonemappingFilmicPS,
		tonemappingHejlPS: tonemappingHejlPS,
		tonemappingLinearPS: tonemappingLinearPS,
		tonemappingNonePS: tonemappingNonePS,
		transformVS: transformVS,
		transformDeclVS: transformDeclVS,
		transmissionPS: transmissionPS,
		uv0VS: uv0VS,
		uv1VS: uv1VS,
		viewDirPS: viewDirPS,
		viewNormalVS: viewNormalVS,
		webgpuPS: webgpuPS,
		webgpuVS: webgpuVS
	};

	var programLibraryDeviceCache = new DeviceCache();
	function getProgramLibrary(device) {
		var library = programLibraryDeviceCache.get(device);
		return library;
	}
	function setProgramLibrary(device, library) {
		programLibraryDeviceCache.get(device, function () {
			return library;
		});
	}

	var ShaderGenerator = function () {
		function ShaderGenerator() {}
		ShaderGenerator.begin = function begin() {
			return 'void main(void)\n{\n';
		};
		ShaderGenerator.end = function end() {
			return '}\n';
		};
		ShaderGenerator.skinCode = function skinCode(device, chunks) {
			if (!chunks) chunks = shaderChunks;
			if (device.supportsBoneTextures) {
				return chunks.skinTexVS;
			}
			return "#define BONE_LIMIT " + device.getBoneLimit() + "\n" + chunks.skinConstVS;
		};
		ShaderGenerator.fogCode = function fogCode(value, chunks) {
			if (!chunks) chunks = shaderChunks;
			if (value === 'linear') {
				return chunks.fogLinearPS ? chunks.fogLinearPS : shaderChunks.fogLinearPS;
			} else if (value === 'exp') {
				return chunks.fogExpPS ? chunks.fogExpPS : shaderChunks.fogExpPS;
			} else if (value === 'exp2') {
				return chunks.fogExp2PS ? chunks.fogExp2PS : shaderChunks.fogExp2PS;
			}
			return chunks.fogNonePS ? chunks.fogNonePS : shaderChunks.fogNonePS;
		};
		ShaderGenerator.gammaCode = function gammaCode(value, chunks) {
			if (!chunks) chunks = shaderChunks;
			if (value === GAMMA_SRGB || value === GAMMA_SRGBFAST) {
				return chunks.gamma2_2PS ? chunks.gamma2_2PS : shaderChunks.gamma2_2PS;
			} else if (value === GAMMA_SRGBHDR) {
				return "#define HDR\n" + (chunks.gamma2_2PS ? chunks.gamma2_2PS : shaderChunks.gamma2_2PS);
			}
			return chunks.gamma1_0PS ? chunks.gamma1_0PS : shaderChunks.gamma1_0PS;
		};
		ShaderGenerator.tonemapCode = function tonemapCode(value, chunks) {
			if (!chunks) chunks = shaderChunks;
			if (value === TONEMAP_FILMIC) {
				return chunks.tonemappingFilmicPS ? chunks.tonemappingFilmicPS : shaderChunks.tonemappingFilmicPS;
			} else if (value === TONEMAP_LINEAR) {
				return chunks.tonemappingLinearPS ? chunks.tonemappingLinearPS : shaderChunks.tonemappingLinearPS;
			} else if (value === TONEMAP_HEJL) {
				return chunks.tonemappingHejlPS ? chunks.tonemappingHejlPS : shaderChunks.tonemappingHejlPS;
			} else if (value === TONEMAP_ACES) {
				return chunks.tonemappingAcesPS ? chunks.tonemappingAcesPS : shaderChunks.tonemappingAcesPS;
			} else if (value === TONEMAP_ACES2) {
				return chunks.tonemappingAces2PS ? chunks.tonemappingAces2PS : shaderChunks.tonemappingAces2PS;
			}
			return chunks.tonemapingNonePS ? chunks.tonemapingNonePS : shaderChunks.tonemappingNonePS;
		};
		return ShaderGenerator;
	}();

	function createShader(device, vsName, fsName, useTransformFeedback) {
		if (useTransformFeedback === void 0) {
			useTransformFeedback = false;
		}
		return new Shader(device, ShaderUtils.createDefinition(device, {
			name: vsName + "_" + fsName,
			vertexCode: shaderChunks[vsName],
			fragmentCode: shaderChunks[fsName],
			useTransformFeedback: useTransformFeedback
		}));
	}
	function createShaderFromCode(device, vsCode, fsCode, uniqueName, attributes, useTransformFeedback) {
		if (useTransformFeedback === void 0) {
			useTransformFeedback = false;
		}
		var programLibrary = getProgramLibrary(device);
		var shader = programLibrary.getCachedShader(uniqueName);
		if (!shader) {
			shader = new Shader(device, ShaderUtils.createDefinition(device, {
				name: uniqueName,
				vertexCode: vsCode,
				fragmentCode: fsCode,
				attributes: attributes,
				useTransformFeedback: useTransformFeedback
			}));
			programLibrary.setCachedShader(uniqueName, shader);
		}
		return shader;
	}
	var ShaderGeneratorPassThrough = function (_ShaderGenerator) {
		_inheritsLoose(ShaderGeneratorPassThrough, _ShaderGenerator);
		function ShaderGeneratorPassThrough(key, shaderDefinition) {
			var _this;
			_this = _ShaderGenerator.call(this) || this;
			_this.key = key;
			_this.shaderDefinition = shaderDefinition;
			return _this;
		}
		var _proto = ShaderGeneratorPassThrough.prototype;
		_proto.generateKey = function generateKey(options) {
			return this.key;
		};
		_proto.createShaderDefinition = function createShaderDefinition(device, options) {
			return this.shaderDefinition;
		};
		return ShaderGeneratorPassThrough;
	}(ShaderGenerator);
	function processShader(shader, processingOptions) {
		var _shaderDefinition$nam;
		var shaderDefinition = shader.definition;
		var name = (_shaderDefinition$nam = shaderDefinition.name) != null ? _shaderDefinition$nam : 'shader';
		var key = name + "-id-" + shader.id;
		var materialGenerator = new ShaderGeneratorPassThrough(key, shaderDefinition);
		var libraryModuleName = 'shader';
		var library = getProgramLibrary(shader.device);
		library.register(libraryModuleName, materialGenerator);
		var variant = library.getProgram(libraryModuleName, {}, processingOptions);
		library.unregister(libraryModuleName);
		return variant;
	}
	shaderChunks.createShader = createShader;
	shaderChunks.createShaderFromCode = createShaderFromCode;

	var _quadPrimitive = {
		type: PRIMITIVE_TRISTRIP,
		base: 0,
		count: 4,
		indexed: false
	};
	var _tempViewport = new Vec4();
	var _tempScissor = new Vec4();
	var QuadRender = function () {
		function QuadRender(shader) {
			this.uniformBuffer = void 0;
			this.bindGroup = void 0;
			var device = shader.device;
			this.shader = shader;
			if (device.supportsUniformBuffers) {
				var processingOptions = new ShaderProcessorOptions();
				this.shader = processShader(shader, processingOptions);
				var ubFormat = this.shader.meshUniformBufferFormat;
				if (ubFormat) {
					this.uniformBuffer = new UniformBuffer(device, ubFormat, false);
				}
				var bindGroupFormat = this.shader.meshBindGroupFormat;
				this.bindGroup = new BindGroup(device, bindGroupFormat, this.uniformBuffer);
			}
		}
		var _proto = QuadRender.prototype;
		_proto.destroy = function destroy() {
			var _this$uniformBuffer, _this$bindGroup;
			(_this$uniformBuffer = this.uniformBuffer) == null || _this$uniformBuffer.destroy();
			this.uniformBuffer = null;
			(_this$bindGroup = this.bindGroup) == null || _this$bindGroup.destroy();
			this.bindGroup = null;
		};
		_proto.render = function render(viewport, scissor) {
			var device = this.shader.device;
			if (viewport) {
				var _scissor;
				_tempViewport.set(device.vx, device.vy, device.vw, device.vh);
				_tempScissor.set(device.sx, device.sy, device.sw, device.sh);
				scissor = (_scissor = scissor) != null ? _scissor : viewport;
				device.setViewport(viewport.x, viewport.y, viewport.z, viewport.w);
				device.setScissor(scissor.x, scissor.y, scissor.z, scissor.w);
			}
			device.setVertexBuffer(device.quadVertexBuffer, 0);
			var shader = this.shader;
			device.setShader(shader);
			if (device.supportsUniformBuffers) {
				var _bindGroup$defaultUni;
				var bindGroup = this.bindGroup;
				(_bindGroup$defaultUni = bindGroup.defaultUniformBuffer) == null || _bindGroup$defaultUni.update();
				bindGroup.update();
				device.setBindGroup(BINDGROUP_MESH, bindGroup);
			}
			device.draw(_quadPrimitive);
			if (viewport) {
				device.setViewport(_tempViewport.x, _tempViewport.y, _tempViewport.z, _tempViewport.w);
				device.setScissor(_tempScissor.x, _tempScissor.y, _tempScissor.z, _tempScissor.w);
			}
		};
		return QuadRender;
	}();

	var RenderPassQuad = function (_RenderPass) {
		_inheritsLoose(RenderPassQuad, _RenderPass);
		function RenderPassQuad(device, quad, rect, scissorRect) {
			var _this;
			_this = _RenderPass.call(this, device) || this;
			_this.quad = quad;
			_this.rect = rect;
			_this.scissorRect = scissorRect;
			return _this;
		}
		var _proto = RenderPassQuad.prototype;
		_proto.execute = function execute() {
			var device = this.device;
			device.setCullMode(CULLFACE_NONE);
			device.setDepthState(DepthState.NODEPTH);
			device.setStencilState(null, null);
			this.quad.render(this.rect, this.scissorRect);
		};
		return RenderPassQuad;
	}(RenderPass);

	var _tempRect = new Vec4();
	function drawQuadWithShader(device, target, shader, rect, scissorRect) {
		var quad = new QuadRender(shader);
		if (!rect) {
			rect = _tempRect;
			rect.x = 0;
			rect.y = 0;
			rect.z = target ? target.width : device.width;
			rect.w = target ? target.height : device.height;
		}
		var renderPass = new RenderPassQuad(device, quad, rect, scissorRect);
		renderPass.init(target);
		renderPass.colorOps.clear = false;
		renderPass.depthStencilOps.clearDepth = false;
		if (device.isWebGPU && target === null && device.samples > 1) {
			renderPass.colorOps.store = true;
		}
		renderPass.render();
		quad.destroy();
	}
	function drawTexture(device, texture, target, shader, rect, scissorRect) {
		shader = shader || device.getCopyShader();
		device.constantTexSource.setValue(texture);
		drawQuadWithShader(device, target, shader, rect, scissorRect);
	}

	var shaderPassDeviceCache = new DeviceCache();
	var ShaderPassInfo = function () {
		function ShaderPassInfo(name, index, options) {
			if (options === void 0) {
				options = {};
			}
			this.index = void 0;
			this.name = void 0;
			this.shaderDefine = void 0;
			this.name = name;
			this.index = index;
			Object.assign(this, options);
			this.initShaderDefines();
		}
		var _proto = ShaderPassInfo.prototype;
		_proto.initShaderDefines = function initShaderDefines() {
			var keyword;
			if (this.isShadow) {
				keyword = 'SHADOW';
			} else if (this.isForward) {
				keyword = 'FORWARD';
			} else if (this.index === SHADER_DEPTH) {
				keyword = 'DEPTH';
			} else if (this.index === SHADER_PICK) {
				keyword = 'PICK';
			}
			var define1 = keyword ? "#define " + keyword + "_PASS\n" : '';
			var define2 = "#define " + this.name.toUpperCase() + "_PASS\n";
			this.shaderDefines = define1 + define2;
		};
		return ShaderPassInfo;
	}();
	var ShaderPass = function () {
		function ShaderPass() {
			var _this = this;
			this.passesNamed = new Map();
			this.passesIndexed = [];
			this.nextIndex = 0;
			var add = function add(name, index, options) {
				_this.allocate(name, options);
			};
			add('forward', SHADER_FORWARD, {
				isForward: true
			});
			add('forward_hdr', SHADER_FORWARDHDR, {
				isForward: true
			});
			add('depth');
			add('pick');
			add('shadow');
		}
		ShaderPass.get = function get(device) {
			return shaderPassDeviceCache.get(device, function () {
				return new ShaderPass();
			});
		};
		var _proto2 = ShaderPass.prototype;
		_proto2.allocate = function allocate(name, options) {
			var info = this.passesNamed.get(name);
			if (info === undefined) {
				info = new ShaderPassInfo(name, this.nextIndex, options);
				this.passesNamed.set(info.name, info);
				this.passesIndexed[info.index] = info;
				this.nextIndex++;
			}
			return info;
		};
		_proto2.getByIndex = function getByIndex(index) {
			var info = this.passesIndexed[index];
			return info;
		};
		_proto2.getByName = function getByName(name) {
			return this.passesNamed.get(name);
		};
		return ShaderPass;
	}();

	var ShaderGeneratorBasic = function (_ShaderGenerator) {
		_inheritsLoose(ShaderGeneratorBasic, _ShaderGenerator);
		function ShaderGeneratorBasic() {
			return _ShaderGenerator.apply(this, arguments) || this;
		}
		var _proto = ShaderGeneratorBasic.prototype;
		_proto.generateKey = function generateKey(options) {
			var key = 'basic';
			if (options.fog) key += '_fog';
			if (options.alphaTest) key += '_atst';
			if (options.vertexColors) key += '_vcol';
			if (options.diffuseMap) key += '_diff';
			if (options.skin) key += '_skin';
			if (options.screenSpace) key += '_ss';
			if (options.useInstancing) key += '_inst';
			if (options.useMorphPosition) key += '_morphp';
			if (options.useMorphNormal) key += '_morphn';
			if (options.useMorphTextureBased) key += '_morpht';
			key += '_' + options.pass;
			return key;
		};
		_proto.createShaderDefinition = function createShaderDefinition(device, options) {
			var attributes = {
				vertex_position: SEMANTIC_POSITION
			};
			if (options.skin) {
				attributes.vertex_boneWeights = SEMANTIC_BLENDWEIGHT;
				attributes.vertex_boneIndices = SEMANTIC_BLENDINDICES;
			}
			if (options.vertexColors) {
				attributes.vertex_color = SEMANTIC_COLOR;
			}
			if (options.diffuseMap) {
				attributes.vertex_texCoord0 = SEMANTIC_TEXCOORD0;
			}
			var shaderPassInfo = ShaderPass.get(device).getByIndex(options.pass);
			var shaderPassDefines = shaderPassInfo.shaderDefines;
			var vshader = shaderPassDefines;
			vshader += shaderChunks.transformDeclVS;
			if (options.skin) {
				vshader += ShaderGenerator.skinCode(device);
				vshader += shaderChunks.transformSkinnedVS;
			} else {
				vshader += shaderChunks.transformVS;
			}
			if (options.vertexColors) {
				vshader += 'attribute vec4 vertex_color;\n';
				vshader += 'varying vec4 vColor;\n';
			}
			if (options.diffuseMap) {
				vshader += 'attribute vec2 vertex_texCoord0;\n';
				vshader += 'varying vec2 vUv0;\n';
			}
			if (options.pass === SHADER_DEPTH) {
				vshader += 'varying float vDepth;\n';
				vshader += '#ifndef VIEWMATRIX\n';
				vshader += '#define VIEWMATRIX\n';
				vshader += 'uniform mat4 matrix_view;\n';
				vshader += '#endif\n';
				vshader += '#ifndef CAMERAPLANES\n';
				vshader += '#define CAMERAPLANES\n';
				vshader += 'uniform vec4 camera_params;\n\n';
				vshader += '#endif\n';
			}
			vshader += ShaderGenerator.begin();
			vshader += "   gl_Position = getPosition();\n";
			if (options.pass === SHADER_DEPTH) {
				vshader += "    vDepth = -(matrix_view * vec4(getWorldPosition(),1.0)).z * camera_params.x;\n";
			}
			if (options.vertexColors) {
				vshader += '    vColor = vertex_color;\n';
			}
			if (options.diffuseMap) {
				vshader += '    vUv0 = vertex_texCoord0;\n';
			}
			vshader += ShaderGenerator.end();
			var fshader = shaderPassDefines;
			if (options.vertexColors) {
				fshader += 'varying vec4 vColor;\n';
			} else {
				fshader += 'uniform vec4 uColor;\n';
			}
			if (options.diffuseMap) {
				fshader += 'varying vec2 vUv0;\n';
				fshader += 'uniform sampler2D texture_diffuseMap;\n';
			}
			if (options.fog) {
				fshader += ShaderGenerator.fogCode(options.fog);
			}
			if (options.alphaTest) {
				fshader += shaderChunks.alphaTestPS;
			}
			if (options.pass === SHADER_DEPTH) {
				fshader += 'varying float vDepth;\n';
				fshader += shaderChunks.packDepthPS;
			}
			fshader += ShaderGenerator.begin();
			if (options.vertexColors) {
				fshader += '    gl_FragColor = vColor;\n';
			} else {
				fshader += '    gl_FragColor = uColor;\n';
			}
			if (options.diffuseMap) {
				fshader += '    gl_FragColor *= texture2D(texture_diffuseMap, vUv0);\n';
			}
			if (options.alphaTest) {
				fshader += "   alphaTest(gl_FragColor.a);\n";
			}
			if (options.pass !== SHADER_PICK) {
				if (options.pass === SHADER_DEPTH) {
					fshader += "    gl_FragColor = packFloat(vDepth);\n";
				} else {
					if (options.fog) {
						fshader += "   glFragColor.rgb = addFog(gl_FragColor.rgb);\n";
					}
				}
			}
			fshader += ShaderGenerator.end();
			return ShaderUtils.createDefinition(device, {
				name: 'BasicShader',
				attributes: attributes,
				vertexCode: vshader,
				fragmentCode: fshader
			});
		};
		return ShaderGeneratorBasic;
	}(ShaderGenerator);
	var basic = new ShaderGeneratorBasic();

	var defaultMaterialDeviceCache = new DeviceCache();
	function getDefaultMaterial(device) {
		var material = defaultMaterialDeviceCache.get(device);
		return material;
	}
	function setDefaultMaterial(device, material) {
		defaultMaterialDeviceCache.get(device, function () {
			return material;
		});
	}

	var blendModes = [];
	blendModes[BLEND_SUBTRACTIVE] = {
		src: BLENDMODE_ONE,
		dst: BLENDMODE_ONE,
		op: BLENDEQUATION_REVERSE_SUBTRACT
	};
	blendModes[BLEND_NONE] = {
		src: BLENDMODE_ONE,
		dst: BLENDMODE_ZERO,
		op: BLENDEQUATION_ADD
	};
	blendModes[BLEND_NORMAL] = {
		src: BLENDMODE_SRC_ALPHA,
		dst: BLENDMODE_ONE_MINUS_SRC_ALPHA,
		op: BLENDEQUATION_ADD
	};
	blendModes[BLEND_PREMULTIPLIED] = {
		src: BLENDMODE_ONE,
		dst: BLENDMODE_ONE_MINUS_SRC_ALPHA,
		op: BLENDEQUATION_ADD
	};
	blendModes[BLEND_ADDITIVE] = {
		src: BLENDMODE_ONE,
		dst: BLENDMODE_ONE,
		op: BLENDEQUATION_ADD
	};
	blendModes[BLEND_ADDITIVEALPHA] = {
		src: BLENDMODE_SRC_ALPHA,
		dst: BLENDMODE_ONE,
		op: BLENDEQUATION_ADD
	};
	blendModes[BLEND_MULTIPLICATIVE2X] = {
		src: BLENDMODE_DST_COLOR,
		dst: BLENDMODE_SRC_COLOR,
		op: BLENDEQUATION_ADD
	};
	blendModes[BLEND_SCREEN] = {
		src: BLENDMODE_ONE_MINUS_DST_COLOR,
		dst: BLENDMODE_ONE,
		op: BLENDEQUATION_ADD
	};
	blendModes[BLEND_MULTIPLICATIVE] = {
		src: BLENDMODE_DST_COLOR,
		dst: BLENDMODE_ZERO,
		op: BLENDEQUATION_ADD
	};
	blendModes[BLEND_MIN] = {
		src: BLENDMODE_ONE,
		dst: BLENDMODE_ONE,
		op: BLENDEQUATION_MIN
	};
	blendModes[BLEND_MAX] = {
		src: BLENDMODE_ONE,
		dst: BLENDMODE_ONE,
		op: BLENDEQUATION_MAX
	};
	var id$2 = 0;
	var Material = function () {
		function Material() {
			this._shader = null;
			this.meshInstances = [];
			this.name = 'Untitled';
			this.userId = '';
			this.id = id$2++;
			this.variants = new Map();
			this.parameters = {};
			this.alphaTest = 0;
			this.alphaToCoverage = false;
			this._blendState = new BlendState();
			this._depthState = new DepthState();
			this.cull = CULLFACE_BACK;
			this.stencilFront = null;
			this.stencilBack = null;
			this.depthBias = 0;
			this.slopeDepthBias = 0;
			this._shaderVersion = 0;
			this._scene = null;
			this.dirty = true;
		}
		var _proto = Material.prototype;
		_proto._updateTransparency = function _updateTransparency() {
			var transparent = this.transparent;
			var meshInstances = this.meshInstances;
			for (var i = 0; i < meshInstances.length; i++) {
				meshInstances[i].transparent = transparent;
			}
		};
		_proto.copy = function copy(source) {
			var _source$stencilFront;
			this.name = source.name;
			this._shader = source._shader;
			this.alphaTest = source.alphaTest;
			this.alphaToCoverage = source.alphaToCoverage;
			this._blendState.copy(source._blendState);
			this._depthState.copy(source._depthState);
			this.cull = source.cull;
			this.depthBias = source.depthBias;
			this.slopeDepthBias = source.slopeDepthBias;
			this.stencilFront = (_source$stencilFront = source.stencilFront) == null ? void 0 : _source$stencilFront.clone();
			if (source.stencilBack) {
				this.stencilBack = source.stencilFront === source.stencilBack ? this.stencilFront : source.stencilBack.clone();
			}
			return this;
		};
		_proto.clone = function clone() {
			var clone = new this.constructor();
			return clone.copy(this);
		};
		_proto._updateMeshInstanceKeys = function _updateMeshInstanceKeys() {
			var meshInstances = this.meshInstances;
			for (var i = 0; i < meshInstances.length; i++) {
				meshInstances[i].updateKey();
			}
		};
		_proto.updateUniforms = function updateUniforms(device, scene) {};
		_proto.getShaderVariant = function getShaderVariant(device, scene, objDefs, unused, pass, sortedLights, viewUniformFormat, viewBindGroupFormat, vertexFormat) {
			var processingOptions = new ShaderProcessorOptions(viewUniformFormat, viewBindGroupFormat, vertexFormat);
			return processShader(this._shader, processingOptions);
		};
		_proto.update = function update() {
			this.dirty = true;
			if (this._shader) this._shader.failed = false;
		};
		_proto.clearParameters = function clearParameters() {
			this.parameters = {};
		};
		_proto.getParameters = function getParameters() {
			return this.parameters;
		};
		_proto.clearVariants = function clearVariants() {
			this.variants.clear();
			var meshInstances = this.meshInstances;
			var count = meshInstances.length;
			for (var i = 0; i < count; i++) {
				meshInstances[i].clearShaders();
			}
		};
		_proto.getParameter = function getParameter(name) {
			return this.parameters[name];
		};
		_proto.setParameter = function setParameter(name, data) {
			if (data === undefined && typeof name === 'object') {
				var uniformObject = name;
				if (uniformObject.length) {
					for (var i = 0; i < uniformObject.length; i++) {
						this.setParameter(uniformObject[i]);
					}
					return;
				}
				name = uniformObject.name;
				data = uniformObject.value;
			}
			var param = this.parameters[name];
			if (param) {
				param.data = data;
			} else {
				this.parameters[name] = {
					scopeId: null,
					data: data
				};
			}
		};
		_proto.deleteParameter = function deleteParameter(name) {
			if (this.parameters[name]) {
				delete this.parameters[name];
			}
		};
		_proto.setParameters = function setParameters(device, names) {
			var parameters = this.parameters;
			if (names === undefined) names = parameters;
			for (var paramName in names) {
				var parameter = parameters[paramName];
				if (parameter) {
					if (!parameter.scopeId) {
						parameter.scopeId = device.scope.resolve(paramName);
					}
					parameter.scopeId.setValue(parameter.data);
				}
			}
		};
		_proto.destroy = function destroy() {
			this.variants.clear();
			this._shader = null;
			for (var i = 0; i < this.meshInstances.length; i++) {
				var meshInstance = this.meshInstances[i];
				meshInstance.clearShaders();
				meshInstance._material = null;
				if (meshInstance.mesh) {
					var defaultMaterial = getDefaultMaterial(meshInstance.mesh.device);
					if (this !== defaultMaterial) {
						meshInstance.material = defaultMaterial;
					}
				}
			}
			this.meshInstances.length = 0;
		};
		_proto.addMeshInstanceRef = function addMeshInstanceRef(meshInstance) {
			this.meshInstances.push(meshInstance);
		};
		_proto.removeMeshInstanceRef = function removeMeshInstanceRef(meshInstance) {
			var meshInstances = this.meshInstances;
			var i = meshInstances.indexOf(meshInstance);
			if (i !== -1) {
				meshInstances.splice(i, 1);
			}
		};
		_createClass(Material, [{
			key: "redWrite",
			get: function get() {
				return this._blendState.redWrite;
			},
			set: function set(value) {
				this._blendState.redWrite = value;
			}
		}, {
			key: "greenWrite",
			get: function get() {
				return this._blendState.greenWrite;
			},
			set: function set(value) {
				this._blendState.greenWrite = value;
			}
		}, {
			key: "blueWrite",
			get: function get() {
				return this._blendState.blueWrite;
			},
			set: function set(value) {
				this._blendState.blueWrite = value;
			}
		}, {
			key: "alphaWrite",
			get: function get() {
				return this._blendState.alphaWrite;
			},
			set: function set(value) {
				this._blendState.alphaWrite = value;
			}
		}, {
			key: "shader",
			get: function get() {
				return this._shader;
			},
			set: function set(shader) {
				this._shader = shader;
			}
		}, {
			key: "transparent",
			get: function get() {
				return this._blendState.blend;
			}
		}, {
			key: "blendState",
			get: function get() {
				return this._blendState;
			},
			set: function set(value) {
				this._blendState.copy(value);
				this._updateTransparency();
			}
		}, {
			key: "blendType",
			get: function get() {
				if (!this.transparent) {
					return BLEND_NONE;
				}
				var _this$_blendState = this._blendState,
					colorOp = _this$_blendState.colorOp,
					colorSrcFactor = _this$_blendState.colorSrcFactor,
					colorDstFactor = _this$_blendState.colorDstFactor,
					alphaOp = _this$_blendState.alphaOp,
					alphaSrcFactor = _this$_blendState.alphaSrcFactor,
					alphaDstFactor = _this$_blendState.alphaDstFactor;
				for (var i = 0; i < blendModes.length; i++) {
					var blendMode = blendModes[i];
					if (blendMode.src === colorSrcFactor && blendMode.dst === colorDstFactor && blendMode.op === colorOp && blendMode.src === alphaSrcFactor && blendMode.dst === alphaDstFactor && blendMode.op === alphaOp) {
						return i;
					}
				}
				return BLEND_NORMAL;
			},
			set: function set(type) {
				var blendMode = blendModes[type];
				this._blendState.setColorBlend(blendMode.op, blendMode.src, blendMode.dst);
				this._blendState.setAlphaBlend(blendMode.op, blendMode.src, blendMode.dst);
				var blend = type !== BLEND_NONE;
				if (this._blendState.blend !== blend) {
					this._blendState.blend = blend;
					this._updateTransparency();
				}
				this._updateMeshInstanceKeys();
			}
		}, {
			key: "depthState",
			get: function get() {
				return this._depthState;
			},
			set: function set(value) {
				this._depthState.copy(value);
			}
		}, {
			key: "depthTest",
			get: function get() {
				return this._depthState.test;
			},
			set: function set(value) {
				this._depthState.test = value;
			}
		}, {
			key: "depthFunc",
			get: function get() {
				return this._depthState.func;
			},
			set: function set(value) {
				this._depthState.func = value;
			}
		}, {
			key: "depthWrite",
			get: function get() {
				return this._depthState.write;
			},
			set: function set(value) {
				this._depthState.write = value;
			}
		}]);
		return Material;
	}();

	var BasicMaterial = function (_Material) {
		_inheritsLoose(BasicMaterial, _Material);
		function BasicMaterial() {
			var _this;
			for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}
			_this = _Material.call.apply(_Material, [this].concat(args)) || this;
			_this.color = new Color(1, 1, 1, 1);
			_this.colorUniform = new Float32Array(4);
			_this.colorMap = null;
			_this.vertexColors = false;
			return _this;
		}
		var _proto = BasicMaterial.prototype;
		_proto.copy = function copy(source) {
			_Material.prototype.copy.call(this, source);
			this.color.copy(source.color);
			this.colorMap = source.colorMap;
			this.vertexColors = source.vertexColors;
			return this;
		};
		_proto.updateUniforms = function updateUniforms(device, scene) {
			this.clearParameters();
			this.colorUniform[0] = this.color.r;
			this.colorUniform[1] = this.color.g;
			this.colorUniform[2] = this.color.b;
			this.colorUniform[3] = this.color.a;
			this.setParameter('uColor', this.colorUniform);
			if (this.colorMap) {
				this.setParameter('texture_diffuseMap', this.colorMap);
			}
		};
		_proto.getShaderVariant = function getShaderVariant(device, scene, objDefs, unused, pass, sortedLights, viewUniformFormat, viewBindGroupFormat, vertexFormat) {
			var options = {
				skin: objDefs && (objDefs & SHADERDEF_SKIN) !== 0,
				screenSpace: objDefs && (objDefs & SHADERDEF_SCREENSPACE) !== 0,
				useInstancing: objDefs && (objDefs & SHADERDEF_INSTANCING) !== 0,
				useMorphPosition: objDefs && (objDefs & SHADERDEF_MORPH_POSITION) !== 0,
				useMorphNormal: objDefs && (objDefs & SHADERDEF_MORPH_NORMAL) !== 0,
				useMorphTextureBased: objDefs && (objDefs & SHADERDEF_MORPH_TEXTURE_BASED) !== 0,
				alphaTest: this.alphaTest > 0,
				vertexColors: this.vertexColors,
				diffuseMap: !!this.colorMap,
				pass: pass
			};
			var processingOptions = new ShaderProcessorOptions(viewUniformFormat, viewBindGroupFormat, vertexFormat);
			var library = getProgramLibrary(device);
			library.register('basic', basic);
			return library.getProgram('basic', options, processingOptions, this.userId);
		};
		return BasicMaterial;
	}(Material);

	var Batch = function () {
		function Batch(meshInstances, dynamic, batchGroupId) {
			this._aabb = new BoundingBox();
			this.origMeshInstances = void 0;
			this.meshInstance = null;
			this.dynamic = void 0;
			this.batchGroupId = void 0;
			this.origMeshInstances = meshInstances;
			this.dynamic = dynamic;
			this.batchGroupId = batchGroupId;
		}
		var _proto = Batch.prototype;
		_proto.destroy = function destroy(scene, layers) {
			if (this.meshInstance) {
				this.removeFromLayers(scene, layers);
				this.meshInstance.destroy();
				this.meshInstance = null;
			}
		};
		_proto.addToLayers = function addToLayers(scene, layers) {
			for (var i = 0; i < layers.length; i++) {
				var layer = scene.layers.getLayerById(layers[i]);
				if (layer) {
					layer.addMeshInstances([this.meshInstance]);
				}
			}
		};
		_proto.removeFromLayers = function removeFromLayers(scene, layers) {
			for (var i = 0; i < layers.length; i++) {
				var layer = scene.layers.getLayerById(layers[i]);
				if (layer) {
					layer.removeMeshInstances([this.meshInstance]);
				}
			}
		};
		_proto.updateBoundingBox = function updateBoundingBox() {
			this._aabb.copy(this.origMeshInstances[0].aabb);
			for (var i = 1; i < this.origMeshInstances.length; i++) {
				this._aabb.add(this.origMeshInstances[i].aabb);
			}
			this.meshInstance.aabb = this._aabb;
			this.meshInstance._aabbVer = 0;
		};
		return Batch;
	}();

	var BatchGroup = function BatchGroup(id, name, dynamic, maxAabbSize, layers) {
		if (layers === void 0) {
			layers = [LAYERID_WORLD];
		}
		this._ui = false;
		this._sprite = false;
		this._obj = {
			model: [],
			element: [],
			sprite: [],
			render: []
		};
		this.id = void 0;
		this.name = void 0;
		this.dynamic = void 0;
		this.maxAabbSize = void 0;
		this.layers = void 0;
		this.id = id;
		this.name = name;
		this.dynamic = dynamic;
		this.maxAabbSize = maxAabbSize;
		this.layers = layers;
	};
	BatchGroup.MODEL = 'model';
	BatchGroup.ELEMENT = 'element';
	BatchGroup.SPRITE = 'sprite';
	BatchGroup.RENDER = 'render';

	var _invMatrix = new Mat4();
	var SkinInstance = function () {
		function SkinInstance(skin) {
			this.bones = void 0;
			this._dirty = true;
			this._rootBone = null;
			this._skinUpdateIndex = -1;
			this._updateBeforeCull = true;
			if (skin) {
				this.initSkin(skin);
			}
		}
		var _proto = SkinInstance.prototype;
		_proto.init = function init(device, numBones) {
			if (device.supportsBoneTextures) {
				var numPixels = numBones * 3;
				var width = Math.ceil(Math.sqrt(numPixels));
				width = math.roundUp(width, 3);
				var height = Math.ceil(numPixels / width);
				this.boneTexture = new Texture(device, {
					width: width,
					height: height,
					format: PIXELFORMAT_RGBA32F,
					mipmaps: false,
					minFilter: FILTER_NEAREST,
					magFilter: FILTER_NEAREST,
					name: 'skin'
				});
				this.matrixPalette = this.boneTexture.lock();
			} else {
				this.matrixPalette = new Float32Array(numBones * 12);
			}
		};
		_proto.destroy = function destroy() {
			if (this.boneTexture) {
				this.boneTexture.destroy();
				this.boneTexture = null;
			}
		};
		_proto.resolve = function resolve(rootBone, entity) {
			this.rootBone = rootBone;
			var skin = this.skin;
			var bones = [];
			for (var j = 0; j < skin.boneNames.length; j++) {
				var boneName = skin.boneNames[j];
				var bone = rootBone.findByName(boneName);
				if (!bone) {
					bone = entity;
				}
				bones.push(bone);
			}
			this.bones = bones;
		};
		_proto.initSkin = function initSkin(skin) {
			this.skin = skin;
			this.bones = [];
			var numBones = skin.inverseBindPose.length;
			this.init(skin.device, numBones);
			this.matrices = [];
			for (var i = 0; i < numBones; i++) {
				this.matrices[i] = new Mat4();
			}
		};
		_proto.uploadBones = function uploadBones(device) {
			if (device.supportsBoneTextures) {
				this.boneTexture.lock();
				this.boneTexture.unlock();
			}
		};
		_proto._updateMatrices = function _updateMatrices(rootNode, skinUpdateIndex) {
			if (this._skinUpdateIndex !== skinUpdateIndex) {
				this._skinUpdateIndex = skinUpdateIndex;
				_invMatrix.copy(rootNode.getWorldTransform()).invert();
				for (var i = this.bones.length - 1; i >= 0; i--) {
					this.matrices[i].mulAffine2(_invMatrix, this.bones[i].getWorldTransform());
					this.matrices[i].mulAffine2(this.matrices[i], this.skin.inverseBindPose[i]);
				}
			}
		};
		_proto.updateMatrices = function updateMatrices(rootNode, skinUpdateIndex) {
			if (this._updateBeforeCull) {
				this._updateMatrices(rootNode, skinUpdateIndex);
			}
		};
		_proto.updateMatrixPalette = function updateMatrixPalette(rootNode, skinUpdateIndex) {
			this._updateMatrices(rootNode, skinUpdateIndex);
			var mp = this.matrixPalette;
			var count = this.bones.length;
			for (var i = 0; i < count; i++) {
				var pe = this.matrices[i].data;
				var base = i * 12;
				mp[base] = pe[0];
				mp[base + 1] = pe[4];
				mp[base + 2] = pe[8];
				mp[base + 3] = pe[12];
				mp[base + 4] = pe[1];
				mp[base + 5] = pe[5];
				mp[base + 6] = pe[9];
				mp[base + 7] = pe[13];
				mp[base + 8] = pe[2];
				mp[base + 9] = pe[6];
				mp[base + 10] = pe[10];
				mp[base + 11] = pe[14];
			}
			this.uploadBones(this.skin.device);
		};
		_createClass(SkinInstance, [{
			key: "rootBone",
			get: function get() {
				return this._rootBone;
			},
			set: function set(rootBone) {
				this._rootBone = rootBone;
			}
		}]);
		return SkinInstance;
	}();

	var SkinBatchInstance = function (_SkinInstance) {
		_inheritsLoose(SkinBatchInstance, _SkinInstance);
		function SkinBatchInstance(device, nodes, rootNode) {
			var _this;
			_this = _SkinInstance.call(this) || this;
			var numBones = nodes.length;
			_this.init(device, numBones);
			_this.device = device;
			_this.rootNode = rootNode;
			_this.bones = nodes;
			return _this;
		}
		var _proto = SkinBatchInstance.prototype;
		_proto.updateMatrices = function updateMatrices(rootNode, skinUpdateIndex) {};
		_proto.updateMatrixPalette = function updateMatrixPalette(rootNode, skinUpdateIndex) {
			var mp = this.matrixPalette;
			var count = this.bones.length;
			for (var i = 0; i < count; i++) {
				var pe = this.bones[i].getWorldTransform().data;
				var base = i * 12;
				mp[base] = pe[0];
				mp[base + 1] = pe[4];
				mp[base + 2] = pe[8];
				mp[base + 3] = pe[12];
				mp[base + 4] = pe[1];
				mp[base + 5] = pe[5];
				mp[base + 6] = pe[9];
				mp[base + 7] = pe[13];
				mp[base + 8] = pe[2];
				mp[base + 9] = pe[6];
				mp[base + 10] = pe[10];
				mp[base + 11] = pe[14];
			}
			this.uploadBones(this.device);
		};
		return SkinBatchInstance;
	}(SkinInstance);

	var scaleCompensatePosTransform = new Mat4();
	var scaleCompensatePos = new Vec3();
	var scaleCompensateRot = new Quat();
	var scaleCompensateRot2 = new Quat();
	var scaleCompensateScale = new Vec3();
	var scaleCompensateScaleForParent = new Vec3();
	var tmpMat4 = new Mat4();
	var tmpQuat = new Quat();
	var position$1 = new Vec3();
	var invParentWtm$1 = new Mat4();
	var rotation = new Quat();
	var invParentRot = new Quat();
	var matrix = new Mat4();
	var target = new Vec3();
	var up = new Vec3();
	var GraphNode = function (_EventHandler) {
		_inheritsLoose(GraphNode, _EventHandler);
		function GraphNode(name) {
			var _this;
			if (name === void 0) {
				name = 'Untitled';
			}
			_this = _EventHandler.call(this) || this;
			_this.name = void 0;
			_this.tags = new Tags(_assertThisInitialized(_this));
			_this._labels = {};
			_this.localPosition = new Vec3();
			_this.localRotation = new Quat();
			_this.localScale = new Vec3(1, 1, 1);
			_this.localEulerAngles = new Vec3();
			_this.position = new Vec3();
			_this.rotation = new Quat();
			_this.eulerAngles = new Vec3();
			_this._scale = null;
			_this.localTransform = new Mat4();
			_this._dirtyLocal = false;
			_this._aabbVer = 0;
			_this._frozen = false;
			_this.worldTransform = new Mat4();
			_this._dirtyWorld = false;
			_this._worldScaleSign = 0;
			_this._normalMatrix = new Mat3();
			_this._dirtyNormal = true;
			_this._right = null;
			_this._up = null;
			_this._forward = null;
			_this._parent = null;
			_this._children = [];
			_this._graphDepth = 0;
			_this._enabled = true;
			_this._enabledInHierarchy = false;
			_this.scaleCompensation = false;
			_this.name = name;
			return _this;
		}
		var _proto = GraphNode.prototype;
		_proto._notifyHierarchyStateChanged = function _notifyHierarchyStateChanged(node, enabled) {
			node._onHierarchyStateChanged(enabled);
			var c = node._children;
			for (var i = 0, len = c.length; i < len; i++) {
				if (c[i]._enabled) this._notifyHierarchyStateChanged(c[i], enabled);
			}
		};
		_proto._onHierarchyStateChanged = function _onHierarchyStateChanged(enabled) {
			this._enabledInHierarchy = enabled;
			if (enabled && !this._frozen) this._unfreezeParentToRoot();
		};
		_proto._cloneInternal = function _cloneInternal(clone) {
			clone.name = this.name;
			var tags = this.tags._list;
			clone.tags.clear();
			for (var i = 0; i < tags.length; i++) clone.tags.add(tags[i]);
			clone._labels = Object.assign({}, this._labels);
			clone.localPosition.copy(this.localPosition);
			clone.localRotation.copy(this.localRotation);
			clone.localScale.copy(this.localScale);
			clone.localEulerAngles.copy(this.localEulerAngles);
			clone.position.copy(this.position);
			clone.rotation.copy(this.rotation);
			clone.eulerAngles.copy(this.eulerAngles);
			clone.localTransform.copy(this.localTransform);
			clone._dirtyLocal = this._dirtyLocal;
			clone.worldTransform.copy(this.worldTransform);
			clone._dirtyWorld = this._dirtyWorld;
			clone._dirtyNormal = this._dirtyNormal;
			clone._aabbVer = this._aabbVer + 1;
			clone._enabled = this._enabled;
			clone.scaleCompensation = this.scaleCompensation;
			clone._enabledInHierarchy = false;
		};
		_proto.clone = function clone() {
			var clone = new this.constructor();
			this._cloneInternal(clone);
			return clone;
		};
		_proto.copy = function copy(source) {
			source._cloneInternal(this);
			return this;
		};
		_proto.destroy = function destroy() {
			this.remove();
			var children = this._children;
			while (children.length) {
				var child = children.pop();
				child._parent = null;
				child.destroy();
			}
			this.fire('destroy', this);
			this.off();
		};
		_proto.find = function find(attr, value) {
			var result,
				results = [];
			var len = this._children.length;
			if (attr instanceof Function) {
				var fn = attr;
				result = fn(this);
				if (result) results.push(this);
				for (var i = 0; i < len; i++) {
					var descendants = this._children[i].find(fn);
					if (descendants.length) results = results.concat(descendants);
				}
			} else {
				var testValue;
				if (this[attr]) {
					if (this[attr] instanceof Function) {
						testValue = this[attr]();
					} else {
						testValue = this[attr];
					}
					if (testValue === value) results.push(this);
				}
				for (var _i = 0; _i < len; ++_i) {
					var _descendants = this._children[_i].find(attr, value);
					if (_descendants.length) results = results.concat(_descendants);
				}
			}
			return results;
		};
		_proto.findOne = function findOne(attr, value) {
			var len = this._children.length;
			var result = null;
			if (attr instanceof Function) {
				var fn = attr;
				result = fn(this);
				if (result) return this;
				for (var i = 0; i < len; i++) {
					result = this._children[i].findOne(fn);
					if (result) return result;
				}
			} else {
				var testValue;
				if (this[attr]) {
					if (this[attr] instanceof Function) {
						testValue = this[attr]();
					} else {
						testValue = this[attr];
					}
					if (testValue === value) {
						return this;
					}
				}
				for (var _i2 = 0; _i2 < len; _i2++) {
					result = this._children[_i2].findOne(attr, value);
					if (result !== null) return result;
				}
			}
			return null;
		};
		_proto.findByTag = function findByTag() {
			var query = arguments;
			var results = [];
			var queryNode = function queryNode(node, checkNode) {
				var _node$tags;
				if (checkNode && (_node$tags = node.tags).has.apply(_node$tags, query)) {
					results.push(node);
				}
				for (var i = 0; i < node._children.length; i++) {
					queryNode(node._children[i], true);
				}
			};
			queryNode(this, false);
			return results;
		};
		_proto.findByName = function findByName(name) {
			if (this.name === name) return this;
			for (var i = 0; i < this._children.length; i++) {
				var found = this._children[i].findByName(name);
				if (found !== null) return found;
			}
			return null;
		};
		_proto.findByPath = function findByPath(path) {
			var parts = Array.isArray(path) ? path : path.split('/');
			var result = this;
			var _loop = function _loop(i) {
					result = result.children.find(function (c) {
						return c.name === parts[i];
					});
					if (!result) {
						return {
							v: null
						};
					}
				},
				_ret;
			for (var i = 0, imax = parts.length; i < imax; ++i) {
				_ret = _loop(i);
				if (_ret) return _ret.v;
			}
			return result;
		};
		_proto.forEach = function forEach(callback, thisArg) {
			callback.call(thisArg, this);
			var children = this._children;
			for (var i = 0; i < children.length; i++) {
				children[i].forEach(callback, thisArg);
			}
		};
		_proto.isDescendantOf = function isDescendantOf(node) {
			var parent = this._parent;
			while (parent) {
				if (parent === node) return true;
				parent = parent._parent;
			}
			return false;
		};
		_proto.isAncestorOf = function isAncestorOf(node) {
			return node.isDescendantOf(this);
		};
		_proto.getEulerAngles = function getEulerAngles() {
			this.getWorldTransform().getEulerAngles(this.eulerAngles);
			return this.eulerAngles;
		};
		_proto.getLocalEulerAngles = function getLocalEulerAngles() {
			this.localRotation.getEulerAngles(this.localEulerAngles);
			return this.localEulerAngles;
		};
		_proto.getLocalPosition = function getLocalPosition() {
			return this.localPosition;
		};
		_proto.getLocalRotation = function getLocalRotation() {
			return this.localRotation;
		};
		_proto.getLocalScale = function getLocalScale() {
			return this.localScale;
		};
		_proto.getLocalTransform = function getLocalTransform() {
			if (this._dirtyLocal) {
				this.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale);
				this._dirtyLocal = false;
			}
			return this.localTransform;
		};
		_proto.getPosition = function getPosition() {
			this.getWorldTransform().getTranslation(this.position);
			return this.position;
		};
		_proto.getRotation = function getRotation() {
			this.rotation.setFromMat4(this.getWorldTransform());
			return this.rotation;
		};
		_proto.getScale = function getScale() {
			if (!this._scale) {
				this._scale = new Vec3();
			}
			return this.getWorldTransform().getScale(this._scale);
		};
		_proto.getWorldTransform = function getWorldTransform() {
			if (!this._dirtyLocal && !this._dirtyWorld) return this.worldTransform;
			if (this._parent) this._parent.getWorldTransform();
			this._sync();
			return this.worldTransform;
		};
		_proto.remove = function remove() {
			var _this$_parent;
			(_this$_parent = this._parent) == null || _this$_parent.removeChild(this);
		};
		_proto.reparent = function reparent(parent, index) {
			this.remove();
			if (parent) {
				if (index >= 0) {
					parent.insertChild(this, index);
				} else {
					parent.addChild(this);
				}
			}
		};
		_proto.setLocalEulerAngles = function setLocalEulerAngles(x, y, z) {
			this.localRotation.setFromEulerAngles(x, y, z);
			if (!this._dirtyLocal) this._dirtifyLocal();
		};
		_proto.setLocalPosition = function setLocalPosition(x, y, z) {
			if (x instanceof Vec3) {
				this.localPosition.copy(x);
			} else {
				this.localPosition.set(x, y, z);
			}
			if (!this._dirtyLocal) this._dirtifyLocal();
		};
		_proto.setLocalRotation = function setLocalRotation(x, y, z, w) {
			if (x instanceof Quat) {
				this.localRotation.copy(x);
			} else {
				this.localRotation.set(x, y, z, w);
			}
			if (!this._dirtyLocal) this._dirtifyLocal();
		};
		_proto.setLocalScale = function setLocalScale(x, y, z) {
			if (x instanceof Vec3) {
				this.localScale.copy(x);
			} else {
				this.localScale.set(x, y, z);
			}
			if (!this._dirtyLocal) this._dirtifyLocal();
		};
		_proto._dirtifyLocal = function _dirtifyLocal() {
			if (!this._dirtyLocal) {
				this._dirtyLocal = true;
				if (!this._dirtyWorld) this._dirtifyWorld();
			}
		};
		_proto._unfreezeParentToRoot = function _unfreezeParentToRoot() {
			var p = this._parent;
			while (p) {
				p._frozen = false;
				p = p._parent;
			}
		};
		_proto._dirtifyWorld = function _dirtifyWorld() {
			if (!this._dirtyWorld) this._unfreezeParentToRoot();
			this._dirtifyWorldInternal();
		};
		_proto._dirtifyWorldInternal = function _dirtifyWorldInternal() {
			if (!this._dirtyWorld) {
				this._frozen = false;
				this._dirtyWorld = true;
				for (var i = 0; i < this._children.length; i++) {
					if (!this._children[i]._dirtyWorld) this._children[i]._dirtifyWorldInternal();
				}
			}
			this._dirtyNormal = true;
			this._worldScaleSign = 0;
			this._aabbVer++;
		};
		_proto.setPosition = function setPosition(x, y, z) {
			if (x instanceof Vec3) {
				position$1.copy(x);
			} else {
				position$1.set(x, y, z);
			}
			if (this._parent === null) {
				this.localPosition.copy(position$1);
			} else {
				invParentWtm$1.copy(this._parent.getWorldTransform()).invert();
				invParentWtm$1.transformPoint(position$1, this.localPosition);
			}
			if (!this._dirtyLocal) this._dirtifyLocal();
		};
		_proto.setRotation = function setRotation(x, y, z, w) {
			if (x instanceof Quat) {
				rotation.copy(x);
			} else {
				rotation.set(x, y, z, w);
			}
			if (this._parent === null) {
				this.localRotation.copy(rotation);
			} else {
				var parentRot = this._parent.getRotation();
				invParentRot.copy(parentRot).invert();
				this.localRotation.copy(invParentRot).mul(rotation);
			}
			if (!this._dirtyLocal) this._dirtifyLocal();
		};
		_proto.setEulerAngles = function setEulerAngles(x, y, z) {
			this.localRotation.setFromEulerAngles(x, y, z);
			if (this._parent !== null) {
				var parentRot = this._parent.getRotation();
				invParentRot.copy(parentRot).invert();
				this.localRotation.mul2(invParentRot, this.localRotation);
			}
			if (!this._dirtyLocal) this._dirtifyLocal();
		};
		_proto.addChild = function addChild(node) {
			this._prepareInsertChild(node);
			this._children.push(node);
			this._onInsertChild(node);
		};
		_proto.addChildAndSaveTransform = function addChildAndSaveTransform(node) {
			var wPos = node.getPosition();
			var wRot = node.getRotation();
			this._prepareInsertChild(node);
			node.setPosition(tmpMat4.copy(this.worldTransform).invert().transformPoint(wPos));
			node.setRotation(tmpQuat.copy(this.getRotation()).invert().mul(wRot));
			this._children.push(node);
			this._onInsertChild(node);
		};
		_proto.insertChild = function insertChild(node, index) {
			this._prepareInsertChild(node);
			this._children.splice(index, 0, node);
			this._onInsertChild(node);
		};
		_proto._prepareInsertChild = function _prepareInsertChild(node) {
			node.remove();
		};
		_proto._fireOnHierarchy = function _fireOnHierarchy(name, nameHierarchy, parent) {
			this.fire(name, parent);
			for (var i = 0; i < this._children.length; i++) {
				this._children[i]._fireOnHierarchy(nameHierarchy, nameHierarchy, parent);
			}
		};
		_proto._onInsertChild = function _onInsertChild(node) {
			node._parent = this;
			var enabledInHierarchy = node._enabled && this.enabled;
			if (node._enabledInHierarchy !== enabledInHierarchy) {
				node._enabledInHierarchy = enabledInHierarchy;
				node._notifyHierarchyStateChanged(node, enabledInHierarchy);
			}
			node._updateGraphDepth();
			node._dirtifyWorld();
			if (this._frozen) node._unfreezeParentToRoot();
			node._fireOnHierarchy('insert', 'inserthierarchy', this);
			if (this.fire) this.fire('childinsert', node);
		};
		_proto._updateGraphDepth = function _updateGraphDepth() {
			this._graphDepth = this._parent ? this._parent._graphDepth + 1 : 0;
			for (var i = 0, len = this._children.length; i < len; i++) {
				this._children[i]._updateGraphDepth();
			}
		};
		_proto.removeChild = function removeChild(child) {
			var index = this._children.indexOf(child);
			if (index === -1) {
				return;
			}
			this._children.splice(index, 1);
			child._parent = null;
			child._fireOnHierarchy('remove', 'removehierarchy', this);
			this.fire('childremove', child);
		};
		_proto._sync = function _sync() {
			if (this._dirtyLocal) {
				this.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale);
				this._dirtyLocal = false;
			}
			if (this._dirtyWorld) {
				if (this._parent === null) {
					this.worldTransform.copy(this.localTransform);
				} else {
					if (this.scaleCompensation) {
						var parentWorldScale;
						var parent = this._parent;
						var scale = this.localScale;
						var parentToUseScaleFrom = parent;
						if (parentToUseScaleFrom) {
							while (parentToUseScaleFrom && parentToUseScaleFrom.scaleCompensation) {
								parentToUseScaleFrom = parentToUseScaleFrom._parent;
							}
							if (parentToUseScaleFrom) {
								parentToUseScaleFrom = parentToUseScaleFrom._parent;
								if (parentToUseScaleFrom) {
									parentWorldScale = parentToUseScaleFrom.worldTransform.getScale();
									scaleCompensateScale.mul2(parentWorldScale, this.localScale);
									scale = scaleCompensateScale;
								}
							}
						}
						scaleCompensateRot2.setFromMat4(parent.worldTransform);
						scaleCompensateRot.mul2(scaleCompensateRot2, this.localRotation);
						var tmatrix = parent.worldTransform;
						if (parent.scaleCompensation) {
							scaleCompensateScaleForParent.mul2(parentWorldScale, parent.getLocalScale());
							scaleCompensatePosTransform.setTRS(parent.worldTransform.getTranslation(scaleCompensatePos), scaleCompensateRot2, scaleCompensateScaleForParent);
							tmatrix = scaleCompensatePosTransform;
						}
						tmatrix.transformPoint(this.localPosition, scaleCompensatePos);
						this.worldTransform.setTRS(scaleCompensatePos, scaleCompensateRot, scale);
					} else {
						this.worldTransform.mulAffine2(this._parent.worldTransform, this.localTransform);
					}
				}
				this._dirtyWorld = false;
			}
		};
		_proto.syncHierarchy = function syncHierarchy() {
			if (!this._enabled) return;
			if (this._frozen) return;
			this._frozen = true;
			if (this._dirtyLocal || this._dirtyWorld) {
				this._sync();
			}
			var children = this._children;
			for (var i = 0, len = children.length; i < len; i++) {
				children[i].syncHierarchy();
			}
		};
		_proto.lookAt = function lookAt(x, y, z, ux, uy, uz) {
			if (ux === void 0) {
				ux = 0;
			}
			if (uy === void 0) {
				uy = 1;
			}
			if (uz === void 0) {
				uz = 0;
			}
			if (x instanceof Vec3) {
				target.copy(x);
				if (y instanceof Vec3) {
					up.copy(y);
				} else {
					up.copy(Vec3.UP);
				}
			} else if (z === undefined) {
				return;
			} else {
				target.set(x, y, z);
				up.set(ux, uy, uz);
			}
			matrix.setLookAt(this.getPosition(), target, up);
			rotation.setFromMat4(matrix);
			this.setRotation(rotation);
		};
		_proto.translate = function translate(x, y, z) {
			if (x instanceof Vec3) {
				position$1.copy(x);
			} else {
				position$1.set(x, y, z);
			}
			position$1.add(this.getPosition());
			this.setPosition(position$1);
		};
		_proto.translateLocal = function translateLocal(x, y, z) {
			if (x instanceof Vec3) {
				position$1.copy(x);
			} else {
				position$1.set(x, y, z);
			}
			this.localRotation.transformVector(position$1, position$1);
			this.localPosition.add(position$1);
			if (!this._dirtyLocal) this._dirtifyLocal();
		};
		_proto.rotate = function rotate(x, y, z) {
			rotation.setFromEulerAngles(x, y, z);
			if (this._parent === null) {
				this.localRotation.mul2(rotation, this.localRotation);
			} else {
				var rot = this.getRotation();
				var parentRot = this._parent.getRotation();
				invParentRot.copy(parentRot).invert();
				rotation.mul2(invParentRot, rotation);
				this.localRotation.mul2(rotation, rot);
			}
			if (!this._dirtyLocal) this._dirtifyLocal();
		};
		_proto.rotateLocal = function rotateLocal(x, y, z) {
			rotation.setFromEulerAngles(x, y, z);
			this.localRotation.mul(rotation);
			if (!this._dirtyLocal) this._dirtifyLocal();
		};
		_createClass(GraphNode, [{
			key: "right",
			get: function get() {
				if (!this._right) {
					this._right = new Vec3();
				}
				return this.getWorldTransform().getX(this._right).normalize();
			}
		}, {
			key: "up",
			get: function get() {
				if (!this._up) {
					this._up = new Vec3();
				}
				return this.getWorldTransform().getY(this._up).normalize();
			}
		}, {
			key: "forward",
			get: function get() {
				if (!this._forward) {
					this._forward = new Vec3();
				}
				return this.getWorldTransform().getZ(this._forward).normalize().mulScalar(-1);
			}
		}, {
			key: "normalMatrix",
			get: function get() {
				var normalMat = this._normalMatrix;
				if (this._dirtyNormal) {
					normalMat.invertMat4(this.getWorldTransform()).transpose();
					this._dirtyNormal = false;
				}
				return normalMat;
			}
		}, {
			key: "enabled",
			get: function get() {
				return this._enabled && this._enabledInHierarchy;
			},
			set: function set(enabled) {
				if (this._enabled !== enabled) {
					var _this$_parent2;
					this._enabled = enabled;
					if (enabled && (_this$_parent2 = this._parent) != null && _this$_parent2.enabled || !enabled) {
						this._notifyHierarchyStateChanged(this, enabled);
					}
				}
			}
		}, {
			key: "parent",
			get: function get() {
				return this._parent;
			}
		}, {
			key: "path",
			get: function get() {
				var node = this._parent;
				if (!node) {
					return '';
				}
				var result = this.name;
				while (node && node._parent) {
					result = node.name + "/" + result;
					node = node._parent;
				}
				return result;
			}
		}, {
			key: "root",
			get: function get() {
				var result = this;
				while (result._parent) {
					result = result._parent;
				}
				return result;
			}
		}, {
			key: "children",
			get: function get() {
				return this._children;
			}
		}, {
			key: "graphDepth",
			get: function get() {
				return this._graphDepth;
			}
		}, {
			key: "worldScaleSign",
			get: function get() {
				if (this._worldScaleSign === 0) {
					this._worldScaleSign = this.getWorldTransform().scaleSign;
				}
				return this._worldScaleSign;
			}
		}]);
		return GraphNode;
	}(EventHandler);

	var RefCountedCache = function () {
		function RefCountedCache() {
			this.cache = new Map();
		}
		var _proto = RefCountedCache.prototype;
		_proto.destroy = function destroy() {
			this.cache.forEach(function (refCount, object) {
				object.destroy();
			});
			this.cache.clear();
		};
		_proto.incRef = function incRef(object) {
			var refCount = (this.cache.get(object) || 0) + 1;
			this.cache.set(object, refCount);
		};
		_proto.decRef = function decRef(object) {
			if (object) {
				var refCount = this.cache.get(object);
				if (refCount) {
					refCount--;
					if (refCount === 0) {
						this.cache.delete(object);
						object.destroy();
					} else {
						this.cache.set(object, refCount);
					}
				}
			}
		};
		return RefCountedCache;
	}();

	var LightmapCache = function () {
		function LightmapCache() {}
		LightmapCache.incRef = function incRef(texture) {
			this.cache.incRef(texture);
		};
		LightmapCache.decRef = function decRef(texture) {
			this.cache.decRef(texture);
		};
		LightmapCache.destroy = function destroy() {
			this.cache.destroy();
		};
		return LightmapCache;
	}();
	LightmapCache.cache = new RefCountedCache();

	var id$1 = 0;
	var _tmpAabb = new BoundingBox();
	var _tempBoneAabb = new BoundingBox();
	var _tempSphere = new BoundingSphere();
	var _meshSet = new Set();
	var InstancingData = function InstancingData(numObjects) {
		this.vertexBuffer = null;
		this.count = numObjects;
	};
	var ShaderInstance = function () {
		function ShaderInstance() {
			this.shader = void 0;
			this.bindGroup = null;
		}
		var _proto = ShaderInstance.prototype;
		_proto.getBindGroup = function getBindGroup(device) {
			if (!this.bindGroup) {
				var shader = this.shader;
				var ubFormat = shader.meshUniformBufferFormat;
				var uniformBuffer = new UniformBuffer(device, ubFormat, false);
				var bindGroupFormat = shader.meshBindGroupFormat;
				this.bindGroup = new BindGroup(device, bindGroupFormat, uniformBuffer);
			}
			return this.bindGroup;
		};
		_proto.destroy = function destroy() {
			var group = this.bindGroup;
			if (group) {
				var _group$defaultUniform;
				(_group$defaultUniform = group.defaultUniformBuffer) == null || _group$defaultUniform.destroy();
				group.destroy();
				this.bindGroup = null;
			}
		};
		return ShaderInstance;
	}();
	var ShaderCacheEntry = function () {
		function ShaderCacheEntry() {
			this.shaderInstances = new Map();
		}
		var _proto2 = ShaderCacheEntry.prototype;
		_proto2.destroy = function destroy() {
			this.shaderInstances.forEach(function (instance) {
				return instance.destroy();
			});
			this.shaderInstances.clear();
		};
		return ShaderCacheEntry;
	}();
	var MeshInstance = function () {
		function MeshInstance(mesh, material, node) {
			if (node === void 0) {
				node = null;
			}
			this.visible = true;
			this.castShadow = false;
			this.transparent = false;
			this._material = null;
			this._shaderCache = [];
			this.id = id$1++;
			this.pick = true;
			if (mesh instanceof GraphNode) {
				var temp = mesh;
				mesh = material;
				material = node;
				node = temp;
			}
			this._key = [0, 0];
			this.node = node;
			this._mesh = mesh;
			mesh.incRefCount();
			this.material = material;
			this._shaderDefs = MASK_AFFECT_DYNAMIC << 16;
			this._shaderDefs |= mesh.vertexBuffer.format.hasUv0 ? SHADERDEF_UV0 : 0;
			this._shaderDefs |= mesh.vertexBuffer.format.hasUv1 ? SHADERDEF_UV1 : 0;
			this._shaderDefs |= mesh.vertexBuffer.format.hasColor ? SHADERDEF_VCOLOR : 0;
			this._shaderDefs |= mesh.vertexBuffer.format.hasTangents ? SHADERDEF_TANGENTS : 0;
			this.layer = LAYER_WORLD;
			this._renderStyle = RENDERSTYLE_SOLID;
			this._receiveShadow = true;
			this._screenSpace = false;
			this._noDepthDrawGl1 = false;
			this.cull = true;
			this._updateAabb = true;
			this._updateAabbFunc = null;
			this._calculateSortDistance = null;
			this.updateKey();
			this._skinInstance = null;
			this._morphInstance = null;
			this.instancingData = null;
			this._customAabb = null;
			this.aabb = new BoundingBox();
			this._aabbVer = -1;
			this._aabbMeshVer = -1;
			this.drawOrder = 0;
			this.visibleThisFrame = false;
			this.isVisibleFunc = null;
			this.parameters = {};
			this.stencilFront = null;
			this.stencilBack = null;
			this.flipFacesFactor = 1;
		}
		var _proto3 = MeshInstance.prototype;
		_proto3.clearShaders = function clearShaders() {
			var shaderCache = this._shaderCache;
			for (var i = 0; i < shaderCache.length; i++) {
				var _shaderCache$i;
				(_shaderCache$i = shaderCache[i]) == null || _shaderCache$i.destroy();
				shaderCache[i] = null;
			}
		};
		_proto3.getShaderInstance = function getShaderInstance(shaderPass, lightHash, scene, viewUniformFormat, viewBindGroupFormat, sortedLights) {
			var shaderInstance;
			var passEntry = this._shaderCache[shaderPass];
			if (passEntry) {
				shaderInstance = passEntry.shaderInstances.get(lightHash);
			} else {
				passEntry = new ShaderCacheEntry();
				this._shaderCache[shaderPass] = passEntry;
			}
			if (!shaderInstance) {
				var mat = this._material;
				var shaderDefs = this._shaderDefs;
				var variantKey = shaderPass + '_' + shaderDefs + '_' + lightHash;
				shaderInstance = new ShaderInstance();
				shaderInstance.shader = mat.variants.get(variantKey);
				if (!shaderInstance.shader) {
					var shader = mat.getShaderVariant(this.mesh.device, scene, shaderDefs, null, shaderPass, sortedLights, viewUniformFormat, viewBindGroupFormat, this._mesh.vertexBuffer.format);
					mat.variants.set(variantKey, shader);
					shaderInstance.shader = shader;
				}
				passEntry.shaderInstances.set(lightHash, shaderInstance);
			}
			return shaderInstance;
		};
		_proto3._updateShaderDefs = function _updateShaderDefs(shaderDefs) {
			if (shaderDefs !== this._shaderDefs) {
				this._shaderDefs = shaderDefs;
				this.clearShaders();
			}
		};
		_proto3.destroy = function destroy() {
			var _this$_skinInstance, _this$morphInstance;
			var mesh = this.mesh;
			if (mesh) {
				this.mesh = null;
				if (mesh.refCount < 1) {
					mesh.destroy();
				}
			}
			this.setRealtimeLightmap(MeshInstance.lightmapParamNames[0], null);
			this.setRealtimeLightmap(MeshInstance.lightmapParamNames[1], null);
			(_this$_skinInstance = this._skinInstance) == null || _this$_skinInstance.destroy();
			this._skinInstance = null;
			(_this$morphInstance = this.morphInstance) == null || _this$morphInstance.destroy();
			this.morphInstance = null;
			this.clearShaders();
			this.material = null;
		};
		MeshInstance._prepareRenderStyleForArray = function _prepareRenderStyleForArray(meshInstances, renderStyle) {
			if (meshInstances) {
				for (var i = 0; i < meshInstances.length; i++) {
					meshInstances[i]._renderStyle = renderStyle;
					var mesh = meshInstances[i].mesh;
					if (!_meshSet.has(mesh)) {
						_meshSet.add(mesh);
						mesh.prepareRenderState(renderStyle);
					}
				}
				_meshSet.clear();
			}
		};
		_proto3._isVisible = function _isVisible(camera) {
			if (this.visible) {
				if (this.isVisibleFunc) {
					return this.isVisibleFunc(camera);
				}
				_tempSphere.center = this.aabb.center;
				_tempSphere.radius = this._aabb.halfExtents.length();
				return camera.frustum.containsSphere(_tempSphere);
			}
			return false;
		};
		_proto3.updateKey = function updateKey() {
			var material = this.material;
			var blendType = material.alphaToCoverage || material.alphaTest ? BLEND_NORMAL : material.blendType;
			this._key[SORTKEY_FORWARD] = (this.layer & 0x0f) << 27 | (blendType === BLEND_NONE ? 1 : 0) << 26 | (material.id & 0x1ffffff) << 0;
		};
		_proto3.setInstancing = function setInstancing(vertexBuffer, cull) {
			if (cull === void 0) {
				cull = false;
			}
			if (vertexBuffer) {
				this.instancingData = new InstancingData(vertexBuffer.numVertices);
				this.instancingData.vertexBuffer = vertexBuffer;
				vertexBuffer.format.instancing = true;
				this.cull = cull;
			} else {
				this.instancingData = null;
				this.cull = true;
			}
			this._updateShaderDefs(vertexBuffer ? this._shaderDefs | SHADERDEF_INSTANCING : this._shaderDefs & ~SHADERDEF_INSTANCING);
		};
		_proto3.ensureMaterial = function ensureMaterial(device) {
			if (!this.material) {
				this.material = getDefaultMaterial(device);
			}
		};
		_proto3.clearParameters = function clearParameters() {
			this.parameters = {};
		};
		_proto3.getParameters = function getParameters() {
			return this.parameters;
		};
		_proto3.getParameter = function getParameter(name) {
			return this.parameters[name];
		};
		_proto3.setParameter = function setParameter(name, data, passFlags) {
			if (passFlags === void 0) {
				passFlags = -262141;
			}
			if (data === undefined && typeof name === 'object') {
				var uniformObject = name;
				if (uniformObject.length) {
					for (var i = 0; i < uniformObject.length; i++) {
						this.setParameter(uniformObject[i]);
					}
					return;
				}
				name = uniformObject.name;
				data = uniformObject.value;
			}
			var param = this.parameters[name];
			if (param) {
				param.data = data;
				param.passFlags = passFlags;
			} else {
				this.parameters[name] = {
					scopeId: null,
					data: data,
					passFlags: passFlags
				};
			}
		};
		_proto3.setRealtimeLightmap = function setRealtimeLightmap(name, texture) {
			var old = this.getParameter(name);
			if (old === texture) return;
			if (old) {
				LightmapCache.decRef(old.data);
			}
			if (texture) {
				LightmapCache.incRef(texture);
				this.setParameter(name, texture);
			} else {
				this.deleteParameter(name);
			}
		};
		_proto3.deleteParameter = function deleteParameter(name) {
			if (this.parameters[name]) {
				delete this.parameters[name];
			}
		};
		_proto3.setParameters = function setParameters(device, passFlag) {
			var parameters = this.parameters;
			for (var paramName in parameters) {
				var parameter = parameters[paramName];
				if (parameter.passFlags & passFlag) {
					if (!parameter.scopeId) {
						parameter.scopeId = device.scope.resolve(paramName);
					}
					parameter.scopeId.setValue(parameter.data);
				}
			}
		};
		_proto3.setLightmapped = function setLightmapped(value) {
			if (value) {
				this.mask = (this.mask | MASK_AFFECT_LIGHTMAPPED) & ~(MASK_AFFECT_DYNAMIC | MASK_BAKE);
			} else {
				this.setRealtimeLightmap(MeshInstance.lightmapParamNames[0], null);
				this.setRealtimeLightmap(MeshInstance.lightmapParamNames[1], null);
				this._shaderDefs &= ~(SHADERDEF_LM | SHADERDEF_DIRLM | SHADERDEF_LMAMBIENT);
				this.mask = (this.mask | MASK_AFFECT_DYNAMIC) & ~(MASK_AFFECT_LIGHTMAPPED | MASK_BAKE);
			}
		};
		_proto3.setCustomAabb = function setCustomAabb(aabb) {
			if (aabb) {
				if (this._customAabb) {
					this._customAabb.copy(aabb);
				} else {
					this._customAabb = aabb.clone();
				}
			} else {
				this._customAabb = null;
				this._aabbVer = -1;
			}
			this._setupSkinUpdate();
		};
		_proto3._setupSkinUpdate = function _setupSkinUpdate() {
			if (this._skinInstance) {
				this._skinInstance._updateBeforeCull = !this._customAabb;
			}
		};
		_createClass(MeshInstance, [{
			key: "renderStyle",
			get: function get() {
				return this._renderStyle;
			},
			set: function set(renderStyle) {
				this._renderStyle = renderStyle;
				this.mesh.prepareRenderState(renderStyle);
			}
		}, {
			key: "mesh",
			get: function get() {
				return this._mesh;
			},
			set: function set(mesh) {
				if (mesh === this._mesh) return;
				if (this._mesh) {
					this._mesh.decRefCount();
				}
				this._mesh = mesh;
				if (mesh) {
					mesh.incRefCount();
				}
			}
		}, {
			key: "aabb",
			get: function get() {
				if (!this._updateAabb) {
					return this._aabb;
				}
				if (this._updateAabbFunc) {
					return this._updateAabbFunc(this._aabb);
				}
				var localAabb = this._customAabb;
				var toWorldSpace = !!localAabb;
				if (!localAabb) {
					localAabb = _tmpAabb;
					if (this.skinInstance) {
						if (!this.mesh.boneAabb) {
							var morphTargets = this._morphInstance ? this._morphInstance.morph._targets : null;
							this.mesh._initBoneAabbs(morphTargets);
						}
						var boneUsed = this.mesh.boneUsed;
						var first = true;
						for (var i = 0; i < this.mesh.boneAabb.length; i++) {
							if (boneUsed[i]) {
								_tempBoneAabb.setFromTransformedAabb(this.mesh.boneAabb[i], this.skinInstance.matrices[i]);
								if (first) {
									first = false;
									localAabb.center.copy(_tempBoneAabb.center);
									localAabb.halfExtents.copy(_tempBoneAabb.halfExtents);
								} else {
									localAabb.add(_tempBoneAabb);
								}
							}
						}
						toWorldSpace = true;
					} else if (this.node._aabbVer !== this._aabbVer || this.mesh._aabbVer !== this._aabbMeshVer) {
						if (this.mesh) {
							localAabb.center.copy(this.mesh.aabb.center);
							localAabb.halfExtents.copy(this.mesh.aabb.halfExtents);
						} else {
							localAabb.center.set(0, 0, 0);
							localAabb.halfExtents.set(0, 0, 0);
						}
						if (this.mesh && this.mesh.morph) {
							var morphAabb = this.mesh.morph.aabb;
							localAabb._expand(morphAabb.getMin(), morphAabb.getMax());
						}
						toWorldSpace = true;
						this._aabbVer = this.node._aabbVer;
						this._aabbMeshVer = this.mesh._aabbVer;
					}
				}
				if (toWorldSpace) {
					this._aabb.setFromTransformedAabb(localAabb, this.node.getWorldTransform());
				}
				return this._aabb;
			},
			set: function set(aabb) {
				this._aabb = aabb;
			}
		}, {
			key: "material",
			get: function get() {
				return this._material;
			},
			set: function set(material) {
				this.clearShaders();
				var prevMat = this._material;
				if (prevMat) {
					prevMat.removeMeshInstanceRef(this);
				}
				this._material = material;
				if (material) {
					material.addMeshInstanceRef(this);
					this.transparent = material.transparent;
					this.updateKey();
				}
			}
		}, {
			key: "layer",
			get: function get() {
				return this._layer;
			},
			set: function set(layer) {
				this._layer = layer;
				this.updateKey();
			}
		}, {
			key: "calculateSortDistance",
			get: function get() {
				return this._calculateSortDistance;
			},
			set: function set(calculateSortDistance) {
				this._calculateSortDistance = calculateSortDistance;
			}
		}, {
			key: "receiveShadow",
			get: function get() {
				return this._receiveShadow;
			},
			set: function set(val) {
				if (this._receiveShadow !== val) {
					this._receiveShadow = val;
					this._updateShaderDefs(val ? this._shaderDefs & ~SHADERDEF_NOSHADOW : this._shaderDefs | SHADERDEF_NOSHADOW);
				}
			}
		}, {
			key: "skinInstance",
			get: function get() {
				return this._skinInstance;
			},
			set: function set(val) {
				this._skinInstance = val;
				this._updateShaderDefs(val ? this._shaderDefs | SHADERDEF_SKIN : this._shaderDefs & ~SHADERDEF_SKIN);
				this._setupSkinUpdate();
			}
		}, {
			key: "morphInstance",
			get: function get() {
				return this._morphInstance;
			},
			set: function set(val) {
				var _this$_morphInstance;
				(_this$_morphInstance = this._morphInstance) == null || _this$_morphInstance.destroy();
				this._morphInstance = val;
				var shaderDefs = this._shaderDefs;
				shaderDefs = val && val.morph.useTextureMorph ? shaderDefs | SHADERDEF_MORPH_TEXTURE_BASED : shaderDefs & ~SHADERDEF_MORPH_TEXTURE_BASED;
				shaderDefs = val && val.morph.morphPositions ? shaderDefs | SHADERDEF_MORPH_POSITION : shaderDefs & ~SHADERDEF_MORPH_POSITION;
				shaderDefs = val && val.morph.morphNormals ? shaderDefs | SHADERDEF_MORPH_NORMAL : shaderDefs & ~SHADERDEF_MORPH_NORMAL;
				this._updateShaderDefs(shaderDefs);
			}
		}, {
			key: "screenSpace",
			get: function get() {
				return this._screenSpace;
			},
			set: function set(val) {
				if (this._screenSpace !== val) {
					this._screenSpace = val;
					this._updateShaderDefs(val ? this._shaderDefs | SHADERDEF_SCREENSPACE : this._shaderDefs & ~SHADERDEF_SCREENSPACE);
				}
			}
		}, {
			key: "key",
			get: function get() {
				return this._key[SORTKEY_FORWARD];
			},
			set: function set(val) {
				this._key[SORTKEY_FORWARD] = val;
			}
		}, {
			key: "mask",
			get: function get() {
				return this._shaderDefs >> 16;
			},
			set: function set(val) {
				var toggles = this._shaderDefs & 0x0000FFFF;
				this._updateShaderDefs(toggles | val << 16);
			}
		}, {
			key: "instancingCount",
			get: function get() {
				return this.instancingData ? this.instancingData.count : 0;
			},
			set: function set(value) {
				if (this.instancingData) this.instancingData.count = value;
			}
		}]);
		return MeshInstance;
	}();
	MeshInstance.lightmapParamNames = ['texture_lightMap', 'texture_dirLightMap'];

	function paramsIdentical(a, b) {
		if (a && !b) return false;
		if (!a && b) return false;
		a = a.data;
		b = b.data;
		if (a === b) return true;
		if (a instanceof Float32Array && b instanceof Float32Array) {
			if (a.length !== b.length) return false;
			for (var i = 0; i < a.length; i++) {
				if (a[i] !== b[i]) return false;
			}
			return true;
		}
		return false;
	}
	function equalParamSets(params1, params2) {
		for (var param in params1) {
			if (params1.hasOwnProperty(param) && !paramsIdentical(params1[param], params2[param])) return false;
		}
		for (var _param in params2) {
			if (params2.hasOwnProperty(_param) && !paramsIdentical(params2[_param], params1[_param])) return false;
		}
		return true;
	}
	var _triFanIndices = [0, 1, 3, 2, 3, 1];
	var _triStripIndices = [0, 1, 3, 0, 3, 2];
	var mat3 = new Mat3();
	function getScaleSign(mi) {
		return mi.node.worldTransform.scaleSign;
	}
	var BatchManager = function () {
		function BatchManager(device, root, scene) {
			this.device = device;
			this.rootNode = root;
			this.scene = scene;
			this._init = false;
			this._batchGroups = {};
			this._batchGroupCounter = 0;
			this._batchList = [];
			this._dirtyGroups = [];
		}
		var _proto = BatchManager.prototype;
		_proto.destroy = function destroy() {
			this.device = null;
			this.rootNode = null;
			this.scene = null;
			this._batchGroups = {};
			this._batchList = [];
			this._dirtyGroups = [];
		};
		_proto.addGroup = function addGroup(name, dynamic, maxAabbSize, id, layers) {
			if (id === undefined) {
				id = this._batchGroupCounter;
				this._batchGroupCounter++;
			}
			if (this._batchGroups[id]) {
				return undefined;
			}
			var group = new BatchGroup(id, name, dynamic, maxAabbSize, layers);
			this._batchGroups[id] = group;
			return group;
		};
		_proto.removeGroup = function removeGroup(id) {
			if (!this._batchGroups[id]) {
				return;
			}
			var newBatchList = [];
			for (var i = 0; i < this._batchList.length; i++) {
				if (this._batchList[i].batchGroupId === id) {
					this.destroyBatch(this._batchList[i]);
				} else {
					newBatchList.push(this._batchList[i]);
				}
			}
			this._batchList = newBatchList;
			this._removeModelsFromBatchGroup(this.rootNode, id);
			delete this._batchGroups[id];
		};
		_proto.markGroupDirty = function markGroupDirty(id) {
			if (this._dirtyGroups.indexOf(id) < 0) {
				this._dirtyGroups.push(id);
			}
		};
		_proto.getGroupByName = function getGroupByName(name) {
			var groups = this._batchGroups;
			for (var group in groups) {
				if (!groups.hasOwnProperty(group)) continue;
				if (groups[group].name === name) {
					return groups[group];
				}
			}
			return null;
		};
		_proto.getBatches = function getBatches(batchGroupId) {
			var results = [];
			var len = this._batchList.length;
			for (var i = 0; i < len; i++) {
				var batch = this._batchList[i];
				if (batch.batchGroupId === batchGroupId) {
					results.push(batch);
				}
			}
			return results;
		};
		_proto._removeModelsFromBatchGroup = function _removeModelsFromBatchGroup(node, id) {
			if (!node.enabled) return;
			if (node.model && node.model.batchGroupId === id) {
				node.model.batchGroupId = -1;
			}
			if (node.render && node.render.batchGroupId === id) {
				node.render.batchGroupId = -1;
			}
			if (node.element && node.element.batchGroupId === id) {
				node.element.batchGroupId = -1;
			}
			if (node.sprite && node.sprite.batchGroupId === id) {
				node.sprite.batchGroupId = -1;
			}
			for (var i = 0; i < node._children.length; i++) {
				this._removeModelsFromBatchGroup(node._children[i], id);
			}
		};
		_proto.insert = function insert(type, groupId, node) {
			var group = this._batchGroups[groupId];
			if (group) {
				if (group._obj[type].indexOf(node) < 0) {
					group._obj[type].push(node);
					this.markGroupDirty(groupId);
				}
			}
		};
		_proto.remove = function remove(type, groupId, node) {
			var group = this._batchGroups[groupId];
			if (group) {
				var idx = group._obj[type].indexOf(node);
				if (idx >= 0) {
					group._obj[type].splice(idx, 1);
					this.markGroupDirty(groupId);
				}
			}
		};
		_proto._extractRender = function _extractRender(node, arr, group, groupMeshInstances) {
			if (node.render) {
				arr = groupMeshInstances[node.render.batchGroupId] = arr.concat(node.render.meshInstances);
				node.render.removeFromLayers();
			}
			return arr;
		};
		_proto._extractModel = function _extractModel(node, arr, group, groupMeshInstances) {
			if (node.model && node.model.model) {
				arr = groupMeshInstances[node.model.batchGroupId] = arr.concat(node.model.meshInstances);
				node.model.removeModelFromLayers();
			}
			return arr;
		};
		_proto._extractElement = function _extractElement(node, arr, group) {
			if (!node.element) return;
			var valid = false;
			if (node.element._text && node.element._text._model.meshInstances.length > 0) {
				arr.push(node.element._text._model.meshInstances[0]);
				node.element.removeModelFromLayers(node.element._text._model);
				valid = true;
			} else if (node.element._image) {
				arr.push(node.element._image._renderable.meshInstance);
				node.element.removeModelFromLayers(node.element._image._renderable.model);
				if (node.element._image._renderable.unmaskMeshInstance) {
					arr.push(node.element._image._renderable.unmaskMeshInstance);
					if (!node.element._image._renderable.unmaskMeshInstance.stencilFront || !node.element._image._renderable.unmaskMeshInstance.stencilBack) {
						node.element._dirtifyMask();
						node.element._onPrerender();
					}
				}
				valid = true;
			}
			if (valid) {
				group._ui = true;
			}
		};
		_proto._collectAndRemoveMeshInstances = function _collectAndRemoveMeshInstances(groupMeshInstances, groupIds) {
			for (var g = 0; g < groupIds.length; g++) {
				var id = groupIds[g];
				var group = this._batchGroups[id];
				if (!group) continue;
				var arr = groupMeshInstances[id];
				if (!arr) arr = groupMeshInstances[id] = [];
				for (var m = 0; m < group._obj.model.length; m++) {
					arr = this._extractModel(group._obj.model[m], arr, group, groupMeshInstances);
				}
				for (var r = 0; r < group._obj.render.length; r++) {
					arr = this._extractRender(group._obj.render[r], arr, group, groupMeshInstances);
				}
				for (var e = 0; e < group._obj.element.length; e++) {
					this._extractElement(group._obj.element[e], arr, group);
				}
				for (var s = 0; s < group._obj.sprite.length; s++) {
					var node = group._obj.sprite[s];
					if (node.sprite && node.sprite._meshInstance && (group.dynamic || node.sprite.sprite._renderMode === SPRITE_RENDERMODE_SIMPLE)) {
						arr.push(node.sprite._meshInstance);
						node.sprite.removeModelFromLayers();
						group._sprite = true;
						node.sprite._batchGroup = group;
					}
				}
			}
		};
		_proto.generate = function generate(groupIds) {
			var groupMeshInstances = {};
			if (!groupIds) {
				groupIds = Object.keys(this._batchGroups);
			}
			var newBatchList = [];
			for (var i = 0; i < this._batchList.length; i++) {
				if (groupIds.indexOf(this._batchList[i].batchGroupId) < 0) {
					newBatchList.push(this._batchList[i]);
					continue;
				}
				this.destroyBatch(this._batchList[i]);
			}
			this._batchList = newBatchList;
			this._collectAndRemoveMeshInstances(groupMeshInstances, groupIds);
			if (groupIds === this._dirtyGroups) {
				this._dirtyGroups.length = 0;
			} else {
				var newDirtyGroups = [];
				for (var _i = 0; _i < this._dirtyGroups.length; _i++) {
					if (groupIds.indexOf(this._dirtyGroups[_i]) < 0) newDirtyGroups.push(this._dirtyGroups[_i]);
				}
				this._dirtyGroups = newDirtyGroups;
			}
			var group, lists, groupData, batch;
			for (var groupId in groupMeshInstances) {
				if (!groupMeshInstances.hasOwnProperty(groupId)) continue;
				group = groupMeshInstances[groupId];
				groupData = this._batchGroups[groupId];
				if (!groupData) {
					continue;
				}
				lists = this.prepare(group, groupData.dynamic, groupData.maxAabbSize, groupData._ui || groupData._sprite);
				for (var _i2 = 0; _i2 < lists.length; _i2++) {
					batch = this.create(lists[_i2], groupData.dynamic, parseInt(groupId, 10));
					if (batch) {
						batch.addToLayers(this.scene, groupData.layers);
					}
				}
			}
		};
		_proto.prepare = function prepare(meshInstances, dynamic, maxAabbSize, translucent) {
			if (maxAabbSize === void 0) {
				maxAabbSize = Number.POSITIVE_INFINITY;
			}
			if (meshInstances.length === 0) return [];
			var halfMaxAabbSize = maxAabbSize * 0.5;
			var maxInstanceCount = this.device.supportsBoneTextures ? 1024 : this.device.boneLimit;
			var maxNumVertices = this.device.extUintElement ? 0xffffffff : 0xffff;
			var aabb = new BoundingBox();
			var testAabb = new BoundingBox();
			var skipTranslucentAabb = null;
			var sf;
			var lists = [];
			var j = 0;
			if (translucent) {
				meshInstances.sort(function (a, b) {
					return a.drawOrder - b.drawOrder;
				});
			}
			var meshInstancesLeftA = meshInstances;
			var meshInstancesLeftB;
			var skipMesh = translucent ? function (mi) {
				if (skipTranslucentAabb) {
					skipTranslucentAabb.add(mi.aabb);
				} else {
					skipTranslucentAabb = mi.aabb.clone();
				}
				meshInstancesLeftB.push(mi);
			} : function (mi) {
				meshInstancesLeftB.push(mi);
			};
			while (meshInstancesLeftA.length > 0) {
				lists[j] = [meshInstancesLeftA[0]];
				meshInstancesLeftB = [];
				var material = meshInstancesLeftA[0].material;
				var layer = meshInstancesLeftA[0].layer;
				var defs = meshInstancesLeftA[0]._shaderDefs;
				var params = meshInstancesLeftA[0].parameters;
				var stencil = meshInstancesLeftA[0].stencilFront;
				var vertCount = meshInstancesLeftA[0].mesh.vertexBuffer.getNumVertices();
				var drawOrder = meshInstancesLeftA[0].drawOrder;
				aabb.copy(meshInstancesLeftA[0].aabb);
				var scaleSign = getScaleSign(meshInstancesLeftA[0]);
				var vertexFormatBatchingHash = meshInstancesLeftA[0].mesh.vertexBuffer.format.batchingHash;
				var indexed = meshInstancesLeftA[0].mesh.primitive[0].indexed;
				skipTranslucentAabb = null;
				for (var i = 1; i < meshInstancesLeftA.length; i++) {
					var mi = meshInstancesLeftA[i];
					if (dynamic && lists[j].length >= maxInstanceCount) {
						meshInstancesLeftB = meshInstancesLeftB.concat(meshInstancesLeftA.slice(i));
						break;
					}
					if (material !== mi.material || layer !== mi.layer || vertexFormatBatchingHash !== mi.mesh.vertexBuffer.format.batchingHash || indexed !== mi.mesh.primitive[0].indexed || defs !== mi._shaderDefs || vertCount + mi.mesh.vertexBuffer.getNumVertices() > maxNumVertices) {
						skipMesh(mi);
						continue;
					}
					testAabb.copy(aabb);
					testAabb.add(mi.aabb);
					if (testAabb.halfExtents.x > halfMaxAabbSize || testAabb.halfExtents.y > halfMaxAabbSize || testAabb.halfExtents.z > halfMaxAabbSize) {
						skipMesh(mi);
						continue;
					}
					if (stencil) {
						if (!(sf = mi.stencilFront) || stencil.func !== sf.func || stencil.zpass !== sf.zpass) {
							skipMesh(mi);
							continue;
						}
					}
					if (scaleSign !== getScaleSign(mi)) {
						skipMesh(mi);
						continue;
					}
					if (!equalParamSets(params, mi.parameters)) {
						skipMesh(mi);
						continue;
					}
					if (translucent && skipTranslucentAabb && skipTranslucentAabb.intersects(mi.aabb) && mi.drawOrder !== drawOrder) {
						skipMesh(mi);
						continue;
					}
					aabb.add(mi.aabb);
					vertCount += mi.mesh.vertexBuffer.getNumVertices();
					lists[j].push(mi);
				}
				j++;
				meshInstancesLeftA = meshInstancesLeftB;
			}
			return lists;
		};
		_proto.collectBatchedMeshData = function collectBatchedMeshData(meshInstances, dynamic) {
			var streams = null;
			var batchNumVerts = 0;
			var batchNumIndices = 0;
			var material = null;
			for (var i = 0; i < meshInstances.length; i++) {
				if (meshInstances[i].visible) {
					var mesh = meshInstances[i].mesh;
					var numVerts = mesh.vertexBuffer.numVertices;
					batchNumVerts += numVerts;
					if (mesh.primitive[0].indexed) {
						batchNumIndices += mesh.primitive[0].count;
					} else {
						var primitiveType = mesh.primitive[0].type;
						if (primitiveType === PRIMITIVE_TRIFAN || primitiveType === PRIMITIVE_TRISTRIP) {
							if (mesh.primitive[0].count === 4) batchNumIndices += 6;
						}
					}
					if (!streams) {
						material = meshInstances[i].material;
						streams = {};
						var elems = mesh.vertexBuffer.format.elements;
						for (var j = 0; j < elems.length; j++) {
							var semantic = elems[j].name;
							streams[semantic] = {
								numComponents: elems[j].numComponents,
								dataType: elems[j].dataType,
								normalize: elems[j].normalize,
								count: 0
							};
						}
						if (dynamic) {
							streams[SEMANTIC_BLENDINDICES] = {
								numComponents: 1,
								dataType: TYPE_FLOAT32,
								normalize: false,
								count: 0
							};
						}
					}
				}
			}
			return {
				streams: streams,
				batchNumVerts: batchNumVerts,
				batchNumIndices: batchNumIndices,
				material: material
			};
		};
		_proto.create = function create(meshInstances, dynamic, batchGroupId) {
			if (!this._init) {
				var boneLimit = '#define BONE_LIMIT ' + this.device.getBoneLimit() + '\n';
				this.transformVS = boneLimit + '#define DYNAMICBATCH\n' + shaderChunks.transformVS;
				this.skinTexVS = shaderChunks.skinBatchTexVS;
				this.skinConstVS = shaderChunks.skinBatchConstVS;
				this.vertexFormats = {};
				this._init = true;
			}
			var stream = null;
			var semantic;
			var mesh, numVerts;
			var batch = null;
			var batchData = this.collectBatchedMeshData(meshInstances, dynamic);
			if (batchData.streams) {
				var streams = batchData.streams;
				var material = batchData.material;
				var batchNumVerts = batchData.batchNumVerts;
				var batchNumIndices = batchData.batchNumIndices;
				batch = new Batch(meshInstances, dynamic, batchGroupId);
				this._batchList.push(batch);
				var indexBase, numIndices, indexData;
				var verticesOffset = 0;
				var indexOffset = 0;
				var transform;
				var vec = new Vec3();
				var indexArrayType = batchNumVerts <= 0xffff ? Uint16Array : Uint32Array;
				var indices = new indexArrayType(batchNumIndices);
				for (semantic in streams) {
					stream = streams[semantic];
					stream.typeArrayType = typedArrayTypes[stream.dataType];
					stream.elementByteSize = typedArrayTypesByteSize[stream.dataType];
					stream.buffer = new stream.typeArrayType(batchNumVerts * stream.numComponents);
				}
				for (var i = 0; i < meshInstances.length; i++) {
					if (!meshInstances[i].visible) continue;
					mesh = meshInstances[i].mesh;
					numVerts = mesh.vertexBuffer.numVertices;
					if (!dynamic) {
						transform = meshInstances[i].node.getWorldTransform();
					}
					for (semantic in streams) {
						if (semantic !== SEMANTIC_BLENDINDICES) {
							stream = streams[semantic];
							var subarray = new stream.typeArrayType(stream.buffer.buffer, stream.elementByteSize * stream.count);
							var totalComponents = mesh.getVertexStream(semantic, subarray) * stream.numComponents;
							stream.count += totalComponents;
							if (!dynamic && stream.numComponents >= 3) {
								if (semantic === SEMANTIC_POSITION) {
									for (var j = 0; j < totalComponents; j += stream.numComponents) {
										vec.set(subarray[j], subarray[j + 1], subarray[j + 2]);
										transform.transformPoint(vec, vec);
										subarray[j] = vec.x;
										subarray[j + 1] = vec.y;
										subarray[j + 2] = vec.z;
									}
								} else if (semantic === SEMANTIC_NORMAL || semantic === SEMANTIC_TANGENT) {
									mat3.invertMat4(transform).transpose();
									for (var _j = 0; _j < totalComponents; _j += stream.numComponents) {
										vec.set(subarray[_j], subarray[_j + 1], subarray[_j + 2]);
										mat3.transformVector(vec, vec);
										subarray[_j] = vec.x;
										subarray[_j + 1] = vec.y;
										subarray[_j + 2] = vec.z;
									}
								}
							}
						}
					}
					if (dynamic) {
						stream = streams[SEMANTIC_BLENDINDICES];
						for (var _j2 = 0; _j2 < numVerts; _j2++) stream.buffer[stream.count++] = i;
					}
					if (mesh.primitive[0].indexed) {
						indexBase = mesh.primitive[0].base;
						numIndices = mesh.primitive[0].count;
						var srcFormat = mesh.indexBuffer[0].getFormat();
						indexData = new typedArrayIndexFormats[srcFormat](mesh.indexBuffer[0].storage);
					} else {
						var primitiveType = mesh.primitive[0].type;
						if (primitiveType === PRIMITIVE_TRIFAN || primitiveType === PRIMITIVE_TRISTRIP) {
							if (mesh.primitive[0].count === 4) {
								indexBase = 0;
								numIndices = 6;
								indexData = primitiveType === PRIMITIVE_TRIFAN ? _triFanIndices : _triStripIndices;
							} else {
								numIndices = 0;
								continue;
							}
						}
					}
					for (var _j3 = 0; _j3 < numIndices; _j3++) {
						indices[_j3 + indexOffset] = indexData[indexBase + _j3] + verticesOffset;
					}
					indexOffset += numIndices;
					verticesOffset += numVerts;
				}
				mesh = new Mesh(this.device);
				for (semantic in streams) {
					stream = streams[semantic];
					mesh.setVertexStream(semantic, stream.buffer, stream.numComponents, undefined, stream.dataType, stream.normalize);
				}
				if (indices.length > 0) mesh.setIndices(indices);
				mesh.update(PRIMITIVE_TRIANGLES, false);
				if (dynamic) {
					material = material.clone();
					material.chunks.transformVS = this.transformVS;
					material.chunks.skinTexVS = this.skinTexVS;
					material.chunks.skinConstVS = this.skinConstVS;
					material.update();
				}
				var meshInstance = new MeshInstance(mesh, material, this.rootNode);
				meshInstance.castShadow = batch.origMeshInstances[0].castShadow;
				meshInstance.parameters = batch.origMeshInstances[0].parameters;
				meshInstance.layer = batch.origMeshInstances[0].layer;
				meshInstance._shaderDefs = batch.origMeshInstances[0]._shaderDefs;
				meshInstance.cull = batch.origMeshInstances[0].cull;
				var batchGroup = this._batchGroups[batchGroupId];
				if (batchGroup && batchGroup._ui) meshInstance.cull = false;
				if (dynamic) {
					var nodes = [];
					for (var _i3 = 0; _i3 < batch.origMeshInstances.length; _i3++) {
						nodes.push(batch.origMeshInstances[_i3].node);
					}
					meshInstance.skinInstance = new SkinBatchInstance(this.device, nodes, this.rootNode);
				}
				meshInstance._updateAabb = false;
				meshInstance.drawOrder = batch.origMeshInstances[0].drawOrder;
				meshInstance.stencilFront = batch.origMeshInstances[0].stencilFront;
				meshInstance.stencilBack = batch.origMeshInstances[0].stencilBack;
				meshInstance.flipFacesFactor = getScaleSign(batch.origMeshInstances[0]);
				meshInstance.castShadow = batch.origMeshInstances[0].castShadow;
				batch.meshInstance = meshInstance;
				batch.updateBoundingBox();
			}
			return batch;
		};
		_proto.updateAll = function updateAll() {
			if (this._dirtyGroups.length > 0) {
				this.generate(this._dirtyGroups);
			}
			for (var i = 0; i < this._batchList.length; i++) {
				if (!this._batchList[i].dynamic) continue;
				this._batchList[i].updateBoundingBox();
			}
		};
		_proto.clone = function clone(batch, clonedMeshInstances) {
			var batch2 = new Batch(clonedMeshInstances, batch.dynamic, batch.batchGroupId);
			this._batchList.push(batch2);
			var nodes = [];
			for (var i = 0; i < clonedMeshInstances.length; i++) {
				nodes.push(clonedMeshInstances[i].node);
			}
			batch2.meshInstance = new MeshInstance(batch.meshInstance.mesh, batch.meshInstance.material, batch.meshInstance.node);
			batch2.meshInstance._updateAabb = false;
			batch2.meshInstance.parameters = clonedMeshInstances[0].parameters;
			batch2.meshInstance.cull = clonedMeshInstances[0].cull;
			batch2.meshInstance.layer = clonedMeshInstances[0].layer;
			if (batch.dynamic) {
				batch2.meshInstance.skinInstance = new SkinBatchInstance(this.device, nodes, this.rootNode);
			}
			batch2.meshInstance.castShadow = batch.meshInstance.castShadow;
			batch2.meshInstance._shader = batch.meshInstance._shader.slice();
			batch2.meshInstance.castShadow = batch.meshInstance.castShadow;
			return batch2;
		};
		_proto.destroyBatch = function destroyBatch(batch) {
			batch.destroy(this.scene, this._batchGroups[batch.batchGroupId].layers);
		};
		return BatchManager;
	}();

	var _colorUniformNames = ['uSceneColorMap', 'texture_grabPass'];
	var RenderPassColorGrab = function (_RenderPass) {
		_inheritsLoose(RenderPassColorGrab, _RenderPass);
		function RenderPassColorGrab(device, camera) {
			var _this;
			_this = _RenderPass.call(this, device) || this;
			_this.colorRenderTarget = null;
			_this.camera = null;
			_this.camera = camera;
			return _this;
		}
		var _proto = RenderPassColorGrab.prototype;
		_proto.destroy = function destroy() {
			_RenderPass.prototype.destroy.call(this);
			this.releaseRenderTarget(this.colorRenderTarget);
		};
		_proto.shouldReallocate = function shouldReallocate(targetRT, sourceTexture, sourceFormat) {
			var targetFormat = targetRT == null ? void 0 : targetRT.colorBuffer.format;
			if (targetFormat !== sourceFormat) return true;
			var width = (sourceTexture == null ? void 0 : sourceTexture.width) || this.device.width;
			var height = (sourceTexture == null ? void 0 : sourceTexture.height) || this.device.height;
			return !targetRT || width !== targetRT.width || height !== targetRT.height;
		};
		_proto.allocateRenderTarget = function allocateRenderTarget(renderTarget, sourceRenderTarget, device, format) {
			var mipmaps = device.isWebGL2;
			var texture = new Texture(device, {
				name: _colorUniformNames[0],
				format: format,
				width: sourceRenderTarget ? sourceRenderTarget.colorBuffer.width : device.width,
				height: sourceRenderTarget ? sourceRenderTarget.colorBuffer.height : device.height,
				mipmaps: mipmaps,
				minFilter: mipmaps ? FILTER_LINEAR_MIPMAP_LINEAR : FILTER_LINEAR,
				magFilter: FILTER_LINEAR,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE
			});
			if (renderTarget) {
				renderTarget.destroyFrameBuffers();
				renderTarget._colorBuffer = texture;
				renderTarget._colorBuffers = [texture];
			} else {
				renderTarget = new RenderTarget({
					name: 'ColorGrabRT',
					colorBuffer: texture,
					depth: false,
					stencil: false,
					autoResolve: false
				});
			}
			return renderTarget;
		};
		_proto.releaseRenderTarget = function releaseRenderTarget(rt) {
			if (rt) {
				rt.destroyTextureBuffers();
				rt.destroy();
			}
		};
		_proto.before = function before() {
			var _camera$renderTarget$, _camera$renderTarget, _camera$renderTarget2;
			var camera = this.camera;
			var device = this.device;
			var sourceFormat = (_camera$renderTarget$ = (_camera$renderTarget = camera.renderTarget) == null ? void 0 : _camera$renderTarget.colorBuffer.format) != null ? _camera$renderTarget$ : this.device.backBufferFormat;
			if (this.shouldReallocate(this.colorRenderTarget, (_camera$renderTarget2 = camera.renderTarget) == null ? void 0 : _camera$renderTarget2.colorBuffer, sourceFormat)) {
				this.releaseRenderTarget(this.colorRenderTarget);
				this.colorRenderTarget = this.allocateRenderTarget(this.colorRenderTarget, camera.renderTarget, device, sourceFormat);
			}
			var colorBuffer = this.colorRenderTarget.colorBuffer;
			_colorUniformNames.forEach(function (name) {
				return device.scope.resolve(name).setValue(colorBuffer);
			});
		};
		_proto.execute = function execute() {
			var device = this.device;
			var colorBuffer = this.colorRenderTarget.colorBuffer;
			if (device.isWebGPU) {
				device.copyRenderTarget(this.camera.renderTarget, this.colorRenderTarget, true, false);
				device.mipmapRenderer.generate(this.colorRenderTarget.colorBuffer.impl);
			} else if (device.isWebGL2) {
				device.copyRenderTarget(device.renderTarget, this.colorRenderTarget, true, false);
				device.activeTexture(device.maxCombinedTextures - 1);
				device.bindTexture(colorBuffer);
				device.gl.generateMipmap(colorBuffer.impl._glTarget);
			} else {
				if (!colorBuffer.impl._glTexture) {
					colorBuffer.impl.initialize(device, colorBuffer);
				}
				device.bindTexture(colorBuffer);
				var gl = device.gl;
				gl.copyTexImage2D(gl.TEXTURE_2D, 0, colorBuffer.impl._glFormat, 0, 0, colorBuffer.width, colorBuffer.height, 0);
				colorBuffer._needsUpload = false;
				colorBuffer._needsMipmapsUpload = false;
			}
		};
		return RenderPassColorGrab;
	}(RenderPass);

	var _depthUniformNames$1 = ['uSceneDepthMap', 'uDepthMap'];
	var RenderPassDepthGrab = function (_RenderPass) {
		_inheritsLoose(RenderPassDepthGrab, _RenderPass);
		function RenderPassDepthGrab(device, camera) {
			var _this;
			_this = _RenderPass.call(this, device) || this;
			_this.depthRenderTarget = null;
			_this.camera = null;
			_this.camera = camera;
			return _this;
		}
		var _proto = RenderPassDepthGrab.prototype;
		_proto.destroy = function destroy() {
			_RenderPass.prototype.destroy.call(this);
			this.releaseRenderTarget(this.depthRenderTarget);
		};
		_proto.shouldReallocate = function shouldReallocate(targetRT, sourceTexture) {
			var width = (sourceTexture == null ? void 0 : sourceTexture.width) || this.device.width;
			var height = (sourceTexture == null ? void 0 : sourceTexture.height) || this.device.height;
			return !targetRT || width !== targetRT.width || height !== targetRT.height;
		};
		_proto.allocateRenderTarget = function allocateRenderTarget(renderTarget, sourceRenderTarget, device, format, isDepth) {
			var texture = new Texture(device, {
				name: _depthUniformNames$1[0],
				format: format,
				width: sourceRenderTarget ? sourceRenderTarget.colorBuffer.width : device.width,
				height: sourceRenderTarget ? sourceRenderTarget.colorBuffer.height : device.height,
				mipmaps: false,
				minFilter: FILTER_NEAREST,
				magFilter: FILTER_NEAREST,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE
			});
			if (renderTarget) {
				renderTarget.destroyFrameBuffers();
				if (isDepth) {
					renderTarget._depthBuffer = texture;
				} else {
					renderTarget._colorBuffer = texture;
					renderTarget._colorBuffers = [texture];
				}
			} else {
				renderTarget = new RenderTarget({
					name: 'DepthGrabRT',
					colorBuffer: isDepth ? null : texture,
					depthBuffer: isDepth ? texture : null,
					depth: !isDepth,
					stencil: device.supportsStencil,
					autoResolve: false
				});
			}
			return renderTarget;
		};
		_proto.releaseRenderTarget = function releaseRenderTarget(rt) {
			if (rt) {
				rt.destroyTextureBuffers();
				rt.destroy();
			}
		};
		_proto.before = function before() {
			var _camera$renderTarget$2, _camera$renderTarget2, _camera$renderTarget3;
			var camera = this.camera;
			var device = this.device;
			var useDepthBuffer = true;
			var format = PIXELFORMAT_DEPTHSTENCIL;
			if (device.isWebGPU) {
				var _camera$renderTarget$, _camera$renderTarget;
				var numSamples = (_camera$renderTarget$ = (_camera$renderTarget = camera.renderTarget) == null ? void 0 : _camera$renderTarget.samples) != null ? _camera$renderTarget$ : device.samples;
				if (numSamples > 1) {
					format = PIXELFORMAT_R32F;
					useDepthBuffer = false;
				}
			}
			var sourceTexture = (_camera$renderTarget$2 = (_camera$renderTarget2 = camera.renderTarget) == null ? void 0 : _camera$renderTarget2.depthBuffer) != null ? _camera$renderTarget$2 : (_camera$renderTarget3 = camera.renderTarget) == null ? void 0 : _camera$renderTarget3.colorBuffer;
			if (this.shouldReallocate(this.depthRenderTarget, sourceTexture)) {
				this.releaseRenderTarget(this.depthRenderTarget);
				this.depthRenderTarget = this.allocateRenderTarget(this.depthRenderTarget, camera.renderTarget, device, format, useDepthBuffer);
			}
			var colorBuffer = useDepthBuffer ? this.depthRenderTarget.depthBuffer : this.depthRenderTarget.colorBuffer;
			_depthUniformNames$1.forEach(function (name) {
				return device.scope.resolve(name).setValue(colorBuffer);
			});
		};
		_proto.execute = function execute() {
			var device = this.device;
			if (device.isWebGL2 && device.renderTarget.samples > 1) {
				var src = device.renderTarget.impl._glFrameBuffer;
				var dest = this.depthRenderTarget;
				device.renderTarget = dest;
				device.updateBegin();
				this.depthRenderTarget.impl.internalResolve(device, src, dest.impl._glFrameBuffer, this.depthRenderTarget, device.gl.DEPTH_BUFFER_BIT);
			} else {
				device.copyRenderTarget(device.renderTarget, this.depthRenderTarget, false, true);
			}
		};
		return RenderPassDepthGrab;
	}(RenderPass);

	var webgl1DepthClearColor = new Color(254.0 / 255, 254.0 / 255, 254.0 / 255, 254.0 / 255);
	var tempMeshInstances$1 = [];
	var lights$1 = [[], [], []];
	var _depthUniformNames = ['uSceneDepthMap', 'uDepthMap'];
	var RenderPassDepth = function (_RenderPass) {
		_inheritsLoose(RenderPassDepth, _RenderPass);
		function RenderPassDepth(device, renderer, camera) {
			var _this;
			_this = _RenderPass.call(this, device) || this;
			_this.renderer = renderer;
			_this.camera = camera;
			return _this;
		}
		var _proto = RenderPassDepth.prototype;
		_proto.destroy = function destroy() {
			_RenderPass.prototype.destroy.call(this);
			this.releaseRenderTarget(this.renderTarget);
		};
		_proto.update = function update(scene) {
			this.scene = scene;
		};
		_proto.shouldReallocate = function shouldReallocate(targetRT, sourceRT) {
			var width = sourceRT.width;
			var height = sourceRT.height;
			return !targetRT || width !== targetRT.width || height !== targetRT.height;
		};
		_proto.allocateRenderTarget = function allocateRenderTarget(renderTarget, sourceRT, device) {
			var _sourceRT$width, _sourceRT$height;
			var texture = new Texture(device, {
				name: _depthUniformNames[0],
				format: PIXELFORMAT_RGBA8,
				width: (_sourceRT$width = sourceRT == null ? void 0 : sourceRT.width) != null ? _sourceRT$width : this.device.width,
				height: (_sourceRT$height = sourceRT == null ? void 0 : sourceRT.height) != null ? _sourceRT$height : this.device.height,
				mipmaps: false,
				minFilter: FILTER_NEAREST,
				magFilter: FILTER_NEAREST,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE
			});
			if (renderTarget) {
				renderTarget.destroyFrameBuffers();
				renderTarget._colorBuffer = texture;
				renderTarget._colorBuffers = [texture];
			} else {
				renderTarget = new RenderTarget({
					name: _depthUniformNames[0] + "RT}",
					colorBuffer: texture,
					depth: true,
					stencil: false
				});
			}
			return renderTarget;
		};
		_proto.releaseRenderTarget = function releaseRenderTarget(rt) {
			if (rt) {
				rt.destroyTextureBuffers();
				rt.destroy();
			}
		};
		_proto.before = function before() {
			var _camera$renderTarget;
			var camera = this.camera;
			var device = this.device;
			var sourceRT = (_camera$renderTarget = camera.renderTarget) != null ? _camera$renderTarget : device.backBuffer;
			if (this.shouldReallocate(this.renderTarget, sourceRT)) {
				var _this$renderTarget;
				(_this$renderTarget = this.renderTarget) == null || _this$renderTarget.destroyTextureBuffers();
				var renderTarget = this.allocateRenderTarget(this.renderTarget, camera.renderTarget, device);
				if (!this.renderTarget) {
					this.init(renderTarget);
					this.setClearColor(webgl1DepthClearColor);
					this.setClearDepth(1.0);
				} else {
					this.renderTarget = renderTarget;
				}
			}
			var colorBuffer = this.renderTarget.colorBuffer;
			_depthUniformNames.forEach(function (name) {
				return device.scope.resolve(name).setValue(colorBuffer);
			});
		};
		_proto.execute = function execute() {
			var device = this.device,
				renderer = this.renderer,
				camera = this.camera,
				scene = this.scene,
				renderTarget = this.renderTarget;
			var layers = scene.layers.layerList;
			var subLayerEnabled = scene.layers.subLayerEnabled;
			var isTransparent = scene.layers.subLayerList;
			for (var i = 0; i < layers.length; i++) {
				var layer = layers[i];
				if (layer.enabled && subLayerEnabled[i]) {
					if (layer.camerasSet.has(camera)) {
						if (layer.id === LAYERID_DEPTH) break;
						var culledInstances = layer.getCulledInstances(camera);
						var meshInstances = isTransparent[i] ? culledInstances.transparent : culledInstances.opaque;
						for (var j = 0; j < meshInstances.length; j++) {
							var _meshInstance$materia;
							var meshInstance = meshInstances[j];
							if ((_meshInstance$materia = meshInstance.material) != null && _meshInstance$materia.depthWrite && !meshInstance._noDepthDrawGl1) {
								tempMeshInstances$1.push(meshInstance);
							}
						}
						renderer.setCameraUniforms(camera, renderTarget);
						renderer.renderForward(camera, tempMeshInstances$1, lights$1, SHADER_DEPTH, function (meshInstance) {
							device.setBlendState(BlendState.NOBLEND);
						}, layer);
						tempMeshInstances$1.length = 0;
					}
				}
			}
		};
		return RenderPassDepth;
	}(RenderPass);

	var _deviceCoord = new Vec3();
	var _halfSize = new Vec3();
	var _point$1 = new Vec3();
	var _invViewProjMat = new Mat4();
	var _frustumPoints = [new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3()];
	var Camera = function () {
		function Camera() {
			this.shaderPassInfo = null;
			this.renderPassColorGrab = null;
			this.renderPassDepthGrab = null;
			this.renderPasses = [];
			this._aspectRatio = 16 / 9;
			this._aspectRatioMode = ASPECT_AUTO;
			this._calculateProjection = null;
			this._calculateTransform = null;
			this._clearColor = new Color(0.75, 0.75, 0.75, 1);
			this._clearColorBuffer = true;
			this._clearDepth = 1;
			this._clearDepthBuffer = true;
			this._clearStencil = 0;
			this._clearStencilBuffer = true;
			this._cullFaces = true;
			this._farClip = 1000;
			this._flipFaces = false;
			this._fov = 45;
			this._frustumCulling = true;
			this._horizontalFov = false;
			this._layers = [LAYERID_WORLD, LAYERID_DEPTH, LAYERID_SKYBOX, LAYERID_UI, LAYERID_IMMEDIATE];
			this._layersSet = new Set(this._layers);
			this._nearClip = 0.1;
			this._node = null;
			this._orthoHeight = 10;
			this._projection = PROJECTION_PERSPECTIVE;
			this._rect = new Vec4(0, 0, 1, 1);
			this._renderTarget = null;
			this._scissorRect = new Vec4(0, 0, 1, 1);
			this._scissorRectClear = false;
			this._aperture = 16.0;
			this._shutter = 1.0 / 1000.0;
			this._sensitivity = 1000;
			this._projMat = new Mat4();
			this._projMatDirty = true;
			this._projMatSkybox = new Mat4();
			this._viewMat = new Mat4();
			this._viewMatDirty = true;
			this._viewProjMat = new Mat4();
			this._viewProjMatDirty = true;
			this.frustum = new Frustum();
			this._xr = null;
			this._xrProperties = {
				horizontalFov: this._horizontalFov,
				fov: this._fov,
				aspectRatio: this._aspectRatio,
				farClip: this._farClip,
				nearClip: this._nearClip
			};
		}
		var _proto = Camera.prototype;
		_proto.destroy = function destroy() {
			var _this$renderPassColor, _this$renderPassDepth;
			(_this$renderPassColor = this.renderPassColorGrab) == null || _this$renderPassColor.destroy();
			this.renderPassColorGrab = null;
			(_this$renderPassDepth = this.renderPassDepthGrab) == null || _this$renderPassDepth.destroy();
			this.renderPassDepthGrab = null;
			this.renderPasses.length = 0;
		};
		_proto.clone = function clone() {
			return new Camera().copy(this);
		};
		_proto.copy = function copy(other) {
			this._aspectRatio = other._aspectRatio;
			this._farClip = other._farClip;
			this._fov = other._fov;
			this._horizontalFov = other._horizontalFov;
			this._nearClip = other._nearClip;
			this._xrProperties.aspectRatio = other._xrProperties.aspectRatio;
			this._xrProperties.farClip = other._xrProperties.farClip;
			this._xrProperties.fov = other._xrProperties.fov;
			this._xrProperties.horizontalFov = other._xrProperties.horizontalFov;
			this._xrProperties.nearClip = other._xrProperties.nearClip;
			this.aspectRatioMode = other.aspectRatioMode;
			this.calculateProjection = other.calculateProjection;
			this.calculateTransform = other.calculateTransform;
			this.clearColor = other.clearColor;
			this.clearColorBuffer = other.clearColorBuffer;
			this.clearDepth = other.clearDepth;
			this.clearDepthBuffer = other.clearDepthBuffer;
			this.clearStencil = other.clearStencil;
			this.clearStencilBuffer = other.clearStencilBuffer;
			this.cullFaces = other.cullFaces;
			this.flipFaces = other.flipFaces;
			this.frustumCulling = other.frustumCulling;
			this.layers = other.layers;
			this.orthoHeight = other.orthoHeight;
			this.projection = other.projection;
			this.rect = other.rect;
			this.renderTarget = other.renderTarget;
			this.scissorRect = other.scissorRect;
			this.aperture = other.aperture;
			this.shutter = other.shutter;
			this.sensitivity = other.sensitivity;
			this.shaderPassInfo = other.shaderPassInfo;
			this._projMatDirty = true;
			return this;
		};
		_proto._enableRenderPassColorGrab = function _enableRenderPassColorGrab(device, enable) {
			if (enable) {
				if (!this.renderPassColorGrab) {
					this.renderPassColorGrab = new RenderPassColorGrab(device, this);
				}
			} else {
				var _this$renderPassColor2;
				(_this$renderPassColor2 = this.renderPassColorGrab) == null || _this$renderPassColor2.destroy();
				this.renderPassColorGrab = null;
			}
		};
		_proto._enableRenderPassDepthGrab = function _enableRenderPassDepthGrab(device, renderer, enable) {
			if (enable) {
				if (!this.renderPassDepthGrab) {
					this.renderPassDepthGrab = device.isWebGL1 ? new RenderPassDepth(device, renderer, this) : new RenderPassDepthGrab(device, this);
				}
			} else {
				var _this$renderPassDepth2;
				(_this$renderPassDepth2 = this.renderPassDepthGrab) == null || _this$renderPassDepth2.destroy();
				this.renderPassDepthGrab = null;
			}
		};
		_proto._updateViewProjMat = function _updateViewProjMat() {
			if (this._projMatDirty || this._viewMatDirty || this._viewProjMatDirty) {
				this._viewProjMat.mul2(this.projectionMatrix, this.viewMatrix);
				this._viewProjMatDirty = false;
			}
		};
		_proto.worldToScreen = function worldToScreen(worldCoord, cw, ch, screenCoord) {
			if (screenCoord === void 0) {
				screenCoord = new Vec3();
			}
			this._updateViewProjMat();
			this._viewProjMat.transformPoint(worldCoord, screenCoord);
			var vpm = this._viewProjMat.data;
			var w = worldCoord.x * vpm[3] + worldCoord.y * vpm[7] + worldCoord.z * vpm[11] + 1 * vpm[15];
			screenCoord.x = (screenCoord.x / w + 1) * 0.5 * cw;
			screenCoord.y = (1 - screenCoord.y / w) * 0.5 * ch;
			return screenCoord;
		};
		_proto.screenToWorld = function screenToWorld(x, y, z, cw, ch, worldCoord) {
			if (worldCoord === void 0) {
				worldCoord = new Vec3();
			}
			var range = this.farClip - this.nearClip;
			_deviceCoord.set(x / cw, (ch - y) / ch, z / range);
			_deviceCoord.mulScalar(2);
			_deviceCoord.sub(Vec3.ONE);
			if (this._projection === PROJECTION_PERSPECTIVE) {
				Mat4._getPerspectiveHalfSize(_halfSize, this.fov, this.aspectRatio, this.nearClip, this.horizontalFov);
				_halfSize.x *= _deviceCoord.x;
				_halfSize.y *= _deviceCoord.y;
				var invView = this._node.getWorldTransform();
				_halfSize.z = -this.nearClip;
				invView.transformPoint(_halfSize, _point$1);
				var cameraPos = this._node.getPosition();
				worldCoord.sub2(_point$1, cameraPos);
				worldCoord.normalize();
				worldCoord.mulScalar(z);
				worldCoord.add(cameraPos);
			} else {
				this._updateViewProjMat();
				_invViewProjMat.copy(this._viewProjMat).invert();
				_invViewProjMat.transformPoint(_deviceCoord, worldCoord);
			}
			return worldCoord;
		};
		_proto._evaluateProjectionMatrix = function _evaluateProjectionMatrix() {
			if (this._projMatDirty) {
				if (this._projection === PROJECTION_PERSPECTIVE) {
					this._projMat.setPerspective(this.fov, this.aspectRatio, this.nearClip, this.farClip, this.horizontalFov);
					this._projMatSkybox.copy(this._projMat);
				} else {
					var y = this._orthoHeight;
					var x = y * this.aspectRatio;
					this._projMat.setOrtho(-x, x, -y, y, this.nearClip, this.farClip);
					this._projMatSkybox.setPerspective(this.fov, this.aspectRatio, this.nearClip, this.farClip);
				}
				this._projMatDirty = false;
			}
		};
		_proto.getProjectionMatrixSkybox = function getProjectionMatrixSkybox() {
			this._evaluateProjectionMatrix();
			return this._projMatSkybox;
		};
		_proto.getExposure = function getExposure() {
			var ev100 = Math.log2(this._aperture * this._aperture / this._shutter * 100.0 / this._sensitivity);
			return 1.0 / (Math.pow(2.0, ev100) * 1.2);
		};
		_proto.getScreenSize = function getScreenSize(sphere) {
			if (this._projection === PROJECTION_PERSPECTIVE) {
				var distance = this._node.getPosition().distance(sphere.center);
				if (distance < sphere.radius) {
					return 1;
				}
				var viewAngle = Math.asin(sphere.radius / distance);
				var sphereViewHeight = Math.tan(viewAngle);
				var screenViewHeight = Math.tan(this.fov / 2 * math.DEG_TO_RAD);
				return Math.min(sphereViewHeight / screenViewHeight, 1);
			}
			return math.clamp(sphere.radius / this._orthoHeight, 0, 1);
		};
		_proto.getFrustumCorners = function getFrustumCorners(near, far) {
			if (near === void 0) {
				near = this.nearClip;
			}
			if (far === void 0) {
				far = this.farClip;
			}
			var fov = this.fov * Math.PI / 180.0;
			var y = this._projection === PROJECTION_PERSPECTIVE ? Math.tan(fov / 2.0) * near : this._orthoHeight;
			var x = y * this.aspectRatio;
			var points = _frustumPoints;
			points[0].x = x;
			points[0].y = -y;
			points[0].z = -near;
			points[1].x = x;
			points[1].y = y;
			points[1].z = -near;
			points[2].x = -x;
			points[2].y = y;
			points[2].z = -near;
			points[3].x = -x;
			points[3].y = -y;
			points[3].z = -near;
			if (this._projection === PROJECTION_PERSPECTIVE) {
				y = Math.tan(fov / 2.0) * far;
				x = y * this.aspectRatio;
			}
			points[4].x = x;
			points[4].y = -y;
			points[4].z = -far;
			points[5].x = x;
			points[5].y = y;
			points[5].z = -far;
			points[6].x = -x;
			points[6].y = y;
			points[6].z = -far;
			points[7].x = -x;
			points[7].y = -y;
			points[7].z = -far;
			return points;
		};
		_proto.setXrProperties = function setXrProperties(properties) {
			Object.assign(this._xrProperties, properties);
			this._projMatDirty = true;
		};
		_createClass(Camera, [{
			key: "fullSizeClearRect",
			get: function get() {
				var rect = this._scissorRectClear ? this.scissorRect : this._rect;
				return rect.x === 0 && rect.y === 0 && rect.z === 1 && rect.w === 1;
			}
		}, {
			key: "aspectRatio",
			get: function get() {
				var _this$xr;
				return (_this$xr = this.xr) != null && _this$xr.active ? this._xrProperties.aspectRatio : this._aspectRatio;
			},
			set: function set(newValue) {
				if (this._aspectRatio !== newValue) {
					this._aspectRatio = newValue;
					this._projMatDirty = true;
				}
			}
		}, {
			key: "aspectRatioMode",
			get: function get() {
				return this._aspectRatioMode;
			},
			set: function set(newValue) {
				if (this._aspectRatioMode !== newValue) {
					this._aspectRatioMode = newValue;
					this._projMatDirty = true;
				}
			}
		}, {
			key: "calculateProjection",
			get: function get() {
				return this._calculateProjection;
			},
			set: function set(newValue) {
				this._calculateProjection = newValue;
				this._projMatDirty = true;
			}
		}, {
			key: "calculateTransform",
			get: function get() {
				return this._calculateTransform;
			},
			set: function set(newValue) {
				this._calculateTransform = newValue;
			}
		}, {
			key: "clearColor",
			get: function get() {
				return this._clearColor;
			},
			set: function set(newValue) {
				this._clearColor.copy(newValue);
			}
		}, {
			key: "clearColorBuffer",
			get: function get() {
				return this._clearColorBuffer;
			},
			set: function set(newValue) {
				this._clearColorBuffer = newValue;
			}
		}, {
			key: "clearDepth",
			get: function get() {
				return this._clearDepth;
			},
			set: function set(newValue) {
				this._clearDepth = newValue;
			}
		}, {
			key: "clearDepthBuffer",
			get: function get() {
				return this._clearDepthBuffer;
			},
			set: function set(newValue) {
				this._clearDepthBuffer = newValue;
			}
		}, {
			key: "clearStencil",
			get: function get() {
				return this._clearStencil;
			},
			set: function set(newValue) {
				this._clearStencil = newValue;
			}
		}, {
			key: "clearStencilBuffer",
			get: function get() {
				return this._clearStencilBuffer;
			},
			set: function set(newValue) {
				this._clearStencilBuffer = newValue;
			}
		}, {
			key: "cullFaces",
			get: function get() {
				return this._cullFaces;
			},
			set: function set(newValue) {
				this._cullFaces = newValue;
			}
		}, {
			key: "farClip",
			get: function get() {
				var _this$xr2;
				return (_this$xr2 = this.xr) != null && _this$xr2.active ? this._xrProperties.farClip : this._farClip;
			},
			set: function set(newValue) {
				if (this._farClip !== newValue) {
					this._farClip = newValue;
					this._projMatDirty = true;
				}
			}
		}, {
			key: "flipFaces",
			get: function get() {
				return this._flipFaces;
			},
			set: function set(newValue) {
				this._flipFaces = newValue;
			}
		}, {
			key: "fov",
			get: function get() {
				var _this$xr3;
				return (_this$xr3 = this.xr) != null && _this$xr3.active ? this._xrProperties.fov : this._fov;
			},
			set: function set(newValue) {
				if (this._fov !== newValue) {
					this._fov = newValue;
					this._projMatDirty = true;
				}
			}
		}, {
			key: "frustumCulling",
			get: function get() {
				return this._frustumCulling;
			},
			set: function set(newValue) {
				this._frustumCulling = newValue;
			}
		}, {
			key: "horizontalFov",
			get: function get() {
				var _this$xr4;
				return (_this$xr4 = this.xr) != null && _this$xr4.active ? this._xrProperties.horizontalFov : this._horizontalFov;
			},
			set: function set(newValue) {
				if (this._horizontalFov !== newValue) {
					this._horizontalFov = newValue;
					this._projMatDirty = true;
				}
			}
		}, {
			key: "layers",
			get: function get() {
				return this._layers;
			},
			set: function set(newValue) {
				this._layers = newValue.slice(0);
				this._layersSet = new Set(this._layers);
			}
		}, {
			key: "layersSet",
			get: function get() {
				return this._layersSet;
			}
		}, {
			key: "nearClip",
			get: function get() {
				var _this$xr5;
				return (_this$xr5 = this.xr) != null && _this$xr5.active ? this._xrProperties.nearClip : this._nearClip;
			},
			set: function set(newValue) {
				if (this._nearClip !== newValue) {
					this._nearClip = newValue;
					this._projMatDirty = true;
				}
			}
		}, {
			key: "node",
			get: function get() {
				return this._node;
			},
			set: function set(newValue) {
				this._node = newValue;
			}
		}, {
			key: "orthoHeight",
			get: function get() {
				return this._orthoHeight;
			},
			set: function set(newValue) {
				if (this._orthoHeight !== newValue) {
					this._orthoHeight = newValue;
					this._projMatDirty = true;
				}
			}
		}, {
			key: "projection",
			get: function get() {
				return this._projection;
			},
			set: function set(newValue) {
				if (this._projection !== newValue) {
					this._projection = newValue;
					this._projMatDirty = true;
				}
			}
		}, {
			key: "projectionMatrix",
			get: function get() {
				this._evaluateProjectionMatrix();
				return this._projMat;
			}
		}, {
			key: "rect",
			get: function get() {
				return this._rect;
			},
			set: function set(newValue) {
				this._rect.copy(newValue);
			}
		}, {
			key: "renderTarget",
			get: function get() {
				return this._renderTarget;
			},
			set: function set(newValue) {
				this._renderTarget = newValue;
			}
		}, {
			key: "scissorRect",
			get: function get() {
				return this._scissorRect;
			},
			set: function set(newValue) {
				this._scissorRect.copy(newValue);
			}
		}, {
			key: "viewMatrix",
			get: function get() {
				if (this._viewMatDirty) {
					var wtm = this._node.getWorldTransform();
					this._viewMat.copy(wtm).invert();
					this._viewMatDirty = false;
				}
				return this._viewMat;
			}
		}, {
			key: "aperture",
			get: function get() {
				return this._aperture;
			},
			set: function set(newValue) {
				this._aperture = newValue;
			}
		}, {
			key: "sensitivity",
			get: function get() {
				return this._sensitivity;
			},
			set: function set(newValue) {
				this._sensitivity = newValue;
			}
		}, {
			key: "shutter",
			get: function get() {
				return this._shutter;
			},
			set: function set(newValue) {
				this._shutter = newValue;
			}
		}, {
			key: "xr",
			get: function get() {
				return this._xr;
			},
			set: function set(newValue) {
				if (this._xr !== newValue) {
					this._xr = newValue;
					this._projMatDirty = true;
				}
			}
		}]);
		return Camera;
	}();

	var LitShaderOptions = function LitShaderOptions() {
		this.hasTangents = false;
		this.chunks = {};
		this.pass = 0;
		this.alphaTest = false;
		this.blendType = BLEND_NONE;
		this.separateAmbient = false;
		this.screenSpace = false;
		this.skin = false;
		this.useInstancing = false;
		this.useMorphPosition = false;
		this.useMorphNormal = false;
		this.useMorphTextureBased = false;
		this.nineSlicedMode = 0;
		this.clusteredLightingEnabled = true;
		this.clusteredLightingCookiesEnabled = false;
		this.clusteredLightingShadowsEnabled = false;
		this.clusteredLightingShadowType = 0;
		this.clusteredLightingAreaLightsEnabled = false;
		this.vertexColors = false;
		this.lightMapEnabled = false;
		this.dirLightMapEnabled = false;
		this.useHeights = false;
		this.useNormals = false;
		this.useClearCoatNormals = false;
		this.useAo = false;
		this.diffuseMapEnabled = false;
		this.useAmbientTint = false;
		this.customFragmentShader = null;
		this.pixelSnap = false;
		this.shadingModel = 0;
		this.ambientSH = false;
		this.fastTbn = false;
		this.twoSidedLighting = false;
		this.occludeDirect = false;
		this.occludeSpecular = 0;
		this.occludeSpecularFloat = false;
		this.useMsdf = false;
		this.msdfTextAttribute = false;
		this.alphaToCoverage = false;
		this.opacityFadesSpecular = false;
		this.cubeMapProjection = 0;
		this.conserveEnergy = false;
		this.useSpecular = false;
		this.useSpecularityFactor = false;
		this.enableGGXSpecular = false;
		this.fresnelModel = 0;
		this.useRefraction = false;
		this.useClearCoat = false;
		this.useSheen = false;
		this.useIridescence = false;
		this.useMetalness = false;
		this.useDynamicRefraction = false;
		this.fog = FOG_NONE;
		this.gamma = GAMMA_NONE;
		this.toneMap = -1;
		this.fixSeams = false;
		this.reflectionSource = null;
		this.reflectionEncoding = null;
		this.reflectionCubemapEncoding = null;
		this.ambientSource = 'constant';
		this.ambientEncoding = null;
		this.skyboxIntensity = 1.0;
		this.useCubeMapRotation = false;
		this.lightMapWithoutAmbient = false;
		this.lights = [];
		this.noShadow = false;
		this.lightMaskDynamic = 0x0;
		this.userAttributes = {};
	};

	var LitMaterialOptions = function LitMaterialOptions() {
		this.usedUvs = void 0;
		this.shaderChunk = void 0;
		this.litOptions = new LitShaderOptions();
	};

	var LitMaterialOptionsBuilder = function () {
		function LitMaterialOptionsBuilder() {}
		LitMaterialOptionsBuilder.update = function update(litOptions, material, scene, objDefs, pass, sortedLights) {
			LitMaterialOptionsBuilder.updateSharedOptions(litOptions, material, scene, objDefs, pass);
			LitMaterialOptionsBuilder.updateMaterialOptions(litOptions, material);
			LitMaterialOptionsBuilder.updateEnvOptions(litOptions, material, scene);
			LitMaterialOptionsBuilder.updateLightingOptions(litOptions, material, objDefs, sortedLights);
			if (pass === SHADER_FORWARDHDR) {
				litOptions.gamma = GAMMA_SRGBHDR;
				litOptions.toneMap = TONEMAP_LINEAR;
			}
		};
		LitMaterialOptionsBuilder.updateSharedOptions = function updateSharedOptions(litOptions, material, scene, objDefs, pass) {
			litOptions.chunks = material.chunks;
			litOptions.pass = pass;
			litOptions.alphaTest = material.alphaTest > 0;
			litOptions.blendType = material.blendType;
			litOptions.screenSpace = objDefs && (objDefs & SHADERDEF_SCREENSPACE) !== 0;
			litOptions.skin = objDefs && (objDefs & SHADERDEF_SKIN) !== 0;
			litOptions.useInstancing = objDefs && (objDefs & SHADERDEF_INSTANCING) !== 0;
			litOptions.useMorphPosition = objDefs && (objDefs & SHADERDEF_MORPH_POSITION) !== 0;
			litOptions.useMorphNormal = objDefs && (objDefs & SHADERDEF_MORPH_NORMAL) !== 0;
			litOptions.useMorphTextureBased = objDefs && (objDefs & SHADERDEF_MORPH_TEXTURE_BASED) !== 0;
			litOptions.hasTangents = objDefs && (objDefs & SHADERDEF_TANGENTS) !== 0;
			litOptions.nineSlicedMode = material.nineSlicedMode || SPRITE_RENDERMODE_SIMPLE;
			if (material.useLighting && scene.clusteredLightingEnabled) {
				litOptions.clusteredLightingEnabled = true;
				litOptions.clusteredLightingCookiesEnabled = scene.lighting.cookiesEnabled;
				litOptions.clusteredLightingShadowsEnabled = scene.lighting.shadowsEnabled;
				litOptions.clusteredLightingShadowType = scene.lighting.shadowType;
				litOptions.clusteredLightingAreaLightsEnabled = scene.lighting.areaLightsEnabled;
			} else {
				litOptions.clusteredLightingEnabled = false;
				litOptions.clusteredLightingCookiesEnabled = false;
				litOptions.clusteredLightingShadowsEnabled = false;
				litOptions.clusteredLightingAreaLightsEnabled = false;
			}
		};
		LitMaterialOptionsBuilder.updateMaterialOptions = function updateMaterialOptions(litOptions, material) {
			litOptions.useAmbientTint = false;
			litOptions.separateAmbient = false;
			litOptions.customFragmentShader = null;
			litOptions.pixelSnap = material.pixelSnap;
			litOptions.shadingModel = material.shadingModel;
			litOptions.ambientSH = material.ambientSH;
			litOptions.fastTbn = material.fastTbn;
			litOptions.twoSidedLighting = material.twoSidedLighting;
			litOptions.occludeDirect = material.occludeDirect;
			litOptions.occludeSpecular = material.occludeSpecular;
			litOptions.occludeSpecularFloat = material.occludeSpecularIntensity !== 1.0;
			litOptions.useMsdf = false;
			litOptions.msdfTextAttribute = false;
			litOptions.alphaToCoverage = material.alphaToCoverage;
			litOptions.opacityFadesSpecular = material.opacityFadesSpecular;
			litOptions.cubeMapProjection = CUBEPROJ_NONE;
			litOptions.conserveEnergy = material.conserveEnergy && material.shadingModel === SPECULAR_BLINN;
			litOptions.useSpecular = material.hasSpecular;
			litOptions.useSpecularityFactor = material.hasSpecularityFactor;
			litOptions.enableGGXSpecular = material.ggxSpecular;
			litOptions.fresnelModel = material.fresnelModel;
			litOptions.useRefraction = material.hasRefraction;
			litOptions.useClearCoat = material.hasClearCoat;
			litOptions.useSheen = material.hasSheen;
			litOptions.useIridescence = material.hasIrridescence;
			litOptions.useMetalness = material.hasMetalness;
			litOptions.useDynamicRefraction = material.dynamicRefraction;
			litOptions.vertexColors = false;
			litOptions.lightMapEnabled = material.hasLighting;
			litOptions.dirLightMapEnabled = material.dirLightMap;
			litOptions.useHeights = material.hasHeights;
			litOptions.useNormals = material.hasNormals;
			litOptions.useClearCoatNormals = material.hasClearCoatNormals;
			litOptions.useAo = material.hasAo;
			litOptions.diffuseMapEnabled = material.hasDiffuseMap;
		};
		LitMaterialOptionsBuilder.updateEnvOptions = function updateEnvOptions(litOptions, material, scene) {
			litOptions.fog = material.useFog ? scene.fog : 'none';
			litOptions.gamma = material.useGammaTonemap ? scene.gammaCorrection : GAMMA_NONE;
			litOptions.toneMap = material.useGammaTonemap ? scene.toneMapping : -1;
			litOptions.fixSeams = false;
			if (material.useSkybox && scene.envAtlas && scene.skybox) {
				litOptions.reflectionSource = 'envAtlasHQ';
				litOptions.reflectionEncoding = scene.envAtlas.encoding;
				litOptions.reflectionCubemapEncoding = scene.skybox.encoding;
			} else if (material.useSkybox && scene.envAtlas) {
				litOptions.reflectionSource = 'envAtlas';
				litOptions.reflectionEncoding = scene.envAtlas.encoding;
			} else if (material.useSkybox && scene.skybox) {
				litOptions.reflectionSource = 'cubeMap';
				litOptions.reflectionEncoding = scene.skybox.encoding;
			} else {
				litOptions.reflectionSource = null;
				litOptions.reflectionEncoding = null;
			}
			if (material.ambientSH) {
				litOptions.ambientSource = 'ambientSH';
				litOptions.ambientEncoding = null;
			} else if (litOptions.reflectionSource && scene.envAtlas) {
				litOptions.ambientSource = 'envAtlas';
				litOptions.ambientEncoding = scene.envAtlas.encoding;
			} else {
				litOptions.ambientSource = 'constant';
				litOptions.ambientEncoding = null;
			}
			var hasSkybox = !!litOptions.reflectionSource;
			litOptions.skyboxIntensity = hasSkybox && (scene.skyboxIntensity !== 1 || scene.physicalUnits);
			litOptions.useCubeMapRotation = hasSkybox && scene._skyboxRotationShaderInclude;
		};
		LitMaterialOptionsBuilder.updateLightingOptions = function updateLightingOptions(litOptions, material, objDefs, sortedLights) {
			litOptions.lightMapWithoutAmbient = false;
			if (material.useLighting) {
				var lightsFiltered = [];
				var mask = objDefs ? objDefs >> 16 : MASK_AFFECT_DYNAMIC;
				litOptions.lightMaskDynamic = !!(mask & MASK_AFFECT_DYNAMIC);
				litOptions.lightMapWithoutAmbient = false;
				if (sortedLights) {
					LitMaterialOptionsBuilder.collectLights(LIGHTTYPE_DIRECTIONAL, sortedLights[LIGHTTYPE_DIRECTIONAL], lightsFiltered, mask);
					LitMaterialOptionsBuilder.collectLights(LIGHTTYPE_OMNI, sortedLights[LIGHTTYPE_OMNI], lightsFiltered, mask);
					LitMaterialOptionsBuilder.collectLights(LIGHTTYPE_SPOT, sortedLights[LIGHTTYPE_SPOT], lightsFiltered, mask);
				}
				litOptions.lights = lightsFiltered;
			} else {
				litOptions.lights = [];
			}
			if (litOptions.lights.length === 0 || (objDefs & SHADERDEF_NOSHADOW) !== 0) {
				litOptions.noShadow = true;
			}
		};
		LitMaterialOptionsBuilder.collectLights = function collectLights(lType, lights, lightsFiltered, mask) {
			for (var i = 0; i < lights.length; i++) {
				var light = lights[i];
				if (light.enabled) {
					if (light.mask & mask) {
						lightsFiltered.push(light);
					}
				}
			}
		};
		return LitMaterialOptionsBuilder;
	}();

	var ChunkBuilder = function () {
		function ChunkBuilder() {
			this.code = '';
		}
		var _proto = ChunkBuilder.prototype;
		_proto.append = function append() {
			var _this = this;
			for (var _len = arguments.length, chunks = new Array(_len), _key = 0; _key < _len; _key++) {
				chunks[_key] = arguments[_key];
			}
			chunks.forEach(function (chunk) {
				if (chunk.endsWith('\n')) {
					_this.code += chunk;
				} else {
					_this.code += chunk + '\n';
				}
			});
		};
		_proto.prepend = function prepend() {
			var _this2 = this;
			for (var _len2 = arguments.length, chunks = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
				chunks[_key2] = arguments[_key2];
			}
			chunks.forEach(function (chunk) {
				if (chunk.endsWith('\n')) {
					_this2.code = chunk + _this2.code;
				} else {
					_this2.code = chunk + '\n' + _this2.code;
				}
			});
		};
		return ChunkBuilder;
	}();

	var decodeTable = {
		'linear': 'decodeLinear',
		'srgb': 'decodeGamma',
		'rgbm': 'decodeRGBM',
		'rgbe': 'decodeRGBE',
		'rgbp': 'decodeRGBP'
	};
	var encodeTable = {
		'linear': 'encodeLinear',
		'srgb': 'encodeGamma',
		'rgbm': 'encodeRGBM',
		'rgbe': 'encodeRGBE',
		'rgbp': 'encodeRGBP'
	};
	var ChunkUtils = function () {
		function ChunkUtils() {}
		ChunkUtils.decodeFunc = function decodeFunc(encoding) {
			return decodeTable[encoding] || 'decodeGamma';
		};
		ChunkUtils.encodeFunc = function encodeFunc(encoding) {
			return encodeTable[encoding] || 'encodeGamma';
		};
		return ChunkUtils;
	}();

	var _viewMat = new Mat4();
	var _viewProjMat = new Mat4();
	var _viewportMatrix = new Mat4();
	var LightCamera = function () {
		function LightCamera() {}
		LightCamera.create = function create(name, lightType, face) {
			var camera = new Camera();
			camera.node = new GraphNode(name);
			camera.aspectRatio = 1;
			camera.aspectRatioMode = ASPECT_MANUAL;
			camera._scissorRectClear = true;
			switch (lightType) {
				case LIGHTTYPE_OMNI:
					camera.node.setRotation(LightCamera.pointLightRotations[face]);
					camera.fov = 90;
					camera.projection = PROJECTION_PERSPECTIVE;
					break;
				case LIGHTTYPE_SPOT:
					camera.projection = PROJECTION_PERSPECTIVE;
					break;
				case LIGHTTYPE_DIRECTIONAL:
					camera.projection = PROJECTION_ORTHOGRAPHIC;
					break;
			}
			return camera;
		};
		LightCamera.evalSpotCookieMatrix = function evalSpotCookieMatrix(light) {
			var cookieCamera = LightCamera._spotCookieCamera;
			if (!cookieCamera) {
				cookieCamera = LightCamera.create('SpotCookieCamera', LIGHTTYPE_SPOT);
				LightCamera._spotCookieCamera = cookieCamera;
			}
			cookieCamera.fov = light._outerConeAngle * 2;
			var cookieNode = cookieCamera._node;
			cookieNode.setPosition(light._node.getPosition());
			cookieNode.setRotation(light._node.getRotation());
			cookieNode.rotateLocal(-90, 0, 0);
			_viewMat.setTRS(cookieNode.getPosition(), cookieNode.getRotation(), Vec3.ONE).invert();
			_viewProjMat.mul2(cookieCamera.projectionMatrix, _viewMat);
			var cookieMatrix = light.cookieMatrix;
			var rectViewport = light.atlasViewport;
			_viewportMatrix.setViewport(rectViewport.x, rectViewport.y, rectViewport.z, rectViewport.w);
			cookieMatrix.mul2(_viewportMatrix, _viewProjMat);
			return cookieMatrix;
		};
		return LightCamera;
	}();
	LightCamera.pointLightRotations = [new Quat().setFromEulerAngles(0, 90, 180), new Quat().setFromEulerAngles(0, -90, 180), new Quat().setFromEulerAngles(90, 0, 0), new Quat().setFromEulerAngles(-90, 0, 0), new Quat().setFromEulerAngles(0, 180, 180), new Quat().setFromEulerAngles(0, 0, 180)];
	LightCamera._spotCookieCamera = null;

	var _class$1;
	var epsilon$1 = 0.000001;
	var tempVec3$1 = new Vec3();
	var tempAreaLightSizes = new Float32Array(6);
	var areaHalfAxisWidth = new Vec3(-0.5, 0, 0);
	var areaHalfAxisHeight = new Vec3(0, 0, 0.5);
	var TextureIndex8 = {
		FLAGS: 0,
		COLOR_A: 1,
		COLOR_B: 2,
		SPOT_ANGLES: 3,
		SHADOW_BIAS: 4,
		COOKIE_A: 5,
		COOKIE_B: 6,
		COUNT_ALWAYS: 7,
		POSITION_X: 7,
		POSITION_Y: 8,
		POSITION_Z: 9,
		RANGE: 10,
		SPOT_DIRECTION_X: 11,
		SPOT_DIRECTION_Y: 12,
		SPOT_DIRECTION_Z: 13,
		PROJ_MAT_00: 14,
		ATLAS_VIEWPORT_A: 14,
		PROJ_MAT_01: 15,
		ATLAS_VIEWPORT_B: 15,
		PROJ_MAT_02: 16,
		PROJ_MAT_03: 17,
		PROJ_MAT_10: 18,
		PROJ_MAT_11: 19,
		PROJ_MAT_12: 20,
		PROJ_MAT_13: 21,
		PROJ_MAT_20: 22,
		PROJ_MAT_21: 23,
		PROJ_MAT_22: 24,
		PROJ_MAT_23: 25,
		PROJ_MAT_30: 26,
		PROJ_MAT_31: 27,
		PROJ_MAT_32: 28,
		PROJ_MAT_33: 29,
		AREA_DATA_WIDTH_X: 30,
		AREA_DATA_WIDTH_Y: 31,
		AREA_DATA_WIDTH_Z: 32,
		AREA_DATA_HEIGHT_X: 33,
		AREA_DATA_HEIGHT_Y: 34,
		AREA_DATA_HEIGHT_Z: 35,
		COUNT: 36
	};
	var TextureIndexFloat = {
		POSITION_RANGE: 0,
		SPOT_DIRECTION: 1,
		PROJ_MAT_0: 2,
		ATLAS_VIEWPORT: 2,
		PROJ_MAT_1: 3,
		PROJ_MAT_2: 4,
		PROJ_MAT_3: 5,
		AREA_DATA_WIDTH: 6,
		AREA_DATA_HEIGHT: 7,
		COUNT: 8
	};
	var LightsBuffer = function () {
		LightsBuffer.initShaderDefines = function initShaderDefines() {
			var clusterTextureFormat = LightsBuffer.lightTextureFormat === LightsBuffer.FORMAT_FLOAT ? 'FLOAT' : '8BIT';
			LightsBuffer.shaderDefines = "\n            \n#define CLUSTER_TEXTURE_" + clusterTextureFormat + "\n            " + LightsBuffer.buildShaderDefines(TextureIndex8, 'CLUSTER_TEXTURE_8_') + "\n            " + LightsBuffer.buildShaderDefines(TextureIndexFloat, 'CLUSTER_TEXTURE_F_') + "\n        ";
		};
		LightsBuffer.buildShaderDefines = function buildShaderDefines(object, prefix) {
			var str = '';
			var floatOffset = LightsBuffer.useTexelFetch ? '' : '.5';
			Object.keys(object).forEach(function (key) {
				str += "\n#define " + prefix + key + " " + object[key] + floatOffset;
			});
			return str;
		};
		LightsBuffer.init = function init(device) {
			LightsBuffer.lightTextureFormat = device.extTextureFloat && device.maxTextures > 8 ? LightsBuffer.FORMAT_FLOAT : LightsBuffer.FORMAT_8BIT;
			LightsBuffer.useTexelFetch = device.supportsTextureFetch;
			LightsBuffer.initShaderDefines();
		};
		LightsBuffer.createTexture = function createTexture(device, width, height, format, name) {
			var tex = new Texture(device, {
				name: name,
				width: width,
				height: height,
				mipmaps: false,
				format: format,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE,
				type: TEXTURETYPE_DEFAULT,
				magFilter: FILTER_NEAREST,
				minFilter: FILTER_NEAREST,
				anisotropy: 1
			});
			return tex;
		};
		function LightsBuffer(device) {
			this.device = device;
			this.cookiesEnabled = false;
			this.shadowsEnabled = false;
			this.areaLightsEnabled = false;
			this.maxLights = 255;
			var pixelsPerLight8 = TextureIndex8.COUNT_ALWAYS;
			var pixelsPerLightFloat = 0;
			if (LightsBuffer.lightTextureFormat === LightsBuffer.FORMAT_FLOAT) {
				pixelsPerLightFloat = TextureIndexFloat.COUNT;
			} else {
				pixelsPerLight8 = TextureIndex8.COUNT;
			}
			this.lights8 = new Uint8ClampedArray(4 * pixelsPerLight8 * this.maxLights);
			this.lightsTexture8 = LightsBuffer.createTexture(this.device, pixelsPerLight8, this.maxLights, PIXELFORMAT_RGBA8, 'LightsTexture8');
			this._lightsTexture8Id = this.device.scope.resolve('lightsTexture8');
			if (pixelsPerLightFloat) {
				this.lightsFloat = new Float32Array(4 * pixelsPerLightFloat * this.maxLights);
				this.lightsTextureFloat = LightsBuffer.createTexture(this.device, pixelsPerLightFloat, this.maxLights, PIXELFORMAT_RGBA32F, 'LightsTextureFloat');
				this._lightsTextureFloatId = this.device.scope.resolve('lightsTextureFloat');
			} else {
				this.lightsFloat = null;
				this.lightsTextureFloat = null;
				this._lightsTextureFloatId = undefined;
			}
			this._lightsTextureInvSizeId = this.device.scope.resolve('lightsTextureInvSize');
			this._lightsTextureInvSizeData = new Float32Array(4);
			this._lightsTextureInvSizeData[0] = pixelsPerLightFloat ? 1.0 / this.lightsTextureFloat.width : 0;
			this._lightsTextureInvSizeData[1] = pixelsPerLightFloat ? 1.0 / this.lightsTextureFloat.height : 0;
			this._lightsTextureInvSizeData[2] = 1.0 / this.lightsTexture8.width;
			this._lightsTextureInvSizeData[3] = 1.0 / this.lightsTexture8.height;
			this.invMaxColorValue = 0;
			this.invMaxAttenuation = 0;
			this.boundsMin = new Vec3();
			this.boundsDelta = new Vec3();
		}
		var _proto = LightsBuffer.prototype;
		_proto.destroy = function destroy() {
			if (this.lightsTexture8) {
				this.lightsTexture8.destroy();
				this.lightsTexture8 = null;
			}
			if (this.lightsTextureFloat) {
				this.lightsTextureFloat.destroy();
				this.lightsTextureFloat = null;
			}
		};
		_proto.setCompressionRanges = function setCompressionRanges(maxAttenuation, maxColorValue) {
			this.invMaxColorValue = 1 / maxColorValue;
			this.invMaxAttenuation = 1 / maxAttenuation;
		};
		_proto.setBounds = function setBounds(min, delta) {
			this.boundsMin.copy(min);
			this.boundsDelta.copy(delta);
		};
		_proto.uploadTextures = function uploadTextures() {
			if (this.lightsTextureFloat) {
				this.lightsTextureFloat.lock().set(this.lightsFloat);
				this.lightsTextureFloat.unlock();
			}
			this.lightsTexture8.lock().set(this.lights8);
			this.lightsTexture8.unlock();
		};
		_proto.updateUniforms = function updateUniforms() {
			this._lightsTexture8Id.setValue(this.lightsTexture8);
			if (LightsBuffer.lightTextureFormat === LightsBuffer.FORMAT_FLOAT) {
				this._lightsTextureFloatId.setValue(this.lightsTextureFloat);
			}
			this._lightsTextureInvSizeId.setValue(this._lightsTextureInvSizeData);
		};
		_proto.getSpotDirection = function getSpotDirection(direction, spot) {
			var mat = spot._node.getWorldTransform();
			mat.getY(direction).mulScalar(-1);
			direction.normalize();
		};
		_proto.getLightAreaSizes = function getLightAreaSizes(light) {
			var mat = light._node.getWorldTransform();
			mat.transformVector(areaHalfAxisWidth, tempVec3$1);
			tempAreaLightSizes[0] = tempVec3$1.x;
			tempAreaLightSizes[1] = tempVec3$1.y;
			tempAreaLightSizes[2] = tempVec3$1.z;
			mat.transformVector(areaHalfAxisHeight, tempVec3$1);
			tempAreaLightSizes[3] = tempVec3$1.x;
			tempAreaLightSizes[4] = tempVec3$1.y;
			tempAreaLightSizes[5] = tempVec3$1.z;
			return tempAreaLightSizes;
		};
		_proto.addLightDataFlags = function addLightDataFlags(data8, index, light, isSpot, castShadows, shadowIntensity) {
			data8[index + 0] = isSpot ? 255 : 0;
			data8[index + 1] = light._shape * 64;
			data8[index + 2] = light._falloffMode * 255;
			data8[index + 3] = castShadows ? shadowIntensity * 255 : 0;
		};
		_proto.addLightDataColor = function addLightDataColor(data8, index, light, gammaCorrection, isCookie) {
			var invMaxColorValue = this.invMaxColorValue;
			var color = gammaCorrection ? light._linearFinalColor : light._finalColor;
			FloatPacking.float2Bytes(color[0] * invMaxColorValue, data8, index + 0, 2);
			FloatPacking.float2Bytes(color[1] * invMaxColorValue, data8, index + 2, 2);
			FloatPacking.float2Bytes(color[2] * invMaxColorValue, data8, index + 4, 2);
			data8[index + 6] = isCookie ? 255 : 0;
			var isDynamic = !!(light.mask & MASK_AFFECT_DYNAMIC);
			var isLightmapped = !!(light.mask & MASK_AFFECT_LIGHTMAPPED);
			data8[index + 7] = isDynamic && isLightmapped ? 127 : isLightmapped ? 255 : 0;
		};
		_proto.addLightDataSpotAngles = function addLightDataSpotAngles(data8, index, light) {
			FloatPacking.float2Bytes(light._innerConeAngleCos * (0.5 - epsilon$1) + 0.5, data8, index + 0, 2);
			FloatPacking.float2Bytes(light._outerConeAngleCos * (0.5 - epsilon$1) + 0.5, data8, index + 2, 2);
		};
		_proto.addLightDataShadowBias = function addLightDataShadowBias(data8, index, light) {
			var lightRenderData = light.getRenderData(null, 0);
			var biases = light._getUniformBiasValues(lightRenderData);
			FloatPacking.float2BytesRange(biases.bias, data8, index, -1, 20, 2);
			FloatPacking.float2Bytes(biases.normalBias, data8, index + 2, 2);
		};
		_proto.addLightDataPositionRange = function addLightDataPositionRange(data8, index, light, pos) {
			var normPos = tempVec3$1.sub2(pos, this.boundsMin).div(this.boundsDelta);
			FloatPacking.float2Bytes(normPos.x, data8, index + 0, 4);
			FloatPacking.float2Bytes(normPos.y, data8, index + 4, 4);
			FloatPacking.float2Bytes(normPos.z, data8, index + 8, 4);
			FloatPacking.float2Bytes(light.attenuationEnd * this.invMaxAttenuation, data8, index + 12, 4);
		};
		_proto.addLightDataSpotDirection = function addLightDataSpotDirection(data8, index, light) {
			this.getSpotDirection(tempVec3$1, light);
			FloatPacking.float2Bytes(tempVec3$1.x * (0.5 - epsilon$1) + 0.5, data8, index + 0, 4);
			FloatPacking.float2Bytes(tempVec3$1.y * (0.5 - epsilon$1) + 0.5, data8, index + 4, 4);
			FloatPacking.float2Bytes(tempVec3$1.z * (0.5 - epsilon$1) + 0.5, data8, index + 8, 4);
		};
		_proto.addLightDataLightProjMatrix = function addLightDataLightProjMatrix(data8, index, lightProjectionMatrix) {
			var matData = lightProjectionMatrix.data;
			for (var m = 0; m < 12; m++) FloatPacking.float2BytesRange(matData[m], data8, index + 4 * m, -2, 2, 4);
			for (var _m = 12; _m < 16; _m++) {
				FloatPacking.float2MantissaExponent(matData[_m], data8, index + 4 * _m, 4);
			}
		};
		_proto.addLightDataCookies = function addLightDataCookies(data8, index, light) {
			var isRgb = light._cookieChannel === 'rgb';
			data8[index + 0] = Math.floor(light.cookieIntensity * 255);
			data8[index + 1] = isRgb ? 255 : 0;
			if (!isRgb) {
				var channel = light._cookieChannel;
				data8[index + 4] = channel === 'rrr' ? 255 : 0;
				data8[index + 5] = channel === 'ggg' ? 255 : 0;
				data8[index + 6] = channel === 'bbb' ? 255 : 0;
				data8[index + 7] = channel === 'aaa' ? 255 : 0;
			}
		};
		_proto.addLightAtlasViewport = function addLightAtlasViewport(data8, index, atlasViewport) {
			FloatPacking.float2Bytes(atlasViewport.x, data8, index + 0, 2);
			FloatPacking.float2Bytes(atlasViewport.y, data8, index + 2, 2);
			FloatPacking.float2Bytes(atlasViewport.z / 3, data8, index + 4, 2);
		};
		_proto.addLightAreaSizes = function addLightAreaSizes(data8, index, light) {
			var areaSizes = this.getLightAreaSizes(light);
			for (var i = 0; i < 6; i++) {
				FloatPacking.float2MantissaExponent(areaSizes[i], data8, index + 4 * i, 4);
			}
		};
		_proto.addLightData = function addLightData(light, lightIndex, gammaCorrection) {
			var isSpot = light._type === LIGHTTYPE_SPOT;
			var hasAtlasViewport = light.atlasViewportAllocated;
			var isCookie = this.cookiesEnabled && !!light._cookie && hasAtlasViewport;
			var isArea = this.areaLightsEnabled && light.shape !== LIGHTSHAPE_PUNCTUAL;
			var castShadows = this.shadowsEnabled && light.castShadows && hasAtlasViewport;
			var pos = light._node.getPosition();
			var lightProjectionMatrix = null;
			var atlasViewport = null;
			if (isSpot) {
				if (castShadows) {
					var lightRenderData = light.getRenderData(null, 0);
					lightProjectionMatrix = lightRenderData.shadowMatrix;
				} else if (isCookie) {
					lightProjectionMatrix = LightCamera.evalSpotCookieMatrix(light);
				}
			} else {
				if (castShadows || isCookie) {
					atlasViewport = light.atlasViewport;
				}
			}
			var data8 = this.lights8;
			var data8Start = lightIndex * this.lightsTexture8.width * 4;
			this.addLightDataFlags(data8, data8Start + 4 * TextureIndex8.FLAGS, light, isSpot, castShadows, light.shadowIntensity);
			this.addLightDataColor(data8, data8Start + 4 * TextureIndex8.COLOR_A, light, gammaCorrection, isCookie);
			if (isSpot) {
				this.addLightDataSpotAngles(data8, data8Start + 4 * TextureIndex8.SPOT_ANGLES, light);
			}
			if (light.castShadows) {
				this.addLightDataShadowBias(data8, data8Start + 4 * TextureIndex8.SHADOW_BIAS, light);
			}
			if (isCookie) {
				this.addLightDataCookies(data8, data8Start + 4 * TextureIndex8.COOKIE_A, light);
			}
			if (LightsBuffer.lightTextureFormat === LightsBuffer.FORMAT_FLOAT) {
				var dataFloat = this.lightsFloat;
				var dataFloatStart = lightIndex * this.lightsTextureFloat.width * 4;
				dataFloat[dataFloatStart + 4 * TextureIndexFloat.POSITION_RANGE + 0] = pos.x;
				dataFloat[dataFloatStart + 4 * TextureIndexFloat.POSITION_RANGE + 1] = pos.y;
				dataFloat[dataFloatStart + 4 * TextureIndexFloat.POSITION_RANGE + 2] = pos.z;
				dataFloat[dataFloatStart + 4 * TextureIndexFloat.POSITION_RANGE + 3] = light.attenuationEnd;
				if (isSpot) {
					this.getSpotDirection(tempVec3$1, light);
					dataFloat[dataFloatStart + 4 * TextureIndexFloat.SPOT_DIRECTION + 0] = tempVec3$1.x;
					dataFloat[dataFloatStart + 4 * TextureIndexFloat.SPOT_DIRECTION + 1] = tempVec3$1.y;
					dataFloat[dataFloatStart + 4 * TextureIndexFloat.SPOT_DIRECTION + 2] = tempVec3$1.z;
				}
				if (lightProjectionMatrix) {
					var matData = lightProjectionMatrix.data;
					for (var m = 0; m < 16; m++) dataFloat[dataFloatStart + 4 * TextureIndexFloat.PROJ_MAT_0 + m] = matData[m];
				}
				if (atlasViewport) {
					dataFloat[dataFloatStart + 4 * TextureIndexFloat.ATLAS_VIEWPORT + 0] = atlasViewport.x;
					dataFloat[dataFloatStart + 4 * TextureIndexFloat.ATLAS_VIEWPORT + 1] = atlasViewport.y;
					dataFloat[dataFloatStart + 4 * TextureIndexFloat.ATLAS_VIEWPORT + 2] = atlasViewport.z / 3;
				}
				if (isArea) {
					var areaSizes = this.getLightAreaSizes(light);
					dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_WIDTH + 0] = areaSizes[0];
					dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_WIDTH + 1] = areaSizes[1];
					dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_WIDTH + 2] = areaSizes[2];
					dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_HEIGHT + 0] = areaSizes[3];
					dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_HEIGHT + 1] = areaSizes[4];
					dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_HEIGHT + 2] = areaSizes[5];
				}
			} else {
				this.addLightDataPositionRange(data8, data8Start + 4 * TextureIndex8.POSITION_X, light, pos);
				if (isSpot) {
					this.addLightDataSpotDirection(data8, data8Start + 4 * TextureIndex8.SPOT_DIRECTION_X, light);
				}
				if (lightProjectionMatrix) {
					this.addLightDataLightProjMatrix(data8, data8Start + 4 * TextureIndex8.PROJ_MAT_00, lightProjectionMatrix);
				}
				if (atlasViewport) {
					this.addLightAtlasViewport(data8, data8Start + 4 * TextureIndex8.ATLAS_VIEWPORT_A, atlasViewport);
				}
				if (isArea) {
					this.addLightAreaSizes(data8, data8Start + 4 * TextureIndex8.AREA_DATA_WIDTH_X, light);
				}
			}
		};
		return LightsBuffer;
	}();
	_class$1 = LightsBuffer;
	LightsBuffer.FORMAT_FLOAT = 0;
	LightsBuffer.FORMAT_8BIT = 1;
	LightsBuffer.lightTextureFormat = _class$1.FORMAT_8BIT;
	LightsBuffer.useTexelFetch = false;
	LightsBuffer.shaderDefines = '';

	var builtinAttributes = {
		vertex_normal: SEMANTIC_NORMAL,
		vertex_tangent: SEMANTIC_TANGENT,
		vertex_texCoord0: SEMANTIC_TEXCOORD0,
		vertex_texCoord1: SEMANTIC_TEXCOORD1,
		vertex_color: SEMANTIC_COLOR,
		vertex_boneWeights: SEMANTIC_BLENDWEIGHT,
		vertex_boneIndices: SEMANTIC_BLENDINDICES
	};
	var builtinVaryings = {
		vVertexColor: "vec4",
		vPositionW: "vec3",
		vNormalV: "vec3",
		vNormalW: "vec3",
		vTangentW: "vec3",
		vBinormalW: "vec3",
		vObjectSpaceUpW: "vec3",
		vUv0: "vec2",
		vUv1: "vec2"
	};
	var LitShader = function () {
		function LitShader(device, options) {
			this.device = device;
			this.options = options;
			this.attributes = {
				vertex_position: SEMANTIC_POSITION
			};
			if (options.userAttributes) {
				for (var _i = 0, _Object$entries = Object.entries(options.userAttributes); _i < _Object$entries.length; _i++) {
					var _Object$entries$_i = _Object$entries[_i],
						semantic = _Object$entries$_i[0],
						name = _Object$entries$_i[1];
					this.attributes[name] = semantic;
				}
			}
			if (options.chunks) {
				var userChunks = options.chunks;
				this.chunks = Object.create(shaderChunks);
				for (var chunkName in shaderChunks) {
					if (userChunks.hasOwnProperty(chunkName)) {
						var chunk = userChunks[chunkName];
						for (var a in builtinAttributes) {
							if (builtinAttributes.hasOwnProperty(a) && chunk.indexOf(a) >= 0) {
								this.attributes[a] = builtinAttributes[a];
							}
						}
						this.chunks[chunkName] = chunk;
					}
				}
			} else {
				this.chunks = shaderChunks;
			}
			this.shaderPassInfo = ShaderPass.get(this.device).getByIndex(options.pass);
			this.shadowPass = this.shaderPassInfo.isShadow;
			this.lighting = options.lights.length > 0 || options.dirLightMapEnabled || options.clusteredLightingEnabled;
			this.reflections = !!options.reflectionSource;
			this.needsNormal = this.lighting || this.reflections || options.useSpecular || options.ambientSH || options.useHeights || options.enableGGXSpecular || options.clusteredLightingEnabled && !this.shadowPass || options.useClearCoatNormals;
			this.needsNormal = this.needsNormal && !this.shadowPass;
			this.needsSceneColor = options.useDynamicRefraction;
			this.needsScreenSize = options.useDynamicRefraction;
			this.needsTransforms = options.useDynamicRefraction;
			this.varyings = "";
			this.varyingDefines = "";
			this.vshader = null;
			this.frontendDecl = null;
			this.frontendCode = null;
			this.frontendFunc = null;
			this.lightingUv = null;
			this.defines = [];
			this.fshader = null;
		}
		var _proto = LitShader.prototype;
		_proto._vsAddBaseCode = function _vsAddBaseCode(code, chunks, options) {
			code += chunks.baseVS;
			if (options.nineSlicedMode === SPRITE_RENDERMODE_SLICED || options.nineSlicedMode === SPRITE_RENDERMODE_TILED) {
				code += chunks.baseNineSlicedVS;
			}
			return code;
		};
		_proto._vsAddTransformCode = function _vsAddTransformCode(code, device, chunks, options) {
			code += this.chunks.transformVS;
			return code;
		};
		_proto._setMapTransform = function _setMapTransform(codes, name, id, uv) {
			var checkId = id + uv * 100;
			if (!codes[3][checkId]) {
				var varName = "texture_" + name + "MapTransform";
				codes[0] += "uniform vec3 " + varName + "0;\n";
				codes[0] += "uniform vec3 " + varName + "1;\n";
				codes[1] += "varying vec2 vUV" + uv + "_" + id + ";\n";
				codes[2] += "   vUV" + uv + "_" + id + " = vec2(dot(vec3(uv" + uv + ", 1), " + varName + "0), dot(vec3(uv" + uv + ", 1), " + varName + "1));\n";
				codes[3][checkId] = true;
			}
			return codes;
		};
		_proto._fsGetBaseCode = function _fsGetBaseCode() {
			var options = this.options;
			var chunks = this.chunks;
			var result = this.chunks.basePS;
			if (options.nineSlicedMode === SPRITE_RENDERMODE_SLICED) {
				result += chunks.baseNineSlicedPS;
			} else if (options.nineSlicedMode === SPRITE_RENDERMODE_TILED) {
				result += chunks.baseNineSlicedTiledPS;
			}
			return result;
		};
		_proto._fsGetStartCode = function _fsGetStartCode(code, device, chunks, options) {
			var result = chunks.startPS;
			if (options.nineSlicedMode === SPRITE_RENDERMODE_SLICED) {
				result += chunks.startNineSlicedPS;
			} else if (options.nineSlicedMode === SPRITE_RENDERMODE_TILED) {
				result += chunks.startNineSlicedTiledPS;
			}
			return result;
		};
		_proto._getLightSourceShapeString = function _getLightSourceShapeString(shape) {
			switch (shape) {
				case LIGHTSHAPE_RECT:
					return 'Rect';
				case LIGHTSHAPE_DISK:
					return 'Disk';
				case LIGHTSHAPE_SPHERE:
					return 'Sphere';
				default:
					return '';
			}
		};
		_proto.generateVertexShader = function generateVertexShader(useUv, useUnmodifiedUv, mapTransforms) {
			var _this = this;
			var device = this.device;
			var options = this.options;
			var chunks = this.chunks;
			var code = '';
			var codeBody = '';
			code = this._vsAddBaseCode(code, chunks, options);
			codeBody += "   vPositionW    = getWorldPosition();\n";
			if (this.options.pass === SHADER_DEPTH) {
				code += 'varying float vDepth;\n';
				code += '#ifndef VIEWMATRIX\n';
				code += '#define VIEWMATRIX\n';
				code += 'uniform mat4 matrix_view;\n';
				code += '#endif\n';
				code += '#ifndef CAMERAPLANES\n';
				code += '#define CAMERAPLANES\n';
				code += 'uniform vec4 camera_params;\n\n';
				code += '#endif\n';
				codeBody += "    vDepth = -(matrix_view * vec4(vPositionW,1.0)).z * camera_params.x;\n";
			}
			if (this.options.useInstancing) {
				this.attributes.instance_line1 = SEMANTIC_ATTR12;
				this.attributes.instance_line2 = SEMANTIC_ATTR13;
				this.attributes.instance_line3 = SEMANTIC_ATTR14;
				this.attributes.instance_line4 = SEMANTIC_ATTR15;
				code += chunks.instancingVS;
			}
			if (this.needsNormal) {
				this.attributes.vertex_normal = SEMANTIC_NORMAL;
				codeBody += "   vNormalW = getNormal();\n";
				if (options.reflectionSource === 'sphereMap' && device.fragmentUniformsCount <= 16) {
					code += chunks.viewNormalVS;
					codeBody += "   vNormalV    = getViewNormal();\n";
				}
				if (options.hasTangents && (options.useHeights || options.useNormals || options.enableGGXSpecular)) {
					this.attributes.vertex_tangent = SEMANTIC_TANGENT;
					code += chunks.tangentBinormalVS;
					codeBody += "   vTangentW   = getTangent();\n";
					codeBody += "   vBinormalW  = getBinormal();\n";
				} else if (options.enableGGXSpecular || !device.extStandardDerivatives) {
					codeBody += "   vObjectSpaceUpW = normalize(dNormalMatrix * vec3(0, 1, 0));\n";
				}
			}
			var maxUvSets = 2;
			for (var i = 0; i < maxUvSets; i++) {
				if (useUv[i]) {
					this.attributes["vertex_texCoord" + i] = "TEXCOORD" + i;
					code += chunks["uv" + i + "VS"];
					codeBody += "   vec2 uv" + i + " = getUv" + i + "();\n";
				}
				if (useUnmodifiedUv[i]) {
					codeBody += "   vUv" + i + " = uv" + i + ";\n";
				}
			}
			var codes = [code, this.varyings, codeBody, []];
			mapTransforms.forEach(function (mapTransform) {
				_this._setMapTransform(codes, mapTransform.name, mapTransform.id, mapTransform.uv);
			});
			code = codes[0];
			this.varyings = codes[1];
			codeBody = codes[2];
			if (options.vertexColors) {
				this.attributes.vertex_color = SEMANTIC_COLOR;
				codeBody += "   vVertexColor = vertex_color;\n";
			}
			if (options.useMsdf && options.msdfTextAttribute) {
				this.attributes.vertex_outlineParameters = SEMANTIC_ATTR8;
				this.attributes.vertex_shadowParameters = SEMANTIC_ATTR9;
				codeBody += "    unpackMsdfParams();\n";
				code += chunks.msdfVS;
			}
			if (options.useMorphPosition || options.useMorphNormal) {
				if (options.useMorphTextureBased) {
					code += "#define MORPHING_TEXTURE_BASED\n";
					if (options.useMorphPosition) {
						code += "#define MORPHING_TEXTURE_BASED_POSITION\n";
					}
					if (options.useMorphNormal) {
						code += "#define MORPHING_TEXTURE_BASED_NORMAL\n";
					}
					this.attributes.morph_vertex_id = SEMANTIC_ATTR15;
					var morphIdType = device.isWebGPU ? 'uint' : 'float';
					code += "attribute " + morphIdType + " morph_vertex_id;\n";
				} else {
					code += "#define MORPHING\n";
					if (options.useMorphPosition) {
						this.attributes.morph_pos0 = SEMANTIC_ATTR8;
						this.attributes.morph_pos1 = SEMANTIC_ATTR9;
						this.attributes.morph_pos2 = SEMANTIC_ATTR10;
						this.attributes.morph_pos3 = SEMANTIC_ATTR11;
						code += "#define MORPHING_POS03\n";
						code += "attribute vec3 morph_pos0;\n";
						code += "attribute vec3 morph_pos1;\n";
						code += "attribute vec3 morph_pos2;\n";
						code += "attribute vec3 morph_pos3;\n";
					} else if (options.useMorphNormal) {
						this.attributes.morph_nrm0 = SEMANTIC_ATTR8;
						this.attributes.morph_nrm1 = SEMANTIC_ATTR9;
						this.attributes.morph_nrm2 = SEMANTIC_ATTR10;
						this.attributes.morph_nrm3 = SEMANTIC_ATTR11;
						code += "#define MORPHING_NRM03\n";
						code += "attribute vec3 morph_nrm0;\n";
						code += "attribute vec3 morph_nrm1;\n";
						code += "attribute vec3 morph_nrm2;\n";
						code += "attribute vec3 morph_nrm3;\n";
					}
					if (!options.useMorphNormal) {
						this.attributes.morph_pos4 = SEMANTIC_ATTR12;
						this.attributes.morph_pos5 = SEMANTIC_ATTR13;
						this.attributes.morph_pos6 = SEMANTIC_ATTR14;
						this.attributes.morph_pos7 = SEMANTIC_ATTR15;
						code += "#define MORPHING_POS47\n";
						code += "attribute vec3 morph_pos4;\n";
						code += "attribute vec3 morph_pos5;\n";
						code += "attribute vec3 morph_pos6;\n";
						code += "attribute vec3 morph_pos7;\n";
					} else {
						this.attributes.morph_nrm4 = SEMANTIC_ATTR12;
						this.attributes.morph_nrm5 = SEMANTIC_ATTR13;
						this.attributes.morph_nrm6 = SEMANTIC_ATTR14;
						this.attributes.morph_nrm7 = SEMANTIC_ATTR15;
						code += "#define MORPHING_NRM47\n";
						code += "attribute vec3 morph_nrm4;\n";
						code += "attribute vec3 morph_nrm5;\n";
						code += "attribute vec3 morph_nrm6;\n";
						code += "attribute vec3 morph_nrm7;\n";
					}
				}
			}
			if (options.skin) {
				this.attributes.vertex_boneWeights = SEMANTIC_BLENDWEIGHT;
				this.attributes.vertex_boneIndices = SEMANTIC_BLENDINDICES;
				code += ShaderGenerator.skinCode(device, chunks);
				code += "#define SKIN\n";
			} else if (options.useInstancing) {
				code += "#define INSTANCING\n";
			}
			if (options.screenSpace) {
				code += "#define SCREENSPACE\n";
			}
			if (options.pixelSnap) {
				code += "#define PIXELSNAP\n";
			}
			code = this._vsAddTransformCode(code, device, chunks, options);
			if (this.needsNormal) {
				code += chunks.normalVS;
			}
			code += "\n";
			code += chunks.startVS;
			code += codeBody;
			code += chunks.endVS;
			code += "}";
			Object.keys(builtinVaryings).forEach(function (v) {
				if (code.indexOf(v) >= 0) {
					_this.varyings += "varying " + builtinVaryings[v] + " " + v + ";\n";
					_this.varyingDefines += "#define VARYING_" + v.toUpperCase() + "\n";
				}
			});
			var shaderPassDefines = this.shaderPassInfo.shaderDefines;
			this.vshader = shaderPassDefines + this.varyings + code;
		};
		_proto._fsGetBeginCode = function _fsGetBeginCode() {
			var code = this.shaderPassInfo.shaderDefines;
			for (var i = 0; i < this.defines.length; i++) {
				code += "#define " + this.defines[i] + "\n";
			}
			return code;
		};
		_proto._fsGetPickPassCode = function _fsGetPickPassCode() {
			var code = this._fsGetBeginCode();
			code += "uniform vec4 uColor;\n";
			code += this.varyings;
			code += this.varyingDefines;
			code += this.frontendDecl;
			code += this.frontendCode;
			code += ShaderGenerator.begin();
			code += this.frontendFunc;
			code += "    gl_FragColor = uColor;\n";
			code += ShaderGenerator.end();
			return code;
		};
		_proto._fsGetDepthPassCode = function _fsGetDepthPassCode() {
			var chunks = this.chunks;
			var code = this._fsGetBeginCode();
			code += 'varying float vDepth;\n';
			code += this.varyings;
			code += this.varyingDefines;
			code += chunks.packDepthPS;
			code += this.frontendDecl;
			code += this.frontendCode;
			code += ShaderGenerator.begin();
			code += this.frontendFunc;
			code += "    gl_FragColor = packFloat(vDepth);\n";
			code += ShaderGenerator.end();
			return code;
		};
		_proto._fsGetShadowPassCode = function _fsGetShadowPassCode() {
			var device = this.device;
			var options = this.options;
			var chunks = this.chunks;
			var varyings = this.varyings;
			var lightType = this.shaderPassInfo.lightType;
			var shadowType = this.shaderPassInfo.shadowType;
			if (lightType !== LIGHTTYPE_DIRECTIONAL && options.clusteredLightingEnabled) {
				if (shadowType === SHADOW_VSM8 || shadowType === SHADOW_VSM16 || shadowType === SHADOW_VSM32 || shadowType === SHADOW_PCSS) {
					shadowType = SHADOW_PCF3;
				}
			}
			var code = this._fsGetBeginCode();
			if (device.extStandardDerivatives && device.isWebGL1) {
				code += 'uniform vec2 polygonOffset;\n';
			}
			if (shadowType === SHADOW_VSM32) {
				if (device.textureFloatHighPrecision) {
					code += '#define VSM_EXPONENT 15.0\n\n';
				} else {
					code += '#define VSM_EXPONENT 5.54\n\n';
				}
			} else if (shadowType === SHADOW_VSM16) {
				code += '#define VSM_EXPONENT 5.54\n\n';
			}
			if (lightType !== LIGHTTYPE_DIRECTIONAL) {
				code += 'uniform vec3 view_position;\n';
				code += 'uniform float light_radius;\n';
			}
			code += varyings;
			code += this.varyingDefines;
			code += this.frontendDecl;
			code += this.frontendCode;
			var mayPackDepth = shadowType === SHADOW_PCF1 || shadowType === SHADOW_PCF3 || shadowType === SHADOW_PCF5 || shadowType === SHADOW_PCSS;
			var mustPackDepth = lightType === LIGHTTYPE_OMNI && shadowType !== SHADOW_PCSS && !options.clusteredLightingEnabled;
			var usePackedDepth = mayPackDepth && !device.supportsDepthShadow || mustPackDepth;
			if (usePackedDepth) {
				code += chunks.packDepthPS;
			} else if (shadowType === SHADOW_VSM8) {
				code += "vec2 encodeFloatRG( float v ) {\n";
				code += "    vec2 enc = vec2(1.0, 255.0) * v;\n";
				code += "    enc = fract(enc);\n";
				code += "    enc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\n";
				code += "    return enc;\n";
				code += "}\n\n";
			}
			if (shadowType === SHADOW_PCSS) {
				code += shaderChunks.linearizeDepthPS;
			}
			code += ShaderGenerator.begin();
			code += this.frontendFunc;
			var isVsm = shadowType === SHADOW_VSM8 || shadowType === SHADOW_VSM16 || shadowType === SHADOW_VSM32;
			var applySlopeScaleBias = device.isWebGL1 && device.extStandardDerivatives;
			var usePerspectiveDepth = lightType === LIGHTTYPE_DIRECTIONAL || !isVsm && lightType === LIGHTTYPE_SPOT;
			var hasModifiedDepth = false;
			if (usePerspectiveDepth) {
				code += "    float depth = gl_FragCoord.z;\n";
			} else {
				code += "    float depth = min(distance(view_position, vPositionW) / light_radius, 0.99999);\n";
				hasModifiedDepth = true;
			}
			if (applySlopeScaleBias) {
				code += "    float minValue = 2.3374370500153186e-10; //(1.0 / 255.0) / (256.0 * 256.0 * 256.0);\n";
				code += "    depth += polygonOffset.x * max(abs(dFdx(depth)), abs(dFdy(depth))) + minValue * polygonOffset.y;\n";
				hasModifiedDepth = true;
			}
			if (usePackedDepth) {
				code += "    gl_FragColor = packFloat(depth);\n";
			} else if (!isVsm) {
				var exportR32 = shadowType === SHADOW_PCSS;
				if (exportR32) {
					code += "    gl_FragColor.r = depth;\n";
				} else {
					if (hasModifiedDepth) {
						code += "    gl_FragDepth = depth;\n";
					}
					code += "    gl_FragColor = vec4(1.0);\n";
				}
			} else if (shadowType === SHADOW_VSM8) {
				code += "    gl_FragColor = vec4(encodeFloatRG(depth), encodeFloatRG(depth*depth));\n";
			} else {
				code += chunks.storeEVSMPS;
			}
			code += ShaderGenerator.end();
			return code;
		};
		_proto._fsGetLitPassCode = function _fsGetLitPassCode() {
			var device = this.device;
			var options = this.options;
			var chunks = this.chunks;
			var decl = new ChunkBuilder();
			var func = new ChunkBuilder();
			var backend = new ChunkBuilder();
			var code = new ChunkBuilder();
			if (options.opacityFadesSpecular === false) {
				decl.append('uniform float material_alphaFade;');
			}
			if (options.useSpecular) {
				this.defines.push("LIT_SPECULAR");
				if (this.reflections) {
					this.defines.push("LIT_REFLECTIONS");
				}
				if (options.useClearCoat) {
					this.defines.push("LIT_CLEARCOAT");
				}
				if (options.fresnelModel > 0) {
					this.defines.push("LIT_SPECULAR_FRESNEL");
				}
				if (options.conserveEnergy) {
					this.defines.push("LIT_CONSERVE_ENERGY");
				}
				if (options.useSheen) {
					this.defines.push("LIT_SHEEN");
				}
				if (options.useIridescence) {
					this.defines.push("LIT_IRIDESCENCE");
				}
			}
			var shadowTypeUsed = [];
			var numShadowLights = 0;
			var shadowedDirectionalLightUsed = false;
			var useVsm = false;
			var usePcss = false;
			var hasAreaLights = options.lights.some(function (light) {
				return light._shape && light._shape !== LIGHTSHAPE_PUNCTUAL;
			});
			if (options.clusteredLightingEnabled && options.clusteredLightingAreaLightsEnabled) {
				hasAreaLights = true;
			}
			var areaLutsPrecision = 'highp';
			if (device.areaLightLutFormat === PIXELFORMAT_RGBA8) {
				decl.append("#define AREA_R8_G8_B8_A8_LUTS");
				areaLutsPrecision = 'lowp';
			}
			if (hasAreaLights || options.clusteredLightingEnabled) {
				decl.append("#define AREA_LIGHTS");
				decl.append("uniform " + areaLutsPrecision + " sampler2D areaLightsLutTex1;");
				decl.append("uniform " + areaLutsPrecision + " sampler2D areaLightsLutTex2;");
			}
			for (var i = 0; i < options.lights.length; i++) {
				var light = options.lights[i];
				var lightType = light._type;
				if (options.clusteredLightingEnabled && lightType !== LIGHTTYPE_DIRECTIONAL) continue;
				var lightShape = hasAreaLights && light._shape ? light._shape : LIGHTSHAPE_PUNCTUAL;
				decl.append("uniform vec3 light" + i + "_color;");
				if (light._shadowType === SHADOW_PCSS && light.castShadows && !options.noShadow) {
					decl.append("uniform float light" + i + "_shadowSearchArea;");
					decl.append("uniform vec4 light" + i + "_cameraParams;");
				}
				if (lightType === LIGHTTYPE_DIRECTIONAL) {
					decl.append("uniform vec3 light" + i + "_direction;");
				} else {
					decl.append("uniform vec3 light" + i + "_position;");
					decl.append("uniform float light" + i + "_radius;");
					if (lightType === LIGHTTYPE_SPOT) {
						decl.append("uniform vec3 light" + i + "_direction;");
						decl.append("uniform float light" + i + "_innerConeAngle;");
						decl.append("uniform float light" + i + "_outerConeAngle;");
					}
				}
				if (lightShape !== LIGHTSHAPE_PUNCTUAL) {
					if (lightType === LIGHTTYPE_DIRECTIONAL) {
						decl.append("uniform vec3 light" + i + "_position;");
					}
					decl.append("uniform vec3 light" + i + "_halfWidth;");
					decl.append("uniform vec3 light" + i + "_halfHeight;");
				}
				if (light.castShadows && !options.noShadow) {
					decl.append("uniform mat4 light" + i + "_shadowMatrix;");
					decl.append("uniform float light" + i + "_shadowIntensity;");
					if (lightType === LIGHTTYPE_DIRECTIONAL) {
						decl.append("uniform mat4 light" + i + "_shadowMatrixPalette[4];");
						decl.append("uniform float light" + i + "_shadowCascadeDistances[4];");
						decl.append("uniform float light" + i + "_shadowCascadeCount;");
					}
					decl.append("uniform vec4 light" + i + "_shadowParams;");
					if (lightType === LIGHTTYPE_DIRECTIONAL) {
						shadowedDirectionalLightUsed = true;
					}
					if (lightType === LIGHTTYPE_OMNI) {
						decl.append("uniform samplerCube light" + i + "_shadowMap;");
					} else {
						if (light._isPcf && device.supportsDepthShadow) {
							decl.append("uniform sampler2DShadow light" + i + "_shadowMap;");
						} else {
							decl.append("uniform sampler2D light" + i + "_shadowMap;");
						}
					}
					numShadowLights++;
					shadowTypeUsed[light._shadowType] = true;
					if (light._isVsm) useVsm = true;
					if (light._shadowType === SHADOW_PCSS) usePcss = true;
				}
				if (light._cookie) {
					if (light._cookie._cubemap) {
						if (lightType === LIGHTTYPE_OMNI) {
							decl.append("uniform samplerCube light" + i + "_cookie;");
							decl.append("uniform float light" + i + "_cookieIntensity;");
							if (!light.castShadows || options.noShadow) {
								decl.append("uniform mat4 light" + i + "_shadowMatrix;");
							}
						}
					} else {
						if (lightType === LIGHTTYPE_SPOT) {
							decl.append("uniform sampler2D light" + i + "_cookie;");
							decl.append("uniform float light" + i + "_cookieIntensity;");
							if (!light.castShadows || options.noShadow) {
								decl.append("uniform mat4 light" + i + "_shadowMatrix;");
							}
							if (light._cookieTransform) {
								decl.append("uniform vec4 light" + i + "_cookieMatrix;");
								decl.append("uniform vec2 light" + i + "_cookieOffset;");
							}
						}
					}
				}
			}
			var hasTBN = this.needsNormal && (options.useNormals || options.useClearCoatNormals || options.enableGGXSpecular && !options.useHeights);
			if (hasTBN) {
				if (options.hasTangents) {
					func.append(options.fastTbn ? chunks.TBNfastPS : chunks.TBNPS);
				} else {
					if (device.extStandardDerivatives && (options.useNormals || options.useClearCoatNormals)) {
						func.append(chunks.TBNderivativePS.replace(/\$UV/g, this.lightingUv));
					} else {
						func.append(chunks.TBNObjectSpacePS);
					}
				}
			}
			func.append(chunks.sphericalPS);
			func.append(chunks.decodePS);
			func.append(ShaderGenerator.gammaCode(options.gamma, chunks));
			func.append(ShaderGenerator.tonemapCode(options.toneMap, chunks));
			func.append(ShaderGenerator.fogCode(options.fog, chunks));
			func.append(this.frontendCode);
			if (options.useCubeMapRotation) {
				decl.append("#define CUBEMAP_ROTATION");
			}
			if (this.needsNormal) {
				func.append(chunks.cubeMapRotatePS);
				func.append(options.cubeMapProjection > 0 ? chunks.cubeMapProjectBoxPS : chunks.cubeMapProjectNonePS);
				func.append(options.skyboxIntensity ? chunks.envMultiplyPS : chunks.envConstPS);
			}
			if (this.lighting && options.useSpecular || this.reflections) {
				if (options.useMetalness) {
					func.append(chunks.metalnessModulatePS);
				}
				if (options.fresnelModel === FRESNEL_SCHLICK) {
					func.append(chunks.fresnelSchlickPS);
				}
				if (options.useIridescence) {
					func.append(chunks.iridescenceDiffractionPS);
				}
			}
			if (options.useAo) {
				func.append(chunks.aoDiffuseOccPS);
				switch (options.occludeSpecular) {
					case SPECOCC_AO:
						func.append(options.occludeSpecularFloat ? chunks.aoSpecOccSimplePS : chunks.aoSpecOccConstSimplePS);
						break;
					case SPECOCC_GLOSSDEPENDENT:
						func.append(options.occludeSpecularFloat ? chunks.aoSpecOccPS : chunks.aoSpecOccConstPS);
						break;
				}
			}
			if (options.reflectionSource === 'envAtlasHQ') {
				func.append(options.fixSeams ? chunks.fixCubemapSeamsStretchPS : chunks.fixCubemapSeamsNonePS);
				func.append(chunks.envAtlasPS);
				func.append(chunks.reflectionEnvHQPS.replace(/\$DECODE_CUBEMAP/g, ChunkUtils.decodeFunc(options.reflectionCubemapEncoding)).replace(/\$DECODE/g, ChunkUtils.decodeFunc(options.reflectionEncoding)));
			} else if (options.reflectionSource === 'envAtlas') {
				func.append(chunks.envAtlasPS);
				func.append(chunks.reflectionEnvPS.replace(/\$DECODE/g, ChunkUtils.decodeFunc(options.reflectionEncoding)));
			} else if (options.reflectionSource === 'cubeMap') {
				func.append(options.fixSeams ? chunks.fixCubemapSeamsStretchPS : chunks.fixCubemapSeamsNonePS);
				func.append(chunks.reflectionCubePS.replace(/\$DECODE/g, ChunkUtils.decodeFunc(options.reflectionEncoding)));
			} else if (options.reflectionSource === 'sphereMap') {
				var scode = device.fragmentUniformsCount > 16 ? chunks.reflectionSpherePS : chunks.reflectionSphereLowPS;
				func.append(scode.replace(/\$DECODE/g, ChunkUtils.decodeFunc(options.reflectionEncoding)));
			}
			if (this.reflections) {
				if (options.useClearCoat) {
					func.append(chunks.reflectionCCPS);
				}
				if (options.useSheen) {
					func.append(chunks.reflectionSheenPS);
				}
			}
			if (options.useRefraction) {
				if (options.useDynamicRefraction) {
					func.append(chunks.refractionDynamicPS);
				} else if (this.reflections) {
					func.append(chunks.refractionCubePS);
				}
			}
			if (options.useSheen) {
				func.append(chunks.lightSheenPS);
			}
			if (options.clusteredLightingEnabled) {
				func.append(chunks.clusteredLightUtilsPS);
				if (options.clusteredLightingCookiesEnabled) func.append(chunks.clusteredLightCookiesPS);
				if (options.clusteredLightingShadowsEnabled && !options.noShadow) {
					shadowTypeUsed[SHADOW_PCF3] = true;
					shadowTypeUsed[SHADOW_PCF5] = true;
					shadowTypeUsed[SHADOW_PCSS] = true;
				}
			}
			if (numShadowLights > 0 || options.clusteredLightingEnabled) {
				if (shadowedDirectionalLightUsed) {
					func.append(chunks.shadowCascadesPS);
				}
				if (shadowTypeUsed[SHADOW_PCF1] || shadowTypeUsed[SHADOW_PCF3]) {
					func.append(chunks.shadowStandardPS);
				}
				if (shadowTypeUsed[SHADOW_PCF5] && !device.isWebGL1) {
					func.append(chunks.shadowStandardGL2PS);
				}
				if (useVsm) {
					func.append(chunks.shadowVSM_commonPS);
					if (shadowTypeUsed[SHADOW_VSM8]) {
						func.append(chunks.shadowVSM8PS);
					}
					if (shadowTypeUsed[SHADOW_VSM16]) {
						func.append(device.extTextureHalfFloatLinear ? chunks.shadowEVSMPS.replace(/\$/g, "16") : chunks.shadowEVSMnPS.replace(/\$/g, "16"));
					}
					if (shadowTypeUsed[SHADOW_VSM32]) {
						func.append(device.extTextureFloatLinear ? chunks.shadowEVSMPS.replace(/\$/g, "32") : chunks.shadowEVSMnPS.replace(/\$/g, "32"));
					}
				}
				if (usePcss) {
					func.append(chunks.linearizeDepthPS);
					func.append(chunks.shadowPCSSPS);
				}
				if (!(device.isWebGL2 || device.isWebGPU || device.extStandardDerivatives)) {
					func.append(chunks.biasConstPS);
				}
			}
			if (options.enableGGXSpecular) func.append("uniform float material_anisotropy;");
			if (this.lighting) {
				func.append(chunks.lightDiffuseLambertPS);
				if (hasAreaLights || options.clusteredLightingAreaLightsEnabled) {
					func.append(chunks.ltcPS);
				}
			}
			var useOldAmbient = false;
			if (options.useSpecular) {
				if (this.lighting) {
					func.append(options.shadingModel === SPECULAR_PHONG ? chunks.lightSpecularPhongPS : options.enableGGXSpecular ? chunks.lightSpecularAnisoGGXPS : chunks.lightSpecularBlinnPS);
				}
				if (!options.fresnelModel && !this.reflections && !options.diffuseMapEnabled) {
					decl.append("uniform vec3 material_ambient;");
					decl.append("#define LIT_OLD_AMBIENT");
					useOldAmbient = true;
				}
			}
			func.append(chunks.combinePS);
			if (options.lightMapEnabled) {
				func.append(options.useSpecular && options.dirLightMapEnabled ? chunks.lightmapDirAddPS : chunks.lightmapAddPS);
			}
			var addAmbient = !options.lightMapEnabled || options.lightMapWithoutAmbient;
			if (addAmbient) {
				if (options.ambientSource === 'ambientSH') {
					func.append(chunks.ambientSHPS);
				} else if (options.ambientSource === 'envAtlas') {
					if (options.reflectionSource !== 'envAtlas' && options.reflectionSource !== 'envAtlasHQ') {
						func.append(chunks.envAtlasPS);
					}
					func.append(chunks.ambientEnvPS.replace(/\$DECODE/g, ChunkUtils.decodeFunc(options.ambientEncoding)));
				} else {
					func.append(chunks.ambientConstantPS);
				}
			}
			if (options.useAmbientTint && !useOldAmbient) {
				decl.append("uniform vec3 material_ambient;");
			}
			if (options.useMsdf) {
				if (!options.msdfTextAttribute) {
					decl.append("#define UNIFORM_TEXT_PARAMETERS");
				}
				func.append(chunks.msdfPS);
			}
			if (this.needsNormal) {
				func.append(chunks.viewDirPS);
				if (options.useSpecular) {
					func.append(options.enableGGXSpecular ? chunks.reflDirAnisoPS : chunks.reflDirPS);
				}
			}
			var hasPointLights = false;
			var usesLinearFalloff = false;
			var usesInvSquaredFalloff = false;
			var usesSpot = false;
			var usesCookie = false;
			var usesCookieNow;
			if (options.clusteredLightingEnabled && this.lighting) {
				usesSpot = true;
				hasPointLights = true;
				usesLinearFalloff = true;
				usesCookie = true;
				func.append(chunks.floatUnpackingPS);
				if (options.lightMaskDynamic) decl.append("#define CLUSTER_MESH_DYNAMIC_LIGHTS");
				if (options.clusteredLightingCookiesEnabled) decl.append("#define CLUSTER_COOKIES");
				if (options.clusteredLightingShadowsEnabled && !options.noShadow) {
					decl.append("#define CLUSTER_SHADOWS");
					decl.append("#define CLUSTER_SHADOW_TYPE_" + shadowTypeToString[options.clusteredLightingShadowType]);
				}
				if (options.clusteredLightingAreaLightsEnabled) decl.append("#define CLUSTER_AREALIGHTS");
				decl.append(LightsBuffer.shaderDefines);
				if (options.clusteredLightingShadowsEnabled && !options.noShadow) {
					func.append(chunks.clusteredLightShadowsPS);
				}
				func.append(chunks.clusteredLightPS);
			}
			if (options.twoSidedLighting) {
				decl.append("uniform float twoSidedLightingNegScaleFactor;");
			}
			code.append(this._fsGetStartCode(code, device, chunks, options));
			if (this.needsNormal) {
				if (options.twoSidedLighting) {
					code.append("    dVertexNormalW = normalize(gl_FrontFacing ? vNormalW * twoSidedLightingNegScaleFactor : -vNormalW * twoSidedLightingNegScaleFactor);");
				} else {
					code.append("    dVertexNormalW = normalize(vNormalW);");
				}
				if ((options.useHeights || options.useNormals) && options.hasTangents) {
					if (options.twoSidedLighting) {
						code.append("    dTangentW = gl_FrontFacing ? vTangentW * twoSidedLightingNegScaleFactor : -vTangentW * twoSidedLightingNegScaleFactor;");
						code.append("    dBinormalW = gl_FrontFacing ? vBinormalW * twoSidedLightingNegScaleFactor : -vBinormalW * twoSidedLightingNegScaleFactor;");
					} else {
						code.append("    dTangentW = vTangentW;");
						code.append("    dBinormalW = vBinormalW;");
					}
				}
				code.append("    getViewDir();");
				if (hasTBN) {
					code.append("    getTBN(dTangentW, dBinormalW, dVertexNormalW);");
				}
			}
			code.append(this.frontendFunc);
			if (this.needsNormal) {
				if (options.useSpecular) {
					backend.append("    getReflDir(litArgs_worldNormal, dViewDirW, litArgs_gloss, dTBN);");
				}
				if (options.useClearCoat) {
					backend.append("    ccReflDirW = normalize(-reflect(dViewDirW, litArgs_clearcoat_worldNormal));");
				}
			}
			if (this.lighting && options.useSpecular || this.reflections) {
				if (options.useMetalness) {
					backend.append("    float f0 = 1.0 / litArgs_ior; f0 = (f0 - 1.0) / (f0 + 1.0); f0 *= f0;");
					backend.append("    litArgs_specularity = getSpecularModulate(litArgs_specularity, litArgs_albedo, litArgs_metalness, f0);");
					backend.append("    litArgs_albedo = getAlbedoModulate(litArgs_albedo, litArgs_metalness);");
				}
				if (options.useIridescence) {
					backend.append("    vec3 iridescenceFresnel = getIridescence(saturate(dot(dViewDirW, litArgs_worldNormal)), litArgs_specularity, litArgs_iridescence_thickness);");
				}
			}
			if (addAmbient) {
				backend.append("    addAmbient(litArgs_worldNormal);");
				if (options.conserveEnergy && options.useSpecular) {
					backend.append("   dDiffuseLight = dDiffuseLight * (1.0 - litArgs_specularity);");
				}
				if (options.separateAmbient) {
					backend.append("\n                    vec3 dAmbientLight = dDiffuseLight;\n                    dDiffuseLight = vec3(0);\n                ");
				}
			}
			if (options.useAmbientTint && !useOldAmbient) {
				backend.append("    dDiffuseLight *= material_ambient;");
			}
			if (options.useAo && !options.occludeDirect) {
				backend.append("    occludeDiffuse(litArgs_ao);");
			}
			if (options.lightMapEnabled) {
				backend.append("    addLightMap(\n                litArgs_lightmap, \n                litArgs_lightmapDir, \n                litArgs_worldNormal, \n                dViewDirW, \n                dReflDirW, \n                litArgs_gloss, \n                litArgs_specularity, \n                dVertexNormalW,\n                dTBN\n            #if defined(LIT_IRIDESCENCE)\n                , iridescenceFresnel,\n                litArgs_iridescence_intensity\n            #endif\n                );");
			}
			if (this.lighting || this.reflections) {
				if (this.reflections) {
					if (options.useClearCoat) {
						backend.append("    addReflectionCC(ccReflDirW, litArgs_clearcoat_gloss);");
						if (options.fresnelModel > 0) {
							backend.append("    ccFresnel = getFresnelCC(dot(dViewDirW, litArgs_clearcoat_worldNormal));");
							backend.append("    ccReflection.rgb *= ccFresnel;");
						} else {
							backend.append("    ccFresnel = 0.0;");
						}
					}
					if (options.useSpecularityFactor) {
						backend.append("    ccReflection.rgb *= litArgs_specularityFactor;");
					}
					if (options.useSheen) {
						backend.append("    addReflectionSheen(litArgs_worldNormal, dViewDirW, litArgs_sheen_gloss);");
					}
					backend.append("    addReflection(dReflDirW, litArgs_gloss);");
					if (options.fresnelModel > 0) {
						backend.append("    dReflection.rgb *= \n                        getFresnel(\n                            dot(dViewDirW, litArgs_worldNormal), \n                            litArgs_gloss, \n                            litArgs_specularity\n                        #if defined(LIT_IRIDESCENCE)\n                            , iridescenceFresnel,\n                            litArgs_iridescence_intensity\n                        #endif\n                            );");
					} else {
						backend.append("    dReflection.rgb *= litArgs_specularity;");
					}
					if (options.useSpecularityFactor) {
						backend.append("    dReflection.rgb *= litArgs_specularityFactor;");
					}
				}
				if (hasAreaLights) {
					backend.append("    dSpecularLight *= litArgs_specularity;");
					if (options.useSpecular) {
						backend.append("    calcLTCLightValues(litArgs_gloss, litArgs_worldNormal, dViewDirW, litArgs_specularity, litArgs_clearcoat_gloss, litArgs_clearcoat_worldNormal, litArgs_clearcoat_specularity);");
					}
				}
				for (var _i2 = 0; _i2 < options.lights.length; _i2++) {
					var _light = options.lights[_i2];
					var _lightType = _light._type;
					if (options.clusteredLightingEnabled && _lightType !== LIGHTTYPE_DIRECTIONAL) {
						continue;
					}
					usesCookieNow = false;
					var _lightShape = hasAreaLights && _light._shape ? _light.shape : LIGHTSHAPE_PUNCTUAL;
					var shapeString = hasAreaLights && _light._shape ? this._getLightSourceShapeString(_lightShape) : '';
					if (_lightShape !== LIGHTSHAPE_PUNCTUAL) {
						backend.append("    calc" + shapeString + "LightValues(light" + _i2 + "_position, light" + _i2 + "_halfWidth, light" + _i2 + "_halfHeight);");
					}
					if (_lightType === LIGHTTYPE_DIRECTIONAL) {
						backend.append("    dLightDirNormW = light" + _i2 + "_direction;");
						backend.append("    dAtten = 1.0;");
					} else {
						if (_light._cookie) {
							if (_lightType === LIGHTTYPE_SPOT && !_light._cookie._cubemap) {
								usesCookie = true;
								usesCookieNow = true;
							} else if (_lightType === LIGHTTYPE_OMNI && _light._cookie._cubemap) {
								usesCookie = true;
								usesCookieNow = true;
							}
						}
						backend.append("    getLightDirPoint(light" + _i2 + "_position);");
						hasPointLights = true;
						if (usesCookieNow) {
							if (_lightType === LIGHTTYPE_SPOT) {
								backend.append("    dAtten3 = getCookie2D" + (_light._cookieFalloff ? "" : "Clip") + (_light._cookieTransform ? "Xform" : "") + "(light" + _i2 + "_cookie, light" + _i2 + "_shadowMatrix, light" + _i2 + "_cookieIntensity" + (_light._cookieTransform ? ", light" + _i2 + "_cookieMatrix, light" + _i2 + "_cookieOffset" : "") + ")." + _light._cookieChannel + ";");
							} else {
								backend.append("    dAtten3 = getCookieCube(light" + _i2 + "_cookie, light" + _i2 + "_shadowMatrix, light" + _i2 + "_cookieIntensity)." + _light._cookieChannel + ";");
							}
						}
						if (_lightShape === LIGHTSHAPE_PUNCTUAL) {
							if (_light._falloffMode === LIGHTFALLOFF_LINEAR) {
								backend.append("    dAtten = getFalloffLinear(light" + _i2 + "_radius, dLightDirW);");
								usesLinearFalloff = true;
							} else {
								backend.append("    dAtten = getFalloffInvSquared(light" + _i2 + "_radius, dLightDirW);");
								usesInvSquaredFalloff = true;
							}
						} else {
							backend.append("    dAtten = getFalloffWindow(light" + _i2 + "_radius, dLightDirW);");
							usesInvSquaredFalloff = true;
						}
						backend.append("    if (dAtten > 0.00001) {");
						if (_lightType === LIGHTTYPE_SPOT) {
							if (!(usesCookieNow && !_light._cookieFalloff)) {
								backend.append("    dAtten *= getSpotEffect(light" + _i2 + "_direction, light" + _i2 + "_innerConeAngle, light" + _i2 + "_outerConeAngle, dLightDirNormW);");
								usesSpot = true;
							}
						}
					}
					if (_lightShape !== LIGHTSHAPE_PUNCTUAL) {
						if (_lightType === LIGHTTYPE_DIRECTIONAL) {
							backend.append("    dAttenD = getLightDiffuse(litArgs_worldNormal, dViewDirW, dLightDirW, dLightDirNormW);");
						} else {
							backend.append("    dAttenD = get" + shapeString + "LightDiffuse(litArgs_worldNormal, dViewDirW, dLightDirW, dLightDirNormW) * 16.0;");
						}
					} else {
						backend.append("    dAtten *= getLightDiffuse(litArgs_worldNormal, dViewDirW, dLightDirW, dLightDirNormW);");
					}
					if (_light.castShadows && !options.noShadow) {
						var pcssShadows = _light._shadowType === SHADOW_PCSS;
						var vsmShadows = _light._shadowType === SHADOW_VSM8 || _light._shadowType === SHADOW_VSM16 || _light._shadowType === SHADOW_VSM32;
						var pcfShadows = _light._shadowType === SHADOW_PCF1 || _light._shadowType === SHADOW_PCF3 || _light._shadowType === SHADOW_PCF5;
						var shadowReadMode = null;
						var evsmExp = void 0;
						switch (_light._shadowType) {
							case SHADOW_VSM8:
								shadowReadMode = "VSM8";
								evsmExp = "0.0";
								break;
							case SHADOW_VSM16:
								shadowReadMode = "VSM16";
								evsmExp = "5.54";
								break;
							case SHADOW_VSM32:
								shadowReadMode = "VSM32";
								if (device.textureFloatHighPrecision) {
									evsmExp = "15.0";
								} else {
									evsmExp = "5.54";
								}
								break;
							case SHADOW_PCF1:
								shadowReadMode = "PCF1x1";
								break;
							case SHADOW_PCF5:
								shadowReadMode = "PCF5x5";
								break;
							case SHADOW_PCSS:
								shadowReadMode = "PCSS";
								break;
							case SHADOW_PCF3:
							default:
								shadowReadMode = "PCF3x3";
								break;
						}
						if (shadowReadMode !== null) {
							if (_light._normalOffsetBias && !_light._isVsm) {
								func.append("#define SHADOW_SAMPLE_NORMAL_OFFSET");
							}
							if (_lightType === LIGHTTYPE_DIRECTIONAL) {
								func.append("#define SHADOW_SAMPLE_ORTHO");
							}
							if ((pcfShadows || pcssShadows) && device.isWebGL2 || device.isWebGPU || device.extStandardDerivatives) {
								func.append("#define SHADOW_SAMPLE_SOURCE_ZBUFFER");
							}
							if (_lightType === LIGHTTYPE_OMNI) {
								func.append("#define SHADOW_SAMPLE_POINT");
							}
							var coordCode = chunks.shadowSampleCoordPS;
							func.append(coordCode.replace("$LIGHT", _i2));
							func.append("#undef SHADOW_SAMPLE_NORMAL_OFFSET");
							func.append("#undef SHADOW_SAMPLE_ORTHO");
							func.append("#undef SHADOW_SAMPLE_SOURCE_ZBUFFER");
							func.append("#undef SHADOW_SAMPLE_POINT");
							var shadowMatrix = "light" + _i2 + "_shadowMatrix";
							if (_lightType === LIGHTTYPE_DIRECTIONAL && _light.numCascades > 1) {
								backend.append("    getShadowCascadeMatrix(light" + _i2 + "_shadowMatrixPalette, light" + _i2 + "_shadowCascadeDistances, light" + _i2 + "_shadowCascadeCount);");
								shadowMatrix = "cascadeShadowMat";
							}
							backend.append("    dShadowCoord = getShadowSampleCoord" + _i2 + "(" + shadowMatrix + ", light" + _i2 + "_shadowParams, vPositionW, dLightPosW, dLightDirW, dLightDirNormW, dVertexNormalW);");
							if (_lightType === LIGHTTYPE_DIRECTIONAL) {
								backend.append("    fadeShadow(light" + _i2 + "_shadowCascadeDistances);");
							}
							var shadowCoordArgs = "SHADOWMAP_PASS(light" + _i2 + "_shadowMap), dShadowCoord, light" + _i2 + "_shadowParams";
							if (vsmShadows) {
								shadowCoordArgs = shadowCoordArgs + ", " + evsmExp + ", dLightDirW";
							} else if (pcssShadows) {
								var penumbraSizeArg = "vec2(light" + _i2 + "_shadowSearchArea)";
								if (_lightShape !== LIGHTSHAPE_PUNCTUAL) {
									penumbraSizeArg = "vec2(length(light" + _i2 + "_halfWidth), length(light" + _i2 + "_halfHeight)) * light" + _i2 + "_shadowSearchArea";
								}
								shadowCoordArgs = shadowCoordArgs + ", light" + _i2 + "_cameraParams, " + penumbraSizeArg + ", dLightDirW";
							}
							if (_lightType === LIGHTTYPE_OMNI) {
								shadowReadMode = "Point" + shadowReadMode;
								if (!pcssShadows) {
									shadowCoordArgs = shadowCoordArgs + ", dLightDirW";
								}
							} else if (_lightType === LIGHTTYPE_SPOT) {
								shadowReadMode = "Spot" + shadowReadMode;
							}
							backend.append("    float shadow" + _i2 + " = getShadow" + shadowReadMode + "(" + shadowCoordArgs + ");");
							backend.append("    dAtten *= mix(1.0, shadow" + _i2 + ", light" + _i2 + "_shadowIntensity);");
						}
					}
					if (_lightShape !== LIGHTSHAPE_PUNCTUAL) {
						if (options.conserveEnergy && options.useSpecular) {
							backend.append("    dDiffuseLight += ((dAttenD * dAtten) * light" + _i2 + "_color" + (usesCookieNow ? " * dAtten3" : "") + ") * (1.0 - dLTCSpecFres);");
						} else {
							backend.append("    dDiffuseLight += (dAttenD * dAtten) * light" + _i2 + "_color" + (usesCookieNow ? " * dAtten3" : "") + ";");
						}
					} else {
						if (hasAreaLights && options.conserveEnergy && options.useSpecular) {
							backend.append("    dDiffuseLight += (dAtten * light" + _i2 + "_color" + (usesCookieNow ? " * dAtten3" : "") + ") * (1.0 - litArgs_specularity);");
						} else {
							backend.append("    dDiffuseLight += dAtten * light" + _i2 + "_color" + (usesCookieNow ? " * dAtten3" : "") + ";");
						}
					}
					if (options.useSpecular) {
						backend.append("    dHalfDirW = normalize(-dLightDirNormW + dViewDirW);");
					}
					if (_light.affectSpecularity) {
						if (_lightShape !== LIGHTSHAPE_PUNCTUAL) {
							if (options.useClearCoat) {
								backend.append("    ccSpecularLight += ccLTCSpecFres * get" + shapeString + "LightSpecular(litArgs_clearcoat_worldNormal, dViewDirW) * dAtten * light" + _i2 + "_color" + (usesCookieNow ? " * dAtten3" : "") + ";");
							}
							if (options.useSpecular) {
								backend.append("    dSpecularLight += dLTCSpecFres * get" + shapeString + "LightSpecular(litArgs_worldNormal, dViewDirW) * dAtten * light" + _i2 + "_color" + (usesCookieNow ? " * dAtten3" : "") + ";");
							}
						} else {
							var calcFresnel = false;
							if (_lightType === LIGHTTYPE_DIRECTIONAL && options.fresnelModel > 0) {
								calcFresnel = true;
							}
							if (options.useClearCoat) {
								backend.append("    ccSpecularLight += getLightSpecular(dHalfDirW, ccReflDirW, litArgs_clearcoat_worldNormal, dViewDirW, dLightDirNormW, litArgs_clearcoat_gloss, dTBN) * dAtten * light" + _i2 + "_color" + (usesCookieNow ? " * dAtten3" : "") + (calcFresnel ? " * getFresnelCC(dot(dViewDirW, dHalfDirW));" : ";"));
							}
							if (options.useSheen) {
								backend.append("    sSpecularLight += getLightSpecularSheen(dHalfDirW, litArgs_worldNormal, dViewDirW, dLightDirNormW, litArgs_sheen_gloss) * dAtten * light" + _i2 + "_color" + (usesCookieNow ? " * dAtten3;" : ";"));
							}
							if (options.useSpecular) {
								backend.append("    dSpecularLight += getLightSpecular(dHalfDirW, dReflDirW, litArgs_worldNormal, dViewDirW, dLightDirNormW, litArgs_gloss, dTBN) * dAtten * light" + _i2 + "_color" + (usesCookieNow ? " * dAtten3" : "") + (calcFresnel ? " \n                                    * getFresnel(\n                                        dot(dViewDirW, dHalfDirW), \n                                        litArgs_gloss, \n                                        litArgs_specularity\n                                    #if defined(LIT_IRIDESCENCE)\n                                        , iridescenceFresnel, \n                                        litArgs_iridescence_intensity\n                                    #endif\n                                    );" : "* litArgs_specularity;"));
							}
						}
					}
					if (_lightType !== LIGHTTYPE_DIRECTIONAL) {
						backend.append("    }");
					}
				}
				if (options.clusteredLightingEnabled && this.lighting) {
					usesLinearFalloff = true;
					usesInvSquaredFalloff = true;
					hasPointLights = true;
					backend.append("    addClusteredLights(\n                                        litArgs_worldNormal, \n                                        dViewDirW, \n                                        dReflDirW,\n                                #if defined(LIT_CLEARCOAT)\n                                        ccReflDirW,\n                                #endif\n                                        litArgs_gloss, \n                                        litArgs_specularity, \n                                        dVertexNormalW, \n                                        dTBN, \n                                #if defined(LIT_IRIDESCENCE)\n                                        iridescenceFresnel,\n                                #endif\n                                        litArgs_clearcoat_worldNormal, \n                                        litArgs_clearcoat_gloss,\n                                        litArgs_sheen_gloss,\n                                        litArgs_iridescence_intensity\n                                    );");
				}
				if (hasAreaLights) {
					if (options.useClearCoat) {
						backend.append("    litArgs_clearcoat_specularity = 1.0;");
					}
					if (options.useSpecular) {
						backend.append("    litArgs_specularity = vec3(1);");
					}
				}
				if (options.useRefraction) {
					backend.append("    addRefraction(\n                        litArgs_worldNormal, \n                        dViewDirW, \n                        litArgs_thickness, \n                        litArgs_gloss, \n                        litArgs_specularity, \n                        litArgs_albedo, \n                        litArgs_transmission,\n                        litArgs_ior\n                    #if defined(LIT_IRIDESCENCE)\n                        , iridescenceFresnel, \n                        litArgs_iridescence_intensity\n                    #endif\n                    );");
				}
			}
			if (options.useAo) {
				if (options.occludeDirect) {
					backend.append("    occludeDiffuse(litArgs_ao);");
				}
				if (options.occludeSpecular === SPECOCC_AO || options.occludeSpecular === SPECOCC_GLOSSDEPENDENT) {
					backend.append("    occludeSpecular(litArgs_gloss, litArgs_ao, litArgs_worldNormal, dViewDirW);");
				}
			}
			if (options.useSpecularityFactor) {
				backend.append("    dSpecularLight *= litArgs_specularityFactor;");
			}
			if (options.opacityFadesSpecular === false) {
				if (options.blendType === BLEND_NORMAL || options.blendType === BLEND_PREMULTIPLIED) {
					backend.append("float specLum = dot((dSpecularLight + dReflection.rgb * dReflection.a), vec3( 0.2126, 0.7152, 0.0722 ));");
					backend.append("#ifdef LIT_CLEARCOAT\n specLum += dot(ccSpecularLight * litArgs_clearcoat_specularity + ccReflection.rgb * litArgs_clearcoat_specularity, vec3( 0.2126, 0.7152, 0.0722 ));\n#endif");
					backend.append("litArgs_opacity = clamp(litArgs_opacity + gammaCorrectInput(specLum), 0.0, 1.0);");
				}
				backend.append("litArgs_opacity *= material_alphaFade;");
			}
			backend.append(chunks.endPS);
			if (options.blendType === BLEND_NORMAL || options.blendType === BLEND_ADDITIVEALPHA || options.alphaToCoverage) {
				backend.append(chunks.outputAlphaPS);
			} else if (options.blendType === BLEND_PREMULTIPLIED) {
				backend.append(chunks.outputAlphaPremulPS);
			} else {
				backend.append(chunks.outputAlphaOpaquePS);
			}
			if (options.useMsdf) {
				backend.append("    gl_FragColor = applyMsdf(gl_FragColor);");
			}
			backend.append(chunks.outputPS);
			backend.append(chunks.debugOutputPS);
			if (hasPointLights) {
				func.prepend(chunks.lightDirPointPS);
			}
			if (usesLinearFalloff) {
				func.prepend(chunks.falloffLinearPS);
			}
			if (usesInvSquaredFalloff) {
				func.prepend(chunks.falloffInvSquaredPS);
			}
			if (usesSpot) {
				func.prepend(chunks.spotPS);
			}
			if (usesCookie && !options.clusteredLightingEnabled) {
				func.prepend(chunks.cookiePS);
			}
			var structCode = "";
			var backendCode = "void evaluateBackend() {\n" + backend.code + "\n}";
			func.append(backendCode);
			code.append(chunks.debugProcessFrontendPS);
			code.append("    evaluateBackend();");
			code.append(ShaderGenerator.end());
			var mergedCode = decl.code + func.code + code.code;
			if (mergedCode.includes("dTBN")) structCode += "mat3 dTBN;\n";
			if (mergedCode.includes("dVertexNormalW")) structCode += "vec3 dVertexNormalW;\n";
			if (mergedCode.includes("dTangentW")) structCode += "vec3 dTangentW;\n";
			if (mergedCode.includes("dBinormalW")) structCode += "vec3 dBinormalW;\n";
			if (mergedCode.includes("dViewDirW")) structCode += "vec3 dViewDirW;\n";
			if (mergedCode.includes("dReflDirW")) structCode += "vec3 dReflDirW;\n";
			if (mergedCode.includes("dHalfDirW")) structCode += "vec3 dHalfDirW;\n";
			if (mergedCode.includes("ccReflDirW")) structCode += "vec3 ccReflDirW;\n";
			if (mergedCode.includes("dLightDirNormW")) structCode += "vec3 dLightDirNormW;\n";
			if (mergedCode.includes("dLightDirW")) structCode += "vec3 dLightDirW;\n";
			if (mergedCode.includes("dLightPosW")) structCode += "vec3 dLightPosW;\n";
			if (mergedCode.includes("dShadowCoord")) structCode += "vec3 dShadowCoord;\n";
			if (mergedCode.includes("dReflection")) structCode += "vec4 dReflection;\n";
			if (mergedCode.includes("dDiffuseLight")) structCode += "vec3 dDiffuseLight;\n";
			if (mergedCode.includes("dSpecularLight")) structCode += "vec3 dSpecularLight;\n";
			if (mergedCode.includes("dAtten")) structCode += "float dAtten;\n";
			if (mergedCode.includes("dAttenD")) structCode += "float dAttenD;\n";
			if (mergedCode.includes("dAtten3")) structCode += "vec3 dAtten3;\n";
			if (mergedCode.includes("dMsdf")) structCode += "vec4 dMsdf;\n";
			if (mergedCode.includes("ccFresnel")) structCode += "float ccFresnel;\n";
			if (mergedCode.includes("ccReflection")) structCode += "vec3 ccReflection;\n";
			if (mergedCode.includes("ccSpecularLight")) structCode += "vec3 ccSpecularLight;\n";
			if (mergedCode.includes("ccSpecularityNoFres")) structCode += "float ccSpecularityNoFres;\n";
			if (mergedCode.includes("sSpecularLight")) structCode += "vec3 sSpecularLight;\n";
			if (mergedCode.includes("sReflection")) structCode += "vec3 sReflection;\n";
			var result = this._fsGetBeginCode() + this.varyings + this.varyingDefines + this._fsGetBaseCode() + structCode + this.frontendDecl + mergedCode;
			return result;
		};
		_proto.generateFragmentShader = function generateFragmentShader(frontendDecl, frontendCode, frontendFunc, lightingUv) {
			var _this$handleCompatibi;
			var options = this.options;
			this.frontendDecl = frontendDecl;
			this.frontendCode = frontendCode;
			this.frontendFunc = frontendFunc;
			this.lightingUv = lightingUv;
			if (options.pass === SHADER_PICK) {
				this.fshader = this._fsGetPickPassCode();
			} else if (options.pass === SHADER_DEPTH) {
				this.fshader = this._fsGetDepthPassCode();
			} else if (this.shadowPass) {
				this.fshader = this._fsGetShadowPassCode();
			} else if (options.customFragmentShader) {
				this.fshader = this._fsGetBeginCode() + options.customFragmentShader;
			} else {
				this.fshader = this._fsGetLitPassCode();
			}
			(_this$handleCompatibi = this.handleCompatibility) == null || _this$handleCompatibi.call(this);
		};
		_proto.getDefinition = function getDefinition() {
			var definition = ShaderUtils.createDefinition(this.device, {
				name: 'LitShader',
				attributes: this.attributes,
				vertexCode: this.vshader,
				fragmentCode: this.fshader
			});
			if (this.shaderPassInfo.isForward) {
				definition.tag = SHADERTAG_MATERIAL;
			}
			return definition;
		};
		return LitShader;
	}();

	var LitOptionsUtils = {
		generateKey: function generateKey(options) {
			return "lit" + Object.keys(options).sort().map(function (key) {
				if (key === "chunks") {
					return LitOptionsUtils.generateChunksKey(options);
				} else if (key === "lights") {
					return LitOptionsUtils.generateLightsKey(options);
				}
				return key + options[key];
			}).join("\n");
		},
		generateLightsKey: function generateLightsKey(options) {
			return 'lights:' + options.lights.map(function (light) {
				return !options.clusteredLightingEnabled || light._type === LIGHTTYPE_DIRECTIONAL ? light.key + "," : '';
			}).join("");
		},
		generateChunksKey: function generateChunksKey(options) {
			var _options$chunks;
			return 'chunks:\n' + Object.keys((_options$chunks = options.chunks) != null ? _options$chunks : {}).sort().map(function (key) {
				return key + options.chunks[key];
			}).join("");
		}
	};

	var dummyUvs = [0, 1, 2, 3, 4, 5, 6, 7];
	var ShaderGeneratorLit = function (_ShaderGenerator) {
		_inheritsLoose(ShaderGeneratorLit, _ShaderGenerator);
		function ShaderGeneratorLit() {
			return _ShaderGenerator.apply(this, arguments) || this;
		}
		var _proto = ShaderGeneratorLit.prototype;
		_proto.generateKey = function generateKey(options) {
			var key = "lit" + dummyUvs.map(function (dummy, index) {
				return options.usedUvs[index] ? "1" : "0";
			}).join("") + options.shaderChunk + LitOptionsUtils.generateKey(options.litOptions);
			return key;
		};
		_proto.createShaderDefinition = function createShaderDefinition(device, options) {
			var litShader = new LitShader(device, options.litOptions);
			var decl = new ChunkBuilder();
			var code = new ChunkBuilder();
			var func = new ChunkBuilder();
			decl.append("uniform float textureBias;");
			decl.append(litShader.chunks.litShaderArgsPS);
			code.append(options.shaderChunk);
			func.code = "evaluateFrontend();";
			func.code = "\n" + func.code.split('\n').map(function (l) {
				return "    " + l;
			}).join('\n') + "\n\n";
			var usedUvSets = options.usedUvs || [true];
			var mapTransforms = [];
			litShader.generateVertexShader(usedUvSets, usedUvSets, mapTransforms);
			litShader.generateFragmentShader(decl.code, code.code, func.code, "vUv0");
			return litShader.getDefinition();
		};
		return ShaderGeneratorLit;
	}(ShaderGenerator);
	var lit = new ShaderGeneratorLit();

	var options = new LitMaterialOptions();
	var LitMaterial = function (_Material) {
		_inheritsLoose(LitMaterial, _Material);
		function LitMaterial() {
			var _this;
			for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}
			_this = _Material.call.apply(_Material, [this].concat(args)) || this;
			_this.usedUvs = [true];
			_this.shaderChunk = 'void evaluateFrontend() {}\n';
			_this.chunks = null;
			_this.useLighting = true;
			_this.useFog = true;
			_this.useGammaTonemap = true;
			_this.useSkybox = true;
			_this.shadingModel = SPECULAR_BLINN;
			_this.ambientSH = null;
			_this.pixelSnap = false;
			_this.nineSlicedMode = null;
			_this.fastTbn = false;
			_this.twoSidedLighting = false;
			_this.occludeDirect = false;
			_this.occludeSpecular = SPECOCC_AO;
			_this.occludeSpecularIntensity = 1;
			_this.opacityFadesSpecular = true;
			_this.conserveEnergy = true;
			_this.ggxSpecular = false;
			_this.fresnelModel = FRESNEL_SCHLICK;
			_this.dynamicRefraction = false;
			_this.hasAo = false;
			_this.hasSpecular = false;
			_this.hasSpecularityFactor = false;
			_this.hasLighting = false;
			_this.hasHeights = false;
			_this.hasNormals = false;
			_this.hasSheen = false;
			_this.hasRefraction = false;
			_this.hasIrridescence = false;
			_this.hasMetalness = false;
			_this.hasClearCoat = false;
			_this.hasClearCoatNormals = false;
			return _this;
		}
		var _proto = LitMaterial.prototype;
		_proto.getShaderVariant = function getShaderVariant(device, scene, objDefs, unused, pass, sortedLights, viewUniformFormat, viewBindGroupFormat, vertexFormat) {
			options.usedUvs = this.usedUvs.slice();
			options.shaderChunk = this.shaderChunk;
			LitMaterialOptionsBuilder.update(options.litOptions, this, scene, objDefs, pass, sortedLights);
			var processingOptions = new ShaderProcessorOptions(viewUniformFormat, viewBindGroupFormat, vertexFormat);
			var library = getProgramLibrary(device);
			library.register('lit', lit);
			var shader = library.getProgram('lit', options, processingOptions, this.userId);
			return shader;
		};
		return LitMaterial;
	}(Material);

	var tempVec3 = new Vec3();
	var tempMin3 = new Vec3();
	var tempMax3 = new Vec3();
	var tempBox = new BoundingBox();
	var epsilon = 0.000001;
	var ClusterLight = function ClusterLight() {
		this.light = null;
		this.min = new Vec3();
		this.max = new Vec3();
	};
	var WorldClusters = function () {
		function WorldClusters(device) {
			this.clusterTexture = void 0;
			this.device = device;
			this.name = 'Untitled';
			this.reportCount = 0;
			this.boundsMin = new Vec3();
			this.boundsMax = new Vec3();
			this.boundsDelta = new Vec3();
			this._cells = new Vec3(1, 1, 1);
			this._cellsLimit = new Vec3();
			this.cells = this._cells;
			this.maxCellLightCount = 4;
			this._maxAttenuation = 0;
			this._maxColorValue = 0;
			this._usedLights = [];
			this._usedLights.push(new ClusterLight());
			this.lightsBuffer = new LightsBuffer(device);
			this.registerUniforms(device);
		}
		var _proto = WorldClusters.prototype;
		_proto.destroy = function destroy() {
			this.lightsBuffer.destroy();
			this.releaseClusterTexture();
		};
		_proto.releaseClusterTexture = function releaseClusterTexture() {
			if (this.clusterTexture) {
				this.clusterTexture.destroy();
				this.clusterTexture = null;
			}
		};
		_proto.registerUniforms = function registerUniforms(device) {
			this._clusterSkipId = device.scope.resolve('clusterSkip');
			this._clusterMaxCellsId = device.scope.resolve('clusterMaxCells');
			this._clusterWorldTextureId = device.scope.resolve('clusterWorldTexture');
			this._clusterTextureSizeId = device.scope.resolve('clusterTextureSize');
			this._clusterTextureSizeData = new Float32Array(3);
			this._clusterBoundsMinId = device.scope.resolve('clusterBoundsMin');
			this._clusterBoundsMinData = new Float32Array(3);
			this._clusterBoundsDeltaId = device.scope.resolve('clusterBoundsDelta');
			this._clusterBoundsDeltaData = new Float32Array(3);
			this._clusterCellsCountByBoundsSizeId = device.scope.resolve('clusterCellsCountByBoundsSize');
			this._clusterCellsCountByBoundsSizeData = new Float32Array(3);
			this._clusterCellsDotId = device.scope.resolve('clusterCellsDot');
			this._clusterCellsDotData = new Float32Array(3);
			this._clusterCellsMaxId = device.scope.resolve('clusterCellsMax');
			this._clusterCellsMaxData = new Float32Array(3);
			this._clusterCompressionLimit0Id = device.scope.resolve('clusterCompressionLimit0');
			this._clusterCompressionLimit0Data = new Float32Array(2);
		};
		_proto.updateParams = function updateParams(lightingParams) {
			if (lightingParams) {
				this.cells = lightingParams.cells;
				this.maxCellLightCount = lightingParams.maxLightsPerCell;
				this.lightsBuffer.cookiesEnabled = lightingParams.cookiesEnabled;
				this.lightsBuffer.shadowsEnabled = lightingParams.shadowsEnabled;
				this.lightsBuffer.areaLightsEnabled = lightingParams.areaLightsEnabled;
			}
		};
		_proto.updateCells = function updateCells() {
			if (this._cellsDirty) {
				this._cellsDirty = false;
				var cx = this._cells.x;
				var cy = this._cells.y;
				var cz = this._cells.z;
				var numCells = cx * cy * cz;
				var totalPixels = this.maxCellLightCount * numCells;
				var width = Math.ceil(Math.sqrt(totalPixels));
				width = math.roundUp(width, this.maxCellLightCount);
				var height = Math.ceil(totalPixels / width);
				this._clusterCellsMaxData[0] = cx;
				this._clusterCellsMaxData[1] = cy;
				this._clusterCellsMaxData[2] = cz;
				this._clusterCellsDotData[0] = this.maxCellLightCount;
				this._clusterCellsDotData[1] = cx * cz * this.maxCellLightCount;
				this._clusterCellsDotData[2] = cx * this.maxCellLightCount;
				this.clusters = new Uint8ClampedArray(totalPixels);
				this.counts = new Int32Array(numCells);
				this._clusterTextureSizeData[0] = width;
				this._clusterTextureSizeData[1] = 1.0 / width;
				this._clusterTextureSizeData[2] = 1.0 / height;
				this.releaseClusterTexture();
				this.clusterTexture = LightsBuffer.createTexture(this.device, width, height, PIXELFORMAT_L8, 'ClusterTexture');
			}
		};
		_proto.uploadTextures = function uploadTextures() {
			this.clusterTexture.lock().set(this.clusters);
			this.clusterTexture.unlock();
			this.lightsBuffer.uploadTextures();
		};
		_proto.updateUniforms = function updateUniforms() {
			this._clusterSkipId.setValue(this._usedLights.length > 1 ? 0 : 1);
			this.lightsBuffer.updateUniforms();
			this._clusterWorldTextureId.setValue(this.clusterTexture);
			this._clusterMaxCellsId.setValue(this.maxCellLightCount);
			var boundsDelta = this.boundsDelta;
			this._clusterCellsCountByBoundsSizeData[0] = this._cells.x / boundsDelta.x;
			this._clusterCellsCountByBoundsSizeData[1] = this._cells.y / boundsDelta.y;
			this._clusterCellsCountByBoundsSizeData[2] = this._cells.z / boundsDelta.z;
			this._clusterCellsCountByBoundsSizeId.setValue(this._clusterCellsCountByBoundsSizeData);
			this._clusterBoundsMinData[0] = this.boundsMin.x;
			this._clusterBoundsMinData[1] = this.boundsMin.y;
			this._clusterBoundsMinData[2] = this.boundsMin.z;
			this._clusterBoundsDeltaData[0] = boundsDelta.x;
			this._clusterBoundsDeltaData[1] = boundsDelta.y;
			this._clusterBoundsDeltaData[2] = boundsDelta.z;
			this._clusterCompressionLimit0Data[0] = this._maxAttenuation;
			this._clusterCompressionLimit0Data[1] = this._maxColorValue;
			this._clusterTextureSizeId.setValue(this._clusterTextureSizeData);
			this._clusterBoundsMinId.setValue(this._clusterBoundsMinData);
			this._clusterBoundsDeltaId.setValue(this._clusterBoundsDeltaData);
			this._clusterCellsDotId.setValue(this._clusterCellsDotData);
			this._clusterCellsMaxId.setValue(this._clusterCellsMaxData);
			this._clusterCompressionLimit0Id.setValue(this._clusterCompressionLimit0Data);
		};
		_proto.evalLightCellMinMax = function evalLightCellMinMax(clusteredLight, min, max) {
			min.copy(clusteredLight.min);
			min.sub(this.boundsMin);
			min.div(this.boundsDelta);
			min.mul2(min, this.cells);
			min.floor();
			max.copy(clusteredLight.max);
			max.sub(this.boundsMin);
			max.div(this.boundsDelta);
			max.mul2(max, this.cells);
			max.ceil();
			min.max(Vec3.ZERO);
			max.min(this._cellsLimit);
		};
		_proto.collectLights = function collectLights(lights) {
			var maxLights = this.lightsBuffer.maxLights;
			var usedLights = this._usedLights;
			var lightIndex = 1;
			lights.forEach(function (light) {
				var runtimeLight = !!(light.mask & (MASK_AFFECT_DYNAMIC | MASK_AFFECT_LIGHTMAPPED));
				var zeroAngleSpotlight = light.type === LIGHTTYPE_SPOT && light._outerConeAngle === 0;
				if (light.enabled && light.type !== LIGHTTYPE_DIRECTIONAL && light.visibleThisFrame && light.intensity > 0 && runtimeLight && !zeroAngleSpotlight) {
					if (lightIndex < maxLights) {
						var clusteredLight;
						if (lightIndex < usedLights.length) {
							clusteredLight = usedLights[lightIndex];
						} else {
							clusteredLight = new ClusterLight();
							usedLights.push(clusteredLight);
						}
						clusteredLight.light = light;
						light.getBoundingBox(tempBox);
						clusteredLight.min.copy(tempBox.getMin());
						clusteredLight.max.copy(tempBox.getMax());
						lightIndex++;
					}
				}
			});
			usedLights.length = lightIndex;
		};
		_proto.evaluateBounds = function evaluateBounds() {
			var usedLights = this._usedLights;
			var min = this.boundsMin;
			var max = this.boundsMax;
			if (usedLights.length > 1) {
				min.copy(usedLights[1].min);
				max.copy(usedLights[1].max);
				for (var i = 2; i < usedLights.length; i++) {
					min.min(usedLights[i].min);
					max.max(usedLights[i].max);
				}
			} else {
				min.set(0, 0, 0);
				max.set(1, 1, 1);
			}
			this.boundsDelta.sub2(max, min);
			this.lightsBuffer.setBounds(min, this.boundsDelta);
		};
		_proto.evaluateCompressionLimits = function evaluateCompressionLimits(gammaCorrection) {
			var maxAttenuation = 0;
			var maxColorValue = 0;
			var usedLights = this._usedLights;
			for (var i = 1; i < usedLights.length; i++) {
				var light = usedLights[i].light;
				maxAttenuation = Math.max(light.attenuationEnd, maxAttenuation);
				var color = gammaCorrection ? light._linearFinalColor : light._finalColor;
				maxColorValue = Math.max(color[0], maxColorValue);
				maxColorValue = Math.max(color[1], maxColorValue);
				maxColorValue = Math.max(color[2], maxColorValue);
			}
			this._maxAttenuation = maxAttenuation + epsilon;
			this._maxColorValue = maxColorValue + epsilon;
			this.lightsBuffer.setCompressionRanges(this._maxAttenuation, this._maxColorValue);
		};
		_proto.updateClusters = function updateClusters(gammaCorrection) {
			this.counts.fill(0);
			this.clusters.fill(0);
			var divX = this._cells.x;
			var divZ = this._cells.z;
			var counts = this.counts;
			var limit = this._maxCellLightCount;
			var clusters = this.clusters;
			var pixelsPerCellCount = this.maxCellLightCount;
			var usedLights = this._usedLights;
			for (var i = 1; i < usedLights.length; i++) {
				var clusteredLight = usedLights[i];
				var light = clusteredLight.light;
				this.lightsBuffer.addLightData(light, i, gammaCorrection);
				this.evalLightCellMinMax(clusteredLight, tempMin3, tempMax3);
				var xStart = tempMin3.x;
				var xEnd = tempMax3.x;
				var yStart = tempMin3.y;
				var yEnd = tempMax3.y;
				var zStart = tempMin3.z;
				var zEnd = tempMax3.z;
				for (var x = xStart; x <= xEnd; x++) {
					for (var z = zStart; z <= zEnd; z++) {
						for (var y = yStart; y <= yEnd; y++) {
							var clusterIndex = x + divX * (z + y * divZ);
							var count = counts[clusterIndex];
							if (count < limit) {
								clusters[pixelsPerCellCount * clusterIndex + count] = i;
								counts[clusterIndex] = count + 1;
							}
						}
					}
				}
			}
		};
		_proto.update = function update(lights, gammaCorrection, lightingParams) {
			this.updateParams(lightingParams);
			this.updateCells();
			this.collectLights(lights);
			this.evaluateBounds();
			this.evaluateCompressionLimits(gammaCorrection);
			this.updateClusters(gammaCorrection);
			this.uploadTextures();
		};
		_proto.activate = function activate() {
			this.updateUniforms();
		};
		_createClass(WorldClusters, [{
			key: "maxCellLightCount",
			get: function get() {
				return this._maxCellLightCount;
			},
			set: function set(count) {
				if (count !== this._maxCellLightCount) {
					this._maxCellLightCount = count;
					this._cellsDirty = true;
				}
			}
		}, {
			key: "cells",
			get: function get() {
				return this._cells;
			},
			set: function set(value) {
				tempVec3.copy(value).floor();
				if (!this._cells.equals(tempVec3)) {
					this._cells.copy(tempVec3);
					this._cellsLimit.copy(tempVec3).sub(Vec3.ONE);
					this._cellsDirty = true;
				}
			}
		}]);
		return WorldClusters;
	}();

	var ShadowMap = function () {
		function ShadowMap(texture, targets) {
			this.texture = texture;
			this.cached = false;
			this.renderTargets = targets;
		}
		var _proto = ShadowMap.prototype;
		_proto.destroy = function destroy() {
			if (this.texture) {
				this.texture.destroy();
				this.texture = null;
			}
			var targets = this.renderTargets;
			for (var i = 0; i < targets.length; i++) {
				targets[i].destroy();
			}
			this.renderTargets.length = 0;
		};
		ShadowMap.getShadowFormat = function getShadowFormat(device, shadowType) {
			if (shadowType === SHADOW_VSM32) {
				return PIXELFORMAT_RGBA32F;
			} else if (shadowType === SHADOW_VSM16) {
				return PIXELFORMAT_RGBA16F;
			} else if (shadowType === SHADOW_PCF5) {
				return PIXELFORMAT_DEPTH;
			} else if ((shadowType === SHADOW_PCF1 || shadowType === SHADOW_PCF3) && device.supportsDepthShadow) {
				return PIXELFORMAT_DEPTH;
			} else if (shadowType === SHADOW_PCSS && !device.isWebGL1) {
				return PIXELFORMAT_R32F;
			}
			return PIXELFORMAT_RGBA8;
		};
		ShadowMap.getShadowFiltering = function getShadowFiltering(device, shadowType) {
			if ((shadowType === SHADOW_PCF1 || shadowType === SHADOW_PCF3 || shadowType === SHADOW_PCSS) && !device.supportsDepthShadow) {
				return FILTER_NEAREST;
			} else if (shadowType === SHADOW_VSM32) {
				return device.extTextureFloatLinear ? FILTER_LINEAR : FILTER_NEAREST;
			} else if (shadowType === SHADOW_VSM16) {
				return device.extTextureHalfFloatLinear ? FILTER_LINEAR : FILTER_NEAREST;
			}
			return FILTER_LINEAR;
		};
		ShadowMap.create = function create(device, light) {
			var shadowMap = null;
			if (light._type === LIGHTTYPE_OMNI) {
				shadowMap = this.createCubemap(device, light._shadowResolution, light._shadowType);
			} else {
				shadowMap = this.create2dMap(device, light._shadowResolution, light._shadowType);
			}
			return shadowMap;
		};
		ShadowMap.createAtlas = function createAtlas(device, resolution, shadowType) {
			var shadowMap = this.create2dMap(device, resolution, shadowType);
			var targets = shadowMap.renderTargets;
			var rt = targets[0];
			for (var i = 0; i < 5; i++) {
				targets.push(rt);
			}
			return shadowMap;
		};
		ShadowMap.create2dMap = function create2dMap(device, size, shadowType) {
			var format = this.getShadowFormat(device, shadowType);
			var filter = this.getShadowFiltering(device, shadowType);
			var texture = new Texture(device, {
				format: format,
				width: size,
				height: size,
				mipmaps: false,
				minFilter: filter,
				magFilter: filter,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE,
				name: 'ShadowMap2D'
			});
			var target = null;
			if (shadowType === SHADOW_PCF5 || (shadowType === SHADOW_PCF1 || shadowType === SHADOW_PCF3) && device.supportsDepthShadow) {
				texture.compareOnRead = true;
				texture.compareFunc = FUNC_LESS;
				target = new RenderTarget({
					depthBuffer: texture
				});
			} else {
				target = new RenderTarget({
					colorBuffer: texture,
					depth: true
				});
			}
			if (device.isWebGPU) {
				target.flipY = true;
			}
			return new ShadowMap(texture, [target]);
		};
		ShadowMap.createCubemap = function createCubemap(device, size, shadowType) {
			var format = shadowType === SHADOW_PCSS && !device.isWebGL1 ? PIXELFORMAT_R32F : PIXELFORMAT_RGBA8;
			var cubemap = new Texture(device, {
				format: format,
				width: size,
				height: size,
				cubemap: true,
				mipmaps: false,
				minFilter: FILTER_NEAREST,
				magFilter: FILTER_NEAREST,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE,
				name: 'ShadowMapCube'
			});
			var targets = [];
			for (var i = 0; i < 6; i++) {
				var target = new RenderTarget({
					colorBuffer: cubemap,
					face: i,
					depth: true
				});
				targets.push(target);
			}
			return new ShadowMap(cubemap, targets);
		};
		return ShadowMap;
	}();

	var _tempArray = [];
	var _tempArray2 = [];
	var _viewport$3 = new Vec4();
	var _scissor = new Vec4();
	var Slot = function Slot(rect) {
		this.size = Math.floor(rect.w * 1024);
		this.used = false;
		this.lightId = -1;
		this.rect = rect;
	};
	var LightTextureAtlas = function () {
		function LightTextureAtlas(device) {
			this.device = device;
			this.version = 1;
			this.shadowAtlasResolution = 2048;
			this.shadowAtlas = null;
			this.shadowEdgePixels = 3;
			this.cookieAtlasResolution = 4;
			this.cookieAtlas = new Texture(this.device, {
				name: 'CookieAtlas',
				width: this.cookieAtlasResolution,
				height: this.cookieAtlasResolution,
				format: PIXELFORMAT_RGBA8,
				cubemap: false,
				mipmaps: false,
				minFilter: FILTER_NEAREST,
				magFilter: FILTER_NEAREST,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE
			});
			this.cookieRenderTarget = new RenderTarget({
				colorBuffer: this.cookieAtlas,
				depth: false,
				flipY: true
			});
			this.slots = [];
			this.atlasSplit = [];
			this.cubeSlotsOffsets = [new Vec2(0, 0), new Vec2(0, 1), new Vec2(1, 0), new Vec2(1, 1), new Vec2(2, 0), new Vec2(2, 1)];
			this.scissorVec = new Vec4();
			this.allocateShadowAtlas(1);
			this.allocateCookieAtlas(1);
			this.allocateUniforms();
		}
		var _proto = LightTextureAtlas.prototype;
		_proto.destroy = function destroy() {
			this.destroyShadowAtlas();
			this.destroyCookieAtlas();
		};
		_proto.destroyShadowAtlas = function destroyShadowAtlas() {
			var _this$shadowAtlas;
			(_this$shadowAtlas = this.shadowAtlas) == null || _this$shadowAtlas.destroy();
			this.shadowAtlas = null;
		};
		_proto.destroyCookieAtlas = function destroyCookieAtlas() {
			var _this$cookieAtlas, _this$cookieRenderTar;
			(_this$cookieAtlas = this.cookieAtlas) == null || _this$cookieAtlas.destroy();
			this.cookieAtlas = null;
			(_this$cookieRenderTar = this.cookieRenderTarget) == null || _this$cookieRenderTar.destroy();
			this.cookieRenderTarget = null;
		};
		_proto.allocateShadowAtlas = function allocateShadowAtlas(resolution) {
			if (!this.shadowAtlas || this.shadowAtlas.texture.width !== resolution) {
				this.version++;
				this.destroyShadowAtlas();
				this.shadowAtlas = ShadowMap.createAtlas(this.device, resolution, SHADOW_PCF3);
				this.shadowAtlas.cached = true;
				var scissorOffset = 4 / this.shadowAtlasResolution;
				this.scissorVec.set(scissorOffset, scissorOffset, -2 * scissorOffset, -2 * scissorOffset);
			}
		};
		_proto.allocateCookieAtlas = function allocateCookieAtlas(resolution) {
			if (this.cookieAtlas.width !== resolution) {
				this.cookieRenderTarget.resize(resolution, resolution);
				this.version++;
			}
		};
		_proto.allocateUniforms = function allocateUniforms() {
			this._shadowAtlasTextureId = this.device.scope.resolve('shadowAtlasTexture');
			this._shadowAtlasParamsId = this.device.scope.resolve('shadowAtlasParams');
			this._shadowAtlasParams = new Float32Array(2);
			this._cookieAtlasTextureId = this.device.scope.resolve('cookieAtlasTexture');
		};
		_proto.updateUniforms = function updateUniforms() {
			var isShadowFilterPcf = true;
			var rt = this.shadowAtlas.renderTargets[0];
			var isDepthShadow = !this.device.isWebGL1 && isShadowFilterPcf;
			var shadowBuffer = isDepthShadow ? rt.depthBuffer : rt.colorBuffer;
			this._shadowAtlasTextureId.setValue(shadowBuffer);
			this._shadowAtlasParams[0] = this.shadowAtlasResolution;
			this._shadowAtlasParams[1] = this.shadowEdgePixels;
			this._shadowAtlasParamsId.setValue(this._shadowAtlasParams);
			this._cookieAtlasTextureId.setValue(this.cookieAtlas);
		};
		_proto.subdivide = function subdivide(numLights, lightingParams) {
			var atlasSplit = lightingParams.atlasSplit;
			if (!atlasSplit) {
				var gridSize = Math.ceil(Math.sqrt(numLights));
				atlasSplit = _tempArray2;
				atlasSplit[0] = gridSize;
				atlasSplit.length = 1;
			}
			var arraysEqual = function arraysEqual(a, b) {
				return a.length === b.length && a.every(function (v, i) {
					return v === b[i];
				});
			};
			if (!arraysEqual(atlasSplit, this.atlasSplit)) {
				var _this$atlasSplit;
				this.version++;
				this.slots.length = 0;
				this.atlasSplit.length = 0;
				(_this$atlasSplit = this.atlasSplit).push.apply(_this$atlasSplit, atlasSplit);
				var splitCount = this.atlasSplit[0];
				if (splitCount > 1) {
					var invSize = 1 / splitCount;
					for (var i = 0; i < splitCount; i++) {
						for (var j = 0; j < splitCount; j++) {
							var rect = new Vec4(i * invSize, j * invSize, invSize, invSize);
							var nextLevelSplit = this.atlasSplit[1 + i * splitCount + j];
							if (nextLevelSplit > 1) {
								for (var x = 0; x < nextLevelSplit; x++) {
									for (var y = 0; y < nextLevelSplit; y++) {
										var invSizeNext = invSize / nextLevelSplit;
										var rectNext = new Vec4(rect.x + x * invSizeNext, rect.y + y * invSizeNext, invSizeNext, invSizeNext);
										this.slots.push(new Slot(rectNext));
									}
								}
							} else {
								this.slots.push(new Slot(rect));
							}
						}
					}
				} else {
					this.slots.push(new Slot(new Vec4(0, 0, 1, 1)));
				}
				this.slots.sort(function (a, b) {
					return b.size - a.size;
				});
			}
		};
		_proto.collectLights = function collectLights(localLights, lightingParams) {
			var cookiesEnabled = lightingParams.cookiesEnabled;
			var shadowsEnabled = lightingParams.shadowsEnabled;
			var needsShadowAtlas = false;
			var needsCookieAtlas = false;
			var lights = _tempArray;
			lights.length = 0;
			var processLights = function processLights(list) {
				for (var i = 0; i < list.length; i++) {
					var light = list[i];
					if (light.visibleThisFrame) {
						var lightShadow = shadowsEnabled && light.castShadows;
						var lightCookie = cookiesEnabled && !!light.cookie;
						needsShadowAtlas || (needsShadowAtlas = lightShadow);
						needsCookieAtlas || (needsCookieAtlas = lightCookie);
						if (lightShadow || lightCookie) {
							lights.push(light);
						}
					}
				}
			};
			if (cookiesEnabled || shadowsEnabled) {
				processLights(localLights);
			}
			lights.sort(function (a, b) {
				return b.maxScreenSize - a.maxScreenSize;
			});
			if (needsShadowAtlas) {
				this.allocateShadowAtlas(this.shadowAtlasResolution);
			}
			if (needsCookieAtlas) {
				this.allocateCookieAtlas(this.cookieAtlasResolution);
			}
			if (needsShadowAtlas || needsCookieAtlas) {
				this.subdivide(lights.length, lightingParams);
			}
			return lights;
		};
		_proto.setupSlot = function setupSlot(light, rect) {
			light.atlasViewport.copy(rect);
			var faceCount = light.numShadowFaces;
			for (var face = 0; face < faceCount; face++) {
				if (light.castShadows || light._cookie) {
					_viewport$3.copy(rect);
					_scissor.copy(rect);
					if (light._type === LIGHTTYPE_SPOT) {
						_viewport$3.add(this.scissorVec);
					}
					if (light._type === LIGHTTYPE_OMNI) {
						var smallSize = _viewport$3.z / 3;
						var offset = this.cubeSlotsOffsets[face];
						_viewport$3.x += smallSize * offset.x;
						_viewport$3.y += smallSize * offset.y;
						_viewport$3.z = smallSize;
						_viewport$3.w = smallSize;
						_scissor.copy(_viewport$3);
					}
					if (light.castShadows) {
						var lightRenderData = light.getRenderData(null, face);
						lightRenderData.shadowViewport.copy(_viewport$3);
						lightRenderData.shadowScissor.copy(_scissor);
					}
				}
			}
		};
		_proto.assignSlot = function assignSlot(light, slotIndex, slotReassigned) {
			light.atlasViewportAllocated = true;
			var slot = this.slots[slotIndex];
			slot.lightId = light.id;
			slot.used = true;
			if (slotReassigned) {
				light.atlasSlotUpdated = true;
				light.atlasVersion = this.version;
				light.atlasSlotIndex = slotIndex;
			}
		};
		_proto.update = function update(localLights, lightingParams) {
			this.shadowAtlasResolution = lightingParams.shadowAtlasResolution;
			this.cookieAtlasResolution = lightingParams.cookieAtlasResolution;
			var lights = this.collectLights(localLights, lightingParams);
			if (lights.length > 0) {
				var slots = this.slots;
				for (var i = 0; i < slots.length; i++) {
					slots[i].used = false;
				}
				var assignCount = Math.min(lights.length, slots.length);
				for (var _i = 0; _i < assignCount; _i++) {
					var light = lights[_i];
					if (light.castShadows) light._shadowMap = this.shadowAtlas;
					var previousSlot = slots[light.atlasSlotIndex];
					if (light.atlasVersion === this.version && light.id === (previousSlot == null ? void 0 : previousSlot.lightId)) {
						var _previousSlot = slots[light.atlasSlotIndex];
						if (_previousSlot.size === slots[_i].size && !_previousSlot.used) {
							this.assignSlot(light, light.atlasSlotIndex, false);
						}
					}
				}
				var usedCount = 0;
				for (var _i2 = 0; _i2 < assignCount; _i2++) {
					while (usedCount < slots.length && slots[usedCount].used) usedCount++;
					var _light = lights[_i2];
					if (!_light.atlasViewportAllocated) {
						this.assignSlot(_light, usedCount, true);
					}
					var slot = slots[_light.atlasSlotIndex];
					this.setupSlot(_light, slot.rect);
				}
			}
			this.updateUniforms();
		};
		return LightTextureAtlas;
	}();

	var lightCubeDir = [new Vec3(-1, 0, 0), new Vec3(1, 0, 0), new Vec3(0, -1, 0), new Vec3(0, 1, 0), new Vec3(0, 0, -1), new Vec3(0, 0, 1)];
	var LightCube = function () {
		function LightCube() {
			this.colors = new Float32Array(6 * 3);
		}
		var _proto = LightCube.prototype;
		_proto.update = function update(ambientLight, lights) {
			var colors = this.colors;
			var r = ambientLight.r,
				g = ambientLight.g,
				b = ambientLight.b;
			for (var j = 0; j < 6; j++) {
				colors[j * 3] = r;
				colors[j * 3 + 1] = g;
				colors[j * 3 + 2] = b;
			}
			for (var _j = 0; _j < lights.length; _j++) {
				var light = lights[_j];
				if (light._type === LIGHTTYPE_DIRECTIONAL) {
					for (var c = 0; c < 6; c++) {
						var weight = Math.max(lightCubeDir[c].dot(light._direction), 0) * light._intensity;
						var lightColor = light._color;
						colors[c * 3] += lightColor.r * weight;
						colors[c * 3 + 1] += lightColor.g * weight;
						colors[c * 3 + 2] += lightColor.b * weight;
					}
				}
			}
		};
		return LightCube;
	}();

	var ShadowMapCache = function () {
		function ShadowMapCache() {
			this.cache = new Map();
		}
		var _proto = ShadowMapCache.prototype;
		_proto.destroy = function destroy() {
			this.clear();
			this.cache = null;
		};
		_proto.clear = function clear() {
			this.cache.forEach(function (shadowMaps) {
				shadowMaps.forEach(function (shadowMap) {
					shadowMap.destroy();
				});
			});
			this.cache.clear();
		};
		_proto.getKey = function getKey(light) {
			var isCubeMap = light._type === LIGHTTYPE_OMNI;
			var shadowType = light._shadowType;
			var resolution = light._shadowResolution;
			return isCubeMap + "-" + shadowType + "-" + resolution;
		};
		_proto.get = function get(device, light) {
			var key = this.getKey(light);
			var shadowMaps = this.cache.get(key);
			if (shadowMaps && shadowMaps.length) {
				return shadowMaps.pop();
			}
			var shadowMap = ShadowMap.create(device, light);
			shadowMap.cached = true;
			return shadowMap;
		};
		_proto.add = function add(light, shadowMap) {
			var key = this.getKey(light);
			var shadowMaps = this.cache.get(key);
			if (shadowMaps) {
				shadowMaps.push(shadowMap);
			} else {
				this.cache.set(key, [shadowMap]);
			}
		};
		return ShadowMapCache;
	}();

	var RenderPassShadowLocalNonClustered = function (_RenderPass) {
		_inheritsLoose(RenderPassShadowLocalNonClustered, _RenderPass);
		function RenderPassShadowLocalNonClustered(device, shadowRenderer, light, face, applyVsm) {
			var _this;
			_this = _RenderPass.call(this, device) || this;
			_this.requiresCubemaps = false;
			_this.shadowRenderer = shadowRenderer;
			_this.light = light;
			_this.face = face;
			_this.applyVsm = applyVsm;
			_this.shadowCamera = shadowRenderer.prepareFace(light, null, face);
			shadowRenderer.setupRenderPass(_assertThisInitialized(_this), _this.shadowCamera, true);
			return _this;
		}
		var _proto = RenderPassShadowLocalNonClustered.prototype;
		_proto.execute = function execute() {
			this.shadowRenderer.renderFace(this.light, null, this.face, false);
		};
		_proto.after = function after() {
			if (this.applyVsm) {
				this.shadowRenderer.renderVsm(this.light, this.shadowCamera);
			}
		};
		return RenderPassShadowLocalNonClustered;
	}(RenderPass);

	var ShadowRendererLocal = function () {
		function ShadowRendererLocal(renderer, shadowRenderer) {
			this.shadowLights = [];
			this.renderer = void 0;
			this.shadowRenderer = void 0;
			this.device = void 0;
			this.renderer = renderer;
			this.shadowRenderer = shadowRenderer;
			this.device = renderer.device;
		}
		var _proto = ShadowRendererLocal.prototype;
		_proto.cull = function cull(light, comp, casters) {
			if (casters === void 0) {
				casters = null;
			}
			var isClustered = this.renderer.scene.clusteredLightingEnabled;
			light.visibleThisFrame = true;
			if (!isClustered) {
				if (!light._shadowMap) {
					light._shadowMap = ShadowMap.create(this.device, light);
				}
			}
			var type = light._type;
			var faceCount = type === LIGHTTYPE_SPOT ? 1 : 6;
			for (var face = 0; face < faceCount; face++) {
				var lightRenderData = light.getRenderData(null, face);
				var shadowCam = lightRenderData.shadowCamera;
				shadowCam.nearClip = light.attenuationEnd / 1000;
				shadowCam.farClip = light.attenuationEnd;
				lightRenderData.depthRangeCompensation = shadowCam.farClip - shadowCam.nearClip;
				var shadowCamNode = shadowCam._node;
				var lightNode = light._node;
				shadowCamNode.setPosition(lightNode.getPosition());
				if (type === LIGHTTYPE_SPOT) {
					shadowCam.fov = light._outerConeAngle * 2;
					shadowCamNode.setRotation(lightNode.getRotation());
					shadowCamNode.rotateLocal(-90, 0, 0);
				} else if (type === LIGHTTYPE_OMNI) {
					if (isClustered) {
						var tileSize = this.shadowRenderer.lightTextureAtlas.shadowAtlasResolution * light.atlasViewport.z / 3;
						var texelSize = 2 / tileSize;
						var filterSize = texelSize * this.shadowRenderer.lightTextureAtlas.shadowEdgePixels;
						shadowCam.fov = Math.atan(1 + filterSize) * math.RAD_TO_DEG * 2;
					} else {
						shadowCam.fov = 90;
					}
				}
				this.renderer.updateCameraFrustum(shadowCam);
				this.shadowRenderer.cullShadowCasters(comp, light, lightRenderData.visibleCasters, shadowCam, casters);
			}
		};
		_proto.prepareLights = function prepareLights(shadowLights, lights) {
			var shadowCamera;
			for (var i = 0; i < lights.length; i++) {
				var light = lights[i];
				if (this.shadowRenderer.needsShadowRendering(light) && light.atlasViewportAllocated) {
					shadowLights.push(light);
					for (var face = 0; face < light.numShadowFaces; face++) {
						shadowCamera = this.shadowRenderer.prepareFace(light, null, face);
					}
				}
			}
			return shadowCamera;
		};
		_proto.buildNonClusteredRenderPasses = function buildNonClusteredRenderPasses(frameGraph, localLights) {
			for (var i = 0; i < localLights.length; i++) {
				var light = localLights[i];
				if (this.shadowRenderer.needsShadowRendering(light)) {
					var applyVsm = light._type === LIGHTTYPE_SPOT;
					var faceCount = light.numShadowFaces;
					for (var face = 0; face < faceCount; face++) {
						var renderPass = new RenderPassShadowLocalNonClustered(this.device, this.shadowRenderer, light, face, applyVsm);
						frameGraph.addRenderPass(renderPass);
					}
				}
			}
		};
		return ShadowRendererLocal;
	}();

	var RenderPassShadowDirectional = function (_RenderPass) {
		_inheritsLoose(RenderPassShadowDirectional, _RenderPass);
		function RenderPassShadowDirectional(device, shadowRenderer, light, camera, allCascadesRendering) {
			var _this;
			_this = _RenderPass.call(this, device) || this;
			_this.shadowRenderer = shadowRenderer;
			_this.light = light;
			_this.camera = camera;
			_this.allCascadesRendering = allCascadesRendering;
			return _this;
		}
		var _proto = RenderPassShadowDirectional.prototype;
		_proto.execute = function execute() {
			var light = this.light,
				camera = this.camera,
				shadowRenderer = this.shadowRenderer,
				allCascadesRendering = this.allCascadesRendering;
			var faceCount = light.numShadowFaces;
			var shadowUpdateOverrides = light.shadowUpdateOverrides;
			for (var face = 0; face < faceCount; face++) {
				if ((shadowUpdateOverrides == null ? void 0 : shadowUpdateOverrides[face]) !== SHADOWUPDATE_NONE) {
					shadowRenderer.renderFace(light, camera, face, !allCascadesRendering);
				}
				if ((shadowUpdateOverrides == null ? void 0 : shadowUpdateOverrides[face]) === SHADOWUPDATE_THISFRAME) {
					shadowUpdateOverrides[face] = SHADOWUPDATE_NONE;
				}
			}
		};
		_proto.after = function after() {
			this.shadowRenderer.renderVsm(this.light, this.camera);
		};
		return RenderPassShadowDirectional;
	}(RenderPass);

	var visibleSceneAabb = new BoundingBox();
	var center = new Vec3();
	var shadowCamView$1 = new Mat4();
	var aabbPoints = [new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3()];
	var _depthRange = {
		min: 0,
		max: 0
	};
	function getDepthRange(cameraViewMatrix, aabbMin, aabbMax) {
		aabbPoints[0].x = aabbPoints[1].x = aabbPoints[2].x = aabbPoints[3].x = aabbMin.x;
		aabbPoints[1].y = aabbPoints[3].y = aabbPoints[7].y = aabbPoints[5].y = aabbMin.y;
		aabbPoints[2].z = aabbPoints[3].z = aabbPoints[6].z = aabbPoints[7].z = aabbMin.z;
		aabbPoints[4].x = aabbPoints[5].x = aabbPoints[6].x = aabbPoints[7].x = aabbMax.x;
		aabbPoints[0].y = aabbPoints[2].y = aabbPoints[4].y = aabbPoints[6].y = aabbMax.y;
		aabbPoints[0].z = aabbPoints[1].z = aabbPoints[4].z = aabbPoints[5].z = aabbMax.z;
		var minz = 9999999999;
		var maxz = -9999999999;
		for (var i = 0; i < 8; ++i) {
			cameraViewMatrix.transformPoint(aabbPoints[i], aabbPoints[i]);
			var z = aabbPoints[i].z;
			if (z < minz) minz = z;
			if (z > maxz) maxz = z;
		}
		_depthRange.min = minz;
		_depthRange.max = maxz;
		return _depthRange;
	}
	var ShadowRendererDirectional = function () {
		function ShadowRendererDirectional(renderer, shadowRenderer) {
			this.renderer = void 0;
			this.shadowRenderer = void 0;
			this.device = void 0;
			this.renderer = renderer;
			this.shadowRenderer = shadowRenderer;
			this.device = renderer.device;
		}
		var _proto = ShadowRendererDirectional.prototype;
		_proto.cull = function cull(light, comp, camera, casters) {
			if (casters === void 0) {
				casters = null;
			}
			light.visibleThisFrame = true;
			if (!light._shadowMap) {
				light._shadowMap = ShadowMap.create(this.device, light);
			}
			var nearDist = camera._nearClip;
			this.generateSplitDistances(light, nearDist, Math.min(camera._farClip, light.shadowDistance));
			var shadowUpdateOverrides = light.shadowUpdateOverrides;
			for (var cascade = 0; cascade < light.numCascades; cascade++) {
				if ((shadowUpdateOverrides == null ? void 0 : shadowUpdateOverrides[cascade]) === SHADOWUPDATE_NONE) {
					break;
				}
				var lightRenderData = light.getRenderData(camera, cascade);
				var shadowCam = lightRenderData.shadowCamera;
				shadowCam.renderTarget = light._shadowMap.renderTargets[0];
				lightRenderData.shadowViewport.copy(light.cascades[cascade]);
				lightRenderData.shadowScissor.copy(light.cascades[cascade]);
				var shadowCamNode = shadowCam._node;
				var lightNode = light._node;
				shadowCamNode.setPosition(lightNode.getPosition());
				shadowCamNode.setRotation(lightNode.getRotation());
				shadowCamNode.rotateLocal(-90, 0, 0);
				var frustumNearDist = cascade === 0 ? nearDist : light._shadowCascadeDistances[cascade - 1];
				var frustumFarDist = light._shadowCascadeDistances[cascade];
				var frustumPoints = camera.getFrustumCorners(frustumNearDist, frustumFarDist);
				center.set(0, 0, 0);
				var cameraWorldMat = camera.node.getWorldTransform();
				for (var i = 0; i < 8; i++) {
					cameraWorldMat.transformPoint(frustumPoints[i], frustumPoints[i]);
					center.add(frustumPoints[i]);
				}
				center.mulScalar(1 / 8);
				var radius = 0;
				for (var _i = 0; _i < 8; _i++) {
					var dist = frustumPoints[_i].sub(center).length();
					if (dist > radius) radius = dist;
				}
				var right = shadowCamNode.right;
				var up = shadowCamNode.up;
				var lightDir = shadowCamNode.forward;
				var sizeRatio = 0.25 * light._shadowResolution / radius;
				var x = Math.ceil(center.dot(up) * sizeRatio) / sizeRatio;
				var y = Math.ceil(center.dot(right) * sizeRatio) / sizeRatio;
				var scaledUp = up.mulScalar(x);
				var scaledRight = right.mulScalar(y);
				var dot = center.dot(lightDir);
				var scaledDir = lightDir.mulScalar(dot);
				center.add2(scaledUp, scaledRight).add(scaledDir);
				shadowCamNode.setPosition(center);
				shadowCamNode.translateLocal(0, 0, 1000000);
				shadowCam.nearClip = 0.01;
				shadowCam.farClip = 2000000;
				shadowCam.orthoHeight = radius;
				this.renderer.updateCameraFrustum(shadowCam);
				this.shadowRenderer.cullShadowCasters(comp, light, lightRenderData.visibleCasters, shadowCam, casters);
				var emptyAabb = true;
				var visibleCasters = lightRenderData.visibleCasters;
				for (var _i2 = 0; _i2 < visibleCasters.length; _i2++) {
					var meshInstance = visibleCasters[_i2];
					if (emptyAabb) {
						emptyAabb = false;
						visibleSceneAabb.copy(meshInstance.aabb);
					} else {
						visibleSceneAabb.add(meshInstance.aabb);
					}
				}
				shadowCamView$1.copy(shadowCamNode.getWorldTransform()).invert();
				var depthRange = getDepthRange(shadowCamView$1, visibleSceneAabb.getMin(), visibleSceneAabb.getMax());
				shadowCamNode.translateLocal(0, 0, depthRange.max + 0.1);
				shadowCam.farClip = depthRange.max - depthRange.min + 0.2;
				lightRenderData.depthRangeCompensation = shadowCam.farClip;
				lightRenderData.projectionCompensation = radius;
			}
		};
		_proto.generateSplitDistances = function generateSplitDistances(light, nearDist, farDist) {
			light._shadowCascadeDistances.fill(farDist);
			for (var i = 1; i < light.numCascades; i++) {
				var fraction = i / light.numCascades;
				var linearDist = nearDist + (farDist - nearDist) * fraction;
				var logDist = nearDist * Math.pow(farDist / nearDist, fraction);
				var dist = math.lerp(linearDist, logDist, light.cascadeDistribution);
				light._shadowCascadeDistances[i - 1] = dist;
			}
		};
		_proto.addLightRenderPasses = function addLightRenderPasses(frameGraph, light, camera) {
			var faceCount = light.numShadowFaces;
			var shadowUpdateOverrides = light.shadowUpdateOverrides;
			var allCascadesRendering = true;
			var shadowCamera;
			for (var face = 0; face < faceCount; face++) {
				if ((shadowUpdateOverrides == null ? void 0 : shadowUpdateOverrides[face]) === SHADOWUPDATE_NONE) allCascadesRendering = false;
				shadowCamera = this.shadowRenderer.prepareFace(light, camera, face);
			}
			var renderPass = new RenderPassShadowDirectional(this.device, this.shadowRenderer, light, camera, allCascadesRendering);
			this.shadowRenderer.setupRenderPass(renderPass, shadowCamera, allCascadesRendering);
			frameGraph.addRenderPass(renderPass);
		};
		_proto.buildFrameGraph = function buildFrameGraph(frameGraph, directionalLights, camera) {
			for (var i = 0; i < directionalLights.length; i++) {
				var light = directionalLights[i];
				if (this.shadowRenderer.needsShadowRendering(light)) {
					this.addLightRenderPasses(frameGraph, light, camera.camera);
				}
			}
		};
		return ShadowRendererDirectional;
	}();

	function gauss(x, sigma) {
		return Math.exp(-(x * x) / (2.0 * sigma * sigma));
	}
	function gaussWeights(kernelSize) {
		var sigma = (kernelSize - 1) / (2 * 3);
		var halfWidth = (kernelSize - 1) * 0.5;
		var values = new Array(kernelSize);
		var sum = 0.0;
		for (var i = 0; i < kernelSize; ++i) {
			values[i] = gauss(i - halfWidth, sigma);
			sum += values[i];
		}
		for (var _i = 0; _i < kernelSize; ++_i) {
			values[_i] /= sum;
		}
		return values;
	}
	var tempSet$1 = new Set();
	var shadowCamView = new Mat4();
	var shadowCamViewProj = new Mat4();
	var pixelOffset = new Float32Array(2);
	var blurScissorRect = new Vec4(1, 1, 0, 0);
	var viewportMatrix = new Mat4();
	var ShadowRenderer = function () {
		function ShadowRenderer(renderer, lightTextureAtlas) {
			this.shadowPassCache = [];
			this.device = renderer.device;
			this.renderer = renderer;
			this.lightTextureAtlas = lightTextureAtlas;
			var scope = this.device.scope;
			this.polygonOffsetId = scope.resolve('polygonOffset');
			this.polygonOffset = new Float32Array(2);
			this.sourceId = scope.resolve('source');
			this.pixelOffsetId = scope.resolve('pixelOffset');
			this.weightId = scope.resolve('weight[0]');
			this.blurVsmShaderCode = [shaderChunks.blurVSMPS, '#define GAUSS\n' + shaderChunks.blurVSMPS];
			var packed = '#define PACKED\n';
			this.blurPackedVsmShaderCode = [packed + this.blurVsmShaderCode[0], packed + this.blurVsmShaderCode[1]];
			this.blurVsmShader = [{}, {}];
			this.blurPackedVsmShader = [{}, {}];
			this.blurVsmWeights = {};
			this.shadowMapLightRadiusId = scope.resolve('light_radius');
			this.viewUniformFormat = null;
			this.viewBindGroupFormat = null;
			this.blendStateWrite = new BlendState();
			this.blendStateNoWrite = new BlendState();
			this.blendStateNoWrite.setColorWrite(false, false, false, false);
		}
		ShadowRenderer.createShadowCamera = function createShadowCamera(device, shadowType, type, face) {
			var shadowCam = LightCamera.create('ShadowCamera', type, face);
			if (shadowType >= SHADOW_VSM8 && shadowType <= SHADOW_VSM32) {
				shadowCam.clearColor = new Color(0, 0, 0, 0);
			} else {
				shadowCam.clearColor = new Color(1, 1, 1, 1);
			}
			shadowCam.clearDepthBuffer = true;
			shadowCam.clearStencilBuffer = false;
			return shadowCam;
		};
		ShadowRenderer.setShadowCameraSettings = function setShadowCameraSettings(shadowCam, device, shadowType, type, isClustered) {
			var hwPcf = shadowType === SHADOW_PCF5 || (shadowType === SHADOW_PCF1 || shadowType === SHADOW_PCF3) && device.supportsDepthShadow;
			if (type === LIGHTTYPE_OMNI && !isClustered) {
				hwPcf = false;
			}
			shadowCam.clearColorBuffer = !hwPcf;
		};
		var _proto = ShadowRenderer.prototype;
		_proto._cullShadowCastersInternal = function _cullShadowCastersInternal(meshInstances, visible, camera) {
			var numInstances = meshInstances.length;
			for (var i = 0; i < numInstances; i++) {
				var meshInstance = meshInstances[i];
				if (meshInstance.castShadow) {
					if (!meshInstance.cull || meshInstance._isVisible(camera)) {
						meshInstance.visibleThisFrame = true;
						visible.push(meshInstance);
					}
				}
			}
		};
		_proto.cullShadowCasters = function cullShadowCasters(comp, light, visible, camera, casters) {
			visible.length = 0;
			if (casters) {
				this._cullShadowCastersInternal(casters, visible, camera);
			} else {
				var layers = comp.layerList;
				var len = layers.length;
				for (var i = 0; i < len; i++) {
					var layer = layers[i];
					if (layer._lightsSet.has(light)) {
						if (!tempSet$1.has(layer)) {
							tempSet$1.add(layer);
							this._cullShadowCastersInternal(layer.shadowCasters, visible, camera);
						}
					}
				}
				tempSet$1.clear();
			}
			visible.sort(this.renderer.sortCompareDepth);
		};
		_proto.setupRenderState = function setupRenderState(device, light) {
			var isClustered = this.renderer.scene.clusteredLightingEnabled;
			if (device.isWebGL2 || device.isWebGPU) {
				if (light._type === LIGHTTYPE_OMNI && !isClustered) {
					device.setDepthBias(false);
				} else {
					device.setDepthBias(true);
					device.setDepthBiasValues(light.shadowBias * -1000.0, light.shadowBias * -1000.0);
				}
			} else if (device.extStandardDerivatives) {
				if (light._type === LIGHTTYPE_OMNI) {
					this.polygonOffset[0] = 0;
					this.polygonOffset[1] = 0;
					this.polygonOffsetId.setValue(this.polygonOffset);
				} else {
					this.polygonOffset[0] = light.shadowBias * -1000.0;
					this.polygonOffset[1] = light.shadowBias * -1000.0;
					this.polygonOffsetId.setValue(this.polygonOffset);
				}
			}
			var gpuOrGl2 = device.isWebGL2 || device.isWebGPU;
			var useShadowSampler = isClustered ? light._isPcf && gpuOrGl2 : light._isPcf && gpuOrGl2 && light._type !== LIGHTTYPE_OMNI;
			device.setBlendState(useShadowSampler ? this.blendStateNoWrite : this.blendStateWrite);
			device.setDepthState(DepthState.DEFAULT);
			device.setStencilState(null, null);
		};
		_proto.restoreRenderState = function restoreRenderState(device) {
			if (device.isWebGL2 || device.isWebGPU) {
				device.setDepthBias(false);
			} else if (device.extStandardDerivatives) {
				this.polygonOffset[0] = 0;
				this.polygonOffset[1] = 0;
				this.polygonOffsetId.setValue(this.polygonOffset);
			}
		};
		_proto.dispatchUniforms = function dispatchUniforms(light, shadowCam, lightRenderData, face) {
			var shadowCamNode = shadowCam._node;
			if (light._type !== LIGHTTYPE_DIRECTIONAL) {
				this.renderer.dispatchViewPos(shadowCamNode.getPosition());
				this.shadowMapLightRadiusId.setValue(light.attenuationEnd);
			}
			shadowCamView.setTRS(shadowCamNode.getPosition(), shadowCamNode.getRotation(), Vec3.ONE).invert();
			shadowCamViewProj.mul2(shadowCam.projectionMatrix, shadowCamView);
			var rectViewport = lightRenderData.shadowViewport;
			shadowCam.rect = rectViewport;
			shadowCam.scissorRect = lightRenderData.shadowScissor;
			viewportMatrix.setViewport(rectViewport.x, rectViewport.y, rectViewport.z, rectViewport.w);
			lightRenderData.shadowMatrix.mul2(viewportMatrix, shadowCamViewProj);
			if (light._type === LIGHTTYPE_DIRECTIONAL) {
				light._shadowMatrixPalette.set(lightRenderData.shadowMatrix.data, face * 16);
			}
		};
		_proto.getShadowPass = function getShadowPass(light) {
			var _this$shadowPassCache;
			var lightType = light._type;
			var shadowType = light._shadowType;
			var shadowPassInfo = (_this$shadowPassCache = this.shadowPassCache[lightType]) == null ? void 0 : _this$shadowPassCache[shadowType];
			if (!shadowPassInfo) {
				var shadowPassName = "ShadowPass_" + lightType + "_" + shadowType;
				shadowPassInfo = ShaderPass.get(this.device).allocate(shadowPassName, {
					isShadow: true,
					lightType: lightType,
					shadowType: shadowType
				});
				if (!this.shadowPassCache[lightType]) this.shadowPassCache[lightType] = [];
				this.shadowPassCache[lightType][shadowType] = shadowPassInfo;
			}
			return shadowPassInfo.index;
		};
		_proto.submitCasters = function submitCasters(visibleCasters, light) {
			var device = this.device;
			var renderer = this.renderer;
			var scene = renderer.scene;
			var passFlags = 1 << SHADER_SHADOW;
			var shadowPass = this.getShadowPass(light);
			var count = visibleCasters.length;
			for (var i = 0; i < count; i++) {
				var meshInstance = visibleCasters[i];
				var mesh = meshInstance.mesh;
				meshInstance.ensureMaterial(device);
				var material = meshInstance.material;
				renderer.setBaseConstants(device, material);
				renderer.setSkinning(device, meshInstance);
				if (material.dirty) {
					material.updateUniforms(device, scene);
					material.dirty = false;
				}
				if (material.chunks) {
					renderer.setupCullMode(true, 1, meshInstance);
					material.setParameters(device);
					meshInstance.setParameters(device, passFlags);
				}
				var shaderInstance = meshInstance.getShaderInstance(shadowPass, 0, scene, this.viewUniformFormat, this.viewBindGroupFormat);
				var shadowShader = shaderInstance.shader;
				meshInstance._key[SORTKEY_DEPTH] = shadowShader.id;
				if (!shadowShader.failed && !device.setShader(shadowShader)) ;
				renderer.setVertexBuffers(device, mesh);
				renderer.setMorphing(device, meshInstance.morphInstance);
				this.renderer.setupMeshUniformBuffers(shaderInstance, meshInstance);
				var style = meshInstance.renderStyle;
				device.setIndexBuffer(mesh.indexBuffer[style]);
				renderer.drawInstance(device, meshInstance, mesh, style);
				renderer._shadowDrawCalls++;
			}
		};
		_proto.needsShadowRendering = function needsShadowRendering(light) {
			var needs = light.enabled && light.castShadows && light.shadowUpdateMode !== SHADOWUPDATE_NONE && light.visibleThisFrame;
			if (light.shadowUpdateMode === SHADOWUPDATE_THISFRAME) {
				light.shadowUpdateMode = SHADOWUPDATE_NONE;
			}
			if (needs) {
				this.renderer._shadowMapUpdates += light.numShadowFaces;
			}
			return needs;
		};
		_proto.getLightRenderData = function getLightRenderData(light, camera, face) {
			return light.getRenderData(light._type === LIGHTTYPE_DIRECTIONAL ? camera : null, face);
		};
		_proto.setupRenderPass = function setupRenderPass(renderPass, shadowCamera, clearRenderTarget) {
			var rt = shadowCamera.renderTarget;
			renderPass.init(rt);
			renderPass.depthStencilOps.clearDepthValue = 1;
			renderPass.depthStencilOps.clearDepth = clearRenderTarget;
			if (rt.depthBuffer) {
				renderPass.depthStencilOps.storeDepth = true;
			} else {
				renderPass.colorOps.clearValue.copy(shadowCamera.clearColor);
				renderPass.colorOps.clear = clearRenderTarget;
				renderPass.depthStencilOps.storeDepth = false;
			}
			renderPass.requiresCubemaps = false;
		};
		_proto.prepareFace = function prepareFace(light, camera, face) {
			var type = light._type;
			var shadowType = light._shadowType;
			var isClustered = this.renderer.scene.clusteredLightingEnabled;
			var lightRenderData = this.getLightRenderData(light, camera, face);
			var shadowCam = lightRenderData.shadowCamera;
			ShadowRenderer.setShadowCameraSettings(shadowCam, this.device, shadowType, type, isClustered);
			var renderTargetIndex = type === LIGHTTYPE_DIRECTIONAL ? 0 : face;
			shadowCam.renderTarget = light._shadowMap.renderTargets[renderTargetIndex];
			return shadowCam;
		};
		_proto.renderFace = function renderFace(light, camera, face, clear, insideRenderPass) {
			if (insideRenderPass === void 0) {
				insideRenderPass = true;
			}
			var device = this.device;
			var lightRenderData = this.getLightRenderData(light, camera, face);
			var shadowCam = lightRenderData.shadowCamera;
			this.dispatchUniforms(light, shadowCam, lightRenderData, face);
			var rt = shadowCam.renderTarget;
			var renderer = this.renderer;
			renderer.setCameraUniforms(shadowCam, rt);
			if (device.supportsUniformBuffers) {
				renderer.setupViewUniformBuffers(lightRenderData.viewBindGroups, this.viewUniformFormat, this.viewBindGroupFormat, 1);
			}
			if (insideRenderPass) {
				renderer.setupViewport(shadowCam, rt);
				if (clear) {
					renderer.clear(shadowCam);
				}
			} else {
				renderer.clearView(shadowCam, rt, true, false);
			}
			this.setupRenderState(device, light);
			this.submitCasters(lightRenderData.visibleCasters, light);
			this.restoreRenderState(device);
		};
		_proto.render = function render(light, camera, insideRenderPass) {
			if (insideRenderPass === void 0) {
				insideRenderPass = true;
			}
			if (this.needsShadowRendering(light)) {
				var faceCount = light.numShadowFaces;
				for (var face = 0; face < faceCount; face++) {
					this.prepareFace(light, camera, face);
					this.renderFace(light, camera, face, true, insideRenderPass);
				}
				this.renderVsm(light, camera);
			}
		};
		_proto.renderVsm = function renderVsm(light, camera) {
			if (light._isVsm && light._vsmBlurSize > 1) {
				var isClustered = this.renderer.scene.clusteredLightingEnabled;
				if (!isClustered || light._type === LIGHTTYPE_DIRECTIONAL) {
					this.applyVsmBlur(light, camera);
				}
			}
		};
		_proto.getVsmBlurShader = function getVsmBlurShader(isVsm8, blurMode, filterSize) {
			var blurShader = (isVsm8 ? this.blurPackedVsmShader : this.blurVsmShader)[blurMode][filterSize];
			if (!blurShader) {
				this.blurVsmWeights[filterSize] = gaussWeights(filterSize);
				var blurVS = shaderChunks.fullscreenQuadVS;
				var blurFS = '#define SAMPLES ' + filterSize + '\n';
				if (isVsm8) {
					blurFS += this.blurPackedVsmShaderCode[blurMode];
				} else {
					blurFS += this.blurVsmShaderCode[blurMode];
				}
				var blurShaderName = 'blurVsm' + blurMode + '' + filterSize + '' + isVsm8;
				blurShader = createShaderFromCode(this.device, blurVS, blurFS, blurShaderName);
				if (isVsm8) {
					this.blurPackedVsmShader[blurMode][filterSize] = blurShader;
				} else {
					this.blurVsmShader[blurMode][filterSize] = blurShader;
				}
			}
			return blurShader;
		};
		_proto.applyVsmBlur = function applyVsmBlur(light, camera) {
			var device = this.device;
			device.setBlendState(BlendState.NOBLEND);
			var lightRenderData = light.getRenderData(light._type === LIGHTTYPE_DIRECTIONAL ? camera : null, 0);
			var shadowCam = lightRenderData.shadowCamera;
			var origShadowMap = shadowCam.renderTarget;
			var tempShadowMap = this.renderer.shadowMapCache.get(device, light);
			var tempRt = tempShadowMap.renderTargets[0];
			var isVsm8 = light._shadowType === SHADOW_VSM8;
			var blurMode = light.vsmBlurMode;
			var filterSize = light._vsmBlurSize;
			var blurShader = this.getVsmBlurShader(isVsm8, blurMode, filterSize);
			blurScissorRect.z = light._shadowResolution - 2;
			blurScissorRect.w = blurScissorRect.z;
			this.sourceId.setValue(origShadowMap.colorBuffer);
			pixelOffset[0] = 1 / light._shadowResolution;
			pixelOffset[1] = 0;
			this.pixelOffsetId.setValue(pixelOffset);
			if (blurMode === BLUR_GAUSSIAN) this.weightId.setValue(this.blurVsmWeights[filterSize]);
			drawQuadWithShader(device, tempRt, blurShader, null, blurScissorRect);
			this.sourceId.setValue(tempRt.colorBuffer);
			pixelOffset[1] = pixelOffset[0];
			pixelOffset[0] = 0;
			this.pixelOffsetId.setValue(pixelOffset);
			drawQuadWithShader(device, origShadowMap, blurShader, null, blurScissorRect);
			this.renderer.shadowMapCache.add(light, tempShadowMap);
		};
		_proto.initViewBindGroupFormat = function initViewBindGroupFormat() {
			if (this.device.supportsUniformBuffers && !this.viewUniformFormat) {
				this.viewUniformFormat = new UniformBufferFormat(this.device, [new UniformFormat("matrix_viewProjection", UNIFORMTYPE_MAT4)]);
				this.viewBindGroupFormat = new BindGroupFormat(this.device, [new BindBufferFormat(UNIFORM_BUFFER_DEFAULT_SLOT_NAME, SHADERSTAGE_VERTEX | SHADERSTAGE_FRAGMENT)], []);
			}
		};
		_proto.frameUpdate = function frameUpdate() {
			this.initViewBindGroupFormat();
		};
		return ShadowRenderer;
	}();

	var tempClusterArray = [];
	var WorldClustersAllocator = function () {
		function WorldClustersAllocator(graphicsDevice) {
			this._empty = null;
			this._allocated = [];
			this._clusters = new Map();
			this.device = graphicsDevice;
		}
		var _proto = WorldClustersAllocator.prototype;
		_proto.destroy = function destroy() {
			if (this._empty) {
				this._empty.destroy();
				this._empty = null;
			}
			this._allocated.forEach(function (cluster) {
				cluster.destroy();
			});
			this._allocated.length = 0;
		};
		_proto.assign = function assign(renderPasses) {
			var empty = this.empty;
			tempClusterArray.push.apply(tempClusterArray, this._allocated);
			this._allocated.length = 0;
			this._clusters.clear();
			var passCount = renderPasses.length;
			for (var p = 0; p < passCount; p++) {
				var renderPass = renderPasses[p];
				var renderActions = renderPass.renderActions;
				if (renderActions) {
					var count = renderActions.length;
					for (var i = 0; i < count; i++) {
						var ra = renderActions[i];
						ra.lightClusters = null;
						var layer = ra.layer;
						if (layer.hasClusteredLights && layer.meshInstances.length) {
							var hash = layer.getLightIdHash();
							var existingRenderAction = this._clusters.get(hash);
							var clusters = existingRenderAction == null ? void 0 : existingRenderAction.lightClusters;
							if (!clusters) {
								var _tempClusterArray$pop;
								clusters = (_tempClusterArray$pop = tempClusterArray.pop()) != null ? _tempClusterArray$pop : new WorldClusters(this.device);
								this._allocated.push(clusters);
								this._clusters.set(hash, ra);
							}
							ra.lightClusters = clusters;
						}
						if (!ra.lightClusters) {
							ra.lightClusters = empty;
						}
					}
				}
			}
			tempClusterArray.forEach(function (item) {
				return item.destroy();
			});
			tempClusterArray.length = 0;
		};
		_proto.update = function update(renderPasses, gammaCorrection, lighting) {
			this.assign(renderPasses);
			this._clusters.forEach(function (renderAction) {
				var layer = renderAction.layer;
				var cluster = renderAction.lightClusters;
				cluster.update(layer.clusteredLightsSet, gammaCorrection, lighting);
			});
		};
		_createClass(WorldClustersAllocator, [{
			key: "count",
			get: function get() {
				return this._allocated.length;
			}
		}, {
			key: "empty",
			get: function get() {
				if (!this._empty) {
					var empty = new WorldClusters(this.device);
					empty.name = 'ClusterEmpty';
					empty.update([], false, null);
					this._empty = empty;
				}
				return this._empty;
			}
		}]);
		return WorldClustersAllocator;
	}();

	var textureBlitVertexShader = "\n\tattribute vec2 vertex_position;\n\tvarying vec2 uv0;\n\tvoid main(void) {\n\t\tgl_Position = vec4(vertex_position, 0.5, 1.0);\n\t\tuv0 = vertex_position.xy * 0.5 + 0.5;\n\t\t#ifndef WEBGPU\n\t\t\tuv0.y = 1.0 - uv0.y;\n\t\t#endif\n\t}";
	var textureBlitFragmentShader = "\n\tvarying vec2 uv0;\n\tuniform sampler2D blitTexture;\n\tvoid main(void) {\n\t\tgl_FragColor = texture2D(blitTexture, uv0);\n\t}";
	var textureCubeBlitFragmentShader = "\n\tvarying vec2 uv0;\n\tuniform samplerCube blitTexture;\n\tuniform mat4 invViewProj;\n\tvoid main(void) {\n\t\tvec4 projPos = vec4(uv0 * 2.0 - 1.0, 0.5, 1.0);\n\t\tvec4 worldPos = invViewProj * projPos;\n\t\tgl_FragColor = textureCube(blitTexture, worldPos.xyz);\n\t}";
	var _viewport$2 = new Vec4();
	var _invViewProjMatrices = [];
	var RenderPassCookieRenderer = function (_RenderPass) {
		_inheritsLoose(RenderPassCookieRenderer, _RenderPass);
		function RenderPassCookieRenderer(device, cubeSlotsOffsets) {
			var _this;
			_this = _RenderPass.call(this, device) || this;
			_this._quadRenderer2D = null;
			_this._quadRendererCube = null;
			_this._filteredLights = [];
			_this._cubeSlotsOffsets = cubeSlotsOffsets;
			_this.requiresCubemaps = false;
			_this.blitTextureId = device.scope.resolve('blitTexture');
			_this.invViewProjId = device.scope.resolve('invViewProj');
			return _this;
		}
		var _proto = RenderPassCookieRenderer.prototype;
		_proto.destroy = function destroy() {
			var _this$_quadRenderer2D, _this$_quadRendererCu;
			(_this$_quadRenderer2D = this._quadRenderer2D) == null || _this$_quadRenderer2D.destroy();
			this._quadRenderer2D = null;
			(_this$_quadRendererCu = this._quadRendererCube) == null || _this$_quadRendererCu.destroy();
			this._quadRendererCube = null;
		};
		RenderPassCookieRenderer.create = function create(renderTarget, cubeSlotsOffsets) {
			var renderPass = new RenderPassCookieRenderer(renderTarget.device, cubeSlotsOffsets);
			renderPass.init(renderTarget);
			renderPass.colorOps.clear = false;
			renderPass.depthStencilOps.clearDepth = false;
			return renderPass;
		};
		_proto.update = function update(lights) {
			var filteredLights = this._filteredLights;
			this.filter(lights, filteredLights);
			this.executeEnabled = filteredLights.length > 0;
		};
		_proto.filter = function filter(lights, filteredLights) {
			for (var i = 0; i < lights.length; i++) {
				var light = lights[i];
				if (light._type === LIGHTTYPE_DIRECTIONAL) continue;
				if (!light.atlasViewportAllocated) continue;
				if (!light.atlasSlotUpdated) continue;
				if (light.enabled && light.cookie && light.visibleThisFrame) {
					filteredLights.push(light);
				}
			}
		};
		_proto.initInvViewProjMatrices = function initInvViewProjMatrices() {
			if (!_invViewProjMatrices.length) {
				for (var face = 0; face < 6; face++) {
					var camera = LightCamera.create(null, LIGHTTYPE_OMNI, face);
					var projMat = camera.projectionMatrix;
					var viewMat = camera.node.getLocalTransform().clone().invert();
					_invViewProjMatrices[face] = new Mat4().mul2(projMat, viewMat).invert();
				}
			}
		};
		_proto.execute = function execute() {
			var device = this.device;
			device.setBlendState(BlendState.NOBLEND);
			device.setCullMode(CULLFACE_NONE);
			device.setDepthState(DepthState.NODEPTH);
			device.setStencilState();
			var renderTargetWidth = this.renderTarget.colorBuffer.width;
			var cubeSlotsOffsets = this._cubeSlotsOffsets;
			var filteredLights = this._filteredLights;
			for (var i = 0; i < filteredLights.length; i++) {
				var light = filteredLights[i];
				var faceCount = light.numShadowFaces;
				var quad = faceCount > 1 ? this.quadRendererCube : this.quadRenderer2D;
				if (faceCount > 1) {
					this.initInvViewProjMatrices();
				}
				this.blitTextureId.setValue(light.cookie);
				for (var face = 0; face < faceCount; face++) {
					_viewport$2.copy(light.atlasViewport);
					if (faceCount > 1) {
						var smallSize = _viewport$2.z / 3;
						var offset = cubeSlotsOffsets[face];
						_viewport$2.x += smallSize * offset.x;
						_viewport$2.y += smallSize * offset.y;
						_viewport$2.z = smallSize;
						_viewport$2.w = smallSize;
						this.invViewProjId.setValue(_invViewProjMatrices[face].data);
					}
					_viewport$2.mulScalar(renderTargetWidth);
					quad.render(_viewport$2);
				}
			}
			filteredLights.length = 0;
		};
		_createClass(RenderPassCookieRenderer, [{
			key: "quadRenderer2D",
			get: function get() {
				if (!this._quadRenderer2D) {
					var shader = createShaderFromCode(this.device, textureBlitVertexShader, textureBlitFragmentShader, "cookieRenderer2d");
					this._quadRenderer2D = new QuadRender(shader);
				}
				return this._quadRenderer2D;
			}
		}, {
			key: "quadRendererCube",
			get: function get() {
				if (!this._quadRendererCube) {
					var shader = createShaderFromCode(this.device, textureBlitVertexShader, textureCubeBlitFragmentShader, "cookieRendererCube");
					this._quadRendererCube = new QuadRender(shader);
				}
				return this._quadRendererCube;
			}
		}]);
		return RenderPassCookieRenderer;
	}(RenderPass);

	var RenderPassShadowLocalClustered = function (_RenderPass) {
		_inheritsLoose(RenderPassShadowLocalClustered, _RenderPass);
		function RenderPassShadowLocalClustered(device, shadowRenderer, shadowRendererLocal) {
			var _this;
			_this = _RenderPass.call(this, device) || this;
			_this.requiresCubemaps = false;
			_this.shadowRenderer = shadowRenderer;
			_this.shadowRendererLocal = shadowRendererLocal;
			return _this;
		}
		var _proto = RenderPassShadowLocalClustered.prototype;
		_proto.update = function update(localLights) {
			var shadowLights = this.shadowRendererLocal.shadowLights;
			var shadowCamera = this.shadowRendererLocal.prepareLights(shadowLights, localLights);
			var count = shadowLights.length;
			this.enabled = count > 0;
			if (count) {
				this.shadowRenderer.setupRenderPass(this, shadowCamera, false);
			}
		};
		_proto.execute = function execute() {
			var shadowLights = this.shadowRendererLocal.shadowLights;
			var count = shadowLights.length;
			for (var i = 0; i < count; i++) {
				var light = shadowLights[i];
				for (var face = 0; face < light.numShadowFaces; face++) {
					this.shadowRenderer.renderFace(light, null, face, true);
				}
			}
			shadowLights.length = 0;
		};
		return RenderPassShadowLocalClustered;
	}(RenderPass);

	var RenderPassUpdateClustered = function (_RenderPass) {
		_inheritsLoose(RenderPassUpdateClustered, _RenderPass);
		function RenderPassUpdateClustered(device, renderer, shadowRenderer, shadowRendererLocal, lightTextureAtlas) {
			var _this;
			_this = _RenderPass.call(this, device) || this;
			_this.renderer = renderer;
			_this.frameGraph = null;
			_this.cookiesRenderPass = RenderPassCookieRenderer.create(lightTextureAtlas.cookieRenderTarget, lightTextureAtlas.cubeSlotsOffsets);
			_this.beforePasses.push(_this.cookiesRenderPass);
			_this.shadowRenderPass = new RenderPassShadowLocalClustered(device, shadowRenderer, shadowRendererLocal);
			_this.beforePasses.push(_this.shadowRenderPass);
			return _this;
		}
		var _proto = RenderPassUpdateClustered.prototype;
		_proto.update = function update(frameGraph, shadowsEnabled, cookiesEnabled, lights, localLights) {
			this.frameGraph = frameGraph;
			this.cookiesRenderPass.enabled = cookiesEnabled;
			if (cookiesEnabled) {
				this.cookiesRenderPass.update(lights);
			}
			this.shadowRenderPass.enabled = shadowsEnabled;
			if (shadowsEnabled) {
				this.shadowRenderPass.update(localLights);
			}
		};
		_proto.destroy = function destroy() {
			this.cookiesRenderPass.destroy();
			this.cookiesRenderPass = null;
		};
		_proto.execute = function execute() {
			var renderer = this.renderer;
			var scene = renderer.scene;
			renderer.worldClustersAllocator.update(this.frameGraph.renderPasses, scene.gammaCorrection, scene.lighting);
		};
		return RenderPassUpdateClustered;
	}(RenderPass);

	var _skinUpdateIndex = 0;
	var boneTextureSize = [0, 0, 0, 0];
	var viewProjMat = new Mat4();
	var viewInvMat = new Mat4();
	var viewMat = new Mat4();
	var viewMat3 = new Mat3();
	var tempSphere$1 = new BoundingSphere();
	var _flipYMat = new Mat4().setScale(1, -1, 1);
	var _tempLightSet = new Set();
	var _tempLayerSet = new Set();
	var _fixProjRangeMat = new Mat4().set([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0.5, 0, 0, 0, 0.5, 1]);
	var _tempProjMat0 = new Mat4();
	var _tempProjMat1 = new Mat4();
	var _tempProjMat2 = new Mat4();
	var _tempProjMat3 = new Mat4();
	var _tempSet = new Set();
	var _tempMeshInstances = [];
	var _tempMeshInstancesSkinned = [];
	var Renderer = function () {
		function Renderer(graphicsDevice) {
			this.clustersDebugRendered = false;
			this.processingMeshInstances = new Set();
			this.worldClustersAllocator = void 0;
			this.lights = [];
			this.localLights = [];
			this.device = graphicsDevice;
			this.scene = null;
			this.worldClustersAllocator = new WorldClustersAllocator(graphicsDevice);
			this.lightTextureAtlas = new LightTextureAtlas(graphicsDevice);
			this.shadowMapCache = new ShadowMapCache();
			this.shadowRenderer = new ShadowRenderer(this, this.lightTextureAtlas);
			this._shadowRendererLocal = new ShadowRendererLocal(this, this.shadowRenderer);
			this._shadowRendererDirectional = new ShadowRendererDirectional(this, this.shadowRenderer);
			this._renderPassUpdateClustered = new RenderPassUpdateClustered(this.device, this, this.shadowRenderer, this._shadowRendererLocal, this.lightTextureAtlas);
			this.viewUniformFormat = null;
			this.viewBindGroupFormat = null;
			this._skinTime = 0;
			this._morphTime = 0;
			this._cullTime = 0;
			this._shadowMapTime = 0;
			this._lightClustersTime = 0;
			this._layerCompositionUpdateTime = 0;
			this._shadowDrawCalls = 0;
			this._skinDrawCalls = 0;
			this._instancedDrawCalls = 0;
			this._shadowMapUpdates = 0;
			this._numDrawCallsCulled = 0;
			this._camerasRendered = 0;
			this._lightClusters = 0;
			var scope = graphicsDevice.scope;
			this.boneTextureId = scope.resolve('texture_poseMap');
			this.boneTextureSizeId = scope.resolve('texture_poseMapSize');
			this.poseMatrixId = scope.resolve('matrix_pose[0]');
			this.modelMatrixId = scope.resolve('matrix_model');
			this.normalMatrixId = scope.resolve('matrix_normal');
			this.viewInvId = scope.resolve('matrix_viewInverse');
			this.viewPos = new Float32Array(3);
			this.viewPosId = scope.resolve('view_position');
			this.projId = scope.resolve('matrix_projection');
			this.projSkyboxId = scope.resolve('matrix_projectionSkybox');
			this.viewId = scope.resolve('matrix_view');
			this.viewId3 = scope.resolve('matrix_view3');
			this.viewProjId = scope.resolve('matrix_viewProjection');
			this.flipYId = scope.resolve('projectionFlipY');
			this.tbnBasis = scope.resolve('tbnBasis');
			this.nearClipId = scope.resolve('camera_near');
			this.farClipId = scope.resolve('camera_far');
			this.cameraParams = new Float32Array(4);
			this.cameraParamsId = scope.resolve('camera_params');
			this.alphaTestId = scope.resolve('alpha_ref');
			this.opacityMapId = scope.resolve('texture_opacityMap');
			this.exposureId = scope.resolve('exposure');
			this.twoSidedLightingNegScaleFactorId = scope.resolve('twoSidedLightingNegScaleFactor');
			this.twoSidedLightingNegScaleFactorId.setValue(0);
			this.morphWeightsA = scope.resolve('morph_weights_a');
			this.morphWeightsB = scope.resolve('morph_weights_b');
			this.morphPositionTex = scope.resolve('morphPositionTex');
			this.morphNormalTex = scope.resolve('morphNormalTex');
			this.morphTexParams = scope.resolve('morph_tex_params');
			this.lightCube = new LightCube();
			this.constantLightCube = scope.resolve('lightCube[0]');
		}
		var _proto = Renderer.prototype;
		_proto.destroy = function destroy() {
			this.shadowRenderer = null;
			this._shadowRendererLocal = null;
			this._shadowRendererDirectional = null;
			this.shadowMapCache.destroy();
			this.shadowMapCache = null;
			this._renderPassUpdateClustered.destroy();
			this._renderPassUpdateClustered = null;
			this.lightTextureAtlas.destroy();
			this.lightTextureAtlas = null;
		};
		_proto.sortCompare = function sortCompare(drawCallA, drawCallB) {
			if (drawCallA.layer === drawCallB.layer) {
				if (drawCallA.drawOrder && drawCallB.drawOrder) {
					return drawCallA.drawOrder - drawCallB.drawOrder;
				} else if (drawCallA.zdist && drawCallB.zdist) {
					return drawCallB.zdist - drawCallA.zdist;
				} else if (drawCallA.zdist2 && drawCallB.zdist2) {
					return drawCallA.zdist2 - drawCallB.zdist2;
				}
			}
			return drawCallB._key[SORTKEY_FORWARD] - drawCallA._key[SORTKEY_FORWARD];
		};
		_proto.sortCompareMesh = function sortCompareMesh(drawCallA, drawCallB) {
			if (drawCallA.layer === drawCallB.layer) {
				if (drawCallA.drawOrder && drawCallB.drawOrder) {
					return drawCallA.drawOrder - drawCallB.drawOrder;
				} else if (drawCallA.zdist && drawCallB.zdist) {
					return drawCallB.zdist - drawCallA.zdist;
				}
			}
			var keyA = drawCallA._key[SORTKEY_FORWARD];
			var keyB = drawCallB._key[SORTKEY_FORWARD];
			if (keyA === keyB && drawCallA.mesh && drawCallB.mesh) {
				return drawCallB.mesh.id - drawCallA.mesh.id;
			}
			return keyB - keyA;
		};
		_proto.sortCompareDepth = function sortCompareDepth(drawCallA, drawCallB) {
			var keyA = drawCallA._key[SORTKEY_DEPTH];
			var keyB = drawCallB._key[SORTKEY_DEPTH];
			if (keyA === keyB && drawCallA.mesh && drawCallB.mesh) {
				return drawCallB.mesh.id - drawCallA.mesh.id;
			}
			return keyB - keyA;
		};
		_proto.setupViewport = function setupViewport(camera, renderTarget) {
			var device = this.device;
			var pixelWidth = renderTarget ? renderTarget.width : device.width;
			var pixelHeight = renderTarget ? renderTarget.height : device.height;
			var rect = camera.rect;
			var x = Math.floor(rect.x * pixelWidth);
			var y = Math.floor(rect.y * pixelHeight);
			var w = Math.floor(rect.z * pixelWidth);
			var h = Math.floor(rect.w * pixelHeight);
			device.setViewport(x, y, w, h);
			if (camera._scissorRectClear) {
				var scissorRect = camera.scissorRect;
				x = Math.floor(scissorRect.x * pixelWidth);
				y = Math.floor(scissorRect.y * pixelHeight);
				w = Math.floor(scissorRect.z * pixelWidth);
				h = Math.floor(scissorRect.w * pixelHeight);
			}
			device.setScissor(x, y, w, h);
		};
		_proto.setCameraUniforms = function setCameraUniforms(camera, target) {
			var flipY = target == null ? void 0 : target.flipY;
			var viewCount = 1;
			if (camera.xr && camera.xr.session) {
				var transform;
				var parent = camera._node.parent;
				if (parent) transform = parent.getWorldTransform();
				var views = camera.xr.views;
				viewCount = views.length;
				for (var v = 0; v < viewCount; v++) {
					var view = views[v];
					if (parent) {
						view.viewInvOffMat.mul2(transform, view.viewInvMat);
						view.viewOffMat.copy(view.viewInvOffMat).invert();
					} else {
						view.viewInvOffMat.copy(view.viewInvMat);
						view.viewOffMat.copy(view.viewMat);
					}
					view.viewMat3.setFromMat4(view.viewOffMat);
					view.projViewOffMat.mul2(view.projMat, view.viewOffMat);
					view.position[0] = view.viewInvOffMat.data[12];
					view.position[1] = view.viewInvOffMat.data[13];
					view.position[2] = view.viewInvOffMat.data[14];
					camera.frustum.setFromMat4(view.projViewOffMat);
				}
			} else {
				var projMat = camera.projectionMatrix;
				if (camera.calculateProjection) {
					camera.calculateProjection(projMat, VIEW_CENTER);
				}
				var projMatSkybox = camera.getProjectionMatrixSkybox();
				if (flipY) {
					projMat = _tempProjMat0.mul2(_flipYMat, projMat);
					projMatSkybox = _tempProjMat1.mul2(_flipYMat, projMatSkybox);
				}
				if (this.device.isWebGPU) {
					projMat = _tempProjMat2.mul2(_fixProjRangeMat, projMat);
					projMatSkybox = _tempProjMat3.mul2(_fixProjRangeMat, projMatSkybox);
				}
				this.projId.setValue(projMat.data);
				this.projSkyboxId.setValue(projMatSkybox.data);
				if (camera.calculateTransform) {
					camera.calculateTransform(viewInvMat, VIEW_CENTER);
				} else {
					var pos = camera._node.getPosition();
					var rot = camera._node.getRotation();
					viewInvMat.setTRS(pos, rot, Vec3.ONE);
				}
				this.viewInvId.setValue(viewInvMat.data);
				viewMat.copy(viewInvMat).invert();
				this.viewId.setValue(viewMat.data);
				viewMat3.setFromMat4(viewMat);
				this.viewId3.setValue(viewMat3.data);
				viewProjMat.mul2(projMat, viewMat);
				this.viewProjId.setValue(viewProjMat.data);
				this.flipYId.setValue(flipY ? -1 : 1);
				this.dispatchViewPos(camera._node.getPosition());
				camera.frustum.setFromMat4(viewProjMat);
			}
			this.tbnBasis.setValue(flipY ? -1 : 1);
			var n = camera._nearClip;
			var f = camera._farClip;
			this.nearClipId.setValue(n);
			this.farClipId.setValue(f);
			this.cameraParams[0] = 1 / f;
			this.cameraParams[1] = f;
			this.cameraParams[2] = n;
			this.cameraParams[3] = camera.projection === PROJECTION_ORTHOGRAPHIC ? 1 : 0;
			this.cameraParamsId.setValue(this.cameraParams);
			this.exposureId.setValue(this.scene.physicalUnits ? camera.getExposure() : this.scene.exposure);
			return viewCount;
		};
		_proto.clear = function clear(camera, clearColor, clearDepth, clearStencil) {
			var flags = ((clearColor != null ? clearColor : camera._clearColorBuffer) ? CLEARFLAG_COLOR : 0) | ((clearDepth != null ? clearDepth : camera._clearDepthBuffer) ? CLEARFLAG_DEPTH : 0) | ((clearStencil != null ? clearStencil : camera._clearStencilBuffer) ? CLEARFLAG_STENCIL : 0);
			if (flags) {
				var device = this.device;
				device.clear({
					color: [camera._clearColor.r, camera._clearColor.g, camera._clearColor.b, camera._clearColor.a],
					depth: camera._clearDepth,
					stencil: camera._clearStencil,
					flags: flags
				});
			}
		};
		_proto.setCamera = function setCamera(camera, target, clear, renderAction) {
			this.setCameraUniforms(camera, target);
			this.clearView(camera, target, clear, false);
		};
		_proto.clearView = function clearView(camera, target, clear, forceWrite) {
			var device = this.device;
			device.setRenderTarget(target);
			device.updateBegin();
			if (forceWrite) {
				device.setColorWrite(true, true, true, true);
				device.setDepthWrite(true);
			}
			this.setupViewport(camera, target);
			if (clear) {
				var options = camera._clearOptions;
				device.clear(options ? options : {
					color: [camera._clearColor.r, camera._clearColor.g, camera._clearColor.b, camera._clearColor.a],
					depth: camera._clearDepth,
					flags: (camera._clearColorBuffer ? CLEARFLAG_COLOR : 0) | (camera._clearDepthBuffer ? CLEARFLAG_DEPTH : 0) | (camera._clearStencilBuffer ? CLEARFLAG_STENCIL : 0),
					stencil: camera._clearStencil
				});
			}
		};
		_proto.setupCullMode = function setupCullMode(cullFaces, flipFactor, drawCall) {
			var material = drawCall.material;
			var mode = CULLFACE_NONE;
			if (cullFaces) {
				var flipFaces = 1;
				if (material.cull === CULLFACE_FRONT || material.cull === CULLFACE_BACK) {
					flipFaces = flipFactor * drawCall.flipFacesFactor * drawCall.node.worldScaleSign;
				}
				if (flipFaces < 0) {
					mode = material.cull === CULLFACE_FRONT ? CULLFACE_BACK : CULLFACE_FRONT;
				} else {
					mode = material.cull;
				}
			}
			this.device.setCullMode(mode);
			if (mode === CULLFACE_NONE && material.cull === CULLFACE_NONE) {
				this.twoSidedLightingNegScaleFactorId.setValue(drawCall.node.worldScaleSign);
			}
		};
		_proto.updateCameraFrustum = function updateCameraFrustum(camera) {
			if (camera.xr && camera.xr.views.length) {
				var view = camera.xr.views[0];
				viewProjMat.mul2(view.projMat, view.viewOffMat);
				camera.frustum.setFromMat4(viewProjMat);
				return;
			}
			var projMat = camera.projectionMatrix;
			if (camera.calculateProjection) {
				camera.calculateProjection(projMat, VIEW_CENTER);
			}
			if (camera.calculateTransform) {
				camera.calculateTransform(viewInvMat, VIEW_CENTER);
			} else {
				var pos = camera._node.getPosition();
				var rot = camera._node.getRotation();
				viewInvMat.setTRS(pos, rot, Vec3.ONE);
				this.viewInvId.setValue(viewInvMat.data);
			}
			viewMat.copy(viewInvMat).invert();
			viewProjMat.mul2(projMat, viewMat);
			camera.frustum.setFromMat4(viewProjMat);
		};
		_proto.setBaseConstants = function setBaseConstants(device, material) {
			device.setCullMode(material.cull);
			if (material.opacityMap) {
				this.opacityMapId.setValue(material.opacityMap);
			}
			if (material.opacityMap || material.alphaTest > 0) {
				this.alphaTestId.setValue(material.alphaTest);
			}
		};
		_proto.updateCpuSkinMatrices = function updateCpuSkinMatrices(drawCalls) {
			_skinUpdateIndex++;
			var drawCallsCount = drawCalls.length;
			if (drawCallsCount === 0) return;
			for (var i = 0; i < drawCallsCount; i++) {
				var si = drawCalls[i].skinInstance;
				if (si) {
					si.updateMatrices(drawCalls[i].node, _skinUpdateIndex);
					si._dirty = true;
				}
			}
		};
		_proto.updateGpuSkinMatrices = function updateGpuSkinMatrices(drawCalls) {
			for (var _iterator = _createForOfIteratorHelperLoose(drawCalls), _step; !(_step = _iterator()).done;) {
				var drawCall = _step.value;
				var skin = drawCall.skinInstance;
				if (skin && skin._dirty) {
					skin.updateMatrixPalette(drawCall.node, _skinUpdateIndex);
					skin._dirty = false;
				}
			}
		};
		_proto.updateMorphing = function updateMorphing(drawCalls) {
			for (var _iterator2 = _createForOfIteratorHelperLoose(drawCalls), _step2; !(_step2 = _iterator2()).done;) {
				var drawCall = _step2.value;
				var morphInst = drawCall.morphInstance;
				if (morphInst && morphInst._dirty) {
					morphInst.update();
				}
			}
		};
		_proto.gpuUpdate = function gpuUpdate(drawCalls) {
			this.updateGpuSkinMatrices(drawCalls);
			this.updateMorphing(drawCalls);
		};
		_proto.setVertexBuffers = function setVertexBuffers(device, mesh) {
			device.setVertexBuffer(mesh.vertexBuffer);
		};
		_proto.setMorphing = function setMorphing(device, morphInstance) {
			if (morphInstance) {
				if (morphInstance.morph.useTextureMorph) {
					device.setVertexBuffer(morphInstance.morph.vertexBufferIds);
					this.morphPositionTex.setValue(morphInstance.texturePositions);
					this.morphNormalTex.setValue(morphInstance.textureNormals);
					this.morphTexParams.setValue(morphInstance._textureParams);
				} else {
					for (var t = 0; t < morphInstance._activeVertexBuffers.length; t++) {
						var vb = morphInstance._activeVertexBuffers[t];
						if (vb) {
							var semantic = SEMANTIC_ATTR + (t + 8);
							vb.format.elements[0].name = semantic;
							vb.format.elements[0].scopeId = device.scope.resolve(semantic);
							vb.format.update();
							device.setVertexBuffer(vb);
						}
					}
					this.morphWeightsA.setValue(morphInstance._shaderMorphWeightsA);
					this.morphWeightsB.setValue(morphInstance._shaderMorphWeightsB);
				}
			}
		};
		_proto.setSkinning = function setSkinning(device, meshInstance) {
			if (meshInstance.skinInstance) {
				this._skinDrawCalls++;
				if (device.supportsBoneTextures) {
					var boneTexture = meshInstance.skinInstance.boneTexture;
					this.boneTextureId.setValue(boneTexture);
					boneTextureSize[0] = boneTexture.width;
					boneTextureSize[1] = boneTexture.height;
					boneTextureSize[2] = 1.0 / boneTexture.width;
					boneTextureSize[3] = 1.0 / boneTexture.height;
					this.boneTextureSizeId.setValue(boneTextureSize);
				} else {
					this.poseMatrixId.setValue(meshInstance.skinInstance.matrixPalette);
				}
			}
		};
		_proto.dispatchViewPos = function dispatchViewPos(position) {
			var vp = this.viewPos;
			vp[0] = position.x;
			vp[1] = position.y;
			vp[2] = position.z;
			this.viewPosId.setValue(vp);
		};
		_proto.initViewBindGroupFormat = function initViewBindGroupFormat(isClustered) {
			if (this.device.supportsUniformBuffers && !this.viewUniformFormat) {
				var uniforms = [new UniformFormat("matrix_viewProjection", UNIFORMTYPE_MAT4), new UniformFormat("cubeMapRotationMatrix", UNIFORMTYPE_MAT3), new UniformFormat("view_position", UNIFORMTYPE_VEC3), new UniformFormat("skyboxIntensity", UNIFORMTYPE_FLOAT), new UniformFormat("exposure", UNIFORMTYPE_FLOAT), new UniformFormat("textureBias", UNIFORMTYPE_FLOAT)];
				if (isClustered) {
					uniforms.push.apply(uniforms, [new UniformFormat("clusterCellsCountByBoundsSize", UNIFORMTYPE_VEC3), new UniformFormat("clusterTextureSize", UNIFORMTYPE_VEC3), new UniformFormat("clusterBoundsMin", UNIFORMTYPE_VEC3), new UniformFormat("clusterBoundsDelta", UNIFORMTYPE_VEC3), new UniformFormat("clusterCellsDot", UNIFORMTYPE_VEC3), new UniformFormat("clusterCellsMax", UNIFORMTYPE_VEC3), new UniformFormat("clusterCompressionLimit0", UNIFORMTYPE_VEC2), new UniformFormat("shadowAtlasParams", UNIFORMTYPE_VEC2), new UniformFormat("clusterMaxCells", UNIFORMTYPE_INT), new UniformFormat("clusterSkip", UNIFORMTYPE_FLOAT)]);
				}
				this.viewUniformFormat = new UniformBufferFormat(this.device, uniforms);
				var buffers = [new BindBufferFormat(UNIFORM_BUFFER_DEFAULT_SLOT_NAME, SHADERSTAGE_VERTEX | SHADERSTAGE_FRAGMENT)];
				var textures = [new BindTextureFormat('lightsTextureFloat', SHADERSTAGE_FRAGMENT, TEXTUREDIMENSION_2D, SAMPLETYPE_UNFILTERABLE_FLOAT), new BindTextureFormat('lightsTexture8', SHADERSTAGE_FRAGMENT, TEXTUREDIMENSION_2D, SAMPLETYPE_UNFILTERABLE_FLOAT), new BindTextureFormat('shadowAtlasTexture', SHADERSTAGE_FRAGMENT, TEXTUREDIMENSION_2D, SAMPLETYPE_DEPTH), new BindTextureFormat('cookieAtlasTexture', SHADERSTAGE_FRAGMENT, TEXTUREDIMENSION_2D, SAMPLETYPE_FLOAT), new BindTextureFormat('areaLightsLutTex1', SHADERSTAGE_FRAGMENT, TEXTUREDIMENSION_2D, SAMPLETYPE_FLOAT), new BindTextureFormat('areaLightsLutTex2', SHADERSTAGE_FRAGMENT, TEXTUREDIMENSION_2D, SAMPLETYPE_FLOAT)];
				if (isClustered) {
					textures.push.apply(textures, [new BindTextureFormat('clusterWorldTexture', SHADERSTAGE_FRAGMENT, TEXTUREDIMENSION_2D, SAMPLETYPE_UNFILTERABLE_FLOAT)]);
				}
				this.viewBindGroupFormat = new BindGroupFormat(this.device, buffers, textures);
			}
		};
		_proto.setupViewUniformBuffers = function setupViewUniformBuffers(viewBindGroups, viewUniformFormat, viewBindGroupFormat, viewCount) {
			var device = this.device;
			while (viewBindGroups.length < viewCount) {
				var ub = new UniformBuffer(device, viewUniformFormat, false);
				var bg = new BindGroup(device, viewBindGroupFormat, ub);
				viewBindGroups.push(bg);
			}
			var viewBindGroup = viewBindGroups[0];
			viewBindGroup.defaultUniformBuffer.update();
			viewBindGroup.update();
			device.setBindGroup(BINDGROUP_VIEW, viewBindGroup);
		};
		_proto.setupMeshUniformBuffers = function setupMeshUniformBuffers(shaderInstance, meshInstance) {
			var device = this.device;
			if (device.supportsUniformBuffers) {
				this.modelMatrixId.setValue(meshInstance.node.worldTransform.data);
				this.normalMatrixId.setValue(meshInstance.node.normalMatrix.data);
				var meshBindGroup = shaderInstance.getBindGroup(device);
				meshBindGroup.defaultUniformBuffer.update();
				meshBindGroup.update();
				device.setBindGroup(BINDGROUP_MESH, meshBindGroup);
			}
		};
		_proto.drawInstance = function drawInstance(device, meshInstance, mesh, style, normal) {
			var modelMatrix = meshInstance.node.worldTransform;
			this.modelMatrixId.setValue(modelMatrix.data);
			if (normal) {
				this.normalMatrixId.setValue(meshInstance.node.normalMatrix.data);
			}
			var instancingData = meshInstance.instancingData;
			if (instancingData) {
				if (instancingData.count > 0) {
					this._instancedDrawCalls++;
					device.setVertexBuffer(instancingData.vertexBuffer);
					device.draw(mesh.primitive[style], instancingData.count);
				}
			} else {
				device.draw(mesh.primitive[style]);
			}
		};
		_proto.drawInstance2 = function drawInstance2(device, meshInstance, mesh, style) {
			var instancingData = meshInstance.instancingData;
			if (instancingData) {
				if (instancingData.count > 0) {
					this._instancedDrawCalls++;
					device.draw(mesh.primitive[style], instancingData.count, true);
				}
			} else {
				device.draw(mesh.primitive[style], undefined, true);
			}
		};
		_proto.cull = function cull(camera, drawCalls, culledInstances) {
			var opaque = culledInstances.opaque;
			opaque.length = 0;
			var transparent = culledInstances.transparent;
			transparent.length = 0;
			var doCull = camera.frustumCulling;
			var count = drawCalls.length;
			for (var i = 0; i < count; i++) {
				var drawCall = drawCalls[i];
				if (drawCall.visible) {
					var visible = !doCull || !drawCall.cull || drawCall._isVisible(camera);
					if (visible) {
						drawCall.visibleThisFrame = true;
						var bucket = drawCall.transparent ? transparent : opaque;
						bucket.push(drawCall);
						if (drawCall.skinInstance || drawCall.morphInstance) this.processingMeshInstances.add(drawCall);
					}
				}
			}
		};
		_proto.collectLights = function collectLights(comp) {
			this.lights.length = 0;
			this.localLights.length = 0;
			var stats = this.scene._stats;
			var count = comp.layerList.length;
			for (var i = 0; i < count; i++) {
				var layer = comp.layerList[i];
				if (!_tempLayerSet.has(layer)) {
					_tempLayerSet.add(layer);
					var lights = layer._lights;
					for (var j = 0; j < lights.length; j++) {
						var light = lights[j];
						if (!_tempLightSet.has(light)) {
							_tempLightSet.add(light);
							this.lights.push(light);
							if (light._type !== LIGHTTYPE_DIRECTIONAL) {
								this.localLights.push(light);
							}
						}
					}
				}
			}
			stats.lights = this.lights.length;
			_tempLightSet.clear();
			_tempLayerSet.clear();
		};
		_proto.cullLights = function cullLights(camera, lights) {
			var clusteredLightingEnabled = this.scene.clusteredLightingEnabled;
			var physicalUnits = this.scene.physicalUnits;
			for (var i = 0; i < lights.length; i++) {
				var light = lights[i];
				if (light.enabled) {
					if (light._type !== LIGHTTYPE_DIRECTIONAL) {
						light.getBoundingSphere(tempSphere$1);
						if (camera.frustum.containsSphere(tempSphere$1)) {
							light.visibleThisFrame = true;
							light.usePhysicalUnits = physicalUnits;
							var screenSize = camera.getScreenSize(tempSphere$1);
							light.maxScreenSize = Math.max(light.maxScreenSize, screenSize);
						} else {
							if (!clusteredLightingEnabled) {
								if (light.castShadows && !light.shadowMap) {
									light.visibleThisFrame = true;
								}
							}
						}
					} else {
						light.usePhysicalUnits = this.scene.physicalUnits;
					}
				}
			}
		};
		_proto.cullShadowmaps = function cullShadowmaps(comp) {
			var isClustered = this.scene.clusteredLightingEnabled;
			for (var i = 0; i < this.localLights.length; i++) {
				var light = this.localLights[i];
				if (light._type !== LIGHTTYPE_DIRECTIONAL) {
					if (isClustered) {
						if (light.atlasSlotUpdated && light.shadowUpdateMode === SHADOWUPDATE_NONE) {
							light.shadowUpdateMode = SHADOWUPDATE_THISFRAME;
						}
					} else {
						if (light.shadowUpdateMode === SHADOWUPDATE_NONE && light.castShadows) {
							if (!light.getRenderData(null, 0).shadowCamera.renderTarget) {
								light.shadowUpdateMode = SHADOWUPDATE_THISFRAME;
							}
						}
					}
					if (light.visibleThisFrame && light.castShadows && light.shadowUpdateMode !== SHADOWUPDATE_NONE) {
						this._shadowRendererLocal.cull(light, comp);
					}
				}
			}
			var renderActions = comp._renderActions;
			for (var _i = 0; _i < renderActions.length; _i++) {
				var renderAction = renderActions[_i];
				renderAction.directionalLights.length = 0;
				var camera = renderAction.camera.camera;
				if (renderAction.firstCameraUse) {
					var cameraLayers = camera.layers;
					for (var l = 0; l < cameraLayers.length; l++) {
						var cameraLayer = comp.getLayerById(cameraLayers[l]);
						if (cameraLayer) {
							var layerDirLights = cameraLayer.splitLights[LIGHTTYPE_DIRECTIONAL];
							for (var j = 0; j < layerDirLights.length; j++) {
								var _light = layerDirLights[j];
								if (_light.castShadows && !_tempSet.has(_light)) {
									_tempSet.add(_light);
									renderAction.directionalLights.push(_light);
									this._shadowRendererDirectional.cull(_light, comp, camera);
								}
							}
						}
					}
					_tempSet.clear();
				}
			}
		};
		_proto.cullComposition = function cullComposition(comp) {
			this.processingMeshInstances.clear();
			var numCameras = comp.cameras.length;
			for (var i = 0; i < numCameras; i++) {
				var camera = comp.cameras[i];
				camera.frameUpdate(camera.renderTarget);
				this.updateCameraFrustum(camera.camera);
				this._camerasRendered++;
				var layerIds = camera.layers;
				for (var j = 0; j < layerIds.length; j++) {
					var layer = comp.getLayerById(layerIds[j]);
					if (layer && layer.enabled) {
						this.cullLights(camera.camera, layer._lights);
						layer.onPreCull == null || layer.onPreCull(comp.camerasMap.get(camera));
						var culledInstances = layer.getCulledInstances(camera.camera);
						this.cull(camera.camera, layer.meshInstances, culledInstances);
						layer.onPostCull == null || layer.onPostCull(comp.camerasMap.get(camera));
					}
				}
			}
			if (this.scene.clusteredLightingEnabled) {
				this.updateLightTextureAtlas();
			}
			this.cullShadowmaps(comp);
		};
		_proto.updateShaders = function updateShaders(drawCalls, onlyLitShaders) {
			var count = drawCalls.length;
			for (var i = 0; i < count; i++) {
				var mat = drawCalls[i].material;
				if (mat) {
					if (!_tempSet.has(mat)) {
						_tempSet.add(mat);
						if (mat.getShaderVariant !== Material.prototype.getShaderVariant) {
							if (onlyLitShaders) {
								if (!mat.useLighting || mat.emitter && !mat.emitter.lighting) continue;
							}
							mat.clearVariants();
						}
					}
				}
			}
			_tempSet.clear();
		};
		_proto.beginFrame = function beginFrame(comp) {
			var scene = this.scene;
			var updateShaders = scene.updateShaders;
			var layers = comp.layerList;
			var layerCount = layers.length;
			for (var i = 0; i < layerCount; i++) {
				var layer = layers[i];
				var meshInstances = layer.meshInstances;
				var count = meshInstances.length;
				for (var j = 0; j < count; j++) {
					var meshInst = meshInstances[j];
					meshInst.visibleThisFrame = false;
					if (updateShaders) {
						_tempMeshInstances.push(meshInst);
					}
					if (meshInst.skinInstance) {
						_tempMeshInstancesSkinned.push(meshInst);
					}
				}
			}
			if (updateShaders) {
				var onlyLitShaders = !scene.updateShaders;
				this.updateShaders(_tempMeshInstances, onlyLitShaders);
				scene.updateShaders = false;
				scene._shaderVersion++;
			}
			this.updateCpuSkinMatrices(_tempMeshInstancesSkinned);
			_tempMeshInstances.length = 0;
			_tempMeshInstancesSkinned.length = 0;
			var lights = this.lights;
			var lightCount = lights.length;
			for (var _i2 = 0; _i2 < lightCount; _i2++) {
				lights[_i2].beginFrame();
			}
		};
		_proto.updateLightTextureAtlas = function updateLightTextureAtlas() {
			this.lightTextureAtlas.update(this.localLights, this.scene.lighting);
		};
		_proto.updateLayerComposition = function updateLayerComposition(comp) {
			var len = comp.layerList.length;
			for (var i = 0; i < len; i++) {
				comp.layerList[i]._postRenderCounter = 0;
			}
			var scene = this.scene;
			var shaderVersion = scene._shaderVersion;
			for (var _i3 = 0; _i3 < len; _i3++) {
				var layer = comp.layerList[_i3];
				layer._shaderVersion = shaderVersion;
				layer._preRenderCalledForCameras = 0;
				layer._postRenderCalledForCameras = 0;
				var transparent = comp.subLayerList[_i3];
				if (transparent) {
					layer._postRenderCounter |= 2;
				} else {
					layer._postRenderCounter |= 1;
				}
				layer._postRenderCounterMax = layer._postRenderCounter;
			}
			comp._update();
		};
		_proto.frameUpdate = function frameUpdate() {
			this.clustersDebugRendered = false;
			this.initViewBindGroupFormat(this.scene.clusteredLightingEnabled);
		};
		return Renderer;
	}();

	var RenderAction = function () {
		function RenderAction() {
			this.layer = null;
			this.transparent = false;
			this.camera = null;
			this.renderTarget = null;
			this.lightClusters = null;
			this.clearColor = false;
			this.clearDepth = false;
			this.clearStencil = false;
			this.triggerPostprocess = false;
			this.firstCameraUse = false;
			this.lastCameraUse = false;
			this.directionalLights = [];
			this.viewBindGroups = [];
			this.useCameraPasses = false;
		}
		var _proto = RenderAction.prototype;
		_proto.destroy = function destroy() {
			this.viewBindGroups.forEach(function (bg) {
				bg.defaultUniformBuffer.destroy();
				bg.destroy();
			});
			this.viewBindGroups.length = 0;
		};
		_proto.setupClears = function setupClears(camera, layer) {
			this.clearColor = (camera == null ? void 0 : camera.clearColorBuffer) || layer.clearColorBuffer;
			this.clearDepth = (camera == null ? void 0 : camera.clearDepthBuffer) || layer.clearDepthBuffer;
			this.clearStencil = (camera == null ? void 0 : camera.clearStencilBuffer) || layer.clearStencilBuffer;
		};
		_createClass(RenderAction, [{
			key: "hasDirectionalShadowLights",
			get: function get() {
				return this.directionalLights.length > 0;
			}
		}]);
		return RenderAction;
	}();

	var _goldenAngle = 2.399963229728653;
	var random = {
		circlePoint: function circlePoint(point) {
			var r = Math.sqrt(Math.random());
			var theta = Math.random() * 2 * Math.PI;
			point.x = r * Math.cos(theta);
			point.y = r * Math.sin(theta);
		},
		circlePointDeterministic: function circlePointDeterministic(point, index, numPoints) {
			var theta = index * _goldenAngle;
			var r = Math.sqrt(index) / Math.sqrt(numPoints);
			point.x = r * Math.cos(theta);
			point.y = r * Math.sin(theta);
		},
		spherePointDeterministic: function spherePointDeterministic(point, index, numPoints, start, end) {
			if (start === void 0) {
				start = 0;
			}
			if (end === void 0) {
				end = 1;
			}
			start = 1 - 2 * start;
			end = 1 - 2 * end;
			var y = math.lerp(start, end, index / numPoints);
			var radius = Math.sqrt(1 - y * y);
			var theta = _goldenAngle * index;
			point.x = Math.cos(theta) * radius;
			point.y = y;
			point.z = Math.sin(theta) * radius;
		},
		radicalInverse: function radicalInverse(i) {
			var bits = (i << 16 | i >>> 16) >>> 0;
			bits = ((bits & 0x55555555) << 1 | (bits & 0xAAAAAAAA) >>> 1) >>> 0;
			bits = ((bits & 0x33333333) << 2 | (bits & 0xCCCCCCCC) >>> 2) >>> 0;
			bits = ((bits & 0x0F0F0F0F) << 4 | (bits & 0xF0F0F0F0) >>> 4) >>> 0;
			bits = ((bits & 0x00FF00FF) << 8 | (bits & 0xFF00FF00) >>> 8) >>> 0;
			return bits * 2.3283064365386963e-10;
		}
	};

	var getProjectionName = function getProjectionName(projection) {
		switch (projection) {
			case TEXTUREPROJECTION_CUBE:
				return "Cubemap";
			case TEXTUREPROJECTION_OCTAHEDRAL:
				return "Octahedral";
			default:
				return "Equirect";
		}
	};
	var packFloat32ToRGBA8 = function packFloat32ToRGBA8(value, array, offset) {
		if (value <= 0) {
			array[offset + 0] = 0;
			array[offset + 1] = 0;
			array[offset + 2] = 0;
			array[offset + 3] = 0;
		} else if (value >= 1.0) {
			array[offset + 0] = 255;
			array[offset + 1] = 0;
			array[offset + 2] = 0;
			array[offset + 3] = 0;
		} else {
			var encX = 1 * value % 1;
			var encY = 255 * value % 1;
			var encZ = 65025 * value % 1;
			var encW = 16581375.0 * value % 1;
			encX -= encY / 255;
			encY -= encZ / 255;
			encZ -= encW / 255;
			array[offset + 0] = Math.min(255, Math.floor(encX * 256));
			array[offset + 1] = Math.min(255, Math.floor(encY * 256));
			array[offset + 2] = Math.min(255, Math.floor(encZ * 256));
			array[offset + 3] = Math.min(255, Math.floor(encW * 256));
		}
	};
	var packSamples = function packSamples(samples) {
		var numSamples = samples.length;
		var w = Math.min(numSamples, 512);
		var h = Math.ceil(numSamples / w);
		var data = new Uint8Array(w * h * 4);
		var off = 0;
		for (var i = 0; i < numSamples; i += 4) {
			packFloat32ToRGBA8(samples[i + 0] * 0.5 + 0.5, data, off + 0);
			packFloat32ToRGBA8(samples[i + 1] * 0.5 + 0.5, data, off + 4);
			packFloat32ToRGBA8(samples[i + 2] * 0.5 + 0.5, data, off + 8);
			packFloat32ToRGBA8(samples[i + 3] / 8, data, off + 12);
			off += 16;
		}
		return {
			width: w,
			height: h,
			data: data
		};
	};
	var hemisphereSamplePhong = function hemisphereSamplePhong(dstVec, x, y, specularPower) {
		var phi = y * 2 * Math.PI;
		var cosTheta = Math.pow(1 - x, 1 / (specularPower + 1));
		var sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
		dstVec.set(Math.cos(phi) * sinTheta, Math.sin(phi) * sinTheta, cosTheta).normalize();
	};
	var hemisphereSampleLambert = function hemisphereSampleLambert(dstVec, x, y) {
		var phi = y * 2 * Math.PI;
		var cosTheta = Math.sqrt(1 - x);
		var sinTheta = Math.sqrt(x);
		dstVec.set(Math.cos(phi) * sinTheta, Math.sin(phi) * sinTheta, cosTheta).normalize();
	};
	var hemisphereSampleGGX = function hemisphereSampleGGX(dstVec, x, y, a) {
		var phi = y * 2 * Math.PI;
		var cosTheta = Math.sqrt((1 - x) / (1 + (a * a - 1) * x));
		var sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
		dstVec.set(Math.cos(phi) * sinTheta, Math.sin(phi) * sinTheta, cosTheta).normalize();
	};
	var D_GGX = function D_GGX(NoH, linearRoughness) {
		var a = NoH * linearRoughness;
		var k = linearRoughness / (1.0 - NoH * NoH + a * a);
		return k * k * (1 / Math.PI);
	};
	var generatePhongSamples = function generatePhongSamples(numSamples, specularPower) {
		var H = new Vec3();
		var result = [];
		for (var i = 0; i < numSamples; ++i) {
			hemisphereSamplePhong(H, i / numSamples, random.radicalInverse(i), specularPower);
			result.push(H.x, H.y, H.z, 0);
		}
		return result;
	};
	var generateLambertSamples = function generateLambertSamples(numSamples, sourceTotalPixels) {
		var pixelsPerSample = sourceTotalPixels / numSamples;
		var H = new Vec3();
		var result = [];
		for (var i = 0; i < numSamples; ++i) {
			hemisphereSampleLambert(H, i / numSamples, random.radicalInverse(i));
			var pdf = H.z / Math.PI;
			var mipLevel = 0.5 * Math.log2(pixelsPerSample / pdf);
			result.push(H.x, H.y, H.z, mipLevel);
		}
		return result;
	};
	var requiredSamplesGGX = {
		"16": {
			"2": 26,
			"8": 20,
			"32": 17,
			"128": 16,
			"512": 16
		},
		"32": {
			"2": 53,
			"8": 40,
			"32": 34,
			"128": 32,
			"512": 32
		},
		"128": {
			"2": 214,
			"8": 163,
			"32": 139,
			"128": 130,
			"512": 128
		},
		"1024": {
			"2": 1722,
			"8": 1310,
			"32": 1114,
			"128": 1041,
			"512": 1025
		}
	};
	var getRequiredSamplesGGX = function getRequiredSamplesGGX(numSamples, specularPower) {
		var table = requiredSamplesGGX[numSamples];
		return table && table[specularPower] || numSamples;
	};
	var generateGGXSamples = function generateGGXSamples(numSamples, specularPower, sourceTotalPixels) {
		var pixelsPerSample = sourceTotalPixels / numSamples;
		var roughness = 1 - Math.log2(specularPower) / 11.0;
		var a = roughness * roughness;
		var H = new Vec3();
		var L = new Vec3();
		var N = new Vec3(0, 0, 1);
		var result = [];
		var requiredSamples = getRequiredSamplesGGX(numSamples, specularPower);
		for (var i = 0; i < requiredSamples; ++i) {
			hemisphereSampleGGX(H, i / requiredSamples, random.radicalInverse(i), a);
			var NoH = H.z;
			L.set(H.x, H.y, H.z).mulScalar(2 * NoH).sub(N);
			if (L.z > 0) {
				var pdf = D_GGX(Math.min(1, NoH), a) / 4 + 0.001;
				var mipLevel = 0.5 * Math.log2(pixelsPerSample / pdf);
				result.push(L.x, L.y, L.z, mipLevel);
			}
		}
		while (result.length < numSamples * 4) {
			result.push(0, 0, 0, 0);
		}
		return result;
	};
	var createSamplesTex = function createSamplesTex(device, name, samples) {
		var packedSamples = packSamples(samples);
		return new Texture(device, {
			name: name,
			width: packedSamples.width,
			height: packedSamples.height,
			mipmaps: false,
			minFilter: FILTER_NEAREST,
			magFilter: FILTER_NEAREST,
			levels: [packedSamples.data]
		});
	};
	var SimpleCache = function () {
		function SimpleCache(destroyContent) {
			if (destroyContent === void 0) {
				destroyContent = true;
			}
			this.map = new Map();
			this.destroyContent = destroyContent;
		}
		var _proto = SimpleCache.prototype;
		_proto.destroy = function destroy() {
			if (this.destroyContent) {
				this.map.forEach(function (value, key) {
					value.destroy();
				});
			}
		};
		_proto.get = function get(key, missFunc) {
			if (!this.map.has(key)) {
				var result = missFunc();
				this.map.set(key, result);
				return result;
			}
			return this.map.get(key);
		};
		return SimpleCache;
	}();
	var samplesCache = new SimpleCache(false);
	var deviceCache$1 = new DeviceCache();
	var getCachedTexture = function getCachedTexture(device, key, getSamplesFnc) {
		var cache = deviceCache$1.get(device, function () {
			return new SimpleCache();
		});
		return cache.get(key, function () {
			return createSamplesTex(device, key, samplesCache.get(key, getSamplesFnc));
		});
	};
	var generateLambertSamplesTex = function generateLambertSamplesTex(device, numSamples, sourceTotalPixels) {
		var key = "lambert-samples-" + numSamples + "-" + sourceTotalPixels;
		return getCachedTexture(device, key, function () {
			return generateLambertSamples(numSamples, sourceTotalPixels);
		});
	};
	var generatePhongSamplesTex = function generatePhongSamplesTex(device, numSamples, specularPower) {
		var key = "phong-samples-" + numSamples + "-" + specularPower;
		return getCachedTexture(device, key, function () {
			return generatePhongSamples(numSamples, specularPower);
		});
	};
	var generateGGXSamplesTex = function generateGGXSamplesTex(device, numSamples, specularPower, sourceTotalPixels) {
		var key = "ggx-samples-" + numSamples + "-" + specularPower + "-" + sourceTotalPixels;
		return getCachedTexture(device, key, function () {
			return generateGGXSamples(numSamples, specularPower, sourceTotalPixels);
		});
	};
	var vsCode = "\nattribute vec2 vertex_position;\n\nuniform vec4 uvMod;\n\nvarying vec2 vUv0;\n\nvoid main(void) {\n    gl_Position = vec4(vertex_position, 0.5, 1.0);\n    vUv0 = getImageEffectUV((vertex_position.xy * 0.5 + 0.5) * uvMod.xy + uvMod.zw);\n}\n";
	function reprojectTexture(source, target, options) {
		var _options;
		if (options === void 0) {
			options = {};
		}
		if (source instanceof GraphicsDevice) {
			source = arguments[1];
			target = arguments[2];
			options = {};
			if (arguments[3] !== undefined) {
				options.specularPower = arguments[3];
			}
			if (arguments[4] !== undefined) {
				options.numSamples = arguments[4];
			}
		}
		var funcNames = {
			'none': 'reproject',
			'lambert': 'prefilterSamplesUnweighted',
			'phong': 'prefilterSamplesUnweighted',
			'ggx': 'prefilterSamples'
		};
		var specularPower = options.hasOwnProperty('specularPower') ? options.specularPower : 1;
		var face = options.hasOwnProperty('face') ? options.face : null;
		var distribution = options.hasOwnProperty('distribution') ? options.distribution : specularPower === 1 ? 'none' : 'phong';
		var processFunc = funcNames[distribution] || 'reproject';
		var prefilterSamples = processFunc.startsWith('prefilterSamples');
		var decodeFunc = ChunkUtils.decodeFunc(source.encoding);
		var encodeFunc = ChunkUtils.encodeFunc(target.encoding);
		var sourceFunc = "sample" + getProjectionName(source.projection);
		var targetFunc = "getDirection" + getProjectionName(target.projection);
		var numSamples = options.hasOwnProperty('numSamples') ? options.numSamples : 1024;
		var shaderKey = processFunc + "_" + decodeFunc + "_" + encodeFunc + "_" + sourceFunc + "_" + targetFunc + "_" + numSamples;
		var device = source.device;
		var shader = getProgramLibrary(device).getCachedShader(shaderKey);
		if (!shader) {
			var defines = "#define PROCESS_FUNC " + processFunc + "\n" + (prefilterSamples ? "#define USE_SAMPLES_TEX\n" : '') + (source.cubemap ? "#define CUBEMAP_SOURCE\n" : '') + ("#define DECODE_FUNC " + decodeFunc + "\n") + ("#define ENCODE_FUNC " + encodeFunc + "\n") + ("#define SOURCE_FUNC " + sourceFunc + "\n") + ("#define TARGET_FUNC " + targetFunc + "\n") + ("#define NUM_SAMPLES " + numSamples + "\n") + ("#define NUM_SAMPLES_SQRT " + Math.round(Math.sqrt(numSamples)).toFixed(1) + "\n");
			shader = createShaderFromCode(device, vsCode, defines + "\n" + shaderChunks.reprojectPS, shaderKey);
		}
		device.setBlendState(BlendState.NOBLEND);
		var constantSource = device.scope.resolve(source.cubemap ? "sourceCube" : "sourceTex");
		constantSource.setValue(source);
		var constantParams = device.scope.resolve("params");
		var constantParams2 = device.scope.resolve("params2");
		var uvModParam = device.scope.resolve("uvMod");
		if ((_options = options) != null && _options.seamPixels) {
			var p = options.seamPixels;
			var w = options.rect ? options.rect.z : target.width;
			var h = options.rect ? options.rect.w : target.height;
			var innerWidth = w - p * 2;
			var innerHeight = h - p * 2;
			uvModParam.setValue([(innerWidth + p * 2) / innerWidth, (innerHeight + p * 2) / innerHeight, -p / innerWidth, -p / innerHeight]);
		} else {
			uvModParam.setValue([1, 1, 0, 0]);
		}
		var params = [0, specularPower, source.fixCubemapSeams ? 1.0 / source.width : 0.0, target.fixCubemapSeams ? 1.0 / target.width : 0.0];
		var params2 = [target.width * target.height * (target.cubemap ? 6 : 1), source.width * source.height * (source.cubemap ? 6 : 1)];
		if (prefilterSamples) {
			var sourceTotalPixels = source.width * source.height * (source.cubemap ? 6 : 1);
			var samplesTex = distribution === 'ggx' ? generateGGXSamplesTex(device, numSamples, specularPower, sourceTotalPixels) : distribution === 'lambert' ? generateLambertSamplesTex(device, numSamples, sourceTotalPixels) : generatePhongSamplesTex(device, numSamples, specularPower);
			device.scope.resolve("samplesTex").setValue(samplesTex);
			device.scope.resolve("samplesTexInverseSize").setValue([1.0 / samplesTex.width, 1.0 / samplesTex.height]);
		}
		for (var f = 0; f < (target.cubemap ? 6 : 1); f++) {
			if (face === null || f === face) {
				var _options2;
				var renderTarget = new RenderTarget({
					colorBuffer: target,
					face: f,
					depth: false,
					flipY: device.isWebGPU
				});
				params[0] = f;
				constantParams.setValue(params);
				constantParams2.setValue(params2);
				drawQuadWithShader(device, renderTarget, shader, (_options2 = options) == null ? void 0 : _options2.rect);
				renderTarget.destroy();
			}
		}
	}

	var fixCubemapSeams = true;
	var calcLevels = function calcLevels(width, height) {
		if (height === void 0) {
			height = 0;
		}
		return 1 + Math.floor(Math.log2(Math.max(width, height)));
	};
	var supportsFloat16 = function supportsFloat16(device) {
		return device.extTextureHalfFloat && device.textureHalfFloatRenderable;
	};
	var supportsFloat32 = function supportsFloat32(device) {
		return device.extTextureFloat && device.textureFloatRenderable;
	};
	var lightingSourcePixelFormat = function lightingSourcePixelFormat(device) {
		return supportsFloat16(device) ? PIXELFORMAT_RGBA16F : supportsFloat32(device) ? PIXELFORMAT_RGBA32F : PIXELFORMAT_RGBA8;
	};
	var lightingPixelFormat = function lightingPixelFormat(device) {
		return PIXELFORMAT_RGBA8;
	};
	var createCubemap = function createCubemap(device, size, format, mipmaps) {
		return new Texture(device, {
			name: "lighting-" + size,
			cubemap: true,
			width: size,
			height: size,
			format: format,
			type: format === PIXELFORMAT_RGBA8 ? TEXTURETYPE_RGBP : TEXTURETYPE_DEFAULT,
			addressU: ADDRESS_CLAMP_TO_EDGE,
			addressV: ADDRESS_CLAMP_TO_EDGE,
			fixCubemapSeams: fixCubemapSeams,
			mipmaps: !!mipmaps
		});
	};
	var EnvLighting = function () {
		function EnvLighting() {}
		EnvLighting.generateSkyboxCubemap = function generateSkyboxCubemap(source, size) {
			var device = source.device;
			var result = createCubemap(device, size || (source.cubemap ? source.width : source.width / 4), PIXELFORMAT_RGBA8, false);
			reprojectTexture(source, result, {
				numSamples: 1024
			});
			return result;
		};
		EnvLighting.generateLightingSource = function generateLightingSource(source, options) {
			var device = source.device;
			var format = lightingSourcePixelFormat(device);
			var result = (options == null ? void 0 : options.target) || new Texture(device, {
				name: "lighting-source",
				cubemap: true,
				width: (options == null ? void 0 : options.size) || 128,
				height: (options == null ? void 0 : options.size) || 128,
				format: format,
				type: format === PIXELFORMAT_RGBA8 ? TEXTURETYPE_RGBP : TEXTURETYPE_DEFAULT,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE,
				fixCubemapSeams: false,
				mipmaps: true
			});
			reprojectTexture(source, result, {
				numSamples: source.mipmaps ? 1 : 1024
			});
			return result;
		};
		EnvLighting.generateAtlas = function generateAtlas(source, options) {
			var device = source.device;
			var format = lightingPixelFormat();
			var result = (options == null ? void 0 : options.target) || new Texture(device, {
				name: 'envAtlas',
				width: (options == null ? void 0 : options.size) || 512,
				height: (options == null ? void 0 : options.size) || 512,
				format: format,
				type: TEXTURETYPE_RGBP ,
				projection: TEXTUREPROJECTION_EQUIRECT,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE,
				mipmaps: false
			});
			var s = result.width / 512;
			var rect = new Vec4(0, 0, 512 * s, 256 * s);
			var levels = calcLevels(256) - calcLevels(4);
			for (var i = 0; i < levels; ++i) {
				reprojectTexture(source, result, {
					numSamples: 1,
					rect: rect,
					seamPixels: s
				});
				rect.x += rect.w;
				rect.y += rect.w;
				rect.z = Math.max(1, Math.floor(rect.z * 0.5));
				rect.w = Math.max(1, Math.floor(rect.w * 0.5));
			}
			rect.set(0, 256 * s, 256 * s, 128 * s);
			for (var _i = 1; _i < 7; ++_i) {
				reprojectTexture(source, result, {
					numSamples: (options == null ? void 0 : options.numReflectionSamples) || 1024,
					distribution: (options == null ? void 0 : options.distribution) || 'ggx',
					specularPower: Math.max(1, 2048 >> _i * 2),
					rect: rect,
					seamPixels: s
				});
				rect.y += rect.w;
				rect.z = Math.max(1, Math.floor(rect.z * 0.5));
				rect.w = Math.max(1, Math.floor(rect.w * 0.5));
			}
			rect.set(128 * s, (256 + 128) * s, 64 * s, 32 * s);
			reprojectTexture(source, result, {
				numSamples: (options == null ? void 0 : options.numAmbientSamples) || 2048,
				distribution: 'lambert',
				rect: rect,
				seamPixels: s
			});
			return result;
		};
		EnvLighting.generatePrefilteredAtlas = function generatePrefilteredAtlas(sources, options) {
			var device = sources[0].device;
			var format = sources[0].format;
			var type = sources[0].type;
			var result = (options == null ? void 0 : options.target) || new Texture(device, {
				name: 'envPrefilteredAtlas',
				width: (options == null ? void 0 : options.size) || 512,
				height: (options == null ? void 0 : options.size) || 512,
				format: format,
				type: type,
				projection: TEXTUREPROJECTION_EQUIRECT,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE,
				mipmaps: false
			});
			var s = result.width / 512;
			var rect = new Vec4(0, 0, 512 * s, 256 * s);
			var levels = calcLevels(512);
			for (var i = 0; i < levels; ++i) {
				reprojectTexture(sources[0], result, {
					numSamples: 1,
					rect: rect,
					seamPixels: s
				});
				rect.x += rect.w;
				rect.y += rect.w;
				rect.z = Math.max(1, Math.floor(rect.z * 0.5));
				rect.w = Math.max(1, Math.floor(rect.w * 0.5));
			}
			rect.set(0, 256 * s, 256 * s, 128 * s);
			for (var _i2 = 1; _i2 < sources.length; ++_i2) {
				reprojectTexture(sources[_i2], result, {
					numSamples: 1,
					rect: rect,
					seamPixels: s
				});
				rect.y += rect.w;
				rect.z = Math.max(1, Math.floor(rect.z * 0.5));
				rect.w = Math.max(1, Math.floor(rect.w * 0.5));
			}
			rect.set(128 * s, (256 + 128) * s, 64 * s, 32 * s);
			if (options != null && options.legacyAmbient) {
				reprojectTexture(sources[5], result, {
					numSamples: 1,
					rect: rect,
					seamPixels: s
				});
			} else {
				reprojectTexture(sources[0], result, {
					numSamples: (options == null ? void 0 : options.numSamples) || 2048,
					distribution: 'lambert',
					rect: rect,
					seamPixels: s
				});
			}
			return result;
		};
		return EnvLighting;
	}();

	var StandardMaterialOptions = function () {
		function StandardMaterialOptions() {
			this.forceUv1 = false;
			this.ambientTint = false;
			this.diffuseTint = false;
			this.specularTint = false;
			this.metalnessTint = false;
			this.glossTint = false;
			this.emissiveTint = false;
			this.opacityTint = false;
			this.emissiveEncoding = 'linear';
			this.lightMapEncoding = 'linear';
			this.packedNormal = false;
			this.glossInvert = false;
			this.sheenGlossInvert = false;
			this.clearCoatGlossInvert = false;
			this.litOptions = new LitShaderOptions();
		}
		_createClass(StandardMaterialOptions, [{
			key: "pass",
			get: function get() {
				return this.litOptions.pass;
			}
		}]);
		return StandardMaterialOptions;
	}();

	var _matTex2D = [];
	var buildPropertiesList = function buildPropertiesList(options) {
		return Object.keys(options).filter(function (key) {
			return key !== "litOptions";
		}).sort();
	};
	var ShaderGeneratorStandard = function (_ShaderGenerator) {
		_inheritsLoose(ShaderGeneratorStandard, _ShaderGenerator);
		function ShaderGeneratorStandard() {
			var _this;
			for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}
			_this = _ShaderGenerator.call.apply(_ShaderGenerator, [this].concat(args)) || this;
			_this.optionsContext = new StandardMaterialOptions();
			_this.optionsContextMin = new StandardMaterialOptions();
			return _this;
		}
		var _proto = ShaderGeneratorStandard.prototype;
		_proto.generateKey = function generateKey(options) {
			var props;
			if (options === this.optionsContextMin) {
				if (!this.propsMin) this.propsMin = buildPropertiesList(options);
				props = this.propsMin;
			} else if (options === this.optionsContext) {
				if (!this.props) this.props = buildPropertiesList(options);
				props = this.props;
			} else {
				props = buildPropertiesList(options);
			}
			var key = "standard:\n" + props.map(function (prop) {
				return prop + options[prop];
			}).join('\n') + LitOptionsUtils.generateKey(options.litOptions);
			return key;
		};
		_proto._getUvSourceExpression = function _getUvSourceExpression(transformPropName, uVPropName, options) {
			var transformId = options[transformPropName];
			var uvChannel = options[uVPropName];
			var isMainPass = options.litOptions.pass === SHADER_FORWARD || options.litOptions.pass === SHADER_FORWARDHDR;
			var expression;
			if (isMainPass && options.litOptions.nineSlicedMode === SPRITE_RENDERMODE_SLICED) {
				expression = "nineSlicedUv";
			} else if (isMainPass && options.litOptions.nineSlicedMode === SPRITE_RENDERMODE_TILED) {
				expression = "nineSlicedUv";
			} else {
				if (transformId === 0) {
					expression = "vUv" + uvChannel;
				} else {
					expression = "vUV" + uvChannel + "_" + transformId;
				}
				if (options.heightMap && transformPropName !== "heightMapTransform") {
					expression += " + dUvOffset";
				}
			}
			return expression;
		};
		_proto._addMapDef = function _addMapDef(name, enabled) {
			return enabled ? "#define " + name + "\n" : "#undef " + name + "\n";
		};
		_proto._addMapDefs = function _addMapDefs(float, color, vertex, map, invert) {
			return this._addMapDef("MAPFLOAT", float) + this._addMapDef("MAPCOLOR", color) + this._addMapDef("MAPVERTEX", vertex) + this._addMapDef("MAPTEXTURE", map) + this._addMapDef("MAPINVERT", invert);
		};
		_proto._addMap = function _addMap(propName, chunkName, options, chunks, mapping, encoding) {
			if (encoding === void 0) {
				encoding = null;
			}
			var mapPropName = propName + "Map";
			var uVPropName = mapPropName + "Uv";
			var identifierPropName = mapPropName + "Identifier";
			var transformPropName = mapPropName + "Transform";
			var channelPropName = mapPropName + "Channel";
			var vertexColorChannelPropName = propName + "VertexColorChannel";
			var tintPropName = propName + "Tint";
			var vertexColorPropName = propName + "VertexColor";
			var detailModePropName = propName + "Mode";
			var invertName = propName + "Invert";
			var tintOption = options[tintPropName];
			var vertexColorOption = options[vertexColorPropName];
			var textureOption = options[mapPropName];
			var textureIdentifier = options[identifierPropName];
			var detailModeOption = options[detailModePropName];
			var subCode = chunks[chunkName];
			if (textureOption) {
				var uv = this._getUvSourceExpression(transformPropName, uVPropName, options);
				subCode = subCode.replace(/\$UV/g, uv).replace(/\$CH/g, options[channelPropName]);
				if (mapping && subCode.search(/\$SAMPLER/g) !== -1) {
					var samplerName = "texture_" + mapPropName;
					var alias = mapping[textureIdentifier];
					if (alias) {
						samplerName = alias;
					} else {
						mapping[textureIdentifier] = samplerName;
					}
					subCode = subCode.replace(/\$SAMPLER/g, samplerName);
				}
				if (encoding) {
					if (options[channelPropName] === 'aaa') {
						subCode = subCode.replace(/\$DECODE/g, 'passThrough');
					} else {
						subCode = subCode.replace(/\$DECODE/g, ChunkUtils.decodeFunc(!options.litOptions.gamma && encoding === 'srgb' ? 'linear' : encoding));
					}
					if (subCode.indexOf('$texture2DSAMPLE')) {
						var decodeTable = {
							linear: 'texture2D',
							srgb: 'texture2DSRGB',
							rgbm: 'texture2DRGBM',
							rgbe: 'texture2DRGBE'
						};
						subCode = subCode.replace(/\$texture2DSAMPLE/g, decodeTable[encoding] || 'texture2D');
					}
				}
			}
			if (vertexColorOption) {
				subCode = subCode.replace(/\$VC/g, options[vertexColorChannelPropName]);
			}
			if (detailModeOption) {
				subCode = subCode.replace(/\$DETAILMODE/g, detailModeOption);
			}
			var isFloatTint = !!(tintOption & 1);
			var isVecTint = !!(tintOption & 2);
			var invertOption = !!options[invertName];
			subCode = this._addMapDefs(isFloatTint, isVecTint, vertexColorOption, textureOption, invertOption) + subCode;
			return subCode.replace(/\$/g, "");
		};
		_proto._correctChannel = function _correctChannel(p, chan, _matTex2D) {
			if (_matTex2D[p] > 0) {
				if (_matTex2D[p] < chan.length) {
					return chan.substring(0, _matTex2D[p]);
				} else if (_matTex2D[p] > chan.length) {
					var str = chan;
					var chr = str.charAt(str.length - 1);
					var addLen = _matTex2D[p] - str.length;
					for (var i = 0; i < addLen; i++) str += chr;
					return str;
				}
				return chan;
			}
		};
		_proto.createShaderDefinition = function createShaderDefinition(device, options) {
			var shaderPassInfo = ShaderPass.get(device).getByIndex(options.litOptions.pass);
			var isForwardPass = shaderPassInfo.isForward;
			var litShader = new LitShader(device, options.litOptions);
			var useUv = [];
			var useUnmodifiedUv = [];
			var mapTransforms = [];
			var maxUvSets = 2;
			var textureMapping = {};
			for (var p in _matTex2D) {
				var mname = p + "Map";
				if (options[p + "VertexColor"]) {
					var cname = p + "VertexColorChannel";
					options[cname] = this._correctChannel(p, options[cname], _matTex2D);
				}
				if (options[mname]) {
					var _cname = mname + "Channel";
					var tname = mname + "Transform";
					var uname = mname + "Uv";
					options[uname] = Math.min(options[uname], maxUvSets - 1);
					options[_cname] = this._correctChannel(p, options[_cname], _matTex2D);
					var uvSet = options[uname];
					useUv[uvSet] = true;
					useUnmodifiedUv[uvSet] = useUnmodifiedUv[uvSet] || options[mname] && !options[tname];
					if (options[tname]) {
						mapTransforms.push({
							name: p,
							id: options[tname],
							uv: options[uname]
						});
					}
				}
			}
			if (options.forceUv1) {
				useUv[1] = true;
				useUnmodifiedUv[1] = useUnmodifiedUv[1] !== undefined ? useUnmodifiedUv[1] : true;
			}
			litShader.generateVertexShader(useUv, useUnmodifiedUv, mapTransforms);
			if (options.litOptions.shadingModel === SPECULAR_PHONG) {
				options.litOptions.fresnelModel = 0;
				options.litOptions.ambientSH = false;
			} else {
				options.litOptions.fresnelModel = options.litOptions.fresnelModel === 0 ? FRESNEL_SCHLICK : options.litOptions.fresnelModel;
			}
			var decl = new ChunkBuilder();
			var code = new ChunkBuilder();
			var func = new ChunkBuilder();
			var args = new ChunkBuilder();
			var lightingUv = "";
			if (options.litOptions.nineSlicedMode === SPRITE_RENDERMODE_TILED) {
				decl.append("const float textureBias = -1000.0;");
			} else {
				decl.append("uniform float textureBias;");
			}
			if (isForwardPass) {
				if (options.heightMap) {
					decl.append("vec2 dUvOffset;");
					code.append(this._addMap("height", "parallaxPS", options, litShader.chunks, textureMapping));
					func.append("getParallax();");
				}
				if (options.litOptions.blendType !== BLEND_NONE || options.litOptions.alphaTest || options.litOptions.alphaToCoverage) {
					decl.append("float dAlpha;");
					code.append(this._addMap("opacity", "opacityPS", options, litShader.chunks, textureMapping));
					func.append("getOpacity();");
					args.append("litArgs_opacity = dAlpha;");
					if (options.litOptions.alphaTest) {
						code.append(litShader.chunks.alphaTestPS);
						func.append("alphaTest(dAlpha);");
					}
				} else {
					decl.append("float dAlpha = 1.0;");
				}
				if (litShader.needsNormal) {
					if (options.normalMap || options.clearCoatNormalMap) {
						code.append(options.packedNormal ? litShader.chunks.normalXYPS : litShader.chunks.normalXYZPS);
						if (!options.litOptions.hasTangents) {
							var baseName = options.normalMap ? "normalMap" : "clearCoatNormalMap";
							lightingUv = this._getUvSourceExpression(baseName + "Transform", baseName + "Uv", options);
						}
					}
					decl.append("vec3 dNormalW;");
					code.append(this._addMap("normalDetail", "normalDetailMapPS", options, litShader.chunks, textureMapping));
					code.append(this._addMap("normal", "normalMapPS", options, litShader.chunks, textureMapping));
					func.append("getNormal();");
					args.append("litArgs_worldNormal = dNormalW;");
				}
				if (litShader.needsSceneColor) {
					decl.append("uniform sampler2D uSceneColorMap;");
				}
				if (litShader.needsScreenSize) {
					decl.append("uniform vec4 uScreenSize;");
				}
				if (litShader.needsTransforms) {
					decl.append("uniform mat4 matrix_viewProjection;");
					decl.append("uniform mat4 matrix_model;");
				}
				if (options.diffuseDetail || options.aoDetail) {
					code.append(litShader.chunks.detailModesPS);
				}
				decl.append("vec3 dAlbedo;");
				if (options.diffuseDetail) {
					code.append(this._addMap("diffuseDetail", "diffuseDetailMapPS", options, litShader.chunks, textureMapping, options.diffuseDetailEncoding));
				}
				code.append(this._addMap("diffuse", "diffusePS", options, litShader.chunks, textureMapping, options.diffuseEncoding));
				func.append("getAlbedo();");
				args.append("litArgs_albedo = dAlbedo;");
				if (options.litOptions.useRefraction) {
					decl.append("float dTransmission;");
					code.append(this._addMap("refraction", "transmissionPS", options, litShader.chunks, textureMapping));
					func.append("getRefraction();");
					args.append("litArgs_transmission = dTransmission;");
					decl.append("float dThickness;");
					code.append(this._addMap("thickness", "thicknessPS", options, litShader.chunks, textureMapping));
					func.append("getThickness();");
					args.append("litArgs_thickness = dThickness;");
				}
				if (options.litOptions.useIridescence) {
					decl.append("float dIridescence;");
					code.append(this._addMap("iridescence", "iridescencePS", options, litShader.chunks, textureMapping));
					func.append("getIridescence();");
					args.append("litArgs_iridescence_intensity = dIridescence;");
					decl.append("float dIridescenceThickness;");
					code.append(this._addMap("iridescenceThickness", "iridescenceThicknessPS", options, litShader.chunks, textureMapping));
					func.append("getIridescenceThickness();");
					args.append("litArgs_iridescence_thickness = dIridescenceThickness;");
				}
				if (litShader.lighting && options.litOptions.useSpecular || litShader.reflections) {
					decl.append("vec3 dSpecularity;");
					decl.append("float dGlossiness;");
					if (options.litOptions.useSheen) {
						decl.append("vec3 sSpecularity;");
						code.append(this._addMap("sheen", "sheenPS", options, litShader.chunks, textureMapping, options.sheenEncoding));
						func.append("getSheen();");
						args.append("litArgs_sheen_specularity = sSpecularity;");
						decl.append("float sGlossiness;");
						code.append(this._addMap("sheenGloss", "sheenGlossPS", options, litShader.chunks, textureMapping));
						func.append("getSheenGlossiness();");
						args.append("litArgs_sheen_gloss = sGlossiness;");
					}
					if (options.litOptions.useMetalness) {
						decl.append("float dMetalness;");
						code.append(this._addMap("metalness", "metalnessPS", options, litShader.chunks, textureMapping));
						func.append("getMetalness();");
						args.append("litArgs_metalness = dMetalness;");
						decl.append("float dIor;");
						code.append(this._addMap("ior", "iorPS", options, litShader.chunks, textureMapping));
						func.append("getIor();");
						args.append("litArgs_ior = dIor;");
					}
					if (options.litOptions.useSpecularityFactor) {
						decl.append("float dSpecularityFactor;");
						code.append(this._addMap("specularityFactor", "specularityFactorPS", options, litShader.chunks, textureMapping));
						func.append("getSpecularityFactor();");
						args.append("litArgs_specularityFactor = dSpecularityFactor;");
					}
					if (options.useSpecularColor) {
						code.append(this._addMap("specular", "specularPS", options, litShader.chunks, textureMapping, options.specularEncoding));
					} else {
						code.append("void getSpecularity() { dSpecularity = vec3(1); }");
					}
					code.append(this._addMap("gloss", "glossPS", options, litShader.chunks, textureMapping));
					func.append("getGlossiness();");
					func.append("getSpecularity();");
					args.append("litArgs_specularity = dSpecularity;");
					args.append("litArgs_gloss = dGlossiness;");
				} else {
					decl.append("vec3 dSpecularity = vec3(0.0);");
					decl.append("float dGlossiness = 0.0;");
				}
				if (options.aoDetail) {
					code.append(this._addMap("aoDetail", "aoDetailMapPS", options, litShader.chunks, textureMapping));
				}
				if (options.aoMap || options.aoVertexColor) {
					decl.append("float dAo;");
					code.append(this._addMap("ao", "aoPS", options, litShader.chunks, textureMapping));
					func.append("getAO();");
					args.append("litArgs_ao = dAo;");
				}
				decl.append("vec3 dEmission;");
				code.append(this._addMap("emissive", "emissivePS", options, litShader.chunks, textureMapping, options.emissiveEncoding));
				func.append("getEmission();");
				args.append("litArgs_emission = dEmission;");
				if (options.litOptions.useClearCoat) {
					decl.append("float ccSpecularity;");
					decl.append("float ccGlossiness;");
					decl.append("vec3 ccNormalW;");
					code.append(this._addMap("clearCoat", "clearCoatPS", options, litShader.chunks, textureMapping));
					code.append(this._addMap("clearCoatGloss", "clearCoatGlossPS", options, litShader.chunks, textureMapping));
					code.append(this._addMap("clearCoatNormal", "clearCoatNormalPS", options, litShader.chunks, textureMapping));
					func.append("getClearCoat();");
					func.append("getClearCoatGlossiness();");
					func.append("getClearCoatNormal();");
					args.append("litArgs_clearcoat_specularity = ccSpecularity;");
					args.append("litArgs_clearcoat_gloss = ccGlossiness;");
					args.append("litArgs_clearcoat_worldNormal = ccNormalW;");
				}
				if (options.lightMap || options.lightVertexColor) {
					var lightmapDir = options.dirLightMap && options.litOptions.useSpecular;
					var lightmapChunkPropName = lightmapDir ? 'lightmapDirPS' : 'lightmapSinglePS';
					decl.append("vec3 dLightmap;");
					if (lightmapDir) {
						decl.append("vec3 dLightmapDir;");
					}
					code.append(this._addMap("light", lightmapChunkPropName, options, litShader.chunks, textureMapping, options.lightMapEncoding));
					func.append("getLightMap();");
					args.append("litArgs_lightmap = dLightmap;");
					if (lightmapDir) {
						args.append("litArgs_lightmapDir = dLightmapDir;");
					}
				}
				if (code.code.indexOf('texture2DSRGB') !== -1 || code.code.indexOf('texture2DRGBM') !== -1 || code.code.indexOf('texture2DRGBE') !== -1) {
					code.prepend(litShader.chunks.textureSamplePS);
				}
			} else {
				if (options.litOptions.alphaTest) {
					decl.append("float dAlpha;");
					code.append(this._addMap("opacity", "opacityPS", options, litShader.chunks, textureMapping));
					code.append(litShader.chunks.alphaTestPS);
					func.append("getOpacity();");
					func.append("alphaTest(dAlpha);");
					args.append("litArgs_opacity = dAlpha;");
				}
			}
			decl.append(litShader.chunks.litShaderArgsPS);
			code.append("void evaluateFrontend() { \n" + func.code + "\n" + args.code + "\n }\n");
			func.code = "evaluateFrontend();";
			for (var texture in textureMapping) {
				decl.append("uniform sampler2D " + textureMapping[texture] + ";");
			}
			func.code = "\n" + func.code.split('\n').map(function (l) {
				return "    " + l;
			}).join('\n') + "\n\n";
			litShader.generateFragmentShader(decl.code, code.code, func.code, lightingUv);
			return litShader.getDefinition();
		};
		return ShaderGeneratorStandard;
	}(ShaderGenerator);
	var standard = new ShaderGeneratorStandard();

	var arraysEqual = function arraysEqual(a, b) {
		if (a.length !== b.length) {
			return false;
		}
		for (var i = 0; i < a.length; ++i) {
			if (a[i] !== b[i]) {
				return false;
			}
		}
		return true;
	};
	var notWhite = function notWhite(color) {
		return color.r !== 1 || color.g !== 1 || color.b !== 1;
	};
	var notBlack = function notBlack(color) {
		return color.r !== 0 || color.g !== 0 || color.b !== 0;
	};
	var StandardMaterialOptionsBuilder = function () {
		function StandardMaterialOptionsBuilder() {
			this._mapXForms = null;
		}
		var _proto = StandardMaterialOptionsBuilder.prototype;
		_proto.updateMinRef = function updateMinRef(options, scene, stdMat, objDefs, pass, sortedLights) {
			this._updateSharedOptions(options, scene, stdMat, objDefs, pass);
			this._updateMinOptions(options, stdMat);
			this._updateUVOptions(options, stdMat, objDefs, true);
		};
		_proto.updateRef = function updateRef(options, scene, stdMat, objDefs, pass, sortedLights) {
			this._updateSharedOptions(options, scene, stdMat, objDefs, pass);
			this._updateEnvOptions(options, stdMat, scene);
			this._updateMaterialOptions(options, stdMat);
			if (pass === SHADER_FORWARDHDR) {
				if (options.litOptions.gamma) options.litOptions.gamma = GAMMA_SRGBHDR;
				options.litOptions.toneMap = TONEMAP_LINEAR;
			}
			options.litOptions.hasTangents = objDefs && (objDefs & SHADERDEF_TANGENTS) !== 0;
			this._updateLightOptions(options, scene, stdMat, objDefs, sortedLights);
			this._updateUVOptions(options, stdMat, objDefs, false);
		};
		_proto._updateSharedOptions = function _updateSharedOptions(options, scene, stdMat, objDefs, pass) {
			options.forceUv1 = stdMat.forceUv1;
			if (stdMat.userAttributes) {
				options.litOptions.userAttributes = Object.fromEntries(stdMat.userAttributes.entries());
			}
			options.litOptions.chunks = stdMat.chunks || {};
			options.litOptions.pass = pass;
			options.litOptions.alphaTest = stdMat.alphaTest > 0;
			options.litOptions.blendType = stdMat.blendType;
			options.litOptions.screenSpace = objDefs && (objDefs & SHADERDEF_SCREENSPACE) !== 0;
			options.litOptions.skin = objDefs && (objDefs & SHADERDEF_SKIN) !== 0;
			options.litOptions.useInstancing = objDefs && (objDefs & SHADERDEF_INSTANCING) !== 0;
			options.litOptions.useMorphPosition = objDefs && (objDefs & SHADERDEF_MORPH_POSITION) !== 0;
			options.litOptions.useMorphNormal = objDefs && (objDefs & SHADERDEF_MORPH_NORMAL) !== 0;
			options.litOptions.useMorphTextureBased = objDefs && (objDefs & SHADERDEF_MORPH_TEXTURE_BASED) !== 0;
			options.litOptions.nineSlicedMode = stdMat.nineSlicedMode || 0;
			if (scene.clusteredLightingEnabled && stdMat.useLighting) {
				options.litOptions.clusteredLightingEnabled = true;
				options.litOptions.clusteredLightingCookiesEnabled = scene.lighting.cookiesEnabled;
				options.litOptions.clusteredLightingShadowsEnabled = scene.lighting.shadowsEnabled;
				options.litOptions.clusteredLightingShadowType = scene.lighting.shadowType;
				options.litOptions.clusteredLightingAreaLightsEnabled = scene.lighting.areaLightsEnabled;
			} else {
				options.litOptions.clusteredLightingEnabled = false;
				options.litOptions.clusteredLightingCookiesEnabled = false;
				options.litOptions.clusteredLightingShadowsEnabled = false;
				options.litOptions.clusteredLightingAreaLightsEnabled = false;
			}
		};
		_proto._updateUVOptions = function _updateUVOptions(options, stdMat, objDefs, minimalOptions) {
			var hasUv0 = false;
			var hasUv1 = false;
			var hasVcolor = false;
			if (objDefs) {
				hasUv0 = (objDefs & SHADERDEF_UV0) !== 0;
				hasUv1 = (objDefs & SHADERDEF_UV1) !== 0;
				hasVcolor = (objDefs & SHADERDEF_VCOLOR) !== 0;
			}
			options.litOptions.vertexColors = false;
			this._mapXForms = [];
			var uniqueTextureMap = {};
			for (var p in _matTex2D) {
				this._updateTexOptions(options, stdMat, p, hasUv0, hasUv1, hasVcolor, minimalOptions, uniqueTextureMap);
			}
			this._mapXForms = null;
			options.litOptions.lightMapEnabled = options.lightMap;
			options.litOptions.dirLightMapEnabled = options.dirLightMap;
			options.litOptions.useHeights = options.heightMap;
			options.litOptions.useNormals = options.normalMap;
			options.litOptions.useClearCoatNormals = options.clearCoatNormalMap;
			options.litOptions.useAo = options.aoMap || options.aoVertexColor;
			options.litOptions.diffuseMapEnabled = options.diffuseMap;
		};
		_proto._updateTexOptions = function _updateTexOptions(options, stdMat, p, hasUv0, hasUv1, hasVcolor, minimalOptions, uniqueTextureMap) {
			var isOpacity = p === 'opacity';
			if (!minimalOptions || isOpacity) {
				var mname = p + 'Map';
				var vname = p + 'VertexColor';
				var vcname = p + 'VertexColorChannel';
				var cname = mname + 'Channel';
				var tname = mname + 'Transform';
				var uname = mname + 'Uv';
				var iname = mname + 'Identifier';
				if (p !== 'light') {
					options[mname] = false;
					options[iname] = undefined;
					options[cname] = '';
					options[tname] = 0;
					options[uname] = 0;
				}
				options[vname] = false;
				options[vcname] = '';
				if (isOpacity && stdMat.blendType === BLEND_NONE && stdMat.alphaTest === 0.0 && !stdMat.alphaToCoverage) {
					return;
				}
				if (p !== 'height' && stdMat[vname]) {
					if (hasVcolor) {
						options[vname] = stdMat[vname];
						options[vcname] = stdMat[vcname];
						options.litOptions.vertexColors = true;
					}
				}
				if (stdMat[mname]) {
					var allow = true;
					if (stdMat[uname] === 0 && !hasUv0) allow = false;
					if (stdMat[uname] === 1 && !hasUv1) allow = false;
					if (allow) {
						var mapId = stdMat[mname].id;
						var identifier = uniqueTextureMap[mapId];
						if (identifier === undefined) {
							uniqueTextureMap[mapId] = p;
							identifier = p;
						}
						options[mname] = !!stdMat[mname];
						options[iname] = identifier;
						options[tname] = this._getMapTransformID(stdMat.getUniform(tname), stdMat[uname]);
						options[cname] = stdMat[cname];
						options[uname] = stdMat[uname];
					}
				}
			}
		};
		_proto._updateMinOptions = function _updateMinOptions(options, stdMat) {
			options.opacityTint = stdMat.opacity !== 1 && stdMat.blendType !== BLEND_NONE;
			options.litOptions.lights = [];
		};
		_proto._updateMaterialOptions = function _updateMaterialOptions(options, stdMat) {
			var _stdMat$diffuseMap, _stdMat$diffuseDetail, _stdMat$emissiveMap, _stdMat$lightMap;
			var diffuseTint = (stdMat.diffuseTint || !stdMat.diffuseMap && !stdMat.diffuseVertexColor) && notWhite(stdMat.diffuse);
			var useSpecular = !!(stdMat.useMetalness || stdMat.specularMap || stdMat.sphereMap || stdMat.cubeMap || notBlack(stdMat.specular) || stdMat.specularityFactor > 0 && stdMat.useMetalness || stdMat.enableGGXSpecular || stdMat.clearCoat > 0);
			var useSpecularColor = !stdMat.useMetalness || stdMat.useMetalnessSpecularColor;
			var specularTint = useSpecular && (stdMat.specularTint || !stdMat.specularMap && !stdMat.specularVertexColor) && notWhite(stdMat.specular);
			var specularityFactorTint = useSpecular && stdMat.useMetalnessSpecularColor && (stdMat.specularityFactorTint || stdMat.specularityFactor < 1 && !stdMat.specularityFactorMap);
			var emissiveTintColor = !stdMat.emissiveMap || notWhite(stdMat.emissive) && stdMat.emissiveTint;
			var emissiveTintIntensity = stdMat.emissiveIntensity !== 1;
			var isPackedNormalMap = stdMat.normalMap ? stdMat.normalMap.format === PIXELFORMAT_DXT5 || stdMat.normalMap.type === TEXTURETYPE_SWIZZLEGGGR : false;
			options.opacityTint = stdMat.opacity !== 1 && stdMat.blendType !== BLEND_NONE ? 1 : 0;
			options.ambientTint = stdMat.ambientTint;
			options.diffuseTint = diffuseTint ? 2 : 0;
			options.specularTint = specularTint ? 2 : 0;
			options.specularityFactorTint = specularityFactorTint ? 1 : 0;
			options.metalnessTint = stdMat.useMetalness && stdMat.metalness < 1 ? 1 : 0;
			options.glossTint = 1;
			options.emissiveTint = (emissiveTintColor ? 2 : 0) + (emissiveTintIntensity ? 1 : 0);
			options.diffuseEncoding = (_stdMat$diffuseMap = stdMat.diffuseMap) == null ? void 0 : _stdMat$diffuseMap.encoding;
			options.diffuseDetailEncoding = (_stdMat$diffuseDetail = stdMat.diffuseDetailMap) == null ? void 0 : _stdMat$diffuseDetail.encoding;
			options.emissiveEncoding = (_stdMat$emissiveMap = stdMat.emissiveMap) == null ? void 0 : _stdMat$emissiveMap.encoding;
			options.lightMapEncoding = (_stdMat$lightMap = stdMat.lightMap) == null ? void 0 : _stdMat$lightMap.encoding;
			options.packedNormal = isPackedNormalMap;
			options.refractionTint = stdMat.refraction !== 1.0 ? 1 : 0;
			options.refractionIndexTint = stdMat.refractionIndex !== 1.0 / 1.5 ? 1 : 0;
			options.thicknessTint = stdMat.useDynamicRefraction && stdMat.thickness !== 1.0 ? 1 : 0;
			options.specularEncoding = stdMat.specularEncoding || 'linear';
			options.sheenEncoding = stdMat.sheenEncoding || 'linear';
			options.aoMapUv = stdMat.aoUvSet;
			options.aoDetail = !!stdMat.aoMap;
			options.diffuseDetail = !!stdMat.diffuseMap;
			options.normalDetail = !!stdMat.normalMap;
			options.diffuseDetailMode = stdMat.diffuseDetailMode;
			options.aoDetailMode = stdMat.aoDetailMode;
			options.clearCoatTint = stdMat.clearCoat !== 1.0 ? 1 : 0;
			options.clearCoatGloss = !!stdMat.clearCoatGloss;
			options.clearCoatGlossTint = stdMat.clearCoatGloss !== 1.0 ? 1 : 0;
			options.iorTint = stdMat.refractionIndex !== 1.0 / 1.5 ? 1 : 0;
			options.iridescenceTint = stdMat.iridescence !== 1.0 ? 1 : 0;
			options.sheenTint = stdMat.useSheen && notWhite(stdMat.sheen) ? 2 : 0;
			options.sheenGlossTint = 1;
			options.glossInvert = stdMat.glossInvert;
			options.sheenGlossInvert = stdMat.sheenGlossInvert;
			options.clearCoatGlossInvert = stdMat.clearCoatGlossInvert;
			options.useSpecularColor = useSpecularColor;
			options.litOptions.separateAmbient = false;
			options.litOptions.useAmbientTint = stdMat.ambientTint;
			options.litOptions.customFragmentShader = stdMat.customFragmentShader;
			options.litOptions.pixelSnap = stdMat.pixelSnap;
			options.litOptions.shadingModel = stdMat.shadingModel;
			options.litOptions.ambientSH = !!stdMat.ambientSH;
			options.litOptions.fastTbn = stdMat.fastTbn;
			options.litOptions.twoSidedLighting = stdMat.twoSidedLighting;
			options.litOptions.occludeSpecular = stdMat.occludeSpecular;
			options.litOptions.occludeSpecularFloat = stdMat.occludeSpecularIntensity !== 1.0;
			options.litOptions.useMsdf = !!stdMat.msdfMap;
			options.litOptions.msdfTextAttribute = !!stdMat.msdfTextAttribute;
			options.litOptions.alphaToCoverage = stdMat.alphaToCoverage;
			options.litOptions.opacityFadesSpecular = stdMat.opacityFadesSpecular;
			options.litOptions.cubeMapProjection = stdMat.cubeMapProjection;
			options.litOptions.occludeDirect = stdMat.occludeDirect;
			options.litOptions.conserveEnergy = stdMat.conserveEnergy && stdMat.shadingModel !== SPECULAR_PHONG;
			options.litOptions.useSpecular = useSpecular;
			options.litOptions.useSpecularityFactor = (specularityFactorTint || !!stdMat.specularityFactorMap) && stdMat.useMetalnessSpecularColor;
			options.litOptions.enableGGXSpecular = stdMat.enableGGXSpecular;
			options.litOptions.fresnelModel = stdMat.fresnelModel;
			options.litOptions.useRefraction = (stdMat.refraction || !!stdMat.refractionMap) && (stdMat.useDynamicRefraction || !!options.litOptions.reflectionSource);
			options.litOptions.useClearCoat = !!stdMat.clearCoat;
			options.litOptions.useSheen = stdMat.useSheen;
			options.litOptions.useIridescence = stdMat.useIridescence && stdMat.iridescence !== 0.0;
			options.litOptions.useMetalness = stdMat.useMetalness;
			options.litOptions.useDynamicRefraction = stdMat.useDynamicRefraction;
		};
		_proto._updateEnvOptions = function _updateEnvOptions(options, stdMat, scene) {
			options.litOptions.fog = stdMat.useFog ? scene.fog : 'none';
			options.litOptions.gamma = stdMat.useGammaTonemap ? scene.gammaCorrection : GAMMA_NONE;
			options.litOptions.toneMap = stdMat.useGammaTonemap ? scene.toneMapping : -1;
			options.litOptions.fixSeams = stdMat.cubeMap ? stdMat.cubeMap.fixCubemapSeams : false;
			var isPhong = stdMat.shadingModel === SPECULAR_PHONG;
			var usingSceneEnv = false;
			if (stdMat.envAtlas && stdMat.cubeMap && !isPhong) {
				options.litOptions.reflectionSource = 'envAtlasHQ';
				options.litOptions.reflectionEncoding = stdMat.envAtlas.encoding;
				options.litOptions.reflectionCubemapEncoding = stdMat.cubeMap.encoding;
			} else if (stdMat.envAtlas && !isPhong) {
				options.litOptions.reflectionSource = 'envAtlas';
				options.litOptions.reflectionEncoding = stdMat.envAtlas.encoding;
			} else if (stdMat.cubeMap) {
				options.litOptions.reflectionSource = 'cubeMap';
				options.litOptions.reflectionEncoding = stdMat.cubeMap.encoding;
			} else if (stdMat.sphereMap) {
				options.litOptions.reflectionSource = 'sphereMap';
				options.litOptions.reflectionEncoding = stdMat.sphereMap.encoding;
			} else if (stdMat.useSkybox && scene.envAtlas && scene.skybox && !isPhong) {
				options.litOptions.reflectionSource = 'envAtlasHQ';
				options.litOptions.reflectionEncoding = scene.envAtlas.encoding;
				options.litOptions.reflectionCubemapEncoding = scene.skybox.encoding;
				usingSceneEnv = true;
			} else if (stdMat.useSkybox && scene.envAtlas && !isPhong) {
				options.litOptions.reflectionSource = 'envAtlas';
				options.litOptions.reflectionEncoding = scene.envAtlas.encoding;
				usingSceneEnv = true;
			} else if (stdMat.useSkybox && scene.skybox) {
				options.litOptions.reflectionSource = 'cubeMap';
				options.litOptions.reflectionEncoding = scene.skybox.encoding;
				usingSceneEnv = true;
			} else {
				options.litOptions.reflectionSource = null;
				options.litOptions.reflectionEncoding = null;
			}
			if (stdMat.ambientSH && !isPhong) {
				options.litOptions.ambientSource = 'ambientSH';
				options.litOptions.ambientEncoding = null;
			} else {
				var envAtlas = stdMat.envAtlas || (stdMat.useSkybox && scene.envAtlas ? scene.envAtlas : null);
				if (envAtlas && !isPhong) {
					options.litOptions.ambientSource = 'envAtlas';
					options.litOptions.ambientEncoding = envAtlas.encoding;
				} else {
					options.litOptions.ambientSource = 'constant';
					options.litOptions.ambientEncoding = null;
				}
			}
			options.litOptions.skyboxIntensity = usingSceneEnv && (scene.skyboxIntensity !== 1 || scene.physicalUnits);
			options.litOptions.useCubeMapRotation = usingSceneEnv && scene._skyboxRotationShaderInclude;
		};
		_proto._updateLightOptions = function _updateLightOptions(options, scene, stdMat, objDefs, sortedLights) {
			options.lightMap = false;
			options.lightMapChannel = '';
			options.lightMapUv = 0;
			options.lightMapTransform = 0;
			options.litOptions.lightMapWithoutAmbient = false;
			options.dirLightMap = false;
			if (objDefs) {
				options.litOptions.noShadow = (objDefs & SHADERDEF_NOSHADOW) !== 0;
				if ((objDefs & SHADERDEF_LM) !== 0) {
					options.lightMapEncoding = scene.lightmapPixelFormat === PIXELFORMAT_RGBA8 ? 'rgbm' : 'linear';
					options.lightMap = true;
					options.lightMapChannel = 'rgb';
					options.lightMapUv = 1;
					options.lightMapTransform = 0;
					options.litOptions.lightMapWithoutAmbient = !stdMat.lightMap;
					if ((objDefs & SHADERDEF_DIRLM) !== 0) {
						options.dirLightMap = true;
					}
					if ((objDefs & SHADERDEF_LMAMBIENT) !== 0) {
						options.litOptions.lightMapWithoutAmbient = false;
					}
				}
			}
			if (stdMat.useLighting) {
				var lightsFiltered = [];
				var mask = objDefs ? objDefs >> 16 : MASK_AFFECT_DYNAMIC;
				options.litOptions.lightMaskDynamic = !!(mask & MASK_AFFECT_DYNAMIC);
				if (sortedLights) {
					LitMaterialOptionsBuilder.collectLights(LIGHTTYPE_DIRECTIONAL, sortedLights[LIGHTTYPE_DIRECTIONAL], lightsFiltered, mask);
					LitMaterialOptionsBuilder.collectLights(LIGHTTYPE_OMNI, sortedLights[LIGHTTYPE_OMNI], lightsFiltered, mask);
					LitMaterialOptionsBuilder.collectLights(LIGHTTYPE_SPOT, sortedLights[LIGHTTYPE_SPOT], lightsFiltered, mask);
				}
				options.litOptions.lights = lightsFiltered;
			} else {
				options.litOptions.lights = [];
			}
			if (options.litOptions.lights.length === 0) {
				options.litOptions.noShadow = true;
			}
		};
		_proto._getMapTransformID = function _getMapTransformID(xform, uv) {
			if (!xform) return 0;
			var xforms = this._mapXForms[uv];
			if (!xforms) {
				xforms = [];
				this._mapXForms[uv] = xforms;
			}
			for (var i = 0; i < xforms.length; i++) {
				if (arraysEqual(xforms[i][0].value, xform[0].value) && arraysEqual(xforms[i][1].value, xform[1].value)) {
					return i + 1;
				}
			}
			return xforms.push(xform);
		};
		return StandardMaterialOptionsBuilder;
	}();

	function _textureParameter(name, channel, vertexColor) {
		if (channel === void 0) {
			channel = true;
		}
		if (vertexColor === void 0) {
			vertexColor = true;
		}
		var result = {};
		result[name + "Map"] = 'texture';
		result[name + "MapTiling"] = 'vec2';
		result[name + "MapOffset"] = 'vec2';
		result[name + "MapRotation"] = 'number';
		result[name + "MapUv"] = 'number';
		if (channel) {
			result[name + "MapChannel"] = 'string';
			if (vertexColor) {
				result[name + "VertexColor"] = 'boolean';
				result[name + "VertexColorChannel"] = 'string';
			}
		}
		return result;
	}
	var standardMaterialParameterTypes = _extends({
		name: 'string',
		chunks: 'chunks',
		mappingFormat: 'string',
		_engine: 'boolean',
		ambient: 'rgb',
		ambientTint: 'boolean'
	}, _textureParameter('ao'), _textureParameter('aoDetail', true, false), {
		aoDetailMode: 'string',
		diffuse: 'rgb',
		diffuseTint: 'boolean'
	}, _textureParameter('diffuse'), _textureParameter('diffuseDetail', true, false), {
		diffuseDetailMode: 'string',
		specular: 'rgb',
		specularTint: 'boolean'
	}, _textureParameter('specular'), {
		occludeSpecular: 'enum:occludeSpecular',
		specularityFactor: 'number',
		specularityFactorTint: 'boolean'
	}, _textureParameter('specularityFactor'), {
		useMetalness: 'boolean',
		metalness: 'number',
		enableGGXSpecular: 'boolean',
		anisotropy: 'number',
		metalnessTint: 'boolean'
	}, _textureParameter('metalness'), {
		useMetalnessSpecularColor: 'boolean',
		conserveEnergy: 'boolean',
		shininess: 'number',
		gloss: 'number',
		glossInvert: 'boolean'
	}, _textureParameter('gloss'), {
		clearCoat: 'number'
	}, _textureParameter('clearCoat'), {
		clearCoatGloss: 'number',
		clearCoatGlossInvert: 'boolean'
	}, _textureParameter('clearCoatGloss'), {
		clearCoatBumpiness: 'number'
	}, _textureParameter('clearCoatNormal', false), {
		useSheen: 'boolean',
		sheen: 'rgb',
		sheenTint: 'boolean'
	}, _textureParameter('sheen'), {
		sheenGloss: 'number',
		sheenGlossTint: 'boolean',
		sheenGlossInvert: 'boolean'
	}, _textureParameter('sheenGloss'), {
		fresnelModel: 'number',
		emissive: 'rgb',
		emissiveTint: 'boolean'
	}, _textureParameter('emissive'), {
		emissiveIntensity: 'number'
	}, _textureParameter('normal', false), {
		bumpiness: 'number'
	}, _textureParameter('normalDetail', false), {
		normalDetailMapBumpiness: 'number'
	}, _textureParameter('height', true, false), {
		heightMapFactor: 'number',
		alphaToCoverage: 'boolean',
		alphaTest: 'number',
		alphaFade: 'number',
		opacity: 'number'
	}, _textureParameter('opacity'), {
		opacityFadesSpecular: 'boolean',
		reflectivity: 'number',
		refraction: 'number',
		refractionTint: 'boolean'
	}, _textureParameter('refraction'), {
		refractionIndex: 'number',
		thickness: 'number',
		thicknessTint: 'boolean'
	}, _textureParameter('thickness'), {
		attenuation: 'rgb',
		attenuationDistance: 'number',
		useDynamicRefraction: 'boolean',
		sphereMap: 'texture',
		cubeMap: 'cubemap',
		cubeMapProjection: 'number',
		cubeMapProjectionBox: 'boundingbox',
		useIridescence: 'boolean',
		iridescence: 'number',
		iridescenceTint: 'boolean'
	}, _textureParameter('iridescence'), {
		iridescenceThicknessTint: 'boolean',
		iridescenceThicknessMin: 'number',
		iridescenceThicknessMax: 'number',
		iridescenceRefractionIndex: 'number'
	}, _textureParameter('iridescenceThickness'), _textureParameter('light'), {
		depthTest: 'boolean',
		depthFunc: 'enum:depthFunc',
		depthWrite: 'boolean',
		depthBias: 'number',
		slopeDepthBias: 'number',
		cull: 'enum:cull',
		blendType: 'enum:blendType',
		shadingModel: 'enum:shadingModel',
		useFog: 'boolean',
		useLighting: 'boolean',
		useSkybox: 'boolean',
		useGammaTonemap: 'boolean',
		envAtlas: 'texture',
		twoSidedLighting: 'boolean'
	});
	var standardMaterialTextureParameters = [];
	for (var key in standardMaterialParameterTypes) {
		var type = standardMaterialParameterTypes[key];
		if (type === 'texture') {
			standardMaterialTextureParameters.push(key);
		}
	}
	var standardMaterialCubemapParameters = [];
	for (var _key in standardMaterialParameterTypes) {
		var _type = standardMaterialParameterTypes[_key];
		if (_type === 'cubemap') {
			standardMaterialCubemapParameters.push(_key);
		}
	}
	var standardMaterialRemovedParameters = {
		aoMapVertexColor: 'boolean',
		diffuseMapTint: 'boolean',
		diffuseMapVertexColor: 'boolean',
		emissiveMapTint: 'boolean',
		emissiveMapVertexColor: 'boolean',
		glossMapVertexColor: 'boolean',
		metalnessMapVertexColor: 'boolean',
		opacityMapVertexColor: 'boolean',
		specularAntialias: 'boolean',
		specularMapTint: 'boolean',
		specularMapVertexColor: 'boolean'
	};

	var _props = {};
	var _uniforms = {};
	var _params = new Set();
	var StandardMaterial = function (_Material) {
		_inheritsLoose(StandardMaterial, _Material);
		function StandardMaterial() {
			var _this;
			_this = _Material.call(this) || this;
			_this.userAttributes = new Map();
			_this._dirtyShader = true;
			_this._assetReferences = {};
			_this._activeParams = new Set();
			_this._activeLightingParams = new Set();
			_this.shaderOptBuilder = new StandardMaterialOptionsBuilder();
			_this.reset();
			return _this;
		}
		var _proto = StandardMaterial.prototype;
		_proto.reset = function reset() {
			var _this2 = this;
			Object.keys(_props).forEach(function (name) {
				_this2["_" + name] = _props[name].value();
			});
			this._chunks = {};
			this._uniformCache = {};
		};
		_proto.copy = function copy(source) {
			var _this3 = this;
			_Material.prototype.copy.call(this, source);
			Object.keys(_props).forEach(function (k) {
				_this3[k] = source[k];
			});
			for (var p in source._chunks) {
				if (source._chunks.hasOwnProperty(p)) this._chunks[p] = source._chunks[p];
			}
			return this;
		};
		_proto.setAttribute = function setAttribute(name, semantic) {
			this.userAttributes.set(semantic, name);
		};
		_proto._setParameter = function _setParameter(name, value) {
			_params.add(name);
			this.setParameter(name, value);
		};
		_proto._setParameters = function _setParameters(parameters) {
			var _this4 = this;
			parameters.forEach(function (v) {
				_this4._setParameter(v.name, v.value);
			});
		};
		_proto._processParameters = function _processParameters(paramsName) {
			var _this5 = this;
			var prevParams = this[paramsName];
			prevParams.forEach(function (param) {
				if (!_params.has(param)) {
					delete _this5.parameters[param];
				}
			});
			this[paramsName] = _params;
			_params = prevParams;
			_params.clear();
		};
		_proto._updateMap = function _updateMap(p) {
			var mname = p + 'Map';
			var map = this[mname];
			if (map) {
				this._setParameter('texture_' + mname, map);
				var tname = mname + 'Transform';
				var uniform = this.getUniform(tname);
				if (uniform) {
					this._setParameters(uniform);
				}
			}
		};
		_proto._allocUniform = function _allocUniform(name, allocFunc) {
			var uniform = this._uniformCache[name];
			if (!uniform) {
				uniform = allocFunc();
				this._uniformCache[name] = uniform;
			}
			return uniform;
		};
		_proto.getUniform = function getUniform(name, device, scene) {
			return _uniforms[name](this, device, scene);
		};
		_proto.updateUniforms = function updateUniforms(device, scene) {
			var _this6 = this;
			var getUniform = function getUniform(name) {
				return _this6.getUniform(name, device, scene);
			};
			this._setParameter('material_ambient', getUniform('ambient'));
			if (!this.diffuseMap || this.diffuseTint) {
				this._setParameter('material_diffuse', getUniform('diffuse'));
			}
			if (this.useMetalness) {
				if (!this.metalnessMap || this.metalness < 1) {
					this._setParameter('material_metalness', this.metalness);
				}
				if (!this.specularMap || this.specularTint) {
					this._setParameter('material_specular', getUniform('specular'));
				}
				if (!this.specularityFactorMap || this.specularityFactorTint) {
					this._setParameter('material_specularityFactor', this.specularityFactor);
				}
				if (!this.sheenMap || this.sheenTint) {
					this._setParameter('material_sheen', getUniform('sheen'));
				}
				if (!this.sheenGlossMap || this.sheenGlossTint) {
					this._setParameter('material_sheenGloss', this.sheenGloss);
				}
				this._setParameter('material_refractionIndex', this.refractionIndex);
			} else {
				if (!this.specularMap || this.specularTint) {
					this._setParameter('material_specular', getUniform('specular'));
				}
			}
			if (this.enableGGXSpecular) {
				this._setParameter('material_anisotropy', this.anisotropy);
			}
			if (this.clearCoat > 0) {
				this._setParameter('material_clearCoat', this.clearCoat);
				this._setParameter('material_clearCoatGloss', this.clearCoatGloss);
				this._setParameter('material_clearCoatBumpiness', this.clearCoatBumpiness);
			}
			this._setParameter('material_gloss', getUniform('gloss'));
			if (!this.emissiveMap || this.emissiveTint) {
				this._setParameter('material_emissive', getUniform('emissive'));
			}
			if (this.emissiveIntensity !== 1) {
				this._setParameter('material_emissiveIntensity', this.emissiveIntensity);
			}
			if (this.refraction > 0) {
				this._setParameter('material_refraction', this.refraction);
			}
			if (this.useDynamicRefraction) {
				this._setParameter('material_thickness', this.thickness);
				this._setParameter('material_attenuation', getUniform('attenuation'));
				this._setParameter('material_invAttenuationDistance', this.attenuationDistance === 0 ? 0 : 1.0 / this.attenuationDistance);
			}
			if (this.useIridescence) {
				this._setParameter('material_iridescence', this.iridescence);
				this._setParameter('material_iridescenceRefractionIndex', this.iridescenceRefractionIndex);
				this._setParameter('material_iridescenceThicknessMin', this.iridescenceThicknessMin);
				this._setParameter('material_iridescenceThicknessMax', this.iridescenceThicknessMax);
			}
			this._setParameter('material_opacity', this.opacity);
			if (this.opacityFadesSpecular === false) {
				this._setParameter('material_alphaFade', this.alphaFade);
			}
			if (this.occludeSpecular) {
				this._setParameter('material_occludeSpecularIntensity', this.occludeSpecularIntensity);
			}
			if (this.cubeMapProjection === CUBEPROJ_BOX) {
				this._setParameter(getUniform('cubeMapProjectionBox'));
			}
			for (var p in _matTex2D) {
				this._updateMap(p);
			}
			if (this.ambientSH) {
				this._setParameter('ambientSH[0]', this.ambientSH);
			}
			if (this.normalMap) {
				this._setParameter('material_bumpiness', this.bumpiness);
			}
			if (this.normalMap && this.normalDetailMap) {
				this._setParameter('material_normalDetailMapBumpiness', this.normalDetailMapBumpiness);
			}
			if (this.heightMap) {
				this._setParameter('material_heightMapFactor', getUniform('heightMapFactor'));
			}
			var isPhong = this.shadingModel === SPECULAR_PHONG;
			if (this.envAtlas && this.cubeMap && !isPhong) {
				this._setParameter('texture_envAtlas', this.envAtlas);
				this._setParameter('texture_cubeMap', this.cubeMap);
			} else if (this.envAtlas && !isPhong) {
				this._setParameter('texture_envAtlas', this.envAtlas);
			} else if (this.cubeMap) {
				this._setParameter('texture_cubeMap', this.cubeMap);
			} else if (this.sphereMap) {
				this._setParameter('texture_sphereMap', this.sphereMap);
			}
			this._setParameter('material_reflectivity', this.reflectivity);
			this._processParameters('_activeParams');
			if (this._dirtyShader) {
				this.clearVariants();
			}
		};
		_proto.updateEnvUniforms = function updateEnvUniforms(device, scene) {
			var isPhong = this.shadingModel === SPECULAR_PHONG;
			var hasLocalEnvOverride = this.envAtlas && !isPhong || this.cubeMap || this.sphereMap;
			if (!hasLocalEnvOverride && this.useSkybox) {
				if (scene.envAtlas && scene.skybox && !isPhong) {
					this._setParameter('texture_envAtlas', scene.envAtlas);
					this._setParameter('texture_cubeMap', scene.skybox);
				} else if (scene.envAtlas && !isPhong) {
					this._setParameter('texture_envAtlas', scene.envAtlas);
				} else if (scene.skybox) {
					this._setParameter('texture_cubeMap', scene.skybox);
				}
			}
			this._processParameters('_activeLightingParams');
		};
		_proto.getShaderVariant = function getShaderVariant(device, scene, objDefs, unused, pass, sortedLights, viewUniformFormat, viewBindGroupFormat, vertexFormat) {
			this.updateEnvUniforms(device, scene);
			var shaderPassInfo = ShaderPass.get(device).getByIndex(pass);
			var minimalOptions = pass === SHADER_DEPTH || pass === SHADER_PICK || shaderPassInfo.isShadow;
			var options = minimalOptions ? standard.optionsContextMin : standard.optionsContext;
			if (minimalOptions) this.shaderOptBuilder.updateMinRef(options, scene, this, objDefs, pass, sortedLights);else this.shaderOptBuilder.updateRef(options, scene, this, objDefs, pass, sortedLights);
			if (this.onUpdateShader) {
				options = this.onUpdateShader(options);
			}
			var processingOptions = new ShaderProcessorOptions(viewUniformFormat, viewBindGroupFormat, vertexFormat);
			var library = getProgramLibrary(device);
			library.register('standard', standard);
			var shader = library.getProgram('standard', options, processingOptions, this.userId);
			this._dirtyShader = false;
			return shader;
		};
		_proto.destroy = function destroy() {
			for (var asset in this._assetReferences) {
				this._assetReferences[asset]._unbind();
			}
			this._assetReferences = null;
			_Material.prototype.destroy.call(this);
		};
		_createClass(StandardMaterial, [{
			key: "shader",
			get: function get() {
				return null;
			},
			set: function set(shader) {}
		}, {
			key: "chunks",
			get: function get() {
				this._dirtyShader = true;
				return this._chunks;
			},
			set: function set(value) {
				this._dirtyShader = true;
				this._chunks = value;
			}
		}]);
		return StandardMaterial;
	}(Material);
	StandardMaterial.TEXTURE_PARAMETERS = standardMaterialTextureParameters;
	StandardMaterial.CUBEMAP_PARAMETERS = standardMaterialCubemapParameters;
	var defineUniform = function defineUniform(name, getUniformFunc) {
		_uniforms[name] = getUniformFunc;
	};
	var definePropInternal = function definePropInternal(name, constructorFunc, setterFunc, getterFunc) {
		Object.defineProperty(StandardMaterial.prototype, name, {
			get: getterFunc || function () {
				return this["_" + name];
			},
			set: setterFunc
		});
		_props[name] = {
			value: constructorFunc
		};
	};
	var defineValueProp = function defineValueProp(prop) {
		var internalName = "_" + prop.name;
		var dirtyShaderFunc = prop.dirtyShaderFunc || function () {
			return true;
		};
		var setterFunc = function setterFunc(value) {
			var oldValue = this[internalName];
			if (oldValue !== value) {
				this._dirtyShader = this._dirtyShader || dirtyShaderFunc(oldValue, value);
				this[internalName] = value;
			}
		};
		definePropInternal(prop.name, function () {
			return prop.defaultValue;
		}, setterFunc, prop.getterFunc);
	};
	var defineAggProp = function defineAggProp(prop) {
		var internalName = "_" + prop.name;
		var dirtyShaderFunc = prop.dirtyShaderFunc || function () {
			return true;
		};
		var setterFunc = function setterFunc(value) {
			var oldValue = this[internalName];
			if (!oldValue.equals(value)) {
				this._dirtyShader = this._dirtyShader || dirtyShaderFunc(oldValue, value);
				this[internalName] = oldValue.copy(value);
			}
		};
		definePropInternal(prop.name, function () {
			return prop.defaultValue.clone();
		}, setterFunc, prop.getterFunc);
	};
	var defineProp = function defineProp(prop) {
		return prop.defaultValue && prop.defaultValue.clone ? defineAggProp(prop) : defineValueProp(prop);
	};
	function _defineTex2D(name, channel, vertexColor, uv) {
		if (channel === void 0) {
			channel = "rgb";
		}
		if (vertexColor === void 0) {
			vertexColor = true;
		}
		if (uv === void 0) {
			uv = 0;
		}
		_matTex2D[name] = channel.length || -1;
		defineProp({
			name: name + "Map",
			defaultValue: null,
			dirtyShaderFunc: function dirtyShaderFunc(oldValue, newValue) {
				return !!oldValue !== !!newValue || oldValue && (oldValue.type !== newValue.type || oldValue.fixCubemapSeams !== newValue.fixCubemapSeams || oldValue.format !== newValue.format);
			}
		});
		defineProp({
			name: name + "MapTiling",
			defaultValue: new Vec2(1, 1)
		});
		defineProp({
			name: name + "MapOffset",
			defaultValue: new Vec2(0, 0)
		});
		defineProp({
			name: name + "MapRotation",
			defaultValue: 0
		});
		defineProp({
			name: name + "MapUv",
			defaultValue: uv
		});
		if (channel) {
			defineProp({
				name: name + "MapChannel",
				defaultValue: channel
			});
			if (vertexColor) {
				defineProp({
					name: name + "VertexColor",
					defaultValue: false
				});
				defineProp({
					name: name + "VertexColorChannel",
					defaultValue: channel
				});
			}
		}
		var mapTiling = name + "MapTiling";
		var mapOffset = name + "MapOffset";
		var mapRotation = name + "MapRotation";
		var mapTransform = name + "MapTransform";
		defineUniform(mapTransform, function (material, device, scene) {
			var tiling = material[mapTiling];
			var offset = material[mapOffset];
			var rotation = material[mapRotation];
			if (tiling.x === 1 && tiling.y === 1 && offset.x === 0 && offset.y === 0 && rotation === 0) {
				return null;
			}
			var uniform = material._allocUniform(mapTransform, function () {
				return [{
					name: "texture_" + mapTransform + "0",
					value: new Float32Array(3)
				}, {
					name: "texture_" + mapTransform + "1",
					value: new Float32Array(3)
				}];
			});
			var cr = Math.cos(rotation * math.DEG_TO_RAD);
			var sr = Math.sin(rotation * math.DEG_TO_RAD);
			var uniform0 = uniform[0].value;
			uniform0[0] = cr * tiling.x;
			uniform0[1] = -sr * tiling.y;
			uniform0[2] = offset.x;
			var uniform1 = uniform[1].value;
			uniform1[0] = sr * tiling.x;
			uniform1[1] = cr * tiling.y;
			uniform1[2] = 1.0 - tiling.y - offset.y;
			return uniform;
		});
	}
	function _defineColor(name, defaultValue) {
		defineProp({
			name: name,
			defaultValue: defaultValue,
			getterFunc: function getterFunc() {
				this._dirtyShader = true;
				return this["_" + name];
			}
		});
		defineUniform(name, function (material, device, scene) {
			var uniform = material._allocUniform(name, function () {
				return new Float32Array(3);
			});
			var color = material[name];
			var gamma = material.useGammaTonemap && scene.gammaCorrection;
			if (gamma) {
				uniform[0] = Math.pow(color.r, 2.2);
				uniform[1] = Math.pow(color.g, 2.2);
				uniform[2] = Math.pow(color.b, 2.2);
			} else {
				uniform[0] = color.r;
				uniform[1] = color.g;
				uniform[2] = color.b;
			}
			return uniform;
		});
	}
	function _defineFloat(name, defaultValue, getUniformFunc) {
		defineProp({
			name: name,
			defaultValue: defaultValue,
			dirtyShaderFunc: function dirtyShaderFunc(oldValue, newValue) {
				return (oldValue === 0 || oldValue === 1) !== (newValue === 0 || newValue === 1);
			}
		});
		defineUniform(name, getUniformFunc);
	}
	function _defineObject(name, getUniformFunc) {
		defineProp({
			name: name,
			defaultValue: null,
			dirtyShaderFunc: function dirtyShaderFunc(oldValue, newValue) {
				return !!oldValue === !!newValue;
			}
		});
		defineUniform(name, getUniformFunc);
	}
	function _defineFlag(name, defaultValue) {
		defineProp({
			name: name,
			defaultValue: defaultValue
		});
	}
	function _defineMaterialProps() {
		_defineColor('ambient', new Color(0.7, 0.7, 0.7));
		_defineColor('diffuse', new Color(1, 1, 1));
		_defineColor('specular', new Color(0, 0, 0));
		_defineColor('emissive', new Color(0, 0, 0));
		_defineColor('sheen', new Color(1, 1, 1));
		_defineColor('attenuation', new Color(1, 1, 1));
		_defineFloat('emissiveIntensity', 1);
		_defineFloat('specularityFactor', 1);
		_defineFloat('sheenGloss', 0.0);
		_defineFloat('gloss', 0.25, function (material, device, scene) {
			return material.shadingModel === SPECULAR_PHONG ? Math.pow(2, material.gloss * 11) : material.gloss;
		});
		_defineFloat('heightMapFactor', 1, function (material, device, scene) {
			return material.heightMapFactor * 0.025;
		});
		_defineFloat('opacity', 1);
		_defineFloat('alphaFade', 1);
		_defineFloat('alphaTest', 0);
		_defineFloat('bumpiness', 1);
		_defineFloat('normalDetailMapBumpiness', 1);
		_defineFloat('reflectivity', 1);
		_defineFloat('occludeSpecularIntensity', 1);
		_defineFloat('refraction', 0);
		_defineFloat('refractionIndex', 1.0 / 1.5);
		_defineFloat('thickness', 0);
		_defineFloat('attenuationDistance', 0);
		_defineFloat('metalness', 1);
		_defineFloat('anisotropy', 0);
		_defineFloat('clearCoat', 0);
		_defineFloat('clearCoatGloss', 1);
		_defineFloat('clearCoatBumpiness', 1);
		_defineFloat('aoUvSet', 0, null);
		_defineFloat('iridescence', 0);
		_defineFloat('iridescenceRefractionIndex', 1.0 / 1.5);
		_defineFloat('iridescenceThicknessMin', 0);
		_defineFloat('iridescenceThicknessMax', 0);
		_defineObject('ambientSH');
		_defineObject('cubeMapProjectionBox', function (material, device, scene) {
			var uniform = material._allocUniform('cubeMapProjectionBox', function () {
				return [{
					name: 'envBoxMin',
					value: new Float32Array(3)
				}, {
					name: 'envBoxMax',
					value: new Float32Array(3)
				}];
			});
			var bboxMin = material.cubeMapProjectionBox.getMin();
			var minUniform = uniform[0].value;
			minUniform[0] = bboxMin.x;
			minUniform[1] = bboxMin.y;
			minUniform[2] = bboxMin.z;
			var bboxMax = material.cubeMapProjectionBox.getMax();
			var maxUniform = uniform[1].value;
			maxUniform[0] = bboxMax.x;
			maxUniform[1] = bboxMax.y;
			maxUniform[2] = bboxMax.z;
			return uniform;
		});
		_defineFlag('ambientTint', false);
		_defineFlag('diffuseTint', false);
		_defineFlag('specularTint', false);
		_defineFlag('specularityFactorTint', false);
		_defineFlag('emissiveTint', false);
		_defineFlag('fastTbn', false);
		_defineFlag('useMetalness', false);
		_defineFlag('useMetalnessSpecularColor', false);
		_defineFlag('useSheen', false);
		_defineFlag('enableGGXSpecular', false);
		_defineFlag('occludeDirect', false);
		_defineFlag('normalizeNormalMap', true);
		_defineFlag('conserveEnergy', true);
		_defineFlag('opacityFadesSpecular', true);
		_defineFlag('occludeSpecular', SPECOCC_AO);
		_defineFlag('shadingModel', SPECULAR_BLINN);
		_defineFlag('fresnelModel', FRESNEL_SCHLICK);
		_defineFlag('useDynamicRefraction', false);
		_defineFlag('cubeMapProjection', CUBEPROJ_NONE);
		_defineFlag('customFragmentShader', null);
		_defineFlag('useFog', true);
		_defineFlag('useLighting', true);
		_defineFlag('useGammaTonemap', true);
		_defineFlag('useSkybox', true);
		_defineFlag('forceUv1', false);
		_defineFlag('pixelSnap', false);
		_defineFlag('twoSidedLighting', false);
		_defineFlag('nineSlicedMode', undefined);
		_defineFlag('msdfTextAttribute', false);
		_defineFlag('useIridescence', false);
		_defineFlag('glossInvert', false);
		_defineFlag('sheenGlossInvert', false);
		_defineFlag('clearCoatGlossInvert', false);
		_defineTex2D('diffuse');
		_defineTex2D('specular');
		_defineTex2D('emissive');
		_defineTex2D('thickness', 'g');
		_defineTex2D('specularityFactor', 'g');
		_defineTex2D('normal', '');
		_defineTex2D('metalness', 'g');
		_defineTex2D('gloss', 'g');
		_defineTex2D('opacity', 'a');
		_defineTex2D('refraction', 'g');
		_defineTex2D('height', 'g', false);
		_defineTex2D('ao', 'g');
		_defineTex2D('light', 'rgb', true, 1);
		_defineTex2D('msdf', '');
		_defineTex2D('diffuseDetail', 'rgb', false);
		_defineTex2D('normalDetail', '');
		_defineTex2D('aoDetail', 'g', false);
		_defineTex2D('clearCoat', 'g');
		_defineTex2D('clearCoatGloss', 'g');
		_defineTex2D('clearCoatNormal', '');
		_defineTex2D('sheen', 'rgb');
		_defineTex2D('sheenGloss', 'g');
		_defineTex2D('iridescence', 'g');
		_defineTex2D('iridescenceThickness', 'g');
		_defineFlag('diffuseDetailMode', DETAILMODE_MUL);
		_defineFlag('aoDetailMode', DETAILMODE_MUL);
		_defineObject('cubeMap');
		_defineObject('sphereMap');
		_defineObject('envAtlas');
		var getterFunc = function getterFunc() {
			return this._prefilteredCubemaps;
		};
		var setterFunc = function setterFunc(value) {
			var cubemaps = this._prefilteredCubemaps;
			value = value || [];
			var changed = false;
			var complete = true;
			for (var i = 0; i < 6; ++i) {
				var v = value[i] || null;
				if (cubemaps[i] !== v) {
					cubemaps[i] = v;
					changed = true;
				}
				complete = complete && !!cubemaps[i];
			}
			if (changed) {
				if (complete) {
					this.envAtlas = EnvLighting.generatePrefilteredAtlas(cubemaps, {
						target: this.envAtlas
					});
				} else {
					if (this.envAtlas) {
						this.envAtlas.destroy();
						this.envAtlas = null;
					}
				}
				this._dirtyShader = true;
			}
		};
		var empty = [null, null, null, null, null, null];
		definePropInternal('prefilteredCubemaps', function () {
			return empty.slice();
		}, setterFunc, getterFunc);
	}
	_defineMaterialProps();

	new Vec3(1, 1, 1);
	new Vec3(40, 0, 0);

	var RenderPassRenderActions = function (_RenderPass) {
		_inheritsLoose(RenderPassRenderActions, _RenderPass);
		function RenderPassRenderActions(device, layerComposition, scene, renderer) {
			var _this;
			_this = _RenderPass.call(this, device) || this;
			_this.layerComposition = void 0;
			_this.scene = void 0;
			_this.renderer = void 0;
			_this.renderActions = [];
			_this.layerComposition = layerComposition;
			_this.scene = scene;
			_this.renderer = renderer;
			return _this;
		}
		var _proto = RenderPassRenderActions.prototype;
		_proto.addRenderAction = function addRenderAction(renderAction) {
			this.renderActions.push(renderAction);
			if (this.renderActions.length === 1) {
				var camera = renderAction.camera;
				this.fullSizeClearRect = camera.camera.fullSizeClearRect;
				if (this.fullSizeClearRect) {
					if (renderAction.clearColor) {
						this.setClearColor(camera.camera.clearColor);
					}
					if (renderAction.clearDepth) {
						this.setClearDepth(camera.camera.clearDepth);
					}
					if (renderAction.clearStencil) {
						this.setClearStencil(camera.camera.clearStencil);
					}
				}
			}
		};
		_proto.addLayer = function addLayer(camera, layer, transparent, autoClears) {
			if (autoClears === void 0) {
				autoClears = true;
			}
			var ra = new RenderAction();
			ra.renderTarget = this.renderTarget;
			ra.camera = camera;
			ra.layer = layer;
			ra.transparent = transparent;
			if (autoClears) {
				var firstRa = this.renderActions.length === 0;
				ra.setupClears(firstRa ? camera : undefined, layer);
			}
			this.addRenderAction(ra);
		};
		_proto.before = function before() {
			var renderActions = this.renderActions;
			if (renderActions.length) {
				var ra = renderActions[0];
				if (ra.camera.onPreRender && ra.firstCameraUse) {
					ra.camera.onPreRender();
				}
			}
		};
		_proto.execute = function execute() {
			var layerComposition = this.layerComposition,
				renderActions = this.renderActions;
			for (var i = 0; i < renderActions.length; i++) {
				var ra = renderActions[i];
				if (layerComposition.isEnabled(ra.layer, ra.transparent)) {
					this.renderRenderAction(ra, i === 0);
				}
			}
		};
		_proto.after = function after() {
			var renderActions = this.renderActions;
			if (renderActions.length) {
				var ra = renderActions[renderActions.length - 1];
				if (ra.camera.onPostRender && ra.lastCameraUse) {
					ra.camera.onPostRender();
				}
			}
		};
		_proto.renderRenderAction = function renderRenderAction(renderAction, firstRenderAction) {
			var scene = this.scene,
				renderer = this.renderer,
				layerComposition = this.layerComposition;
			var clusteredLightingEnabled = scene.clusteredLightingEnabled;
			var device = renderer.device;
			var layer = renderAction.layer,
				transparent = renderAction.transparent,
				camera = renderAction.camera;
			var cameraPass = layerComposition.camerasMap.get(camera);
			if (!transparent && layer.onPreRenderOpaque) {
				layer.onPreRenderOpaque(cameraPass);
			} else if (transparent && layer.onPreRenderTransparent) {
				layer.onPreRenderTransparent(cameraPass);
			}
			if (!(layer._preRenderCalledForCameras & 1 << cameraPass)) {
				if (layer.onPreRender) {
					layer.onPreRender(cameraPass);
				}
				layer._preRenderCalledForCameras |= 1 << cameraPass;
			}
			if (camera) {
				var _renderAction$renderT, _camera$camera$shader, _camera$camera$shader2;
				renderer.setupViewport(camera.camera, renderAction.renderTarget);
				if (!firstRenderAction || !camera.camera.fullSizeClearRect) {
					renderer.clear(camera.camera, renderAction.clearColor, renderAction.clearDepth, renderAction.clearStencil);
				}
				layer.sortVisible(camera.camera, transparent);
				var culledInstances = layer.getCulledInstances(camera.camera);
				var visible = transparent ? culledInstances.transparent : culledInstances.opaque;
				scene.immediate.onPreRenderLayer(layer, visible, transparent);
				if (layer.requiresLightCube) {
					renderer.lightCube.update(scene.ambientLight, layer._lights);
					renderer.constantLightCube.setValue(renderer.lightCube.colors);
				}
				if (clusteredLightingEnabled && renderAction.lightClusters) {
					renderAction.lightClusters.activate();
					if (!renderer.clustersDebugRendered && scene.lighting.debugLayer === layer.id) {
						renderer.clustersDebugRendered = true;
					}
				}
				scene._activeCamera = camera.camera;
				var viewCount = renderer.setCameraUniforms(camera.camera, renderAction.renderTarget);
				if (device.supportsUniformBuffers) {
					renderer.setupViewUniformBuffers(renderAction.viewBindGroups, renderer.viewUniformFormat, renderer.viewBindGroupFormat, viewCount);
				}
				var flipFaces = !!(camera.camera._flipFaces ^ (renderAction == null || (_renderAction$renderT = renderAction.renderTarget) == null ? void 0 : _renderAction$renderT.flipY));
				var shaderPass = (_camera$camera$shader = (_camera$camera$shader2 = camera.camera.shaderPassInfo) == null ? void 0 : _camera$camera$shader2.index) != null ? _camera$camera$shader : layer.shaderPass;
				var draws = renderer._forwardDrawCalls;
				renderer.renderForward(camera.camera, visible, layer.splitLights, shaderPass, layer.onDrawCall, layer, flipFaces);
				layer._forwardDrawCalls += renderer._forwardDrawCalls - draws;
				device.setBlendState(BlendState.NOBLEND);
				device.setStencilState(null, null);
				device.setAlphaToCoverage(false);
				device.setDepthBias(false);
			}
			if (!transparent && layer.onPostRenderOpaque) {
				layer.onPostRenderOpaque(cameraPass);
			} else if (transparent && layer.onPostRenderTransparent) {
				layer.onPostRenderTransparent(cameraPass);
			}
			if (layer.onPostRender && !(layer._postRenderCalledForCameras & 1 << cameraPass)) {
				layer._postRenderCounter &= ~(transparent ? 2 : 1);
				if (layer._postRenderCounter === 0) {
					layer.onPostRender(cameraPass);
					layer._postRenderCalledForCameras |= 1 << cameraPass;
					layer._postRenderCounter = layer._postRenderCounterMax;
				}
			}
		};
		return RenderPassRenderActions;
	}(RenderPass);

	var RenderPassPostprocessing = function (_RenderPass) {
		_inheritsLoose(RenderPassPostprocessing, _RenderPass);
		function RenderPassPostprocessing(device, renderer, renderAction) {
			var _this;
			_this = _RenderPass.call(this, device) || this;
			_this.renderer = renderer;
			_this.renderAction = renderAction;
			_this.requiresCubemaps = false;
			return _this;
		}
		var _proto = RenderPassPostprocessing.prototype;
		_proto.execute = function execute() {
			var renderAction = this.renderAction;
			var camera = renderAction.camera;
			camera.onPostprocessing();
		};
		return RenderPassPostprocessing;
	}(RenderPass);

	var _drawCallList = {
		drawCalls: [],
		shaderInstances: [],
		isNewMaterial: [],
		lightMaskChanged: [],
		clear: function clear() {
			this.drawCalls.length = 0;
			this.shaderInstances.length = 0;
			this.isNewMaterial.length = 0;
			this.lightMaskChanged.length = 0;
		}
	};
	function vogelDiskPrecalculationSamples(numSamples) {
		var samples = [];
		for (var i = 0; i < numSamples; ++i) {
			var r = Math.sqrt(i + 0.5) / Math.sqrt(numSamples);
			samples.push(r);
		}
		return samples;
	}
	function vogelSpherePrecalculationSamples(numSamples) {
		var samples = [];
		for (var i = 0; i < numSamples; i++) {
			var weight = i / numSamples;
			var radius = Math.sqrt(1.0 - weight * weight);
			samples.push(radius);
		}
		return samples;
	}
	var ForwardRenderer = function (_Renderer) {
		_inheritsLoose(ForwardRenderer, _Renderer);
		function ForwardRenderer(graphicsDevice) {
			var _this;
			_this = _Renderer.call(this, graphicsDevice) || this;
			var device = _this.device;
			_this._forwardDrawCalls = 0;
			_this._materialSwitches = 0;
			_this._depthMapTime = 0;
			_this._forwardTime = 0;
			_this._sortTime = 0;
			var scope = device.scope;
			_this.fogColorId = scope.resolve('fog_color');
			_this.fogStartId = scope.resolve('fog_start');
			_this.fogEndId = scope.resolve('fog_end');
			_this.fogDensityId = scope.resolve('fog_density');
			_this.ambientId = scope.resolve('light_globalAmbient');
			_this.skyboxIntensityId = scope.resolve('skyboxIntensity');
			_this.cubeMapRotationMatrixId = scope.resolve('cubeMapRotationMatrix');
			_this.pcssDiskSamplesId = scope.resolve('pcssDiskSamples[0]');
			_this.pcssSphereSamplesId = scope.resolve('pcssSphereSamples[0]');
			_this.lightColorId = [];
			_this.lightDir = [];
			_this.lightDirId = [];
			_this.lightShadowMapId = [];
			_this.lightShadowMatrixId = [];
			_this.lightShadowParamsId = [];
			_this.lightShadowIntensity = [];
			_this.lightRadiusId = [];
			_this.lightPos = [];
			_this.lightPosId = [];
			_this.lightWidth = [];
			_this.lightWidthId = [];
			_this.lightHeight = [];
			_this.lightHeightId = [];
			_this.lightInAngleId = [];
			_this.lightOutAngleId = [];
			_this.lightCookieId = [];
			_this.lightCookieIntId = [];
			_this.lightCookieMatrixId = [];
			_this.lightCookieOffsetId = [];
			_this.lightShadowSearchAreaId = [];
			_this.lightCameraParamsId = [];
			_this.shadowMatrixPaletteId = [];
			_this.shadowCascadeDistancesId = [];
			_this.shadowCascadeCountId = [];
			_this.screenSizeId = scope.resolve('uScreenSize');
			_this._screenSize = new Float32Array(4);
			_this.fogColor = new Float32Array(3);
			_this.ambientColor = new Float32Array(3);
			_this.pcssDiskSamples = vogelDiskPrecalculationSamples(16);
			_this.pcssSphereSamples = vogelSpherePrecalculationSamples(16);
			return _this;
		}
		var _proto = ForwardRenderer.prototype;
		_proto.destroy = function destroy() {
			_Renderer.prototype.destroy.call(this);
		};
		_proto.dispatchGlobalLights = function dispatchGlobalLights(scene) {
			this.ambientColor[0] = scene.ambientLight.r;
			this.ambientColor[1] = scene.ambientLight.g;
			this.ambientColor[2] = scene.ambientLight.b;
			if (scene.gammaCorrection) {
				for (var i = 0; i < 3; i++) {
					this.ambientColor[i] = Math.pow(this.ambientColor[i], 2.2);
				}
			}
			if (scene.physicalUnits) {
				for (var _i = 0; _i < 3; _i++) {
					this.ambientColor[_i] *= scene.ambientLuminance;
				}
			}
			this.ambientId.setValue(this.ambientColor);
			this.skyboxIntensityId.setValue(scene.physicalUnits ? scene.skyboxLuminance : scene.skyboxIntensity);
			this.cubeMapRotationMatrixId.setValue(scene._skyboxRotationMat3.data);
		};
		_proto._resolveLight = function _resolveLight(scope, i) {
			var light = 'light' + i;
			this.lightColorId[i] = scope.resolve(light + '_color');
			this.lightDir[i] = new Float32Array(3);
			this.lightDirId[i] = scope.resolve(light + '_direction');
			this.lightShadowMapId[i] = scope.resolve(light + '_shadowMap');
			this.lightShadowMatrixId[i] = scope.resolve(light + '_shadowMatrix');
			this.lightShadowParamsId[i] = scope.resolve(light + '_shadowParams');
			this.lightShadowIntensity[i] = scope.resolve(light + '_shadowIntensity');
			this.lightShadowSearchAreaId[i] = scope.resolve(light + '_shadowSearchArea');
			this.lightRadiusId[i] = scope.resolve(light + '_radius');
			this.lightPos[i] = new Float32Array(3);
			this.lightPosId[i] = scope.resolve(light + '_position');
			this.lightWidth[i] = new Float32Array(3);
			this.lightWidthId[i] = scope.resolve(light + '_halfWidth');
			this.lightHeight[i] = new Float32Array(3);
			this.lightHeightId[i] = scope.resolve(light + '_halfHeight');
			this.lightInAngleId[i] = scope.resolve(light + '_innerConeAngle');
			this.lightOutAngleId[i] = scope.resolve(light + '_outerConeAngle');
			this.lightCookieId[i] = scope.resolve(light + '_cookie');
			this.lightCookieIntId[i] = scope.resolve(light + '_cookieIntensity');
			this.lightCookieMatrixId[i] = scope.resolve(light + '_cookieMatrix');
			this.lightCookieOffsetId[i] = scope.resolve(light + '_cookieOffset');
			this.lightCameraParamsId[i] = scope.resolve(light + '_cameraParams');
			this.shadowMatrixPaletteId[i] = scope.resolve(light + '_shadowMatrixPalette[0]');
			this.shadowCascadeDistancesId[i] = scope.resolve(light + '_shadowCascadeDistances[0]');
			this.shadowCascadeCountId[i] = scope.resolve(light + '_shadowCascadeCount');
		};
		_proto.setLTCDirectionalLight = function setLTCDirectionalLight(wtm, cnt, dir, campos, far) {
			this.lightPos[cnt][0] = campos.x - dir.x * far;
			this.lightPos[cnt][1] = campos.y - dir.y * far;
			this.lightPos[cnt][2] = campos.z - dir.z * far;
			this.lightPosId[cnt].setValue(this.lightPos[cnt]);
			var hWidth = wtm.transformVector(new Vec3(-0.5, 0, 0));
			this.lightWidth[cnt][0] = hWidth.x * far;
			this.lightWidth[cnt][1] = hWidth.y * far;
			this.lightWidth[cnt][2] = hWidth.z * far;
			this.lightWidthId[cnt].setValue(this.lightWidth[cnt]);
			var hHeight = wtm.transformVector(new Vec3(0, 0, 0.5));
			this.lightHeight[cnt][0] = hHeight.x * far;
			this.lightHeight[cnt][1] = hHeight.y * far;
			this.lightHeight[cnt][2] = hHeight.z * far;
			this.lightHeightId[cnt].setValue(this.lightHeight[cnt]);
		};
		_proto.dispatchDirectLights = function dispatchDirectLights(dirs, scene, mask, camera) {
			var cnt = 0;
			var scope = this.device.scope;
			for (var i = 0; i < dirs.length; i++) {
				if (!(dirs[i].mask & mask)) continue;
				var directional = dirs[i];
				var wtm = directional._node.getWorldTransform();
				if (!this.lightColorId[cnt]) {
					this._resolveLight(scope, cnt);
				}
				this.lightColorId[cnt].setValue(scene.gammaCorrection ? directional._linearFinalColor : directional._finalColor);
				wtm.getY(directional._direction).mulScalar(-1);
				directional._direction.normalize();
				this.lightDir[cnt][0] = directional._direction.x;
				this.lightDir[cnt][1] = directional._direction.y;
				this.lightDir[cnt][2] = directional._direction.z;
				this.lightDirId[cnt].setValue(this.lightDir[cnt]);
				if (directional.shape !== LIGHTSHAPE_PUNCTUAL) {
					this.setLTCDirectionalLight(wtm, cnt, directional._direction, camera._node.getPosition(), camera.farClip);
				}
				if (directional.castShadows) {
					var lightRenderData = directional.getRenderData(camera, 0);
					var biases = directional._getUniformBiasValues(lightRenderData);
					this.lightShadowMapId[cnt].setValue(lightRenderData.shadowBuffer);
					this.lightShadowMatrixId[cnt].setValue(lightRenderData.shadowMatrix.data);
					this.shadowMatrixPaletteId[cnt].setValue(directional._shadowMatrixPalette);
					this.shadowCascadeDistancesId[cnt].setValue(directional._shadowCascadeDistances);
					this.shadowCascadeCountId[cnt].setValue(directional.numCascades);
					this.lightShadowIntensity[cnt].setValue(directional.shadowIntensity);
					var projectionCompensation = 50.0 / lightRenderData.projectionCompensation;
					var pixelsPerMeter = directional.penumbraSize / lightRenderData.shadowCamera.renderTarget.width;
					this.lightShadowSearchAreaId[cnt].setValue(pixelsPerMeter * projectionCompensation);
					var cameraParams = directional._shadowCameraParams;
					cameraParams.length = 4;
					cameraParams[0] = lightRenderData.depthRangeCompensation;
					cameraParams[1] = lightRenderData.shadowCamera._farClip;
					cameraParams[2] = lightRenderData.shadowCamera._nearClip;
					cameraParams[3] = 1;
					this.lightCameraParamsId[cnt].setValue(cameraParams);
					var params = directional._shadowRenderParams;
					params.length = 4;
					params[0] = directional._shadowResolution;
					params[1] = biases.normalBias;
					params[2] = biases.bias;
					params[3] = 0;
					this.lightShadowParamsId[cnt].setValue(params);
				}
				cnt++;
			}
			return cnt;
		};
		_proto.setLTCPositionalLight = function setLTCPositionalLight(wtm, cnt) {
			var hWidth = wtm.transformVector(new Vec3(-0.5, 0, 0));
			this.lightWidth[cnt][0] = hWidth.x;
			this.lightWidth[cnt][1] = hWidth.y;
			this.lightWidth[cnt][2] = hWidth.z;
			this.lightWidthId[cnt].setValue(this.lightWidth[cnt]);
			var hHeight = wtm.transformVector(new Vec3(0, 0, 0.5));
			this.lightHeight[cnt][0] = hHeight.x;
			this.lightHeight[cnt][1] = hHeight.y;
			this.lightHeight[cnt][2] = hHeight.z;
			this.lightHeightId[cnt].setValue(this.lightHeight[cnt]);
		};
		_proto.dispatchOmniLight = function dispatchOmniLight(scene, scope, omni, cnt) {
			var wtm = omni._node.getWorldTransform();
			if (!this.lightColorId[cnt]) {
				this._resolveLight(scope, cnt);
			}
			this.lightRadiusId[cnt].setValue(omni.attenuationEnd);
			this.lightColorId[cnt].setValue(scene.gammaCorrection ? omni._linearFinalColor : omni._finalColor);
			wtm.getTranslation(omni._position);
			this.lightPos[cnt][0] = omni._position.x;
			this.lightPos[cnt][1] = omni._position.y;
			this.lightPos[cnt][2] = omni._position.z;
			this.lightPosId[cnt].setValue(this.lightPos[cnt]);
			if (omni.shape !== LIGHTSHAPE_PUNCTUAL) {
				this.setLTCPositionalLight(wtm, cnt);
			}
			if (omni.castShadows) {
				var lightRenderData = omni.getRenderData(null, 0);
				this.lightShadowMapId[cnt].setValue(lightRenderData.shadowBuffer);
				var biases = omni._getUniformBiasValues(lightRenderData);
				var params = omni._shadowRenderParams;
				params.length = 4;
				params[0] = omni._shadowResolution;
				params[1] = biases.normalBias;
				params[2] = biases.bias;
				params[3] = 1.0 / omni.attenuationEnd;
				this.lightShadowParamsId[cnt].setValue(params);
				this.lightShadowIntensity[cnt].setValue(omni.shadowIntensity);
				var pixelsPerMeter = omni.penumbraSize / lightRenderData.shadowCamera.renderTarget.width;
				this.lightShadowSearchAreaId[cnt].setValue(pixelsPerMeter);
				var cameraParams = omni._shadowCameraParams;
				cameraParams.length = 4;
				cameraParams[0] = lightRenderData.depthRangeCompensation;
				cameraParams[1] = lightRenderData.shadowCamera._farClip;
				cameraParams[2] = lightRenderData.shadowCamera._nearClip;
				cameraParams[3] = 0;
				this.lightCameraParamsId[cnt].setValue(cameraParams);
			}
			if (omni._cookie) {
				this.lightCookieId[cnt].setValue(omni._cookie);
				this.lightShadowMatrixId[cnt].setValue(wtm.data);
				this.lightCookieIntId[cnt].setValue(omni.cookieIntensity);
			}
		};
		_proto.dispatchSpotLight = function dispatchSpotLight(scene, scope, spot, cnt) {
			var wtm = spot._node.getWorldTransform();
			if (!this.lightColorId[cnt]) {
				this._resolveLight(scope, cnt);
			}
			this.lightInAngleId[cnt].setValue(spot._innerConeAngleCos);
			this.lightOutAngleId[cnt].setValue(spot._outerConeAngleCos);
			this.lightRadiusId[cnt].setValue(spot.attenuationEnd);
			this.lightColorId[cnt].setValue(scene.gammaCorrection ? spot._linearFinalColor : spot._finalColor);
			wtm.getTranslation(spot._position);
			this.lightPos[cnt][0] = spot._position.x;
			this.lightPos[cnt][1] = spot._position.y;
			this.lightPos[cnt][2] = spot._position.z;
			this.lightPosId[cnt].setValue(this.lightPos[cnt]);
			if (spot.shape !== LIGHTSHAPE_PUNCTUAL) {
				this.setLTCPositionalLight(wtm, cnt);
			}
			wtm.getY(spot._direction).mulScalar(-1);
			spot._direction.normalize();
			this.lightDir[cnt][0] = spot._direction.x;
			this.lightDir[cnt][1] = spot._direction.y;
			this.lightDir[cnt][2] = spot._direction.z;
			this.lightDirId[cnt].setValue(this.lightDir[cnt]);
			if (spot.castShadows) {
				var lightRenderData = spot.getRenderData(null, 0);
				this.lightShadowMapId[cnt].setValue(lightRenderData.shadowBuffer);
				this.lightShadowMatrixId[cnt].setValue(lightRenderData.shadowMatrix.data);
				var biases = spot._getUniformBiasValues(lightRenderData);
				var params = spot._shadowRenderParams;
				params.length = 4;
				params[0] = spot._shadowResolution;
				params[1] = biases.normalBias;
				params[2] = biases.bias;
				params[3] = 1.0 / spot.attenuationEnd;
				this.lightShadowParamsId[cnt].setValue(params);
				this.lightShadowIntensity[cnt].setValue(spot.shadowIntensity);
				var pixelsPerMeter = spot.penumbraSize / lightRenderData.shadowCamera.renderTarget.width;
				var fov = lightRenderData.shadowCamera._fov * Math.PI / 180.0;
				var fovRatio = 1.0 / Math.tan(fov / 2.0);
				this.lightShadowSearchAreaId[cnt].setValue(pixelsPerMeter * fovRatio);
				var cameraParams = spot._shadowCameraParams;
				cameraParams.length = 4;
				cameraParams[0] = lightRenderData.depthRangeCompensation;
				cameraParams[1] = lightRenderData.shadowCamera._farClip;
				cameraParams[2] = lightRenderData.shadowCamera._nearClip;
				cameraParams[3] = 0;
				this.lightCameraParamsId[cnt].setValue(cameraParams);
			}
			if (spot._cookie) {
				if (!spot.castShadows) {
					var cookieMatrix = LightCamera.evalSpotCookieMatrix(spot);
					this.lightShadowMatrixId[cnt].setValue(cookieMatrix.data);
				}
				this.lightCookieId[cnt].setValue(spot._cookie);
				this.lightCookieIntId[cnt].setValue(spot.cookieIntensity);
				if (spot._cookieTransform) {
					spot._cookieTransformUniform[0] = spot._cookieTransform.x;
					spot._cookieTransformUniform[1] = spot._cookieTransform.y;
					spot._cookieTransformUniform[2] = spot._cookieTransform.z;
					spot._cookieTransformUniform[3] = spot._cookieTransform.w;
					this.lightCookieMatrixId[cnt].setValue(spot._cookieTransformUniform);
					spot._cookieOffsetUniform[0] = spot._cookieOffset.x;
					spot._cookieOffsetUniform[1] = spot._cookieOffset.y;
					this.lightCookieOffsetId[cnt].setValue(spot._cookieOffsetUniform);
				}
			}
		};
		_proto.dispatchLocalLights = function dispatchLocalLights(sortedLights, scene, mask, usedDirLights) {
			var cnt = usedDirLights;
			var scope = this.device.scope;
			var omnis = sortedLights[LIGHTTYPE_OMNI];
			var numOmnis = omnis.length;
			for (var i = 0; i < numOmnis; i++) {
				var omni = omnis[i];
				if (!(omni.mask & mask)) continue;
				this.dispatchOmniLight(scene, scope, omni, cnt);
				cnt++;
			}
			var spts = sortedLights[LIGHTTYPE_SPOT];
			var numSpts = spts.length;
			for (var _i2 = 0; _i2 < numSpts; _i2++) {
				var spot = spts[_i2];
				if (!(spot.mask & mask)) continue;
				this.dispatchSpotLight(scene, scope, spot, cnt);
				cnt++;
			}
		};
		_proto.renderForwardPrepareMaterials = function renderForwardPrepareMaterials(camera, drawCalls, sortedLights, layer, pass) {
			var _layer$getLightHash;
			var addCall = function addCall(drawCall, shaderInstance, isNewMaterial, lightMaskChanged) {
				_drawCallList.drawCalls.push(drawCall);
				_drawCallList.shaderInstances.push(shaderInstance);
				_drawCallList.isNewMaterial.push(isNewMaterial);
				_drawCallList.lightMaskChanged.push(lightMaskChanged);
			};
			_drawCallList.clear();
			var device = this.device;
			var scene = this.scene;
			var clusteredLightingEnabled = scene.clusteredLightingEnabled;
			var lightHash = (_layer$getLightHash = layer == null ? void 0 : layer.getLightHash(clusteredLightingEnabled)) != null ? _layer$getLightHash : 0;
			var prevMaterial = null,
				prevObjDefs,
				prevLightMask;
			var drawCallsCount = drawCalls.length;
			for (var i = 0; i < drawCallsCount; i++) {
				var drawCall = drawCalls[i];
				drawCall.ensureMaterial(device);
				var material = drawCall.material;
				var objDefs = drawCall._shaderDefs;
				var lightMask = drawCall.mask;
				if (material && material === prevMaterial && objDefs !== prevObjDefs) {
					prevMaterial = null;
				}
				if (material !== prevMaterial) {
					this._materialSwitches++;
					material._scene = scene;
					if (material.dirty) {
						material.updateUniforms(device, scene);
						material.dirty = false;
					}
				}
				var shaderInstance = drawCall.getShaderInstance(pass, lightHash, scene, this.viewUniformFormat, this.viewBindGroupFormat, sortedLights);
				addCall(drawCall, shaderInstance, material !== prevMaterial, !prevMaterial || lightMask !== prevLightMask);
				prevMaterial = material;
				prevObjDefs = objDefs;
				prevLightMask = lightMask;
			}
			device.endShaderBatch == null || device.endShaderBatch();
			return _drawCallList;
		};
		_proto.renderForwardInternal = function renderForwardInternal(camera, preparedCalls, sortedLights, pass, drawCallback, flipFaces) {
			var device = this.device;
			var scene = this.scene;
			var passFlag = 1 << pass;
			var flipFactor = flipFaces ? -1 : 1;
			var clusteredLightingEnabled = this.scene.clusteredLightingEnabled;
			var skipMaterial = false;
			var preparedCallsCount = preparedCalls.drawCalls.length;
			for (var i = 0; i < preparedCallsCount; i++) {
				var _drawCall$stencilFron, _drawCall$stencilBack;
				var drawCall = preparedCalls.drawCalls[i];
				var newMaterial = preparedCalls.isNewMaterial[i];
				var lightMaskChanged = preparedCalls.lightMaskChanged[i];
				var shaderInstance = preparedCalls.shaderInstances[i];
				var material = drawCall.material;
				drawCall._shaderDefs;
				var lightMask = drawCall.mask;
				if (newMaterial) {
					var shader = shaderInstance.shader;
					if (!shader.failed && !device.setShader(shader)) ;
					skipMaterial = shader.failed;
					if (skipMaterial) break;
					material.setParameters(device);
					if (lightMaskChanged) {
						var usedDirLights = this.dispatchDirectLights(sortedLights[LIGHTTYPE_DIRECTIONAL], scene, lightMask, camera);
						if (!clusteredLightingEnabled) {
							this.dispatchLocalLights(sortedLights, scene, lightMask, usedDirLights);
						}
					}
					this.alphaTestId.setValue(material.alphaTest);
					device.setBlendState(material.blendState);
					device.setDepthState(material.depthState);
					device.setAlphaToCoverage(material.alphaToCoverage);
					if (material.depthBias || material.slopeDepthBias) {
						device.setDepthBias(true);
						device.setDepthBiasValues(material.depthBias, material.slopeDepthBias);
					} else {
						device.setDepthBias(false);
					}
				}
				this.setupCullMode(camera._cullFaces, flipFactor, drawCall);
				var stencilFront = (_drawCall$stencilFron = drawCall.stencilFront) != null ? _drawCall$stencilFron : material.stencilFront;
				var stencilBack = (_drawCall$stencilBack = drawCall.stencilBack) != null ? _drawCall$stencilBack : material.stencilBack;
				device.setStencilState(stencilFront, stencilBack);
				var mesh = drawCall.mesh;
				drawCall.setParameters(device, passFlag);
				this.setVertexBuffers(device, mesh);
				this.setMorphing(device, drawCall.morphInstance);
				this.setSkinning(device, drawCall);
				this.setupMeshUniformBuffers(shaderInstance, drawCall);
				var style = drawCall.renderStyle;
				device.setIndexBuffer(mesh.indexBuffer[style]);
				drawCallback == null || drawCallback(drawCall, i);
				if (camera.xr && camera.xr.session && camera.xr.views.length) {
					var views = camera.xr.views;
					for (var v = 0; v < views.length; v++) {
						var view = views[v];
						device.setViewport(view.viewport.x, view.viewport.y, view.viewport.z, view.viewport.w);
						this.projId.setValue(view.projMat.data);
						this.projSkyboxId.setValue(view.projMat.data);
						this.viewId.setValue(view.viewOffMat.data);
						this.viewInvId.setValue(view.viewInvOffMat.data);
						this.viewId3.setValue(view.viewMat3.data);
						this.viewProjId.setValue(view.projViewOffMat.data);
						this.viewPosId.setValue(view.position);
						if (v === 0) {
							this.drawInstance(device, drawCall, mesh, style, true);
						} else {
							this.drawInstance2(device, drawCall, mesh, style);
						}
						this._forwardDrawCalls++;
					}
				} else {
					this.drawInstance(device, drawCall, mesh, style, true);
					this._forwardDrawCalls++;
				}
				if (i < preparedCallsCount - 1 && !preparedCalls.isNewMaterial[i + 1]) {
					material.setParameters(device, drawCall.parameters);
				}
			}
		};
		_proto.renderForward = function renderForward(camera, allDrawCalls, sortedLights, pass, drawCallback, layer, flipFaces) {
			var preparedCalls = this.renderForwardPrepareMaterials(camera, allDrawCalls, sortedLights, layer, pass);
			this.renderForwardInternal(camera, preparedCalls, sortedLights, pass, drawCallback, flipFaces);
			_drawCallList.clear();
		};
		_proto.setSceneConstants = function setSceneConstants() {
			var scene = this.scene;
			this.dispatchGlobalLights(scene);
			if (scene.fog !== FOG_NONE) {
				this.fogColor[0] = scene.fogColor.r;
				this.fogColor[1] = scene.fogColor.g;
				this.fogColor[2] = scene.fogColor.b;
				if (scene.gammaCorrection) {
					for (var i = 0; i < 3; i++) {
						this.fogColor[i] = Math.pow(this.fogColor[i], 2.2);
					}
				}
				this.fogColorId.setValue(this.fogColor);
				if (scene.fog === FOG_LINEAR) {
					this.fogStartId.setValue(scene.fogStart);
					this.fogEndId.setValue(scene.fogEnd);
				} else {
					this.fogDensityId.setValue(scene.fogDensity);
				}
			}
			var device = this.device;
			this._screenSize[0] = device.width;
			this._screenSize[1] = device.height;
			this._screenSize[2] = 1 / device.width;
			this._screenSize[3] = 1 / device.height;
			this.screenSizeId.setValue(this._screenSize);
			this.pcssDiskSamplesId.setValue(this.pcssDiskSamples);
			this.pcssSphereSamplesId.setValue(this.pcssSphereSamples);
		};
		_proto.buildFrameGraph = function buildFrameGraph(frameGraph, layerComposition) {
			var scene = this.scene;
			var webgl1 = this.device.isWebGL1;
			frameGraph.reset();
			this.update(layerComposition);
			if (scene.clusteredLightingEnabled) {
				var _scene$lighting = scene.lighting,
					shadowsEnabled = _scene$lighting.shadowsEnabled,
					cookiesEnabled = _scene$lighting.cookiesEnabled;
				this._renderPassUpdateClustered.update(frameGraph, shadowsEnabled, cookiesEnabled, this.lights, this.localLights);
				frameGraph.addRenderPass(this._renderPassUpdateClustered);
			} else {
				this._shadowRendererLocal.buildNonClusteredRenderPasses(frameGraph, this.localLights);
			}
			var startIndex = 0;
			var newStart = true;
			var renderTarget = null;
			var renderActions = layerComposition._renderActions;
			for (var i = startIndex; i < renderActions.length; i++) {
				var renderAction = renderActions[i];
				var layer = renderAction.layer,
					camera = renderAction.camera;
				if (renderAction.useCameraPasses) {
					camera.camera.renderPasses.forEach(function (renderPass) {
						frameGraph.addRenderPass(renderPass);
					});
				} else {
					var depthPass = camera.camera.renderPassDepthGrab;
					if (depthPass && webgl1 && renderAction.firstCameraUse) {
						depthPass.update(this.scene);
						frameGraph.addRenderPass(depthPass);
					}
					var isDepthLayer = layer.id === LAYERID_DEPTH;
					if (webgl1 && isDepthLayer && !camera.renderSceneColorMap) continue;
					var isGrabPass = isDepthLayer && (camera.renderSceneColorMap || camera.renderSceneDepthMap);
					if (renderAction.hasDirectionalShadowLights && camera) {
						this._shadowRendererDirectional.buildFrameGraph(frameGraph, renderAction.directionalLights, camera);
					}
					if (newStart) {
						newStart = false;
						startIndex = i;
						renderTarget = renderAction.renderTarget;
					}
					var nextRenderAction = renderActions[i + 1];
					var isNextLayerDepth = nextRenderAction ? nextRenderAction.layer.id === LAYERID_DEPTH : false;
					var isNextLayerGrabPass = isNextLayerDepth && (camera.renderSceneColorMap || camera.renderSceneDepthMap) && !webgl1;
					if (!nextRenderAction || nextRenderAction.renderTarget !== renderTarget || nextRenderAction.hasDirectionalShadowLights || isNextLayerGrabPass || isGrabPass) {
						var isDepthOnly = isDepthLayer && startIndex === i;
						if (!isDepthOnly) {
							this.addMainRenderPass(frameGraph, layerComposition, renderTarget, startIndex, i);
						}
						if (isDepthLayer) {
							if (camera.renderSceneColorMap) {
								frameGraph.addRenderPass(camera.camera.renderPassColorGrab);
							}
							if (camera.renderSceneDepthMap && !webgl1) {
								frameGraph.addRenderPass(camera.camera.renderPassDepthGrab);
							}
						}
						if (renderAction.triggerPostprocess && camera != null && camera.onPostprocessing) {
							var renderPass = new RenderPassPostprocessing(this.device, this, renderAction);
							frameGraph.addRenderPass(renderPass);
						}
						newStart = true;
					}
				}
			}
		};
		_proto.addMainRenderPass = function addMainRenderPass(frameGraph, layerComposition, renderTarget, startIndex, endIndex) {
			var renderPass = new RenderPassRenderActions(this.device, layerComposition, this.scene, this);
			renderPass.init(renderTarget);
			var renderActions = layerComposition._renderActions;
			for (var i = startIndex; i <= endIndex; i++) {
				renderPass.addRenderAction(renderActions[i]);
			}
			frameGraph.addRenderPass(renderPass);
		};
		_proto.update = function update(comp) {
			this.frameUpdate();
			this.shadowRenderer.frameUpdate();
			this.scene._updateSky(this.device);
			this.updateLayerComposition(comp);
			this.collectLights(comp);
			this.beginFrame(comp);
			this.setSceneConstants();
			this.cullComposition(comp);
			this.gpuUpdate(this.processingMeshInstances);
		};
		return ForwardRenderer;
	}(Renderer);

	function sortManual(drawCallA, drawCallB) {
		return drawCallA.drawOrder - drawCallB.drawOrder;
	}
	function sortMaterialMesh(drawCallA, drawCallB) {
		var keyA = drawCallA._key[SORTKEY_FORWARD];
		var keyB = drawCallB._key[SORTKEY_FORWARD];
		if (keyA === keyB && drawCallA.mesh && drawCallB.mesh) {
			return drawCallB.mesh.id - drawCallA.mesh.id;
		}
		return keyB - keyA;
	}
	function sortBackToFront(drawCallA, drawCallB) {
		return drawCallB.zdist - drawCallA.zdist;
	}
	function sortFrontToBack(drawCallA, drawCallB) {
		return drawCallA.zdist - drawCallB.zdist;
	}
	var sortCallbacks = [null, sortManual, sortMaterialMesh, sortBackToFront, sortFrontToBack];
	var layerCounter = 0;
	var lightKeys = [];
	var _tempMaterials = new Set();
	var CulledInstances = function CulledInstances() {
		this.opaque = [];
		this.transparent = [];
	};
	var Layer = function () {
		function Layer(options) {
			var _options$enabled, _options$opaqueSortMo, _options$transparentS, _options$shaderPass;
			if (options === void 0) {
				options = {};
			}
			this.meshInstances = [];
			this.meshInstancesSet = new Set();
			this.shadowCasters = [];
			this.shadowCastersSet = new Set();
			this._visibleInstances = new WeakMap();
			this._lights = [];
			this._lightsSet = new Set();
			this._clusteredLightsSet = new Set();
			this._splitLights = [[], [], []];
			this._splitLightsDirty = true;
			this.requiresLightCube = false;
			this.cameras = [];
			this.camerasSet = new Set();
			this._dirtyComposition = false;
			if (options.id !== undefined) {
				this.id = options.id;
				layerCounter = Math.max(this.id + 1, layerCounter);
			} else {
				this.id = layerCounter++;
			}
			this.name = options.name;
			this._enabled = (_options$enabled = options.enabled) != null ? _options$enabled : true;
			this._refCounter = this._enabled ? 1 : 0;
			this.opaqueSortMode = (_options$opaqueSortMo = options.opaqueSortMode) != null ? _options$opaqueSortMo : SORTMODE_MATERIALMESH;
			this.transparentSortMode = (_options$transparentS = options.transparentSortMode) != null ? _options$transparentS : SORTMODE_BACK2FRONT;
			if (options.renderTarget) {
				this.renderTarget = options.renderTarget;
			}
			this.shaderPass = (_options$shaderPass = options.shaderPass) != null ? _options$shaderPass : SHADER_FORWARD;
			this._clearColorBuffer = !!options.clearColorBuffer;
			this._clearDepthBuffer = !!options.clearDepthBuffer;
			this._clearStencilBuffer = !!options.clearStencilBuffer;
			this.onPreCull = options.onPreCull;
			this.onPreRender = options.onPreRender;
			this.onPreRenderOpaque = options.onPreRenderOpaque;
			this.onPreRenderTransparent = options.onPreRenderTransparent;
			this.onPostCull = options.onPostCull;
			this.onPostRender = options.onPostRender;
			this.onPostRenderOpaque = options.onPostRenderOpaque;
			this.onPostRenderTransparent = options.onPostRenderTransparent;
			this.onDrawCall = options.onDrawCall;
			this.onEnable = options.onEnable;
			this.onDisable = options.onDisable;
			if (this._enabled && this.onEnable) {
				this.onEnable();
			}
			this.layerReference = options.layerReference;
			this.customSortCallback = null;
			this.customCalculateSortValues = null;
			this._lightHash = 0;
			this._lightHashDirty = false;
			this._lightIdHash = 0;
			this._lightIdHashDirty = false;
			this._shaderVersion = -1;
		}
		var _proto = Layer.prototype;
		_proto.incrementCounter = function incrementCounter() {
			if (this._refCounter === 0) {
				this._enabled = true;
				if (this.onEnable) this.onEnable();
			}
			this._refCounter++;
		};
		_proto.decrementCounter = function decrementCounter() {
			if (this._refCounter === 1) {
				this._enabled = false;
				if (this.onDisable) this.onDisable();
			} else if (this._refCounter === 0) {
				return;
			}
			this._refCounter--;
		};
		_proto.addMeshInstances = function addMeshInstances(meshInstances, skipShadowCasters) {
			var destMeshInstances = this.meshInstances;
			var destMeshInstancesSet = this.meshInstancesSet;
			for (var i = 0; i < meshInstances.length; i++) {
				var mi = meshInstances[i];
				if (!destMeshInstancesSet.has(mi)) {
					destMeshInstances.push(mi);
					destMeshInstancesSet.add(mi);
					_tempMaterials.add(mi.material);
				}
			}
			if (!skipShadowCasters) {
				this.addShadowCasters(meshInstances);
			}
			if (_tempMaterials.size > 0) {
				var sceneShaderVer = this._shaderVersion;
				_tempMaterials.forEach(function (mat) {
					if (sceneShaderVer >= 0 && mat._shaderVersion !== sceneShaderVer) {
						if (mat.getShaderVariant !== Material.prototype.getShaderVariant) {
							mat.clearVariants();
						}
						mat._shaderVersion = sceneShaderVer;
					}
				});
				_tempMaterials.clear();
			}
		};
		_proto.removeMeshInstances = function removeMeshInstances(meshInstances, skipShadowCasters) {
			var destMeshInstances = this.meshInstances;
			var destMeshInstancesSet = this.meshInstancesSet;
			for (var i = 0; i < meshInstances.length; i++) {
				var mi = meshInstances[i];
				if (destMeshInstancesSet.has(mi)) {
					destMeshInstancesSet.delete(mi);
					var j = destMeshInstances.indexOf(mi);
					if (j >= 0) {
						destMeshInstances.splice(j, 1);
					}
				}
			}
			if (!skipShadowCasters) {
				this.removeShadowCasters(meshInstances);
			}
		};
		_proto.addShadowCasters = function addShadowCasters(meshInstances) {
			var shadowCasters = this.shadowCasters;
			var shadowCastersSet = this.shadowCastersSet;
			for (var i = 0; i < meshInstances.length; i++) {
				var mi = meshInstances[i];
				if (mi.castShadow && !shadowCastersSet.has(mi)) {
					shadowCastersSet.add(mi);
					shadowCasters.push(mi);
				}
			}
		};
		_proto.removeShadowCasters = function removeShadowCasters(meshInstances) {
			var shadowCasters = this.shadowCasters;
			var shadowCastersSet = this.shadowCastersSet;
			for (var i = 0; i < meshInstances.length; i++) {
				var mi = meshInstances[i];
				if (shadowCastersSet.has(mi)) {
					shadowCastersSet.delete(mi);
					var j = shadowCasters.indexOf(mi);
					if (j >= 0) {
						shadowCasters.splice(j, 1);
					}
				}
			}
		};
		_proto.clearMeshInstances = function clearMeshInstances(skipShadowCasters) {
			if (skipShadowCasters === void 0) {
				skipShadowCasters = false;
			}
			this.meshInstances.length = 0;
			this.meshInstancesSet.clear();
			if (!skipShadowCasters) {
				this.shadowCasters.length = 0;
				this.shadowCastersSet.clear();
			}
		};
		_proto.markLightsDirty = function markLightsDirty() {
			this._lightHashDirty = true;
			this._lightIdHashDirty = true;
			this._splitLightsDirty = true;
		};
		_proto.addLight = function addLight(light) {
			var l = light.light;
			if (!this._lightsSet.has(l)) {
				this._lightsSet.add(l);
				this._lights.push(l);
				this.markLightsDirty();
			}
			if (l.type !== LIGHTTYPE_DIRECTIONAL) {
				this._clusteredLightsSet.add(l);
			}
		};
		_proto.removeLight = function removeLight(light) {
			var l = light.light;
			if (this._lightsSet.has(l)) {
				this._lightsSet.delete(l);
				this._lights.splice(this._lights.indexOf(l), 1);
				this.markLightsDirty();
			}
			if (l.type !== LIGHTTYPE_DIRECTIONAL) {
				this._clusteredLightsSet.delete(l);
			}
		};
		_proto.clearLights = function clearLights() {
			var _this = this;
			this._lightsSet.forEach(function (light) {
				return light.removeLayer(_this);
			});
			this._lightsSet.clear();
			this._clusteredLightsSet.clear();
			this._lights.length = 0;
			this.markLightsDirty();
		};
		_proto.evaluateLightHash = function evaluateLightHash(localLights, directionalLights, useIds) {
			var hash = 0;
			var lights = this._lights;
			for (var i = 0; i < lights.length; i++) {
				var isLocalLight = lights[i].type !== LIGHTTYPE_DIRECTIONAL;
				if (localLights && isLocalLight || directionalLights && !isLocalLight) {
					lightKeys.push(useIds ? lights[i].id : lights[i].key);
				}
			}
			if (lightKeys.length > 0) {
				lightKeys.sort();
				hash = hash32Fnv1a(lightKeys);
				lightKeys.length = 0;
			}
			return hash;
		};
		_proto.getLightHash = function getLightHash(isClustered) {
			if (this._lightHashDirty) {
				this._lightHashDirty = false;
				this._lightHash = this.evaluateLightHash(!isClustered, true, false);
			}
			return this._lightHash;
		};
		_proto.getLightIdHash = function getLightIdHash() {
			if (this._lightIdHashDirty) {
				this._lightIdHashDirty = false;
				this._lightIdHash = this.evaluateLightHash(true, false, true);
			}
			return this._lightIdHash;
		};
		_proto.addCamera = function addCamera(camera) {
			if (!this.camerasSet.has(camera.camera)) {
				this.camerasSet.add(camera.camera);
				this.cameras.push(camera);
				this._dirtyComposition = true;
			}
		};
		_proto.removeCamera = function removeCamera(camera) {
			if (this.camerasSet.has(camera.camera)) {
				this.camerasSet.delete(camera.camera);
				var index = this.cameras.indexOf(camera);
				this.cameras.splice(index, 1);
				this._dirtyComposition = true;
			}
		};
		_proto.clearCameras = function clearCameras() {
			this.cameras.length = 0;
			this.camerasSet.clear();
			this._dirtyComposition = true;
		};
		_proto._calculateSortDistances = function _calculateSortDistances(drawCalls, drawCallsCount, camPos, camFwd) {
			for (var i = 0; i < drawCallsCount; i++) {
				var drawCall = drawCalls[i];
				if (drawCall.layer <= LAYER_FX) continue;
				if (drawCall.calculateSortDistance) {
					drawCall.zdist = drawCall.calculateSortDistance(drawCall, camPos, camFwd);
					continue;
				}
				var meshPos = drawCall.aabb.center;
				var tempx = meshPos.x - camPos.x;
				var tempy = meshPos.y - camPos.y;
				var tempz = meshPos.z - camPos.z;
				drawCall.zdist = tempx * camFwd.x + tempy * camFwd.y + tempz * camFwd.z;
			}
		};
		_proto.getCulledInstances = function getCulledInstances(camera) {
			var instances = this._visibleInstances.get(camera);
			if (!instances) {
				instances = new CulledInstances();
				this._visibleInstances.set(camera, instances);
			}
			return instances;
		};
		_proto.sortVisible = function sortVisible(camera, transparent) {
			var sortMode = transparent ? this.transparentSortMode : this.opaqueSortMode;
			if (sortMode === SORTMODE_NONE) return;
			var culledInstances = this.getCulledInstances(camera);
			var instances = transparent ? culledInstances.transparent : culledInstances.opaque;
			var cameraNode = camera.node;
			if (sortMode === SORTMODE_CUSTOM) {
				var sortPos = cameraNode.getPosition();
				var sortDir = cameraNode.forward;
				if (this.customCalculateSortValues) {
					this.customCalculateSortValues(instances, instances.length, sortPos, sortDir);
				}
				if (this.customSortCallback) {
					instances.sort(this.customSortCallback);
				}
			} else {
				if (sortMode === SORTMODE_BACK2FRONT || sortMode === SORTMODE_FRONT2BACK) {
					var _sortPos = cameraNode.getPosition();
					var _sortDir = cameraNode.forward;
					this._calculateSortDistances(instances, instances.length, _sortPos, _sortDir);
				}
				instances.sort(sortCallbacks[sortMode]);
			}
		};
		_createClass(Layer, [{
			key: "enabled",
			get: function get() {
				return this._enabled;
			},
			set: function set(val) {
				if (val !== this._enabled) {
					this._dirtyComposition = true;
					this._enabled = val;
					if (val) {
						this.incrementCounter();
						if (this.onEnable) this.onEnable();
					} else {
						this.decrementCounter();
						if (this.onDisable) this.onDisable();
					}
				}
			}
		}, {
			key: "clearColorBuffer",
			get: function get() {
				return this._clearColorBuffer;
			},
			set: function set(val) {
				this._clearColorBuffer = val;
				this._dirtyComposition = true;
			}
		}, {
			key: "clearDepthBuffer",
			get: function get() {
				return this._clearDepthBuffer;
			},
			set: function set(val) {
				this._clearDepthBuffer = val;
				this._dirtyComposition = true;
			}
		}, {
			key: "clearStencilBuffer",
			get: function get() {
				return this._clearStencilBuffer;
			},
			set: function set(val) {
				this._clearStencilBuffer = val;
				this._dirtyComposition = true;
			}
		}, {
			key: "hasClusteredLights",
			get: function get() {
				return this._clusteredLightsSet.size > 0;
			}
		}, {
			key: "clusteredLightsSet",
			get: function get() {
				return this._clusteredLightsSet;
			}
		}, {
			key: "splitLights",
			get: function get() {
				if (this._splitLightsDirty) {
					this._splitLightsDirty = false;
					var splitLights = this._splitLights;
					for (var i = 0; i < splitLights.length; i++) splitLights[i].length = 0;
					var lights = this._lights;
					for (var _i = 0; _i < lights.length; _i++) {
						var light = lights[_i];
						if (light.enabled) {
							splitLights[light._type].push(light);
						}
					}
					for (var _i2 = 0; _i2 < splitLights.length; _i2++) splitLights[_i2].sort(function (a, b) {
						return a.key - b.key;
					});
				}
				return this._splitLights;
			}
		}]);
		return Layer;
	}();

	var cmpPriority = function cmpPriority(a, b) {
		return a.priority - b.priority;
	};
	var sortPriority = function sortPriority(arr) {
		return arr.sort(cmpPriority);
	};

	var LayerComposition = function (_EventHandler) {
		_inheritsLoose(LayerComposition, _EventHandler);
		function LayerComposition(name) {
			var _this;
			if (name === void 0) {
				name = 'Untitled';
			}
			_this = _EventHandler.call(this) || this;
			_this.layerList = [];
			_this.layerIdMap = new Map();
			_this.layerNameMap = new Map();
			_this.layerOpaqueIndexMap = new Map();
			_this.layerTransparentIndexMap = new Map();
			_this.subLayerList = [];
			_this.subLayerEnabled = [];
			_this.cameras = [];
			_this.camerasMap = new Map();
			_this._renderActions = [];
			_this._dirty = false;
			_this.name = name;
			_this._opaqueOrder = {};
			_this._transparentOrder = {};
			return _this;
		}
		var _proto = LayerComposition.prototype;
		_proto.destroy = function destroy() {
			this.destroyRenderActions();
		};
		_proto.destroyRenderActions = function destroyRenderActions() {
			this._renderActions.forEach(function (ra) {
				return ra.destroy();
			});
			this._renderActions.length = 0;
		};
		_proto._update = function _update() {
			var len = this.layerList.length;
			if (!this._dirty) {
				for (var i = 0; i < len; i++) {
					if (this.layerList[i]._dirtyComposition) {
						this._dirty = true;
						break;
					}
				}
			}
			if (this._dirty) {
				this._dirty = false;
				this.cameras.length = 0;
				for (var _i = 0; _i < len; _i++) {
					var layer = this.layerList[_i];
					layer._dirtyComposition = false;
					for (var j = 0; j < layer.cameras.length; j++) {
						var camera = layer.cameras[j];
						var index = this.cameras.indexOf(camera);
						if (index < 0) {
							this.cameras.push(camera);
						}
					}
				}
				if (this.cameras.length > 1) {
					sortPriority(this.cameras);
				}
				this.camerasMap.clear();
				for (var _i2 = 0; _i2 < this.cameras.length; _i2++) {
					this.camerasMap.set(this.cameras[_i2], _i2);
				}
				var cameraLayers = [];
				var renderActionCount = 0;
				this.destroyRenderActions();
				for (var _i3 = 0; _i3 < this.cameras.length; _i3++) {
					var _camera = this.cameras[_i3];
					cameraLayers.length = 0;
					if (_camera.camera.renderPasses.length > 0) {
						this.addDummyRenderAction(renderActionCount, _camera);
						continue;
					}
					var cameraFirstRenderAction = true;
					var cameraFirstRenderActionIndex = renderActionCount;
					var lastRenderAction = null;
					var postProcessMarked = false;
					for (var _j = 0; _j < len; _j++) {
						var _layer = this.layerList[_j];
						var isLayerEnabled = _layer.enabled && this.subLayerEnabled[_j];
						if (isLayerEnabled) {
							if (_layer.cameras.length > 0) {
								if (_camera.layers.indexOf(_layer.id) >= 0) {
									cameraLayers.push(_layer);
									if (!postProcessMarked && _layer.id === _camera.disablePostEffectsLayer) {
										postProcessMarked = true;
										if (lastRenderAction) {
											lastRenderAction.triggerPostprocess = true;
										}
									}
									var isTransparent = this.subLayerList[_j];
									lastRenderAction = this.addRenderAction(renderActionCount, _layer, isTransparent, _camera, cameraFirstRenderAction, postProcessMarked);
									renderActionCount++;
									cameraFirstRenderAction = false;
								}
							}
						}
					}
					if (cameraFirstRenderActionIndex < renderActionCount) {
						lastRenderAction.lastCameraUse = true;
					}
					if (!postProcessMarked && lastRenderAction) {
						lastRenderAction.triggerPostprocess = true;
					}
					if (_camera.renderTarget && _camera.postEffectsEnabled) {
						this.propagateRenderTarget(cameraFirstRenderActionIndex - 1, _camera);
					}
				}
				this._logRenderActions();
			}
		};
		_proto.getNextRenderAction = function getNextRenderAction(renderActionIndex) {
			var renderAction = new RenderAction();
			this._renderActions.push(renderAction);
			return renderAction;
		};
		_proto.addDummyRenderAction = function addDummyRenderAction(renderActionIndex, camera) {
			var renderAction = this.getNextRenderAction(renderActionIndex);
			renderAction.camera = camera;
			renderAction.useCameraPasses = true;
		};
		_proto.addRenderAction = function addRenderAction(renderActionIndex, layer, isTransparent, camera, cameraFirstRenderAction, postProcessMarked) {
			var rt = layer.renderTarget;
			if (camera && camera.renderTarget) {
				if (layer.id !== LAYERID_DEPTH) {
					rt = camera.renderTarget;
				}
			}
			var used = false;
			var renderActions = this._renderActions;
			for (var i = renderActionIndex - 1; i >= 0; i--) {
				if (renderActions[i].camera === camera && renderActions[i].renderTarget === rt) {
					used = true;
					break;
				}
			}
			if (postProcessMarked && camera.postEffectsEnabled) {
				rt = null;
			}
			var renderAction = this.getNextRenderAction(renderActionIndex);
			renderAction.triggerPostprocess = false;
			renderAction.layer = layer;
			renderAction.transparent = isTransparent;
			renderAction.camera = camera;
			renderAction.renderTarget = rt;
			renderAction.firstCameraUse = cameraFirstRenderAction;
			renderAction.lastCameraUse = false;
			var needsClear = cameraFirstRenderAction || !used;
			if (needsClear) {
				renderAction.setupClears(needsClear ? camera : undefined, layer);
			}
			return renderAction;
		};
		_proto.propagateRenderTarget = function propagateRenderTarget(startIndex, fromCamera) {
			for (var a = startIndex; a >= 0; a--) {
				var ra = this._renderActions[a];
				var layer = ra.layer;
				if (ra.renderTarget && layer.id !== LAYERID_DEPTH) {
					break;
				}
				if (layer.id === LAYERID_DEPTH) {
					continue;
				}
				if (ra.useCameraPasses) {
					break;
				}
				var thisCamera = ra == null ? void 0 : ra.camera.camera;
				if (thisCamera) {
					if (!fromCamera.camera.rect.equals(thisCamera.rect) || !fromCamera.camera.scissorRect.equals(thisCamera.scissorRect)) {
						break;
					}
				}
				ra.renderTarget = fromCamera.renderTarget;
			}
		};
		_proto._logRenderActions = function _logRenderActions() {};
		_proto._isLayerAdded = function _isLayerAdded(layer) {
			var found = this.layerIdMap.get(layer.id) === layer;
			return found;
		};
		_proto._isSublayerAdded = function _isSublayerAdded(layer, transparent) {
			var map = transparent ? this.layerTransparentIndexMap : this.layerOpaqueIndexMap;
			if (map.get(layer) !== undefined) {
				return true;
			}
			return false;
		};
		_proto.push = function push(layer) {
			if (this._isLayerAdded(layer)) return;
			this.layerList.push(layer);
			this.layerList.push(layer);
			this._opaqueOrder[layer.id] = this.subLayerList.push(false) - 1;
			this._transparentOrder[layer.id] = this.subLayerList.push(true) - 1;
			this.subLayerEnabled.push(true);
			this.subLayerEnabled.push(true);
			this._updateLayerMaps();
			this._dirty = true;
			this.fire('add', layer);
		};
		_proto.insert = function insert(layer, index) {
			if (this._isLayerAdded(layer)) return;
			this.layerList.splice(index, 0, layer, layer);
			this.subLayerList.splice(index, 0, false, true);
			var count = this.layerList.length;
			this._updateOpaqueOrder(index, count - 1);
			this._updateTransparentOrder(index, count - 1);
			this.subLayerEnabled.splice(index, 0, true, true);
			this._updateLayerMaps();
			this._dirty = true;
			this.fire('add', layer);
		};
		_proto.remove = function remove(layer) {
			var id = this.layerList.indexOf(layer);
			delete this._opaqueOrder[id];
			delete this._transparentOrder[id];
			while (id >= 0) {
				this.layerList.splice(id, 1);
				this.subLayerList.splice(id, 1);
				this.subLayerEnabled.splice(id, 1);
				id = this.layerList.indexOf(layer);
				this._dirty = true;
				this.fire('remove', layer);
			}
			var count = this.layerList.length;
			this._updateOpaqueOrder(0, count - 1);
			this._updateTransparentOrder(0, count - 1);
			this._updateLayerMaps();
		};
		_proto.pushOpaque = function pushOpaque(layer) {
			if (this._isSublayerAdded(layer, false)) return;
			this.layerList.push(layer);
			this._opaqueOrder[layer.id] = this.subLayerList.push(false) - 1;
			this.subLayerEnabled.push(true);
			this._updateLayerMaps();
			this._dirty = true;
			this.fire('add', layer);
		};
		_proto.insertOpaque = function insertOpaque(layer, index) {
			if (this._isSublayerAdded(layer, false)) return;
			this.layerList.splice(index, 0, layer);
			this.subLayerList.splice(index, 0, false);
			var count = this.subLayerList.length;
			this._updateOpaqueOrder(index, count - 1);
			this.subLayerEnabled.splice(index, 0, true);
			this._updateLayerMaps();
			this._dirty = true;
			this.fire('add', layer);
		};
		_proto.removeOpaque = function removeOpaque(layer) {
			for (var i = 0, len = this.layerList.length; i < len; i++) {
				if (this.layerList[i] === layer && !this.subLayerList[i]) {
					this.layerList.splice(i, 1);
					this.subLayerList.splice(i, 1);
					len--;
					this._updateOpaqueOrder(i, len - 1);
					this.subLayerEnabled.splice(i, 1);
					this._dirty = true;
					if (this.layerList.indexOf(layer) < 0) {
						this.fire('remove', layer);
					}
					break;
				}
			}
			this._updateLayerMaps();
		};
		_proto.pushTransparent = function pushTransparent(layer) {
			if (this._isSublayerAdded(layer, true)) return;
			this.layerList.push(layer);
			this._transparentOrder[layer.id] = this.subLayerList.push(true) - 1;
			this.subLayerEnabled.push(true);
			this._updateLayerMaps();
			this._dirty = true;
			this.fire('add', layer);
		};
		_proto.insertTransparent = function insertTransparent(layer, index) {
			if (this._isSublayerAdded(layer, true)) return;
			this.layerList.splice(index, 0, layer);
			this.subLayerList.splice(index, 0, true);
			var count = this.subLayerList.length;
			this._updateTransparentOrder(index, count - 1);
			this.subLayerEnabled.splice(index, 0, true);
			this._updateLayerMaps();
			this._dirty = true;
			this.fire('add', layer);
		};
		_proto.removeTransparent = function removeTransparent(layer) {
			for (var i = 0, len = this.layerList.length; i < len; i++) {
				if (this.layerList[i] === layer && this.subLayerList[i]) {
					this.layerList.splice(i, 1);
					this.subLayerList.splice(i, 1);
					len--;
					this._updateTransparentOrder(i, len - 1);
					this.subLayerEnabled.splice(i, 1);
					this._dirty = true;
					if (this.layerList.indexOf(layer) < 0) {
						this.fire('remove', layer);
					}
					break;
				}
			}
			this._updateLayerMaps();
		};
		_proto.getOpaqueIndex = function getOpaqueIndex(layer) {
			var _this$layerOpaqueInde;
			return (_this$layerOpaqueInde = this.layerOpaqueIndexMap.get(layer)) != null ? _this$layerOpaqueInde : -1;
		};
		_proto.getTransparentIndex = function getTransparentIndex(layer) {
			var _this$layerTransparen;
			return (_this$layerTransparen = this.layerTransparentIndexMap.get(layer)) != null ? _this$layerTransparen : -1;
		};
		_proto.isEnabled = function isEnabled(layer, transparent) {
			var index = transparent ? this.getTransparentIndex(layer) : this.getOpaqueIndex(layer);
			return this.subLayerEnabled[index];
		};
		_proto._updateLayerMaps = function _updateLayerMaps() {
			this.layerIdMap.clear();
			this.layerNameMap.clear();
			this.layerOpaqueIndexMap.clear();
			this.layerTransparentIndexMap.clear();
			for (var i = 0; i < this.layerList.length; i++) {
				var layer = this.layerList[i];
				this.layerIdMap.set(layer.id, layer);
				this.layerNameMap.set(layer.name, layer);
				var subLayerIndexMap = this.subLayerList[i] ? this.layerTransparentIndexMap : this.layerOpaqueIndexMap;
				subLayerIndexMap.set(layer, i);
			}
		};
		_proto.getLayerById = function getLayerById(id) {
			var _this$layerIdMap$get;
			return (_this$layerIdMap$get = this.layerIdMap.get(id)) != null ? _this$layerIdMap$get : null;
		};
		_proto.getLayerByName = function getLayerByName(name) {
			var _this$layerNameMap$ge;
			return (_this$layerNameMap$ge = this.layerNameMap.get(name)) != null ? _this$layerNameMap$ge : null;
		};
		_proto._updateOpaqueOrder = function _updateOpaqueOrder(startIndex, endIndex) {
			for (var i = startIndex; i <= endIndex; i++) {
				if (this.subLayerList[i] === false) {
					this._opaqueOrder[this.layerList[i].id] = i;
				}
			}
		};
		_proto._updateTransparentOrder = function _updateTransparentOrder(startIndex, endIndex) {
			for (var i = startIndex; i <= endIndex; i++) {
				if (this.subLayerList[i] === true) {
					this._transparentOrder[this.layerList[i].id] = i;
				}
			}
		};
		_proto._sortLayersDescending = function _sortLayersDescending(layersA, layersB, order) {
			var topLayerA = -1;
			var topLayerB = -1;
			for (var i = 0, len = layersA.length; i < len; i++) {
				var id = layersA[i];
				if (order.hasOwnProperty(id)) {
					topLayerA = Math.max(topLayerA, order[id]);
				}
			}
			for (var _i4 = 0, _len = layersB.length; _i4 < _len; _i4++) {
				var _id = layersB[_i4];
				if (order.hasOwnProperty(_id)) {
					topLayerB = Math.max(topLayerB, order[_id]);
				}
			}
			if (topLayerA === -1 && topLayerB !== -1) {
				return 1;
			} else if (topLayerB === -1 && topLayerA !== -1) {
				return -1;
			}
			return topLayerB - topLayerA;
		};
		_proto.sortTransparentLayers = function sortTransparentLayers(layersA, layersB) {
			return this._sortLayersDescending(layersA, layersB, this._transparentOrder);
		};
		_proto.sortOpaqueLayers = function sortOpaqueLayers(layersA, layersB) {
			return this._sortLayersDescending(layersA, layersB, this._opaqueOrder);
		};
		return LayerComposition;
	}(EventHandler);

	var tmpVec = new Vec3();
	var tmpBiases = {
		bias: 0,
		normalBias: 0
	};
	var chanId = {
		r: 0,
		g: 1,
		b: 2,
		a: 3
	};
	var lightTypes = {
		'directional': LIGHTTYPE_DIRECTIONAL,
		'omni': LIGHTTYPE_OMNI,
		'point': LIGHTTYPE_OMNI,
		'spot': LIGHTTYPE_SPOT
	};
	var directionalCascades = [[new Vec4(0, 0, 1, 1)], [new Vec4(0, 0, 0.5, 0.5), new Vec4(0, 0.5, 0.5, 0.5)], [new Vec4(0, 0, 0.5, 0.5), new Vec4(0, 0.5, 0.5, 0.5), new Vec4(0.5, 0, 0.5, 0.5)], [new Vec4(0, 0, 0.5, 0.5), new Vec4(0, 0.5, 0.5, 0.5), new Vec4(0.5, 0, 0.5, 0.5), new Vec4(0.5, 0.5, 0.5, 0.5)]];
	var id = 0;
	var LightRenderData = function () {
		function LightRenderData(device, camera, face, light) {
			this.light = light;
			this.camera = camera;
			this.shadowCamera = ShadowRenderer.createShadowCamera(device, light._shadowType, light._type, face);
			this.shadowMatrix = new Mat4();
			this.shadowViewport = new Vec4(0, 0, 1, 1);
			this.shadowScissor = new Vec4(0, 0, 1, 1);
			this.depthRangeCompensation = 0;
			this.projectionCompensation = 0;
			this.face = face;
			this.visibleCasters = [];
			this.viewBindGroups = [];
		}
		var _proto = LightRenderData.prototype;
		_proto.destroy = function destroy() {
			this.viewBindGroups.forEach(function (bg) {
				bg.defaultUniformBuffer.destroy();
				bg.destroy();
			});
			this.viewBindGroups.length = 0;
		};
		_createClass(LightRenderData, [{
			key: "shadowBuffer",
			get: function get() {
				var rt = this.shadowCamera.renderTarget;
				if (rt) {
					var light = this.light;
					if (light._type === LIGHTTYPE_OMNI) {
						return rt.colorBuffer;
					}
					return light._isPcf && light.device.supportsDepthShadow ? rt.depthBuffer : rt.colorBuffer;
				}
				return null;
			}
		}]);
		return LightRenderData;
	}();
	var Light = function () {
		function Light(graphicsDevice) {
			this.layers = new Set();
			this.device = graphicsDevice;
			this.id = id++;
			this._type = LIGHTTYPE_DIRECTIONAL;
			this._color = new Color(0.8, 0.8, 0.8);
			this._intensity = 1;
			this._affectSpecularity = true;
			this._luminance = 0;
			this._castShadows = false;
			this._enabled = false;
			this._mask = MASK_AFFECT_DYNAMIC;
			this.isStatic = false;
			this.key = 0;
			this.bakeDir = true;
			this.bakeNumSamples = 1;
			this.bakeArea = 0;
			this.attenuationStart = 10;
			this.attenuationEnd = 10;
			this._falloffMode = LIGHTFALLOFF_LINEAR;
			this._shadowType = SHADOW_PCF3;
			this._vsmBlurSize = 11;
			this.vsmBlurMode = BLUR_GAUSSIAN;
			this.vsmBias = 0.01 * 0.25;
			this._cookie = null;
			this.cookieIntensity = 1;
			this._cookieFalloff = true;
			this._cookieChannel = 'rgb';
			this._cookieTransform = null;
			this._cookieTransformUniform = new Float32Array(4);
			this._cookieOffset = null;
			this._cookieOffsetUniform = new Float32Array(2);
			this._cookieTransformSet = false;
			this._cookieOffsetSet = false;
			this._innerConeAngle = 40;
			this._outerConeAngle = 45;
			this.cascades = null;
			this._shadowMatrixPalette = null;
			this._shadowCascadeDistances = null;
			this.numCascades = 1;
			this.cascadeDistribution = 0.5;
			this._shape = LIGHTSHAPE_PUNCTUAL;
			this._finalColor = new Float32Array([0.8, 0.8, 0.8]);
			var c = Math.pow(this._finalColor[0], 2.2);
			this._linearFinalColor = new Float32Array([c, c, c]);
			this._position = new Vec3(0, 0, 0);
			this._direction = new Vec3(0, 0, 0);
			this._innerConeAngleCos = Math.cos(this._innerConeAngle * Math.PI / 180);
			this._updateOuterAngle(this._outerConeAngle);
			this._usePhysicalUnits = undefined;
			this._shadowMap = null;
			this._shadowRenderParams = [];
			this._shadowCameraParams = [];
			this.shadowDistance = 40;
			this._shadowResolution = 1024;
			this.shadowBias = -0.0005;
			this.shadowIntensity = 1.0;
			this._normalOffsetBias = 0.0;
			this.shadowUpdateMode = SHADOWUPDATE_REALTIME;
			this.shadowUpdateOverrides = null;
			this._penumbraSize = 1.0;
			this._isVsm = false;
			this._isPcf = true;
			this._cookieMatrix = null;
			this._atlasViewport = null;
			this.atlasViewportAllocated = false;
			this.atlasVersion = 0;
			this.atlasSlotIndex = 0;
			this.atlasSlotUpdated = false;
			this._node = null;
			this._renderData = [];
			this.visibleThisFrame = false;
			this.maxScreenSize = 0;
		}
		var _proto2 = Light.prototype;
		_proto2.destroy = function destroy() {
			this._destroyShadowMap();
			this.releaseRenderData();
			this._renderData = null;
		};
		_proto2.releaseRenderData = function releaseRenderData() {
			if (this._renderData) {
				for (var i = 0; i < this._renderData.length; i++) {
					this._renderData[i].destroy();
				}
				this._renderData.length = 0;
			}
		};
		_proto2.addLayer = function addLayer(layer) {
			this.layers.add(layer);
		};
		_proto2.removeLayer = function removeLayer(layer) {
			this.layers.delete(layer);
		};
		_proto2._updateOuterAngle = function _updateOuterAngle(angle) {
			var radAngle = angle * Math.PI / 180;
			this._outerConeAngleCos = Math.cos(radAngle);
			this._outerConeAngleSin = Math.sin(radAngle);
		};
		_proto2.beginFrame = function beginFrame() {
			this.visibleThisFrame = this._type === LIGHTTYPE_DIRECTIONAL && this._enabled;
			this.maxScreenSize = 0;
			this.atlasViewportAllocated = false;
			this.atlasSlotUpdated = false;
		};
		_proto2._destroyShadowMap = function _destroyShadowMap() {
			this.releaseRenderData();
			if (this._shadowMap) {
				if (!this._shadowMap.cached) {
					this._shadowMap.destroy();
				}
				this._shadowMap = null;
			}
			if (this.shadowUpdateMode === SHADOWUPDATE_NONE) {
				this.shadowUpdateMode = SHADOWUPDATE_THISFRAME;
			}
			if (this.shadowUpdateOverrides) {
				for (var i = 0; i < this.shadowUpdateOverrides.length; i++) {
					if (this.shadowUpdateOverrides[i] === SHADOWUPDATE_NONE) {
						this.shadowUpdateOverrides[i] = SHADOWUPDATE_THISFRAME;
					}
				}
			}
		};
		_proto2.getRenderData = function getRenderData(camera, face) {
			for (var i = 0; i < this._renderData.length; i++) {
				var current = this._renderData[i];
				if (current.camera === camera && current.face === face) {
					return current;
				}
			}
			var rd = new LightRenderData(this.device, camera, face, this);
			this._renderData.push(rd);
			return rd;
		};
		_proto2.clone = function clone() {
			var clone = new Light(this.device);
			clone.type = this._type;
			clone.setColor(this._color);
			clone.intensity = this._intensity;
			clone.affectSpecularity = this._affectSpecularity;
			clone.luminance = this._luminance;
			clone.castShadows = this.castShadows;
			clone._enabled = this._enabled;
			clone.attenuationStart = this.attenuationStart;
			clone.attenuationEnd = this.attenuationEnd;
			clone.falloffMode = this._falloffMode;
			clone.shadowType = this._shadowType;
			clone.vsmBlurSize = this._vsmBlurSize;
			clone.vsmBlurMode = this.vsmBlurMode;
			clone.vsmBias = this.vsmBias;
			clone.penumbraSize = this.penumbraSize;
			clone.shadowUpdateMode = this.shadowUpdateMode;
			clone.mask = this.mask;
			if (this.shadowUpdateOverrides) {
				clone.shadowUpdateOverrides = this.shadowUpdateOverrides.slice();
			}
			clone.innerConeAngle = this._innerConeAngle;
			clone.outerConeAngle = this._outerConeAngle;
			clone.numCascades = this.numCascades;
			clone.cascadeDistribution = this.cascadeDistribution;
			clone.shape = this._shape;
			clone.shadowBias = this.shadowBias;
			clone.normalOffsetBias = this._normalOffsetBias;
			clone.shadowResolution = this._shadowResolution;
			clone.shadowDistance = this.shadowDistance;
			clone.shadowIntensity = this.shadowIntensity;
			return clone;
		};
		Light.getLightUnitConversion = function getLightUnitConversion(type, outerAngle, innerAngle) {
			if (outerAngle === void 0) {
				outerAngle = Math.PI / 4;
			}
			if (innerAngle === void 0) {
				innerAngle = 0;
			}
			switch (type) {
				case LIGHTTYPE_SPOT:
					{
						var falloffEnd = Math.cos(outerAngle);
						var falloffStart = Math.cos(innerAngle);
						return 2 * Math.PI * (1 - falloffStart + (falloffStart - falloffEnd) / 2.0);
					}
				case LIGHTTYPE_OMNI:
					return 4 * Math.PI;
				case LIGHTTYPE_DIRECTIONAL:
					return 1;
			}
		};
		_proto2._getUniformBiasValues = function _getUniformBiasValues(lightRenderData) {
			var farClip = lightRenderData.shadowCamera._farClip;
			switch (this._type) {
				case LIGHTTYPE_OMNI:
					tmpBiases.bias = this.shadowBias;
					tmpBiases.normalBias = this._normalOffsetBias;
					break;
				case LIGHTTYPE_SPOT:
					if (this._isVsm) {
						tmpBiases.bias = -0.00001 * 20;
					} else {
						tmpBiases.bias = this.shadowBias * 20;
						if (this.device.isWebGL1 && this.device.extStandardDerivatives) tmpBiases.bias *= -100;
					}
					tmpBiases.normalBias = this._isVsm ? this.vsmBias / (this.attenuationEnd / 7.0) : this._normalOffsetBias;
					break;
				case LIGHTTYPE_DIRECTIONAL:
					if (this._isVsm) {
						tmpBiases.bias = -0.00001 * 20;
					} else {
						tmpBiases.bias = this.shadowBias / farClip * 100;
						if (this.device.isWebGL1 && this.device.extStandardDerivatives) tmpBiases.bias *= -100;
					}
					tmpBiases.normalBias = this._isVsm ? this.vsmBias / (farClip / 7.0) : this._normalOffsetBias;
					break;
			}
			return tmpBiases;
		};
		_proto2.getColor = function getColor() {
			return this._color;
		};
		_proto2.getBoundingSphere = function getBoundingSphere(sphere) {
			if (this._type === LIGHTTYPE_SPOT) {
				var size = this.attenuationEnd;
				var angle = this._outerConeAngle;
				var cosAngle = this._outerConeAngleCos;
				var node = this._node;
				tmpVec.copy(node.up);
				if (angle > 45) {
					sphere.radius = size * this._outerConeAngleSin;
					tmpVec.mulScalar(-size * cosAngle);
				} else {
					sphere.radius = size / (2 * cosAngle);
					tmpVec.mulScalar(-sphere.radius);
				}
				sphere.center.add2(node.getPosition(), tmpVec);
			} else if (this._type === LIGHTTYPE_OMNI) {
				sphere.center = this._node.getPosition();
				sphere.radius = this.attenuationEnd;
			}
		};
		_proto2.getBoundingBox = function getBoundingBox(box) {
			if (this._type === LIGHTTYPE_SPOT) {
				var range = this.attenuationEnd;
				var angle = this._outerConeAngle;
				var node = this._node;
				var scl = Math.abs(Math.sin(angle * math.DEG_TO_RAD) * range);
				box.center.set(0, -range * 0.5, 0);
				box.halfExtents.set(scl, range * 0.5, scl);
				box.setFromTransformedAabb(box, node.getWorldTransform(), true);
			} else if (this._type === LIGHTTYPE_OMNI) {
				box.center.copy(this._node.getPosition());
				box.halfExtents.set(this.attenuationEnd, this.attenuationEnd, this.attenuationEnd);
			}
		};
		_proto2._updateFinalColor = function _updateFinalColor() {
			var color = this._color;
			var r = color.r;
			var g = color.g;
			var b = color.b;
			var i = this._intensity;
			if (this._usePhysicalUnits) {
				i = this._luminance / Light.getLightUnitConversion(this._type, this._outerConeAngle * math.DEG_TO_RAD, this._innerConeAngle * math.DEG_TO_RAD);
			}
			var finalColor = this._finalColor;
			var linearFinalColor = this._linearFinalColor;
			finalColor[0] = r * i;
			finalColor[1] = g * i;
			finalColor[2] = b * i;
			if (i >= 1) {
				linearFinalColor[0] = Math.pow(r, 2.2) * i;
				linearFinalColor[1] = Math.pow(g, 2.2) * i;
				linearFinalColor[2] = Math.pow(b, 2.2) * i;
			} else {
				linearFinalColor[0] = Math.pow(finalColor[0], 2.2);
				linearFinalColor[1] = Math.pow(finalColor[1], 2.2);
				linearFinalColor[2] = Math.pow(finalColor[2], 2.2);
			}
		};
		_proto2.setColor = function setColor() {
			if (arguments.length === 1) {
				this._color.set(arguments[0].r, arguments[0].g, arguments[0].b);
			} else if (arguments.length === 3) {
				this._color.set(arguments[0], arguments[1], arguments[2]);
			}
			this._updateFinalColor();
		};
		_proto2.layersDirty = function layersDirty() {
			this.layers.forEach(function (layer) {
				layer.markLightsDirty();
			});
		};
		_proto2.updateKey = function updateKey() {
			var key = this._type << 29 | (this._castShadows ? 1 : 0) << 28 | this._shadowType << 25 | this._falloffMode << 23 | (this._normalOffsetBias !== 0.0 ? 1 : 0) << 22 | (this._cookie ? 1 : 0) << 21 | (this._cookieFalloff ? 1 : 0) << 20 | chanId[this._cookieChannel.charAt(0)] << 18 | (this._cookieTransform ? 1 : 0) << 12 | this._shape << 10 | this.numCascades - 1 << 8 | (this.affectSpecularity ? 1 : 0) << 7 | this.mask << 6;
			if (this._cookieChannel.length === 3) {
				key |= chanId[this._cookieChannel.charAt(1)] << 16;
				key |= chanId[this._cookieChannel.charAt(2)] << 14;
			}
			if (key !== this.key) {
				this.layersDirty();
			}
			this.key = key;
		};
		_createClass(Light, [{
			key: "numCascades",
			get: function get() {
				return this.cascades.length;
			},
			set: function set(value) {
				if (!this.cascades || this.numCascades !== value) {
					this.cascades = directionalCascades[value - 1];
					this._shadowMatrixPalette = new Float32Array(4 * 16);
					this._shadowCascadeDistances = new Float32Array(4);
					this._destroyShadowMap();
					this.updateKey();
				}
			}
		}, {
			key: "shadowMap",
			get: function get() {
				return this._shadowMap;
			},
			set: function set(shadowMap) {
				if (this._shadowMap !== shadowMap) {
					this._destroyShadowMap();
					this._shadowMap = shadowMap;
				}
			}
		}, {
			key: "mask",
			get: function get() {
				return this._mask;
			},
			set: function set(value) {
				if (this._mask !== value) {
					this._mask = value;
					this.updateKey();
				}
			}
		}, {
			key: "numShadowFaces",
			get: function get() {
				var type = this._type;
				if (type === LIGHTTYPE_DIRECTIONAL) {
					return this.numCascades;
				} else if (type === LIGHTTYPE_OMNI) {
					return 6;
				}
				return 1;
			}
		}, {
			key: "type",
			get: function get() {
				return this._type;
			},
			set: function set(value) {
				if (this._type === value) return;
				this._type = value;
				this._destroyShadowMap();
				this.updateKey();
				var stype = this._shadowType;
				this._shadowType = null;
				this.shadowUpdateOverrides = null;
				this.shadowType = stype;
			}
		}, {
			key: "shape",
			get: function get() {
				return this._shape;
			},
			set: function set(value) {
				if (this._shape === value) return;
				this._shape = value;
				this._destroyShadowMap();
				this.updateKey();
				var stype = this._shadowType;
				this._shadowType = null;
				this.shadowType = stype;
			}
		}, {
			key: "usePhysicalUnits",
			get: function get() {
				return this._usePhysicalUnits;
			},
			set: function set(value) {
				if (this._usePhysicalUnits !== value) {
					this._usePhysicalUnits = value;
					this._updateFinalColor();
				}
			}
		}, {
			key: "shadowType",
			get: function get() {
				return this._shadowType;
			},
			set: function set(value) {
				if (this._shadowType === value) return;
				var device = this.device;
				if (this._type === LIGHTTYPE_OMNI && value !== SHADOW_PCF3 && value !== SHADOW_PCSS) value = SHADOW_PCF3;
				var supportsDepthShadow = device.supportsDepthShadow;
				if (value === SHADOW_PCF5 && !supportsDepthShadow) {
					value = SHADOW_PCF3;
				}
				if (value === SHADOW_VSM32 && (!device.textureFloatRenderable || !device.textureFloatFilterable)) value = SHADOW_VSM16;
				if (value === SHADOW_VSM16 && !device.textureHalfFloatRenderable) value = SHADOW_VSM8;
				this._isVsm = value >= SHADOW_VSM8 && value <= SHADOW_VSM32;
				this._isPcf = value === SHADOW_PCF1 || value === SHADOW_PCF3 || value === SHADOW_PCF5;
				this._shadowType = value;
				this._destroyShadowMap();
				this.updateKey();
			}
		}, {
			key: "enabled",
			get: function get() {
				return this._enabled;
			},
			set: function set(value) {
				if (this._enabled !== value) {
					this._enabled = value;
					this.layersDirty();
				}
			}
		}, {
			key: "castShadows",
			get: function get() {
				return this._castShadows && this._mask !== MASK_BAKE && this._mask !== 0;
			},
			set: function set(value) {
				if (this._castShadows !== value) {
					this._castShadows = value;
					this._destroyShadowMap();
					this.layersDirty();
					this.updateKey();
				}
			}
		}, {
			key: "shadowResolution",
			get: function get() {
				return this._shadowResolution;
			},
			set: function set(value) {
				if (this._shadowResolution !== value) {
					if (this._type === LIGHTTYPE_OMNI) {
						value = Math.min(value, this.device.maxCubeMapSize);
					} else {
						value = Math.min(value, this.device.maxTextureSize);
					}
					this._shadowResolution = value;
					this._destroyShadowMap();
				}
			}
		}, {
			key: "vsmBlurSize",
			get: function get() {
				return this._vsmBlurSize;
			},
			set: function set(value) {
				if (this._vsmBlurSize === value) return;
				if (value % 2 === 0) value++;
				this._vsmBlurSize = value;
			}
		}, {
			key: "normalOffsetBias",
			get: function get() {
				return this._normalOffsetBias;
			},
			set: function set(value) {
				if (this._normalOffsetBias === value) return;
				if (!this._normalOffsetBias && value || this._normalOffsetBias && !value) {
					this.updateKey();
				}
				this._normalOffsetBias = value;
			}
		}, {
			key: "falloffMode",
			get: function get() {
				return this._falloffMode;
			},
			set: function set(value) {
				if (this._falloffMode === value) return;
				this._falloffMode = value;
				this.updateKey();
			}
		}, {
			key: "innerConeAngle",
			get: function get() {
				return this._innerConeAngle;
			},
			set: function set(value) {
				if (this._innerConeAngle === value) return;
				this._innerConeAngle = value;
				this._innerConeAngleCos = Math.cos(value * Math.PI / 180);
				if (this._usePhysicalUnits) {
					this._updateFinalColor();
				}
			}
		}, {
			key: "outerConeAngle",
			get: function get() {
				return this._outerConeAngle;
			},
			set: function set(value) {
				if (this._outerConeAngle === value) return;
				this._outerConeAngle = value;
				this._updateOuterAngle(value);
				if (this._usePhysicalUnits) {
					this._updateFinalColor();
				}
			}
		}, {
			key: "penumbraSize",
			get: function get() {
				return this._penumbraSize;
			},
			set: function set(value) {
				this._penumbraSize = value;
			}
		}, {
			key: "intensity",
			get: function get() {
				return this._intensity;
			},
			set: function set(value) {
				if (this._intensity !== value) {
					this._intensity = value;
					this._updateFinalColor();
				}
			}
		}, {
			key: "affectSpecularity",
			get: function get() {
				return this._affectSpecularity;
			},
			set: function set(value) {
				if (this._type === LIGHTTYPE_DIRECTIONAL) {
					this._affectSpecularity = value;
					this.updateKey();
				}
			}
		}, {
			key: "luminance",
			get: function get() {
				return this._luminance;
			},
			set: function set(value) {
				if (this._luminance !== value) {
					this._luminance = value;
					this._updateFinalColor();
				}
			}
		}, {
			key: "cookieMatrix",
			get: function get() {
				if (!this._cookieMatrix) {
					this._cookieMatrix = new Mat4();
				}
				return this._cookieMatrix;
			}
		}, {
			key: "atlasViewport",
			get: function get() {
				if (!this._atlasViewport) {
					this._atlasViewport = new Vec4(0, 0, 1, 1);
				}
				return this._atlasViewport;
			}
		}, {
			key: "cookie",
			get: function get() {
				return this._cookie;
			},
			set: function set(value) {
				if (this._cookie === value) return;
				this._cookie = value;
				this.updateKey();
			}
		}, {
			key: "cookieFalloff",
			get: function get() {
				return this._cookieFalloff;
			},
			set: function set(value) {
				if (this._cookieFalloff === value) return;
				this._cookieFalloff = value;
				this.updateKey();
			}
		}, {
			key: "cookieChannel",
			get: function get() {
				return this._cookieChannel;
			},
			set: function set(value) {
				if (this._cookieChannel === value) return;
				if (value.length < 3) {
					var chr = value.charAt(value.length - 1);
					var addLen = 3 - value.length;
					for (var i = 0; i < addLen; i++) value += chr;
				}
				this._cookieChannel = value;
				this.updateKey();
			}
		}, {
			key: "cookieTransform",
			get: function get() {
				return this._cookieTransform;
			},
			set: function set(value) {
				if (this._cookieTransform === value) return;
				this._cookieTransform = value;
				this._cookieTransformSet = !!value;
				if (value && !this._cookieOffset) {
					this.cookieOffset = new Vec2();
					this._cookieOffsetSet = false;
				}
				this.updateKey();
			}
		}, {
			key: "cookieOffset",
			get: function get() {
				return this._cookieOffset;
			},
			set: function set(value) {
				if (this._cookieOffset === value) return;
				var xformNew = !!(this._cookieTransformSet || value);
				if (xformNew && !value && this._cookieOffset) {
					this._cookieOffset.set(0, 0);
				} else {
					this._cookieOffset = value;
				}
				this._cookieOffsetSet = !!value;
				if (value && !this._cookieTransform) {
					this.cookieTransform = new Vec4(1, 1, 0, 0);
					this._cookieTransformSet = false;
				}
				this.updateKey();
			}
		}]);
		return Light;
	}();

	var LightingParams = function () {
		function LightingParams(supportsAreaLights, maxTextureSize, dirtyLightsFnc) {
			this._areaLightsEnabled = false;
			this._cells = new Vec3(10, 3, 10);
			this._maxLightsPerCell = 255;
			this._shadowsEnabled = true;
			this._shadowType = SHADOW_PCF3;
			this._shadowAtlasResolution = 2048;
			this._cookiesEnabled = false;
			this._cookieAtlasResolution = 2048;
			this.debugLayer = void 0;
			this.atlasSplit = null;
			this._supportsAreaLights = supportsAreaLights;
			this._maxTextureSize = maxTextureSize;
			this._dirtyLightsFnc = dirtyLightsFnc;
		}
		var _proto = LightingParams.prototype;
		_proto.applySettings = function applySettings(render) {
			var _render$lightingShado, _render$lightingCooki, _render$lightingAreaL, _render$lightingShado2, _render$lightingCooki2, _render$lightingMaxLi, _render$lightingShado3;
			this.shadowsEnabled = (_render$lightingShado = render.lightingShadowsEnabled) != null ? _render$lightingShado : this.shadowsEnabled;
			this.cookiesEnabled = (_render$lightingCooki = render.lightingCookiesEnabled) != null ? _render$lightingCooki : this.cookiesEnabled;
			this.areaLightsEnabled = (_render$lightingAreaL = render.lightingAreaLightsEnabled) != null ? _render$lightingAreaL : this.areaLightsEnabled;
			this.shadowAtlasResolution = (_render$lightingShado2 = render.lightingShadowAtlasResolution) != null ? _render$lightingShado2 : this.shadowAtlasResolution;
			this.cookieAtlasResolution = (_render$lightingCooki2 = render.lightingCookieAtlasResolution) != null ? _render$lightingCooki2 : this.cookieAtlasResolution;
			this.maxLightsPerCell = (_render$lightingMaxLi = render.lightingMaxLightsPerCell) != null ? _render$lightingMaxLi : this.maxLightsPerCell;
			this.shadowType = (_render$lightingShado3 = render.lightingShadowType) != null ? _render$lightingShado3 : this.shadowType;
			if (render.lightingCells) this.cell = new Vec3(render.lightingCells);
		};
		_createClass(LightingParams, [{
			key: "cells",
			get: function get() {
				return this._cells;
			},
			set: function set(value) {
				this._cells.copy(value);
			}
		}, {
			key: "maxLightsPerCell",
			get: function get() {
				return this._maxLightsPerCell;
			},
			set: function set(value) {
				this._maxLightsPerCell = math.clamp(value, 1, 255);
			}
		}, {
			key: "cookieAtlasResolution",
			get: function get() {
				return this._cookieAtlasResolution;
			},
			set: function set(value) {
				this._cookieAtlasResolution = math.clamp(value, 32, this._maxTextureSize);
			}
		}, {
			key: "shadowAtlasResolution",
			get: function get() {
				return this._shadowAtlasResolution;
			},
			set: function set(value) {
				this._shadowAtlasResolution = math.clamp(value, 32, this._maxTextureSize);
			}
		}, {
			key: "shadowType",
			get: function get() {
				return this._shadowType;
			},
			set: function set(value) {
				if (this._shadowType !== value) {
					this._shadowType = value;
					this._dirtyLightsFnc();
				}
			}
		}, {
			key: "cookiesEnabled",
			get: function get() {
				return this._cookiesEnabled;
			},
			set: function set(value) {
				if (this._cookiesEnabled !== value) {
					this._cookiesEnabled = value;
					this._dirtyLightsFnc();
				}
			}
		}, {
			key: "areaLightsEnabled",
			get: function get() {
				return this._areaLightsEnabled;
			},
			set: function set(value) {
				if (this._supportsAreaLights) {
					if (this._areaLightsEnabled !== value) {
						this._areaLightsEnabled = value;
						this._dirtyLightsFnc();
					}
				}
			}
		}, {
			key: "shadowsEnabled",
			get: function get() {
				return this._shadowsEnabled;
			},
			set: function set(value) {
				if (this._shadowsEnabled !== value) {
					this._shadowsEnabled = value;
					this._dirtyLightsFnc();
				}
			}
		}]);
		return LightingParams;
	}();

	var textureMorphVertexShader = "\n\tattribute vec2 vertex_position;\n\tvarying vec2 uv0;\n\tvoid main(void) {\n\t\tgl_Position = vec4(vertex_position, 0.5, 1.0);\n\t\tuv0 = vertex_position.xy * 0.5 + 0.5;\n\t}\n\t";
	var blendStateAdditive = new BlendState(true, BLENDEQUATION_ADD, BLENDMODE_ONE, BLENDMODE_ONE);
	var MorphInstance = function () {
		function MorphInstance(morph) {
			var _this = this;
			this.morph = morph;
			morph.incRefCount();
			this.device = morph.device;
			this._weights = [];
			this._weightMap = new Map();
			for (var v = 0; v < morph._targets.length; v++) {
				var target = morph._targets[v];
				if (target.name) {
					this._weightMap.set(target.name, v);
				}
				this.setWeight(v, target.defaultWeight);
			}
			this._activeTargets = [];
			if (morph.useTextureMorph) {
				this.shaderCache = {};
				this.maxSubmitCount = this.device.maxTextures;
				this._shaderMorphWeights = new Float32Array(this.maxSubmitCount);
				var createRT = function createRT(name, textureVar) {
					_this[textureVar] = morph._createTexture(name, morph._renderTextureFormat);
					return new RenderTarget({
						colorBuffer: _this[textureVar],
						depth: false
					});
				};
				if (morph.morphPositions) {
					this.rtPositions = createRT('MorphRTPos', 'texturePositions');
				}
				if (morph.morphNormals) {
					this.rtNormals = createRT('MorphRTNrm', 'textureNormals');
				}
				this._textureParams = new Float32Array([morph.morphTextureWidth, morph.morphTextureHeight, 1 / morph.morphTextureWidth, 1 / morph.morphTextureHeight]);
				for (var i = 0; i < this.maxSubmitCount; i++) {
					this['morphBlendTex' + i] = this.device.scope.resolve('morphBlendTex' + i);
				}
				this.morphFactor = this.device.scope.resolve('morphFactor[0]');
				this.zeroTextures = false;
			} else {
				this.maxSubmitCount = 8;
				this._shaderMorphWeights = new Float32Array(this.maxSubmitCount);
				this._shaderMorphWeightsA = new Float32Array(this._shaderMorphWeights.buffer, 0, 4);
				this._shaderMorphWeightsB = new Float32Array(this._shaderMorphWeights.buffer, 4 * 4, 4);
				this._activeVertexBuffers = new Array(this.maxSubmitCount);
			}
		}
		var _proto = MorphInstance.prototype;
		_proto.destroy = function destroy() {
			this.shader = null;
			var morph = this.morph;
			if (morph) {
				this.morph = null;
				morph.decRefCount();
				if (morph.refCount < 1) {
					morph.destroy();
				}
			}
			if (this.rtPositions) {
				this.rtPositions.destroy();
				this.rtPositions = null;
			}
			if (this.texturePositions) {
				this.texturePositions.destroy();
				this.texturePositions = null;
			}
			if (this.rtNormals) {
				this.rtNormals.destroy();
				this.rtNormals = null;
			}
			if (this.textureNormals) {
				this.textureNormals.destroy();
				this.textureNormals = null;
			}
		};
		_proto.clone = function clone() {
			return new MorphInstance(this.morph);
		};
		_proto._getWeightIndex = function _getWeightIndex(key) {
			if (typeof key === 'string') {
				var index = this._weightMap.get(key);
				return index;
			}
			return key;
		};
		_proto.getWeight = function getWeight(key) {
			var index = this._getWeightIndex(key);
			return this._weights[index];
		};
		_proto.setWeight = function setWeight(key, weight) {
			var index = this._getWeightIndex(key);
			this._weights[index] = weight;
			this._dirty = true;
		};
		_proto._getFragmentShader = function _getFragmentShader(numTextures) {
			var fragmentShader = '';
			if (numTextures > 0) {
				fragmentShader += 'varying vec2 uv0;\n' + 'uniform highp float morphFactor[' + numTextures + '];\n';
			}
			for (var i = 0; i < numTextures; i++) {
				fragmentShader += 'uniform highp sampler2D morphBlendTex' + i + ';\n';
			}
			fragmentShader += 'void main (void) {\n' + '    highp vec4 color = vec4(0, 0, 0, 1);\n';
			for (var _i = 0; _i < numTextures; _i++) {
				fragmentShader += '    color.xyz += morphFactor[' + _i + '] * texture2D(morphBlendTex' + _i + ', uv0).xyz;\n';
			}
			fragmentShader += '    gl_FragColor = color;\n' + '}\n';
			return fragmentShader;
		};
		_proto._getShader = function _getShader(count) {
			var shader = this.shaderCache[count];
			if (!shader) {
				var fs = this._getFragmentShader(count);
				shader = createShaderFromCode(this.device, textureMorphVertexShader, fs, 'textureMorph' + count);
				this.shaderCache[count] = shader;
			}
			return shader;
		};
		_proto._updateTextureRenderTarget = function _updateTextureRenderTarget(renderTarget, srcTextureName) {
			var _this2 = this;
			var device = this.device;
			var submitBatch = function submitBatch(usedCount, blending) {
				_this2.morphFactor.setValue(_this2._shaderMorphWeights);
				device.setBlendState(blending ? blendStateAdditive : BlendState.NOBLEND);
				var shader = _this2._getShader(usedCount);
				drawQuadWithShader(device, renderTarget, shader);
			};
			var usedCount = 0;
			var blending = false;
			var count = this._activeTargets.length;
			for (var i = 0; i < count; i++) {
				var activeTarget = this._activeTargets[i];
				var tex = activeTarget.target[srcTextureName];
				if (tex) {
					this['morphBlendTex' + usedCount].setValue(tex);
					this._shaderMorphWeights[usedCount] = activeTarget.weight;
					usedCount++;
					if (usedCount >= this.maxSubmitCount) {
						submitBatch(usedCount, blending);
						usedCount = 0;
						blending = true;
					}
				}
			}
			if (usedCount > 0 || count === 0 && !this.zeroTextures) {
				submitBatch(usedCount, blending);
			}
		};
		_proto._updateTextureMorph = function _updateTextureMorph() {
			this.device;
			if (this._activeTargets.length > 0 || !this.zeroTextures) {
				if (this.rtPositions) this._updateTextureRenderTarget(this.rtPositions, 'texturePositions');
				if (this.rtNormals) this._updateTextureRenderTarget(this.rtNormals, 'textureNormals');
				this.zeroTextures = this._activeTargets.length === 0;
			}
		};
		_proto._updateVertexMorph = function _updateVertexMorph() {
			var count = this.maxSubmitCount;
			for (var i = 0; i < count; i++) {
				this._shaderMorphWeights[i] = 0;
				this._activeVertexBuffers[i] = null;
			}
			var posIndex = 0;
			var nrmIndex = this.morph.morphPositions ? 4 : 0;
			for (var _i2 = 0; _i2 < this._activeTargets.length; _i2++) {
				var target = this._activeTargets[_i2].target;
				if (target._vertexBufferPositions) {
					this._activeVertexBuffers[posIndex] = target._vertexBufferPositions;
					this._shaderMorphWeights[posIndex] = this._activeTargets[_i2].weight;
					posIndex++;
				}
				if (target._vertexBufferNormals) {
					this._activeVertexBuffers[nrmIndex] = target._vertexBufferNormals;
					this._shaderMorphWeights[nrmIndex] = this._activeTargets[_i2].weight;
					nrmIndex++;
				}
			}
		};
		_proto.update = function update() {
			this._dirty = false;
			var targets = this.morph._targets;
			var activeCount = 0;
			var epsilon = 0.00001;
			for (var i = 0; i < targets.length; i++) {
				var absWeight = Math.abs(this.getWeight(i));
				if (absWeight > epsilon) {
					if (this._activeTargets.length <= activeCount) {
						this._activeTargets[activeCount] = {};
					}
					var activeTarget = this._activeTargets[activeCount++];
					activeTarget.absWeight = absWeight;
					activeTarget.weight = this.getWeight(i);
					activeTarget.target = targets[i];
				}
			}
			this._activeTargets.length = activeCount;
			var maxActiveTargets = this.morph.maxActiveTargets;
			if (this._activeTargets.length > maxActiveTargets) {
				this._activeTargets.sort(function (l, r) {
					return l.absWeight < r.absWeight ? 1 : r.absWeight < l.absWeight ? -1 : 0;
				});
				this._activeTargets.length = maxActiveTargets;
			}
			if (this.morph.useTextureMorph) {
				this._updateTextureMorph();
			} else {
				this._updateVertexMorph();
			}
		};
		return MorphInstance;
	}();

	var Model = function () {
		function Model() {
			this.graph = null;
			this.meshInstances = [];
			this.skinInstances = [];
			this.morphInstances = [];
			this.cameras = [];
			this.lights = [];
			this._shadersVersion = 0;
			this._immutable = false;
		}
		var _proto = Model.prototype;
		_proto.getGraph = function getGraph() {
			return this.graph;
		};
		_proto.setGraph = function setGraph(graph) {
			this.graph = graph;
		};
		_proto.getCameras = function getCameras() {
			return this.cameras;
		};
		_proto.setCameras = function setCameras(cameras) {
			this.cameras = cameras;
		};
		_proto.getLights = function getLights() {
			return this.lights;
		};
		_proto.setLights = function setLights(lights) {
			this.lights = lights;
		};
		_proto.getMaterials = function getMaterials() {
			var materials = [];
			for (var i = 0; i < this.meshInstances.length; i++) {
				var meshInstance = this.meshInstances[i];
				if (materials.indexOf(meshInstance.material) === -1) {
					materials.push(meshInstance.material);
				}
			}
			return materials;
		};
		_proto.clone = function clone() {
			var srcNodes = [];
			var cloneNodes = [];
			var _duplicate = function _duplicate(node) {
				var newNode = node.clone();
				srcNodes.push(node);
				cloneNodes.push(newNode);
				for (var idx = 0; idx < node._children.length; idx++) {
					newNode.addChild(_duplicate(node._children[idx]));
				}
				return newNode;
			};
			var cloneGraph = _duplicate(this.graph);
			var cloneMeshInstances = [];
			var cloneSkinInstances = [];
			var cloneMorphInstances = [];
			for (var i = 0; i < this.skinInstances.length; i++) {
				var skin = this.skinInstances[i].skin;
				var cloneSkinInstance = new SkinInstance(skin);
				var bones = [];
				for (var j = 0; j < skin.boneNames.length; j++) {
					var boneName = skin.boneNames[j];
					var bone = cloneGraph.findByName(boneName);
					bones.push(bone);
				}
				cloneSkinInstance.bones = bones;
				cloneSkinInstances.push(cloneSkinInstance);
			}
			for (var _i = 0; _i < this.morphInstances.length; _i++) {
				var morph = this.morphInstances[_i].morph;
				var cloneMorphInstance = new MorphInstance(morph);
				cloneMorphInstances.push(cloneMorphInstance);
			}
			for (var _i2 = 0; _i2 < this.meshInstances.length; _i2++) {
				var meshInstance = this.meshInstances[_i2];
				var nodeIndex = srcNodes.indexOf(meshInstance.node);
				var cloneMeshInstance = new MeshInstance(meshInstance.mesh, meshInstance.material, cloneNodes[nodeIndex]);
				if (meshInstance.skinInstance) {
					var skinInstanceIndex = this.skinInstances.indexOf(meshInstance.skinInstance);
					cloneMeshInstance.skinInstance = cloneSkinInstances[skinInstanceIndex];
				}
				if (meshInstance.morphInstance) {
					var morphInstanceIndex = this.morphInstances.indexOf(meshInstance.morphInstance);
					cloneMeshInstance.morphInstance = cloneMorphInstances[morphInstanceIndex];
				}
				cloneMeshInstances.push(cloneMeshInstance);
			}
			var clone = new Model();
			clone.graph = cloneGraph;
			clone.meshInstances = cloneMeshInstances;
			clone.skinInstances = cloneSkinInstances;
			clone.morphInstances = cloneMorphInstances;
			clone.getGraph().syncHierarchy();
			return clone;
		};
		_proto.destroy = function destroy() {
			var meshInstances = this.meshInstances;
			for (var i = 0; i < meshInstances.length; i++) {
				meshInstances[i].destroy();
			}
			this.meshInstances.length = 0;
		};
		_proto.generateWireframe = function generateWireframe() {
			MeshInstance._prepareRenderStyleForArray(this.meshInstances, RENDERSTYLE_WIREFRAME);
		};
		return Model;
	}();

	var Morph = function (_RefCountedObject) {
		_inheritsLoose(Morph, _RefCountedObject);
		function Morph(targets, graphicsDevice, _temp) {
			var _this;
			var _ref = _temp === void 0 ? {} : _temp,
				_ref$preferHighPrecis = _ref.preferHighPrecision,
				preferHighPrecision = _ref$preferHighPrecis === void 0 ? false : _ref$preferHighPrecis;
			_this = _RefCountedObject.call(this) || this;
			_this._aabb = void 0;
			_this.preferHighPrecision = void 0;
			_this.device = graphicsDevice || GraphicsDeviceAccess.get();
			_this.preferHighPrecision = preferHighPrecision;
			_this._targets = targets.slice();
			var device = _this.device;
			if (device.supportsMorphTargetTexturesCore) {
				var renderableHalf = device.extTextureHalfFloat && device.textureHalfFloatRenderable ? PIXELFORMAT_RGBA16F : undefined;
				var renderableFloat = device.extTextureFloat && device.textureFloatRenderable ? PIXELFORMAT_RGBA32F : undefined;
				_this._renderTextureFormat = _this.preferHighPrecision ? renderableFloat != null ? renderableFloat : renderableHalf : renderableHalf != null ? renderableHalf : renderableFloat;
				var textureHalf = device.extTextureHalfFloat && device.textureHalfFloatUpdatable ? PIXELFORMAT_RGBA16F : undefined;
				var textureFloat = device.extTextureFloat ? PIXELFORMAT_RGB32F : undefined;
				_this._textureFormat = _this.preferHighPrecision ? textureFloat != null ? textureFloat : textureHalf : textureHalf != null ? textureHalf : textureFloat;
				if (_this._renderTextureFormat !== undefined && _this._textureFormat !== undefined) {
					_this._useTextureMorph = true;
				}
			}
			_this._init();
			_this._updateMorphFlags();
			return _this;
		}
		var _proto = Morph.prototype;
		_proto._init = function _init() {
			if (this._useTextureMorph) {
				this._useTextureMorph = this._initTextureBased();
			}
			if (!this._useTextureMorph) {
				for (var i = 0; i < this._targets.length; i++) {
					this._targets[i]._initVertexBuffers(this.device);
				}
			}
			for (var _i = 0; _i < this._targets.length; _i++) {
				this._targets[_i]._postInit();
			}
		};
		_proto._findSparseSet = function _findSparseSet(deltaArrays, ids, usedDataIndices, floatRounding) {
			var freeIndex = 1;
			var dataCount = deltaArrays[0].length;
			for (var v = 0; v < dataCount; v += 3) {
				var vertexUsed = false;
				for (var i = 0; i < deltaArrays.length; i++) {
					var data = deltaArrays[i];
					if (data[v] !== 0 || data[v + 1] !== 0 || data[v + 2] !== 0) {
						vertexUsed = true;
						break;
					}
				}
				if (vertexUsed) {
					ids.push(freeIndex + floatRounding);
					usedDataIndices.push(v / 3);
					freeIndex++;
				} else {
					ids.push(0 + floatRounding);
				}
			}
			return freeIndex;
		};
		_proto._initTextureBased = function _initTextureBased() {
			var useUintIds = this.device.isWebGPU;
			var floatRounding = useUintIds ? 0 : 0.2;
			var deltaArrays = [],
				deltaInfos = [];
			for (var i = 0; i < this._targets.length; i++) {
				var target = this._targets[i];
				if (target.options.deltaPositions) {
					deltaArrays.push(target.options.deltaPositions);
					deltaInfos.push({
						target: target,
						name: 'texturePositions'
					});
				}
				if (target.options.deltaNormals) {
					deltaArrays.push(target.options.deltaNormals);
					deltaInfos.push({
						target: target,
						name: 'textureNormals'
					});
				}
			}
			var ids = [],
				usedDataIndices = [];
			var freeIndex = this._findSparseSet(deltaArrays, ids, usedDataIndices, floatRounding);
			var maxTextureSize = Math.min(this.device.maxTextureSize, 4096);
			var morphTextureWidth = Math.ceil(Math.sqrt(freeIndex));
			morphTextureWidth = Math.min(morphTextureWidth, maxTextureSize);
			var morphTextureHeight = Math.ceil(freeIndex / morphTextureWidth);
			if (morphTextureHeight > maxTextureSize) {
				return false;
			}
			this.morphTextureWidth = morphTextureWidth;
			this.morphTextureHeight = morphTextureHeight;
			var halfFloat = false;
			var numComponents = 3;
			var float2Half = FloatPacking.float2Half;
			if (this._textureFormat === PIXELFORMAT_RGBA16F) {
				halfFloat = true;
				numComponents = 4;
			}
			var textures = [];
			for (var _i2 = 0; _i2 < deltaArrays.length; _i2++) {
				textures.push(this._createTexture('MorphTarget', this._textureFormat));
			}
			for (var _i3 = 0; _i3 < deltaArrays.length; _i3++) {
				var data = deltaArrays[_i3];
				var texture = textures[_i3];
				var textureData = texture.lock();
				if (halfFloat) {
					for (var v = 0; v < usedDataIndices.length; v++) {
						var index = usedDataIndices[v] * 3;
						var dstIndex = v * numComponents + numComponents;
						textureData[dstIndex] = float2Half(data[index]);
						textureData[dstIndex + 1] = float2Half(data[index + 1]);
						textureData[dstIndex + 2] = float2Half(data[index + 2]);
					}
				} else {
					for (var _v = 0; _v < usedDataIndices.length; _v++) {
						var _index = usedDataIndices[_v] * 3;
						var _dstIndex = _v * numComponents + numComponents;
						textureData[_dstIndex] = data[_index];
						textureData[_dstIndex + 1] = data[_index + 1];
						textureData[_dstIndex + 2] = data[_index + 2];
					}
				}
				texture.unlock();
				var _target = deltaInfos[_i3].target;
				_target._setTexture(deltaInfos[_i3].name, texture);
			}
			var formatDesc = [{
				semantic: SEMANTIC_ATTR15,
				components: 1,
				type: useUintIds ? TYPE_UINT32 : TYPE_FLOAT32
			}];
			this.vertexBufferIds = new VertexBuffer(this.device, new VertexFormat(this.device, formatDesc, ids.length), ids.length, BUFFER_STATIC, useUintIds ? new Uint32Array(ids) : new Float32Array(ids));
			return true;
		};
		_proto.destroy = function destroy() {
			var _this$vertexBufferIds;
			(_this$vertexBufferIds = this.vertexBufferIds) == null || _this$vertexBufferIds.destroy();
			this.vertexBufferIds = null;
			for (var i = 0; i < this._targets.length; i++) {
				this._targets[i].destroy();
			}
			this._targets.length = 0;
		};
		_proto._updateMorphFlags = function _updateMorphFlags() {
			this._morphPositions = false;
			this._morphNormals = false;
			for (var i = 0; i < this._targets.length; i++) {
				var target = this._targets[i];
				if (target.morphPositions) {
					this._morphPositions = true;
				}
				if (target.morphNormals) {
					this._morphNormals = true;
				}
			}
		};
		_proto._createTexture = function _createTexture(name, format) {
			return new Texture(this.device, {
				width: this.morphTextureWidth,
				height: this.morphTextureHeight,
				format: format,
				cubemap: false,
				mipmaps: false,
				minFilter: FILTER_NEAREST,
				magFilter: FILTER_NEAREST,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE,
				name: name
			});
		};
		_createClass(Morph, [{
			key: "aabb",
			get: function get() {
				if (!this._aabb) {
					var min = new Vec3();
					var max = new Vec3();
					for (var i = 0; i < this._targets.length; i++) {
						var targetAabb = this._targets[i].aabb;
						min.min(targetAabb.getMin());
						max.max(targetAabb.getMax());
					}
					this._aabb = new BoundingBox();
					this._aabb.setMinMax(min, max);
				}
				return this._aabb;
			}
		}, {
			key: "morphPositions",
			get: function get() {
				return this._morphPositions;
			}
		}, {
			key: "morphNormals",
			get: function get() {
				return this._morphNormals;
			}
		}, {
			key: "maxActiveTargets",
			get: function get() {
				if (this._useTextureMorph) return this._targets.length;
				return this._morphPositions && this._morphNormals ? 4 : 8;
			}
		}, {
			key: "useTextureMorph",
			get: function get() {
				return this._useTextureMorph;
			}
		}, {
			key: "targets",
			get: function get() {
				return this._targets;
			}
		}]);
		return Morph;
	}(RefCountedObject);

	var MorphTarget = function () {
		function MorphTarget(options) {
			this.used = false;
			if (arguments.length === 2) {
				options = arguments[1];
			}
			this.options = options;
			this._name = options.name;
			this._defaultWeight = options.defaultWeight || 0;
			this._aabb = options.aabb;
			this.deltaPositions = options.deltaPositions;
		}
		var _proto = MorphTarget.prototype;
		_proto.destroy = function destroy() {
			var _this$_vertexBufferPo, _this$_vertexBufferNo, _this$texturePosition, _this$textureNormals;
			(_this$_vertexBufferPo = this._vertexBufferPositions) == null || _this$_vertexBufferPo.destroy();
			this._vertexBufferPositions = null;
			(_this$_vertexBufferNo = this._vertexBufferNormals) == null || _this$_vertexBufferNo.destroy();
			this._vertexBufferNormals = null;
			(_this$texturePosition = this.texturePositions) == null || _this$texturePosition.destroy();
			this.texturePositions = null;
			(_this$textureNormals = this.textureNormals) == null || _this$textureNormals.destroy();
			this.textureNormals = null;
		};
		_proto.clone = function clone() {
			return new MorphTarget(this.options);
		};
		_proto._postInit = function _postInit() {
			if (!this.options.preserveData) {
				this.options = null;
			}
			this.used = true;
		};
		_proto._initVertexBuffers = function _initVertexBuffers(graphicsDevice) {
			var options = this.options;
			this._vertexBufferPositions = this._createVertexBuffer(graphicsDevice, options.deltaPositions, options.deltaPositionsType);
			this._vertexBufferNormals = this._createVertexBuffer(graphicsDevice, options.deltaNormals, options.deltaNormalsType);
			if (this._vertexBufferPositions) {
				this.deltaPositions = this._vertexBufferPositions.lock();
			}
		};
		_proto._createVertexBuffer = function _createVertexBuffer(device, data, dataType) {
			if (dataType === void 0) {
				dataType = TYPE_FLOAT32;
			}
			if (data) {
				var formatDesc = [{
					semantic: SEMANTIC_ATTR0,
					components: 3,
					type: dataType
				}];
				return new VertexBuffer(device, new VertexFormat(device, formatDesc), data.length / 3, BUFFER_STATIC, data);
			}
			return null;
		};
		_proto._setTexture = function _setTexture(name, texture) {
			this[name] = texture;
		};
		_createClass(MorphTarget, [{
			key: "name",
			get: function get() {
				return this._name;
			}
		}, {
			key: "defaultWeight",
			get: function get() {
				return this._defaultWeight;
			}
		}, {
			key: "aabb",
			get: function get() {
				if (!this._aabb) {
					this._aabb = new BoundingBox();
					if (this.deltaPositions) this._aabb.compute(this.deltaPositions);
				}
				return this._aabb;
			}
		}, {
			key: "morphPositions",
			get: function get() {
				return !!this._vertexBufferPositions || !!this.texturePositions;
			}
		}, {
			key: "morphNormals",
			get: function get() {
				return !!this._vertexBufferNormals || !!this.textureNormals;
			}
		}]);
		return MorphTarget;
	}();

	var ShaderGeneratorParticle = function (_ShaderGenerator) {
		_inheritsLoose(ShaderGeneratorParticle, _ShaderGenerator);
		function ShaderGeneratorParticle() {
			return _ShaderGenerator.apply(this, arguments) || this;
		}
		var _proto = ShaderGeneratorParticle.prototype;
		_proto.generateKey = function generateKey(options) {
			var key = "particle";
			for (var prop in options) {
				if (options.hasOwnProperty(prop)) {
					key += options[prop];
				}
			}
			return key;
		};
		_proto._animTex = function _animTex(options) {
			var vshader = "";
			vshader += options.animTexLoop ? shaderChunks.particleAnimFrameLoopVS : shaderChunks.particleAnimFrameClampVS;
			vshader += shaderChunks.particleAnimTexVS;
			return vshader;
		};
		_proto.createShaderDefinition = function createShaderDefinition(device, options) {
			var executionDefine = "#define PARTICLE_" + (options.useCpu ? 'CPU' : 'GPU') + "\n";
			var fshader = '#define PARTICLE\n' + executionDefine;
			var vshader = "#define VERTEXSHADER\n" + executionDefine;
			if (options.mesh) vshader += "#define USE_MESH\n";
			if (options.localSpace) vshader += "#define LOCAL_SPACE\n";
			if (options.screenSpace) vshader += "#define SCREEN_SPACE\n";
			if (options.animTex) vshader += "\nuniform vec2 animTexTilesParams;\n";
			if (options.animTex) vshader += "\nuniform vec4 animTexParams;\n";
			if (options.animTex) vshader += "\nuniform vec2 animTexIndexParams;\n";
			if (options.normal === 2) vshader += "\nvarying mat3 ParticleMat;\n";
			if (options.normal === 1) vshader += "\nvarying vec3 Normal;\n";
			if (options.soft) vshader += "\nvarying float vDepth;\n";
			var faceVS = options.customFace ? shaderChunks.particle_customFaceVS : shaderChunks.particle_billboardVS;
			if (!options.useCpu) {
				vshader += shaderChunks.particle_initVS;
				vshader += options.pack8 ? shaderChunks.particleInputRgba8PS : shaderChunks.particleInputFloatPS;
				if (options.soft > 0) vshader += shaderChunks.screenDepthPS;
				vshader += shaderChunks.particleVS;
				if (options.localSpace) vshader += shaderChunks.particle_localShiftVS;
				if (options.animTex) vshader += this._animTex(options);
				if (options.wrap) vshader += shaderChunks.particle_wrapVS;
				if (options.alignToMotion) vshader += shaderChunks.particle_pointAlongVS;
				vshader += options.mesh ? shaderChunks.particle_meshVS : faceVS;
				if (options.normal === 1) vshader += shaderChunks.particle_normalVS;
				if (options.normal === 2) vshader += shaderChunks.particle_TBNVS;
				if (options.stretch > 0.0) vshader += shaderChunks.particle_stretchVS;
				vshader += shaderChunks.particle_endVS;
				if (options.soft > 0) vshader += shaderChunks.particle_softVS;
			} else {
				if (options.soft > 0) vshader += shaderChunks.screenDepthPS;
				vshader += shaderChunks.particle_cpuVS;
				if (options.localSpace) vshader += shaderChunks.particle_localShiftVS;
				if (options.animTex) vshader += this._animTex(options);
				if (options.alignToMotion) vshader += shaderChunks.particle_pointAlongVS;
				vshader += options.mesh ? shaderChunks.particle_meshVS : faceVS;
				if (options.normal === 1) vshader += shaderChunks.particle_normalVS;
				if (options.normal === 2) vshader += shaderChunks.particle_TBNVS;
				if (options.stretch > 0.0) vshader += shaderChunks.particle_stretchVS;
				vshader += shaderChunks.particle_cpu_endVS;
				if (options.soft > 0) vshader += shaderChunks.particle_softVS;
			}
			vshader += "}\n";
			if (options.normal > 0) {
				if (options.normal === 1) {
					fshader += "\nvarying vec3 Normal;\n";
				} else if (options.normal === 2) {
					fshader += "\nvarying mat3 ParticleMat;\n";
				}
				fshader += "\nuniform vec3 lightCube[6];\n";
			}
			if (options.soft) fshader += "\nvarying float vDepth;\n";
			if (options.normal === 0 && options.fog === "none") options.srgb = false;
			fshader += shaderChunks.decodePS;
			fshader += ShaderGenerator.gammaCode(options.gamma);
			fshader += ShaderGenerator.tonemapCode(options.toneMap);
			if (options.fog === 'linear') {
				fshader += shaderChunks.fogLinearPS;
			} else if (options.fog === 'exp') {
				fshader += shaderChunks.fogExpPS;
			} else if (options.fog === 'exp2') {
				fshader += shaderChunks.fogExp2PS;
			} else {
				fshader += shaderChunks.fogNonePS;
			}
			if (options.normal === 2) fshader += "\nuniform sampler2D normalMap;\n";
			if (options.soft > 0) fshader += shaderChunks.screenDepthPS;
			fshader += shaderChunks.particlePS;
			if (options.soft > 0) fshader += shaderChunks.particle_softPS;
			if (options.normal === 1) fshader += "\nvec3 normal = Normal;\n";
			if (options.normal === 2) fshader += shaderChunks.particle_normalMapPS;
			if (options.normal > 0) fshader += options.halflambert ? shaderChunks.particle_halflambertPS : shaderChunks.particle_lambertPS;
			if (options.normal > 0) fshader += shaderChunks.particle_lightingPS;
			if (options.blend === BLEND_NORMAL) {
				fshader += shaderChunks.particle_blendNormalPS;
			} else if (options.blend === BLEND_ADDITIVE) {
				fshader += shaderChunks.particle_blendAddPS;
			} else if (options.blend === BLEND_MULTIPLICATIVE) {
				fshader += shaderChunks.particle_blendMultiplyPS;
			}
			fshader += shaderChunks.particle_endPS;
			return ShaderUtils.createDefinition(device, {
				name: 'ParticleShader',
				vertexCode: vshader,
				fragmentCode: fshader
			});
		};
		return ShaderGeneratorParticle;
	}(ShaderGenerator);
	var particle = new ShaderGeneratorParticle();

	var nonUniformScale;
	var uniformScale = 1;
	var particleTexChannels$1 = 4;
	var rotMat = new Mat4();
	var rotMatInv = new Mat4();
	var randomPosTformed = new Vec3();
	var randomPos = new Vec3();
	var rndFactor3Vec = new Vec3();
	var particlePosPrev = new Vec3();
	var velocityVec = new Vec3();
	var localVelocityVec = new Vec3();
	var velocityVec2 = new Vec3();
	var localVelocityVec2 = new Vec3();
	var radialVelocityVec = new Vec3();
	var particlePos = new Vec3();
	var particleFinalPos = new Vec3();
	var moveDirVec = new Vec3();
	var tmpVec3$1 = new Vec3();
	function frac(f) {
		return f - Math.floor(f);
	}
	function saturate$1(x) {
		return Math.max(Math.min(x, 1), 0);
	}
	function glMod(x, y) {
		return x - y * Math.floor(x / y);
	}
	function encodeFloatRGBA(v) {
		var encX = frac(v);
		var encY = frac(255.0 * v);
		var encZ = frac(65025.0 * v);
		var encW = frac(160581375.0 * v);
		encX -= encY / 255.0;
		encY -= encZ / 255.0;
		encZ -= encW / 255.0;
		encW -= encW / 255.0;
		return [encX, encY, encZ, encW];
	}
	function encodeFloatRG(v) {
		var encX = frac(v);
		var encY = frac(255.0 * v);
		encX -= encY / 255.0;
		encY -= encY / 255.0;
		return [encX, encY];
	}
	var ParticleCPUUpdater = function () {
		function ParticleCPUUpdater(emitter) {
			this._emitter = emitter;
		}
		var _proto = ParticleCPUUpdater.prototype;
		_proto.calcSpawnPosition = function calcSpawnPosition(particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, i) {
			var emitter = this._emitter;
			var rX = Math.random();
			var rY = Math.random();
			var rZ = Math.random();
			var rW = Math.random();
			if (emitter.useCpu) {
				particleTex[i * particleTexChannels$1 + 0 + emitter.numParticlesPot * 2 * particleTexChannels$1] = rX;
				particleTex[i * particleTexChannels$1 + 1 + emitter.numParticlesPot * 2 * particleTexChannels$1] = rY;
				particleTex[i * particleTexChannels$1 + 2 + emitter.numParticlesPot * 2 * particleTexChannels$1] = rZ;
			}
			randomPos.x = rX - 0.5;
			randomPos.y = rY - 0.5;
			randomPos.z = rZ - 0.5;
			if (emitter.emitterShape === EMITTERSHAPE_BOX) {
				var max = Math.max(Math.abs(randomPos.x), Math.max(Math.abs(randomPos.y), Math.abs(randomPos.z)));
				var edgeX = max + (0.5 - max) * extentsInnerRatioUniform[0];
				var edgeY = max + (0.5 - max) * extentsInnerRatioUniform[1];
				var edgeZ = max + (0.5 - max) * extentsInnerRatioUniform[2];
				randomPos.x = edgeX * (max === Math.abs(randomPos.x) ? Math.sign(randomPos.x) : 2 * randomPos.x);
				randomPos.y = edgeY * (max === Math.abs(randomPos.y) ? Math.sign(randomPos.y) : 2 * randomPos.y);
				randomPos.z = edgeZ * (max === Math.abs(randomPos.z) ? Math.sign(randomPos.z) : 2 * randomPos.z);
				if (!emitter.localSpace) randomPosTformed.copy(emitterPos).add(spawnMatrix.transformPoint(randomPos));else randomPosTformed.copy(spawnMatrix.transformPoint(randomPos));
			} else {
				randomPos.normalize();
				var spawnBoundsSphereInnerRatio = emitter.emitterRadius === 0 ? 0 : emitter.emitterRadiusInner / emitter.emitterRadius;
				var r = rW * (1.0 - spawnBoundsSphereInnerRatio) + spawnBoundsSphereInnerRatio;
				if (!emitter.localSpace) randomPosTformed.copy(emitterPos).add(randomPos.mulScalar(r * emitter.emitterRadius));else randomPosTformed.copy(randomPos.mulScalar(r * emitter.emitterRadius));
			}
			var particleRate = math.lerp(emitter.rate, emitter.rate2, rX);
			var startSpawnTime = -particleRate * i;
			if (emitter.pack8) {
				var packX = (randomPosTformed.x - emitter.worldBounds.center.x) / emitter.worldBoundsSize.x + 0.5;
				var packY = (randomPosTformed.y - emitter.worldBounds.center.y) / emitter.worldBoundsSize.y + 0.5;
				var packZ = (randomPosTformed.z - emitter.worldBounds.center.z) / emitter.worldBoundsSize.z + 0.5;
				var packA = math.lerp(emitter.startAngle * math.DEG_TO_RAD, emitter.startAngle2 * math.DEG_TO_RAD, rX);
				packA = packA % (Math.PI * 2) / (Math.PI * 2);
				var rg0 = encodeFloatRG(packX);
				particleTex[i * particleTexChannels$1] = rg0[0];
				particleTex[i * particleTexChannels$1 + 1] = rg0[1];
				var ba0 = encodeFloatRG(packY);
				particleTex[i * particleTexChannels$1 + 2] = ba0[0];
				particleTex[i * particleTexChannels$1 + 3] = ba0[1];
				var rg1 = encodeFloatRG(packZ);
				particleTex[i * particleTexChannels$1 + 0 + emitter.numParticlesPot * particleTexChannels$1] = rg1[0];
				particleTex[i * particleTexChannels$1 + 1 + emitter.numParticlesPot * particleTexChannels$1] = rg1[1];
				var ba1 = encodeFloatRG(packA);
				particleTex[i * particleTexChannels$1 + 2 + emitter.numParticlesPot * particleTexChannels$1] = ba1[0];
				particleTex[i * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1] = ba1[1];
				var a2 = 1.0;
				particleTex[i * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1 * 2] = a2;
				var maxNegLife = Math.max(emitter.lifetime, (emitter.numParticles - 1.0) * Math.max(emitter.rate, emitter.rate2));
				var maxPosLife = emitter.lifetime + 1.0;
				startSpawnTime = (startSpawnTime + maxNegLife) / (maxNegLife + maxPosLife);
				var rgba3 = encodeFloatRGBA(startSpawnTime);
				particleTex[i * particleTexChannels$1 + 0 + emitter.numParticlesPot * particleTexChannels$1 * 3] = rgba3[0];
				particleTex[i * particleTexChannels$1 + 1 + emitter.numParticlesPot * particleTexChannels$1 * 3] = rgba3[1];
				particleTex[i * particleTexChannels$1 + 2 + emitter.numParticlesPot * particleTexChannels$1 * 3] = rgba3[2];
				particleTex[i * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1 * 3] = rgba3[3];
			} else {
				particleTex[i * particleTexChannels$1] = randomPosTformed.x;
				particleTex[i * particleTexChannels$1 + 1] = randomPosTformed.y;
				particleTex[i * particleTexChannels$1 + 2] = randomPosTformed.z;
				particleTex[i * particleTexChannels$1 + 3] = math.lerp(emitter.startAngle * math.DEG_TO_RAD, emitter.startAngle2 * math.DEG_TO_RAD, rX);
				particleTex[i * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1] = startSpawnTime;
			}
		};
		_proto.update = function update(data, vbToSort, particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, delta, isOnStop) {
			var a, b, c;
			var emitter = this._emitter;
			if (emitter.meshInstance.node) {
				var fullMat = emitter.meshInstance.node.worldTransform;
				for (var j = 0; j < 12; j++) {
					rotMat.data[j] = fullMat.data[j];
				}
				rotMatInv.copy(rotMat);
				rotMatInv.invert();
				nonUniformScale = emitter.meshInstance.node.localScale;
				uniformScale = Math.max(Math.max(nonUniformScale.x, nonUniformScale.y), nonUniformScale.z);
			}
			emitterPos = emitter.meshInstance.node === null || emitter.localSpace ? Vec3.ZERO : emitter.meshInstance.node.getPosition();
			var posCam = emitter.camera ? emitter.camera._node.getPosition() : Vec3.ZERO;
			var vertSize = !emitter.useMesh ? 15 : 17;
			var cf, cc;
			var rotSpeed, rotSpeed2, scale2, alpha, alpha2, radialSpeed, radialSpeed2;
			var precision1 = emitter.precision - 1;
			for (var i = 0; i < emitter.numParticles; i++) {
				var id = Math.floor(emitter.vbCPU[i * emitter.numParticleVerts * (emitter.useMesh ? 6 : 4) + 3]);
				var rndFactor = particleTex[id * particleTexChannels$1 + 0 + emitter.numParticlesPot * 2 * particleTexChannels$1];
				rndFactor3Vec.x = rndFactor;
				rndFactor3Vec.y = particleTex[id * particleTexChannels$1 + 1 + emitter.numParticlesPot * 2 * particleTexChannels$1];
				rndFactor3Vec.z = particleTex[id * particleTexChannels$1 + 2 + emitter.numParticlesPot * 2 * particleTexChannels$1];
				var particleRate = emitter.rate + (emitter.rate2 - emitter.rate) * rndFactor;
				var particleLifetime = emitter.lifetime;
				var life = particleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1] + delta;
				var nlife = saturate$1(life / particleLifetime);
				var scale = 0;
				var alphaDiv = 0;
				var angle = 0;
				var respawn = life - delta <= 0.0 || life >= particleLifetime;
				if (respawn) {
					this.calcSpawnPosition(particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, id);
				}
				var particleEnabled = life > 0.0 && life < particleLifetime;
				if (particleEnabled) {
					c = nlife * precision1;
					cf = Math.floor(c);
					cc = Math.ceil(c);
					c %= 1;
					a = emitter.qRotSpeed[cf];
					b = emitter.qRotSpeed[cc];
					rotSpeed = a + (b - a) * c;
					a = emitter.qRotSpeed2[cf];
					b = emitter.qRotSpeed2[cc];
					rotSpeed2 = a + (b - a) * c;
					a = emitter.qScale[cf];
					b = emitter.qScale[cc];
					scale = a + (b - a) * c;
					a = emitter.qScale2[cf];
					b = emitter.qScale2[cc];
					scale2 = a + (b - a) * c;
					a = emitter.qAlpha[cf];
					b = emitter.qAlpha[cc];
					alpha = a + (b - a) * c;
					a = emitter.qAlpha2[cf];
					b = emitter.qAlpha2[cc];
					alpha2 = a + (b - a) * c;
					a = emitter.qRadialSpeed[cf];
					b = emitter.qRadialSpeed[cc];
					radialSpeed = a + (b - a) * c;
					a = emitter.qRadialSpeed2[cf];
					b = emitter.qRadialSpeed2[cc];
					radialSpeed2 = a + (b - a) * c;
					radialSpeed += (radialSpeed2 - radialSpeed) * (rndFactor * 100.0 % 1.0);
					particlePosPrev.x = particleTex[id * particleTexChannels$1];
					particlePosPrev.y = particleTex[id * particleTexChannels$1 + 1];
					particlePosPrev.z = particleTex[id * particleTexChannels$1 + 2];
					if (!emitter.localSpace) radialVelocityVec.copy(particlePosPrev).sub(emitterPos);else radialVelocityVec.copy(particlePosPrev);
					radialVelocityVec.normalize().mulScalar(radialSpeed);
					cf *= 3;
					cc *= 3;
					a = emitter.qLocalVelocity[cf];
					b = emitter.qLocalVelocity[cc];
					localVelocityVec.x = a + (b - a) * c;
					a = emitter.qLocalVelocity[cf + 1];
					b = emitter.qLocalVelocity[cc + 1];
					localVelocityVec.y = a + (b - a) * c;
					a = emitter.qLocalVelocity[cf + 2];
					b = emitter.qLocalVelocity[cc + 2];
					localVelocityVec.z = a + (b - a) * c;
					a = emitter.qLocalVelocity2[cf];
					b = emitter.qLocalVelocity2[cc];
					localVelocityVec2.x = a + (b - a) * c;
					a = emitter.qLocalVelocity2[cf + 1];
					b = emitter.qLocalVelocity2[cc + 1];
					localVelocityVec2.y = a + (b - a) * c;
					a = emitter.qLocalVelocity2[cf + 2];
					b = emitter.qLocalVelocity2[cc + 2];
					localVelocityVec2.z = a + (b - a) * c;
					a = emitter.qVelocity[cf];
					b = emitter.qVelocity[cc];
					velocityVec.x = a + (b - a) * c;
					a = emitter.qVelocity[cf + 1];
					b = emitter.qVelocity[cc + 1];
					velocityVec.y = a + (b - a) * c;
					a = emitter.qVelocity[cf + 2];
					b = emitter.qVelocity[cc + 2];
					velocityVec.z = a + (b - a) * c;
					a = emitter.qVelocity2[cf];
					b = emitter.qVelocity2[cc];
					velocityVec2.x = a + (b - a) * c;
					a = emitter.qVelocity2[cf + 1];
					b = emitter.qVelocity2[cc + 1];
					velocityVec2.y = a + (b - a) * c;
					a = emitter.qVelocity2[cf + 2];
					b = emitter.qVelocity2[cc + 2];
					velocityVec2.z = a + (b - a) * c;
					localVelocityVec.x += (localVelocityVec2.x - localVelocityVec.x) * rndFactor3Vec.x;
					localVelocityVec.y += (localVelocityVec2.y - localVelocityVec.y) * rndFactor3Vec.y;
					localVelocityVec.z += (localVelocityVec2.z - localVelocityVec.z) * rndFactor3Vec.z;
					if (emitter.initialVelocity > 0) {
						if (emitter.emitterShape === EMITTERSHAPE_SPHERE) {
							randomPos.copy(rndFactor3Vec).mulScalar(2).sub(Vec3.ONE).normalize();
							localVelocityVec.add(randomPos.mulScalar(emitter.initialVelocity));
						} else {
							localVelocityVec.add(Vec3.FORWARD.mulScalar(emitter.initialVelocity));
						}
					}
					velocityVec.x += (velocityVec2.x - velocityVec.x) * rndFactor3Vec.x;
					velocityVec.y += (velocityVec2.y - velocityVec.y) * rndFactor3Vec.y;
					velocityVec.z += (velocityVec2.z - velocityVec.z) * rndFactor3Vec.z;
					rotSpeed += (rotSpeed2 - rotSpeed) * rndFactor3Vec.y;
					scale = (scale + (scale2 - scale) * (rndFactor * 10000.0 % 1.0)) * uniformScale;
					alphaDiv = (alpha2 - alpha) * (rndFactor * 1000.0 % 1.0);
					if (emitter.meshInstance.node) {
						if (!emitter.localSpace) {
							rotMat.transformPoint(localVelocityVec, localVelocityVec);
						} else {
							localVelocityVec.x /= nonUniformScale.x;
							localVelocityVec.y /= nonUniformScale.y;
							localVelocityVec.z /= nonUniformScale.z;
						}
					}
					if (!emitter.localSpace) {
						localVelocityVec.add(velocityVec.mul(nonUniformScale));
						localVelocityVec.add(radialVelocityVec.mul(nonUniformScale));
					} else {
						rotMatInv.transformPoint(velocityVec, velocityVec);
						localVelocityVec.add(velocityVec).add(radialVelocityVec);
					}
					moveDirVec.copy(localVelocityVec);
					particlePos.copy(particlePosPrev).add(localVelocityVec.mulScalar(delta));
					particleFinalPos.copy(particlePos);
					particleTex[id * particleTexChannels$1] = particleFinalPos.x;
					particleTex[id * particleTexChannels$1 + 1] = particleFinalPos.y;
					particleTex[id * particleTexChannels$1 + 2] = particleFinalPos.z;
					particleTex[id * particleTexChannels$1 + 3] += rotSpeed * delta;
					if (emitter.wrap && emitter.wrapBounds) {
						if (!emitter.localSpace) particleFinalPos.sub(emitterPos);
						particleFinalPos.x = glMod(particleFinalPos.x, emitter.wrapBounds.x) - emitter.wrapBounds.x * 0.5;
						particleFinalPos.y = glMod(particleFinalPos.y, emitter.wrapBounds.y) - emitter.wrapBounds.y * 0.5;
						particleFinalPos.z = glMod(particleFinalPos.z, emitter.wrapBounds.z) - emitter.wrapBounds.z * 0.5;
						if (!emitter.localSpace) particleFinalPos.add(emitterPos);
					}
					if (emitter.sort > 0) {
						if (emitter.sort === 1) {
							tmpVec3$1.copy(particleFinalPos).sub(posCam);
							emitter.particleDistance[id] = -(tmpVec3$1.x * tmpVec3$1.x + tmpVec3$1.y * tmpVec3$1.y + tmpVec3$1.z * tmpVec3$1.z);
						} else if (emitter.sort === 2) {
							emitter.particleDistance[id] = life;
						} else if (emitter.sort === 3) {
							emitter.particleDistance[id] = -life;
						}
					}
				}
				if (isOnStop) {
					if (life < 0) {
						particleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * 2 * particleTexChannels$1] = -1;
					}
				} else {
					if (life >= particleLifetime) {
						life -= Math.max(particleLifetime, (emitter.numParticles - 1) * particleRate);
						particleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * 2 * particleTexChannels$1] = emitter.loop ? 1 : -1;
					}
					if (life < 0 && emitter.loop) {
						particleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * 2 * particleTexChannels$1] = 1;
					}
				}
				if (particleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * 2 * particleTexChannels$1] < 0) particleEnabled = false;
				particleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1] = life;
				for (var v = 0; v < emitter.numParticleVerts; v++) {
					var vbOffset = (i * emitter.numParticleVerts + v) * (emitter.useMesh ? 6 : 4);
					var quadX = emitter.vbCPU[vbOffset];
					var quadY = emitter.vbCPU[vbOffset + 1];
					var quadZ = emitter.vbCPU[vbOffset + 2];
					if (!particleEnabled) {
						quadX = quadY = quadZ = 0;
					}
					var w = i * emitter.numParticleVerts * vertSize + v * vertSize;
					data[w] = particleFinalPos.x;
					data[w + 1] = particleFinalPos.y;
					data[w + 2] = particleFinalPos.z;
					data[w + 3] = nlife;
					data[w + 4] = emitter.alignToMotion ? angle : particleTex[id * particleTexChannels$1 + 3];
					data[w + 5] = scale;
					data[w + 6] = alphaDiv;
					data[w + 7] = moveDirVec.x;
					data[w + 8] = quadX;
					data[w + 9] = quadY;
					data[w + 10] = quadZ;
					data[w + 11] = moveDirVec.y;
					data[w + 12] = id;
					data[w + 13] = moveDirVec.z;
					data[w + 14] = emitter.vbCPU[vbOffset + 3];
					if (emitter.useMesh) {
						data[w + 15] = emitter.vbCPU[vbOffset + 4];
						data[w + 16] = emitter.vbCPU[vbOffset + 5];
					}
				}
			}
			if (emitter.sort > PARTICLESORT_NONE && emitter.camera) {
				var vbStride = emitter.useMesh ? 6 : 4;
				var particleDistance = emitter.particleDistance;
				for (var _i = 0; _i < emitter.numParticles; _i++) {
					vbToSort[_i][0] = _i;
					vbToSort[_i][1] = particleDistance[Math.floor(emitter.vbCPU[_i * emitter.numParticleVerts * vbStride + 3])];
				}
				emitter.vbOld.set(emitter.vbCPU);
				vbToSort.sort(function (p1, p2) {
					return p1[1] - p2[1];
				});
				for (var _i2 = 0; _i2 < emitter.numParticles; _i2++) {
					var src = vbToSort[_i2][0] * emitter.numParticleVerts * vbStride;
					var dest = _i2 * emitter.numParticleVerts * vbStride;
					for (var _j = 0; _j < emitter.numParticleVerts * vbStride; _j++) {
						emitter.vbCPU[dest + _j] = emitter.vbOld[src + _j];
					}
				}
			}
		};
		return ParticleCPUUpdater;
	}();

	var spawnMatrix3 = new Mat3();
	var emitterMatrix3 = new Mat3();
	var emitterMatrix3Inv = new Mat3();
	var ParticleGPUUpdater = function () {
		function ParticleGPUUpdater(emitter, gd) {
			this._emitter = emitter;
			this.frameRandomUniform = new Float32Array(3);
			this.emitterPosUniform = new Float32Array(3);
			this.emitterScaleUniform = new Float32Array([1, 1, 1]);
			this.worldBoundsMulUniform = new Float32Array(3);
			this.worldBoundsAddUniform = new Float32Array(3);
			this.inBoundsSizeUniform = new Float32Array(3);
			this.inBoundsCenterUniform = new Float32Array(3);
			this.constantParticleTexIN = gd.scope.resolve('particleTexIN');
			this.constantParticleTexOUT = gd.scope.resolve('particleTexOUT');
			this.constantEmitterPos = gd.scope.resolve('emitterPos');
			this.constantEmitterScale = gd.scope.resolve('emitterScale');
			this.constantSpawnBounds = gd.scope.resolve('spawnBounds');
			this.constantSpawnPosInnerRatio = gd.scope.resolve('spawnPosInnerRatio');
			this.constantSpawnBoundsSphere = gd.scope.resolve('spawnBoundsSphere');
			this.constantSpawnBoundsSphereInnerRatio = gd.scope.resolve('spawnBoundsSphereInnerRatio');
			this.constantInitialVelocity = gd.scope.resolve('initialVelocity');
			this.constantFrameRandom = gd.scope.resolve('frameRandom');
			this.constantDelta = gd.scope.resolve('delta');
			this.constantRate = gd.scope.resolve('rate');
			this.constantRateDiv = gd.scope.resolve('rateDiv');
			this.constantLifetime = gd.scope.resolve('lifetime');
			this.constantGraphSampleSize = gd.scope.resolve('graphSampleSize');
			this.constantGraphNumSamples = gd.scope.resolve('graphNumSamples');
			this.constantInternalTex0 = gd.scope.resolve('internalTex0');
			this.constantInternalTex1 = gd.scope.resolve('internalTex1');
			this.constantInternalTex2 = gd.scope.resolve('internalTex2');
			this.constantInternalTex3 = gd.scope.resolve('internalTex3');
			this.constantEmitterMatrix = gd.scope.resolve('emitterMatrix');
			this.constantEmitterMatrixInv = gd.scope.resolve('emitterMatrixInv');
			this.constantNumParticles = gd.scope.resolve('numParticles');
			this.constantNumParticlesPot = gd.scope.resolve('numParticlesPot');
			this.constantLocalVelocityDivMult = gd.scope.resolve('localVelocityDivMult');
			this.constantVelocityDivMult = gd.scope.resolve('velocityDivMult');
			this.constantRotSpeedDivMult = gd.scope.resolve('rotSpeedDivMult');
			this.constantSeed = gd.scope.resolve('seed');
			this.constantStartAngle = gd.scope.resolve('startAngle');
			this.constantStartAngle2 = gd.scope.resolve('startAngle2');
			this.constantOutBoundsMul = gd.scope.resolve('outBoundsMul');
			this.constantOutBoundsAdd = gd.scope.resolve('outBoundsAdd');
			this.constantInBoundsSize = gd.scope.resolve('inBoundsSize');
			this.constantInBoundsCenter = gd.scope.resolve('inBoundsCenter');
			this.constantMaxVel = gd.scope.resolve('maxVel');
			this.constantFaceTangent = gd.scope.resolve('faceTangent');
			this.constantFaceBinorm = gd.scope.resolve('faceBinorm');
		}
		var _proto = ParticleGPUUpdater.prototype;
		_proto._setInputBounds = function _setInputBounds() {
			this.inBoundsSizeUniform[0] = this._emitter.prevWorldBoundsSize.x;
			this.inBoundsSizeUniform[1] = this._emitter.prevWorldBoundsSize.y;
			this.inBoundsSizeUniform[2] = this._emitter.prevWorldBoundsSize.z;
			this.constantInBoundsSize.setValue(this.inBoundsSizeUniform);
			this.inBoundsCenterUniform[0] = this._emitter.prevWorldBoundsCenter.x;
			this.inBoundsCenterUniform[1] = this._emitter.prevWorldBoundsCenter.y;
			this.inBoundsCenterUniform[2] = this._emitter.prevWorldBoundsCenter.z;
			this.constantInBoundsCenter.setValue(this.inBoundsCenterUniform);
		};
		_proto.randomize = function randomize() {
			this.frameRandomUniform[0] = Math.random();
			this.frameRandomUniform[1] = Math.random();
			this.frameRandomUniform[2] = Math.random();
		};
		_proto.update = function update(device, spawnMatrix, extentsInnerRatioUniform, delta, isOnStop) {
			var emitter = this._emitter;
			device.setBlendState(BlendState.NOBLEND);
			device.setDepthState(DepthState.NODEPTH);
			device.setCullMode(CULLFACE_NONE);
			this.randomize();
			this.constantGraphSampleSize.setValue(1.0 / emitter.precision);
			this.constantGraphNumSamples.setValue(emitter.precision);
			this.constantNumParticles.setValue(emitter.numParticles);
			this.constantNumParticlesPot.setValue(emitter.numParticlesPot);
			this.constantInternalTex0.setValue(emitter.internalTex0);
			this.constantInternalTex1.setValue(emitter.internalTex1);
			this.constantInternalTex2.setValue(emitter.internalTex2);
			this.constantInternalTex3.setValue(emitter.internalTex3);
			var node = emitter.meshInstance.node;
			var emitterScale = node === null ? Vec3.ONE : node.localScale;
			if (emitter.pack8) {
				this.worldBoundsMulUniform[0] = emitter.worldBoundsMul.x;
				this.worldBoundsMulUniform[1] = emitter.worldBoundsMul.y;
				this.worldBoundsMulUniform[2] = emitter.worldBoundsMul.z;
				this.constantOutBoundsMul.setValue(this.worldBoundsMulUniform);
				this.worldBoundsAddUniform[0] = emitter.worldBoundsAdd.x;
				this.worldBoundsAddUniform[1] = emitter.worldBoundsAdd.y;
				this.worldBoundsAddUniform[2] = emitter.worldBoundsAdd.z;
				this.constantOutBoundsAdd.setValue(this.worldBoundsAddUniform);
				this._setInputBounds();
				var maxVel = emitter.maxVel * Math.max(Math.max(emitterScale.x, emitterScale.y), emitterScale.z);
				maxVel = Math.max(maxVel, 1);
				this.constantMaxVel.setValue(maxVel);
			}
			var emitterPos = node === null || emitter.localSpace ? Vec3.ZERO : node.getPosition();
			var emitterMatrix = node === null ? Mat4.IDENTITY : node.getWorldTransform();
			if (emitter.emitterShape === EMITTERSHAPE_BOX) {
				spawnMatrix3.setFromMat4(spawnMatrix);
				this.constantSpawnBounds.setValue(spawnMatrix3.data);
				this.constantSpawnPosInnerRatio.setValue(extentsInnerRatioUniform);
			} else {
				this.constantSpawnBoundsSphere.setValue(emitter.emitterRadius);
				this.constantSpawnBoundsSphereInnerRatio.setValue(emitter.emitterRadius === 0 ? 0 : emitter.emitterRadiusInner / emitter.emitterRadius);
			}
			this.constantInitialVelocity.setValue(emitter.initialVelocity);
			emitterMatrix3.setFromMat4(emitterMatrix);
			emitterMatrix3Inv.invertMat4(emitterMatrix);
			this.emitterPosUniform[0] = emitterPos.x;
			this.emitterPosUniform[1] = emitterPos.y;
			this.emitterPosUniform[2] = emitterPos.z;
			this.constantEmitterPos.setValue(this.emitterPosUniform);
			this.constantFrameRandom.setValue(this.frameRandomUniform);
			this.constantDelta.setValue(delta);
			this.constantRate.setValue(emitter.rate);
			this.constantRateDiv.setValue(emitter.rate2 - emitter.rate);
			this.constantStartAngle.setValue(emitter.startAngle * math.DEG_TO_RAD);
			this.constantStartAngle2.setValue(emitter.startAngle2 * math.DEG_TO_RAD);
			this.constantSeed.setValue(emitter.seed);
			this.constantLifetime.setValue(emitter.lifetime);
			this.emitterScaleUniform[0] = emitterScale.x;
			this.emitterScaleUniform[1] = emitterScale.y;
			this.emitterScaleUniform[2] = emitterScale.z;
			this.constantEmitterScale.setValue(this.emitterScaleUniform);
			this.constantEmitterMatrix.setValue(emitterMatrix3.data);
			this.constantEmitterMatrixInv.setValue(emitterMatrix3Inv.data);
			this.constantLocalVelocityDivMult.setValue(emitter.localVelocityUMax);
			this.constantVelocityDivMult.setValue(emitter.velocityUMax);
			this.constantRotSpeedDivMult.setValue(emitter.rotSpeedUMax[0]);
			var texIN = emitter.swapTex ? emitter.particleTexOUT : emitter.particleTexIN;
			texIN = emitter.beenReset ? emitter.particleTexStart : texIN;
			var texOUT = emitter.swapTex ? emitter.particleTexIN : emitter.particleTexOUT;
			this.constantParticleTexIN.setValue(texIN);
			drawQuadWithShader(device, emitter.swapTex ? emitter.rtParticleTexIN : emitter.rtParticleTexOUT, !isOnStop ? emitter.loop ? emitter.shaderParticleUpdateRespawn : emitter.shaderParticleUpdateNoRespawn : emitter.shaderParticleUpdateOnStop);
			emitter.material.setParameter('particleTexOUT', texIN);
			emitter.material.setParameter('particleTexIN', texOUT);
			emitter.beenReset = false;
			emitter.swapTex = !emitter.swapTex;
			emitter.prevWorldBoundsSize.copy(emitter.worldBoundsSize);
			emitter.prevWorldBoundsCenter.copy(emitter.worldBounds.center);
			if (emitter.pack8) this._setInputBounds();
		};
		return ParticleGPUUpdater;
	}();

	var particleVerts = [[-1, -1], [1, -1], [1, 1], [-1, 1]];
	function _createTexture(device, width, height, pixelData, format, mult8Bit, filter) {
		if (format === void 0) {
			format = PIXELFORMAT_RGBA32F;
		}
		var mipFilter = FILTER_NEAREST;
		if (filter && format === PIXELFORMAT_RGBA8) mipFilter = FILTER_LINEAR;
		var texture = new Texture(device, {
			width: width,
			height: height,
			format: format,
			cubemap: false,
			mipmaps: false,
			minFilter: mipFilter,
			magFilter: mipFilter,
			addressU: ADDRESS_CLAMP_TO_EDGE,
			addressV: ADDRESS_CLAMP_TO_EDGE,
			name: 'ParticleSystemTexture'
		});
		var pixels = texture.lock();
		if (format === PIXELFORMAT_RGBA8) {
			var temp = new Uint8Array(pixelData.length);
			for (var i = 0; i < pixelData.length; i++) {
				temp[i] = pixelData[i] * mult8Bit * 255;
			}
			pixelData = temp;
		}
		pixels.set(pixelData);
		texture.unlock();
		return texture;
	}
	function saturate(x) {
		return Math.max(Math.min(x, 1), 0);
	}
	var default0Curve = new Curve([0, 0, 1, 0]);
	var default1Curve = new Curve([0, 1, 1, 1]);
	var default0Curve3 = new CurveSet([0, 0, 1, 0], [0, 0, 1, 0], [0, 0, 1, 0]);
	var default1Curve3 = new CurveSet([0, 1, 1, 1], [0, 1, 1, 1], [0, 1, 1, 1]);
	var particleTexHeight = 2;
	var particleTexChannels = 4;
	var extentsInnerRatioUniform = new Float32Array(3);
	var spawnMatrix = new Mat4();
	var tmpVec3 = new Vec3();
	var bMin = new Vec3();
	var bMax = new Vec3();
	var setPropertyTarget;
	var setPropertyOptions;
	function setProperty(pName, defaultVal) {
		if (setPropertyOptions[pName] !== undefined && setPropertyOptions[pName] !== null) {
			setPropertyTarget[pName] = setPropertyOptions[pName];
		} else {
			setPropertyTarget[pName] = defaultVal;
		}
	}
	function pack3NFloats(a, b, c) {
		var packed = a * 255 << 16 | b * 255 << 8 | c * 255;
		return packed / (1 << 24);
	}
	function packTextureXYZ_NXYZ(qXYZ, qXYZ2) {
		var num = qXYZ.length / 3;
		var colors = new Array(num * 4);
		for (var i = 0; i < num; i++) {
			colors[i * 4] = qXYZ[i * 3];
			colors[i * 4 + 1] = qXYZ[i * 3 + 1];
			colors[i * 4 + 2] = qXYZ[i * 3 + 2];
			colors[i * 4 + 3] = pack3NFloats(qXYZ2[i * 3], qXYZ2[i * 3 + 1], qXYZ2[i * 3 + 2]);
		}
		return colors;
	}
	function packTextureRGBA(qRGB, qA) {
		var colors = new Array(qA.length * 4);
		for (var i = 0; i < qA.length; i++) {
			colors[i * 4] = qRGB[i * 3];
			colors[i * 4 + 1] = qRGB[i * 3 + 1];
			colors[i * 4 + 2] = qRGB[i * 3 + 2];
			colors[i * 4 + 3] = qA[i];
		}
		return colors;
	}
	function packTexture5Floats(qA, qB, qC, qD, qE) {
		var colors = new Array(qA.length * 4);
		for (var i = 0; i < qA.length; i++) {
			colors[i * 4] = qA[i];
			colors[i * 4 + 1] = qB[i];
			colors[i * 4 + 2] = 0;
			colors[i * 4 + 3] = pack3NFloats(qC[i], qD[i], qE[i]);
		}
		return colors;
	}
	function packTexture2Floats(qA, qB) {
		var colors = new Array(qA.length * 4);
		for (var i = 0; i < qA.length; i++) {
			colors[i * 4] = qA[i];
			colors[i * 4 + 1] = qB[i];
			colors[i * 4 + 2] = 0;
			colors[i * 4 + 3] = 0;
		}
		return colors;
	}
	function calcEndTime(emitter) {
		var interval = Math.max(emitter.rate, emitter.rate2) * emitter.numParticles + emitter.lifetime;
		return Date.now() + interval * 1000;
	}
	function subGraph(A, B) {
		var r = new Float32Array(A.length);
		for (var i = 0; i < A.length; i++) {
			r[i] = A[i] - B[i];
		}
		return r;
	}
	function maxUnsignedGraphValue(A, outUMax) {
		var chans = outUMax.length;
		var values = A.length / chans;
		for (var i = 0; i < values; i++) {
			for (var j = 0; j < chans; j++) {
				var a = Math.abs(A[i * chans + j]);
				outUMax[j] = Math.max(outUMax[j], a);
			}
		}
	}
	function normalizeGraph(A, uMax) {
		var chans = uMax.length;
		var values = A.length / chans;
		for (var i = 0; i < values; i++) {
			for (var j = 0; j < chans; j++) {
				A[i * chans + j] /= uMax[j] === 0 ? 1 : uMax[j];
				A[i * chans + j] *= 0.5;
				A[i * chans + j] += 0.5;
			}
		}
	}
	function divGraphFrom2Curves(curve1, curve2, outUMax) {
		var sub = subGraph(curve2, curve1);
		maxUnsignedGraphValue(sub, outUMax);
		normalizeGraph(sub, outUMax);
		return sub;
	}
	var particleEmitterDeviceCache = new DeviceCache();
	var ParticleEmitter = function () {
		function ParticleEmitter(graphicsDevice, options) {
			this.graphicsDevice = graphicsDevice;
			var gd = graphicsDevice;
			var precision = 32;
			this.precision = precision;
			this._addTimeTime = 0;
			setPropertyTarget = this;
			setPropertyOptions = options;
			setProperty('numParticles', 1);
			if (this.numParticles > graphicsDevice.maxTextureSize) {
				this.numParticles = graphicsDevice.maxTextureSize;
			}
			setProperty('rate', 1);
			setProperty('rate2', this.rate);
			setProperty('lifetime', 50);
			setProperty('emitterExtents', new Vec3(0, 0, 0));
			setProperty('emitterExtentsInner', new Vec3(0, 0, 0));
			setProperty('emitterRadius', 0);
			setProperty('emitterRadiusInner', 0);
			setProperty('emitterShape', EMITTERSHAPE_BOX);
			setProperty('initialVelocity', 1);
			setProperty('wrap', false);
			setProperty('localSpace', false);
			setProperty('screenSpace', false);
			setProperty('wrapBounds', null);
			setProperty('colorMap', this.defaultParamTexture);
			setProperty('normalMap', null);
			setProperty('loop', true);
			setProperty('preWarm', false);
			setProperty('sort', PARTICLESORT_NONE);
			setProperty('mode', PARTICLEMODE_GPU);
			setProperty('scene', null);
			setProperty('lighting', false);
			setProperty('halfLambert', false);
			setProperty('intensity', 1.0);
			setProperty('stretch', 0.0);
			setProperty('alignToMotion', false);
			setProperty('depthSoftening', 0);
			setProperty('mesh', null);
			setProperty('particleNormal', new Vec3(0, 1, 0));
			setProperty('orientation', PARTICLEORIENTATION_SCREEN);
			setProperty('depthWrite', false);
			setProperty('noFog', false);
			setProperty('blendType', BLEND_NORMAL);
			setProperty('node', null);
			setProperty('startAngle', 0);
			setProperty('startAngle2', this.startAngle);
			setProperty('animTilesX', 1);
			setProperty('animTilesY', 1);
			setProperty('animStartFrame', 0);
			setProperty('animNumFrames', 1);
			setProperty('animNumAnimations', 1);
			setProperty('animIndex', 0);
			setProperty('randomizeAnimIndex', false);
			setProperty('animSpeed', 1);
			setProperty('animLoop', true);
			this._gpuUpdater = new ParticleGPUUpdater(this, gd);
			this._cpuUpdater = new ParticleCPUUpdater(this);
			this.emitterPosUniform = new Float32Array(3);
			this.wrapBoundsUniform = new Float32Array(3);
			this.emitterScaleUniform = new Float32Array([1, 1, 1]);
			setProperty('colorGraph', default1Curve3);
			setProperty('colorGraph2', this.colorGraph);
			setProperty('scaleGraph', default1Curve);
			setProperty('scaleGraph2', this.scaleGraph);
			setProperty('alphaGraph', default1Curve);
			setProperty('alphaGraph2', this.alphaGraph);
			setProperty('localVelocityGraph', default0Curve3);
			setProperty('localVelocityGraph2', this.localVelocityGraph);
			setProperty('velocityGraph', default0Curve3);
			setProperty('velocityGraph2', this.velocityGraph);
			setProperty('rotationSpeedGraph', default0Curve);
			setProperty('rotationSpeedGraph2', this.rotationSpeedGraph);
			setProperty('radialSpeedGraph', default0Curve);
			setProperty('radialSpeedGraph2', this.radialSpeedGraph);
			this.animTilesParams = new Float32Array(2);
			this.animParams = new Float32Array(4);
			this.animIndexParams = new Float32Array(2);
			this.internalTex0 = null;
			this.internalTex1 = null;
			this.internalTex2 = null;
			this.colorParam = null;
			this.vbToSort = null;
			this.vbOld = null;
			this.particleDistance = null;
			this.camera = null;
			this.swapTex = false;
			this.useMesh = true;
			this.useCpu = !graphicsDevice.supportsGpuParticles;
			this.pack8 = true;
			this.localBounds = new BoundingBox();
			this.worldBoundsNoTrail = new BoundingBox();
			this.worldBoundsTrail = [new BoundingBox(), new BoundingBox()];
			this.worldBounds = new BoundingBox();
			this.worldBoundsSize = new Vec3();
			this.prevWorldBoundsSize = new Vec3();
			this.prevWorldBoundsCenter = new Vec3();
			this.prevEmitterExtents = this.emitterExtents;
			this.prevEmitterRadius = this.emitterRadius;
			this.worldBoundsMul = new Vec3();
			this.worldBoundsAdd = new Vec3();
			this.timeToSwitchBounds = 0;
			this.shaderParticleUpdateRespawn = null;
			this.shaderParticleUpdateNoRespawn = null;
			this.shaderParticleUpdateOnStop = null;
			this.numParticleVerts = 0;
			this.numParticleIndices = 0;
			this.material = null;
			this.meshInstance = null;
			this.drawOrder = 0;
			this.seed = Math.random();
			this.fixedTimeStep = 1.0 / 60;
			this.maxSubSteps = 10;
			this.simTime = 0;
			this.simTimeTotal = 0;
			this.beenReset = false;
			this._layer = null;
			this.rebuild();
		}
		var _proto = ParticleEmitter.prototype;
		_proto.onChangeCamera = function onChangeCamera() {
			this.regenShader();
			this.resetMaterial();
		};
		_proto.calculateBoundsMad = function calculateBoundsMad() {
			this.worldBoundsMul.x = 1.0 / this.worldBoundsSize.x;
			this.worldBoundsMul.y = 1.0 / this.worldBoundsSize.y;
			this.worldBoundsMul.z = 1.0 / this.worldBoundsSize.z;
			this.worldBoundsAdd.copy(this.worldBounds.center).mul(this.worldBoundsMul).mulScalar(-1);
			this.worldBoundsAdd.x += 0.5;
			this.worldBoundsAdd.y += 0.5;
			this.worldBoundsAdd.z += 0.5;
		};
		_proto.calculateWorldBounds = function calculateWorldBounds() {
			if (!this.node) return;
			this.prevWorldBoundsSize.copy(this.worldBoundsSize);
			this.prevWorldBoundsCenter.copy(this.worldBounds.center);
			if (!this.useCpu) {
				var recalculateLocalBounds = false;
				if (this.emitterShape === EMITTERSHAPE_BOX) {
					recalculateLocalBounds = !this.emitterExtents.equals(this.prevEmitterExtents);
				} else {
					recalculateLocalBounds = !(this.emitterRadius === this.prevEmitterRadius);
				}
				if (recalculateLocalBounds) {
					this.calculateLocalBounds();
				}
			}
			var nodeWT = this.node.getWorldTransform();
			if (this.localSpace) {
				this.worldBoundsNoTrail.copy(this.localBounds);
			} else {
				this.worldBoundsNoTrail.setFromTransformedAabb(this.localBounds, nodeWT);
			}
			this.worldBoundsTrail[0].add(this.worldBoundsNoTrail);
			this.worldBoundsTrail[1].add(this.worldBoundsNoTrail);
			var now = this.simTimeTotal;
			if (now >= this.timeToSwitchBounds) {
				this.worldBoundsTrail[0].copy(this.worldBoundsTrail[1]);
				this.worldBoundsTrail[1].copy(this.worldBoundsNoTrail);
				this.timeToSwitchBounds = now + this.lifetime;
			}
			this.worldBounds.copy(this.worldBoundsTrail[0]);
			this.worldBoundsSize.copy(this.worldBounds.halfExtents).mulScalar(2);
			if (this.localSpace) {
				this.meshInstance.aabb.setFromTransformedAabb(this.worldBounds, nodeWT);
				this.meshInstance.mesh.aabb.setFromTransformedAabb(this.worldBounds, nodeWT);
			} else {
				this.meshInstance.aabb.copy(this.worldBounds);
				this.meshInstance.mesh.aabb.copy(this.worldBounds);
			}
			this.meshInstance._aabbVer = 1 - this.meshInstance._aabbVer;
			if (this.pack8) this.calculateBoundsMad();
		};
		_proto.resetWorldBounds = function resetWorldBounds() {
			if (!this.node) return;
			this.worldBoundsNoTrail.setFromTransformedAabb(this.localBounds, this.localSpace ? Mat4.IDENTITY : this.node.getWorldTransform());
			this.worldBoundsTrail[0].copy(this.worldBoundsNoTrail);
			this.worldBoundsTrail[1].copy(this.worldBoundsNoTrail);
			this.worldBounds.copy(this.worldBoundsTrail[0]);
			this.worldBoundsSize.copy(this.worldBounds.halfExtents).mulScalar(2);
			this.prevWorldBoundsSize.copy(this.worldBoundsSize);
			this.prevWorldBoundsCenter.copy(this.worldBounds.center);
			this.simTimeTotal = 0;
			this.timeToSwitchBounds = 0;
		};
		_proto.calculateLocalBounds = function calculateLocalBounds() {
			var minx = Number.MAX_VALUE;
			var miny = Number.MAX_VALUE;
			var minz = Number.MAX_VALUE;
			var maxx = -Number.MAX_VALUE;
			var maxy = -Number.MAX_VALUE;
			var maxz = -Number.MAX_VALUE;
			var maxR = 0;
			var maxScale = 0;
			var stepWeight = this.lifetime / this.precision;
			var wVels = [this.qVelocity, this.qVelocity2];
			var lVels = [this.qLocalVelocity, this.qLocalVelocity2];
			var accumX = [0, 0];
			var accumY = [0, 0];
			var accumZ = [0, 0];
			var accumR = [0, 0];
			var accumW = [0, 0];
			var x, y, z;
			for (var i = 0; i < this.precision + 1; i++) {
				var index = Math.min(i, this.precision - 1);
				for (var j = 0; j < 2; j++) {
					x = lVels[j][index * 3 + 0] * stepWeight + accumX[j];
					y = lVels[j][index * 3 + 1] * stepWeight + accumY[j];
					z = lVels[j][index * 3 + 2] * stepWeight + accumZ[j];
					minx = Math.min(x, minx);
					miny = Math.min(y, miny);
					minz = Math.min(z, minz);
					maxx = Math.max(x, maxx);
					maxy = Math.max(y, maxy);
					maxz = Math.max(z, maxz);
					accumX[j] = x;
					accumY[j] = y;
					accumZ[j] = z;
				}
				for (var _j = 0; _j < 2; _j++) {
					accumW[_j] += stepWeight * Math.sqrt(wVels[_j][index * 3 + 0] * wVels[_j][index * 3 + 0] + wVels[_j][index * 3 + 1] * wVels[_j][index * 3 + 1] + wVels[_j][index * 3 + 2] * wVels[_j][index * 3 + 2]);
				}
				accumR[0] += this.qRadialSpeed[index] * stepWeight;
				accumR[1] += this.qRadialSpeed2[index] * stepWeight;
				maxR = Math.max(maxR, Math.max(Math.abs(accumR[0]), Math.abs(accumR[1])));
				maxScale = Math.max(maxScale, this.qScale[index]);
			}
			if (this.emitterShape === EMITTERSHAPE_BOX) {
				x = this.emitterExtents.x * 0.5;
				y = this.emitterExtents.y * 0.5;
				z = this.emitterExtents.z * 0.5;
			} else {
				x = this.emitterRadius;
				y = this.emitterRadius;
				z = this.emitterRadius;
			}
			var w = Math.max(accumW[0], accumW[1]);
			bMin.x = minx - maxScale - x - maxR - w;
			bMin.y = miny - maxScale - y - maxR - w;
			bMin.z = minz - maxScale - z - maxR - w;
			bMax.x = maxx + maxScale + x + maxR + w;
			bMax.y = maxy + maxScale + y + maxR + w;
			bMax.z = maxz + maxScale + z + maxR + w;
			this.localBounds.setMinMax(bMin, bMax);
		};
		_proto.rebuild = function rebuild() {
			var gd = this.graphicsDevice;
			if (this.colorMap === null) this.colorMap = this.defaultParamTexture;
			this.spawnBounds = this.emitterShape === EMITTERSHAPE_BOX ? this.emitterExtents : this.emitterRadius;
			this.useCpu = this.useCpu || this.sort > PARTICLESORT_NONE || gd.maxVertexTextures <= 1 || gd.fragmentUniformsCount < 64 || gd.forceCpuParticles || !gd.extTextureFloat;
			this._destroyResources();
			this.pack8 = (this.pack8 || !gd.textureFloatRenderable) && !this.useCpu;
			particleTexHeight = this.useCpu || this.pack8 ? 4 : 2;
			this.useMesh = false;
			if (this.mesh) {
				var totalVertCount = this.numParticles * this.mesh.vertexBuffer.numVertices;
				if (totalVertCount > 65535) ; else {
					this.useMesh = true;
				}
			}
			this.numParticlesPot = math.nextPowerOfTwo(this.numParticles);
			this.rebuildGraphs();
			this.calculateLocalBounds();
			this.resetWorldBounds();
			if (this.node) {
				this.worldBounds.setFromTransformedAabb(this.localBounds, this.localSpace ? Mat4.IDENTITY : this.node.getWorldTransform());
				this.worldBoundsTrail[0].copy(this.worldBounds);
				this.worldBoundsTrail[1].copy(this.worldBounds);
				this.worldBoundsSize.copy(this.worldBounds.halfExtents).mulScalar(2);
				this.prevWorldBoundsSize.copy(this.worldBoundsSize);
				this.prevWorldBoundsCenter.copy(this.worldBounds.center);
				if (this.pack8) this.calculateBoundsMad();
			}
			this.vbToSort = new Array(this.numParticles);
			for (var iSort = 0; iSort < this.numParticles; iSort++) this.vbToSort[iSort] = [0, 0];
			this.particleDistance = new Float32Array(this.numParticles);
			this._gpuUpdater.randomize();
			this.particleTex = new Float32Array(this.numParticlesPot * particleTexHeight * particleTexChannels);
			var emitterPos = this.node === null || this.localSpace ? Vec3.ZERO : this.node.getPosition();
			if (this.emitterShape === EMITTERSHAPE_BOX) {
				if (this.node === null || this.localSpace) {
					spawnMatrix.setTRS(Vec3.ZERO, Quat.IDENTITY, this.spawnBounds);
				} else {
					spawnMatrix.setTRS(Vec3.ZERO, this.node.getRotation(), tmpVec3.copy(this.spawnBounds).mul(this.node.localScale));
				}
				extentsInnerRatioUniform[0] = this.emitterExtents.x !== 0 ? this.emitterExtentsInner.x / this.emitterExtents.x : 0;
				extentsInnerRatioUniform[1] = this.emitterExtents.y !== 0 ? this.emitterExtentsInner.y / this.emitterExtents.y : 0;
				extentsInnerRatioUniform[2] = this.emitterExtents.z !== 0 ? this.emitterExtentsInner.z / this.emitterExtents.z : 0;
			}
			for (var i = 0; i < this.numParticles; i++) {
				this._cpuUpdater.calcSpawnPosition(this.particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, i);
				if (this.useCpu) this.particleTex[i * particleTexChannels + 3 + this.numParticlesPot * 2 * particleTexChannels] = 1;
			}
			this.particleTexStart = new Float32Array(this.numParticlesPot * particleTexHeight * particleTexChannels);
			for (var _i = 0; _i < this.particleTexStart.length; _i++) {
				this.particleTexStart[_i] = this.particleTex[_i];
			}
			if (!this.useCpu) {
				if (this.pack8) {
					this.particleTexIN = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex, PIXELFORMAT_RGBA8, 1, false);
					this.particleTexOUT = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex, PIXELFORMAT_RGBA8, 1, false);
					this.particleTexStart = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTexStart, PIXELFORMAT_RGBA8, 1, false);
				} else {
					this.particleTexIN = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex);
					this.particleTexOUT = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex);
					this.particleTexStart = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTexStart);
				}
				this.rtParticleTexIN = new RenderTarget({
					colorBuffer: this.particleTexIN,
					depth: false
				});
				this.rtParticleTexOUT = new RenderTarget({
					colorBuffer: this.particleTexOUT,
					depth: false
				});
				this.swapTex = false;
			}
			var shaderCodeStart = (this.localSpace ? '#define LOCAL_SPACE\n' : '') + shaderChunks.particleUpdaterInitPS + (this.pack8 ? shaderChunks.particleInputRgba8PS + shaderChunks.particleOutputRgba8PS : shaderChunks.particleInputFloatPS + shaderChunks.particleOutputFloatPS) + (this.emitterShape === EMITTERSHAPE_BOX ? shaderChunks.particleUpdaterAABBPS : shaderChunks.particleUpdaterSpherePS) + shaderChunks.particleUpdaterStartPS;
			var shaderCodeRespawn = shaderCodeStart + shaderChunks.particleUpdaterRespawnPS + shaderChunks.particleUpdaterEndPS;
			var shaderCodeNoRespawn = shaderCodeStart + shaderChunks.particleUpdaterNoRespawnPS + shaderChunks.particleUpdaterEndPS;
			var shaderCodeOnStop = shaderCodeStart + shaderChunks.particleUpdaterOnStopPS + shaderChunks.particleUpdaterEndPS;
			var params = this.emitterShape + '' + this.pack8 + '' + this.localSpace;
			this.shaderParticleUpdateRespawn = createShaderFromCode(gd, shaderChunks.fullscreenQuadVS, shaderCodeRespawn, 'fsQuad0' + params);
			this.shaderParticleUpdateNoRespawn = createShaderFromCode(gd, shaderChunks.fullscreenQuadVS, shaderCodeNoRespawn, 'fsQuad1' + params);
			this.shaderParticleUpdateOnStop = createShaderFromCode(gd, shaderChunks.fullscreenQuadVS, shaderCodeOnStop, 'fsQuad2' + params);
			this.numParticleVerts = this.useMesh ? this.mesh.vertexBuffer.numVertices : 4;
			this.numParticleIndices = this.useMesh ? this.mesh.indexBuffer[0].numIndices : 6;
			this._allocate(this.numParticles);
			var mesh = new Mesh(gd);
			mesh.vertexBuffer = this.vertexBuffer;
			mesh.indexBuffer[0] = this.indexBuffer;
			mesh.primitive[0].type = PRIMITIVE_TRIANGLES;
			mesh.primitive[0].base = 0;
			mesh.primitive[0].count = this.numParticles * this.numParticleIndices;
			mesh.primitive[0].indexed = true;
			this.material = new Material();
			this.material.name = this.node.name;
			this.material.cull = CULLFACE_NONE;
			this.material.alphaWrite = false;
			this.material.blendType = this.blendType;
			this.material.depthWrite = this.depthWrite;
			this.material.emitter = this;
			this.regenShader();
			this.resetMaterial();
			var wasVisible = this.meshInstance ? this.meshInstance.visible : true;
			this.meshInstance = new MeshInstance(mesh, this.material, this.node);
			this.meshInstance.pick = false;
			this.meshInstance.updateKey();
			this.meshInstance.cull = true;
			this.meshInstance._noDepthDrawGl1 = true;
			if (this.localSpace) {
				this.meshInstance.aabb.setFromTransformedAabb(this.worldBounds, this.node.getWorldTransform());
			} else {
				this.meshInstance.aabb.copy(this.worldBounds);
			}
			this.meshInstance._updateAabb = false;
			this.meshInstance.visible = wasVisible;
			this._initializeTextures();
			this.resetTime();
			this.addTime(0, false);
			if (this.preWarm) this.prewarm(this.lifetime);
		};
		_proto._isAnimated = function _isAnimated() {
			return this.animNumFrames >= 1 && (this.animTilesX > 1 || this.animTilesY > 1) && (this.colorMap && this.colorMap !== this.defaultParamTexture || this.normalMap);
		};
		_proto.rebuildGraphs = function rebuildGraphs() {
			var precision = this.precision;
			var gd = this.graphicsDevice;
			this.qLocalVelocity = this.localVelocityGraph.quantize(precision);
			this.qVelocity = this.velocityGraph.quantize(precision);
			this.qColor = this.colorGraph.quantizeClamped(precision, 0, 1);
			this.qRotSpeed = this.rotationSpeedGraph.quantize(precision);
			this.qScale = this.scaleGraph.quantize(precision);
			this.qAlpha = this.alphaGraph.quantize(precision);
			this.qRadialSpeed = this.radialSpeedGraph.quantize(precision);
			this.qLocalVelocity2 = this.localVelocityGraph2.quantize(precision);
			this.qVelocity2 = this.velocityGraph2.quantize(precision);
			this.qColor2 = this.colorGraph2.quantizeClamped(precision, 0, 1);
			this.qRotSpeed2 = this.rotationSpeedGraph2.quantize(precision);
			this.qScale2 = this.scaleGraph2.quantize(precision);
			this.qAlpha2 = this.alphaGraph2.quantize(precision);
			this.qRadialSpeed2 = this.radialSpeedGraph2.quantize(precision);
			for (var i = 0; i < precision; i++) {
				this.qRotSpeed[i] *= math.DEG_TO_RAD;
				this.qRotSpeed2[i] *= math.DEG_TO_RAD;
			}
			this.localVelocityUMax = new Float32Array(3);
			this.velocityUMax = new Float32Array(3);
			this.colorUMax = new Float32Array(3);
			this.rotSpeedUMax = [0];
			this.scaleUMax = [0];
			this.alphaUMax = [0];
			this.radialSpeedUMax = [0];
			this.qLocalVelocityDiv = divGraphFrom2Curves(this.qLocalVelocity, this.qLocalVelocity2, this.localVelocityUMax);
			this.qVelocityDiv = divGraphFrom2Curves(this.qVelocity, this.qVelocity2, this.velocityUMax);
			this.qColorDiv = divGraphFrom2Curves(this.qColor, this.qColor2, this.colorUMax);
			this.qRotSpeedDiv = divGraphFrom2Curves(this.qRotSpeed, this.qRotSpeed2, this.rotSpeedUMax);
			this.qScaleDiv = divGraphFrom2Curves(this.qScale, this.qScale2, this.scaleUMax);
			this.qAlphaDiv = divGraphFrom2Curves(this.qAlpha, this.qAlpha2, this.alphaUMax);
			this.qRadialSpeedDiv = divGraphFrom2Curves(this.qRadialSpeed, this.qRadialSpeed2, this.radialSpeedUMax);
			if (this.pack8) {
				var umax = [0, 0, 0];
				maxUnsignedGraphValue(this.qVelocity, umax);
				var umax2 = [0, 0, 0];
				maxUnsignedGraphValue(this.qVelocity2, umax2);
				var lumax = [0, 0, 0];
				maxUnsignedGraphValue(this.qLocalVelocity, lumax);
				var lumax2 = [0, 0, 0];
				maxUnsignedGraphValue(this.qLocalVelocity2, lumax2);
				var rumax = [0];
				maxUnsignedGraphValue(this.qRadialSpeed, rumax);
				var rumax2 = [0];
				maxUnsignedGraphValue(this.qRadialSpeed2, rumax2);
				var maxVel = Math.max(umax[0], umax2[0]);
				maxVel = Math.max(maxVel, umax[1]);
				maxVel = Math.max(maxVel, umax2[1]);
				maxVel = Math.max(maxVel, umax[2]);
				maxVel = Math.max(maxVel, umax2[2]);
				var lmaxVel = Math.max(lumax[0], lumax2[0]);
				lmaxVel = Math.max(lmaxVel, lumax[1]);
				lmaxVel = Math.max(lmaxVel, lumax2[1]);
				lmaxVel = Math.max(lmaxVel, lumax[2]);
				lmaxVel = Math.max(lmaxVel, lumax2[2]);
				var maxRad = Math.max(rumax[0], rumax2[0]);
				this.maxVel = maxVel + lmaxVel + maxRad;
			}
			if (!this.useCpu) {
				this.internalTex0 = _createTexture(gd, precision, 1, packTextureXYZ_NXYZ(this.qLocalVelocity, this.qLocalVelocityDiv));
				this.internalTex1 = _createTexture(gd, precision, 1, packTextureXYZ_NXYZ(this.qVelocity, this.qVelocityDiv));
				this.internalTex2 = _createTexture(gd, precision, 1, packTexture5Floats(this.qRotSpeed, this.qScale, this.qScaleDiv, this.qRotSpeedDiv, this.qAlphaDiv));
				this.internalTex3 = _createTexture(gd, precision, 1, packTexture2Floats(this.qRadialSpeed, this.qRadialSpeedDiv));
			}
			this.colorParam = _createTexture(gd, precision, 1, packTextureRGBA(this.qColor, this.qAlpha), PIXELFORMAT_RGBA8, 1.0, true);
		};
		_proto._initializeTextures = function _initializeTextures() {
			if (this.colorMap) {
				this.material.setParameter('colorMap', this.colorMap);
				if (this.lighting && this.normalMap) {
					this.material.setParameter('normalMap', this.normalMap);
				}
			}
		};
		_proto.regenShader = function regenShader() {
			var programLib = getProgramLibrary(this.graphicsDevice);
			programLib.register('particle', particle);
			var hasNormal = this.normalMap !== null;
			this.normalOption = 0;
			if (this.lighting) {
				this.normalOption = hasNormal ? 2 : 1;
			}
			this.material.getShaderVariant = function (dev, sc, defs, unused, pass, sortedLights, viewUniformFormat, viewBindGroupFormat) {
				if (this.emitter.scene) {
					if (this.emitter.camera !== this.emitter.scene._activeCamera) {
						this.emitter.camera = this.emitter.scene._activeCamera;
						this.emitter.onChangeCamera();
					}
				}
				var inTools = this.emitter.inTools;
				var processingOptions = new ShaderProcessorOptions(viewUniformFormat, viewBindGroupFormat);
				var shader = programLib.getProgram('particle', {
					pass: SHADER_FORWARD,
					useCpu: this.emitter.useCpu,
					normal: this.emitter.normalOption,
					halflambert: this.emitter.halfLambert,
					stretch: this.emitter.stretch,
					alignToMotion: this.emitter.alignToMotion,
					soft: this.emitter.depthSoftening,
					mesh: this.emitter.useMesh,
					gamma: this.emitter.scene ? this.emitter.scene.gammaCorrection : 0,
					toneMap: this.emitter.scene ? this.emitter.scene.toneMapping : 0,
					fog: this.emitter.scene && !this.emitter.noFog ? this.emitter.scene.fog : 'none',
					wrap: this.emitter.wrap && this.emitter.wrapBounds,
					localSpace: this.emitter.localSpace,
					screenSpace: inTools ? false : this.emitter.screenSpace,
					blend: this.blendType,
					animTex: this.emitter._isAnimated(),
					animTexLoop: this.emitter.animLoop,
					pack8: this.emitter.pack8,
					customFace: this.emitter.orientation !== PARTICLEORIENTATION_SCREEN
				}, processingOptions);
				return shader;
			};
			this.material.shader = this.material.getShaderVariant();
		};
		_proto.resetMaterial = function resetMaterial() {
			var material = this.material;
			material.setParameter('stretch', this.stretch);
			if (this._isAnimated()) {
				material.setParameter('animTexTilesParams', this.animTilesParams);
				material.setParameter('animTexParams', this.animParams);
				material.setParameter('animTexIndexParams', this.animIndexParams);
			}
			material.setParameter('colorMult', this.intensity);
			if (!this.useCpu) {
				material.setParameter('internalTex0', this.internalTex0);
				material.setParameter('internalTex1', this.internalTex1);
				material.setParameter('internalTex2', this.internalTex2);
				material.setParameter('internalTex3', this.internalTex3);
			}
			material.setParameter('colorParam', this.colorParam);
			material.setParameter('numParticles', this.numParticles);
			material.setParameter('numParticlesPot', this.numParticlesPot);
			material.setParameter('lifetime', this.lifetime);
			material.setParameter('rate', this.rate);
			material.setParameter('rateDiv', this.rate2 - this.rate);
			material.setParameter('seed', this.seed);
			material.setParameter('scaleDivMult', this.scaleUMax[0]);
			material.setParameter('alphaDivMult', this.alphaUMax[0]);
			material.setParameter('radialSpeedDivMult', this.radialSpeedUMax[0]);
			material.setParameter('graphNumSamples', this.precision);
			material.setParameter('graphSampleSize', 1.0 / this.precision);
			material.setParameter('emitterScale', new Float32Array([1, 1, 1]));
			if (this.pack8) {
				this._gpuUpdater._setInputBounds();
				material.setParameter('inBoundsSize', this._gpuUpdater.inBoundsSizeUniform);
				material.setParameter('inBoundsCenter', this._gpuUpdater.inBoundsCenterUniform);
				material.setParameter('maxVel', this.maxVel);
			}
			if (this.wrap && this.wrapBounds) {
				this.wrapBoundsUniform[0] = this.wrapBounds.x;
				this.wrapBoundsUniform[1] = this.wrapBounds.y;
				this.wrapBoundsUniform[2] = this.wrapBounds.z;
				material.setParameter('wrapBounds', this.wrapBoundsUniform);
			}
			if (this.colorMap) {
				material.setParameter('colorMap', this.colorMap);
			}
			if (this.lighting) {
				if (this.normalMap) {
					material.setParameter('normalMap', this.normalMap);
				}
			}
			if (this.depthSoftening > 0) {
				material.setParameter('softening', 1.0 / (this.depthSoftening * this.depthSoftening * 100));
			}
			if (this.stretch > 0.0) material.cull = CULLFACE_NONE;
			this._compParticleFaceParams();
		};
		_proto._compParticleFaceParams = function _compParticleFaceParams() {
			var tangent, binormal;
			if (this.orientation === PARTICLEORIENTATION_SCREEN) {
				tangent = new Float32Array([1, 0, 0]);
				binormal = new Float32Array([0, 0, 1]);
			} else {
				var n;
				if (this.orientation === PARTICLEORIENTATION_WORLD) {
					n = this.particleNormal.normalize();
				} else {
					var emitterMat = this.node === null ? Mat4.IDENTITY : this.node.getWorldTransform();
					n = emitterMat.transformVector(this.particleNormal).normalize();
				}
				var t = new Vec3(1, 0, 0);
				if (Math.abs(t.dot(n)) === 1) t.set(0, 0, 1);
				var b = new Vec3().cross(n, t).normalize();
				t.cross(b, n).normalize();
				tangent = new Float32Array([t.x, t.y, t.z]);
				binormal = new Float32Array([b.x, b.y, b.z]);
			}
			this.material.setParameter('faceTangent', tangent);
			this.material.setParameter('faceBinorm', binormal);
		};
		_proto._allocate = function _allocate(numParticles) {
			var psysVertCount = numParticles * this.numParticleVerts;
			var psysIndexCount = numParticles * this.numParticleIndices;
			if (this.vertexBuffer === undefined || this.vertexBuffer.getNumVertices() !== psysVertCount) {
				if (!this.useCpu) {
					var elements = [{
						semantic: SEMANTIC_ATTR0,
						components: 4,
						type: TYPE_FLOAT32
					}];
					if (this.useMesh) {
						elements.push({
							semantic: SEMANTIC_ATTR1,
							components: 2,
							type: TYPE_FLOAT32
						});
					}
					var particleFormat = new VertexFormat(this.graphicsDevice, elements);
					this.vertexBuffer = new VertexBuffer(this.graphicsDevice, particleFormat, psysVertCount, BUFFER_DYNAMIC);
					this.indexBuffer = new IndexBuffer(this.graphicsDevice, INDEXFORMAT_UINT16, psysIndexCount);
				} else {
					var _elements = [{
						semantic: SEMANTIC_ATTR0,
						components: 4,
						type: TYPE_FLOAT32
					}, {
						semantic: SEMANTIC_ATTR1,
						components: 4,
						type: TYPE_FLOAT32
					}, {
						semantic: SEMANTIC_ATTR2,
						components: 4,
						type: TYPE_FLOAT32
					}, {
						semantic: SEMANTIC_ATTR3,
						components: 1,
						type: TYPE_FLOAT32
					}, {
						semantic: SEMANTIC_ATTR4,
						components: this.useMesh ? 4 : 2,
						type: TYPE_FLOAT32
					}];
					var _particleFormat = new VertexFormat(this.graphicsDevice, _elements);
					this.vertexBuffer = new VertexBuffer(this.graphicsDevice, _particleFormat, psysVertCount, BUFFER_DYNAMIC);
					this.indexBuffer = new IndexBuffer(this.graphicsDevice, INDEXFORMAT_UINT16, psysIndexCount);
				}
				var data = new Float32Array(this.vertexBuffer.lock());
				var meshData, stride, texCoordOffset;
				if (this.useMesh) {
					meshData = new Float32Array(this.mesh.vertexBuffer.lock());
					stride = meshData.length / this.mesh.vertexBuffer.numVertices;
					for (var elem = 0; elem < this.mesh.vertexBuffer.format.elements.length; elem++) {
						if (this.mesh.vertexBuffer.format.elements[elem].name === SEMANTIC_TEXCOORD0) {
							texCoordOffset = this.mesh.vertexBuffer.format.elements[elem].offset / 4;
							break;
						}
					}
				}
				for (var i = 0; i < psysVertCount; i++) {
					var id = Math.floor(i / this.numParticleVerts);
					if (!this.useMesh) {
						var vertID = i % 4;
						data[i * 4] = particleVerts[vertID][0];
						data[i * 4 + 1] = particleVerts[vertID][1];
						data[i * 4 + 2] = 0;
						data[i * 4 + 3] = id;
					} else {
						var vert = i % this.numParticleVerts;
						data[i * 6] = meshData[vert * stride];
						data[i * 6 + 1] = meshData[vert * stride + 1];
						data[i * 6 + 2] = meshData[vert * stride + 2];
						data[i * 6 + 3] = id;
						data[i * 6 + 4] = meshData[vert * stride + texCoordOffset + 0];
						data[i * 6 + 5] = 1.0 - meshData[vert * stride + texCoordOffset + 1];
					}
				}
				if (this.useCpu) {
					this.vbCPU = new Float32Array(data);
					this.vbOld = new Float32Array(this.vbCPU.length);
				}
				this.vertexBuffer.unlock();
				if (this.useMesh) {
					this.mesh.vertexBuffer.unlock();
				}
				var dst = 0;
				var indices = new Uint16Array(this.indexBuffer.lock());
				if (this.useMesh) meshData = new Uint16Array(this.mesh.indexBuffer[0].lock());
				for (var _i2 = 0; _i2 < numParticles; _i2++) {
					if (!this.useMesh) {
						var baseIndex = _i2 * 4;
						indices[dst++] = baseIndex;
						indices[dst++] = baseIndex + 1;
						indices[dst++] = baseIndex + 2;
						indices[dst++] = baseIndex;
						indices[dst++] = baseIndex + 2;
						indices[dst++] = baseIndex + 3;
					} else {
						for (var j = 0; j < this.numParticleIndices; j++) {
							indices[_i2 * this.numParticleIndices + j] = meshData[j] + _i2 * this.numParticleVerts;
						}
					}
				}
				this.indexBuffer.unlock();
				if (this.useMesh) this.mesh.indexBuffer[0].unlock();
			}
		};
		_proto.reset = function reset() {
			this.beenReset = true;
			this.seed = Math.random();
			this.material.setParameter('seed', this.seed);
			if (this.useCpu) {
				for (var i = 0; i < this.particleTexStart.length; i++) {
					this.particleTex[i] = this.particleTexStart[i];
				}
			} else {
				this._initializeTextures();
			}
			this.resetWorldBounds();
			this.resetTime();
			var origLoop = this.loop;
			this.loop = true;
			this.addTime(0, false);
			this.loop = origLoop;
			if (this.preWarm) {
				this.prewarm(this.lifetime);
			}
		};
		_proto.prewarm = function prewarm(time) {
			var lifetimeFraction = time / this.lifetime;
			var iterations = Math.min(Math.floor(lifetimeFraction * this.precision), this.precision);
			var stepDelta = time / iterations;
			for (var i = 0; i < iterations; i++) {
				this.addTime(stepDelta, false);
			}
		};
		_proto.resetTime = function resetTime() {
			this.endTime = calcEndTime(this);
		};
		_proto.finishFrame = function finishFrame() {
			if (this.useCpu) this.vertexBuffer.unlock();
		};
		_proto.addTime = function addTime(delta, isOnStop) {
			var device = this.graphicsDevice;
			this.simTimeTotal += delta;
			this.calculateWorldBounds();
			if (this._isAnimated()) {
				var tilesParams = this.animTilesParams;
				tilesParams[0] = 1.0 / this.animTilesX;
				tilesParams[1] = 1.0 / this.animTilesY;
				var params = this.animParams;
				params[0] = this.animStartFrame;
				params[1] = this.animNumFrames * this.animSpeed;
				params[2] = this.animNumFrames - 1;
				params[3] = this.animNumAnimations - 1;
				var animIndexParams = this.animIndexParams;
				animIndexParams[0] = this.animIndex;
				animIndexParams[1] = this.randomizeAnimIndex;
			}
			if (this.scene) {
				if (this.camera !== this.scene._activeCamera) {
					this.camera = this.scene._activeCamera;
					this.onChangeCamera();
				}
			}
			if (this.emitterShape === EMITTERSHAPE_BOX) {
				extentsInnerRatioUniform[0] = this.emitterExtents.x !== 0 ? this.emitterExtentsInner.x / this.emitterExtents.x : 0;
				extentsInnerRatioUniform[1] = this.emitterExtents.y !== 0 ? this.emitterExtentsInner.y / this.emitterExtents.y : 0;
				extentsInnerRatioUniform[2] = this.emitterExtents.z !== 0 ? this.emitterExtentsInner.z / this.emitterExtents.z : 0;
				if (this.meshInstance.node === null) {
					spawnMatrix.setTRS(Vec3.ZERO, Quat.IDENTITY, this.emitterExtents);
				} else {
					spawnMatrix.setTRS(Vec3.ZERO, this.meshInstance.node.getRotation(), tmpVec3.copy(this.emitterExtents).mul(this.meshInstance.node.localScale));
				}
			}
			var emitterPos;
			var emitterScale = this.meshInstance.node === null ? Vec3.ONE : this.meshInstance.node.localScale;
			this.emitterScaleUniform[0] = emitterScale.x;
			this.emitterScaleUniform[1] = emitterScale.y;
			this.emitterScaleUniform[2] = emitterScale.z;
			this.material.setParameter('emitterScale', this.emitterScaleUniform);
			if (this.localSpace && this.meshInstance.node) {
				emitterPos = this.meshInstance.node.getPosition();
				this.emitterPosUniform[0] = emitterPos.x;
				this.emitterPosUniform[1] = emitterPos.y;
				this.emitterPosUniform[2] = emitterPos.z;
				this.material.setParameter('emitterPos', this.emitterPosUniform);
			}
			this._compParticleFaceParams();
			if (!this.useCpu) {
				this._gpuUpdater.update(device, spawnMatrix, extentsInnerRatioUniform, delta, isOnStop);
			} else {
				var data = new Float32Array(this.vertexBuffer.lock());
				this._cpuUpdater.update(data, this.vbToSort, this.particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, delta, isOnStop);
			}
			if (!this.loop) {
				if (Date.now() > this.endTime) {
					if (this.onFinished) this.onFinished();
					this.meshInstance.visible = false;
				}
			}
			if (this.meshInstance) {
				this.meshInstance.drawOrder = this.drawOrder;
			}
		};
		_proto._destroyResources = function _destroyResources() {
			if (this.particleTexIN) {
				this.particleTexIN.destroy();
				this.particleTexIN = null;
			}
			if (this.particleTexOUT) {
				this.particleTexOUT.destroy();
				this.particleTexOUT = null;
			}
			if (this.particleTexStart && this.particleTexStart.destroy) {
				this.particleTexStart.destroy();
				this.particleTexStart = null;
			}
			if (this.rtParticleTexIN) {
				this.rtParticleTexIN.destroy();
				this.rtParticleTexIN = null;
			}
			if (this.rtParticleTexOUT) {
				this.rtParticleTexOUT.destroy();
				this.rtParticleTexOUT = null;
			}
			if (this.internalTex0) {
				this.internalTex0.destroy();
				this.internalTex0 = null;
			}
			if (this.internalTex1) {
				this.internalTex1.destroy();
				this.internalTex1 = null;
			}
			if (this.internalTex2) {
				this.internalTex2.destroy();
				this.internalTex2 = null;
			}
			if (this.internalTex3) {
				this.internalTex3.destroy();
				this.internalTex3 = null;
			}
			if (this.colorParam) {
				this.colorParam.destroy();
				this.colorParam = null;
			}
			if (this.vertexBuffer) {
				this.vertexBuffer.destroy();
				this.vertexBuffer = undefined;
			}
			if (this.indexBuffer) {
				this.indexBuffer.destroy();
				this.indexBuffer = undefined;
			}
			if (this.material) {
				this.material.destroy();
				this.material = null;
			}
		};
		_proto.destroy = function destroy() {
			this.camera = null;
			this._destroyResources();
		};
		_createClass(ParticleEmitter, [{
			key: "defaultParamTexture",
			get: function get() {
				var _this = this;
				return particleEmitterDeviceCache.get(this.graphicsDevice, function () {
					var resolution = 16;
					var centerPoint = resolution * 0.5 + 0.5;
					var dtex = new Float32Array(resolution * resolution * 4);
					for (var y = 0; y < resolution; y++) {
						for (var x = 0; x < resolution; x++) {
							var xgrad = x + 1 - centerPoint;
							var ygrad = y + 1 - centerPoint;
							var c = saturate(1 - saturate(Math.sqrt(xgrad * xgrad + ygrad * ygrad) / resolution) - 0.5);
							var p = y * resolution + x;
							dtex[p * 4] = 1;
							dtex[p * 4 + 1] = 1;
							dtex[p * 4 + 2] = 1;
							dtex[p * 4 + 3] = c;
						}
					}
					var texture = _createTexture(_this.graphicsDevice, resolution, resolution, dtex, PIXELFORMAT_RGBA8, 1.0, true);
					texture.minFilter = FILTER_LINEAR;
					texture.magFilter = FILTER_LINEAR;
					return texture;
				});
			}
		}]);
		return ParticleEmitter;
	}();

	var ShaderGeneratorSkybox = function (_ShaderGenerator) {
		_inheritsLoose(ShaderGeneratorSkybox, _ShaderGenerator);
		function ShaderGeneratorSkybox() {
			return _ShaderGenerator.apply(this, arguments) || this;
		}
		var _proto = ShaderGeneratorSkybox.prototype;
		_proto.generateKey = function generateKey(options) {
			return options.type === 'cubemap' ? "skybox-" + options.type + "-" + options.encoding + "-" + options.useIntensity + "-" + options.gamma + "-" + options.toneMapping + "-" + options.fixSeams + "-" + options.mip : "skybox-" + options.type + "-" + options.encoding + "-" + options.useIntensity + "-" + options.gamma + "-" + options.toneMapping;
		};
		_proto.createShaderDefinition = function createShaderDefinition(device, options) {
			var fshader = '';
			if (options.type === 'cubemap') {
				var mip2size = [128, 64, 16, 8, 4, 2];
				fshader += options.mip ? shaderChunks.fixCubemapSeamsStretchPS : shaderChunks.fixCubemapSeamsNonePS;
				fshader += options.useIntensity ? shaderChunks.envMultiplyPS : shaderChunks.envConstPS;
				fshader += shaderChunks.decodePS;
				fshader += ShaderGenerator.gammaCode(options.gamma);
				fshader += ShaderGenerator.tonemapCode(options.toneMapping);
				fshader += shaderChunks.skyboxHDRPS.replace(/\$DECODE/g, ChunkUtils.decodeFunc(options.encoding)).replace(/\$FIXCONST/g, 1 - 1 / mip2size[options.mip] + "");
			} else {
				fshader += options.useIntensity ? shaderChunks.envMultiplyPS : shaderChunks.envConstPS;
				fshader += shaderChunks.decodePS;
				fshader += ShaderGenerator.gammaCode(options.gamma);
				fshader += ShaderGenerator.tonemapCode(options.toneMapping);
				fshader += shaderChunks.sphericalPS;
				fshader += shaderChunks.envAtlasPS;
				fshader += shaderChunks.skyboxEnvPS.replace(/\$DECODE/g, ChunkUtils.decodeFunc(options.encoding));
			}
			return ShaderUtils.createDefinition(device, {
				name: 'SkyboxShader',
				attributes: {
					aPosition: SEMANTIC_POSITION
				},
				vertexCode: shaderChunks.skyboxVS,
				fragmentCode: fshader
			});
		};
		return ShaderGeneratorSkybox;
	}(ShaderGenerator);
	var skybox = new ShaderGeneratorSkybox();

	var Sky = function () {
		function Sky(device, scene, texture) {
			this.meshInstance = void 0;
			var material = new Material();
			material.getShaderVariant = function (dev, sc, defs, unused, pass, sortedLights, viewUniformFormat, viewBindGroupFormat) {
				var options = {
					pass: pass,
					encoding: texture.encoding,
					useIntensity: scene.skyboxIntensity !== 1 || scene.physicalUnits,
					gamma: pass === SHADER_FORWARDHDR ? scene.gammaCorrection ? GAMMA_SRGBHDR : GAMMA_NONE : scene.gammaCorrection,
					toneMapping: pass === SHADER_FORWARDHDR ? TONEMAP_LINEAR : scene.toneMapping
				};
				if (texture.cubemap) {
					options.type = 'cubemap';
					options.mip = texture.fixCubemapSeams ? scene.skyboxMip : 0;
					options.fixSeams = texture.fixCubemapSeams;
				} else {
					options.type = 'envAtlas';
				}
				var processingOptions = new ShaderProcessorOptions(viewUniformFormat, viewBindGroupFormat);
				var library = getProgramLibrary(device);
				library.register('skybox', skybox);
				return library.getProgram('skybox', options, processingOptions);
			};
			if (texture.cubemap) {
				material.setParameter('texture_cubeMap', texture);
			} else {
				material.setParameter('texture_envAtlas', texture);
				material.setParameter('mipLevel', scene._skyboxMip);
			}
			material.cull = CULLFACE_FRONT;
			material.depthWrite = false;
			var skyLayer = scene.layers.getLayerById(LAYERID_SKYBOX);
			if (skyLayer) {
				var node = new GraphNode('Skybox');
				var mesh = createBox(device);
				var meshInstance = new MeshInstance(mesh, material, node);
				this.meshInstance = meshInstance;
				meshInstance.cull = false;
				meshInstance._noDepthDrawGl1 = true;
				meshInstance.pick = false;
				skyLayer.addMeshInstances([meshInstance]);
				this.skyLayer = skyLayer;
			}
		}
		var _proto = Sky.prototype;
		_proto.destroy = function destroy() {
			if (this.meshInstance) {
				if (this.skyLayer) {
					this.skyLayer.removeMeshInstances([this.meshInstance]);
				}
				this.meshInstance.destroy();
				this.meshInstance = null;
			}
		};
		return Sky;
	}();

	var identityGraphNode = new GraphNode();
	identityGraphNode.worldTransform = Mat4.IDENTITY;
	identityGraphNode._dirtyWorld = identityGraphNode._dirtyNormal = false;
	var ImmediateBatch = function () {
		function ImmediateBatch(device, material, layer) {
			this.material = material;
			this.layer = layer;
			this.positions = [];
			this.colors = [];
			this.mesh = new Mesh(device);
			this.meshInstance = null;
		}
		var _proto = ImmediateBatch.prototype;
		_proto.addLines = function addLines(positions, color) {
			var destPos = this.positions;
			var count = positions.length;
			for (var i = 0; i < count; i++) {
				var pos = positions[i];
				destPos.push(pos.x, pos.y, pos.z);
			}
			var destCol = this.colors;
			if (color.length) {
				for (var _i = 0; _i < count; _i++) {
					var col = color[_i];
					destCol.push(col.r, col.g, col.b, col.a);
				}
			} else {
				for (var _i2 = 0; _i2 < count; _i2++) {
					destCol.push(color.r, color.g, color.b, color.a);
				}
			}
		};
		_proto.addLinesArrays = function addLinesArrays(positions, color) {
			var destPos = this.positions;
			for (var i = 0; i < positions.length; i += 3) {
				destPos.push(positions[i], positions[i + 1], positions[i + 2]);
			}
			var destCol = this.colors;
			if (color.length) {
				for (var _i3 = 0; _i3 < color.length; _i3 += 4) {
					destCol.push(color[_i3], color[_i3 + 1], color[_i3 + 2], color[_i3 + 3]);
				}
			} else {
				var count = positions.length / 3;
				for (var _i4 = 0; _i4 < count; _i4++) {
					destCol.push(color.r, color.g, color.b, color.a);
				}
			}
		};
		_proto.onPreRender = function onPreRender(visibleList, transparent) {
			if (this.positions.length > 0 && this.material.transparent === transparent) {
				this.mesh.setPositions(this.positions);
				this.mesh.setColors(this.colors);
				this.mesh.update(PRIMITIVE_LINES, false);
				if (!this.meshInstance) {
					this.meshInstance = new MeshInstance(this.mesh, this.material, identityGraphNode);
				}
				this.positions.length = 0;
				this.colors.length = 0;
				visibleList.push(this.meshInstance);
			}
		};
		return ImmediateBatch;
	}();

	var ImmediateBatches = function () {
		function ImmediateBatches(device) {
			this.device = device;
			this.map = new Map();
		}
		var _proto = ImmediateBatches.prototype;
		_proto.getBatch = function getBatch(material, layer) {
			var batch = this.map.get(material);
			if (!batch) {
				batch = new ImmediateBatch(this.device, material, layer);
				this.map.set(material, batch);
			}
			return batch;
		};
		_proto.onPreRender = function onPreRender(visibleList, transparent) {
			this.map.forEach(function (batch) {
				batch.onPreRender(visibleList, transparent);
			});
		};
		return ImmediateBatches;
	}();

	var tempPoints = [];
	var Immediate = function () {
		function Immediate(device) {
			this.device = device;
			this.quadMesh = null;
			this.textureShader = null;
			this.depthTextureShader = null;
			this.cubeLocalPos = null;
			this.cubeWorldPos = null;
			this.batchesMap = new Map();
			this.allBatches = new Set();
			this.updatedLayers = new Set();
			this._materialDepth = null;
			this._materialNoDepth = null;
			this.layerMeshInstances = new Map();
		}
		var _proto = Immediate.prototype;
		_proto.createMaterial = function createMaterial(depthTest) {
			var material = new BasicMaterial();
			material.vertexColors = true;
			material.blendType = BLEND_NORMAL;
			material.depthTest = depthTest;
			material.update();
			return material;
		};
		_proto.getBatch = function getBatch(layer, depthTest) {
			var batches = this.batchesMap.get(layer);
			if (!batches) {
				batches = new ImmediateBatches(this.device);
				this.batchesMap.set(layer, batches);
			}
			this.allBatches.add(batches);
			var material = depthTest ? this.materialDepth : this.materialNoDepth;
			return batches.getBatch(material, layer);
		};
		_proto.getShader = function getShader(id, fragment) {
			if (!this[id]) {
				var vertex = "\n\t\t\t\tattribute vec2 vertex_position;\n\t\t\t\tuniform mat4 matrix_model;\n\t\t\t\tvarying vec2 uv0;\n\t\t\t\tvoid main(void) {\n\t\t\t\t\tgl_Position = matrix_model * vec4(vertex_position, 0, 1);\n\t\t\t\t\tuv0 = vertex_position.xy + 0.5;\n\t\t\t\t}\n\t\t\t";
				this[id] = createShaderFromCode(this.device, vertex, fragment, "DebugShader:" + id);
			}
			return this[id];
		};
		_proto.getTextureShader = function getTextureShader() {
			return this.getShader('textureShader', "\n\t\t\tvarying vec2 uv0;\n\t\t\tuniform sampler2D colorMap;\n\t\t\tvoid main (void) {\n\t\t\t\tgl_FragColor = vec4(texture2D(colorMap, uv0).xyz, 1);\n\t\t\t}\n\t\t");
		};
		_proto.getUnfilterableTextureShader = function getUnfilterableTextureShader() {
			return this.getShader('textureShaderUnfilterable', "\n\t\t\tvarying vec2 uv0;\n\t\t\tuniform highp sampler2D colorMap;\n\t\t\tvoid main (void) {\n\t\t\t\tivec2 uv = ivec2(uv0 * textureSize(colorMap, 0));\n\t\t\t\tgl_FragColor = vec4(texelFetch(colorMap, uv, 0).xyz, 1);\n\t\t\t}\n\t\t");
		};
		_proto.getDepthTextureShader = function getDepthTextureShader() {
			return this.getShader('depthTextureShader', "\n\t\t\t" + shaderChunks.screenDepthPS + "\n\t\t\tvarying vec2 uv0;\n\t\t\tvoid main() {\n\t\t\t\tfloat depth = getLinearScreenDepth(uv0) * camera_params.x;\n\t\t\t\tgl_FragColor = vec4(vec3(depth), 1.0);\n\t\t\t}\n\t\t");
		};
		_proto.getQuadMesh = function getQuadMesh() {
			if (!this.quadMesh) {
				this.quadMesh = new Mesh(this.device);
				this.quadMesh.setPositions([-0.5, -0.5, 0, 0.5, -0.5, 0, -0.5, 0.5, 0, 0.5, 0.5, 0]);
				this.quadMesh.update(PRIMITIVE_TRISTRIP);
			}
			return this.quadMesh;
		};
		_proto.drawMesh = function drawMesh(material, matrix, mesh, meshInstance, layer) {
			if (!meshInstance) {
				var graphNode = this.getGraphNode(matrix);
				meshInstance = new MeshInstance(mesh, material, graphNode);
			}
			var layerMeshInstances = this.layerMeshInstances.get(layer);
			if (!layerMeshInstances) {
				layerMeshInstances = [];
				this.layerMeshInstances.set(layer, layerMeshInstances);
			}
			layerMeshInstances.push(meshInstance);
		};
		_proto.drawWireAlignedBox = function drawWireAlignedBox(min, max, color, depthTest, layer) {
			tempPoints.push(min.x, min.y, min.z, min.x, max.y, min.z, min.x, max.y, min.z, max.x, max.y, min.z, max.x, max.y, min.z, max.x, min.y, min.z, max.x, min.y, min.z, min.x, min.y, min.z, min.x, min.y, max.z, min.x, max.y, max.z, min.x, max.y, max.z, max.x, max.y, max.z, max.x, max.y, max.z, max.x, min.y, max.z, max.x, min.y, max.z, min.x, min.y, max.z, min.x, min.y, min.z, min.x, min.y, max.z, min.x, max.y, min.z, min.x, max.y, max.z, max.x, max.y, min.z, max.x, max.y, max.z, max.x, min.y, min.z, max.x, min.y, max.z);
			var batch = this.getBatch(layer, depthTest);
			batch.addLinesArrays(tempPoints, color);
			tempPoints.length = 0;
		};
		_proto.drawWireSphere = function drawWireSphere(center, radius, color, numSegments, depthTest, layer) {
			var step = 2 * Math.PI / numSegments;
			var angle = 0;
			for (var i = 0; i < numSegments; i++) {
				var sin0 = Math.sin(angle);
				var cos0 = Math.cos(angle);
				angle += step;
				var sin1 = Math.sin(angle);
				var cos1 = Math.cos(angle);
				tempPoints.push(center.x + radius * sin0, center.y, center.z + radius * cos0);
				tempPoints.push(center.x + radius * sin1, center.y, center.z + radius * cos1);
				tempPoints.push(center.x + radius * sin0, center.y + radius * cos0, center.z);
				tempPoints.push(center.x + radius * sin1, center.y + radius * cos1, center.z);
				tempPoints.push(center.x, center.y + radius * sin0, center.z + radius * cos0);
				tempPoints.push(center.x, center.y + radius * sin1, center.z + radius * cos1);
			}
			var batch = this.getBatch(layer, depthTest);
			batch.addLinesArrays(tempPoints, color);
			tempPoints.length = 0;
		};
		_proto.getGraphNode = function getGraphNode(matrix) {
			var graphNode = new GraphNode('ImmediateDebug');
			graphNode.worldTransform = matrix;
			graphNode._dirtyWorld = graphNode._dirtyNormal = false;
			return graphNode;
		};
		_proto.onPreRenderLayer = function onPreRenderLayer(layer, visibleList, transparent) {
			this.batchesMap.forEach(function (batches, batchLayer) {
				if (batchLayer === layer) {
					batches.onPreRender(visibleList, transparent);
				}
			});
			if (!this.updatedLayers.has(layer)) {
				this.updatedLayers.add(layer);
				var meshInstances = this.layerMeshInstances.get(layer);
				if (meshInstances) {
					for (var i = 0; i < meshInstances.length; i++) {
						visibleList.push(meshInstances[i]);
					}
					meshInstances.length = 0;
				}
			}
		};
		_proto.onPostRender = function onPostRender() {
			this.allBatches.clear();
			this.updatedLayers.clear();
		};
		_createClass(Immediate, [{
			key: "materialDepth",
			get: function get() {
				if (!this._materialDepth) {
					this._materialDepth = this.createMaterial(true);
				}
				return this._materialDepth;
			}
		}, {
			key: "materialNoDepth",
			get: function get() {
				if (!this._materialNoDepth) {
					this._materialNoDepth = this.createMaterial(false);
				}
				return this._materialNoDepth;
			}
		}]);
		return Immediate;
	}();

	var Scene = function (_EventHandler) {
		_inheritsLoose(Scene, _EventHandler);
		function Scene(graphicsDevice) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this.ambientBake = false;
			_this.ambientBakeOcclusionBrightness = 0;
			_this.ambientBakeOcclusionContrast = 0;
			_this.ambientLight = new Color(0, 0, 0);
			_this.ambientLuminance = 0;
			_this.exposure = 1;
			_this.fogColor = new Color(0, 0, 0);
			_this.fogDensity = 0;
			_this.fogEnd = 1000;
			_this.fogStart = 1;
			_this.lightmapSizeMultiplier = 1;
			_this.lightmapMaxResolution = 2048;
			_this.lightmapMode = BAKE_COLORDIR;
			_this.lightmapFilterEnabled = false;
			_this.lightmapHDR = false;
			_this.root = null;
			_this.sky = null;
			_this.physicalUnits = false;
			_this.device = graphicsDevice || GraphicsDeviceAccess.get();
			_this._gravity = new Vec3(0, -9.8, 0);
			_this._layers = null;
			_this._fog = FOG_NONE;
			_this._gammaCorrection = GAMMA_SRGB;
			_this._toneMapping = 0;
			_this._skyboxCubeMap = null;
			_this._prefilteredCubemaps = [];
			_this._envAtlas = null;
			_this._internalEnvAtlas = null;
			_this._skyboxIntensity = 1;
			_this._skyboxLuminance = 0;
			_this._skyboxMip = 0;
			_this._skyboxRotationShaderInclude = false;
			_this._skyboxRotation = new Quat();
			_this._skyboxRotationMat3 = new Mat3();
			_this._skyboxRotationMat4 = new Mat4();
			_this._ambientBakeNumSamples = 1;
			_this._ambientBakeSpherePart = 0.4;
			_this._lightmapFilterRange = 10;
			_this._lightmapFilterSmoothness = 0.2;
			_this._clusteredLightingEnabled = true;
			_this._lightingParams = new LightingParams(_this.device.supportsAreaLights, _this.device.maxTextureSize, function () {
				_this.updateShaders = true;
			});
			_this._stats = {
				meshInstances: 0,
				lights: 0,
				dynamicLights: 0,
				bakedLights: 0,
				updateShadersTime: 0
			};
			_this.updateShaders = true;
			_this._shaderVersion = 0;
			_this.immediate = new Immediate(_this.device);
			return _this;
		}
		var _proto = Scene.prototype;
		_proto.destroy = function destroy() {
			this._resetSky();
			this.root = null;
			this.off();
		};
		_proto.drawLine = function drawLine(start, end, color, depthTest, layer) {
			if (color === void 0) {
				color = Color.WHITE;
			}
			if (depthTest === void 0) {
				depthTest = true;
			}
			if (layer === void 0) {
				layer = this.defaultDrawLayer;
			}
			var batch = this.immediate.getBatch(layer, depthTest);
			batch.addLines([start, end], [color, color]);
		};
		_proto.drawLines = function drawLines(positions, colors, depthTest, layer) {
			if (depthTest === void 0) {
				depthTest = true;
			}
			if (layer === void 0) {
				layer = this.defaultDrawLayer;
			}
			var batch = this.immediate.getBatch(layer, depthTest);
			batch.addLines(positions, colors);
		};
		_proto.drawLineArrays = function drawLineArrays(positions, colors, depthTest, layer) {
			if (depthTest === void 0) {
				depthTest = true;
			}
			if (layer === void 0) {
				layer = this.defaultDrawLayer;
			}
			var batch = this.immediate.getBatch(layer, depthTest);
			batch.addLinesArrays(positions, colors);
		};
		_proto.applySettings = function applySettings(settings) {
			var _render$skyboxIntensi,
				_render$skyboxLuminan,
				_render$skyboxMip,
				_render$clusteredLigh,
				_this2 = this;
			var physics = settings.physics;
			var render = settings.render;
			this._gravity.set(physics.gravity[0], physics.gravity[1], physics.gravity[2]);
			this.ambientLight.set(render.global_ambient[0], render.global_ambient[1], render.global_ambient[2]);
			this.ambientLuminance = render.ambientLuminance;
			this._fog = render.fog;
			this.fogColor.set(render.fog_color[0], render.fog_color[1], render.fog_color[2]);
			this.fogStart = render.fog_start;
			this.fogEnd = render.fog_end;
			this.fogDensity = render.fog_density;
			this._gammaCorrection = render.gamma_correction;
			this._toneMapping = render.tonemapping;
			this.lightmapSizeMultiplier = render.lightmapSizeMultiplier;
			this.lightmapMaxResolution = render.lightmapMaxResolution;
			this.lightmapMode = render.lightmapMode;
			this.exposure = render.exposure;
			this._skyboxIntensity = (_render$skyboxIntensi = render.skyboxIntensity) != null ? _render$skyboxIntensi : 1;
			this._skyboxLuminance = (_render$skyboxLuminan = render.skyboxLuminance) != null ? _render$skyboxLuminan : 20000;
			this._skyboxMip = (_render$skyboxMip = render.skyboxMip) != null ? _render$skyboxMip : 0;
			if (render.skyboxRotation) {
				this.skyboxRotation = new Quat().setFromEulerAngles(render.skyboxRotation[0], render.skyboxRotation[1], render.skyboxRotation[2]);
			}
			this.clusteredLightingEnabled = (_render$clusteredLigh = render.clusteredLightingEnabled) != null ? _render$clusteredLigh : false;
			this.lighting.applySettings(render);
			['lightmapFilterEnabled', 'lightmapFilterRange', 'lightmapFilterSmoothness', 'ambientBake', 'ambientBakeNumSamples', 'ambientBakeSpherePart', 'ambientBakeOcclusionBrightness', 'ambientBakeOcclusionContrast'].forEach(function (setting) {
				if (render.hasOwnProperty(setting)) {
					_this2[setting] = render[setting];
				}
			});
			this._resetSky();
		};
		_proto._getSkyboxTex = function _getSkyboxTex() {
			var cubemaps = this._prefilteredCubemaps;
			if (this._skyboxMip) {
				var skyboxMapping = [0, 1, 3, 4, 5, 6];
				return cubemaps[skyboxMapping[this._skyboxMip]] || this._envAtlas || cubemaps[0] || this._skyboxCubeMap;
			}
			return this._skyboxCubeMap || cubemaps[0] || this._envAtlas;
		};
		_proto._updateSky = function _updateSky(device) {
			if (!this.sky) {
				var texture = this._getSkyboxTex();
				if (texture) {
					this.sky = new Sky(device, this, texture);
					this.fire('set:skybox', texture);
				}
			}
		};
		_proto._resetSky = function _resetSky() {
			var _this$sky;
			(_this$sky = this.sky) == null || _this$sky.destroy();
			this.sky = null;
			this.updateShaders = true;
		};
		_proto.setSkybox = function setSkybox(cubemaps) {
			if (!cubemaps) {
				this.skybox = null;
				this.envAtlas = null;
			} else {
				this.skybox = cubemaps[0] || null;
				if (cubemaps[1] && !cubemaps[1].cubemap) {
					this.envAtlas = cubemaps[1];
				} else {
					this.prefilteredCubemaps = cubemaps.slice(1);
				}
			}
		};
		_createClass(Scene, [{
			key: "defaultDrawLayer",
			get: function get() {
				return this.layers.getLayerById(LAYERID_IMMEDIATE);
			}
		}, {
			key: "ambientBakeNumSamples",
			get: function get() {
				return this._ambientBakeNumSamples;
			},
			set: function set(value) {
				this._ambientBakeNumSamples = math.clamp(Math.floor(value), 1, 255);
			}
		}, {
			key: "ambientBakeSpherePart",
			get: function get() {
				return this._ambientBakeSpherePart;
			},
			set: function set(value) {
				this._ambientBakeSpherePart = math.clamp(value, 0.001, 1);
			}
		}, {
			key: "clusteredLightingEnabled",
			get: function get() {
				return this._clusteredLightingEnabled;
			},
			set: function set(value) {
				if (this.device.isWebGPU && !value) {
					return;
				}
				if (!this._clusteredLightingEnabled && value) {
					console.error('Turning on disabled clustered lighting is not currently supported');
					return;
				}
				this._clusteredLightingEnabled = value;
			}
		}, {
			key: "envAtlas",
			get: function get() {
				return this._envAtlas;
			},
			set: function set(value) {
				if (value !== this._envAtlas) {
					this._envAtlas = value;
					if (value) {
						value.addressU = ADDRESS_CLAMP_TO_EDGE;
						value.addressV = ADDRESS_CLAMP_TO_EDGE;
						value.minFilter = FILTER_LINEAR;
						value.magFilter = FILTER_LINEAR;
						value.mipmaps = false;
					}
					this._prefilteredCubemaps = [];
					if (this._internalEnvAtlas) {
						this._internalEnvAtlas.destroy();
						this._internalEnvAtlas = null;
					}
					this._resetSky();
				}
			}
		}, {
			key: "fog",
			get: function get() {
				return this._fog;
			},
			set: function set(type) {
				if (type !== this._fog) {
					this._fog = type;
					this.updateShaders = true;
				}
			}
		}, {
			key: "gammaCorrection",
			get: function get() {
				return this._gammaCorrection;
			},
			set: function set(value) {
				if (value !== this._gammaCorrection) {
					this._gammaCorrection = value;
					this.updateShaders = true;
				}
			}
		}, {
			key: "layers",
			get: function get() {
				return this._layers;
			},
			set: function set(layers) {
				var prev = this._layers;
				this._layers = layers;
				this.fire('set:layers', prev, layers);
			}
		}, {
			key: "lighting",
			get: function get() {
				return this._lightingParams;
			}
		}, {
			key: "lightmapFilterRange",
			get: function get() {
				return this._lightmapFilterRange;
			},
			set: function set(value) {
				this._lightmapFilterRange = Math.max(value, 0.001);
			}
		}, {
			key: "lightmapFilterSmoothness",
			get: function get() {
				return this._lightmapFilterSmoothness;
			},
			set: function set(value) {
				this._lightmapFilterSmoothness = Math.max(value, 0.001);
			}
		}, {
			key: "prefilteredCubemaps",
			get: function get() {
				return this._prefilteredCubemaps;
			},
			set: function set(value) {
				value = value || [];
				var cubemaps = this._prefilteredCubemaps;
				var changed = cubemaps.length !== value.length || cubemaps.some(function (c, i) {
					return c !== value[i];
				});
				if (changed) {
					var complete = value.length === 6 && value.every(function (c) {
						return !!c;
					});
					if (complete) {
						this._internalEnvAtlas = EnvLighting.generatePrefilteredAtlas(value, {
							target: this._internalEnvAtlas
						});
						this._envAtlas = this._internalEnvAtlas;
					} else {
						if (this._internalEnvAtlas) {
							this._internalEnvAtlas.destroy();
							this._internalEnvAtlas = null;
						}
						this._envAtlas = null;
					}
					this._prefilteredCubemaps = value.slice();
					this._resetSky();
				}
			}
		}, {
			key: "skybox",
			get: function get() {
				return this._skyboxCubeMap;
			},
			set: function set(value) {
				if (value !== this._skyboxCubeMap) {
					this._skyboxCubeMap = value;
					this._resetSky();
				}
			}
		}, {
			key: "skyboxIntensity",
			get: function get() {
				return this._skyboxIntensity;
			},
			set: function set(value) {
				if (value !== this._skyboxIntensity) {
					this._skyboxIntensity = value;
					this._resetSky();
				}
			}
		}, {
			key: "skyboxLuminance",
			get: function get() {
				return this._skyboxLuminance;
			},
			set: function set(value) {
				if (value !== this._skyboxLuminance) {
					this._skyboxLuminance = value;
					this._resetSky();
				}
			}
		}, {
			key: "skyboxMip",
			get: function get() {
				return this._skyboxMip;
			},
			set: function set(value) {
				if (value !== this._skyboxMip) {
					this._skyboxMip = value;
					this._resetSky();
				}
			}
		}, {
			key: "skyboxRotation",
			get: function get() {
				return this._skyboxRotation;
			},
			set: function set(value) {
				if (!this._skyboxRotation.equals(value)) {
					var isIdentity = value.equals(Quat.IDENTITY);
					this._skyboxRotation.copy(value);
					if (isIdentity) {
						this._skyboxRotationMat3.setIdentity();
					} else {
						this._skyboxRotationMat4.setTRS(Vec3.ZERO, value, Vec3.ONE);
						this._skyboxRotationMat3.invertMat4(this._skyboxRotationMat4);
					}
					if (!this._skyboxRotationShaderInclude && !isIdentity) {
						this._skyboxRotationShaderInclude = true;
						this._resetSky();
					}
				}
			}
		}, {
			key: "toneMapping",
			get: function get() {
				return this._toneMapping;
			},
			set: function set(value) {
				if (value !== this._toneMapping) {
					this._toneMapping = value;
					this.updateShaders = true;
				}
			}
		}, {
			key: "lightmapPixelFormat",
			get: function get() {
				return this.lightmapHDR && this.device.getRenderableHdrFormat() || PIXELFORMAT_RGBA8;
			}
		}]);
		return Scene;
	}(EventHandler);

	var Skin = function Skin(graphicsDevice, ibp, boneNames) {
		this.device = graphicsDevice;
		this.inverseBindPose = ibp;
		this.boneNames = boneNames;
	};

	var spriteNormals = [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1];
	var spriteIndices = [0, 1, 3, 2, 3, 1];
	var Sprite = function (_EventHandler) {
		_inheritsLoose(Sprite, _EventHandler);
		function Sprite(device, options) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this._device = device;
			_this._pixelsPerUnit = options && options.pixelsPerUnit !== undefined ? options.pixelsPerUnit : 1;
			_this._renderMode = options && options.renderMode !== undefined ? options.renderMode : SPRITE_RENDERMODE_SIMPLE;
			_this._atlas = options && options.atlas !== undefined ? options.atlas : null;
			_this._frameKeys = options && options.frameKeys !== undefined ? options.frameKeys : null;
			_this._meshes = [];
			_this._updatingProperties = false;
			_this._meshesDirty = false;
			if (_this._atlas && _this._frameKeys) {
				_this._createMeshes();
			}
			return _this;
		}
		var _proto = Sprite.prototype;
		_proto._createMeshes = function _createMeshes() {
			var len = this._meshes.length;
			for (var i = 0; i < len; i++) {
				var mesh = this._meshes[i];
				if (mesh) {
					mesh.destroy();
				}
			}
			var count = this._frameKeys.length;
			this._meshes = new Array(count);
			var createMeshFunc = this.renderMode === SPRITE_RENDERMODE_SLICED || this._renderMode === SPRITE_RENDERMODE_TILED ? this._create9SliceMesh : this._createSimpleMesh;
			for (var _i = 0; _i < count; _i++) {
				var frame = this._atlas.frames[this._frameKeys[_i]];
				this._meshes[_i] = frame ? createMeshFunc.call(this, frame) : null;
			}
			this.fire('set:meshes');
		};
		_proto._createSimpleMesh = function _createSimpleMesh(frame) {
			var rect = frame.rect;
			var texWidth = this._atlas.texture.width;
			var texHeight = this._atlas.texture.height;
			var w = rect.z / this._pixelsPerUnit;
			var h = rect.w / this._pixelsPerUnit;
			var hp = frame.pivot.x;
			var vp = frame.pivot.y;
			var positions = [-hp * w, -vp * h, 0, (1 - hp) * w, -vp * h, 0, (1 - hp) * w, (1 - vp) * h, 0, -hp * w, (1 - vp) * h, 0];
			var lu = rect.x / texWidth;
			var bv = 1.0 - rect.y / texHeight;
			var ru = (rect.x + rect.z) / texWidth;
			var tv = 1.0 - (rect.y + rect.w) / texHeight;
			var uvs = [lu, bv, ru, bv, ru, tv, lu, tv];
			var mesh = createMesh$1(this._device, positions, {
				uvs: uvs,
				normals: spriteNormals,
				indices: spriteIndices
			});
			return mesh;
		};
		_proto._create9SliceMesh = function _create9SliceMesh() {
			var he = Vec2.ONE;
			var ws = 3;
			var ls = 3;
			var positions = [];
			var normals = [];
			var uvs = [];
			var indices = [];
			var vcounter = 0;
			for (var i = 0; i <= ws; i++) {
				var u = i === 0 || i === ws ? 0 : 1;
				for (var j = 0; j <= ls; j++) {
					var x = -he.x + 2.0 * he.x * (i <= 1 ? 0 : 3) / ws;
					var y = 0.0;
					var z = -(-he.y + 2.0 * he.y * (j <= 1 ? 0 : 3) / ls);
					var v = j === 0 || j === ls ? 0 : 1;
					positions.push(-x, y, z);
					normals.push(0.0, 1.0, 0.0);
					uvs.push(u, v);
					if (i < ws && j < ls) {
						indices.push(vcounter + ls + 1, vcounter + 1, vcounter);
						indices.push(vcounter + ls + 1, vcounter + ls + 2, vcounter + 1);
					}
					vcounter++;
				}
			}
			var options = {
				normals: normals,
				uvs: uvs,
				indices: indices
			};
			return createMesh$1(this._device, positions, options);
		};
		_proto._onSetFrames = function _onSetFrames(frames) {
			if (this._updatingProperties) {
				this._meshesDirty = true;
			} else {
				this._createMeshes();
			}
		};
		_proto._onFrameChanged = function _onFrameChanged(frameKey, frame) {
			var idx = this._frameKeys.indexOf(frameKey);
			if (idx < 0) return;
			if (frame) {
				if (this.renderMode === SPRITE_RENDERMODE_SIMPLE) {
					this._meshes[idx] = this._createSimpleMesh(frame);
				}
			} else {
				this._meshes[idx] = null;
			}
			this.fire('set:meshes');
		};
		_proto._onFrameRemoved = function _onFrameRemoved(frameKey) {
			var idx = this._frameKeys.indexOf(frameKey);
			if (idx < 0) return;
			this._meshes[idx] = null;
			this.fire('set:meshes');
		};
		_proto.startUpdate = function startUpdate() {
			this._updatingProperties = true;
			this._meshesDirty = false;
		};
		_proto.endUpdate = function endUpdate() {
			this._updatingProperties = false;
			if (this._meshesDirty && this._atlas && this._frameKeys) {
				this._createMeshes();
			}
			this._meshesDirty = false;
		};
		_proto.destroy = function destroy() {
			for (var _iterator = _createForOfIteratorHelperLoose(this._meshes), _step; !(_step = _iterator()).done;) {
				var mesh = _step.value;
				if (mesh) mesh.destroy();
			}
			this._meshes.length = 0;
		};
		_createClass(Sprite, [{
			key: "frameKeys",
			get: function get() {
				return this._frameKeys;
			},
			set: function set(value) {
				this._frameKeys = value;
				if (this._atlas && this._frameKeys) {
					if (this._updatingProperties) {
						this._meshesDirty = true;
					} else {
						this._createMeshes();
					}
				}
				this.fire('set:frameKeys', value);
			}
		}, {
			key: "atlas",
			get: function get() {
				return this._atlas;
			},
			set: function set(value) {
				if (value === this._atlas) return;
				if (this._atlas) {
					this._atlas.off('set:frames', this._onSetFrames, this);
					this._atlas.off('set:frame', this._onFrameChanged, this);
					this._atlas.off('remove:frame', this._onFrameRemoved, this);
				}
				this._atlas = value;
				if (this._atlas && this._frameKeys) {
					this._atlas.on('set:frames', this._onSetFrames, this);
					this._atlas.on('set:frame', this._onFrameChanged, this);
					this._atlas.on('remove:frame', this._onFrameRemoved, this);
					if (this._updatingProperties) {
						this._meshesDirty = true;
					} else {
						this._createMeshes();
					}
				}
				this.fire('set:atlas', value);
			}
		}, {
			key: "pixelsPerUnit",
			get: function get() {
				return this._pixelsPerUnit;
			},
			set: function set(value) {
				if (this._pixelsPerUnit === value) return;
				this._pixelsPerUnit = value;
				this.fire('set:pixelsPerUnit', value);
				if (this._atlas && this._frameKeys && this.renderMode === SPRITE_RENDERMODE_SIMPLE) {
					if (this._updatingProperties) {
						this._meshesDirty = true;
					} else {
						this._createMeshes();
					}
				}
			}
		}, {
			key: "renderMode",
			get: function get() {
				return this._renderMode;
			},
			set: function set(value) {
				if (this._renderMode === value) return;
				var prev = this._renderMode;
				this._renderMode = value;
				this.fire('set:renderMode', value);
				if (prev === SPRITE_RENDERMODE_SIMPLE || value === SPRITE_RENDERMODE_SIMPLE) {
					if (this._atlas && this._frameKeys) {
						if (this._updatingProperties) {
							this._meshesDirty = true;
						} else {
							this._createMeshes();
						}
					}
				}
			}
		}, {
			key: "meshes",
			get: function get() {
				return this._meshes;
			}
		}]);
		return Sprite;
	}(EventHandler);

	var TextureAtlas = function (_EventHandler) {
		_inheritsLoose(TextureAtlas, _EventHandler);
		function TextureAtlas() {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this._texture = null;
			_this._frames = null;
			return _this;
		}
		var _proto = TextureAtlas.prototype;
		_proto.setFrame = function setFrame(key, data) {
			var frame = this._frames[key];
			if (!frame) {
				frame = {
					rect: data.rect.clone(),
					pivot: data.pivot.clone(),
					border: data.border.clone()
				};
				this._frames[key] = frame;
			} else {
				frame.rect.copy(data.rect);
				frame.pivot.copy(data.pivot);
				frame.border.copy(data.border);
			}
			this.fire('set:frame', key.toString(), frame);
		};
		_proto.removeFrame = function removeFrame(key) {
			var frame = this._frames[key];
			if (frame) {
				delete this._frames[key];
				this.fire('remove:frame', key.toString(), frame);
			}
		};
		_proto.destroy = function destroy() {
			if (this._texture) {
				this._texture.destroy();
			}
		};
		_createClass(TextureAtlas, [{
			key: "texture",
			get: function get() {
				return this._texture;
			},
			set: function set(value) {
				this._texture = value;
				this.fire('set:texture', value);
			}
		}, {
			key: "frames",
			get: function get() {
				return this._frames;
			},
			set: function set(value) {
				this._frames = value;
				this.fire('set:frames', value);
			}
		}]);
		return TextureAtlas;
	}(EventHandler);

	var Key = function Key(time, position, rotation, scale) {
		this.time = time;
		this.position = position;
		this.rotation = rotation;
		this.scale = scale;
	};
	var Node = function Node() {
		this._name = '';
		this._keys = [];
	};
	var Animation = function () {
		function Animation() {
			this.name = '';
			this.duration = 0;
			this._nodes = [];
			this._nodeDict = {};
		}
		var _proto = Animation.prototype;
		_proto.getNode = function getNode(name) {
			return this._nodeDict[name];
		};
		_proto.addNode = function addNode(node) {
			this._nodes.push(node);
			this._nodeDict[node._name] = node;
		};
		_createClass(Animation, [{
			key: "nodes",
			get: function get() {
				return this._nodes;
			}
		}]);
		return Animation;
	}();

	var InterpolatedKey = function () {
		function InterpolatedKey() {
			this._written = false;
			this._name = '';
			this._keyFrames = [];
			this._quat = new Quat();
			this._pos = new Vec3();
			this._scale = new Vec3();
			this._targetNode = null;
		}
		var _proto = InterpolatedKey.prototype;
		_proto.getTarget = function getTarget() {
			return this._targetNode;
		};
		_proto.setTarget = function setTarget(node) {
			this._targetNode = node;
		};
		return InterpolatedKey;
	}();
	var Skeleton = function () {
		function Skeleton(graph) {
			var _this = this;
			this.looping = true;
			this._animation = null;
			this._time = 0;
			this._interpolatedKeys = [];
			this._interpolatedKeyDict = {};
			this._currKeyIndices = {};
			this.graph = null;
			var addInterpolatedKeys = function addInterpolatedKeys(node) {
				var interpKey = new InterpolatedKey();
				interpKey._name = node.name;
				_this._interpolatedKeys.push(interpKey);
				_this._interpolatedKeyDict[node.name] = interpKey;
				_this._currKeyIndices[node.name] = 0;
				for (var i = 0; i < node._children.length; i++) addInterpolatedKeys(node._children[i]);
			};
			addInterpolatedKeys(graph);
		}
		var _proto2 = Skeleton.prototype;
		_proto2.addTime = function addTime(delta) {
			if (this._animation !== null) {
				var nodes = this._animation._nodes;
				var duration = this._animation.duration;
				if (this._time === duration && !this.looping) {
					return;
				}
				this._time += delta;
				if (this._time > duration) {
					this._time = this.looping ? 0.0 : duration;
					for (var i = 0; i < nodes.length; i++) {
						var node = nodes[i];
						var nodeName = node._name;
						this._currKeyIndices[nodeName] = 0;
					}
				} else if (this._time < 0) {
					this._time = this.looping ? duration : 0.0;
					for (var _i = 0; _i < nodes.length; _i++) {
						var _node = nodes[_i];
						var _nodeName = _node._name;
						this._currKeyIndices[_nodeName] = _node._keys.length - 2;
					}
				}
				var offset = delta >= 0 ? 1 : -1;
				for (var _i2 = 0; _i2 < nodes.length; _i2++) {
					var _node2 = nodes[_i2];
					var _nodeName2 = _node2._name;
					var keys = _node2._keys;
					var interpKey = this._interpolatedKeyDict[_nodeName2];
					if (interpKey === undefined) {
						continue;
					}
					var foundKey = false;
					if (keys.length !== 1) {
						for (var currKeyIndex = this._currKeyIndices[_nodeName2]; currKeyIndex < keys.length - 1 && currKeyIndex >= 0; currKeyIndex += offset) {
							var k1 = keys[currKeyIndex];
							var k2 = keys[currKeyIndex + 1];
							if (k1.time <= this._time && k2.time >= this._time) {
								var alpha = (this._time - k1.time) / (k2.time - k1.time);
								interpKey._pos.lerp(k1.position, k2.position, alpha);
								interpKey._quat.slerp(k1.rotation, k2.rotation, alpha);
								interpKey._scale.lerp(k1.scale, k2.scale, alpha);
								interpKey._written = true;
								this._currKeyIndices[_nodeName2] = currKeyIndex;
								foundKey = true;
								break;
							}
						}
					}
					if (keys.length === 1 || !foundKey && this._time === 0.0 && this.looping) {
						interpKey._pos.copy(keys[0].position);
						interpKey._quat.copy(keys[0].rotation);
						interpKey._scale.copy(keys[0].scale);
						interpKey._written = true;
					}
				}
			}
		};
		_proto2.blend = function blend(skel1, skel2, alpha) {
			var numNodes = this._interpolatedKeys.length;
			for (var i = 0; i < numNodes; i++) {
				var key1 = skel1._interpolatedKeys[i];
				var key2 = skel2._interpolatedKeys[i];
				var dstKey = this._interpolatedKeys[i];
				if (key1._written && key2._written) {
					dstKey._quat.slerp(key1._quat, skel2._interpolatedKeys[i]._quat, alpha);
					dstKey._pos.lerp(key1._pos, skel2._interpolatedKeys[i]._pos, alpha);
					dstKey._scale.lerp(key1._scale, key2._scale, alpha);
					dstKey._written = true;
				} else if (key1._written) {
					dstKey._quat.copy(key1._quat);
					dstKey._pos.copy(key1._pos);
					dstKey._scale.copy(key1._scale);
					dstKey._written = true;
				} else if (key2._written) {
					dstKey._quat.copy(key2._quat);
					dstKey._pos.copy(key2._pos);
					dstKey._scale.copy(key2._scale);
					dstKey._written = true;
				}
			}
		};
		_proto2.setGraph = function setGraph(graph) {
			this.graph = graph;
			if (graph) {
				for (var i = 0; i < this._interpolatedKeys.length; i++) {
					var interpKey = this._interpolatedKeys[i];
					var graphNode = graph.findByName(interpKey._name);
					this._interpolatedKeys[i].setTarget(graphNode);
				}
			} else {
				for (var _i3 = 0; _i3 < this._interpolatedKeys.length; _i3++) {
					this._interpolatedKeys[_i3].setTarget(null);
				}
			}
		};
		_proto2.updateGraph = function updateGraph() {
			if (this.graph) {
				for (var i = 0; i < this._interpolatedKeys.length; i++) {
					var interpKey = this._interpolatedKeys[i];
					if (interpKey._written) {
						var transform = interpKey.getTarget();
						transform.localPosition.copy(interpKey._pos);
						transform.localRotation.copy(interpKey._quat);
						transform.localScale.copy(interpKey._scale);
						if (!transform._dirtyLocal) transform._dirtifyLocal();
						interpKey._written = false;
					}
				}
			}
		};
		_createClass(Skeleton, [{
			key: "animation",
			get: function get() {
				return this._animation;
			},
			set: function set(value) {
				this._animation = value;
				this.currentTime = 0;
			}
		}, {
			key: "currentTime",
			get: function get() {
				return this._time;
			},
			set: function set(value) {
				this._time = value;
				var numNodes = this._interpolatedKeys.length;
				for (var i = 0; i < numNodes; i++) {
					var node = this._interpolatedKeys[i];
					var nodeName = node._name;
					this._currKeyIndices[nodeName] = 0;
				}
				this.addTime(0);
				this.updateGraph();
			}
		}, {
			key: "numNodes",
			get: function get() {
				return this._interpolatedKeys.length;
			}
		}]);
		return Skeleton;
	}();

	var _viewport$1 = new Vec4();
	var PostEffect$1 = function () {
		function PostEffect(graphicsDevice) {
			this.device = graphicsDevice;
			this.needsDepthBuffer = false;
		}
		var _proto = PostEffect.prototype;
		_proto.render = function render(inputTarget, outputTarget, rect) {};
		_proto.drawQuad = function drawQuad(target, shader, rect) {
			var viewport;
			if (rect) {
				var w = target ? target.width : this.device.width;
				var h = target ? target.height : this.device.height;
				viewport = _viewport$1.set(rect.x * w, rect.y * h, rect.z * w, rect.w * h);
			}
			this.device.setBlendState(BlendState.NOBLEND);
			drawQuadWithShader(this.device, target, shader, viewport);
		};
		return PostEffect;
	}();
	PostEffect$1.quadVertexShader = "\n        attribute vec2 aPosition;\n        varying vec2 vUv0;\n        void main(void)\n        {\n            gl_Position = vec4(aPosition, 0.0, 1.0);\n            vUv0 = getImageEffectUV((aPosition.xy + 1.0) * 0.5);\n        }\n    ";

	var RenderPassShaderQuad = function (_RenderPass) {
		_inheritsLoose(RenderPassShaderQuad, _RenderPass);
		function RenderPassShaderQuad() {
			var _this;
			for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}
			_this = _RenderPass.call.apply(_RenderPass, [this].concat(args)) || this;
			_this._shader = null;
			_this.quadRender = null;
			_this.cullMode = CULLFACE_NONE;
			_this.blendState = BlendState.NOBLEND;
			_this.depthState = DepthState.NODEPTH;
			_this.stencilFront = null;
			_this.stencilBack = null;
			return _this;
		}
		var _proto = RenderPassShaderQuad.prototype;
		_proto.createQuadShader = function createQuadShader(name, fs) {
			return createShaderFromCode(this.device, RenderPassShaderQuad.quadVertexShader, fs, name, {
				aPosition: SEMANTIC_POSITION
			});
		};
		_proto.destroy = function destroy() {
			var _this$shader;
			(_this$shader = this.shader) == null || _this$shader.destroy();
			this.shader = null;
		};
		_proto.execute = function execute() {
			var device = this.device;
			device.setBlendState(this.blendState);
			device.setCullMode(this.cullMode);
			device.setDepthState(this.depthState);
			device.setStencilState(this.stencilFront, this.stencilBack);
			this.quadRender.render();
		};
		_createClass(RenderPassShaderQuad, [{
			key: "shader",
			get: function get() {
				return this._shader;
			},
			set: function set(shader) {
				var _this$quadRender, _this$_shader;
				(_this$quadRender = this.quadRender) == null || _this$quadRender.destroy();
				this.quadRender = null;
				(_this$_shader = this._shader) == null || _this$_shader.destroy();
				this._shader = shader;
				if (shader) this.quadRender = new QuadRender(shader);
			}
		}]);
		return RenderPassShaderQuad;
	}(RenderPass);
	RenderPassShaderQuad.quadVertexShader = "\n        attribute vec2 aPosition;\n        varying vec2 uv0;\n        void main(void)\n        {\n            gl_Position = vec4(aPosition, 0.0, 1.0);\n            uv0 = getImageEffectUV((aPosition.xy + 1.0) * 0.5);\n        }\n    ";

	function areaElement(x, y) {
		return Math.atan2(x * y, Math.sqrt(x * x + y * y + 1));
	}
	function texelCoordSolidAngle(u, v, size) {
		var _u = 2.0 * (u + 0.5) / size - 1.0;
		var _v = 2.0 * (v + 0.5) / size - 1.0;
		_u *= 1.0 - 1.0 / size;
		_v *= 1.0 - 1.0 / size;
		var invResolution = 1.0 / size;
		var x0 = _u - invResolution;
		var y0 = _v - invResolution;
		var x1 = _u + invResolution;
		var y1 = _v + invResolution;
		var solidAngle = areaElement(x0, y0) - areaElement(x0, y1) - areaElement(x1, y0) + areaElement(x1, y1);
		if (u === 0 && v === 0 || u === size - 1 && v === 0 || u === 0 && v === size - 1 || u === size - 1 && v === size - 1) {
			solidAngle /= 3;
		} else if (u === 0 || v === 0 || u === size - 1 || v === size - 1) {
			solidAngle *= 0.5;
		}
		return solidAngle;
	}
	function shFromCubemap(device, source, dontFlipX) {
		if (source.format !== PIXELFORMAT_RGBA8) {
			return null;
		}
		if (!source._levels[0] || !source._levels[0][0]) {
			return null;
		}
		var cubeSize = source.width;
		if (!source._levels[0][0].length) {
			if (source._levels[0][0] instanceof HTMLImageElement) {
				var shader = createShaderFromCode(device, shaderChunks.fullscreenQuadVS, shaderChunks.fullscreenQuadPS, "fsQuadSimple");
				var constantTexSource = device.scope.resolve("source");
				for (var face = 0; face < 6; face++) {
					var img = source._levels[0][face];
					var tex = new Texture(device, {
						name: 'prefiltered-cube',
						cubemap: false,
						type: TEXTURETYPE_DEFAULT,
						format: source.format,
						width: cubeSize,
						height: cubeSize,
						mipmaps: false
					});
					tex._levels[0] = img;
					tex.upload();
					var tex2 = new Texture(device, {
						name: 'prefiltered-cube',
						cubemap: false,
						type: TEXTURETYPE_DEFAULT,
						format: source.format,
						width: cubeSize,
						height: cubeSize,
						mipmaps: false
					});
					var targ = new RenderTarget({
						colorBuffer: tex2,
						depth: false
					});
					constantTexSource.setValue(tex);
					device.setBlendState(BlendState.NOBLEND);
					drawQuadWithShader(device, targ, shader);
					var gl = device.gl;
					gl.bindFramebuffer(gl.FRAMEBUFFER, targ.impl._glFrameBuffer);
					var pixels = new Uint8Array(cubeSize * cubeSize * 4);
					gl.readPixels(0, 0, tex.width, tex.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
					source._levels[0][face] = pixels;
				}
			} else {
				return null;
			}
		}
		var dirs = [];
		for (var y = 0; y < cubeSize; y++) {
			for (var x = 0; x < cubeSize; x++) {
				var u = x / (cubeSize - 1) * 2 - 1;
				var v = y / (cubeSize - 1) * 2 - 1;
				dirs[y * cubeSize + x] = new Vec3(u, v, 1.0).normalize();
			}
		}
		var sh = new Float32Array(9 * 3);
		var coef1 = 0;
		var coef2 = 1 * 3;
		var coef3 = 2 * 3;
		var coef4 = 3 * 3;
		var coef5 = 4 * 3;
		var coef6 = 5 * 3;
		var coef7 = 6 * 3;
		var coef8 = 7 * 3;
		var coef9 = 8 * 3;
		var nx = 0;
		var px = 1;
		var ny = 2;
		var py = 3;
		var nz = 4;
		var pz = 5;
		var accum = 0;
		for (var _face = 0; _face < 6; _face++) {
			for (var _y = 0; _y < cubeSize; _y++) {
				for (var _x = 0; _x < cubeSize; _x++) {
					var addr = _y * cubeSize + _x;
					var weight = texelCoordSolidAngle(_x, _y, cubeSize);
					var weight1 = weight * 4 / 17;
					var weight2 = weight * 8 / 17;
					var weight3 = weight * 15 / 17;
					var weight4 = weight * 5 / 68;
					var weight5 = weight * 15 / 68;
					var dir = dirs[addr];
					var dx = void 0,
						dy = void 0,
						dz = void 0;
					if (_face === nx) {
						dx = dir.z;
						dy = -dir.y;
						dz = -dir.x;
					} else if (_face === px) {
						dx = -dir.z;
						dy = -dir.y;
						dz = dir.x;
					} else if (_face === ny) {
						dx = dir.x;
						dy = dir.z;
						dz = dir.y;
					} else if (_face === py) {
						dx = dir.x;
						dy = -dir.z;
						dz = -dir.y;
					} else if (_face === nz) {
						dx = dir.x;
						dy = -dir.y;
						dz = dir.z;
					} else if (_face === pz) {
						dx = -dir.x;
						dy = -dir.y;
						dz = -dir.z;
					}
					if (!dontFlipX) dx = -dx;
					var a = source._levels[0][_face][addr * 4 + 3] / 255.0;
					for (var c = 0; c < 3; c++) {
						var value = source._levels[0][_face][addr * 4 + c] / 255.0;
						if (source.type === TEXTURETYPE_RGBM) {
							value *= a * 8.0;
							value *= value;
						} else {
							value = Math.pow(value, 2.2);
						}
						sh[coef1 + c] += value * weight1;
						sh[coef2 + c] += value * weight2 * dx;
						sh[coef3 + c] += value * weight2 * dy;
						sh[coef4 + c] += value * weight2 * dz;
						sh[coef5 + c] += value * weight3 * dx * dz;
						sh[coef6 + c] += value * weight3 * dz * dy;
						sh[coef7 + c] += value * weight3 * dy * dx;
						sh[coef8 + c] += value * weight4 * (3.0 * dz * dz - 1.0);
						sh[coef9 + c] += value * weight5 * (dx * dx - dy * dy);
						accum += weight;
					}
				}
			}
		}
		for (var _c = 0; _c < sh.length; _c++) {
			sh[_c] *= 4 * Math.PI / accum;
		}
		return sh;
	}

	var ProgramLibrary = function () {
		function ProgramLibrary(device, standardMaterial) {
			var _this = this;
			this.processedCache = new Map();
			this.definitionsCache = new Map();
			this._generators = new Map();
			this._device = device;
			this._isClearingCache = false;
			this._precached = false;
			this._programsCollection = [];
			this._defaultStdMatOption = new StandardMaterialOptions();
			this._defaultStdMatOptionMin = new StandardMaterialOptions();
			standardMaterial.shaderOptBuilder.updateRef(this._defaultStdMatOption, {}, standardMaterial, null, [], SHADER_FORWARD, null);
			standardMaterial.shaderOptBuilder.updateMinRef(this._defaultStdMatOptionMin, {}, standardMaterial, null, SHADER_SHADOW, null);
			device.on('destroy:shader', function (shader) {
				_this.removeFromCache(shader);
			});
		}
		var _proto = ProgramLibrary.prototype;
		_proto.destroy = function destroy() {
			this.clearCache();
		};
		_proto.register = function register(name, generator) {
			if (!this._generators.has(name)) {
				this._generators.set(name, generator);
			}
		};
		_proto.unregister = function unregister(name) {
			if (this._generators.has(name)) {
				this._generators.delete(name);
			}
		};
		_proto.isRegistered = function isRegistered(name) {
			return this._generators.has(name);
		};
		_proto.generateShaderDefinition = function generateShaderDefinition(generator, name, key, options) {
			var def = this.definitionsCache.get(key);
			if (!def) {
				var _options$litOptions, _options$litOptions2, _def$name;
				var lights;
				if ((_options$litOptions = options.litOptions) != null && _options$litOptions.lights) {
					lights = options.litOptions.lights;
					options.litOptions.lights = lights.map(function (l) {
						var lcopy = l.clone ? l.clone() : l;
						lcopy.key = l.key;
						return lcopy;
					});
				}
				this.storeNewProgram(name, options);
				if ((_options$litOptions2 = options.litOptions) != null && _options$litOptions2.lights) options.litOptions.lights = lights;
				if (this._precached) ;
				var device = this._device;
				def = generator.createShaderDefinition(device, options);
				def.name = (_def$name = def.name) != null ? _def$name : options.pass ? name + "-pass:" + options.pass : name;
				this.definitionsCache.set(key, def);
			}
			return def;
		};
		_proto.getCachedShader = function getCachedShader(key) {
			return this.processedCache.get(key);
		};
		_proto.setCachedShader = function setCachedShader(key, shader) {
			this.processedCache.set(key, shader);
		};
		_proto.getProgram = function getProgram(name, options, processingOptions, userMaterialId) {
			var generator = this._generators.get(name);
			if (!generator) {
				return null;
			}
			var generationKeyString = generator.generateKey(options);
			var generationKey = hashCode(generationKeyString);
			var processingKeyString = processingOptions.generateKey(this._device);
			var processingKey = hashCode(processingKeyString);
			var totalKey = generationKey + "#" + processingKey;
			var processedShader = this.getCachedShader(totalKey);
			if (!processedShader) {
				var generatedShaderDef = this.generateShaderDefinition(generator, name, generationKey, options);
				var passName = '';
				var shaderPassInfo;
				if (options.pass !== undefined) {
					shaderPassInfo = ShaderPass.get(this._device).getByIndex(options.pass);
					passName = "-" + shaderPassInfo.name;
				}
				this._device.fire('shader:generate', {
					userMaterialId: userMaterialId,
					shaderPassInfo: shaderPassInfo,
					definition: generatedShaderDef
				});
				var shaderDefinition = {
					name: "" + generatedShaderDef.name + passName + "-proc",
					attributes: generatedShaderDef.attributes,
					vshader: generatedShaderDef.vshader,
					fshader: generatedShaderDef.fshader,
					processingOptions: processingOptions
				};
				processedShader = new Shader(this._device, shaderDefinition);
				this.setCachedShader(totalKey, processedShader);
			}
			return processedShader;
		};
		_proto.storeNewProgram = function storeNewProgram(name, options) {
			var opt = {};
			if (name === "standard") {
				var defaultMat = this._getDefaultStdMatOptions(options.pass);
				for (var p in options) {
					if (options.hasOwnProperty(p) && defaultMat[p] !== options[p] || p === "pass") opt[p] = options[p];
				}
				for (var _p in options.litOptions) {
					opt[_p] = options.litOptions[_p];
				}
			} else {
				opt = options;
			}
			this._programsCollection.push(JSON.stringify({
				name: name,
				options: opt
			}));
		};
		_proto.dumpPrograms = function dumpPrograms() {
			var text = 'let device = pc.app ? pc.app.graphicsDevice : pc.Application.getApplication().graphicsDevice;\n';
			text += 'let shaders = [';
			if (this._programsCollection[0]) text += '\n\t' + this._programsCollection[0];
			for (var i = 1; i < this._programsCollection.length; ++i) {
				text += ',\n\t' + this._programsCollection[i];
			}
			text += '\n];\n';
			text += 'device.getProgramLibrary().precompile(shaders);\n';
			text += 'if (pc.version != \"' + version + '\" || pc.revision != \"' + revision + '\")\n';
			text += '\tconsole.warn(\"precompile-shaders.js: engine version mismatch, rebuild shaders lib with current engine\");';
			var element = document.createElement('a');
			element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
			element.setAttribute('download', 'precompile-shaders.js');
			element.style.display = 'none';
			document.body.appendChild(element);
			element.click();
			document.body.removeChild(element);
		};
		_proto.clearCache = function clearCache() {
			this._isClearingCache = true;
			this.processedCache.forEach(function (shader) {
				shader.destroy();
			});
			this.processedCache.clear();
			this._isClearingCache = false;
		};
		_proto.removeFromCache = function removeFromCache(shader) {
			var _this2 = this;
			if (this._isClearingCache) return;
			this.processedCache.forEach(function (cachedShader, key) {
				if (shader === cachedShader) {
					_this2.processedCache.delete(key);
				}
			});
		};
		_proto._getDefaultStdMatOptions = function _getDefaultStdMatOptions(pass) {
			var shaderPassInfo = ShaderPass.get(this._device).getByIndex(pass);
			return pass === SHADER_DEPTH || pass === SHADER_PICK || shaderPassInfo.isShadow ? this._defaultStdMatOptionMin : this._defaultStdMatOption;
		};
		_proto.precompile = function precompile(cache) {
			if (cache) {
				var shaders = new Array(cache.length);
				for (var i = 0; i < cache.length; i++) {
					if (cache[i].name === "standard") {
						var opt = cache[i].options;
						var defaultMat = this._getDefaultStdMatOptions(opt.pass);
						for (var p in defaultMat) {
							if (defaultMat.hasOwnProperty(p) && opt[p] === undefined) opt[p] = defaultMat[p];
						}
					}
					shaders[i] = this.getProgram(cache[i].name, cache[i].options);
				}
			}
			this._precached = true;
		};
		return ProgramLibrary;
	}();

	var bakeDirLmEndPS = "\n\tvec4 dirLm = texture2D(texture_dirLightMap, vUv1);\n\tif (bakeDir > 0.5) {\n\t\tif (dAtten > 0.00001) {\n\t\t\tdirLm.xyz = dirLm.xyz * 2.0 - vec3(1.0);\n\t\t\tdAtten = saturate(dAtten);\n\t\t\tgl_FragColor.rgb = normalize(dLightDirNormW.xyz*dAtten + dirLm.xyz*dirLm.w) * 0.5 + vec3(0.5);\n\t\t\tgl_FragColor.a = dirLm.w + dAtten;\n\t\t\tgl_FragColor.a = max(gl_FragColor.a, 1.0 / 255.0);\n\t\t} else {\n\t\t\tgl_FragColor = dirLm;\n\t\t}\n\t} else {\n\t\tgl_FragColor.rgb = dirLm.xyz;\n\t\tgl_FragColor.a = max(dirLm.w, dAtten > 0.00001? (1.0/255.0) : 0.0);\n\t}\n";

	var bakeLmEndPS = "\n#ifdef LIGHTMAP_RGBM\n\tgl_FragColor.rgb = dDiffuseLight;\n\tgl_FragColor.rgb = pow(gl_FragColor.rgb, vec3(0.5));\n\tgl_FragColor.rgb /= 8.0;\n\tgl_FragColor.a = clamp( max( max( gl_FragColor.r, gl_FragColor.g ), max( gl_FragColor.b, 1.0 / 255.0 ) ), 0.0,1.0 );\n\tgl_FragColor.a = ceil(gl_FragColor.a * 255.0) / 255.0;\n\tgl_FragColor.rgb /= gl_FragColor.a;\n#else\n\tgl_FragColor = vec4(dDiffuseLight, 1.0);\n#endif\n";

	var dilatePS = "\nvarying vec2 vUv0;\nuniform sampler2D source;\nuniform vec2 pixelOffset;\nvoid main(void) {\n\tvec4 c = texture2D(source, vUv0);\n\tc = c.a>0.0? c : texture2D(source, vUv0 - pixelOffset);\n\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(0, -pixelOffset.y));\n\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(pixelOffset.x, -pixelOffset.y));\n\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(-pixelOffset.x, 0));\n\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(pixelOffset.x, 0));\n\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(-pixelOffset.x, pixelOffset.y));\n\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(0, pixelOffset.y));\n\tc = c.a>0.0? c : texture2D(source, vUv0 + pixelOffset);\n\tgl_FragColor = c;\n}\n";

	var bilateralDeNoisePS = "\nfloat normpdf3(in vec3 v, in float sigma) {\n\treturn 0.39894 * exp(-0.5 * dot(v, v) / (sigma * sigma)) / sigma;\n}\nvec3 decodeRGBM(vec4 rgbm) {\n\tvec3 color = (8.0 * rgbm.a) * rgbm.rgb;\n\treturn color * color;\n}\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\nvec4 encodeRGBM(vec3 color) {\n\tvec4 encoded;\n\tencoded.rgb = pow(color.rgb, vec3(0.5));\n\tencoded.rgb *= 1.0 / 8.0;\n\tencoded.a = saturate( max( max( encoded.r, encoded.g ), max( encoded.b, 1.0 / 255.0 ) ) );\n\tencoded.a = ceil(encoded.a * 255.0) / 255.0;\n\tencoded.rgb /= encoded.a;\n\treturn encoded;\n}\n#define MSIZE 15\nvarying vec2 vUv0;\nuniform sampler2D source;\nuniform vec2 pixelOffset;\nuniform vec2 sigmas;\nuniform float bZnorm;\nuniform float kernel[MSIZE];\nvoid main(void) {\n\t\n\tvec4 pixelRgbm = texture2D(source, vUv0);\n\tif (pixelRgbm.a <= 0.0) {\n\t\tgl_FragColor = pixelRgbm;\n\t\treturn ;\n\t}\n\tfloat sigma = sigmas.x;\n\tfloat bSigma = sigmas.y;\n\tvec3 pixelHdr = decodeRGBM(pixelRgbm);\n\tvec3 accumulatedHdr = vec3(0.0);\n\tfloat accumulatedFactor = 0.0;\n\tconst int kSize = (MSIZE-1)/2;\n\tfor (int i = -kSize; i <= kSize; ++i) {\n\t\tfor (int j = -kSize; j <= kSize; ++j) {\n\t\t\t\n\t\t\tvec2 coord = vUv0 + vec2(float(i), float(j)) * pixelOffset;\n\t\t\tvec4 rgbm = texture2D(source, coord);\n\t\t\tif (rgbm.a > 0.0) {\n\t\t\t\tvec3 hdr = decodeRGBM(rgbm);\n\t\t\t\tfloat factor = kernel[kSize + j] * kernel[kSize + i];\n\t\t\t\tfactor *= normpdf3(hdr - pixelHdr, bSigma) * bZnorm;\n\t\t\t\taccumulatedHdr += factor * hdr;\n\t\t\t\taccumulatedFactor += factor;\n\t\t\t}\n\t\t}\n\t}\n\tgl_FragColor = encodeRGBM(accumulatedHdr / accumulatedFactor);\n}\n";

	var shaderChunksLightmapper = {
		bakeDirLmEndPS: bakeDirLmEndPS,
		bakeLmEndPS: bakeLmEndPS,
		dilatePS: dilatePS,
		bilateralDeNoisePS: bilateralDeNoisePS
	};

	var FILLMODE_NONE = 'NONE';
	var FILLMODE_FILL_WINDOW = 'FILL_WINDOW';
	var FILLMODE_KEEP_ASPECT = 'KEEP_ASPECT';
	var RESOLUTION_AUTO = 'AUTO';
	var RESOLUTION_FIXED = 'FIXED';

	var currentApplication;
	function getApplication() {
		return currentApplication;
	}
	function setApplication(app) {
		currentApplication = app;
		GraphicsDeviceAccess.set(app == null ? void 0 : app.graphicsDevice);
	}

	var ScriptTypes = function () {
		function ScriptTypes() {}
		ScriptTypes.push = function push(Type, isLegacy) {
			if (isLegacy && ScriptTypes._types.length > 0) {
				console.assert('Script Ordering Error. Contact support@playcanvas.com');
			} else {
				ScriptTypes._types.push(Type);
			}
		};
		return ScriptTypes;
	}();
	ScriptTypes._types = [];

	var _legacy = false;
	var _createdLoadingScreen = false;
	var script = {
		app: null,
		create: function create(name, callback) {
			if (!_legacy) return;
			var ScriptType = callback(script.app);
			ScriptType._pcScriptName = name;
			ScriptTypes.push(ScriptType, _legacy);
			this.fire("created", name, callback);
		},
		attribute: function attribute(name, type, defaultValue, options) {},
		createLoadingScreen: function createLoadingScreen(callback) {
			if (_createdLoadingScreen) return;
			_createdLoadingScreen = true;
			var app = getApplication();
			callback(app);
		}
	};
	Object.defineProperty(script, 'legacy', {
		get: function get() {
			return _legacy;
		},
		set: function set(value) {
			_legacy = value;
		}
	});
	events.attach(script);

	var FrameGraph = function () {
		function FrameGraph() {
			this.renderPasses = [];
			this.renderTargetMap = new Map();
		}
		var _proto = FrameGraph.prototype;
		_proto.addRenderPass = function addRenderPass(renderPass) {
			renderPass.frameUpdate();
			var passes = this.renderPasses;
			var beforePasses = renderPass.beforePasses;
			for (var i = 0; i < beforePasses.length; i++) {
				var pass = beforePasses[i];
				if (pass.enabled) {
					pass.frameUpdate();
					passes.push(pass);
				}
			}
			if (renderPass.enabled) {
				renderPass.frameUpdate();
				passes.push(renderPass);
			}
			var afterPasses = renderPass.afterPasses;
			for (var _i = 0; _i < afterPasses.length; _i++) {
				var _pass = afterPasses[_i];
				if (_pass.enabled) {
					_pass.frameUpdate();
					passes.push(_pass);
				}
			}
		};
		_proto.reset = function reset() {
			this.renderPasses.length = 0;
		};
		_proto.compile = function compile() {
			var renderTargetMap = this.renderTargetMap;
			var renderPasses = this.renderPasses;
			for (var i = 0; i < renderPasses.length; i++) {
				var renderPass = renderPasses[i];
				var renderTarget = renderPass.renderTarget;
				if (renderTarget !== undefined) {
					var prevPass = renderTargetMap.get(renderTarget);
					if (prevPass) {
						var count = renderPass.colorArrayOps.length;
						for (var j = 0; j < count; j++) {
							var colorOps = renderPass.colorArrayOps[j];
							if (!colorOps.clear) {
								prevPass.colorArrayOps[j].store = true;
							}
						}
						if (!renderPass.depthStencilOps.clearDepth) {
							prevPass.depthStencilOps.storeDepth = true;
						}
						if (!renderPass.depthStencilOps.clearStencil) {
							prevPass.depthStencilOps.storeStencil = true;
						}
					}
					renderTargetMap.set(renderTarget, renderPass);
				}
			}
			var lastCubeTexture = null;
			var lastCubeRenderPass = null;
			for (var _i2 = 0; _i2 < renderPasses.length; _i2++) {
				var _renderPass = renderPasses[_i2];
				var _renderTarget = _renderPass.renderTarget;
				var thisTexture = _renderTarget == null ? void 0 : _renderTarget.colorBuffer;
				if (thisTexture != null && thisTexture.cubemap) {
					if (lastCubeTexture === thisTexture) {
						var _count = lastCubeRenderPass.colorArrayOps.length;
						for (var _j = 0; _j < _count; _j++) {
							lastCubeRenderPass.colorArrayOps[_j].mipmaps = false;
						}
					}
					lastCubeTexture = _renderTarget.colorBuffer;
					lastCubeRenderPass = _renderPass;
				} else if (_renderPass.requiresCubemaps) {
					lastCubeTexture = null;
					lastCubeRenderPass = null;
				}
			}
			renderTargetMap.clear();
		};
		_proto.render = function render(device) {
			this.compile();
			var renderPasses = this.renderPasses;
			for (var i = 0; i < renderPasses.length; i++) {
				renderPasses[i].render();
			}
		};
		return FrameGraph;
	}();

	var AreaLightCacheEntry = function () {
		function AreaLightCacheEntry(texture0, texture1) {
			this.texture0 = texture0;
			this.texture1 = texture1;
		}
		var _proto = AreaLightCacheEntry.prototype;
		_proto.destroy = function destroy() {
			var _this$texture, _this$texture2;
			(_this$texture = this.texture0) == null || _this$texture.destroy();
			(_this$texture2 = this.texture1) == null || _this$texture2.destroy();
		};
		return AreaLightCacheEntry;
	}();
	var deviceCache = new DeviceCache();
	var AreaLightLuts = function () {
		function AreaLightLuts() {}
		AreaLightLuts.createTexture = function createTexture(device, format, size, postfix) {
			if (postfix === void 0) {
				postfix = '';
			}
			var tex = new Texture(device, {
				name: "AreaLightLUT" + postfix,
				width: size,
				height: size,
				format: format,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE,
				type: TEXTURETYPE_DEFAULT,
				magFilter: FILTER_LINEAR,
				minFilter: FILTER_NEAREST,
				anisotropy: 1,
				mipmaps: false
			});
			return tex;
		};
		AreaLightLuts.applyTextures = function applyTextures(device, texture1, texture2) {
			deviceCache.remove(device);
			deviceCache.get(device, function () {
				return new AreaLightCacheEntry(texture1, texture1 === texture2 ? null : texture2);
			});
			device.scope.resolve('areaLightsLutTex1').setValue(texture1);
			device.scope.resolve('areaLightsLutTex2').setValue(texture2);
		};
		AreaLightLuts.createPlaceholder = function createPlaceholder(device) {
			var texture = AreaLightLuts.createTexture(device, device.areaLightLutFormat, 2, 'placeholder');
			var pixels = texture.lock();
			pixels.fill(0);
			texture.unlock();
			AreaLightLuts.applyTextures(device, texture, texture);
		};
		AreaLightLuts.set = function set(device, ltcMat1, ltcMat2) {
			function buildTexture(device, data, format) {
				var texture = AreaLightLuts.createTexture(device, format, 64);
				texture.lock().set(data);
				texture.unlock();
				return texture;
			}
			function offsetScale(data, offset, scale) {
				var count = data.length;
				var ret = new Float32Array(count);
				for (var i = 0; i < count; i++) {
					var n = i % 4;
					ret[i] = (data[i] + offset[n]) * scale[n];
				}
				return ret;
			}
			function convertToHalfFloat(data) {
				var count = data.length;
				var ret = new Uint16Array(count);
				var float2Half = FloatPacking.float2Half;
				for (var i = 0; i < count; i++) {
					ret[i] = float2Half(data[i]);
				}
				return ret;
			}
			function convertToUint(data) {
				var count = data.length;
				var ret = new Uint8ClampedArray(count);
				for (var i = 0; i < count; i++) {
					ret[i] = data[i] * 255;
				}
				return ret;
			}
			var srcData1 = ltcMat1;
			var srcData2 = ltcMat2;
			var data1, data2;
			var format = device.areaLightLutFormat;
			if (format === PIXELFORMAT_RGBA32F) {
				data1 = srcData1;
				data2 = srcData2;
			} else if (format === PIXELFORMAT_RGBA16F) {
				data1 = convertToHalfFloat(srcData1);
				data2 = convertToHalfFloat(srcData2);
			} else {
				var o1 = [0.0, 0.2976, 0.01381, 0.0];
				var s1 = [0.999, 3.08737, 1.6546, 0.603249];
				var o2 = [-0.306897, 0.0, 0.0, 0.0];
				var s2 = [1.442787, 1.0, 1.0, 1.0];
				data1 = convertToUint(offsetScale(srcData1, o1, s1));
				data2 = convertToUint(offsetScale(srcData2, o2, s2));
			}
			var tex1 = buildTexture(device, data1, format);
			var tex2 = buildTexture(device, data2, format);
			AreaLightLuts.applyTextures(device, tex1, tex2);
		};
		return AreaLightLuts;
	}();

	var DEFAULT_LOCALE = 'en-US';
	var DEFAULT_LOCALE_FALLBACKS = {
		'en': 'en-US',
		'es': 'en-ES',
		'zh': 'zh-CN',
		'zh-HK': 'zh-TW',
		'zh-TW': 'zh-HK',
		'zh-MO': 'zh-HK',
		'fr': 'fr-FR',
		'de': 'de-DE',
		'it': 'it-IT',
		'ru': 'ru-RU',
		'ja': 'ja-JP'
	};

	var PLURALS = {};
	function definePluralFn(locales, fn) {
		for (var i = 0, len = locales.length; i < len; i++) {
			PLURALS[locales[i]] = fn;
		}
	}
	function getLang(locale) {
		var idx = locale.indexOf('-');
		if (idx !== -1) {
			return locale.substring(0, idx);
		}
		return locale;
	}
	function replaceLang(locale, desiredLang) {
		var idx = locale.indexOf('-');
		if (idx !== -1) {
			return desiredLang + locale.substring(idx);
		}
		return desiredLang;
	}
	function findAvailableLocale(desiredLocale, availableLocales) {
		if (availableLocales[desiredLocale]) {
			return desiredLocale;
		}
		var fallback = DEFAULT_LOCALE_FALLBACKS[desiredLocale];
		if (fallback && availableLocales[fallback]) {
			return fallback;
		}
		var lang = getLang(desiredLocale);
		fallback = DEFAULT_LOCALE_FALLBACKS[lang];
		if (availableLocales[fallback]) {
			return fallback;
		}
		if (availableLocales[lang]) {
			return lang;
		}
		return DEFAULT_LOCALE;
	}
	definePluralFn(['ja', 'ko', 'th', 'vi', 'zh', 'id'], function (n) {
		return 0;
	});
	definePluralFn(['fa', 'hi'], function (n) {
		if (n >= 0 && n <= 1) {
			return 0;
		}
		return 1;
	});
	definePluralFn(['fr', 'pt'], function (n) {
		if (n >= 0 && n < 2) {
			return 0;
		}
		return 1;
	});
	definePluralFn(['da'], function (n) {
		if (n === 1 || !Number.isInteger(n) && n >= 0 && n <= 1) {
			return 0;
		}
		return 1;
	});
	definePluralFn(['de', 'en', 'it', 'el', 'es', 'tr', 'fi', 'sv', 'nb', 'no', 'ur'], function (n) {
		if (n === 1) {
			return 0;
		}
		return 1;
	});
	definePluralFn(['ru', 'uk'], function (n) {
		if (Number.isInteger(n)) {
			var mod10 = n % 10;
			var mod100 = n % 100;
			if (mod10 === 1 && mod100 !== 11) {
				return 0;
			} else if (mod10 >= 2 && mod10 <= 4 && (mod100 < 12 || mod100 > 14)) {
				return 1;
			} else if (mod10 === 0 || mod10 >= 5 && mod10 <= 9 || mod100 >= 11 && mod100 <= 14) {
				return 2;
			}
		}
		return 3;
	});
	definePluralFn(['pl'], function (n) {
		if (Number.isInteger(n)) {
			if (n === 1) {
				return 0;
			}
			var mod10 = n % 10;
			var mod100 = n % 100;
			if (mod10 >= 2 && mod10 <= 4 && (mod100 < 12 || mod100 > 14)) {
				return 1;
			} else if (mod10 >= 0 && mod10 <= 1 || mod10 >= 5 && mod10 <= 9 || mod100 >= 12 && mod100 <= 14) {
				return 2;
			}
		}
		return 3;
	});
	definePluralFn(['ar'], function (n) {
		if (n === 0) {
			return 0;
		} else if (n === 1) {
			return 1;
		} else if (n === 2) {
			return 2;
		}
		if (Number.isInteger(n)) {
			var mod100 = n % 100;
			if (mod100 >= 3 && mod100 <= 10) {
				return 3;
			} else if (mod100 >= 11 && mod100 <= 99) {
				return 4;
			}
		}
		return 5;
	});
	var DEFAULT_PLURAL_FN = PLURALS[getLang(DEFAULT_LOCALE)];
	function getPluralFn(lang) {
		return PLURALS[lang] || DEFAULT_PLURAL_FN;
	}

	var ABSOLUTE_URL = new RegExp('^' + '\\s*' + '(?:' + '(?:' + '[a-z]+[a-z0-9\\-\\+\\.]*' + ':' + ')?' + '//' + '|' + 'data:' + '|blob:' + ')', 'i');
	var ASSET_ANIMATION = 'animation';
	var ASSET_AUDIO = 'audio';
	var ASSET_IMAGE = 'image';
	var ASSET_JSON = 'json';
	var ASSET_MODEL = 'model';
	var ASSET_MATERIAL = 'material';
	var ASSET_TEXT = 'text';
	var ASSET_TEXTURE = 'texture';
	var ASSET_TEXTUREATLAS = 'textureatlas';
	var ASSET_CUBEMAP = 'cubemap';
	var ASSET_SHADER = 'shader';
	var ASSET_CSS = 'css';
	var ASSET_HTML = 'html';
	var ASSET_SCRIPT = 'script';
	var ASSET_CONTAINER = 'container';

	var AssetFile = function () {
		function AssetFile(url, filename, hash, size, opt, contents) {
			if (url === void 0) {
				url = '';
			}
			if (filename === void 0) {
				filename = '';
			}
			if (hash === void 0) {
				hash = null;
			}
			if (size === void 0) {
				size = null;
			}
			if (opt === void 0) {
				opt = null;
			}
			if (contents === void 0) {
				contents = null;
			}
			this.url = url;
			this.filename = filename;
			this.hash = hash;
			this.size = size;
			this.opt = opt;
			this.contents = contents;
		}
		var _proto = AssetFile.prototype;
		_proto.equals = function equals(other) {
			return this.url === other.url && this.filename === other.filename && this.hash === other.hash && this.size === other.size && this.opt === other.opt && this.contents === other.contents;
		};
		return AssetFile;
	}();

	var assetIdCounter = -1;
	var VARIANT_SUPPORT = {
		pvr: 'extCompressedTexturePVRTC',
		dxt: 'extCompressedTextureS3TC',
		etc2: 'extCompressedTextureETC',
		etc1: 'extCompressedTextureETC1',
		basis: 'canvas'
	};
	var VARIANT_DEFAULT_PRIORITY = ['pvr', 'dxt', 'etc2', 'etc1', 'basis'];
	var Asset = function (_EventHandler) {
		_inheritsLoose(Asset, _EventHandler);
		function Asset(name, type, file, data, options) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this._id = assetIdCounter--;
			_this._name = name || '';
			_this.type = type;
			_this.tags = new Tags(_assertThisInitialized(_this));
			_this._preload = false;
			_this._file = null;
			_this._data = data || {};
			_this.options = options || {};
			_this._resources = [];
			_this._i18n = {};
			_this.loaded = false;
			_this.loading = false;
			_this.registry = null;
			if (file) _this.file = file;
			return _this;
		}
		var _proto = Asset.prototype;
		_proto.getFileUrl = function getFileUrl() {
			var file = this.file;
			if (!file || !file.url) return null;
			var url = file.url;
			if (this.registry && this.registry.prefix && !ABSOLUTE_URL.test(url)) url = this.registry.prefix + url;
			if (this.type !== 'script' && file.hash) {
				var separator = url.indexOf('?') !== -1 ? '&' : '?';
				url += separator + 't=' + file.hash;
			}
			return url;
		};
		_proto.getAbsoluteUrl = function getAbsoluteUrl(relativePath) {
			if (relativePath.startsWith('blob:') || relativePath.startsWith('data:')) {
				return relativePath;
			}
			var base = path.getDirectory(this.file.url);
			return path.join(base, relativePath);
		};
		_proto.getLocalizedAssetId = function getLocalizedAssetId(locale) {
			locale = findAvailableLocale(locale, this._i18n);
			return this._i18n[locale] || null;
		};
		_proto.addLocalizedAssetId = function addLocalizedAssetId(locale, assetId) {
			this._i18n[locale] = assetId;
			this.fire('add:localized', locale, assetId);
		};
		_proto.removeLocalizedAssetId = function removeLocalizedAssetId(locale) {
			var assetId = this._i18n[locale];
			if (assetId) {
				delete this._i18n[locale];
				this.fire('remove:localized', locale, assetId);
			}
		};
		_proto.ready = function ready(callback, scope) {
			scope = scope || this;
			if (this.loaded) {
				callback.call(scope, this);
			} else {
				this.once('load', function (asset) {
					callback.call(scope, asset);
				});
			}
		};
		_proto.reload = function reload() {
			if (this.loaded) {
				this.loaded = false;
				this.registry.load(this);
			}
		};
		_proto.unload = function unload() {
			if (!this.loaded && this._resources.length === 0) return;
			this.fire('unload', this);
			this.registry.fire('unload:' + this.id, this);
			var old = this._resources;
			this.resources = [];
			this.loaded = false;
			if (this.file) {
				this.registry._loader.clearCache(this.getFileUrl(), this.type);
			}
			for (var i = 0; i < old.length; ++i) {
				var resource = old[i];
				if (resource && resource.destroy) {
					resource.destroy();
				}
			}
		};
		Asset.fetchArrayBuffer = function fetchArrayBuffer(loadUrl, callback, asset, maxRetries) {
			var _asset$file;
			if (maxRetries === void 0) {
				maxRetries = 0;
			}
			if (asset != null && (_asset$file = asset.file) != null && _asset$file.contents) {
				setTimeout(function () {
					callback(null, asset.file.contents);
				});
			} else {
				http.get(loadUrl, {
					cache: true,
					responseType: 'arraybuffer',
					retry: maxRetries > 0,
					maxRetries: maxRetries
				}, callback);
			}
		};
		_createClass(Asset, [{
			key: "id",
			get: function get() {
				return this._id;
			},
			set: function set(value) {
				this._id = value;
			}
		}, {
			key: "name",
			get: function get() {
				return this._name;
			},
			set: function set(value) {
				if (this._name === value) return;
				var old = this._name;
				this._name = value;
				this.fire('name', this, this._name, old);
			}
		}, {
			key: "file",
			get: function get() {
				return this._file;
			},
			set: function set(value) {
				var _this2 = this;
				if (value && value.variants && ['texture', 'textureatlas', 'bundle'].indexOf(this.type) !== -1) {
					var _this$registry;
					var app = ((_this$registry = this.registry) == null || (_this$registry = _this$registry._loader) == null ? void 0 : _this$registry._app) || getApplication();
					var device = app == null ? void 0 : app.graphicsDevice;
					if (device) {
						var _loop = function _loop() {
								var variant = VARIANT_DEFAULT_PRIORITY[i];
								if (value.variants[variant] && device[VARIANT_SUPPORT[variant]]) {
									value = value.variants[variant];
									return 0;
								}
								if (app.enableBundles) {
									var bundles = app.bundles.listBundlesForAsset(_this2);
									if (bundles && bundles.find(function (b) {
										var _b$file;
										return b == null || (_b$file = b.file) == null ? void 0 : _b$file.variants[variant];
									})) {
										return 0;
									}
								}
							},
							_ret;
						for (var i = 0, len = VARIANT_DEFAULT_PRIORITY.length; i < len; i++) {
							_ret = _loop();
							if (_ret === 0) break;
						}
					}
				}
				var oldFile = this._file;
				var newFile = value ? new AssetFile(value.url, value.filename, value.hash, value.size, value.opt, value.contents) : null;
				if (!!newFile !== !!oldFile || newFile && !newFile.equals(oldFile)) {
					this._file = newFile;
					this.fire('change', this, 'file', newFile, oldFile);
					this.reload();
				}
			}
		}, {
			key: "data",
			get: function get() {
				return this._data;
			},
			set: function set(value) {
				var old = this._data;
				this._data = value;
				if (value !== old) {
					this.fire('change', this, 'data', value, old);
					if (this.loaded) this.registry._loader.patch(this, this.registry);
				}
			}
		}, {
			key: "resource",
			get: function get() {
				return this._resources[0];
			},
			set: function set(value) {
				var _old = this._resources[0];
				this._resources[0] = value;
				this.fire('change', this, 'resource', value, _old);
			}
		}, {
			key: "resources",
			get: function get() {
				return this._resources;
			},
			set: function set(value) {
				var _old = this._resources;
				this._resources = value;
				this.fire('change', this, 'resources', value, _old);
			}
		}, {
			key: "preload",
			get: function get() {
				return this._preload;
			},
			set: function set(value) {
				value = !!value;
				if (this._preload === value) return;
				this._preload = value;
				if (this._preload && !this.loaded && !this.loading && this.registry) this.registry.load(this);
			}
		}, {
			key: "loadFaces",
			get: function get() {
				return this._loadFaces;
			},
			set: function set(value) {
				value = !!value;
				if (!this.hasOwnProperty('_loadFaces') || value !== this._loadFaces) {
					this._loadFaces = value;
					if (this.loaded) this.registry._loader.patch(this, this.registry);
				}
			}
		}]);
		return Asset;
	}(EventHandler);

	var TagsCache = function () {
		function TagsCache(key) {
			if (key === void 0) {
				key = null;
			}
			this._index = {};
			this._key = void 0;
			this._key = key;
		}
		var _proto = TagsCache.prototype;
		_proto.addItem = function addItem(item) {
			var tags = item.tags._list;
			for (var _iterator = _createForOfIteratorHelperLoose(tags), _step; !(_step = _iterator()).done;) {
				var tag = _step.value;
				this.add(tag, item);
			}
		};
		_proto.removeItem = function removeItem(item) {
			var tags = item.tags._list;
			for (var _iterator2 = _createForOfIteratorHelperLoose(tags), _step2; !(_step2 = _iterator2()).done;) {
				var tag = _step2.value;
				this.remove(tag, item);
			}
		};
		_proto.add = function add(tag, item) {
			if (this._index[tag] && this._index[tag].list.indexOf(item) !== -1) return;
			if (!this._index[tag]) {
				this._index[tag] = {
					list: []
				};
				if (this._key) this._index[tag].keys = {};
			}
			this._index[tag].list.push(item);
			if (this._key) this._index[tag].keys[item[this._key]] = item;
		};
		_proto.remove = function remove(tag, item) {
			if (!this._index[tag]) return;
			if (this._key) {
				if (!this._index[tag].keys[item[this._key]]) return;
			}
			var ind = this._index[tag].list.indexOf(item);
			if (ind === -1) return;
			this._index[tag].list.splice(ind, 1);
			if (this._key) delete this._index[tag].keys[item[this._key]];
			if (this._index[tag].list.length === 0) delete this._index[tag];
		};
		_proto.find = function find(args) {
			var _this = this;
			var index = {};
			var items = [];
			var item, tag, tags, tagsRest, missingIndex;
			var sort = function sort(a, b) {
				return _this._index[a].list.length - _this._index[b].list.length;
			};
			for (var i = 0; i < args.length; i++) {
				tag = args[i];
				if (tag instanceof Array) {
					if (tag.length === 0) continue;
					if (tag.length === 1) {
						tag = tag[0];
					} else {
						missingIndex = false;
						for (var t = 0; t < tag.length; t++) {
							if (!this._index[tag[t]]) {
								missingIndex = true;
								break;
							}
						}
						if (missingIndex) continue;
						tags = tag.slice(0).sort(sort);
						tagsRest = tags.slice(1);
						if (tagsRest.length === 1) tagsRest = tagsRest[0];
						for (var n = 0; n < this._index[tags[0]].list.length; n++) {
							item = this._index[tags[0]].list[n];
							if ((this._key ? !index[item[this._key]] : items.indexOf(item) === -1) && item.tags.has(tagsRest)) {
								if (this._key) index[item[this._key]] = true;
								items.push(item);
							}
						}
						continue;
					}
				}
				if (tag && typeof tag === 'string' && this._index[tag]) {
					for (var _n = 0; _n < this._index[tag].list.length; _n++) {
						item = this._index[tag].list[_n];
						if (this._key) {
							if (!index[item[this._key]]) {
								index[item[this._key]] = true;
								items.push(item);
							}
						} else if (items.indexOf(item) === -1) {
							items.push(item);
						}
					}
				}
			}
			return items;
		};
		return TagsCache;
	}();

	var AssetRegistry = function (_EventHandler) {
		_inheritsLoose(AssetRegistry, _EventHandler);
		function AssetRegistry(loader) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this._assets = new Set();
			_this._idToAsset = new Map();
			_this._urlToAsset = new Map();
			_this._nameToAsset = new Map();
			_this._tags = new TagsCache('_id');
			_this.prefix = null;
			_this._loader = loader;
			return _this;
		}
		var _proto = AssetRegistry.prototype;
		_proto.list = function list(filters) {
			if (filters === void 0) {
				filters = {};
			}
			var assets = Array.from(this._assets);
			if (filters.preload !== undefined) {
				return assets.filter(function (asset) {
					return asset.preload === filters.preload;
				});
			}
			return assets;
		};
		_proto.add = function add(asset) {
			var _asset$file, _asset$file2;
			if (this._assets.has(asset)) return;
			this._assets.add(asset);
			this._idToAsset.set(asset.id, asset);
			if ((_asset$file = asset.file) != null && _asset$file.url) {
				this._urlToAsset.set(asset.file.url, asset);
			}
			if (!this._nameToAsset.has(asset.name)) this._nameToAsset.set(asset.name, new Set());
			this._nameToAsset.get(asset.name).add(asset);
			asset.on('name', this._onNameChange, this);
			asset.registry = this;
			this._tags.addItem(asset);
			asset.tags.on('add', this._onTagAdd, this);
			asset.tags.on('remove', this._onTagRemove, this);
			this.fire('add', asset);
			this.fire('add:' + asset.id, asset);
			if ((_asset$file2 = asset.file) != null && _asset$file2.url) {
				this.fire('add:url:' + asset.file.url, asset);
			}
			if (asset.preload) this.load(asset);
		};
		_proto.remove = function remove(asset) {
			var _asset$file3, _asset$file4;
			if (!this._assets.has(asset)) return false;
			this._assets.delete(asset);
			this._idToAsset.delete(asset.id);
			if ((_asset$file3 = asset.file) != null && _asset$file3.url) {
				this._urlToAsset.delete(asset.file.url);
			}
			asset.off('name', this._onNameChange, this);
			if (this._nameToAsset.has(asset.name)) {
				var items = this._nameToAsset.get(asset.name);
				items.delete(asset);
				if (items.size === 0) {
					this._nameToAsset.delete(asset.name);
				}
			}
			this._tags.removeItem(asset);
			asset.tags.off('add', this._onTagAdd, this);
			asset.tags.off('remove', this._onTagRemove, this);
			asset.fire('remove', asset);
			this.fire('remove', asset);
			this.fire('remove:' + asset.id, asset);
			if ((_asset$file4 = asset.file) != null && _asset$file4.url) {
				this.fire('remove:url:' + asset.file.url, asset);
			}
			return true;
		};
		_proto.get = function get(id) {
			return this._idToAsset.get(Number(id));
		};
		_proto.getByUrl = function getByUrl(url) {
			return this._urlToAsset.get(url);
		};
		_proto.load = function load(asset) {
			var _this2 = this;
			if (asset.loading || asset.loaded) {
				return;
			}
			var file = asset.file;
			var _opened = function _opened(resource) {
				if (resource instanceof Array) {
					asset.resources = resource;
				} else {
					asset.resource = resource;
				}
				_this2._loader.patch(asset, _this2);
				_this2.fire('load', asset);
				_this2.fire('load:' + asset.id, asset);
				if (file && file.url) _this2.fire('load:url:' + file.url, asset);
				asset.fire('load', asset);
			};
			var _loaded = function _loaded(err, resource, extra) {
				asset.loaded = true;
				asset.loading = false;
				if (err) {
					_this2.fire('error', err, asset);
					_this2.fire('error:' + asset.id, err, asset);
					asset.fire('error', err, asset);
				} else {
					if (!script.legacy && asset.type === 'script') {
						var handler = _this2._loader.getHandler('script');
						if (handler._cache[asset.id] && handler._cache[asset.id].parentNode === document.head) {
							document.head.removeChild(handler._cache[asset.id]);
						}
						handler._cache[asset.id] = extra;
					}
					_opened(resource);
				}
			};
			if (file || asset.type === 'cubemap') {
				this.fire('load:start', asset);
				this.fire('load:' + asset.id + ':start', asset);
				asset.loading = true;
				this._loader.load(asset.getFileUrl(), asset.type, _loaded, asset);
			} else {
				var resource = this._loader.open(asset.type, asset.data);
				asset.loaded = true;
				_opened(resource);
			}
		};
		_proto.loadFromUrl = function loadFromUrl(url, type, callback) {
			this.loadFromUrlAndFilename(url, null, type, callback);
		};
		_proto.loadFromUrlAndFilename = function loadFromUrlAndFilename(url, filename, type, callback) {
			var _this3 = this;
			var name = path.getBasename(filename || url);
			var file = {
				filename: filename || name,
				url: url
			};
			var asset = this.getByUrl(url);
			if (!asset) {
				asset = new Asset(name, type, file);
				this.add(asset);
			} else if (asset.loaded) {
				callback(asset.loadFromUrlError || null, asset);
				return;
			}
			var startLoad = function startLoad(asset) {
				asset.once('load', function (loadedAsset) {
					if (type === 'material') {
						_this3._loadTextures(loadedAsset, function (err, textures) {
							callback(err, loadedAsset);
						});
					} else {
						callback(null, loadedAsset);
					}
				});
				asset.once('error', function (err) {
					if (err) {
						_this3.loadFromUrlError = err;
					}
					callback(err, asset);
				});
				_this3.load(asset);
			};
			if (asset.resource) {
				callback(null, asset);
			} else if (type === 'model') {
				this._loadModel(asset, startLoad);
			} else {
				startLoad(asset);
			}
		};
		_proto._loadModel = function _loadModel(modelAsset, continuation) {
			var _this4 = this;
			var url = modelAsset.getFileUrl();
			var ext = path.getExtension(url);
			if (ext === '.json' || ext === '.glb') {
				var dir = path.getDirectory(url);
				var basename = path.getBasename(url);
				var mappingUrl = path.join(dir, basename.replace(ext, '.mapping.json'));
				this._loader.load(mappingUrl, 'json', function (err, data) {
					if (err) {
						modelAsset.data = {
							mapping: []
						};
						continuation(modelAsset);
					} else {
						_this4._loadMaterials(modelAsset, data, function (e, materials) {
							modelAsset.data = data;
							continuation(modelAsset);
						});
					}
				});
			} else {
				continuation(modelAsset);
			}
		};
		_proto._loadMaterials = function _loadMaterials(modelAsset, mapping, callback) {
			var _this5 = this;
			var materials = [];
			var count = 0;
			var onMaterialLoaded = function onMaterialLoaded(err, materialAsset) {
				_this5._loadTextures(materialAsset, function (err, textures) {
					materials.push(materialAsset);
					if (materials.length === count) {
						callback(null, materials);
					}
				});
			};
			for (var i = 0; i < mapping.mapping.length; i++) {
				var _path = mapping.mapping[i].path;
				if (_path) {
					count++;
					var url = modelAsset.getAbsoluteUrl(_path);
					this.loadFromUrl(url, 'material', onMaterialLoaded);
				}
			}
			if (count === 0) {
				callback(null, materials);
			}
		};
		_proto._loadTextures = function _loadTextures(materialAsset, callback) {
			var textures = [];
			var count = 0;
			var data = materialAsset.data;
			if (data.mappingFormat !== 'path') {
				callback(null, textures);
				return;
			}
			var onTextureLoaded = function onTextureLoaded(err, texture) {
				if (err) console.error(err);
				textures.push(texture);
				if (textures.length === count) {
					callback(null, textures);
				}
			};
			var texParams = standardMaterialTextureParameters;
			for (var i = 0; i < texParams.length; i++) {
				var _path2 = data[texParams[i]];
				if (_path2 && typeof _path2 === 'string') {
					count++;
					var url = materialAsset.getAbsoluteUrl(_path2);
					this.loadFromUrl(url, 'texture', onTextureLoaded);
				}
			}
			if (count === 0) {
				callback(null, textures);
			}
		};
		_proto._onTagAdd = function _onTagAdd(tag, asset) {
			this._tags.add(tag, asset);
		};
		_proto._onTagRemove = function _onTagRemove(tag, asset) {
			this._tags.remove(tag, asset);
		};
		_proto._onNameChange = function _onNameChange(asset, name, nameOld) {
			if (this._nameToAsset.has(nameOld)) {
				var items = this._nameToAsset.get(nameOld);
				items.delete(asset);
				if (items.size === 0) {
					this._nameToAsset.delete(nameOld);
				}
			}
			if (!this._nameToAsset.has(asset.name)) this._nameToAsset.set(asset.name, new Set());
			this._nameToAsset.get(asset.name).add(asset);
		};
		_proto.findByTag = function findByTag() {
			return this._tags.find(arguments);
		};
		_proto.filter = function filter(callback) {
			return Array.from(this._assets).filter(function (asset) {
				return callback(asset);
			});
		};
		_proto.find = function find(name, type) {
			var items = this._nameToAsset.get(name);
			if (!items) return null;
			for (var _iterator = _createForOfIteratorHelperLoose(items), _step; !(_step = _iterator()).done;) {
				var asset = _step.value;
				if (!type || asset.type === type) {
					return asset;
				}
			}
			return null;
		};
		_proto.findAll = function findAll(name, type) {
			var items = this._nameToAsset.get(name);
			if (!items) return [];
			var results = Array.from(items);
			if (!type) return results;
			return results.filter(function (asset) {
				return asset.type === type;
			});
		};
		return AssetRegistry;
	}(EventHandler);

	var BundleRegistry = function () {
		function BundleRegistry(assets) {
			this._assets = assets;
			this._bundleAssets = {};
			this._assetsInBundles = {};
			this._urlsInBundles = {};
			this._fileRequests = {};
			this._assets.on('add', this._onAssetAdded, this);
			this._assets.on('remove', this._onAssetRemoved, this);
		}
		var _proto = BundleRegistry.prototype;
		_proto._onAssetAdded = function _onAssetAdded(asset) {
			if (asset.type === 'bundle') {
				this._bundleAssets[asset.id] = asset;
				this._registerBundleEventListeners(asset.id);
				for (var i = 0, len = asset.data.assets.length; i < len; i++) {
					this._indexAssetInBundle(asset.data.assets[i], asset);
				}
			} else {
				if (this._assetsInBundles[asset.id]) {
					this._indexAssetFileUrls(asset);
				}
			}
		};
		_proto._registerBundleEventListeners = function _registerBundleEventListeners(bundleAssetId) {
			this._assets.on('load:' + bundleAssetId, this._onBundleLoaded, this);
			this._assets.on('error:' + bundleAssetId, this._onBundleError, this);
		};
		_proto._unregisterBundleEventListeners = function _unregisterBundleEventListeners(bundleAssetId) {
			this._assets.off('load:' + bundleAssetId, this._onBundleLoaded, this);
			this._assets.off('error:' + bundleAssetId, this._onBundleError, this);
		};
		_proto._indexAssetInBundle = function _indexAssetInBundle(assetId, bundleAsset) {
			if (!this._assetsInBundles[assetId]) {
				this._assetsInBundles[assetId] = [bundleAsset];
			} else {
				var bundles = this._assetsInBundles[assetId];
				var idx = bundles.indexOf(bundleAsset);
				if (idx === -1) {
					bundles.push(bundleAsset);
				}
			}
			var asset = this._assets.get(assetId);
			if (asset) {
				this._indexAssetFileUrls(asset);
			}
		};
		_proto._indexAssetFileUrls = function _indexAssetFileUrls(asset) {
			var urls = this._getAssetFileUrls(asset);
			if (!urls) return;
			for (var i = 0, len = urls.length; i < len; i++) {
				var url = urls[i];
				this._urlsInBundles[url] = this._assetsInBundles[asset.id];
			}
		};
		_proto._getAssetFileUrls = function _getAssetFileUrls(asset) {
			var url = asset.getFileUrl();
			if (!url) return null;
			url = this._normalizeUrl(url);
			var urls = [url];
			if (asset.type === 'font') {
				var numFiles = asset.data.info.maps.length;
				for (var i = 1; i < numFiles; i++) {
					urls.push(url.replace('.png', i + '.png'));
				}
			}
			return urls;
		};
		_proto._normalizeUrl = function _normalizeUrl(url) {
			return url && url.split('?')[0];
		};
		_proto._onAssetRemoved = function _onAssetRemoved(asset) {
			if (asset.type === 'bundle') {
				delete this._bundleAssets[asset.id];
				this._unregisterBundleEventListeners(asset.id);
				for (var id in this._assetsInBundles) {
					var array = this._assetsInBundles[id];
					var idx = array.indexOf(asset);
					if (idx !== -1) {
						array.splice(idx, 1);
						if (!array.length) {
							delete this._assetsInBundles[id];
							for (var url in this._urlsInBundles) {
								if (this._urlsInBundles[url] === array) {
									delete this._urlsInBundles[url];
								}
							}
						}
					}
				}
				this._onBundleError("Bundle " + asset.id + " was removed", asset);
			} else if (this._assetsInBundles[asset.id]) {
				delete this._assetsInBundles[asset.id];
				var urls = this._getAssetFileUrls(asset);
				for (var i = 0, len = urls.length; i < len; i++) {
					delete this._urlsInBundles[urls[i]];
				}
			}
		};
		_proto._onBundleLoaded = function _onBundleLoaded(bundleAsset) {
			var _this = this;
			if (!bundleAsset.resource) {
				this._onBundleError("Bundle " + bundleAsset.id + " failed to load", bundleAsset);
				return;
			}
			requestAnimationFrame(function () {
				if (!_this._fileRequests) {
					return;
				}
				for (var url in _this._fileRequests) {
					var bundles = _this._urlsInBundles[url];
					if (!bundles || bundles.indexOf(bundleAsset) === -1) continue;
					var decodedUrl = decodeURIComponent(url);
					var err = null;
					if (!bundleAsset.resource.hasBlobUrl(decodedUrl)) {
						err = "Bundle " + bundleAsset.id + " does not contain URL " + url;
					}
					var requests = _this._fileRequests[url];
					for (var i = 0, len = requests.length; i < len; i++) {
						if (err) {
							requests[i](err);
						} else {
							requests[i](null, bundleAsset.resource.getBlobUrl(decodedUrl));
						}
					}
					delete _this._fileRequests[url];
				}
			});
		};
		_proto._onBundleError = function _onBundleError(err, bundleAsset) {
			for (var url in this._fileRequests) {
				var bundle = this._findLoadedOrLoadingBundleForUrl(url);
				if (!bundle) {
					var requests = this._fileRequests[url];
					for (var i = 0, len = requests.length; i < len; i++) {
						requests[i](err);
					}
					delete this._fileRequests[url];
				}
			}
		};
		_proto._findLoadedOrLoadingBundleForUrl = function _findLoadedOrLoadingBundleForUrl(url) {
			var bundles = this._urlsInBundles[url];
			if (!bundles) return null;
			var len = bundles.length;
			for (var i = 0; i < len; i++) {
				if (bundles[i].loaded && bundles[i].resource) {
					return bundles[i];
				}
			}
			for (var _i = 0; _i < len; _i++) {
				if (bundles[_i].loading) {
					return bundles[_i];
				}
			}
			return null;
		};
		_proto.listBundlesForAsset = function listBundlesForAsset(asset) {
			return this._assetsInBundles[asset.id] || null;
		};
		_proto.list = function list() {
			var result = [];
			for (var id in this._bundleAssets) {
				result.push(this._bundleAssets[id]);
			}
			return result;
		};
		_proto.hasUrl = function hasUrl(url) {
			return !!this._urlsInBundles[url];
		};
		_proto.canLoadUrl = function canLoadUrl(url) {
			return !!this._findLoadedOrLoadingBundleForUrl(url);
		};
		_proto.loadUrl = function loadUrl(url, callback) {
			var bundle = this._findLoadedOrLoadingBundleForUrl(url);
			if (!bundle) {
				callback("URL " + url + " not found in any bundles");
				return;
			}
			if (bundle.loaded) {
				var decodedUrl = decodeURIComponent(url);
				if (!bundle.resource.hasBlobUrl(decodedUrl)) {
					callback("Bundle " + bundle.id + " does not contain URL " + url);
					return;
				}
				callback(null, bundle.resource.getBlobUrl(decodedUrl));
			} else if (this._fileRequests.hasOwnProperty(url)) {
				this._fileRequests[url].push(callback);
			} else {
				this._fileRequests[url] = [callback];
			}
		};
		_proto.destroy = function destroy() {
			this._assets.off('add', this._onAssetAdded, this);
			this._assets.off('remove', this._onAssetRemoved, this);
			for (var id in this._bundleAssets) {
				this._unregisterBundleEventListeners(id);
			}
			this._assets = null;
			this._bundleAssets = null;
			this._assetsInBundles = null;
			this._urlsInBundles = null;
			this._fileRequests = null;
		};
		return BundleRegistry;
	}();

	var ComponentSystemRegistry = function (_EventHandler) {
		_inheritsLoose(ComponentSystemRegistry, _EventHandler);
		function ComponentSystemRegistry() {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this.anim = void 0;
			_this.animation = void 0;
			_this.audiolistener = void 0;
			_this.audiosource = void 0;
			_this.button = void 0;
			_this.camera = void 0;
			_this.collision = void 0;
			_this.element = void 0;
			_this.joint = void 0;
			_this.layoutchild = void 0;
			_this.layoutgroup = void 0;
			_this.light = void 0;
			_this.model = void 0;
			_this.particlesystem = void 0;
			_this.render = void 0;
			_this.rigidbody = void 0;
			_this.screen = void 0;
			_this.script = void 0;
			_this.scrollbar = void 0;
			_this.scrollview = void 0;
			_this.sound = void 0;
			_this.sprite = void 0;
			_this.zone = void 0;
			_this.list = [];
			return _this;
		}
		var _proto = ComponentSystemRegistry.prototype;
		_proto.add = function add(system) {
			var id = system.id;
			if (this[id]) {
				throw new Error("ComponentSystem name '" + id + "' already registered or not allowed");
			}
			this[id] = system;
			this.list.push(system);
		};
		_proto.remove = function remove(system) {
			var id = system.id;
			if (!this[id]) {
				throw new Error("No ComponentSystem named '" + id + "' registered");
			}
			delete this[id];
			var index = this.list.indexOf(this[id]);
			if (index !== -1) {
				this.list.splice(index, 1);
			}
		};
		_proto.destroy = function destroy() {
			this.off();
			for (var i = 0; i < this.list.length; i++) {
				this.list[i].destroy();
			}
		};
		return ComponentSystemRegistry;
	}(EventHandler);

	var Bundle = function () {
		function Bundle(files) {
			this._blobUrls = {};
			for (var i = 0, len = files.length; i < len; i++) {
				if (files[i].url) {
					this._blobUrls[files[i].name] = files[i].url;
				}
			}
		}
		var _proto = Bundle.prototype;
		_proto.hasBlobUrl = function hasBlobUrl(url) {
			return !!this._blobUrls[url];
		};
		_proto.getBlobUrl = function getBlobUrl(url) {
			return this._blobUrls[url];
		};
		_proto.destroy = function destroy() {
			for (var key in this._blobUrls) {
				URL.revokeObjectURL(this._blobUrls[key]);
			}
			this._blobUrls = null;
		};
		return Bundle;
	}();

	var Untar;
	function UntarScope(isWorker) {
		var utfDecoder;
		var asciiDecoder;
		if (typeof TextDecoder !== 'undefined') {
			try {
				utfDecoder = new TextDecoder('utf-8');
				asciiDecoder = new TextDecoder('windows-1252');
			} catch (e) {
				console.warn('TextDecoder not supported - pc.Untar module will not work');
			}
		} else {
			console.warn('TextDecoder not supported - pc.Untar module will not work');
		}
		function PaxHeader(fields) {
			this._fields = fields;
		}
		PaxHeader.parse = function (buffer, start, length) {
			var paxArray = new Uint8Array(buffer, start, length);
			var bytesRead = 0;
			var fields = [];
			while (bytesRead < length) {
				var spaceIndex = void 0;
				for (spaceIndex = bytesRead; spaceIndex < length; spaceIndex++) {
					if (paxArray[spaceIndex] === 0x20) break;
				}
				if (spaceIndex >= length) {
					throw new Error('Invalid PAX header data format.');
				}
				var fieldLength = parseInt(utfDecoder.decode(new Uint8Array(buffer, start + bytesRead, spaceIndex - bytesRead)), 10);
				var fieldText = utfDecoder.decode(new Uint8Array(buffer, start + spaceIndex + 1, fieldLength - (spaceIndex - bytesRead) - 2));
				var field = fieldText.split('=');
				if (field.length !== 2) {
					throw new Error('Invalid PAX header data format.');
				}
				if (field[1].length === 0) {
					field[1] = null;
				}
				fields.push({
					name: field[0],
					value: field[1]
				});
				bytesRead += fieldLength;
			}
			return new PaxHeader(fields);
		};
		PaxHeader.prototype.applyHeader = function (file) {
			for (var i = 0; i < this._fields.length; i++) {
				var fieldName = this._fields[i].name;
				var fieldValue = this._fields[i].value;
				if (fieldName === 'path') {
					fieldName = 'name';
				}
				if (fieldValue === null) {
					delete file[fieldName];
				} else {
					file[fieldName] = fieldValue;
				}
			}
		};
		function UntarInternal(arrayBuffer) {
			this._arrayBuffer = arrayBuffer || new ArrayBuffer(0);
			this._bufferView = new DataView(this._arrayBuffer);
			this._globalPaxHeader = null;
			this._paxHeader = null;
			this._bytesRead = 0;
		}
		if (!isWorker) {
			Untar = UntarInternal;
		}
		UntarInternal.prototype._hasNext = function () {
			return this._bytesRead + 4 < this._arrayBuffer.byteLength && this._bufferView.getUint32(this._bytesRead) !== 0;
		};
		UntarInternal.prototype._readNextFile = function () {
			var headersDataView = new DataView(this._arrayBuffer, this._bytesRead, 512);
			var headers = asciiDecoder.decode(headersDataView);
			this._bytesRead += 512;
			var name = headers.substring(0, 100).replace(/\0/g, '');
			var ustarFormat = headers.substring(257, 263);
			var size = parseInt(headers.substring(124, 136), 8);
			var type = headers.substring(156, 157);
			var start = this._bytesRead;
			var url = null;
			var normalFile = false;
			switch (type) {
				case '0':
				case '':
					normalFile = true;
					if (!isWorker) {
						var blob = new Blob([this._arrayBuffer.slice(this._bytesRead, this._bytesRead + size)]);
						url = URL.createObjectURL(blob);
					}
					break;
				case 'g':
					this._globalPaxHeader = PaxHeader.parse(this._arrayBuffer, this._bytesRead, size);
					break;
				case 'x':
					this._paxHeader = PaxHeader.parse(this._arrayBuffer, this._bytesRead, size);
					break;
			}
			this._bytesRead += size;
			var remainder = size % 512;
			if (remainder !== 0) {
				this._bytesRead += 512 - remainder;
			}
			if (!normalFile) {
				return null;
			}
			if (ustarFormat.indexOf('ustar') !== -1) {
				var namePrefix = headers.substring(345, 500).replace(/\0/g, '');
				if (namePrefix.length > 0) {
					name = namePrefix.trim() + name.trim();
				}
			}
			var file = {
				name: name,
				start: start,
				size: size,
				url: url
			};
			if (this._globalPaxHeader) {
				this._globalPaxHeader.applyHeader(file);
			}
			if (this._paxHeader) {
				this._paxHeader.applyHeader(file);
				this._paxHeader = null;
			}
			return file;
		};
		UntarInternal.prototype.untar = function (filenamePrefix) {
			if (!utfDecoder) {
				console.error('Cannot untar because TextDecoder interface is not available for this platform.');
				return [];
			}
			var files = [];
			while (this._hasNext()) {
				var file = this._readNextFile();
				if (!file) continue;
				if (filenamePrefix && file.name) {
					file.name = filenamePrefix + file.name;
				}
				files.push(file);
			}
			return files;
		};
		if (isWorker) {
			self.onmessage = function (e) {
				var id = e.data.id;
				try {
					var archive = new UntarInternal(e.data.arrayBuffer);
					var files = archive.untar(e.data.prefix);
					postMessage({
						id: id,
						files: files,
						arrayBuffer: e.data.arrayBuffer
					}, [e.data.arrayBuffer]);
				} catch (err) {
					postMessage({
						id: id,
						error: err.toString()
					});
				}
			};
		}
	}
	var workerUrl = null;
	function getWorkerUrl() {
		if (!workerUrl) {
			var code = '(' + UntarScope.toString() + ')(true)\n\n';
			var blob = new Blob([code], {
				type: 'application/javascript'
			});
			workerUrl = URL.createObjectURL(blob);
		}
		return workerUrl;
	}
	var UntarWorker = function () {
		function UntarWorker(filenamePrefix) {
			this._requestId = 0;
			this._pendingRequests = {};
			this._filenamePrefix = filenamePrefix;
			this._worker = new Worker(getWorkerUrl());
			this._worker.addEventListener('message', this._onMessage.bind(this));
		}
		var _proto = UntarWorker.prototype;
		_proto._onMessage = function _onMessage(e) {
			var id = e.data.id;
			if (!this._pendingRequests[id]) return;
			var callback = this._pendingRequests[id];
			delete this._pendingRequests[id];
			if (e.data.error) {
				callback(e.data.error);
			} else {
				var arrayBuffer = e.data.arrayBuffer;
				for (var i = 0, len = e.data.files.length; i < len; i++) {
					var file = e.data.files[i];
					var blob = new Blob([arrayBuffer.slice(file.start, file.start + file.size)]);
					file.url = URL.createObjectURL(blob);
				}
				callback(null, e.data.files);
			}
		};
		_proto.untar = function untar(arrayBuffer, callback) {
			var id = this._requestId++;
			this._pendingRequests[id] = callback;
			this._worker.postMessage({
				id: id,
				prefix: this._filenamePrefix,
				arrayBuffer: arrayBuffer
			}, [arrayBuffer]);
		};
		_proto.hasPendingRequests = function hasPendingRequests() {
			return Object.keys(this._pendingRequests).length > 0;
		};
		_proto.destroy = function destroy() {
			if (this._worker) {
				this._worker.terminate();
				this._worker = null;
				this._pendingRequests = null;
			}
		};
		return UntarWorker;
	}();
	UntarScope();

	var BundleHandler = function () {
		function BundleHandler(app) {
			this.handlerType = "bundle";
			this._assets = app.assets;
			this._worker = null;
			this.maxRetries = 0;
		}
		var _proto = BundleHandler.prototype;
		_proto.load = function load(url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			var self = this;
			http.get(url.load, {
				responseType: Http.ResponseType.ARRAY_BUFFER,
				retry: this.maxRetries > 0,
				maxRetries: this.maxRetries
			}, function (err, response) {
				if (!err) {
					try {
						self._untar(response, callback);
					} catch (ex) {
						callback('Error loading bundle resource ' + url.original + ': ' + ex);
					}
				} else {
					callback('Error loading bundle resource ' + url.original + ': ' + err);
				}
			});
		};
		_proto._untar = function _untar(response, callback) {
			var self = this;
			if (platform.workers) {
				if (!self._worker) {
					self._worker = new UntarWorker(self._assets.prefix);
				}
				self._worker.untar(response, function (err, files) {
					callback(err, files);
					if (!self._worker.hasPendingRequests()) {
						self._worker.destroy();
						self._worker = null;
					}
				});
			} else {
				var archive = new Untar(response);
				var files = archive.untar(self._assets.prefix);
				callback(null, files);
			}
		};
		_proto.open = function open(url, data) {
			return new Bundle(data);
		};
		_proto.patch = function patch(asset, assets) {};
		return BundleHandler;
	}();

	var ResourceLoader = function () {
		function ResourceLoader(app) {
			this._handlers = {};
			this._requests = {};
			this._cache = {};
			this._app = app;
		}
		var _proto = ResourceLoader.prototype;
		_proto.addHandler = function addHandler(type, handler) {
			this._handlers[type] = handler;
			handler._loader = this;
		};
		_proto.removeHandler = function removeHandler(type) {
			delete this._handlers[type];
		};
		_proto.getHandler = function getHandler(type) {
			return this._handlers[type];
		};
		ResourceLoader.makeKey = function makeKey(url, type) {
			return url + "-" + type;
		};
		_proto.load = function load(url, type, callback, asset) {
			var handler = this._handlers[type];
			if (!handler) {
				var err = "No resource handler for asset type: '" + type + "' when loading [" + url + "]";
				callback(err);
				return;
			}
			if (!url) {
				this._loadNull(handler, callback, asset);
				return;
			}
			var key = ResourceLoader.makeKey(url, type);
			if (this._cache[key] !== undefined) {
				callback(null, this._cache[key]);
			} else if (this._requests[key]) {
				this._requests[key].push(callback);
			} else {
				this._requests[key] = [callback];
				var self = this;
				var handleLoad = function handleLoad(err, urlObj) {
					if (err) {
						self._onFailure(key, err);
						return;
					}
					handler.load(urlObj, function (err, data, extra) {
						if (!self._requests[key]) {
							return;
						}
						if (err) {
							self._onFailure(key, err);
							return;
						}
						try {
							self._onSuccess(key, handler.open(urlObj.original, data, asset), extra);
						} catch (e) {
							self._onFailure(key, e);
						}
					}, asset);
				};
				var normalizedUrl = url.split('?')[0];
				if (this._app.enableBundles && this._app.bundles.hasUrl(normalizedUrl)) {
					if (!this._app.bundles.canLoadUrl(normalizedUrl)) {
						handleLoad("Bundle for " + url + " not loaded yet");
						return;
					}
					this._app.bundles.loadUrl(normalizedUrl, function (err, fileUrlFromBundle) {
						handleLoad(err, {
							load: fileUrlFromBundle,
							original: normalizedUrl
						});
					});
				} else {
					handleLoad(null, {
						load: url,
						original: asset && asset.file.filename || url
					});
				}
			}
		};
		_proto._loadNull = function _loadNull(handler, callback, asset) {
			var onLoad = function onLoad(err, data, extra) {
				if (err) {
					callback(err);
				} else {
					try {
						callback(null, handler.open(null, data, asset), extra);
					} catch (e) {
						callback(e);
					}
				}
			};
			handler.load(null, onLoad, asset);
		};
		_proto._onSuccess = function _onSuccess(key, result, extra) {
			if (result !== null) {
				this._cache[key] = result;
			} else {
				delete this._cache[key];
			}
			for (var i = 0; i < this._requests[key].length; i++) {
				this._requests[key][i](null, result, extra);
			}
			delete this._requests[key];
		};
		_proto._onFailure = function _onFailure(key, err) {
			console.error(err);
			if (this._requests[key]) {
				for (var i = 0; i < this._requests[key].length; i++) {
					this._requests[key][i](err);
				}
				delete this._requests[key];
			}
		};
		_proto.open = function open(type, data) {
			var handler = this._handlers[type];
			if (!handler) {
				console.warn('No resource handler found for: ' + type);
				return data;
			}
			return handler.open(null, data);
		};
		_proto.patch = function patch(asset, assets) {
			var handler = this._handlers[asset.type];
			if (!handler) {
				console.warn('No resource handler found for: ' + asset.type);
				return;
			}
			if (handler.patch) {
				handler.patch(asset, assets);
			}
		};
		_proto.clearCache = function clearCache(url, type) {
			var key = ResourceLoader.makeKey(url, type);
			delete this._cache[key];
		};
		_proto.getFromCache = function getFromCache(url, type) {
			var key = ResourceLoader.makeKey(url, type);
			if (this._cache[key]) {
				return this._cache[key];
			}
			return undefined;
		};
		_proto.enableRetry = function enableRetry(maxRetries) {
			if (maxRetries === void 0) {
				maxRetries = 5;
			}
			maxRetries = Math.max(0, maxRetries) || 0;
			for (var key in this._handlers) {
				this._handlers[key].maxRetries = maxRetries;
			}
		};
		_proto.disableRetry = function disableRetry() {
			for (var key in this._handlers) {
				this._handlers[key].maxRetries = 0;
			}
		};
		_proto.destroy = function destroy() {
			this._handlers = {};
			this._requests = {};
			this._cache = {};
		};
		return ResourceLoader;
	}();

	var I18nParser = function () {
		function I18nParser() {}
		var _proto = I18nParser.prototype;
		_proto._validate = function _validate(data) {
			if (!data.header) {
				throw new Error('pc.I18n#addData: Missing "header" field');
			}
			if (!data.header.version) {
				throw new Error('pc.I18n#addData: Missing "header.version" field');
			}
			if (data.header.version !== 1) {
				throw new Error('pc.I18n#addData: Invalid "header.version" field');
			}
			if (!data.data) {
				throw new Error('pc.I18n#addData: Missing "data" field');
			} else if (!Array.isArray(data.data)) {
				throw new Error('pc.I18n#addData: "data" field must be an array');
			}
			for (var i = 0, len = data.data.length; i < len; i++) {
				var entry = data.data[i];
				if (!entry.info) {
					throw new Error("pc.I18n#addData: missing \"data[" + i + "].info\" field");
				}
				if (!entry.info.locale) {
					throw new Error("pc.I18n#addData: missing \"data[" + i + "].info.locale\" field");
				}
				if (typeof entry.info.locale !== 'string') {
					throw new Error("pc.I18n#addData: \"data[" + i + "].info.locale\" must be a string");
				}
				if (!entry.messages) {
					throw new Error("pc.I18n#addData: missing \"data[" + i + "].messages\" field");
				}
			}
		};
		_proto.parse = function parse(data) {
			return data.data;
		};
		return I18nParser;
	}();

	var I18n = function (_EventHandler) {
		_inheritsLoose(I18n, _EventHandler);
		function I18n(app) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this.locale = DEFAULT_LOCALE;
			_this._translations = {};
			_this._availableLangs = {};
			_this._app = app;
			_this._assets = [];
			_this._parser = new I18nParser();
			return _this;
		}
		I18n.findAvailableLocale = function findAvailableLocale$1(desiredLocale, availableLocales) {
			return findAvailableLocale(desiredLocale, availableLocales);
		};
		var _proto = I18n.prototype;
		_proto.findAvailableLocale = function findAvailableLocale(desiredLocale) {
			if (this._translations[desiredLocale]) {
				return desiredLocale;
			}
			var lang = getLang(desiredLocale);
			return this._findFallbackLocale(desiredLocale, lang);
		};
		_proto.getText = function getText(key, locale) {
			var result = key;
			var lang;
			if (!locale) {
				locale = this._locale;
				lang = this._lang;
			}
			var translations = this._translations[locale];
			if (!translations) {
				if (!lang) {
					lang = getLang(locale);
				}
				locale = this._findFallbackLocale(locale, lang);
				translations = this._translations[locale];
			}
			if (translations && translations.hasOwnProperty(key)) {
				result = translations[key];
				if (Array.isArray(result)) {
					result = result[0];
				}
				if (result === null || result === undefined) {
					result = key;
				}
			}
			return result;
		};
		_proto.getPluralText = function getPluralText(key, n, locale) {
			var result = key;
			var lang;
			var pluralFn;
			if (!locale) {
				locale = this._locale;
				lang = this._lang;
				pluralFn = this._pluralFn;
			} else {
				lang = getLang(locale);
				pluralFn = getPluralFn(lang);
			}
			var translations = this._translations[locale];
			if (!translations) {
				locale = this._findFallbackLocale(locale, lang);
				lang = getLang(locale);
				pluralFn = getPluralFn(lang);
				translations = this._translations[locale];
			}
			if (translations && translations[key] && pluralFn) {
				var index = pluralFn(n);
				result = translations[key][index];
				if (result === null || result === undefined) {
					result = key;
				}
			}
			return result;
		};
		_proto.addData = function addData(data) {
			var parsed;
			try {
				parsed = this._parser.parse(data);
			} catch (err) {
				console.error(err);
				return;
			}
			for (var i = 0, len = parsed.length; i < len; i++) {
				var entry = parsed[i];
				var locale = entry.info.locale;
				var messages = entry.messages;
				if (!this._translations[locale]) {
					this._translations[locale] = {};
					var lang = getLang(locale);
					if (!this._availableLangs[lang]) {
						this._availableLangs[lang] = locale;
					}
				}
				Object.assign(this._translations[locale], messages);
				this.fire('data:add', locale, messages);
			}
		};
		_proto.removeData = function removeData(data) {
			var parsed;
			try {
				parsed = this._parser.parse(data);
			} catch (err) {
				console.error(err);
				return;
			}
			for (var i = 0, len = parsed.length; i < len; i++) {
				var entry = parsed[i];
				var locale = entry.info.locale;
				var translations = this._translations[locale];
				if (!translations) continue;
				var messages = entry.messages;
				for (var key in messages) {
					delete translations[key];
				}
				if (Object.keys(translations).length === 0) {
					delete this._translations[locale];
					delete this._availableLangs[getLang(locale)];
				}
				this.fire('data:remove', locale, messages);
			}
		};
		_proto.destroy = function destroy() {
			this._translations = null;
			this._availableLangs = null;
			this._assets = null;
			this._parser = null;
			this.off();
		};
		_proto._findFallbackLocale = function _findFallbackLocale(locale, lang) {
			var result = DEFAULT_LOCALE_FALLBACKS[locale];
			if (result && this._translations[result]) {
				return result;
			}
			result = DEFAULT_LOCALE_FALLBACKS[lang];
			if (result && this._translations[result]) {
				return result;
			}
			result = this._availableLangs[lang];
			if (result && this._translations[result]) {
				return result;
			}
			return DEFAULT_LOCALE;
		};
		_proto._onAssetAdd = function _onAssetAdd(asset) {
			asset.on('load', this._onAssetLoad, this);
			asset.on('change', this._onAssetChange, this);
			asset.on('remove', this._onAssetRemove, this);
			asset.on('unload', this._onAssetUnload, this);
			if (asset.resource) {
				this._onAssetLoad(asset);
			}
		};
		_proto._onAssetLoad = function _onAssetLoad(asset) {
			this.addData(asset.resource);
		};
		_proto._onAssetChange = function _onAssetChange(asset) {
			if (asset.resource) {
				this.addData(asset.resource);
			}
		};
		_proto._onAssetRemove = function _onAssetRemove(asset) {
			asset.off('load', this._onAssetLoad, this);
			asset.off('change', this._onAssetChange, this);
			asset.off('remove', this._onAssetRemove, this);
			asset.off('unload', this._onAssetUnload, this);
			if (asset.resource) {
				this.removeData(asset.resource);
			}
			this._app.assets.once('add:' + asset.id, this._onAssetAdd, this);
		};
		_proto._onAssetUnload = function _onAssetUnload(asset) {
			if (asset.resource) {
				this.removeData(asset.resource);
			}
		};
		_createClass(I18n, [{
			key: "assets",
			get: function get() {
				return this._assets;
			},
			set: function set(value) {
				var index = {};
				for (var _i = 0, len = value.length; _i < len; _i++) {
					var id = value[_i] instanceof Asset ? value[_i].id : value[_i];
					index[id] = true;
				}
				var i = this._assets.length;
				while (i--) {
					var _id = this._assets[i];
					if (!index[_id]) {
						this._app.assets.off('add:' + _id, this._onAssetAdd, this);
						var asset = this._app.assets.get(_id);
						if (asset) {
							this._onAssetRemove(asset);
						}
						this._assets.splice(i, 1);
					}
				}
				for (var _id2 in index) {
					var idNum = parseInt(_id2, 10);
					if (this._assets.indexOf(idNum) !== -1) continue;
					this._assets.push(idNum);
					var _asset = this._app.assets.get(idNum);
					if (!_asset) {
						this._app.assets.once('add:' + idNum, this._onAssetAdd, this);
					} else {
						this._onAssetAdd(_asset);
					}
				}
			}
		}, {
			key: "locale",
			get: function get() {
				return this._locale;
			},
			set: function set(value) {
				if (this._locale === value) {
					return;
				}
				var lang = getLang(value);
				if (lang === 'in') {
					lang = 'id';
					value = replaceLang(value, lang);
					if (this._locale === value) {
						return;
					}
				}
				var old = this._locale;
				this._locale = value;
				this._lang = lang;
				this._pluralFn = getPluralFn(this._lang);
				this.fire('set:locale', value, old);
			}
		}]);
		return I18n;
	}(EventHandler);

	var ScriptRegistry = function (_EventHandler) {
		_inheritsLoose(ScriptRegistry, _EventHandler);
		function ScriptRegistry(app) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this.app = app;
			_this._scripts = {};
			_this._list = [];
			return _this;
		}
		var _proto = ScriptRegistry.prototype;
		_proto.destroy = function destroy() {
			this.app = null;
			this.off();
		};
		_proto.add = function add(script) {
			var _this2 = this;
			var scriptName = script.__name;
			if (this._scripts.hasOwnProperty(scriptName)) {
				setTimeout(function () {
					if (script.prototype.swap) {
						var old = _this2._scripts[scriptName];
						var ind = _this2._list.indexOf(old);
						_this2._list[ind] = script;
						_this2._scripts[scriptName] = script;
						_this2.fire('swap', scriptName, script);
						_this2.fire('swap:' + scriptName, script);
					} else {
						console.warn("script registry already has '" + scriptName + "' script, define 'swap' method for new script type to enable code hot swapping");
					}
				});
				return false;
			}
			this._scripts[scriptName] = script;
			this._list.push(script);
			this.fire('add', scriptName, script);
			this.fire('add:' + scriptName, script);
			setTimeout(function () {
				if (!_this2._scripts.hasOwnProperty(scriptName)) return;
				if (!_this2.app || !_this2.app.systems || !_this2.app.systems.script) {
					return;
				}
				var components = _this2.app.systems.script._components;
				var attributes;
				var scriptInstances = [];
				var scriptInstancesInitialized = [];
				for (components.loopIndex = 0; components.loopIndex < components.length; components.loopIndex++) {
					var component = components.items[components.loopIndex];
					if (component._scriptsIndex[scriptName] && component._scriptsIndex[scriptName].awaiting) {
						if (component._scriptsData && component._scriptsData[scriptName]) attributes = component._scriptsData[scriptName].attributes;
						var scriptInstance = component.create(scriptName, {
							preloading: true,
							ind: component._scriptsIndex[scriptName].ind,
							attributes: attributes
						});
						if (scriptInstance) scriptInstances.push(scriptInstance);
					}
				}
				for (var i = 0; i < scriptInstances.length; i++) scriptInstances[i].__initializeAttributes();
				for (var _i = 0; _i < scriptInstances.length; _i++) {
					if (scriptInstances[_i].enabled) {
						scriptInstances[_i]._initialized = true;
						scriptInstancesInitialized.push(scriptInstances[_i]);
						if (scriptInstances[_i].initialize) scriptInstances[_i].initialize();
					}
				}
				for (var _i2 = 0; _i2 < scriptInstancesInitialized.length; _i2++) {
					if (!scriptInstancesInitialized[_i2].enabled || scriptInstancesInitialized[_i2]._postInitialized) {
						continue;
					}
					scriptInstancesInitialized[_i2]._postInitialized = true;
					if (scriptInstancesInitialized[_i2].postInitialize) scriptInstancesInitialized[_i2].postInitialize();
				}
			});
			return true;
		};
		_proto.remove = function remove(nameOrType) {
			var scriptType = nameOrType;
			var scriptName = nameOrType;
			if (typeof scriptName !== 'string') {
				scriptName = scriptType.__name;
			} else {
				scriptType = this.get(scriptName);
			}
			if (this.get(scriptName) !== scriptType) return false;
			delete this._scripts[scriptName];
			var ind = this._list.indexOf(scriptType);
			this._list.splice(ind, 1);
			this.fire('remove', scriptName, scriptType);
			this.fire('remove:' + scriptName, scriptType);
			return true;
		};
		_proto.get = function get(name) {
			return this._scripts[name] || null;
		};
		_proto.has = function has(nameOrType) {
			if (typeof nameOrType === 'string') {
				return this._scripts.hasOwnProperty(nameOrType);
			}
			if (!nameOrType) return false;
			var scriptName = nameOrType.__name;
			return this._scripts[scriptName] === nameOrType;
		};
		_proto.list = function list() {
			return this._list;
		};
		return ScriptRegistry;
	}(EventHandler);

	var _enableList = [];
	var Entity = function (_GraphNode) {
		_inheritsLoose(Entity, _GraphNode);
		function Entity(name, app) {
			var _this;
			if (app === void 0) {
				app = getApplication();
			}
			_this = _GraphNode.call(this, name) || this;
			_this.anim = void 0;
			_this.animation = void 0;
			_this.audiolistener = void 0;
			_this.button = void 0;
			_this.camera = void 0;
			_this.collision = void 0;
			_this.element = void 0;
			_this.layoutchild = void 0;
			_this.layoutgroup = void 0;
			_this.light = void 0;
			_this.model = void 0;
			_this.particlesystem = void 0;
			_this.render = void 0;
			_this.rigidbody = void 0;
			_this.screen = void 0;
			_this.script = void 0;
			_this.scrollbar = void 0;
			_this.scrollview = void 0;
			_this.sound = void 0;
			_this.sprite = void 0;
			_this.c = {};
			_this._app = void 0;
			_this._destroying = false;
			_this._guid = null;
			_this._template = false;
			_this._app = app;
			return _this;
		}
		var _proto = Entity.prototype;
		_proto.addComponent = function addComponent(type, data) {
			var system = this._app.systems[type];
			if (!system) {
				return null;
			}
			if (this.c[type]) {
				return null;
			}
			return system.addComponent(this, data);
		};
		_proto.removeComponent = function removeComponent(type) {
			var system = this._app.systems[type];
			if (!system) {
				return;
			}
			if (!this.c[type]) {
				return;
			}
			system.removeComponent(this);
		};
		_proto.findComponent = function findComponent(type) {
			var entity = this.findOne(function (node) {
				return node.c && node.c[type];
			});
			return entity && entity.c[type];
		};
		_proto.findComponents = function findComponents(type) {
			var entities = this.find(function (node) {
				return node.c && node.c[type];
			});
			return entities.map(function (entity) {
				return entity.c[type];
			});
		};
		_proto.getGuid = function getGuid() {
			if (!this._guid) {
				this.setGuid(guid.create());
			}
			return this._guid;
		};
		_proto.setGuid = function setGuid(guid) {
			var index = this._app._entityIndex;
			if (this._guid) {
				delete index[this._guid];
			}
			this._guid = guid;
			index[this._guid] = this;
		};
		_proto._notifyHierarchyStateChanged = function _notifyHierarchyStateChanged(node, enabled) {
			var enableFirst = false;
			if (node === this && _enableList.length === 0) enableFirst = true;
			node._beingEnabled = true;
			node._onHierarchyStateChanged(enabled);
			if (node._onHierarchyStatePostChanged) _enableList.push(node);
			var c = node._children;
			for (var i = 0, len = c.length; i < len; i++) {
				if (c[i]._enabled) this._notifyHierarchyStateChanged(c[i], enabled);
			}
			node._beingEnabled = false;
			if (enableFirst) {
				for (var _i = 0; _i < _enableList.length; _i++) {
					_enableList[_i]._onHierarchyStatePostChanged();
				}
				_enableList.length = 0;
			}
		};
		_proto._onHierarchyStateChanged = function _onHierarchyStateChanged(enabled) {
			_GraphNode.prototype._onHierarchyStateChanged.call(this, enabled);
			var components = this.c;
			for (var type in components) {
				if (components.hasOwnProperty(type)) {
					var component = components[type];
					if (component.enabled) {
						if (enabled) {
							component.onEnable();
						} else {
							component.onDisable();
						}
					}
				}
			}
		};
		_proto._onHierarchyStatePostChanged = function _onHierarchyStatePostChanged() {
			var components = this.c;
			for (var type in components) {
				if (components.hasOwnProperty(type)) components[type].onPostStateChange();
			}
		};
		_proto.findByGuid = function findByGuid(guid) {
			if (this._guid === guid) return this;
			var e = this._app._entityIndex[guid];
			if (e && (e === this || e.isDescendantOf(this))) {
				return e;
			}
			return null;
		};
		_proto.destroy = function destroy() {
			this._destroying = true;
			for (var name in this.c) {
				this.c[name].enabled = false;
			}
			for (var _name in this.c) {
				this.c[_name].system.removeComponent(this);
			}
			_GraphNode.prototype.destroy.call(this);
			if (this._guid) {
				delete this._app._entityIndex[this._guid];
			}
			this._destroying = false;
		};
		_proto.clone = function clone() {
			var duplicatedIdsMap = {};
			var clone = this._cloneRecursively(duplicatedIdsMap);
			duplicatedIdsMap[this.getGuid()] = clone;
			resolveDuplicatedEntityReferenceProperties(this, this, clone, duplicatedIdsMap);
			return clone;
		};
		_proto._cloneRecursively = function _cloneRecursively(duplicatedIdsMap) {
			var clone = new this.constructor(undefined, this._app);
			_GraphNode.prototype._cloneInternal.call(this, clone);
			for (var type in this.c) {
				var component = this.c[type];
				component.system.cloneComponent(this, clone);
			}
			for (var i = 0; i < this._children.length; i++) {
				var oldChild = this._children[i];
				if (oldChild instanceof Entity) {
					var newChild = oldChild._cloneRecursively(duplicatedIdsMap);
					clone.addChild(newChild);
					duplicatedIdsMap[oldChild.getGuid()] = newChild;
				}
			}
			return clone;
		};
		return Entity;
	}(GraphNode);
	function resolveDuplicatedEntityReferenceProperties(oldSubtreeRoot, oldEntity, newEntity, duplicatedIdsMap) {
		if (oldEntity instanceof Entity) {
			var components = oldEntity.c;
			for (var componentName in components) {
				var component = components[componentName];
				var entityProperties = component.system.getPropertiesOfType('entity');
				for (var i = 0, len = entityProperties.length; i < len; i++) {
					var propertyDescriptor = entityProperties[i];
					var propertyName = propertyDescriptor.name;
					var oldEntityReferenceId = component[propertyName];
					var entityIsWithinOldSubtree = !!oldSubtreeRoot.findByGuid(oldEntityReferenceId);
					if (entityIsWithinOldSubtree) {
						var newEntityReferenceId = duplicatedIdsMap[oldEntityReferenceId].getGuid();
						if (newEntityReferenceId) {
							newEntity.c[componentName][propertyName] = newEntityReferenceId;
						}
					}
				}
			}
			if (components.script && !newEntity._app.useLegacyScriptAttributeCloning) {
				newEntity.script.resolveDuplicatedEntityReferenceProperties(components.script, duplicatedIdsMap);
			}
			if (components.render) {
				newEntity.render.resolveDuplicatedEntityReferenceProperties(components.render, duplicatedIdsMap);
			}
			if (components.anim) {
				newEntity.anim.resolveDuplicatedEntityReferenceProperties(components.anim, duplicatedIdsMap);
			}
			var _old = oldEntity.children.filter(function (e) {
				return e instanceof Entity;
			});
			var _new = newEntity.children.filter(function (e) {
				return e instanceof Entity;
			});
			for (var _i2 = 0, _len = _old.length; _i2 < _len; _i2++) {
				resolveDuplicatedEntityReferenceProperties(oldSubtreeRoot, _old[_i2], _new[_i2], duplicatedIdsMap);
			}
		}
	}

	var SceneRegistryItem = function () {
		function SceneRegistryItem(name, url) {
			this.name = void 0;
			this.url = void 0;
			this.data = null;
			this._loading = false;
			this._onLoadedCallbacks = [];
			this.name = name;
			this.url = url;
		}
		_createClass(SceneRegistryItem, [{
			key: "loaded",
			get: function get() {
				return !!this.data;
			}
		}, {
			key: "loading",
			get: function get() {
				return this._loading;
			}
		}]);
		return SceneRegistryItem;
	}();

	var SceneRegistry = function () {
		function SceneRegistry(app) {
			this._app = void 0;
			this._list = [];
			this._index = {};
			this._urlIndex = {};
			this._app = app;
		}
		var _proto = SceneRegistry.prototype;
		_proto.destroy = function destroy() {
			this._app = null;
		};
		_proto.list = function list() {
			return this._list;
		};
		_proto.add = function add(name, url) {
			if (this._index.hasOwnProperty(name)) {
				return false;
			}
			var item = new SceneRegistryItem(name, url);
			var i = this._list.push(item);
			this._index[item.name] = i - 1;
			this._urlIndex[item.url] = i - 1;
			return true;
		};
		_proto.find = function find(name) {
			if (this._index.hasOwnProperty(name)) {
				return this._list[this._index[name]];
			}
			return null;
		};
		_proto.findByUrl = function findByUrl(url) {
			if (this._urlIndex.hasOwnProperty(url)) {
				return this._list[this._urlIndex[url]];
			}
			return null;
		};
		_proto.remove = function remove(name) {
			if (this._index.hasOwnProperty(name)) {
				var idx = this._index[name];
				var item = this._list[idx];
				delete this._urlIndex[item.url];
				delete this._index[name];
				this._list.splice(idx, 1);
				for (var i = 0; i < this._list.length; i++) {
					item = this._list[i];
					this._index[item.name] = i;
					this._urlIndex[item.url] = i;
				}
			}
		};
		_proto._loadSceneData = function _loadSceneData(sceneItem, storeInCache, callback) {
			var app = this._app;
			var url = sceneItem;
			if (typeof sceneItem === 'string') {
				sceneItem = this.findByUrl(url) || this.find(url) || new SceneRegistryItem('Untitled', url);
			}
			url = sceneItem.url;
			if (!url) {
				callback("Cannot find scene to load");
				return;
			}
			if (sceneItem.loaded) {
				callback(null, sceneItem);
				return;
			}
			if (app.assets && app.assets.prefix && !ABSOLUTE_URL.test(url)) {
				url = path.join(app.assets.prefix, url);
			}
			sceneItem._onLoadedCallbacks.push(callback);
			if (!sceneItem._loading) {
				var handler = app.loader.getHandler("hierarchy");
				handler.load(url, function (err, data) {
					sceneItem.data = data;
					sceneItem._loading = false;
					for (var i = 0; i < sceneItem._onLoadedCallbacks.length; i++) {
						sceneItem._onLoadedCallbacks[i](err, sceneItem);
					}
					if (!storeInCache) {
						sceneItem.data = null;
					}
					sceneItem._onLoadedCallbacks.length = 0;
				});
			}
			sceneItem._loading = true;
		};
		_proto.loadSceneData = function loadSceneData(sceneItem, callback) {
			this._loadSceneData(sceneItem, true, callback);
		};
		_proto.unloadSceneData = function unloadSceneData(sceneItem) {
			if (typeof sceneItem === 'string') {
				sceneItem = this.findByUrl(sceneItem);
			}
			if (sceneItem) {
				sceneItem.data = null;
			}
		};
		_proto._loadSceneHierarchy = function _loadSceneHierarchy(sceneItem, onBeforeAddHierarchy, callback) {
			var _this = this;
			this._loadSceneData(sceneItem, false, function (err, sceneItem) {
				if (err) {
					if (callback) {
						callback(err);
					}
					return;
				}
				if (onBeforeAddHierarchy) {
					onBeforeAddHierarchy(sceneItem);
				}
				var app = _this._app;
				var _loaded = function _loaded() {
					var handler = app.loader.getHandler("hierarchy");
					app.systems.script.preloading = true;
					var entity = handler.open(sceneItem.url, sceneItem.data);
					app.systems.script.preloading = false;
					app.loader.clearCache(sceneItem.url, "hierarchy");
					app.root.addChild(entity);
					app.systems.fire('initialize', entity);
					app.systems.fire('postInitialize', entity);
					app.systems.fire('postPostInitialize', entity);
					if (callback) callback(null, entity);
				};
				app._preloadScripts(sceneItem.data, _loaded);
			});
		};
		_proto.loadSceneHierarchy = function loadSceneHierarchy(sceneItem, callback) {
			this._loadSceneHierarchy(sceneItem, null, callback);
		};
		_proto.loadSceneSettings = function loadSceneSettings(sceneItem, callback) {
			var _this2 = this;
			this._loadSceneData(sceneItem, false, function (err, sceneItem) {
				if (!err) {
					_this2._app.applySceneSettings(sceneItem.data.settings);
					if (callback) {
						callback(null);
					}
				} else {
					if (callback) {
						callback(err);
					}
				}
			});
		};
		_proto.changeScene = function changeScene(sceneItem, callback) {
			var app = this._app;
			var onBeforeAddHierarchy = function onBeforeAddHierarchy(sceneItem) {
				var children = app.root.children;
				while (children.length) {
					children[0].destroy();
				}
				app.applySceneSettings(sceneItem.data.settings);
			};
			this._loadSceneHierarchy(sceneItem, onBeforeAddHierarchy, callback);
		};
		_proto.loadScene = function loadScene(url, callback) {
			var _this3 = this;
			var app = this._app;
			var handler = app.loader.getHandler("scene");
			if (app.assets && app.assets.prefix && !ABSOLUTE_URL.test(url)) {
				url = path.join(app.assets.prefix, url);
			}
			handler.load(url, function (err, data) {
				if (!err) {
					var _loaded = function _loaded() {
						app.systems.script.preloading = true;
						var scene = handler.open(url, data);
						var sceneItem = _this3.findByUrl(url);
						if (sceneItem && !sceneItem.loaded) {
							sceneItem.data = data;
						}
						app.systems.script.preloading = false;
						app.loader.clearCache(url, "scene");
						app.loader.patch({
							resource: scene,
							type: "scene"
						}, app.assets);
						app.root.addChild(scene.root);
						if (app.systems.rigidbody && typeof Ammo !== 'undefined') {
							app.systems.rigidbody.gravity.set(scene._gravity.x, scene._gravity.y, scene._gravity.z);
						}
						if (callback) {
							callback(null, scene);
						}
					};
					app._preloadScripts(data, _loaded);
				} else {
					if (callback) {
						callback(err);
					}
				}
			});
		};
		return SceneRegistry;
	}();

	var ApplicationStats = function () {
		function ApplicationStats(device) {
			this.frame = {
				fps: 0,
				ms: 0,
				dt: 0,
				updateStart: 0,
				updateTime: 0,
				renderStart: 0,
				renderTime: 0,
				physicsStart: 0,
				physicsTime: 0,
				cullTime: 0,
				sortTime: 0,
				skinTime: 0,
				morphTime: 0,
				instancingTime: 0,
				triangles: 0,
				otherPrimitives: 0,
				shaders: 0,
				materials: 0,
				cameras: 0,
				shadowMapUpdates: 0,
				shadowMapTime: 0,
				depthMapTime: 0,
				forwardTime: 0,
				lightClustersTime: 0,
				lightClusters: 0,
				_timeToCountFrames: 0,
				_fpsAccum: 0
			};
			this.drawCalls = {
				forward: 0,
				depth: 0,
				shadow: 0,
				immediate: 0,
				misc: 0,
				total: 0,
				skinned: 0,
				instanced: 0,
				removedByInstancing: 0
			};
			this.misc = {
				renderTargetCreationTime: 0
			};
			this.particles = {
				updatesPerFrame: 0,
				_updatesPerFrame: 0,
				frameTime: 0,
				_frameTime: 0
			};
			this.shaders = device._shaderStats;
			this.vram = device._vram;
			Object.defineProperty(this.vram, 'totalUsed', {
				get: function get() {
					return this.tex + this.vb + this.ib;
				}
			});
			Object.defineProperty(this.vram, 'geom', {
				get: function get() {
					return this.vb + this.ib;
				}
			});
		}
		_createClass(ApplicationStats, [{
			key: "scene",
			get: function get() {
				return getApplication().scene._stats;
			}
		}, {
			key: "lightmapper",
			get: function get() {
				var _getApplication$light;
				return (_getApplication$light = getApplication().lightmapper) == null ? void 0 : _getApplication$light.stats;
			}
		}, {
			key: "batcher",
			get: function get() {
				var batcher = getApplication()._batcher;
				return batcher ? batcher._stats : null;
			}
		}]);
		return ApplicationStats;
	}();

	var Progress = function () {
		function Progress(length) {
			this.length = length;
			this.count = 0;
		}
		var _proto = Progress.prototype;
		_proto.inc = function inc() {
			this.count++;
		};
		_proto.done = function done() {
			return this.count === this.length;
		};
		return Progress;
	}();
	exports.app = null;
	var AppBase = function (_EventHandler) {
		_inheritsLoose(AppBase, _EventHandler);
		function AppBase(canvas) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this.frameRequestId = void 0;
			AppBase._applications[canvas.id] = _assertThisInitialized(_this);
			setApplication(_assertThisInitialized(_this));
			exports.app = _assertThisInitialized(_this);
			_this._destroyRequested = false;
			_this._inFrameUpdate = false;
			_this._time = 0;
			_this.timeScale = 1;
			_this.maxDeltaTime = 0.1;
			_this.frame = 0;
			_this.autoRender = true;
			_this.renderNextFrame = false;
			_this.useLegacyScriptAttributeCloning = script.legacy;
			_this._librariesLoaded = false;
			_this._fillMode = FILLMODE_KEEP_ASPECT;
			_this._resolutionMode = RESOLUTION_FIXED;
			_this._allowResize = true;
			_this.context = _assertThisInitialized(_this);
			return _this;
		}
		var _proto2 = AppBase.prototype;
		_proto2.init = function init(appOptions) {
			var _this2 = this;
			var device = appOptions.graphicsDevice;
			this.graphicsDevice = device;
			GraphicsDeviceAccess.set(device);
			this._initDefaultMaterial();
			this._initProgramLibrary();
			this.stats = new ApplicationStats(device);
			this._soundManager = appOptions.soundManager;
			this.loader = new ResourceLoader(this);
			LightsBuffer.init(device);
			this._entityIndex = {};
			this.scene = new Scene(device);
			this._registerSceneImmediate(this.scene);
			this.root = new Entity();
			this.root._enabledInHierarchy = true;
			this.assets = new AssetRegistry(this.loader);
			if (appOptions.assetPrefix) this.assets.prefix = appOptions.assetPrefix;
			this.bundles = new BundleRegistry(this.assets);
			this.enableBundles = typeof TextDecoder !== 'undefined';
			this.scriptsOrder = appOptions.scriptsOrder || [];
			this.scripts = new ScriptRegistry(this);
			this.i18n = new I18n(this);
			this.scenes = new SceneRegistry(this);
			this.defaultLayerWorld = new Layer({
				name: "World",
				id: LAYERID_WORLD
			});
			this.defaultLayerDepth = new Layer({
				name: "Depth",
				id: LAYERID_DEPTH,
				enabled: false,
				opaqueSortMode: SORTMODE_NONE
			});
			this.defaultLayerSkybox = new Layer({
				name: "Skybox",
				id: LAYERID_SKYBOX,
				opaqueSortMode: SORTMODE_NONE
			});
			this.defaultLayerUi = new Layer({
				name: "UI",
				id: LAYERID_UI,
				transparentSortMode: SORTMODE_MANUAL
			});
			this.defaultLayerImmediate = new Layer({
				name: "Immediate",
				id: LAYERID_IMMEDIATE,
				opaqueSortMode: SORTMODE_NONE
			});
			var defaultLayerComposition = new LayerComposition("default");
			defaultLayerComposition.pushOpaque(this.defaultLayerWorld);
			defaultLayerComposition.pushOpaque(this.defaultLayerDepth);
			defaultLayerComposition.pushOpaque(this.defaultLayerSkybox);
			defaultLayerComposition.pushTransparent(this.defaultLayerWorld);
			defaultLayerComposition.pushOpaque(this.defaultLayerImmediate);
			defaultLayerComposition.pushTransparent(this.defaultLayerImmediate);
			defaultLayerComposition.pushTransparent(this.defaultLayerUi);
			this.scene.layers = defaultLayerComposition;
			AreaLightLuts.createPlaceholder(device);
			this.renderer = new ForwardRenderer(device);
			this.renderer.scene = this.scene;
			this.frameGraph = new FrameGraph();
			this.lightmapper = null;
			if (appOptions.lightmapper) {
				this.lightmapper = new appOptions.lightmapper(device, this.root, this.scene, this.renderer, this.assets);
				this.once('prerender', this._firstBake, this);
			}
			this._batcher = null;
			if (appOptions.batchManager) {
				this._batcher = new appOptions.batchManager(device, this.root, this.scene);
				this.once('prerender', this._firstBatch, this);
			}
			this.keyboard = appOptions.keyboard || null;
			this.mouse = appOptions.mouse || null;
			this.touch = appOptions.touch || null;
			this.gamepads = appOptions.gamepads || null;
			this.elementInput = appOptions.elementInput || null;
			if (this.elementInput) this.elementInput.app = this;
			this.xr = appOptions.xr ? new appOptions.xr(this) : null;
			if (this.elementInput) this.elementInput.attachSelectEvents();
			this._inTools = false;
			this._skyboxAsset = null;
			this._scriptPrefix = appOptions.scriptPrefix || '';
			if (this.enableBundles) {
				this.loader.addHandler("bundle", new BundleHandler(this));
			}
			appOptions.resourceHandlers.forEach(function (resourceHandler) {
				var handler = new resourceHandler(_this2);
				_this2.loader.addHandler(handler.handlerType, handler);
			});
			this.systems = new ComponentSystemRegistry();
			appOptions.componentSystems.forEach(function (componentSystem) {
				_this2.systems.add(new componentSystem(_this2));
			});
			this._visibilityChangeHandler = this.onVisibilityChange.bind(this);
			if (typeof document !== 'undefined') {
				if (document.hidden !== undefined) {
					this._hiddenAttr = 'hidden';
					document.addEventListener('visibilitychange', this._visibilityChangeHandler, false);
				} else if (document.mozHidden !== undefined) {
					this._hiddenAttr = 'mozHidden';
					document.addEventListener('mozvisibilitychange', this._visibilityChangeHandler, false);
				} else if (document.msHidden !== undefined) {
					this._hiddenAttr = 'msHidden';
					document.addEventListener('msvisibilitychange', this._visibilityChangeHandler, false);
				} else if (document.webkitHidden !== undefined) {
					this._hiddenAttr = 'webkitHidden';
					document.addEventListener('webkitvisibilitychange', this._visibilityChangeHandler, false);
				}
			}
			this.tick = makeTick(this);
		};
		AppBase.getApplication = function getApplication$1(id) {
			return id ? AppBase._applications[id] : getApplication();
		};
		_proto2._initDefaultMaterial = function _initDefaultMaterial() {
			var material = new StandardMaterial();
			material.name = "Default Material";
			material.shadingModel = SPECULAR_BLINN;
			setDefaultMaterial(this.graphicsDevice, material);
		};
		_proto2._initProgramLibrary = function _initProgramLibrary() {
			var library = new ProgramLibrary(this.graphicsDevice, new StandardMaterial());
			setProgramLibrary(this.graphicsDevice, library);
		};
		_proto2.configure = function configure(url, callback) {
			var _this3 = this;
			http.get(url, function (err, response) {
				if (err) {
					callback(err);
					return;
				}
				var props = response.application_properties;
				var scenes = response.scenes;
				var assets = response.assets;
				_this3._parseApplicationProperties(props, function (err) {
					_this3._parseScenes(scenes);
					_this3._parseAssets(assets);
					if (!err) {
						callback(null);
					} else {
						callback(err);
					}
				});
			});
		};
		_proto2.preload = function preload(callback) {
			var _this4 = this;
			this.fire("preload:start");
			var assets = this.assets.list({
				preload: true
			});
			var progress = new Progress(assets.length);
			var _done = false;
			var done = function done() {
				if (!_this4.graphicsDevice) {
					return;
				}
				if (!_done && progress.done()) {
					_done = true;
					_this4.fire("preload:end");
					callback();
				}
			};
			var total = assets.length;
			if (progress.length) {
				var onAssetLoad = function onAssetLoad(asset) {
					progress.inc();
					_this4.fire('preload:progress', progress.count / total);
					if (progress.done()) done();
				};
				var onAssetError = function onAssetError(err, asset) {
					progress.inc();
					_this4.fire('preload:progress', progress.count / total);
					if (progress.done()) done();
				};
				for (var i = 0; i < assets.length; i++) {
					if (!assets[i].loaded) {
						assets[i].once('load', onAssetLoad);
						assets[i].once('error', onAssetError);
						this.assets.load(assets[i]);
					} else {
						progress.inc();
						this.fire("preload:progress", progress.count / total);
						if (progress.done()) done();
					}
				}
			} else {
				done();
			}
		};
		_proto2._preloadScripts = function _preloadScripts(sceneData, callback) {
			var _this5 = this;
			if (!script.legacy) {
				callback();
				return;
			}
			this.systems.script.preloading = true;
			var scripts = this._getScriptReferences(sceneData);
			var l = scripts.length;
			var progress = new Progress(l);
			var regex = /^http(s)?:\/\//;
			if (l) {
				var onLoad = function onLoad(err, ScriptType) {
					if (err) console.error(err);
					progress.inc();
					if (progress.done()) {
						_this5.systems.script.preloading = false;
						callback();
					}
				};
				for (var i = 0; i < l; i++) {
					var scriptUrl = scripts[i];
					if (!regex.test(scriptUrl.toLowerCase()) && this._scriptPrefix) scriptUrl = path.join(this._scriptPrefix, scripts[i]);
					this.loader.load(scriptUrl, 'script', onLoad);
				}
			} else {
				this.systems.script.preloading = false;
				callback();
			}
		};
		_proto2._parseApplicationProperties = function _parseApplicationProperties(props, callback) {
			if (typeof props.maxAssetRetries === 'number' && props.maxAssetRetries > 0) {
				this.loader.enableRetry(props.maxAssetRetries);
			}
			if (!props.useDevicePixelRatio) props.useDevicePixelRatio = props.use_device_pixel_ratio;
			if (!props.resolutionMode) props.resolutionMode = props.resolution_mode;
			if (!props.fillMode) props.fillMode = props.fill_mode;
			this._width = props.width;
			this._height = props.height;
			if (props.useDevicePixelRatio) {
				this.graphicsDevice.maxPixelRatio = window.devicePixelRatio;
			}
			this.setCanvasResolution(props.resolutionMode, this._width, this._height);
			this.setCanvasFillMode(props.fillMode, this._width, this._height);
			if (props.layers && props.layerOrder) {
				var composition = new LayerComposition("application");
				var layers = {};
				for (var key in props.layers) {
					var data = props.layers[key];
					data.id = parseInt(key, 10);
					data.enabled = data.id !== LAYERID_DEPTH;
					layers[key] = new Layer(data);
				}
				for (var i = 0, len = props.layerOrder.length; i < len; i++) {
					var sublayer = props.layerOrder[i];
					var layer = layers[sublayer.layer];
					if (!layer) continue;
					if (sublayer.transparent) {
						composition.pushTransparent(layer);
					} else {
						composition.pushOpaque(layer);
					}
					composition.subLayerEnabled[i] = sublayer.enabled;
				}
				this.scene.layers = composition;
			}
			if (props.batchGroups) {
				var batcher = this.batcher;
				if (batcher) {
					for (var _i = 0, _len = props.batchGroups.length; _i < _len; _i++) {
						var grp = props.batchGroups[_i];
						batcher.addGroup(grp.name, grp.dynamic, grp.maxAabbSize, grp.id, grp.layers);
					}
				}
			}
			if (props.i18nAssets) {
				this.i18n.assets = props.i18nAssets;
			}
			this._loadLibraries(props.libraries, callback);
		};
		_proto2._loadLibraries = function _loadLibraries(urls, callback) {
			var _this6 = this;
			var len = urls.length;
			var count = len;
			var regex = /^http(s)?:\/\//;
			if (len) {
				var onLoad = function onLoad(err, script) {
					count--;
					if (err) {
						callback(err);
					} else if (count === 0) {
						_this6.onLibrariesLoaded();
						callback(null);
					}
				};
				for (var i = 0; i < len; ++i) {
					var url = urls[i];
					if (!regex.test(url.toLowerCase()) && this._scriptPrefix) url = path.join(this._scriptPrefix, url);
					this.loader.load(url, 'script', onLoad);
				}
			} else {
				this.onLibrariesLoaded();
				callback(null);
			}
		};
		_proto2._parseScenes = function _parseScenes(scenes) {
			if (!scenes) return;
			for (var i = 0; i < scenes.length; i++) {
				this.scenes.add(scenes[i].name, scenes[i].url);
			}
		};
		_proto2._parseAssets = function _parseAssets(assets) {
			var list = [];
			var scriptsIndex = {};
			var bundlesIndex = {};
			if (!script.legacy) {
				for (var i = 0; i < this.scriptsOrder.length; i++) {
					var id = this.scriptsOrder[i];
					if (!assets[id]) continue;
					scriptsIndex[id] = true;
					list.push(assets[id]);
				}
				if (this.enableBundles) {
					for (var _id in assets) {
						if (assets[_id].type === 'bundle') {
							bundlesIndex[_id] = true;
							list.push(assets[_id]);
						}
					}
				}
				for (var _id2 in assets) {
					if (scriptsIndex[_id2] || bundlesIndex[_id2]) continue;
					list.push(assets[_id2]);
				}
			} else {
				if (this.enableBundles) {
					for (var _id3 in assets) {
						if (assets[_id3].type === 'bundle') {
							bundlesIndex[_id3] = true;
							list.push(assets[_id3]);
						}
					}
				}
				for (var _id4 in assets) {
					if (bundlesIndex[_id4]) continue;
					list.push(assets[_id4]);
				}
			}
			for (var _i2 = 0; _i2 < list.length; _i2++) {
				var data = list[_i2];
				var asset = new Asset(data.name, data.type, data.file, data.data);
				asset.id = parseInt(data.id, 10);
				asset.preload = data.preload ? data.preload : false;
				asset.loaded = data.type === 'script' && data.data && data.data.loadingType > 0;
				asset.tags.add(data.tags);
				if (data.i18n) {
					for (var locale in data.i18n) {
						asset.addLocalizedAssetId(locale, data.i18n[locale]);
					}
				}
				this.assets.add(asset);
			}
		};
		_proto2._getScriptReferences = function _getScriptReferences(scene) {
			var priorityScripts = [];
			if (scene.settings.priority_scripts) {
				priorityScripts = scene.settings.priority_scripts;
			}
			var _scripts = [];
			var _index = {};
			for (var i = 0; i < priorityScripts.length; i++) {
				_scripts.push(priorityScripts[i]);
				_index[priorityScripts[i]] = true;
			}
			var entities = scene.entities;
			for (var key in entities) {
				if (!entities[key].components.script) {
					continue;
				}
				var scripts = entities[key].components.script.scripts;
				for (var _i3 = 0; _i3 < scripts.length; _i3++) {
					if (_index[scripts[_i3].url]) continue;
					_scripts.push(scripts[_i3].url);
					_index[scripts[_i3].url] = true;
				}
			}
			return _scripts;
		};
		_proto2.start = function start() {
			this.frame = 0;
			this.fire("start", {
				timestamp: now(),
				target: this
			});
			if (!this._librariesLoaded) {
				this.onLibrariesLoaded();
			}
			this.systems.fire('initialize', this.root);
			this.fire('initialize');
			this.systems.fire('postInitialize', this.root);
			this.systems.fire('postPostInitialize', this.root);
			this.fire('postinitialize');
			this.tick();
		};
		_proto2.inputUpdate = function inputUpdate(dt) {
			if (this.controller) {
				this.controller.update(dt);
			}
			if (this.mouse) {
				this.mouse.update();
			}
			if (this.keyboard) {
				this.keyboard.update();
			}
			if (this.gamepads) {
				this.gamepads.update();
			}
		};
		_proto2.update = function update(dt) {
			this.frame++;
			this.graphicsDevice.updateClientRect();
			if (script.legacy) this.systems.fire('fixedUpdate', 1.0 / 60.0);
			this.systems.fire(this._inTools ? 'toolsUpdate' : 'update', dt);
			this.systems.fire('animationUpdate', dt);
			this.systems.fire('postUpdate', dt);
			this.fire("update", dt);
			this.inputUpdate(dt);
		};
		_proto2.frameStart = function frameStart() {
			this.graphicsDevice.frameStart();
		};
		_proto2.frameEnd = function frameEnd() {
			this.graphicsDevice.frameEnd();
		};
		_proto2.render = function render() {
			this.fire('prerender');
			this.root.syncHierarchy();
			if (this._batcher) {
				this._batcher.updateAll();
			}
			this.renderComposition(this.scene.layers);
			this.fire('postrender');
		};
		_proto2.renderComposition = function renderComposition(layerComposition) {
			this.renderer.buildFrameGraph(this.frameGraph, layerComposition);
			this.frameGraph.render(this.graphicsDevice);
		};
		_proto2._fillFrameStatsBasic = function _fillFrameStatsBasic(now, dt, ms) {
			var stats = this.stats.frame;
			stats.dt = dt;
			stats.ms = ms;
			if (now > stats._timeToCountFrames) {
				stats.fps = stats._fpsAccum;
				stats._fpsAccum = 0;
				stats._timeToCountFrames = now + 1000;
			} else {
				stats._fpsAccum++;
			}
			this.stats.drawCalls.total = this.graphicsDevice._drawCallsPerFrame;
			this.graphicsDevice._drawCallsPerFrame = 0;
		};
		_proto2._fillFrameStats = function _fillFrameStats() {
			var stats = this.stats.frame;
			stats.cameras = this.renderer._camerasRendered;
			stats.materials = this.renderer._materialSwitches;
			stats.shaders = this.graphicsDevice._shaderSwitchesPerFrame;
			stats.shadowMapUpdates = this.renderer._shadowMapUpdates;
			stats.shadowMapTime = this.renderer._shadowMapTime;
			stats.depthMapTime = this.renderer._depthMapTime;
			stats.forwardTime = this.renderer._forwardTime;
			var prims = this.graphicsDevice._primsPerFrame;
			stats.triangles = prims[PRIMITIVE_TRIANGLES] / 3 + Math.max(prims[PRIMITIVE_TRISTRIP] - 2, 0) + Math.max(prims[PRIMITIVE_TRIFAN] - 2, 0);
			stats.cullTime = this.renderer._cullTime;
			stats.sortTime = this.renderer._sortTime;
			stats.skinTime = this.renderer._skinTime;
			stats.morphTime = this.renderer._morphTime;
			stats.lightClusters = this.renderer._lightClusters;
			stats.lightClustersTime = this.renderer._lightClustersTime;
			stats.otherPrimitives = 0;
			for (var i = 0; i < prims.length; i++) {
				if (i < PRIMITIVE_TRIANGLES) {
					stats.otherPrimitives += prims[i];
				}
				prims[i] = 0;
			}
			this.renderer._camerasRendered = 0;
			this.renderer._materialSwitches = 0;
			this.renderer._shadowMapUpdates = 0;
			this.graphicsDevice._shaderSwitchesPerFrame = 0;
			this.renderer._cullTime = 0;
			this.renderer._layerCompositionUpdateTime = 0;
			this.renderer._lightClustersTime = 0;
			this.renderer._sortTime = 0;
			this.renderer._skinTime = 0;
			this.renderer._morphTime = 0;
			this.renderer._shadowMapTime = 0;
			this.renderer._depthMapTime = 0;
			this.renderer._forwardTime = 0;
			stats = this.stats.drawCalls;
			stats.forward = this.renderer._forwardDrawCalls;
			stats.culled = this.renderer._numDrawCallsCulled;
			stats.depth = 0;
			stats.shadow = this.renderer._shadowDrawCalls;
			stats.skinned = this.renderer._skinDrawCalls;
			stats.immediate = 0;
			stats.instanced = 0;
			stats.removedByInstancing = 0;
			stats.misc = stats.total - (stats.forward + stats.shadow);
			this.renderer._depthDrawCalls = 0;
			this.renderer._shadowDrawCalls = 0;
			this.renderer._forwardDrawCalls = 0;
			this.renderer._numDrawCallsCulled = 0;
			this.renderer._skinDrawCalls = 0;
			this.renderer._immediateRendered = 0;
			this.renderer._instancedDrawCalls = 0;
			this.stats.misc.renderTargetCreationTime = this.graphicsDevice.renderTargetCreationTime;
			stats = this.stats.particles;
			stats.updatesPerFrame = stats._updatesPerFrame;
			stats.frameTime = stats._frameTime;
			stats._updatesPerFrame = 0;
			stats._frameTime = 0;
		};
		_proto2.setCanvasFillMode = function setCanvasFillMode(mode, width, height) {
			this._fillMode = mode;
			this.resizeCanvas(width, height);
		};
		_proto2.setCanvasResolution = function setCanvasResolution(mode, width, height) {
			this._resolutionMode = mode;
			if (mode === RESOLUTION_AUTO && width === undefined) {
				width = this.graphicsDevice.canvas.clientWidth;
				height = this.graphicsDevice.canvas.clientHeight;
			}
			this.graphicsDevice.resizeCanvas(width, height);
		};
		_proto2.isHidden = function isHidden() {
			return document[this._hiddenAttr];
		};
		_proto2.onVisibilityChange = function onVisibilityChange() {
			if (this.isHidden()) {
				if (this._soundManager) {
					this._soundManager.suspend();
				}
			} else {
				if (this._soundManager) {
					this._soundManager.resume();
				}
			}
		};
		_proto2.resizeCanvas = function resizeCanvas(width, height) {
			if (!this._allowResize) return undefined;
			if (this.xr && this.xr.session) return undefined;
			var windowWidth = window.innerWidth;
			var windowHeight = window.innerHeight;
			if (this._fillMode === FILLMODE_KEEP_ASPECT) {
				var r = this.graphicsDevice.canvas.width / this.graphicsDevice.canvas.height;
				var winR = windowWidth / windowHeight;
				if (r > winR) {
					width = windowWidth;
					height = width / r;
				} else {
					height = windowHeight;
					width = height * r;
				}
			} else if (this._fillMode === FILLMODE_FILL_WINDOW) {
				width = windowWidth;
				height = windowHeight;
			}
			this.graphicsDevice.canvas.style.width = width + 'px';
			this.graphicsDevice.canvas.style.height = height + 'px';
			this.updateCanvasSize();
			return {
				width: width,
				height: height
			};
		};
		_proto2.updateCanvasSize = function updateCanvasSize() {
			var _this$xr;
			if (!this._allowResize || (_this$xr = this.xr) != null && _this$xr.active) {
				return;
			}
			if (this._resolutionMode === RESOLUTION_AUTO) {
				var canvas = this.graphicsDevice.canvas;
				this.graphicsDevice.resizeCanvas(canvas.clientWidth, canvas.clientHeight);
			}
		};
		_proto2.onLibrariesLoaded = function onLibrariesLoaded() {
			this._librariesLoaded = true;
			if (this.systems.rigidbody) {
				this.systems.rigidbody.onLibraryLoaded();
			}
		};
		_proto2.applySceneSettings = function applySceneSettings(settings) {
			var asset;
			if (this.systems.rigidbody && typeof Ammo !== 'undefined') {
				var gravity = settings.physics.gravity;
				this.systems.rigidbody.gravity.set(gravity[0], gravity[1], gravity[2]);
			}
			this.scene.applySettings(settings);
			if (settings.render.hasOwnProperty('skybox')) {
				if (settings.render.skybox) {
					asset = this.assets.get(settings.render.skybox);
					if (asset) {
						this.setSkybox(asset);
					} else {
						this.assets.once('add:' + settings.render.skybox, this.setSkybox, this);
					}
				} else {
					this.setSkybox(null);
				}
			}
		};
		_proto2.setAreaLightLuts = function setAreaLightLuts(ltcMat1, ltcMat2) {
			if (ltcMat1 && ltcMat2) {
				AreaLightLuts.set(this.graphicsDevice, ltcMat1, ltcMat2);
			}
		};
		_proto2.setSkybox = function setSkybox(asset) {
			var _this7 = this;
			if (asset !== this._skyboxAsset) {
				var onSkyboxRemoved = function onSkyboxRemoved() {
					_this7.setSkybox(null);
				};
				var onSkyboxChanged = function onSkyboxChanged() {
					_this7.scene.setSkybox(_this7._skyboxAsset ? _this7._skyboxAsset.resources : null);
				};
				if (this._skyboxAsset) {
					this.assets.off('load:' + this._skyboxAsset.id, onSkyboxChanged, this);
					this.assets.off('remove:' + this._skyboxAsset.id, onSkyboxRemoved, this);
					this._skyboxAsset.off('change', onSkyboxChanged, this);
				}
				this._skyboxAsset = asset;
				if (this._skyboxAsset) {
					this.assets.on('load:' + this._skyboxAsset.id, onSkyboxChanged, this);
					this.assets.once('remove:' + this._skyboxAsset.id, onSkyboxRemoved, this);
					this._skyboxAsset.on('change', onSkyboxChanged, this);
					if (this.scene.skyboxMip === 0 && !this._skyboxAsset.loadFaces) {
						this._skyboxAsset.loadFaces = true;
					}
					this.assets.load(this._skyboxAsset);
				}
				onSkyboxChanged();
			}
		};
		_proto2._firstBake = function _firstBake() {
			var _this$lightmapper;
			(_this$lightmapper = this.lightmapper) == null || _this$lightmapper.bake(null, this.scene.lightmapMode);
		};
		_proto2._firstBatch = function _firstBatch() {
			var _this$batcher;
			(_this$batcher = this.batcher) == null || _this$batcher.generate();
		};
		_proto2._processTimestamp = function _processTimestamp(timestamp) {
			return timestamp;
		};
		_proto2.drawLine = function drawLine(start, end, color, depthTest, layer) {
			this.scene.drawLine(start, end, color, depthTest, layer);
		};
		_proto2.drawLines = function drawLines(positions, colors, depthTest, layer) {
			if (depthTest === void 0) {
				depthTest = true;
			}
			if (layer === void 0) {
				layer = this.scene.defaultDrawLayer;
			}
			this.scene.drawLines(positions, colors, depthTest, layer);
		};
		_proto2.drawLineArrays = function drawLineArrays(positions, colors, depthTest, layer) {
			if (depthTest === void 0) {
				depthTest = true;
			}
			if (layer === void 0) {
				layer = this.scene.defaultDrawLayer;
			}
			this.scene.drawLineArrays(positions, colors, depthTest, layer);
		};
		_proto2.drawWireSphere = function drawWireSphere(center, radius, color, segments, depthTest, layer) {
			if (color === void 0) {
				color = Color.WHITE;
			}
			if (segments === void 0) {
				segments = 20;
			}
			if (depthTest === void 0) {
				depthTest = true;
			}
			if (layer === void 0) {
				layer = this.scene.defaultDrawLayer;
			}
			this.scene.immediate.drawWireSphere(center, radius, color, segments, depthTest, layer);
		};
		_proto2.drawWireAlignedBox = function drawWireAlignedBox(minPoint, maxPoint, color, depthTest, layer) {
			if (color === void 0) {
				color = Color.WHITE;
			}
			if (depthTest === void 0) {
				depthTest = true;
			}
			if (layer === void 0) {
				layer = this.scene.defaultDrawLayer;
			}
			this.scene.immediate.drawWireAlignedBox(minPoint, maxPoint, color, depthTest, layer);
		};
		_proto2.drawMeshInstance = function drawMeshInstance(meshInstance, layer) {
			if (layer === void 0) {
				layer = this.scene.defaultDrawLayer;
			}
			this.scene.immediate.drawMesh(null, null, null, meshInstance, layer);
		};
		_proto2.drawMesh = function drawMesh(mesh, material, matrix, layer) {
			if (layer === void 0) {
				layer = this.scene.defaultDrawLayer;
			}
			this.scene.immediate.drawMesh(material, matrix, mesh, null, layer);
		};
		_proto2.drawQuad = function drawQuad(matrix, material, layer) {
			if (layer === void 0) {
				layer = this.scene.defaultDrawLayer;
			}
			this.scene.immediate.drawMesh(material, matrix, this.scene.immediate.getQuadMesh(), null, layer);
		};
		_proto2.drawTexture = function drawTexture(x, y, width, height, texture, material, layer, filterable) {
			if (layer === void 0) {
				layer = this.scene.defaultDrawLayer;
			}
			if (filterable === void 0) {
				filterable = true;
			}
			if (filterable === false && !this.graphicsDevice.isWebGPU) return;
			var matrix = new Mat4();
			matrix.setTRS(new Vec3(x, y, 0.0), Quat.IDENTITY, new Vec3(width, -height, 0.0));
			if (!material) {
				material = new Material();
				material.cull = CULLFACE_NONE;
				material.setParameter("colorMap", texture);
				material.shader = filterable ? this.scene.immediate.getTextureShader() : this.scene.immediate.getUnfilterableTextureShader();
				material.update();
			}
			this.drawQuad(matrix, material, layer);
		};
		_proto2.drawDepthTexture = function drawDepthTexture(x, y, width, height, layer) {
			if (layer === void 0) {
				layer = this.scene.defaultDrawLayer;
			}
			var material = new Material();
			material.cull = CULLFACE_NONE;
			material.shader = this.scene.immediate.getDepthTextureShader();
			material.update();
			this.drawTexture(x, y, width, height, null, material, layer);
		};
		_proto2.destroy = function destroy() {
			var _this$lightmapper2, _this$xr2, _this$xr3, _this$_soundManager;
			if (this._inFrameUpdate) {
				this._destroyRequested = true;
				return;
			}
			var canvasId = this.graphicsDevice.canvas.id;
			this.fire('destroy', this);
			this.off('librariesloaded');
			if (typeof document !== 'undefined') {
				document.removeEventListener('visibilitychange', this._visibilityChangeHandler, false);
				document.removeEventListener('mozvisibilitychange', this._visibilityChangeHandler, false);
				document.removeEventListener('msvisibilitychange', this._visibilityChangeHandler, false);
				document.removeEventListener('webkitvisibilitychange', this._visibilityChangeHandler, false);
			}
			this._visibilityChangeHandler = null;
			this.root.destroy();
			this.root = null;
			if (this.mouse) {
				this.mouse.off();
				this.mouse.detach();
				this.mouse = null;
			}
			if (this.keyboard) {
				this.keyboard.off();
				this.keyboard.detach();
				this.keyboard = null;
			}
			if (this.touch) {
				this.touch.off();
				this.touch.detach();
				this.touch = null;
			}
			if (this.elementInput) {
				this.elementInput.detach();
				this.elementInput = null;
			}
			if (this.gamepads) {
				this.gamepads.destroy();
				this.gamepads = null;
			}
			if (this.controller) {
				this.controller = null;
			}
			this.systems.destroy();
			if (this.scene.layers) {
				this.scene.layers.destroy();
			}
			var assets = this.assets.list();
			for (var i = 0; i < assets.length; i++) {
				assets[i].unload();
				assets[i].off();
			}
			this.assets.off();
			this.bundles.destroy();
			this.bundles = null;
			this.i18n.destroy();
			this.i18n = null;
			var scriptHandler = this.loader.getHandler('script');
			scriptHandler == null || scriptHandler.clearCache();
			this.loader.destroy();
			this.loader = null;
			this.scene.destroy();
			this.scene = null;
			this.systems = null;
			this.context = null;
			this.scripts.destroy();
			this.scripts = null;
			this.scenes.destroy();
			this.scenes = null;
			(_this$lightmapper2 = this.lightmapper) == null || _this$lightmapper2.destroy();
			this.lightmapper = null;
			if (this._batcher) {
				this._batcher.destroy();
				this._batcher = null;
			}
			this._entityIndex = {};
			this.defaultLayerDepth.onPreRenderOpaque = null;
			this.defaultLayerDepth.onPostRenderOpaque = null;
			this.defaultLayerDepth.onDisable = null;
			this.defaultLayerDepth.onEnable = null;
			this.defaultLayerDepth = null;
			this.defaultLayerWorld = null;
			(_this$xr2 = this.xr) == null || _this$xr2.end();
			(_this$xr3 = this.xr) == null || _this$xr3.destroy();
			this.renderer.destroy();
			this.renderer = null;
			this.graphicsDevice.destroy();
			this.graphicsDevice = null;
			this.tick = null;
			this.off();
			(_this$_soundManager = this._soundManager) == null || _this$_soundManager.destroy();
			this._soundManager = null;
			script.app = null;
			AppBase._applications[canvasId] = null;
			if (getApplication() === this) {
				setApplication(null);
			}
			AppBase.cancelTick(this);
		};
		AppBase.cancelTick = function cancelTick(app) {
			if (app.frameRequestId) {
				window.cancelAnimationFrame(app.frameRequestId);
				app.frameRequestId = undefined;
			}
		};
		_proto2.getEntityFromIndex = function getEntityFromIndex(guid) {
			return this._entityIndex[guid];
		};
		_proto2._registerSceneImmediate = function _registerSceneImmediate(scene) {
			this.on('postrender', scene.immediate.onPostRender, scene.immediate);
		};
		_createClass(AppBase, [{
			key: "soundManager",
			get: function get() {
				return this._soundManager;
			}
		}, {
			key: "batcher",
			get: function get() {
				return this._batcher;
			}
		}, {
			key: "fillMode",
			get: function get() {
				return this._fillMode;
			}
		}, {
			key: "resolutionMode",
			get: function get() {
				return this._resolutionMode;
			}
		}]);
		return AppBase;
	}(EventHandler);
	AppBase._applications = {};
	var _frameEndData = {};
	var makeTick = function makeTick(_app) {
		var application = _app;
		return function (timestamp, frame) {
			var _application$xr;
			if (!application.graphicsDevice) return;
			application.frameRequestId = null;
			application._inFrameUpdate = true;
			setApplication(application);
			exports.app = application;
			var currentTime = application._processTimestamp(timestamp) || now();
			var ms = currentTime - (application._time || currentTime);
			var dt = ms / 1000.0;
			dt = math.clamp(dt, 0, application.maxDeltaTime);
			dt *= application.timeScale;
			application._time = currentTime;
			if ((_application$xr = application.xr) != null && _application$xr.session) {
				application.frameRequestId = application.xr.session.requestAnimationFrame(application.tick);
			} else {
				application.frameRequestId = platform.browser ? window.requestAnimationFrame(application.tick) : null;
			}
			if (application.graphicsDevice.contextLost) return;
			application._fillFrameStatsBasic(currentTime, dt, ms);
			application.fire("frameupdate", ms);
			var shouldRenderFrame = true;
			if (frame) {
				var _application$xr2;
				shouldRenderFrame = (_application$xr2 = application.xr) == null ? void 0 : _application$xr2.update(frame);
				application.graphicsDevice.defaultFramebuffer = frame.session.renderState.baseLayer.framebuffer;
			} else {
				application.graphicsDevice.defaultFramebuffer = null;
			}
			if (shouldRenderFrame) {
				application.update(dt);
				application.fire("framerender");
				if (application.autoRender || application.renderNextFrame) {
					application.updateCanvasSize();
					application.frameStart();
					application.render();
					application.frameEnd();
					application.renderNextFrame = false;
				}
				_frameEndData.timestamp = now();
				_frameEndData.target = application;
				application.fire("frameend", _frameEndData);
			}
			application._inFrameUpdate = false;
			if (application._destroyRequested) {
				application.destroy();
			}
		};
	};

	var AppOptions = function AppOptions() {
		this.elementInput = void 0;
		this.keyboard = void 0;
		this.mouse = void 0;
		this.touch = void 0;
		this.gamepads = void 0;
		this.scriptPrefix = void 0;
		this.assetPrefix = void 0;
		this.scriptsOrder = void 0;
		this.soundManager = void 0;
		this.graphicsDevice = void 0;
		this.lightmapper = void 0;
		this.batchManager = void 0;
		this.xr = void 0;
		this.componentSystems = [];
		this.resourceHandlers = [];
	};

	var tempSphere = new BoundingSphere();
	var BakeLight = function () {
		function BakeLight(scene, light) {
			this.scene = scene;
			this.light = light;
			this.store();
			light.numCascades = 1;
			if (light.type !== LIGHTTYPE_DIRECTIONAL) {
				light._node.getWorldTransform();
				light.getBoundingSphere(tempSphere);
				this.lightBounds = new BoundingBox();
				this.lightBounds.center.copy(tempSphere.center);
				this.lightBounds.halfExtents.set(tempSphere.radius, tempSphere.radius, tempSphere.radius);
			}
		}
		var _proto = BakeLight.prototype;
		_proto.store = function store() {
			this.mask = this.light.mask;
			this.shadowUpdateMode = this.light.shadowUpdateMode;
			this.enabled = this.light.enabled;
			this.intensity = this.light.intensity;
			this.rotation = this.light._node.getLocalRotation().clone();
			this.numCascades = this.light.numCascades;
		};
		_proto.restore = function restore() {
			var light = this.light;
			light.mask = this.mask;
			light.shadowUpdateMode = this.shadowUpdateMode;
			light.enabled = this.enabled;
			light.intensity = this.intensity;
			light._node.setLocalRotation(this.rotation);
			light.numCascades = this.numCascades;
		};
		_proto.startBake = function startBake() {
			this.light.enabled = true;
			this.light._destroyShadowMap();
			this.light.beginFrame();
		};
		_proto.endBake = function endBake(shadowMapCache) {
			var light = this.light;
			light.enabled = false;
			if (light.shadowMap) {
				if (light.shadowMap.cached) shadowMapCache.add(light, light.shadowMap);
				light.shadowMap = null;
			}
		};
		return BakeLight;
	}();

	var _tempPoint$1 = new Vec2();
	var BakeLightSimple = function (_BakeLight) {
		_inheritsLoose(BakeLightSimple, _BakeLight);
		function BakeLightSimple() {
			return _BakeLight.apply(this, arguments) || this;
		}
		var _proto = BakeLightSimple.prototype;
		_proto.prepareVirtualLight = function prepareVirtualLight(index, numVirtualLights) {
			var light = this.light;
			light._node.setLocalRotation(this.rotation);
			if (index > 0) {
				var directionalSpreadAngle = light.bakeArea;
				random.circlePointDeterministic(_tempPoint$1, index, numVirtualLights);
				_tempPoint$1.mulScalar(directionalSpreadAngle * 0.5);
				light._node.rotateLocal(_tempPoint$1.x, 0, _tempPoint$1.y);
			}
			light._node.getWorldTransform();
			var gamma = this.scene.gammaCorrection ? 2.2 : 1;
			var linearIntensity = Math.pow(this.intensity, gamma);
			light.intensity = Math.pow(linearIntensity / numVirtualLights, 1 / gamma);
		};
		_createClass(BakeLightSimple, [{
			key: "numVirtualLights",
			get: function get() {
				if (this.light.type === LIGHTTYPE_DIRECTIONAL) {
					return this.light.bakeNumSamples;
				}
				return 1;
			}
		}]);
		return BakeLightSimple;
	}(BakeLight);

	var _tempPoint = new Vec3();
	var BakeLightAmbient = function (_BakeLight) {
		_inheritsLoose(BakeLightAmbient, _BakeLight);
		function BakeLightAmbient(scene) {
			var lightEntity = new Entity('AmbientLight');
			lightEntity.addComponent('light', {
				type: 'directional',
				affectDynamic: true,
				affectLightmapped: false,
				bake: true,
				bakeNumSamples: scene.ambientBakeNumSamples,
				castShadows: true,
				normalOffsetBias: 0.05,
				shadowBias: 0.2,
				shadowDistance: 1,
				shadowResolution: 2048,
				shadowType: SHADOW_PCF3,
				color: Color.WHITE,
				intensity: 1,
				bakeDir: false
			});
			return _BakeLight.call(this, scene, lightEntity.light.light) || this;
		}
		var _proto = BakeLightAmbient.prototype;
		_proto.prepareVirtualLight = function prepareVirtualLight(index, numVirtualLights) {
			random.spherePointDeterministic(_tempPoint, index, numVirtualLights, 0, this.scene.ambientBakeSpherePart);
			this.light._node.lookAt(_tempPoint.mulScalar(-1));
			this.light._node.rotateLocal(90, 0, 0);
			var gamma = this.scene.gammaCorrection ? 2.2 : 1;
			var fullIntensity = 2 * Math.PI * this.scene.ambientBakeSpherePart;
			var linearIntensity = Math.pow(fullIntensity, gamma);
			this.light.intensity = Math.pow(linearIntensity / numVirtualLights, 1 / gamma);
		};
		_createClass(BakeLightAmbient, [{
			key: "numVirtualLights",
			get: function get() {
				return this.light.bakeNumSamples;
			}
		}]);
		return BakeLightAmbient;
	}(BakeLight);

	var BakeMeshNode = function () {
		function BakeMeshNode(node, meshInstances) {
			if (meshInstances === void 0) {
				meshInstances = null;
			}
			this.node = node;
			this.component = node.render || node.model;
			meshInstances = meshInstances || this.component.meshInstances;
			this.store();
			this.meshInstances = meshInstances;
			this.bounds = null;
			this.renderTargets = [];
		}
		var _proto = BakeMeshNode.prototype;
		_proto.store = function store() {
			this.castShadows = this.component.castShadows;
		};
		_proto.restore = function restore() {
			this.component.castShadows = this.castShadows;
		};
		return BakeMeshNode;
	}();

	var DENOISE_FILTER_SIZE = 15;
	var LightmapFilters = function () {
		function LightmapFilters(device) {
			this.device = device;
			this.shaderDilate = createShaderFromCode(device, shaderChunks.fullscreenQuadVS, shaderChunksLightmapper.dilatePS, 'lmDilate');
			this.constantTexSource = device.scope.resolve('source');
			this.constantPixelOffset = device.scope.resolve('pixelOffset');
			this.pixelOffset = new Float32Array(2);
			this.shaderDenoise = null;
			this.sigmas = null;
			this.constantSigmas = null;
			this.kernel = null;
		}
		var _proto = LightmapFilters.prototype;
		_proto.setSourceTexture = function setSourceTexture(texture) {
			this.constantTexSource.setValue(texture);
		};
		_proto.prepare = function prepare(textureWidth, textureHeight) {
			this.pixelOffset[0] = 1 / textureWidth;
			this.pixelOffset[1] = 1 / textureHeight;
			this.constantPixelOffset.setValue(this.pixelOffset);
		};
		_proto.prepareDenoise = function prepareDenoise(filterRange, filterSmoothness) {
			if (!this.shaderDenoise) {
				this.shaderDenoise = createShaderFromCode(this.device, shaderChunks.fullscreenQuadVS, shaderChunksLightmapper.bilateralDeNoisePS, 'lmBilateralDeNoise');
				this.sigmas = new Float32Array(2);
				this.constantSigmas = this.device.scope.resolve('sigmas');
				this.constantKernel = this.device.scope.resolve('kernel[0]');
				this.bZnorm = this.device.scope.resolve('bZnorm');
			}
			this.sigmas[0] = filterRange;
			this.sigmas[1] = filterSmoothness;
			this.constantSigmas.setValue(this.sigmas);
			this.evaluateDenoiseUniforms(filterRange, filterSmoothness);
		};
		_proto.evaluateDenoiseUniforms = function evaluateDenoiseUniforms(filterRange, filterSmoothness) {
			function normpdf(x, sigma) {
				return 0.39894 * Math.exp(-0.5 * x * x / (sigma * sigma)) / sigma;
			}
			this.kernel = this.kernel || new Float32Array(DENOISE_FILTER_SIZE);
			var kernel = this.kernel;
			var kSize = Math.floor((DENOISE_FILTER_SIZE - 1) / 2);
			for (var j = 0; j <= kSize; ++j) {
				var value = normpdf(j, filterRange);
				kernel[kSize + j] = value;
				kernel[kSize - j] = value;
			}
			this.constantKernel.setValue(this.kernel);
			var bZnorm = 1 / normpdf(0.0, filterSmoothness);
			this.bZnorm.setValue(bZnorm);
		};
		return LightmapFilters;
	}();

	var MAX_LIGHTMAP_SIZE = 2048;
	var PASS_COLOR = 0;
	var PASS_DIR = 1;
	var tempVec$1 = new Vec3();
	var Lightmapper = function () {
		function Lightmapper(device, root, scene, renderer, assets) {
			this.device = device;
			this.root = root;
			this.scene = scene;
			this.renderer = renderer;
			this.assets = assets;
			this.shadowMapCache = renderer.shadowMapCache;
			this._tempSet = new Set();
			this._initCalled = false;
			this.passMaterials = [];
			this.ambientAOMaterial = null;
			this.fog = '';
			this.ambientLight = new Color();
			this.renderTargets = new Map();
			this.stats = {
				renderPasses: 0,
				lightmapCount: 0,
				totalRenderTime: 0,
				forwardTime: 0,
				fboTime: 0,
				shadowMapTime: 0,
				compileTime: 0,
				shadersLinked: 0
			};
		}
		var _proto = Lightmapper.prototype;
		_proto.destroy = function destroy() {
			var _this$camera;
			LightmapCache.decRef(this.blackTex);
			this.blackTex = null;
			LightmapCache.destroy();
			this.device = null;
			this.root = null;
			this.scene = null;
			this.renderer = null;
			this.assets = null;
			(_this$camera = this.camera) == null || _this$camera.destroy();
			this.camera = null;
		};
		_proto.initBake = function initBake(device) {
			if (!this._initCalled) {
				this._initCalled = true;
				this.lightmapFilters = new LightmapFilters(device);
				this.constantBakeDir = device.scope.resolve('bakeDir');
				this.materials = [];
				this.blackTex = new Texture(this.device, {
					width: 4,
					height: 4,
					format: PIXELFORMAT_RGBA8,
					type: TEXTURETYPE_RGBM,
					name: 'lightmapBlack'
				});
				LightmapCache.incRef(this.blackTex);
				var camera = new Camera();
				camera.clearColor.set(0, 0, 0, 0);
				camera.clearColorBuffer = true;
				camera.clearDepthBuffer = false;
				camera.clearStencilBuffer = false;
				camera.frustumCulling = false;
				camera.projection = PROJECTION_ORTHOGRAPHIC;
				camera.aspectRatio = 1;
				camera.node = new GraphNode();
				this.camera = camera;
			}
			if (this.scene.clusteredLightingEnabled) {
				var lightingParams = new LightingParams(device.supportsAreaLights, device.maxTextureSize, function () {});
				this.lightingParams = lightingParams;
				var srcParams = this.scene.lighting;
				lightingParams.shadowsEnabled = srcParams.shadowsEnabled;
				lightingParams.shadowAtlasResolution = srcParams.shadowAtlasResolution;
				lightingParams.cookiesEnabled = srcParams.cookiesEnabled;
				lightingParams.cookieAtlasResolution = srcParams.cookieAtlasResolution;
				lightingParams.areaLightsEnabled = srcParams.areaLightsEnabled;
				lightingParams.cells = new Vec3(3, 3, 3);
				lightingParams.maxLightsPerCell = 4;
				this.worldClusters = new WorldClusters(device);
				this.worldClusters.name = 'ClusterLightmapper';
			}
		};
		_proto.finishBake = function finishBake(bakeNodes) {
			this.materials = [];
			function destroyRT(rt) {
				LightmapCache.decRef(rt.colorBuffer);
				rt.destroy();
			}
			this.renderTargets.forEach(function (rt) {
				destroyRT(rt);
			});
			this.renderTargets.clear();
			bakeNodes.forEach(function (node) {
				node.renderTargets.forEach(function (rt) {
					destroyRT(rt);
				});
				node.renderTargets.length = 0;
			});
			this.ambientAOMaterial = null;
			if (this.worldClusters) {
				this.worldClusters.destroy();
				this.worldClusters = null;
			}
		};
		_proto.createMaterialForPass = function createMaterialForPass(device, scene, pass, addAmbient) {
			var material = new StandardMaterial();
			material.name = "lmMaterial-pass:" + pass + "-ambient:" + addAmbient;
			material.chunks.APIVersion = CHUNKAPI_1_65;
			material.chunks.transformVS = '#define UV1LAYOUT\n' + shaderChunks.transformVS;
			if (pass === PASS_COLOR) {
				var bakeLmEndChunk = shaderChunksLightmapper.bakeLmEndPS;
				if (addAmbient) {
					bakeLmEndChunk = "\n                    dDiffuseLight = ((dDiffuseLight - 0.5) * max(" + scene.ambientBakeOcclusionContrast.toFixed(1) + " + 1.0, 0.0)) + 0.5;\n                    dDiffuseLight += vec3(" + scene.ambientBakeOcclusionBrightness.toFixed(1) + ");\n                    dDiffuseLight = saturate(dDiffuseLight);\n                    dDiffuseLight *= dAmbientLight;\n                " + bakeLmEndChunk;
				} else {
					material.ambient = new Color(0, 0, 0);
					material.ambientTint = true;
				}
				material.chunks.basePS = shaderChunks.basePS + (scene.lightmapPixelFormat === PIXELFORMAT_RGBA8 ? '\n#define LIGHTMAP_RGBM\n' : '');
				material.chunks.endPS = bakeLmEndChunk;
				material.lightMap = this.blackTex;
			} else {
				material.chunks.basePS = shaderChunks.basePS + '\nuniform sampler2D texture_dirLightMap;\nuniform float bakeDir;\n';
				material.chunks.endPS = shaderChunksLightmapper.bakeDirLmEndPS;
			}
			material.chunks.outputAlphaPS = '\n';
			material.chunks.outputAlphaOpaquePS = '\n';
			material.chunks.outputAlphaPremulPS = '\n';
			material.cull = CULLFACE_NONE;
			material.forceUv1 = true;
			material.update();
			return material;
		};
		_proto.createMaterials = function createMaterials(device, scene, passCount) {
			for (var pass = 0; pass < passCount; pass++) {
				if (!this.passMaterials[pass]) {
					this.passMaterials[pass] = this.createMaterialForPass(device, scene, pass, false);
				}
			}
			if (!this.ambientAOMaterial) {
				this.ambientAOMaterial = this.createMaterialForPass(device, scene, 0, true);
				this.ambientAOMaterial.onUpdateShader = function (options) {
					options.litOptions.lightMapWithoutAmbient = true;
					options.litOptions.separateAmbient = true;
					return options;
				};
			}
		};
		_proto.createTexture = function createTexture(size, name) {
			return new Texture(this.device, {
				width: size,
				height: size,
				format: this.scene.lightmapPixelFormat,
				mipmaps: false,
				type: this.scene.lightmapPixelFormat === PIXELFORMAT_RGBA8 ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT,
				minFilter: FILTER_NEAREST,
				magFilter: FILTER_NEAREST,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE,
				name: name
			});
		};
		_proto.collectModels = function collectModels(node, bakeNodes, allNodes) {
			var _node$model, _node$model2, _node$render;
			if (!node.enabled) return;
			var meshInstances;
			if ((_node$model = node.model) != null && _node$model.model && (_node$model2 = node.model) != null && _node$model2.enabled) {
				if (allNodes) allNodes.push(new BakeMeshNode(node));
				if (node.model.lightmapped) {
					if (bakeNodes) {
						meshInstances = node.model.model.meshInstances;
					}
				}
			}
			if ((_node$render = node.render) != null && _node$render.enabled) {
				if (allNodes) allNodes.push(new BakeMeshNode(node));
				if (node.render.lightmapped) {
					if (bakeNodes) {
						meshInstances = node.render.meshInstances;
					}
				}
			}
			if (meshInstances) {
				var hasUv1 = true;
				for (var i = 0; i < meshInstances.length; i++) {
					if (!meshInstances[i].mesh.vertexBuffer.format.hasUv1) {
						hasUv1 = false;
						break;
					}
				}
				if (hasUv1) {
					var notInstancedMeshInstances = [];
					for (var _i = 0; _i < meshInstances.length; _i++) {
						var mesh = meshInstances[_i].mesh;
						if (this._tempSet.has(mesh)) {
							bakeNodes.push(new BakeMeshNode(node, [meshInstances[_i]]));
						} else {
							notInstancedMeshInstances.push(meshInstances[_i]);
						}
						this._tempSet.add(mesh);
					}
					this._tempSet.clear();
					if (notInstancedMeshInstances.length > 0) {
						bakeNodes.push(new BakeMeshNode(node, notInstancedMeshInstances));
					}
				}
			}
			for (var _i2 = 0; _i2 < node._children.length; _i2++) {
				this.collectModels(node._children[_i2], bakeNodes, allNodes);
			}
		};
		_proto.prepareShadowCasters = function prepareShadowCasters(nodes) {
			var casters = [];
			for (var n = 0; n < nodes.length; n++) {
				var component = nodes[n].component;
				component.castShadows = component.castShadowsLightmap;
				if (component.castShadowsLightmap) {
					var meshes = nodes[n].meshInstances;
					for (var i = 0; i < meshes.length; i++) {
						meshes[i].visibleThisFrame = true;
						casters.push(meshes[i]);
					}
				}
			}
			return casters;
		};
		_proto.updateTransforms = function updateTransforms(nodes) {
			for (var i = 0; i < nodes.length; i++) {
				var meshInstances = nodes[i].meshInstances;
				for (var j = 0; j < meshInstances.length; j++) {
					meshInstances[j].node.getWorldTransform();
				}
			}
		};
		_proto.calculateLightmapSize = function calculateLightmapSize(node) {
			var data;
			var sizeMult = this.scene.lightmapSizeMultiplier || 16;
			var scale = tempVec$1;
			var srcArea, lightmapSizeMultiplier;
			if (node.model) {
				lightmapSizeMultiplier = node.model.lightmapSizeMultiplier;
				if (node.model.asset) {
					data = this.assets.get(node.model.asset).data;
					if (data.area) {
						srcArea = data.area;
					}
				} else if (node.model._area) {
					data = node.model;
					if (data._area) {
						srcArea = data._area;
					}
				}
			} else if (node.render) {
				lightmapSizeMultiplier = node.render.lightmapSizeMultiplier;
				if (node.render.type !== 'asset') {
					if (node.render._area) {
						data = node.render;
						if (data._area) {
							srcArea = data._area;
						}
					}
				}
			}
			var area = {
				x: 1,
				y: 1,
				z: 1,
				uv: 1
			};
			if (srcArea) {
				area.x = srcArea.x;
				area.y = srcArea.y;
				area.z = srcArea.z;
				area.uv = srcArea.uv;
			}
			var areaMult = lightmapSizeMultiplier || 1;
			area.x *= areaMult;
			area.y *= areaMult;
			area.z *= areaMult;
			var component = node.render || node.model;
			var bounds = this.computeNodeBounds(component.meshInstances);
			scale.copy(bounds.halfExtents);
			var totalArea = area.x * scale.y * scale.z + area.y * scale.x * scale.z + area.z * scale.x * scale.y;
			totalArea /= area.uv;
			totalArea = Math.sqrt(totalArea);
			var lightmapSize = Math.min(math.nextPowerOfTwo(totalArea * sizeMult), this.scene.lightmapMaxResolution || MAX_LIGHTMAP_SIZE);
			return lightmapSize;
		};
		_proto.setLightmapping = function setLightmapping(nodes, value, passCount, shaderDefs) {
			for (var i = 0; i < nodes.length; i++) {
				var node = nodes[i];
				var meshInstances = node.meshInstances;
				for (var j = 0; j < meshInstances.length; j++) {
					var meshInstance = meshInstances[j];
					meshInstance.setLightmapped(value);
					if (value) {
						if (shaderDefs) {
							meshInstance._shaderDefs |= shaderDefs;
						}
						meshInstance.mask = MASK_AFFECT_LIGHTMAPPED;
						for (var pass = 0; pass < passCount; pass++) {
							var tex = node.renderTargets[pass].colorBuffer;
							tex.minFilter = FILTER_LINEAR;
							tex.magFilter = FILTER_LINEAR;
							meshInstance.setRealtimeLightmap(MeshInstance.lightmapParamNames[pass], tex);
						}
					}
				}
			}
		};
		_proto.bake = function bake(nodes, mode) {
			if (mode === void 0) {
				mode = BAKE_COLORDIR;
			}
			var device = this.device;
			if (device.isWebGPU) {
				return;
			}
			var startTime = now();
			this.scene._updateSky(device);
			this.stats.renderPasses = 0;
			this.stats.shadowMapTime = 0;
			this.stats.forwardTime = 0;
			var startShaders = device._shaderStats.linked;
			var startFboTime = device._renderTargetCreationTime;
			var startCompileTime = device._shaderStats.compileTime;
			var bakeNodes = [];
			var allNodes = [];
			if (nodes) {
				for (var i = 0; i < nodes.length; i++) {
					this.collectModels(nodes[i], bakeNodes, null);
				}
				this.collectModels(this.root, null, allNodes);
			} else {
				this.collectModels(this.root, bakeNodes, allNodes);
			}
			if (bakeNodes.length > 0) {
				this.renderer.shadowRenderer.frameUpdate();
				var passCount = mode === BAKE_COLORDIR ? 2 : 1;
				this.setLightmapping(bakeNodes, false, passCount);
				this.initBake(device);
				this.bakeInternal(passCount, bakeNodes, allNodes);
				var shaderDefs = SHADERDEF_LM;
				if (mode === BAKE_COLORDIR) {
					shaderDefs |= SHADERDEF_DIRLM;
				}
				if (this.scene.ambientBake) {
					shaderDefs |= SHADERDEF_LMAMBIENT;
				}
				this.setLightmapping(bakeNodes, true, passCount, shaderDefs);
				this.finishBake(bakeNodes);
			}
			var nowTime = now();
			this.stats.totalRenderTime = nowTime - startTime;
			this.stats.shadersLinked = device._shaderStats.linked - startShaders;
			this.stats.compileTime = device._shaderStats.compileTime - startCompileTime;
			this.stats.fboTime = device._renderTargetCreationTime - startFboTime;
			this.stats.lightmapCount = bakeNodes.length;
		};
		_proto.allocateTextures = function allocateTextures(bakeNodes, passCount) {
			for (var i = 0; i < bakeNodes.length; i++) {
				var bakeNode = bakeNodes[i];
				var size = this.calculateLightmapSize(bakeNode.node);
				for (var pass = 0; pass < passCount; pass++) {
					var tex = this.createTexture(size, 'lightmapper_lightmap_' + i);
					LightmapCache.incRef(tex);
					bakeNode.renderTargets[pass] = new RenderTarget({
						colorBuffer: tex,
						depth: false
					});
				}
				if (!this.renderTargets.has(size)) {
					var _tex = this.createTexture(size, 'lightmapper_temp_lightmap_' + size);
					LightmapCache.incRef(_tex);
					this.renderTargets.set(size, new RenderTarget({
						colorBuffer: _tex,
						depth: false
					}));
				}
			}
		};
		_proto.prepareLightsToBake = function prepareLightsToBake(layerComposition, allLights, bakeLights) {
			if (this.scene.ambientBake) {
				var ambientLight = new BakeLightAmbient(this.scene);
				bakeLights.push(ambientLight);
			}
			var sceneLights = this.renderer.lights;
			for (var i = 0; i < sceneLights.length; i++) {
				var light = sceneLights[i];
				var bakeLight = new BakeLightSimple(this.scene, light);
				allLights.push(bakeLight);
				if (light.enabled && (light.mask & MASK_BAKE) !== 0) {
					light.mask = MASK_BAKE | MASK_AFFECT_LIGHTMAPPED | MASK_AFFECT_DYNAMIC;
					light.shadowUpdateMode = light.type === LIGHTTYPE_DIRECTIONAL ? SHADOWUPDATE_REALTIME : SHADOWUPDATE_THISFRAME;
					bakeLights.push(bakeLight);
				}
			}
			bakeLights.sort();
		};
		_proto.restoreLights = function restoreLights(allLights) {
			for (var i = 0; i < allLights.length; i++) {
				allLights[i].restore();
			}
		};
		_proto.setupScene = function setupScene() {
			this.fog = this.scene.fog;
			this.ambientLight.copy(this.scene.ambientLight);
			this.scene.fog = FOG_NONE;
			if (!this.scene.ambientBake) {
				this.scene.ambientLight.set(0, 0, 0);
			}
			this.renderer.setSceneConstants();
		};
		_proto.restoreScene = function restoreScene() {
			this.scene.fog = this.fog;
			this.scene.ambientLight.copy(this.ambientLight);
		};
		_proto.computeNodeBounds = function computeNodeBounds(meshInstances) {
			var bounds = new BoundingBox();
			if (meshInstances.length > 0) {
				bounds.copy(meshInstances[0].aabb);
				for (var m = 1; m < meshInstances.length; m++) {
					bounds.add(meshInstances[m].aabb);
				}
			}
			return bounds;
		};
		_proto.computeNodesBounds = function computeNodesBounds(nodes) {
			for (var i = 0; i < nodes.length; i++) {
				var meshInstances = nodes[i].meshInstances;
				nodes[i].bounds = this.computeNodeBounds(meshInstances);
			}
		};
		_proto.computeBounds = function computeBounds(meshInstances) {
			var bounds = new BoundingBox();
			for (var i = 0; i < meshInstances.length; i++) {
				bounds.copy(meshInstances[0].aabb);
				for (var m = 1; m < meshInstances.length; m++) {
					bounds.add(meshInstances[m].aabb);
				}
			}
			return bounds;
		};
		_proto.backupMaterials = function backupMaterials(meshInstances) {
			for (var i = 0; i < meshInstances.length; i++) {
				this.materials[i] = meshInstances[i].material;
			}
		};
		_proto.restoreMaterials = function restoreMaterials(meshInstances) {
			for (var i = 0; i < meshInstances.length; i++) {
				meshInstances[i].material = this.materials[i];
			}
		};
		_proto.lightCameraPrepare = function lightCameraPrepare(device, bakeLight) {
			var light = bakeLight.light;
			var shadowCam;
			if (light.type === LIGHTTYPE_SPOT) {
				var lightRenderData = light.getRenderData(null, 0);
				shadowCam = lightRenderData.shadowCamera;
				shadowCam._node.setPosition(light._node.getPosition());
				shadowCam._node.setRotation(light._node.getRotation());
				shadowCam._node.rotateLocal(-90, 0, 0);
				shadowCam.projection = PROJECTION_PERSPECTIVE;
				shadowCam.nearClip = light.attenuationEnd / 1000;
				shadowCam.farClip = light.attenuationEnd;
				shadowCam.aspectRatio = 1;
				shadowCam.fov = light._outerConeAngle * 2;
				this.renderer.updateCameraFrustum(shadowCam);
			}
			return shadowCam;
		};
		_proto.lightCameraPrepareAndCull = function lightCameraPrepareAndCull(bakeLight, bakeNode, shadowCam, casterBounds) {
			var light = bakeLight.light;
			var lightAffectsNode = true;
			if (light.type === LIGHTTYPE_DIRECTIONAL) {
				tempVec$1.copy(casterBounds.center);
				tempVec$1.y += casterBounds.halfExtents.y;
				this.camera.node.setPosition(tempVec$1);
				this.camera.node.setEulerAngles(-90, 0, 0);
				this.camera.nearClip = 0;
				this.camera.farClip = casterBounds.halfExtents.y * 2;
				var frustumSize = Math.max(casterBounds.halfExtents.x, casterBounds.halfExtents.z);
				this.camera.orthoHeight = frustumSize;
			} else {
				if (!bakeLight.lightBounds.intersects(bakeNode.bounds)) {
					lightAffectsNode = false;
				}
			}
			if (light.type === LIGHTTYPE_SPOT) {
				var nodeVisible = false;
				var meshInstances = bakeNode.meshInstances;
				for (var i = 0; i < meshInstances.length; i++) {
					if (meshInstances[i]._isVisible(shadowCam)) {
						nodeVisible = true;
						break;
					}
				}
				if (!nodeVisible) {
					lightAffectsNode = false;
				}
			}
			return lightAffectsNode;
		};
		_proto.setupLightArray = function setupLightArray(lightArray, light) {
			lightArray[LIGHTTYPE_DIRECTIONAL].length = 0;
			lightArray[LIGHTTYPE_OMNI].length = 0;
			lightArray[LIGHTTYPE_SPOT].length = 0;
			lightArray[light.type][0] = light;
			light.visibleThisFrame = true;
		};
		_proto.renderShadowMap = function renderShadowMap(comp, shadowMapRendered, casters, bakeLight) {
			var light = bakeLight.light;
			var isClustered = this.scene.clusteredLightingEnabled;
			var castShadow = light.castShadows && (!isClustered || this.scene.lighting.shadowsEnabled);
			if (!shadowMapRendered && castShadow) {
				if (!light.shadowMap && !isClustered) {
					light.shadowMap = this.shadowMapCache.get(this.device, light);
				}
				if (light.type === LIGHTTYPE_DIRECTIONAL) {
					this.renderer._shadowRendererDirectional.cull(light, comp, this.camera, casters);
				} else {
					this.renderer._shadowRendererLocal.cull(light, comp, casters);
				}
				var insideRenderPass = false;
				this.renderer.shadowRenderer.render(light, this.camera, insideRenderPass);
			}
			return true;
		};
		_proto.postprocessTextures = function postprocessTextures(device, bakeNodes, passCount) {
			var numDilates2x = 1;
			var dilateShader = this.lightmapFilters.shaderDilate;
			var filterLightmap = this.scene.lightmapFilterEnabled;
			if (filterLightmap) {
				this.lightmapFilters.prepareDenoise(this.scene.lightmapFilterRange, this.scene.lightmapFilterSmoothness);
			}
			device.setBlendState(BlendState.NOBLEND);
			device.setDepthState(DepthState.NODEPTH);
			device.setStencilState(null, null);
			for (var node = 0; node < bakeNodes.length; node++) {
				var bakeNode = bakeNodes[node];
				for (var pass = 0; pass < passCount; pass++) {
					var nodeRT = bakeNode.renderTargets[pass];
					var lightmap = nodeRT.colorBuffer;
					var tempRT = this.renderTargets.get(lightmap.width);
					var tempTex = tempRT.colorBuffer;
					this.lightmapFilters.prepare(lightmap.width, lightmap.height);
					for (var i = 0; i < numDilates2x; i++) {
						this.lightmapFilters.setSourceTexture(lightmap);
						var bilateralFilterEnabled = filterLightmap && pass === 0 && i === 0;
						drawQuadWithShader(device, tempRT, bilateralFilterEnabled ? this.lightmapFilters.shaderDenoise : dilateShader);
						this.lightmapFilters.setSourceTexture(tempTex);
						drawQuadWithShader(device, nodeRT, dilateShader);
					}
				}
			}
		};
		_proto.bakeInternal = function bakeInternal(passCount, bakeNodes, allNodes) {
			var scene = this.scene;
			var comp = scene.layers;
			var device = this.device;
			var clusteredLightingEnabled = scene.clusteredLightingEnabled;
			this.createMaterials(device, scene, passCount);
			this.setupScene();
			comp._update();
			this.computeNodesBounds(bakeNodes);
			this.allocateTextures(bakeNodes, passCount);
			this.renderer.collectLights(comp);
			var allLights = [],
				bakeLights = [];
			this.prepareLightsToBake(comp, allLights, bakeLights);
			this.updateTransforms(allNodes);
			var casters = this.prepareShadowCasters(allNodes);
			this.renderer.updateCpuSkinMatrices(casters);
			this.renderer.gpuUpdate(casters);
			var casterBounds = this.computeBounds(casters);
			var i, j, rcv, m;
			for (i = 0; i < bakeNodes.length; i++) {
				var bakeNode = bakeNodes[i];
				rcv = bakeNode.meshInstances;
				for (j = 0; j < rcv.length; j++) {
					m = rcv[j];
					m.setLightmapped(false);
					m.mask = MASK_BAKE;
					m.setRealtimeLightmap(MeshInstance.lightmapParamNames[0], m.material.lightMap ? m.material.lightMap : this.blackTex);
					m.setRealtimeLightmap(MeshInstance.lightmapParamNames[1], this.blackTex);
				}
			}
			for (j = 0; j < bakeLights.length; j++) {
				bakeLights[j].light.enabled = false;
			}
			var lightArray = [[], [], []];
			var pass, node;
			var shadersUpdatedOn1stPass = false;
			for (i = 0; i < bakeLights.length; i++) {
				var bakeLight = bakeLights[i];
				var isAmbientLight = bakeLight instanceof BakeLightAmbient;
				var isDirectional = bakeLight.light.type === LIGHTTYPE_DIRECTIONAL;
				var numVirtualLights = bakeLight.numVirtualLights;
				if (passCount > 1 && numVirtualLights > 1 && bakeLight.light.bakeDir) {
					numVirtualLights = 1;
				}
				for (var virtualLightIndex = 0; virtualLightIndex < numVirtualLights; virtualLightIndex++) {
					if (numVirtualLights > 1) {
						bakeLight.prepareVirtualLight(virtualLightIndex, numVirtualLights);
					}
					bakeLight.startBake();
					var shadowMapRendered = false;
					var shadowCam = this.lightCameraPrepare(device, bakeLight);
					for (node = 0; node < bakeNodes.length; node++) {
						var _bakeNode = bakeNodes[node];
						rcv = _bakeNode.meshInstances;
						var lightAffectsNode = this.lightCameraPrepareAndCull(bakeLight, _bakeNode, shadowCam, casterBounds);
						if (!lightAffectsNode) {
							continue;
						}
						this.setupLightArray(lightArray, bakeLight.light);
						var clusterLights = isDirectional ? [] : [bakeLight.light];
						if (clusteredLightingEnabled) {
							this.renderer.lightTextureAtlas.update(clusterLights, this.lightingParams);
						}
						shadowMapRendered = this.renderShadowMap(comp, shadowMapRendered, casters, bakeLight);
						if (clusteredLightingEnabled) {
							this.worldClusters.update(clusterLights, this.scene.gammaCorrection, this.lightingParams);
						}
						this.backupMaterials(rcv);
						for (pass = 0; pass < passCount; pass++) {
							if (pass > 0 && virtualLightIndex > 0) {
								break;
							}
							if (isAmbientLight && pass > 0) {
								break;
							}
							var nodeRT = _bakeNode.renderTargets[pass];
							var lightmapSize = _bakeNode.renderTargets[pass].colorBuffer.width;
							var tempRT = this.renderTargets.get(lightmapSize);
							var tempTex = tempRT.colorBuffer;
							if (pass === 0) {
								shadersUpdatedOn1stPass = scene.updateShaders;
							} else if (shadersUpdatedOn1stPass) {
								scene.updateShaders = true;
							}
							var passMaterial = this.passMaterials[pass];
							if (isAmbientLight) {
								var lastVirtualLightForPass = virtualLightIndex + 1 === numVirtualLights;
								if (lastVirtualLightForPass && pass === 0) {
									passMaterial = this.ambientAOMaterial;
								}
							}
							for (j = 0; j < rcv.length; j++) {
								rcv[j].material = passMaterial;
							}
							this.renderer.updateShaders(rcv);
							this.renderer.setCamera(this.camera, tempRT, true);
							if (pass === PASS_DIR) {
								this.constantBakeDir.setValue(bakeLight.light.bakeDir ? 1 : 0);
							}
							if (clusteredLightingEnabled) {
								this.worldClusters.activate();
							}
							this.renderer._forwardTime = 0;
							this.renderer._shadowMapTime = 0;
							this.renderer.renderForward(this.camera, rcv, lightArray, SHADER_FORWARDHDR);
							device.updateEnd();
							_bakeNode.renderTargets[pass] = tempRT;
							this.renderTargets.set(lightmapSize, nodeRT);
							for (j = 0; j < rcv.length; j++) {
								m = rcv[j];
								m.setRealtimeLightmap(MeshInstance.lightmapParamNames[pass], tempTex);
								m._shaderDefs |= SHADERDEF_LM;
							}
						}
						this.restoreMaterials(rcv);
					}
					bakeLight.endBake(this.shadowMapCache);
				}
			}
			this.postprocessTextures(device, bakeNodes, passCount);
			for (node = 0; node < allNodes.length; node++) {
				allNodes[node].restore();
			}
			this.restoreLights(allLights);
			this.restoreScene();
			if (!clusteredLightingEnabled) {
				this.shadowMapCache.clear();
			}
		};
		return Lightmapper;
	}();

	var Component = function (_EventHandler) {
		_inheritsLoose(Component, _EventHandler);
		function Component(system, entity) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this.system = void 0;
			_this.entity = void 0;
			_this.system = system;
			_this.entity = entity;
			if (_this.system.schema && !_this._accessorsBuilt) {
				_this.buildAccessors(_this.system.schema);
			}
			_this.on('set', function (name, oldValue, newValue) {
				this.fire('set_' + name, name, oldValue, newValue);
			});
			_this.on('set_enabled', _this.onSetEnabled, _assertThisInitialized(_this));
			return _this;
		}
		Component._buildAccessors = function _buildAccessors(obj, schema) {
			schema.forEach(function (descriptor) {
				var name = typeof descriptor === 'object' ? descriptor.name : descriptor;
				Object.defineProperty(obj, name, {
					get: function get() {
						return this.data[name];
					},
					set: function set(value) {
						var data = this.data;
						var oldValue = data[name];
						data[name] = value;
						this.fire('set', name, oldValue, value);
					},
					configurable: true
				});
			});
			obj._accessorsBuilt = true;
		};
		var _proto = Component.prototype;
		_proto.buildAccessors = function buildAccessors(schema) {
			Component._buildAccessors(this, schema);
		};
		_proto.onSetEnabled = function onSetEnabled(name, oldValue, newValue) {
			if (oldValue !== newValue) {
				if (this.entity.enabled) {
					if (newValue) {
						this.onEnable();
					} else {
						this.onDisable();
					}
				}
			}
		};
		_proto.onEnable = function onEnable() {};
		_proto.onDisable = function onDisable() {};
		_proto.onPostStateChange = function onPostStateChange() {};
		_createClass(Component, [{
			key: "data",
			get: function get() {
				var record = this.system.store[this.entity.getGuid()];
				return record ? record.data : null;
			}
		}]);
		return Component;
	}(EventHandler);

	var ComponentSystem = function (_EventHandler) {
		_inheritsLoose(ComponentSystem, _EventHandler);
		function ComponentSystem(app) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this.app = app;
			_this.store = {};
			_this.schema = [];
			return _this;
		}
		var _proto = ComponentSystem.prototype;
		_proto.addComponent = function addComponent(entity, data) {
			if (data === void 0) {
				data = {};
			}
			var component = new this.ComponentType(this, entity);
			var componentData = new this.DataType();
			this.store[entity.getGuid()] = {
				entity: entity,
				data: componentData
			};
			entity[this.id] = component;
			entity.c[this.id] = component;
			this.initializeComponentData(component, data, []);
			this.fire('add', entity, component);
			return component;
		};
		_proto.removeComponent = function removeComponent(entity) {
			var record = this.store[entity.getGuid()];
			var component = entity.c[this.id];
			this.fire('beforeremove', entity, component);
			delete this.store[entity.getGuid()];
			entity[this.id] = undefined;
			delete entity.c[this.id];
			this.fire('remove', entity, record.data);
		};
		_proto.cloneComponent = function cloneComponent(entity, clone) {
			var src = this.store[entity.getGuid()];
			return this.addComponent(clone, src.data);
		};
		_proto.initializeComponentData = function initializeComponentData(component, data, properties) {
			if (data === void 0) {
				data = {};
			}
			for (var i = 0, len = properties.length; i < len; i++) {
				var descriptor = properties[i];
				var name = void 0,
					type = void 0;
				if (typeof descriptor === 'object') {
					name = descriptor.name;
					type = descriptor.type;
				} else {
					name = descriptor;
					type = undefined;
				}
				var value = data[name];
				if (value !== undefined) {
					if (type !== undefined) {
						value = convertValue(value, type);
					}
					component[name] = value;
				} else {
					component[name] = component.data[name];
				}
			}
			if (component.enabled && component.entity.enabled) {
				component.onEnable();
			}
		};
		_proto.getPropertiesOfType = function getPropertiesOfType(type) {
			var matchingProperties = [];
			var schema = this.schema || [];
			schema.forEach(function (descriptor) {
				if (descriptor && typeof descriptor === 'object' && descriptor.type === type) {
					matchingProperties.push(descriptor);
				}
			});
			return matchingProperties;
		};
		_proto.destroy = function destroy() {
			this.off();
		};
		return ComponentSystem;
	}(EventHandler);
	function convertValue(value, type) {
		if (!value) {
			return value;
		}
		switch (type) {
			case 'rgb':
				if (value instanceof Color) {
					return value.clone();
				}
				return new Color(value[0], value[1], value[2]);
			case 'rgba':
				if (value instanceof Color) {
					return value.clone();
				}
				return new Color(value[0], value[1], value[2], value[3]);
			case 'vec2':
				if (value instanceof Vec2) {
					return value.clone();
				}
				return new Vec2(value[0], value[1]);
			case 'vec3':
				if (value instanceof Vec3) {
					return value.clone();
				}
				return new Vec3(value[0], value[1], value[2]);
			case 'vec4':
				if (value instanceof Vec4) {
					return value.clone();
				}
				return new Vec4(value[0], value[1], value[2], value[3]);
			case 'boolean':
			case 'number':
			case 'string':
				return value;
			case 'entity':
				return value;
			default:
				throw new Error('Could not convert unhandled type: ' + type);
		}
	}

	var INTERPOLATION_STEP = 0;
	var INTERPOLATION_LINEAR = 1;
	var INTERPOLATION_CUBIC = 2;

	var AnimCache = function () {
		function AnimCache() {
			this._left = Infinity;
			this._right = -Infinity;
			this._len = 0;
			this._recip = 0;
			this._p0 = 0;
			this._p1 = 0;
			this._t = 0;
			this._hermite = {
				valid: false,
				p0: 0,
				m0: 0,
				p1: 0,
				m1: 0
			};
		}
		var _proto = AnimCache.prototype;
		_proto.update = function update(time, input) {
			if (time < this._left || time >= this._right) {
				var len = input.length;
				if (!len) {
					this._left = -Infinity;
					this._right = Infinity;
					this._len = 0;
					this._recip = 0;
					this._p0 = this._p1 = 0;
				} else {
					if (time < input[0]) {
						this._left = -Infinity;
						this._right = input[0];
						this._len = 0;
						this._recip = 0;
						this._p0 = this._p1 = 0;
					} else if (time >= input[len - 1]) {
						this._left = input[len - 1];
						this._right = Infinity;
						this._len = 0;
						this._recip = 0;
						this._p0 = this._p1 = len - 1;
					} else {
						var index = this._findKey(time, input);
						this._left = input[index];
						this._right = input[index + 1];
						this._len = this._right - this._left;
						var diff = 1.0 / this._len;
						this._recip = isFinite(diff) ? diff : 0;
						this._p0 = index;
						this._p1 = index + 1;
					}
				}
			}
			this._t = this._recip === 0 ? 0 : (time - this._left) * this._recip;
			this._hermite.valid = false;
		};
		_proto._findKey = function _findKey(time, input) {
			var index = 0;
			while (time >= input[index + 1]) {
				index++;
			}
			return index;
		};
		_proto.eval = function _eval(result, interpolation, output) {
			var data = output._data;
			var comp = output._components;
			var idx0 = this._p0 * comp;
			if (interpolation === INTERPOLATION_STEP) {
				for (var i = 0; i < comp; ++i) {
					result[i] = data[idx0 + i];
				}
			} else {
				var t = this._t;
				var idx1 = this._p1 * comp;
				switch (interpolation) {
					case INTERPOLATION_LINEAR:
						for (var _i = 0; _i < comp; ++_i) {
							result[_i] = math.lerp(data[idx0 + _i], data[idx1 + _i], t);
						}
						break;
					case INTERPOLATION_CUBIC:
						{
							var hermite = this._hermite;
							if (!hermite.valid) {
								var t2 = t * t;
								var twot = t + t;
								var omt = 1 - t;
								var omt2 = omt * omt;
								hermite.valid = true;
								hermite.p0 = (1 + twot) * omt2;
								hermite.m0 = t * omt2;
								hermite.p1 = t2 * (3 - twot);
								hermite.m1 = t2 * (t - 1);
							}
							var p0 = (this._p0 * 3 + 1) * comp;
							var m0 = (this._p0 * 3 + 2) * comp;
							var p1 = (this._p1 * 3 + 1) * comp;
							var m1 = (this._p1 * 3 + 0) * comp;
							for (var _i2 = 0; _i2 < comp; ++_i2) {
								result[_i2] = hermite.p0 * data[p0 + _i2] + hermite.m0 * data[m0 + _i2] * this._len + hermite.p1 * data[p1 + _i2] + hermite.m1 * data[m1 + _i2] * this._len;
							}
							break;
						}
				}
			}
		};
		return AnimCache;
	}();

	var AnimSnapshot = function AnimSnapshot(animTrack) {
		this._name = animTrack.name + 'Snapshot';
		this._time = -1;
		this._cache = [];
		this._results = [];
		for (var i = 0; i < animTrack._inputs.length; ++i) {
			this._cache[i] = new AnimCache();
		}
		var curves = animTrack._curves;
		var outputs = animTrack._outputs;
		for (var _i = 0; _i < curves.length; ++_i) {
			var curve = curves[_i];
			var output = outputs[curve._output];
			var storage = [];
			for (var j = 0; j < output._components; ++j) {
				storage[j] = 0;
			}
			this._results[_i] = storage;
		}
	};

	var AnimClip = function () {
		function AnimClip(track, time, speed, playing, loop, eventHandler) {
			this._name = track.name;
			this._track = track;
			this._snapshot = new AnimSnapshot(track);
			this._playing = playing;
			this._time = time;
			this._speed = speed;
			this._loop = loop;
			this._blendWeight = 1.0;
			this._blendOrder = 0.0;
			this._eventHandler = eventHandler;
			this.alignCursorToCurrentTime();
		}
		var _proto = AnimClip.prototype;
		_proto.nextEventAheadOfTime = function nextEventAheadOfTime(time) {
			if (!this.nextEvent) return false;
			return this.isReverse ? this.nextEvent.time <= time : this.nextEvent.time >= time;
		};
		_proto.nextEventBehindTime = function nextEventBehindTime(time) {
			if (!this.nextEvent) return false;
			if (time === this.track.duration) {
				return this.isReverse ? this.nextEvent.time >= time : this.nextEvent.time <= time;
			}
			return this.isReverse ? this.nextEvent.time > time : this.nextEvent.time < time;
		};
		_proto.resetEventCursor = function resetEventCursor() {
			this._eventCursor = this.isReverse ? this._track.events.length - 1 : 0;
		};
		_proto.moveEventCursor = function moveEventCursor() {
			this._eventCursor += this.isReverse ? -1 : 1;
			if (this._eventCursor >= this.track.events.length) {
				this._eventCursor = 0;
			} else if (this._eventCursor < 0) {
				this._eventCursor = this.track.events.length - 1;
			}
		};
		_proto.clipFrameTime = function clipFrameTime(frameEndTime) {
			var eventFrame = AnimClip.eventFrame;
			eventFrame.start = 0;
			eventFrame.end = frameEndTime;
			eventFrame.residual = 0;
			if (this.isReverse) {
				if (frameEndTime < 0) {
					eventFrame.start = this.track.duration;
					eventFrame.end = 0;
					eventFrame.residual = frameEndTime + this.track.duration;
				}
			} else {
				if (frameEndTime > this.track.duration) {
					eventFrame.start = 0;
					eventFrame.end = this.track.duration;
					eventFrame.residual = frameEndTime - this.track.duration;
				}
			}
		};
		_proto.alignCursorToCurrentTime = function alignCursorToCurrentTime() {
			this.resetEventCursor();
			while (this.nextEventBehindTime(this._time) && this._eventCursor !== this.eventCursorEnd) {
				this.moveEventCursor();
			}
		};
		_proto.fireNextEvent = function fireNextEvent() {
			this._eventHandler.fire(this.nextEvent.name, _extends({
				track: this.track
			}, this.nextEvent));
			this.moveEventCursor();
		};
		_proto.fireNextEventInFrame = function fireNextEventInFrame(frameStartTime, frameEndTime) {
			if (this.nextEventAheadOfTime(frameStartTime) && this.nextEventBehindTime(frameEndTime)) {
				this.fireNextEvent();
				return true;
			}
			return false;
		};
		_proto.activeEventsForFrame = function activeEventsForFrame(frameStartTime, frameEndTime) {
			var eventFrame = AnimClip.eventFrame;
			this.clipFrameTime(frameEndTime);
			var initialCursor = this.eventCursor;
			while (this.fireNextEventInFrame(frameStartTime, eventFrame.end)) {
				if (initialCursor === this.eventCursor) {
					break;
				}
			}
			if (this.loop && Math.abs(eventFrame.residual) > 0) {
				this.activeEventsForFrame(eventFrame.start, eventFrame.residual);
			}
		};
		_proto.progressForTime = function progressForTime(time) {
			return time * this._speed / this._track.duration;
		};
		_proto._update = function _update(deltaTime) {
			if (this._playing) {
				var time = this._time;
				var duration = this._track.duration;
				var speed = this._speed;
				var loop = this._loop;
				if (this._track.events.length > 0 && duration > 0) {
					this.activeEventsForFrame(time, time + speed * deltaTime);
				}
				time += speed * deltaTime;
				if (speed >= 0) {
					if (time > duration) {
						if (loop) {
							time = time % duration || 0;
						} else {
							time = this._track.duration;
							this.pause();
						}
					}
				} else {
					if (time < 0) {
						if (loop) {
							time = duration + (time % duration || 0);
						} else {
							time = 0;
							this.pause();
						}
					}
				}
				this._time = time;
			}
			if (this._time !== this._snapshot._time) {
				this._track.eval(this._time, this._snapshot);
			}
		};
		_proto.play = function play() {
			this._playing = true;
			this._time = 0;
		};
		_proto.stop = function stop() {
			this._playing = false;
			this._time = 0;
		};
		_proto.pause = function pause() {
			this._playing = false;
		};
		_proto.resume = function resume() {
			this._playing = true;
		};
		_proto.reset = function reset() {
			this._time = 0;
		};
		_createClass(AnimClip, [{
			key: "name",
			get: function get() {
				return this._name;
			},
			set: function set(name) {
				this._name = name;
			}
		}, {
			key: "track",
			get: function get() {
				return this._track;
			},
			set: function set(track) {
				this._track = track;
				this._snapshot = new AnimSnapshot(track);
			}
		}, {
			key: "snapshot",
			get: function get() {
				return this._snapshot;
			}
		}, {
			key: "time",
			get: function get() {
				return this._time;
			},
			set: function set(time) {
				this._time = time;
				this.alignCursorToCurrentTime();
			}
		}, {
			key: "speed",
			get: function get() {
				return this._speed;
			},
			set: function set(speed) {
				var signChanged = Math.sign(speed) !== Math.sign(this._speed);
				this._speed = speed;
				if (signChanged) {
					this.alignCursorToCurrentTime();
				}
			}
		}, {
			key: "loop",
			get: function get() {
				return this._loop;
			},
			set: function set(loop) {
				this._loop = loop;
			}
		}, {
			key: "blendWeight",
			get: function get() {
				return this._blendWeight;
			},
			set: function set(blendWeight) {
				this._blendWeight = blendWeight;
			}
		}, {
			key: "blendOrder",
			get: function get() {
				return this._blendOrder;
			},
			set: function set(blendOrder) {
				this._blendOrder = blendOrder;
			}
		}, {
			key: "eventCursor",
			get: function get() {
				return this._eventCursor;
			},
			set: function set(value) {
				this._eventCursor = value;
			}
		}, {
			key: "eventCursorEnd",
			get: function get() {
				return this.isReverse ? 0 : this._track.events.length - 1;
			}
		}, {
			key: "nextEvent",
			get: function get() {
				return this._track.events[this._eventCursor];
			}
		}, {
			key: "isReverse",
			get: function get() {
				return this._speed < 0;
			}
		}]);
		return AnimClip;
	}();
	AnimClip.eventFrame = {
		start: 0,
		end: 0,
		residual: 0
	};

	var ANIM_INTERRUPTION_NONE = 'NONE';
	var ANIM_INTERRUPTION_PREV = 'PREV_STATE';
	var ANIM_INTERRUPTION_NEXT = 'NEXT_STATE';
	var ANIM_INTERRUPTION_PREV_NEXT = 'PREV_STATE_NEXT_STATE';
	var ANIM_INTERRUPTION_NEXT_PREV = 'NEXT_STATE_PREV_STATE';
	var ANIM_GREATER_THAN = 'GREATER_THAN';
	var ANIM_LESS_THAN = 'LESS_THAN';
	var ANIM_GREATER_THAN_EQUAL_TO = 'GREATER_THAN_EQUAL_TO';
	var ANIM_LESS_THAN_EQUAL_TO = 'LESS_THAN_EQUAL_TO';
	var ANIM_EQUAL_TO = 'EQUAL_TO';
	var ANIM_NOT_EQUAL_TO = 'NOT_EQUAL_TO';
	var ANIM_PARAMETER_INTEGER = 'INTEGER';
	var ANIM_PARAMETER_FLOAT = 'FLOAT';
	var ANIM_PARAMETER_BOOLEAN = 'BOOLEAN';
	var ANIM_PARAMETER_TRIGGER = 'TRIGGER';
	var ANIM_BLEND_1D = '1D';
	var ANIM_BLEND_2D_DIRECTIONAL = '2D_DIRECTIONAL';
	var ANIM_BLEND_2D_CARTESIAN = '2D_CARTESIAN';
	var ANIM_BLEND_DIRECT = 'DIRECT';
	var ANIM_STATE_START = 'START';
	var ANIM_STATE_END = 'END';
	var ANIM_STATE_ANY = 'ANY';
	var ANIM_CONTROL_STATES = [ANIM_STATE_START, ANIM_STATE_END, ANIM_STATE_ANY];
	var ANIM_LAYER_OVERWRITE = 'OVERWRITE';
	var ANIM_LAYER_ADDITIVE = 'ADDITIVE';

	var AnimBlend = function () {
		function AnimBlend() {}
		AnimBlend.dot = function dot(a, b) {
			var len = a.length;
			var result = 0;
			for (var i = 0; i < len; ++i) {
				result += a[i] * b[i];
			}
			return result;
		};
		AnimBlend.normalize = function normalize(a) {
			var l = AnimBlend.dot(a, a);
			if (l > 0) {
				l = 1.0 / Math.sqrt(l);
				var len = a.length;
				for (var i = 0; i < len; ++i) {
					a[i] *= l;
				}
			}
		};
		AnimBlend.set = function set(a, b, type) {
			var len = a.length;
			if (type === 'quaternion') {
				var l = AnimBlend.dot(b, b);
				if (l > 0) {
					l = 1.0 / Math.sqrt(l);
				}
				for (var i = 0; i < len; ++i) {
					a[i] = b[i] * l;
				}
			} else {
				for (var _i = 0; _i < len; ++_i) {
					a[_i] = b[_i];
				}
			}
		};
		AnimBlend.blendVec = function blendVec(a, b, t, additive) {
			var it = additive ? 1.0 : 1.0 - t;
			var len = a.length;
			for (var i = 0; i < len; ++i) {
				a[i] = a[i] * it + b[i] * t;
			}
		};
		AnimBlend.blendQuat = function blendQuat(a, b, t, additive) {
			var len = a.length;
			var it = additive ? 1.0 : 1.0 - t;
			if (AnimBlend.dot(a, b) < 0) {
				t = -t;
			}
			for (var i = 0; i < len; ++i) {
				a[i] = a[i] * it + b[i] * t;
			}
			if (!additive) {
				AnimBlend.normalize(a);
			}
		};
		AnimBlend.blend = function blend(a, b, t, type, additive) {
			if (type === 'quaternion') {
				AnimBlend.blendQuat(a, b, t, additive);
			} else {
				AnimBlend.blendVec(a, b, t, additive);
			}
		};
		AnimBlend.stableSort = function stableSort(a, lessFunc) {
			var len = a.length;
			for (var i = 0; i < len - 1; ++i) {
				for (var j = i + 1; j < len; ++j) {
					if (lessFunc(a[j], a[i])) {
						var tmp = a[i];
						a[i] = a[j];
						a[j] = tmp;
					}
				}
			}
		};
		return AnimBlend;
	}();

	var AnimTargetValue = function () {
		function AnimTargetValue(component, type) {
			this._component = component;
			this.mask = new Int8Array(component.layers.length);
			this.weights = new Float32Array(component.layers.length);
			this.totalWeight = 0;
			this.counter = 0;
			this.layerCounter = 0;
			this.valueType = type;
			this.dirty = true;
			this.value = type === AnimTargetValue.TYPE_QUAT ? [0, 0, 0, 1] : [0, 0, 0];
			this.baseValue = null;
			this.setter = null;
		}
		var _proto = AnimTargetValue.prototype;
		_proto.getWeight = function getWeight(index) {
			if (this.dirty) this.updateWeights();
			if (this._normalizeWeights && this.totalWeight === 0 || !this.mask[index]) {
				return 0;
			} else if (this._normalizeWeights) {
				return this.weights[index] / this.totalWeight;
			}
			return math.clamp(this.weights[index], 0, 1);
		};
		_proto._layerBlendType = function _layerBlendType(index) {
			return this._component.layers[index].blendType;
		};
		_proto.setMask = function setMask(index, value) {
			this.mask[index] = value;
			if (this._normalizeWeights) {
				if (this._component.layers[index].blendType === ANIM_LAYER_OVERWRITE) {
					this.mask = this.mask.fill(0, 0, index);
				}
				this.dirty = true;
			}
		};
		_proto.updateWeights = function updateWeights() {
			this.totalWeight = 0;
			for (var i = 0; i < this.weights.length; i++) {
				this.weights[i] = this._component.layers[i].weight;
				this.totalWeight += this.mask[i] * this.weights[i];
			}
			this.dirty = false;
		};
		_proto.updateValue = function updateValue(index, value) {
			if (this.counter === 0) {
				AnimBlend.set(this.value, AnimTargetValue.IDENTITY_QUAT_ARR, this.valueType);
				if (!this._normalizeWeights) {
					AnimBlend.blend(this.value, this.baseValue, 1, this.valueType);
				}
			}
			if (!this.mask[index] || this.getWeight(index) === 0) return;
			if (this._layerBlendType(index) === ANIM_LAYER_ADDITIVE && !this._normalizeWeights) {
				if (this.valueType === AnimTargetValue.TYPE_QUAT) {
					var v = AnimTargetValue.q1.set(this.value[0], this.value[1], this.value[2], this.value[3]);
					var aV1 = AnimTargetValue.q2.set(this.baseValue[0], this.baseValue[1], this.baseValue[2], this.baseValue[3]);
					var aV2 = AnimTargetValue.q3.set(value[0], value[1], value[2], value[3]);
					var aV = aV1.invert().mul(aV2);
					aV.slerp(Quat.IDENTITY, aV, this.getWeight(index));
					v.mul(aV);
					AnimTargetValue.quatArr[0] = v.x;
					AnimTargetValue.quatArr[1] = v.y;
					AnimTargetValue.quatArr[2] = v.z;
					AnimTargetValue.quatArr[3] = v.w;
					AnimBlend.set(this.value, AnimTargetValue.quatArr, this.valueType);
				} else {
					AnimTargetValue.vecArr[0] = value[0] - this.baseValue[0];
					AnimTargetValue.vecArr[1] = value[1] - this.baseValue[1];
					AnimTargetValue.vecArr[2] = value[2] - this.baseValue[2];
					AnimBlend.blend(this.value, AnimTargetValue.vecArr, this.getWeight(index), this.valueType, true);
				}
			} else {
				AnimBlend.blend(this.value, value, this.getWeight(index), this.valueType);
			}
			if (this.setter) this.setter(this.value);
		};
		_proto.unbind = function unbind() {
			if (this.setter) {
				this.setter(this.baseValue);
			}
		};
		_createClass(AnimTargetValue, [{
			key: "_normalizeWeights",
			get: function get() {
				return this._component.normalizeWeights;
			}
		}]);
		return AnimTargetValue;
	}();
	AnimTargetValue.TYPE_QUAT = 'quaternion';
	AnimTargetValue.TYPE_VEC3 = 'vector3';
	AnimTargetValue.q1 = new Quat();
	AnimTargetValue.q2 = new Quat();
	AnimTargetValue.q3 = new Quat();
	AnimTargetValue.quatArr = [0, 0, 0, 1];
	AnimTargetValue.vecArr = [0, 0, 0];
	AnimTargetValue.IDENTITY_QUAT_ARR = [0, 0, 0, 1];

	var AnimEvaluator = function () {
		function AnimEvaluator(binder) {
			this._binder = binder;
			this._clips = [];
			this._inputs = [];
			this._outputs = [];
			this._targets = {};
		}
		var _proto = AnimEvaluator.prototype;
		_proto.addClip = function addClip(clip) {
			var targets = this._targets;
			var binder = this._binder;
			var curves = clip.track.curves;
			var snapshot = clip.snapshot;
			var inputs = [];
			var outputs = [];
			for (var i = 0; i < curves.length; ++i) {
				var curve = curves[i];
				var paths = curve.paths;
				for (var j = 0; j < paths.length; ++j) {
					var path = paths[j];
					var resolved = binder.resolve(path);
					var target = targets[resolved && resolved.targetPath || null];
					if (!target && resolved) {
						target = {
							target: resolved,
							value: [],
							curves: 0,
							blendCounter: 0
						};
						for (var k = 0; k < target.target.components; ++k) {
							target.value.push(0);
						}
						targets[resolved.targetPath] = target;
						if (binder.animComponent) {
							if (!binder.animComponent.targets[resolved.targetPath]) {
								var type = void 0;
								if (resolved.targetPath.substring(resolved.targetPath.length - 13) === 'localRotation') {
									type = AnimTargetValue.TYPE_QUAT;
								} else {
									type = AnimTargetValue.TYPE_VEC3;
								}
								binder.animComponent.targets[resolved.targetPath] = new AnimTargetValue(binder.animComponent, type);
							}
							binder.animComponent.targets[resolved.targetPath].layerCounter++;
							binder.animComponent.targets[resolved.targetPath].setMask(binder.layerIndex, 1);
						}
					}
					if (target) {
						target.curves++;
						inputs.push(snapshot._results[i]);
						outputs.push(target);
					}
				}
			}
			this._clips.push(clip);
			this._inputs.push(inputs);
			this._outputs.push(outputs);
		};
		_proto.removeClip = function removeClip(index) {
			var targets = this._targets;
			var binder = this._binder;
			var clips = this._clips;
			var clip = clips[index];
			var curves = clip.track.curves;
			for (var i = 0; i < curves.length; ++i) {
				var curve = curves[i];
				var paths = curve.paths;
				for (var j = 0; j < paths.length; ++j) {
					var path = paths[j];
					var target = this._binder.resolve(path);
					if (target) {
						target.curves--;
						if (target.curves === 0) {
							binder.unresolve(path);
							delete targets[target.targetPath];
							if (binder.animComponent) {
								binder.animComponent.targets[target.targetPath].layerCounter--;
							}
						}
					}
				}
			}
			clips.splice(index, 1);
			this._inputs.splice(index, 1);
			this._outputs.splice(index, 1);
		};
		_proto.removeClips = function removeClips() {
			while (this._clips.length > 0) {
				this.removeClip(0);
			}
		};
		_proto.updateClipTrack = function updateClipTrack(name, animTrack) {
			this._clips.forEach(function (clip) {
				if (clip.name.includes(name)) {
					clip.track = animTrack;
				}
			});
			this.rebind();
		};
		_proto.findClip = function findClip(name) {
			var clips = this._clips;
			for (var i = 0; i < clips.length; ++i) {
				var clip = clips[i];
				if (clip.name === name) {
					return clip;
				}
			}
			return null;
		};
		_proto.rebind = function rebind() {
			var _this = this;
			this._binder.rebind();
			this._targets = {};
			var clips = [].concat(this.clips);
			this.removeClips();
			clips.forEach(function (clip) {
				_this.addClip(clip);
			});
		};
		_proto.assignMask = function assignMask(mask) {
			return this._binder.assignMask(mask);
		};
		_proto.update = function update(deltaTime, outputAnimation) {
			if (outputAnimation === void 0) {
				outputAnimation = true;
			}
			var clips = this._clips;
			var order = clips.map(function (c, i) {
				return i;
			});
			AnimBlend.stableSort(order, function (a, b) {
				return clips[a].blendOrder < clips[b].blendOrder;
			});
			for (var i = 0; i < order.length; ++i) {
				var index = order[i];
				var clip = clips[index];
				var inputs = this._inputs[index];
				var outputs = this._outputs[index];
				var blendWeight = clip.blendWeight;
				if (blendWeight > 0.0) {
					clip._update(deltaTime);
				}
				if (!outputAnimation) break;
				var input = void 0;
				var output = void 0;
				var value = void 0;
				if (blendWeight >= 1.0) {
					for (var j = 0; j < inputs.length; ++j) {
						input = inputs[j];
						output = outputs[j];
						value = output.value;
						AnimBlend.set(value, input, output.target.type);
						output.blendCounter++;
					}
				} else if (blendWeight > 0.0) {
					for (var _j = 0; _j < inputs.length; ++_j) {
						input = inputs[_j];
						output = outputs[_j];
						value = output.value;
						if (output.blendCounter === 0) {
							AnimBlend.set(value, input, output.target.type);
						} else {
							AnimBlend.blend(value, input, blendWeight, output.target.type);
						}
						output.blendCounter++;
					}
				}
			}
			var targets = this._targets;
			var binder = this._binder;
			for (var path in targets) {
				if (targets.hasOwnProperty(path)) {
					var target = targets[path];
					if (binder.animComponent && target.target.isTransform) {
						var animTarget = binder.animComponent.targets[path];
						if (animTarget.counter === animTarget.layerCounter) {
							animTarget.counter = 0;
						}
						if (!animTarget.path) {
							animTarget.path = path;
							animTarget.baseValue = target.target.get();
							animTarget.setter = target.target.set;
						}
						animTarget.updateValue(binder.layerIndex, target.value);
						animTarget.counter++;
					} else {
						target.target.set(target.value);
					}
					target.blendCounter = 0;
				}
			}
			this._binder.update(deltaTime);
		};
		_createClass(AnimEvaluator, [{
			key: "clips",
			get: function get() {
				return this._clips;
			}
		}]);
		return AnimEvaluator;
	}();

	var AnimEvents = function () {
		function AnimEvents(events) {
			this._events = [].concat(events);
			this._events.sort(function (a, b) {
				return a.time - b.time;
			});
		}
		_createClass(AnimEvents, [{
			key: "events",
			get: function get() {
				return this._events;
			}
		}]);
		return AnimEvents;
	}();

	var _class;
	var AnimTrack = function () {
		function AnimTrack(name, duration, inputs, outputs, curves, animEvents) {
			if (animEvents === void 0) {
				animEvents = new AnimEvents([]);
			}
			this._name = name;
			this._duration = duration;
			this._inputs = inputs;
			this._outputs = outputs;
			this._curves = curves;
			this._animEvents = animEvents;
		}
		var _proto = AnimTrack.prototype;
		_proto.eval = function _eval(time, snapshot) {
			snapshot._time = time;
			var inputs = this._inputs;
			var outputs = this._outputs;
			var curves = this._curves;
			var cache = snapshot._cache;
			var results = snapshot._results;
			for (var i = 0; i < inputs.length; ++i) {
				cache[i].update(time, inputs[i]._data);
			}
			for (var _i = 0; _i < curves.length; ++_i) {
				var curve = curves[_i];
				var output = outputs[curve._output];
				var result = results[_i];
				cache[curve._input].eval(result, curve._interpolation, output);
			}
		};
		_createClass(AnimTrack, [{
			key: "name",
			get: function get() {
				return this._name;
			}
		}, {
			key: "duration",
			get: function get() {
				return this._duration;
			}
		}, {
			key: "inputs",
			get: function get() {
				return this._inputs;
			}
		}, {
			key: "outputs",
			get: function get() {
				return this._outputs;
			}
		}, {
			key: "curves",
			get: function get() {
				return this._curves;
			}
		}, {
			key: "events",
			get: function get() {
				return this._animEvents.events;
			},
			set: function set(animEvents) {
				this._animEvents = animEvents;
			}
		}]);
		return AnimTrack;
	}();
	_class = AnimTrack;
	AnimTrack.EMPTY = Object.freeze(new _class('empty', Number.MAX_VALUE, [], [], []));

	var AnimBinder = function () {
		function AnimBinder() {}
		AnimBinder.joinPath = function joinPath(pathSegments, character) {
			character = character || '.';
			var escape = function escape(string) {
				return string.replace(/\\/g, '\\\\').replace(new RegExp('\\' + character, 'g'), '\\' + character);
			};
			return pathSegments.map(escape).join(character);
		};
		AnimBinder.splitPath = function splitPath(path, character) {
			character = character || '.';
			var result = [];
			var curr = "";
			var i = 0;
			while (i < path.length) {
				var c = path[i++];
				if (c === '\\' && i < path.length) {
					c = path[i++];
					if (c === '\\' || c === character) {
						curr += c;
					} else {
						curr += '\\' + c;
					}
				} else if (c === character) {
					result.push(curr);
					curr = '';
				} else {
					curr += c;
				}
			}
			if (curr.length > 0) {
				result.push(curr);
			}
			return result;
		};
		AnimBinder.encode = function encode(entityPath, component, propertyPath) {
			return (Array.isArray(entityPath) ? entityPath.join('/') : entityPath) + "/" + component + "/" + (Array.isArray(propertyPath) ? propertyPath.join('/') : propertyPath);
		};
		var _proto = AnimBinder.prototype;
		_proto.resolve = function resolve(path) {
			return null;
		};
		_proto.unresolve = function unresolve(path) {};
		_proto.update = function update(deltaTime) {};
		return AnimBinder;
	}();

	var AnimTarget = function () {
		function AnimTarget(func, type, components, targetPath) {
			if (func.set) {
				this._set = func.set;
				this._get = func.get;
			} else {
				this._set = func;
			}
			this._type = type;
			this._components = components;
			this._targetPath = targetPath;
			this._isTransform = this._targetPath.substring(this._targetPath.length - 13) === 'localRotation' || this._targetPath.substring(this._targetPath.length - 13) === 'localPosition' || this._targetPath.substring(this._targetPath.length - 10) === 'localScale';
		}
		_createClass(AnimTarget, [{
			key: "set",
			get: function get() {
				return this._set;
			}
		}, {
			key: "get",
			get: function get() {
				return this._get;
			}
		}, {
			key: "type",
			get: function get() {
				return this._type;
			}
		}, {
			key: "components",
			get: function get() {
				return this._components;
			}
		}, {
			key: "targetPath",
			get: function get() {
				return this._targetPath;
			}
		}, {
			key: "isTransform",
			get: function get() {
				return this._isTransform;
			}
		}]);
		return AnimTarget;
	}();

	var DefaultAnimBinder = function () {
		function DefaultAnimBinder(graph) {
			var _this = this;
			this._isPathInMask = function (path, checkMaskValue) {
				var maskItem = _this._mask[path];
				if (!maskItem) return false;else if (maskItem.children || checkMaskValue && maskItem.value !== false) return true;
				return false;
			};
			this.graph = graph;
			if (!graph) return;
			this._mask = null;
			var nodes = {};
			var flatten = function flatten(node) {
				nodes[node.name] = node;
				for (var i = 0; i < node.children.length; ++i) {
					flatten(node.children[i]);
				}
			};
			flatten(graph);
			this.nodes = nodes;
			this.targetCache = {};
			var findMeshInstances = function findMeshInstances(node) {
				var object = node;
				while (object && !(object instanceof Entity)) {
					object = object.parent;
				}
				var meshInstances;
				if (object) {
					if (object.render) {
						meshInstances = object.render.meshInstances;
					} else if (object.model) {
						meshInstances = object.model.meshInstances;
					}
				}
				return meshInstances;
			};
			this.nodeCounts = {};
			this.activeNodes = [];
			this.handlers = {
				'localPosition': function localPosition(node) {
					var object = node.localPosition;
					var func = function func(value) {
						object.set.apply(object, value);
					};
					return DefaultAnimBinder.createAnimTarget(func, 'vector', 3, node, 'localPosition');
				},
				'localRotation': function localRotation(node) {
					var object = node.localRotation;
					var func = function func(value) {
						object.set.apply(object, value);
					};
					return DefaultAnimBinder.createAnimTarget(func, 'quaternion', 4, node, 'localRotation');
				},
				'localScale': function localScale(node) {
					var object = node.localScale;
					var func = function func(value) {
						object.set.apply(object, value);
					};
					return DefaultAnimBinder.createAnimTarget(func, 'vector', 3, node, 'localScale');
				},
				'weight': function weight(node, weightName) {
					if (weightName.indexOf('name.') === 0) {
						weightName = weightName.replace('name.', '');
					} else {
						weightName = Number(weightName);
					}
					var meshInstances = findMeshInstances(node);
					var setters;
					if (meshInstances) {
						var _loop = function _loop() {
							if (meshInstances[i].node.name === node.name && meshInstances[i].morphInstance) {
								var morphInstance = meshInstances[i].morphInstance;
								var func = function func(value) {
									morphInstance.setWeight(weightName, value[0]);
								};
								if (!setters) setters = [];
								setters.push(func);
							}
						};
						for (var i = 0; i < meshInstances.length; ++i) {
							_loop();
						}
					}
					if (setters) {
						var callSetters = function callSetters(value) {
							for (var _i = 0; _i < setters.length; ++_i) {
								setters[_i](value);
							}
						};
						return DefaultAnimBinder.createAnimTarget(callSetters, 'number', 1, node, "weight." + weightName);
					}
					return null;
				},
				'materialTexture': function materialTexture(node, textureName) {
					var meshInstances = findMeshInstances(node);
					if (meshInstances) {
						var meshInstance;
						for (var i = 0; i < meshInstances.length; ++i) {
							if (meshInstances[i].node.name === node.name) {
								meshInstance = meshInstances[i];
								break;
							}
						}
						if (meshInstance) {
							var func = function func(value) {
								var textureAsset = _this.animComponent.system.app.assets.get(value[0]);
								if (textureAsset && textureAsset.resource && textureAsset.type === 'texture') {
									meshInstance.material[textureName] = textureAsset.resource;
									meshInstance.material.update();
								}
							};
							return DefaultAnimBinder.createAnimTarget(func, 'vector', 1, node, 'materialTexture', 'material');
						}
					}
					return null;
				}
			};
		}
		var _proto = DefaultAnimBinder.prototype;
		_proto._isPathActive = function _isPathActive(path) {
			if (!this._mask) return true;
			var rootNodeNames = [path.entityPath[0], this.graph.name];
			for (var j = 0; j < rootNodeNames.length; ++j) {
				var currEntityPath = rootNodeNames[j];
				if (this._isPathInMask(currEntityPath, path.entityPath.length === 1)) return true;
				for (var i = 1; i < path.entityPath.length; i++) {
					currEntityPath += '/' + path.entityPath[i];
					if (this._isPathInMask(currEntityPath, i === path.entityPath.length - 1)) return true;
				}
			}
			return false;
		};
		_proto.findNode = function findNode(path) {
			if (!this._isPathActive(path)) {
				return null;
			}
			var node;
			if (this.graph) {
				node = this.graph.findByPath(path.entityPath);
				if (!node) {
					node = this.graph.findByPath(path.entityPath.slice(1));
				}
			}
			if (!node) {
				node = this.nodes[path.entityPath[path.entityPath.length - 1] || ""];
			}
			return node;
		};
		DefaultAnimBinder.createAnimTarget = function createAnimTarget(func, type, valueCount, node, propertyPath, componentType) {
			var targetPath = AnimBinder.encode(node.path, componentType ? componentType : 'entity', propertyPath);
			return new AnimTarget(func, type, valueCount, targetPath);
		};
		_proto.resolve = function resolve(path) {
			var encodedPath = AnimBinder.encode(path.entityPath, path.component, path.propertyPath);
			var target = this.targetCache[encodedPath];
			if (target) return target;
			var node = this.findNode(path);
			if (!node) {
				return null;
			}
			var handler = this.handlers[path.propertyPath];
			if (!handler) {
				return null;
			}
			target = handler(node);
			if (!target) {
				return null;
			}
			this.targetCache[encodedPath] = target;
			if (!this.nodeCounts[node.path]) {
				this.activeNodes.push(node);
				this.nodeCounts[node.path] = 1;
			} else {
				this.nodeCounts[node.path]++;
			}
			return target;
		};
		_proto.unresolve = function unresolve(path) {
			if (path.component !== 'graph') return;
			var node = this.nodes[path.entityPath[path.entityPath.length - 1] || ""];
			this.nodeCounts[node.path]--;
			if (this.nodeCounts[node.path] === 0) {
				var activeNodes = this.activeNodes;
				var i = activeNodes.indexOf(node.node);
				var len = activeNodes.length;
				if (i < len - 1) {
					activeNodes[i] = activeNodes[len - 1];
				}
				activeNodes.pop();
			}
		};
		_proto.update = function update(deltaTime) {
			var activeNodes = this.activeNodes;
			for (var i = 0; i < activeNodes.length; ++i) {
				activeNodes[i]._dirtifyLocal();
			}
		};
		_proto.assignMask = function assignMask(mask) {
			if (mask !== this._mask) {
				this._mask = mask;
				return true;
			}
			return false;
		};
		return DefaultAnimBinder;
	}();

	var AnimationComponent = function (_Component) {
		_inheritsLoose(AnimationComponent, _Component);
		function AnimationComponent(system, entity) {
			var _this;
			_this = _Component.call(this, system, entity) || this;
			_this._animations = {};
			_this._assets = [];
			_this._loop = true;
			_this.animEvaluator = null;
			_this.model = null;
			_this.skeleton = null;
			_this.fromSkel = null;
			_this.toSkel = null;
			_this.animationsIndex = {};
			_this.prevAnim = null;
			_this.currAnim = null;
			_this.blend = 0;
			_this.blending = false;
			_this.blendSpeed = 0;
			_this.activate = true;
			_this.speed = 1;
			return _this;
		}
		var _proto = AnimationComponent.prototype;
		_proto.play = function play(name, blendTime) {
			if (blendTime === void 0) {
				blendTime = 0;
			}
			if (!this.enabled || !this.entity.enabled) {
				return;
			}
			if (!this.animations[name]) {
				return;
			}
			this.prevAnim = this.currAnim;
			this.currAnim = name;
			if (this.model) {
				if (!this.skeleton && !this.animEvaluator) {
					this._createAnimationController();
				}
				var prevAnim = this.animations[this.prevAnim];
				var currAnim = this.animations[this.currAnim];
				this.blending = blendTime > 0 && !!this.prevAnim;
				if (this.blending) {
					this.blend = 0;
					this.blendSpeed = 1 / blendTime;
				}
				if (this.skeleton) {
					if (this.blending) {
						this.fromSkel.animation = prevAnim;
						this.fromSkel.addTime(this.skeleton._time);
						this.toSkel.animation = currAnim;
					} else {
						this.skeleton.animation = currAnim;
					}
				}
				if (this.animEvaluator) {
					var animEvaluator = this.animEvaluator;
					if (this.blending) {
						while (animEvaluator.clips.length > 1) {
							animEvaluator.removeClip(0);
						}
					} else {
						this.animEvaluator.removeClips();
					}
					var clip = new AnimClip(this.animations[this.currAnim], 0, 1.0, true, this.loop);
					clip.name = this.currAnim;
					clip.blendWeight = this.blending ? 0 : 1;
					clip.reset();
					this.animEvaluator.addClip(clip);
				}
			}
			this.playing = true;
		};
		_proto.getAnimation = function getAnimation(name) {
			return this.animations[name];
		};
		_proto.setModel = function setModel(model) {
			if (model !== this.model) {
				this._resetAnimationController();
				this.model = model;
				if (this.animations && this.currAnim && this.animations[this.currAnim]) {
					this.play(this.currAnim);
				}
			}
		};
		_proto.onSetAnimations = function onSetAnimations() {
			var modelComponent = this.entity.model;
			if (modelComponent) {
				var m = modelComponent.model;
				if (m && m !== this.model) {
					this.setModel(m);
				}
			}
			if (!this.currAnim && this.activate && this.enabled && this.entity.enabled) {
				var animationNames = Object.keys(this._animations);
				if (animationNames.length > 0) {
					this.play(animationNames[0]);
				}
			}
		};
		_proto._resetAnimationController = function _resetAnimationController() {
			this.skeleton = null;
			this.fromSkel = null;
			this.toSkel = null;
			this.animEvaluator = null;
		};
		_proto._createAnimationController = function _createAnimationController() {
			var model = this.model;
			var animations = this.animations;
			var hasJson = false;
			var hasGlb = false;
			for (var animation in animations) {
				if (animations.hasOwnProperty(animation)) {
					var anim = animations[animation];
					if (anim.constructor === AnimTrack) {
						hasGlb = true;
					} else {
						hasJson = true;
					}
				}
			}
			var graph = model.getGraph();
			if (hasJson) {
				this.fromSkel = new Skeleton(graph);
				this.toSkel = new Skeleton(graph);
				this.skeleton = new Skeleton(graph);
				this.skeleton.looping = this.loop;
				this.skeleton.setGraph(graph);
			} else if (hasGlb) {
				this.animEvaluator = new AnimEvaluator(new DefaultAnimBinder(this.entity));
			}
		};
		_proto.loadAnimationAssets = function loadAnimationAssets(ids) {
			var _this2 = this;
			if (!ids || !ids.length) return;
			var assets = this.system.app.assets;
			var onAssetReady = function onAssetReady(asset) {
				if (asset.resources.length > 1) {
					for (var i = 0; i < asset.resources.length; i++) {
						_this2.animations[asset.resources[i].name] = asset.resources[i];
						_this2.animationsIndex[asset.id] = asset.resources[i].name;
					}
				} else {
					_this2.animations[asset.name] = asset.resource;
					_this2.animationsIndex[asset.id] = asset.name;
				}
				_this2.animations = _this2.animations;
			};
			var onAssetAdd = function onAssetAdd(asset) {
				asset.off('change', _this2.onAssetChanged, _this2);
				asset.on('change', _this2.onAssetChanged, _this2);
				asset.off('remove', _this2.onAssetRemoved, _this2);
				asset.on('remove', _this2.onAssetRemoved, _this2);
				if (asset.resource) {
					onAssetReady(asset);
				} else {
					asset.once('load', onAssetReady, _this2);
					if (_this2.enabled && _this2.entity.enabled) assets.load(asset);
				}
			};
			for (var i = 0, l = ids.length; i < l; i++) {
				var asset = assets.get(ids[i]);
				if (asset) {
					onAssetAdd(asset);
				} else {
					assets.on('add:' + ids[i], onAssetAdd);
				}
			}
		};
		_proto.onAssetChanged = function onAssetChanged(asset, attribute, newValue, oldValue) {
			if (attribute === 'resource' || attribute === 'resources') {
				if (attribute === 'resources' && newValue && newValue.length === 0) {
					newValue = null;
				}
				if (newValue) {
					var restarted = false;
					if (newValue.length > 1) {
						if (oldValue && oldValue.length > 1) {
							for (var i = 0; i < oldValue.length; i++) {
								delete this.animations[oldValue[i].name];
							}
						} else {
							delete this.animations[asset.name];
						}
						restarted = false;
						for (var _i = 0; _i < newValue.length; _i++) {
							this.animations[newValue[_i].name] = newValue[_i];
							if (!restarted && this.currAnim === newValue[_i].name) {
								if (this.playing && this.enabled && this.entity.enabled) {
									restarted = true;
									this.play(newValue[_i].name);
								}
							}
						}
						if (!restarted) {
							this._stopCurrentAnimation();
							this.onSetAnimations();
						}
					} else {
						if (oldValue && oldValue.length > 1) {
							for (var _i2 = 0; _i2 < oldValue.length; _i2++) {
								delete this.animations[oldValue[_i2].name];
							}
						}
						this.animations[asset.name] = newValue[0] || newValue;
						restarted = false;
						if (this.currAnim === asset.name) {
							if (this.playing && this.enabled && this.entity.enabled) {
								restarted = true;
								this.play(asset.name);
							}
						}
						if (!restarted) {
							this._stopCurrentAnimation();
							this.onSetAnimations();
						}
					}
					this.animationsIndex[asset.id] = asset.name;
				} else {
					if (oldValue.length > 1) {
						for (var _i3 = 0; _i3 < oldValue.length; _i3++) {
							delete this.animations[oldValue[_i3].name];
							if (this.currAnim === oldValue[_i3].name) {
								this._stopCurrentAnimation();
							}
						}
					} else {
						delete this.animations[asset.name];
						if (this.currAnim === asset.name) {
							this._stopCurrentAnimation();
						}
					}
					delete this.animationsIndex[asset.id];
				}
			}
		};
		_proto.onAssetRemoved = function onAssetRemoved(asset) {
			asset.off('remove', this.onAssetRemoved, this);
			if (this.animations) {
				if (asset.resources.length > 1) {
					for (var i = 0; i < asset.resources.length; i++) {
						delete this.animations[asset.resources[i].name];
						if (this.currAnim === asset.resources[i].name) this._stopCurrentAnimation();
					}
				} else {
					delete this.animations[asset.name];
					if (this.currAnim === asset.name) this._stopCurrentAnimation();
				}
				delete this.animationsIndex[asset.id];
			}
		};
		_proto._stopCurrentAnimation = function _stopCurrentAnimation() {
			this.currAnim = null;
			this.playing = false;
			if (this.skeleton) {
				this.skeleton.currentTime = 0;
				this.skeleton.animation = null;
			}
			if (this.animEvaluator) {
				for (var i = 0; i < this.animEvaluator.clips.length; ++i) {
					this.animEvaluator.clips[i].stop();
				}
				this.animEvaluator.update(0);
				this.animEvaluator.removeClips();
			}
		};
		_proto.onEnable = function onEnable() {
			_Component.prototype.onEnable.call(this);
			var assets = this.assets;
			var registry = this.system.app.assets;
			if (assets) {
				for (var i = 0, len = assets.length; i < len; i++) {
					var asset = assets[i];
					if (!(asset instanceof Asset)) asset = registry.get(asset);
					if (asset && !asset.resource) registry.load(asset);
				}
			}
			if (this.activate && !this.currAnim) {
				var animationNames = Object.keys(this.animations);
				if (animationNames.length > 0) {
					this.play(animationNames[0]);
				}
			}
		};
		_proto.onBeforeRemove = function onBeforeRemove() {
			for (var i = 0; i < this.assets.length; i++) {
				var asset = this.assets[i];
				if (typeof asset === 'number') {
					asset = this.system.app.assets.get(asset);
				}
				if (!asset) continue;
				asset.off('change', this.onAssetChanged, this);
				asset.off('remove', this.onAssetRemoved, this);
			}
			this.skeleton = null;
			this.fromSkel = null;
			this.toSkel = null;
			this.animEvaluator = null;
		};
		_proto.update = function update(dt) {
			if (this.blending) {
				this.blend += dt * this.blendSpeed;
				if (this.blend >= 1) {
					this.blend = 1;
				}
			}
			if (this.playing) {
				var skeleton = this.skeleton;
				if (skeleton !== null && this.model !== null) {
					if (this.blending) {
						skeleton.blend(this.fromSkel, this.toSkel, this.blend);
					} else {
						var delta = dt * this.speed;
						skeleton.addTime(delta);
						if (this.speed > 0 && skeleton._time === skeleton.animation.duration && !this.loop) {
							this.playing = false;
						} else if (this.speed < 0 && skeleton._time === 0 && !this.loop) {
							this.playing = false;
						}
					}
					if (this.blending && this.blend === 1) {
						skeleton.animation = this.toSkel.animation;
					}
					skeleton.updateGraph();
				}
			}
			var animEvaluator = this.animEvaluator;
			if (animEvaluator) {
				for (var i = 0; i < animEvaluator.clips.length; ++i) {
					var clip = animEvaluator.clips[i];
					clip.speed = this.speed;
					if (!this.playing) {
						clip.pause();
					} else {
						clip.resume();
					}
				}
				if (this.blending && animEvaluator.clips.length > 1) {
					animEvaluator.clips[1].blendWeight = this.blend;
				}
				animEvaluator.update(dt);
			}
			if (this.blending && this.blend === 1) {
				this.blending = false;
			}
		};
		_createClass(AnimationComponent, [{
			key: "animations",
			get: function get() {
				return this._animations;
			},
			set: function set(value) {
				this._animations = value;
				this.onSetAnimations();
			}
		}, {
			key: "assets",
			get: function get() {
				return this._assets;
			},
			set: function set(value) {
				var assets = this._assets;
				if (assets && assets.length) {
					for (var i = 0; i < assets.length; i++) {
						if (assets[i]) {
							var asset = this.system.app.assets.get(assets[i]);
							if (asset) {
								asset.off('change', this.onAssetChanged, this);
								asset.off('remove', this.onAssetRemoved, this);
								var animName = this.animationsIndex[asset.id];
								if (this.currAnim === animName) this._stopCurrentAnimation();
								delete this.animations[animName];
								delete this.animationsIndex[asset.id];
							}
						}
					}
				}
				this._assets = value;
				var assetIds = value.map(function (value) {
					return value instanceof Asset ? value.id : value;
				});
				this.loadAnimationAssets(assetIds);
			}
		}, {
			key: "currentTime",
			get: function get() {
				if (this.skeleton) {
					return this.skeleton._time;
				}
				if (this.animEvaluator) {
					var clips = this.animEvaluator.clips;
					if (clips.length > 0) {
						return clips[clips.length - 1].time;
					}
				}
				return 0;
			},
			set: function set(currentTime) {
				if (this.skeleton) {
					this.skeleton.currentTime = currentTime;
					this.skeleton.addTime(0);
					this.skeleton.updateGraph();
				}
				if (this.animEvaluator) {
					var clips = this.animEvaluator.clips;
					for (var i = 0; i < clips.length; ++i) {
						clips[i].time = currentTime;
					}
				}
			}
		}, {
			key: "duration",
			get: function get() {
				if (this.currAnim) {
					return this.animations[this.currAnim].duration;
				}
				return 0;
			}
		}, {
			key: "loop",
			get: function get() {
				return this._loop;
			},
			set: function set(value) {
				this._loop = value;
				if (this.skeleton) {
					this.skeleton.looping = value;
				}
				if (this.animEvaluator) {
					for (var i = 0; i < this.animEvaluator.clips.length; ++i) {
						this.animEvaluator.clips[i].loop = value;
					}
				}
			}
		}]);
		return AnimationComponent;
	}(Component);

	var AnimationComponentData = function AnimationComponentData() {
		this.enabled = true;
	};

	var _schema$l = ['enabled'];
	var AnimationComponentSystem = function (_ComponentSystem) {
		_inheritsLoose(AnimationComponentSystem, _ComponentSystem);
		function AnimationComponentSystem(app) {
			var _this;
			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'animation';
			_this.ComponentType = AnimationComponent;
			_this.DataType = AnimationComponentData;
			_this.schema = _schema$l;
			_this.on('beforeremove', _this.onBeforeRemove, _assertThisInitialized(_this));
			_this.app.systems.on('update', _this.onUpdate, _assertThisInitialized(_this));
			return _this;
		}
		var _proto = AnimationComponentSystem.prototype;
		_proto.initializeComponentData = function initializeComponentData(component, data, properties) {
			properties = ['activate', 'enabled', 'loop', 'speed', 'assets'];
			for (var _iterator = _createForOfIteratorHelperLoose(properties), _step; !(_step = _iterator()).done;) {
				var property = _step.value;
				if (data.hasOwnProperty(property)) {
					component[property] = data[property];
				}
			}
			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, _schema$l);
		};
		_proto.cloneComponent = function cloneComponent(entity, clone) {
			this.addComponent(clone, {});
			clone.animation.assets = entity.animation.assets.slice();
			clone.animation.speed = entity.animation.speed;
			clone.animation.loop = entity.animation.loop;
			clone.animation.activate = entity.animation.activate;
			clone.animation.enabled = entity.animation.enabled;
			var clonedAnimations = {};
			var animations = entity.animation.animations;
			for (var key in animations) {
				if (animations.hasOwnProperty(key)) {
					clonedAnimations[key] = animations[key];
				}
			}
			clone.animation.animations = clonedAnimations;
			var clonedAnimationsIndex = {};
			var animationsIndex = entity.animation.animationsIndex;
			for (var _key in animationsIndex) {
				if (animationsIndex.hasOwnProperty(_key)) {
					clonedAnimationsIndex[_key] = animationsIndex[_key];
				}
			}
			clone.animation.animationsIndex = clonedAnimationsIndex;
			return clone.animation;
		};
		_proto.onBeforeRemove = function onBeforeRemove(entity, component) {
			component.onBeforeRemove();
		};
		_proto.onUpdate = function onUpdate(dt) {
			var components = this.store;
			for (var id in components) {
				if (components.hasOwnProperty(id)) {
					var component = components[id];
					if (component.data.enabled && component.entity.enabled) {
						component.entity.animation.update(dt);
					}
				}
			}
		};
		_proto.destroy = function destroy() {
			_ComponentSystem.prototype.destroy.call(this);
			this.app.systems.off('update', this.onUpdate, this);
		};
		return AnimationComponentSystem;
	}(ComponentSystem);
	Component._buildAccessors(AnimationComponent.prototype, _schema$l);

	var AnimNode = function () {
		function AnimNode(state, parent, name, point, speed) {
			if (speed === void 0) {
				speed = 1;
			}
			this._state = state;
			this._parent = parent;
			this._name = name;
			if (Array.isArray(point)) {
				this._point = new Vec2(point[0], point[1]);
				this._pointLength = this._point.length();
			} else {
				this._point = point;
				this._pointLength = point;
			}
			this._speed = speed;
			this._weightedSpeed = 1.0;
			this._weight = 1.0;
			this._animTrack = null;
		}
		_createClass(AnimNode, [{
			key: "parent",
			get: function get() {
				return this._parent;
			}
		}, {
			key: "name",
			get: function get() {
				return this._name;
			}
		}, {
			key: "path",
			get: function get() {
				return this._parent ? this._parent.path + '.' + this._name : this._name;
			}
		}, {
			key: "point",
			get: function get() {
				return this._point;
			}
		}, {
			key: "pointLength",
			get: function get() {
				return this._pointLength;
			}
		}, {
			key: "weight",
			get: function get() {
				return this._parent ? this._parent.weight * this._weight : this._weight;
			},
			set: function set(value) {
				this._weight = value;
			}
		}, {
			key: "normalizedWeight",
			get: function get() {
				var totalWeight = this._state.totalWeight;
				if (totalWeight === 0.0) return 0.0;
				return this.weight / totalWeight;
			}
		}, {
			key: "speed",
			get: function get() {
				return this._weightedSpeed * this._speed;
			}
		}, {
			key: "absoluteSpeed",
			get: function get() {
				return Math.abs(this._speed);
			}
		}, {
			key: "weightedSpeed",
			get: function get() {
				return this._weightedSpeed;
			},
			set: function set(weightedSpeed) {
				this._weightedSpeed = weightedSpeed;
			}
		}, {
			key: "animTrack",
			get: function get() {
				return this._animTrack;
			},
			set: function set(value) {
				this._animTrack = value;
			}
		}]);
		return AnimNode;
	}();

	var AnimBlendTree = function (_AnimNode) {
		_inheritsLoose(AnimBlendTree, _AnimNode);
		function AnimBlendTree(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter) {
			var _this;
			_this = _AnimNode.call(this, state, parent, name, point) || this;
			_this._parameters = parameters;
			_this._parameterValues = new Array(parameters.length);
			_this._children = [];
			_this._findParameter = findParameter;
			_this._syncAnimations = syncAnimations !== false;
			_this._pointCache = {};
			for (var i = 0; i < children.length; i++) {
				var child = children[i];
				if (child.children) {
					_this._children.push(createTree(child.type, _assertThisInitialized(_this), null, name, 1.0, child.parameter ? [child.parameter] : child.parameters, child.children, createTree, findParameter));
				} else {
					_this._children.push(new AnimNode(state, _assertThisInitialized(_this), child.name, child.point, child.speed));
				}
			}
			return _this;
		}
		var _proto = AnimBlendTree.prototype;
		_proto.getChild = function getChild(name) {
			for (var i = 0; i < this._children.length; i++) {
				if (this._children[i].name === name) return this._children[i];
			}
			return null;
		};
		_proto.updateParameterValues = function updateParameterValues() {
			var paramsEqual = true;
			for (var i = 0; i < this._parameterValues.length; i++) {
				var updatedParameter = this._findParameter(this._parameters[i]).value;
				if (this._parameterValues[i] !== updatedParameter) {
					this._parameterValues[i] = updatedParameter;
					paramsEqual = false;
				}
			}
			return paramsEqual;
		};
		_proto.getNodeWeightedDuration = function getNodeWeightedDuration(i) {
			return this._children[i].animTrack.duration / this._children[i].speedMultiplier * this._children[i].weight;
		};
		_proto.getNodeCount = function getNodeCount() {
			var count = 0;
			for (var i = 0; i < this._children.length; i++) {
				var child = this._children[i];
				if (child.constructor === AnimBlendTree) {
					count += this._children[i].getNodeCount();
				} else {
					count++;
				}
			}
			return count;
		};
		_createClass(AnimBlendTree, [{
			key: "weight",
			get: function get() {
				this.calculateWeights();
				return this._parent ? this._parent.weight * this._weight : this._weight;
			}
		}, {
			key: "syncAnimations",
			get: function get() {
				return this._syncAnimations;
			}
		}]);
		return AnimBlendTree;
	}(AnimNode);

	var AnimBlendTree1D = function (_AnimBlendTree) {
		_inheritsLoose(AnimBlendTree1D, _AnimBlendTree);
		function AnimBlendTree1D(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter) {
			children.sort(function (a, b) {
				return a.point - b.point;
			});
			return _AnimBlendTree.call(this, state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter) || this;
		}
		var _proto = AnimBlendTree1D.prototype;
		_proto.calculateWeights = function calculateWeights() {
			if (this.updateParameterValues()) return;
			var weightedDurationSum = 0.0;
			this._children[0].weight = 0.0;
			for (var i = 0; i < this._children.length; i++) {
				var c1 = this._children[i];
				if (i !== this._children.length - 1) {
					var c2 = this._children[i + 1];
					if (c1.point === c2.point) {
						c1.weight = 0.5;
						c2.weight = 0.5;
					} else if (math.between(this._parameterValues[0], c1.point, c2.point, true)) {
						var child2Distance = Math.abs(c1.point - c2.point);
						var parameterDistance = Math.abs(c1.point - this._parameterValues[0]);
						var weight = (child2Distance - parameterDistance) / child2Distance;
						c1.weight = weight;
						c2.weight = 1.0 - weight;
					} else {
						c2.weight = 0.0;
					}
				}
				if (this._syncAnimations) {
					weightedDurationSum += c1.animTrack.duration / c1.absoluteSpeed * c1.weight;
				}
			}
			if (this._syncAnimations) {
				for (var _i = 0; _i < this._children.length; _i++) {
					var child = this._children[_i];
					child.weightedSpeed = child.animTrack.duration / child.absoluteSpeed / weightedDurationSum;
				}
			}
		};
		return AnimBlendTree1D;
	}(AnimBlendTree);

	var AnimBlendTreeCartesian2D = function (_AnimBlendTree) {
		_inheritsLoose(AnimBlendTreeCartesian2D, _AnimBlendTree);
		function AnimBlendTreeCartesian2D() {
			return _AnimBlendTree.apply(this, arguments) || this;
		}
		var _proto = AnimBlendTreeCartesian2D.prototype;
		_proto.pointDistanceCache = function pointDistanceCache(i, j) {
			var pointKey = "" + i + j;
			if (!this._pointCache[pointKey]) {
				this._pointCache[pointKey] = this._children[j].point.clone().sub(this._children[i].point);
			}
			return this._pointCache[pointKey];
		};
		_proto.calculateWeights = function calculateWeights() {
			var _AnimBlendTreeCartesi;
			if (this.updateParameterValues()) return;
			var weightSum, weightedDurationSum;
			(_AnimBlendTreeCartesi = AnimBlendTreeCartesian2D._p).set.apply(_AnimBlendTreeCartesi, this._parameterValues);
			weightSum = 0.0;
			weightedDurationSum = 0.0;
			for (var i = 0; i < this._children.length; i++) {
				var child = this._children[i];
				var pi = child.point;
				AnimBlendTreeCartesian2D._pip.set(AnimBlendTreeCartesian2D._p.x, AnimBlendTreeCartesian2D._p.y).sub(pi);
				var minj = Number.MAX_VALUE;
				for (var j = 0; j < this._children.length; j++) {
					if (i === j) continue;
					var pipj = this.pointDistanceCache(i, j);
					var result = math.clamp(1.0 - AnimBlendTreeCartesian2D._pip.dot(pipj) / pipj.lengthSq(), 0.0, 1.0);
					if (result < minj) minj = result;
				}
				child.weight = minj;
				weightSum += minj;
				if (this._syncAnimations) {
					weightedDurationSum += child.animTrack.duration / child.absoluteSpeed * child.weight;
				}
			}
			for (var _i = 0; _i < this._children.length; _i++) {
				var _child = this._children[_i];
				_child.weight = _child._weight / weightSum;
				if (this._syncAnimations) {
					_child.weightedSpeed = _child.animTrack.duration / _child.absoluteSpeed / weightedDurationSum;
				}
			}
		};
		return AnimBlendTreeCartesian2D;
	}(AnimBlendTree);
	AnimBlendTreeCartesian2D._p = new Vec2();
	AnimBlendTreeCartesian2D._pip = new Vec2();

	var AnimBlendTreeDirectional2D = function (_AnimBlendTree) {
		_inheritsLoose(AnimBlendTreeDirectional2D, _AnimBlendTree);
		function AnimBlendTreeDirectional2D() {
			return _AnimBlendTree.apply(this, arguments) || this;
		}
		var _proto = AnimBlendTreeDirectional2D.prototype;
		_proto.pointCache = function pointCache(i, j) {
			var pointKey = "" + i + j;
			if (!this._pointCache[pointKey]) {
				this._pointCache[pointKey] = new Vec2((this._children[j].pointLength - this._children[i].pointLength) / ((this._children[j].pointLength + this._children[i].pointLength) / 2), Vec2.angleRad(this._children[i].point, this._children[j].point) * 2.0);
			}
			return this._pointCache[pointKey];
		};
		_proto.calculateWeights = function calculateWeights() {
			var _AnimBlendTreeDirecti;
			if (this.updateParameterValues()) return;
			var weightSum, weightedDurationSum;
			(_AnimBlendTreeDirecti = AnimBlendTreeDirectional2D._p).set.apply(_AnimBlendTreeDirecti, this._parameterValues);
			var pLength = AnimBlendTreeDirectional2D._p.length();
			weightSum = 0.0;
			weightedDurationSum = 0.0;
			for (var i = 0; i < this._children.length; i++) {
				var child = this._children[i];
				var pi = child.point;
				var piLength = child.pointLength;
				var minj = Number.MAX_VALUE;
				for (var j = 0; j < this._children.length; j++) {
					if (i === j) continue;
					var pipj = this.pointCache(i, j);
					var pjLength = this._children[j].pointLength;
					AnimBlendTreeDirectional2D._pip.set((pLength - piLength) / ((pjLength + piLength) / 2), Vec2.angleRad(pi, AnimBlendTreeDirectional2D._p) * 2.0);
					var result = math.clamp(1.0 - Math.abs(AnimBlendTreeDirectional2D._pip.dot(pipj) / pipj.lengthSq()), 0.0, 1.0);
					if (result < minj) minj = result;
				}
				child.weight = minj;
				weightSum += minj;
				if (this._syncAnimations) {
					weightedDurationSum += child.animTrack.duration / child.absoluteSpeed * child.weight;
				}
			}
			for (var _i = 0; _i < this._children.length; _i++) {
				var _child = this._children[_i];
				_child.weight = _child._weight / weightSum;
				if (this._syncAnimations) {
					var weightedChildDuration = _child.animTrack.duration / weightedDurationSum * weightSum;
					_child.weightedSpeed = _child.absoluteSpeed * weightedChildDuration;
				}
			}
		};
		return AnimBlendTreeDirectional2D;
	}(AnimBlendTree);
	AnimBlendTreeDirectional2D._p = new Vec2();
	AnimBlendTreeDirectional2D._pip = new Vec2();

	var AnimBlendTreeDirect = function (_AnimBlendTree) {
		_inheritsLoose(AnimBlendTreeDirect, _AnimBlendTree);
		function AnimBlendTreeDirect() {
			return _AnimBlendTree.apply(this, arguments) || this;
		}
		var _proto = AnimBlendTreeDirect.prototype;
		_proto.calculateWeights = function calculateWeights() {
			if (this.updateParameterValues()) return;
			var weightSum = 0.0;
			var weightedDurationSum = 0.0;
			for (var i = 0; i < this._children.length; i++) {
				weightSum += Math.max(this._parameterValues[i], 0.0);
				if (this._syncAnimations) {
					var child = this._children[i];
					weightedDurationSum += child.animTrack.duration / child.absoluteSpeed * child.weight;
				}
			}
			for (var _i = 0; _i < this._children.length; _i++) {
				var _child = this._children[_i];
				var weight = Math.max(this._parameterValues[_i], 0.0);
				if (weightSum) {
					_child.weight = weight / weightSum;
					if (this._syncAnimations) {
						_child.weightedSpeed = _child.animTrack.duration / _child.absoluteSpeed / weightedDurationSum;
					}
				} else {
					_child.weight = 0.0;
					if (this._syncAnimations) {
						_child.weightedSpeed = 0;
					}
				}
			}
		};
		return AnimBlendTreeDirect;
	}(AnimBlendTree);

	var AnimState = function () {
		function AnimState(controller, name, speed, loop, blendTree) {
			if (speed === void 0) {
				speed = 1;
			}
			if (loop === void 0) {
				loop = true;
			}
			this._animations = {};
			this._animationList = [];
			this._controller = controller;
			this._name = name;
			this._speed = speed;
			this._loop = loop;
			this._hasAnimations = false;
			if (blendTree) {
				this._blendTree = this._createTree(blendTree.type, this, null, name, 1.0, blendTree.parameter ? [blendTree.parameter] : blendTree.parameters, blendTree.children, blendTree.syncAnimations, this._createTree, this._controller.findParameter);
			} else {
				this._blendTree = new AnimNode(this, null, name, 1.0, speed);
			}
		}
		var _proto = AnimState.prototype;
		_proto._createTree = function _createTree(type, state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter) {
			switch (type) {
				case ANIM_BLEND_1D:
					return new AnimBlendTree1D(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);
				case ANIM_BLEND_2D_CARTESIAN:
					return new AnimBlendTreeCartesian2D(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);
				case ANIM_BLEND_2D_DIRECTIONAL:
					return new AnimBlendTreeDirectional2D(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);
				case ANIM_BLEND_DIRECT:
					return new AnimBlendTreeDirect(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);
			}
			return undefined;
		};
		_proto._getNodeFromPath = function _getNodeFromPath(path) {
			var currNode = this._blendTree;
			for (var i = 1; i < path.length; i++) {
				currNode = currNode.getChild(path[i]);
			}
			return currNode;
		};
		_proto.addAnimation = function addAnimation(path, animTrack) {
			var pathString = path.join('.');
			var indexOfAnimation = this._animationList.findIndex(function (animation) {
				return animation.path === pathString;
			});
			if (indexOfAnimation >= 0) {
				this._animationList[indexOfAnimation].animTrack = animTrack;
			} else {
				var node = this._getNodeFromPath(path);
				node.animTrack = animTrack;
				this._animationList.push(node);
			}
			this._updateHasAnimations();
		};
		_proto._updateHasAnimations = function _updateHasAnimations() {
			this._hasAnimations = this._animationList.length > 0 && this._animationList.every(function (animation) {
				return animation.animTrack && animation.animTrack !== AnimTrack.EMPTY;
			});
		};
		_createClass(AnimState, [{
			key: "name",
			get: function get() {
				return this._name;
			}
		}, {
			key: "animations",
			get: function get() {
				return this._animationList;
			},
			set: function set(value) {
				this._animationList = value;
				this._updateHasAnimations();
			}
		}, {
			key: "hasAnimations",
			get: function get() {
				return this._hasAnimations;
			}
		}, {
			key: "speed",
			get: function get() {
				return this._speed;
			},
			set: function set(value) {
				this._speed = value;
			}
		}, {
			key: "loop",
			get: function get() {
				return this._loop;
			},
			set: function set(value) {
				this._loop = value;
			}
		}, {
			key: "nodeCount",
			get: function get() {
				if (!this._blendTree || this._blendTree.constructor === AnimNode) return 1;
				return this._blendTree.getNodeCount();
			}
		}, {
			key: "playable",
			get: function get() {
				return ANIM_CONTROL_STATES.indexOf(this.name) !== -1 || this.animations.length === this.nodeCount;
			}
		}, {
			key: "looping",
			get: function get() {
				if (this.animations.length > 0) {
					var trackClipName = this.name + '.' + this.animations[0].animTrack.name;
					var trackClip = this._controller.animEvaluator.findClip(trackClipName);
					if (trackClip) {
						return trackClip.loop;
					}
				}
				return false;
			}
		}, {
			key: "totalWeight",
			get: function get() {
				var sum = 0;
				for (var i = 0; i < this.animations.length; i++) {
					sum += this.animations[i].weight;
				}
				return sum;
			}
		}, {
			key: "timelineDuration",
			get: function get() {
				var duration = 0;
				for (var i = 0; i < this.animations.length; i++) {
					var animation = this.animations[i];
					if (animation.animTrack.duration > duration) {
						duration = animation.animTrack.duration;
					}
				}
				return duration;
			}
		}]);
		return AnimState;
	}();

	var AnimTransition = function () {
		function AnimTransition(_ref) {
			var from = _ref.from,
				to = _ref.to,
				_ref$time = _ref.time,
				time = _ref$time === void 0 ? 0 : _ref$time,
				_ref$priority = _ref.priority,
				priority = _ref$priority === void 0 ? 0 : _ref$priority,
				_ref$conditions = _ref.conditions,
				conditions = _ref$conditions === void 0 ? [] : _ref$conditions,
				_ref$exitTime = _ref.exitTime,
				exitTime = _ref$exitTime === void 0 ? null : _ref$exitTime,
				_ref$transitionOffset = _ref.transitionOffset,
				transitionOffset = _ref$transitionOffset === void 0 ? null : _ref$transitionOffset,
				_ref$interruptionSour = _ref.interruptionSource,
				interruptionSource = _ref$interruptionSour === void 0 ? ANIM_INTERRUPTION_NONE : _ref$interruptionSour;
			this._from = from;
			this._to = to;
			this._time = time;
			this._priority = priority;
			this._conditions = conditions;
			this._exitTime = exitTime;
			this._transitionOffset = transitionOffset;
			this._interruptionSource = interruptionSource;
		}
		_createClass(AnimTransition, [{
			key: "from",
			get: function get() {
				return this._from;
			}
		}, {
			key: "to",
			get: function get() {
				return this._to;
			},
			set: function set(value) {
				this._to = value;
			}
		}, {
			key: "time",
			get: function get() {
				return this._time;
			}
		}, {
			key: "priority",
			get: function get() {
				return this._priority;
			}
		}, {
			key: "conditions",
			get: function get() {
				return this._conditions;
			}
		}, {
			key: "exitTime",
			get: function get() {
				return this._exitTime;
			}
		}, {
			key: "transitionOffset",
			get: function get() {
				return this._transitionOffset;
			}
		}, {
			key: "interruptionSource",
			get: function get() {
				return this._interruptionSource;
			}
		}, {
			key: "hasExitTime",
			get: function get() {
				return !!this.exitTime;
			}
		}]);
		return AnimTransition;
	}();

	var AnimController = function () {
		function AnimController(animEvaluator, states, transitions, activate, eventHandler, findParameter, consumeTrigger) {
			var _this = this;
			this.findParameter = function (name) {
				return _this._findParameter(name);
			};
			this._animEvaluator = animEvaluator;
			this._states = {};
			this._stateNames = [];
			this._eventHandler = eventHandler;
			this._findParameter = findParameter;
			this._consumeTrigger = consumeTrigger;
			for (var i = 0; i < states.length; i++) {
				this._states[states[i].name] = new AnimState(this, states[i].name, states[i].speed, states[i].loop, states[i].blendTree);
				this._stateNames.push(states[i].name);
			}
			this._transitions = transitions.map(function (transition) {
				return new AnimTransition(_extends({}, transition));
			});
			this._findTransitionsFromStateCache = {};
			this._findTransitionsBetweenStatesCache = {};
			this._previousStateName = null;
			this._activeStateName = ANIM_STATE_START;
			this._activeStateDuration = 0.0;
			this._activeStateDurationDirty = true;
			this._playing = false;
			this._activate = activate;
			this._currTransitionTime = 1.0;
			this._totalTransitionTime = 1.0;
			this._isTransitioning = false;
			this._transitionInterruptionSource = ANIM_INTERRUPTION_NONE;
			this._transitionPreviousStates = [];
			this._timeInState = 0;
			this._timeInStateBefore = 0;
		}
		var _proto = AnimController.prototype;
		_proto.assignMask = function assignMask(mask) {
			return this._animEvaluator.assignMask(mask);
		};
		_proto._findState = function _findState(stateName) {
			return this._states[stateName];
		};
		_proto._getActiveStateProgressForTime = function _getActiveStateProgressForTime(time) {
			if (this.activeStateName === ANIM_STATE_START || this.activeStateName === ANIM_STATE_END || this.activeStateName === ANIM_STATE_ANY) return 1.0;
			var activeClip = this._animEvaluator.findClip(this.activeStateAnimations[0].name);
			if (activeClip) {
				return activeClip.progressForTime(time);
			}
			return null;
		};
		_proto._findTransitionsFromState = function _findTransitionsFromState(stateName) {
			var transitions = this._findTransitionsFromStateCache[stateName];
			if (!transitions) {
				transitions = this._transitions.filter(function (transition) {
					return transition.from === stateName;
				});
				sortPriority(transitions);
				this._findTransitionsFromStateCache[stateName] = transitions;
			}
			return transitions;
		};
		_proto._findTransitionsBetweenStates = function _findTransitionsBetweenStates(sourceStateName, destinationStateName) {
			var transitions = this._findTransitionsBetweenStatesCache[sourceStateName + '->' + destinationStateName];
			if (!transitions) {
				transitions = this._transitions.filter(function (transition) {
					return transition.from === sourceStateName && transition.to === destinationStateName;
				});
				sortPriority(transitions);
				this._findTransitionsBetweenStatesCache[sourceStateName + '->' + destinationStateName] = transitions;
			}
			return transitions;
		};
		_proto._transitionHasConditionsMet = function _transitionHasConditionsMet(transition) {
			var conditions = transition.conditions;
			for (var i = 0; i < conditions.length; i++) {
				var condition = conditions[i];
				var parameter = this._findParameter(condition.parameterName);
				switch (condition.predicate) {
					case ANIM_GREATER_THAN:
						if (!(parameter.value > condition.value)) return false;
						break;
					case ANIM_LESS_THAN:
						if (!(parameter.value < condition.value)) return false;
						break;
					case ANIM_GREATER_THAN_EQUAL_TO:
						if (!(parameter.value >= condition.value)) return false;
						break;
					case ANIM_LESS_THAN_EQUAL_TO:
						if (!(parameter.value <= condition.value)) return false;
						break;
					case ANIM_EQUAL_TO:
						if (!(parameter.value === condition.value)) return false;
						break;
					case ANIM_NOT_EQUAL_TO:
						if (!(parameter.value !== condition.value)) return false;
						break;
				}
			}
			return true;
		};
		_proto._findTransition = function _findTransition(from, to) {
			var _this2 = this;
			var transitions = [];
			if (from && to) {
				transitions = transitions.concat(this._findTransitionsBetweenStates(from, to));
			} else {
				if (!this._isTransitioning) {
					transitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));
					transitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));
				} else {
					switch (this._transitionInterruptionSource) {
						case ANIM_INTERRUPTION_PREV:
							transitions = transitions.concat(this._findTransitionsFromState(this._previousStateName));
							transitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));
							break;
						case ANIM_INTERRUPTION_NEXT:
							transitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));
							transitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));
							break;
						case ANIM_INTERRUPTION_PREV_NEXT:
							transitions = transitions.concat(this._findTransitionsFromState(this._previousStateName));
							transitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));
							transitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));
							break;
						case ANIM_INTERRUPTION_NEXT_PREV:
							transitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));
							transitions = transitions.concat(this._findTransitionsFromState(this._previousStateName));
							transitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));
							break;
					}
				}
			}
			transitions = transitions.filter(function (transition) {
				if (transition.to === _this2.activeStateName) {
					return false;
				}
				if (transition.hasExitTime) {
					var progressBefore = _this2._getActiveStateProgressForTime(_this2._timeInStateBefore);
					var progress = _this2._getActiveStateProgressForTime(_this2._timeInState);
					if (transition.exitTime < 1.0 && _this2.activeState.loop) {
						progressBefore -= Math.floor(progressBefore);
						progress -= Math.floor(progress);
					}
					if (progress === progressBefore) {
						if (progress !== transition.exitTime) {
							return null;
						}
					} else if (!(transition.exitTime > progressBefore && transition.exitTime <= progress)) {
						return null;
					}
				}
				return _this2._transitionHasConditionsMet(transition);
			});
			if (transitions.length > 0) {
				var transition = transitions[0];
				if (transition.to === ANIM_STATE_END) {
					var startTransition = this._findTransitionsFromState(ANIM_STATE_START)[0];
					transition.to = startTransition.to;
				}
				return transition;
			}
			return null;
		};
		_proto.updateStateFromTransition = function updateStateFromTransition(transition) {
			var state;
			var animation;
			var clip;
			this.previousState = transition.from ? this.activeStateName : null;
			this.activeState = transition.to;
			this._activeStateDurationDirty = true;
			for (var i = 0; i < transition.conditions.length; i++) {
				var condition = transition.conditions[i];
				var parameter = this._findParameter(condition.parameterName);
				if (parameter.type === ANIM_PARAMETER_TRIGGER) {
					this._consumeTrigger(condition.parameterName);
				}
			}
			if (this.previousState) {
				if (!this._isTransitioning) {
					this._transitionPreviousStates = [];
				}
				this._transitionPreviousStates.push({
					name: this._previousStateName,
					weight: 1
				});
				var interpolatedTime = Math.min(this._totalTransitionTime !== 0 ? this._currTransitionTime / this._totalTransitionTime : 1, 1.0);
				for (var _i = 0; _i < this._transitionPreviousStates.length; _i++) {
					if (!this._isTransitioning) {
						this._transitionPreviousStates[_i].weight = 1.0;
					} else if (_i !== this._transitionPreviousStates.length - 1) {
						this._transitionPreviousStates[_i].weight *= 1.0 - interpolatedTime;
					} else {
						this._transitionPreviousStates[_i].weight = interpolatedTime;
					}
					state = this._findState(this._transitionPreviousStates[_i].name);
					for (var j = 0; j < state.animations.length; j++) {
						animation = state.animations[j];
						clip = this._animEvaluator.findClip(animation.name + '.previous.' + _i);
						if (!clip) {
							clip = this._animEvaluator.findClip(animation.name);
							clip.name = animation.name + '.previous.' + _i;
						}
						if (_i !== this._transitionPreviousStates.length - 1) {
							clip.pause();
						}
					}
				}
			}
			this._isTransitioning = true;
			this._totalTransitionTime = transition.time;
			this._currTransitionTime = 0;
			this._transitionInterruptionSource = transition.interruptionSource;
			var activeState = this.activeState;
			var hasTransitionOffset = transition.transitionOffset && transition.transitionOffset > 0.0 && transition.transitionOffset < 1.0;
			var timeInState = 0;
			var timeInStateBefore = 0;
			if (hasTransitionOffset) {
				var offsetTime = activeState.timelineDuration * transition.transitionOffset;
				timeInState = offsetTime;
				timeInStateBefore = offsetTime;
			}
			this._timeInState = timeInState;
			this._timeInStateBefore = timeInStateBefore;
			for (var _i2 = 0; _i2 < activeState.animations.length; _i2++) {
				clip = this._animEvaluator.findClip(activeState.animations[_i2].name);
				if (!clip) {
					var speed = Number.isFinite(activeState.animations[_i2].speed) ? activeState.animations[_i2].speed : activeState.speed;
					clip = new AnimClip(activeState.animations[_i2].animTrack, this._timeInState, speed, true, activeState.loop, this._eventHandler);
					clip.name = activeState.animations[_i2].name;
					this._animEvaluator.addClip(clip);
				} else {
					clip.reset();
				}
				if (transition.time > 0) {
					clip.blendWeight = 0.0;
				} else {
					clip.blendWeight = activeState.animations[_i2].normalizedWeight;
				}
				clip.play();
				if (hasTransitionOffset) {
					clip.time = activeState.timelineDuration * transition.transitionOffset;
				} else {
					var startTime = activeState.speed >= 0 ? 0 : this.activeStateDuration;
					clip.time = startTime;
				}
			}
		};
		_proto._transitionToState = function _transitionToState(newStateName) {
			if (!this._findState(newStateName)) {
				return;
			}
			var transition = this._findTransition(this._activeStateName, newStateName);
			if (!transition) {
				this._animEvaluator.removeClips();
				transition = new AnimTransition({
					from: null,
					to: newStateName
				});
			}
			this.updateStateFromTransition(transition);
		};
		_proto.assignAnimation = function assignAnimation(pathString, animTrack, speed, loop) {
			var path = pathString.split('.');
			var state = this._findState(path[0]);
			if (!state) {
				state = new AnimState(this, path[0], speed);
				this._states[path[0]] = state;
				this._stateNames.push(path[0]);
			}
			state.addAnimation(path, animTrack);
			this._animEvaluator.updateClipTrack(state.name, animTrack);
			if (speed !== undefined) {
				state.speed = speed;
			}
			if (loop !== undefined) {
				state.loop = loop;
			}
			if (!this._playing && this._activate && this.playable) {
				this.play();
			}
			this._activeStateDurationDirty = true;
		};
		_proto.removeNodeAnimations = function removeNodeAnimations(nodeName) {
			if (ANIM_CONTROL_STATES.indexOf(nodeName) !== -1) {
				return false;
			}
			var state = this._findState(nodeName);
			if (!state) {
				return false;
			}
			state.animations = [];
			return true;
		};
		_proto.play = function play(stateName) {
			if (stateName) {
				this._transitionToState(stateName);
			}
			this._playing = true;
		};
		_proto.pause = function pause() {
			this._playing = false;
		};
		_proto.reset = function reset() {
			this._previousStateName = null;
			this._activeStateName = ANIM_STATE_START;
			this._playing = false;
			this._currTransitionTime = 1.0;
			this._totalTransitionTime = 1.0;
			this._isTransitioning = false;
			this._timeInState = 0;
			this._timeInStateBefore = 0;
			this._animEvaluator.removeClips();
		};
		_proto.rebind = function rebind() {
			this._animEvaluator.rebind();
		};
		_proto.update = function update(dt) {
			if (!this._playing) {
				return;
			}
			var state;
			var animation;
			var clip;
			if (this.activeState.loop || this._timeInState < this.activeStateDuration) {
				this._timeInStateBefore = this._timeInState;
				this._timeInState += dt * this.activeState.speed;
				if (!this.activeState.loop && this._timeInState > this.activeStateDuration) {
					this._timeInState = this.activeStateDuration;
					dt = this.activeStateDuration - this._timeInStateBefore;
				}
			}
			var transition = this._findTransition(this._activeStateName);
			if (transition) this.updateStateFromTransition(transition);
			if (this._isTransitioning) {
				this._currTransitionTime += dt;
				if (this._currTransitionTime <= this._totalTransitionTime) {
					var interpolatedTime = this._totalTransitionTime !== 0 ? this._currTransitionTime / this._totalTransitionTime : 1;
					for (var i = 0; i < this._transitionPreviousStates.length; i++) {
						state = this._findState(this._transitionPreviousStates[i].name);
						var stateWeight = this._transitionPreviousStates[i].weight;
						for (var j = 0; j < state.animations.length; j++) {
							animation = state.animations[j];
							clip = this._animEvaluator.findClip(animation.name + '.previous.' + i);
							if (clip) {
								clip.blendWeight = (1.0 - interpolatedTime) * animation.normalizedWeight * stateWeight;
							}
						}
					}
					state = this.activeState;
					for (var _i3 = 0; _i3 < state.animations.length; _i3++) {
						animation = state.animations[_i3];
						this._animEvaluator.findClip(animation.name).blendWeight = interpolatedTime * animation.normalizedWeight;
					}
				} else {
					this._isTransitioning = false;
					var activeClips = this.activeStateAnimations.length;
					var totalClips = this._animEvaluator.clips.length;
					for (var _i4 = 0; _i4 < totalClips - activeClips; _i4++) {
						this._animEvaluator.removeClip(0);
					}
					this._transitionPreviousStates = [];
					state = this.activeState;
					for (var _i5 = 0; _i5 < state.animations.length; _i5++) {
						animation = state.animations[_i5];
						clip = this._animEvaluator.findClip(animation.name);
						if (clip) {
							clip.blendWeight = animation.normalizedWeight;
						}
					}
				}
			} else {
				if (this.activeState._blendTree.constructor !== AnimNode) {
					state = this.activeState;
					for (var _i6 = 0; _i6 < state.animations.length; _i6++) {
						animation = state.animations[_i6];
						clip = this._animEvaluator.findClip(animation.name);
						if (clip) {
							clip.blendWeight = animation.normalizedWeight;
							if (animation.parent.syncAnimations) {
								clip.speed = animation.speed;
							}
						}
					}
				}
			}
			this._animEvaluator.update(dt, this.activeState.hasAnimations);
		};
		_createClass(AnimController, [{
			key: "animEvaluator",
			get: function get() {
				return this._animEvaluator;
			}
		}, {
			key: "activeState",
			get: function get() {
				return this._findState(this._activeStateName);
			},
			set: function set(stateName) {
				this._activeStateName = stateName;
			}
		}, {
			key: "activeStateName",
			get: function get() {
				return this._activeStateName;
			}
		}, {
			key: "activeStateAnimations",
			get: function get() {
				return this.activeState.animations;
			}
		}, {
			key: "previousState",
			get: function get() {
				return this._findState(this._previousStateName);
			},
			set: function set(stateName) {
				this._previousStateName = stateName;
			}
		}, {
			key: "previousStateName",
			get: function get() {
				return this._previousStateName;
			}
		}, {
			key: "playable",
			get: function get() {
				var playable = true;
				for (var i = 0; i < this._stateNames.length; i++) {
					if (!this._states[this._stateNames[i]].playable) {
						playable = false;
					}
				}
				return playable;
			}
		}, {
			key: "playing",
			get: function get() {
				return this._playing;
			},
			set: function set(value) {
				this._playing = value;
			}
		}, {
			key: "activeStateProgress",
			get: function get() {
				return this._getActiveStateProgressForTime(this._timeInState);
			}
		}, {
			key: "activeStateDuration",
			get: function get() {
				if (this._activeStateDurationDirty) {
					var maxDuration = 0.0;
					for (var i = 0; i < this.activeStateAnimations.length; i++) {
						var activeClip = this._animEvaluator.findClip(this.activeStateAnimations[i].name);
						if (activeClip) {
							maxDuration = Math.max(maxDuration, activeClip.track.duration);
						}
					}
					this._activeStateDuration = maxDuration;
					this._activeStateDurationDirty = false;
				}
				return this._activeStateDuration;
			}
		}, {
			key: "activeStateCurrentTime",
			get: function get() {
				return this._timeInState;
			},
			set: function set(time) {
				this._timeInStateBefore = time;
				this._timeInState = time;
				for (var i = 0; i < this.activeStateAnimations.length; i++) {
					var clip = this.animEvaluator.findClip(this.activeStateAnimations[i].name);
					if (clip) {
						clip.time = time;
					}
				}
			}
		}, {
			key: "transitioning",
			get: function get() {
				return this._isTransitioning;
			}
		}, {
			key: "transitionProgress",
			get: function get() {
				return this._currTransitionTime / this._totalTransitionTime;
			}
		}, {
			key: "states",
			get: function get() {
				return this._stateNames;
			}
		}]);
		return AnimController;
	}();

	var v2 = new Vec2();
	var v3 = new Vec3();
	var v4 = new Vec4();
	var c = new Color();
	var q = new Quat();
	var AnimComponentBinder = function (_DefaultAnimBinder) {
		_inheritsLoose(AnimComponentBinder, _DefaultAnimBinder);
		function AnimComponentBinder(animComponent, graph, layerName, mask, layerIndex) {
			var _this;
			_this = _DefaultAnimBinder.call(this, graph) || this;
			_this.animComponent = animComponent;
			_this._mask = mask;
			_this.layerName = layerName;
			_this.layerIndex = layerIndex;
			return _this;
		}
		AnimComponentBinder._packFloat = function _packFloat(values) {
			return values[0];
		};
		AnimComponentBinder._packBoolean = function _packBoolean(values) {
			return !!values[0];
		};
		AnimComponentBinder._packVec2 = function _packVec2(values) {
			v2.x = values[0];
			v2.y = values[1];
			return v2;
		};
		AnimComponentBinder._packVec3 = function _packVec3(values) {
			v3.x = values[0];
			v3.y = values[1];
			v3.z = values[2];
			return v3;
		};
		AnimComponentBinder._packVec4 = function _packVec4(values) {
			v4.x = values[0];
			v4.y = values[1];
			v4.z = values[2];
			v4.w = values[3];
			return v4;
		};
		AnimComponentBinder._packColor = function _packColor(values) {
			c.r = values[0];
			c.g = values[1];
			c.b = values[2];
			c.a = values[3];
			return c;
		};
		AnimComponentBinder._packQuat = function _packQuat(values) {
			q.x = values[0];
			q.y = values[1];
			q.z = values[2];
			q.w = values[3];
			return q;
		};
		var _proto = AnimComponentBinder.prototype;
		_proto.resolve = function resolve(path) {
			var encodedPath = AnimBinder.encode(path.entityPath, path.component, path.propertyPath);
			var target = this.targetCache[encodedPath];
			if (target) return target;
			var entity;
			var propertyComponent;
			var targetPath;
			switch (path.component) {
				case 'entity':
					entity = this._getEntityFromHierarchy(path.entityPath);
					targetPath = AnimBinder.encode(entity.path, 'entity', path.propertyPath);
					propertyComponent = entity;
					break;
				case 'graph':
					propertyComponent = this.findNode(path);
					if (!propertyComponent) return null;
					targetPath = AnimBinder.encode(propertyComponent.path, 'graph', path.propertyPath);
					break;
				default:
					entity = this._getEntityFromHierarchy(path.entityPath);
					propertyComponent = entity.findComponent(path.component);
					if (!propertyComponent) return null;
					targetPath = AnimBinder.encode(entity.path, path.component, path.propertyPath);
					break;
			}
			target = this._createAnimTargetForProperty(propertyComponent, path.propertyPath, targetPath);
			this.targetCache[encodedPath] = target;
			return target;
		};
		_proto.update = function update(deltaTime) {
			var activeNodes = this.activeNodes;
			if (activeNodes) {
				for (var i = 0; i < activeNodes.length; i++) {
					activeNodes[i]._dirtifyLocal();
				}
			}
		};
		_proto._getEntityFromHierarchy = function _getEntityFromHierarchy(entityHierarchy) {
			if (!this.animComponent.entity.name === entityHierarchy[0]) {
				return null;
			}
			var currEntity = this.animComponent.entity;
			if (entityHierarchy.length === 1) {
				return currEntity;
			}
			return currEntity._parent.findByPath(entityHierarchy);
		};
		_proto._resolvePath = function _resolvePath(object, path, resolveLeaf) {
			var steps = path.length - (resolveLeaf ? 0 : 1);
			for (var i = 0; i < steps; i++) {
				object = object[path[i]];
			}
			return object;
		};
		_proto._setter = function _setter(object, path, packFunc) {
			var obj = this._resolvePath(object, path);
			var key = path[path.length - 1];
			var setterFuncName = 'set' + key.substring(0, 1).toUpperCase() + key.substring(1);
			if (obj[setterFuncName]) {
				var getterFunc = obj['get' + key.substring(0, 1).toUpperCase() + key.substring(1)].bind(obj);
				var baseValues = getterFunc();
				baseValues = [baseValues.x, baseValues.y, baseValues.z, baseValues.w];
				var setterFunc = obj[setterFuncName].bind(obj);
				return {
					set: function set(values) {
						setterFunc(packFunc(values));
					},
					get: function get() {
						return baseValues;
					}
				};
			}
			var prop = obj[key];
			if (typeof prop === 'object' && prop.hasOwnProperty('copy')) {
				return function (values) {
					prop.copy(packFunc(values));
				};
			}
			if ([Vec2, Vec3, Vec4, Color, Quat].indexOf(obj.constructor) !== -1 && path.length > 1) {
				var parent = path.length > 2 ? this._resolvePath(object, path.slice(0, -1)) : object;
				var objKey = path[path.length - 2];
				return function (values) {
					obj[key] = packFunc(values);
					parent[objKey] = obj;
				};
			}
			return function (values) {
				obj[key] = packFunc(values);
			};
		};
		_proto._createAnimTargetForProperty = function _createAnimTargetForProperty(propertyComponent, propertyHierarchy, targetPath) {
			if (this.handlers && propertyHierarchy[0].startsWith('weight.')) {
				return this.handlers.weight(propertyComponent, propertyHierarchy[0].replace('weight.', ''));
			} else if (this.handlers && propertyHierarchy[0] === 'material' && propertyHierarchy.length === 2) {
				var materialPropertyName = propertyHierarchy[1];
				if (materialPropertyName.endsWith('Map')) {
					return this.handlers.materialTexture(propertyComponent, materialPropertyName);
				}
			}
			var property = this._resolvePath(propertyComponent, propertyHierarchy, true);
			if (typeof property === 'undefined') return null;
			var setter;
			var animDataType;
			var animDataComponents;
			if (typeof property === 'number') {
				setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packFloat);
				animDataType = 'vector';
				animDataComponents = 1;
			} else if (typeof property === 'boolean') {
				setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packBoolean);
				animDataType = 'vector';
				animDataComponents = 1;
			} else if (typeof property === 'object') {
				switch (property.constructor) {
					case Vec2:
						setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packVec2);
						animDataType = 'vector';
						animDataComponents = 2;
						break;
					case Vec3:
						setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packVec3);
						animDataType = 'vector';
						animDataComponents = 3;
						break;
					case Vec4:
						setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packVec4);
						animDataType = 'vector';
						animDataComponents = 4;
						break;
					case Color:
						setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packColor);
						animDataType = 'vector';
						animDataComponents = 4;
						break;
					case Quat:
						setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packQuat);
						animDataType = 'quaternion';
						animDataComponents = 4;
						break;
					default:
						return null;
				}
			}
			if (propertyHierarchy.indexOf('material') !== -1) {
				return new AnimTarget(function (values) {
					setter(values);
					propertyComponent.material.update();
				}, animDataType, animDataComponents, targetPath);
			}
			return new AnimTarget(setter, animDataType, animDataComponents, targetPath);
		};
		_proto.rebind = function rebind() {
			this.targetCache = {};
			if (this.animComponent.rootBone) {
				this.graph = this.animComponent.rootBone;
			} else {
				this.graph = this.animComponent.entity;
			}
			var nodes = {};
			var flatten = function flatten(node) {
				nodes[node.name] = node;
				for (var i = 0; i < node.children.length; ++i) {
					flatten(node.children[i]);
				}
			};
			flatten(this.graph);
			this.nodes = nodes;
		};
		return AnimComponentBinder;
	}(DefaultAnimBinder);

	var AnimComponentLayer = function () {
		function AnimComponentLayer(name, controller, component, weight, blendType, normalizedWeight) {
			if (weight === void 0) {
				weight = 1;
			}
			if (blendType === void 0) {
				blendType = ANIM_LAYER_OVERWRITE;
			}
			if (normalizedWeight === void 0) {
				normalizedWeight = true;
			}
			this._name = name;
			this._controller = controller;
			this._component = component;
			this._weight = weight;
			this._blendType = blendType;
			this._normalizedWeight = normalizedWeight;
			this._mask = null;
			this._blendTime = 0;
			this._blendTimeElapsed = 0;
			this._startingWeight = 0;
			this._targetWeight = 0;
		}
		var _proto = AnimComponentLayer.prototype;
		_proto.play = function play(name) {
			this._controller.play(name);
		};
		_proto.pause = function pause() {
			this._controller.pause();
		};
		_proto.reset = function reset() {
			this._controller.reset();
		};
		_proto.rebind = function rebind() {
			this._controller.rebind();
		};
		_proto.update = function update(dt) {
			if (this._blendTime) {
				if (this._blendTimeElapsed < this._blendTime) {
					this.weight = math.lerp(this._startingWeight, this._targetWeight, this._blendTimeElapsed / this._blendTime);
					this._blendTimeElapsed += dt;
				} else {
					this.weight = this._targetWeight;
					this._blendTime = 0;
					this._blendTimeElapsed = 0;
					this._startingWeight = 0;
					this._targetWeight = 0;
				}
			}
			this._controller.update(dt);
		};
		_proto.blendToWeight = function blendToWeight(weight, time) {
			this._startingWeight = this.weight;
			this._targetWeight = weight;
			this._blendTime = Math.max(0, time);
			this._blendTimeElapsed = 0;
		};
		_proto.assignMask = function assignMask(mask) {
			if (this._controller.assignMask(mask)) {
				this._component.rebind();
			}
			this._mask = mask;
		};
		_proto.assignAnimation = function assignAnimation(nodePath, animTrack, speed, loop) {
			if (!(animTrack instanceof AnimTrack)) {
				return;
			}
			this._controller.assignAnimation(nodePath, animTrack, speed, loop);
			if (this._controller._transitions.length === 0) {
				this._controller._transitions.push(new AnimTransition({
					from: 'START',
					to: nodePath
				}));
			}
			if (this._component.activate && this._component.playable) {
				this._component.playing = true;
			}
		};
		_proto.removeNodeAnimations = function removeNodeAnimations(nodeName) {
			if (this._controller.removeNodeAnimations(nodeName)) {
				this._component.playing = false;
			}
		};
		_proto.getAnimationAsset = function getAnimationAsset(stateName) {
			return this._component.animationAssets[this.name + ":" + stateName];
		};
		_proto.transition = function transition(to, time, transitionOffset) {
			if (time === void 0) {
				time = 0;
			}
			if (transitionOffset === void 0) {
				transitionOffset = null;
			}
			this._controller.updateStateFromTransition(new AnimTransition({
				from: this._controller.activeStateName,
				to: to,
				time: time,
				transitionOffset: transitionOffset
			}));
		};
		_createClass(AnimComponentLayer, [{
			key: "name",
			get: function get() {
				return this._name;
			}
		}, {
			key: "playing",
			get: function get() {
				return this._controller.playing;
			},
			set: function set(value) {
				this._controller.playing = value;
			}
		}, {
			key: "playable",
			get: function get() {
				return this._controller.playable;
			}
		}, {
			key: "activeState",
			get: function get() {
				return this._controller.activeStateName;
			}
		}, {
			key: "previousState",
			get: function get() {
				return this._controller.previousStateName;
			}
		}, {
			key: "activeStateProgress",
			get: function get() {
				return this._controller.activeStateProgress;
			}
		}, {
			key: "activeStateDuration",
			get: function get() {
				return this._controller.activeStateDuration;
			}
		}, {
			key: "activeStateCurrentTime",
			get: function get() {
				return this._controller.activeStateCurrentTime;
			},
			set: function set(time) {
				var controller = this._controller;
				var layerPlaying = controller.playing;
				controller.playing = true;
				controller.activeStateCurrentTime = time;
				if (!layerPlaying) {
					controller.update(0);
				}
				controller.playing = layerPlaying;
			}
		}, {
			key: "transitioning",
			get: function get() {
				return this._controller.transitioning;
			}
		}, {
			key: "transitionProgress",
			get: function get() {
				if (this.transitioning) {
					return this._controller.transitionProgress;
				}
				return null;
			}
		}, {
			key: "states",
			get: function get() {
				return this._controller.states;
			}
		}, {
			key: "weight",
			get: function get() {
				return this._weight;
			},
			set: function set(value) {
				this._weight = value;
				this._component.dirtifyTargets();
			}
		}, {
			key: "blendType",
			get: function get() {
				return this._blendType;
			},
			set: function set(value) {
				if (value !== this._blendType) {
					this._blendType = value;
					if (this._controller.normalizeWeights) {
						this._component.rebind();
					}
				}
			}
		}, {
			key: "mask",
			get: function get() {
				return this._mask;
			},
			set: function set(value) {
				if (this._controller.assignMask(value)) {
					this._component.rebind();
				}
				this._mask = value;
			}
		}]);
		return AnimComponentLayer;
	}();

	var AnimStateGraph = function () {
		function AnimStateGraph(data) {
			this._layers = [];
			this._parameters = {};
			if (!Array.isArray(data.layers)) {
				for (var layerId in data.layers) {
					var dataLayer = data.layers[layerId];
					var layer = {
						name: dataLayer.name,
						blendType: dataLayer.blendType,
						weight: dataLayer.weight,
						states: [],
						transitions: []
					};
					for (var i = 0; i < dataLayer.states.length; i++) {
						layer.states.push(data.states[dataLayer.states[i]]);
					}
					for (var _i = 0; _i < dataLayer.transitions.length; _i++) {
						var dataLayerTransition = data.transitions[dataLayer.transitions[_i]];
						if (dataLayerTransition.conditions && !Array.isArray(dataLayerTransition.conditions)) {
							var conditionKeys = Object.keys(dataLayerTransition.conditions);
							var conditions = [];
							for (var j = 0; j < conditionKeys.length; j++) {
								var condition = dataLayerTransition.conditions[conditionKeys[j]];
								if (condition.parameterName) {
									conditions.push(condition);
								}
							}
							dataLayerTransition.conditions = conditions;
						}
						if (Number.isInteger(dataLayerTransition.from)) {
							dataLayerTransition.from = data.states[dataLayerTransition.from].name;
						}
						if (Number.isInteger(dataLayerTransition.to)) {
							dataLayerTransition.to = data.states[dataLayerTransition.to].name;
						}
						layer.transitions.push(dataLayerTransition);
					}
					this._layers.push(layer);
				}
			} else {
				this._layers = data.layers;
			}
			for (var paramId in data.parameters) {
				var param = data.parameters[paramId];
				this._parameters[param.name] = {
					type: param.type,
					value: param.value
				};
			}
		}
		_createClass(AnimStateGraph, [{
			key: "parameters",
			get: function get() {
				return Object.assign({}, this._parameters);
			}
		}, {
			key: "layers",
			get: function get() {
				return this._layers;
			}
		}]);
		return AnimStateGraph;
	}();

	var AnimComponent = function (_Component) {
		_inheritsLoose(AnimComponent, _Component);
		function AnimComponent(system, entity) {
			var _this;
			_this = _Component.call(this, system, entity) || this;
			_this.findParameter = function (name) {
				return _this._parameters[name];
			};
			_this.consumeTrigger = function (name) {
				_this._consumedTriggers.add(name);
			};
			_this._stateGraphAsset = null;
			_this._animationAssets = {};
			_this._speed = 1.0;
			_this._activate = true;
			_this._playing = false;
			_this._rootBone = null;
			_this._stateGraph = null;
			_this._layers = [];
			_this._layerIndices = {};
			_this._parameters = {};
			_this._targets = {};
			_this._consumedTriggers = new Set();
			_this._normalizeWeights = false;
			return _this;
		}
		var _proto = AnimComponent.prototype;
		_proto._onStateGraphAssetChangeEvent = function _onStateGraphAssetChangeEvent(asset) {
			var prevAnimationAssets = this.animationAssets;
			var prevMasks = this.layers.map(function (layer) {
				return layer.mask;
			});
			this.removeStateGraph();
			this._stateGraph = new AnimStateGraph(asset._data);
			this.loadStateGraph(this._stateGraph);
			this.animationAssets = prevAnimationAssets;
			this.loadAnimationAssets();
			this.layers.forEach(function (layer, i) {
				layer.mask = prevMasks[i];
			});
			this.rebind();
		};
		_proto.dirtifyTargets = function dirtifyTargets() {
			var targets = Object.values(this._targets);
			for (var i = 0; i < targets.length; i++) {
				targets[i].dirty = true;
			}
		};
		_proto._addLayer = function _addLayer(_ref) {
			var name = _ref.name,
				states = _ref.states,
				transitions = _ref.transitions,
				weight = _ref.weight,
				mask = _ref.mask,
				blendType = _ref.blendType;
			var graph;
			if (this.rootBone) {
				graph = this.rootBone;
			} else {
				graph = this.entity;
			}
			var layerIndex = this._layers.length;
			var animBinder = new AnimComponentBinder(this, graph, name, mask, layerIndex);
			var animEvaluator = new AnimEvaluator(animBinder);
			var controller = new AnimController(animEvaluator, states, transitions, this._activate, this, this.findParameter, this.consumeTrigger);
			this._layers.push(new AnimComponentLayer(name, controller, this, weight, blendType));
			this._layerIndices[name] = layerIndex;
			return this._layers[layerIndex];
		};
		_proto.addLayer = function addLayer(name, weight, mask, blendType) {
			var layer = this.findAnimationLayer(name);
			if (layer) return layer;
			var states = [{
				'name': 'START',
				'speed': 1
			}];
			var transitions = [];
			return this._addLayer({
				name: name,
				states: states,
				transitions: transitions,
				weight: weight,
				mask: mask,
				blendType: blendType
			});
		};
		_proto._assignParameters = function _assignParameters(stateGraph) {
			this._parameters = {};
			var paramKeys = Object.keys(stateGraph.parameters);
			for (var i = 0; i < paramKeys.length; i++) {
				var paramKey = paramKeys[i];
				this._parameters[paramKey] = {
					type: stateGraph.parameters[paramKey].type,
					value: stateGraph.parameters[paramKey].value
				};
			}
		};
		_proto.loadStateGraph = function loadStateGraph(stateGraph) {
			this._stateGraph = stateGraph;
			this._assignParameters(stateGraph);
			this._layers = [];
			var containsBlendTree = false;
			for (var i = 0; i < stateGraph.layers.length; i++) {
				var layer = stateGraph.layers[i];
				this._addLayer(_extends({}, layer));
				if (layer.states.some(function (state) {
					return state.blendTree;
				})) {
					containsBlendTree = true;
				}
			}
			if (!containsBlendTree) {
				this.setupAnimationAssets();
			}
		};
		_proto.setupAnimationAssets = function setupAnimationAssets() {
			for (var i = 0; i < this._layers.length; i++) {
				var layer = this._layers[i];
				var layerName = layer.name;
				for (var j = 0; j < layer.states.length; j++) {
					var stateName = layer.states[j];
					if (ANIM_CONTROL_STATES.indexOf(stateName) === -1) {
						var stateKey = layerName + ':' + stateName;
						if (!this._animationAssets[stateKey]) {
							this._animationAssets[stateKey] = {
								asset: null
							};
						}
					}
				}
			}
			this.loadAnimationAssets();
		};
		_proto.loadAnimationAssets = function loadAnimationAssets() {
			for (var i = 0; i < this._layers.length; i++) {
				var layer = this._layers[i];
				for (var j = 0; j < layer.states.length; j++) {
					var stateName = layer.states[j];
					if (ANIM_CONTROL_STATES.indexOf(stateName) !== -1) continue;
					var animationAsset = this._animationAssets[layer.name + ':' + stateName];
					if (!animationAsset || !animationAsset.asset) {
						this.findAnimationLayer(layer.name).assignAnimation(stateName, AnimTrack.EMPTY);
						continue;
					}
					var assetId = animationAsset.asset;
					var asset = this.system.app.assets.get(assetId);
					if (asset) {
						if (asset.resource) {
							this.onAnimationAssetLoaded(layer.name, stateName, asset);
						} else {
							asset.once('load', function (layerName, stateName) {
								return function (asset) {
									this.onAnimationAssetLoaded(layerName, stateName, asset);
								}.bind(this);
							}.bind(this)(layer.name, stateName));
							this.system.app.assets.load(asset);
						}
					}
				}
			}
		};
		_proto.onAnimationAssetLoaded = function onAnimationAssetLoaded(layerName, stateName, asset) {
			this.findAnimationLayer(layerName).assignAnimation(stateName, asset.resource);
		};
		_proto.removeStateGraph = function removeStateGraph() {
			this._stateGraph = null;
			this._stateGraphAsset = null;
			this._animationAssets = {};
			this._layers = [];
			this._layerIndices = {};
			this._parameters = {};
			this._playing = false;
			this.unbind();
			this._targets = {};
		};
		_proto.reset = function reset() {
			this._assignParameters(this._stateGraph);
			for (var i = 0; i < this._layers.length; i++) {
				var layerPlaying = this._layers[i].playing;
				this._layers[i].reset();
				this._layers[i].playing = layerPlaying;
			}
		};
		_proto.unbind = function unbind() {
			var _this2 = this;
			if (!this._normalizeWeights) {
				Object.keys(this._targets).forEach(function (targetKey) {
					_this2._targets[targetKey].unbind();
				});
			}
		};
		_proto.rebind = function rebind() {
			this._targets = {};
			for (var i = 0; i < this._layers.length; i++) {
				this._layers[i].rebind();
			}
		};
		_proto.findAnimationLayer = function findAnimationLayer(name) {
			var layerIndex = this._layerIndices[name];
			return this._layers[layerIndex] || null;
		};
		_proto.addAnimationState = function addAnimationState(nodeName, animTrack, speed, loop, layerName) {
			if (speed === void 0) {
				speed = 1;
			}
			if (loop === void 0) {
				loop = true;
			}
			if (layerName === void 0) {
				layerName = 'Base';
			}
			if (!this._stateGraph) {
				this.loadStateGraph(new AnimStateGraph({
					'layers': [{
						'name': layerName,
						'states': [{
							'name': 'START',
							'speed': 1
						}, {
							'name': nodeName,
							'speed': speed,
							'loop': loop,
							'defaultState': true
						}],
						'transitions': [{
							'from': 'START',
							'to': nodeName
						}]
					}],
					'parameters': {}
				}));
			}
			var layer = this.findAnimationLayer(layerName);
			if (layer) {
				layer.assignAnimation(nodeName, animTrack, speed, loop);
			} else {
				var _this$addLayer;
				(_this$addLayer = this.addLayer(layerName)) == null || _this$addLayer.assignAnimation(nodeName, animTrack, speed, loop);
			}
		};
		_proto.assignAnimation = function assignAnimation(nodePath, animTrack, layerName, speed, loop) {
			if (speed === void 0) {
				speed = 1;
			}
			if (loop === void 0) {
				loop = true;
			}
			if (!this._stateGraph && nodePath.indexOf('.') === -1) {
				this.loadStateGraph(new AnimStateGraph({
					'layers': [{
						'name': 'Base',
						'states': [{
							'name': 'START',
							'speed': 1
						}, {
							'name': nodePath,
							'speed': speed,
							'loop': loop,
							'defaultState': true
						}],
						'transitions': [{
							'from': 'START',
							'to': nodePath
						}]
					}],
					'parameters': {}
				}));
				this.baseLayer.assignAnimation(nodePath, animTrack);
				return;
			}
			var layer = layerName ? this.findAnimationLayer(layerName) : this.baseLayer;
			if (!layer) {
				return;
			}
			layer.assignAnimation(nodePath, animTrack, speed, loop);
		};
		_proto.removeNodeAnimations = function removeNodeAnimations(nodeName, layerName) {
			var layer = layerName ? this.findAnimationLayer(layerName) : this.baseLayer;
			if (!layer) {
				return;
			}
			layer.removeNodeAnimations(nodeName);
		};
		_proto.getParameterValue = function getParameterValue(name, type) {
			var param = this._parameters[name];
			if (param && param.type === type) {
				return param.value;
			}
			return undefined;
		};
		_proto.setParameterValue = function setParameterValue(name, type, value) {
			var param = this._parameters[name];
			if (param && param.type === type) {
				param.value = value;
				return;
			}
		};
		_proto.getFloat = function getFloat(name) {
			return this.getParameterValue(name, ANIM_PARAMETER_FLOAT);
		};
		_proto.setFloat = function setFloat(name, value) {
			this.setParameterValue(name, ANIM_PARAMETER_FLOAT, value);
		};
		_proto.getInteger = function getInteger(name) {
			return this.getParameterValue(name, ANIM_PARAMETER_INTEGER);
		};
		_proto.setInteger = function setInteger(name, value) {
			if (typeof value === 'number' && value % 1 === 0) {
				this.setParameterValue(name, ANIM_PARAMETER_INTEGER, value);
			}
		};
		_proto.getBoolean = function getBoolean(name) {
			return this.getParameterValue(name, ANIM_PARAMETER_BOOLEAN);
		};
		_proto.setBoolean = function setBoolean(name, value) {
			this.setParameterValue(name, ANIM_PARAMETER_BOOLEAN, !!value);
		};
		_proto.getTrigger = function getTrigger(name) {
			return this.getParameterValue(name, ANIM_PARAMETER_TRIGGER);
		};
		_proto.setTrigger = function setTrigger(name, singleFrame) {
			if (singleFrame === void 0) {
				singleFrame = false;
			}
			this.setParameterValue(name, ANIM_PARAMETER_TRIGGER, true);
			if (singleFrame) {
				this._consumedTriggers.add(name);
			}
		};
		_proto.resetTrigger = function resetTrigger(name) {
			this.setParameterValue(name, ANIM_PARAMETER_TRIGGER, false);
		};
		_proto.onBeforeRemove = function onBeforeRemove() {
			if (Number.isFinite(this._stateGraphAsset)) {
				var stateGraphAsset = this.system.app.assets.get(this._stateGraphAsset);
				stateGraphAsset.off('change', this._onStateGraphAssetChangeEvent, this);
			}
		};
		_proto.update = function update(dt) {
			var _this3 = this;
			for (var i = 0; i < this.layers.length; i++) {
				this.layers[i].update(dt * this.speed);
			}
			this._consumedTriggers.forEach(function (trigger) {
				_this3.parameters[trigger].value = false;
			});
			this._consumedTriggers.clear();
		};
		_proto.resolveDuplicatedEntityReferenceProperties = function resolveDuplicatedEntityReferenceProperties(oldAnim, duplicatedIdsMap) {
			if (oldAnim.rootBone && duplicatedIdsMap[oldAnim.rootBone.getGuid()]) {
				this.rootBone = duplicatedIdsMap[oldAnim.rootBone.getGuid()];
			} else {
				this.rebind();
			}
		};
		_createClass(AnimComponent, [{
			key: "stateGraphAsset",
			get: function get() {
				return this._stateGraphAsset;
			},
			set: function set(value) {
				var _this4 = this;
				if (value === null) {
					this.removeStateGraph();
					return;
				}
				if (this._stateGraphAsset) {
					var stateGraphAsset = this.system.app.assets.get(this._stateGraphAsset);
					stateGraphAsset.off('change', this._onStateGraphAssetChangeEvent, this);
				}
				var _id;
				var _asset;
				if (value instanceof Asset) {
					_id = value.id;
					_asset = this.system.app.assets.get(_id);
					if (!_asset) {
						this.system.app.assets.add(value);
						_asset = this.system.app.assets.get(_id);
					}
				} else {
					_id = value;
					_asset = this.system.app.assets.get(_id);
				}
				if (!_asset || this._stateGraphAsset === _id) {
					return;
				}
				if (_asset.resource) {
					this._stateGraph = _asset.resource;
					this.loadStateGraph(this._stateGraph);
					_asset.on('change', this._onStateGraphAssetChangeEvent, this);
				} else {
					_asset.once('load', function (asset) {
						_this4._stateGraph = asset.resource;
						_this4.loadStateGraph(_this4._stateGraph);
					});
					_asset.on('change', this._onStateGraphAssetChangeEvent, this);
					this.system.app.assets.load(_asset);
				}
				this._stateGraphAsset = _id;
			}
		}, {
			key: "normalizeWeights",
			get: function get() {
				return this._normalizeWeights;
			},
			set: function set(value) {
				this._normalizeWeights = value;
				this.unbind();
			}
		}, {
			key: "animationAssets",
			get: function get() {
				return this._animationAssets;
			},
			set: function set(value) {
				this._animationAssets = value;
				this.loadAnimationAssets();
			}
		}, {
			key: "speed",
			get: function get() {
				return this._speed;
			},
			set: function set(value) {
				this._speed = value;
			}
		}, {
			key: "activate",
			get: function get() {
				return this._activate;
			},
			set: function set(value) {
				this._activate = value;
			}
		}, {
			key: "playing",
			get: function get() {
				return this._playing;
			},
			set: function set(value) {
				this._playing = value;
			}
		}, {
			key: "rootBone",
			get: function get() {
				return this._rootBone;
			},
			set: function set(value) {
				if (typeof value === 'string') {
					var entity = this.entity.root.findByGuid(value);
					this._rootBone = entity;
				} else if (value instanceof Entity) {
					this._rootBone = value;
				} else {
					this._rootBone = null;
				}
				this.rebind();
			}
		}, {
			key: "stateGraph",
			get: function get() {
				return this._stateGraph;
			},
			set: function set(value) {
				this._stateGraph = value;
			}
		}, {
			key: "layers",
			get: function get() {
				return this._layers;
			}
		}, {
			key: "layerIndices",
			get: function get() {
				return this._layerIndices;
			},
			set: function set(value) {
				this._layerIndices = value;
			}
		}, {
			key: "parameters",
			get: function get() {
				return this._parameters;
			},
			set: function set(value) {
				this._parameters = value;
			}
		}, {
			key: "targets",
			get: function get() {
				return this._targets;
			},
			set: function set(value) {
				this._targets = value;
			}
		}, {
			key: "playable",
			get: function get() {
				for (var i = 0; i < this._layers.length; i++) {
					if (!this._layers[i].playable) {
						return false;
					}
				}
				return true;
			}
		}, {
			key: "baseLayer",
			get: function get() {
				if (this._layers.length > 0) {
					return this._layers[0];
				}
				return null;
			}
		}]);
		return AnimComponent;
	}(Component);

	var AnimComponentData = function AnimComponentData() {
		this.enabled = true;
	};

	var _schema$k = ['enabled'];
	var AnimComponentSystem = function (_ComponentSystem) {
		_inheritsLoose(AnimComponentSystem, _ComponentSystem);
		function AnimComponentSystem(app) {
			var _this;
			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'anim';
			_this.ComponentType = AnimComponent;
			_this.DataType = AnimComponentData;
			_this.schema = _schema$k;
			_this.on('beforeremove', _this.onBeforeRemove, _assertThisInitialized(_this));
			_this.app.systems.on('animationUpdate', _this.onAnimationUpdate, _assertThisInitialized(_this));
			return _this;
		}
		var _proto = AnimComponentSystem.prototype;
		_proto.initializeComponentData = function initializeComponentData(component, data, properties) {
			var _this2 = this;
			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, _schema$k);
			var complexProperties = ['animationAssets', 'stateGraph', 'layers', 'masks'];
			Object.keys(data).forEach(function (key) {
				if (complexProperties.includes(key)) return;
				component[key] = data[key];
			});
			if (data.stateGraph) {
				component.stateGraph = data.stateGraph;
				component.loadStateGraph(component.stateGraph);
			}
			if (data.layers) {
				data.layers.forEach(function (layer, i) {
					layer._controller.states.forEach(function (stateKey) {
						layer._controller._states[stateKey]._animationList.forEach(function (node) {
							if (!node.animTrack || node.animTrack === AnimTrack.EMPTY) {
								var animationAsset = _this2.app.assets.get(layer._component._animationAssets[layer.name + ':' + node.name].asset);
								if (animationAsset && !animationAsset.loaded) {
									animationAsset.once('load', function () {
										component.layers[i].assignAnimation(node.name, animationAsset.resource);
									});
								}
							} else {
								component.layers[i].assignAnimation(node.name, node.animTrack);
							}
						});
					});
				});
			} else if (data.animationAssets) {
				component.animationAssets = Object.assign(component.animationAssets, data.animationAssets);
			}
			if (data.masks) {
				Object.keys(data.masks).forEach(function (key) {
					if (component.layers[key]) {
						var maskData = data.masks[key].mask;
						var mask = {};
						Object.keys(maskData).forEach(function (maskKey) {
							mask[decodeURI(maskKey)] = maskData[maskKey];
						});
						component.layers[key].mask = mask;
					}
				});
			}
		};
		_proto.onAnimationUpdate = function onAnimationUpdate(dt) {
			var components = this.store;
			for (var id in components) {
				if (components.hasOwnProperty(id)) {
					var component = components[id].entity.anim;
					var componentData = component.data;
					if (componentData.enabled && component.entity.enabled && component.playing) {
						component.update(dt);
					}
				}
			}
		};
		_proto.cloneComponent = function cloneComponent(entity, clone) {
			var masks;
			if (!entity.anim.rootBone || entity.anim.rootBone === entity) {
				masks = {};
				entity.anim.layers.forEach(function (layer, i) {
					if (layer.mask) {
						var mask = {};
						Object.keys(layer.mask).forEach(function (path) {
							var pathArr = path.split('/');
							pathArr.shift();
							var clonePath = [clone.name].concat(pathArr).join('/');
							mask[clonePath] = layer.mask[path];
						});
						masks[i] = {
							mask: mask
						};
					}
				});
			}
			var data = {
				stateGraphAsset: entity.anim.stateGraphAsset,
				animationAssets: entity.anim.animationAssets,
				speed: entity.anim.speed,
				activate: entity.anim.activate,
				playing: entity.anim.playing,
				rootBone: entity.anim.rootBone,
				stateGraph: entity.anim.stateGraph,
				layers: entity.anim.layers,
				layerIndices: entity.anim.layerIndices,
				parameters: entity.anim.parameters,
				normalizeWeights: entity.anim.normalizeWeights,
				masks: masks
			};
			return this.addComponent(clone, data);
		};
		_proto.onBeforeRemove = function onBeforeRemove(entity, component) {
			component.onBeforeRemove();
		};
		_proto.destroy = function destroy() {
			_ComponentSystem.prototype.destroy.call(this);
			this.app.systems.off('animationUpdate', this.onAnimationUpdate, this);
		};
		return AnimComponentSystem;
	}(ComponentSystem);
	Component._buildAccessors(AnimComponent.prototype, _schema$k);

	var AudioListenerComponent = function (_Component) {
		_inheritsLoose(AudioListenerComponent, _Component);
		function AudioListenerComponent(system, entity) {
			return _Component.call(this, system, entity) || this;
		}
		var _proto = AudioListenerComponent.prototype;
		_proto.setCurrentListener = function setCurrentListener() {
			if (this.enabled && this.entity.audiolistener && this.entity.enabled) {
				this.system.current = this.entity;
				var position = this.system.current.getPosition();
				this.system.manager.listener.setPosition(position);
			}
		};
		_proto.onEnable = function onEnable() {
			this.setCurrentListener();
		};
		_proto.onDisable = function onDisable() {
			if (this.system.current === this.entity) {
				this.system.current = null;
			}
		};
		return AudioListenerComponent;
	}(Component);

	var AudioListenerComponentData = function AudioListenerComponentData() {
		this.enabled = true;
	};

	var _schema$j = ['enabled'];
	var AudioListenerComponentSystem = function (_ComponentSystem) {
		_inheritsLoose(AudioListenerComponentSystem, _ComponentSystem);
		function AudioListenerComponentSystem(app) {
			var _this;
			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'audiolistener';
			_this.ComponentType = AudioListenerComponent;
			_this.DataType = AudioListenerComponentData;
			_this.schema = _schema$j;
			_this.manager = app.soundManager;
			_this.current = null;
			_this.app.systems.on('update', _this.onUpdate, _assertThisInitialized(_this));
			return _this;
		}
		var _proto = AudioListenerComponentSystem.prototype;
		_proto.initializeComponentData = function initializeComponentData(component, data, properties) {
			properties = ['enabled'];
			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
		};
		_proto.onUpdate = function onUpdate(dt) {
			if (this.current) {
				var position = this.current.getPosition();
				this.manager.listener.setPosition(position);
				var wtm = this.current.getWorldTransform();
				this.manager.listener.setOrientation(wtm);
			}
		};
		_proto.destroy = function destroy() {
			_ComponentSystem.prototype.destroy.call(this);
			this.app.systems.off('update', this.onUpdate, this);
		};
		return AudioListenerComponentSystem;
	}(ComponentSystem);
	Component._buildAccessors(AudioListenerComponent.prototype, _schema$j);

	var AudioSourceComponent = function (_Component) {
		_inheritsLoose(AudioSourceComponent, _Component);
		function AudioSourceComponent(system, entity) {
			var _this;
			_this = _Component.call(this, system, entity) || this;
			_this.on('set_assets', _this.onSetAssets, _assertThisInitialized(_this));
			_this.on('set_loop', _this.onSetLoop, _assertThisInitialized(_this));
			_this.on('set_volume', _this.onSetVolume, _assertThisInitialized(_this));
			_this.on('set_pitch', _this.onSetPitch, _assertThisInitialized(_this));
			_this.on('set_minDistance', _this.onSetMinDistance, _assertThisInitialized(_this));
			_this.on('set_maxDistance', _this.onSetMaxDistance, _assertThisInitialized(_this));
			_this.on('set_rollOffFactor', _this.onSetRollOffFactor, _assertThisInitialized(_this));
			_this.on('set_distanceModel', _this.onSetDistanceModel, _assertThisInitialized(_this));
			_this.on('set_3d', _this.onSet3d, _assertThisInitialized(_this));
			return _this;
		}
		var _proto = AudioSourceComponent.prototype;
		_proto.play = function play(name) {
			if (!this.enabled || !this.entity.enabled) {
				return;
			}
			if (this.channel) {
				this.stop();
			}
			var channel;
			var componentData = this.data;
			if (componentData.sources[name]) {
				if (!componentData['3d']) {
					channel = this.system.manager.playSound(componentData.sources[name], componentData);
					componentData.currentSource = name;
					componentData.channel = channel;
				} else {
					var pos = this.entity.getPosition();
					channel = this.system.manager.playSound3d(componentData.sources[name], pos, componentData);
					componentData.currentSource = name;
					componentData.channel = channel;
				}
			}
		};
		_proto.pause = function pause() {
			if (this.channel) {
				this.channel.pause();
			}
		};
		_proto.unpause = function unpause() {
			if (this.channel && this.channel.paused) {
				this.channel.unpause();
			}
		};
		_proto.stop = function stop() {
			if (this.channel) {
				this.channel.stop();
				this.channel = null;
			}
		};
		_proto.onSetAssets = function onSetAssets(name, oldValue, newValue) {
			var newAssets = [];
			var len = newValue.length;
			if (oldValue && oldValue.length) {
				for (var i = 0; i < oldValue.length; i++) {
					if (oldValue[i]) {
						var asset = this.system.app.assets.get(oldValue[i]);
						if (asset) {
							asset.off('change', this.onAssetChanged, this);
							asset.off('remove', this.onAssetRemoved, this);
							if (this.currentSource === asset.name) {
								this.stop();
							}
						}
					}
				}
			}
			if (len) {
				for (var _i = 0; _i < len; _i++) {
					if (oldValue.indexOf(newValue[_i]) < 0) {
						if (newValue[_i] instanceof Asset) {
							newAssets.push(newValue[_i].id);
						} else {
							newAssets.push(newValue[_i]);
						}
					}
				}
			}
			if (!this.system._inTools && newAssets.length) {
				this.loadAudioSourceAssets(newAssets);
			}
		};
		_proto.onAssetChanged = function onAssetChanged(asset, attribute, newValue, oldValue) {
			if (attribute === 'resource') {
				var sources = this.data.sources;
				if (sources) {
					this.data.sources[asset.name] = newValue;
					if (this.data.currentSource === asset.name) {
						if (this.channel) {
							if (this.channel.paused) {
								this.play(asset.name);
								this.pause();
							} else {
								this.play(asset.name);
							}
						}
					}
				}
			}
		};
		_proto.onAssetRemoved = function onAssetRemoved(asset) {
			asset.off('remove', this.onAssetRemoved, this);
			if (this.data.sources[asset.name]) {
				delete this.data.sources[asset.name];
				if (this.data.currentSource === asset.name) {
					this.stop();
					this.data.currentSource = null;
				}
			}
		};
		_proto.onSetLoop = function onSetLoop(name, oldValue, newValue) {
			if (oldValue !== newValue) {
				if (this.channel) {
					this.channel.setLoop(newValue);
				}
			}
		};
		_proto.onSetVolume = function onSetVolume(name, oldValue, newValue) {
			if (oldValue !== newValue) {
				if (this.channel) {
					this.channel.setVolume(newValue);
				}
			}
		};
		_proto.onSetPitch = function onSetPitch(name, oldValue, newValue) {
			if (oldValue !== newValue) {
				if (this.channel) {
					this.channel.setPitch(newValue);
				}
			}
		};
		_proto.onSetMaxDistance = function onSetMaxDistance(name, oldValue, newValue) {
			if (oldValue !== newValue) {
				if (this.channel instanceof Channel3d) {
					this.channel.setMaxDistance(newValue);
				}
			}
		};
		_proto.onSetMinDistance = function onSetMinDistance(name, oldValue, newValue) {
			if (oldValue !== newValue) {
				if (this.channel instanceof Channel3d) {
					this.channel.setMinDistance(newValue);
				}
			}
		};
		_proto.onSetRollOffFactor = function onSetRollOffFactor(name, oldValue, newValue) {
			if (oldValue !== newValue) {
				if (this.channel instanceof Channel3d) {
					this.channel.setRollOffFactor(newValue);
				}
			}
		};
		_proto.onSetDistanceModel = function onSetDistanceModel(name, oldValue, newValue) {
			if (oldValue !== newValue) {
				if (this.channel instanceof Channel3d) {
					this.channel.setDistanceModel(newValue);
				}
			}
		};
		_proto.onSet3d = function onSet3d(name, oldValue, newValue) {
			if (oldValue !== newValue) {
				if (this.system.initialized && this.currentSource) {
					var paused = false;
					var suspended = false;
					if (this.channel) {
						paused = this.channel.paused;
						suspended = this.channel.suspended;
					}
					this.play(this.currentSource);
					if (this.channel) {
						this.channel.paused = paused;
						this.channel.suspended = suspended;
					}
				}
			}
		};
		_proto.onEnable = function onEnable() {
			var assets = this.data.assets;
			if (assets) {
				var registry = this.system.app.assets;
				for (var i = 0, len = assets.length; i < len; i++) {
					var asset = assets[i];
					if (!(asset instanceof Asset)) asset = registry.get(asset);
					if (asset && !asset.resource) {
						registry.load(asset);
					}
				}
			}
			if (this.system.initialized) {
				if (this.data.activate && !this.channel) {
					this.play(this.currentSource);
				} else {
					this.unpause();
				}
			}
		};
		_proto.onDisable = function onDisable() {
			this.pause();
		};
		_proto.loadAudioSourceAssets = function loadAudioSourceAssets(ids) {
			var _this2 = this;
			var assets = ids.map(function (id) {
				return _this2.system.app.assets.get(id);
			});
			var sources = {};
			var currentSource = null;
			var count = assets.length;
			var _error = function _error(e) {
				count--;
			};
			var _done = function _done() {
				_this2.data.sources = sources;
				_this2.data.currentSource = currentSource;
				if (_this2.enabled && _this2.activate && currentSource) {
					_this2.onEnable();
				}
			};
			assets.forEach(function (asset, index) {
				if (asset) {
					currentSource = currentSource || asset.name;
					asset.off('change', _this2.onAssetChanged, _this2);
					asset.on('change', _this2.onAssetChanged, _this2);
					asset.off('remove', _this2.onAssetRemoved, _this2);
					asset.on('remove', _this2.onAssetRemoved, _this2);
					asset.off('error', _error, _this2);
					asset.on('error', _error, _this2);
					asset.ready(function (asset) {
						sources[asset.name] = asset.resource;
						count--;
						if (count === 0) {
							_done();
						}
					});
					if (!asset.resource && _this2.enabled && _this2.entity.enabled) _this2.system.app.assets.load(asset);
				} else {
					count--;
					if (count === 0) {
						_done();
					}
					_this2.system.app.assets.on('add:' + ids[index], function (asset) {
						asset.ready(function (asset) {
							_this2.data.sources[asset.name] = asset.resource;
						});
						if (!asset.resource) _this2.system.app.assets.load(asset);
					});
				}
			});
		};
		return AudioSourceComponent;
	}(Component);

	var AudioSourceComponentData = function AudioSourceComponentData() {
		this.enabled = true;
		this.assets = [];
		this.activate = true;
		this.volume = 1;
		this.pitch = 1;
		this.loop = false;
		this['3d'] = true;
		this.minDistance = 1;
		this.maxDistance = 10000;
		this.rollOffFactor = 1;
		this.distanceModel = DISTANCE_INVERSE;
		this.paused = true;
		this.sources = {};
		this.currentSource = null;
		this.channel = null;
	};

	var _schema$i = ['enabled', 'assets', 'volume', 'pitch', 'loop', 'activate', '3d', 'minDistance', 'maxDistance', 'rollOffFactor', 'distanceModel', 'sources', 'currentSource', 'channel'];
	var AudioSourceComponentSystem = function (_ComponentSystem) {
		_inheritsLoose(AudioSourceComponentSystem, _ComponentSystem);
		function AudioSourceComponentSystem(app) {
			var _this;
			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'audiosource';
			_this.ComponentType = AudioSourceComponent;
			_this.DataType = AudioSourceComponentData;
			_this.schema = _schema$i;
			_this.manager = app.soundManager;
			_this.initialized = false;
			_this.app.systems.on('initialize', _this.onInitialize, _assertThisInitialized(_this));
			_this.app.systems.on('update', _this.onUpdate, _assertThisInitialized(_this));
			_this.on('remove', _this.onRemove, _assertThisInitialized(_this));
			return _this;
		}
		var _proto = AudioSourceComponentSystem.prototype;
		_proto.initializeComponentData = function initializeComponentData(component, data, properties) {
			properties = ['activate', 'volume', 'pitch', 'loop', '3d', 'minDistance', 'maxDistance', 'rollOffFactor', 'distanceModel', 'enabled', 'assets'];
			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
			component.paused = !(component.enabled && component.activate);
		};
		_proto.onInitialize = function onInitialize(root) {
			if (root.audiosource && root.enabled && root.audiosource.enabled && root.audiosource.activate) {
				root.audiosource.play(root.audiosource.currentSource);
			}
			var children = root._children;
			for (var i = 0, len = children.length; i < len; i++) {
				if (children[i] instanceof Entity) {
					this.onInitialize(children[i]);
				}
			}
			this.initialized = true;
		};
		_proto.onUpdate = function onUpdate(dt) {
			var components = this.store;
			for (var id in components) {
				if (components.hasOwnProperty(id)) {
					var component = components[id];
					var entity = component.entity;
					var componentData = component.data;
					if (componentData.enabled && entity.enabled && componentData.channel instanceof Channel3d) {
						var pos = entity.getPosition();
						componentData.channel.setPosition(pos);
					}
				}
			}
		};
		_proto.onRemove = function onRemove(entity, data) {
			if (data.channel) {
				data.channel.stop();
				data.channel = null;
			}
		};
		_proto.setVolume = function setVolume(volume) {
			this.manager.setVolume(volume);
		};
		_proto.destroy = function destroy() {
			_ComponentSystem.prototype.destroy.call(this);
			this.app.systems.off('initialize', this.onInitialize, this);
			this.app.systems.off('update', this.onUpdate, this);
		};
		return AudioSourceComponentSystem;
	}(ComponentSystem);
	Component._buildAccessors(AudioSourceComponent.prototype, _schema$i);

	var EntityReference = function (_EventHandler) {
		_inheritsLoose(EntityReference, _EventHandler);
		function EntityReference(parentComponent, entityPropertyName, eventConfig) {
			var _this;
			_this = _EventHandler.call(this) || this;
			if (!parentComponent || !(parentComponent instanceof Component)) {
				throw new Error('The parentComponent argument is required and must be a Component');
			} else if (!entityPropertyName || typeof entityPropertyName !== 'string') {
				throw new Error('The propertyName argument is required and must be a string');
			} else if (eventConfig && typeof eventConfig !== 'object') {
				throw new Error('If provided, the eventConfig argument must be an object');
			}
			_this._parentComponent = parentComponent;
			_this._entityPropertyName = entityPropertyName;
			_this._entity = null;
			_this._app = parentComponent.system.app;
			_this._configureEventListeners(eventConfig || {}, {
				'entity#destroy': _this._onEntityDestroy
			});
			_this._toggleLifecycleListeners('on');
			return _this;
		}
		var _proto = EntityReference.prototype;
		_proto._configureEventListeners = function _configureEventListeners(externalEventConfig, internalEventConfig) {
			var externalEventListenerConfigs = this._parseEventListenerConfig(externalEventConfig, 'external', this._parentComponent);
			var internalEventListenerConfigs = this._parseEventListenerConfig(internalEventConfig, 'internal', this);
			this._eventListenerConfigs = externalEventListenerConfigs.concat(internalEventListenerConfigs);
			this._listenerStatusFlags = {};
			this._gainListeners = {};
			this._loseListeners = {};
		};
		_proto._parseEventListenerConfig = function _parseEventListenerConfig(eventConfig, prefix, scope) {
			return Object.keys(eventConfig).map(function (listenerDescription, index) {
				var listenerDescriptionParts = listenerDescription.split('#');
				var sourceName = listenerDescriptionParts[0];
				var eventName = listenerDescriptionParts[1];
				var callback = eventConfig[listenerDescription];
				if (listenerDescriptionParts.length !== 2 || typeof sourceName !== 'string' || sourceName.length === 0 || typeof eventName !== 'string' || eventName.length === 0) {
					throw new Error('Invalid event listener description: `' + listenerDescription + '`');
				}
				if (typeof callback !== 'function') {
					throw new Error('Invalid or missing callback for event listener `' + listenerDescription + '`');
				}
				return {
					id: prefix + '_' + index + '_' + listenerDescription,
					sourceName: sourceName,
					eventName: eventName,
					callback: callback,
					scope: scope
				};
			}, this);
		};
		_proto._toggleLifecycleListeners = function _toggleLifecycleListeners(onOrOff) {
			this._parentComponent[onOrOff]('set_' + this._entityPropertyName, this._onSetEntity, this);
			this._parentComponent.system[onOrOff]('beforeremove', this._onParentComponentRemove, this);
			this._app.systems[onOrOff]('postPostInitialize', this._updateEntityReference, this);
			this._app[onOrOff]('tools:sceneloaded', this._onSceneLoaded, this);
			var allComponentSystems = [];
			for (var i = 0; i < this._eventListenerConfigs.length; ++i) {
				var config = this._eventListenerConfigs[i];
				var componentSystem = this._app.systems[config.sourceName];
				if (componentSystem) {
					if (allComponentSystems.indexOf(componentSystem) === -1) {
						allComponentSystems.push(componentSystem);
					}
					if (componentSystem && config.eventName === 'gain') {
						this._gainListeners[config.sourceName] = config;
					}
					if (componentSystem && config.eventName === 'lose') {
						this._loseListeners[config.sourceName] = config;
					}
				}
			}
			for (var _i = 0; _i < allComponentSystems.length; ++_i) {
				allComponentSystems[_i][onOrOff]('add', this._onComponentAdd, this);
				allComponentSystems[_i][onOrOff]('beforeremove', this._onComponentRemove, this);
			}
		};
		_proto._onSetEntity = function _onSetEntity(name, oldValue, newValue) {
			if (newValue instanceof Entity) {
				this._updateEntityReference();
			} else {
				if (newValue !== null && newValue !== undefined && typeof newValue !== 'string') {
					console.warn("Entity field `" + this._entityPropertyName + "` was set to unexpected type '" + typeof newValue + "'");
					return;
				}
				if (oldValue !== newValue) {
					this._updateEntityReference();
				}
			}
		};
		_proto.onParentComponentEnable = function onParentComponentEnable() {
			if (!this._entity) {
				this._updateEntityReference();
			}
		};
		_proto._onSceneLoaded = function _onSceneLoaded() {
			this._updateEntityReference();
		};
		_proto._updateEntityReference = function _updateEntityReference() {
			var nextEntityGuid = this._parentComponent.data[this._entityPropertyName];
			var nextEntity;
			if (nextEntityGuid instanceof Entity) {
				nextEntity = nextEntityGuid;
				nextEntityGuid = nextEntity.getGuid();
				this._parentComponent.data[this._entityPropertyName] = nextEntityGuid;
			} else {
				var root = this._parentComponent.system.app.root;
				var isOnSceneGraph = this._parentComponent.entity.isDescendantOf(root);
				nextEntity = isOnSceneGraph && nextEntityGuid ? root.findByGuid(nextEntityGuid) : null;
			}
			var hasChanged = this._entity !== nextEntity;
			if (hasChanged) {
				if (this._entity) {
					this._onBeforeEntityChange();
				}
				this._entity = nextEntity;
				if (this._entity) {
					this._onAfterEntityChange();
				}
				this.fire('set:entity', this._entity);
			}
		};
		_proto._onBeforeEntityChange = function _onBeforeEntityChange() {
			this._toggleEntityListeners('off');
			this._callAllGainOrLoseListeners(this._loseListeners);
		};
		_proto._onAfterEntityChange = function _onAfterEntityChange() {
			this._toggleEntityListeners('on');
			this._callAllGainOrLoseListeners(this._gainListeners);
		};
		_proto._onComponentAdd = function _onComponentAdd(entity, component) {
			var componentName = component.system.id;
			if (entity === this._entity) {
				this._callGainOrLoseListener(componentName, this._gainListeners);
				this._toggleComponentListeners('on', componentName);
			}
		};
		_proto._onComponentRemove = function _onComponentRemove(entity, component) {
			var componentName = component.system.id;
			if (entity === this._entity) {
				this._callGainOrLoseListener(componentName, this._loseListeners);
				this._toggleComponentListeners('off', componentName, true);
			}
		};
		_proto._callAllGainOrLoseListeners = function _callAllGainOrLoseListeners(listenerMap) {
			for (var componentName in this._entity.c) {
				this._callGainOrLoseListener(componentName, listenerMap);
			}
		};
		_proto._callGainOrLoseListener = function _callGainOrLoseListener(componentName, listenerMap) {
			if (this._entity.c.hasOwnProperty(componentName) && listenerMap[componentName]) {
				var config = listenerMap[componentName];
				config.callback.call(config.scope);
			}
		};
		_proto._toggleEntityListeners = function _toggleEntityListeners(onOrOff, isDestroying) {
			if (this._entity) {
				for (var i = 0; i < this._eventListenerConfigs.length; ++i) {
					this._safeToggleListener(onOrOff, this._eventListenerConfigs[i], isDestroying);
				}
			}
		};
		_proto._toggleComponentListeners = function _toggleComponentListeners(onOrOff, componentName, isDestroying) {
			for (var i = 0; i < this._eventListenerConfigs.length; ++i) {
				var config = this._eventListenerConfigs[i];
				if (config.sourceName === componentName) {
					this._safeToggleListener(onOrOff, config, isDestroying);
				}
			}
		};
		_proto._safeToggleListener = function _safeToggleListener(onOrOff, config, isDestroying) {
			var isAdding = onOrOff === 'on';
			if (isAdding && this._listenerStatusFlags[config.id]) {
				return;
			}
			var source = this._getEventSource(config.sourceName, isDestroying);
			if (source) {
				source[onOrOff](config.eventName, config.callback, config.scope);
				this._listenerStatusFlags[config.id] = isAdding;
			}
		};
		_proto._getEventSource = function _getEventSource(sourceName, isDestroying) {
			if (sourceName === 'entity') {
				return this._entity;
			}
			var component = this._entity[sourceName];
			if (component) {
				return component;
			}
			if (!isDestroying) {
				console.warn('Entity has no component with name ' + sourceName);
			}
			return null;
		};
		_proto._onEntityDestroy = function _onEntityDestroy(entity) {
			if (this._entity === entity) {
				this._toggleEntityListeners('off', true);
				this._entity = null;
			}
		};
		_proto._onParentComponentRemove = function _onParentComponentRemove(entity, component) {
			if (component === this._parentComponent) {
				this._toggleLifecycleListeners('off');
				this._toggleEntityListeners('off', true);
			}
		};
		_proto.hasComponent = function hasComponent(componentName) {
			return this._entity && this._entity.c ? !!this._entity.c[componentName] : false;
		};
		_createClass(EntityReference, [{
			key: "entity",
			get: function get() {
				return this._entity;
			}
		}]);
		return EntityReference;
	}(EventHandler);

	var BUTTON_TRANSITION_MODE_TINT = 0;
	var BUTTON_TRANSITION_MODE_SPRITE_CHANGE = 1;

	var ELEMENTTYPE_GROUP = 'group';
	var ELEMENTTYPE_IMAGE = 'image';
	var ELEMENTTYPE_TEXT = 'text';
	var FITMODE_STRETCH = 'stretch';
	var FITMODE_CONTAIN = 'contain';
	var FITMODE_COVER = 'cover';

	var VisualState = {
		DEFAULT: 'DEFAULT',
		HOVER: 'HOVER',
		PRESSED: 'PRESSED',
		INACTIVE: 'INACTIVE'
	};
	var STATES_TO_TINT_NAMES = {};
	STATES_TO_TINT_NAMES[VisualState.DEFAULT] = '_defaultTint';
	STATES_TO_TINT_NAMES[VisualState.HOVER] = 'hoverTint';
	STATES_TO_TINT_NAMES[VisualState.PRESSED] = 'pressedTint';
	STATES_TO_TINT_NAMES[VisualState.INACTIVE] = 'inactiveTint';
	var STATES_TO_SPRITE_ASSET_NAMES = {};
	STATES_TO_SPRITE_ASSET_NAMES[VisualState.DEFAULT] = '_defaultSpriteAsset';
	STATES_TO_SPRITE_ASSET_NAMES[VisualState.HOVER] = 'hoverSpriteAsset';
	STATES_TO_SPRITE_ASSET_NAMES[VisualState.PRESSED] = 'pressedSpriteAsset';
	STATES_TO_SPRITE_ASSET_NAMES[VisualState.INACTIVE] = 'inactiveSpriteAsset';
	var STATES_TO_SPRITE_FRAME_NAMES = {};
	STATES_TO_SPRITE_FRAME_NAMES[VisualState.DEFAULT] = '_defaultSpriteFrame';
	STATES_TO_SPRITE_FRAME_NAMES[VisualState.HOVER] = 'hoverSpriteFrame';
	STATES_TO_SPRITE_FRAME_NAMES[VisualState.PRESSED] = 'pressedSpriteFrame';
	STATES_TO_SPRITE_FRAME_NAMES[VisualState.INACTIVE] = 'inactiveSpriteFrame';
	var ButtonComponent = function (_Component) {
		_inheritsLoose(ButtonComponent, _Component);
		function ButtonComponent(system, entity) {
			var _this;
			_this = _Component.call(this, system, entity) || this;
			_this._visualState = VisualState.DEFAULT;
			_this._isHovering = false;
			_this._hoveringCounter = 0;
			_this._isPressed = false;
			_this._defaultTint = new Color(1, 1, 1, 1);
			_this._defaultSpriteAsset = null;
			_this._defaultSpriteFrame = 0;
			_this._imageReference = new EntityReference(_assertThisInitialized(_this), 'imageEntity', {
				'element#gain': _this._onImageElementGain,
				'element#lose': _this._onImageElementLose,
				'element#set:color': _this._onSetColor,
				'element#set:opacity': _this._onSetOpacity,
				'element#set:spriteAsset': _this._onSetSpriteAsset,
				'element#set:spriteFrame': _this._onSetSpriteFrame
			});
			_this._toggleLifecycleListeners('on', system);
			return _this;
		}
		var _proto = ButtonComponent.prototype;
		_proto._toggleLifecycleListeners = function _toggleLifecycleListeners(onOrOff, system) {
			this[onOrOff]('set_active', this._onSetActive, this);
			this[onOrOff]('set_transitionMode', this._onSetTransitionMode, this);
			this[onOrOff]('set_hoverTint', this._onSetTransitionValue, this);
			this[onOrOff]('set_pressedTint', this._onSetTransitionValue, this);
			this[onOrOff]('set_inactiveTint', this._onSetTransitionValue, this);
			this[onOrOff]('set_hoverSpriteAsset', this._onSetTransitionValue, this);
			this[onOrOff]('set_hoverSpriteFrame', this._onSetTransitionValue, this);
			this[onOrOff]('set_pressedSpriteAsset', this._onSetTransitionValue, this);
			this[onOrOff]('set_pressedSpriteFrame', this._onSetTransitionValue, this);
			this[onOrOff]('set_inactiveSpriteAsset', this._onSetTransitionValue, this);
			this[onOrOff]('set_inactiveSpriteFrame', this._onSetTransitionValue, this);
			system.app.systems.element[onOrOff]('add', this._onElementComponentAdd, this);
			system.app.systems.element[onOrOff]('beforeremove', this._onElementComponentRemove, this);
		};
		_proto._onSetActive = function _onSetActive(name, oldValue, newValue) {
			if (oldValue !== newValue) {
				this._updateVisualState();
			}
		};
		_proto._onSetTransitionMode = function _onSetTransitionMode(name, oldValue, newValue) {
			if (oldValue !== newValue) {
				this._cancelTween();
				this._resetToDefaultVisualState(oldValue);
				this._forceReapplyVisualState();
			}
		};
		_proto._onSetTransitionValue = function _onSetTransitionValue(name, oldValue, newValue) {
			if (oldValue !== newValue) {
				this._forceReapplyVisualState();
			}
		};
		_proto._onElementComponentRemove = function _onElementComponentRemove(entity) {
			if (this.entity === entity) {
				this._toggleHitElementListeners('off');
			}
		};
		_proto._onElementComponentAdd = function _onElementComponentAdd(entity) {
			if (this.entity === entity) {
				this._toggleHitElementListeners('on');
			}
		};
		_proto._onImageElementLose = function _onImageElementLose() {
			this._cancelTween();
			this._resetToDefaultVisualState(this.transitionMode);
		};
		_proto._onImageElementGain = function _onImageElementGain() {
			this._storeDefaultVisualState();
			this._forceReapplyVisualState();
		};
		_proto._toggleHitElementListeners = function _toggleHitElementListeners(onOrOff) {
			if (this.entity.element) {
				var isAdding = onOrOff === 'on';
				if (isAdding && this._hasHitElementListeners) {
					return;
				}
				this.entity.element[onOrOff]('mouseenter', this._onMouseEnter, this);
				this.entity.element[onOrOff]('mouseleave', this._onMouseLeave, this);
				this.entity.element[onOrOff]('mousedown', this._onMouseDown, this);
				this.entity.element[onOrOff]('mouseup', this._onMouseUp, this);
				this.entity.element[onOrOff]('touchstart', this._onTouchStart, this);
				this.entity.element[onOrOff]('touchend', this._onTouchEnd, this);
				this.entity.element[onOrOff]('touchleave', this._onTouchLeave, this);
				this.entity.element[onOrOff]('touchcancel', this._onTouchCancel, this);
				this.entity.element[onOrOff]('selectstart', this._onSelectStart, this);
				this.entity.element[onOrOff]('selectend', this._onSelectEnd, this);
				this.entity.element[onOrOff]('selectenter', this._onSelectEnter, this);
				this.entity.element[onOrOff]('selectleave', this._onSelectLeave, this);
				this.entity.element[onOrOff]('click', this._onClick, this);
				this._hasHitElementListeners = isAdding;
			}
		};
		_proto._storeDefaultVisualState = function _storeDefaultVisualState() {
			if (this._imageReference.hasComponent('element')) {
				var element = this._imageReference.entity.element;
				if (element.type !== ELEMENTTYPE_GROUP) {
					this._storeDefaultColor(element.color);
					this._storeDefaultOpacity(element.opacity);
					this._storeDefaultSpriteAsset(element.spriteAsset);
					this._storeDefaultSpriteFrame(element.spriteFrame);
				}
			}
		};
		_proto._storeDefaultColor = function _storeDefaultColor(color) {
			this._defaultTint.r = color.r;
			this._defaultTint.g = color.g;
			this._defaultTint.b = color.b;
		};
		_proto._storeDefaultOpacity = function _storeDefaultOpacity(opacity) {
			this._defaultTint.a = opacity;
		};
		_proto._storeDefaultSpriteAsset = function _storeDefaultSpriteAsset(spriteAsset) {
			this._defaultSpriteAsset = spriteAsset;
		};
		_proto._storeDefaultSpriteFrame = function _storeDefaultSpriteFrame(spriteFrame) {
			this._defaultSpriteFrame = spriteFrame;
		};
		_proto._onSetColor = function _onSetColor(color) {
			if (!this._isApplyingTint) {
				this._storeDefaultColor(color);
				this._forceReapplyVisualState();
			}
		};
		_proto._onSetOpacity = function _onSetOpacity(opacity) {
			if (!this._isApplyingTint) {
				this._storeDefaultOpacity(opacity);
				this._forceReapplyVisualState();
			}
		};
		_proto._onSetSpriteAsset = function _onSetSpriteAsset(spriteAsset) {
			if (!this._isApplyingSprite) {
				this._storeDefaultSpriteAsset(spriteAsset);
				this._forceReapplyVisualState();
			}
		};
		_proto._onSetSpriteFrame = function _onSetSpriteFrame(spriteFrame) {
			if (!this._isApplyingSprite) {
				this._storeDefaultSpriteFrame(spriteFrame);
				this._forceReapplyVisualState();
			}
		};
		_proto._onMouseEnter = function _onMouseEnter(event) {
			this._isHovering = true;
			this._updateVisualState();
			this._fireIfActive('mouseenter', event);
		};
		_proto._onMouseLeave = function _onMouseLeave(event) {
			this._isHovering = false;
			this._isPressed = false;
			this._updateVisualState();
			this._fireIfActive('mouseleave', event);
		};
		_proto._onMouseDown = function _onMouseDown(event) {
			this._isPressed = true;
			this._updateVisualState();
			this._fireIfActive('mousedown', event);
		};
		_proto._onMouseUp = function _onMouseUp(event) {
			this._isPressed = false;
			this._updateVisualState();
			this._fireIfActive('mouseup', event);
		};
		_proto._onTouchStart = function _onTouchStart(event) {
			this._isPressed = true;
			this._updateVisualState();
			this._fireIfActive('touchstart', event);
		};
		_proto._onTouchEnd = function _onTouchEnd(event) {
			event.event.preventDefault();
			this._isPressed = false;
			this._updateVisualState();
			this._fireIfActive('touchend', event);
		};
		_proto._onTouchLeave = function _onTouchLeave(event) {
			this._isPressed = false;
			this._updateVisualState();
			this._fireIfActive('touchleave', event);
		};
		_proto._onTouchCancel = function _onTouchCancel(event) {
			this._isPressed = false;
			this._updateVisualState();
			this._fireIfActive('touchcancel', event);
		};
		_proto._onSelectStart = function _onSelectStart(event) {
			this._isPressed = true;
			this._updateVisualState();
			this._fireIfActive('selectstart', event);
		};
		_proto._onSelectEnd = function _onSelectEnd(event) {
			this._isPressed = false;
			this._updateVisualState();
			this._fireIfActive('selectend', event);
		};
		_proto._onSelectEnter = function _onSelectEnter(event) {
			this._hoveringCounter++;
			if (this._hoveringCounter === 1) {
				this._isHovering = true;
				this._updateVisualState();
			}
			this._fireIfActive('selectenter', event);
		};
		_proto._onSelectLeave = function _onSelectLeave(event) {
			this._hoveringCounter--;
			if (this._hoveringCounter === 0) {
				this._isHovering = false;
				this._isPressed = false;
				this._updateVisualState();
			}
			this._fireIfActive('selectleave', event);
		};
		_proto._onClick = function _onClick(event) {
			this._fireIfActive('click', event);
		};
		_proto._fireIfActive = function _fireIfActive(name, event) {
			if (this.data.active) {
				this.fire(name, event);
			}
		};
		_proto._updateVisualState = function _updateVisualState(force) {
			var oldVisualState = this._visualState;
			var newVisualState = this._determineVisualState();
			if ((oldVisualState !== newVisualState || force) && this.enabled) {
				this._visualState = newVisualState;
				if (oldVisualState === VisualState.HOVER) {
					this._fireIfActive('hoverend');
				}
				if (oldVisualState === VisualState.PRESSED) {
					this._fireIfActive('pressedend');
				}
				if (newVisualState === VisualState.HOVER) {
					this._fireIfActive('hoverstart');
				}
				if (newVisualState === VisualState.PRESSED) {
					this._fireIfActive('pressedstart');
				}
				switch (this.transitionMode) {
					case BUTTON_TRANSITION_MODE_TINT:
						{
							var tintName = STATES_TO_TINT_NAMES[this._visualState];
							var tintColor = this[tintName];
							this._applyTint(tintColor);
							break;
						}
					case BUTTON_TRANSITION_MODE_SPRITE_CHANGE:
						{
							var spriteAssetName = STATES_TO_SPRITE_ASSET_NAMES[this._visualState];
							var spriteFrameName = STATES_TO_SPRITE_FRAME_NAMES[this._visualState];
							var spriteAsset = this[spriteAssetName];
							var spriteFrame = this[spriteFrameName];
							this._applySprite(spriteAsset, spriteFrame);
							break;
						}
				}
			}
		};
		_proto._forceReapplyVisualState = function _forceReapplyVisualState() {
			this._updateVisualState(true);
		};
		_proto._resetToDefaultVisualState = function _resetToDefaultVisualState(transitionMode) {
			if (this._imageReference.hasComponent('element')) {
				switch (transitionMode) {
					case BUTTON_TRANSITION_MODE_TINT:
						this._cancelTween();
						this._applyTintImmediately(this._defaultTint);
						break;
					case BUTTON_TRANSITION_MODE_SPRITE_CHANGE:
						this._applySprite(this._defaultSpriteAsset, this._defaultSpriteFrame);
						break;
				}
			}
		};
		_proto._determineVisualState = function _determineVisualState() {
			if (!this.active) {
				return VisualState.INACTIVE;
			} else if (this._isPressed) {
				return VisualState.PRESSED;
			} else if (this._isHovering) {
				return VisualState.HOVER;
			}
			return VisualState.DEFAULT;
		};
		_proto._applySprite = function _applySprite(spriteAsset, spriteFrame) {
			spriteFrame = spriteFrame || 0;
			if (this._imageReference.hasComponent('element')) {
				this._isApplyingSprite = true;
				if (this._imageReference.entity.element.spriteAsset !== spriteAsset) {
					this._imageReference.entity.element.spriteAsset = spriteAsset;
				}
				if (this._imageReference.entity.element.spriteFrame !== spriteFrame) {
					this._imageReference.entity.element.spriteFrame = spriteFrame;
				}
				this._isApplyingSprite = false;
			}
		};
		_proto._applyTint = function _applyTint(tintColor) {
			this._cancelTween();
			if (this.fadeDuration === 0) {
				this._applyTintImmediately(tintColor);
			} else {
				this._applyTintWithTween(tintColor);
			}
		};
		_proto._applyTintImmediately = function _applyTintImmediately(tintColor) {
			if (!tintColor || !this._imageReference.hasComponent('element') || this._imageReference.entity.element.type === ELEMENTTYPE_GROUP) return;
			var color3 = toColor3(tintColor);
			this._isApplyingTint = true;
			if (!color3.equals(this._imageReference.entity.element.color)) this._imageReference.entity.element.color = color3;
			if (this._imageReference.entity.element.opacity !== tintColor.a) this._imageReference.entity.element.opacity = tintColor.a;
			this._isApplyingTint = false;
		};
		_proto._applyTintWithTween = function _applyTintWithTween(tintColor) {
			if (!tintColor || !this._imageReference.hasComponent('element') || this._imageReference.entity.element.type === ELEMENTTYPE_GROUP) return;
			var color3 = toColor3(tintColor);
			var color = this._imageReference.entity.element.color;
			var opacity = this._imageReference.entity.element.opacity;
			if (color3.equals(color) && tintColor.a === opacity) return;
			this._tweenInfo = {
				startTime: now(),
				from: new Color(color.r, color.g, color.b, opacity),
				to: tintColor.clone(),
				lerpColor: new Color()
			};
		};
		_proto._updateTintTween = function _updateTintTween() {
			var elapsedTime = now() - this._tweenInfo.startTime;
			var elapsedProportion = this.fadeDuration === 0 ? 1 : elapsedTime / this.fadeDuration;
			elapsedProportion = math.clamp(elapsedProportion, 0, 1);
			if (Math.abs(elapsedProportion - 1) > 1e-5) {
				var lerpColor = this._tweenInfo.lerpColor;
				lerpColor.lerp(this._tweenInfo.from, this._tweenInfo.to, elapsedProportion);
				this._applyTintImmediately(new Color(lerpColor.r, lerpColor.g, lerpColor.b, lerpColor.a));
			} else {
				this._applyTintImmediately(this._tweenInfo.to);
				this._cancelTween();
			}
		};
		_proto._cancelTween = function _cancelTween() {
			delete this._tweenInfo;
		};
		_proto.onUpdate = function onUpdate() {
			if (this._tweenInfo) {
				this._updateTintTween();
			}
		};
		_proto.onEnable = function onEnable() {
			this._isHovering = false;
			this._hoveringCounter = 0;
			this._isPressed = false;
			this._imageReference.onParentComponentEnable();
			this._toggleHitElementListeners('on');
			this._forceReapplyVisualState();
		};
		_proto.onDisable = function onDisable() {
			this._toggleHitElementListeners('off');
			this._resetToDefaultVisualState(this.transitionMode);
		};
		_proto.onRemove = function onRemove() {
			this._toggleLifecycleListeners('off', this.system);
			this.onDisable();
		};
		return ButtonComponent;
	}(Component);
	function toColor3(color4) {
		return new Color(color4.r, color4.g, color4.b);
	}

	var ButtonComponentData = function ButtonComponentData() {
		this.enabled = true;
		this.active = true;
		this.imageEntity = null;
		this.hitPadding = new Vec4();
		this.transitionMode = BUTTON_TRANSITION_MODE_TINT;
		this.hoverTint = new Color(0.75, 0.75, 0.75);
		this.pressedTint = new Color(0.5, 0.5, 0.5);
		this.inactiveTint = new Color(0.25, 0.25, 0.25);
		this.fadeDuration = 0;
		this.hoverSpriteAsset = null;
		this.hoverSpriteFrame = 0;
		this.pressedSpriteAsset = null;
		this.pressedSpriteFrame = 0;
		this.inactiveSpriteAsset = null;
		this.inactiveSpriteFrame = 0;
	};

	var _schema$h = ['enabled', 'active', {
		name: 'imageEntity',
		type: 'entity'
	}, {
		name: 'hitPadding',
		type: 'vec4'
	}, 'transitionMode', {
		name: 'hoverTint',
		type: 'rgba'
	}, {
		name: 'pressedTint',
		type: 'rgba'
	}, {
		name: 'inactiveTint',
		type: 'rgba'
	}, 'fadeDuration', 'hoverSpriteAsset', 'hoverSpriteFrame', 'pressedSpriteAsset', 'pressedSpriteFrame', 'inactiveSpriteAsset', 'inactiveSpriteFrame'];
	var ButtonComponentSystem = function (_ComponentSystem) {
		_inheritsLoose(ButtonComponentSystem, _ComponentSystem);
		function ButtonComponentSystem(app) {
			var _this;
			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'button';
			_this.ComponentType = ButtonComponent;
			_this.DataType = ButtonComponentData;
			_this.schema = _schema$h;
			_this.on('beforeremove', _this._onRemoveComponent, _assertThisInitialized(_this));
			_this.app.systems.on('update', _this.onUpdate, _assertThisInitialized(_this));
			return _this;
		}
		var _proto = ButtonComponentSystem.prototype;
		_proto.initializeComponentData = function initializeComponentData(component, data, properties) {
			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, _schema$h);
		};
		_proto.onUpdate = function onUpdate(dt) {
			var components = this.store;
			for (var id in components) {
				var entity = components[id].entity;
				var component = entity.button;
				if (component.enabled && entity.enabled) {
					component.onUpdate();
				}
			}
		};
		_proto._onRemoveComponent = function _onRemoveComponent(entity, component) {
			component.onRemove();
		};
		_proto.destroy = function destroy() {
			_ComponentSystem.prototype.destroy.call(this);
			this.app.systems.off('update', this.onUpdate, this);
		};
		return ButtonComponentSystem;
	}(ComponentSystem);
	Component._buildAccessors(ButtonComponent.prototype, _schema$h);

	var _vec3$1 = new Vec3();
	var _quat = new Quat();
	var CollisionComponent = function (_Component) {
		_inheritsLoose(CollisionComponent, _Component);
		function CollisionComponent(system, entity) {
			var _this;
			_this = _Component.call(this, system, entity) || this;
			_this._compoundParent = null;
			_this._hasOffset = false;
			_this.entity.on('insert', _this._onInsert, _assertThisInitialized(_this));
			_this.on('set_type', _this.onSetType, _assertThisInitialized(_this));
			_this.on('set_halfExtents', _this.onSetHalfExtents, _assertThisInitialized(_this));
			_this.on('set_linearOffset', _this.onSetOffset, _assertThisInitialized(_this));
			_this.on('set_angularOffset', _this.onSetOffset, _assertThisInitialized(_this));
			_this.on('set_radius', _this.onSetRadius, _assertThisInitialized(_this));
			_this.on('set_height', _this.onSetHeight, _assertThisInitialized(_this));
			_this.on('set_axis', _this.onSetAxis, _assertThisInitialized(_this));
			_this.on('set_asset', _this.onSetAsset, _assertThisInitialized(_this));
			_this.on('set_renderAsset', _this.onSetRenderAsset, _assertThisInitialized(_this));
			_this.on('set_model', _this.onSetModel, _assertThisInitialized(_this));
			_this.on('set_render', _this.onSetRender, _assertThisInitialized(_this));
			return _this;
		}
		var _proto = CollisionComponent.prototype;
		_proto.onSetType = function onSetType(name, oldValue, newValue) {
			if (oldValue !== newValue) {
				this.system.changeType(this, oldValue, newValue);
			}
		};
		_proto.onSetHalfExtents = function onSetHalfExtents(name, oldValue, newValue) {
			var t = this.data.type;
			if (this.data.initialized && t === 'box') {
				this.system.recreatePhysicalShapes(this);
			}
		};
		_proto.onSetOffset = function onSetOffset(name, oldValue, newValue) {
			this._hasOffset = !this.data.linearOffset.equals(Vec3.ZERO) || !this.data.angularOffset.equals(Quat.IDENTITY);
			if (this.data.initialized) {
				this.system.recreatePhysicalShapes(this);
			}
		};
		_proto.onSetRadius = function onSetRadius(name, oldValue, newValue) {
			var t = this.data.type;
			if (this.data.initialized && (t === 'sphere' || t === 'capsule' || t === 'cylinder' || t === 'cone')) {
				this.system.recreatePhysicalShapes(this);
			}
		};
		_proto.onSetHeight = function onSetHeight(name, oldValue, newValue) {
			var t = this.data.type;
			if (this.data.initialized && (t === 'capsule' || t === 'cylinder' || t === 'cone')) {
				this.system.recreatePhysicalShapes(this);
			}
		};
		_proto.onSetAxis = function onSetAxis(name, oldValue, newValue) {
			var t = this.data.type;
			if (this.data.initialized && (t === 'capsule' || t === 'cylinder' || t === 'cone')) {
				this.system.recreatePhysicalShapes(this);
			}
		};
		_proto.onSetAsset = function onSetAsset(name, oldValue, newValue) {
			var assets = this.system.app.assets;
			if (oldValue) {
				var asset = assets.get(oldValue);
				if (asset) {
					asset.off('remove', this.onAssetRemoved, this);
				}
			}
			if (newValue) {
				if (newValue instanceof Asset) {
					this.data.asset = newValue.id;
				}
				var _asset = assets.get(this.data.asset);
				if (_asset) {
					_asset.off('remove', this.onAssetRemoved, this);
					_asset.on('remove', this.onAssetRemoved, this);
				}
			}
			if (this.data.initialized && this.data.type === 'mesh') {
				if (!newValue) {
					this.data.model = null;
				}
				this.system.recreatePhysicalShapes(this);
			}
		};
		_proto.onSetRenderAsset = function onSetRenderAsset(name, oldValue, newValue) {
			var assets = this.system.app.assets;
			if (oldValue) {
				var asset = assets.get(oldValue);
				if (asset) {
					asset.off('remove', this.onRenderAssetRemoved, this);
				}
			}
			if (newValue) {
				if (newValue instanceof Asset) {
					this.data.renderAsset = newValue.id;
				}
				var _asset2 = assets.get(this.data.renderAsset);
				if (_asset2) {
					_asset2.off('remove', this.onRenderAssetRemoved, this);
					_asset2.on('remove', this.onRenderAssetRemoved, this);
				}
			}
			if (this.data.initialized && this.data.type === 'mesh') {
				if (!newValue) {
					this.data.render = null;
				}
				this.system.recreatePhysicalShapes(this);
			}
		};
		_proto.onSetModel = function onSetModel(name, oldValue, newValue) {
			if (this.data.initialized && this.data.type === 'mesh') {
				this.system.implementations.mesh.doRecreatePhysicalShape(this);
			}
		};
		_proto.onSetRender = function onSetRender(name, oldValue, newValue) {
			this.onSetModel(name, oldValue, newValue);
		};
		_proto.onAssetRemoved = function onAssetRemoved(asset) {
			asset.off('remove', this.onAssetRemoved, this);
			if (this.data.asset === asset.id) {
				this.asset = null;
			}
		};
		_proto.onRenderAssetRemoved = function onRenderAssetRemoved(asset) {
			asset.off('remove', this.onRenderAssetRemoved, this);
			if (this.data.renderAsset === asset.id) {
				this.renderAsset = null;
			}
		};
		_proto._getCompoundChildShapeIndex = function _getCompoundChildShapeIndex(shape) {
			var compound = this.data.shape;
			var shapes = compound.getNumChildShapes();
			for (var i = 0; i < shapes; i++) {
				var childShape = compound.getChildShape(i);
				if (childShape.ptr === shape.ptr) {
					return i;
				}
			}
			return null;
		};
		_proto._onInsert = function _onInsert(parent) {
			if (typeof Ammo === 'undefined') return;
			if (this._compoundParent) {
				this.system.recreatePhysicalShapes(this);
			} else if (!this.entity.rigidbody) {
				var ancestor = this.entity.parent;
				while (ancestor) {
					if (ancestor.collision && ancestor.collision.type === 'compound') {
						if (ancestor.collision.shape.getNumChildShapes() === 0) {
							this.system.recreatePhysicalShapes(ancestor.collision);
						} else {
							this.system.recreatePhysicalShapes(this);
						}
						break;
					}
					ancestor = ancestor.parent;
				}
			}
		};
		_proto._updateCompound = function _updateCompound() {
			var entity = this.entity;
			if (entity._dirtyWorld) {
				var dirty = entity._dirtyLocal;
				var parent = entity;
				while (parent && !dirty) {
					if (parent.collision && parent.collision === this._compoundParent) break;
					if (parent._dirtyLocal) dirty = true;
					parent = parent.parent;
				}
				if (dirty) {
					entity.forEach(this.system.implementations.compound._updateEachDescendantTransform, entity);
					var bodyComponent = this._compoundParent.entity.rigidbody;
					if (bodyComponent) bodyComponent.activate();
				}
			}
		};
		_proto.getShapePosition = function getShapePosition() {
			var pos = this.entity.getPosition();
			if (this._hasOffset) {
				var rot = this.entity.getRotation();
				var lo = this.data.linearOffset;
				_quat.copy(rot).transformVector(lo, _vec3$1);
				return _vec3$1.add(pos);
			}
			return pos;
		};
		_proto.getShapeRotation = function getShapeRotation() {
			var rot = this.entity.getRotation();
			if (this._hasOffset) {
				return _quat.copy(rot).mul(this.data.angularOffset);
			}
			return rot;
		};
		_proto.onEnable = function onEnable() {
			if (this.data.type === 'mesh' && (this.data.asset || this.data.renderAsset) && this.data.initialized) {
				var asset = this.system.app.assets.get(this.data.asset || this.data.renderAsset);
				if (asset && (!asset.resource || !this.data.shape)) {
					this.system.recreatePhysicalShapes(this);
					return;
				}
			}
			if (this.entity.rigidbody) {
				if (this.entity.rigidbody.enabled) {
					this.entity.rigidbody.enableSimulation();
				}
			} else if (this._compoundParent && this !== this._compoundParent) {
				if (this._compoundParent.shape.getNumChildShapes() === 0) {
					this.system.recreatePhysicalShapes(this._compoundParent);
				} else {
					var transform = this.system._getNodeTransform(this.entity, this._compoundParent.entity);
					this._compoundParent.shape.addChildShape(transform, this.data.shape);
					Ammo.destroy(transform);
					if (this._compoundParent.entity.rigidbody) this._compoundParent.entity.rigidbody.activate();
				}
			} else if (this.entity.trigger) {
				this.entity.trigger.enable();
			}
		};
		_proto.onDisable = function onDisable() {
			if (this.entity.rigidbody) {
				this.entity.rigidbody.disableSimulation();
			} else if (this._compoundParent && this !== this._compoundParent) {
				if (!this._compoundParent.entity._destroying) {
					this.system._removeCompoundChild(this._compoundParent, this.data.shape);
					if (this._compoundParent.entity.rigidbody) this._compoundParent.entity.rigidbody.activate();
				}
			} else if (this.entity.trigger) {
				this.entity.trigger.disable();
			}
		};
		_proto.onBeforeRemove = function onBeforeRemove() {
			if (this.asset) {
				this.asset = null;
			}
			if (this.renderAsset) {
				this.renderAsset = null;
			}
			this.entity.off('insert', this._onInsert, this);
			this.off();
		};
		return CollisionComponent;
	}(Component);

	var CollisionComponentData = function CollisionComponentData() {
		this.enabled = true;
		this.type = 'box';
		this.halfExtents = new Vec3(0.5, 0.5, 0.5);
		this.linearOffset = new Vec3();
		this.angularOffset = new Quat();
		this.radius = 0.5;
		this.axis = 1;
		this.height = 2;
		this.asset = null;
		this.renderAsset = null;
		this.shape = null;
		this.model = null;
		this.render = null;
		this.initialized = false;
	};

	var BODYTYPE_STATIC = 'static';
	var BODYTYPE_DYNAMIC = 'dynamic';
	var BODYTYPE_KINEMATIC = 'kinematic';
	var BODYFLAG_STATIC_OBJECT = 1;
	var BODYFLAG_KINEMATIC_OBJECT = 2;
	var BODYFLAG_NORESPONSE_OBJECT = 4;
	var BODYSTATE_ACTIVE_TAG = 1;
	var BODYSTATE_ISLAND_SLEEPING = 2;
	var BODYSTATE_WANTS_DEACTIVATION = 3;
	var BODYSTATE_DISABLE_DEACTIVATION = 4;
	var BODYSTATE_DISABLE_SIMULATION = 5;
	var BODYGROUP_NONE = 0;
	var BODYGROUP_DEFAULT = 1;
	var BODYGROUP_DYNAMIC = 1;
	var BODYGROUP_STATIC = 2;
	var BODYGROUP_KINEMATIC = 4;
	var BODYGROUP_ENGINE_1 = 8;
	var BODYGROUP_TRIGGER = 16;
	var BODYGROUP_ENGINE_2 = 32;
	var BODYGROUP_ENGINE_3 = 64;
	var BODYGROUP_USER_1 = 128;
	var BODYGROUP_USER_2 = 256;
	var BODYGROUP_USER_3 = 512;
	var BODYGROUP_USER_4 = 1024;
	var BODYGROUP_USER_5 = 2048;
	var BODYGROUP_USER_6 = 4096;
	var BODYGROUP_USER_7 = 8192;
	var BODYGROUP_USER_8 = 16384;
	var BODYMASK_NONE = 0;
	var BODYMASK_ALL = 65535;
	var BODYMASK_STATIC = 2;
	var BODYMASK_NOT_STATIC = 65535 ^ 2;
	var BODYMASK_NOT_STATIC_KINEMATIC = 65535 ^ (2 | 4);

	var _ammoVec1$1, _ammoQuat$1, _ammoTransform$1;
	var Trigger = function () {
		function Trigger(app, component, data) {
			this.entity = component.entity;
			this.component = component;
			this.app = app;
			if (typeof Ammo !== 'undefined' && !_ammoVec1$1) {
				_ammoVec1$1 = new Ammo.btVector3();
				_ammoQuat$1 = new Ammo.btQuaternion();
				_ammoTransform$1 = new Ammo.btTransform();
			}
			this.initialize(data);
		}
		var _proto = Trigger.prototype;
		_proto.initialize = function initialize(data) {
			var entity = this.entity;
			var shape = data.shape;
			if (shape && typeof Ammo !== 'undefined') {
				if (entity.trigger) {
					entity.trigger.destroy();
				}
				var mass = 1;
				var component = this.component;
				if (component) {
					var bodyPos = component.getShapePosition();
					var bodyRot = component.getShapeRotation();
					_ammoVec1$1.setValue(bodyPos.x, bodyPos.y, bodyPos.z);
					_ammoQuat$1.setValue(bodyRot.x, bodyRot.y, bodyRot.z, bodyRot.w);
				} else {
					var pos = entity.getPosition();
					var rot = entity.getRotation();
					_ammoVec1$1.setValue(pos.x, pos.y, pos.z);
					_ammoQuat$1.setValue(rot.x, rot.y, rot.z, rot.w);
				}
				_ammoTransform$1.setOrigin(_ammoVec1$1);
				_ammoTransform$1.setRotation(_ammoQuat$1);
				var body = this.app.systems.rigidbody.createBody(mass, shape, _ammoTransform$1);
				body.setRestitution(0);
				body.setFriction(0);
				body.setDamping(0, 0);
				_ammoVec1$1.setValue(0, 0, 0);
				body.setLinearFactor(_ammoVec1$1);
				body.setAngularFactor(_ammoVec1$1);
				body.setCollisionFlags(body.getCollisionFlags() | BODYFLAG_NORESPONSE_OBJECT);
				body.entity = entity;
				this.body = body;
				if (this.component.enabled && entity.enabled) {
					this.enable();
				}
			}
		};
		_proto.destroy = function destroy() {
			var body = this.body;
			if (!body) return;
			this.disable();
			this.app.systems.rigidbody.destroyBody(body);
		};
		_proto._getEntityTransform = function _getEntityTransform(transform) {
			var component = this.component;
			if (component) {
				var bodyPos = component.getShapePosition();
				var bodyRot = component.getShapeRotation();
				_ammoVec1$1.setValue(bodyPos.x, bodyPos.y, bodyPos.z);
				_ammoQuat$1.setValue(bodyRot.x, bodyRot.y, bodyRot.z, bodyRot.w);
			} else {
				var pos = this.entity.getPosition();
				var rot = this.entity.getRotation();
				_ammoVec1$1.setValue(pos.x, pos.y, pos.z);
				_ammoQuat$1.setValue(rot.x, rot.y, rot.z, rot.w);
			}
			transform.setOrigin(_ammoVec1$1);
			transform.setRotation(_ammoQuat$1);
		};
		_proto.updateTransform = function updateTransform() {
			this._getEntityTransform(_ammoTransform$1);
			var body = this.body;
			body.setWorldTransform(_ammoTransform$1);
			body.activate();
		};
		_proto.enable = function enable() {
			var body = this.body;
			if (!body) return;
			var systems = this.app.systems;
			systems.rigidbody.addBody(body, BODYGROUP_TRIGGER, BODYMASK_NOT_STATIC ^ BODYGROUP_TRIGGER);
			systems.rigidbody._triggers.push(this);
			body.forceActivationState(BODYSTATE_ACTIVE_TAG);
			this.updateTransform();
		};
		_proto.disable = function disable() {
			var body = this.body;
			if (!body) return;
			var systems = this.app.systems;
			var idx = systems.rigidbody._triggers.indexOf(this);
			if (idx > -1) {
				systems.rigidbody._triggers.splice(idx, 1);
			}
			systems.rigidbody.removeBody(body);
			body.forceActivationState(BODYSTATE_DISABLE_SIMULATION);
		};
		return Trigger;
	}();

	var mat4 = new Mat4();
	var p1 = new Vec3();
	var p2 = new Vec3();
	var quat$1 = new Quat();
	var tempGraphNode = new GraphNode();
	var _schema$g = ['enabled', 'type', 'halfExtents', 'linearOffset', 'angularOffset', 'radius', 'axis', 'height', 'asset', 'renderAsset', 'shape', 'model', 'render'];
	var CollisionSystemImpl = function () {
		function CollisionSystemImpl(system) {
			this.system = system;
		}
		var _proto = CollisionSystemImpl.prototype;
		_proto.beforeInitialize = function beforeInitialize(component, data) {
			data.shape = null;
			data.model = new Model();
			data.model.graph = new GraphNode();
		};
		_proto.afterInitialize = function afterInitialize(component, data) {
			this.recreatePhysicalShapes(component);
			component.data.initialized = true;
		};
		_proto.reset = function reset(component, data) {
			this.beforeInitialize(component, data);
			this.afterInitialize(component, data);
		};
		_proto.recreatePhysicalShapes = function recreatePhysicalShapes(component) {
			var entity = component.entity;
			var data = component.data;
			if (typeof Ammo !== 'undefined') {
				if (entity.trigger) {
					entity.trigger.destroy();
					delete entity.trigger;
				}
				if (data.shape) {
					if (component._compoundParent) {
						this.system._removeCompoundChild(component._compoundParent, data.shape);
						if (component._compoundParent.entity.rigidbody) component._compoundParent.entity.rigidbody.activate();
					}
					this.destroyShape(data);
				}
				data.shape = this.createPhysicalShape(component.entity, data);
				var firstCompoundChild = !component._compoundParent;
				if (data.type === 'compound' && (!component._compoundParent || component === component._compoundParent)) {
					component._compoundParent = component;
					entity.forEach(this._addEachDescendant, component);
				} else if (data.type !== 'compound') {
					if (component._compoundParent && component === component._compoundParent) {
						entity.forEach(this.system.implementations.compound._updateEachDescendant, component);
					}
					if (!component.rigidbody) {
						component._compoundParent = null;
						var parent = entity.parent;
						while (parent) {
							if (parent.collision && parent.collision.type === 'compound') {
								component._compoundParent = parent.collision;
								break;
							}
							parent = parent.parent;
						}
					}
				}
				if (component._compoundParent) {
					if (component !== component._compoundParent) {
						if (firstCompoundChild && component._compoundParent.shape.getNumChildShapes() === 0) {
							this.system.recreatePhysicalShapes(component._compoundParent);
						} else {
							this.system.updateCompoundChildTransform(entity);
							if (component._compoundParent.entity.rigidbody) component._compoundParent.entity.rigidbody.activate();
						}
					}
				}
				if (entity.rigidbody) {
					entity.rigidbody.disableSimulation();
					entity.rigidbody.createBody();
					if (entity.enabled && entity.rigidbody.enabled) {
						entity.rigidbody.enableSimulation();
					}
				} else if (!component._compoundParent) {
					if (!entity.trigger) {
						entity.trigger = new Trigger(this.system.app, component, data);
					} else {
						entity.trigger.initialize(data);
					}
				}
			}
		};
		_proto.createPhysicalShape = function createPhysicalShape(entity, data) {
			return undefined;
		};
		_proto.updateTransform = function updateTransform(component, position, rotation, scale) {
			if (component.entity.trigger) {
				component.entity.trigger.updateTransform();
			}
		};
		_proto.destroyShape = function destroyShape(data) {
			if (data.shape) {
				Ammo.destroy(data.shape);
				data.shape = null;
			}
		};
		_proto.beforeRemove = function beforeRemove(entity, component) {
			if (component.data.shape) {
				if (component._compoundParent && !component._compoundParent.entity._destroying) {
					this.system._removeCompoundChild(component._compoundParent, component.data.shape);
					if (component._compoundParent.entity.rigidbody) component._compoundParent.entity.rigidbody.activate();
				}
				component._compoundParent = null;
				this.destroyShape(component.data);
			}
		};
		_proto.remove = function remove(entity, data) {
			if (entity.rigidbody && entity.rigidbody.body) {
				entity.rigidbody.disableSimulation();
			}
			if (entity.trigger) {
				entity.trigger.destroy();
				delete entity.trigger;
			}
		};
		_proto.clone = function clone(entity, _clone) {
			var src = this.system.store[entity.getGuid()];
			var data = {
				enabled: src.data.enabled,
				type: src.data.type,
				halfExtents: [src.data.halfExtents.x, src.data.halfExtents.y, src.data.halfExtents.z],
				linearOffset: [src.data.linearOffset.x, src.data.linearOffset.y, src.data.linearOffset.z],
				angularOffset: [src.data.angularOffset.x, src.data.angularOffset.y, src.data.angularOffset.z, src.data.angularOffset.w],
				radius: src.data.radius,
				axis: src.data.axis,
				height: src.data.height,
				asset: src.data.asset,
				renderAsset: src.data.renderAsset,
				model: src.data.model,
				render: src.data.render
			};
			return this.system.addComponent(_clone, data);
		};
		return CollisionSystemImpl;
	}();
	var CollisionBoxSystemImpl = function (_CollisionSystemImpl) {
		_inheritsLoose(CollisionBoxSystemImpl, _CollisionSystemImpl);
		function CollisionBoxSystemImpl() {
			return _CollisionSystemImpl.apply(this, arguments) || this;
		}
		var _proto2 = CollisionBoxSystemImpl.prototype;
		_proto2.createPhysicalShape = function createPhysicalShape(entity, data) {
			if (typeof Ammo !== 'undefined') {
				var he = data.halfExtents;
				var ammoHe = new Ammo.btVector3(he ? he.x : 0.5, he ? he.y : 0.5, he ? he.z : 0.5);
				var shape = new Ammo.btBoxShape(ammoHe);
				Ammo.destroy(ammoHe);
				return shape;
			}
			return undefined;
		};
		return CollisionBoxSystemImpl;
	}(CollisionSystemImpl);
	var CollisionSphereSystemImpl = function (_CollisionSystemImpl2) {
		_inheritsLoose(CollisionSphereSystemImpl, _CollisionSystemImpl2);
		function CollisionSphereSystemImpl() {
			return _CollisionSystemImpl2.apply(this, arguments) || this;
		}
		var _proto3 = CollisionSphereSystemImpl.prototype;
		_proto3.createPhysicalShape = function createPhysicalShape(entity, data) {
			if (typeof Ammo !== 'undefined') {
				return new Ammo.btSphereShape(data.radius);
			}
			return undefined;
		};
		return CollisionSphereSystemImpl;
	}(CollisionSystemImpl);
	var CollisionCapsuleSystemImpl = function (_CollisionSystemImpl3) {
		_inheritsLoose(CollisionCapsuleSystemImpl, _CollisionSystemImpl3);
		function CollisionCapsuleSystemImpl() {
			return _CollisionSystemImpl3.apply(this, arguments) || this;
		}
		var _proto4 = CollisionCapsuleSystemImpl.prototype;
		_proto4.createPhysicalShape = function createPhysicalShape(entity, data) {
			var _data$axis, _data$radius, _data$height;
			var axis = (_data$axis = data.axis) != null ? _data$axis : 1;
			var radius = (_data$radius = data.radius) != null ? _data$radius : 0.5;
			var height = Math.max(((_data$height = data.height) != null ? _data$height : 2) - 2 * radius, 0);
			var shape = null;
			if (typeof Ammo !== 'undefined') {
				switch (axis) {
					case 0:
						shape = new Ammo.btCapsuleShapeX(radius, height);
						break;
					case 1:
						shape = new Ammo.btCapsuleShape(radius, height);
						break;
					case 2:
						shape = new Ammo.btCapsuleShapeZ(radius, height);
						break;
				}
			}
			return shape;
		};
		return CollisionCapsuleSystemImpl;
	}(CollisionSystemImpl);
	var CollisionCylinderSystemImpl = function (_CollisionSystemImpl4) {
		_inheritsLoose(CollisionCylinderSystemImpl, _CollisionSystemImpl4);
		function CollisionCylinderSystemImpl() {
			return _CollisionSystemImpl4.apply(this, arguments) || this;
		}
		var _proto5 = CollisionCylinderSystemImpl.prototype;
		_proto5.createPhysicalShape = function createPhysicalShape(entity, data) {
			var _data$axis2, _data$radius2, _data$height2;
			var axis = (_data$axis2 = data.axis) != null ? _data$axis2 : 1;
			var radius = (_data$radius2 = data.radius) != null ? _data$radius2 : 0.5;
			var height = (_data$height2 = data.height) != null ? _data$height2 : 1;
			var halfExtents = null;
			var shape = null;
			if (typeof Ammo !== 'undefined') {
				switch (axis) {
					case 0:
						halfExtents = new Ammo.btVector3(height * 0.5, radius, radius);
						shape = new Ammo.btCylinderShapeX(halfExtents);
						break;
					case 1:
						halfExtents = new Ammo.btVector3(radius, height * 0.5, radius);
						shape = new Ammo.btCylinderShape(halfExtents);
						break;
					case 2:
						halfExtents = new Ammo.btVector3(radius, radius, height * 0.5);
						shape = new Ammo.btCylinderShapeZ(halfExtents);
						break;
				}
			}
			if (halfExtents) Ammo.destroy(halfExtents);
			return shape;
		};
		return CollisionCylinderSystemImpl;
	}(CollisionSystemImpl);
	var CollisionConeSystemImpl = function (_CollisionSystemImpl5) {
		_inheritsLoose(CollisionConeSystemImpl, _CollisionSystemImpl5);
		function CollisionConeSystemImpl() {
			return _CollisionSystemImpl5.apply(this, arguments) || this;
		}
		var _proto6 = CollisionConeSystemImpl.prototype;
		_proto6.createPhysicalShape = function createPhysicalShape(entity, data) {
			var _data$axis3, _data$radius3, _data$height3;
			var axis = (_data$axis3 = data.axis) != null ? _data$axis3 : 1;
			var radius = (_data$radius3 = data.radius) != null ? _data$radius3 : 0.5;
			var height = (_data$height3 = data.height) != null ? _data$height3 : 1;
			var shape = null;
			if (typeof Ammo !== 'undefined') {
				switch (axis) {
					case 0:
						shape = new Ammo.btConeShapeX(radius, height);
						break;
					case 1:
						shape = new Ammo.btConeShape(radius, height);
						break;
					case 2:
						shape = new Ammo.btConeShapeZ(radius, height);
						break;
				}
			}
			return shape;
		};
		return CollisionConeSystemImpl;
	}(CollisionSystemImpl);
	var CollisionMeshSystemImpl = function (_CollisionSystemImpl6) {
		_inheritsLoose(CollisionMeshSystemImpl, _CollisionSystemImpl6);
		function CollisionMeshSystemImpl() {
			return _CollisionSystemImpl6.apply(this, arguments) || this;
		}
		var _proto7 = CollisionMeshSystemImpl.prototype;
		_proto7.beforeInitialize = function beforeInitialize(component, data) {};
		_proto7.createAmmoMesh = function createAmmoMesh(mesh, node, shape) {
			var triMesh;
			if (this.system._triMeshCache[mesh.id]) {
				triMesh = this.system._triMeshCache[mesh.id];
			} else {
				var vb = mesh.vertexBuffer;
				var format = vb.getFormat();
				var stride;
				var positions;
				for (var i = 0; i < format.elements.length; i++) {
					var element = format.elements[i];
					if (element.name === SEMANTIC_POSITION) {
						positions = new Float32Array(vb.lock(), element.offset);
						stride = element.stride / 4;
						break;
					}
				}
				var indices = [];
				mesh.getIndices(indices);
				var numTriangles = mesh.primitive[0].count / 3;
				var v1 = new Ammo.btVector3();
				var v2 = new Ammo.btVector3();
				var v3 = new Ammo.btVector3();
				var i1, i2, i3;
				var base = mesh.primitive[0].base;
				triMesh = new Ammo.btTriangleMesh();
				this.system._triMeshCache[mesh.id] = triMesh;
				for (var _i = 0; _i < numTriangles; _i++) {
					i1 = indices[base + _i * 3] * stride;
					i2 = indices[base + _i * 3 + 1] * stride;
					i3 = indices[base + _i * 3 + 2] * stride;
					v1.setValue(positions[i1], positions[i1 + 1], positions[i1 + 2]);
					v2.setValue(positions[i2], positions[i2 + 1], positions[i2 + 2]);
					v3.setValue(positions[i3], positions[i3 + 1], positions[i3 + 2]);
					triMesh.addTriangle(v1, v2, v3, true);
				}
				Ammo.destroy(v1);
				Ammo.destroy(v2);
				Ammo.destroy(v3);
			}
			var useQuantizedAabbCompression = true;
			var triMeshShape = new Ammo.btBvhTriangleMeshShape(triMesh, useQuantizedAabbCompression);
			var scaling = this.system._getNodeScaling(node);
			triMeshShape.setLocalScaling(scaling);
			Ammo.destroy(scaling);
			var transform = this.system._getNodeTransform(node);
			shape.addChildShape(transform, triMeshShape);
			Ammo.destroy(transform);
		};
		_proto7.createPhysicalShape = function createPhysicalShape(entity, data) {
			if (typeof Ammo === 'undefined') return undefined;
			if (data.model || data.render) {
				var shape = new Ammo.btCompoundShape();
				if (data.model) {
					var meshInstances = data.model.meshInstances;
					for (var i = 0; i < meshInstances.length; i++) {
						this.createAmmoMesh(meshInstances[i].mesh, meshInstances[i].node, shape);
					}
				} else if (data.render) {
					var meshes = data.render.meshes;
					for (var _i2 = 0; _i2 < meshes.length; _i2++) {
						this.createAmmoMesh(meshes[_i2], tempGraphNode, shape);
					}
				}
				var entityTransform = entity.getWorldTransform();
				var scale = entityTransform.getScale();
				var vec = new Ammo.btVector3(scale.x, scale.y, scale.z);
				shape.setLocalScaling(vec);
				Ammo.destroy(vec);
				return shape;
			}
			return undefined;
		};
		_proto7.recreatePhysicalShapes = function recreatePhysicalShapes(component) {
			var data = component.data;
			if (data.renderAsset || data.asset) {
				if (component.enabled && component.entity.enabled) {
					this.loadAsset(component, data.renderAsset || data.asset, data.renderAsset ? 'render' : 'model');
					return;
				}
			}
			this.doRecreatePhysicalShape(component);
		};
		_proto7.loadAsset = function loadAsset(component, id, property) {
			var _this = this;
			var data = component.data;
			var assets = this.system.app.assets;
			var previousPropertyValue = data[property];
			var onAssetFullyReady = function onAssetFullyReady(asset) {
				if (data[property] !== previousPropertyValue) {
					return;
				}
				data[property] = asset.resource;
				_this.doRecreatePhysicalShape(component);
			};
			var loadAndHandleAsset = function loadAndHandleAsset(asset) {
				asset.ready(function (asset) {
					if (asset.data.containerAsset) {
						var containerAsset = assets.get(asset.data.containerAsset);
						if (containerAsset.loaded) {
							onAssetFullyReady(asset);
						} else {
							containerAsset.ready(function () {
								onAssetFullyReady(asset);
							});
							assets.load(containerAsset);
						}
					} else {
						onAssetFullyReady(asset);
					}
				});
				assets.load(asset);
			};
			var asset = assets.get(id);
			if (asset) {
				loadAndHandleAsset(asset);
			} else {
				assets.once('add:' + id, loadAndHandleAsset);
			}
		};
		_proto7.doRecreatePhysicalShape = function doRecreatePhysicalShape(component) {
			var entity = component.entity;
			var data = component.data;
			if (data.model || data.render) {
				this.destroyShape(data);
				data.shape = this.createPhysicalShape(entity, data);
				if (entity.rigidbody) {
					entity.rigidbody.disableSimulation();
					entity.rigidbody.createBody();
					if (entity.enabled && entity.rigidbody.enabled) {
						entity.rigidbody.enableSimulation();
					}
				} else {
					if (!entity.trigger) {
						entity.trigger = new Trigger(this.system.app, component, data);
					} else {
						entity.trigger.initialize(data);
					}
				}
			} else {
				this.beforeRemove(entity, component);
				this.remove(entity, data);
			}
		};
		_proto7.updateTransform = function updateTransform(component, position, rotation, scale) {
			if (component.shape) {
				var entityTransform = component.entity.getWorldTransform();
				var worldScale = entityTransform.getScale();
				var previousScale = component.shape.getLocalScaling();
				if (worldScale.x !== previousScale.x() || worldScale.y !== previousScale.y() || worldScale.z !== previousScale.z()) {
					this.doRecreatePhysicalShape(component);
				}
			}
			_CollisionSystemImpl6.prototype.updateTransform.call(this, component, position, rotation, scale);
		};
		_proto7.destroyShape = function destroyShape(data) {
			if (!data.shape) return;
			var numShapes = data.shape.getNumChildShapes();
			for (var i = 0; i < numShapes; i++) {
				var shape = data.shape.getChildShape(i);
				Ammo.destroy(shape);
			}
			Ammo.destroy(data.shape);
			data.shape = null;
		};
		return CollisionMeshSystemImpl;
	}(CollisionSystemImpl);
	var CollisionCompoundSystemImpl = function (_CollisionSystemImpl7) {
		_inheritsLoose(CollisionCompoundSystemImpl, _CollisionSystemImpl7);
		function CollisionCompoundSystemImpl() {
			return _CollisionSystemImpl7.apply(this, arguments) || this;
		}
		var _proto8 = CollisionCompoundSystemImpl.prototype;
		_proto8.createPhysicalShape = function createPhysicalShape(entity, data) {
			if (typeof Ammo !== 'undefined') {
				return new Ammo.btCompoundShape();
			}
			return undefined;
		};
		_proto8._addEachDescendant = function _addEachDescendant(entity) {
			if (!entity.collision || entity.rigidbody) return;
			entity.collision._compoundParent = this;
			if (entity !== this.entity) {
				entity.collision.system.recreatePhysicalShapes(entity.collision);
			}
		};
		_proto8._updateEachDescendant = function _updateEachDescendant(entity) {
			if (!entity.collision) return;
			if (entity.collision._compoundParent !== this) return;
			entity.collision._compoundParent = null;
			if (entity !== this.entity && !entity.rigidbody) {
				entity.collision.system.recreatePhysicalShapes(entity.collision);
			}
		};
		_proto8._updateEachDescendantTransform = function _updateEachDescendantTransform(entity) {
			if (!entity.collision || entity.collision._compoundParent !== this.collision._compoundParent) return;
			this.collision.system.updateCompoundChildTransform(entity);
		};
		return CollisionCompoundSystemImpl;
	}(CollisionSystemImpl);
	var CollisionComponentSystem = function (_ComponentSystem) {
		_inheritsLoose(CollisionComponentSystem, _ComponentSystem);
		function CollisionComponentSystem(app) {
			var _this2;
			_this2 = _ComponentSystem.call(this, app) || this;
			_this2.id = 'collision';
			_this2.ComponentType = CollisionComponent;
			_this2.DataType = CollisionComponentData;
			_this2.schema = _schema$g;
			_this2.implementations = {};
			_this2._triMeshCache = {};
			_this2.on('beforeremove', _this2.onBeforeRemove, _assertThisInitialized(_this2));
			_this2.on('remove', _this2.onRemove, _assertThisInitialized(_this2));
			return _this2;
		}
		var _proto9 = CollisionComponentSystem.prototype;
		_proto9.initializeComponentData = function initializeComponentData(component, _data, properties) {
			properties = ['type', 'halfExtents', 'radius', 'axis', 'height', 'shape', 'model', 'asset', 'render', 'renderAsset', 'enabled', 'linearOffset', 'angularOffset'];
			var data = {};
			for (var i = 0, len = properties.length; i < len; i++) {
				var property = properties[i];
				data[property] = _data[property];
			}
			var idx;
			if (_data.hasOwnProperty('asset')) {
				idx = properties.indexOf('model');
				if (idx !== -1) {
					properties.splice(idx, 1);
				}
				idx = properties.indexOf('render');
				if (idx !== -1) {
					properties.splice(idx, 1);
				}
			} else if (_data.hasOwnProperty('model')) {
				idx = properties.indexOf('asset');
				if (idx !== -1) {
					properties.splice(idx, 1);
				}
			}
			if (!data.type) {
				data.type = component.data.type;
			}
			component.data.type = data.type;
			if (Array.isArray(data.halfExtents)) {
				data.halfExtents = new Vec3(data.halfExtents);
			}
			if (Array.isArray(data.linearOffset)) {
				data.linearOffset = new Vec3(data.linearOffset);
			}
			if (Array.isArray(data.angularOffset)) {
				var values = data.angularOffset;
				if (values.length === 3) {
					data.angularOffset = new Quat().setFromEulerAngles(values[0], values[1], values[2]);
				} else {
					data.angularOffset = new Quat(data.angularOffset);
				}
			}
			var impl = this._createImplementation(data.type);
			impl.beforeInitialize(component, data);
			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
			impl.afterInitialize(component, data);
		};
		_proto9._createImplementation = function _createImplementation(type) {
			if (this.implementations[type] === undefined) {
				var impl;
				switch (type) {
					case 'box':
						impl = new CollisionBoxSystemImpl(this);
						break;
					case 'sphere':
						impl = new CollisionSphereSystemImpl(this);
						break;
					case 'capsule':
						impl = new CollisionCapsuleSystemImpl(this);
						break;
					case 'cylinder':
						impl = new CollisionCylinderSystemImpl(this);
						break;
					case 'cone':
						impl = new CollisionConeSystemImpl(this);
						break;
					case 'mesh':
						impl = new CollisionMeshSystemImpl(this);
						break;
					case 'compound':
						impl = new CollisionCompoundSystemImpl(this);
						break;
				}
				this.implementations[type] = impl;
			}
			return this.implementations[type];
		};
		_proto9._getImplementation = function _getImplementation(entity) {
			return this.implementations[entity.collision.data.type];
		};
		_proto9.cloneComponent = function cloneComponent(entity, clone) {
			return this._getImplementation(entity).clone(entity, clone);
		};
		_proto9.onBeforeRemove = function onBeforeRemove(entity, component) {
			this.implementations[component.data.type].beforeRemove(entity, component);
			component.onBeforeRemove();
		};
		_proto9.onRemove = function onRemove(entity, data) {
			this.implementations[data.type].remove(entity, data);
		};
		_proto9.updateCompoundChildTransform = function updateCompoundChildTransform(entity) {
			this._removeCompoundChild(entity.collision._compoundParent, entity.collision.data.shape);
			if (entity.enabled && entity.collision.enabled) {
				var transform = this._getNodeTransform(entity, entity.collision._compoundParent.entity);
				entity.collision._compoundParent.shape.addChildShape(transform, entity.collision.data.shape);
				Ammo.destroy(transform);
			}
		};
		_proto9._removeCompoundChild = function _removeCompoundChild(collision, shape) {
			if (collision.shape.removeChildShape) {
				collision.shape.removeChildShape(shape);
			} else {
				var ind = collision._getCompoundChildShapeIndex(shape);
				if (ind !== null) {
					collision.shape.removeChildShapeByIndex(ind);
				}
			}
		};
		_proto9.onTransformChanged = function onTransformChanged(component, position, rotation, scale) {
			this.implementations[component.data.type].updateTransform(component, position, rotation, scale);
		};
		_proto9.changeType = function changeType(component, previousType, newType) {
			this.implementations[previousType].beforeRemove(component.entity, component);
			this.implementations[previousType].remove(component.entity, component.data);
			this._createImplementation(newType).reset(component, component.data);
		};
		_proto9.recreatePhysicalShapes = function recreatePhysicalShapes(component) {
			this.implementations[component.data.type].recreatePhysicalShapes(component);
		};
		_proto9._calculateNodeRelativeTransform = function _calculateNodeRelativeTransform(node, relative) {
			if (node === relative) {
				var scale = node.getWorldTransform().getScale();
				mat4.setScale(scale.x, scale.y, scale.z);
			} else {
				this._calculateNodeRelativeTransform(node.parent, relative);
				mat4.mul(node.getLocalTransform());
			}
		};
		_proto9._getNodeScaling = function _getNodeScaling(node) {
			var wtm = node.getWorldTransform();
			var scl = wtm.getScale();
			return new Ammo.btVector3(scl.x, scl.y, scl.z);
		};
		_proto9._getNodeTransform = function _getNodeTransform(node, relative) {
			var pos, rot;
			if (relative) {
				this._calculateNodeRelativeTransform(node, relative);
				pos = p1;
				rot = quat$1;
				mat4.getTranslation(pos);
				rot.setFromMat4(mat4);
			} else {
				pos = node.getPosition();
				rot = node.getRotation();
			}
			var ammoQuat = new Ammo.btQuaternion();
			var transform = new Ammo.btTransform();
			transform.setIdentity();
			var origin = transform.getOrigin();
			var component = node.collision;
			if (component && component._hasOffset) {
				var lo = component.data.linearOffset;
				var ao = component.data.angularOffset;
				var newOrigin = p2;
				quat$1.copy(rot).transformVector(lo, newOrigin);
				newOrigin.add(pos);
				quat$1.copy(rot).mul(ao);
				origin.setValue(newOrigin.x, newOrigin.y, newOrigin.z);
				ammoQuat.setValue(quat$1.x, quat$1.y, quat$1.z, quat$1.w);
			} else {
				origin.setValue(pos.x, pos.y, pos.z);
				ammoQuat.setValue(rot.x, rot.y, rot.z, rot.w);
			}
			transform.setRotation(ammoQuat);
			Ammo.destroy(ammoQuat);
			Ammo.destroy(origin);
			return transform;
		};
		_proto9.destroy = function destroy() {
			for (var key in this._triMeshCache) {
				Ammo.destroy(this._triMeshCache[key]);
			}
			this._triMeshCache = null;
			_ComponentSystem.prototype.destroy.call(this);
		};
		return CollisionComponentSystem;
	}(ComponentSystem);
	Component._buildAccessors(CollisionComponent.prototype, _schema$g);

	var _vertexFormatDeviceCache = new DeviceCache();
	var ImageRenderable = function () {
		function ImageRenderable(entity, mesh, material) {
			this._entity = entity;
			this._element = entity.element;
			this.model = new Model();
			this.node = new GraphNode();
			this.model.graph = this.node;
			this.mesh = mesh;
			this.meshInstance = new MeshInstance(this.mesh, material, this.node);
			this.meshInstance.name = 'ImageElement: ' + entity.name;
			this.meshInstance.castShadow = false;
			this.meshInstance.receiveShadow = false;
			this._meshDirty = false;
			this.model.meshInstances.push(this.meshInstance);
			this._entity.addChild(this.model.graph);
			this.model._entity = this._entity;
			this.unmaskMeshInstance = null;
		}
		var _proto = ImageRenderable.prototype;
		_proto.destroy = function destroy() {
			this.setMaterial(null);
			this._element.removeModelFromLayers(this.model);
			this.model.destroy();
			this.model = null;
			this.node = null;
			this.mesh = null;
			this.meshInstance = null;
			this._entity = null;
			this._element = null;
		};
		_proto.setMesh = function setMesh(mesh) {
			if (!this.meshInstance) return;
			this.mesh = mesh;
			this.meshInstance.mesh = mesh;
			this.meshInstance.visible = !!mesh;
			if (this.unmaskMeshInstance) {
				this.unmaskMeshInstance.mesh = mesh;
			}
			this.forceUpdateAabb();
		};
		_proto.setMask = function setMask(mask) {
			if (!this.meshInstance) return;
			if (mask) {
				this.unmaskMeshInstance = new MeshInstance(this.mesh, this.meshInstance.material, this.node);
				this.unmaskMeshInstance.name = 'Unmask: ' + this._entity.name;
				this.unmaskMeshInstance.castShadow = false;
				this.unmaskMeshInstance.receiveShadow = false;
				this.unmaskMeshInstance.pick = false;
				this.model.meshInstances.push(this.unmaskMeshInstance);
				for (var name in this.meshInstance.parameters) {
					this.unmaskMeshInstance.setParameter(name, this.meshInstance.parameters[name].data);
				}
			} else {
				var idx = this.model.meshInstances.indexOf(this.unmaskMeshInstance);
				if (idx >= 0) {
					this.model.meshInstances.splice(idx, 1);
				}
				this.unmaskMeshInstance = null;
			}
			if (this._entity.enabled && this._element.enabled) {
				this._element.removeModelFromLayers(this.model);
				this._element.addModelToLayers(this.model);
			}
		};
		_proto.setMaterial = function setMaterial(material) {
			if (!this.meshInstance) return;
			this.meshInstance.material = material;
			if (this.unmaskMeshInstance) {
				this.unmaskMeshInstance.material = material;
			}
		};
		_proto.setParameter = function setParameter(name, value) {
			if (!this.meshInstance) return;
			this.meshInstance.setParameter(name, value);
			if (this.unmaskMeshInstance) {
				this.unmaskMeshInstance.setParameter(name, value);
			}
		};
		_proto.deleteParameter = function deleteParameter(name) {
			if (!this.meshInstance) return;
			this.meshInstance.deleteParameter(name);
			if (this.unmaskMeshInstance) {
				this.unmaskMeshInstance.deleteParameter(name);
			}
		};
		_proto.setUnmaskDrawOrder = function setUnmaskDrawOrder() {
			if (!this.meshInstance) return;
			var getLastChild = function getLastChild(e) {
				var last;
				var c = e.children;
				var l = c.length;
				if (l) {
					for (var i = 0; i < l; i++) {
						if (c[i].element) {
							last = c[i];
						}
					}
					if (!last) return null;
					var child = getLastChild(last);
					if (child) {
						return child;
					}
					return last;
				}
				return null;
			};
			if (this.unmaskMeshInstance) {
				var lastChild = getLastChild(this._entity);
				if (lastChild && lastChild.element) {
					this.unmaskMeshInstance.drawOrder = lastChild.element.drawOrder + lastChild.element.getMaskOffset();
				} else {
					this.unmaskMeshInstance.drawOrder = this.meshInstance.drawOrder + this._element.getMaskOffset();
				}
			}
		};
		_proto.setDrawOrder = function setDrawOrder(drawOrder) {
			if (!this.meshInstance) return;
			this.meshInstance.drawOrder = drawOrder;
		};
		_proto.setCull = function setCull(cull) {
			if (!this.meshInstance) return;
			var element = this._element;
			var visibleFn = null;
			if (cull && element._isScreenSpace()) {
				visibleFn = function visibleFn(camera) {
					return element.isVisibleForCamera(camera);
				};
			}
			this.meshInstance.cull = cull;
			this.meshInstance.isVisibleFunc = visibleFn;
			if (this.unmaskMeshInstance) {
				this.unmaskMeshInstance.cull = cull;
				this.unmaskMeshInstance.isVisibleFunc = visibleFn;
			}
		};
		_proto.setScreenSpace = function setScreenSpace(screenSpace) {
			if (!this.meshInstance) return;
			this.meshInstance.screenSpace = screenSpace;
			if (this.unmaskMeshInstance) {
				this.unmaskMeshInstance.screenSpace = screenSpace;
			}
		};
		_proto.setLayer = function setLayer(layer) {
			if (!this.meshInstance) return;
			this.meshInstance.layer = layer;
			if (this.unmaskMeshInstance) {
				this.unmaskMeshInstance.layer = layer;
			}
		};
		_proto.forceUpdateAabb = function forceUpdateAabb(mask) {
			if (!this.meshInstance) return;
			this.meshInstance._aabbVer = -1;
			if (this.unmaskMeshInstance) {
				this.unmaskMeshInstance._aabbVer = -1;
			}
		};
		_proto.setAabbFunc = function setAabbFunc(fn) {
			if (!this.meshInstance) return;
			this.meshInstance._updateAabbFunc = fn;
			if (this.unmaskMeshInstance) {
				this.unmaskMeshInstance._updateAabbFunc = fn;
			}
		};
		return ImageRenderable;
	}();
	var ImageElement = function () {
		function ImageElement(element) {
			this._element = element;
			this._entity = element.entity;
			this._system = element.system;
			this._textureAsset = null;
			this._texture = null;
			this._materialAsset = null;
			this._material = null;
			this._spriteAsset = null;
			this._sprite = null;
			this._spriteFrame = 0;
			this._pixelsPerUnit = null;
			this._targetAspectRatio = -1;
			this._rect = new Vec4(0, 0, 1, 1);
			this._mask = false;
			this._maskRef = 0;
			this._outerScale = new Vec2();
			this._outerScaleUniform = new Float32Array(2);
			this._innerOffset = new Vec4();
			this._innerOffsetUniform = new Float32Array(4);
			this._atlasRect = new Vec4();
			this._atlasRectUniform = new Float32Array(4);
			this._defaultMesh = this._createMesh();
			this._renderable = new ImageRenderable(this._entity, this._defaultMesh, this._material);
			this._color = new Color(1, 1, 1, 1);
			this._colorUniform = new Float32Array([1, 1, 1]);
			this._renderable.setParameter('material_emissive', this._colorUniform);
			this._renderable.setParameter('material_opacity', 1);
			this._updateAabbFunc = this._updateAabb.bind(this);
			this._onScreenChange(this._element.screen);
			this._element.on('resize', this._onParentResizeOrPivotChange, this);
			this._element.on('set:pivot', this._onParentResizeOrPivotChange, this);
			this._element.on('screen:set:screenspace', this._onScreenSpaceChange, this);
			this._element.on('set:screen', this._onScreenChange, this);
			this._element.on('set:draworder', this._onDrawOrderChange, this);
			this._element.on('screen:set:resolution', this._onResolutionChange, this);
		}
		var _proto2 = ImageElement.prototype;
		_proto2.destroy = function destroy() {
			this.textureAsset = null;
			this.spriteAsset = null;
			this.materialAsset = null;
			this._renderable.setMesh(this._defaultMesh);
			this._renderable.destroy();
			this._defaultMesh = null;
			this._element.off('resize', this._onParentResizeOrPivotChange, this);
			this._element.off('set:pivot', this._onParentResizeOrPivotChange, this);
			this._element.off('screen:set:screenspace', this._onScreenSpaceChange, this);
			this._element.off('set:screen', this._onScreenChange, this);
			this._element.off('set:draworder', this._onDrawOrderChange, this);
			this._element.off('screen:set:resolution', this._onResolutionChange, this);
		};
		_proto2._onResolutionChange = function _onResolutionChange(res) {};
		_proto2._onParentResizeOrPivotChange = function _onParentResizeOrPivotChange() {
			if (this._renderable.mesh) {
				this._updateMesh(this._renderable.mesh);
			}
		};
		_proto2._onScreenSpaceChange = function _onScreenSpaceChange(value) {
			this._updateMaterial(value);
		};
		_proto2._onScreenChange = function _onScreenChange(screen, previous) {
			if (screen) {
				this._updateMaterial(screen.screen.screenSpace);
			} else {
				this._updateMaterial(false);
			}
		};
		_proto2._onDrawOrderChange = function _onDrawOrderChange(order) {
			this._renderable.setDrawOrder(order);
			if (this.mask && this._element.screen) {
				this._element.screen.screen.once('syncdraworder', function () {
					this._renderable.setUnmaskDrawOrder();
				}, this);
			}
		};
		_proto2._hasUserMaterial = function _hasUserMaterial() {
			return !!this._materialAsset || !!this._material && this._system.defaultImageMaterials.indexOf(this._material) === -1;
		};
		_proto2._use9Slicing = function _use9Slicing() {
			return this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED);
		};
		_proto2._updateMaterial = function _updateMaterial(screenSpace) {
			var mask = !!this._mask;
			var nineSliced = !!(this.sprite && this.sprite.renderMode === SPRITE_RENDERMODE_SLICED);
			var nineTiled = !!(this.sprite && this.sprite.renderMode === SPRITE_RENDERMODE_TILED);
			if (!this._hasUserMaterial()) {
				this._material = this._system.getImageElementMaterial(screenSpace, mask, nineSliced, nineTiled);
			}
			if (this._renderable) {
				this._renderable.setCull(!this._element._isScreenSpace() || this._element._isScreenCulled());
				this._renderable.setMaterial(this._material);
				this._renderable.setScreenSpace(screenSpace);
				this._renderable.setLayer(screenSpace ? LAYER_HUD : LAYER_WORLD);
			}
		};
		_proto2._createMesh = function _createMesh() {
			var element = this._element;
			var w = element.calculatedWidth;
			var h = element.calculatedHeight;
			var r = this._rect;
			var device = this._system.app.graphicsDevice;
			var vertexData = new Float32Array([w, 0, 0, 0, 0, 1, r.x + r.z, 1.0 - r.y, w, h, 0, 0, 0, 1, r.x + r.z, 1.0 - (r.y + r.w), 0, 0, 0, 0, 0, 1, r.x, 1.0 - r.y, 0, h, 0, 0, 0, 1, r.x, 1.0 - (r.y + r.w)]);
			var vertexFormat = _vertexFormatDeviceCache.get(device, function () {
				return new VertexFormat(device, [{
					semantic: SEMANTIC_POSITION,
					components: 3,
					type: TYPE_FLOAT32
				}, {
					semantic: SEMANTIC_NORMAL,
					components: 3,
					type: TYPE_FLOAT32
				}, {
					semantic: SEMANTIC_TEXCOORD0,
					components: 2,
					type: TYPE_FLOAT32
				}]);
			});
			var vertexBuffer = new VertexBuffer(device, vertexFormat, 4, BUFFER_STATIC, vertexData.buffer);
			var mesh = new Mesh(device);
			mesh.vertexBuffer = vertexBuffer;
			mesh.primitive[0].type = PRIMITIVE_TRISTRIP;
			mesh.primitive[0].base = 0;
			mesh.primitive[0].count = 4;
			mesh.primitive[0].indexed = false;
			mesh.aabb.setMinMax(Vec3.ZERO, new Vec3(w, h, 0));
			this._updateMesh(mesh);
			return mesh;
		};
		_proto2._updateMesh = function _updateMesh(mesh) {
			var element = this._element;
			var w = element.calculatedWidth;
			var h = element.calculatedHeight;
			if (element.fitMode !== FITMODE_STRETCH && this._targetAspectRatio > 0) {
				var actualRatio = element.calculatedWidth / element.calculatedHeight;
				if (element.fitMode === FITMODE_CONTAIN && actualRatio > this._targetAspectRatio || element.fitMode === FITMODE_COVER && actualRatio < this._targetAspectRatio) {
					w = element.calculatedHeight * this._targetAspectRatio;
				} else {
					h = element.calculatedWidth / this._targetAspectRatio;
				}
			}
			var screenSpace = element._isScreenSpace();
			this._updateMaterial(screenSpace);
			if (this._renderable) this._renderable.forceUpdateAabb();
			if (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED)) {
				var frameData = this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]];
				var borderWidthScale = 2 / frameData.rect.z;
				var borderHeightScale = 2 / frameData.rect.w;
				this._innerOffset.set(frameData.border.x * borderWidthScale, frameData.border.y * borderHeightScale, frameData.border.z * borderWidthScale, frameData.border.w * borderHeightScale);
				var tex = this.sprite.atlas.texture;
				this._atlasRect.set(frameData.rect.x / tex.width, frameData.rect.y / tex.height, frameData.rect.z / tex.width, frameData.rect.w / tex.height);
				var ppu = this._pixelsPerUnit !== null ? this._pixelsPerUnit : this.sprite.pixelsPerUnit;
				var scaleMulX = frameData.rect.z / ppu;
				var scaleMulY = frameData.rect.w / ppu;
				this._outerScale.set(Math.max(w, this._innerOffset.x * scaleMulX), Math.max(h, this._innerOffset.y * scaleMulY));
				var scaleX = scaleMulX;
				var scaleY = scaleMulY;
				this._outerScale.x /= scaleMulX;
				this._outerScale.y /= scaleMulY;
				scaleX *= math.clamp(w / (this._innerOffset.x * scaleMulX), 0.0001, 1);
				scaleY *= math.clamp(h / (this._innerOffset.y * scaleMulY), 0.0001, 1);
				if (this._renderable) {
					this._innerOffsetUniform[0] = this._innerOffset.x;
					this._innerOffsetUniform[1] = this._innerOffset.y;
					this._innerOffsetUniform[2] = this._innerOffset.z;
					this._innerOffsetUniform[3] = this._innerOffset.w;
					this._renderable.setParameter('innerOffset', this._innerOffsetUniform);
					this._atlasRectUniform[0] = this._atlasRect.x;
					this._atlasRectUniform[1] = this._atlasRect.y;
					this._atlasRectUniform[2] = this._atlasRect.z;
					this._atlasRectUniform[3] = this._atlasRect.w;
					this._renderable.setParameter('atlasRect', this._atlasRectUniform);
					this._outerScaleUniform[0] = this._outerScale.x;
					this._outerScaleUniform[1] = this._outerScale.y;
					this._renderable.setParameter('outerScale', this._outerScaleUniform);
					this._renderable.setAabbFunc(this._updateAabbFunc);
					this._renderable.node.setLocalScale(scaleX, scaleY, 1);
					this._renderable.node.setLocalPosition((0.5 - element.pivot.x) * w, (0.5 - element.pivot.y) * h, 0);
				}
			} else {
				var vb = mesh.vertexBuffer;
				var vertexDataF32 = new Float32Array(vb.lock());
				var hp = element.pivot.x;
				var vp = element.pivot.y;
				vertexDataF32[0] = w - hp * w;
				vertexDataF32[1] = 0 - vp * h;
				vertexDataF32[8] = w - hp * w;
				vertexDataF32[9] = h - vp * h;
				vertexDataF32[16] = 0 - hp * w;
				vertexDataF32[17] = 0 - vp * h;
				vertexDataF32[24] = 0 - hp * w;
				vertexDataF32[25] = h - vp * h;
				var atlasTextureWidth = 1;
				var atlasTextureHeight = 1;
				var rect = this._rect;
				if (this._sprite && this._sprite.frameKeys[this._spriteFrame] && this._sprite.atlas) {
					var frame = this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]];
					if (frame) {
						rect = frame.rect;
						atlasTextureWidth = this._sprite.atlas.texture.width;
						atlasTextureHeight = this._sprite.atlas.texture.height;
					}
				}
				vertexDataF32[6] = (rect.x + rect.z) / atlasTextureWidth;
				vertexDataF32[7] = 1.0 - rect.y / atlasTextureHeight;
				vertexDataF32[14] = (rect.x + rect.z) / atlasTextureWidth;
				vertexDataF32[15] = 1.0 - (rect.y + rect.w) / atlasTextureHeight;
				vertexDataF32[22] = rect.x / atlasTextureWidth;
				vertexDataF32[23] = 1.0 - rect.y / atlasTextureHeight;
				vertexDataF32[30] = rect.x / atlasTextureWidth;
				vertexDataF32[31] = 1.0 - (rect.y + rect.w) / atlasTextureHeight;
				vb.unlock();
				var min = new Vec3(0 - hp * w, 0 - vp * h, 0);
				var max = new Vec3(w - hp * w, h - vp * h, 0);
				mesh.aabb.setMinMax(min, max);
				if (this._renderable) {
					this._renderable.node.setLocalScale(1, 1, 1);
					this._renderable.node.setLocalPosition(0, 0, 0);
					this._renderable.setAabbFunc(null);
				}
			}
			this._meshDirty = false;
		};
		_proto2._updateSprite = function _updateSprite() {
			var nineSlice = false;
			var mesh = null;
			this._targetAspectRatio = -1;
			if (this._sprite && this._sprite.atlas) {
				mesh = this._sprite.meshes[this.spriteFrame];
				nineSlice = this._sprite.renderMode === SPRITE_RENDERMODE_SLICED || this._sprite.renderMode === SPRITE_RENDERMODE_TILED;
				var frameData = this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]];
				if ((frameData == null ? void 0 : frameData.rect.w) > 0) {
					this._targetAspectRatio = frameData.rect.z / frameData.rect.w;
				}
			}
			this.mesh = nineSlice ? mesh : this._defaultMesh;
			this.refreshMesh();
		};
		_proto2.refreshMesh = function refreshMesh() {
			if (this.mesh) {
				if (!this._element._beingInitialized) {
					this._updateMesh(this.mesh);
				} else {
					this._meshDirty = true;
				}
			}
		};
		_proto2._updateAabb = function _updateAabb(aabb) {
			aabb.center.set(0, 0, 0);
			aabb.halfExtents.set(this._outerScale.x * 0.5, this._outerScale.y * 0.5, 0.001);
			aabb.setFromTransformedAabb(aabb, this._renderable.node.getWorldTransform());
			return aabb;
		};
		_proto2._toggleMask = function _toggleMask() {
			this._element._dirtifyMask();
			var screenSpace = this._element._isScreenSpace();
			this._updateMaterial(screenSpace);
			this._renderable.setMask(!!this._mask);
		};
		_proto2._onMaterialLoad = function _onMaterialLoad(asset) {
			this.material = asset.resource;
		};
		_proto2._onMaterialAdded = function _onMaterialAdded(asset) {
			this._system.app.assets.off('add:' + asset.id, this._onMaterialAdded, this);
			if (this._materialAsset === asset.id) {
				this._bindMaterialAsset(asset);
			}
		};
		_proto2._bindMaterialAsset = function _bindMaterialAsset(asset) {
			if (!this._entity.enabled) return;
			asset.on('load', this._onMaterialLoad, this);
			asset.on('change', this._onMaterialChange, this);
			asset.on('remove', this._onMaterialRemove, this);
			if (asset.resource) {
				this._onMaterialLoad(asset);
			} else {
				this._system.app.assets.load(asset);
			}
		};
		_proto2._unbindMaterialAsset = function _unbindMaterialAsset(asset) {
			asset.off('load', this._onMaterialLoad, this);
			asset.off('change', this._onMaterialChange, this);
			asset.off('remove', this._onMaterialRemove, this);
		};
		_proto2._onMaterialChange = function _onMaterialChange() {};
		_proto2._onMaterialRemove = function _onMaterialRemove() {};
		_proto2._onTextureAdded = function _onTextureAdded(asset) {
			this._system.app.assets.off('add:' + asset.id, this._onTextureAdded, this);
			if (this._textureAsset === asset.id) {
				this._bindTextureAsset(asset);
			}
		};
		_proto2._bindTextureAsset = function _bindTextureAsset(asset) {
			if (!this._entity.enabled) return;
			asset.on('load', this._onTextureLoad, this);
			asset.on('change', this._onTextureChange, this);
			asset.on('remove', this._onTextureRemove, this);
			if (asset.resource) {
				this._onTextureLoad(asset);
			} else {
				this._system.app.assets.load(asset);
			}
		};
		_proto2._unbindTextureAsset = function _unbindTextureAsset(asset) {
			asset.off('load', this._onTextureLoad, this);
			asset.off('change', this._onTextureChange, this);
			asset.off('remove', this._onTextureRemove, this);
		};
		_proto2._onTextureLoad = function _onTextureLoad(asset) {
			this.texture = asset.resource;
		};
		_proto2._onTextureChange = function _onTextureChange(asset) {};
		_proto2._onTextureRemove = function _onTextureRemove(asset) {};
		_proto2._onSpriteAssetAdded = function _onSpriteAssetAdded(asset) {
			this._system.app.assets.off('add:' + asset.id, this._onSpriteAssetAdded, this);
			if (this._spriteAsset === asset.id) {
				this._bindSpriteAsset(asset);
			}
		};
		_proto2._bindSpriteAsset = function _bindSpriteAsset(asset) {
			if (!this._entity.enabled) return;
			asset.on('load', this._onSpriteAssetLoad, this);
			asset.on('change', this._onSpriteAssetChange, this);
			asset.on('remove', this._onSpriteAssetRemove, this);
			if (asset.resource) {
				this._onSpriteAssetLoad(asset);
			} else {
				this._system.app.assets.load(asset);
			}
		};
		_proto2._unbindSpriteAsset = function _unbindSpriteAsset(asset) {
			asset.off('load', this._onSpriteAssetLoad, this);
			asset.off('change', this._onSpriteAssetChange, this);
			asset.off('remove', this._onSpriteAssetRemove, this);
			if (asset.data.textureAtlasAsset) {
				this._system.app.assets.off('load:' + asset.data.textureAtlasAsset, this._onTextureAtlasLoad, this);
			}
		};
		_proto2._onSpriteAssetLoad = function _onSpriteAssetLoad(asset) {
			if (!asset || !asset.resource) {
				this.sprite = null;
			} else {
				if (!asset.resource.atlas) {
					var atlasAssetId = asset.data.textureAtlasAsset;
					if (atlasAssetId) {
						var assets = this._system.app.assets;
						assets.off('load:' + atlasAssetId, this._onTextureAtlasLoad, this);
						assets.once('load:' + atlasAssetId, this._onTextureAtlasLoad, this);
					}
				} else {
					this.sprite = asset.resource;
				}
			}
		};
		_proto2._onSpriteAssetChange = function _onSpriteAssetChange(asset) {
			this._onSpriteAssetLoad(asset);
		};
		_proto2._onSpriteAssetRemove = function _onSpriteAssetRemove(asset) {};
		_proto2._bindSprite = function _bindSprite(sprite) {
			sprite.on('set:meshes', this._onSpriteMeshesChange, this);
			sprite.on('set:pixelsPerUnit', this._onSpritePpuChange, this);
			sprite.on('set:atlas', this._onAtlasTextureChange, this);
			if (sprite.atlas) {
				sprite.atlas.on('set:texture', this._onAtlasTextureChange, this);
			}
		};
		_proto2._unbindSprite = function _unbindSprite(sprite) {
			sprite.off('set:meshes', this._onSpriteMeshesChange, this);
			sprite.off('set:pixelsPerUnit', this._onSpritePpuChange, this);
			sprite.off('set:atlas', this._onAtlasTextureChange, this);
			if (sprite.atlas) {
				sprite.atlas.off('set:texture', this._onAtlasTextureChange, this);
			}
		};
		_proto2._onSpriteMeshesChange = function _onSpriteMeshesChange() {
			if (this._sprite) {
				this._spriteFrame = math.clamp(this._spriteFrame, 0, this._sprite.frameKeys.length - 1);
			}
			this._updateSprite();
		};
		_proto2._onSpritePpuChange = function _onSpritePpuChange() {
			if (this.sprite.renderMode !== SPRITE_RENDERMODE_SIMPLE && this._pixelsPerUnit === null) {
				this._updateSprite();
			}
		};
		_proto2._onAtlasTextureChange = function _onAtlasTextureChange() {
			if (this.sprite && this.sprite.atlas && this.sprite.atlas.texture) {
				this._renderable.setParameter('texture_emissiveMap', this._sprite.atlas.texture);
				this._renderable.setParameter('texture_opacityMap', this._sprite.atlas.texture);
			} else {
				this._renderable.deleteParameter('texture_emissiveMap');
				this._renderable.deleteParameter('texture_opacityMap');
			}
		};
		_proto2._onTextureAtlasLoad = function _onTextureAtlasLoad(atlasAsset) {
			var spriteAsset = this._spriteAsset;
			if (spriteAsset instanceof Asset) {
				this._onSpriteAssetLoad(spriteAsset);
			} else {
				this._onSpriteAssetLoad(this._system.app.assets.get(spriteAsset));
			}
		};
		_proto2.onEnable = function onEnable() {
			if (this._materialAsset) {
				var asset = this._system.app.assets.get(this._materialAsset);
				if (asset && asset.resource !== this._material) {
					this._bindMaterialAsset(asset);
				}
			}
			if (this._textureAsset) {
				var _asset = this._system.app.assets.get(this._textureAsset);
				if (_asset && _asset.resource !== this._texture) {
					this._bindTextureAsset(_asset);
				}
			}
			if (this._spriteAsset) {
				var _asset2 = this._system.app.assets.get(this._spriteAsset);
				if (_asset2 && _asset2.resource !== this._sprite) {
					this._bindSpriteAsset(_asset2);
				}
			}
			this._element.addModelToLayers(this._renderable.model);
		};
		_proto2.onDisable = function onDisable() {
			this._element.removeModelFromLayers(this._renderable.model);
		};
		_proto2._setStencil = function _setStencil(stencilParams) {
			this._renderable.meshInstance.stencilFront = stencilParams;
			this._renderable.meshInstance.stencilBack = stencilParams;
			var ref = 0;
			if (this._element.maskedBy) {
				ref = this._element.maskedBy.element._image._maskRef;
			}
			if (this._renderable.unmaskMeshInstance) {
				var sp = new StencilParameters({
					ref: ref + 1,
					func: FUNC_EQUAL,
					zpass: STENCILOP_DECREMENT
				});
				this._renderable.unmaskMeshInstance.stencilFront = sp;
				this._renderable.unmaskMeshInstance.stencilBack = sp;
			}
		};
		_proto2._removeMaterialAssetEvents = function _removeMaterialAssetEvents() {
			if (this._materialAsset) {
				var assets = this._system.app.assets;
				assets.off('add:' + this._materialAsset, this._onMaterialAdded, this);
				var asset = assets.get(this._materialAsset);
				if (asset) {
					asset.off('load', this._onMaterialLoad, this);
					asset.off('change', this._onMaterialChange, this);
					asset.off('remove', this._onMaterialRemove, this);
				}
			}
		};
		_createClass(ImageElement, [{
			key: "color",
			get: function get() {
				return this._color;
			},
			set: function set(value) {
				var r = value.r;
				var g = value.g;
				var b = value.b;
				if (this._color.r !== r || this._color.g !== g || this._color.b !== b) {
					this._color.r = r;
					this._color.g = g;
					this._color.b = b;
					this._colorUniform[0] = r;
					this._colorUniform[1] = g;
					this._colorUniform[2] = b;
					this._renderable.setParameter('material_emissive', this._colorUniform);
				}
				if (this._element) {
					this._element.fire('set:color', this._color);
				}
			}
		}, {
			key: "opacity",
			get: function get() {
				return this._color.a;
			},
			set: function set(value) {
				if (value !== this._color.a) {
					this._color.a = value;
					this._renderable.setParameter('material_opacity', value);
				}
				if (this._element) {
					this._element.fire('set:opacity', value);
				}
			}
		}, {
			key: "rect",
			get: function get() {
				return this._rect;
			},
			set: function set(value) {
				var x, y, z, w;
				if (value instanceof Vec4) {
					x = value.x;
					y = value.y;
					z = value.z;
					w = value.w;
				} else {
					x = value[0];
					y = value[1];
					z = value[2];
					w = value[3];
				}
				if (x === this._rect.x && y === this._rect.y && z === this._rect.z && w === this._rect.w) {
					return;
				}
				this._rect.set(x, y, z, w);
				if (this._renderable.mesh) {
					if (!this._element._beingInitialized) {
						this._updateMesh(this._renderable.mesh);
					} else {
						this._meshDirty = true;
					}
				}
			}
		}, {
			key: "material",
			get: function get() {
				return this._material;
			},
			set: function set(value) {
				if (this._material === value) return;
				if (!value) {
					var screenSpace = this._element._isScreenSpace();
					if (this.mask) {
						value = screenSpace ? this._system.defaultScreenSpaceImageMaskMaterial : this._system.defaultImageMaskMaterial;
					} else {
						value = screenSpace ? this._system.defaultScreenSpaceImageMaterial : this._system.defaultImageMaterial;
					}
				}
				this._material = value;
				if (this._materialAsset) {
					var asset = this._system.app.assets.get(this._materialAsset);
					if (!asset || asset.resource !== value) {
						this._removeMaterialAssetEvents();
						this._materialAsset = null;
					}
				}
				if (value) {
					this._renderable.setMaterial(value);
					if (this._hasUserMaterial()) {
						this._renderable.deleteParameter('material_opacity');
						this._renderable.deleteParameter('material_emissive');
					} else {
						this._colorUniform[0] = this._color.r;
						this._colorUniform[1] = this._color.g;
						this._colorUniform[2] = this._color.b;
						this._renderable.setParameter('material_emissive', this._colorUniform);
						this._renderable.setParameter('material_opacity', this._color.a);
					}
				}
			}
		}, {
			key: "materialAsset",
			get: function get() {
				return this._materialAsset;
			},
			set: function set(value) {
				var assets = this._system.app.assets;
				var _id = value;
				if (value instanceof Asset) {
					_id = value.id;
				}
				if (this._materialAsset !== _id) {
					this._removeMaterialAssetEvents();
					this._materialAsset = _id;
					if (this._materialAsset) {
						var asset = assets.get(this._materialAsset);
						if (!asset) {
							this._materialAsset = null;
							this.material = null;
							this._materialAsset = _id;
							assets.on('add:' + this._materialAsset, this._onMaterialAdded, this);
						} else {
							this._bindMaterialAsset(asset);
						}
					} else {
						this._materialAsset = null;
						this.material = null;
						this._materialAsset = _id;
					}
				}
			}
		}, {
			key: "texture",
			get: function get() {
				return this._texture;
			},
			set: function set(value) {
				if (this._texture === value) return;
				if (this._textureAsset) {
					var textureAsset = this._system.app.assets.get(this._textureAsset);
					if (textureAsset && textureAsset.resource !== value) {
						this.textureAsset = null;
					}
				}
				this._texture = value;
				if (value) {
					if (this._spriteAsset) {
						this.spriteAsset = null;
					}
					this._renderable.setParameter('texture_emissiveMap', this._texture);
					this._renderable.setParameter('texture_opacityMap', this._texture);
					this._colorUniform[0] = this._color.r;
					this._colorUniform[1] = this._color.g;
					this._colorUniform[2] = this._color.b;
					this._renderable.setParameter('material_emissive', this._colorUniform);
					this._renderable.setParameter('material_opacity', this._color.a);
					var newAspectRatio = this._texture.width / this._texture.height;
					if (newAspectRatio !== this._targetAspectRatio) {
						this._targetAspectRatio = newAspectRatio;
						if (this._element.fitMode !== FITMODE_STRETCH) {
							this.refreshMesh();
						}
					}
				} else {
					this._renderable.deleteParameter('texture_emissiveMap');
					this._renderable.deleteParameter('texture_opacityMap');
					this._targetAspectRatio = -1;
					if (this._element.fitMode !== FITMODE_STRETCH) {
						this.refreshMesh();
					}
				}
			}
		}, {
			key: "textureAsset",
			get: function get() {
				return this._textureAsset;
			},
			set: function set(value) {
				var assets = this._system.app.assets;
				var _id = value;
				if (value instanceof Asset) {
					_id = value.id;
				}
				if (this._textureAsset !== _id) {
					if (this._textureAsset) {
						assets.off('add:' + this._textureAsset, this._onTextureAdded, this);
						var _prev = assets.get(this._textureAsset);
						if (_prev) {
							_prev.off('load', this._onTextureLoad, this);
							_prev.off('change', this._onTextureChange, this);
							_prev.off('remove', this._onTextureRemove, this);
						}
					}
					this._textureAsset = _id;
					if (this._textureAsset) {
						var asset = assets.get(this._textureAsset);
						if (!asset) {
							this.texture = null;
							assets.on('add:' + this._textureAsset, this._onTextureAdded, this);
						} else {
							this._bindTextureAsset(asset);
						}
					} else {
						this.texture = null;
					}
				}
			}
		}, {
			key: "spriteAsset",
			get: function get() {
				return this._spriteAsset;
			},
			set: function set(value) {
				var assets = this._system.app.assets;
				var _id = value;
				if (value instanceof Asset) {
					_id = value.id;
				}
				if (this._spriteAsset !== _id) {
					if (this._spriteAsset) {
						assets.off('add:' + this._spriteAsset, this._onSpriteAssetAdded, this);
						var _prev = assets.get(this._spriteAsset);
						if (_prev) {
							this._unbindSpriteAsset(_prev);
						}
					}
					this._spriteAsset = _id;
					if (this._spriteAsset) {
						var asset = assets.get(this._spriteAsset);
						if (!asset) {
							this.sprite = null;
							assets.on('add:' + this._spriteAsset, this._onSpriteAssetAdded, this);
						} else {
							this._bindSpriteAsset(asset);
						}
					} else {
						this.sprite = null;
					}
				}
				if (this._element) {
					this._element.fire('set:spriteAsset', _id);
				}
			}
		}, {
			key: "sprite",
			get: function get() {
				return this._sprite;
			},
			set: function set(value) {
				if (this._sprite === value) return;
				if (this._sprite) {
					this._unbindSprite(this._sprite);
				}
				if (this._spriteAsset) {
					var spriteAsset = this._system.app.assets.get(this._spriteAsset);
					if (spriteAsset && spriteAsset.resource !== value) {
						this.spriteAsset = null;
					}
				}
				this._sprite = value;
				if (this._sprite) {
					this._bindSprite(this._sprite);
					if (this._textureAsset) {
						this.textureAsset = null;
					}
				}
				if (this._sprite && this._sprite.atlas && this._sprite.atlas.texture) {
					this._renderable.setParameter('texture_emissiveMap', this._sprite.atlas.texture);
					this._renderable.setParameter('texture_opacityMap', this._sprite.atlas.texture);
				} else {
					this._renderable.deleteParameter('texture_emissiveMap');
					this._renderable.deleteParameter('texture_opacityMap');
				}
				if (this._sprite) {
					this._spriteFrame = math.clamp(this._spriteFrame, 0, this._sprite.frameKeys.length - 1);
				}
				this._updateSprite();
			}
		}, {
			key: "spriteFrame",
			get: function get() {
				return this._spriteFrame;
			},
			set: function set(value) {
				var oldValue = this._spriteFrame;
				if (this._sprite) {
					this._spriteFrame = math.clamp(value, 0, this._sprite.frameKeys.length - 1);
				} else {
					this._spriteFrame = value;
				}
				if (this._spriteFrame !== oldValue) {
					this._updateSprite();
				}
				if (this._element) {
					this._element.fire('set:spriteFrame', value);
				}
			}
		}, {
			key: "mesh",
			get: function get() {
				return this._renderable.mesh;
			},
			set: function set(value) {
				this._renderable.setMesh(value);
				if (this._defaultMesh === value) {
					this._renderable.setAabbFunc(null);
				} else {
					this._renderable.setAabbFunc(this._updateAabbFunc);
				}
			}
		}, {
			key: "mask",
			get: function get() {
				return this._mask;
			},
			set: function set(value) {
				if (this._mask !== value) {
					this._mask = value;
					this._toggleMask();
				}
			}
		}, {
			key: "pixelsPerUnit",
			get: function get() {
				return this._pixelsPerUnit;
			},
			set: function set(value) {
				if (this._pixelsPerUnit === value) return;
				this._pixelsPerUnit = value;
				if (this._sprite && (this._sprite.renderMode === SPRITE_RENDERMODE_SLICED || this._sprite.renderMode === SPRITE_RENDERMODE_TILED)) {
					this._updateSprite();
				}
			}
		}, {
			key: "aabb",
			get: function get() {
				if (this._renderable.meshInstance) {
					return this._renderable.meshInstance.aabb;
				}
				return null;
			}
		}]);
		return ImageElement;
	}();

	var LocalizedAsset = function (_EventHandler) {
		_inheritsLoose(LocalizedAsset, _EventHandler);
		function LocalizedAsset(app) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this._app = app;
			app.i18n.on('set:locale', _this._onSetLocale, _assertThisInitialized(_this));
			_this._autoLoad = false;
			_this._disableLocalization = false;
			_this._defaultAsset = null;
			_this._localizedAsset = null;
			return _this;
		}
		var _proto = LocalizedAsset.prototype;
		_proto._bindDefaultAsset = function _bindDefaultAsset() {
			var asset = this._app.assets.get(this._defaultAsset);
			if (!asset) {
				this._app.assets.once('add:' + this._defaultAsset, this._onDefaultAssetAdd, this);
			} else {
				this._onDefaultAssetAdd(asset);
			}
		};
		_proto._unbindDefaultAsset = function _unbindDefaultAsset() {
			if (!this._defaultAsset) return;
			this._app.assets.off('add:' + this._defaultAsset, this._onDefaultAssetAdd, this);
			var asset = this._app.assets.get(this._defaultAsset);
			if (!asset) return;
			asset.off('add:localized', this._onLocaleAdd, this);
			asset.off('remove:localized', this._onLocaleRemove, this);
			asset.off('remove', this._onDefaultAssetRemove, this);
		};
		_proto._onDefaultAssetAdd = function _onDefaultAssetAdd(asset) {
			if (this._defaultAsset !== asset.id) return;
			asset.on('add:localized', this._onLocaleAdd, this);
			asset.on('remove:localized', this._onLocaleRemove, this);
			asset.once('remove', this._onDefaultAssetRemove, this);
		};
		_proto._onDefaultAssetRemove = function _onDefaultAssetRemove(asset) {
			if (this._defaultAsset !== asset.id) return;
			asset.off('add:localized', this._onLocaleAdd, this);
			asset.off('remove:localized', this._onLocaleAdd, this);
			this._app.assets.once('add:' + this._defaultAsset, this._onDefaultAssetAdd, this);
		};
		_proto._bindLocalizedAsset = function _bindLocalizedAsset() {
			if (!this._autoLoad) return;
			var asset = this._app.assets.get(this._localizedAsset);
			if (!asset) return;
			asset.on('load', this._onLocalizedAssetLoad, this);
			asset.on('change', this._onLocalizedAssetChange, this);
			asset.on('remove', this._onLocalizedAssetRemove, this);
			if (asset.resource) {
				this._onLocalizedAssetLoad(asset);
			} else {
				this._app.assets.load(asset);
			}
		};
		_proto._unbindLocalizedAsset = function _unbindLocalizedAsset() {
			var asset = this._app.assets.get(this._localizedAsset);
			if (!asset) return;
			asset.off('load', this._onLocalizedAssetLoad, this);
			asset.off('change', this._onLocalizedAssetChange, this);
			asset.off('remove', this._onLocalizedAssetRemove, this);
		};
		_proto._onLocalizedAssetAdd = function _onLocalizedAssetAdd(asset) {
			if (this._localizedAsset !== asset.id) return;
			this._bindLocalizedAsset();
		};
		_proto._onLocalizedAssetLoad = function _onLocalizedAssetLoad(asset) {
			this.fire('load', asset);
		};
		_proto._onLocalizedAssetChange = function _onLocalizedAssetChange(asset, name, newValue, oldValue) {
			this.fire('change', asset, name, newValue, oldValue);
		};
		_proto._onLocalizedAssetRemove = function _onLocalizedAssetRemove(asset) {
			if (this._localizedAsset === asset.id) {
				this.localizedAsset = this._defaultAsset;
			}
			this.fire('remove', asset);
		};
		_proto._onLocaleAdd = function _onLocaleAdd(locale, assetId) {
			if (this._app.i18n.locale !== locale) return;
			this._onSetLocale(locale);
		};
		_proto._onLocaleRemove = function _onLocaleRemove(locale, assetId) {
			if (this._app.i18n.locale !== locale) return;
			this._onSetLocale(locale);
		};
		_proto._onSetLocale = function _onSetLocale(locale) {
			if (!this._defaultAsset) {
				this.localizedAsset = null;
				return;
			}
			var asset = this._app.assets.get(this._defaultAsset);
			if (!asset || this._disableLocalization) {
				this.localizedAsset = this._defaultAsset;
				return;
			}
			var localizedAssetId = asset.getLocalizedAssetId(locale);
			if (!localizedAssetId) {
				this.localizedAsset = this._defaultAsset;
				return;
			}
			this.localizedAsset = localizedAssetId;
		};
		_proto.destroy = function destroy() {
			this.defaultAsset = null;
			this._app.i18n.off('set:locale', this._onSetLocale, this);
			this.off();
		};
		_createClass(LocalizedAsset, [{
			key: "defaultAsset",
			get: function get() {
				return this._defaultAsset;
			},
			set: function set(value) {
				var id = value instanceof Asset ? value.id : value;
				if (this._defaultAsset === id) return;
				if (this._defaultAsset) {
					this._unbindDefaultAsset();
				}
				this._defaultAsset = id;
				if (this._defaultAsset) {
					this._bindDefaultAsset();
				}
				this._onSetLocale(this._app.i18n.locale);
			}
		}, {
			key: "localizedAsset",
			get: function get() {
				return this._localizedAsset;
			},
			set: function set(value) {
				var id = value instanceof Asset ? value.id : value;
				if (this._localizedAsset === id) {
					return;
				}
				if (this._localizedAsset) {
					this._app.assets.off('add:' + this._localizedAsset, this._onLocalizedAssetAdd, this);
					this._unbindLocalizedAsset();
					this._localizedAsset = null;
				}
				this._localizedAsset = id;
				if (this._localizedAsset) {
					var asset = this._app.assets.get(this._localizedAsset);
					if (!asset) {
						this._app.assets.once('add:' + this._localizedAsset, this._onLocalizedAssetAdd, this);
					} else {
						this._bindLocalizedAsset();
					}
				}
			}
		}, {
			key: "autoLoad",
			get: function get() {
				return this._autoLoad;
			},
			set: function set(value) {
				if (this._autoLoad === value) return;
				this._autoLoad = value;
				if (this._autoLoad && this._localizedAsset) {
					this._unbindLocalizedAsset();
					this._bindLocalizedAsset();
				}
			}
		}, {
			key: "disableLocalization",
			get: function get() {
				return this._disableLocalization;
			},
			set: function set(value) {
				if (this._disableLocalization === value) return;
				this._disableLocalization = value;
				this._onSetLocale(this._app.i18n.locale);
			}
		}]);
		return LocalizedAsset;
	}(EventHandler);

	var FONT_MSDF = 'msdf';
	var FONT_BITMAP = 'bitmap';

	var EOF_TOKEN = 0;
	var ERROR_TOKEN = 1;
	var TEXT_TOKEN = 2;
	var OPEN_BRACKET_TOKEN = 3;
	var CLOSE_BRACKET_TOKEN = 4;
	var EQUALS_TOKEN = 5;
	var STRING_TOKEN = 6;
	var IDENTIFIER_TOKEN = 7;
	var WHITESPACE_TOKEN = 8;
	var WHITESPACE_CHARS = ' \t\n\r\v\f';
	var IDENTIFIER_REGEX = /[A-Z|a-z|0-9|_|-|/]/;
	var Scanner = function () {
		function Scanner(symbols) {
			this._symbols = symbols;
			this._index = 0;
			this._last = 0;
			this._cur = this._symbols.length > 0 ? this._symbols[0] : null;
			this._buf = [];
			this._mode = 'text';
			this._error = null;
		}
		var _proto = Scanner.prototype;
		_proto.read = function read() {
			var token = this._read();
			while (token === WHITESPACE_TOKEN) {
				token = this._read();
			}
			if (token !== EOF_TOKEN && token !== ERROR_TOKEN) {
				this._last = this._index;
			}
			return token;
		};
		_proto.buf = function buf() {
			return this._buf;
		};
		_proto.last = function last() {
			return this._last;
		};
		_proto.error = function error() {
			return this._error;
		};
		_proto.debugPrint = function debugPrint() {
			var tokenStrings = ['EOF', 'ERROR', 'TEXT', 'OPEN_BRACKET', 'CLOSE_BRACKET', 'EQUALS', 'STRING', 'IDENTIFIER', 'WHITESPACE'];
			var token = this.read();
			var result = '';
			while (true) {
				result += (result.length > 0 ? '\n' : '') + tokenStrings[token] + ' \'' + this.buf().join('') + '\'';
				if (token === EOF_TOKEN || token === ERROR_TOKEN) {
					break;
				}
				token = this.read();
			}
			return result;
		};
		_proto._read = function _read() {
			this._buf = [];
			if (this._eof()) {
				return EOF_TOKEN;
			}
			return this._mode === 'text' ? this._text() : this._tag();
		};
		_proto._text = function _text() {
			while (true) {
				switch (this._cur) {
					case null:
						return this._buf.length > 0 ? TEXT_TOKEN : EOF_TOKEN;
					case '[':
						this._mode = 'tag';
						return this._buf.length > 0 ? TEXT_TOKEN : this._tag();
					case '\\':
						this._next();
						switch (this._cur) {
							case '[':
								this._store();
								break;
							default:
								this._output('\\');
								break;
						}
						break;
					default:
						this._store();
						break;
				}
			}
		};
		_proto._tag = function _tag() {
			switch (this._cur) {
				case null:
					this._error = 'unexpected end of input reading tag';
					return ERROR_TOKEN;
				case '[':
					this._store();
					return OPEN_BRACKET_TOKEN;
				case ']':
					this._store();
					this._mode = 'text';
					return CLOSE_BRACKET_TOKEN;
				case '=':
					this._store();
					return EQUALS_TOKEN;
				case ' ':
				case '\t':
				case '\n':
				case '\r':
				case '\v':
				case '\f':
					return this._whitespace();
				case '"':
					return this._string();
				default:
					if (!this._isIdentifierSymbol(this._cur)) {
						this._error = 'unrecognized character';
						return ERROR_TOKEN;
					}
					return this._identifier();
			}
		};
		_proto._whitespace = function _whitespace() {
			this._store();
			while (WHITESPACE_CHARS.indexOf(this._cur) !== -1) {
				this._store();
			}
			return WHITESPACE_TOKEN;
		};
		_proto._string = function _string() {
			this._next();
			while (true) {
				switch (this._cur) {
					case null:
						this._error = 'unexpected end of input reading string';
						return ERROR_TOKEN;
					case '"':
						this._next();
						return STRING_TOKEN;
					default:
						this._store();
						break;
				}
			}
		};
		_proto._identifier = function _identifier() {
			this._store();
			while (this._cur !== null && this._isIdentifierSymbol(this._cur)) {
				this._store();
			}
			return IDENTIFIER_TOKEN;
		};
		_proto._isIdentifierSymbol = function _isIdentifierSymbol(s) {
			return s.length === 1 && s.match(IDENTIFIER_REGEX) !== null;
		};
		_proto._eof = function _eof() {
			return this._cur === null;
		};
		_proto._next = function _next() {
			if (!this._eof()) {
				this._index++;
				this._cur = this._index < this._symbols.length ? this._symbols[this._index] : null;
			}
			return this._cur;
		};
		_proto._store = function _store() {
			this._buf.push(this._cur);
			return this._next();
		};
		_proto._output = function _output(c) {
			this._buf.push(c);
		};
		return Scanner;
	}();
	var Parser = function () {
		function Parser(symbols) {
			this._scanner = new Scanner(symbols);
			this._error = null;
		}
		var _proto2 = Parser.prototype;
		_proto2.parse = function parse(symbols, tags) {
			while (true) {
				var token = this._scanner.read();
				switch (token) {
					case EOF_TOKEN:
						return true;
					case ERROR_TOKEN:
						return false;
					case TEXT_TOKEN:
						Array.prototype.push.apply(symbols, this._scanner.buf());
						break;
					case OPEN_BRACKET_TOKEN:
						if (!this._parseTag(symbols, tags)) {
							return false;
						}
						break;
					default:
						return false;
				}
			}
		};
		_proto2.error = function error() {
			return 'Error evaluating markup at #' + this._scanner.last().toString() + ' (' + (this._scanner.error() || this._error) + ')';
		};
		_proto2._parseTag = function _parseTag(symbols, tags) {
			var token = this._scanner.read();
			if (token !== IDENTIFIER_TOKEN) {
				this._error = 'expected identifier';
				return false;
			}
			var name = this._scanner.buf().join('');
			if (name[0] === '/') {
				for (var index = tags.length - 1; index >= 0; --index) {
					if (name === '/' + tags[index].name && tags[index].end === null) {
						tags[index].end = symbols.length;
						token = this._scanner.read();
						if (token !== CLOSE_BRACKET_TOKEN) {
							this._error = 'expected close bracket';
							return false;
						}
						return true;
					}
				}
				this._error = 'failed to find matching tag';
				return false;
			}
			var tag = {
				name: name,
				value: null,
				attributes: {},
				start: symbols.length,
				end: null
			};
			token = this._scanner.read();
			if (token === EQUALS_TOKEN) {
				token = this._scanner.read();
				if (token !== STRING_TOKEN) {
					this._error = 'expected string';
					return false;
				}
				tag.value = this._scanner.buf().join('');
				token = this._scanner.read();
			}
			while (true) {
				switch (token) {
					case CLOSE_BRACKET_TOKEN:
						tags.push(tag);
						return true;
					case IDENTIFIER_TOKEN:
						{
							var identifier = this._scanner.buf().join('');
							token = this._scanner.read();
							if (token !== EQUALS_TOKEN) {
								this._error = 'expected equals';
								return false;
							}
							token = this._scanner.read();
							if (token !== STRING_TOKEN) {
								this._error = 'expected string';
								return false;
							}
							var value = this._scanner.buf().join('');
							tag.attributes[identifier] = value;
							break;
						}
					default:
						this._error = 'expected close bracket or identifier';
						return false;
				}
				token = this._scanner.read();
			}
		};
		return Parser;
	}();
	function merge(target, source) {
		for (var key in source) {
			if (!source.hasOwnProperty(key)) {
				continue;
			}
			var value = source[key];
			if (value instanceof Object) {
				if (!target.hasOwnProperty(key)) {
					target[key] = {};
				}
				merge(target[key], source[key]);
			} else {
				target[key] = value;
			}
		}
	}
	function combineTags(tags) {
		if (tags.length === 0) {
			return null;
		}
		var result = {};
		for (var index = 0; index < tags.length; ++index) {
			var tag = tags[index];
			var tmp = {};
			tmp[tag.name] = {
				value: tag.value,
				attributes: tag.attributes
			};
			merge(result, tmp);
		}
		return result;
	}
	function resolveMarkupTags(tags, numSymbols) {
		if (tags.length === 0) {
			return null;
		}
		var edges = {};
		for (var index = 0; index < tags.length; ++index) {
			var tag = tags[index];
			if (!edges.hasOwnProperty(tag.start)) {
				edges[tag.start] = {
					open: [tag],
					close: null
				};
			} else {
				if (edges[tag.start].open === null) {
					edges[tag.start].open = [tag];
				} else {
					edges[tag.start].open.push(tag);
				}
			}
			if (!edges.hasOwnProperty(tag.end)) {
				edges[tag.end] = {
					open: null,
					close: [tag]
				};
			} else {
				if (edges[tag.end].close === null) {
					edges[tag.end].close = [tag];
				} else {
					edges[tag.end].close.push(tag);
				}
			}
		}
		var tagStack = [];
		function removeTags(tags) {
			tagStack = tagStack.filter(function (tag) {
				return tags.find(function (t) {
					return t === tag;
				}) === undefined;
			});
		}
		function addTags(tags) {
			for (var _index = 0; _index < tags.length; ++_index) {
				tagStack.push(tags[_index]);
			}
		}
		var edgeKeys = Object.keys(edges).sort(function (a, b) {
			return a - b;
		});
		var resolvedTags = [];
		for (var _index2 = 0; _index2 < edgeKeys.length; ++_index2) {
			var edge = edges[edgeKeys[_index2]];
			if (edge.close !== null) {
				removeTags(edge.close);
			}
			if (edge.open !== null) {
				addTags(edge.open);
			}
			resolvedTags.push({
				start: edgeKeys[_index2],
				tags: combineTags(tagStack)
			});
		}
		var result = [];
		var prevTag = null;
		for (var _index3 = 0; _index3 < resolvedTags.length; ++_index3) {
			var resolvedTag = resolvedTags[_index3];
			while (result.length < resolvedTag.start) {
				result.push(prevTag ? prevTag.tags : null);
			}
			prevTag = resolvedTag;
		}
		while (result.length < numSymbols) {
			result.push(null);
		}
		return result;
	}
	function evaluateMarkup(symbols) {
		var parser = new Parser(symbols);
		var stripped_symbols = [];
		var tags = [];
		if (!parser.parse(stripped_symbols, tags)) {
			console.warn(parser.error());
			return {
				symbols: symbols,
				tags: null
			};
		}
		var invalidTag = tags.find(function (t) {
			return t.end === null;
		});
		if (invalidTag) {
			console.warn("Markup error: found unclosed tag='" + invalidTag.name + "'");
			return {
				symbols: symbols,
				tags: null
			};
		}
		var resolved_tags = resolveMarkupTags(tags, stripped_symbols.length);
		return {
			symbols: stripped_symbols,
			tags: resolved_tags
		};
	}
	var Markup = function () {
		function Markup() {}
		Markup.evaluate = function evaluate(symbols) {
			return evaluateMarkup(symbols);
		};
		return Markup;
	}();

	var MeshInfo = function MeshInfo() {
		this.count = 0;
		this.quad = 0;
		this.lines = {};
		this.positions = [];
		this.normals = [];
		this.uvs = [];
		this.colors = [];
		this.indices = [];
		this.outlines = [];
		this.shadows = [];
		this.meshInstance = null;
	};
	function createTextMesh(device, meshInfo) {
		var mesh = new Mesh(device);
		mesh.setPositions(meshInfo.positions);
		mesh.setNormals(meshInfo.normals);
		mesh.setColors32(meshInfo.colors);
		mesh.setUvs(0, meshInfo.uvs);
		mesh.setIndices(meshInfo.indices);
		mesh.setVertexStream(SEMANTIC_ATTR8, meshInfo.outlines, 3, undefined, TYPE_FLOAT32, false);
		mesh.setVertexStream(SEMANTIC_ATTR9, meshInfo.shadows, 3, undefined, TYPE_FLOAT32, false);
		mesh.update();
		return mesh;
	}
	var LINE_BREAK_CHAR = /^[\r\n]$/;
	var WHITESPACE_CHAR = /^[ \t]$/;
	var WORD_BOUNDARY_CHAR = /^[ \t\-]|[\u200b]$/;
	var ALPHANUMERIC_CHAR = /^[a-z0-9]$/i;
	var CJK_CHAR = /^[\u1100-\u11ff]|[\u3000-\u9fff]|[\ua960-\ua97f]|[\uac00-\ud7ff]$/;
	var NO_LINE_BREAK_CJK_CHAR = /^[〕〉》」』】〙〗〟ヽヾーァィゥェォッャュョヮヵヶぁぃぅぇぉっゃゅょゎゕゖㇰㇱㇲㇳㇴㇵㇶㇷㇸㇹㇺㇻㇼㇽㇾㇿ々〻]$/;
	var CONTROL_CHARS = ["\u200B", "\u061C", "\u200E", "\u200F", "\u202A", "\u202B", "\u202C", "\u202D", "\u202E", "\u2066", "\u2067", "\u2068", "\u2069"];
	var CONTROL_GLYPH_DATA = {
		width: 0,
		height: 0,
		xadvance: 0,
		xoffset: 0,
		yoffset: 0
	};
	var colorTmp = new Color();
	var vec2Tmp = new Vec2();
	var TextElement = function () {
		function TextElement(element) {
			this._element = element;
			this._system = element.system;
			this._entity = element.entity;
			this._text = '';
			this._symbols = [];
			this._colorPalette = [];
			this._outlinePalette = [];
			this._shadowPalette = [];
			this._symbolColors = null;
			this._symbolOutlineParams = null;
			this._symbolShadowParams = null;
			this._i18nKey = null;
			this._fontAsset = new LocalizedAsset(this._system.app);
			this._fontAsset.disableLocalization = true;
			this._fontAsset.on('load', this._onFontLoad, this);
			this._fontAsset.on('change', this._onFontChange, this);
			this._fontAsset.on('remove', this._onFontRemove, this);
			this._font = null;
			this._color = new Color(1, 1, 1, 1);
			this._colorUniform = new Float32Array(3);
			this._spacing = 1;
			this._fontSize = 32;
			this._fontMinY = 0;
			this._fontMaxY = 0;
			this._originalFontSize = 32;
			this._maxFontSize = 32;
			this._minFontSize = 8;
			this._autoFitWidth = false;
			this._autoFitHeight = false;
			this._maxLines = -1;
			this._lineHeight = 32;
			this._scaledLineHeight = 32;
			this._wrapLines = false;
			this._drawOrder = 0;
			this._alignment = new Vec2(0.5, 0.5);
			this._autoWidth = true;
			this._autoHeight = true;
			this.width = 0;
			this.height = 0;
			this._node = new GraphNode();
			this._model = new Model();
			this._model.graph = this._node;
			this._entity.addChild(this._node);
			this._meshInfo = [];
			this._material = null;
			this._aabbDirty = true;
			this._aabb = new BoundingBox();
			this._noResize = false;
			this._currentMaterialType = null;
			this._maskedMaterialSrc = null;
			this._rtlReorder = false;
			this._unicodeConverter = false;
			this._rtl = false;
			this._outlineColor = new Color(0, 0, 0, 1);
			this._outlineColorUniform = new Float32Array(4);
			this._outlineThicknessScale = 0.2;
			this._outlineThickness = 0.0;
			this._shadowColor = new Color(0, 0, 0, 1);
			this._shadowColorUniform = new Float32Array(4);
			this._shadowOffsetScale = 0.005;
			this._shadowOffset = new Vec2(0, 0);
			this._shadowOffsetUniform = new Float32Array(2);
			this._enableMarkup = false;
			this._onScreenChange(this._element.screen);
			element.on('resize', this._onParentResize, this);
			element.on('set:screen', this._onScreenChange, this);
			element.on('screen:set:screenspace', this._onScreenSpaceChange, this);
			element.on('set:draworder', this._onDrawOrderChange, this);
			element.on('set:pivot', this._onPivotChange, this);
			this._system.app.i18n.on('set:locale', this._onLocaleSet, this);
			this._system.app.i18n.on('data:add', this._onLocalizationData, this);
			this._system.app.i18n.on('data:remove', this._onLocalizationData, this);
			this._rangeStart = 0;
			this._rangeEnd = 0;
		}
		var _proto = TextElement.prototype;
		_proto.destroy = function destroy() {
			this._setMaterial(null);
			if (this._model) {
				this._element.removeModelFromLayers(this._model);
				this._model.destroy();
				this._model = null;
			}
			this._fontAsset.destroy();
			this.font = null;
			this._element.off('resize', this._onParentResize, this);
			this._element.off('set:screen', this._onScreenChange, this);
			this._element.off('screen:set:screenspace', this._onScreenSpaceChange, this);
			this._element.off('set:draworder', this._onDrawOrderChange, this);
			this._element.off('set:pivot', this._onPivotChange, this);
			this._system.app.i18n.off('set:locale', this._onLocaleSet, this);
			this._system.app.i18n.off('data:add', this._onLocalizationData, this);
			this._system.app.i18n.off('data:remove', this._onLocalizationData, this);
		};
		_proto._onParentResize = function _onParentResize(width, height) {
			if (this._noResize) return;
			if (this._font) this._updateText();
		};
		_proto._onScreenChange = function _onScreenChange(screen) {
			if (screen) {
				this._updateMaterial(screen.screen.screenSpace);
			} else {
				this._updateMaterial(false);
			}
		};
		_proto._onScreenSpaceChange = function _onScreenSpaceChange(value) {
			this._updateMaterial(value);
		};
		_proto._onDrawOrderChange = function _onDrawOrderChange(order) {
			this._drawOrder = order;
			if (this._model) {
				for (var i = 0, len = this._model.meshInstances.length; i < len; i++) {
					this._model.meshInstances[i].drawOrder = order;
				}
			}
		};
		_proto._onPivotChange = function _onPivotChange(pivot) {
			if (this._font) this._updateText();
		};
		_proto._onLocaleSet = function _onLocaleSet(locale) {
			if (!this._i18nKey) return;
			if (this.fontAsset) {
				var asset = this._system.app.assets.get(this.fontAsset);
				if (!asset || !asset.resource || asset.resource !== this._font) {
					this.font = null;
				}
			}
			this._resetLocalizedText();
		};
		_proto._onLocalizationData = function _onLocalizationData(locale, messages) {
			if (this._i18nKey && messages[this._i18nKey]) {
				this._resetLocalizedText();
			}
		};
		_proto._resetLocalizedText = function _resetLocalizedText() {
			this._setText(this._system.app.i18n.getText(this._i18nKey));
		};
		_proto._setText = function _setText(text) {
			if (this.unicodeConverter) {
				var unicodeConverterFunc = this._system.getUnicodeConverter();
				if (unicodeConverterFunc) {
					text = unicodeConverterFunc(text);
				} else {
					console.warn('Element created with unicodeConverter option but no unicodeConverter function registered');
				}
			}
			if (this._text !== text) {
				if (this._font) {
					this._updateText(text);
				}
				this._text = text;
			}
		};
		_proto._updateText = function _updateText(text) {
			var tags;
			if (text === undefined) text = this._text;
			this._symbols = string.getSymbols(text.normalize ? text.normalize('NFC') : text);
			if (this._symbols.length === 0) {
				this._symbols = [' '];
			}
			if (this._enableMarkup) {
				var results = Markup.evaluate(this._symbols);
				this._symbols = results.symbols;
				tags = results.tags || [];
			}
			if (this._rtlReorder) {
				var rtlReorderFunc = this._system.app.systems.element.getRtlReorder();
				if (rtlReorderFunc) {
					var _results = rtlReorderFunc(this._symbols);
					this._rtl = _results.rtl;
					this._symbols = _results.mapping.map(function (v) {
						return this._symbols[v];
					}, this);
					if (tags) {
						tags = _results.mapping.map(function (v) {
							return tags[v];
						});
					}
				} else {
					console.warn('Element created with rtlReorder option but no rtlReorder function registered');
				}
			} else {
				this._rtl = false;
			}
			var getColorThicknessHash = function getColorThicknessHash(color, thickness) {
				return color.toString(true).toLowerCase() + ":" + thickness.toFixed(2);
			};
			var getColorOffsetHash = function getColorOffsetHash(color, offset) {
				return color.toString(true).toLowerCase() + ":" + offset.x.toFixed(2) + ":" + offset.y.toFixed(2);
			};
			if (tags) {
				var paletteMap = {};
				var outlinePaletteMap = {};
				var shadowPaletteMap = {};
				this._colorPalette = [Math.round(this._color.r * 255), Math.round(this._color.g * 255), Math.round(this._color.b * 255)];
				this._outlinePalette = [Math.round(this._outlineColor.r * 255), Math.round(this._outlineColor.g * 255), Math.round(this._outlineColor.b * 255), Math.round(this._outlineColor.a * 255), Math.round(this._outlineThickness * 255)];
				this._shadowPalette = [Math.round(this._shadowColor.r * 255), Math.round(this._shadowColor.g * 255), Math.round(this._shadowColor.b * 255), Math.round(this._shadowColor.a * 255), Math.round(this._shadowOffset.x * 127), Math.round(this._shadowOffset.y * 127)];
				this._symbolColors = [];
				this._symbolOutlineParams = [];
				this._symbolShadowParams = [];
				paletteMap[this._color.toString(false).toLowerCase()] = 0;
				outlinePaletteMap[getColorThicknessHash(this._outlineColor, this._outlineThickness)] = 0;
				shadowPaletteMap[getColorOffsetHash(this._shadowColor, this._shadowOffset)] = 0;
				for (var i = 0, len = this._symbols.length; i < len; ++i) {
					var tag = tags[i];
					var color = 0;
					if (tag && tag.color && tag.color.value) {
						var c = tag.color.value;
						if (c.length === 7 && c[0] === '#') {
							var hex = c.substring(1).toLowerCase();
							if (paletteMap.hasOwnProperty(hex)) {
								color = paletteMap[hex];
							} else {
								if (/^([0-9a-f]{2}){3}$/.test(hex)) {
									color = this._colorPalette.length / 3;
									paletteMap[hex] = color;
									this._colorPalette.push(parseInt(hex.substring(0, 2), 16));
									this._colorPalette.push(parseInt(hex.substring(2, 4), 16));
									this._colorPalette.push(parseInt(hex.substring(4, 6), 16));
								}
							}
						}
					}
					this._symbolColors.push(color);
					var outline = 0;
					if (tag && tag.outline && (tag.outline.attributes.color || tag.outline.attributes.thickness)) {
						var _color = tag.outline.attributes.color ? colorTmp.fromString(tag.outline.attributes.color) : this._outlineColor;
						var thickness = Number(tag.outline.attributes.thickness);
						if (Number.isNaN(_color.r) || Number.isNaN(_color.g) || Number.isNaN(_color.b) || Number.isNaN(_color.a)) {
							_color = this._outlineColor;
						}
						if (Number.isNaN(thickness)) {
							thickness = this._outlineThickness;
						}
						var outlineHash = getColorThicknessHash(_color, thickness);
						if (outlinePaletteMap.hasOwnProperty(outlineHash)) {
							outline = outlinePaletteMap[outlineHash];
						} else {
							outline = this._outlinePalette.length / 5;
							outlinePaletteMap[outlineHash] = outline;
							this._outlinePalette.push(Math.round(_color.r * 255), Math.round(_color.g * 255), Math.round(_color.b * 255), Math.round(_color.a * 255), Math.round(thickness * 255));
						}
					}
					this._symbolOutlineParams.push(outline);
					var shadow = 0;
					if (tag && tag.shadow && (tag.shadow.attributes.color || tag.shadow.attributes.offset || tag.shadow.attributes.offsetX || tag.shadow.attributes.offsetY)) {
						var _color2 = tag.shadow.attributes.color ? colorTmp.fromString(tag.shadow.attributes.color) : this._shadowColor;
						var off = Number(tag.shadow.attributes.offset);
						var offX = Number(tag.shadow.attributes.offsetX);
						var offY = Number(tag.shadow.attributes.offsetY);
						if (Number.isNaN(_color2.r) || Number.isNaN(_color2.g) || Number.isNaN(_color2.b) || Number.isNaN(_color2.a)) {
							_color2 = this._shadowColor;
						}
						var offset = vec2Tmp.set(!Number.isNaN(offX) ? offX : !Number.isNaN(off) ? off : this._shadowOffset.x, !Number.isNaN(offY) ? offY : !Number.isNaN(off) ? off : this._shadowOffset.y);
						var shadowHash = getColorOffsetHash(_color2, offset);
						if (shadowPaletteMap.hasOwnProperty(shadowHash)) {
							shadow = shadowPaletteMap[shadowHash];
						} else {
							shadow = this._shadowPalette.length / 6;
							shadowPaletteMap[shadowHash] = shadow;
							this._shadowPalette.push(Math.round(_color2.r * 255), Math.round(_color2.g * 255), Math.round(_color2.b * 255), Math.round(_color2.a * 255), Math.round(offset.x * 127), Math.round(offset.y * 127));
						}
					}
					this._symbolShadowParams.push(shadow);
				}
			} else {
				this._colorPalette = [];
				this._symbolColors = null;
				this._symbolOutlineParams = null;
				this._symbolShadowParams = null;
			}
			this._updateMaterialEmissive();
			this._updateMaterialOutline();
			this._updateMaterialShadow();
			var charactersPerTexture = this._calculateCharsPerTexture();
			var removedModel = false;
			var element = this._element;
			var screenSpace = element._isScreenSpace();
			var screenCulled = element._isScreenCulled();
			var visibleFn = function visibleFn(camera) {
				return element.isVisibleForCamera(camera);
			};
			for (var _i = 0, _len = this._meshInfo.length; _i < _len; _i++) {
				var l = charactersPerTexture[_i] || 0;
				var meshInfo = this._meshInfo[_i];
				if (meshInfo.count !== l) {
					if (!removedModel) {
						element.removeModelFromLayers(this._model);
						removedModel = true;
					}
					meshInfo.count = l;
					meshInfo.positions.length = meshInfo.normals.length = l * 3 * 4;
					meshInfo.indices.length = l * 3 * 2;
					meshInfo.uvs.length = l * 2 * 4;
					meshInfo.colors.length = l * 4 * 4;
					meshInfo.outlines.length = l * 4 * 3;
					meshInfo.shadows.length = l * 4 * 3;
					if (meshInfo.meshInstance) {
						this._removeMeshInstance(meshInfo.meshInstance);
					}
					if (l === 0) {
						meshInfo.meshInstance = null;
						continue;
					}
					for (var v = 0; v < l; v++) {
						meshInfo.indices[v * 3 * 2 + 0] = v * 4;
						meshInfo.indices[v * 3 * 2 + 1] = v * 4 + 1;
						meshInfo.indices[v * 3 * 2 + 2] = v * 4 + 3;
						meshInfo.indices[v * 3 * 2 + 3] = v * 4 + 2;
						meshInfo.indices[v * 3 * 2 + 4] = v * 4 + 3;
						meshInfo.indices[v * 3 * 2 + 5] = v * 4 + 1;
						meshInfo.normals[v * 4 * 3 + 0] = 0;
						meshInfo.normals[v * 4 * 3 + 1] = 0;
						meshInfo.normals[v * 4 * 3 + 2] = -1;
						meshInfo.normals[v * 4 * 3 + 3] = 0;
						meshInfo.normals[v * 4 * 3 + 4] = 0;
						meshInfo.normals[v * 4 * 3 + 5] = -1;
						meshInfo.normals[v * 4 * 3 + 6] = 0;
						meshInfo.normals[v * 4 * 3 + 7] = 0;
						meshInfo.normals[v * 4 * 3 + 8] = -1;
						meshInfo.normals[v * 4 * 3 + 9] = 0;
						meshInfo.normals[v * 4 * 3 + 10] = 0;
						meshInfo.normals[v * 4 * 3 + 11] = -1;
					}
					var mesh = createTextMesh(this._system.app.graphicsDevice, meshInfo);
					var mi = new MeshInstance(mesh, this._material, this._node);
					mi.name = 'Text Element: ' + this._entity.name;
					mi.castShadow = false;
					mi.receiveShadow = false;
					mi.cull = !screenSpace;
					mi.screenSpace = screenSpace;
					mi.drawOrder = this._drawOrder;
					if (screenCulled) {
						mi.cull = true;
						mi.isVisibleFunc = visibleFn;
					}
					this._setTextureParams(mi, this._font.textures[_i]);
					mi.setParameter('material_emissive', this._colorUniform);
					mi.setParameter('material_opacity', this._color.a);
					mi.setParameter('font_sdfIntensity', this._font.intensity);
					mi.setParameter('font_pxrange', this._getPxRange(this._font));
					mi.setParameter('font_textureWidth', this._font.data.info.maps[_i].width);
					mi.setParameter('outline_color', this._outlineColorUniform);
					mi.setParameter('outline_thickness', this._outlineThicknessScale * this._outlineThickness);
					mi.setParameter('shadow_color', this._shadowColorUniform);
					if (this._symbolShadowParams) {
						this._shadowOffsetUniform[0] = 0;
						this._shadowOffsetUniform[1] = 0;
					} else {
						var ratio = -this._font.data.info.maps[_i].width / this._font.data.info.maps[_i].height;
						this._shadowOffsetUniform[0] = this._shadowOffsetScale * this._shadowOffset.x;
						this._shadowOffsetUniform[1] = ratio * this._shadowOffsetScale * this._shadowOffset.y;
					}
					mi.setParameter('shadow_offset', this._shadowOffsetUniform);
					meshInfo.meshInstance = mi;
					this._model.meshInstances.push(mi);
				}
			}
			if (this._element.maskedBy) {
				this._element._setMaskedBy(this._element.maskedBy);
			}
			if (removedModel && this._element.enabled && this._entity.enabled) {
				this._element.addModelToLayers(this._model);
			}
			this._updateMeshes();
			this._rangeStart = 0;
			this._rangeEnd = this._symbols.length;
			this._updateRenderRange();
		};
		_proto._removeMeshInstance = function _removeMeshInstance(meshInstance) {
			meshInstance.destroy();
			var idx = this._model.meshInstances.indexOf(meshInstance);
			if (idx !== -1) this._model.meshInstances.splice(idx, 1);
		};
		_proto._setMaterial = function _setMaterial(material) {
			this._material = material;
			if (this._model) {
				for (var i = 0, len = this._model.meshInstances.length; i < len; i++) {
					var mi = this._model.meshInstances[i];
					mi.material = material;
				}
			}
		};
		_proto._updateMaterial = function _updateMaterial(screenSpace) {
			var element = this._element;
			var screenCulled = element._isScreenCulled();
			var visibleFn = function visibleFn(camera) {
				return element.isVisibleForCamera(camera);
			};
			var msdf = this._font && this._font.type === FONT_MSDF;
			this._material = this._system.getTextElementMaterial(screenSpace, msdf, this._enableMarkup);
			if (this._model) {
				for (var i = 0, len = this._model.meshInstances.length; i < len; i++) {
					var mi = this._model.meshInstances[i];
					mi.cull = !screenSpace;
					mi.material = this._material;
					mi.screenSpace = screenSpace;
					if (screenCulled) {
						mi.cull = true;
						mi.isVisibleFunc = visibleFn;
					} else {
						mi.isVisibleFunc = null;
					}
				}
			}
		};
		_proto._updateMaterialEmissive = function _updateMaterialEmissive() {
			if (this._symbolColors) {
				this._colorUniform[0] = 1;
				this._colorUniform[1] = 1;
				this._colorUniform[2] = 1;
			} else {
				this._colorUniform[0] = this._color.r;
				this._colorUniform[1] = this._color.g;
				this._colorUniform[2] = this._color.b;
			}
		};
		_proto._updateMaterialOutline = function _updateMaterialOutline() {
			if (this._symbolOutlineParams) {
				this._outlineColorUniform[0] = 0;
				this._outlineColorUniform[1] = 0;
				this._outlineColorUniform[2] = 0;
				this._outlineColorUniform[3] = 1;
			} else {
				this._outlineColorUniform[0] = this._outlineColor.r;
				this._outlineColorUniform[1] = this._outlineColor.g;
				this._outlineColorUniform[2] = this._outlineColor.b;
				this._outlineColorUniform[3] = this._outlineColor.a;
			}
		};
		_proto._updateMaterialShadow = function _updateMaterialShadow() {
			if (this._symbolOutlineParams) {
				this._shadowColorUniform[0] = 0;
				this._shadowColorUniform[1] = 0;
				this._shadowColorUniform[2] = 0;
				this._shadowColorUniform[3] = 0;
			} else {
				this._shadowColorUniform[0] = this._shadowColor.r;
				this._shadowColorUniform[1] = this._shadowColor.g;
				this._shadowColorUniform[2] = this._shadowColor.b;
				this._shadowColorUniform[3] = this._shadowColor.a;
			}
		};
		_proto._isWordBoundary = function _isWordBoundary(char) {
			return WORD_BOUNDARY_CHAR.test(char);
		};
		_proto._isValidNextChar = function _isValidNextChar(nextchar) {
			return nextchar !== null && !NO_LINE_BREAK_CJK_CHAR.test(nextchar);
		};
		_proto._isNextCJKBoundary = function _isNextCJKBoundary(char, nextchar) {
			return CJK_CHAR.test(char) && (WORD_BOUNDARY_CHAR.test(nextchar) || ALPHANUMERIC_CHAR.test(nextchar));
		};
		_proto._isNextCJKWholeWord = function _isNextCJKWholeWord(nextchar) {
			return CJK_CHAR.test(nextchar);
		};
		_proto._updateMeshes = function _updateMeshes() {
			var json = this._font.data;
			var self = this;
			var minFont = Math.min(this._minFontSize, this._maxFontSize);
			var maxFont = this._maxFontSize;
			var autoFit = this._shouldAutoFit();
			if (autoFit) {
				this._fontSize = this._maxFontSize;
			}
			var MAGIC = 32;
			var l = this._symbols.length;
			var _x = 0;
			var _y = 0;
			var _z = 0;
			var _xMinusTrailingWhitespace = 0;
			var lines = 1;
			var wordStartX = 0;
			var wordStartIndex = 0;
			var lineStartIndex = 0;
			var numWordsThisLine = 0;
			var numCharsThisLine = 0;
			var numBreaksThisLine = 0;
			var splitHorizontalAnchors = Math.abs(this._element.anchor.x - this._element.anchor.z) >= 0.0001;
			var maxLineWidth = this._element.calculatedWidth;
			if (this.autoWidth && !splitHorizontalAnchors || !this._wrapLines) {
				maxLineWidth = Number.POSITIVE_INFINITY;
			}
			var fontMinY = 0;
			var fontMaxY = 0;
			var char, data, quad, nextchar;
			function breakLine(symbols, lineBreakIndex, lineBreakX) {
				self._lineWidths.push(Math.abs(lineBreakX));
				var sliceStart = lineStartIndex > lineBreakIndex ? lineBreakIndex + 1 : lineStartIndex;
				var sliceEnd = lineStartIndex > lineBreakIndex ? lineStartIndex + 1 : lineBreakIndex;
				var chars = symbols.slice(sliceStart, sliceEnd);
				if (numBreaksThisLine) {
					var i = chars.length;
					while (i-- && numBreaksThisLine > 0) {
						if (LINE_BREAK_CHAR.test(chars[i])) {
							chars.splice(i, 1);
							numBreaksThisLine--;
						}
					}
				}
				self._lineContents.push(chars.join(''));
				_x = 0;
				_y -= self._scaledLineHeight;
				lines++;
				numWordsThisLine = 0;
				numCharsThisLine = 0;
				numBreaksThisLine = 0;
				wordStartX = 0;
				lineStartIndex = lineBreakIndex;
			}
			var retryUpdateMeshes = true;
			while (retryUpdateMeshes) {
				retryUpdateMeshes = false;
				if (autoFit) {
					this._scaledLineHeight = this._lineHeight * this._fontSize / (this._maxFontSize || 0.0001);
				} else {
					this._scaledLineHeight = this._lineHeight;
				}
				this.width = 0;
				this.height = 0;
				this._lineWidths = [];
				this._lineContents = [];
				_x = 0;
				_y = 0;
				_z = 0;
				_xMinusTrailingWhitespace = 0;
				lines = 1;
				wordStartX = 0;
				wordStartIndex = 0;
				lineStartIndex = 0;
				numWordsThisLine = 0;
				numCharsThisLine = 0;
				numBreaksThisLine = 0;
				var scale = this._fontSize / MAGIC;
				fontMinY = this._fontMinY * scale;
				fontMaxY = this._fontMaxY * scale;
				for (var i = 0; i < this._meshInfo.length; i++) {
					this._meshInfo[i].quad = 0;
					this._meshInfo[i].lines = {};
				}
				var color_r = 255;
				var color_g = 255;
				var color_b = 255;
				var outline_color_rg = 255 + 255 * 256;
				var outline_color_ba = 255 + 255 * 256;
				var outline_thickness = 0;
				var shadow_color_rg = 255 + 255 * 256;
				var shadow_color_ba = 255 + 255 * 256;
				var shadow_offset_xy = 127 + 127 * 256;
				for (var _i2 = 0; _i2 < l; _i2++) {
					char = this._symbols[_i2];
					nextchar = _i2 + 1 >= l ? null : this._symbols[_i2 + 1];
					var isLineBreak = LINE_BREAK_CHAR.test(char);
					if (isLineBreak) {
						numBreaksThisLine++;
						if (!this._wrapLines || this._maxLines < 0 || lines < this._maxLines) {
							breakLine(this._symbols, _i2, _xMinusTrailingWhitespace);
							wordStartIndex = _i2 + 1;
							lineStartIndex = _i2 + 1;
						}
						continue;
					}
					var x = 0;
					var y = 0;
					var advance = 0;
					var quadsize = 1;
					var dataScale = void 0,
						size = void 0;
					data = json.chars[char];
					if (!data) {
						if (CONTROL_CHARS.indexOf(char) !== -1) {
							data = CONTROL_GLYPH_DATA;
						} else {
							if (json.chars[' ']) {
								data = json.chars[' '];
							} else {
								for (var key in json.chars) {
									data = json.chars[key];
									break;
								}
							}
						}
					}
					if (data) {
						var kerning = 0;
						if (numCharsThisLine > 0) {
							var kernTable = this._font.data.kerning;
							if (kernTable) {
								var kernLeft = kernTable[string.getCodePoint(this._symbols[_i2 - 1]) || 0];
								if (kernLeft) {
									kerning = kernLeft[string.getCodePoint(this._symbols[_i2]) || 0] || 0;
								}
							}
						}
						dataScale = data.scale || 1;
						size = (data.width + data.height) / 2;
						quadsize = scale * size / dataScale;
						advance = (data.xadvance + kerning) * scale;
						x = (data.xoffset - kerning) * scale;
						y = data.yoffset * scale;
					} else {
						console.error("Couldn't substitute missing character: '" + char + "'");
					}
					var isWhitespace = WHITESPACE_CHAR.test(char);
					var meshInfoId = data && data.map || 0;
					var ratio = -this._font.data.info.maps[meshInfoId].width / this._font.data.info.maps[meshInfoId].height;
					var meshInfo = this._meshInfo[meshInfoId];
					var candidateLineWidth = _x + this._spacing * advance;
					if (candidateLineWidth > maxLineWidth && numCharsThisLine > 0 && !isWhitespace) {
						if (this._maxLines < 0 || lines < this._maxLines) {
							if (numWordsThisLine === 0) {
								wordStartIndex = _i2;
								breakLine(this._symbols, _i2, _xMinusTrailingWhitespace);
							} else {
								var backtrack = Math.max(_i2 - wordStartIndex, 0);
								if (this._meshInfo.length <= 1) {
									meshInfo.lines[lines - 1] -= backtrack;
									meshInfo.quad -= backtrack;
								} else {
									var backtrackStart = wordStartIndex;
									var backtrackEnd = _i2;
									for (var j = backtrackStart; j < backtrackEnd; j++) {
										var backChar = this._symbols[j];
										var backCharData = json.chars[backChar];
										var backMeshInfo = this._meshInfo[backCharData && backCharData.map || 0];
										backMeshInfo.lines[lines - 1] -= 1;
										backMeshInfo.quad -= 1;
									}
								}
								_i2 -= backtrack + 1;
								breakLine(this._symbols, wordStartIndex, wordStartX);
								continue;
							}
						}
					}
					quad = meshInfo.quad;
					meshInfo.lines[lines - 1] = quad;
					var left = _x - x;
					var right = left + quadsize;
					var bottom = _y - y;
					var top = bottom + quadsize;
					if (this._rtl) {
						var shift = quadsize - x - this._spacing * advance - x;
						left -= shift;
						right -= shift;
					}
					meshInfo.positions[quad * 4 * 3 + 0] = left;
					meshInfo.positions[quad * 4 * 3 + 1] = bottom;
					meshInfo.positions[quad * 4 * 3 + 2] = _z;
					meshInfo.positions[quad * 4 * 3 + 3] = right;
					meshInfo.positions[quad * 4 * 3 + 4] = bottom;
					meshInfo.positions[quad * 4 * 3 + 5] = _z;
					meshInfo.positions[quad * 4 * 3 + 6] = right;
					meshInfo.positions[quad * 4 * 3 + 7] = top;
					meshInfo.positions[quad * 4 * 3 + 8] = _z;
					meshInfo.positions[quad * 4 * 3 + 9] = left;
					meshInfo.positions[quad * 4 * 3 + 10] = top;
					meshInfo.positions[quad * 4 * 3 + 11] = _z;
					this.width = Math.max(this.width, candidateLineWidth);
					var fontSize = void 0;
					if (this._shouldAutoFitWidth() && this.width > this._element.calculatedWidth) {
						fontSize = Math.floor(this._element.fontSize * this._element.calculatedWidth / (this.width || 0.0001));
						fontSize = math.clamp(fontSize, minFont, maxFont);
						if (fontSize !== this._element.fontSize) {
							this._fontSize = fontSize;
							retryUpdateMeshes = true;
							break;
						}
					}
					this.height = Math.max(this.height, fontMaxY - (_y + fontMinY));
					if (this._shouldAutoFitHeight() && this.height > this._element.calculatedHeight) {
						fontSize = math.clamp(this._fontSize - 1, minFont, maxFont);
						if (fontSize !== this._element.fontSize) {
							this._fontSize = fontSize;
							retryUpdateMeshes = true;
							break;
						}
					}
					_x += this._spacing * advance;
					if (!isWhitespace) {
						_xMinusTrailingWhitespace = _x;
					}
					if (this._isWordBoundary(char) || this._isValidNextChar(nextchar) && (this._isNextCJKBoundary(char, nextchar) || this._isNextCJKWholeWord(nextchar))) {
						numWordsThisLine++;
						wordStartX = _xMinusTrailingWhitespace;
						wordStartIndex = _i2 + 1;
					}
					numCharsThisLine++;
					var uv = this._getUv(char);
					meshInfo.uvs[quad * 4 * 2 + 0] = uv[0];
					meshInfo.uvs[quad * 4 * 2 + 1] = 1.0 - uv[1];
					meshInfo.uvs[quad * 4 * 2 + 2] = uv[2];
					meshInfo.uvs[quad * 4 * 2 + 3] = 1.0 - uv[1];
					meshInfo.uvs[quad * 4 * 2 + 4] = uv[2];
					meshInfo.uvs[quad * 4 * 2 + 5] = 1.0 - uv[3];
					meshInfo.uvs[quad * 4 * 2 + 6] = uv[0];
					meshInfo.uvs[quad * 4 * 2 + 7] = 1.0 - uv[3];
					if (this._symbolColors) {
						var colorIdx = this._symbolColors[_i2] * 3;
						color_r = this._colorPalette[colorIdx];
						color_g = this._colorPalette[colorIdx + 1];
						color_b = this._colorPalette[colorIdx + 2];
					}
					meshInfo.colors[quad * 4 * 4 + 0] = color_r;
					meshInfo.colors[quad * 4 * 4 + 1] = color_g;
					meshInfo.colors[quad * 4 * 4 + 2] = color_b;
					meshInfo.colors[quad * 4 * 4 + 3] = 255;
					meshInfo.colors[quad * 4 * 4 + 4] = color_r;
					meshInfo.colors[quad * 4 * 4 + 5] = color_g;
					meshInfo.colors[quad * 4 * 4 + 6] = color_b;
					meshInfo.colors[quad * 4 * 4 + 7] = 255;
					meshInfo.colors[quad * 4 * 4 + 8] = color_r;
					meshInfo.colors[quad * 4 * 4 + 9] = color_g;
					meshInfo.colors[quad * 4 * 4 + 10] = color_b;
					meshInfo.colors[quad * 4 * 4 + 11] = 255;
					meshInfo.colors[quad * 4 * 4 + 12] = color_r;
					meshInfo.colors[quad * 4 * 4 + 13] = color_g;
					meshInfo.colors[quad * 4 * 4 + 14] = color_b;
					meshInfo.colors[quad * 4 * 4 + 15] = 255;
					if (this._symbolOutlineParams) {
						var outlineIdx = this._symbolOutlineParams[_i2] * 5;
						outline_color_rg = this._outlinePalette[outlineIdx] + this._outlinePalette[outlineIdx + 1] * 256;
						outline_color_ba = this._outlinePalette[outlineIdx + 2] + this._outlinePalette[outlineIdx + 3] * 256;
						outline_thickness = this._outlinePalette[outlineIdx + 4];
					}
					meshInfo.outlines[quad * 4 * 3 + 0] = outline_color_rg;
					meshInfo.outlines[quad * 4 * 3 + 1] = outline_color_ba;
					meshInfo.outlines[quad * 4 * 3 + 2] = outline_thickness;
					meshInfo.outlines[quad * 4 * 3 + 3] = outline_color_rg;
					meshInfo.outlines[quad * 4 * 3 + 4] = outline_color_ba;
					meshInfo.outlines[quad * 4 * 3 + 5] = outline_thickness;
					meshInfo.outlines[quad * 4 * 3 + 6] = outline_color_rg;
					meshInfo.outlines[quad * 4 * 3 + 7] = outline_color_ba;
					meshInfo.outlines[quad * 4 * 3 + 8] = outline_thickness;
					meshInfo.outlines[quad * 4 * 3 + 9] = outline_color_rg;
					meshInfo.outlines[quad * 4 * 3 + 10] = outline_color_ba;
					meshInfo.outlines[quad * 4 * 3 + 11] = outline_thickness;
					if (this._symbolShadowParams) {
						var shadowIdx = this._symbolShadowParams[_i2] * 6;
						shadow_color_rg = this._shadowPalette[shadowIdx] + this._shadowPalette[shadowIdx + 1] * 256;
						shadow_color_ba = this._shadowPalette[shadowIdx + 2] + this._shadowPalette[shadowIdx + 3] * 256;
						shadow_offset_xy = this._shadowPalette[shadowIdx + 4] + 127 + Math.round(ratio * this._shadowPalette[shadowIdx + 5] + 127) * 256;
					}
					meshInfo.shadows[quad * 4 * 3 + 0] = shadow_color_rg;
					meshInfo.shadows[quad * 4 * 3 + 1] = shadow_color_ba;
					meshInfo.shadows[quad * 4 * 3 + 2] = shadow_offset_xy;
					meshInfo.shadows[quad * 4 * 3 + 3] = shadow_color_rg;
					meshInfo.shadows[quad * 4 * 3 + 4] = shadow_color_ba;
					meshInfo.shadows[quad * 4 * 3 + 5] = shadow_offset_xy;
					meshInfo.shadows[quad * 4 * 3 + 6] = shadow_color_rg;
					meshInfo.shadows[quad * 4 * 3 + 7] = shadow_color_ba;
					meshInfo.shadows[quad * 4 * 3 + 8] = shadow_offset_xy;
					meshInfo.shadows[quad * 4 * 3 + 9] = shadow_color_rg;
					meshInfo.shadows[quad * 4 * 3 + 10] = shadow_color_ba;
					meshInfo.shadows[quad * 4 * 3 + 11] = shadow_offset_xy;
					meshInfo.quad++;
				}
				if (retryUpdateMeshes) {
					continue;
				}
				if (lineStartIndex < l) {
					breakLine(this._symbols, l, _x);
				}
			}
			this._noResize = true;
			this.autoWidth = this._autoWidth;
			this.autoHeight = this._autoHeight;
			this._noResize = false;
			var hp = this._element.pivot.x;
			var vp = this._element.pivot.y;
			var ha = this._alignment.x;
			var va = this._alignment.y;
			for (var _i3 = 0; _i3 < this._meshInfo.length; _i3++) {
				if (this._meshInfo[_i3].count === 0) continue;
				var prevQuad = 0;
				for (var line in this._meshInfo[_i3].lines) {
					var index = this._meshInfo[_i3].lines[line];
					var lw = this._lineWidths[parseInt(line, 10)];
					var hoffset = -hp * this._element.calculatedWidth + ha * (this._element.calculatedWidth - lw) * (this._rtl ? -1 : 1);
					var voffset = (1 - vp) * this._element.calculatedHeight - fontMaxY - (1 - va) * (this._element.calculatedHeight - this.height);
					for (var _quad = prevQuad; _quad <= index; _quad++) {
						this._meshInfo[_i3].positions[_quad * 4 * 3] += hoffset;
						this._meshInfo[_i3].positions[_quad * 4 * 3 + 3] += hoffset;
						this._meshInfo[_i3].positions[_quad * 4 * 3 + 6] += hoffset;
						this._meshInfo[_i3].positions[_quad * 4 * 3 + 9] += hoffset;
						this._meshInfo[_i3].positions[_quad * 4 * 3 + 1] += voffset;
						this._meshInfo[_i3].positions[_quad * 4 * 3 + 4] += voffset;
						this._meshInfo[_i3].positions[_quad * 4 * 3 + 7] += voffset;
						this._meshInfo[_i3].positions[_quad * 4 * 3 + 10] += voffset;
					}
					if (this._rtl) {
						for (var _quad2 = prevQuad; _quad2 <= index; _quad2++) {
							var idx = _quad2 * 4 * 3;
							for (var vert = 0; vert < 4; ++vert) {
								this._meshInfo[_i3].positions[idx + vert * 3] = this._element.calculatedWidth - this._meshInfo[_i3].positions[idx + vert * 3] + hoffset * 2;
							}
							var tmp0 = this._meshInfo[_i3].positions[idx + 3];
							var tmp1 = this._meshInfo[_i3].positions[idx + 6];
							this._meshInfo[_i3].positions[idx + 3] = this._meshInfo[_i3].positions[idx + 0];
							this._meshInfo[_i3].positions[idx + 6] = this._meshInfo[_i3].positions[idx + 9];
							this._meshInfo[_i3].positions[idx + 0] = tmp0;
							this._meshInfo[_i3].positions[idx + 9] = tmp1;
						}
					}
					prevQuad = index + 1;
				}
				var numVertices = this._meshInfo[_i3].count * 4;
				var vertMax = this._meshInfo[_i3].quad * 4;
				var it = new VertexIterator(this._meshInfo[_i3].meshInstance.mesh.vertexBuffer);
				for (var v = 0; v < numVertices; v++) {
					if (v >= vertMax) {
						it.element[SEMANTIC_POSITION].set(0, 0, 0);
						it.element[SEMANTIC_TEXCOORD0].set(0, 0);
						it.element[SEMANTIC_COLOR].set(0, 0, 0, 0);
						it.element[SEMANTIC_ATTR8].set(0, 0, 0, 0);
						it.element[SEMANTIC_ATTR9].set(0, 0, 0, 0);
					} else {
						it.element[SEMANTIC_POSITION].set(this._meshInfo[_i3].positions[v * 3 + 0], this._meshInfo[_i3].positions[v * 3 + 1], this._meshInfo[_i3].positions[v * 3 + 2]);
						it.element[SEMANTIC_TEXCOORD0].set(this._meshInfo[_i3].uvs[v * 2 + 0], this._meshInfo[_i3].uvs[v * 2 + 1]);
						it.element[SEMANTIC_COLOR].set(this._meshInfo[_i3].colors[v * 4 + 0], this._meshInfo[_i3].colors[v * 4 + 1], this._meshInfo[_i3].colors[v * 4 + 2], this._meshInfo[_i3].colors[v * 4 + 3]);
						it.element[SEMANTIC_ATTR8].set(this._meshInfo[_i3].outlines[v * 3 + 0], this._meshInfo[_i3].outlines[v * 3 + 1], this._meshInfo[_i3].outlines[v * 3 + 2]);
						it.element[SEMANTIC_ATTR9].set(this._meshInfo[_i3].shadows[v * 3 + 0], this._meshInfo[_i3].shadows[v * 3 + 1], this._meshInfo[_i3].shadows[v * 3 + 2]);
					}
					it.next();
				}
				it.end();
				this._meshInfo[_i3].meshInstance.mesh.aabb.compute(this._meshInfo[_i3].positions);
				this._meshInfo[_i3].meshInstance._aabbVer = -1;
			}
			this._aabbDirty = true;
		};
		_proto._onFontRender = function _onFontRender() {
			this.font = this._font;
		};
		_proto._onFontLoad = function _onFontLoad(asset) {
			if (this.font !== asset.resource) {
				this.font = asset.resource;
			}
		};
		_proto._onFontChange = function _onFontChange(asset, name, _new, _old) {
			if (name === 'data') {
				this._font.data = _new;
				var maps = this._font.data.info.maps.length;
				for (var i = 0; i < maps; i++) {
					if (!this._meshInfo[i]) continue;
					var mi = this._meshInfo[i].meshInstance;
					if (mi) {
						mi.setParameter('font_sdfIntensity', this._font.intensity);
						mi.setParameter('font_pxrange', this._getPxRange(this._font));
						mi.setParameter('font_textureWidth', this._font.data.info.maps[i].width);
					}
				}
			}
		};
		_proto._onFontRemove = function _onFontRemove(asset) {};
		_proto._setTextureParams = function _setTextureParams(mi, texture) {
			if (this._font) {
				if (this._font.type === FONT_MSDF) {
					mi.deleteParameter('texture_emissiveMap');
					mi.deleteParameter('texture_opacityMap');
					mi.setParameter('texture_msdfMap', texture);
				} else if (this._font.type === FONT_BITMAP) {
					mi.deleteParameter('texture_msdfMap');
					mi.setParameter('texture_emissiveMap', texture);
					mi.setParameter('texture_opacityMap', texture);
				}
			}
		};
		_proto._getPxRange = function _getPxRange(font) {
			var keys = Object.keys(this._font.data.chars);
			for (var i = 0; i < keys.length; i++) {
				var char = this._font.data.chars[keys[i]];
				if (char.range) {
					return (char.scale || 1) * char.range;
				}
			}
			return 2;
		};
		_proto._getUv = function _getUv(char) {
			var data = this._font.data;
			if (!data.chars[char]) {
				var space = ' ';
				if (data.chars[space]) {
					return this._getUv(space);
				}
				return [0, 0, 0, 0];
			}
			var map = data.chars[char].map;
			var width = data.info.maps[map].width;
			var height = data.info.maps[map].height;
			var x = data.chars[char].x;
			var y = data.chars[char].y;
			var x1 = x;
			var y1 = y;
			var x2 = x + data.chars[char].width;
			var y2 = y - data.chars[char].height;
			var edge = 1 - data.chars[char].height / height;
			return [x1 / width, edge - y1 / height, x2 / width, edge - y2 / height];
		};
		_proto.onEnable = function onEnable() {
			this._fontAsset.autoLoad = true;
			if (this._model) {
				this._element.addModelToLayers(this._model);
			}
		};
		_proto.onDisable = function onDisable() {
			this._fontAsset.autoLoad = false;
			if (this._model) {
				this._element.removeModelFromLayers(this._model);
			}
		};
		_proto._setStencil = function _setStencil(stencilParams) {
			if (this._model) {
				var instances = this._model.meshInstances;
				for (var i = 0; i < instances.length; i++) {
					instances[i].stencilFront = stencilParams;
					instances[i].stencilBack = stencilParams;
				}
			}
		};
		_proto._shouldAutoFitWidth = function _shouldAutoFitWidth() {
			return this._autoFitWidth && !this._autoWidth;
		};
		_proto._shouldAutoFitHeight = function _shouldAutoFitHeight() {
			return this._autoFitHeight && !this._autoHeight;
		};
		_proto._shouldAutoFit = function _shouldAutoFit() {
			return this._autoFitWidth && !this._autoWidth || this._autoFitHeight && !this._autoHeight;
		};
		_proto._calculateCharsPerTexture = function _calculateCharsPerTexture(symbolIndex) {
			var charactersPerTexture = {};
			if (symbolIndex === undefined) {
				symbolIndex = this._symbols.length;
			}
			for (var i = 0, len = symbolIndex; i < len; i++) {
				var char = this._symbols[i];
				var info = this._font.data.chars[char];
				if (!info) {
					info = this._font.data.chars[' '];
					if (!info) {
						info = this._font.data.chars[Object.keys(this._font.data.chars)[0]];
					}
				}
				var map = info.map;
				if (!charactersPerTexture[map]) {
					charactersPerTexture[map] = 1;
				} else {
					charactersPerTexture[map]++;
				}
			}
			return charactersPerTexture;
		};
		_proto._updateRenderRange = function _updateRenderRange() {
			var startChars = this._rangeStart === 0 ? 0 : this._calculateCharsPerTexture(this._rangeStart);
			var endChars = this._rangeEnd === 0 ? 0 : this._calculateCharsPerTexture(this._rangeEnd);
			for (var i = 0, len = this._meshInfo.length; i < len; i++) {
				var start = startChars[i] || 0;
				var end = endChars[i] || 0;
				var instance = this._meshInfo[i].meshInstance;
				if (instance) {
					var mesh = instance.mesh;
					if (mesh) {
						mesh.primitive[0].base = start * 3 * 2;
						mesh.primitive[0].count = (end - start) * 3 * 2;
					}
				}
			}
		};
		_createClass(TextElement, [{
			key: "text",
			get: function get() {
				return this._text;
			},
			set: function set(value) {
				this._i18nKey = null;
				var str = value != null && value.toString() || '';
				this._setText(str);
			}
		}, {
			key: "key",
			get: function get() {
				return this._i18nKey;
			},
			set: function set(value) {
				var str = value !== null ? value.toString() : null;
				if (this._i18nKey === str) {
					return;
				}
				this._i18nKey = str;
				if (str) {
					this._fontAsset.disableLocalization = false;
					this._resetLocalizedText();
				} else {
					this._fontAsset.disableLocalization = true;
				}
			}
		}, {
			key: "color",
			get: function get() {
				return this._color;
			},
			set: function set(value) {
				var r = value.r;
				var g = value.g;
				var b = value.b;
				if (this._color.r === r && this._color.g === g && this._color.b === b) {
					return;
				}
				this._color.r = r;
				this._color.g = g;
				this._color.b = b;
				if (!this._model) {
					return;
				}
				if (this._symbolColors) {
					if (this._font) {
						this._updateText();
					}
				} else {
					this._colorUniform[0] = this._color.r;
					this._colorUniform[1] = this._color.g;
					this._colorUniform[2] = this._color.b;
					for (var i = 0, len = this._model.meshInstances.length; i < len; i++) {
						var mi = this._model.meshInstances[i];
						mi.setParameter('material_emissive', this._colorUniform);
					}
				}
				if (this._element) {
					this._element.fire('set:color', this._color);
				}
			}
		}, {
			key: "opacity",
			get: function get() {
				return this._color.a;
			},
			set: function set(value) {
				if (this._color.a !== value) {
					this._color.a = value;
					if (this._model) {
						for (var i = 0, len = this._model.meshInstances.length; i < len; i++) {
							var mi = this._model.meshInstances[i];
							mi.setParameter('material_opacity', value);
						}
					}
				}
				if (this._element) {
					this._element.fire('set:opacity', value);
				}
			}
		}, {
			key: "lineHeight",
			get: function get() {
				return this._lineHeight;
			},
			set: function set(value) {
				var _prev = this._lineHeight;
				this._lineHeight = value;
				this._scaledLineHeight = value;
				if (_prev !== value && this._font) {
					this._updateText();
				}
			}
		}, {
			key: "wrapLines",
			get: function get() {
				return this._wrapLines;
			},
			set: function set(value) {
				var _prev = this._wrapLines;
				this._wrapLines = value;
				if (_prev !== value && this._font) {
					this._updateText();
				}
			}
		}, {
			key: "lines",
			get: function get() {
				return this._lineContents;
			}
		}, {
			key: "spacing",
			get: function get() {
				return this._spacing;
			},
			set: function set(value) {
				var _prev = this._spacing;
				this._spacing = value;
				if (_prev !== value && this._font) {
					this._updateText();
				}
			}
		}, {
			key: "fontSize",
			get: function get() {
				return this._fontSize;
			},
			set: function set(value) {
				var _prev = this._fontSize;
				this._fontSize = value;
				this._originalFontSize = value;
				if (_prev !== value && this._font) {
					this._updateText();
				}
			}
		}, {
			key: "fontAsset",
			get: function get() {
				return this._fontAsset.localizedAsset;
			},
			set: function set(value) {
				this._fontAsset.defaultAsset = value;
			}
		}, {
			key: "font",
			get: function get() {
				return this._font;
			},
			set: function set(value) {
				var previousFontType;
				if (this._font) {
					previousFontType = this._font.type;
					if (this._font.off) this._font.off('render', this._onFontRender, this);
				}
				this._font = value;
				this._fontMinY = 0;
				this._fontMaxY = 0;
				if (!value) return;
				var json = this._font.data;
				for (var charId in json.chars) {
					var data = json.chars[charId];
					if (data.bounds) {
						this._fontMinY = Math.min(this._fontMinY, data.bounds[1]);
						this._fontMaxY = Math.max(this._fontMaxY, data.bounds[3]);
					}
				}
				if (this._font.on) this._font.on('render', this._onFontRender, this);
				if (this._fontAsset.localizedAsset) {
					var asset = this._system.app.assets.get(this._fontAsset.localizedAsset);
					if (asset.resource !== this._font) {
						this._fontAsset.defaultAsset = null;
					}
				}
				if (value.type !== previousFontType) {
					var screenSpace = this._element._isScreenSpace();
					this._updateMaterial(screenSpace);
				}
				for (var i = 0, len = this._font.textures.length; i < len; i++) {
					if (!this._meshInfo[i]) {
						this._meshInfo[i] = new MeshInfo();
					} else {
						var mi = this._meshInfo[i].meshInstance;
						if (mi) {
							mi.setParameter('font_sdfIntensity', this._font.intensity);
							mi.setParameter('font_pxrange', this._getPxRange(this._font));
							mi.setParameter('font_textureWidth', this._font.data.info.maps[i].width);
							this._setTextureParams(mi, this._font.textures[i]);
						}
					}
				}
				var removedModel = false;
				for (var _i4 = this._font.textures.length; _i4 < this._meshInfo.length; _i4++) {
					if (this._meshInfo[_i4].meshInstance) {
						if (!removedModel) {
							this._element.removeModelFromLayers(this._model);
							removedModel = true;
						}
						this._removeMeshInstance(this._meshInfo[_i4].meshInstance);
					}
				}
				if (this._meshInfo.length > this._font.textures.length) this._meshInfo.length = this._font.textures.length;
				this._updateText();
			}
		}, {
			key: "alignment",
			get: function get() {
				return this._alignment;
			},
			set: function set(value) {
				if (value instanceof Vec2) {
					this._alignment.set(value.x, value.y);
				} else {
					this._alignment.set(value[0], value[1]);
				}
				if (this._font) this._updateText();
			}
		}, {
			key: "autoWidth",
			get: function get() {
				return this._autoWidth;
			},
			set: function set(value) {
				var old = this._autoWidth;
				this._autoWidth = value;
				if (value && Math.abs(this._element.anchor.x - this._element.anchor.z) < 0.0001) {
					this._element.width = this.width;
				}
				if (old !== value) {
					var newFontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;
					if (newFontSize !== this._fontSize) {
						this._fontSize = newFontSize;
						if (this._font) {
							this._updateText();
						}
					}
				}
			}
		}, {
			key: "autoHeight",
			get: function get() {
				return this._autoHeight;
			},
			set: function set(value) {
				var old = this._autoHeight;
				this._autoHeight = value;
				if (value && Math.abs(this._element.anchor.y - this._element.anchor.w) < 0.0001) {
					this._element.height = this.height;
				}
				if (old !== value) {
					var newFontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;
					if (newFontSize !== this._fontSize) {
						this._fontSize = newFontSize;
						if (this._font) {
							this._updateText();
						}
					}
				}
			}
		}, {
			key: "rtlReorder",
			get: function get() {
				return this._rtlReorder;
			},
			set: function set(value) {
				if (this._rtlReorder !== value) {
					this._rtlReorder = value;
					if (this._font) {
						this._updateText();
					}
				}
			}
		}, {
			key: "unicodeConverter",
			get: function get() {
				return this._unicodeConverter;
			},
			set: function set(value) {
				if (this._unicodeConverter !== value) {
					this._unicodeConverter = value;
					this._setText(this._text);
				}
			}
		}, {
			key: "aabb",
			get: function get() {
				if (this._aabbDirty) {
					var initialized = false;
					for (var i = 0; i < this._meshInfo.length; i++) {
						if (!this._meshInfo[i].meshInstance) continue;
						if (!initialized) {
							this._aabb.copy(this._meshInfo[i].meshInstance.aabb);
							initialized = true;
						} else {
							this._aabb.add(this._meshInfo[i].meshInstance.aabb);
						}
					}
					this._aabbDirty = false;
				}
				return this._aabb;
			}
		}, {
			key: "outlineColor",
			get: function get() {
				return this._outlineColor;
			},
			set: function set(value) {
				var r = value instanceof Color ? value.r : value[0];
				var g = value instanceof Color ? value.g : value[1];
				var b = value instanceof Color ? value.b : value[2];
				var a = value instanceof Color ? value.a : value[3];
				if (this._outlineColor.r === r && this._outlineColor.g === g && this._outlineColor.b === b && this._outlineColor.a === a) {
					return;
				}
				this._outlineColor.r = r;
				this._outlineColor.g = g;
				this._outlineColor.b = b;
				this._outlineColor.a = a;
				if (!this._model) {
					return;
				}
				if (this._symbolOutlineParams) {
					if (this._font) {
						this._updateText();
					}
				} else {
					this._outlineColorUniform[0] = this._outlineColor.r;
					this._outlineColorUniform[1] = this._outlineColor.g;
					this._outlineColorUniform[2] = this._outlineColor.b;
					this._outlineColorUniform[3] = this._outlineColor.a;
					for (var i = 0, len = this._model.meshInstances.length; i < len; i++) {
						var mi = this._model.meshInstances[i];
						mi.setParameter('outline_color', this._outlineColorUniform);
					}
				}
				if (this._element) {
					this._element.fire('set:outline', this._color);
				}
			}
		}, {
			key: "outlineThickness",
			get: function get() {
				return this._outlineThickness;
			},
			set: function set(value) {
				var _prev = this._outlineThickness;
				this._outlineThickness = value;
				if (_prev !== value && this._font) {
					if (!this._model) {
						return;
					}
					if (this._symbolOutlineParams) {
						if (this._font) {
							this._updateText();
						}
					} else {
						for (var i = 0, len = this._model.meshInstances.length; i < len; i++) {
							var mi = this._model.meshInstances[i];
							mi.setParameter('outline_thickness', this._outlineThicknessScale * this._outlineThickness);
						}
					}
				}
			}
		}, {
			key: "shadowColor",
			get: function get() {
				return this._shadowColor;
			},
			set: function set(value) {
				var r = value instanceof Color ? value.r : value[0];
				var g = value instanceof Color ? value.g : value[1];
				var b = value instanceof Color ? value.b : value[2];
				var a = value instanceof Color ? value.a : value[3];
				if (this._shadowColor.r === r && this._shadowColor.g === g && this._shadowColor.b === b && this._shadowColor.a === a) {
					return;
				}
				this._shadowColor.r = r;
				this._shadowColor.g = g;
				this._shadowColor.b = b;
				this._shadowColor.a = a;
				if (!this._model) {
					return;
				}
				if (this._symbolShadowParams) {
					if (this._font) {
						this._updateText();
					}
				} else {
					this._shadowColorUniform[0] = this._shadowColor.r;
					this._shadowColorUniform[1] = this._shadowColor.g;
					this._shadowColorUniform[2] = this._shadowColor.b;
					this._shadowColorUniform[3] = this._shadowColor.a;
					for (var i = 0, len = this._model.meshInstances.length; i < len; i++) {
						var mi = this._model.meshInstances[i];
						mi.setParameter('shadow_color', this._shadowColorUniform);
					}
				}
			}
		}, {
			key: "shadowOffset",
			get: function get() {
				return this._shadowOffset;
			},
			set: function set(value) {
				var x = value instanceof Vec2 ? value.x : value[0],
					y = value instanceof Vec2 ? value.y : value[1];
				if (this._shadowOffset.x === x && this._shadowOffset.y === y) {
					return;
				}
				this._shadowOffset.set(x, y);
				if (this._font && this._model) {
					if (this._symbolShadowParams) {
						this._updateText();
					} else {
						for (var i = 0, len = this._model.meshInstances.length; i < len; i++) {
							var ratio = -this._font.data.info.maps[i].width / this._font.data.info.maps[i].height;
							this._shadowOffsetUniform[0] = this._shadowOffsetScale * this._shadowOffset.x;
							this._shadowOffsetUniform[1] = ratio * this._shadowOffsetScale * this._shadowOffset.y;
							var mi = this._model.meshInstances[i];
							mi.setParameter('shadow_offset', this._shadowOffsetUniform);
						}
					}
				}
			}
		}, {
			key: "minFontSize",
			get: function get() {
				return this._minFontSize;
			},
			set: function set(value) {
				if (this._minFontSize === value) return;
				this._minFontSize = value;
				if (this.font && this._shouldAutoFit()) {
					this._updateText();
				}
			}
		}, {
			key: "maxFontSize",
			get: function get() {
				return this._maxFontSize;
			},
			set: function set(value) {
				if (this._maxFontSize === value) return;
				this._maxFontSize = value;
				if (this.font && this._shouldAutoFit()) {
					this._updateText();
				}
			}
		}, {
			key: "autoFitWidth",
			get: function get() {
				return this._autoFitWidth;
			},
			set: function set(value) {
				if (this._autoFitWidth === value) return;
				this._autoFitWidth = value;
				this._fontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;
				if (this.font) {
					this._updateText();
				}
			}
		}, {
			key: "autoFitHeight",
			get: function get() {
				return this._autoFitHeight;
			},
			set: function set(value) {
				if (this._autoFitHeight === value) return;
				this._autoFitHeight = value;
				this._fontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;
				if (this.font) {
					this._updateText();
				}
			}
		}, {
			key: "maxLines",
			get: function get() {
				return this._maxLines;
			},
			set: function set(value) {
				if (this._maxLines === value) return;
				if (value === null && this._maxLines === -1) return;
				this._maxLines = value === null ? -1 : value;
				if (this.font && this._wrapLines) {
					this._updateText();
				}
			}
		}, {
			key: "enableMarkup",
			get: function get() {
				return this._enableMarkup;
			},
			set: function set(value) {
				value = !!value;
				if (this._enableMarkup === value) return;
				this._enableMarkup = value;
				if (this.font) {
					this._updateText();
				}
				var screenSpace = this._element._isScreenSpace();
				this._updateMaterial(screenSpace);
			}
		}, {
			key: "symbols",
			get: function get() {
				return this._symbols;
			}
		}, {
			key: "symbolColors",
			get: function get() {
				if (this._symbolColors === null) {
					return null;
				}
				return this._symbolColors.map(function (c) {
					return this._colorPalette.slice(c * 3, c * 3 + 3);
				}, this);
			}
		}, {
			key: "symbolOutlineParams",
			get: function get() {
				if (this._symbolOutlineParams === null) {
					return null;
				}
				return this._symbolOutlineParams.map(function (paramId) {
					return this._outlinePalette.slice(paramId * 5, paramId * 5 + 5);
				}, this);
			}
		}, {
			key: "symbolShadowParams",
			get: function get() {
				if (this._symbolShadowParams === null) {
					return null;
				}
				return this._symbolShadowParams.map(function (paramId) {
					return this._shadowPalette.slice(paramId * 6, paramId * 6 + 6);
				}, this);
			}
		}, {
			key: "rtl",
			get: function get() {
				return this._rtl;
			}
		}, {
			key: "rangeStart",
			get: function get() {
				return this._rangeStart;
			},
			set: function set(rangeStart) {
				rangeStart = Math.max(0, Math.min(rangeStart, this._symbols.length));
				if (rangeStart !== this._rangeStart) {
					this._rangeStart = rangeStart;
					this._updateRenderRange();
				}
			}
		}, {
			key: "rangeEnd",
			get: function get() {
				return this._rangeEnd;
			},
			set: function set(rangeEnd) {
				rangeEnd = Math.max(this._rangeStart, Math.min(rangeEnd, this._symbols.length));
				if (rangeEnd !== this._rangeEnd) {
					this._rangeEnd = rangeEnd;
					this._updateRenderRange();
				}
			}
		}]);
		return TextElement;
	}();

	var position = new Vec3();
	var invParentWtm = new Mat4();
	var vecA$2 = new Vec3();
	var vecB$2 = new Vec3();
	var matA = new Mat4();
	var matB = new Mat4();
	var matC = new Mat4();
	var matD = new Mat4();
	var ElementComponent = function (_Component) {
		_inheritsLoose(ElementComponent, _Component);
		function ElementComponent(system, entity) {
			var _this;
			_this = _Component.call(this, system, entity) || this;
			_this._beingInitialized = false;
			_this._anchor = new Vec4();
			_this._localAnchor = new Vec4();
			_this._pivot = new Vec2();
			_this._width = _this._calculatedWidth = 32;
			_this._height = _this._calculatedHeight = 32;
			_this._margin = new Vec4(0, 0, -32, -32);
			_this._modelTransform = new Mat4();
			_this._screenToWorld = new Mat4();
			_this._anchorTransform = new Mat4();
			_this._anchorDirty = true;
			_this._parentWorldTransform = new Mat4();
			_this._screenTransform = new Mat4();
			_this._screenCorners = [new Vec3(), new Vec3(), new Vec3(), new Vec3()];
			_this._canvasCorners = [new Vec2(), new Vec2(), new Vec2(), new Vec2()];
			_this._worldCorners = [new Vec3(), new Vec3(), new Vec3(), new Vec3()];
			_this._cornersDirty = true;
			_this._canvasCornersDirty = true;
			_this._worldCornersDirty = true;
			_this.entity.on('insert', _this._onInsert, _assertThisInitialized(_this));
			_this._patch();
			_this.screen = null;
			_this._type = ELEMENTTYPE_GROUP;
			_this._image = null;
			_this._text = null;
			_this._group = null;
			_this._drawOrder = 0;
			_this._fitMode = FITMODE_STRETCH;
			_this._useInput = false;
			_this._layers = [LAYERID_UI];
			_this._addedModels = [];
			_this._batchGroupId = -1;
			_this._offsetReadAt = 0;
			_this._maskOffset = 0.5;
			_this._maskedBy = null;
			return _this;
		}
		var _proto = ElementComponent.prototype;
		_proto._patch = function _patch() {
			this.entity._sync = this._sync;
			this.entity.setPosition = this._setPosition;
			this.entity.setLocalPosition = this._setLocalPosition;
		};
		_proto._unpatch = function _unpatch() {
			this.entity._sync = Entity.prototype._sync;
			this.entity.setPosition = Entity.prototype.setPosition;
			this.entity.setLocalPosition = Entity.prototype.setLocalPosition;
		};
		_proto._setPosition = function _setPosition(x, y, z) {
			if (!this.element.screen) {
				Entity.prototype.setPosition.call(this, x, y, z);
				return;
			}
			if (x instanceof Vec3) {
				position.copy(x);
			} else {
				position.set(x, y, z);
			}
			this.getWorldTransform();
			invParentWtm.copy(this.element._screenToWorld).invert();
			invParentWtm.transformPoint(position, this.localPosition);
			if (!this._dirtyLocal) this._dirtifyLocal();
		};
		_proto._setLocalPosition = function _setLocalPosition(x, y, z) {
			if (x instanceof Vec3) {
				this.localPosition.copy(x);
			} else {
				this.localPosition.set(x, y, z);
			}
			var element = this.element;
			var p = this.localPosition;
			var pvt = element._pivot;
			element._margin.x = p.x - element._calculatedWidth * pvt.x;
			element._margin.z = element._localAnchor.z - element._localAnchor.x - element._calculatedWidth - element._margin.x;
			element._margin.y = p.y - element._calculatedHeight * pvt.y;
			element._margin.w = element._localAnchor.w - element._localAnchor.y - element._calculatedHeight - element._margin.y;
			if (!this._dirtyLocal) this._dirtifyLocal();
		};
		_proto._sync = function _sync() {
			var element = this.element;
			var screen = element.screen;
			if (screen) {
				if (element._anchorDirty) {
					var resx = 0;
					var resy = 0;
					var px = 0;
					var py = 1;
					if (this._parent && this._parent.element) {
						resx = this._parent.element.calculatedWidth;
						resy = this._parent.element.calculatedHeight;
						px = this._parent.element.pivot.x;
						py = this._parent.element.pivot.y;
					} else {
						var resolution = screen.screen.resolution;
						resx = resolution.x / screen.screen.scale;
						resy = resolution.y / screen.screen.scale;
					}
					element._anchorTransform.setTranslate(resx * (element.anchor.x - px), -(resy * (py - element.anchor.y)), 0);
					element._anchorDirty = false;
					element._calculateLocalAnchors();
				}
				if (element._sizeDirty) {
					element._calculateSize(false, false);
				}
			}
			if (this._dirtyLocal) {
				this.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale);
				var p = this.localPosition;
				var pvt = element._pivot;
				element._margin.x = p.x - element._calculatedWidth * pvt.x;
				element._margin.z = element._localAnchor.z - element._localAnchor.x - element._calculatedWidth - element._margin.x;
				element._margin.y = p.y - element._calculatedHeight * pvt.y;
				element._margin.w = element._localAnchor.w - element._localAnchor.y - element._calculatedHeight - element._margin.y;
				this._dirtyLocal = false;
			}
			if (!screen) {
				if (this._dirtyWorld) {
					element._cornersDirty = true;
					element._canvasCornersDirty = true;
					element._worldCornersDirty = true;
				}
				Entity.prototype._sync.call(this);
				return;
			}
			if (this._dirtyWorld) {
				if (this._parent === null) {
					this.worldTransform.copy(this.localTransform);
				} else {
					if (this._parent.element) {
						element._screenToWorld.mul2(this._parent.element._modelTransform, element._anchorTransform);
					} else {
						element._screenToWorld.copy(element._anchorTransform);
					}
					element._modelTransform.mul2(element._screenToWorld, this.localTransform);
					if (screen) {
						element._screenToWorld.mul2(screen.screen._screenMatrix, element._screenToWorld);
						if (!screen.screen.screenSpace) {
							element._screenToWorld.mul2(screen.worldTransform, element._screenToWorld);
						}
						this.worldTransform.mul2(element._screenToWorld, this.localTransform);
						var parentWorldTransform = element._parentWorldTransform;
						parentWorldTransform.setIdentity();
						var parent = this._parent;
						if (parent && parent.element && parent !== screen) {
							matA.setTRS(Vec3.ZERO, parent.getLocalRotation(), parent.getLocalScale());
							parentWorldTransform.mul2(parent.element._parentWorldTransform, matA);
						}
						var depthOffset = vecA$2;
						depthOffset.set(0, 0, this.localPosition.z);
						var pivotOffset = vecB$2;
						pivotOffset.set(element._absLeft + element._pivot.x * element.calculatedWidth, element._absBottom + element._pivot.y * element.calculatedHeight, 0);
						matA.setTranslate(-pivotOffset.x, -pivotOffset.y, -pivotOffset.z);
						matB.setTRS(depthOffset, this.getLocalRotation(), this.getLocalScale());
						matC.setTranslate(pivotOffset.x, pivotOffset.y, pivotOffset.z);
						element._screenTransform.mul2(element._parentWorldTransform, matC).mul(matB).mul(matA);
						element._cornersDirty = true;
						element._canvasCornersDirty = true;
						element._worldCornersDirty = true;
					} else {
						this.worldTransform.copy(element._modelTransform);
					}
				}
				this._dirtyWorld = false;
			}
		};
		_proto._onInsert = function _onInsert(parent) {
			var result = this._parseUpToScreen();
			this.entity._dirtifyWorld();
			this._updateScreen(result.screen);
			this._dirtifyMask();
		};
		_proto._dirtifyMask = function _dirtifyMask() {
			var current = this.entity;
			while (current) {
				var next = current.parent;
				if ((next === null || next.screen) && current.element) {
					if (!this.system._prerender || !this.system._prerender.length) {
						this.system._prerender = [];
						this.system.app.once('prerender', this._onPrerender, this);
					}
					var i = this.system._prerender.indexOf(this.entity);
					if (i >= 0) {
						this.system._prerender.splice(i, 1);
					}
					var j = this.system._prerender.indexOf(current);
					if (j < 0) {
						this.system._prerender.push(current);
					}
				}
				current = next;
			}
		};
		_proto._onPrerender = function _onPrerender() {
			for (var i = 0; i < this.system._prerender.length; i++) {
				var mask = this.system._prerender[i];
				if (mask.element) {
					var depth = 1;
					mask.element.syncMask(depth);
				}
			}
			this.system._prerender.length = 0;
		};
		_proto._bindScreen = function _bindScreen(screen) {
			screen._bindElement(this);
		};
		_proto._unbindScreen = function _unbindScreen(screen) {
			screen._unbindElement(this);
		};
		_proto._updateScreen = function _updateScreen(screen) {
			if (this.screen && this.screen !== screen) {
				this._unbindScreen(this.screen.screen);
			}
			var previousScreen = this.screen;
			this.screen = screen;
			if (this.screen) {
				this._bindScreen(this.screen.screen);
			}
			this._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY);
			this.fire('set:screen', this.screen, previousScreen);
			this._anchorDirty = true;
			var children = this.entity.children;
			for (var i = 0, l = children.length; i < l; i++) {
				if (children[i].element) children[i].element._updateScreen(screen);
			}
			if (this.screen) this.screen.screen.syncDrawOrder();
		};
		_proto.syncMask = function syncMask(depth) {
			var result = this._parseUpToScreen();
			this._updateMask(result.mask, depth);
		};
		_proto._setMaskedBy = function _setMaskedBy(mask) {
			var renderableElement = this._image || this._text;
			if (mask) {
				var ref = mask.element._image._maskRef;
				renderableElement == null || renderableElement._setStencil(new StencilParameters({
					ref: ref,
					func: FUNC_EQUAL
				}));
				this._maskedBy = mask;
			} else {
				renderableElement == null || renderableElement._setStencil(null);
				this._maskedBy = null;
			}
		};
		_proto._updateMask = function _updateMask(currentMask, depth) {
			if (currentMask) {
				this._setMaskedBy(currentMask);
				if (this.mask) {
					var ref = currentMask.element._image._maskRef;
					var sp = new StencilParameters({
						ref: ref,
						func: FUNC_EQUAL,
						zpass: STENCILOP_INCREMENT
					});
					this._image._setStencil(sp);
					this._image._maskRef = depth;
					depth++;
					currentMask = this.entity;
				}
				var children = this.entity.children;
				for (var i = 0, l = children.length; i < l; i++) {
					var _children$i$element;
					(_children$i$element = children[i].element) == null || _children$i$element._updateMask(currentMask, depth);
				}
				if (this.mask) depth--;
			} else {
				this._setMaskedBy(null);
				if (this.mask) {
					var _sp = new StencilParameters({
						ref: depth,
						func: FUNC_ALWAYS,
						zpass: STENCILOP_REPLACE
					});
					this._image._setStencil(_sp);
					this._image._maskRef = depth;
					depth++;
					currentMask = this.entity;
				}
				var _children = this.entity.children;
				for (var _i = 0, _l = _children.length; _i < _l; _i++) {
					var _children$_i$element;
					(_children$_i$element = _children[_i].element) == null || _children$_i$element._updateMask(currentMask, depth);
				}
				if (this.mask) depth--;
			}
		};
		_proto._parseUpToScreen = function _parseUpToScreen() {
			var result = {
				screen: null,
				mask: null
			};
			var parent = this.entity._parent;
			while (parent && !parent.screen) {
				if (parent.element && parent.element.mask) {
					if (!result.mask) result.mask = parent;
				}
				parent = parent.parent;
			}
			if (parent && parent.screen) result.screen = parent;
			return result;
		};
		_proto._onScreenResize = function _onScreenResize(res) {
			this._anchorDirty = true;
			this._cornersDirty = true;
			this._worldCornersDirty = true;
			this._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY);
			this.fire('screen:set:resolution', res);
		};
		_proto._onScreenSpaceChange = function _onScreenSpaceChange() {
			this.fire('screen:set:screenspace', this.screen.screen.screenSpace);
		};
		_proto._onScreenRemove = function _onScreenRemove() {
			if (this.screen) {
				if (this.screen._destroying) {
					this.screen = null;
				} else {
					this._updateScreen(null);
				}
			}
		};
		_proto._calculateLocalAnchors = function _calculateLocalAnchors() {
			var resx = 1000;
			var resy = 1000;
			var parent = this.entity._parent;
			if (parent && parent.element) {
				resx = parent.element.calculatedWidth;
				resy = parent.element.calculatedHeight;
			} else if (this.screen) {
				var res = this.screen.screen.resolution;
				var scale = this.screen.screen.scale;
				resx = res.x / scale;
				resy = res.y / scale;
			}
			this._localAnchor.set(this._anchor.x * resx, this._anchor.y * resy, this._anchor.z * resx, this._anchor.w * resy);
		};
		_proto.getOffsetPosition = function getOffsetPosition(x, y) {
			var p = this.entity.getLocalPosition().clone();
			p.x += x;
			p.y += y;
			this._screenToWorld.transformPoint(p, p);
			return p;
		};
		_proto.onLayersChanged = function onLayersChanged(oldComp, newComp) {
			this.addModelToLayers(this._image ? this._image._renderable.model : this._text._model);
			oldComp.off('add', this.onLayerAdded, this);
			oldComp.off('remove', this.onLayerRemoved, this);
			newComp.on('add', this.onLayerAdded, this);
			newComp.on('remove', this.onLayerRemoved, this);
		};
		_proto.onLayerAdded = function onLayerAdded(layer) {
			var index = this.layers.indexOf(layer.id);
			if (index < 0) return;
			if (this._image) {
				layer.addMeshInstances(this._image._renderable.model.meshInstances);
			} else if (this._text) {
				layer.addMeshInstances(this._text._model.meshInstances);
			}
		};
		_proto.onLayerRemoved = function onLayerRemoved(layer) {
			var index = this.layers.indexOf(layer.id);
			if (index < 0) return;
			if (this._image) {
				layer.removeMeshInstances(this._image._renderable.model.meshInstances);
			} else if (this._text) {
				layer.removeMeshInstances(this._text._model.meshInstances);
			}
		};
		_proto.onEnable = function onEnable() {
			if (this._image) this._image.onEnable();
			if (this._text) this._text.onEnable();
			if (this._group) this._group.onEnable();
			if (this.useInput && this.system.app.elementInput) {
				this.system.app.elementInput.addElement(this);
			}
			this.system.app.scene.on('set:layers', this.onLayersChanged, this);
			if (this.system.app.scene.layers) {
				this.system.app.scene.layers.on('add', this.onLayerAdded, this);
				this.system.app.scene.layers.on('remove', this.onLayerRemoved, this);
			}
			if (this._batchGroupId >= 0) {
				var _this$system$app$batc;
				(_this$system$app$batc = this.system.app.batcher) == null || _this$system$app$batc.insert(BatchGroup.ELEMENT, this.batchGroupId, this.entity);
			}
			this.fire('enableelement');
		};
		_proto.onDisable = function onDisable() {
			this.system.app.scene.off('set:layers', this.onLayersChanged, this);
			if (this.system.app.scene.layers) {
				this.system.app.scene.layers.off('add', this.onLayerAdded, this);
				this.system.app.scene.layers.off('remove', this.onLayerRemoved, this);
			}
			if (this._image) this._image.onDisable();
			if (this._text) this._text.onDisable();
			if (this._group) this._group.onDisable();
			if (this.system.app.elementInput && this.useInput) {
				this.system.app.elementInput.removeElement(this);
			}
			if (this._batchGroupId >= 0) {
				var _this$system$app$batc2;
				(_this$system$app$batc2 = this.system.app.batcher) == null || _this$system$app$batc2.remove(BatchGroup.ELEMENT, this.batchGroupId, this.entity);
			}
			this.fire('disableelement');
		};
		_proto.onRemove = function onRemove() {
			this.entity.off('insert', this._onInsert, this);
			this._unpatch();
			if (this._image) this._image.destroy();
			if (this._text) this._text.destroy();
			if (this.system.app.elementInput && this.useInput) {
				this.system.app.elementInput.removeElement(this);
			}
			if (this.screen && this.screen.screen) {
				this._unbindScreen(this.screen.screen);
				this.screen.screen.syncDrawOrder();
			}
			this.off();
		};
		_proto._calculateSize = function _calculateSize(propagateCalculatedWidth, propagateCalculatedHeight) {
			if (!this.entity._parent && !this.screen) return;
			this._calculateLocalAnchors();
			var newWidth = this._absRight - this._absLeft;
			var newHeight = this._absTop - this._absBottom;
			if (propagateCalculatedWidth) {
				this._setWidth(newWidth);
			} else {
				this._setCalculatedWidth(newWidth, false);
			}
			if (propagateCalculatedHeight) {
				this._setHeight(newHeight);
			} else {
				this._setCalculatedHeight(newHeight, false);
			}
			var p = this.entity.getLocalPosition();
			p.x = this._margin.x + this._calculatedWidth * this._pivot.x;
			p.y = this._margin.y + this._calculatedHeight * this._pivot.y;
			this.entity.setLocalPosition(p);
			this._sizeDirty = false;
		};
		_proto._setWidth = function _setWidth(w) {
			this._width = w;
			this._setCalculatedWidth(w, false);
			this.fire('set:width', this._width);
		};
		_proto._setHeight = function _setHeight(h) {
			this._height = h;
			this._setCalculatedHeight(h, false);
			this.fire('set:height', this._height);
		};
		_proto._setCalculatedWidth = function _setCalculatedWidth(value, updateMargins) {
			if (Math.abs(value - this._calculatedWidth) <= 1e-4) return;
			this._calculatedWidth = value;
			this.entity._dirtifyLocal();
			if (updateMargins) {
				var p = this.entity.getLocalPosition();
				var pvt = this._pivot;
				this._margin.x = p.x - this._calculatedWidth * pvt.x;
				this._margin.z = this._localAnchor.z - this._localAnchor.x - this._calculatedWidth - this._margin.x;
			}
			this._flagChildrenAsDirty();
			this.fire('set:calculatedWidth', this._calculatedWidth);
			this.fire('resize', this._calculatedWidth, this._calculatedHeight);
		};
		_proto._setCalculatedHeight = function _setCalculatedHeight(value, updateMargins) {
			if (Math.abs(value - this._calculatedHeight) <= 1e-4) return;
			this._calculatedHeight = value;
			this.entity._dirtifyLocal();
			if (updateMargins) {
				var p = this.entity.getLocalPosition();
				var pvt = this._pivot;
				this._margin.y = p.y - this._calculatedHeight * pvt.y;
				this._margin.w = this._localAnchor.w - this._localAnchor.y - this._calculatedHeight - this._margin.y;
			}
			this._flagChildrenAsDirty();
			this.fire('set:calculatedHeight', this._calculatedHeight);
			this.fire('resize', this._calculatedWidth, this._calculatedHeight);
		};
		_proto._flagChildrenAsDirty = function _flagChildrenAsDirty() {
			var c = this.entity._children;
			for (var i = 0, l = c.length; i < l; i++) {
				if (c[i].element) {
					c[i].element._anchorDirty = true;
					c[i].element._sizeDirty = true;
				}
			}
		};
		_proto.addModelToLayers = function addModelToLayers(model) {
			this._addedModels.push(model);
			for (var i = 0; i < this.layers.length; i++) {
				var layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
				if (!layer) continue;
				layer.addMeshInstances(model.meshInstances);
			}
		};
		_proto.removeModelFromLayers = function removeModelFromLayers(model) {
			var idx = this._addedModels.indexOf(model);
			if (idx >= 0) {
				this._addedModels.splice(idx, 1);
			}
			for (var i = 0; i < this.layers.length; i++) {
				var layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
				if (!layer) continue;
				layer.removeMeshInstances(model.meshInstances);
			}
		};
		_proto.getMaskOffset = function getMaskOffset() {
			var frame = this.system.app.frame;
			if (this._offsetReadAt !== frame) {
				this._maskOffset = 0.5;
				this._offsetReadAt = frame;
			}
			var mo = this._maskOffset;
			this._maskOffset -= 0.001;
			return mo;
		};
		_proto.isVisibleForCamera = function isVisibleForCamera(camera) {
			var clipL, clipR, clipT, clipB;
			if (this.maskedBy) {
				var corners = this.maskedBy.element.screenCorners;
				clipL = Math.min(Math.min(corners[0].x, corners[1].x), Math.min(corners[2].x, corners[3].x));
				clipR = Math.max(Math.max(corners[0].x, corners[1].x), Math.max(corners[2].x, corners[3].x));
				clipB = Math.min(Math.min(corners[0].y, corners[1].y), Math.min(corners[2].y, corners[3].y));
				clipT = Math.max(Math.max(corners[0].y, corners[1].y), Math.max(corners[2].y, corners[3].y));
			} else {
				var sw = this.system.app.graphicsDevice.width;
				var sh = this.system.app.graphicsDevice.height;
				var cameraWidth = camera._rect.z * sw;
				var cameraHeight = camera._rect.w * sh;
				clipL = camera._rect.x * sw;
				clipR = clipL + cameraWidth;
				clipT = (1 - camera._rect.y) * sh;
				clipB = clipT - cameraHeight;
			}
			var hitCorners = this.screenCorners;
			var left = Math.min(Math.min(hitCorners[0].x, hitCorners[1].x), Math.min(hitCorners[2].x, hitCorners[3].x));
			var right = Math.max(Math.max(hitCorners[0].x, hitCorners[1].x), Math.max(hitCorners[2].x, hitCorners[3].x));
			var bottom = Math.min(Math.min(hitCorners[0].y, hitCorners[1].y), Math.min(hitCorners[2].y, hitCorners[3].y));
			var top = Math.max(Math.max(hitCorners[0].y, hitCorners[1].y), Math.max(hitCorners[2].y, hitCorners[3].y));
			if (right < clipL || left > clipR || bottom > clipT || top < clipB) {
				return false;
			}
			return true;
		};
		_proto._isScreenSpace = function _isScreenSpace() {
			if (this.screen && this.screen.screen) {
				return this.screen.screen.screenSpace;
			}
			return false;
		};
		_proto._isScreenCulled = function _isScreenCulled() {
			if (this.screen && this.screen.screen) {
				return this.screen.screen.cull;
			}
			return false;
		};
		_proto._dirtyBatch = function _dirtyBatch() {
			if (this.batchGroupId !== -1) {
				var _this$system$app$batc3;
				(_this$system$app$batc3 = this.system.app.batcher) == null || _this$system$app$batc3.markGroupDirty(this.batchGroupId);
			}
		};
		_createClass(ElementComponent, [{
			key: "_absLeft",
			get: function get() {
				return this._localAnchor.x + this._margin.x;
			}
		}, {
			key: "_absRight",
			get: function get() {
				return this._localAnchor.z - this._margin.z;
			}
		}, {
			key: "_absTop",
			get: function get() {
				return this._localAnchor.w - this._margin.w;
			}
		}, {
			key: "_absBottom",
			get: function get() {
				return this._localAnchor.y + this._margin.y;
			}
		}, {
			key: "_hasSplitAnchorsX",
			get: function get() {
				return Math.abs(this._anchor.x - this._anchor.z) > 0.001;
			}
		}, {
			key: "_hasSplitAnchorsY",
			get: function get() {
				return Math.abs(this._anchor.y - this._anchor.w) > 0.001;
			}
		}, {
			key: "aabb",
			get: function get() {
				if (this._image) return this._image.aabb;
				if (this._text) return this._text.aabb;
				return null;
			}
		}, {
			key: "anchor",
			get: function get() {
				return this._anchor;
			},
			set: function set(value) {
				if (value instanceof Vec4) {
					this._anchor.copy(value);
				} else {
					var _this$_anchor;
					(_this$_anchor = this._anchor).set.apply(_this$_anchor, value);
				}
				if (!this.entity._parent && !this.screen) {
					this._calculateLocalAnchors();
				} else {
					this._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY);
				}
				this._anchorDirty = true;
				if (!this.entity._dirtyLocal) this.entity._dirtifyLocal();
				this.fire('set:anchor', this._anchor);
			}
		}, {
			key: "batchGroupId",
			get: function get() {
				return this._batchGroupId;
			},
			set: function set(value) {
				if (this._batchGroupId === value) return;
				if (this.entity.enabled && this._batchGroupId >= 0) {
					var _this$system$app$batc4;
					(_this$system$app$batc4 = this.system.app.batcher) == null || _this$system$app$batc4.remove(BatchGroup.ELEMENT, this.batchGroupId, this.entity);
				}
				if (this.entity.enabled && value >= 0) {
					var _this$system$app$batc5;
					(_this$system$app$batc5 = this.system.app.batcher) == null || _this$system$app$batc5.insert(BatchGroup.ELEMENT, value, this.entity);
				}
				if (value < 0 && this._batchGroupId >= 0 && this.enabled && this.entity.enabled) {
					if (this._image && this._image._renderable.model) {
						this.addModelToLayers(this._image._renderable.model);
					} else if (this._text && this._text._model) {
						this.addModelToLayers(this._text._model);
					}
				}
				this._batchGroupId = value;
			}
		}, {
			key: "bottom",
			get: function get() {
				return this._margin.y;
			},
			set: function set(value) {
				this._margin.y = value;
				var p = this.entity.getLocalPosition();
				var wt = this._absTop;
				var wb = this._localAnchor.y + value;
				this._setHeight(wt - wb);
				p.y = value + this._calculatedHeight * this._pivot.y;
				this.entity.setLocalPosition(p);
			}
		}, {
			key: "calculatedWidth",
			get: function get() {
				return this._calculatedWidth;
			},
			set: function set(value) {
				this._setCalculatedWidth(value, true);
			}
		}, {
			key: "calculatedHeight",
			get: function get() {
				return this._calculatedHeight;
			},
			set: function set(value) {
				this._setCalculatedHeight(value, true);
			}
		}, {
			key: "canvasCorners",
			get: function get() {
				if (!this._canvasCornersDirty || !this.screen || !this.screen.screen.screenSpace) return this._canvasCorners;
				var device = this.system.app.graphicsDevice;
				var screenCorners = this.screenCorners;
				var sx = device.canvas.clientWidth / device.width;
				var sy = device.canvas.clientHeight / device.height;
				for (var i = 0; i < 4; i++) {
					this._canvasCorners[i].set(screenCorners[i].x * sx, (device.height - screenCorners[i].y) * sy);
				}
				this._canvasCornersDirty = false;
				return this._canvasCorners;
			}
		}, {
			key: "drawOrder",
			get: function get() {
				return this._drawOrder;
			},
			set: function set(value) {
				var priority = 0;
				if (this.screen) {
					priority = this.screen.screen.priority;
				}
				if (value > 0xFFFFFF) {
					value = 0xFFFFFF;
				}
				this._drawOrder = (priority << 24) + value;
				this.fire('set:draworder', this._drawOrder);
			}
		}, {
			key: "height",
			get: function get() {
				return this._height;
			},
			set: function set(value) {
				this._height = value;
				if (!this._hasSplitAnchorsY) {
					this._setCalculatedHeight(value, true);
				}
				this.fire('set:height', this._height);
			}
		}, {
			key: "layers",
			get: function get() {
				return this._layers;
			},
			set: function set(value) {
				if (this._addedModels.length) {
					for (var i = 0; i < this._layers.length; i++) {
						var layer = this.system.app.scene.layers.getLayerById(this._layers[i]);
						if (layer) {
							for (var j = 0; j < this._addedModels.length; j++) {
								layer.removeMeshInstances(this._addedModels[j].meshInstances);
							}
						}
					}
				}
				this._layers = value;
				if (!this.enabled || !this.entity.enabled || !this._addedModels.length) return;
				for (var _i2 = 0; _i2 < this._layers.length; _i2++) {
					var _layer = this.system.app.scene.layers.getLayerById(this._layers[_i2]);
					if (_layer) {
						for (var _j = 0; _j < this._addedModels.length; _j++) {
							_layer.addMeshInstances(this._addedModels[_j].meshInstances);
						}
					}
				}
			}
		}, {
			key: "left",
			get: function get() {
				return this._margin.x;
			},
			set: function set(value) {
				this._margin.x = value;
				var p = this.entity.getLocalPosition();
				var wr = this._absRight;
				var wl = this._localAnchor.x + value;
				this._setWidth(wr - wl);
				p.x = value + this._calculatedWidth * this._pivot.x;
				this.entity.setLocalPosition(p);
			}
		}, {
			key: "margin",
			get: function get() {
				return this._margin;
			},
			set: function set(value) {
				this._margin.copy(value);
				this._calculateSize(true, true);
				this.fire('set:margin', this._margin);
			}
		}, {
			key: "maskedBy",
			get: function get() {
				return this._maskedBy;
			}
		}, {
			key: "pivot",
			get: function get() {
				return this._pivot;
			},
			set: function set(value) {
				var pivot = this.pivot,
					margin = this.margin;
				var prevX = pivot.x;
				var prevY = pivot.y;
				if (value instanceof Vec2) {
					pivot.copy(value);
				} else {
					pivot.set.apply(pivot, value);
				}
				var mx = margin.x + margin.z;
				var dx = pivot.x - prevX;
				margin.x += mx * dx;
				margin.z -= mx * dx;
				var my = margin.y + margin.w;
				var dy = pivot.y - prevY;
				margin.y += my * dy;
				margin.w -= my * dy;
				this._anchorDirty = true;
				this._cornersDirty = true;
				this._worldCornersDirty = true;
				this._calculateSize(false, false);
				this._flagChildrenAsDirty();
				this.fire('set:pivot', pivot);
			}
		}, {
			key: "right",
			get: function get() {
				return this._margin.z;
			},
			set: function set(value) {
				this._margin.z = value;
				var p = this.entity.getLocalPosition();
				var wl = this._absLeft;
				var wr = this._localAnchor.z - value;
				this._setWidth(wr - wl);
				p.x = this._localAnchor.z - this._localAnchor.x - value - this._calculatedWidth * (1 - this._pivot.x);
				this.entity.setLocalPosition(p);
			}
		}, {
			key: "screenCorners",
			get: function get() {
				if (!this._cornersDirty || !this.screen) return this._screenCorners;
				var parentBottomLeft = this.entity.parent && this.entity.parent.element && this.entity.parent.element.screenCorners[0];
				this._screenCorners[0].set(this._absLeft, this._absBottom, 0);
				this._screenCorners[1].set(this._absRight, this._absBottom, 0);
				this._screenCorners[2].set(this._absRight, this._absTop, 0);
				this._screenCorners[3].set(this._absLeft, this._absTop, 0);
				var screenSpace = this.screen.screen.screenSpace;
				for (var i = 0; i < 4; i++) {
					this._screenTransform.transformPoint(this._screenCorners[i], this._screenCorners[i]);
					if (screenSpace) this._screenCorners[i].mulScalar(this.screen.screen.scale);
					if (parentBottomLeft) {
						this._screenCorners[i].add(parentBottomLeft);
					}
				}
				this._cornersDirty = false;
				this._canvasCornersDirty = true;
				this._worldCornersDirty = true;
				return this._screenCorners;
			}
		}, {
			key: "textWidth",
			get: function get() {
				return this._text ? this._text.width : 0;
			}
		}, {
			key: "textHeight",
			get: function get() {
				return this._text ? this._text.height : 0;
			}
		}, {
			key: "top",
			get: function get() {
				return this._margin.w;
			},
			set: function set(value) {
				this._margin.w = value;
				var p = this.entity.getLocalPosition();
				var wb = this._absBottom;
				var wt = this._localAnchor.w - value;
				this._setHeight(wt - wb);
				p.y = this._localAnchor.w - this._localAnchor.y - value - this._calculatedHeight * (1 - this._pivot.y);
				this.entity.setLocalPosition(p);
			}
		}, {
			key: "type",
			get: function get() {
				return this._type;
			},
			set: function set(value) {
				if (value !== this._type) {
					this._type = value;
					if (this._image) {
						this._image.destroy();
						this._image = null;
					}
					if (this._text) {
						this._text.destroy();
						this._text = null;
					}
					if (value === ELEMENTTYPE_IMAGE) {
						this._image = new ImageElement(this);
					} else if (value === ELEMENTTYPE_TEXT) {
						this._text = new TextElement(this);
					}
				}
			}
		}, {
			key: "useInput",
			get: function get() {
				return this._useInput;
			},
			set: function set(value) {
				if (this._useInput === value) return;
				this._useInput = value;
				if (this.system.app.elementInput) {
					if (value) {
						if (this.enabled && this.entity.enabled) {
							this.system.app.elementInput.addElement(this);
						}
					} else {
						this.system.app.elementInput.removeElement(this);
					}
				} else {
					if (this._useInput === true) ;
				}
				this.fire('set:useInput', value);
			}
		}, {
			key: "fitMode",
			get: function get() {
				return this._fitMode;
			},
			set: function set(value) {
				this._fitMode = value;
				this._calculateSize(true, true);
				if (this._image) {
					this._image.refreshMesh();
				}
			}
		}, {
			key: "width",
			get: function get() {
				return this._width;
			},
			set: function set(value) {
				this._width = value;
				if (!this._hasSplitAnchorsX) {
					this._setCalculatedWidth(value, true);
				}
				this.fire('set:width', this._width);
			}
		}, {
			key: "worldCorners",
			get: function get() {
				if (!this._worldCornersDirty) {
					return this._worldCorners;
				}
				if (this.screen) {
					var screenCorners = this.screenCorners;
					if (!this.screen.screen.screenSpace) {
						matA.copy(this.screen.screen._screenMatrix);
						matA.data[13] = -matA.data[13];
						matA.mul2(this.screen.getWorldTransform(), matA);
						for (var i = 0; i < 4; i++) {
							matA.transformPoint(screenCorners[i], this._worldCorners[i]);
						}
					}
				} else {
					var localPos = this.entity.getLocalPosition();
					matA.setTranslate(-localPos.x, -localPos.y, -localPos.z);
					matB.setTRS(Vec3.ZERO, this.entity.getLocalRotation(), this.entity.getLocalScale());
					matC.setTranslate(localPos.x, localPos.y, localPos.z);
					var entity = this.entity.parent ? this.entity.parent : this.entity;
					matD.copy(entity.getWorldTransform());
					matD.mul(matC).mul(matB).mul(matA);
					vecA$2.set(localPos.x - this.pivot.x * this.calculatedWidth, localPos.y - this.pivot.y * this.calculatedHeight, localPos.z);
					matD.transformPoint(vecA$2, this._worldCorners[0]);
					vecA$2.set(localPos.x + (1 - this.pivot.x) * this.calculatedWidth, localPos.y - this.pivot.y * this.calculatedHeight, localPos.z);
					matD.transformPoint(vecA$2, this._worldCorners[1]);
					vecA$2.set(localPos.x + (1 - this.pivot.x) * this.calculatedWidth, localPos.y + (1 - this.pivot.y) * this.calculatedHeight, localPos.z);
					matD.transformPoint(vecA$2, this._worldCorners[2]);
					vecA$2.set(localPos.x - this.pivot.x * this.calculatedWidth, localPos.y + (1 - this.pivot.y) * this.calculatedHeight, localPos.z);
					matD.transformPoint(vecA$2, this._worldCorners[3]);
				}
				this._worldCornersDirty = false;
				return this._worldCorners;
			}
		}]);
		return ElementComponent;
	}(Component);
	function _define(name) {
		Object.defineProperty(ElementComponent.prototype, name, {
			get: function get() {
				if (this._text) {
					return this._text[name];
				} else if (this._image) {
					return this._image[name];
				}
				return null;
			},
			set: function set(value) {
				if (this._text) {
					if (this._text[name] !== value) {
						this._dirtyBatch();
					}
					this._text[name] = value;
				} else if (this._image) {
					if (this._image[name] !== value) {
						this._dirtyBatch();
					}
					this._image[name] = value;
				}
			}
		});
	}
	_define('fontSize');
	_define('minFontSize');
	_define('maxFontSize');
	_define('maxLines');
	_define('autoFitWidth');
	_define('autoFitHeight');
	_define('color');
	_define('font');
	_define('fontAsset');
	_define('spacing');
	_define('lineHeight');
	_define('wrapLines');
	_define('lines');
	_define('alignment');
	_define('autoWidth');
	_define('autoHeight');
	_define('rtlReorder');
	_define('unicodeConverter');
	_define('text');
	_define('key');
	_define('texture');
	_define('textureAsset');
	_define('material');
	_define('materialAsset');
	_define('sprite');
	_define('spriteAsset');
	_define('spriteFrame');
	_define('pixelsPerUnit');
	_define('opacity');
	_define('rect');
	_define('mask');
	_define('outlineColor');
	_define('outlineThickness');
	_define('shadowColor');
	_define('shadowOffset');
	_define('enableMarkup');
	_define('rangeStart');
	_define('rangeEnd');

	var ElementComponentData = function ElementComponentData() {
		this.enabled = true;
	};

	var _schema$f = ['enabled'];
	var ElementComponentSystem = function (_ComponentSystem) {
		_inheritsLoose(ElementComponentSystem, _ComponentSystem);
		function ElementComponentSystem(app) {
			var _this;
			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'element';
			_this.ComponentType = ElementComponent;
			_this.DataType = ElementComponentData;
			_this.schema = _schema$f;
			_this._unicodeConverter = null;
			_this._rtlReorder = null;
			_this._defaultTexture = new Texture(app.graphicsDevice, {
				width: 1,
				height: 1,
				format: PIXELFORMAT_RGBA8,
				name: 'element-system'
			});
			var pixels = _this._defaultTexture.lock();
			var pixelData = new Uint8Array(4);
			pixelData[0] = 255.0;
			pixelData[1] = 255.0;
			pixelData[2] = 255.0;
			pixelData[3] = 255.0;
			pixels.set(pixelData);
			_this._defaultTexture.unlock();
			_this.defaultImageMaterial = null;
			_this.defaultImage9SlicedMaterial = null;
			_this.defaultImage9TiledMaterial = null;
			_this.defaultImageMaskMaterial = null;
			_this.defaultImage9SlicedMaskMaterial = null;
			_this.defaultImage9TiledMaskMaterial = null;
			_this.defaultScreenSpaceImageMaterial = null;
			_this.defaultScreenSpaceImage9SlicedMaterial = null;
			_this.defaultScreenSpaceImage9TiledMaterial = null;
			_this.defaultScreenSpaceImageMask9SlicedMaterial = null;
			_this.defaultScreenSpaceImageMask9TiledMaterial = null;
			_this.defaultScreenSpaceImageMaskMaterial = null;
			_this._defaultTextMaterials = {};
			_this.defaultImageMaterials = [];
			_this.on('beforeremove', _this.onRemoveComponent, _assertThisInitialized(_this));
			return _this;
		}
		var _proto = ElementComponentSystem.prototype;
		_proto.destroy = function destroy() {
			_ComponentSystem.prototype.destroy.call(this);
			this._defaultTexture.destroy();
		};
		_proto.initializeComponentData = function initializeComponentData(component, data, properties) {
			component._beingInitialized = true;
			if (data.anchor !== undefined) {
				if (data.anchor instanceof Vec4) {
					component.anchor.copy(data.anchor);
				} else {
					component.anchor.set(data.anchor[0], data.anchor[1], data.anchor[2], data.anchor[3]);
				}
			}
			if (data.pivot !== undefined) {
				if (data.pivot instanceof Vec2) {
					component.pivot.copy(data.pivot);
				} else {
					component.pivot.set(data.pivot[0], data.pivot[1]);
				}
			}
			var splitHorAnchors = Math.abs(component.anchor.x - component.anchor.z) > 0.001;
			var splitVerAnchors = Math.abs(component.anchor.y - component.anchor.w) > 0.001;
			var _marginChange = false;
			var color;
			if (data.margin !== undefined) {
				if (data.margin instanceof Vec4) {
					component.margin.copy(data.margin);
				} else {
					component._margin.set(data.margin[0], data.margin[1], data.margin[2], data.margin[3]);
				}
				_marginChange = true;
			}
			if (data.left !== undefined) {
				component._margin.x = data.left;
				_marginChange = true;
			}
			if (data.bottom !== undefined) {
				component._margin.y = data.bottom;
				_marginChange = true;
			}
			if (data.right !== undefined) {
				component._margin.z = data.right;
				_marginChange = true;
			}
			if (data.top !== undefined) {
				component._margin.w = data.top;
				_marginChange = true;
			}
			if (_marginChange) {
				component.margin = component._margin;
			}
			var shouldForceSetAnchor = false;
			if (data.width !== undefined && !splitHorAnchors) {
				component.width = data.width;
			} else if (splitHorAnchors) {
				shouldForceSetAnchor = true;
			}
			if (data.height !== undefined && !splitVerAnchors) {
				component.height = data.height;
			} else if (splitVerAnchors) {
				shouldForceSetAnchor = true;
			}
			if (shouldForceSetAnchor) {
				component.anchor = component.anchor;
			}
			if (data.enabled !== undefined) {
				component.enabled = data.enabled;
			}
			if (data.useInput !== undefined) {
				component.useInput = data.useInput;
			}
			if (data.fitMode !== undefined) {
				component.fitMode = data.fitMode;
			}
			component.batchGroupId = data.batchGroupId === undefined || data.batchGroupId === null ? -1 : data.batchGroupId;
			if (data.layers && Array.isArray(data.layers)) {
				component.layers = data.layers.slice(0);
			}
			if (data.type !== undefined) {
				component.type = data.type;
			}
			if (component.type === ELEMENTTYPE_IMAGE) {
				if (data.rect !== undefined) {
					component.rect = data.rect;
				}
				if (data.color !== undefined) {
					color = data.color;
					if (!(color instanceof Color)) {
						color = new Color(data.color[0], data.color[1], data.color[2]);
					}
					component.color = color;
				}
				if (data.opacity !== undefined) component.opacity = data.opacity;
				if (data.textureAsset !== undefined) component.textureAsset = data.textureAsset;
				if (data.texture) component.texture = data.texture;
				if (data.spriteAsset !== undefined) component.spriteAsset = data.spriteAsset;
				if (data.sprite) component.sprite = data.sprite;
				if (data.spriteFrame !== undefined) component.spriteFrame = data.spriteFrame;
				if (data.pixelsPerUnit !== undefined && data.pixelsPerUnit !== null) component.pixelsPerUnit = data.pixelsPerUnit;
				if (data.materialAsset !== undefined) component.materialAsset = data.materialAsset;
				if (data.material) component.material = data.material;
				if (data.mask !== undefined) {
					component.mask = data.mask;
				}
			} else if (component.type === ELEMENTTYPE_TEXT) {
				if (data.autoWidth !== undefined) component.autoWidth = data.autoWidth;
				if (data.autoHeight !== undefined) component.autoHeight = data.autoHeight;
				if (data.rtlReorder !== undefined) component.rtlReorder = data.rtlReorder;
				if (data.unicodeConverter !== undefined) component.unicodeConverter = data.unicodeConverter;
				if (data.text !== null && data.text !== undefined) {
					component.text = data.text;
				} else if (data.key !== null && data.key !== undefined) {
					component.key = data.key;
				}
				if (data.color !== undefined) {
					color = data.color;
					if (!(color instanceof Color)) {
						color = new Color(color[0], color[1], color[2]);
					}
					component.color = color;
				}
				if (data.opacity !== undefined) {
					component.opacity = data.opacity;
				}
				if (data.spacing !== undefined) component.spacing = data.spacing;
				if (data.fontSize !== undefined) {
					component.fontSize = data.fontSize;
					if (!data.lineHeight) component.lineHeight = data.fontSize;
				}
				if (data.lineHeight !== undefined) component.lineHeight = data.lineHeight;
				if (data.maxLines !== undefined) component.maxLines = data.maxLines;
				if (data.wrapLines !== undefined) component.wrapLines = data.wrapLines;
				if (data.minFontSize !== undefined) component.minFontSize = data.minFontSize;
				if (data.maxFontSize !== undefined) component.maxFontSize = data.maxFontSize;
				if (data.autoFitWidth) component.autoFitWidth = data.autoFitWidth;
				if (data.autoFitHeight) component.autoFitHeight = data.autoFitHeight;
				if (data.fontAsset !== undefined) component.fontAsset = data.fontAsset;
				if (data.font !== undefined) component.font = data.font;
				if (data.alignment !== undefined) component.alignment = data.alignment;
				if (data.outlineColor !== undefined) component.outlineColor = data.outlineColor;
				if (data.outlineThickness !== undefined) component.outlineThickness = data.outlineThickness;
				if (data.shadowColor !== undefined) component.shadowColor = data.shadowColor;
				if (data.shadowOffset !== undefined) component.shadowOffset = data.shadowOffset;
				if (data.enableMarkup !== undefined) component.enableMarkup = data.enableMarkup;
			}
			var result = component._parseUpToScreen();
			if (result.screen) {
				component._updateScreen(result.screen);
			}
			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
			component._beingInitialized = false;
			if (component.type === ELEMENTTYPE_IMAGE && component._image._meshDirty) {
				component._image._updateMesh(component._image.mesh);
			}
		};
		_proto.onRemoveComponent = function onRemoveComponent(entity, component) {
			component.onRemove();
		};
		_proto.cloneComponent = function cloneComponent(entity, clone) {
			var source = entity.element;
			var data = {
				enabled: source.enabled,
				width: source.width,
				height: source.height,
				anchor: source.anchor.clone(),
				pivot: source.pivot.clone(),
				margin: source.margin.clone(),
				alignment: source.alignment && source.alignment.clone() || source.alignment,
				autoWidth: source.autoWidth,
				autoHeight: source.autoHeight,
				type: source.type,
				rect: source.rect && source.rect.clone() || source.rect,
				rtlReorder: source.rtlReorder,
				unicodeConverter: source.unicodeConverter,
				materialAsset: source.materialAsset,
				material: source.material,
				color: source.color && source.color.clone() || source.color,
				opacity: source.opacity,
				textureAsset: source.textureAsset,
				texture: source.texture,
				spriteAsset: source.spriteAsset,
				sprite: source.sprite,
				spriteFrame: source.spriteFrame,
				pixelsPerUnit: source.pixelsPerUnit,
				spacing: source.spacing,
				lineHeight: source.lineHeight,
				wrapLines: source.wrapLines,
				layers: source.layers,
				fontSize: source.fontSize,
				minFontSize: source.minFontSize,
				maxFontSize: source.maxFontSize,
				autoFitWidth: source.autoFitWidth,
				autoFitHeight: source.autoFitHeight,
				maxLines: source.maxLines,
				fontAsset: source.fontAsset,
				font: source.font,
				useInput: source.useInput,
				fitMode: source.fitMode,
				batchGroupId: source.batchGroupId,
				mask: source.mask,
				outlineColor: source.outlineColor && source.outlineColor.clone() || source.outlineColor,
				outlineThickness: source.outlineThickness,
				shadowColor: source.shadowColor && source.shadowColor.clone() || source.shadowColor,
				shadowOffset: source.shadowOffset && source.shadowOffset.clone() || source.shadowOffset,
				enableMarkup: source.enableMarkup
			};
			if (source.key !== undefined && source.key !== null) {
				data.key = source.key;
			} else {
				data.text = source.text;
			}
			return this.addComponent(clone, data);
		};
		_proto.getTextElementMaterial = function getTextElementMaterial(screenSpace, msdf, textAttibutes) {
			var hash = (screenSpace && 1 << 0) | (msdf && 1 << 1) | (textAttibutes && 1 << 2);
			var material = this._defaultTextMaterials[hash];
			if (material) {
				return material;
			}
			var name = "TextMaterial";
			material = new StandardMaterial();
			if (msdf) {
				material.msdfMap = this._defaultTexture;
				material.msdfTextAttribute = textAttibutes;
				material.emissive.set(1, 1, 1);
			} else {
				name = "Bitmap" + name;
				material.emissive.set(0.5, 0.5, 0.5);
				material.emissiveMap = this._defaultTexture;
				material.emissiveTint = true;
				material.opacityMap = this._defaultTexture;
				material.opacityMapChannel = 'a';
			}
			if (screenSpace) {
				name = 'ScreenSpace' + name;
				material.depthTest = false;
			}
			material.name = 'default' + name;
			material.useLighting = false;
			material.useGammaTonemap = false;
			material.useFog = false;
			material.useSkybox = false;
			material.diffuse.set(0, 0, 0);
			material.opacity = 0.5;
			material.blendType = BLEND_PREMULTIPLIED;
			material.depthWrite = false;
			material.emissiveVertexColor = true;
			material.update();
			this._defaultTextMaterials[hash] = material;
			return material;
		};
		_proto._createBaseImageMaterial = function _createBaseImageMaterial() {
			var material = new StandardMaterial();
			material.diffuse.set(0, 0, 0);
			material.emissive.set(0.5, 0.5, 0.5);
			material.emissiveMap = this._defaultTexture;
			material.emissiveTint = true;
			material.opacityMap = this._defaultTexture;
			material.opacityMapChannel = 'a';
			material.opacityTint = true;
			material.opacity = 0;
			material.useLighting = false;
			material.useGammaTonemap = false;
			material.useFog = false;
			material.useSkybox = false;
			material.blendType = BLEND_PREMULTIPLIED;
			material.depthWrite = false;
			return material;
		};
		_proto.getImageElementMaterial = function getImageElementMaterial(screenSpace, mask, nineSliced, nineSliceTiled) {
			if (screenSpace) {
				if (mask) {
					if (nineSliced) {
						if (!this.defaultScreenSpaceImageMask9SlicedMaterial) {
							this.defaultScreenSpaceImageMask9SlicedMaterial = this._createBaseImageMaterial();
							this.defaultScreenSpaceImageMask9SlicedMaterial.name = 'defaultScreenSpaceImageMask9SlicedMaterial';
							this.defaultScreenSpaceImageMask9SlicedMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;
							this.defaultScreenSpaceImageMask9SlicedMaterial.depthTest = false;
							this.defaultScreenSpaceImageMask9SlicedMaterial.alphaTest = 1;
							this.defaultScreenSpaceImageMask9SlicedMaterial.redWrite = false;
							this.defaultScreenSpaceImageMask9SlicedMaterial.greenWrite = false;
							this.defaultScreenSpaceImageMask9SlicedMaterial.blueWrite = false;
							this.defaultScreenSpaceImageMask9SlicedMaterial.alphaWrite = false;
							this.defaultScreenSpaceImageMask9SlicedMaterial.update();
							this.defaultImageMaterials.push(this.defaultScreenSpaceImageMask9SlicedMaterial);
						}
						return this.defaultScreenSpaceImageMask9SlicedMaterial;
					} else if (nineSliceTiled) {
						if (!this.defaultScreenSpaceImageMask9TiledMaterial) {
							this.defaultScreenSpaceImageMask9TiledMaterial = this.defaultScreenSpaceImage9TiledMaterial.clone();
							this.defaultScreenSpaceImageMask9TiledMaterial.name = 'defaultScreenSpaceImageMask9TiledMaterial';
							this.defaultScreenSpaceImageMask9TiledMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;
							this.defaultScreenSpaceImageMask9TiledMaterial.depthTest = false;
							this.defaultScreenSpaceImageMask9TiledMaterial.alphaTest = 1;
							this.defaultScreenSpaceImageMask9TiledMaterial.redWrite = false;
							this.defaultScreenSpaceImageMask9TiledMaterial.greenWrite = false;
							this.defaultScreenSpaceImageMask9TiledMaterial.blueWrite = false;
							this.defaultScreenSpaceImageMask9TiledMaterial.alphaWrite = false;
							this.defaultScreenSpaceImageMask9TiledMaterial.update();
							this.defaultImageMaterials.push(this.defaultScreenSpaceImageMask9TiledMaterial);
						}
						return this.defaultScreenSpaceImageMask9TiledMaterial;
					} else {
						if (!this.defaultScreenSpaceImageMaskMaterial) {
							this.defaultScreenSpaceImageMaskMaterial = this._createBaseImageMaterial();
							this.defaultScreenSpaceImageMaskMaterial.name = 'defaultScreenSpaceImageMaskMaterial';
							this.defaultScreenSpaceImageMaskMaterial.depthTest = false;
							this.defaultScreenSpaceImageMaskMaterial.alphaTest = 1;
							this.defaultScreenSpaceImageMaskMaterial.redWrite = false;
							this.defaultScreenSpaceImageMaskMaterial.greenWrite = false;
							this.defaultScreenSpaceImageMaskMaterial.blueWrite = false;
							this.defaultScreenSpaceImageMaskMaterial.alphaWrite = false;
							this.defaultScreenSpaceImageMaskMaterial.update();
							this.defaultImageMaterials.push(this.defaultScreenSpaceImageMaskMaterial);
						}
						return this.defaultScreenSpaceImageMaskMaterial;
					}
				} else {
					if (nineSliced) {
						if (!this.defaultScreenSpaceImage9SlicedMaterial) {
							this.defaultScreenSpaceImage9SlicedMaterial = this._createBaseImageMaterial();
							this.defaultScreenSpaceImage9SlicedMaterial.name = 'defaultScreenSpaceImage9SlicedMaterial';
							this.defaultScreenSpaceImage9SlicedMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;
							this.defaultScreenSpaceImage9SlicedMaterial.depthTest = false;
							this.defaultScreenSpaceImage9SlicedMaterial.update();
							this.defaultImageMaterials.push(this.defaultScreenSpaceImage9SlicedMaterial);
						}
						return this.defaultScreenSpaceImage9SlicedMaterial;
					} else if (nineSliceTiled) {
						if (!this.defaultScreenSpaceImage9TiledMaterial) {
							this.defaultScreenSpaceImage9TiledMaterial = this._createBaseImageMaterial();
							this.defaultScreenSpaceImage9TiledMaterial.name = 'defaultScreenSpaceImage9TiledMaterial';
							this.defaultScreenSpaceImage9TiledMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;
							this.defaultScreenSpaceImage9TiledMaterial.depthTest = false;
							this.defaultScreenSpaceImage9TiledMaterial.update();
							this.defaultImageMaterials.push(this.defaultScreenSpaceImage9TiledMaterial);
						}
						return this.defaultScreenSpaceImage9TiledMaterial;
					} else {
						if (!this.defaultScreenSpaceImageMaterial) {
							this.defaultScreenSpaceImageMaterial = this._createBaseImageMaterial();
							this.defaultScreenSpaceImageMaterial.name = 'defaultScreenSpaceImageMaterial';
							this.defaultScreenSpaceImageMaterial.depthTest = false;
							this.defaultScreenSpaceImageMaterial.update();
							this.defaultImageMaterials.push(this.defaultScreenSpaceImageMaterial);
						}
						return this.defaultScreenSpaceImageMaterial;
					}
				}
			} else {
				if (mask) {
					if (nineSliced) {
						if (!this.defaultImage9SlicedMaskMaterial) {
							this.defaultImage9SlicedMaskMaterial = this._createBaseImageMaterial();
							this.defaultImage9SlicedMaskMaterial.name = 'defaultImage9SlicedMaskMaterial';
							this.defaultImage9SlicedMaskMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;
							this.defaultImage9SlicedMaskMaterial.alphaTest = 1;
							this.defaultImage9SlicedMaskMaterial.redWrite = false;
							this.defaultImage9SlicedMaskMaterial.greenWrite = false;
							this.defaultImage9SlicedMaskMaterial.blueWrite = false;
							this.defaultImage9SlicedMaskMaterial.alphaWrite = false;
							this.defaultImage9SlicedMaskMaterial.update();
							this.defaultImageMaterials.push(this.defaultImage9SlicedMaskMaterial);
						}
						return this.defaultImage9SlicedMaskMaterial;
					} else if (nineSliceTiled) {
						if (!this.defaultImage9TiledMaskMaterial) {
							this.defaultImage9TiledMaskMaterial = this._createBaseImageMaterial();
							this.defaultImage9TiledMaskMaterial.name = 'defaultImage9TiledMaskMaterial';
							this.defaultImage9TiledMaskMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;
							this.defaultImage9TiledMaskMaterial.alphaTest = 1;
							this.defaultImage9TiledMaskMaterial.redWrite = false;
							this.defaultImage9TiledMaskMaterial.greenWrite = false;
							this.defaultImage9TiledMaskMaterial.blueWrite = false;
							this.defaultImage9TiledMaskMaterial.alphaWrite = false;
							this.defaultImage9TiledMaskMaterial.update();
							this.defaultImageMaterials.push(this.defaultImage9TiledMaskMaterial);
						}
						return this.defaultImage9TiledMaskMaterial;
					} else {
						if (!this.defaultImageMaskMaterial) {
							this.defaultImageMaskMaterial = this._createBaseImageMaterial();
							this.defaultImageMaskMaterial.name = 'defaultImageMaskMaterial';
							this.defaultImageMaskMaterial.alphaTest = 1;
							this.defaultImageMaskMaterial.redWrite = false;
							this.defaultImageMaskMaterial.greenWrite = false;
							this.defaultImageMaskMaterial.blueWrite = false;
							this.defaultImageMaskMaterial.alphaWrite = false;
							this.defaultImageMaskMaterial.update();
							this.defaultImageMaterials.push(this.defaultImageMaskMaterial);
						}
						return this.defaultImageMaskMaterial;
					}
				} else {
					if (nineSliced) {
						if (!this.defaultImage9SlicedMaterial) {
							this.defaultImage9SlicedMaterial = this._createBaseImageMaterial();
							this.defaultImage9SlicedMaterial.name = 'defaultImage9SlicedMaterial';
							this.defaultImage9SlicedMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;
							this.defaultImage9SlicedMaterial.update();
							this.defaultImageMaterials.push(this.defaultImage9SlicedMaterial);
						}
						return this.defaultImage9SlicedMaterial;
					} else if (nineSliceTiled) {
						if (!this.defaultImage9TiledMaterial) {
							this.defaultImage9TiledMaterial = this._createBaseImageMaterial();
							this.defaultImage9TiledMaterial.name = 'defaultImage9TiledMaterial';
							this.defaultImage9TiledMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;
							this.defaultImage9TiledMaterial.update();
							this.defaultImageMaterials.push(this.defaultImage9TiledMaterial);
						}
						return this.defaultImage9TiledMaterial;
					} else {
						if (!this.defaultImageMaterial) {
							this.defaultImageMaterial = this._createBaseImageMaterial();
							this.defaultImageMaterial.name = 'defaultImageMaterial';
							this.defaultImageMaterial.update();
							this.defaultImageMaterials.push(this.defaultImageMaterial);
						}
						return this.defaultImageMaterial;
					}
				}
			}
		};
		_proto.registerUnicodeConverter = function registerUnicodeConverter(func) {
			this._unicodeConverter = func;
		};
		_proto.registerRtlReorder = function registerRtlReorder(func) {
			this._rtlReorder = func;
		};
		_proto.getUnicodeConverter = function getUnicodeConverter() {
			return this._unicodeConverter;
		};
		_proto.getRtlReorder = function getRtlReorder() {
			return this._rtlReorder;
		};
		return ElementComponentSystem;
	}(ComponentSystem);
	Component._buildAccessors(ElementComponent.prototype, _schema$f);

	var MOTION_FREE = 'free';
	var MOTION_LIMITED = 'limited';
	var MOTION_LOCKED = 'locked';

	var properties = ['angularDampingX', 'angularDampingY', 'angularDampingZ', 'angularEquilibriumX', 'angularEquilibriumY', 'angularEquilibriumZ', 'angularLimitsX', 'angularLimitsY', 'angularLimitsZ', 'angularMotionX', 'angularMotionY', 'angularMotionZ', 'angularSpringX', 'angularSpringY', 'angularSpringZ', 'angularStiffnessX', 'angularStiffnessY', 'angularStiffnessZ', 'breakForce', 'enableCollision', 'enabled', 'entityA', 'entityB', 'linearDampingX', 'linearDampingY', 'linearDampingZ', 'linearEquilibriumX', 'linearEquilibriumY', 'linearEquilibriumZ', 'linearLimitsX', 'linearLimitsY', 'linearLimitsZ', 'linearMotionX', 'linearMotionY', 'linearMotionZ', 'linearSpringX', 'linearSpringY', 'linearSpringZ', 'linearStiffnessX', 'linearStiffnessY', 'linearStiffnessZ'];
	var JointComponent = function (_Component) {
		_inheritsLoose(JointComponent, _Component);
		function JointComponent(system, entity) {
			var _this;
			_this = _Component.call(this, system, entity) || this;
			_this._constraint = null;
			_this._entityA = null;
			_this._entityB = null;
			_this._breakForce = 3.4e+38;
			_this._enableCollision = true;
			_this._linearMotionX = MOTION_LOCKED;
			_this._linearLimitsX = new Vec2(0, 0);
			_this._linearSpringX = false;
			_this._linearStiffnessX = 0;
			_this._linearDampingX = 1;
			_this._linearEquilibriumX = 0;
			_this._linearMotionY = MOTION_LOCKED;
			_this._linearLimitsY = new Vec2(0, 0);
			_this._linearSpringY = false;
			_this._linearStiffnessY = 0;
			_this._linearDampingY = 1;
			_this._linearEquilibriumY = 0;
			_this._linearMotionZ = MOTION_LOCKED;
			_this._linearLimitsZ = new Vec2(0, 0);
			_this._linearSpringZ = false;
			_this._linearStiffnessZ = 0;
			_this._linearDampingZ = 1;
			_this._linearEquilibriumZ = 0;
			_this._angularMotionX = MOTION_LOCKED;
			_this._angularLimitsX = new Vec2(0, 0);
			_this._angularSpringX = false;
			_this._angularStiffnessX = 0;
			_this._angularDampingX = 1;
			_this._angularEquilibriumX = 0;
			_this._angularMotionY = MOTION_LOCKED;
			_this._angularLimitsY = new Vec2(0, 0);
			_this._angularSpringY = false;
			_this._angularStiffnessY = 0;
			_this._angularDampingY = 1;
			_this._angularEquilibriumY = 0;
			_this._angularMotionZ = MOTION_LOCKED;
			_this._angularLimitsZ = new Vec2(0, 0);
			_this._angularSpringZ = false;
			_this._angularEquilibriumZ = 0;
			_this._angularDampingZ = 1;
			_this._angularStiffnessZ = 0;
			_this.on('set_enabled', _this._onSetEnabled, _assertThisInitialized(_this));
			return _this;
		}
		var _proto = JointComponent.prototype;
		_proto._convertTransform = function _convertTransform(pcTransform, ammoTransform) {
			var pos = pcTransform.getTranslation();
			var rot = new Quat();
			rot.setFromMat4(pcTransform);
			var ammoVec = new Ammo.btVector3(pos.x, pos.y, pos.z);
			var ammoQuat = new Ammo.btQuaternion(rot.x, rot.y, rot.z, rot.w);
			ammoTransform.setOrigin(ammoVec);
			ammoTransform.setRotation(ammoQuat);
			Ammo.destroy(ammoVec);
			Ammo.destroy(ammoQuat);
		};
		_proto._updateAngularLimits = function _updateAngularLimits() {
			var constraint = this._constraint;
			if (constraint) {
				var lx, ly, lz, ux, uy, uz;
				if (this._angularMotionX === MOTION_LIMITED) {
					lx = this._angularLimitsX.x * math.DEG_TO_RAD;
					ux = this._angularLimitsX.y * math.DEG_TO_RAD;
				} else if (this._angularMotionX === MOTION_FREE) {
					lx = 1;
					ux = 0;
				} else {
					lx = ux = 0;
				}
				if (this._angularMotionY === MOTION_LIMITED) {
					ly = this._angularLimitsY.x * math.DEG_TO_RAD;
					uy = this._angularLimitsY.y * math.DEG_TO_RAD;
				} else if (this._angularMotionY === MOTION_FREE) {
					ly = 1;
					uy = 0;
				} else {
					ly = uy = 0;
				}
				if (this._angularMotionZ === MOTION_LIMITED) {
					lz = this._angularLimitsZ.x * math.DEG_TO_RAD;
					uz = this._angularLimitsZ.y * math.DEG_TO_RAD;
				} else if (this._angularMotionZ === MOTION_FREE) {
					lz = 1;
					uz = 0;
				} else {
					lz = uz = 0;
				}
				var limits = new Ammo.btVector3(lx, ly, lz);
				constraint.setAngularLowerLimit(limits);
				limits.setValue(ux, uy, uz);
				constraint.setAngularUpperLimit(limits);
				Ammo.destroy(limits);
			}
		};
		_proto._updateLinearLimits = function _updateLinearLimits() {
			var constraint = this._constraint;
			if (constraint) {
				var lx, ly, lz, ux, uy, uz;
				if (this._linearMotionX === MOTION_LIMITED) {
					lx = this._linearLimitsX.x;
					ux = this._linearLimitsX.y;
				} else if (this._linearMotionX === MOTION_FREE) {
					lx = 1;
					ux = 0;
				} else {
					lx = ux = 0;
				}
				if (this._linearMotionY === MOTION_LIMITED) {
					ly = this._linearLimitsY.x;
					uy = this._linearLimitsY.y;
				} else if (this._linearMotionY === MOTION_FREE) {
					ly = 1;
					uy = 0;
				} else {
					ly = uy = 0;
				}
				if (this._linearMotionZ === MOTION_LIMITED) {
					lz = this._linearLimitsZ.x;
					uz = this._linearLimitsZ.y;
				} else if (this._linearMotionZ === MOTION_FREE) {
					lz = 1;
					uz = 0;
				} else {
					lz = uz = 0;
				}
				var limits = new Ammo.btVector3(lx, ly, lz);
				constraint.setLinearLowerLimit(limits);
				limits.setValue(ux, uy, uz);
				constraint.setLinearUpperLimit(limits);
				Ammo.destroy(limits);
			}
		};
		_proto._createConstraint = function _createConstraint() {
			if (this._entityA && this._entityA.rigidbody) {
				this._destroyConstraint();
				var mat = new Mat4();
				var bodyA = this._entityA.rigidbody.body;
				bodyA.activate();
				var jointWtm = this.entity.getWorldTransform();
				var entityAWtm = this._entityA.getWorldTransform();
				var invEntityAWtm = entityAWtm.clone().invert();
				mat.mul2(invEntityAWtm, jointWtm);
				var frameA = new Ammo.btTransform();
				this._convertTransform(mat, frameA);
				if (this._entityB && this._entityB.rigidbody) {
					var bodyB = this._entityB.rigidbody.body;
					bodyB.activate();
					var entityBWtm = this._entityB.getWorldTransform();
					var invEntityBWtm = entityBWtm.clone().invert();
					mat.mul2(invEntityBWtm, jointWtm);
					var frameB = new Ammo.btTransform();
					this._convertTransform(mat, frameB);
					this._constraint = new Ammo.btGeneric6DofSpringConstraint(bodyA, bodyB, frameA, frameB, !this._enableCollision);
					Ammo.destroy(frameB);
				} else {
					this._constraint = new Ammo.btGeneric6DofSpringConstraint(bodyA, frameA, !this._enableCollision);
				}
				Ammo.destroy(frameA);
				var axis = ['X', 'Y', 'Z', 'X', 'Y', 'Z'];
				for (var i = 0; i < 6; i++) {
					var type = i < 3 ? '_linear' : '_angular';
					this._constraint.enableSpring(i, this[type + 'Spring' + axis[i]]);
					this._constraint.setDamping(i, this[type + 'Damping' + axis[i]]);
					this._constraint.setEquilibriumPoint(i, this[type + 'Equilibrium' + axis[i]]);
					this._constraint.setStiffness(i, this[type + 'Stiffness' + axis[i]]);
				}
				this._constraint.setBreakingImpulseThreshold(this._breakForce);
				this._updateLinearLimits();
				this._updateAngularLimits();
				var app = this.system.app;
				var dynamicsWorld = app.systems.rigidbody.dynamicsWorld;
				dynamicsWorld.addConstraint(this._constraint, !this._enableCollision);
			}
		};
		_proto._destroyConstraint = function _destroyConstraint() {
			if (this._constraint) {
				var app = this.system.app;
				var dynamicsWorld = app.systems.rigidbody.dynamicsWorld;
				dynamicsWorld.removeConstraint(this._constraint);
				Ammo.destroy(this._constraint);
				this._constraint = null;
			}
		};
		_proto.initFromData = function initFromData(data) {
			for (var _i = 0, _properties = properties; _i < _properties.length; _i++) {
				var prop = _properties[_i];
				if (data.hasOwnProperty(prop)) {
					if (data[prop] instanceof Vec2) {
						this['_' + prop].copy(data[prop]);
					} else {
						this['_' + prop] = data[prop];
					}
				}
			}
			this._createConstraint();
		};
		_proto.onEnable = function onEnable() {
			this._createConstraint();
		};
		_proto.onDisable = function onDisable() {
			this._destroyConstraint();
		};
		_proto._onSetEnabled = function _onSetEnabled(prop, old, value) {};
		_proto._onBeforeRemove = function _onBeforeRemove() {
			this.fire('remove');
		};
		_createClass(JointComponent, [{
			key: "entityA",
			get: function get() {
				return this._entityA;
			},
			set: function set(body) {
				this._destroyConstraint();
				this._entityA = body;
				this._createConstraint();
			}
		}, {
			key: "entityB",
			get: function get() {
				return this._entityB;
			},
			set: function set(body) {
				this._destroyConstraint();
				this._entityB = body;
				this._createConstraint();
			}
		}, {
			key: "breakForce",
			get: function get() {
				return this._breakForce;
			},
			set: function set(force) {
				if (this._constraint && this._breakForce !== force) {
					this._constraint.setBreakingImpulseThreshold(force);
					this._breakForce = force;
				}
			}
		}, {
			key: "enableCollision",
			get: function get() {
				return this._enableCollision;
			},
			set: function set(enableCollision) {
				this._destroyConstraint();
				this._enableCollision = enableCollision;
				this._createConstraint();
			}
		}, {
			key: "angularLimitsX",
			get: function get() {
				return this._angularLimitsX;
			},
			set: function set(limits) {
				if (!this._angularLimitsX.equals(limits)) {
					this._angularLimitsX.copy(limits);
					this._updateAngularLimits();
				}
			}
		}, {
			key: "angularMotionX",
			get: function get() {
				return this._angularMotionX;
			},
			set: function set(value) {
				if (this._angularMotionX !== value) {
					this._angularMotionX = value;
					this._updateAngularLimits();
				}
			}
		}, {
			key: "angularLimitsY",
			get: function get() {
				return this._angularLimitsY;
			},
			set: function set(limits) {
				if (!this._angularLimitsY.equals(limits)) {
					this._angularLimitsY.copy(limits);
					this._updateAngularLimits();
				}
			}
		}, {
			key: "angularMotionY",
			get: function get() {
				return this._angularMotionY;
			},
			set: function set(value) {
				if (this._angularMotionY !== value) {
					this._angularMotionY = value;
					this._updateAngularLimits();
				}
			}
		}, {
			key: "angularLimitsZ",
			get: function get() {
				return this._angularLimitsZ;
			},
			set: function set(limits) {
				if (!this._angularLimitsZ.equals(limits)) {
					this._angularLimitsZ.copy(limits);
					this._updateAngularLimits();
				}
			}
		}, {
			key: "angularMotionZ",
			get: function get() {
				return this._angularMotionZ;
			},
			set: function set(value) {
				if (this._angularMotionZ !== value) {
					this._angularMotionZ = value;
					this._updateAngularLimits();
				}
			}
		}, {
			key: "linearLimitsX",
			get: function get() {
				return this._linearLimitsX;
			},
			set: function set(limits) {
				if (!this._linearLimitsX.equals(limits)) {
					this._linearLimitsX.copy(limits);
					this._updateLinearLimits();
				}
			}
		}, {
			key: "linearMotionX",
			get: function get() {
				return this._linearMotionX;
			},
			set: function set(value) {
				if (this._linearMotionX !== value) {
					this._linearMotionX = value;
					this._updateLinearLimits();
				}
			}
		}, {
			key: "linearLimitsY",
			get: function get() {
				return this._linearLimitsY;
			},
			set: function set(limits) {
				if (!this._linearLimitsY.equals(limits)) {
					this._linearLimitsY.copy(limits);
					this._updateLinearLimits();
				}
			}
		}, {
			key: "linearMotionY",
			get: function get() {
				return this._linearMotionY;
			},
			set: function set(value) {
				if (this._linearMotionY !== value) {
					this._linearMotionY = value;
					this._updateLinearLimits();
				}
			}
		}, {
			key: "linearLimitsZ",
			get: function get() {
				return this._linearLimitsZ;
			},
			set: function set(limits) {
				if (!this._linearLimitsZ.equals(limits)) {
					this._linearLimitsZ.copy(limits);
					this._updateLinearLimits();
				}
			}
		}, {
			key: "linearMotionZ",
			get: function get() {
				return this._linearMotionZ;
			},
			set: function set(value) {
				if (this._linearMotionZ !== value) {
					this._linearMotionZ = value;
					this._updateLinearLimits();
				}
			}
		}]);
		return JointComponent;
	}(Component);
	var functionMap = {
		Damping: 'setDamping',
		Equilibrium: 'setEquilibriumPoint',
		Spring: 'enableSpring',
		Stiffness: 'setStiffness'
	};
	['linear', 'angular'].forEach(function (type) {
		['Damping', 'Equilibrium', 'Spring', 'Stiffness'].forEach(function (name) {
			['X', 'Y', 'Z'].forEach(function (axis) {
				var prop = type + name + axis;
				var propInternal = '_' + prop;
				var index = type === 'linear' ? 0 : 3;
				if (axis === 'Y') index += 1;
				if (axis === 'Z') index += 2;
				Object.defineProperty(JointComponent.prototype, prop, {
					get: function get() {
						return this[propInternal];
					},
					set: function set(value) {
						if (this[propInternal] !== value) {
							this[propInternal] = value;
							this._constraint[functionMap[name]](index, value);
						}
					}
				});
			});
		});
	});

	var JointComponentData = function JointComponentData() {
		this.enabled = true;
	};

	var _schema$e = ['enabled'];
	var JointComponentSystem = function (_ComponentSystem) {
		_inheritsLoose(JointComponentSystem, _ComponentSystem);
		function JointComponentSystem(app) {
			var _this;
			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'joint';
			_this.app = app;
			_this.ComponentType = JointComponent;
			_this.DataType = JointComponentData;
			_this.schema = _schema$e;
			return _this;
		}
		var _proto = JointComponentSystem.prototype;
		_proto.initializeComponentData = function initializeComponentData(component, data, properties) {
			component.initFromData(data);
		};
		return JointComponentSystem;
	}(ComponentSystem);
	Component._buildAccessors(JointComponent.prototype, _schema$e);

	var LayoutChildComponent = function (_Component) {
		_inheritsLoose(LayoutChildComponent, _Component);
		function LayoutChildComponent(system, entity) {
			var _this;
			_this = _Component.call(this, system, entity) || this;
			_this._minWidth = 0;
			_this._minHeight = 0;
			_this._maxWidth = null;
			_this._maxHeight = null;
			_this._fitWidthProportion = 0;
			_this._fitHeightProportion = 0;
			_this._excludeFromLayout = false;
			return _this;
		}
		_createClass(LayoutChildComponent, [{
			key: "minWidth",
			get: function get() {
				return this._minWidth;
			},
			set: function set(value) {
				if (value !== this._minWidth) {
					this._minWidth = value;
					this.fire('resize');
				}
			}
		}, {
			key: "minHeight",
			get: function get() {
				return this._minHeight;
			},
			set: function set(value) {
				if (value !== this._minHeight) {
					this._minHeight = value;
					this.fire('resize');
				}
			}
		}, {
			key: "maxWidth",
			get: function get() {
				return this._maxWidth;
			},
			set: function set(value) {
				if (value !== this._maxWidth) {
					this._maxWidth = value;
					this.fire('resize');
				}
			}
		}, {
			key: "maxHeight",
			get: function get() {
				return this._maxHeight;
			},
			set: function set(value) {
				if (value !== this._maxHeight) {
					this._maxHeight = value;
					this.fire('resize');
				}
			}
		}, {
			key: "fitWidthProportion",
			get: function get() {
				return this._fitWidthProportion;
			},
			set: function set(value) {
				if (value !== this._fitWidthProportion) {
					this._fitWidthProportion = value;
					this.fire('resize');
				}
			}
		}, {
			key: "fitHeightProportion",
			get: function get() {
				return this._fitHeightProportion;
			},
			set: function set(value) {
				if (value !== this._fitHeightProportion) {
					this._fitHeightProportion = value;
					this.fire('resize');
				}
			}
		}, {
			key: "excludeFromLayout",
			get: function get() {
				return this._excludeFromLayout;
			},
			set: function set(value) {
				if (value !== this._excludeFromLayout) {
					this._excludeFromLayout = value;
					this.fire('resize');
				}
			}
		}]);
		return LayoutChildComponent;
	}(Component);

	var LayoutChildComponentData = function LayoutChildComponentData() {
		this.enabled = true;
	};

	var _schema$d = ['enabled'];
	var LayoutChildComponentSystem = function (_ComponentSystem) {
		_inheritsLoose(LayoutChildComponentSystem, _ComponentSystem);
		function LayoutChildComponentSystem(app) {
			var _this;
			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'layoutchild';
			_this.ComponentType = LayoutChildComponent;
			_this.DataType = LayoutChildComponentData;
			_this.schema = _schema$d;
			return _this;
		}
		var _proto = LayoutChildComponentSystem.prototype;
		_proto.initializeComponentData = function initializeComponentData(component, data, properties) {
			if (data.enabled !== undefined) component.enabled = data.enabled;
			if (data.minWidth !== undefined) component.minWidth = data.minWidth;
			if (data.minHeight !== undefined) component.minHeight = data.minHeight;
			if (data.maxWidth !== undefined) component.maxWidth = data.maxWidth;
			if (data.maxHeight !== undefined) component.maxHeight = data.maxHeight;
			if (data.fitWidthProportion !== undefined) component.fitWidthProportion = data.fitWidthProportion;
			if (data.fitHeightProportion !== undefined) component.fitHeightProportion = data.fitHeightProportion;
			if (data.excludeFromLayout !== undefined) component.excludeFromLayout = data.excludeFromLayout;
			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
		};
		_proto.cloneComponent = function cloneComponent(entity, clone) {
			var layoutChild = entity.layoutchild;
			return this.addComponent(clone, {
				enabled: layoutChild.enabled,
				minWidth: layoutChild.minWidth,
				minHeight: layoutChild.minHeight,
				maxWidth: layoutChild.maxWidth,
				maxHeight: layoutChild.maxHeight,
				fitWidthProportion: layoutChild.fitWidthProportion,
				fitHeightProportion: layoutChild.fitHeightProportion,
				excludeFromLayout: layoutChild.excludeFromLayout
			});
		};
		return LayoutChildComponentSystem;
	}(ComponentSystem);
	Component._buildAccessors(LayoutChildComponent.prototype, _schema$d);

	var FITTING_NONE = 0;
	var FITTING_STRETCH = 1;
	var FITTING_SHRINK = 2;
	var FITTING_BOTH = 3;

	var AXIS_MAPPINGS = {};
	AXIS_MAPPINGS[ORIENTATION_HORIZONTAL] = {
		axis: 'x',
		size: 'width',
		calculatedSize: 'calculatedWidth',
		minSize: 'minWidth',
		maxSize: 'maxWidth',
		fitting: 'widthFitting',
		fittingProportion: 'fitWidthProportion'
	};
	AXIS_MAPPINGS[ORIENTATION_VERTICAL] = {
		axis: 'y',
		size: 'height',
		calculatedSize: 'calculatedHeight',
		minSize: 'minHeight',
		maxSize: 'maxHeight',
		fitting: 'heightFitting',
		fittingProportion: 'fitHeightProportion'
	};
	var OPPOSITE_ORIENTATION = {};
	OPPOSITE_ORIENTATION[ORIENTATION_HORIZONTAL] = ORIENTATION_VERTICAL;
	OPPOSITE_ORIENTATION[ORIENTATION_VERTICAL] = ORIENTATION_HORIZONTAL;
	var PROPERTY_DEFAULTS = {
		minWidth: 0,
		minHeight: 0,
		maxWidth: Number.POSITIVE_INFINITY,
		maxHeight: Number.POSITIVE_INFINITY,
		width: null,
		height: null,
		fitWidthProportion: 0,
		fitHeightProportion: 0
	};
	var FITTING_ACTION = {
		NONE: 'NONE',
		APPLY_STRETCHING: 'APPLY_STRETCHING',
		APPLY_SHRINKING: 'APPLY_SHRINKING'
	};
	var availableSpace = new Vec2();
	function createCalculator(orientation) {
		var options;
		var a = AXIS_MAPPINGS[orientation];
		var b = AXIS_MAPPINGS[OPPOSITE_ORIENTATION[orientation]];
		function minExtentA(element, size) {
			return -size[a.size] * element.pivot[a.axis];
		}
		function minExtentB(element, size) {
			return -size[b.size] * element.pivot[b.axis];
		}
		function maxExtentA(element, size) {
			return size[a.size] * (1 - element.pivot[a.axis]);
		}
		function calculateAll(allElements, layoutOptions) {
			allElements = allElements.filter(shouldIncludeInLayout);
			options = layoutOptions;
			availableSpace.x = options.containerSize.x - options.padding.x - options.padding.z;
			availableSpace.y = options.containerSize.y - options.padding.y - options.padding.w;
			resetAnchors(allElements);
			var lines = reverseLinesIfRequired(splitLines(allElements));
			var sizes = calculateSizesOnAxisB(lines, calculateSizesOnAxisA(lines));
			var positions = calculateBasePositions(lines, sizes);
			applyAlignmentAndPadding(lines, sizes, positions);
			applySizesAndPositions(lines, sizes, positions);
			return createLayoutInfo(lines);
		}
		function shouldIncludeInLayout(element) {
			var layoutChildComponent = element.entity.layoutchild;
			return !layoutChildComponent || !layoutChildComponent.enabled || !layoutChildComponent.excludeFromLayout;
		}
		function resetAnchors(allElements) {
			for (var i = 0; i < allElements.length; ++i) {
				var element = allElements[i];
				var anchor = element.anchor;
				if (anchor.x !== 0 || anchor.y !== 0 || anchor.z !== 0 || anchor.w !== 0) {
					element.anchor = Vec4.ZERO;
				}
			}
		}
		function splitLines(allElements) {
			if (!options.wrap) {
				return [allElements];
			}
			var lines = [[]];
			var sizes = getElementSizeProperties(allElements);
			var runningSize = 0;
			var allowOverrun = options[a.fitting] === FITTING_SHRINK;
			for (var i = 0; i < allElements.length; ++i) {
				if (lines[lines.length - 1].length > 0) {
					runningSize += options.spacing[a.axis];
				}
				var idealElementSize = sizes[i][a.size];
				runningSize += idealElementSize;
				if (!allowOverrun && runningSize > availableSpace[a.axis] && lines[lines.length - 1].length !== 0) {
					runningSize = idealElementSize;
					lines.push([]);
				}
				lines[lines.length - 1].push(allElements[i]);
				if (allowOverrun && runningSize > availableSpace[a.axis] && i !== allElements.length - 1) {
					runningSize = 0;
					lines.push([]);
				}
			}
			return lines;
		}
		function reverseLinesIfRequired(lines) {
			var reverseAxisA = options.orientation === ORIENTATION_HORIZONTAL && options.reverseX || options.orientation === ORIENTATION_VERTICAL && options.reverseY;
			var reverseAxisB = options.orientation === ORIENTATION_HORIZONTAL && options.reverseY || options.orientation === ORIENTATION_VERTICAL && options.reverseX;
			if (reverseAxisA) {
				for (var lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
					if (reverseAxisA) {
						lines[lineIndex].reverse();
					}
				}
			}
			if (reverseAxisB) {
				lines.reverse();
			}
			return lines;
		}
		function calculateSizesOnAxisA(lines) {
			var sizesAllLines = [];
			for (var lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
				var line = lines[lineIndex];
				var sizesThisLine = getElementSizeProperties(line);
				var idealRequiredSpace = calculateTotalSpace(sizesThisLine, a);
				var fittingAction = determineFittingAction(options[a.fitting], idealRequiredSpace, availableSpace[a.axis]);
				if (fittingAction === FITTING_ACTION.APPLY_STRETCHING) {
					stretchSizesToFitContainer(sizesThisLine, idealRequiredSpace, a);
				} else if (fittingAction === FITTING_ACTION.APPLY_SHRINKING) {
					shrinkSizesToFitContainer(sizesThisLine, idealRequiredSpace, a);
				}
				sizesAllLines.push(sizesThisLine);
			}
			return sizesAllLines;
		}
		function calculateSizesOnAxisB(lines, sizesAllLines) {
			var largestElementsForEachLine = [];
			var largestSizesForEachLine = [];
			for (var lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
				var line = lines[lineIndex];
				line.largestElement = null;
				line.largestSize = {
					width: Number.NEGATIVE_INFINITY,
					height: Number.NEGATIVE_INFINITY
				};
				for (var elementIndex = 0; elementIndex < line.length; ++elementIndex) {
					var sizesThisElement = sizesAllLines[lineIndex][elementIndex];
					if (sizesThisElement[b.size] > line.largestSize[b.size]) {
						line.largestElement = line[elementIndex];
						line.largestSize = sizesThisElement;
					}
				}
				largestElementsForEachLine.push(line.largestElement);
				largestSizesForEachLine.push(line.largestSize);
			}
			var idealRequiredSpace = calculateTotalSpace(largestSizesForEachLine, b);
			var fittingAction = determineFittingAction(options[b.fitting], idealRequiredSpace, availableSpace[b.axis]);
			if (fittingAction === FITTING_ACTION.APPLY_STRETCHING) {
				stretchSizesToFitContainer(largestSizesForEachLine, idealRequiredSpace, b);
			} else if (fittingAction === FITTING_ACTION.APPLY_SHRINKING) {
				shrinkSizesToFitContainer(largestSizesForEachLine, idealRequiredSpace, b);
			}
			for (var _lineIndex = 0; _lineIndex < lines.length; ++_lineIndex) {
				var _line = lines[_lineIndex];
				for (var _elementIndex = 0; _elementIndex < _line.length; ++_elementIndex) {
					var sizesForThisElement = sizesAllLines[_lineIndex][_elementIndex];
					var currentSize = sizesForThisElement[b.size];
					var availableSize = lines.length === 1 ? availableSpace[b.axis] : _line.largestSize[b.size];
					var elementFittingAction = determineFittingAction(options[b.fitting], currentSize, availableSize);
					if (elementFittingAction === FITTING_ACTION.APPLY_STRETCHING) {
						sizesForThisElement[b.size] = Math.min(availableSize, sizesForThisElement[b.maxSize]);
					} else if (elementFittingAction === FITTING_ACTION.APPLY_SHRINKING) {
						sizesForThisElement[b.size] = Math.max(availableSize, sizesForThisElement[b.minSize]);
					}
				}
			}
			return sizesAllLines;
		}
		function determineFittingAction(fittingMode, currentSize, availableSize) {
			switch (fittingMode) {
				case FITTING_NONE:
					return FITTING_ACTION.NONE;
				case FITTING_STRETCH:
					if (currentSize < availableSize) {
						return FITTING_ACTION.APPLY_STRETCHING;
					}
					return FITTING_ACTION.NONE;
				case FITTING_SHRINK:
					if (currentSize >= availableSize) {
						return FITTING_ACTION.APPLY_SHRINKING;
					}
					return FITTING_ACTION.NONE;
				case FITTING_BOTH:
					if (currentSize < availableSize) {
						return FITTING_ACTION.APPLY_STRETCHING;
					}
					return FITTING_ACTION.APPLY_SHRINKING;
				default:
					throw new Error("Unrecognized fitting mode: " + fittingMode);
			}
		}
		function calculateTotalSpace(sizes, axis) {
			var totalSizes = sumValues(sizes, axis.size);
			var totalSpacing = (sizes.length - 1) * options.spacing[axis.axis];
			return totalSizes + totalSpacing;
		}
		function stretchSizesToFitContainer(sizesThisLine, idealRequiredSpace, axis) {
			var ascendingMaxSizeOrder = getTraversalOrder(sizesThisLine, axis.maxSize);
			var fittingProportions = getNormalizedValues(sizesThisLine, axis.fittingProportion);
			var fittingProportionSums = createSumArray(fittingProportions, ascendingMaxSizeOrder);
			var remainingUndershoot = availableSpace[axis.axis] - idealRequiredSpace;
			for (var i = 0; i < sizesThisLine.length; ++i) {
				var index = ascendingMaxSizeOrder[i];
				var targetIncrease = calculateAdjustment(index, remainingUndershoot, fittingProportions, fittingProportionSums);
				var targetSize = sizesThisLine[index][axis.size] + targetIncrease;
				var maxSize = sizesThisLine[index][axis.maxSize];
				var actualSize = Math.min(targetSize, maxSize);
				sizesThisLine[index][axis.size] = actualSize;
				var actualIncrease = Math.max(targetSize - actualSize, 0);
				var appliedIncrease = targetIncrease - actualIncrease;
				remainingUndershoot -= appliedIncrease;
			}
		}
		function shrinkSizesToFitContainer(sizesThisLine, idealRequiredSpace, axis) {
			var descendingMinSizeOrder = getTraversalOrder(sizesThisLine, axis.minSize, true);
			var fittingProportions = getNormalizedValues(sizesThisLine, axis.fittingProportion);
			var inverseFittingProportions = invertNormalizedValues(fittingProportions);
			var inverseFittingProportionSums = createSumArray(inverseFittingProportions, descendingMinSizeOrder);
			var remainingOvershoot = idealRequiredSpace - availableSpace[axis.axis];
			for (var i = 0; i < sizesThisLine.length; ++i) {
				var index = descendingMinSizeOrder[i];
				var targetReduction = calculateAdjustment(index, remainingOvershoot, inverseFittingProportions, inverseFittingProportionSums);
				var targetSize = sizesThisLine[index][axis.size] - targetReduction;
				var minSize = sizesThisLine[index][axis.minSize];
				var actualSize = Math.max(targetSize, minSize);
				sizesThisLine[index][axis.size] = actualSize;
				var actualReduction = Math.max(actualSize - targetSize, 0);
				var appliedReduction = targetReduction - actualReduction;
				remainingOvershoot -= appliedReduction;
			}
		}
		function calculateAdjustment(index, remainingAdjustment, fittingProportions, fittingProportionSums) {
			var proportion = fittingProportions[index];
			var sumOfRemainingProportions = fittingProportionSums[index];
			if (Math.abs(proportion) < 1e-5 && Math.abs(sumOfRemainingProportions) < 1e-5) {
				return remainingAdjustment;
			}
			return remainingAdjustment * proportion / sumOfRemainingProportions;
		}
		function calculateBasePositions(lines, sizes) {
			var cursor = {};
			cursor[a.axis] = 0;
			cursor[b.axis] = 0;
			lines[a.size] = Number.NEGATIVE_INFINITY;
			var positionsAllLines = [];
			for (var lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
				var line = lines[lineIndex];
				if (line.length === 0) {
					positionsAllLines.push([]);
					continue;
				}
				var positionsThisLine = [];
				var sizesThisLine = sizes[lineIndex];
				for (var elementIndex = 0; elementIndex < line.length; ++elementIndex) {
					var element = line[elementIndex];
					var sizesThisElement = sizesThisLine[elementIndex];
					cursor[b.axis] -= minExtentB(element, sizesThisElement);
					cursor[a.axis] -= minExtentA(element, sizesThisElement);
					positionsThisLine[elementIndex] = {};
					positionsThisLine[elementIndex][a.axis] = cursor[a.axis];
					positionsThisLine[elementIndex][b.axis] = cursor[b.axis];
					cursor[b.axis] += minExtentB(element, sizesThisElement);
					cursor[a.axis] += maxExtentA(element, sizesThisElement) + options.spacing[a.axis];
				}
				line[a.size] = cursor[a.axis] - options.spacing[a.axis];
				line[b.size] = line.largestSize[b.size];
				lines[a.size] = Math.max(lines[a.size], line[a.size]);
				cursor[a.axis] = 0;
				cursor[b.axis] += line[b.size] + options.spacing[b.axis];
				positionsAllLines.push(positionsThisLine);
			}
			lines[b.size] = cursor[b.axis] - options.spacing[b.axis];
			return positionsAllLines;
		}
		function applyAlignmentAndPadding(lines, sizes, positions) {
			var alignmentA = options.alignment[a.axis];
			var alignmentB = options.alignment[b.axis];
			var paddingA = options.padding[a.axis];
			var paddingB = options.padding[b.axis];
			for (var lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
				var line = lines[lineIndex];
				var sizesThisLine = sizes[lineIndex];
				var positionsThisLine = positions[lineIndex];
				var axisAOffset = (availableSpace[a.axis] - line[a.size]) * alignmentA + paddingA;
				var axisBOffset = (availableSpace[b.axis] - lines[b.size]) * alignmentB + paddingB;
				for (var elementIndex = 0; elementIndex < line.length; ++elementIndex) {
					var withinLineAxisBOffset = (line[b.size] - sizesThisLine[elementIndex][b.size]) * options.alignment[b.axis];
					positionsThisLine[elementIndex][a.axis] += axisAOffset;
					positionsThisLine[elementIndex][b.axis] += axisBOffset + withinLineAxisBOffset;
				}
			}
		}
		function applySizesAndPositions(lines, sizes, positions) {
			for (var lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
				var line = lines[lineIndex];
				var sizesThisLine = sizes[lineIndex];
				var positionsThisLine = positions[lineIndex];
				for (var elementIndex = 0; elementIndex < line.length; ++elementIndex) {
					var element = line[elementIndex];
					element[a.calculatedSize] = sizesThisLine[elementIndex][a.size];
					element[b.calculatedSize] = sizesThisLine[elementIndex][b.size];
					if (options.orientation === ORIENTATION_HORIZONTAL) {
						element.entity.setLocalPosition(positionsThisLine[elementIndex][a.axis], positionsThisLine[elementIndex][b.axis], element.entity.getLocalPosition().z);
					} else {
						element.entity.setLocalPosition(positionsThisLine[elementIndex][b.axis], positionsThisLine[elementIndex][a.axis], element.entity.getLocalPosition().z);
					}
				}
			}
		}
		function createLayoutInfo(lines) {
			var layoutWidth = lines.width;
			var layoutHeight = lines.height;
			var xOffset = (availableSpace.x - layoutWidth) * options.alignment.x + options.padding.x;
			var yOffset = (availableSpace.y - layoutHeight) * options.alignment.y + options.padding.y;
			return {
				bounds: new Vec4(xOffset, yOffset, layoutWidth, layoutHeight)
			};
		}
		function getElementSizeProperties(elements) {
			var sizeProperties = [];
			for (var i = 0; i < elements.length; ++i) {
				var element = elements[i];
				var minWidth = Math.max(getProperty(element, 'minWidth'), 0);
				var minHeight = Math.max(getProperty(element, 'minHeight'), 0);
				var maxWidth = Math.max(getProperty(element, 'maxWidth'), minWidth);
				var maxHeight = Math.max(getProperty(element, 'maxHeight'), minHeight);
				var width = clamp(getProperty(element, 'width'), minWidth, maxWidth);
				var height = clamp(getProperty(element, 'height'), minHeight, maxHeight);
				var fitWidthProportion = getProperty(element, 'fitWidthProportion');
				var fitHeightProportion = getProperty(element, 'fitHeightProportion');
				sizeProperties.push({
					minWidth: minWidth,
					minHeight: minHeight,
					maxWidth: maxWidth,
					maxHeight: maxHeight,
					width: width,
					height: height,
					fitWidthProportion: fitWidthProportion,
					fitHeightProportion: fitHeightProportion
				});
			}
			return sizeProperties;
		}
		function getProperty(element, propertyName) {
			var layoutChildComponent = element.entity.layoutchild;
			if (layoutChildComponent && layoutChildComponent.enabled && layoutChildComponent[propertyName] !== undefined && layoutChildComponent[propertyName] !== null) {
				return layoutChildComponent[propertyName];
			} else if (element[propertyName] !== undefined) {
				return element[propertyName];
			}
			return PROPERTY_DEFAULTS[propertyName];
		}
		function clamp(value, min, max) {
			return Math.min(Math.max(value, min), max);
		}
		function sumValues(items, propertyName) {
			return items.reduce(function (accumulator, current) {
				return accumulator + current[propertyName];
			}, 0);
		}
		function getNormalizedValues(items, propertyName) {
			var sum = sumValues(items, propertyName);
			var normalizedValues = [];
			var numItems = items.length;
			if (sum === 0) {
				for (var i = 0; i < numItems; ++i) {
					normalizedValues.push(1 / numItems);
				}
			} else {
				for (var _i = 0; _i < numItems; ++_i) {
					normalizedValues.push(items[_i][propertyName] / sum);
				}
			}
			return normalizedValues;
		}
		function invertNormalizedValues(values) {
			if (values.length === 1) {
				return [1];
			}
			var invertedValues = [];
			var numValues = values.length;
			for (var i = 0; i < numValues; ++i) {
				invertedValues.push((1 - values[i]) / (numValues - 1));
			}
			return invertedValues;
		}
		function getTraversalOrder(items, orderBy, descending) {
			items.forEach(assignIndex);
			return items.slice().sort(function (itemA, itemB) {
				return descending ? itemB[orderBy] - itemA[orderBy] : itemA[orderBy] - itemB[orderBy];
			}).map(getIndex);
		}
		function assignIndex(item, index) {
			item.index = index;
		}
		function getIndex(item) {
			return item.index;
		}
		function createSumArray(values, order) {
			var sumArray = [];
			sumArray[order[values.length - 1]] = values[order[values.length - 1]];
			for (var i = values.length - 2; i >= 0; --i) {
				sumArray[order[i]] = sumArray[order[i + 1]] + values[order[i]];
			}
			return sumArray;
		}
		return calculateAll;
	}
	var CALCULATE_FNS = {};
	CALCULATE_FNS[ORIENTATION_HORIZONTAL] = createCalculator(ORIENTATION_HORIZONTAL);
	CALCULATE_FNS[ORIENTATION_VERTICAL] = createCalculator(ORIENTATION_VERTICAL);
	var LayoutCalculator = function () {
		function LayoutCalculator() {}
		var _proto = LayoutCalculator.prototype;
		_proto.calculateLayout = function calculateLayout(elements, options) {
			var calculateFn = CALCULATE_FNS[options.orientation];
			if (!calculateFn) {
				throw new Error('Unrecognized orientation value: ' + options.orientation);
			} else {
				return calculateFn(elements, options);
			}
		};
		return LayoutCalculator;
	}();

	function getElement(entity) {
		return entity.element;
	}
	function isEnabledAndHasEnabledElement(entity) {
		return entity.enabled && entity.element && entity.element.enabled;
	}
	var LayoutGroupComponent = function (_Component) {
		_inheritsLoose(LayoutGroupComponent, _Component);
		function LayoutGroupComponent(system, entity) {
			var _this;
			_this = _Component.call(this, system, entity) || this;
			_this._orientation = ORIENTATION_HORIZONTAL;
			_this._reverseX = false;
			_this._reverseY = true;
			_this._alignment = new Vec2(0, 1);
			_this._padding = new Vec4();
			_this._spacing = new Vec2();
			_this._widthFitting = FITTING_NONE;
			_this._heightFitting = FITTING_NONE;
			_this._wrap = false;
			_this._layoutCalculator = new LayoutCalculator();
			_this._listenForReflowEvents(_this.entity, 'on');
			_this.entity.children.forEach(function (child) {
				_this._listenForReflowEvents(child, 'on');
			});
			_this.entity.on('childinsert', _this._onChildInsert, _assertThisInitialized(_this));
			_this.entity.on('childremove', _this._onChildRemove, _assertThisInitialized(_this));
			system.app.systems.element.on('add', _this._onElementOrLayoutComponentAdd, _assertThisInitialized(_this));
			system.app.systems.element.on('beforeremove', _this._onElementOrLayoutComponentRemove, _assertThisInitialized(_this));
			system.app.systems.layoutchild.on('add', _this._onElementOrLayoutComponentAdd, _assertThisInitialized(_this));
			system.app.systems.layoutchild.on('beforeremove', _this._onElementOrLayoutComponentRemove, _assertThisInitialized(_this));
			return _this;
		}
		var _proto = LayoutGroupComponent.prototype;
		_proto._isSelfOrChild = function _isSelfOrChild(entity) {
			return entity === this.entity || this.entity.children.indexOf(entity) !== -1;
		};
		_proto._listenForReflowEvents = function _listenForReflowEvents(target, onOff) {
			if (target.element) {
				target.element[onOff]('enableelement', this._scheduleReflow, this);
				target.element[onOff]('disableelement', this._scheduleReflow, this);
				target.element[onOff]('resize', this._scheduleReflow, this);
				target.element[onOff]('set:pivot', this._scheduleReflow, this);
			}
			if (target.layoutchild) {
				target.layoutchild[onOff]('set_enabled', this._scheduleReflow, this);
				target.layoutchild[onOff]('resize', this._scheduleReflow, this);
			}
		};
		_proto._onElementOrLayoutComponentAdd = function _onElementOrLayoutComponentAdd(entity) {
			if (this._isSelfOrChild(entity)) {
				this._listenForReflowEvents(entity, 'on');
				this._scheduleReflow();
			}
		};
		_proto._onElementOrLayoutComponentRemove = function _onElementOrLayoutComponentRemove(entity) {
			if (this._isSelfOrChild(entity)) {
				this._listenForReflowEvents(entity, 'off');
				this._scheduleReflow();
			}
		};
		_proto._onChildInsert = function _onChildInsert(child) {
			this._listenForReflowEvents(child, 'on');
			this._scheduleReflow();
		};
		_proto._onChildRemove = function _onChildRemove(child) {
			this._listenForReflowEvents(child, 'off');
			this._scheduleReflow();
		};
		_proto._scheduleReflow = function _scheduleReflow() {
			if (this.enabled && this.entity && this.entity.enabled && !this._isPerformingReflow) {
				this.system.scheduleReflow(this);
			}
		};
		_proto.reflow = function reflow() {
			var container = getElement(this.entity);
			var elements = this.entity.children.filter(isEnabledAndHasEnabledElement).map(getElement);
			if (!container || elements.length === 0) {
				return;
			}
			var containerWidth = Math.max(container.calculatedWidth, 0);
			var containerHeight = Math.max(container.calculatedHeight, 0);
			var options = {
				orientation: this._orientation,
				reverseX: this._reverseX,
				reverseY: this._reverseY,
				alignment: this._alignment,
				padding: this._padding,
				spacing: this._spacing,
				widthFitting: this._widthFitting,
				heightFitting: this._heightFitting,
				wrap: this._wrap,
				containerSize: new Vec2(containerWidth, containerHeight)
			};
			this._isPerformingReflow = true;
			var layoutInfo = this._layoutCalculator.calculateLayout(elements, options);
			this._isPerformingReflow = false;
			this.fire('reflow', layoutInfo);
		};
		_proto.onEnable = function onEnable() {
			this._scheduleReflow();
		};
		_proto.onRemove = function onRemove() {
			var _this2 = this;
			this.entity.off('childinsert', this._onChildInsert, this);
			this.entity.off('childremove', this._onChildRemove, this);
			this._listenForReflowEvents(this.entity, 'off');
			this.entity.children.forEach(function (child) {
				_this2._listenForReflowEvents(child, 'off');
			});
			this.system.app.systems.element.off('add', this._onElementOrLayoutComponentAdd, this);
			this.system.app.systems.element.off('beforeremove', this._onElementOrLayoutComponentRemove, this);
			this.system.app.systems.layoutchild.off('add', this._onElementOrLayoutComponentAdd, this);
			this.system.app.systems.layoutchild.off('beforeremove', this._onElementOrLayoutComponentRemove, this);
		};
		_createClass(LayoutGroupComponent, [{
			key: "orientation",
			get: function get() {
				return this._orientation;
			},
			set: function set(value) {
				if (value !== this._orientation) {
					this._orientation = value;
					this._scheduleReflow();
				}
			}
		}, {
			key: "reverseX",
			get: function get() {
				return this._reverseX;
			},
			set: function set(value) {
				if (value !== this._reverseX) {
					this._reverseX = value;
					this._scheduleReflow();
				}
			}
		}, {
			key: "reverseY",
			get: function get() {
				return this._reverseY;
			},
			set: function set(value) {
				if (value !== this._reverseY) {
					this._reverseY = value;
					this._scheduleReflow();
				}
			}
		}, {
			key: "alignment",
			get: function get() {
				return this._alignment;
			},
			set: function set(value) {
				if (!value.equals(this._alignment)) {
					this._alignment.copy(value);
					this._scheduleReflow();
				}
			}
		}, {
			key: "padding",
			get: function get() {
				return this._padding;
			},
			set: function set(value) {
				if (!value.equals(this._padding)) {
					this._padding.copy(value);
					this._scheduleReflow();
				}
			}
		}, {
			key: "spacing",
			get: function get() {
				return this._spacing;
			},
			set: function set(value) {
				if (!value.equals(this._spacing)) {
					this._spacing.copy(value);
					this._scheduleReflow();
				}
			}
		}, {
			key: "widthFitting",
			get: function get() {
				return this._widthFitting;
			},
			set: function set(value) {
				if (value !== this._widthFitting) {
					this._widthFitting = value;
					this._scheduleReflow();
				}
			}
		}, {
			key: "heightFitting",
			get: function get() {
				return this._heightFitting;
			},
			set: function set(value) {
				if (value !== this._heightFitting) {
					this._heightFitting = value;
					this._scheduleReflow();
				}
			}
		}, {
			key: "wrap",
			get: function get() {
				return this._wrap;
			},
			set: function set(value) {
				if (value !== this._wrap) {
					this._wrap = value;
					this._scheduleReflow();
				}
			}
		}]);
		return LayoutGroupComponent;
	}(Component);

	var LayoutGroupComponentData = function LayoutGroupComponentData() {
		this.enabled = true;
	};

	var _schema$c = ['enabled'];
	var MAX_ITERATIONS = 100;
	var LayoutGroupComponentSystem = function (_ComponentSystem) {
		_inheritsLoose(LayoutGroupComponentSystem, _ComponentSystem);
		function LayoutGroupComponentSystem(app) {
			var _this;
			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'layoutgroup';
			_this.ComponentType = LayoutGroupComponent;
			_this.DataType = LayoutGroupComponentData;
			_this.schema = _schema$c;
			_this._reflowQueue = [];
			_this.on('beforeremove', _this._onRemoveComponent, _assertThisInitialized(_this));
			_this.app.systems.on('postUpdate', _this._onPostUpdate, _assertThisInitialized(_this));
			return _this;
		}
		var _proto = LayoutGroupComponentSystem.prototype;
		_proto.initializeComponentData = function initializeComponentData(component, data, properties) {
			if (data.enabled !== undefined) component.enabled = data.enabled;
			if (data.orientation !== undefined) component.orientation = data.orientation;
			if (data.reverseX !== undefined) component.reverseX = data.reverseX;
			if (data.reverseY !== undefined) component.reverseY = data.reverseY;
			if (data.alignment !== undefined) {
				component.alignment = Array.isArray(data.alignment) ? new Vec2(data.alignment) : data.alignment;
			}
			if (data.padding !== undefined) {
				component.padding = Array.isArray(data.padding) ? new Vec4(data.padding) : data.padding;
			}
			if (data.spacing !== undefined) {
				component.spacing = Array.isArray(data.spacing) ? new Vec2(data.spacing) : data.spacing;
			}
			if (data.widthFitting !== undefined) component.widthFitting = data.widthFitting;
			if (data.heightFitting !== undefined) component.heightFitting = data.heightFitting;
			if (data.wrap !== undefined) component.wrap = data.wrap;
			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
		};
		_proto.cloneComponent = function cloneComponent(entity, clone) {
			var layoutGroup = entity.layoutgroup;
			return this.addComponent(clone, {
				enabled: layoutGroup.enabled,
				orientation: layoutGroup.orientation,
				reverseX: layoutGroup.reverseX,
				reverseY: layoutGroup.reverseY,
				alignment: layoutGroup.alignment,
				padding: layoutGroup.padding,
				spacing: layoutGroup.spacing,
				widthFitting: layoutGroup.widthFitting,
				heightFitting: layoutGroup.heightFitting,
				wrap: layoutGroup.wrap
			});
		};
		_proto.scheduleReflow = function scheduleReflow(component) {
			if (this._reflowQueue.indexOf(component) === -1) {
				this._reflowQueue.push(component);
			}
		};
		_proto._onPostUpdate = function _onPostUpdate() {
			this._processReflowQueue();
		};
		_proto._processReflowQueue = function _processReflowQueue() {
			if (this._reflowQueue.length === 0) {
				return;
			}
			var iterationCount = 0;
			while (this._reflowQueue.length > 0) {
				var queue = this._reflowQueue.slice();
				this._reflowQueue.length = 0;
				queue.sort(function (componentA, componentB) {
					return componentA.entity.graphDepth - componentB.entity.graphDepth;
				});
				for (var i = 0; i < queue.length; ++i) {
					queue[i].reflow();
				}
				if (++iterationCount >= MAX_ITERATIONS) {
					console.warn('Max reflow iterations limit reached, bailing.');
					break;
				}
			}
		};
		_proto._onRemoveComponent = function _onRemoveComponent(entity, component) {
			component.onRemove();
		};
		_proto.destroy = function destroy() {
			_ComponentSystem.prototype.destroy.call(this);
			this.app.systems.off('postUpdate', this._onPostUpdate, this);
		};
		return LayoutGroupComponentSystem;
	}(ComponentSystem);
	Component._buildAccessors(LayoutGroupComponent.prototype, _schema$c);

	var ModelComponent = function (_Component) {
		_inheritsLoose(ModelComponent, _Component);
		function ModelComponent(system, entity) {
			var _this;
			_this = _Component.call(this, system, entity) || this;
			_this._type = 'asset';
			_this._asset = null;
			_this._model = null;
			_this._mapping = {};
			_this._castShadows = true;
			_this._receiveShadows = true;
			_this._materialAsset = null;
			_this._material = void 0;
			_this._castShadowsLightmap = true;
			_this._lightmapped = false;
			_this._lightmapSizeMultiplier = 1;
			_this.isStatic = false;
			_this._layers = [LAYERID_WORLD];
			_this._batchGroupId = -1;
			_this._customAabb = null;
			_this._area = null;
			_this._materialEvents = null;
			_this._clonedModel = false;
			_this._material = system.defaultMaterial;
			entity.on('remove', _this.onRemoveChild, _assertThisInitialized(_this));
			entity.on('removehierarchy', _this.onRemoveChild, _assertThisInitialized(_this));
			entity.on('insert', _this.onInsertChild, _assertThisInitialized(_this));
			entity.on('inserthierarchy', _this.onInsertChild, _assertThisInitialized(_this));
			return _this;
		}
		var _proto = ModelComponent.prototype;
		_proto.addModelToLayers = function addModelToLayers() {
			var layers = this.system.app.scene.layers;
			for (var i = 0; i < this._layers.length; i++) {
				var layer = layers.getLayerById(this._layers[i]);
				if (layer) {
					layer.addMeshInstances(this.meshInstances);
				}
			}
		};
		_proto.removeModelFromLayers = function removeModelFromLayers() {
			var layers = this.system.app.scene.layers;
			for (var i = 0; i < this._layers.length; i++) {
				var layer = layers.getLayerById(this._layers[i]);
				if (!layer) continue;
				layer.removeMeshInstances(this.meshInstances);
			}
		};
		_proto.onRemoveChild = function onRemoveChild() {
			if (this._model) this.removeModelFromLayers();
		};
		_proto.onInsertChild = function onInsertChild() {
			if (this._model && this.enabled && this.entity.enabled) this.addModelToLayers();
		};
		_proto.onRemove = function onRemove() {
			this.asset = null;
			this.model = null;
			this.materialAsset = null;
			this._unsetMaterialEvents();
			this.entity.off('remove', this.onRemoveChild, this);
			this.entity.off('insert', this.onInsertChild, this);
		};
		_proto.onLayersChanged = function onLayersChanged(oldComp, newComp) {
			this.addModelToLayers();
			oldComp.off('add', this.onLayerAdded, this);
			oldComp.off('remove', this.onLayerRemoved, this);
			newComp.on('add', this.onLayerAdded, this);
			newComp.on('remove', this.onLayerRemoved, this);
		};
		_proto.onLayerAdded = function onLayerAdded(layer) {
			var index = this.layers.indexOf(layer.id);
			if (index < 0) return;
			layer.addMeshInstances(this.meshInstances);
		};
		_proto.onLayerRemoved = function onLayerRemoved(layer) {
			var index = this.layers.indexOf(layer.id);
			if (index < 0) return;
			layer.removeMeshInstances(this.meshInstances);
		};
		_proto._setMaterialEvent = function _setMaterialEvent(index, event, id, handler) {
			var evt = event + ':' + id;
			this.system.app.assets.on(evt, handler, this);
			if (!this._materialEvents) this._materialEvents = [];
			if (!this._materialEvents[index]) this._materialEvents[index] = {};
			this._materialEvents[index][evt] = {
				id: id,
				handler: handler
			};
		};
		_proto._unsetMaterialEvents = function _unsetMaterialEvents() {
			var assets = this.system.app.assets;
			var events = this._materialEvents;
			if (!events) return;
			for (var i = 0, len = events.length; i < len; i++) {
				if (!events[i]) continue;
				var evt = events[i];
				for (var key in evt) {
					assets.off(key, evt[key].handler, this);
				}
			}
			this._materialEvents = null;
		};
		_proto._getAssetByIdOrPath = function _getAssetByIdOrPath(idOrPath) {
			var asset = null;
			var isPath = isNaN(parseInt(idOrPath, 10));
			if (!isPath) {
				asset = this.system.app.assets.get(idOrPath);
			} else if (this.asset) {
				var url = this._getMaterialAssetUrl(idOrPath);
				if (url) asset = this.system.app.assets.getByUrl(url);
			}
			return asset;
		};
		_proto._getMaterialAssetUrl = function _getMaterialAssetUrl(path) {
			if (!this.asset) return null;
			var modelAsset = this.system.app.assets.get(this.asset);
			return modelAsset ? modelAsset.getAbsoluteUrl(path) : null;
		};
		_proto._loadAndSetMeshInstanceMaterial = function _loadAndSetMeshInstanceMaterial(materialAsset, meshInstance, index) {
			var assets = this.system.app.assets;
			if (!materialAsset) return;
			if (materialAsset.resource) {
				meshInstance.material = materialAsset.resource;
				this._setMaterialEvent(index, 'remove', materialAsset.id, function () {
					meshInstance.material = this.system.defaultMaterial;
				});
			} else {
				this._setMaterialEvent(index, 'load', materialAsset.id, function (asset) {
					meshInstance.material = asset.resource;
					this._setMaterialEvent(index, 'remove', materialAsset.id, function () {
						meshInstance.material = this.system.defaultMaterial;
					});
				});
				if (this.enabled && this.entity.enabled) assets.load(materialAsset);
			}
		};
		_proto.onEnable = function onEnable() {
			var app = this.system.app;
			var scene = app.scene;
			scene.on('set:layers', this.onLayersChanged, this);
			if (scene.layers) {
				scene.layers.on('add', this.onLayerAdded, this);
				scene.layers.on('remove', this.onLayerRemoved, this);
			}
			var isAsset = this._type === 'asset';
			var asset;
			if (this._model) {
				this.addModelToLayers();
			} else if (isAsset && this._asset) {
				asset = app.assets.get(this._asset);
				if (asset && asset.resource !== this._model) {
					this._bindModelAsset(asset);
				}
			}
			if (this._materialAsset) {
				asset = app.assets.get(this._materialAsset);
				if (asset && asset.resource !== this._material) {
					this._bindMaterialAsset(asset);
				}
			}
			if (isAsset) {
				if (this._mapping) {
					for (var index in this._mapping) {
						if (this._mapping[index]) {
							asset = this._getAssetByIdOrPath(this._mapping[index]);
							if (asset && !asset.resource) {
								app.assets.load(asset);
							}
						}
					}
				}
			}
			if (this._batchGroupId >= 0) {
				var _app$batcher;
				(_app$batcher = app.batcher) == null || _app$batcher.insert(BatchGroup.MODEL, this.batchGroupId, this.entity);
			}
		};
		_proto.onDisable = function onDisable() {
			var app = this.system.app;
			var scene = app.scene;
			scene.off('set:layers', this.onLayersChanged, this);
			if (scene.layers) {
				scene.layers.off('add', this.onLayerAdded, this);
				scene.layers.off('remove', this.onLayerRemoved, this);
			}
			if (this._batchGroupId >= 0) {
				var _app$batcher2;
				(_app$batcher2 = app.batcher) == null || _app$batcher2.remove(BatchGroup.MODEL, this.batchGroupId, this.entity);
			}
			if (this._model) {
				this.removeModelFromLayers();
			}
		};
		_proto.hide = function hide() {
			if (this._model) {
				var instances = this._model.meshInstances;
				for (var i = 0, l = instances.length; i < l; i++) {
					instances[i].visible = false;
				}
			}
		};
		_proto.show = function show() {
			if (this._model) {
				var instances = this._model.meshInstances;
				for (var i = 0, l = instances.length; i < l; i++) {
					instances[i].visible = true;
				}
			}
		};
		_proto._bindMaterialAsset = function _bindMaterialAsset(asset) {
			asset.on('load', this._onMaterialAssetLoad, this);
			asset.on('unload', this._onMaterialAssetUnload, this);
			asset.on('remove', this._onMaterialAssetRemove, this);
			asset.on('change', this._onMaterialAssetChange, this);
			if (asset.resource) {
				this._onMaterialAssetLoad(asset);
			} else {
				if (!this.enabled || !this.entity.enabled) return;
				this.system.app.assets.load(asset);
			}
		};
		_proto._unbindMaterialAsset = function _unbindMaterialAsset(asset) {
			asset.off('load', this._onMaterialAssetLoad, this);
			asset.off('unload', this._onMaterialAssetUnload, this);
			asset.off('remove', this._onMaterialAssetRemove, this);
			asset.off('change', this._onMaterialAssetChange, this);
		};
		_proto._onMaterialAssetAdd = function _onMaterialAssetAdd(asset) {
			this.system.app.assets.off('add:' + asset.id, this._onMaterialAssetAdd, this);
			if (this._materialAsset === asset.id) {
				this._bindMaterialAsset(asset);
			}
		};
		_proto._onMaterialAssetLoad = function _onMaterialAssetLoad(asset) {
			this._setMaterial(asset.resource);
		};
		_proto._onMaterialAssetUnload = function _onMaterialAssetUnload(asset) {
			this._setMaterial(this.system.defaultMaterial);
		};
		_proto._onMaterialAssetRemove = function _onMaterialAssetRemove(asset) {
			this._onMaterialAssetUnload(asset);
		};
		_proto._onMaterialAssetChange = function _onMaterialAssetChange(asset) {};
		_proto._bindModelAsset = function _bindModelAsset(asset) {
			this._unbindModelAsset(asset);
			asset.on('load', this._onModelAssetLoad, this);
			asset.on('unload', this._onModelAssetUnload, this);
			asset.on('change', this._onModelAssetChange, this);
			asset.on('remove', this._onModelAssetRemove, this);
			if (asset.resource) {
				this._onModelAssetLoad(asset);
			} else {
				if (!this.enabled || !this.entity.enabled) return;
				this.system.app.assets.load(asset);
			}
		};
		_proto._unbindModelAsset = function _unbindModelAsset(asset) {
			asset.off('load', this._onModelAssetLoad, this);
			asset.off('unload', this._onModelAssetUnload, this);
			asset.off('change', this._onModelAssetChange, this);
			asset.off('remove', this._onModelAssetRemove, this);
		};
		_proto._onModelAssetAdded = function _onModelAssetAdded(asset) {
			this.system.app.assets.off('add:' + asset.id, this._onModelAssetAdded, this);
			if (asset.id === this._asset) {
				this._bindModelAsset(asset);
			}
		};
		_proto._onModelAssetLoad = function _onModelAssetLoad(asset) {
			this.model = asset.resource.clone();
			this._clonedModel = true;
		};
		_proto._onModelAssetUnload = function _onModelAssetUnload(asset) {
			this.model = null;
		};
		_proto._onModelAssetChange = function _onModelAssetChange(asset, attr, _new, _old) {
			if (attr === 'data') {
				this.mapping = this._mapping;
			}
		};
		_proto._onModelAssetRemove = function _onModelAssetRemove(asset) {
			this.model = null;
		};
		_proto._setMaterial = function _setMaterial(material) {
			if (this._material === material) return;
			this._material = material;
			var model = this._model;
			if (model && this._type !== 'asset') {
				var meshInstances = model.meshInstances;
				for (var i = 0, len = meshInstances.length; i < len; i++) {
					meshInstances[i].material = material;
				}
			}
		};
		_createClass(ModelComponent, [{
			key: "meshInstances",
			get: function get() {
				if (!this._model) return null;
				return this._model.meshInstances;
			},
			set: function set(value) {
				if (!this._model) return;
				this._model.meshInstances = value;
			}
		}, {
			key: "customAabb",
			get: function get() {
				return this._customAabb;
			},
			set: function set(value) {
				this._customAabb = value;
				if (this._model) {
					var mi = this._model.meshInstances;
					if (mi) {
						for (var i = 0; i < mi.length; i++) {
							mi[i].setCustomAabb(this._customAabb);
						}
					}
				}
			}
		}, {
			key: "type",
			get: function get() {
				return this._type;
			},
			set: function set(value) {
				if (this._type === value) return;
				this._area = null;
				this._type = value;
				if (value === 'asset') {
					if (this._asset !== null) {
						this._bindModelAsset(this._asset);
					} else {
						this.model = null;
					}
				} else {
					var primData = getShapePrimitive(this.system.app.graphicsDevice, value);
					this._area = primData.area;
					var mesh = primData.mesh;
					var node = new GraphNode();
					var model = new Model();
					model.graph = node;
					model.meshInstances = [new MeshInstance(mesh, this._material, node)];
					this.model = model;
					this._asset = null;
				}
			}
		}, {
			key: "asset",
			get: function get() {
				return this._asset;
			},
			set: function set(value) {
				var assets = this.system.app.assets;
				var _id = value;
				if (value instanceof Asset) {
					_id = value.id;
				}
				if (this._asset !== _id) {
					if (this._asset) {
						assets.off('add:' + this._asset, this._onModelAssetAdded, this);
						var _prev = assets.get(this._asset);
						if (_prev) {
							this._unbindModelAsset(_prev);
						}
					}
					this._asset = _id;
					if (this._asset) {
						var asset = assets.get(this._asset);
						if (!asset) {
							this.model = null;
							assets.on('add:' + this._asset, this._onModelAssetAdded, this);
						} else {
							this._bindModelAsset(asset);
						}
					} else {
						this.model = null;
					}
				}
			}
		}, {
			key: "model",
			get: function get() {
				return this._model;
			},
			set: function set(value) {
				if (this._model === value) return;
				if (value && value._immutable) {
					return;
				}
				if (this._model) {
					this._model._immutable = false;
					this.removeModelFromLayers();
					this._model.getGraph().destroy();
					delete this._model._entity;
					if (this._clonedModel) {
						this._model.destroy();
						this._clonedModel = false;
					}
				}
				this._model = value;
				if (this._model) {
					this._model._immutable = true;
					var meshInstances = this._model.meshInstances;
					for (var i = 0; i < meshInstances.length; i++) {
						meshInstances[i].castShadow = this._castShadows;
						meshInstances[i].receiveShadow = this._receiveShadows;
						meshInstances[i].setCustomAabb(this._customAabb);
					}
					this.lightmapped = this._lightmapped;
					this.entity.addChild(this._model.graph);
					if (this.enabled && this.entity.enabled) {
						this.addModelToLayers();
					}
					this._model._entity = this.entity;
					if (this.entity.animation) this.entity.animation.setModel(this._model);
					if (this.entity.anim) {
						this.entity.anim.rebind();
					}
					if (this.type === 'asset') {
						this.mapping = this._mapping;
					} else {
						this._unsetMaterialEvents();
					}
				}
			}
		}, {
			key: "lightmapped",
			get: function get() {
				return this._lightmapped;
			},
			set: function set(value) {
				if (value !== this._lightmapped) {
					this._lightmapped = value;
					if (this._model) {
						var mi = this._model.meshInstances;
						for (var i = 0; i < mi.length; i++) {
							mi[i].setLightmapped(value);
						}
					}
				}
			}
		}, {
			key: "castShadows",
			get: function get() {
				return this._castShadows;
			},
			set: function set(value) {
				if (this._castShadows === value) return;
				var model = this._model;
				if (model) {
					var layers = this.layers;
					var scene = this.system.app.scene;
					if (this._castShadows && !value) {
						for (var i = 0; i < layers.length; i++) {
							var layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
							if (!layer) continue;
							layer.removeShadowCasters(model.meshInstances);
						}
					}
					var meshInstances = model.meshInstances;
					for (var _i = 0; _i < meshInstances.length; _i++) {
						meshInstances[_i].castShadow = value;
					}
					if (!this._castShadows && value) {
						for (var _i2 = 0; _i2 < layers.length; _i2++) {
							var _layer = scene.layers.getLayerById(layers[_i2]);
							if (!_layer) continue;
							_layer.addShadowCasters(model.meshInstances);
						}
					}
				}
				this._castShadows = value;
			}
		}, {
			key: "receiveShadows",
			get: function get() {
				return this._receiveShadows;
			},
			set: function set(value) {
				if (this._receiveShadows === value) return;
				this._receiveShadows = value;
				if (this._model) {
					var meshInstances = this._model.meshInstances;
					for (var i = 0, len = meshInstances.length; i < len; i++) {
						meshInstances[i].receiveShadow = value;
					}
				}
			}
		}, {
			key: "castShadowsLightmap",
			get: function get() {
				return this._castShadowsLightmap;
			},
			set: function set(value) {
				this._castShadowsLightmap = value;
			}
		}, {
			key: "lightmapSizeMultiplier",
			get: function get() {
				return this._lightmapSizeMultiplier;
			},
			set: function set(value) {
				this._lightmapSizeMultiplier = value;
			}
		}, {
			key: "layers",
			get: function get() {
				return this._layers;
			},
			set: function set(value) {
				var layers = this.system.app.scene.layers;
				if (this.meshInstances) {
					for (var i = 0; i < this._layers.length; i++) {
						var layer = layers.getLayerById(this._layers[i]);
						if (!layer) continue;
						layer.removeMeshInstances(this.meshInstances);
					}
				}
				this._layers.length = 0;
				for (var _i3 = 0; _i3 < value.length; _i3++) {
					this._layers[_i3] = value[_i3];
				}
				if (!this.enabled || !this.entity.enabled || !this.meshInstances) return;
				for (var _i4 = 0; _i4 < this._layers.length; _i4++) {
					var _layer2 = layers.getLayerById(this._layers[_i4]);
					if (!_layer2) continue;
					_layer2.addMeshInstances(this.meshInstances);
				}
			}
		}, {
			key: "batchGroupId",
			get: function get() {
				return this._batchGroupId;
			},
			set: function set(value) {
				if (this._batchGroupId === value) return;
				if (this.entity.enabled && this._batchGroupId >= 0) {
					var _this$system$app$batc;
					(_this$system$app$batc = this.system.app.batcher) == null || _this$system$app$batc.remove(BatchGroup.MODEL, this.batchGroupId, this.entity);
				}
				if (this.entity.enabled && value >= 0) {
					var _this$system$app$batc2;
					(_this$system$app$batc2 = this.system.app.batcher) == null || _this$system$app$batc2.insert(BatchGroup.MODEL, value, this.entity);
				}
				if (value < 0 && this._batchGroupId >= 0 && this.enabled && this.entity.enabled) {
					this.addModelToLayers();
				}
				this._batchGroupId = value;
			}
		}, {
			key: "materialAsset",
			get: function get() {
				return this._materialAsset;
			},
			set: function set(value) {
				var _id = value;
				if (value instanceof Asset) {
					_id = value.id;
				}
				var assets = this.system.app.assets;
				if (_id !== this._materialAsset) {
					if (this._materialAsset) {
						assets.off('add:' + this._materialAsset, this._onMaterialAssetAdd, this);
						var _prev = assets.get(this._materialAsset);
						if (_prev) {
							this._unbindMaterialAsset(_prev);
						}
					}
					this._materialAsset = _id;
					if (this._materialAsset) {
						var asset = assets.get(this._materialAsset);
						if (!asset) {
							this._setMaterial(this.system.defaultMaterial);
							assets.on('add:' + this._materialAsset, this._onMaterialAssetAdd, this);
						} else {
							this._bindMaterialAsset(asset);
						}
					} else {
						this._setMaterial(this.system.defaultMaterial);
					}
				}
			}
		}, {
			key: "material",
			get: function get() {
				return this._material;
			},
			set: function set(value) {
				if (this._material === value) return;
				this.materialAsset = null;
				this._setMaterial(value);
			}
		}, {
			key: "mapping",
			get: function get() {
				return this._mapping;
			},
			set: function set(value) {
				if (this._type !== 'asset') return;
				this._unsetMaterialEvents();
				if (!value) value = {};
				this._mapping = value;
				if (!this._model) return;
				var meshInstances = this._model.meshInstances;
				var modelAsset = this.asset ? this.system.app.assets.get(this.asset) : null;
				var assetMapping = modelAsset ? modelAsset.data.mapping : null;
				var asset = null;
				for (var i = 0, len = meshInstances.length; i < len; i++) {
					if (value[i] !== undefined) {
						if (value[i]) {
							asset = this.system.app.assets.get(value[i]);
							this._loadAndSetMeshInstanceMaterial(asset, meshInstances[i], i);
						} else {
							meshInstances[i].material = this.system.defaultMaterial;
						}
					} else if (assetMapping) {
						if (assetMapping[i] && (assetMapping[i].material || assetMapping[i].path)) {
							if (assetMapping[i].material !== undefined) {
								asset = this.system.app.assets.get(assetMapping[i].material);
							} else if (assetMapping[i].path !== undefined) {
								var url = this._getMaterialAssetUrl(assetMapping[i].path);
								if (url) {
									asset = this.system.app.assets.getByUrl(url);
								}
							}
							this._loadAndSetMeshInstanceMaterial(asset, meshInstances[i], i);
						} else {
							meshInstances[i].material = this.system.defaultMaterial;
						}
					}
				}
			}
		}]);
		return ModelComponent;
	}(Component);

	var ModelComponentData = function ModelComponentData() {
		this.enabled = true;
	};

	var _schema$b = ['enabled'];
	var ModelComponentSystem = function (_ComponentSystem) {
		_inheritsLoose(ModelComponentSystem, _ComponentSystem);
		function ModelComponentSystem(app) {
			var _this;
			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'model';
			_this.ComponentType = ModelComponent;
			_this.DataType = ModelComponentData;
			_this.schema = _schema$b;
			_this.defaultMaterial = getDefaultMaterial(app.graphicsDevice);
			_this.on('beforeremove', _this.onRemove, _assertThisInitialized(_this));
			return _this;
		}
		var _proto = ModelComponentSystem.prototype;
		_proto.initializeComponentData = function initializeComponentData(component, _data, properties) {
			properties = ['material', 'materialAsset', 'asset', 'castShadows', 'receiveShadows', 'castShadowsLightmap', 'lightmapped', 'lightmapSizeMultiplier', 'type', 'mapping', 'layers', 'isStatic', 'batchGroupId'];
			if (_data.batchGroupId === null || _data.batchGroupId === undefined) {
				_data.batchGroupId = -1;
			}
			if (_data.layers && _data.layers.length) {
				_data.layers = _data.layers.slice(0);
			}
			for (var i = 0; i < properties.length; i++) {
				if (_data.hasOwnProperty(properties[i])) {
					component[properties[i]] = _data[properties[i]];
				}
			}
			if (_data.aabbCenter && _data.aabbHalfExtents) {
				component.customAabb = new BoundingBox(new Vec3(_data.aabbCenter), new Vec3(_data.aabbHalfExtents));
			}
			_ComponentSystem.prototype.initializeComponentData.call(this, component, _data, ['enabled']);
		};
		_proto.cloneComponent = function cloneComponent(entity, clone) {
			var data = {
				type: entity.model.type,
				asset: entity.model.asset,
				castShadows: entity.model.castShadows,
				receiveShadows: entity.model.receiveShadows,
				castShadowsLightmap: entity.model.castShadowsLightmap,
				lightmapped: entity.model.lightmapped,
				lightmapSizeMultiplier: entity.model.lightmapSizeMultiplier,
				isStatic: entity.model.isStatic,
				enabled: entity.model.enabled,
				layers: entity.model.layers,
				batchGroupId: entity.model.batchGroupId,
				mapping: extend({}, entity.model.mapping)
			};
			var materialAsset = entity.model.materialAsset;
			if (!(materialAsset instanceof Asset) && materialAsset != null) {
				materialAsset = this.app.assets.get(materialAsset);
			}
			var material = entity.model.material;
			if (!material || material === this.defaultMaterial || !materialAsset || material === materialAsset.resource) {
				data.materialAsset = materialAsset;
			}
			var component = this.addComponent(clone, data);
			if (entity.model.model && entity.model.type === 'asset' && !entity.model.asset) {
				component.model = entity.model.model.clone();
				component._clonedModel = true;
			}
			if (!data.materialAsset) component.material = material;
			if (entity.model.model) {
				var meshInstances = entity.model.model.meshInstances;
				var meshInstancesClone = component.model.meshInstances;
				for (var i = 0; i < meshInstances.length; i++) {
					meshInstancesClone[i].mask = meshInstances[i].mask;
					meshInstancesClone[i].material = meshInstances[i].material;
					meshInstancesClone[i].layer = meshInstances[i].layer;
					meshInstancesClone[i].receiveShadow = meshInstances[i].receiveShadow;
				}
			}
			if (entity.model.customAabb) {
				component.customAabb = entity.model.customAabb.clone();
			}
			return component;
		};
		_proto.onRemove = function onRemove(entity, component) {
			component.onRemove();
		};
		return ModelComponentSystem;
	}(ComponentSystem);
	Component._buildAccessors(ModelComponent.prototype, _schema$b);

	var SIMPLE_PROPERTIES = ['emitterExtents', 'emitterRadius', 'emitterExtentsInner', 'emitterRadiusInner', 'loop', 'initialVelocity', 'animSpeed', 'normalMap', 'particleNormal'];
	var COMPLEX_PROPERTIES = ['numParticles', 'lifetime', 'rate', 'rate2', 'startAngle', 'startAngle2', 'lighting', 'halfLambert', 'intensity', 'wrap', 'wrapBounds', 'depthWrite', 'noFog', 'sort', 'stretch', 'alignToMotion', 'preWarm', 'emitterShape', 'animTilesX', 'animTilesY', 'animStartFrame', 'animNumFrames', 'animNumAnimations', 'animIndex', 'randomizeAnimIndex', 'animLoop', 'colorMap', 'localSpace', 'screenSpace', 'orientation'];
	var GRAPH_PROPERTIES = ['scaleGraph', 'scaleGraph2', 'colorGraph', 'colorGraph2', 'alphaGraph', 'alphaGraph2', 'velocityGraph', 'velocityGraph2', 'localVelocityGraph', 'localVelocityGraph2', 'rotationSpeedGraph', 'rotationSpeedGraph2', 'radialSpeedGraph', 'radialSpeedGraph2'];
	var ASSET_PROPERTIES = ['colorMapAsset', 'normalMapAsset', 'meshAsset', 'renderAsset'];
	var depthLayer;
	var ParticleSystemComponent = function (_Component) {
		_inheritsLoose(ParticleSystemComponent, _Component);
		function ParticleSystemComponent(system, entity) {
			var _this;
			_this = _Component.call(this, system, entity) || this;
			_this._requestedDepth = false;
			_this._drawOrder = 0;
			_this.on('set_colorMapAsset', _this.onSetColorMapAsset, _assertThisInitialized(_this));
			_this.on('set_normalMapAsset', _this.onSetNormalMapAsset, _assertThisInitialized(_this));
			_this.on('set_meshAsset', _this.onSetMeshAsset, _assertThisInitialized(_this));
			_this.on('set_mesh', _this.onSetMesh, _assertThisInitialized(_this));
			_this.on('set_renderAsset', _this.onSetRenderAsset, _assertThisInitialized(_this));
			_this.on('set_loop', _this.onSetLoop, _assertThisInitialized(_this));
			_this.on('set_blendType', _this.onSetBlendType, _assertThisInitialized(_this));
			_this.on('set_depthSoftening', _this.onSetDepthSoftening, _assertThisInitialized(_this));
			_this.on('set_layers', _this.onSetLayers, _assertThisInitialized(_this));
			SIMPLE_PROPERTIES.forEach(function (prop) {
				_this.on("set_" + prop, _this.onSetSimpleProperty, _assertThisInitialized(_this));
			});
			COMPLEX_PROPERTIES.forEach(function (prop) {
				_this.on("set_" + prop, _this.onSetComplexProperty, _assertThisInitialized(_this));
			});
			GRAPH_PROPERTIES.forEach(function (prop) {
				_this.on("set_" + prop, _this.onSetGraphProperty, _assertThisInitialized(_this));
			});
			return _this;
		}
		var _proto = ParticleSystemComponent.prototype;
		_proto.addMeshInstanceToLayers = function addMeshInstanceToLayers() {
			if (!this.emitter) return;
			for (var i = 0; i < this.layers.length; i++) {
				var layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
				if (!layer) continue;
				layer.addMeshInstances([this.emitter.meshInstance]);
				this.emitter._layer = layer;
			}
		};
		_proto.removeMeshInstanceFromLayers = function removeMeshInstanceFromLayers() {
			if (!this.emitter) return;
			for (var i = 0; i < this.layers.length; i++) {
				var layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
				if (!layer) continue;
				layer.removeMeshInstances([this.emitter.meshInstance]);
			}
		};
		_proto.onSetLayers = function onSetLayers(name, oldValue, newValue) {
			if (!this.emitter) return;
			for (var i = 0; i < oldValue.length; i++) {
				var layer = this.system.app.scene.layers.getLayerById(oldValue[i]);
				if (!layer) continue;
				layer.removeMeshInstances([this.emitter.meshInstance]);
			}
			if (!this.enabled || !this.entity.enabled) return;
			for (var _i = 0; _i < newValue.length; _i++) {
				var _layer = this.system.app.scene.layers.getLayerById(newValue[_i]);
				if (!_layer) continue;
				_layer.addMeshInstances([this.emitter.meshInstance]);
			}
		};
		_proto.onLayersChanged = function onLayersChanged(oldComp, newComp) {
			this.addMeshInstanceToLayers();
			oldComp.off('add', this.onLayerAdded, this);
			oldComp.off('remove', this.onLayerRemoved, this);
			newComp.on('add', this.onLayerAdded, this);
			newComp.on('remove', this.onLayerRemoved, this);
		};
		_proto.onLayerAdded = function onLayerAdded(layer) {
			if (!this.emitter) return;
			var index = this.layers.indexOf(layer.id);
			if (index < 0) return;
			layer.addMeshInstances([this.emitter.meshInstance]);
		};
		_proto.onLayerRemoved = function onLayerRemoved(layer) {
			if (!this.emitter) return;
			var index = this.layers.indexOf(layer.id);
			if (index < 0) return;
			layer.removeMeshInstances([this.emitter.meshInstance]);
		};
		_proto._bindColorMapAsset = function _bindColorMapAsset(asset) {
			asset.on('load', this._onColorMapAssetLoad, this);
			asset.on('unload', this._onColorMapAssetUnload, this);
			asset.on('remove', this._onColorMapAssetRemove, this);
			asset.on('change', this._onColorMapAssetChange, this);
			if (asset.resource) {
				this._onColorMapAssetLoad(asset);
			} else {
				if (!this.enabled || !this.entity.enabled) return;
				this.system.app.assets.load(asset);
			}
		};
		_proto._unbindColorMapAsset = function _unbindColorMapAsset(asset) {
			asset.off('load', this._onColorMapAssetLoad, this);
			asset.off('unload', this._onColorMapAssetUnload, this);
			asset.off('remove', this._onColorMapAssetRemove, this);
			asset.off('change', this._onColorMapAssetChange, this);
		};
		_proto._onColorMapAssetLoad = function _onColorMapAssetLoad(asset) {
			this.colorMap = asset.resource;
		};
		_proto._onColorMapAssetUnload = function _onColorMapAssetUnload(asset) {
			this.colorMap = null;
		};
		_proto._onColorMapAssetRemove = function _onColorMapAssetRemove(asset) {
			this._onColorMapAssetUnload(asset);
		};
		_proto._onColorMapAssetChange = function _onColorMapAssetChange(asset) {};
		_proto.onSetColorMapAsset = function onSetColorMapAsset(name, oldValue, newValue) {
			var _this2 = this;
			var assets = this.system.app.assets;
			if (oldValue) {
				var asset = assets.get(oldValue);
				if (asset) {
					this._unbindColorMapAsset(asset);
				}
			}
			if (newValue) {
				if (newValue instanceof Asset) {
					this.data.colorMapAsset = newValue.id;
					newValue = newValue.id;
				}
				var _asset = assets.get(newValue);
				if (_asset) {
					this._bindColorMapAsset(_asset);
				} else {
					assets.once('add:' + newValue, function (asset) {
						_this2._bindColorMapAsset(asset);
					});
				}
			} else {
				this.colorMap = null;
			}
		};
		_proto._bindNormalMapAsset = function _bindNormalMapAsset(asset) {
			asset.on('load', this._onNormalMapAssetLoad, this);
			asset.on('unload', this._onNormalMapAssetUnload, this);
			asset.on('remove', this._onNormalMapAssetRemove, this);
			asset.on('change', this._onNormalMapAssetChange, this);
			if (asset.resource) {
				this._onNormalMapAssetLoad(asset);
			} else {
				if (!this.enabled || !this.entity.enabled) return;
				this.system.app.assets.load(asset);
			}
		};
		_proto._unbindNormalMapAsset = function _unbindNormalMapAsset(asset) {
			asset.off('load', this._onNormalMapAssetLoad, this);
			asset.off('unload', this._onNormalMapAssetUnload, this);
			asset.off('remove', this._onNormalMapAssetRemove, this);
			asset.off('change', this._onNormalMapAssetChange, this);
		};
		_proto._onNormalMapAssetLoad = function _onNormalMapAssetLoad(asset) {
			this.normalMap = asset.resource;
		};
		_proto._onNormalMapAssetUnload = function _onNormalMapAssetUnload(asset) {
			this.normalMap = null;
		};
		_proto._onNormalMapAssetRemove = function _onNormalMapAssetRemove(asset) {
			this._onNormalMapAssetUnload(asset);
		};
		_proto._onNormalMapAssetChange = function _onNormalMapAssetChange(asset) {};
		_proto.onSetNormalMapAsset = function onSetNormalMapAsset(name, oldValue, newValue) {
			var _this3 = this;
			var assets = this.system.app.assets;
			if (oldValue) {
				var asset = assets.get(oldValue);
				if (asset) {
					this._unbindNormalMapAsset(asset);
				}
			}
			if (newValue) {
				if (newValue instanceof Asset) {
					this.data.normalMapAsset = newValue.id;
					newValue = newValue.id;
				}
				var _asset2 = assets.get(newValue);
				if (_asset2) {
					this._bindNormalMapAsset(_asset2);
				} else {
					assets.once('add:' + newValue, function (asset) {
						_this3._bindNormalMapAsset(asset);
					});
				}
			} else {
				this.normalMap = null;
			}
		};
		_proto._bindMeshAsset = function _bindMeshAsset(asset) {
			asset.on('load', this._onMeshAssetLoad, this);
			asset.on('unload', this._onMeshAssetUnload, this);
			asset.on('remove', this._onMeshAssetRemove, this);
			asset.on('change', this._onMeshAssetChange, this);
			if (asset.resource) {
				this._onMeshAssetLoad(asset);
			} else {
				if (!this.enabled || !this.entity.enabled) return;
				this.system.app.assets.load(asset);
			}
		};
		_proto._unbindMeshAsset = function _unbindMeshAsset(asset) {
			asset.off('load', this._onMeshAssetLoad, this);
			asset.off('unload', this._onMeshAssetUnload, this);
			asset.off('remove', this._onMeshAssetRemove, this);
			asset.off('change', this._onMeshAssetChange, this);
		};
		_proto._onMeshAssetLoad = function _onMeshAssetLoad(asset) {
			this._onMeshChanged(asset.resource);
		};
		_proto._onMeshAssetUnload = function _onMeshAssetUnload(asset) {
			this.mesh = null;
		};
		_proto._onMeshAssetRemove = function _onMeshAssetRemove(asset) {
			this._onMeshAssetUnload(asset);
		};
		_proto._onMeshAssetChange = function _onMeshAssetChange(asset) {};
		_proto.onSetMeshAsset = function onSetMeshAsset(name, oldValue, newValue) {
			var assets = this.system.app.assets;
			if (oldValue) {
				var asset = assets.get(oldValue);
				if (asset) {
					this._unbindMeshAsset(asset);
				}
			}
			if (newValue) {
				if (newValue instanceof Asset) {
					this.data.meshAsset = newValue.id;
					newValue = newValue.id;
				}
				var _asset3 = assets.get(newValue);
				if (_asset3) {
					this._bindMeshAsset(_asset3);
				}
			} else {
				this._onMeshChanged(null);
			}
		};
		_proto.onSetMesh = function onSetMesh(name, oldValue, newValue) {
			if (!newValue || newValue instanceof Asset || typeof newValue === 'number') {
				this.meshAsset = newValue;
			} else {
				this._onMeshChanged(newValue);
			}
		};
		_proto._onMeshChanged = function _onMeshChanged(mesh) {
			if (mesh && !(mesh instanceof Mesh)) {
				if (mesh.meshInstances[0]) {
					mesh = mesh.meshInstances[0].mesh;
				} else {
					mesh = null;
				}
			}
			this.data.mesh = mesh;
			if (this.emitter) {
				this.emitter.mesh = mesh;
				this.emitter.resetMaterial();
				this.rebuild();
			}
		};
		_proto.onSetRenderAsset = function onSetRenderAsset(name, oldValue, newValue) {
			var assets = this.system.app.assets;
			if (oldValue) {
				var asset = assets.get(oldValue);
				if (asset) {
					this._unbindRenderAsset(asset);
				}
			}
			if (newValue) {
				if (newValue instanceof Asset) {
					this.data.renderAsset = newValue.id;
					newValue = newValue.id;
				}
				var _asset4 = assets.get(newValue);
				if (_asset4) {
					this._bindRenderAsset(_asset4);
				}
			} else {
				this._onRenderChanged(null);
			}
		};
		_proto._bindRenderAsset = function _bindRenderAsset(asset) {
			asset.on('load', this._onRenderAssetLoad, this);
			asset.on('unload', this._onRenderAssetUnload, this);
			asset.on('remove', this._onRenderAssetRemove, this);
			if (asset.resource) {
				this._onRenderAssetLoad(asset);
			} else {
				if (!this.enabled || !this.entity.enabled) return;
				this.system.app.assets.load(asset);
			}
		};
		_proto._unbindRenderAsset = function _unbindRenderAsset(asset) {
			asset.off('load', this._onRenderAssetLoad, this);
			asset.off('unload', this._onRenderAssetUnload, this);
			asset.off('remove', this._onRenderAssetRemove, this);
			if (asset.resource) {
				asset.resource.off('set:meshes', this._onRenderSetMeshes, this);
			}
		};
		_proto._onRenderAssetLoad = function _onRenderAssetLoad(asset) {
			this._onRenderChanged(asset.resource);
		};
		_proto._onRenderAssetUnload = function _onRenderAssetUnload(asset) {
			this._onRenderChanged(null);
		};
		_proto._onRenderAssetRemove = function _onRenderAssetRemove(asset) {
			this._onRenderAssetUnload(asset);
		};
		_proto._onRenderChanged = function _onRenderChanged(render) {
			if (!render) {
				this._onMeshChanged(null);
				return;
			}
			render.off('set:meshes', this._onRenderSetMeshes, this);
			render.on('set:meshes', this._onRenderSetMeshes, this);
			if (render.meshes) {
				this._onRenderSetMeshes(render.meshes);
			}
		};
		_proto._onRenderSetMeshes = function _onRenderSetMeshes(meshes) {
			this._onMeshChanged(meshes && meshes[0]);
		};
		_proto.onSetLoop = function onSetLoop(name, oldValue, newValue) {
			if (this.emitter) {
				this.emitter[name] = newValue;
				this.emitter.resetTime();
			}
		};
		_proto.onSetBlendType = function onSetBlendType(name, oldValue, newValue) {
			if (this.emitter) {
				this.emitter[name] = newValue;
				this.emitter.material.blendType = newValue;
				this.emitter.resetMaterial();
				this.rebuild();
			}
		};
		_proto._requestDepth = function _requestDepth() {
			if (this._requestedDepth) return;
			if (!depthLayer) depthLayer = this.system.app.scene.layers.getLayerById(LAYERID_DEPTH);
			if (depthLayer) {
				depthLayer.incrementCounter();
				this._requestedDepth = true;
			}
		};
		_proto._releaseDepth = function _releaseDepth() {
			if (!this._requestedDepth) return;
			if (depthLayer) {
				depthLayer.decrementCounter();
				this._requestedDepth = false;
			}
		};
		_proto.onSetDepthSoftening = function onSetDepthSoftening(name, oldValue, newValue) {
			if (oldValue !== newValue) {
				if (newValue) {
					if (this.enabled && this.entity.enabled) this._requestDepth();
					if (this.emitter) this.emitter[name] = newValue;
				} else {
					if (this.enabled && this.entity.enabled) this._releaseDepth();
					if (this.emitter) this.emitter[name] = newValue;
				}
				if (this.emitter) {
					this.reset();
					this.emitter.resetMaterial();
					this.rebuild();
				}
			}
		};
		_proto.onSetSimpleProperty = function onSetSimpleProperty(name, oldValue, newValue) {
			if (this.emitter) {
				this.emitter[name] = newValue;
				this.emitter.resetMaterial();
			}
		};
		_proto.onSetComplexProperty = function onSetComplexProperty(name, oldValue, newValue) {
			if (this.emitter) {
				this.emitter[name] = newValue;
				this.emitter.resetMaterial();
				this.rebuild();
				this.reset();
			}
		};
		_proto.onSetGraphProperty = function onSetGraphProperty(name, oldValue, newValue) {
			if (this.emitter) {
				this.emitter[name] = newValue;
				this.emitter.rebuildGraphs();
				this.emitter.resetMaterial();
			}
		};
		_proto.onEnable = function onEnable() {
			var data = this.data;
			for (var i = 0, len = ASSET_PROPERTIES.length; i < len; i++) {
				var asset = data[ASSET_PROPERTIES[i]];
				if (asset) {
					if (!(asset instanceof Asset)) {
						var id = parseInt(asset, 10);
						if (id >= 0) {
							asset = this.system.app.assets.get(asset);
						} else {
							continue;
						}
					}
					if (asset && !asset.resource) {
						this.system.app.assets.load(asset);
					}
				}
			}
			if (this.system.app.graphicsDevice.disableParticleSystem) {
				return;
			}
			if (!this.emitter) {
				var mesh = data.mesh;
				if (!(mesh instanceof Mesh)) mesh = null;
				this.emitter = new ParticleEmitter(this.system.app.graphicsDevice, {
					numParticles: data.numParticles,
					emitterExtents: data.emitterExtents,
					emitterExtentsInner: data.emitterExtentsInner,
					emitterRadius: data.emitterRadius,
					emitterRadiusInner: data.emitterRadiusInner,
					emitterShape: data.emitterShape,
					initialVelocity: data.initialVelocity,
					wrap: data.wrap,
					localSpace: data.localSpace,
					screenSpace: data.screenSpace,
					wrapBounds: data.wrapBounds,
					lifetime: data.lifetime,
					rate: data.rate,
					rate2: data.rate2,
					orientation: data.orientation,
					particleNormal: data.particleNormal,
					animTilesX: data.animTilesX,
					animTilesY: data.animTilesY,
					animStartFrame: data.animStartFrame,
					animNumFrames: data.animNumFrames,
					animNumAnimations: data.animNumAnimations,
					animIndex: data.animIndex,
					randomizeAnimIndex: data.randomizeAnimIndex,
					animSpeed: data.animSpeed,
					animLoop: data.animLoop,
					startAngle: data.startAngle,
					startAngle2: data.startAngle2,
					scaleGraph: data.scaleGraph,
					scaleGraph2: data.scaleGraph2,
					colorGraph: data.colorGraph,
					colorGraph2: data.colorGraph2,
					alphaGraph: data.alphaGraph,
					alphaGraph2: data.alphaGraph2,
					localVelocityGraph: data.localVelocityGraph,
					localVelocityGraph2: data.localVelocityGraph2,
					velocityGraph: data.velocityGraph,
					velocityGraph2: data.velocityGraph2,
					rotationSpeedGraph: data.rotationSpeedGraph,
					rotationSpeedGraph2: data.rotationSpeedGraph2,
					radialSpeedGraph: data.radialSpeedGraph,
					radialSpeedGraph2: data.radialSpeedGraph2,
					colorMap: data.colorMap,
					normalMap: data.normalMap,
					loop: data.loop,
					preWarm: data.preWarm,
					sort: data.sort,
					stretch: data.stretch,
					alignToMotion: data.alignToMotion,
					lighting: data.lighting,
					halfLambert: data.halfLambert,
					intensity: data.intensity,
					depthSoftening: data.depthSoftening,
					scene: this.system.app.scene,
					mesh: mesh,
					depthWrite: data.depthWrite,
					noFog: data.noFog,
					node: this.entity,
					blendType: data.blendType
				});
				this.emitter.meshInstance.node = this.entity;
				this.emitter.drawOrder = this.drawOrder;
				if (!data.autoPlay) {
					this.pause();
					this.emitter.meshInstance.visible = false;
				}
			}
			if (this.emitter.colorMap) {
				this.addMeshInstanceToLayers();
			}
			this.system.app.scene.on('set:layers', this.onLayersChanged, this);
			if (this.system.app.scene.layers) {
				this.system.app.scene.layers.on('add', this.onLayerAdded, this);
				this.system.app.scene.layers.on('remove', this.onLayerRemoved, this);
			}
			if (this.enabled && this.entity.enabled && data.depthSoftening) {
				this._requestDepth();
			}
		};
		_proto.onDisable = function onDisable() {
			this.system.app.scene.off('set:layers', this.onLayersChanged, this);
			if (this.system.app.scene.layers) {
				this.system.app.scene.layers.off('add', this.onLayerAdded, this);
				this.system.app.scene.layers.off('remove', this.onLayerRemoved, this);
			}
			if (this.emitter) {
				this.removeMeshInstanceFromLayers();
				if (this.data.depthSoftening) this._releaseDepth();
				this.emitter.camera = null;
			}
		};
		_proto.onBeforeRemove = function onBeforeRemove() {
			if (this.enabled) {
				this.enabled = false;
			}
			if (this.emitter) {
				this.emitter.destroy();
				this.emitter = null;
			}
			for (var i = 0; i < ASSET_PROPERTIES.length; i++) {
				var prop = ASSET_PROPERTIES[i];
				if (this.data[prop]) {
					this[prop] = null;
				}
			}
			this.off();
		};
		_proto.reset = function reset() {
			if (this.emitter) {
				this.emitter.reset();
			}
		};
		_proto.stop = function stop() {
			if (this.emitter) {
				this.emitter.loop = false;
				this.emitter.resetTime();
				this.emitter.addTime(0, true);
			}
		};
		_proto.pause = function pause() {
			this.data.paused = true;
		};
		_proto.unpause = function unpause() {
			this.data.paused = false;
		};
		_proto.play = function play() {
			this.data.paused = false;
			if (this.emitter) {
				this.emitter.meshInstance.visible = true;
				this.emitter.loop = this.data.loop;
				this.emitter.resetTime();
			}
		};
		_proto.isPlaying = function isPlaying() {
			if (this.data.paused) {
				return false;
			}
			if (this.emitter && this.emitter.loop) {
				return true;
			}
			return Date.now() <= this.emitter.endTime;
		};
		_proto.rebuild = function rebuild() {
			var enabled = this.enabled;
			this.enabled = false;
			if (this.emitter) {
				this.emitter.rebuild();
				this.emitter.meshInstance.node = this.entity;
			}
			this.enabled = enabled;
		};
		_createClass(ParticleSystemComponent, [{
			key: "drawOrder",
			get: function get() {
				return this._drawOrder;
			},
			set: function set(drawOrder) {
				this._drawOrder = drawOrder;
				if (this.emitter) {
					this.emitter.drawOrder = drawOrder;
				}
			}
		}]);
		return ParticleSystemComponent;
	}(Component);

	var ParticleSystemComponentData = function ParticleSystemComponentData() {
		this.numParticles = 1;
		this.rate = 1;
		this.rate2 = null;
		this.startAngle = 0;
		this.startAngle2 = null;
		this.lifetime = 50;
		this.emitterExtents = new Vec3();
		this.emitterExtentsInner = new Vec3();
		this.emitterRadius = 0;
		this.emitterRadiusInner = 0;
		this.emitterShape = EMITTERSHAPE_BOX;
		this.initialVelocity = 0;
		this.wrapBounds = new Vec3();
		this.localSpace = false;
		this.screenSpace = false;
		this.colorMap = null;
		this.colorMapAsset = null;
		this.normalMap = null;
		this.normalMapAsset = null;
		this.loop = true;
		this.preWarm = false;
		this.sort = 0;
		this.mode = PARTICLEMODE_GPU;
		this.scene = null;
		this.lighting = false;
		this.halfLambert = false;
		this.intensity = 1;
		this.stretch = 0.0;
		this.alignToMotion = false;
		this.depthSoftening = 0;
		this.meshAsset = null;
		this.mesh = null;
		this.depthWrite = false;
		this.noFog = false;
		this.orientation = PARTICLEORIENTATION_SCREEN;
		this.particleNormal = new Vec3(0, 1, 0);
		this.animTilesX = 1;
		this.animTilesY = 1;
		this.animStartFrame = 0;
		this.animNumFrames = 1;
		this.animNumAnimations = 1;
		this.animIndex = 0;
		this.randomizeAnimIndex = false;
		this.animSpeed = 1;
		this.animLoop = true;
		this.scaleGraph = null;
		this.scaleGraph2 = null;
		this.colorGraph = null;
		this.colorGraph2 = null;
		this.alphaGraph = null;
		this.alphaGraph2 = null;
		this.localVelocityGraph = null;
		this.localVelocityGraph2 = null;
		this.velocityGraph = null;
		this.velocityGraph2 = null;
		this.rotationSpeedGraph = null;
		this.rotationSpeedGraph2 = null;
		this.radialSpeedGraph = null;
		this.radialSpeedGraph2 = null;
		this.blendType = BLEND_NORMAL;
		this.enabled = true;
		this.paused = false;
		this.autoPlay = true;
		this.layers = [LAYERID_WORLD];
	};

	var _schema$a = ['enabled', 'autoPlay', 'numParticles', 'lifetime', 'rate', 'rate2', 'startAngle', 'startAngle2', 'loop', 'preWarm', 'lighting', 'halfLambert', 'intensity', 'depthWrite', 'noFog', 'depthSoftening', 'sort', 'blendType', 'stretch', 'alignToMotion', 'emitterShape', 'emitterExtents', 'emitterExtentsInner', 'emitterRadius', 'emitterRadiusInner', 'initialVelocity', 'wrap', 'wrapBounds', 'localSpace', 'screenSpace', 'colorMapAsset', 'normalMapAsset', 'mesh', 'meshAsset', 'renderAsset', 'orientation', 'particleNormal', 'localVelocityGraph', 'localVelocityGraph2', 'velocityGraph', 'velocityGraph2', 'rotationSpeedGraph', 'rotationSpeedGraph2', 'radialSpeedGraph', 'radialSpeedGraph2', 'scaleGraph', 'scaleGraph2', 'colorGraph', 'colorGraph2', 'alphaGraph', 'alphaGraph2', 'colorMap', 'normalMap', 'animTilesX', 'animTilesY', 'animStartFrame', 'animNumFrames', 'animNumAnimations', 'animIndex', 'randomizeAnimIndex', 'animSpeed', 'animLoop', 'layers'];
	var ParticleSystemComponentSystem = function (_ComponentSystem) {
		_inheritsLoose(ParticleSystemComponentSystem, _ComponentSystem);
		function ParticleSystemComponentSystem(app) {
			var _this;
			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'particlesystem';
			_this.ComponentType = ParticleSystemComponent;
			_this.DataType = ParticleSystemComponentData;
			_this.schema = _schema$a;
			_this.propertyTypes = {
				emitterExtents: 'vec3',
				emitterExtentsInner: 'vec3',
				particleNormal: 'vec3',
				wrapBounds: 'vec3',
				localVelocityGraph: 'curveset',
				localVelocityGraph2: 'curveset',
				velocityGraph: 'curveset',
				velocityGraph2: 'curveset',
				colorGraph: 'curveset',
				colorGraph2: 'curveset',
				alphaGraph: 'curve',
				alphaGraph2: 'curve',
				rotationSpeedGraph: 'curve',
				rotationSpeedGraph2: 'curve',
				radialSpeedGraph: 'curve',
				radialSpeedGraph2: 'curve',
				scaleGraph: 'curve',
				scaleGraph2: 'curve'
			};
			_this.on('beforeremove', _this.onBeforeRemove, _assertThisInitialized(_this));
			_this.app.systems.on('update', _this.onUpdate, _assertThisInitialized(_this));
			return _this;
		}
		var _proto = ParticleSystemComponentSystem.prototype;
		_proto.initializeComponentData = function initializeComponentData(component, _data, properties) {
			var data = {};
			properties = [];
			var types = this.propertyTypes;
			if (_data.mesh instanceof Asset || typeof _data.mesh === 'number') {
				_data.meshAsset = _data.mesh;
				delete _data.mesh;
			}
			for (var prop in _data) {
				if (_data.hasOwnProperty(prop)) {
					properties.push(prop);
					data[prop] = _data[prop];
				}
				if (types[prop] === 'vec3') {
					if (Array.isArray(data[prop])) {
						data[prop] = new Vec3(data[prop][0], data[prop][1], data[prop][2]);
					}
				} else if (types[prop] === 'curve') {
					if (!(data[prop] instanceof Curve)) {
						var t = data[prop].type;
						data[prop] = new Curve(data[prop].keys);
						data[prop].type = t;
					}
				} else if (types[prop] === 'curveset') {
					if (!(data[prop] instanceof CurveSet)) {
						var _t = data[prop].type;
						data[prop] = new CurveSet(data[prop].keys);
						data[prop].type = _t;
					}
				}
				if (data.layers && Array.isArray(data.layers)) {
					data.layers = data.layers.slice(0);
				}
			}
			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
		};
		_proto.cloneComponent = function cloneComponent(entity, clone) {
			var source = entity.particlesystem.data;
			var schema = this.schema;
			var data = {};
			for (var i = 0, len = schema.length; i < len; i++) {
				var prop = schema[i];
				var sourceProp = source[prop];
				if (sourceProp instanceof Vec3 || sourceProp instanceof Curve || sourceProp instanceof CurveSet) {
					sourceProp = sourceProp.clone();
					data[prop] = sourceProp;
				} else if (prop === 'layers') {
					data.layers = source.layers.slice(0);
				} else {
					if (sourceProp !== null && sourceProp !== undefined) {
						data[prop] = sourceProp;
					}
				}
			}
			return this.addComponent(clone, data);
		};
		_proto.onUpdate = function onUpdate(dt) {
			var components = this.store;
			var numSteps;
			var stats = this.app.stats.particles;
			var composition = this.app.scene.layers;
			for (var i = 0; i < composition.layerList.length; i++) {
				composition.layerList[i].requiresLightCube = false;
			}
			for (var id in components) {
				if (components.hasOwnProperty(id)) {
					var component = components[id];
					var entity = component.entity;
					var data = component.data;
					if (data.enabled && entity.enabled) {
						var emitter = entity.particlesystem.emitter;
						if (!(emitter != null && emitter.meshInstance.visible)) continue;
						if (emitter.lighting) {
							var layers = data.layers;
							for (var _i = 0; _i < layers.length; _i++) {
								var layer = composition.getLayerById(layers[_i]);
								if (layer) layer.requiresLightCube = true;
							}
						}
						if (!data.paused) {
							emitter.simTime += dt;
							if (emitter.simTime > emitter.fixedTimeStep) {
								numSteps = Math.floor(emitter.simTime / emitter.fixedTimeStep);
								emitter.simTime -= numSteps * emitter.fixedTimeStep;
							}
							if (numSteps) {
								numSteps = Math.min(numSteps, emitter.maxSubSteps);
								for (var _i2 = 0; _i2 < numSteps; _i2++) {
									emitter.addTime(emitter.fixedTimeStep, false);
								}
								stats._updatesPerFrame += numSteps;
								stats._frameTime += emitter._addTimeTime;
								emitter._addTimeTime = 0;
							}
							emitter.finishFrame();
						}
					}
				}
			}
		};
		_proto.onBeforeRemove = function onBeforeRemove(entity, component) {
			component.onBeforeRemove();
		};
		_proto.destroy = function destroy() {
			_ComponentSystem.prototype.destroy.call(this);
			this.app.systems.off('update', this.onUpdate, this);
		};
		return ParticleSystemComponentSystem;
	}(ComponentSystem);
	Component._buildAccessors(ParticleSystemComponent.prototype, _schema$a);

	var SkinInstanceCachedObject = function (_RefCountedObject) {
		_inheritsLoose(SkinInstanceCachedObject, _RefCountedObject);
		function SkinInstanceCachedObject(skin, skinInstance) {
			var _this;
			_this = _RefCountedObject.call(this) || this;
			_this.skin = skin;
			_this.skinInstance = skinInstance;
			return _this;
		}
		return SkinInstanceCachedObject;
	}(RefCountedObject);
	var SkinInstanceCache = function () {
		function SkinInstanceCache() {}
		SkinInstanceCache.createCachedSkinInstance = function createCachedSkinInstance(skin, rootBone, entity) {
			var skinInst = SkinInstanceCache.getCachedSkinInstance(skin, rootBone);
			if (!skinInst) {
				skinInst = new SkinInstance(skin);
				skinInst.resolve(rootBone, entity);
				SkinInstanceCache.addCachedSkinInstance(skin, rootBone, skinInst);
			}
			return skinInst;
		};
		SkinInstanceCache.getCachedSkinInstance = function getCachedSkinInstance(skin, rootBone) {
			var skinInstance = null;
			var cachedObjArray = SkinInstanceCache._skinInstanceCache.get(rootBone);
			if (cachedObjArray) {
				var cachedObj = cachedObjArray.find(function (element) {
					return element.skin === skin;
				});
				if (cachedObj) {
					cachedObj.incRefCount();
					skinInstance = cachedObj.skinInstance;
				}
			}
			return skinInstance;
		};
		SkinInstanceCache.addCachedSkinInstance = function addCachedSkinInstance(skin, rootBone, skinInstance) {
			var cachedObjArray = SkinInstanceCache._skinInstanceCache.get(rootBone);
			if (!cachedObjArray) {
				cachedObjArray = [];
				SkinInstanceCache._skinInstanceCache.set(rootBone, cachedObjArray);
			}
			var cachedObj = cachedObjArray.find(function (element) {
				return element.skin === skin;
			});
			if (!cachedObj) {
				cachedObj = new SkinInstanceCachedObject(skin, skinInstance);
				cachedObjArray.push(cachedObj);
			}
			cachedObj.incRefCount();
		};
		SkinInstanceCache.removeCachedSkinInstance = function removeCachedSkinInstance(skinInstance) {
			if (skinInstance) {
				var rootBone = skinInstance.rootBone;
				if (rootBone) {
					var cachedObjArray = SkinInstanceCache._skinInstanceCache.get(rootBone);
					if (cachedObjArray) {
						var cachedObjIndex = cachedObjArray.findIndex(function (element) {
							return element.skinInstance === skinInstance;
						});
						if (cachedObjIndex >= 0) {
							var cachedObj = cachedObjArray[cachedObjIndex];
							cachedObj.decRefCount();
							if (cachedObj.refCount === 0) {
								cachedObjArray.splice(cachedObjIndex, 1);
								if (!cachedObjArray.length) {
									SkinInstanceCache._skinInstanceCache.delete(rootBone);
								}
								if (skinInstance) {
									skinInstance.destroy();
									cachedObj.skinInstance = null;
								}
							}
						}
					}
				}
			}
		};
		return SkinInstanceCache;
	}();
	SkinInstanceCache._skinInstanceCache = new Map();

	var AssetReference = function () {
		function AssetReference(propertyName, parent, registry, callbacks, scope) {
			this.propertyName = propertyName;
			this.parent = parent;
			this._scope = scope;
			this._registry = registry;
			this.id = null;
			this.url = null;
			this.asset = null;
			this._onAssetLoad = callbacks.load;
			this._onAssetAdd = callbacks.add;
			this._onAssetRemove = callbacks.remove;
			this._onAssetUnload = callbacks.unload;
		}
		var _proto = AssetReference.prototype;
		_proto._bind = function _bind() {
			if (this.id) {
				if (this._onAssetLoad) this._registry.on('load:' + this.id, this._onLoad, this);
				if (this._onAssetAdd) this._registry.once('add:' + this.id, this._onAdd, this);
				if (this._onAssetRemove) this._registry.on('remove:' + this.id, this._onRemove, this);
				if (this._onAssetUnload) this._registry.on('unload:' + this.id, this._onUnload, this);
			}
			if (this.url) {
				if (this._onAssetLoad) this._registry.on('load:url:' + this.url, this._onLoad, this);
				if (this._onAssetAdd) this._registry.once('add:url:' + this.url, this._onAdd, this);
				if (this._onAssetRemove) this._registry.on('remove:url:' + this.url, this._onRemove, this);
			}
		};
		_proto._unbind = function _unbind() {
			if (this.id) {
				if (this._onAssetLoad) this._registry.off('load:' + this.id, this._onLoad, this);
				if (this._onAssetAdd) this._registry.off('add:' + this.id, this._onAdd, this);
				if (this._onAssetRemove) this._registry.off('remove:' + this.id, this._onRemove, this);
				if (this._onAssetUnload) this._registry.off('unload:' + this.id, this._onUnload, this);
			}
			if (this.url) {
				if (this._onAssetLoad) this._registry.off('load:' + this.url, this._onLoad, this);
				if (this._onAssetAdd) this._registry.off('add:' + this.url, this._onAdd, this);
				if (this._onAssetRemove) this._registry.off('remove:' + this.url, this._onRemove, this);
			}
		};
		_proto._onLoad = function _onLoad(asset) {
			this._onAssetLoad.call(this._scope, this.propertyName, this.parent, asset);
		};
		_proto._onAdd = function _onAdd(asset) {
			this.asset = asset;
			this._onAssetAdd.call(this._scope, this.propertyName, this.parent, asset);
		};
		_proto._onRemove = function _onRemove(asset) {
			this._onAssetRemove.call(this._scope, this.propertyName, this.parent, asset);
			this.asset = null;
		};
		_proto._onUnload = function _onUnload(asset) {
			this._onAssetUnload.call(this._scope, this.propertyName, this.parent, asset);
		};
		_createClass(AssetReference, [{
			key: "id",
			get: function get() {
				return this._id;
			},
			set: function set(value) {
				if (this.url) throw Error('Can\'t set id and url');
				this._unbind();
				this._id = value;
				this.asset = this._registry.get(this._id);
				this._bind();
			}
		}, {
			key: "url",
			get: function get() {
				return this._url;
			},
			set: function set(value) {
				if (this.id) throw Error('Can\'t set id and url');
				this._unbind();
				this._url = value;
				this.asset = this._registry.getByUrl(this._url);
				this._bind();
			}
		}]);
		return AssetReference;
	}();

	var RenderComponent = function (_Component) {
		_inheritsLoose(RenderComponent, _Component);
		function RenderComponent(system, entity) {
			var _this;
			_this = _Component.call(this, system, entity) || this;
			_this._type = 'asset';
			_this._castShadows = true;
			_this._receiveShadows = true;
			_this._castShadowsLightmap = true;
			_this._lightmapped = false;
			_this._lightmapSizeMultiplier = 1;
			_this.isStatic = false;
			_this._batchGroupId = -1;
			_this._layers = [LAYERID_WORLD];
			_this._renderStyle = RENDERSTYLE_SOLID;
			_this._meshInstances = [];
			_this._customAabb = null;
			_this._area = null;
			_this._assetReference = [];
			_this._materialReferences = [];
			_this._material = void 0;
			_this._rootBone = void 0;
			_this._rootBone = new EntityReference(_assertThisInitialized(_this), 'rootBone');
			_this._rootBone.on('set:entity', _this._onSetRootBone, _assertThisInitialized(_this));
			_this._assetReference = new AssetReference('asset', _assertThisInitialized(_this), system.app.assets, {
				add: _this._onRenderAssetAdded,
				load: _this._onRenderAssetLoad,
				remove: _this._onRenderAssetRemove,
				unload: _this._onRenderAssetUnload
			}, _assertThisInitialized(_this));
			_this._material = system.defaultMaterial;
			entity.on('remove', _this.onRemoveChild, _assertThisInitialized(_this));
			entity.on('removehierarchy', _this.onRemoveChild, _assertThisInitialized(_this));
			entity.on('insert', _this.onInsertChild, _assertThisInitialized(_this));
			entity.on('inserthierarchy', _this.onInsertChild, _assertThisInitialized(_this));
			return _this;
		}
		var _proto = RenderComponent.prototype;
		_proto.assignAsset = function assignAsset(asset) {
			var id = asset instanceof Asset ? asset.id : asset;
			this._assetReference.id = id;
		};
		_proto._onSetRootBone = function _onSetRootBone(entity) {
			if (entity) {
				this._onRootBoneChanged();
			}
		};
		_proto._onRootBoneChanged = function _onRootBoneChanged() {
			this._clearSkinInstances();
			if (this.enabled && this.entity.enabled) {
				this._cloneSkinInstances();
			}
		};
		_proto.destroyMeshInstances = function destroyMeshInstances() {
			var meshInstances = this._meshInstances;
			if (meshInstances) {
				this.removeFromLayers();
				this._clearSkinInstances();
				for (var i = 0; i < meshInstances.length; i++) {
					meshInstances[i].destroy();
				}
				this._meshInstances.length = 0;
			}
		};
		_proto.addToLayers = function addToLayers() {
			var layers = this.system.app.scene.layers;
			for (var i = 0; i < this._layers.length; i++) {
				var layer = layers.getLayerById(this._layers[i]);
				if (layer) {
					layer.addMeshInstances(this._meshInstances);
				}
			}
		};
		_proto.removeFromLayers = function removeFromLayers() {
			if (this._meshInstances && this._meshInstances.length) {
				var layers = this.system.app.scene.layers;
				for (var i = 0; i < this._layers.length; i++) {
					var layer = layers.getLayerById(this._layers[i]);
					if (layer) {
						layer.removeMeshInstances(this._meshInstances);
					}
				}
			}
		};
		_proto.onRemoveChild = function onRemoveChild() {
			this.removeFromLayers();
		};
		_proto.onInsertChild = function onInsertChild() {
			if (this._meshInstances && this.enabled && this.entity.enabled) {
				this.addToLayers();
			}
		};
		_proto.onRemove = function onRemove() {
			this.destroyMeshInstances();
			this.asset = null;
			this.materialAsset = null;
			this._assetReference.id = null;
			for (var i = 0; i < this._materialReferences.length; i++) {
				this._materialReferences[i].id = null;
			}
			this.entity.off('remove', this.onRemoveChild, this);
			this.entity.off('insert', this.onInsertChild, this);
		};
		_proto.onLayersChanged = function onLayersChanged(oldComp, newComp) {
			this.addToLayers();
			oldComp.off('add', this.onLayerAdded, this);
			oldComp.off('remove', this.onLayerRemoved, this);
			newComp.on('add', this.onLayerAdded, this);
			newComp.on('remove', this.onLayerRemoved, this);
		};
		_proto.onLayerAdded = function onLayerAdded(layer) {
			var index = this.layers.indexOf(layer.id);
			if (index < 0) return;
			layer.addMeshInstances(this._meshInstances);
		};
		_proto.onLayerRemoved = function onLayerRemoved(layer) {
			var index = this.layers.indexOf(layer.id);
			if (index < 0) return;
			layer.removeMeshInstances(this._meshInstances);
		};
		_proto.onEnable = function onEnable() {
			var app = this.system.app;
			var scene = app.scene;
			this._rootBone.onParentComponentEnable();
			this._cloneSkinInstances();
			scene.on('set:layers', this.onLayersChanged, this);
			if (scene.layers) {
				scene.layers.on('add', this.onLayerAdded, this);
				scene.layers.on('remove', this.onLayerRemoved, this);
			}
			var isAsset = this._type === 'asset';
			if (this._meshInstances && this._meshInstances.length) {
				this.addToLayers();
			} else if (isAsset && this.asset) {
				this._onRenderAssetAdded();
			}
			for (var i = 0; i < this._materialReferences.length; i++) {
				if (this._materialReferences[i].asset) {
					this.system.app.assets.load(this._materialReferences[i].asset);
				}
			}
			if (this._batchGroupId >= 0) {
				var _app$batcher;
				(_app$batcher = app.batcher) == null || _app$batcher.insert(BatchGroup.RENDER, this.batchGroupId, this.entity);
			}
		};
		_proto.onDisable = function onDisable() {
			var app = this.system.app;
			var scene = app.scene;
			scene.off('set:layers', this.onLayersChanged, this);
			if (scene.layers) {
				scene.layers.off('add', this.onLayerAdded, this);
				scene.layers.off('remove', this.onLayerRemoved, this);
			}
			if (this._batchGroupId >= 0) {
				var _app$batcher2;
				(_app$batcher2 = app.batcher) == null || _app$batcher2.remove(BatchGroup.RENDER, this.batchGroupId, this.entity);
			}
			this.removeFromLayers();
		};
		_proto.hide = function hide() {
			if (this._meshInstances) {
				for (var i = 0; i < this._meshInstances.length; i++) {
					this._meshInstances[i].visible = false;
				}
			}
		};
		_proto.show = function show() {
			if (this._meshInstances) {
				for (var i = 0; i < this._meshInstances.length; i++) {
					this._meshInstances[i].visible = true;
				}
			}
		};
		_proto._onRenderAssetAdded = function _onRenderAssetAdded() {
			if (!this._assetReference.asset) return;
			if (this._assetReference.asset.resource) {
				this._onRenderAssetLoad();
			} else if (this.enabled && this.entity.enabled) {
				this.system.app.assets.load(this._assetReference.asset);
			}
		};
		_proto._onRenderAssetLoad = function _onRenderAssetLoad() {
			this.destroyMeshInstances();
			if (this._assetReference.asset) {
				var render = this._assetReference.asset.resource;
				render.off('set:meshes', this._onSetMeshes, this);
				render.on('set:meshes', this._onSetMeshes, this);
				if (render.meshes) {
					this._onSetMeshes(render.meshes);
				}
			}
		};
		_proto._onSetMeshes = function _onSetMeshes(meshes) {
			this._cloneMeshes(meshes);
		};
		_proto._clearSkinInstances = function _clearSkinInstances() {
			for (var i = 0; i < this._meshInstances.length; i++) {
				var meshInstance = this._meshInstances[i];
				SkinInstanceCache.removeCachedSkinInstance(meshInstance.skinInstance);
				meshInstance.skinInstance = null;
			}
		};
		_proto._cloneSkinInstances = function _cloneSkinInstances() {
			if (this._meshInstances.length && this._rootBone.entity instanceof GraphNode) {
				for (var i = 0; i < this._meshInstances.length; i++) {
					var meshInstance = this._meshInstances[i];
					var mesh = meshInstance.mesh;
					if (mesh.skin && !meshInstance.skinInstance) {
						meshInstance.skinInstance = SkinInstanceCache.createCachedSkinInstance(mesh.skin, this._rootBone.entity, this.entity);
					}
				}
			}
		};
		_proto._cloneMeshes = function _cloneMeshes(meshes) {
			if (meshes && meshes.length) {
				var meshInstances = [];
				for (var i = 0; i < meshes.length; i++) {
					var mesh = meshes[i];
					var material = this._materialReferences[i] && this._materialReferences[i].asset && this._materialReferences[i].asset.resource;
					var meshInst = new MeshInstance(mesh, material || this.system.defaultMaterial, this.entity);
					meshInstances.push(meshInst);
					if (mesh.morph) {
						meshInst.morphInstance = new MorphInstance(mesh.morph);
					}
				}
				this.meshInstances = meshInstances;
				this._cloneSkinInstances();
			}
		};
		_proto._onRenderAssetUnload = function _onRenderAssetUnload() {
			if (this._type === 'asset') {
				this.destroyMeshInstances();
			}
		};
		_proto._onRenderAssetRemove = function _onRenderAssetRemove() {
			if (this._assetReference.asset && this._assetReference.asset.resource) {
				this._assetReference.asset.resource.off('set:meshes', this._onSetMeshes, this);
			}
			this._onRenderAssetUnload();
		};
		_proto._onMaterialAdded = function _onMaterialAdded(index, component, asset) {
			if (asset.resource) {
				this._onMaterialLoad(index, component, asset);
			} else {
				if (this.enabled && this.entity.enabled) {
					this.system.app.assets.load(asset);
				}
			}
		};
		_proto._updateMainMaterial = function _updateMainMaterial(index, material) {
			if (index === 0) {
				this.material = material;
			}
		};
		_proto._onMaterialLoad = function _onMaterialLoad(index, component, asset) {
			if (this._meshInstances[index]) {
				this._meshInstances[index].material = asset.resource;
			}
			this._updateMainMaterial(index, asset.resource);
		};
		_proto._onMaterialRemove = function _onMaterialRemove(index, component, asset) {
			if (this._meshInstances[index]) {
				this._meshInstances[index].material = this.system.defaultMaterial;
			}
			this._updateMainMaterial(index, this.system.defaultMaterial);
		};
		_proto._onMaterialUnload = function _onMaterialUnload(index, component, asset) {
			if (this._meshInstances[index]) {
				this._meshInstances[index].material = this.system.defaultMaterial;
			}
			this._updateMainMaterial(index, this.system.defaultMaterial);
		};
		_proto.resolveDuplicatedEntityReferenceProperties = function resolveDuplicatedEntityReferenceProperties(oldRender, duplicatedIdsMap) {
			if (oldRender.rootBone && duplicatedIdsMap[oldRender.rootBone]) {
				this.rootBone = duplicatedIdsMap[oldRender.rootBone];
			}
			this._clearSkinInstances();
		};
		_createClass(RenderComponent, [{
			key: "renderStyle",
			get: function get() {
				return this._renderStyle;
			},
			set: function set(renderStyle) {
				if (this._renderStyle !== renderStyle) {
					this._renderStyle = renderStyle;
					MeshInstance._prepareRenderStyleForArray(this._meshInstances, renderStyle);
				}
			}
		}, {
			key: "customAabb",
			get: function get() {
				return this._customAabb;
			},
			set: function set(value) {
				this._customAabb = value;
				var mi = this._meshInstances;
				if (mi) {
					for (var i = 0; i < mi.length; i++) {
						mi[i].setCustomAabb(this._customAabb);
					}
				}
			}
		}, {
			key: "type",
			get: function get() {
				return this._type;
			},
			set: function set(value) {
				if (this._type !== value) {
					this._area = null;
					this._type = value;
					this.destroyMeshInstances();
					if (value !== 'asset') {
						var material = this._material;
						if (!material || material === this.system.defaultMaterial) {
							material = this._materialReferences[0] && this._materialReferences[0].asset && this._materialReferences[0].asset.resource;
						}
						var primData = getShapePrimitive(this.system.app.graphicsDevice, value);
						this._area = primData.area;
						this.meshInstances = [new MeshInstance(primData.mesh, material || this.system.defaultMaterial, this.entity)];
					}
				}
			}
		}, {
			key: "meshInstances",
			get: function get() {
				return this._meshInstances;
			},
			set: function set(value) {
				this.destroyMeshInstances();
				this._meshInstances = value;
				if (this._meshInstances) {
					var mi = this._meshInstances;
					for (var i = 0; i < mi.length; i++) {
						if (!mi[i].node) {
							mi[i].node = this.entity;
						}
						mi[i].castShadow = this._castShadows;
						mi[i].receiveShadow = this._receiveShadows;
						mi[i].renderStyle = this._renderStyle;
						mi[i].setLightmapped(this._lightmapped);
						mi[i].setCustomAabb(this._customAabb);
					}
					if (this.enabled && this.entity.enabled) {
						this.addToLayers();
					}
				}
			}
		}, {
			key: "lightmapped",
			get: function get() {
				return this._lightmapped;
			},
			set: function set(value) {
				if (value !== this._lightmapped) {
					this._lightmapped = value;
					var mi = this._meshInstances;
					if (mi) {
						for (var i = 0; i < mi.length; i++) {
							mi[i].setLightmapped(value);
						}
					}
				}
			}
		}, {
			key: "castShadows",
			get: function get() {
				return this._castShadows;
			},
			set: function set(value) {
				if (this._castShadows !== value) {
					var mi = this._meshInstances;
					if (mi) {
						var layers = this.layers;
						var scene = this.system.app.scene;
						if (this._castShadows && !value) {
							for (var i = 0; i < layers.length; i++) {
								var layer = scene.layers.getLayerById(this.layers[i]);
								if (layer) {
									layer.removeShadowCasters(mi);
								}
							}
						}
						for (var _i = 0; _i < mi.length; _i++) {
							mi[_i].castShadow = value;
						}
						if (!this._castShadows && value) {
							for (var _i2 = 0; _i2 < layers.length; _i2++) {
								var _layer = scene.layers.getLayerById(layers[_i2]);
								if (_layer) {
									_layer.addShadowCasters(mi);
								}
							}
						}
					}
					this._castShadows = value;
				}
			}
		}, {
			key: "receiveShadows",
			get: function get() {
				return this._receiveShadows;
			},
			set: function set(value) {
				if (this._receiveShadows !== value) {
					this._receiveShadows = value;
					var mi = this._meshInstances;
					if (mi) {
						for (var i = 0; i < mi.length; i++) {
							mi[i].receiveShadow = value;
						}
					}
				}
			}
		}, {
			key: "castShadowsLightmap",
			get: function get() {
				return this._castShadowsLightmap;
			},
			set: function set(value) {
				this._castShadowsLightmap = value;
			}
		}, {
			key: "lightmapSizeMultiplier",
			get: function get() {
				return this._lightmapSizeMultiplier;
			},
			set: function set(value) {
				this._lightmapSizeMultiplier = value;
			}
		}, {
			key: "layers",
			get: function get() {
				return this._layers;
			},
			set: function set(value) {
				var layers = this.system.app.scene.layers;
				var layer;
				if (this._meshInstances) {
					for (var i = 0; i < this._layers.length; i++) {
						layer = layers.getLayerById(this._layers[i]);
						if (layer) {
							layer.removeMeshInstances(this._meshInstances);
						}
					}
				}
				this._layers.length = 0;
				for (var _i3 = 0; _i3 < value.length; _i3++) {
					this._layers[_i3] = value[_i3];
				}
				if (!this.enabled || !this.entity.enabled || !this._meshInstances) return;
				for (var _i4 = 0; _i4 < this._layers.length; _i4++) {
					layer = layers.getLayerById(this._layers[_i4]);
					if (layer) {
						layer.addMeshInstances(this._meshInstances);
					}
				}
			}
		}, {
			key: "batchGroupId",
			get: function get() {
				return this._batchGroupId;
			},
			set: function set(value) {
				if (this._batchGroupId !== value) {
					if (this.entity.enabled && this._batchGroupId >= 0) {
						var _this$system$app$batc;
						(_this$system$app$batc = this.system.app.batcher) == null || _this$system$app$batc.remove(BatchGroup.RENDER, this.batchGroupId, this.entity);
					}
					if (this.entity.enabled && value >= 0) {
						var _this$system$app$batc2;
						(_this$system$app$batc2 = this.system.app.batcher) == null || _this$system$app$batc2.insert(BatchGroup.RENDER, value, this.entity);
					}
					if (value < 0 && this._batchGroupId >= 0 && this.enabled && this.entity.enabled) {
						this.addToLayers();
					}
					this._batchGroupId = value;
				}
			}
		}, {
			key: "material",
			get: function get() {
				return this._material;
			},
			set: function set(value) {
				if (this._material !== value) {
					this._material = value;
					if (this._meshInstances && this._type !== 'asset') {
						for (var i = 0; i < this._meshInstances.length; i++) {
							this._meshInstances[i].material = value;
						}
					}
				}
			}
		}, {
			key: "materialAssets",
			get: function get() {
				return this._materialReferences.map(function (ref) {
					return ref.id;
				});
			},
			set: function set(value) {
				if (value === void 0) {
					value = [];
				}
				if (this._materialReferences.length > value.length) {
					for (var i = value.length; i < this._materialReferences.length; i++) {
						this._materialReferences[i].id = null;
					}
					this._materialReferences.length = value.length;
				}
				for (var _i5 = 0; _i5 < value.length; _i5++) {
					if (!this._materialReferences[_i5]) {
						this._materialReferences.push(new AssetReference(_i5, this, this.system.app.assets, {
							add: this._onMaterialAdded,
							load: this._onMaterialLoad,
							remove: this._onMaterialRemove,
							unload: this._onMaterialUnload
						}, this));
					}
					if (value[_i5]) {
						var id = value[_i5] instanceof Asset ? value[_i5].id : value[_i5];
						if (this._materialReferences[_i5].id !== id) {
							this._materialReferences[_i5].id = id;
						}
						if (this._materialReferences[_i5].asset) {
							this._onMaterialAdded(_i5, this, this._materialReferences[_i5].asset);
						}
					} else {
						this._materialReferences[_i5].id = null;
						if (this._meshInstances[_i5]) {
							this._meshInstances[_i5].material = this.system.defaultMaterial;
						}
					}
				}
			}
		}, {
			key: "asset",
			get: function get() {
				return this._assetReference.id;
			},
			set: function set(value) {
				var id = value instanceof Asset ? value.id : value;
				if (this._assetReference.id === id) return;
				if (this._assetReference.asset && this._assetReference.asset.resource) {
					this._onRenderAssetRemove();
				}
				this._assetReference.id = id;
				if (this._assetReference.asset) {
					this._onRenderAssetAdded();
				}
			}
		}]);
		return RenderComponent;
	}(Component);

	var RenderComponentData = function RenderComponentData() {
		this.enabled = true;
		this.rootBone = null;
	};

	var _schema$9 = [{
		name: 'rootBone',
		type: 'entity'
	}, 'enabled'];
	var _properties = ['material', 'meshInstances', 'asset', 'materialAssets', 'castShadows', 'receiveShadows', 'castShadowsLightmap', 'lightmapped', 'lightmapSizeMultiplier', 'renderStyle', 'type', 'layers', 'isStatic', 'batchGroupId'];
	var RenderComponentSystem = function (_ComponentSystem) {
		_inheritsLoose(RenderComponentSystem, _ComponentSystem);
		function RenderComponentSystem(app) {
			var _this;
			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'render';
			_this.ComponentType = RenderComponent;
			_this.DataType = RenderComponentData;
			_this.schema = _schema$9;
			_this.defaultMaterial = getDefaultMaterial(app.graphicsDevice);
			_this.on('beforeremove', _this.onRemove, _assertThisInitialized(_this));
			return _this;
		}
		var _proto = RenderComponentSystem.prototype;
		_proto.initializeComponentData = function initializeComponentData(component, _data, properties) {
			if (_data.batchGroupId === null || _data.batchGroupId === undefined) {
				_data.batchGroupId = -1;
			}
			if (_data.layers && _data.layers.length) {
				_data.layers = _data.layers.slice(0);
			}
			for (var i = 0; i < _properties.length; i++) {
				if (_data.hasOwnProperty(_properties[i])) {
					component[_properties[i]] = _data[_properties[i]];
				}
			}
			if (_data.aabbCenter && _data.aabbHalfExtents) {
				component.customAabb = new BoundingBox(new Vec3(_data.aabbCenter), new Vec3(_data.aabbHalfExtents));
			}
			_ComponentSystem.prototype.initializeComponentData.call(this, component, _data, _schema$9);
		};
		_proto.cloneComponent = function cloneComponent(entity, clone) {
			var data = {};
			for (var i = 0; i < _properties.length; i++) {
				data[_properties[i]] = entity.render[_properties[i]];
			}
			data.enabled = entity.render.enabled;
			delete data.meshInstances;
			var component = this.addComponent(clone, data);
			var srcMeshInstances = entity.render.meshInstances;
			var meshes = srcMeshInstances.map(function (mi) {
				return mi.mesh;
			});
			component._onSetMeshes(meshes);
			for (var m = 0; m < srcMeshInstances.length; m++) {
				component.meshInstances[m].material = srcMeshInstances[m].material;
			}
			if (entity.render.customAabb) {
				component.customAabb = entity.render.customAabb.clone();
			}
			return component;
		};
		_proto.onRemove = function onRemove(entity, component) {
			component.onRemove();
		};
		return RenderComponentSystem;
	}(ComponentSystem);
	Component._buildAccessors(RenderComponent.prototype, _schema$9);

	var ObjectPool = function () {
		function ObjectPool(constructorFunc, size) {
			this._pool = [];
			this._count = 0;
			this._constructor = constructorFunc;
			this._resize(size);
		}
		var _proto = ObjectPool.prototype;
		_proto._resize = function _resize(size) {
			if (size > this._pool.length) {
				for (var i = this._pool.length; i < size; i++) {
					this._pool[i] = new this._constructor();
				}
			}
		};
		_proto.allocate = function allocate() {
			if (this._count >= this._pool.length) {
				this._resize(this._pool.length * 2);
			}
			return this._pool[this._count++];
		};
		_proto.freeAll = function freeAll() {
			this._count = 0;
		};
		return ObjectPool;
	}();

	var _ammoTransform;
	var _ammoVec1, _ammoVec2, _ammoQuat;
	var _quat1 = new Quat();
	var _quat2 = new Quat();
	var _vec3 = new Vec3();
	var RigidBodyComponent = function (_Component) {
		_inheritsLoose(RigidBodyComponent, _Component);
		function RigidBodyComponent(system, entity) {
			var _this;
			_this = _Component.call(this, system, entity) || this;
			_this._angularDamping = 0;
			_this._angularFactor = new Vec3(1, 1, 1);
			_this._angularVelocity = new Vec3();
			_this._body = null;
			_this._friction = 0.5;
			_this._group = BODYGROUP_STATIC;
			_this._linearDamping = 0;
			_this._linearFactor = new Vec3(1, 1, 1);
			_this._linearVelocity = new Vec3();
			_this._mask = BODYMASK_NOT_STATIC;
			_this._mass = 1;
			_this._restitution = 0;
			_this._rollingFriction = 0;
			_this._simulationEnabled = false;
			_this._type = BODYTYPE_STATIC;
			return _this;
		}
		RigidBodyComponent.onLibraryLoaded = function onLibraryLoaded() {
			if (typeof Ammo !== 'undefined') {
				_ammoTransform = new Ammo.btTransform();
				_ammoVec1 = new Ammo.btVector3();
				_ammoVec2 = new Ammo.btVector3();
				_ammoQuat = new Ammo.btQuaternion();
			}
		};
		var _proto = RigidBodyComponent.prototype;
		_proto.createBody = function createBody() {
			var entity = this.entity;
			var shape;
			if (entity.collision) {
				shape = entity.collision.shape;
				if (entity.trigger) {
					entity.trigger.destroy();
					delete entity.trigger;
				}
			}
			if (shape) {
				if (this._body) {
					this.system.removeBody(this._body);
					this.system.destroyBody(this._body);
					this._body = null;
				}
				var mass = this._type === BODYTYPE_DYNAMIC ? this._mass : 0;
				this._getEntityTransform(_ammoTransform);
				var body = this.system.createBody(mass, shape, _ammoTransform);
				body.setRestitution(this._restitution);
				body.setFriction(this._friction);
				body.setRollingFriction(this._rollingFriction);
				body.setDamping(this._linearDamping, this._angularDamping);
				if (this._type === BODYTYPE_DYNAMIC) {
					var linearFactor = this._linearFactor;
					_ammoVec1.setValue(linearFactor.x, linearFactor.y, linearFactor.z);
					body.setLinearFactor(_ammoVec1);
					var angularFactor = this._angularFactor;
					_ammoVec1.setValue(angularFactor.x, angularFactor.y, angularFactor.z);
					body.setAngularFactor(_ammoVec1);
				} else if (this._type === BODYTYPE_KINEMATIC) {
					body.setCollisionFlags(body.getCollisionFlags() | BODYFLAG_KINEMATIC_OBJECT);
					body.setActivationState(BODYSTATE_DISABLE_DEACTIVATION);
				}
				body.entity = entity;
				this.body = body;
				if (this.enabled && entity.enabled) {
					this.enableSimulation();
				}
			}
		};
		_proto.isActive = function isActive() {
			return this._body ? this._body.isActive() : false;
		};
		_proto.activate = function activate() {
			if (this._body) {
				this._body.activate();
			}
		};
		_proto.enableSimulation = function enableSimulation() {
			var entity = this.entity;
			if (entity.collision && entity.collision.enabled && !this._simulationEnabled) {
				var body = this._body;
				if (body) {
					this.system.addBody(body, this._group, this._mask);
					switch (this._type) {
						case BODYTYPE_DYNAMIC:
							this.system._dynamic.push(this);
							body.forceActivationState(BODYSTATE_ACTIVE_TAG);
							this.syncEntityToBody();
							break;
						case BODYTYPE_KINEMATIC:
							this.system._kinematic.push(this);
							body.forceActivationState(BODYSTATE_DISABLE_DEACTIVATION);
							break;
						case BODYTYPE_STATIC:
							body.forceActivationState(BODYSTATE_ACTIVE_TAG);
							this.syncEntityToBody();
							break;
					}
					if (entity.collision.type === 'compound') {
						this.system._compounds.push(entity.collision);
					}
					body.activate();
					this._simulationEnabled = true;
				}
			}
		};
		_proto.disableSimulation = function disableSimulation() {
			var body = this._body;
			if (body && this._simulationEnabled) {
				var system = this.system;
				var idx = system._compounds.indexOf(this.entity.collision);
				if (idx > -1) {
					system._compounds.splice(idx, 1);
				}
				idx = system._dynamic.indexOf(this);
				if (idx > -1) {
					system._dynamic.splice(idx, 1);
				}
				idx = system._kinematic.indexOf(this);
				if (idx > -1) {
					system._kinematic.splice(idx, 1);
				}
				system.removeBody(body);
				body.forceActivationState(BODYSTATE_DISABLE_SIMULATION);
				this._simulationEnabled = false;
			}
		};
		_proto.applyForce = function applyForce(x, y, z, px, py, pz) {
			var body = this._body;
			if (body) {
				body.activate();
				if (x instanceof Vec3) {
					_ammoVec1.setValue(x.x, x.y, x.z);
				} else {
					_ammoVec1.setValue(x, y, z);
				}
				if (y instanceof Vec3) {
					_ammoVec2.setValue(y.x, y.y, y.z);
				} else if (px !== undefined) {
					_ammoVec2.setValue(px, py, pz);
				} else {
					_ammoVec2.setValue(0, 0, 0);
				}
				body.applyForce(_ammoVec1, _ammoVec2);
			}
		};
		_proto.applyTorque = function applyTorque(x, y, z) {
			var body = this._body;
			if (body) {
				body.activate();
				if (x instanceof Vec3) {
					_ammoVec1.setValue(x.x, x.y, x.z);
				} else {
					_ammoVec1.setValue(x, y, z);
				}
				body.applyTorque(_ammoVec1);
			}
		};
		_proto.applyImpulse = function applyImpulse(x, y, z, px, py, pz) {
			var body = this._body;
			if (body) {
				body.activate();
				if (x instanceof Vec3) {
					_ammoVec1.setValue(x.x, x.y, x.z);
				} else {
					_ammoVec1.setValue(x, y, z);
				}
				if (y instanceof Vec3) {
					_ammoVec2.setValue(y.x, y.y, y.z);
				} else if (px !== undefined) {
					_ammoVec2.setValue(px, py, pz);
				} else {
					_ammoVec2.setValue(0, 0, 0);
				}
				body.applyImpulse(_ammoVec1, _ammoVec2);
			}
		};
		_proto.applyTorqueImpulse = function applyTorqueImpulse(x, y, z) {
			var body = this._body;
			if (body) {
				body.activate();
				if (x instanceof Vec3) {
					_ammoVec1.setValue(x.x, x.y, x.z);
				} else {
					_ammoVec1.setValue(x, y, z);
				}
				body.applyTorqueImpulse(_ammoVec1);
			}
		};
		_proto.isStatic = function isStatic() {
			return this._type === BODYTYPE_STATIC;
		};
		_proto.isStaticOrKinematic = function isStaticOrKinematic() {
			return this._type === BODYTYPE_STATIC || this._type === BODYTYPE_KINEMATIC;
		};
		_proto.isKinematic = function isKinematic() {
			return this._type === BODYTYPE_KINEMATIC;
		};
		_proto._getEntityTransform = function _getEntityTransform(transform) {
			var entity = this.entity;
			var component = entity.collision;
			if (component) {
				var bodyPos = component.getShapePosition();
				var bodyRot = component.getShapeRotation();
				_ammoVec1.setValue(bodyPos.x, bodyPos.y, bodyPos.z);
				_ammoQuat.setValue(bodyRot.x, bodyRot.y, bodyRot.z, bodyRot.w);
			} else {
				var pos = entity.getPosition();
				var rot = entity.getRotation();
				_ammoVec1.setValue(pos.x, pos.y, pos.z);
				_ammoQuat.setValue(rot.x, rot.y, rot.z, rot.w);
			}
			transform.setOrigin(_ammoVec1);
			transform.setRotation(_ammoQuat);
		};
		_proto.syncEntityToBody = function syncEntityToBody() {
			var body = this._body;
			if (body) {
				this._getEntityTransform(_ammoTransform);
				body.setWorldTransform(_ammoTransform);
				if (this._type === BODYTYPE_KINEMATIC) {
					var motionState = body.getMotionState();
					if (motionState) {
						motionState.setWorldTransform(_ammoTransform);
					}
				}
				body.activate();
			}
		};
		_proto._updateDynamic = function _updateDynamic() {
			var body = this._body;
			if (body.isActive()) {
				var motionState = body.getMotionState();
				if (motionState) {
					var entity = this.entity;
					motionState.getWorldTransform(_ammoTransform);
					var p = _ammoTransform.getOrigin();
					var q = _ammoTransform.getRotation();
					var component = entity.collision;
					if (component && component._hasOffset) {
						var lo = component.data.linearOffset;
						var ao = component.data.angularOffset;
						var invertedAo = _quat2.copy(ao).invert();
						var entityRot = _quat1.set(q.x(), q.y(), q.z(), q.w()).mul(invertedAo);
						entityRot.transformVector(lo, _vec3);
						entity.setPosition(p.x() - _vec3.x, p.y() - _vec3.y, p.z() - _vec3.z);
						entity.setRotation(entityRot);
					} else {
						entity.setPosition(p.x(), p.y(), p.z());
						entity.setRotation(q.x(), q.y(), q.z(), q.w());
					}
				}
			}
		};
		_proto._updateKinematic = function _updateKinematic() {
			var motionState = this._body.getMotionState();
			if (motionState) {
				this._getEntityTransform(_ammoTransform);
				motionState.setWorldTransform(_ammoTransform);
			}
		};
		_proto.teleport = function teleport(x, y, z, rx, ry, rz) {
			if (x instanceof Vec3) {
				this.entity.setPosition(x);
			} else {
				this.entity.setPosition(x, y, z);
			}
			if (y instanceof Quat) {
				this.entity.setRotation(y);
			} else if (y instanceof Vec3) {
				this.entity.setEulerAngles(y);
			} else if (rx !== undefined) {
				this.entity.setEulerAngles(rx, ry, rz);
			}
			this.syncEntityToBody();
		};
		_proto.onEnable = function onEnable() {
			if (!this._body) {
				this.createBody();
			}
			this.enableSimulation();
		};
		_proto.onDisable = function onDisable() {
			this.disableSimulation();
		};
		_createClass(RigidBodyComponent, [{
			key: "angularDamping",
			get: function get() {
				return this._angularDamping;
			},
			set: function set(damping) {
				if (this._angularDamping !== damping) {
					this._angularDamping = damping;
					if (this._body) {
						this._body.setDamping(this._linearDamping, damping);
					}
				}
			}
		}, {
			key: "angularFactor",
			get: function get() {
				return this._angularFactor;
			},
			set: function set(factor) {
				if (!this._angularFactor.equals(factor)) {
					this._angularFactor.copy(factor);
					if (this._body && this._type === BODYTYPE_DYNAMIC) {
						_ammoVec1.setValue(factor.x, factor.y, factor.z);
						this._body.setAngularFactor(_ammoVec1);
					}
				}
			}
		}, {
			key: "angularVelocity",
			get: function get() {
				if (this._body && this._type === BODYTYPE_DYNAMIC) {
					var velocity = this._body.getAngularVelocity();
					this._angularVelocity.set(velocity.x(), velocity.y(), velocity.z());
				}
				return this._angularVelocity;
			},
			set: function set(velocity) {
				if (this._body && this._type === BODYTYPE_DYNAMIC) {
					this._body.activate();
					_ammoVec1.setValue(velocity.x, velocity.y, velocity.z);
					this._body.setAngularVelocity(_ammoVec1);
					this._angularVelocity.copy(velocity);
				}
			}
		}, {
			key: "body",
			get: function get() {
				return this._body;
			},
			set: function set(body) {
				if (this._body !== body) {
					this._body = body;
					if (body && this._simulationEnabled) {
						body.activate();
					}
				}
			}
		}, {
			key: "friction",
			get: function get() {
				return this._friction;
			},
			set: function set(friction) {
				if (this._friction !== friction) {
					this._friction = friction;
					if (this._body) {
						this._body.setFriction(friction);
					}
				}
			}
		}, {
			key: "group",
			get: function get() {
				return this._group;
			},
			set: function set(group) {
				if (this._group !== group) {
					this._group = group;
					if (this.enabled && this.entity.enabled) {
						this.disableSimulation();
						this.enableSimulation();
					}
				}
			}
		}, {
			key: "linearDamping",
			get: function get() {
				return this._linearDamping;
			},
			set: function set(damping) {
				if (this._linearDamping !== damping) {
					this._linearDamping = damping;
					if (this._body) {
						this._body.setDamping(damping, this._angularDamping);
					}
				}
			}
		}, {
			key: "linearFactor",
			get: function get() {
				return this._linearFactor;
			},
			set: function set(factor) {
				if (!this._linearFactor.equals(factor)) {
					this._linearFactor.copy(factor);
					if (this._body && this._type === BODYTYPE_DYNAMIC) {
						_ammoVec1.setValue(factor.x, factor.y, factor.z);
						this._body.setLinearFactor(_ammoVec1);
					}
				}
			}
		}, {
			key: "linearVelocity",
			get: function get() {
				if (this._body && this._type === BODYTYPE_DYNAMIC) {
					var velocity = this._body.getLinearVelocity();
					this._linearVelocity.set(velocity.x(), velocity.y(), velocity.z());
				}
				return this._linearVelocity;
			},
			set: function set(velocity) {
				if (this._body && this._type === BODYTYPE_DYNAMIC) {
					this._body.activate();
					_ammoVec1.setValue(velocity.x, velocity.y, velocity.z);
					this._body.setLinearVelocity(_ammoVec1);
					this._linearVelocity.copy(velocity);
				}
			}
		}, {
			key: "mask",
			get: function get() {
				return this._mask;
			},
			set: function set(mask) {
				if (this._mask !== mask) {
					this._mask = mask;
					if (this.enabled && this.entity.enabled) {
						this.disableSimulation();
						this.enableSimulation();
					}
				}
			}
		}, {
			key: "mass",
			get: function get() {
				return this._mass;
			},
			set: function set(mass) {
				if (this._mass !== mass) {
					this._mass = mass;
					if (this._body && this._type === BODYTYPE_DYNAMIC) {
						var enabled = this.enabled && this.entity.enabled;
						if (enabled) {
							this.disableSimulation();
						}
						this._body.getCollisionShape().calculateLocalInertia(mass, _ammoVec1);
						this._body.setMassProps(mass, _ammoVec1);
						this._body.updateInertiaTensor();
						if (enabled) {
							this.enableSimulation();
						}
					}
				}
			}
		}, {
			key: "restitution",
			get: function get() {
				return this._restitution;
			},
			set: function set(restitution) {
				if (this._restitution !== restitution) {
					this._restitution = restitution;
					if (this._body) {
						this._body.setRestitution(restitution);
					}
				}
			}
		}, {
			key: "rollingFriction",
			get: function get() {
				return this._rollingFriction;
			},
			set: function set(friction) {
				if (this._rollingFriction !== friction) {
					this._rollingFriction = friction;
					if (this._body) {
						this._body.setRollingFriction(friction);
					}
				}
			}
		}, {
			key: "type",
			get: function get() {
				return this._type;
			},
			set: function set(type) {
				if (this._type !== type) {
					this._type = type;
					this.disableSimulation();
					switch (type) {
						case BODYTYPE_DYNAMIC:
							this._group = BODYGROUP_DYNAMIC;
							this._mask = BODYMASK_ALL;
							break;
						case BODYTYPE_KINEMATIC:
							this._group = BODYGROUP_KINEMATIC;
							this._mask = BODYMASK_ALL;
							break;
						case BODYTYPE_STATIC:
						default:
							this._group = BODYGROUP_STATIC;
							this._mask = BODYMASK_NOT_STATIC;
							break;
					}
					this.createBody();
				}
			}
		}]);
		return RigidBodyComponent;
	}(Component);

	var RigidBodyComponentData = function RigidBodyComponentData() {
		this.enabled = true;
	};

	var ammoRayStart, ammoRayEnd;
	var RaycastResult = function RaycastResult(entity, point, normal, hitFraction) {
		this.entity = entity;
		this.point = point;
		this.normal = normal;
		this.hitFraction = hitFraction;
	};
	var SingleContactResult = function SingleContactResult(a, b, contactPoint) {
		if (arguments.length === 0) {
			this.a = null;
			this.b = null;
			this.impulse = 0;
			this.localPointA = new Vec3();
			this.localPointB = new Vec3();
			this.pointA = new Vec3();
			this.pointB = new Vec3();
			this.normal = new Vec3();
		} else {
			this.a = a;
			this.b = b;
			this.impulse = contactPoint.impulse;
			this.localPointA = contactPoint.localPoint;
			this.localPointB = contactPoint.localPointOther;
			this.pointA = contactPoint.point;
			this.pointB = contactPoint.pointOther;
			this.normal = contactPoint.normal;
		}
	};
	var ContactPoint = function ContactPoint(localPoint, localPointOther, point, pointOther, normal, impulse) {
		if (localPoint === void 0) {
			localPoint = new Vec3();
		}
		if (localPointOther === void 0) {
			localPointOther = new Vec3();
		}
		if (point === void 0) {
			point = new Vec3();
		}
		if (pointOther === void 0) {
			pointOther = new Vec3();
		}
		if (normal === void 0) {
			normal = new Vec3();
		}
		if (impulse === void 0) {
			impulse = 0;
		}
		this.localPoint = localPoint;
		this.localPointOther = localPointOther;
		this.point = point;
		this.pointOther = pointOther;
		this.normal = normal;
		this.impulse = impulse;
	};
	var ContactResult = function ContactResult(other, contacts) {
		this.other = other;
		this.contacts = contacts;
	};
	var _schema$8 = ['enabled'];
	var RigidBodyComponentSystem = function (_ComponentSystem) {
		_inheritsLoose(RigidBodyComponentSystem, _ComponentSystem);
		function RigidBodyComponentSystem(app) {
			var _this;
			_this = _ComponentSystem.call(this, app) || this;
			_this.maxSubSteps = 10;
			_this.fixedTimeStep = 1 / 60;
			_this.gravity = new Vec3(0, -9.81, 0);
			_this._gravityFloat32 = new Float32Array(3);
			_this._dynamic = [];
			_this._kinematic = [];
			_this._triggers = [];
			_this._compounds = [];
			_this.id = 'rigidbody';
			_this._stats = app.stats.frame;
			_this.ComponentType = RigidBodyComponent;
			_this.DataType = RigidBodyComponentData;
			_this.contactPointPool = null;
			_this.contactResultPool = null;
			_this.singleContactResultPool = null;
			_this.schema = _schema$8;
			_this.collisions = {};
			_this.frameCollisions = {};
			_this.on('beforeremove', _this.onBeforeRemove, _assertThisInitialized(_this));
			return _this;
		}
		var _proto = RigidBodyComponentSystem.prototype;
		_proto.onLibraryLoaded = function onLibraryLoaded() {
			if (typeof Ammo !== 'undefined') {
				this.collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
				this.dispatcher = new Ammo.btCollisionDispatcher(this.collisionConfiguration);
				this.overlappingPairCache = new Ammo.btDbvtBroadphase();
				this.solver = new Ammo.btSequentialImpulseConstraintSolver();
				this.dynamicsWorld = new Ammo.btDiscreteDynamicsWorld(this.dispatcher, this.overlappingPairCache, this.solver, this.collisionConfiguration);
				if (this.dynamicsWorld.setInternalTickCallback) {
					var checkForCollisionsPointer = Ammo.addFunction(this._checkForCollisions.bind(this), 'vif');
					this.dynamicsWorld.setInternalTickCallback(checkForCollisionsPointer);
				}
				ammoRayStart = new Ammo.btVector3();
				ammoRayEnd = new Ammo.btVector3();
				RigidBodyComponent.onLibraryLoaded();
				this.contactPointPool = new ObjectPool(ContactPoint, 1);
				this.contactResultPool = new ObjectPool(ContactResult, 1);
				this.singleContactResultPool = new ObjectPool(SingleContactResult, 1);
				this.app.systems.on('update', this.onUpdate, this);
			} else {
				this.app.systems.off('update', this.onUpdate, this);
			}
		};
		_proto.initializeComponentData = function initializeComponentData(component, data, properties) {
			var props = ['mass', 'linearDamping', 'angularDamping', 'linearFactor', 'angularFactor', 'friction', 'rollingFriction', 'restitution', 'type', 'group', 'mask'];
			for (var _i = 0, _props = props; _i < _props.length; _i++) {
				var property = _props[_i];
				if (data.hasOwnProperty(property)) {
					var value = data[property];
					if (Array.isArray(value)) {
						component[property] = new Vec3(value[0], value[1], value[2]);
					} else {
						component[property] = value;
					}
				}
			}
			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, ['enabled']);
		};
		_proto.cloneComponent = function cloneComponent(entity, clone) {
			var rigidbody = entity.rigidbody;
			var data = {
				enabled: rigidbody.enabled,
				mass: rigidbody.mass,
				linearDamping: rigidbody.linearDamping,
				angularDamping: rigidbody.angularDamping,
				linearFactor: [rigidbody.linearFactor.x, rigidbody.linearFactor.y, rigidbody.linearFactor.z],
				angularFactor: [rigidbody.angularFactor.x, rigidbody.angularFactor.y, rigidbody.angularFactor.z],
				friction: rigidbody.friction,
				rollingFriction: rigidbody.rollingFriction,
				restitution: rigidbody.restitution,
				type: rigidbody.type,
				group: rigidbody.group,
				mask: rigidbody.mask
			};
			return this.addComponent(clone, data);
		};
		_proto.onBeforeRemove = function onBeforeRemove(entity, component) {
			if (component.enabled) {
				component.enabled = false;
			}
			if (component.body) {
				this.destroyBody(component.body);
				component.body = null;
			}
		};
		_proto.addBody = function addBody(body, group, mask) {
			if (group !== undefined && mask !== undefined) {
				this.dynamicsWorld.addRigidBody(body, group, mask);
			} else {
				this.dynamicsWorld.addRigidBody(body);
			}
		};
		_proto.removeBody = function removeBody(body) {
			this.dynamicsWorld.removeRigidBody(body);
		};
		_proto.createBody = function createBody(mass, shape, transform) {
			var localInertia = new Ammo.btVector3(0, 0, 0);
			if (mass !== 0) {
				shape.calculateLocalInertia(mass, localInertia);
			}
			var motionState = new Ammo.btDefaultMotionState(transform);
			var bodyInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);
			var body = new Ammo.btRigidBody(bodyInfo);
			Ammo.destroy(bodyInfo);
			Ammo.destroy(localInertia);
			return body;
		};
		_proto.destroyBody = function destroyBody(body) {
			var motionState = body.getMotionState();
			if (motionState) {
				Ammo.destroy(motionState);
			}
			Ammo.destroy(body);
		};
		_proto.raycastFirst = function raycastFirst(start, end, options) {
			if (options === void 0) {
				options = {};
			}
			if (options.filterTags || options.filterCallback) {
				options.sort = true;
				return this.raycastAll(start, end, options)[0] || null;
			}
			var result = null;
			ammoRayStart.setValue(start.x, start.y, start.z);
			ammoRayEnd.setValue(end.x, end.y, end.z);
			var rayCallback = new Ammo.ClosestRayResultCallback(ammoRayStart, ammoRayEnd);
			if (typeof options.filterCollisionGroup === 'number') {
				rayCallback.set_m_collisionFilterGroup(options.filterCollisionGroup);
			}
			if (typeof options.filterCollisionMask === 'number') {
				rayCallback.set_m_collisionFilterMask(options.filterCollisionMask);
			}
			this.dynamicsWorld.rayTest(ammoRayStart, ammoRayEnd, rayCallback);
			if (rayCallback.hasHit()) {
				var collisionObj = rayCallback.get_m_collisionObject();
				var body = Ammo.castObject(collisionObj, Ammo.btRigidBody);
				if (body) {
					var point = rayCallback.get_m_hitPointWorld();
					var normal = rayCallback.get_m_hitNormalWorld();
					result = new RaycastResult(body.entity, new Vec3(point.x(), point.y(), point.z()), new Vec3(normal.x(), normal.y(), normal.z()), rayCallback.get_m_closestHitFraction());
				}
			}
			Ammo.destroy(rayCallback);
			return result;
		};
		_proto.raycastAll = function raycastAll(start, end, options) {
			if (options === void 0) {
				options = {};
			}
			var results = [];
			ammoRayStart.setValue(start.x, start.y, start.z);
			ammoRayEnd.setValue(end.x, end.y, end.z);
			var rayCallback = new Ammo.AllHitsRayResultCallback(ammoRayStart, ammoRayEnd);
			if (typeof options.filterCollisionGroup === 'number') {
				rayCallback.set_m_collisionFilterGroup(options.filterCollisionGroup);
			}
			if (typeof options.filterCollisionMask === 'number') {
				rayCallback.set_m_collisionFilterMask(options.filterCollisionMask);
			}
			this.dynamicsWorld.rayTest(ammoRayStart, ammoRayEnd, rayCallback);
			if (rayCallback.hasHit()) {
				var collisionObjs = rayCallback.get_m_collisionObjects();
				var points = rayCallback.get_m_hitPointWorld();
				var normals = rayCallback.get_m_hitNormalWorld();
				var hitFractions = rayCallback.get_m_hitFractions();
				var numHits = collisionObjs.size();
				for (var i = 0; i < numHits; i++) {
					var body = Ammo.castObject(collisionObjs.at(i), Ammo.btRigidBody);
					if (body && body.entity) {
						var _body$entity$tags;
						if (options.filterTags && !(_body$entity$tags = body.entity.tags).has.apply(_body$entity$tags, options.filterTags) || options.filterCallback && !options.filterCallback(body.entity)) {
							continue;
						}
						var point = points.at(i);
						var normal = normals.at(i);
						var result = new RaycastResult(body.entity, new Vec3(point.x(), point.y(), point.z()), new Vec3(normal.x(), normal.y(), normal.z()), hitFractions.at(i));
						results.push(result);
					}
				}
				if (options.sort) {
					results.sort(function (a, b) {
						return a.hitFraction - b.hitFraction;
					});
				}
			}
			Ammo.destroy(rayCallback);
			return results;
		};
		_proto._storeCollision = function _storeCollision(entity, other) {
			var isNewCollision = false;
			var guid = entity.getGuid();
			this.collisions[guid] = this.collisions[guid] || {
				others: [],
				entity: entity
			};
			if (this.collisions[guid].others.indexOf(other) < 0) {
				this.collisions[guid].others.push(other);
				isNewCollision = true;
			}
			this.frameCollisions[guid] = this.frameCollisions[guid] || {
				others: [],
				entity: entity
			};
			this.frameCollisions[guid].others.push(other);
			return isNewCollision;
		};
		_proto._createContactPointFromAmmo = function _createContactPointFromAmmo(contactPoint) {
			var localPointA = contactPoint.get_m_localPointA();
			var localPointB = contactPoint.get_m_localPointB();
			var positionWorldOnA = contactPoint.getPositionWorldOnA();
			var positionWorldOnB = contactPoint.getPositionWorldOnB();
			var normalWorldOnB = contactPoint.get_m_normalWorldOnB();
			var contact = this.contactPointPool.allocate();
			contact.localPoint.set(localPointA.x(), localPointA.y(), localPointA.z());
			contact.localPointOther.set(localPointB.x(), localPointB.y(), localPointB.z());
			contact.point.set(positionWorldOnA.x(), positionWorldOnA.y(), positionWorldOnA.z());
			contact.pointOther.set(positionWorldOnB.x(), positionWorldOnB.y(), positionWorldOnB.z());
			contact.normal.set(normalWorldOnB.x(), normalWorldOnB.y(), normalWorldOnB.z());
			contact.impulse = contactPoint.getAppliedImpulse();
			return contact;
		};
		_proto._createReverseContactPointFromAmmo = function _createReverseContactPointFromAmmo(contactPoint) {
			var localPointA = contactPoint.get_m_localPointA();
			var localPointB = contactPoint.get_m_localPointB();
			var positionWorldOnA = contactPoint.getPositionWorldOnA();
			var positionWorldOnB = contactPoint.getPositionWorldOnB();
			var normalWorldOnB = contactPoint.get_m_normalWorldOnB();
			var contact = this.contactPointPool.allocate();
			contact.localPointOther.set(localPointA.x(), localPointA.y(), localPointA.z());
			contact.localPoint.set(localPointB.x(), localPointB.y(), localPointB.z());
			contact.pointOther.set(positionWorldOnA.x(), positionWorldOnA.y(), positionWorldOnA.z());
			contact.point.set(positionWorldOnB.x(), positionWorldOnB.y(), positionWorldOnB.z());
			contact.normal.set(normalWorldOnB.x(), normalWorldOnB.y(), normalWorldOnB.z());
			contact.impulse = contactPoint.getAppliedImpulse();
			return contact;
		};
		_proto._createSingleContactResult = function _createSingleContactResult(a, b, contactPoint) {
			var result = this.singleContactResultPool.allocate();
			result.a = a;
			result.b = b;
			result.localPointA = contactPoint.localPoint;
			result.localPointB = contactPoint.localPointOther;
			result.pointA = contactPoint.point;
			result.pointB = contactPoint.pointOther;
			result.normal = contactPoint.normal;
			result.impulse = contactPoint.impulse;
			return result;
		};
		_proto._createContactResult = function _createContactResult(other, contacts) {
			var result = this.contactResultPool.allocate();
			result.other = other;
			result.contacts = contacts;
			return result;
		};
		_proto._cleanOldCollisions = function _cleanOldCollisions() {
			for (var guid in this.collisions) {
				if (this.collisions.hasOwnProperty(guid)) {
					var frameCollision = this.frameCollisions[guid];
					var collision = this.collisions[guid];
					var entity = collision.entity;
					var entityCollision = entity.collision;
					var entityRigidbody = entity.rigidbody;
					var others = collision.others;
					var length = others.length;
					var i = length;
					while (i--) {
						var other = others[i];
						if (!frameCollision || frameCollision.others.indexOf(other) < 0) {
							others.splice(i, 1);
							if (entity.trigger) {
								if (entityCollision) {
									entityCollision.fire('triggerleave', other);
								}
								if (other.rigidbody) {
									other.rigidbody.fire('triggerleave', entity);
								}
							} else if (!other.trigger) {
								if (entityRigidbody) {
									entityRigidbody.fire('collisionend', other);
								}
								if (entityCollision) {
									entityCollision.fire('collisionend', other);
								}
							}
						}
					}
					if (others.length === 0) {
						delete this.collisions[guid];
					}
				}
			}
		};
		_proto._hasContactEvent = function _hasContactEvent(entity) {
			var c = entity.collision;
			if (c && (c.hasEvent('collisionstart') || c.hasEvent('collisionend') || c.hasEvent('contact'))) {
				return true;
			}
			var r = entity.rigidbody;
			return r && (r.hasEvent('collisionstart') || r.hasEvent('collisionend') || r.hasEvent('contact'));
		};
		_proto._checkForCollisions = function _checkForCollisions(world, timeStep) {
			var dynamicsWorld = Ammo.wrapPointer(world, Ammo.btDynamicsWorld);
			var dispatcher = dynamicsWorld.getDispatcher();
			var numManifolds = dispatcher.getNumManifolds();
			this.frameCollisions = {};
			for (var i = 0; i < numManifolds; i++) {
				var manifold = dispatcher.getManifoldByIndexInternal(i);
				var body0 = manifold.getBody0();
				var body1 = manifold.getBody1();
				var wb0 = Ammo.castObject(body0, Ammo.btRigidBody);
				var wb1 = Ammo.castObject(body1, Ammo.btRigidBody);
				var e0 = wb0.entity;
				var e1 = wb1.entity;
				if (!e0 || !e1) {
					continue;
				}
				var flags0 = wb0.getCollisionFlags();
				var flags1 = wb1.getCollisionFlags();
				var numContacts = manifold.getNumContacts();
				var forwardContacts = [];
				var reverseContacts = [];
				var newCollision = void 0;
				if (numContacts > 0) {
					if (flags0 & BODYFLAG_NORESPONSE_OBJECT || flags1 & BODYFLAG_NORESPONSE_OBJECT) {
						var e0Events = e0.collision && (e0.collision.hasEvent('triggerenter') || e0.collision.hasEvent('triggerleave'));
						var e1Events = e1.collision && (e1.collision.hasEvent('triggerenter') || e1.collision.hasEvent('triggerleave'));
						var e0BodyEvents = e0.rigidbody && (e0.rigidbody.hasEvent('triggerenter') || e0.rigidbody.hasEvent('triggerleave'));
						var e1BodyEvents = e1.rigidbody && (e1.rigidbody.hasEvent('triggerenter') || e1.rigidbody.hasEvent('triggerleave'));
						if (e0Events) {
							newCollision = this._storeCollision(e0, e1);
							if (newCollision && !(flags1 & BODYFLAG_NORESPONSE_OBJECT)) {
								e0.collision.fire('triggerenter', e1);
							}
						}
						if (e1Events) {
							newCollision = this._storeCollision(e1, e0);
							if (newCollision && !(flags0 & BODYFLAG_NORESPONSE_OBJECT)) {
								e1.collision.fire('triggerenter', e0);
							}
						}
						if (e0BodyEvents) {
							if (!newCollision) {
								newCollision = this._storeCollision(e1, e0);
							}
							if (newCollision) {
								e0.rigidbody.fire('triggerenter', e1);
							}
						}
						if (e1BodyEvents) {
							if (!newCollision) {
								newCollision = this._storeCollision(e0, e1);
							}
							if (newCollision) {
								e1.rigidbody.fire('triggerenter', e0);
							}
						}
					} else {
						var _e0Events = this._hasContactEvent(e0);
						var _e1Events = this._hasContactEvent(e1);
						var globalEvents = this.hasEvent('contact');
						if (globalEvents || _e0Events || _e1Events) {
							for (var j = 0; j < numContacts; j++) {
								var btContactPoint = manifold.getContactPoint(j);
								var contactPoint = this._createContactPointFromAmmo(btContactPoint);
								if (_e0Events || _e1Events) {
									forwardContacts.push(contactPoint);
									var reverseContactPoint = this._createReverseContactPointFromAmmo(btContactPoint);
									reverseContacts.push(reverseContactPoint);
								}
								if (globalEvents) {
									var result = this._createSingleContactResult(e0, e1, contactPoint);
									this.fire('contact', result);
								}
							}
							if (_e0Events) {
								var forwardResult = this._createContactResult(e1, forwardContacts);
								newCollision = this._storeCollision(e0, e1);
								if (e0.collision) {
									e0.collision.fire('contact', forwardResult);
									if (newCollision) {
										e0.collision.fire('collisionstart', forwardResult);
									}
								}
								if (e0.rigidbody) {
									e0.rigidbody.fire('contact', forwardResult);
									if (newCollision) {
										e0.rigidbody.fire('collisionstart', forwardResult);
									}
								}
							}
							if (_e1Events) {
								var reverseResult = this._createContactResult(e0, reverseContacts);
								newCollision = this._storeCollision(e1, e0);
								if (e1.collision) {
									e1.collision.fire('contact', reverseResult);
									if (newCollision) {
										e1.collision.fire('collisionstart', reverseResult);
									}
								}
								if (e1.rigidbody) {
									e1.rigidbody.fire('contact', reverseResult);
									if (newCollision) {
										e1.rigidbody.fire('collisionstart', reverseResult);
									}
								}
							}
						}
					}
				}
			}
			this._cleanOldCollisions();
			this.contactPointPool.freeAll();
			this.contactResultPool.freeAll();
			this.singleContactResultPool.freeAll();
		};
		_proto.onUpdate = function onUpdate(dt) {
			var i, len;
			this._gravityFloat32[0] = this.gravity.x;
			this._gravityFloat32[1] = this.gravity.y;
			this._gravityFloat32[2] = this.gravity.z;
			var gravity = this.dynamicsWorld.getGravity();
			if (gravity.x() !== this._gravityFloat32[0] || gravity.y() !== this._gravityFloat32[1] || gravity.z() !== this._gravityFloat32[2]) {
				gravity.setValue(this.gravity.x, this.gravity.y, this.gravity.z);
				this.dynamicsWorld.setGravity(gravity);
			}
			var triggers = this._triggers;
			for (i = 0, len = triggers.length; i < len; i++) {
				triggers[i].updateTransform();
			}
			var compounds = this._compounds;
			for (i = 0, len = compounds.length; i < len; i++) {
				compounds[i]._updateCompound();
			}
			var kinematic = this._kinematic;
			for (i = 0, len = kinematic.length; i < len; i++) {
				kinematic[i]._updateKinematic();
			}
			this.dynamicsWorld.stepSimulation(dt, this.maxSubSteps, this.fixedTimeStep);
			var dynamic = this._dynamic;
			for (i = 0, len = dynamic.length; i < len; i++) {
				dynamic[i]._updateDynamic();
			}
			if (!this.dynamicsWorld.setInternalTickCallback) this._checkForCollisions(Ammo.getPointer(this.dynamicsWorld), dt);
		};
		_proto.destroy = function destroy() {
			_ComponentSystem.prototype.destroy.call(this);
			this.app.systems.off('update', this.onUpdate, this);
			if (typeof Ammo !== 'undefined') {
				Ammo.destroy(this.dynamicsWorld);
				Ammo.destroy(this.solver);
				Ammo.destroy(this.overlappingPairCache);
				Ammo.destroy(this.dispatcher);
				Ammo.destroy(this.collisionConfiguration);
				this.dynamicsWorld = null;
				this.solver = null;
				this.overlappingPairCache = null;
				this.dispatcher = null;
				this.collisionConfiguration = null;
			}
		};
		return RigidBodyComponentSystem;
	}(ComponentSystem);
	Component._buildAccessors(RigidBodyComponent.prototype, _schema$8);

	var SCALEMODE_NONE = 'none';
	var SCALEMODE_BLEND = 'blend';

	var _transform = new Mat4();
	var ScreenComponent = function (_Component) {
		_inheritsLoose(ScreenComponent, _Component);
		function ScreenComponent(system, entity) {
			var _this;
			_this = _Component.call(this, system, entity) || this;
			_this._resolution = new Vec2(640, 320);
			_this._referenceResolution = new Vec2(640, 320);
			_this._scaleMode = SCALEMODE_NONE;
			_this.scale = 1;
			_this._scaleBlend = 0.5;
			_this._priority = 0;
			_this._screenSpace = false;
			_this.cull = _this._screenSpace;
			_this._screenMatrix = new Mat4();
			_this._elements = new Set();
			system.app.graphicsDevice.on('resizecanvas', _this._onResize, _assertThisInitialized(_this));
			return _this;
		}
		var _proto = ScreenComponent.prototype;
		_proto.syncDrawOrder = function syncDrawOrder() {
			this.system.queueDrawOrderSync(this.entity.getGuid(), this._processDrawOrderSync, this);
		};
		_proto._recurseDrawOrderSync = function _recurseDrawOrderSync(e, i) {
			if (!(e instanceof Entity)) {
				return i;
			}
			if (e.element) {
				var prevDrawOrder = e.element.drawOrder;
				e.element.drawOrder = i++;
				if (e.element._batchGroupId >= 0 && prevDrawOrder !== e.element.drawOrder) {
					var _this$system$app$batc;
					(_this$system$app$batc = this.system.app.batcher) == null || _this$system$app$batc.markGroupDirty(e.element._batchGroupId);
				}
			}
			if (e.particlesystem) {
				e.particlesystem.drawOrder = i++;
			}
			var children = e.children;
			for (var j = 0; j < children.length; j++) {
				i = this._recurseDrawOrderSync(children[j], i);
			}
			return i;
		};
		_proto._processDrawOrderSync = function _processDrawOrderSync() {
			var i = 1;
			this._recurseDrawOrderSync(this.entity, i);
			this.fire('syncdraworder');
		};
		_proto._calcProjectionMatrix = function _calcProjectionMatrix() {
			var w = this._resolution.x / this.scale;
			var h = this._resolution.y / this.scale;
			var left = 0;
			var right = w;
			var bottom = -h;
			var top = 0;
			var near = 1;
			var far = -1;
			this._screenMatrix.setOrtho(left, right, bottom, top, near, far);
			if (!this._screenSpace) {
				_transform.setScale(0.5 * w, 0.5 * h, 1);
				this._screenMatrix.mul2(_transform, this._screenMatrix);
			}
		};
		_proto._updateScale = function _updateScale() {
			this.scale = this._calcScale(this._resolution, this.referenceResolution);
		};
		_proto._calcScale = function _calcScale(resolution, referenceResolution) {
			var lx = Math.log2(resolution.x / referenceResolution.x);
			var ly = Math.log2(resolution.y / referenceResolution.y);
			return Math.pow(2, lx * (1 - this._scaleBlend) + ly * this._scaleBlend);
		};
		_proto._onResize = function _onResize(width, height) {
			if (this._screenSpace) {
				this._resolution.set(width, height);
				this.resolution = this._resolution;
			}
		};
		_proto._bindElement = function _bindElement(element) {
			this._elements.add(element);
		};
		_proto._unbindElement = function _unbindElement(element) {
			this._elements.delete(element);
		};
		_proto.onRemove = function onRemove() {
			this.system.app.graphicsDevice.off('resizecanvas', this._onResize, this);
			this.fire('remove');
			this._elements.forEach(function (element) {
				return element._onScreenRemove();
			});
			this._elements.clear();
			this.off();
		};
		_createClass(ScreenComponent, [{
			key: "resolution",
			get: function get() {
				return this._resolution;
			},
			set: function set(value) {
				var _this2 = this;
				if (!this._screenSpace) {
					this._resolution.set(value.x, value.y);
				} else {
					this._resolution.set(this.system.app.graphicsDevice.width, this.system.app.graphicsDevice.height);
				}
				this._updateScale();
				this._calcProjectionMatrix();
				if (!this.entity._dirtyLocal) this.entity._dirtifyLocal();
				this.fire('set:resolution', this._resolution);
				this._elements.forEach(function (element) {
					return element._onScreenResize(_this2._resolution);
				});
			}
		}, {
			key: "referenceResolution",
			get: function get() {
				if (this._scaleMode === SCALEMODE_NONE) {
					return this._resolution;
				}
				return this._referenceResolution;
			},
			set: function set(value) {
				var _this3 = this;
				this._referenceResolution.set(value.x, value.y);
				this._updateScale();
				this._calcProjectionMatrix();
				if (!this.entity._dirtyLocal) this.entity._dirtifyLocal();
				this.fire('set:referenceresolution', this._resolution);
				this._elements.forEach(function (element) {
					return element._onScreenResize(_this3._resolution);
				});
			}
		}, {
			key: "screenSpace",
			get: function get() {
				return this._screenSpace;
			},
			set: function set(value) {
				this._screenSpace = value;
				if (this._screenSpace) {
					this._resolution.set(this.system.app.graphicsDevice.width, this.system.app.graphicsDevice.height);
				}
				this.resolution = this._resolution;
				if (!this.entity._dirtyLocal) this.entity._dirtifyLocal();
				this.fire('set:screenspace', this._screenSpace);
				this._elements.forEach(function (element) {
					return element._onScreenSpaceChange();
				});
			}
		}, {
			key: "scaleMode",
			get: function get() {
				return this._scaleMode;
			},
			set: function set(value) {
				if (value !== SCALEMODE_NONE && value !== SCALEMODE_BLEND) {
					value = SCALEMODE_NONE;
				}
				if (!this._screenSpace && value !== SCALEMODE_NONE) {
					value = SCALEMODE_NONE;
				}
				this._scaleMode = value;
				this.resolution = this._resolution;
				this.fire('set:scalemode', this._scaleMode);
			}
		}, {
			key: "scaleBlend",
			get: function get() {
				return this._scaleBlend;
			},
			set: function set(value) {
				var _this4 = this;
				this._scaleBlend = value;
				this._updateScale();
				this._calcProjectionMatrix();
				if (!this.entity._dirtyLocal) this.entity._dirtifyLocal();
				this.fire('set:scaleblend', this._scaleBlend);
				this._elements.forEach(function (element) {
					return element._onScreenResize(_this4._resolution);
				});
			}
		}, {
			key: "priority",
			get: function get() {
				return this._priority;
			},
			set: function set(value) {
				if (value > 0xFF) {
					value = 0xFF;
				}
				if (this._priority === value) {
					return;
				}
				this._priority = value;
				this.syncDrawOrder();
			}
		}]);
		return ScreenComponent;
	}(Component);

	var ScreenComponentData = function ScreenComponentData() {
		this.enabled = true;
	};

	var _schema$7 = ['enabled'];
	var ScreenComponentSystem = function (_ComponentSystem) {
		_inheritsLoose(ScreenComponentSystem, _ComponentSystem);
		function ScreenComponentSystem(app) {
			var _this;
			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'screen';
			_this.ComponentType = ScreenComponent;
			_this.DataType = ScreenComponentData;
			_this.schema = _schema$7;
			_this.windowResolution = new Vec2();
			_this._drawOrderSyncQueue = new IndexedList();
			_this.app.graphicsDevice.on('resizecanvas', _this._onResize, _assertThisInitialized(_this));
			_this.app.systems.on('update', _this._onUpdate, _assertThisInitialized(_this));
			_this.on('beforeremove', _this.onRemoveComponent, _assertThisInitialized(_this));
			return _this;
		}
		var _proto = ScreenComponentSystem.prototype;
		_proto.initializeComponentData = function initializeComponentData(component, data, properties) {
			if (data.priority !== undefined) component.priority = data.priority;
			if (data.screenSpace !== undefined) component.screenSpace = data.screenSpace;
			component.cull = component.screenSpace;
			if (data.scaleMode !== undefined) component.scaleMode = data.scaleMode;
			if (data.scaleBlend !== undefined) component.scaleBlend = data.scaleBlend;
			if (data.resolution !== undefined) {
				if (data.resolution instanceof Vec2) {
					component._resolution.copy(data.resolution);
				} else {
					component._resolution.set(data.resolution[0], data.resolution[1]);
				}
				component.resolution = component._resolution;
			}
			if (data.referenceResolution !== undefined) {
				if (data.referenceResolution instanceof Vec2) {
					component._referenceResolution.copy(data.referenceResolution);
				} else {
					component._referenceResolution.set(data.referenceResolution[0], data.referenceResolution[1]);
				}
				component.referenceResolution = component._referenceResolution;
			}
			component.syncDrawOrder();
			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
		};
		_proto.destroy = function destroy() {
			_ComponentSystem.prototype.destroy.call(this);
			this.app.graphicsDevice.off('resizecanvas', this._onResize, this);
			this.app.systems.off('update', this._onUpdate, this);
		};
		_proto._onUpdate = function _onUpdate(dt) {
			var components = this.store;
			for (var id in components) {
				if (components[id].entity.screen.update) components[id].entity.screen.update(dt);
			}
		};
		_proto._onResize = function _onResize(width, height) {
			this.windowResolution.x = width;
			this.windowResolution.y = height;
		};
		_proto.cloneComponent = function cloneComponent(entity, clone) {
			var screen = entity.screen;
			return this.addComponent(clone, {
				enabled: screen.enabled,
				screenSpace: screen.screenSpace,
				scaleMode: screen.scaleMode,
				resolution: screen.resolution.clone(),
				referenceResolution: screen.referenceResolution.clone()
			});
		};
		_proto.onRemoveComponent = function onRemoveComponent(entity, component) {
			component.onRemove();
		};
		_proto.processDrawOrderSyncQueue = function processDrawOrderSyncQueue() {
			var list = this._drawOrderSyncQueue.list();
			for (var i = 0; i < list.length; i++) {
				var item = list[i];
				item.callback.call(item.scope);
			}
			this._drawOrderSyncQueue.clear();
		};
		_proto.queueDrawOrderSync = function queueDrawOrderSync(id, fn, scope) {
			if (!this._drawOrderSyncQueue.list().length) {
				this.app.once('prerender', this.processDrawOrderSyncQueue, this);
			}
			if (!this._drawOrderSyncQueue.has(id)) {
				this._drawOrderSyncQueue.push(id, {
					callback: fn,
					scope: scope
				});
			}
		};
		return ScreenComponentSystem;
	}(ComponentSystem);
	Component._buildAccessors(ScreenComponent.prototype, _schema$7);

	var ScriptLegacyComponent = function (_Component) {
		_inheritsLoose(ScriptLegacyComponent, _Component);
		function ScriptLegacyComponent(system, entity) {
			var _this;
			_this = _Component.call(this, system, entity) || this;
			_this.on('set_scripts', _this.onSetScripts, _assertThisInitialized(_this));
			return _this;
		}
		var _proto = ScriptLegacyComponent.prototype;
		_proto.send = function send(name, functionName) {
			var args = Array.prototype.slice.call(arguments, 2);
			var instances = this.entity.script.instances;
			var fn;
			if (instances && instances[name]) {
				fn = instances[name].instance[functionName];
				if (fn) {
					return fn.apply(instances[name].instance, args);
				}
			}
			return undefined;
		};
		_proto.onEnable = function onEnable() {
			if (this.data.areScriptsLoaded && !this.system.preloading) {
				if (!this.data.initialized) {
					this.system._initializeScriptComponent(this);
				} else {
					this.system._enableScriptComponent(this);
				}
				if (!this.data.postInitialized) {
					this.system._postInitializeScriptComponent(this);
				}
			}
		};
		_proto.onDisable = function onDisable() {
			this.system._disableScriptComponent(this);
		};
		_proto.onSetScripts = function onSetScripts(name, oldValue, newValue) {
			if (!this.system._inTools || this.runInTools) {
				if (this._updateScriptAttributes(oldValue, newValue)) {
					return;
				}
				if (this.enabled) {
					this.system._disableScriptComponent(this);
				}
				this.system._destroyScriptComponent(this);
				this.data.areScriptsLoaded = false;
				var scripts = newValue;
				var urls = scripts.map(function (s) {
					return s.url;
				});
				if (this._loadFromCache(urls)) {
					return;
				}
				this._loadScripts(urls);
			}
		};
		_proto._updateScriptAttributes = function _updateScriptAttributes(oldValue, newValue) {
			var onlyUpdateAttributes = true;
			if (oldValue.length !== newValue.length) {
				onlyUpdateAttributes = false;
			} else {
				for (var i = 0, len = newValue.length; i < len; i++) {
					if (oldValue[i].url !== newValue[i].url) {
						onlyUpdateAttributes = false;
						break;
					}
				}
			}
			if (onlyUpdateAttributes) {
				for (var key in this.instances) {
					if (this.instances.hasOwnProperty(key)) {
						this.system._updateAccessors(this.entity, this.instances[key]);
					}
				}
			}
			return onlyUpdateAttributes;
		};
		_proto._loadFromCache = function _loadFromCache(urls) {
			var cached = [];
			var prefix = this.system.app._scriptPrefix || '';
			var regex = /^http(s)?:\/\//i;
			for (var i = 0, len = urls.length; i < len; i++) {
				var url = urls[i];
				if (!regex.test(url)) {
					url = path.join(prefix, url);
				}
				var type = this.system.app.loader.getFromCache(url, 'script');
				if (!type) {
					return false;
				}
				cached.push(type);
			}
			for (var _i = 0, _len = cached.length; _i < _len; _i++) {
				var ScriptType = cached[_i];
				if (ScriptType === true) {
					continue;
				}
				if (ScriptType && this.entity.script) {
					if (!this.entity.script.instances[ScriptType._pcScriptName]) {
						var instance = new ScriptType(this.entity);
						this.system._preRegisterInstance(this.entity, urls[_i], ScriptType._pcScriptName, instance);
					}
				}
			}
			if (this.data) {
				this.data.areScriptsLoaded = true;
			}
			if (!this.system.preloading) {
				this.system.onInitialize(this.entity);
				this.system.onPostInitialize(this.entity);
			}
			return true;
		};
		_proto._loadScripts = function _loadScripts(urls) {
			var _this2 = this;
			var count = urls.length;
			var prefix = this.system.app._scriptPrefix || '';
			urls.forEach(function (url) {
				var _url = null;
				var _unprefixed = null;
				if (url.toLowerCase().startsWith('http://') || url.toLowerCase().startsWith('https://')) {
					_unprefixed = url;
					_url = url;
				} else {
					_unprefixed = url;
					_url = path.join(prefix, url);
				}
				_this2.system.app.loader.load(_url, 'script', function (err, ScriptType) {
					count--;
					if (!err) {
						if (ScriptType && _this2.entity.script) {
							if (!_this2.entity.script.instances[ScriptType._pcScriptName]) {
								var instance = new ScriptType(_this2.entity);
								_this2.system._preRegisterInstance(_this2.entity, _unprefixed, ScriptType._pcScriptName, instance);
							}
						}
					} else {
						console.error(err);
					}
					if (count === 0) {
						_this2.data.areScriptsLoaded = true;
						if (!_this2.system.preloading) {
							_this2.system.onInitialize(_this2.entity);
							_this2.system.onPostInitialize(_this2.entity);
						}
					}
				});
			});
		};
		return ScriptLegacyComponent;
	}(Component);

	var ScriptLegacyComponentData = function ScriptLegacyComponentData() {
		this.scripts = [];
		this.enabled = true;
		this.instances = {};
		this._instances = {};
		this.runInTools = false;
		this.attributes = {};
		this.initialized = false;
		this.postInitialized = false;
		this.areScriptsLoaded = false;
	};

	var _schema$6 = ['enabled', 'scripts', 'instances', 'runInTools'];
	var INITIALIZE = 'initialize';
	var POST_INITIALIZE = 'postInitialize';
	var UPDATE = 'update';
	var POST_UPDATE = 'postUpdate';
	var FIXED_UPDATE = 'fixedUpdate';
	var TOOLS_UPDATE = 'toolsUpdate';
	var ON_ENABLE = 'onEnable';
	var ON_DISABLE = 'onDisable';
	var ScriptLegacyComponentSystem = function (_ComponentSystem) {
		_inheritsLoose(ScriptLegacyComponentSystem, _ComponentSystem);
		function ScriptLegacyComponentSystem(app) {
			var _this;
			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'script';
			_this.ComponentType = ScriptLegacyComponent;
			_this.DataType = ScriptLegacyComponentData;
			_this.schema = _schema$6;
			_this.preloading = false;
			_this.instancesWithUpdate = [];
			_this.instancesWithFixedUpdate = [];
			_this.instancesWithPostUpdate = [];
			_this.instancesWithToolsUpdate = [];
			_this.on('beforeremove', _this.onBeforeRemove, _assertThisInitialized(_this));
			_this.app.systems.on(INITIALIZE, _this.onInitialize, _assertThisInitialized(_this));
			_this.app.systems.on(POST_INITIALIZE, _this.onPostInitialize, _assertThisInitialized(_this));
			_this.app.systems.on(UPDATE, _this.onUpdate, _assertThisInitialized(_this));
			_this.app.systems.on(FIXED_UPDATE, _this.onFixedUpdate, _assertThisInitialized(_this));
			_this.app.systems.on(POST_UPDATE, _this.onPostUpdate, _assertThisInitialized(_this));
			_this.app.systems.on(TOOLS_UPDATE, _this.onToolsUpdate, _assertThisInitialized(_this));
			return _this;
		}
		var _proto = ScriptLegacyComponentSystem.prototype;
		_proto.initializeComponentData = function initializeComponentData(component, data, properties) {
			properties = ['runInTools', 'enabled', 'scripts'];
			if (data.scripts && data.scripts.length) {
				data.scripts.forEach(function (script) {
					if (script.attributes && Array.isArray(script.attributes)) {
						var dict = {};
						for (var i = 0; i < script.attributes.length; i++) {
							dict[script.attributes[i].name] = script.attributes[i];
						}
						script.attributes = dict;
					}
				});
			}
			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
		};
		_proto.cloneComponent = function cloneComponent(entity, clone) {
			var src = this.store[entity.getGuid()];
			var data = {
				runInTools: src.data.runInTools,
				scripts: [],
				enabled: src.data.enabled
			};
			var scripts = src.data.scripts;
			for (var i = 0, len = scripts.length; i < len; i++) {
				var attributes = scripts[i].attributes;
				if (attributes) {
					delete scripts[i].attributes;
				}
				data.scripts.push(extend({}, scripts[i]));
				if (attributes) {
					data.scripts[i].attributes = this._cloneAttributes(attributes);
					scripts[i].attributes = attributes;
				}
			}
			return this.addComponent(clone, data);
		};
		_proto.onBeforeRemove = function onBeforeRemove(entity, component) {
			if (component.enabled) {
				this._disableScriptComponent(component);
			}
			this._destroyScriptComponent(component);
		};
		_proto.onInitialize = function onInitialize(root) {
			this._registerInstances(root);
			if (root.enabled) {
				if (root.script && root.script.enabled) {
					this._initializeScriptComponent(root.script);
				}
				var children = root._children;
				for (var i = 0, len = children.length; i < len; i++) {
					if (children[i] instanceof Entity) {
						this.onInitialize(children[i]);
					}
				}
			}
		};
		_proto.onPostInitialize = function onPostInitialize(root) {
			if (root.enabled) {
				if (root.script && root.script.enabled) {
					this._postInitializeScriptComponent(root.script);
				}
				var children = root._children;
				for (var i = 0, len = children.length; i < len; i++) {
					if (children[i] instanceof Entity) {
						this.onPostInitialize(children[i]);
					}
				}
			}
		};
		_proto._callInstancesMethod = function _callInstancesMethod(script, method) {
			var instances = script.data.instances;
			for (var name in instances) {
				if (instances.hasOwnProperty(name)) {
					var instance = instances[name].instance;
					if (instance[method]) {
						instance[method]();
					}
				}
			}
		};
		_proto._initializeScriptComponent = function _initializeScriptComponent(script) {
			this._callInstancesMethod(script, INITIALIZE);
			script.data.initialized = true;
			if (script.enabled && script.entity.enabled) {
				this._enableScriptComponent(script);
			}
		};
		_proto._enableScriptComponent = function _enableScriptComponent(script) {
			this._callInstancesMethod(script, ON_ENABLE);
		};
		_proto._disableScriptComponent = function _disableScriptComponent(script) {
			this._callInstancesMethod(script, ON_DISABLE);
		};
		_proto._destroyScriptComponent = function _destroyScriptComponent(script) {
			var instances = script.data.instances;
			for (var name in instances) {
				if (instances.hasOwnProperty(name)) {
					var instance = instances[name].instance;
					if (instance.destroy) {
						instance.destroy();
					}
					if (instance.update) {
						var index = this.instancesWithUpdate.indexOf(instance);
						if (index >= 0) {
							this.instancesWithUpdate.splice(index, 1);
						}
					}
					if (instance.fixedUpdate) {
						var _index = this.instancesWithFixedUpdate.indexOf(instance);
						if (_index >= 0) {
							this.instancesWithFixedUpdate.splice(_index, 1);
						}
					}
					if (instance.postUpdate) {
						var _index2 = this.instancesWithPostUpdate.indexOf(instance);
						if (_index2 >= 0) {
							this.instancesWithPostUpdate.splice(_index2, 1);
						}
					}
					if (instance.toolsUpdate) {
						var _index3 = this.instancesWithToolsUpdate.indexOf(instance);
						if (_index3 >= 0) {
							this.instancesWithToolsUpdate.splice(_index3, 1);
						}
					}
					if (script.instances[name].instance === script[name]) {
						delete script[name];
					}
					delete script.instances[name];
				}
			}
		};
		_proto._postInitializeScriptComponent = function _postInitializeScriptComponent(script) {
			this._callInstancesMethod(script, POST_INITIALIZE);
			script.data.postInitialized = true;
		};
		_proto._updateInstances = function _updateInstances(method, updateList, dt) {
			for (var i = 0, len = updateList.length; i < len; i++) {
				var item = updateList[i];
				if (item && item.entity && item.entity.enabled && item.entity.script.enabled) {
					item[method](dt);
				}
			}
		};
		_proto.onUpdate = function onUpdate(dt) {
			this._updateInstances(UPDATE, this.instancesWithUpdate, dt);
		};
		_proto.onFixedUpdate = function onFixedUpdate(dt) {
			this._updateInstances(FIXED_UPDATE, this.instancesWithFixedUpdate, dt);
		};
		_proto.onPostUpdate = function onPostUpdate(dt) {
			this._updateInstances(POST_UPDATE, this.instancesWithPostUpdate, dt);
		};
		_proto.onToolsUpdate = function onToolsUpdate(dt) {
			this._updateInstances(TOOLS_UPDATE, this.instancesWithToolsUpdate, dt);
		};
		_proto.broadcast = function broadcast(name, functionName) {
			var args = Array.prototype.slice.call(arguments, 2);
			var dataStore = this.store;
			for (var id in dataStore) {
				if (dataStore.hasOwnProperty(id)) {
					var data = dataStore[id].data;
					if (data.instances[name]) {
						var fn = data.instances[name].instance[functionName];
						if (fn) {
							fn.apply(data.instances[name].instance, args);
						}
					}
				}
			}
		};
		_proto._preRegisterInstance = function _preRegisterInstance(entity, url, name, instance) {
			if (entity.script) {
				entity.script.data._instances = entity.script.data._instances || {};
				if (entity.script.data._instances[name]) {
					throw Error("Script name collision '" + name + "'. Scripts from '" + url + "' and '" + entity.script.data._instances[name].url + "' {" + entity.getGuid() + "}");
				}
				entity.script.data._instances[name] = {
					url: url,
					name: name,
					instance: instance
				};
			}
		};
		_proto._registerInstances = function _registerInstances(entity) {
			if (entity.script) {
				if (entity.script.data._instances) {
					entity.script.instances = entity.script.data._instances;
					for (var instanceName in entity.script.instances) {
						var preRegistered = entity.script.instances[instanceName];
						var instance = preRegistered.instance;
						events.attach(instance);
						if (instance.update) {
							this.instancesWithUpdate.push(instance);
						}
						if (instance.fixedUpdate) {
							this.instancesWithFixedUpdate.push(instance);
						}
						if (instance.postUpdate) {
							this.instancesWithPostUpdate.push(instance);
						}
						if (instance.toolsUpdate) {
							this.instancesWithToolsUpdate.push(instance);
						}
						if (entity.script.scripts) {
							this._createAccessors(entity, preRegistered);
						}
						if (entity.script[instanceName]) {
							throw Error("Script with name '" + instanceName + "' is already attached to Script Component");
						} else {
							entity.script[instanceName] = instance;
						}
					}
					delete entity.script.data._instances;
				}
			}
			var children = entity._children;
			for (var i = 0, len = children.length; i < len; i++) {
				if (children[i] instanceof Entity) {
					this._registerInstances(children[i]);
				}
			}
		};
		_proto._cloneAttributes = function _cloneAttributes(attributes) {
			var result = {};
			for (var key in attributes) {
				if (!attributes.hasOwnProperty(key)) continue;
				if (attributes[key].type !== 'entity') {
					result[key] = extend({}, attributes[key]);
				} else {
					var val = attributes[key].value;
					delete attributes[key].value;
					result[key] = extend({}, attributes[key]);
					result[key].value = val;
					attributes[key].value = val;
				}
			}
			return result;
		};
		_proto._createAccessors = function _createAccessors(entity, instance) {
			var len = entity.script.scripts.length;
			var url = instance.url;
			for (var i = 0; i < len; i++) {
				var script = entity.script.scripts[i];
				if (script.url === url) {
					var attributes = script.attributes;
					if (script.name && attributes) {
						for (var key in attributes) {
							if (attributes.hasOwnProperty(key)) {
								this._createAccessor(attributes[key], instance);
							}
						}
						entity.script.data.attributes[script.name] = this._cloneAttributes(attributes);
					}
					break;
				}
			}
		};
		_proto._createAccessor = function _createAccessor(attribute, instance) {
			var self = this;
			attribute = {
				name: attribute.name,
				value: attribute.value,
				type: attribute.type
			};
			this._convertAttributeValue(attribute);
			Object.defineProperty(instance.instance, attribute.name, {
				get: function get() {
					return attribute.value;
				},
				set: function set(value) {
					var oldValue = attribute.value;
					attribute.value = value;
					self._convertAttributeValue(attribute);
					instance.instance.fire('set', attribute.name, oldValue, attribute.value);
				},
				configurable: true
			});
		};
		_proto._updateAccessors = function _updateAccessors(entity, instance) {
			var len = entity.script.scripts.length;
			var url = instance.url;
			for (var i = 0; i < len; i++) {
				var scriptComponent = entity.script;
				var script = scriptComponent.scripts[i];
				if (script.url === url) {
					var name = script.name;
					var attributes = script.attributes;
					if (name) {
						if (attributes) {
							for (var key in attributes) {
								if (attributes.hasOwnProperty(key)) {
									this._createAccessor(attributes[key], instance);
								}
							}
						}
						var previousAttributes = scriptComponent.data.attributes[name];
						if (previousAttributes) {
							for (var _key in previousAttributes) {
								var oldAttribute = previousAttributes[_key];
								if (!(_key in attributes)) {
									delete instance.instance[oldAttribute.name];
								} else {
									if (attributes[_key].value !== oldAttribute.value) {
										if (instance.instance.onAttributeChanged) {
											instance.instance.onAttributeChanged(oldAttribute.name, oldAttribute.value, attributes[_key].value);
										}
									}
								}
							}
						}
						if (attributes) {
							scriptComponent.data.attributes[name] = this._cloneAttributes(attributes);
						} else {
							delete scriptComponent.data.attributes[name];
						}
					}
					break;
				}
			}
		};
		_proto._convertAttributeValue = function _convertAttributeValue(attribute) {
			if (attribute.type === 'rgb' || attribute.type === 'rgba') {
				if (Array.isArray(attribute.value)) {
					attribute.value = attribute.value.length === 3 ? new Color(attribute.value[0], attribute.value[1], attribute.value[2]) : new Color(attribute.value[0], attribute.value[1], attribute.value[2], attribute.value[3]);
				}
			} else if (attribute.type === 'vec2') {
				if (Array.isArray(attribute.value)) attribute.value = new Vec2(attribute.value[0], attribute.value[1]);
			} else if (attribute.type === 'vec3' || attribute.type === 'vector') {
				if (Array.isArray(attribute.value)) attribute.value = new Vec3(attribute.value[0], attribute.value[1], attribute.value[2]);
			} else if (attribute.type === 'vec4') {
				if (Array.isArray(attribute.value)) attribute.value = new Vec4(attribute.value[0], attribute.value[1], attribute.value[2], attribute.value[3]);
			} else if (attribute.type === 'entity') {
				if (attribute.value !== null && typeof attribute.value === 'string') attribute.value = this.app.root.findByGuid(attribute.value);
			} else if (attribute.type === 'curve' || attribute.type === 'colorcurve') {
				var curveType = attribute.value.keys[0] instanceof Array ? CurveSet : Curve;
				attribute.value = new curveType(attribute.value.keys);
				attribute.value.type = attribute.value.type;
			}
		};
		_proto.destroy = function destroy() {
			_ComponentSystem.prototype.destroy.call(this);
			this.app.systems.off(INITIALIZE, this.onInitialize, this);
			this.app.systems.off(POST_INITIALIZE, this.onPostInitialize, this);
			this.app.systems.off(UPDATE, this.onUpdate, this);
			this.app.systems.off(FIXED_UPDATE, this.onFixedUpdate, this);
			this.app.systems.off(POST_UPDATE, this.onPostUpdate, this);
			this.app.systems.off(TOOLS_UPDATE, this.onToolsUpdate, this);
		};
		return ScriptLegacyComponentSystem;
	}(ComponentSystem);
	Component._buildAccessors(ScriptLegacyComponent.prototype, _schema$6);

	var _inputScreenPosition = new Vec2();
	var _inputWorldPosition = new Vec3();
	var _ray = new Ray();
	var _plane = new Plane();
	var _normal = new Vec3();
	var _point = new Vec3();
	var _entityRotation = new Quat();
	var OPPOSITE_AXIS = {
		x: 'y',
		y: 'x'
	};
	var ElementDragHelper = function (_EventHandler) {
		_inheritsLoose(ElementDragHelper, _EventHandler);
		function ElementDragHelper(element, axis) {
			var _this;
			_this = _EventHandler.call(this) || this;
			if (!element || !(element instanceof ElementComponent)) {
				throw new Error('Element was null or not an ElementComponent');
			}
			if (axis && axis !== 'x' && axis !== 'y') {
				throw new Error('Unrecognized axis: ' + axis);
			}
			_this._element = element;
			_this._app = element.system.app;
			_this._axis = axis || null;
			_this._enabled = true;
			_this._dragScale = new Vec3();
			_this._dragStartMousePosition = new Vec3();
			_this._dragStartHandlePosition = new Vec3();
			_this._deltaMousePosition = new Vec3();
			_this._deltaHandlePosition = new Vec3();
			_this._isDragging = false;
			_this._toggleLifecycleListeners('on');
			return _this;
		}
		var _proto = ElementDragHelper.prototype;
		_proto._toggleLifecycleListeners = function _toggleLifecycleListeners(onOrOff) {
			this._element[onOrOff]('mousedown', this._onMouseDownOrTouchStart, this);
			this._element[onOrOff]('touchstart', this._onMouseDownOrTouchStart, this);
			this._element[onOrOff]('selectstart', this._onMouseDownOrTouchStart, this);
		};
		_proto._toggleDragListeners = function _toggleDragListeners(onOrOff) {
			var isOn = onOrOff === 'on';
			if (this._hasDragListeners && isOn) {
				return;
			}
			if (this._app.mouse) {
				this._element[onOrOff]('mousemove', this._onMove, this);
				this._element[onOrOff]('mouseup', this._onMouseUpOrTouchEnd, this);
			}
			if (platform.touch) {
				this._element[onOrOff]('touchmove', this._onMove, this);
				this._element[onOrOff]('touchend', this._onMouseUpOrTouchEnd, this);
				this._element[onOrOff]('touchcancel', this._onMouseUpOrTouchEnd, this);
			}
			this._element[onOrOff]('selectmove', this._onMove, this);
			this._element[onOrOff]('selectend', this._onMouseUpOrTouchEnd, this);
			this._hasDragListeners = isOn;
		};
		_proto._onMouseDownOrTouchStart = function _onMouseDownOrTouchStart(event) {
			if (this._element && !this._isDragging && this.enabled) {
				this._dragCamera = event.camera;
				this._calculateDragScale();
				var currentMousePosition = this._screenToLocal(event);
				if (currentMousePosition) {
					this._toggleDragListeners('on');
					this._isDragging = true;
					this._dragStartMousePosition.copy(currentMousePosition);
					this._dragStartHandlePosition.copy(this._element.entity.getLocalPosition());
					this.fire('drag:start');
				}
			}
		};
		_proto._onMouseUpOrTouchEnd = function _onMouseUpOrTouchEnd() {
			if (this._isDragging) {
				this._isDragging = false;
				this._toggleDragListeners('off');
				this.fire('drag:end');
			}
		};
		_proto._screenToLocal = function _screenToLocal(event) {
			if (event.inputSource) {
				_ray.set(event.inputSource.getOrigin(), event.inputSource.getDirection());
			} else {
				this._determineInputPosition(event);
				this._chooseRayOriginAndDirection();
			}
			_normal.copy(this._element.entity.forward).mulScalar(-1);
			_plane.setFromPointNormal(this._element.entity.getPosition(), _normal);
			if (_plane.intersectsRay(_ray, _point)) {
				_entityRotation.copy(this._element.entity.getRotation()).invert().transformVector(_point, _point);
				_point.mul(this._dragScale);
				return _point;
			}
			return null;
		};
		_proto._determineInputPosition = function _determineInputPosition(event) {
			var devicePixelRatio = this._app.graphicsDevice.maxPixelRatio;
			if (typeof event.x !== 'undefined' && typeof event.y !== 'undefined') {
				_inputScreenPosition.x = event.x * devicePixelRatio;
				_inputScreenPosition.y = event.y * devicePixelRatio;
			} else if (event.changedTouches) {
				_inputScreenPosition.x = event.changedTouches[0].x * devicePixelRatio;
				_inputScreenPosition.y = event.changedTouches[0].y * devicePixelRatio;
			} else {
				console.warn('Could not determine position from input event');
			}
		};
		_proto._chooseRayOriginAndDirection = function _chooseRayOriginAndDirection() {
			if (this._element.screen && this._element.screen.screen.screenSpace) {
				_ray.origin.set(_inputScreenPosition.x, -_inputScreenPosition.y, 0);
				_ray.direction.copy(Vec3.FORWARD);
			} else {
				_inputWorldPosition.copy(this._dragCamera.screenToWorld(_inputScreenPosition.x, _inputScreenPosition.y, 1));
				_ray.origin.copy(this._dragCamera.entity.getPosition());
				_ray.direction.copy(_inputWorldPosition).sub(_ray.origin).normalize();
			}
		};
		_proto._calculateDragScale = function _calculateDragScale() {
			var current = this._element.entity.parent;
			var screen = this._element.screen && this._element.screen.screen;
			var isWithin2DScreen = screen && screen.screenSpace;
			var screenScale = isWithin2DScreen ? screen.scale : 1;
			var dragScale = this._dragScale;
			dragScale.set(screenScale, screenScale, screenScale);
			while (current) {
				dragScale.mul(current.getLocalScale());
				current = current.parent;
				if (isWithin2DScreen && current.screen) {
					break;
				}
			}
			dragScale.x = 1 / dragScale.x;
			dragScale.y = 1 / dragScale.y;
			dragScale.z = 0;
		};
		_proto._onMove = function _onMove(event) {
			var element = this._element,
				deltaMousePosition = this._deltaMousePosition,
				deltaHandlePosition = this._deltaHandlePosition,
				axis = this._axis;
			if (element && this._isDragging && this.enabled && element.enabled && element.entity.enabled) {
				var currentMousePosition = this._screenToLocal(event);
				if (currentMousePosition) {
					deltaMousePosition.sub2(currentMousePosition, this._dragStartMousePosition);
					deltaHandlePosition.add2(this._dragStartHandlePosition, deltaMousePosition);
					if (axis) {
						var currentPosition = element.entity.getLocalPosition();
						var constrainedAxis = OPPOSITE_AXIS[axis];
						deltaHandlePosition[constrainedAxis] = currentPosition[constrainedAxis];
					}
					element.entity.setLocalPosition(deltaHandlePosition);
					this.fire('drag:move', deltaHandlePosition);
				}
			}
		};
		_proto.destroy = function destroy() {
			this._toggleLifecycleListeners('off');
			this._toggleDragListeners('off');
		};
		_createClass(ElementDragHelper, [{
			key: "enabled",
			get: function get() {
				return this._enabled;
			},
			set: function set(value) {
				this._enabled = value;
			}
		}, {
			key: "isDragging",
			get: function get() {
				return this._isDragging;
			}
		}]);
		return ElementDragHelper;
	}(EventHandler);

	var SCROLL_MODE_CLAMP = 0;
	var SCROLL_MODE_BOUNCE = 1;
	var SCROLL_MODE_INFINITE = 2;
	var SCROLLBAR_VISIBILITY_SHOW_ALWAYS = 0;
	var SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED = 1;

	var _tempScrollValue = new Vec2();
	var ScrollViewComponent = function (_Component) {
		_inheritsLoose(ScrollViewComponent, _Component);
		function ScrollViewComponent(system, entity) {
			var _this;
			_this = _Component.call(this, system, entity) || this;
			_this._viewportReference = new EntityReference(_assertThisInitialized(_this), 'viewportEntity', {
				'element#gain': _this._onViewportElementGain,
				'element#resize': _this._onSetContentOrViewportSize
			});
			_this._contentReference = new EntityReference(_assertThisInitialized(_this), 'contentEntity', {
				'element#gain': _this._onContentElementGain,
				'element#lose': _this._onContentElementLose,
				'element#resize': _this._onSetContentOrViewportSize
			});
			_this._scrollbarUpdateFlags = {};
			_this._scrollbarReferences = {};
			_this._scrollbarReferences[ORIENTATION_HORIZONTAL] = new EntityReference(_assertThisInitialized(_this), 'horizontalScrollbarEntity', {
				'scrollbar#set:value': _this._onSetHorizontalScrollbarValue,
				'scrollbar#gain': _this._onHorizontalScrollbarGain
			});
			_this._scrollbarReferences[ORIENTATION_VERTICAL] = new EntityReference(_assertThisInitialized(_this), 'verticalScrollbarEntity', {
				'scrollbar#set:value': _this._onSetVerticalScrollbarValue,
				'scrollbar#gain': _this._onVerticalScrollbarGain
			});
			_this._prevContentSizes = {};
			_this._prevContentSizes[ORIENTATION_HORIZONTAL] = null;
			_this._prevContentSizes[ORIENTATION_VERTICAL] = null;
			_this._scroll = new Vec2();
			_this._velocity = new Vec3();
			_this._dragStartPosition = new Vec3();
			_this._disabledContentInput = false;
			_this._disabledContentInputEntities = [];
			_this._toggleLifecycleListeners('on', system);
			_this._toggleElementListeners('on');
			return _this;
		}
		var _proto = ScrollViewComponent.prototype;
		_proto._toggleLifecycleListeners = function _toggleLifecycleListeners(onOrOff, system) {
			this[onOrOff]('set_horizontal', this._onSetHorizontalScrollingEnabled, this);
			this[onOrOff]('set_vertical', this._onSetVerticalScrollingEnabled, this);
			system.app.systems.element[onOrOff]('add', this._onElementComponentAdd, this);
			system.app.systems.element[onOrOff]('beforeremove', this._onElementComponentRemove, this);
		};
		_proto._toggleElementListeners = function _toggleElementListeners(onOrOff) {
			if (this.entity.element) {
				if (onOrOff === 'on' && this._hasElementListeners) {
					return;
				}
				this.entity.element[onOrOff]('resize', this._onSetContentOrViewportSize, this);
				this.entity.element[onOrOff](EVENT_MOUSEWHEEL, this._onMouseWheel, this);
				this._hasElementListeners = onOrOff === 'on';
			}
		};
		_proto._onElementComponentAdd = function _onElementComponentAdd(entity) {
			if (this.entity === entity) {
				this._toggleElementListeners('on');
			}
		};
		_proto._onElementComponentRemove = function _onElementComponentRemove(entity) {
			if (this.entity === entity) {
				this._toggleElementListeners('off');
			}
		};
		_proto._onViewportElementGain = function _onViewportElementGain() {
			this._syncAll();
		};
		_proto._onContentElementGain = function _onContentElementGain() {
			this._destroyDragHelper();
			this._contentDragHelper = new ElementDragHelper(this._contentReference.entity.element);
			this._contentDragHelper.on('drag:start', this._onContentDragStart, this);
			this._contentDragHelper.on('drag:end', this._onContentDragEnd, this);
			this._contentDragHelper.on('drag:move', this._onContentDragMove, this);
			this._prevContentSizes[ORIENTATION_HORIZONTAL] = null;
			this._prevContentSizes[ORIENTATION_VERTICAL] = null;
			this._syncAll();
		};
		_proto._onContentElementLose = function _onContentElementLose() {
			this._destroyDragHelper();
		};
		_proto._onContentDragStart = function _onContentDragStart() {
			if (this._contentReference.entity && this.enabled && this.entity.enabled) {
				this._dragStartPosition.copy(this._contentReference.entity.getLocalPosition());
			}
		};
		_proto._onContentDragEnd = function _onContentDragEnd() {
			this._prevContentDragPosition = null;
			this._enableContentInput();
		};
		_proto._onContentDragMove = function _onContentDragMove(position) {
			if (this._contentReference.entity && this.enabled && this.entity.enabled) {
				this._wasDragged = true;
				this._setScrollFromContentPosition(position);
				this._setVelocityFromContentPositionDelta(position);
				if (!this._disabledContentInput) {
					var dx = position.x - this._dragStartPosition.x;
					var dy = position.y - this._dragStartPosition.y;
					if (Math.abs(dx) > this.dragThreshold || Math.abs(dy) > this.dragThreshold) {
						this._disableContentInput();
					}
				}
			}
		};
		_proto._onSetContentOrViewportSize = function _onSetContentOrViewportSize() {
			this._syncAll();
		};
		_proto._onSetHorizontalScrollbarValue = function _onSetHorizontalScrollbarValue(scrollValueX) {
			if (!this._scrollbarUpdateFlags[ORIENTATION_HORIZONTAL] && this.enabled && this.entity.enabled) {
				this._onSetScroll(scrollValueX, null);
			}
		};
		_proto._onSetVerticalScrollbarValue = function _onSetVerticalScrollbarValue(scrollValueY) {
			if (!this._scrollbarUpdateFlags[ORIENTATION_VERTICAL] && this.enabled && this.entity.enabled) {
				this._onSetScroll(null, scrollValueY);
			}
		};
		_proto._onSetHorizontalScrollingEnabled = function _onSetHorizontalScrollingEnabled() {
			this._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);
		};
		_proto._onSetVerticalScrollingEnabled = function _onSetVerticalScrollingEnabled() {
			this._syncScrollbarEnabledState(ORIENTATION_VERTICAL);
		};
		_proto._onHorizontalScrollbarGain = function _onHorizontalScrollbarGain() {
			this._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);
			this._syncScrollbarPosition(ORIENTATION_HORIZONTAL);
		};
		_proto._onVerticalScrollbarGain = function _onVerticalScrollbarGain() {
			this._syncScrollbarEnabledState(ORIENTATION_VERTICAL);
			this._syncScrollbarPosition(ORIENTATION_VERTICAL);
		};
		_proto._onSetScroll = function _onSetScroll(x, y, resetVelocity) {
			if (resetVelocity !== false) {
				this._velocity.set(0, 0, 0);
			}
			var xChanged = this._updateAxis(x, 'x', ORIENTATION_HORIZONTAL);
			var yChanged = this._updateAxis(y, 'y', ORIENTATION_VERTICAL);
			if (xChanged || yChanged) {
				this.fire('set:scroll', this._scroll);
			}
		};
		_proto._updateAxis = function _updateAxis(scrollValue, axis, orientation) {
			var hasChanged = scrollValue !== null && Math.abs(scrollValue - this._scroll[axis]) > 1e-5;
			if (hasChanged || this._isDragging() || scrollValue === 0) {
				this._scroll[axis] = this._determineNewScrollValue(scrollValue, axis, orientation);
				this._syncContentPosition(orientation);
				this._syncScrollbarPosition(orientation);
			}
			return hasChanged;
		};
		_proto._determineNewScrollValue = function _determineNewScrollValue(scrollValue, axis, orientation) {
			if (!this._getScrollingEnabled(orientation)) {
				return this._scroll[axis];
			}
			switch (this.scrollMode) {
				case SCROLL_MODE_CLAMP:
					return math.clamp(scrollValue, 0, this._getMaxScrollValue(orientation));
				case SCROLL_MODE_BOUNCE:
					this._setVelocityFromOvershoot(scrollValue, axis, orientation);
					return scrollValue;
				case SCROLL_MODE_INFINITE:
					return scrollValue;
				default:
					console.warn('Unhandled scroll mode:' + this.scrollMode);
					return scrollValue;
			}
		};
		_proto._syncAll = function _syncAll() {
			this._syncContentPosition(ORIENTATION_HORIZONTAL);
			this._syncContentPosition(ORIENTATION_VERTICAL);
			this._syncScrollbarPosition(ORIENTATION_HORIZONTAL);
			this._syncScrollbarPosition(ORIENTATION_VERTICAL);
			this._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);
			this._syncScrollbarEnabledState(ORIENTATION_VERTICAL);
		};
		_proto._syncContentPosition = function _syncContentPosition(orientation) {
			var axis = this._getAxis(orientation);
			var sign = this._getSign(orientation);
			var contentEntity = this._contentReference.entity;
			if (contentEntity) {
				var prevContentSize = this._prevContentSizes[orientation];
				var currContentSize = this._getContentSize(orientation);
				if (prevContentSize !== null && Math.abs(prevContentSize - currContentSize) > 1e-4) {
					var prevMaxOffset = this._getMaxOffset(orientation, prevContentSize);
					var currMaxOffset = this._getMaxOffset(orientation, currContentSize);
					if (currMaxOffset === 0) {
						this._scroll[axis] = 1;
					} else {
						this._scroll[axis] = math.clamp(this._scroll[axis] * prevMaxOffset / currMaxOffset, 0, 1);
					}
				}
				var offset = this._scroll[axis] * this._getMaxOffset(orientation);
				var contentPosition = contentEntity.getLocalPosition();
				contentPosition[axis] = offset * sign;
				contentEntity.setLocalPosition(contentPosition);
				this._prevContentSizes[orientation] = currContentSize;
			}
		};
		_proto._syncScrollbarPosition = function _syncScrollbarPosition(orientation) {
			var axis = this._getAxis(orientation);
			var scrollbarEntity = this._scrollbarReferences[orientation].entity;
			if (scrollbarEntity && scrollbarEntity.scrollbar) {
				this._scrollbarUpdateFlags[orientation] = true;
				scrollbarEntity.scrollbar.value = this._scroll[axis];
				scrollbarEntity.scrollbar.handleSize = this._getScrollbarHandleSize(axis, orientation);
				this._scrollbarUpdateFlags[orientation] = false;
			}
		};
		_proto._syncScrollbarEnabledState = function _syncScrollbarEnabledState(orientation) {
			var entity = this._scrollbarReferences[orientation].entity;
			if (entity) {
				var isScrollingEnabled = this._getScrollingEnabled(orientation);
				var requestedVisibility = this._getScrollbarVisibility(orientation);
				switch (requestedVisibility) {
					case SCROLLBAR_VISIBILITY_SHOW_ALWAYS:
						entity.enabled = isScrollingEnabled;
						return;
					case SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED:
						entity.enabled = isScrollingEnabled && this._contentIsLargerThanViewport(orientation);
						return;
					default:
						console.warn('Unhandled scrollbar visibility:' + requestedVisibility);
						entity.enabled = isScrollingEnabled;
				}
			}
		};
		_proto._contentIsLargerThanViewport = function _contentIsLargerThanViewport(orientation) {
			return this._getContentSize(orientation) > this._getViewportSize(orientation);
		};
		_proto._contentPositionToScrollValue = function _contentPositionToScrollValue(contentPosition) {
			var maxOffsetH = this._getMaxOffset(ORIENTATION_HORIZONTAL);
			var maxOffsetV = this._getMaxOffset(ORIENTATION_VERTICAL);
			if (maxOffsetH === 0) {
				_tempScrollValue.x = 0;
			} else {
				_tempScrollValue.x = contentPosition.x / maxOffsetH;
			}
			if (maxOffsetV === 0) {
				_tempScrollValue.y = 0;
			} else {
				_tempScrollValue.y = contentPosition.y / -maxOffsetV;
			}
			return _tempScrollValue;
		};
		_proto._getMaxOffset = function _getMaxOffset(orientation, contentSize) {
			contentSize = contentSize === undefined ? this._getContentSize(orientation) : contentSize;
			var viewportSize = this._getViewportSize(orientation);
			if (contentSize < viewportSize) {
				return -this._getViewportSize(orientation);
			}
			return viewportSize - contentSize;
		};
		_proto._getMaxScrollValue = function _getMaxScrollValue(orientation) {
			return this._contentIsLargerThanViewport(orientation) ? 1 : 0;
		};
		_proto._getScrollbarHandleSize = function _getScrollbarHandleSize(axis, orientation) {
			var viewportSize = this._getViewportSize(orientation);
			var contentSize = this._getContentSize(orientation);
			if (Math.abs(contentSize) < 0.001) {
				return 1;
			}
			var handleSize = Math.min(viewportSize / contentSize, 1);
			var overshoot = this._toOvershoot(this._scroll[axis], orientation);
			if (overshoot === 0) {
				return handleSize;
			}
			return handleSize / (1 + Math.abs(overshoot));
		};
		_proto._getViewportSize = function _getViewportSize(orientation) {
			return this._getSize(orientation, this._viewportReference);
		};
		_proto._getContentSize = function _getContentSize(orientation) {
			return this._getSize(orientation, this._contentReference);
		};
		_proto._getSize = function _getSize(orientation, entityReference) {
			if (entityReference.entity && entityReference.entity.element) {
				return entityReference.entity.element[this._getCalculatedDimension(orientation)];
			}
			return 0;
		};
		_proto._getScrollingEnabled = function _getScrollingEnabled(orientation) {
			if (orientation === ORIENTATION_HORIZONTAL) {
				return this.horizontal;
			} else if (orientation === ORIENTATION_VERTICAL) {
				return this.vertical;
			}
			return undefined;
		};
		_proto._getScrollbarVisibility = function _getScrollbarVisibility(orientation) {
			if (orientation === ORIENTATION_HORIZONTAL) {
				return this.horizontalScrollbarVisibility;
			} else if (orientation === ORIENTATION_VERTICAL) {
				return this.verticalScrollbarVisibility;
			}
			return undefined;
		};
		_proto._getSign = function _getSign(orientation) {
			return orientation === ORIENTATION_HORIZONTAL ? 1 : -1;
		};
		_proto._getAxis = function _getAxis(orientation) {
			return orientation === ORIENTATION_HORIZONTAL ? 'x' : 'y';
		};
		_proto._getCalculatedDimension = function _getCalculatedDimension(orientation) {
			return orientation === ORIENTATION_HORIZONTAL ? 'calculatedWidth' : 'calculatedHeight';
		};
		_proto._destroyDragHelper = function _destroyDragHelper() {
			if (this._contentDragHelper) {
				this._contentDragHelper.destroy();
			}
		};
		_proto.onUpdate = function onUpdate() {
			if (this._contentReference.entity) {
				this._updateVelocity();
				this._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);
				this._syncScrollbarEnabledState(ORIENTATION_VERTICAL);
			}
		};
		_proto._updateVelocity = function _updateVelocity() {
			if (!this._isDragging()) {
				if (this.scrollMode === SCROLL_MODE_BOUNCE) {
					if (this._hasOvershoot('x', ORIENTATION_HORIZONTAL)) {
						this._setVelocityFromOvershoot(this.scroll.x, 'x', ORIENTATION_HORIZONTAL);
					}
					if (this._hasOvershoot('y', ORIENTATION_VERTICAL)) {
						this._setVelocityFromOvershoot(this.scroll.y, 'y', ORIENTATION_VERTICAL);
					}
				}
				if (Math.abs(this._velocity.x) > 1e-4 || Math.abs(this._velocity.y) > 1e-4) {
					var position = this._contentReference.entity.getLocalPosition();
					position.x += this._velocity.x;
					position.y += this._velocity.y;
					this._contentReference.entity.setLocalPosition(position);
					this._setScrollFromContentPosition(position);
				}
				this._velocity.x *= 1 - this.friction;
				this._velocity.y *= 1 - this.friction;
			}
		};
		_proto._hasOvershoot = function _hasOvershoot(axis, orientation) {
			return Math.abs(this._toOvershoot(this.scroll[axis], orientation)) > 0.001;
		};
		_proto._toOvershoot = function _toOvershoot(scrollValue, orientation) {
			var maxScrollValue = this._getMaxScrollValue(orientation);
			if (scrollValue < 0) {
				return scrollValue;
			} else if (scrollValue > maxScrollValue) {
				return scrollValue - maxScrollValue;
			}
			return 0;
		};
		_proto._setVelocityFromOvershoot = function _setVelocityFromOvershoot(scrollValue, axis, orientation) {
			var overshootValue = this._toOvershoot(scrollValue, orientation);
			var overshootPixels = overshootValue * this._getMaxOffset(orientation) * this._getSign(orientation);
			if (Math.abs(overshootPixels) > 0) {
				this._velocity[axis] = -overshootPixels / (this.bounceAmount * 50 + 1);
			}
		};
		_proto._setVelocityFromContentPositionDelta = function _setVelocityFromContentPositionDelta(position) {
			if (this._prevContentDragPosition) {
				this._velocity.sub2(position, this._prevContentDragPosition);
				this._prevContentDragPosition.copy(position);
			} else {
				this._velocity.set(0, 0, 0);
				this._prevContentDragPosition = position.clone();
			}
		};
		_proto._setScrollFromContentPosition = function _setScrollFromContentPosition(position) {
			var scrollValue = this._contentPositionToScrollValue(position);
			if (this._isDragging()) {
				scrollValue = this._applyScrollValueTension(scrollValue);
			}
			this._onSetScroll(scrollValue.x, scrollValue.y, false);
		};
		_proto._applyScrollValueTension = function _applyScrollValueTension(scrollValue) {
			var factor = 1;
			var max = this._getMaxScrollValue(ORIENTATION_HORIZONTAL);
			var overshoot = this._toOvershoot(scrollValue.x, ORIENTATION_HORIZONTAL);
			if (overshoot > 0) {
				scrollValue.x = max + factor * Math.log10(1 + overshoot);
			} else if (overshoot < 0) {
				scrollValue.x = -factor * Math.log10(1 - overshoot);
			}
			max = this._getMaxScrollValue(ORIENTATION_VERTICAL);
			overshoot = this._toOvershoot(scrollValue.y, ORIENTATION_VERTICAL);
			if (overshoot > 0) {
				scrollValue.y = max + factor * Math.log10(1 + overshoot);
			} else if (overshoot < 0) {
				scrollValue.y = -factor * Math.log10(1 - overshoot);
			}
			return scrollValue;
		};
		_proto._isDragging = function _isDragging() {
			return this._contentDragHelper && this._contentDragHelper.isDragging;
		};
		_proto._setScrollbarComponentsEnabled = function _setScrollbarComponentsEnabled(enabled) {
			if (this._scrollbarReferences[ORIENTATION_HORIZONTAL].hasComponent('scrollbar')) {
				this._scrollbarReferences[ORIENTATION_HORIZONTAL].entity.scrollbar.enabled = enabled;
			}
			if (this._scrollbarReferences[ORIENTATION_VERTICAL].hasComponent('scrollbar')) {
				this._scrollbarReferences[ORIENTATION_VERTICAL].entity.scrollbar.enabled = enabled;
			}
		};
		_proto._setContentDraggingEnabled = function _setContentDraggingEnabled(enabled) {
			if (this._contentDragHelper) {
				this._contentDragHelper.enabled = enabled;
			}
		};
		_proto._onMouseWheel = function _onMouseWheel(event) {
			if (this.useMouseWheel) {
				var wheelEvent = event.event;
				var normalizedDeltaX = wheelEvent.deltaX / this._contentReference.entity.element.calculatedWidth * this.mouseWheelSensitivity.x;
				var normalizedDeltaY = wheelEvent.deltaY / this._contentReference.entity.element.calculatedHeight * this.mouseWheelSensitivity.y;
				var scrollX = math.clamp(this._scroll.x + normalizedDeltaX, 0, this._getMaxScrollValue(ORIENTATION_HORIZONTAL));
				var scrollY = math.clamp(this._scroll.y + normalizedDeltaY, 0, this._getMaxScrollValue(ORIENTATION_VERTICAL));
				this.scroll = new Vec2(scrollX, scrollY);
			}
		};
		_proto._enableContentInput = function _enableContentInput() {
			while (this._disabledContentInputEntities.length) {
				var e = this._disabledContentInputEntities.pop();
				if (e.element) {
					e.element.useInput = true;
				}
			}
			this._disabledContentInput = false;
		};
		_proto._disableContentInput = function _disableContentInput() {
			var _this2 = this;
			var _disableInput = function _disableInput(e) {
				if (e.element && e.element.useInput) {
					_this2._disabledContentInputEntities.push(e);
					e.element.useInput = false;
				}
				var children = e.children;
				for (var i = 0, l = children.length; i < l; i++) {
					_disableInput(children[i]);
				}
			};
			var contentEntity = this._contentReference.entity;
			if (contentEntity) {
				var children = contentEntity.children;
				for (var i = 0, l = children.length; i < l; i++) {
					_disableInput(children[i]);
				}
			}
			this._disabledContentInput = true;
		};
		_proto.onEnable = function onEnable() {
			this._viewportReference.onParentComponentEnable();
			this._contentReference.onParentComponentEnable();
			this._scrollbarReferences[ORIENTATION_HORIZONTAL].onParentComponentEnable();
			this._scrollbarReferences[ORIENTATION_VERTICAL].onParentComponentEnable();
			this._setScrollbarComponentsEnabled(true);
			this._setContentDraggingEnabled(true);
			this._syncAll();
		};
		_proto.onDisable = function onDisable() {
			this._setScrollbarComponentsEnabled(false);
			this._setContentDraggingEnabled(false);
		};
		_proto.onRemove = function onRemove() {
			this._toggleLifecycleListeners('off', this.system);
			this._toggleElementListeners('off');
			this._destroyDragHelper();
		};
		_createClass(ScrollViewComponent, [{
			key: "scroll",
			get: function get() {
				return this._scroll;
			},
			set: function set(value) {
				this._onSetScroll(value.x, value.y);
			}
		}]);
		return ScrollViewComponent;
	}(Component);

	var ScrollViewComponentData = function ScrollViewComponentData() {
		this.enabled = true;
	};

	var _schema$5 = [{
		name: 'enabled',
		type: 'boolean'
	}, {
		name: 'horizontal',
		type: 'boolean'
	}, {
		name: 'vertical',
		type: 'boolean'
	}, {
		name: 'scrollMode',
		type: 'number'
	}, {
		name: 'bounceAmount',
		type: 'number'
	}, {
		name: 'friction',
		type: 'number'
	}, {
		name: 'dragThreshold',
		type: 'number'
	}, {
		name: 'useMouseWheel',
		type: 'boolean'
	}, {
		name: 'mouseWheelSensitivity',
		type: 'vec2'
	}, {
		name: 'horizontalScrollbarVisibility',
		type: 'number'
	}, {
		name: 'verticalScrollbarVisibility',
		type: 'number'
	}, {
		name: 'viewportEntity',
		type: 'entity'
	}, {
		name: 'contentEntity',
		type: 'entity'
	}, {
		name: 'horizontalScrollbarEntity',
		type: 'entity'
	}, {
		name: 'verticalScrollbarEntity',
		type: 'entity'
	}];
	var DEFAULT_DRAG_THRESHOLD = 10;
	var ScrollViewComponentSystem = function (_ComponentSystem) {
		_inheritsLoose(ScrollViewComponentSystem, _ComponentSystem);
		function ScrollViewComponentSystem(app) {
			var _this;
			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'scrollview';
			_this.ComponentType = ScrollViewComponent;
			_this.DataType = ScrollViewComponentData;
			_this.schema = _schema$5;
			_this.on('beforeremove', _this._onRemoveComponent, _assertThisInitialized(_this));
			_this.app.systems.on('update', _this.onUpdate, _assertThisInitialized(_this));
			return _this;
		}
		var _proto = ScrollViewComponentSystem.prototype;
		_proto.initializeComponentData = function initializeComponentData(component, data, properties) {
			if (data.dragThreshold === undefined) {
				data.dragThreshold = DEFAULT_DRAG_THRESHOLD;
			}
			if (data.useMouseWheel === undefined) {
				data.useMouseWheel = true;
			}
			if (data.mouseWheelSensitivity === undefined) {
				data.mouseWheelSensitivity = new Vec2(1, 1);
			}
			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, _schema$5);
		};
		_proto.onUpdate = function onUpdate(dt) {
			var components = this.store;
			for (var id in components) {
				var entity = components[id].entity;
				var component = entity.scrollview;
				if (component.enabled && entity.enabled) {
					component.onUpdate();
				}
			}
		};
		_proto._onRemoveComponent = function _onRemoveComponent(entity, component) {
			component.onRemove();
		};
		_proto.destroy = function destroy() {
			_ComponentSystem.prototype.destroy.call(this);
			this.app.systems.off('update', this.onUpdate, this);
		};
		return ScrollViewComponentSystem;
	}(ComponentSystem);
	Component._buildAccessors(ScrollViewComponent.prototype, _schema$5);

	var ScrollbarComponent = function (_Component) {
		_inheritsLoose(ScrollbarComponent, _Component);
		function ScrollbarComponent(system, entity) {
			var _this;
			_this = _Component.call(this, system, entity) || this;
			_this._handleReference = new EntityReference(_assertThisInitialized(_this), 'handleEntity', {
				'element#gain': _this._onHandleElementGain,
				'element#lose': _this._onHandleElementLose,
				'element#set:anchor': _this._onSetHandleAlignment,
				'element#set:margin': _this._onSetHandleAlignment,
				'element#set:pivot': _this._onSetHandleAlignment
			});
			_this._toggleLifecycleListeners('on');
			return _this;
		}
		var _proto = ScrollbarComponent.prototype;
		_proto._toggleLifecycleListeners = function _toggleLifecycleListeners(onOrOff) {
			this[onOrOff]('set_value', this._onSetValue, this);
			this[onOrOff]('set_handleSize', this._onSetHandleSize, this);
			this[onOrOff]('set_orientation', this._onSetOrientation, this);
		};
		_proto._onHandleElementGain = function _onHandleElementGain() {
			this._destroyDragHelper();
			this._handleDragHelper = new ElementDragHelper(this._handleReference.entity.element, this._getAxis());
			this._handleDragHelper.on('drag:move', this._onHandleDrag, this);
			this._updateHandlePositionAndSize();
		};
		_proto._onHandleElementLose = function _onHandleElementLose() {
			this._destroyDragHelper();
		};
		_proto._onHandleDrag = function _onHandleDrag(position) {
			if (this._handleReference.entity && this.enabled && this.entity.enabled) {
				this.value = this._handlePositionToScrollValue(position[this._getAxis()]);
			}
		};
		_proto._onSetValue = function _onSetValue(name, oldValue, newValue) {
			if (Math.abs(newValue - oldValue) > 1e-5) {
				this.data.value = math.clamp(newValue, 0, 1);
				this._updateHandlePositionAndSize();
				this.fire('set:value', this.data.value);
			}
		};
		_proto._onSetHandleSize = function _onSetHandleSize(name, oldValue, newValue) {
			if (Math.abs(newValue - oldValue) > 1e-5) {
				this.data.handleSize = math.clamp(newValue, 0, 1);
				this._updateHandlePositionAndSize();
			}
		};
		_proto._onSetHandleAlignment = function _onSetHandleAlignment() {
			this._updateHandlePositionAndSize();
		};
		_proto._onSetOrientation = function _onSetOrientation(name, oldValue, newValue) {
			if (newValue !== oldValue && this._handleReference.hasComponent('element')) {
				this._handleReference.entity.element[this._getOppositeDimension()] = 0;
			}
		};
		_proto._updateHandlePositionAndSize = function _updateHandlePositionAndSize() {
			var handleEntity = this._handleReference.entity;
			var handleElement = handleEntity && handleEntity.element;
			if (handleEntity) {
				var position = handleEntity.getLocalPosition();
				position[this._getAxis()] = this._getHandlePosition();
				this._handleReference.entity.setLocalPosition(position);
			}
			if (handleElement) {
				handleElement[this._getDimension()] = this._getHandleLength();
			}
		};
		_proto._handlePositionToScrollValue = function _handlePositionToScrollValue(handlePosition) {
			return handlePosition * this._getSign() / this._getUsableTrackLength();
		};
		_proto._scrollValueToHandlePosition = function _scrollValueToHandlePosition(value) {
			return value * this._getSign() * this._getUsableTrackLength();
		};
		_proto._getUsableTrackLength = function _getUsableTrackLength() {
			return Math.max(this._getTrackLength() - this._getHandleLength(), 0.001);
		};
		_proto._getTrackLength = function _getTrackLength() {
			if (this.entity.element) {
				return this.orientation === ORIENTATION_HORIZONTAL ? this.entity.element.calculatedWidth : this.entity.element.calculatedHeight;
			}
			return 0;
		};
		_proto._getHandleLength = function _getHandleLength() {
			return this._getTrackLength() * this.handleSize;
		};
		_proto._getHandlePosition = function _getHandlePosition() {
			return this._scrollValueToHandlePosition(this.value);
		};
		_proto._getSign = function _getSign() {
			return this.orientation === ORIENTATION_HORIZONTAL ? 1 : -1;
		};
		_proto._getAxis = function _getAxis() {
			return this.orientation === ORIENTATION_HORIZONTAL ? 'x' : 'y';
		};
		_proto._getDimension = function _getDimension() {
			return this.orientation === ORIENTATION_HORIZONTAL ? 'width' : 'height';
		};
		_proto._getOppositeDimension = function _getOppositeDimension() {
			return this.orientation === ORIENTATION_HORIZONTAL ? 'height' : 'width';
		};
		_proto._destroyDragHelper = function _destroyDragHelper() {
			if (this._handleDragHelper) {
				this._handleDragHelper.destroy();
			}
		};
		_proto._setHandleDraggingEnabled = function _setHandleDraggingEnabled(enabled) {
			if (this._handleDragHelper) {
				this._handleDragHelper.enabled = enabled;
			}
		};
		_proto.onEnable = function onEnable() {
			this._handleReference.onParentComponentEnable();
			this._setHandleDraggingEnabled(true);
		};
		_proto.onDisable = function onDisable() {
			this._setHandleDraggingEnabled(false);
		};
		_proto.onRemove = function onRemove() {
			this._destroyDragHelper();
			this._toggleLifecycleListeners('off');
		};
		return ScrollbarComponent;
	}(Component);

	var ScrollbarComponentData = function ScrollbarComponentData() {
		this.enabled = true;
	};

	var _schema$4 = [{
		name: 'enabled',
		type: 'boolean'
	}, {
		name: 'orientation',
		type: 'number'
	}, {
		name: 'value',
		type: 'number'
	}, {
		name: 'handleSize',
		type: 'number'
	}, {
		name: 'handleEntity',
		type: 'entity'
	}];
	var ScrollbarComponentSystem = function (_ComponentSystem) {
		_inheritsLoose(ScrollbarComponentSystem, _ComponentSystem);
		function ScrollbarComponentSystem(app) {
			var _this;
			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'scrollbar';
			_this.ComponentType = ScrollbarComponent;
			_this.DataType = ScrollbarComponentData;
			_this.schema = _schema$4;
			_this.on('beforeremove', _this._onRemoveComponent, _assertThisInitialized(_this));
			return _this;
		}
		var _proto = ScrollbarComponentSystem.prototype;
		_proto.initializeComponentData = function initializeComponentData(component, data, properties) {
			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, _schema$4);
		};
		_proto._onRemoveComponent = function _onRemoveComponent(entity, component) {
			component.onRemove();
		};
		return ScrollbarComponentSystem;
	}(ComponentSystem);
	Component._buildAccessors(ScrollbarComponent.prototype, _schema$4);

	var instanceOptions = {
		volume: 0,
		pitch: 0,
		loop: false,
		startTime: 0,
		duration: 0,
		position: new Vec3(),
		maxDistance: 0,
		refDistance: 0,
		rollOffFactor: 0,
		distanceModel: 0,
		onPlay: null,
		onPause: null,
		onResume: null,
		onStop: null,
		onEnd: null
	};
	var SoundSlot = function (_EventHandler) {
		_inheritsLoose(SoundSlot, _EventHandler);
		function SoundSlot(component, name, options) {
			var _this;
			if (name === void 0) {
				name = 'Untitled';
			}
			if (options === void 0) {
				options = {};
			}
			_this = _EventHandler.call(this) || this;
			_this.name = void 0;
			_this.instances = [];
			_this._component = component;
			_this._assets = component.system.app.assets;
			_this._manager = component.system.manager;
			_this.name = name;
			_this._volume = options.volume !== undefined ? math.clamp(Number(options.volume) || 0, 0, 1) : 1;
			_this._pitch = options.pitch !== undefined ? Math.max(0.01, Number(options.pitch) || 0) : 1;
			_this._loop = !!(options.loop !== undefined ? options.loop : false);
			_this._duration = options.duration > 0 ? options.duration : null;
			_this._startTime = Math.max(0, Number(options.startTime) || 0);
			_this._overlap = !!options.overlap;
			_this._autoPlay = !!options.autoPlay;
			_this._firstNode = null;
			_this._lastNode = null;
			_this._asset = options.asset;
			if (_this._asset instanceof Asset) {
				_this._asset = _this._asset.id;
			}
			_this._onInstancePlayHandler = _this._onInstancePlay.bind(_assertThisInitialized(_this));
			_this._onInstancePauseHandler = _this._onInstancePause.bind(_assertThisInitialized(_this));
			_this._onInstanceResumeHandler = _this._onInstanceResume.bind(_assertThisInitialized(_this));
			_this._onInstanceStopHandler = _this._onInstanceStop.bind(_assertThisInitialized(_this));
			_this._onInstanceEndHandler = _this._onInstanceEnd.bind(_assertThisInitialized(_this));
			return _this;
		}
		var _proto = SoundSlot.prototype;
		_proto.play = function play() {
			if (!this.overlap) {
				this.stop();
			}
			if (!this.isLoaded && !this._hasAsset()) {
				return undefined;
			}
			var instance = this._createInstance();
			this.instances.push(instance);
			if (!this.isLoaded) {
				var onLoad = function onLoad(sound) {
					var playWhenLoaded = instance._playWhenLoaded;
					instance.sound = sound;
					if (playWhenLoaded) {
						instance.play();
					}
				};
				this.off('load', onLoad);
				this.once('load', onLoad);
				this.load();
			} else {
				instance.play();
			}
			return instance;
		};
		_proto.pause = function pause() {
			var paused = false;
			var instances = this.instances;
			for (var i = 0, len = instances.length; i < len; i++) {
				if (instances[i].pause()) {
					paused = true;
				}
			}
			return paused;
		};
		_proto.resume = function resume() {
			var resumed = false;
			var instances = this.instances;
			for (var i = 0, len = instances.length; i < len; i++) {
				if (instances[i].resume()) resumed = true;
			}
			return resumed;
		};
		_proto.stop = function stop() {
			var stopped = false;
			var instances = this.instances;
			var i = instances.length;
			while (i--) {
				instances[i].stop();
				stopped = true;
			}
			instances.length = 0;
			return stopped;
		};
		_proto.load = function load() {
			if (!this._hasAsset()) return;
			var asset = this._assets.get(this._asset);
			if (!asset) {
				this._assets.off('add:' + this._asset, this._onAssetAdd, this);
				this._assets.once('add:' + this._asset, this._onAssetAdd, this);
				return;
			}
			asset.off('remove', this._onAssetRemoved, this);
			asset.on('remove', this._onAssetRemoved, this);
			if (!asset.resource) {
				asset.off('load', this._onAssetLoad, this);
				asset.once('load', this._onAssetLoad, this);
				this._assets.load(asset);
				return;
			}
			this.fire('load', asset.resource);
		};
		_proto.setExternalNodes = function setExternalNodes(firstNode, lastNode) {
			if (!firstNode) {
				console.error('The firstNode must have a valid AudioNode');
				return;
			}
			if (!lastNode) {
				lastNode = firstNode;
			}
			this._firstNode = firstNode;
			this._lastNode = lastNode;
			if (!this._overlap) {
				var instances = this.instances;
				for (var i = 0, len = instances.length; i < len; i++) {
					instances[i].setExternalNodes(firstNode, lastNode);
				}
			}
		};
		_proto.clearExternalNodes = function clearExternalNodes() {
			this._firstNode = null;
			this._lastNode = null;
			if (!this._overlap) {
				var instances = this.instances;
				for (var i = 0, len = instances.length; i < len; i++) {
					instances[i].clearExternalNodes();
				}
			}
		};
		_proto.getExternalNodes = function getExternalNodes() {
			return [this._firstNode, this._lastNode];
		};
		_proto._hasAsset = function _hasAsset() {
			return this._asset != null;
		};
		_proto._createInstance = function _createInstance() {
			var instance = null;
			var component = this._component;
			var sound = null;
			if (this._hasAsset()) {
				var asset = this._assets.get(this._asset);
				if (asset) {
					sound = asset.resource;
				}
			}
			var data = instanceOptions;
			data.volume = this._volume * component.volume;
			data.pitch = this._pitch * component.pitch;
			data.loop = this._loop;
			data.startTime = this._startTime;
			data.duration = this._duration;
			data.onPlay = this._onInstancePlayHandler;
			data.onPause = this._onInstancePauseHandler;
			data.onResume = this._onInstanceResumeHandler;
			data.onStop = this._onInstanceStopHandler;
			data.onEnd = this._onInstanceEndHandler;
			if (component.positional) {
				data.position.copy(component.entity.getPosition());
				data.maxDistance = component.maxDistance;
				data.refDistance = component.refDistance;
				data.rollOffFactor = component.rollOffFactor;
				data.distanceModel = component.distanceModel;
				instance = new SoundInstance3d(this._manager, sound, data);
			} else {
				instance = new SoundInstance(this._manager, sound, data);
			}
			if (this._firstNode) {
				instance.setExternalNodes(this._firstNode, this._lastNode);
			}
			return instance;
		};
		_proto._onInstancePlay = function _onInstancePlay(instance) {
			this.fire('play', instance);
			this._component.fire('play', this, instance);
		};
		_proto._onInstancePause = function _onInstancePause(instance) {
			this.fire('pause', instance);
			this._component.fire('pause', this, instance);
		};
		_proto._onInstanceResume = function _onInstanceResume(instance) {
			this.fire('resume', instance);
			this._component.fire('resume', this, instance);
		};
		_proto._onInstanceStop = function _onInstanceStop(instance) {
			var idx = this.instances.indexOf(instance);
			if (idx !== -1) {
				this.instances.splice(idx, 1);
			}
			this.fire('stop', instance);
			this._component.fire('stop', this, instance);
		};
		_proto._onInstanceEnd = function _onInstanceEnd(instance) {
			var idx = this.instances.indexOf(instance);
			if (idx !== -1) {
				this.instances.splice(idx, 1);
			}
			this.fire('end', instance);
			this._component.fire('end', this, instance);
		};
		_proto._onAssetAdd = function _onAssetAdd(asset) {
			this.load();
		};
		_proto._onAssetLoad = function _onAssetLoad(asset) {
			this.load();
		};
		_proto._onAssetRemoved = function _onAssetRemoved(asset) {
			asset.off('remove', this._onAssetRemoved, this);
			this._assets.off('add:' + asset.id, this._onAssetAdd, this);
			this.stop();
		};
		_proto.updatePosition = function updatePosition(position) {
			var instances = this.instances;
			for (var i = 0, len = instances.length; i < len; i++) {
				instances[i].position = position;
			}
		};
		_createClass(SoundSlot, [{
			key: "asset",
			get: function get() {
				return this._asset;
			},
			set: function set(value) {
				var old = this._asset;
				if (old) {
					this._assets.off('add:' + old, this._onAssetAdd, this);
					var oldAsset = this._assets.get(old);
					if (oldAsset) {
						oldAsset.off('remove', this._onAssetRemoved, this);
					}
				}
				this._asset = value;
				if (this._asset instanceof Asset) {
					this._asset = this._asset.id;
				}
				if (this._hasAsset() && this._component.enabled && this._component.entity.enabled) {
					this.load();
				}
			}
		}, {
			key: "autoPlay",
			get: function get() {
				return this._autoPlay;
			},
			set: function set(value) {
				this._autoPlay = !!value;
			}
		}, {
			key: "duration",
			get: function get() {
				var assetDuration = 0;
				if (this._hasAsset()) {
					var asset = this._assets.get(this._asset);
					assetDuration = asset != null && asset.resource ? asset.resource.duration : 0;
				}
				if (this._duration != null) {
					return this._duration % (assetDuration || 1);
				}
				return assetDuration;
			},
			set: function set(value) {
				this._duration = Math.max(0, Number(value) || 0) || null;
				if (!this._overlap) {
					var instances = this.instances;
					for (var i = 0, len = instances.length; i < len; i++) {
						instances[i].duration = this._duration;
					}
				}
			}
		}, {
			key: "isLoaded",
			get: function get() {
				if (this._hasAsset()) {
					var asset = this._assets.get(this._asset);
					if (asset) {
						return !!asset.resource;
					}
				}
				return false;
			}
		}, {
			key: "isPaused",
			get: function get() {
				var instances = this.instances;
				var len = instances.length;
				if (len === 0) return false;
				for (var i = 0; i < len; i++) {
					if (!instances[i].isPaused) return false;
				}
				return true;
			}
		}, {
			key: "isPlaying",
			get: function get() {
				var instances = this.instances;
				for (var i = 0, len = instances.length; i < len; i++) {
					if (instances[i].isPlaying) return true;
				}
				return false;
			}
		}, {
			key: "isStopped",
			get: function get() {
				var instances = this.instances;
				for (var i = 0, len = instances.length; i < len; i++) {
					if (!instances[i].isStopped) return false;
				}
				return true;
			}
		}, {
			key: "loop",
			get: function get() {
				return this._loop;
			},
			set: function set(value) {
				this._loop = !!value;
				var instances = this.instances;
				for (var i = 0, len = instances.length; i < len; i++) {
					instances[i].loop = this._loop;
				}
			}
		}, {
			key: "overlap",
			get: function get() {
				return this._overlap;
			},
			set: function set(value) {
				this._overlap = !!value;
			}
		}, {
			key: "pitch",
			get: function get() {
				return this._pitch;
			},
			set: function set(value) {
				this._pitch = Math.max(Number(value) || 0, 0.01);
				if (!this._overlap) {
					var instances = this.instances;
					for (var i = 0, len = instances.length; i < len; i++) {
						instances[i].pitch = this.pitch * this._component.pitch;
					}
				}
			}
		}, {
			key: "startTime",
			get: function get() {
				return this._startTime;
			},
			set: function set(value) {
				this._startTime = Math.max(0, Number(value) || 0);
				if (!this._overlap) {
					var instances = this.instances;
					for (var i = 0, len = instances.length; i < len; i++) {
						instances[i].startTime = this._startTime;
					}
				}
			}
		}, {
			key: "volume",
			get: function get() {
				return this._volume;
			},
			set: function set(value) {
				this._volume = math.clamp(Number(value) || 0, 0, 1);
				if (!this._overlap) {
					var instances = this.instances;
					for (var i = 0, len = instances.length; i < len; i++) {
						instances[i].volume = this._volume * this._component.volume;
					}
				}
			}
		}]);
		return SoundSlot;
	}(EventHandler);

	var SoundComponent = function (_Component) {
		_inheritsLoose(SoundComponent, _Component);
		function SoundComponent(system, entity) {
			var _this;
			_this = _Component.call(this, system, entity) || this;
			_this._volume = 1;
			_this._pitch = 1;
			_this._positional = true;
			_this._refDistance = 1;
			_this._maxDistance = 10000;
			_this._rollOffFactor = 1;
			_this._distanceModel = DISTANCE_LINEAR;
			_this._slots = {};
			_this._playingBeforeDisable = {};
			return _this;
		}
		var _proto = SoundComponent.prototype;
		_proto._updateSoundInstances = function _updateSoundInstances(property, value, isFactor) {
			var slots = this._slots;
			for (var key in slots) {
				var slot = slots[key];
				if (!slot.overlap) {
					var instances = slot.instances;
					for (var i = 0, len = instances.length; i < len; i++) {
						instances[i][property] = isFactor ? slot[property] * value : value;
					}
				}
			}
		};
		_proto.onEnable = function onEnable() {
			if (this.system._inTools) {
				return;
			}
			var slots = this._slots;
			var playingBeforeDisable = this._playingBeforeDisable;
			for (var key in slots) {
				var slot = slots[key];
				if (slot.autoPlay && slot.isStopped) {
					slot.play();
				} else if (playingBeforeDisable[key]) {
					slot.resume();
				} else if (!slot.isLoaded) {
					slot.load();
				}
			}
		};
		_proto.onDisable = function onDisable() {
			var slots = this._slots;
			var playingBeforeDisable = {};
			for (var key in slots) {
				if (!slots[key].overlap) {
					if (slots[key].isPlaying) {
						slots[key].pause();
						playingBeforeDisable[key] = true;
					}
				}
			}
			this._playingBeforeDisable = playingBeforeDisable;
		};
		_proto.onRemove = function onRemove() {
			this.off();
		};
		_proto.addSlot = function addSlot(name, options) {
			var slots = this._slots;
			if (slots[name]) {
				return null;
			}
			var slot = new SoundSlot(this, name, options);
			slots[name] = slot;
			if (slot.autoPlay && this.enabled && this.entity.enabled) {
				slot.play();
			}
			return slot;
		};
		_proto.removeSlot = function removeSlot(name) {
			var slots = this._slots;
			if (slots[name]) {
				slots[name].stop();
				delete slots[name];
			}
		};
		_proto.slot = function slot(name) {
			return this._slots[name];
		};
		_proto._getSlotProperty = function _getSlotProperty(name, property) {
			if (!this.enabled || !this.entity.enabled) {
				return undefined;
			}
			var slot = this._slots[name];
			if (!slot) {
				return undefined;
			}
			return slot[property];
		};
		_proto.isPlaying = function isPlaying(name) {
			return this._getSlotProperty(name, 'isPlaying') || false;
		};
		_proto.isLoaded = function isLoaded(name) {
			return this._getSlotProperty(name, 'isLoaded') || false;
		};
		_proto.isPaused = function isPaused(name) {
			return this._getSlotProperty(name, 'isPaused') || false;
		};
		_proto.isStopped = function isStopped(name) {
			return this._getSlotProperty(name, 'isStopped') || false;
		};
		_proto.play = function play(name) {
			if (!this.enabled || !this.entity.enabled) {
				return null;
			}
			var slot = this._slots[name];
			if (!slot) {
				return null;
			}
			return slot.play();
		};
		_proto.pause = function pause(name) {
			var slots = this._slots;
			if (name) {
				var slot = slots[name];
				if (!slot) {
					return;
				}
				slot.pause();
			} else {
				for (var key in slots) {
					slots[key].pause();
				}
			}
		};
		_proto.resume = function resume(name) {
			var slots = this._slots;
			if (name) {
				var slot = slots[name];
				if (!slot) {
					return;
				}
				if (slot.isPaused) {
					slot.resume();
				}
			} else {
				for (var key in slots) {
					slots[key].resume();
				}
			}
		};
		_proto.stop = function stop(name) {
			var slots = this._slots;
			if (name) {
				var slot = slots[name];
				if (!slot) {
					return;
				}
				slot.stop();
			} else {
				for (var key in slots) {
					slots[key].stop();
				}
			}
		};
		_createClass(SoundComponent, [{
			key: "distanceModel",
			get: function get() {
				return this._distanceModel;
			},
			set: function set(value) {
				this._distanceModel = value;
				this._updateSoundInstances('distanceModel', value, false);
			}
		}, {
			key: "maxDistance",
			get: function get() {
				return this._maxDistance;
			},
			set: function set(value) {
				this._maxDistance = value;
				this._updateSoundInstances('maxDistance', value, false);
			}
		}, {
			key: "refDistance",
			get: function get() {
				return this._refDistance;
			},
			set: function set(value) {
				this._refDistance = value;
				this._updateSoundInstances('refDistance', value, false);
			}
		}, {
			key: "rollOffFactor",
			get: function get() {
				return this._rollOffFactor;
			},
			set: function set(value) {
				this._rollOffFactor = value;
				this._updateSoundInstances('rollOffFactor', value, false);
			}
		}, {
			key: "pitch",
			get: function get() {
				return this._pitch;
			},
			set: function set(value) {
				this._pitch = value;
				this._updateSoundInstances('pitch', value, true);
			}
		}, {
			key: "volume",
			get: function get() {
				return this._volume;
			},
			set: function set(value) {
				this._volume = value;
				this._updateSoundInstances('volume', value, true);
			}
		}, {
			key: "positional",
			get: function get() {
				return this._positional;
			},
			set: function set(newValue) {
				this._positional = newValue;
				var slots = this._slots;
				for (var key in slots) {
					var slot = slots[key];
					if (!slot.overlap) {
						var instances = slot.instances;
						var oldLength = instances.length;
						for (var i = oldLength - 1; i >= 0; i--) {
							var isPlaying = instances[i].isPlaying || instances[i].isSuspended;
							var currentTime = instances[i].currentTime;
							if (isPlaying) instances[i].stop();
							var instance = slot._createInstance();
							if (isPlaying) {
								instance.play();
								instance.currentTime = currentTime;
							}
							instances.push(instance);
						}
					}
				}
			}
		}, {
			key: "slots",
			get: function get() {
				return this._slots;
			},
			set: function set(newValue) {
				var oldValue = this._slots;
				if (oldValue) {
					for (var key in oldValue) {
						oldValue[key].stop();
					}
				}
				var slots = {};
				for (var _key in newValue) {
					if (!(newValue[_key] instanceof SoundSlot)) {
						if (newValue[_key].name) {
							slots[newValue[_key].name] = new SoundSlot(this, newValue[_key].name, newValue[_key]);
						}
					} else {
						slots[newValue[_key].name] = newValue[_key];
					}
				}
				this._slots = slots;
				if (this.enabled && this.entity.enabled) this.onEnable();
			}
		}]);
		return SoundComponent;
	}(Component);

	var SoundComponentData = function SoundComponentData() {
		this.enabled = true;
	};

	var _schema$3 = ['enabled'];
	var SoundComponentSystem = function (_ComponentSystem) {
		_inheritsLoose(SoundComponentSystem, _ComponentSystem);
		function SoundComponentSystem(app) {
			var _this;
			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'sound';
			_this.ComponentType = SoundComponent;
			_this.DataType = SoundComponentData;
			_this.schema = _schema$3;
			_this.manager = app.soundManager;
			_this.app.systems.on('update', _this.onUpdate, _assertThisInitialized(_this));
			_this.on('beforeremove', _this.onBeforeRemove, _assertThisInitialized(_this));
			return _this;
		}
		var _proto = SoundComponentSystem.prototype;
		_proto.initializeComponentData = function initializeComponentData(component, data, properties) {
			properties = ['volume', 'pitch', 'positional', 'refDistance', 'maxDistance', 'rollOffFactor', 'distanceModel', 'slots'];
			for (var i = 0; i < properties.length; i++) {
				if (data.hasOwnProperty(properties[i])) {
					component[properties[i]] = data[properties[i]];
				}
			}
			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, ['enabled']);
		};
		_proto.cloneComponent = function cloneComponent(entity, clone) {
			var srcComponent = entity.sound;
			var srcSlots = srcComponent.slots;
			var slots = {};
			for (var key in srcSlots) {
				var srcSlot = srcSlots[key];
				slots[key] = {
					name: srcSlot.name,
					volume: srcSlot.volume,
					pitch: srcSlot.pitch,
					loop: srcSlot.loop,
					duration: srcSlot.duration,
					startTime: srcSlot.startTime,
					overlap: srcSlot.overlap,
					autoPlay: srcSlot.autoPlay,
					asset: srcSlot.asset
				};
			}
			var cloneData = {
				distanceModel: srcComponent.distanceModel,
				enabled: srcComponent.enabled,
				maxDistance: srcComponent.maxDistance,
				pitch: srcComponent.pitch,
				positional: srcComponent.positional,
				refDistance: srcComponent.refDistance,
				rollOffFactor: srcComponent.rollOffFactor,
				slots: slots,
				volume: srcComponent.volume
			};
			return this.addComponent(clone, cloneData);
		};
		_proto.onUpdate = function onUpdate(dt) {
			var store = this.store;
			for (var id in store) {
				if (store.hasOwnProperty(id)) {
					var item = store[id];
					var entity = item.entity;
					if (entity.enabled) {
						var component = entity.sound;
						if (component.enabled && component.positional) {
							var position = entity.getPosition();
							var slots = component.slots;
							for (var key in slots) {
								slots[key].updatePosition(position);
							}
						}
					}
				}
			}
		};
		_proto.onBeforeRemove = function onBeforeRemove(entity, component) {
			var slots = component.slots;
			for (var key in slots) {
				if (!slots[key].overlap) {
					slots[key].stop();
				}
			}
			component.onRemove();
		};
		_proto.destroy = function destroy() {
			_ComponentSystem.prototype.destroy.call(this);
			this.app.systems.off('update', this.onUpdate, this);
		};
		_createClass(SoundComponentSystem, [{
			key: "volume",
			get: function get() {
				return this.manager.volume;
			},
			set: function set(volume) {
				this.manager.volume = volume;
			}
		}, {
			key: "context",
			get: function get() {
				if (!hasAudioContext()) {
					return null;
				}
				return this.manager.context;
			}
		}]);
		return SoundComponentSystem;
	}(ComponentSystem);
	Component._buildAccessors(SoundComponent.prototype, _schema$3);

	var SPRITETYPE_SIMPLE = 'simple';
	var SPRITETYPE_ANIMATED = 'animated';

	var SpriteAnimationClip = function (_EventHandler) {
		_inheritsLoose(SpriteAnimationClip, _EventHandler);
		function SpriteAnimationClip(component, data) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this._component = component;
			_this._frame = 0;
			_this._sprite = null;
			_this._spriteAsset = null;
			_this.spriteAsset = data.spriteAsset;
			_this.name = data.name;
			_this.fps = data.fps || 0;
			_this.loop = data.loop || false;
			_this._playing = false;
			_this._paused = false;
			_this._time = 0;
			return _this;
		}
		var _proto = SpriteAnimationClip.prototype;
		_proto._onSpriteAssetAdded = function _onSpriteAssetAdded(asset) {
			this._component.system.app.assets.off('add:' + asset.id, this._onSpriteAssetAdded, this);
			if (this._spriteAsset === asset.id) {
				this._bindSpriteAsset(asset);
			}
		};
		_proto._bindSpriteAsset = function _bindSpriteAsset(asset) {
			asset.on('load', this._onSpriteAssetLoad, this);
			asset.on('remove', this._onSpriteAssetRemove, this);
			if (asset.resource) {
				this._onSpriteAssetLoad(asset);
			} else {
				this._component.system.app.assets.load(asset);
			}
		};
		_proto._unbindSpriteAsset = function _unbindSpriteAsset(asset) {
			if (!asset) {
				return;
			}
			asset.off('load', this._onSpriteAssetLoad, this);
			asset.off('remove', this._onSpriteAssetRemove, this);
			if (asset.resource && !asset.resource.atlas) {
				this._component.system.app.assets.off('load:' + asset.data.textureAtlasAsset, this._onTextureAtlasLoad, this);
			}
		};
		_proto._onSpriteAssetLoad = function _onSpriteAssetLoad(asset) {
			if (!asset.resource) {
				this.sprite = null;
			} else {
				if (!asset.resource.atlas) {
					var atlasAssetId = asset.data.textureAtlasAsset;
					var assets = this._component.system.app.assets;
					assets.off('load:' + atlasAssetId, this._onTextureAtlasLoad, this);
					assets.once('load:' + atlasAssetId, this._onTextureAtlasLoad, this);
				} else {
					this.sprite = asset.resource;
				}
			}
		};
		_proto._onTextureAtlasLoad = function _onTextureAtlasLoad(atlasAsset) {
			var spriteAsset = this._spriteAsset;
			if (spriteAsset instanceof Asset) {
				this._onSpriteAssetLoad(spriteAsset);
			} else {
				this._onSpriteAssetLoad(this._component.system.app.assets.get(spriteAsset));
			}
		};
		_proto._onSpriteAssetRemove = function _onSpriteAssetRemove(asset) {
			this.sprite = null;
		};
		_proto._onSpriteMeshesChange = function _onSpriteMeshesChange() {
			if (this._component.currentClip === this) {
				this._component._showFrame(this.frame);
			}
		};
		_proto._onSpritePpuChanged = function _onSpritePpuChanged() {
			if (this._component.currentClip === this) {
				if (this.sprite.renderMode !== SPRITE_RENDERMODE_SIMPLE) {
					this._component._showFrame(this.frame);
				}
			}
		};
		_proto._update = function _update(dt) {
			if (this.fps === 0) return;
			if (!this._playing || this._paused || !this._sprite) return;
			var dir = this.fps < 0 ? -1 : 1;
			var time = this._time + dt * this._component.speed * dir;
			var duration = this.duration;
			var end = time > duration || time < 0;
			this._setTime(time);
			var frame = this.frame;
			if (this._sprite) {
				frame = Math.floor(this._sprite.frameKeys.length * this._time / duration);
			} else {
				frame = 0;
			}
			if (frame !== this._frame) {
				this._setFrame(frame);
			}
			if (end) {
				if (this.loop) {
					this.fire('loop');
					this._component.fire('loop', this);
				} else {
					this._playing = false;
					this._paused = false;
					this.fire('end');
					this._component.fire('end', this);
				}
			}
		};
		_proto._setTime = function _setTime(value) {
			this._time = value;
			var duration = this.duration;
			if (this._time < 0) {
				if (this.loop) {
					this._time = this._time % duration + duration;
				} else {
					this._time = 0;
				}
			} else if (this._time > duration) {
				if (this.loop) {
					this._time %= duration;
				} else {
					this._time = duration;
				}
			}
		};
		_proto._setFrame = function _setFrame(value) {
			if (this._sprite) {
				this._frame = math.clamp(value, 0, this._sprite.frameKeys.length - 1);
			} else {
				this._frame = value;
			}
			if (this._component.currentClip === this) {
				this._component._showFrame(this._frame);
			}
		};
		_proto._destroy = function _destroy() {
			if (this._spriteAsset) {
				var assets = this._component.system.app.assets;
				this._unbindSpriteAsset(assets.get(this._spriteAsset));
			}
			if (this._sprite) {
				this.sprite = null;
			}
			if (this._spriteAsset) {
				this.spriteAsset = null;
			}
		};
		_proto.play = function play() {
			if (this._playing) return;
			this._playing = true;
			this._paused = false;
			this.frame = 0;
			this.fire('play');
			this._component.fire('play', this);
		};
		_proto.pause = function pause() {
			if (!this._playing || this._paused) return;
			this._paused = true;
			this.fire('pause');
			this._component.fire('pause', this);
		};
		_proto.resume = function resume() {
			if (!this._paused) return;
			this._paused = false;
			this.fire('resume');
			this._component.fire('resume', this);
		};
		_proto.stop = function stop() {
			if (!this._playing) return;
			this._playing = false;
			this._paused = false;
			this._time = 0;
			this.frame = 0;
			this.fire('stop');
			this._component.fire('stop', this);
		};
		_createClass(SpriteAnimationClip, [{
			key: "duration",
			get: function get() {
				if (this._sprite) {
					var fps = this.fps || Number.MIN_VALUE;
					return this._sprite.frameKeys.length / Math.abs(fps);
				}
				return 0;
			}
		}, {
			key: "frame",
			get: function get() {
				return this._frame;
			},
			set: function set(value) {
				this._setFrame(value);
				var fps = this.fps || Number.MIN_VALUE;
				this._setTime(this._frame / fps);
			}
		}, {
			key: "isPaused",
			get: function get() {
				return this._paused;
			}
		}, {
			key: "isPlaying",
			get: function get() {
				return this._playing;
			}
		}, {
			key: "sprite",
			get: function get() {
				return this._sprite;
			},
			set: function set(value) {
				if (this._sprite) {
					this._sprite.off('set:meshes', this._onSpriteMeshesChange, this);
					this._sprite.off('set:pixelsPerUnit', this._onSpritePpuChanged, this);
					this._sprite.off('set:atlas', this._onSpriteMeshesChange, this);
					if (this._sprite.atlas) {
						this._sprite.atlas.off('set:texture', this._onSpriteMeshesChange, this);
					}
				}
				this._sprite = value;
				if (this._sprite) {
					this._sprite.on('set:meshes', this._onSpriteMeshesChange, this);
					this._sprite.on('set:pixelsPerUnit', this._onSpritePpuChanged, this);
					this._sprite.on('set:atlas', this._onSpriteMeshesChange, this);
					if (this._sprite.atlas) {
						this._sprite.atlas.on('set:texture', this._onSpriteMeshesChange, this);
					}
				}
				if (this._component.currentClip === this) {
					var mi;
					if (!value || !value.atlas) {
						mi = this._component._meshInstance;
						if (mi) {
							mi.deleteParameter('texture_emissiveMap');
							mi.deleteParameter('texture_opacityMap');
						}
						this._component._hideModel();
					} else {
						if (value.atlas.texture) {
							mi = this._component._meshInstance;
							if (mi) {
								mi.setParameter('texture_emissiveMap', value.atlas.texture);
								mi.setParameter('texture_opacityMap', value.atlas.texture);
							}
							if (this._component.enabled && this._component.entity.enabled) {
								this._component._showModel();
							}
						}
						if (this.time && this.fps) {
							this.time = this.time;
						} else {
							this.frame = this.frame;
						}
					}
				}
			}
		}, {
			key: "spriteAsset",
			get: function get() {
				return this._spriteAsset;
			},
			set: function set(value) {
				var assets = this._component.system.app.assets;
				var id = value;
				if (value instanceof Asset) {
					id = value.id;
				}
				if (this._spriteAsset !== id) {
					if (this._spriteAsset) {
						var prev = assets.get(this._spriteAsset);
						if (prev) {
							this._unbindSpriteAsset(prev);
						}
					}
					this._spriteAsset = id;
					if (this._spriteAsset) {
						var asset = assets.get(this._spriteAsset);
						if (!asset) {
							this.sprite = null;
							assets.on('add:' + this._spriteAsset, this._onSpriteAssetAdded, this);
						} else {
							this._bindSpriteAsset(asset);
						}
					} else {
						this.sprite = null;
					}
				}
			}
		}, {
			key: "time",
			get: function get() {
				return this._time;
			},
			set: function set(value) {
				this._setTime(value);
				if (this._sprite) {
					this.frame = Math.min(this._sprite.frameKeys.length - 1, Math.floor(this._time * Math.abs(this.fps)));
				} else {
					this.frame = 0;
				}
			}
		}]);
		return SpriteAnimationClip;
	}(EventHandler);

	var PARAM_EMISSIVE_MAP = 'texture_emissiveMap';
	var PARAM_OPACITY_MAP = 'texture_opacityMap';
	var PARAM_EMISSIVE = 'material_emissive';
	var PARAM_OPACITY = 'material_opacity';
	var PARAM_INNER_OFFSET = 'innerOffset';
	var PARAM_OUTER_SCALE = 'outerScale';
	var PARAM_ATLAS_RECT = 'atlasRect';
	var SpriteComponent = function (_Component) {
		_inheritsLoose(SpriteComponent, _Component);
		function SpriteComponent(system, entity) {
			var _this;
			_this = _Component.call(this, system, entity) || this;
			_this._type = SPRITETYPE_SIMPLE;
			_this._material = system.defaultMaterial;
			_this._color = new Color(1, 1, 1, 1);
			_this._colorUniform = new Float32Array(3);
			_this._speed = 1;
			_this._flipX = false;
			_this._flipY = false;
			_this._width = 1;
			_this._height = 1;
			_this._drawOrder = 0;
			_this._layers = [LAYERID_WORLD];
			_this._outerScale = new Vec2(1, 1);
			_this._outerScaleUniform = new Float32Array(2);
			_this._innerOffset = new Vec4();
			_this._innerOffsetUniform = new Float32Array(4);
			_this._atlasRect = new Vec4();
			_this._atlasRectUniform = new Float32Array(4);
			_this._batchGroupId = -1;
			_this._batchGroup = null;
			_this._node = new GraphNode();
			_this._model = new Model();
			_this._model.graph = _this._node;
			_this._meshInstance = null;
			entity.addChild(_this._model.graph);
			_this._model._entity = entity;
			_this._updateAabbFunc = _this._updateAabb.bind(_assertThisInitialized(_this));
			_this._addedModel = false;
			_this._autoPlayClip = null;
			_this._clips = {};
			_this._defaultClip = new SpriteAnimationClip(_assertThisInitialized(_this), {
				name: _this.entity.name,
				fps: 0,
				loop: false,
				spriteAsset: null
			});
			_this._currentClip = _this._defaultClip;
			return _this;
		}
		var _proto = SpriteComponent.prototype;
		_proto.onEnable = function onEnable() {
			var app = this.system.app;
			var scene = app.scene;
			scene.on('set:layers', this._onLayersChanged, this);
			if (scene.layers) {
				scene.layers.on('add', this._onLayerAdded, this);
				scene.layers.on('remove', this._onLayerRemoved, this);
			}
			this._showModel();
			if (this._autoPlayClip) this._tryAutoPlay();
			if (this._batchGroupId >= 0) {
				var _app$batcher;
				(_app$batcher = app.batcher) == null || _app$batcher.insert(BatchGroup.SPRITE, this._batchGroupId, this.entity);
			}
		};
		_proto.onDisable = function onDisable() {
			var app = this.system.app;
			var scene = app.scene;
			scene.off('set:layers', this._onLayersChanged, this);
			if (scene.layers) {
				scene.layers.off('add', this._onLayerAdded, this);
				scene.layers.off('remove', this._onLayerRemoved, this);
			}
			this.stop();
			this._hideModel();
			if (this._batchGroupId >= 0) {
				var _app$batcher2;
				(_app$batcher2 = app.batcher) == null || _app$batcher2.remove(BatchGroup.SPRITE, this._batchGroupId, this.entity);
			}
		};
		_proto.onDestroy = function onDestroy() {
			var _this$_node;
			this._currentClip = null;
			if (this._defaultClip) {
				this._defaultClip._destroy();
				this._defaultClip = null;
			}
			for (var key in this._clips) {
				this._clips[key]._destroy();
			}
			this._clips = null;
			this._hideModel();
			this._model = null;
			(_this$_node = this._node) == null || _this$_node.remove();
			this._node = null;
			if (this._meshInstance) {
				this._meshInstance.material = null;
				this._meshInstance.mesh = null;
				this._meshInstance = null;
			}
		};
		_proto._showModel = function _showModel() {
			if (this._addedModel) return;
			if (!this._meshInstance) return;
			var meshInstances = [this._meshInstance];
			for (var i = 0, len = this._layers.length; i < len; i++) {
				var layer = this.system.app.scene.layers.getLayerById(this._layers[i]);
				if (layer) {
					layer.addMeshInstances(meshInstances);
				}
			}
			this._addedModel = true;
		};
		_proto._hideModel = function _hideModel() {
			if (!this._addedModel || !this._meshInstance) return;
			var meshInstances = [this._meshInstance];
			for (var i = 0, len = this._layers.length; i < len; i++) {
				var layer = this.system.app.scene.layers.getLayerById(this._layers[i]);
				if (layer) {
					layer.removeMeshInstances(meshInstances);
				}
			}
			this._addedModel = false;
		};
		_proto._showFrame = function _showFrame(frame) {
			if (!this.sprite) return;
			var mesh = this.sprite.meshes[frame];
			if (!mesh) {
				if (this._meshInstance) {
					this._meshInstance.mesh = null;
					this._meshInstance.visible = false;
				}
				return;
			}
			var material;
			if (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED) {
				material = this.system.default9SlicedMaterialSlicedMode;
			} else if (this.sprite.renderMode === SPRITE_RENDERMODE_TILED) {
				material = this.system.default9SlicedMaterialTiledMode;
			} else {
				material = this.system.defaultMaterial;
			}
			if (!this._meshInstance) {
				this._meshInstance = new MeshInstance(mesh, this._material, this._node);
				this._meshInstance.castShadow = false;
				this._meshInstance.receiveShadow = false;
				this._meshInstance.drawOrder = this._drawOrder;
				this._model.meshInstances.push(this._meshInstance);
				this._colorUniform[0] = this._color.r;
				this._colorUniform[1] = this._color.g;
				this._colorUniform[2] = this._color.b;
				this._meshInstance.setParameter(PARAM_EMISSIVE, this._colorUniform);
				this._meshInstance.setParameter(PARAM_OPACITY, this._color.a);
				if (this.enabled && this.entity.enabled) {
					this._showModel();
				}
			}
			if (this._meshInstance.material !== material) {
				this._meshInstance.material = material;
			}
			if (this._meshInstance.mesh !== mesh) {
				this._meshInstance.mesh = mesh;
				this._meshInstance.visible = true;
				this._meshInstance._aabbVer = -1;
			}
			if (this.sprite.atlas && this.sprite.atlas.texture) {
				this._meshInstance.setParameter(PARAM_EMISSIVE_MAP, this.sprite.atlas.texture);
				this._meshInstance.setParameter(PARAM_OPACITY_MAP, this.sprite.atlas.texture);
			} else {
				this._meshInstance.deleteParameter(PARAM_EMISSIVE_MAP);
				this._meshInstance.deleteParameter(PARAM_OPACITY_MAP);
			}
			if (this.sprite.atlas && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED)) {
				this._meshInstance._updateAabbFunc = this._updateAabbFunc;
				var frameData = this.sprite.atlas.frames[this.sprite.frameKeys[frame]];
				if (frameData) {
					var borderWidthScale = 2 / frameData.rect.z;
					var borderHeightScale = 2 / frameData.rect.w;
					this._innerOffset.set(frameData.border.x * borderWidthScale, frameData.border.y * borderHeightScale, frameData.border.z * borderWidthScale, frameData.border.w * borderHeightScale);
					var tex = this.sprite.atlas.texture;
					this._atlasRect.set(frameData.rect.x / tex.width, frameData.rect.y / tex.height, frameData.rect.z / tex.width, frameData.rect.w / tex.height);
				} else {
					this._innerOffset.set(0, 0, 0, 0);
				}
				this._innerOffsetUniform[0] = this._innerOffset.x;
				this._innerOffsetUniform[1] = this._innerOffset.y;
				this._innerOffsetUniform[2] = this._innerOffset.z;
				this._innerOffsetUniform[3] = this._innerOffset.w;
				this._meshInstance.setParameter(PARAM_INNER_OFFSET, this._innerOffsetUniform);
				this._atlasRectUniform[0] = this._atlasRect.x;
				this._atlasRectUniform[1] = this._atlasRect.y;
				this._atlasRectUniform[2] = this._atlasRect.z;
				this._atlasRectUniform[3] = this._atlasRect.w;
				this._meshInstance.setParameter(PARAM_ATLAS_RECT, this._atlasRectUniform);
			} else {
				this._meshInstance._updateAabbFunc = null;
			}
			this._updateTransform();
		};
		_proto._updateTransform = function _updateTransform() {
			var scaleX = this.flipX ? -1 : 1;
			var scaleY = this.flipY ? -1 : 1;
			var posX = 0;
			var posY = 0;
			if (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED)) {
				var w = 1;
				var h = 1;
				if (this.sprite.atlas) {
					var frameData = this.sprite.atlas.frames[this.sprite.frameKeys[this.frame]];
					if (frameData) {
						w = frameData.rect.z;
						h = frameData.rect.w;
						posX = (0.5 - frameData.pivot.x) * this._width;
						posY = (0.5 - frameData.pivot.y) * this._height;
					}
				}
				var scaleMulX = w / this.sprite.pixelsPerUnit;
				var scaleMulY = h / this.sprite.pixelsPerUnit;
				this._outerScale.set(Math.max(this._width, this._innerOffset.x * scaleMulX), Math.max(this._height, this._innerOffset.y * scaleMulY));
				scaleX *= scaleMulX;
				scaleY *= scaleMulY;
				this._outerScale.x /= scaleMulX;
				this._outerScale.y /= scaleMulY;
				scaleX *= math.clamp(this._width / (this._innerOffset.x * scaleMulX), 0.0001, 1);
				scaleY *= math.clamp(this._height / (this._innerOffset.y * scaleMulY), 0.0001, 1);
				if (this._meshInstance) {
					this._outerScaleUniform[0] = this._outerScale.x;
					this._outerScaleUniform[1] = this._outerScale.y;
					this._meshInstance.setParameter(PARAM_OUTER_SCALE, this._outerScaleUniform);
				}
			}
			this._node.setLocalScale(scaleX, scaleY, 1);
			this._node.setLocalPosition(posX, posY, 0);
		};
		_proto._updateAabb = function _updateAabb(aabb) {
			aabb.center.set(0, 0, 0);
			aabb.halfExtents.set(this._outerScale.x * 0.5, this._outerScale.y * 0.5, 0.001);
			aabb.setFromTransformedAabb(aabb, this._node.getWorldTransform());
			return aabb;
		};
		_proto._tryAutoPlay = function _tryAutoPlay() {
			if (!this._autoPlayClip) return;
			if (this.type !== SPRITETYPE_ANIMATED) return;
			var clip = this._clips[this._autoPlayClip];
			if (clip && !clip.isPlaying && (!this._currentClip || !this._currentClip.isPlaying)) {
				if (this.enabled && this.entity.enabled) {
					this.play(clip.name);
				}
			}
		};
		_proto._onLayersChanged = function _onLayersChanged(oldComp, newComp) {
			oldComp.off('add', this.onLayerAdded, this);
			oldComp.off('remove', this.onLayerRemoved, this);
			newComp.on('add', this.onLayerAdded, this);
			newComp.on('remove', this.onLayerRemoved, this);
			if (this.enabled && this.entity.enabled) {
				this._showModel();
			}
		};
		_proto._onLayerAdded = function _onLayerAdded(layer) {
			var index = this.layers.indexOf(layer.id);
			if (index < 0) return;
			if (this._addedModel && this.enabled && this.entity.enabled && this._meshInstance) {
				layer.addMeshInstances([this._meshInstance]);
			}
		};
		_proto._onLayerRemoved = function _onLayerRemoved(layer) {
			if (!this._meshInstance) return;
			var index = this.layers.indexOf(layer.id);
			if (index < 0) return;
			layer.removeMeshInstances([this._meshInstance]);
		};
		_proto.removeModelFromLayers = function removeModelFromLayers() {
			for (var i = 0; i < this.layers.length; i++) {
				var layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
				if (!layer) continue;
				layer.removeMeshInstances([this._meshInstance]);
			}
		};
		_proto.addClip = function addClip(data) {
			var clip = new SpriteAnimationClip(this, {
				name: data.name,
				fps: data.fps,
				loop: data.loop,
				spriteAsset: data.spriteAsset
			});
			this._clips[data.name] = clip;
			if (clip.name && clip.name === this._autoPlayClip) this._tryAutoPlay();
			return clip;
		};
		_proto.removeClip = function removeClip(name) {
			delete this._clips[name];
		};
		_proto.clip = function clip(name) {
			return this._clips[name];
		};
		_proto.play = function play(name) {
			var clip = this._clips[name];
			var current = this._currentClip;
			if (current && current !== clip) {
				current._playing = false;
			}
			this._currentClip = clip;
			if (this._currentClip) {
				this._currentClip = clip;
				this._currentClip.play();
			}
			return clip;
		};
		_proto.pause = function pause() {
			if (this._currentClip === this._defaultClip) return;
			if (this._currentClip.isPlaying) {
				this._currentClip.pause();
			}
		};
		_proto.resume = function resume() {
			if (this._currentClip === this._defaultClip) return;
			if (this._currentClip.isPaused) {
				this._currentClip.resume();
			}
		};
		_proto.stop = function stop() {
			if (this._currentClip === this._defaultClip) return;
			this._currentClip.stop();
		};
		_createClass(SpriteComponent, [{
			key: "type",
			get: function get() {
				return this._type;
			},
			set: function set(value) {
				if (this._type === value) return;
				this._type = value;
				if (this._type === SPRITETYPE_SIMPLE) {
					this.stop();
					this._currentClip = this._defaultClip;
					if (this.enabled && this.entity.enabled) {
						this._currentClip.frame = this.frame;
						if (this._currentClip.sprite) {
							this._showModel();
						} else {
							this._hideModel();
						}
					}
				} else if (this._type === SPRITETYPE_ANIMATED) {
					this.stop();
					if (this._autoPlayClip) {
						this._tryAutoPlay();
					}
					if (this._currentClip && this._currentClip.isPlaying && this.enabled && this.entity.enabled) {
						this._showModel();
					} else {
						this._hideModel();
					}
				}
			}
		}, {
			key: "frame",
			get: function get() {
				return this._currentClip.frame;
			},
			set: function set(value) {
				this._currentClip.frame = value;
			}
		}, {
			key: "spriteAsset",
			get: function get() {
				return this._defaultClip._spriteAsset;
			},
			set: function set(value) {
				this._defaultClip.spriteAsset = value;
			}
		}, {
			key: "sprite",
			get: function get() {
				return this._currentClip.sprite;
			},
			set: function set(value) {
				this._currentClip.sprite = value;
			}
		}, {
			key: "material",
			get: function get() {
				return this._material;
			},
			set: function set(value) {
				this._material = value;
				if (this._meshInstance) {
					this._meshInstance.material = value;
				}
			}
		}, {
			key: "color",
			get: function get() {
				return this._color;
			},
			set: function set(value) {
				this._color.r = value.r;
				this._color.g = value.g;
				this._color.b = value.b;
				if (this._meshInstance) {
					this._colorUniform[0] = this._color.r;
					this._colorUniform[1] = this._color.g;
					this._colorUniform[2] = this._color.b;
					this._meshInstance.setParameter(PARAM_EMISSIVE, this._colorUniform);
				}
			}
		}, {
			key: "opacity",
			get: function get() {
				return this._color.a;
			},
			set: function set(value) {
				this._color.a = value;
				if (this._meshInstance) {
					this._meshInstance.setParameter(PARAM_OPACITY, value);
				}
			}
		}, {
			key: "clips",
			get: function get() {
				return this._clips;
			},
			set: function set(value) {
				if (!value) {
					for (var name in this._clips) {
						this.removeClip(name);
					}
					return;
				}
				for (var _name in this._clips) {
					var found = false;
					for (var key in value) {
						if (value[key].name === _name) {
							found = true;
							this._clips[_name].fps = value[key].fps;
							this._clips[_name].loop = value[key].loop;
							if (value[key].hasOwnProperty('sprite')) {
								this._clips[_name].sprite = value[key].sprite;
							} else if (value[key].hasOwnProperty('spriteAsset')) {
								this._clips[_name].spriteAsset = value[key].spriteAsset;
							}
							break;
						}
					}
					if (!found) {
						this.removeClip(_name);
					}
				}
				for (var _key in value) {
					if (this._clips[value[_key].name]) continue;
					this.addClip(value[_key]);
				}
				if (this._autoPlayClip) {
					this._tryAutoPlay();
				}
				if (!this._currentClip || !this._currentClip.sprite) {
					this._hideModel();
				}
			}
		}, {
			key: "currentClip",
			get: function get() {
				return this._currentClip;
			}
		}, {
			key: "speed",
			get: function get() {
				return this._speed;
			},
			set: function set(value) {
				this._speed = value;
			}
		}, {
			key: "flipX",
			get: function get() {
				return this._flipX;
			},
			set: function set(value) {
				if (this._flipX === value) return;
				this._flipX = value;
				this._updateTransform();
			}
		}, {
			key: "flipY",
			get: function get() {
				return this._flipY;
			},
			set: function set(value) {
				if (this._flipY === value) return;
				this._flipY = value;
				this._updateTransform();
			}
		}, {
			key: "width",
			get: function get() {
				return this._width;
			},
			set: function set(value) {
				if (value === this._width) return;
				this._width = value;
				this._outerScale.x = this._width;
				if (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_TILED || this.sprite.renderMode === SPRITE_RENDERMODE_SLICED)) {
					this._updateTransform();
				}
			}
		}, {
			key: "height",
			get: function get() {
				return this._height;
			},
			set: function set(value) {
				if (value === this._height) return;
				this._height = value;
				this._outerScale.y = this.height;
				if (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_TILED || this.sprite.renderMode === SPRITE_RENDERMODE_SLICED)) {
					this._updateTransform();
				}
			}
		}, {
			key: "batchGroupId",
			get: function get() {
				return this._batchGroupId;
			},
			set: function set(value) {
				if (this._batchGroupId === value) return;
				var prev = this._batchGroupId;
				this._batchGroupId = value;
				if (this.entity.enabled && prev >= 0) {
					var _this$system$app$batc;
					(_this$system$app$batc = this.system.app.batcher) == null || _this$system$app$batc.remove(BatchGroup.SPRITE, prev, this.entity);
				}
				if (this.entity.enabled && value >= 0) {
					var _this$system$app$batc2;
					(_this$system$app$batc2 = this.system.app.batcher) == null || _this$system$app$batc2.insert(BatchGroup.SPRITE, value, this.entity);
				} else {
					if (prev >= 0) {
						if (this._currentClip && this._currentClip.sprite && this.enabled && this.entity.enabled) {
							this._showModel();
						}
					}
				}
			}
		}, {
			key: "autoPlayClip",
			get: function get() {
				return this._autoPlayClip;
			},
			set: function set(value) {
				this._autoPlayClip = value instanceof SpriteAnimationClip ? value.name : value;
				this._tryAutoPlay();
			}
		}, {
			key: "drawOrder",
			get: function get() {
				return this._drawOrder;
			},
			set: function set(value) {
				this._drawOrder = value;
				if (this._meshInstance) {
					this._meshInstance.drawOrder = value;
				}
			}
		}, {
			key: "layers",
			get: function get() {
				return this._layers;
			},
			set: function set(value) {
				if (this._addedModel) {
					this._hideModel();
				}
				this._layers = value;
				if (!this._meshInstance) {
					return;
				}
				if (this.enabled && this.entity.enabled) {
					this._showModel();
				}
			}
		}, {
			key: "aabb",
			get: function get() {
				if (this._meshInstance) {
					return this._meshInstance.aabb;
				}
				return null;
			}
		}]);
		return SpriteComponent;
	}(Component);

	var SpriteComponentData = function SpriteComponentData() {
		this.enabled = true;
	};

	var _schema$2 = ['enabled'];
	var SpriteComponentSystem = function (_ComponentSystem) {
		_inheritsLoose(SpriteComponentSystem, _ComponentSystem);
		function SpriteComponentSystem(app) {
			var _this;
			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'sprite';
			_this.ComponentType = SpriteComponent;
			_this.DataType = SpriteComponentData;
			_this.schema = _schema$2;
			_this._defaultTexture = null;
			_this._defaultMaterial = null;
			_this._default9SlicedMaterialSlicedMode = null;
			_this._default9SlicedMaterialTiledMode = null;
			_this.app.systems.on('update', _this.onUpdate, _assertThisInitialized(_this));
			_this.on('beforeremove', _this.onBeforeRemove, _assertThisInitialized(_this));
			return _this;
		}
		var _proto = SpriteComponentSystem.prototype;
		_proto.destroy = function destroy() {
			_ComponentSystem.prototype.destroy.call(this);
			this.app.systems.off('update', this.onUpdate, this);
			if (this._defaultTexture) {
				this._defaultTexture.destroy();
				this._defaultTexture = null;
			}
		};
		_proto.initializeComponentData = function initializeComponentData(component, data, properties) {
			if (data.enabled !== undefined) {
				component.enabled = data.enabled;
			}
			component.type = data.type;
			if (data.layers && Array.isArray(data.layers)) {
				component.layers = data.layers.slice(0);
			}
			if (data.drawOrder !== undefined) {
				component.drawOrder = data.drawOrder;
			}
			if (data.color !== undefined) {
				if (data.color instanceof Color) {
					var _data$opacity;
					component.color.set(data.color.r, data.color.g, data.color.b, (_data$opacity = data.opacity) != null ? _data$opacity : 1);
				} else {
					var _data$opacity2;
					component.color.set(data.color[0], data.color[1], data.color[2], (_data$opacity2 = data.opacity) != null ? _data$opacity2 : 1);
				}
				component.color = component.color;
			}
			if (data.opacity !== undefined) {
				component.opacity = data.opacity;
			}
			if (data.flipX !== undefined) {
				component.flipX = data.flipX;
			}
			if (data.flipY !== undefined) {
				component.flipY = data.flipY;
			}
			if (data.width !== undefined) {
				component.width = data.width;
			}
			if (data.height !== undefined) {
				component.height = data.height;
			}
			if (data.spriteAsset !== undefined) {
				component.spriteAsset = data.spriteAsset;
			}
			if (data.sprite) {
				component.sprite = data.sprite;
			}
			if (data.frame !== undefined) {
				component.frame = data.frame;
			}
			if (data.clips) {
				for (var name in data.clips) {
					component.addClip(data.clips[name]);
				}
			}
			if (data.speed !== undefined) {
				component.speed = data.speed;
			}
			if (data.autoPlayClip) {
				component.autoPlayClip = data.autoPlayClip;
			}
			component.batchGroupId = data.batchGroupId === undefined || data.batchGroupId === null ? -1 : data.batchGroupId;
			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
		};
		_proto.cloneComponent = function cloneComponent(entity, clone) {
			var source = entity.sprite;
			return this.addComponent(clone, {
				enabled: source.enabled,
				type: source.type,
				spriteAsset: source.spriteAsset,
				sprite: source.sprite,
				width: source.width,
				height: source.height,
				frame: source.frame,
				color: source.color.clone(),
				opacity: source.opacity,
				flipX: source.flipX,
				flipY: source.flipY,
				speed: source.speed,
				clips: source.clips,
				autoPlayClip: source.autoPlayClip,
				batchGroupId: source.batchGroupId,
				drawOrder: source.drawOrder,
				layers: source.layers.slice(0)
			});
		};
		_proto.onUpdate = function onUpdate(dt) {
			var components = this.store;
			for (var id in components) {
				if (components.hasOwnProperty(id)) {
					var component = components[id];
					if (component.data.enabled && component.entity.enabled) {
						var sprite = component.entity.sprite;
						if (sprite._currentClip) {
							sprite._currentClip._update(dt);
						}
					}
				}
			}
		};
		_proto.onBeforeRemove = function onBeforeRemove(entity, component) {
			component.onDestroy();
		};
		_createClass(SpriteComponentSystem, [{
			key: "defaultMaterial",
			get: function get() {
				if (!this._defaultMaterial) {
					var texture = new Texture(this.app.graphicsDevice, {
						width: 1,
						height: 1,
						format: PIXELFORMAT_RGBA8,
						name: 'sprite'
					});
					var pixels = new Uint8Array(texture.lock());
					pixels[0] = pixels[1] = pixels[2] = pixels[3] = 255;
					texture.unlock();
					var material = new StandardMaterial();
					material.diffuse.set(0, 0, 0);
					material.emissive.set(0.5, 0.5, 0.5);
					material.emissiveMap = texture;
					material.emissiveTint = true;
					material.opacityMap = texture;
					material.opacityMapChannel = 'a';
					material.opacityTint = true;
					material.opacity = 0;
					material.useLighting = false;
					material.useGammaTonemap = false;
					material.useFog = false;
					material.useSkybox = false;
					material.blendType = BLEND_PREMULTIPLIED;
					material.depthWrite = false;
					material.pixelSnap = false;
					material.cull = CULLFACE_NONE;
					material.update();
					this._defaultTexture = texture;
					this._defaultMaterial = material;
				}
				return this._defaultMaterial;
			},
			set: function set(material) {
				this._defaultMaterial = material;
			}
		}, {
			key: "default9SlicedMaterialSlicedMode",
			get: function get() {
				if (!this._default9SlicedMaterialSlicedMode) {
					var material = this.defaultMaterial.clone();
					material.nineSlicedMode = SPRITE_RENDERMODE_SLICED;
					material.update();
					this._default9SlicedMaterialSlicedMode = material;
				}
				return this._default9SlicedMaterialSlicedMode;
			},
			set: function set(material) {
				this._default9SlicedMaterialSlicedMode = material;
			}
		}, {
			key: "default9SlicedMaterialTiledMode",
			get: function get() {
				if (!this._default9SlicedMaterialTiledMode) {
					var material = this.defaultMaterial.clone();
					material.nineSlicedMode = SPRITE_RENDERMODE_TILED;
					material.update();
					this._default9SlicedMaterialTiledMode = material;
				}
				return this._default9SlicedMaterialTiledMode;
			},
			set: function set(material) {
				this._default9SlicedMaterialTiledMode = material;
			}
		}]);
		return SpriteComponentSystem;
	}(ComponentSystem);
	Component._buildAccessors(SpriteComponent.prototype, _schema$2);

	var ZoneComponent = function (_Component) {
		_inheritsLoose(ZoneComponent, _Component);
		function ZoneComponent(system, entity) {
			var _this;
			_this = _Component.call(this, system, entity) || this;
			_this._oldState = true;
			_this._size = new Vec3();
			_this.on('set_enabled', _this._onSetEnabled, _assertThisInitialized(_this));
			return _this;
		}
		var _proto = ZoneComponent.prototype;
		_proto.onEnable = function onEnable() {
			this._checkState();
		};
		_proto.onDisable = function onDisable() {
			this._checkState();
		};
		_proto._onSetEnabled = function _onSetEnabled(prop, old, value) {
			this._checkState();
		};
		_proto._checkState = function _checkState() {
			var state = this.enabled && this.entity.enabled;
			if (state === this._oldState) return;
			this._oldState = state;
			this.fire('enable');
			this.fire('state', this.enabled);
		};
		_proto._onBeforeRemove = function _onBeforeRemove() {
			this.fire('remove');
		};
		_createClass(ZoneComponent, [{
			key: "size",
			get: function get() {
				return this._size;
			},
			set: function set(data) {
				if (data instanceof Vec3) {
					this._size.copy(data);
				} else if (data instanceof Array && data.length >= 3) {
					this.size.set(data[0], data[1], data[2]);
				}
			}
		}]);
		return ZoneComponent;
	}(Component);

	var ZoneComponentData = function ZoneComponentData() {
		this.enabled = true;
	};

	var _schema$1 = ['enabled'];
	var ZoneComponentSystem = function (_ComponentSystem) {
		_inheritsLoose(ZoneComponentSystem, _ComponentSystem);
		function ZoneComponentSystem(app) {
			var _this;
			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'zone';
			_this.ComponentType = ZoneComponent;
			_this.DataType = ZoneComponentData;
			_this.schema = _schema$1;
			_this.on('beforeremove', _this._onBeforeRemove, _assertThisInitialized(_this));
			return _this;
		}
		var _proto = ZoneComponentSystem.prototype;
		_proto.initializeComponentData = function initializeComponentData(component, data, properties) {
			component.enabled = data.hasOwnProperty('enabled') ? !!data.enabled : true;
			if (data.size) {
				if (data.size instanceof Vec3) {
					component.size.copy(data.size);
				} else if (data.size instanceof Array && data.size.length >= 3) {
					component.size.set(data.size[0], data.size[1], data.size[2]);
				}
			}
		};
		_proto.cloneComponent = function cloneComponent(entity, clone) {
			var data = {
				size: entity.zone.size
			};
			return this.addComponent(clone, data);
		};
		_proto._onBeforeRemove = function _onBeforeRemove(entity, component) {
			component._onBeforeRemove();
		};
		return ZoneComponentSystem;
	}(ComponentSystem);
	Component._buildAccessors(ZoneComponent.prototype, _schema$1);

	var PostEffect = function PostEffect(effect, inputTarget) {
		this.effect = effect;
		this.inputTarget = inputTarget;
		this.outputTarget = null;
		this.name = effect.constructor.name;
	};
	var PostEffectQueue = function () {
		function PostEffectQueue(app, camera) {
			this.app = app;
			this.camera = camera;
			this.destinationRenderTarget = null;
			this.effects = [];
			this.enabled = false;
			this.depthTarget = null;
			camera.on('set:rect', this.onCameraRectChanged, this);
		}
		var _proto = PostEffectQueue.prototype;
		_proto._allocateColorBuffer = function _allocateColorBuffer(format, name) {
			var _renderTarget$width, _renderTarget$height;
			var rect = this.camera.rect;
			var renderTarget = this.destinationRenderTarget;
			var device = this.app.graphicsDevice;
			var width = Math.floor(rect.z * ((_renderTarget$width = renderTarget == null ? void 0 : renderTarget.width) != null ? _renderTarget$width : device.width));
			var height = Math.floor(rect.w * ((_renderTarget$height = renderTarget == null ? void 0 : renderTarget.height) != null ? _renderTarget$height : device.height));
			var colorBuffer = new Texture(device, {
				name: name,
				format: format,
				width: width,
				height: height,
				mipmaps: false,
				minFilter: FILTER_NEAREST,
				magFilter: FILTER_NEAREST,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE
			});
			return colorBuffer;
		};
		_proto._createOffscreenTarget = function _createOffscreenTarget(useDepth, hdr) {
			var device = this.app.graphicsDevice;
			var format = hdr && device.getRenderableHdrFormat([PIXELFORMAT_RGBA16F, PIXELFORMAT_RGBA32F], true) || PIXELFORMAT_RGBA8;
			var name = this.camera.entity.name + '-posteffect-' + this.effects.length;
			var colorBuffer = this._allocateColorBuffer(format, name);
			return new RenderTarget({
				colorBuffer: colorBuffer,
				depth: useDepth,
				stencil: useDepth && this.app.graphicsDevice.supportsStencil,
				samples: useDepth ? device.samples : 1
			});
		};
		_proto._resizeOffscreenTarget = function _resizeOffscreenTarget(rt) {
			var format = rt.colorBuffer.format;
			var name = rt.colorBuffer.name;
			rt.destroyFrameBuffers();
			rt.destroyTextureBuffers();
			rt._colorBuffer = this._allocateColorBuffer(format, name);
			rt._colorBuffers = [rt._colorBuffer];
		};
		_proto._destroyOffscreenTarget = function _destroyOffscreenTarget(rt) {
			rt.destroyTextureBuffers();
			rt.destroy();
		};
		_proto.addEffect = function addEffect(effect) {
			var effects = this.effects;
			var isFirstEffect = effects.length === 0;
			var inputTarget = this._createOffscreenTarget(isFirstEffect, effect.hdr);
			var newEntry = new PostEffect(effect, inputTarget);
			effects.push(newEntry);
			this._sourceTarget = newEntry.inputTarget;
			if (effects.length > 1) {
				effects[effects.length - 2].outputTarget = newEntry.inputTarget;
			}
			this._newPostEffect = effect;
			if (effect.needsDepthBuffer) {
				this._requestDepthMap();
			}
			this.enable();
			this._newPostEffect = undefined;
		};
		_proto.removeEffect = function removeEffect(effect) {
			var index = -1;
			for (var i = 0, len = this.effects.length; i < len; i++) {
				if (this.effects[i].effect === effect) {
					index = i;
					break;
				}
			}
			if (index >= 0) {
				if (index > 0) {
					this.effects[index - 1].outputTarget = index + 1 < this.effects.length ? this.effects[index + 1].inputTarget : null;
				} else {
					if (this.effects.length > 1) {
						if (!this.effects[1].inputTarget._depth) {
							this._destroyOffscreenTarget(this.effects[1].inputTarget);
							this.effects[1].inputTarget = this._createOffscreenTarget(true, this.effects[1].hdr);
							this._sourceTarget = this.effects[1].inputTarget;
						}
						this.camera.renderTarget = this.effects[1].inputTarget;
					}
				}
				this._destroyOffscreenTarget(this.effects[index].inputTarget);
				this.effects.splice(index, 1);
			}
			if (this.enabled) {
				if (effect.needsDepthBuffer) {
					this._releaseDepthMap();
				}
			}
			if (this.effects.length === 0) {
				this.disable();
			}
		};
		_proto._requestDepthMaps = function _requestDepthMaps() {
			for (var i = 0, len = this.effects.length; i < len; i++) {
				var effect = this.effects[i].effect;
				if (this._newPostEffect === effect) continue;
				if (effect.needsDepthBuffer) {
					this._requestDepthMap();
				}
			}
		};
		_proto._releaseDepthMaps = function _releaseDepthMaps() {
			for (var i = 0, len = this.effects.length; i < len; i++) {
				var effect = this.effects[i].effect;
				if (effect.needsDepthBuffer) {
					this._releaseDepthMap();
				}
			}
		};
		_proto._requestDepthMap = function _requestDepthMap() {
			var depthLayer = this.app.scene.layers.getLayerById(LAYERID_DEPTH);
			if (depthLayer) {
				depthLayer.incrementCounter();
				this.camera.requestSceneDepthMap(true);
			}
		};
		_proto._releaseDepthMap = function _releaseDepthMap() {
			var depthLayer = this.app.scene.layers.getLayerById(LAYERID_DEPTH);
			if (depthLayer) {
				depthLayer.decrementCounter();
				this.camera.requestSceneDepthMap(false);
			}
		};
		_proto.destroy = function destroy() {
			for (var i = 0, len = this.effects.length; i < len; i++) {
				this.effects[i].inputTarget.destroy();
			}
			this.effects.length = 0;
			this.disable();
		};
		_proto.enable = function enable() {
			var _this = this;
			if (!this.enabled && this.effects.length) {
				this.enabled = true;
				this._requestDepthMaps();
				this.app.graphicsDevice.on('resizecanvas', this._onCanvasResized, this);
				this.destinationRenderTarget = this.camera.renderTarget;
				this.camera.renderTarget = this.effects[0].inputTarget;
				this.camera.onPostprocessing = function () {
					if (_this.enabled) {
						var rect = null;
						var len = _this.effects.length;
						if (len) {
							for (var i = 0; i < len; i++) {
								var fx = _this.effects[i];
								var destTarget = fx.outputTarget;
								if (i === len - 1) {
									rect = _this.camera.rect;
									if (_this.destinationRenderTarget) {
										destTarget = _this.destinationRenderTarget;
									}
								}
								fx.effect.render(fx.inputTarget, destTarget, rect);
							}
						}
					}
				};
			}
		};
		_proto.disable = function disable() {
			if (this.enabled) {
				this.enabled = false;
				this.app.graphicsDevice.off('resizecanvas', this._onCanvasResized, this);
				this._releaseDepthMaps();
				this._destroyOffscreenTarget(this._sourceTarget);
				this.camera.renderTarget = null;
				this.camera.onPostprocessing = null;
			}
		};
		_proto._onCanvasResized = function _onCanvasResized(width, height) {
			var _renderTarget$width2, _renderTarget$height2;
			var rect = this.camera.rect;
			var renderTarget = this.destinationRenderTarget;
			width = (_renderTarget$width2 = renderTarget == null ? void 0 : renderTarget.width) != null ? _renderTarget$width2 : width;
			height = (_renderTarget$height2 = renderTarget == null ? void 0 : renderTarget.height) != null ? _renderTarget$height2 : height;
			this.camera.camera.aspectRatio = width * rect.z / (height * rect.w);
			this.resizeRenderTargets();
		};
		_proto.resizeRenderTargets = function resizeRenderTargets() {
			var _renderTarget$width3, _renderTarget$height3;
			var device = this.app.graphicsDevice;
			var renderTarget = this.destinationRenderTarget;
			var width = (_renderTarget$width3 = renderTarget == null ? void 0 : renderTarget.width) != null ? _renderTarget$width3 : device.width;
			var height = (_renderTarget$height3 = renderTarget == null ? void 0 : renderTarget.height) != null ? _renderTarget$height3 : device.height;
			var rect = this.camera.rect;
			var desiredWidth = Math.floor(rect.z * width);
			var desiredHeight = Math.floor(rect.w * height);
			var effects = this.effects;
			for (var i = 0, len = effects.length; i < len; i++) {
				var fx = effects[i];
				if (fx.inputTarget.width !== desiredWidth || fx.inputTarget.height !== desiredHeight) {
					this._resizeOffscreenTarget(fx.inputTarget);
				}
			}
		};
		_proto.onCameraRectChanged = function onCameraRectChanged(name, oldValue, newValue) {
			if (this.enabled) {
				this.resizeRenderTargets();
			}
		};
		return PostEffectQueue;
	}();

	var CameraComponent = function (_Component) {
		_inheritsLoose(CameraComponent, _Component);
		function CameraComponent(system, entity) {
			var _this;
			_this = _Component.call(this, system, entity) || this;
			_this.onPostprocessing = null;
			_this.onPreRender = null;
			_this.onPostRender = null;
			_this._renderSceneDepthMap = 0;
			_this._renderSceneColorMap = 0;
			_this._sceneDepthMapRequested = false;
			_this._sceneColorMapRequested = false;
			_this._priority = 0;
			_this._disablePostEffectsLayer = LAYERID_UI;
			_this._camera = new Camera();
			_this._camera.node = entity;
			_this._postEffects = new PostEffectQueue(system.app, _assertThisInitialized(_this));
			return _this;
		}
		var _proto = CameraComponent.prototype;
		_proto.setShaderPass = function setShaderPass(name) {
			var shaderPass = ShaderPass.get(this.system.app.graphicsDevice);
			var shaderPassInfo = name ? shaderPass.allocate(name, {
				isForward: true
			}) : null;
			this._camera.shaderPassInfo = shaderPassInfo;
			return shaderPassInfo.index;
		};
		_proto.getShaderPass = function getShaderPass() {
			var _this$_camera$shaderP;
			return (_this$_camera$shaderP = this._camera.shaderPassInfo) == null ? void 0 : _this$_camera$shaderP.name;
		};
		_proto._enableDepthLayer = function _enableDepthLayer(value) {
			var hasDepthLayer = this.layers.find(function (layerId) {
				return layerId === LAYERID_DEPTH;
			});
			if (hasDepthLayer) {
				var depthLayer = this.system.app.scene.layers.getLayerById(LAYERID_DEPTH);
				if (value) {
					depthLayer == null || depthLayer.incrementCounter();
				} else {
					depthLayer == null || depthLayer.decrementCounter();
				}
			} else if (value) {
				return false;
			}
			return true;
		};
		_proto.requestSceneColorMap = function requestSceneColorMap(enabled) {
			this._renderSceneColorMap += enabled ? 1 : -1;
			this._enableDepthLayer(enabled);
			this.camera._enableRenderPassColorGrab(this.system.app.graphicsDevice, this.renderSceneColorMap);
		};
		_proto.requestSceneDepthMap = function requestSceneDepthMap(enabled) {
			this._renderSceneDepthMap += enabled ? 1 : -1;
			this._enableDepthLayer(enabled);
			this.camera._enableRenderPassDepthGrab(this.system.app.graphicsDevice, this.system.app.renderer, this.renderSceneDepthMap);
		};
		_proto.dirtyLayerCompositionCameras = function dirtyLayerCompositionCameras() {
			var layerComp = this.system.app.scene.layers;
			layerComp._dirty = true;
		};
		_proto.screenToWorld = function screenToWorld(screenx, screeny, cameraz, worldCoord) {
			var device = this.system.app.graphicsDevice;
			var w = device.clientRect.width;
			var h = device.clientRect.height;
			return this._camera.screenToWorld(screenx, screeny, cameraz, w, h, worldCoord);
		};
		_proto.worldToScreen = function worldToScreen(worldCoord, screenCoord) {
			var device = this.system.app.graphicsDevice;
			var w = device.clientRect.width;
			var h = device.clientRect.height;
			return this._camera.worldToScreen(worldCoord, w, h, screenCoord);
		};
		_proto.onAppPrerender = function onAppPrerender() {
			this._camera._viewMatDirty = true;
			this._camera._viewProjMatDirty = true;
		};
		_proto.addCameraToLayers = function addCameraToLayers() {
			var layers = this.layers;
			for (var i = 0; i < layers.length; i++) {
				var layer = this.system.app.scene.layers.getLayerById(layers[i]);
				if (layer) {
					layer.addCamera(this);
				}
			}
		};
		_proto.removeCameraFromLayers = function removeCameraFromLayers() {
			var layers = this.layers;
			for (var i = 0; i < layers.length; i++) {
				var layer = this.system.app.scene.layers.getLayerById(layers[i]);
				if (layer) {
					layer.removeCamera(this);
				}
			}
		};
		_proto.onLayersChanged = function onLayersChanged(oldComp, newComp) {
			this.addCameraToLayers();
			oldComp.off('add', this.onLayerAdded, this);
			oldComp.off('remove', this.onLayerRemoved, this);
			newComp.on('add', this.onLayerAdded, this);
			newComp.on('remove', this.onLayerRemoved, this);
		};
		_proto.onLayerAdded = function onLayerAdded(layer) {
			var index = this.layers.indexOf(layer.id);
			if (index < 0) return;
			layer.addCamera(this);
		};
		_proto.onLayerRemoved = function onLayerRemoved(layer) {
			var index = this.layers.indexOf(layer.id);
			if (index < 0) return;
			layer.removeCamera(this);
		};
		_proto.onEnable = function onEnable() {
			var system = this.system;
			var scene = system.app.scene;
			var layers = scene.layers;
			system.addCamera(this);
			scene.on('set:layers', this.onLayersChanged, this);
			if (layers) {
				layers.on('add', this.onLayerAdded, this);
				layers.on('remove', this.onLayerRemoved, this);
			}
			if (this.enabled && this.entity.enabled) {
				this.addCameraToLayers();
			}
			this.postEffects.enable();
		};
		_proto.onDisable = function onDisable() {
			var system = this.system;
			var scene = system.app.scene;
			var layers = scene.layers;
			this.postEffects.disable();
			this.removeCameraFromLayers();
			scene.off('set:layers', this.onLayersChanged, this);
			if (layers) {
				layers.off('add', this.onLayerAdded, this);
				layers.off('remove', this.onLayerRemoved, this);
			}
			system.removeCamera(this);
		};
		_proto.onRemove = function onRemove() {
			this.onDisable();
			this.off();
			this.camera.destroy();
		};
		_proto.calculateAspectRatio = function calculateAspectRatio(rt) {
			var device = this.system.app.graphicsDevice;
			var width = rt ? rt.width : device.width;
			var height = rt ? rt.height : device.height;
			return width * this.rect.z / (height * this.rect.w);
		};
		_proto.frameUpdate = function frameUpdate(rt) {
			if (this.aspectRatioMode === ASPECT_AUTO) {
				this.aspectRatio = this.calculateAspectRatio(rt);
			}
		};
		_proto.startXr = function startXr(type, spaceType, options) {
			this.system.app.xr.start(this, type, spaceType, options);
		};
		_proto.endXr = function endXr(callback) {
			if (!this._camera.xr) {
				if (callback) callback(new Error('Camera is not in XR'));
				return;
			}
			this._camera.xr.end(callback);
		};
		_proto.copy = function copy(source) {
			this.aperture = source.aperture;
			this.aspectRatio = source.aspectRatio;
			this.aspectRatioMode = source.aspectRatioMode;
			this.calculateProjection = source.calculateProjection;
			this.calculateTransform = source.calculateTransform;
			this.clearColor = source.clearColor;
			this.clearColorBuffer = source.clearColorBuffer;
			this.clearDepthBuffer = source.clearDepthBuffer;
			this.clearStencilBuffer = source.clearStencilBuffer;
			this.cullFaces = source.cullFaces;
			this.disablePostEffectsLayer = source.disablePostEffectsLayer;
			this.farClip = source.farClip;
			this.flipFaces = source.flipFaces;
			this.fov = source.fov;
			this.frustumCulling = source.frustumCulling;
			this.horizontalFov = source.horizontalFov;
			this.layers = source.layers;
			this.nearClip = source.nearClip;
			this.orthoHeight = source.orthoHeight;
			this.priority = source.priority;
			this.projection = source.projection;
			this.rect = source.rect;
			this.renderTarget = source.renderTarget;
			this.scissorRect = source.scissorRect;
			this.sensitivity = source.sensitivity;
			this.shutter = source.shutter;
		};
		_createClass(CameraComponent, [{
			key: "renderPasses",
			get: function get() {
				return this._camera.renderPasses;
			},
			set: function set(passes) {
				this._camera.renderPasses = passes;
			}
		}, {
			key: "aperture",
			get: function get() {
				return this._camera.aperture;
			},
			set: function set(value) {
				this._camera.aperture = value;
			}
		}, {
			key: "aspectRatio",
			get: function get() {
				return this._camera.aspectRatio;
			},
			set: function set(value) {
				this._camera.aspectRatio = value;
			}
		}, {
			key: "aspectRatioMode",
			get: function get() {
				return this._camera.aspectRatioMode;
			},
			set: function set(value) {
				this._camera.aspectRatioMode = value;
			}
		}, {
			key: "calculateProjection",
			get: function get() {
				return this._camera.calculateProjection;
			},
			set: function set(value) {
				this._camera.calculateProjection = value;
			}
		}, {
			key: "calculateTransform",
			get: function get() {
				return this._camera.calculateTransform;
			},
			set: function set(value) {
				this._camera.calculateTransform = value;
			}
		}, {
			key: "camera",
			get: function get() {
				return this._camera;
			}
		}, {
			key: "clearColor",
			get: function get() {
				return this._camera.clearColor;
			},
			set: function set(value) {
				this._camera.clearColor = value;
			}
		}, {
			key: "clearColorBuffer",
			get: function get() {
				return this._camera.clearColorBuffer;
			},
			set: function set(value) {
				this._camera.clearColorBuffer = value;
				this.dirtyLayerCompositionCameras();
			}
		}, {
			key: "clearDepthBuffer",
			get: function get() {
				return this._camera.clearDepthBuffer;
			},
			set: function set(value) {
				this._camera.clearDepthBuffer = value;
				this.dirtyLayerCompositionCameras();
			}
		}, {
			key: "clearStencilBuffer",
			get: function get() {
				return this._camera.clearStencilBuffer;
			},
			set: function set(value) {
				this._camera.clearStencilBuffer = value;
				this.dirtyLayerCompositionCameras();
			}
		}, {
			key: "cullFaces",
			get: function get() {
				return this._camera.cullFaces;
			},
			set: function set(value) {
				this._camera.cullFaces = value;
			}
		}, {
			key: "disablePostEffectsLayer",
			get: function get() {
				return this._disablePostEffectsLayer;
			},
			set: function set(layer) {
				this._disablePostEffectsLayer = layer;
				this.dirtyLayerCompositionCameras();
			}
		}, {
			key: "farClip",
			get: function get() {
				return this._camera.farClip;
			},
			set: function set(value) {
				this._camera.farClip = value;
			}
		}, {
			key: "flipFaces",
			get: function get() {
				return this._camera.flipFaces;
			},
			set: function set(value) {
				this._camera.flipFaces = value;
			}
		}, {
			key: "fov",
			get: function get() {
				return this._camera.fov;
			},
			set: function set(value) {
				this._camera.fov = value;
			}
		}, {
			key: "frustum",
			get: function get() {
				return this._camera.frustum;
			}
		}, {
			key: "frustumCulling",
			get: function get() {
				return this._camera.frustumCulling;
			},
			set: function set(value) {
				this._camera.frustumCulling = value;
			}
		}, {
			key: "horizontalFov",
			get: function get() {
				return this._camera.horizontalFov;
			},
			set: function set(value) {
				this._camera.horizontalFov = value;
			}
		}, {
			key: "layers",
			get: function get() {
				return this._camera.layers;
			},
			set: function set(newValue) {
				var layers = this._camera.layers;
				for (var i = 0; i < layers.length; i++) {
					var layer = this.system.app.scene.layers.getLayerById(layers[i]);
					if (!layer) continue;
					layer.removeCamera(this);
				}
				this._camera.layers = newValue;
				if (!this.enabled || !this.entity.enabled) return;
				for (var _i = 0; _i < newValue.length; _i++) {
					var _layer = this.system.app.scene.layers.getLayerById(newValue[_i]);
					if (!_layer) continue;
					_layer.addCamera(this);
				}
			}
		}, {
			key: "layersSet",
			get: function get() {
				return this._camera.layersSet;
			}
		}, {
			key: "nearClip",
			get: function get() {
				return this._camera.nearClip;
			},
			set: function set(value) {
				this._camera.nearClip = value;
			}
		}, {
			key: "orthoHeight",
			get: function get() {
				return this._camera.orthoHeight;
			},
			set: function set(value) {
				this._camera.orthoHeight = value;
			}
		}, {
			key: "postEffects",
			get: function get() {
				return this._postEffects;
			}
		}, {
			key: "postEffectsEnabled",
			get: function get() {
				return this._postEffects.enabled;
			}
		}, {
			key: "priority",
			get: function get() {
				return this._priority;
			},
			set: function set(newValue) {
				this._priority = newValue;
				this.dirtyLayerCompositionCameras();
			}
		}, {
			key: "projection",
			get: function get() {
				return this._camera.projection;
			},
			set: function set(value) {
				this._camera.projection = value;
			}
		}, {
			key: "projectionMatrix",
			get: function get() {
				return this._camera.projectionMatrix;
			}
		}, {
			key: "rect",
			get: function get() {
				return this._camera.rect;
			},
			set: function set(value) {
				this._camera.rect = value;
				this.fire('set:rect', this._camera.rect);
			}
		}, {
			key: "renderSceneColorMap",
			get: function get() {
				return this._renderSceneColorMap > 0;
			},
			set: function set(value) {
				if (value && !this._sceneColorMapRequested) {
					this.requestSceneColorMap(true);
					this._sceneColorMapRequested = true;
				} else if (this._sceneColorMapRequested) {
					this.requestSceneColorMap(false);
					this._sceneColorMapRequested = false;
				}
			}
		}, {
			key: "renderSceneDepthMap",
			get: function get() {
				return this._renderSceneDepthMap > 0;
			},
			set: function set(value) {
				if (value && !this._sceneDepthMapRequested) {
					this.requestSceneDepthMap(true);
					this._sceneDepthMapRequested = true;
				} else if (this._sceneDepthMapRequested) {
					this.requestSceneDepthMap(false);
					this._sceneDepthMapRequested = false;
				}
			}
		}, {
			key: "renderTarget",
			get: function get() {
				return this._camera.renderTarget;
			},
			set: function set(value) {
				this._camera.renderTarget = value;
				this.dirtyLayerCompositionCameras();
			}
		}, {
			key: "scissorRect",
			get: function get() {
				return this._camera.scissorRect;
			},
			set: function set(value) {
				this._camera.scissorRect = value;
			}
		}, {
			key: "sensitivity",
			get: function get() {
				return this._camera.sensitivity;
			},
			set: function set(value) {
				this._camera.sensitivity = value;
			}
		}, {
			key: "shutter",
			get: function get() {
				return this._camera.shutter;
			},
			set: function set(value) {
				this._camera.shutter = value;
			}
		}, {
			key: "viewMatrix",
			get: function get() {
				return this._camera.viewMatrix;
			}
		}]);
		return CameraComponent;
	}(Component);

	var CameraComponentData = function CameraComponentData() {
		this.enabled = true;
	};

	var _schema = ['enabled'];
	var CameraComponentSystem = function (_ComponentSystem) {
		_inheritsLoose(CameraComponentSystem, _ComponentSystem);
		function CameraComponentSystem(app) {
			var _this;
			_this = _ComponentSystem.call(this, app) || this;
			_this.cameras = [];
			_this.id = 'camera';
			_this.ComponentType = CameraComponent;
			_this.DataType = CameraComponentData;
			_this.schema = _schema;
			_this.on('beforeremove', _this.onBeforeRemove, _assertThisInitialized(_this));
			_this.app.on('prerender', _this.onAppPrerender, _assertThisInitialized(_this));
			_this.app.systems.on('update', _this.onUpdate, _assertThisInitialized(_this));
			return _this;
		}
		var _proto = CameraComponentSystem.prototype;
		_proto.initializeComponentData = function initializeComponentData(component, data, properties) {
			properties = ['aspectRatio', 'aspectRatioMode', 'calculateProjection', 'calculateTransform', 'clearColor', 'clearColorBuffer', 'clearDepthBuffer', 'clearStencilBuffer', 'renderSceneColorMap', 'renderSceneDepthMap', 'cullFaces', 'farClip', 'flipFaces', 'fov', 'frustumCulling', 'horizontalFov', 'layers', 'renderTarget', 'nearClip', 'orthoHeight', 'projection', 'priority', 'rect', 'scissorRect', 'aperture', 'shutter', 'sensitivity'];
			for (var i = 0; i < properties.length; i++) {
				var property = properties[i];
				if (data.hasOwnProperty(property)) {
					var value = data[property];
					switch (property) {
						case 'rect':
						case 'scissorRect':
							if (Array.isArray(value)) {
								component[property] = new Vec4(value[0], value[1], value[2], value[3]);
							} else {
								component[property] = value;
							}
							break;
						case 'clearColor':
							if (Array.isArray(value)) {
								component[property] = new Color(value[0], value[1], value[2], value[3]);
							} else {
								component[property] = value;
							}
							break;
						default:
							component[property] = value;
							break;
					}
				}
			}
			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, ['enabled']);
		};
		_proto.cloneComponent = function cloneComponent(entity, clone) {
			var c = entity.camera;
			return this.addComponent(clone, {
				aspectRatio: c.aspectRatio,
				aspectRatioMode: c.aspectRatioMode,
				calculateProjection: c.calculateProjection,
				calculateTransform: c.calculateTransform,
				clearColor: c.clearColor,
				clearColorBuffer: c.clearColorBuffer,
				clearDepthBuffer: c.clearDepthBuffer,
				clearStencilBuffer: c.clearStencilBuffer,
				renderSceneDepthMap: c.renderSceneDepthMap,
				renderSceneColorMap: c.renderSceneColorMap,
				cullFaces: c.cullFaces,
				enabled: c.enabled,
				farClip: c.farClip,
				flipFaces: c.flipFaces,
				fov: c.fov,
				frustumCulling: c.frustumCulling,
				horizontalFov: c.horizontalFov,
				layers: c.layers,
				renderTarget: c.renderTarget,
				nearClip: c.nearClip,
				orthoHeight: c.orthoHeight,
				projection: c.projection,
				priority: c.priority,
				rect: c.rect,
				scissorRect: c.scissorRect,
				aperture: c.aperture,
				sensitivity: c.sensitivity,
				shutter: c.shutter
			});
		};
		_proto.onBeforeRemove = function onBeforeRemove(entity, component) {
			this.removeCamera(component);
			component.onRemove();
		};
		_proto.onUpdate = function onUpdate(dt) {};
		_proto.onAppPrerender = function onAppPrerender() {
			for (var i = 0, len = this.cameras.length; i < len; i++) {
				this.cameras[i].onAppPrerender();
			}
		};
		_proto.addCamera = function addCamera(camera) {
			this.cameras.push(camera);
			sortPriority(this.cameras);
		};
		_proto.removeCamera = function removeCamera(camera) {
			var index = this.cameras.indexOf(camera);
			if (index >= 0) {
				this.cameras.splice(index, 1);
				sortPriority(this.cameras);
			}
		};
		_proto.destroy = function destroy() {
			_ComponentSystem.prototype.destroy.call(this);
			this.app.systems.off('update', this.onUpdate, this);
		};
		return CameraComponentSystem;
	}(ComponentSystem);
	Component._buildAccessors(CameraComponent.prototype, _schema);

	var _lightProps = [];
	var _lightPropsDefault = [];
	var LightComponent = function (_Component) {
		_inheritsLoose(LightComponent, _Component);
		function LightComponent(system, entity) {
			var _this;
			_this = _Component.call(this, system, entity) || this;
			_this._cookieAsset = null;
			_this._cookieAssetId = null;
			_this._cookieAssetAdd = false;
			_this._cookieMatrix = null;
			return _this;
		}
		var _proto = LightComponent.prototype;
		_proto.addLightToLayers = function addLightToLayers() {
			for (var i = 0; i < this.layers.length; i++) {
				var layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
				if (layer) {
					layer.addLight(this);
					this.light.addLayer(layer);
				}
			}
		};
		_proto.removeLightFromLayers = function removeLightFromLayers() {
			for (var i = 0; i < this.layers.length; i++) {
				var layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
				if (layer) {
					layer.removeLight(this);
					this.light.removeLayer(layer);
				}
			}
		};
		_proto.onLayersChanged = function onLayersChanged(oldComp, newComp) {
			if (this.enabled && this.entity.enabled) {
				this.addLightToLayers();
			}
			oldComp.off('add', this.onLayerAdded, this);
			oldComp.off('remove', this.onLayerRemoved, this);
			newComp.on('add', this.onLayerAdded, this);
			newComp.on('remove', this.onLayerRemoved, this);
		};
		_proto.onLayerAdded = function onLayerAdded(layer) {
			var index = this.layers.indexOf(layer.id);
			if (index >= 0 && this.enabled && this.entity.enabled) {
				layer.addLight(this);
				this.light.addLayer(layer);
			}
		};
		_proto.onLayerRemoved = function onLayerRemoved(layer) {
			var index = this.layers.indexOf(layer.id);
			if (index >= 0) {
				layer.removeLight(this);
				this.light.removeLayer(layer);
			}
		};
		_proto.refreshProperties = function refreshProperties() {
			for (var i = 0; i < _lightProps.length; i++) {
				var name = _lightProps[i];
				this[name] = this[name];
			}
			if (this.enabled && this.entity.enabled) this.onEnable();
		};
		_proto.onCookieAssetSet = function onCookieAssetSet() {
			var forceLoad = false;
			if (this._cookieAsset.type === 'cubemap' && !this._cookieAsset.loadFaces) {
				this._cookieAsset.loadFaces = true;
				forceLoad = true;
			}
			if (!this._cookieAsset.resource || forceLoad) this.system.app.assets.load(this._cookieAsset);
			if (this._cookieAsset.resource) this.onCookieAssetLoad();
		};
		_proto.onCookieAssetAdd = function onCookieAssetAdd(asset) {
			if (this._cookieAssetId !== asset.id) return;
			this._cookieAsset = asset;
			if (this.light.enabled) this.onCookieAssetSet();
			this._cookieAsset.on('load', this.onCookieAssetLoad, this);
			this._cookieAsset.on('remove', this.onCookieAssetRemove, this);
		};
		_proto.onCookieAssetLoad = function onCookieAssetLoad() {
			if (!this._cookieAsset || !this._cookieAsset.resource) return;
			this.cookie = this._cookieAsset.resource;
		};
		_proto.onCookieAssetRemove = function onCookieAssetRemove() {
			if (!this._cookieAssetId) return;
			if (this._cookieAssetAdd) {
				this.system.app.assets.off('add:' + this._cookieAssetId, this.onCookieAssetAdd, this);
				this._cookieAssetAdd = false;
			}
			if (this._cookieAsset) {
				this._cookieAsset.off('load', this.onCookieAssetLoad, this);
				this._cookieAsset.off('remove', this.onCookieAssetRemove, this);
				this._cookieAsset = null;
			}
			this.cookie = null;
		};
		_proto.onEnable = function onEnable() {
			this.light.enabled = true;
			this.system.app.scene.on('set:layers', this.onLayersChanged, this);
			if (this.system.app.scene.layers) {
				this.system.app.scene.layers.on('add', this.onLayerAdded, this);
				this.system.app.scene.layers.on('remove', this.onLayerRemoved, this);
			}
			if (this.enabled && this.entity.enabled) {
				this.addLightToLayers();
			}
			if (this._cookieAsset && !this.cookie) this.onCookieAssetSet();
		};
		_proto.onDisable = function onDisable() {
			this.light.enabled = false;
			this.system.app.scene.off('set:layers', this.onLayersChanged, this);
			if (this.system.app.scene.layers) {
				this.system.app.scene.layers.off('add', this.onLayerAdded, this);
				this.system.app.scene.layers.off('remove', this.onLayerRemoved, this);
			}
			this.removeLightFromLayers();
		};
		_proto.onRemove = function onRemove() {
			this.onDisable();
			this.light.destroy();
			this.cookieAsset = null;
		};
		_createClass(LightComponent, [{
			key: "shadowUpdateOverrides",
			get: function get() {
				return this.light.shadowUpdateOverrides;
			},
			set: function set(values) {
				this.light.shadowUpdateOverrides = values;
			}
		}, {
			key: "penumbraSize",
			get: function get() {
				return this.light.penumbraSize;
			},
			set: function set(value) {
				this.light.penumbraSize = value;
			}
		}]);
		return LightComponent;
	}(Component);
	function _defineProperty(name, defaultValue, setFunc, skipEqualsCheck) {
		var c = LightComponent.prototype;
		_lightProps.push(name);
		_lightPropsDefault.push(defaultValue);
		Object.defineProperty(c, name, {
			get: function get() {
				return this.data[name];
			},
			set: function set(value) {
				var data = this.data;
				var oldValue = data[name];
				if (!skipEqualsCheck && oldValue === value) return;
				data[name] = value;
				if (setFunc) setFunc.call(this, value, oldValue);
			},
			configurable: true
		});
	}
	function _defineProps() {
		_defineProperty('enabled', true, function (newValue, oldValue) {
			this.onSetEnabled(null, oldValue, newValue);
		});
		_defineProperty('light', null);
		_defineProperty('type', 'directional', function (newValue, oldValue) {
			this.system.changeType(this, oldValue, newValue);
			this.refreshProperties();
		});
		_defineProperty('color', new Color(1, 1, 1), function (newValue, oldValue) {
			this.light.setColor(newValue);
		}, true);
		_defineProperty('intensity', 1, function (newValue, oldValue) {
			this.light.intensity = newValue;
		});
		_defineProperty('luminance', 0, function (newValue, oldValue) {
			this.light.luminance = newValue;
		});
		_defineProperty('shape', LIGHTSHAPE_PUNCTUAL, function (newValue, oldValue) {
			this.light.shape = newValue;
		});
		_defineProperty('affectSpecularity', true, function (newValue, oldValue) {
			this.light.affectSpecularity = newValue;
		});
		_defineProperty('castShadows', false, function (newValue, oldValue) {
			this.light.castShadows = newValue;
		});
		_defineProperty('shadowDistance', 40, function (newValue, oldValue) {
			this.light.shadowDistance = newValue;
		});
		_defineProperty('shadowIntensity', 1, function (newValue, oldValue) {
			this.light.shadowIntensity = newValue;
		});
		_defineProperty('shadowResolution', 1024, function (newValue, oldValue) {
			this.light.shadowResolution = newValue;
		});
		_defineProperty('shadowBias', 0.05, function (newValue, oldValue) {
			this.light.shadowBias = -0.01 * math.clamp(newValue, 0, 1);
		});
		_defineProperty('numCascades', 1, function (newValue, oldValue) {
			this.light.numCascades = math.clamp(Math.floor(newValue), 1, 4);
		});
		_defineProperty('bakeNumSamples', 1, function (newValue, oldValue) {
			this.light.bakeNumSamples = math.clamp(Math.floor(newValue), 1, 255);
		});
		_defineProperty('bakeArea', 0, function (newValue, oldValue) {
			this.light.bakeArea = math.clamp(newValue, 0, 180);
		});
		_defineProperty('cascadeDistribution', 0.5, function (newValue, oldValue) {
			this.light.cascadeDistribution = math.clamp(newValue, 0, 1);
		});
		_defineProperty('normalOffsetBias', 0, function (newValue, oldValue) {
			this.light.normalOffsetBias = math.clamp(newValue, 0, 1);
		});
		_defineProperty('range', 10, function (newValue, oldValue) {
			this.light.attenuationEnd = newValue;
		});
		_defineProperty('innerConeAngle', 40, function (newValue, oldValue) {
			this.light.innerConeAngle = newValue;
		});
		_defineProperty('outerConeAngle', 45, function (newValue, oldValue) {
			this.light.outerConeAngle = newValue;
		});
		_defineProperty('falloffMode', LIGHTFALLOFF_LINEAR, function (newValue, oldValue) {
			this.light.falloffMode = newValue;
		});
		_defineProperty('shadowType', SHADOW_PCF3, function (newValue, oldValue) {
			this.light.shadowType = newValue;
		});
		_defineProperty('vsmBlurSize', 11, function (newValue, oldValue) {
			this.light.vsmBlurSize = newValue;
		});
		_defineProperty('vsmBlurMode', BLUR_GAUSSIAN, function (newValue, oldValue) {
			this.light.vsmBlurMode = newValue;
		});
		_defineProperty('vsmBias', 0.01 * 0.25, function (newValue, oldValue) {
			this.light.vsmBias = math.clamp(newValue, 0, 1);
		});
		_defineProperty('cookieAsset', null, function (newValue, oldValue) {
			if (this._cookieAssetId && (newValue instanceof Asset && newValue.id === this._cookieAssetId || newValue === this._cookieAssetId)) return;
			this.onCookieAssetRemove();
			this._cookieAssetId = null;
			if (newValue instanceof Asset) {
				this.data.cookieAsset = newValue.id;
				this._cookieAssetId = newValue.id;
				this.onCookieAssetAdd(newValue);
			} else if (typeof newValue === 'number') {
				this._cookieAssetId = newValue;
				var asset = this.system.app.assets.get(newValue);
				if (asset) {
					this.onCookieAssetAdd(asset);
				} else {
					this._cookieAssetAdd = true;
					this.system.app.assets.on('add:' + this._cookieAssetId, this.onCookieAssetAdd, this);
				}
			}
		});
		_defineProperty('cookie', null, function (newValue, oldValue) {
			this.light.cookie = newValue;
		});
		_defineProperty('cookieIntensity', 1, function (newValue, oldValue) {
			this.light.cookieIntensity = math.clamp(newValue, 0, 1);
		});
		_defineProperty('cookieFalloff', true, function (newValue, oldValue) {
			this.light.cookieFalloff = newValue;
		});
		_defineProperty('cookieChannel', 'rgb', function (newValue, oldValue) {
			this.light.cookieChannel = newValue;
		});
		_defineProperty('cookieAngle', 0, function (newValue, oldValue) {
			if (newValue !== 0 || this.cookieScale !== null) {
				if (!this._cookieMatrix) this._cookieMatrix = new Vec4();
				var scx = 1;
				var scy = 1;
				if (this.cookieScale) {
					scx = this.cookieScale.x;
					scy = this.cookieScale.y;
				}
				var c = Math.cos(newValue * math.DEG_TO_RAD);
				var s = Math.sin(newValue * math.DEG_TO_RAD);
				this._cookieMatrix.set(c / scx, -s / scx, s / scy, c / scy);
				this.light.cookieTransform = this._cookieMatrix;
			} else {
				this.light.cookieTransform = null;
			}
		});
		_defineProperty('cookieScale', null, function (newValue, oldValue) {
			if (newValue !== null || this.cookieAngle !== 0) {
				if (!this._cookieMatrix) this._cookieMatrix = new Vec4();
				var scx = newValue.x;
				var scy = newValue.y;
				var c = Math.cos(this.cookieAngle * math.DEG_TO_RAD);
				var s = Math.sin(this.cookieAngle * math.DEG_TO_RAD);
				this._cookieMatrix.set(c / scx, -s / scx, s / scy, c / scy);
				this.light.cookieTransform = this._cookieMatrix;
			} else {
				this.light.cookieTransform = null;
			}
		}, true);
		_defineProperty('cookieOffset', null, function (newValue, oldValue) {
			this.light.cookieOffset = newValue;
		}, true);
		_defineProperty('shadowUpdateMode', SHADOWUPDATE_REALTIME, function (newValue, oldValue) {
			this.light.shadowUpdateMode = newValue;
		}, true);
		_defineProperty('mask', 1, function (newValue, oldValue) {
			this.light.mask = newValue;
		});
		_defineProperty('affectDynamic', true, function (newValue, oldValue) {
			if (newValue) {
				this.light.mask |= MASK_AFFECT_DYNAMIC;
			} else {
				this.light.mask &= ~MASK_AFFECT_DYNAMIC;
			}
			this.light.layersDirty();
		});
		_defineProperty('affectLightmapped', false, function (newValue, oldValue) {
			if (newValue) {
				this.light.mask |= MASK_AFFECT_LIGHTMAPPED;
				if (this.bake) this.light.mask &= ~MASK_BAKE;
			} else {
				this.light.mask &= ~MASK_AFFECT_LIGHTMAPPED;
				if (this.bake) this.light.mask |= MASK_BAKE;
			}
		});
		_defineProperty('bake', false, function (newValue, oldValue) {
			if (newValue) {
				this.light.mask |= MASK_BAKE;
				if (this.affectLightmapped) this.light.mask &= ~MASK_AFFECT_LIGHTMAPPED;
			} else {
				this.light.mask &= ~MASK_BAKE;
				if (this.affectLightmapped) this.light.mask |= MASK_AFFECT_LIGHTMAPPED;
			}
			this.light.layersDirty();
		});
		_defineProperty('bakeDir', true, function (newValue, oldValue) {
			this.light.bakeDir = newValue;
		});
		_defineProperty('isStatic', false, function (newValue, oldValue) {
			this.light.isStatic = newValue;
		});
		_defineProperty('layers', [LAYERID_WORLD], function (newValue, oldValue) {
			for (var i = 0; i < oldValue.length; i++) {
				var layer = this.system.app.scene.layers.getLayerById(oldValue[i]);
				if (!layer) continue;
				layer.removeLight(this);
				this.light.removeLayer(layer);
			}
			for (var _i = 0; _i < newValue.length; _i++) {
				var _layer = this.system.app.scene.layers.getLayerById(newValue[_i]);
				if (!_layer) continue;
				if (this.enabled && this.entity.enabled) {
					_layer.addLight(this);
					this.light.addLayer(_layer);
				}
			}
		});
		_lightProps.push("penumbraSize");
		_lightPropsDefault.push(1);
	}
	_defineProps();

	var LightComponentData = function LightComponentData() {
		var _props = _lightProps;
		var _propsDefault = _lightPropsDefault;
		for (var i = 0; i < _props.length; i++) {
			var value = _propsDefault[i];
			if (value && value.clone) {
				this[_props[i]] = value.clone();
			} else {
				this[_props[i]] = value;
			}
		}
	};

	var LightComponentSystem = function (_ComponentSystem) {
		_inheritsLoose(LightComponentSystem, _ComponentSystem);
		function LightComponentSystem(app) {
			var _this;
			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'light';
			_this.ComponentType = LightComponent;
			_this.DataType = LightComponentData;
			_this.on('beforeremove', _this._onRemoveComponent, _assertThisInitialized(_this));
			return _this;
		}
		var _proto = LightComponentSystem.prototype;
		_proto.initializeComponentData = function initializeComponentData(component, _data) {
			var properties = _lightProps;
			var data = {};
			for (var i = 0, len = properties.length; i < len; i++) {
				var property = properties[i];
				data[property] = _data[property];
			}
			if (!data.type) data.type = component.data.type;
			component.data.type = data.type;
			if (data.layers && Array.isArray(data.layers)) {
				data.layers = data.layers.slice(0);
			}
			if (data.color && Array.isArray(data.color)) data.color = new Color(data.color[0], data.color[1], data.color[2]);
			if (data.cookieOffset && data.cookieOffset instanceof Array) data.cookieOffset = new Vec2(data.cookieOffset[0], data.cookieOffset[1]);
			if (data.cookieScale && data.cookieScale instanceof Array) data.cookieScale = new Vec2(data.cookieScale[0], data.cookieScale[1]);
			if (data.enable) {
				console.warn('WARNING: enable: Property is deprecated. Set enabled property instead.');
				data.enabled = data.enable;
			}
			if (!data.shape) {
				data.shape = LIGHTSHAPE_PUNCTUAL;
			}
			var light = new Light(this.app.graphicsDevice);
			light.type = lightTypes[data.type];
			light._node = component.entity;
			component.data.light = light;
			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
		};
		_proto._onRemoveComponent = function _onRemoveComponent(entity, component) {
			component.onRemove();
		};
		_proto.cloneComponent = function cloneComponent(entity, clone) {
			var light = entity.light;
			var data = [];
			var name;
			var _props = _lightProps;
			for (var i = 0; i < _props.length; i++) {
				name = _props[i];
				if (name === 'light') continue;
				if (light[name] && light[name].clone) {
					data[name] = light[name].clone();
				} else {
					data[name] = light[name];
				}
			}
			return this.addComponent(clone, data);
		};
		_proto.changeType = function changeType(component, oldValue, newValue) {
			if (oldValue !== newValue) {
				component.light.type = lightTypes[newValue];
			}
		};
		return LightComponentSystem;
	}(ComponentSystem);

	var components = ['x', 'y', 'z', 'w'];
	var vecLookup = [undefined, undefined, Vec2, Vec3, Vec4];
	function rawToValue(app, args, value, old) {
		switch (args.type) {
			case 'boolean':
				return !!value;
			case 'number':
				if (typeof value === 'number') {
					return value;
				} else if (typeof value === 'string') {
					var v = parseInt(value, 10);
					if (isNaN(v)) return null;
					return v;
				} else if (typeof value === 'boolean') {
					return 0 + value;
				}
				return null;
			case 'json':
				{
					var result = {};
					if (Array.isArray(args.schema)) {
						if (!value || typeof value !== 'object') {
							value = {};
						}
						for (var i = 0; i < args.schema.length; i++) {
							var field = args.schema[i];
							if (!field.name) continue;
							if (field.array) {
								result[field.name] = [];
								var arr = Array.isArray(value[field.name]) ? value[field.name] : [];
								for (var j = 0; j < arr.length; j++) {
									result[field.name].push(rawToValue(app, field, arr[j]));
								}
							} else {
								var val = value.hasOwnProperty(field.name) ? value[field.name] : field.default;
								result[field.name] = rawToValue(app, field, val);
							}
						}
					}
					return result;
				}
			case 'asset':
				if (value instanceof Asset) {
					return value;
				} else if (typeof value === 'number') {
					return app.assets.get(value) || null;
				} else if (typeof value === 'string') {
					return app.assets.get(parseInt(value, 10)) || null;
				}
				return null;
			case 'entity':
				if (value instanceof GraphNode) {
					return value;
				} else if (typeof value === 'string') {
					return app.getEntityFromIndex(value);
				}
				return null;
			case 'rgb':
			case 'rgba':
				if (value instanceof Color) {
					if (old instanceof Color) {
						old.copy(value);
						return old;
					}
					return value.clone();
				} else if (value instanceof Array && value.length >= 3 && value.length <= 4) {
					for (var _i = 0; _i < value.length; _i++) {
						if (typeof value[_i] !== 'number') return null;
					}
					if (!old) old = new Color();
					old.r = value[0];
					old.g = value[1];
					old.b = value[2];
					old.a = value.length === 3 ? 1 : value[3];
					return old;
				} else if (typeof value === 'string' && /#([0-9abcdef]{2}){3,4}/i.test(value)) {
					if (!old) old = new Color();
					old.fromString(value);
					return old;
				}
				return null;
			case 'vec2':
			case 'vec3':
			case 'vec4':
				{
					var len = parseInt(args.type.slice(3), 10);
					var vecType = vecLookup[len];
					if (value instanceof vecType) {
						if (old instanceof vecType) {
							old.copy(value);
							return old;
						}
						return value.clone();
					} else if (value instanceof Array && value.length === len) {
						for (var _i2 = 0; _i2 < value.length; _i2++) {
							if (typeof value[_i2] !== 'number') return null;
						}
						if (!old) old = new vecType();
						for (var _i3 = 0; _i3 < len; _i3++) old[components[_i3]] = value[_i3];
						return old;
					}
					return null;
				}
			case 'curve':
				if (value) {
					var curve;
					if (value instanceof Curve || value instanceof CurveSet) {
						curve = value.clone();
					} else {
						var CurveType = value.keys[0] instanceof Array ? CurveSet : Curve;
						curve = new CurveType(value.keys);
						curve.type = value.type;
					}
					return curve;
				}
				break;
		}
		return value;
	}
	var ScriptAttributes = function () {
		function ScriptAttributes(scriptType) {
			this.scriptType = scriptType;
			this.index = {};
		}
		var _proto = ScriptAttributes.prototype;
		_proto.add = function add(name, args) {
			if (this.index[name]) {
				return;
			} else if (ScriptAttributes.reservedNames.has(name)) {
				return;
			}
			this.index[name] = args;
			Object.defineProperty(this.scriptType.prototype, name, {
				get: function get() {
					return this.__attributes[name];
				},
				set: function set(raw) {
					var evt = 'attr';
					var evtName = 'attr:' + name;
					var old = this.__attributes[name];
					var oldCopy = old;
					if (old && args.type !== 'json' && args.type !== 'entity' && old.clone) {
						if (this.hasEvent(evt) || this.hasEvent(evtName)) {
							oldCopy = old.clone();
						}
					}
					if (args.array) {
						this.__attributes[name] = [];
						if (raw) {
							for (var i = 0, len = raw.length; i < len; i++) {
								this.__attributes[name].push(rawToValue(this.app, args, raw[i], old ? old[i] : null));
							}
						}
					} else {
						this.__attributes[name] = rawToValue(this.app, args, raw, old);
					}
					this.fire(evt, name, this.__attributes[name], oldCopy);
					this.fire(evtName, this.__attributes[name], oldCopy);
				}
			});
		};
		_proto.remove = function remove(name) {
			if (!this.index[name]) return false;
			delete this.index[name];
			delete this.scriptType.prototype[name];
			return true;
		};
		_proto.has = function has(name) {
			return !!this.index[name];
		};
		_proto.get = function get(name) {
			return this.index[name] || null;
		};
		return ScriptAttributes;
	}();
	ScriptAttributes.reservedNames = new Set(['app', 'entity', 'enabled', '_enabled', '_enabledOld', '_destroyed', '__attributes', '__attributesRaw', '__scriptType', '__executionOrder', '_callbacks', '_callbackActive', 'has', 'get', 'on', 'off', 'fire', 'once', 'hasEvent']);

	var SCRIPT_INITIALIZE = 'initialize';
	var SCRIPT_POST_INITIALIZE = 'postInitialize';
	var SCRIPT_UPDATE = 'update';
	var SCRIPT_POST_UPDATE = 'postUpdate';
	var SCRIPT_SWAP = 'swap';

	var ScriptComponent = function (_Component) {
		_inheritsLoose(ScriptComponent, _Component);
		function ScriptComponent(system, entity) {
			var _this;
			_this = _Component.call(this, system, entity) || this;
			_this._scripts = [];
			_this._updateList = new SortedLoopArray({
				sortBy: '__executionOrder'
			});
			_this._postUpdateList = new SortedLoopArray({
				sortBy: '__executionOrder'
			});
			_this._scriptsIndex = {};
			_this._destroyedScripts = [];
			_this._destroyed = false;
			_this._scriptsData = null;
			_this._oldState = true;
			_this._enabled = true;
			_this._beingEnabled = false;
			_this._isLoopingThroughScripts = false;
			_this._executionOrder = -1;
			_this.on('set_enabled', _this._onSetEnabled, _assertThisInitialized(_this));
			return _this;
		}
		var _proto = ScriptComponent.prototype;
		_proto.onEnable = function onEnable() {
			this._beingEnabled = true;
			this._checkState();
			if (!this.entity._beingEnabled) {
				this.onPostStateChange();
			}
			this._beingEnabled = false;
		};
		_proto.onDisable = function onDisable() {
			this._checkState();
		};
		_proto.onPostStateChange = function onPostStateChange() {
			var wasLooping = this._beginLooping();
			for (var i = 0, len = this.scripts.length; i < len; i++) {
				var script = this.scripts[i];
				if (script._initialized && !script._postInitialized && script.enabled) {
					script._postInitialized = true;
					if (script.postInitialize) this._scriptMethod(script, SCRIPT_POST_INITIALIZE);
				}
			}
			this._endLooping(wasLooping);
		};
		_proto._beginLooping = function _beginLooping() {
			var looping = this._isLoopingThroughScripts;
			this._isLoopingThroughScripts = true;
			return looping;
		};
		_proto._endLooping = function _endLooping(wasLoopingBefore) {
			this._isLoopingThroughScripts = wasLoopingBefore;
			if (!this._isLoopingThroughScripts) {
				this._removeDestroyedScripts();
			}
		};
		_proto._onSetEnabled = function _onSetEnabled(prop, old, value) {
			this._beingEnabled = true;
			this._checkState();
			this._beingEnabled = false;
		};
		_proto._checkState = function _checkState() {
			var state = this.enabled && this.entity.enabled;
			if (state === this._oldState) return;
			this._oldState = state;
			this.fire(state ? 'enable' : 'disable');
			this.fire('state', state);
			if (state) {
				this.system._addComponentToEnabled(this);
			} else {
				this.system._removeComponentFromEnabled(this);
			}
			var wasLooping = this._beginLooping();
			for (var i = 0, len = this.scripts.length; i < len; i++) {
				var script = this.scripts[i];
				script.enabled = script._enabled;
			}
			this._endLooping(wasLooping);
		};
		_proto._onBeforeRemove = function _onBeforeRemove() {
			this.fire('remove');
			var wasLooping = this._beginLooping();
			for (var i = 0; i < this.scripts.length; i++) {
				var script = this.scripts[i];
				if (!script) continue;
				this.destroy(script.__scriptType.__name);
			}
			this._endLooping(wasLooping);
		};
		_proto._removeDestroyedScripts = function _removeDestroyedScripts() {
			var len = this._destroyedScripts.length;
			if (!len) return;
			for (var i = 0; i < len; i++) {
				var script = this._destroyedScripts[i];
				this._removeScriptInstance(script);
			}
			this._destroyedScripts.length = 0;
			this._resetExecutionOrder(0, this._scripts.length);
		};
		_proto._onInitializeAttributes = function _onInitializeAttributes() {
			for (var i = 0, len = this.scripts.length; i < len; i++) this.scripts[i].__initializeAttributes();
		};
		_proto._scriptMethod = function _scriptMethod(script, method, arg) {
			script[method](arg);
		};
		_proto._onInitialize = function _onInitialize() {
			var scripts = this._scripts;
			var wasLooping = this._beginLooping();
			for (var i = 0, len = scripts.length; i < len; i++) {
				var script = scripts[i];
				if (!script._initialized && script.enabled) {
					script._initialized = true;
					if (script.initialize) this._scriptMethod(script, SCRIPT_INITIALIZE);
				}
			}
			this._endLooping(wasLooping);
		};
		_proto._onPostInitialize = function _onPostInitialize() {
			this.onPostStateChange();
		};
		_proto._onUpdate = function _onUpdate(dt) {
			var list = this._updateList;
			if (!list.length) return;
			var wasLooping = this._beginLooping();
			for (list.loopIndex = 0; list.loopIndex < list.length; list.loopIndex++) {
				var script = list.items[list.loopIndex];
				if (script.enabled) {
					this._scriptMethod(script, SCRIPT_UPDATE, dt);
				}
			}
			this._endLooping(wasLooping);
		};
		_proto._onPostUpdate = function _onPostUpdate(dt) {
			var list = this._postUpdateList;
			if (!list.length) return;
			var wasLooping = this._beginLooping();
			for (list.loopIndex = 0; list.loopIndex < list.length; list.loopIndex++) {
				var script = list.items[list.loopIndex];
				if (script.enabled) {
					this._scriptMethod(script, SCRIPT_POST_UPDATE, dt);
				}
			}
			this._endLooping(wasLooping);
		};
		_proto._insertScriptInstance = function _insertScriptInstance(scriptInstance, index, scriptsLength) {
			if (index === -1) {
				this._scripts.push(scriptInstance);
				scriptInstance.__executionOrder = scriptsLength;
				if (scriptInstance.update) {
					this._updateList.append(scriptInstance);
				}
				if (scriptInstance.postUpdate) {
					this._postUpdateList.append(scriptInstance);
				}
			} else {
				this._scripts.splice(index, 0, scriptInstance);
				scriptInstance.__executionOrder = index;
				this._resetExecutionOrder(index + 1, scriptsLength + 1);
				if (scriptInstance.update) {
					this._updateList.insert(scriptInstance);
				}
				if (scriptInstance.postUpdate) {
					this._postUpdateList.insert(scriptInstance);
				}
			}
		};
		_proto._removeScriptInstance = function _removeScriptInstance(scriptInstance) {
			var idx = this._scripts.indexOf(scriptInstance);
			if (idx === -1) return idx;
			this._scripts.splice(idx, 1);
			if (scriptInstance.update) {
				this._updateList.remove(scriptInstance);
			}
			if (scriptInstance.postUpdate) {
				this._postUpdateList.remove(scriptInstance);
			}
			return idx;
		};
		_proto._resetExecutionOrder = function _resetExecutionOrder(startIndex, scriptsLength) {
			for (var i = startIndex; i < scriptsLength; i++) {
				this._scripts[i].__executionOrder = i;
			}
		};
		_proto._resolveEntityScriptAttribute = function _resolveEntityScriptAttribute(attribute, attributeName, oldValue, useGuid, newAttributes, duplicatedIdsMap) {
			if (attribute.array) {
				var len = oldValue.length;
				if (!len) {
					return;
				}
				var newGuidArray = oldValue.slice();
				for (var i = 0; i < len; i++) {
					var guid = newGuidArray[i] instanceof Entity ? newGuidArray[i].getGuid() : newGuidArray[i];
					if (duplicatedIdsMap[guid]) {
						newGuidArray[i] = useGuid ? duplicatedIdsMap[guid].getGuid() : duplicatedIdsMap[guid];
					}
				}
				newAttributes[attributeName] = newGuidArray;
			} else {
				if (oldValue instanceof Entity) {
					oldValue = oldValue.getGuid();
				} else if (typeof oldValue !== 'string') {
					return;
				}
				if (duplicatedIdsMap[oldValue]) {
					newAttributes[attributeName] = duplicatedIdsMap[oldValue];
				}
			}
		};
		_proto.has = function has(nameOrType) {
			if (typeof nameOrType === 'string') {
				return !!this._scriptsIndex[nameOrType];
			}
			if (!nameOrType) return false;
			var scriptType = nameOrType;
			var scriptName = scriptType.__name;
			var scriptData = this._scriptsIndex[scriptName];
			var scriptInstance = scriptData && scriptData.instance;
			return scriptInstance instanceof scriptType;
		};
		_proto.get = function get(nameOrType) {
			if (typeof nameOrType === 'string') {
				var data = this._scriptsIndex[nameOrType];
				return data ? data.instance : null;
			}
			if (!nameOrType) return null;
			var scriptType = nameOrType;
			var scriptName = scriptType.__name;
			var scriptData = this._scriptsIndex[scriptName];
			var scriptInstance = scriptData && scriptData.instance;
			return scriptInstance instanceof scriptType ? scriptInstance : null;
		};
		_proto.create = function create(nameOrType, args) {
			if (args === void 0) {
				args = {};
			}
			var self = this;
			var scriptType = nameOrType;
			var scriptName = nameOrType;
			if (typeof scriptType === 'string') {
				scriptType = this.system.app.scripts.get(scriptType);
			} else if (scriptType) {
				scriptName = scriptType.__name;
			}
			if (scriptType) {
				if (!this._scriptsIndex[scriptName] || !this._scriptsIndex[scriptName].instance) {
					var scriptInstance = new scriptType({
						app: this.system.app,
						entity: this.entity,
						enabled: args.hasOwnProperty('enabled') ? args.enabled : true,
						attributes: args.attributes
					});
					var len = this._scripts.length;
					var ind = -1;
					if (typeof args.ind === 'number' && args.ind !== -1 && len > args.ind) ind = args.ind;
					this._insertScriptInstance(scriptInstance, ind, len);
					this._scriptsIndex[scriptName] = {
						instance: scriptInstance,
						onSwap: function onSwap() {
							self.swap(scriptName);
						}
					};
					this[scriptName] = scriptInstance;
					if (!args.preloading) scriptInstance.__initializeAttributes();
					this.fire('create', scriptName, scriptInstance);
					this.fire('create:' + scriptName, scriptInstance);
					this.system.app.scripts.on('swap:' + scriptName, this._scriptsIndex[scriptName].onSwap);
					if (!args.preloading) {
						if (scriptInstance.enabled && !scriptInstance._initialized) {
							scriptInstance._initialized = true;
							if (scriptInstance.initialize) this._scriptMethod(scriptInstance, SCRIPT_INITIALIZE);
						}
						if (scriptInstance.enabled && !scriptInstance._postInitialized) {
							scriptInstance._postInitialized = true;
							if (scriptInstance.postInitialize) this._scriptMethod(scriptInstance, SCRIPT_POST_INITIALIZE);
						}
					}
					return scriptInstance;
				}
			} else {
				this._scriptsIndex[scriptName] = {
					awaiting: true,
					ind: this._scripts.length
				};
			}
			return null;
		};
		_proto.destroy = function destroy(nameOrType) {
			var scriptName = nameOrType;
			var scriptType = nameOrType;
			if (typeof scriptType === 'string') {
				scriptType = this.system.app.scripts.get(scriptType);
			} else if (scriptType) {
				scriptName = scriptType.__name;
			}
			var scriptData = this._scriptsIndex[scriptName];
			delete this._scriptsIndex[scriptName];
			if (!scriptData) return false;
			var scriptInstance = scriptData.instance;
			if (scriptInstance && !scriptInstance._destroyed) {
				scriptInstance.enabled = false;
				scriptInstance._destroyed = true;
				if (!this._isLoopingThroughScripts) {
					var ind = this._removeScriptInstance(scriptInstance);
					if (ind >= 0) {
						this._resetExecutionOrder(ind, this._scripts.length);
					}
				} else {
					this._destroyedScripts.push(scriptInstance);
				}
			}
			this.system.app.scripts.off('swap:' + scriptName, scriptData.onSwap);
			delete this[scriptName];
			this.fire('destroy', scriptName, scriptInstance || null);
			this.fire('destroy:' + scriptName, scriptInstance || null);
			if (scriptInstance) scriptInstance.fire('destroy');
			return true;
		};
		_proto.swap = function swap(nameOrType) {
			var scriptName = nameOrType;
			var scriptType = nameOrType;
			if (typeof scriptType === 'string') {
				scriptType = this.system.app.scripts.get(scriptType);
			} else if (scriptType) {
				scriptName = scriptType.__name;
			}
			var old = this._scriptsIndex[scriptName];
			if (!old || !old.instance) return false;
			var scriptInstanceOld = old.instance;
			var ind = this._scripts.indexOf(scriptInstanceOld);
			var scriptInstance = new scriptType({
				app: this.system.app,
				entity: this.entity,
				enabled: scriptInstanceOld.enabled,
				attributes: scriptInstanceOld.__attributes
			});
			if (!scriptInstance.swap) return false;
			scriptInstance.__initializeAttributes();
			this._scripts[ind] = scriptInstance;
			this._scriptsIndex[scriptName].instance = scriptInstance;
			this[scriptName] = scriptInstance;
			scriptInstance.__executionOrder = ind;
			if (scriptInstanceOld.update) {
				this._updateList.remove(scriptInstanceOld);
			}
			if (scriptInstanceOld.postUpdate) {
				this._postUpdateList.remove(scriptInstanceOld);
			}
			if (scriptInstance.update) {
				this._updateList.insert(scriptInstance);
			}
			if (scriptInstance.postUpdate) {
				this._postUpdateList.insert(scriptInstance);
			}
			this._scriptMethod(scriptInstance, SCRIPT_SWAP, scriptInstanceOld);
			this.fire('swap', scriptName, scriptInstance);
			this.fire('swap:' + scriptName, scriptInstance);
			return true;
		};
		_proto.resolveDuplicatedEntityReferenceProperties = function resolveDuplicatedEntityReferenceProperties(oldScriptComponent, duplicatedIdsMap) {
			var newScriptComponent = this.entity.script;
			for (var scriptName in oldScriptComponent._scriptsIndex) {
				var scriptType = this.system.app.scripts.get(scriptName);
				if (!scriptType) {
					continue;
				}
				var script = oldScriptComponent._scriptsIndex[scriptName];
				if (!script || !script.instance) {
					continue;
				}
				var newAttributesRaw = newScriptComponent[scriptName].__attributesRaw;
				var newAttributes = newScriptComponent[scriptName].__attributes;
				if (!newAttributesRaw && !newAttributes) {
					continue;
				}
				var useGuid = !!newAttributesRaw;
				var oldAttributes = script.instance.__attributes;
				for (var attributeName in oldAttributes) {
					if (!oldAttributes[attributeName]) {
						continue;
					}
					var attribute = scriptType.attributes.get(attributeName);
					if (!attribute) {
						continue;
					}
					if (attribute.type === 'entity') {
						this._resolveEntityScriptAttribute(attribute, attributeName, oldAttributes[attributeName], useGuid, newAttributesRaw || newAttributes, duplicatedIdsMap);
					} else if (attribute.type === 'json' && Array.isArray(attribute.schema)) {
						var oldValue = oldAttributes[attributeName];
						var newJsonValue = newAttributesRaw ? newAttributesRaw[attributeName] : newAttributes[attributeName];
						for (var i = 0; i < attribute.schema.length; i++) {
							var field = attribute.schema[i];
							if (field.type !== 'entity') {
								continue;
							}
							if (attribute.array) {
								for (var j = 0; j < oldValue.length; j++) {
									this._resolveEntityScriptAttribute(field, field.name, oldValue[j][field.name], useGuid, newJsonValue[j], duplicatedIdsMap);
								}
							} else {
								this._resolveEntityScriptAttribute(field, field.name, oldValue[field.name], useGuid, newJsonValue, duplicatedIdsMap);
							}
						}
					}
				}
			}
		};
		_proto.move = function move(nameOrType, ind) {
			var len = this._scripts.length;
			if (ind >= len || ind < 0) return false;
			var scriptType = nameOrType;
			var scriptName = nameOrType;
			if (typeof scriptName !== 'string') {
				scriptName = nameOrType.__name;
			} else {
				scriptType = null;
			}
			var scriptData = this._scriptsIndex[scriptName];
			if (!scriptData || !scriptData.instance) return false;
			var scriptInstance = scriptData.instance;
			if (scriptType && !(scriptInstance instanceof scriptType)) return false;
			var indOld = this._scripts.indexOf(scriptInstance);
			if (indOld === -1 || indOld === ind) return false;
			this._scripts.splice(ind, 0, this._scripts.splice(indOld, 1)[0]);
			this._resetExecutionOrder(0, len);
			this._updateList.sort();
			this._postUpdateList.sort();
			this.fire('move', scriptName, scriptInstance, ind, indOld);
			this.fire('move:' + scriptName, scriptInstance, ind, indOld);
			return true;
		};
		_createClass(ScriptComponent, [{
			key: "scripts",
			get: function get() {
				return this._scripts;
			},
			set: function set(value) {
				this._scriptsData = value;
				for (var key in value) {
					if (!value.hasOwnProperty(key)) continue;
					var script = this._scriptsIndex[key];
					if (script) {
						if (typeof value[key].enabled === 'boolean') script.enabled = !!value[key].enabled;
						if (typeof value[key].attributes === 'object') {
							for (var attr in value[key].attributes) {
								if (ScriptAttributes.reservedNames.has(attr)) continue;
								if (!script.__attributes.hasOwnProperty(attr)) {
									var scriptType = this.system.app.scripts.get(key);
									if (scriptType) scriptType.attributes.add(attr, {});
								}
								script[attr] = value[key].attributes[attr];
							}
						}
					} else {
						console.log(this.order);
					}
				}
			}
		}, {
			key: "enabled",
			get: function get() {
				return this._enabled;
			},
			set: function set(value) {
				var oldValue = this._enabled;
				this._enabled = value;
				this.fire('set', 'enabled', oldValue, value);
			}
		}]);
		return ScriptComponent;
	}(Component);

	var ScriptComponentData = function ScriptComponentData() {
		this.enabled = true;
	};

	var METHOD_INITIALIZE_ATTRIBUTES = '_onInitializeAttributes';
	var METHOD_INITIALIZE = '_onInitialize';
	var METHOD_POST_INITIALIZE = '_onPostInitialize';
	var METHOD_UPDATE = '_onUpdate';
	var METHOD_POST_UPDATE = '_onPostUpdate';
	var executionOrderCounter = 0;
	var ScriptComponentSystem = function (_ComponentSystem) {
		_inheritsLoose(ScriptComponentSystem, _ComponentSystem);
		function ScriptComponentSystem(app) {
			var _this;
			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'script';
			_this.ComponentType = ScriptComponent;
			_this.DataType = ScriptComponentData;
			_this._components = new SortedLoopArray({
				sortBy: '_executionOrder'
			});
			_this._enabledComponents = new SortedLoopArray({
				sortBy: '_executionOrder'
			});
			_this.preloading = true;
			_this.on('beforeremove', _this._onBeforeRemove, _assertThisInitialized(_this));
			_this.app.systems.on('initialize', _this._onInitialize, _assertThisInitialized(_this));
			_this.app.systems.on('postInitialize', _this._onPostInitialize, _assertThisInitialized(_this));
			_this.app.systems.on('update', _this._onUpdate, _assertThisInitialized(_this));
			_this.app.systems.on('postUpdate', _this._onPostUpdate, _assertThisInitialized(_this));
			return _this;
		}
		var _proto = ScriptComponentSystem.prototype;
		_proto.initializeComponentData = function initializeComponentData(component, data) {
			component._executionOrder = executionOrderCounter++;
			this._components.append(component);
			if (executionOrderCounter > Number.MAX_SAFE_INTEGER) {
				this._resetExecutionOrder();
			}
			component.enabled = data.hasOwnProperty('enabled') ? !!data.enabled : true;
			if (component.enabled && component.entity.enabled) {
				this._enabledComponents.append(component);
			}
			if (data.hasOwnProperty('order') && data.hasOwnProperty('scripts')) {
				component._scriptsData = data.scripts;
				for (var i = 0; i < data.order.length; i++) {
					component.create(data.order[i], {
						enabled: data.scripts[data.order[i]].enabled,
						attributes: data.scripts[data.order[i]].attributes,
						preloading: this.preloading
					});
				}
			}
		};
		_proto.cloneComponent = function cloneComponent(entity, clone) {
			var order = [];
			var scripts = {};
			for (var i = 0; i < entity.script._scripts.length; i++) {
				var scriptInstance = entity.script._scripts[i];
				var scriptName = scriptInstance.__scriptType.__name;
				order.push(scriptName);
				var attributes = {};
				for (var key in scriptInstance.__attributes) attributes[key] = scriptInstance.__attributes[key];
				scripts[scriptName] = {
					enabled: scriptInstance._enabled,
					attributes: attributes
				};
			}
			for (var _key in entity.script._scriptsIndex) {
				if (_key.awaiting) {
					order.splice(_key.ind, 0, _key);
				}
			}
			var data = {
				enabled: entity.script.enabled,
				order: order,
				scripts: scripts
			};
			return this.addComponent(clone, data);
		};
		_proto._resetExecutionOrder = function _resetExecutionOrder() {
			executionOrderCounter = 0;
			for (var i = 0, len = this._components.length; i < len; i++) {
				this._components.items[i]._executionOrder = executionOrderCounter++;
			}
		};
		_proto._callComponentMethod = function _callComponentMethod(components, name, dt) {
			for (components.loopIndex = 0; components.loopIndex < components.length; components.loopIndex++) {
				components.items[components.loopIndex][name](dt);
			}
		};
		_proto._onInitialize = function _onInitialize() {
			this.preloading = false;
			this._callComponentMethod(this._components, METHOD_INITIALIZE_ATTRIBUTES);
			this._callComponentMethod(this._enabledComponents, METHOD_INITIALIZE);
		};
		_proto._onPostInitialize = function _onPostInitialize() {
			this._callComponentMethod(this._enabledComponents, METHOD_POST_INITIALIZE);
		};
		_proto._onUpdate = function _onUpdate(dt) {
			this._callComponentMethod(this._enabledComponents, METHOD_UPDATE, dt);
		};
		_proto._onPostUpdate = function _onPostUpdate(dt) {
			this._callComponentMethod(this._enabledComponents, METHOD_POST_UPDATE, dt);
		};
		_proto._addComponentToEnabled = function _addComponentToEnabled(component) {
			this._enabledComponents.insert(component);
		};
		_proto._removeComponentFromEnabled = function _removeComponentFromEnabled(component) {
			this._enabledComponents.remove(component);
		};
		_proto._onBeforeRemove = function _onBeforeRemove(entity, component) {
			var ind = this._components.items.indexOf(component);
			if (ind >= 0) {
				component._onBeforeRemove();
			}
			this._removeComponentFromEnabled(component);
			this._components.remove(component);
		};
		_proto.destroy = function destroy() {
			_ComponentSystem.prototype.destroy.call(this);
			this.app.systems.off('initialize', this._onInitialize, this);
			this.app.systems.off('postInitialize', this._onPostInitialize, this);
			this.app.systems.off('update', this._onUpdate, this);
			this.app.systems.off('postUpdate', this._onPostUpdate, this);
		};
		return ScriptComponentSystem;
	}(ComponentSystem);

	var Render = function (_EventHandler) {
		_inheritsLoose(Render, _EventHandler);
		function Render() {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this._meshes = null;
			return _this;
		}
		var _proto = Render.prototype;
		_proto.destroy = function destroy() {
			this.meshes = null;
		};
		_proto.decRefMeshes = function decRefMeshes() {
			if (this._meshes) {
				var count = this._meshes.length;
				for (var i = 0; i < count; i++) {
					var mesh = this._meshes[i];
					if (mesh) {
						mesh.decRefCount();
						if (mesh.refCount < 1) {
							mesh.destroy();
							this._meshes[i] = null;
						}
					}
				}
			}
		};
		_proto.incRefMeshes = function incRefMeshes() {
			if (this._meshes) {
				var count = this._meshes.length;
				for (var i = 0; i < count; i++) {
					if (this._meshes[i]) {
						this._meshes[i].incRefCount();
					}
				}
			}
		};
		_createClass(Render, [{
			key: "meshes",
			get: function get() {
				return this._meshes;
			},
			set: function set(value) {
				this.decRefMeshes();
				this._meshes = value;
				this.incRefMeshes();
				this.fire('set:meshes', value);
			}
		}]);
		return Render;
	}(EventHandler);

	function onContainerAssetLoaded(containerAsset) {
		var renderAsset = this;
		if (!renderAsset.resource) return;
		var containerResource = containerAsset.resource;
		var render = containerResource.renders && containerResource.renders[renderAsset.data.renderIndex];
		if (render) {
			renderAsset.resource.meshes = render.resource.meshes;
		}
	}
	function onContainerAssetAdded(containerAsset) {
		var renderAsset = this;
		renderAsset.registry.off('load:' + containerAsset.id, onContainerAssetLoaded, renderAsset);
		renderAsset.registry.on('load:' + containerAsset.id, onContainerAssetLoaded, renderAsset);
		renderAsset.registry.off('remove:' + containerAsset.id, onContainerAssetRemoved, renderAsset);
		renderAsset.registry.once('remove:' + containerAsset.id, onContainerAssetRemoved, renderAsset);
		if (!containerAsset.resource) {
			renderAsset.registry.load(containerAsset);
		} else {
			onContainerAssetLoaded.call(renderAsset, containerAsset);
		}
	}
	function onContainerAssetRemoved(containerAsset) {
		var renderAsset = this;
		renderAsset.registry.off('load:' + containerAsset.id, onContainerAssetLoaded, renderAsset);
		if (renderAsset.resource) {
			renderAsset.resource.destroy();
		}
	}
	var RenderHandler = function () {
		function RenderHandler(app) {
			this.handlerType = "render";
			this._registry = app.assets;
		}
		var _proto = RenderHandler.prototype;
		_proto.load = function load(url, callback, asset) {};
		_proto.open = function open(url, data) {
			return new Render();
		};
		_proto.patch = function patch(asset, registry) {
			if (!asset.data.containerAsset) return;
			var containerAsset = registry.get(asset.data.containerAsset);
			if (!containerAsset) {
				registry.once('add:' + asset.data.containerAsset, onContainerAssetAdded, asset);
				return;
			}
			onContainerAssetAdded.call(asset, containerAsset);
		};
		return RenderHandler;
	}();

	var AnimCurve = function () {
		function AnimCurve(paths, input, output, interpolation) {
			this._paths = paths;
			this._input = input;
			this._output = output;
			this._interpolation = interpolation;
		}
		_createClass(AnimCurve, [{
			key: "paths",
			get: function get() {
				return this._paths;
			}
		}, {
			key: "input",
			get: function get() {
				return this._input;
			}
		}, {
			key: "output",
			get: function get() {
				return this._output;
			}
		}, {
			key: "interpolation",
			get: function get() {
				return this._interpolation;
			}
		}]);
		return AnimCurve;
	}();

	var AnimData = function () {
		function AnimData(components, data) {
			this._components = components;
			this._data = data;
		}
		_createClass(AnimData, [{
			key: "components",
			get: function get() {
				return this._components;
			}
		}, {
			key: "data",
			get: function get() {
				return this._data;
			}
		}]);
		return AnimData;
	}();

	function DracoWorker(jsUrl, wasmUrl) {
		var draco;
		var POSITION_ATTRIBUTE = 0;
		var NORMAL_ATTRIBUTE = 1;
		var wrap = function wrap(typedArray, dataType) {
			switch (dataType) {
				case draco.DT_INT8:
					return new Int8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
				case draco.DT_INT16:
					return new Int16Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength / 2);
				case draco.DT_INT32:
					return new Int32Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength / 4);
				case draco.DT_UINT8:
					return new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
				case draco.DT_UINT16:
					return new Uint16Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength / 2);
				case draco.DT_UINT32:
					return new Uint32Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength / 4);
				case draco.DT_FLOAT32:
					return new Float32Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength / 4);
			}
			return null;
		};
		var componentSizeInBytes = function componentSizeInBytes(dataType) {
			switch (dataType) {
				case draco.DT_INT8:
					return 1;
				case draco.DT_INT16:
					return 2;
				case draco.DT_INT32:
					return 4;
				case draco.DT_UINT8:
					return 1;
				case draco.DT_UINT16:
					return 2;
				case draco.DT_UINT32:
					return 4;
				case draco.DT_FLOAT32:
					return 4;
			}
			return 1;
		};
		var attributeSizeInBytes = function attributeSizeInBytes(attribute) {
			return attribute.num_components() * componentSizeInBytes(attribute.data_type());
		};
		var attributeOrder = {
			0: 0,
			1: 1,
			5: 2,
			2: 3,
			7: 4,
			8: 5,
			4: 6,
			3: 7
		};
		var generateNormals = function generateNormals(vertices, indices) {
			var subtract = function subtract(dst, a, b) {
				dst[0] = a[0] - b[0];
				dst[1] = a[1] - b[1];
				dst[2] = a[2] - b[2];
			};
			var cross = function cross(dst, a, b) {
				dst[0] = a[1] * b[2] - b[1] * a[2];
				dst[1] = a[2] * b[0] - b[2] * a[0];
				dst[2] = a[0] * b[1] - b[0] * a[1];
			};
			var normalize = function normalize(dst, offset) {
				var a = dst[offset + 0];
				var b = dst[offset + 1];
				var c = dst[offset + 2];
				var l = 1.0 / Math.sqrt(a * a + b * b + c * c);
				dst[offset + 0] *= l;
				dst[offset + 1] *= l;
				dst[offset + 2] *= l;
			};
			var copy = function copy(dst, src, srcOffset) {
				for (var i = 0; i < 3; ++i) {
					dst[i] = src[srcOffset + i];
				}
			};
			var numTriangles = indices.length / 3;
			var numVertices = vertices.length / 3;
			var result = new Float32Array(vertices.length);
			var a = [0, 0, 0],
				b = [0, 0, 0],
				c = [0, 0, 0],
				t1 = [0, 0, 0],
				t2 = [0, 0, 0],
				n = [0, 0, 0];
			for (var i = 0; i < numTriangles; ++i) {
				var v0 = indices[i * 3 + 0] * 3;
				var v1 = indices[i * 3 + 1] * 3;
				var v2 = indices[i * 3 + 2] * 3;
				copy(a, vertices, v0);
				copy(b, vertices, v1);
				copy(c, vertices, v2);
				subtract(t1, b, a);
				subtract(t2, c, a);
				cross(n, t1, t2);
				normalize(n, 0);
				for (var j = 0; j < 3; ++j) {
					result[v0 + j] += n[j];
					result[v1 + j] += n[j];
					result[v2 + j] += n[j];
				}
			}
			for (var _i = 0; _i < numVertices; ++_i) {
				normalize(result, _i * 3);
			}
			return new Uint8Array(result.buffer);
		};
		var decodeMesh = function decodeMesh(inputBuffer) {
			var result = {};
			var buffer = new draco.DecoderBuffer();
			buffer.Init(inputBuffer, inputBuffer.length);
			var decoder = new draco.Decoder();
			if (decoder.GetEncodedGeometryType(buffer) !== draco.TRIANGULAR_MESH) {
				result.error = 'Failed to decode draco mesh: not a mesh';
				return result;
			}
			var mesh = new draco.Mesh();
			var status = decoder.DecodeBufferToMesh(buffer, mesh);
			if (!status || !status.ok() || mesh.ptr === 0) {
				result.error = 'Failed to decode draco asset';
				return result;
			}
			var numIndices = mesh.num_faces() * 3;
			var shortIndices = mesh.num_points() <= 65535;
			var indicesSize = numIndices * (shortIndices ? 2 : 4);
			var indicesPtr = draco._malloc(indicesSize);
			if (shortIndices) {
				decoder.GetTrianglesUInt16Array(mesh, indicesSize, indicesPtr);
				result.indices = new Uint16Array(draco.HEAPU16.buffer, indicesPtr, numIndices).slice().buffer;
			} else {
				decoder.GetTrianglesUInt32Array(mesh, indicesSize, indicesPtr);
				result.indices = new Uint32Array(draco.HEAPU32.buffer, indicesPtr, numIndices).slice().buffer;
			}
			draco._free(indicesPtr);
			var attributes = [];
			for (var i = 0; i < mesh.num_attributes(); ++i) {
				attributes.push(decoder.GetAttribute(mesh, i));
			}
			attributes.sort(function (a, b) {
				var _attributeOrder$a$att, _attributeOrder$b$att;
				return ((_attributeOrder$a$att = attributeOrder[a.attribute_type()]) != null ? _attributeOrder$a$att : attributeOrder.length) - ((_attributeOrder$b$att = attributeOrder[b.attribute_type()]) != null ? _attributeOrder$b$att : attributeOrder.length);
			});
			result.attributes = attributes.map(function (a) {
				return a.unique_id();
			});
			var totalVertexSize = 0;
			var offsets = attributes.map(function (a) {
				var offset = totalVertexSize;
				totalVertexSize += Math.ceil(attributeSizeInBytes(a) / 4) * 4;
				return offset;
			});
			var hasNormals = attributes.some(function (a) {
				return a.attribute_type() === NORMAL_ATTRIBUTE;
			});
			var normalOffset = offsets[1];
			if (!hasNormals) {
				for (var _i2 = 1; _i2 < offsets.length; ++_i2) {
					offsets[_i2] += 12;
				}
				totalVertexSize += 12;
			}
			result.vertices = new ArrayBuffer(mesh.num_points() * totalVertexSize);
			var dst = new Uint8Array(result.vertices);
			for (var _i3 = 0; _i3 < mesh.num_attributes(); ++_i3) {
				var attribute = attributes[_i3];
				var sizeInBytes = attributeSizeInBytes(attribute);
				var ptrSize = mesh.num_points() * sizeInBytes;
				var ptr = draco._malloc(ptrSize);
				decoder.GetAttributeDataArrayForAllPoints(mesh, attribute, attribute.data_type(), ptrSize, ptr);
				var src = new Uint8Array(draco.HEAPU8.buffer, ptr, ptrSize);
				for (var j = 0; j < mesh.num_points(); ++j) {
					for (var c = 0; c < sizeInBytes; ++c) {
						dst[j * totalVertexSize + offsets[_i3] + c] = src[j * sizeInBytes + c];
					}
				}
				if (!hasNormals && attribute.attribute_type() === POSITION_ATTRIBUTE) {
					var normals = generateNormals(wrap(src, attribute.data_type()), shortIndices ? new Uint16Array(result.indices) : new Uint32Array(result.indices));
					for (var _j = 0; _j < mesh.num_points(); ++_j) {
						for (var _c = 0; _c < 12; ++_c) {
							dst[_j * totalVertexSize + normalOffset + _c] = normals[_j * 12 + _c];
						}
					}
				}
				draco._free(ptr);
			}
			draco.destroy(mesh);
			draco.destroy(decoder);
			draco.destroy(buffer);
			return result;
		};
		var decode = function decode(data) {
			var result = decodeMesh(new Uint8Array(data.buffer));
			self.postMessage({
				jobId: data.jobId,
				error: result.error,
				indices: result.indices,
				vertices: result.vertices,
				attributes: result.attributes
			}, [result.indices, result.vertices].filter(function (t) {
				return t != null;
			}));
		};
		var workQueue = [];
		self.onmessage = function (message) {
			var data = message.data;
			switch (data.type) {
				case 'init':
					self.DracoDecoderModule({
						instantiateWasm: function instantiateWasm(imports, successCallback) {
							WebAssembly.instantiate(data.module, imports).then(function (result) {
								return successCallback(result);
							}).catch(function (reason) {
								return console.error('instantiate failed + ' + reason);
							});
							return {};
						}
					}).then(function (instance) {
						draco = instance;
						workQueue.forEach(function (data) {
							return decode(data);
						});
					});
					break;
				case 'decodeMesh':
					if (draco) {
						decode(data);
					} else {
						workQueue.push(data);
					}
					break;
			}
		};
	}

	var downloadMaxRetries = 3;
	var JobQueue = function () {
		function JobQueue() {
			this.workers = [[], [], []];
			this.jobId = 0;
			this.jobQueue = [];
			this.jobCallbacks = new Map();
			this.run = function (worker, job) {
				worker.postMessage({
					type: 'decodeMesh',
					jobId: job.jobId,
					buffer: job.buffer
				}, [job.buffer]);
			};
		}
		var _proto = JobQueue.prototype;
		_proto.init = function init(workers) {
			var _this = this;
			workers.forEach(function (worker) {
				worker.addEventListener('message', function (message) {
					var data = message.data;
					var callback = _this.jobCallbacks.get(data.jobId);
					if (callback) {
						callback(data.error, {
							indices: data.indices,
							vertices: data.vertices,
							attributes: data.attributes
						});
					}
					_this.jobCallbacks.delete(data.jobId);
					if (_this.jobQueue.length > 0) {
						var job = _this.jobQueue.shift();
						_this.run(worker, job);
					} else {
						var index2 = _this.workers[2].indexOf(worker);
						if (index2 !== -1) {
							_this.workers[2].splice(index2, 1);
							_this.workers[1].push(worker);
						} else {
							var index1 = _this.workers[1].indexOf(worker);
							if (index1 !== -1) {
								_this.workers[1].splice(index1, 1);
								_this.workers[0].push(worker);
							}
						}
					}
				});
			});
			this.workers[0] = workers;
			while (this.jobQueue.length && (this.workers[0].length || this.workers[1].length)) {
				var job = this.jobQueue.shift();
				if (this.workers[0].length > 0) {
					var worker = this.workers[0].shift();
					this.workers[1].push(worker);
					this.run(worker, job);
				} else {
					var _worker = this.workers[1].shift();
					this.workers[2].push(_worker);
					this.run(_worker, job);
				}
			}
		};
		_proto.enqueueJob = function enqueueJob(buffer, callback) {
			var job = {
				jobId: this.jobId++,
				buffer: buffer
			};
			this.jobCallbacks.set(job.jobId, callback);
			if (this.workers[0].length > 0) {
				var worker = this.workers[0].shift();
				this.workers[1].push(worker);
				this.run(worker, job);
			} else if (this.workers[1].length > 0) {
				var _worker2 = this.workers[1].shift();
				this.workers[2].push(_worker2);
				this.run(_worker2, job);
			} else {
				this.jobQueue.push(job);
			}
		};
		return JobQueue;
	}();
	var downloadScript = function downloadScript(url) {
		return new Promise(function (resolve, reject) {
			var options = {
				cache: true,
				responseType: 'text',
				retry: downloadMaxRetries > 0,
				maxRetries: downloadMaxRetries
			};
			http.get(url, options, function (err, response) {
				if (err) {
					reject(err);
				} else {
					resolve(response);
				}
			});
		});
	};
	var compileModule = function compileModule(url) {
		var compileManual = function compileManual() {
			return fetch(url).then(function (result) {
				return result.arrayBuffer();
			}).then(function (buffer) {
				return WebAssembly.compile(buffer);
			});
		};
		var compileStreaming = function compileStreaming() {
			return WebAssembly.compileStreaming(fetch(url)).catch(function (err) {
				return compileManual();
			});
		};
		return WebAssembly.compileStreaming ? compileStreaming() : compileManual();
	};
	var defaultNumWorkers$1 = 1;
	var jobQueue;
	var lazyConfig$1;
	var initializeWorkers = function initializeWorkers(config) {
		if (jobQueue) {
			return true;
		}
		if (!config) {
			if (lazyConfig$1) {
				config = lazyConfig$1;
			} else {
				var moduleConfig = WasmModule.getConfig('DracoDecoderModule');
				if (moduleConfig) {
					config = {
						jsUrl: moduleConfig.glueUrl,
						wasmUrl: moduleConfig.wasmUrl,
						numWorkers: moduleConfig.numWorkers
					};
				} else {
					config = {
						jsUrl: 'draco.wasm.js',
						wasmUrl: 'draco.wasm.wasm',
						numWorkers: defaultNumWorkers$1
					};
				}
			}
		}
		if (!config.jsUrl || !config.wasmUrl) {
			return false;
		}
		jobQueue = new JobQueue();
		Promise.all([downloadScript(config.jsUrl), compileModule(config.wasmUrl)]).then(function (_ref) {
			var dracoSource = _ref[0],
				dracoModule = _ref[1];
			var code = ['/* draco */', dracoSource, '/* worker */', "(\n" + DracoWorker.toString() + "\n)()\n\n"].join('\n');
			var blob = new Blob([code], {
				type: 'application/javascript'
			});
			var workerUrl = URL.createObjectURL(blob);
			var numWorkers = Math.max(1, Math.min(16, config.numWorkers || defaultNumWorkers$1));
			var workers = [];
			for (var i = 0; i < numWorkers; ++i) {
				var worker = new Worker(workerUrl);
				worker.postMessage({
					type: 'init',
					module: dracoModule
				});
				workers.push(worker);
			}
			jobQueue.init(workers);
		});
		return true;
	};
	var dracoInitialize = function dracoInitialize(config) {
		if (config != null && config.lazyInit) {
			lazyConfig$1 = config;
		} else {
			initializeWorkers(config);
		}
	};
	var dracoDecode = function dracoDecode(buffer, callback) {
		if (!initializeWorkers()) {
			return false;
		}
		jobQueue.enqueueJob(buffer, callback);
		return true;
	};

	var _attributeOrder;
	var GlbResources = function () {
		function GlbResources() {
			this.gltf = void 0;
			this.nodes = void 0;
			this.scenes = void 0;
			this.animations = void 0;
			this.textures = void 0;
			this.materials = void 0;
			this.variants = void 0;
			this.meshVariants = void 0;
			this.meshDefaultMaterials = void 0;
			this.renders = void 0;
			this.skins = void 0;
			this.lights = void 0;
			this.cameras = void 0;
		}
		var _proto = GlbResources.prototype;
		_proto.destroy = function destroy() {
			if (this.renders) {
				this.renders.forEach(function (render) {
					render.meshes = null;
				});
			}
		};
		return GlbResources;
	}();
	var isDataURI = function isDataURI(uri) {
		return /^data:.*,.*$/i.test(uri);
	};
	var getDataURIMimeType = function getDataURIMimeType(uri) {
		return uri.substring(uri.indexOf(':') + 1, uri.indexOf(';'));
	};
	var getNumComponents = function getNumComponents(accessorType) {
		switch (accessorType) {
			case 'SCALAR':
				return 1;
			case 'VEC2':
				return 2;
			case 'VEC3':
				return 3;
			case 'VEC4':
				return 4;
			case 'MAT2':
				return 4;
			case 'MAT3':
				return 9;
			case 'MAT4':
				return 16;
			default:
				return 3;
		}
	};
	var getComponentType = function getComponentType(componentType) {
		switch (componentType) {
			case 5120:
				return TYPE_INT8;
			case 5121:
				return TYPE_UINT8;
			case 5122:
				return TYPE_INT16;
			case 5123:
				return TYPE_UINT16;
			case 5124:
				return TYPE_INT32;
			case 5125:
				return TYPE_UINT32;
			case 5126:
				return TYPE_FLOAT32;
			default:
				return 0;
		}
	};
	var getComponentSizeInBytes = function getComponentSizeInBytes(componentType) {
		switch (componentType) {
			case 5120:
				return 1;
			case 5121:
				return 1;
			case 5122:
				return 2;
			case 5123:
				return 2;
			case 5124:
				return 4;
			case 5125:
				return 4;
			case 5126:
				return 4;
			default:
				return 0;
		}
	};
	var getComponentDataType = function getComponentDataType(componentType) {
		switch (componentType) {
			case 5120:
				return Int8Array;
			case 5121:
				return Uint8Array;
			case 5122:
				return Int16Array;
			case 5123:
				return Uint16Array;
			case 5124:
				return Int32Array;
			case 5125:
				return Uint32Array;
			case 5126:
				return Float32Array;
			default:
				return null;
		}
	};
	var gltfToEngineSemanticMap = {
		'POSITION': SEMANTIC_POSITION,
		'NORMAL': SEMANTIC_NORMAL,
		'TANGENT': SEMANTIC_TANGENT,
		'COLOR_0': SEMANTIC_COLOR,
		'JOINTS_0': SEMANTIC_BLENDINDICES,
		'WEIGHTS_0': SEMANTIC_BLENDWEIGHT,
		'TEXCOORD_0': SEMANTIC_TEXCOORD0,
		'TEXCOORD_1': SEMANTIC_TEXCOORD1,
		'TEXCOORD_2': SEMANTIC_TEXCOORD2,
		'TEXCOORD_3': SEMANTIC_TEXCOORD3,
		'TEXCOORD_4': SEMANTIC_TEXCOORD4,
		'TEXCOORD_5': SEMANTIC_TEXCOORD5,
		'TEXCOORD_6': SEMANTIC_TEXCOORD6,
		'TEXCOORD_7': SEMANTIC_TEXCOORD7
	};
	var attributeOrder = (_attributeOrder = {}, _attributeOrder[SEMANTIC_POSITION] = 0, _attributeOrder[SEMANTIC_NORMAL] = 1, _attributeOrder[SEMANTIC_TANGENT] = 2, _attributeOrder[SEMANTIC_COLOR] = 3, _attributeOrder[SEMANTIC_BLENDINDICES] = 4, _attributeOrder[SEMANTIC_BLENDWEIGHT] = 5, _attributeOrder[SEMANTIC_TEXCOORD0] = 6, _attributeOrder[SEMANTIC_TEXCOORD1] = 7, _attributeOrder[SEMANTIC_TEXCOORD2] = 8, _attributeOrder[SEMANTIC_TEXCOORD3] = 9, _attributeOrder[SEMANTIC_TEXCOORD4] = 10, _attributeOrder[SEMANTIC_TEXCOORD5] = 11, _attributeOrder[SEMANTIC_TEXCOORD6] = 12, _attributeOrder[SEMANTIC_TEXCOORD7] = 13, _attributeOrder);
	var getDequantizeFunc = function getDequantizeFunc(srcType) {
		switch (srcType) {
			case TYPE_INT8:
				return function (x) {
					return Math.max(x / 127.0, -1.0);
				};
			case TYPE_UINT8:
				return function (x) {
					return x / 255.0;
				};
			case TYPE_INT16:
				return function (x) {
					return Math.max(x / 32767.0, -1.0);
				};
			case TYPE_UINT16:
				return function (x) {
					return x / 65535.0;
				};
			default:
				return function (x) {
					return x;
				};
		}
	};
	var dequantizeArray = function dequantizeArray(dstArray, srcArray, srcType) {
		var convFunc = getDequantizeFunc(srcType);
		var len = srcArray.length;
		for (var i = 0; i < len; ++i) {
			dstArray[i] = convFunc(srcArray[i]);
		}
		return dstArray;
	};
	var getAccessorData = function getAccessorData(gltfAccessor, bufferViews, flatten) {
		if (flatten === void 0) {
			flatten = false;
		}
		var numComponents = getNumComponents(gltfAccessor.type);
		var dataType = getComponentDataType(gltfAccessor.componentType);
		if (!dataType) {
			return null;
		}
		var result;
		if (gltfAccessor.sparse) {
			var sparse = gltfAccessor.sparse;
			var indicesAccessor = {
				count: sparse.count,
				type: 'SCALAR'
			};
			var indices = getAccessorData(Object.assign(indicesAccessor, sparse.indices), bufferViews, true);
			var valuesAccessor = {
				count: sparse.count,
				type: gltfAccessor.type,
				componentType: gltfAccessor.componentType
			};
			var values = getAccessorData(Object.assign(valuesAccessor, sparse.values), bufferViews, true);
			if (gltfAccessor.hasOwnProperty('bufferView')) {
				var baseAccessor = {
					bufferView: gltfAccessor.bufferView,
					byteOffset: gltfAccessor.byteOffset,
					componentType: gltfAccessor.componentType,
					count: gltfAccessor.count,
					type: gltfAccessor.type
				};
				result = getAccessorData(baseAccessor, bufferViews, true).slice();
			} else {
				result = new dataType(gltfAccessor.count * numComponents);
			}
			for (var i = 0; i < sparse.count; ++i) {
				var targetIndex = indices[i];
				for (var j = 0; j < numComponents; ++j) {
					result[targetIndex * numComponents + j] = values[i * numComponents + j];
				}
			}
		} else {
			if (gltfAccessor.hasOwnProperty("bufferView")) {
				var bufferView = bufferViews[gltfAccessor.bufferView];
				if (flatten && bufferView.hasOwnProperty('byteStride')) {
					var bytesPerElement = numComponents * dataType.BYTES_PER_ELEMENT;
					var storage = new ArrayBuffer(gltfAccessor.count * bytesPerElement);
					var tmpArray = new Uint8Array(storage);
					var dstOffset = 0;
					for (var _i = 0; _i < gltfAccessor.count; ++_i) {
						var srcOffset = (gltfAccessor.byteOffset || 0) + _i * bufferView.byteStride;
						for (var b = 0; b < bytesPerElement; ++b) {
							tmpArray[dstOffset++] = bufferView[srcOffset++];
						}
					}
					result = new dataType(storage);
				} else {
					result = new dataType(bufferView.buffer, bufferView.byteOffset + (gltfAccessor.byteOffset || 0), gltfAccessor.count * numComponents);
				}
			} else {
				result = new dataType(gltfAccessor.count * numComponents);
			}
		}
		return result;
	};
	var getAccessorDataFloat32 = function getAccessorDataFloat32(gltfAccessor, bufferViews) {
		var data = getAccessorData(gltfAccessor, bufferViews, true);
		if (data instanceof Float32Array || !gltfAccessor.normalized) {
			return data;
		}
		var float32Data = new Float32Array(data.length);
		dequantizeArray(float32Data, data, getComponentType(gltfAccessor.componentType));
		return float32Data;
	};
	var getAccessorBoundingBox = function getAccessorBoundingBox(gltfAccessor) {
		var min = gltfAccessor.min;
		var max = gltfAccessor.max;
		if (!min || !max) {
			return null;
		}
		if (gltfAccessor.normalized) {
			var ctype = getComponentType(gltfAccessor.componentType);
			min = dequantizeArray([], min, ctype);
			max = dequantizeArray([], max, ctype);
		}
		return new BoundingBox(new Vec3((max[0] + min[0]) * 0.5, (max[1] + min[1]) * 0.5, (max[2] + min[2]) * 0.5), new Vec3((max[0] - min[0]) * 0.5, (max[1] - min[1]) * 0.5, (max[2] - min[2]) * 0.5));
	};
	var getPrimitiveType = function getPrimitiveType(primitive) {
		if (!primitive.hasOwnProperty('mode')) {
			return PRIMITIVE_TRIANGLES;
		}
		switch (primitive.mode) {
			case 0:
				return PRIMITIVE_POINTS;
			case 1:
				return PRIMITIVE_LINES;
			case 2:
				return PRIMITIVE_LINELOOP;
			case 3:
				return PRIMITIVE_LINESTRIP;
			case 4:
				return PRIMITIVE_TRIANGLES;
			case 5:
				return PRIMITIVE_TRISTRIP;
			case 6:
				return PRIMITIVE_TRIFAN;
			default:
				return PRIMITIVE_TRIANGLES;
		}
	};
	var generateIndices = function generateIndices(numVertices) {
		var dummyIndices = new Uint16Array(numVertices);
		for (var i = 0; i < numVertices; i++) {
			dummyIndices[i] = i;
		}
		return dummyIndices;
	};
	var generateNormals = function generateNormals(sourceDesc, indices) {
		var p = sourceDesc[SEMANTIC_POSITION];
		if (!p || p.components !== 3) {
			return;
		}
		var positions;
		if (p.size !== p.stride) {
			var srcStride = p.stride / typedArrayTypesByteSize[p.type];
			var src = new typedArrayTypes[p.type](p.buffer, p.offset, p.count * srcStride);
			positions = new typedArrayTypes[p.type](p.count * 3);
			for (var i = 0; i < p.count; ++i) {
				positions[i * 3 + 0] = src[i * srcStride + 0];
				positions[i * 3 + 1] = src[i * srcStride + 1];
				positions[i * 3 + 2] = src[i * srcStride + 2];
			}
		} else {
			positions = new typedArrayTypes[p.type](p.buffer, p.offset, p.count * 3);
		}
		var numVertices = p.count;
		if (!indices) {
			indices = generateIndices(numVertices);
		}
		var normalsTemp = calculateNormals(positions, indices);
		var normals = new Float32Array(normalsTemp.length);
		normals.set(normalsTemp);
		sourceDesc[SEMANTIC_NORMAL] = {
			buffer: normals.buffer,
			size: 12,
			offset: 0,
			stride: 12,
			count: numVertices,
			components: 3,
			type: TYPE_FLOAT32
		};
	};
	var flipTexCoordVs = function flipTexCoordVs(vertexBuffer) {
		var i, j;
		var floatOffsets = [];
		var shortOffsets = [];
		var byteOffsets = [];
		for (i = 0; i < vertexBuffer.format.elements.length; ++i) {
			var element = vertexBuffer.format.elements[i];
			if (element.name === SEMANTIC_TEXCOORD0 || element.name === SEMANTIC_TEXCOORD1) {
				switch (element.dataType) {
					case TYPE_FLOAT32:
						floatOffsets.push({
							offset: element.offset / 4 + 1,
							stride: element.stride / 4
						});
						break;
					case TYPE_UINT16:
						shortOffsets.push({
							offset: element.offset / 2 + 1,
							stride: element.stride / 2
						});
						break;
					case TYPE_UINT8:
						byteOffsets.push({
							offset: element.offset + 1,
							stride: element.stride
						});
						break;
				}
			}
		}
		var flip = function flip(offsets, type, one) {
			var typedArray = new type(vertexBuffer.storage);
			for (i = 0; i < offsets.length; ++i) {
				var index = offsets[i].offset;
				var stride = offsets[i].stride;
				for (j = 0; j < vertexBuffer.numVertices; ++j) {
					typedArray[index] = one - typedArray[index];
					index += stride;
				}
			}
		};
		if (floatOffsets.length > 0) {
			flip(floatOffsets, Float32Array, 1.0);
		}
		if (shortOffsets.length > 0) {
			flip(shortOffsets, Uint16Array, 65535);
		}
		if (byteOffsets.length > 0) {
			flip(byteOffsets, Uint8Array, 255);
		}
	};
	var cloneTexture = function cloneTexture(texture) {
		var shallowCopyLevels = function shallowCopyLevels(texture) {
			var result = [];
			for (var mip = 0; mip < texture._levels.length; ++mip) {
				var level = [];
				if (texture.cubemap) {
					for (var face = 0; face < 6; ++face) {
						level.push(texture._levels[mip][face]);
					}
				} else {
					level = texture._levels[mip];
				}
				result.push(level);
			}
			return result;
		};
		var result = new Texture(texture.device, texture);
		result._levels = shallowCopyLevels(texture);
		return result;
	};
	var cloneTextureAsset = function cloneTextureAsset(src) {
		var result = new Asset(src.name + '_clone', src.type, src.file, src.data, src.options);
		result.loaded = true;
		result.resource = cloneTexture(src.resource);
		src.registry.add(result);
		return result;
	};
	var createVertexBufferInternal = function createVertexBufferInternal(device, sourceDesc, flipV) {
		var positionDesc = sourceDesc[SEMANTIC_POSITION];
		if (!positionDesc) {
			return null;
		}
		var numVertices = positionDesc.count;
		var vertexDesc = [];
		for (var semantic in sourceDesc) {
			if (sourceDesc.hasOwnProperty(semantic)) {
				var element = {
					semantic: semantic,
					components: sourceDesc[semantic].components,
					type: sourceDesc[semantic].type,
					normalize: !!sourceDesc[semantic].normalize
				};
				if (!VertexFormat.isElementValid(device, element)) {
					element.components++;
				}
				vertexDesc.push(element);
			}
		}
		vertexDesc.sort(function (lhs, rhs) {
			return attributeOrder[lhs.semantic] - attributeOrder[rhs.semantic];
		});
		var i, j, k;
		var source, target, sourceOffset;
		var vertexFormat = new VertexFormat(device, vertexDesc);
		var isCorrectlyInterleaved = true;
		for (i = 0; i < vertexFormat.elements.length; ++i) {
			target = vertexFormat.elements[i];
			source = sourceDesc[target.name];
			sourceOffset = source.offset - positionDesc.offset;
			if (source.buffer !== positionDesc.buffer || source.stride !== target.stride || source.size !== target.size || sourceOffset !== target.offset) {
				isCorrectlyInterleaved = false;
				break;
			}
		}
		var vertexBuffer = new VertexBuffer(device, vertexFormat, numVertices, BUFFER_STATIC);
		var vertexData = vertexBuffer.lock();
		var targetArray = new Uint32Array(vertexData);
		var sourceArray;
		if (isCorrectlyInterleaved) {
			sourceArray = new Uint32Array(positionDesc.buffer, positionDesc.offset, numVertices * vertexBuffer.format.size / 4);
			targetArray.set(sourceArray);
		} else {
			var targetStride, sourceStride;
			for (i = 0; i < vertexBuffer.format.elements.length; ++i) {
				target = vertexBuffer.format.elements[i];
				targetStride = target.stride / 4;
				source = sourceDesc[target.name];
				sourceStride = source.stride / 4;
				sourceArray = new Uint32Array(source.buffer, source.offset, (source.count - 1) * sourceStride + (source.size + 3) / 4);
				var src = 0;
				var dst = target.offset / 4;
				var kend = Math.floor((source.size + 3) / 4);
				for (j = 0; j < numVertices; ++j) {
					for (k = 0; k < kend; ++k) {
						targetArray[dst + k] = sourceArray[src + k];
					}
					src += sourceStride;
					dst += targetStride;
				}
			}
		}
		if (flipV) {
			flipTexCoordVs(vertexBuffer);
		}
		vertexBuffer.unlock();
		return vertexBuffer;
	};
	var createVertexBuffer = function createVertexBuffer(device, attributes, indices, accessors, bufferViews, flipV, vertexBufferDict) {
		var useAttributes = {};
		var attribIds = [];
		for (var attrib in attributes) {
			if (attributes.hasOwnProperty(attrib) && gltfToEngineSemanticMap.hasOwnProperty(attrib)) {
				useAttributes[attrib] = attributes[attrib];
				attribIds.push(attrib + ':' + attributes[attrib]);
			}
		}
		attribIds.sort();
		var vbKey = attribIds.join();
		var vb = vertexBufferDict[vbKey];
		if (!vb) {
			var sourceDesc = {};
			for (var _attrib in useAttributes) {
				var accessor = accessors[attributes[_attrib]];
				var accessorData = getAccessorData(accessor, bufferViews);
				var bufferView = bufferViews[accessor.bufferView];
				var semantic = gltfToEngineSemanticMap[_attrib];
				var size = getNumComponents(accessor.type) * getComponentSizeInBytes(accessor.componentType);
				var stride = bufferView && bufferView.hasOwnProperty('byteStride') ? bufferView.byteStride : size;
				sourceDesc[semantic] = {
					buffer: accessorData.buffer,
					size: size,
					offset: accessorData.byteOffset,
					stride: stride,
					count: accessor.count,
					components: getNumComponents(accessor.type),
					type: getComponentType(accessor.componentType),
					normalize: accessor.normalized
				};
			}
			if (!sourceDesc.hasOwnProperty(SEMANTIC_NORMAL)) {
				generateNormals(sourceDesc, indices);
			}
			vb = createVertexBufferInternal(device, sourceDesc, flipV);
			vertexBufferDict[vbKey] = vb;
		}
		return vb;
	};
	var createSkin = function createSkin(device, gltfSkin, accessors, bufferViews, nodes, glbSkins) {
		var i, j, bindMatrix;
		var joints = gltfSkin.joints;
		var numJoints = joints.length;
		var ibp = [];
		if (gltfSkin.hasOwnProperty('inverseBindMatrices')) {
			var inverseBindMatrices = gltfSkin.inverseBindMatrices;
			var ibmData = getAccessorData(accessors[inverseBindMatrices], bufferViews, true);
			var ibmValues = [];
			for (i = 0; i < numJoints; i++) {
				for (j = 0; j < 16; j++) {
					ibmValues[j] = ibmData[i * 16 + j];
				}
				bindMatrix = new Mat4();
				bindMatrix.set(ibmValues);
				ibp.push(bindMatrix);
			}
		} else {
			for (i = 0; i < numJoints; i++) {
				bindMatrix = new Mat4();
				ibp.push(bindMatrix);
			}
		}
		var boneNames = [];
		for (i = 0; i < numJoints; i++) {
			boneNames[i] = nodes[joints[i]].name;
		}
		var key = boneNames.join('#');
		var skin = glbSkins.get(key);
		if (!skin) {
			skin = new Skin(device, ibp, boneNames);
			glbSkins.set(key, skin);
		}
		return skin;
	};
	var createDracoMesh = function createDracoMesh(device, primitive, accessors, bufferViews, meshVariants, meshDefaultMaterials, promises) {
		var _primitive$extensions;
		var result = new Mesh(device);
		result.aabb = getAccessorBoundingBox(accessors[primitive.attributes.POSITION]);
		var vertexDesc = [];
		for (var _i2 = 0, _Object$entries = Object.entries(primitive.attributes); _i2 < _Object$entries.length; _i2++) {
			var _accessor$normalized;
			var _Object$entries$_i = _Object$entries[_i2],
				name = _Object$entries$_i[0],
				index = _Object$entries$_i[1];
			var accessor = accessors[index];
			var semantic = gltfToEngineSemanticMap[name];
			var componentType = getComponentType(accessor.componentType);
			vertexDesc.push({
				semantic: semantic,
				components: getNumComponents(accessor.type),
				type: componentType,
				normalize: (_accessor$normalized = accessor.normalized) != null ? _accessor$normalized : semantic === SEMANTIC_COLOR && (componentType === TYPE_UINT8 || componentType === TYPE_UINT16)
			});
		}
		promises.push(new Promise(function (resolve, reject) {
			var dracoExt = primitive.extensions.KHR_draco_mesh_compression;
			dracoDecode(bufferViews[dracoExt.bufferView].slice().buffer, function (err, decompressedData) {
				if (err) {
					console.log(err);
					reject(err);
				} else {
					var _primitive$attributes;
					var order = {};
					for (var _i3 = 0, _Object$entries2 = Object.entries(dracoExt.attributes); _i3 < _Object$entries2.length; _i3++) {
						var _Object$entries2$_i = _Object$entries2[_i3],
							_name = _Object$entries2$_i[0],
							_index = _Object$entries2$_i[1];
						order[gltfToEngineSemanticMap[_name]] = decompressedData.attributes.indexOf(_index);
					}
					vertexDesc.sort(function (a, b) {
						return order[a.semantic] - order[b.semantic];
					});
					if (!((_primitive$attributes = primitive.attributes) != null && _primitive$attributes.NORMAL)) {
						vertexDesc.splice(1, 0, {
							semantic: 'NORMAL',
							components: 3,
							type: TYPE_FLOAT32
						});
					}
					var vertexFormat = new VertexFormat(device, vertexDesc);
					var numVertices = decompressedData.vertices.byteLength / vertexFormat.size;
					var indexFormat = numVertices <= 65535 ? INDEXFORMAT_UINT16 : INDEXFORMAT_UINT32;
					var numIndices = decompressedData.indices.byteLength / (numVertices <= 65535 ? 2 : 4);
					var vertexBuffer = new VertexBuffer(device, vertexFormat, numVertices, BUFFER_STATIC, decompressedData.vertices);
					var indexBuffer = new IndexBuffer(device, indexFormat, numIndices, BUFFER_STATIC, decompressedData.indices);
					result.vertexBuffer = vertexBuffer;
					result.indexBuffer[0] = indexBuffer;
					result.primitive[0].type = getPrimitiveType(primitive);
					result.primitive[0].base = 0;
					result.primitive[0].count = indexBuffer ? numIndices : numVertices;
					result.primitive[0].indexed = !!indexBuffer;
					resolve();
				}
			});
		}));
		if (primitive != null && (_primitive$extensions = primitive.extensions) != null && _primitive$extensions.KHR_materials_variants) {
			var variants = primitive.extensions.KHR_materials_variants;
			var tempMapping = {};
			variants.mappings.forEach(function (mapping) {
				mapping.variants.forEach(function (variant) {
					tempMapping[variant] = mapping.material;
				});
			});
			meshVariants[result.id] = tempMapping;
		}
		meshDefaultMaterials[result.id] = primitive.material;
		return result;
	};
	var createMesh = function createMesh(device, gltfMesh, accessors, bufferViews, flipV, vertexBufferDict, meshVariants, meshDefaultMaterials, assetOptions, promises) {
		var meshes = [];
		gltfMesh.primitives.forEach(function (primitive) {
			var _primitive$extensions2;
			if ((_primitive$extensions2 = primitive.extensions) != null && _primitive$extensions2.KHR_draco_mesh_compression) {
				meshes.push(createDracoMesh(device, primitive, accessors, bufferViews, meshVariants, meshDefaultMaterials, promises));
			} else {
				var indices = primitive.hasOwnProperty('indices') ? getAccessorData(accessors[primitive.indices], bufferViews, true) : null;
				var vertexBuffer = createVertexBuffer(device, primitive.attributes, indices, accessors, bufferViews, flipV, vertexBufferDict);
				var primitiveType = getPrimitiveType(primitive);
				var mesh = new Mesh(device);
				mesh.vertexBuffer = vertexBuffer;
				mesh.primitive[0].type = primitiveType;
				mesh.primitive[0].base = 0;
				mesh.primitive[0].indexed = indices !== null;
				if (indices !== null) {
					var indexFormat;
					if (indices instanceof Uint8Array) {
						indexFormat = INDEXFORMAT_UINT8;
					} else if (indices instanceof Uint16Array) {
						indexFormat = INDEXFORMAT_UINT16;
					} else {
						indexFormat = INDEXFORMAT_UINT32;
					}
					if (indexFormat === INDEXFORMAT_UINT32 && !device.extUintElement) {
						indexFormat = INDEXFORMAT_UINT16;
						indices = new Uint16Array(indices);
					}
					if (indexFormat === INDEXFORMAT_UINT8 && device.isWebGPU) {
						indexFormat = INDEXFORMAT_UINT16;
						indices = new Uint16Array(indices);
					}
					var indexBuffer = new IndexBuffer(device, indexFormat, indices.length, BUFFER_STATIC, indices);
					mesh.indexBuffer[0] = indexBuffer;
					mesh.primitive[0].count = indices.length;
				} else {
					mesh.primitive[0].count = vertexBuffer.numVertices;
				}
				if (primitive.hasOwnProperty("extensions") && primitive.extensions.hasOwnProperty("KHR_materials_variants")) {
					var variants = primitive.extensions.KHR_materials_variants;
					var tempMapping = {};
					variants.mappings.forEach(function (mapping) {
						mapping.variants.forEach(function (variant) {
							tempMapping[variant] = mapping.material;
						});
					});
					meshVariants[mesh.id] = tempMapping;
				}
				meshDefaultMaterials[mesh.id] = primitive.material;
				var accessor = accessors[primitive.attributes.POSITION];
				mesh.aabb = getAccessorBoundingBox(accessor);
				if (primitive.hasOwnProperty('targets')) {
					var targets = [];
					primitive.targets.forEach(function (target, index) {
						var options = {};
						if (target.hasOwnProperty('POSITION')) {
							accessor = accessors[target.POSITION];
							options.deltaPositions = getAccessorDataFloat32(accessor, bufferViews);
							options.deltaPositionsType = TYPE_FLOAT32;
							options.aabb = getAccessorBoundingBox(accessor);
						}
						if (target.hasOwnProperty('NORMAL')) {
							accessor = accessors[target.NORMAL];
							options.deltaNormals = getAccessorDataFloat32(accessor, bufferViews);
							options.deltaNormalsType = TYPE_FLOAT32;
						}
						if (gltfMesh.hasOwnProperty('extras') && gltfMesh.extras.hasOwnProperty('targetNames')) {
							options.name = gltfMesh.extras.targetNames[index];
						} else {
							options.name = index.toString(10);
						}
						if (gltfMesh.hasOwnProperty('weights')) {
							options.defaultWeight = gltfMesh.weights[index];
						}
						options.preserveData = assetOptions.morphPreserveData;
						targets.push(new MorphTarget(options));
					});
					mesh.morph = new Morph(targets, device, {
						preferHighPrecision: assetOptions.morphPreferHighPrecision
					});
				}
				meshes.push(mesh);
			}
		});
		return meshes;
	};
	var extractTextureTransform = function extractTextureTransform(source, material, maps) {
		var _source$extensions;
		var map;
		var texCoord = source.texCoord;
		if (texCoord) {
			for (map = 0; map < maps.length; ++map) {
				material[maps[map] + 'MapUv'] = texCoord;
			}
		}
		var zeros = [0, 0];
		var ones = [1, 1];
		var textureTransform = (_source$extensions = source.extensions) == null ? void 0 : _source$extensions.KHR_texture_transform;
		if (textureTransform) {
			var offset = textureTransform.offset || zeros;
			var scale = textureTransform.scale || ones;
			var rotation = textureTransform.rotation ? -textureTransform.rotation * math.RAD_TO_DEG : 0;
			var tilingVec = new Vec2(scale[0], scale[1]);
			var offsetVec = new Vec2(offset[0], 1.0 - scale[1] - offset[1]);
			for (map = 0; map < maps.length; ++map) {
				material[maps[map] + "MapTiling"] = tilingVec;
				material[maps[map] + "MapOffset"] = offsetVec;
				material[maps[map] + "MapRotation"] = rotation;
			}
		}
	};
	var extensionPbrSpecGlossiness = function extensionPbrSpecGlossiness(data, material, textures) {
		var color, texture;
		if (data.hasOwnProperty('diffuseFactor')) {
			color = data.diffuseFactor;
			material.diffuse.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
			material.opacity = color[3];
		} else {
			material.diffuse.set(1, 1, 1);
			material.opacity = 1;
		}
		if (data.hasOwnProperty('diffuseTexture')) {
			var diffuseTexture = data.diffuseTexture;
			texture = textures[diffuseTexture.index];
			material.diffuseMap = texture;
			material.diffuseMapChannel = 'rgb';
			material.opacityMap = texture;
			material.opacityMapChannel = 'a';
			extractTextureTransform(diffuseTexture, material, ['diffuse', 'opacity']);
		}
		material.useMetalness = false;
		if (data.hasOwnProperty('specularFactor')) {
			color = data.specularFactor;
			material.specular.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
		} else {
			material.specular.set(1, 1, 1);
		}
		if (data.hasOwnProperty('glossinessFactor')) {
			material.gloss = data.glossinessFactor;
		} else {
			material.gloss = 1.0;
		}
		if (data.hasOwnProperty('specularGlossinessTexture')) {
			var specularGlossinessTexture = data.specularGlossinessTexture;
			material.specularEncoding = 'srgb';
			material.specularMap = material.glossMap = textures[specularGlossinessTexture.index];
			material.specularMapChannel = 'rgb';
			material.glossMapChannel = 'a';
			extractTextureTransform(specularGlossinessTexture, material, ['gloss', 'metalness']);
		}
	};
	var extensionClearCoat = function extensionClearCoat(data, material, textures) {
		if (data.hasOwnProperty('clearcoatFactor')) {
			material.clearCoat = data.clearcoatFactor * 0.25;
		} else {
			material.clearCoat = 0;
		}
		if (data.hasOwnProperty('clearcoatTexture')) {
			var clearcoatTexture = data.clearcoatTexture;
			material.clearCoatMap = textures[clearcoatTexture.index];
			material.clearCoatMapChannel = 'r';
			extractTextureTransform(clearcoatTexture, material, ['clearCoat']);
		}
		if (data.hasOwnProperty('clearcoatRoughnessFactor')) {
			material.clearCoatGloss = data.clearcoatRoughnessFactor;
		} else {
			material.clearCoatGloss = 0;
		}
		if (data.hasOwnProperty('clearcoatRoughnessTexture')) {
			var clearcoatRoughnessTexture = data.clearcoatRoughnessTexture;
			material.clearCoatGlossMap = textures[clearcoatRoughnessTexture.index];
			material.clearCoatGlossMapChannel = 'g';
			extractTextureTransform(clearcoatRoughnessTexture, material, ['clearCoatGloss']);
		}
		if (data.hasOwnProperty('clearcoatNormalTexture')) {
			var clearcoatNormalTexture = data.clearcoatNormalTexture;
			material.clearCoatNormalMap = textures[clearcoatNormalTexture.index];
			extractTextureTransform(clearcoatNormalTexture, material, ['clearCoatNormal']);
			if (clearcoatNormalTexture.hasOwnProperty('scale')) {
				material.clearCoatBumpiness = clearcoatNormalTexture.scale;
			}
		}
		material.clearCoatGlossInvert = true;
	};
	var extensionUnlit = function extensionUnlit(data, material, textures) {
		material.useLighting = false;
		material.emissive.copy(material.diffuse);
		material.emissiveTint = material.diffuseTint;
		material.emissiveMap = material.diffuseMap;
		material.emissiveMapUv = material.diffuseMapUv;
		material.emissiveMapTiling.copy(material.diffuseMapTiling);
		material.emissiveMapOffset.copy(material.diffuseMapOffset);
		material.emissiveMapRotation = material.diffuseMapRotation;
		material.emissiveMapChannel = material.diffuseMapChannel;
		material.emissiveVertexColor = material.diffuseVertexColor;
		material.emissiveVertexColorChannel = material.diffuseVertexColorChannel;
		material.useLighting = false;
		material.useSkybox = false;
		material.diffuse.set(0, 0, 0);
		material.diffuseTint = false;
		material.diffuseMap = null;
		material.diffuseVertexColor = false;
	};
	var extensionSpecular = function extensionSpecular(data, material, textures) {
		material.useMetalnessSpecularColor = true;
		if (data.hasOwnProperty('specularColorTexture')) {
			material.specularEncoding = 'srgb';
			material.specularMap = textures[data.specularColorTexture.index];
			material.specularMapChannel = 'rgb';
			extractTextureTransform(data.specularColorTexture, material, ['specular']);
		}
		if (data.hasOwnProperty('specularColorFactor')) {
			var color = data.specularColorFactor;
			material.specular.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
		} else {
			material.specular.set(1, 1, 1);
		}
		if (data.hasOwnProperty('specularFactor')) {
			material.specularityFactor = data.specularFactor;
		} else {
			material.specularityFactor = 1;
		}
		if (data.hasOwnProperty('specularTexture')) {
			material.specularityFactorMapChannel = 'a';
			material.specularityFactorMap = textures[data.specularTexture.index];
			extractTextureTransform(data.specularTexture, material, ['specularityFactor']);
		}
	};
	var extensionIor = function extensionIor(data, material, textures) {
		if (data.hasOwnProperty('ior')) {
			material.refractionIndex = 1.0 / data.ior;
		}
	};
	var extensionTransmission = function extensionTransmission(data, material, textures) {
		material.blendType = BLEND_NORMAL;
		material.useDynamicRefraction = true;
		if (data.hasOwnProperty('transmissionFactor')) {
			material.refraction = data.transmissionFactor;
		}
		if (data.hasOwnProperty('transmissionTexture')) {
			material.refractionMapChannel = 'r';
			material.refractionMap = textures[data.transmissionTexture.index];
			extractTextureTransform(data.transmissionTexture, material, ['refraction']);
		}
	};
	var extensionSheen = function extensionSheen(data, material, textures) {
		material.useSheen = true;
		if (data.hasOwnProperty('sheenColorFactor')) {
			var color = data.sheenColorFactor;
			material.sheen.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
		} else {
			material.sheen.set(1, 1, 1);
		}
		if (data.hasOwnProperty('sheenColorTexture')) {
			material.sheenMap = textures[data.sheenColorTexture.index];
			material.sheenEncoding = 'srgb';
			extractTextureTransform(data.sheenColorTexture, material, ['sheen']);
		}
		if (data.hasOwnProperty('sheenRoughnessFactor')) {
			material.sheenGloss = data.sheenRoughnessFactor;
		} else {
			material.sheenGloss = 0.0;
		}
		if (data.hasOwnProperty('sheenRoughnessTexture')) {
			material.sheenGlossMap = textures[data.sheenRoughnessTexture.index];
			material.sheenGlossMapChannel = 'a';
			extractTextureTransform(data.sheenRoughnessTexture, material, ['sheenGloss']);
		}
		material.sheenGlossInvert = true;
	};
	var extensionVolume = function extensionVolume(data, material, textures) {
		material.blendType = BLEND_NORMAL;
		material.useDynamicRefraction = true;
		if (data.hasOwnProperty('thicknessFactor')) {
			material.thickness = data.thicknessFactor;
		}
		if (data.hasOwnProperty('thicknessTexture')) {
			material.thicknessMap = textures[data.thicknessTexture.index];
			material.thicknessMapChannel = 'g';
			extractTextureTransform(data.thicknessTexture, material, ['thickness']);
		}
		if (data.hasOwnProperty('attenuationDistance')) {
			material.attenuationDistance = data.attenuationDistance;
		}
		if (data.hasOwnProperty('attenuationColor')) {
			var color = data.attenuationColor;
			material.attenuation.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
		}
	};
	var extensionEmissiveStrength = function extensionEmissiveStrength(data, material, textures) {
		if (data.hasOwnProperty('emissiveStrength')) {
			material.emissiveIntensity = data.emissiveStrength;
		}
	};
	var extensionIridescence = function extensionIridescence(data, material, textures) {
		material.useIridescence = true;
		if (data.hasOwnProperty('iridescenceFactor')) {
			material.iridescence = data.iridescenceFactor;
		}
		if (data.hasOwnProperty('iridescenceTexture')) {
			material.iridescenceMapChannel = 'r';
			material.iridescenceMap = textures[data.iridescenceTexture.index];
			extractTextureTransform(data.iridescenceTexture, material, ['iridescence']);
		}
		if (data.hasOwnProperty('iridescenceIor')) {
			material.iridescenceRefractionIndex = data.iridescenceIor;
		}
		if (data.hasOwnProperty('iridescenceThicknessMinimum')) {
			material.iridescenceThicknessMin = data.iridescenceThicknessMinimum;
		}
		if (data.hasOwnProperty('iridescenceThicknessMaximum')) {
			material.iridescenceThicknessMax = data.iridescenceThicknessMaximum;
		}
		if (data.hasOwnProperty('iridescenceThicknessTexture')) {
			material.iridescenceThicknessMapChannel = 'g';
			material.iridescenceThicknessMap = textures[data.iridescenceThicknessTexture.index];
			extractTextureTransform(data.iridescenceThicknessTexture, material, ['iridescenceThickness']);
		}
	};
	var createMaterial = function createMaterial(gltfMaterial, textures, flipV) {
		var material = new StandardMaterial();
		material.occludeSpecular = SPECOCC_AO;
		material.diffuseTint = true;
		material.diffuseVertexColor = true;
		material.specularTint = true;
		material.specularVertexColor = true;
		if (gltfMaterial.hasOwnProperty('name')) {
			material.name = gltfMaterial.name;
		}
		var color, texture;
		if (gltfMaterial.hasOwnProperty('pbrMetallicRoughness')) {
			var pbrData = gltfMaterial.pbrMetallicRoughness;
			if (pbrData.hasOwnProperty('baseColorFactor')) {
				color = pbrData.baseColorFactor;
				material.diffuse.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
				material.opacity = color[3];
			} else {
				material.diffuse.set(1, 1, 1);
				material.opacity = 1;
			}
			if (pbrData.hasOwnProperty('baseColorTexture')) {
				var baseColorTexture = pbrData.baseColorTexture;
				texture = textures[baseColorTexture.index];
				material.diffuseMap = texture;
				material.diffuseMapChannel = 'rgb';
				material.opacityMap = texture;
				material.opacityMapChannel = 'a';
				extractTextureTransform(baseColorTexture, material, ['diffuse', 'opacity']);
			}
			material.useMetalness = true;
			material.specular.set(1, 1, 1);
			if (pbrData.hasOwnProperty('metallicFactor')) {
				material.metalness = pbrData.metallicFactor;
			} else {
				material.metalness = 1;
			}
			if (pbrData.hasOwnProperty('roughnessFactor')) {
				material.gloss = pbrData.roughnessFactor;
			} else {
				material.gloss = 1;
			}
			material.glossInvert = true;
			if (pbrData.hasOwnProperty('metallicRoughnessTexture')) {
				var metallicRoughnessTexture = pbrData.metallicRoughnessTexture;
				material.metalnessMap = material.glossMap = textures[metallicRoughnessTexture.index];
				material.metalnessMapChannel = 'b';
				material.glossMapChannel = 'g';
				extractTextureTransform(metallicRoughnessTexture, material, ['gloss', 'metalness']);
			}
		}
		if (gltfMaterial.hasOwnProperty('normalTexture')) {
			var normalTexture = gltfMaterial.normalTexture;
			material.normalMap = textures[normalTexture.index];
			extractTextureTransform(normalTexture, material, ['normal']);
			if (normalTexture.hasOwnProperty('scale')) {
				material.bumpiness = normalTexture.scale;
			}
		}
		if (gltfMaterial.hasOwnProperty('occlusionTexture')) {
			var occlusionTexture = gltfMaterial.occlusionTexture;
			material.aoMap = textures[occlusionTexture.index];
			material.aoMapChannel = 'r';
			extractTextureTransform(occlusionTexture, material, ['ao']);
		}
		if (gltfMaterial.hasOwnProperty('emissiveFactor')) {
			color = gltfMaterial.emissiveFactor;
			material.emissive.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
			material.emissiveTint = true;
		} else {
			material.emissive.set(0, 0, 0);
			material.emissiveTint = false;
		}
		if (gltfMaterial.hasOwnProperty('emissiveTexture')) {
			var emissiveTexture = gltfMaterial.emissiveTexture;
			material.emissiveMap = textures[emissiveTexture.index];
			extractTextureTransform(emissiveTexture, material, ['emissive']);
		}
		if (gltfMaterial.hasOwnProperty('alphaMode')) {
			switch (gltfMaterial.alphaMode) {
				case 'MASK':
					material.blendType = BLEND_NONE;
					if (gltfMaterial.hasOwnProperty('alphaCutoff')) {
						material.alphaTest = gltfMaterial.alphaCutoff;
					} else {
						material.alphaTest = 0.5;
					}
					break;
				case 'BLEND':
					material.blendType = BLEND_NORMAL;
					material.alphaTest = 1.0 / 255.0;
					break;
				default:
				case 'OPAQUE':
					material.blendType = BLEND_NONE;
					break;
			}
		} else {
			material.blendType = BLEND_NONE;
		}
		if (gltfMaterial.hasOwnProperty('doubleSided')) {
			material.twoSidedLighting = gltfMaterial.doubleSided;
			material.cull = gltfMaterial.doubleSided ? CULLFACE_NONE : CULLFACE_BACK;
		} else {
			material.twoSidedLighting = false;
			material.cull = CULLFACE_BACK;
		}
		var extensions = {
			"KHR_materials_clearcoat": extensionClearCoat,
			"KHR_materials_emissive_strength": extensionEmissiveStrength,
			"KHR_materials_ior": extensionIor,
			"KHR_materials_iridescence": extensionIridescence,
			"KHR_materials_pbrSpecularGlossiness": extensionPbrSpecGlossiness,
			"KHR_materials_sheen": extensionSheen,
			"KHR_materials_specular": extensionSpecular,
			"KHR_materials_transmission": extensionTransmission,
			"KHR_materials_unlit": extensionUnlit,
			"KHR_materials_volume": extensionVolume
		};
		if (gltfMaterial.hasOwnProperty('extensions')) {
			for (var key in gltfMaterial.extensions) {
				var extensionFunc = extensions[key];
				if (extensionFunc !== undefined) {
					extensionFunc(gltfMaterial.extensions[key], material, textures);
				}
			}
		}
		material.update();
		return material;
	};
	var createAnimation = function createAnimation(gltfAnimation, animationIndex, gltfAccessors, bufferViews, nodes, meshes, gltfNodes) {
		var createAnimData = function createAnimData(gltfAccessor) {
			return new AnimData(getNumComponents(gltfAccessor.type), getAccessorDataFloat32(gltfAccessor, bufferViews));
		};
		var interpMap = {
			'STEP': INTERPOLATION_STEP,
			'LINEAR': INTERPOLATION_LINEAR,
			'CUBICSPLINE': INTERPOLATION_CUBIC
		};
		var inputMap = {};
		var outputMap = {};
		var curveMap = {};
		var outputCounter = 1;
		var i;
		for (i = 0; i < gltfAnimation.samplers.length; ++i) {
			var sampler = gltfAnimation.samplers[i];
			if (!inputMap.hasOwnProperty(sampler.input)) {
				inputMap[sampler.input] = createAnimData(gltfAccessors[sampler.input]);
			}
			if (!outputMap.hasOwnProperty(sampler.output)) {
				outputMap[sampler.output] = createAnimData(gltfAccessors[sampler.output]);
			}
			var interpolation = sampler.hasOwnProperty('interpolation') && interpMap.hasOwnProperty(sampler.interpolation) ? interpMap[sampler.interpolation] : INTERPOLATION_LINEAR;
			var curve = {
				paths: [],
				input: sampler.input,
				output: sampler.output,
				interpolation: interpolation
			};
			curveMap[i] = curve;
		}
		var quatArrays = [];
		var transformSchema = {
			'translation': 'localPosition',
			'rotation': 'localRotation',
			'scale': 'localScale'
		};
		var constructNodePath = function constructNodePath(node) {
			var path = [];
			while (node) {
				path.unshift(node.name);
				node = node.parent;
			}
			return path;
		};
		var createMorphTargetCurves = function createMorphTargetCurves(curve, gltfNode, entityPath) {
			var out = outputMap[curve.output];
			if (!out) {
				return;
			}
			var targetNames;
			if (meshes && meshes[gltfNode.mesh]) {
				var mesh = meshes[gltfNode.mesh];
				if (mesh.hasOwnProperty('extras') && mesh.extras.hasOwnProperty('targetNames')) {
					targetNames = mesh.extras.targetNames;
				}
			}
			var outData = out.data;
			var morphTargetCount = outData.length / inputMap[curve.input].data.length;
			var keyframeCount = outData.length / morphTargetCount;
			var singleBufferSize = keyframeCount * 4;
			var buffer = new ArrayBuffer(singleBufferSize * morphTargetCount);
			for (var j = 0; j < morphTargetCount; j++) {
				var _targetNames;
				var morphTargetOutput = new Float32Array(buffer, singleBufferSize * j, keyframeCount);
				for (var k = 0; k < keyframeCount; k++) {
					morphTargetOutput[k] = outData[k * morphTargetCount + j];
				}
				var output = new AnimData(1, morphTargetOutput);
				var weightName = (_targetNames = targetNames) != null && _targetNames[j] ? "name." + targetNames[j] : j;
				outputMap[-outputCounter] = output;
				var morphCurve = {
					paths: [{
						entityPath: entityPath,
						component: 'graph',
						propertyPath: ["weight." + weightName]
					}],
					input: curve.input,
					output: -outputCounter,
					interpolation: curve.interpolation
				};
				outputCounter++;
				curveMap["morphCurve-" + i + "-" + j] = morphCurve;
			}
		};
		for (i = 0; i < gltfAnimation.channels.length; ++i) {
			var channel = gltfAnimation.channels[i];
			var target = channel.target;
			var _curve = curveMap[channel.sampler];
			var node = nodes[target.node];
			var gltfNode = gltfNodes[target.node];
			var entityPath = constructNodePath(node);
			if (target.path.startsWith('weights')) {
				createMorphTargetCurves(_curve, gltfNode, entityPath);
				curveMap[channel.sampler].morphCurve = true;
			} else {
				_curve.paths.push({
					entityPath: entityPath,
					component: 'graph',
					propertyPath: [transformSchema[target.path]]
				});
			}
		}
		var inputs = [];
		var outputs = [];
		var curves = [];
		for (var inputKey in inputMap) {
			inputs.push(inputMap[inputKey]);
			inputMap[inputKey] = inputs.length - 1;
		}
		for (var outputKey in outputMap) {
			outputs.push(outputMap[outputKey]);
			outputMap[outputKey] = outputs.length - 1;
		}
		for (var curveKey in curveMap) {
			var curveData = curveMap[curveKey];
			if (curveData.morphCurve) {
				continue;
			}
			curves.push(new AnimCurve(curveData.paths, inputMap[curveData.input], outputMap[curveData.output], curveData.interpolation));
			if (curveData.paths.length > 0 && curveData.paths[0].propertyPath[0] === 'localRotation' && curveData.interpolation !== INTERPOLATION_CUBIC) {
				quatArrays.push(curves[curves.length - 1].output);
			}
		}
		quatArrays.sort();
		var prevIndex = null;
		var data;
		for (i = 0; i < quatArrays.length; ++i) {
			var index = quatArrays[i];
			if (i === 0 || index !== prevIndex) {
				data = outputs[index];
				if (data.components === 4) {
					var d = data.data;
					var len = d.length - 4;
					for (var j = 0; j < len; j += 4) {
						var dp = d[j + 0] * d[j + 4] + d[j + 1] * d[j + 5] + d[j + 2] * d[j + 6] + d[j + 3] * d[j + 7];
						if (dp < 0) {
							d[j + 4] *= -1;
							d[j + 5] *= -1;
							d[j + 6] *= -1;
							d[j + 7] *= -1;
						}
					}
				}
				prevIndex = index;
			}
		}
		var duration = 0;
		for (i = 0; i < inputs.length; i++) {
			data = inputs[i]._data;
			duration = Math.max(duration, data.length === 0 ? 0 : data[data.length - 1]);
		}
		return new AnimTrack(gltfAnimation.hasOwnProperty('name') ? gltfAnimation.name : 'animation_' + animationIndex, duration, inputs, outputs, curves);
	};
	var tempMat = new Mat4();
	var tempVec = new Vec3();
	var createNode = function createNode(gltfNode, nodeIndex) {
		var entity = new GraphNode();
		if (gltfNode.hasOwnProperty('name') && gltfNode.name.length > 0) {
			entity.name = gltfNode.name;
		} else {
			entity.name = 'node_' + nodeIndex;
		}
		if (gltfNode.hasOwnProperty('matrix')) {
			tempMat.data.set(gltfNode.matrix);
			tempMat.getTranslation(tempVec);
			entity.setLocalPosition(tempVec);
			tempMat.getEulerAngles(tempVec);
			entity.setLocalEulerAngles(tempVec);
			tempMat.getScale(tempVec);
			entity.setLocalScale(tempVec);
		}
		if (gltfNode.hasOwnProperty('rotation')) {
			var r = gltfNode.rotation;
			entity.setLocalRotation(r[0], r[1], r[2], r[3]);
		}
		if (gltfNode.hasOwnProperty('translation')) {
			var t = gltfNode.translation;
			entity.setLocalPosition(t[0], t[1], t[2]);
		}
		if (gltfNode.hasOwnProperty('scale')) {
			var s = gltfNode.scale;
			entity.setLocalScale(s[0], s[1], s[2]);
		}
		return entity;
	};
	var createCamera = function createCamera(gltfCamera, node) {
		var projection = gltfCamera.type === 'orthographic' ? PROJECTION_ORTHOGRAPHIC : PROJECTION_PERSPECTIVE;
		var gltfProperties = projection === PROJECTION_ORTHOGRAPHIC ? gltfCamera.orthographic : gltfCamera.perspective;
		var componentData = {
			enabled: false,
			projection: projection,
			nearClip: gltfProperties.znear,
			aspectRatioMode: ASPECT_AUTO
		};
		if (gltfProperties.zfar) {
			componentData.farClip = gltfProperties.zfar;
		}
		if (projection === PROJECTION_ORTHOGRAPHIC) {
			componentData.orthoHeight = 0.5 * gltfProperties.ymag;
			if (gltfProperties.ymag) {
				componentData.aspectRatioMode = ASPECT_MANUAL;
				componentData.aspectRatio = gltfProperties.xmag / gltfProperties.ymag;
			}
		} else {
			componentData.fov = gltfProperties.yfov * math.RAD_TO_DEG;
			if (gltfProperties.aspectRatio) {
				componentData.aspectRatioMode = ASPECT_MANUAL;
				componentData.aspectRatio = gltfProperties.aspectRatio;
			}
		}
		var cameraEntity = new Entity(gltfCamera.name);
		cameraEntity.addComponent('camera', componentData);
		return cameraEntity;
	};
	var createLight = function createLight(gltfLight, node) {
		var lightProps = {
			enabled: false,
			type: gltfLight.type === 'point' ? 'omni' : gltfLight.type,
			color: gltfLight.hasOwnProperty('color') ? new Color(gltfLight.color) : Color.WHITE,
			range: gltfLight.hasOwnProperty('range') ? gltfLight.range : 9999,
			falloffMode: LIGHTFALLOFF_INVERSESQUARED,
			intensity: gltfLight.hasOwnProperty('intensity') ? math.clamp(gltfLight.intensity, 0, 2) : 1
		};
		if (gltfLight.hasOwnProperty('spot')) {
			lightProps.innerConeAngle = gltfLight.spot.hasOwnProperty('innerConeAngle') ? gltfLight.spot.innerConeAngle * math.RAD_TO_DEG : 0;
			lightProps.outerConeAngle = gltfLight.spot.hasOwnProperty('outerConeAngle') ? gltfLight.spot.outerConeAngle * math.RAD_TO_DEG : Math.PI / 4;
		}
		if (gltfLight.hasOwnProperty("intensity")) {
			lightProps.luminance = gltfLight.intensity * Light.getLightUnitConversion(lightTypes[lightProps.type], lightProps.outerConeAngle, lightProps.innerConeAngle);
		}
		var lightEntity = new Entity(node.name);
		lightEntity.rotateLocal(90, 0, 0);
		lightEntity.addComponent('light', lightProps);
		return lightEntity;
	};
	var createSkins = function createSkins(device, gltf, nodes, bufferViews) {
		if (!gltf.hasOwnProperty('skins') || gltf.skins.length === 0) {
			return [];
		}
		var glbSkins = new Map();
		return gltf.skins.map(function (gltfSkin) {
			return createSkin(device, gltfSkin, gltf.accessors, bufferViews, nodes, glbSkins);
		});
	};
	var createMeshes = function createMeshes(device, gltf, bufferViews, flipV, options) {
		var _gltf$meshes, _gltf$accessors, _gltf$bufferViews;
		var vertexBufferDict = {};
		var meshVariants = {};
		var meshDefaultMaterials = {};
		var promises = [];
		var valid = !options.skipMeshes && (gltf == null || (_gltf$meshes = gltf.meshes) == null ? void 0 : _gltf$meshes.length) && (gltf == null || (_gltf$accessors = gltf.accessors) == null ? void 0 : _gltf$accessors.length) && (gltf == null || (_gltf$bufferViews = gltf.bufferViews) == null ? void 0 : _gltf$bufferViews.length);
		var meshes = valid ? gltf.meshes.map(function (gltfMesh) {
			return createMesh(device, gltfMesh, gltf.accessors, bufferViews, flipV, vertexBufferDict, meshVariants, meshDefaultMaterials, options, promises);
		}) : [];
		return {
			meshes: meshes,
			meshVariants: meshVariants,
			meshDefaultMaterials: meshDefaultMaterials,
			promises: promises
		};
	};
	var createMaterials = function createMaterials(gltf, textures, options, flipV) {
		var _options$material, _options$material$pro, _options$material2, _options$material3;
		if (!gltf.hasOwnProperty('materials') || gltf.materials.length === 0) {
			return [];
		}
		var preprocess = options == null || (_options$material = options.material) == null ? void 0 : _options$material.preprocess;
		var process = (_options$material$pro = options == null || (_options$material2 = options.material) == null ? void 0 : _options$material2.process) != null ? _options$material$pro : createMaterial;
		var postprocess = options == null || (_options$material3 = options.material) == null ? void 0 : _options$material3.postprocess;
		return gltf.materials.map(function (gltfMaterial) {
			if (preprocess) {
				preprocess(gltfMaterial);
			}
			var material = process(gltfMaterial, textures, flipV);
			if (postprocess) {
				postprocess(gltfMaterial, material);
			}
			return material;
		});
	};
	var createVariants = function createVariants(gltf) {
		if (!gltf.hasOwnProperty("extensions") || !gltf.extensions.hasOwnProperty("KHR_materials_variants")) return null;
		var data = gltf.extensions.KHR_materials_variants.variants;
		var variants = {};
		for (var i = 0; i < data.length; i++) {
			variants[data[i].name] = i;
		}
		return variants;
	};
	var createAnimations = function createAnimations(gltf, nodes, bufferViews, options) {
		var _options$animation, _options$animation2;
		if (!gltf.hasOwnProperty('animations') || gltf.animations.length === 0) {
			return [];
		}
		var preprocess = options == null || (_options$animation = options.animation) == null ? void 0 : _options$animation.preprocess;
		var postprocess = options == null || (_options$animation2 = options.animation) == null ? void 0 : _options$animation2.postprocess;
		return gltf.animations.map(function (gltfAnimation, index) {
			if (preprocess) {
				preprocess(gltfAnimation);
			}
			var animation = createAnimation(gltfAnimation, index, gltf.accessors, bufferViews, nodes, gltf.meshes, gltf.nodes);
			if (postprocess) {
				postprocess(gltfAnimation, animation);
			}
			return animation;
		});
	};
	var createNodes = function createNodes(gltf, options) {
		var _options$node, _options$node$process, _options$node2, _options$node3;
		if (!gltf.hasOwnProperty('nodes') || gltf.nodes.length === 0) {
			return [];
		}
		var preprocess = options == null || (_options$node = options.node) == null ? void 0 : _options$node.preprocess;
		var process = (_options$node$process = options == null || (_options$node2 = options.node) == null ? void 0 : _options$node2.process) != null ? _options$node$process : createNode;
		var postprocess = options == null || (_options$node3 = options.node) == null ? void 0 : _options$node3.postprocess;
		var nodes = gltf.nodes.map(function (gltfNode, index) {
			if (preprocess) {
				preprocess(gltfNode);
			}
			var node = process(gltfNode, index);
			if (postprocess) {
				postprocess(gltfNode, node);
			}
			return node;
		});
		for (var i = 0; i < gltf.nodes.length; ++i) {
			var gltfNode = gltf.nodes[i];
			if (gltfNode.hasOwnProperty('children')) {
				var parent = nodes[i];
				var uniqueNames = {};
				for (var j = 0; j < gltfNode.children.length; ++j) {
					var child = nodes[gltfNode.children[j]];
					if (!child.parent) {
						if (uniqueNames.hasOwnProperty(child.name)) {
							child.name += uniqueNames[child.name]++;
						} else {
							uniqueNames[child.name] = 1;
						}
						parent.addChild(child);
					}
				}
			}
		}
		return nodes;
	};
	var createScenes = function createScenes(gltf, nodes) {
		var _gltf$scenes$0$nodes;
		var scenes = [];
		var count = gltf.scenes.length;
		if (count === 1 && ((_gltf$scenes$0$nodes = gltf.scenes[0].nodes) == null ? void 0 : _gltf$scenes$0$nodes.length) === 1) {
			var nodeIndex = gltf.scenes[0].nodes[0];
			scenes.push(nodes[nodeIndex]);
		} else {
			for (var i = 0; i < count; i++) {
				var scene = gltf.scenes[i];
				if (scene.nodes) {
					var sceneRoot = new GraphNode(scene.name);
					for (var n = 0; n < scene.nodes.length; n++) {
						var childNode = nodes[scene.nodes[n]];
						sceneRoot.addChild(childNode);
					}
					scenes.push(sceneRoot);
				}
			}
		}
		return scenes;
	};
	var createCameras = function createCameras(gltf, nodes, options) {
		var cameras = null;
		if (gltf.hasOwnProperty('nodes') && gltf.hasOwnProperty('cameras') && gltf.cameras.length > 0) {
			var _options$camera, _options$camera$proce, _options$camera2, _options$camera3;
			var preprocess = options == null || (_options$camera = options.camera) == null ? void 0 : _options$camera.preprocess;
			var process = (_options$camera$proce = options == null || (_options$camera2 = options.camera) == null ? void 0 : _options$camera2.process) != null ? _options$camera$proce : createCamera;
			var postprocess = options == null || (_options$camera3 = options.camera) == null ? void 0 : _options$camera3.postprocess;
			gltf.nodes.forEach(function (gltfNode, nodeIndex) {
				if (gltfNode.hasOwnProperty('camera')) {
					var gltfCamera = gltf.cameras[gltfNode.camera];
					if (gltfCamera) {
						if (preprocess) {
							preprocess(gltfCamera);
						}
						var camera = process(gltfCamera, nodes[nodeIndex]);
						if (postprocess) {
							postprocess(gltfCamera, camera);
						}
						if (camera) {
							if (!cameras) cameras = new Map();
							cameras.set(gltfNode, camera);
						}
					}
				}
			});
		}
		return cameras;
	};
	var createLights = function createLights(gltf, nodes, options) {
		var lights = null;
		if (gltf.hasOwnProperty('nodes') && gltf.hasOwnProperty('extensions') && gltf.extensions.hasOwnProperty('KHR_lights_punctual') && gltf.extensions.KHR_lights_punctual.hasOwnProperty('lights')) {
			var gltfLights = gltf.extensions.KHR_lights_punctual.lights;
			if (gltfLights.length) {
				var _options$light, _options$light$proces, _options$light2, _options$light3;
				var preprocess = options == null || (_options$light = options.light) == null ? void 0 : _options$light.preprocess;
				var process = (_options$light$proces = options == null || (_options$light2 = options.light) == null ? void 0 : _options$light2.process) != null ? _options$light$proces : createLight;
				var postprocess = options == null || (_options$light3 = options.light) == null ? void 0 : _options$light3.postprocess;
				gltf.nodes.forEach(function (gltfNode, nodeIndex) {
					if (gltfNode.hasOwnProperty('extensions') && gltfNode.extensions.hasOwnProperty('KHR_lights_punctual') && gltfNode.extensions.KHR_lights_punctual.hasOwnProperty('light')) {
						var lightIndex = gltfNode.extensions.KHR_lights_punctual.light;
						var gltfLight = gltfLights[lightIndex];
						if (gltfLight) {
							if (preprocess) {
								preprocess(gltfLight);
							}
							var light = process(gltfLight, nodes[nodeIndex]);
							if (postprocess) {
								postprocess(gltfLight, light);
							}
							if (light) {
								if (!lights) lights = new Map();
								lights.set(gltfNode, light);
							}
						}
					}
				});
			}
		}
		return lights;
	};
	var linkSkins = function linkSkins(gltf, renders, skins) {
		gltf.nodes.forEach(function (gltfNode) {
			if (gltfNode.hasOwnProperty('mesh') && gltfNode.hasOwnProperty('skin')) {
				var meshGroup = renders[gltfNode.mesh].meshes;
				meshGroup.forEach(function (mesh) {
					mesh.skin = skins[gltfNode.skin];
				});
			}
		});
	};
	var createResources = function () {
		var _ref = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(device, gltf, bufferViews, textures, options) {
			var _options$global, _options$global2;
			var preprocess, postprocess, flipV, nodes, scenes, lights, cameras, variants, bufferViewData, _createMeshes, meshes, meshVariants, meshDefaultMaterials, promises, animations, textureAssets, textureInstances, materials, skins, renders, i, result;
			return _regeneratorRuntime().wrap(function _callee$(_context) {
				while (1) switch (_context.prev = _context.next) {
					case 0:
						preprocess = options == null || (_options$global = options.global) == null ? void 0 : _options$global.preprocess;
						postprocess = options == null || (_options$global2 = options.global) == null ? void 0 : _options$global2.postprocess;
						if (preprocess) {
							preprocess(gltf);
						}
						flipV = gltf.asset && gltf.asset.generator === 'PlayCanvas';
						nodes = createNodes(gltf, options);
						scenes = createScenes(gltf, nodes);
						lights = createLights(gltf, nodes, options);
						cameras = createCameras(gltf, nodes, options);
						variants = createVariants(gltf);
						_context.next = 12;
						return Promise.all(bufferViews);
					case 12:
						bufferViewData = _context.sent;
						_createMeshes = createMeshes(device, gltf, bufferViewData, flipV, options), meshes = _createMeshes.meshes, meshVariants = _createMeshes.meshVariants, meshDefaultMaterials = _createMeshes.meshDefaultMaterials, promises = _createMeshes.promises;
						animations = createAnimations(gltf, nodes, bufferViewData, options);
						_context.next = 17;
						return Promise.all(textures);
					case 17:
						textureAssets = _context.sent;
						textureInstances = textureAssets.map(function (t) {
							return t.resource;
						});
						materials = createMaterials(gltf, textureInstances, options, flipV);
						skins = createSkins(device, gltf, nodes, bufferViewData);
						renders = [];
						for (i = 0; i < meshes.length; i++) {
							renders[i] = new Render();
							renders[i].meshes = meshes[i];
						}
						linkSkins(gltf, renders, skins);
						result = new GlbResources();
						result.gltf = gltf;
						result.nodes = nodes;
						result.scenes = scenes;
						result.animations = animations;
						result.textures = textureAssets;
						result.materials = materials;
						result.variants = variants;
						result.meshVariants = meshVariants;
						result.meshDefaultMaterials = meshDefaultMaterials;
						result.renders = renders;
						result.skins = skins;
						result.lights = lights;
						result.cameras = cameras;
						if (postprocess) {
							postprocess(gltf, result);
						}
						_context.next = 41;
						return Promise.all(promises);
					case 41:
						return _context.abrupt("return", result);
					case 42:
					case "end":
						return _context.stop();
				}
			}, _callee);
		}));
		return function createResources(_x, _x2, _x3, _x4, _x5) {
			return _ref.apply(this, arguments);
		};
	}();
	var applySampler = function applySampler(texture, gltfSampler) {
		var getFilter = function getFilter(filter, defaultValue) {
			switch (filter) {
				case 9728:
					return FILTER_NEAREST;
				case 9729:
					return FILTER_LINEAR;
				case 9984:
					return FILTER_NEAREST_MIPMAP_NEAREST;
				case 9985:
					return FILTER_LINEAR_MIPMAP_NEAREST;
				case 9986:
					return FILTER_NEAREST_MIPMAP_LINEAR;
				case 9987:
					return FILTER_LINEAR_MIPMAP_LINEAR;
				default:
					return defaultValue;
			}
		};
		var getWrap = function getWrap(wrap, defaultValue) {
			switch (wrap) {
				case 33071:
					return ADDRESS_CLAMP_TO_EDGE;
				case 33648:
					return ADDRESS_MIRRORED_REPEAT;
				case 10497:
					return ADDRESS_REPEAT;
				default:
					return defaultValue;
			}
		};
		if (texture) {
			var _gltfSampler;
			gltfSampler = (_gltfSampler = gltfSampler) != null ? _gltfSampler : {};
			texture.minFilter = getFilter(gltfSampler.minFilter, FILTER_LINEAR_MIPMAP_LINEAR);
			texture.magFilter = getFilter(gltfSampler.magFilter, FILTER_LINEAR);
			texture.addressU = getWrap(gltfSampler.wrapS, ADDRESS_REPEAT);
			texture.addressV = getWrap(gltfSampler.wrapT, ADDRESS_REPEAT);
		}
	};
	var gltfTextureUniqueId = 0;
	var createImages = function createImages(gltf, bufferViews, urlBase, registry, options) {
		var _options$image, _options$image2, _options$image3;
		if (!gltf.images || gltf.images.length === 0) {
			return [];
		}
		var preprocess = options == null || (_options$image = options.image) == null ? void 0 : _options$image.preprocess;
		var processAsync = options == null || (_options$image2 = options.image) == null ? void 0 : _options$image2.processAsync;
		var postprocess = options == null || (_options$image3 = options.image) == null ? void 0 : _options$image3.postprocess;
		var mimeTypeFileExtensions = {
			'image/png': 'png',
			'image/jpeg': 'jpg',
			'image/basis': 'basis',
			'image/ktx': 'ktx',
			'image/ktx2': 'ktx2',
			'image/vnd-ms.dds': 'dds'
		};
		var loadTexture = function loadTexture(gltfImage, url, bufferView, mimeType, options) {
			return new Promise(function (resolve, reject) {
				var continuation = function continuation(bufferViewData) {
					var name = (gltfImage.name || 'gltf-texture') + '-' + gltfTextureUniqueId++;
					var file = {
						url: url || name
					};
					if (bufferViewData) {
						file.contents = bufferViewData.slice(0).buffer;
					}
					if (mimeType) {
						var extension = mimeTypeFileExtensions[mimeType];
						if (extension) {
							file.filename = file.url + '.' + extension;
						}
					}
					var asset = new Asset(name, 'texture', file, null, options);
					asset.on('load', function (asset) {
						return resolve(asset);
					});
					asset.on('error', function (err) {
						return reject(err);
					});
					registry.add(asset);
					registry.load(asset);
				};
				if (bufferView) {
					bufferView.then(function (bufferViewData) {
						return continuation(bufferViewData);
					});
				} else {
					continuation(null);
				}
			});
		};
		return gltf.images.map(function (gltfImage, i) {
			if (preprocess) {
				preprocess(gltfImage);
			}
			var promise;
			if (processAsync) {
				promise = new Promise(function (resolve, reject) {
					processAsync(gltfImage, function (err, textureAsset) {
						if (err) reject(err);else resolve(textureAsset);
					});
				});
			} else {
				promise = new Promise(function (resolve) {
					resolve(null);
				});
			}
			promise = promise.then(function (textureAsset) {
				if (textureAsset) {
					return textureAsset;
				} else if (gltfImage.hasOwnProperty('uri')) {
					if (isDataURI(gltfImage.uri)) {
						return loadTexture(gltfImage, gltfImage.uri, null, getDataURIMimeType(gltfImage.uri), null);
					}
					return loadTexture(gltfImage, ABSOLUTE_URL.test(gltfImage.uri) ? gltfImage.uri : path.join(urlBase, gltfImage.uri), null, null, {
						crossOrigin: 'anonymous'
					});
				} else if (gltfImage.hasOwnProperty('bufferView') && gltfImage.hasOwnProperty('mimeType')) {
					return loadTexture(gltfImage, null, bufferViews[gltfImage.bufferView], gltfImage.mimeType, null);
				}
				return Promise.reject(new Error("Invalid image found in gltf (neither uri or bufferView found). index=" + i));
			});
			if (postprocess) {
				promise = promise.then(function (textureAsset) {
					postprocess(gltfImage, textureAsset);
					return textureAsset;
				});
			}
			return promise;
		});
	};
	var createTextures = function createTextures(gltf, images, options) {
		var _gltf$images, _gltf$textures, _options$texture, _options$texture2, _options$texture3;
		if (!(gltf != null && (_gltf$images = gltf.images) != null && _gltf$images.length) || !(gltf != null && (_gltf$textures = gltf.textures) != null && _gltf$textures.length)) {
			return [];
		}
		var preprocess = options == null || (_options$texture = options.texture) == null ? void 0 : _options$texture.preprocess;
		var processAsync = options == null || (_options$texture2 = options.texture) == null ? void 0 : _options$texture2.processAsync;
		var postprocess = options == null || (_options$texture3 = options.texture) == null ? void 0 : _options$texture3.postprocess;
		var seenImages = new Set();
		return gltf.textures.map(function (gltfTexture) {
			if (preprocess) {
				preprocess(gltfTexture);
			}
			var promise;
			if (processAsync) {
				promise = new Promise(function (resolve, reject) {
					processAsync(gltfTexture, gltf.images, function (err, gltfImageIndex) {
						if (err) reject(err);else resolve(gltfImageIndex);
					});
				});
			} else {
				promise = new Promise(function (resolve) {
					resolve(null);
				});
			}
			promise = promise.then(function (gltfImageIndex) {
				var _ref2, _ref3, _gltfImageIndex, _gltfTexture$extensio, _gltfTexture$extensio2;
				gltfImageIndex = (_ref2 = (_ref3 = (_gltfImageIndex = gltfImageIndex) != null ? _gltfImageIndex : gltfTexture == null || (_gltfTexture$extensio = gltfTexture.extensions) == null || (_gltfTexture$extensio = _gltfTexture$extensio.KHR_texture_basisu) == null ? void 0 : _gltfTexture$extensio.source) != null ? _ref3 : gltfTexture == null || (_gltfTexture$extensio2 = gltfTexture.extensions) == null || (_gltfTexture$extensio2 = _gltfTexture$extensio2.EXT_texture_webp) == null ? void 0 : _gltfTexture$extensio2.source) != null ? _ref2 : gltfTexture.source;
				var cloneAsset = seenImages.has(gltfImageIndex);
				seenImages.add(gltfImageIndex);
				return images[gltfImageIndex].then(function (imageAsset) {
					var _gltf$samplers;
					var asset = cloneAsset ? cloneTextureAsset(imageAsset) : imageAsset;
					applySampler(asset.resource, ((_gltf$samplers = gltf.samplers) != null ? _gltf$samplers : [])[gltfTexture.sampler]);
					return asset;
				});
			});
			if (postprocess) {
				promise = promise.then(function (textureAsset) {
					postprocess(gltfTexture, textureAsset);
					return textureAsset;
				});
			}
			return promise;
		});
	};
	var loadBuffers = function loadBuffers(gltf, binaryChunk, urlBase, options) {
		var _options$buffer, _options$buffer2, _options$buffer3;
		if (!gltf.buffers || gltf.buffers.length === 0) {
			return [];
		}
		var preprocess = options == null || (_options$buffer = options.buffer) == null ? void 0 : _options$buffer.preprocess;
		var processAsync = options == null || (_options$buffer2 = options.buffer) == null ? void 0 : _options$buffer2.processAsync;
		var postprocess = options == null || (_options$buffer3 = options.buffer) == null ? void 0 : _options$buffer3.postprocess;
		return gltf.buffers.map(function (gltfBuffer, i) {
			if (preprocess) {
				preprocess(gltfBuffer);
			}
			var promise;
			if (processAsync) {
				promise = new Promise(function (resolve, reject) {
					processAsync(gltfBuffer, function (err, arrayBuffer) {
						if (err) reject(err);else resolve(arrayBuffer);
					});
				});
			} else {
				promise = new Promise(function (resolve) {
					resolve(null);
				});
			}
			promise = promise.then(function (arrayBuffer) {
				if (arrayBuffer) {
					return arrayBuffer;
				} else if (gltfBuffer.hasOwnProperty('uri')) {
					if (isDataURI(gltfBuffer.uri)) {
						var byteString = atob(gltfBuffer.uri.split(',')[1]);
						var binaryArray = new Uint8Array(byteString.length);
						for (var j = 0; j < byteString.length; j++) {
							binaryArray[j] = byteString.charCodeAt(j);
						}
						return binaryArray;
					}
					return new Promise(function (resolve, reject) {
						http.get(ABSOLUTE_URL.test(gltfBuffer.uri) ? gltfBuffer.uri : path.join(urlBase, gltfBuffer.uri), {
							cache: true,
							responseType: 'arraybuffer',
							retry: false
						}, function (err, result) {
							if (err) reject(err);else resolve(new Uint8Array(result));
						});
					});
				}
				return binaryChunk;
			});
			if (postprocess) {
				promise = promise.then(function (buffer) {
					postprocess(gltf.buffers[i], buffer);
					return buffer;
				});
			}
			return promise;
		});
	};
	var parseGltf = function parseGltf(gltfChunk, callback) {
		var decodeBinaryUtf8 = function decodeBinaryUtf8(array) {
			if (typeof TextDecoder !== 'undefined') {
				return new TextDecoder().decode(array);
			}
			var str = '';
			for (var i = 0; i < array.length; i++) {
				str += String.fromCharCode(array[i]);
			}
			return decodeURIComponent(escape(str));
		};
		var gltf = JSON.parse(decodeBinaryUtf8(gltfChunk));
		if (gltf.asset && gltf.asset.version && parseFloat(gltf.asset.version) < 2) {
			callback("Invalid gltf version. Expected version 2.0 or above but found version '" + gltf.asset.version + "'.");
			return;
		}
		callback(null, gltf);
	};
	var parseGlb = function parseGlb(glbData, callback) {
		var data = glbData instanceof ArrayBuffer ? new DataView(glbData) : new DataView(glbData.buffer, glbData.byteOffset, glbData.byteLength);
		var magic = data.getUint32(0, true);
		var version = data.getUint32(4, true);
		var length = data.getUint32(8, true);
		if (magic !== 0x46546C67) {
			callback('Invalid magic number found in glb header. Expected 0x46546C67, found 0x' + magic.toString(16));
			return;
		}
		if (version !== 2) {
			callback('Invalid version number found in glb header. Expected 2, found ' + version);
			return;
		}
		if (length <= 0 || length > data.byteLength) {
			callback('Invalid length found in glb header. Found ' + length);
			return;
		}
		var chunks = [];
		var offset = 12;
		while (offset < length) {
			var chunkLength = data.getUint32(offset, true);
			if (offset + chunkLength + 8 > data.byteLength) {
				callback("Invalid chunk length found in glb. Found " + chunkLength);
			}
			var chunkType = data.getUint32(offset + 4, true);
			var chunkData = new Uint8Array(data.buffer, data.byteOffset + offset + 8, chunkLength);
			chunks.push({
				length: chunkLength,
				type: chunkType,
				data: chunkData
			});
			offset += chunkLength + 8;
		}
		if (chunks.length !== 1 && chunks.length !== 2) {
			callback('Invalid number of chunks found in glb file.');
			return;
		}
		if (chunks[0].type !== 0x4E4F534A) {
			callback("Invalid chunk type found in glb file. Expected 0x4E4F534A, found 0x" + chunks[0].type.toString(16));
			return;
		}
		if (chunks.length > 1 && chunks[1].type !== 0x004E4942) {
			callback("Invalid chunk type found in glb file. Expected 0x004E4942, found 0x" + chunks[1].type.toString(16));
			return;
		}
		callback(null, {
			gltfChunk: chunks[0].data,
			binaryChunk: chunks.length === 2 ? chunks[1].data : null
		});
	};
	var parseChunk = function parseChunk(filename, data, callback) {
		var hasGlbHeader = function hasGlbHeader() {
			var u8 = new Uint8Array(data);
			return u8[0] === 103 && u8[1] === 108 && u8[2] === 84 && u8[3] === 70;
		};
		if (filename && filename.toLowerCase().endsWith('.glb') || hasGlbHeader()) {
			parseGlb(data, callback);
		} else {
			callback(null, {
				gltfChunk: data,
				binaryChunk: null
			});
		}
	};
	var createBufferViews = function createBufferViews(gltf, buffers, options) {
		var _options$bufferView, _options$bufferView2, _options$bufferView3, _gltf$bufferViews2;
		var result = [];
		var preprocess = options == null || (_options$bufferView = options.bufferView) == null ? void 0 : _options$bufferView.preprocess;
		var processAsync = options == null || (_options$bufferView2 = options.bufferView) == null ? void 0 : _options$bufferView2.processAsync;
		var postprocess = options == null || (_options$bufferView3 = options.bufferView) == null ? void 0 : _options$bufferView3.postprocess;
		if (!((_gltf$bufferViews2 = gltf.bufferViews) != null && _gltf$bufferViews2.length)) {
			return result;
		}
		var _loop = function _loop() {
			var gltfBufferView = gltf.bufferViews[i];
			if (preprocess) {
				preprocess(gltfBufferView);
			}
			var promise;
			if (processAsync) {
				promise = new Promise(function (resolve, reject) {
					processAsync(gltfBufferView, buffers, function (err, result) {
						if (err) reject(err);else resolve(result);
					});
				});
			} else {
				promise = new Promise(function (resolve) {
					resolve(null);
				});
			}
			promise = promise.then(function (buffer) {
				if (buffer) {
					return buffer;
				}
				return buffers[gltfBufferView.buffer].then(function (buffer) {
					return new Uint8Array(buffer.buffer, buffer.byteOffset + (gltfBufferView.byteOffset || 0), gltfBufferView.byteLength);
				});
			});
			if (gltfBufferView.hasOwnProperty('byteStride')) {
				promise = promise.then(function (typedArray) {
					typedArray.byteStride = gltfBufferView.byteStride;
					return typedArray;
				});
			}
			if (postprocess) {
				promise = promise.then(function (typedArray) {
					postprocess(gltfBufferView, typedArray);
					return typedArray;
				});
			}
			result.push(promise);
		};
		for (var i = 0; i < gltf.bufferViews.length; ++i) {
			_loop();
		}
		return result;
	};
	var GlbParser = function () {
		function GlbParser() {}
		GlbParser.parse = function parse(filename, urlBase, data, device, registry, options, callback) {
			parseChunk(filename, data, function (err, chunks) {
				if (err) {
					callback(err);
					return;
				}
				parseGltf(chunks.gltfChunk, function (err, gltf) {
					if (err) {
						callback(err);
						return;
					}
					var buffers = loadBuffers(gltf, chunks.binaryChunk, urlBase, options);
					var bufferViews = createBufferViews(gltf, buffers, options);
					var images = createImages(gltf, bufferViews, urlBase, registry, options);
					var textures = createTextures(gltf, images, options);
					createResources(device, gltf, bufferViews, textures, options).then(function (result) {
						return callback(null, result);
					}).catch(function (err) {
						return callback(err);
					});
				});
			});
		};
		GlbParser.createDefaultMaterial = function createDefaultMaterial() {
			return createMaterial({
				name: 'defaultGlbMaterial'
			}, []);
		};
		return GlbParser;
	}();

	var AnimationHandler = function () {
		function AnimationHandler(app) {
			this.handlerType = "animation";
			this.device = app.graphicsDevice;
			this.assets = app.assets;
			this.maxRetries = 0;
		}
		var _proto = AnimationHandler.prototype;
		_proto.load = function load(url, callback, asset) {
			var _this = this;
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			var options = {
				retry: this.maxRetries > 0,
				maxRetries: this.maxRetries
			};
			if (url.load.startsWith('blob:') || url.load.startsWith('data:')) {
				if (path.getExtension(url.original).toLowerCase() === '.glb') {
					options.responseType = Http.ResponseType.ARRAY_BUFFER;
				} else {
					options.responseType = Http.ResponseType.JSON;
				}
			}
			http.get(url.load, options, function (err, response) {
				if (err) {
					callback("Error loading animation resource: " + url.original + " [" + err + "]");
				} else {
					if (path.getExtension(url.original).toLowerCase() === '.glb') {
						var _asset$options;
						GlbParser.parse('filename.glb', '', response, _this.device, _this.assets, (_asset$options = asset == null ? void 0 : asset.options) != null ? _asset$options : {}, function (err, parseResult) {
							if (err) {
								callback(err);
							} else {
								var _asset$data;
								var animations = parseResult.animations;
								if (asset != null && (_asset$data = asset.data) != null && _asset$data.events) {
									for (var i = 0; i < animations.length; i++) {
										animations[i].events = new AnimEvents(Object.values(asset.data.events));
									}
								}
								parseResult.destroy();
								callback(null, animations);
							}
						});
					} else {
						callback(null, _this['_parseAnimationV' + response.animation.version](response));
					}
				}
			});
		};
		_proto.open = function open(url, data, asset) {
			return data;
		};
		_proto.patch = function patch(asset, assets) {};
		_proto._parseAnimationV3 = function _parseAnimationV3(data) {
			var animData = data.animation;
			var anim = new Animation();
			anim.name = animData.name;
			anim.duration = animData.duration;
			for (var i = 0; i < animData.nodes.length; i++) {
				var node = new Node();
				var n = animData.nodes[i];
				node._name = n.name;
				for (var j = 0; j < n.keys.length; j++) {
					var k = n.keys[j];
					var t = k.time;
					var p = k.pos;
					var r = k.rot;
					var s = k.scale;
					var pos = new Vec3(p[0], p[1], p[2]);
					var rot = new Quat().setFromEulerAngles(r[0], r[1], r[2]);
					var scl = new Vec3(s[0], s[1], s[2]);
					var key = new Key(t, pos, rot, scl);
					node._keys.push(key);
				}
				anim.addNode(node);
			}
			return anim;
		};
		_proto._parseAnimationV4 = function _parseAnimationV4(data) {
			var animData = data.animation;
			var anim = new Animation();
			anim.name = animData.name;
			anim.duration = animData.duration;
			for (var i = 0; i < animData.nodes.length; i++) {
				var node = new Node();
				var n = animData.nodes[i];
				node._name = n.name;
				var defPos = n.defaults.p;
				var defRot = n.defaults.r;
				var defScl = n.defaults.s;
				for (var j = 0; j < n.keys.length; j++) {
					var k = n.keys[j];
					var t = k.t;
					var p = defPos ? defPos : k.p;
					var r = defRot ? defRot : k.r;
					var s = defScl ? defScl : k.s;
					var pos = new Vec3(p[0], p[1], p[2]);
					var rot = new Quat().setFromEulerAngles(r[0], r[1], r[2]);
					var scl = new Vec3(s[0], s[1], s[2]);
					var key = new Key(t, pos, rot, scl);
					node._keys.push(key);
				}
				anim.addNode(node);
			}
			return anim;
		};
		return AnimationHandler;
	}();

	var AnimClipHandler = function () {
		function AnimClipHandler(app) {
			this.handlerType = "animclip";
			this.maxRetries = 0;
		}
		var _proto = AnimClipHandler.prototype;
		_proto.load = function load(url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			var options = {
				retry: this.maxRetries > 0,
				maxRetries: this.maxRetries
			};
			if (url.load.startsWith('blob:')) {
				options.responseType = Http.ResponseType.JSON;
			}
			http.get(url.load, options, function (err, response) {
				if (err) {
					callback("Error loading animation clip resource: " + url.original + " [" + err + "]");
				} else {
					callback(null, response);
				}
			});
		};
		_proto.open = function open(url, data) {
			var name = data.name;
			var duration = data.duration;
			var inputs = data.inputs.map(function (input) {
				return new AnimData(1, input);
			});
			var outputs = data.outputs.map(function (output) {
				return new AnimData(output.components, output.data);
			});
			var curves = data.curves.map(function (curve) {
				return new AnimCurve([curve.path], curve.inputIndex, curve.outputIndex, curve.interpolation);
			});
			return new AnimTrack(name, duration, inputs, outputs, curves);
		};
		_proto.patch = function patch(asset, assets) {};
		return AnimClipHandler;
	}();

	var AnimStateGraphHandler = function () {
		function AnimStateGraphHandler(app) {
			this.handlerType = "animstategraph";
			this.maxRetries = 0;
		}
		var _proto = AnimStateGraphHandler.prototype;
		_proto.load = function load(url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			var options = {
				retry: this.maxRetries > 0,
				maxRetries: this.maxRetries
			};
			if (url.load.startsWith('blob:')) {
				options.responseType = Http.ResponseType.JSON;
			}
			http.get(url.load, options, function (err, response) {
				if (err) {
					callback("Error loading animation state graph resource: " + url.original + " [" + err + "]");
				} else {
					callback(null, response);
				}
			});
		};
		_proto.open = function open(url, data) {
			return new AnimStateGraph(data);
		};
		_proto.patch = function patch(asset, assets) {};
		return AnimStateGraphHandler;
	}();

	var ie = function () {
		if (typeof window === 'undefined') {
			return false;
		}
		var ua = window.navigator.userAgent;
		var msie = ua.indexOf('MSIE ');
		if (msie > 0) {
			return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
		}
		var trident = ua.indexOf('Trident/');
		if (trident > 0) {
			var rv = ua.indexOf('rv:');
			return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
		}
		return false;
	}();
	var supportedExtensions = ['.ogg', '.mp3', '.wav', '.mp4a', '.m4a', '.mp4', '.aac', '.opus'];
	var AudioHandler = function () {
		function AudioHandler(app) {
			this.handlerType = "audio";
			this.manager = app.soundManager;
			this.maxRetries = 0;
		}
		var _proto = AudioHandler.prototype;
		_proto._isSupported = function _isSupported(url) {
			var ext = path.getExtension(url);
			return supportedExtensions.indexOf(ext) > -1;
		};
		_proto.load = function load(url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			var success = function success(resource) {
				callback(null, new Sound(resource));
			};
			var error = function error(err) {
				var msg = 'Error loading audio url: ' + url.original;
				if (err) {
					msg += ': ' + (err.message || err);
				}
				console.warn(msg);
				callback(msg);
			};
			if (this._createSound) {
				if (!this._isSupported(url.original)) {
					error("Audio format for " + url.original + " not supported");
					return;
				}
				this._createSound(url.load, success, error);
			} else {
				error(null);
			}
		};
		_proto.open = function open(url, data) {
			return data;
		};
		_proto.patch = function patch(asset, assets) {};
		_proto._createSound = function _createSound(url, success, error) {
			if (hasAudioContext()) {
				var manager = this.manager;
				if (!manager.context) {
					error('Audio manager has no audio context');
					return;
				}
				var options = {
					retry: this.maxRetries > 0,
					maxRetries: this.maxRetries
				};
				if (url.startsWith('blob:') || url.startsWith('data:')) {
					options.responseType = Http.ResponseType.ARRAY_BUFFER;
				}
				http.get(url, options, function (err, response) {
					if (err) {
						error(err);
						return;
					}
					manager.context.decodeAudioData(response, success, error);
				});
			} else {
				var audio = null;
				try {
					audio = new Audio();
				} catch (e) {
					error('No support for Audio element');
					return;
				}
				if (ie) {
					document.body.appendChild(audio);
				}
				var onReady = function onReady() {
					audio.removeEventListener('canplaythrough', onReady);
					if (ie) {
						document.body.removeChild(audio);
					}
					success(audio);
				};
				audio.onerror = function () {
					audio.onerror = null;
					if (ie) {
						document.body.removeChild(audio);
					}
					error();
				};
				audio.addEventListener('canplaythrough', onReady);
				audio.src = url;
			}
		};
		return AudioHandler;
	}();

	var BinaryHandler = function () {
		function BinaryHandler(app) {
			this.handlerType = "binary";
			this.maxRetries = 0;
		}
		var _proto = BinaryHandler.prototype;
		_proto.load = function load(url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			http.get(url.load, {
				responseType: Http.ResponseType.ARRAY_BUFFER,
				retry: this.maxRetries > 0,
				maxRetries: this.maxRetries
			}, function (err, response) {
				if (!err) {
					callback(null, response);
				} else {
					callback("Error loading binary resource: " + url.original + " [" + err + "]");
				}
			});
		};
		_proto.open = function open(url, data) {
			return data;
		};
		_proto.patch = function patch(asset, assets) {};
		return BinaryHandler;
	}();

	var GlbContainerResource = function () {
		function GlbContainerResource(data, asset, assets, defaultMaterial) {
			var createAsset = function createAsset(type, resource, index) {
				var subAsset = GlbContainerResource.createAsset(asset.name, type, resource, index);
				assets.add(subAsset);
				return subAsset;
			};
			var renders = [];
			for (var i = 0; i < data.renders.length; ++i) {
				renders.push(createAsset('render', data.renders[i], i));
			}
			var materials = [];
			for (var _i = 0; _i < data.materials.length; ++_i) {
				materials.push(createAsset('material', data.materials[_i], _i));
			}
			var animations = [];
			for (var _i2 = 0; _i2 < data.animations.length; ++_i2) {
				animations.push(createAsset('animation', data.animations[_i2], _i2));
			}
			this.data = data;
			this._model = null;
			this._assetName = asset.name;
			this._assets = assets;
			this._defaultMaterial = defaultMaterial;
			this.renders = renders;
			this.materials = materials;
			this.textures = data.textures;
			this.animations = animations;
		}
		GlbContainerResource.createAsset = function createAsset(assetName, type, resource, index) {
			var subAsset = new Asset(assetName + '/' + type + '/' + index, type, {
				url: ''
			});
			subAsset.resource = resource;
			subAsset.loaded = true;
			return subAsset;
		};
		var _proto = GlbContainerResource.prototype;
		_proto.instantiateModelEntity = function instantiateModelEntity(options) {
			var entity = new Entity();
			entity.addComponent('model', Object.assign({
				type: 'asset',
				asset: this.model
			}, options));
			return entity;
		};
		_proto.instantiateRenderEntity = function instantiateRenderEntity(options) {
			var _this = this;
			var defaultMaterial = this._defaultMaterial;
			var skinnedMeshInstances = [];
			var createMeshInstance = function createMeshInstance(root, entity, mesh, materials, meshDefaultMaterials, skins, gltfNode) {
				var materialIndex = meshDefaultMaterials[mesh.id];
				var material = materialIndex === undefined ? defaultMaterial : materials[materialIndex];
				var meshInstance = new MeshInstance(mesh, material);
				if (mesh.morph) {
					meshInstance.morphInstance = new MorphInstance(mesh.morph);
				}
				if (gltfNode.hasOwnProperty('skin')) {
					skinnedMeshInstances.push({
						meshInstance: meshInstance,
						rootBone: root,
						entity: entity
					});
				}
				return meshInstance;
			};
			var cloneHierarchy = function cloneHierarchy(root, node, glb) {
				var entity = new Entity();
				node._cloneInternal(entity);
				if (!root) root = entity;
				var attachedMi = null;
				var renderAsset = null;
				for (var i = 0; i < glb.nodes.length; i++) {
					var glbNode = glb.nodes[i];
					if (glbNode === node) {
						var gltfNode = glb.gltf.nodes[i];
						if (gltfNode.hasOwnProperty('mesh')) {
							var meshGroup = glb.renders[gltfNode.mesh].meshes;
							renderAsset = _this.renders[gltfNode.mesh];
							for (var mi = 0; mi < meshGroup.length; mi++) {
								var mesh = meshGroup[mi];
								if (mesh) {
									var cloneMi = createMeshInstance(root, entity, mesh, glb.materials, glb.meshDefaultMaterials, glb.skins, gltfNode);
									if (!attachedMi) {
										attachedMi = [];
									}
									attachedMi.push(cloneMi);
								}
							}
						}
						if (glb.lights) {
							var lightEntity = glb.lights.get(gltfNode);
							if (lightEntity) {
								entity.addChild(lightEntity.clone());
							}
						}
						if (glb.cameras) {
							var cameraEntity = glb.cameras.get(gltfNode);
							if (cameraEntity) {
								cameraEntity.camera.system.cloneComponent(cameraEntity, entity);
							}
						}
					}
				}
				if (attachedMi) {
					entity.addComponent('render', Object.assign({
						type: 'asset',
						meshInstances: attachedMi,
						rootBone: root
					}, options));
					entity.render.assignAsset(renderAsset);
				}
				var children = node.children;
				for (var _i3 = 0; _i3 < children.length; _i3++) {
					var childClone = cloneHierarchy(root, children[_i3], glb);
					entity.addChild(childClone);
				}
				return entity;
			};
			var sceneClones = [];
			for (var _iterator = _createForOfIteratorHelperLoose(this.data.scenes), _step; !(_step = _iterator()).done;) {
				var scene = _step.value;
				sceneClones.push(cloneHierarchy(null, scene, this.data));
			}
			skinnedMeshInstances.forEach(function (data) {
				data.meshInstance.skinInstance = SkinInstanceCache.createCachedSkinInstance(data.meshInstance.mesh.skin, data.rootBone, data.entity);
			});
			return GlbContainerResource.createSceneHierarchy(sceneClones, 'Entity');
		};
		_proto.getMaterialVariants = function getMaterialVariants() {
			return this.data.variants ? Object.keys(this.data.variants) : [];
		};
		_proto.applyMaterialVariant = function applyMaterialVariant(entity, name) {
			var variant = name ? this.data.variants[name] : null;
			if (variant === undefined) {
				return;
			}
			var renders = entity.findComponents("render");
			for (var i = 0; i < renders.length; i++) {
				var renderComponent = renders[i];
				this._applyMaterialVariant(variant, renderComponent.meshInstances);
			}
		};
		_proto.applyMaterialVariantInstances = function applyMaterialVariantInstances(instances, name) {
			var variant = name ? this.data.variants[name] : null;
			if (variant === undefined) {
				return;
			}
			this._applyMaterialVariant(variant, instances);
		};
		_proto._applyMaterialVariant = function _applyMaterialVariant(variant, instances) {
			var _this2 = this;
			instances.forEach(function (instance) {
				if (variant === null) {
					instance.material = _this2._defaultMaterial;
				} else {
					var meshVariants = _this2.data.meshVariants[instance.mesh.id];
					if (meshVariants) {
						instance.material = _this2.data.materials[meshVariants[variant]];
					}
				}
			});
		};
		GlbContainerResource.createSceneHierarchy = function createSceneHierarchy(sceneNodes, nodeType) {
			var root = null;
			if (sceneNodes.length === 1) {
				root = sceneNodes[0];
			} else {
				root = new nodeType('SceneGroup');
				for (var _iterator2 = _createForOfIteratorHelperLoose(sceneNodes), _step2; !(_step2 = _iterator2()).done;) {
					var scene = _step2.value;
					root.addChild(scene);
				}
			}
			return root;
		};
		GlbContainerResource.createModel = function createModel(glb, defaultMaterial) {
			var createMeshInstance = function createMeshInstance(model, mesh, skins, skinInstances, materials, node, gltfNode) {
				var materialIndex = glb.meshDefaultMaterials[mesh.id];
				var material = materialIndex === undefined ? defaultMaterial : materials[materialIndex];
				var meshInstance = new MeshInstance(mesh, material, node);
				if (mesh.morph) {
					var morphInstance = new MorphInstance(mesh.morph);
					meshInstance.morphInstance = morphInstance;
					model.morphInstances.push(morphInstance);
				}
				if (gltfNode.hasOwnProperty('skin')) {
					var skinIndex = gltfNode.skin;
					var skin = skins[skinIndex];
					mesh.skin = skin;
					var skinInstance = skinInstances[skinIndex];
					meshInstance.skinInstance = skinInstance;
					model.skinInstances.push(skinInstance);
				}
				model.meshInstances.push(meshInstance);
			};
			var model = new Model();
			var skinInstances = [];
			for (var _iterator3 = _createForOfIteratorHelperLoose(glb.skins), _step3; !(_step3 = _iterator3()).done;) {
				var skin = _step3.value;
				var skinInstance = new SkinInstance(skin);
				skinInstance.bones = skin.bones;
				skinInstances.push(skinInstance);
			}
			model.graph = GlbContainerResource.createSceneHierarchy(glb.scenes, 'GraphNode');
			for (var i = 0; i < glb.nodes.length; i++) {
				var node = glb.nodes[i];
				if (node.root === model.graph) {
					var gltfNode = glb.gltf.nodes[i];
					if (gltfNode.hasOwnProperty('mesh')) {
						var meshGroup = glb.renders[gltfNode.mesh].meshes;
						for (var mi = 0; mi < meshGroup.length; mi++) {
							var mesh = meshGroup[mi];
							if (mesh) {
								createMeshInstance(model, mesh, glb.skins, skinInstances, glb.materials, node, gltfNode);
							}
						}
					}
				}
			}
			return model;
		};
		_proto.destroy = function destroy() {
			var registry = this._assets;
			var destroyAsset = function destroyAsset(asset) {
				registry.remove(asset);
				asset.unload();
			};
			var destroyAssets = function destroyAssets(assets) {
				assets.forEach(function (asset) {
					destroyAsset(asset);
				});
			};
			if (this.animations) {
				destroyAssets(this.animations);
				this.animations = null;
			}
			if (this.textures) {
				destroyAssets(this.textures);
				this.textures = null;
			}
			if (this.materials) {
				destroyAssets(this.materials);
				this.materials = null;
			}
			if (this.renders) {
				destroyAssets(this.renders);
				this.renders = null;
			}
			if (this._model) {
				destroyAsset(this._model);
				this._model = null;
			}
			this.data = null;
			this.assets = null;
		};
		_createClass(GlbContainerResource, [{
			key: "model",
			get: function get() {
				if (!this._model) {
					var model = GlbContainerResource.createModel(this.data, this._defaultMaterial);
					var modelAsset = GlbContainerResource.createAsset(this._assetName, 'model', model, 0);
					this._assets.add(modelAsset);
					this._model = modelAsset;
				}
				return this._model;
			}
		}]);
		return GlbContainerResource;
	}();

	var GlbContainerParser = function () {
		function GlbContainerParser(device, assets, maxRetries) {
			this._device = device;
			this._assets = assets;
			this._defaultMaterial = GlbParser.createDefaultMaterial();
			this.maxRetries = maxRetries;
		}
		var _proto = GlbContainerParser.prototype;
		_proto._getUrlWithoutParams = function _getUrlWithoutParams(url) {
			return url.indexOf('?') >= 0 ? url.split('?')[0] : url;
		};
		_proto.load = function load(url, callback, asset) {
			var _this = this;
			Asset.fetchArrayBuffer(url.load, function (err, result) {
				if (err) {
					callback(err);
				} else {
					GlbParser.parse(_this._getUrlWithoutParams(url.original), path.extractPath(url.load), result, _this._device, asset.registry, asset.options, function (err, result) {
						if (err) {
							callback(err);
						} else {
							callback(null, new GlbContainerResource(result, asset, _this._assets, _this._defaultMaterial));
						}
					});
				}
			}, asset, this.maxRetries);
		};
		_proto.open = function open(url, data, asset) {
			return data;
		};
		_proto.patch = function patch(asset, assets) {};
		return GlbContainerParser;
	}();

	var ContainerResource = function () {
		function ContainerResource() {}
		var _proto = ContainerResource.prototype;
		_proto.instantiateModelEntity = function instantiateModelEntity(options) {
			return null;
		};
		_proto.instantiateRenderEntity = function instantiateRenderEntity(options) {
			return null;
		};
		_proto.getMaterialVariants = function getMaterialVariants() {
			return null;
		};
		_proto.applyMaterialVariant = function applyMaterialVariant(entity, name) {};
		_proto.applyMaterialVariantInstances = function applyMaterialVariantInstances(instances, name) {};
		return ContainerResource;
	}();
	var ContainerHandler = function () {
		function ContainerHandler(app) {
			this.handlerType = "container";
			this.glbContainerParser = new GlbContainerParser(app.graphicsDevice, app.assets, 0);
			this.parsers = {};
		}
		var _proto2 = ContainerHandler.prototype;
		_proto2._getUrlWithoutParams = function _getUrlWithoutParams(url) {
			return url.indexOf('?') >= 0 ? url.split('?')[0] : url;
		};
		_proto2._getParser = function _getParser(url) {
			var ext = url ? path.getExtension(this._getUrlWithoutParams(url)).toLowerCase().replace('.', '') : null;
			return this.parsers[ext] || this.glbContainerParser;
		};
		_proto2.load = function load(url, callback, asset) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			this._getParser(url.original).load(url, callback, asset);
		};
		_proto2.open = function open(url, data, asset) {
			return this._getParser(url).open(url, data, asset);
		};
		_proto2.patch = function patch(asset, assets) {};
		_createClass(ContainerHandler, [{
			key: "maxRetries",
			get: function get() {
				return this.glbContainerParser.maxRetries;
			},
			set: function set(value) {
				this.glbContainerParser.maxRetries = value;
				for (var parser in this.parsers) {
					if (this.parsers.hasOwnProperty(parser)) {
						this.parsers[parser].maxRetries = value;
					}
				}
			}
		}]);
		return ContainerHandler;
	}();

	var CssHandler = function () {
		function CssHandler(app) {
			this.handlerType = "css";
			this.maxRetries = 0;
		}
		var _proto = CssHandler.prototype;
		_proto.load = function load(url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			http.get(url.load, {
				retry: this.maxRetries > 0,
				maxRetries: this.maxRetries
			}, function (err, response) {
				if (!err) {
					callback(null, response);
				} else {
					callback("Error loading css resource: " + url.original + " [" + err + "]");
				}
			});
		};
		_proto.open = function open(url, data) {
			return data;
		};
		_proto.patch = function patch(asset, assets) {};
		return CssHandler;
	}();

	var CubemapHandler = function () {
		function CubemapHandler(app) {
			this.handlerType = "cubemap";
			this._device = app.graphicsDevice;
			this._registry = app.assets;
			this._loader = app.loader;
		}
		var _proto = CubemapHandler.prototype;
		_proto.load = function load(url, callback, asset) {
			this.loadAssets(asset, callback);
		};
		_proto.open = function open(url, data, asset) {
			return asset ? asset.resource : null;
		};
		_proto.patch = function patch(asset, registry) {
			this.loadAssets(asset, function (err, result) {
				if (err) {
					registry.fire('error', asset);
					registry.fire('error:' + asset.id, err, asset);
					asset.fire('error', asset);
				}
			});
		};
		_proto.getAssetIds = function getAssetIds(cubemapAsset) {
			var result = [];
			result[0] = cubemapAsset.file;
			if ((cubemapAsset.loadFaces || !cubemapAsset.file) && cubemapAsset.data && cubemapAsset.data.textures) {
				for (var i = 0; i < 6; ++i) {
					result[i + 1] = cubemapAsset.data.textures[i];
				}
			} else {
				result[1] = result[2] = result[3] = result[4] = result[5] = result[6] = null;
			}
			return result;
		};
		_proto.compareAssetIds = function compareAssetIds(assetIdA, assetIdB) {
			if (assetIdA && assetIdB) {
				if (parseInt(assetIdA, 10) === assetIdA || typeof assetIdA === 'string') {
					return assetIdA === assetIdB;
				}
				return assetIdA.url === assetIdB.url;
			}
			return assetIdA !== null === (assetIdB !== null);
		};
		_proto.update = function update(cubemapAsset, assetIds, assets) {
			var assetData = cubemapAsset.data || {};
			var oldAssets = cubemapAsset._handlerState.assets;
			var oldResources = cubemapAsset._resources;
			var tex, mip, i;
			var resources = [null, null, null, null, null, null, null];
			var getType = function getType() {
				if (assetData.hasOwnProperty('type')) {
					return assetData.type;
				}
				if (assetData.hasOwnProperty('rgbm')) {
					return assetData.rgbm ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT;
				}
				return null;
			};
			if (!cubemapAsset.loaded || assets[0] !== oldAssets[0]) {
				if (assets[0]) {
					tex = assets[0].resource;
					if (tex.cubemap) {
						for (i = 0; i < 6; ++i) {
							resources[i + 1] = new Texture(this._device, {
								name: cubemapAsset.name + '_prelitCubemap' + (tex.width >> i),
								cubemap: true,
								type: getType() || tex.type,
								width: tex.width >> i,
								height: tex.height >> i,
								format: tex.format,
								levels: [tex._levels[i]],
								fixCubemapSeams: true,
								addressU: ADDRESS_CLAMP_TO_EDGE,
								addressV: ADDRESS_CLAMP_TO_EDGE,
								mipmaps: i === 0
							});
						}
					} else {
						tex.type = TEXTURETYPE_RGBP;
						tex.addressU = ADDRESS_CLAMP_TO_EDGE;
						tex.addressV = ADDRESS_CLAMP_TO_EDGE;
						tex.mipmaps = false;
						resources[1] = tex;
					}
				}
			} else {
				resources[1] = oldResources[1] || null;
				resources[2] = oldResources[2] || null;
				resources[3] = oldResources[3] || null;
				resources[4] = oldResources[4] || null;
				resources[5] = oldResources[5] || null;
				resources[6] = oldResources[6] || null;
			}
			var faceAssets = assets.slice(1);
			if (!cubemapAsset.loaded || !this.cmpArrays(faceAssets, oldAssets.slice(1))) {
				if (faceAssets.indexOf(null) === -1) {
					var _assetData$mipmaps;
					var faceTextures = faceAssets.map(function (asset) {
						return asset.resource;
					});
					var faceLevels = [];
					for (mip = 0; mip < faceTextures[0]._levels.length; ++mip) {
						faceLevels.push(faceTextures.map(function (faceTexture) {
							return faceTexture._levels[mip];
						}));
					}
					var format = faceTextures[0].format;
					var faces = new Texture(this._device, {
						name: cubemapAsset.name + '_faces',
						cubemap: true,
						type: getType() || faceTextures[0].type,
						width: faceTextures[0].width,
						height: faceTextures[0].height,
						format: format === PIXELFORMAT_RGB8 ? PIXELFORMAT_RGBA8 : format,
						mipmaps: (_assetData$mipmaps = assetData.mipmaps) != null ? _assetData$mipmaps : true,
						levels: faceLevels,
						minFilter: assetData.hasOwnProperty('minFilter') ? assetData.minFilter : faceTextures[0].minFilter,
						magFilter: assetData.hasOwnProperty('magFilter') ? assetData.magFilter : faceTextures[0].magFilter,
						anisotropy: assetData.hasOwnProperty('anisotropy') ? assetData.anisotropy : 1,
						addressU: ADDRESS_CLAMP_TO_EDGE,
						addressV: ADDRESS_CLAMP_TO_EDGE,
						fixCubemapSeams: !!assets[0]
					});
					resources[0] = faces;
				}
			} else {
				resources[0] = oldResources[0] || null;
			}
			if (!this.cmpArrays(resources, oldResources)) {
				cubemapAsset.resources = resources;
				cubemapAsset._handlerState.assetIds = assetIds;
				cubemapAsset._handlerState.assets = assets;
				for (i = 0; i < oldResources.length; ++i) {
					if (oldResources[i] !== null && resources.indexOf(oldResources[i]) === -1) {
						oldResources[i].destroy();
					}
				}
			}
			for (i = 0; i < oldAssets.length; ++i) {
				if (oldAssets[i] !== null && assets.indexOf(oldAssets[i]) === -1) {
					oldAssets[i].unload();
				}
			}
		};
		_proto.cmpArrays = function cmpArrays(arr1, arr2) {
			if (arr1.length !== arr2.length) {
				return false;
			}
			for (var i = 0; i < arr1.length; ++i) {
				if (arr1[i] !== arr2[i]) {
					return false;
				}
			}
			return true;
		};
		_proto.resolveId = function resolveId(value) {
			var valueInt = parseInt(value, 10);
			return valueInt === value || valueInt.toString() === value ? valueInt : value;
		};
		_proto.loadAssets = function loadAssets(cubemapAsset, callback) {
			if (!cubemapAsset.hasOwnProperty('_handlerState')) {
				cubemapAsset._handlerState = {
					assetIds: [null, null, null, null, null, null, null],
					assets: [null, null, null, null, null, null, null]
				};
			}
			var self = this;
			var assetIds = self.getAssetIds(cubemapAsset);
			var assets = [null, null, null, null, null, null, null];
			var loadedAssetIds = cubemapAsset._handlerState.assetIds;
			var loadedAssets = cubemapAsset._handlerState.assets;
			var registry = self._registry;
			var awaiting = 7;
			var onLoad = function onLoad(index, asset) {
				assets[index] = asset;
				awaiting--;
				if (awaiting === 0) {
					self.update(cubemapAsset, assetIds, assets);
					callback(null, cubemapAsset.resources);
				}
			};
			var onError = function onError(index, err, asset) {
				callback(err);
			};
			var processTexAsset = function processTexAsset(index, texAsset) {
				if (texAsset.loaded) {
					onLoad(index, texAsset);
				} else {
					registry.once('load:' + texAsset.id, onLoad.bind(self, index));
					registry.once('error:' + texAsset.id, onError.bind(self, index));
					if (!texAsset.loading) {
						registry.load(texAsset);
					}
				}
			};
			var texAsset;
			for (var i = 0; i < 7; ++i) {
				var assetId = this.resolveId(assetIds[i]);
				if (!assetId) {
					onLoad(i, null);
				} else if (self.compareAssetIds(assetId, loadedAssetIds[i])) {
					onLoad(i, loadedAssets[i]);
				} else if (parseInt(assetId, 10) === assetId) {
					texAsset = registry.get(assetId);
					if (texAsset) {
						processTexAsset(i, texAsset);
					} else {
						setTimeout(function (index, assetId_) {
							var texAsset = registry.get(assetId_);
							if (texAsset) {
								processTexAsset(index, texAsset);
							} else {
								onError(index, 'failed to find dependent cubemap asset=' + assetId_);
							}
						}.bind(null, i, assetId));
					}
				} else {
					var file = typeof assetId === 'string' ? {
						url: assetId,
						filename: assetId
					} : assetId;
					texAsset = new Asset(cubemapAsset.name + '_part_' + i, 'texture', file);
					registry.add(texAsset);
					registry.once('load:' + texAsset.id, onLoad.bind(self, i));
					registry.once('error:' + texAsset.id, onError.bind(self, i));
					registry.load(texAsset);
				}
			}
		};
		return CubemapHandler;
	}();

	var FolderHandler = function () {
		function FolderHandler() {
			this.handlerType = "folder";
		}
		var _proto = FolderHandler.prototype;
		_proto.load = function load(url, callback) {
			callback(null, null);
		};
		_proto.open = function open(url, data) {
			return data;
		};
		return FolderHandler;
	}();

	var Font = function () {
		function Font(textures, data) {
			this.type = data ? data.type || FONT_MSDF : FONT_MSDF;
			this.em = 1;
			this.textures = textures;
			this.intensity = 0.0;
			this._data = null;
			this.data = data;
		}
		_createClass(Font, [{
			key: "data",
			get: function get() {
				return this._data;
			},
			set: function set(value) {
				this._data = value;
				if (!value) return;
				if (this._data.intensity !== undefined) {
					this.intensity = this._data.intensity;
				}
				if (!this._data.info) this._data.info = {};
				if (!this._data.version || this._data.version < 2) {
					this._data.info.maps = [{
						width: this._data.info.width,
						height: this._data.info.height
					}];
					if (this._data.chars) {
						for (var key in this._data.chars) {
							this._data.chars[key].map = 0;
						}
					}
				}
			}
		}]);
		return Font;
	}();

	function upgradeDataSchema(data) {
		if (data.version < 3) {
			if (data.version < 2) {
				data.info.maps = data.info.maps || [{
					width: data.info.width,
					height: data.info.height
				}];
			}
			data.chars = Object.keys(data.chars || {}).reduce(function (newChars, key) {
				var existing = data.chars[key];
				var newKey = existing.letter !== undefined ? existing.letter : string.fromCodePoint(key);
				if (data.version < 2) {
					existing.map = existing.map || 0;
				}
				newChars[newKey] = existing;
				return newChars;
			}, {});
			data.version = 3;
		}
		return data;
	}
	var FontHandler = function () {
		function FontHandler(app) {
			this.handlerType = "font";
			this._loader = app.loader;
			this.maxRetries = 0;
		}
		var _proto = FontHandler.prototype;
		_proto.load = function load(url, callback, asset) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			var self = this;
			if (path.getExtension(url.original) === '.json') {
				http.get(url.load, {
					retry: this.maxRetries > 0,
					maxRetries: this.maxRetries
				}, function (err, response) {
					if (!err) {
						var data = upgradeDataSchema(response);
						self._loadTextures(url.load.replace('.json', '.png'), data, function (err, textures) {
							if (err) {
								callback(err);
							} else {
								callback(null, {
									data: data,
									textures: textures
								});
							}
						});
					} else {
						callback("Error loading font resource: " + url.original + " [" + err + "]");
					}
				});
			} else {
				if (asset && asset.data) {
					asset.data = upgradeDataSchema(asset.data);
				}
				this._loadTextures(url.load, asset && asset.data, callback);
			}
		};
		_proto._loadTextures = function _loadTextures(url, data, callback) {
			var numTextures = data.info.maps.length;
			var numLoaded = 0;
			var error = null;
			var textures = new Array(numTextures);
			var loader = this._loader;
			var loadTexture = function loadTexture(index) {
				var onLoaded = function onLoaded(err, texture) {
					if (error) return;
					if (err) {
						error = err;
						callback(err);
						return;
					}
					texture.upload();
					textures[index] = texture;
					numLoaded++;
					if (numLoaded === numTextures) {
						callback(null, textures);
					}
				};
				if (index === 0) {
					loader.load(url, 'texture', onLoaded);
				} else {
					loader.load(url.replace('.png', index + '.png'), 'texture', onLoaded);
				}
			};
			for (var i = 0; i < numTextures; i++) loadTexture(i);
		};
		_proto.open = function open(url, data, asset) {
			var font;
			if (data.textures) {
				font = new Font(data.textures, data.data);
			} else {
				font = new Font(data, null);
			}
			return font;
		};
		_proto.patch = function patch(asset, assets) {
			var font = asset.resource;
			if (!font.data && asset.data) {
				font.data = asset.data;
			} else if (!asset.data && font.data) {
				asset.data = font.data;
			}
			if (asset.data) {
				asset.data = upgradeDataSchema(asset.data);
			}
		};
		return FontHandler;
	}();

	var CompressUtils = function () {
		function CompressUtils() {}
		CompressUtils.setCompressedPRS = function setCompressedPRS(entity, data, compressed) {
			var a = compressed.singleVecs;
			var b, i;
			var v = data.___1;
			if (!v) {
				b = compressed.tripleVecs;
				i = data.___2;
			}
			var n = v ? v[0] : b[i];
			entity.setLocalPosition(a[n], a[n + 1], a[n + 2]);
			n = v ? v[1] : b[i + 1];
			entity.setLocalEulerAngles(a[n], a[n + 1], a[n + 2]);
			n = v ? v[2] : b[i + 2];
			entity.setLocalScale(a[n], a[n + 1], a[n + 2]);
		};
		CompressUtils.oneCharToKey = function oneCharToKey(s, data) {
			var i = s.charCodeAt(0) - data.fieldFirstCode;
			return data.fieldArray[i];
		};
		CompressUtils.multCharToKey = function multCharToKey(s, data) {
			var ind = 0;
			for (var i = 0; i < s.length; i++) {
				ind = ind * data.fieldCodeBase + s.charCodeAt(i) - data.fieldFirstCode;
			}
			return data.fieldArray[ind];
		};
		return CompressUtils;
	}();

	var Decompress = function () {
		function Decompress(node, data) {
			this._node = node;
			this._data = data;
		}
		var _proto = Decompress.prototype;
		_proto.run = function run() {
			var type = Object.prototype.toString.call(this._node);
			if (type === '[object Object]') {
				this._handleMap();
			} else if (type === '[object Array]') {
				this._handleArray();
			} else {
				this._result = this._node;
			}
			return this._result;
		};
		_proto._handleMap = function _handleMap() {
			this._result = {};
			var a = Object.keys(this._node);
			a.forEach(this._handleKey, this);
		};
		_proto._handleKey = function _handleKey(origKey) {
			var newKey = origKey;
			var len = origKey.length;
			if (len === 1) {
				newKey = CompressUtils.oneCharToKey(origKey, this._data);
			} else if (len === 2) {
				newKey = CompressUtils.multCharToKey(origKey, this._data);
			}
			this._result[newKey] = new Decompress(this._node[origKey], this._data).run();
		};
		_proto._handleArray = function _handleArray() {
			this._result = [];
			this._node.forEach(this._handleArElt, this);
		};
		_proto._handleArElt = function _handleArElt(elt) {
			var v = new Decompress(elt, this._data).run();
			this._result.push(v);
		};
		return Decompress;
	}();

	var SceneParser = function () {
		function SceneParser(app, isTemplate) {
			this._app = app;
			this._isTemplate = isTemplate;
		}
		var _proto = SceneParser.prototype;
		_proto.parse = function parse(data) {
			var entities = {};
			var parent = null;
			var compressed = data.compressedFormat;
			if (compressed && !data.entDecompressed) {
				data.entDecompressed = true;
				data.entities = new Decompress(data.entities, compressed).run();
			}
			for (var id in data.entities) {
				var curData = data.entities[id];
				var curEnt = this._createEntity(curData, compressed);
				entities[id] = curEnt;
				if (curData.parent === null) {
					parent = curEnt;
				}
			}
			for (var _id in data.entities) {
				var _curEnt = entities[_id];
				var children = data.entities[_id].children;
				var len = children.length;
				for (var i = 0; i < len; i++) {
					var childEnt = entities[children[i]];
					if (childEnt) {
						_curEnt.addChild(childEnt);
					}
				}
			}
			this._openComponentData(parent, data.entities);
			return parent;
		};
		_proto._createEntity = function _createEntity(data, compressed) {
			var _data$enabled;
			var entity = new Entity(data.name, this._app);
			entity.setGuid(data.resource_id);
			this._setPosRotScale(entity, data, compressed);
			entity._enabled = (_data$enabled = data.enabled) != null ? _data$enabled : true;
			if (this._isTemplate) {
				entity._template = true;
			} else {
				entity._enabledInHierarchy = entity._enabled;
			}
			entity.template = data.template;
			if (data.tags) {
				for (var i = 0; i < data.tags.length; i++) {
					entity.tags.add(data.tags[i]);
				}
			}
			if (data.labels) {
				data.labels.forEach(function (label) {
					entity.addLabel(label);
				});
			}
			return entity;
		};
		_proto._setPosRotScale = function _setPosRotScale(entity, data, compressed) {
			if (compressed) {
				CompressUtils.setCompressedPRS(entity, data, compressed);
			} else {
				var p = data.position;
				var r = data.rotation;
				var s = data.scale;
				entity.setLocalPosition(p[0], p[1], p[2]);
				entity.setLocalEulerAngles(r[0], r[1], r[2]);
				entity.setLocalScale(s[0], s[1], s[2]);
			}
		};
		_proto._openComponentData = function _openComponentData(entity, entities) {
			var systemsList = this._app.systems.list;
			var len = systemsList.length;
			var entityData = entities[entity.getGuid()];
			for (var i = 0; i < len; i++) {
				var system = systemsList[i];
				var componentData = entityData.components[system.id];
				if (componentData) {
					system.addComponent(entity, componentData);
				}
			}
			len = entityData.children.length;
			var children = entity._children;
			for (var _i = 0; _i < len; _i++) {
				if (children[_i]) {
					children[_i] = this._openComponentData(children[_i], entities);
				}
			}
			return entity;
		};
		return SceneParser;
	}();

	var SceneUtils = function () {
		function SceneUtils() {}
		SceneUtils.load = function load(url, maxRetries, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			http.get(url.load, {
				retry: maxRetries > 0,
				maxRetries: maxRetries
			}, function (err, response) {
				if (!err) {
					callback(err, response);
				} else {
					var errMsg = 'Error while loading scene JSON ' + url.original;
					if (err.message) {
						errMsg += ': ' + err.message;
						if (err.stack) {
							errMsg += '\n' + err.stack;
						}
					} else {
						errMsg += ': ' + err;
					}
					callback(errMsg);
				}
			});
		};
		return SceneUtils;
	}();

	var HierarchyHandler = function () {
		function HierarchyHandler(app) {
			this.handlerType = "hierarchy";
			this._app = app;
			this.maxRetries = 0;
		}
		var _proto = HierarchyHandler.prototype;
		_proto.load = function load(url, callback) {
			SceneUtils.load(url, this.maxRetries, callback);
		};
		_proto.open = function open(url, data) {
			this._app.systems.script.preloading = true;
			var parser = new SceneParser(this._app, false);
			var parent = parser.parse(data);
			this._app.systems.script.preloading = false;
			return parent;
		};
		return HierarchyHandler;
	}();

	var HtmlHandler = function () {
		function HtmlHandler(app) {
			this.handlerType = "html";
			this.maxRetries = 0;
		}
		var _proto = HtmlHandler.prototype;
		_proto.load = function load(url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			http.get(url.load, {
				retry: this.maxRetries > 0,
				maxRetries: this.maxRetries
			}, function (err, response) {
				if (!err) {
					callback(null, response);
				} else {
					callback("Error loading html resource: " + url.original + " [" + err + "]");
				}
			});
		};
		_proto.open = function open(url, data) {
			return data;
		};
		_proto.patch = function patch(asset, assets) {};
		return HtmlHandler;
	}();

	var JsonHandler = function () {
		function JsonHandler(app) {
			this.handlerType = "json";
			this.maxRetries = 0;
		}
		var _proto = JsonHandler.prototype;
		_proto.load = function load(url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			var options = {
				retry: this.maxRetries > 0,
				maxRetries: this.maxRetries
			};
			if (url.load.startsWith('blob:')) {
				options.responseType = Http.ResponseType.JSON;
			}
			http.get(url.load, options, function (err, response) {
				if (!err) {
					callback(null, response);
				} else {
					callback("Error loading JSON resource: " + url.original + " [" + err + "]");
				}
			});
		};
		_proto.open = function open(url, data) {
			return data;
		};
		_proto.patch = function patch(asset, assets) {};
		return JsonHandler;
	}();

	var StandardMaterialValidator = function () {
		function StandardMaterialValidator() {
			this.removeInvalid = true;
			this.valid = true;
			this.enumValidators = {
				occludeSpecular: this._createEnumValidator([SPECOCC_NONE, SPECOCC_AO, SPECOCC_GLOSSDEPENDENT]),
				cull: this._createEnumValidator([CULLFACE_NONE, CULLFACE_BACK, CULLFACE_FRONT, CULLFACE_FRONTANDBACK]),
				blendType: this._createEnumValidator([BLEND_SUBTRACTIVE, BLEND_ADDITIVE, BLEND_NORMAL, BLEND_NONE, BLEND_PREMULTIPLIED, BLEND_MULTIPLICATIVE, BLEND_ADDITIVEALPHA, BLEND_MULTIPLICATIVE2X, BLEND_SCREEN, BLEND_MIN, BLEND_MAX]),
				depthFunc: this._createEnumValidator([FUNC_NEVER, FUNC_LESS, FUNC_EQUAL, FUNC_LESSEQUAL, FUNC_GREATER, FUNC_NOTEQUAL, FUNC_GREATEREQUAL, FUNC_ALWAYS]),
				shadingModel: this._createEnumValidator([SPECULAR_PHONG, SPECULAR_BLINN])
			};
		}
		var _proto = StandardMaterialValidator.prototype;
		_proto.setInvalid = function setInvalid(key, data) {
			this.valid = false;
			if (this.removeInvalid) {
				delete data[key];
			}
		};
		_proto.validate = function validate(data) {
			var TYPES = standardMaterialParameterTypes;
			var REMOVED = standardMaterialRemovedParameters;
			var pathMapping = data.mappingFormat === 'path';
			for (var key in data) {
				var type = TYPES[key];
				if (!type) {
					if (REMOVED[key]) {
						delete data[key];
					} else {
						this.valid = false;
					}
					continue;
				}
				if (type.startsWith('enum')) {
					var enumType = type.split(':')[1];
					if (this.enumValidators[enumType]) {
						if (!this.enumValidators[enumType](data[key])) {
							this.setInvalid(key, data);
						}
					}
				} else if (type === 'number') {
					if (typeof data[key] !== 'number') {
						this.setInvalid(key, data);
					}
				} else if (type === 'boolean') {
					if (typeof data[key] !== 'boolean') {
						this.setInvalid(key, data);
					}
				} else if (type === 'string') {
					if (typeof data[key] !== 'string') {
						this.setInvalid(key, data);
					}
				} else if (type === 'vec2') {
					if (!(data[key] instanceof Array && data[key].length === 2)) {
						this.setInvalid(key, data);
					}
				} else if (type === 'rgb') {
					if (!(data[key] instanceof Array && data[key].length === 3)) {
						this.setInvalid(key, data);
					}
				} else if (type === 'texture') {
					if (!pathMapping) {
						if (!(typeof data[key] === 'number' || data[key] === null)) {
							if (!(data[key] instanceof Texture)) {
								this.setInvalid(key, data);
							}
						}
					} else {
						if (!(typeof data[key] === 'string' || data[key] === null)) {
							if (!(data[key] instanceof Texture)) {
								this.setInvalid(key, data);
							}
						}
					}
				} else if (type === 'boundingbox') {
					if (!(data[key].center && data[key].center instanceof Array && data[key].center.length === 3)) {
						this.setInvalid(key, data);
					}
					if (!(data[key].halfExtents && data[key].halfExtents instanceof Array && data[key].halfExtents.length === 3)) {
						this.setInvalid(key, data);
					}
				} else if (type === 'cubemap') {
					if (!(typeof data[key] === 'number' || data[key] === null || data[key] === undefined)) {
						if (!(data[key] instanceof Texture && data[key].cubemap)) {
							this.setInvalid(key, data);
						}
					}
				} else if (type === 'chunks') {
					var chunkNames = Object.keys(data[key]);
					for (var i = 0; i < chunkNames.length; i++) {
						if (typeof data[key][chunkNames[i]] !== 'string') {
							this.setInvalid(chunkNames[i], data[key]);
						}
					}
				} else {
					console.error('Unknown material type: ' + type);
				}
			}
			data.validated = true;
			return this.valid;
		};
		_proto._createEnumValidator = function _createEnumValidator(values) {
			return function (value) {
				return values.indexOf(value) >= 0;
			};
		};
		return StandardMaterialValidator;
	}();

	var JsonStandardMaterialParser = function () {
		function JsonStandardMaterialParser() {
			this._validator = null;
		}
		var _proto = JsonStandardMaterialParser.prototype;
		_proto.parse = function parse(input) {
			var migrated = this.migrate(input);
			var validated = this._validate(migrated);
			var material = new StandardMaterial();
			this.initialize(material, validated);
			return material;
		};
		_proto.initialize = function initialize(material, data) {
			if (!data.validated) {
				data = this._validate(data);
			}
			if (data.chunks) {
				material.chunks = _extends({}, data.chunks);
			}
			for (var key in data) {
				var type = standardMaterialParameterTypes[key];
				var value = data[key];
				if (type === 'vec2') {
					material[key] = new Vec2(value[0], value[1]);
				} else if (type === 'rgb') {
					material[key] = new Color(value[0], value[1], value[2]);
				} else if (type === 'texture') {
					if (value instanceof Texture) {
						material[key] = value;
					} else if (!(material[key] instanceof Texture && typeof value === 'number' && value > 0)) {
						material[key] = null;
					}
				} else if (type === 'cubemap') {
					if (value instanceof Texture) {
						material[key] = value;
					} else if (!(material[key] instanceof Texture && typeof value === 'number' && value > 0)) {
						material[key] = null;
					}
					if (key === 'cubeMap' && !value) {
						material.prefilteredCubemaps = null;
					}
				} else if (type === 'boundingbox') {
					var center = new Vec3(value.center[0], value.center[1], value.center[2]);
					var halfExtents = new Vec3(value.halfExtents[0], value.halfExtents[1], value.halfExtents[2]);
					material[key] = new BoundingBox(center, halfExtents);
				} else {
					material[key] = data[key];
				}
			}
			material.update();
		};
		_proto.migrate = function migrate(data) {
			if (data.shadingModel === undefined) {
				if (data.shader === 'blinn') {
					data.shadingModel = SPECULAR_BLINN;
				} else {
					data.shadingModel = SPECULAR_PHONG;
				}
			}
			if (data.shader) delete data.shader;
			if (data.mapping_format) {
				data.mappingFormat = data.mapping_format;
				delete data.mapping_format;
			}
			var i;
			var RENAMED_PROPERTIES = [['bumpMapFactor', 'bumpiness'], ['aoUvSet', 'aoMapUv'], ['aoMapVertexColor', 'aoVertexColor'], ['diffuseMapVertexColor', 'diffuseVertexColor'], ['emissiveMapVertexColor', 'emissiveVertexColor'], ['specularMapVertexColor', 'specularVertexColor'], ['metalnessMapVertexColor', 'metalnessVertexColor'], ['opacityMapVertexColor', 'opacityVertexColor'], ['glossMapVertexColor', 'glossVertexColor'], ['lightMapVertexColor', 'lightVertexColor'], ['diffuseMapTint', 'diffuseTint'], ['specularMapTint', 'specularTint'], ['emissiveMapTint', 'emissiveTint'], ['metalnessMapTint', 'metalnessTint'], ['clearCoatGlossiness', 'clearCoatGloss']];
			for (i = 0; i < RENAMED_PROPERTIES.length; i++) {
				var _old = RENAMED_PROPERTIES[i][0];
				var _new = RENAMED_PROPERTIES[i][1];
				if (data[_old] !== undefined) {
					if (data[_new] === undefined) {
						data[_new] = data[_old];
					}
					delete data[_old];
				}
			}
			var DEPRECATED_PROPERTIES = ['fresnelFactor', 'shadowSampleType'];
			for (i = 0; i < DEPRECATED_PROPERTIES.length; i++) {
				var name = DEPRECATED_PROPERTIES[i];
				if (data.hasOwnProperty(name)) {
					delete data[name];
				}
			}
			return data;
		};
		_proto._validate = function _validate(data) {
			if (!data.validated) {
				if (!this._validator) {
					this._validator = new StandardMaterialValidator();
				}
				this._validator.validate(data);
			}
			return data;
		};
		return JsonStandardMaterialParser;
	}();

	var PLACEHOLDER_MAP = {
		aoMap: 'white',
		diffuseMap: 'gray',
		specularMap: 'gray',
		specularityFactorMap: 'white',
		metalnessMap: 'black',
		glossMap: 'gray',
		sheenMap: 'black',
		sheenGlossinessMap: 'gray',
		clearCoatMap: 'black',
		clearCoatGlossMap: 'gray',
		clearCoatNormalMap: 'normal',
		refractionMap: 'white',
		emissiveMap: 'gray',
		normalMap: 'normal',
		heightMap: 'gray',
		opacityMap: 'gray',
		sphereMap: 'gray',
		lightMap: 'white'
	};
	var MaterialHandler = function () {
		function MaterialHandler(app) {
			this.handlerType = "material";
			this._assets = app.assets;
			this._device = app.graphicsDevice;
			this._placeholderTextures = null;
			this._parser = new JsonStandardMaterialParser();
			this.maxRetries = 0;
		}
		var _proto = MaterialHandler.prototype;
		_proto.load = function load(url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			http.get(url.load, {
				retry: this.maxRetries > 0,
				maxRetries: this.maxRetries
			}, function (err, response) {
				if (!err) {
					if (callback) {
						response._engine = true;
						callback(null, response);
					}
				} else {
					if (callback) {
						callback("Error loading material: " + url.original + " [" + err + "]");
					}
				}
			});
		};
		_proto.open = function open(url, data) {
			var material = this._parser.parse(data);
			if (data._engine) {
				material._data = data;
				delete data._engine;
			}
			return material;
		};
		_proto._createPlaceholders = function _createPlaceholders() {
			this._placeholderTextures = {};
			var textures = {
				white: [255, 255, 255, 255],
				gray: [128, 128, 128, 255],
				black: [0, 0, 0, 255],
				normal: [128, 128, 255, 255]
			};
			for (var key in textures) {
				if (!textures.hasOwnProperty(key)) continue;
				this._placeholderTextures[key] = new Texture(this._device, {
					width: 2,
					height: 2,
					format: PIXELFORMAT_RGBA8,
					name: 'material_placeholder'
				});
				var pixels = this._placeholderTextures[key].lock();
				for (var i = 0; i < 4; i++) {
					for (var c = 0; c < 4; c++) {
						pixels[i * 4 + c] = textures[key][c];
					}
				}
				this._placeholderTextures[key].unlock();
			}
		};
		_proto.patch = function patch(asset, assets) {
			if (asset.resource._data) {
				asset._data = asset.resource._data;
				delete asset.resource._data;
			}
			asset.data.name = asset.name;
			asset.resource.name = asset.name;
			this._bindAndAssignAssets(asset, assets);
			asset.off('unload', this._onAssetUnload, this);
			asset.on('unload', this._onAssetUnload, this);
		};
		_proto._onAssetUnload = function _onAssetUnload(asset) {
			delete asset.data.parameters;
			delete asset.data.chunks;
			delete asset.data.name;
		};
		_proto._assignTexture = function _assignTexture(parameterName, materialAsset, texture) {
			materialAsset.resource[parameterName] = texture;
		};
		_proto._getPlaceholderTexture = function _getPlaceholderTexture(parameterName) {
			if (!this._placeholderTextures) {
				this._createPlaceholders();
			}
			var placeholder = PLACEHOLDER_MAP[parameterName];
			var texture = this._placeholderTextures[placeholder];
			return texture;
		};
		_proto._assignPlaceholderTexture = function _assignPlaceholderTexture(parameterName, materialAsset) {
			materialAsset.resource[parameterName] = this._getPlaceholderTexture(parameterName);
		};
		_proto._onTextureLoad = function _onTextureLoad(parameterName, materialAsset, textureAsset) {
			this._assignTexture(parameterName, materialAsset, textureAsset.resource);
			materialAsset.resource.update();
		};
		_proto._onTextureAdd = function _onTextureAdd(parameterName, materialAsset, textureAsset) {
			this._assets.load(textureAsset);
		};
		_proto._onTextureRemoveOrUnload = function _onTextureRemoveOrUnload(parameterName, materialAsset, textureAsset) {
			var material = materialAsset.resource;
			if (material) {
				if (materialAsset.resource[parameterName] === textureAsset.resource) {
					this._assignPlaceholderTexture(parameterName, materialAsset);
					material.update();
				}
			}
		};
		_proto._assignCubemap = function _assignCubemap(parameterName, materialAsset, textures) {
			materialAsset.resource[parameterName] = textures[0];
			if (parameterName === 'cubeMap') {
				var prefiltered = textures.slice(1);
				if (prefiltered.every(function (t) {
					return t;
				})) {
					materialAsset.resource.prefilteredCubemaps = prefiltered;
				} else if (prefiltered[0]) {
					materialAsset.resource.envAtlas = prefiltered[0];
				}
			}
		};
		_proto._onCubemapLoad = function _onCubemapLoad(parameterName, materialAsset, cubemapAsset) {
			this._assignCubemap(parameterName, materialAsset, cubemapAsset.resources);
			this._parser.initialize(materialAsset.resource, materialAsset.data);
		};
		_proto._onCubemapAdd = function _onCubemapAdd(parameterName, materialAsset, cubemapAsset) {
			if (materialAsset.data.shadingModel === SPECULAR_PHONG) {
				materialAsset.loadFaces = true;
			}
			this._assets.load(cubemapAsset);
		};
		_proto._onCubemapRemoveOrUnload = function _onCubemapRemoveOrUnload(parameterName, materialAsset, cubemapAsset) {
			var material = materialAsset.resource;
			if (materialAsset.data.prefilteredCubeMap128 === cubemapAsset.resources[1]) {
				this._assignCubemap(parameterName, materialAsset, [null, null, null, null, null, null, null]);
				material.update();
			}
		};
		_proto._bindAndAssignAssets = function _bindAndAssignAssets(materialAsset, assets) {
			var data = this._parser.migrate(materialAsset.data);
			var material = materialAsset.resource;
			var pathMapping = data.mappingFormat === 'path';
			var TEXTURES = standardMaterialTextureParameters;
			var i, name, assetReference;
			for (i = 0; i < TEXTURES.length; i++) {
				name = TEXTURES[i];
				assetReference = material._assetReferences[name];
				var dataAssetId = data[name];
				var materialTexture = material[name];
				var isPlaceHolderTexture = materialTexture === this._getPlaceholderTexture(name);
				var dataValidated = data.validated;
				if (dataAssetId && (!materialTexture || !dataValidated || isPlaceHolderTexture)) {
					if (!assetReference) {
						assetReference = new AssetReference(name, materialAsset, assets, {
							load: this._onTextureLoad,
							add: this._onTextureAdd,
							remove: this._onTextureRemoveOrUnload,
							unload: this._onTextureRemoveOrUnload
						}, this);
						material._assetReferences[name] = assetReference;
					}
					if (pathMapping) {
						assetReference.url = materialAsset.getAbsoluteUrl(dataAssetId);
					} else {
						assetReference.id = dataAssetId;
					}
					if (assetReference.asset) {
						if (assetReference.asset.resource) {
							this._assignTexture(name, materialAsset, assetReference.asset.resource);
						} else {
							this._assignPlaceholderTexture(name, materialAsset);
						}
						assets.load(assetReference.asset);
					}
				} else {
					if (assetReference) {
						if (pathMapping) {
							assetReference.url = null;
						} else {
							assetReference.id = null;
						}
					}
				}
			}
			var CUBEMAPS = standardMaterialCubemapParameters;
			for (i = 0; i < CUBEMAPS.length; i++) {
				name = CUBEMAPS[i];
				assetReference = material._assetReferences[name];
				if (data[name] && !materialAsset.data.prefilteredCubeMap128) {
					if (!assetReference) {
						assetReference = new AssetReference(name, materialAsset, assets, {
							load: this._onCubemapLoad,
							add: this._onCubemapAdd,
							remove: this._onCubemapRemoveOrUnload,
							unload: this._onCubemapRemoveOrUnload
						}, this);
						material._assetReferences[name] = assetReference;
					}
					if (pathMapping) {
						assetReference.url = data[name];
					} else {
						assetReference.id = data[name];
					}
					if (assetReference.asset) {
						if (assetReference.asset.loaded) {
							this._assignCubemap(name, materialAsset, assetReference.asset.resources);
						}
						assets.load(assetReference.asset);
					}
				}
			}
			this._parser.initialize(material, data);
		};
		return MaterialHandler;
	}();

	var GlbModelParser = function () {
		function GlbModelParser(modelHandler) {
			this._device = modelHandler.device;
			this._defaultMaterial = modelHandler.defaultMaterial;
			this._assets = modelHandler.assets;
		}
		var _proto = GlbModelParser.prototype;
		_proto.parse = function parse(data, callback, asset) {
			var _asset$options,
				_this = this;
			GlbParser.parse('filename.glb', '', data, this._device, this._assets, (_asset$options = asset == null ? void 0 : asset.options) != null ? _asset$options : {}, function (err, result) {
				if (err) {
					callback(err);
				} else {
					var model = GlbContainerResource.createModel(result, _this._defaultMaterial);
					result.destroy();
					callback(null, model);
				}
			});
		};
		return GlbModelParser;
	}();

	var PartitionedVertex = function PartitionedVertex() {
		this.index = 0;
		this.boneIndices = [0, 0, 0, 0];
	};
	var SkinPartition = function () {
		function SkinPartition() {
			this.partition = 0;
			this.vertexStart = 0;
			this.vertexCount = 0;
			this.indexStart = 0;
			this.indexCount = 0;
			this.boneIndices = [];
			this.vertices = [];
			this.indices = [];
			this.indexMap = {};
			this.originalMesh = null;
		}
		var _proto = SkinPartition.prototype;
		_proto.addVertex = function addVertex(vertex, idx, vertexArray) {
			var remappedIndex = -1;
			if (this.indexMap[idx] !== undefined) {
				remappedIndex = this.indexMap[idx];
				this.indices.push(remappedIndex);
			} else {
				for (var influence = 0; influence < 4; influence++) {
					if (vertexArray.blendWeight.data[idx * 4 + influence] === 0) continue;
					var originalBoneIndex = vertexArray.blendIndices.data[vertex.index * 4 + influence];
					vertex.boneIndices[influence] = this.getBoneRemap(originalBoneIndex);
				}
				remappedIndex = this.vertices.length;
				this.indices.push(remappedIndex);
				this.vertices.push(vertex);
				this.indexMap[idx] = remappedIndex;
			}
		};
		_proto.addPrimitive = function addPrimitive(vertices, vertexIndices, vertexArray, boneLimit) {
			var bonesToAdd = [];
			var bonesToAddCount = 0;
			var vertexCount = vertices.length;
			for (var i = 0; i < vertexCount; i++) {
				var vertex = vertices[i];
				var idx = vertex.index;
				for (var influence = 0; influence < 4; influence++) {
					if (vertexArray.blendWeight.data[idx * 4 + influence] > 0) {
						var boneIndex = vertexArray.blendIndices.data[idx * 4 + influence];
						var needToAdd = true;
						for (var j = 0; j < bonesToAddCount; j++) {
							if (bonesToAdd[j] === boneIndex) {
								needToAdd = false;
								break;
							}
						}
						if (needToAdd) {
							bonesToAdd[bonesToAddCount] = boneIndex;
							var boneRemap = this.getBoneRemap(boneIndex);
							bonesToAddCount += boneRemap === -1 ? 1 : 0;
						}
					}
				}
			}
			if (this.boneIndices.length + bonesToAddCount > boneLimit) {
				return false;
			}
			for (var _i = 0; _i < bonesToAddCount; _i++) {
				this.boneIndices.push(bonesToAdd[_i]);
			}
			for (var _i2 = 0; _i2 < vertexCount; _i2++) {
				this.addVertex(vertices[_i2], vertexIndices[_i2], vertexArray);
			}
			return true;
		};
		_proto.getBoneRemap = function getBoneRemap(boneIndex) {
			for (var i = 0; i < this.boneIndices.length; i++) {
				if (this.boneIndices[i] === boneIndex) {
					return i;
				}
			}
			return -1;
		};
		return SkinPartition;
	}();
	function indicesToReferences(model) {
		var vertices = model.vertices;
		var skins = model.skins;
		var meshes = model.meshes;
		var meshInstances = model.meshInstances;
		for (var i = 0; i < meshes.length; i++) {
			meshes[i].vertices = vertices[meshes[i].vertices];
			if (meshes[i].skin !== undefined) {
				meshes[i].skin = skins[meshes[i].skin];
			}
		}
		for (var _i3 = 0; _i3 < meshInstances.length; _i3++) {
			meshInstances[_i3].mesh = meshes[meshInstances[_i3].mesh];
		}
	}
	function referencesToIndices(model) {
		var vertices = model.vertices;
		var skins = model.skins;
		var meshes = model.meshes;
		var meshInstances = model.meshInstances;
		for (var i = 0; i < meshes.length; i++) {
			meshes[i].vertices = vertices.indexOf(meshes[i].vertices);
			if (meshes[i].skin !== undefined) {
				meshes[i].skin = skins.indexOf(meshes[i].skin);
			}
		}
		for (var _i4 = 0; _i4 < meshInstances.length; _i4++) {
			meshInstances[_i4].mesh = meshes.indexOf(meshInstances[_i4].mesh);
		}
	}
	function partitionSkin(model, materialMappings, boneLimit) {
		var i, j, k, index;
		indicesToReferences(model);
		var vertexArrays = model.vertices;
		var skins = model.skins;
		var mesh;
		var meshes = model.meshes;
		var meshInstances = model.meshInstances;
		var getVertex = function getVertex(idx) {
			var vert = new PartitionedVertex();
			vert.index = idx;
			return vert;
		};
		for (i = skins.length - 1; i >= 0; i--) {
			if (skins[i].boneNames.length > boneLimit) {
				var skin = skins.splice(i, 1)[0];
				var meshesToSplit = [];
				for (j = 0; j < meshes.length; j++) {
					if (meshes[j].skin === skin) {
						meshesToSplit.push(meshes[j]);
					}
				}
				for (j = 0; j < meshesToSplit.length; j++) {
					index = meshes.indexOf(meshesToSplit[j]);
					if (index !== -1) {
						meshes.splice(index, 1);
					}
				}
				if (meshesToSplit.length === 0) {
					throw new Error('partitionSkin: There should be at least one mesh that references a skin');
				}
				var vertexArray = meshesToSplit[0].vertices;
				for (j = 1; j < meshesToSplit.length; j++) {
					if (meshesToSplit[j].vertices !== vertexArray) {
						throw new Error('partitionSkin: All meshes that share a skin should also share the same vertex buffer');
					}
				}
				var partition = void 0;
				var partitions = [];
				var primitiveVertices = [];
				var primitiveIndices = [];
				var basePartition = 0;
				for (j = 0; j < meshesToSplit.length; j++) {
					mesh = meshesToSplit[j];
					var indices = mesh.indices;
					for (var iIndex = mesh.base; iIndex < mesh.base + mesh.count;) {
						index = indices[iIndex++];
						primitiveVertices[0] = getVertex(index);
						primitiveIndices[0] = index;
						index = indices[iIndex++];
						primitiveVertices[1] = getVertex(index);
						primitiveIndices[1] = index;
						index = indices[iIndex++];
						primitiveVertices[2] = getVertex(index);
						primitiveIndices[2] = index;
						var added = false;
						for (var iBonePartition = basePartition; iBonePartition < partitions.length; iBonePartition++) {
							partition = partitions[iBonePartition];
							if (partition.addPrimitive(primitiveVertices, primitiveIndices, vertexArray, boneLimit)) {
								added = true;
								break;
							}
						}
						if (!added) {
							partition = new SkinPartition();
							partition.originalMesh = mesh;
							partition.addPrimitive(primitiveVertices, primitiveIndices, vertexArray, boneLimit);
							partitions.push(partition);
						}
					}
					basePartition = partitions.length;
				}
				var partitionedVertices = [];
				var partitionedIndices = [];
				for (j = 0; j < partitions.length; j++) {
					partition = partitions[j];
					if (partition.vertices.length && partition.indices.length) {
						var vertexStart = partitionedVertices.length;
						var vertexCount = partition.vertices.length;
						var indexStart = partitionedIndices.length;
						var indexCount = partition.indices.length;
						partition.partition = j;
						partition.vertexStart = vertexStart;
						partition.vertexCount = vertexCount;
						partition.indexStart = indexStart;
						partition.indexCount = indexCount;
						var iSour = void 0;
						var iDest = void 0;
						iSour = 0;
						iDest = vertexStart;
						while (iSour < vertexCount) {
							partitionedVertices[iDest++] = partition.vertices[iSour++];
						}
						iSour = 0;
						iDest = indexStart;
						while (iSour < indexCount) {
							partitionedIndices[iDest++] = partition.indices[iSour++] + vertexStart;
						}
					}
				}
				var splitSkins = [];
				for (j = 0; j < partitions.length; j++) {
					partition = partitions[j];
					var ibp = [];
					var boneNames = [];
					for (k = 0; k < partition.boneIndices.length; k++) {
						ibp.push(skin.inverseBindMatrices[partition.boneIndices[k]]);
						boneNames.push(skin.boneNames[partition.boneIndices[k]]);
					}
					var splitSkin = {
						inverseBindMatrices: ibp,
						boneNames: boneNames
					};
					splitSkins.push(splitSkin);
					skins.push(splitSkin);
				}
				var attrib = void 0,
					attribName = void 0,
					data = void 0,
					components = void 0;
				var splitVertexArray = {};
				for (attribName in vertexArray) {
					splitVertexArray[attribName] = {
						components: vertexArray[attribName].components,
						data: [],
						type: vertexArray[attribName].type
					};
				}
				for (attribName in vertexArray) {
					if (attribName === 'blendIndices') {
						var dstBoneIndices = splitVertexArray[attribName].data;
						for (j = 0; j < partitionedVertices.length; j++) {
							var srcBoneIndices = partitionedVertices[j].boneIndices;
							dstBoneIndices.push(srcBoneIndices[0], srcBoneIndices[1], srcBoneIndices[2], srcBoneIndices[3]);
						}
					} else {
						attrib = vertexArray[attribName];
						data = attrib.data;
						components = attrib.components;
						for (j = 0; j < partitionedVertices.length; j++) {
							index = partitionedVertices[j].index;
							for (k = 0; k < components; k++) {
								splitVertexArray[attribName].data.push(data[index * components + k]);
							}
						}
					}
				}
				vertexArrays[vertexArrays.indexOf(vertexArray)] = splitVertexArray;
				for (j = 0; j < partitions.length; j++) {
					partition = partitions[j];
					mesh = {
						aabb: {
							min: [0, 0, 0],
							max: [0, 0, 0]
						},
						vertices: splitVertexArray,
						skin: splitSkins[j],
						indices: partitionedIndices.splice(0, partition.indexCount),
						type: 'triangles',
						base: 0,
						count: partition.indexCount
					};
					meshes.push(mesh);
					for (k = meshInstances.length - 1; k >= 0; k--) {
						if (meshInstances[k].mesh === partition.originalMesh) {
							meshInstances.push({
								mesh: mesh,
								node: meshInstances[k].node
							});
							if (materialMappings) {
								materialMappings.push({
									material: materialMappings[k].material,
									path: materialMappings[k].path
								});
							}
						}
					}
				}
				for (j = 0; j < partitions.length; j++) {
					partition = partitions[j];
					for (k = meshInstances.length - 1; k >= 0; k--) {
						if (meshInstances[k].mesh === partition.originalMesh) {
							meshInstances.splice(k, 1);
							if (materialMappings) {
								materialMappings.splice(k, 1);
							}
						}
					}
				}
			}
		}
		referencesToIndices(model);
	}

	var JSON_PRIMITIVE_TYPE = {
		'points': PRIMITIVE_POINTS,
		'lines': PRIMITIVE_LINES,
		'lineloop': PRIMITIVE_LINELOOP,
		'linestrip': PRIMITIVE_LINESTRIP,
		'triangles': PRIMITIVE_TRIANGLES,
		'trianglestrip': PRIMITIVE_TRISTRIP,
		'trianglefan': PRIMITIVE_TRIFAN
	};
	var JSON_VERTEX_ELEMENT_TYPE = {
		'int8': TYPE_INT8,
		'uint8': TYPE_UINT8,
		'int16': TYPE_INT16,
		'uint16': TYPE_UINT16,
		'int32': TYPE_INT32,
		'uint32': TYPE_UINT32,
		'float32': TYPE_FLOAT32
	};
	var JsonModelParser = function () {
		function JsonModelParser(modelHandler) {
			this._device = modelHandler.device;
			this._defaultMaterial = modelHandler.defaultMaterial;
		}
		var _proto = JsonModelParser.prototype;
		_proto.parse = function parse(data, callback) {
			var modelData = data.model;
			if (!modelData) {
				callback(null, null);
				return;
			}
			if (modelData.version <= 1) {
				callback('JsonModelParser#parse: Trying to parse unsupported model format.');
				return;
			}
			var nodes = this._parseNodes(data);
			var skins = this._parseSkins(data, nodes);
			var vertexBuffers = this._parseVertexBuffers(data);
			var indices = this._parseIndexBuffers(data, vertexBuffers);
			var morphs = this._parseMorphs(data, nodes, vertexBuffers);
			var meshes = this._parseMeshes(data, skins.skins, morphs.morphs, vertexBuffers, indices.buffer, indices.data);
			var meshInstances = this._parseMeshInstances(data, nodes, meshes, skins.skins, skins.instances, morphs.morphs, morphs.instances);
			var model = new Model();
			model.graph = nodes[0];
			model.meshInstances = meshInstances;
			model.skinInstances = skins.instances;
			model.morphInstances = morphs.instances;
			model.getGraph().syncHierarchy();
			callback(null, model);
		};
		_proto._parseNodes = function _parseNodes(data) {
			var modelData = data.model;
			var nodes = [];
			var i;
			for (i = 0; i < modelData.nodes.length; i++) {
				var nodeData = modelData.nodes[i];
				var node = new GraphNode(nodeData.name);
				node.setLocalPosition(nodeData.position[0], nodeData.position[1], nodeData.position[2]);
				node.setLocalEulerAngles(nodeData.rotation[0], nodeData.rotation[1], nodeData.rotation[2]);
				node.setLocalScale(nodeData.scale[0], nodeData.scale[1], nodeData.scale[2]);
				node.scaleCompensation = !!nodeData.scaleCompensation;
				nodes.push(node);
			}
			for (i = 1; i < modelData.parents.length; i++) {
				nodes[modelData.parents[i]].addChild(nodes[i]);
			}
			return nodes;
		};
		_proto._parseSkins = function _parseSkins(data, nodes) {
			var modelData = data.model;
			var skins = [];
			var skinInstances = [];
			var i, j;
			if (!this._device.supportsBoneTextures && modelData.skins.length > 0) {
				var boneLimit = this._device.getBoneLimit();
				partitionSkin(modelData, null, boneLimit);
			}
			for (i = 0; i < modelData.skins.length; i++) {
				var skinData = modelData.skins[i];
				var inverseBindMatrices = [];
				for (j = 0; j < skinData.inverseBindMatrices.length; j++) {
					var ibm = skinData.inverseBindMatrices[j];
					inverseBindMatrices[j] = new Mat4().set(ibm);
				}
				var skin = new Skin(this._device, inverseBindMatrices, skinData.boneNames);
				skins.push(skin);
				var skinInstance = new SkinInstance(skin);
				var bones = [];
				for (j = 0; j < skin.boneNames.length; j++) {
					var boneName = skin.boneNames[j];
					var bone = nodes[0].findByName(boneName);
					bones.push(bone);
				}
				skinInstance.bones = bones;
				skinInstances.push(skinInstance);
			}
			return {
				skins: skins,
				instances: skinInstances
			};
		};
		_proto._getMorphVertexCount = function _getMorphVertexCount(modelData, morphIndex, vertexBuffers) {
			for (var i = 0; i < modelData.meshes.length; i++) {
				var meshData = modelData.meshes[i];
				if (meshData.morph === morphIndex) {
					var vertexBuffer = vertexBuffers[meshData.vertices];
					return vertexBuffer.numVertices;
				}
			}
			return undefined;
		};
		_proto._parseMorphs = function _parseMorphs(data, nodes, vertexBuffers) {
			var modelData = data.model;
			var morphs = [];
			var morphInstances = [];
			var i, j, vertexCount;
			var targets, morphTarget, morphTargetArray;
			if (modelData.morphs) {
				var sparseToFull = function sparseToFull(data, indices, totalCount) {
					var full = new Float32Array(totalCount * 3);
					for (var s = 0; s < indices.length; s++) {
						var dstIndex = indices[s] * 3;
						full[dstIndex] = data[s * 3];
						full[dstIndex + 1] = data[s * 3 + 1];
						full[dstIndex + 2] = data[s * 3 + 2];
					}
					return full;
				};
				for (i = 0; i < modelData.morphs.length; i++) {
					targets = modelData.morphs[i].targets;
					morphTargetArray = [];
					vertexCount = this._getMorphVertexCount(modelData, i, vertexBuffers);
					for (j = 0; j < targets.length; j++) {
						var targetAabb = targets[j].aabb;
						var min = targetAabb.min;
						var max = targetAabb.max;
						var aabb = new BoundingBox(new Vec3((max[0] + min[0]) * 0.5, (max[1] + min[1]) * 0.5, (max[2] + min[2]) * 0.5), new Vec3((max[0] - min[0]) * 0.5, (max[1] - min[1]) * 0.5, (max[2] - min[2]) * 0.5));
						var indices = targets[j].indices;
						var deltaPositions = targets[j].deltaPositions;
						var deltaNormals = targets[j].deltaNormals;
						if (indices) {
							deltaPositions = sparseToFull(deltaPositions, indices, vertexCount);
							deltaNormals = sparseToFull(deltaNormals, indices, vertexCount);
						}
						morphTarget = new MorphTarget({
							deltaPositions: deltaPositions,
							deltaNormals: deltaNormals,
							name: targets[j].name,
							aabb: aabb
						});
						morphTargetArray.push(morphTarget);
					}
					var morph = new Morph(morphTargetArray, this._device);
					morphs.push(morph);
					var morphInstance = new MorphInstance(morph);
					morphInstances.push(morphInstance);
				}
			}
			return {
				morphs: morphs,
				instances: morphInstances
			};
		};
		_proto._parseVertexBuffers = function _parseVertexBuffers(data) {
			var modelData = data.model;
			var vertexBuffers = [];
			var attributeMap = {
				position: SEMANTIC_POSITION,
				normal: SEMANTIC_NORMAL,
				tangent: SEMANTIC_TANGENT,
				blendWeight: SEMANTIC_BLENDWEIGHT,
				blendIndices: SEMANTIC_BLENDINDICES,
				color: SEMANTIC_COLOR,
				texCoord0: SEMANTIC_TEXCOORD0,
				texCoord1: SEMANTIC_TEXCOORD1,
				texCoord2: SEMANTIC_TEXCOORD2,
				texCoord3: SEMANTIC_TEXCOORD3,
				texCoord4: SEMANTIC_TEXCOORD4,
				texCoord5: SEMANTIC_TEXCOORD5,
				texCoord6: SEMANTIC_TEXCOORD6,
				texCoord7: SEMANTIC_TEXCOORD7
			};
			for (var i = 0; i < modelData.vertices.length; i++) {
				var vertexData = modelData.vertices[i];
				var formatDesc = [];
				for (var attributeName in vertexData) {
					var attribute = vertexData[attributeName];
					formatDesc.push({
						semantic: attributeMap[attributeName],
						components: attribute.components,
						type: JSON_VERTEX_ELEMENT_TYPE[attribute.type],
						normalize: attributeMap[attributeName] === SEMANTIC_COLOR
					});
				}
				var vertexFormat = new VertexFormat(this._device, formatDesc);
				var numVertices = vertexData.position.data.length / vertexData.position.components;
				var vertexBuffer = new VertexBuffer(this._device, vertexFormat, numVertices);
				var iterator = new VertexIterator(vertexBuffer);
				for (var j = 0; j < numVertices; j++) {
					for (var _attributeName in vertexData) {
						var _attribute = vertexData[_attributeName];
						switch (_attribute.components) {
							case 1:
								iterator.element[attributeMap[_attributeName]].set(_attribute.data[j]);
								break;
							case 2:
								iterator.element[attributeMap[_attributeName]].set(_attribute.data[j * 2], 1.0 - _attribute.data[j * 2 + 1]);
								break;
							case 3:
								iterator.element[attributeMap[_attributeName]].set(_attribute.data[j * 3], _attribute.data[j * 3 + 1], _attribute.data[j * 3 + 2]);
								break;
							case 4:
								iterator.element[attributeMap[_attributeName]].set(_attribute.data[j * 4], _attribute.data[j * 4 + 1], _attribute.data[j * 4 + 2], _attribute.data[j * 4 + 3]);
								break;
						}
					}
					iterator.next();
				}
				iterator.end();
				vertexBuffers.push(vertexBuffer);
			}
			return vertexBuffers;
		};
		_proto._parseIndexBuffers = function _parseIndexBuffers(data, vertexBuffers) {
			var modelData = data.model;
			var indexBuffer = null;
			var indexData = null;
			var i;
			var numIndices = 0;
			for (i = 0; i < modelData.meshes.length; i++) {
				var meshData = modelData.meshes[i];
				if (meshData.indices !== undefined) {
					numIndices += meshData.indices.length;
				}
			}
			var maxVerts = 0;
			for (i = 0; i < vertexBuffers.length; i++) {
				maxVerts = Math.max(maxVerts, vertexBuffers[i].numVertices);
			}
			if (numIndices > 0) {
				if (maxVerts > 0xFFFF && this._device.extUintElement) {
					indexBuffer = new IndexBuffer(this._device, INDEXFORMAT_UINT32, numIndices);
					indexData = new Uint32Array(indexBuffer.lock());
				} else {
					indexBuffer = new IndexBuffer(this._device, INDEXFORMAT_UINT16, numIndices);
					indexData = new Uint16Array(indexBuffer.lock());
				}
			}
			return {
				buffer: indexBuffer,
				data: indexData
			};
		};
		_proto._parseMeshes = function _parseMeshes(data, skins, morphs, vertexBuffers, indexBuffer, indexData) {
			var modelData = data.model;
			var meshes = [];
			var indexBase = 0;
			for (var i = 0; i < modelData.meshes.length; i++) {
				var meshData = modelData.meshes[i];
				var meshAabb = meshData.aabb;
				var min = meshAabb.min;
				var max = meshAabb.max;
				var aabb = new BoundingBox(new Vec3((max[0] + min[0]) * 0.5, (max[1] + min[1]) * 0.5, (max[2] + min[2]) * 0.5), new Vec3((max[0] - min[0]) * 0.5, (max[1] - min[1]) * 0.5, (max[2] - min[2]) * 0.5));
				var indexed = meshData.indices !== undefined;
				var mesh = new Mesh(this._device);
				mesh.vertexBuffer = vertexBuffers[meshData.vertices];
				mesh.indexBuffer[0] = indexed ? indexBuffer : null;
				mesh.primitive[0].type = JSON_PRIMITIVE_TYPE[meshData.type];
				mesh.primitive[0].base = indexed ? meshData.base + indexBase : meshData.base;
				mesh.primitive[0].count = meshData.count;
				mesh.primitive[0].indexed = indexed;
				mesh.skin = meshData.skin !== undefined ? skins[meshData.skin] : null;
				mesh.morph = meshData.morph !== undefined ? morphs[meshData.morph] : null;
				mesh.aabb = aabb;
				if (indexed) {
					indexData.set(meshData.indices, indexBase);
					indexBase += meshData.indices.length;
				}
				meshes.push(mesh);
			}
			if (indexBuffer !== null) {
				indexBuffer.unlock();
			}
			return meshes;
		};
		_proto._parseMeshInstances = function _parseMeshInstances(data, nodes, meshes, skins, skinInstances, morphs, morphInstances) {
			var modelData = data.model;
			var meshInstances = [];
			var i;
			for (i = 0; i < modelData.meshInstances.length; i++) {
				var meshInstanceData = modelData.meshInstances[i];
				var node = nodes[meshInstanceData.node];
				var mesh = meshes[meshInstanceData.mesh];
				var meshInstance = new MeshInstance(mesh, this._defaultMaterial, node);
				if (mesh.skin) {
					var skinIndex = skins.indexOf(mesh.skin);
					meshInstance.skinInstance = skinInstances[skinIndex];
				}
				if (mesh.morph) {
					var morphIndex = morphs.indexOf(mesh.morph);
					meshInstance.morphInstance = morphInstances[morphIndex];
				}
				meshInstances.push(meshInstance);
			}
			return meshInstances;
		};
		return JsonModelParser;
	}();

	var ModelHandler = function () {
		function ModelHandler(app) {
			this.handlerType = "model";
			this._parsers = [];
			this.device = app.graphicsDevice;
			this.assets = app.assets;
			this.defaultMaterial = getDefaultMaterial(this.device);
			this.maxRetries = 0;
			this.addParser(new JsonModelParser(this), function (url, data) {
				return path.getExtension(url) === '.json';
			});
			this.addParser(new GlbModelParser(this), function (url, data) {
				return path.getExtension(url) === '.glb';
			});
		}
		var _proto = ModelHandler.prototype;
		_proto.load = function load(url, callback, asset) {
			var _this = this;
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			var options = {
				retry: this.maxRetries > 0,
				maxRetries: this.maxRetries
			};
			if (url.load.startsWith('blob:') || url.load.startsWith('data:')) {
				if (path.getExtension(url.original).toLowerCase() === '.glb') {
					options.responseType = Http.ResponseType.ARRAY_BUFFER;
				} else {
					options.responseType = Http.ResponseType.JSON;
				}
			}
			http.get(url.load, options, function (err, response) {
				if (!callback) return;
				if (!err) {
					for (var i = 0; i < _this._parsers.length; i++) {
						var p = _this._parsers[i];
						if (p.decider(url.original, response)) {
							p.parser.parse(response, function (err, parseResult) {
								if (err) {
									callback(err);
								} else {
									callback(null, parseResult);
								}
							}, asset);
							return;
						}
					}
					callback("No parsers found");
				} else {
					callback("Error loading model: " + url.original + " [" + err + "]");
				}
			});
		};
		_proto.open = function open(url, data) {
			return data;
		};
		_proto.patch = function patch(asset, assets) {
			if (!asset.resource) return;
			var data = asset.data;
			var self = this;
			asset.resource.meshInstances.forEach(function (meshInstance, i) {
				if (data.mapping) {
					var handleMaterial = function handleMaterial(asset) {
						if (asset.resource) {
							meshInstance.material = asset.resource;
						} else {
							asset.once('load', handleMaterial);
							assets.load(asset);
						}
						asset.once('remove', function (asset) {
							if (meshInstance.material === asset.resource) {
								meshInstance.material = self.defaultMaterial;
							}
						});
					};
					if (!data.mapping[i]) {
						meshInstance.material = self.defaultMaterial;
						return;
					}
					var id = data.mapping[i].material;
					var url = data.mapping[i].path;
					var material;
					if (id !== undefined) {
						if (!id) {
							meshInstance.material = self.defaultMaterial;
						} else {
							material = assets.get(id);
							if (material) {
								handleMaterial(material);
							} else {
								assets.once('add:' + id, handleMaterial);
							}
						}
					} else if (url) {
						var _path = asset.getAbsoluteUrl(data.mapping[i].path);
						material = assets.getByUrl(_path);
						if (material) {
							handleMaterial(material);
						} else {
							assets.once('add:url:' + _path, handleMaterial);
						}
					}
				}
			});
		};
		_proto.addParser = function addParser(parser, decider) {
			this._parsers.push({
				parser: parser,
				decider: decider
			});
		};
		return ModelHandler;
	}();

	var SceneHandler = function () {
		function SceneHandler(app) {
			this.handlerType = "scene";
			this._app = app;
			this.maxRetries = 0;
		}
		var _proto = SceneHandler.prototype;
		_proto.load = function load(url, callback) {
			SceneUtils.load(url, this.maxRetries, callback);
		};
		_proto.open = function open(url, data) {
			this._app.systems.script.preloading = true;
			var parser = new SceneParser(this._app, false);
			var parent = parser.parse(data);
			var scene = this._app.scene;
			scene.root = parent;
			this._app.applySceneSettings(data.settings);
			this._app.systems.script.preloading = false;
			return scene;
		};
		_proto.patch = function patch(asset, assets) {};
		return SceneHandler;
	}();

	var ScriptHandler = function () {
		function ScriptHandler(app) {
			this.handlerType = "script";
			this._app = app;
			this._scripts = {};
			this._cache = {};
		}
		var _proto = ScriptHandler.prototype;
		_proto.clearCache = function clearCache() {
			for (var key in this._cache) {
				var element = this._cache[key];
				var parent = element.parentNode;
				if (parent) parent.removeChild(element);
			}
			this._cache = {};
		};
		_proto.load = function load(url, callback) {
			var _this = this;
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			var self = this;
			script.app = this._app;
			this._loadScript(url.load, function (err, url, extra) {
				if (!err) {
					if (script.legacy) {
						var Type = null;
						if (ScriptTypes._types.length) {
							Type = ScriptTypes._types.pop();
						}
						if (Type) {
							_this._scripts[url] = Type;
						} else {
							Type = null;
						}
						callback(null, Type, extra);
					} else {
						var obj = {};
						for (var i = 0; i < ScriptTypes._types.length; i++) obj[ScriptTypes._types[i].name] = ScriptTypes._types[i];
						ScriptTypes._types.length = 0;
						callback(null, obj, extra);
						delete self._loader._cache[ResourceLoader.makeKey(url, 'script')];
					}
				} else {
					callback(err);
				}
			});
		};
		_proto.open = function open(url, data) {
			return data;
		};
		_proto.patch = function patch(asset, assets) {};
		_proto._loadScript = function _loadScript(url, callback) {
			var head = document.head;
			var element = document.createElement('script');
			this._cache[url] = element;
			element.async = false;
			element.addEventListener('error', function (e) {
				callback("Script: " + e.target.src + " failed to load");
			}, false);
			var done = false;
			element.onload = element.onreadystatechange = function () {
				if (!done && (!this.readyState || this.readyState === 'loaded' || this.readyState === 'complete')) {
					done = true;
					callback(null, url, element);
				}
			};
			element.src = url;
			head.appendChild(element);
		};
		return ScriptHandler;
	}();

	var ShaderHandler = function () {
		function ShaderHandler(app) {
			this.handlerType = "shader";
			this.maxRetries = 0;
		}
		var _proto = ShaderHandler.prototype;
		_proto.load = function load(url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			http.get(url.load, {
				retry: this.maxRetries > 0,
				maxRetries: this.maxRetries
			}, function (err, response) {
				if (!err) {
					callback(null, response);
				} else {
					callback("Error loading shader resource: " + url.original + " [" + err + "]");
				}
			});
		};
		_proto.open = function open(url, data) {
			return data;
		};
		_proto.patch = function patch(asset, assets) {};
		return ShaderHandler;
	}();

	function onTextureAtlasLoaded(atlasAsset) {
		var spriteAsset = this;
		if (spriteAsset.resource) {
			spriteAsset.resource.atlas = atlasAsset.resource;
		}
	}
	function onTextureAtlasAdded(atlasAsset) {
		var spriteAsset = this;
		spriteAsset.registry.load(atlasAsset);
	}
	var SpriteHandler = function () {
		function SpriteHandler(app) {
			this.handlerType = "sprite";
			this._assets = app.assets;
			this._device = app.graphicsDevice;
			this.maxRetries = 0;
		}
		var _proto = SpriteHandler.prototype;
		_proto.load = function load(url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			if (path.getExtension(url.original) === '.json') {
				http.get(url.load, {
					retry: this.maxRetries > 0,
					maxRetries: this.maxRetries
				}, function (err, response) {
					if (!err) {
						callback(null, response);
					} else {
						callback(err);
					}
				});
			}
		};
		_proto.open = function open(url, data) {
			var sprite = new Sprite(this._device);
			if (url) {
				sprite.__data = data;
			}
			return sprite;
		};
		_proto.patch = function patch(asset, assets) {
			var sprite = asset.resource;
			if (sprite.__data) {
				asset.data.pixelsPerUnit = sprite.__data.pixelsPerUnit;
				asset.data.renderMode = sprite.__data.renderMode;
				asset.data.frameKeys = sprite.__data.frameKeys;
				if (sprite.__data.textureAtlasAsset) {
					var atlas = assets.getByUrl(sprite.__data.textureAtlasAsset);
					if (atlas) {
						asset.data.textureAtlasAsset = atlas.id;
					} else {
						console.warn('Could not find textureatlas with url: ' + sprite.__data.textureAtlasAsset);
					}
				}
			}
			sprite.startUpdate();
			sprite.renderMode = asset.data.renderMode;
			sprite.pixelsPerUnit = asset.data.pixelsPerUnit;
			sprite.frameKeys = asset.data.frameKeys;
			this._updateAtlas(asset);
			sprite.endUpdate();
			asset.off('change', this._onAssetChange, this);
			asset.on('change', this._onAssetChange, this);
		};
		_proto._updateAtlas = function _updateAtlas(asset) {
			var sprite = asset.resource;
			if (!asset.data.textureAtlasAsset) {
				sprite.atlas = null;
				return;
			}
			this._assets.off('load:' + asset.data.textureAtlasAsset, onTextureAtlasLoaded, asset);
			this._assets.on('load:' + asset.data.textureAtlasAsset, onTextureAtlasLoaded, asset);
			var atlasAsset = this._assets.get(asset.data.textureAtlasAsset);
			if (atlasAsset && atlasAsset.resource) {
				sprite.atlas = atlasAsset.resource;
			} else {
				if (!atlasAsset) {
					this._assets.off('add:' + asset.data.textureAtlasAsset, onTextureAtlasAdded, asset);
					this._assets.on('add:' + asset.data.textureAtlasAsset, onTextureAtlasAdded, asset);
				} else {
					this._assets.load(atlasAsset);
				}
			}
		};
		_proto._onAssetChange = function _onAssetChange(asset, attribute, value, oldValue) {
			if (attribute === 'data') {
				if (value && value.textureAtlasAsset && oldValue && value.textureAtlasAsset !== oldValue.textureAtlasAsset) {
					this._assets.off('load:' + oldValue.textureAtlasAsset, onTextureAtlasLoaded, asset);
					this._assets.off('add:' + oldValue.textureAtlasAsset, onTextureAtlasAdded, asset);
				}
			}
		};
		return SpriteHandler;
	}();

	var Template = function () {
		function Template(app, data) {
			this._app = void 0;
			this._data = void 0;
			this._templateRoot = null;
			this._app = app;
			this._data = data;
		}
		var _proto = Template.prototype;
		_proto.instantiate = function instantiate() {
			if (!this._templateRoot) {
				this._parseTemplate();
			}
			return this._templateRoot.clone();
		};
		_proto._parseTemplate = function _parseTemplate() {
			var parser = new SceneParser(this._app, true);
			this._templateRoot = parser.parse(this._data);
		};
		return Template;
	}();

	var TemplateHandler = function () {
		function TemplateHandler(app) {
			this.handlerType = "template";
			this._app = app;
			this.maxRetries = 0;
		}
		var _proto = TemplateHandler.prototype;
		_proto.load = function load(url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			var options = {
				retry: this.maxRetries > 0,
				maxRetries: this.maxRetries
			};
			http.get(url.load, options, function (err, response) {
				if (err) {
					callback('Error requesting template: ' + url.original);
				} else {
					callback(err, response);
				}
			});
		};
		_proto.open = function open(url, data) {
			return new Template(this._app, data);
		};
		return TemplateHandler;
	}();

	var TextHandler = function () {
		function TextHandler(app) {
			this.handlerType = "text";
			this.maxRetries = 0;
		}
		var _proto = TextHandler.prototype;
		_proto.load = function load(url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			http.get(url.load, {
				retry: this.maxRetries > 0,
				maxRetries: this.maxRetries
			}, function (err, response) {
				if (!err) {
					callback(null, response);
				} else {
					callback("Error loading text resource: " + url.original + " [" + err + "]");
				}
			});
		};
		_proto.open = function open(url, data) {
			return data;
		};
		_proto.patch = function patch(asset, assets) {};
		return TextHandler;
	}();

	var JSON_ADDRESS_MODE$1 = {
		'repeat': ADDRESS_REPEAT,
		'clamp': ADDRESS_CLAMP_TO_EDGE,
		'mirror': ADDRESS_MIRRORED_REPEAT
	};
	var JSON_FILTER_MODE$1 = {
		'nearest': FILTER_NEAREST,
		'linear': FILTER_LINEAR,
		'nearest_mip_nearest': FILTER_NEAREST_MIPMAP_NEAREST,
		'linear_mip_nearest': FILTER_LINEAR_MIPMAP_NEAREST,
		'nearest_mip_linear': FILTER_NEAREST_MIPMAP_LINEAR,
		'linear_mip_linear': FILTER_LINEAR_MIPMAP_LINEAR
	};
	var regexFrame = /^data\.frames\.(\d+)$/;
	var TextureAtlasHandler = function () {
		function TextureAtlasHandler(app) {
			this.handlerType = "textureatlas";
			this._loader = app.loader;
			this.maxRetries = 0;
		}
		var _proto = TextureAtlasHandler.prototype;
		_proto.load = function load(url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			var self = this;
			var handler = this._loader.getHandler('texture');
			if (path.getExtension(url.original) === '.json') {
				http.get(url.load, {
					retry: this.maxRetries > 0,
					maxRetries: this.maxRetries
				}, function (err, response) {
					if (!err) {
						var textureUrl = url.original.replace('.json', '.png');
						self._loader.load(textureUrl, 'texture', function (err, texture) {
							if (err) {
								callback(err);
							} else {
								callback(null, {
									data: response,
									texture: texture
								});
							}
						});
					} else {
						callback(err);
					}
				});
			} else {
				handler.load(url, callback);
			}
		};
		_proto.open = function open(url, data) {
			var resource = new TextureAtlas();
			if (data.texture && data.data) {
				resource.texture = data.texture;
				resource.__data = data.data;
			} else {
				var handler = this._loader.getHandler('texture');
				var texture = handler.open(url, data);
				if (!texture) return null;
				resource.texture = texture;
			}
			return resource;
		};
		_proto.patch = function patch(asset, assets) {
			if (!asset.resource) {
				return;
			}
			if (asset.resource.__data) {
				if (asset.resource.__data.minfilter !== undefined) asset.data.minfilter = asset.resource.__data.minfilter;
				if (asset.resource.__data.magfilter !== undefined) asset.data.magfilter = asset.resource.__data.magfilter;
				if (asset.resource.__data.addressu !== undefined) asset.data.addressu = asset.resource.__data.addressu;
				if (asset.resource.__data.addressv !== undefined) asset.data.addressv = asset.resource.__data.addressv;
				if (asset.resource.__data.mipmaps !== undefined) asset.data.mipmaps = asset.resource.__data.mipmaps;
				if (asset.resource.__data.anisotropy !== undefined) asset.data.anisotropy = asset.resource.__data.anisotropy;
				if (asset.resource.__data.rgbm !== undefined) asset.data.rgbm = !!asset.resource.__data.rgbm;
				asset.data.frames = asset.resource.__data.frames;
				delete asset.resource.__data;
			}
			var texture = asset.resource.texture;
			if (texture) {
				texture.name = asset.name;
				if (asset.data.hasOwnProperty('minfilter') && texture.minFilter !== JSON_FILTER_MODE$1[asset.data.minfilter]) texture.minFilter = JSON_FILTER_MODE$1[asset.data.minfilter];
				if (asset.data.hasOwnProperty('magfilter') && texture.magFilter !== JSON_FILTER_MODE$1[asset.data.magfilter]) texture.magFilter = JSON_FILTER_MODE$1[asset.data.magfilter];
				if (asset.data.hasOwnProperty('addressu') && texture.addressU !== JSON_ADDRESS_MODE$1[asset.data.addressu]) texture.addressU = JSON_ADDRESS_MODE$1[asset.data.addressu];
				if (asset.data.hasOwnProperty('addressv') && texture.addressV !== JSON_ADDRESS_MODE$1[asset.data.addressv]) texture.addressV = JSON_ADDRESS_MODE$1[asset.data.addressv];
				if (asset.data.hasOwnProperty('mipmaps') && texture.mipmaps !== asset.data.mipmaps) texture.mipmaps = asset.data.mipmaps;
				if (asset.data.hasOwnProperty('anisotropy') && texture.anisotropy !== asset.data.anisotropy) texture.anisotropy = asset.data.anisotropy;
				if (asset.data.hasOwnProperty('rgbm')) {
					var type = asset.data.rgbm ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT;
					if (texture.type !== type) {
						texture.type = type;
					}
				}
			}
			asset.resource.texture = texture;
			var frames = {};
			for (var key in asset.data.frames) {
				var frame = asset.data.frames[key];
				frames[key] = {
					rect: new Vec4(frame.rect),
					pivot: new Vec2(frame.pivot),
					border: new Vec4(frame.border)
				};
			}
			asset.resource.frames = frames;
			asset.off('change', this._onAssetChange, this);
			asset.on('change', this._onAssetChange, this);
		};
		_proto._onAssetChange = function _onAssetChange(asset, attribute, value) {
			var frame;
			if (attribute === 'data' || attribute === 'data.frames') {
				var frames = {};
				for (var key in value.frames) {
					frame = value.frames[key];
					frames[key] = {
						rect: new Vec4(frame.rect),
						pivot: new Vec2(frame.pivot),
						border: new Vec4(frame.border)
					};
				}
				asset.resource.frames = frames;
			} else {
				var match = attribute.match(regexFrame);
				if (match) {
					var frameKey = match[1];
					if (value) {
						if (!asset.resource.frames[frameKey]) {
							asset.resource.frames[frameKey] = {
								rect: new Vec4(value.rect),
								pivot: new Vec2(value.pivot),
								border: new Vec4(value.border)
							};
						} else {
							frame = asset.resource.frames[frameKey];
							frame.rect.set(value.rect[0], value.rect[1], value.rect[2], value.rect[3]);
							frame.pivot.set(value.pivot[0], value.pivot[1]);
							frame.border.set(value.border[0], value.border[1], value.border[2], value.border[3]);
						}
						asset.resource.fire('set:frame', frameKey, asset.resource.frames[frameKey]);
					} else {
						if (asset.resource.frames[frameKey]) {
							delete asset.resource.frames[frameKey];
							asset.resource.fire('remove:frame', frameKey);
						}
					}
				}
			}
		};
		return TextureAtlasHandler;
	}();

	function BasisWorker() {
		var BASIS_FORMAT = {
			cTFETC1: 0,
			cTFETC2: 1,
			cTFBC1: 2,
			cTFBC3: 3,
			cTFPVRTC1_4_RGB: 8,
			cTFPVRTC1_4_RGBA: 9,
			cTFASTC_4x4: 10,
			cTFATC_RGB: 11,
			cTFATC_RGBA_INTERPOLATED_ALPHA: 12,
			cTFRGBA32: 13,
			cTFRGB565: 14,
			cTFRGBA4444: 16
		};
		var opaqueMapping = {
			astc: BASIS_FORMAT.cTFASTC_4x4,
			dxt: BASIS_FORMAT.cTFBC1,
			etc1: BASIS_FORMAT.cTFETC1,
			etc2: BASIS_FORMAT.cTFETC1,
			pvr: BASIS_FORMAT.cTFPVRTC1_4_RGB,
			atc: BASIS_FORMAT.cTFATC_RGB,
			none: BASIS_FORMAT.cTFRGB565
		};
		var alphaMapping = {
			astc: BASIS_FORMAT.cTFASTC_4x4,
			dxt: BASIS_FORMAT.cTFBC3,
			etc1: BASIS_FORMAT.cTFRGBA4444,
			etc2: BASIS_FORMAT.cTFETC2,
			pvr: BASIS_FORMAT.cTFPVRTC1_4_RGBA,
			atc: BASIS_FORMAT.cTFATC_RGBA_INTERPOLATED_ALPHA,
			none: BASIS_FORMAT.cTFRGBA4444
		};
		var PIXEL_FORMAT = {
			ETC1: 21,
			ETC2_RGB: 22,
			ETC2_RGBA: 23,
			DXT1: 8,
			DXT5: 10,
			PVRTC_4BPP_RGB_1: 26,
			PVRTC_4BPP_RGBA_1: 27,
			ASTC_4x4: 28,
			ATC_RGB: 29,
			ATC_RGBA: 30,
			R8_G8_B8_A8: 7,
			R5_G6_B5: 3,
			R4_G4_B4_A4: 5
		};
		var basisToEngineMapping = function basisToEngineMapping(basisFormat, deviceDetails) {
			switch (basisFormat) {
				case BASIS_FORMAT.cTFETC1:
					return deviceDetails.formats.etc1 ? PIXEL_FORMAT.ETC1 : PIXEL_FORMAT.ETC2_RGB;
				case BASIS_FORMAT.cTFETC2:
					return PIXEL_FORMAT.ETC2_RGBA;
				case BASIS_FORMAT.cTFBC1:
					return PIXEL_FORMAT.DXT1;
				case BASIS_FORMAT.cTFBC3:
					return PIXEL_FORMAT.DXT5;
				case BASIS_FORMAT.cTFPVRTC1_4_RGB:
					return PIXEL_FORMAT.PVRTC_4BPP_RGB_1;
				case BASIS_FORMAT.cTFPVRTC1_4_RGBA:
					return PIXEL_FORMAT.PVRTC_4BPP_RGBA_1;
				case BASIS_FORMAT.cTFASTC_4x4:
					return PIXEL_FORMAT.ASTC_4x4;
				case BASIS_FORMAT.cTFATC_RGB:
					return PIXEL_FORMAT.ATC_RGB;
				case BASIS_FORMAT.cTFATC_RGBA_INTERPOLATED_ALPHA:
					return PIXEL_FORMAT.ATC_RGBA;
				case BASIS_FORMAT.cTFRGBA32:
					return PIXEL_FORMAT.R8_G8_B8_A8;
				case BASIS_FORMAT.cTFRGB565:
					return PIXEL_FORMAT.R5_G6_B5;
				case BASIS_FORMAT.cTFRGBA4444:
					return PIXEL_FORMAT.R4_G4_B4_A4;
			}
		};
		var unswizzleGGGR = function unswizzleGGGR(data) {
			var genB = function genB(R, G) {
				var r = R * (2.0 / 255.0) - 1.0;
				var g = G * (2.0 / 255.0) - 1.0;
				var b = Math.sqrt(1.0 - Math.min(1.0, r * r + g * g));
				return Math.max(0, Math.min(255, Math.floor((b + 1.0) * 0.5 * 255.0)));
			};
			for (var offset = 0; offset < data.length; offset += 4) {
				var R = data[offset + 3];
				var G = data[offset + 1];
				data[offset + 0] = R;
				data[offset + 2] = genB(R, G);
				data[offset + 3] = 255;
			}
			return data;
		};
		var pack565 = function pack565(data) {
			var result = new Uint16Array(data.length / 4);
			for (var offset = 0; offset < data.length; offset += 4) {
				var R = data[offset + 0];
				var G = data[offset + 1];
				var B = data[offset + 2];
				result[offset / 4] = (R & 0xf8) << 8 | (G & 0xfc) << 3 | B >> 3;
			}
			return result;
		};
		var isPOT = function isPOT(width, height) {
			return (width & width - 1) === 0 && (height & height - 1) === 0;
		};
		var performanceNow = function performanceNow() {
			return typeof performance !== 'undefined' ? performance.now() : 0;
		};
		var basis;
		var rgbPriority;
		var rgbaPriority;
		var chooseTargetFormat = function chooseTargetFormat(deviceDetails, hasAlpha, isUASTC) {
			if (isUASTC) {
				if (deviceDetails.formats.astc) {
					return 'astc';
				}
			} else {
				if (hasAlpha) {
					if (deviceDetails.formats.etc2) {
						return 'etc2';
					}
				} else {
					if (deviceDetails.formats.etc1 || deviceDetails.formats.etc2) {
						return 'etc1';
					}
				}
			}
			var testInOrder = function testInOrder(priority) {
				for (var i = 0; i < priority.length; ++i) {
					var format = priority[i];
					if (deviceDetails.formats[format]) {
						return format;
					}
				}
				return 'none';
			};
			return testInOrder(hasAlpha ? rgbaPriority : rgbPriority);
		};
		var dimensionsValid = function dimensionsValid(width, height, format, webgl2) {
			switch (format) {
				case BASIS_FORMAT.cTFETC1:
				case BASIS_FORMAT.cTFETC2:
					return true;
				case BASIS_FORMAT.cTFBC1:
				case BASIS_FORMAT.cTFBC3:
					return (width & 0x3) === 0 && (height & 0x3) === 0;
				case BASIS_FORMAT.cTFPVRTC1_4_RGB:
				case BASIS_FORMAT.cTFPVRTC1_4_RGBA:
					return isPOT(width, height) && (width === height || webgl2);
				case BASIS_FORMAT.cTFASTC_4x4:
					return true;
				case BASIS_FORMAT.cTFATC_RGB:
				case BASIS_FORMAT.cTFATC_RGBA_INTERPOLATED_ALPHA:
					return true;
			}
			return false;
		};
		var transcodeKTX2 = function transcodeKTX2(url, data, options) {
			if (!basis.KTX2File) {
				throw new Error('Basis transcoder module does not include support for KTX2.');
			}
			var funcStart = performanceNow();
			var basisFile = new basis.KTX2File(new Uint8Array(data));
			var width = basisFile.getWidth();
			var height = basisFile.getHeight();
			var levels = basisFile.getLevels();
			var hasAlpha = !!basisFile.getHasAlpha();
			var isUASTC = basisFile.isUASTC && basisFile.isUASTC();
			if (!width || !height || !levels) {
				basisFile.close();
				basisFile.delete();
				throw new Error("Invalid image dimensions url=" + url + " width=" + width + " height=" + height + " levels=" + levels);
			}
			var format = chooseTargetFormat(options.deviceDetails, hasAlpha, isUASTC);
			var unswizzle = !!options.isGGGR && format === 'pvr';
			var basisFormat;
			if (unswizzle) {
				basisFormat = BASIS_FORMAT.cTFRGBA32;
			} else {
				basisFormat = hasAlpha ? alphaMapping[format] : opaqueMapping[format];
				if (!dimensionsValid(width, height, basisFormat, options.deviceDetails.webgl2)) {
					basisFormat = hasAlpha ? BASIS_FORMAT.cTFRGBA32 : BASIS_FORMAT.cTFRGB565;
				}
			}
			if (!basisFile.startTranscoding()) {
				basisFile.close();
				basisFile.delete();
				throw new Error('Failed to start transcoding url=' + url);
			}
			var i;
			var levelData = [];
			for (var mip = 0; mip < levels; ++mip) {
				var dstSize = basisFile.getImageTranscodedSizeInBytes(mip, 0, 0, basisFormat);
				var dst = new Uint8Array(dstSize);
				if (!basisFile.transcodeImage(dst, mip, 0, 0, basisFormat, 0, -1, -1)) {
					basisFile.close();
					basisFile.delete();
					throw new Error('Failed to transcode image url=' + url);
				}
				var is16BitFormat = basisFormat === BASIS_FORMAT.cTFRGB565 || basisFormat === BASIS_FORMAT.cTFRGBA4444;
				levelData.push(is16BitFormat ? new Uint16Array(dst.buffer) : dst);
			}
			basisFile.close();
			basisFile.delete();
			if (unswizzle) {
				basisFormat = BASIS_FORMAT.cTFRGB565;
				for (i = 0; i < levelData.length; ++i) {
					levelData[i] = pack565(unswizzleGGGR(levelData[i]));
				}
			}
			return {
				format: basisToEngineMapping(basisFormat, options.deviceDetails),
				width: width,
				height: height,
				levels: levelData,
				cubemap: false,
				transcodeTime: performanceNow() - funcStart,
				url: url,
				unswizzledGGGR: unswizzle
			};
		};
		var transcodeBasis = function transcodeBasis(url, data, options) {
			var funcStart = performanceNow();
			var basisFile = new basis.BasisFile(new Uint8Array(data));
			var width = basisFile.getImageWidth(0, 0);
			var height = basisFile.getImageHeight(0, 0);
			var images = basisFile.getNumImages();
			var levels = basisFile.getNumLevels(0);
			var hasAlpha = !!basisFile.getHasAlpha();
			var isUASTC = basisFile.isUASTC && basisFile.isUASTC();
			if (!width || !height || !images || !levels) {
				basisFile.close();
				basisFile.delete();
				throw new Error("Invalid image dimensions url=" + url + " width=" + width + " height=" + height + " images=" + images + " levels=" + levels);
			}
			var format = chooseTargetFormat(options.deviceDetails, hasAlpha, isUASTC);
			var unswizzle = !!options.isGGGR && format === 'pvr';
			var basisFormat;
			if (unswizzle) {
				basisFormat = BASIS_FORMAT.cTFRGBA32;
			} else {
				basisFormat = hasAlpha ? alphaMapping[format] : opaqueMapping[format];
				if (!dimensionsValid(width, height, basisFormat, options.deviceDetails.webgl2)) {
					basisFormat = hasAlpha ? BASIS_FORMAT.cTFRGBA32 : BASIS_FORMAT.cTFRGB565;
				}
			}
			if (!basisFile.startTranscoding()) {
				basisFile.close();
				basisFile.delete();
				throw new Error('Failed to start transcoding url=' + url);
			}
			var i;
			var levelData = [];
			for (var mip = 0; mip < levels; ++mip) {
				var dstSize = basisFile.getImageTranscodedSizeInBytes(0, mip, basisFormat);
				var dst = new Uint8Array(dstSize);
				if (!basisFile.transcodeImage(dst, 0, mip, basisFormat, 0, 0)) {
					if (mip === levels - 1 && dstSize === levelData[mip - 1].buffer.byteLength) {
						dst.set(new Uint8Array(levelData[mip - 1].buffer));
						console.warn('Failed to transcode last mipmap level, using previous level instead url=' + url);
					} else {
						basisFile.close();
						basisFile.delete();
						throw new Error('Failed to transcode image url=' + url);
					}
				}
				var is16BitFormat = basisFormat === BASIS_FORMAT.cTFRGB565 || basisFormat === BASIS_FORMAT.cTFRGBA4444;
				levelData.push(is16BitFormat ? new Uint16Array(dst.buffer) : dst);
			}
			basisFile.close();
			basisFile.delete();
			if (unswizzle) {
				basisFormat = BASIS_FORMAT.cTFRGB565;
				for (i = 0; i < levelData.length; ++i) {
					levelData[i] = pack565(unswizzleGGGR(levelData[i]));
				}
			}
			return {
				format: basisToEngineMapping(basisFormat, options.deviceDetails),
				width: width,
				height: height,
				levels: levelData,
				cubemap: false,
				transcodeTime: performanceNow() - funcStart,
				url: url,
				unswizzledGGGR: unswizzle
			};
		};
		var transcode = function transcode(url, data, options) {
			return options.isKTX2 ? transcodeKTX2(url, data, options) : transcodeBasis(url, data, options);
		};
		var workerTranscode = function workerTranscode(url, data, options) {
			try {
				var result = transcode(url, data, options);
				result.levels = result.levels.map(function (v) {
					return v.buffer;
				});
				self.postMessage({
					url: url,
					data: result
				}, result.levels);
			} catch (err) {
				self.postMessage({
					url: url,
					err: err
				}, null);
			}
		};
		var workerInit = function workerInit(config, callback) {
			var instantiateWasmFunc = function instantiateWasmFunc(imports, successCallback) {
				WebAssembly.instantiate(config.module, imports).then(function (result) {
					successCallback(result);
				}).catch(function (reason) {
					console.error('instantiate failed + ' + reason);
				});
				return {};
			};
			self.BASIS(config.module ? {
				instantiateWasm: instantiateWasmFunc
			} : null).then(function (instance) {
				instance.initializeBasis();
				basis = instance;
				rgbPriority = config.rgbPriority;
				rgbaPriority = config.rgbaPriority;
				callback(null);
			});
		};
		var queue = [];
		self.onmessage = function (message) {
			var data = message.data;
			switch (data.type) {
				case 'init':
					workerInit(data.config, function () {
						for (var i = 0; i < queue.length; ++i) {
							workerTranscode(queue[i].url, queue[i].data, queue[i].options);
						}
						queue.length = 0;
					});
					break;
				case 'transcode':
					if (basis) {
						workerTranscode(data.url, data.data, data.options);
					} else {
						queue.push(data);
					}
					break;
			}
		};
	}

	var getCompressionFormats = function getCompressionFormats(device) {
		return {
			astc: !!device.extCompressedTextureASTC,
			atc: !!device.extCompressedTextureATC,
			dxt: !!device.extCompressedTextureS3TC,
			etc1: !!device.extCompressedTextureETC1,
			etc2: !!device.extCompressedTextureETC,
			pvr: !!device.extCompressedTexturePVRTC
		};
	};
	var prepareWorkerModules = function prepareWorkerModules(config, callback) {
		var getWorkerBlob = function getWorkerBlob(basisCode) {
			var code = ['/* basis */', basisCode, "", '(' + BasisWorker.toString() + ')()\n\n'].join('\n');
			return new Blob([code], {
				type: 'application/javascript'
			});
		};
		var wasmSupported = function wasmSupported() {
			try {
				if (typeof WebAssembly === 'object' && typeof WebAssembly.instantiate === 'function') {
					var module = new WebAssembly.Module(Uint8Array.of(0x0, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00));
					if (module instanceof WebAssembly.Module) return new WebAssembly.Instance(module) instanceof WebAssembly.Instance;
				}
			} catch (e) {}
			return false;
		};
		var sendResponse = function sendResponse(basisCode, module) {
			callback(null, {
				workerUrl: URL.createObjectURL(getWorkerBlob(basisCode)),
				module: module,
				rgbPriority: config.rgbPriority,
				rgbaPriority: config.rgbaPriority
			});
		};
		var options = {
			cache: true,
			responseType: 'text',
			retry: config.maxRetries > 0,
			maxRetries: config.maxRetries
		};
		if (config.glueUrl && config.wasmUrl && wasmSupported()) {
			var basisCode = null;
			var module = null;
			http.get(config.glueUrl, options, function (err, response) {
				if (err) {
					callback(err);
				} else {
					if (module) {
						sendResponse(response, module);
					} else {
						basisCode = response;
					}
				}
			});
			var fetchPromise = fetch(config.wasmUrl);
			var compileManual = function compileManual() {
				fetchPromise.then(function (result) {
					return result.arrayBuffer();
				}).then(function (buffer) {
					return WebAssembly.compile(buffer);
				}).then(function (module_) {
					if (basisCode) {
						sendResponse(basisCode, module_);
					} else {
						module = module_;
					}
				}).catch(function (err) {
					callback(err, null);
				});
			};
			if (WebAssembly.compileStreaming) {
				WebAssembly.compileStreaming(fetchPromise).then(function (module_) {
					if (basisCode) {
						sendResponse(basisCode, module_);
					} else {
						module = module_;
					}
				}).catch(function (err) {
					compileManual();
				});
			} else {
				compileManual();
			}
		} else {
			http.get(config.fallbackUrl, options, function (err, response) {
				if (err) {
					callback(err, null);
				} else {
					sendResponse(response, null);
				}
			});
		}
	};
	var BasisQueue = function () {
		function BasisQueue() {
			this.callbacks = {};
			this.queue = [];
			this.clients = [];
		}
		var _proto = BasisQueue.prototype;
		_proto.enqueueJob = function enqueueJob(url, data, callback, options) {
			if (this.callbacks.hasOwnProperty(url)) {
				this.callbacks[url].push(callback);
			} else {
				this.callbacks[url] = [callback];
				var job = {
					url: url,
					data: data,
					options: options
				};
				if (this.clients.length > 0) {
					this.clients.shift().run(job);
				} else {
					this.queue.push(job);
				}
			}
		};
		_proto.enqueueClient = function enqueueClient(client) {
			if (this.queue.length > 0) {
				client.run(this.queue.shift());
			} else {
				this.clients.push(client);
			}
		};
		_proto.handleResponse = function handleResponse(url, err, data) {
			var callback = this.callbacks[url];
			if (err) {
				for (var i = 0; i < callback.length; ++i) {
					callback[i](err);
				}
			} else {
				if (data.format === PIXELFORMAT_RGB565 || data.format === PIXELFORMAT_RGBA4) {
					data.levels = data.levels.map(function (v) {
						return new Uint16Array(v);
					});
				} else {
					data.levels = data.levels.map(function (v) {
						return new Uint8Array(v);
					});
				}
				for (var _i = 0; _i < callback.length; ++_i) {
					callback[_i](null, data);
				}
			}
			delete this.callbacks[url];
		};
		return BasisQueue;
	}();
	var BasisClient = function () {
		function BasisClient(queue, config, eager) {
			var _this = this;
			this.queue = queue;
			this.worker = new Worker(config.workerUrl);
			this.worker.addEventListener('message', function (message) {
				var data = message.data;
				_this.queue.handleResponse(data.url, data.err, data.data);
				if (!_this.eager) {
					_this.queue.enqueueClient(_this);
				}
			});
			this.worker.postMessage({
				type: 'init',
				config: config
			});
			this.eager = eager;
		}
		var _proto2 = BasisClient.prototype;
		_proto2.run = function run(job) {
			var transfer = [];
			if (job.data instanceof ArrayBuffer) {
				transfer.push(job.data);
			}
			this.worker.postMessage({
				type: 'transcode',
				url: job.url,
				format: job.format,
				data: job.data,
				options: job.options
			}, transfer);
			if (this.eager) {
				this.queue.enqueueClient(this);
			}
		};
		return BasisClient;
	}();
	var defaultNumWorkers = 1;
	var defaultRgbPriority = ['etc1', 'etc2', 'astc', 'dxt', 'pvr', 'atc'];
	var defaultRgbaPriority = ['astc', 'dxt', 'etc2', 'pvr', 'atc'];
	var defaultMaxRetries = 5;
	var queue = new BasisQueue();
	var lazyConfig = null;
	var initializing = false;
	function basisInitialize(config) {
		if (initializing) {
			return;
		}
		if (!config) {
			config = lazyConfig || {};
		} else if (config.lazyInit) {
			lazyConfig = config;
			return;
		}
		if (!config.glueUrl || !config.wasmUrl || !config.fallbackUrl) {
			var moduleConfig = WasmModule.getConfig('BASIS');
			if (moduleConfig) {
				config = {
					glueUrl: moduleConfig.glueUrl,
					wasmUrl: moduleConfig.wasmUrl,
					fallbackUrl: moduleConfig.fallbackUrl,
					numWorkers: moduleConfig.numWorkers
				};
			}
		}
		if (config.glueUrl || config.wasmUrl || config.fallbackUrl) {
			initializing = true;
			var numWorkers = Math.max(1, Math.min(16, config.numWorkers || defaultNumWorkers));
			var eagerWorkers = config.numWorkers === 1 || (config.hasOwnProperty('eagerWorkers') ? config.eagerWorkers : true);
			config.rgbPriority = config.rgbPriority || defaultRgbPriority;
			config.rgbaPriority = config.rgbaPriority || defaultRgbaPriority;
			config.maxRetries = config.hasOwnProperty('maxRetries') ? config.maxRetries : defaultMaxRetries;
			prepareWorkerModules(config, function (err, clientConfig) {
				if (err) {
					console.error("failed to initialize basis worker: " + err);
				} else {
					for (var i = 0; i < numWorkers; ++i) {
						queue.enqueueClient(new BasisClient(queue, clientConfig, eagerWorkers));
					}
				}
			});
		}
	}
	var deviceDetails = null;
	function basisTranscode(device, url, data, callback, options) {
		basisInitialize();
		if (!deviceDetails) {
			deviceDetails = {
				webgl2: device.isWebGL2,
				formats: getCompressionFormats(device)
			};
		}
		queue.enqueueJob(url, data, callback, {
			deviceDetails: deviceDetails,
			isGGGR: !!(options != null && options.isGGGR),
			isKTX2: !!(options != null && options.isKTX2)
		});
		return initializing;
	}

	var BasisParser = function () {
		function BasisParser(registry, device) {
			this.device = device;
			this.maxRetries = 0;
		}
		var _proto = BasisParser.prototype;
		_proto.load = function load(url, callback, asset) {
			var device = this.device;
			var transcode = function transcode(data) {
				var _asset$file;
				var basisModuleFound = basisTranscode(device, url.load, data, callback, {
					isGGGR: ((asset == null || (_asset$file = asset.file) == null || (_asset$file = _asset$file.variants) == null || (_asset$file = _asset$file.basis) == null ? void 0 : _asset$file.opt) & 8) !== 0
				});
				if (!basisModuleFound) {
					callback("Basis module not found. Asset '" + asset.name + "' basis texture variant will not be loaded.");
				}
			};
			Asset.fetchArrayBuffer(url.load, function (err, result) {
				if (err) {
					callback(err);
				} else {
					transcode(result);
				}
			}, asset, this.maxRetries);
		};
		_proto.open = function open(url, data, device, textureOptions) {
			if (textureOptions === void 0) {
				textureOptions = {};
			}
			var texture = new Texture(device, _extends({
				name: url,
				addressU: data.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
				addressV: data.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
				width: data.width,
				height: data.height,
				format: data.format,
				cubemap: data.cubemap,
				levels: data.levels
			}, textureOptions));
			texture.upload();
			return texture;
		};
		return BasisParser;
	}();

	var ImgParser = function () {
		function ImgParser(registry, device) {
			this.crossOrigin = registry.prefix ? 'anonymous' : null;
			this.maxRetries = 0;
			this.device = device;
		}
		var _proto = ImgParser.prototype;
		_proto.load = function load(url, callback, asset) {
			var _asset$file;
			var hasContents = !!(asset != null && (_asset$file = asset.file) != null && _asset$file.contents);
			if (hasContents) {
				if (this.device.supportsImageBitmap) {
					this._loadImageBitmapFromBlob(new Blob([asset.file.contents]), callback);
					return;
				}
				url = {
					load: URL.createObjectURL(new Blob([asset.file.contents])),
					original: url.original
				};
			}
			var handler = function handler(err, result) {
				if (hasContents) {
					URL.revokeObjectURL(url.load);
				}
				callback(err, result);
			};
			var crossOrigin;
			if (asset && asset.options && asset.options.hasOwnProperty('crossOrigin')) {
				crossOrigin = asset.options.crossOrigin;
			} else if (ABSOLUTE_URL.test(url.load)) {
				crossOrigin = this.crossOrigin;
			}
			if (this.device.supportsImageBitmap) {
				this._loadImageBitmap(url.load, url.original, crossOrigin, handler);
			} else {
				this._loadImage(url.load, url.original, crossOrigin, handler);
			}
		};
		_proto.open = function open(url, data, device, textureOptions) {
			if (textureOptions === void 0) {
				textureOptions = {};
			}
			var texture = new Texture(device, _extends({
				name: url,
				width: data.width,
				height: data.height,
				format: PIXELFORMAT_RGBA8
			}, textureOptions));
			texture.setSource(data);
			return texture;
		};
		_proto._loadImage = function _loadImage(url, originalUrl, crossOrigin, callback) {
			var image = new Image();
			if (crossOrigin) {
				image.crossOrigin = crossOrigin;
			}
			var retries = 0;
			var maxRetries = this.maxRetries;
			var retryTimeout;
			image.onload = function () {
				callback(null, image);
			};
			image.onerror = function () {
				if (retryTimeout) return;
				if (maxRetries > 0 && ++retries <= maxRetries) {
					var retryDelay = Math.pow(2, retries) * 100;
					console.log("Error loading Texture from: '" + originalUrl + "' - Retrying in " + retryDelay + "ms...");
					var idx = url.indexOf('?');
					var separator = idx >= 0 ? '&' : '?';
					retryTimeout = setTimeout(function () {
						image.src = url + separator + 'retry=' + Date.now();
						retryTimeout = null;
					}, retryDelay);
				} else {
					callback("Error loading Texture from: '" + originalUrl + "'");
				}
			};
			image.src = url;
		};
		_proto._loadImageBitmap = function _loadImageBitmap(url, originalUrl, crossOrigin, callback) {
			var _this = this;
			var options = {
				cache: true,
				responseType: 'blob',
				retry: this.maxRetries > 0,
				maxRetries: this.maxRetries
			};
			http.get(url, options, function (err, blob) {
				if (err) {
					callback(err);
				} else {
					_this._loadImageBitmapFromBlob(blob, callback);
				}
			});
		};
		_proto._loadImageBitmapFromBlob = function _loadImageBitmapFromBlob(blob, callback) {
			createImageBitmap(blob, {
				premultiplyAlpha: 'none',
				colorSpaceConversion: 'none'
			}).then(function (imageBitmap) {
				return callback(null, imageBitmap);
			}).catch(function (e) {
				return callback(e);
			});
		};
		return ImgParser;
	}();

	var IDENTIFIER = [0x58544BAB, 0xBB313120, 0x0A1A0A0D];
	var KNOWN_FORMATS = {
		0x83F0: PIXELFORMAT_DXT1,
		0x83F2: PIXELFORMAT_DXT3,
		0x83F3: PIXELFORMAT_DXT5,
		0x8D64: PIXELFORMAT_ETC1,
		0x9274: PIXELFORMAT_ETC2_RGB,
		0x9278: PIXELFORMAT_ETC2_RGBA,
		0x8C00: PIXELFORMAT_PVRTC_4BPP_RGB_1,
		0x8C01: PIXELFORMAT_PVRTC_2BPP_RGB_1,
		0x8C02: PIXELFORMAT_PVRTC_4BPP_RGBA_1,
		0x8C03: PIXELFORMAT_PVRTC_2BPP_RGBA_1,
		0x8051: PIXELFORMAT_RGB8,
		0x8058: PIXELFORMAT_RGBA8,
		0x8C41: PIXELFORMAT_SRGB,
		0x8C43: PIXELFORMAT_SRGBA,
		0x8C3A: PIXELFORMAT_111110F,
		0x881B: PIXELFORMAT_RGB16F,
		0x881A: PIXELFORMAT_RGBA16F
	};
	function createContainer(pixelFormat, buffer, byteOffset, byteSize) {
		return pixelFormat === PIXELFORMAT_111110F ? new Uint32Array(buffer, byteOffset, byteSize / 4) : new Uint8Array(buffer, byteOffset, byteSize);
	}
	var KtxParser = function () {
		function KtxParser(registry) {
			this.maxRetries = 0;
		}
		var _proto = KtxParser.prototype;
		_proto.load = function load(url, callback, asset) {
			Asset.fetchArrayBuffer(url.load, callback, asset, this.maxRetries);
		};
		_proto.open = function open(url, data, device, textureOptions) {
			if (textureOptions === void 0) {
				textureOptions = {};
			}
			var textureData = this.parse(data);
			if (!textureData) {
				return null;
			}
			var texture = new Texture(device, _extends({
				name: url,
				addressU: textureData.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
				addressV: textureData.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
				width: textureData.width,
				height: textureData.height,
				format: textureData.format,
				cubemap: textureData.cubemap,
				levels: textureData.levels
			}, textureOptions));
			texture.upload();
			return texture;
		};
		_proto.parse = function parse(data) {
			var dataU32 = new Uint32Array(data);
			if (IDENTIFIER[0] !== dataU32[0] || IDENTIFIER[1] !== dataU32[1] || IDENTIFIER[2] !== dataU32[2]) {
				return null;
			}
			var header = {
				endianness: dataU32[3],
				glType: dataU32[4],
				glTypeSize: dataU32[5],
				glFormat: dataU32[6],
				glInternalFormat: dataU32[7],
				glBaseInternalFormat: dataU32[8],
				pixelWidth: dataU32[9],
				pixelHeight: dataU32[10],
				pixelDepth: dataU32[11],
				numberOfArrayElements: dataU32[12],
				numberOfFaces: dataU32[13],
				numberOfMipmapLevels: dataU32[14],
				bytesOfKeyValueData: dataU32[15]
			};
			if (header.pixelDepth > 1) {
				return null;
			}
			if (header.numberOfArrayElements !== 0) {
				return null;
			}
			var format = KNOWN_FORMATS[header.glInternalFormat];
			if (format === undefined) {
				return null;
			}
			var offset = 16 + header.bytesOfKeyValueData / 4;
			var isCubemap = header.numberOfFaces > 1;
			var levels = [];
			for (var mipmapLevel = 0; mipmapLevel < (header.numberOfMipmapLevels || 1); mipmapLevel++) {
				var imageSizeInBytes = dataU32[offset++];
				if (isCubemap) {
					levels.push([]);
				}
				var target = isCubemap ? levels[mipmapLevel] : levels;
				for (var face = 0; face < (isCubemap ? 6 : 1); ++face) {
					target.push(createContainer(format, data, offset * 4, imageSizeInBytes));
					offset += imageSizeInBytes + 3 >> 2;
				}
			}
			return {
				format: format,
				width: header.pixelWidth,
				height: header.pixelHeight,
				levels: levels,
				cubemap: isCubemap
			};
		};
		return KtxParser;
	}();

	var KHRConstants = {
		KHR_DF_MODEL_ETC1S: 163,
		KHR_DF_MODEL_UASTC: 166
	};
	var Ktx2Parser = function () {
		function Ktx2Parser(registry, device) {
			this.maxRetries = 0;
			this.device = device;
		}
		var _proto = Ktx2Parser.prototype;
		_proto.load = function load(url, callback, asset) {
			var _this = this;
			Asset.fetchArrayBuffer(url.load, function (err, result) {
				if (err) {
					callback(err, result);
				} else {
					_this.parse(result, url, callback, asset);
				}
			}, asset, this.maxRetries);
		};
		_proto.open = function open(url, data, device, textureOptions) {
			if (textureOptions === void 0) {
				textureOptions = {};
			}
			var texture = new Texture(device, _extends({
				name: url,
				addressU: data.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
				addressV: data.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
				width: data.width,
				height: data.height,
				format: data.format,
				cubemap: data.cubemap,
				levels: data.levels
			}, textureOptions));
			texture.upload();
			return texture;
		};
		_proto.parse = function parse(arraybuffer, url, callback, asset) {
			var rs = new ReadStream(arraybuffer);
			var magic = [rs.readU32be(), rs.readU32be(), rs.readU32be()];
			if (magic[0] !== 0xAB4B5458 || magic[1] !== 0x203230BB || magic[2] !== 0x0D0A1A0A) {
				return null;
			}
			var header = {
				vkFormat: rs.readU32(),
				typeSize: rs.readU32(),
				pixelWidth: rs.readU32(),
				pixelHeight: rs.readU32(),
				pixelDepth: rs.readU32(),
				layerCount: rs.readU32(),
				faceCount: rs.readU32(),
				levelCount: rs.readU32(),
				supercompressionScheme: rs.readU32()
			};
			var index = {
				dfdByteOffset: rs.readU32(),
				dfdByteLength: rs.readU32(),
				kvdByteOffset: rs.readU32(),
				kvdByteLength: rs.readU32(),
				sgdByteOffset: rs.readU64(),
				sgdByteLength: rs.readU64()
			};
			var levels = [];
			for (var i = 0; i < Math.max(1, header.levelCount); ++i) {
				levels.push({
					byteOffset: rs.readU64(),
					byteLength: rs.readU64(),
					uncompressedByteLength: rs.readU64()
				});
			}
			var dfdTotalSize = rs.readU32();
			if (dfdTotalSize !== index.kvdByteOffset - index.dfdByteOffset) {
				return null;
			}
			rs.skip(8);
			var colorModel = rs.readU8();
			rs.skip(index.dfdByteLength - 9);
			rs.skip(index.kvdByteLength);
			if (header.supercompressionScheme === 1 || colorModel === KHRConstants.KHR_DF_MODEL_UASTC) {
				var _asset$file;
				var basisModuleFound = basisTranscode(this.device, url.load, arraybuffer, callback, {
					isGGGR: ((asset == null || (_asset$file = asset.file) == null || (_asset$file = _asset$file.variants) == null || (_asset$file = _asset$file.basis) == null ? void 0 : _asset$file.opt) & 8) !== 0,
					isKTX2: true
				});
				if (!basisModuleFound) {
					callback('Basis module not found. Asset "' + asset.name + '" basis texture variant will not be loaded.');
				}
			} else {
				callback('unsupported KTX2 pixel format');
			}
		};
		return Ktx2Parser;
	}();

	var DdsParser = function () {
		function DdsParser(registry) {
			this.maxRetries = 0;
		}
		var _proto = DdsParser.prototype;
		_proto.load = function load(url, callback, asset) {
			Asset.fetchArrayBuffer(url.load, callback, asset, this.maxRetries);
		};
		_proto.open = function open(url, data, device, textureOptions) {
			if (textureOptions === void 0) {
				textureOptions = {};
			}
			var header = new Uint32Array(data, 0, 128 / 4);
			var width = header[4];
			var height = header[3];
			var mips = Math.max(header[7], 1);
			var isFourCc = header[20] === 4;
			var fcc = header[21];
			var bpp = header[22];
			var isCubemap = header[28] === 65024;
			var FCC_DXT1 = 827611204;
			var FCC_DXT5 = 894720068;
			var FCC_FP16 = 113;
			var FCC_FP32 = 116;
			var FCC_ETC1 = 826496069;
			var FCC_PVRTC_2BPP_RGB_1 = 825438800;
			var FCC_PVRTC_2BPP_RGBA_1 = 825504336;
			var FCC_PVRTC_4BPP_RGB_1 = 825439312;
			var FCC_PVRTC_4BPP_RGBA_1 = 825504848;
			var compressed = false;
			var etc1 = false;
			var pvrtc2 = false;
			var pvrtc4 = false;
			var format = null;
			var componentSize = 1;
			var texture;
			if (isFourCc) {
				if (fcc === FCC_DXT1) {
					format = PIXELFORMAT_DXT1;
					compressed = true;
				} else if (fcc === FCC_DXT5) {
					format = PIXELFORMAT_DXT5;
					compressed = true;
				} else if (fcc === FCC_FP16) {
					format = PIXELFORMAT_RGBA16F;
					componentSize = 2;
				} else if (fcc === FCC_FP32) {
					format = PIXELFORMAT_RGBA32F;
					componentSize = 4;
				} else if (fcc === FCC_ETC1) {
					format = PIXELFORMAT_ETC1;
					compressed = true;
					etc1 = true;
				} else if (fcc === FCC_PVRTC_2BPP_RGB_1 || fcc === FCC_PVRTC_2BPP_RGBA_1) {
					format = fcc === FCC_PVRTC_2BPP_RGB_1 ? PIXELFORMAT_PVRTC_2BPP_RGB_1 : PIXELFORMAT_PVRTC_2BPP_RGBA_1;
					compressed = true;
					pvrtc2 = true;
				} else if (fcc === FCC_PVRTC_4BPP_RGB_1 || fcc === FCC_PVRTC_4BPP_RGBA_1) {
					format = fcc === FCC_PVRTC_4BPP_RGB_1 ? PIXELFORMAT_PVRTC_4BPP_RGB_1 : PIXELFORMAT_PVRTC_4BPP_RGBA_1;
					compressed = true;
					pvrtc4 = true;
				}
			} else {
				if (bpp === 32) {
					format = PIXELFORMAT_RGBA8;
				}
			}
			if (!format) {
				texture = new Texture(device, {
					width: 4,
					height: 4,
					format: PIXELFORMAT_RGB8,
					name: 'dds-legacy-empty'
				});
				return texture;
			}
			texture = new Texture(device, _extends({
				name: url,
				addressU: isCubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
				addressV: isCubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
				width: width,
				height: height,
				format: format,
				cubemap: isCubemap,
				mipmaps: mips > 1
			}, textureOptions));
			var offset = 128;
			var faces = isCubemap ? 6 : 1;
			var mipSize;
			var DXT_BLOCK_WIDTH = 4;
			var DXT_BLOCK_HEIGHT = 4;
			var blockSize = fcc === FCC_DXT1 ? 8 : 16;
			var numBlocksAcross, numBlocksDown, numBlocks;
			for (var face = 0; face < faces; face++) {
				var mipWidth = width;
				var mipHeight = height;
				for (var i = 0; i < mips; i++) {
					if (compressed) {
						if (etc1) {
							mipSize = Math.floor((mipWidth + 3) / 4) * Math.floor((mipHeight + 3) / 4) * 8;
						} else if (pvrtc2) {
							mipSize = Math.max(mipWidth, 16) * Math.max(mipHeight, 8) / 4;
						} else if (pvrtc4) {
							mipSize = Math.max(mipWidth, 8) * Math.max(mipHeight, 8) / 2;
						} else {
							numBlocksAcross = Math.floor((mipWidth + DXT_BLOCK_WIDTH - 1) / DXT_BLOCK_WIDTH);
							numBlocksDown = Math.floor((mipHeight + DXT_BLOCK_HEIGHT - 1) / DXT_BLOCK_HEIGHT);
							numBlocks = numBlocksAcross * numBlocksDown;
							mipSize = numBlocks * blockSize;
						}
					} else {
						mipSize = mipWidth * mipHeight * 4;
					}
					var mipBuff = format === PIXELFORMAT_RGBA32F ? new Float32Array(data, offset, mipSize) : format === PIXELFORMAT_RGBA16F ? new Uint16Array(data, offset, mipSize) : new Uint8Array(data, offset, mipSize);
					if (!isCubemap) {
						texture._levels[i] = mipBuff;
					} else {
						if (!texture._levels[i]) texture._levels[i] = [];
						texture._levels[i][face] = mipBuff;
					}
					offset += mipSize * componentSize;
					mipWidth = Math.max(mipWidth * 0.5, 1);
					mipHeight = Math.max(mipHeight * 0.5, 1);
				}
			}
			texture.upload();
			return texture;
		};
		return DdsParser;
	}();

	var HdrParser = function () {
		function HdrParser(registry) {
			this.maxRetries = 0;
		}
		var _proto = HdrParser.prototype;
		_proto.load = function load(url, callback, asset) {
			Asset.fetchArrayBuffer(url.load, callback, asset, this.maxRetries);
		};
		_proto.open = function open(url, data, device, textureOptions) {
			if (textureOptions === void 0) {
				textureOptions = {};
			}
			var textureData = this.parse(data);
			if (!textureData) {
				return null;
			}
			var texture = new Texture(device, _extends({
				name: url,
				addressU: ADDRESS_REPEAT,
				addressV: ADDRESS_CLAMP_TO_EDGE,
				minFilter: FILTER_NEAREST,
				magFilter: FILTER_NEAREST,
				width: textureData.width,
				height: textureData.height,
				levels: textureData.levels,
				format: PIXELFORMAT_RGBA8,
				type: TEXTURETYPE_RGBE,
				mipmaps: false
			}, textureOptions));
			texture.upload();
			return texture;
		};
		_proto.parse = function parse(data) {
			var readStream = new ReadStream(data);
			var magic = readStream.readLine();
			if (!magic.startsWith('#?RADIANCE')) {
				return null;
			}
			var variables = {};
			while (true) {
				var line = readStream.readLine();
				if (line.length === 0) {
					break;
				} else {
					var parts = line.split('=');
					if (parts.length === 2) {
						variables[parts[0]] = parts[1];
					}
				}
			}
			if (!variables.hasOwnProperty('FORMAT')) {
				return null;
			}
			var resolution = readStream.readLine().split(' ');
			if (resolution.length !== 4) {
				return null;
			}
			var height = parseInt(resolution[1], 10);
			var width = parseInt(resolution[3], 10);
			var pixels = this._readPixels(readStream, width, height, resolution[0] === '-Y');
			if (!pixels) {
				return null;
			}
			return {
				width: width,
				height: height,
				levels: [pixels]
			};
		};
		_proto._readPixels = function _readPixels(readStream, width, height, flipY) {
			if (width < 8 || width > 0x7fff) {
				return this._readPixelsFlat(readStream, width, height);
			}
			var rgbe = [0, 0, 0, 0];
			readStream.readArray(rgbe);
			if (rgbe[0] !== 2 || rgbe[1] !== 2 || (rgbe[2] & 0x80) !== 0) {
				readStream.skip(-4);
				return this._readPixelsFlat(readStream, width, height);
			}
			var buffer = new ArrayBuffer(width * height * 4);
			var view = new Uint8Array(buffer);
			var scanstart = flipY ? 0 : width * 4 * (height - 1);
			var x, y, i, channel, count, value;
			for (y = 0; y < height; ++y) {
				if (y) {
					readStream.readArray(rgbe);
				}
				if ((rgbe[2] << 8) + rgbe[3] !== width) {
					return null;
				}
				for (channel = 0; channel < 4; ++channel) {
					x = 0;
					while (x < width) {
						count = readStream.readU8();
						if (count > 128) {
							count -= 128;
							if (x + count > width) {
								return null;
							}
							value = readStream.readU8();
							for (i = 0; i < count; ++i) {
								view[scanstart + channel + 4 * x++] = value;
							}
						} else {
							if (count === 0 || x + count > width) {
								return null;
							}
							for (i = 0; i < count; ++i) {
								view[scanstart + channel + 4 * x++] = readStream.readU8();
							}
						}
					}
				}
				scanstart += width * 4 * (flipY ? 1 : -1);
			}
			return view;
		};
		_proto._readPixelsFlat = function _readPixelsFlat(readStream, width, height) {
			return readStream.remainingBytes === width * height * 4 ? new Uint8Array(readStream.arraybuffer, readStream.offset) : null;
		};
		return HdrParser;
	}();

	var JSON_ADDRESS_MODE = {
		'repeat': ADDRESS_REPEAT,
		'clamp': ADDRESS_CLAMP_TO_EDGE,
		'mirror': ADDRESS_MIRRORED_REPEAT
	};
	var JSON_FILTER_MODE = {
		'nearest': FILTER_NEAREST,
		'linear': FILTER_LINEAR,
		'nearest_mip_nearest': FILTER_NEAREST_MIPMAP_NEAREST,
		'linear_mip_nearest': FILTER_LINEAR_MIPMAP_NEAREST,
		'nearest_mip_linear': FILTER_NEAREST_MIPMAP_LINEAR,
		'linear_mip_linear': FILTER_LINEAR_MIPMAP_LINEAR
	};
	var JSON_TEXTURE_TYPE = {
		'default': TEXTURETYPE_DEFAULT,
		'rgbm': TEXTURETYPE_RGBM,
		'rgbe': TEXTURETYPE_RGBE,
		'rgbp': TEXTURETYPE_RGBP,
		'swizzleGGGR': TEXTURETYPE_SWIZZLEGGGR
	};
	var TextureParser = function () {
		function TextureParser() {}
		var _proto = TextureParser.prototype;
		_proto.load = function load(url, callback, asset) {
			throw new Error('not implemented');
		};
		_proto.open = function open(url, data, device) {
			throw new Error('not implemented');
		};
		return TextureParser;
	}();
	var _completePartialMipmapChain = function _completePartialMipmapChain(texture) {
		var requiredMipLevels = TextureUtils.calcMipLevelsCount(texture._width, texture._height);
		var isHtmlElement = function isHtmlElement(object) {
			return object instanceof HTMLCanvasElement || object instanceof HTMLImageElement || object instanceof HTMLVideoElement;
		};
		if (!(texture._format === PIXELFORMAT_RGBA8 || texture._format === PIXELFORMAT_RGBA32F) || texture._volume || texture._compressed || texture._levels.length === 1 || texture._levels.length === requiredMipLevels || isHtmlElement(texture._cubemap ? texture._levels[0][0] : texture._levels[0])) {
			return;
		}
		var downsample = function downsample(width, height, data) {
			var sampledWidth = Math.max(1, width >> 1);
			var sampledHeight = Math.max(1, height >> 1);
			var sampledData = new data.constructor(sampledWidth * sampledHeight * 4);
			var xs = Math.floor(width / sampledWidth);
			var ys = Math.floor(height / sampledHeight);
			var xsys = xs * ys;
			for (var y = 0; y < sampledHeight; ++y) {
				for (var x = 0; x < sampledWidth; ++x) {
					for (var e = 0; e < 4; ++e) {
						var sum = 0;
						for (var sy = 0; sy < ys; ++sy) {
							for (var sx = 0; sx < xs; ++sx) {
								sum += data[(x * xs + sx + (y * ys + sy) * width) * 4 + e];
							}
						}
						sampledData[(x + y * sampledWidth) * 4 + e] = sum / xsys;
					}
				}
			}
			return sampledData;
		};
		for (var level = texture._levels.length; level < requiredMipLevels; ++level) {
			var width = Math.max(1, texture._width >> level - 1);
			var height = Math.max(1, texture._height >> level - 1);
			if (texture._cubemap) {
				var mips = [];
				for (var face = 0; face < 6; ++face) {
					mips.push(downsample(width, height, texture._levels[level - 1][face]));
				}
				texture._levels.push(mips);
			} else {
				texture._levels.push(downsample(width, height, texture._levels[level - 1]));
			}
		}
		texture._levelsUpdated = texture._cubemap ? [[true, true, true, true, true, true]] : [true];
	};
	var TextureHandler = function () {
		function TextureHandler(app) {
			this.handlerType = "texture";
			var assets = app.assets;
			var device = app.graphicsDevice;
			this._device = device;
			this._assets = assets;
			this.imgParser = new ImgParser(assets, device);
			this.parsers = {
				dds: new DdsParser(assets),
				ktx: new KtxParser(assets),
				ktx2: new Ktx2Parser(assets, device),
				basis: new BasisParser(assets, device),
				hdr: new HdrParser(assets)
			};
		}
		var _proto2 = TextureHandler.prototype;
		_proto2._getUrlWithoutParams = function _getUrlWithoutParams(url) {
			return url.indexOf('?') >= 0 ? url.split('?')[0] : url;
		};
		_proto2._getParser = function _getParser(url) {
			var ext = path.getExtension(this._getUrlWithoutParams(url)).toLowerCase().replace('.', '');
			return this.parsers[ext] || this.imgParser;
		};
		_proto2._getTextureOptions = function _getTextureOptions(asset) {
			var options = {};
			if (asset) {
				var _asset$name;
				if (((_asset$name = asset.name) == null ? void 0 : _asset$name.length) > 0) {
					options.name = asset.name;
				}
				var assetData = asset.data;
				if (assetData.hasOwnProperty('minfilter')) {
					options.minFilter = JSON_FILTER_MODE[assetData.minfilter];
				}
				if (assetData.hasOwnProperty('magfilter')) {
					options.magFilter = JSON_FILTER_MODE[assetData.magfilter];
				}
				if (assetData.hasOwnProperty('addressu')) {
					options.addressU = JSON_ADDRESS_MODE[assetData.addressu];
				}
				if (assetData.hasOwnProperty('addressv')) {
					options.addressV = JSON_ADDRESS_MODE[assetData.addressv];
				}
				if (assetData.hasOwnProperty('mipmaps')) {
					options.mipmaps = assetData.mipmaps;
				}
				if (assetData.hasOwnProperty('anisotropy')) {
					options.anisotropy = assetData.anisotropy;
				}
				if (assetData.hasOwnProperty('flipY')) {
					options.flipY = !!assetData.flipY;
				}
				if (assetData.hasOwnProperty('type')) {
					options.type = JSON_TEXTURE_TYPE[assetData.type];
				} else if (assetData.hasOwnProperty('rgbm') && assetData.rgbm) {
					options.type = TEXTURETYPE_RGBM;
				} else if (asset.file && (asset.file.opt & 8) !== 0) {
					options.type = TEXTURETYPE_SWIZZLEGGGR;
				}
			}
			return options;
		};
		_proto2.load = function load(url, callback, asset) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			this._getParser(url.original).load(url, callback, asset);
		};
		_proto2.open = function open(url, data, asset) {
			if (!url) return undefined;
			var textureOptions = this._getTextureOptions(asset);
			var texture = this._getParser(url).open(url, data, this._device, textureOptions);
			if (texture === null) {
				texture = new Texture(this._device, {
					width: 4,
					height: 4,
					format: PIXELFORMAT_RGB8
				});
			} else {
				_completePartialMipmapChain(texture);
				if (data.unswizzledGGGR) {
					asset.file.variants.basis.opt &= ~8;
				}
			}
			return texture;
		};
		_proto2.patch = function patch(asset, assets) {
			var texture = asset.resource;
			if (!texture) {
				return;
			}
			var options = this._getTextureOptions(asset);
			for (var _i = 0, _Object$keys = Object.keys(options); _i < _Object$keys.length; _i++) {
				var key = _Object$keys[_i];
				texture[key] = options[key];
			}
		};
		_createClass(TextureHandler, [{
			key: "crossOrigin",
			get: function get() {
				return this.imgParser.crossOrigin;
			},
			set: function set(value) {
				this.imgParser.crossOrigin = value;
			}
		}, {
			key: "maxRetries",
			get: function get() {
				return this.imgParser.maxRetries;
			},
			set: function set(value) {
				this.imgParser.maxRetries = value;
				for (var parser in this.parsers) {
					if (this.parsers.hasOwnProperty(parser)) {
						this.parsers[parser].maxRetries = value;
					}
				}
			}
		}]);
		return TextureHandler;
	}();

	var XRTYPE_INLINE = 'inline';
	var XRTYPE_VR = 'immersive-vr';
	var XRTYPE_AR = 'immersive-ar';
	var XRSPACE_VIEWER = 'viewer';
	var XRSPACE_LOCAL = 'local';
	var XRSPACE_LOCALFLOOR = 'local-floor';
	var XRSPACE_BOUNDEDFLOOR = 'bounded-floor';
	var XRSPACE_UNBOUNDED = 'unbounded';
	var XRTARGETRAY_GAZE = 'gaze';
	var XRTARGETRAY_SCREEN = 'screen';
	var XRTARGETRAY_POINTER = 'tracked-pointer';
	var XRHAND_NONE = 'none';
	var XRHAND_LEFT = 'left';
	var XRHAND_RIGHT = 'right';
	var XRTRACKABLE_POINT = 'point';
	var XRTRACKABLE_PLANE = 'plane';
	var XRTRACKABLE_MESH = 'mesh';
	var XRDEPTHSENSINGUSAGE_CPU = 'cpu-optimized';
	var XRDEPTHSENSINGUSAGE_GPU = 'gpu-optimized';
	var XRDEPTHSENSINGFORMAT_L8A8 = 'luminance-alpha';
	var XRDEPTHSENSINGFORMAT_F32 = 'float32';

	var XrDepthSensing = function (_EventHandler) {
		_inheritsLoose(XrDepthSensing, _EventHandler);
		function XrDepthSensing(manager) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this._manager = void 0;
			_this._available = false;
			_this._depthInfoCpu = null;
			_this._depthInfoGpu = null;
			_this._usage = null;
			_this._dataFormat = null;
			_this._matrixDirty = false;
			_this._matrix = new Mat4();
			_this._emptyBuffer = new Uint8Array(32);
			_this._depthBuffer = null;
			_this._texture = void 0;
			_this._manager = manager;
			_this._texture = new Texture(_this._manager.app.graphicsDevice, {
				format: PIXELFORMAT_LA8,
				mipmaps: false,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE,
				minFilter: FILTER_LINEAR,
				magFilter: FILTER_LINEAR,
				name: 'XRDepthSensing'
			});
			if (_this.supported) {
				_this._manager.on('start', _this._onSessionStart, _assertThisInitialized(_this));
				_this._manager.on('end', _this._onSessionEnd, _assertThisInitialized(_this));
			}
			return _this;
		}
		var _proto = XrDepthSensing.prototype;
		_proto.destroy = function destroy() {
			this._texture.destroy();
			this._texture = null;
		};
		_proto._onSessionStart = function _onSessionStart() {
			var session = this._manager.session;
			try {
				this._usage = session.depthUsage;
				this._dataFormat = session.depthDataFormat;
			} catch (ex) {
				this._usage = null;
				this._dataFormat = null;
				this._available = false;
				this.fire('error', ex);
			}
		};
		_proto._onSessionEnd = function _onSessionEnd() {
			this._depthInfoCpu = null;
			this._depthInfoGpu = null;
			this._usage = null;
			this._dataFormat = null;
			if (this._available) {
				this._available = false;
				this.fire('unavailable');
			}
			this._depthBuffer = null;
			this._texture._width = 4;
			this._texture._height = 4;
			this._texture._levels[0] = this._emptyBuffer;
			this._texture.upload();
		};
		_proto._updateTexture = function _updateTexture() {
			var depthInfo = this._depthInfoCpu || this._depthInfoGpu;
			if (depthInfo) {
				var resized = false;
				if (depthInfo.width !== this._texture.width || depthInfo.height !== this._texture.height) {
					this._texture._width = depthInfo.width;
					this._texture._height = depthInfo.height;
					this._matrixDirty = true;
					resized = true;
				}
				if (this._depthInfoCpu) {
					var dataBuffer = this._depthInfoCpu.data;
					this._depthBuffer = new Uint8Array(dataBuffer);
					this._texture._levels[0] = this._depthBuffer;
					this._texture.upload();
				} else if (this._depthInfoGpu) {
					this._texture._levels[0] = this._depthInfoGpu.texture;
					this._texture.upload();
				}
				if (resized) this.fire('resize', depthInfo.width, depthInfo.height);
			} else if (this._depthBuffer) {
				this._depthBuffer = null;
				this._texture._width = 4;
				this._texture._height = 4;
				this._texture._levels[0] = this._emptyBuffer;
				this._texture.upload();
			}
		};
		_proto.update = function update(frame, view) {
			if (!this._usage) return;
			var depthInfoCpu = null;
			var depthInfoGpu = null;
			if (this._usage === XRDEPTHSENSINGUSAGE_CPU && view) {
				depthInfoCpu = frame.getDepthInformation(view);
			} else if (this._usage === XRDEPTHSENSINGUSAGE_GPU && view) {
				depthInfoGpu = frame.getDepthInformation(view);
			}
			if (this._depthInfoCpu && !depthInfoCpu || !this._depthInfoCpu && depthInfoCpu || this.depthInfoGpu && !depthInfoGpu || !this._depthInfoGpu && depthInfoGpu) {
				this._matrixDirty = true;
			}
			this._depthInfoCpu = depthInfoCpu;
			this._depthInfoGpu = depthInfoGpu;
			this._updateTexture();
			if (this._matrixDirty) {
				this._matrixDirty = false;
				var depthInfo = this._depthInfoCpu || this._depthInfoGpu;
				if (depthInfo) {
					this._matrix.data.set(depthInfo.normDepthBufferFromNormView.matrix);
				} else {
					this._matrix.setIdentity();
				}
			}
			if ((this._depthInfoCpu || this._depthInfoGpu) && !this._available) {
				this._available = true;
				this.fire('available');
			} else if (!this._depthInfoCpu && !this._depthInfoGpu && this._available) {
				this._available = false;
				this.fire('unavailable');
			}
		};
		_proto.getDepth = function getDepth(u, v) {
			if (!this._depthInfoCpu) return null;
			return this._depthInfoCpu.getDepthInMeters(u, v);
		};
		_createClass(XrDepthSensing, [{
			key: "supported",
			get: function get() {
				return platform.browser && !!window.XRDepthInformation;
			}
		}, {
			key: "available",
			get: function get() {
				return this._available;
			}
		}, {
			key: "usage",
			get: function get() {
				return this._usage;
			}
		}, {
			key: "dataFormat",
			get: function get() {
				return this._dataFormat;
			}
		}, {
			key: "width",
			get: function get() {
				var depthInfo = this._depthInfoCpu || this._depthInfoGpu;
				return depthInfo && depthInfo.width || 0;
			}
		}, {
			key: "height",
			get: function get() {
				var depthInfo = this._depthInfoCpu || this._depthInfoGpu;
				return depthInfo && depthInfo.height || 0;
			}
		}, {
			key: "texture",
			get: function get() {
				return this._texture;
			}
		}, {
			key: "uvMatrix",
			get: function get() {
				return this._matrix;
			}
		}, {
			key: "rawValueToMeters",
			get: function get() {
				var depthInfo = this._depthInfoCpu || this._depthInfoGpu;
				return depthInfo && depthInfo.rawValueToMeters || 0;
			}
		}]);
		return XrDepthSensing;
	}(EventHandler);

	var XrDomOverlay = function () {
		function XrDomOverlay(manager) {
			this._manager = void 0;
			this._supported = platform.browser && !!window.XRDOMOverlayState;
			this._root = null;
			this._manager = manager;
		}
		_createClass(XrDomOverlay, [{
			key: "supported",
			get: function get() {
				return this._supported;
			}
		}, {
			key: "available",
			get: function get() {
				return this._supported && this._manager.active && this._manager._session.domOverlayState !== null;
			}
		}, {
			key: "state",
			get: function get() {
				if (!this._supported || !this._manager.active || !this._manager._session.domOverlayState) return null;
				return this._manager._session.domOverlayState.type;
			}
		}, {
			key: "root",
			get: function get() {
				return this._root;
			},
			set: function set(value) {
				if (!this._supported || this._manager.active) return;
				this._root = value;
			}
		}]);
		return XrDomOverlay;
	}();

	var poolVec3 = [];
	var poolQuat = [];
	var XrHitTestSource = function (_EventHandler) {
		_inheritsLoose(XrHitTestSource, _EventHandler);
		function XrHitTestSource(manager, xrHitTestSource, transient) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this.manager = void 0;
			_this._xrHitTestSource = void 0;
			_this._transient = void 0;
			_this.manager = manager;
			_this._xrHitTestSource = xrHitTestSource;
			_this._transient = transient;
			return _this;
		}
		var _proto = XrHitTestSource.prototype;
		_proto.remove = function remove() {
			if (!this._xrHitTestSource) return;
			var sources = this.manager.hitTest.sources;
			var ind = sources.indexOf(this);
			if (ind !== -1) sources.splice(ind, 1);
			this.onStop();
		};
		_proto.onStop = function onStop() {
			this._xrHitTestSource.cancel();
			this._xrHitTestSource = null;
			this.fire('remove');
			this.manager.hitTest.fire('remove', this);
		};
		_proto.update = function update(frame) {
			if (this._transient) {
				var transientResults = frame.getHitTestResultsForTransientInput(this._xrHitTestSource);
				for (var i = 0; i < transientResults.length; i++) {
					var transientResult = transientResults[i];
					var inputSource = void 0;
					if (transientResult.inputSource) inputSource = this.manager.input._getByInputSource(transientResult.inputSource);
					this.updateHitResults(transientResult.results, inputSource);
				}
			} else {
				this.updateHitResults(frame.getHitTestResults(this._xrHitTestSource));
			}
		};
		_proto.updateHitResults = function updateHitResults(results, inputSource) {
			var _poolVec3$pop, _poolVec3$pop2, _poolQuat$pop;
			if (inputSource && !inputSource.hitTestSourcesSet.has(this)) return;
			var origin = (_poolVec3$pop = poolVec3.pop()) != null ? _poolVec3$pop : new Vec3();
			if (inputSource) {
				origin.copy(inputSource.getOrigin());
			} else {
				origin.copy(this.manager.camera.getPosition());
			}
			var candidateDistance = Infinity;
			var candidateHitTestResult = null;
			var position = (_poolVec3$pop2 = poolVec3.pop()) != null ? _poolVec3$pop2 : new Vec3();
			var rotation = (_poolQuat$pop = poolQuat.pop()) != null ? _poolQuat$pop : new Quat();
			for (var i = 0; i < results.length; i++) {
				var pose = results[i].getPose(this.manager._referenceSpace);
				var distance = origin.distance(pose.transform.position);
				if (distance >= candidateDistance) continue;
				candidateDistance = distance;
				candidateHitTestResult = results[i];
				position.copy(pose.transform.position);
				rotation.copy(pose.transform.orientation);
			}
			this.fire('result', position, rotation, inputSource, candidateHitTestResult);
			this.manager.hitTest.fire('result', this, position, rotation, inputSource, candidateHitTestResult);
			poolVec3.push(origin);
			poolVec3.push(position);
			poolQuat.push(rotation);
		};
		return XrHitTestSource;
	}(EventHandler);

	var XrHitTest = function (_EventHandler) {
		_inheritsLoose(XrHitTest, _EventHandler);
		function XrHitTest(manager) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this.manager = void 0;
			_this._supported = platform.browser && !!(window.XRSession && window.XRSession.prototype.requestHitTestSource);
			_this._session = null;
			_this.sources = [];
			_this.manager = manager;
			if (_this._supported) {
				_this.manager.on('start', _this._onSessionStart, _assertThisInitialized(_this));
				_this.manager.on('end', _this._onSessionEnd, _assertThisInitialized(_this));
			}
			return _this;
		}
		var _proto = XrHitTest.prototype;
		_proto._onSessionStart = function _onSessionStart() {
			if (this.manager.type !== XRTYPE_AR) return;
			this._session = this.manager.session;
		};
		_proto._onSessionEnd = function _onSessionEnd() {
			if (!this._session) return;
			this._session = null;
			for (var i = 0; i < this.sources.length; i++) {
				this.sources[i].onStop();
			}
			this.sources = [];
		};
		_proto.isAvailable = function isAvailable(callback, fireError) {
			var err;
			if (!this._supported) err = new Error('XR HitTest is not supported');
			if (!this._session) err = new Error('XR Session is not started (1)');
			if (this.manager.type !== XRTYPE_AR) err = new Error('XR HitTest is available only for AR');
			if (err) {
				if (callback) callback(err);
				if (fireError) fireError.fire('error', err);
				return false;
			}
			return true;
		};
		_proto.start = function start(options) {
			var _this2 = this;
			if (options === void 0) {
				options = {};
			}
			if (!this.isAvailable(options.callback, this)) return;
			if (!options.profile && !options.spaceType) options.spaceType = XRSPACE_VIEWER;
			var xrRay;
			var offsetRay = options.offsetRay;
			if (offsetRay) {
				var origin = new DOMPoint(offsetRay.origin.x, offsetRay.origin.y, offsetRay.origin.z, 1.0);
				var direction = new DOMPoint(offsetRay.direction.x, offsetRay.direction.y, offsetRay.direction.z, 0.0);
				xrRay = new XRRay(origin, direction);
			}
			var callback = options.callback;
			if (options.spaceType) {
				this._session.requestReferenceSpace(options.spaceType).then(function (referenceSpace) {
					if (!_this2._session) {
						var err = new Error('XR Session is not started (2)');
						if (callback) callback(err);
						_this2.fire('error', err);
						return;
					}
					_this2._session.requestHitTestSource({
						space: referenceSpace,
						entityTypes: options.entityTypes || undefined,
						offsetRay: xrRay
					}).then(function (xrHitTestSource) {
						_this2._onHitTestSource(xrHitTestSource, false, callback);
					}).catch(function (ex) {
						if (callback) callback(ex);
						_this2.fire('error', ex);
					});
				}).catch(function (ex) {
					if (callback) callback(ex);
					_this2.fire('error', ex);
				});
			} else {
				this._session.requestHitTestSourceForTransientInput({
					profile: options.profile,
					entityTypes: options.entityTypes || undefined,
					offsetRay: xrRay
				}).then(function (xrHitTestSource) {
					_this2._onHitTestSource(xrHitTestSource, true, callback);
				}).catch(function (ex) {
					if (callback) callback(ex);
					_this2.fire('error', ex);
				});
			}
		};
		_proto._onHitTestSource = function _onHitTestSource(xrHitTestSource, transient, callback) {
			if (!this._session) {
				xrHitTestSource.cancel();
				var err = new Error('XR Session is not started (3)');
				if (callback) callback(err);
				this.fire('error', err);
				return;
			}
			var hitTestSource = new XrHitTestSource(this.manager, xrHitTestSource, transient);
			this.sources.push(hitTestSource);
			if (callback) callback(null, hitTestSource);
			this.fire('add', hitTestSource);
		};
		_proto.update = function update(frame) {
			for (var i = 0; i < this.sources.length; i++) {
				this.sources[i].update(frame);
			}
		};
		_createClass(XrHitTest, [{
			key: "supported",
			get: function get() {
				return this._supported;
			}
		}]);
		return XrHitTest;
	}(EventHandler);

	var XrTrackedImage = function (_EventHandler) {
		_inheritsLoose(XrTrackedImage, _EventHandler);
		function XrTrackedImage(image, width) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this._image = void 0;
			_this._width = void 0;
			_this._bitmap = null;
			_this._measuredWidth = 0;
			_this._trackable = false;
			_this._tracking = false;
			_this._emulated = false;
			_this._pose = null;
			_this._position = new Vec3();
			_this._rotation = new Quat();
			_this._image = image;
			_this._width = width;
			return _this;
		}
		var _proto = XrTrackedImage.prototype;
		_proto.prepare = function prepare() {
			var _this2 = this;
			if (this._bitmap) {
				return {
					image: this._bitmap,
					widthInMeters: this._width
				};
			}
			return createImageBitmap(this._image).then(function (bitmap) {
				_this2._bitmap = bitmap;
				return {
					image: _this2._bitmap,
					widthInMeters: _this2._width
				};
			});
		};
		_proto.destroy = function destroy() {
			this._image = null;
			this._pose = null;
			if (this._bitmap) {
				this._bitmap.close();
				this._bitmap = null;
			}
		};
		_proto.getPosition = function getPosition() {
			if (this._pose) this._position.copy(this._pose.transform.position);
			return this._position;
		};
		_proto.getRotation = function getRotation() {
			if (this._pose) this._rotation.copy(this._pose.transform.orientation);
			return this._rotation;
		};
		_createClass(XrTrackedImage, [{
			key: "image",
			get: function get() {
				return this._image;
			}
		}, {
			key: "width",
			get: function get() {
				return this._width;
			},
			set: function set(value) {
				this._width = value;
			}
		}, {
			key: "trackable",
			get: function get() {
				return this._trackable;
			}
		}, {
			key: "tracking",
			get: function get() {
				return this._tracking;
			}
		}, {
			key: "emulated",
			get: function get() {
				return this._emulated;
			}
		}]);
		return XrTrackedImage;
	}(EventHandler);

	var XrImageTracking = function (_EventHandler) {
		_inheritsLoose(XrImageTracking, _EventHandler);
		function XrImageTracking(manager) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this._manager = void 0;
			_this._supported = platform.browser && !!window.XRImageTrackingResult;
			_this._available = false;
			_this._images = [];
			_this._manager = manager;
			if (_this._supported) {
				_this._manager.on('start', _this._onSessionStart, _assertThisInitialized(_this));
				_this._manager.on('end', _this._onSessionEnd, _assertThisInitialized(_this));
			}
			return _this;
		}
		var _proto = XrImageTracking.prototype;
		_proto.add = function add(image, width) {
			if (!this._supported || this._manager.active) return null;
			var trackedImage = new XrTrackedImage(image, width);
			this._images.push(trackedImage);
			return trackedImage;
		};
		_proto.remove = function remove(trackedImage) {
			if (this._manager.active) return;
			var ind = this._images.indexOf(trackedImage);
			if (ind !== -1) {
				trackedImage.destroy();
				this._images.splice(ind, 1);
			}
		};
		_proto._onSessionStart = function _onSessionStart() {
			var _this2 = this;
			this._manager.session.getTrackedImageScores().then(function (images) {
				_this2._available = true;
				for (var i = 0; i < images.length; i++) {
					_this2._images[i]._trackable = images[i] === 'trackable';
				}
			}).catch(function (err) {
				_this2._available = false;
				_this2.fire('error', err);
			});
		};
		_proto._onSessionEnd = function _onSessionEnd() {
			this._available = false;
			for (var i = 0; i < this._images.length; i++) {
				var image = this._images[i];
				image._pose = null;
				image._measuredWidth = 0;
				if (image._tracking) {
					image._tracking = false;
					image.fire('untracked');
				}
			}
		};
		_proto.prepareImages = function prepareImages(callback) {
			if (this._images.length) {
				Promise.all(this._images.map(function (trackedImage) {
					return trackedImage.prepare();
				})).then(function (bitmaps) {
					callback(null, bitmaps);
				}).catch(function (err) {
					callback(err, null);
				});
			} else {
				callback(null, null);
			}
		};
		_proto.update = function update(frame) {
			if (!this._available) return;
			var results = frame.getImageTrackingResults();
			var index = {};
			for (var i = 0; i < results.length; i++) {
				index[results[i].index] = results[i];
				var trackedImage = this._images[results[i].index];
				trackedImage._emulated = results[i].trackingState === 'emulated';
				trackedImage._measuredWidth = results[i].measuredWidthInMeters;
				trackedImage._pose = frame.getPose(results[i].imageSpace, this._manager._referenceSpace);
			}
			for (var _i = 0; _i < this._images.length; _i++) {
				if (this._images[_i]._tracking && !index[_i]) {
					this._images[_i]._tracking = false;
					this._images[_i].fire('untracked');
				} else if (!this._images[_i]._tracking && index[_i]) {
					this._images[_i]._tracking = true;
					this._images[_i].fire('tracked');
				}
			}
		};
		_createClass(XrImageTracking, [{
			key: "supported",
			get: function get() {
				return this._supported;
			}
		}, {
			key: "available",
			get: function get() {
				return this._available;
			}
		}, {
			key: "images",
			get: function get() {
				return this._images;
			}
		}]);
		return XrImageTracking;
	}(EventHandler);

	var XrFinger = function () {
		function XrFinger(index, hand) {
			this._index = void 0;
			this._hand = void 0;
			this._joints = [];
			this._tip = null;
			this._index = index;
			this._hand = hand;
			this._hand._fingers.push(this);
		}
		_createClass(XrFinger, [{
			key: "index",
			get: function get() {
				return this._index;
			}
		}, {
			key: "hand",
			get: function get() {
				return this._hand;
			}
		}, {
			key: "joints",
			get: function get() {
				return this._joints;
			}
		}, {
			key: "tip",
			get: function get() {
				return this._tip;
			}
		}]);
		return XrFinger;
	}();

	var tipJointIds = platform.browser && window.XRHand ? ['thumb-tip', 'index-finger-tip', 'middle-finger-tip', 'ring-finger-tip', 'pinky-finger-tip'] : [];
	var tipJointIdsIndex = {};
	for (var i = 0; i < tipJointIds.length; i++) {
		tipJointIdsIndex[tipJointIds[i]] = true;
	}
	var XrJoint = function () {
		function XrJoint(index, id, hand, finger) {
			if (finger === void 0) {
				finger = null;
			}
			this._index = void 0;
			this._id = void 0;
			this._hand = void 0;
			this._finger = void 0;
			this._wrist = void 0;
			this._tip = void 0;
			this._radius = null;
			this._localTransform = new Mat4();
			this._worldTransform = new Mat4();
			this._localPosition = new Vec3();
			this._localRotation = new Quat();
			this._position = new Vec3();
			this._rotation = new Quat();
			this._dirtyLocal = true;
			this._index = index;
			this._id = id;
			this._hand = hand;
			this._finger = finger;
			this._wrist = id === 'wrist';
			this._tip = this._finger && !!tipJointIdsIndex[id];
		}
		var _proto = XrJoint.prototype;
		_proto.update = function update(pose) {
			this._dirtyLocal = true;
			this._radius = pose.radius;
			this._localPosition.copy(pose.transform.position);
			this._localRotation.copy(pose.transform.orientation);
		};
		_proto._updateTransforms = function _updateTransforms() {
			if (this._dirtyLocal) {
				this._dirtyLocal = false;
				this._localTransform.setTRS(this._localPosition, this._localRotation, Vec3.ONE);
			}
			var manager = this._hand._manager;
			var parent = manager.camera.parent;
			if (parent) {
				this._worldTransform.mul2(parent.getWorldTransform(), this._localTransform);
			} else {
				this._worldTransform.copy(this._localTransform);
			}
		};
		_proto.getPosition = function getPosition() {
			this._updateTransforms();
			this._worldTransform.getTranslation(this._position);
			return this._position;
		};
		_proto.getRotation = function getRotation() {
			this._updateTransforms();
			this._rotation.setFromMat4(this._worldTransform);
			return this._rotation;
		};
		_createClass(XrJoint, [{
			key: "index",
			get: function get() {
				return this._index;
			}
		}, {
			key: "hand",
			get: function get() {
				return this._hand;
			}
		}, {
			key: "finger",
			get: function get() {
				return this._finger;
			}
		}, {
			key: "wrist",
			get: function get() {
				return this._wrist;
			}
		}, {
			key: "tip",
			get: function get() {
				return this._tip;
			}
		}, {
			key: "radius",
			get: function get() {
				return this._radius || 0.005;
			}
		}]);
		return XrJoint;
	}();

	var fingerJointIds = [];
	var vecA$1 = new Vec3();
	var vecB$1 = new Vec3();
	var vecC = new Vec3();
	if (platform.browser && window.XRHand) {
		fingerJointIds = [['thumb-metacarpal', 'thumb-phalanx-proximal', 'thumb-phalanx-distal', 'thumb-tip'], ['index-finger-metacarpal', 'index-finger-phalanx-proximal', 'index-finger-phalanx-intermediate', 'index-finger-phalanx-distal', 'index-finger-tip'], ['middle-finger-metacarpal', 'middle-finger-phalanx-proximal', 'middle-finger-phalanx-intermediate', 'middle-finger-phalanx-distal', 'middle-finger-tip'], ['ring-finger-metacarpal', 'ring-finger-phalanx-proximal', 'ring-finger-phalanx-intermediate', 'ring-finger-phalanx-distal', 'ring-finger-tip'], ['pinky-finger-metacarpal', 'pinky-finger-phalanx-proximal', 'pinky-finger-phalanx-intermediate', 'pinky-finger-phalanx-distal', 'pinky-finger-tip']];
	}
	var XrHand = function (_EventHandler) {
		_inheritsLoose(XrHand, _EventHandler);
		function XrHand(inputSource) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this._manager = void 0;
			_this._inputSource = void 0;
			_this._tracking = false;
			_this._fingers = [];
			_this._joints = [];
			_this._jointsById = {};
			_this._tips = [];
			_this._wrist = null;
			var xrHand = inputSource._xrInputSource.hand;
			_this._manager = inputSource._manager;
			_this._inputSource = inputSource;
			if (xrHand.get('wrist')) {
				var joint = new XrJoint(0, 'wrist', _assertThisInitialized(_this), null);
				_this._wrist = joint;
				_this._joints.push(joint);
				_this._jointsById.wrist = joint;
			}
			for (var f = 0; f < fingerJointIds.length; f++) {
				var finger = new XrFinger(f, _assertThisInitialized(_this));
				for (var j = 0; j < fingerJointIds[f].length; j++) {
					var jointId = fingerJointIds[f][j];
					if (!xrHand.get(jointId)) continue;
					var _joint = new XrJoint(j, jointId, _assertThisInitialized(_this), finger);
					_this._joints.push(_joint);
					_this._jointsById[jointId] = _joint;
					if (_joint.tip) {
						_this._tips.push(_joint);
						finger._tip = _joint;
					}
					finger._joints.push(_joint);
				}
			}
			return _this;
		}
		var _proto = XrHand.prototype;
		_proto.update = function update(frame) {
			var xrInputSource = this._inputSource._xrInputSource;
			for (var j = 0; j < this._joints.length; j++) {
				var joint = this._joints[j];
				var jointSpace = xrInputSource.hand.get(joint._id);
				if (jointSpace) {
					var pose = void 0;
					if (frame.session.visibilityState !== 'hidden') pose = frame.getJointPose(jointSpace, this._manager._referenceSpace);
					if (pose) {
						joint.update(pose);
						if (joint.wrist && !this._tracking) {
							this._tracking = true;
							this.fire('tracking');
						}
					} else if (joint.wrist) {
						if (this._tracking) {
							this._tracking = false;
							this.fire('trackinglost');
						}
						break;
					}
				}
			}
			var j1 = this._jointsById['thumb-metacarpal'];
			var j4 = this._jointsById['thumb-tip'];
			var j6 = this._jointsById['index-finger-phalanx-proximal'];
			var j9 = this._jointsById['index-finger-tip'];
			var j16 = this._jointsById['ring-finger-phalanx-proximal'];
			var j21 = this._jointsById['pinky-finger-phalanx-proximal'];
			if (j1 && j4 && j6 && j9 && j16 && j21) {
				this._inputSource._dirtyRay = true;
				this._inputSource._rayLocal.origin.lerp(j4._localPosition, j9._localPosition, 0.5);
				var jointL = j1;
				var jointR = j21;
				if (this._inputSource.handedness === XRHAND_LEFT) {
					var t = jointL;
					jointL = jointR;
					jointR = t;
				}
				vecA$1.sub2(jointL._localPosition, this._wrist._localPosition);
				vecB$1.sub2(jointR._localPosition, this._wrist._localPosition);
				vecC.cross(vecA$1, vecB$1).normalize();
				vecA$1.lerp(j6._localPosition, j16._localPosition, 0.5);
				vecA$1.sub(this._wrist._localPosition).normalize();
				this._inputSource._rayLocal.direction.lerp(vecC, vecA$1, 0.5).normalize();
			}
			var squeezing = this._fingerIsClosed(1) && this._fingerIsClosed(2) && this._fingerIsClosed(3) && this._fingerIsClosed(4);
			if (squeezing) {
				if (!this._inputSource._squeezing) {
					this._inputSource._squeezing = true;
					this._inputSource.fire('squeezestart');
					this._manager.input.fire('squeezestart', this._inputSource);
				}
			} else {
				if (this._inputSource._squeezing) {
					this._inputSource._squeezing = false;
					this._inputSource.fire('squeeze');
					this._manager.input.fire('squeeze', this._inputSource);
					this._inputSource.fire('squeezeend');
					this._manager.input.fire('squeezeend', this._inputSource);
				}
			}
		};
		_proto._fingerIsClosed = function _fingerIsClosed(index) {
			var finger = this._fingers[index];
			vecA$1.sub2(finger.joints[0]._localPosition, finger.joints[1]._localPosition).normalize();
			vecB$1.sub2(finger.joints[2]._localPosition, finger.joints[3]._localPosition).normalize();
			return vecA$1.dot(vecB$1) < -0.8;
		};
		_proto.getJointById = function getJointById(id) {
			return this._jointsById[id] || null;
		};
		_createClass(XrHand, [{
			key: "fingers",
			get: function get() {
				return this._fingers;
			}
		}, {
			key: "joints",
			get: function get() {
				return this._joints;
			}
		}, {
			key: "tips",
			get: function get() {
				return this._tips;
			}
		}, {
			key: "wrist",
			get: function get() {
				return this._wrist;
			}
		}, {
			key: "tracking",
			get: function get() {
				return this._tracking;
			}
		}]);
		return XrHand;
	}(EventHandler);

	var quat = new Quat();
	var ids$1 = 0;
	var XrInputSource = function (_EventHandler) {
		_inheritsLoose(XrInputSource, _EventHandler);
		function XrInputSource(manager, xrInputSource) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this._id = void 0;
			_this._manager = void 0;
			_this._xrInputSource = void 0;
			_this._ray = new Ray();
			_this._rayLocal = new Ray();
			_this._grip = false;
			_this._hand = null;
			_this._localTransform = null;
			_this._worldTransform = null;
			_this._position = new Vec3();
			_this._rotation = new Quat();
			_this._localPosition = null;
			_this._localRotation = null;
			_this._dirtyLocal = true;
			_this._dirtyRay = false;
			_this._selecting = false;
			_this._squeezing = false;
			_this._elementInput = true;
			_this._elementEntity = null;
			_this._hitTestSources = [];
			_this.hitTestSourcesSet = new Set();
			_this._id = ++ids$1;
			_this._manager = manager;
			_this._xrInputSource = xrInputSource;
			if (xrInputSource.hand) _this._hand = new XrHand(_assertThisInitialized(_this));
			return _this;
		}
		var _proto = XrInputSource.prototype;
		_proto.update = function update(frame) {
			if (this._hand) {
				this._hand.update(frame);
			} else {
				if (this._xrInputSource.gripSpace) {
					var gripPose = frame.getPose(this._xrInputSource.gripSpace, this._manager._referenceSpace);
					if (gripPose) {
						if (!this._grip) {
							this._grip = true;
							this._localTransform = new Mat4();
							this._worldTransform = new Mat4();
							this._localPosition = new Vec3();
							this._localRotation = new Quat();
						}
						this._dirtyLocal = true;
						this._localPosition.copy(gripPose.transform.position);
						this._localRotation.copy(gripPose.transform.orientation);
					}
				}
				var targetRayPose = frame.getPose(this._xrInputSource.targetRaySpace, this._manager._referenceSpace);
				if (targetRayPose) {
					this._dirtyRay = true;
					this._rayLocal.origin.copy(targetRayPose.transform.position);
					this._rayLocal.direction.set(0, 0, -1);
					quat.copy(targetRayPose.transform.orientation);
					quat.transformVector(this._rayLocal.direction, this._rayLocal.direction);
				}
			}
		};
		_proto._updateTransforms = function _updateTransforms() {
			if (this._dirtyLocal) {
				this._dirtyLocal = false;
				this._localTransform.setTRS(this._localPosition, this._localRotation, Vec3.ONE);
			}
			var parent = this._manager.camera.parent;
			if (parent) {
				this._worldTransform.mul2(parent.getWorldTransform(), this._localTransform);
			} else {
				this._worldTransform.copy(this._localTransform);
			}
		};
		_proto._updateRayTransforms = function _updateRayTransforms() {
			var dirty = this._dirtyRay;
			this._dirtyRay = false;
			var parent = this._manager.camera.parent;
			if (parent) {
				var parentTransform = this._manager.camera.parent.getWorldTransform();
				parentTransform.getTranslation(this._position);
				this._rotation.setFromMat4(parentTransform);
				this._rotation.transformVector(this._rayLocal.origin, this._ray.origin);
				this._ray.origin.add(this._position);
				this._rotation.transformVector(this._rayLocal.direction, this._ray.direction);
			} else if (dirty) {
				this._ray.origin.copy(this._rayLocal.origin);
				this._ray.direction.copy(this._rayLocal.direction);
			}
		};
		_proto.getPosition = function getPosition() {
			if (!this._position) return null;
			this._updateTransforms();
			this._worldTransform.getTranslation(this._position);
			return this._position;
		};
		_proto.getLocalPosition = function getLocalPosition() {
			return this._localPosition;
		};
		_proto.getRotation = function getRotation() {
			if (!this._rotation) return null;
			this._updateTransforms();
			this._rotation.setFromMat4(this._worldTransform);
			return this._rotation;
		};
		_proto.getLocalRotation = function getLocalRotation() {
			return this._localRotation;
		};
		_proto.getOrigin = function getOrigin() {
			this._updateRayTransforms();
			return this._ray.origin;
		};
		_proto.getDirection = function getDirection() {
			this._updateRayTransforms();
			return this._ray.direction;
		};
		_proto.hitTestStart = function hitTestStart(options) {
			var _this2 = this;
			if (options === void 0) {
				options = {};
			}
			options.profile = this._xrInputSource.profiles[0];
			var callback = options.callback;
			options.callback = function (err, hitTestSource) {
				if (hitTestSource) _this2.onHitTestSourceAdd(hitTestSource);
				if (callback) callback(err, hitTestSource);
			};
			this._manager.hitTest.start(options);
		};
		_proto.onHitTestSourceAdd = function onHitTestSourceAdd(hitTestSource) {
			this.hitTestSourcesSet.add(hitTestSource);
			this._hitTestSources.push(hitTestSource);
			this.fire('hittest:add', hitTestSource);
			hitTestSource.on('result', function (position, rotation, inputSource) {
				if (inputSource !== this) return;
				this.fire('hittest:result', hitTestSource, position, rotation);
			}, this);
			hitTestSource.once('remove', function () {
				this.onHitTestSourceRemove(hitTestSource);
				this.fire('hittest:remove', hitTestSource);
			}, this);
		};
		_proto.onHitTestSourceRemove = function onHitTestSourceRemove(hitTestSource) {
			this.hitTestSourcesSet.delete(hitTestSource);
			var ind = this._hitTestSources.indexOf(hitTestSource);
			if (ind !== -1) this._hitTestSources.splice(ind, 1);
		};
		_createClass(XrInputSource, [{
			key: "id",
			get: function get() {
				return this._id;
			}
		}, {
			key: "inputSource",
			get: function get() {
				return this._xrInputSource;
			}
		}, {
			key: "targetRayMode",
			get: function get() {
				return this._xrInputSource.targetRayMode;
			}
		}, {
			key: "handedness",
			get: function get() {
				return this._xrInputSource.handedness;
			}
		}, {
			key: "profiles",
			get: function get() {
				return this._xrInputSource.profiles;
			}
		}, {
			key: "grip",
			get: function get() {
				return this._grip;
			}
		}, {
			key: "hand",
			get: function get() {
				return this._hand;
			}
		}, {
			key: "gamepad",
			get: function get() {
				return this._xrInputSource.gamepad || null;
			}
		}, {
			key: "selecting",
			get: function get() {
				return this._selecting;
			}
		}, {
			key: "squeezing",
			get: function get() {
				return this._squeezing;
			}
		}, {
			key: "elementInput",
			get: function get() {
				return this._elementInput;
			},
			set: function set(value) {
				if (this._elementInput === value) return;
				this._elementInput = value;
				if (!this._elementInput) this._elementEntity = null;
			}
		}, {
			key: "elementEntity",
			get: function get() {
				return this._elementEntity;
			}
		}, {
			key: "hitTestSources",
			get: function get() {
				return this._hitTestSources;
			}
		}]);
		return XrInputSource;
	}(EventHandler);

	var XrInput = function (_EventHandler) {
		_inheritsLoose(XrInput, _EventHandler);
		function XrInput(manager) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this.manager = void 0;
			_this._inputSources = [];
			_this._onInputSourcesChangeEvt = void 0;
			_this.manager = manager;
			_this._onInputSourcesChangeEvt = function (evt) {
				_this._onInputSourcesChange(evt);
			};
			_this.manager.on('start', _this._onSessionStart, _assertThisInitialized(_this));
			_this.manager.on('end', _this._onSessionEnd, _assertThisInitialized(_this));
			return _this;
		}
		var _proto = XrInput.prototype;
		_proto._onSessionStart = function _onSessionStart() {
			var _this2 = this;
			var session = this.manager.session;
			session.addEventListener('inputsourceschange', this._onInputSourcesChangeEvt);
			session.addEventListener('select', function (evt) {
				var inputSource = _this2._getByInputSource(evt.inputSource);
				inputSource.update(evt.frame);
				inputSource.fire('select', evt);
				_this2.fire('select', inputSource, evt);
			});
			session.addEventListener('selectstart', function (evt) {
				var inputSource = _this2._getByInputSource(evt.inputSource);
				inputSource.update(evt.frame);
				inputSource._selecting = true;
				inputSource.fire('selectstart', evt);
				_this2.fire('selectstart', inputSource, evt);
			});
			session.addEventListener('selectend', function (evt) {
				var inputSource = _this2._getByInputSource(evt.inputSource);
				inputSource.update(evt.frame);
				inputSource._selecting = false;
				inputSource.fire('selectend', evt);
				_this2.fire('selectend', inputSource, evt);
			});
			session.addEventListener('squeeze', function (evt) {
				var inputSource = _this2._getByInputSource(evt.inputSource);
				inputSource.update(evt.frame);
				inputSource.fire('squeeze', evt);
				_this2.fire('squeeze', inputSource, evt);
			});
			session.addEventListener('squeezestart', function (evt) {
				var inputSource = _this2._getByInputSource(evt.inputSource);
				inputSource.update(evt.frame);
				inputSource._squeezing = true;
				inputSource.fire('squeezestart', evt);
				_this2.fire('squeezestart', inputSource, evt);
			});
			session.addEventListener('squeezeend', function (evt) {
				var inputSource = _this2._getByInputSource(evt.inputSource);
				inputSource.update(evt.frame);
				inputSource._squeezing = false;
				inputSource.fire('squeezeend', evt);
				_this2.fire('squeezeend', inputSource, evt);
			});
			var inputSources = session.inputSources;
			for (var i = 0; i < inputSources.length; i++) {
				this._addInputSource(inputSources[i]);
			}
		};
		_proto._onSessionEnd = function _onSessionEnd() {
			var i = this._inputSources.length;
			while (i--) {
				var inputSource = this._inputSources[i];
				this._inputSources.splice(i, 1);
				inputSource.fire('remove');
				this.fire('remove', inputSource);
			}
			var session = this.manager.session;
			session.removeEventListener('inputsourceschange', this._onInputSourcesChangeEvt);
		};
		_proto._onInputSourcesChange = function _onInputSourcesChange(evt) {
			for (var i = 0; i < evt.removed.length; i++) {
				this._removeInputSource(evt.removed[i]);
			}
			for (var _i = 0; _i < evt.added.length; _i++) {
				this._addInputSource(evt.added[_i]);
			}
		};
		_proto._getByInputSource = function _getByInputSource(xrInputSource) {
			for (var i = 0; i < this._inputSources.length; i++) {
				if (this._inputSources[i].inputSource === xrInputSource) {
					return this._inputSources[i];
				}
			}
			return null;
		};
		_proto._addInputSource = function _addInputSource(xrInputSource) {
			if (this._getByInputSource(xrInputSource)) return;
			var inputSource = new XrInputSource(this.manager, xrInputSource);
			this._inputSources.push(inputSource);
			this.fire('add', inputSource);
		};
		_proto._removeInputSource = function _removeInputSource(xrInputSource) {
			for (var i = 0; i < this._inputSources.length; i++) {
				if (this._inputSources[i].inputSource !== xrInputSource) continue;
				var inputSource = this._inputSources[i];
				this._inputSources.splice(i, 1);
				var h = inputSource.hitTestSources.length;
				while (h--) {
					inputSource.hitTestSources[h].remove();
				}
				inputSource.fire('remove');
				this.fire('remove', inputSource);
				return;
			}
		};
		_proto.update = function update(frame) {
			for (var i = 0; i < this._inputSources.length; i++) {
				this._inputSources[i].update(frame);
			}
		};
		_createClass(XrInput, [{
			key: "inputSources",
			get: function get() {
				return this._inputSources;
			}
		}]);
		return XrInput;
	}(EventHandler);

	var vec3A = new Vec3();
	var vec3B = new Vec3();
	var mat4A = new Mat4();
	var mat4B = new Mat4();
	var XrLightEstimation = function (_EventHandler) {
		_inheritsLoose(XrLightEstimation, _EventHandler);
		function XrLightEstimation(manager) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this._manager = void 0;
			_this._supported = false;
			_this._available = false;
			_this._lightProbeRequested = false;
			_this._lightProbe = null;
			_this._intensity = 0;
			_this._rotation = new Quat();
			_this._color = new Color();
			_this._sphericalHarmonics = new Float32Array(27);
			_this._manager = manager;
			_this._manager.on('start', _this._onSessionStart, _assertThisInitialized(_this));
			_this._manager.on('end', _this._onSessionEnd, _assertThisInitialized(_this));
			return _this;
		}
		var _proto = XrLightEstimation.prototype;
		_proto._onSessionStart = function _onSessionStart() {
			var supported = !!this._manager.session.requestLightProbe;
			if (!supported) return;
			this._supported = true;
		};
		_proto._onSessionEnd = function _onSessionEnd() {
			this._supported = false;
			this._available = false;
			this._lightProbeRequested = false;
			this._lightProbe = null;
		};
		_proto.start = function start() {
			var _this2 = this;
			var err;
			if (!this._manager.session) err = new Error('XR session is not running');
			if (!err && this._manager.type !== XRTYPE_AR) err = new Error('XR session type is not AR');
			if (!err && !this._supported) err = new Error('light-estimation is not supported');
			if (!err && this._lightProbe || this._lightProbeRequested) err = new Error('light estimation is already requested');
			if (err) {
				this.fire('error', err);
				return;
			}
			this._lightProbeRequested = true;
			this._manager.session.requestLightProbe().then(function (lightProbe) {
				var wasRequested = _this2._lightProbeRequested;
				_this2._lightProbeRequested = false;
				if (_this2._manager.active) {
					if (wasRequested) {
						_this2._lightProbe = lightProbe;
					}
				} else {
					_this2.fire('error', new Error('XR session is not active'));
				}
			}).catch(function (ex) {
				_this2._lightProbeRequested = false;
				_this2.fire('error', ex);
			});
		};
		_proto.end = function end() {
			this._lightProbeRequested = false;
			this._lightProbe = null;
			this._available = false;
		};
		_proto.update = function update(frame) {
			if (!this._lightProbe) return;
			var lightEstimate = frame.getLightEstimate(this._lightProbe);
			if (!lightEstimate) return;
			if (!this._available) {
				this._available = true;
				this.fire('available');
			}
			var pli = lightEstimate.primaryLightIntensity;
			this._intensity = Math.max(1.0, Math.max(pli.x, Math.max(pli.y, pli.z)));
			vec3A.copy(pli).mulScalar(1 / this._intensity);
			this._color.set(vec3A.x, vec3A.y, vec3A.z);
			vec3A.set(0, 0, 0);
			vec3B.copy(lightEstimate.primaryLightDirection);
			mat4A.setLookAt(vec3B, vec3A, Vec3.UP);
			mat4B.setFromAxisAngle(Vec3.RIGHT, 90);
			mat4A.mul(mat4B);
			this._rotation.setFromMat4(mat4A);
			this._sphericalHarmonics.set(lightEstimate.sphericalHarmonicsCoefficients);
		};
		_createClass(XrLightEstimation, [{
			key: "supported",
			get: function get() {
				return this._supported;
			}
		}, {
			key: "available",
			get: function get() {
				return this._available;
			}
		}, {
			key: "intensity",
			get: function get() {
				return this._available ? this._intensity : null;
			}
		}, {
			key: "color",
			get: function get() {
				return this._available ? this._color : null;
			}
		}, {
			key: "rotation",
			get: function get() {
				return this._available ? this._rotation : null;
			}
		}, {
			key: "sphericalHarmonics",
			get: function get() {
				return this._available ? this._sphericalHarmonics : null;
			}
		}]);
		return XrLightEstimation;
	}(EventHandler);

	var ids = 0;
	var XrPlane = function (_EventHandler) {
		_inheritsLoose(XrPlane, _EventHandler);
		function XrPlane(planeDetection, xrPlane) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this._id = void 0;
			_this._planeDetection = void 0;
			_this._xrPlane = void 0;
			_this._lastChangedTime = void 0;
			_this._orientation = void 0;
			_this._position = new Vec3();
			_this._rotation = new Quat();
			_this._id = ++ids;
			_this._planeDetection = planeDetection;
			_this._xrPlane = xrPlane;
			_this._lastChangedTime = xrPlane.lastChangedTime;
			_this._orientation = xrPlane.orientation;
			return _this;
		}
		var _proto = XrPlane.prototype;
		_proto.destroy = function destroy() {
			if (!this._xrPlane) return;
			this._xrPlane = null;
			this.fire('remove');
		};
		_proto.update = function update(frame) {
			var manager = this._planeDetection._manager;
			var pose = frame.getPose(this._xrPlane.planeSpace, manager._referenceSpace);
			if (pose) {
				this._position.copy(pose.transform.position);
				this._rotation.copy(pose.transform.orientation);
			}
			if (this._lastChangedTime !== this._xrPlane.lastChangedTime) {
				this._lastChangedTime = this._xrPlane.lastChangedTime;
				this.fire('change');
			}
		};
		_proto.getPosition = function getPosition() {
			return this._position;
		};
		_proto.getRotation = function getRotation() {
			return this._rotation;
		};
		_createClass(XrPlane, [{
			key: "id",
			get: function get() {
				return this._id;
			}
		}, {
			key: "orientation",
			get: function get() {
				return this._orientation;
			}
		}, {
			key: "points",
			get: function get() {
				return this._xrPlane.polygon;
			}
		}, {
			key: "label",
			get: function get() {
				return this._xrPlane.semanticLabel || '';
			}
		}]);
		return XrPlane;
	}(EventHandler);

	var XrPlaneDetection = function (_EventHandler) {
		_inheritsLoose(XrPlaneDetection, _EventHandler);
		function XrPlaneDetection(manager) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this._manager = void 0;
			_this._supported = platform.browser && !!window.XRPlane;
			_this._available = false;
			_this._planesIndex = new Map();
			_this._planes = [];
			_this._manager = manager;
			if (_this._supported) {
				_this._manager.on('start', _this._onSessionStart, _assertThisInitialized(_this));
				_this._manager.on('end', _this._onSessionEnd, _assertThisInitialized(_this));
			}
			return _this;
		}
		var _proto = XrPlaneDetection.prototype;
		_proto._onSessionStart = function _onSessionStart() {
			var available = this._supported && this._manager.session.enabledFeatures.indexOf('plane-detection') !== -1;
			if (available) {
				this._available = true;
				this.fire('available');
			}
		};
		_proto._onSessionEnd = function _onSessionEnd() {
			for (var i = 0; i < this._planes.length; i++) {
				this._planes[i].destroy();
				this.fire('remove', this._planes[i]);
			}
			this._planesIndex.clear();
			this._planes.length = 0;
			if (this._available) {
				this._available = false;
				this.fire('unavailable');
			}
		};
		_proto.update = function update(frame) {
			if (!this._supported || !this._available) return;
			var detectedPlanes = frame.detectedPlanes;
			for (var _iterator = _createForOfIteratorHelperLoose(this._planesIndex), _step; !(_step = _iterator()).done;) {
				var _step$value = _step.value,
					xrPlane = _step$value[0],
					plane = _step$value[1];
				if (detectedPlanes.has(xrPlane)) continue;
				this._planesIndex.delete(xrPlane);
				this._planes.splice(this._planes.indexOf(plane), 1);
				plane.destroy();
				this.fire('remove', plane);
			}
			for (var _iterator2 = _createForOfIteratorHelperLoose(detectedPlanes), _step2; !(_step2 = _iterator2()).done;) {
				var _xrPlane = _step2.value;
				var _plane = this._planesIndex.get(_xrPlane);
				if (!_plane) {
					_plane = new XrPlane(this, _xrPlane);
					this._planesIndex.set(_xrPlane, _plane);
					this._planes.push(_plane);
					_plane.update(frame);
					this.fire('add', _plane);
				} else {
					_plane.update(frame);
				}
			}
		};
		_createClass(XrPlaneDetection, [{
			key: "supported",
			get: function get() {
				return this._supported;
			}
		}, {
			key: "available",
			get: function get() {
				return this._available;
			}
		}, {
			key: "planes",
			get: function get() {
				return this._planes;
			}
		}]);
		return XrPlaneDetection;
	}(EventHandler);

	var XrAnchor = function (_EventHandler) {
		_inheritsLoose(XrAnchor, _EventHandler);
		function XrAnchor(anchors, xrAnchor, uuid) {
			var _this;
			if (uuid === void 0) {
				uuid = null;
			}
			_this = _EventHandler.call(this) || this;
			_this._position = new Vec3();
			_this._rotation = new Quat();
			_this._uuid = null;
			_this._uuidRequests = null;
			_this._anchors = anchors;
			_this._xrAnchor = xrAnchor;
			_this._uuid = uuid;
			return _this;
		}
		var _proto = XrAnchor.prototype;
		_proto.destroy = function destroy() {
			if (!this._xrAnchor) return;
			var xrAnchor = this._xrAnchor;
			this._xrAnchor.delete();
			this._xrAnchor = null;
			this.fire('destroy', xrAnchor, this);
		};
		_proto.update = function update(frame) {
			if (!this._xrAnchor) return;
			var pose = frame.getPose(this._xrAnchor.anchorSpace, this._anchors.manager._referenceSpace);
			if (pose) {
				if (this._position.equals(pose.transform.position) && this._rotation.equals(pose.transform.orientation)) return;
				this._position.copy(pose.transform.position);
				this._rotation.copy(pose.transform.orientation);
				this.fire('change');
			}
		};
		_proto.getPosition = function getPosition() {
			return this._position;
		};
		_proto.getRotation = function getRotation() {
			return this._rotation;
		};
		_proto.persist = function persist(callback) {
			var _this2 = this;
			if (!this._anchors.persistence) {
				callback == null || callback(new Error('Persistent Anchors are not supported'), null);
				return;
			}
			if (this._uuid) {
				callback == null || callback(null, this._uuid);
				return;
			}
			if (this._uuidRequests) {
				if (callback) this._uuidRequests.push(callback);
				return;
			}
			this._uuidRequests = [];
			this._xrAnchor.requestPersistentHandle().then(function (uuid) {
				_this2._uuid = uuid;
				_this2._anchors._indexByUuid.set(_this2._uuid, _this2);
				callback == null || callback(null, uuid);
				for (var i = 0; i < _this2._uuidRequests.length; i++) {
					_this2._uuidRequests[i](null, uuid);
				}
				_this2._uuidRequests = null;
				_this2.fire('persist', uuid);
			}).catch(function (ex) {
				callback == null || callback(ex, null);
				for (var i = 0; i < _this2._uuidRequests.length; i++) {
					_this2._uuidRequests[i](ex);
				}
				_this2._uuidRequests = null;
			});
		};
		_proto.forget = function forget(callback) {
			var _this3 = this;
			if (!this._uuid) {
				callback == null || callback(new Error('Anchor is not persistent'));
				return;
			}
			this._anchors.forget(this._uuid, function (ex) {
				_this3._uuid = null;
				callback == null || callback(ex);
				_this3.fire('forget');
			});
		};
		_createClass(XrAnchor, [{
			key: "uuid",
			get: function get() {
				return this._uuid;
			}
		}, {
			key: "persistent",
			get: function get() {
				return !!this._uuid;
			}
		}]);
		return XrAnchor;
	}(EventHandler);

	var XrAnchors = function (_EventHandler) {
		_inheritsLoose(XrAnchors, _EventHandler);
		function XrAnchors(manager) {
			var _window;
			var _this;
			_this = _EventHandler.call(this) || this;
			_this._supported = platform.browser && !!window.XRAnchor;
			_this._persistence = platform.browser && !!((_window = window) != null && (_window = _window.XRSession) != null && _window.prototype.restorePersistentAnchor);
			_this._creationQueue = [];
			_this._index = new Map();
			_this._indexByUuid = new Map();
			_this._list = [];
			_this._callbacksAnchors = new Map();
			_this.manager = manager;
			if (_this._supported) {
				_this.manager.on('end', _this._onSessionEnd, _assertThisInitialized(_this));
			}
			return _this;
		}
		var _proto = XrAnchors.prototype;
		_proto._onSessionEnd = function _onSessionEnd() {
			for (var _i = 0; _i < this._creationQueue.length; _i++) {
				if (!this._creationQueue[_i].callback) continue;
				this._creationQueue[_i].callback(new Error('session ended'), null);
			}
			this._creationQueue.length = 0;
			this._index.clear();
			this._indexByUuid.clear();
			var i = this._list.length;
			while (i--) {
				this._list[i].destroy();
			}
			this._list.length = 0;
		};
		_proto._createAnchor = function _createAnchor(xrAnchor, uuid) {
			if (uuid === void 0) {
				uuid = null;
			}
			var anchor = new XrAnchor(this, xrAnchor, uuid);
			this._index.set(xrAnchor, anchor);
			if (uuid) this._indexByUuid.set(uuid, anchor);
			this._list.push(anchor);
			anchor.once('destroy', this._onAnchorDestroy, this);
			return anchor;
		};
		_proto._onAnchorDestroy = function _onAnchorDestroy(xrAnchor, anchor) {
			this._index.delete(xrAnchor);
			if (anchor.uuid) this._indexByUuid.delete(anchor.uuid);
			var ind = this._list.indexOf(anchor);
			if (ind !== -1) this._list.splice(ind, 1);
			this.fire('destroy', anchor);
		};
		_proto.create = function create(position, rotation, callback) {
			var _this2 = this;
			if (window.XRHitTestResult && position instanceof XRHitTestResult) {
				var hitResult = position;
				callback = rotation;
				if (!this._supported) {
					callback == null || callback(new Error('Anchors API is not supported'), null);
					return;
				}
				if (!hitResult.createAnchor) {
					callback == null || callback(new Error('Creating Anchor from Hit Test is not supported'), null);
					return;
				}
				hitResult.createAnchor().then(function (xrAnchor) {
					var anchor = _this2._createAnchor(xrAnchor);
					callback == null || callback(null, anchor);
					_this2.fire('add', anchor);
				}).catch(function (ex) {
					callback == null || callback(ex, null);
					_this2.fire('error', ex);
				});
			} else {
				this._creationQueue.push({
					transform: new XRRigidTransform(position, rotation),
					callback: callback
				});
			}
		};
		_proto.restore = function restore(uuid, callback) {
			var _this3 = this;
			if (!this._persistence) {
				callback == null || callback(new Error('Anchor Persistence is not supported'), null);
				return;
			}
			if (!this.manager.active) {
				callback == null || callback(new Error('WebXR session is not active'), null);
				return;
			}
			this.manager.session.restorePersistentAnchor(uuid).then(function (xrAnchor) {
				var anchor = _this3._createAnchor(xrAnchor, uuid);
				callback == null || callback(null, anchor);
				_this3.fire('add', anchor);
			}).catch(function (ex) {
				callback == null || callback(ex, null);
				_this3.fire('error', ex);
			});
		};
		_proto.forget = function forget(uuid, callback) {
			var _this4 = this;
			if (!this._persistence) {
				callback == null || callback(new Error('Anchor Persistence is not supported'));
				return;
			}
			if (!this.manager.active) {
				callback == null || callback(new Error('WebXR session is not active'));
				return;
			}
			this.manager.session.deletePersistentAnchor(uuid).then(function () {
				callback == null || callback(null);
			}).catch(function (ex) {
				callback == null || callback(ex);
				_this4.fire('error', ex);
			});
		};
		_proto.update = function update(frame) {
			var _this5 = this;
			if (this._creationQueue.length) {
				var _loop = function _loop() {
					var request = _this5._creationQueue[i];
					frame.createAnchor(request.transform, _this5.manager._referenceSpace).then(function (xrAnchor) {
						if (request.callback) _this5._callbacksAnchors.set(xrAnchor, request.callback);
					}).catch(function (ex) {
						if (request.callback) request.callback(ex, null);
						_this5.fire('error', ex);
					});
				};
				for (var i = 0; i < this._creationQueue.length; i++) {
					_loop();
				}
				this._creationQueue.length = 0;
			}
			for (var _iterator = _createForOfIteratorHelperLoose(this._index), _step; !(_step = _iterator()).done;) {
				var _step$value = _step.value,
					xrAnchor = _step$value[0],
					anchor = _step$value[1];
				if (frame.trackedAnchors.has(xrAnchor)) continue;
				this._index.delete(xrAnchor);
				anchor.destroy();
			}
			for (var _i2 = 0; _i2 < this._list.length; _i2++) {
				this._list[_i2].update(frame);
			}
			for (var _iterator2 = _createForOfIteratorHelperLoose(frame.trackedAnchors), _step2; !(_step2 = _iterator2()).done;) {
				var _xrAnchor = _step2.value;
				if (this._index.has(_xrAnchor)) continue;
				try {
					var tmp = _xrAnchor.anchorSpace;
				} catch (ex) {
					continue;
				}
				var _anchor = this._createAnchor(_xrAnchor);
				_anchor.update(frame);
				var callback = this._callbacksAnchors.get(_xrAnchor);
				if (callback) {
					this._callbacksAnchors.delete(_xrAnchor);
					callback(null, _anchor);
				}
				this.fire('add', _anchor);
			}
		};
		_createClass(XrAnchors, [{
			key: "supported",
			get: function get() {
				return this._supported;
			}
		}, {
			key: "persistence",
			get: function get() {
				return this._persistence;
			}
		}, {
			key: "uuids",
			get: function get() {
				if (!this._persistence) return null;
				if (!this.manager.active) return null;
				return this.manager.session.persistentAnchors;
			}
		}, {
			key: "list",
			get: function get() {
				return this._list;
			}
		}]);
		return XrAnchors;
	}(EventHandler);

	var XrManager = function (_EventHandler) {
		_inheritsLoose(XrManager, _EventHandler);
		function XrManager(app) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this.app = void 0;
			_this._supported = platform.browser && !!navigator.xr;
			_this._available = {};
			_this._type = null;
			_this._spaceType = null;
			_this._session = null;
			_this._baseLayer = null;
			_this._referenceSpace = null;
			_this.depthSensing = void 0;
			_this.domOverlay = void 0;
			_this.hitTest = void 0;
			_this.imageTracking = void 0;
			_this.planeDetection = void 0;
			_this.input = void 0;
			_this.lightEstimation = void 0;
			_this.anchors = void 0;
			_this._camera = null;
			_this.views = [];
			_this.viewsPool = [];
			_this._localPosition = new Vec3();
			_this._localRotation = new Quat();
			_this._depthNear = 0.1;
			_this._depthFar = 1000;
			_this._width = 0;
			_this._height = 0;
			_this.app = app;
			_this._available[XRTYPE_INLINE] = false;
			_this._available[XRTYPE_VR] = false;
			_this._available[XRTYPE_AR] = false;
			_this.depthSensing = new XrDepthSensing(_assertThisInitialized(_this));
			_this.domOverlay = new XrDomOverlay(_assertThisInitialized(_this));
			_this.hitTest = new XrHitTest(_assertThisInitialized(_this));
			_this.imageTracking = new XrImageTracking(_assertThisInitialized(_this));
			_this.planeDetection = new XrPlaneDetection(_assertThisInitialized(_this));
			_this.input = new XrInput(_assertThisInitialized(_this));
			_this.lightEstimation = new XrLightEstimation(_assertThisInitialized(_this));
			_this.anchors = new XrAnchors(_assertThisInitialized(_this));
			if (_this._supported) {
				navigator.xr.addEventListener('devicechange', function () {
					_this._deviceAvailabilityCheck();
				});
				_this._deviceAvailabilityCheck();
			}
			return _this;
		}
		var _proto = XrManager.prototype;
		_proto.destroy = function destroy() {
			this.depthSensing.destroy();
			this.depthSensing = null;
		};
		_proto.start = function start(camera, type, spaceType, options) {
			var _this2 = this;
			var callback = options;
			if (typeof options === 'object') callback = options.callback;
			if (!this._available[type]) {
				if (callback) callback(new Error('XR is not available'));
				return;
			}
			if (this._session) {
				if (callback) callback(new Error('XR session is already started'));
				return;
			}
			this._camera = camera;
			this._camera.camera.xr = this;
			this._type = type;
			this._spaceType = spaceType;
			this._setClipPlanes(camera.nearClip, camera.farClip);
			var opts = {
				requiredFeatures: [spaceType],
				optionalFeatures: []
			};
			if (type === XRTYPE_AR) {
				opts.optionalFeatures.push('light-estimation');
				opts.optionalFeatures.push('hit-test');
				if (options) {
					if (options.imageTracking && this.imageTracking.supported) opts.optionalFeatures.push('image-tracking');
					if (options.planeDetection) opts.optionalFeatures.push('plane-detection');
				}
				if (this.domOverlay.supported && this.domOverlay.root) {
					opts.optionalFeatures.push('dom-overlay');
					opts.domOverlay = {
						root: this.domOverlay.root
					};
				}
				if (options && options.anchors && this.anchors.supported) {
					opts.optionalFeatures.push('anchors');
				}
				if (options && options.depthSensing && this.depthSensing.supported) {
					opts.optionalFeatures.push('depth-sensing');
					var usagePreference = [XRDEPTHSENSINGUSAGE_CPU];
					var dataFormatPreference = [XRDEPTHSENSINGFORMAT_L8A8];
					if (options.depthSensing.usagePreference) {
						var ind = usagePreference.indexOf(options.depthSensing.usagePreference);
						if (ind !== -1) usagePreference.splice(ind, 1);
						usagePreference.unshift(options.depthSensing.usagePreference);
					}
					if (options.depthSensing.dataFormatPreference) {
						var _ind = dataFormatPreference.indexOf(options.depthSensing.dataFormatPreference);
						if (_ind !== -1) dataFormatPreference.splice(_ind, 1);
						dataFormatPreference.unshift(options.depthSensing.dataFormatPreference);
					}
					opts.depthSensing = {
						usagePreference: usagePreference,
						dataFormatPreference: dataFormatPreference
					};
				}
			} else if (type === XRTYPE_VR) {
				opts.optionalFeatures.push('hand-tracking');
			}
			if (options && options.optionalFeatures) opts.optionalFeatures = opts.optionalFeatures.concat(options.optionalFeatures);
			if (this.imageTracking.supported && this.imageTracking.images.length) {
				this.imageTracking.prepareImages(function (err, trackedImages) {
					if (err) {
						if (callback) callback(err);
						_this2.fire('error', err);
						return;
					}
					if (trackedImages !== null) opts.trackedImages = trackedImages;
					_this2._onStartOptionsReady(type, spaceType, opts, callback);
				});
			} else {
				this._onStartOptionsReady(type, spaceType, opts, callback);
			}
		};
		_proto._onStartOptionsReady = function _onStartOptionsReady(type, spaceType, options, callback) {
			var _this3 = this;
			navigator.xr.requestSession(type, options).then(function (session) {
				_this3._onSessionStart(session, spaceType, callback);
			}).catch(function (ex) {
				_this3._camera.camera.xr = null;
				_this3._camera = null;
				_this3._type = null;
				_this3._spaceType = null;
				if (callback) callback(ex);
				_this3.fire('error', ex);
			});
		};
		_proto.end = function end(callback) {
			if (!this._session) {
				if (callback) callback(new Error('XR Session is not initialized'));
				return;
			}
			if (callback) this.once('end', callback);
			this._session.end();
		};
		_proto.isAvailable = function isAvailable(type) {
			return this._available[type];
		};
		_proto._deviceAvailabilityCheck = function _deviceAvailabilityCheck() {
			for (var key in this._available) {
				this._sessionSupportCheck(key);
			}
		};
		_proto.initiateRoomCapture = function initiateRoomCapture(callback) {
			if (!this._session) {
				callback(new Error('Session is not active'));
				return;
			}
			if (!this._session.initiateRoomCapture) {
				callback(new Error('Session does not support manual room capture'));
				return;
			}
			this._session.initiateRoomCapture().then(function () {
				if (callback) callback(null);
			}).catch(function (err) {
				if (callback) callback(err);
			});
		};
		_proto._sessionSupportCheck = function _sessionSupportCheck(type) {
			var _this4 = this;
			navigator.xr.isSessionSupported(type).then(function (available) {
				if (_this4._available[type] === available) return;
				_this4._available[type] = available;
				_this4.fire('available', type, available);
				_this4.fire('available:' + type, available);
			}).catch(function (ex) {
				_this4.fire('error', ex);
			});
		};
		_proto._onSessionStart = function _onSessionStart(session, spaceType, callback) {
			var _this5 = this;
			var failed = false;
			this._session = session;
			var onVisibilityChange = function onVisibilityChange() {
				_this5.fire('visibility:change', session.visibilityState);
			};
			var onClipPlanesChange = function onClipPlanesChange() {
				_this5._setClipPlanes(_this5._camera.nearClip, _this5._camera.farClip);
			};
			var onEnd = function onEnd() {
				if (_this5._camera) {
					_this5._camera.off('set_nearClip', onClipPlanesChange);
					_this5._camera.off('set_farClip', onClipPlanesChange);
					_this5._camera.camera.xr = null;
					_this5._camera = null;
				}
				session.removeEventListener('end', onEnd);
				session.removeEventListener('visibilitychange', onVisibilityChange);
				if (!failed) _this5.fire('end');
				_this5._session = null;
				_this5._referenceSpace = null;
				_this5.views = [];
				_this5._width = 0;
				_this5._height = 0;
				_this5._type = null;
				_this5._spaceType = null;
				_this5.app.tick();
			};
			session.addEventListener('end', onEnd);
			session.addEventListener('visibilitychange', onVisibilityChange);
			this._camera.on('set_nearClip', onClipPlanesChange);
			this._camera.on('set_farClip', onClipPlanesChange);
			var framebufferScaleFactor = this.app.graphicsDevice.maxPixelRatio / window.devicePixelRatio;
			this._baseLayer = new XRWebGLLayer(session, this.app.graphicsDevice.gl, {
				alpha: true,
				depth: true,
				stencil: true,
				framebufferScaleFactor: framebufferScaleFactor,
				antialias: false
			});
			session.updateRenderState({
				baseLayer: this._baseLayer,
				depthNear: this._depthNear,
				depthFar: this._depthFar
			});
			session.requestReferenceSpace(spaceType).then(function (referenceSpace) {
				_this5._referenceSpace = referenceSpace;
				_this5.app.tick();
				if (callback) callback(null);
				_this5.fire('start');
			}).catch(function (ex) {
				failed = true;
				session.end();
				if (callback) callback(ex);
				_this5.fire('error', ex);
			});
		};
		_proto._setClipPlanes = function _setClipPlanes(near, far) {
			if (this._depthNear === near && this._depthFar === far) return;
			this._depthNear = near;
			this._depthFar = far;
			if (!this._session) return;
			this._session.updateRenderState({
				depthNear: this._depthNear,
				depthFar: this._depthFar
			});
		};
		_proto.update = function update(frame) {
			if (!this._session) return false;
			var width = frame.session.renderState.baseLayer.framebufferWidth;
			var height = frame.session.renderState.baseLayer.framebufferHeight;
			if (this._width !== width || this._height !== height) {
				this._width = width;
				this._height = height;
				this.app.graphicsDevice.setResolution(width, height);
			}
			var pose = frame.getViewerPose(this._referenceSpace);
			if (!pose) return false;
			var lengthOld = this.views.length;
			var lengthNew = pose.views.length;
			while (lengthNew > this.views.length) {
				var view = this.viewsPool.pop();
				if (!view) {
					view = {
						viewport: new Vec4(),
						projMat: new Mat4(),
						viewMat: new Mat4(),
						viewOffMat: new Mat4(),
						viewInvMat: new Mat4(),
						viewInvOffMat: new Mat4(),
						projViewOffMat: new Mat4(),
						viewMat3: new Mat3(),
						position: new Float32Array(3),
						rotation: new Quat()
					};
				}
				this.views.push(view);
			}
			while (lengthNew < this.views.length) {
				this.viewsPool.push(this.views.pop());
			}
			var posePosition = pose.transform.position;
			var poseOrientation = pose.transform.orientation;
			this._localPosition.set(posePosition.x, posePosition.y, posePosition.z);
			this._localRotation.set(poseOrientation.x, poseOrientation.y, poseOrientation.z, poseOrientation.w);
			var layer = frame.session.renderState.baseLayer;
			for (var i = 0; i < pose.views.length; i++) {
				var viewRaw = pose.views[i];
				var _view = this.views[i];
				var viewport = layer.getViewport(viewRaw);
				_view.viewport.x = viewport.x;
				_view.viewport.y = viewport.y;
				_view.viewport.z = viewport.width;
				_view.viewport.w = viewport.height;
				_view.projMat.set(viewRaw.projectionMatrix);
				_view.viewMat.set(viewRaw.transform.inverse.matrix);
				_view.viewInvMat.set(viewRaw.transform.matrix);
			}
			if (lengthOld === 0 && this.views.length > 0) {
				var viewProjMat = new Mat4();
				var _view2 = this.views[0];
				viewProjMat.copy(_view2.projMat);
				var data = viewProjMat.data;
				var fov = 2.0 * Math.atan(1.0 / data[5]) * 180.0 / Math.PI;
				var aspectRatio = data[5] / data[0];
				var farClip = data[14] / (data[10] + 1);
				var nearClip = data[14] / (data[10] - 1);
				var horizontalFov = false;
				var camera = this._camera.camera;
				camera.setXrProperties({
					aspectRatio: aspectRatio,
					farClip: farClip,
					fov: fov,
					horizontalFov: horizontalFov,
					nearClip: nearClip
				});
			}
			this._camera.camera._node.setLocalPosition(this._localPosition);
			this._camera.camera._node.setLocalRotation(this._localRotation);
			this.input.update(frame);
			if (this._type === XRTYPE_AR) {
				if (this.hitTest.supported) this.hitTest.update(frame);
				if (this.lightEstimation.supported) this.lightEstimation.update(frame);
				if (this.depthSensing.supported) this.depthSensing.update(frame, pose && pose.views[0]);
				if (this.imageTracking.supported) this.imageTracking.update(frame);
				if (this.anchors.supported) this.anchors.update(frame);
				if (this.planeDetection.supported) this.planeDetection.update(frame);
			}
			this.fire('update', frame);
			return true;
		};
		_createClass(XrManager, [{
			key: "supported",
			get: function get() {
				return this._supported;
			}
		}, {
			key: "active",
			get: function get() {
				return !!this._session;
			}
		}, {
			key: "type",
			get: function get() {
				return this._type;
			}
		}, {
			key: "spaceType",
			get: function get() {
				return this._spaceType;
			}
		}, {
			key: "session",
			get: function get() {
				return this._session;
			}
		}, {
			key: "camera",
			get: function get() {
				return this._camera ? this._camera.entity : null;
			}
		}, {
			key: "visibilityState",
			get: function get() {
				if (!this._session) return null;
				return this._session.visibilityState;
			}
		}]);
		return XrManager;
	}(EventHandler);

	var Application = function (_AppBase) {
		_inheritsLoose(Application, _AppBase);
		function Application(canvas, options) {
			var _this;
			if (options === void 0) {
				options = {};
			}
			_this = _AppBase.call(this, canvas) || this;
			var appOptions = new AppOptions();
			appOptions.graphicsDevice = _this.createDevice(canvas, options);
			_this.addComponentSystems(appOptions);
			_this.addResourceHandles(appOptions);
			appOptions.elementInput = options.elementInput;
			appOptions.keyboard = options.keyboard;
			appOptions.mouse = options.mouse;
			appOptions.touch = options.touch;
			appOptions.gamepads = options.gamepads;
			appOptions.scriptPrefix = options.scriptPrefix;
			appOptions.assetPrefix = options.assetPrefix;
			appOptions.scriptsOrder = options.scriptsOrder;
			appOptions.soundManager = new SoundManager();
			appOptions.lightmapper = Lightmapper;
			appOptions.batchManager = BatchManager;
			appOptions.xr = XrManager;
			_this.init(appOptions);
			return _this;
		}
		var _proto = Application.prototype;
		_proto.createDevice = function createDevice(canvas, options) {
			if (!options.graphicsDeviceOptions) {
				options.graphicsDeviceOptions = {};
			}
			if (platform.browser && !!navigator.xr) {
				options.graphicsDeviceOptions.xrCompatible = true;
			}
			options.graphicsDeviceOptions.alpha = options.graphicsDeviceOptions.alpha || false;
			return new WebglGraphicsDevice(canvas, options.graphicsDeviceOptions);
		};
		_proto.addComponentSystems = function addComponentSystems(appOptions) {
			appOptions.componentSystems = [RigidBodyComponentSystem, CollisionComponentSystem, JointComponentSystem, AnimationComponentSystem, AnimComponentSystem, ModelComponentSystem, RenderComponentSystem, CameraComponentSystem, LightComponentSystem, script.legacy ? ScriptLegacyComponentSystem : ScriptComponentSystem, AudioSourceComponentSystem, SoundComponentSystem, AudioListenerComponentSystem, ParticleSystemComponentSystem, ScreenComponentSystem, ElementComponentSystem, ButtonComponentSystem, ScrollViewComponentSystem, ScrollbarComponentSystem, SpriteComponentSystem, LayoutGroupComponentSystem, LayoutChildComponentSystem, ZoneComponentSystem];
		};
		_proto.addResourceHandles = function addResourceHandles(appOptions) {
			appOptions.resourceHandlers = [RenderHandler, AnimationHandler, AnimClipHandler, AnimStateGraphHandler, ModelHandler, MaterialHandler, TextureHandler, TextHandler, JsonHandler, AudioHandler, ScriptHandler, SceneHandler, CubemapHandler, HtmlHandler, CssHandler, ShaderHandler, HierarchyHandler, FolderHandler, FontHandler, BinaryHandler, TextureAtlasHandler, SpriteHandler, TemplateHandler, ContainerHandler];
		};
		return Application;
	}(AppBase);

	var AssetListLoader = function (_EventHandler) {
		_inheritsLoose(AssetListLoader, _EventHandler);
		function AssetListLoader(assetList, assetRegistry) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this._assets = new Set();
			_this._loadingAssets = new Set();
			_this._waitingAssets = new Set();
			_this._registry = assetRegistry;
			_this._loading = false;
			_this._loaded = false;
			_this._failed = [];
			assetList.forEach(function (a) {
				if (a instanceof Asset) {
					if (!a.registry) {
						a.registry = assetRegistry;
					}
					_this._assets.add(a);
				} else {
					var asset = assetRegistry.get(a);
					if (asset) {
						_this._assets.add(asset);
					} else {
						_this._waitForAsset(a);
					}
				}
			});
			return _this;
		}
		var _proto = AssetListLoader.prototype;
		_proto.destroy = function destroy() {
			var self = this;
			this._registry.off("load", this._onLoad);
			this._registry.off("error", this._onError);
			this._waitingAssets.forEach(function (id) {
				self._registry.off("add:" + id, this._onAddAsset);
			});
			this.off("progress");
			this.off("load");
		};
		_proto._assetHasDependencies = function _assetHasDependencies(asset) {
			var _asset$file;
			return asset.type === 'model' && ((_asset$file = asset.file) == null ? void 0 : _asset$file.url) && asset.file.url && asset.file.url.match(/.json$/g);
		};
		_proto.load = function load(done, scope) {
			var _this2 = this;
			if (this._loading) {
				return;
			}
			this._loading = true;
			this._callback = done;
			this._scope = scope;
			this._registry.on("load", this._onLoad, this);
			this._registry.on("error", this._onError, this);
			var loadingAssets = false;
			this._assets.forEach(function (asset) {
				if (!asset.loaded) {
					loadingAssets = true;
					if (_this2._assetHasDependencies(asset)) {
						_this2._registry.loadFromUrl(asset.file.url, asset.type, function (err, loadedAsset) {
							if (err) {
								_this2._onError(err, asset);
								return;
							}
							_this2._onLoad(asset);
						});
					}
					_this2._loadingAssets.add(asset);
					_this2._registry.add(asset);
				}
			});
			this._loadingAssets.forEach(function (asset) {
				if (!_this2._assetHasDependencies(asset)) {
					_this2._registry.load(asset);
				}
			});
			if (!loadingAssets && this._waitingAssets.size === 0) {
				this._loadingComplete();
			}
		};
		_proto.ready = function ready(done, scope) {
			if (scope === void 0) {
				scope = this;
			}
			if (this._loaded) {
				done.call(scope, Array.from(this._assets));
			} else {
				this.once("load", function (assets) {
					done.call(scope, assets);
				});
			}
		};
		_proto._loadingComplete = function _loadingComplete() {
			if (this._loaded) return;
			this._loaded = true;
			this._registry.off("load", this._onLoad, this);
			this._registry.off("error", this._onError, this);
			if (this._failed.length) {
				if (this._callback) {
					this._callback.call(this._scope, "Failed to load some assets", this._failed);
				}
				this.fire("error", this._failed);
			} else {
				if (this._callback) {
					this._callback.call(this._scope);
				}
				this.fire("load", Array.from(this._assets));
			}
		};
		_proto._onLoad = function _onLoad(asset) {
			var _this3 = this;
			if (this._loadingAssets.has(asset)) {
				this.fire("progress", asset);
				this._loadingAssets.delete(asset);
			}
			if (this._loadingAssets.size === 0) {
				setTimeout(function () {
					_this3._loadingComplete(_this3._failed);
				}, 0);
			}
		};
		_proto._onError = function _onError(err, asset) {
			var _this4 = this;
			if (this._loadingAssets.has(asset)) {
				this._failed.push(asset);
				this._loadingAssets.delete(asset);
			}
			if (this._loadingAssets.size === 0) {
				setTimeout(function () {
					_this4._loadingComplete(_this4._failed);
				}, 0);
			}
		};
		_proto._onAddAsset = function _onAddAsset(asset) {
			this._waitingAssets.delete(asset);
			this._assets.add(asset);
			if (!asset.loaded) {
				this._loadingAssets.add(asset);
				this._registry.load(asset);
			}
		};
		_proto._waitForAsset = function _waitForAsset(assetId) {
			this._waitingAssets.add(assetId);
			this._registry.once('add:' + assetId, this._onAddAsset, this);
		};
		return AssetListLoader;
	}(EventHandler);

	var MAX_TEXTURE_SIZE = 4096;
	var DEFAULT_TEXTURE_SIZE = 512;
	var Atlas = function () {
		function Atlas(device, width, height, name) {
			this.canvas = document.createElement('canvas');
			this.canvas.width = width;
			this.canvas.height = height;
			this.texture = new Texture(device, {
				name: name,
				format: PIXELFORMAT_RGBA8,
				width: width,
				height: height,
				mipmaps: true,
				minFilter: FILTER_LINEAR_MIPMAP_LINEAR,
				magFilter: FILTER_LINEAR,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE,
				levels: [this.canvas]
			});
			this.ctx = this.canvas.getContext('2d', {
				alpha: true
			});
		}
		var _proto = Atlas.prototype;
		_proto.destroy = function destroy() {
			this.texture.destroy();
		};
		_proto.clear = function clear(clearColor) {
			var _this$canvas = this.canvas,
				width = _this$canvas.width,
				height = _this$canvas.height;
			this.ctx.clearRect(0, 0, width, height);
			this.ctx.fillStyle = clearColor;
			this.ctx.fillRect(0, 0, width, height);
		};
		return Atlas;
	}();
	var CanvasFont = function (_EventHandler) {
		_inheritsLoose(CanvasFont, _EventHandler);
		function CanvasFont(app, options) {
			var _this;
			if (options === void 0) {
				options = {};
			}
			_this = _EventHandler.call(this) || this;
			_this.type = 'bitmap';
			_this.app = app;
			_this.intensity = 0;
			_this.fontWeight = options.fontWeight || 'normal';
			_this.fontSize = parseInt(options.fontSize, 10);
			_this.glyphSize = _this.fontSize;
			_this.fontName = options.fontName || 'Arial';
			_this.color = options.color || new Color(1, 1, 1);
			_this.padding = options.padding || 0;
			_this.width = Math.min(MAX_TEXTURE_SIZE, options.width || DEFAULT_TEXTURE_SIZE);
			_this.height = Math.min(MAX_TEXTURE_SIZE, options.height || DEFAULT_TEXTURE_SIZE);
			_this.atlases = [];
			_this.chars = '';
			_this.data = {};
			return _this;
		}
		var _proto2 = CanvasFont.prototype;
		_proto2.createTextures = function createTextures(text) {
			var _chars = this._normalizeCharsSet(text);
			if (_chars.length !== this.chars.length) {
				this._renderAtlas(_chars);
				return;
			}
			for (var i = 0; i < _chars.length; i++) {
				if (_chars[i] !== this.chars[i]) {
					this._renderAtlas(_chars);
					return;
				}
			}
		};
		_proto2.updateTextures = function updateTextures(text) {
			var _chars = this._normalizeCharsSet(text);
			var newCharsSet = [];
			for (var i = 0; i < _chars.length; i++) {
				var char = _chars[i];
				if (!this.data.chars[char]) {
					newCharsSet.push(char);
				}
			}
			if (newCharsSet.length > 0) {
				this._renderAtlas(this.chars.concat(newCharsSet));
			}
		};
		_proto2.destroy = function destroy() {
			this.atlases.forEach(function (atlas) {
				return atlas.destroy();
			});
			this.chars = null;
			this.color = null;
			this.data = null;
			this.fontName = null;
			this.fontSize = null;
			this.glyphSize = null;
			this.intensity = null;
			this.atlases = null;
			this.type = null;
			this.fontWeight = null;
		};
		_proto2._colorToRgbString = function _colorToRgbString(color, alpha) {
			var str;
			var r = Math.round(255 * color.r);
			var g = Math.round(255 * color.g);
			var b = Math.round(255 * color.b);
			if (alpha) {
				str = "rgba(" + r + ", " + g + ", " + b + ", " + color.a + ")";
			} else {
				str = "rgb(" + r + ", " + g + ", " + b + ")";
			}
			return str;
		};
		_proto2.renderCharacter = function renderCharacter(context, char, x, y, color) {
			context.fillStyle = color;
			context.fillText(char, x, y);
		};
		_proto2._getAtlas = function _getAtlas(index) {
			if (index >= this.atlases.length) {
				this.atlases[index] = new Atlas(this.app.graphicsDevice, this.width, this.height, "font-atlas-" + this.fontName + "-" + index);
			}
			return this.atlases[index];
		};
		_proto2._renderAtlas = function _renderAtlas(charsArray) {
			this.chars = charsArray;
			var w = this.width;
			var h = this.height;
			var color = this._colorToRgbString(this.color, false);
			var a = this.color.a;
			this.color.a = 1 / 255;
			var transparent = this._colorToRgbString(this.color, true);
			this.color.a = a;
			var TEXT_ALIGN = 'center';
			var TEXT_BASELINE = 'alphabetic';
			var atlasIndex = 0;
			var atlas = this._getAtlas(atlasIndex++);
			atlas.clear(transparent);
			this.data = this._createJson(this.chars, this.fontName, w, h);
			var symbols = string.getSymbols(this.chars.join(''));
			var maxHeight = 0;
			var maxDescent = 0;
			var metrics = {};
			for (var i = 0; i < symbols.length; i++) {
				var ch = symbols[i];
				metrics[ch] = this._getTextMetrics(ch);
				maxHeight = Math.max(maxHeight, metrics[ch].height);
				maxDescent = Math.max(maxDescent, metrics[ch].descent);
			}
			this.glyphSize = Math.max(this.glyphSize, maxHeight);
			var sx = this.glyphSize + this.padding * 2;
			var sy = this.glyphSize + this.padding * 2;
			var _xOffset = this.glyphSize / 2 + this.padding;
			var _yOffset = sy - maxDescent - this.padding;
			var _x = 0;
			var _y = 0;
			for (var _i = 0; _i < symbols.length; _i++) {
				var _ch = symbols[_i];
				var code = string.getCodePoint(symbols[_i]);
				var fs = this.fontSize;
				atlas.ctx.font = this.fontWeight + ' ' + fs.toString() + 'px ' + this.fontName;
				atlas.ctx.textAlign = TEXT_ALIGN;
				atlas.ctx.textBaseline = TEXT_BASELINE;
				var width = atlas.ctx.measureText(_ch).width;
				if (width > fs) {
					fs = this.fontSize * this.fontSize / width;
					atlas.ctx.font = this.fontWeight + ' ' + fs.toString() + 'px ' + this.fontName;
					width = this.fontSize;
				}
				this.renderCharacter(atlas.ctx, _ch, _x + _xOffset, _y + _yOffset, color);
				var xoffset = this.padding + (this.glyphSize - width) / 2;
				var yoffset = -this.padding + metrics[_ch].descent - maxDescent;
				var xadvance = width;
				this._addChar(this.data, _ch, code, _x, _y, sx, sy, xoffset, yoffset, xadvance, atlasIndex - 1, w, h);
				_x += sx;
				if (_x + sx > w) {
					_x = 0;
					_y += sy;
					if (_y + sy > h) {
						atlas = this._getAtlas(atlasIndex++);
						atlas.clear(transparent);
						_y = 0;
					}
				}
			}
			this.atlases.splice(atlasIndex).forEach(function (atlas) {
				return atlas.destroy();
			});
			this.atlases.forEach(function (atlas) {
				return atlas.texture.upload();
			});
			this.fire('render');
		};
		_proto2._createJson = function _createJson(chars, fontName, width, height) {
			var base = {
				'version': 3,
				'intensity': this.intensity,
				'info': {
					'face': fontName,
					'width': width,
					'height': height,
					'maps': [{
						'width': width,
						'height': height
					}]
				},
				'chars': {}
			};
			return base;
		};
		_proto2._addChar = function _addChar(json, char, charCode, x, y, w, h, xoffset, yoffset, xadvance, mapNum, mapW, mapH) {
			if (json.info.maps.length < mapNum + 1) {
				json.info.maps.push({
					'width': mapW,
					'height': mapH
				});
			}
			var scale = this.fontSize / 32;
			json.chars[char] = {
				'id': charCode,
				'letter': char,
				'x': x,
				'y': y,
				'width': w,
				'height': h,
				'xadvance': xadvance / scale,
				'xoffset': xoffset / scale,
				'yoffset': (yoffset + this.padding) / scale,
				'scale': scale,
				'range': 1,
				'map': mapNum,
				'bounds': [0, 0, w / scale, h / scale]
			};
		};
		_proto2._normalizeCharsSet = function _normalizeCharsSet(text) {
			var unicodeConverterFunc = this.app.systems.element.getUnicodeConverter();
			if (unicodeConverterFunc) {
				text = unicodeConverterFunc(text);
			}
			var set = {};
			var symbols = string.getSymbols(text);
			for (var i = 0; i < symbols.length; i++) {
				var ch = symbols[i];
				if (set[ch]) continue;
				set[ch] = ch;
			}
			var chars = Object.keys(set);
			return chars.sort();
		};
		_proto2._getTextMetrics = function _getTextMetrics(text) {
			var textSpan = document.createElement('span');
			textSpan.id = 'content-span';
			textSpan.innerHTML = text;
			var block = document.createElement('div');
			block.id = 'content-block';
			block.style.display = 'inline-block';
			block.style.width = '1px';
			block.style.height = '0px';
			var div = document.createElement('div');
			div.appendChild(textSpan);
			div.appendChild(block);
			div.style.font = this.fontSize + 'px ' + this.fontName;
			var body = document.body;
			body.appendChild(div);
			var ascent = -1;
			var descent = -1;
			var height = -1;
			try {
				block.style['vertical-align'] = 'baseline';
				ascent = block.offsetTop - textSpan.offsetTop;
				block.style['vertical-align'] = 'bottom';
				height = block.offsetTop - textSpan.offsetTop;
				descent = height - ascent;
			} finally {
				document.body.removeChild(div);
			}
			return {
				ascent: ascent,
				descent: descent,
				height: height
			};
		};
		_createClass(CanvasFont, [{
			key: "textures",
			get: function get() {
				return this.atlases.map(function (atlas) {
					return atlas.texture;
				});
			}
		}]);
		return CanvasFont;
	}(EventHandler);

	var tempMeshInstances = [];
	var lights = [[], [], []];
	var RenderPassPicker = function (_RenderPass) {
		_inheritsLoose(RenderPassPicker, _RenderPass);
		function RenderPassPicker(device, renderer) {
			var _this;
			_this = _RenderPass.call(this, device) || this;
			_this.pickColor = new Float32Array(4);
			_this.renderer = renderer;
			return _this;
		}
		var _proto = RenderPassPicker.prototype;
		_proto.update = function update(camera, scene, layers, mapping) {
			this.camera = camera;
			this.scene = scene;
			this.layers = layers;
			this.mapping = mapping;
		};
		_proto.execute = function execute() {
			var device = this.device;
			var renderer = this.renderer,
				camera = this.camera,
				scene = this.scene,
				layers = this.layers,
				mapping = this.mapping,
				renderTarget = this.renderTarget;
			var srcLayers = scene.layers.layerList;
			var subLayerEnabled = scene.layers.subLayerEnabled;
			var isTransparent = scene.layers.subLayerList;
			var pickColorId = device.scope.resolve('uColor');
			var pickColor = this.pickColor;
			for (var i = 0; i < srcLayers.length; i++) {
				var srcLayer = srcLayers[i];
				if (layers && layers.indexOf(srcLayer) < 0) {
					continue;
				}
				if (srcLayer.enabled && subLayerEnabled[i]) {
					if (srcLayer.camerasSet.has(camera.camera)) {
						var transparent = isTransparent[i];
						if (srcLayer._clearDepthBuffer) {
							renderer.clear(camera.camera, false, true, false);
						}
						var meshInstances = srcLayer.meshInstances;
						for (var j = 0; j < meshInstances.length; j++) {
							var meshInstance = meshInstances[j];
							if (meshInstance.pick && meshInstance.transparent === transparent) {
								tempMeshInstances.push(meshInstance);
								mapping.set(meshInstance.id, meshInstance);
							}
						}
						if (tempMeshInstances.length > 0) {
							renderer.setCameraUniforms(camera.camera, renderTarget);
							renderer.renderForward(camera.camera, tempMeshInstances, lights, SHADER_PICK, function (meshInstance) {
								var miId = meshInstance.id;
								pickColor[0] = (miId >> 16 & 0xff) / 255;
								pickColor[1] = (miId >> 8 & 0xff) / 255;
								pickColor[2] = (miId & 0xff) / 255;
								pickColor[3] = (miId >> 24 & 0xff) / 255;
								pickColorId.setValue(pickColor);
								device.setBlendState(BlendState.NOBLEND);
							});
							tempMeshInstances.length = 0;
						}
					}
				}
			}
		};
		return RenderPassPicker;
	}(RenderPass);

	var tempSet = new Set();
	var Picker = function () {
		function Picker(app, width, height) {
			this.renderTarget = null;
			this.mapping = new Map();
			if (app instanceof GraphicsDevice) {
				app = getApplication();
			}
			this.renderer = app.renderer;
			this.device = app.graphicsDevice;
			this.renderPass = new RenderPassPicker(this.device, app.renderer);
			this.width = 0;
			this.height = 0;
			this.resize(width, height);
		}
		var _proto = Picker.prototype;
		_proto.getSelection = function getSelection(x, y, width, height) {
			var device = this.device;
			if (typeof x === 'object') {
				var rect = x;
				x = rect.x;
				y = rect.y;
				width = rect.width;
				height = rect.height;
			} else {
				y = this.renderTarget.height - (y + (height || 1));
			}
			x = Math.floor(x);
			y = Math.floor(y);
			width = Math.floor(Math.max(width || 1, 1));
			height = Math.floor(Math.max(height || 1, 1));
			device.setRenderTarget(this.renderTarget);
			device.updateBegin();
			var pixels = new Uint8Array(4 * width * height);
			device.readPixels(x, y, width, height, pixels);
			device.updateEnd();
			var mapping = this.mapping;
			for (var i = 0; i < width * height; i++) {
				var r = pixels[4 * i + 0];
				var g = pixels[4 * i + 1];
				var b = pixels[4 * i + 2];
				var a = pixels[4 * i + 3];
				var index = a << 24 | r << 16 | g << 8 | b;
				if (index !== -1) {
					tempSet.add(mapping.get(index));
				}
			}
			var selection = [];
			tempSet.forEach(function (meshInstance) {
				return selection.push(meshInstance);
			});
			tempSet.clear();
			return selection;
		};
		_proto.allocateRenderTarget = function allocateRenderTarget() {
			var colorBuffer = new Texture(this.device, {
				format: PIXELFORMAT_RGBA8,
				width: this.width,
				height: this.height,
				mipmaps: false,
				minFilter: FILTER_NEAREST,
				magFilter: FILTER_NEAREST,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE,
				name: 'pick'
			});
			this.renderTarget = new RenderTarget({
				colorBuffer: colorBuffer,
				depth: true
			});
		};
		_proto.releaseRenderTarget = function releaseRenderTarget() {
			if (this.renderTarget) {
				this.renderTarget.destroyTextureBuffers();
				this.renderTarget.destroy();
				this.renderTarget = null;
			}
		};
		_proto.prepare = function prepare(camera, scene, layers) {
			if (camera instanceof Camera) {
				camera = camera.node.camera;
			}
			if (layers instanceof Layer) {
				layers = [layers];
			}
			if (!this.renderTarget || this.width !== this.renderTarget.width || this.height !== this.renderTarget.height) {
				this.releaseRenderTarget();
				this.allocateRenderTarget();
			}
			this.mapping.clear();
			var renderPass = this.renderPass;
			renderPass.init(this.renderTarget);
			renderPass.colorOps.clearValue = Color.WHITE;
			renderPass.colorOps.clear = true;
			renderPass.depthStencilOps.clearDepth = true;
			renderPass.update(camera, scene, layers, this.mapping);
			renderPass.render();
		};
		_proto.resize = function resize(width, height) {
			this.width = Math.floor(width);
			this.height = Math.floor(height);
		};
		return Picker;
	}();

	var ResourceHandler = function () {
		function ResourceHandler() {}
		var _proto = ResourceHandler.prototype;
		_proto.load = function load(url, callback, asset) {
			throw new Error('not implemented');
		};
		_proto.open = function open(url, data, asset) {
			throw new Error('not implemented');
		};
		_proto.patch = function patch(asset, assets) {};
		return ResourceHandler;
	}();

	var SceneSettingsHandler = function () {
		function SceneSettingsHandler(app) {
			this._app = app;
			this.maxRetries = 0;
		}
		var _proto = SceneSettingsHandler.prototype;
		_proto.load = function load(url, callback) {
			SceneUtils.load(url, this.maxRetries, callback);
		};
		_proto.open = function open(url, data) {
			return data.settings;
		};
		return SceneSettingsHandler;
	}();

	var targetX, targetY;
	var vecA = new Vec3();
	var vecB = new Vec3();
	var rayA = new Ray();
	var rayB = new Ray();
	var rayC = new Ray();
	rayA.end = new Vec3();
	rayB.end = new Vec3();
	rayC.end = new Vec3();
	var _pq = new Vec3();
	var _pa = new Vec3();
	var _pb = new Vec3();
	var _pc = new Vec3();
	var _pd = new Vec3();
	var _m = new Vec3();
	var _au = new Vec3();
	var _bv = new Vec3();
	var _cw = new Vec3();
	var _ir = new Vec3();
	var _sct = new Vec3();
	var _accumulatedScale = new Vec3();
	var _paddingTop = new Vec3();
	var _paddingBottom = new Vec3();
	var _paddingLeft = new Vec3();
	var _paddingRight = new Vec3();
	var _cornerBottomLeft = new Vec3();
	var _cornerBottomRight = new Vec3();
	var _cornerTopRight = new Vec3();
	var _cornerTopLeft = new Vec3();
	var ZERO_VEC4 = new Vec4();
	function scalarTriple(p1, p2, p3) {
		return _sct.cross(p1, p2).dot(p3);
	}
	function intersectLineQuad(p, q, corners) {
		_pq.sub2(q, p);
		_pa.sub2(corners[0], p);
		_pb.sub2(corners[1], p);
		_pc.sub2(corners[2], p);
		_m.cross(_pc, _pq);
		var v = _pa.dot(_m);
		var u;
		var w;
		if (v >= 0) {
			u = -_pb.dot(_m);
			if (u < 0) return -1;
			w = scalarTriple(_pq, _pb, _pa);
			if (w < 0) return -1;
			var denom = 1.0 / (u + v + w);
			_au.copy(corners[0]).mulScalar(u * denom);
			_bv.copy(corners[1]).mulScalar(v * denom);
			_cw.copy(corners[2]).mulScalar(w * denom);
			_ir.copy(_au).add(_bv).add(_cw);
		} else {
			_pd.sub2(corners[3], p);
			u = _pd.dot(_m);
			if (u < 0) return -1;
			w = scalarTriple(_pq, _pa, _pd);
			if (w < 0) return -1;
			v = -v;
			var _denom = 1.0 / (u + v + w);
			_au.copy(corners[0]).mulScalar(u * _denom);
			_bv.copy(corners[3]).mulScalar(v * _denom);
			_cw.copy(corners[2]).mulScalar(w * _denom);
			_ir.copy(_au).add(_bv).add(_cw);
		}
		if (_pq.sub2(corners[0], corners[2]).lengthSq() < 0.0001 * 0.0001) return -1;
		if (_pq.sub2(corners[1], corners[3]).lengthSq() < 0.0001 * 0.0001) return -1;
		return _ir.sub(p).lengthSq();
	}
	var ElementInputEvent = function () {
		function ElementInputEvent(event, element, camera) {
			this.event = event;
			this.element = element;
			this.camera = camera;
			this._stopPropagation = false;
		}
		var _proto = ElementInputEvent.prototype;
		_proto.stopPropagation = function stopPropagation() {
			this._stopPropagation = true;
			if (this.event) {
				this.event.stopImmediatePropagation();
				this.event.stopPropagation();
			}
		};
		return ElementInputEvent;
	}();
	var ElementMouseEvent = function (_ElementInputEvent) {
		_inheritsLoose(ElementMouseEvent, _ElementInputEvent);
		function ElementMouseEvent(event, element, camera, x, y, lastX, lastY) {
			var _this;
			_this = _ElementInputEvent.call(this, event, element, camera) || this;
			_this.x = x;
			_this.y = y;
			_this.ctrlKey = event.ctrlKey || false;
			_this.altKey = event.altKey || false;
			_this.shiftKey = event.shiftKey || false;
			_this.metaKey = event.metaKey || false;
			_this.button = event.button;
			if (Mouse.isPointerLocked()) {
				_this.dx = event.movementX || event.webkitMovementX || event.mozMovementX || 0;
				_this.dy = event.movementY || event.webkitMovementY || event.mozMovementY || 0;
			} else {
				_this.dx = x - lastX;
				_this.dy = y - lastY;
			}
			_this.wheelDelta = 0;
			if (event.type === 'wheel') {
				if (event.deltaY > 0) {
					_this.wheelDelta = 1;
				} else if (event.deltaY < 0) {
					_this.wheelDelta = -1;
				}
			}
			return _this;
		}
		return ElementMouseEvent;
	}(ElementInputEvent);
	var ElementTouchEvent = function (_ElementInputEvent2) {
		_inheritsLoose(ElementTouchEvent, _ElementInputEvent2);
		function ElementTouchEvent(event, element, camera, x, y, touch) {
			var _this2;
			_this2 = _ElementInputEvent2.call(this, event, element, camera) || this;
			_this2.touches = event.touches;
			_this2.changedTouches = event.changedTouches;
			_this2.x = x;
			_this2.y = y;
			_this2.touch = touch;
			return _this2;
		}
		return ElementTouchEvent;
	}(ElementInputEvent);
	var ElementSelectEvent = function (_ElementInputEvent3) {
		_inheritsLoose(ElementSelectEvent, _ElementInputEvent3);
		function ElementSelectEvent(event, element, camera, inputSource) {
			var _this3;
			_this3 = _ElementInputEvent3.call(this, event, element, camera) || this;
			_this3.inputSource = inputSource;
			return _this3;
		}
		return ElementSelectEvent;
	}(ElementInputEvent);
	var ElementInput = function () {
		function ElementInput(domElement, options) {
			this._app = null;
			this._attached = false;
			this._target = null;
			this._enabled = true;
			this._lastX = 0;
			this._lastY = 0;
			this._upHandler = this._handleUp.bind(this);
			this._downHandler = this._handleDown.bind(this);
			this._moveHandler = this._handleMove.bind(this);
			this._wheelHandler = this._handleWheel.bind(this);
			this._touchstartHandler = this._handleTouchStart.bind(this);
			this._touchendHandler = this._handleTouchEnd.bind(this);
			this._touchcancelHandler = this._touchendHandler;
			this._touchmoveHandler = this._handleTouchMove.bind(this);
			this._sortHandler = this._sortElements.bind(this);
			this._elements = [];
			this._hoveredElement = null;
			this._pressedElement = null;
			this._touchedElements = {};
			this._touchesForWhichTouchLeaveHasFired = {};
			this._selectedElements = {};
			this._selectedPressedElements = {};
			this._useMouse = !options || options.useMouse !== false;
			this._useTouch = !options || options.useTouch !== false;
			this._useXr = !options || options.useXr !== false;
			this._selectEventsAttached = false;
			if (platform.touch) this._clickedEntities = {};
			this.attach(domElement);
		}
		var _proto2 = ElementInput.prototype;
		_proto2.attach = function attach(domElement) {
			if (this._attached) {
				this._attached = false;
				this.detach();
			}
			this._target = domElement;
			this._attached = true;
			var opts = platform.passiveEvents ? {
				passive: true
			} : false;
			if (this._useMouse) {
				window.addEventListener('mouseup', this._upHandler, opts);
				window.addEventListener('mousedown', this._downHandler, opts);
				window.addEventListener('mousemove', this._moveHandler, opts);
				window.addEventListener('wheel', this._wheelHandler, opts);
			}
			if (this._useTouch && platform.touch) {
				this._target.addEventListener('touchstart', this._touchstartHandler, opts);
				this._target.addEventListener('touchend', this._touchendHandler, false);
				this._target.addEventListener('touchmove', this._touchmoveHandler, false);
				this._target.addEventListener('touchcancel', this._touchcancelHandler, false);
			}
			this.attachSelectEvents();
		};
		_proto2.attachSelectEvents = function attachSelectEvents() {
			if (!this._selectEventsAttached && this._useXr && this.app && this.app.xr && this.app.xr.supported) {
				if (!this._clickedEntities) this._clickedEntities = {};
				this._selectEventsAttached = true;
				this.app.xr.on('start', this._onXrStart, this);
			}
		};
		_proto2.detach = function detach() {
			if (!this._attached) return;
			this._attached = false;
			var opts = platform.passiveEvents ? {
				passive: true
			} : false;
			if (this._useMouse) {
				window.removeEventListener('mouseup', this._upHandler, opts);
				window.removeEventListener('mousedown', this._downHandler, opts);
				window.removeEventListener('mousemove', this._moveHandler, opts);
				window.removeEventListener('wheel', this._wheelHandler, opts);
			}
			if (this._useTouch) {
				this._target.removeEventListener('touchstart', this._touchstartHandler, opts);
				this._target.removeEventListener('touchend', this._touchendHandler, false);
				this._target.removeEventListener('touchmove', this._touchmoveHandler, false);
				this._target.removeEventListener('touchcancel', this._touchcancelHandler, false);
			}
			if (this._selectEventsAttached) {
				this._selectEventsAttached = false;
				this.app.xr.off('start', this._onXrStart, this);
				this.app.xr.off('end', this._onXrEnd, this);
				this.app.xr.off('update', this._onXrUpdate, this);
				this.app.xr.input.off('selectstart', this._onSelectStart, this);
				this.app.xr.input.off('selectend', this._onSelectEnd, this);
				this.app.xr.input.off('remove', this._onXrInputRemove, this);
			}
			this._target = null;
		};
		_proto2.addElement = function addElement(element) {
			if (this._elements.indexOf(element) === -1) this._elements.push(element);
		};
		_proto2.removeElement = function removeElement(element) {
			var idx = this._elements.indexOf(element);
			if (idx !== -1) this._elements.splice(idx, 1);
		};
		_proto2._handleUp = function _handleUp(event) {
			if (!this._enabled) return;
			if (Mouse.isPointerLocked()) return;
			this._calcMouseCoords(event);
			this._onElementMouseEvent('mouseup', event);
		};
		_proto2._handleDown = function _handleDown(event) {
			if (!this._enabled) return;
			if (Mouse.isPointerLocked()) return;
			this._calcMouseCoords(event);
			this._onElementMouseEvent('mousedown', event);
		};
		_proto2._handleMove = function _handleMove(event) {
			if (!this._enabled) return;
			this._calcMouseCoords(event);
			this._onElementMouseEvent('mousemove', event);
			this._lastX = targetX;
			this._lastY = targetY;
		};
		_proto2._handleWheel = function _handleWheel(event) {
			if (!this._enabled) return;
			this._calcMouseCoords(event);
			this._onElementMouseEvent('mousewheel', event);
		};
		_proto2._determineTouchedElements = function _determineTouchedElements(event) {
			var touchedElements = {};
			var cameras = this.app.systems.camera.cameras;
			for (var i = cameras.length - 1; i >= 0; i--) {
				var camera = cameras[i];
				var done = 0;
				var len = event.changedTouches.length;
				for (var j = 0; j < len; j++) {
					if (touchedElements[event.changedTouches[j].identifier]) {
						done++;
						continue;
					}
					var coords = this._calcTouchCoords(event.changedTouches[j]);
					var element = this._getTargetElementByCoords(camera, coords.x, coords.y);
					if (element) {
						done++;
						touchedElements[event.changedTouches[j].identifier] = {
							element: element,
							camera: camera,
							x: coords.x,
							y: coords.y
						};
					}
				}
				if (done === len) {
					break;
				}
			}
			return touchedElements;
		};
		_proto2._handleTouchStart = function _handleTouchStart(event) {
			if (!this._enabled) return;
			var newTouchedElements = this._determineTouchedElements(event);
			for (var i = 0, len = event.changedTouches.length; i < len; i++) {
				var touch = event.changedTouches[i];
				var newTouchInfo = newTouchedElements[touch.identifier];
				var oldTouchInfo = this._touchedElements[touch.identifier];
				if (newTouchInfo && (!oldTouchInfo || newTouchInfo.element !== oldTouchInfo.element)) {
					this._fireEvent(event.type, new ElementTouchEvent(event, newTouchInfo.element, newTouchInfo.camera, newTouchInfo.x, newTouchInfo.y, touch));
					this._touchesForWhichTouchLeaveHasFired[touch.identifier] = false;
				}
			}
			for (var touchId in newTouchedElements) {
				this._touchedElements[touchId] = newTouchedElements[touchId];
			}
		};
		_proto2._handleTouchEnd = function _handleTouchEnd(event) {
			if (!this._enabled) return;
			var cameras = this.app.systems.camera.cameras;
			for (var key in this._clickedEntities) {
				delete this._clickedEntities[key];
			}
			for (var i = 0, len = event.changedTouches.length; i < len; i++) {
				var touch = event.changedTouches[i];
				var touchInfo = this._touchedElements[touch.identifier];
				if (!touchInfo) continue;
				var element = touchInfo.element;
				var camera = touchInfo.camera;
				var x = touchInfo.x;
				var y = touchInfo.y;
				delete this._touchedElements[touch.identifier];
				delete this._touchesForWhichTouchLeaveHasFired[touch.identifier];
				var coords = this._calcTouchCoords(touch);
				for (var c = cameras.length - 1; c >= 0; c--) {
					var hovered = this._getTargetElementByCoords(cameras[c], coords.x, coords.y);
					if (hovered === element) {
						if (!this._clickedEntities[element.entity.getGuid()]) {
							this._fireEvent('click', new ElementTouchEvent(event, element, camera, x, y, touch));
							this._clickedEntities[element.entity.getGuid()] = Date.now();
						}
					}
				}
				this._fireEvent(event.type, new ElementTouchEvent(event, element, camera, x, y, touch));
			}
		};
		_proto2._handleTouchMove = function _handleTouchMove(event) {
			event.preventDefault();
			if (!this._enabled) return;
			var newTouchedElements = this._determineTouchedElements(event);
			for (var i = 0, len = event.changedTouches.length; i < len; i++) {
				var touch = event.changedTouches[i];
				var newTouchInfo = newTouchedElements[touch.identifier];
				var oldTouchInfo = this._touchedElements[touch.identifier];
				if (oldTouchInfo) {
					var coords = this._calcTouchCoords(touch);
					if ((!newTouchInfo || newTouchInfo.element !== oldTouchInfo.element) && !this._touchesForWhichTouchLeaveHasFired[touch.identifier]) {
						this._fireEvent('touchleave', new ElementTouchEvent(event, oldTouchInfo.element, oldTouchInfo.camera, coords.x, coords.y, touch));
						this._touchesForWhichTouchLeaveHasFired[touch.identifier] = true;
					}
					this._fireEvent('touchmove', new ElementTouchEvent(event, oldTouchInfo.element, oldTouchInfo.camera, coords.x, coords.y, touch));
				}
			}
		};
		_proto2._onElementMouseEvent = function _onElementMouseEvent(eventType, event) {
			var element = null;
			var lastHovered = this._hoveredElement;
			this._hoveredElement = null;
			var cameras = this.app.systems.camera.cameras;
			var camera;
			for (var i = cameras.length - 1; i >= 0; i--) {
				camera = cameras[i];
				element = this._getTargetElementByCoords(camera, targetX, targetY);
				if (element) break;
			}
			this._hoveredElement = element;
			if ((eventType === 'mousemove' || eventType === 'mouseup') && this._pressedElement) {
				this._fireEvent(eventType, new ElementMouseEvent(event, this._pressedElement, camera, targetX, targetY, this._lastX, this._lastY));
			} else if (element) {
				this._fireEvent(eventType, new ElementMouseEvent(event, element, camera, targetX, targetY, this._lastX, this._lastY));
				if (eventType === 'mousedown') {
					this._pressedElement = element;
				}
			}
			if (lastHovered !== this._hoveredElement) {
				if (lastHovered) {
					this._fireEvent('mouseleave', new ElementMouseEvent(event, lastHovered, camera, targetX, targetY, this._lastX, this._lastY));
				}
				if (this._hoveredElement) {
					this._fireEvent('mouseenter', new ElementMouseEvent(event, this._hoveredElement, camera, targetX, targetY, this._lastX, this._lastY));
				}
			}
			if (eventType === 'mouseup' && this._pressedElement) {
				if (this._pressedElement === this._hoveredElement) {
					var guid = this._hoveredElement.entity.getGuid();
					var fireClick = !this._clickedEntities;
					if (this._clickedEntities) {
						var lastTouchUp = this._clickedEntities[guid] || 0;
						var dt = Date.now() - lastTouchUp;
						fireClick = dt > 300;
						delete this._clickedEntities[guid];
					}
					if (fireClick) {
						this._fireEvent('click', new ElementMouseEvent(event, this._hoveredElement, camera, targetX, targetY, this._lastX, this._lastY));
					}
				}
				this._pressedElement = null;
			}
		};
		_proto2._onXrStart = function _onXrStart() {
			this.app.xr.on('end', this._onXrEnd, this);
			this.app.xr.on('update', this._onXrUpdate, this);
			this.app.xr.input.on('selectstart', this._onSelectStart, this);
			this.app.xr.input.on('selectend', this._onSelectEnd, this);
			this.app.xr.input.on('remove', this._onXrInputRemove, this);
		};
		_proto2._onXrEnd = function _onXrEnd() {
			this.app.xr.off('update', this._onXrUpdate, this);
			this.app.xr.input.off('selectstart', this._onSelectStart, this);
			this.app.xr.input.off('selectend', this._onSelectEnd, this);
			this.app.xr.input.off('remove', this._onXrInputRemove, this);
		};
		_proto2._onXrUpdate = function _onXrUpdate() {
			if (!this._enabled) return;
			var inputSources = this.app.xr.input.inputSources;
			for (var i = 0; i < inputSources.length; i++) {
				this._onElementSelectEvent('selectmove', inputSources[i], null);
			}
		};
		_proto2._onXrInputRemove = function _onXrInputRemove(inputSource) {
			var hovered = this._selectedElements[inputSource.id];
			if (hovered) {
				inputSource._elementEntity = null;
				this._fireEvent('selectleave', new ElementSelectEvent(null, hovered, null, inputSource));
			}
			delete this._selectedElements[inputSource.id];
			delete this._selectedPressedElements[inputSource.id];
		};
		_proto2._onSelectStart = function _onSelectStart(inputSource, event) {
			if (!this._enabled) return;
			this._onElementSelectEvent('selectstart', inputSource, event);
		};
		_proto2._onSelectEnd = function _onSelectEnd(inputSource, event) {
			if (!this._enabled) return;
			this._onElementSelectEvent('selectend', inputSource, event);
		};
		_proto2._onElementSelectEvent = function _onElementSelectEvent(eventType, inputSource, event) {
			var element;
			var hoveredBefore = this._selectedElements[inputSource.id];
			var hoveredNow;
			var cameras = this.app.systems.camera.cameras;
			var camera;
			if (inputSource.elementInput) {
				rayC.set(inputSource.getOrigin(), inputSource.getDirection());
				for (var i = cameras.length - 1; i >= 0; i--) {
					camera = cameras[i];
					element = this._getTargetElementByRay(rayC, camera);
					if (element) break;
				}
			}
			inputSource._elementEntity = element || null;
			if (element) {
				this._selectedElements[inputSource.id] = element;
				hoveredNow = element;
			} else {
				delete this._selectedElements[inputSource.id];
			}
			if (hoveredBefore !== hoveredNow) {
				if (hoveredBefore) this._fireEvent('selectleave', new ElementSelectEvent(event, hoveredBefore, camera, inputSource));
				if (hoveredNow) this._fireEvent('selectenter', new ElementSelectEvent(event, hoveredNow, camera, inputSource));
			}
			var pressed = this._selectedPressedElements[inputSource.id];
			if (eventType === 'selectmove' && pressed) {
				this._fireEvent('selectmove', new ElementSelectEvent(event, pressed, camera, inputSource));
			}
			if (eventType === 'selectstart') {
				this._selectedPressedElements[inputSource.id] = hoveredNow;
				if (hoveredNow) this._fireEvent('selectstart', new ElementSelectEvent(event, hoveredNow, camera, inputSource));
			}
			if (!inputSource.elementInput && pressed) {
				delete this._selectedPressedElements[inputSource.id];
				if (hoveredBefore) {
					this._fireEvent('selectend', new ElementSelectEvent(event, pressed, camera, inputSource));
				}
			}
			if (eventType === 'selectend' && inputSource.elementInput) {
				delete this._selectedPressedElements[inputSource.id];
				if (pressed) {
					this._fireEvent('selectend', new ElementSelectEvent(event, pressed, camera, inputSource));
				}
				if (pressed && pressed === hoveredBefore) {
					this._fireEvent('click', new ElementSelectEvent(event, pressed, camera, inputSource));
				}
			}
		};
		_proto2._fireEvent = function _fireEvent(name, evt) {
			var element = evt.element;
			while (true) {
				element.fire(name, evt);
				if (evt._stopPropagation) break;
				if (!element.entity.parent) break;
				element = element.entity.parent.element;
				if (!element) break;
			}
		};
		_proto2._calcMouseCoords = function _calcMouseCoords(event) {
			var rect = this._target.getBoundingClientRect();
			var left = Math.floor(rect.left);
			var top = Math.floor(rect.top);
			targetX = event.clientX - left;
			targetY = event.clientY - top;
		};
		_proto2._calcTouchCoords = function _calcTouchCoords(touch) {
			var totalOffsetX = 0;
			var totalOffsetY = 0;
			var target = touch.target;
			while (!(target instanceof HTMLElement)) {
				target = target.parentNode;
			}
			var currentElement = target;
			do {
				totalOffsetX += currentElement.offsetLeft - currentElement.scrollLeft;
				totalOffsetY += currentElement.offsetTop - currentElement.scrollTop;
				currentElement = currentElement.offsetParent;
			} while (currentElement);
			return {
				x: touch.pageX - totalOffsetX,
				y: touch.pageY - totalOffsetY
			};
		};
		_proto2._sortElements = function _sortElements(a, b) {
			var layerOrder = this.app.scene.layers.sortTransparentLayers(a.layers, b.layers);
			if (layerOrder !== 0) return layerOrder;
			if (a.screen && !b.screen) return -1;
			if (!a.screen && b.screen) return 1;
			if (!a.screen && !b.screen) return 0;
			if (a.screen.screen.screenSpace && !b.screen.screen.screenSpace) return -1;
			if (b.screen.screen.screenSpace && !a.screen.screen.screenSpace) return 1;
			return b.drawOrder - a.drawOrder;
		};
		_proto2._getTargetElementByCoords = function _getTargetElementByCoords(camera, x, y) {
			var rayScreen = this._calculateRayScreen(x, y, camera, rayA) ? rayA : null;
			var ray3d = this._calculateRay3d(x, y, camera, rayB) ? rayB : null;
			return this._getTargetElement(camera, rayScreen, ray3d);
		};
		_proto2._getTargetElementByRay = function _getTargetElementByRay(ray, camera) {
			rayA.origin.copy(ray.origin);
			rayA.direction.copy(ray.direction);
			rayA.end.copy(rayA.direction).mulScalar(camera.farClip * 2).add(rayA.origin);
			var ray3d = rayA;
			var screenPos = camera.worldToScreen(ray3d.origin, vecA);
			var rayScreen = this._calculateRayScreen(screenPos.x, screenPos.y, camera, rayB) ? rayB : null;
			return this._getTargetElement(camera, rayScreen, ray3d);
		};
		_proto2._getTargetElement = function _getTargetElement(camera, rayScreen, ray3d) {
			var result = null;
			var closestDistance3d = Infinity;
			this._elements.sort(this._sortHandler);
			for (var i = 0, len = this._elements.length; i < len; i++) {
				var element = this._elements[i];
				if (!element.layers.some(function (v) {
					return camera.layersSet.has(v);
				})) {
					continue;
				}
				if (element.screen && element.screen.screen.screenSpace) {
					if (!rayScreen) {
						continue;
					}
					var currentDistance = this._checkElement(rayScreen, element, true);
					if (currentDistance >= 0) {
						result = element;
						break;
					}
				} else {
					if (!ray3d) {
						continue;
					}
					var _currentDistance = this._checkElement(ray3d, element, false);
					if (_currentDistance >= 0) {
						if (_currentDistance < closestDistance3d) {
							result = element;
							closestDistance3d = _currentDistance;
						}
						if (element.screen) {
							result = element;
							break;
						}
					}
				}
			}
			return result;
		};
		_proto2._calculateRayScreen = function _calculateRayScreen(x, y, camera, ray) {
			var sw = this.app.graphicsDevice.width;
			var sh = this.app.graphicsDevice.height;
			var cameraWidth = camera.rect.z * sw;
			var cameraHeight = camera.rect.w * sh;
			var cameraLeft = camera.rect.x * sw;
			var cameraRight = cameraLeft + cameraWidth;
			var cameraBottom = (1 - camera.rect.y) * sh;
			var cameraTop = cameraBottom - cameraHeight;
			var _x = x * sw / this._target.clientWidth;
			var _y = y * sh / this._target.clientHeight;
			if (_x >= cameraLeft && _x <= cameraRight && _y <= cameraBottom && _y >= cameraTop) {
				_x = sw * (_x - cameraLeft) / cameraWidth;
				_y = sh * (_y - cameraTop) / cameraHeight;
				_y = sh - _y;
				ray.origin.set(_x, _y, 1);
				ray.direction.set(0, 0, -1);
				ray.end.copy(ray.direction).mulScalar(2).add(ray.origin);
				return true;
			}
			return false;
		};
		_proto2._calculateRay3d = function _calculateRay3d(x, y, camera, ray) {
			var sw = this._target.clientWidth;
			var sh = this._target.clientHeight;
			var cameraWidth = camera.rect.z * sw;
			var cameraHeight = camera.rect.w * sh;
			var cameraLeft = camera.rect.x * sw;
			var cameraRight = cameraLeft + cameraWidth;
			var cameraBottom = (1 - camera.rect.y) * sh;
			var cameraTop = cameraBottom - cameraHeight;
			var _x = x;
			var _y = y;
			if (x >= cameraLeft && x <= cameraRight && y <= cameraBottom && _y >= cameraTop) {
				_x = sw * (_x - cameraLeft) / cameraWidth;
				_y = sh * (_y - cameraTop) / cameraHeight;
				camera.screenToWorld(_x, _y, camera.nearClip, vecA);
				camera.screenToWorld(_x, _y, camera.farClip, vecB);
				ray.origin.copy(vecA);
				ray.direction.set(0, 0, -1);
				ray.end.copy(vecB);
				return true;
			}
			return false;
		};
		_proto2._checkElement = function _checkElement(ray, element, screen) {
			if (element.maskedBy) {
				if (this._checkElement(ray, element.maskedBy.element, screen) < 0) {
					return -1;
				}
			}
			var scale;
			if (screen) {
				scale = ElementInput.calculateScaleToScreen(element);
			} else {
				scale = ElementInput.calculateScaleToWorld(element);
			}
			var corners = ElementInput.buildHitCorners(element, screen ? element.screenCorners : element.worldCorners, scale);
			return intersectLineQuad(ray.origin, ray.end, corners);
		};
		ElementInput.buildHitCorners = function buildHitCorners(element, screenOrWorldCorners, scale) {
			var hitCorners = screenOrWorldCorners;
			var button = element.entity && element.entity.button;
			if (button) {
				var hitPadding = element.entity.button.hitPadding || ZERO_VEC4;
				_paddingTop.copy(element.entity.up);
				_paddingBottom.copy(_paddingTop).mulScalar(-1);
				_paddingRight.copy(element.entity.right);
				_paddingLeft.copy(_paddingRight).mulScalar(-1);
				_paddingTop.mulScalar(hitPadding.w * scale.y);
				_paddingBottom.mulScalar(hitPadding.y * scale.y);
				_paddingRight.mulScalar(hitPadding.z * scale.x);
				_paddingLeft.mulScalar(hitPadding.x * scale.x);
				_cornerBottomLeft.copy(hitCorners[0]).add(_paddingBottom).add(_paddingLeft);
				_cornerBottomRight.copy(hitCorners[1]).add(_paddingBottom).add(_paddingRight);
				_cornerTopRight.copy(hitCorners[2]).add(_paddingTop).add(_paddingRight);
				_cornerTopLeft.copy(hitCorners[3]).add(_paddingTop).add(_paddingLeft);
				hitCorners = [_cornerBottomLeft, _cornerBottomRight, _cornerTopRight, _cornerTopLeft];
			}
			if (scale.x < 0) {
				var left = hitCorners[2].x;
				var right = hitCorners[0].x;
				hitCorners[0].x = left;
				hitCorners[1].x = right;
				hitCorners[2].x = right;
				hitCorners[3].x = left;
			}
			if (scale.y < 0) {
				var bottom = hitCorners[2].y;
				var top = hitCorners[0].y;
				hitCorners[0].y = bottom;
				hitCorners[1].y = bottom;
				hitCorners[2].y = top;
				hitCorners[3].y = top;
			}
			if (scale.z < 0) {
				var x = hitCorners[2].x;
				var y = hitCorners[2].y;
				var z = hitCorners[2].z;
				hitCorners[2].x = hitCorners[0].x;
				hitCorners[2].y = hitCorners[0].y;
				hitCorners[2].z = hitCorners[0].z;
				hitCorners[0].x = x;
				hitCorners[0].y = y;
				hitCorners[0].z = z;
			}
			return hitCorners;
		};
		ElementInput.calculateScaleToScreen = function calculateScaleToScreen(element) {
			var current = element.entity;
			var screenScale = element.screen.screen.scale;
			_accumulatedScale.set(screenScale, screenScale, screenScale);
			while (current && !current.screen) {
				_accumulatedScale.mul(current.getLocalScale());
				current = current.parent;
			}
			return _accumulatedScale;
		};
		ElementInput.calculateScaleToWorld = function calculateScaleToWorld(element) {
			var current = element.entity;
			_accumulatedScale.set(1, 1, 1);
			while (current) {
				_accumulatedScale.mul(current.getLocalScale());
				current = current.parent;
			}
			return _accumulatedScale;
		};
		_createClass(ElementInput, [{
			key: "enabled",
			get: function get() {
				return this._enabled;
			},
			set: function set(value) {
				this._enabled = value;
			}
		}, {
			key: "app",
			get: function get() {
				return this._app || getApplication();
			},
			set: function set(value) {
				this._app = value;
			}
		}]);
		return ElementInput;
	}();

	var funcNameRegex = new RegExp('^\\s*function(?:\\s|\\s*\\/\\*.*\\*\\/\\s*)+([^\\(\\s\\/]*)\\s*');
	var ScriptType = function (_EventHandler) {
		_inheritsLoose(ScriptType, _EventHandler);
		function ScriptType(args) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this.app = void 0;
			_this.entity = void 0;
			_this._enabled = void 0;
			_this._enabledOld = void 0;
			_this._initialized = void 0;
			_this._postInitialized = void 0;
			_this.__destroyed = void 0;
			_this.__attributes = void 0;
			_this.__attributesRaw = void 0;
			_this.__scriptType = void 0;
			_this.__executionOrder = void 0;
			_this.initScriptType(args);
			return _this;
		}
		var _proto = ScriptType.prototype;
		_proto.initScriptType = function initScriptType(args) {
			var script = this.constructor;
			this.app = args.app;
			this.entity = args.entity;
			this._enabled = typeof args.enabled === 'boolean' ? args.enabled : true;
			this._enabledOld = this.enabled;
			this.__destroyed = false;
			this.__attributes = {};
			this.__attributesRaw = args.attributes || {};
			this.__scriptType = script;
			this.__executionOrder = -1;
		};
		ScriptType.__getScriptName = function __getScriptName(constructorFn) {
			if (typeof constructorFn !== 'function') return undefined;
			if ('name' in Function.prototype) return constructorFn.name;
			if (constructorFn === Function || constructorFn === Function.prototype.constructor) return 'Function';
			var match = ('' + constructorFn).match(funcNameRegex);
			return match ? match[1] : undefined;
		};
		_proto.__initializeAttributes = function __initializeAttributes(force) {
			if (!force && !this.__attributesRaw) return;
			for (var key in this.__scriptType.attributes.index) {
				if (this.__attributesRaw && this.__attributesRaw.hasOwnProperty(key)) {
					this[key] = this.__attributesRaw[key];
				} else if (!this.__attributes.hasOwnProperty(key)) {
					if (this.__scriptType.attributes.index[key].hasOwnProperty('default')) {
						this[key] = this.__scriptType.attributes.index[key].default;
					} else {
						this[key] = null;
					}
				}
			}
			this.__attributesRaw = null;
		};
		ScriptType.extend = function extend(methods) {
			for (var key in methods) {
				if (!methods.hasOwnProperty(key)) continue;
				this.prototype[key] = methods[key];
			}
		};
		_createClass(ScriptType, [{
			key: "enabled",
			get: function get() {
				return this._enabled && !this._destroyed && this.entity.script.enabled && this.entity.enabled;
			},
			set: function set(value) {
				this._enabled = !!value;
				if (this.enabled === this._enabledOld) return;
				this._enabledOld = this.enabled;
				this.fire(this.enabled ? 'enable' : 'disable');
				this.fire('state', this.enabled);
				if (!this._initialized && this.enabled) {
					this._initialized = true;
					this.__initializeAttributes(true);
					if (this.initialize) this.entity.script._scriptMethod(this, SCRIPT_INITIALIZE);
				}
				if (this._initialized && !this._postInitialized && this.enabled && !this.entity.script._beingEnabled) {
					this._postInitialized = true;
					if (this.postInitialize) this.entity.script._scriptMethod(this, SCRIPT_POST_INITIALIZE);
				}
			}
		}], [{
			key: "scriptName",
			get: function get() {
				return this.__name;
			}
		}, {
			key: "attributes",
			get: function get() {
				if (!this.hasOwnProperty('__attributes')) this.__attributes = new ScriptAttributes(this);
				return this.__attributes;
			}
		}]);
		return ScriptType;
	}(EventHandler);
	ScriptType.__name = null;

	var reservedScriptNames = new Set(['system', 'entity', 'create', 'destroy', 'swap', 'move', 'data', 'scripts', '_scripts', '_scriptsIndex', '_scriptsData', 'enabled', '_oldState', 'onEnable', 'onDisable', 'onPostStateChange', '_onSetEnabled', '_checkState', '_onBeforeRemove', '_onInitializeAttributes', '_onInitialize', '_onPostInitialize', '_onUpdate', '_onPostUpdate', '_callbacks', '_callbackActive', 'has', 'get', 'on', 'off', 'fire', 'once', 'hasEvent']);
	function getReservedScriptNames() {
		return reservedScriptNames;
	}
	function createScript(name, app) {
		if (script.legacy) {
			return null;
		}
		if (reservedScriptNames.has(name)) throw new Error("Script name '" + name + "' is reserved, please rename the script");
		var scriptType = function scriptType(args) {
			EventHandler.prototype.initEventHandler.call(this);
			ScriptType.prototype.initScriptType.call(this, args);
		};
		scriptType.prototype = Object.create(ScriptType.prototype);
		scriptType.prototype.constructor = scriptType;
		scriptType.extend = ScriptType.extend;
		scriptType.attributes = new ScriptAttributes(scriptType);
		registerScript(scriptType, name, app);
		return scriptType;
	}
	var reservedAttributes = {};
	ScriptAttributes.reservedNames.forEach(function (value, value2, set) {
		reservedAttributes[value] = 1;
	});
	createScript.reservedAttributes = reservedAttributes;
	function registerScript(script, name, app) {
		if (script.legacy) {
			return;
		}
		if (typeof script !== 'function') throw new Error("script class: '" + script + "' must be a constructor function (i.e. class).");
		if (!(script.prototype instanceof ScriptType)) throw new Error("script class: '" + ScriptType.__getScriptName(script) + "' does not extend pc.ScriptType.");
		name = name || script.__name || ScriptType.__getScriptName(script);
		if (reservedScriptNames.has(name)) throw new Error("script name: '" + name + "' is reserved, please change script name");
		script.__name = name;
		var registry = app ? app.scripts : AppBase.getApplication().scripts;
		registry.add(script);
		ScriptTypes.push(script, script.legacy);
	}

	var log = {
		write: function write(text) {
			console.log(text);
		},
		open: function open() {
			log.write('Powered by PlayCanvas ' + version + ' ' + revision);
		},
		info: function info(text) {
			console.info('INFO:    ' + text);
		},
		debug: function debug(text) {
			console.debug('DEBUG:   ' + text);
		},
		error: function error(text) {
			console.error('ERROR:   ' + text);
		},
		warning: function warning(text) {
			console.warn('WARNING: ' + text);
		},
		alert: function (_alert) {
			function alert(_x) {
				return _alert.apply(this, arguments);
			}
			alert.toString = function () {
				return _alert.toString();
			};
			return alert;
		}(function (text) {
			log.write('ALERT:   ' + text);
			alert(text);
		}),
		assert: function assert(condition, text) {
			if (condition === false) {
				log.write('ASSERT:  ' + text);
			}
		}
	};
	string.endsWith = function (s, subs) {
		return s.endsWith(subs);
	};
	string.startsWith = function (s, subs) {
		return s.startsWith(subs);
	};
	var Timer = function () {
		function Timer() {
			this._isRunning = false;
			this._a = 0;
			this._b = 0;
		}
		var _proto = Timer.prototype;
		_proto.start = function start() {
			this._isRunning = true;
			this._a = now();
		};
		_proto.stop = function stop() {
			this._isRunning = false;
			this._b = now();
		};
		_proto.getMilliseconds = function getMilliseconds() {
			return this._b - this._a;
		};
		return Timer;
	}();
	var time = {
		now: now,
		Timer: Timer
	};
	Object.defineProperty(Color.prototype, 'data', {
		get: function get() {
			if (!this._data) {
				this._data = new Float32Array(4);
			}
			this._data[0] = this.r;
			this._data[1] = this.g;
			this._data[2] = this.b;
			this._data[3] = this.a;
			return this._data;
		}
	});
	Object.defineProperty(Color.prototype, 'data3', {
		get: function get() {
			if (!this._data3) {
				this._data3 = new Float32Array(3);
			}
			this._data3[0] = this.r;
			this._data3[1] = this.g;
			this._data3[2] = this.b;
			return this._data3;
		}
	});
	function inherits(Self, Super) {
		var Temp = function Temp() {};
		var Func = function Func(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {
			Super.call(this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
			Self.call(this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
		};
		Func._super = Super.prototype;
		Temp.prototype = Super.prototype;
		Func.prototype = new Temp();
		return Func;
	}
	function makeArray(arr) {
		return Array.prototype.slice.call(arr);
	}
	function createStyle(cssString) {
		var result = document.createElement('style');
		result.type = 'text/css';
		if (result.styleSheet) {
			result.styleSheet.cssText = cssString;
		} else {
			result.appendChild(document.createTextNode(cssString));
		}
		return result;
	}
	math.INV_LOG2 = Math.LOG2E;
	math.intToBytes = math.intToBytes32;
	math.bytesToInt = math.bytesToInt32;
	Object.defineProperty(Vec2.prototype, 'data', {
		get: function get() {
			if (!this._data) {
				this._data = new Float32Array(2);
			}
			this._data[0] = this.x;
			this._data[1] = this.y;
			return this._data;
		}
	});
	Vec2.prototype.scale = Vec2.prototype.mulScalar;
	Object.defineProperty(Vec3.prototype, 'data', {
		get: function get() {
			if (!this._data) {
				this._data = new Float32Array(3);
			}
			this._data[0] = this.x;
			this._data[1] = this.y;
			this._data[2] = this.z;
			return this._data;
		}
	});
	Vec3.prototype.scale = Vec3.prototype.mulScalar;
	Object.defineProperty(Vec4.prototype, 'data', {
		get: function get() {
			if (!this._data) {
				this._data = new Float32Array(4);
			}
			this._data[0] = this.x;
			this._data[1] = this.y;
			this._data[2] = this.z;
			this._data[3] = this.w;
			return this._data;
		}
	});
	Vec4.prototype.scale = Vec4.prototype.mulScalar;
	var shape = {
		Aabb: BoundingBox,
		Sphere: BoundingSphere,
		Plane: Plane
	};
	BoundingSphere.prototype.intersectRay = BoundingSphere.prototype.intersectsRay;
	Frustum.prototype.update = function (projectionMatrix, viewMatrix) {
		var viewProj = new Mat4();
		viewProj.mul2(projectionMatrix, viewMatrix);
		this.setFromMat4(viewProj);
	};
	var ELEMENTTYPE_INT8 = TYPE_INT8;
	var ELEMENTTYPE_UINT8 = TYPE_UINT8;
	var ELEMENTTYPE_INT16 = TYPE_INT16;
	var ELEMENTTYPE_UINT16 = TYPE_UINT16;
	var ELEMENTTYPE_INT32 = TYPE_INT32;
	var ELEMENTTYPE_UINT32 = TYPE_UINT32;
	var ELEMENTTYPE_FLOAT32 = TYPE_FLOAT32;
	var PIXELFORMAT_L8_A8 = PIXELFORMAT_LA8;
	var PIXELFORMAT_R5_G6_B5 = PIXELFORMAT_RGB565;
	var PIXELFORMAT_R5_G5_B5_A1 = PIXELFORMAT_RGBA5551;
	var PIXELFORMAT_R4_G4_B4_A4 = PIXELFORMAT_RGBA4;
	var PIXELFORMAT_R8_G8_B8 = PIXELFORMAT_RGB8;
	var PIXELFORMAT_R8_G8_B8_A8 = PIXELFORMAT_RGBA8;
	var BLENDMODE_CONSTANT_COLOR = BLENDMODE_CONSTANT;
	var BLENDMODE_ONE_MINUS_CONSTANT_COLOR = BLENDMODE_ONE_MINUS_CONSTANT;
	var BLENDMODE_CONSTANT_ALPHA = BLENDMODE_CONSTANT;
	var BLENDMODE_ONE_MINUS_CONSTANT_ALPHA = BLENDMODE_ONE_MINUS_CONSTANT;
	function UnsupportedBrowserError(message) {
		this.name = 'UnsupportedBrowserError';
		this.message = message || '';
	}
	UnsupportedBrowserError.prototype = Error.prototype;
	function ContextCreationError(message) {
		this.name = 'ContextCreationError';
		this.message = message || '';
	}
	ContextCreationError.prototype = Error.prototype;
	var programlib = {
		begin: ShaderGenerator.begin,
		dummyFragmentCode: ShaderUtils.dummyFragmentCode,
		end: ShaderGenerator.end,
		fogCode: ShaderGenerator.fogCode,
		gammaCode: ShaderGenerator.gammaCode,
		precisionCode: ShaderUtils.precisionCode,
		skinCode: ShaderGenerator.skinCode,
		tonemapCode: ShaderGenerator.tonemapCode,
		versionCode: ShaderUtils.versionCode
	};
	var gfx = {
		ADDRESS_CLAMP_TO_EDGE: ADDRESS_CLAMP_TO_EDGE,
		ADDRESS_MIRRORED_REPEAT: ADDRESS_MIRRORED_REPEAT,
		ADDRESS_REPEAT: ADDRESS_REPEAT,
		BLENDMODE_ZERO: BLENDMODE_ZERO,
		BLENDMODE_ONE: BLENDMODE_ONE,
		BLENDMODE_SRC_COLOR: BLENDMODE_SRC_COLOR,
		BLENDMODE_ONE_MINUS_SRC_COLOR: BLENDMODE_ONE_MINUS_SRC_COLOR,
		BLENDMODE_DST_COLOR: BLENDMODE_DST_COLOR,
		BLENDMODE_ONE_MINUS_DST_COLOR: BLENDMODE_ONE_MINUS_DST_COLOR,
		BLENDMODE_SRC_ALPHA: BLENDMODE_SRC_ALPHA,
		BLENDMODE_SRC_ALPHA_SATURATE: BLENDMODE_SRC_ALPHA_SATURATE,
		BLENDMODE_ONE_MINUS_SRC_ALPHA: BLENDMODE_ONE_MINUS_SRC_ALPHA,
		BLENDMODE_DST_ALPHA: BLENDMODE_DST_ALPHA,
		BLENDMODE_ONE_MINUS_DST_ALPHA: BLENDMODE_ONE_MINUS_DST_ALPHA,
		BUFFER_STATIC: BUFFER_STATIC,
		BUFFER_DYNAMIC: BUFFER_DYNAMIC,
		BUFFER_STREAM: BUFFER_STREAM,
		CULLFACE_NONE: CULLFACE_NONE,
		CULLFACE_BACK: CULLFACE_BACK,
		CULLFACE_FRONT: CULLFACE_FRONT,
		CULLFACE_FRONTANDBACK: CULLFACE_FRONTANDBACK,
		ELEMENTTYPE_INT8: TYPE_INT8,
		ELEMENTTYPE_UINT8: TYPE_UINT8,
		ELEMENTTYPE_INT16: TYPE_INT16,
		ELEMENTTYPE_UINT16: TYPE_UINT16,
		ELEMENTTYPE_INT32: TYPE_INT32,
		ELEMENTTYPE_UINT32: TYPE_UINT32,
		ELEMENTTYPE_FLOAT32: TYPE_FLOAT32,
		FILTER_NEAREST: FILTER_NEAREST,
		FILTER_LINEAR: FILTER_LINEAR,
		FILTER_NEAREST_MIPMAP_NEAREST: FILTER_NEAREST_MIPMAP_NEAREST,
		FILTER_NEAREST_MIPMAP_LINEAR: FILTER_NEAREST_MIPMAP_LINEAR,
		FILTER_LINEAR_MIPMAP_NEAREST: FILTER_LINEAR_MIPMAP_NEAREST,
		FILTER_LINEAR_MIPMAP_LINEAR: FILTER_LINEAR_MIPMAP_LINEAR,
		INDEXFORMAT_UINT8: INDEXFORMAT_UINT8,
		INDEXFORMAT_UINT16: INDEXFORMAT_UINT16,
		INDEXFORMAT_UINT32: INDEXFORMAT_UINT32,
		PIXELFORMAT_RGB565: PIXELFORMAT_RGB565,
		PIXELFORMAT_RGB8: PIXELFORMAT_RGB8,
		PIXELFORMAT_RGBA8: PIXELFORMAT_RGBA8,
		PRIMITIVE_POINTS: PRIMITIVE_POINTS,
		PRIMITIVE_LINES: PRIMITIVE_LINES,
		PRIMITIVE_LINELOOP: PRIMITIVE_LINELOOP,
		PRIMITIVE_LINESTRIP: PRIMITIVE_LINESTRIP,
		PRIMITIVE_TRIANGLES: PRIMITIVE_TRIANGLES,
		PRIMITIVE_TRISTRIP: PRIMITIVE_TRISTRIP,
		PRIMITIVE_TRIFAN: PRIMITIVE_TRIFAN,
		SEMANTIC_POSITION: SEMANTIC_POSITION,
		SEMANTIC_NORMAL: SEMANTIC_NORMAL,
		SEMANTIC_COLOR: SEMANTIC_COLOR,
		SEMANTIC_TEXCOORD: SEMANTIC_TEXCOORD,
		SEMANTIC_TEXCOORD0: SEMANTIC_TEXCOORD0,
		SEMANTIC_TEXCOORD1: SEMANTIC_TEXCOORD1,
		SEMANTIC_ATTR0: SEMANTIC_ATTR0,
		SEMANTIC_ATTR1: SEMANTIC_ATTR1,
		SEMANTIC_ATTR2: SEMANTIC_ATTR2,
		SEMANTIC_ATTR3: SEMANTIC_ATTR3,
		TEXTURELOCK_READ: TEXTURELOCK_READ,
		TEXTURELOCK_WRITE: TEXTURELOCK_WRITE,
		drawQuadWithShader: drawQuadWithShader,
		programlib: programlib,
		shaderChunks: shaderChunks,
		ContextCreationError: ContextCreationError,
		Device: GraphicsDevice,
		IndexBuffer: IndexBuffer,
		ProgramLibrary: ProgramLibrary,
		RenderTarget: RenderTarget,
		ScopeId: ScopeId,
		Shader: Shader,
		ShaderInput: WebglShaderInput,
		Texture: Texture,
		UnsupportedBrowserError: UnsupportedBrowserError,
		VertexBuffer: VertexBuffer,
		VertexFormat: VertexFormat,
		VertexIterator: VertexIterator
	};
	var _viewport = new Vec4();
	function drawFullscreenQuad(device, target, vertexBuffer, shader, rect) {
		var viewport;
		if (rect) {
			var w = target ? target.width : device.width;
			var h = target ? target.height : device.height;
			viewport = _viewport.set(rect.x * w, rect.y * h, rect.z * w, rect.w * h);
		}
		drawQuadWithShader(device, target, shader, viewport);
	}
	var posteffect = {
		createFullscreenQuad: function createFullscreenQuad(device) {
			return device.quadVertexBuffer;
		},
		drawFullscreenQuad: drawFullscreenQuad,
		PostEffect: PostEffect$1,
		PostEffectQueue: PostEffectQueue
	};
	Object.defineProperty(shaderChunks, 'transformSkinnedVS', {
		get: function get() {
			return '#define SKIN\n' + shaderChunks.transformVS;
		}
	});
	var deprecatedChunks = {
		'ambientPrefilteredCube.frag': 'ambientEnv.frag',
		'ambientPrefilteredCubeLod.frag': 'ambientEnv.frag',
		'dpAtlasQuad.frag': null,
		'genParaboloid.frag': null,
		'prefilterCubemap.frag': null,
		'reflectionDpAtlas.frag': 'reflectionEnv.frag',
		'reflectionPrefilteredCube.frag': 'reflectionEnv.frag',
		'reflectionPrefilteredCubeLod.frag': 'reflectionEnv.frag'
	};
	Object.keys(deprecatedChunks).forEach(function (chunkName) {
		Object.defineProperty(shaderChunks, chunkName, {
			get: function get() {
				return null;
			},
			set: function set() {}
		});
	});
	Object.defineProperties(RenderTarget.prototype, {
		_glFrameBuffer: {
			get: function get() {
				return this.impl._glFrameBuffer;
			},
			set: function set(rgbm) {}
		}
	});
	Object.defineProperty(VertexFormat, 'defaultInstancingFormat', {
		get: function get() {
			return VertexFormat.getDefaultInstancingFormat(GraphicsDeviceAccess.get());
		}
	});
	Object.defineProperties(Texture.prototype, {
		rgbm: {
			get: function get() {
				return this.type === TEXTURETYPE_RGBM;
			},
			set: function set(rgbm) {
				this.type = rgbm ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT;
			}
		},
		swizzleGGGR: {
			get: function get() {
				return this.type === TEXTURETYPE_SWIZZLEGGGR;
			},
			set: function set(swizzleGGGR) {
				this.type = swizzleGGGR ? TEXTURETYPE_SWIZZLEGGGR : TEXTURETYPE_DEFAULT;
			}
		},
		_glTexture: {
			get: function get() {
				return this.impl._glTexture;
			}
		},
		autoMipmap: {
			get: function get() {
				return this._mipmaps;
			},
			set: function set(value) {
				this._mipmaps = value;
			}
		}
	});
	Object.defineProperty(GraphicsDevice.prototype, 'webgl2', {
		get: function get() {
			return this.isWebGL2;
		}
	});
	GraphicsDevice.prototype.getProgramLibrary = function () {
		return getProgramLibrary(this);
	};
	GraphicsDevice.prototype.setProgramLibrary = function (lib) {
		setProgramLibrary(this, lib);
	};
	GraphicsDevice.prototype.removeShaderFromCache = function (shader) {
		getProgramLibrary(this).removeFromCache(shader);
	};
	BlendState.DEFAULT = Object.freeze(new BlendState());
	var _tempBlendState = new BlendState();
	var _tempDepthState = new DepthState();
	GraphicsDevice.prototype.setBlendFunction = function (blendSrc, blendDst) {
		var currentBlendState = this.blendState;
		_tempBlendState.copy(currentBlendState);
		_tempBlendState.setColorBlend(currentBlendState.colorOp, blendSrc, blendDst);
		_tempBlendState.setAlphaBlend(currentBlendState.alphaOp, blendSrc, blendDst);
		this.setBlendState(_tempBlendState);
	};
	GraphicsDevice.prototype.setBlendFunctionSeparate = function (blendSrc, blendDst, blendSrcAlpha, blendDstAlpha) {
		var currentBlendState = this.blendState;
		_tempBlendState.copy(currentBlendState);
		_tempBlendState.setColorBlend(currentBlendState.colorOp, blendSrc, blendDst);
		_tempBlendState.setAlphaBlend(currentBlendState.alphaOp, blendSrcAlpha, blendDstAlpha);
		this.setBlendState(_tempBlendState);
	};
	GraphicsDevice.prototype.setBlendEquation = function (blendEquation) {
		var currentBlendState = this.blendState;
		_tempBlendState.copy(currentBlendState);
		_tempBlendState.setColorBlend(blendEquation, currentBlendState.colorSrcFactor, currentBlendState.colorDstFactor);
		_tempBlendState.setAlphaBlend(blendEquation, currentBlendState.alphaSrcFactor, currentBlendState.alphaDstFactor);
		this.setBlendState(_tempBlendState);
	};
	GraphicsDevice.prototype.setBlendEquationSeparate = function (blendEquation, blendAlphaEquation) {
		var currentBlendState = this.blendState;
		_tempBlendState.copy(currentBlendState);
		_tempBlendState.setColorBlend(blendEquation, currentBlendState.colorSrcFactor, currentBlendState.colorDstFactor);
		_tempBlendState.setAlphaBlend(blendAlphaEquation, currentBlendState.alphaSrcFactor, currentBlendState.alphaDstFactor);
		this.setBlendState(_tempBlendState);
	};
	GraphicsDevice.prototype.setColorWrite = function (redWrite, greenWrite, blueWrite, alphaWrite) {
		var currentBlendState = this.blendState;
		_tempBlendState.copy(currentBlendState);
		_tempBlendState.setColorWrite(redWrite, greenWrite, blueWrite, alphaWrite);
		this.setBlendState(_tempBlendState);
	};
	GraphicsDevice.prototype.getBlending = function () {
		return this.blendState.blend;
	};
	GraphicsDevice.prototype.setBlending = function (blending) {
		_tempBlendState.copy(this.blendState);
		_tempBlendState.blend = blending;
		this.setBlendState(_tempBlendState);
	};
	GraphicsDevice.prototype.setDepthWrite = function (write) {
		_tempDepthState.copy(this.depthState);
		_tempDepthState.write = write;
		this.setDepthState(_tempDepthState);
	};
	GraphicsDevice.prototype.setDepthFunc = function (func) {
		_tempDepthState.copy(this.depthState);
		_tempDepthState.func = func;
		this.setDepthState(_tempDepthState);
	};
	GraphicsDevice.prototype.setDepthTest = function (test) {
		_tempDepthState.copy(this.depthState);
		_tempDepthState.test = test;
		this.setDepthState(_tempDepthState);
	};
	GraphicsDevice.prototype.getCullMode = function () {
		return this.cullMode;
	};
	var PhongMaterial = StandardMaterial;
	var LitOptions = LitShaderOptions;
	var scene = {
		partitionSkin: partitionSkin,
		procedural: {
			calculateTangents: calculateTangents,
			createMesh: createMesh$1,
			createTorus: createTorus,
			createCylinder: createCylinder,
			createCapsule: createCapsule,
			createCone: createCone,
			createSphere: createSphere,
			createPlane: createPlane,
			createBox: createBox
		},
		BasicMaterial: BasicMaterial,
		ForwardRenderer: ForwardRenderer,
		GraphNode: GraphNode,
		Material: Material,
		Mesh: Mesh,
		MeshInstance: MeshInstance,
		Model: Model,
		ParticleEmitter: ParticleEmitter,
		PhongMaterial: StandardMaterial,
		Picker: Picker,
		Projection: {
			ORTHOGRAPHIC: PROJECTION_ORTHOGRAPHIC,
			PERSPECTIVE: PROJECTION_PERSPECTIVE
		},
		Scene: Scene,
		Skin: Skin,
		SkinInstance: SkinInstance
	};
	Object.defineProperty(Scene.prototype, 'defaultMaterial', {
		get: function get() {
			return getDefaultMaterial(getApplication().graphicsDevice);
		}
	});
	Object.defineProperty(LayerComposition.prototype, '_meshInstances', {
		get: function get() {
			return null;
		}
	});
	Object.defineProperty(Scene.prototype, 'drawCalls', {
		get: function get() {
			return null;
		}
	});
	['128', '64', '32', '16', '8', '4'].forEach(function (size, index) {
		Object.defineProperty(Scene.prototype, "skyboxPrefiltered" + size, {
			get: function get() {
				return this._prefilteredCubemaps[index];
			},
			set: function set(value) {
				this._prefilteredCubemaps[index] = value;
				this.updateShaders = true;
			}
		});
	});
	Object.defineProperty(Scene.prototype, 'models', {
		get: function get() {
			if (!this._models) {
				this._models = [];
			}
			return this._models;
		}
	});
	Object.defineProperty(Layer.prototype, 'renderTarget', {
		set: function set(rt) {
			this._renderTarget = rt;
			this._dirtyComposition = true;
		},
		get: function get() {
			return this._renderTarget;
		}
	});
	Scene.prototype._updateSkybox = function (device) {
		this._updateSky(device);
	};
	Scene.prototype.addModel = function (model) {
		if (this.containsModel(model)) return;
		var layer = this.layers.getLayerById(LAYERID_WORLD);
		if (!layer) return;
		layer.addMeshInstances(model.meshInstances);
		this.models.push(model);
	};
	Scene.prototype.addShadowCaster = function (model) {
		var layer = this.layers.getLayerById(LAYERID_WORLD);
		if (!layer) return;
		layer.addShadowCasters(model.meshInstances);
	};
	Scene.prototype.removeModel = function (model) {
		var index = this.models.indexOf(model);
		if (index !== -1) {
			var layer = this.layers.getLayerById(LAYERID_WORLD);
			if (!layer) return;
			layer.removeMeshInstances(model.meshInstances);
			this.models.splice(index, 1);
		}
	};
	Scene.prototype.removeShadowCasters = function (model) {
		var layer = this.layers.getLayerById(LAYERID_WORLD);
		if (!layer) return;
		layer.removeShadowCasters(model.meshInstances);
	};
	Scene.prototype.containsModel = function (model) {
		return this.models.indexOf(model) >= 0;
	};
	Scene.prototype.getModels = function (model) {
		return this.models;
	};
	Object.defineProperty(Batch.prototype, 'model', {
		get: function get() {
			return null;
		}
	});
	ForwardRenderer.prototype.renderComposition = function (comp) {
		getApplication().renderComposition(comp);
	};
	MeshInstance.prototype.syncAabb = function () {};
	Morph.prototype.getTarget = function (index) {
		return this.targets[index];
	};
	GraphNode.prototype._dirtify = function (local) {
		if (local) this._dirtifyLocal();else this._dirtifyWorld();
	};
	GraphNode.prototype.addLabel = function (label) {
		this._labels[label] = true;
	};
	GraphNode.prototype.getLabels = function () {
		return Object.keys(this._labels);
	};
	GraphNode.prototype.hasLabel = function (label) {
		return !!this._labels[label];
	};
	GraphNode.prototype.removeLabel = function (label) {
		delete this._labels[label];
	};
	GraphNode.prototype.findByLabel = function (label, results) {
		if (results === void 0) {
			results = [];
		}
		if (this.hasLabel(label)) {
			results.push(this);
		}
		for (var i = 0; i < this._children.length; ++i) {
			results = this._children[i].findByLabel(label, results);
		}
		return results;
	};
	GraphNode.prototype.getChildren = function () {
		return this.children;
	};
	GraphNode.prototype.getName = function () {
		return this.name;
	};
	GraphNode.prototype.getPath = function () {
		return this.path;
	};
	GraphNode.prototype.getRoot = function () {
		return this.root;
	};
	GraphNode.prototype.getParent = function () {
		return this.parent;
	};
	GraphNode.prototype.setName = function (name) {
		this.name = name;
	};
	Material.prototype.getName = function () {
		return this.name;
	};
	Material.prototype.setName = function (name) {
		this.name = name;
	};
	Material.prototype.getShader = function () {
		return this.shader;
	};
	Material.prototype.setShader = function (shader) {
		this.shader = shader;
	};
	Object.defineProperty(Material.prototype, 'blend', {
		set: function set(value) {
			this.blendState.blend = value;
		},
		get: function get() {
			return this.blendState.blend;
		}
	});
	Object.defineProperty(Material.prototype, 'blendSrc', {
		set: function set(value) {
			var currentBlendState = this.blendState;
			_tempBlendState.copy(currentBlendState);
			_tempBlendState.setColorBlend(currentBlendState.colorOp, value, currentBlendState.colorDstFactor);
			_tempBlendState.setAlphaBlend(currentBlendState.alphaOp, value, currentBlendState.alphaDstFactor);
			this.blendState = _tempBlendState;
		},
		get: function get() {
			return this.blendState.colorSrcFactor;
		}
	});
	Object.defineProperty(Material.prototype, 'blendDst', {
		set: function set(value) {
			var currentBlendState = this.blendState;
			_tempBlendState.copy(currentBlendState);
			_tempBlendState.setColorBlend(currentBlendState.colorOp, currentBlendState.colorSrcFactor, value);
			_tempBlendState.setAlphaBlend(currentBlendState.alphaOp, currentBlendState.alphaSrcFactor, value);
			this.blendState = _tempBlendState;
		},
		get: function get() {
			return this.blendState.colorDstFactor;
		}
	});
	Object.defineProperty(StandardMaterial.prototype, 'shininess', {
		get: function get() {
			return this.gloss * 100;
		},
		set: function set(value) {
			this.gloss = value * 0.01;
		}
	});
	function _defineAlias(newName, oldName) {
		Object.defineProperty(StandardMaterial.prototype, oldName, {
			get: function get() {
				return this[newName];
			},
			set: function set(value) {
				this[newName] = value;
			}
		});
	}
	_defineAlias('diffuseTint', 'diffuseMapTint');
	_defineAlias('specularTint', 'specularMapTint');
	_defineAlias('emissiveTint', 'emissiveMapTint');
	_defineAlias('aoVertexColor', 'aoMapVertexColor');
	_defineAlias('diffuseVertexColor', 'diffuseMapVertexColor');
	_defineAlias('specularVertexColor', 'specularMapVertexColor');
	_defineAlias('emissiveVertexColor', 'emissiveMapVertexColor');
	_defineAlias('metalnessVertexColor', 'metalnessMapVertexColor');
	_defineAlias('glossVertexColor', 'glossMapVertexColor');
	_defineAlias('opacityVertexColor', 'opacityMapVertexColor');
	_defineAlias('lightVertexColor', 'lightMapVertexColor');
	_defineAlias('sheenGloss', 'sheenGlossiess');
	_defineAlias('clearCoatGloss', 'clearCostGlossiness');
	function _defineOption(name, newName) {
		if (name !== 'pass') {
			Object.defineProperty(StandardMaterialOptions.prototype, name, {
				get: function get() {
					return this.litOptions[newName || name];
				},
				set: function set(value) {
					this.litOptions[newName || name] = value;
				}
			});
		}
	}
	_defineOption('refraction', 'useRefraction');
	var tempOptions = new LitShaderOptions();
	var litOptionProperties = Object.getOwnPropertyNames(tempOptions);
	for (var litOption in litOptionProperties) {
		_defineOption(litOptionProperties[litOption]);
	}
	var anim = {
		Animation: Animation,
		Key: Key,
		Node: Node,
		Skeleton: Skeleton
	};
	Animation.prototype.getDuration = function () {
		return this.duration;
	};
	Animation.prototype.getName = function () {
		return this.name;
	};
	Animation.prototype.getNodes = function () {
		return this.nodes;
	};
	Animation.prototype.setDuration = function (duration) {
		this.duration = duration;
	};
	Animation.prototype.setName = function (name) {
		this.name = name;
	};
	Skeleton.prototype.getAnimation = function () {
		return this.animation;
	};
	Skeleton.prototype.getCurrentTime = function () {
		return this.currentTime;
	};
	Skeleton.prototype.getLooping = function () {
		return this.looping;
	};
	Skeleton.prototype.getNumNodes = function () {
		return this.numNodes;
	};
	Skeleton.prototype.setAnimation = function (animation) {
		this.animation = animation;
	};
	Skeleton.prototype.setCurrentTime = function (time) {
		this.currentTime = time;
	};
	Skeleton.prototype.setLooping = function (looping) {
		this.looping = looping;
	};
	var audio = {
		AudioManager: SoundManager,
		Channel: Channel,
		Channel3d: Channel3d,
		Listener: Listener,
		Sound: Sound
	};
	SoundManager.prototype.getListener = function () {
		return this.listener;
	};
	SoundManager.prototype.getVolume = function () {
		return this.volume;
	};
	SoundManager.prototype.setVolume = function (volume) {
		this.volume = volume;
	};
	var asset = {
		ASSET_ANIMATION: 'animation',
		ASSET_AUDIO: 'audio',
		ASSET_IMAGE: 'image',
		ASSET_JSON: 'json',
		ASSET_MODEL: 'model',
		ASSET_MATERIAL: 'material',
		ASSET_TEXT: 'text',
		ASSET_TEXTURE: 'texture',
		ASSET_CUBEMAP: 'cubemap',
		ASSET_SCRIPT: 'script'
	};
	AssetRegistry.prototype.getAssetById = function (id) {
		return this.get(id);
	};
	Object.defineProperty(XrInputSource.prototype, 'ray', {
		get: function get() {
			return this._rayLocal;
		}
	});
	Object.defineProperty(XrInputSource.prototype, 'position', {
		get: function get() {
			return this._localPosition;
		}
	});
	Object.defineProperty(XrInputSource.prototype, 'rotation', {
		get: function get() {
			return this._localRotation;
		}
	});
	var input = {
		getTouchTargetCoords: getTouchTargetCoords,
		Controller: Controller,
		GamePads: GamePads,
		Keyboard: Keyboard,
		KeyboardEvent: KeyboardEvent,
		Mouse: Mouse,
		MouseEvent: MouseEvent,
		Touch: Touch,
		TouchDevice: TouchDevice,
		TouchEvent: TouchEvent
	};
	Object.defineProperty(ElementInput.prototype, 'wheel', {
		get: function get() {
			return this.wheelDelta * -2;
		}
	});
	Object.defineProperty(MouseEvent.prototype, 'wheel', {
		get: function get() {
			return this.wheelDelta * -2;
		}
	});
	var RIGIDBODY_TYPE_STATIC = BODYTYPE_STATIC;
	var RIGIDBODY_TYPE_DYNAMIC = BODYTYPE_DYNAMIC;
	var RIGIDBODY_TYPE_KINEMATIC = BODYTYPE_KINEMATIC;
	var RIGIDBODY_CF_STATIC_OBJECT = BODYFLAG_STATIC_OBJECT;
	var RIGIDBODY_CF_KINEMATIC_OBJECT = BODYFLAG_KINEMATIC_OBJECT;
	var RIGIDBODY_CF_NORESPONSE_OBJECT = BODYFLAG_NORESPONSE_OBJECT;
	var RIGIDBODY_ACTIVE_TAG = BODYSTATE_ACTIVE_TAG;
	var RIGIDBODY_ISLAND_SLEEPING = BODYSTATE_ISLAND_SLEEPING;
	var RIGIDBODY_WANTS_DEACTIVATION = BODYSTATE_WANTS_DEACTIVATION;
	var RIGIDBODY_DISABLE_DEACTIVATION = BODYSTATE_DISABLE_DEACTIVATION;
	var RIGIDBODY_DISABLE_SIMULATION = BODYSTATE_DISABLE_SIMULATION;
	AppBase.prototype.isFullscreen = function () {
		return !!document.fullscreenElement;
	};
	AppBase.prototype.enableFullscreen = function (element, success, error) {
		element = element || this.graphicsDevice.canvas;
		var s = function s() {
			success();
			document.removeEventListener('fullscreenchange', s);
		};
		var e = function e() {
			error();
			document.removeEventListener('fullscreenerror', e);
		};
		if (success) {
			document.addEventListener('fullscreenchange', s, false);
		}
		if (error) {
			document.addEventListener('fullscreenerror', e, false);
		}
		if (element.requestFullscreen) {
			element.requestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
		} else {
			error();
		}
	};
	AppBase.prototype.disableFullscreen = function (success) {
		var s = function s() {
			success();
			document.removeEventListener('fullscreenchange', s);
		};
		if (success) {
			document.addEventListener('fullscreenchange', s, false);
		}
		document.exitFullscreen();
	};
	AppBase.prototype.getSceneUrl = function (name) {
		var entry = this.scenes.find(name);
		if (entry) {
			return entry.url;
		}
		return null;
	};
	AppBase.prototype.loadScene = function (url, callback) {
		this.scenes.loadScene(url, callback);
	};
	AppBase.prototype.loadSceneHierarchy = function (url, callback) {
		this.scenes.loadSceneHierarchy(url, callback);
	};
	AppBase.prototype.loadSceneSettings = function (url, callback) {
		this.scenes.loadSceneSettings(url, callback);
	};
	AppBase.prototype.renderMeshInstance = function (meshInstance, options) {
		var layer = options != null && options.layer ? options.layer : this.scene.defaultDrawLayer;
		this.scene.immediate.drawMesh(null, null, null, meshInstance, layer);
	};
	AppBase.prototype.renderMesh = function (mesh, material, matrix, options) {
		var layer = options != null && options.layer ? options.layer : this.scene.defaultDrawLayer;
		this.scene.immediate.drawMesh(material, matrix, mesh, null, layer);
	};
	AppBase.prototype._addLines = function (positions, colors, options) {
		var layer = options && options.layer ? options.layer : this.scene.layers.getLayerById(LAYERID_IMMEDIATE);
		var depthTest = options && options.depthTest !== undefined ? options.depthTest : true;
		var batch = this.scene.immediate.getBatch(layer, depthTest);
		batch.addLines(positions, colors);
	};
	AppBase.prototype.renderLine = function (start, end, color) {
		var endColor = color;
		var options;
		var arg3 = arguments[3];
		var arg4 = arguments[4];
		if (arg3 instanceof Color) {
			endColor = arg3;
			if (typeof arg4 === 'number') {
				if (arg4 === LINEBATCH_OVERLAY) {
					options = {
						layer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),
						depthTest: false
					};
				} else {
					options = {
						layer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),
						depthTest: true
					};
				}
			} else {
				options = arg4;
			}
		} else if (typeof arg3 === 'number') {
			endColor = color;
			if (arg3 === LINEBATCH_OVERLAY) {
				options = {
					layer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),
					depthTest: false
				};
			} else {
				options = {
					layer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),
					depthTest: true
				};
			}
		} else if (arg3) {
			options = arg3;
		}
		this._addLines([start, end], [color, endColor], options);
	};
	AppBase.prototype.renderLines = function (position, color, options) {
		if (!options) {
			options = {
				layer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),
				depthTest: true
			};
		} else if (typeof options === 'number') {
			if (options === LINEBATCH_OVERLAY) {
				options = {
					layer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),
					depthTest: false
				};
			} else {
				options = {
					layer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),
					depthTest: true
				};
			}
		}
		var multiColor = !!color.length;
		if (multiColor) {
			if (position.length !== color.length) {
				console.error('renderLines: position/color arrays have different lengths');
				return;
			}
		}
		if (position.length % 2 !== 0) {
			console.error('renderLines: array length is not divisible by 2');
			return;
		}
		this._addLines(position, color, options);
	};
	AppBase.prototype.enableVr = function () {};
	Object.defineProperty(CameraComponent.prototype, 'node', {
		get: function get() {
			return this.entity;
		}
	});
	Object.defineProperty(LightComponent.prototype, 'enable', {
		get: function get() {
			return this.enabled;
		},
		set: function set(value) {
			this.enabled = value;
		}
	});
	ModelComponent.prototype.setVisible = function (visible) {
		this.enabled = visible;
	};
	Object.defineProperty(ModelComponent.prototype, 'aabb', {
		get: function get() {
			return null;
		},
		set: function set(type) {}
	});
	Object.defineProperty(RenderComponent.prototype, 'aabb', {
		get: function get() {
			return null;
		},
		set: function set(type) {}
	});
	Object.defineProperty(RigidBodyComponent.prototype, 'bodyType', {
		get: function get() {
			return this.type;
		},
		set: function set(type) {
			this.type = type;
		}
	});
	RigidBodyComponent.prototype.syncBodyToEntity = function () {
		this._updateDynamic();
	};
	RigidBodyComponentSystem.prototype.setGravity = function () {
		if (arguments.length === 1) {
			this.gravity.copy(arguments[0]);
		} else {
			this.gravity.set(arguments[0], arguments[1], arguments[2]);
		}
	};
	function basisSetDownloadConfig(glueUrl, wasmUrl, fallbackUrl) {
		basisInitialize({
			glueUrl: glueUrl,
			wasmUrl: wasmUrl,
			fallbackUrl: fallbackUrl,
			lazyInit: true
		});
	}
	function prefilterCubemap(options) {}

	exports.ABSOLUTE_URL = ABSOLUTE_URL;
	exports.ACTION_GAMEPAD = ACTION_GAMEPAD;
	exports.ACTION_KEYBOARD = ACTION_KEYBOARD;
	exports.ACTION_MOUSE = ACTION_MOUSE;
	exports.ADDRESS_CLAMP_TO_EDGE = ADDRESS_CLAMP_TO_EDGE;
	exports.ADDRESS_MIRRORED_REPEAT = ADDRESS_MIRRORED_REPEAT;
	exports.ADDRESS_REPEAT = ADDRESS_REPEAT;
	exports.ANIM_BLEND_1D = ANIM_BLEND_1D;
	exports.ANIM_BLEND_2D_CARTESIAN = ANIM_BLEND_2D_CARTESIAN;
	exports.ANIM_BLEND_2D_DIRECTIONAL = ANIM_BLEND_2D_DIRECTIONAL;
	exports.ANIM_BLEND_DIRECT = ANIM_BLEND_DIRECT;
	exports.ANIM_CONTROL_STATES = ANIM_CONTROL_STATES;
	exports.ANIM_EQUAL_TO = ANIM_EQUAL_TO;
	exports.ANIM_GREATER_THAN = ANIM_GREATER_THAN;
	exports.ANIM_GREATER_THAN_EQUAL_TO = ANIM_GREATER_THAN_EQUAL_TO;
	exports.ANIM_INTERRUPTION_NEXT = ANIM_INTERRUPTION_NEXT;
	exports.ANIM_INTERRUPTION_NEXT_PREV = ANIM_INTERRUPTION_NEXT_PREV;
	exports.ANIM_INTERRUPTION_NONE = ANIM_INTERRUPTION_NONE;
	exports.ANIM_INTERRUPTION_PREV = ANIM_INTERRUPTION_PREV;
	exports.ANIM_INTERRUPTION_PREV_NEXT = ANIM_INTERRUPTION_PREV_NEXT;
	exports.ANIM_LAYER_ADDITIVE = ANIM_LAYER_ADDITIVE;
	exports.ANIM_LAYER_OVERWRITE = ANIM_LAYER_OVERWRITE;
	exports.ANIM_LESS_THAN = ANIM_LESS_THAN;
	exports.ANIM_LESS_THAN_EQUAL_TO = ANIM_LESS_THAN_EQUAL_TO;
	exports.ANIM_NOT_EQUAL_TO = ANIM_NOT_EQUAL_TO;
	exports.ANIM_PARAMETER_BOOLEAN = ANIM_PARAMETER_BOOLEAN;
	exports.ANIM_PARAMETER_FLOAT = ANIM_PARAMETER_FLOAT;
	exports.ANIM_PARAMETER_INTEGER = ANIM_PARAMETER_INTEGER;
	exports.ANIM_PARAMETER_TRIGGER = ANIM_PARAMETER_TRIGGER;
	exports.ANIM_STATE_ANY = ANIM_STATE_ANY;
	exports.ANIM_STATE_END = ANIM_STATE_END;
	exports.ANIM_STATE_START = ANIM_STATE_START;
	exports.ASPECT_AUTO = ASPECT_AUTO;
	exports.ASPECT_MANUAL = ASPECT_MANUAL;
	exports.ASSET_ANIMATION = ASSET_ANIMATION;
	exports.ASSET_AUDIO = ASSET_AUDIO;
	exports.ASSET_CONTAINER = ASSET_CONTAINER;
	exports.ASSET_CSS = ASSET_CSS;
	exports.ASSET_CUBEMAP = ASSET_CUBEMAP;
	exports.ASSET_HTML = ASSET_HTML;
	exports.ASSET_IMAGE = ASSET_IMAGE;
	exports.ASSET_JSON = ASSET_JSON;
	exports.ASSET_MATERIAL = ASSET_MATERIAL;
	exports.ASSET_MODEL = ASSET_MODEL;
	exports.ASSET_SCRIPT = ASSET_SCRIPT;
	exports.ASSET_SHADER = ASSET_SHADER;
	exports.ASSET_TEXT = ASSET_TEXT;
	exports.ASSET_TEXTURE = ASSET_TEXTURE;
	exports.ASSET_TEXTUREATLAS = ASSET_TEXTUREATLAS;
	exports.AXIS_KEY = AXIS_KEY;
	exports.AXIS_MOUSE_X = AXIS_MOUSE_X;
	exports.AXIS_MOUSE_Y = AXIS_MOUSE_Y;
	exports.AXIS_PAD_L_X = AXIS_PAD_L_X;
	exports.AXIS_PAD_L_Y = AXIS_PAD_L_Y;
	exports.AXIS_PAD_R_X = AXIS_PAD_R_X;
	exports.AXIS_PAD_R_Y = AXIS_PAD_R_Y;
	exports.AnimBinder = AnimBinder;
	exports.AnimClip = AnimClip;
	exports.AnimClipHandler = AnimClipHandler;
	exports.AnimComponent = AnimComponent;
	exports.AnimComponentLayer = AnimComponentLayer;
	exports.AnimComponentSystem = AnimComponentSystem;
	exports.AnimController = AnimController;
	exports.AnimCurve = AnimCurve;
	exports.AnimData = AnimData;
	exports.AnimEvaluator = AnimEvaluator;
	exports.AnimEvents = AnimEvents;
	exports.AnimSnapshot = AnimSnapshot;
	exports.AnimStateGraph = AnimStateGraph;
	exports.AnimStateGraphHandler = AnimStateGraphHandler;
	exports.AnimTarget = AnimTarget;
	exports.AnimTrack = AnimTrack;
	exports.Animation = Animation;
	exports.AnimationComponent = AnimationComponent;
	exports.AnimationComponentSystem = AnimationComponentSystem;
	exports.AnimationHandler = AnimationHandler;
	exports.AppBase = AppBase;
	exports.AppOptions = AppOptions;
	exports.Application = Application;
	exports.Asset = Asset;
	exports.AssetListLoader = AssetListLoader;
	exports.AssetReference = AssetReference;
	exports.AssetRegistry = AssetRegistry;
	exports.AudioHandler = AudioHandler;
	exports.AudioListenerComponent = AudioListenerComponent;
	exports.AudioListenerComponentSystem = AudioListenerComponentSystem;
	exports.AudioSourceComponent = AudioSourceComponent;
	exports.AudioSourceComponentSystem = AudioSourceComponentSystem;
	exports.BAKE_COLOR = BAKE_COLOR;
	exports.BAKE_COLORDIR = BAKE_COLORDIR;
	exports.BINDGROUP_MESH = BINDGROUP_MESH;
	exports.BINDGROUP_VIEW = BINDGROUP_VIEW;
	exports.BLENDEQUATION_ADD = BLENDEQUATION_ADD;
	exports.BLENDEQUATION_MAX = BLENDEQUATION_MAX;
	exports.BLENDEQUATION_MIN = BLENDEQUATION_MIN;
	exports.BLENDEQUATION_REVERSE_SUBTRACT = BLENDEQUATION_REVERSE_SUBTRACT;
	exports.BLENDEQUATION_SUBTRACT = BLENDEQUATION_SUBTRACT;
	exports.BLENDMODE_CONSTANT = BLENDMODE_CONSTANT;
	exports.BLENDMODE_CONSTANT_ALPHA = BLENDMODE_CONSTANT_ALPHA;
	exports.BLENDMODE_CONSTANT_COLOR = BLENDMODE_CONSTANT_COLOR;
	exports.BLENDMODE_DST_ALPHA = BLENDMODE_DST_ALPHA;
	exports.BLENDMODE_DST_COLOR = BLENDMODE_DST_COLOR;
	exports.BLENDMODE_ONE = BLENDMODE_ONE;
	exports.BLENDMODE_ONE_MINUS_CONSTANT = BLENDMODE_ONE_MINUS_CONSTANT;
	exports.BLENDMODE_ONE_MINUS_CONSTANT_ALPHA = BLENDMODE_ONE_MINUS_CONSTANT_ALPHA;
	exports.BLENDMODE_ONE_MINUS_CONSTANT_COLOR = BLENDMODE_ONE_MINUS_CONSTANT_COLOR;
	exports.BLENDMODE_ONE_MINUS_DST_ALPHA = BLENDMODE_ONE_MINUS_DST_ALPHA;
	exports.BLENDMODE_ONE_MINUS_DST_COLOR = BLENDMODE_ONE_MINUS_DST_COLOR;
	exports.BLENDMODE_ONE_MINUS_SRC_ALPHA = BLENDMODE_ONE_MINUS_SRC_ALPHA;
	exports.BLENDMODE_ONE_MINUS_SRC_COLOR = BLENDMODE_ONE_MINUS_SRC_COLOR;
	exports.BLENDMODE_SRC_ALPHA = BLENDMODE_SRC_ALPHA;
	exports.BLENDMODE_SRC_ALPHA_SATURATE = BLENDMODE_SRC_ALPHA_SATURATE;
	exports.BLENDMODE_SRC_COLOR = BLENDMODE_SRC_COLOR;
	exports.BLENDMODE_ZERO = BLENDMODE_ZERO;
	exports.BLEND_ADDITIVE = BLEND_ADDITIVE;
	exports.BLEND_ADDITIVEALPHA = BLEND_ADDITIVEALPHA;
	exports.BLEND_MAX = BLEND_MAX;
	exports.BLEND_MIN = BLEND_MIN;
	exports.BLEND_MULTIPLICATIVE = BLEND_MULTIPLICATIVE;
	exports.BLEND_MULTIPLICATIVE2X = BLEND_MULTIPLICATIVE2X;
	exports.BLEND_NONE = BLEND_NONE;
	exports.BLEND_NORMAL = BLEND_NORMAL;
	exports.BLEND_PREMULTIPLIED = BLEND_PREMULTIPLIED;
	exports.BLEND_SCREEN = BLEND_SCREEN;
	exports.BLEND_SUBTRACTIVE = BLEND_SUBTRACTIVE;
	exports.BLUR_BOX = BLUR_BOX;
	exports.BLUR_GAUSSIAN = BLUR_GAUSSIAN;
	exports.BODYFLAG_KINEMATIC_OBJECT = BODYFLAG_KINEMATIC_OBJECT;
	exports.BODYFLAG_NORESPONSE_OBJECT = BODYFLAG_NORESPONSE_OBJECT;
	exports.BODYFLAG_STATIC_OBJECT = BODYFLAG_STATIC_OBJECT;
	exports.BODYGROUP_DEFAULT = BODYGROUP_DEFAULT;
	exports.BODYGROUP_DYNAMIC = BODYGROUP_DYNAMIC;
	exports.BODYGROUP_ENGINE_1 = BODYGROUP_ENGINE_1;
	exports.BODYGROUP_ENGINE_2 = BODYGROUP_ENGINE_2;
	exports.BODYGROUP_ENGINE_3 = BODYGROUP_ENGINE_3;
	exports.BODYGROUP_KINEMATIC = BODYGROUP_KINEMATIC;
	exports.BODYGROUP_NONE = BODYGROUP_NONE;
	exports.BODYGROUP_STATIC = BODYGROUP_STATIC;
	exports.BODYGROUP_TRIGGER = BODYGROUP_TRIGGER;
	exports.BODYGROUP_USER_1 = BODYGROUP_USER_1;
	exports.BODYGROUP_USER_2 = BODYGROUP_USER_2;
	exports.BODYGROUP_USER_3 = BODYGROUP_USER_3;
	exports.BODYGROUP_USER_4 = BODYGROUP_USER_4;
	exports.BODYGROUP_USER_5 = BODYGROUP_USER_5;
	exports.BODYGROUP_USER_6 = BODYGROUP_USER_6;
	exports.BODYGROUP_USER_7 = BODYGROUP_USER_7;
	exports.BODYGROUP_USER_8 = BODYGROUP_USER_8;
	exports.BODYMASK_ALL = BODYMASK_ALL;
	exports.BODYMASK_NONE = BODYMASK_NONE;
	exports.BODYMASK_NOT_STATIC = BODYMASK_NOT_STATIC;
	exports.BODYMASK_NOT_STATIC_KINEMATIC = BODYMASK_NOT_STATIC_KINEMATIC;
	exports.BODYMASK_STATIC = BODYMASK_STATIC;
	exports.BODYSTATE_ACTIVE_TAG = BODYSTATE_ACTIVE_TAG;
	exports.BODYSTATE_DISABLE_DEACTIVATION = BODYSTATE_DISABLE_DEACTIVATION;
	exports.BODYSTATE_DISABLE_SIMULATION = BODYSTATE_DISABLE_SIMULATION;
	exports.BODYSTATE_ISLAND_SLEEPING = BODYSTATE_ISLAND_SLEEPING;
	exports.BODYSTATE_WANTS_DEACTIVATION = BODYSTATE_WANTS_DEACTIVATION;
	exports.BODYTYPE_DYNAMIC = BODYTYPE_DYNAMIC;
	exports.BODYTYPE_KINEMATIC = BODYTYPE_KINEMATIC;
	exports.BODYTYPE_STATIC = BODYTYPE_STATIC;
	exports.BUFFER_DYNAMIC = BUFFER_DYNAMIC;
	exports.BUFFER_GPUDYNAMIC = BUFFER_GPUDYNAMIC;
	exports.BUFFER_STATIC = BUFFER_STATIC;
	exports.BUFFER_STREAM = BUFFER_STREAM;
	exports.BUTTON_TRANSITION_MODE_SPRITE_CHANGE = BUTTON_TRANSITION_MODE_SPRITE_CHANGE;
	exports.BUTTON_TRANSITION_MODE_TINT = BUTTON_TRANSITION_MODE_TINT;
	exports.BasicMaterial = BasicMaterial;
	exports.Batch = Batch;
	exports.BatchGroup = BatchGroup;
	exports.BatchManager = BatchManager;
	exports.BinaryHandler = BinaryHandler;
	exports.BindBufferFormat = BindBufferFormat;
	exports.BindGroupFormat = BindGroupFormat;
	exports.BindStorageTextureFormat = BindStorageTextureFormat;
	exports.BindTextureFormat = BindTextureFormat;
	exports.BlendState = BlendState;
	exports.BoundingBox = BoundingBox;
	exports.BoundingSphere = BoundingSphere;
	exports.Bundle = Bundle;
	exports.BundleHandler = BundleHandler;
	exports.BundleRegistry = BundleRegistry;
	exports.ButtonComponent = ButtonComponent;
	exports.ButtonComponentSystem = ButtonComponentSystem;
	exports.CHUNKAPI_1_51 = CHUNKAPI_1_51;
	exports.CHUNKAPI_1_55 = CHUNKAPI_1_55;
	exports.CHUNKAPI_1_56 = CHUNKAPI_1_56;
	exports.CHUNKAPI_1_57 = CHUNKAPI_1_57;
	exports.CHUNKAPI_1_58 = CHUNKAPI_1_58;
	exports.CHUNKAPI_1_60 = CHUNKAPI_1_60;
	exports.CHUNKAPI_1_62 = CHUNKAPI_1_62;
	exports.CHUNKAPI_1_65 = CHUNKAPI_1_65;
	exports.CLEARFLAG_COLOR = CLEARFLAG_COLOR;
	exports.CLEARFLAG_DEPTH = CLEARFLAG_DEPTH;
	exports.CLEARFLAG_STENCIL = CLEARFLAG_STENCIL;
	exports.CUBEFACE_NEGX = CUBEFACE_NEGX;
	exports.CUBEFACE_NEGY = CUBEFACE_NEGY;
	exports.CUBEFACE_NEGZ = CUBEFACE_NEGZ;
	exports.CUBEFACE_POSX = CUBEFACE_POSX;
	exports.CUBEFACE_POSY = CUBEFACE_POSY;
	exports.CUBEFACE_POSZ = CUBEFACE_POSZ;
	exports.CUBEPROJ_BOX = CUBEPROJ_BOX;
	exports.CUBEPROJ_NONE = CUBEPROJ_NONE;
	exports.CULLFACE_BACK = CULLFACE_BACK;
	exports.CULLFACE_FRONT = CULLFACE_FRONT;
	exports.CULLFACE_FRONTANDBACK = CULLFACE_FRONTANDBACK;
	exports.CULLFACE_NONE = CULLFACE_NONE;
	exports.CURVE_CARDINAL = CURVE_CARDINAL;
	exports.CURVE_CATMULL = CURVE_CATMULL;
	exports.CURVE_LINEAR = CURVE_LINEAR;
	exports.CURVE_SMOOTHSTEP = CURVE_SMOOTHSTEP;
	exports.CURVE_SPLINE = CURVE_SPLINE;
	exports.CURVE_STEP = CURVE_STEP;
	exports.Camera = Camera;
	exports.CameraComponent = CameraComponent;
	exports.CameraComponentSystem = CameraComponentSystem;
	exports.CanvasFont = CanvasFont;
	exports.ChunkBuilder = ChunkBuilder;
	exports.CollisionComponent = CollisionComponent;
	exports.CollisionComponentSystem = CollisionComponentSystem;
	exports.Color = Color;
	exports.Component = Component;
	exports.ComponentSystem = ComponentSystem;
	exports.ComponentSystemRegistry = ComponentSystemRegistry;
	exports.Compute = Compute;
	exports.ContactPoint = ContactPoint;
	exports.ContactResult = ContactResult;
	exports.ContainerHandler = ContainerHandler;
	exports.ContainerResource = ContainerResource;
	exports.ContextCreationError = ContextCreationError;
	exports.Controller = Controller;
	exports.CssHandler = CssHandler;
	exports.CubemapHandler = CubemapHandler;
	exports.Curve = Curve;
	exports.CurveSet = CurveSet;
	exports.DETAILMODE_ADD = DETAILMODE_ADD;
	exports.DETAILMODE_MAX = DETAILMODE_MAX;
	exports.DETAILMODE_MIN = DETAILMODE_MIN;
	exports.DETAILMODE_MUL = DETAILMODE_MUL;
	exports.DETAILMODE_OVERLAY = DETAILMODE_OVERLAY;
	exports.DETAILMODE_SCREEN = DETAILMODE_SCREEN;
	exports.DEVICETYPE_NULL = DEVICETYPE_NULL;
	exports.DEVICETYPE_WEBGL1 = DEVICETYPE_WEBGL1;
	exports.DEVICETYPE_WEBGL2 = DEVICETYPE_WEBGL2;
	exports.DEVICETYPE_WEBGPU = DEVICETYPE_WEBGPU;
	exports.DISTANCE_EXPONENTIAL = DISTANCE_EXPONENTIAL;
	exports.DISTANCE_INVERSE = DISTANCE_INVERSE;
	exports.DISTANCE_LINEAR = DISTANCE_LINEAR;
	exports.DefaultAnimBinder = DefaultAnimBinder;
	exports.DepthState = DepthState;
	exports.ELEMENTTYPE_FLOAT32 = ELEMENTTYPE_FLOAT32;
	exports.ELEMENTTYPE_GROUP = ELEMENTTYPE_GROUP;
	exports.ELEMENTTYPE_IMAGE = ELEMENTTYPE_IMAGE;
	exports.ELEMENTTYPE_INT16 = ELEMENTTYPE_INT16;
	exports.ELEMENTTYPE_INT32 = ELEMENTTYPE_INT32;
	exports.ELEMENTTYPE_INT8 = ELEMENTTYPE_INT8;
	exports.ELEMENTTYPE_TEXT = ELEMENTTYPE_TEXT;
	exports.ELEMENTTYPE_UINT16 = ELEMENTTYPE_UINT16;
	exports.ELEMENTTYPE_UINT32 = ELEMENTTYPE_UINT32;
	exports.ELEMENTTYPE_UINT8 = ELEMENTTYPE_UINT8;
	exports.EMITTERSHAPE_BOX = EMITTERSHAPE_BOX;
	exports.EMITTERSHAPE_SPHERE = EMITTERSHAPE_SPHERE;
	exports.EVENT_GAMEPADCONNECTED = EVENT_GAMEPADCONNECTED;
	exports.EVENT_GAMEPADDISCONNECTED = EVENT_GAMEPADDISCONNECTED;
	exports.EVENT_KEYDOWN = EVENT_KEYDOWN;
	exports.EVENT_KEYUP = EVENT_KEYUP;
	exports.EVENT_MOUSEDOWN = EVENT_MOUSEDOWN;
	exports.EVENT_MOUSEMOVE = EVENT_MOUSEMOVE;
	exports.EVENT_MOUSEUP = EVENT_MOUSEUP;
	exports.EVENT_MOUSEWHEEL = EVENT_MOUSEWHEEL;
	exports.EVENT_SELECT = EVENT_SELECT;
	exports.EVENT_SELECTEND = EVENT_SELECTEND;
	exports.EVENT_SELECTSTART = EVENT_SELECTSTART;
	exports.EVENT_TOUCHCANCEL = EVENT_TOUCHCANCEL;
	exports.EVENT_TOUCHEND = EVENT_TOUCHEND;
	exports.EVENT_TOUCHMOVE = EVENT_TOUCHMOVE;
	exports.EVENT_TOUCHSTART = EVENT_TOUCHSTART;
	exports.ElementComponent = ElementComponent;
	exports.ElementComponentSystem = ElementComponentSystem;
	exports.ElementDragHelper = ElementDragHelper;
	exports.ElementInput = ElementInput;
	exports.ElementInputEvent = ElementInputEvent;
	exports.ElementMouseEvent = ElementMouseEvent;
	exports.ElementSelectEvent = ElementSelectEvent;
	exports.ElementTouchEvent = ElementTouchEvent;
	exports.Entity = Entity;
	exports.EntityReference = EntityReference;
	exports.EnvLighting = EnvLighting;
	exports.EventHandler = EventHandler;
	exports.FILLMODE_FILL_WINDOW = FILLMODE_FILL_WINDOW;
	exports.FILLMODE_KEEP_ASPECT = FILLMODE_KEEP_ASPECT;
	exports.FILLMODE_NONE = FILLMODE_NONE;
	exports.FILTER_LINEAR = FILTER_LINEAR;
	exports.FILTER_LINEAR_MIPMAP_LINEAR = FILTER_LINEAR_MIPMAP_LINEAR;
	exports.FILTER_LINEAR_MIPMAP_NEAREST = FILTER_LINEAR_MIPMAP_NEAREST;
	exports.FILTER_NEAREST = FILTER_NEAREST;
	exports.FILTER_NEAREST_MIPMAP_LINEAR = FILTER_NEAREST_MIPMAP_LINEAR;
	exports.FILTER_NEAREST_MIPMAP_NEAREST = FILTER_NEAREST_MIPMAP_NEAREST;
	exports.FITMODE_CONTAIN = FITMODE_CONTAIN;
	exports.FITMODE_COVER = FITMODE_COVER;
	exports.FITMODE_STRETCH = FITMODE_STRETCH;
	exports.FITTING_BOTH = FITTING_BOTH;
	exports.FITTING_NONE = FITTING_NONE;
	exports.FITTING_SHRINK = FITTING_SHRINK;
	exports.FITTING_STRETCH = FITTING_STRETCH;
	exports.FOG_EXP = FOG_EXP;
	exports.FOG_EXP2 = FOG_EXP2;
	exports.FOG_LINEAR = FOG_LINEAR;
	exports.FOG_NONE = FOG_NONE;
	exports.FONT_BITMAP = FONT_BITMAP;
	exports.FONT_MSDF = FONT_MSDF;
	exports.FRESNEL_NONE = FRESNEL_NONE;
	exports.FRESNEL_SCHLICK = FRESNEL_SCHLICK;
	exports.FUNC_ALWAYS = FUNC_ALWAYS;
	exports.FUNC_EQUAL = FUNC_EQUAL;
	exports.FUNC_GREATER = FUNC_GREATER;
	exports.FUNC_GREATEREQUAL = FUNC_GREATEREQUAL;
	exports.FUNC_LESS = FUNC_LESS;
	exports.FUNC_LESSEQUAL = FUNC_LESSEQUAL;
	exports.FUNC_NEVER = FUNC_NEVER;
	exports.FUNC_NOTEQUAL = FUNC_NOTEQUAL;
	exports.FloatPacking = FloatPacking;
	exports.FolderHandler = FolderHandler;
	exports.Font = Font;
	exports.FontHandler = FontHandler;
	exports.ForwardRenderer = ForwardRenderer;
	exports.Frustum = Frustum;
	exports.GAMMA_NONE = GAMMA_NONE;
	exports.GAMMA_SRGB = GAMMA_SRGB;
	exports.GAMMA_SRGBFAST = GAMMA_SRGBFAST;
	exports.GAMMA_SRGBHDR = GAMMA_SRGBHDR;
	exports.GamePads = GamePads;
	exports.GraphNode = GraphNode;
	exports.GraphicsDevice = GraphicsDevice;
	exports.HierarchyHandler = HierarchyHandler;
	exports.HtmlHandler = HtmlHandler;
	exports.Http = Http;
	exports.I18n = I18n;
	exports.INDEXFORMAT_UINT16 = INDEXFORMAT_UINT16;
	exports.INDEXFORMAT_UINT32 = INDEXFORMAT_UINT32;
	exports.INDEXFORMAT_UINT8 = INDEXFORMAT_UINT8;
	exports.INTERPOLATION_CUBIC = INTERPOLATION_CUBIC;
	exports.INTERPOLATION_LINEAR = INTERPOLATION_LINEAR;
	exports.INTERPOLATION_STEP = INTERPOLATION_STEP;
	exports.ImageElement = ImageElement;
	exports.IndexBuffer = IndexBuffer;
	exports.IndexedList = IndexedList;
	exports.JointComponent = JointComponent;
	exports.JointComponentSystem = JointComponentSystem;
	exports.JsonHandler = JsonHandler;
	exports.JsonStandardMaterialParser = JsonStandardMaterialParser;
	exports.KEY_0 = KEY_0;
	exports.KEY_1 = KEY_1;
	exports.KEY_2 = KEY_2;
	exports.KEY_3 = KEY_3;
	exports.KEY_4 = KEY_4;
	exports.KEY_5 = KEY_5;
	exports.KEY_6 = KEY_6;
	exports.KEY_7 = KEY_7;
	exports.KEY_8 = KEY_8;
	exports.KEY_9 = KEY_9;
	exports.KEY_A = KEY_A;
	exports.KEY_ADD = KEY_ADD;
	exports.KEY_ALT = KEY_ALT;
	exports.KEY_B = KEY_B;
	exports.KEY_BACKSPACE = KEY_BACKSPACE;
	exports.KEY_BACK_SLASH = KEY_BACK_SLASH;
	exports.KEY_C = KEY_C;
	exports.KEY_CAPS_LOCK = KEY_CAPS_LOCK;
	exports.KEY_CLOSE_BRACKET = KEY_CLOSE_BRACKET;
	exports.KEY_COMMA = KEY_COMMA;
	exports.KEY_CONTEXT_MENU = KEY_CONTEXT_MENU;
	exports.KEY_CONTROL = KEY_CONTROL;
	exports.KEY_D = KEY_D;
	exports.KEY_DECIMAL = KEY_DECIMAL;
	exports.KEY_DELETE = KEY_DELETE;
	exports.KEY_DIVIDE = KEY_DIVIDE;
	exports.KEY_DOWN = KEY_DOWN;
	exports.KEY_E = KEY_E;
	exports.KEY_END = KEY_END;
	exports.KEY_ENTER = KEY_ENTER;
	exports.KEY_EQUAL = KEY_EQUAL;
	exports.KEY_ESCAPE = KEY_ESCAPE;
	exports.KEY_F = KEY_F;
	exports.KEY_F1 = KEY_F1;
	exports.KEY_F10 = KEY_F10;
	exports.KEY_F11 = KEY_F11;
	exports.KEY_F12 = KEY_F12;
	exports.KEY_F2 = KEY_F2;
	exports.KEY_F3 = KEY_F3;
	exports.KEY_F4 = KEY_F4;
	exports.KEY_F5 = KEY_F5;
	exports.KEY_F6 = KEY_F6;
	exports.KEY_F7 = KEY_F7;
	exports.KEY_F8 = KEY_F8;
	exports.KEY_F9 = KEY_F9;
	exports.KEY_G = KEY_G;
	exports.KEY_H = KEY_H;
	exports.KEY_HOME = KEY_HOME;
	exports.KEY_I = KEY_I;
	exports.KEY_INSERT = KEY_INSERT;
	exports.KEY_J = KEY_J;
	exports.KEY_K = KEY_K;
	exports.KEY_L = KEY_L;
	exports.KEY_LEFT = KEY_LEFT;
	exports.KEY_M = KEY_M;
	exports.KEY_META = KEY_META;
	exports.KEY_MULTIPLY = KEY_MULTIPLY;
	exports.KEY_N = KEY_N;
	exports.KEY_NUMPAD_0 = KEY_NUMPAD_0;
	exports.KEY_NUMPAD_1 = KEY_NUMPAD_1;
	exports.KEY_NUMPAD_2 = KEY_NUMPAD_2;
	exports.KEY_NUMPAD_3 = KEY_NUMPAD_3;
	exports.KEY_NUMPAD_4 = KEY_NUMPAD_4;
	exports.KEY_NUMPAD_5 = KEY_NUMPAD_5;
	exports.KEY_NUMPAD_6 = KEY_NUMPAD_6;
	exports.KEY_NUMPAD_7 = KEY_NUMPAD_7;
	exports.KEY_NUMPAD_8 = KEY_NUMPAD_8;
	exports.KEY_NUMPAD_9 = KEY_NUMPAD_9;
	exports.KEY_O = KEY_O;
	exports.KEY_OPEN_BRACKET = KEY_OPEN_BRACKET;
	exports.KEY_P = KEY_P;
	exports.KEY_PAGE_DOWN = KEY_PAGE_DOWN;
	exports.KEY_PAGE_UP = KEY_PAGE_UP;
	exports.KEY_PAUSE = KEY_PAUSE;
	exports.KEY_PERIOD = KEY_PERIOD;
	exports.KEY_PRINT_SCREEN = KEY_PRINT_SCREEN;
	exports.KEY_Q = KEY_Q;
	exports.KEY_R = KEY_R;
	exports.KEY_RETURN = KEY_RETURN;
	exports.KEY_RIGHT = KEY_RIGHT;
	exports.KEY_S = KEY_S;
	exports.KEY_SEMICOLON = KEY_SEMICOLON;
	exports.KEY_SEPARATOR = KEY_SEPARATOR;
	exports.KEY_SHIFT = KEY_SHIFT;
	exports.KEY_SLASH = KEY_SLASH;
	exports.KEY_SPACE = KEY_SPACE;
	exports.KEY_SUBTRACT = KEY_SUBTRACT;
	exports.KEY_T = KEY_T;
	exports.KEY_TAB = KEY_TAB;
	exports.KEY_U = KEY_U;
	exports.KEY_UP = KEY_UP;
	exports.KEY_V = KEY_V;
	exports.KEY_W = KEY_W;
	exports.KEY_WINDOWS = KEY_WINDOWS;
	exports.KEY_X = KEY_X;
	exports.KEY_Y = KEY_Y;
	exports.KEY_Z = KEY_Z;
	exports.Key = Key;
	exports.Keyboard = Keyboard;
	exports.KeyboardEvent = KeyboardEvent;
	exports.LAYERID_DEPTH = LAYERID_DEPTH;
	exports.LAYERID_IMMEDIATE = LAYERID_IMMEDIATE;
	exports.LAYERID_SKYBOX = LAYERID_SKYBOX;
	exports.LAYERID_UI = LAYERID_UI;
	exports.LAYERID_WORLD = LAYERID_WORLD;
	exports.LAYER_FX = LAYER_FX;
	exports.LAYER_GIZMO = LAYER_GIZMO;
	exports.LAYER_HUD = LAYER_HUD;
	exports.LAYER_WORLD = LAYER_WORLD;
	exports.LIGHTFALLOFF_INVERSESQUARED = LIGHTFALLOFF_INVERSESQUARED;
	exports.LIGHTFALLOFF_LINEAR = LIGHTFALLOFF_LINEAR;
	exports.LIGHTSHAPE_DISK = LIGHTSHAPE_DISK;
	exports.LIGHTSHAPE_PUNCTUAL = LIGHTSHAPE_PUNCTUAL;
	exports.LIGHTSHAPE_RECT = LIGHTSHAPE_RECT;
	exports.LIGHTSHAPE_SPHERE = LIGHTSHAPE_SPHERE;
	exports.LIGHTTYPE_COUNT = LIGHTTYPE_COUNT;
	exports.LIGHTTYPE_DIRECTIONAL = LIGHTTYPE_DIRECTIONAL;
	exports.LIGHTTYPE_OMNI = LIGHTTYPE_OMNI;
	exports.LIGHTTYPE_POINT = LIGHTTYPE_POINT;
	exports.LIGHTTYPE_SPOT = LIGHTTYPE_SPOT;
	exports.LINEBATCH_GIZMO = LINEBATCH_GIZMO;
	exports.LINEBATCH_OVERLAY = LINEBATCH_OVERLAY;
	exports.LINEBATCH_WORLD = LINEBATCH_WORLD;
	exports.Layer = Layer;
	exports.LayerComposition = LayerComposition;
	exports.LayoutCalculator = LayoutCalculator;
	exports.LayoutChildComponent = LayoutChildComponent;
	exports.LayoutChildComponentSystem = LayoutChildComponentSystem;
	exports.LayoutGroupComponent = LayoutGroupComponent;
	exports.LayoutGroupComponentSystem = LayoutGroupComponentSystem;
	exports.Light = Light;
	exports.LightComponent = LightComponent;
	exports.LightComponentSystem = LightComponentSystem;
	exports.LightingParams = LightingParams;
	exports.Lightmapper = Lightmapper;
	exports.LitMaterial = LitMaterial;
	exports.LitOptions = LitOptions;
	exports.LitShaderOptions = LitShaderOptions;
	exports.LocalizedAsset = LocalizedAsset;
	exports.MASK_AFFECT_DYNAMIC = MASK_AFFECT_DYNAMIC;
	exports.MASK_AFFECT_LIGHTMAPPED = MASK_AFFECT_LIGHTMAPPED;
	exports.MASK_BAKE = MASK_BAKE;
	exports.MOTION_FREE = MOTION_FREE;
	exports.MOTION_LIMITED = MOTION_LIMITED;
	exports.MOTION_LOCKED = MOTION_LOCKED;
	exports.MOUSEBUTTON_LEFT = MOUSEBUTTON_LEFT;
	exports.MOUSEBUTTON_MIDDLE = MOUSEBUTTON_MIDDLE;
	exports.MOUSEBUTTON_NONE = MOUSEBUTTON_NONE;
	exports.MOUSEBUTTON_RIGHT = MOUSEBUTTON_RIGHT;
	exports.Mat3 = Mat3;
	exports.Mat4 = Mat4;
	exports.Material = Material;
	exports.MaterialHandler = MaterialHandler;
	exports.Mesh = Mesh;
	exports.MeshInstance = MeshInstance;
	exports.Model = Model;
	exports.ModelComponent = ModelComponent;
	exports.ModelComponentSystem = ModelComponentSystem;
	exports.ModelHandler = ModelHandler;
	exports.Morph = Morph;
	exports.MorphInstance = MorphInstance;
	exports.MorphTarget = MorphTarget;
	exports.Mouse = Mouse;
	exports.MouseEvent = MouseEvent;
	exports.Node = Node;
	exports.NullGraphicsDevice = NullGraphicsDevice;
	exports.ORIENTATION_HORIZONTAL = ORIENTATION_HORIZONTAL;
	exports.ORIENTATION_VERTICAL = ORIENTATION_VERTICAL;
	exports.OrientedBox = OrientedBox;
	exports.PAD_1 = PAD_1;
	exports.PAD_2 = PAD_2;
	exports.PAD_3 = PAD_3;
	exports.PAD_4 = PAD_4;
	exports.PAD_DOWN = PAD_DOWN;
	exports.PAD_FACE_1 = PAD_FACE_1;
	exports.PAD_FACE_2 = PAD_FACE_2;
	exports.PAD_FACE_3 = PAD_FACE_3;
	exports.PAD_FACE_4 = PAD_FACE_4;
	exports.PAD_LEFT = PAD_LEFT;
	exports.PAD_L_SHOULDER_1 = PAD_L_SHOULDER_1;
	exports.PAD_L_SHOULDER_2 = PAD_L_SHOULDER_2;
	exports.PAD_L_STICK_BUTTON = PAD_L_STICK_BUTTON;
	exports.PAD_L_STICK_X = PAD_L_STICK_X;
	exports.PAD_L_STICK_Y = PAD_L_STICK_Y;
	exports.PAD_RIGHT = PAD_RIGHT;
	exports.PAD_R_SHOULDER_1 = PAD_R_SHOULDER_1;
	exports.PAD_R_SHOULDER_2 = PAD_R_SHOULDER_2;
	exports.PAD_R_STICK_BUTTON = PAD_R_STICK_BUTTON;
	exports.PAD_R_STICK_X = PAD_R_STICK_X;
	exports.PAD_R_STICK_Y = PAD_R_STICK_Y;
	exports.PAD_SELECT = PAD_SELECT;
	exports.PAD_START = PAD_START;
	exports.PAD_UP = PAD_UP;
	exports.PAD_VENDOR = PAD_VENDOR;
	exports.PARTICLEMODE_CPU = PARTICLEMODE_CPU;
	exports.PARTICLEMODE_GPU = PARTICLEMODE_GPU;
	exports.PARTICLEORIENTATION_EMITTER = PARTICLEORIENTATION_EMITTER;
	exports.PARTICLEORIENTATION_SCREEN = PARTICLEORIENTATION_SCREEN;
	exports.PARTICLEORIENTATION_WORLD = PARTICLEORIENTATION_WORLD;
	exports.PARTICLESORT_DISTANCE = PARTICLESORT_DISTANCE;
	exports.PARTICLESORT_NEWER_FIRST = PARTICLESORT_NEWER_FIRST;
	exports.PARTICLESORT_NONE = PARTICLESORT_NONE;
	exports.PARTICLESORT_OLDER_FIRST = PARTICLESORT_OLDER_FIRST;
	exports.PIXELFORMAT_111110F = PIXELFORMAT_111110F;
	exports.PIXELFORMAT_A8 = PIXELFORMAT_A8;
	exports.PIXELFORMAT_ASTC_4x4 = PIXELFORMAT_ASTC_4x4;
	exports.PIXELFORMAT_ATC_RGB = PIXELFORMAT_ATC_RGB;
	exports.PIXELFORMAT_ATC_RGBA = PIXELFORMAT_ATC_RGBA;
	exports.PIXELFORMAT_BGRA8 = PIXELFORMAT_BGRA8;
	exports.PIXELFORMAT_DEPTH = PIXELFORMAT_DEPTH;
	exports.PIXELFORMAT_DEPTHSTENCIL = PIXELFORMAT_DEPTHSTENCIL;
	exports.PIXELFORMAT_DXT1 = PIXELFORMAT_DXT1;
	exports.PIXELFORMAT_DXT3 = PIXELFORMAT_DXT3;
	exports.PIXELFORMAT_DXT5 = PIXELFORMAT_DXT5;
	exports.PIXELFORMAT_ETC1 = PIXELFORMAT_ETC1;
	exports.PIXELFORMAT_ETC2_RGB = PIXELFORMAT_ETC2_RGB;
	exports.PIXELFORMAT_ETC2_RGBA = PIXELFORMAT_ETC2_RGBA;
	exports.PIXELFORMAT_L8 = PIXELFORMAT_L8;
	exports.PIXELFORMAT_L8_A8 = PIXELFORMAT_L8_A8;
	exports.PIXELFORMAT_LA8 = PIXELFORMAT_LA8;
	exports.PIXELFORMAT_PVRTC_2BPP_RGBA_1 = PIXELFORMAT_PVRTC_2BPP_RGBA_1;
	exports.PIXELFORMAT_PVRTC_2BPP_RGB_1 = PIXELFORMAT_PVRTC_2BPP_RGB_1;
	exports.PIXELFORMAT_PVRTC_4BPP_RGBA_1 = PIXELFORMAT_PVRTC_4BPP_RGBA_1;
	exports.PIXELFORMAT_PVRTC_4BPP_RGB_1 = PIXELFORMAT_PVRTC_4BPP_RGB_1;
	exports.PIXELFORMAT_R32F = PIXELFORMAT_R32F;
	exports.PIXELFORMAT_R4_G4_B4_A4 = PIXELFORMAT_R4_G4_B4_A4;
	exports.PIXELFORMAT_R5_G5_B5_A1 = PIXELFORMAT_R5_G5_B5_A1;
	exports.PIXELFORMAT_R5_G6_B5 = PIXELFORMAT_R5_G6_B5;
	exports.PIXELFORMAT_R8_G8_B8 = PIXELFORMAT_R8_G8_B8;
	exports.PIXELFORMAT_R8_G8_B8_A8 = PIXELFORMAT_R8_G8_B8_A8;
	exports.PIXELFORMAT_RGB16F = PIXELFORMAT_RGB16F;
	exports.PIXELFORMAT_RGB32F = PIXELFORMAT_RGB32F;
	exports.PIXELFORMAT_RGB565 = PIXELFORMAT_RGB565;
	exports.PIXELFORMAT_RGB8 = PIXELFORMAT_RGB8;
	exports.PIXELFORMAT_RGBA16F = PIXELFORMAT_RGBA16F;
	exports.PIXELFORMAT_RGBA32F = PIXELFORMAT_RGBA32F;
	exports.PIXELFORMAT_RGBA4 = PIXELFORMAT_RGBA4;
	exports.PIXELFORMAT_RGBA5551 = PIXELFORMAT_RGBA5551;
	exports.PIXELFORMAT_RGBA8 = PIXELFORMAT_RGBA8;
	exports.PIXELFORMAT_SRGB = PIXELFORMAT_SRGB;
	exports.PIXELFORMAT_SRGBA = PIXELFORMAT_SRGBA;
	exports.PRIMITIVE_LINELOOP = PRIMITIVE_LINELOOP;
	exports.PRIMITIVE_LINES = PRIMITIVE_LINES;
	exports.PRIMITIVE_LINESTRIP = PRIMITIVE_LINESTRIP;
	exports.PRIMITIVE_POINTS = PRIMITIVE_POINTS;
	exports.PRIMITIVE_TRIANGLES = PRIMITIVE_TRIANGLES;
	exports.PRIMITIVE_TRIFAN = PRIMITIVE_TRIFAN;
	exports.PRIMITIVE_TRISTRIP = PRIMITIVE_TRISTRIP;
	exports.PROJECTION_ORTHOGRAPHIC = PROJECTION_ORTHOGRAPHIC;
	exports.PROJECTION_PERSPECTIVE = PROJECTION_PERSPECTIVE;
	exports.ParticleEmitter = ParticleEmitter;
	exports.ParticleSystemComponent = ParticleSystemComponent;
	exports.ParticleSystemComponentSystem = ParticleSystemComponentSystem;
	exports.PhongMaterial = PhongMaterial;
	exports.Picker = Picker;
	exports.Plane = Plane;
	exports.PostEffect = PostEffect$1;
	exports.PostEffectQueue = PostEffectQueue;
	exports.ProgramLibrary = ProgramLibrary;
	exports.QuadRender = QuadRender;
	exports.Quat = Quat;
	exports.RENDERSTYLE_POINTS = RENDERSTYLE_POINTS;
	exports.RENDERSTYLE_SOLID = RENDERSTYLE_SOLID;
	exports.RENDERSTYLE_WIREFRAME = RENDERSTYLE_WIREFRAME;
	exports.RESOLUTION_AUTO = RESOLUTION_AUTO;
	exports.RESOLUTION_FIXED = RESOLUTION_FIXED;
	exports.RIGIDBODY_ACTIVE_TAG = RIGIDBODY_ACTIVE_TAG;
	exports.RIGIDBODY_CF_KINEMATIC_OBJECT = RIGIDBODY_CF_KINEMATIC_OBJECT;
	exports.RIGIDBODY_CF_NORESPONSE_OBJECT = RIGIDBODY_CF_NORESPONSE_OBJECT;
	exports.RIGIDBODY_CF_STATIC_OBJECT = RIGIDBODY_CF_STATIC_OBJECT;
	exports.RIGIDBODY_DISABLE_DEACTIVATION = RIGIDBODY_DISABLE_DEACTIVATION;
	exports.RIGIDBODY_DISABLE_SIMULATION = RIGIDBODY_DISABLE_SIMULATION;
	exports.RIGIDBODY_ISLAND_SLEEPING = RIGIDBODY_ISLAND_SLEEPING;
	exports.RIGIDBODY_TYPE_DYNAMIC = RIGIDBODY_TYPE_DYNAMIC;
	exports.RIGIDBODY_TYPE_KINEMATIC = RIGIDBODY_TYPE_KINEMATIC;
	exports.RIGIDBODY_TYPE_STATIC = RIGIDBODY_TYPE_STATIC;
	exports.RIGIDBODY_WANTS_DEACTIVATION = RIGIDBODY_WANTS_DEACTIVATION;
	exports.Ray = Ray;
	exports.RaycastResult = RaycastResult;
	exports.ReadStream = ReadStream;
	exports.RenderComponent = RenderComponent;
	exports.RenderComponentSystem = RenderComponentSystem;
	exports.RenderHandler = RenderHandler;
	exports.RenderPass = RenderPass;
	exports.RenderPassRenderActions = RenderPassRenderActions;
	exports.RenderPassShaderQuad = RenderPassShaderQuad;
	exports.RenderTarget = RenderTarget;
	exports.ResourceHandler = ResourceHandler;
	exports.ResourceLoader = ResourceLoader;
	exports.RigidBodyComponent = RigidBodyComponent;
	exports.RigidBodyComponentSystem = RigidBodyComponentSystem;
	exports.SAMPLETYPE_DEPTH = SAMPLETYPE_DEPTH;
	exports.SAMPLETYPE_FLOAT = SAMPLETYPE_FLOAT;
	exports.SAMPLETYPE_UNFILTERABLE_FLOAT = SAMPLETYPE_UNFILTERABLE_FLOAT;
	exports.SCALEMODE_BLEND = SCALEMODE_BLEND;
	exports.SCALEMODE_NONE = SCALEMODE_NONE;
	exports.SCROLLBAR_VISIBILITY_SHOW_ALWAYS = SCROLLBAR_VISIBILITY_SHOW_ALWAYS;
	exports.SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED = SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED;
	exports.SCROLL_MODE_BOUNCE = SCROLL_MODE_BOUNCE;
	exports.SCROLL_MODE_CLAMP = SCROLL_MODE_CLAMP;
	exports.SCROLL_MODE_INFINITE = SCROLL_MODE_INFINITE;
	exports.SEMANTIC_ATTR = SEMANTIC_ATTR;
	exports.SEMANTIC_ATTR0 = SEMANTIC_ATTR0;
	exports.SEMANTIC_ATTR1 = SEMANTIC_ATTR1;
	exports.SEMANTIC_ATTR10 = SEMANTIC_ATTR10;
	exports.SEMANTIC_ATTR11 = SEMANTIC_ATTR11;
	exports.SEMANTIC_ATTR12 = SEMANTIC_ATTR12;
	exports.SEMANTIC_ATTR13 = SEMANTIC_ATTR13;
	exports.SEMANTIC_ATTR14 = SEMANTIC_ATTR14;
	exports.SEMANTIC_ATTR15 = SEMANTIC_ATTR15;
	exports.SEMANTIC_ATTR2 = SEMANTIC_ATTR2;
	exports.SEMANTIC_ATTR3 = SEMANTIC_ATTR3;
	exports.SEMANTIC_ATTR4 = SEMANTIC_ATTR4;
	exports.SEMANTIC_ATTR5 = SEMANTIC_ATTR5;
	exports.SEMANTIC_ATTR6 = SEMANTIC_ATTR6;
	exports.SEMANTIC_ATTR7 = SEMANTIC_ATTR7;
	exports.SEMANTIC_ATTR8 = SEMANTIC_ATTR8;
	exports.SEMANTIC_ATTR9 = SEMANTIC_ATTR9;
	exports.SEMANTIC_BLENDINDICES = SEMANTIC_BLENDINDICES;
	exports.SEMANTIC_BLENDWEIGHT = SEMANTIC_BLENDWEIGHT;
	exports.SEMANTIC_COLOR = SEMANTIC_COLOR;
	exports.SEMANTIC_NORMAL = SEMANTIC_NORMAL;
	exports.SEMANTIC_POSITION = SEMANTIC_POSITION;
	exports.SEMANTIC_TANGENT = SEMANTIC_TANGENT;
	exports.SEMANTIC_TEXCOORD = SEMANTIC_TEXCOORD;
	exports.SEMANTIC_TEXCOORD0 = SEMANTIC_TEXCOORD0;
	exports.SEMANTIC_TEXCOORD1 = SEMANTIC_TEXCOORD1;
	exports.SEMANTIC_TEXCOORD2 = SEMANTIC_TEXCOORD2;
	exports.SEMANTIC_TEXCOORD3 = SEMANTIC_TEXCOORD3;
	exports.SEMANTIC_TEXCOORD4 = SEMANTIC_TEXCOORD4;
	exports.SEMANTIC_TEXCOORD5 = SEMANTIC_TEXCOORD5;
	exports.SEMANTIC_TEXCOORD6 = SEMANTIC_TEXCOORD6;
	exports.SEMANTIC_TEXCOORD7 = SEMANTIC_TEXCOORD7;
	exports.SHADERDEF_DIRLM = SHADERDEF_DIRLM;
	exports.SHADERDEF_INSTANCING = SHADERDEF_INSTANCING;
	exports.SHADERDEF_LM = SHADERDEF_LM;
	exports.SHADERDEF_LMAMBIENT = SHADERDEF_LMAMBIENT;
	exports.SHADERDEF_MORPH_NORMAL = SHADERDEF_MORPH_NORMAL;
	exports.SHADERDEF_MORPH_POSITION = SHADERDEF_MORPH_POSITION;
	exports.SHADERDEF_MORPH_TEXTURE_BASED = SHADERDEF_MORPH_TEXTURE_BASED;
	exports.SHADERDEF_NOSHADOW = SHADERDEF_NOSHADOW;
	exports.SHADERDEF_SCREENSPACE = SHADERDEF_SCREENSPACE;
	exports.SHADERDEF_SKIN = SHADERDEF_SKIN;
	exports.SHADERDEF_TANGENTS = SHADERDEF_TANGENTS;
	exports.SHADERDEF_UV0 = SHADERDEF_UV0;
	exports.SHADERDEF_UV1 = SHADERDEF_UV1;
	exports.SHADERDEF_VCOLOR = SHADERDEF_VCOLOR;
	exports.SHADERLANGUAGE_GLSL = SHADERLANGUAGE_GLSL;
	exports.SHADERLANGUAGE_WGSL = SHADERLANGUAGE_WGSL;
	exports.SHADERPASS_ALBEDO = SHADERPASS_ALBEDO;
	exports.SHADERPASS_AO = SHADERPASS_AO;
	exports.SHADERPASS_EMISSION = SHADERPASS_EMISSION;
	exports.SHADERPASS_FORWARD = SHADERPASS_FORWARD;
	exports.SHADERPASS_GLOSS = SHADERPASS_GLOSS;
	exports.SHADERPASS_LIGHTING = SHADERPASS_LIGHTING;
	exports.SHADERPASS_METALNESS = SHADERPASS_METALNESS;
	exports.SHADERPASS_OPACITY = SHADERPASS_OPACITY;
	exports.SHADERPASS_SPECULARITY = SHADERPASS_SPECULARITY;
	exports.SHADERPASS_UV0 = SHADERPASS_UV0;
	exports.SHADERPASS_WORLDNORMAL = SHADERPASS_WORLDNORMAL;
	exports.SHADERSTAGE_COMPUTE = SHADERSTAGE_COMPUTE;
	exports.SHADERSTAGE_FRAGMENT = SHADERSTAGE_FRAGMENT;
	exports.SHADERSTAGE_VERTEX = SHADERSTAGE_VERTEX;
	exports.SHADERTAG_MATERIAL = SHADERTAG_MATERIAL;
	exports.SHADER_DEPTH = SHADER_DEPTH;
	exports.SHADER_FORWARD = SHADER_FORWARD;
	exports.SHADER_FORWARDHDR = SHADER_FORWARDHDR;
	exports.SHADER_PICK = SHADER_PICK;
	exports.SHADER_SHADOW = SHADER_SHADOW;
	exports.SHADOWUPDATE_NONE = SHADOWUPDATE_NONE;
	exports.SHADOWUPDATE_REALTIME = SHADOWUPDATE_REALTIME;
	exports.SHADOWUPDATE_THISFRAME = SHADOWUPDATE_THISFRAME;
	exports.SHADOW_DEPTH = SHADOW_DEPTH;
	exports.SHADOW_PCF1 = SHADOW_PCF1;
	exports.SHADOW_PCF3 = SHADOW_PCF3;
	exports.SHADOW_PCF5 = SHADOW_PCF5;
	exports.SHADOW_PCSS = SHADOW_PCSS;
	exports.SHADOW_VSM16 = SHADOW_VSM16;
	exports.SHADOW_VSM32 = SHADOW_VSM32;
	exports.SHADOW_VSM8 = SHADOW_VSM8;
	exports.SORTKEY_DEPTH = SORTKEY_DEPTH;
	exports.SORTKEY_FORWARD = SORTKEY_FORWARD;
	exports.SORTMODE_BACK2FRONT = SORTMODE_BACK2FRONT;
	exports.SORTMODE_CUSTOM = SORTMODE_CUSTOM;
	exports.SORTMODE_FRONT2BACK = SORTMODE_FRONT2BACK;
	exports.SORTMODE_MANUAL = SORTMODE_MANUAL;
	exports.SORTMODE_MATERIALMESH = SORTMODE_MATERIALMESH;
	exports.SORTMODE_NONE = SORTMODE_NONE;
	exports.SPECOCC_AO = SPECOCC_AO;
	exports.SPECOCC_GLOSSDEPENDENT = SPECOCC_GLOSSDEPENDENT;
	exports.SPECOCC_NONE = SPECOCC_NONE;
	exports.SPECULAR_BLINN = SPECULAR_BLINN;
	exports.SPECULAR_PHONG = SPECULAR_PHONG;
	exports.SPRITETYPE_ANIMATED = SPRITETYPE_ANIMATED;
	exports.SPRITETYPE_SIMPLE = SPRITETYPE_SIMPLE;
	exports.SPRITE_RENDERMODE_SIMPLE = SPRITE_RENDERMODE_SIMPLE;
	exports.SPRITE_RENDERMODE_SLICED = SPRITE_RENDERMODE_SLICED;
	exports.SPRITE_RENDERMODE_TILED = SPRITE_RENDERMODE_TILED;
	exports.STENCILOP_DECREMENT = STENCILOP_DECREMENT;
	exports.STENCILOP_DECREMENTWRAP = STENCILOP_DECREMENTWRAP;
	exports.STENCILOP_INCREMENT = STENCILOP_INCREMENT;
	exports.STENCILOP_INCREMENTWRAP = STENCILOP_INCREMENTWRAP;
	exports.STENCILOP_INVERT = STENCILOP_INVERT;
	exports.STENCILOP_KEEP = STENCILOP_KEEP;
	exports.STENCILOP_REPLACE = STENCILOP_REPLACE;
	exports.STENCILOP_ZERO = STENCILOP_ZERO;
	exports.Scene = Scene;
	exports.SceneHandler = SceneHandler;
	exports.SceneRegistry = SceneRegistry;
	exports.SceneRegistryItem = SceneRegistryItem;
	exports.SceneSettingsHandler = SceneSettingsHandler;
	exports.ScopeId = ScopeId;
	exports.ScopeSpace = ScopeSpace;
	exports.ScreenComponent = ScreenComponent;
	exports.ScreenComponentSystem = ScreenComponentSystem;
	exports.ScriptAttributes = ScriptAttributes;
	exports.ScriptComponent = ScriptComponent;
	exports.ScriptComponentSystem = ScriptComponentSystem;
	exports.ScriptHandler = ScriptHandler;
	exports.ScriptLegacyComponent = ScriptLegacyComponent;
	exports.ScriptLegacyComponentSystem = ScriptLegacyComponentSystem;
	exports.ScriptRegistry = ScriptRegistry;
	exports.ScriptType = ScriptType;
	exports.ScrollViewComponent = ScrollViewComponent;
	exports.ScrollViewComponentSystem = ScrollViewComponentSystem;
	exports.ScrollbarComponent = ScrollbarComponent;
	exports.ScrollbarComponentSystem = ScrollbarComponentSystem;
	exports.Shader = Shader;
	exports.ShaderHandler = ShaderHandler;
	exports.ShaderPass = ShaderPass;
	exports.SingleContactResult = SingleContactResult;
	exports.Skeleton = Skeleton;
	exports.Skin = Skin;
	exports.SkinBatchInstance = SkinBatchInstance;
	exports.SkinInstance = SkinInstance;
	exports.SortedLoopArray = SortedLoopArray;
	exports.Sound = Sound;
	exports.SoundComponent = SoundComponent;
	exports.SoundComponentSystem = SoundComponentSystem;
	exports.SoundInstance = SoundInstance;
	exports.SoundInstance3d = SoundInstance3d;
	exports.SoundManager = SoundManager;
	exports.SoundSlot = SoundSlot;
	exports.Sprite = Sprite;
	exports.SpriteAnimationClip = SpriteAnimationClip;
	exports.SpriteComponent = SpriteComponent;
	exports.SpriteComponentSystem = SpriteComponentSystem;
	exports.SpriteHandler = SpriteHandler;
	exports.StandardMaterial = StandardMaterial;
	exports.StandardMaterialOptions = StandardMaterialOptions;
	exports.StencilParameters = StencilParameters;
	exports.TEXHINT_ASSET = TEXHINT_ASSET;
	exports.TEXHINT_LIGHTMAP = TEXHINT_LIGHTMAP;
	exports.TEXHINT_NONE = TEXHINT_NONE;
	exports.TEXHINT_SHADOWMAP = TEXHINT_SHADOWMAP;
	exports.TEXTUREDIMENSION_1D = TEXTUREDIMENSION_1D;
	exports.TEXTUREDIMENSION_2D = TEXTUREDIMENSION_2D;
	exports.TEXTUREDIMENSION_2D_ARRAY = TEXTUREDIMENSION_2D_ARRAY;
	exports.TEXTUREDIMENSION_3D = TEXTUREDIMENSION_3D;
	exports.TEXTUREDIMENSION_CUBE = TEXTUREDIMENSION_CUBE;
	exports.TEXTUREDIMENSION_CUBE_ARRAY = TEXTUREDIMENSION_CUBE_ARRAY;
	exports.TEXTURELOCK_READ = TEXTURELOCK_READ;
	exports.TEXTURELOCK_WRITE = TEXTURELOCK_WRITE;
	exports.TEXTUREPROJECTION_CUBE = TEXTUREPROJECTION_CUBE;
	exports.TEXTUREPROJECTION_EQUIRECT = TEXTUREPROJECTION_EQUIRECT;
	exports.TEXTUREPROJECTION_NONE = TEXTUREPROJECTION_NONE;
	exports.TEXTUREPROJECTION_OCTAHEDRAL = TEXTUREPROJECTION_OCTAHEDRAL;
	exports.TEXTURETYPE_DEFAULT = TEXTURETYPE_DEFAULT;
	exports.TEXTURETYPE_RGBE = TEXTURETYPE_RGBE;
	exports.TEXTURETYPE_RGBM = TEXTURETYPE_RGBM;
	exports.TEXTURETYPE_RGBP = TEXTURETYPE_RGBP;
	exports.TEXTURETYPE_SWIZZLEGGGR = TEXTURETYPE_SWIZZLEGGGR;
	exports.TONEMAP_ACES = TONEMAP_ACES;
	exports.TONEMAP_ACES2 = TONEMAP_ACES2;
	exports.TONEMAP_FILMIC = TONEMAP_FILMIC;
	exports.TONEMAP_HEJL = TONEMAP_HEJL;
	exports.TONEMAP_LINEAR = TONEMAP_LINEAR;
	exports.TRACEID_BINDGROUPFORMAT_ALLOC = TRACEID_BINDGROUPFORMAT_ALLOC;
	exports.TRACEID_BINDGROUP_ALLOC = TRACEID_BINDGROUP_ALLOC;
	exports.TRACEID_COMPUTEPIPELINE_ALLOC = TRACEID_COMPUTEPIPELINE_ALLOC;
	exports.TRACEID_GPU_TIMINGS = TRACEID_GPU_TIMINGS;
	exports.TRACEID_PIPELINELAYOUT_ALLOC = TRACEID_PIPELINELAYOUT_ALLOC;
	exports.TRACEID_RENDERPIPELINE_ALLOC = TRACEID_RENDERPIPELINE_ALLOC;
	exports.TRACEID_RENDER_ACTION = TRACEID_RENDER_ACTION;
	exports.TRACEID_RENDER_FRAME = TRACEID_RENDER_FRAME;
	exports.TRACEID_RENDER_FRAME_TIME = TRACEID_RENDER_FRAME_TIME;
	exports.TRACEID_RENDER_PASS = TRACEID_RENDER_PASS;
	exports.TRACEID_RENDER_PASS_DETAIL = TRACEID_RENDER_PASS_DETAIL;
	exports.TRACEID_RENDER_QUEUE = TRACEID_RENDER_QUEUE;
	exports.TRACEID_RENDER_TARGET_ALLOC = TRACEID_RENDER_TARGET_ALLOC;
	exports.TRACEID_SHADER_ALLOC = TRACEID_SHADER_ALLOC;
	exports.TRACEID_SHADER_COMPILE = TRACEID_SHADER_COMPILE;
	exports.TRACEID_TEXTURES = TRACEID_TEXTURES;
	exports.TRACEID_TEXTURE_ALLOC = TRACEID_TEXTURE_ALLOC;
	exports.TRACEID_VRAM_IB = TRACEID_VRAM_IB;
	exports.TRACEID_VRAM_TEXTURE = TRACEID_VRAM_TEXTURE;
	exports.TRACEID_VRAM_VB = TRACEID_VRAM_VB;
	exports.TRACE_ID_ELEMENT = TRACE_ID_ELEMENT;
	exports.TYPE_FLOAT16 = TYPE_FLOAT16;
	exports.TYPE_FLOAT32 = TYPE_FLOAT32;
	exports.TYPE_INT16 = TYPE_INT16;
	exports.TYPE_INT32 = TYPE_INT32;
	exports.TYPE_INT8 = TYPE_INT8;
	exports.TYPE_UINT16 = TYPE_UINT16;
	exports.TYPE_UINT32 = TYPE_UINT32;
	exports.TYPE_UINT8 = TYPE_UINT8;
	exports.Tags = Tags;
	exports.Template = Template;
	exports.TemplateHandler = TemplateHandler;
	exports.TextElement = TextElement;
	exports.TextHandler = TextHandler;
	exports.Texture = Texture;
	exports.TextureAtlas = TextureAtlas;
	exports.TextureAtlasHandler = TextureAtlasHandler;
	exports.TextureHandler = TextureHandler;
	exports.TextureParser = TextureParser;
	exports.TextureUtils = TextureUtils;
	exports.Touch = Touch;
	exports.TouchDevice = TouchDevice;
	exports.TouchEvent = TouchEvent;
	exports.Tracing = Tracing;
	exports.TransformFeedback = TransformFeedback;
	exports.UNIFORMTYPE_BOOL = UNIFORMTYPE_BOOL;
	exports.UNIFORMTYPE_BVEC2 = UNIFORMTYPE_BVEC2;
	exports.UNIFORMTYPE_BVEC3 = UNIFORMTYPE_BVEC3;
	exports.UNIFORMTYPE_BVEC4 = UNIFORMTYPE_BVEC4;
	exports.UNIFORMTYPE_FLOAT = UNIFORMTYPE_FLOAT;
	exports.UNIFORMTYPE_FLOATARRAY = UNIFORMTYPE_FLOATARRAY;
	exports.UNIFORMTYPE_INT = UNIFORMTYPE_INT;
	exports.UNIFORMTYPE_IVEC2 = UNIFORMTYPE_IVEC2;
	exports.UNIFORMTYPE_IVEC3 = UNIFORMTYPE_IVEC3;
	exports.UNIFORMTYPE_IVEC4 = UNIFORMTYPE_IVEC4;
	exports.UNIFORMTYPE_MAT2 = UNIFORMTYPE_MAT2;
	exports.UNIFORMTYPE_MAT3 = UNIFORMTYPE_MAT3;
	exports.UNIFORMTYPE_MAT4 = UNIFORMTYPE_MAT4;
	exports.UNIFORMTYPE_MAT4ARRAY = UNIFORMTYPE_MAT4ARRAY;
	exports.UNIFORMTYPE_TEXTURE2D = UNIFORMTYPE_TEXTURE2D;
	exports.UNIFORMTYPE_TEXTURE2D_ARRAY = UNIFORMTYPE_TEXTURE2D_ARRAY;
	exports.UNIFORMTYPE_TEXTURE2D_SHADOW = UNIFORMTYPE_TEXTURE2D_SHADOW;
	exports.UNIFORMTYPE_TEXTURE3D = UNIFORMTYPE_TEXTURE3D;
	exports.UNIFORMTYPE_TEXTURECUBE = UNIFORMTYPE_TEXTURECUBE;
	exports.UNIFORMTYPE_TEXTURECUBE_SHADOW = UNIFORMTYPE_TEXTURECUBE_SHADOW;
	exports.UNIFORMTYPE_VEC2 = UNIFORMTYPE_VEC2;
	exports.UNIFORMTYPE_VEC2ARRAY = UNIFORMTYPE_VEC2ARRAY;
	exports.UNIFORMTYPE_VEC3 = UNIFORMTYPE_VEC3;
	exports.UNIFORMTYPE_VEC3ARRAY = UNIFORMTYPE_VEC3ARRAY;
	exports.UNIFORMTYPE_VEC4 = UNIFORMTYPE_VEC4;
	exports.UNIFORMTYPE_VEC4ARRAY = UNIFORMTYPE_VEC4ARRAY;
	exports.UNIFORM_BUFFER_DEFAULT_SLOT_NAME = UNIFORM_BUFFER_DEFAULT_SLOT_NAME;
	exports.URI = URI;
	exports.UnsupportedBrowserError = UnsupportedBrowserError;
	exports.VIEW_CENTER = VIEW_CENTER;
	exports.VIEW_LEFT = VIEW_LEFT;
	exports.VIEW_RIGHT = VIEW_RIGHT;
	exports.Vec2 = Vec2;
	exports.Vec3 = Vec3;
	exports.Vec4 = Vec4;
	exports.VertexBuffer = VertexBuffer;
	exports.VertexFormat = VertexFormat;
	exports.VertexIterator = VertexIterator;
	exports.WasmModule = WasmModule;
	exports.WebglGraphicsDevice = WebglGraphicsDevice;
	exports.WebgpuGraphicsDevice = WebgpuGraphicsDevice;
	exports.WorldClusters = WorldClusters;
	exports.XRDEPTHSENSINGFORMAT_F32 = XRDEPTHSENSINGFORMAT_F32;
	exports.XRDEPTHSENSINGFORMAT_L8A8 = XRDEPTHSENSINGFORMAT_L8A8;
	exports.XRDEPTHSENSINGUSAGE_CPU = XRDEPTHSENSINGUSAGE_CPU;
	exports.XRDEPTHSENSINGUSAGE_GPU = XRDEPTHSENSINGUSAGE_GPU;
	exports.XRHAND_LEFT = XRHAND_LEFT;
	exports.XRHAND_NONE = XRHAND_NONE;
	exports.XRHAND_RIGHT = XRHAND_RIGHT;
	exports.XRPAD_A = XRPAD_A;
	exports.XRPAD_B = XRPAD_B;
	exports.XRPAD_SQUEEZE = XRPAD_SQUEEZE;
	exports.XRPAD_STICK_BUTTON = XRPAD_STICK_BUTTON;
	exports.XRPAD_STICK_X = XRPAD_STICK_X;
	exports.XRPAD_STICK_Y = XRPAD_STICK_Y;
	exports.XRPAD_TOUCHPAD_BUTTON = XRPAD_TOUCHPAD_BUTTON;
	exports.XRPAD_TOUCHPAD_X = XRPAD_TOUCHPAD_X;
	exports.XRPAD_TOUCHPAD_Y = XRPAD_TOUCHPAD_Y;
	exports.XRPAD_TRIGGER = XRPAD_TRIGGER;
	exports.XRSPACE_BOUNDEDFLOOR = XRSPACE_BOUNDEDFLOOR;
	exports.XRSPACE_LOCAL = XRSPACE_LOCAL;
	exports.XRSPACE_LOCALFLOOR = XRSPACE_LOCALFLOOR;
	exports.XRSPACE_UNBOUNDED = XRSPACE_UNBOUNDED;
	exports.XRSPACE_VIEWER = XRSPACE_VIEWER;
	exports.XRTARGETRAY_GAZE = XRTARGETRAY_GAZE;
	exports.XRTARGETRAY_POINTER = XRTARGETRAY_POINTER;
	exports.XRTARGETRAY_SCREEN = XRTARGETRAY_SCREEN;
	exports.XRTRACKABLE_MESH = XRTRACKABLE_MESH;
	exports.XRTRACKABLE_PLANE = XRTRACKABLE_PLANE;
	exports.XRTRACKABLE_POINT = XRTRACKABLE_POINT;
	exports.XRTYPE_AR = XRTYPE_AR;
	exports.XRTYPE_INLINE = XRTYPE_INLINE;
	exports.XRTYPE_VR = XRTYPE_VR;
	exports.XrAnchor = XrAnchor;
	exports.XrAnchors = XrAnchors;
	exports.XrDepthSensing = XrDepthSensing;
	exports.XrDomOverlay = XrDomOverlay;
	exports.XrHitTest = XrHitTest;
	exports.XrHitTestSource = XrHitTestSource;
	exports.XrImageTracking = XrImageTracking;
	exports.XrInput = XrInput;
	exports.XrInputSource = XrInputSource;
	exports.XrLightEstimation = XrLightEstimation;
	exports.XrManager = XrManager;
	exports.XrPlane = XrPlane;
	exports.XrPlaneDetection = XrPlaneDetection;
	exports.XrTrackedImage = XrTrackedImage;
	exports.ZoneComponent = ZoneComponent;
	exports.ZoneComponentSystem = ZoneComponentSystem;
	exports.anim = anim;
	exports.apps = apps;
	exports.asset = asset;
	exports.audio = audio;
	exports.basisInitialize = basisInitialize;
	exports.basisSetDownloadConfig = basisSetDownloadConfig;
	exports.bindGroupNames = bindGroupNames;
	exports.calculateNormals = calculateNormals;
	exports.calculateTangents = calculateTangents;
	exports.common = common;
	exports.config = config;
	exports.createBox = createBox;
	exports.createCapsule = createCapsule;
	exports.createCone = createCone;
	exports.createCylinder = createCylinder;
	exports.createGraphicsDevice = createGraphicsDevice;
	exports.createMesh = createMesh$1;
	exports.createPlane = createPlane;
	exports.createScript = createScript;
	exports.createShader = createShader;
	exports.createShaderFromCode = createShaderFromCode;
	exports.createSphere = createSphere;
	exports.createStyle = createStyle;
	exports.createTorus = createTorus;
	exports.createURI = createURI;
	exports.data = data;
	exports.dracoInitialize = dracoInitialize;
	exports.drawFullscreenQuad = drawFullscreenQuad;
	exports.drawQuadWithShader = drawQuadWithShader;
	exports.drawTexture = drawTexture;
	exports.events = events;
	exports.extend = extend;
	exports.getPixelFormatArrayType = getPixelFormatArrayType;
	exports.getReservedScriptNames = getReservedScriptNames;
	exports.getTouchTargetCoords = getTouchTargetCoords;
	exports.gfx = gfx;
	exports.guid = guid;
	exports.http = http;
	exports.inherits = inherits;
	exports.input = input;
	exports.isCompressedPixelFormat = isCompressedPixelFormat;
	exports.log = log;
	exports.makeArray = makeArray;
	exports.math = math;
	exports.now = now;
	exports.path = path;
	exports.pixelFormatInfo = pixelFormatInfo;
	exports.platform = platform;
	exports.posteffect = posteffect;
	exports.prefilterCubemap = prefilterCubemap;
	exports.programlib = programlib;
	exports.registerScript = registerScript;
	exports.reprojectTexture = reprojectTexture;
	exports.revision = revision;
	exports.scene = scene;
	exports.script = script;
	exports.semanticToLocation = semanticToLocation;
	exports.shFromCubemap = shFromCubemap;
	exports.shaderChunks = shaderChunks;
	exports.shaderChunksLightmapper = shaderChunksLightmapper;
	exports.shadowTypeToString = shadowTypeToString;
	exports.shape = shape;
	exports.string = string;
	exports.time = time;
	exports.type = type$1;
	exports.typedArrayIndexFormats = typedArrayIndexFormats;
	exports.typedArrayIndexFormatsByteSize = typedArrayIndexFormatsByteSize;
	exports.typedArrayToType = typedArrayToType;
	exports.typedArrayTypes = typedArrayTypes;
	exports.typedArrayTypesByteSize = typedArrayTypesByteSize;
	exports.uniformTypeToName = uniformTypeToName;
	exports.version = version;
	exports.vertexTypesNames = vertexTypesNames;

}));
