import{extends as t}from"../../../_virtual/_rollupPluginBabelHelpers.js";import"../../../core/tracing.js";import{sortPriority as i}from"../../../core/sort.js";import{AnimClip as e}from"../evaluator/anim-clip.js";import{AnimState as a}from"./anim-state.js";import{AnimNode as s}from"./anim-node.js";import{AnimTransition as n}from"./anim-transition.js";import{ANIM_STATE_START as r,ANIM_INTERRUPTION_NONE as o,ANIM_STATE_END as h,ANIM_STATE_ANY as m,ANIM_NOT_EQUAL_TO as l,ANIM_EQUAL_TO as _,ANIM_LESS_THAN_EQUAL_TO as u,ANIM_GREATER_THAN_EQUAL_TO as c,ANIM_LESS_THAN as S,ANIM_GREATER_THAN as v,ANIM_INTERRUPTION_NEXT_PREV as f,ANIM_INTERRUPTION_PREV_NEXT as p,ANIM_INTERRUPTION_NEXT as d,ANIM_INTERRUPTION_PREV as T,ANIM_PARAMETER_TRIGGER as g,ANIM_CONTROL_STATES as N}from"./constants.js";class F{constructor(i,e,s,h,m,l,_){this._animEvaluator=i,this._states={},this._stateNames=[],this._eventHandler=l,this._consumedTriggers=_;for(let t=0;t<e.length;t++)this._states[e[t].name]=new a(this,e[t].name,e[t].speed,e[t].loop,e[t].blendTree),this._stateNames.push(e[t].name);this._transitions=s.map((i=>new n(t({},i)))),this._findTransitionsFromStateCache={},this._findTransitionsBetweenStatesCache={},this._parameters=h,this._previousStateName=null,this._activeStateName=r,this._playing=!1,this._activate=m,this._currTransitionTime=1,this._totalTransitionTime=1,this._isTransitioning=!1,this._transitionInterruptionSource=o,this._transitionPreviousStates=[],this._timeInState=0,this._timeInStateBefore=0}get animEvaluator(){return this._animEvaluator}set activeState(t){this._activeStateName=t}get activeState(){return this._findState(this._activeStateName)}get activeStateName(){return this._activeStateName}get activeStateAnimations(){return this.activeState.animations}set previousState(t){this._previousStateName=t}get previousState(){return this._findState(this._previousStateName)}get previousStateName(){return this._previousStateName}get playable(){let t=!0;for(let i=0;i<this._stateNames.length;i++)this._states[this._stateNames[i]].playable||(t=!1);return t}set playing(t){this._playing=t}get playing(){return this._playing}get activeStateProgress(){return this._getActiveStateProgressForTime(this._timeInState)}get activeStateDuration(){if(this.activeStateName===r||this.activeStateName===h)return 0;let t=0;for(let i=0;i<this.activeStateAnimations.length;i++){const e=this._animEvaluator.findClip(this.activeStateAnimations[i].name);e&&(t=Math.max(t,e.track.duration))}return t}set activeStateCurrentTime(t){this._timeInStateBefore=t,this._timeInState=t;for(let i=0;i<this.activeStateAnimations.length;i++){const e=this.animEvaluator.findClip(this.activeStateAnimations[i].name);e&&(e.time=t)}}get activeStateCurrentTime(){return this._timeInState}get transitioning(){return this._isTransitioning}get transitionProgress(){return this._currTransitionTime/this._totalTransitionTime}get states(){return this._stateNames}assignMask(t){return this._animEvaluator.assignMask(t)}_findState(t){return this._states[t]}_getActiveStateProgressForTime(t){if(this.activeStateName===r||this.activeStateName===h||this.activeStateName===m)return 1;const i=this._animEvaluator.findClip(this.activeStateAnimations[0].name);return i?i.progressForTime(t):null}_findTransitionsFromState(t){let e=this._findTransitionsFromStateCache[t];return e||(e=this._transitions.filter((function(i){return i.from===t})),i(e),this._findTransitionsFromStateCache[t]=e),e}_findTransitionsBetweenStates(t,e){let a=this._findTransitionsBetweenStatesCache[t+"->"+e];return a||(a=this._transitions.filter((function(i){return i.from===t&&i.to===e})),i(a),this._findTransitionsBetweenStatesCache[t+"->"+e]=a),a}_transitionHasConditionsMet(t){const i=t.conditions;for(let t=0;t<i.length;t++){const e=i[t],a=this.findParameter(e.parameterName);switch(e.predicate){case v:if(!(a.value>e.value))return!1;break;case S:if(!(a.value<e.value))return!1;break;case c:if(!(a.value>=e.value))return!1;break;case u:if(!(a.value<=e.value))return!1;break;case _:if(a.value!==e.value)return!1;break;case l:if(a.value===e.value)return!1}}return!0}_findTransition(t,i){let e=[];if(t&&i)e=e.concat(this._findTransitionsBetweenStates(t,i));else if(this._isTransitioning)switch(this._transitionInterruptionSource){case T:e=e.concat(this._findTransitionsFromState(this._previousStateName)),e=e.concat(this._findTransitionsFromState(m));break;case d:e=e.concat(this._findTransitionsFromState(this._activeStateName)),e=e.concat(this._findTransitionsFromState(m));break;case p:e=e.concat(this._findTransitionsFromState(this._previousStateName)),e=e.concat(this._findTransitionsFromState(this._activeStateName)),e=e.concat(this._findTransitionsFromState(m));break;case f:e=e.concat(this._findTransitionsFromState(this._activeStateName)),e=e.concat(this._findTransitionsFromState(this._previousStateName)),e=e.concat(this._findTransitionsFromState(m))}else e=e.concat(this._findTransitionsFromState(this._activeStateName)),e=e.concat(this._findTransitionsFromState(m));if(e=e.filter((t=>{if(t.to===this.activeStateName)return!1;if(t.hasExitTime){let i=this._getActiveStateProgressForTime(this._timeInStateBefore),e=this._getActiveStateProgressForTime(this._timeInState);if(t.exitTime<1&&this.activeState.loop&&(i-=Math.floor(i),e-=Math.floor(e)),!(t.exitTime>i&&t.exitTime<=e))return null}return this._transitionHasConditionsMet(t)})),e.length>0){const t=e[0];if(t.to===h){const i=this._findTransitionsFromState(r)[0];t.to=i.to}return t}return null}updateStateFromTransition(t){let i,a,s;this.previousState=t.from?this.activeStateName:null,this.activeState=t.to;for(let i=0;i<t.conditions.length;i++){const e=t.conditions[i];this.findParameter(e.parameterName).type===g&&this._consumedTriggers.add(e.parameterName)}if(this.previousState){this._isTransitioning||(this._transitionPreviousStates=[]),this._transitionPreviousStates.push({name:this._previousStateName,weight:1});const t=Math.min(0!==this._totalTransitionTime?this._currTransitionTime/this._totalTransitionTime:1,1);for(let e=0;e<this._transitionPreviousStates.length;e++){this._isTransitioning?e!==this._transitionPreviousStates.length-1?this._transitionPreviousStates[e].weight*=1-t:this._transitionPreviousStates[e].weight=t:this._transitionPreviousStates[e].weight=1,i=this._findState(this._transitionPreviousStates[e].name);for(let t=0;t<i.animations.length;t++)a=i.animations[t],s=this._animEvaluator.findClip(a.name+".previous."+e),s||(s=this._animEvaluator.findClip(a.name),s.name=a.name+".previous."+e),e!==this._transitionPreviousStates.length-1&&s.pause()}}this._isTransitioning=!0,this._totalTransitionTime=t.time,this._currTransitionTime=0,this._transitionInterruptionSource=t.interruptionSource;const n=this.activeState,r=t.transitionOffset&&t.transitionOffset>0&&t.transitionOffset<1;let o=0,h=0;if(r){const i=n.timelineDuration*t.transitionOffset;o=i,h=i}this._timeInState=o,this._timeInStateBefore=h;for(let i=0;i<n.animations.length;i++){if(s=this._animEvaluator.findClip(n.animations[i].name),s)s.reset();else{const t=Number.isFinite(n.animations[i].speed)?n.animations[i].speed:n.speed;s=new e(n.animations[i].animTrack,this._timeInState,t,!0,n.loop,this._eventHandler),s.name=n.animations[i].name,this._animEvaluator.addClip(s)}if(t.time>0?s.blendWeight=0:s.blendWeight=n.animations[i].normalizedWeight,s.play(),r)s.time=n.timelineDuration*t.transitionOffset;else{const t=n.speed>=0?0:this.activeStateDuration;s.time=t}}}_transitionToState(t){if(!this._findState(t))return;let i=this._findTransition(this._activeStateName,t);i||(this._animEvaluator.removeClips(),i=new n({from:null,to:t})),this.updateStateFromTransition(i)}assignAnimation(t,i,e,s){const n=t.split(".");let r=this._findState(n[0]);r||(r=new a(this,n[0],1),this._states[n[0]]=r,this._stateNames.push(n[0])),r.addAnimation(n,i),this._animEvaluator.updateClipTrack(r.name,i),void 0!==e&&(r.speed=e),void 0!==s&&(r.loop=s),!this._playing&&this._activate&&this.playable&&this.play()}removeNodeAnimations(t){if(-1!==N.indexOf(t))return!1;const i=this._findState(t);return!!i&&(i.animations=[],!0)}play(t){t&&this._transitionToState(t),this._playing=!0}pause(){this._playing=!1}reset(){this._previousStateName=null,this._activeStateName=r,this._playing=!1,this._currTransitionTime=1,this._totalTransitionTime=1,this._isTransitioning=!1,this._timeInState=0,this._timeInStateBefore=0,this._animEvaluator.removeClips()}rebind(){this._animEvaluator.rebind()}update(t){if(!this._playing)return;let i,e,a;this._timeInStateBefore=this._timeInState,this._timeInState+=t*this.activeState.speed;const n=this._findTransition(this._activeStateName);if(n&&this.updateStateFromTransition(n),this._isTransitioning)if(this._currTransitionTime+=t,this._currTransitionTime<=this._totalTransitionTime){const t=0!==this._totalTransitionTime?this._currTransitionTime/this._totalTransitionTime:1;for(let s=0;s<this._transitionPreviousStates.length;s++){i=this._findState(this._transitionPreviousStates[s].name);const n=this._transitionPreviousStates[s].weight;for(let r=0;r<i.animations.length;r++)e=i.animations[r],a=this._animEvaluator.findClip(e.name+".previous."+s),a&&(a.blendWeight=(1-t)*e.normalizedWeight*n)}i=this.activeState;for(let a=0;a<i.animations.length;a++)e=i.animations[a],this._animEvaluator.findClip(e.name).blendWeight=t*e.normalizedWeight}else{this._isTransitioning=!1;const t=this.activeStateAnimations.length,s=this._animEvaluator.clips.length;for(let i=0;i<s-t;i++)this._animEvaluator.removeClip(0);this._transitionPreviousStates=[],i=this.activeState;for(let t=0;t<i.animations.length;t++)e=i.animations[t],a=this._animEvaluator.findClip(e.name),a&&(a.blendWeight=e.normalizedWeight)}else if(this.activeState._blendTree.constructor!==s){i=this.activeState;for(let t=0;t<i.animations.length;t++)e=i.animations[t],a=this._animEvaluator.findClip(e.name),a&&(a.blendWeight=e.normalizedWeight,e.parent.syncAnimations&&(a.speed=e.speed))}this._animEvaluator.update(t,this.activeState.hasAnimations)}findParameter(t){return this._parameters[t]}}export{F as AnimController};
