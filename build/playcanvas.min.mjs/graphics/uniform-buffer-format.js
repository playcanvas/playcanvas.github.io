import"../core/tracing.js";import{math as t}from"../math/math.js";import{bindGroupNames as s,uniformTypeToName as e,UNIFORMTYPE_FLOAT as i,UNIFORMTYPE_VEC2 as o,UNIFORMTYPE_VEC3 as n,UNIFORMTYPE_VEC4 as c,UNIFORMTYPE_INT as h,UNIFORMTYPE_IVEC2 as r,UNIFORMTYPE_IVEC3 as a,UNIFORMTYPE_IVEC4 as m,UNIFORMTYPE_BOOL as p,UNIFORMTYPE_BVEC2 as f,UNIFORMTYPE_BVEC3 as u,UNIFORMTYPE_BVEC4 as d,UNIFORMTYPE_MAT2 as l,UNIFORMTYPE_MAT3 as y,UNIFORMTYPE_MAT4 as b}from"./constants.js";const S=[];S[i]=1,S[o]=2,S[n]=3,S[c]=4,S[h]=1,S[r]=2,S[a]=3,S[m]=4,S[p]=1,S[f]=2,S[u]=3,S[d]=4,S[l]=8,S[y]=12,S[b]=16;class v{constructor(t,s,e=1){this.name=void 0,this.type=void 0,this.byteSize=void 0,this.offset=void 0,this.scopeId=void 0,this.count=void 0,this.name=t,this.type=s,this.count=e;const i=S[s];this.byteSize=e*i*4}calculateOffset(s){const e=this.byteSize<=8?this.byteSize:16;s=t.roundUp(s,e),this.offset=s/4}}class z{constructor(s,e){this.byteSize=0,this.map=new Map,this.scope=s.scope,this.uniforms=e;let i=0;for(let t=0;t<e.length;t++){const s=e[t];s.calculateOffset(i),i=4*s.offset+s.byteSize,s.scopeId=this.scope.resolve(s.name),this.map.set(s.name,s)}this.byteSize=t.roundUp(i,16)}get(t){return this.map.get(t)}getShaderDeclaration(t,i){let o=`layout(set = ${t}, binding = ${i}, std140) uniform ub_${s[t]} {\n`;return this.uniforms.forEach((t=>{const s=e[t.type];o+=`    ${s} ${t.name};\n`})),o+"};\n"}}export{z as UniformBufferFormat,v as UniformFormat};
