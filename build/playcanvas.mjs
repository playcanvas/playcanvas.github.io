/**
 * @license
 * PlayCanvas Engine v1.52.2 revision 610e6669f
 * Copyright 2011-2022 PlayCanvas Ltd. All rights reserved.
 */
if (!Array.prototype.fill) {
	Object.defineProperty(Array.prototype, 'fill', {
		value: function (value) {
			if (this == null) {
				throw new TypeError('this is null or not defined');
			}

			var O = Object(this);
			var len = O.length >>> 0;
			var start = arguments[1];
			var relativeStart = start >> 0;
			var k = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);
			var end = arguments[2];
			var relativeEnd = end === undefined ? len : end >> 0;
			var finalValue = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len);

			while (k < finalValue) {
				O[k] = value;
				k++;
			}

			return O;
		}
	});
}

if (!Array.prototype.find) {
	Object.defineProperty(Array.prototype, 'find', {
		value: function (predicate) {
			if (this == null) {
				throw TypeError('"this" is null or not defined');
			}

			var o = Object(this);
			var len = o.length >>> 0;

			if (typeof predicate !== 'function') {
				throw TypeError('predicate must be a function');
			}

			var thisArg = arguments[1];
			var k = 0;

			while (k < len) {
				var kValue = o[k];

				if (predicate.call(thisArg, kValue, k, o)) {
					return kValue;
				}

				k++;
			}

			return undefined;
		},
		configurable: true,
		writable: true
	});
}

if (!Array.prototype.findIndex) {
	Object.defineProperty(Array.prototype, 'findIndex', {
		value: function (predicate) {
			if (this == null) {
				throw new TypeError('"this" is null or not defined');
			}

			var o = Object(this);
			var len = o.length >>> 0;

			if (typeof predicate !== 'function') {
				throw new TypeError('predicate must be a function');
			}

			var thisArg = arguments[1];
			var k = 0;

			while (k < len) {
				var kValue = o[k];

				if (predicate.call(thisArg, kValue, k, o)) {
					return k;
				}

				k++;
			}

			return -1;
		},
		configurable: true,
		writable: true
	});
}

Math.log2 = Math.log2 || function (x) {
	return Math.log(x) * Math.LOG2E;
};

if (!Math.sign) {
	Math.sign = function (x) {
		return (x > 0) - (x < 0) || +x;
	};
}

if (Number.isFinite === undefined) Number.isFinite = function (value) {
	return typeof value === 'number' && isFinite(value);
};

if (typeof Object.assign != 'function') {
	Object.defineProperty(Object, "assign", {
		value: function assign(target, varArgs) {

			if (target == null) {
				throw new TypeError('Cannot convert undefined or null to object');
			}

			var to = Object(target);

			for (var index = 1; index < arguments.length; index++) {
				var nextSource = arguments[index];

				if (nextSource != null) {
					for (var nextKey in nextSource) {
						if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
							to[nextKey] = nextSource[nextKey];
						}
					}
				}
			}

			return to;
		},
		writable: true,
		configurable: true
	});
}

(function () {
	if (typeof navigator === 'undefined' || typeof document === 'undefined') {
		return;
	}

	navigator.pointer = navigator.pointer || navigator.webkitPointer || navigator.mozPointer;

	var pointerlockchange = function pointerlockchange() {
		var e = document.createEvent('CustomEvent');
		e.initCustomEvent('pointerlockchange', true, false, null);
		document.dispatchEvent(e);
	};

	var pointerlockerror = function pointerlockerror() {
		var e = document.createEvent('CustomEvent');
		e.initCustomEvent('pointerlockerror', true, false, null);
		document.dispatchEvent(e);
	};

	document.addEventListener('webkitpointerlockchange', pointerlockchange, false);
	document.addEventListener('webkitpointerlocklost', pointerlockchange, false);
	document.addEventListener('mozpointerlockchange', pointerlockchange, false);
	document.addEventListener('mozpointerlocklost', pointerlockchange, false);
	document.addEventListener('webkitpointerlockerror', pointerlockerror, false);
	document.addEventListener('mozpointerlockerror', pointerlockerror, false);

	if (Element.prototype.mozRequestPointerLock) {
		Element.prototype.requestPointerLock = function () {
			this.mozRequestPointerLock();
		};
	} else {
		Element.prototype.requestPointerLock = Element.prototype.requestPointerLock || Element.prototype.webkitRequestPointerLock || Element.prototype.mozRequestPointerLock;
	}

	if (!Element.prototype.requestPointerLock && navigator.pointer) {
		Element.prototype.requestPointerLock = function () {
			var el = this;
			document.pointerLockElement = el;
			navigator.pointer.lock(el, pointerlockchange, pointerlockerror);
		};
	}

	document.exitPointerLock = document.exitPointerLock || document.webkitExitPointerLock || document.mozExitPointerLock;

	if (!document.exitPointerLock) {
		document.exitPointerLock = function () {
			if (navigator.pointer) {
				document.pointerLockElement = null;
				navigator.pointer.unlock();
			}
		};
	}
})();

(function () {
	if (typeof window === 'undefined') return;
	var lastTime = 0;
	var vendors = ['ms', 'moz', 'webkit', 'o'];

	for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
		window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
		window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];
	}

	if (!window.requestAnimationFrame) window.requestAnimationFrame = function (callback, element) {
		var currTime = new Date().getTime();
		var timeToCall = Math.max(0, 16 - (currTime - lastTime));
		var id = window.setTimeout(function () {
			callback(currTime + timeToCall);
		}, timeToCall);
		lastTime = currTime + timeToCall;
		return id;
	};
	if (!window.cancelAnimationFrame) window.cancelAnimationFrame = function (id) {
		clearTimeout(id);
	};
})();

if (!String.prototype.endsWith) {
	String.prototype.endsWith = function (search, this_len) {
		if (this_len === undefined || this_len > this.length) {
			this_len = this.length;
		}

		return this.substring(this_len - search.length, this_len) === search;
	};
}

if (!String.prototype.includes) {
	String.prototype.includes = function (search, start) {

		if (typeof start !== 'number') {
			start = 0;
		}

		if (start + search.length > this.length) {
			return false;
		} else {
			return this.indexOf(search, start) !== -1;
		}
	};
}

if (!String.prototype.startsWith) {
	String.prototype.startsWith = function (search, pos) {
		return this.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
	};
}

if (!Int8Array.prototype.fill) {
	Int8Array.prototype.fill = Array.prototype.fill;
}

if (!Uint8Array.prototype.fill) {
	Uint8Array.prototype.fill = Array.prototype.fill;
}

if (!Uint8ClampedArray.prototype.fill) {
	Uint8ClampedArray.prototype.fill = Array.prototype.fill;
}

if (!Int16Array.prototype.fill) {
	Int16Array.prototype.fill = Array.prototype.fill;
}

if (!Uint16Array.prototype.fill) {
	Uint16Array.prototype.fill = Array.prototype.fill;
}

if (!Int32Array.prototype.fill) {
	Int32Array.prototype.fill = Array.prototype.fill;
}

if (!Uint32Array.prototype.fill) {
	Uint32Array.prototype.fill = Array.prototype.fill;
}

if (!Float32Array.prototype.fill) {
	Float32Array.prototype.fill = Array.prototype.fill;
}

var glErrorShadow = {};

function error(msg) {
	if (window.console && window.console.error) {
		window.console.error(msg);
	}
}

function log$1(msg) {
	if (window.console && window.console.log) {
		window.console.log(msg);
	}
}

function synthesizeGLError(err, opt_msg) {
	glErrorShadow[err] = true;

	if (opt_msg !== undefined) {
		error(opt_msg);
	}
}

function wrapGLError(gl) {
	var f = gl.getError;

	gl.getError = function () {
		var err;

		do {
			err = f.apply(gl);

			if (err != gl.NO_ERROR) {
				glErrorShadow[err] = true;
			}
		} while (err != gl.NO_ERROR);

		for (var err in glErrorShadow) {
			if (glErrorShadow[err]) {
				delete glErrorShadow[err];
				return parseInt(err);
			}
		}

		return gl.NO_ERROR;
	};
}

var WebGLVertexArrayObjectOES = function WebGLVertexArrayObjectOES(ext) {
	var gl = ext.gl;
	this.ext = ext;
	this.isAlive = true;
	this.hasBeenBound = false;
	this.elementArrayBuffer = null;
	this.attribs = new Array(ext.maxVertexAttribs);

	for (var n = 0; n < this.attribs.length; n++) {
		var attrib = new WebGLVertexArrayObjectOES.VertexAttrib(gl);
		this.attribs[n] = attrib;
	}

	this.maxAttrib = 0;
};

WebGLVertexArrayObjectOES.VertexAttrib = function VertexAttrib(gl) {
	this.enabled = false;
	this.buffer = null;
	this.size = 4;
	this.type = gl.FLOAT;
	this.normalized = false;
	this.stride = 16;
	this.offset = 0;
	this.cached = "";
	this.recache();
};

WebGLVertexArrayObjectOES.VertexAttrib.prototype.recache = function recache() {
	this.cached = [this.size, this.type, this.normalized, this.stride, this.offset].join(":");
};

var OESVertexArrayObject = function OESVertexArrayObject(gl) {
	var self = this;
	this.gl = gl;
	wrapGLError(gl);
	var original = this.original = {
		getParameter: gl.getParameter,
		enableVertexAttribArray: gl.enableVertexAttribArray,
		disableVertexAttribArray: gl.disableVertexAttribArray,
		bindBuffer: gl.bindBuffer,
		getVertexAttrib: gl.getVertexAttrib,
		vertexAttribPointer: gl.vertexAttribPointer
	};

	gl.getParameter = function getParameter(pname) {
		if (pname == self.VERTEX_ARRAY_BINDING_OES) {
			if (self.currentVertexArrayObject == self.defaultVertexArrayObject) {
				return null;
			} else {
				return self.currentVertexArrayObject;
			}
		}

		return original.getParameter.apply(this, arguments);
	};

	gl.enableVertexAttribArray = function enableVertexAttribArray(index) {
		var vao = self.currentVertexArrayObject;
		vao.maxAttrib = Math.max(vao.maxAttrib, index);
		var attrib = vao.attribs[index];
		attrib.enabled = true;
		return original.enableVertexAttribArray.apply(this, arguments);
	};

	gl.disableVertexAttribArray = function disableVertexAttribArray(index) {
		var vao = self.currentVertexArrayObject;
		vao.maxAttrib = Math.max(vao.maxAttrib, index);
		var attrib = vao.attribs[index];
		attrib.enabled = false;
		return original.disableVertexAttribArray.apply(this, arguments);
	};

	gl.bindBuffer = function bindBuffer(target, buffer) {
		switch (target) {
			case gl.ARRAY_BUFFER:
				self.currentArrayBuffer = buffer;
				break;

			case gl.ELEMENT_ARRAY_BUFFER:
				self.currentVertexArrayObject.elementArrayBuffer = buffer;
				break;
		}

		return original.bindBuffer.apply(this, arguments);
	};

	gl.getVertexAttrib = function getVertexAttrib(index, pname) {
		var vao = self.currentVertexArrayObject;
		var attrib = vao.attribs[index];

		switch (pname) {
			case gl.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:
				return attrib.buffer;

			case gl.VERTEX_ATTRIB_ARRAY_ENABLED:
				return attrib.enabled;

			case gl.VERTEX_ATTRIB_ARRAY_SIZE:
				return attrib.size;

			case gl.VERTEX_ATTRIB_ARRAY_STRIDE:
				return attrib.stride;

			case gl.VERTEX_ATTRIB_ARRAY_TYPE:
				return attrib.type;

			case gl.VERTEX_ATTRIB_ARRAY_NORMALIZED:
				return attrib.normalized;

			default:
				return original.getVertexAttrib.apply(this, arguments);
		}
	};

	gl.vertexAttribPointer = function vertexAttribPointer(indx, size, type, normalized, stride, offset) {
		var vao = self.currentVertexArrayObject;
		vao.maxAttrib = Math.max(vao.maxAttrib, indx);
		var attrib = vao.attribs[indx];
		attrib.buffer = self.currentArrayBuffer;
		attrib.size = size;
		attrib.type = type;
		attrib.normalized = normalized;
		attrib.stride = stride;
		attrib.offset = offset;
		attrib.recache();
		return original.vertexAttribPointer.apply(this, arguments);
	};

	if (gl.instrumentExtension) {
		gl.instrumentExtension(this, "OES_vertex_array_object");
	}

	gl.canvas.addEventListener('webglcontextrestored', function () {
		log$1("OESVertexArrayObject emulation library context restored");
		self.reset_();
	}, true);
	this.reset_();
};

OESVertexArrayObject.prototype.VERTEX_ARRAY_BINDING_OES = 0x85B5;

OESVertexArrayObject.prototype.reset_ = function reset_() {
	var contextWasLost = this.vertexArrayObjects !== undefined;

	if (contextWasLost) {
		for (var ii = 0; ii < this.vertexArrayObjects.length; ++ii) {
			this.vertexArrayObjects.isAlive = false;
		}
	}

	var gl = this.gl;
	this.maxVertexAttribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
	this.defaultVertexArrayObject = new WebGLVertexArrayObjectOES(this);
	this.currentVertexArrayObject = null;
	this.currentArrayBuffer = null;
	this.vertexArrayObjects = [this.defaultVertexArrayObject];
	this.bindVertexArrayOES(null);
};

OESVertexArrayObject.prototype.createVertexArrayOES = function createVertexArrayOES() {
	var arrayObject = new WebGLVertexArrayObjectOES(this);
	this.vertexArrayObjects.push(arrayObject);
	return arrayObject;
};

OESVertexArrayObject.prototype.deleteVertexArrayOES = function deleteVertexArrayOES(arrayObject) {
	arrayObject.isAlive = false;
	this.vertexArrayObjects.splice(this.vertexArrayObjects.indexOf(arrayObject), 1);

	if (this.currentVertexArrayObject == arrayObject) {
		this.bindVertexArrayOES(null);
	}
};

OESVertexArrayObject.prototype.isVertexArrayOES = function isVertexArrayOES(arrayObject) {
	if (arrayObject && arrayObject instanceof WebGLVertexArrayObjectOES) {
		if (arrayObject.hasBeenBound && arrayObject.ext == this) {
			return true;
		}
	}

	return false;
};

OESVertexArrayObject.prototype.bindVertexArrayOES = function bindVertexArrayOES(arrayObject) {
	var gl = this.gl;

	if (arrayObject && !arrayObject.isAlive) {
		synthesizeGLError(gl.INVALID_OPERATION, "bindVertexArrayOES: attempt to bind deleted arrayObject");
		return;
	}

	var original = this.original;
	var oldVAO = this.currentVertexArrayObject;
	this.currentVertexArrayObject = arrayObject || this.defaultVertexArrayObject;
	this.currentVertexArrayObject.hasBeenBound = true;
	var newVAO = this.currentVertexArrayObject;

	if (oldVAO == newVAO) {
		return;
	}

	if (!oldVAO || newVAO.elementArrayBuffer != oldVAO.elementArrayBuffer) {
		original.bindBuffer.call(gl, gl.ELEMENT_ARRAY_BUFFER, newVAO.elementArrayBuffer);
	}

	var currentBinding = this.currentArrayBuffer;
	var maxAttrib = Math.max(oldVAO ? oldVAO.maxAttrib : 0, newVAO.maxAttrib);

	for (var n = 0; n <= maxAttrib; n++) {
		var attrib = newVAO.attribs[n];
		var oldAttrib = oldVAO ? oldVAO.attribs[n] : null;

		if (!oldVAO || attrib.enabled != oldAttrib.enabled) {
			if (attrib.enabled) {
				original.enableVertexAttribArray.call(gl, n);
			} else {
				original.disableVertexAttribArray.call(gl, n);
			}
		}

		if (attrib.enabled) {
			var bufferChanged = false;

			if (!oldVAO || attrib.buffer != oldAttrib.buffer) {
				if (currentBinding != attrib.buffer) {
					original.bindBuffer.call(gl, gl.ARRAY_BUFFER, attrib.buffer);
					currentBinding = attrib.buffer;
				}

				bufferChanged = true;
			}

			if (bufferChanged || attrib.cached != oldAttrib.cached) {
				original.vertexAttribPointer.call(gl, n, attrib.size, attrib.type, attrib.normalized, attrib.stride, attrib.offset);
			}
		}
	}

	if (this.currentArrayBuffer != currentBinding) {
		original.bindBuffer.call(gl, gl.ARRAY_BUFFER, this.currentArrayBuffer);
	}
};

const setupVertexArrayObject = function setupVertexArrayObject(gl) {
	if (gl.getSupportedExtensions) {
		var exts = gl.getSupportedExtensions();

		if (exts.indexOf("OES_vertex_array_object") != -1) {
			return;
		}
	} else if (gl.getExtension) {
		var vao = gl.getExtension("OES_vertex_array_object");

		if (vao) {
			return;
		}
	}

	if (gl.getSupportedExtensions) {
		var original_getSupportedExtensions = gl.getSupportedExtensions;

		gl.getSupportedExtensions = function getSupportedExtensions() {
			var list = original_getSupportedExtensions.call(this) || [];
			list.push("OES_vertex_array_object");
			return list;
		};
	}

	var original_getExtension = gl.getExtension;

	gl.getExtension = function getExtension(name) {
		if (name == "OES_vertex_array_object") {
			if (!gl.__OESVertexArrayObject) {
				gl.__OESVertexArrayObject = new OESVertexArrayObject(gl);
			}

			return gl.__OESVertexArrayObject;
		}

		if (original_getExtension) {
			return original_getExtension.call(this, name);
		} else {
			return null;
		}
	};
};

const version = "1.52.2";
const revision = "610e6669f";
const config = {};
const common = {};
const apps = {};
const data = {};

const _typeLookup = function () {
	const result = {};
	const names = ["Array", "Object", "Function", "Date", "RegExp", "Float32Array"];

	for (let i = 0; i < names.length; i++) result["[object " + names[i] + "]"] = names[i].toLowerCase();

	return result;
}();

function type(obj) {
	if (obj === null) {
		return "null";
	}

	const type = typeof obj;

	if (type === "undefined" || type === "number" || type === "string" || type === "boolean") {
		return type;
	}

	return _typeLookup[Object.prototype.toString.call(obj)];
}

function extend(target, ex) {
	for (const prop in ex) {
		const copy = ex[prop];

		if (type(copy) === "object") {
			target[prop] = extend({}, copy);
		} else if (type(copy) === "array") {
			target[prop] = extend([], copy);
		} else {
			target[prop] = copy;
		}
	}

	return target;
}

function isDefined(o) {
	let a;
	return o !== a;
}

class EventHandler {
	constructor() {
		this._callbacks = {};
		this._callbackActive = {};
	}

	initEventHandler() {
		this._callbacks = {};
		this._callbackActive = {};
	}

	_addCallback(name, callback, scope, once = false) {
		if (!name || typeof name !== 'string' || !callback) return;
		if (!this._callbacks[name]) this._callbacks[name] = [];
		if (this._callbackActive[name] && this._callbackActive[name] === this._callbacks[name]) this._callbackActive[name] = this._callbackActive[name].slice();

		this._callbacks[name].push({
			callback: callback,
			scope: scope || this,
			once: once
		});
	}

	on(name, callback, scope) {
		this._addCallback(name, callback, scope, false);

		return this;
	}

	off(name, callback, scope) {
		if (name) {
			if (this._callbackActive[name] && this._callbackActive[name] === this._callbacks[name]) this._callbackActive[name] = this._callbackActive[name].slice();
		} else {
			for (const key in this._callbackActive) {
				if (!this._callbacks[key]) continue;
				if (this._callbacks[key] !== this._callbackActive[key]) continue;
				this._callbackActive[key] = this._callbackActive[key].slice();
			}
		}

		if (!name) {
			this._callbacks = {};
		} else if (!callback) {
			if (this._callbacks[name]) this._callbacks[name] = [];
		} else {
			const events = this._callbacks[name];
			if (!events) return this;
			let count = events.length;

			for (let i = 0; i < count; i++) {
				if (events[i].callback !== callback) continue;
				if (scope && events[i].scope !== scope) continue;
				events[i--] = events[--count];
			}

			events.length = count;
		}

		return this;
	}

	fire(name, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {
		if (!name || !this._callbacks[name]) return this;
		let callbacks;

		if (!this._callbackActive[name]) {
			this._callbackActive[name] = this._callbacks[name];
		} else {
			if (this._callbackActive[name] === this._callbacks[name]) this._callbackActive[name] = this._callbackActive[name].slice();
			callbacks = this._callbacks[name].slice();
		}

		for (let i = 0; (callbacks || this._callbackActive[name]) && i < (callbacks || this._callbackActive[name]).length; i++) {
			const evt = (callbacks || this._callbackActive[name])[i];
			evt.callback.call(evt.scope, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);

			if (evt.once) {
				const existingCallback = this._callbacks[name];
				const ind = existingCallback ? existingCallback.indexOf(evt) : -1;

				if (ind !== -1) {
					if (this._callbackActive[name] === existingCallback) this._callbackActive[name] = this._callbackActive[name].slice();

					this._callbacks[name].splice(ind, 1);
				}
			}
		}

		if (!callbacks) this._callbackActive[name] = null;
		return this;
	}

	once(name, callback, scope) {
		this._addCallback(name, callback, scope, true);

		return this;
	}

	hasEvent(name) {
		return this._callbacks[name] && this._callbacks[name].length !== 0 || false;
	}

}

const events = {
	attach: function (target) {
		const ev = events;
		target._addCallback = ev._addCallback;
		target.on = ev.on;
		target.off = ev.off;
		target.fire = ev.fire;
		target.once = ev.once;
		target.hasEvent = ev.hasEvent;
		target._callbacks = {};
		target._callbackActive = {};
		return target;
	},
	_addCallback: EventHandler.prototype._addCallback,
	on: EventHandler.prototype.on,
	off: EventHandler.prototype.off,
	fire: EventHandler.prototype.fire,
	once: EventHandler.prototype.once,
	hasEvent: EventHandler.prototype.hasEvent
};

const guid = {
	create: function () {
		return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
			const r = Math.random() * 16 | 0;
			const v = c === 'x' ? r : r & 0x3 | 0x8;
			return v.toString(16);
		});
	}
};

const path = {
	delimiter: "/",
	join: function () {
		const num = arguments.length;
		let result = arguments[0];

		for (let index = 0; index < num - 1; ++index) {
			const one = arguments[index];
			const two = arguments[index + 1];

			if (!isDefined(one) || !isDefined(two)) {
				throw new Error("undefined argument to pc.path.join");
			}

			if (two[0] === path.delimiter) {
				result = two;
				continue;
			}

			if (one && two && one[one.length - 1] !== path.delimiter && two[0] !== path.delimiter) {
				result += path.delimiter + two;
			} else {
				result += two;
			}
		}

		return result;
	},
	normalize: function (pathname) {
		const lead = pathname.startsWith(path.delimiter);
		const trail = pathname.endsWith(path.delimiter);
		const parts = pathname.split('/');
		let result = '';
		let cleaned = [];

		for (let i = 0; i < parts.length; i++) {
			if (parts[i] === '') continue;
			if (parts[i] === '.') continue;

			if (parts[i] === '..' && cleaned.length > 0) {
				cleaned = cleaned.slice(0, cleaned.length - 2);
				continue;
			}

			if (i > 0) cleaned.push(path.delimiter);
			cleaned.push(parts[i]);
		}

		result = cleaned.join('');

		if (!lead && result[0] === path.delimiter) {
			result = result.slice(1);
		}

		if (trail && result[result.length - 1] !== path.delimiter) {
			result += path.delimiter;
		}

		return result;
	},
	split: function (pathname) {
		const parts = pathname.split(path.delimiter);
		const tail = parts.slice(parts.length - 1)[0];
		const head = parts.slice(0, parts.length - 1).join(path.delimiter);
		return [head, tail];
	},
	getBasename: function (pathname) {
		return path.split(pathname)[1];
	},
	getDirectory: function (pathname) {
		const parts = pathname.split(path.delimiter);
		return parts.slice(0, parts.length - 1).join(path.delimiter);
	},
	getExtension: function (pathname) {
		const ext = pathname.split('?')[0].split('.').pop();

		if (ext !== pathname) {
			return "." + ext;
		}

		return "";
	},
	isRelativePath: function (pathname) {
		return pathname.charAt(0) !== "/" && pathname.match(/:\/\//) === null;
	},
	extractPath: function (pathname) {
		let result = "";
		const parts = pathname.split("/");
		let i = 0;

		if (parts.length > 1) {
			if (path.isRelativePath(pathname)) {
				if (parts[0] === ".") {
					for (i = 0; i < parts.length - 1; ++i) {
						result += i === 0 ? parts[i] : "/" + parts[i];
					}
				} else if (parts[0] === "..") {
					for (i = 0; i < parts.length - 1; ++i) {
						result += i === 0 ? parts[i] : "/" + parts[i];
					}
				} else {
					result = ".";

					for (i = 0; i < parts.length - 1; ++i) {
						result += "/" + parts[i];
					}
				}
			} else {
				for (i = 0; i < parts.length - 1; ++i) {
					result += i === 0 ? parts[i] : "/" + parts[i];
				}
			}
		}

		return result;
	}
};

let desktop = false;
let mobile = false;
let windows = false;
let xbox = false;
let android = false;
let ios = false;
let touch = false;
let gamepads = false;
let workers = false;
let passiveEvents = false;

if (typeof navigator !== 'undefined') {
	const ua = navigator.userAgent;
	if (/(windows|mac os|linux|cros)/i.test(ua)) desktop = true;
	if (/xbox/i.test(ua)) xbox = true;

	if (/(windows phone|iemobile|wpdesktop)/i.test(ua)) {
		desktop = false;
		mobile = true;
		windows = true;
	} else if (/android/i.test(ua)) {
		desktop = false;
		mobile = true;
		android = true;
	} else if (/ip([ao]d|hone)/i.test(ua)) {
		desktop = false;
		mobile = true;
		ios = true;
	}

	if (typeof window !== 'undefined') {
		touch = 'ontouchstart' in window || 'maxTouchPoints' in navigator && navigator.maxTouchPoints > 0;
	}

	gamepads = 'getGamepads' in navigator;
	workers = typeof Worker !== 'undefined';

	try {
		const opts = Object.defineProperty({}, 'passive', {
			get: function () {
				passiveEvents = true;
				return false;
			}
		});
		window.addEventListener("testpassive", null, opts);
		window.removeEventListener("testpassive", null, opts);
	} catch (e) {}
}

const environment = typeof window !== 'undefined' ? 'browser' : 'node';
const platform = {
	environment: environment,
	global: environment === 'browser' ? window : global,
	browser: environment === 'browser',
	desktop: desktop,
	mobile: mobile,
	ios: ios,
	android: android,
	windows: windows,
	xbox: xbox,
	gamepads: gamepads,
	touch: touch,
	workers: workers,
	passiveEvents: passiveEvents
};

const ASCII_LOWERCASE = "abcdefghijklmnopqrstuvwxyz";
const ASCII_UPPERCASE = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
const ASCII_LETTERS = ASCII_LOWERCASE + ASCII_UPPERCASE;
const HIGH_SURROGATE_BEGIN = 0xD800;
const HIGH_SURROGATE_END = 0xDBFF;
const LOW_SURROGATE_BEGIN = 0xDC00;
const LOW_SURROGATE_END = 0xDFFF;
const ZERO_WIDTH_JOINER = 0x200D;
const REGIONAL_INDICATOR_BEGIN = 0x1F1E6;
const REGIONAL_INDICATOR_END = 0x1F1FF;
const FITZPATRICK_MODIFIER_BEGIN = 0x1F3FB;
const FITZPATRICK_MODIFIER_END = 0x1F3FF;
const DIACRITICAL_MARKS_BEGIN = 0x20D0;
const DIACRITICAL_MARKS_END = 0x20FF;
const VARIATION_MODIFIER_BEGIN = 0xFE00;
const VARIATION_MODIFIER_END = 0xFE0F;

function getCodePointData(string, i = 0) {
	const size = string.length;

	if (i < 0 || i >= size) {
		return null;
	}

	const first = string.charCodeAt(i);

	if (size > 1 && first >= HIGH_SURROGATE_BEGIN && first <= HIGH_SURROGATE_END) {
		const second = string.charCodeAt(i + 1);

		if (second >= LOW_SURROGATE_BEGIN && second <= LOW_SURROGATE_END) {
			return {
				code: (first - HIGH_SURROGATE_BEGIN) * 0x400 + second - LOW_SURROGATE_BEGIN + 0x10000,
				long: true
			};
		}
	}

	return {
		code: first,
		long: false
	};
}

function isCodeBetween(string, begin, end) {
	if (!string) return false;
	const codeData = getCodePointData(string);

	if (codeData) {
		const code = codeData.code;
		return code >= begin && code <= end;
	}

	return false;
}

function numCharsToTakeForNextSymbol(string, index) {
	if (index === string.length - 1) {
		return 1;
	}

	if (isCodeBetween(string[index], HIGH_SURROGATE_BEGIN, HIGH_SURROGATE_END)) {
		const first = string.substring(index, index + 2);
		const second = string.substring(index + 2, index + 4);

		if (isCodeBetween(second, FITZPATRICK_MODIFIER_BEGIN, FITZPATRICK_MODIFIER_END) || isCodeBetween(first, REGIONAL_INDICATOR_BEGIN, REGIONAL_INDICATOR_END) && isCodeBetween(second, REGIONAL_INDICATOR_BEGIN, REGIONAL_INDICATOR_END)) {
			return 4;
		}

		if (isCodeBetween(second, VARIATION_MODIFIER_BEGIN, VARIATION_MODIFIER_END)) {
			return 3;
		}

		return 2;
	}

	if (isCodeBetween(string[index + 1], VARIATION_MODIFIER_BEGIN, VARIATION_MODIFIER_END)) {
		return 2;
	}

	return 1;
}

const string = {
	ASCII_LOWERCASE: ASCII_LOWERCASE,
	ASCII_UPPERCASE: ASCII_UPPERCASE,
	ASCII_LETTERS: ASCII_LETTERS,
	format: function (s) {
		for (let i = 1; i < arguments.length; i++) {
			s = s.replace('{' + (i - 1) + '}', arguments[i]);
		}

		return s;
	},
	toBool: function (s, strict = false) {
		if (s === 'true') {
			return true;
		}

		if (strict) {
			if (s === 'false') {
				return false;
			}

			throw new TypeError('Not a boolean string');
		}

		return false;
	},
	getCodePoint: function (string, i) {
		const codePointData = getCodePointData(string, i);
		return codePointData && codePointData.code;
	},
	getCodePoints: function (string) {
		if (typeof string !== 'string') {
			throw new TypeError('Not a string');
		}

		let i = 0;
		const arr = [];
		let codePoint;

		while (!!(codePoint = getCodePointData(string, i))) {
			arr.push(codePoint.code);
			i += codePoint.long ? 2 : 1;
		}

		return arr;
	},
	getSymbols: function (string) {
		if (typeof string !== 'string') {
			throw new TypeError('Not a string');
		}

		let index = 0;
		const length = string.length;
		const output = [];
		let take = 0;
		let ch;

		while (index < length) {
			take += numCharsToTakeForNextSymbol(string, index + take);
			ch = string[index + take];

			if (isCodeBetween(ch, DIACRITICAL_MARKS_BEGIN, DIACRITICAL_MARKS_END)) {
				ch = string[index + take++];
			}

			if (isCodeBetween(ch, VARIATION_MODIFIER_BEGIN, VARIATION_MODIFIER_END)) {
				ch = string[index + take++];
			}

			if (ch && ch.charCodeAt(0) === ZERO_WIDTH_JOINER) {
				ch = string[index + take++];
				continue;
			}

			const char = string.substring(index, index + take);
			output.push(char);
			index += take;
			take = 0;
		}

		return output;
	},
	fromCodePoint: function () {
		const chars = [];
		let current;
		let codePoint;
		let units;

		for (let i = 0; i < arguments.length; ++i) {
			current = Number(arguments[i]);
			codePoint = current - 0x10000;
			units = current > 0xFFFF ? [(codePoint >> 10) + 0xD800, codePoint % 0x400 + 0xDC00] : [current];
			chars.push(String.fromCharCode.apply(null, units));
		}

		return chars.join('');
	}
};

class IndexedList {
	constructor() {
		this._list = [];
		this._index = {};
	}

	push(key, item) {
		if (this._index[key]) {
			throw Error("Key already in index " + key);
		}

		const location = this._list.push(item) - 1;
		this._index[key] = location;
	}

	has(key) {
		return this._index[key] !== undefined;
	}

	get(key) {
		const location = this._index[key];

		if (location !== undefined) {
			return this._list[location];
		}

		return null;
	}

	remove(key) {
		const location = this._index[key];

		if (location !== undefined) {
			this._list.splice(location, 1);

			delete this._index[key];

			for (key in this._index) {
				const idx = this._index[key];

				if (idx > location) {
					this._index[key] = idx - 1;
				}
			}

			return true;
		}

		return false;
	}

	list() {
		return this._list;
	}

	clear() {
		this._list.length = 0;

		for (const prop in this._index) {
			delete this._index[prop];
		}
	}

}

class ReadStream {
	constructor(arraybuffer) {
		this.arraybuffer = arraybuffer;
		this.dataView = new DataView(arraybuffer);
		this.offset = 0;
		this.stack = [];
	}

	get remainingBytes() {
		return this.dataView.byteLength - this.offset;
	}

	reset(offset = 0) {
		this.offset = offset;
	}

	skip(bytes) {
		this.offset += bytes;
	}

	align(bytes) {
		this.offset = this.offset + bytes - 1 & ~(bytes - 1);
	}

	_inc(amount) {
		this.offset += amount;
		return this.offset - amount;
	}

	readChar() {
		return String.fromCharCode(this.dataView.getUint8(this.offset++));
	}

	readChars(numChars) {
		let result = '';

		for (let i = 0; i < numChars; ++i) {
			result += this.readChar();
		}

		return result;
	}

	readU8() {
		return this.dataView.getUint8(this.offset++);
	}

	readU16() {
		return this.dataView.getUint16(this._inc(2), true);
	}

	readU32() {
		return this.dataView.getUint32(this._inc(4), true);
	}

	readU64() {
		return this.readU32() + 2 ** 32 * this.readU32();
	}

	readU32be() {
		return this.dataView.getUint32(this._inc(4), false);
	}

	readArray(result) {
		for (let i = 0; i < result.length; ++i) {
			result[i] = this.readU8();
		}
	}

	readLine() {
		const view = this.dataView;
		let result = "";

		while (true) {
			if (this.offset >= view.byteLength) {
				break;
			}

			const c = String.fromCharCode(this.readU8());

			if (c === '\n') {
				break;
			}

			result += c;
		}

		return result;
	}

}

class SortedLoopArray {
	constructor(args) {
		this.items = [];
		this.length = 0;
		this.loopIndex = -1;
		this._sortBy = args.sortBy;
		this._sortHandler = this._doSort.bind(this);
	}

	_binarySearch(item) {
		let left = 0;
		let right = this.items.length - 1;
		const search = item[this._sortBy];
		let middle;
		let current;

		while (left <= right) {
			middle = Math.floor((left + right) / 2);
			current = this.items[middle][this._sortBy];

			if (current <= search) {
				left = middle + 1;
			} else if (current > search) {
				right = middle - 1;
			}
		}

		return left;
	}

	_doSort(a, b) {
		const sortBy = this._sortBy;
		return a[sortBy] - b[sortBy];
	}

	insert(item) {
		const index = this._binarySearch(item);

		this.items.splice(index, 0, item);
		this.length++;

		if (this.loopIndex >= index) {
			this.loopIndex++;
		}
	}

	append(item) {
		this.items.push(item);
		this.length++;
	}

	remove(item) {
		const idx = this.items.indexOf(item);
		if (idx < 0) return;
		this.items.splice(idx, 1);
		this.length--;

		if (this.loopIndex >= idx) {
			this.loopIndex--;
		}
	}

	sort() {
		const current = this.loopIndex >= 0 ? this.items[this.loopIndex] : null;
		this.items.sort(this._sortHandler);

		if (current !== null) {
			this.loopIndex = this.items.indexOf(current);
		}
	}

}

class Tags extends EventHandler {
	constructor(parent) {
		super();
		this._index = {};
		this._list = [];
		this._parent = parent;
	}

	add() {
		let changed = false;

		const tags = this._processArguments(arguments, true);

		if (!tags.length) return changed;

		for (let i = 0; i < tags.length; i++) {
			if (this._index[tags[i]]) continue;
			changed = true;
			this._index[tags[i]] = true;

			this._list.push(tags[i]);

			this.fire('add', tags[i], this._parent);
		}

		if (changed) this.fire('change', this._parent);
		return changed;
	}

	remove() {
		let changed = false;
		if (!this._list.length) return changed;

		const tags = this._processArguments(arguments, true);

		if (!tags.length) return changed;

		for (let i = 0; i < tags.length; i++) {
			if (!this._index[tags[i]]) continue;
			changed = true;
			delete this._index[tags[i]];

			this._list.splice(this._list.indexOf(tags[i]), 1);

			this.fire('remove', tags[i], this._parent);
		}

		if (changed) this.fire('change', this._parent);
		return changed;
	}

	clear() {
		if (!this._list.length) return;

		const tags = this._list.slice(0);

		this._list = [];
		this._index = {};

		for (let i = 0; i < tags.length; i++) this.fire('remove', tags[i], this._parent);

		this.fire('change', this._parent);
	}

	has() {
		if (!this._list.length) return false;
		return this._has(this._processArguments(arguments));
	}

	_has(tags) {
		if (!this._list.length || !tags.length) return false;

		for (let i = 0; i < tags.length; i++) {
			if (tags[i].length === 1) {
				if (this._index[tags[i][0]]) return true;
			} else {
				let multiple = true;

				for (let t = 0; t < tags[i].length; t++) {
					if (this._index[tags[i][t]]) continue;
					multiple = false;
					break;
				}

				if (multiple) return true;
			}
		}

		return false;
	}

	list() {
		return this._list.slice(0);
	}

	_processArguments(args, flat) {
		const tags = [];
		let tmp = [];
		if (!args || !args.length) return tags;

		for (let i = 0; i < args.length; i++) {
			if (args[i] instanceof Array) {
				if (!flat) tmp = [];

				for (let t = 0; t < args[i].length; t++) {
					if (typeof args[i][t] !== 'string') continue;

					if (flat) {
						tags.push(args[i][t]);
					} else {
						tmp.push(args[i][t]);
					}
				}

				if (!flat && tmp.length) tags.push(tmp);
			} else if (typeof args[i] === 'string') {
				if (flat) {
					tags.push(args[i]);
				} else {
					tags.push([args[i]]);
				}
			}
		}

		return tags;
	}

	get size() {
		return this._list.length;
	}

}

const now = typeof window !== 'undefined' && window.performance && window.performance.now && window.performance.timing ? function () {
	return window.performance.now();
} : Date.now;

class Timer {
	constructor() {
		this._isRunning = false;
		this._a = 0;
		this._b = 0;
	}

	start() {
		this._isRunning = true;
		this._a = now();
	}

	stop() {
		this._isRunning = false;
		this._b = now();
	}

	getMilliseconds() {
		return this._b - this._a;
	}

}

function createURI(options) {
	let s = "";

	if ((options.authority || options.scheme) && (options.host || options.hostpath)) {
		throw new Error("Can't have 'scheme' or 'authority' and 'host' or 'hostpath' option");
	}

	if (options.host && options.hostpath) {
		throw new Error("Can't have 'host' and 'hostpath' option");
	}

	if (options.path && options.hostpath) {
		throw new Error("Can't have 'path' and 'hostpath' option");
	}

	if (options.scheme) {
		s += options.scheme + ":";
	}

	if (options.authority) {
		s += "//" + options.authority;
	}

	if (options.host) {
		s += options.host;
	}

	if (options.path) {
		s += options.path;
	}

	if (options.hostpath) {
		s += options.hostpath;
	}

	if (options.query) {
		s += "?" + options.query;
	}

	if (options.fragment) {
		s += "#" + options.fragment;
	}

	return s;
}

const re = /^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;

class URI {
	constructor(uri) {
		const result = uri.match(re);
		this.scheme = result[2];
		this.authority = result[4];
		this.path = result[5];
		this.query = result[7];
		this.fragment = result[9];
	}

	toString() {
		let s = "";

		if (this.scheme) {
			s += this.scheme + ":";
		}

		if (this.authority) {
			s += "//" + this.authority;
		}

		s += this.path;

		if (this.query) {
			s += "?" + this.query;
		}

		if (this.fragment) {
			s += "#" + this.fragment;
		}

		return s;
	}

	getQuery() {
		const result = {};

		if (this.query) {
			const queryParams = decodeURIComponent(this.query).split("&");

			for (const queryParam of queryParams) {
				const pair = queryParam.split("=");
				result[pair[0]] = pair[1];
			}
		}

		return result;
	}

	setQuery(params) {
		let q = "";

		for (const key in params) {
			if (params.hasOwnProperty(key)) {
				if (q !== "") {
					q += "&";
				}

				q += encodeURIComponent(key) + "=" + encodeURIComponent(params[key]);
			}
		}

		this.query = q;
	}

}

const math = {
	DEG_TO_RAD: Math.PI / 180,
	RAD_TO_DEG: 180 / Math.PI,
	clamp: function (value, min, max) {
		if (value >= max) return max;
		if (value <= min) return min;
		return value;
	},
	intToBytes24: function (i) {
		const r = i >> 16 & 0xff;
		const g = i >> 8 & 0xff;
		const b = i & 0xff;
		return [r, g, b];
	},
	intToBytes32: function (i) {
		const r = i >> 24 & 0xff;
		const g = i >> 16 & 0xff;
		const b = i >> 8 & 0xff;
		const a = i & 0xff;
		return [r, g, b, a];
	},
	bytesToInt24: function (r, g, b) {
		if (r.length) {
			b = r[2];
			g = r[1];
			r = r[0];
		}

		return r << 16 | g << 8 | b;
	},
	bytesToInt32: function (r, g, b, a) {
		if (r.length) {
			a = r[3];
			b = r[2];
			g = r[1];
			r = r[0];
		}

		return (r << 24 | g << 16 | b << 8 | a) >>> 0;
	},
	lerp: function (a, b, alpha) {
		return a + (b - a) * math.clamp(alpha, 0, 1);
	},
	lerpAngle: function (a, b, alpha) {
		if (b - a > 180) {
			b -= 360;
		}

		if (b - a < -180) {
			b += 360;
		}

		return math.lerp(a, b, math.clamp(alpha, 0, 1));
	},
	powerOfTwo: function (x) {
		return x !== 0 && !(x & x - 1);
	},
	nextPowerOfTwo: function (val) {
		val--;
		val |= val >> 1;
		val |= val >> 2;
		val |= val >> 4;
		val |= val >> 8;
		val |= val >> 16;
		val++;
		return val;
	},
	random: function (min, max) {
		const diff = max - min;
		return Math.random() * diff + min;
	},
	smoothstep: function (min, max, x) {
		if (x <= min) return 0;
		if (x >= max) return 1;
		x = (x - min) / (max - min);
		return x * x * (3 - 2 * x);
	},
	smootherstep: function (min, max, x) {
		if (x <= min) return 0;
		if (x >= max) return 1;
		x = (x - min) / (max - min);
		return x * x * x * (x * (x * 6 - 15) + 10);
	},
	roundUp: function (numToRound, multiple) {
		if (multiple === 0) return numToRound;
		return Math.ceil(numToRound / multiple) * multiple;
	},
	between: function (num, a, b, inclusive) {
		const min = Math.min(a, b);
		const max = Math.max(a, b);
		return inclusive ? num >= min && num <= max : num > min && num < max;
	}
};

class Http {
	get(url, options, callback) {
		if (typeof options === "function") {
			callback = options;
			options = {};
		}

		return this.request("GET", url, options, callback);
	}

	post(url, data, options, callback) {
		if (typeof options === "function") {
			callback = options;
			options = {};
		}

		options.postdata = data;
		return this.request("POST", url, options, callback);
	}

	put(url, data, options, callback) {
		if (typeof options === "function") {
			callback = options;
			options = {};
		}

		options.postdata = data;
		return this.request("PUT", url, options, callback);
	}

	del(url, options, callback) {
		if (typeof options === "function") {
			callback = options;
			options = {};
		}

		return this.request("DELETE", url, options, callback);
	}

	request(method, url, options, callback) {
		let uri, query, postdata;
		let errored = false;

		if (typeof options === "function") {
			callback = options;
			options = {};
		}

		if (options.retry) {
			options = Object.assign({
				retries: 0,
				maxRetries: 5
			}, options);
		}

		options.callback = callback;

		if (options.async == null) {
			options.async = true;
		}

		if (options.headers == null) {
			options.headers = {};
		}

		if (options.postdata != null) {
			if (options.postdata instanceof Document) {
				postdata = options.postdata;
			} else if (options.postdata instanceof FormData) {
				postdata = options.postdata;
			} else if (options.postdata instanceof Object) {
				let contentType = options.headers["Content-Type"];

				if (contentType === undefined) {
					options.headers["Content-Type"] = Http.ContentType.FORM_URLENCODED;
					contentType = options.headers["Content-Type"];
				}

				switch (contentType) {
					case Http.ContentType.FORM_URLENCODED:
						{
							postdata = "";
							let bFirstItem = true;

							for (const key in options.postdata) {
								if (options.postdata.hasOwnProperty(key)) {
									if (bFirstItem) {
										bFirstItem = false;
									} else {
										postdata += "&";
									}

									const encodedKey = encodeURIComponent(key);
									const encodedValue = encodeURIComponent(options.postdata[key]);
									postdata += `${encodedKey}=${encodedValue}`;
								}
							}

							break;
						}

					default:
					case Http.ContentType.JSON:
						if (contentType == null) {
							options.headers["Content-Type"] = Http.ContentType.JSON;
						}

						postdata = JSON.stringify(options.postdata);
						break;
				}
			} else {
				postdata = options.postdata;
			}
		}

		if (options.cache === false) {
			const timestamp = now();
			uri = new URI(url);

			if (!uri.query) {
				uri.query = "ts=" + timestamp;
			} else {
				uri.query = uri.query + "&ts=" + timestamp;
			}

			url = uri.toString();
		}

		if (options.query) {
			uri = new URI(url);
			query = extend(uri.getQuery(), options.query);
			uri.setQuery(query);
			url = uri.toString();
		}

		const xhr = new XMLHttpRequest();
		xhr.open(method, url, options.async);
		xhr.withCredentials = options.withCredentials !== undefined ? options.withCredentials : false;
		xhr.responseType = options.responseType || this._guessResponseType(url);

		for (const header in options.headers) {
			if (options.headers.hasOwnProperty(header)) {
				xhr.setRequestHeader(header, options.headers[header]);
			}
		}

		xhr.onreadystatechange = () => {
			this._onReadyStateChange(method, url, options, xhr);
		};

		xhr.onerror = () => {
			this._onError(method, url, options, xhr);

			errored = true;
		};

		try {
			xhr.send(postdata);
		} catch (e) {
			if (!errored) {
				options.error(xhr.status, xhr, e);
			}
		}

		return xhr;
	}

	_guessResponseType(url) {
		const uri = new URI(url);
		const ext = path.getExtension(uri.path);

		if (Http.binaryExtensions.indexOf(ext) >= 0) {
			return Http.ResponseType.ARRAY_BUFFER;
		}

		if (ext === ".xml") {
			return Http.ResponseType.DOCUMENT;
		}

		return Http.ResponseType.TEXT;
	}

	_isBinaryContentType(contentType) {
		const binTypes = [Http.ContentType.MP4, Http.ContentType.WAV, Http.ContentType.OGG, Http.ContentType.MP3, Http.ContentType.BIN, Http.ContentType.DDS, Http.ContentType.BASIS, Http.ContentType.GLB];

		if (binTypes.indexOf(contentType) >= 0) {
			return true;
		}

		return false;
	}

	_onReadyStateChange(method, url, options, xhr) {
		if (xhr.readyState === 4) {
			switch (xhr.status) {
				case 0:
					{
						if (xhr.responseURL && xhr.responseURL.startsWith('file:///')) {
							this._onSuccess(method, url, options, xhr);
						} else {
							this._onError(method, url, options, xhr);
						}

						break;
					}

				case 200:
				case 201:
				case 206:
				case 304:
					{
						this._onSuccess(method, url, options, xhr);

						break;
					}

				default:
					{
						this._onError(method, url, options, xhr);

						break;
					}
			}
		}
	}

	_onSuccess(method, url, options, xhr) {
		let response;
		let contentType;
		const header = xhr.getResponseHeader("Content-Type");

		if (header) {
			const parts = header.split(";");
			contentType = parts[0].trim();
		}

		try {
			if (contentType === Http.ContentType.JSON || url.split('?')[0].endsWith(".json")) {
				response = JSON.parse(xhr.responseText);
			} else if (this._isBinaryContentType(contentType)) {
				response = xhr.response;
			} else {
				if (xhr.responseType === Http.ResponseType.ARRAY_BUFFER) {
					response = xhr.response;
				} else if (xhr.responseType === Http.ResponseType.BLOB || xhr.responseType === Http.ResponseType.JSON) {
					response = xhr.response;
				} else {
					if (xhr.responseType === Http.ResponseType.DOCUMENT || contentType === Http.ContentType.XML) {
						response = xhr.responseXML;
					} else {
						response = xhr.responseText;
					}
				}
			}

			options.callback(null, response);
		} catch (err) {
			options.callback(err);
		}
	}

	_onError(method, url, options, xhr) {
		if (options.retrying) {
			return;
		}

		if (options.retry && options.retries < options.maxRetries) {
			options.retries++;
			options.retrying = true;
			const retryDelay = math.clamp(Math.pow(2, options.retries) * Http.retryDelay, 0, options.maxRetryDelay || 5000);
			console.log(`${method}: ${url} - Error ${xhr.status}. Retrying in ${retryDelay} ms`);
			setTimeout(() => {
				options.retrying = false;
				this.request(method, url, options, options.callback);
			}, retryDelay);
		} else {
			options.callback(xhr.status === 0 ? 'Network error' : xhr.status, null);
		}
	}

}

Http.ContentType = {
	FORM_URLENCODED: "application/x-www-form-urlencoded",
	GIF: "image/gif",
	JPEG: "image/jpeg",
	DDS: "image/dds",
	JSON: "application/json",
	PNG: "image/png",
	TEXT: "text/plain",
	XML: "application/xml",
	WAV: "audio/x-wav",
	OGG: "audio/ogg",
	MP3: "audio/mpeg",
	MP4: "audio/mp4",
	AAC: "audio/aac",
	BIN: "application/octet-stream",
	BASIS: "image/basis",
	GLB: "model/gltf-binary"
};
Http.ResponseType = {
	TEXT: 'text',
	ARRAY_BUFFER: 'arraybuffer',
	BLOB: 'blob',
	DOCUMENT: 'document',
	JSON: 'json'
};
Http.binaryExtensions = ['.model', '.wav', '.ogg', '.mp3', '.mp4', '.m4a', '.aac', '.dds', '.basis', '.glb'];
Http.retryDelay = 100;
const http = new Http();

const CURVE_LINEAR = 0;
const CURVE_SMOOTHSTEP = 1;
const CURVE_CATMULL = 2;
const CURVE_CARDINAL = 3;
const CURVE_SPLINE = 4;
const CURVE_STEP = 5;

class Color {
	constructor(r = 0, g = 0, b = 0, a = 1) {
		const length = r.length;

		if (length === 3 || length === 4) {
			this.r = r[0];
			this.g = r[1];
			this.b = r[2];
			this.a = r[3] !== undefined ? r[3] : 1;
		} else {
			this.r = r;
			this.g = g;
			this.b = b;
			this.a = a;
		}
	}

	clone() {
		return new Color(this.r, this.g, this.b, this.a);
	}

	copy(rhs) {
		this.r = rhs.r;
		this.g = rhs.g;
		this.b = rhs.b;
		this.a = rhs.a;
		return this;
	}

	equals(rhs) {
		return this.r === rhs.r && this.g === rhs.g && this.b === rhs.b && this.a === rhs.a;
	}

	set(r, g, b, a = 1) {
		this.r = r;
		this.g = g;
		this.b = b;
		this.a = a;
		return this;
	}

	lerp(lhs, rhs, alpha) {
		this.r = lhs.r + alpha * (rhs.r - lhs.r);
		this.g = lhs.g + alpha * (rhs.g - lhs.g);
		this.b = lhs.b + alpha * (rhs.b - lhs.b);
		this.a = lhs.a + alpha * (rhs.a - lhs.a);
		return this;
	}

	fromString(hex) {
		const i = parseInt(hex.replace('#', '0x'), 16);
		let bytes;

		if (hex.length > 7) {
			bytes = math.intToBytes32(i);
		} else {
			bytes = math.intToBytes24(i);
			bytes[3] = 255;
		}

		this.set(bytes[0] / 255, bytes[1] / 255, bytes[2] / 255, bytes[3] / 255);
		return this;
	}

	toString(alpha) {
		let s = "#" + ((1 << 24) + (Math.round(this.r * 255) << 16) + (Math.round(this.g * 255) << 8) + Math.round(this.b * 255)).toString(16).slice(1);

		if (alpha === true) {
			const a = Math.round(this.a * 255).toString(16);

			if (this.a < 16 / 255) {
				s += '0' + a;
			} else {
				s += a;
			}
		}

		return s;
	}

}

Color.BLACK = Object.freeze(new Color(0, 0, 0, 1));
Color.BLUE = Object.freeze(new Color(0, 0, 1, 1));
Color.CYAN = Object.freeze(new Color(0, 1, 1, 1));
Color.GRAY = Object.freeze(new Color(0.5, 0.5, 0.5, 1));
Color.GREEN = Object.freeze(new Color(0, 1, 0, 1));
Color.MAGENTA = Object.freeze(new Color(1, 0, 1, 1));
Color.RED = Object.freeze(new Color(1, 0, 0, 1));
Color.WHITE = Object.freeze(new Color(1, 1, 1, 1));
Color.YELLOW = Object.freeze(new Color(1, 1, 0, 1));

class CurveEvaluator {
	constructor(curve, time = 0) {
		this._curve = curve;
		this._left = -Infinity;
		this._right = Infinity;
		this._recip = 0;
		this._p0 = 0;
		this._p1 = 0;
		this._m0 = 0;
		this._m1 = 0;

		this._reset(time);
	}

	evaluate(time, forceReset = false) {
		if (forceReset || time < this._left || time >= this._right) {
			this._reset(time);
		}

		let result;
		const type = this._curve.type;

		if (type === CURVE_STEP) {
			result = this._p0;
		} else {
			const t = this._recip === 0 ? 0 : (time - this._left) * this._recip;

			if (type === CURVE_LINEAR) {
				result = math.lerp(this._p0, this._p1, t);
			} else if (type === CURVE_SMOOTHSTEP) {
				result = math.lerp(this._p0, this._p1, t * t * (3 - 2 * t));
			} else {
				result = this._evaluateHermite(this._p0, this._p1, this._m0, this._m1, t);
			}
		}

		return result;
	}

	_reset(time) {
		const keys = this._curve.keys;
		const len = keys.length;

		if (!len) {
			this._left = -Infinity;
			this._right = Infinity;
			this._recip = 0;
			this._p0 = this._p1 = this._m0 = this._m1 = 0;
		} else {
			if (time < keys[0][0]) {
				this._left = -Infinity;
				this._right = keys[0][0];
				this._recip = 0;
				this._p0 = this._p1 = keys[0][1];
				this._m0 = this._m1 = 0;
			} else if (time >= keys[len - 1][0]) {
				this._left = keys[len - 1][0];
				this._right = Infinity;
				this._recip = 0;
				this._p0 = this._p1 = keys[len - 1][1];
				this._m0 = this._m1 = 0;
			} else {
				let index = 0;

				while (time >= keys[index + 1][0]) {
					index++;
				}

				this._left = keys[index][0];
				this._right = keys[index + 1][0];
				const diff = 1.0 / (this._right - this._left);
				this._recip = isFinite(diff) ? diff : 0;
				this._p0 = keys[index][1];
				this._p1 = keys[index + 1][1];

				if (this._isHermite()) {
					this._calcTangents(keys, index);
				}
			}
		}
	}

	_isHermite() {
		return this._curve.type === CURVE_CATMULL || this._curve.type === CURVE_CARDINAL || this._curve.type === CURVE_SPLINE;
	}

	_calcTangents(keys, index) {
		let a;
		const b = keys[index];
		const c = keys[index + 1];
		let d;

		if (index === 0) {
			a = [keys[0][0] + (keys[0][0] - keys[1][0]), keys[0][1] + (keys[0][1] - keys[1][1])];
		} else {
			a = keys[index - 1];
		}

		if (index === keys.length - 2) {
			d = [keys[index + 1][0] + (keys[index + 1][0] - keys[index][0]), keys[index + 1][1] + (keys[index + 1][1] - keys[index][1])];
		} else {
			d = keys[index + 2];
		}

		if (this._curve.type === CURVE_SPLINE) {
			const s1_ = 2 * (c[0] - b[0]) / (c[0] - a[0]);
			const s2_ = 2 * (c[0] - b[0]) / (d[0] - b[0]);
			this._m0 = this._curve.tension * (isFinite(s1_) ? s1_ : 0) * (c[1] - a[1]);
			this._m1 = this._curve.tension * (isFinite(s2_) ? s2_ : 0) * (d[1] - b[1]);
		} else {
			const s1 = (c[0] - b[0]) / (b[0] - a[0]);
			const s2 = (c[0] - b[0]) / (d[0] - c[0]);
			const a_ = b[1] + (a[1] - b[1]) * (isFinite(s1) ? s1 : 0);
			const d_ = c[1] + (d[1] - c[1]) * (isFinite(s2) ? s2 : 0);
			const tension = this._curve.type === CURVE_CATMULL ? 0.5 : this._curve.tension;
			this._m0 = tension * (c[1] - a_);
			this._m1 = tension * (d_ - b[1]);
		}
	}

	_evaluateHermite(p0, p1, m0, m1, t) {
		const t2 = t * t;
		const twot = t + t;
		const omt = 1 - t;
		const omt2 = omt * omt;
		return p0 * ((1 + twot) * omt2) + m0 * (t * omt2) + p1 * (t2 * (3 - twot)) + m1 * (t2 * (t - 1));
	}

}

class Curve {
	constructor(data) {
		this.keys = [];
		this.type = CURVE_SMOOTHSTEP;
		this.tension = 0.5;
		this._eval = new CurveEvaluator(this);

		if (data) {
			for (let i = 0; i < data.length - 1; i += 2) {
				this.keys.push([data[i], data[i + 1]]);
			}
		}

		this.sort();
	}

	get length() {
		return this.keys.length;
	}

	add(time, value) {
		const keys = this.keys;
		const len = keys.length;
		let i = 0;

		for (; i < len; i++) {
			if (keys[i][0] > time) {
				break;
			}
		}

		const key = [time, value];
		this.keys.splice(i, 0, key);
		return key;
	}

	get(index) {
		return this.keys[index];
	}

	sort() {
		this.keys.sort(function (a, b) {
			return a[0] - b[0];
		});
	}

	value(time) {
		return this._eval.evaluate(time, true);
	}

	closest(time) {
		const keys = this.keys;
		const length = keys.length;
		let min = 2;
		let result = null;

		for (let i = 0; i < length; i++) {
			const diff = Math.abs(time - keys[i][0]);

			if (min >= diff) {
				min = diff;
				result = keys[i];
			} else {
				break;
			}
		}

		return result;
	}

	clone() {
		const result = new Curve();
		result.keys = extend(result.keys, this.keys);
		result.type = this.type;
		result.tension = this.tension;
		return result;
	}

	quantize(precision) {
		precision = Math.max(precision, 2);
		const values = new Float32Array(precision);
		const step = 1.0 / (precision - 1);
		values[0] = this._eval.evaluate(0, true);

		for (let i = 1; i < precision; i++) {
			values[i] = this._eval.evaluate(step * i);
		}

		return values;
	}

	quantizeClamped(precision, min, max) {
		const result = this.quantize(precision);

		for (let i = 0; i < result.length; ++i) {
			result[i] = Math.min(max, Math.max(min, result[i]));
		}

		return result;
	}

}

class CurveSet {
	constructor() {
		this.curves = [];
		this._type = CURVE_SMOOTHSTEP;

		if (arguments.length > 1) {
			for (let i = 0; i < arguments.length; i++) {
				this.curves.push(new Curve(arguments[i]));
			}
		} else {
			if (arguments.length === 0) {
				this.curves.push(new Curve());
			} else {
				const arg = arguments[0];

				if (typeof arg === 'number') {
					for (let i = 0; i < arg; i++) {
						this.curves.push(new Curve());
					}
				} else {
					for (let i = 0; i < arg.length; i++) {
						this.curves.push(new Curve(arg[i]));
					}
				}
			}
		}
	}

	get length() {
		return this.curves.length;
	}

	set type(value) {
		this._type = value;

		for (let i = 0; i < this.curves.length; i++) {
			this.curves[i].type = value;
		}
	}

	get type() {
		return this._type;
	}

	get(index) {
		return this.curves[index];
	}

	value(time, result = []) {
		const length = this.curves.length;
		result.length = length;

		for (let i = 0; i < length; i++) {
			result[i] = this.curves[i].value(time);
		}

		return result;
	}

	clone() {
		const result = new CurveSet();
		result.curves = [];

		for (let i = 0; i < this.curves.length; i++) {
			result.curves.push(this.curves[i].clone());
		}

		result._type = this._type;
		return result;
	}

	quantize(precision) {
		precision = Math.max(precision, 2);
		const numCurves = this.curves.length;
		const values = new Float32Array(precision * numCurves);
		const step = 1.0 / (precision - 1);

		for (let c = 0; c < numCurves; c++) {
			const ev = new CurveEvaluator(this.curves[c]);

			for (let i = 0; i < precision; i++) {
				values[i * numCurves + c] = ev.evaluate(step * i);
			}
		}

		return values;
	}

	quantizeClamped(precision, min, max) {
		const result = this.quantize(precision);

		for (let i = 0; i < result.length; ++i) {
			result[i] = Math.min(max, Math.max(min, result[i]));
		}

		return result;
	}

}

class Vec3 {
	constructor(x = 0, y = 0, z = 0) {
		if (x.length === 3) {
			this.x = x[0];
			this.y = x[1];
			this.z = x[2];
		} else {
			this.x = x;
			this.y = y;
			this.z = z;
		}
	}

	add(rhs) {
		this.x += rhs.x;
		this.y += rhs.y;
		this.z += rhs.z;
		return this;
	}

	add2(lhs, rhs) {
		this.x = lhs.x + rhs.x;
		this.y = lhs.y + rhs.y;
		this.z = lhs.z + rhs.z;
		return this;
	}

	addScalar(scalar) {
		this.x += scalar;
		this.y += scalar;
		this.z += scalar;
		return this;
	}

	clone() {
		return new Vec3(this.x, this.y, this.z);
	}

	copy(rhs) {
		this.x = rhs.x;
		this.y = rhs.y;
		this.z = rhs.z;
		return this;
	}

	cross(lhs, rhs) {
		const lx = lhs.x;
		const ly = lhs.y;
		const lz = lhs.z;
		const rx = rhs.x;
		const ry = rhs.y;
		const rz = rhs.z;
		this.x = ly * rz - ry * lz;
		this.y = lz * rx - rz * lx;
		this.z = lx * ry - rx * ly;
		return this;
	}

	distance(rhs) {
		const x = this.x - rhs.x;
		const y = this.y - rhs.y;
		const z = this.z - rhs.z;
		return Math.sqrt(x * x + y * y + z * z);
	}

	div(rhs) {
		this.x /= rhs.x;
		this.y /= rhs.y;
		this.z /= rhs.z;
		return this;
	}

	div2(lhs, rhs) {
		this.x = lhs.x / rhs.x;
		this.y = lhs.y / rhs.y;
		this.z = lhs.z / rhs.z;
		return this;
	}

	divScalar(scalar) {
		this.x /= scalar;
		this.y /= scalar;
		this.z /= scalar;
		return this;
	}

	dot(rhs) {
		return this.x * rhs.x + this.y * rhs.y + this.z * rhs.z;
	}

	equals(rhs) {
		return this.x === rhs.x && this.y === rhs.y && this.z === rhs.z;
	}

	length() {
		return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
	}

	lengthSq() {
		return this.x * this.x + this.y * this.y + this.z * this.z;
	}

	lerp(lhs, rhs, alpha) {
		this.x = lhs.x + alpha * (rhs.x - lhs.x);
		this.y = lhs.y + alpha * (rhs.y - lhs.y);
		this.z = lhs.z + alpha * (rhs.z - lhs.z);
		return this;
	}

	mul(rhs) {
		this.x *= rhs.x;
		this.y *= rhs.y;
		this.z *= rhs.z;
		return this;
	}

	mul2(lhs, rhs) {
		this.x = lhs.x * rhs.x;
		this.y = lhs.y * rhs.y;
		this.z = lhs.z * rhs.z;
		return this;
	}

	mulScalar(scalar) {
		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;
		return this;
	}

	normalize() {
		const lengthSq = this.x * this.x + this.y * this.y + this.z * this.z;

		if (lengthSq > 0) {
			const invLength = 1 / Math.sqrt(lengthSq);
			this.x *= invLength;
			this.y *= invLength;
			this.z *= invLength;
		}

		return this;
	}

	floor() {
		this.x = Math.floor(this.x);
		this.y = Math.floor(this.y);
		this.z = Math.floor(this.z);
		return this;
	}

	ceil() {
		this.x = Math.ceil(this.x);
		this.y = Math.ceil(this.y);
		this.z = Math.ceil(this.z);
		return this;
	}

	round() {
		this.x = Math.round(this.x);
		this.y = Math.round(this.y);
		this.z = Math.round(this.z);
		return this;
	}

	min(rhs) {
		if (rhs.x < this.x) this.x = rhs.x;
		if (rhs.y < this.y) this.y = rhs.y;
		if (rhs.z < this.z) this.z = rhs.z;
		return this;
	}

	max(rhs) {
		if (rhs.x > this.x) this.x = rhs.x;
		if (rhs.y > this.y) this.y = rhs.y;
		if (rhs.z > this.z) this.z = rhs.z;
		return this;
	}

	project(rhs) {
		const a_dot_b = this.x * rhs.x + this.y * rhs.y + this.z * rhs.z;
		const b_dot_b = rhs.x * rhs.x + rhs.y * rhs.y + rhs.z * rhs.z;
		const s = a_dot_b / b_dot_b;
		this.x = rhs.x * s;
		this.y = rhs.y * s;
		this.z = rhs.z * s;
		return this;
	}

	set(x, y, z) {
		this.x = x;
		this.y = y;
		this.z = z;
		return this;
	}

	sub(rhs) {
		this.x -= rhs.x;
		this.y -= rhs.y;
		this.z -= rhs.z;
		return this;
	}

	sub2(lhs, rhs) {
		this.x = lhs.x - rhs.x;
		this.y = lhs.y - rhs.y;
		this.z = lhs.z - rhs.z;
		return this;
	}

	subScalar(scalar) {
		this.x -= scalar;
		this.y -= scalar;
		this.z -= scalar;
		return this;
	}

	toString() {
		return `[${this.x}, ${this.y}, ${this.z}]`;
	}

}

Vec3.ZERO = Object.freeze(new Vec3(0, 0, 0));
Vec3.ONE = Object.freeze(new Vec3(1, 1, 1));
Vec3.UP = Object.freeze(new Vec3(0, 1, 0));
Vec3.DOWN = Object.freeze(new Vec3(0, -1, 0));
Vec3.RIGHT = Object.freeze(new Vec3(1, 0, 0));
Vec3.LEFT = Object.freeze(new Vec3(-1, 0, 0));
Vec3.FORWARD = Object.freeze(new Vec3(0, 0, -1));
Vec3.BACK = Object.freeze(new Vec3(0, 0, 1));

class Mat3 {
	constructor() {
		const data = new Float32Array(9);
		data[0] = data[4] = data[8] = 1;
		this.data = data;
	}

	clone() {
		return new Mat3().copy(this);
	}

	copy(rhs) {
		const src = rhs.data;
		const dst = this.data;
		dst[0] = src[0];
		dst[1] = src[1];
		dst[2] = src[2];
		dst[3] = src[3];
		dst[4] = src[4];
		dst[5] = src[5];
		dst[6] = src[6];
		dst[7] = src[7];
		dst[8] = src[8];
		return this;
	}

	set(src) {
		const dst = this.data;
		dst[0] = src[0];
		dst[1] = src[1];
		dst[2] = src[2];
		dst[3] = src[3];
		dst[4] = src[4];
		dst[5] = src[5];
		dst[6] = src[6];
		dst[7] = src[7];
		dst[8] = src[8];
		return this;
	}

	equals(rhs) {
		const l = this.data;
		const r = rhs.data;
		return l[0] === r[0] && l[1] === r[1] && l[2] === r[2] && l[3] === r[3] && l[4] === r[4] && l[5] === r[5] && l[6] === r[6] && l[7] === r[7] && l[8] === r[8];
	}

	isIdentity() {
		const m = this.data;
		return m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 0 && m[4] === 1 && m[5] === 0 && m[6] === 0 && m[7] === 0 && m[8] === 1;
	}

	setIdentity() {
		const m = this.data;
		m[0] = 1;
		m[1] = 0;
		m[2] = 0;
		m[3] = 0;
		m[4] = 1;
		m[5] = 0;
		m[6] = 0;
		m[7] = 0;
		m[8] = 1;
		return this;
	}

	toString() {
		let t = '[';

		for (let i = 0; i < 9; i++) {
			t += this.data[i];
			t += i !== 8 ? ', ' : '';
		}

		t += ']';
		return t;
	}

	transpose() {
		const m = this.data;
		let tmp;
		tmp = m[1];
		m[1] = m[3];
		m[3] = tmp;
		tmp = m[2];
		m[2] = m[6];
		m[6] = tmp;
		tmp = m[5];
		m[5] = m[7];
		m[7] = tmp;
		return this;
	}

	setFromMat4(m) {
		const src = m.data;
		const dst = this.data;
		dst[0] = src[0];
		dst[1] = src[1];
		dst[2] = src[2];
		dst[3] = src[4];
		dst[4] = src[5];
		dst[5] = src[6];
		dst[6] = src[8];
		dst[7] = src[9];
		dst[8] = src[10];
		return this;
	}

	transformVector(vec, res = new Vec3()) {
		const m = this.data;
		const x = vec.x;
		const y = vec.y;
		const z = vec.z;
		res.x = x * m[0] + y * m[3] + z * m[6];
		res.y = x * m[1] + y * m[4] + z * m[7];
		res.z = x * m[2] + y * m[5] + z * m[8];
		return res;
	}

}

Mat3.IDENTITY = Object.freeze(new Mat3());
Mat3.ZERO = Object.freeze(new Mat3().set([0, 0, 0, 0, 0, 0, 0, 0, 0]));

class Vec2 {
	constructor(x = 0, y = 0) {
		if (x.length === 2) {
			this.x = x[0];
			this.y = x[1];
		} else {
			this.x = x;
			this.y = y;
		}
	}

	add(rhs) {
		this.x += rhs.x;
		this.y += rhs.y;
		return this;
	}

	add2(lhs, rhs) {
		this.x = lhs.x + rhs.x;
		this.y = lhs.y + rhs.y;
		return this;
	}

	addScalar(scalar) {
		this.x += scalar;
		this.y += scalar;
		return this;
	}

	clone() {
		return new Vec2(this.x, this.y);
	}

	copy(rhs) {
		this.x = rhs.x;
		this.y = rhs.y;
		return this;
	}

	cross(rhs) {
		return this.x * rhs.y - this.y * rhs.x;
	}

	distance(rhs) {
		const x = this.x - rhs.x;
		const y = this.y - rhs.y;
		return Math.sqrt(x * x + y * y);
	}

	div(rhs) {
		this.x /= rhs.x;
		this.y /= rhs.y;
		return this;
	}

	div2(lhs, rhs) {
		this.x = lhs.x / rhs.x;
		this.y = lhs.y / rhs.y;
		return this;
	}

	divScalar(scalar) {
		this.x /= scalar;
		this.y /= scalar;
		return this;
	}

	dot(rhs) {
		return this.x * rhs.x + this.y * rhs.y;
	}

	equals(rhs) {
		return this.x === rhs.x && this.y === rhs.y;
	}

	length() {
		return Math.sqrt(this.x * this.x + this.y * this.y);
	}

	lengthSq() {
		return this.x * this.x + this.y * this.y;
	}

	lerp(lhs, rhs, alpha) {
		this.x = lhs.x + alpha * (rhs.x - lhs.x);
		this.y = lhs.y + alpha * (rhs.y - lhs.y);
		return this;
	}

	mul(rhs) {
		this.x *= rhs.x;
		this.y *= rhs.y;
		return this;
	}

	mul2(lhs, rhs) {
		this.x = lhs.x * rhs.x;
		this.y = lhs.y * rhs.y;
		return this;
	}

	mulScalar(scalar) {
		this.x *= scalar;
		this.y *= scalar;
		return this;
	}

	normalize() {
		const lengthSq = this.x * this.x + this.y * this.y;

		if (lengthSq > 0) {
			const invLength = 1 / Math.sqrt(lengthSq);
			this.x *= invLength;
			this.y *= invLength;
		}

		return this;
	}

	floor() {
		this.x = Math.floor(this.x);
		this.y = Math.floor(this.y);
		return this;
	}

	ceil() {
		this.x = Math.ceil(this.x);
		this.y = Math.ceil(this.y);
		return this;
	}

	round() {
		this.x = Math.round(this.x);
		this.y = Math.round(this.y);
		return this;
	}

	min(rhs) {
		if (rhs.x < this.x) this.x = rhs.x;
		if (rhs.y < this.y) this.y = rhs.y;
		return this;
	}

	max(rhs) {
		if (rhs.x > this.x) this.x = rhs.x;
		if (rhs.y > this.y) this.y = rhs.y;
		return this;
	}

	set(x, y) {
		this.x = x;
		this.y = y;
		return this;
	}

	sub(rhs) {
		this.x -= rhs.x;
		this.y -= rhs.y;
		return this;
	}

	sub2(lhs, rhs) {
		this.x = lhs.x - rhs.x;
		this.y = lhs.y - rhs.y;
		return this;
	}

	subScalar(scalar) {
		this.x -= scalar;
		this.y -= scalar;
		return this;
	}

	toString() {
		return `[${this.x}, ${this.y}]`;
	}

	static angleRad(lhs, rhs) {
		return Math.atan2(lhs.x * rhs.y - lhs.y * rhs.x, lhs.x * rhs.x + lhs.y * rhs.y);
	}

}

Vec2.ZERO = Object.freeze(new Vec2(0, 0));
Vec2.ONE = Object.freeze(new Vec2(1, 1));
Vec2.UP = Object.freeze(new Vec2(0, 1));
Vec2.DOWN = Object.freeze(new Vec2(0, -1));
Vec2.RIGHT = Object.freeze(new Vec2(1, 0));
Vec2.LEFT = Object.freeze(new Vec2(-1, 0));

class Vec4 {
	constructor(x = 0, y = 0, z = 0, w = 0) {
		if (x.length === 4) {
			this.x = x[0];
			this.y = x[1];
			this.z = x[2];
			this.w = x[3];
		} else {
			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;
		}
	}

	add(rhs) {
		this.x += rhs.x;
		this.y += rhs.y;
		this.z += rhs.z;
		this.w += rhs.w;
		return this;
	}

	add2(lhs, rhs) {
		this.x = lhs.x + rhs.x;
		this.y = lhs.y + rhs.y;
		this.z = lhs.z + rhs.z;
		this.w = lhs.w + rhs.w;
		return this;
	}

	addScalar(scalar) {
		this.x += scalar;
		this.y += scalar;
		this.z += scalar;
		this.w += scalar;
		return this;
	}

	clone() {
		return new Vec4(this.x, this.y, this.z, this.w);
	}

	copy(rhs) {
		this.x = rhs.x;
		this.y = rhs.y;
		this.z = rhs.z;
		this.w = rhs.w;
		return this;
	}

	div(rhs) {
		this.x /= rhs.x;
		this.y /= rhs.y;
		this.z /= rhs.z;
		this.w /= rhs.w;
		return this;
	}

	div2(lhs, rhs) {
		this.x = lhs.x / rhs.x;
		this.y = lhs.y / rhs.y;
		this.z = lhs.z / rhs.z;
		this.w = lhs.w / rhs.w;
		return this;
	}

	divScalar(scalar) {
		this.x /= scalar;
		this.y /= scalar;
		this.z /= scalar;
		this.w /= scalar;
		return this;
	}

	dot(rhs) {
		return this.x * rhs.x + this.y * rhs.y + this.z * rhs.z + this.w * rhs.w;
	}

	equals(rhs) {
		return this.x === rhs.x && this.y === rhs.y && this.z === rhs.z && this.w === rhs.w;
	}

	length() {
		return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
	}

	lengthSq() {
		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
	}

	lerp(lhs, rhs, alpha) {
		this.x = lhs.x + alpha * (rhs.x - lhs.x);
		this.y = lhs.y + alpha * (rhs.y - lhs.y);
		this.z = lhs.z + alpha * (rhs.z - lhs.z);
		this.w = lhs.w + alpha * (rhs.w - lhs.w);
		return this;
	}

	mul(rhs) {
		this.x *= rhs.x;
		this.y *= rhs.y;
		this.z *= rhs.z;
		this.w *= rhs.w;
		return this;
	}

	mul2(lhs, rhs) {
		this.x = lhs.x * rhs.x;
		this.y = lhs.y * rhs.y;
		this.z = lhs.z * rhs.z;
		this.w = lhs.w * rhs.w;
		return this;
	}

	mulScalar(scalar) {
		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;
		this.w *= scalar;
		return this;
	}

	normalize() {
		const lengthSq = this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

		if (lengthSq > 0) {
			const invLength = 1 / Math.sqrt(lengthSq);
			this.x *= invLength;
			this.y *= invLength;
			this.z *= invLength;
			this.w *= invLength;
		}

		return this;
	}

	floor() {
		this.x = Math.floor(this.x);
		this.y = Math.floor(this.y);
		this.z = Math.floor(this.z);
		this.w = Math.floor(this.w);
		return this;
	}

	ceil() {
		this.x = Math.ceil(this.x);
		this.y = Math.ceil(this.y);
		this.z = Math.ceil(this.z);
		this.w = Math.ceil(this.w);
		return this;
	}

	round() {
		this.x = Math.round(this.x);
		this.y = Math.round(this.y);
		this.z = Math.round(this.z);
		this.w = Math.round(this.w);
		return this;
	}

	min(rhs) {
		if (rhs.x < this.x) this.x = rhs.x;
		if (rhs.y < this.y) this.y = rhs.y;
		if (rhs.z < this.z) this.z = rhs.z;
		if (rhs.w < this.w) this.w = rhs.w;
		return this;
	}

	max(rhs) {
		if (rhs.x > this.x) this.x = rhs.x;
		if (rhs.y > this.y) this.y = rhs.y;
		if (rhs.z > this.z) this.z = rhs.z;
		if (rhs.w > this.w) this.w = rhs.w;
		return this;
	}

	set(x, y, z, w) {
		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;
		return this;
	}

	sub(rhs) {
		this.x -= rhs.x;
		this.y -= rhs.y;
		this.z -= rhs.z;
		this.w -= rhs.w;
		return this;
	}

	sub2(lhs, rhs) {
		this.x = lhs.x - rhs.x;
		this.y = lhs.y - rhs.y;
		this.z = lhs.z - rhs.z;
		this.w = lhs.w - rhs.w;
		return this;
	}

	subScalar(scalar) {
		this.x -= scalar;
		this.y -= scalar;
		this.z -= scalar;
		this.w -= scalar;
		return this;
	}

	toString() {
		return `[${this.x}, ${this.y}, ${this.z}, ${this.w}]`;
	}

}

Vec4.ZERO = Object.freeze(new Vec4(0, 0, 0, 0));
Vec4.ONE = Object.freeze(new Vec4(1, 1, 1, 1));

const _halfSize$1 = new Vec2();

const x = new Vec3();
const y = new Vec3();
const z = new Vec3();
const scale = new Vec3();

class Mat4 {
	constructor() {
		const data = new Float32Array(16);
		data[0] = data[5] = data[10] = data[15] = 1;
		this.data = data;
	}

	static _getPerspectiveHalfSize(halfSize, fov, aspect, znear, fovIsHorizontal) {
		if (fovIsHorizontal) {
			halfSize.x = znear * Math.tan(fov * Math.PI / 360);
			halfSize.y = halfSize.x / aspect;
		} else {
			halfSize.y = znear * Math.tan(fov * Math.PI / 360);
			halfSize.x = halfSize.y * aspect;
		}
	}

	add2(lhs, rhs) {
		const a = lhs.data,
					b = rhs.data,
					r = this.data;
		r[0] = a[0] + b[0];
		r[1] = a[1] + b[1];
		r[2] = a[2] + b[2];
		r[3] = a[3] + b[3];
		r[4] = a[4] + b[4];
		r[5] = a[5] + b[5];
		r[6] = a[6] + b[6];
		r[7] = a[7] + b[7];
		r[8] = a[8] + b[8];
		r[9] = a[9] + b[9];
		r[10] = a[10] + b[10];
		r[11] = a[11] + b[11];
		r[12] = a[12] + b[12];
		r[13] = a[13] + b[13];
		r[14] = a[14] + b[14];
		r[15] = a[15] + b[15];
		return this;
	}

	add(rhs) {
		return this.add2(this, rhs);
	}

	clone() {
		return new Mat4().copy(this);
	}

	copy(rhs) {
		const src = rhs.data,
					dst = this.data;
		dst[0] = src[0];
		dst[1] = src[1];
		dst[2] = src[2];
		dst[3] = src[3];
		dst[4] = src[4];
		dst[5] = src[5];
		dst[6] = src[6];
		dst[7] = src[7];
		dst[8] = src[8];
		dst[9] = src[9];
		dst[10] = src[10];
		dst[11] = src[11];
		dst[12] = src[12];
		dst[13] = src[13];
		dst[14] = src[14];
		dst[15] = src[15];
		return this;
	}

	equals(rhs) {
		const l = this.data,
					r = rhs.data;
		return l[0] === r[0] && l[1] === r[1] && l[2] === r[2] && l[3] === r[3] && l[4] === r[4] && l[5] === r[5] && l[6] === r[6] && l[7] === r[7] && l[8] === r[8] && l[9] === r[9] && l[10] === r[10] && l[11] === r[11] && l[12] === r[12] && l[13] === r[13] && l[14] === r[14] && l[15] === r[15];
	}

	isIdentity() {
		const m = this.data;
		return m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 0 && m[4] === 0 && m[5] === 1 && m[6] === 0 && m[7] === 0 && m[8] === 0 && m[9] === 0 && m[10] === 1 && m[11] === 0 && m[12] === 0 && m[13] === 0 && m[14] === 0 && m[15] === 1;
	}

	mul2(lhs, rhs) {
		const a = lhs.data;
		const b = rhs.data;
		const r = this.data;
		const a00 = a[0];
		const a01 = a[1];
		const a02 = a[2];
		const a03 = a[3];
		const a10 = a[4];
		const a11 = a[5];
		const a12 = a[6];
		const a13 = a[7];
		const a20 = a[8];
		const a21 = a[9];
		const a22 = a[10];
		const a23 = a[11];
		const a30 = a[12];
		const a31 = a[13];
		const a32 = a[14];
		const a33 = a[15];
		let b0, b1, b2, b3;
		b0 = b[0];
		b1 = b[1];
		b2 = b[2];
		b3 = b[3];
		r[0] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
		r[1] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
		r[2] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
		r[3] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;
		b0 = b[4];
		b1 = b[5];
		b2 = b[6];
		b3 = b[7];
		r[4] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
		r[5] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
		r[6] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
		r[7] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;
		b0 = b[8];
		b1 = b[9];
		b2 = b[10];
		b3 = b[11];
		r[8] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
		r[9] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
		r[10] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
		r[11] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;
		b0 = b[12];
		b1 = b[13];
		b2 = b[14];
		b3 = b[15];
		r[12] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
		r[13] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
		r[14] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
		r[15] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;
		return this;
	}

	mulAffine2(lhs, rhs) {
		const a = lhs.data;
		const b = rhs.data;
		const r = this.data;
		const a00 = a[0];
		const a01 = a[1];
		const a02 = a[2];
		const a10 = a[4];
		const a11 = a[5];
		const a12 = a[6];
		const a20 = a[8];
		const a21 = a[9];
		const a22 = a[10];
		const a30 = a[12];
		const a31 = a[13];
		const a32 = a[14];
		let b0, b1, b2;
		b0 = b[0];
		b1 = b[1];
		b2 = b[2];
		r[0] = a00 * b0 + a10 * b1 + a20 * b2;
		r[1] = a01 * b0 + a11 * b1 + a21 * b2;
		r[2] = a02 * b0 + a12 * b1 + a22 * b2;
		r[3] = 0;
		b0 = b[4];
		b1 = b[5];
		b2 = b[6];
		r[4] = a00 * b0 + a10 * b1 + a20 * b2;
		r[5] = a01 * b0 + a11 * b1 + a21 * b2;
		r[6] = a02 * b0 + a12 * b1 + a22 * b2;
		r[7] = 0;
		b0 = b[8];
		b1 = b[9];
		b2 = b[10];
		r[8] = a00 * b0 + a10 * b1 + a20 * b2;
		r[9] = a01 * b0 + a11 * b1 + a21 * b2;
		r[10] = a02 * b0 + a12 * b1 + a22 * b2;
		r[11] = 0;
		b0 = b[12];
		b1 = b[13];
		b2 = b[14];
		r[12] = a00 * b0 + a10 * b1 + a20 * b2 + a30;
		r[13] = a01 * b0 + a11 * b1 + a21 * b2 + a31;
		r[14] = a02 * b0 + a12 * b1 + a22 * b2 + a32;
		r[15] = 1;
		return this;
	}

	mul(rhs) {
		return this.mul2(this, rhs);
	}

	transformPoint(vec, res = new Vec3()) {
		const m = this.data;
		const x = vec.x;
		const y = vec.y;
		const z = vec.z;
		res.x = x * m[0] + y * m[4] + z * m[8] + m[12];
		res.y = x * m[1] + y * m[5] + z * m[9] + m[13];
		res.z = x * m[2] + y * m[6] + z * m[10] + m[14];
		return res;
	}

	transformVector(vec, res = new Vec3()) {
		const m = this.data;
		const x = vec.x;
		const y = vec.y;
		const z = vec.z;
		res.x = x * m[0] + y * m[4] + z * m[8];
		res.y = x * m[1] + y * m[5] + z * m[9];
		res.z = x * m[2] + y * m[6] + z * m[10];
		return res;
	}

	transformVec4(vec, res = new Vec4()) {
		const m = this.data;
		const x = vec.x;
		const y = vec.y;
		const z = vec.z;
		const w = vec.w;
		res.x = x * m[0] + y * m[4] + z * m[8] + w * m[12];
		res.y = x * m[1] + y * m[5] + z * m[9] + w * m[13];
		res.z = x * m[2] + y * m[6] + z * m[10] + w * m[14];
		res.w = x * m[3] + y * m[7] + z * m[11] + w * m[15];
		return res;
	}

	setLookAt(position, target, up) {
		z.sub2(position, target).normalize();
		y.copy(up).normalize();
		x.cross(y, z).normalize();
		y.cross(z, x);
		const r = this.data;
		r[0] = x.x;
		r[1] = x.y;
		r[2] = x.z;
		r[3] = 0;
		r[4] = y.x;
		r[5] = y.y;
		r[6] = y.z;
		r[7] = 0;
		r[8] = z.x;
		r[9] = z.y;
		r[10] = z.z;
		r[11] = 0;
		r[12] = position.x;
		r[13] = position.y;
		r[14] = position.z;
		r[15] = 1;
		return this;
	}

	setFrustum(left, right, bottom, top, znear, zfar) {
		const temp1 = 2 * znear;
		const temp2 = right - left;
		const temp3 = top - bottom;
		const temp4 = zfar - znear;
		const r = this.data;
		r[0] = temp1 / temp2;
		r[1] = 0;
		r[2] = 0;
		r[3] = 0;
		r[4] = 0;
		r[5] = temp1 / temp3;
		r[6] = 0;
		r[7] = 0;
		r[8] = (right + left) / temp2;
		r[9] = (top + bottom) / temp3;
		r[10] = (-zfar - znear) / temp4;
		r[11] = -1;
		r[12] = 0;
		r[13] = 0;
		r[14] = -temp1 * zfar / temp4;
		r[15] = 0;
		return this;
	}

	setPerspective(fov, aspect, znear, zfar, fovIsHorizontal) {
		Mat4._getPerspectiveHalfSize(_halfSize$1, fov, aspect, znear, fovIsHorizontal);

		return this.setFrustum(-_halfSize$1.x, _halfSize$1.x, -_halfSize$1.y, _halfSize$1.y, znear, zfar);
	}

	setOrtho(left, right, bottom, top, near, far) {
		const r = this.data;
		r[0] = 2 / (right - left);
		r[1] = 0;
		r[2] = 0;
		r[3] = 0;
		r[4] = 0;
		r[5] = 2 / (top - bottom);
		r[6] = 0;
		r[7] = 0;
		r[8] = 0;
		r[9] = 0;
		r[10] = -2 / (far - near);
		r[11] = 0;
		r[12] = -(right + left) / (right - left);
		r[13] = -(top + bottom) / (top - bottom);
		r[14] = -(far + near) / (far - near);
		r[15] = 1;
		return this;
	}

	setFromAxisAngle(axis, angle) {
		angle *= math.DEG_TO_RAD;
		const x = axis.x;
		const y = axis.y;
		const z = axis.z;
		const c = Math.cos(angle);
		const s = Math.sin(angle);
		const t = 1 - c;
		const tx = t * x;
		const ty = t * y;
		const m = this.data;
		m[0] = tx * x + c;
		m[1] = tx * y + s * z;
		m[2] = tx * z - s * y;
		m[3] = 0;
		m[4] = tx * y - s * z;
		m[5] = ty * y + c;
		m[6] = ty * z + s * x;
		m[7] = 0;
		m[8] = tx * z + s * y;
		m[9] = ty * z - x * s;
		m[10] = t * z * z + c;
		m[11] = 0;
		m[12] = 0;
		m[13] = 0;
		m[14] = 0;
		m[15] = 1;
		return this;
	}

	setTranslate(x, y, z) {
		const m = this.data;
		m[0] = 1;
		m[1] = 0;
		m[2] = 0;
		m[3] = 0;
		m[4] = 0;
		m[5] = 1;
		m[6] = 0;
		m[7] = 0;
		m[8] = 0;
		m[9] = 0;
		m[10] = 1;
		m[11] = 0;
		m[12] = x;
		m[13] = y;
		m[14] = z;
		m[15] = 1;
		return this;
	}

	setScale(x, y, z) {
		const m = this.data;
		m[0] = x;
		m[1] = 0;
		m[2] = 0;
		m[3] = 0;
		m[4] = 0;
		m[5] = y;
		m[6] = 0;
		m[7] = 0;
		m[8] = 0;
		m[9] = 0;
		m[10] = z;
		m[11] = 0;
		m[12] = 0;
		m[13] = 0;
		m[14] = 0;
		m[15] = 1;
		return this;
	}

	setViewport(x, y, width, height) {
		const m = this.data;
		m[0] = width * 0.5;
		m[1] = 0;
		m[2] = 0;
		m[3] = 0;
		m[4] = 0;
		m[5] = height * 0.5;
		m[6] = 0;
		m[7] = 0;
		m[8] = 0;
		m[9] = 0;
		m[10] = 0.5;
		m[11] = 0;
		m[12] = x + width * 0.5;
		m[13] = y + height * 0.5;
		m[14] = 0.5;
		m[15] = 1;
		return this;
	}

	invert() {
		const m = this.data;
		const a00 = m[0];
		const a01 = m[1];
		const a02 = m[2];
		const a03 = m[3];
		const a10 = m[4];
		const a11 = m[5];
		const a12 = m[6];
		const a13 = m[7];
		const a20 = m[8];
		const a21 = m[9];
		const a22 = m[10];
		const a23 = m[11];
		const a30 = m[12];
		const a31 = m[13];
		const a32 = m[14];
		const a33 = m[15];
		const b00 = a00 * a11 - a01 * a10;
		const b01 = a00 * a12 - a02 * a10;
		const b02 = a00 * a13 - a03 * a10;
		const b03 = a01 * a12 - a02 * a11;
		const b04 = a01 * a13 - a03 * a11;
		const b05 = a02 * a13 - a03 * a12;
		const b06 = a20 * a31 - a21 * a30;
		const b07 = a20 * a32 - a22 * a30;
		const b08 = a20 * a33 - a23 * a30;
		const b09 = a21 * a32 - a22 * a31;
		const b10 = a21 * a33 - a23 * a31;
		const b11 = a22 * a33 - a23 * a32;
		const det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

		if (det === 0) {
			this.setIdentity();
		} else {
			const invDet = 1 / det;
			m[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;
			m[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;
			m[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;
			m[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;
			m[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * invDet;
			m[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;
			m[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * invDet;
			m[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;
			m[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;
			m[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;
			m[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;
			m[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;
			m[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet;
			m[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;
			m[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet;
			m[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;
		}

		return this;
	}

	set(src) {
		const dst = this.data;
		dst[0] = src[0];
		dst[1] = src[1];
		dst[2] = src[2];
		dst[3] = src[3];
		dst[4] = src[4];
		dst[5] = src[5];
		dst[6] = src[6];
		dst[7] = src[7];
		dst[8] = src[8];
		dst[9] = src[9];
		dst[10] = src[10];
		dst[11] = src[11];
		dst[12] = src[12];
		dst[13] = src[13];
		dst[14] = src[14];
		dst[15] = src[15];
		return this;
	}

	setIdentity() {
		const m = this.data;
		m[0] = 1;
		m[1] = 0;
		m[2] = 0;
		m[3] = 0;
		m[4] = 0;
		m[5] = 1;
		m[6] = 0;
		m[7] = 0;
		m[8] = 0;
		m[9] = 0;
		m[10] = 1;
		m[11] = 0;
		m[12] = 0;
		m[13] = 0;
		m[14] = 0;
		m[15] = 1;
		return this;
	}

	setTRS(t, r, s) {
		const qx = r.x;
		const qy = r.y;
		const qz = r.z;
		const qw = r.w;
		const sx = s.x;
		const sy = s.y;
		const sz = s.z;
		const x2 = qx + qx;
		const y2 = qy + qy;
		const z2 = qz + qz;
		const xx = qx * x2;
		const xy = qx * y2;
		const xz = qx * z2;
		const yy = qy * y2;
		const yz = qy * z2;
		const zz = qz * z2;
		const wx = qw * x2;
		const wy = qw * y2;
		const wz = qw * z2;
		const m = this.data;
		m[0] = (1 - (yy + zz)) * sx;
		m[1] = (xy + wz) * sx;
		m[2] = (xz - wy) * sx;
		m[3] = 0;
		m[4] = (xy - wz) * sy;
		m[5] = (1 - (xx + zz)) * sy;
		m[6] = (yz + wx) * sy;
		m[7] = 0;
		m[8] = (xz + wy) * sz;
		m[9] = (yz - wx) * sz;
		m[10] = (1 - (xx + yy)) * sz;
		m[11] = 0;
		m[12] = t.x;
		m[13] = t.y;
		m[14] = t.z;
		m[15] = 1;
		return this;
	}

	transpose() {
		let tmp;
		const m = this.data;
		tmp = m[1];
		m[1] = m[4];
		m[4] = tmp;
		tmp = m[2];
		m[2] = m[8];
		m[8] = tmp;
		tmp = m[3];
		m[3] = m[12];
		m[12] = tmp;
		tmp = m[6];
		m[6] = m[9];
		m[9] = tmp;
		tmp = m[7];
		m[7] = m[13];
		m[13] = tmp;
		tmp = m[11];
		m[11] = m[14];
		m[14] = tmp;
		return this;
	}

	invertTo3x3(res) {
		const m = this.data;
		const r = res.data;
		const m0 = m[0];
		const m1 = m[1];
		const m2 = m[2];
		const m4 = m[4];
		const m5 = m[5];
		const m6 = m[6];
		const m8 = m[8];
		const m9 = m[9];
		const m10 = m[10];
		const a11 = m10 * m5 - m6 * m9;
		const a21 = -m10 * m1 + m2 * m9;
		const a31 = m6 * m1 - m2 * m5;
		const a12 = -m10 * m4 + m6 * m8;
		const a22 = m10 * m0 - m2 * m8;
		const a32 = -m6 * m0 + m2 * m4;
		const a13 = m9 * m4 - m5 * m8;
		const a23 = -m9 * m0 + m1 * m8;
		const a33 = m5 * m0 - m1 * m4;
		const det = m0 * a11 + m1 * a12 + m2 * a13;

		if (det === 0) {
			return this;
		}

		const idet = 1 / det;
		r[0] = idet * a11;
		r[1] = idet * a21;
		r[2] = idet * a31;
		r[3] = idet * a12;
		r[4] = idet * a22;
		r[5] = idet * a32;
		r[6] = idet * a13;
		r[7] = idet * a23;
		r[8] = idet * a33;
		return this;
	}

	getTranslation(t = new Vec3()) {
		return t.set(this.data[12], this.data[13], this.data[14]);
	}

	getX(x = new Vec3()) {
		return x.set(this.data[0], this.data[1], this.data[2]);
	}

	getY(y = new Vec3()) {
		return y.set(this.data[4], this.data[5], this.data[6]);
	}

	getZ(z = new Vec3()) {
		return z.set(this.data[8], this.data[9], this.data[10]);
	}

	getScale(scale = new Vec3()) {
		this.getX(x);
		this.getY(y);
		this.getZ(z);
		scale.set(x.length(), y.length(), z.length());
		return scale;
	}

	setFromEulerAngles(ex, ey, ez) {
		ex *= math.DEG_TO_RAD;
		ey *= math.DEG_TO_RAD;
		ez *= math.DEG_TO_RAD;
		const s1 = Math.sin(-ex);
		const c1 = Math.cos(-ex);
		const s2 = Math.sin(-ey);
		const c2 = Math.cos(-ey);
		const s3 = Math.sin(-ez);
		const c3 = Math.cos(-ez);
		const m = this.data;
		m[0] = c2 * c3;
		m[1] = -c2 * s3;
		m[2] = s2;
		m[3] = 0;
		m[4] = c1 * s3 + c3 * s1 * s2;
		m[5] = c1 * c3 - s1 * s2 * s3;
		m[6] = -c2 * s1;
		m[7] = 0;
		m[8] = s1 * s3 - c1 * c3 * s2;
		m[9] = c3 * s1 + c1 * s2 * s3;
		m[10] = c1 * c2;
		m[11] = 0;
		m[12] = 0;
		m[13] = 0;
		m[14] = 0;
		m[15] = 1;
		return this;
	}

	getEulerAngles(eulers = new Vec3()) {
		this.getScale(scale);
		const sx = scale.x;
		const sy = scale.y;
		const sz = scale.z;
		if (sx === 0 || sy === 0 || sz === 0) return eulers.set(0, 0, 0);
		const m = this.data;
		const y = Math.asin(-m[2] / sx);
		const halfPi = Math.PI * 0.5;
		let x, z;

		if (y < halfPi) {
			if (y > -halfPi) {
				x = Math.atan2(m[6] / sy, m[10] / sz);
				z = Math.atan2(m[1] / sx, m[0] / sx);
			} else {
				z = 0;
				x = -Math.atan2(m[4] / sy, m[5] / sy);
			}
		} else {
			z = 0;
			x = Math.atan2(m[4] / sy, m[5] / sy);
		}

		return eulers.set(x, y, z).mulScalar(math.RAD_TO_DEG);
	}

	toString() {
		let t = '[';

		for (let i = 0; i < 16; i += 1) {
			t += this.data[i];
			t += i !== 15 ? ', ' : '';
		}

		t += ']';
		return t;
	}

}

Mat4.IDENTITY = Object.freeze(new Mat4());
Mat4.ZERO = Object.freeze(new Mat4().set([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]));

class Quat {
	constructor(x = 0, y = 0, z = 0, w = 1) {
		if (x.length === 4) {
			this.x = x[0];
			this.y = x[1];
			this.z = x[2];
			this.w = x[3];
		} else {
			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;
		}
	}

	clone() {
		return new Quat(this.x, this.y, this.z, this.w);
	}

	conjugate() {
		this.x *= -1;
		this.y *= -1;
		this.z *= -1;
		return this;
	}

	copy(rhs) {
		this.x = rhs.x;
		this.y = rhs.y;
		this.z = rhs.z;
		this.w = rhs.w;
		return this;
	}

	equals(rhs) {
		return this.x === rhs.x && this.y === rhs.y && this.z === rhs.z && this.w === rhs.w;
	}

	getAxisAngle(axis) {
		let rad = Math.acos(this.w) * 2;
		const s = Math.sin(rad / 2);

		if (s !== 0) {
			axis.x = this.x / s;
			axis.y = this.y / s;
			axis.z = this.z / s;

			if (axis.x < 0 || axis.y < 0 || axis.z < 0) {
				axis.x *= -1;
				axis.y *= -1;
				axis.z *= -1;
				rad *= -1;
			}
		} else {
			axis.x = 1;
			axis.y = 0;
			axis.z = 0;
		}

		return rad * math.RAD_TO_DEG;
	}

	getEulerAngles(eulers = new Vec3()) {
		let x, y, z;
		const qx = this.x;
		const qy = this.y;
		const qz = this.z;
		const qw = this.w;
		const a2 = 2 * (qw * qy - qx * qz);

		if (a2 <= -0.99999) {
			x = 2 * Math.atan2(qx, qw);
			y = -Math.PI / 2;
			z = 0;
		} else if (a2 >= 0.99999) {
			x = 2 * Math.atan2(qx, qw);
			y = Math.PI / 2;
			z = 0;
		} else {
			x = Math.atan2(2 * (qw * qx + qy * qz), 1 - 2 * (qx * qx + qy * qy));
			y = Math.asin(a2);
			z = Math.atan2(2 * (qw * qz + qx * qy), 1 - 2 * (qy * qy + qz * qz));
		}

		return eulers.set(x, y, z).mulScalar(math.RAD_TO_DEG);
	}

	invert() {
		return this.conjugate().normalize();
	}

	length() {
		return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
	}

	lengthSq() {
		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
	}

	mul(rhs) {
		const q1x = this.x;
		const q1y = this.y;
		const q1z = this.z;
		const q1w = this.w;
		const q2x = rhs.x;
		const q2y = rhs.y;
		const q2z = rhs.z;
		const q2w = rhs.w;
		this.x = q1w * q2x + q1x * q2w + q1y * q2z - q1z * q2y;
		this.y = q1w * q2y + q1y * q2w + q1z * q2x - q1x * q2z;
		this.z = q1w * q2z + q1z * q2w + q1x * q2y - q1y * q2x;
		this.w = q1w * q2w - q1x * q2x - q1y * q2y - q1z * q2z;
		return this;
	}

	mul2(lhs, rhs) {
		const q1x = lhs.x;
		const q1y = lhs.y;
		const q1z = lhs.z;
		const q1w = lhs.w;
		const q2x = rhs.x;
		const q2y = rhs.y;
		const q2z = rhs.z;
		const q2w = rhs.w;
		this.x = q1w * q2x + q1x * q2w + q1y * q2z - q1z * q2y;
		this.y = q1w * q2y + q1y * q2w + q1z * q2x - q1x * q2z;
		this.z = q1w * q2z + q1z * q2w + q1x * q2y - q1y * q2x;
		this.w = q1w * q2w - q1x * q2x - q1y * q2y - q1z * q2z;
		return this;
	}

	normalize() {
		let len = this.length();

		if (len === 0) {
			this.x = this.y = this.z = 0;
			this.w = 1;
		} else {
			len = 1 / len;
			this.x *= len;
			this.y *= len;
			this.z *= len;
			this.w *= len;
		}

		return this;
	}

	set(x, y, z, w) {
		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;
		return this;
	}

	setFromAxisAngle(axis, angle) {
		angle *= 0.5 * math.DEG_TO_RAD;
		const sa = Math.sin(angle);
		const ca = Math.cos(angle);
		this.x = sa * axis.x;
		this.y = sa * axis.y;
		this.z = sa * axis.z;
		this.w = ca;
		return this;
	}

	setFromEulerAngles(ex, ey, ez) {
		const halfToRad = 0.5 * math.DEG_TO_RAD;
		ex *= halfToRad;
		ey *= halfToRad;
		ez *= halfToRad;
		const sx = Math.sin(ex);
		const cx = Math.cos(ex);
		const sy = Math.sin(ey);
		const cy = Math.cos(ey);
		const sz = Math.sin(ez);
		const cz = Math.cos(ez);
		this.x = sx * cy * cz - cx * sy * sz;
		this.y = cx * sy * cz + sx * cy * sz;
		this.z = cx * cy * sz - sx * sy * cz;
		this.w = cx * cy * cz + sx * sy * sz;
		return this;
	}

	setFromMat4(m) {
		let m00, m01, m02, m10, m11, m12, m20, m21, m22, s, rs, lx, ly, lz;
		m = m.data;
		m00 = m[0];
		m01 = m[1];
		m02 = m[2];
		m10 = m[4];
		m11 = m[5];
		m12 = m[6];
		m20 = m[8];
		m21 = m[9];
		m22 = m[10];
		lx = m00 * m00 + m01 * m01 + m02 * m02;
		if (lx === 0) return this;
		lx = 1 / Math.sqrt(lx);
		ly = m10 * m10 + m11 * m11 + m12 * m12;
		if (ly === 0) return this;
		ly = 1 / Math.sqrt(ly);
		lz = m20 * m20 + m21 * m21 + m22 * m22;
		if (lz === 0) return this;
		lz = 1 / Math.sqrt(lz);
		m00 *= lx;
		m01 *= lx;
		m02 *= lx;
		m10 *= ly;
		m11 *= ly;
		m12 *= ly;
		m20 *= lz;
		m21 *= lz;
		m22 *= lz;
		const tr = m00 + m11 + m22;

		if (tr >= 0) {
			s = Math.sqrt(tr + 1);
			this.w = s * 0.5;
			s = 0.5 / s;
			this.x = (m12 - m21) * s;
			this.y = (m20 - m02) * s;
			this.z = (m01 - m10) * s;
		} else {
			if (m00 > m11) {
				if (m00 > m22) {
					rs = m00 - (m11 + m22) + 1;
					rs = Math.sqrt(rs);
					this.x = rs * 0.5;
					rs = 0.5 / rs;
					this.w = (m12 - m21) * rs;
					this.y = (m01 + m10) * rs;
					this.z = (m02 + m20) * rs;
				} else {
					rs = m22 - (m00 + m11) + 1;
					rs = Math.sqrt(rs);
					this.z = rs * 0.5;
					rs = 0.5 / rs;
					this.w = (m01 - m10) * rs;
					this.x = (m20 + m02) * rs;
					this.y = (m21 + m12) * rs;
				}
			} else if (m11 > m22) {
				rs = m11 - (m22 + m00) + 1;
				rs = Math.sqrt(rs);
				this.y = rs * 0.5;
				rs = 0.5 / rs;
				this.w = (m20 - m02) * rs;
				this.z = (m12 + m21) * rs;
				this.x = (m10 + m01) * rs;
			} else {
				rs = m22 - (m00 + m11) + 1;
				rs = Math.sqrt(rs);
				this.z = rs * 0.5;
				rs = 0.5 / rs;
				this.w = (m01 - m10) * rs;
				this.x = (m20 + m02) * rs;
				this.y = (m21 + m12) * rs;
			}
		}

		return this;
	}

	slerp(lhs, rhs, alpha) {
		const lx = lhs.x;
		const ly = lhs.y;
		const lz = lhs.z;
		const lw = lhs.w;
		let rx = rhs.x;
		let ry = rhs.y;
		let rz = rhs.z;
		let rw = rhs.w;
		let cosHalfTheta = lw * rw + lx * rx + ly * ry + lz * rz;

		if (cosHalfTheta < 0) {
			rw = -rw;
			rx = -rx;
			ry = -ry;
			rz = -rz;
			cosHalfTheta = -cosHalfTheta;
		}

		if (Math.abs(cosHalfTheta) >= 1) {
			this.w = lw;
			this.x = lx;
			this.y = ly;
			this.z = lz;
			return this;
		}

		const halfTheta = Math.acos(cosHalfTheta);
		const sinHalfTheta = Math.sqrt(1 - cosHalfTheta * cosHalfTheta);

		if (Math.abs(sinHalfTheta) < 0.001) {
			this.w = lw * 0.5 + rw * 0.5;
			this.x = lx * 0.5 + rx * 0.5;
			this.y = ly * 0.5 + ry * 0.5;
			this.z = lz * 0.5 + rz * 0.5;
			return this;
		}

		const ratioA = Math.sin((1 - alpha) * halfTheta) / sinHalfTheta;
		const ratioB = Math.sin(alpha * halfTheta) / sinHalfTheta;
		this.w = lw * ratioA + rw * ratioB;
		this.x = lx * ratioA + rx * ratioB;
		this.y = ly * ratioA + ry * ratioB;
		this.z = lz * ratioA + rz * ratioB;
		return this;
	}

	transformVector(vec, res = new Vec3()) {
		const x = vec.x,
					y = vec.y,
					z = vec.z;
		const qx = this.x,
					qy = this.y,
					qz = this.z,
					qw = this.w;
		const ix = qw * x + qy * z - qz * y;
		const iy = qw * y + qz * x - qx * z;
		const iz = qw * z + qx * y - qy * x;
		const iw = -qx * x - qy * y - qz * z;
		res.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
		res.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
		res.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
		return res;
	}

	toString() {
		return `[${this.x}, ${this.y}, ${this.z}, ${this.w}]`;
	}

}

Quat.IDENTITY = Object.freeze(new Quat(0, 0, 0, 1));
Quat.ZERO = Object.freeze(new Quat(0, 0, 0, 0));

const tmpVecA$2 = new Vec3();
const tmpVecB$1 = new Vec3();
const tmpVecC = new Vec3();
const tmpVecD = new Vec3();
const tmpVecE = new Vec3();

class BoundingBox {
	constructor(center = new Vec3(), halfExtents = new Vec3(0.5, 0.5, 0.5)) {
		this.center = center;
		this.halfExtents = halfExtents;
		this._min = new Vec3();
		this._max = new Vec3();
	}

	add(other) {
		const tc = this.center;
		const tcx = tc.x;
		const tcy = tc.y;
		const tcz = tc.z;
		const th = this.halfExtents;
		const thx = th.x;
		const thy = th.y;
		const thz = th.z;
		let tminx = tcx - thx;
		let tmaxx = tcx + thx;
		let tminy = tcy - thy;
		let tmaxy = tcy + thy;
		let tminz = tcz - thz;
		let tmaxz = tcz + thz;
		const oc = other.center;
		const ocx = oc.x;
		const ocy = oc.y;
		const ocz = oc.z;
		const oh = other.halfExtents;
		const ohx = oh.x;
		const ohy = oh.y;
		const ohz = oh.z;
		const ominx = ocx - ohx;
		const omaxx = ocx + ohx;
		const ominy = ocy - ohy;
		const omaxy = ocy + ohy;
		const ominz = ocz - ohz;
		const omaxz = ocz + ohz;
		if (ominx < tminx) tminx = ominx;
		if (omaxx > tmaxx) tmaxx = omaxx;
		if (ominy < tminy) tminy = ominy;
		if (omaxy > tmaxy) tmaxy = omaxy;
		if (ominz < tminz) tminz = ominz;
		if (omaxz > tmaxz) tmaxz = omaxz;
		tc.x = (tminx + tmaxx) * 0.5;
		tc.y = (tminy + tmaxy) * 0.5;
		tc.z = (tminz + tmaxz) * 0.5;
		th.x = (tmaxx - tminx) * 0.5;
		th.y = (tmaxy - tminy) * 0.5;
		th.z = (tmaxz - tminz) * 0.5;
	}

	copy(src) {
		this.center.copy(src.center);
		this.halfExtents.copy(src.halfExtents);
	}

	clone() {
		return new BoundingBox(this.center.clone(), this.halfExtents.clone());
	}

	intersects(other) {
		const aMax = this.getMax();
		const aMin = this.getMin();
		const bMax = other.getMax();
		const bMin = other.getMin();
		return aMin.x <= bMax.x && aMax.x >= bMin.x && aMin.y <= bMax.y && aMax.y >= bMin.y && aMin.z <= bMax.z && aMax.z >= bMin.z;
	}

	_intersectsRay(ray, point) {
		const tMin = tmpVecA$2.copy(this.getMin()).sub(ray.origin);
		const tMax = tmpVecB$1.copy(this.getMax()).sub(ray.origin);
		const dir = ray.direction;

		if (dir.x === 0) {
			tMin.x = tMin.x < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
			tMax.x = tMax.x < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
		} else {
			tMin.x /= dir.x;
			tMax.x /= dir.x;
		}

		if (dir.y === 0) {
			tMin.y = tMin.y < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
			tMax.y = tMax.y < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
		} else {
			tMin.y /= dir.y;
			tMax.y /= dir.y;
		}

		if (dir.z === 0) {
			tMin.z = tMin.z < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
			tMax.z = tMax.z < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
		} else {
			tMin.z /= dir.z;
			tMax.z /= dir.z;
		}

		const realMin = tmpVecC.set(Math.min(tMin.x, tMax.x), Math.min(tMin.y, tMax.y), Math.min(tMin.z, tMax.z));
		const realMax = tmpVecD.set(Math.max(tMin.x, tMax.x), Math.max(tMin.y, tMax.y), Math.max(tMin.z, tMax.z));
		const minMax = Math.min(Math.min(realMax.x, realMax.y), realMax.z);
		const maxMin = Math.max(Math.max(realMin.x, realMin.y), realMin.z);
		const intersects = minMax >= maxMin && maxMin >= 0;
		if (intersects) point.copy(ray.direction).mulScalar(maxMin).add(ray.origin);
		return intersects;
	}

	_fastIntersectsRay(ray) {
		const diff = tmpVecA$2;
		const cross = tmpVecB$1;
		const prod = tmpVecC;
		const absDiff = tmpVecD;
		const absDir = tmpVecE;
		const rayDir = ray.direction;
		diff.sub2(ray.origin, this.center);
		absDiff.set(Math.abs(diff.x), Math.abs(diff.y), Math.abs(diff.z));
		prod.mul2(diff, rayDir);
		if (absDiff.x > this.halfExtents.x && prod.x >= 0) return false;
		if (absDiff.y > this.halfExtents.y && prod.y >= 0) return false;
		if (absDiff.z > this.halfExtents.z && prod.z >= 0) return false;
		absDir.set(Math.abs(rayDir.x), Math.abs(rayDir.y), Math.abs(rayDir.z));
		cross.cross(rayDir, diff);
		cross.set(Math.abs(cross.x), Math.abs(cross.y), Math.abs(cross.z));
		if (cross.x > this.halfExtents.y * absDir.z + this.halfExtents.z * absDir.y) return false;
		if (cross.y > this.halfExtents.x * absDir.z + this.halfExtents.z * absDir.x) return false;
		if (cross.z > this.halfExtents.x * absDir.y + this.halfExtents.y * absDir.x) return false;
		return true;
	}

	intersectsRay(ray, point) {
		if (point) {
			return this._intersectsRay(ray, point);
		}

		return this._fastIntersectsRay(ray);
	}

	setMinMax(min, max) {
		this.center.add2(max, min).mulScalar(0.5);
		this.halfExtents.sub2(max, min).mulScalar(0.5);
	}

	getMin() {
		return this._min.copy(this.center).sub(this.halfExtents);
	}

	getMax() {
		return this._max.copy(this.center).add(this.halfExtents);
	}

	containsPoint(point) {
		const min = this.getMin();
		const max = this.getMax();

		if (point.x < min.x || point.x > max.x || point.y < min.y || point.y > max.y || point.z < min.z || point.z > max.z) {
			return false;
		}

		return true;
	}

	setFromTransformedAabb(aabb, m, ignoreScale = false) {
		const ac = aabb.center;
		const ar = aabb.halfExtents;
		const d = m.data;
		let mx0 = d[0];
		let mx1 = d[4];
		let mx2 = d[8];
		let my0 = d[1];
		let my1 = d[5];
		let my2 = d[9];
		let mz0 = d[2];
		let mz1 = d[6];
		let mz2 = d[10];

		if (ignoreScale) {
			let lengthSq = mx0 * mx0 + mx1 * mx1 + mx2 * mx2;

			if (lengthSq > 0) {
				const invLength = 1 / Math.sqrt(lengthSq);
				mx0 *= invLength;
				mx1 *= invLength;
				mx2 *= invLength;
			}

			lengthSq = my0 * my0 + my1 * my1 + my2 * my2;

			if (lengthSq > 0) {
				const invLength = 1 / Math.sqrt(lengthSq);
				my0 *= invLength;
				my1 *= invLength;
				my2 *= invLength;
			}

			lengthSq = mz0 * mz0 + mz1 * mz1 + mz2 * mz2;

			if (lengthSq > 0) {
				const invLength = 1 / Math.sqrt(lengthSq);
				mz0 *= invLength;
				mz1 *= invLength;
				mz2 *= invLength;
			}
		}

		this.center.set(d[12] + mx0 * ac.x + mx1 * ac.y + mx2 * ac.z, d[13] + my0 * ac.x + my1 * ac.y + my2 * ac.z, d[14] + mz0 * ac.x + mz1 * ac.y + mz2 * ac.z);
		this.halfExtents.set(Math.abs(mx0) * ar.x + Math.abs(mx1) * ar.y + Math.abs(mx2) * ar.z, Math.abs(my0) * ar.x + Math.abs(my1) * ar.y + Math.abs(my2) * ar.z, Math.abs(mz0) * ar.x + Math.abs(mz1) * ar.y + Math.abs(mz2) * ar.z);
	}

	compute(vertices, numVerts) {
		numVerts = numVerts === undefined ? vertices.length / 3 : numVerts;

		if (numVerts > 0) {
			const min = tmpVecA$2.set(vertices[0], vertices[1], vertices[2]);
			const max = tmpVecB$1.set(vertices[0], vertices[1], vertices[2]);

			for (let i = 1; i < numVerts; i++) {
				const x = vertices[i * 3 + 0];
				const y = vertices[i * 3 + 1];
				const z = vertices[i * 3 + 2];
				if (x < min.x) min.x = x;
				if (y < min.y) min.y = y;
				if (z < min.z) min.z = z;
				if (x > max.x) max.x = x;
				if (y > max.y) max.y = y;
				if (z > max.z) max.z = z;
			}

			this.setMinMax(min, max);
		}
	}

	intersectsBoundingSphere(sphere) {
		const sq = this._distanceToBoundingSphereSq(sphere);

		if (sq <= sphere.radius * sphere.radius) {
			return true;
		}

		return false;
	}

	_distanceToBoundingSphereSq(sphere) {
		const boxMin = this.getMin();
		const boxMax = this.getMax();
		let sq = 0;
		const axis = ['x', 'y', 'z'];

		for (let i = 0; i < 3; ++i) {
			let out = 0;
			const pn = sphere.center[axis[i]];
			const bMin = boxMin[axis[i]];
			const bMax = boxMax[axis[i]];
			let val = 0;

			if (pn < bMin) {
				val = bMin - pn;
				out += val * val;
			}

			if (pn > bMax) {
				val = pn - bMax;
				out += val * val;
			}

			sq += out;
		}

		return sq;
	}

	_expand(expandMin, expandMax) {
		tmpVecA$2.add2(this.getMin(), expandMin);
		tmpVecB$1.add2(this.getMax(), expandMax);
		this.setMinMax(tmpVecA$2, tmpVecB$1);
	}

}

const tmpVecA$1 = new Vec3();
const tmpVecB = new Vec3();

class BoundingSphere {
	constructor(center = new Vec3(), radius = 0.5) {
		this.center = center;
		this.radius = radius;
	}

	containsPoint(point) {
		const lenSq = tmpVecA$1.sub2(point, this.center).lengthSq();
		const r = this.radius;
		return lenSq < r * r;
	}

	intersectsRay(ray, point) {
		const m = tmpVecA$1.copy(ray.origin).sub(this.center);
		const b = m.dot(tmpVecB.copy(ray.direction).normalize());
		const c = m.dot(m) - this.radius * this.radius;
		if (c > 0 && b > 0) return false;
		const discr = b * b - c;
		if (discr < 0) return false;
		const t = Math.abs(-b - Math.sqrt(discr));
		if (point) point.copy(ray.direction).mulScalar(t).add(ray.origin);
		return true;
	}

	intersectsBoundingSphere(sphere) {
		tmpVecA$1.sub2(sphere.center, this.center);
		const totalRadius = sphere.radius + this.radius;

		if (tmpVecA$1.lengthSq() <= totalRadius * totalRadius) {
			return true;
		}

		return false;
	}

}

const BLEND_SUBTRACTIVE = 0;
const BLEND_ADDITIVE = 1;
const BLEND_NORMAL = 2;
const BLEND_NONE = 3;
const BLEND_PREMULTIPLIED = 4;
const BLEND_MULTIPLICATIVE = 5;
const BLEND_ADDITIVEALPHA = 6;
const BLEND_MULTIPLICATIVE2X = 7;
const BLEND_SCREEN = 8;
const BLEND_MIN = 9;
const BLEND_MAX = 10;
const FOG_NONE = 'none';
const FOG_LINEAR = 'linear';
const FOG_EXP = 'exp';
const FOG_EXP2 = 'exp2';
const FRESNEL_NONE = 0;
const FRESNEL_SCHLICK = 2;
const LAYER_HUD = 0;
const LAYER_GIZMO = 1;
const LAYER_FX = 2;
const LAYER_WORLD = 15;
const LAYERID_WORLD = 0;
const LAYERID_DEPTH = 1;
const LAYERID_SKYBOX = 2;
const LAYERID_IMMEDIATE = 3;
const LAYERID_UI = 4;
const LIGHTTYPE_DIRECTIONAL = 0;
const LIGHTTYPE_OMNI = 1;
const LIGHTTYPE_POINT = LIGHTTYPE_OMNI;
const LIGHTTYPE_SPOT = 2;
const LIGHTSHAPE_PUNCTUAL = 0;
const LIGHTSHAPE_RECT = 1;
const LIGHTSHAPE_DISK = 2;
const LIGHTSHAPE_SPHERE = 3;
const LIGHTFALLOFF_LINEAR = 0;
const LIGHTFALLOFF_INVERSESQUARED = 1;
const SHADOW_PCF3 = 0;
const SHADOW_DEPTH = 0;
const SHADOW_VSM8 = 1;
const SHADOW_VSM16 = 2;
const SHADOW_VSM32 = 3;
const SHADOW_PCF5 = 4;
const SHADOW_PCF1 = 5;
const SHADOW_COUNT = 6;
const shadowTypeToString = {};
shadowTypeToString[SHADOW_PCF3] = "PCF3";
shadowTypeToString[SHADOW_VSM8] = "VSM8";
shadowTypeToString[SHADOW_VSM16] = "VSM16";
shadowTypeToString[SHADOW_VSM32] = "VSM32";
shadowTypeToString[SHADOW_PCF5] = "PCF5";
shadowTypeToString[SHADOW_PCF1] = "PCF1";
const BLUR_BOX = 0;
const BLUR_GAUSSIAN = 1;
const PARTICLESORT_NONE = 0;
const PARTICLESORT_DISTANCE = 1;
const PARTICLESORT_NEWER_FIRST = 2;
const PARTICLESORT_OLDER_FIRST = 3;
const PARTICLEMODE_GPU = 0;
const PARTICLEMODE_CPU = 1;
const EMITTERSHAPE_BOX = 0;
const EMITTERSHAPE_SPHERE = 1;
const PARTICLEORIENTATION_SCREEN = 0;
const PARTICLEORIENTATION_WORLD = 1;
const PARTICLEORIENTATION_EMITTER = 2;
const PROJECTION_PERSPECTIVE = 0;
const PROJECTION_ORTHOGRAPHIC = 1;
const RENDERSTYLE_SOLID = 0;
const RENDERSTYLE_WIREFRAME = 1;
const RENDERSTYLE_POINTS = 2;
const CUBEPROJ_NONE = 0;
const CUBEPROJ_BOX = 1;
const SPECULAR_PHONG = 0;
const SPECULAR_BLINN = 1;
const DETAILMODE_MUL = 'mul';
const DETAILMODE_ADD = 'add';
const DETAILMODE_SCREEN = 'screen';
const DETAILMODE_OVERLAY = 'overlay';
const DETAILMODE_MIN = 'min';
const DETAILMODE_MAX = 'max';
const GAMMA_NONE = 0;
const GAMMA_SRGB = 1;
const GAMMA_SRGBFAST = 2;
const GAMMA_SRGBHDR = 3;
const TONEMAP_LINEAR = 0;
const TONEMAP_FILMIC = 1;
const TONEMAP_HEJL = 2;
const TONEMAP_ACES = 3;
const TONEMAP_ACES2 = 4;
const SPECOCC_NONE = 0;
const SPECOCC_AO = 1;
const SPECOCC_GLOSSDEPENDENT = 2;
const SHADERDEF_NOSHADOW = 1;
const SHADERDEF_SKIN = 2;
const SHADERDEF_UV0 = 4;
const SHADERDEF_UV1 = 8;
const SHADERDEF_VCOLOR = 16;
const SHADERDEF_INSTANCING = 32;
const SHADERDEF_LM = 64;
const SHADERDEF_DIRLM = 128;
const SHADERDEF_SCREENSPACE = 256;
const SHADERDEF_TANGENTS = 512;
const SHADERDEF_MORPH_POSITION = 1024;
const SHADERDEF_MORPH_NORMAL = 2048;
const SHADERDEF_MORPH_TEXTURE_BASED = 4096;
const SHADERDEF_LMAMBIENT = 8192;
const LINEBATCH_WORLD = 0;
const LINEBATCH_OVERLAY = 1;
const LINEBATCH_GIZMO = 2;
const SHADOWUPDATE_NONE = 0;
const SHADOWUPDATE_THISFRAME = 1;
const SHADOWUPDATE_REALTIME = 2;
const SORTKEY_FORWARD = 0;
const SORTKEY_DEPTH = 1;
const MASK_AFFECT_DYNAMIC = 1;
const MASK_AFFECT_LIGHTMAPPED = 2;
const MASK_BAKE = 4;
const SHADER_FORWARD = 0;
const SHADER_FORWARDHDR = 1;
const SHADER_DEPTH = 2;
const SHADER_SHADOW = 3;
const SHADER_PICK = 18;
const SPRITE_RENDERMODE_SIMPLE = 0;
const SPRITE_RENDERMODE_SLICED = 1;
const SPRITE_RENDERMODE_TILED = 2;
const BAKE_COLOR = 0;
const BAKE_COLORDIR = 1;
const VIEW_CENTER = 0;
const VIEW_LEFT = 1;
const VIEW_RIGHT = 2;
const SORTMODE_NONE = 0;
const SORTMODE_MANUAL = 1;
const SORTMODE_MATERIALMESH = 2;
const SORTMODE_BACK2FRONT = 3;
const SORTMODE_FRONT2BACK = 4;
const SORTMODE_CUSTOM = 5;
const COMPUPDATED_INSTANCES = 1;
const COMPUPDATED_LIGHTS = 2;
const COMPUPDATED_CAMERAS = 4;
const COMPUPDATED_BLEND = 8;
const ASPECT_AUTO = 0;
const ASPECT_MANUAL = 1;
const ORIENTATION_HORIZONTAL = 0;
const ORIENTATION_VERTICAL = 1;

const _frustumPoints = [new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3()];

class Frustum {
	constructor() {
		this.planes = [];

		for (let i = 0; i < 6; i++) this.planes[i] = [];
	}

	setFromMat4(matrix) {
		const vpm = matrix.data;
		let plane;
		const planes = this.planes;
		plane = planes[0];
		plane[0] = vpm[3] - vpm[0];
		plane[1] = vpm[7] - vpm[4];
		plane[2] = vpm[11] - vpm[8];
		plane[3] = vpm[15] - vpm[12];
		let t = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);
		plane[0] /= t;
		plane[1] /= t;
		plane[2] /= t;
		plane[3] /= t;
		plane = planes[1];
		plane[0] = vpm[3] + vpm[0];
		plane[1] = vpm[7] + vpm[4];
		plane[2] = vpm[11] + vpm[8];
		plane[3] = vpm[15] + vpm[12];
		t = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);
		plane[0] /= t;
		plane[1] /= t;
		plane[2] /= t;
		plane[3] /= t;
		plane = planes[2];
		plane[0] = vpm[3] + vpm[1];
		plane[1] = vpm[7] + vpm[5];
		plane[2] = vpm[11] + vpm[9];
		plane[3] = vpm[15] + vpm[13];
		t = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);
		plane[0] /= t;
		plane[1] /= t;
		plane[2] /= t;
		plane[3] /= t;
		plane = planes[3];
		plane[0] = vpm[3] - vpm[1];
		plane[1] = vpm[7] - vpm[5];
		plane[2] = vpm[11] - vpm[9];
		plane[3] = vpm[15] - vpm[13];
		t = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);
		plane[0] /= t;
		plane[1] /= t;
		plane[2] /= t;
		plane[3] /= t;
		plane = planes[4];
		plane[0] = vpm[3] - vpm[2];
		plane[1] = vpm[7] - vpm[6];
		plane[2] = vpm[11] - vpm[10];
		plane[3] = vpm[15] - vpm[14];
		t = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);
		plane[0] /= t;
		plane[1] /= t;
		plane[2] /= t;
		plane[3] /= t;
		plane = planes[5];
		plane[0] = vpm[3] + vpm[2];
		plane[1] = vpm[7] + vpm[6];
		plane[2] = vpm[11] + vpm[10];
		plane[3] = vpm[15] + vpm[14];
		t = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);
		plane[0] /= t;
		plane[1] /= t;
		plane[2] /= t;
		plane[3] /= t;
	}

	containsPoint(point) {
		let p, plane;

		for (p = 0; p < 6; p++) {
			plane = this.planes[p];

			if (plane[0] * point.x + plane[1] * point.y + plane[2] * point.z + plane[3] <= 0) {
				return false;
			}
		}

		return true;
	}

	containsSphere(sphere) {
		let c = 0;
		let d;
		let p;
		const sr = sphere.radius;
		const sc = sphere.center;
		const scx = sc.x;
		const scy = sc.y;
		const scz = sc.z;
		const planes = this.planes;
		let plane;

		for (p = 0; p < 6; p++) {
			plane = planes[p];
			d = plane[0] * scx + plane[1] * scy + plane[2] * scz + plane[3];
			if (d <= -sr) return 0;
			if (d > sr) c++;
		}

		return c === 6 ? 2 : 1;
	}

	static getPoints(camera, near, far) {
		near = near || camera._nearClip;
		far = far || camera._farClip;
		const fov = camera._fov * Math.PI / 180.0;
		let y = camera._projection === PROJECTION_PERSPECTIVE ? Math.tan(fov / 2.0) * near : camera._orthoHeight;
		let x = y * camera._aspectRatio;
		const points = _frustumPoints;
		points[0].x = x;
		points[0].y = -y;
		points[0].z = -near;
		points[1].x = x;
		points[1].y = y;
		points[1].z = -near;
		points[2].x = -x;
		points[2].y = y;
		points[2].z = -near;
		points[3].x = -x;
		points[3].y = -y;
		points[3].z = -near;

		if (camera._projection === PROJECTION_PERSPECTIVE) {
			y = Math.tan(fov / 2.0) * far;
			x = y * camera._aspectRatio;
		}

		points[4].x = x;
		points[4].y = -y;
		points[4].z = -far;
		points[5].x = x;
		points[5].y = y;
		points[5].z = -far;
		points[6].x = -x;
		points[6].y = y;
		points[6].z = -far;
		points[7].x = -x;
		points[7].y = -y;
		points[7].z = -far;
		return points;
	}

}

class Ray {
	constructor(origin = new Vec3(), direction = new Vec3(0, 0, -1)) {
		this.origin = origin;
		this.direction = direction;
	}

	set(origin, direction) {
		this.origin.copy(origin);
		this.direction.copy(direction);
		return this;
	}

}

const tmpRay = new Ray();
const tmpVec3$2 = new Vec3();
const tmpSphere = new BoundingSphere();
const tmpMat4$1 = new Mat4();

class OrientedBox {
	constructor(worldTransform = new Mat4(), halfExtents = new Vec3(0.5, 0.5, 0.5)) {
		this.halfExtents = halfExtents;
		this._modelTransform = worldTransform.clone().invert();
		this._worldTransform = worldTransform.clone();
		this._aabb = new BoundingBox(new Vec3(), this.halfExtents);
	}

	set worldTransform(value) {
		this._worldTransform.copy(value);

		this._modelTransform.copy(value).invert();
	}

	get worldTransform() {
		return this._worldTransform;
	}

	intersectsRay(ray, point) {
		this._modelTransform.transformPoint(ray.origin, tmpRay.origin);

		this._modelTransform.transformVector(ray.direction, tmpRay.direction);

		if (point) {
			const result = this._aabb._intersectsRay(tmpRay, point);

			tmpMat4$1.copy(this._modelTransform).invert().transformPoint(point, point);
			return result;
		}

		return this._aabb._fastIntersectsRay(tmpRay);
	}

	containsPoint(point) {
		this._modelTransform.transformPoint(point, tmpVec3$2);

		return this._aabb.containsPoint(tmpVec3$2);
	}

	intersectsBoundingSphere(sphere) {
		this._modelTransform.transformPoint(sphere.center, tmpSphere.center);

		tmpSphere.radius = sphere.radius;

		if (this._aabb.intersectsBoundingSphere(tmpSphere)) {
			return true;
		}

		return false;
	}

}

const tmpVecA = new Vec3();

class Plane {
	constructor(point = new Vec3(), normal = new Vec3(0, 0, 1)) {
		this.normal = normal;
		this.point = point;
	}

	intersectsLine(start, end, point) {
		const d = -this.normal.dot(this.point);
		const d0 = this.normal.dot(start) + d;
		const d1 = this.normal.dot(end) + d;
		const t = d0 / (d0 - d1);
		const intersects = t >= 0 && t <= 1;
		if (intersects && point) point.lerp(start, end, t);
		return intersects;
	}

	intersectsRay(ray, point) {
		const pointToOrigin = tmpVecA.sub2(this.point, ray.origin);
		const t = this.normal.dot(pointToOrigin) / this.normal.dot(ray.direction);
		const intersects = t >= 0;
		if (intersects && point) point.copy(ray.direction).mulScalar(t).add(ray.origin);
		return intersects;
	}

}

const ADDRESS_REPEAT = 0;
const ADDRESS_CLAMP_TO_EDGE = 1;
const ADDRESS_MIRRORED_REPEAT = 2;
const BLENDMODE_ZERO = 0;
const BLENDMODE_ONE = 1;
const BLENDMODE_SRC_COLOR = 2;
const BLENDMODE_ONE_MINUS_SRC_COLOR = 3;
const BLENDMODE_DST_COLOR = 4;
const BLENDMODE_ONE_MINUS_DST_COLOR = 5;
const BLENDMODE_SRC_ALPHA = 6;
const BLENDMODE_SRC_ALPHA_SATURATE = 7;
const BLENDMODE_ONE_MINUS_SRC_ALPHA = 8;
const BLENDMODE_DST_ALPHA = 9;
const BLENDMODE_ONE_MINUS_DST_ALPHA = 10;
const BLENDEQUATION_ADD = 0;
const BLENDEQUATION_SUBTRACT = 1;
const BLENDEQUATION_REVERSE_SUBTRACT = 2;
const BLENDEQUATION_MIN = 3;
const BLENDEQUATION_MAX = 4;
const BUFFER_STATIC = 0;
const BUFFER_DYNAMIC = 1;
const BUFFER_STREAM = 2;
const BUFFER_GPUDYNAMIC = 3;
const CLEARFLAG_COLOR = 1;
const CLEARFLAG_DEPTH = 2;
const CLEARFLAG_STENCIL = 4;
const CUBEFACE_POSX = 0;
const CUBEFACE_NEGX = 1;
const CUBEFACE_POSY = 2;
const CUBEFACE_NEGY = 3;
const CUBEFACE_POSZ = 4;
const CUBEFACE_NEGZ = 5;
const CULLFACE_NONE = 0;
const CULLFACE_BACK = 1;
const CULLFACE_FRONT = 2;
const CULLFACE_FRONTANDBACK = 3;
const FILTER_NEAREST = 0;
const FILTER_LINEAR = 1;
const FILTER_NEAREST_MIPMAP_NEAREST = 2;
const FILTER_NEAREST_MIPMAP_LINEAR = 3;
const FILTER_LINEAR_MIPMAP_NEAREST = 4;
const FILTER_LINEAR_MIPMAP_LINEAR = 5;
const FUNC_NEVER = 0;
const FUNC_LESS = 1;
const FUNC_EQUAL = 2;
const FUNC_LESSEQUAL = 3;
const FUNC_GREATER = 4;
const FUNC_NOTEQUAL = 5;
const FUNC_GREATEREQUAL = 6;
const FUNC_ALWAYS = 7;
const INDEXFORMAT_UINT8 = 0;
const INDEXFORMAT_UINT16 = 1;
const INDEXFORMAT_UINT32 = 2;
const PIXELFORMAT_A8 = 0;
const PIXELFORMAT_L8 = 1;
const PIXELFORMAT_L8_A8 = 2;
const PIXELFORMAT_R5_G6_B5 = 3;
const PIXELFORMAT_R5_G5_B5_A1 = 4;
const PIXELFORMAT_R4_G4_B4_A4 = 5;
const PIXELFORMAT_R8_G8_B8 = 6;
const PIXELFORMAT_R8_G8_B8_A8 = 7;
const PIXELFORMAT_DXT1 = 8;
const PIXELFORMAT_DXT3 = 9;
const PIXELFORMAT_DXT5 = 10;
const PIXELFORMAT_RGB16F = 11;
const PIXELFORMAT_RGBA16F = 12;
const PIXELFORMAT_RGB32F = 13;
const PIXELFORMAT_RGBA32F = 14;
const PIXELFORMAT_R32F = 15;
const PIXELFORMAT_DEPTH = 16;
const PIXELFORMAT_DEPTHSTENCIL = 17;
const PIXELFORMAT_111110F = 18;
const PIXELFORMAT_SRGB = 19;
const PIXELFORMAT_SRGBA = 20;
const PIXELFORMAT_ETC1 = 21;
const PIXELFORMAT_ETC2_RGB = 22;
const PIXELFORMAT_ETC2_RGBA = 23;
const PIXELFORMAT_PVRTC_2BPP_RGB_1 = 24;
const PIXELFORMAT_PVRTC_2BPP_RGBA_1 = 25;
const PIXELFORMAT_PVRTC_4BPP_RGB_1 = 26;
const PIXELFORMAT_PVRTC_4BPP_RGBA_1 = 27;
const PIXELFORMAT_ASTC_4x4 = 28;
const PIXELFORMAT_ATC_RGB = 29;
const PIXELFORMAT_ATC_RGBA = 30;
const PRIMITIVE_POINTS = 0;
const PRIMITIVE_LINES = 1;
const PRIMITIVE_LINELOOP = 2;
const PRIMITIVE_LINESTRIP = 3;
const PRIMITIVE_TRIANGLES = 4;
const PRIMITIVE_TRISTRIP = 5;
const PRIMITIVE_TRIFAN = 6;
const SEMANTIC_POSITION = "POSITION";
const SEMANTIC_NORMAL = "NORMAL";
const SEMANTIC_TANGENT = "TANGENT";
const SEMANTIC_BLENDWEIGHT = "BLENDWEIGHT";
const SEMANTIC_BLENDINDICES = "BLENDINDICES";
const SEMANTIC_COLOR = "COLOR";
const SEMANTIC_TEXCOORD = "TEXCOORD";
const SEMANTIC_TEXCOORD0 = "TEXCOORD0";
const SEMANTIC_TEXCOORD1 = "TEXCOORD1";
const SEMANTIC_TEXCOORD2 = "TEXCOORD2";
const SEMANTIC_TEXCOORD3 = "TEXCOORD3";
const SEMANTIC_TEXCOORD4 = "TEXCOORD4";
const SEMANTIC_TEXCOORD5 = "TEXCOORD5";
const SEMANTIC_TEXCOORD6 = "TEXCOORD6";
const SEMANTIC_TEXCOORD7 = "TEXCOORD7";
const SEMANTIC_ATTR = "ATTR";
const SEMANTIC_ATTR0 = "ATTR0";
const SEMANTIC_ATTR1 = "ATTR1";
const SEMANTIC_ATTR2 = "ATTR2";
const SEMANTIC_ATTR3 = "ATTR3";
const SEMANTIC_ATTR4 = "ATTR4";
const SEMANTIC_ATTR5 = "ATTR5";
const SEMANTIC_ATTR6 = "ATTR6";
const SEMANTIC_ATTR7 = "ATTR7";
const SEMANTIC_ATTR8 = "ATTR8";
const SEMANTIC_ATTR9 = "ATTR9";
const SEMANTIC_ATTR10 = "ATTR10";
const SEMANTIC_ATTR11 = "ATTR11";
const SEMANTIC_ATTR12 = "ATTR12";
const SEMANTIC_ATTR13 = "ATTR13";
const SEMANTIC_ATTR14 = "ATTR14";
const SEMANTIC_ATTR15 = "ATTR15";
const SHADERTAG_MATERIAL = 1;
const STENCILOP_KEEP = 0;
const STENCILOP_ZERO = 1;
const STENCILOP_REPLACE = 2;
const STENCILOP_INCREMENT = 3;
const STENCILOP_INCREMENTWRAP = 4;
const STENCILOP_DECREMENT = 5;
const STENCILOP_DECREMENTWRAP = 6;
const STENCILOP_INVERT = 7;
const TEXTURELOCK_READ = 1;
const TEXTURELOCK_WRITE = 2;
const TEXTURETYPE_DEFAULT = 'default';
const TEXTURETYPE_RGBM = 'rgbm';
const TEXTURETYPE_RGBE = 'rgbe';
const TEXTURETYPE_SWIZZLEGGGR = 'swizzleGGGR';
const TEXHINT_NONE = 0;
const TEXHINT_SHADOWMAP = 1;
const TEXHINT_ASSET = 2;
const TEXHINT_LIGHTMAP = 3;
const TEXTUREPROJECTION_NONE = "none";
const TEXTUREPROJECTION_CUBE = "cube";
const TEXTUREPROJECTION_EQUIRECT = "equirect";
const TEXTUREPROJECTION_OCTAHEDRAL = "octahedral";
const TYPE_INT8 = 0;
const TYPE_UINT8 = 1;
const TYPE_INT16 = 2;
const TYPE_UINT16 = 3;
const TYPE_INT32 = 4;
const TYPE_UINT32 = 5;
const TYPE_FLOAT32 = 6;
const UNIFORMTYPE_BOOL = 0;
const UNIFORMTYPE_INT = 1;
const UNIFORMTYPE_FLOAT = 2;
const UNIFORMTYPE_VEC2 = 3;
const UNIFORMTYPE_VEC3 = 4;
const UNIFORMTYPE_VEC4 = 5;
const UNIFORMTYPE_IVEC2 = 6;
const UNIFORMTYPE_IVEC3 = 7;
const UNIFORMTYPE_IVEC4 = 8;
const UNIFORMTYPE_BVEC2 = 9;
const UNIFORMTYPE_BVEC3 = 10;
const UNIFORMTYPE_BVEC4 = 11;
const UNIFORMTYPE_MAT2 = 12;
const UNIFORMTYPE_MAT3 = 13;
const UNIFORMTYPE_MAT4 = 14;
const UNIFORMTYPE_TEXTURE2D = 15;
const UNIFORMTYPE_TEXTURECUBE = 16;
const UNIFORMTYPE_FLOATARRAY = 17;
const UNIFORMTYPE_TEXTURE2D_SHADOW = 18;
const UNIFORMTYPE_TEXTURECUBE_SHADOW = 19;
const UNIFORMTYPE_TEXTURE3D = 20;
const UNIFORMTYPE_VEC2ARRAY = 21;
const UNIFORMTYPE_VEC3ARRAY = 22;
const UNIFORMTYPE_VEC4ARRAY = 23;
const typedArrayTypes = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array];
const typedArrayTypesByteSize = [1, 1, 2, 2, 4, 4, 4];
const typedArrayToType = {
	"Int8Array": TYPE_INT8,
	"Uint8Array": TYPE_UINT8,
	"Int16Array": TYPE_INT16,
	"Uint16Array": TYPE_UINT16,
	"Int32Array": TYPE_INT32,
	"Uint32Array": TYPE_UINT32,
	"Float32Array": TYPE_FLOAT32
};
const typedArrayIndexFormats = [Uint8Array, Uint16Array, Uint32Array];
const typedArrayIndexFormatsByteSize = [1, 2, 4];
const semanticToLocation = {};
semanticToLocation[SEMANTIC_POSITION] = 0;
semanticToLocation[SEMANTIC_NORMAL] = 1;
semanticToLocation[SEMANTIC_BLENDWEIGHT] = 2;
semanticToLocation[SEMANTIC_BLENDINDICES] = 3;
semanticToLocation[SEMANTIC_COLOR] = 4;
semanticToLocation[SEMANTIC_TEXCOORD0] = 5;
semanticToLocation[SEMANTIC_TEXCOORD1] = 6;
semanticToLocation[SEMANTIC_TEXCOORD2] = 7;
semanticToLocation[SEMANTIC_TEXCOORD3] = 8;
semanticToLocation[SEMANTIC_TEXCOORD4] = 9;
semanticToLocation[SEMANTIC_TEXCOORD5] = 10;
semanticToLocation[SEMANTIC_TEXCOORD6] = 11;
semanticToLocation[SEMANTIC_TEXCOORD7] = 12;
semanticToLocation[SEMANTIC_TANGENT] = 13;
semanticToLocation[SEMANTIC_ATTR0] = 0;
semanticToLocation[SEMANTIC_ATTR1] = 1;
semanticToLocation[SEMANTIC_ATTR2] = 2;
semanticToLocation[SEMANTIC_ATTR3] = 3;
semanticToLocation[SEMANTIC_ATTR4] = 4;
semanticToLocation[SEMANTIC_ATTR5] = 5;
semanticToLocation[SEMANTIC_ATTR6] = 6;
semanticToLocation[SEMANTIC_ATTR7] = 7;
semanticToLocation[SEMANTIC_ATTR8] = 8;
semanticToLocation[SEMANTIC_ATTR9] = 9;
semanticToLocation[SEMANTIC_ATTR10] = 10;
semanticToLocation[SEMANTIC_ATTR11] = 11;
semanticToLocation[SEMANTIC_ATTR12] = 12;
semanticToLocation[SEMANTIC_ATTR13] = 13;
semanticToLocation[SEMANTIC_ATTR14] = 14;
semanticToLocation[SEMANTIC_ATTR15] = 15;

let id$3 = 0;

class VertexBuffer {
	constructor(graphicsDevice, format, numVertices, usage = BUFFER_STATIC, initialData) {
		this.device = graphicsDevice;
		this.format = format;
		this.numVertices = numVertices;
		this.usage = usage;
		this.id = id$3++;
		this.impl = graphicsDevice.createVertexBufferImpl(this, format);
		this.instancing = false;
		this.numBytes = format.verticesByteSize ? format.verticesByteSize : format.size * numVertices;
		graphicsDevice._vram.vb += this.numBytes;

		if (initialData) {
			this.setData(initialData);
		} else {
			this.storage = new ArrayBuffer(this.numBytes);
		}

		this.device.buffers.push(this);
	}

	destroy() {
		const device = this.device;
		const idx = device.buffers.indexOf(this);

		if (idx !== -1) {
			device.buffers.splice(idx, 1);
		}

		this.impl.destroy(device);
		device._vram.vb -= this.storage.byteLength;
	}

	loseContext() {
		this.impl.loseContext();
	}

	getFormat() {
		return this.format;
	}

	getUsage() {
		return this.usage;
	}

	getNumVertices() {
		return this.numVertices;
	}

	lock() {
		return this.storage;
	}

	unlock() {
		this.impl.unlock(this);
	}

	setData(data) {
		if (data.byteLength !== this.numBytes) {
			return false;
		}

		this.storage = data;
		this.unlock();
		return true;
	}

}

function hashCode(str) {
	let hash = 0;

	for (let i = 0, len = str.length; i < len; i++) {
		hash = (hash << 5) - hash + str.charCodeAt(i);
		hash |= 0;
	}

	return hash;
}

class VertexFormat {
	constructor(graphicsDevice, description, vertexCount) {
		this._elements = [];
		this.hasUv0 = false;
		this.hasUv1 = false;
		this.hasColor = false;
		this.hasTangents = false;
		this.verticesByteSize = 0;
		this.vertexCount = vertexCount;
		this.interleaved = vertexCount === undefined;
		this.size = description.reduce((total, desc) => {
			return total + Math.ceil(desc.components * typedArrayTypesByteSize[desc.type] / 4) * 4;
		}, 0);
		let offset = 0,
				elementSize;

		for (let i = 0, len = description.length; i < len; i++) {
			const elementDesc = description[i];
			elementSize = elementDesc.components * typedArrayTypesByteSize[elementDesc.type];

			if (vertexCount) {
				offset = math.roundUp(offset, elementSize);
			}

			const element = {
				name: elementDesc.semantic,
				offset: vertexCount ? offset : elementDesc.hasOwnProperty('offset') ? elementDesc.offset : offset,
				stride: vertexCount ? elementSize : elementDesc.hasOwnProperty('stride') ? elementDesc.stride : this.size,
				dataType: elementDesc.type,
				numComponents: elementDesc.components,
				normalize: elementDesc.normalize === undefined ? false : elementDesc.normalize,
				size: elementSize
			};

			this._elements.push(element);

			if (vertexCount) {
				offset += elementSize * vertexCount;
			} else {
				offset += Math.ceil(elementSize / 4) * 4;
			}

			if (elementDesc.semantic === SEMANTIC_TEXCOORD0) {
				this.hasUv0 = true;
			} else if (elementDesc.semantic === SEMANTIC_TEXCOORD1) {
				this.hasUv1 = true;
			} else if (elementDesc.semantic === SEMANTIC_COLOR) {
				this.hasColor = true;
			} else if (elementDesc.semantic === SEMANTIC_TANGENT) {
				this.hasTangents = true;
			}
		}

		if (vertexCount) {
			this.verticesByteSize = offset;
		}

		this._evaluateHash();
	}

	get elements() {
		return this._elements;
	}

	static get defaultInstancingFormat() {
		if (!VertexFormat._defaultInstancingFormat) {
			VertexFormat._defaultInstancingFormat = new VertexFormat(null, [{
				semantic: SEMANTIC_ATTR12,
				components: 4,
				type: TYPE_FLOAT32
			}, {
				semantic: SEMANTIC_ATTR13,
				components: 4,
				type: TYPE_FLOAT32
			}, {
				semantic: SEMANTIC_ATTR14,
				components: 4,
				type: TYPE_FLOAT32
			}, {
				semantic: SEMANTIC_ATTR15,
				components: 4,
				type: TYPE_FLOAT32
			}]);
		}

		return VertexFormat._defaultInstancingFormat;
	}

	_evaluateHash() {
		let stringElementBatch;
		const stringElementsBatch = [];
		let stringElementRender;
		const stringElementsRender = [];
		const len = this._elements.length;

		for (let i = 0; i < len; i++) {
			const element = this._elements[i];
			stringElementBatch = element.name;
			stringElementBatch += element.dataType;
			stringElementBatch += element.numComponents;
			stringElementBatch += element.normalize;
			stringElementsBatch.push(stringElementBatch);
			stringElementRender = stringElementBatch;
			stringElementRender += element.offset;
			stringElementRender += element.stride;
			stringElementRender += element.size;
			stringElementsRender.push(stringElementRender);
		}

		stringElementsBatch.sort();
		this.batchingHash = hashCode(stringElementsBatch.join());
		this.renderingingHash = hashCode(stringElementsRender.join());
	}

}

VertexFormat._defaultInstancingFormat = null;

class DeviceCache {
	constructor() {
		this._cache = new Map();
	}

	get(device, onCreate) {
		if (!this._cache.has(device)) {
			this._cache.set(device, onCreate());

			device.on('destroy', () => {
				var _this$_cache$get;

				(_this$_cache$get = this._cache.get(device)) == null ? void 0 : _this$_cache$get.destroy();

				this._cache.delete(device);
			});
		}

		return this._cache.get(device);
	}

}

const _postEffectQuadDraw = {
	type: PRIMITIVE_TRISTRIP,
	base: 0,
	count: 4,
	indexed: false
};
const postEffectDeviceCache = new DeviceCache();

function getPostEffectQuadVB(device) {
	return postEffectDeviceCache.get(device, () => {
		const vertexFormat = new VertexFormat(device, [{
			semantic: SEMANTIC_POSITION,
			components: 2,
			type: TYPE_FLOAT32
		}]);
		const positions = new Float32Array(8);
		positions.set([-1, -1, 1, -1, -1, 1, 1, 1]);
		return new VertexBuffer(device, vertexFormat, 4, BUFFER_STATIC, positions);
	});
}

function drawQuadWithShader(device, target, shader, rect, scissorRect, useBlend = false) {
	const oldRt = device.renderTarget;
	device.setRenderTarget(target);
	device.updateBegin();
	let x, y, w, h;
	let sx, sy, sw, sh;

	if (!rect) {
		w = target ? target.width : device.width;
		h = target ? target.height : device.height;
		x = 0;
		y = 0;
	} else {
		x = rect.x;
		y = rect.y;
		w = rect.z;
		h = rect.w;
	}

	if (!scissorRect) {
		sx = x;
		sy = y;
		sw = w;
		sh = h;
	} else {
		sx = scissorRect.x;
		sy = scissorRect.y;
		sw = scissorRect.z;
		sh = scissorRect.w;
	}

	const oldVx = device.vx;
	const oldVy = device.vy;
	const oldVw = device.vw;
	const oldVh = device.vh;
	device.setViewport(x, y, w, h);
	const oldSx = device.sx;
	const oldSy = device.sy;
	const oldSw = device.sw;
	const oldSh = device.sh;
	device.setScissor(sx, sy, sw, sh);
	const oldDepthTest = device.getDepthTest();
	const oldDepthWrite = device.getDepthWrite();
	const oldCullMode = device.getCullMode();
	const oldWR = device.writeRed;
	const oldWG = device.writeGreen;
	const oldWB = device.writeBlue;
	const oldWA = device.writeAlpha;
	device.setDepthTest(false);
	device.setDepthWrite(false);
	device.setCullMode(CULLFACE_NONE);
	device.setColorWrite(true, true, true, true);
	if (!useBlend) device.setBlending(false);
	device.setVertexBuffer(getPostEffectQuadVB(device), 0);
	device.setShader(shader);
	device.draw(_postEffectQuadDraw);
	device.setDepthTest(oldDepthTest);
	device.setDepthWrite(oldDepthWrite);
	device.setCullMode(oldCullMode);
	device.setColorWrite(oldWR, oldWG, oldWB, oldWA);
	device.updateEnd();
	device.setRenderTarget(oldRt);
	device.updateBegin();
	device.setViewport(oldVx, oldVy, oldVw, oldVh);
	device.setScissor(oldSx, oldSy, oldSw, oldSh);
}

function drawTexture(device, texture, target, shader, rect, scissorRect, useBlend = false) {
	shader = shader || device.getCopyShader();
	device.constantTexSource.setValue(texture);
	drawQuadWithShader(device, target, shader, rect, scissorRect, useBlend);
}

class Shader {
	constructor(graphicsDevice, definition) {
		this.device = graphicsDevice;
		this.definition = definition;
		this.init();
		this.impl = graphicsDevice.createShaderImpl(this);
	}

	init() {
		this.attributes = [];
		this.uniforms = [];
		this.samplers = [];
		this.ready = false;
		this.failed = false;
	}

	destroy() {
		this.impl.destroy(this);
	}

	loseContext() {
		this.init();
	}

	restoreContext() {
		this.impl.restoreContext(this.device, this);
	}

}

var alphaTestPS = "uniform float alpha_ref;\nvoid alphaTest(float a) {\n\tif (a < alpha_ref) discard;\n}\n";

var ambientConstantPS = "void addAmbient() {\n\tdDiffuseLight += light_globalAmbient;\n}\n";

var ambientEnvPS = "#ifndef ENV_ATLAS\n#define ENV_ATLAS\nuniform sampler2D texture_envAtlas;\n#endif\nvoid addAmbient() {\n\tvec3 dir = normalize(cubeMapRotate(dNormalW) * vec3(-1.0, 1.0, 1.0));\n\tvec2 uv = mapUv(toSphericalUv(dir), vec4(128.0, 256.0 + 128.0, 64.0, 32.0) / atlasSize);\n\tvec4 raw = texture2D(texture_envAtlas, uv);\n\tvec3 linear = $DECODE(raw);\n\tdDiffuseLight += processEnvironment(linear);\n}\n";

var ambientSHPS = "uniform vec3 ambientSH[9];\nvoid addAmbient() {\n\tvec3 n = cubeMapRotate(dNormalW);\n\tvec3 color =\n\t\tambientSH[0] +\n\t\tambientSH[1] * n.x +\n\t\tambientSH[2] * n.y +\n\t\tambientSH[3] * n.z +\n\t\tambientSH[4] * n.x * n.z +\n\t\tambientSH[5] * n.z * n.y +\n\t\tambientSH[6] * n.y * n.x +\n\t\tambientSH[7] * (3.0 * n.z * n.z - 1.0) +\n\t\tambientSH[8] * (n.x * n.x - n.y * n.y);\n\tdDiffuseLight += processEnvironment(max(color, vec3(0.0)));\n}\n";

var aoPS = "#ifdef MAPTEXTURE\nuniform sampler2D texture_aoMap;\n#endif\nvoid applyAO() {\n\tdAo = 1.0;\n\t#ifdef MAPTEXTURE\n\tdAo *= texture2D(texture_aoMap, $UV).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tdAo *= saturate(vVertexColor.$VC);\n\t#endif\n\tdDiffuseLight *= dAo;\n}\n";

var aoSpecOccPS = "uniform float material_occludeSpecularIntensity;\nvoid occludeSpecular() {\n\tfloat specPow = exp2(dGlossiness * 11.0);\n\tfloat specOcc = saturate(pow(dot(dNormalW, dViewDirW) + dAo, 0.01*specPow) - 1.0 + dAo);\n\tspecOcc = mix(1.0, specOcc, material_occludeSpecularIntensity);\n\tdSpecularLight *= specOcc;\n\tdReflection *= specOcc;\n}\n";

var aoSpecOccConstPS = "void occludeSpecular() {\n\tfloat specPow = exp2(dGlossiness * 11.0);\n\tfloat specOcc = saturate(pow(dot(dNormalW, dViewDirW) + dAo, 0.01*specPow) - 1.0 + dAo);\n\tdSpecularLight *= specOcc;\n\tdReflection *= specOcc;\n}\n";

var aoSpecOccConstSimplePS = "void occludeSpecular() {\n\tfloat specOcc = dAo;\n\tdSpecularLight *= specOcc;\n\tdReflection *= specOcc;\n}\n";

var aoSpecOccSimplePS = "uniform float material_occludeSpecularIntensity;\nvoid occludeSpecular() {\n\tfloat specOcc = mix(1.0, dAo, material_occludeSpecularIntensity);\n\tdSpecularLight *= specOcc;\n\tdReflection *= specOcc;\n}\n";

var bakeDirLmEndPS = "\tvec4 dirLm = texture2D(texture_dirLightMap, vUv1);\n\tif (bakeDir > 0.5) {\n\t\tif (dAtten > 0.00001) {\n\t\t\tdirLm.xyz = dirLm.xyz * 2.0 - vec3(1.0);\n\t\t\tdAtten = saturate(dAtten);\n\t\t\tgl_FragColor.rgb = normalize(dLightDirNormW.xyz*dAtten + dirLm.xyz*dirLm.w) * 0.5 + vec3(0.5);\n\t\t\tgl_FragColor.a = dirLm.w + dAtten;\n\t\t\tgl_FragColor.a = max(gl_FragColor.a, 1.0 / 255.0);\n\t\t} else {\n\t\t\tgl_FragColor = dirLm;\n\t\t}\n\t} else {\n\t\tgl_FragColor.rgb = dirLm.xyz;\n\t\tgl_FragColor.a = max(dirLm.w, dAtten > 0.00001? (1.0/255.0) : 0.0);\n\t}\n";

var bakeLmEndPS = "\tgl_FragColor.rgb = dDiffuseLight;\n\tgl_FragColor.rgb = pow(gl_FragColor.rgb, vec3(0.5));\n\tgl_FragColor.rgb /= 8.0;\n\tgl_FragColor.a = clamp( max( max( gl_FragColor.r, gl_FragColor.g ), max( gl_FragColor.b, 1.0 / 255.0 ) ), 0.0,1.0 );\n\tgl_FragColor.a = ceil(gl_FragColor.a * 255.0) / 255.0;\n\tgl_FragColor.rgb /= gl_FragColor.a;\n";

var basePS = "uniform vec3 view_position;\nuniform vec3 light_globalAmbient;\nfloat square(float x) {\n\treturn x*x;\n}\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\nvec3 saturate(vec3 x) {\n\treturn clamp(x, vec3(0.0), vec3(1.0));\n}\n";

var baseVS = "attribute vec3 vertex_position;\nattribute vec3 vertex_normal;\nattribute vec4 vertex_tangent;\nattribute vec2 vertex_texCoord0;\nattribute vec2 vertex_texCoord1;\nattribute vec4 vertex_color;\nuniform mat4 matrix_viewProjection;\nuniform mat4 matrix_model;\nuniform mat3 matrix_normal;\nvec3 dPositionW;\nmat4 dModelMatrix;\nmat3 dNormalMatrix;\n";

var baseNineSlicedPS = "#define NINESLICED\nvarying vec2 vMask;\nvarying vec2 vTiledUv;\nuniform mediump vec4 innerOffset;\nuniform mediump vec2 outerScale;\nuniform mediump vec4 atlasRect;\nvec2 nineSlicedUv;\n";

var baseNineSlicedVS = "#define NINESLICED\nvarying vec2 vMask;\nvarying vec2 vTiledUv;\nuniform mediump vec4 innerOffset;\nuniform mediump vec2 outerScale;\nuniform mediump vec4 atlasRect;\n";

var baseNineSlicedTiledPS = "#define NINESLICED\n#define NINESLICETILED\nvarying vec2 vMask;\nvarying vec2 vTiledUv;\nuniform mediump vec4 innerOffset;\nuniform mediump vec2 outerScale;\nuniform mediump vec4 atlasRect;\nvec2 nineSlicedUv;\n";

var biasConstPS = "#define SHADOWBIAS\nfloat getShadowBias(float resolution, float maxBias) {\n\treturn maxBias;\n}\n";

var blurVSMPS = "varying vec2 vUv0;\nuniform sampler2D source;\nuniform vec2 pixelOffset;\n#ifdef GAUSS\nuniform float weight[SAMPLES];\n#endif\n#ifdef PACKED\nfloat decodeFloatRG(vec2 rg) {\n\treturn rg.y*(1.0/255.0) + rg.x;\n}\nvec2 encodeFloatRG( float v ) {\n\tvec2 enc = vec2(1.0, 255.0) * v;\n\tenc = fract(enc);\n\tenc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\n\treturn enc;\n}\n#endif\nvoid main(void) {\n\tvec3 moments = vec3(0.0);\n\tvec2 uv = vUv0 - pixelOffset * (float(SAMPLES) * 0.5);\n\tfor (int i=0; i<SAMPLES; i++) {\n\t\tvec4 c = texture2D(source, uv + pixelOffset * float(i));\n\t\t#ifdef PACKED\n\t\tc.xy = vec2(decodeFloatRG(c.xy), decodeFloatRG(c.zw));\n\t\t#endif\n\t\t#ifdef GAUSS\n\t\tmoments += c.xyz * weight[i];\n\t\t#else\n\t\tmoments += c.xyz;\n\t\t#endif\n\t}\n\t#ifndef GAUSS\n\tmoments /= float(SAMPLES);\n\t#endif\n\t#ifdef PACKED\n\tgl_FragColor = vec4(encodeFloatRG(moments.x), encodeFloatRG(moments.y));\n\t#else\n\tgl_FragColor = vec4(moments.x, moments.y, moments.z, 1.0);\n\t#endif\n}\n";

var clearCoatPS = "#ifdef MAPFLOAT\nuniform float material_clearCoat;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_clearCoatMap;\n#endif\nvoid getClearCoat() {\n\tccSpecularity = 1.0;\n\t#ifdef MAPFLOAT\n\tccSpecularity *= material_clearCoat;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tccSpecularity *= texture2D(texture_clearCoatMap, $UV).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tccSpecularity *= saturate(vVertexColor.$VC);\n\t#endif\n}\n";

var clearCoatGlossPS = "#ifdef MAPFLOAT\nuniform float material_clearCoatGlossiness;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_clearCoatGlossMap;\n#endif\nvoid getClearCoatGlossiness() {\n\tccGlossiness = 1.0;\n\t#ifdef MAPFLOAT\n\tccGlossiness *= material_clearCoatGlossiness;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tccGlossiness *= texture2D(texture_clearCoatGlossMap, $UV).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tccGlossiness *= saturate(vVertexColor.$VC);\n\t#endif\n\tccGlossiness += 0.0000001;\n}\n";

var clearCoatNormalPS = "#ifdef MAPTEXTURE\nuniform sampler2D texture_clearCoatNormalMap;\nuniform float material_clearCoatBumpiness;\n#endif\nvoid getClearCoatNormal() {\n\t#ifdef MAPTEXTURE\n\tvec3 normalMap = unpackNormal(texture2D(texture_clearCoatNormalMap, $UV));\n\tnormalMap = normalize(mix(vec3(0.0, 0.0, 1.0), normalMap, material_clearCoatBumpiness));\n\tccNormalW = dTBN * normalMap;\n\t#else\n\tccNormalW = normalize(dVertexNormalW);\n\t#endif\n\tccReflDirW = normalize(-reflect(dViewDirW, ccNormalW));\n}\n";

var clusteredLightUtilsPS = "vec2 getCubemapFaceCoordinates(const vec3 dir, out float faceIndex, out vec2 tileOffset)\n{\n\tvec3 vAbs = abs(dir);\n\tfloat ma;\n\tvec2 uv;\n\tif (vAbs.z >= vAbs.x && vAbs.z >= vAbs.y) {\n\t\tfaceIndex = dir.z < 0.0 ? 5.0 : 4.0;\n\t\tma = 0.5 / vAbs.z;\n\t\tuv = vec2(dir.z < 0.0 ? -dir.x : dir.x, -dir.y);\n\t\ttileOffset.x = 2.0;\n\t\ttileOffset.y = dir.z < 0.0 ? 1.0 : 0.0;\n\t} else if(vAbs.y >= vAbs.x) {\n\t\tfaceIndex = dir.y < 0.0 ? 3.0 : 2.0;\n\t\tma = 0.5 / vAbs.y;\n\t\tuv = vec2(dir.x, dir.y < 0.0 ? -dir.z : dir.z);\n\t\ttileOffset.x = 1.0;\n\t\ttileOffset.y = dir.y < 0.0 ? 1.0 : 0.0;\n\t} else {\n\t\tfaceIndex = dir.x < 0.0 ? 1.0 : 0.0;\n\t\tma = 0.5 / vAbs.x;\n\t\tuv = vec2(dir.x < 0.0 ? dir.z : -dir.z, -dir.y);\n\t\ttileOffset.x = 0.0;\n\t\ttileOffset.y = dir.x < 0.0 ? 1.0 : 0.0;\n\t}\n\treturn uv * ma + 0.5;\n}\nvec2 getCubemapAtlasCoordinates(const vec3 omniAtlasViewport, float shadowEdgePixels, float shadowTextureResolution, const vec3 dir) {\n\tfloat faceIndex;\n\tvec2 tileOffset;\n\tvec2 uv = getCubemapFaceCoordinates(dir, faceIndex, tileOffset);\n\tfloat atlasFaceSize = omniAtlasViewport.z;\n\tfloat tileSize = shadowTextureResolution * atlasFaceSize;\n\tfloat offset = shadowEdgePixels / tileSize;\n\tuv = uv * vec2(1.0 - offset * 2.0) + vec2(offset * 1.0);\n\tuv *= atlasFaceSize;\n\tuv += tileOffset * atlasFaceSize;\n\tuv += omniAtlasViewport.xy;\n\treturn uv;\n}\n";

var clusteredLightCookiesPS = "vec3 _getCookieClustered(sampler2D tex, vec2 uv, float intensity, bool isRgb, vec4 cookieChannel) {\n\tvec4 pixel = mix(vec4(1.0), texture2D(tex, uv), intensity);\n\treturn isRgb == true ? pixel.rgb : vec3(dot(pixel, cookieChannel));\n}\nvec3 getCookie2DClustered(sampler2D tex, mat4 transform, vec3 worldPosition, float intensity, bool isRgb, vec4 cookieChannel) {\n\tvec4 projPos = transform * vec4(worldPosition, 1.0);\n\treturn _getCookieClustered(tex, projPos.xy / projPos.w, intensity, isRgb, cookieChannel);\n}\nvec3 getCookieCubeClustered(sampler2D tex, vec3 dir, float intensity, bool isRgb, vec4 cookieChannel, float shadowTextureResolution, float shadowEdgePixels, vec3 omniAtlasViewport) {\n\tvec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);\n\treturn _getCookieClustered(tex, uv, intensity, isRgb, cookieChannel);\n}\n";

var clusteredLightShadowsPS = "#ifdef GL2\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF1)\n\tfloat getShadowOmniClusteredPCF1(sampler2DShadow shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 dir) {\n\t\tfloat shadowTextureResolution = shadowParams.x;\n\t\tvec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);\n\t\tfloat shadowZ = length(dir) * shadowParams.w + shadowParams.z;\n\t\treturn texture(shadowMap, vec3(uv, shadowZ));\n\t}\n\t#endif\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF3)\n\tfloat getShadowOmniClusteredPCF3(sampler2DShadow shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 dir) {\n\t\tfloat shadowTextureResolution = shadowParams.x;\n\t\tvec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);\n\t\tfloat shadowZ = length(dir) * shadowParams.w + shadowParams.z;\n\t\tdShadowCoord = vec3(uv, shadowZ);\n\t\treturn getShadowPCF3x3(shadowMap, shadowParams.xyz);\n\t}\n\t#endif\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF5)\n\tfloat getShadowOmniClusteredPCF5(sampler2DShadow shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 dir) {\n\t\tfloat shadowTextureResolution = shadowParams.x;\n\t\tvec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);\n\t\tfloat shadowZ = length(dir) * shadowParams.w + shadowParams.z;\n\t\tdShadowCoord = vec3(uv, shadowZ);\n\t\treturn getShadowPCF5x5(shadowMap, shadowParams.xyz);\n\t}\n\t#endif\n#else\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF1)\n\tfloat getShadowOmniClusteredPCF1(sampler2D shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 dir) {\n\t\tfloat shadowTextureResolution = shadowParams.x;\n\t\tvec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);\n\t\tfloat depth = unpackFloat(texture2D(shadowMap, uv));\n\t\tfloat shadowZ = length(dir) * shadowParams.w + shadowParams.z;\n\t\treturn depth > shadowZ ? 1.0 : 0.0;\n\t}\n\t#endif\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF3) || defined(CLUSTER_SHADOW_TYPE_PCF5)\n\tfloat getShadowOmniClusteredPCF3(sampler2D shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 dir) {\n\t\tfloat shadowTextureResolution = shadowParams.x;\n\t\tvec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);\n\t\tfloat shadowZ = length(dir) * shadowParams.w + shadowParams.z;\n\t\tdShadowCoord = vec3(uv, shadowZ);\n\t\treturn getShadowPCF3x3(shadowMap, shadowParams.xyz);\n\t}\n\t#endif\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF5)\n\tfloat getShadowOmniClusteredPCF5(sampler2D shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 dir) {\n\t\treturn getShadowOmniClusteredPCF3(shadowMap, shadowParams, omniAtlasViewport, shadowEdgePixels, dir);\n\t}\n\t#endif\n#endif\n#ifdef GL2\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF1)\n\tfloat getShadowSpotClusteredPCF1(sampler2DShadow shadowMap, vec4 shadowParams) {\n\t\treturn texture(shadowMap, dShadowCoord);\n\t}\n\t#endif\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF3)\n\tfloat getShadowSpotClusteredPCF3(sampler2DShadow shadowMap, vec4 shadowParams) {\n\t\treturn getShadowSpotPCF3x3(shadowMap, shadowParams);\n\t}\n\t#endif\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF5)\n\tfloat getShadowSpotClusteredPCF5(sampler2DShadow shadowMap, vec4 shadowParams) {\n\t\treturn getShadowPCF5x5(shadowMap, shadowParams.xyz);\n\t}\n\t#endif\n#else\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF1)\n\tfloat getShadowSpotClusteredPCF1(sampler2D shadowMap, vec4 shadowParams) {\n\t\tfloat depth = unpackFloat(texture2D(shadowMap, dShadowCoord.xy));\n\t\treturn depth > dShadowCoord.z ? 1.0 : 0.0;\n\t}\n\t#endif\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF3) || defined(CLUSTER_SHADOW_TYPE_PCF5)\n\tfloat getShadowSpotClusteredPCF3(sampler2D shadowMap, vec4 shadowParams) {\n\t\treturn getShadowSpotPCF3x3(shadowMap, shadowParams);\n\t}\n\t#endif\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF5)\n\tfloat getShadowSpotClusteredPCF5(sampler2D shadowMap, vec4 shadowParams) {\n\t\treturn getShadowSpotClusteredPCF3(shadowMap, shadowParams);\n\t}\n\t#endif\n#endif\n";

var clusteredLightPS = "uniform sampler2D clusterWorldTexture;\nuniform sampler2D lightsTexture8;\nuniform highp sampler2D lightsTextureFloat;\n#ifdef CLUSTER_SHADOWS\n\t#ifdef GL2\n\t\tuniform sampler2DShadow shadowAtlasTexture;\n\t#else\n\t\tuniform sampler2D shadowAtlasTexture;\n\t#endif\n#endif\n#ifdef CLUSTER_COOKIES\n\tuniform sampler2D cookieAtlasTexture;\n#endif\nuniform float clusterPixelsPerCell;\nuniform vec3 clusterCellsCountByBoundsSize;\nuniform vec4 lightsTextureInvSize;\nuniform vec3 clusterTextureSize;\nuniform vec3 clusterBoundsMin;\nuniform vec3 clusterBoundsDelta;\nuniform vec3 clusterCellsDot;\nuniform vec3 clusterCellsMax;\nuniform vec2 clusterCompressionLimit0;\nuniform vec2 shadowAtlasParams;\nfloat LTCLightValuesEvaluated = 0.0;\nstruct ClusterLightData {\n\tfloat lightV;\n\tfloat type;\n\tfloat shape;\n\tvec3 halfWidth;\n\tvec3 halfHeight;\n\tfloat falloffMode;\n\tfloat castShadows;\n\tfloat shadowBias;\n\tfloat shadowNormalBias;\n\tvec3 position;\n\tvec3 direction;\n\tfloat range;\n\tfloat innerConeAngleCos;\n\tfloat outerConeAngleCos;\n\tvec3 color;\n\tvec3 omniAtlasViewport;\n\tfloat cookie;\n\tfloat cookieRgb;\n\tfloat cookieIntensity;\n\tvec4 cookieChannelMask;\n\tfloat mask;\n};\nmat4 lightProjectionMatrix;\n#define isClusteredLightCastShadow(light) ( light.castShadows > 0.5 )\n#define isClusteredLightCookie(light) (light.cookie > 0.5 )\n#define isClusteredLightCookieRgb(light) (light.cookieRgb > 0.5 )\n#define isClusteredLightSpot(light) ( light.type > 0.5 )\n#define isClusteredLightFalloffLinear(light) ( light.falloffMode < 0.5 )\n#define isClusteredLightArea(light) ( light.shape > 0.1 )\n#define isClusteredLightRect(light) ( light.shape < 0.3 )\n#define isClusteredLightDisk(light) ( light.shape < 0.6 )\n#ifdef CLUSTER_MESH_DYNAMIC_LIGHTS\n\t#define acceptLightMask(light) ( light.mask < 0.75)\n#else\n\t#define acceptLightMask(light) ( light.mask > 0.25)\n#endif\nvec4 decodeClusterLowRange4Vec4(vec4 d0, vec4 d1, vec4 d2, vec4 d3) {\n\treturn vec4(\n\t\tbytes2floatRange4(d0, -2.0, 2.0),\n\t\tbytes2floatRange4(d1, -2.0, 2.0),\n\t\tbytes2floatRange4(d2, -2.0, 2.0),\n\t\tbytes2floatRange4(d3, -2.0, 2.0)\n\t);\n}\n#ifdef SUPPORTS_TEXLOD\n\t#define textureData(texture, uv) texture2DLodEXT(texture, uv, 0.0)\n#else\n\t#define textureData(texture, uv) texture2D(texture, uv)\n#endif\nvec4 sampleLightsTexture8(const ClusterLightData clusterLightData, float index) {\n\treturn textureData(lightsTexture8, vec2(index * lightsTextureInvSize.z, clusterLightData.lightV));\n}\nvec4 sampleLightTextureF(const ClusterLightData clusterLightData, float index) {\n\treturn textureData(lightsTextureFloat, vec2(index * lightsTextureInvSize.x, clusterLightData.lightV));\n}\nvoid decodeClusterLightCore(inout ClusterLightData clusterLightData, float lightIndex) {\n\tclusterLightData.lightV = (lightIndex + 0.5) * lightsTextureInvSize.w;\n\tvec4 lightInfo = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_FLAGS);\n\tclusterLightData.type = lightInfo.x;\n\tclusterLightData.shape = lightInfo.y;\n\tclusterLightData.falloffMode = lightInfo.z;\n\tclusterLightData.castShadows = lightInfo.w;\n\tvec4 colorA = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COLOR_A);\n\tvec4 colorB = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COLOR_B);\n\tclusterLightData.color = vec3(bytes2float2(colorA.xy), bytes2float2(colorA.zw), bytes2float2(colorB.xy)) * clusterCompressionLimit0.y;\n\tclusterLightData.cookie = colorB.z;\n\tclusterLightData.mask = colorB.w;\n\t#ifdef CLUSTER_TEXTURE_FLOAT\n\t\tvec4 lightPosRange = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_POSITION_RANGE);\n\t\tclusterLightData.position = lightPosRange.xyz;\n\t\tclusterLightData.range = lightPosRange.w;\n\t\tvec4 lightDir_Unused = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_SPOT_DIRECTION);\n\t\tclusterLightData.direction = lightDir_Unused.xyz;\n\t#else\n\t\tvec4 encPosX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_POSITION_X);\n\t\tvec4 encPosY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_POSITION_Y);\n\t\tvec4 encPosZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_POSITION_Z);\n\t\tclusterLightData.position = vec3(bytes2float4(encPosX), bytes2float4(encPosY), bytes2float4(encPosZ)) * clusterBoundsDelta + clusterBoundsMin;\n\t\tvec4 encRange = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_RANGE);\n\t\tclusterLightData.range = bytes2float4(encRange) * clusterCompressionLimit0.x;\n\t\tvec4 encDirX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_DIRECTION_X);\n\t\tvec4 encDirY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_DIRECTION_Y);\n\t\tvec4 encDirZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_DIRECTION_Z);\n\t\tclusterLightData.direction = vec3(bytes2float4(encDirX), bytes2float4(encDirY), bytes2float4(encDirZ)) * 2.0 - 1.0;\n\t#endif\n}\nvoid decodeClusterLightSpot(inout ClusterLightData clusterLightData) {\n\tvec4 coneAngle = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_ANGLES);\n\tclusterLightData.innerConeAngleCos = bytes2float2(coneAngle.xy) * 2.0 - 1.0;\n\tclusterLightData.outerConeAngleCos = bytes2float2(coneAngle.zw) * 2.0 - 1.0;\n}\nvoid decodeClusterLightOmniAtlasViewport(inout ClusterLightData clusterLightData) {\n\t#ifdef CLUSTER_TEXTURE_FLOAT\n\t\tclusterLightData.omniAtlasViewport = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_0).xyz;\n\t#else\n\t\tvec4 viewportA = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_ATLAS_VIEWPORT_A);\n\t\tvec4 viewportB = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_ATLAS_VIEWPORT_B);\n\t\tclusterLightData.omniAtlasViewport = vec3(bytes2float2(viewportA.xy), bytes2float2(viewportA.zw), bytes2float2(viewportB.xy));\n\t#endif\n}\nvoid decodeClusterLightAreaData(inout ClusterLightData clusterLightData) {\n\t#ifdef CLUSTER_TEXTURE_FLOAT\n\t\tclusterLightData.halfWidth = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_AREA_DATA_WIDTH).xyz;\n\t\tclusterLightData.halfHeight = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_AREA_DATA_HEIGHT).xyz;\n\t#else\n\t\tvec4 areaWidthX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_WIDTH_X);\n\t\tvec4 areaWidthY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_WIDTH_Y);\n\t\tvec4 areaWidthZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_WIDTH_Z);\n\t\tclusterLightData.halfWidth = vec3(mantissaExponent2Float(areaWidthX), mantissaExponent2Float(areaWidthY), mantissaExponent2Float(areaWidthZ));\n\t\tvec4 areaHeightX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_HEIGHT_X);\n\t\tvec4 areaHeightY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_HEIGHT_Y);\n\t\tvec4 areaHeightZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_HEIGHT_Z);\n\t\tclusterLightData.halfHeight = vec3(mantissaExponent2Float(areaHeightX), mantissaExponent2Float(areaHeightY), mantissaExponent2Float(areaHeightZ));\n\t#endif\n}\nvoid decodeClusterLightProjectionMatrixData(inout ClusterLightData clusterLightData) {\n\t#ifdef CLUSTER_TEXTURE_FLOAT\n\t\tvec4 m0 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_0);\n\t\tvec4 m1 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_1);\n\t\tvec4 m2 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_2);\n\t\tvec4 m3 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_3);\n\t#else\n\t\tvec4 m00 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_00);\n\t\tvec4 m01 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_01);\n\t\tvec4 m02 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_02);\n\t\tvec4 m03 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_03);\n\t\tvec4 m0 = decodeClusterLowRange4Vec4(m00, m01, m02, m03);\n\t\tvec4 m10 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_10);\n\t\tvec4 m11 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_11);\n\t\tvec4 m12 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_12);\n\t\tvec4 m13 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_13);\n\t\tvec4 m1 = decodeClusterLowRange4Vec4(m10, m11, m12, m13);\n\t\tvec4 m20 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_20);\n\t\tvec4 m21 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_21);\n\t\tvec4 m22 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_22);\n\t\tvec4 m23 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_23);\n\t\tvec4 m2 = decodeClusterLowRange4Vec4(m20, m21, m22, m23);\n\t\tvec4 m30 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_30);\n\t\tvec4 m31 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_31);\n\t\tvec4 m32 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_32);\n\t\tvec4 m33 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_33);\n\t\tvec4 m3 = vec4(mantissaExponent2Float(m30), mantissaExponent2Float(m31), mantissaExponent2Float(m32), mantissaExponent2Float(m33));\n\t#endif\n\tlightProjectionMatrix = mat4(m0, m1, m2, m3);\n}\nvoid decodeClusterLightShadowData(inout ClusterLightData clusterLightData) {\n\tvec4 biases = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SHADOW_BIAS);\n\tclusterLightData.shadowBias = bytes2floatRange2(biases.xy, -1.0, 20.0),\n\tclusterLightData.shadowNormalBias = bytes2float2(biases.zw);\n}\nvoid decodeClusterLightCookieData(inout ClusterLightData clusterLightData) {\n\tvec4 cookieA = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COOKIE_A);\n\tclusterLightData.cookieIntensity = cookieA.x;\n\tclusterLightData.cookieRgb = cookieA.y;\n\tclusterLightData.cookieChannelMask = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COOKIE_B);\n}\nvoid evaluateLight(ClusterLightData light) {\n\tdAtten3 = vec3(1.0);\n\tgetLightDirPoint(light.position);\n\t#ifdef CLUSTER_AREALIGHTS\n\tif (isClusteredLightArea(light)) {\n\t\tdecodeClusterLightAreaData(light);\n\t\tif (LTCLightValuesEvaluated < 0.5) {\n\t\t\tLTCLightValuesEvaluated = 1.0;\n\t\t\tcalcLTCLightValues();\n\t\t}\n\t\tif (isClusteredLightRect(light)) {\n\t\t\tcalcRectLightValues(light.position, light.halfWidth, light.halfHeight);\n\t\t} else if (isClusteredLightDisk(light)) {\n\t\t\tcalcDiskLightValues(light.position, light.halfWidth, light.halfHeight);\n\t\t} else {\n\t\t\tcalcSphereLightValues(light.position, light.halfWidth, light.halfHeight);\n\t\t}\n\t\tdAtten = getFalloffWindow(light.range);\n\t} else\n\t#endif\n\t{\n\t\tif (isClusteredLightFalloffLinear(light))\n\t\t\tdAtten = getFalloffLinear(light.range);\n\t\telse\n\t\t\tdAtten = getFalloffInvSquared(light.range);\n\t}\n\tif (dAtten > 0.00001) {\n\t\t#ifdef CLUSTER_AREALIGHTS\n\t\tif (isClusteredLightArea(light)) {\n\t\t\tif (isClusteredLightRect(light)) {\n\t\t\t\tdAttenD = getRectLightDiffuse() * 16.0;\n\t\t\t} else if (isClusteredLightDisk(light)) {\n\t\t\t\tdAttenD = getDiskLightDiffuse() * 16.0;\n\t\t\t} else {\n\t\t\t\tdAttenD = getSphereLightDiffuse() * 16.0;\n\t\t\t}\n\t\t} else\n\t\t#endif\n\t\t{\n\t\t\tdAtten *= getLightDiffuse();\n\t\t}\n\t\tif (isClusteredLightSpot(light)) {\n\t\t\tdecodeClusterLightSpot(light);\n\t\t\tdAtten *= getSpotEffect(light.direction, light.innerConeAngleCos, light.outerConeAngleCos);\n\t\t}\n\t\t#if defined(CLUSTER_COOKIES) || defined(CLUSTER_SHADOWS)\n\t\tif (dAtten > 0.00001) {\n\t\t\tif (isClusteredLightCastShadow(light) || isClusteredLightCookie(light)) {\n\t\t\t\tif (isClusteredLightSpot(light)) {\n\t\t\t\t\tdecodeClusterLightProjectionMatrixData(light);\n\t\t\t\t} else {\n\t\t\t\t\tdecodeClusterLightOmniAtlasViewport(light);\n\t\t\t\t}\n\t\t\t\tfloat shadowTextureResolution = shadowAtlasParams.x;\n\t\t\t\tfloat shadowEdgePixels = shadowAtlasParams.y;\n\t\t\t\t#ifdef CLUSTER_COOKIES\n\t\t\t\tif (isClusteredLightCookie(light)) {\n\t\t\t\t\tdecodeClusterLightCookieData(light);\n\t\t\t\t\tif (isClusteredLightSpot(light)) {\n\t\t\t\t\t\tdAtten3 = getCookie2DClustered(cookieAtlasTexture, lightProjectionMatrix, vPositionW, light.cookieIntensity, isClusteredLightCookieRgb(light), light.cookieChannelMask);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdAtten3 = getCookieCubeClustered(cookieAtlasTexture, dLightDirW, light.cookieIntensity, isClusteredLightCookieRgb(light), light.cookieChannelMask, shadowTextureResolution, shadowEdgePixels, light.omniAtlasViewport);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t#endif\n\t\t\t\t#ifdef CLUSTER_SHADOWS\n\t\t\t\tif (isClusteredLightCastShadow(light)) {\n\t\t\t\t\tdecodeClusterLightShadowData(light);\n\t\t\t\t\tvec4 shadowParams = vec4(shadowTextureResolution, light.shadowNormalBias, light.shadowBias, 1.0 / light.range);\n\t\t\t\t\tif (isClusteredLightSpot(light)) {\n\t\t\t\t\t\tgetShadowCoordPerspZbufferNormalOffset(lightProjectionMatrix, shadowParams);\n\t\t\t\t\t\t#if defined(CLUSTER_SHADOW_TYPE_PCF1)\n\t\t\t\t\t\t\tdAtten *= getShadowSpotClusteredPCF1(shadowAtlasTexture, shadowParams);\n\t\t\t\t\t\t#elif defined(CLUSTER_SHADOW_TYPE_PCF3)\n\t\t\t\t\t\t\tdAtten *= getShadowSpotClusteredPCF3(shadowAtlasTexture, shadowParams);\n\t\t\t\t\t\t#elif defined(CLUSTER_SHADOW_TYPE_PCF5)\n\t\t\t\t\t\t\tdAtten *= getShadowSpotClusteredPCF5(shadowAtlasTexture, shadowParams);\n\t\t\t\t\t\t#endif\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnormalOffsetPointShadow(shadowParams);\n\t\t\t\t\t\t#if defined(CLUSTER_SHADOW_TYPE_PCF1)\n\t\t\t\t\t\t\tdAtten *= getShadowOmniClusteredPCF1(shadowAtlasTexture, shadowParams, light.omniAtlasViewport, shadowEdgePixels, dLightDirW);\n\t\t\t\t\t\t#elif defined(CLUSTER_SHADOW_TYPE_PCF3)\n\t\t\t\t\t\t\tdAtten *= getShadowOmniClusteredPCF3(shadowAtlasTexture, shadowParams, light.omniAtlasViewport, shadowEdgePixels, dLightDirW);\n\t\t\t\t\t\t#elif defined(CLUSTER_SHADOW_TYPE_PCF5)\n\t\t\t\t\t\t\tdAtten *= getShadowOmniClusteredPCF5(shadowAtlasTexture, shadowParams, light.omniAtlasViewport, shadowEdgePixels, dLightDirW);\n\t\t\t\t\t\t#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t#endif\n\t\t\t}\n\t\t}\n\t\t#endif\n\t\t#ifdef CLUSTER_AREALIGHTS\n\t\tif (isClusteredLightArea(light)) {\n\t\t\t{\n\t\t\t\tvec3 areaDiffuse = (dAttenD * dAtten) * light.color * dAtten3;\n\t\t\t\t#if defined(CLUSTER_SPECULAR) && defined(CLUSTER_CONSERVE_ENERGY)\n\t\t\t\t\tareaDiffuse = mix(areaDiffuse, vec3(0), dLTCSpecFres);\n\t\t\t\t#endif\n\t\t\t\tdDiffuseLight += areaDiffuse;\n\t\t\t}\n\t\t\t#ifdef CLUSTER_SPECULAR\n\t\t\t\tfloat areaLightSpecular;\n\t\t\t\tif (isClusteredLightRect(light)) {\n\t\t\t\t\tareaLightSpecular = getRectLightSpecular();\n\t\t\t\t} else if (isClusteredLightDisk(light)) {\n\t\t\t\t\tareaLightSpecular = getDiskLightSpecular();\n\t\t\t\t} else {\n\t\t\t\t\tareaLightSpecular = getSphereLightSpecular();\n\t\t\t\t}\n\t\t\t\tdSpecularLight += dLTCSpecFres * areaLightSpecular * dAtten * light.color * dAtten3;\n\t\t\t\t#ifdef CLUSTER_CLEAR_COAT\n\t\t\t\t\tfloat areaLightSpecularCC;\n\t\t\t\t\tif (isClusteredLightRect(light)) {\n\t\t\t\t\t\tareaLightSpecularCC = getRectLightSpecularCC();\n\t\t\t\t\t} else if (isClusteredLightDisk(light)) {\n\t\t\t\t\t\tareaLightSpecularCC = getDiskLightSpecularCC();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tareaLightSpecularCC = getSphereLightSpecularCC();\n\t\t\t\t\t}\n\t\t\t\t\tccSpecularLight += ccLTCSpecFres * areaLightSpecularCC * dAtten * light.color	* dAtten3;\n\t\t\t\t#endif\n\t\t\t#endif\n\t\t} else\n\t\t#endif\n\t\t{\n\t\t\t{\n\t\t\t\tvec3 punctualDiffuse = dAtten * light.color * dAtten3;\n\t\t\t\t#if defined(CLUSTER_AREALIGHTS) && defined(CLUSTER_SPECULAR) && defined(CLUSTER_CONSERVE_ENERGY)\n\t\t\t\t\tpunctualDiffuse = mix(punctualDiffuse, vec3(0), dSpecularity);\n\t\t\t\t#endif\n\t\t\t\tdDiffuseLight += punctualDiffuse;\n\t\t\t}\n\t\t\t#ifdef CLUSTER_SPECULAR\n\t\t\t\t{\n\t\t\t\t\tvec3 punctualSpecular = getLightSpecular() * dAtten * light.color * dAtten3;\n\t\t\t\t\t#if defined(CLUSTER_AREALIGHTS)\n\t\t\t\t\t\tpunctualSpecular *= dSpecularity;\n\t\t\t\t\t#endif\n\t\t\t\t\tdSpecularLight += punctualSpecular;\n\t\t\t\t}\n\t\t\t\t#ifdef CLUSTER_CLEAR_COAT\n\t\t\t\t\tvec3 punctualCC = getLightSpecularCC() * dAtten * light.color * dAtten3;\n\t\t\t\t\t#if defined(CLUSTER_AREALIGHTS)\n\t\t\t\t\t\tpunctualCC *= ccSpecularity;\n\t\t\t\t\t#endif\n\t\t\t\t\tccSpecularLight += punctualCC;\n\t\t\t\t#endif\n\t\t\t#endif\n\t\t}\n\t}\n}\nvoid evaluateClusterLight(float lightIndex) {\n\tClusterLightData clusterLightData;\n\tdecodeClusterLightCore(clusterLightData, lightIndex);\n\tif (acceptLightMask(clusterLightData))\n\t\tevaluateLight(clusterLightData);\n}\nvoid addClusteredLights() {\n\tvec3 cellCoords = floor((vPositionW - clusterBoundsMin) * clusterCellsCountByBoundsSize);\n\tif (!(any(lessThan(cellCoords, vec3(0.0))) || any(greaterThanEqual(cellCoords, clusterCellsMax)))) {\n\t\tfloat cellIndex = dot(clusterCellsDot, cellCoords);\n\t\tfloat clusterV = floor(cellIndex * clusterTextureSize.y);\n\t\tfloat clusterU = cellIndex - (clusterV * clusterTextureSize.x);\n\t\tclusterV = (clusterV + 0.5) * clusterTextureSize.z;\n\t\tconst float maxLightCells = 256.0 / 4.0;\n\t\tfor (float lightCellIndex = 0.5; lightCellIndex < maxLightCells; lightCellIndex++) {\n\t\t\tvec4 lightIndices = textureData(clusterWorldTexture, vec2(clusterTextureSize.y * (clusterU + lightCellIndex), clusterV));\n\t\t\tvec4 indices = lightIndices * 255.0;\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tif (indices.x <= 0.0)\n\t\t\t\t\treturn;\n\t\t\t\tevaluateClusterLight(indices.x);\n\t\t\t\tindices = indices.yzwx;\n\t\t\t}\n\t\t\tif (lightCellIndex > clusterPixelsPerCell) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n";

var combineClearCoatPS = "vec3 combineColorCC() {\n\treturn combineColor()+(ccSpecularLight*ccSpecularity+ccReflection.rgb*ccSpecularity*ccReflection.a);\n}\n";

var combineDiffusePS = "vec3 combineColor() {\n\treturn dAlbedo * dDiffuseLight;\n}\n";

var combineDiffuseSpecularPS = "vec3 combineColor() {\n\treturn mix(dAlbedo * dDiffuseLight, dSpecularLight + dReflection.rgb * dReflection.a, dSpecularity);\n}\n";

var combineDiffuseSpecularNoConservePS = "vec3 combineColor() {\n\treturn dAlbedo * dDiffuseLight + (dSpecularLight + dReflection.rgb * dReflection.a) * dSpecularity;\n}\n";

var combineDiffuseSpecularNoReflPS = "vec3 combineColor() {\n\treturn dAlbedo * dDiffuseLight + dSpecularLight * dSpecularity;\n}\n";

var combineDiffuseSpecularNoReflSeparateAmbientPS = "uniform vec3 material_ambient;\nvec3 combineColor() {\n\treturn (dDiffuseLight - light_globalAmbient) * dAlbedo + dSpecularLight * dSpecularity + material_ambient * light_globalAmbient;\n}\n";

var combineDiffuseSpecularOldPS = "vec3 combineColor() {\n\treturn mix(dAlbedo * dDiffuseLight + dSpecularLight * dSpecularity, dReflection.rgb, dReflection.a);\n}\n";

var cookiePS = "vec4 getCookie2D(sampler2D tex, mat4 transform, float intensity) {\n\tvec4 projPos = transform * vec4(vPositionW, 1.0);\n\tprojPos.xy /= projPos.w;\n\treturn mix(vec4(1.0), texture2D(tex, projPos.xy), intensity);\n}\nvec4 getCookie2DClip(sampler2D tex, mat4 transform, float intensity) {\n\tvec4 projPos = transform * vec4(vPositionW, 1.0);\n\tprojPos.xy /= projPos.w;\n\tif (projPos.x < 0.0 || projPos.x > 1.0 || projPos.y < 0.0 || projPos.y > 1.0 || projPos.z < 0.0) return vec4(0.0);\n\treturn mix(vec4(1.0), texture2D(tex, projPos.xy), intensity);\n}\nvec4 getCookie2DXform(sampler2D tex, mat4 transform, float intensity, vec4 cookieMatrix, vec2 cookieOffset) {\n\tvec4 projPos = transform * vec4(vPositionW, 1.0);\n\tprojPos.xy /= projPos.w;\n\tprojPos.xy += cookieOffset;\n\tvec2 uv = mat2(cookieMatrix) * (projPos.xy-vec2(0.5)) + vec2(0.5);\n\treturn mix(vec4(1.0), texture2D(tex, uv), intensity);\n}\nvec4 getCookie2DClipXform(sampler2D tex, mat4 transform, float intensity, vec4 cookieMatrix, vec2 cookieOffset) {\n\tvec4 projPos = transform * vec4(vPositionW, 1.0);\n\tprojPos.xy /= projPos.w;\n\tprojPos.xy += cookieOffset;\n\tif (projPos.x < 0.0 || projPos.x > 1.0 || projPos.y < 0.0 || projPos.y > 1.0 || projPos.z < 0.0) return vec4(0.0);\n\tvec2 uv = mat2(cookieMatrix) * (projPos.xy-vec2(0.5)) + vec2(0.5);\n\treturn mix(vec4(1.0), texture2D(tex, uv), intensity);\n}\nvec4 getCookieCube(samplerCube tex, mat4 transform, float intensity) {\n\treturn mix(vec4(1.0), textureCube(tex, dLightDirNormW * mat3(transform)), intensity);\n}\n";

var cubeMapProjectBoxPS = "uniform vec3 envBoxMin, envBoxMax;\nvec3 cubeMapProject(vec3 nrdir) {\n\tnrdir = cubeMapRotate(nrdir);\n\tvec3 rbmax = (envBoxMax - vPositionW) / nrdir;\n\tvec3 rbmin = (envBoxMin - vPositionW) / nrdir;\n\tvec3 rbminmax;\n\trbminmax.x = nrdir.x>0.0? rbmax.x : rbmin.x;\n\trbminmax.y = nrdir.y>0.0? rbmax.y : rbmin.y;\n\trbminmax.z = nrdir.z>0.0? rbmax.z : rbmin.z;\n\tfloat fa = min(min(rbminmax.x, rbminmax.y), rbminmax.z);\n\tvec3 posonbox = vPositionW + nrdir * fa;\n\tvec3 envBoxPos = (envBoxMin + envBoxMax) * 0.5;\n\treturn normalize(posonbox - envBoxPos);\n}\n";

var cubeMapProjectNonePS = "vec3 cubeMapProject(vec3 dir) {\n\treturn cubeMapRotate(dir);\n}\n";

var cubeMapRotatePS = "#ifdef CUBEMAP_ROTATION\nuniform mat3 cubeMapRotationMatrix;\n#endif\nvec3 cubeMapRotate(vec3 refDir) {\n#ifdef CUBEMAP_ROTATION\n\treturn refDir * cubeMapRotationMatrix;\n#else\n\treturn refDir;\n#endif\n}\n";

var decodePS = "vec3 decodeLinear(vec4 raw) {\n\treturn raw.rgb;\n}\nvec3 decodeGamma(vec4 raw) {\n\treturn pow(raw.xyz, vec3(2.2));\n}\nvec3 decodeRGBM(vec4 raw) {\n\tvec3 color = (8.0 * raw.a) * raw.rgb;\n\treturn color * color;\n}\nvec3 decodeRGBE(vec4 raw) {\n\tif (raw.a == 0.0) {\n\t\treturn vec3(0.0, 0.0, 0.0);\n\t} else {\n\t\treturn raw.xyz * pow(2.0, raw.w * 255.0 - 128.0);\n\t}\n}\nconst float PI = 3.141592653589793;\nvec2 toSpherical(vec3 dir) {\n\treturn vec2(dir.xz == vec2(0.0) ? 0.0 : atan(dir.x, dir.z), asin(dir.y));\n}\nvec2 toSphericalUv(vec3 dir) {\n\tvec2 uv = toSpherical(dir) / vec2(PI * 2.0, PI) + 0.5;\n\treturn vec2(uv.x, 1.0 - uv.y);\n}\nconst float atlasSize = 512.0;\nconst float seamSize = 1.0 / atlasSize;\nvec2 mapUv(vec2 uv, vec4 rect) {\n\treturn vec2(mix(rect.x + seamSize, rect.x + rect.z - seamSize, uv.x),\n\t\t\t\tmix(rect.y + seamSize, rect.y + rect.w - seamSize, uv.y));\n}\nvec2 mapRoughnessUv(vec2 uv, float level) {\n\tfloat t = 1.0 / exp2(level);\n\treturn mapUv(uv, vec4(0, 1.0 - t, t, t * 0.5));\n}\nvec2 mapMip(vec2 uv, float level) {\n\tfloat t = 1.0 / exp2(level);\n\treturn mapUv(uv, vec4(1.0 - t, 1.0 - t, t, t * 0.5));\n}\n";

var detailModesPS = "vec3 detailMode_mul(vec3 c1, vec3 c2) {\n\treturn c1 * c2;\n}\nvec3 detailMode_add(vec3 c1, vec3 c2) {\n\treturn c1 + c2;\n}\nvec3 detailMode_screen(vec3 c1, vec3 c2) {\n\treturn 1.0 - (1.0 - c1)*(1.0 - c2);\n}\nvec3 detailMode_overlay(vec3 c1, vec3 c2) {\n\treturn mix(1.0 - 2.0*(1.0 - c1)*(1.0 - c2), 2.0*c1*c2, step(c1, vec3(0.5)));\n}\nvec3 detailMode_min(vec3 c1, vec3 c2) {\n\treturn min(c1, c2);\n}\nvec3 detailMode_max(vec3 c1, vec3 c2) {\n\treturn max(c1, c2);\n}\n";

var diffusePS = "#ifdef MAPCOLOR\nuniform vec3 material_diffuse;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_diffuseMap;\n#endif\nvoid getAlbedo() {\n\tdAlbedo = vec3(1.0);\n\t#ifdef MAPCOLOR\n\tdAlbedo *= material_diffuse.rgb;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tdAlbedo *= gammaCorrectInput(addAlbedoDetail(texture2D(texture_diffuseMap, $UV).$CH));\n\t#endif\n\t#ifdef MAPVERTEX\n\tdAlbedo *= gammaCorrectInput(saturate(vVertexColor.$VC));\n\t#endif\n}\n";

var diffuseDetailMapPS = "#ifdef MAPTEXTURE\nuniform sampler2D texture_diffuseDetailMap;\n#endif\nvec3 addAlbedoDetail(vec3 albedo) {\n\t#ifdef MAPTEXTURE\n\tvec3 albedoDetail = vec3(texture2D(texture_diffuseDetailMap, $UV).$CH);\n\treturn detailMode_$DETAILMODE(albedo, albedoDetail);\n\t#else\n\treturn albedo;\n\t#endif\n}\n";

var dilatePS = "#define SHADER_NAME Dilate\nvarying vec2 vUv0;\nuniform sampler2D source;\nuniform vec2 pixelOffset;\nvoid main(void) {\n\tvec4 c = texture2D(source, vUv0);\n\tc = c.a>0.0? c : texture2D(source, vUv0 - pixelOffset);\n\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(0, -pixelOffset.y));\n\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(pixelOffset.x, -pixelOffset.y));\n\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(-pixelOffset.x, 0));\n\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(pixelOffset.x, 0));\n\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(-pixelOffset.x, pixelOffset.y));\n\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(0, pixelOffset.y));\n\tc = c.a>0.0? c : texture2D(source, vUv0 + pixelOffset);\n\tgl_FragColor = c;\n}\n";

var bilateralDeNoisePS = "#define SHADER_NAME BilateralDeNoise\nfloat normpdf3(in vec3 v, in float sigma) {\n\treturn 0.39894 * exp(-0.5 * dot(v, v) / (sigma * sigma)) / sigma;\n}\nvec3 decodeRGBM(vec4 rgbm) {\n\tvec3 color = (8.0 * rgbm.a) * rgbm.rgb;\n\treturn color * color;\n}\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\nvec4 encodeRGBM(vec3 color) {\n\tvec4 encoded;\n\tencoded.rgb = pow(color.rgb, vec3(0.5));\n\tencoded.rgb *= 1.0 / 8.0;\n\tencoded.a = saturate( max( max( encoded.r, encoded.g ), max( encoded.b, 1.0 / 255.0 ) ) );\n\tencoded.a = ceil(encoded.a * 255.0) / 255.0;\n\tencoded.rgb /= encoded.a;\n\treturn encoded;\n}\n#define MSIZE 15\nvarying vec2 vUv0;\nuniform sampler2D source;\nuniform vec2 pixelOffset;\nuniform vec2 sigmas;\nuniform float bZnorm;\nuniform float kernel[MSIZE];\nvoid main(void) {\n\tvec4 pixelRgbm = texture2D(source, vUv0);\n\tif (pixelRgbm.a <= 0.0) {\n\t\tgl_FragColor = pixelRgbm;\n\t\treturn ;\n\t}\n\tfloat sigma = sigmas.x;\n\tfloat bSigma = sigmas.y;\n\tvec3 pixelHdr = decodeRGBM(pixelRgbm);\n\tvec3 accumulatedHdr = vec3(0.0);\n\tfloat accumulatedFactor = 0.0;\n\tconst int kSize = (MSIZE-1)/2;\n\tfor (int i = -kSize; i <= kSize; ++i) {\n\t\tfor (int j = -kSize; j <= kSize; ++j) {\n\t\t\tvec2 coord = vUv0 + vec2(float(i), float(j)) * pixelOffset;\n\t\t\tvec4 rgbm = texture2D(source, coord);\n\t\t\tif (rgbm.a > 0.0) {\n\t\t\t\tvec3 hdr = decodeRGBM(rgbm);\n\t\t\t\tfloat factor = kernel[kSize + j] * kernel[kSize + i];\n\t\t\t\tfactor *= normpdf3(hdr - pixelHdr, bSigma) * bZnorm;\n\t\t\t\taccumulatedHdr += factor * hdr;\n\t\t\t\taccumulatedFactor += factor;\n\t\t\t}\n\t\t}\n\t}\n\tgl_FragColor = encodeRGBM(accumulatedHdr / accumulatedFactor);\n}\n";

var emissivePS = "#ifdef MAPCOLOR\nuniform vec3 material_emissive;\n#endif\n#ifdef MAPFLOAT\nuniform float material_emissiveIntensity;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_emissiveMap;\n#endif\nvec3 getEmission() {\n\tvec3 emission = vec3(1.0);\n\t#ifdef MAPFLOAT\n\temission *= material_emissiveIntensity;\n\t#endif\n\t#ifdef MAPCOLOR\n\temission *= material_emissive;\n\t#endif\n\t#ifdef MAPTEXTURE\n\temission *= $texture2DSAMPLE(texture_emissiveMap, $UV).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\temission *= gammaCorrectInput(saturate(vVertexColor.$VC));\n\t#endif\n\treturn emission;\n}\n";

var endPS = "\t#ifdef CLEARCOAT\n\tgl_FragColor.rgb = combineColorCC();\n\t#else\n\tgl_FragColor.rgb = combineColor();\n\t#endif\n\tgl_FragColor.rgb += getEmission();\n\tgl_FragColor.rgb = addFog(gl_FragColor.rgb);\n\t#ifndef HDR\n\tgl_FragColor.rgb = toneMap(gl_FragColor.rgb);\n\tgl_FragColor.rgb = gammaCorrectOutput(gl_FragColor.rgb);\n\t#endif\n";

var endVS = "\n";

var envConstPS = "vec3 processEnvironment(vec3 color) {\n\treturn color;\n}\n";

var envMultiplyPS = "uniform float skyboxIntensity;\nvec3 processEnvironment(vec3 color) {\n\treturn color * skyboxIntensity;\n}\n";

var extensionPS = "\n";

var extensionVS = "\n";

var falloffInvSquaredPS = "float getFalloffWindow(float lightRadius) {\n\tfloat sqrDist = dot(dLightDirW, dLightDirW);\n\tfloat invRadius = 1.0 / lightRadius;\n\treturn square( saturate( 1.0 - square( sqrDist * square(invRadius) ) ) );\n}\nfloat getFalloffInvSquared(float lightRadius) {\n\tfloat sqrDist = dot(dLightDirW, dLightDirW);\n\tfloat falloff = 1.0 / (sqrDist + 1.0);\n\tfloat invRadius = 1.0 / lightRadius;\n\tfalloff *= 16.0;\n\tfalloff *= square( saturate( 1.0 - square( sqrDist * square(invRadius) ) ) );\n\treturn falloff;\n}\n";

var falloffLinearPS = "float getFalloffLinear(float lightRadius) {\n\tfloat d = length(dLightDirW);\n\treturn max(((lightRadius - d) / lightRadius), 0.0);\n}\n";

var fixCubemapSeamsNonePS = "vec3 fixSeams(vec3 vec, float mipmapIndex) {\n\treturn vec;\n}\nvec3 fixSeams(vec3 vec) {\n\treturn vec;\n}\nvec3 fixSeamsStatic(vec3 vec, float invRecMipSize) {\n\treturn vec;\n}\nvec3 calcSeam(vec3 vec) {\n\treturn vec3(0);\n}\nvec3 applySeam(vec3 vec, vec3 seam, float scale) {\n\treturn vec;\n}\n";

var fixCubemapSeamsStretchPS = "vec3 fixSeams(vec3 vec, float mipmapIndex) {\n\tvec3 avec = abs(vec);\n\tfloat scale = 1.0 - exp2(mipmapIndex) / 128.0;\n\tfloat M = max(max(avec.x, avec.y), avec.z);\n\tif (avec.x != M) vec.x *= scale;\n\tif (avec.y != M) vec.y *= scale;\n\tif (avec.z != M) vec.z *= scale;\n\treturn vec;\n}\nvec3 fixSeams(vec3 vec) {\n\tvec3 avec = abs(vec);\n\tfloat scale = 1.0 - 1.0 / 128.0;\n\tfloat M = max(max(avec.x, avec.y), avec.z);\n\tif (avec.x != M) vec.x *= scale;\n\tif (avec.y != M) vec.y *= scale;\n\tif (avec.z != M) vec.z *= scale;\n\treturn vec;\n}\nvec3 fixSeamsStatic(vec3 vec, float invRecMipSize) {\n\tvec3 avec = abs(vec);\n\tfloat scale = invRecMipSize;\n\tfloat M = max(max(avec.x, avec.y), avec.z);\n\tif (avec.x != M) vec.x *= scale;\n\tif (avec.y != M) vec.y *= scale;\n\tif (avec.z != M) vec.z *= scale;\n\treturn vec;\n}\nvec3 calcSeam(vec3 vec) {\n\tvec3 avec = abs(vec);\n\tfloat M = max(avec.x, max(avec.y, avec.z));\n\treturn vec3(avec.x != M ? 1.0 : 0.0,\n\t\t\t\tavec.y != M ? 1.0 : 0.0,\n\t\t\t\tavec.z != M ? 1.0 : 0.0);\n}\nvec3 applySeam(vec3 vec, vec3 seam, float scale) {\n\treturn vec * (seam * -scale + vec3(1.0));\n}\n";

var floatUnpackingPS = "float bytes2float2(vec2 data) {\n\treturn dot(data, vec2(1.0, 1.0 / 255.0));\n}\nfloat bytes2float3(vec3 data) {\n\treturn dot(data, vec3(1.0, 1.0 / 255.0, 1.0 / 65025.0));\n}\nfloat bytes2float4(vec4 data) {\n\treturn dot(data, vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n}\nfloat bytes2floatRange2(vec2 data, float min, float max) {\n\treturn mix(min, max, bytes2float2(data));\n}\nfloat bytes2floatRange3(vec3 data, float min, float max) {\n\treturn mix(min, max, bytes2float3(data));\n}\nfloat bytes2floatRange4(vec4 data, float min, float max) {\n\treturn mix(min, max, bytes2float4(data));\n}\nfloat mantissaExponent2Float(vec4 pack)\n{\n\tfloat value = bytes2floatRange3(pack.xyz, -1.0, 1.0);\n\tfloat exponent = floor(pack.w * 255.0 - 127.0);\n\treturn value * exp2(exponent);\n}\n";

var fogExpPS = "uniform vec3 fog_color;\nuniform float fog_density;\nfloat dBlendModeFogFactor = 1.0;\nvec3 addFog(vec3 color) {\n\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\tfloat fogFactor = exp(-depth * fog_density);\n\tfogFactor = clamp(fogFactor, 0.0, 1.0);\n\treturn mix(fog_color * dBlendModeFogFactor, color, fogFactor);\n}\n";

var fogExp2PS = "uniform vec3 fog_color;\nuniform float fog_density;\nfloat dBlendModeFogFactor = 1.0;\nvec3 addFog(vec3 color) {\n\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\tfloat fogFactor = exp(-depth * depth * fog_density * fog_density);\n\tfogFactor = clamp(fogFactor, 0.0, 1.0);\n\treturn mix(fog_color * dBlendModeFogFactor, color, fogFactor);\n}\n";

var fogLinearPS = "uniform vec3 fog_color;\nuniform float fog_start;\nuniform float fog_end;\nfloat dBlendModeFogFactor = 1.0;\nvec3 addFog(vec3 color) {\n\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\tfloat fogFactor = (fog_end - depth) / (fog_end - fog_start);\n\tfogFactor = clamp(fogFactor, 0.0, 1.0);\n\tfogFactor = gammaCorrectInput(fogFactor);\n\treturn mix(fog_color * dBlendModeFogFactor, color, fogFactor);\n}\n";

var fogNonePS = "float dBlendModeFogFactor = 1.0;\nvec3 addFog(vec3 color) {\n\treturn color;\n}\n";

var fresnelSchlickPS = "uniform float material_fresnelFactor;\nvoid getFresnel() {\n\tfloat fresnel = 1.0 - max(dot(dNormalW, dViewDirW), 0.0);\n\tfloat fresnel2 = fresnel * fresnel;\n\tfresnel *= fresnel2 * fresnel2;\n\tfresnel *= dGlossiness * dGlossiness;\n\tdSpecularity = dSpecularity + (1.0 - dSpecularity) * fresnel;\n\t#ifdef CLEARCOAT\n\tfresnel = 1.0 - max(dot(ccNormalW, dViewDirW), 0.0);\n\tfresnel2 = fresnel * fresnel;\n\tfresnel *= fresnel2 * fresnel2;\n\tfresnel *= ccGlossiness * ccGlossiness;\n\tccSpecularity = ccSpecularity + (1.0 - ccSpecularity) * fresnel;\n\t#endif\n}\n";

var fullscreenQuadPS = "varying vec2 vUv0;\nuniform sampler2D source;\nvoid main(void) {\n\tgl_FragColor = texture2D(source, vUv0);\n}\n";

var fullscreenQuadVS = "attribute vec2 vertex_position;\nvarying vec2 vUv0;\nvoid main(void)\n{\n\tgl_Position = vec4(vertex_position, 0.5, 1.0);\n\tvUv0 = vertex_position.xy*0.5+0.5;\n}\n";

var gamma1_0PS = "vec4 texture2DSRGB(sampler2D tex, vec2 uv) {\n\treturn texture2D(tex, uv);\n}\nvec4 texture2DSRGB(sampler2D tex, vec2 uv, float bias) {\n\treturn texture2D(tex, uv, bias);\n}\nvec4 textureCubeSRGB(samplerCube tex, vec3 uvw) {\n\treturn textureCube(tex, uvw);\n}\nvec3 gammaCorrectOutput(vec3 color) {\n\treturn color;\n}\nvec3 gammaCorrectInput(vec3 color) {\n\treturn color;\n}\nfloat gammaCorrectInput(float color) {\n\treturn color;\n}\nvec4 gammaCorrectInput(vec4 color) {\n\treturn color;\n}\n";

var gamma2_2PS = "vec3 gammaCorrectInput(vec3 color) {\n\treturn pow(color, vec3(2.2));\n}\nfloat gammaCorrectInput(float color) {\n\treturn pow(color, 2.2);\n}\nvec4 gammaCorrectInput(vec4 color) {\n\treturn vec4(pow(color.rgb, vec3(2.2)), color.a);\n}\nvec4 texture2DSRGB(sampler2D tex, vec2 uv) {\n\tvec4 rgba = texture2D(tex, uv);\n\trgba.rgb = gammaCorrectInput(rgba.rgb);\n\treturn rgba;\n}\nvec4 texture2DSRGB(sampler2D tex, vec2 uv, float bias) {\n\tvec4 rgba = texture2D(tex, uv, bias);\n\trgba.rgb = gammaCorrectInput(rgba.rgb);\n\treturn rgba;\n}\nvec4 textureCubeSRGB(samplerCube tex, vec3 uvw) {\n\tvec4 rgba = textureCube(tex, uvw);\n\trgba.rgb = gammaCorrectInput(rgba.rgb);\n\treturn rgba;\n}\nvec3 gammaCorrectOutput(vec3 color) {\n\t#ifdef HDR\n\treturn color;\n\t#else\n\tcolor += vec3(0.0000001);\n\treturn pow(color, vec3(0.45));\n\t#endif\n}\n";

var gles3PS = "#define varying in\nout highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\n#define GL2\n#define SUPPORTS_TEXLOD\n";

var gles3VS = "#define attribute in\n#define varying out\n#define texture2D texture\n#define GL2\n#define VERTEXSHADER\n";

var glossPS = "#ifdef MAPFLOAT\nuniform float material_shininess;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_glossMap;\n#endif\nvoid getGlossiness() {\n\tdGlossiness = 1.0;\n\t#ifdef MAPFLOAT\n\tdGlossiness *= material_shininess;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tdGlossiness *= texture2D(texture_glossMap, $UV).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tdGlossiness *= saturate(vVertexColor.$VC);\n\t#endif\n\tdGlossiness += 0.0000001;\n}\n";

var instancingVS = "attribute vec4 instance_line1;\nattribute vec4 instance_line2;\nattribute vec4 instance_line3;\nattribute vec4 instance_line4;\n";

var lightDiffuseLambertPS = "float getLightDiffuse() {\n\treturn max(dot(dNormalW, -dLightDirNormW), 0.0);\n}\n";

var lightDirPointPS = "void getLightDirPoint(vec3 lightPosW) {\n\tdLightDirW = vPositionW - lightPosW;\n\tdLightDirNormW = normalize(dLightDirW);\n\tdLightPosW = lightPosW;\n}\n";

var lightmapDirPS = "uniform sampler2D texture_lightMap;\nuniform sampler2D texture_dirLightMap;\nvoid addLightMap() {\n\tvec3 color = $texture2DSAMPLE(texture_lightMap, $UV).$CH;\n\tvec3 dir = texture2D(texture_dirLightMap, $UV).xyz;\n\tif (dot(dir, vec3(1.0)) < 0.00001) {\n\t\tdDiffuseLight += color;\n\t} else {\n\t\tdLightDirNormW = normalize(dir * 2.0 - vec3(1.0));\n\t\tfloat vlight = saturate(dot(dLightDirNormW, -dVertexNormalW));\n\t\tfloat flight = saturate(dot(dLightDirNormW, -dNormalW));\n\t\tfloat nlight = (flight / max(vlight, 0.01)) * 0.5;\n\t\tdDiffuseLight += color * nlight * 2.0;\n\t}\n\tdSpecularLight += color * getLightSpecular();\n}\n";

var lightmapSinglePS = "#ifdef MAPTEXTURE\nuniform sampler2D texture_lightMap;\n#endif\nvoid addLightMap() {\n\tvec3 lm = vec3(1.0);\n\t#ifdef MAPTEXTURE\n\tlm *= $texture2DSAMPLE(texture_lightMap, $UV).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tlm *= saturate(vVertexColor.$VC);\n\t#endif\n\tdDiffuseLight += lm;\n}\n";

var lightmapSingleVertPS = "void addLightMap() {\n\tdDiffuseLight += saturate(vVertexColor.$CH);\n}\n";

var lightSpecularAnisoGGXPS = "float calcLightSpecular(float tGlossiness, vec3 tNormalW) {\n\tfloat PI = 3.141592653589793;\n\tfloat roughness = max((1.0 - tGlossiness) * (1.0 - tGlossiness), 0.001);\n\tfloat anisotropy = material_anisotropy * roughness;\n\tfloat at = max((roughness + anisotropy), roughness / 4.0);\n\tfloat ab = max((roughness - anisotropy), roughness / 4.0);\n\tvec3 h = normalize(normalize(-dLightDirNormW) + normalize(dViewDirW));\n\tfloat NoH = dot(tNormalW, h);\n\tfloat ToH = dot(dTBN[0], h);\n\tfloat BoH = dot(dTBN[1], h);\n\tfloat a2 = at * ab;\n\tvec3 v = vec3(ab * ToH, at * BoH, a2 * NoH);\n\tfloat v2 = dot(v, v);\n\tfloat w2 = a2 / v2;\n\tfloat D = a2 * w2 * w2 * (1.0 / PI);\n\tfloat ToV = dot(dTBN[0], dViewDirW);\n\tfloat BoV = dot(dTBN[1], dViewDirW);\n\tfloat ToL = dot(dTBN[0], -dLightDirNormW);\n\tfloat BoL = dot(dTBN[1], -dLightDirNormW);\n\tfloat NoV = dot(tNormalW, dViewDirW);\n\tfloat NoL = dot(tNormalW, -dLightDirNormW);\n\tfloat lambdaV = NoL * length(vec3(at * ToV, ab * BoV, NoV));\n\tfloat lambdaL = NoV * length(vec3(at * ToL, ab * BoL, NoL));\n\tfloat G = 0.5 / (lambdaV + lambdaL);\n\treturn D * G;\n}\nfloat getLightSpecular() {\n\treturn calcLightSpecular(dGlossiness, dNormalW);\n}\nfloat getLightSpecularCC() {\n\treturn calcLightSpecular(ccGlossiness, ccNormalW);\n}\n";

var lightSpecularBlinnPS = "float calcLightSpecular(float tGlossiness, vec3 tNormalW) {\n\tvec3 h = normalize( -dLightDirNormW + dViewDirW );\n\tfloat nh = max( dot( h, tNormalW ), 0.0 );\n\tfloat specPow = exp2(tGlossiness * 11.0);\n\tspecPow = antiAliasGlossiness(specPow);\n\tspecPow = max(specPow, 0.0001);\n\treturn pow(nh, specPow) * (specPow + 2.0) / 8.0;\n}\nfloat getLightSpecular() {\n\treturn calcLightSpecular(dGlossiness, dNormalW);\n}\nfloat getLightSpecularCC() {\n\treturn calcLightSpecular(ccGlossiness, ccNormalW);\n}\n";

var lightSpecularPhongPS = "float calcLightSpecular(float tGlossiness, vec3 tReflDirW) {\n\tfloat specPow = tGlossiness;\n\tspecPow = antiAliasGlossiness(specPow);\n\treturn pow(max(dot(tReflDirW, -dLightDirNormW), 0.0), specPow + 0.0001);\n}\nfloat getLightSpecular() {\n\treturn calcLightSpecular(dGlossiness, dReflDirW);\n}\nfloat getLightSpecularCC() {\n\treturn calcLightSpecular(ccGlossiness, ccReflDirW);\n}\n";

var ltc = "mat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nstruct Coords {\n\tvec3 coord0;\n\tvec3 coord1;\n\tvec3 coord2;\n\tvec3 coord3;\n};\nfloat LTC_EvaluateRect( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in Coords rectCoords) {\n\tvec3 v1 = rectCoords.coord1 - rectCoords.coord0;\n\tvec3 v2 = rectCoords.coord3 - rectCoords.coord0;\n\tvec3 lightNormal = cross( v1, v2 );\n\tfloat factor = sign(-dot( lightNormal, P - rectCoords.coord0 ));\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 =	factor * cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords.coord0 - P );\n\tcoords[ 1 ] = mat * ( rectCoords.coord1 - P );\n\tcoords[ 2 ] = mat * ( rectCoords.coord2 - P );\n\tcoords[ 3 ] = mat * ( rectCoords.coord3 - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn result;\n}\nCoords dLTCCoords;\nCoords getLTCLightCoords(vec3 lightPos, vec3 halfWidth, vec3 halfHeight){\n\tCoords coords;\n\tcoords.coord0 = lightPos + halfWidth - halfHeight;\n\tcoords.coord1 = lightPos - halfWidth - halfHeight;\n\tcoords.coord2 = lightPos - halfWidth + halfHeight;\n\tcoords.coord3 = lightPos + halfWidth + halfHeight;\n\treturn coords;\n}\nfloat dSphereRadius;\nCoords getSphereLightCoords(vec3 lightPos, vec3 halfWidth, vec3 halfHeight){\n\tdSphereRadius = max(length(halfWidth), length(halfHeight));\n\tvec3 f = reflect(normalize(lightPos - view_position), vNormalW);\n\tvec3 w = normalize(cross(f, halfHeight));\n\tvec3 h = normalize(cross(f, w));\n\treturn getLTCLightCoords(lightPos, w * dSphereRadius, h * dSphereRadius);\n}\nvec2 dLTCUV;\n#ifdef CLEARCOAT\nvec2 ccLTCUV;\n#endif\nvec2 getLTCLightUV(float tGlossiness, vec3 tNormalW)\n{\n\tfloat roughness = max((1.0 - tGlossiness) * (1.0 - tGlossiness), 0.001);\n\treturn LTC_Uv( tNormalW, dViewDirW, roughness );\n}\nvec3 dLTCSpecFres;\n#ifdef CLEARCOAT\nvec3 ccLTCSpecFres;\n#endif\nvec3 getLTCLightSpecFres(vec2 uv, vec3 tSpecularity)\n{\n\tvec4 t2 = texture2D( areaLightsLutTex2, uv );\n\t#ifdef AREA_R8_G8_B8_A8_LUTS\n\tt2 *= vec4(0.693103,1,1,1);\n\tt2 += vec4(0.306897,0,0,0);\n\t#endif\n\treturn tSpecularity * t2.x + ( vec3( 1.0 ) - tSpecularity) * t2.y;\n}\nvoid calcLTCLightValues()\n{\n\tdLTCUV = getLTCLightUV(dGlossiness, dNormalW);\n\tdLTCSpecFres = getLTCLightSpecFres(dLTCUV, dSpecularityNoFres);\n#ifdef CLEARCOAT\n\tccLTCUV = getLTCLightUV(ccGlossiness, ccNormalW);\n\tccLTCSpecFres = getLTCLightSpecFres(ccLTCUV, vec3(ccSpecularityNoFres));\n#endif\n}\nvoid calcRectLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)\n{\n\tdLTCCoords = getLTCLightCoords(lightPos, halfWidth, halfHeight);\n}\nvoid calcDiskLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)\n{\n\tcalcRectLightValues(lightPos, halfWidth, halfHeight);\n}\nvoid calcSphereLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)\n{\n\tdLTCCoords = getSphereLightCoords(lightPos, halfWidth, halfHeight);\n}\nvec3 SolveCubic(vec4 Coefficient)\n{\n\tfloat pi = 3.14159;\n\tCoefficient.xyz /= Coefficient.w;\n\tCoefficient.yz /= 3.0;\n\tfloat A = Coefficient.w;\n\tfloat B = Coefficient.z;\n\tfloat C = Coefficient.y;\n\tfloat D = Coefficient.x;\n\tvec3 Delta = vec3(\n\t\t-Coefficient.z * Coefficient.z + Coefficient.y,\n\t\t-Coefficient.y * Coefficient.z + Coefficient.x,\n\t\tdot(vec2(Coefficient.z, -Coefficient.y), Coefficient.xy)\n\t);\n\tfloat Discriminant = dot(vec2(4.0 * Delta.x, -Delta.y), Delta.zy);\n\tvec3 RootsA, RootsD;\n\tvec2 xlc, xsc;\n\t{\n\t\tfloat A_a = 1.0;\n\t\tfloat C_a = Delta.x;\n\t\tfloat D_a = -2.0 * B * Delta.x + Delta.y;\n\t\tfloat Theta = atan(sqrt(Discriminant), -D_a) / 3.0;\n\t\tfloat x_1a = 2.0 * sqrt(-C_a) * cos(Theta);\n\t\tfloat x_3a = 2.0 * sqrt(-C_a) * cos(Theta + (2.0 / 3.0) * pi);\n\t\tfloat xl;\n\t\tif ((x_1a + x_3a) > 2.0 * B)\n\t\t\txl = x_1a;\n\t\telse\n\t\t\txl = x_3a;\n\t\txlc = vec2(xl - B, A);\n\t}\n\t{\n\t\tfloat A_d = D;\n\t\tfloat C_d = Delta.z;\n\t\tfloat D_d = -D * Delta.y + 2.0 * C * Delta.z;\n\t\tfloat Theta = atan(D * sqrt(Discriminant), -D_d) / 3.0;\n\t\tfloat x_1d = 2.0 * sqrt(-C_d) * cos(Theta);\n\t\tfloat x_3d = 2.0 * sqrt(-C_d) * cos(Theta + (2.0 / 3.0) * pi);\n\t\tfloat xs;\n\t\tif (x_1d + x_3d < 2.0 * C)\n\t\t\txs = x_1d;\n\t\telse\n\t\t\txs = x_3d;\n\t\txsc = vec2(-D, xs + C);\n\t}\n\tfloat E =	xlc.y * xsc.y;\n\tfloat F = -xlc.x * xsc.y - xlc.y * xsc.x;\n\tfloat G =	xlc.x * xsc.x;\n\tvec2 xmc = vec2(C * F - B * G, -B * F + C * E);\n\tvec3 Root = vec3(xsc.x / xsc.y, xmc.x / xmc.y, xlc.x / xlc.y);\n\tif (Root.x < Root.y && Root.x < Root.z)\n\t\tRoot.xyz = Root.yxz;\n\telse if (Root.z < Root.x && Root.z < Root.y)\n\t\tRoot.xyz = Root.xzy;\n\treturn Root;\n}\nfloat LTC_EvaluateDisk(vec3 N, vec3 V, vec3 P, mat3 Minv, Coords points)\n{\n\tvec3 T1, T2;\n\tT1 = normalize(V - N * dot(V, N));\n\tT2 = cross(N, T1);\n\tmat3 R = transposeMat3( mat3( T1, T2, N ) );\n\tvec3 L_[ 3 ];\n\tL_[ 0 ] = R * ( points.coord0 - P );\n\tL_[ 1 ] = R * ( points.coord1 - P );\n\tL_[ 2 ] = R * ( points.coord2 - P );\n\tvec3 Lo_i = vec3(0);\n\tvec3 C	= 0.5 * (L_[0] + L_[2]);\n\tvec3 V1 = 0.5 * (L_[1] - L_[2]);\n\tvec3 V2 = 0.5 * (L_[1] - L_[0]);\n\tC	= Minv * C;\n\tV1 = Minv * V1;\n\tV2 = Minv * V2;\n\tfloat a, b;\n\tfloat d11 = dot(V1, V1);\n\tfloat d22 = dot(V2, V2);\n\tfloat d12 = dot(V1, V2);\n\tif (abs(d12) / sqrt(d11 * d22) > 0.0001)\n\t{\n\t\tfloat tr = d11 + d22;\n\t\tfloat det = -d12 * d12 + d11 * d22;\n\t\tdet = sqrt(det);\n\t\tfloat u = 0.5 * sqrt(tr - 2.0 * det);\n\t\tfloat v = 0.5 * sqrt(tr + 2.0 * det);\n\t\tfloat e_max = (u + v) * (u + v);\n\t\tfloat e_min = (u - v) * (u - v);\n\t\tvec3 V1_, V2_;\n\t\tif (d11 > d22)\n\t\t{\n\t\t\tV1_ = d12 * V1 + (e_max - d11) * V2;\n\t\t\tV2_ = d12 * V1 + (e_min - d11) * V2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tV1_ = d12*V2 + (e_max - d22)*V1;\n\t\t\tV2_ = d12*V2 + (e_min - d22)*V1;\n\t\t}\n\t\ta = 1.0 / e_max;\n\t\tb = 1.0 / e_min;\n\t\tV1 = normalize(V1_);\n\t\tV2 = normalize(V2_);\n\t}\n\telse\n\t{\n\t\ta = 1.0 / dot(V1, V1);\n\t\tb = 1.0 / dot(V2, V2);\n\t\tV1 *= sqrt(a);\n\t\tV2 *= sqrt(b);\n\t}\n\tvec3 V3 = cross(V1, V2);\n\tif (dot(C, V3) < 0.0)\n\t\tV3 *= -1.0;\n\tfloat L	= dot(V3, C);\n\tfloat x0 = dot(V1, C) / L;\n\tfloat y0 = dot(V2, C) / L;\n\tfloat E1 = inversesqrt(a);\n\tfloat E2 = inversesqrt(b);\n\ta *= L * L;\n\tb *= L * L;\n\tfloat c0 = a * b;\n\tfloat c1 = a * b * (1.0 + x0 * x0 + y0 * y0) - a - b;\n\tfloat c2 = 1.0 - a * (1.0 + x0 * x0) - b * (1.0 + y0 * y0);\n\tfloat c3 = 1.0;\n\tvec3 roots = SolveCubic(vec4(c0, c1, c2, c3));\n\tfloat e1 = roots.x;\n\tfloat e2 = roots.y;\n\tfloat e3 = roots.z;\n\tvec3 avgDir = vec3(a * x0 / (a - e2), b * y0 / (b - e2), 1.0);\n\tmat3 rotate = mat3(V1, V2, V3);\n\tavgDir = rotate * avgDir;\n\tavgDir = normalize(avgDir);\n\tfloat L1 = sqrt(-e2 / e3);\n\tfloat L2 = sqrt(-e2 / e1);\n\tfloat formFactor = L1 * L2 * inversesqrt((1.0 + L1 * L1) * (1.0 + L2 * L2));\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tvec2 uv = vec2(avgDir.z * 0.5 + 0.5, formFactor);\n\tuv = uv*LUT_SCALE + LUT_BIAS;\n\tfloat scale = texture2D( areaLightsLutTex2, uv ).w;\n\treturn formFactor*scale;\n}\nfloat getRectLightDiffuse() {\n\treturn LTC_EvaluateRect( dNormalW, dViewDirW, vPositionW, mat3( 1.0 ), dLTCCoords );\n}\nfloat getDiskLightDiffuse() {\n\treturn LTC_EvaluateDisk( dNormalW, dViewDirW, vPositionW, mat3( 1.0 ), dLTCCoords );\n}\nfloat getSphereLightDiffuse() {\n\tfloat falloff = dSphereRadius / (dot(dLightDirW, dLightDirW) + dSphereRadius);\n\treturn getLightDiffuse()*falloff;\n}\nmat3 getLTCLightInvMat(vec2 uv)\n{\n\tvec4 t1 = texture2D( areaLightsLutTex1, uv );\n\t#ifdef AREA_R8_G8_B8_A8_LUTS\n\tt1 *= vec4(1.001, 0.3239, 0.60437568, 1.0);\n\tt1 += vec4(0.0, -0.2976, -0.01381, 0.0);\n\t#endif\n\treturn mat3(\n\t\tvec3( t1.x, 0, t1.y ),\n\t\tvec3(\t0, 1,\t0 ),\n\t\tvec3( t1.z, 0, t1.w )\n\t);\n}\nfloat calcRectLightSpecular(vec3 tNormalW, vec2 uv) {\n\tmat3 mInv = getLTCLightInvMat(uv);\n\treturn LTC_EvaluateRect( tNormalW, dViewDirW, vPositionW, mInv, dLTCCoords );\n}\nfloat getRectLightSpecular() {\n\treturn calcRectLightSpecular(dNormalW, dLTCUV);\n}\n#ifdef CLEARCOAT\nfloat getRectLightSpecularCC() {\n\treturn calcRectLightSpecular(ccNormalW, ccLTCUV);\n}\n#endif\nfloat calcDiskLightSpecular(vec3 tNormalW, vec2 uv) {\n\tmat3 mInv = getLTCLightInvMat(uv);\n\treturn LTC_EvaluateDisk( tNormalW, dViewDirW, vPositionW, mInv, dLTCCoords );\n}\nfloat getDiskLightSpecular() {\n\treturn calcDiskLightSpecular(dNormalW, dLTCUV);\n}\n#ifdef CLEARCOAT\nfloat getDiskLightSpecularCC() {\n\treturn calcDiskLightSpecular(ccNormalW, ccLTCUV);\n}\n#endif\nfloat getSphereLightSpecular() {\n\treturn calcDiskLightSpecular(dNormalW, dLTCUV);\n}\n#ifdef CLEARCOAT\nfloat getSphereLightSpecularCC() {\n\treturn calcDiskLightSpecular(ccNormalW, ccLTCUV);\n}\n#endif\n";

var metalnessPS = "void processMetalness(float metalness) {\n\tconst float dielectricF0 = 0.04;\n\tdSpecularity = mix(vec3(dielectricF0), dAlbedo, metalness);\n\tdAlbedo *= 1.0 - metalness;\n}\n#ifdef MAPFLOAT\nuniform float material_metalness;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_metalnessMap;\n#endif\nvoid getSpecularity() {\n\tfloat metalness = 1.0;\n\t#ifdef MAPFLOAT\n\tmetalness *= material_metalness;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tmetalness *= texture2D(texture_metalnessMap, $UV).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tmetalness *= saturate(vVertexColor.$VC);\n\t#endif\n\tprocessMetalness(metalness);\n}\n";

var msdfPS = "uniform sampler2D texture_msdfMap;\n#ifdef GL_OES_standard_derivatives\n#define USE_FWIDTH\n#endif\n#ifdef GL2\n#define USE_FWIDTH\n#endif\nfloat median(float r, float g, float b) {\n\treturn max(min(r, g), min(max(r, g), b));\n}\nfloat map (float min, float max, float v) {\n\treturn (v - min) / (max - min);\n}\nuniform float font_sdfIntensity;\nuniform float font_pxrange;\nuniform float font_textureWidth;\nuniform vec4 outline_color;\nuniform float outline_thickness;\nuniform vec4 shadow_color;\nuniform vec2 shadow_offset;\nvec4 applyMsdf(vec4 color) {\n\tvec3 tsample = texture2D(texture_msdfMap, vUv0).rgb;\n\tvec2 uvShdw = vUv0 - shadow_offset;\n\tvec3 ssample = texture2D(texture_msdfMap, uvShdw).rgb;\n\tfloat sigDist = median(tsample.r, tsample.g, tsample.b);\n\tfloat sigDistShdw = median(ssample.r, ssample.g, ssample.b);\n\tfloat smoothingMax = 0.2;\n\t#ifdef USE_FWIDTH\n\tvec2 w = fwidth(vUv0);\n\tfloat smoothing = clamp(w.x * font_textureWidth / font_pxrange, 0.0, smoothingMax);\n\t#else\n\tfloat font_size = 16.0;\n\tfloat smoothing = clamp(font_pxrange / font_size, 0.0, smoothingMax);\n\t#endif\n\tfloat mapMin = 0.05;\n\tfloat mapMax = clamp(1.0 - font_sdfIntensity, mapMin, 1.0);\n\tfloat sigDistInner = map(mapMin, mapMax, sigDist);\n\tfloat sigDistOutline = map(mapMin, mapMax, sigDist + outline_thickness);\n\tsigDistShdw = map(mapMin, mapMax, sigDistShdw + outline_thickness);\n\tfloat center = 0.5;\n\tfloat inside = smoothstep(center-smoothing, center+smoothing, sigDistInner);\n\tfloat outline = smoothstep(center-smoothing, center+smoothing, sigDistOutline);\n\tfloat shadow = smoothstep(center-smoothing, center+smoothing, sigDistShdw);\n\tvec4 tcolor = (outline > inside) ? outline * vec4(outline_color.a * outline_color.rgb, outline_color.a) : vec4(0.0);\n\ttcolor = mix(tcolor, color, inside);\n\tvec4 scolor = (shadow > outline) ? shadow * vec4(shadow_color.a * shadow_color.rgb, shadow_color.a) : tcolor;\n\ttcolor = mix(scolor, tcolor, outline);\n\treturn tcolor;\n}\n";

var normalVS = "#ifdef MORPHING_TEXTURE_BASED_NORMAL\nuniform highp sampler2D morphNormalTex;\n#endif\nvec3 getNormal() {\n\t#ifdef SKIN\n\tdNormalMatrix = mat3(dModelMatrix[0].xyz, dModelMatrix[1].xyz, dModelMatrix[2].xyz);\n\t#elif defined(INSTANCING)\n\tdNormalMatrix = mat3(instance_line1.xyz, instance_line2.xyz, instance_line3.xyz);\n\t#else\n\tdNormalMatrix = matrix_normal;\n\t#endif\n\tvec3 tempNormal = vertex_normal;\n\t#ifdef MORPHING\n\t#ifdef MORPHING_NRM03\n\ttempNormal += morph_weights_a[0] * morph_nrm0;\n\ttempNormal += morph_weights_a[1] * morph_nrm1;\n\ttempNormal += morph_weights_a[2] * morph_nrm2;\n\ttempNormal += morph_weights_a[3] * morph_nrm3;\n\t#endif\n\t#ifdef MORPHING_NRM47\n\ttempNormal += morph_weights_b[0] * morph_nrm4;\n\ttempNormal += morph_weights_b[1] * morph_nrm5;\n\ttempNormal += morph_weights_b[2] * morph_nrm6;\n\ttempNormal += morph_weights_b[3] * morph_nrm7;\n\t#endif\n\t#endif\n\t#ifdef MORPHING_TEXTURE_BASED_NORMAL\n\tvec2 morphUV = getTextureMorphCoords();\n\tvec3 morphNormal = texture2D(morphNormalTex, morphUV).xyz;\n\ttempNormal += morphNormal;\n\t#endif\n\treturn normalize(dNormalMatrix * tempNormal);\n}\n";

var normalDetailMapPS = "#ifdef MAPTEXTURE\nuniform sampler2D texture_normalDetailMap;\nuniform float material_normalDetailMapBumpiness;\nvec3 blendNormals(vec3 n1, vec3 n2) {\n\tn1 += vec3(0, 0, 1);\n\tn2 *= vec3(-1, -1, 1);\n\treturn normalize(n1*dot(n1, n2)/n1.z - n2);\n}\n#endif\nvec3 addNormalDetail(vec3 normalMap) {\n\t#ifdef MAPTEXTURE\n\tvec3 normalDetailMap = unpackNormal(texture2D(texture_normalDetailMap, $UV));\n\tnormalDetailMap = normalize(mix(vec3(0.0, 0.0, 1.0), normalDetailMap, material_normalDetailMapBumpiness));\n\treturn blendNormals(normalMap, normalDetailMap);\n\t#else\n\treturn normalMap;\n\t#endif\n}\n";

var normalInstancedVS = "vec3 getNormal() {\n\tdNormalMatrix = mat3(instance_line1.xyz, instance_line2.xyz, instance_line3.xyz);\n\treturn normalize(dNormalMatrix * vertex_normal);\n}\n";

var normalMapPS = "uniform sampler2D texture_normalMap;\nuniform float material_bumpiness;\nvoid getNormal() {\n\tvec3 normalMap = unpackNormal(texture2D(texture_normalMap, $UV));\n\tnormalMap = normalize(mix(vec3(0.0, 0.0, 1.0), normalMap, material_bumpiness));\n\tdNormalMap = addNormalDetail(normalMap);\n\tdNormalW = dTBN * dNormalMap;\n}\n";

var normalMapFastPS = "uniform sampler2D texture_normalMap;\nvoid getNormal() {\n\tvec3 normalMap = unpackNormal(texture2D(texture_normalMap, $UV));\n\tdNormalMap = addNormalDetail(normalMap);\n\tdNormalW = dTBN * dNormalMap;\n}\n";

var normalSkinnedVS = "vec3 getNormal() {\n\tdNormalMatrix = mat3(dModelMatrix[0].xyz, dModelMatrix[1].xyz, dModelMatrix[2].xyz);\n\treturn normalize(dNormalMatrix * vertex_normal);\n}\n";

var normalVertexPS = "void getNormal() {\n\tdNormalW = normalize(dVertexNormalW);\n}\n";

var normalXYPS = "vec3 unpackNormal(vec4 nmap) {\n\tvec3 normal;\n\tnormal.xy = nmap.wy * 2.0 - 1.0;\n\tnormal.z = sqrt(1.0 - saturate(dot(normal.xy, normal.xy)));\n\treturn normal;\n}\n";

var normalXYZPS = "vec3 unpackNormal(vec4 nmap) {\n\treturn nmap.xyz * 2.0 - 1.0;\n}\n";

var opacityPS = "#ifdef MAPFLOAT\nuniform float material_opacity;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_opacityMap;\n#endif\nvoid getOpacity() {\n\tdAlpha = 1.0;\n\t#ifdef MAPFLOAT\n\tdAlpha *= material_opacity;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tdAlpha *= texture2D(texture_opacityMap, $UV).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tdAlpha *= clamp(vVertexColor.$VC, 0.0, 1.0);\n\t#endif\n}\n";

var outputAlphaPS = "gl_FragColor.a = dAlpha;\n";

var outputAlphaOpaquePS = "gl_FragColor.a = 1.0;\n";

var outputAlphaPremulPS = "gl_FragColor.rgb *= dAlpha;\ngl_FragColor.a = dAlpha;\n";

var outputCubemapPS = "varying vec2 vUv0;\nuniform samplerCube source;\nuniform vec4 params;\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\nvec4 encodeRGBM(vec4 color) {\n\tcolor.rgb = pow(color.rgb, vec3(0.5));\n\tcolor.rgb *= 1.0 / 8.0;\n\tcolor.a = saturate( max( max( color.r, color.g ), max( color.b, 1.0 / 255.0 ) ) );\n\tcolor.a = ceil(color.a * 255.0) / 255.0;\n\tcolor.rgb /= color.a;\n\treturn color;\n}\nvoid main(void) {\n\tvec2 st = vUv0 * 2.0 - 1.0;\n\tfloat face = params.x;\n\tvec3 vec;\n\tif (face==0.0) {\n\t\tvec = vec3(1, -st.y, -st.x);\n\t} else if (face==1.0) {\n\t\tvec = vec3(-1, -st.y, st.x);\n\t} else if (face==2.0) {\n\t\tvec = vec3(st.x, 1, st.y);\n\t} else if (face==3.0) {\n\t\tvec = vec3(st.x, -1, -st.y);\n\t} else if (face==4.0) {\n\t\tvec = vec3(st.x, -st.y, 1);\n\t} else {\n\t\tvec = vec3(-st.x, -st.y, -1);\n\t}\n\tgl_FragColor = textureCube(source, vec);\n\tif (params.w >= 2.0) gl_FragColor = encodeRGBM(gl_FragColor);\n}\n";

var outputTex2DPS = "varying vec2 vUv0;\nuniform sampler2D source;\nvoid main(void) {\n\tgl_FragColor = texture2D(source, vUv0);\n}\n";

var packDepthPS = "vec4 packFloat(float depth) {\n\tconst vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);\n\tconst vec4 bit_mask	= vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\n\tvec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);\n\tres -= res.xxyz * bit_mask;\n\treturn res;\n}\n";

var packDepthMaskPS = "vec4 packFloat(float depth) {\n\tconst vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);\n\tconst vec4 bit_mask	= vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\n\tvec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);\n\tres.x = 0.0;\n\tres -= res.xxyz * bit_mask;\n\treturn res;\n}\n";

var parallaxPS = "uniform sampler2D texture_heightMap;\nuniform float material_heightMapFactor;\nvoid getParallax() {\n\tfloat parallaxScale = material_heightMapFactor;\n\tfloat height = texture2D(texture_heightMap, $UV).$CH;\n\theight = height * parallaxScale - parallaxScale*0.5;\n\tvec3 viewDirT = dViewDirW * dTBN;\n\tviewDirT.z += 0.42;\n\tdUvOffset = height * (viewDirT.xy / viewDirT.z);\n}\n";

var particlePS = "varying vec4 texCoordsAlphaLife;\nuniform sampler2D colorMap;\nuniform sampler2D colorParam;\nuniform float graphSampleSize;\nuniform float graphNumSamples;\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params;\n#endif\nuniform float softening;\nuniform float colorMult;\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\n#ifndef UNPACKFLOAT\n#define UNPACKFLOAT\nfloat unpackFloat(vec4 rgbaDepth) {\n\tconst vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n\tfloat depth = dot(rgbaDepth, bitShift);\n\treturn depth;\n}\n#endif\nvoid main(void) {\n\tvec4 tex	= texture2DSRGB(colorMap, vec2(texCoordsAlphaLife.x, 1.0 - texCoordsAlphaLife.y));\n\tvec4 ramp = texture2DSRGB(colorParam, vec2(texCoordsAlphaLife.w, 0.0));\n\tramp.rgb *= colorMult;\n\tramp.a += texCoordsAlphaLife.z;\n\tvec3 rgb = tex.rgb * ramp.rgb;\n\tfloat a	= tex.a * ramp.a;\n";

var particleVS = "vec3 unpack3NFloats(float src) {\n\tfloat r = fract(src);\n\tfloat g = fract(src * 256.0);\n\tfloat b = fract(src * 65536.0);\n\treturn vec3(r, g, b);\n}\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\nvec4 tex1Dlod_lerp(highp sampler2D tex, vec2 tc) {\n\treturn mix( texture2D(tex,tc), texture2D(tex,tc + graphSampleSize), fract(tc.x*graphNumSamples) );\n}\nvec4 tex1Dlod_lerp(highp sampler2D tex, vec2 tc, out vec3 w) {\n\tvec4 a = texture2D(tex,tc);\n\tvec4 b = texture2D(tex,tc + graphSampleSize);\n\tfloat c = fract(tc.x*graphNumSamples);\n\tvec3 unpackedA = unpack3NFloats(a.w);\n\tvec3 unpackedB = unpack3NFloats(b.w);\n\tw = mix(unpackedA, unpackedB, c);\n\treturn mix(a, b, c);\n}\nvec2 rotate(vec2 quadXY, float pRotation, out mat2 rotMatrix) {\n\tfloat c = cos(pRotation);\n\tfloat s = sin(pRotation);\n\tmat2 m = mat2(c, -s, s, c);\n\trotMatrix = m;\n\treturn m * quadXY;\n}\nvec3 billboard(vec3 InstanceCoords, vec2 quadXY) {\n\t#ifdef SCREEN_SPACE\n\t\tvec3 pos = vec3(-1, 0, 0) * quadXY.x + vec3(0, -1, 0) * quadXY.y;\n\t#else\n\t\tvec3 pos = -matrix_viewInverse[0].xyz * quadXY.x + -matrix_viewInverse[1].xyz * quadXY.y;\n\t#endif\n\treturn pos;\n}\nvec3 customFace(vec3 InstanceCoords, vec2 quadXY) {\n\tvec3 pos = faceTangent * quadXY.x + faceBinorm * quadXY.y;\n\treturn pos;\n}\nvec2 safeNormalize(vec2 v) {\n\tfloat l = length(v);\n\treturn (l > 1e-06) ? v / l : v;\n}\nvoid main(void) {\n\tvec3 meshLocalPos = particle_vertexData.xyz;\n\tfloat id = floor(particle_vertexData.w);\n\tfloat rndFactor = fract(sin(id + 1.0 + seed));\n\tvec3 rndFactor3 = vec3(rndFactor, fract(rndFactor*10.0), fract(rndFactor*100.0));\n\tfloat uv = id / numParticlesPot;\n\treadInput(uv);\n#ifdef LOCAL_SPACE\n\tinVel = mat3(matrix_model) * inVel;\n#endif\n\tvec2 velocityV = safeNormalize((mat3(matrix_view) * inVel).xy);\n\tfloat particleLifetime = lifetime;\n\tif (inLife <= 0.0 || inLife > particleLifetime || !inShow) meshLocalPos = vec3(0.0);\n\tvec2 quadXY = meshLocalPos.xy;\n\tfloat nlife = clamp(inLife / particleLifetime, 0.0, 1.0);\n\tvec3 paramDiv;\n\tvec4 params = tex1Dlod_lerp(internalTex2, vec2(nlife, 0), paramDiv);\n\tfloat scale = params.y;\n\tfloat scaleDiv = paramDiv.x;\n\tfloat alphaDiv = paramDiv.z;\n\tscale += (scaleDiv * 2.0 - 1.0) * scaleDivMult * fract(rndFactor*10000.0);\n#ifndef USE_MESH\n\ttexCoordsAlphaLife = vec4(quadXY * -0.5 + 0.5, (alphaDiv * 2.0 - 1.0) * alphaDivMult * fract(rndFactor*1000.0), nlife);\n#else\n\ttexCoordsAlphaLife = vec4(particle_uv, (alphaDiv * 2.0 - 1.0) * alphaDivMult * fract(rndFactor*1000.0), nlife);\n#endif\n\tvec3 particlePos = inPos;\n\tvec3 particlePosMoved = vec3(0.0);\n\tmat2 rotMatrix;\n";

var particleAnimFrameClampVS = "\tfloat animFrame = min(floor(texCoordsAlphaLife.w * animTexParams.y) + animTexParams.x, animTexParams.z);\n";

var particleAnimFrameLoopVS = "\tfloat animFrame = floor(mod(texCoordsAlphaLife.w * animTexParams.y + animTexParams.x, animTexParams.z + 1.0));\n";

var particleAnimTexVS = "\tfloat animationIndex;\n\tif (animTexIndexParams.y == 1.0) {\n\t\tanimationIndex = floor((animTexParams.w + 1.0) * rndFactor3.z) * (animTexParams.z + 1.0);\n\t} else {\n\t\tanimationIndex = animTexIndexParams.x * (animTexParams.z + 1.0);\n\t}\n\tfloat atlasX = (animationIndex + animFrame) * animTexTilesParams.x;\n\tfloat atlasY = 1.0 - floor(atlasX + 1.0) * animTexTilesParams.y;\n\tatlasX = fract(atlasX);\n\ttexCoordsAlphaLife.xy *= animTexTilesParams.xy;\n\ttexCoordsAlphaLife.xy += vec2(atlasX, atlasY);\n";

var particleInputFloatPS = "void readInput(float uv) {\n\tvec4 tex = texture2D(particleTexIN, vec2(uv, 0.25));\n\tvec4 tex2 = texture2D(particleTexIN, vec2(uv, 0.75));\n\tinPos = tex.xyz;\n\tinVel = tex2.xyz;\n\tinAngle = (tex.w < 0.0? -tex.w : tex.w) - 1000.0;\n\tinShow = tex.w >= 0.0;\n\tinLife = tex2.w;\n}\n";

var particleInputRgba8PS = "#define PI2 6.283185307179586\nuniform vec3 inBoundsSize;\nuniform vec3 inBoundsCenter;\nuniform float maxVel;\nfloat decodeFloatRG(vec2 rg) {\n\treturn rg.y*(1.0/255.0) + rg.x;\n}\nfloat decodeFloatRGBA( vec4 rgba ) {\n	return dot( rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/160581375.0) );\n}\nvoid readInput(float uv) {\n\tvec4 tex0 = texture2D(particleTexIN, vec2(uv, 0.125));\n\tvec4 tex1 = texture2D(particleTexIN, vec2(uv, 0.375));\n\tvec4 tex2 = texture2D(particleTexIN, vec2(uv, 0.625));\n\tvec4 tex3 = texture2D(particleTexIN, vec2(uv, 0.875));\n\tinPos = vec3(decodeFloatRG(tex0.rg), decodeFloatRG(tex0.ba), decodeFloatRG(tex1.rg));\n\tinPos = (inPos - vec3(0.5)) * inBoundsSize + inBoundsCenter;\n\tinVel = tex2.xyz;\n\tinVel = (inVel - vec3(0.5)) * maxVel;\n\tinAngle = decodeFloatRG(tex1.ba) * PI2;\n\tinShow = tex2.a > 0.5;\n\tinLife = decodeFloatRGBA(tex3);\n\tfloat maxNegLife = max(lifetime, (numParticles - 1.0) * (rate+rateDiv));\n\tfloat maxPosLife = lifetime+1.0;\n\tinLife = inLife * (maxNegLife + maxPosLife) - maxNegLife;\n}\n";

var particleOutputFloatPS = "void writeOutput() {\n\tif (gl_FragCoord.y<1.0) {\n\t\tgl_FragColor = vec4(outPos, (outAngle + 1000.0) * visMode);\n\t} else {\n\t\tgl_FragColor = vec4(outVel, outLife);\n\t}\n}\n";

var particleOutputRgba8PS = "uniform vec3 outBoundsMul;\nuniform vec3 outBoundsAdd;\nvec2 encodeFloatRG( float v ) {\n\tvec2 enc = vec2(1.0, 255.0) * v;\n\tenc = fract(enc);\n\tenc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\n\treturn enc;\n}\nvec4 encodeFloatRGBA( float v ) {\n\tvec4 enc = vec4(1.0, 255.0, 65025.0, 160581375.0) * v;\n\tenc = fract(enc);\n\tenc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);\n\treturn enc;\n}\nvoid writeOutput() {\n\toutPos = outPos * outBoundsMul + outBoundsAdd;\n\toutAngle = fract(outAngle / PI2);\n\toutVel = (outVel / maxVel) + vec3(0.5);\n\tfloat maxNegLife = max(lifetime, (numParticles - 1.0) * (rate+rateDiv));\n\tfloat maxPosLife = lifetime+1.0;\n\toutLife = (outLife + maxNegLife) / (maxNegLife + maxPosLife);\n\tif (gl_FragCoord.y < 1.0) {\n\t\tgl_FragColor = vec4(encodeFloatRG(outPos.x), encodeFloatRG(outPos.y));\n\t} else if (gl_FragCoord.y < 2.0) {\n\t\tgl_FragColor = vec4(encodeFloatRG(outPos.z), encodeFloatRG(outAngle));\n\t} else if (gl_FragCoord.y < 3.0) {\n\t\tgl_FragColor = vec4(outVel, visMode*0.5+0.5);\n\t} else {\n\t\tgl_FragColor = encodeFloatRGBA(outLife);\n\t}\n}\n";

var particleUpdaterAABBPS = "uniform mat3 spawnBounds;\nuniform vec3 spawnPosInnerRatio;\nvec3 calcSpawnPosition(vec3 inBounds, float rndFactor) {\n\tvec3 pos = inBounds - vec3(0.5);\n\tvec3 posAbs = abs(pos);\n\tvec3 maxPos = vec3(max(posAbs.x, max(posAbs.y, posAbs.z)));\n\tvec3 edge = maxPos + (vec3(0.5) - maxPos) * spawnPosInnerRatio;\n\tpos.x = edge.x * (maxPos.x == posAbs.x ? sign(pos.x) : 2.0 * pos.x);\n\tpos.y = edge.y * (maxPos.y == posAbs.y ? sign(pos.y) : 2.0 * pos.y);\n\tpos.z = edge.z * (maxPos.z == posAbs.z ? sign(pos.z) : 2.0 * pos.z);\n#ifndef LOCAL_SPACE\n\treturn emitterPos + spawnBounds * pos;\n#else\n\treturn spawnBounds * pos;\n#endif\n}\nvoid addInitialVelocity(inout vec3 localVelocity, vec3 inBounds) {\n\tlocalVelocity -= vec3(0, 0, initialVelocity);\n}\n";

var particleUpdaterEndPS = "\twriteOutput();\n}\n";

var particleUpdaterInitPS = "varying vec2 vUv0;\nuniform highp sampler2D particleTexIN;\nuniform highp sampler2D internalTex0;\nuniform highp sampler2D internalTex1;\nuniform highp sampler2D internalTex2;\nuniform highp sampler2D internalTex3;\nuniform mat3 emitterMatrix, emitterMatrixInv;\nuniform vec3 emitterScale;\nuniform vec3 emitterPos, frameRandom, localVelocityDivMult, velocityDivMult;\nuniform float delta, rate, rateDiv, lifetime, numParticles, rotSpeedDivMult, radialSpeedDivMult, seed;\nuniform float startAngle, startAngle2;\nuniform float initialVelocity;\nuniform float graphSampleSize;\nuniform float graphNumSamples;\nvec3 inPos;\nvec3 inVel;\nfloat inAngle;\nbool inShow;\nfloat inLife;\nfloat visMode;\nvec3 outPos;\nvec3 outVel;\nfloat outAngle;\nbool outShow;\nfloat outLife;\n";

var particleUpdaterNoRespawnPS = "\tif (outLife >= lifetime) {\n\t\toutLife -= max(lifetime, (numParticles - 1.0) * particleRate);\n\t\tvisMode = -1.0;\n\t}\n";

var particleUpdaterOnStopPS = "\tvisMode = outLife < 0.0? -1.0: visMode;\n";

var particleUpdaterRespawnPS = "\tif (outLife >= lifetime) {\n\t\toutLife -= max(lifetime, (numParticles - 1.0) * particleRate);\n\t\tvisMode = 1.0;\n\t}\n\tvisMode = outLife < 0.0? 1.0: visMode;\n";

var particleUpdaterSpherePS = "uniform float spawnBoundsSphere;\nuniform float spawnBoundsSphereInnerRatio;\nvec3 calcSpawnPosition(vec3 inBounds, float rndFactor) {\n\tfloat rnd4 = fract(rndFactor * 1000.0);\n\tvec3 norm = normalize(inBounds.xyz - vec3(0.5));\n\tfloat r = rnd4 * (1.0 - spawnBoundsSphereInnerRatio) + spawnBoundsSphereInnerRatio;\n#ifndef LOCAL_SPACE\n\treturn emitterPos + norm * r * spawnBoundsSphere;\n#else\n\treturn norm * r * spawnBoundsSphere;\n#endif\n}\nvoid addInitialVelocity(inout vec3 localVelocity, vec3 inBounds) {\n\tlocalVelocity += normalize(inBounds - vec3(0.5)) * initialVelocity;\n}\n";

var particleUpdaterStartPS = "float saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\nvec3 unpack3NFloats(float src) {\n\tfloat r = fract(src);\n\tfloat g = fract(src * 256.0);\n\tfloat b = fract(src * 65536.0);\n\treturn vec3(r, g, b);\n}\nvec3 tex1Dlod_lerp(highp sampler2D tex, vec2 tc, out vec3 w) {\n\tvec4 a = texture2D(tex, tc);\n\tvec4 b = texture2D(tex, tc + graphSampleSize);\n\tfloat c = fract(tc.x * graphNumSamples);\n\tvec3 unpackedA = unpack3NFloats(a.w);\n\tvec3 unpackedB = unpack3NFloats(b.w);\n\tw = mix(unpackedA, unpackedB, c);\n\treturn mix(a.xyz, b.xyz, c);\n}\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\nvec4 hash41(float p) {\n\tvec4 p4 = fract(vec4(p) * HASHSCALE4);\n\tp4 += dot(p4, p4.wzxy+19.19);\n\treturn fract(vec4((p4.x + p4.y)*p4.z, (p4.x + p4.z)*p4.y, (p4.y + p4.z)*p4.w, (p4.z + p4.w)*p4.x));\n}\nvoid main(void) {\n\tif (gl_FragCoord.x > numParticles) discard;\n\treadInput(vUv0.x);\n\tvisMode = inShow? 1.0 : -1.0;\n\tvec4 rndFactor = hash41(gl_FragCoord.x + seed);\n\tfloat particleRate = rate + rateDiv * rndFactor.x;\n\toutLife = inLife + delta;\n\tfloat nlife = clamp(outLife / lifetime, 0.0, 1.0);\n\tvec3 localVelocityDiv;\n\tvec3 velocityDiv;\n\tvec3 paramDiv;\n\tvec3 localVelocity = tex1Dlod_lerp(internalTex0, vec2(nlife, 0), localVelocityDiv);\n\tvec3 velocity =\t	tex1Dlod_lerp(internalTex1, vec2(nlife, 0), velocityDiv);\n\tvec3 params =\t\ttex1Dlod_lerp(internalTex2, vec2(nlife, 0), paramDiv);\n\tfloat rotSpeed = params.x;\n\tfloat rotSpeedDiv = paramDiv.y;\n\tvec3 radialParams = tex1Dlod_lerp(internalTex3, vec2(nlife, 0), paramDiv);\n\tfloat radialSpeed = radialParams.x;\n\tfloat radialSpeedDiv = radialParams.y;\n\tbool respawn = inLife <= 0.0 || outLife >= lifetime;\n\tinPos = respawn ? calcSpawnPosition(rndFactor.xyz, rndFactor.x) : inPos;\n\tinAngle = respawn ? mix(startAngle, startAngle2, rndFactor.x) : inAngle;\n#ifndef LOCAL_SPACE\n\tvec3 radialVel = inPos - emitterPos;\n#else\n\tvec3 radialVel = inPos;\n#endif\n\tradialVel = (dot(radialVel, radialVel) > 1.0E-8) ? radialSpeed * normalize(radialVel) : vec3(0.0);\n\tradialVel += (radialSpeedDiv * vec3(2.0) - vec3(1.0)) * radialSpeedDivMult * rndFactor.xyz;\n\tlocalVelocity +=\t(localVelocityDiv * vec3(2.0) - vec3(1.0)) * localVelocityDivMult * rndFactor.xyz;\n\tvelocity +=\t\t (velocityDiv * vec3(2.0) - vec3(1.0)) * velocityDivMult * rndFactor.xyz;\n\trotSpeed +=\t\t (rotSpeedDiv * 2.0 - 1.0) * rotSpeedDivMult * rndFactor.y;\n\taddInitialVelocity(localVelocity, rndFactor.xyz);\n#ifndef LOCAL_SPACE\n\toutVel = emitterMatrix * localVelocity + (radialVel + velocity) * emitterScale;\n#else\n\toutVel = (localVelocity + radialVel) / emitterScale + emitterMatrixInv * velocity;\n#endif\n\toutPos = inPos + outVel * delta;\n\toutAngle = inAngle + rotSpeed * delta;\n";

var particle_billboardVS = "\tquadXY = rotate(quadXY, inAngle, rotMatrix);\n\tvec3 localPos = billboard(particlePos, quadXY);\n";

var particle_blendAddPS = "\tdBlendModeFogFactor = 0.0;\n\trgb *= saturate(gammaCorrectInput(max(a, 0.0)));\n\tif ((rgb.r + rgb.g + rgb.b) < 0.000001) discard;\n";

var particle_blendMultiplyPS = "\trgb = mix(vec3(1.0), rgb, vec3(a));\n\tif (rgb.r + rgb.g + rgb.b > 2.99) discard;\n";

var particle_blendNormalPS = "\tif (a < 0.01) discard;\n";

var particle_cpuVS = "attribute vec4 particle_vertexData;\nattribute vec4 particle_vertexData2;\nattribute vec4 particle_vertexData3;\nattribute float particle_vertexData4;\n#ifndef USE_MESH\n#define VDATA5TYPE vec2\n#else\n#define VDATA5TYPE vec4\n#endif\nattribute VDATA5TYPE particle_vertexData5;\nuniform mat4 matrix_viewProjection;\nuniform mat4 matrix_model;\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform mat3 matrix_normal;\nuniform mat4 matrix_viewInverse;\nuniform float numParticles;\nuniform float lifetime;\nuniform float stretch;\nuniform float seed;\nuniform vec3 wrapBounds, emitterScale, faceTangent, faceBinorm;\nuniform sampler2D texLifeAndSourcePosOUT;\nuniform highp sampler2D internalTex0;\nuniform highp sampler2D internalTex1;\nuniform highp sampler2D internalTex2;\nuniform vec3 emitterPos;\nvarying vec4 texCoordsAlphaLife;\nvec2 rotate(vec2 quadXY, float pRotation, out mat2 rotMatrix)\n{\n\tfloat c = cos(pRotation);\n\tfloat s = sin(pRotation);\n\tmat2 m = mat2(c, -s, s, c);\n\trotMatrix = m;\n\treturn m * quadXY;\n}\nvec3 billboard(vec3 InstanceCoords, vec2 quadXY)\n{\n\tvec3 pos = -matrix_viewInverse[0].xyz * quadXY.x + -matrix_viewInverse[1].xyz * quadXY.y;\n\treturn pos;\n}\nvec3 customFace(vec3 InstanceCoords, vec2 quadXY)\n{\n\tvec3 pos = faceTangent * quadXY.x + faceBinorm * quadXY.y;\n\treturn pos;\n}\nvoid main(void)\n{\n\tvec3 particlePos = particle_vertexData.xyz;\n\tvec3 inPos = particlePos;\n\tvec3 vertPos = particle_vertexData3.xyz;\n\tvec3 inVel = vec3(particle_vertexData2.w, particle_vertexData3.w, particle_vertexData5.x);\n\tfloat id = floor(particle_vertexData4);\n\tfloat rndFactor = fract(sin(id + 1.0 + seed));\n\tvec3 rndFactor3 = vec3(rndFactor, fract(rndFactor*10.0), fract(rndFactor*100.0));\n#ifdef LOCAL_SPACE\n\tinVel = mat3(matrix_model) * inVel;\n#endif\n\tvec2 velocityV = normalize((mat3(matrix_view) * inVel).xy);\n\tvec2 quadXY = vertPos.xy;\n#ifdef USE_MESH\n\ttexCoordsAlphaLife = vec4(particle_vertexData5.zw, particle_vertexData2.z, particle_vertexData.w);\n#else\n\ttexCoordsAlphaLife = vec4(quadXY * -0.5 + 0.5, particle_vertexData2.z, particle_vertexData.w);\n#endif\n\tmat2 rotMatrix;\n\tfloat inAngle = particle_vertexData2.x;\n\tvec3 particlePosMoved = vec3(0.0);\n\tvec3 meshLocalPos = particle_vertexData3.xyz;\n";

var particle_cpu_endVS = "\tlocalPos *= particle_vertexData2.y * emitterScale;\n\tlocalPos += particlePos;\n\tgl_Position = matrix_viewProjection * vec4(localPos, 1.0);\n";

var particle_customFaceVS = "\tquadXY = rotate(quadXY, inAngle, rotMatrix);\n\tvec3 localPos = customFace(particlePos, quadXY);\n";

var particle_endPS = "\trgb = addFog(rgb);\n\trgb = toneMap(rgb);\n\trgb = gammaCorrectOutput(rgb);\n\tgl_FragColor = vec4(rgb, a);\n}\n";

var particle_endVS = "\tlocalPos *= scale * emitterScale;\n\tlocalPos += particlePos;\n\t#ifdef SCREEN_SPACE\n\tgl_Position = vec4(localPos.x, localPos.y, 0.0, 1.0);\n\t#else\n\tgl_Position = matrix_viewProjection * vec4(localPos.xyz, 1.0);\n\t#endif\n";

var particle_halflambertPS = "\tvec3 negNormal = normal*0.5+0.5;\n\tvec3 posNormal = -normal*0.5+0.5;\n\tnegNormal *= negNormal;\n\tposNormal *= posNormal;\n";

var particle_initVS = "attribute vec4 particle_vertexData;\n#ifdef USE_MESH\nattribute vec2 particle_uv;\n#endif\nuniform mat4 matrix_viewProjection;\nuniform mat4 matrix_model;\nuniform mat3 matrix_normal;\nuniform mat4 matrix_viewInverse;\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform float numParticles, numParticlesPot;\nuniform float graphSampleSize;\nuniform float graphNumSamples;\nuniform float stretch;\nuniform vec3 wrapBounds;\nuniform vec3 emitterScale, emitterPos, faceTangent, faceBinorm;\nuniform float rate, rateDiv, lifetime, deltaRandomnessStatic, scaleDivMult, alphaDivMult, seed, delta;\nuniform sampler2D particleTexOUT, particleTexIN;\nuniform highp sampler2D internalTex0;\nuniform highp sampler2D internalTex1;\nuniform highp sampler2D internalTex2;\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params;\n#endif\nvarying vec4 texCoordsAlphaLife;\nvec3 inPos;\nvec3 inVel;\nfloat inAngle;\nbool inShow;\nfloat inLife;\n";

var particle_lambertPS = "\tvec3 negNormal = max(normal, vec3(0.0));\n\tvec3 posNormal = max(-normal, vec3(0.0));\n";

var particle_lightingPS = "\tvec3 light = negNormal.x*lightCube[0] + posNormal.x*lightCube[1] +\n\t\t\t\t\t\tnegNormal.y*lightCube[2] + posNormal.y*lightCube[3] +\n\t\t\t\t\t\tnegNormal.z*lightCube[4] + posNormal.z*lightCube[5];\n\trgb *= light;\n";

var particle_localShiftVS = "\tparticlePos = (matrix_model * vec4(particlePos, 1.0)).xyz;\n";

var particle_meshVS = "\tvec3 localPos = meshLocalPos;\n\tlocalPos.xy = rotate(localPos.xy, inAngle, rotMatrix);\n\tlocalPos.yz = rotate(localPos.yz, inAngle, rotMatrix);\n\tbillboard(particlePos, quadXY);\n";

var particle_normalVS = "\tNormal = normalize(localPos + matrix_viewInverse[2].xyz);\n";

var particle_normalMapPS = "\tvec3 normalMap = normalize(texture2D(normalMap, vec2(texCoordsAlphaLife.x, 1.0 - texCoordsAlphaLife.y)).xyz * 2.0 - 1.0);\n\tvec3 normal = ParticleMat * normalMap;\n";

var particle_pointAlongVS = "\tinAngle = atan(velocityV.x, velocityV.y);\n";

var particle_softPS = "\tfloat depth = getLinearScreenDepth();\n\tfloat particleDepth = vDepth;\n\tfloat depthDiff = saturate(abs(particleDepth - depth) * softening);\n\ta *= depthDiff;\n";

var particle_softVS = "\tvDepth = getLinearDepth(localPos);\n";

var particle_stretchVS = "\tvec3 moveDir = inVel * stretch;\n\tvec3 posPrev = particlePos - moveDir;\n\tposPrev += particlePosMoved;\n\tvec2 centerToVertexV = normalize((mat3(matrix_view) * localPos).xy);\n\tfloat interpolation = dot(-velocityV, centerToVertexV) * 0.5 + 0.5;\n\tparticlePos = mix(particlePos, posPrev, interpolation);\n";

var particle_TBNVS = "\tmat3 rot3 = mat3(rotMatrix[0][0], rotMatrix[0][1], 0.0, rotMatrix[1][0], rotMatrix[1][1], 0.0, 0.0, 0.0, 1.0);\n\tParticleMat = mat3(-matrix_viewInverse[0].xyz, -matrix_viewInverse[1].xyz, matrix_viewInverse[2].xyz) * rot3;\n";

var particle_wrapVS = "\tvec3 origParticlePos = particlePos;\n\tparticlePos -= matrix_model[3].xyz;\n\tparticlePos = mod(particlePos, wrapBounds) - wrapBounds * 0.5;\n\tparticlePos += matrix_model[3].xyz;\n\tparticlePosMoved = particlePos - origParticlePos;\n";

var precisionTestPS = "void main(void) {\n\tgl_FragColor = vec4(2147483648.0);\n}\n";

var precisionTest2PS = "uniform sampler2D source;\nvec4 packFloat(float depth) {\n\tconst vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);\n\tconst vec4 bit_mask	= vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\n\tvec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);\n\tres -= res.xxyz * bit_mask;\n\treturn res;\n}\nvoid main(void) {\n\tfloat c = texture2D(source, vec2(0.0)).r;\n\tfloat diff = abs(c - 2147483648.0) / 2147483648.0;\n\tgl_FragColor = packFloat(diff);\n}\n";

var reflDirPS = "void getReflDir() {\n\tdReflDirW = normalize(-reflect(dViewDirW, dNormalW));\n}\n";

var reflDirAnisoPS = "void getReflDir() {\n\tfloat roughness = sqrt(1.0 - min(dGlossiness, 1.0));\n\tfloat anisotropy = material_anisotropy * roughness;\n\tvec3 anisotropicDirection = anisotropy >= 0.0 ? dTBN[1] : dTBN[0];\n\tvec3 anisotropicTangent = cross(anisotropicDirection, dViewDirW);\n\tvec3 anisotropicNormal = cross(anisotropicTangent, anisotropicDirection);\n\tvec3 bentNormal = normalize(mix(normalize(dNormalW), normalize(anisotropicNormal), anisotropy));\n\tdReflDirW = reflect(-dViewDirW, bentNormal);\n}\n";

var reflectionCCPS = "#ifdef CLEARCOAT\nuniform float material_clearCoatReflectivity;\nvoid addReflectionCC() {\n\tccReflection += vec4(calcReflection(ccReflDirW, ccGlossiness), material_clearCoatReflectivity);\n}\n#endif\n";

var reflectionCubePS = "uniform samplerCube texture_cubeMap;\nuniform float material_reflectivity;\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\n\tvec3 lookupVec = fixSeams(cubeMapProject(tReflDirW));\n\tlookupVec.x *= -1.0;\n\treturn $DECODE(textureCube(texture_cubeMap, lookupVec));\n}\nvoid addReflection() {\n\tdReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\n}\n";

var reflectionEnvPS = "#ifndef ENV_ATLAS\n#define ENV_ATLAS\nuniform sampler2D texture_envAtlas;\n#endif\nuniform float material_reflectivity;\nfloat shinyMipLevel(vec2 uv) {\n\tvec2 dx = dFdx(uv);\n\tvec2 dy = dFdy(uv);\n\tvec2 uv2 = vec2(fract(uv.x + 0.5), uv.y);\n\tvec2 dx2 = dFdx(uv2);\n\tvec2 dy2 = dFdy(uv2);\n\tfloat maxd = min(max(dot(dx, dx), dot(dy, dy)), max(dot(dx2, dx2), dot(dy2, dy2)));\n\treturn clamp(0.5 * log2(maxd) - 1.0, 0.0, 6.0);\n}\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\n\tvec3 dir = cubeMapProject(tReflDirW) * vec3(-1.0, 1.0, 1.0);\n\tvec2 uv = toSphericalUv(dir);\n\tfloat level = saturate(1.0 - tGlossiness) * 5.0;\n\tfloat ilevel = floor(level);\n\tfloat level2 = shinyMipLevel(uv * atlasSize);\n\tfloat ilevel2 = floor(level2);\n\tvec2 uv0, uv1;\n\tfloat weight;\n\tif (ilevel == 0.0) {\n\t\tuv0 = mapMip(uv, ilevel2);\n\t\tuv1 = mapMip(uv, ilevel2 + 1.0);\n\t\tweight = level2 - ilevel2;\n\t} else {\n\t\tuv0 = uv1 = mapRoughnessUv(uv, ilevel);\n\t\tweight = 0.0;\n\t}\n\tvec3 linearA = $DECODE(texture2D(texture_envAtlas, uv0));\n\tvec3 linearB = $DECODE(texture2D(texture_envAtlas, uv1));\n\tvec3 linear0 = mix(linearA, linearB, weight);\n\tvec3 linear1 = $DECODE(texture2D(texture_envAtlas, mapRoughnessUv(uv, ilevel + 1.0)));\n\treturn processEnvironment(mix(linear0, linear1, level - ilevel));\n}\nvoid addReflection() {\n\tdReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\n}\n";

var reflectionSpherePS = "#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform sampler2D texture_sphereMap;\nuniform float material_reflectivity;\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\n\tvec3 reflDirV = (mat3(matrix_view) * tReflDirW).xyz;\n\tfloat m = 2.0 * sqrt( dot(reflDirV.xy, reflDirV.xy) + (reflDirV.z+1.0)*(reflDirV.z+1.0) );\n\tvec2 sphereMapUv = reflDirV.xy / m + 0.5;\n\treturn $DECODE(texture2D(texture_sphereMap, sphereMapUv));\n}\nvoid addReflection() {\n\tdReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\n}\n";

var reflectionSphereLowPS = "uniform sampler2D texture_sphereMap;\nuniform float material_reflectivity;\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\n\tvec3 reflDirV = vNormalV;\n\tvec2 sphereMapUv = reflDirV.xy * 0.5 + 0.5;\n\treturn $DECODE(texture2D(texture_sphereMap, sphereMapUv));\n}\nvoid addReflection() {\n\tdReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\n}\n";

var refractionPS = "uniform float material_refraction, material_refractionIndex;\nvec3 refract2(vec3 viewVec, vec3 Normal, float IOR) {\n\tfloat vn = dot(viewVec, Normal);\n\tfloat k = 1.0 - IOR * IOR * (1.0 - vn * vn);\n\tvec3 refrVec = IOR * viewVec - (IOR * vn + sqrt(k)) * Normal;\n\treturn refrVec;\n}\nvoid addRefraction() {\n\tvec3 tmp = dReflDirW;\n\tvec4 tmp2 = dReflection;\n\tdReflection = vec4(0.0);\n\tdReflDirW = refract2(-dViewDirW, dNormalW, material_refractionIndex);\n\taddReflection();\n\tdDiffuseLight = mix(dDiffuseLight, dReflection.rgb * dAlbedo, material_refraction);\n\tdReflDirW = tmp;\n\tdReflection = tmp2;\n}\n";

var reprojectPS = "varying vec2 vUv0;\nuniform sampler2D sourceTex;\nuniform samplerCube sourceCube;\nuniform sampler2D samplesTex;\nuniform vec2 samplesTexInverseSize;\nuniform vec4 params;\nuniform vec2 params2;\nfloat targetFace() { return params.x; }\nfloat specularPower() { return params.y; }\nfloat sourceCubeSeamScale() { return params.z; }\nfloat targetCubeSeamScale() { return params.w; }\nfloat targetTotalPixels() { return params2.x; }\nfloat sourceTotalPixels() { return params2.y; }\nfloat PI = 3.141592653589793;\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\nvec3 decodeLinear(vec4 source) {\n\treturn source.rgb;\n}\nvec4 encodeLinear(vec3 source) {\n\treturn vec4(source, 1.0);\n}\nvec3 decodeGamma(vec4 source) {\n\treturn pow(source.xyz, vec3(2.2));\n}\nvec4 encodeGamma(vec3 source) {\n\treturn vec4(pow(source + 0.0000001, vec3(1.0 / 2.2)), 1.0);\n}\nvec3 decodeRGBM(vec4 rgbm) {\n\tvec3 color = (8.0 * rgbm.a) * rgbm.rgb;\n\treturn color * color;\n}\nvec4 encodeRGBM(vec3 source) {\n\tvec4 result;\n\tresult.rgb = pow(source.rgb, vec3(0.5));\n\tresult.rgb *= 1.0 / 8.0;\n\tresult.a = saturate( max( max( result.r, result.g ), max( result.b, 1.0 / 255.0 ) ) );\n\tresult.a = ceil(result.a * 255.0) / 255.0;\n\tresult.rgb /= result.a;\n\treturn result;\n}\nvec3 decodeRGBE(vec4 source) {\n\tif (source.a == 0.0) {\n\t\treturn vec3(0.0, 0.0, 0.0);\n\t} else {\n\t\treturn source.xyz * pow(2.0, source.w * 255.0 - 128.0);\n\t}\n}\nvec4 encodeRGBE(vec3 source) {\n\tfloat maxVal = max(source.x, max(source.y, source.z));\n\tif (maxVal < 1e-32) {\n\t\treturn vec4(0, 0, 0, 0);\n\t} else {\n\t\tfloat e = ceil(log2(maxVal));\n\t\treturn vec4(source / pow(2.0, e), (e + 128.0) / 255.0);\n\t}\n}\nvec3 modifySeams(vec3 dir, float scale) {\n\tvec3 adir = abs(dir);\n\tfloat M = max(max(adir.x, adir.y), adir.z);\n\treturn dir / M * vec3(\n\t\tadir.x == M ? 1.0 : scale,\n\t\tadir.y == M ? 1.0 : scale,\n\t\tadir.z == M ? 1.0 : scale\n\t);\n}\nvec2 toSpherical(vec3 dir) {\n\treturn vec2(dir.xz == vec2(0.0) ? 0.0 : atan(dir.x, dir.z), asin(dir.y));\n}\nvec3 fromSpherical(vec2 uv) {\n\treturn vec3(cos(uv.y) * sin(uv.x),\n\t\t\t\tsin(uv.y),\n\t\t\t\tcos(uv.y) * cos(uv.x));\n}\nvec3 getDirectionEquirect() {\n\treturn fromSpherical((vec2(vUv0.x, 1.0 - vUv0.y) * 2.0 - 1.0) * vec2(PI, PI * 0.5));\n}\nvec4 sampleEquirect(vec2 sph) {\n\tvec2 uv = sph / vec2(PI * 2.0, PI) + 0.5;\n\treturn texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));\n}\nvec4 sampleEquirect(vec3 dir) {\n\treturn sampleEquirect(toSpherical(dir));\n}\nvec4 sampleCubemap(vec3 dir) {\n\treturn textureCube(sourceCube, modifySeams(dir, 1.0 - sourceCubeSeamScale()));\n}\nvec4 sampleCubemap(vec2 sph) {\n\treturn sampleCubemap(fromSpherical(sph));\n}\nvec4 sampleEquirect(vec2 sph, float mipLevel) {\n\tvec2 uv = sph / vec2(PI * 2.0, PI) + 0.5;\n#ifdef SUPPORTS_TEXLOD\n\treturn texture2DLodEXT(sourceTex, vec2(uv.x, 1.0 - uv.y), mipLevel);\n#else\n\treturn texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));\n#endif\n}\nvec4 sampleEquirect(vec3 dir, float mipLevel) {\n\treturn sampleEquirect(toSpherical(dir), mipLevel);\n}\nvec4 sampleCubemap(vec3 dir, float mipLevel) {\n#ifdef SUPPORTS_TEXLOD\n\treturn textureCubeLodEXT(sourceCube, modifySeams(dir, 1.0 - exp2(mipLevel) * sourceCubeSeamScale()), mipLevel);\n#else\n\treturn textureCube(sourceCube, modifySeams(dir, 1.0 - exp2(mipLevel) * sourceCubeSeamScale()));\n#endif\n}\nvec4 sampleCubemap(vec2 sph, float mipLevel) {\n\treturn sampleCubemap(fromSpherical(sph), mipLevel);\n}\nfloat signNotZero(float k){\n\treturn(k >= 0.0) ? 1.0 : -1.0;\n}\nvec2 signNotZero(vec2 v) {\n\treturn vec2(signNotZero(v.x), signNotZero(v.y));\n}\nvec3 octDecode(vec2 o) {\n\tvec3 v = vec3(o.x, 1.0 - abs(o.x) - abs(o.y), o.y);\n\tif (v.y < 0.0) {\n\t\tv.xz = (1.0 - abs(v.zx)) * signNotZero(v.xz);\n\t}\n\treturn normalize(v);\n}\nvec3 getDirectionOctahedral() {\n\treturn octDecode(vec2(vUv0.x, 1.0 - vUv0.y) * 2.0 - 1.0);\n}\nvec2 octEncode(in vec3 v) {\n\tfloat l1norm = abs(v.x) + abs(v.y) + abs(v.z);\n\tvec2 result = v.xz * (1.0 / l1norm);\n\tif (v.y < 0.0) {\n\t\tresult = (1.0 - abs(result.yx)) * signNotZero(result.xy);\n\t}\n\treturn result;\n}\nvec4 sampleOctahedral(vec3 dir) {\n\tvec2 uv = octEncode(dir) * 0.5 + 0.5;\n\treturn texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));\n}\nvec4 sampleOctahedral(vec2 sph) {\n\treturn sampleOctahedral(fromSpherical(sph));\n}\nvec4 sampleOctahedral(vec3 dir, float mipLevel) {\n\tvec2 uv = octEncode(dir) * 0.5 + 0.5;\n#ifdef SUPPORTS_TEXLOD\n\treturn texture2DLodEXT(sourceTex, vec2(uv.x, 1.0 - uv.y), mipLevel);\n#else\n\treturn texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));\n#endif\n}\nvec4 sampleOctahedral(vec2 sph, float mipLevel) {\n\treturn sampleOctahedral(fromSpherical(sph), mipLevel);\n}\nvec3 getDirectionCubemap() {\n\tvec2 st = vUv0 * 2.0 - 1.0;\n\tfloat face = targetFace();\n\tvec3 vec;\n\tif (face == 0.0) {\n\t\tvec = vec3(1, -st.y, -st.x);\n\t} else if (face == 1.0) {\n\t\tvec = vec3(-1, -st.y, st.x);\n\t} else if (face == 2.0) {\n\t\tvec = vec3(st.x, 1, st.y);\n\t} else if (face == 3.0) {\n\t\tvec = vec3(st.x, -1, -st.y);\n\t} else if (face == 4.0) {\n\t\tvec = vec3(st.x, -st.y, 1);\n\t} else {\n\t\tvec = vec3(-st.x, -st.y, -1);\n\t}\n\treturn normalize(modifySeams(vec, 1.0 / (1.0 - targetCubeSeamScale())));\n}\nmat3 matrixFromVector(vec3 n) {\n\tfloat a = 1.0 / (1.0 + n.z);\n\tfloat b = -n.x * n.y * a;\n\tvec3 b1 = vec3(1.0 - n.x * n.x * a, b, -n.x);\n\tvec3 b2 = vec3(b, 1.0 - n.y * n.y * a, -n.y);\n\treturn mat3(b1, b2, n);\n}\nmat3 matrixFromVectorSlow(vec3 n) {\n\tvec3 up = (1.0 - abs(n.y) <= 0.0000001) ? vec3(0.0, 0.0, n.y > 0.0 ? 1.0 : -1.0) : vec3(0.0, 1.0, 0.0);\n\tvec3 x = normalize(cross(up, n));\n\tvec3 y = cross(n, x);\n\treturn mat3(x, y, n);\n}\nvec4 reproject() {\n\tif (NUM_SAMPLES <= 1) {\n\t\treturn ENCODE_FUNC(DECODE_FUNC(SOURCE_FUNC(TARGET_FUNC())));\n\t} else {\n\t\tvec2 sph = toSpherical(TARGET_FUNC());\n\t\tvec2 sphu = dFdx(sph);\n\t\tvec2 sphv = dFdy(sph);\n\t\tconst float NUM_SAMPLES_SQRT = sqrt(float(NUM_SAMPLES));\n\t\tvec3 result = vec3(0.0);\n\t\tfor (float u = 0.0; u < NUM_SAMPLES_SQRT; ++u) {\n\t\t\tfor (float v = 0.0; v < NUM_SAMPLES_SQRT; ++v) {\n\t\t\t\tresult += DECODE_FUNC(SOURCE_FUNC(sph +\n\t\t\t\t\t\t\t\t\t\t\t\t	sphu * (u / NUM_SAMPLES_SQRT - 0.5) +\n\t\t\t\t\t\t\t\t\t\t\t\t	sphv * (v / NUM_SAMPLES_SQRT - 0.5)));\n\t\t\t}\n\t\t}\n\t\treturn ENCODE_FUNC(result / (NUM_SAMPLES_SQRT * NUM_SAMPLES_SQRT));\n\t}\n}\nvec4 unpackFloat = vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0);\nvoid unpackSample(int i, out vec3 L, out float mipLevel) {\n\tfloat u = (float(i * 4) + 0.5) * samplesTexInverseSize.x;\n\tfloat v = (floor(u) + 0.5) * samplesTexInverseSize.y;\n\tvec4 raw;\n\traw.x = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;\n\traw.y = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;\n\traw.z = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;\n\traw.w = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat);\n\tL.xyz = raw.xyz * 2.0 - 1.0;\n\tmipLevel = raw.w * 8.0;\n}\nvec4 prefilterSamples() {\n\tmat3 vecSpace = matrixFromVectorSlow(TARGET_FUNC());\n\tvec3 L;\n\tfloat mipLevel;\n\tvec3 result = vec3(0.0);\n\tfloat totalWeight = 0.0;\n\tfor (int i = 0; i < NUM_SAMPLES; ++i) {\n\t\tunpackSample(i, L, mipLevel);\n\t\tresult += DECODE_FUNC(SOURCE_FUNC(vecSpace * L, mipLevel)) * L.z;\n\t\ttotalWeight += L.z;\n\t}\n\treturn ENCODE_FUNC(result / totalWeight);\n}\nvec4 prefilterSamplesUnweighted() {\n\tmat3 vecSpace = matrixFromVectorSlow(TARGET_FUNC());\n\tvec3 L;\n\tfloat mipLevel;\n\tvec3 result = vec3(0.0);\n\tfloat totalWeight = 0.0;\n\tfor (int i = 0; i < NUM_SAMPLES; ++i) {\n\t\tunpackSample(i, L, mipLevel);\n\t\tresult += DECODE_FUNC(SOURCE_FUNC(vecSpace * L, mipLevel));\n\t}\n\treturn ENCODE_FUNC(result / float(NUM_SAMPLES));\n}\nvoid main(void) {\n\tgl_FragColor = PROCESS_FUNC();\n}\n";

var rgbmPS = "vec3 texture2DRGBM(sampler2D tex, vec2 uv) {\n\treturn decodeRGBM(texture2D(tex, uv));\n}\nvec3 textureCubeRGBM(samplerCube tex, vec3 uvw) {\n\treturn decodeRGBM(textureCube(tex, uvw));\n}\n";

var screenDepthPS = "uniform highp sampler2D uDepthMap;\n#ifndef SCREENSIZE\n#define SCREENSIZE\nuniform vec4 uScreenSize;\n#endif\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params;\n#endif\n#ifdef GL2\nfloat linearizeDepth(float z) {\n\tz = z * 2.0 - 1.0;\n\treturn 1.0 / (camera_params.z * z + camera_params.w);\n}\n#else\n#ifndef UNPACKFLOAT\n#define UNPACKFLOAT\nfloat unpackFloat(vec4 rgbaDepth) {\n\tconst vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n\treturn dot(rgbaDepth, bitShift);\n}\n#endif\n#endif\nfloat getLinearScreenDepth(vec2 uv) {\n\t#ifdef GL2\n\treturn linearizeDepth(texture2D(uDepthMap, uv).r) * camera_params.y;\n\t#else\n\treturn unpackFloat(texture2D(uDepthMap, uv)) * camera_params.y;\n\t#endif\n}\n#ifndef VERTEXSHADER\nfloat getLinearScreenDepth() {\n\tvec2 uv = gl_FragCoord.xy * uScreenSize.zw;\n\treturn getLinearScreenDepth(uv);\n}\n#endif\nfloat getLinearDepth(vec3 pos) {\n\treturn -(matrix_view * vec4(pos, 1.0)).z;\n}\n";

var shadowCascadesPS = "const float maxCascades = 4.0;\nmat4 cascadeShadowMat;\nvoid getShadowCascadeMatrix(mat4 shadowMatrixPalette[4], float shadowCascadeDistances[4], float shadowCascadeCount) {\n\tfloat depth = 1.0 / gl_FragCoord.w;\n\tfloat cascadeIndex = 0.0;\n\tfor (float i = 0.0; i < maxCascades; i++) {\n\t\tif (depth < shadowCascadeDistances[int(i)]) {\n\t\t\tcascadeIndex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcascadeIndex = min(cascadeIndex, shadowCascadeCount - 1.0);\n\t#ifdef GL2\n\t\tcascadeShadowMat = shadowMatrixPalette[int(cascadeIndex)];\n\t#else\n\t\tif (cascadeIndex == 0.0) {\n\t\t\tcascadeShadowMat = shadowMatrixPalette[0];\n\t\t}\n\t\telse if (cascadeIndex == 1.0) {\n\t\t\tcascadeShadowMat = shadowMatrixPalette[1];\n\t\t}\n\t\telse if (cascadeIndex == 2.0) {\n\t\t\tcascadeShadowMat = shadowMatrixPalette[2];\n\t\t}\n\t\telse {\n\t\t\tcascadeShadowMat = shadowMatrixPalette[3];\n\t\t}\n\t#endif\n}\nvoid fadeShadow(float shadowCascadeDistances[4]) {\n\tfloat depth = 1.0 / gl_FragCoord.w;\n\tif (depth > shadowCascadeDistances[int(maxCascades - 1.0)]) {\n\t\tdShadowCoord.z = -9999999.0;\n\t}\n}\n";

var shadowCommonPS = "void normalOffsetPointShadow(vec4 shadowParams) {\n\tfloat distScale = length(dLightDirW);\n\tvec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0) * distScale;\n\tvec3 dir = wPos - dLightPosW;\n\tdLightDirW = dir;\n}\n";

var shadowCoordPS = "void _getShadowCoordOrtho(mat4 shadowMatrix, vec3 shadowParams, vec3 wPos) {\n\tdShadowCoord = (shadowMatrix * vec4(wPos, 1.0)).xyz;\n\tdShadowCoord.z = saturate(dShadowCoord.z) - 0.0001;\n\t#ifdef SHADOWBIAS\n\tdShadowCoord.z += getShadowBias(shadowParams.x, shadowParams.z);\n\t#endif\n}\nvoid _getShadowCoordPersp(mat4 shadowMatrix, vec4 shadowParams, vec3 wPos) {\n\tvec4 projPos = shadowMatrix * vec4(wPos, 1.0);\n\tprojPos.xy /= projPos.w;\n\tdShadowCoord.xy = projPos.xy;\n\tdShadowCoord.z = length(dLightDirW) * shadowParams.w;\n\t#ifdef SHADOWBIAS\n\tdShadowCoord.z += getShadowBias(shadowParams.x, shadowParams.z);\n\t#endif\n}\nvoid getShadowCoordOrtho(mat4 shadowMatrix, vec3 shadowParams) {\n\t_getShadowCoordOrtho(shadowMatrix, shadowParams, vPositionW);\n}\nvoid getShadowCoordPersp(mat4 shadowMatrix, vec4 shadowParams) {\n\t_getShadowCoordPersp(shadowMatrix, shadowParams, vPositionW);\n}\nvoid getShadowCoordPerspNormalOffset(mat4 shadowMatrix, vec4 shadowParams) {\n\tfloat distScale = abs(dot(vPositionW - dLightPosW, dLightDirNormW));\n\tvec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0) * distScale;\n\t_getShadowCoordPersp(shadowMatrix, shadowParams, wPos);\n}\nvoid getShadowCoordOrthoNormalOffset(mat4 shadowMatrix, vec3 shadowParams) {\n\tvec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0);\n\t_getShadowCoordOrtho(shadowMatrix, shadowParams, wPos);\n}\n";

var shadowCoordPerspZbufferPS = "void _getShadowCoordPerspZbuffer(mat4 shadowMatrix, vec4 shadowParams, vec3 wPos) {\n\tvec4 projPos = shadowMatrix * vec4(wPos, 1.0);\n\tprojPos.xyz /= projPos.w;\n\tdShadowCoord = projPos.xyz;\n}\nvoid getShadowCoordPerspZbufferNormalOffset(mat4 shadowMatrix, vec4 shadowParams) {\n\tfloat distScale = abs(dot(vPositionW - dLightPosW, dLightDirNormW));\n\tvec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0) * distScale;\n\t_getShadowCoordPerspZbuffer(shadowMatrix, shadowParams, wPos);\n}\nvoid getShadowCoordPerspZbuffer(mat4 shadowMatrix, vec4 shadowParams) {\n\t_getShadowCoordPerspZbuffer(shadowMatrix, shadowParams, vPositionW);\n}\n";

var shadowEVSMPS = "float VSM$(sampler2D tex, vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {\n\tvec3 moments = texture2D(tex, texCoords).xyz;\n\treturn calculateEVSM(moments, Z, vsmBias, exponent);\n}\nfloat getShadowVSM$(sampler2D shadowMap, vec3 shadowParams, float exponent) {\n\treturn VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, dShadowCoord.z, shadowParams.y, exponent);\n}\nfloat getShadowSpotVSM$(sampler2D shadowMap, vec4 shadowParams, float exponent) {\n\treturn VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, length(dLightDirW) * shadowParams.w + shadowParams.z, shadowParams.y, exponent);\n}\n";

var shadowEVSMnPS = "float VSM$(sampler2D tex, vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {\n\tfloat pixelSize = 1.0 / resolution;\n\ttexCoords -= vec2(pixelSize);\n\tvec3 s00 = texture2D(tex, texCoords).xyz;\n\tvec3 s10 = texture2D(tex, texCoords + vec2(pixelSize, 0)).xyz;\n\tvec3 s01 = texture2D(tex, texCoords + vec2(0, pixelSize)).xyz;\n\tvec3 s11 = texture2D(tex, texCoords + vec2(pixelSize)).xyz;\n\tvec2 fr = fract(texCoords * resolution);\n\tvec3 h0 = mix(s00, s10, fr.x);\n\tvec3 h1 = mix(s01, s11, fr.x);\n\tvec3 moments = mix(h0, h1, fr.y);\n\treturn calculateEVSM(moments, Z, vsmBias, exponent);\n}\nfloat getShadowVSM$(sampler2D shadowMap, vec3 shadowParams, float exponent) {\n\treturn VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, dShadowCoord.z, shadowParams.y, exponent);\n}\nfloat getShadowSpotVSM$(sampler2D shadowMap, vec4 shadowParams, float exponent) {\n\treturn VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, length(dLightDirW) * shadowParams.w + shadowParams.z, shadowParams.y, exponent);\n}\n";

var shadowStandardPS = "vec3 lessThan2(vec3 a, vec3 b) {\n\treturn clamp((b - a)*1000.0, 0.0, 1.0);\n}\n#ifndef UNPACKFLOAT\n#define UNPACKFLOAT\nfloat unpackFloat(vec4 rgbaDepth) {\n\tconst vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n\treturn dot(rgbaDepth, bitShift);\n}\n#endif\n#ifdef GL2\nfloat _getShadowPCF3x3(sampler2DShadow shadowMap, vec3 shadowParams) {\n\tfloat z = dShadowCoord.z;\n\tvec2 uv = dShadowCoord.xy * shadowParams.x;\n\tfloat shadowMapSizeInv = 1.0 / shadowParams.x;\n\tvec2 base_uv = floor(uv + 0.5);\n\tfloat s = (uv.x + 0.5 - base_uv.x);\n\tfloat t = (uv.y + 0.5 - base_uv.y);\n\tbase_uv -= vec2(0.5);\n\tbase_uv *= shadowMapSizeInv;\n\tfloat sum = 0.0;\n\tfloat uw0 = (3.0 - 2.0 * s);\n\tfloat uw1 = (1.0 + 2.0 * s);\n\tfloat u0 = (2.0 - s) / uw0 - 1.0;\n\tfloat u1 = s / uw1 + 1.0;\n\tfloat vw0 = (3.0 - 2.0 * t);\n\tfloat vw1 = (1.0 + 2.0 * t);\n\tfloat v0 = (2.0 - t) / vw0 - 1.0;\n\tfloat v1 = t / vw1 + 1.0;\n\tu0 = u0 * shadowMapSizeInv + base_uv.x;\n\tv0 = v0 * shadowMapSizeInv + base_uv.y;\n\tu1 = u1 * shadowMapSizeInv + base_uv.x;\n\tv1 = v1 * shadowMapSizeInv + base_uv.y;\n\tsum += uw0 * vw0 * texture(shadowMap, vec3(u0, v0, z));\n\tsum += uw1 * vw0 * texture(shadowMap, vec3(u1, v0, z));\n\tsum += uw0 * vw1 * texture(shadowMap, vec3(u0, v1, z));\n\tsum += uw1 * vw1 * texture(shadowMap, vec3(u1, v1, z));\n\tsum *= 1.0f / 16.0;\n\treturn sum;\n}\nfloat getShadowPCF3x3(sampler2DShadow shadowMap, vec3 shadowParams) {\n\treturn _getShadowPCF3x3(shadowMap, shadowParams);\n}\nfloat getShadowSpotPCF3x3(sampler2DShadow shadowMap, vec4 shadowParams) {\n\treturn _getShadowPCF3x3(shadowMap, shadowParams.xyz);\n}\n#else\nfloat _xgetShadowPCF3x3(mat3 depthKernel, sampler2D shadowMap, vec3 shadowParams) {\n\tmat3 shadowKernel;\n\tvec3 shadowCoord = dShadowCoord;\n\tvec3 shadowZ = vec3(shadowCoord.z);\n\tshadowKernel[0] = vec3(greaterThan(depthKernel[0], shadowZ));\n\tshadowKernel[1] = vec3(greaterThan(depthKernel[1], shadowZ));\n\tshadowKernel[2] = vec3(greaterThan(depthKernel[2], shadowZ));\n\tvec2 fractionalCoord = fract( shadowCoord.xy * shadowParams.x );\n\tshadowKernel[0] = mix(shadowKernel[0], shadowKernel[1], fractionalCoord.x);\n\tshadowKernel[1] = mix(shadowKernel[1], shadowKernel[2], fractionalCoord.x);\n\tvec4 shadowValues;\n\tshadowValues.x = mix(shadowKernel[0][0], shadowKernel[0][1], fractionalCoord.y);\n\tshadowValues.y = mix(shadowKernel[0][1], shadowKernel[0][2], fractionalCoord.y);\n\tshadowValues.z = mix(shadowKernel[1][0], shadowKernel[1][1], fractionalCoord.y);\n\tshadowValues.w = mix(shadowKernel[1][1], shadowKernel[1][2], fractionalCoord.y);\n\treturn dot( shadowValues, vec4( 1.0 ) ) * 0.25;\n}\nfloat _getShadowPCF3x3(sampler2D shadowMap, vec3 shadowParams) {\n\tvec3 shadowCoord = dShadowCoord;\n\tfloat xoffset = 1.0 / shadowParams.x;\n\tfloat dx0 = -xoffset;\n\tfloat dx1 = xoffset;\n\tmat3 depthKernel;\n\tdepthKernel[0][0] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx0, dx0)));\n\tdepthKernel[0][1] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx0, 0.0)));\n\tdepthKernel[0][2] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx0, dx1)));\n\tdepthKernel[1][0] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(0.0, dx0)));\n\tdepthKernel[1][1] = unpackFloat(texture2D(shadowMap, shadowCoord.xy));\n\tdepthKernel[1][2] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(0.0, dx1)));\n\tdepthKernel[2][0] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx1, dx0)));\n\tdepthKernel[2][1] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx1, 0.0)));\n\tdepthKernel[2][2] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx1, dx1)));\n\treturn _xgetShadowPCF3x3(depthKernel, shadowMap, shadowParams);\n}\nfloat getShadowPCF3x3(sampler2D shadowMap, vec3 shadowParams) {\n\treturn _getShadowPCF3x3(shadowMap, shadowParams);\n}\nfloat getShadowSpotPCF3x3(sampler2D shadowMap, vec4 shadowParams) {\n\treturn _getShadowPCF3x3(shadowMap, shadowParams.xyz);\n}\n#endif\nfloat _getShadowPoint(samplerCube shadowMap, vec4 shadowParams, vec3 dir) {\n\tvec3 tc = normalize(dir);\n\tvec3 tcAbs = abs(tc);\n\tvec4 dirX = vec4(1,0,0, tc.x);\n\tvec4 dirY = vec4(0,1,0, tc.y);\n\tfloat majorAxisLength = tc.z;\n\tif ((tcAbs.x > tcAbs.y) && (tcAbs.x > tcAbs.z)) {\n\t\tdirX = vec4(0,0,1, tc.z);\n\t\tdirY = vec4(0,1,0, tc.y);\n\t\tmajorAxisLength = tc.x;\n\t} else if ((tcAbs.y > tcAbs.x) && (tcAbs.y > tcAbs.z)) {\n\t\tdirX = vec4(1,0,0, tc.x);\n\t\tdirY = vec4(0,0,1, tc.z);\n\t\tmajorAxisLength = tc.y;\n\t}\n\tfloat shadowParamsInFaceSpace = ((1.0/shadowParams.x) * 2.0) * abs(majorAxisLength);\n\tvec3 xoffset = (dirX.xyz * shadowParamsInFaceSpace);\n\tvec3 yoffset = (dirY.xyz * shadowParamsInFaceSpace);\n\tvec3 dx0 = -xoffset;\n\tvec3 dy0 = -yoffset;\n\tvec3 dx1 = xoffset;\n\tvec3 dy1 = yoffset;\n\tmat3 shadowKernel;\n\tmat3 depthKernel;\n\tdepthKernel[0][0] = unpackFloat(textureCube(shadowMap, tc + dx0 + dy0));\n\tdepthKernel[0][1] = unpackFloat(textureCube(shadowMap, tc + dx0));\n\tdepthKernel[0][2] = unpackFloat(textureCube(shadowMap, tc + dx0 + dy1));\n\tdepthKernel[1][0] = unpackFloat(textureCube(shadowMap, tc + dy0));\n\tdepthKernel[1][1] = unpackFloat(textureCube(shadowMap, tc));\n\tdepthKernel[1][2] = unpackFloat(textureCube(shadowMap, tc + dy1));\n\tdepthKernel[2][0] = unpackFloat(textureCube(shadowMap, tc + dx1 + dy0));\n\tdepthKernel[2][1] = unpackFloat(textureCube(shadowMap, tc + dx1));\n\tdepthKernel[2][2] = unpackFloat(textureCube(shadowMap, tc + dx1 + dy1));\n\tvec3 shadowZ = vec3(length(dir) * shadowParams.w + shadowParams.z);\n\tshadowKernel[0] = vec3(lessThan2(depthKernel[0], shadowZ));\n\tshadowKernel[1] = vec3(lessThan2(depthKernel[1], shadowZ));\n\tshadowKernel[2] = vec3(lessThan2(depthKernel[2], shadowZ));\n\tvec2 uv = (vec2(dirX.w, dirY.w) / abs(majorAxisLength)) * 0.5;\n\tvec2 fractionalCoord = fract( uv * shadowParams.x );\n\tshadowKernel[0] = mix(shadowKernel[0], shadowKernel[1], fractionalCoord.x);\n\tshadowKernel[1] = mix(shadowKernel[1], shadowKernel[2], fractionalCoord.x);\n\tvec4 shadowValues;\n\tshadowValues.x = mix(shadowKernel[0][0], shadowKernel[0][1], fractionalCoord.y);\n\tshadowValues.y = mix(shadowKernel[0][1], shadowKernel[0][2], fractionalCoord.y);\n\tshadowValues.z = mix(shadowKernel[1][0], shadowKernel[1][1], fractionalCoord.y);\n\tshadowValues.w = mix(shadowKernel[1][1], shadowKernel[1][2], fractionalCoord.y);\n\treturn 1.0 - dot( shadowValues, vec4( 1.0 ) ) * 0.25;\n}\nfloat getShadowPointPCF3x3(samplerCube shadowMap, vec4 shadowParams) {\n\treturn _getShadowPoint(shadowMap, shadowParams, dLightDirW);\n}\n";

var shadowStandardGL2PS = "float _getShadowPCF5x5(sampler2DShadow shadowMap, vec3 shadowParams) {\n\tfloat z = dShadowCoord.z;\n\tvec2 uv = dShadowCoord.xy * shadowParams.x;\n\tfloat shadowMapSizeInv = 1.0 / shadowParams.x;\n\tvec2 base_uv = floor(uv + 0.5);\n\tfloat s = (uv.x + 0.5 - base_uv.x);\n\tfloat t = (uv.y + 0.5 - base_uv.y);\n\tbase_uv -= vec2(0.5);\n\tbase_uv *= shadowMapSizeInv;\n\tfloat uw0 = (4.0 - 3.0 * s);\n\tfloat uw1 = 7.0;\n\tfloat uw2 = (1.0 + 3.0 * s);\n\tfloat u0 = (3.0 - 2.0 * s) / uw0 - 2.0;\n\tfloat u1 = (3.0 + s) / uw1;\n\tfloat u2 = s / uw2 + 2.0;\n\tfloat vw0 = (4.0 - 3.0 * t);\n\tfloat vw1 = 7.0;\n\tfloat vw2 = (1.0 + 3.0 * t);\n\tfloat v0 = (3.0 - 2.0 * t) / vw0 - 2.0;\n\tfloat v1 = (3.0 + t) / vw1;\n\tfloat v2 = t / vw2 + 2.0;\n\tfloat sum = 0.0;\n\tu0 = u0 * shadowMapSizeInv + base_uv.x;\n\tv0 = v0 * shadowMapSizeInv + base_uv.y;\n\tu1 = u1 * shadowMapSizeInv + base_uv.x;\n\tv1 = v1 * shadowMapSizeInv + base_uv.y;\n\tu2 = u2 * shadowMapSizeInv + base_uv.x;\n\tv2 = v2 * shadowMapSizeInv + base_uv.y;\n\tsum += uw0 * vw0 * texture(shadowMap, vec3(u0, v0, z));\n\tsum += uw1 * vw0 * texture(shadowMap, vec3(u1, v0, z));\n\tsum += uw2 * vw0 * texture(shadowMap, vec3(u2, v0, z));\n\tsum += uw0 * vw1 * texture(shadowMap, vec3(u0, v1, z));\n\tsum += uw1 * vw1 * texture(shadowMap, vec3(u1, v1, z));\n\tsum += uw2 * vw1 * texture(shadowMap, vec3(u2, v1, z));\n\tsum += uw0 * vw2 * texture(shadowMap, vec3(u0, v2, z));\n\tsum += uw1 * vw2 * texture(shadowMap, vec3(u1, v2, z));\n\tsum += uw2 * vw2 * texture(shadowMap, vec3(u2, v2, z));\n\tsum *= 1.0f / 144.0;\n\tsum = gammaCorrectInput(sum);\n\tsum = saturate(sum);\n\treturn sum;\n}\nfloat getShadowPCF5x5(sampler2DShadow shadowMap, vec3 shadowParams) {\n\treturn _getShadowPCF5x5(shadowMap, shadowParams);\n}\nfloat getShadowSpotPCF5x5(sampler2DShadow shadowMap, vec4 shadowParams) {\n\treturn _getShadowPCF5x5(shadowMap, shadowParams.xyz);\n}\n";

var shadowVSM8PS = "float calculateVSM8(vec3 moments, float Z, float vsmBias) {\n\tfloat VSMBias = vsmBias;\n\tfloat depthScale = VSMBias * Z;\n\tfloat minVariance1 = depthScale * depthScale;\n\treturn chebyshevUpperBound(moments.xy, Z, minVariance1, 0.1);\n}\nfloat decodeFloatRG(vec2 rg) {\n\treturn rg.y*(1.0/255.0) + rg.x;\n}\nfloat VSM8(sampler2D tex, vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {\n\tvec4 c = texture2D(tex, texCoords);\n\tvec3 moments = vec3(decodeFloatRG(c.xy), decodeFloatRG(c.zw), 0.0);\n\treturn calculateVSM8(moments, Z, vsmBias);\n}\nfloat getShadowVSM8(sampler2D shadowMap, vec3 shadowParams, float exponent) {\n\treturn VSM8(shadowMap, dShadowCoord.xy, shadowParams.x, dShadowCoord.z, shadowParams.y, 0.0);\n}\nfloat getShadowSpotVSM8(sampler2D shadowMap, vec4 shadowParams, float exponent) {\n\treturn VSM8(shadowMap, dShadowCoord.xy, shadowParams.x, length(dLightDirW) * shadowParams.w + shadowParams.z, shadowParams.y, 0.0);\n}\n";

var shadowVSM_commonPS = "float linstep(float a, float b, float v) {\n\treturn saturate((v - a) / (b - a));\n}\nfloat reduceLightBleeding(float pMax, float amount) {\n	 return linstep(amount, 1.0, pMax);\n}\nfloat chebyshevUpperBound(vec2 moments, float mean, float minVariance, float lightBleedingReduction) {\n\tfloat variance = moments.y - (moments.x * moments.x);\n\tvariance = max(variance, minVariance);\n\tfloat d = mean - moments.x;\n\tfloat pMax = variance / (variance + (d * d));\n\tpMax = reduceLightBleeding(pMax, lightBleedingReduction);\n\treturn (mean <= moments.x ? 1.0 : pMax);\n}\nfloat calculateEVSM(vec3 moments, float Z, float vsmBias, float exponent) {\n\tZ = 2.0 * Z - 1.0;\n\tfloat warpedDepth = exp(exponent * Z);\n\tmoments.xy += vec2(warpedDepth, warpedDepth*warpedDepth) * (1.0 - moments.z);\n\tfloat VSMBias = vsmBias;\n\tfloat depthScale = VSMBias * exponent * warpedDepth;\n\tfloat minVariance1 = depthScale * depthScale;\n\treturn chebyshevUpperBound(moments.xy, warpedDepth, minVariance1, 0.1);\n}\n";

var skinBatchConstVS = "attribute float vertex_boneIndices;\nuniform vec4 matrix_pose[BONE_LIMIT * 3];\nmat4 getBoneMatrix(const in float i) {\n\tvec4 v1 = matrix_pose[int(3.0 * i)];\n\tvec4 v2 = matrix_pose[int(3.0 * i + 1.0)];\n\tvec4 v3 = matrix_pose[int(3.0 * i + 2.0)];\n\treturn mat4(\n\t\tv1.x, v2.x, v3.x, 0,\n\t\tv1.y, v2.y, v3.y, 0,\n\t\tv1.z, v2.z, v3.z, 0,\n\t\tv1.w, v2.w, v3.w, 1\n\t);\n}\n";

var skinBatchTexVS = "attribute float vertex_boneIndices;\nuniform highp sampler2D texture_poseMap;\nuniform vec4 texture_poseMapSize;\nmat4 getBoneMatrix(const in float i) {\n\tfloat j = i * 3.0;\n\tfloat dx = texture_poseMapSize.z;\n\tfloat dy = texture_poseMapSize.w;\n\tfloat y = floor(j * dx);\n\tfloat x = j - (y * texture_poseMapSize.x);\n\ty = dy * (y + 0.5);\n\tvec4 v1 = texture2D(texture_poseMap, vec2(dx * (x + 0.5), y));\n\tvec4 v2 = texture2D(texture_poseMap, vec2(dx * (x + 1.5), y));\n\tvec4 v3 = texture2D(texture_poseMap, vec2(dx * (x + 2.5), y));\n\treturn mat4(\n\t\tv1.x, v2.x, v3.x, 0,\n\t\tv1.y, v2.y, v3.y, 0,\n\t\tv1.z, v2.z, v3.z, 0,\n\t\tv1.w, v2.w, v3.w, 1\n\t);\n}\n";

var skinConstVS = "attribute vec4 vertex_boneWeights;\nattribute vec4 vertex_boneIndices;\nuniform vec4 matrix_pose[BONE_LIMIT * 3];\nvoid getBoneMatrix(const in float i, out vec4 v1, out vec4 v2, out vec4 v3) {\n\tv1 = matrix_pose[int(3.0 * i)];\n\tv2 = matrix_pose[int(3.0 * i + 1.0)];\n\tv3 = matrix_pose[int(3.0 * i + 2.0)];\n}\nmat4 getSkinMatrix(const in vec4 indices, const in vec4 weights) {\n\tvec4 a1, a2, a3;\n\tgetBoneMatrix(indices.x, a1, a2, a3);\n\tvec4 b1, b2, b3;\n\tgetBoneMatrix(indices.y, b1, b2, b3);\n\tvec4 c1, c2, c3;\n\tgetBoneMatrix(indices.z, c1, c2, c3);\n\tvec4 d1, d2, d3;\n\tgetBoneMatrix(indices.w, d1, d2, d3);\n\tvec4 v1 = a1 * weights.x + b1 * weights.y + c1 * weights.z + d1 * weights.w;\n\tvec4 v2 = a2 * weights.x + b2 * weights.y + c2 * weights.z + d2 * weights.w;\n\tvec4 v3 = a3 * weights.x + b3 * weights.y + c3 * weights.z + d3 * weights.w;\n\tfloat one = dot(weights, vec4(1.0));\n\treturn mat4(\n\t\tv1.x, v2.x, v3.x, 0,\n\t\tv1.y, v2.y, v3.y, 0,\n\t\tv1.z, v2.z, v3.z, 0,\n\t\tv1.w, v2.w, v3.w, one\n\t);\n}\n";

var skinTexVS = "attribute vec4 vertex_boneWeights;\nattribute vec4 vertex_boneIndices;\nuniform highp sampler2D texture_poseMap;\nuniform vec4 texture_poseMapSize;\nvoid getBoneMatrix(const in float i, out vec4 v1, out vec4 v2, out vec4 v3) {\n\tfloat j = i * 3.0;\n\tfloat dx = texture_poseMapSize.z;\n\tfloat dy = texture_poseMapSize.w;\n\tfloat y = floor(j * dx);\n\tfloat x = j - (y * texture_poseMapSize.x);\n\ty = dy * (y + 0.5);\n\tv1 = texture2D(texture_poseMap, vec2(dx * (x + 0.5), y));\n\tv2 = texture2D(texture_poseMap, vec2(dx * (x + 1.5), y));\n\tv3 = texture2D(texture_poseMap, vec2(dx * (x + 2.5), y));\n}\nmat4 getSkinMatrix(const in vec4 indices, const in vec4 weights) {\n\tvec4 a1, a2, a3;\n\tgetBoneMatrix(indices.x, a1, a2, a3);\n\tvec4 b1, b2, b3;\n\tgetBoneMatrix(indices.y, b1, b2, b3);\n\tvec4 c1, c2, c3;\n\tgetBoneMatrix(indices.z, c1, c2, c3);\n\tvec4 d1, d2, d3;\n\tgetBoneMatrix(indices.w, d1, d2, d3);\n\tvec4 v1 = a1 * weights.x + b1 * weights.y + c1 * weights.z + d1 * weights.w;\n\tvec4 v2 = a2 * weights.x + b2 * weights.y + c2 * weights.z + d2 * weights.w;\n\tvec4 v3 = a3 * weights.x + b3 * weights.y + c3 * weights.z + d3 * weights.w;\n\tfloat one = dot(weights, vec4(1.0));\n\treturn mat4(\n\t\tv1.x, v2.x, v3.x, 0,\n\t\tv1.y, v2.y, v3.y, 0,\n\t\tv1.z, v2.z, v3.z, 0,\n\t\tv1.w, v2.w, v3.w, one\n\t);\n}\n";

var skyboxEnvPS = "varying vec3 vViewDir;\nuniform sampler2D texture_envAtlas;\nuniform float mipLevel;\nvoid main(void) {\n\tvec3 dir = vViewDir * vec3(-1.0, 1.0, 1.0);\n\tvec2 uv = toSphericalUv(normalize(dir));\n\tvec3 linear = $DECODE(texture2D(texture_envAtlas, mapRoughnessUv(uv, mipLevel)));\n\tgl_FragColor = vec4(gammaCorrectOutput(toneMap(processEnvironment(linear))), 1.0);\n}\n";

var skyboxHDRPS = "varying vec3 vViewDir;\nuniform samplerCube texture_cubeMap;\nvoid main(void) {\n\tvec3 dir=vViewDir;\n\tdir.x *= -1.0;\n\tvec3 color = processEnvironment($textureCubeSAMPLE(texture_cubeMap, fixSeamsStatic(dir, $FIXCONST)).rgb);\n\tcolor = toneMap(color);\n\tcolor = gammaCorrectOutput(color);\n\tgl_FragColor = vec4(color, 1.0);\n}\n";

var skyboxVS = "attribute vec3 aPosition;\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform mat4 matrix_projectionSkybox;\nuniform mat3 cubeMapRotationMatrix;\nvarying vec3 vViewDir;\nvoid main(void) {\n\tmat4 view = matrix_view;\n\tview[3][0] = view[3][1] = view[3][2] = 0.0;\n\tgl_Position = matrix_projectionSkybox * view * vec4(aPosition, 1.0);\n\tgl_Position.z = gl_Position.w - 0.00001;\n\tvViewDir = aPosition * cubeMapRotationMatrix;\n}\n";

var specularPS = "#ifdef MAPCOLOR\nuniform vec3 material_specular;\n#endif\n#ifdef MAPTEXTURE\nuniform sampler2D texture_specularMap;\n#endif\nvoid getSpecularity() {\n\tdSpecularity = vec3(1.0);\n\t#ifdef MAPCOLOR\n\tdSpecularity *= material_specular;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tdSpecularity *= texture2D(texture_specularMap, $UV).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tdSpecularity *= saturate(vVertexColor.$VC);\n\t#endif\n}\n";

var specularAaNonePS = "float antiAliasGlossiness(float power) {\n\treturn power;\n}\n";

var specularAaToksvigPS = "float antiAliasGlossiness(float power) {\n\tfloat rlen = 1.0 / saturate(length(dNormalMap));\n\tfloat toksvig = 1.0 / (1.0 + power * (rlen - 1.0));\n\treturn power * mix(1.0, toksvig, material_bumpiness);\n}\n";

var specularAaToksvigFastPS = "float antiAliasGlossiness(float power) {\n\tfloat rlen = 1.0 / saturate(length(dNormalMap));\n\tfloat toksvig = 1.0 / (1.0 + power * (rlen - 1.0));\n\treturn power * toksvig;\n}\n";

var spotPS = "float getSpotEffect(vec3 lightSpotDirW, float lightInnerConeAngle, float lightOuterConeAngle) {\n\tfloat cosAngle = dot(dLightDirNormW, lightSpotDirW);\n\treturn smoothstep(lightOuterConeAngle, lightInnerConeAngle, cosAngle);\n}\n";

var startPS = "void main(void) {\n\tdDiffuseLight = vec3(0);\n\tdSpecularLight = vec3(0);\n\tdReflection = vec4(0);\n\tdSpecularity = vec3(0);\n\t#ifdef CLEARCOAT\n\tccSpecularLight = vec3(0);\n\tccReflection = vec4(0);\n\t#endif\n";

var startVS = "void main(void) {\n\tgl_Position = getPosition();\n";

var startNineSlicedPS = "\tnineSlicedUv = vUv0;\n\tnineSlicedUv.y = 1.0 - nineSlicedUv.y;\n";

var startNineSlicedTiledPS = "\tvec2 tileMask = step(vMask, vec2(0.99999));\n\tvec2 tileSize = 0.5 * (innerOffset.xy + innerOffset.zw);\n\tvec2 tileScale = vec2(1.0) / (vec2(1.0) - tileSize);\n\tvec2 clampedUv = mix(innerOffset.xy * 0.5, vec2(1.0) - innerOffset.zw * 0.5, fract((vTiledUv - tileSize) * tileScale));\n\tclampedUv = clampedUv * atlasRect.zw + atlasRect.xy;\n\tnineSlicedUv = vUv0 * tileMask + clampedUv * (vec2(1.0) - tileMask);\n\tnineSlicedUv.y = 1.0 - nineSlicedUv.y;\n";

var storeEVSMPS = "float exponent = VSM_EXPONENT;\ndepth = 2.0 * depth - 1.0;\ndepth =	exp(exponent * depth);\ngl_FragColor = vec4(depth, depth*depth, 1.0, 1.0);\n";

var tangentBinormalVS = "vec3 getTangent() {\n\treturn normalize(dNormalMatrix * vertex_tangent.xyz);\n}\nvec3 getBinormal() {\n\treturn cross(vNormalW, vTangentW) * vertex_tangent.w;\n}\nvec3 getObjectSpaceUp() {\n\treturn normalize(dNormalMatrix * vec3(0, 1, 0));\n}\n";

var TBNPS = "void getTBN() {\n\tdTBN = mat3(normalize(dTangentW), normalize(dBinormalW), normalize(dVertexNormalW));\n}\n";

var TBNderivativePS = "uniform float tbnBasis;\nvoid getTBN() {\n\tvec2 uv = $UV;\n\tvec3 dp1 = dFdx( vPositionW );\n\tvec3 dp2 = dFdy( vPositionW );\n\tvec2 duv1 = dFdx( uv );\n\tvec2 duv2 = dFdy( uv );\n\tvec3 dp2perp = cross( dp2, dVertexNormalW );\n\tvec3 dp1perp = cross( dVertexNormalW, dp1 );\n\tvec3 T = dp2perp * duv1.x + dp1perp * duv2.x;\n\tvec3 B = dp2perp * duv1.y + dp1perp * duv2.y;\n\tfloat denom = max( dot(T,T), dot(B,B) );\n\tfloat invmax = (denom == 0.0) ? 0.0 : tbnBasis / sqrt( denom );\n\tdTBN = mat3(T * invmax, -B * invmax, dVertexNormalW );\n}\n";

var TBNfastPS = "void getTBN() {\n\tdTBN = mat3(dTangentW, dBinormalW, dVertexNormalW);\n}\n";

var TBNObjectSpacePS = "void getTBN() {\n\tvec3 B = cross(dVertexNormalW, vObjectSpaceUpW);\n\tvec3 T = cross(dVertexNormalW, B);\n\tif (dot(B,B)==0.0)\n\t{\n\t\tfloat major=max(max(dVertexNormalW.x, dVertexNormalW.y),dVertexNormalW.z);\n\t\tif (dVertexNormalW.x==major)\n\t\t{\n\t\t\tB=cross(dVertexNormalW, vec3(0,1,0));\n\t\t\tT=cross(dVertexNormalW, B);\n\t\t}\n\t\telse if (dVertexNormalW.y==major)\n\t\t{\n\t\t\tB=cross(dVertexNormalW, vec3(0,0,1));\n\t\t\tT=cross(dVertexNormalW, B);\n\t\t}\n\t\telse if (dVertexNormalW.z==major)\n\t\t{\n\t\t\tB=cross(dVertexNormalW, vec3(1,0,0));\n\t\t\tT=cross(dVertexNormalW, B);\n\t\t}\n\t}\n\tdTBN = mat3(normalize(T), normalize(B), normalize(dVertexNormalW));\n}\n";

var tonemappingAcesPS = "uniform float exposure;\nvec3 toneMap(vec3 color) {\n\tfloat tA = 2.51;\n\tfloat tB = 0.03;\n\tfloat tC = 2.43;\n\tfloat tD = 0.59;\n\tfloat tE = 0.14;\n\tvec3 x = color * exposure;\n\treturn (x*(tA*x+tB))/(x*(tC*x+tD)+tE);\n}\n";

var tonemappingAces2PS = "uniform float exposure;\nconst mat3 ACESInputMat = mat3(\n\t0.59719, 0.35458, 0.04823,\n\t0.07600, 0.90834, 0.01566,\n\t0.02840, 0.13383, 0.83777\n);\nconst mat3 ACESOutputMat = mat3(\n\t 1.60475, -0.53108, -0.07367,\n\t-0.10208,	1.10813, -0.00605,\n\t-0.00327, -0.07276,	1.07602\n);\nvec3 RRTAndODTFit(vec3 v) {\n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn a / b;\n}\nvec3 toneMap(vec3 color) {\n\tcolor *= exposure;\n\tcolor = color * ACESInputMat;\n\tcolor = RRTAndODTFit(color);\n\tcolor = color * ACESOutputMat;\n\tcolor = clamp(color, 0.0, 1.0);\n\treturn color;\n}\n";

var tonemappingFilmicPS = "const float A =	0.15;\nconst float B =	0.50;\nconst float C =	0.10;\nconst float D =	0.20;\nconst float E =	0.02;\nconst float F =	0.30;\nconst float W =	11.2;\nuniform float exposure;\nvec3 uncharted2Tonemap(vec3 x) {\n	 return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n}\nvec3 toneMap(vec3 color) {\n\tcolor = uncharted2Tonemap(color * exposure);\n\tvec3 whiteScale = 1.0 / uncharted2Tonemap(vec3(W,W,W));\n\tcolor = color * whiteScale;\n\treturn color;\n}\n";

var tonemappingHejlPS = "uniform float exposure;\nvec3 toneMap(vec3 color) {\n\tcolor *= exposure;\n\tconst float	A = 0.22, B = 0.3, C = .1, D = 0.2, E = .01, F = 0.3;\n\tconst float Scl = 1.25;\n\tvec3 h = max( vec3(0.0), color - vec3(0.004) );\n\treturn (h*((Scl*A)*h+Scl*vec3(C*B,C*B,C*B))+Scl*vec3(D*E,D*E,D*E)) / (h*(A*h+vec3(B,B,B))+vec3(D*F,D*F,D*F)) - Scl*vec3(E/F,E/F,E/F);\n}\n";

var tonemappingLinearPS = "uniform float exposure;\nvec3 toneMap(vec3 color) {\n\treturn color * exposure;\n}\n";

var tonemappingNonePS = "vec3 toneMap(vec3 color) {\n\treturn color;\n}\n";

var transformVS = "#ifdef PIXELSNAP\nuniform vec4 uScreenSize;\n#endif\n#ifdef MORPHING\nuniform vec4 morph_weights_a;\nuniform vec4 morph_weights_b;\n#endif\n#ifdef MORPHING_TEXTURE_BASED\nuniform vec4 morph_tex_params;\nvec2 getTextureMorphCoords() {\n\tfloat vertexId = morph_vertex_id;\n\tvec2 textureSize = morph_tex_params.xy;\n\tvec2 invTextureSize = morph_tex_params.zw;\n\tfloat morphGridV = floor(vertexId * invTextureSize.x);\n\tfloat morphGridU = vertexId - (morphGridV * textureSize.x);\n\treturn (vec2(morphGridU, morphGridV) * invTextureSize) + (0.5 * invTextureSize);\n}\n#endif\n#ifdef MORPHING_TEXTURE_BASED_POSITION\nuniform highp sampler2D morphPositionTex;\n#endif\nmat4 getModelMatrix() {\n\t#ifdef DYNAMICBATCH\n\treturn getBoneMatrix(vertex_boneIndices);\n\t#elif defined(SKIN)\n\treturn matrix_model * getSkinMatrix(vertex_boneIndices, vertex_boneWeights);\n\t#elif defined(INSTANCING)\n\treturn mat4(instance_line1, instance_line2, instance_line3, instance_line4);\n\t#else\n\treturn matrix_model;\n\t#endif\n}\nvec4 getPosition() {\n\tdModelMatrix = getModelMatrix();\n\tvec3 localPos = vertex_position;\n\t#ifdef NINESLICED\n\tlocalPos.xz *= outerScale;\n\tvec2 positiveUnitOffset = clamp(vertex_position.xz, vec2(0.0), vec2(1.0));\n\tvec2 negativeUnitOffset = clamp(-vertex_position.xz, vec2(0.0), vec2(1.0));\n\tlocalPos.xz += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;\n\tvTiledUv = (localPos.xz - outerScale + innerOffset.xy) * -0.5 + 1.0;\n\tlocalPos.xz *= -0.5;\n\tlocalPos = localPos.xzy;\n\t#endif\n\t#ifdef MORPHING\n\t#ifdef MORPHING_POS03\n\tlocalPos.xyz += morph_weights_a[0] * morph_pos0;\n\tlocalPos.xyz += morph_weights_a[1] * morph_pos1;\n\tlocalPos.xyz += morph_weights_a[2] * morph_pos2;\n\tlocalPos.xyz += morph_weights_a[3] * morph_pos3;\n\t#endif\n\t#ifdef MORPHING_POS47\n\tlocalPos.xyz += morph_weights_b[0] * morph_pos4;\n\tlocalPos.xyz += morph_weights_b[1] * morph_pos5;\n\tlocalPos.xyz += morph_weights_b[2] * morph_pos6;\n\tlocalPos.xyz += morph_weights_b[3] * morph_pos7;\n\t#endif\n\t#endif\n\t#ifdef MORPHING_TEXTURE_BASED_POSITION\n\tvec2 morphUV = getTextureMorphCoords();\n\tvec3 morphPos = texture2D(morphPositionTex, morphUV).xyz;\n\tlocalPos += morphPos;\n\t#endif\n\tvec4 posW = dModelMatrix * vec4(localPos, 1.0);\n\t#ifdef SCREENSPACE\n\tposW.zw = vec2(0.0, 1.0);\n\t#endif\n\tdPositionW = posW.xyz;\n\tvec4 screenPos;\n\t#ifdef UV1LAYOUT\n\tscreenPos = vec4(vertex_texCoord1.xy * 2.0 - 1.0, 0.5, 1);\n\t#else\n\t#ifdef SCREENSPACE\n\tscreenPos = posW;\n\t#else\n\tscreenPos = matrix_viewProjection * posW;\n\t#endif\n\t#ifdef PIXELSNAP\n\tscreenPos.xy = (screenPos.xy * 0.5) + 0.5;\n\tscreenPos.xy *= uScreenSize.xy;\n\tscreenPos.xy = floor(screenPos.xy);\n\tscreenPos.xy *= uScreenSize.zw;\n\tscreenPos.xy = (screenPos.xy * 2.0) - 1.0;\n\t#endif\n\t#endif\n\treturn screenPos;\n}\nvec3 getWorldPosition() {\n\treturn dPositionW;\n}\n";

var transformDeclVS = "attribute vec3 vertex_position;\nuniform mat4 matrix_model;\nuniform mat4 matrix_viewProjection;\nvec3 dPositionW;\nmat4 dModelMatrix;\n";

var uv0VS = "#ifdef NINESLICED\nvec2 getUv0() {\n\tvec2 uv = vertex_position.xz;\n\tvec2 positiveUnitOffset = clamp(vertex_position.xz, vec2(0.0), vec2(1.0));\n\tvec2 negativeUnitOffset = clamp(-vertex_position.xz, vec2(0.0), vec2(1.0));\n\tuv += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;\n\tuv = uv * -0.5 + 0.5;\n\tuv = uv * atlasRect.zw + atlasRect.xy;\n\tvMask = vertex_texCoord0.xy;\n\treturn uv;\n}\n#else\nvec2 getUv0() {\n\treturn vertex_texCoord0;\n}\n#endif\n";

var uv1VS = "vec2 getUv1() {\n\treturn vertex_texCoord1;\n}\n";

var viewDirPS = "void getViewDir() {\n\tdViewDirW = normalize(view_position - vPositionW);\n}\n";

var viewNormalVS = "#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nvec3 getViewNormal() {\n\treturn mat3(matrix_view) * vNormalW;\n}\n";

const shaderChunks = {
	alphaTestPS,
	ambientConstantPS,
	ambientEnvPS,
	ambientSHPS,
	aoPS,
	aoSpecOccPS,
	aoSpecOccConstPS,
	aoSpecOccConstSimplePS,
	aoSpecOccSimplePS,
	bakeDirLmEndPS,
	bakeLmEndPS,
	basePS,
	baseVS,
	baseNineSlicedPS,
	baseNineSlicedVS,
	baseNineSlicedTiledPS,
	biasConstPS,
	blurVSMPS,
	clearCoatPS,
	clearCoatGlossPS,
	clearCoatNormalPS,
	clusteredLightCookiesPS,
	clusteredLightShadowsPS,
	clusteredLightUtilsPS,
	clusteredLightPS,
	combineClearCoatPS,
	combineDiffusePS,
	combineDiffuseSpecularPS,
	combineDiffuseSpecularNoConservePS,
	combineDiffuseSpecularNoReflPS,
	combineDiffuseSpecularNoReflSeparateAmbientPS,
	combineDiffuseSpecularOldPS,
	cookiePS,
	cubeMapProjectBoxPS,
	cubeMapProjectNonePS,
	cubeMapRotatePS,
	detailModesPS,
	diffusePS,
	diffuseDetailMapPS,
	dilatePS,
	bilateralDeNoisePS,
	decodePS,
	emissivePS,
	endPS,
	endVS,
	envConstPS,
	envMultiplyPS,
	extensionPS,
	extensionVS,
	falloffInvSquaredPS,
	falloffLinearPS,
	fixCubemapSeamsNonePS,
	fixCubemapSeamsStretchPS,
	floatUnpackingPS,
	fogExpPS,
	fogExp2PS,
	fogLinearPS,
	fogNonePS,
	fresnelSchlickPS,
	fullscreenQuadPS,
	fullscreenQuadVS,
	gamma1_0PS,
	gamma2_2PS,
	gles3PS,
	gles3VS,
	glossPS,
	instancingVS,
	lightDiffuseLambertPS,
	lightDirPointPS,
	lightmapDirPS,
	lightmapSinglePS,
	lightmapSingleVertPS,
	lightSpecularAnisoGGXPS,
	lightSpecularBlinnPS,
	lightSpecularPhongPS,
	ltc,
	metalnessPS,
	msdfPS,
	normalVS,
	normalDetailMapPS,
	normalInstancedVS,
	normalMapPS,
	normalMapFastPS,
	normalSkinnedVS,
	normalVertexPS,
	normalXYPS,
	normalXYZPS,
	opacityPS,
	outputAlphaPS,
	outputAlphaOpaquePS,
	outputAlphaPremulPS,
	outputCubemapPS,
	outputTex2DPS,
	packDepthPS,
	packDepthMaskPS,
	parallaxPS,
	particlePS,
	particleVS,
	particleAnimFrameClampVS,
	particleAnimFrameLoopVS,
	particleAnimTexVS,
	particleInputFloatPS,
	particleInputRgba8PS,
	particleOutputFloatPS,
	particleOutputRgba8PS,
	particleUpdaterAABBPS,
	particleUpdaterEndPS,
	particleUpdaterInitPS,
	particleUpdaterNoRespawnPS,
	particleUpdaterOnStopPS,
	particleUpdaterRespawnPS,
	particleUpdaterSpherePS,
	particleUpdaterStartPS,
	particle_billboardVS,
	particle_blendAddPS,
	particle_blendMultiplyPS,
	particle_blendNormalPS,
	particle_cpuVS,
	particle_cpu_endVS,
	particle_customFaceVS,
	particle_endPS,
	particle_endVS,
	particle_halflambertPS,
	particle_initVS,
	particle_lambertPS,
	particle_lightingPS,
	particle_localShiftVS,
	particle_meshVS,
	particle_normalVS,
	particle_normalMapPS,
	particle_pointAlongVS,
	particle_softPS,
	particle_softVS,
	particle_stretchVS,
	particle_TBNVS,
	particle_wrapVS,
	precisionTestPS,
	precisionTest2PS,
	reflDirPS,
	reflDirAnisoPS,
	reflectionCCPS,
	reflectionCubePS,
	reflectionEnvPS,
	reflectionSpherePS,
	reflectionSphereLowPS,
	refractionPS,
	reprojectPS,
	rgbmPS,
	screenDepthPS,
	shadowCascadesPS,
	shadowCommonPS,
	shadowCoordPS,
	shadowCoordPerspZbufferPS,
	shadowEVSMPS,
	shadowEVSMnPS,
	shadowStandardPS,
	shadowStandardGL2PS,
	shadowVSM8PS,
	shadowVSM_commonPS,
	skinBatchConstVS,
	skinBatchTexVS,
	skinConstVS,
	skinTexVS,
	skyboxEnvPS,
	skyboxHDRPS,
	skyboxVS,
	specularPS,
	specularAaNonePS,
	specularAaToksvigPS,
	specularAaToksvigFastPS,
	spotPS,
	startPS,
	startVS,
	startNineSlicedPS,
	startNineSlicedTiledPS,
	storeEVSMPS,
	tangentBinormalVS,
	TBNPS,
	TBNderivativePS,
	TBNfastPS,
	TBNObjectSpacePS,
	tonemappingAcesPS,
	tonemappingAces2PS,
	tonemappingFilmicPS,
	tonemappingHejlPS,
	tonemappingLinearPS,
	tonemappingNonePS,
	transformVS,
	transformDeclVS,
	uv0VS,
	uv1VS,
	viewDirPS,
	viewNormalVS
};

function gammaCode(value, chunks) {
	if (!chunks) chunks = shaderChunks;

	if (value === GAMMA_SRGB || value === GAMMA_SRGBFAST) {
		return chunks.gamma2_2PS ? chunks.gamma2_2PS : shaderChunks.gamma2_2PS;
	} else if (value === GAMMA_SRGBHDR) {
		return "#define HDR\n" + (chunks.gamma2_2PS ? chunks.gamma2_2PS : shaderChunks.gamma2_2PS);
	}

	return chunks.gamma1_0PS ? chunks.gamma1_0PS : shaderChunks.gamma1_0PS;
}

function tonemapCode(value, chunks) {
	if (!chunks) chunks = shaderChunks;

	if (value === TONEMAP_FILMIC) {
		return chunks.tonemappingFilmicPS ? chunks.tonemappingFilmicPS : shaderChunks.tonemappingFilmicPS;
	} else if (value === TONEMAP_LINEAR) {
		return chunks.tonemappingLinearPS ? chunks.tonemappingLinearPS : shaderChunks.tonemappingLinearPS;
	} else if (value === TONEMAP_HEJL) {
		return chunks.tonemappingHejlPS ? chunks.tonemappingHejlPS : shaderChunks.tonemappingHejlPS;
	} else if (value === TONEMAP_ACES) {
		return chunks.tonemappingAcesPS ? chunks.tonemappingAcesPS : shaderChunks.tonemappingAcesPS;
	} else if (value === TONEMAP_ACES2) {
		return chunks.tonemappingAces2PS ? chunks.tonemappingAces2PS : shaderChunks.tonemappingAces2PS;
	}

	return chunks.tonemapingNonePS ? chunks.tonemapingNonePS : shaderChunks.tonemappingNonePS;
}

function fogCode(value, chunks) {
	if (!chunks) chunks = shaderChunks;

	if (value === 'linear') {
		return chunks.fogLinearPS ? chunks.fogLinearPS : shaderChunks.fogLinearPS;
	} else if (value === 'exp') {
		return chunks.fogExpPS ? chunks.fogExpPS : shaderChunks.fogExpPS;
	} else if (value === 'exp2') {
		return chunks.fogExp2PS ? chunks.fogExp2PS : shaderChunks.fogExp2PS;
	}

	return chunks.fogNonePS ? chunks.fogNonePS : shaderChunks.fogNonePS;
}

function skinCode(device, chunks) {
	if (!chunks) chunks = shaderChunks;

	if (device.supportsBoneTextures) {
		return chunks.skinTexVS;
	}

	return "#define BONE_LIMIT " + device.getBoneLimit() + "\n" + chunks.skinConstVS;
}

function precisionCode(device) {
	let pcode = 'precision ' + device.precision + ' float;\n';

	if (device.webgl2) {
		pcode += '#ifdef GL2\nprecision ' + device.precision + ' sampler2DShadow;\n#endif\n';
	}

	return pcode;
}

function versionCode(device) {
	return device.webgl2 ? "#version 300 es\n" : "";
}

function dummyFragmentCode() {
	return "void main(void) {gl_FragColor = vec4(0.0);}";
}

function begin() {
	return 'void main(void)\n{\n';
}

function end() {
	return '}\n';
}

const attrib2Semantic = {
	vertex_position: SEMANTIC_POSITION,
	vertex_normal: SEMANTIC_NORMAL,
	vertex_tangent: SEMANTIC_TANGENT,
	vertex_texCoord0: SEMANTIC_TEXCOORD0,
	vertex_texCoord1: SEMANTIC_TEXCOORD1,
	vertex_texCoord2: SEMANTIC_TEXCOORD2,
	vertex_texCoord3: SEMANTIC_TEXCOORD3,
	vertex_texCoord4: SEMANTIC_TEXCOORD4,
	vertex_texCoord5: SEMANTIC_TEXCOORD5,
	vertex_texCoord6: SEMANTIC_TEXCOORD6,
	vertex_texCoord7: SEMANTIC_TEXCOORD7,
	vertex_color: SEMANTIC_COLOR,
	vertex_boneIndices: SEMANTIC_BLENDINDICES,
	vertex_boneWeights: SEMANTIC_BLENDWEIGHT
};

function collectAttribs(vsCode) {
	const attribs = {};
	let attrs = 0;
	let found = vsCode.indexOf("attribute");

	while (found >= 0) {
		if (found > 0 && vsCode[found - 1] === "/") break;
		const endOfLine = vsCode.indexOf(';', found);
		const startOfAttribName = vsCode.lastIndexOf(' ', endOfLine);
		const attribName = vsCode.substr(startOfAttribName + 1, endOfLine - (startOfAttribName + 1));
		const semantic = attrib2Semantic[attribName];

		if (semantic !== undefined) {
			attribs[attribName] = semantic;
		} else {
			attribs[attribName] = "ATTR" + attrs;
			attrs++;
		}

		found = vsCode.indexOf("attribute", found + 1);
	}

	return attribs;
}

function createShader(device, vsName, psName, useTransformFeedback = false) {
	let vsCode = shaderChunks[vsName];
	let psCode = precisionCode(device) + "\n" + shaderChunks[psName];
	const attribs = collectAttribs(vsCode);

	if (device.webgl2) {
		vsCode = versionCode(device) + shaderChunks.gles3VS + vsCode;
		psCode = versionCode(device) + shaderChunks.gles3PS + psCode;
	}

	return new Shader(device, {
		attributes: attribs,
		vshader: vsCode,
		fshader: psCode,
		useTransformFeedback: useTransformFeedback
	});
}

function createShaderFromCode(device, vsCode, psCode, uName, useTransformFeedback = false, psPreamble = "") {
	const shaderCache = device.programLib._cache;
	const cached = shaderCache[uName];
	if (cached !== undefined) return cached;
	psCode = precisionCode(device) + "\n" + (psCode || dummyFragmentCode());
	const attribs = collectAttribs(vsCode);

	if (device.webgl2) {
		vsCode = versionCode(device) + shaderChunks.gles3VS + vsCode;
		psCode = versionCode(device) + shaderChunks.gles3PS + psCode;
	}

	shaderCache[uName] = new Shader(device, {
		attributes: attribs,
		vshader: vsCode,
		fshader: psPreamble + psCode,
		useTransformFeedback: useTransformFeedback
	});
	return shaderCache[uName];
}

shaderChunks.collectAttribs = collectAttribs;
shaderChunks.createShader = createShader;
shaderChunks.createShaderFromCode = createShaderFromCode;

class Version {
	constructor() {
		this.globalId = 0;
		this.revision = 0;
	}

	equals(other) {
		return this.globalId === other.globalId && this.revision === other.revision;
	}

	copy(other) {
		this.globalId = other.globalId;
		this.revision = other.revision;
	}

	reset() {
		this.globalId = 0;
		this.revision = 0;
	}

}

let idCounter = 0;

class VersionedObject {
	constructor() {
		idCounter++;
		this.version = new Version();
		this.version.globalId = idCounter;
	}

	increment() {
		this.version.revision++;
	}

}

class ScopeId {
	constructor(name) {
		this.name = name;
		this.value = null;
		this.versionObject = new VersionedObject();
	}

	setValue(value) {
		this.value = value;
		this.versionObject.increment();
	}

	getValue() {
		return this.value;
	}

}

class ScopeSpace {
	constructor(name) {
		this.name = name;
		this.variables = new Map();
	}

	resolve(name) {
		if (!this.variables.has(name)) {
			this.variables.set(name, new ScopeId(name));
		}

		return this.variables.get(name);
	}

	removeValue(value) {
		for (const uniformName in this.variables) {
			const uniform = this.variables[uniformName];

			if (uniform.value === value) {
				uniform.value = null;
			}
		}
	}

}

const basic = {
	generateKey: function (options) {
		let key = 'basic';
		if (options.fog) key += '_fog';
		if (options.alphaTest) key += '_atst';
		if (options.vertexColors) key += '_vcol';
		if (options.diffuseMap) key += '_diff';
		if (options.skin) key += '_skin';
		if (options.screenSpace) key += '_ss';
		if (options.useInstancing) key += '_inst';
		if (options.useMorphPosition) key += '_morphp';
		if (options.useMorphNormal) key += '_morphn';
		if (options.useMorphTextureBased) key += '_morpht';
		key += '_' + options.pass;
		return key;
	},
	createShaderDefinition: function (device, options) {
		const attributes = {
			vertex_position: SEMANTIC_POSITION
		};

		if (options.skin) {
			attributes.vertex_boneWeights = SEMANTIC_BLENDWEIGHT;
			attributes.vertex_boneIndices = SEMANTIC_BLENDINDICES;
		}

		if (options.vertexColors) {
			attributes.vertex_color = SEMANTIC_COLOR;
		}

		if (options.diffuseMap) {
			attributes.vertex_texCoord0 = SEMANTIC_TEXCOORD0;
		}

		let code = '';
		code += shaderChunks.transformDeclVS;

		if (options.skin) {
			code += skinCode(device);
			code += shaderChunks.transformSkinnedVS;
		} else {
			code += shaderChunks.transformVS;
		}

		if (options.vertexColors) {
			code += 'attribute vec4 vertex_color;\n';
			code += 'varying vec4 vColor;\n';
		}

		if (options.diffuseMap) {
			code += 'attribute vec2 vertex_texCoord0;\n';
			code += 'varying vec2 vUv0;\n';
		}

		if (options.pass === SHADER_DEPTH) {
			code += 'varying float vDepth;\n';
			code += '#ifndef VIEWMATRIX\n';
			code += '#define VIEWMATRIX\n';
			code += 'uniform mat4 matrix_view;\n';
			code += '#endif\n';
			code += '#ifndef CAMERAPLANES\n';
			code += '#define CAMERAPLANES\n';
			code += 'uniform vec4 camera_params;\n\n';
			code += '#endif\n';
		}

		code += begin();
		code += "	 gl_Position = getPosition();\n";

		if (options.pass === SHADER_DEPTH) {
			code += "		vDepth = -(matrix_view * vec4(getWorldPosition(),1.0)).z * camera_params.x;\n";
		}

		if (options.vertexColors) {
			code += '		vColor = vertex_color;\n';
		}

		if (options.diffuseMap) {
			code += '		vUv0 = vertex_texCoord0;\n';
		}

		code += end();
		const vshader = code;
		code = precisionCode(device);

		if (options.vertexColors) {
			code += 'varying vec4 vColor;\n';
		} else {
			code += 'uniform vec4 uColor;\n';
		}

		if (options.diffuseMap) {
			code += 'varying vec2 vUv0;\n';
			code += 'uniform sampler2D texture_diffuseMap;\n';
		}

		if (options.fog) {
			code += fogCode(options.fog);
		}

		if (options.alphatest) {
			code += shaderChunks.alphaTestPS;
		}

		if (options.pass === SHADER_DEPTH) {
			code += 'varying float vDepth;\n';
			code += shaderChunks.packDepthPS;
		}

		code += begin();

		if (options.vertexColors) {
			code += '		gl_FragColor = vColor;\n';
		} else {
			code += '		gl_FragColor = uColor;\n';
		}

		if (options.diffuseMap) {
			code += '		gl_FragColor *= texture2D(texture_diffuseMap, vUv0);\n';
		}

		if (options.alphatest) {
			code += "	 alphaTest(gl_FragColor.a);\n";
		}

		if (options.pass !== SHADER_PICK) {
			if (options.pass === SHADER_DEPTH) {
				code += "		gl_FragColor = packFloat(vDepth);\n";
			} else {
				if (options.fog) {
					code += "	 glFragColor.rgb = addFog(gl_FragColor.rgb);\n";
				}
			}
		}

		code += end();
		const fshader = code;
		return {
			attributes: attributes,
			vshader: vshader,
			fshader: fshader
		};
	}
};

const particle = {
	generateKey: function (options) {
		let key = "particle";

		for (const prop in options) {
			if (options.hasOwnProperty(prop)) {
				key += options[prop];
			}
		}

		return key;
	},
	_animTex: function (options) {
		let vshader = "";
		vshader += options.animTexLoop ? shaderChunks.particleAnimFrameLoopVS : shaderChunks.particleAnimFrameClampVS;
		vshader += shaderChunks.particleAnimTexVS;
		return vshader;
	},
	createShaderDefinition: function (device, options) {
		let vshader = "";
		let fshader = precisionCode(device) + "\n";
		fshader += '#define PARTICLE\n';

		if (device.webgl2) {
			vshader += "#define GL2\n";
			fshader += "#define GL2\n";
		}

		vshader += "#define VERTEXSHADER\n";
		if (options.mesh) vshader += "#define USE_MESH\n";
		if (options.localSpace) vshader += "#define LOCAL_SPACE\n";
		if (options.screenSpace) vshader += "#define SCREEN_SPACE\n";
		if (options.animTex) vshader += "\nuniform vec2 animTexTilesParams;\n";
		if (options.animTex) vshader += "\nuniform vec4 animTexParams;\n";
		if (options.animTex) vshader += "\nuniform vec2 animTexIndexParams;\n";
		if (options.normal === 2) vshader += "\nvarying mat3 ParticleMat;\n";
		if (options.normal === 1) vshader += "\nvarying vec3 Normal;\n";
		if (options.soft) vshader += "\nvarying float vDepth;\n";
		const faceVS = options.customFace ? shaderChunks.particle_customFaceVS : shaderChunks.particle_billboardVS;

		if (!options.useCpu) {
			vshader += shaderChunks.particle_initVS;
			vshader += options.pack8 ? shaderChunks.particleInputRgba8PS : shaderChunks.particleInputFloatPS;
			if (options.soft > 0) vshader += shaderChunks.screenDepthPS;
			vshader += shaderChunks.particleVS;
			if (options.localSpace) vshader += shaderChunks.particle_localShiftVS;
			if (options.animTex) vshader += this._animTex(options);
			if (options.wrap) vshader += shaderChunks.particle_wrapVS;
			if (options.alignToMotion) vshader += shaderChunks.particle_pointAlongVS;
			vshader += options.mesh ? shaderChunks.particle_meshVS : faceVS;
			if (options.normal === 1) vshader += shaderChunks.particle_normalVS;
			if (options.normal === 2) vshader += shaderChunks.particle_TBNVS;
			if (options.stretch > 0.0) vshader += shaderChunks.particle_stretchVS;
			vshader += shaderChunks.particle_endVS;
			if (options.soft > 0) vshader += shaderChunks.particle_softVS;
		} else {
			if (options.soft > 0) vshader += shaderChunks.screenDepthPS;
			vshader += shaderChunks.particle_cpuVS;
			if (options.localSpace) vshader += shaderChunks.particle_localShiftVS;
			if (options.animTex) vshader += this._animTex(options);
			if (options.alignToMotion) vshader += shaderChunks.particle_pointAlongVS;
			vshader += options.mesh ? shaderChunks.particle_meshVS : faceVS;
			if (options.normal === 1) vshader += shaderChunks.particle_normalVS;
			if (options.normal === 2) vshader += shaderChunks.particle_TBNVS;
			if (options.stretch > 0.0) vshader += shaderChunks.particle_stretchVS;
			vshader += shaderChunks.particle_cpu_endVS;
			if (options.soft > 0) vshader += shaderChunks.particle_softVS;
		}

		vshader += "}\n";

		if (options.normal > 0) {
			if (options.normal === 1) {
				fshader += "\nvarying vec3 Normal;\n";
			} else if (options.normal === 2) {
				fshader += "\nvarying mat3 ParticleMat;\n";
			}

			fshader += "\nuniform vec3 lightCube[6];\n";
		}

		if (options.soft) fshader += "\nvarying float vDepth;\n";
		if (options.normal === 0 && options.fog === "none") options.srgb = false;
		fshader += gammaCode(options.gamma);
		fshader += tonemapCode(options.toneMap);

		if (options.fog === 'linear') {
			fshader += shaderChunks.fogLinearPS;
		} else if (options.fog === 'exp') {
			fshader += shaderChunks.fogExpPS;
		} else if (options.fog === 'exp2') {
			fshader += shaderChunks.fogExp2PS;
		} else {
			fshader += shaderChunks.fogNonePS;
		}

		if (options.normal === 2) fshader += "\nuniform sampler2D normalMap;\n";
		if (options.soft > 0) fshader += shaderChunks.screenDepthPS;
		fshader += shaderChunks.particlePS;
		if (options.soft > 0) fshader += shaderChunks.particle_softPS;
		if (options.normal === 1) fshader += "\nvec3 normal = Normal;\n";
		if (options.normal === 2) fshader += shaderChunks.particle_normalMapPS;
		if (options.normal > 0) fshader += options.halflambert ? shaderChunks.particle_halflambertPS : shaderChunks.particle_lambertPS;
		if (options.normal > 0) fshader += shaderChunks.particle_lightingPS;

		if (options.blend === BLEND_NORMAL) {
			fshader += shaderChunks.particle_blendNormalPS;
		} else if (options.blend === BLEND_ADDITIVE) {
			fshader += shaderChunks.particle_blendAddPS;
		} else if (options.blend === BLEND_MULTIPLICATIVE) {
			fshader += shaderChunks.particle_blendMultiplyPS;
		}

		fshader += shaderChunks.particle_endPS;
		const attributes = collectAttribs(vshader);
		return {
			attributes: attributes,
			vshader: vshader,
			fshader: fshader
		};
	}
};

const skybox = {
	generateKey: function (options) {
		return options.type === 'cubemap' ? `skybox-${options.type}-${options.rgbm}-${options.hdr}-${options.fixSeams}-${options.toneMapping}-${options.gamma}-${options.useIntensity}-${options.mip}` : `skybox-${options.type}-${options.encoding}-${options.useIntensity}-${options.gamma}-${options.toneMapping}`;
	},
	createShaderDefinition: function (device, options) {
		let fshader;

		if (options.type === 'cubemap') {
			const mip2size = [128, 64, 16, 8, 4, 2];
			fshader = precisionCode(device);
			fshader += options.mip ? shaderChunks.fixCubemapSeamsStretchPS : shaderChunks.fixCubemapSeamsNonePS;
			fshader += options.useIntensity ? shaderChunks.envMultiplyPS : shaderChunks.envConstPS;
			fshader += gammaCode(options.gamma);
			fshader += tonemapCode(options.toneMapping);
			fshader += shaderChunks.decodePS;
			fshader += shaderChunks.rgbmPS;
			fshader += shaderChunks.skyboxHDRPS.replace(/\$textureCubeSAMPLE/g, options.rgbm ? "textureCubeRGBM" : options.hdr ? "textureCube" : "textureCubeSRGB").replace(/\$FIXCONST/g, 1 - 1 / mip2size[options.mip] + "");
		} else {
			const decodeTable = {
				'rgbm': 'decodeRGBM',
				'rgbe': 'decodeRGBE',
				'linear': 'decodeLinear'
			};
			fshader = precisionCode(device);
			fshader += options.useIntensity ? shaderChunks.envMultiplyPS : shaderChunks.envConstPS;
			fshader += gammaCode(options.gamma);
			fshader += tonemapCode(options.toneMapping);
			fshader += shaderChunks.decodePS;
			fshader += shaderChunks.skyboxEnvPS.replace(/\$DECODE/g, decodeTable[options.encoding] || "decodeGamma");
		}

		return {
			attributes: {
				aPosition: SEMANTIC_POSITION
			},
			vshader: shaderChunks.skyboxVS,
			fshader: fshader
		};
	}
};

const oneDiv255 = 1 / 255;
const floatView = new Float32Array(1);
const int32View = new Int32Array(floatView.buffer);

class FloatPacking {
	static float2Half(value) {
		floatView[0] = value;
		const x = int32View[0];
		let bits = x >> 16 & 0x8000;
		let m = x >> 12 & 0x07ff;
		const e = x >> 23 & 0xff;

		if (e < 103) {
			return bits;
		}

		if (e > 142) {
			bits |= 0x7c00;
			bits |= (e === 255 ? 0 : 1) && x & 0x007fffff;
			return bits;
		}

		if (e < 113) {
			m |= 0x0800;
			bits |= (m >> 114 - e) + (m >> 113 - e & 1);
			return bits;
		}

		bits |= e - 112 << 10 | m >> 1;
		bits += m & 1;
		return bits;
	}

	static float2Bytes(value, array, offset, numBytes) {
		const enc1 = 255.0 * value % 1;
		array[offset + 0] = Math.round((value % 1 - oneDiv255 * enc1) * 255);

		if (numBytes > 1) {
			const enc2 = 65025.0 * value % 1;
			array[offset + 1] = Math.round((enc1 - oneDiv255 * enc2) * 255);

			if (numBytes > 2) {
				const enc3 = 16581375.0 * value % 1;
				array[offset + 2] = Math.round((enc2 - oneDiv255 * enc3) * 255);

				if (numBytes > 3) {
					array[offset + 3] = Math.round(enc3 * 255);
				}
			}
		}
	}

	static float2BytesRange(value, array, offset, min, max, numBytes) {
		value = math.clamp((value - min) / (max - min), 0, 1);
		FloatPacking.float2Bytes(value, array, offset, numBytes);
	}

	static float2MantissaExponent(value, array, offset, numBytes) {
		const exponent = Math.floor(Math.log2(Math.abs(value))) + 1;
		value /= Math.pow(2, exponent);
		FloatPacking.float2BytesRange(value, array, offset, -1, 1, numBytes - 1);
		array[offset + numBytes - 1] = Math.round(exponent + 127);
	}

}

let _pixelSizeTable = null;
let _blockSizeTable = null;

class Texture {
	constructor(graphicsDevice, options) {
		this.device = graphicsDevice;
		this.name = null;
		this._width = 4;
		this._height = 4;
		this._depth = 1;
		this._format = PIXELFORMAT_R8_G8_B8_A8;
		this.type = TEXTURETYPE_DEFAULT;
		this.projection = TEXTUREPROJECTION_NONE;
		this._cubemap = false;
		this._volume = false;
		this.fixCubemapSeams = false;
		this._flipY = false;
		this._premultiplyAlpha = false;
		this._isRenderTarget = false;
		this._mipmaps = true;
		this._minFilter = FILTER_LINEAR_MIPMAP_LINEAR;
		this._magFilter = FILTER_LINEAR;
		this._anisotropy = 1;
		this._addressU = ADDRESS_REPEAT;
		this._addressV = ADDRESS_REPEAT;
		this._addressW = ADDRESS_REPEAT;
		this._compareOnRead = false;
		this._compareFunc = FUNC_LESS;

		if (options !== undefined) {
			if (options.name !== undefined) {
				this.name = options.name;
			}

			this._width = options.width !== undefined ? options.width : this._width;
			this._height = options.height !== undefined ? options.height : this._height;
			this._format = options.format !== undefined ? options.format : this._format;

			if (options.hasOwnProperty('type')) {
				this.type = options.type;
			} else if (options.hasOwnProperty('rgbm')) {
				this.type = options.rgbm ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT;
			} else if (options.hasOwnProperty('swizzleGGGR')) {
				this.type = options.swizzleGGGR ? TEXTURETYPE_SWIZZLEGGGR : TEXTURETYPE_DEFAULT;
			}

			if (options.mipmaps !== undefined) {
				this._mipmaps = options.mipmaps;
			} else {
				this._mipmaps = options.autoMipmap !== undefined ? options.autoMipmap : this._mipmaps;
			}

			this._levels = options.levels;
			this._cubemap = options.cubemap !== undefined ? options.cubemap : this._cubemap;
			this.fixCubemapSeams = options.fixCubemapSeams !== undefined ? options.fixCubemapSeams : this.fixCubemapSeams;

			if (this._cubemap) {
				this.projection = TEXTUREPROJECTION_CUBE;
			} else if (options.projection && options.projection !== TEXTUREPROJECTION_CUBE) {
				this.projection = options.projection;
			}

			this._minFilter = options.minFilter !== undefined ? options.minFilter : this._minFilter;
			this._magFilter = options.magFilter !== undefined ? options.magFilter : this._magFilter;
			this._anisotropy = options.anisotropy !== undefined ? options.anisotropy : this._anisotropy;
			this._addressU = options.addressU !== undefined ? options.addressU : this._addressU;
			this._addressV = options.addressV !== undefined ? options.addressV : this._addressV;
			this._compareOnRead = options.compareOnRead !== undefined ? options.compareOnRead : this._compareOnRead;
			this._compareFunc = options._compareFunc !== undefined ? options._compareFunc : this._compareFunc;
			this._flipY = options.flipY !== undefined ? options.flipY : this._flipY;
			this._premultiplyAlpha = options.premultiplyAlpha !== undefined ? options.premultiplyAlpha : this._premultiplyAlpha;

			if (graphicsDevice.webgl2) {
				this._depth = options.depth !== undefined ? options.depth : this._depth;
				this._volume = options.volume !== undefined ? options.volume : this._volume;
				this._addressW = options.addressW !== undefined ? options.addressW : this._addressW;
			}
		}

		this._compressed = this._format === PIXELFORMAT_DXT1 || this._format === PIXELFORMAT_DXT3 || this._format === PIXELFORMAT_DXT5 || this._format >= PIXELFORMAT_ETC1;
		this._invalid = false;
		this._lockedLevel = -1;

		if (!this._levels) {
			this._levels = this._cubemap ? [[null, null, null, null, null, null]] : [null];
		}

		this.dirtyAll();
		this._gpuSize = 0;
		this.impl = graphicsDevice.createTextureImpl(this);
		graphicsDevice.textures.push(this);
	}

	destroy() {
		if (this.device) {
			const device = this.device;
			const idx = device.textures.indexOf(this);

			if (idx !== -1) {
				device.textures.splice(idx, 1);
			}

			device.scope.removeValue(this);
			this.impl.destroy(device);
			this.adjustVramSizeTracking(device._vram, -this._gpuSize);
			this._levels = null;
			this.device = null;
		}
	}

	loseContext() {
		this.impl.loseContext();
		this.dirtyAll();
	}

	adjustVramSizeTracking(vram, size) {
		vram.tex += size;
	}

	set minFilter(v) {
		if (this._minFilter !== v) {
			this._minFilter = v;
			this._parameterFlags |= 1;
		}
	}

	get minFilter() {
		return this._minFilter;
	}

	set magFilter(v) {
		if (this._magFilter !== v) {
			this._magFilter = v;
			this._parameterFlags |= 2;
		}
	}

	get magFilter() {
		return this._magFilter;
	}

	set addressU(v) {
		if (this._addressU !== v) {
			this._addressU = v;
			this._parameterFlags |= 4;
		}
	}

	get addressU() {
		return this._addressU;
	}

	set addressV(v) {
		if (this._addressV !== v) {
			this._addressV = v;
			this._parameterFlags |= 8;
		}
	}

	get addressV() {
		return this._addressV;
	}

	set addressW(addressW) {
		if (!this.device.webgl2) return;

		if (!this._volume) {
			return;
		}

		if (addressW !== this._addressW) {
			this._addressW = addressW;
			this._parameterFlags |= 16;
		}
	}

	get addressW() {
		return this._addressW;
	}

	set compareOnRead(v) {
		if (this._compareOnRead !== v) {
			this._compareOnRead = v;
			this._parameterFlags |= 32;
		}
	}

	get compareOnRead() {
		return this._compareOnRead;
	}

	set compareFunc(v) {
		if (this._compareFunc !== v) {
			this._compareFunc = v;
			this._parameterFlags |= 64;
		}
	}

	get compareFunc() {
		return this._compareFunc;
	}

	set anisotropy(v) {
		if (this._anisotropy !== v) {
			this._anisotropy = v;
			this._parameterFlags |= 128;
		}
	}

	get anisotropy() {
		return this._anisotropy;
	}

	set autoMipmap(v) {
		this._mipmaps = v;
	}

	get autoMipmap() {
		return this._mipmaps;
	}

	set mipmaps(v) {
		if (this._mipmaps !== v) {
			this._mipmaps = v;
			if (v) this._needsMipmapsUpload = true;
		}
	}

	get mipmaps() {
		return this._mipmaps;
	}

	get width() {
		return this._width;
	}

	get height() {
		return this._height;
	}

	get depth() {
		return this._depth;
	}

	get format() {
		return this._format;
	}

	get cubemap() {
		return this._cubemap;
	}

	get gpuSize() {
		const mips = this.pot && this._mipmaps && !(this._compressed && this._levels.length === 1);
		return Texture.calcGpuSize(this._width, this._height, this._depth, this._format, mips, this._cubemap);
	}

	get volume() {
		return this._volume;
	}

	set flipY(flipY) {
		if (this._flipY !== flipY) {
			this._flipY = flipY;
			this._needsUpload = true;
		}
	}

	get flipY() {
		return this._flipY;
	}

	set premultiplyAlpha(premultiplyAlpha) {
		if (this._premultiplyAlpha !== premultiplyAlpha) {
			this._premultiplyAlpha = premultiplyAlpha;
			this._needsUpload = true;
		}
	}

	get premultiplyAlpha() {
		return this._premultiplyAlpha;
	}

	get pot() {
		return math.powerOfTwo(this._width) && math.powerOfTwo(this._height);
	}

	get encoding() {
		if (this.type === TEXTURETYPE_RGBM) {
			return 'rgbm';
		}

		if (this.type === TEXTURETYPE_RGBE) {
			return 'rgbe';
		}

		if (this.format === PIXELFORMAT_RGBA16F || this.format === PIXELFORMAT_RGBA32F) {
			return 'linear';
		}

		return 'srgb';
	}

	static calcGpuSize(width, height, depth, format, mipmaps, cubemap) {
		if (!_pixelSizeTable) {
			_pixelSizeTable = [];
			_pixelSizeTable[PIXELFORMAT_A8] = 1;
			_pixelSizeTable[PIXELFORMAT_L8] = 1;
			_pixelSizeTable[PIXELFORMAT_L8_A8] = 2;
			_pixelSizeTable[PIXELFORMAT_R5_G6_B5] = 2;
			_pixelSizeTable[PIXELFORMAT_R5_G5_B5_A1] = 2;
			_pixelSizeTable[PIXELFORMAT_R4_G4_B4_A4] = 2;
			_pixelSizeTable[PIXELFORMAT_R8_G8_B8] = 4;
			_pixelSizeTable[PIXELFORMAT_R8_G8_B8_A8] = 4;
			_pixelSizeTable[PIXELFORMAT_RGB16F] = 8;
			_pixelSizeTable[PIXELFORMAT_RGBA16F] = 8;
			_pixelSizeTable[PIXELFORMAT_RGB32F] = 16;
			_pixelSizeTable[PIXELFORMAT_RGBA32F] = 16;
			_pixelSizeTable[PIXELFORMAT_R32F] = 4;
			_pixelSizeTable[PIXELFORMAT_DEPTH] = 4;
			_pixelSizeTable[PIXELFORMAT_DEPTHSTENCIL] = 4;
			_pixelSizeTable[PIXELFORMAT_111110F] = 4;
			_pixelSizeTable[PIXELFORMAT_SRGB] = 4;
			_pixelSizeTable[PIXELFORMAT_SRGBA] = 4;
		}

		if (!_blockSizeTable) {
			_blockSizeTable = [];
			_blockSizeTable[PIXELFORMAT_ETC1] = 8;
			_blockSizeTable[PIXELFORMAT_ETC2_RGB] = 8;
			_blockSizeTable[PIXELFORMAT_PVRTC_2BPP_RGB_1] = 8;
			_blockSizeTable[PIXELFORMAT_PVRTC_2BPP_RGBA_1] = 8;
			_blockSizeTable[PIXELFORMAT_PVRTC_4BPP_RGB_1] = 8;
			_blockSizeTable[PIXELFORMAT_PVRTC_4BPP_RGBA_1] = 8;
			_blockSizeTable[PIXELFORMAT_DXT1] = 8;
			_blockSizeTable[PIXELFORMAT_ATC_RGB] = 8;
			_blockSizeTable[PIXELFORMAT_ETC2_RGBA] = 16;
			_blockSizeTable[PIXELFORMAT_DXT3] = 16;
			_blockSizeTable[PIXELFORMAT_DXT5] = 16;
			_blockSizeTable[PIXELFORMAT_ASTC_4x4] = 16;
			_blockSizeTable[PIXELFORMAT_ATC_RGBA] = 16;
		}

		const pixelSize = _pixelSizeTable.hasOwnProperty(format) ? _pixelSizeTable[format] : 0;
		const blockSize = _blockSizeTable.hasOwnProperty(format) ? _blockSizeTable[format] : 0;
		let result = 0;

		while (1) {
			if (pixelSize > 0) {
				result += width * height * depth * pixelSize;
			} else {
				let blockWidth = Math.floor((width + 3) / 4);
				const blockHeight = Math.floor((height + 3) / 4);
				const blockDepth = Math.floor((depth + 3) / 4);

				if (format === PIXELFORMAT_PVRTC_2BPP_RGB_1 || format === PIXELFORMAT_PVRTC_2BPP_RGBA_1) {
					blockWidth = Math.max(Math.floor(blockWidth / 2), 1);
				}

				result += blockWidth * blockHeight * blockDepth * blockSize;
			}

			if (!mipmaps || width === 1 && height === 1 && depth === 1) {
				break;
			}

			width = Math.max(Math.floor(width / 2), 1);
			height = Math.max(Math.floor(height / 2), 1);
			depth = Math.max(Math.floor(depth / 2), 1);
		}

		return result * (cubemap ? 6 : 1);
	}

	dirtyAll() {
		this._levelsUpdated = this._cubemap ? [[true, true, true, true, true, true]] : [true];
		this._needsUpload = true;
		this._needsMipmapsUpload = this._mipmaps;
		this._mipmapsUploaded = false;
		this._parameterFlags = 255;
	}

	lock(options = {}) {
		if (options.level === undefined) {
			options.level = 0;
		}

		if (options.face === undefined) {
			options.face = 0;
		}

		if (options.mode === undefined) {
			options.mode = TEXTURELOCK_WRITE;
		}

		this._lockedLevel = options.level;

		if (this._levels[options.level] === null) {
			switch (this._format) {
				case PIXELFORMAT_A8:
				case PIXELFORMAT_L8:
					this._levels[options.level] = new Uint8Array(this._width * this._height * this._depth);
					break;

				case PIXELFORMAT_L8_A8:
					this._levels[options.level] = new Uint8Array(this._width * this._height * this._depth * 2);
					break;

				case PIXELFORMAT_R5_G6_B5:
				case PIXELFORMAT_R5_G5_B5_A1:
				case PIXELFORMAT_R4_G4_B4_A4:
					this._levels[options.level] = new Uint16Array(this._width * this._height * this._depth);
					break;

				case PIXELFORMAT_R8_G8_B8:
					this._levels[options.level] = new Uint8Array(this._width * this._height * this._depth * 3);
					break;

				case PIXELFORMAT_R8_G8_B8_A8:
					this._levels[options.level] = new Uint8Array(this._width * this._height * this._depth * 4);
					break;

				case PIXELFORMAT_DXT1:
					this._levels[options.level] = new Uint8Array(Math.floor((this._width + 3) / 4) * Math.floor((this._height + 3) / 4) * 8 * this._depth);
					break;

				case PIXELFORMAT_DXT3:
				case PIXELFORMAT_DXT5:
					this._levels[options.level] = new Uint8Array(Math.floor((this._width + 3) / 4) * Math.floor((this._height + 3) / 4) * 16 * this._depth);
					break;

				case PIXELFORMAT_RGB16F:
					this._levels[options.level] = new Uint16Array(this._width * this._height * this._depth * 3);
					break;

				case PIXELFORMAT_RGB32F:
					this._levels[options.level] = new Float32Array(this._width * this._height * this._depth * 3);
					break;

				case PIXELFORMAT_RGBA16F:
					this._levels[options.level] = new Uint16Array(this._width * this._height * this._depth * 4);
					break;

				case PIXELFORMAT_RGBA32F:
					this._levels[options.level] = new Float32Array(this._width * this._height * this._depth * 4);
					break;
			}
		}

		return this._levels[options.level];
	}

	setSource(source, mipLevel = 0) {
		let invalid = false;
		let width, height;

		if (this._cubemap) {
			if (source[0]) {
				width = source[0].width || 0;
				height = source[0].height || 0;

				for (let i = 0; i < 6; i++) {
					const face = source[i];

					if (!face || face.width !== width || face.height !== height || !this.device._isBrowserInterface(face)) {
						invalid = true;
						break;
					}
				}
			} else {
				invalid = true;
			}

			if (!invalid) {
				for (let i = 0; i < 6; i++) {
					if (this._levels[mipLevel][i] !== source[i]) this._levelsUpdated[mipLevel][i] = true;
				}
			}
		} else {
			if (!this.device._isBrowserInterface(source)) invalid = true;

			if (!invalid) {
				if (source !== this._levels[mipLevel]) this._levelsUpdated[mipLevel] = true;
				width = source.width;
				height = source.height;
			}
		}

		if (invalid) {
			this._width = 4;
			this._height = 4;

			if (this._cubemap) {
				for (let i = 0; i < 6; i++) {
					this._levels[mipLevel][i] = null;
					this._levelsUpdated[mipLevel][i] = true;
				}
			} else {
				this._levels[mipLevel] = null;
				this._levelsUpdated[mipLevel] = true;
			}
		} else {
			if (mipLevel === 0) {
				this._width = width;
				this._height = height;
			}

			this._levels[mipLevel] = source;
		}

		if (this._invalid !== invalid || !invalid) {
			this._invalid = invalid;
			this.upload();
		}
	}

	getSource(mipLevel = 0) {
		return this._levels[mipLevel];
	}

	unlock() {
		if (this._lockedLevel === -1) ;

		this.upload();
		this._lockedLevel = -1;
	}

	upload() {
		this._needsUpload = true;
		this._needsMipmapsUpload = this._mipmaps;
	}

	getDds() {
		let fsize = 128;
		let idx = 0;

		while (this._levels[idx]) {
			if (!this.cubemap) {
				const mipSize = this._levels[idx].length;

				if (!mipSize) {
					return;
				}

				fsize += mipSize;
			} else {
				for (let face = 0; face < 6; face++) {
					if (!this._levels[idx][face]) {
						return;
					}

					const mipSize = this._levels[idx][face].length;

					if (!mipSize) {
						return;
					}

					fsize += mipSize;
				}
			}

			fsize += this._levels[idx].length;
			idx++;
		}

		const buff = new ArrayBuffer(fsize);
		const header = new Uint32Array(buff, 0, 128 / 4);
		const DDS_MAGIC = 542327876;
		const DDS_HEADER_SIZE = 124;
		const DDS_FLAGS_REQUIRED = 0x01 | 0x02 | 0x04 | 0x1000 | 0x80000;
		const DDS_FLAGS_MIPMAP = 0x20000;
		const DDS_PIXELFORMAT_SIZE = 32;
		const DDS_PIXELFLAGS_RGBA8 = 0x01 | 0x40;
		const DDS_CAPS_REQUIRED = 0x1000;
		const DDS_CAPS_MIPMAP = 0x400000;
		const DDS_CAPS_COMPLEX = 0x8;
		const DDS_CAPS2_CUBEMAP = 0x200 | 0x400 | 0x800 | 0x1000 | 0x2000 | 0x4000 | 0x8000;
		let flags = DDS_FLAGS_REQUIRED;
		if (this._levels.length > 1) flags |= DDS_FLAGS_MIPMAP;
		let caps = DDS_CAPS_REQUIRED;
		if (this._levels.length > 1) caps |= DDS_CAPS_MIPMAP;
		if (this._levels.length > 1 || this.cubemap) caps |= DDS_CAPS_COMPLEX;
		const caps2 = this.cubemap ? DDS_CAPS2_CUBEMAP : 0;
		header[0] = DDS_MAGIC;
		header[1] = DDS_HEADER_SIZE;
		header[2] = flags;
		header[3] = this.height;
		header[4] = this.width;
		header[5] = this.width * this.height * 4;
		header[6] = 0;
		header[7] = this._levels.length;

		for (let i = 0; i < 11; i++) {
			header[8 + i] = 0;
		}

		header[19] = DDS_PIXELFORMAT_SIZE;
		header[20] = DDS_PIXELFLAGS_RGBA8;
		header[21] = 0;
		header[22] = 32;
		header[23] = 0x00FF0000;
		header[24] = 0x0000FF00;
		header[25] = 0x000000FF;
		header[26] = 0xFF000000;
		header[27] = caps;
		header[28] = caps2;
		header[29] = 0;
		header[30] = 0;
		header[31] = 0;
		let offset = 128;

		if (!this.cubemap) {
			for (let i = 0; i < this._levels.length; i++) {
				const level = this._levels[i];
				const mip = new Uint8Array(buff, offset, level.length);

				for (let j = 0; j < level.length; j++) {
					mip[j] = level[j];
				}

				offset += level.length;
			}
		} else {
			for (let face = 0; face < 6; face++) {
				for (let i = 0; i < this._levels.length; i++) {
					const level = this._levels[i][face];
					const mip = new Uint8Array(buff, offset, level.length);

					for (let j = 0; j < level.length; j++) {
						mip[j] = level[j];
					}

					offset += level.length;
				}
			}
		}

		return buff;
	}

}

const _deviceCoord = new Vec3();

const _halfSize = new Vec3();

const _point = new Vec3();

const _invViewProjMat = new Mat4();

class Camera {
	constructor() {
		this._aspectRatio = 16 / 9;
		this._aspectRatioMode = ASPECT_AUTO;
		this._calculateProjection = null;
		this._calculateTransform = null;
		this._clearColor = new Color(0.75, 0.75, 0.75, 1);
		this._clearColorBuffer = true;
		this._clearDepth = 1;
		this._clearDepthBuffer = true;
		this._clearStencil = 0;
		this._clearStencilBuffer = true;
		this._cullingMask = 0xFFFFFFFF;
		this._cullFaces = true;
		this._farClip = 1000;
		this._flipFaces = false;
		this._fov = 45;
		this._frustumCulling = true;
		this._horizontalFov = false;
		this._layers = [LAYERID_WORLD, LAYERID_DEPTH, LAYERID_SKYBOX, LAYERID_UI, LAYERID_IMMEDIATE];
		this._nearClip = 0.1;
		this._node = null;
		this._orthoHeight = 10;
		this._projection = PROJECTION_PERSPECTIVE;
		this._rect = new Vec4(0, 0, 1, 1);
		this._renderTarget = null;
		this._scissorRect = new Vec4(0, 0, 1, 1);
		this._scissorRectClear = false;
		this._vrDisplay = null;
		this._projMat = new Mat4();
		this._projMatDirty = true;
		this._projMatSkybox = new Mat4();
		this._viewMat = new Mat4();
		this._viewMatDirty = true;
		this._viewProjMat = new Mat4();
		this._viewProjMatDirty = true;
		this.frustum = new Frustum();
	}

	set aspectRatio(newValue) {
		if (this._aspectRatio !== newValue) {
			this._aspectRatio = newValue;
			this._projMatDirty = true;
		}
	}

	get aspectRatio() {
		return this._aspectRatio;
	}

	set aspectRatioMode(newValue) {
		if (this._aspectRatioMode !== newValue) {
			this._aspectRatioMode = newValue;
			this._projMatDirty = true;
		}
	}

	get aspectRatioMode() {
		return this._aspectRatioMode;
	}

	set calculateProjection(newValue) {
		this._calculateProjection = newValue;
		this._projMatDirty = true;
	}

	get calculateProjection() {
		return this._calculateProjection;
	}

	set calculateTransform(newValue) {
		this._calculateTransform = newValue;
	}

	get calculateTransform() {
		return this._calculateTransform;
	}

	set clearColor(newValue) {
		this._clearColor.copy(newValue);
	}

	get clearColor() {
		return this._clearColor;
	}

	set clearColorBuffer(newValue) {
		this._clearColorBuffer = newValue;
	}

	get clearColorBuffer() {
		return this._clearColorBuffer;
	}

	set clearDepth(newValue) {
		this._clearDepth = newValue;
	}

	get clearDepth() {
		return this._clearDepth;
	}

	set clearDepthBuffer(newValue) {
		this._clearDepthBuffer = newValue;
	}

	get clearDepthBuffer() {
		return this._clearDepthBuffer;
	}

	set clearStencil(newValue) {
		this._clearStencil = newValue;
	}

	get clearStencil() {
		return this._clearStencil;
	}

	set clearStencilBuffer(newValue) {
		this._clearStencilBuffer = newValue;
	}

	get clearStencilBuffer() {
		return this._clearStencilBuffer;
	}

	set cullingMask(newValue) {
		this._cullingMask = newValue;
	}

	get cullingMask() {
		return this._cullingMask;
	}

	set cullFaces(newValue) {
		this._cullFaces = newValue;
	}

	get cullFaces() {
		return this._cullFaces;
	}

	set farClip(newValue) {
		if (this._farClip !== newValue) {
			this._farClip = newValue;
			this._projMatDirty = true;
		}
	}

	get farClip() {
		return this._farClip;
	}

	set flipFaces(newValue) {
		this._flipFaces = newValue;
	}

	get flipFaces() {
		return this._flipFaces;
	}

	set fov(newValue) {
		if (this._fov !== newValue) {
			this._fov = newValue;
			this._projMatDirty = true;
		}
	}

	get fov() {
		return this._fov;
	}

	set frustumCulling(newValue) {
		this._frustumCulling = newValue;
	}

	get frustumCulling() {
		return this._frustumCulling;
	}

	set horizontalFov(newValue) {
		if (this._horizontalFov !== newValue) {
			this._horizontalFov = newValue;
			this._projMatDirty = true;
		}
	}

	get horizontalFov() {
		return this._horizontalFov;
	}

	set layers(newValue) {
		this._layers = newValue.slice(0);
	}

	get layers() {
		return this._layers;
	}

	set nearClip(newValue) {
		if (this._nearClip !== newValue) {
			this._nearClip = newValue;
			this._projMatDirty = true;
		}
	}

	get nearClip() {
		return this._nearClip;
	}

	set node(newValue) {
		this._node = newValue;
	}

	get node() {
		return this._node;
	}

	set orthoHeight(newValue) {
		if (this._orthoHeight !== newValue) {
			this._orthoHeight = newValue;
			this._projMatDirty = true;
		}
	}

	get orthoHeight() {
		return this._orthoHeight;
	}

	set projection(newValue) {
		if (this._projection !== newValue) {
			this._projection = newValue;
			this._projMatDirty = true;
		}
	}

	get projection() {
		return this._projection;
	}

	get projectionMatrix() {
		this._evaluateProjectionMatrix();

		return this._projMat;
	}

	set rect(newValue) {
		this._rect.copy(newValue);
	}

	get rect() {
		return this._rect;
	}

	set renderTarget(newValue) {
		this._renderTarget = newValue;
	}

	get renderTarget() {
		return this._renderTarget;
	}

	set scissorRect(newValue) {
		this._scissorRect.copy(newValue);
	}

	get scissorRect() {
		return this._scissorRect;
	}

	get viewMatrix() {
		if (this._viewMatDirty) {
			const wtm = this._node.getWorldTransform();

			this._viewMat.copy(wtm).invert();

			this._viewMatDirty = false;
		}

		return this._viewMat;
	}

	set vrDisplay(newValue) {
		this._vrDisplay = newValue;

		if (newValue) {
			newValue._camera = this;
		}
	}

	get vrDisplay() {
		return this._vrDisplay;
	}

	clone() {
		return new Camera().copy(this);
	}

	copy(other) {
		this.aspectRatio = other.aspectRatio;
		this.aspectRatioMode = other.aspectRatioMode;
		this.calculateProjection = other.calculateProjection;
		this.calculateTransform = other.calculateTransform;
		this.clearColor = other.clearColor;
		this.clearColorBuffer = other.clearColorBuffer;
		this.clearDepth = other.clearDepth;
		this.clearDepthBuffer = other.clearDepthBuffer;
		this.clearStencil = other.clearStencil;
		this.clearStencilBuffer = other.clearStencilBuffer;
		this.cullFaces = other.cullFaces;
		this.cullingMask = other.cullingMask;
		this.farClip = other.farClip;
		this.flipFaces = other.flipFaces;
		this.fov = other.fov;
		this.frustumCulling = other.frustumCulling;
		this.horizontalFov = other.horizontalFov;
		this.layers = other.layers;
		this.nearClip = other.nearClip;
		this.orthoHeight = other.orthoHeight;
		this.projection = other.projection;
		this.rect = other.rect;
		this.renderTarget = other.renderTarget;
		this.scissorRect = other.scissorRect;
		this.vrDisplay = other.vrDisplay;
		return this;
	}

	_updateViewProjMat() {
		if (this._projMatDirty || this._viewMatDirty || this._viewProjMatDirty) {
			this._viewProjMat.mul2(this.projectionMatrix, this.viewMatrix);

			this._viewProjMatDirty = false;
		}
	}

	worldToScreen(worldCoord, cw, ch, screenCoord = new Vec3()) {
		this._updateViewProjMat();

		this._viewProjMat.transformPoint(worldCoord, screenCoord);

		const vpm = this._viewProjMat.data;
		const w = worldCoord.x * vpm[3] + worldCoord.y * vpm[7] + worldCoord.z * vpm[11] + 1 * vpm[15];
		screenCoord.x = (screenCoord.x / w + 1) * 0.5 * cw;
		screenCoord.y = (1 - screenCoord.y / w) * 0.5 * ch;
		return screenCoord;
	}

	screenToWorld(x, y, z, cw, ch, worldCoord = new Vec3()) {
		const range = this._farClip - this._nearClip;

		_deviceCoord.set(x / cw, (ch - y) / ch, z / range);

		_deviceCoord.mulScalar(2);

		_deviceCoord.sub(Vec3.ONE);

		if (this._projection === PROJECTION_PERSPECTIVE) {
			Mat4._getPerspectiveHalfSize(_halfSize, this._fov, this._aspectRatio, this._nearClip, this._horizontalFov);

			_halfSize.x *= _deviceCoord.x;
			_halfSize.y *= _deviceCoord.y;

			const invView = this._node.getWorldTransform();

			_halfSize.z = -this._nearClip;
			invView.transformPoint(_halfSize, _point);

			const cameraPos = this._node.getPosition();

			worldCoord.sub2(_point, cameraPos);
			worldCoord.normalize();
			worldCoord.mulScalar(z);
			worldCoord.add(cameraPos);
		} else {
			this._updateViewProjMat();

			_invViewProjMat.copy(this._viewProjMat).invert();

			_invViewProjMat.transformPoint(_deviceCoord, worldCoord);
		}

		return worldCoord;
	}

	_evaluateProjectionMatrix() {
		if (this._projMatDirty) {
			if (this._projection === PROJECTION_PERSPECTIVE) {
				this._projMat.setPerspective(this._fov, this._aspectRatio, this._nearClip, this._farClip, this._horizontalFov);

				this._projMatSkybox.copy(this._projMat);
			} else {
				const y = this._orthoHeight;
				const x = y * this._aspectRatio;

				this._projMat.setOrtho(-x, x, -y, y, this._nearClip, this._farClip);

				this._projMatSkybox.setPerspective(this._fov, this._aspectRatio, this._nearClip, this._farClip);
			}

			this._projMatDirty = false;
		}
	}

	getProjectionMatrixSkybox() {
		this._evaluateProjectionMatrix();

		return this._projMatSkybox;
	}

	getScreenSize(sphere) {
		if (this._projection === PROJECTION_PERSPECTIVE) {
			const distance = this._node.getPosition().distance(sphere.center);

			if (distance < sphere.radius) {
				return 1;
			}

			const viewAngle = Math.asin(sphere.radius / distance);
			const sphereViewHeight = Math.tan(viewAngle);
			const screenViewHeight = Math.tan(this._fov / 2 * math.DEG_TO_RAD);
			return Math.min(sphereViewHeight / screenViewHeight, 1);
		}

		return math.clamp(sphere.radius / this._orthoHeight, 0, 1);
	}

}

const scaleCompensatePosTransform = new Mat4();
const scaleCompensatePos = new Vec3();
const scaleCompensateRot = new Quat();
const scaleCompensateRot2 = new Quat();
const scaleCompensateScale = new Vec3();
const scaleCompensateScaleForParent = new Vec3();
const tmpMat4 = new Mat4();
const tmpQuat = new Quat();
const position$1 = new Vec3();
const invParentWtm$1 = new Mat4();
const rotation = new Quat();
const invParentRot = new Quat();
const matrix = new Mat4();
const target = new Vec3();
const up = new Vec3();

class GraphNode extends EventHandler {
	constructor(name = 'Untitled') {
		super();
		this.name = name;
		this.tags = new Tags(this);
		this._labels = {};
		this.localPosition = new Vec3();
		this.localRotation = new Quat();
		this.localScale = new Vec3(1, 1, 1);
		this.localEulerAngles = new Vec3();
		this.position = new Vec3();
		this.rotation = new Quat();
		this.eulerAngles = new Vec3();
		this._scale = null;
		this.localTransform = new Mat4();
		this._dirtyLocal = false;
		this._aabbVer = 0;
		this._frozen = false;
		this.worldTransform = new Mat4();
		this._dirtyWorld = false;
		this.normalMatrix = new Mat3();
		this._dirtyNormal = true;
		this._right = null;
		this._up = null;
		this._forward = null;
		this._parent = null;
		this._children = [];
		this._graphDepth = 0;
		this._enabled = true;
		this._enabledInHierarchy = false;
		this.scaleCompensation = false;
	}

	get right() {
		if (!this._right) {
			this._right = new Vec3();
		}

		return this.getWorldTransform().getX(this._right).normalize();
	}

	get up() {
		if (!this._up) {
			this._up = new Vec3();
		}

		return this.getWorldTransform().getY(this._up).normalize();
	}

	get forward() {
		if (!this._forward) {
			this._forward = new Vec3();
		}

		return this.getWorldTransform().getZ(this._forward).normalize().mulScalar(-1);
	}

	set enabled(enabled) {
		if (this._enabled !== enabled) {
			var _this$_parent;

			this._enabled = enabled;

			if (enabled && (_this$_parent = this._parent) != null && _this$_parent.enabled || !enabled) {
				this._notifyHierarchyStateChanged(this, enabled);
			}
		}
	}

	get enabled() {
		return this._enabled && this._enabledInHierarchy;
	}

	get parent() {
		return this._parent;
	}

	get path() {
		let node = this._parent;

		if (!node) {
			return '';
		}

		let result = this.name;

		while (node && node._parent) {
			result = `${node.name}/${result}`;
			node = node._parent;
		}

		return result;
	}

	get root() {
		let result = this;

		while (result._parent) {
			result = result._parent;
		}

		return result;
	}

	get children() {
		return this._children;
	}

	get graphDepth() {
		return this._graphDepth;
	}

	_notifyHierarchyStateChanged(node, enabled) {
		node._onHierarchyStateChanged(enabled);

		const c = node._children;

		for (let i = 0, len = c.length; i < len; i++) {
			if (c[i]._enabled) this._notifyHierarchyStateChanged(c[i], enabled);
		}
	}

	_onHierarchyStateChanged(enabled) {
		this._enabledInHierarchy = enabled;
		if (enabled && !this._frozen) this._unfreezeParentToRoot();
	}

	_cloneInternal(clone) {
		clone.name = this.name;
		const tags = this.tags._list;
		clone.tags.clear();

		for (let i = 0; i < tags.length; i++) clone.tags.add(tags[i]);

		clone._labels = Object.assign({}, this._labels);
		clone.localPosition.copy(this.localPosition);
		clone.localRotation.copy(this.localRotation);
		clone.localScale.copy(this.localScale);
		clone.localEulerAngles.copy(this.localEulerAngles);
		clone.position.copy(this.position);
		clone.rotation.copy(this.rotation);
		clone.eulerAngles.copy(this.eulerAngles);
		clone.localTransform.copy(this.localTransform);
		clone._dirtyLocal = this._dirtyLocal;
		clone.worldTransform.copy(this.worldTransform);
		clone._dirtyWorld = this._dirtyWorld;
		clone._dirtyNormal = this._dirtyNormal;
		clone._aabbVer = this._aabbVer + 1;
		clone._enabled = this._enabled;
		clone.scaleCompensation = this.scaleCompensation;
		clone._enabledInHierarchy = false;
	}

	clone() {
		const clone = new GraphNode();

		this._cloneInternal(clone);

		return clone;
	}

	copy(source) {
		source._cloneInternal(this);

		return this;
	}

	find(attr, value) {
		let result,
				results = [];
		const len = this._children.length;

		if (attr instanceof Function) {
			const fn = attr;
			result = fn(this);
			if (result) results.push(this);

			for (let i = 0; i < len; i++) {
				const descendants = this._children[i].find(fn);

				if (descendants.length) results = results.concat(descendants);
			}
		} else {
			let testValue;

			if (this[attr]) {
				if (this[attr] instanceof Function) {
					testValue = this[attr]();
				} else {
					testValue = this[attr];
				}

				if (testValue === value) results.push(this);
			}

			for (let i = 0; i < len; ++i) {
				const descendants = this._children[i].find(attr, value);

				if (descendants.length) results = results.concat(descendants);
			}
		}

		return results;
	}

	findOne(attr, value) {
		const len = this._children.length;
		let result = null;

		if (attr instanceof Function) {
			const fn = attr;
			result = fn(this);
			if (result) return this;

			for (let i = 0; i < len; i++) {
				result = this._children[i].findOne(fn);
				if (result) return result;
			}
		} else {
			let testValue;

			if (this[attr]) {
				if (this[attr] instanceof Function) {
					testValue = this[attr]();
				} else {
					testValue = this[attr];
				}

				if (testValue === value) {
					return this;
				}
			}

			for (let i = 0; i < len; i++) {
				result = this._children[i].findOne(attr, value);
				if (result !== null) return result;
			}
		}

		return null;
	}

	findByTag() {
		const query = arguments;
		const results = [];

		const queryNode = (node, checkNode) => {
			if (checkNode && node.tags.has(...query)) {
				results.push(node);
			}

			for (let i = 0; i < node._children.length; i++) {
				queryNode(node._children[i], true);
			}
		};

		queryNode(this, false);
		return results;
	}

	findByName(name) {
		if (this.name === name) return this;

		for (let i = 0; i < this._children.length; i++) {
			const found = this._children[i].findByName(name);

			if (found !== null) return found;
		}

		return null;
	}

	findByPath(path) {
		const parts = Array.isArray(path) ? path : path.split('/');
		let result = this;

		for (let i = 0, imax = parts.length; i < imax; ++i) {
			result = result.children.find(c => c.name === parts[i]);

			if (!result) {
				return null;
			}
		}

		return result;
	}

	forEach(callback, thisArg) {
		callback.call(thisArg, this);
		const children = this._children;

		for (let i = 0; i < children.length; i++) {
			children[i].forEach(callback, thisArg);
		}
	}

	isDescendantOf(node) {
		let parent = this._parent;

		while (parent) {
			if (parent === node) return true;
			parent = parent._parent;
		}

		return false;
	}

	isAncestorOf(node) {
		return node.isDescendantOf(this);
	}

	getEulerAngles() {
		this.getWorldTransform().getEulerAngles(this.eulerAngles);
		return this.eulerAngles;
	}

	getLocalEulerAngles() {
		this.localRotation.getEulerAngles(this.localEulerAngles);
		return this.localEulerAngles;
	}

	getLocalPosition() {
		return this.localPosition;
	}

	getLocalRotation() {
		return this.localRotation;
	}

	getLocalScale() {
		return this.localScale;
	}

	getLocalTransform() {
		if (this._dirtyLocal) {
			this.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale);
			this._dirtyLocal = false;
		}

		return this.localTransform;
	}

	getPosition() {
		this.getWorldTransform().getTranslation(this.position);
		return this.position;
	}

	getRotation() {
		this.rotation.setFromMat4(this.getWorldTransform());
		return this.rotation;
	}

	getScale() {
		if (!this._scale) {
			this._scale = new Vec3();
		}

		return this.getWorldTransform().getScale(this._scale);
	}

	getWorldTransform() {
		if (!this._dirtyLocal && !this._dirtyWorld) return this.worldTransform;
		if (this._parent) this._parent.getWorldTransform();

		this._sync();

		return this.worldTransform;
	}

	reparent(parent, index) {
		const current = this._parent;
		if (current) current.removeChild(this);

		if (parent) {
			if (index >= 0) {
				parent.insertChild(this, index);
			} else {
				parent.addChild(this);
			}
		}
	}

	setLocalEulerAngles(x, y, z) {
		if (x instanceof Vec3) {
			this.localRotation.setFromEulerAngles(x.x, x.y, x.z);
		} else {
			this.localRotation.setFromEulerAngles(x, y, z);
		}

		if (!this._dirtyLocal) this._dirtifyLocal();
	}

	setLocalPosition(x, y, z) {
		if (x instanceof Vec3) {
			this.localPosition.copy(x);
		} else {
			this.localPosition.set(x, y, z);
		}

		if (!this._dirtyLocal) this._dirtifyLocal();
	}

	setLocalRotation(x, y, z, w) {
		if (x instanceof Quat) {
			this.localRotation.copy(x);
		} else {
			this.localRotation.set(x, y, z, w);
		}

		if (!this._dirtyLocal) this._dirtifyLocal();
	}

	setLocalScale(x, y, z) {
		if (x instanceof Vec3) {
			this.localScale.copy(x);
		} else {
			this.localScale.set(x, y, z);
		}

		if (!this._dirtyLocal) this._dirtifyLocal();
	}

	_dirtifyLocal() {
		if (!this._dirtyLocal) {
			this._dirtyLocal = true;
			if (!this._dirtyWorld) this._dirtifyWorld();
		}
	}

	_unfreezeParentToRoot() {
		let p = this._parent;

		while (p) {
			p._frozen = false;
			p = p._parent;
		}
	}

	_dirtifyWorld() {
		if (!this._dirtyWorld) this._unfreezeParentToRoot();

		this._dirtifyWorldInternal();
	}

	_dirtifyWorldInternal() {
		if (!this._dirtyWorld) {
			this._frozen = false;
			this._dirtyWorld = true;

			for (let i = 0; i < this._children.length; i++) {
				if (!this._children[i]._dirtyWorld) this._children[i]._dirtifyWorldInternal();
			}
		}

		this._dirtyNormal = true;
		this._aabbVer++;
	}

	setPosition(x, y, z) {
		if (x instanceof Vec3) {
			position$1.copy(x);
		} else {
			position$1.set(x, y, z);
		}

		if (this._parent === null) {
			this.localPosition.copy(position$1);
		} else {
			invParentWtm$1.copy(this._parent.getWorldTransform()).invert();
			invParentWtm$1.transformPoint(position$1, this.localPosition);
		}

		if (!this._dirtyLocal) this._dirtifyLocal();
	}

	setRotation(x, y, z, w) {
		if (x instanceof Quat) {
			rotation.copy(x);
		} else {
			rotation.set(x, y, z, w);
		}

		if (this._parent === null) {
			this.localRotation.copy(rotation);
		} else {
			const parentRot = this._parent.getRotation();

			invParentRot.copy(parentRot).invert();
			this.localRotation.copy(invParentRot).mul(rotation);
		}

		if (!this._dirtyLocal) this._dirtifyLocal();
	}

	setEulerAngles(x, y, z) {
		if (x instanceof Vec3) {
			this.localRotation.setFromEulerAngles(x.x, x.y, x.z);
		} else {
			this.localRotation.setFromEulerAngles(x, y, z);
		}

		if (this._parent !== null) {
			const parentRot = this._parent.getRotation();

			invParentRot.copy(parentRot).invert();
			this.localRotation.mul2(invParentRot, this.localRotation);
		}

		if (!this._dirtyLocal) this._dirtifyLocal();
	}

	addChild(node) {
		if (node._parent !== null) throw new Error("GraphNode is already parented");

		this._children.push(node);

		this._onInsertChild(node);
	}

	addChildAndSaveTransform(node) {
		const wPos = node.getPosition();
		const wRot = node.getRotation();
		const current = node._parent;
		if (current) current.removeChild(node);
		node.setPosition(tmpMat4.copy(this.worldTransform).invert().transformPoint(wPos));
		node.setRotation(tmpQuat.copy(this.getRotation()).invert().mul(wRot));

		this._children.push(node);

		this._onInsertChild(node);
	}

	insertChild(node, index) {
		if (node._parent !== null) throw new Error("GraphNode is already parented");

		this._children.splice(index, 0, node);

		this._onInsertChild(node);
	}

	_fireOnHierarchy(name, nameHierarchy, parent) {
		this.fire(name, parent);

		for (let i = 0; i < this._children.length; i++) {
			this._children[i]._fireOnHierarchy(nameHierarchy, nameHierarchy, parent);
		}
	}

	_onInsertChild(node) {
		node._parent = this;
		const enabledInHierarchy = node._enabled && this.enabled;

		if (node._enabledInHierarchy !== enabledInHierarchy) {
			node._enabledInHierarchy = enabledInHierarchy;

			node._notifyHierarchyStateChanged(node, enabledInHierarchy);
		}

		node._updateGraphDepth();

		node._dirtifyWorld();

		if (this._frozen) node._unfreezeParentToRoot();

		node._fireOnHierarchy('insert', 'inserthierarchy', this);

		if (this.fire) this.fire('childinsert', node);
	}

	_updateGraphDepth() {
		this._graphDepth = this._parent ? this._parent._graphDepth + 1 : 0;

		for (let i = 0, len = this._children.length; i < len; i++) {
			this._children[i]._updateGraphDepth();
		}
	}

	removeChild(child) {
		const index = this._children.indexOf(child);

		if (index === -1) {
			return;
		}

		this._children.splice(index, 1);

		child._parent = null;

		if (child._enabledInHierarchy) {
			child._notifyHierarchyStateChanged(child, false);
		}

		child._fireOnHierarchy('remove', 'removehierarchy', this);

		this.fire('childremove', child);
	}

	_sync() {
		if (this._dirtyLocal) {
			this.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale);
			this._dirtyLocal = false;
		}

		if (this._dirtyWorld) {
			if (this._parent === null) {
				this.worldTransform.copy(this.localTransform);
			} else {
				if (this.scaleCompensation) {
					let parentWorldScale;
					const parent = this._parent;
					let scale = this.localScale;
					let parentToUseScaleFrom = parent;

					if (parentToUseScaleFrom) {
						while (parentToUseScaleFrom && parentToUseScaleFrom.scaleCompensation) {
							parentToUseScaleFrom = parentToUseScaleFrom._parent;
						}

						if (parentToUseScaleFrom) {
							parentToUseScaleFrom = parentToUseScaleFrom._parent;

							if (parentToUseScaleFrom) {
								parentWorldScale = parentToUseScaleFrom.worldTransform.getScale();
								scaleCompensateScale.mul2(parentWorldScale, this.localScale);
								scale = scaleCompensateScale;
							}
						}
					}

					scaleCompensateRot2.setFromMat4(parent.worldTransform);
					scaleCompensateRot.mul2(scaleCompensateRot2, this.localRotation);
					let tmatrix = parent.worldTransform;

					if (parent.scaleCompensation) {
						scaleCompensateScaleForParent.mul2(parentWorldScale, parent.getLocalScale());
						scaleCompensatePosTransform.setTRS(parent.worldTransform.getTranslation(scaleCompensatePos), scaleCompensateRot2, scaleCompensateScaleForParent);
						tmatrix = scaleCompensatePosTransform;
					}

					tmatrix.transformPoint(this.localPosition, scaleCompensatePos);
					this.worldTransform.setTRS(scaleCompensatePos, scaleCompensateRot, scale);
				} else {
					this.worldTransform.mulAffine2(this._parent.worldTransform, this.localTransform);
				}
			}

			this._dirtyWorld = false;
		}
	}

	syncHierarchy() {
		if (!this._enabled) return;
		if (this._frozen) return;
		this._frozen = true;

		if (this._dirtyLocal || this._dirtyWorld) {
			this._sync();
		}

		const children = this._children;

		for (let i = 0, len = children.length; i < len; i++) {
			children[i].syncHierarchy();
		}
	}

	lookAt(x, y, z, ux = 0, uy = 1, uz = 0) {
		if (x instanceof Vec3) {
			target.copy(x);

			if (y instanceof Vec3) {
				up.copy(y);
			} else {
				up.copy(Vec3.UP);
			}
		} else if (z === undefined) {
			return;
		} else {
			target.set(x, y, z);
			up.set(ux, uy, uz);
		}

		matrix.setLookAt(this.getPosition(), target, up);
		rotation.setFromMat4(matrix);
		this.setRotation(rotation);
	}

	translate(x, y, z) {
		if (x instanceof Vec3) {
			position$1.copy(x);
		} else {
			position$1.set(x, y, z);
		}

		position$1.add(this.getPosition());
		this.setPosition(position$1);
	}

	translateLocal(x, y, z) {
		if (x instanceof Vec3) {
			position$1.copy(x);
		} else {
			position$1.set(x, y, z);
		}

		this.localRotation.transformVector(position$1, position$1);
		this.localPosition.add(position$1);
		if (!this._dirtyLocal) this._dirtifyLocal();
	}

	rotate(x, y, z) {
		if (x instanceof Vec3) {
			rotation.setFromEulerAngles(x.x, x.y, x.z);
		} else {
			rotation.setFromEulerAngles(x, y, z);
		}

		if (this._parent === null) {
			this.localRotation.mul2(rotation, this.localRotation);
		} else {
			const rot = this.getRotation();

			const parentRot = this._parent.getRotation();

			invParentRot.copy(parentRot).invert();
			rotation.mul2(invParentRot, rotation);
			this.localRotation.mul2(rotation, rot);
		}

		if (!this._dirtyLocal) this._dirtifyLocal();
	}

	rotateLocal(x, y, z) {
		if (x instanceof Vec3) {
			rotation.setFromEulerAngles(x.x, x.y, x.z);
		} else {
			rotation.setFromEulerAngles(x, y, z);
		}

		this.localRotation.mul(rotation);
		if (!this._dirtyLocal) this._dirtifyLocal();
	}

}

const _viewMat = new Mat4();

const _viewProjMat = new Mat4();

const _viewportMatrix = new Mat4();

class LightCamera {
	static create(name, lightType, face) {
		const camera = new Camera();
		camera.node = new GraphNode(name);
		camera.aspectRatio = 1;
		camera.aspectRatioMode = ASPECT_MANUAL;
		camera._scissorRectClear = true;

		switch (lightType) {
			case LIGHTTYPE_OMNI:
				camera.node.setRotation(LightCamera.pointLightRotations[face]);
				camera.fov = 90;
				camera.projection = PROJECTION_PERSPECTIVE;
				break;

			case LIGHTTYPE_SPOT:
				camera.projection = PROJECTION_PERSPECTIVE;
				break;

			case LIGHTTYPE_DIRECTIONAL:
				camera.projection = PROJECTION_ORTHOGRAPHIC;
				break;
		}

		return camera;
	}

	static evalSpotCookieMatrix(light) {
		let cookieCamera = LightCamera._spotCookieCamera;

		if (!cookieCamera) {
			cookieCamera = LightCamera.create("SpotCookieCamera", LIGHTTYPE_SPOT);
			LightCamera._spotCookieCamera = cookieCamera;
		}

		cookieCamera.fov = light._outerConeAngle * 2;
		const cookieNode = cookieCamera._node;
		cookieNode.setPosition(light._node.getPosition());
		cookieNode.setRotation(light._node.getRotation());
		cookieNode.rotateLocal(-90, 0, 0);

		_viewMat.setTRS(cookieNode.getPosition(), cookieNode.getRotation(), Vec3.ONE).invert();

		_viewProjMat.mul2(cookieCamera.projectionMatrix, _viewMat);

		const cookieMatrix = light.cookieMatrix;
		const rectViewport = light.atlasViewport;

		_viewportMatrix.setViewport(rectViewport.x, rectViewport.y, rectViewport.z, rectViewport.w);

		cookieMatrix.mul2(_viewportMatrix, _viewProjMat);
		return cookieMatrix;
	}

}

LightCamera.pointLightRotations = [new Quat().setFromEulerAngles(0, 90, 180), new Quat().setFromEulerAngles(0, -90, 180), new Quat().setFromEulerAngles(90, 0, 0), new Quat().setFromEulerAngles(-90, 0, 0), new Quat().setFromEulerAngles(0, 180, 180), new Quat().setFromEulerAngles(0, 0, 180)];
LightCamera._spotCookieCamera = null;

const epsilon$1 = 0.000001;
const tempVec3$1 = new Vec3();
const tempAreaLightSizes = new Float32Array(6);
const areaHalfAxisWidth = new Vec3(-0.5, 0, 0);
const areaHalfAxisHeight = new Vec3(0, 0, 0.5);
const TextureIndex8 = {
	FLAGS: 0,
	COLOR_A: 1,
	COLOR_B: 2,
	SPOT_ANGLES: 3,
	SHADOW_BIAS: 4,
	COOKIE_A: 5,
	COOKIE_B: 6,
	COUNT_ALWAYS: 7,
	POSITION_X: 7,
	POSITION_Y: 8,
	POSITION_Z: 9,
	RANGE: 10,
	SPOT_DIRECTION_X: 11,
	SPOT_DIRECTION_Y: 12,
	SPOT_DIRECTION_Z: 13,
	PROJ_MAT_00: 14,
	ATLAS_VIEWPORT_A: 14,
	PROJ_MAT_01: 15,
	ATLAS_VIEWPORT_B: 15,
	PROJ_MAT_02: 16,
	PROJ_MAT_03: 17,
	PROJ_MAT_10: 18,
	PROJ_MAT_11: 19,
	PROJ_MAT_12: 20,
	PROJ_MAT_13: 21,
	PROJ_MAT_20: 22,
	PROJ_MAT_21: 23,
	PROJ_MAT_22: 24,
	PROJ_MAT_23: 25,
	PROJ_MAT_30: 26,
	PROJ_MAT_31: 27,
	PROJ_MAT_32: 28,
	PROJ_MAT_33: 29,
	AREA_DATA_WIDTH_X: 30,
	AREA_DATA_WIDTH_Y: 31,
	AREA_DATA_WIDTH_Z: 32,
	AREA_DATA_HEIGHT_X: 33,
	AREA_DATA_HEIGHT_Y: 34,
	AREA_DATA_HEIGHT_Z: 35,
	COUNT: 36
};
const TextureIndexFloat = {
	POSITION_RANGE: 0,
	SPOT_DIRECTION: 1,
	PROJ_MAT_0: 2,
	ATLAS_VIEWPORT: 2,
	PROJ_MAT_1: 3,
	PROJ_MAT_2: 4,
	PROJ_MAT_3: 5,
	AREA_DATA_WIDTH: 6,
	AREA_DATA_HEIGHT: 7,
	COUNT: 8
};

class LightsBuffer {
	static initShaderDefines() {
		const clusterTextureFormat = LightsBuffer.lightTextureFormat === LightsBuffer.FORMAT_FLOAT ? "FLOAT" : "8BIT";
		LightsBuffer.shaderDefines = `
						\n#define CLUSTER_TEXTURE_${clusterTextureFormat}
						${LightsBuffer.buildShaderDefines(TextureIndex8, "CLUSTER_TEXTURE_8_")}
						${LightsBuffer.buildShaderDefines(TextureIndexFloat, "CLUSTER_TEXTURE_F_")}
				`;
	}

	static buildShaderDefines(object, prefix) {
		let str = "";
		Object.keys(object).forEach(key => {
			str += `\n#define ${prefix}${key} ${object[key]}.5`;
		});
		return str;
	}

	static init(device) {
		LightsBuffer.lightTextureFormat = device.extTextureFloat && device.maxTextures > 8 ? LightsBuffer.FORMAT_FLOAT : LightsBuffer.FORMAT_8BIT;
		LightsBuffer.initShaderDefines();
	}

	static createTexture(device, width, height, format, name) {
		const tex = new Texture(device, {
			name: name,
			width: width,
			height: height,
			mipmaps: false,
			format: format,
			addressU: ADDRESS_CLAMP_TO_EDGE,
			addressV: ADDRESS_CLAMP_TO_EDGE,
			type: TEXTURETYPE_DEFAULT,
			magFilter: FILTER_NEAREST,
			minFilter: FILTER_NEAREST,
			anisotropy: 1
		});
		return tex;
	}

	constructor(device) {
		this.device = device;
		this.cookiesEnabled = false;
		this.shadowsEnabled = false;
		this.areaLightsEnabled = false;
		this.maxLights = 255;
		let pixelsPerLight8 = TextureIndex8.COUNT_ALWAYS;
		let pixelsPerLightFloat = 0;

		if (LightsBuffer.lightTextureFormat === LightsBuffer.FORMAT_FLOAT) {
			pixelsPerLightFloat = TextureIndexFloat.COUNT;
		} else {
			pixelsPerLight8 = TextureIndex8.COUNT;
		}

		this.lights8 = new Uint8ClampedArray(4 * pixelsPerLight8 * this.maxLights);
		this.lightsTexture8 = LightsBuffer.createTexture(this.device, pixelsPerLight8, this.maxLights, PIXELFORMAT_R8_G8_B8_A8, "LightsTexture8");
		this._lightsTexture8Id = this.device.scope.resolve("lightsTexture8");

		if (pixelsPerLightFloat) {
			this.lightsFloat = new Float32Array(4 * pixelsPerLightFloat * this.maxLights);
			this.lightsTextureFloat = LightsBuffer.createTexture(this.device, pixelsPerLightFloat, this.maxLights, PIXELFORMAT_RGBA32F, "LightsTextureFloat");
			this._lightsTextureFloatId = this.device.scope.resolve("lightsTextureFloat");
		} else {
			this.lightsFloat = null;
			this.lightsTextureFloat = null;
			this._lightsTextureFloatId = undefined;
		}

		this._lightsTextureInvSizeId = this.device.scope.resolve("lightsTextureInvSize");
		this._lightsTextureInvSizeData = new Float32Array(4);
		this._lightsTextureInvSizeData[0] = pixelsPerLightFloat ? 1.0 / this.lightsTextureFloat.width : 0;
		this._lightsTextureInvSizeData[1] = pixelsPerLightFloat ? 1.0 / this.lightsTextureFloat.height : 0;
		this._lightsTextureInvSizeData[2] = 1.0 / this.lightsTexture8.width;
		this._lightsTextureInvSizeData[3] = 1.0 / this.lightsTexture8.height;
		this.invMaxColorValue = 0;
		this.invMaxAttenuation = 0;
		this.boundsMin = new Vec3();
		this.boundsDelta = new Vec3();
	}

	destroy() {
		if (this.lightsTexture8) {
			this.lightsTexture8.destroy();
			this.lightsTexture8 = null;
		}

		if (this.lightsTextureFloat) {
			this.lightsTextureFloat.destroy();
			this.lightsTextureFloat = null;
		}
	}

	setCompressionRanges(maxAttenuation, maxColorValue) {
		this.invMaxColorValue = 1 / maxColorValue;
		this.invMaxAttenuation = 1 / maxAttenuation;
	}

	setBounds(min, delta) {
		this.boundsMin.copy(min);
		this.boundsDelta.copy(delta);
	}

	uploadTextures() {
		if (this.lightsTextureFloat) {
			this.lightsTextureFloat.lock().set(this.lightsFloat);
			this.lightsTextureFloat.unlock();
		}

		this.lightsTexture8.lock().set(this.lights8);
		this.lightsTexture8.unlock();
	}

	updateUniforms() {
		this._lightsTexture8Id.setValue(this.lightsTexture8);

		if (LightsBuffer.lightTextureFormat === LightsBuffer.FORMAT_FLOAT) {
			this._lightsTextureFloatId.setValue(this.lightsTextureFloat);
		}

		this._lightsTextureInvSizeId.setValue(this._lightsTextureInvSizeData);
	}

	getSpotDirection(direction, spot) {
		const mat = spot._node.getWorldTransform();

		mat.getY(direction).mulScalar(-1);
		direction.normalize();
	}

	getLightAreaSizes(light) {
		const mat = light._node.getWorldTransform();

		mat.transformVector(areaHalfAxisWidth, tempVec3$1);
		tempAreaLightSizes[0] = tempVec3$1.x;
		tempAreaLightSizes[1] = tempVec3$1.y;
		tempAreaLightSizes[2] = tempVec3$1.z;
		mat.transformVector(areaHalfAxisHeight, tempVec3$1);
		tempAreaLightSizes[3] = tempVec3$1.x;
		tempAreaLightSizes[4] = tempVec3$1.y;
		tempAreaLightSizes[5] = tempVec3$1.z;
		return tempAreaLightSizes;
	}

	addLightDataFlags(data8, index, light, isSpot, castShadows) {
		data8[index + 0] = isSpot ? 255 : 0;
		data8[index + 1] = light._shape * 64;
		data8[index + 2] = light._falloffMode * 255;
		data8[index + 3] = castShadows ? 255 : 0;
	}

	addLightDataColor(data8, index, light, gammaCorrection, isCookie) {
		const invMaxColorValue = this.invMaxColorValue;
		const color = gammaCorrection ? light._linearFinalColor : light._finalColor;
		FloatPacking.float2Bytes(color[0] * invMaxColorValue, data8, index + 0, 2);
		FloatPacking.float2Bytes(color[1] * invMaxColorValue, data8, index + 2, 2);
		FloatPacking.float2Bytes(color[2] * invMaxColorValue, data8, index + 4, 2);
		data8[index + 6] = isCookie ? 255 : 0;
		const isDynamic = !!(light.mask & MASK_AFFECT_DYNAMIC);
		const isLightmapped = !!(light.mask & MASK_AFFECT_LIGHTMAPPED);
		data8[index + 7] = isDynamic && isLightmapped ? 127 : isLightmapped ? 255 : 0;
	}

	addLightDataSpotAngles(data8, index, light) {
		FloatPacking.float2Bytes(light._innerConeAngleCos * (0.5 - epsilon$1) + 0.5, data8, index + 0, 2);
		FloatPacking.float2Bytes(light._outerConeAngleCos * (0.5 - epsilon$1) + 0.5, data8, index + 2, 2);
	}

	addLightDataShadowBias(data8, index, light) {
		const lightRenderData = light.getRenderData(null, 0);

		const biases = light._getUniformBiasValues(lightRenderData);

		FloatPacking.float2BytesRange(biases.bias, data8, index, -1, 20, 2);
		FloatPacking.float2Bytes(biases.normalBias, data8, index + 2, 2);
	}

	addLightDataPositionRange(data8, index, light, pos) {
		const normPos = tempVec3$1.sub2(pos, this.boundsMin).div(this.boundsDelta);
		FloatPacking.float2Bytes(normPos.x, data8, index + 0, 4);
		FloatPacking.float2Bytes(normPos.y, data8, index + 4, 4);
		FloatPacking.float2Bytes(normPos.z, data8, index + 8, 4);
		FloatPacking.float2Bytes(light.attenuationEnd * this.invMaxAttenuation, data8, index + 12, 4);
	}

	addLightDataSpotDirection(data8, index, light) {
		this.getSpotDirection(tempVec3$1, light);
		FloatPacking.float2Bytes(tempVec3$1.x * (0.5 - epsilon$1) + 0.5, data8, index + 0, 4);
		FloatPacking.float2Bytes(tempVec3$1.y * (0.5 - epsilon$1) + 0.5, data8, index + 4, 4);
		FloatPacking.float2Bytes(tempVec3$1.z * (0.5 - epsilon$1) + 0.5, data8, index + 8, 4);
	}

	addLightDataLightProjMatrix(data8, index, lightProjectionMatrix) {
		const matData = lightProjectionMatrix.data;

		for (let m = 0; m < 12; m++) FloatPacking.float2BytesRange(matData[m], data8, index + 4 * m, -2, 2, 4);

		for (let m = 12; m < 16; m++) {
			FloatPacking.float2MantissaExponent(matData[m], data8, index + 4 * m, 4);
		}
	}

	addLightDataCookies(data8, index, light) {
		const isRgb = light._cookieChannel === "rgb";
		data8[index + 0] = Math.floor(light.cookieIntensity * 255);
		data8[index + 1] = isRgb ? 255 : 0;

		if (!isRgb) {
			const channel = light._cookieChannel;
			data8[index + 4] = channel === "rrr" ? 255 : 0;
			data8[index + 5] = channel === "ggg" ? 255 : 0;
			data8[index + 6] = channel === "bbb" ? 255 : 0;
			data8[index + 7] = channel === "aaa" ? 255 : 0;
		}
	}

	addLightAtlasViewport(data8, index, atlasViewport) {
		FloatPacking.float2Bytes(atlasViewport.x, data8, index + 0, 2);
		FloatPacking.float2Bytes(atlasViewport.y, data8, index + 2, 2);
		FloatPacking.float2Bytes(atlasViewport.z / 3, data8, index + 4, 2);
	}

	addLightAreaSizes(data8, index, light) {
		const areaSizes = this.getLightAreaSizes(light);

		for (let i = 0; i < 6; i++) {
			FloatPacking.float2MantissaExponent(areaSizes[i], data8, index + 4 * i, 4);
		}
	}

	addLightData(light, lightIndex, gammaCorrection) {
		const isSpot = light._type === LIGHTTYPE_SPOT;
		const hasAtlasViewport = light.atlasViewportAllocated;
		const isCookie = this.cookiesEnabled && !!light._cookie && hasAtlasViewport;
		const isArea = this.areaLightsEnabled && light.shape !== LIGHTSHAPE_PUNCTUAL;
		const castShadows = this.shadowsEnabled && light.castShadows && hasAtlasViewport;

		const pos = light._node.getPosition();

		let lightProjectionMatrix = null;
		let atlasViewport = null;

		if (isSpot) {
			if (castShadows) {
				const lightRenderData = light.getRenderData(null, 0);
				lightProjectionMatrix = lightRenderData.shadowMatrix;
			} else if (isCookie) {
				lightProjectionMatrix = LightCamera.evalSpotCookieMatrix(light);
			}
		} else {
			if (castShadows || isCookie) {
				atlasViewport = light.atlasViewport;
			}
		}

		const data8 = this.lights8;
		const data8Start = lightIndex * this.lightsTexture8.width * 4;
		this.addLightDataFlags(data8, data8Start + 4 * TextureIndex8.FLAGS, light, isSpot, castShadows);
		this.addLightDataColor(data8, data8Start + 4 * TextureIndex8.COLOR_A, light, gammaCorrection, isCookie);

		if (isSpot) {
			this.addLightDataSpotAngles(data8, data8Start + 4 * TextureIndex8.SPOT_ANGLES, light);
		}

		if (light.castShadows) {
			this.addLightDataShadowBias(data8, data8Start + 4 * TextureIndex8.SHADOW_BIAS, light);
		}

		if (isCookie) {
			this.addLightDataCookies(data8, data8Start + 4 * TextureIndex8.COOKIE_A, light);
		}

		if (LightsBuffer.lightTextureFormat === LightsBuffer.FORMAT_FLOAT) {
			const dataFloat = this.lightsFloat;
			const dataFloatStart = lightIndex * this.lightsTextureFloat.width * 4;
			dataFloat[dataFloatStart + 4 * TextureIndexFloat.POSITION_RANGE + 0] = pos.x;
			dataFloat[dataFloatStart + 4 * TextureIndexFloat.POSITION_RANGE + 1] = pos.y;
			dataFloat[dataFloatStart + 4 * TextureIndexFloat.POSITION_RANGE + 2] = pos.z;
			dataFloat[dataFloatStart + 4 * TextureIndexFloat.POSITION_RANGE + 3] = light.attenuationEnd;

			if (isSpot) {
				this.getSpotDirection(tempVec3$1, light);
				dataFloat[dataFloatStart + 4 * TextureIndexFloat.SPOT_DIRECTION + 0] = tempVec3$1.x;
				dataFloat[dataFloatStart + 4 * TextureIndexFloat.SPOT_DIRECTION + 1] = tempVec3$1.y;
				dataFloat[dataFloatStart + 4 * TextureIndexFloat.SPOT_DIRECTION + 2] = tempVec3$1.z;
			}

			if (lightProjectionMatrix) {
				const matData = lightProjectionMatrix.data;

				for (let m = 0; m < 16; m++) dataFloat[dataFloatStart + 4 * TextureIndexFloat.PROJ_MAT_0 + m] = matData[m];
			}

			if (atlasViewport) {
				dataFloat[dataFloatStart + 4 * TextureIndexFloat.ATLAS_VIEWPORT + 0] = atlasViewport.x;
				dataFloat[dataFloatStart + 4 * TextureIndexFloat.ATLAS_VIEWPORT + 1] = atlasViewport.y;
				dataFloat[dataFloatStart + 4 * TextureIndexFloat.ATLAS_VIEWPORT + 2] = atlasViewport.z / 3;
			}

			if (isArea) {
				const areaSizes = this.getLightAreaSizes(light);
				dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_WIDTH + 0] = areaSizes[0];
				dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_WIDTH + 1] = areaSizes[1];
				dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_WIDTH + 2] = areaSizes[2];
				dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_HEIGHT + 0] = areaSizes[3];
				dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_HEIGHT + 1] = areaSizes[4];
				dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_HEIGHT + 2] = areaSizes[5];
			}
		} else {
			this.addLightDataPositionRange(data8, data8Start + 4 * TextureIndex8.POSITION_X, light, pos);

			if (isSpot) {
				this.addLightDataSpotDirection(data8, data8Start + 4 * TextureIndex8.SPOT_DIRECTION_X, light);
			}

			if (lightProjectionMatrix) {
				this.addLightDataLightProjMatrix(data8, data8Start + 4 * TextureIndex8.PROJ_MAT_00, lightProjectionMatrix);
			}

			if (atlasViewport) {
				this.addLightAtlasViewport(data8, data8Start + 4 * TextureIndex8.ATLAS_VIEWPORT_A, atlasViewport);
			}

			if (isArea) {
				this.addLightAreaSizes(data8, data8Start + 4 * TextureIndex8.AREA_DATA_WIDTH_X, light);
			}
		}
	}

}

LightsBuffer.FORMAT_FLOAT = 0;
LightsBuffer.FORMAT_8BIT = 1;
LightsBuffer.lightTextureFormat = LightsBuffer.FORMAT_8BIT;
LightsBuffer.shaderDefines = "";

const _matTex2D = [];
const decodeTable = {
	'rgbm': 'decodeRGBM',
	'rgbe': 'decodeRGBE',
	'linear': 'decodeLinear'
};
const standard = {
	optionsContext: {},
	optionsContextMin: {},
	generateKey: function (options) {
		const buildPropertiesList = function buildPropertiesList(options) {
			const props = [];

			for (const prop in options) {
				if (options.hasOwnProperty(prop) && prop !== "chunks" && prop !== "lights") props.push(prop);
			}

			return props.sort();
		};

		let props;

		if (options === this.optionsContextMin) {
			if (!this.propsMin) this.propsMin = buildPropertiesList(options);
			props = this.propsMin;
		} else if (options === this.optionsContext) {
			if (!this.props) this.props = buildPropertiesList(options);
			props = this.props;
		} else {
			props = buildPropertiesList(options);
		}

		let key = "standard";

		for (let i = 0; i < props.length; i++) {
			if (options[props[i]]) key += props[i] + options[props[i]];
		}

		if (options.chunks) {
			const chunks = [];

			for (const p in options.chunks) {
				if (options.chunks.hasOwnProperty(p)) {
					chunks.push(p + options.chunks[p]);
				}
			}

			chunks.sort();
			key += chunks;
		}

		if (options.lights) {
			const isClustered = options.clusteredLightingEnabled;

			for (let i = 0; i < options.lights.length; i++) {
				const light = options.lights[i];

				if (!isClustered || light._type === LIGHTTYPE_DIRECTIONAL) {
					key += light.key;
				}
			}
		}

		return hashCode(key);
	},
	_correctChannel: function (p, chan) {
		if (_matTex2D[p] > 0) {
			if (_matTex2D[p] < chan.length) {
				return chan.substring(0, _matTex2D[p]);
			} else if (_matTex2D[p] > chan.length) {
				let str = chan;
				const chr = str.charAt(str.length - 1);
				const addLen = _matTex2D[p] - str.length;

				for (let i = 0; i < addLen; i++) str += chr;

				return str;
			}

			return chan;
		}
	},
	_setMapTransform: function (codes, name, id, uv) {
		const varName = `texture_${name}MapTransform`;
		const checkId = id + uv * 100;
		codes[0] += `uniform vec3 ${varName}0;\n`;
		codes[0] += `uniform vec3 ${varName}1;\n`;

		if (!codes[3][checkId]) {
			codes[1] += `varying vec2 vUV${uv}_${id};\n`;
			codes[2] += `	 vUV${uv}_${id} = vec2(dot(vec3(uv${uv}, 1), ${varName}0), dot(vec3(uv${uv}, 1), ${varName}1));\n`;
			codes[3][checkId] = true;
		}

		return codes;
	},
	_getUvSourceExpression: function (transformPropName, uVPropName, options) {
		const transformId = options[transformPropName];
		const uvChannel = options[uVPropName];
		const isMainPass = options.pass === SHADER_FORWARD || options.pass === SHADER_FORWARDHDR;
		let expression;

		if (isMainPass && options.nineSlicedMode === SPRITE_RENDERMODE_SLICED) {
			expression = "nineSlicedUv";
		} else if (isMainPass && options.nineSlicedMode === SPRITE_RENDERMODE_TILED) {
			expression = "nineSlicedUv, -1000.0";
		} else {
			if (transformId === 0) {
				expression = "vUv" + uvChannel;
			} else {
				expression = "vUV" + uvChannel + "_" + transformId;
			}

			if (options.heightMap && transformPropName !== "heightMapTransform") {
				expression += " + dUvOffset";
			}
		}

		return expression;
	},
	_addMapDef: function (name, enabled) {
		let s = "\n#undef " + name + "\n";
		if (enabled) s += " #define " + name + "\n";
		return s;
	},
	_addMapDefs: function (float, color, vertex, map) {
		let s = "";
		s += this._addMapDef("MAPFLOAT", float);
		s += this._addMapDef("MAPCOLOR", color);
		s += this._addMapDef("MAPVERTEX", vertex);
		s += this._addMapDef("MAPTEXTURE", map);
		return s;
	},
	_addMap: function (propName, chunkName, options, chunks, samplerFormat) {
		const mapPropName = propName + "Map";
		const uVPropName = mapPropName + "Uv";
		const transformPropName = mapPropName + "Transform";
		const channelPropName = mapPropName + "Channel";
		const vertexColorChannelPropName = propName + "VertexColorChannel";
		const tintPropName = propName + "Tint";
		const vertexColorPropName = propName + "VertexColor";
		const detailModePropName = propName + "Mode";
		const tintOption = options[tintPropName];
		const vertexColorOption = options[vertexColorPropName];
		const textureOption = options[mapPropName];
		const detailModeOption = options[detailModePropName];
		let subCode = chunks[chunkName];

		if (textureOption) {
			const uv = this._getUvSourceExpression(transformPropName, uVPropName, options);

			subCode = subCode.replace(/\$UV/g, uv).replace(/\$CH/g, options[channelPropName]);

			if (samplerFormat !== undefined) {
				const fmt = samplerFormat === 0 ? "texture2DSRGB" : samplerFormat === 1 ? "texture2DRGBM" : "texture2D";
				subCode = subCode.replace(/\$texture2DSAMPLE/g, fmt);
			}
		}

		if (vertexColorOption) {
			subCode = subCode.replace(/\$VC/g, options[vertexColorChannelPropName]);
		}

		if (detailModeOption) {
			subCode = subCode.replace(/\$DETAILMODE/g, detailModeOption);
		}

		const isFloatTint = !!(tintOption & 1);
		const isVecTint = !!(tintOption & 2);
		subCode = this._addMapDefs(isFloatTint, isVecTint, vertexColorOption, textureOption) + subCode;
		return subCode.replace(/\$/g, "");
	},
	_directionalShadowMapProjection: function (light, shadowCoordArgs, shadowParamArg, lightIndex, coordsFunctionName) {
		let code = "";

		if (light.numCascades > 1) {
			code += `getShadowCascadeMatrix(light${lightIndex}_shadowMatrixPalette, light${lightIndex}_shadowCascadeDistances, light${lightIndex}_shadowCascadeCount);\n`;
			shadowCoordArgs = `(cascadeShadowMat, ${shadowParamArg});\n`;
		}

		code += coordsFunctionName + shadowCoordArgs;
		code += `fadeShadow(light${lightIndex}_shadowCascadeDistances);\n`;
		return code;
	},
	_nonPointShadowMapProjection: function (device, light, shadowMatArg, shadowParamArg, lightIndex) {
		const shadowCoordArgs = `(${shadowMatArg}, ${shadowParamArg});\n`;

		if (!light._normalOffsetBias || light._isVsm) {
			if (light._type === LIGHTTYPE_SPOT) {
				if (light._isPcf && (device.webgl2 || device.extStandardDerivatives)) {
					return "			 getShadowCoordPerspZbuffer" + shadowCoordArgs;
				}

				return "			 getShadowCoordPersp" + shadowCoordArgs;
			}

			return this._directionalShadowMapProjection(light, shadowCoordArgs, shadowParamArg, lightIndex, "getShadowCoordOrtho");
		}

		if (light._type === LIGHTTYPE_SPOT) {
			if (light._isPcf && (device.webgl2 || device.extStandardDerivatives)) {
				return "			 getShadowCoordPerspZbufferNormalOffset" + shadowCoordArgs;
			}

			return "			 getShadowCoordPerspNormalOffset" + shadowCoordArgs;
		}

		return this._directionalShadowMapProjection(light, shadowCoordArgs, shadowParamArg, lightIndex, "getShadowCoordOrthoNormalOffset");
	},
	_addVaryingIfNeeded: function (code, type, name) {
		return code.indexOf(name) >= 0 ? "varying " + type + " " + name + ";\n" : "";
	},
	_getLightSourceShapeString: function (shape) {
		switch (shape) {
			case LIGHTSHAPE_RECT:
				return 'Rect';

			case LIGHTSHAPE_DISK:
				return 'Disk';

			case LIGHTSHAPE_SPHERE:
				return 'Sphere';

			default:
				return '';
		}
	},
	_getPassDefineString: function (pass) {
		if (pass === SHADER_PICK) {
			return '#define PICK_PASS\n';
		} else if (pass === SHADER_DEPTH) {
			return '#define DEPTH_PASS\n';
		} else if (pass >= SHADER_SHADOW && pass <= 17) {
			return '#define SHADOW_PASS\n';
		}

		return '';
	},
	_vsAddTransformCode: function (code, device, chunks, options) {
		code += chunks.transformVS;
		return code;
	},
	_vsAddBaseCode: function (code, device, chunks, options) {
		code += chunks.baseVS;

		if (options.nineSlicedMode === SPRITE_RENDERMODE_SLICED || options.nineSlicedMode === SPRITE_RENDERMODE_TILED) {
			code += chunks.baseNineSlicedVS;
		}

		return code;
	},
	_fsAddBaseCode: function (code, device, chunks, options) {
		code += chunks.basePS;

		if (options.nineSlicedMode === SPRITE_RENDERMODE_SLICED) {
			code += chunks.baseNineSlicedPS;
		} else if (options.nineSlicedMode === SPRITE_RENDERMODE_TILED) {
			code += chunks.baseNineSlicedTiledPS;
		}

		return code;
	},
	_decodeFunc: function (textureFormat) {
		return decodeTable[textureFormat] || 'decodeGamma';
	},
	_fsAddStartCode: function (code, device, chunks, options) {
		code += chunks.startPS;

		if (options.nineSlicedMode === SPRITE_RENDERMODE_SLICED) {
			code += chunks.startNineSlicedPS;
		} else if (options.nineSlicedMode === SPRITE_RENDERMODE_TILED) {
			code += chunks.startNineSlicedTiledPS;
		}

		return code;
	},
	_buildShadowPassFragmentCode: function (code, device, chunks, options, varyings) {
		const smode = options.pass - SHADER_SHADOW;
		const numShadowModes = SHADOW_COUNT;
		const lightType = Math.floor(smode / numShadowModes);
		const shadowType = smode - lightType * numShadowModes;

		if (device.extStandardDerivatives && !device.webgl2) {
			code += 'uniform vec2 polygonOffset;\n';
		}

		if (shadowType === SHADOW_VSM32) {
			if (device.textureFloatHighPrecision) {
				code += '#define VSM_EXPONENT 15.0\n\n';
			} else {
				code += '#define VSM_EXPONENT 5.54\n\n';
			}
		} else if (shadowType === SHADOW_VSM16) {
			code += '#define VSM_EXPONENT 5.54\n\n';
		}

		if (lightType !== LIGHTTYPE_DIRECTIONAL) {
			code += 'uniform vec3 view_position;\n';
			code += 'uniform float light_radius;\n';
		}

		code += varyings;

		if (options.alphaTest) {
			code += "float dAlpha;\n";
			code += this._addMap("opacity", "opacityPS", options, chunks);
			code += chunks.alphaTestPS;
		}

		if (shadowType === SHADOW_PCF3 && (!device.webgl2 || lightType === LIGHTTYPE_OMNI)) {
			code += chunks.packDepthPS;
		} else if (shadowType === SHADOW_VSM8) {
			code += "vec2 encodeFloatRG( float v ) {\n";
			code += "		vec2 enc = vec2(1.0, 255.0) * v;\n";
			code += "		enc = fract(enc);\n";
			code += "		enc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\n";
			code += "		return enc;\n";
			code += "}\n\n";
		}

		code += begin();

		if (options.alphaTest) {
			code += "	 getOpacity();\n";
			code += "	 alphaTest(dAlpha);\n";
		}

		const isVsm = shadowType === SHADOW_VSM8 || shadowType === SHADOW_VSM16 || shadowType === SHADOW_VSM32;

		if (lightType === LIGHTTYPE_OMNI || isVsm && lightType !== LIGHTTYPE_DIRECTIONAL) {
			code += "	 float depth = min(distance(view_position, vPositionW) / light_radius, 0.99999);\n";
		} else {
			code += "	 float depth = gl_FragCoord.z;\n";
		}

		if (shadowType === SHADOW_PCF3 && (!device.webgl2 || lightType === LIGHTTYPE_OMNI && !options.clusteredLightingEnabled)) {
			if (device.extStandardDerivatives && !device.webgl2) {
				code += "	 float minValue = 2.3374370500153186e-10; //(1.0 / 255.0) / (256.0 * 256.0 * 256.0);\n";
				code += "	 depth += polygonOffset.x * max(abs(dFdx(depth)), abs(dFdy(depth))) + minValue * polygonOffset.y;\n";
				code += "	 gl_FragColor = packFloat(depth);\n";
			} else {
				code += "	 gl_FragColor = packFloat(depth);\n";
			}
		} else if (shadowType === SHADOW_PCF3 || shadowType === SHADOW_PCF5) {
			code += "	 gl_FragColor = vec4(1.0);\n";

			if (options.clusteredLightingEnabled && lightType === LIGHTTYPE_OMNI && device.webgl2) {
				code += "	 gl_FragDepth = depth;\n";
			}
		} else if (shadowType === SHADOW_VSM8) {
			code += "	 gl_FragColor = vec4(encodeFloatRG(depth), encodeFloatRG(depth*depth));\n";
		} else {
			code += chunks.storeEVSMPS;
		}

		code += end();
		return code;
	},
	createShaderDefinition: function (device, options) {
		let lighting = options.lights.length > 0;

		if (options.dirLightMap) {
			lighting = true;
		}

		if (options.clusteredLightingEnabled) {
			lighting = true;
		}

		if (options.shadingModel === SPECULAR_PHONG) {
			options.fresnelModel = 0;
			options.specularAntialias = false;
			options.ambientSH = false;
		} else {
			options.fresnelModel = options.fresnelModel === 0 ? FRESNEL_SCHLICK : options.fresnelModel;
		}

		const reflections = !!options.reflectionSource;
		if (!options.useSpecular) options.specularMap = options.glossMap = null;
		const shadowPass = options.pass >= SHADER_SHADOW && options.pass <= 17;
		const needsNormal = lighting || reflections || options.ambientSH || options.heightMap || options.enableGGXSpecular || options.clusteredLightingEnabled && !shadowPass || options.clearCoatNormalMap;
		this.options = options;
		let code = '';
		let codeBody = '';
		let varyings = "";
		let chunks = shaderChunks;
		let shadowCoordArgs;
		let chunk;
		const attributes = {
			vertex_position: SEMANTIC_POSITION
		};

		if (options.chunks) {
			const customChunks = {};

			for (const p in chunks) {
				if (chunks.hasOwnProperty(p)) {
					if (!options.chunks[p]) {
						customChunks[p] = chunks[p];
					} else {
						chunk = options.chunks[p];

						if (chunk.indexOf("vertex_normal") >= 0) {
							attributes.vertex_normal = SEMANTIC_NORMAL;
						}

						if (chunk.indexOf("vertex_tangent") >= 0) {
							attributes.vertex_tangent = SEMANTIC_TANGENT;
						}

						if (chunk.indexOf("vertex_texCoord0") >= 0) {
							attributes.vertex_texCoord0 = SEMANTIC_TEXCOORD0;
						}

						if (chunk.indexOf("vertex_texCoord1") >= 0) {
							attributes.vertex_texCoord1 = SEMANTIC_TEXCOORD1;
						}

						if (chunk.indexOf("vertex_color") >= 0) {
							attributes.vertex_color = SEMANTIC_COLOR;
						}

						if (chunk.indexOf("vertex_boneWeights") >= 0) {
							attributes.vertex_boneWeights = SEMANTIC_BLENDWEIGHT;
						}

						if (chunk.indexOf("vertex_boneIndices") >= 0) {
							attributes.vertex_boneIndices = SEMANTIC_BLENDINDICES;
						}

						customChunks[p] = chunk;
					}
				}
			}

			chunks = customChunks;
		}

		code += this._getPassDefineString(options.pass);
		code = this._vsAddBaseCode(code, device, chunks, options);
		codeBody += "	 vPositionW		= getWorldPosition();\n";

		if (options.pass === SHADER_DEPTH) {
			code += 'varying float vDepth;\n';
			code += '#ifndef VIEWMATRIX\n';
			code += '#define VIEWMATRIX\n';
			code += 'uniform mat4 matrix_view;\n';
			code += '#endif\n';
			code += '#ifndef CAMERAPLANES\n';
			code += '#define CAMERAPLANES\n';
			code += 'uniform vec4 camera_params;\n\n';
			code += '#endif\n';
			codeBody += "		vDepth = -(matrix_view * vec4(vPositionW,1.0)).z * camera_params.x;\n";
		}

		if (options.useInstancing) {
			attributes.instance_line1 = SEMANTIC_ATTR12;
			attributes.instance_line2 = SEMANTIC_ATTR13;
			attributes.instance_line3 = SEMANTIC_ATTR14;
			attributes.instance_line4 = SEMANTIC_ATTR15;
			code += chunks.instancingVS;
		}

		if (needsNormal) {
			attributes.vertex_normal = SEMANTIC_NORMAL;
			codeBody += "	 vNormalW = getNormal();\n";

			if (options.reflectionSource === 'sphereMap' && device.fragmentUniformsCount <= 16) {
				code += chunks.viewNormalVS;
				codeBody += "	 vNormalV		= getViewNormal();\n";
			}

			if ((options.heightMap || options.normalMap || options.enableGGXSpecular) && options.hasTangents) {
				attributes.vertex_tangent = SEMANTIC_TANGENT;
				code += chunks.tangentBinormalVS;
				codeBody += "	 vTangentW	 = getTangent();\n";
				codeBody += "	 vBinormalW	= getBinormal();\n";
			} else if (options.enableGGXSpecular) {
				code += chunks.tangentBinormalVS;
				codeBody += "	 vObjectSpaceUpW	= getObjectSpaceUp();\n";
			}
		}

		const useUv = [];
		const useUnmodifiedUv = [];
		const maxUvSets = 2;

		for (const p in _matTex2D) {
			const mname = p + "Map";

			if (options[p + "VertexColor"]) {
				const cname = p + "VertexColorChannel";
				options[cname] = this._correctChannel(p, options[cname]);
			}

			if (options[mname]) {
				const cname = mname + "Channel";
				const tname = mname + "Transform";
				const uname = mname + "Uv";
				options[uname] = Math.min(options[uname], maxUvSets - 1);
				options[cname] = this._correctChannel(p, options[cname]);
				const uvSet = options[uname];
				useUv[uvSet] = true;
				useUnmodifiedUv[uvSet] = useUnmodifiedUv[uvSet] || options[mname] && !options[tname];
			}
		}

		if (options.forceUv1) {
			useUv[1] = true;
			useUnmodifiedUv[1] = useUnmodifiedUv[1] !== undefined ? useUnmodifiedUv[1] : true;
		}

		for (let i = 0; i < maxUvSets; i++) {
			if (useUv[i]) {
				attributes["vertex_texCoord" + i] = "TEXCOORD" + i;
				code += chunks["uv" + i + "VS"];
				codeBody += "	 vec2 uv" + i + " = getUv" + i + "();\n";
			}

			if (useUnmodifiedUv[i]) {
				codeBody += "	 vUv" + i + " = uv" + i + ";\n";
			}
		}

		const codes = [code, varyings, codeBody, []];

		for (const p in _matTex2D) {
			const mname = p + "Map";

			if (options[mname]) {
				const tname = mname + "Transform";

				if (options[tname]) {
					const uname = mname + "Uv";

					this._setMapTransform(codes, p, options[tname], options[uname]);
				}
			}
		}

		code = codes[0];
		varyings = codes[1];
		codeBody = codes[2];

		if (options.vertexColors) {
			attributes.vertex_color = SEMANTIC_COLOR;
			codeBody += "	 vVertexColor = vertex_color;\n";
		}

		if (options.useMorphPosition || options.useMorphNormal) {
			if (options.useMorphTextureBased) {
				code += "#define MORPHING_TEXTURE_BASED\n";

				if (options.useMorphPosition) {
					code += "#define MORPHING_TEXTURE_BASED_POSITION\n";
				}

				if (options.useMorphNormal) {
					code += "#define MORPHING_TEXTURE_BASED_NORMAL\n";
				}

				attributes.morph_vertex_id = SEMANTIC_ATTR15;
				code += "attribute float morph_vertex_id;\n";
			} else {
				code += "#define MORPHING\n";

				if (options.useMorphPosition) {
					attributes.morph_pos0 = SEMANTIC_ATTR8;
					attributes.morph_pos1 = SEMANTIC_ATTR9;
					attributes.morph_pos2 = SEMANTIC_ATTR10;
					attributes.morph_pos3 = SEMANTIC_ATTR11;
					code += "#define MORPHING_POS03\n";
					code += "attribute vec3 morph_pos0;\n";
					code += "attribute vec3 morph_pos1;\n";
					code += "attribute vec3 morph_pos2;\n";
					code += "attribute vec3 morph_pos3;\n";
				} else if (options.useMorphNormal) {
					attributes.morph_nrm0 = SEMANTIC_ATTR8;
					attributes.morph_nrm1 = SEMANTIC_ATTR9;
					attributes.morph_nrm2 = SEMANTIC_ATTR10;
					attributes.morph_nrm3 = SEMANTIC_ATTR11;
					code += "#define MORPHING_NRM03\n";
					code += "attribute vec3 morph_nrm0;\n";
					code += "attribute vec3 morph_nrm1;\n";
					code += "attribute vec3 morph_nrm2;\n";
					code += "attribute vec3 morph_nrm3;\n";
				}

				if (!options.useMorphNormal) {
					attributes.morph_pos4 = SEMANTIC_ATTR12;
					attributes.morph_pos5 = SEMANTIC_ATTR13;
					attributes.morph_pos6 = SEMANTIC_ATTR14;
					attributes.morph_pos7 = SEMANTIC_ATTR15;
					code += "#define MORPHING_POS47\n";
					code += "attribute vec3 morph_pos4;\n";
					code += "attribute vec3 morph_pos5;\n";
					code += "attribute vec3 morph_pos6;\n";
					code += "attribute vec3 morph_pos7;\n";
				} else {
					attributes.morph_nrm4 = SEMANTIC_ATTR12;
					attributes.morph_nrm5 = SEMANTIC_ATTR13;
					attributes.morph_nrm6 = SEMANTIC_ATTR14;
					attributes.morph_nrm7 = SEMANTIC_ATTR15;
					code += "#define MORPHING_NRM47\n";
					code += "attribute vec3 morph_nrm4;\n";
					code += "attribute vec3 morph_nrm5;\n";
					code += "attribute vec3 morph_nrm6;\n";
					code += "attribute vec3 morph_nrm7;\n";
				}
			}
		}

		if (options.skin) {
			attributes.vertex_boneWeights = SEMANTIC_BLENDWEIGHT;
			attributes.vertex_boneIndices = SEMANTIC_BLENDINDICES;
			code += skinCode(device, chunks);
			code += "#define SKIN\n";
		} else if (options.useInstancing) {
			code += "#define INSTANCING\n";
		}

		if (options.screenSpace) {
			code += "#define SCREENSPACE\n";
		}

		if (options.pixelSnap) {
			code += "#define PIXELSNAP\n";
		}

		code = this._vsAddTransformCode(code, device, chunks, options);
		if (needsNormal) code += chunks.normalVS;
		code += "\n";
		code += chunks.startVS;
		code += codeBody;
		code += chunks.endVS;
		code += "}";
		let vshader = code;
		const oldVars = varyings;
		varyings = "";
		varyings += this._addVaryingIfNeeded(code, "vec4", "vVertexColor");
		varyings += this._addVaryingIfNeeded(code, "vec3", "vPositionW");
		varyings += this._addVaryingIfNeeded(code, "vec3", "vNormalV");
		varyings += this._addVaryingIfNeeded(code, "vec3", "vNormalW");
		varyings += this._addVaryingIfNeeded(code, "vec3", "vTangentW");
		varyings += this._addVaryingIfNeeded(code, "vec3", "vBinormalW");
		varyings += this._addVaryingIfNeeded(code, "vec3", "vObjectSpaceUpW");
		varyings += this._addVaryingIfNeeded(code, "vec2", "vUv0");
		varyings += this._addVaryingIfNeeded(code, "vec2", "vUv1");
		varyings += oldVars;
		vshader = varyings + vshader;
		let startCode = "";

		if (device.webgl2) {
			startCode = versionCode(device);

			if (chunks.extensionVS) {
				startCode += chunks.extensionVS + "\n";
			}

			vshader = startCode + chunks.gles3VS + vshader;
		} else {
			if (chunks.extensionVS) {
				startCode = chunks.extensionVS + "\n";
			}

			vshader = startCode + vshader;
		}

		if (options.forceFragmentPrecision && options.forceFragmentPrecision !== "highp" && options.forceFragmentPrecision !== "mediump" && options.forceFragmentPrecision !== "lowp") options.forceFragmentPrecision = null;

		if (options.forceFragmentPrecision) {
			if (options.forceFragmentPrecision === "highp" && device.maxPrecision !== "highp") options.forceFragmentPrecision = "mediump";
			if (options.forceFragmentPrecision === "mediump" && device.maxPrecision === "lowp") options.forceFragmentPrecision = "lowp";
		}

		let fshader;
		code = '';

		if (device.webgl2) {
			code += versionCode(device);
		}

		if (!device.webgl2) {
			if (device.extStandardDerivatives) {
				code += "#extension GL_OES_standard_derivatives : enable\n";
			}

			if (device.extTextureLod) {
				code += "#extension GL_EXT_shader_texture_lod : enable\n";
				code += "#define SUPPORTS_TEXLOD\n";
			}
		}

		if (chunks.extensionPS) {
			code += chunks.extensionPS + "\n";
		}

		if (device.webgl2) {
			code += chunks.gles3PS;
		}

		code += options.forceFragmentPrecision ? "precision " + options.forceFragmentPrecision + " float;\n\n" : precisionCode(device);
		code += this._getPassDefineString(options.pass);

		if (options.pass === SHADER_PICK) {
			code += "uniform vec4 uColor;\n";
			code += varyings;

			if (options.alphaTest) {
				code += "float dAlpha;\n";
				code += this._addMap("opacity", "opacityPS", options, chunks);
				code += chunks.alphaTestPS;
			}

			code += begin();

			if (options.alphaTest) {
				code += "	 getOpacity();\n";
				code += "	 alphaTest(dAlpha);\n";
			}

			code += "		gl_FragColor = uColor;\n";
			code += end();
			return {
				attributes: attributes,
				vshader: vshader,
				fshader: code
			};
		} else if (options.pass === SHADER_DEPTH) {
			code += 'varying float vDepth;\n';
			code += varyings;
			code += chunks.packDepthPS;

			if (options.alphaTest) {
				code += "float dAlpha;\n";
				code += this._addMap("opacity", "opacityPS", options, chunks);
				code += chunks.alphaTestPS;
			}

			code += begin();

			if (options.alphaTest) {
				code += "	 getOpacity();\n";
				code += "	 alphaTest(dAlpha);\n";
			}

			code += "		gl_FragColor = packFloat(vDepth);\n";
			code += end();
			return {
				attributes: attributes,
				vshader: vshader,
				fshader: code
			};
		} else if (shadowPass) {
			return {
				attributes: attributes,
				vshader: vshader,
				fshader: this._buildShadowPassFragmentCode(code, device, chunks, options, varyings)
			};
		}

		if (options.customFragmentShader) {
			fshader = code + options.customFragmentShader;
			return {
				attributes: attributes,
				vshader: vshader,
				fshader: fshader,
				tag: SHADERTAG_MATERIAL
			};
		}

		code += varyings;
		code = this._fsAddBaseCode(code, device, chunks, options);

		if (options.detailModes) {
			code += chunks.detailModesPS;
		}

		const codeBegin = code;
		code = "";

		if (options.clearCoat > 0) {
			code += '#define CLEARCOAT\n';
			code += "#define CLUSTER_CLEAR_COAT\n";
		}

		if (options.opacityFadesSpecular === false) {
			code += 'uniform float material_alphaFade;\n';
		}

		let numShadowLights = 0;
		const shadowTypeUsed = [];
		let shadowedDirectionalLightUsed = false;
		let useVsm = false;
		let usePerspZbufferShadow = false;
		let hasAreaLights = options.lights.some(function (light) {
			return light._shape && light._shape !== LIGHTSHAPE_PUNCTUAL;
		});

		if (options.clusteredLightingEnabled && options.clusteredLightingAreaLightsEnabled) {
			hasAreaLights = true;
		}

		if (device.areaLightLutFormat === PIXELFORMAT_R8_G8_B8_A8) {
			code += "#define AREA_R8_G8_B8_A8_LUTS\n";
			code += "#define AREA_LUTS_PRECISION lowp\n";
		} else {
			code += "#define AREA_LUTS_PRECISION highp\n";
		}

		if (hasAreaLights || options.clusteredLightingEnabled) {
			code += "#define AREA_LIGHTS\n";
			code += "uniform AREA_LUTS_PRECISION sampler2D areaLightsLutTex1;\n";
			code += "uniform AREA_LUTS_PRECISION sampler2D areaLightsLutTex2;\n";
		}

		for (let i = 0; i < options.lights.length; i++) {
			const light = options.lights[i];
			const lightType = light._type;
			if (options.clusteredLightingEnabled && lightType !== LIGHTTYPE_DIRECTIONAL) continue;
			const lightShape = hasAreaLights && light._shape ? light._shape : LIGHTSHAPE_PUNCTUAL;
			code += "uniform vec3 light" + i + "_color;\n";

			if (lightType === LIGHTTYPE_DIRECTIONAL) {
				code += "uniform vec3 light" + i + "_direction;\n";
			} else {
				code += "uniform vec3 light" + i + "_position;\n";
				code += "uniform float light" + i + "_radius;\n";

				if (lightType === LIGHTTYPE_SPOT) {
					code += "uniform vec3 light" + i + "_direction;\n";
					code += "uniform float light" + i + "_innerConeAngle;\n";
					code += "uniform float light" + i + "_outerConeAngle;\n";
				}
			}

			if (lightShape !== LIGHTSHAPE_PUNCTUAL) {
				if (lightType === LIGHTTYPE_DIRECTIONAL) {
					code += "uniform vec3 light" + i + "_position;\n";
				}

				code += "uniform vec3 light" + i + "_halfWidth;\n";
				code += "uniform vec3 light" + i + "_halfHeight;\n";
			}

			if (light.castShadows && !options.noShadow) {
				code += "uniform mat4 light" + i + "_shadowMatrix;\n";

				if (lightType === LIGHTTYPE_DIRECTIONAL) {
					code += "uniform mat4 light" + i + "_shadowMatrixPalette[4];\n";
					code += "uniform float light" + i + "_shadowCascadeDistances[4];\n";
					code += "uniform float light" + i + "_shadowCascadeCount;\n";
				}

				if (lightType !== LIGHTTYPE_DIRECTIONAL) {
					code += "uniform vec4 light" + i + "_shadowParams;\n";
				} else {
					shadowedDirectionalLightUsed = true;
					code += "uniform vec3 light" + i + "_shadowParams;\n";
				}

				if (lightType === LIGHTTYPE_OMNI) {
					code += "uniform samplerCube light" + i + "_shadowMap;\n";
				} else {
					if (light._isPcf && device.webgl2) {
						code += "uniform sampler2DShadow light" + i + "_shadowMap;\n";
					} else {
						code += "uniform sampler2D light" + i + "_shadowMap;\n";
					}
				}

				numShadowLights++;
				shadowTypeUsed[light._shadowType] = true;
				if (light._isVsm) useVsm = true;
				if (light._isPcf && (device.webgl2 || device.extStandardDerivatives) && lightType === LIGHTTYPE_SPOT) usePerspZbufferShadow = true;
			}

			if (light._cookie) {
				if (light._cookie._cubemap) {
					if (lightType === LIGHTTYPE_OMNI) {
						code += "uniform samplerCube light" + i + "_cookie;\n";
						code += "uniform float light" + i + "_cookieIntensity;\n";
						if (!light.castShadows || options.noShadow) code += "uniform mat4 light" + i + "_shadowMatrix;\n";
					}
				} else {
					if (lightType === LIGHTTYPE_SPOT) {
						code += "uniform sampler2D light" + i + "_cookie;\n";
						code += "uniform float light" + i + "_cookieIntensity;\n";
						if (!light.castShadows || options.noShadow) code += "uniform mat4 light" + i + "_shadowMatrix;\n";

						if (light._cookieTransform) {
							code += "uniform vec4 light" + i + "_cookieMatrix;\n";
							code += "uniform vec2 light" + i + "_cookieOffset;\n";
						}
					}
				}
			}
		}

		code += "\n";
		let tbn;

		if (!options.hasTangents && device.extStandardDerivatives) {
			tbn = chunks.TBNderivativePS;
		} else if (options.fastTbn) {
			tbn = chunks.TBNfastPS;
		} else {
			tbn = chunks.TBNPS;
		}

		if (needsNormal) {
			if (options.normalMap || options.clearCoatNormalMap) {
				code += options.packedNormal ? chunks.normalXYPS : chunks.normalXYZPS;

				if (!options.hasTangents) {
					const baseName = options.normalMap ? "normalMap" : "clearCoatNormalMap";

					const uv = this._getUvSourceExpression(`${baseName}Transform`, `${baseName}Uv`, options);

					tbn = tbn.replace(/\$UV/g, uv);
				}

				code += tbn;
			} else if (options.enableGGXSpecular && !options.heightMap) {
				code += chunks.normalVertexPS;
				code += chunks.TBNObjectSpacePS;
			}
		}

		if (needsNormal) {
			if (options.normalMap) {
				if (options.normalDetail) {
					code += this._addMap("normalDetail", "normalDetailMapPS", options, chunks);
				}

				const transformedNormalMapUv = this._getUvSourceExpression("normalMapTransform", "normalMapUv", options);

				if (options.normalizeNormalMap) {
					code += chunks.normalMapPS.replace(/\$UV/g, transformedNormalMapUv);
				} else {
					code += chunks.normalMapFastPS.replace(/\$UV/g, transformedNormalMapUv);
				}
			} else if (!(options.enableGGXSpecular && !options.heightMap)) {
				code += chunks.normalVertexPS;
			}
		}

		code += gammaCode(options.gamma, chunks);
		code += tonemapCode(options.toneMap, chunks);
		code += fogCode(options.fog, chunks);
		code += chunks.decodePS;
		if (options.useRgbm) code += chunks.rgbmPS;

		if (options.useCubeMapRotation) {
			code += "#define CUBEMAP_ROTATION\n";
		}

		if (needsNormal) {
			code += chunks.cubeMapRotatePS;
			code += options.cubeMapProjection > 0 ? chunks.cubeMapProjectBoxPS : chunks.cubeMapProjectNonePS;
			code += options.skyboxIntensity ? chunks.envMultiplyPS : chunks.envConstPS;
		}

		if (options.diffuseDetail) {
			code += this._addMap("diffuseDetail", "diffuseDetailMapPS", options, chunks);
		}

		code += this._addMap("diffuse", "diffusePS", options, chunks);

		if (options.blendType !== BLEND_NONE || options.alphaTest || options.alphaToCoverage) {
			code += this._addMap("opacity", "opacityPS", options, chunks);
		}

		code += this._addMap("emissive", "emissivePS", options, chunks, options.emissiveFormat);

		if (lighting && options.useSpecular || reflections) {
			if (options.specularAntialias && options.normalMap) {
				if (options.normalizeNormalMap && needsNormal) {
					code += chunks.specularAaToksvigPS;
				} else {
					code += chunks.specularAaToksvigFastPS;
				}
			} else {
				code += chunks.specularAaNonePS;
			}

			const specularPropName = options.useMetalness ? "metalness" : "specular";
			code += this._addMap(specularPropName, specularPropName + "PS", options, chunks);
			code += this._addMap("gloss", "glossPS", options, chunks);

			if (options.fresnelModel === FRESNEL_SCHLICK) {
				code += chunks.fresnelSchlickPS;
			}
		}

		if (options.clearCoat > 0) {
			code += this._addMap("clearCoat", "clearCoatPS", options, chunks);
			code += this._addMap("clearCoatGloss", "clearCoatGlossPS", options, chunks);
			code += this._addMap("clearCoatNormal", "clearCoatNormalPS", options, chunks);
		}

		if (options.heightMap) {
			if (!options.normalMap) {
				const transformedHeightMapUv = this._getUvSourceExpression("heightMapTransform", "heightMapUv", options);

				if (!options.hasTangents) tbn = tbn.replace(/\$UV/g, transformedHeightMapUv);
				code += tbn;
			}

			code += this._addMap("height", "parallaxPS", options, chunks);
		}

		const useAo = options.aoMap || options.aoVertexColor;

		if (useAo) {
			code += this._addMap("ao", "aoPS", options, chunks);

			if (options.occludeSpecular) {
				if (options.occludeSpecular === SPECOCC_AO) {
					code += options.occludeSpecularFloat ? chunks.aoSpecOccSimplePS : chunks.aoSpecOccConstSimplePS;
				} else {
					code += options.occludeSpecularFloat ? chunks.aoSpecOccPS : chunks.aoSpecOccConstPS;
				}
			}
		}

		if (options.reflectionSource === 'envAtlas') {
			code += chunks.reflectionEnvPS.replace(/\$DECODE/g, this._decodeFunc(options.reflectionEncoding));
		} else if (options.reflectionSource === 'cubeMap') {
			code += options.fixSeams ? chunks.fixCubemapSeamsStretchPS : chunks.fixCubemapSeamsNonePS;
			code += chunks.reflectionCubePS.replace(/\$DECODE/g, this._decodeFunc(options.reflectionEncoding));
		} else if (options.reflectionSource === 'sphereMap') {
			const scode = device.fragmentUniformsCount > 16 ? chunks.reflectionSpherePS : chunks.reflectionSphereLowPS;
			code += scode.replace(/\$DECODE/g, this._decodeFunc(options.reflectionEncoding));
		}

		if (reflections) {
			if (options.clearCoat > 0) {
				code += chunks.reflectionCCPS;
			}

			if (options.refraction) {
				code += chunks.refractionPS;
			}
		}

		if (options.clusteredLightingEnabled) {
			code += chunks.clusteredLightUtilsPS;
			code += chunks.clusteredLightCookiesPS;
			shadowTypeUsed[SHADOW_PCF3] = true;
			shadowTypeUsed[SHADOW_PCF5] = true;
			usePerspZbufferShadow = true;
		}

		if (numShadowLights > 0 || options.clusteredLightingEnabled) {
			if (shadowedDirectionalLightUsed) {
				code += chunks.shadowCascadesPS;
			}

			if (shadowTypeUsed[SHADOW_PCF3]) {
				code += chunks.shadowStandardPS;
			}

			if (shadowTypeUsed[SHADOW_PCF5] && device.webgl2) {
				code += chunks.shadowStandardGL2PS;
			}

			if (useVsm) {
				code += chunks.shadowVSM_commonPS;

				if (shadowTypeUsed[SHADOW_VSM8]) {
					code += chunks.shadowVSM8PS;
				}

				if (shadowTypeUsed[SHADOW_VSM16]) {
					code += device.extTextureHalfFloatLinear ? chunks.shadowEVSMPS.replace(/\$/g, "16") : chunks.shadowEVSMnPS.replace(/\$/g, "16");
				}

				if (shadowTypeUsed[SHADOW_VSM32]) {
					code += device.extTextureFloatLinear ? chunks.shadowEVSMPS.replace(/\$/g, "32") : chunks.shadowEVSMnPS.replace(/\$/g, "32");
				}
			}

			if (!(device.webgl2 || device.extStandardDerivatives)) {
				code += chunks.biasConstPS;
			}

			code += chunks.shadowCoordPS + chunks.shadowCommonPS;
			if (usePerspZbufferShadow) code += chunks.shadowCoordPerspZbufferPS;
		}

		if (options.enableGGXSpecular) code += "uniform float material_anisotropy;\n";

		if (lighting) {
			code += chunks.lightDiffuseLambertPS;
			if (hasAreaLights || options.clusteredLightingEnabled) code += chunks.ltc;
		}

		code += '\n';
		let useOldAmbient = false;

		if (options.useSpecular) {
			code += "#define CLUSTER_SPECULAR\n";

			if (options.conserveEnergy) {
				code += "#define CLUSTER_CONSERVE_ENERGY\n";
			}

			if (lighting) {
				code += options.shadingModel === SPECULAR_PHONG ? chunks.lightSpecularPhongPS : options.enableGGXSpecular ? chunks.lightSpecularAnisoGGXPS : chunks.lightSpecularBlinnPS;
			}

			if (options.fresnelModel > 0) {
				if (options.conserveEnergy && !hasAreaLights) {
					code += chunks.combineDiffuseSpecularPS;
				} else {
					code += chunks.combineDiffuseSpecularNoConservePS;
				}
			} else if (reflections) {
				code += chunks.combineDiffuseSpecularOldPS;
			} else {
				if (options.diffuseMap) {
					code += chunks.combineDiffuseSpecularNoReflPS;
				} else {
					code += chunks.combineDiffuseSpecularNoReflSeparateAmbientPS;
					useOldAmbient = true;
				}
			}
		} else {
			code += chunks.combineDiffusePS;
		}

		if (options.clearCoat > 0) {
			code += chunks.combineClearCoatPS;
		}

		let addAmbient = true;

		if (options.lightMap || options.lightVertexColor) {
			const lightmapChunkPropName = options.dirLightMap && options.useSpecular ? 'lightmapDirPS' : 'lightmapSinglePS';
			code += this._addMap("light", lightmapChunkPropName, options, chunks, options.lightMapFormat);
			addAmbient = options.lightMapWithoutAmbient;
		}

		if (addAmbient) {
			if (options.ambientSource === 'ambientSH') {
				code += chunks.ambientSHPS;
			} else if (options.ambientSource === 'envAtlas') {
				code += chunks.ambientEnvPS.replace(/\$DECODE/g, this._decodeFunc(options.ambientEncoding));
			} else {
				code += chunks.ambientConstantPS;
			}
		}

		if (options.ambientTint && !useOldAmbient) {
			code += "uniform vec3 material_ambient;\n";
		}

		if (options.alphaTest) {
			code += chunks.alphaTestPS;
		}

		if (options.msdf) {
			code += chunks.msdfPS;
		}

		if (needsNormal) {
			code += chunks.viewDirPS;

			if (options.useSpecular) {
				code += options.enableGGXSpecular ? chunks.reflDirAnisoPS : chunks.reflDirPS;
			}
		}

		let hasPointLights = false;
		let usesLinearFalloff = false;
		let usesInvSquaredFalloff = false;
		let usesSpot = false;
		let usesCookie = false;
		let usesCookieNow;

		if (options.clusteredLightingEnabled && lighting) {
			usesSpot = true;
			hasPointLights = true;
			usesLinearFalloff = true;
			usesCookie = true;
			code += chunks.floatUnpackingPS;
			if (options.lightMaskDynamic) code += "\n#define CLUSTER_MESH_DYNAMIC_LIGHTS";
			if (options.clusteredLightingCookiesEnabled) code += "\n#define CLUSTER_COOKIES";

			if (options.clusteredLightingShadowsEnabled && !options.noShadow) {
				code += "\n#define CLUSTER_SHADOWS";
				code += "\n#define CLUSTER_SHADOW_TYPE_" + shadowTypeToString[options.clusteredLightingShadowType];
			}

			if (options.clusteredLightingAreaLightsEnabled) code += "\n#define CLUSTER_AREALIGHTS";
			code += LightsBuffer.shaderDefines;
			code += chunks.clusteredLightShadowsPS;
			code += chunks.clusteredLightPS;
		}

		if (options.twoSidedLighting) code += "uniform float twoSidedLightingNegScaleFactor;\n";
		code = this._fsAddStartCode(code, device, chunks, options);

		if (needsNormal) {
			if (!options.hasTangents && device.extStandardDerivatives && !options.fastTbn) {
				if (options.twoSidedLighting) {
					code += "	 dVertexNormalW = normalize(gl_FrontFacing ? vNormalW * twoSidedLightingNegScaleFactor : -vNormalW * twoSidedLightingNegScaleFactor);\n";
				} else {
					code += "	 dVertexNormalW = normalize(vNormalW);\n";
				}
			} else {
				if (options.twoSidedLighting) {
					code += "	 dVertexNormalW = gl_FrontFacing ? vNormalW * twoSidedLightingNegScaleFactor : -vNormalW * twoSidedLightingNegScaleFactor;\n";
				} else {
					code += "	 dVertexNormalW = vNormalW;\n";
				}
			}

			if ((options.heightMap || options.normalMap) && options.hasTangents) {
				if (options.twoSidedLighting) {
					code += "	 dTangentW = gl_FrontFacing ? vTangentW * twoSidedLightingNegScaleFactor : -vTangentW * twoSidedLightingNegScaleFactor;\n";
					code += "	 dBinormalW = gl_FrontFacing ? vBinormalW * twoSidedLightingNegScaleFactor : -vBinormalW * twoSidedLightingNegScaleFactor;\n";
				} else {
					code += "	 dTangentW = vTangentW;\n";
					code += "	 dBinormalW = vBinormalW;\n";
				}
			}
		}

		let opacityParallax = false;

		if (options.blendType === BLEND_NONE && !options.alphaTest && !options.alphaToCoverage) {
			code += "	 dAlpha = 1.0;\n";
		} else {
			if (options.heightMap && options.opacityMap) {
				opacityParallax = true;
			} else {
				code += "	 getOpacity();\n";

				if (options.alphaTest) {
					code += "	 alphaTest(dAlpha);\n";
				}
			}
		}

		let getGlossinessCalled = false;

		if (needsNormal) {
			code += "	 getViewDir();\n";

			if (options.heightMap || options.normalMap || options.clearCoatNormalMap || options.enableGGXSpecular) {
				code += "	 getTBN();\n";
			}

			if (options.heightMap) {
				code += "	 getParallax();\n";
			}

			if (opacityParallax) {
				code += "	 getOpacity();\n";

				if (options.alphaTest) {
					code += "	 alphaTest(dAlpha);\n";
				}
			}

			code += "	 getNormal();\n";

			if (options.useSpecular) {
				if (lighting && options.enableGGXSpecular) {
					code += "	 getGlossiness();\n";
					getGlossinessCalled = true;
				}

				code += "	 getReflDir();\n";
			}
		}

		code += "	 getAlbedo();\n";

		if (options.clearCoat > 0) {
			code += "	 getClearCoat();\n";
			code += "	 getClearCoatGlossiness();\n";
			code += "	 getClearCoatNormal();\n";
		}

		if (lighting && options.useSpecular || reflections) {
			code += "	 getSpecularity();\n";
			if (!getGlossinessCalled) code += "	 getGlossiness();\n";

			if (hasAreaLights) {
				code += "	 #ifdef AREA_LIGHTS\n";
				code += "	 dSpecularityNoFres = dSpecularity;\n";
				code += "	 #ifdef CLEARCOAT\n";
				code += "	 ccSpecularityNoFres = ccSpecularity;\n";
				code += "	 #endif\n";
				code += "	 #endif\n";
			}

			if (options.fresnelModel > 0) code += "	 getFresnel();\n";
		}

		if (addAmbient) {
			code += "	 addAmbient();\n";

			if (options.separateAmbient) {
				code += `
										vec3 dAmbientLight = dDiffuseLight;
										dDiffuseLight = vec3(0);
								`;
			}
		}

		if (options.ambientTint && !useOldAmbient) {
			code += "	 dDiffuseLight *= material_ambient;\n";
		}

		if (useAo && !options.occludeDirect) {
			code += "		applyAO();\n";
		}

		if (options.lightMap || options.lightVertexColor) {
			code += "	 addLightMap();\n";
		}

		if (lighting || reflections) {
			if (reflections) {
				if (options.clearCoat > 0) {
					code += "	 addReflectionCC();\n";
				}

				code += "	 addReflection();\n";
			}

			if (hasAreaLights) {
				code += "	 ccReflection.rgb *= ccSpecularity;\n";
				code += "	 dReflection.rgb *= dSpecularity;\n";
				code += "	 dSpecularLight *= dSpecularity;\n";
				code += "	 float roughness = max((1.0 - dGlossiness) * (1.0 - dGlossiness), 0.001);\n";
				code += "	 calcLTCLightValues();\n";
			}

			for (let i = 0; i < options.lights.length; i++) {
				const light = options.lights[i];
				const lightType = light._type;

				if (options.clusteredLightingEnabled && lightType !== LIGHTTYPE_DIRECTIONAL) {
					continue;
				}

				usesCookieNow = false;
				const lightShape = hasAreaLights && light._shape ? light.shape : LIGHTSHAPE_PUNCTUAL;
				const shapeString = hasAreaLights && light._shape ? this._getLightSourceShapeString(lightShape) : '';

				if (lightShape !== LIGHTSHAPE_PUNCTUAL) {
					code += "	 calc" + shapeString + "LightValues(light" + i + "_position, light" + i + "_halfWidth, light" + i + "_halfHeight);\n";
				}

				if (lightType === LIGHTTYPE_DIRECTIONAL) {
					code += "	 dLightDirNormW = light" + i + "_direction;\n";
					code += "	 dAtten = 1.0;\n";
				} else {
					if (light._cookie) {
						if (lightType === LIGHTTYPE_SPOT && !light._cookie._cubemap) {
							usesCookie = true;
							usesCookieNow = true;
						} else if (lightType === LIGHTTYPE_OMNI && light._cookie._cubemap) {
							usesCookie = true;
							usesCookieNow = true;
						}
					}

					code += "	 getLightDirPoint(light" + i + "_position);\n";
					hasPointLights = true;

					if (usesCookieNow) {
						if (lightType === LIGHTTYPE_SPOT) {
							code += "	 dAtten3 = getCookie2D" + (light._cookieFalloff ? "" : "Clip") + (light._cookieTransform ? "Xform" : "") + "(light" + i + "_cookie, light" + i + "_shadowMatrix, light" + i + "_cookieIntensity" + (light._cookieTransform ? ", light" + i + "_cookieMatrix, light" + i + "_cookieOffset" : "") + ")." + light._cookieChannel + ";\n";
						} else {
							code += "	 dAtten3 = getCookieCube(light" + i + "_cookie, light" + i + "_shadowMatrix, light" + i + "_cookieIntensity)." + light._cookieChannel + ";\n";
						}
					}

					if (lightShape === LIGHTSHAPE_PUNCTUAL) {
						if (light._falloffMode === LIGHTFALLOFF_LINEAR) {
							code += "	 dAtten = getFalloffLinear(light" + i + "_radius);\n";
							usesLinearFalloff = true;
						} else {
							code += "	 dAtten = getFalloffInvSquared(light" + i + "_radius);\n";
							usesInvSquaredFalloff = true;
						}
					} else {
						code += "	 dAtten = getFalloffWindow(light" + i + "_radius);\n";
						usesInvSquaredFalloff = true;
					}

					code += "	 if (dAtten > 0.00001) {\n";

					if (lightType === LIGHTTYPE_SPOT) {
						if (!(usesCookieNow && !light._cookieFalloff)) {
							code += "			 dAtten *= getSpotEffect(light" + i + "_direction, light" + i + "_innerConeAngle, light" + i + "_outerConeAngle);\n";
							usesSpot = true;
						}
					}
				}

				if (lightShape !== LIGHTSHAPE_PUNCTUAL) {
					if (lightType === LIGHTTYPE_DIRECTIONAL) {
						code += "			 dAttenD = getLightDiffuse();\n";
					} else {
						code += "			 dAttenD = get" + shapeString + "LightDiffuse() * 16.0;\n";
					}
				} else {
					code += "			 dAtten *= getLightDiffuse();\n";
				}

				if (light.castShadows && !options.noShadow) {
					let shadowReadMode = null;
					let evsmExp;

					if (light._shadowType === SHADOW_VSM8) {
						shadowReadMode = "VSM8";
						evsmExp = "0.0";
					} else if (light._shadowType === SHADOW_VSM16) {
						shadowReadMode = "VSM16";
						evsmExp = "5.54";
					} else if (light._shadowType === SHADOW_VSM32) {
						shadowReadMode = "VSM32";

						if (device.textureFloatHighPrecision) {
							evsmExp = "15.0";
						} else {
							evsmExp = "5.54";
						}
					} else if (light._shadowType === SHADOW_PCF5) {
						shadowReadMode = "PCF5x5";
					} else {
						shadowReadMode = "PCF3x3";
					}

					if (shadowReadMode !== null) {
						if (lightType === LIGHTTYPE_OMNI) {
							shadowCoordArgs = "(light" + i + "_shadowMap, light" + i + "_shadowParams);\n";

							if (light._normalOffsetBias) {
								code += "			 normalOffsetPointShadow(light" + i + "_shadowParams);\n";
							}

							code += "			 dAtten *= getShadowPoint" + shadowReadMode + shadowCoordArgs;
						} else {
							const shadowMatArg = `light${i}_shadowMatrix`;
							const shadowParamArg = `light${i}_shadowParams`;
							code += this._nonPointShadowMapProjection(device, options.lights[i], shadowMatArg, shadowParamArg, i);
							if (lightType === LIGHTTYPE_SPOT) shadowReadMode = "Spot" + shadowReadMode;
							code += "			 dAtten *= getShadow" + shadowReadMode + "(light" + i + "_shadowMap, light" + i + "_shadowParams" + (light._isVsm ? ", " + evsmExp : "") + ");\n";
						}
					}
				}

				if (lightShape !== LIGHTSHAPE_PUNCTUAL) {
					if (options.conserveEnergy && options.useSpecular) {
						code += "			 dDiffuseLight += mix((dAttenD * dAtten) * light" + i + "_color" + (usesCookieNow ? " * dAtten3" : "") + ", vec3(0), dLTCSpecFres);\n";
					} else {
						code += "			 dDiffuseLight += (dAttenD * dAtten) * light" + i + "_color" + (usesCookieNow ? " * dAtten3" : "") + ";\n";
					}
				} else {
					if (hasAreaLights && options.conserveEnergy && options.useSpecular) {
						code += "			 dDiffuseLight += mix(dAtten * light" + i + "_color" + (usesCookieNow ? " * dAtten3" : "") + ", vec3(0), dSpecularity);\n";
					} else {
						code += "			 dDiffuseLight += dAtten * light" + i + "_color" + (usesCookieNow ? " * dAtten3" : "") + ";\n";
					}
				}

				if (lightShape !== LIGHTSHAPE_PUNCTUAL) {
					if (options.clearCoat > 0) code += "			 ccSpecularLight += ccLTCSpecFres * get" + shapeString + "LightSpecularCC() * dAtten * light" + i + "_color" + (usesCookieNow ? " * dAtten3" : "") + ";\n";
					if (options.useSpecular) code += "			 dSpecularLight += dLTCSpecFres * get" + shapeString + "LightSpecular() * dAtten * light" + i + "_color" + (usesCookieNow ? " * dAtten3" : "") + ";\n";
				} else {
					if (hasAreaLights) {
						if (options.clearCoat > 0) code += "			 ccSpecularLight += ccSpecularity * getLightSpecularCC() * dAtten * light" + i + "_color" + (usesCookieNow ? " * dAtten3" : "") + ";\n";
						if (options.useSpecular) code += "			 dSpecularLight += dSpecularity * getLightSpecular() * dAtten * light" + i + "_color" + (usesCookieNow ? " * dAtten3" : "") + ";\n";
					} else {
						if (options.clearCoat > 0) code += "			 ccSpecularLight += getLightSpecularCC() * dAtten * light" + i + "_color" + (usesCookieNow ? " * dAtten3" : "") + ";\n";
						if (options.useSpecular) code += "			 dSpecularLight += getLightSpecular() * dAtten * light" + i + "_color" + (usesCookieNow ? " * dAtten3" : "") + ";\n";
					}
				}

				if (lightType !== LIGHTTYPE_DIRECTIONAL) {
					code += "	 }\n";
				}

				code += "\n";
			}

			if (options.clusteredLightingEnabled && lighting) {
				usesLinearFalloff = true;
				usesInvSquaredFalloff = true;
				hasPointLights = true;
				code += '	 addClusteredLights();\n';
			}

			if (hasAreaLights) {
				if (options.clearCoat > 0) {
					code += "	 ccSpecularity = 1.0;\n";
				}

				if (options.useSpecular) {
					code += "	 dSpecularity = vec3(1);\n";
				}
			}

			if (reflections && options.refraction) {
				code += "	 addRefraction();\n";
			}
		}

		code += "\n";

		if (useAo) {
			if (options.occludeDirect) {
				code += "		applyAO();\n";
			}

			if (options.occludeSpecular) {
				code += "		occludeSpecular();\n";
			}
		}

		if (options.opacityFadesSpecular === false) {
			if (options.blendType === BLEND_NORMAL || options.blendType === BLEND_PREMULTIPLIED) {
				code += "float specLum = dot((dSpecularLight + dReflection.rgb * dReflection.a) * dSpecularity, vec3( 0.2126, 0.7152, 0.0722 ));\n";
				code += "#ifdef CLEARCOAT\n specLum += dot(ccSpecularLight * ccSpecularity + ccReflection.rgb * ccReflection.a * ccSpecularity, vec3( 0.2126, 0.7152, 0.0722 ));\n#endif\n";
				code += "dAlpha = clamp(dAlpha + gammaCorrectInput(specLum), 0.0, 1.0);\n";
			}

			code += "dAlpha *= material_alphaFade;\n";
		}

		code += chunks.endPS;

		if (options.blendType === BLEND_NORMAL || options.blendType === BLEND_ADDITIVEALPHA || options.alphaToCoverage) {
			code += chunks.outputAlphaPS;
		} else if (options.blendType === BLEND_PREMULTIPLIED) {
			code += chunks.outputAlphaPremulPS;
		} else {
			code += chunks.outputAlphaOpaquePS;
		}

		if (options.msdf) {
			code += "	 gl_FragColor = applyMsdf(gl_FragColor);\n";
		}

		code += "\n";
		code += end();

		if (hasPointLights) {
			code = chunks.lightDirPointPS + code;
		}

		if (usesLinearFalloff) {
			code = chunks.falloffLinearPS + code;
		}

		if (usesInvSquaredFalloff) {
			code = chunks.falloffInvSquaredPS + code;
		}

		if (usesSpot) {
			code = chunks.spotPS + code;
		}

		if (usesCookie) {
			code = chunks.cookiePS + code;
		}

		let structCode = "";
		if (code.includes("dReflection")) structCode += "vec4 dReflection;\n";
		if (code.includes("dTBN")) structCode += "mat3 dTBN;\n";
		if (code.includes("dAlbedo")) structCode += "vec3 dAlbedo;\n";
		if (code.includes("dEmission")) structCode += "vec3 dEmission;\n";
		if (code.includes("dNormalW")) structCode += "vec3 dNormalW;\n";
		if (code.includes("dVertexNormalW")) structCode += "vec3 dVertexNormalW;\n";
		if (code.includes("dTangentW")) structCode += "vec3 dTangentW;\n";
		if (code.includes("dBinormalW")) structCode += "vec3 dBinormalW;\n";
		if (code.includes("dViewDirW")) structCode += "vec3 dViewDirW;\n";
		if (code.includes("dReflDirW")) structCode += "vec3 dReflDirW;\n";
		if (code.includes("dDiffuseLight")) structCode += "vec3 dDiffuseLight;\n";
		if (code.includes("dSpecularLight")) structCode += "vec3 dSpecularLight;\n";
		if (code.includes("dLightDirNormW")) structCode += "vec3 dLightDirNormW;\n";
		if (code.includes("dLightDirW")) structCode += "vec3 dLightDirW;\n";
		if (code.includes("dLightPosW")) structCode += "vec3 dLightPosW;\n";
		if (code.includes("dShadowCoord")) structCode += "vec3 dShadowCoord;\n";
		if (code.includes("dNormalMap")) structCode += "vec3 dNormalMap;\n";
		if (code.includes("dSpecularity")) structCode += "vec3 dSpecularity;\n";
		if (code.includes("dSpecularityNoFres")) structCode += "vec3 dSpecularityNoFres;\n";
		if (code.includes("dUvOffset")) structCode += "vec2 dUvOffset;\n";
		if (code.includes("dGlossiness")) structCode += "float dGlossiness;\n";
		if (code.includes("dAlpha")) structCode += "float dAlpha;\n";
		if (code.includes("dAtten")) structCode += "float dAtten;\n";
		if (code.includes("dAttenD")) structCode += "float dAttenD;\n";
		if (code.includes("dAtten3")) structCode += "vec3 dAtten3;\n";
		if (code.includes("dAo")) structCode += "float dAo;\n";
		if (code.includes("dMsdf")) structCode += "vec4 dMsdf;\n";
		if (code.includes("ccReflection")) structCode += "vec4 ccReflection;\n";
		if (code.includes("ccNormalW")) structCode += "vec3 ccNormalW;\n";
		if (code.includes("ccReflDirW")) structCode += "vec3 ccReflDirW;\n";
		if (code.includes("ccSpecularLight")) structCode += "vec3 ccSpecularLight;\n";
		if (code.includes("ccSpecularity")) structCode += "float ccSpecularity;\n";
		if (code.includes("ccSpecularityNoFres")) structCode += "float ccSpecularityNoFres;\n";
		if (code.includes("ccGlossiness")) structCode += "float ccGlossiness;\n";
		code = codeBegin + structCode + code;
		fshader = code;
		return {
			attributes: attributes,
			vshader: vshader,
			fshader: fshader,
			tag: SHADERTAG_MATERIAL
		};
	}
};

const programlib = {
	begin: begin,
	dummyFragmentCode: dummyFragmentCode,
	end: end,
	fogCode: fogCode,
	gammaCode: gammaCode,
	precisionCode: precisionCode,
	skinCode: skinCode,
	tonemapCode: tonemapCode,
	versionCode: versionCode,
	basic: basic,
	particle: particle,
	skybox: skybox,
	standard: standard
};

const _goldenAngle = 2.399963229728653;
const random = {
	circlePoint: function (point) {
		const r = Math.sqrt(Math.random());
		const theta = Math.random() * 2 * Math.PI;
		point.x = r * Math.cos(theta);
		point.y = r * Math.sin(theta);
	},
	circlePointDeterministic: function (point, index, numPoints) {
		const theta = index * _goldenAngle;
		const r = Math.sqrt(index) / Math.sqrt(numPoints);
		point.x = r * Math.cos(theta);
		point.y = r * Math.sin(theta);
	},
	spherePointDeterministic: function (point, index, numPoints, start = 0, end = 1) {
		start = 1 - 2 * start;
		end = 1 - 2 * end;
		const y = math.lerp(start, end, index / numPoints);
		const radius = Math.sqrt(1 - y * y);
		const theta = _goldenAngle * index;
		point.x = Math.cos(theta) * radius;
		point.y = y;
		point.z = Math.sin(theta) * radius;
	},
	radicalInverse: function (i) {
		let bits = (i << 16 | i >>> 16) >>> 0;
		bits = ((bits & 0x55555555) << 1 | (bits & 0xAAAAAAAA) >>> 1) >>> 0;
		bits = ((bits & 0x33333333) << 2 | (bits & 0xCCCCCCCC) >>> 2) >>> 0;
		bits = ((bits & 0x0F0F0F0F) << 4 | (bits & 0xF0F0F0F0) >>> 4) >>> 0;
		bits = ((bits & 0x00FF00FF) << 8 | (bits & 0xFF00FF00) >>> 8) >>> 0;
		return bits * 2.3283064365386963e-10;
	}
};

const getCoding = texture => {
	switch (texture.type) {
		case TEXTURETYPE_RGBM:
			return "RGBM";

		case TEXTURETYPE_RGBE:
			return "RGBE";

		default:
			switch (texture.format) {
				case PIXELFORMAT_RGB16F:
				case PIXELFORMAT_RGB32F:
				case PIXELFORMAT_RGBA16F:
				case PIXELFORMAT_RGBA32F:
					return "Linear";

				default:
					return "Gamma";
			}

	}
};

const getProjectionName = projection => {
	if (projection === TEXTUREPROJECTION_NONE) {
		projection = TEXTUREPROJECTION_EQUIRECT;
	}

	switch (projection) {
		case TEXTUREPROJECTION_CUBE:
			return "Cubemap";

		case TEXTUREPROJECTION_EQUIRECT:
			return "Equirect";

		case TEXTUREPROJECTION_OCTAHEDRAL:
			return "Octahedral";
	}
};

const packFloat32ToRGBA8 = (value, array, offset) => {
	if (value <= 0) {
		array[offset + 0] = 0;
		array[offset + 1] = 0;
		array[offset + 2] = 0;
		array[offset + 3] = 0;
	} else if (value >= 1.0) {
		array[offset + 0] = 255;
		array[offset + 1] = 0;
		array[offset + 2] = 0;
		array[offset + 3] = 0;
	} else {
		let encX = 1 * value % 1;
		let encY = 255 * value % 1;
		let encZ = 65025 * value % 1;
		const encW = 16581375.0 * value % 1;
		encX -= encY / 255;
		encY -= encZ / 255;
		encZ -= encW / 255;
		array[offset + 0] = Math.min(255, Math.floor(encX * 256));
		array[offset + 1] = Math.min(255, Math.floor(encY * 256));
		array[offset + 2] = Math.min(255, Math.floor(encZ * 256));
		array[offset + 3] = Math.min(255, Math.floor(encW * 256));
	}
};

const packSamples = samples => {
	const numSamples = samples.length;
	const w = Math.min(numSamples, 512);
	const h = Math.ceil(numSamples / w);
	const data = new Uint8Array(w * h * 4);
	let off = 0;

	for (let i = 0; i < numSamples; ++i) {
		packFloat32ToRGBA8(samples[i * 4 + 0] * 0.5 + 0.5, data, off + 0);
		packFloat32ToRGBA8(samples[i * 4 + 1] * 0.5 + 0.5, data, off + 4);
		packFloat32ToRGBA8(samples[i * 4 + 2] * 0.5 + 0.5, data, off + 8);
		packFloat32ToRGBA8(samples[i * 4 + 3] / 8, data, off + 12);
		off += 16;
	}

	return {
		width: w,
		height: h,
		data: data
	};
};

const hemisphereSamplePhong = (dstVec, x, y, specularPower) => {
	const phi = y * 2 * Math.PI;
	const cosTheta = Math.pow(1 - x, 1 / (specularPower + 1));
	const sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
	dstVec.set(Math.cos(phi) * sinTheta, Math.sin(phi) * sinTheta, cosTheta).normalize();
};

const hemisphereSampleLambert = (dstVec, x, y) => {
	const phi = y * 2 * Math.PI;
	const cosTheta = Math.sqrt(1 - x);
	const sinTheta = Math.sqrt(x);
	dstVec.set(Math.cos(phi) * sinTheta, Math.sin(phi) * sinTheta, cosTheta).normalize();
};

const hemisphereSampleGGX = (dstVec, x, y, a) => {
	const phi = y * 2 * Math.PI;
	const cosTheta = Math.sqrt((1 - x) / (1 + (a * a - 1) * x));
	const sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
	dstVec.set(Math.cos(phi) * sinTheta, Math.sin(phi) * sinTheta, cosTheta).normalize();
};

const D_GGX = (NoH, linearRoughness) => {
	const a = NoH * linearRoughness;
	const k = linearRoughness / (1.0 - NoH * NoH + a * a);
	return k * k * (1 / Math.PI);
};

const generatePhongSamples = (numSamples, specularPower) => {
	const H = new Vec3();
	const result = [];

	for (let i = 0; i < numSamples; ++i) {
		hemisphereSamplePhong(H, i / numSamples, random.radicalInverse(i), specularPower);
		result.push(H.x, H.y, H.z, 0);
	}

	return result;
};

const generateLambertSamples = (numSamples, sourceTotalPixels) => {
	const pixelsPerSample = sourceTotalPixels / numSamples;
	const H = new Vec3();
	const result = [];

	for (let i = 0; i < numSamples; ++i) {
		hemisphereSampleLambert(H, i / numSamples, random.radicalInverse(i));
		const pdf = H.z / Math.PI;
		const mipLevel = 0.5 * Math.log2(pixelsPerSample / pdf);
		result.push(H.x, H.y, H.z, mipLevel);
	}

	return result;
};

const requiredSamplesGGX = {
	"16": {
		"2": 26,
		"8": 20,
		"32": 17,
		"128": 16,
		"512": 16
	},
	"32": {
		"2": 53,
		"8": 40,
		"32": 34,
		"128": 32,
		"512": 32
	},
	"128": {
		"2": 214,
		"8": 163,
		"32": 139,
		"128": 130,
		"512": 128
	},
	"1024": {
		"2": 1722,
		"8": 1310,
		"32": 1114,
		"128": 1041,
		"512": 1025
	}
};

const getRequiredSamplesGGX = (numSamples, specularPower) => {
	const table = requiredSamplesGGX[numSamples];
	return table && table[specularPower] || numSamples;
};

const generateGGXSamples = (numSamples, specularPower, sourceTotalPixels) => {
	const pixelsPerSample = sourceTotalPixels / numSamples;
	const roughness = 1 - Math.log2(specularPower) / 11.0;
	const a = roughness * roughness;
	const H = new Vec3();
	const L = new Vec3();
	const N = new Vec3(0, 0, 1);
	const result = [];
	const requiredSamples = getRequiredSamplesGGX(numSamples, specularPower);

	for (let i = 0; i < requiredSamples; ++i) {
		hemisphereSampleGGX(H, i / requiredSamples, random.radicalInverse(i), a);
		const NoH = H.z;
		L.set(H.x, H.y, H.z).mulScalar(2 * NoH).sub(N);

		if (L.z > 0) {
			const pdf = D_GGX(Math.min(1, NoH), a) / 4 + 0.001;
			const mipLevel = 0.5 * Math.log2(pixelsPerSample / pdf);
			result.push(L.x, L.y, L.z, mipLevel);
		}
	}

	while (result.length < numSamples * 4) {
		result.push(0, 0, 0, 0);
	}

	return result;
};

const createSamplesTex = (device, name, samples) => {
	const packedSamples = packSamples(samples);
	return new Texture(device, {
		name: name,
		width: packedSamples.width,
		height: packedSamples.height,
		mipmaps: false,
		minFilter: FILTER_NEAREST,
		magFilter: FILTER_NEAREST,
		levels: [packedSamples.data]
	});
};

class SimpleCache {
	constructor(destroyContent = true) {
		this.map = new Map();
		this.destroyContent = destroyContent;
	}

	destroy() {
		if (this.destroyContent) {
			this.map.forEach((value, key) => {
				value.destroy();
			});
		}
	}

	get(key, missFunc) {
		if (!this.map.has(key)) {
			const result = missFunc();
			this.map.set(key, result);
			return result;
		}

		return this.map.get(key);
	}

}

const samplesCache = new SimpleCache(false);
const deviceCache = new DeviceCache();

const getCachedTexture = (device, key, getSamplesFnc) => {
	const cache = deviceCache.get(device, () => {
		return new SimpleCache();
	});
	return cache.get(key, () => {
		return createSamplesTex(device, key, samplesCache.get(key, getSamplesFnc));
	});
};

const generateLambertSamplesTex = (device, numSamples, sourceTotalPixels) => {
	const key = `lambert-samples-${numSamples}-${sourceTotalPixels}`;
	return getCachedTexture(device, key, () => {
		return generateLambertSamples(numSamples, sourceTotalPixels);
	});
};

const generatePhongSamplesTex = (device, numSamples, specularPower) => {
	const key = `phong-samples-${numSamples}-${specularPower}`;
	return getCachedTexture(device, key, () => {
		return generatePhongSamples(numSamples, specularPower);
	});
};

const generateGGXSamplesTex = (device, numSamples, specularPower, sourceTotalPixels) => {
	const key = `ggx-samples-${numSamples}-${specularPower}-${sourceTotalPixels}`;
	return getCachedTexture(device, key, () => {
		return generateGGXSamples(numSamples, specularPower, sourceTotalPixels);
	});
};

const vsCode = `
attribute vec2 vertex_position;

uniform vec4 uvMod;

varying vec2 vUv0;

void main(void) {
		gl_Position = vec4(vertex_position, 0.5, 1.0);
		vUv0 = (vertex_position.xy * 0.5 + 0.5) * uvMod.xy + uvMod.zw;
}
`;

function reprojectTexture(source, target, options = {}) {
	var _options;

	if (source instanceof GraphicsDevice) {
		source = arguments[1];
		target = arguments[2];
		options = {};

		if (arguments[3] !== undefined) {
			options.specularPower = arguments[3];
		}

		if (arguments[4] !== undefined) {
			options.numSamples = arguments[4];
		}
	}

	const funcNames = {
		'none': 'reproject',
		'lambert': 'prefilterSamplesUnweighted',
		'phong': 'prefilterSamplesUnweighted',
		'ggx': 'prefilterSamples'
	};
	const specularPower = options.hasOwnProperty('specularPower') ? options.specularPower : 1;
	const face = options.hasOwnProperty('face') ? options.face : null;
	const distribution = options.hasOwnProperty('distribution') ? options.distribution : specularPower === 1 ? 'none' : 'phong';
	const processFunc = funcNames[distribution] || 'reproject';
	const decodeFunc = `decode${getCoding(source)}`;
	const encodeFunc = `encode${getCoding(target)}`;
	const sourceFunc = `sample${getProjectionName(source.projection)}`;
	const targetFunc = `getDirection${getProjectionName(target.projection)}`;
	const numSamples = options.hasOwnProperty('numSamples') ? options.numSamples : 1024;
	const shaderKey = `${processFunc}_${decodeFunc}_${encodeFunc}_${sourceFunc}_${targetFunc}_${numSamples}`;
	const device = source.device;
	let shader = device.programLib._cache[shaderKey];

	if (!shader) {
		const defines = `#define PROCESS_FUNC ${processFunc}\n` + `#define DECODE_FUNC ${decodeFunc}\n` + `#define ENCODE_FUNC ${encodeFunc}\n` + `#define SOURCE_FUNC ${sourceFunc}\n` + `#define TARGET_FUNC ${targetFunc}\n` + `#define NUM_SAMPLES ${numSamples}\n` + (device.extTextureLod ? `#define SUPPORTS_TEXLOD\n` : '');
		let extensions = '';

		if (!device.webgl2) {
			extensions = '#extension GL_OES_standard_derivatives: enable\n';

			if (device.extTextureLod) {
				extensions += '#extension GL_EXT_shader_texture_lod: enable\n\n';
			}
		}

		shader = createShaderFromCode(device, vsCode, `${defines}\n${shaderChunks.reprojectPS}`, shaderKey, false, extensions);
	}

	const constantSource = device.scope.resolve(source.cubemap ? "sourceCube" : "sourceTex");
	constantSource.setValue(source);
	const constantParams = device.scope.resolve("params");
	const constantParams2 = device.scope.resolve("params2");
	const uvModParam = device.scope.resolve("uvMod");

	if ((_options = options) != null && _options.seamPixels) {
		const p = options.seamPixels;
		const w = options.rect ? options.rect.z : target.width;
		const h = options.rect ? options.rect.w : target.height;
		const innerWidth = w - p * 2;
		const innerHeight = h - p * 2;
		uvModParam.setValue([(innerWidth + p * 2) / innerWidth, (innerHeight + p * 2) / innerHeight, -p / innerWidth, -p / innerHeight]);
	} else {
		uvModParam.setValue([1, 1, 0, 0]);
	}

	const params = [0, specularPower, source.fixCubemapSeams ? 1.0 / source.width : 0.0, target.fixCubemapSeams ? 1.0 / target.width : 0.0];
	const params2 = [target.width * target.height * (target.cubemap ? 6 : 1), source.width * source.height * (source.cubemap ? 6 : 1)];

	if (processFunc.startsWith('prefilterSamples')) {
		const sourceTotalPixels = source.width * source.height * (source.cubemap ? 6 : 1);
		const samplesTex = distribution === 'ggx' ? generateGGXSamplesTex(device, numSamples, specularPower, sourceTotalPixels) : distribution === 'lambert' ? generateLambertSamplesTex(device, numSamples, sourceTotalPixels) : generatePhongSamplesTex(device, numSamples, specularPower);
		device.scope.resolve("samplesTex").setValue(samplesTex);
		device.scope.resolve("samplesTexInverseSize").setValue([1.0 / samplesTex.width, 1.0 / samplesTex.height]);
	}

	for (let f = 0; f < (target.cubemap ? 6 : 1); f++) {
		if (face === null || f === face) {
			var _options2;

			const renderTarget = new RenderTarget({
				colorBuffer: target,
				face: f,
				depth: false
			});
			params[0] = f;
			constantParams.setValue(params);
			constantParams2.setValue(params2);
			drawQuadWithShader(device, renderTarget, shader, (_options2 = options) == null ? void 0 : _options2.rect);
			renderTarget.destroy();
		}
	}
}

const fixCubemapSeams = true;

const calcLevels = (width, height) => {
	return 1 + Math.floor(Math.log2(Math.max(width, height)));
};

const supportsFloat16 = device => {
	return device.extTextureHalfFloat && device.textureHalfFloatRenderable;
};

const supportsFloat32 = device => {
	return device.extTextureFloat && device.textureFloatRenderable;
};

const lightingSourcePixelFormat = device => {
	return supportsFloat16(device) ? PIXELFORMAT_RGBA16F : supportsFloat32(device) ? PIXELFORMAT_RGBA32F : PIXELFORMAT_R8_G8_B8_A8;
};

const lightingPixelFormat = device => {
	return PIXELFORMAT_R8_G8_B8_A8;
};

const createCubemap = (device, size, format, mipmaps) => {
	return new Texture(device, {
		name: `lighting-${size}`,
		cubemap: true,
		width: size,
		height: size,
		format: format,
		type: format === PIXELFORMAT_R8_G8_B8_A8 ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT,
		addressU: ADDRESS_CLAMP_TO_EDGE,
		addressV: ADDRESS_CLAMP_TO_EDGE,
		fixCubemapSeams: fixCubemapSeams,
		mipmaps: !!mipmaps
	});
};

class EnvLighting {
	static generateSkyboxCubemap(source, size) {
		const device = source.device;
		const result = createCubemap(device, size || (source.cubemap ? source.width : source.width / 4), PIXELFORMAT_R8_G8_B8_A8, false);
		reprojectTexture(source, result, {
			numSamples: 1024
		});
		return result;
	}

	static generateLightingSource(source) {
		const device = source.device;
		const format = lightingSourcePixelFormat(device);
		const result = new Texture(device, {
			name: `lighting-source`,
			cubemap: true,
			width: 128,
			height: 128,
			format: format,
			type: format === PIXELFORMAT_R8_G8_B8_A8 ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT,
			addressU: ADDRESS_CLAMP_TO_EDGE,
			addressV: ADDRESS_CLAMP_TO_EDGE,
			fixCubemapSeams: false,
			mipmaps: true
		});
		reprojectTexture(source, result, {
			numSamples: source.mipmaps ? 1 : 1024
		});
		return result;
	}

	static generateAtlas(source, options) {
		const device = source.device;
		const format = lightingPixelFormat();
		const result = (options == null ? void 0 : options.target) || new Texture(device, {
			width: 512,
			height: 512,
			format: format,
			type: TEXTURETYPE_RGBM ,
			projection: TEXTUREPROJECTION_EQUIRECT,
			addressU: ADDRESS_CLAMP_TO_EDGE,
			addressV: ADDRESS_CLAMP_TO_EDGE,
			mipmaps: false
		});
		const rect = new Vec4(0, 0, 512, 256);
		const levels = calcLevels(result.width, result.height);

		for (let i = 0; i < levels; ++i) {
			reprojectTexture(source, result, {
				numSamples: 1,
				rect: rect,
				seamPixels: 1
			});
			rect.x += rect.w;
			rect.y += rect.w;
			rect.z = Math.max(1, Math.floor(rect.z * 0.5));
			rect.w = Math.max(1, Math.floor(rect.w * 0.5));
		}

		rect.set(0, 256, 256, 128);

		for (let i = 1; i < 7; ++i) {
			reprojectTexture(source, result, {
				numSamples: (options == null ? void 0 : options.numSamples) || 1024,
				distribution: (options == null ? void 0 : options.distribution) || 'ggx',
				specularPower: Math.max(1, 2048 >> i * 2),
				rect: rect,
				seamPixels: 1
			});
			rect.y += rect.w;
			rect.z = Math.max(1, Math.floor(rect.z * 0.5));
			rect.w = Math.max(1, Math.floor(rect.w * 0.5));
		}

		rect.set(128, 256 + 128, 64, 32);
		reprojectTexture(source, result, {
			numSamples: (options == null ? void 0 : options.numSamples) || 2048,
			distribution: 'lambert',
			rect: rect,
			seamPixels: 1
		});
		return result;
	}

	static generatePrefilteredAtlas(sources, options) {
		const device = sources[0].device;
		const format = lightingPixelFormat();
		const result = (options == null ? void 0 : options.target) || new Texture(device, {
			width: 512,
			height: 512,
			format: format,
			type: TEXTURETYPE_RGBM ,
			projection: TEXTUREPROJECTION_EQUIRECT,
			addressU: ADDRESS_CLAMP_TO_EDGE,
			addressV: ADDRESS_CLAMP_TO_EDGE,
			mipmaps: false
		});
		const rect = new Vec4(0, 0, 512, 256);
		const levels = calcLevels(result.width, result.height);

		for (let i = 0; i < levels; ++i) {
			reprojectTexture(sources[0], result, {
				numSamples: 1,
				rect: rect,
				seamPixels: 1
			});
			rect.x += rect.w;
			rect.y += rect.w;
			rect.z = Math.max(1, Math.floor(rect.z * 0.5));
			rect.w = Math.max(1, Math.floor(rect.w * 0.5));
		}

		rect.set(0, 256, 256, 128);

		for (let i = 1; i < sources.length; ++i) {
			reprojectTexture(sources[i], result, {
				numSamples: 1,
				rect: rect,
				seamPixels: 1
			});
			rect.y += rect.w;
			rect.z = Math.max(1, Math.floor(rect.z * 0.5));
			rect.w = Math.max(1, Math.floor(rect.w * 0.5));
		}

		rect.set(128, 256 + 128, 64, 32);

		if (options != null && options.legacyAmbient) {
			reprojectTexture(sources[5], result, {
				numSamples: 1,
				rect: rect,
				seamPixels: 1
			});
		} else {
			reprojectTexture(sources[0], result, {
				numSamples: (options == null ? void 0 : options.numSamples) || 2048,
				distribution: 'lambert',
				rect: rect,
				seamPixels: 1
			});
		}

		return result;
	}

}

const defaultMaterialDeviceCache = new DeviceCache();

function getDefaultMaterial(device) {
	return defaultMaterialDeviceCache.get(device);
}

function setDefaultMaterial(device, material) {
	defaultMaterialDeviceCache.get(device, () => {
		return material;
	});
}

let id$2 = 0;

class Material {
	constructor() {
		this.name = "Untitled";
		this.id = id$2++;
		this._shader = null;
		this.variants = {};
		this.parameters = {};
		this.alphaTest = 0;
		this.alphaToCoverage = false;
		this.blend = false;
		this.blendSrc = BLENDMODE_ONE;
		this.blendDst = BLENDMODE_ZERO;
		this.blendEquation = BLENDEQUATION_ADD;
		this.separateAlphaBlend = false;
		this.blendSrcAlpha = BLENDMODE_ONE;
		this.blendDstAlpha = BLENDMODE_ZERO;
		this.blendAlphaEquation = BLENDEQUATION_ADD;
		this.cull = CULLFACE_BACK;
		this.depthTest = true;
		this.depthWrite = true;
		this.stencilFront = null;
		this.stencilBack = null;
		this.depthBias = 0;
		this.slopeDepthBias = 0;
		this.redWrite = true;
		this.greenWrite = true;
		this.blueWrite = true;
		this.alphaWrite = true;
		this.meshInstances = [];
		this._shaderVersion = 0;
		this._scene = null;
		this._dirtyBlend = false;
		this.dirty = true;
	}

	set shader(shader) {
		this._shader = shader;
	}

	get shader() {
		return this._shader;
	}

	get transparent() {
		return this.blend || this.blendSrc !== BLENDMODE_ONE || this.blendDst !== BLENDMODE_ZERO || this.blendEquation !== BLENDEQUATION_ADD;
	}

	set blendType(type) {
		const prevBlend = this.blend;

		switch (type) {
			case BLEND_NONE:
				this.blend = false;
				this.blendSrc = BLENDMODE_ONE;
				this.blendDst = BLENDMODE_ZERO;
				this.blendEquation = BLENDEQUATION_ADD;
				break;

			case BLEND_NORMAL:
				this.blend = true;
				this.blendSrc = BLENDMODE_SRC_ALPHA;
				this.blendDst = BLENDMODE_ONE_MINUS_SRC_ALPHA;
				this.blendEquation = BLENDEQUATION_ADD;
				break;

			case BLEND_PREMULTIPLIED:
				this.blend = true;
				this.blendSrc = BLENDMODE_ONE;
				this.blendDst = BLENDMODE_ONE_MINUS_SRC_ALPHA;
				this.blendEquation = BLENDEQUATION_ADD;
				break;

			case BLEND_ADDITIVE:
				this.blend = true;
				this.blendSrc = BLENDMODE_ONE;
				this.blendDst = BLENDMODE_ONE;
				this.blendEquation = BLENDEQUATION_ADD;
				break;

			case BLEND_ADDITIVEALPHA:
				this.blend = true;
				this.blendSrc = BLENDMODE_SRC_ALPHA;
				this.blendDst = BLENDMODE_ONE;
				this.blendEquation = BLENDEQUATION_ADD;
				break;

			case BLEND_MULTIPLICATIVE2X:
				this.blend = true;
				this.blendSrc = BLENDMODE_DST_COLOR;
				this.blendDst = BLENDMODE_SRC_COLOR;
				this.blendEquation = BLENDEQUATION_ADD;
				break;

			case BLEND_SCREEN:
				this.blend = true;
				this.blendSrc = BLENDMODE_ONE_MINUS_DST_COLOR;
				this.blendDst = BLENDMODE_ONE;
				this.blendEquation = BLENDEQUATION_ADD;
				break;

			case BLEND_MULTIPLICATIVE:
				this.blend = true;
				this.blendSrc = BLENDMODE_DST_COLOR;
				this.blendDst = BLENDMODE_ZERO;
				this.blendEquation = BLENDEQUATION_ADD;
				break;

			case BLEND_MIN:
				this.blend = true;
				this.blendSrc = BLENDMODE_ONE;
				this.blendDst = BLENDMODE_ONE;
				this.blendEquation = BLENDEQUATION_MIN;
				break;

			case BLEND_MAX:
				this.blend = true;
				this.blendSrc = BLENDMODE_ONE;
				this.blendDst = BLENDMODE_ONE;
				this.blendEquation = BLENDEQUATION_MAX;
				break;
		}

		if (prevBlend !== this.blend) {
			if (this._scene) {
				this._scene.layers._dirtyBlend = true;
			} else {
				this._dirtyBlend = true;
			}
		}

		this._updateMeshInstanceKeys();
	}

	get blendType() {
		if (!this.transparent) {
			return BLEND_NONE;
		} else if (this.blend && this.blendSrc === BLENDMODE_SRC_ALPHA && this.blendDst === BLENDMODE_ONE_MINUS_SRC_ALPHA && this.blendEquation === BLENDEQUATION_ADD) {
			return BLEND_NORMAL;
		} else if (this.blend && this.blendSrc === BLENDMODE_ONE && this.blendDst === BLENDMODE_ONE && this.blendEquation === BLENDEQUATION_ADD) {
			return BLEND_ADDITIVE;
		} else if (this.blend && this.blendSrc === BLENDMODE_SRC_ALPHA && this.blendDst === BLENDMODE_ONE && this.blendEquation === BLENDEQUATION_ADD) {
			return BLEND_ADDITIVEALPHA;
		} else if (this.blend && this.blendSrc === BLENDMODE_DST_COLOR && this.blendDst === BLENDMODE_SRC_COLOR && this.blendEquation === BLENDEQUATION_ADD) {
			return BLEND_MULTIPLICATIVE2X;
		} else if (this.blend && this.blendSrc === BLENDMODE_ONE_MINUS_DST_COLOR && this.blendDst === BLENDMODE_ONE && this.blendEquation === BLENDEQUATION_ADD) {
			return BLEND_SCREEN;
		} else if (this.blend && this.blendSrc === BLENDMODE_ONE && this.blendDst === BLENDMODE_ONE && this.blendEquation === BLENDEQUATION_MIN) {
			return BLEND_MIN;
		} else if (this.blend && this.blendSrc === BLENDMODE_ONE && this.blendDst === BLENDMODE_ONE && this.blendEquation === BLENDEQUATION_MAX) {
			return BLEND_MAX;
		} else if (this.blend && this.blendSrc === BLENDMODE_DST_COLOR && this.blendDst === BLENDMODE_ZERO && this.blendEquation === BLENDEQUATION_ADD) {
			return BLEND_MULTIPLICATIVE;
		} else if (this.blend && this.blendSrc === BLENDMODE_ONE && this.blendDst === BLENDMODE_ONE_MINUS_SRC_ALPHA && this.blendEquation === BLENDEQUATION_ADD) {
			return BLEND_PREMULTIPLIED;
		}

		return BLEND_NORMAL;
	}

	copy(source) {
		this.name = source.name;
		this.shader = source.shader;
		this.alphaTest = source.alphaTest;
		this.alphaToCoverage = source.alphaToCoverage;
		this.blend = source.blend;
		this.blendSrc = source.blendSrc;
		this.blendDst = source.blendDst;
		this.blendEquation = source.blendEquation;
		this.separateAlphaBlend = source.separateAlphaBlend;
		this.blendSrcAlpha = source.blendSrcAlpha;
		this.blendDstAlpha = source.blendDstAlpha;
		this.blendAlphaEquation = source.blendAlphaEquation;
		this.cull = source.cull;
		this.depthTest = source.depthTest;
		this.depthWrite = source.depthWrite;
		this.depthBias = source.depthBias;
		this.slopeDepthBias = source.slopeDepthBias;
		if (source.stencilFront) this.stencilFront = source.stencilFront.clone();

		if (source.stencilBack) {
			if (source.stencilFront === source.stencilBack) {
				this.stencilBack = this.stencilFront;
			} else {
				this.stencilBack = source.stencilBack.clone();
			}
		}

		this.redWrite = source.redWrite;
		this.greenWrite = source.greenWrite;
		this.blueWrite = source.blueWrite;
		this.alphaWrite = source.alphaWrite;
		return this;
	}

	clone() {
		const clone = new this.constructor();
		return clone.copy(this);
	}

	_updateMeshInstanceKeys() {
		const meshInstances = this.meshInstances;

		for (let i = 0; i < meshInstances.length; i++) {
			meshInstances[i].updateKey();
		}
	}

	updateUniforms(device, scene) {}

	updateShader(device, scene, objDefs, staticLightList, pass, sortedLights) {}

	update() {
		this.dirty = true;
		if (this._shader) this._shader.failed = false;
	}

	clearParameters() {
		this.parameters = {};
	}

	getParameters() {
		return this.parameters;
	}

	clearVariants() {
		this.variants = {};

		for (let i = 0; i < this.meshInstances.length; i++) {
			const meshInstance = this.meshInstances[i];

			for (let j = 0; j < meshInstance._shader.length; j++) {
				meshInstance._shader[j] = null;
			}
		}
	}

	getParameter(name) {
		return this.parameters[name];
	}

	setParameter(name, data) {
		if (data === undefined && typeof name === 'object') {
			const uniformObject = name;

			if (uniformObject.length) {
				for (let i = 0; i < uniformObject.length; i++) {
					this.setParameter(uniformObject[i]);
				}

				return;
			}

			name = uniformObject.name;
			data = uniformObject.value;
		}

		const param = this.parameters[name];

		if (param) {
			param.data = data;
		} else {
			this.parameters[name] = {
				scopeId: null,
				data: data
			};
		}
	}

	deleteParameter(name) {
		if (this.parameters[name]) {
			delete this.parameters[name];
		}
	}

	setParameters(device, names) {
		const parameters = this.parameters;
		if (names === undefined) names = parameters;

		for (const paramName in names) {
			const parameter = parameters[paramName];

			if (parameter) {
				if (!parameter.scopeId) {
					parameter.scopeId = device.scope.resolve(paramName);
				}

				parameter.scopeId.setValue(parameter.data);
			}
		}
	}

	destroy() {
		this.variants = {};
		this.shader = null;

		for (let i = 0; i < this.meshInstances.length; i++) {
			const meshInstance = this.meshInstances[i];

			for (let j = 0; j < meshInstance._shader.length; j++) {
				meshInstance._shader[j] = null;
			}

			meshInstance._material = null;

			if (meshInstance.mesh) {
				const defaultMaterial = getDefaultMaterial(meshInstance.mesh.device);

				if (this !== defaultMaterial) {
					meshInstance.material = defaultMaterial;
				}
			}
		}
	}

	addMeshInstanceRef(meshInstance) {
		this.meshInstances.push(meshInstance);
	}

	removeMeshInstanceRef(meshInstance) {
		const meshInstances = this.meshInstances;
		const i = meshInstances.indexOf(meshInstance);

		if (i !== -1) {
			meshInstances.splice(i, 1);
		}
	}

}

const arraysEqual = (a, b) => {
	if (a.length !== b.length) {
		return false;
	}

	for (let i = 0; i < a.length; ++i) {
		if (a[i] !== b[i]) {
			return false;
		}
	}

	return true;
};

const notWhite = color => {
	return color.r !== 1 || color.g !== 1 || color.b !== 1;
};

const notBlack = color => {
	return color.r !== 0 || color.g !== 0 || color.b !== 0;
};

class StandardMaterialOptionsBuilder {
	constructor() {
		this._mapXForms = null;
	}

	updateMinRef(options, device, scene, stdMat, objDefs, staticLightList, pass, sortedLights) {
		this._updateSharedOptions(options, scene, stdMat, objDefs, pass);

		this._updateMinOptions(options, stdMat);

		this._updateUVOptions(options, stdMat, objDefs, true);
	}

	updateRef(options, device, scene, stdMat, objDefs, staticLightList, pass, sortedLights) {
		this._updateSharedOptions(options, scene, stdMat, objDefs, pass);

		this._updateEnvOptions(options, device, stdMat, scene);

		this._updateMaterialOptions(options, stdMat);

		if (pass === SHADER_FORWARDHDR) {
			if (options.gamma) options.gamma = GAMMA_SRGBHDR;
			options.toneMap = TONEMAP_LINEAR;
		}

		options.hasTangents = objDefs && stdMat.normalMap && (objDefs & SHADERDEF_TANGENTS) !== 0;

		this._updateLightOptions(options, stdMat, objDefs, sortedLights, staticLightList);

		this._updateUVOptions(options, stdMat, objDefs, false);
	}

	_updateSharedOptions(options, scene, stdMat, objDefs, pass) {
		options.pass = pass;
		options.alphaTest = stdMat.alphaTest > 0;
		options.forceFragmentPrecision = stdMat.forceFragmentPrecision || "";
		options.chunks = stdMat.chunks || "";
		options.blendType = stdMat.blendType;
		options.forceUv1 = stdMat.forceUv1;
		options.separateAmbient = false;
		options.screenSpace = objDefs && (objDefs & SHADERDEF_SCREENSPACE) !== 0;
		options.skin = objDefs && (objDefs & SHADERDEF_SKIN) !== 0;
		options.useInstancing = objDefs && (objDefs & SHADERDEF_INSTANCING) !== 0;
		options.useMorphPosition = objDefs && (objDefs & SHADERDEF_MORPH_POSITION) !== 0;
		options.useMorphNormal = objDefs && (objDefs & SHADERDEF_MORPH_NORMAL) !== 0;
		options.useMorphTextureBased = objDefs && (objDefs & SHADERDEF_MORPH_TEXTURE_BASED) !== 0;
		options.nineSlicedMode = stdMat.nineSlicedMode || 0;

		if (scene.clusteredLightingEnabled) {
			options.clusteredLightingEnabled = true;
			options.clusteredLightingCookiesEnabled = scene.lighting.cookiesEnabled;
			options.clusteredLightingShadowsEnabled = scene.lighting.shadowsEnabled;
			options.clusteredLightingShadowType = scene.lighting.shadowType;
			options.clusteredLightingAreaLightsEnabled = scene.lighting.areaLightsEnabled;
		}
	}

	_updateUVOptions(options, stdMat, objDefs, minimalOptions) {
		let hasUv0 = false;
		let hasUv1 = false;
		let hasVcolor = false;

		if (objDefs) {
			hasUv0 = (objDefs & SHADERDEF_UV0) !== 0;
			hasUv1 = (objDefs & SHADERDEF_UV1) !== 0;
			hasVcolor = (objDefs & SHADERDEF_VCOLOR) !== 0;
		}

		options.vertexColors = false;
		this._mapXForms = [];

		for (const p in _matTex2D) {
			this._updateTexOptions(options, stdMat, p, hasUv0, hasUv1, hasVcolor, minimalOptions);
		}

		this._mapXForms = null;
	}

	_updateMinOptions(options, stdMat) {
		options.opacityTint = stdMat.opacity !== 1 && stdMat.blendType !== BLEND_NONE;
		options.lights = [];
	}

	_updateMaterialOptions(options, stdMat) {
		const diffuseTint = (stdMat.diffuseTint || !stdMat.diffuseMap && !stdMat.diffuseVertexColor) && notWhite(stdMat.diffuse);
		const useSpecular = !!(stdMat.useMetalness || stdMat.specularMap || stdMat.sphereMap || stdMat.cubeMap || notBlack(stdMat.specular) || stdMat.enableGGXSpecular || stdMat.clearCoat > 0);
		const specularTint = useSpecular && !stdMat.useMetalness && (stdMat.specularTint || !stdMat.specularMap && !stdMat.specularVertexColor) && notWhite(stdMat.specular);
		const emissiveTintColor = !stdMat.emissiveMap || notWhite(stdMat.emissive) && stdMat.emissiveTint;
		const emissiveTintIntensity = stdMat.emissiveIntensity !== 1;
		const isPackedNormalMap = stdMat.normalMap ? stdMat.normalMap.format === PIXELFORMAT_DXT5 || stdMat.normalMap.type === TEXTURETYPE_SWIZZLEGGGR : false;
		options.opacityTint = stdMat.opacity !== 1 && stdMat.blendType !== BLEND_NONE ? 1 : 0;
		options.blendMapsWithColors = true;
		options.ambientTint = stdMat.ambientTint;
		options.diffuseTint = diffuseTint ? 2 : 0;
		options.specularTint = specularTint ? 2 : 0;
		options.metalnessTint = stdMat.useMetalness && stdMat.metalness < 1 ? 1 : 0;
		options.glossTint = 1;
		options.emissiveTint = (emissiveTintColor ? 2 : 0) + (emissiveTintIntensity ? 1 : 0);
		options.alphaToCoverage = stdMat.alphaToCoverage;
		options.normalizeNormalMap = stdMat.normalizeNormalMap;
		options.ambientSH = !!stdMat.ambientSH;
		options.useSpecular = useSpecular;
		options.emissiveFormat = stdMat.emissiveMap ? stdMat.emissiveMap.type === TEXTURETYPE_RGBM ? 1 : stdMat.emissiveMap.format === PIXELFORMAT_RGBA32F ? 2 : 0 : null;
		options.lightMapFormat = stdMat.lightMap ? stdMat.lightMap.type === TEXTURETYPE_RGBM ? 1 : stdMat.lightMap.format === PIXELFORMAT_RGBA32F ? 2 : 0 : null;
		options.specularAntialias = stdMat.specularAntialias && !!stdMat.normalMap && !!stdMat.normalMap.mipmaps && !isPackedNormalMap;
		options.conserveEnergy = stdMat.conserveEnergy;
		options.opacityFadesSpecular = stdMat.opacityFadesSpecular;
		options.alphaFade = stdMat.alphaFade;
		options.occludeSpecular = stdMat.occludeSpecular;
		options.occludeSpecularFloat = stdMat.occludeSpecularIntensity !== 1.0;
		options.occludeDirect = stdMat.occludeDirect;
		options.shadingModel = stdMat.shadingModel;
		options.fresnelModel = stdMat.fresnelModel;
		options.packedNormal = isPackedNormalMap;
		options.fastTbn = stdMat.fastTbn;
		options.cubeMapProjection = stdMat.cubeMapProjection;
		options.customFragmentShader = stdMat.customFragmentShader;
		options.refraction = !!stdMat.refraction;
		options.useMetalness = stdMat.useMetalness;
		options.enableGGXSpecular = stdMat.enableGGXSpecular;
		options.msdf = !!stdMat.msdfMap;
		options.twoSidedLighting = stdMat.twoSidedLighting;
		options.pixelSnap = stdMat.pixelSnap;
		options.aoMapUv = stdMat.aoUvSet;
		options.diffuseDetail = !!stdMat.diffuseMap;
		options.normalDetail = !!stdMat.normalMap;
		options.diffuseDetailMode = stdMat.diffuseDetailMode;
		options.detailModes = !!options.diffuseDetail;
		options.clearCoat = !!stdMat.clearCoat;
		options.clearCoatTint = stdMat.clearCoat !== 1.0 ? 1 : 0;
		options.clearCoatGlossiness = !!stdMat.clearCoatGlossiness;
		options.clearCoatGlossTint = stdMat.clearCoatGlossiness !== 1.0 ? 1 : 0;
	}

	_updateEnvOptions(options, device, stdMat, scene) {
		options.fog = stdMat.useFog ? scene.fog : "none";
		options.gamma = stdMat.useGammaTonemap ? scene.gammaCorrection : GAMMA_NONE;
		options.toneMap = stdMat.useGammaTonemap ? scene.toneMapping : -1;
		options.useRgbm = stdMat.emissiveMap && stdMat.emissiveMap.type === TEXTURETYPE_RGBM || stdMat.lightMap && stdMat.lightMap.type === TEXTURETYPE_RGBM;
		options.fixSeams = stdMat.cubeMap ? stdMat.cubeMap.fixCubemapSeams : false;
		const isPhong = stdMat.shadingModel === SPECULAR_PHONG;
		let usingSceneEnv = false;

		if (stdMat.envAtlas && !isPhong) {
			options.reflectionSource = 'envAtlas';
			options.reflectionEncoding = stdMat.envAtlas.encoding;
		} else if (stdMat.cubeMap) {
			options.reflectionSource = 'cubeMap';
			options.reflectionEncoding = stdMat.cubeMap.encoding;
		} else if (stdMat.sphereMap) {
			options.reflectionSource = 'sphereMap';
			options.reflectionEncoding = stdMat.sphereMap.encoding;
		} else if (stdMat.useSkybox && scene.envAtlas && !isPhong) {
			options.reflectionSource = 'envAtlas';
			options.reflectionEncoding = scene.envAtlas.encoding;
			usingSceneEnv = true;
		} else {
			options.reflectionSource = null;
			options.reflectionEncoding = null;
		}

		if (stdMat.ambientSH && !isPhong) {
			options.ambientSource = 'ambientSH';
			options.ambientEncoding = null;
		} else {
			const envAtlas = stdMat.envAtlas || (stdMat.useSkybox && scene.envAtlas ? scene.envAtlas : null);

			if (envAtlas && !isPhong) {
				options.ambientSource = 'envAtlas';
				options.ambientEncoding = envAtlas.encoding;
			} else {
				options.ambientSource = 'constant';
				options.ambientEncoding = null;
			}
		}

		options.skyboxIntensity = usingSceneEnv && scene.skyboxIntensity !== 1;
		options.useCubeMapRotation = usingSceneEnv && scene.skyboxRotation && !scene.skyboxRotation.equals(Quat.IDENTITY);
	}

	_updateLightOptions(options, stdMat, objDefs, sortedLights, staticLightList) {
		options.lightMap = false;
		options.lightMapChannel = "";
		options.lightMapUv = 0;
		options.lightMapTransform = 0;
		options.lightMapWithoutAmbient = false;
		options.dirLightMap = false;

		if (objDefs) {
			options.noShadow = (objDefs & SHADERDEF_NOSHADOW) !== 0;

			if ((objDefs & SHADERDEF_LM) !== 0) {
				options.lightMapFormat = 1;
				options.lightMap = true;
				options.lightMapChannel = "rgb";
				options.lightMapUv = 1;
				options.lightMapTransform = 0;
				options.lightMapWithoutAmbient = !stdMat.lightMap;
				options.useRgbm = true;

				if ((objDefs & SHADERDEF_DIRLM) !== 0) {
					options.dirLightMap = true;
				}

				if ((objDefs & SHADERDEF_LMAMBIENT) !== 0) {
					options.lightMapWithoutAmbient = false;
				}
			}
		}

		if (stdMat.useLighting) {
			const lightsFiltered = [];
			const mask = objDefs ? objDefs >> 16 : MASK_AFFECT_DYNAMIC;
			options.lightMaskDynamic = !!(mask & MASK_AFFECT_DYNAMIC);

			if (sortedLights) {
				this._collectLights(LIGHTTYPE_DIRECTIONAL, sortedLights[LIGHTTYPE_DIRECTIONAL], lightsFiltered, mask);

				this._collectLights(LIGHTTYPE_OMNI, sortedLights[LIGHTTYPE_OMNI], lightsFiltered, mask, staticLightList);

				this._collectLights(LIGHTTYPE_SPOT, sortedLights[LIGHTTYPE_SPOT], lightsFiltered, mask, staticLightList);
			}

			options.lights = lightsFiltered;
		} else {
			options.lights = [];
		}

		if (options.lights.length === 0) {
			options.noShadow = true;
		}
	}

	_updateTexOptions(options, stdMat, p, hasUv0, hasUv1, hasVcolor, minimalOptions) {
		const mname = p + "Map";
		const vname = p + "VertexColor";
		const vcname = p + "VertexColorChannel";
		const cname = mname + "Channel";
		const tname = mname + "Transform";
		const uname = mname + "Uv";

		if (p !== "light") {
			options[mname] = false;
			options[cname] = "";
			options[tname] = 0;
			options[uname] = 0;
		}

		options[vname] = false;
		options[vcname] = "";
		const isOpacity = p === "opacity";
		if (isOpacity && stdMat.blendType === BLEND_NONE && stdMat.alphaTest === 0.0 && !stdMat.alphaToCoverage) return options;

		if (!minimalOptions || isOpacity) {
			if (p !== "height" && stdMat[vname]) {
				if (hasVcolor) {
					options[vname] = stdMat[vname];
					options[vcname] = stdMat[vcname];
					options.vertexColors = true;
				}
			}

			if (stdMat[mname]) {
				let allow = true;
				if (stdMat[uname] === 0 && !hasUv0) allow = false;
				if (stdMat[uname] === 1 && !hasUv1) allow = false;

				if (allow) {
					options[mname] = !!stdMat[mname];
					options[tname] = this._getMapTransformID(stdMat.getUniform(tname), stdMat[uname]);
					options[cname] = stdMat[cname];
					options[uname] = stdMat[uname];
				}
			}
		}
	}

	_collectLights(lType, lights, lightsFiltered, mask, staticLightList) {
		for (let i = 0; i < lights.length; i++) {
			const light = lights[i];

			if (light.enabled) {
				if (light.mask & mask) {
					if (lType !== LIGHTTYPE_DIRECTIONAL) {
						if (light.isStatic) {
							continue;
						}
					}

					lightsFiltered.push(light);
				}
			}
		}

		if (staticLightList) {
			for (let i = 0; i < staticLightList.length; i++) {
				const light = staticLightList[i];

				if (light._type === lType) {
					lightsFiltered.push(light);
				}
			}
		}
	}

	_getMapTransformID(xform, uv) {
		if (!xform) return 0;
		let xforms = this._mapXForms[uv];

		if (!xforms) {
			xforms = [];
			this._mapXForms[uv] = xforms;
		}

		for (let i = 0; i < xforms.length; i++) {
			if (arraysEqual(xforms[i][0].value, xform[0].value) && arraysEqual(xforms[i][1].value, xform[1].value)) {
				return i + 1;
			}
		}

		return xforms.push(xform);
	}

}

const standardMaterialParameterTypes = {
	name: 'string',
	chunks: 'chunks',
	mappingFormat: 'string',
	_engine: 'boolean',
	ambient: 'rgb',
	ambientTint: 'boolean',
	aoVertexColor: 'boolean',
	aoVertexColorChannel: 'string',
	aoMap: 'texture',
	aoMapChannel: 'string',
	aoMapUv: 'number',
	aoMapTiling: 'vec2',
	aoMapOffset: 'vec2',
	aoMapRotation: 'number',
	diffuse: 'rgb',
	diffuseTint: 'boolean',
	diffuseVertexColor: 'boolean',
	diffuseVertexColorChannel: 'string',
	diffuseMap: 'texture',
	diffuseMapChannel: 'string',
	diffuseMapUv: 'number',
	diffuseMapTiling: 'vec2',
	diffuseMapOffset: 'vec2',
	diffuseMapRotation: 'number',
	diffuseDetailMap: 'texture',
	diffuseDetailMapChannel: 'string',
	diffuseDetailMapUv: 'number',
	diffuseDetailMapTiling: 'vec2',
	diffuseDetailMapOffset: 'vec2',
	diffuseDetailMapRotation: 'number',
	diffuseDetailMode: 'string',
	specular: 'rgb',
	specularTint: 'boolean',
	specularVertexColor: 'boolean',
	specularVertexColorChannel: 'string',
	specularMap: 'texture',
	specularMapChannel: 'string',
	specularMapUv: 'number',
	specularMapTiling: 'vec2',
	specularMapOffset: 'vec2',
	specularMapRotation: 'number',
	specularAntialias: 'boolean',
	occludeSpecular: 'enum:occludeSpecular',
	useMetalness: 'boolean',
	metalness: 'number',
	enableGGXSpecular: 'boolean',
	anisotropy: 'number',
	metalnessTint: 'boolean',
	metalnessVertexColor: 'boolean',
	metalnessVertexColorChannel: 'string',
	metalnessMap: 'texture',
	metalnessMapChannel: 'string',
	metalnessMapUv: 'number',
	metalnessMapTiling: 'vec2',
	metalnessMapOffset: 'vec2',
	netalnessMapRotation: 'number',
	conserveEnergy: 'boolean',
	shininess: 'number',
	glossVertexColor: 'boolean',
	glossVertexColorChannel: 'string',
	glossMap: 'texture',
	glossMapChannel: 'string',
	glossMapUv: 'number',
	glossMapTiling: 'vec2',
	glossMapOffset: 'vec2',
	glossMapRotation: 'number',
	clearCoat: 'number',
	clearCoatVertexColor: 'boolean',
	clearCoatVertexColorChannel: 'string',
	clearCoatMap: 'texture',
	clearCoatMapChannel: 'string',
	clearCoatMapUv: 'number',
	clearCoatMapTiling: 'vec2',
	clearCoatMapOffset: 'vec2',
	clearCoatMapRotation: 'number',
	clearCoatGlossiness: 'number',
	clearCoatGlossVertexColor: 'boolean',
	clearCoatGlossVertexColorChannel: 'string',
	clearCoatGlossMap: 'texture',
	clearCoatGlossMapChannel: 'string',
	clearCoatGlossMapUv: 'number',
	clearCoatGlossMapTiling: 'vec2',
	clearCoatGlossMapOffset: 'vec2',
	clearCoatGlossMapRotation: 'number',
	clearCoatBumpiness: 'number',
	clearCoatNormalMap: 'texture',
	clearCoatNormalMapUv: 'number',
	clearCoatNormalMapTiling: 'vec2',
	clearCoatNormalMapOffset: 'vec2',
	clearCoatNormalMapRotation: 'number',
	fresnelModel: 'number',
	emissive: 'rgb',
	emissiveTint: 'boolean',
	emissiveVertexColor: 'boolean',
	emissiveVertexColorChannel: 'string',
	emissiveMap: 'texture',
	emissiveMapChannel: 'string',
	emissiveMapUv: 'number',
	emissiveMapTiling: 'vec2',
	emissiveMapOffset: 'vec2',
	emissiveMapMapRotation: 'number',
	emissiveIntensity: 'number',
	normalMap: 'texture',
	normalMapTiling: 'vec2',
	normalMapOffset: 'vec2',
	normalMapRotation: 'number',
	normalMapUv: 'number',
	bumpiness: 'number',
	normalDetailMap: 'texture',
	normalDetailMapTiling: 'vec2',
	normalDetailMapOffset: 'vec2',
	normalDetailMapRotation: 'number',
	normalDetailMapUv: 'number',
	normalDetailMapBumpiness: 'number',
	heightMap: 'texture',
	heightMapChannel: 'string',
	heightMapUv: 'number',
	heightMapTiling: 'vec2',
	heightMapOffset: 'vec2',
	heightMapRotation: 'number',
	heightMapFactor: 'number',
	alphaToCoverage: 'boolean',
	alphaTest: 'number',
	alphaFade: 'number',
	opacity: 'number',
	opacityVertexColor: 'boolean',
	opacityVertexColorChannel: 'string',
	opacityMap: 'texture',
	opacityMapChannel: 'string',
	opacityMapUv: 'number',
	opacityMapTiling: 'vec2',
	opacityMapOffset: 'vec2',
	opacityMapRotation: 'number',
	opacityFadesSpecular: 'boolean',
	reflectivity: 'number',
	refraction: 'number',
	refractionIndex: 'number',
	sphereMap: 'texture',
	cubeMap: 'cubemap',
	cubeMapProjection: 'number',
	cubeMapProjectionBox: 'boundingbox',
	lightVertexColor: 'boolean',
	lightVertexColorChannel: 'string',
	lightMap: 'texture',
	lightMapChannel: 'string',
	lightMapUv: 'number',
	lightMapTiling: 'vec2',
	lightMapOffset: 'vec2',
	lightMapRotation: 'number',
	depthTest: 'boolean',
	depthWrite: 'boolean',
	depthBias: 'number',
	slopeDepthBias: 'number',
	cull: 'enum:cull',
	blendType: 'enum:blendType',
	shadingModel: 'enum:shadingModel',
	useFog: 'boolean',
	useLighting: 'boolean',
	useSkybox: 'boolean',
	useGammaTonemap: 'boolean',
	envAtlas: 'texture'
};
const standardMaterialTextureParameters = [];

for (const key in standardMaterialParameterTypes) {
	const type = standardMaterialParameterTypes[key];

	if (type === 'texture') {
		standardMaterialTextureParameters.push(key);
	}
}

const standardMaterialCubemapParameters = [];

for (const key in standardMaterialParameterTypes) {
	const type = standardMaterialParameterTypes[key];

	if (type === 'cubemap') {
		standardMaterialCubemapParameters.push(key);
	}
}

const _props = {};
const _uniforms = {};

let _params = new Set();

class StandardMaterial extends Material {
	constructor() {
		super();
		this._dirtyShader = true;
		this._assetReferences = {};
		this._activeParams = new Set();
		this._activeLightingParams = new Set();
		this.shaderOptBuilder = new StandardMaterialOptionsBuilder();
		this.reset();
	}

	reset() {
		Object.keys(_props).forEach(name => {
			this[`_${name}`] = _props[name].value();
		});
		this._chunks = {};
		this._uniformCache = {};
	}

	set chunks(value) {
		this._dirtyShader = true;
		this._chunks = value;
	}

	get chunks() {
		this._dirtyShader = true;
		return this._chunks;
	}

	copy(source) {
		super.copy(source);
		Object.keys(_props).forEach(k => {
			this[k] = source[k];
		});

		for (const p in source._chunks) {
			if (source._chunks.hasOwnProperty(p)) this._chunks[p] = source._chunks[p];
		}

		return this;
	}

	_setParameter(name, value) {
		_params.add(name);

		this.setParameter(name, value);
	}

	_setParameters(parameters) {
		parameters.forEach(v => {
			this._setParameter(v.name, v.value);
		});
	}

	_processParameters(paramsName) {
		const prevParams = this[paramsName];
		prevParams.forEach(param => {
			if (!_params.has(param)) {
				delete this.parameters[param];
			}
		});
		this[paramsName] = _params;
		_params = prevParams;

		_params.clear();
	}

	_updateMap(p) {
		const mname = p + "Map";
		const map = this[mname];

		if (map) {
			this._setParameter("texture_" + mname, map);

			const tname = mname + "Transform";
			const uniform = this.getUniform(tname);

			if (uniform) {
				this._setParameters(uniform);
			}
		}
	}

	_allocUniform(name, allocFunc) {
		let uniform = this._uniformCache[name];

		if (!uniform) {
			uniform = allocFunc();
			this._uniformCache[name] = uniform;
		}

		return uniform;
	}

	getUniform(name, device, scene) {
		return _uniforms[name](this, device, scene);
	}

	updateUniforms(device, scene) {
		const getUniform = name => {
			return this.getUniform(name, device, scene);
		};

		this._setParameter('material_ambient', getUniform('ambient'));

		if (!this.diffuseMap || this.diffuseTint) {
			this._setParameter('material_diffuse', getUniform('diffuse'));
		}

		if (!this.useMetalness) {
			if (!this.specularMap || this.specularTint) {
				this._setParameter('material_specular', getUniform('specular'));
			}
		} else {
			if (!this.metalnessMap || this.metalness < 1) {
				this._setParameter('material_metalness', this.metalness);
			}
		}

		if (this.enableGGXSpecular) {
			this._setParameter('material_anisotropy', this.anisotropy);
		}

		if (this.clearCoat > 0) {
			this._setParameter('material_clearCoat', this.clearCoat);

			this._setParameter('material_clearCoatGlossiness', this.clearCoatGlossiness);

			this._setParameter('material_clearCoatReflectivity', this.clearCoat);

			this._setParameter('material_clearCoatBumpiness', this.clearCoatBumpiness);
		}

		this._setParameter("material_shininess", getUniform('shininess'));

		if (!this.emissiveMap || this.emissiveTint) {
			this._setParameter('material_emissive', getUniform('emissive'));
		}

		if (this.emissiveIntensity !== 1) {
			this._setParameter('material_emissiveIntensity', this.emissiveIntensity);
		}

		if (this.refraction > 0) {
			this._setParameter('material_refraction', this.refraction);

			this._setParameter('material_refractionIndex', this.refractionIndex);
		}

		this._setParameter('material_opacity', this.opacity);

		if (this.opacityFadesSpecular === false) {
			this._setParameter('material_alphaFade', this.alphaFade);
		}

		if (this.occludeSpecular) {
			this._setParameter('material_occludeSpecularIntensity', this.occludeSpecularIntensity);
		}

		if (this.cubeMapProjection === CUBEPROJ_BOX) {
			this._setParameter(getUniform("cubeMapProjectionBox"));
		}

		for (const p in _matTex2D) {
			this._updateMap(p);
		}

		if (this.ambientSH) {
			this._setParameter('ambientSH[0]', this.ambientSH);
		}

		if (this.normalMap) {
			this._setParameter('material_bumpiness', this.bumpiness);
		}

		if (this.normalMap && this.normalDetailMap) {
			this._setParameter('material_normalDetailMapBumpiness', this.normalDetailMapBumpiness);
		}

		if (this.heightMap) {
			this._setParameter('material_heightMapFactor', getUniform('heightMapFactor'));
		}

		if (this.cubeMap) {
			this._setParameter('texture_cubeMap', this.cubeMap);
		}

		if (this.sphereMap) {
			this._setParameter('texture_sphereMap', this.sphereMap);
		}

		this._setParameter('material_reflectivity', this.reflectivity);

		this._processParameters('_activeParams');

		if (this._dirtyShader) {
			this.shader = null;
			this.clearVariants();
		}
	}

	updateEnvUniforms(device, scene) {
		const envAtlas = this.envAtlas || (this.useSkybox ? scene.envAtlas : null);

		if (envAtlas) {
			this._setParameter('texture_envAtlas', envAtlas);

			if (this.useSkybox && !scene.skyboxRotation.equals(Quat.IDENTITY) && scene._skyboxRotationMat3) {
				this._setParameter('cubeMapRotationMatrix', scene._skyboxRotationMat3.data);
			}
		}

		this._processParameters('_activeLightingParams');
	}

	updateShader(device, scene, objDefs, staticLightList, pass, sortedLights) {
		this.updateEnvUniforms(device, scene);
		const minimalOptions = pass > SHADER_FORWARDHDR && pass <= SHADER_PICK;
		let options = minimalOptions ? standard.optionsContextMin : standard.optionsContext;
		if (minimalOptions) this.shaderOptBuilder.updateMinRef(options, device, scene, this, objDefs, staticLightList, pass, sortedLights);else this.shaderOptBuilder.updateRef(options, device, scene, this, objDefs, staticLightList, pass, sortedLights);

		if (this.onUpdateShader) {
			options = this.onUpdateShader(options);
		}

		const library = device.getProgramLibrary();
		this.shader = library.getProgram('standard', options);

		if (!objDefs) {
			this.clearVariants();
			this.variants[0] = this.shader;
		}

		this._dirtyShader = false;
	}

	destroy() {
		for (const asset in this._assetReferences) {
			this._assetReferences[asset]._unbind();
		}

		this._assetReferences = null;
		super.destroy();
	}

}

StandardMaterial.TEXTURE_PARAMETERS = standardMaterialTextureParameters;
StandardMaterial.CUBEMAP_PARAMETERS = standardMaterialCubemapParameters;

const defineUniform = (name, getUniformFunc) => {
	_uniforms[name] = getUniformFunc;
};

const definePropInternal = (name, constructorFunc, setterFunc, getterFunc) => {
	Object.defineProperty(StandardMaterial.prototype, name, {
		get: getterFunc || function () {
			return this[`_${name}`];
		},
		set: setterFunc
	});
	_props[name] = {
		value: constructorFunc
	};
};

const defineValueProp = prop => {
	const internalName = `_${prop.name}`;

	const dirtyShaderFunc = prop.dirtyShaderFunc || (() => true);

	const setterFunc = function setterFunc(value) {
		const oldValue = this[internalName];

		if (oldValue !== value) {
			this._dirtyShader = this._dirtyShader || dirtyShaderFunc(oldValue, value);
			this[internalName] = value;
		}
	};

	definePropInternal(prop.name, () => prop.defaultValue, setterFunc, prop.getterFunc);
};

const defineAggProp = prop => {
	const internalName = `_${prop.name}`;

	const dirtyShaderFunc = prop.dirtyShaderFunc || (() => true);

	const setterFunc = function setterFunc(value) {
		const oldValue = this[internalName];

		if (!oldValue.equals(value)) {
			this._dirtyShader = this._dirtyShader || dirtyShaderFunc(oldValue, value);
			this[internalName] = oldValue.copy(value);
		}
	};

	definePropInternal(prop.name, () => prop.defaultValue.clone(), setterFunc, prop.getterFunc);
};

const defineProp = prop => {
	return prop.defaultValue && prop.defaultValue.clone ? defineAggProp(prop) : defineValueProp(prop);
};

function _defineTex2D(name, uv, channels, defChannel, vertexColor, detailMode) {
	_matTex2D[name] = channels;
	defineProp({
		name: `${name}Map`,
		defaultValue: null,
		dirtyShaderFunc: (oldValue, newValue) => {
			return !!oldValue !== !!newValue || oldValue && (oldValue.type !== newValue.type || oldValue.fixCubemapSeams !== newValue.fixCubemapSeams || oldValue.format !== newValue.format);
		}
	});
	defineProp({
		name: `${name}MapTiling`,
		defaultValue: new Vec2(1, 1)
	});
	defineProp({
		name: `${name}MapOffset`,
		defaultValue: new Vec2(0, 0)
	});
	defineProp({
		name: `${name}MapRotation`,
		defaultValue: 0
	});
	defineProp({
		name: `${name}MapUv`,
		defaultValue: uv
	});

	if (channels > 0) {
		defineProp({
			name: `${name}MapChannel`,
			defaultValue: defChannel ? defChannel : channels > 1 ? "rgb" : "g"
		});
	}

	if (vertexColor) {
		defineProp({
			name: `${name}VertexColor`,
			defaultValue: false
		});

		if (channels > 0) {
			defineProp({
				name: `${name}VertexColorChannel`,
				defaultValue: defChannel ? defChannel : channels > 1 ? "rgb" : "g"
			});
		}
	}

	if (detailMode) {
		defineProp({
			name: `${name}Mode`,
			defaultValue: DETAILMODE_MUL
		});
	}

	const mapTiling = `${name}MapTiling`;
	const mapOffset = `${name}MapOffset`;
	const mapRotation = `${name}MapRotation`;
	const mapTransform = `${name}MapTransform`;
	defineUniform(mapTransform, (material, device, scene) => {
		const tiling = material[mapTiling];
		const offset = material[mapOffset];
		const rotation = material[mapRotation];

		if (tiling.x === 1 && tiling.y === 1 && offset.x === 0 && offset.y === 0 && rotation === 0) {
			return null;
		}

		const uniform = material._allocUniform(mapTransform, () => {
			return [{
				name: `texture_${mapTransform}0`,
				value: new Float32Array(3)
			}, {
				name: `texture_${mapTransform}1`,
				value: new Float32Array(3)
			}];
		});

		const cr = Math.cos(rotation * math.DEG_TO_RAD);
		const sr = Math.sin(rotation * math.DEG_TO_RAD);
		const uniform0 = uniform[0].value;
		uniform0[0] = cr * tiling.x;
		uniform0[1] = -sr * tiling.y;
		uniform0[2] = offset.x;
		const uniform1 = uniform[1].value;
		uniform1[0] = sr * tiling.x;
		uniform1[1] = cr * tiling.y;
		uniform1[2] = 1.0 - tiling.y - offset.y;
		return uniform;
	});
}

function _defineColor(name, defaultValue) {
	defineProp({
		name: name,
		defaultValue: defaultValue,
		getterFunc: function () {
			this._dirtyShader = true;
			return this[`_${name}`];
		}
	});
	defineUniform(name, (material, device, scene) => {
		const uniform = material._allocUniform(name, () => new Float32Array(3));

		const color = material[name];
		const gamma = material.useGammaTonemap && scene.gammaCorrection;

		if (gamma) {
			uniform[0] = Math.pow(color.r, 2.2);
			uniform[1] = Math.pow(color.g, 2.2);
			uniform[2] = Math.pow(color.b, 2.2);
		} else {
			uniform[0] = color.r;
			uniform[1] = color.g;
			uniform[2] = color.b;
		}

		return uniform;
	});
}

function _defineFloat(name, defaultValue, getUniformFunc) {
	defineProp({
		name: name,
		defaultValue: defaultValue,
		dirtyShaderFunc: (oldValue, newValue) => {
			return (oldValue === 0 || oldValue === 1) !== (newValue === 0 || newValue === 1);
		}
	});
	defineUniform(name, getUniformFunc);
}

function _defineObject(name, getUniformFunc) {
	defineProp({
		name: name,
		defaultValue: null,
		dirtyShaderFunc: (oldValue, newValue) => {
			return !!oldValue === !!newValue;
		}
	});
	defineUniform(name, getUniformFunc);
}

function _defineFlag(name, defaultValue) {
	defineProp({
		name: name,
		defaultValue: defaultValue
	});
}

function _defineMaterialProps() {
	_defineColor("ambient", new Color(0.7, 0.7, 0.7));

	_defineColor("diffuse", new Color(1, 1, 1));

	_defineColor("specular", new Color(0, 0, 0));

	_defineColor("emissive", new Color(0, 0, 0));

	_defineFloat("emissiveIntensity", 1);

	_defineFloat("shininess", 25, (material, device, scene) => {
		return material.shadingModel === SPECULAR_PHONG ? Math.pow(2, material.shininess * 0.01 * 11) : material.shininess * 0.01;
	});

	_defineFloat("heightMapFactor", 1, (material, device, scene) => {
		return material.heightMapFactor * 0.025;
	});

	_defineFloat("opacity", 1);

	_defineFloat("alphaFade", 1);

	_defineFloat("alphaTest", 0);

	_defineFloat("bumpiness", 1);

	_defineFloat("normalDetailMapBumpiness", 1);

	_defineFloat("reflectivity", 1);

	_defineFloat("occludeSpecularIntensity", 1);

	_defineFloat("refraction", 0);

	_defineFloat("refractionIndex", 1.0 / 1.5);

	_defineFloat("metalness", 1);

	_defineFloat("anisotropy", 0);

	_defineFloat("clearCoat", 0);

	_defineFloat("clearCoatGlossiness", 1);

	_defineFloat("clearCoatBumpiness", 1);

	_defineFloat("aoUvSet", 0, null);

	_defineObject("ambientSH");

	_defineObject("cubeMapProjectionBox", (material, device, scene) => {
		const uniform = material._allocUniform('cubeMapProjectionBox', () => {
			return [{
				name: 'envBoxMin',
				value: new Float32Array(3)
			}, {
				name: 'envBoxMax',
				value: new Float32Array(3)
			}];
		});

		const bboxMin = material.cubeMapProjectionBox.getMin();
		const minUniform = uniform[0].value;
		minUniform[0] = bboxMin.x;
		minUniform[1] = bboxMin.y;
		minUniform[2] = bboxMin.z;
		const bboxMax = material.cubeMapProjectionBox.getMax();
		const maxUniform = uniform[1].value;
		maxUniform[0] = bboxMax.x;
		maxUniform[1] = bboxMax.y;
		maxUniform[2] = bboxMax.z;
		return uniform;
	});

	_defineFlag("ambientTint", false);

	_defineFlag("diffuseTint", false);

	_defineFlag("specularTint", false);

	_defineFlag("emissiveTint", false);

	_defineFlag("fastTbn", false);

	_defineFlag("specularAntialias", false);

	_defineFlag("useMetalness", false);

	_defineFlag("enableGGXSpecular", false);

	_defineFlag("occludeDirect", false);

	_defineFlag("normalizeNormalMap", true);

	_defineFlag("conserveEnergy", true);

	_defineFlag("opacityFadesSpecular", true);

	_defineFlag("occludeSpecular", SPECOCC_AO);

	_defineFlag("shadingModel", SPECULAR_BLINN);

	_defineFlag("fresnelModel", FRESNEL_SCHLICK);

	_defineFlag("cubeMapProjection", CUBEPROJ_NONE);

	_defineFlag("customFragmentShader", null);

	_defineFlag("forceFragmentPrecision", null);

	_defineFlag("useFog", true);

	_defineFlag("useLighting", true);

	_defineFlag("useGammaTonemap", true);

	_defineFlag("useSkybox", true);

	_defineFlag("forceUv1", false);

	_defineFlag("pixelSnap", false);

	_defineFlag("twoSidedLighting", false);

	_defineFlag("nineSlicedMode", undefined);

	_defineTex2D("diffuse", 0, 3, "", true);

	_defineTex2D("specular", 0, 3, "", true);

	_defineTex2D("emissive", 0, 3, "", true);

	_defineTex2D("normal", 0, -1, "", false);

	_defineTex2D("metalness", 0, 1, "", true);

	_defineTex2D("gloss", 0, 1, "", true);

	_defineTex2D("opacity", 0, 1, "a", true);

	_defineTex2D("height", 0, 1, "", false);

	_defineTex2D("ao", 0, 1, "", true);

	_defineTex2D("light", 1, 3, "", true);

	_defineTex2D("msdf", 0, 3, "", false);

	_defineTex2D("diffuseDetail", 0, 3, "", false, true);

	_defineTex2D("normalDetail", 0, -1, "", false);

	_defineTex2D("clearCoat", 0, 1, "", true);

	_defineTex2D("clearCoatGloss", 0, 1, "", true);

	_defineTex2D("clearCoatNormal", 0, -1, "", false);

	_defineObject("cubeMap");

	_defineObject("sphereMap");

	_defineObject("envAtlas");

	const getterFunc = function getterFunc() {
		return this._prefilteredCubemaps;
	};

	const setterFunc = function setterFunc(value) {
		const cubemaps = this._prefilteredCubemaps;
		value = value || [];
		let changed = false;
		let complete = true;

		for (let i = 0; i < 6; ++i) {
			const v = value[i] || null;

			if (cubemaps[i] !== v) {
				cubemaps[i] = v;
				changed = true;
			}

			complete = complete && !!cubemaps[i];
		}

		if (changed) {
			if (complete) {
				this.envAtlas = EnvLighting.generatePrefilteredAtlas(cubemaps, {
					target: this.envAtlas
				});
			} else {
				if (this.envAtlas) {
					this.envAtlas.destroy();
					this.envAtlas = null;
				}
			}

			this._dirtyShader = true;
		}
	};

	const empty = [null, null, null, null, null, null];
	definePropInternal("prefilteredCubemaps", () => empty.slice(), setterFunc, getterFunc);
}

_defineMaterialProps();

class ProgramLibrary {
	constructor(device) {
		this._device = device;
		this._cache = {};
		this._generators = {};
		this._isClearingCache = false;
		this._precached = false;
		this._programsCollection = [];
		this._defaultStdMatOption = {};
		this._defaultStdMatOptionMin = {};
		const m = new StandardMaterial();
		m.shaderOptBuilder.updateRef(this._defaultStdMatOption, device, {}, m, null, [], SHADER_FORWARD, null, null);
		m.shaderOptBuilder.updateMinRef(this._defaultStdMatOptionMin, device, {}, m, null, [], SHADER_SHADOW, null, null);
	}

	register(name, generator) {
		if (!this.isRegistered(name)) {
			this._generators[name] = generator;
		}
	}

	unregister(name) {
		if (this.isRegistered(name)) {
			delete this._generators[name];
		}
	}

	isRegistered(name) {
		const generator = this._generators[name];
		return generator !== undefined;
	}

	getProgram(name, options) {
		const generator = this._generators[name];

		if (generator === undefined) {
			return null;
		}

		const gd = this._device;
		const key = generator.generateKey(options);
		let shader = this._cache[key];

		if (!shader) {
			let lights;

			if (options.lights) {
				lights = options.lights;
				options.lights = lights.map(function (l) {
					const lcopy = l.clone ? l.clone() : l;
					lcopy.key = l.key;
					return lcopy;
				});
			}

			this.storeNewProgram(name, options);
			if (options.lights) options.lights = lights;
			if (this._precached) console.warn(`ProgramLibrary#getProgram: Cache miss for shader ${name} key ${key} after shaders precaching`);
			const shaderDefinition = generator.createShaderDefinition(gd, options);
			shader = this._cache[key] = new Shader(gd, shaderDefinition);
		}

		return shader;
	}

	storeNewProgram(name, options) {
		let opt = {};

		if (name === "standard") {
			const defaultMat = this._getDefaultStdMatOptions(options.pass);

			for (const p in options) {
				if (options.hasOwnProperty(p) && defaultMat[p] !== options[p] || p === "pass") opt[p] = options[p];
			}
		} else {
			opt = options;
		}

		this._programsCollection.push(JSON.stringify({
			name: name,
			options: opt
		}));
	}

	dumpPrograms() {
		let text = 'let device = pc.app ? pc.app.graphicsDevice : pc.Application.getApplication().graphicsDevice;\n';
		text += 'let shaders = [';
		if (this._programsCollection[0]) text += '\n\t' + this._programsCollection[0];

		for (let i = 1; i < this._programsCollection.length; ++i) {
			text += ',\n\t' + this._programsCollection[i];
		}

		text += '\n];\n';
		text += 'device.programLib.precompile(shaders);\n';
		text += 'if (pc.version != \"' + version + '\" || pc.revision != \"' + revision + '\")\n';
		text += '\tconsole.warn(\"precompile-shaders.js: engine version mismatch, rebuild shaders lib with current engine\");';
		const element = document.createElement('a');
		element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
		element.setAttribute('download', 'precompile-shaders.js');
		element.style.display = 'none';
		document.body.appendChild(element);
		element.click();
		document.body.removeChild(element);
	}

	clearCache() {
		const cache = this._cache;
		this._isClearingCache = true;

		for (const key in cache) {
			if (cache.hasOwnProperty(key)) {
				cache[key].destroy();
			}
		}

		this._cache = {};
		this._isClearingCache = false;
	}

	removeFromCache(shader) {
		if (this._isClearingCache) return;
		const cache = this._cache;

		for (const key in cache) {
			if (cache.hasOwnProperty(key)) {
				if (cache[key] === shader) {
					delete cache[key];
					break;
				}
			}
		}
	}

	_getDefaultStdMatOptions(pass) {
		return pass > SHADER_FORWARDHDR && pass <= SHADER_PICK ? this._defaultStdMatOptionMin : this._defaultStdMatOption;
	}

	precompile(cache) {
		if (cache) {
			const shaders = new Array(cache.length);

			for (let i = 0; i < cache.length; i++) {
				if (cache[i].name === "standard") {
					const opt = cache[i].options;

					const defaultMat = this._getDefaultStdMatOptions(opt.pass);

					for (const p in defaultMat) {
						if (defaultMat.hasOwnProperty(p) && opt[p] === undefined) opt[p] = defaultMat[p];
					}
				}

				shaders[i] = this.getProgram(cache[i].name, cache[i].options);
			}
		}

		this._precached = true;
	}

}

const EVENT_RESIZE = 'resizecanvas';

class GraphicsDevice extends EventHandler {
	constructor(canvas) {
		super();
		this.canvas = void 0;
		this.scope = void 0;
		this.maxAnisotropy = void 0;
		this.maxCubeMapSize = void 0;
		this.maxTextureSize = void 0;
		this.maxVolumeSize = void 0;
		this.precision = void 0;
		this.supportsInstancing = void 0;
		this.textureFloatRenderable = void 0;
		this.textureHalfFloatRenderable = void 0;
		this.canvas = canvas;
		this._width = 0;
		this._height = 0;
		this._maxPixelRatio = 1;
		this.shaders = [];
		this.buffers = [];
		this.textures = [];
		this.targets = [];
		this._vram = {
			tex: 0,
			vb: 0,
			ib: 0
		};
		this._shaderStats = {
			vsCompiled: 0,
			fsCompiled: 0,
			linked: 0,
			materialShaders: 0,
			compileTime: 0
		};
		this.initializeContextCaches();
		this._drawCallsPerFrame = 0;
		this._shaderSwitchesPerFrame = 0;
		this._primsPerFrame = [];

		for (let i = PRIMITIVE_POINTS; i <= PRIMITIVE_TRIFAN; i++) {
			this._primsPerFrame[i] = 0;
		}

		this._renderTargetCreationTime = 0;
		this.scope = new ScopeSpace("Device");
		this.programLib = new ProgramLibrary(this);

		for (const generator in programlib) this.programLib.register(generator, programlib[generator]);
	}

	destroy() {
		this.fire('destroy');
	}

	postDestroy() {
		this.scope = null;
		this.canvas = null;
	}

	toJSON(key) {
		return undefined;
	}

	initializeContextCaches() {
		this.indexBuffer = null;
		this.vertexBuffers = [];
		this.shader = null;
		this.renderTarget = null;
	}

	getProgramLibrary() {
		return this.programLib;
	}

	setProgramLibrary(programLib) {
		this.programLib = programLib;
	}

	setRenderTarget(renderTarget) {
		this.renderTarget = renderTarget;
	}

	getRenderTarget() {
		return this.renderTarget;
	}

	_isBrowserInterface(texture) {
		return typeof HTMLCanvasElement !== 'undefined' && texture instanceof HTMLCanvasElement || typeof HTMLImageElement !== 'undefined' && texture instanceof HTMLImageElement || typeof HTMLVideoElement !== 'undefined' && texture instanceof HTMLVideoElement || typeof ImageBitmap !== 'undefined' && texture instanceof ImageBitmap;
	}

	resizeCanvas(width, height) {
		this._width = width;
		this._height = height;
		const ratio = Math.min(this._maxPixelRatio, platform.browser ? window.devicePixelRatio : 1);
		width = Math.floor(width * ratio);
		height = Math.floor(height * ratio);

		if (this.canvas.width !== width || this.canvas.height !== height) {
			this.canvas.width = width;
			this.canvas.height = height;
			this.fire(EVENT_RESIZE, width, height);
		}
	}

	setResolution(width, height) {
		this._width = width;
		this._height = height;
		this.canvas.width = width;
		this.canvas.height = height;
		this.fire(EVENT_RESIZE, width, height);
	}

	updateClientRect() {
		this.clientRect = this.canvas.getBoundingClientRect();
	}

	get width() {
		return this.canvas.width;
	}

	get height() {
		return this.canvas.height;
	}

	set fullscreen(fullscreen) {}

	get fullscreen() {
		return false;
	}

	set maxPixelRatio(ratio) {
		this._maxPixelRatio = ratio;
		this.resizeCanvas(this._width, this._height);
	}

	get maxPixelRatio() {
		return this._maxPixelRatio;
	}

}

const defaultOptions = {
	depth: true,
	face: 0
};

class RenderTarget {
	constructor(options) {
		var _this$_colorBuffer, _this$_depthBuffer;

		const _arg2 = arguments[1];
		const _arg3 = arguments[2];

		if (options instanceof GraphicsDevice) {
			this._colorBuffer = _arg2;
			options = _arg3;
		} else {
			this._colorBuffer = options.colorBuffer;
		}

		if (this._colorBuffer) {
			this._colorBuffer._isRenderTarget = true;
		}

		this._glFrameBuffer = null;
		this._glDepthBuffer = null;
		options = options !== undefined ? options : defaultOptions;
		this._depthBuffer = options.depthBuffer;
		this._face = options.face !== undefined ? options.face : 0;

		if (this._depthBuffer) {
			const format = this._depthBuffer._format;

			if (format === PIXELFORMAT_DEPTH) {
				this._depth = true;
				this._stencil = false;
			} else if (format === PIXELFORMAT_DEPTHSTENCIL) {
				this._depth = true;
				this._stencil = true;
			} else {
				this._depth = false;
				this._stencil = false;
			}
		} else {
			this._depth = options.depth !== undefined ? options.depth : true;
			this._stencil = options.stencil !== undefined ? options.stencil : false;
		}

		this._device = ((_this$_colorBuffer = this._colorBuffer) == null ? void 0 : _this$_colorBuffer.device) || ((_this$_depthBuffer = this._depthBuffer) == null ? void 0 : _this$_depthBuffer.device);
		this._samples = options.samples !== undefined ? Math.min(options.samples, this._device.maxSamples) : 1;
		this.autoResolve = options.autoResolve !== undefined ? options.autoResolve : true;
		this._glResolveFrameBuffer = null;
		this._glMsaaColorBuffer = null;
		this._glMsaaDepthBuffer = null;
		this.name = options.name;

		if (!this.name) {
			var _this$_colorBuffer2;

			this.name = (_this$_colorBuffer2 = this._colorBuffer) == null ? void 0 : _this$_colorBuffer2.name;
		}

		if (!this.name) {
			var _this$_depthBuffer2;

			this.name = (_this$_depthBuffer2 = this._depthBuffer) == null ? void 0 : _this$_depthBuffer2.name;
		}

		if (!this.name) {
			this.name = "Untitled";
		}

		this.flipY = !!options.flipY;
	}

	destroy() {
		const device = this._device;

		if (device) {
			const idx = device.targets.indexOf(this);

			if (idx !== -1) {
				device.targets.splice(idx, 1);
			}

			this.destroyFrameBuffers();
		}
	}

	destroyFrameBuffers() {
		const device = this._device;

		if (device) {
			const gl = device.gl;

			if (this._glFrameBuffer) {
				gl.deleteFramebuffer(this._glFrameBuffer);
				this._glFrameBuffer = null;
			}

			if (this._glDepthBuffer) {
				gl.deleteRenderbuffer(this._glDepthBuffer);
				this._glDepthBuffer = null;
			}

			if (this._glResolveFrameBuffer) {
				gl.deleteFramebuffer(this._glResolveFrameBuffer);
				this._glResolveFrameBuffer = null;
			}

			if (this._glMsaaColorBuffer) {
				gl.deleteRenderbuffer(this._glMsaaColorBuffer);
				this._glMsaaColorBuffer = null;
			}

			if (this._glMsaaDepthBuffer) {
				gl.deleteRenderbuffer(this._glMsaaDepthBuffer);
				this._glMsaaDepthBuffer = null;
			}
		}
	}

	destroyTextureBuffers() {
		if (this._depthBuffer) {
			this._depthBuffer.destroy();

			this._depthBuffer = null;
		}

		if (this._colorBuffer) {
			this._colorBuffer.destroy();

			this._colorBuffer = null;
		}
	}

	loseContext() {
		this._glFrameBuffer = undefined;
		this._glDepthBuffer = undefined;
		this._glResolveFrameBuffer = undefined;
		this._glMsaaColorBuffer = undefined;
		this._glMsaaDepthBuffer = undefined;
	}

	resolve(color = true, depth = !!this._depthBuffer) {
		if (!this._device) return;
		if (!this._device.webgl2) return;
		const gl = this._device.gl;
		gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this._glFrameBuffer);
		gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this._glResolveFrameBuffer);
		gl.blitFramebuffer(0, 0, this.width, this.height, 0, 0, this.width, this.height, (color ? gl.COLOR_BUFFER_BIT : 0) | (depth ? gl.DEPTH_BUFFER_BIT : 0), gl.NEAREST);
		gl.bindFramebuffer(gl.FRAMEBUFFER, this._glFrameBuffer);
	}

	copy(source, color, depth) {
		if (!this._device) {
			if (source._device) {
				this._device = source._device;
			} else {
				return false;
			}
		}

		return this._device.copyRenderTarget(source, this, color, depth);
	}

	get colorBuffer() {
		return this._colorBuffer;
	}

	get depthBuffer() {
		return this._depthBuffer;
	}

	get face() {
		return this._face;
	}

	get width() {
		return this._colorBuffer ? this._colorBuffer.width : this._depthBuffer.width;
	}

	get height() {
		return this._colorBuffer ? this._colorBuffer.height : this._depthBuffer.height;
	}

}

function areaElement(x, y) {
	return Math.atan2(x * y, Math.sqrt(x * x + y * y + 1));
}

function texelCoordSolidAngle(u, v, size) {
	let _u = 2.0 * (u + 0.5) / size - 1.0;

	let _v = 2.0 * (v + 0.5) / size - 1.0;

	_u *= 1.0 - 1.0 / size;
	_v *= 1.0 - 1.0 / size;
	const invResolution = 1.0 / size;
	const x0 = _u - invResolution;
	const y0 = _v - invResolution;
	const x1 = _u + invResolution;
	const y1 = _v + invResolution;
	let solidAngle = areaElement(x0, y0) - areaElement(x0, y1) - areaElement(x1, y0) + areaElement(x1, y1);

	if (u === 0 && v === 0 || u === size - 1 && v === 0 || u === 0 && v === size - 1 || u === size - 1 && v === size - 1) {
		solidAngle /= 3;
	} else if (u === 0 || v === 0 || u === size - 1 || v === size - 1) {
		solidAngle *= 0.5;
	}

	return solidAngle;
}

function shFromCubemap(device, source, dontFlipX) {
	if (source.format !== PIXELFORMAT_R8_G8_B8_A8) {
		return null;
	}

	if (!source._levels[0] || !source._levels[0][0]) {
		return null;
	}

	const cubeSize = source.width;

	if (!source._levels[0][0].length) {
		if (source._levels[0][0] instanceof HTMLImageElement) {
			const shader = createShaderFromCode(device, shaderChunks.fullscreenQuadVS, shaderChunks.fullscreenQuadPS, "fsQuadSimple");
			const constantTexSource = device.scope.resolve("source");

			for (let face = 0; face < 6; face++) {
				const img = source._levels[0][face];
				const tex = new Texture(device, {
					cubemap: false,
					type: TEXTURETYPE_DEFAULT,
					format: source.format,
					width: cubeSize,
					height: cubeSize,
					mipmaps: false
				});
				tex.name = 'prefiltered-cube';
				tex._levels[0] = img;
				tex.upload();
				const tex2 = new Texture(device, {
					cubemap: false,
					type: TEXTURETYPE_DEFAULT,
					format: source.format,
					width: cubeSize,
					height: cubeSize,
					mipmaps: false
				});
				tex2.name = 'prefiltered-cube';
				const targ = new RenderTarget({
					colorBuffer: tex2,
					depth: false
				});
				constantTexSource.setValue(tex);
				drawQuadWithShader(device, targ, shader);
				const gl = device.gl;
				gl.bindFramebuffer(gl.FRAMEBUFFER, targ._glFrameBuffer);
				const pixels = new Uint8Array(cubeSize * cubeSize * 4);
				gl.readPixels(0, 0, tex.width, tex.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
				source._levels[0][face] = pixels;
			}
		} else {
			return null;
		}
	}

	const dirs = [];

	for (let y = 0; y < cubeSize; y++) {
		for (let x = 0; x < cubeSize; x++) {
			const u = x / (cubeSize - 1) * 2 - 1;
			const v = y / (cubeSize - 1) * 2 - 1;
			dirs[y * cubeSize + x] = new Vec3(u, v, 1.0).normalize();
		}
	}

	const sh = new Float32Array(9 * 3);
	const coef1 = 0;
	const coef2 = 1 * 3;
	const coef3 = 2 * 3;
	const coef4 = 3 * 3;
	const coef5 = 4 * 3;
	const coef6 = 5 * 3;
	const coef7 = 6 * 3;
	const coef8 = 7 * 3;
	const coef9 = 8 * 3;
	const nx = 0;
	const px = 1;
	const ny = 2;
	const py = 3;
	const nz = 4;
	const pz = 5;
	let accum = 0;

	for (let face = 0; face < 6; face++) {
		for (let y = 0; y < cubeSize; y++) {
			for (let x = 0; x < cubeSize; x++) {
				const addr = y * cubeSize + x;
				const weight = texelCoordSolidAngle(x, y, cubeSize);
				const weight1 = weight * 4 / 17;
				const weight2 = weight * 8 / 17;
				const weight3 = weight * 15 / 17;
				const weight4 = weight * 5 / 68;
				const weight5 = weight * 15 / 68;
				const dir = dirs[addr];
				let dx, dy, dz;

				if (face === nx) {
					dx = dir.z;
					dy = -dir.y;
					dz = -dir.x;
				} else if (face === px) {
					dx = -dir.z;
					dy = -dir.y;
					dz = dir.x;
				} else if (face === ny) {
					dx = dir.x;
					dy = dir.z;
					dz = dir.y;
				} else if (face === py) {
					dx = dir.x;
					dy = -dir.z;
					dz = -dir.y;
				} else if (face === nz) {
					dx = dir.x;
					dy = -dir.y;
					dz = dir.z;
				} else if (face === pz) {
					dx = -dir.x;
					dy = -dir.y;
					dz = -dir.z;
				}

				if (!dontFlipX) dx = -dx;
				const a = source._levels[0][face][addr * 4 + 3] / 255.0;

				for (let c = 0; c < 3; c++) {
					let value = source._levels[0][face][addr * 4 + c] / 255.0;

					if (source.type === TEXTURETYPE_RGBM) {
						value *= a * 8.0;
						value *= value;
					} else {
						value = Math.pow(value, 2.2);
					}

					sh[coef1 + c] += value * weight1;
					sh[coef2 + c] += value * weight2 * dx;
					sh[coef3 + c] += value * weight2 * dy;
					sh[coef4 + c] += value * weight2 * dz;
					sh[coef5 + c] += value * weight3 * dx * dz;
					sh[coef6 + c] += value * weight3 * dz * dy;
					sh[coef7 + c] += value * weight3 * dy * dx;
					sh[coef8 + c] += value * weight4 * (3.0 * dz * dz - 1.0);
					sh[coef9 + c] += value * weight5 * (dx * dx - dy * dy);
					accum += weight;
				}
			}
		}
	}

	for (let c = 0; c < sh.length; c++) {
		sh[c] *= 4 * Math.PI / accum;
	}

	return sh;
}

class IndexBuffer {
	constructor(graphicsDevice, format, numIndices, usage = BUFFER_STATIC, initialData) {
		this.device = graphicsDevice;
		this.format = format;
		this.numIndices = numIndices;
		this.usage = usage;
		this.impl = graphicsDevice.createIndexBufferImpl(this);
		const bytesPerIndex = typedArrayIndexFormatsByteSize[format];
		this.bytesPerIndex = bytesPerIndex;
		this.numBytes = this.numIndices * bytesPerIndex;

		if (initialData) {
			this.setData(initialData);
		} else {
			this.storage = new ArrayBuffer(this.numBytes);
		}

		graphicsDevice._vram.ib += this.numBytes;
		this.device.buffers.push(this);
	}

	destroy() {
		const device = this.device;
		const idx = device.buffers.indexOf(this);

		if (idx !== -1) {
			device.buffers.splice(idx, 1);
		}

		if (this.device.indexBuffer === this) {
			this.device.indexBuffer = null;
		}

		this.impl.destroy(device);
		this.device._vram.ib -= this.storage.byteLength;
	}

	loseContext() {
		this.impl.loseContext();
	}

	getFormat() {
		return this.format;
	}

	getNumIndices() {
		return this.numIndices;
	}

	lock() {
		return this.storage;
	}

	unlock() {
		this.impl.unlock(this);
	}

	setData(data) {
		if (data.byteLength !== this.numBytes) {
			return false;
		}

		this.storage = data;
		this.unlock();
		return true;
	}

	_lockTypedArray() {
		const lock = this.lock();
		const indices = this.format === INDEXFORMAT_UINT32 ? new Uint32Array(lock) : this.format === INDEXFORMAT_UINT16 ? new Uint16Array(lock) : new Uint8Array(lock);
		return indices;
	}

	writeData(data, count) {
		const indices = this._lockTypedArray();

		if (data.length > count) {
			if (ArrayBuffer.isView(data)) {
				data = data.subarray(0, count);
				indices.set(data);
			} else {
				for (let i = 0; i < count; i++) indices[i] = data[i];
			}
		} else {
			indices.set(data);
		}

		this.unlock();
	}

	readData(data) {
		const indices = this._lockTypedArray();

		const count = this.numIndices;

		if (ArrayBuffer.isView(data)) {
			data.set(indices);
		} else {
			data.length = 0;

			for (let i = 0; i < count; i++) data[i] = indices[i];
		}

		return count;
	}

}

function set1(a) {
	this.array[this.index] = a;
}

function set2(a, b) {
	this.array[this.index] = a;
	this.array[this.index + 1] = b;
}

function set3(a, b, c) {
	this.array[this.index] = a;
	this.array[this.index + 1] = b;
	this.array[this.index + 2] = c;
}

function set4(a, b, c, d) {
	this.array[this.index] = a;
	this.array[this.index + 1] = b;
	this.array[this.index + 2] = c;
	this.array[this.index + 3] = d;
}

function arraySet1(index, inputArray, inputIndex) {
	this.array[index] = inputArray[inputIndex];
}

function arraySet2(index, inputArray, inputIndex) {
	this.array[index] = inputArray[inputIndex];
	this.array[index + 1] = inputArray[inputIndex + 1];
}

function arraySet3(index, inputArray, inputIndex) {
	this.array[index] = inputArray[inputIndex];
	this.array[index + 1] = inputArray[inputIndex + 1];
	this.array[index + 2] = inputArray[inputIndex + 2];
}

function arraySet4(index, inputArray, inputIndex) {
	this.array[index] = inputArray[inputIndex];
	this.array[index + 1] = inputArray[inputIndex + 1];
	this.array[index + 2] = inputArray[inputIndex + 2];
	this.array[index + 3] = inputArray[inputIndex + 3];
}

function arrayGet1(offset, outputArray, outputIndex) {
	outputArray[outputIndex] = this.array[offset];
}

function arrayGet2(offset, outputArray, outputIndex) {
	outputArray[outputIndex] = this.array[offset];
	outputArray[outputIndex + 1] = this.array[offset + 1];
}

function arrayGet3(offset, outputArray, outputIndex) {
	outputArray[outputIndex] = this.array[offset];
	outputArray[outputIndex + 1] = this.array[offset + 1];
	outputArray[outputIndex + 2] = this.array[offset + 2];
}

function arrayGet4(offset, outputArray, outputIndex) {
	outputArray[outputIndex] = this.array[offset];
	outputArray[outputIndex + 1] = this.array[offset + 1];
	outputArray[outputIndex + 2] = this.array[offset + 2];
	outputArray[outputIndex + 3] = this.array[offset + 3];
}

class VertexIteratorAccessor {
	constructor(buffer, vertexElement, vertexFormat) {
		this.index = 0;
		this.numComponents = vertexElement.numComponents;

		if (vertexFormat.interleaved) {
			this.array = new typedArrayTypes[vertexElement.dataType](buffer, vertexElement.offset);
		} else {
			this.array = new typedArrayTypes[vertexElement.dataType](buffer, vertexElement.offset, vertexFormat.vertexCount * vertexElement.numComponents);
		}

		this.stride = vertexElement.stride / this.array.constructor.BYTES_PER_ELEMENT;

		switch (vertexElement.numComponents) {
			case 1:
				this.set = set1;
				this.getToArray = arrayGet1;
				this.setFromArray = arraySet1;
				break;

			case 2:
				this.set = set2;
				this.getToArray = arrayGet2;
				this.setFromArray = arraySet2;
				break;

			case 3:
				this.set = set3;
				this.getToArray = arrayGet3;
				this.setFromArray = arraySet3;
				break;

			case 4:
				this.set = set4;
				this.getToArray = arrayGet4;
				this.setFromArray = arraySet4;
				break;
		}
	}

	get(offset) {
		return this.array[this.index + offset];
	}

	set(a, b, c, d) {}

	getToArray(offset, outputArray, outputIndex) {}

	setFromArray(index, inputArray, inputIndex) {}

}

class VertexIterator {
	constructor(vertexBuffer) {
		this.vertexBuffer = vertexBuffer;
		this.vertexFormatSize = vertexBuffer.getFormat().size;
		this.buffer = this.vertexBuffer.lock();
		this.accessors = [];
		this.element = {};
		const vertexFormat = this.vertexBuffer.getFormat();

		for (let i = 0; i < vertexFormat.elements.length; i++) {
			const vertexElement = vertexFormat.elements[i];
			this.accessors[i] = new VertexIteratorAccessor(this.buffer, vertexElement, vertexFormat);
			this.element[vertexElement.name] = this.accessors[i];
		}
	}

	next(count = 1) {
		let i = 0;
		const accessors = this.accessors;
		const numAccessors = this.accessors.length;

		while (i < numAccessors) {
			const accessor = accessors[i++];
			accessor.index += count * accessor.stride;
		}
	}

	end() {
		this.vertexBuffer.unlock();
	}

	writeData(semantic, data, numVertices) {
		const element = this.element[semantic];

		if (element) {
			if (numVertices > this.vertexBuffer.numVertices) {
				numVertices = this.vertexBuffer.numVertices;
			}

			const numComponents = element.numComponents;

			if (this.vertexBuffer.getFormat().interleaved) {
				let index = 0;

				for (let i = 0; i < numVertices; i++) {
					element.setFromArray(index, data, i * numComponents);
					index += element.stride;
				}
			} else {
				if (data.length > numVertices * numComponents) {
					const copyCount = numVertices * numComponents;

					if (ArrayBuffer.isView(data)) {
						data = data.subarray(0, copyCount);
						element.array.set(data);
					} else {
						for (let i = 0; i < copyCount; i++) element.array[i] = data[i];
					}
				} else {
					element.array.set(data);
				}
			}
		}
	}

	readData(semantic, data) {
		const element = this.element[semantic];
		let count = 0;

		if (element) {
			count = this.vertexBuffer.numVertices;
			let i;
			const numComponents = element.numComponents;

			if (this.vertexBuffer.getFormat().interleaved) {
				if (Array.isArray(data)) data.length = 0;
				element.index = 0;
				let offset = 0;

				for (i = 0; i < count; i++) {
					element.getToArray(offset, data, i * numComponents);
					offset += element.stride;
				}
			} else {
				if (ArrayBuffer.isView(data)) {
					data.set(element.array);
				} else {
					data.length = 0;
					const copyCount = count * numComponents;

					for (i = 0; i < copyCount; i++) data[i] = element.array[i];
				}
			}
		}

		return count;
	}

}

const primitive = {
	type: PRIMITIVE_TRISTRIP,
	base: 0,
	count: 4,
	indexed: false
};

class PostEffect$1 {
	constructor(graphicsDevice) {
		this.device = graphicsDevice;
		this.shader = null;
		this.vertexBuffer = createFullscreenQuad(graphicsDevice);
		this.needsDepthBuffer = false;
		this.depthMap = null;
	}

	render(inputTarget, outputTarget, rect) {}

}

function createFullscreenQuad(device) {
	const vertexFormat = new VertexFormat(device, [{
		semantic: SEMANTIC_POSITION,
		components: 2,
		type: TYPE_FLOAT32
	}]);
	const vertexBuffer = new VertexBuffer(device, vertexFormat, 4);
	const iterator = new VertexIterator(vertexBuffer);
	iterator.element[SEMANTIC_POSITION].set(-1.0, -1.0);
	iterator.next();
	iterator.element[SEMANTIC_POSITION].set(1.0, -1.0);
	iterator.next();
	iterator.element[SEMANTIC_POSITION].set(-1.0, 1.0);
	iterator.next();
	iterator.element[SEMANTIC_POSITION].set(1.0, 1.0);
	iterator.end();
	return vertexBuffer;
}

function drawFullscreenQuad(device, target, vertexBuffer, shader, rect) {
	const oldRt = device.getRenderTarget();
	device.setRenderTarget(target);
	device.updateBegin();
	let w = target ? target.width : device.width;
	let h = target ? target.height : device.height;
	let x = 0;
	let y = 0;

	if (rect) {
		x = rect.x * w;
		y = rect.y * h;
		w *= rect.z;
		h *= rect.w;
	}

	const oldVx = device.vx;
	const oldVy = device.vy;
	const oldVw = device.vw;
	const oldVh = device.vh;
	device.setViewport(x, y, w, h);
	const oldSx = device.sx;
	const oldSy = device.sy;
	const oldSw = device.sw;
	const oldSh = device.sh;
	device.setScissor(x, y, w, h);
	const oldBlending = device.getBlending();
	const oldDepthTest = device.getDepthTest();
	const oldDepthWrite = device.getDepthWrite();
	const oldCullMode = device.getCullMode();
	const oldWR = device.writeRed;
	const oldWG = device.writeGreen;
	const oldWB = device.writeBlue;
	const oldWA = device.writeAlpha;
	device.setBlending(false);
	device.setDepthTest(false);
	device.setDepthWrite(false);
	device.setCullMode(CULLFACE_NONE);
	device.setColorWrite(true, true, true, true);
	device.setVertexBuffer(vertexBuffer, 0);
	device.setShader(shader);
	device.draw(primitive);
	device.setBlending(oldBlending);
	device.setDepthTest(oldDepthTest);
	device.setDepthWrite(oldDepthWrite);
	device.setCullMode(oldCullMode);
	device.setColorWrite(oldWR, oldWG, oldWB, oldWA);
	device.updateEnd();
	device.setRenderTarget(oldRt);
	device.updateBegin();
	device.setViewport(oldVx, oldVy, oldVw, oldVh);
	device.setScissor(oldSx, oldSy, oldSw, oldSh);
}

class TransformFeedback {
	constructor(inputBuffer, usage = BUFFER_GPUDYNAMIC) {
		this.device = inputBuffer.device;
		const gl = this.device.gl;
		this._inputBuffer = inputBuffer;

		if (usage === BUFFER_GPUDYNAMIC && inputBuffer.usage !== usage) {
			gl.bindBuffer(gl.ARRAY_BUFFER, inputBuffer.impl.bufferId);
			gl.bufferData(gl.ARRAY_BUFFER, inputBuffer.storage, gl.DYNAMIC_COPY);
		}

		this._outputBuffer = new VertexBuffer(inputBuffer.device, inputBuffer.format, inputBuffer.numVertices, usage, inputBuffer.storage);
	}

	static createShader(graphicsDevice, vsCode, name) {
		return createShaderFromCode(graphicsDevice, vsCode, null, name, true);
	}

	destroy() {
		this._outputBuffer.destroy();
	}

	process(shader, swap = true) {
		const device = this.device;
		const oldRt = device.getRenderTarget();
		device.setRenderTarget(null);
		device.updateBegin();
		device.setVertexBuffer(this._inputBuffer, 0);
		device.setRaster(false);
		device.setTransformFeedbackBuffer(this._outputBuffer);
		device.setShader(shader);
		device.draw({
			type: PRIMITIVE_POINTS,
			base: 0,
			count: this._inputBuffer.numVertices,
			indexed: false
		});
		device.setTransformFeedbackBuffer(null);
		device.setRaster(true);
		device.updateEnd();
		device.setRenderTarget(oldRt);

		if (swap) {
			let tmp = this._inputBuffer.impl.bufferId;
			this._inputBuffer.impl.bufferId = this._outputBuffer.impl.bufferId;
			this._outputBuffer.impl.bufferId = tmp;
			tmp = this._inputBuffer.impl.vao;
			this._inputBuffer.impl.vao = this._outputBuffer.impl.vao;
			this._outputBuffer.impl.vao = tmp;
		}
	}

	get inputBuffer() {
		return this._inputBuffer;
	}

	get outputBuffer() {
		return this._outputBuffer;
	}

}

class GrabPass {
	constructor(device, useAlpha) {
		this.device = device;
		this.useAlpha = useAlpha;
		this.useMipmaps = device.webgl2;
		this.texture = null;
		this.renderTarget = null;
		this.textureId = null;
	}

	destroy() {
		this.textureId = null;

		if (this.renderTarget) {
			this.renderTarget.destroy();
			this.renderTarget = null;
		}

		if (this.texture) {
			this.texture.destroy();
			this.texture = null;
		}
	}

	create() {
		if (!this.texture) {
			const texture = new Texture(this.device, {
				name: 'texture_grabPass',
				format: this.useAlpha ? PIXELFORMAT_R8_G8_B8_A8 : PIXELFORMAT_R8_G8_B8,
				minFilter: this.useMipmaps ? FILTER_LINEAR_MIPMAP_LINEAR : FILTER_LINEAR,
				magFilter: FILTER_LINEAR,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE,
				mipmaps: this.useMipmaps
			});
			this.texture = texture;
			this.renderTarget = new RenderTarget({
				colorBuffer: texture,
				depth: false
			});
			this.textureId = this.device.scope.resolve(texture.name);
			this.textureId.setValue(texture);
		}
	}

	update() {
		const device = this.device;
		const gl = device.gl;

		if (!device.grabPassAvailable) {
			return false;
		}

		const renderTarget = device.renderTarget;
		const resolveRenderTarget = renderTarget && renderTarget._glResolveFrameBuffer;
		const texture = this.texture;
		const width = device.width;
		const height = device.height;

		if (device.webgl2 && !device._tempMacChromeBlitFramebufferWorkaround && width === texture._width && height === texture._height) {
			if (resolveRenderTarget) {
				renderTarget.resolve(true);
			}

			const currentFrameBuffer = renderTarget ? renderTarget._glFrameBuffer : null;
			const resolvedFrameBuffer = renderTarget ? renderTarget._glResolveFrameBuffer || renderTarget._glFrameBuffer : null;
			device.initRenderTarget(this.renderTarget);
			const grabPassFrameBuffer = this.renderTarget._glFrameBuffer;
			gl.bindFramebuffer(gl.READ_FRAMEBUFFER, resolvedFrameBuffer);
			gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, grabPassFrameBuffer);
			gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, gl.COLOR_BUFFER_BIT, gl.NEAREST);
			gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, currentFrameBuffer);
		} else {
			if (resolveRenderTarget) {
				renderTarget.resolve(true);
				gl.bindFramebuffer(gl.FRAMEBUFFER, renderTarget._glResolveFrameBuffer);
			}

			const format = texture.impl._glFormat;
			gl.copyTexImage2D(gl.TEXTURE_2D, 0, format, 0, 0, width, height, 0);
			texture._width = width;
			texture._height = height;

			if (resolveRenderTarget) {
				gl.bindFramebuffer(gl.FRAMEBUFFER, renderTarget._glFrameBuffer);
			}
		}

		return true;
	}

	generateMipmaps() {
		if (this.useMipmaps) {
			this.device.gl.generateMipmap(this.texture.impl._glTarget);
		}
	}

	prepareTexture() {
		const updated = this.update();

		if (updated) {
			this.generateMipmaps();
		}

		return updated;
	}

}

class WebglBuffer {
	constructor() {
		this.bufferId = null;
	}

	destroy(device) {
		if (this.bufferId) {
			device.gl.deleteBuffer(this.bufferId);
			this.bufferId = null;
		}
	}

	loseContext() {
		this.bufferId = null;
	}

	unlock(device, usage, target, storage) {
		const gl = device.gl;

		if (!this.bufferId) {
			this.bufferId = gl.createBuffer();
		}

		let glUsage;

		switch (usage) {
			case BUFFER_STATIC:
				glUsage = gl.STATIC_DRAW;
				break;

			case BUFFER_DYNAMIC:
				glUsage = gl.DYNAMIC_DRAW;
				break;

			case BUFFER_STREAM:
				glUsage = gl.STREAM_DRAW;
				break;

			case BUFFER_GPUDYNAMIC:
				if (device.webgl2) {
					glUsage = gl.DYNAMIC_COPY;
				} else {
					glUsage = gl.STATIC_DRAW;
				}

				break;
		}

		gl.bindBuffer(target, this.bufferId);
		gl.bufferData(target, storage, glUsage);
	}

}

class WebglVertexBuffer extends WebglBuffer {
	constructor(...args) {
		super(...args);
		this.vao = null;
	}

	destroy(device) {
		super.destroy(device);
		device.boundVao = null;
		device.gl.bindVertexArray(null);
	}

	loseContext() {
		super.loseContext();
		this.vao = null;
	}

	unlock(vertexBuffer) {
		const device = vertexBuffer.device;
		super.unlock(device, vertexBuffer.usage, device.gl.ARRAY_BUFFER, vertexBuffer.storage);
	}

}

class WebglIndexBuffer extends WebglBuffer {
	constructor(indexBuffer) {
		super();
		const gl = indexBuffer.device.gl;
		const format = indexBuffer.format;

		if (format === INDEXFORMAT_UINT8) {
			this.glFormat = gl.UNSIGNED_BYTE;
		} else if (format === INDEXFORMAT_UINT16) {
			this.glFormat = gl.UNSIGNED_SHORT;
		} else if (format === INDEXFORMAT_UINT32) {
			this.glFormat = gl.UNSIGNED_INT;
		}
	}

	unlock(indexBuffer) {
		const device = indexBuffer.device;
		super.unlock(device, indexBuffer.usage, device.gl.ELEMENT_ARRAY_BUFFER, indexBuffer.storage);
	}

}

class ShaderInput {
	constructor(graphicsDevice, name, type, locationId) {
		this.locationId = locationId;
		this.scopeId = graphicsDevice.scope.resolve(name);
		this.version = new Version();

		if (name.substr(name.length - 3) === "[0]") {
			switch (type) {
				case UNIFORMTYPE_FLOAT:
					type = UNIFORMTYPE_FLOATARRAY;
					break;

				case UNIFORMTYPE_VEC2:
					type = UNIFORMTYPE_VEC2ARRAY;
					break;

				case UNIFORMTYPE_VEC3:
					type = UNIFORMTYPE_VEC3ARRAY;
					break;

				case UNIFORMTYPE_VEC4:
					type = UNIFORMTYPE_VEC4ARRAY;
					break;
			}
		}

		this.dataType = type;
		this.value = [null, null, null, null];
		this.array = [];
	}

}

class WebglShader {
	constructor(shader) {
		this.glProgram = null;
		this.glVertexShader = null;
		this.glFragmentShader = null;
		this.compileAndLink(shader.device, shader);
		shader.device.shaders.push(shader);
	}

	destroy(shader) {
		const device = shader.device;
		const idx = device.shaders.indexOf(shader);

		if (idx !== -1) {
			device.shaders.splice(idx, 1);
		}

		if (this.glProgram) {
			device.gl.deleteProgram(this.glProgram);
			this.glProgram = null;
			device.removeShaderFromCache(shader);
		}
	}

	restoreContext(device, shader) {
		this.compileAndLink(device, shader);
	}

	compileAndLink(device, shader) {
		const definition = shader.definition;

		const glVertexShader = this._compileShaderSource(device, definition.vshader, true);

		const glFragmentShader = this._compileShaderSource(device, definition.fshader, false);

		const gl = device.gl;
		const glProgram = gl.createProgram();
		gl.attachShader(glProgram, glVertexShader);
		gl.attachShader(glProgram, glFragmentShader);
		const attrs = definition.attributes;

		if (device.webgl2 && definition.useTransformFeedback) {
			const outNames = [];

			for (const attr in attrs) {
				if (attrs.hasOwnProperty(attr)) {
					outNames.push("out_" + attr);
				}
			}

			gl.transformFeedbackVaryings(glProgram, outNames, gl.INTERLEAVED_ATTRIBS);
		}

		const locations = {};

		for (const attr in attrs) {
			if (attrs.hasOwnProperty(attr)) {
				const semantic = attrs[attr];
				const loc = semanticToLocation[semantic];
				locations[loc] = attr;
				gl.bindAttribLocation(glProgram, loc, attr);
			}
		}

		gl.linkProgram(glProgram);
		this.glVertexShader = glVertexShader;
		this.glFragmentShader = glFragmentShader;
		this.glProgram = glProgram;
	}

	_compileShaderSource(device, src, isVertexShader) {
		const gl = device.gl;
		const shaderCache = isVertexShader ? device.vertexShaderCache : device.fragmentShaderCache;
		let glShader = shaderCache[src];

		if (!glShader) {
			glShader = gl.createShader(isVertexShader ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER);
			gl.shaderSource(glShader, src);
			gl.compileShader(glShader);
			shaderCache[src] = glShader;
		}

		return glShader;
	}

	postLink(device, shader) {
		const gl = device.gl;
		const glProgram = this.glProgram;
		const definition = shader.definition;
		if (!this._isCompiled(device, shader, this.glVertexShader, definition.vshader, "vertex")) return false;
		if (!this._isCompiled(device, shader, this.glFragmentShader, definition.fshader, "fragment")) return false;

		if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {
			const message = "Failed to link shader program. Error: " + gl.getProgramInfoLog(glProgram);
			console.error(message);
			return false;
		}

		let i, info, location, shaderInput;
		i = 0;
		const numAttributes = gl.getProgramParameter(glProgram, gl.ACTIVE_ATTRIBUTES);

		while (i < numAttributes) {
			info = gl.getActiveAttrib(glProgram, i++);
			location = gl.getAttribLocation(glProgram, info.name);

			if (definition.attributes[info.name] === undefined) {
				console.error(`Vertex shader attribute "${info.name}" is not mapped to a semantic in shader definition.`);
			}

			shaderInput = new ShaderInput(device, definition.attributes[info.name], device.pcUniformType[info.type], location);
			shader.attributes.push(shaderInput);
		}

		i = 0;
		const numUniforms = gl.getProgramParameter(glProgram, gl.ACTIVE_UNIFORMS);

		while (i < numUniforms) {
			info = gl.getActiveUniform(glProgram, i++);
			location = gl.getUniformLocation(glProgram, info.name);
			shaderInput = new ShaderInput(device, info.name, device.pcUniformType[info.type], location);

			if (info.type === gl.SAMPLER_2D || info.type === gl.SAMPLER_CUBE || device.webgl2 && (info.type === gl.SAMPLER_2D_SHADOW || info.type === gl.SAMPLER_CUBE_SHADOW || info.type === gl.SAMPLER_3D)) {
				shader.samplers.push(shaderInput);
			} else {
				shader.uniforms.push(shaderInput);
			}
		}

		shader.ready = true;
		return true;
	}

	_isCompiled(device, shader, glShader, source, shaderType) {
		const gl = device.gl;

		if (!gl.getShaderParameter(glShader, gl.COMPILE_STATUS)) {
			const infoLog = gl.getShaderInfoLog(glShader);

			const [code, error] = this._processError(source, infoLog);

			const message = `Failed to compile ${shaderType} shader:\n\n${infoLog}\n${code}`;
			console.error(message);
			return false;
		}

		return true;
	}

	_processError(src, infoLog) {
		if (!src) return "";
		const lines = src.split('\n');
		const error = {};
		let code = '';
		let from = 0;
		let to = lines.length;

		if (infoLog && infoLog.startsWith('ERROR:')) {
			const match = infoLog.match(/^ERROR:\s([0-9]+):([0-9]+):\s*(.+)/);

			if (match) {
				error.message = match[3];
				error.line = parseInt(match[2], 10);
				from = Math.max(0, error.line - 6);
				to = Math.min(lines.length, error.line + 5);
			}
		}

		for (let i = from; i < to; i++) {
			code += i + 1 + ":\t" + lines[i] + '\n';
		}

		error.source = src;
		return [code, error];
	}

}

function downsampleImage(image, size) {
	const srcW = image.width;
	const srcH = image.height;

	if (srcW > size || srcH > size) {
		const scale = size / Math.max(srcW, srcH);
		const dstW = Math.floor(srcW * scale);
		const dstH = Math.floor(srcH * scale);
		const canvas = document.createElement('canvas');
		canvas.width = dstW;
		canvas.height = dstH;
		const context = canvas.getContext('2d');
		context.drawImage(image, 0, 0, srcW, srcH, 0, 0, dstW, dstH);
		return canvas;
	}

	return image;
}

class WebglTexture {
	constructor() {
		this._glTexture = null;
		this._glTarget = void 0;
		this._glFormat = void 0;
		this._glInternalFormat = void 0;
		this._glPixelType = void 0;
	}

	destroy(device) {
		if (this._glTexture) {
			for (let i = 0; i < device.textureUnits.length; i++) {
				const textureUnit = device.textureUnits[i];

				for (let j = 0; j < textureUnit.length; j++) {
					if (textureUnit[j] === this._glTexture) {
						textureUnit[j] = null;
					}
				}
			}

			device.gl.deleteTexture(this._glTexture);
			this._glTexture = null;
		}
	}

	loseContext() {
		this._glTexture = null;
	}

	initialize(device, texture) {
		const gl = device.gl;
		let ext;
		this._glTexture = gl.createTexture();
		this._glTarget = texture._cubemap ? gl.TEXTURE_CUBE_MAP : texture._volume ? gl.TEXTURE_3D : gl.TEXTURE_2D;

		switch (texture._format) {
			case PIXELFORMAT_A8:
				this._glFormat = gl.ALPHA;
				this._glInternalFormat = gl.ALPHA;
				this._glPixelType = gl.UNSIGNED_BYTE;
				break;

			case PIXELFORMAT_L8:
				this._glFormat = gl.LUMINANCE;
				this._glInternalFormat = gl.LUMINANCE;
				this._glPixelType = gl.UNSIGNED_BYTE;
				break;

			case PIXELFORMAT_L8_A8:
				this._glFormat = gl.LUMINANCE_ALPHA;
				this._glInternalFormat = gl.LUMINANCE_ALPHA;
				this._glPixelType = gl.UNSIGNED_BYTE;
				break;

			case PIXELFORMAT_R5_G6_B5:
				this._glFormat = gl.RGB;
				this._glInternalFormat = gl.RGB;
				this._glPixelType = gl.UNSIGNED_SHORT_5_6_5;
				break;

			case PIXELFORMAT_R5_G5_B5_A1:
				this._glFormat = gl.RGBA;
				this._glInternalFormat = gl.RGBA;
				this._glPixelType = gl.UNSIGNED_SHORT_5_5_5_1;
				break;

			case PIXELFORMAT_R4_G4_B4_A4:
				this._glFormat = gl.RGBA;
				this._glInternalFormat = gl.RGBA;
				this._glPixelType = gl.UNSIGNED_SHORT_4_4_4_4;
				break;

			case PIXELFORMAT_R8_G8_B8:
				this._glFormat = gl.RGB;
				this._glInternalFormat = device.webgl2 ? gl.RGB8 : gl.RGB;
				this._glPixelType = gl.UNSIGNED_BYTE;
				break;

			case PIXELFORMAT_R8_G8_B8_A8:
				this._glFormat = gl.RGBA;
				this._glInternalFormat = device.webgl2 ? gl.RGBA8 : gl.RGBA;
				this._glPixelType = gl.UNSIGNED_BYTE;
				break;

			case PIXELFORMAT_DXT1:
				ext = device.extCompressedTextureS3TC;
				this._glFormat = gl.RGB;
				this._glInternalFormat = ext.COMPRESSED_RGB_S3TC_DXT1_EXT;
				break;

			case PIXELFORMAT_DXT3:
				ext = device.extCompressedTextureS3TC;
				this._glFormat = gl.RGBA;
				this._glInternalFormat = ext.COMPRESSED_RGBA_S3TC_DXT3_EXT;
				break;

			case PIXELFORMAT_DXT5:
				ext = device.extCompressedTextureS3TC;
				this._glFormat = gl.RGBA;
				this._glInternalFormat = ext.COMPRESSED_RGBA_S3TC_DXT5_EXT;
				break;

			case PIXELFORMAT_ETC1:
				ext = device.extCompressedTextureETC1;
				this._glFormat = gl.RGB;
				this._glInternalFormat = ext.COMPRESSED_RGB_ETC1_WEBGL;
				break;

			case PIXELFORMAT_PVRTC_2BPP_RGB_1:
				ext = device.extCompressedTexturePVRTC;
				this._glFormat = gl.RGB;
				this._glInternalFormat = ext.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
				break;

			case PIXELFORMAT_PVRTC_2BPP_RGBA_1:
				ext = device.extCompressedTexturePVRTC;
				this._glFormat = gl.RGBA;
				this._glInternalFormat = ext.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
				break;

			case PIXELFORMAT_PVRTC_4BPP_RGB_1:
				ext = device.extCompressedTexturePVRTC;
				this._glFormat = gl.RGB;
				this._glInternalFormat = ext.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
				break;

			case PIXELFORMAT_PVRTC_4BPP_RGBA_1:
				ext = device.extCompressedTexturePVRTC;
				this._glFormat = gl.RGBA;
				this._glInternalFormat = ext.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
				break;

			case PIXELFORMAT_ETC2_RGB:
				ext = device.extCompressedTextureETC;
				this._glFormat = gl.RGB;
				this._glInternalFormat = ext.COMPRESSED_RGB8_ETC2;
				break;

			case PIXELFORMAT_ETC2_RGBA:
				ext = device.extCompressedTextureETC;
				this._glFormat = gl.RGBA;
				this._glInternalFormat = ext.COMPRESSED_RGBA8_ETC2_EAC;
				break;

			case PIXELFORMAT_ASTC_4x4:
				ext = device.extCompressedTextureASTC;
				this._glFormat = gl.RGBA;
				this._glInternalFormat = ext.COMPRESSED_RGBA_ASTC_4x4_KHR;
				break;

			case PIXELFORMAT_ATC_RGB:
				ext = device.extCompressedTextureATC;
				this._glFormat = gl.RGB;
				this._glInternalFormat = ext.COMPRESSED_RGB_ATC_WEBGL;
				break;

			case PIXELFORMAT_ATC_RGBA:
				ext = device.extCompressedTextureATC;
				this._glFormat = gl.RGBA;
				this._glInternalFormat = ext.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL;
				break;

			case PIXELFORMAT_RGB16F:
				ext = device.extTextureHalfFloat;
				this._glFormat = gl.RGB;

				if (device.webgl2) {
					this._glInternalFormat = gl.RGB16F;
					this._glPixelType = gl.HALF_FLOAT;
				} else {
					this._glInternalFormat = gl.RGB;
					this._glPixelType = ext.HALF_FLOAT_OES;
				}

				break;

			case PIXELFORMAT_RGBA16F:
				ext = device.extTextureHalfFloat;
				this._glFormat = gl.RGBA;

				if (device.webgl2) {
					this._glInternalFormat = gl.RGBA16F;
					this._glPixelType = gl.HALF_FLOAT;
				} else {
					this._glInternalFormat = gl.RGBA;
					this._glPixelType = ext.HALF_FLOAT_OES;
				}

				break;

			case PIXELFORMAT_RGB32F:
				this._glFormat = gl.RGB;

				if (device.webgl2) {
					this._glInternalFormat = gl.RGB32F;
				} else {
					this._glInternalFormat = gl.RGB;
				}

				this._glPixelType = gl.FLOAT;
				break;

			case PIXELFORMAT_RGBA32F:
				this._glFormat = gl.RGBA;

				if (device.webgl2) {
					this._glInternalFormat = gl.RGBA32F;
				} else {
					this._glInternalFormat = gl.RGBA;
				}

				this._glPixelType = gl.FLOAT;
				break;

			case PIXELFORMAT_R32F:
				this._glFormat = gl.RED;
				this._glInternalFormat = gl.R32F;
				this._glPixelType = gl.FLOAT;
				break;

			case PIXELFORMAT_DEPTH:
				if (device.webgl2) {
					this._glFormat = gl.DEPTH_COMPONENT;
					this._glInternalFormat = gl.DEPTH_COMPONENT32F;
					this._glPixelType = gl.FLOAT;
				} else {
					this._glFormat = gl.DEPTH_COMPONENT;
					this._glInternalFormat = gl.DEPTH_COMPONENT;
					this._glPixelType = gl.UNSIGNED_SHORT;
				}

				break;

			case PIXELFORMAT_DEPTHSTENCIL:
				this._glFormat = gl.DEPTH_STENCIL;
				this._glInternalFormat = gl.DEPTH24_STENCIL8;
				this._glPixelType = gl.UNSIGNED_INT_24_8;
				break;

			case PIXELFORMAT_111110F:
				this._glFormat = gl.RGB;
				this._glInternalFormat = gl.R11F_G11F_B10F;
				this._glPixelType = gl.UNSIGNED_INT_10F_11F_11F_REV;
				break;

			case PIXELFORMAT_SRGB:
				this._glFormat = gl.RGB;
				this._glInternalFormat = gl.SRGB8;
				this._glPixelType = gl.UNSIGNED_BYTE;
				break;

			case PIXELFORMAT_SRGBA:
				this._glFormat = gl.RGBA;
				this._glInternalFormat = gl.SRGB8_ALPHA8;
				this._glPixelType = gl.UNSIGNED_BYTE;
				break;
		}
	}

	upload(device, texture) {
		const gl = device.gl;
		if (!texture._needsUpload && (texture._needsMipmapsUpload && texture._mipmapsUploaded || !texture.pot)) return;
		let mipLevel = 0;
		let mipObject;
		let resMult;
		const requiredMipLevels = Math.log2(Math.max(texture._width, texture._height)) + 1;

		while (texture._levels[mipLevel] || mipLevel === 0) {
			if (!texture._needsUpload && mipLevel === 0) {
				mipLevel++;
				continue;
			} else if (mipLevel && (!texture._needsMipmapsUpload || !texture._mipmaps)) {
				break;
			}

			mipObject = texture._levels[mipLevel];

			if (mipLevel === 1 && !texture._compressed && texture._levels.length < requiredMipLevels) {
				gl.generateMipmap(this._glTarget);
				texture._mipmapsUploaded = true;
			}

			if (texture._cubemap) {
				let face;

				if (device._isBrowserInterface(mipObject[0])) {
					for (face = 0; face < 6; face++) {
						if (!texture._levelsUpdated[0][face]) continue;
						let src = mipObject[face];

						if (src instanceof HTMLImageElement) {
							if (src.width > device.maxCubeMapSize || src.height > device.maxCubeMapSize) {
								src = downsampleImage(src, device.maxCubeMapSize);

								if (mipLevel === 0) {
									texture._width = src.width;
									texture._height = src.height;
								}
							}
						}

						device.setUnpackFlipY(false);
						device.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
						gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, this._glInternalFormat, this._glFormat, this._glPixelType, src);
					}
				} else {
					resMult = 1 / Math.pow(2, mipLevel);

					for (face = 0; face < 6; face++) {
						if (!texture._levelsUpdated[0][face]) continue;
						const texData = mipObject[face];

						if (texture._compressed) {
							gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, this._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), 0, texData);
						} else {
							device.setUnpackFlipY(false);
							device.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
							gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, this._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), 0, this._glFormat, this._glPixelType, texData);
						}
					}
				}
			} else if (texture._volume) {
				resMult = 1 / Math.pow(2, mipLevel);

				if (texture._compressed) {
					gl.compressedTexImage3D(gl.TEXTURE_3D, mipLevel, this._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), Math.max(texture._depth * resMult, 1), 0, mipObject);
				} else {
					device.setUnpackFlipY(false);
					device.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
					gl.texImage3D(gl.TEXTURE_3D, mipLevel, this._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), Math.max(texture._depth * resMult, 1), 0, this._glFormat, this._glPixelType, mipObject);
				}
			} else {
				if (device._isBrowserInterface(mipObject)) {
					if (mipObject instanceof HTMLImageElement) {
						if (mipObject.width > device.maxTextureSize || mipObject.height > device.maxTextureSize) {
							mipObject = downsampleImage(mipObject, device.maxTextureSize);

							if (mipLevel === 0) {
								texture._width = mipObject.width;
								texture._height = mipObject.height;
							}
						}
					}

					device.setUnpackFlipY(texture._flipY);
					device.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
					gl.texImage2D(gl.TEXTURE_2D, mipLevel, this._glInternalFormat, this._glFormat, this._glPixelType, mipObject);
				} else {
					resMult = 1 / Math.pow(2, mipLevel);

					if (texture._compressed) {
						gl.compressedTexImage2D(gl.TEXTURE_2D, mipLevel, this._glInternalFormat, Math.max(Math.floor(texture._width * resMult), 1), Math.max(Math.floor(texture._height * resMult), 1), 0, mipObject);
					} else {
						device.setUnpackFlipY(false);
						device.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
						gl.texImage2D(gl.TEXTURE_2D, mipLevel, this._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), 0, this._glFormat, this._glPixelType, mipObject);
					}
				}

				if (mipLevel === 0) {
					texture._mipmapsUploaded = false;
				} else {
					texture._mipmapsUploaded = true;
				}
			}

			mipLevel++;
		}

		if (texture._needsUpload) {
			if (texture._cubemap) {
				for (let i = 0; i < 6; i++) texture._levelsUpdated[0][i] = false;
			} else {
				texture._levelsUpdated[0] = false;
			}
		}

		if (!texture._compressed && texture._mipmaps && texture._needsMipmapsUpload && (texture.pot || device.webgl2) && texture._levels.length === 1) {
			gl.generateMipmap(this._glTarget);
			texture._mipmapsUploaded = true;
		}

		if (texture._gpuSize) {
			texture.adjustVramSizeTracking(device._vram, -texture._gpuSize);
		}

		texture._gpuSize = texture.gpuSize;
		texture.adjustVramSizeTracking(device._vram, texture._gpuSize);
	}

}

function testRenderable(gl, pixelFormat) {
	let result = true;
	const texture = gl.createTexture();
	gl.bindTexture(gl.TEXTURE_2D, texture);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, pixelFormat, null);
	const framebuffer = gl.createFramebuffer();
	gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
	gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);

	if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) {
		result = false;
	}

	gl.bindTexture(gl.TEXTURE_2D, null);
	gl.deleteTexture(texture);
	gl.bindFramebuffer(gl.FRAMEBUFFER, null);
	gl.deleteFramebuffer(framebuffer);
	return result;
}

function testTextureHalfFloatUpdatable(gl, pixelFormat) {
	let result = true;
	const texture = gl.createTexture();
	gl.bindTexture(gl.TEXTURE_2D, texture);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	const data = new Uint16Array(4 * 2 * 2);
	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, pixelFormat, data);

	if (gl.getError() !== gl.NO_ERROR) {
		result = false;
		console.log("Above error related to HALF_FLOAT_OES can be ignored, it was triggered by testing half float texture support");
	}

	gl.bindTexture(gl.TEXTURE_2D, null);
	gl.deleteTexture(texture);
	return result;
}

function testTextureFloatHighPrecision(device) {
	if (!device.textureFloatRenderable) return false;
	const test1 = createShaderFromCode(device, shaderChunks.fullscreenQuadVS, shaderChunks.precisionTestPS, "ptest1");
	const test2 = createShaderFromCode(device, shaderChunks.fullscreenQuadVS, shaderChunks.precisionTest2PS, "ptest2");
	const textureOptions = {
		format: PIXELFORMAT_RGBA32F,
		width: 1,
		height: 1,
		mipmaps: false,
		minFilter: FILTER_NEAREST,
		magFilter: FILTER_NEAREST
	};
	const tex1 = new Texture(device, textureOptions);
	tex1.name = 'testFHP';
	const targ1 = new RenderTarget({
		colorBuffer: tex1,
		depth: false
	});
	drawQuadWithShader(device, targ1, test1);
	textureOptions.format = PIXELFORMAT_R8_G8_B8_A8;
	const tex2 = new Texture(device, textureOptions);
	tex2.name = 'testFHP';
	const targ2 = new RenderTarget({
		colorBuffer: tex2,
		depth: false
	});
	device.constantTexSource.setValue(tex1);
	drawQuadWithShader(device, targ2, test2);
	const prevFramebuffer = device.activeFramebuffer;
	device.setFramebuffer(targ2._glFrameBuffer);
	const pixels = new Uint8Array(4);
	device.readPixels(0, 0, 1, 1, pixels);
	device.setFramebuffer(prevFramebuffer);
	const x = pixels[0] / 255;
	const y = pixels[1] / 255;
	const z = pixels[2] / 255;
	const w = pixels[3] / 255;
	const f = x / (256 * 256 * 256) + y / (256 * 256) + z / 256 + w;
	tex1.destroy();
	targ1.destroy();
	tex2.destroy();
	targ2.destroy();
	return f === 0;
}

class WebglGraphicsDevice extends GraphicsDevice {
	constructor(canvas, options = {}) {
		super(canvas);
		this.gl = void 0;
		this.webgl2 = void 0;
		this.defaultFramebuffer = null;
		this.updateClientRect();
		this.contextLost = false;

		this._contextLostHandler = event => {
			event.preventDefault();
			this.contextLost = true;
			this.loseContext();
			this.fire('devicelost');
		};

		this._contextRestoredHandler = () => {
			this.restoreContext();
			this.contextLost = false;
			this.fire('devicerestored');
		};

		options.stencil = true;

		if (!options.powerPreference) {
			options.powerPreference = 'high-performance';
		}

		const preferWebGl2 = options.preferWebGl2 !== undefined ? options.preferWebGl2 : true;
		const names = preferWebGl2 ? ["webgl2", "webgl", "experimental-webgl"] : ["webgl", "experimental-webgl"];
		let gl = null;

		for (let i = 0; i < names.length; i++) {
			gl = canvas.getContext(names[i], options);

			if (gl) {
				this.webgl2 = names[i] === 'webgl2';
				break;
			}
		}

		if (!gl) {
			throw new Error("WebGL not supported");
		}

		const isChrome = platform.browser && !!window.chrome;
		const isMac = platform.browser && navigator.appVersion.indexOf("Mac") !== -1;
		this.gl = gl;
		this._tempEnableSafariTextureUnitWorkaround = platform.browser && !!window.safari;
		this._tempMacChromeBlitFramebufferWorkaround = isMac && isChrome && !options.alpha;

		if (!this.webgl2) {
			setupVertexArrayObject(gl);
		}

		canvas.addEventListener("webglcontextlost", this._contextLostHandler, false);
		canvas.addEventListener("webglcontextrestored", this._contextRestoredHandler, false);
		this.initializeExtensions();
		this.initializeCapabilities();
		this.initializeRenderState();
		this.initializeContextCaches();
		this.defaultClearOptions = {
			color: [0, 0, 0, 1],
			depth: 1,
			stencil: 0,
			flags: CLEARFLAG_COLOR | CLEARFLAG_DEPTH
		};
		this.glAddress = [gl.REPEAT, gl.CLAMP_TO_EDGE, gl.MIRRORED_REPEAT];
		this.glBlendEquation = [gl.FUNC_ADD, gl.FUNC_SUBTRACT, gl.FUNC_REVERSE_SUBTRACT, this.webgl2 ? gl.MIN : this.extBlendMinmax ? this.extBlendMinmax.MIN_EXT : gl.FUNC_ADD, this.webgl2 ? gl.MAX : this.extBlendMinmax ? this.extBlendMinmax.MAX_EXT : gl.FUNC_ADD];
		this.glBlendFunction = [gl.ZERO, gl.ONE, gl.SRC_COLOR, gl.ONE_MINUS_SRC_COLOR, gl.DST_COLOR, gl.ONE_MINUS_DST_COLOR, gl.SRC_ALPHA, gl.SRC_ALPHA_SATURATE, gl.ONE_MINUS_SRC_ALPHA, gl.DST_ALPHA, gl.ONE_MINUS_DST_ALPHA];
		this.glComparison = [gl.NEVER, gl.LESS, gl.EQUAL, gl.LEQUAL, gl.GREATER, gl.NOTEQUAL, gl.GEQUAL, gl.ALWAYS];
		this.glStencilOp = [gl.KEEP, gl.ZERO, gl.REPLACE, gl.INCR, gl.INCR_WRAP, gl.DECR, gl.DECR_WRAP, gl.INVERT];
		this.glClearFlag = [0, gl.COLOR_BUFFER_BIT, gl.DEPTH_BUFFER_BIT, gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT, gl.STENCIL_BUFFER_BIT, gl.STENCIL_BUFFER_BIT | gl.COLOR_BUFFER_BIT, gl.STENCIL_BUFFER_BIT | gl.DEPTH_BUFFER_BIT, gl.STENCIL_BUFFER_BIT | gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT];
		this.glCull = [0, gl.BACK, gl.FRONT, gl.FRONT_AND_BACK];
		this.glFilter = [gl.NEAREST, gl.LINEAR, gl.NEAREST_MIPMAP_NEAREST, gl.NEAREST_MIPMAP_LINEAR, gl.LINEAR_MIPMAP_NEAREST, gl.LINEAR_MIPMAP_LINEAR];
		this.glPrimitive = [gl.POINTS, gl.LINES, gl.LINE_LOOP, gl.LINE_STRIP, gl.TRIANGLES, gl.TRIANGLE_STRIP, gl.TRIANGLE_FAN];
		this.glType = [gl.BYTE, gl.UNSIGNED_BYTE, gl.SHORT, gl.UNSIGNED_SHORT, gl.INT, gl.UNSIGNED_INT, gl.FLOAT];
		this.pcUniformType = {};
		this.pcUniformType[gl.BOOL] = UNIFORMTYPE_BOOL;
		this.pcUniformType[gl.INT] = UNIFORMTYPE_INT;
		this.pcUniformType[gl.FLOAT] = UNIFORMTYPE_FLOAT;
		this.pcUniformType[gl.FLOAT_VEC2] = UNIFORMTYPE_VEC2;
		this.pcUniformType[gl.FLOAT_VEC3] = UNIFORMTYPE_VEC3;
		this.pcUniformType[gl.FLOAT_VEC4] = UNIFORMTYPE_VEC4;
		this.pcUniformType[gl.INT_VEC2] = UNIFORMTYPE_IVEC2;
		this.pcUniformType[gl.INT_VEC3] = UNIFORMTYPE_IVEC3;
		this.pcUniformType[gl.INT_VEC4] = UNIFORMTYPE_IVEC4;
		this.pcUniformType[gl.BOOL_VEC2] = UNIFORMTYPE_BVEC2;
		this.pcUniformType[gl.BOOL_VEC3] = UNIFORMTYPE_BVEC3;
		this.pcUniformType[gl.BOOL_VEC4] = UNIFORMTYPE_BVEC4;
		this.pcUniformType[gl.FLOAT_MAT2] = UNIFORMTYPE_MAT2;
		this.pcUniformType[gl.FLOAT_MAT3] = UNIFORMTYPE_MAT3;
		this.pcUniformType[gl.FLOAT_MAT4] = UNIFORMTYPE_MAT4;
		this.pcUniformType[gl.SAMPLER_2D] = UNIFORMTYPE_TEXTURE2D;
		this.pcUniformType[gl.SAMPLER_CUBE] = UNIFORMTYPE_TEXTURECUBE;

		if (this.webgl2) {
			this.pcUniformType[gl.SAMPLER_2D_SHADOW] = UNIFORMTYPE_TEXTURE2D_SHADOW;
			this.pcUniformType[gl.SAMPLER_CUBE_SHADOW] = UNIFORMTYPE_TEXTURECUBE_SHADOW;
			this.pcUniformType[gl.SAMPLER_3D] = UNIFORMTYPE_TEXTURE3D;
		}

		this.targetToSlot = {};
		this.targetToSlot[gl.TEXTURE_2D] = 0;
		this.targetToSlot[gl.TEXTURE_CUBE_MAP] = 1;
		this.targetToSlot[gl.TEXTURE_3D] = 2;
		let scopeX, scopeY, scopeZ, scopeW;
		let uniformValue;
		this.commitFunction = [];

		this.commitFunction[UNIFORMTYPE_BOOL] = function (uniform, value) {
			if (uniform.value !== value) {
				gl.uniform1i(uniform.locationId, value);
				uniform.value = value;
			}
		};

		this.commitFunction[UNIFORMTYPE_INT] = this.commitFunction[UNIFORMTYPE_BOOL];

		this.commitFunction[UNIFORMTYPE_FLOAT] = function (uniform, value) {
			if (uniform.value !== value) {
				gl.uniform1f(uniform.locationId, value);
				uniform.value = value;
			}
		};

		this.commitFunction[UNIFORMTYPE_VEC2] = function (uniform, value) {
			uniformValue = uniform.value;
			scopeX = value[0];
			scopeY = value[1];

			if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY) {
				gl.uniform2fv(uniform.locationId, value);
				uniformValue[0] = scopeX;
				uniformValue[1] = scopeY;
			}
		};

		this.commitFunction[UNIFORMTYPE_VEC3] = function (uniform, value) {
			uniformValue = uniform.value;
			scopeX = value[0];
			scopeY = value[1];
			scopeZ = value[2];

			if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ) {
				gl.uniform3fv(uniform.locationId, value);
				uniformValue[0] = scopeX;
				uniformValue[1] = scopeY;
				uniformValue[2] = scopeZ;
			}
		};

		this.commitFunction[UNIFORMTYPE_VEC4] = function (uniform, value) {
			uniformValue = uniform.value;
			scopeX = value[0];
			scopeY = value[1];
			scopeZ = value[2];
			scopeW = value[3];

			if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ || uniformValue[3] !== scopeW) {
				gl.uniform4fv(uniform.locationId, value);
				uniformValue[0] = scopeX;
				uniformValue[1] = scopeY;
				uniformValue[2] = scopeZ;
				uniformValue[3] = scopeW;
			}
		};

		this.commitFunction[UNIFORMTYPE_IVEC2] = function (uniform, value) {
			uniformValue = uniform.value;
			scopeX = value[0];
			scopeY = value[1];

			if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY) {
				gl.uniform2iv(uniform.locationId, value);
				uniformValue[0] = scopeX;
				uniformValue[1] = scopeY;
			}
		};

		this.commitFunction[UNIFORMTYPE_BVEC2] = this.commitFunction[UNIFORMTYPE_IVEC2];

		this.commitFunction[UNIFORMTYPE_IVEC3] = function (uniform, value) {
			uniformValue = uniform.value;
			scopeX = value[0];
			scopeY = value[1];
			scopeZ = value[2];

			if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ) {
				gl.uniform3iv(uniform.locationId, value);
				uniformValue[0] = scopeX;
				uniformValue[1] = scopeY;
				uniformValue[2] = scopeZ;
			}
		};

		this.commitFunction[UNIFORMTYPE_BVEC3] = this.commitFunction[UNIFORMTYPE_IVEC3];

		this.commitFunction[UNIFORMTYPE_IVEC4] = function (uniform, value) {
			uniformValue = uniform.value;
			scopeX = value[0];
			scopeY = value[1];
			scopeZ = value[2];
			scopeW = value[3];

			if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ || uniformValue[3] !== scopeW) {
				gl.uniform4iv(uniform.locationId, value);
				uniformValue[0] = scopeX;
				uniformValue[1] = scopeY;
				uniformValue[2] = scopeZ;
				uniformValue[3] = scopeW;
			}
		};

		this.commitFunction[UNIFORMTYPE_BVEC4] = this.commitFunction[UNIFORMTYPE_IVEC4];

		this.commitFunction[UNIFORMTYPE_MAT2] = function (uniform, value) {
			gl.uniformMatrix2fv(uniform.locationId, false, value);
		};

		this.commitFunction[UNIFORMTYPE_MAT3] = function (uniform, value) {
			gl.uniformMatrix3fv(uniform.locationId, false, value);
		};

		this.commitFunction[UNIFORMTYPE_MAT4] = function (uniform, value) {
			gl.uniformMatrix4fv(uniform.locationId, false, value);
		};

		this.commitFunction[UNIFORMTYPE_FLOATARRAY] = function (uniform, value) {
			gl.uniform1fv(uniform.locationId, value);
		};

		this.commitFunction[UNIFORMTYPE_VEC2ARRAY] = function (uniform, value) {
			gl.uniform2fv(uniform.locationId, value);
		};

		this.commitFunction[UNIFORMTYPE_VEC3ARRAY] = function (uniform, value) {
			gl.uniform3fv(uniform.locationId, value);
		};

		this.commitFunction[UNIFORMTYPE_VEC4ARRAY] = function (uniform, value) {
			gl.uniform4fv(uniform.locationId, value);
		};

		this.supportsBoneTextures = this.extTextureFloat && this.maxVertexTextures > 0;
		let numUniforms = this.vertexUniformsCount;
		numUniforms -= 4 * 4;
		numUniforms -= 8;
		numUniforms -= 1;
		numUniforms -= 4 * 4;
		this.boneLimit = Math.floor(numUniforms / 3);
		this.boneLimit = Math.min(this.boneLimit, 128);

		if (this.unmaskedRenderer === 'Mali-450 MP') {
			this.boneLimit = 34;
		}

		this.constantTexSource = this.scope.resolve("source");

		if (this.extTextureFloat) {
			if (this.webgl2) {
				this.textureFloatRenderable = !!this.extColorBufferFloat;
			} else {
				this.textureFloatRenderable = testRenderable(gl, gl.FLOAT);
			}
		} else {
			this.textureFloatRenderable = false;
		}

		if (this.extColorBufferHalfFloat) {
			this.textureHalfFloatRenderable = !!this.extColorBufferHalfFloat;
		} else if (this.extTextureHalfFloat) {
			if (this.webgl2) {
				this.textureHalfFloatRenderable = !!this.extColorBufferFloat;
			} else {
				this.textureHalfFloatRenderable = testRenderable(gl, this.extTextureHalfFloat.HALF_FLOAT_OES);
			}
		} else {
			this.textureHalfFloatRenderable = false;
		}

		this.supportsMorphTargetTexturesCore = this.maxPrecision === "highp" && this.maxVertexTextures >= 2;
		this._textureFloatHighPrecision = undefined;
		this._textureHalfFloatUpdatable = undefined;
		this.grabPassAvailable = true;
		this.grabPass = new GrabPass(this, options.alpha);
		this.grabPass.create();
		this.areaLightLutFormat = PIXELFORMAT_R8_G8_B8_A8;

		if (this.extTextureHalfFloat && this.textureHalfFloatUpdatable && this.extTextureHalfFloatLinear) {
			this.areaLightLutFormat = PIXELFORMAT_RGBA16F;
		} else if (this.extTextureFloat && this.extTextureFloatLinear) {
			this.areaLightLutFormat = PIXELFORMAT_RGBA32F;
		}
	}

	destroy() {
		super.destroy();
		const gl = this.gl;
		this.grabPass.destroy();

		if (this.webgl2 && this.feedback) {
			gl.deleteTransformFeedback(this.feedback);
		}

		this.clearShaderCache();
		this.clearVertexArrayObjectCache();
		this.canvas.removeEventListener('webglcontextlost', this._contextLostHandler, false);
		this.canvas.removeEventListener('webglcontextrestored', this._contextRestoredHandler, false);
		this._contextLostHandler = null;
		this._contextRestoredHandler = null;
		this.gl = null;
		super.postDestroy();
	}

	createVertexBufferImpl(vertexBuffer, format) {
		return new WebglVertexBuffer();
	}

	createIndexBufferImpl(indexBuffer) {
		return new WebglIndexBuffer(indexBuffer);
	}

	createShaderImpl(shader) {
		return new WebglShader(shader);
	}

	createTextureImpl(texture) {
		return new WebglTexture(texture);
	}

	getPrecision() {
		const gl = this.gl;
		let precision = "highp";

		if (gl.getShaderPrecisionFormat) {
			const vertexShaderPrecisionHighpFloat = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT);
			const vertexShaderPrecisionMediumpFloat = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT);
			const fragmentShaderPrecisionHighpFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
			const fragmentShaderPrecisionMediumpFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT);
			const highpAvailable = vertexShaderPrecisionHighpFloat.precision > 0 && fragmentShaderPrecisionHighpFloat.precision > 0;
			const mediumpAvailable = vertexShaderPrecisionMediumpFloat.precision > 0 && fragmentShaderPrecisionMediumpFloat.precision > 0;

			if (!highpAvailable) {
				if (mediumpAvailable) {
					precision = "mediump";
				} else {
					precision = "lowp";
				}
			}
		}

		return precision;
	}

	initializeExtensions() {
		const gl = this.gl;
		const supportedExtensions = gl.getSupportedExtensions();

		const getExtension = function getExtension() {
			for (let i = 0; i < arguments.length; i++) {
				if (supportedExtensions.indexOf(arguments[i]) !== -1) {
					return gl.getExtension(arguments[i]);
				}
			}

			return null;
		};

		if (this.webgl2) {
			this.extBlendMinmax = true;
			this.extDrawBuffers = true;
			this.extInstancing = true;
			this.extStandardDerivatives = true;
			this.extTextureFloat = true;
			this.extTextureHalfFloat = true;
			this.extTextureLod = true;
			this.extUintElement = true;
			this.extVertexArrayObject = true;
			this.extColorBufferFloat = getExtension('EXT_color_buffer_float');
			this.extDisjointTimerQuery = getExtension('EXT_disjoint_timer_query_webgl2', 'EXT_disjoint_timer_query');
		} else {
			this.extBlendMinmax = getExtension("EXT_blend_minmax");
			this.extDrawBuffers = getExtension('EXT_draw_buffers');
			this.extInstancing = getExtension("ANGLE_instanced_arrays");

			if (this.extInstancing) {
				const ext = this.extInstancing;
				gl.drawArraysInstanced = ext.drawArraysInstancedANGLE.bind(ext);
				gl.drawElementsInstanced = ext.drawElementsInstancedANGLE.bind(ext);
				gl.vertexAttribDivisor = ext.vertexAttribDivisorANGLE.bind(ext);
			}

			this.extStandardDerivatives = getExtension("OES_standard_derivatives");
			this.extTextureFloat = getExtension("OES_texture_float");
			this.extTextureHalfFloat = getExtension("OES_texture_half_float");
			this.extTextureLod = getExtension('EXT_shader_texture_lod');
			this.extUintElement = getExtension("OES_element_index_uint");
			this.extVertexArrayObject = getExtension("OES_vertex_array_object");

			if (this.extVertexArrayObject) {
				const ext = this.extVertexArrayObject;
				gl.createVertexArray = ext.createVertexArrayOES.bind(ext);
				gl.deleteVertexArray = ext.deleteVertexArrayOES.bind(ext);
				gl.isVertexArray = ext.isVertexArrayOES.bind(ext);
				gl.bindVertexArray = ext.bindVertexArrayOES.bind(ext);
			}

			this.extColorBufferFloat = null;
			this.extDisjointTimerQuery = null;
		}

		this.extDebugRendererInfo = getExtension('WEBGL_debug_renderer_info');
		this.extTextureFloatLinear = getExtension("OES_texture_float_linear");
		this.extTextureHalfFloatLinear = getExtension("OES_texture_half_float_linear");
		this.extFloatBlend = getExtension("EXT_float_blend");
		this.extTextureFilterAnisotropic = getExtension('EXT_texture_filter_anisotropic', 'WEBKIT_EXT_texture_filter_anisotropic');
		this.extCompressedTextureETC1 = getExtension('WEBGL_compressed_texture_etc1');
		this.extCompressedTextureETC = getExtension('WEBGL_compressed_texture_etc');
		this.extCompressedTexturePVRTC = getExtension('WEBGL_compressed_texture_pvrtc', 'WEBKIT_WEBGL_compressed_texture_pvrtc');
		this.extCompressedTextureS3TC = getExtension('WEBGL_compressed_texture_s3tc', 'WEBKIT_WEBGL_compressed_texture_s3tc');
		this.extCompressedTextureATC = getExtension('WEBGL_compressed_texture_atc');
		this.extCompressedTextureASTC = getExtension('WEBGL_compressed_texture_astc');
		this.extParallelShaderCompile = getExtension('KHR_parallel_shader_compile');
		this.extColorBufferHalfFloat = getExtension("EXT_color_buffer_half_float");
		this.supportsInstancing = !!this.extInstancing;
	}

	initializeCapabilities() {
		const gl = this.gl;
		let ext;
		this.maxPrecision = this.precision = this.getPrecision();
		const contextAttribs = gl.getContextAttributes();
		this.supportsMsaa = contextAttribs.antialias;
		this.supportsStencil = contextAttribs.stencil;
		this.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
		this.maxCubeMapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
		this.maxRenderBufferSize = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);
		this.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
		this.maxCombinedTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
		this.maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
		this.vertexUniformsCount = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
		this.fragmentUniformsCount = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);

		if (this.webgl2) {
			this.maxDrawBuffers = gl.getParameter(gl.MAX_DRAW_BUFFERS);
			this.maxColorAttachments = gl.getParameter(gl.MAX_COLOR_ATTACHMENTS);
			this.maxVolumeSize = gl.getParameter(gl.MAX_3D_TEXTURE_SIZE);
		} else {
			ext = this.extDrawBuffers;
			this.maxDrawBuffers = ext ? gl.getParameter(ext.MAX_DRAW_BUFFERS_EXT) : 1;
			this.maxColorAttachments = ext ? gl.getParameter(ext.MAX_COLOR_ATTACHMENTS_EXT) : 1;
			this.maxVolumeSize = 1;
		}

		ext = this.extDebugRendererInfo;
		this.unmaskedRenderer = ext ? gl.getParameter(ext.UNMASKED_RENDERER_WEBGL) : '';
		this.unmaskedVendor = ext ? gl.getParameter(ext.UNMASKED_VENDOR_WEBGL) : '';
		ext = this.extTextureFilterAnisotropic;
		this.maxAnisotropy = ext ? gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1;
		this.samples = gl.getParameter(gl.SAMPLES);
		this.maxSamples = this.webgl2 ? gl.getParameter(gl.MAX_SAMPLES) : 1;
		this.supportsAreaLights = this.webgl2 || !platform.android;

		if (this.maxTextures <= 8) {
			this.supportsAreaLights = false;
		}
	}

	initializeRenderState() {
		const gl = this.gl;
		this.blending = false;
		gl.disable(gl.BLEND);
		this.blendSrc = BLENDMODE_ONE;
		this.blendDst = BLENDMODE_ZERO;
		this.blendSrcAlpha = BLENDMODE_ONE;
		this.blendDstAlpha = BLENDMODE_ZERO;
		this.separateAlphaBlend = false;
		this.blendEquation = BLENDEQUATION_ADD;
		this.blendAlphaEquation = BLENDEQUATION_ADD;
		this.separateAlphaEquation = false;
		gl.blendFunc(gl.ONE, gl.ZERO);
		gl.blendEquation(gl.FUNC_ADD);
		this.writeRed = true;
		this.writeGreen = true;
		this.writeBlue = true;
		this.writeAlpha = true;
		gl.colorMask(true, true, true, true);
		this.cullMode = CULLFACE_BACK;
		gl.enable(gl.CULL_FACE);
		gl.cullFace(gl.BACK);
		this.depthTest = true;
		gl.enable(gl.DEPTH_TEST);
		this.depthFunc = FUNC_LESSEQUAL;
		gl.depthFunc(gl.LEQUAL);
		this.depthWrite = true;
		gl.depthMask(true);
		this.stencil = false;
		gl.disable(gl.STENCIL_TEST);
		this.stencilFuncFront = this.stencilFuncBack = FUNC_ALWAYS;
		this.stencilRefFront = this.stencilRefBack = 0;
		this.stencilMaskFront = this.stencilMaskBack = 0xFF;
		gl.stencilFunc(gl.ALWAYS, 0, 0xFF);
		this.stencilFailFront = this.stencilFailBack = STENCILOP_KEEP;
		this.stencilZfailFront = this.stencilZfailBack = STENCILOP_KEEP;
		this.stencilZpassFront = this.stencilZpassBack = STENCILOP_KEEP;
		this.stencilWriteMaskFront = 0xFF;
		this.stencilWriteMaskBack = 0xFF;
		gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
		gl.stencilMask(0xFF);
		this.alphaToCoverage = false;
		this.raster = true;

		if (this.webgl2) {
			gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
			gl.disable(gl.RASTERIZER_DISCARD);
		}

		this.depthBiasEnabled = false;
		gl.disable(gl.POLYGON_OFFSET_FILL);
		this.clearDepth = 1;
		gl.clearDepth(1);
		this.clearRed = 0;
		this.clearBlue = 0;
		this.clearGreen = 0;
		this.clearAlpha = 0;
		gl.clearColor(0, 0, 0, 0);
		this.clearStencil = 0;
		gl.clearStencil(0);
		this.vx = this.vy = this.vw = this.vh = 0;
		this.sx = this.sy = this.sw = this.sh = 0;

		if (this.webgl2) {
			gl.hint(gl.FRAGMENT_SHADER_DERIVATIVE_HINT, gl.NICEST);
		} else {
			if (this.extStandardDerivatives) {
				gl.hint(this.extStandardDerivatives.FRAGMENT_SHADER_DERIVATIVE_HINT_OES, gl.NICEST);
			}
		}

		gl.enable(gl.SCISSOR_TEST);
		gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
		this.unpackFlipY = false;
		gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
		this.unpackPremultiplyAlpha = false;
		gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
		gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
	}

	initializeContextCaches() {
		super.initializeContextCaches();
		this.vertexShaderCache = {};
		this.fragmentShaderCache = {};
		this._vaoMap = new Map();
		this.boundVao = null;
		this.activeFramebuffer = null;
		this.feedback = null;
		this.transformFeedbackBuffer = null;
		this.textureUnit = 0;
		this.textureUnits = [];

		for (let i = 0; i < this.maxCombinedTextures; i++) {
			this.textureUnits.push([null, null, null]);
		}
	}

	loseContext() {
		for (const shader of this.shaders) {
			shader.loseContext();
		}

		this.grabPass.destroy();

		for (const texture of this.textures) {
			texture.loseContext();
		}

		for (const buffer of this.buffers) {
			buffer.loseContext();
		}

		for (const target of this.targets) {
			target.loseContext();
		}
	}

	restoreContext() {
		this.initializeExtensions();
		this.initializeCapabilities();
		this.initializeRenderState();
		this.initializeContextCaches();

		for (const shader of this.shaders) {
			shader.restoreContext();
		}

		for (const buffer of this.buffers) {
			buffer.unlock();
		}

		this.grabPass.create();
	}

	setViewport(x, y, w, h) {
		if (this.vx !== x || this.vy !== y || this.vw !== w || this.vh !== h) {
			this.gl.viewport(x, y, w, h);
			this.vx = x;
			this.vy = y;
			this.vw = w;
			this.vh = h;
		}
	}

	setScissor(x, y, w, h) {
		if (this.sx !== x || this.sy !== y || this.sw !== w || this.sh !== h) {
			this.gl.scissor(x, y, w, h);
			this.sx = x;
			this.sy = y;
			this.sw = w;
			this.sh = h;
		}
	}

	setFramebuffer(fb) {
		if (this.activeFramebuffer !== fb) {
			const gl = this.gl;
			gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
			this.activeFramebuffer = fb;
		}
	}

	_checkFbo() {
		const gl = this.gl;
		const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

		switch (status) {
			case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
				console.error("ERROR: FRAMEBUFFER_INCOMPLETE_ATTACHMENT");
				break;

			case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
				console.error("ERROR: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
				break;

			case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
				console.error("ERROR: FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
				break;

			case gl.FRAMEBUFFER_UNSUPPORTED:
				console.error("ERROR: FRAMEBUFFER_UNSUPPORTED");
				break;

			case gl.FRAMEBUFFER_COMPLETE:
				break;
		}
	}

	copyRenderTarget(source, dest, color, depth) {
		const gl = this.gl;

		if (!this.webgl2 && depth) {
			return false;
		}

		if (color) {
			if (!dest) {
				if (!source._colorBuffer) {
					return false;
				}
			} else {
				if (!source._colorBuffer || !dest._colorBuffer) {
					return false;
				}

				if (source._colorBuffer._format !== dest._colorBuffer._format) {
					return false;
				}
			}
		}

		if (depth) {
			if (!source._depthBuffer || !dest._depthBuffer) {
				return false;
			}

			if (source._depthBuffer._format !== dest._depthBuffer._format) {
				return false;
			}
		}

		if (this.webgl2 && dest) {
			const prevRt = this.renderTarget;
			this.renderTarget = dest;
			this.updateBegin();
			gl.bindFramebuffer(gl.READ_FRAMEBUFFER, source ? source._glFrameBuffer : null);
			gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, dest._glFrameBuffer);
			const w = source ? source.width : dest.width;
			const h = source ? source.height : dest.height;
			gl.blitFramebuffer(0, 0, w, h, 0, 0, w, h, (color ? gl.COLOR_BUFFER_BIT : 0) | (depth ? gl.DEPTH_BUFFER_BIT : 0), gl.NEAREST);
			this.renderTarget = prevRt;
			gl.bindFramebuffer(gl.FRAMEBUFFER, prevRt ? prevRt._glFrameBuffer : null);
		} else {
			const shader = this.getCopyShader();
			this.constantTexSource.setValue(source._colorBuffer);
			drawQuadWithShader(this, dest, shader);
		}

		return true;
	}

	initRenderTarget(target) {
		if (target._glFrameBuffer) return;
		const gl = this.gl;
		target._glFrameBuffer = gl.createFramebuffer();
		this.setFramebuffer(target._glFrameBuffer);
		const colorBuffer = target._colorBuffer;

		if (colorBuffer) {
			if (!colorBuffer.impl._glTexture) {
				colorBuffer._width = Math.min(colorBuffer.width, this.maxRenderBufferSize);
				colorBuffer._height = Math.min(colorBuffer.height, this.maxRenderBufferSize);
				this.setTexture(colorBuffer, 0);
			}

			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, colorBuffer._cubemap ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + target._face : gl.TEXTURE_2D, colorBuffer.impl._glTexture, 0);
		}

		const depthBuffer = target._depthBuffer;

		if (depthBuffer && this.webgl2) {
			if (!depthBuffer.impl._glTexture) {
				depthBuffer._width = Math.min(depthBuffer.width, this.maxRenderBufferSize);
				depthBuffer._height = Math.min(depthBuffer.height, this.maxRenderBufferSize);
				this.setTexture(depthBuffer, 0);
			}

			if (target._stencil) {
				gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, depthBuffer._cubemap ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + target._face : gl.TEXTURE_2D, target._depthBuffer.impl._glTexture, 0);
			} else {
				gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, depthBuffer._cubemap ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + target._face : gl.TEXTURE_2D, target._depthBuffer.impl._glTexture, 0);
			}
		} else if (target._depth) {
			const willRenderMsaa = target._samples > 1 && this.webgl2;

			if (!willRenderMsaa) {
				if (!target._glDepthBuffer) {
					target._glDepthBuffer = gl.createRenderbuffer();
				}

				gl.bindRenderbuffer(gl.RENDERBUFFER, target._glDepthBuffer);

				if (target._stencil) {
					gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, target.width, target.height);
					gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, target._glDepthBuffer);
				} else {
					const depthFormat = this.webgl2 ? gl.DEPTH_COMPONENT32F : gl.DEPTH_COMPONENT16;
					gl.renderbufferStorage(gl.RENDERBUFFER, depthFormat, target.width, target.height);
					gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, target._glDepthBuffer);
				}

				gl.bindRenderbuffer(gl.RENDERBUFFER, null);
			}
		}

		if (this.webgl2 && target._samples > 1) {
			target._glResolveFrameBuffer = target._glFrameBuffer;
			target._glFrameBuffer = gl.createFramebuffer();
			this.setFramebuffer(target._glFrameBuffer);

			if (colorBuffer) {
				if (!target._glMsaaColorBuffer) {
					target._glMsaaColorBuffer = gl.createRenderbuffer();
				}

				gl.bindRenderbuffer(gl.RENDERBUFFER, target._glMsaaColorBuffer);
				gl.renderbufferStorageMultisample(gl.RENDERBUFFER, target._samples, colorBuffer.impl._glInternalFormat, target.width, target.height);
				gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, target._glMsaaColorBuffer);
			}

			if (target._depth) {
				if (!target._glMsaaDepthBuffer) {
					target._glMsaaDepthBuffer = gl.createRenderbuffer();
				}

				gl.bindRenderbuffer(gl.RENDERBUFFER, target._glMsaaDepthBuffer);

				if (target._stencil) {
					gl.renderbufferStorageMultisample(gl.RENDERBUFFER, target._samples, gl.DEPTH24_STENCIL8, target.width, target.height);
					gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, target._glMsaaDepthBuffer);
				} else {
					gl.renderbufferStorageMultisample(gl.RENDERBUFFER, target._samples, gl.DEPTH_COMPONENT32F, target.width, target.height);
					gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, target._glMsaaDepthBuffer);
				}
			}
		}

		this.targets.push(target);
	}

	getCopyShader() {
		if (!this._copyShader) {
			const vs = shaderChunks.fullscreenQuadVS;
			const fs = shaderChunks.outputTex2DPS;
			this._copyShader = createShaderFromCode(this, vs, fs, "outputTex2D");
		}

		return this._copyShader;
	}

	updateBegin() {
		this.boundVao = null;

		if (this._tempEnableSafariTextureUnitWorkaround) {
			for (let unit = 0; unit < this.textureUnits.length; ++unit) {
				for (let slot = 0; slot < 3; ++slot) {
					this.textureUnits[unit][slot] = null;
				}
			}
		}

		const target = this.renderTarget;

		if (target) {
			if (!target._glFrameBuffer) {
				this.initRenderTarget(target);
			} else {
				this.setFramebuffer(target._glFrameBuffer);
			}
		} else {
			this.setFramebuffer(this.defaultFramebuffer);
		}
	}

	updateEnd() {
		const gl = this.gl;

		if (this.boundVao) {
			this.boundVao = null;
			this.gl.bindVertexArray(null);
		}

		const target = this.renderTarget;

		if (target) {
			const colorBuffer = target._colorBuffer;

			if (colorBuffer && colorBuffer.impl._glTexture && colorBuffer.mipmaps && (colorBuffer.pot || this.webgl2)) {
				this.activeTexture(this.maxCombinedTextures - 1);
				this.bindTexture(colorBuffer);
				gl.generateMipmap(colorBuffer.impl._glTarget);
			}

			if (this.webgl2 && target._samples > 1 && target.autoResolve) {
				target.resolve();
			}
		}
	}

	setUnpackFlipY(flipY) {
		if (this.unpackFlipY !== flipY) {
			this.unpackFlipY = flipY;
			const gl = this.gl;
			gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
		}
	}

	setUnpackPremultiplyAlpha(premultiplyAlpha) {
		if (this.unpackPremultiplyAlpha !== premultiplyAlpha) {
			this.unpackPremultiplyAlpha = premultiplyAlpha;
			const gl = this.gl;
			gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiplyAlpha);
		}
	}

	activeTexture(textureUnit) {
		if (this.textureUnit !== textureUnit) {
			this.gl.activeTexture(this.gl.TEXTURE0 + textureUnit);
			this.textureUnit = textureUnit;
		}
	}

	bindTexture(texture) {
		const impl = texture.impl;
		const textureTarget = impl._glTarget;
		const textureObject = impl._glTexture;
		const textureUnit = this.textureUnit;
		const slot = this.targetToSlot[textureTarget];

		if (this.textureUnits[textureUnit][slot] !== textureObject) {
			this.gl.bindTexture(textureTarget, textureObject);
			this.textureUnits[textureUnit][slot] = textureObject;
		}
	}

	bindTextureOnUnit(texture, textureUnit) {
		const impl = texture.impl;
		const textureTarget = impl._glTarget;
		const textureObject = impl._glTexture;
		const slot = this.targetToSlot[textureTarget];

		if (this.textureUnits[textureUnit][slot] !== textureObject) {
			this.activeTexture(textureUnit);
			this.gl.bindTexture(textureTarget, textureObject);
			this.textureUnits[textureUnit][slot] = textureObject;
		}
	}

	setTextureParameters(texture) {
		const gl = this.gl;
		const flags = texture._parameterFlags;
		const target = texture.impl._glTarget;

		if (flags & 1) {
			let filter = texture._minFilter;

			if (!texture.pot && !this.webgl2 || !texture._mipmaps || texture._compressed && texture._levels.length === 1) {
				if (filter === FILTER_NEAREST_MIPMAP_NEAREST || filter === FILTER_NEAREST_MIPMAP_LINEAR) {
					filter = FILTER_NEAREST;
				} else if (filter === FILTER_LINEAR_MIPMAP_NEAREST || filter === FILTER_LINEAR_MIPMAP_LINEAR) {
					filter = FILTER_LINEAR;
				}
			}

			gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, this.glFilter[filter]);
		}

		if (flags & 2) {
			gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, this.glFilter[texture._magFilter]);
		}

		if (flags & 4) {
			if (this.webgl2) {
				gl.texParameteri(target, gl.TEXTURE_WRAP_S, this.glAddress[texture._addressU]);
			} else {
				gl.texParameteri(target, gl.TEXTURE_WRAP_S, this.glAddress[texture.pot ? texture._addressU : ADDRESS_CLAMP_TO_EDGE]);
			}
		}

		if (flags & 8) {
			if (this.webgl2) {
				gl.texParameteri(target, gl.TEXTURE_WRAP_T, this.glAddress[texture._addressV]);
			} else {
				gl.texParameteri(target, gl.TEXTURE_WRAP_T, this.glAddress[texture.pot ? texture._addressV : ADDRESS_CLAMP_TO_EDGE]);
			}
		}

		if (flags & 16) {
			if (this.webgl2) {
				gl.texParameteri(target, gl.TEXTURE_WRAP_R, this.glAddress[texture._addressW]);
			}
		}

		if (flags & 32) {
			if (this.webgl2) {
				gl.texParameteri(target, gl.TEXTURE_COMPARE_MODE, texture._compareOnRead ? gl.COMPARE_REF_TO_TEXTURE : gl.NONE);
			}
		}

		if (flags & 64) {
			if (this.webgl2) {
				gl.texParameteri(target, gl.TEXTURE_COMPARE_FUNC, this.glComparison[texture._compareFunc]);
			}
		}

		if (flags & 128) {
			const ext = this.extTextureFilterAnisotropic;

			if (ext) {
				gl.texParameterf(target, ext.TEXTURE_MAX_ANISOTROPY_EXT, Math.max(1, Math.min(Math.round(texture._anisotropy), this.maxAnisotropy)));
			}
		}
	}

	setTexture(texture, textureUnit) {
		if (!texture.impl._glTexture) texture.impl.initialize(this, texture);

		if (texture._parameterFlags > 0 || texture._needsUpload || texture._needsMipmapsUpload || texture === this.grabPass.texture) {
			this.activeTexture(textureUnit);
			this.bindTexture(texture);

			if (texture._parameterFlags) {
				this.setTextureParameters(texture);
				texture._parameterFlags = 0;
			}

			const processed = texture === this.grabPass.texture && this.grabPass.prepareTexture();

			if (!processed && (texture._needsUpload || texture._needsMipmapsUpload)) {
				texture.impl.upload(this, texture);
				texture._needsUpload = false;
				texture._needsMipmapsUpload = false;
			}
		} else {
			this.bindTextureOnUnit(texture, textureUnit);
		}
	}

	createVertexArray(vertexBuffers) {
		let key, vao;
		const useCache = vertexBuffers.length > 1;

		if (useCache) {
			key = "";

			for (let i = 0; i < vertexBuffers.length; i++) {
				const vertexBuffer = vertexBuffers[i];
				key += vertexBuffer.id + vertexBuffer.format.renderingingHash;
			}

			vao = this._vaoMap.get(key);
		}

		if (!vao) {
			const gl = this.gl;
			vao = gl.createVertexArray();
			gl.bindVertexArray(vao);
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

			for (let i = 0; i < vertexBuffers.length; i++) {
				const vertexBuffer = vertexBuffers[i];
				gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer.impl.bufferId);
				const elements = vertexBuffer.format.elements;

				for (let j = 0; j < elements.length; j++) {
					const e = elements[j];
					const loc = semanticToLocation[e.name];

					gl.vertexAttribPointer(loc, e.numComponents, this.glType[e.dataType], e.normalize, e.stride, e.offset);
					gl.enableVertexAttribArray(loc);

					if (vertexBuffer.instancing) {
						gl.vertexAttribDivisor(loc, 1);
					}
				}
			}

			gl.bindVertexArray(null);
			gl.bindBuffer(gl.ARRAY_BUFFER, null);

			if (useCache) {
				this._vaoMap.set(key, vao);
			}
		}

		return vao;
	}

	setBuffers() {
		const gl = this.gl;
		let vao;

		if (this.vertexBuffers.length === 1) {
			const vertexBuffer = this.vertexBuffers[0];

			if (!vertexBuffer.impl.vao) {
				vertexBuffer.impl.vao = this.createVertexArray(this.vertexBuffers);
			}

			vao = vertexBuffer.impl.vao;
		} else {
			vao = this.createVertexArray(this.vertexBuffers);
		}

		if (this.boundVao !== vao) {
			this.boundVao = vao;
			gl.bindVertexArray(vao);
		}

		this.vertexBuffers.length = 0;
		const bufferId = this.indexBuffer ? this.indexBuffer.impl.bufferId : null;
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufferId);
	}

	draw(primitive, numInstances, keepBuffers) {
		const gl = this.gl;
		let sampler, samplerValue, texture, numTextures;
		let uniform, scopeId, uniformVersion, programVersion;
		const shader = this.shader;
		if (!shader) return;
		const samplers = shader.samplers;
		const uniforms = shader.uniforms;

		if (!keepBuffers) {
			this.setBuffers();
		}

		let textureUnit = 0;

		for (let i = 0, len = samplers.length; i < len; i++) {
			sampler = samplers[i];
			samplerValue = sampler.scopeId.value;

			if (!samplerValue) {
				continue;
			}

			if (samplerValue instanceof Texture) {
				texture = samplerValue;
				this.setTexture(texture, textureUnit);

				if (sampler.slot !== textureUnit) {
					gl.uniform1i(sampler.locationId, textureUnit);
					sampler.slot = textureUnit;
				}

				textureUnit++;
			} else {
				sampler.array.length = 0;
				numTextures = samplerValue.length;

				for (let j = 0; j < numTextures; j++) {
					texture = samplerValue[j];
					this.setTexture(texture, textureUnit);
					sampler.array[j] = textureUnit;
					textureUnit++;
				}

				gl.uniform1iv(sampler.locationId, sampler.array);
			}
		}

		for (let i = 0, len = uniforms.length; i < len; i++) {
			uniform = uniforms[i];
			scopeId = uniform.scopeId;
			uniformVersion = uniform.version;
			programVersion = scopeId.versionObject.version;

			if (uniformVersion.globalId !== programVersion.globalId || uniformVersion.revision !== programVersion.revision) {
				uniformVersion.globalId = programVersion.globalId;
				uniformVersion.revision = programVersion.revision;

				if (scopeId.value !== null) {
					this.commitFunction[uniform.dataType](uniform, scopeId.value);
				}
			}
		}

		if (this.webgl2 && this.transformFeedbackBuffer) {
			gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, this.transformFeedbackBuffer.impl.bufferId);
			gl.beginTransformFeedback(gl.POINTS);
		}

		const mode = this.glPrimitive[primitive.type];
		const count = primitive.count;

		if (primitive.indexed) {
			const indexBuffer = this.indexBuffer;
			const format = indexBuffer.impl.glFormat;
			const offset = primitive.base * indexBuffer.bytesPerIndex;

			if (numInstances > 0) {
				gl.drawElementsInstanced(mode, count, format, offset, numInstances);
			} else {
				gl.drawElements(mode, count, format, offset);
			}
		} else {
			const first = primitive.base;

			if (numInstances > 0) {
				gl.drawArraysInstanced(mode, first, count, numInstances);
			} else {
				gl.drawArrays(mode, first, count);
			}
		}

		if (this.webgl2 && this.transformFeedbackBuffer) {
			gl.endTransformFeedback();
			gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, null);
		}

		this._drawCallsPerFrame++;
	}

	clear(options) {
		const defaultOptions = this.defaultClearOptions;
		options = options || defaultOptions;
		const flags = options.flags == undefined ? defaultOptions.flags : options.flags;

		if (flags !== 0) {
			const gl = this.gl;

			if (flags & CLEARFLAG_COLOR) {
				const color = options.color == undefined ? defaultOptions.color : options.color;
				this.setClearColor(color[0], color[1], color[2], color[3]);
			}

			if (flags & CLEARFLAG_DEPTH) {
				const depth = options.depth == undefined ? defaultOptions.depth : options.depth;
				this.setClearDepth(depth);

				if (!this.depthWrite) {
					gl.depthMask(true);
				}
			}

			if (flags & CLEARFLAG_STENCIL) {
				const stencil = options.stencil == undefined ? defaultOptions.stencil : options.stencil;
				this.setClearStencil(stencil);
			}

			gl.clear(this.glClearFlag[flags]);

			if (flags & CLEARFLAG_DEPTH) {
				if (!this.depthWrite) {
					gl.depthMask(false);
				}
			}
		}
	}

	readPixels(x, y, w, h, pixels) {
		const gl = this.gl;
		gl.readPixels(x, y, w, h, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
	}

	setClearDepth(depth) {
		if (depth !== this.clearDepth) {
			this.gl.clearDepth(depth);
			this.clearDepth = depth;
		}
	}

	setClearColor(r, g, b, a) {
		if (r !== this.clearRed || g !== this.clearGreen || b !== this.clearBlue || a !== this.clearAlpha) {
			this.gl.clearColor(r, g, b, a);
			this.clearRed = r;
			this.clearGreen = g;
			this.clearBlue = b;
			this.clearAlpha = a;
		}
	}

	setClearStencil(value) {
		if (value !== this.clearStencil) {
			this.gl.clearStencil(value);
			this.clearStencil = value;
		}
	}

	getDepthTest() {
		return this.depthTest;
	}

	setDepthTest(depthTest) {
		if (this.depthTest !== depthTest) {
			const gl = this.gl;

			if (depthTest) {
				gl.enable(gl.DEPTH_TEST);
			} else {
				gl.disable(gl.DEPTH_TEST);
			}

			this.depthTest = depthTest;
		}
	}

	setDepthFunc(func) {
		if (this.depthFunc === func) return;
		this.gl.depthFunc(this.glComparison[func]);
		this.depthFunc = func;
	}

	getDepthWrite() {
		return this.depthWrite;
	}

	setDepthWrite(writeDepth) {
		if (this.depthWrite !== writeDepth) {
			this.gl.depthMask(writeDepth);
			this.depthWrite = writeDepth;
		}
	}

	setColorWrite(writeRed, writeGreen, writeBlue, writeAlpha) {
		if (this.writeRed !== writeRed || this.writeGreen !== writeGreen || this.writeBlue !== writeBlue || this.writeAlpha !== writeAlpha) {
			this.gl.colorMask(writeRed, writeGreen, writeBlue, writeAlpha);
			this.writeRed = writeRed;
			this.writeGreen = writeGreen;
			this.writeBlue = writeBlue;
			this.writeAlpha = writeAlpha;
		}
	}

	setAlphaToCoverage(state) {
		if (!this.webgl2) return;
		if (this.alphaToCoverage === state) return;
		this.alphaToCoverage = state;

		if (state) {
			this.gl.enable(this.gl.SAMPLE_ALPHA_TO_COVERAGE);
		} else {
			this.gl.disable(this.gl.SAMPLE_ALPHA_TO_COVERAGE);
		}
	}

	setTransformFeedbackBuffer(tf) {
		if (this.transformFeedbackBuffer === tf) return;
		this.transformFeedbackBuffer = tf;

		if (this.webgl2) {
			const gl = this.gl;

			if (tf) {
				if (!this.feedback) {
					this.feedback = gl.createTransformFeedback();
				}

				gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, this.feedback);
			} else {
				gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
			}
		}
	}

	setRaster(on) {
		if (this.raster === on) return;
		this.raster = on;

		if (this.webgl2) {
			if (on) {
				this.gl.disable(this.gl.RASTERIZER_DISCARD);
			} else {
				this.gl.enable(this.gl.RASTERIZER_DISCARD);
			}
		}
	}

	setDepthBias(on) {
		if (this.depthBiasEnabled === on) return;
		this.depthBiasEnabled = on;

		if (on) {
			this.gl.enable(this.gl.POLYGON_OFFSET_FILL);
		} else {
			this.gl.disable(this.gl.POLYGON_OFFSET_FILL);
		}
	}

	setDepthBiasValues(constBias, slopeBias) {
		this.gl.polygonOffset(slopeBias, constBias);
	}

	getBlending() {
		return this.blending;
	}

	setBlending(blending) {
		if (this.blending !== blending) {
			const gl = this.gl;

			if (blending) {
				gl.enable(gl.BLEND);
			} else {
				gl.disable(gl.BLEND);
			}

			this.blending = blending;
		}
	}

	setStencilTest(enable) {
		if (this.stencil !== enable) {
			const gl = this.gl;

			if (enable) {
				gl.enable(gl.STENCIL_TEST);
			} else {
				gl.disable(gl.STENCIL_TEST);
			}

			this.stencil = enable;
		}
	}

	setStencilFunc(func, ref, mask) {
		if (this.stencilFuncFront !== func || this.stencilRefFront !== ref || this.stencilMaskFront !== mask || this.stencilFuncBack !== func || this.stencilRefBack !== ref || this.stencilMaskBack !== mask) {
			const gl = this.gl;
			gl.stencilFunc(this.glComparison[func], ref, mask);
			this.stencilFuncFront = this.stencilFuncBack = func;
			this.stencilRefFront = this.stencilRefBack = ref;
			this.stencilMaskFront = this.stencilMaskBack = mask;
		}
	}

	setStencilFuncFront(func, ref, mask) {
		if (this.stencilFuncFront !== func || this.stencilRefFront !== ref || this.stencilMaskFront !== mask) {
			const gl = this.gl;
			gl.stencilFuncSeparate(gl.FRONT, this.glComparison[func], ref, mask);
			this.stencilFuncFront = func;
			this.stencilRefFront = ref;
			this.stencilMaskFront = mask;
		}
	}

	setStencilFuncBack(func, ref, mask) {
		if (this.stencilFuncBack !== func || this.stencilRefBack !== ref || this.stencilMaskBack !== mask) {
			const gl = this.gl;
			gl.stencilFuncSeparate(gl.BACK, this.glComparison[func], ref, mask);
			this.stencilFuncBack = func;
			this.stencilRefBack = ref;
			this.stencilMaskBack = mask;
		}
	}

	setStencilOperation(fail, zfail, zpass, writeMask) {
		if (this.stencilFailFront !== fail || this.stencilZfailFront !== zfail || this.stencilZpassFront !== zpass || this.stencilFailBack !== fail || this.stencilZfailBack !== zfail || this.stencilZpassBack !== zpass) {
			this.gl.stencilOp(this.glStencilOp[fail], this.glStencilOp[zfail], this.glStencilOp[zpass]);
			this.stencilFailFront = this.stencilFailBack = fail;
			this.stencilZfailFront = this.stencilZfailBack = zfail;
			this.stencilZpassFront = this.stencilZpassBack = zpass;
		}

		if (this.stencilWriteMaskFront !== writeMask || this.stencilWriteMaskBack !== writeMask) {
			this.gl.stencilMask(writeMask);
			this.stencilWriteMaskFront = writeMask;
			this.stencilWriteMaskBack = writeMask;
		}
	}

	setStencilOperationFront(fail, zfail, zpass, writeMask) {
		if (this.stencilFailFront !== fail || this.stencilZfailFront !== zfail || this.stencilZpassFront !== zpass) {
			this.gl.stencilOpSeparate(this.gl.FRONT, this.glStencilOp[fail], this.glStencilOp[zfail], this.glStencilOp[zpass]);
			this.stencilFailFront = fail;
			this.stencilZfailFront = zfail;
			this.stencilZpassFront = zpass;
		}

		if (this.stencilWriteMaskFront !== writeMask) {
			this.gl.stencilMaskSeparate(this.gl.FRONT, writeMask);
			this.stencilWriteMaskFront = writeMask;
		}
	}

	setStencilOperationBack(fail, zfail, zpass, writeMask) {
		if (this.stencilFailBack !== fail || this.stencilZfailBack !== zfail || this.stencilZpassBack !== zpass) {
			this.gl.stencilOpSeparate(this.gl.BACK, this.glStencilOp[fail], this.glStencilOp[zfail], this.glStencilOp[zpass]);
			this.stencilFailBack = fail;
			this.stencilZfailBack = zfail;
			this.stencilZpassBack = zpass;
		}

		if (this.stencilWriteMaskBack !== writeMask) {
			this.gl.stencilMaskSeparate(this.gl.BACK, writeMask);
			this.stencilWriteMaskBack = writeMask;
		}
	}

	setBlendFunction(blendSrc, blendDst) {
		if (this.blendSrc !== blendSrc || this.blendDst !== blendDst || this.separateAlphaBlend) {
			this.gl.blendFunc(this.glBlendFunction[blendSrc], this.glBlendFunction[blendDst]);
			this.blendSrc = blendSrc;
			this.blendDst = blendDst;
			this.separateAlphaBlend = false;
		}
	}

	setBlendFunctionSeparate(blendSrc, blendDst, blendSrcAlpha, blendDstAlpha) {
		if (this.blendSrc !== blendSrc || this.blendDst !== blendDst || this.blendSrcAlpha !== blendSrcAlpha || this.blendDstAlpha !== blendDstAlpha || !this.separateAlphaBlend) {
			this.gl.blendFuncSeparate(this.glBlendFunction[blendSrc], this.glBlendFunction[blendDst], this.glBlendFunction[blendSrcAlpha], this.glBlendFunction[blendDstAlpha]);
			this.blendSrc = blendSrc;
			this.blendDst = blendDst;
			this.blendSrcAlpha = blendSrcAlpha;
			this.blendDstAlpha = blendDstAlpha;
			this.separateAlphaBlend = true;
		}
	}

	setBlendEquation(blendEquation) {
		if (this.blendEquation !== blendEquation || this.separateAlphaEquation) {
			this.gl.blendEquation(this.glBlendEquation[blendEquation]);
			this.blendEquation = blendEquation;
			this.separateAlphaEquation = false;
		}
	}

	setBlendEquationSeparate(blendEquation, blendAlphaEquation) {
		if (this.blendEquation !== blendEquation || this.blendAlphaEquation !== blendAlphaEquation || !this.separateAlphaEquation) {
			this.gl.blendEquationSeparate(this.glBlendEquation[blendEquation], this.glBlendEquation[blendAlphaEquation]);
			this.blendEquation = blendEquation;
			this.blendAlphaEquation = blendAlphaEquation;
			this.separateAlphaEquation = true;
		}
	}

	setCullMode(cullMode) {
		if (this.cullMode !== cullMode) {
			if (cullMode === CULLFACE_NONE) {
				this.gl.disable(this.gl.CULL_FACE);
			} else {
				if (this.cullMode === CULLFACE_NONE) {
					this.gl.enable(this.gl.CULL_FACE);
				}

				const mode = this.glCull[cullMode];

				if (this.cullFace !== mode) {
					this.gl.cullFace(mode);
					this.cullFace = mode;
				}
			}

			this.cullMode = cullMode;
		}
	}

	getCullMode() {
		return this.cullMode;
	}

	setIndexBuffer(indexBuffer) {
		this.indexBuffer = indexBuffer;
	}

	setVertexBuffer(vertexBuffer) {
		if (vertexBuffer) {
			this.vertexBuffers.push(vertexBuffer);
		}
	}

	setShader(shader) {
		if (shader !== this.shader) {
			if (shader.failed) {
				return false;
			} else if (!shader.ready && !shader.impl.postLink(this, shader)) {
				shader.failed = true;
				return false;
			}

			this.shader = shader;
			this.gl.useProgram(shader.impl.glProgram);
			this.attributesInvalidated = true;
		}

		return true;
	}

	getHdrFormat() {
		if (this.textureHalfFloatRenderable) {
			return PIXELFORMAT_RGBA16F;
		} else if (this.textureFloatRenderable) {
			return PIXELFORMAT_RGBA32F;
		}

		return PIXELFORMAT_R8_G8_B8_A8;
	}

	getBoneLimit() {
		return this.boneLimit;
	}

	setBoneLimit(maxBones) {
		this.boneLimit = maxBones;
	}

	clearShaderCache() {
		const gl = this.gl;

		for (const shaderSrc in this.fragmentShaderCache) {
			gl.deleteShader(this.fragmentShaderCache[shaderSrc]);
			delete this.fragmentShaderCache[shaderSrc];
		}

		for (const shaderSrc in this.vertexShaderCache) {
			gl.deleteShader(this.vertexShaderCache[shaderSrc]);
			delete this.vertexShaderCache[shaderSrc];
		}

		this.programLib.clearCache();
	}

	clearVertexArrayObjectCache() {
		const gl = this.gl;

		this._vaoMap.forEach((item, key, mapObj) => {
			gl.deleteVertexArray(item);
		});

		this._vaoMap.clear();
	}

	removeShaderFromCache(shader) {
		this.programLib.removeFromCache(shader);
	}

	get width() {
		return this.gl.drawingBufferWidth || this.canvas.width;
	}

	get height() {
		return this.gl.drawingBufferHeight || this.canvas.height;
	}

	set fullscreen(fullscreen) {
		if (fullscreen) {
			const canvas = this.gl.canvas;
			canvas.requestFullscreen();
		} else {
			document.exitFullscreen();
		}
	}

	get fullscreen() {
		return !!document.fullscreenElement;
	}

	get textureFloatHighPrecision() {
		if (this._textureFloatHighPrecision === undefined) {
			this._textureFloatHighPrecision = testTextureFloatHighPrecision(this);
		}

		return this._textureFloatHighPrecision;
	}

	get textureHalfFloatUpdatable() {
		if (this._textureHalfFloatUpdatable === undefined) {
			if (this.webgl2) {
				this._textureHalfFloatUpdatable = true;
			} else {
				this._textureHalfFloatUpdatable = testTextureHalfFloatUpdatable(this.gl, this.extTextureHalfFloat.HALF_FLOAT_OES);
			}
		}

		return this._textureHalfFloatUpdatable;
	}

}

class RefCountedObject {
	constructor() {
		this._refCount = 0;
	}

	incRefCount() {
		this._refCount++;
	}

	decRefCount() {
		this._refCount--;
	}

	get refCount() {
		return this._refCount;
	}

}

let currentApplication;

function getApplication() {
	return currentApplication;
}

function setApplication(app) {
	currentApplication = app;
}

let id$1 = 0;

class GeometryData {
	constructor() {
		this.initDefaults();
	}

	initDefaults() {
		this.recreate = false;
		this.verticesUsage = BUFFER_STATIC;
		this.indicesUsage = BUFFER_STATIC;
		this.maxVertices = 0;
		this.maxIndices = 0;
		this.vertexCount = 0;
		this.indexCount = 0;
		this.vertexStreamsUpdated = false;
		this.indexStreamUpdated = false;
		this.vertexStreamDictionary = {};
		this.indices = null;
	}

	_changeVertexCount(count, semantic) {
		if (!this.vertexCount) {
			this.vertexCount = count;
		}
	}

}

GeometryData.DEFAULT_COMPONENTS_POSITION = 3;
GeometryData.DEFAULT_COMPONENTS_NORMAL = 3;
GeometryData.DEFAULT_COMPONENTS_UV = 2;
GeometryData.DEFAULT_COMPONENTS_COLORS = 4;

class GeometryVertexStream {
	constructor(data, componentCount, dataType, dataTypeNormalize) {
		this.data = data;
		this.componentCount = componentCount;
		this.dataType = dataType;
		this.dataTypeNormalize = dataTypeNormalize;
	}

}

class Mesh extends RefCountedObject {
	constructor(graphicsDevice) {
		super();
		this.id = id$1++;
		this.device = graphicsDevice || getApplication().graphicsDevice;
		this.vertexBuffer = null;
		this.indexBuffer = [null];
		this.primitive = [{
			type: 0,
			base: 0,
			count: 0
		}];
		this.skin = null;
		this._morph = null;
		this._geometryData = null;
		this._aabb = new BoundingBox();
		this.boneAabb = null;
	}

	set morph(morph) {
		if (morph !== this._morph) {
			if (this._morph) {
				this._morph.decRefCount();
			}

			this._morph = morph;

			if (morph) {
				morph.incRefCount();
			}
		}
	}

	get morph() {
		return this._morph;
	}

	set aabb(aabb) {
		this._aabb = aabb;
	}

	get aabb() {
		return this._aabb;
	}

	destroy() {
		const morph = this.morph;

		if (morph) {
			this.morph = null;

			if (morph.refCount < 1) {
				morph.destroy();
			}
		}

		if (this.vertexBuffer) {
			this.vertexBuffer.destroy();
			this.vertexBuffer = null;
		}

		for (let j = 0; j < this.indexBuffer.length; j++) {
			this._destroyIndexBuffer(j);
		}

		this.indexBuffer.length = 0;
		this._geometryData = null;
	}

	_destroyIndexBuffer(index) {
		if (this.indexBuffer[index]) {
			this.indexBuffer[index].destroy();
			this.indexBuffer[index] = null;
		}
	}

	_initBoneAabbs(morphTargets) {
		this.boneAabb = [];
		this.boneUsed = [];
		let x, y, z;
		let bMax, bMin;
		const boneMin = [];
		const boneMax = [];
		const boneUsed = this.boneUsed;
		const numBones = this.skin.boneNames.length;
		let maxMorphX, maxMorphY, maxMorphZ;

		for (let i = 0; i < numBones; i++) {
			boneMin[i] = new Vec3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
			boneMax[i] = new Vec3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
		}

		const iterator = new VertexIterator(this.vertexBuffer);
		const posElement = iterator.element[SEMANTIC_POSITION];
		const weightsElement = iterator.element[SEMANTIC_BLENDWEIGHT];
		const indicesElement = iterator.element[SEMANTIC_BLENDINDICES];
		const numVerts = this.vertexBuffer.numVertices;

		for (let j = 0; j < numVerts; j++) {
			for (let k = 0; k < 4; k++) {
				const boneWeight = weightsElement.array[weightsElement.index + k];

				if (boneWeight > 0) {
					const boneIndex = indicesElement.array[indicesElement.index + k];
					boneUsed[boneIndex] = true;
					x = posElement.array[posElement.index];
					y = posElement.array[posElement.index + 1];
					z = posElement.array[posElement.index + 2];
					bMax = boneMax[boneIndex];
					bMin = boneMin[boneIndex];
					if (bMin.x > x) bMin.x = x;
					if (bMin.y > y) bMin.y = y;
					if (bMin.z > z) bMin.z = z;
					if (bMax.x < x) bMax.x = x;
					if (bMax.y < y) bMax.y = y;
					if (bMax.z < z) bMax.z = z;

					if (morphTargets) {
						let minMorphX = maxMorphX = x;
						let minMorphY = maxMorphY = y;
						let minMorphZ = maxMorphZ = z;

						for (let l = 0; l < morphTargets.length; l++) {
							const target = morphTargets[l];
							const dx = target.deltaPositions[j * 3];
							const dy = target.deltaPositions[j * 3 + 1];
							const dz = target.deltaPositions[j * 3 + 2];

							if (dx < 0) {
								minMorphX += dx;
							} else {
								maxMorphX += dx;
							}

							if (dy < 0) {
								minMorphY += dy;
							} else {
								maxMorphY += dy;
							}

							if (dz < 0) {
								minMorphZ += dz;
							} else {
								maxMorphZ += dz;
							}
						}

						if (bMin.x > minMorphX) bMin.x = minMorphX;
						if (bMin.y > minMorphY) bMin.y = minMorphY;
						if (bMin.z > minMorphZ) bMin.z = minMorphZ;
						if (bMax.x < maxMorphX) bMax.x = maxMorphX;
						if (bMax.y < maxMorphY) bMax.y = maxMorphY;
						if (bMax.z < maxMorphZ) bMax.z = maxMorphZ;
					}
				}
			}

			iterator.next();
		}

		const positionElement = this.vertexBuffer.getFormat().elements.find(e => e.name === SEMANTIC_POSITION);

		if (positionElement && positionElement.normalize) {
			const func = (() => {
				switch (positionElement.dataType) {
					case TYPE_INT8:
						return x => Math.max(x / 127.0, -1.0);

					case TYPE_UINT8:
						return x => x / 255.0;

					case TYPE_INT16:
						return x => Math.max(x / 32767.0, -1.0);

					case TYPE_UINT16:
						return x => x / 65535.0;

					default:
						return x => x;
				}
			})();

			for (let i = 0; i < numBones; i++) {
				if (boneUsed[i]) {
					const min = boneMin[i];
					const max = boneMax[i];
					min.set(func(min.x), func(min.y), func(min.z));
					max.set(func(max.x), func(max.y), func(max.z));
				}
			}
		}

		for (let i = 0; i < numBones; i++) {
			const aabb = new BoundingBox();
			aabb.setMinMax(boneMin[i], boneMax[i]);
			this.boneAabb.push(aabb);
		}
	}

	_initGeometryData() {
		if (!this._geometryData) {
			this._geometryData = new GeometryData();

			if (this.vertexBuffer) {
				this._geometryData.vertexCount = this.vertexBuffer.numVertices;
				this._geometryData.maxVertices = this.vertexBuffer.numVertices;
			}

			if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
				this._geometryData.indexCount = this.indexBuffer[0].numIndices;
				this._geometryData.maxIndices = this.indexBuffer[0].numIndices;
			}
		}
	}

	clear(verticesDynamic, indicesDynamic, maxVertices = 0, maxIndices = 0) {
		this._initGeometryData();

		this._geometryData.initDefaults();

		this._geometryData.recreate = true;
		this._geometryData.maxVertices = maxVertices;
		this._geometryData.maxIndices = maxIndices;
		this._geometryData.verticesUsage = verticesDynamic ? BUFFER_STATIC : BUFFER_DYNAMIC;
		this._geometryData.indicesUsage = indicesDynamic ? BUFFER_STATIC : BUFFER_DYNAMIC;
	}

	setVertexStream(semantic, data, componentCount, numVertices, dataType = TYPE_FLOAT32, dataTypeNormalize = false) {
		this._initGeometryData();

		const vertexCount = numVertices || data.length / componentCount;

		this._geometryData._changeVertexCount(vertexCount, semantic);

		this._geometryData.vertexStreamsUpdated = true;
		this._geometryData.vertexStreamDictionary[semantic] = new GeometryVertexStream(data, componentCount, dataType, dataTypeNormalize);
	}

	getVertexStream(semantic, data) {
		let count = 0;
		let done = false;

		if (this._geometryData) {
			const stream = this._geometryData.vertexStreamDictionary[semantic];

			if (stream) {
				done = true;
				count = this._geometryData.vertexCount;

				if (ArrayBuffer.isView(data)) {
					data.set(stream.data);
				} else {
					data.length = 0;
					data.push(stream.data);
				}
			}
		}

		if (!done) {
			if (this.vertexBuffer) {
				const iterator = new VertexIterator(this.vertexBuffer);
				count = iterator.readData(semantic, data);
			}
		}

		return count;
	}

	setPositions(positions, componentCount = GeometryData.DEFAULT_COMPONENTS_POSITION, numVertices) {
		this.setVertexStream(SEMANTIC_POSITION, positions, componentCount, numVertices, TYPE_FLOAT32, false);
	}

	setNormals(normals, componentCount = GeometryData.DEFAULT_COMPONENTS_NORMAL, numVertices) {
		this.setVertexStream(SEMANTIC_NORMAL, normals, componentCount, numVertices, TYPE_FLOAT32, false);
	}

	setUvs(channel, uvs, componentCount = GeometryData.DEFAULT_COMPONENTS_UV, numVertices) {
		this.setVertexStream(SEMANTIC_TEXCOORD + channel, uvs, componentCount, numVertices, TYPE_FLOAT32, false);
	}

	setColors(colors, componentCount = GeometryData.DEFAULT_COMPONENTS_COLORS, numVertices) {
		this.setVertexStream(SEMANTIC_COLOR, colors, componentCount, numVertices, TYPE_FLOAT32, false);
	}

	setColors32(colors, numVertices) {
		this.setVertexStream(SEMANTIC_COLOR, colors, GeometryData.DEFAULT_COMPONENTS_COLORS, numVertices, TYPE_UINT8, true);
	}

	setIndices(indices, numIndices) {
		this._initGeometryData();

		this._geometryData.indexStreamUpdated = true;
		this._geometryData.indices = indices;
		this._geometryData.indexCount = numIndices || indices.length;
	}

	getPositions(positions) {
		return this.getVertexStream(SEMANTIC_POSITION, positions);
	}

	getNormals(normals) {
		return this.getVertexStream(SEMANTIC_NORMAL, normals);
	}

	getUvs(channel, uvs) {
		return this.getVertexStream(SEMANTIC_TEXCOORD + channel, uvs);
	}

	getColors(colors) {
		return this.getVertexStream(SEMANTIC_COLOR, colors);
	}

	getIndices(indices) {
		let count = 0;

		if (this._geometryData && this._geometryData.indices) {
			const streamIndices = this._geometryData.indices;
			count = this._geometryData.indexCount;

			if (ArrayBuffer.isView(indices)) {
				indices.set(streamIndices);
			} else {
				indices.length = 0;
				indices.push(streamIndices);
			}
		} else {
			if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
				const indexBuffer = this.indexBuffer[0];
				count = indexBuffer.readData(indices);
			}
		}

		return count;
	}

	update(primitiveType = PRIMITIVE_TRIANGLES, updateBoundingBox = true) {
		if (this._geometryData) {
			if (updateBoundingBox) {
				const stream = this._geometryData.vertexStreamDictionary[SEMANTIC_POSITION];

				if (stream) {
					if (stream.componentCount === 3) {
						this._aabb.compute(stream.data, this._geometryData.vertexCount);
					}
				}
			}

			let destroyVB = this._geometryData.recreate;

			if (this._geometryData.vertexCount > this._geometryData.maxVertices) {
				destroyVB = true;
				this._geometryData.maxVertices = this._geometryData.vertexCount;
			}

			if (destroyVB) {
				if (this.vertexBuffer) {
					this.vertexBuffer.destroy();
					this.vertexBuffer = null;
				}
			}

			let destroyIB = this._geometryData.recreate;

			if (this._geometryData.indexCount > this._geometryData.maxIndices) {
				destroyIB = true;
				this._geometryData.maxIndices = this._geometryData.indexCount;
			}

			if (destroyIB) {
				if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
					this.indexBuffer[0].destroy();
					this.indexBuffer[0] = null;
				}
			}

			if (this._geometryData.vertexStreamsUpdated) {
				this._updateVertexBuffer();
			}

			if (this._geometryData.indexStreamUpdated) {
				this._updateIndexBuffer();
			}

			this.primitive[0].type = primitiveType;

			if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
				if (this._geometryData.indexStreamUpdated) {
					this.primitive[0].count = this._geometryData.indexCount;
					this.primitive[0].indexed = true;
				}
			} else {
				if (this._geometryData.vertexStreamsUpdated) {
					this.primitive[0].count = this._geometryData.vertexCount;
					this.primitive[0].indexed = false;
				}
			}

			this._geometryData.vertexCount = 0;
			this._geometryData.indexCount = 0;
			this._geometryData.vertexStreamsUpdated = false;
			this._geometryData.indexStreamUpdated = false;
			this._geometryData.recreate = false;
			this.updateRenderStates();
		}
	}

	_buildVertexFormat(vertexCount) {
		const vertexDesc = [];

		for (const semantic in this._geometryData.vertexStreamDictionary) {
			const stream = this._geometryData.vertexStreamDictionary[semantic];
			vertexDesc.push({
				semantic: semantic,
				components: stream.componentCount,
				type: stream.dataType,
				normalize: stream.dataTypeNormalize
			});
		}

		return new VertexFormat(this.device, vertexDesc, vertexCount);
	}

	_updateVertexBuffer() {
		if (!this.vertexBuffer) {
			const allocateVertexCount = this._geometryData.maxVertices;

			const format = this._buildVertexFormat(allocateVertexCount);

			this.vertexBuffer = new VertexBuffer(this.device, format, allocateVertexCount, this._geometryData.verticesUsage);
		}

		const iterator = new VertexIterator(this.vertexBuffer);
		const numVertices = this._geometryData.vertexCount;

		for (const semantic in this._geometryData.vertexStreamDictionary) {
			const stream = this._geometryData.vertexStreamDictionary[semantic];
			iterator.writeData(semantic, stream.data, numVertices);
			delete this._geometryData.vertexStreamDictionary[semantic];
		}

		iterator.end();
	}

	_updateIndexBuffer() {
		if (this.indexBuffer.length <= 0 || !this.indexBuffer[0]) {
			const createFormat = this._geometryData.maxVertices > 0xffff ? INDEXFORMAT_UINT32 : INDEXFORMAT_UINT16;
			this.indexBuffer[0] = new IndexBuffer(this.device, createFormat, this._geometryData.maxIndices, this._geometryData.indicesUsage);
		}

		const srcIndices = this._geometryData.indices;

		if (srcIndices) {
			const indexBuffer = this.indexBuffer[0];
			indexBuffer.writeData(srcIndices, this._geometryData.indexCount);
			this._geometryData.indices = null;
		}
	}

	prepareRenderState(renderStyle) {
		if (renderStyle === RENDERSTYLE_WIREFRAME) {
			this.generateWireframe();
		} else if (renderStyle === RENDERSTYLE_POINTS) {
			this.primitive[RENDERSTYLE_POINTS] = {
				type: PRIMITIVE_POINTS,
				base: 0,
				count: this.vertexBuffer ? this.vertexBuffer.numVertices : 0,
				indexed: false
			};
		}
	}

	updateRenderStates() {
		if (this.primitive[RENDERSTYLE_POINTS]) {
			this.prepareRenderState(RENDERSTYLE_POINTS);
		}

		if (this.primitive[RENDERSTYLE_WIREFRAME]) {
			this.prepareRenderState(RENDERSTYLE_WIREFRAME);
		}
	}

	generateWireframe() {
		this._destroyIndexBuffer(RENDERSTYLE_WIREFRAME);

		const lines = [];
		let format;

		if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
			const offsets = [[0, 1], [1, 2], [2, 0]];
			const base = this.primitive[RENDERSTYLE_SOLID].base;
			const count = this.primitive[RENDERSTYLE_SOLID].count;
			const indexBuffer = this.indexBuffer[RENDERSTYLE_SOLID];
			const srcIndices = new typedArrayIndexFormats[indexBuffer.format](indexBuffer.storage);
			const uniqueLineIndices = {};

			for (let j = base; j < base + count; j += 3) {
				for (let k = 0; k < 3; k++) {
					const i1 = srcIndices[j + offsets[k][0]];
					const i2 = srcIndices[j + offsets[k][1]];
					const line = i1 > i2 ? i2 << 16 | i1 : i1 << 16 | i2;

					if (uniqueLineIndices[line] === undefined) {
						uniqueLineIndices[line] = 0;
						lines.push(i1, i2);
					}
				}
			}

			format = indexBuffer.format;
		} else {
			for (let i = 0; i < this.vertexBuffer.numVertices; i += 3) {
				lines.push(i, i + 1, i + 1, i + 2, i + 2, i);
			}

			format = lines.length > 65535 ? INDEXFORMAT_UINT32 : INDEXFORMAT_UINT16;
		}

		const wireBuffer = new IndexBuffer(this.vertexBuffer.device, format, lines.length);
		const dstIndices = new typedArrayIndexFormats[wireBuffer.format](wireBuffer.storage);
		dstIndices.set(lines);
		wireBuffer.unlock();
		this.primitive[RENDERSTYLE_WIREFRAME] = {
			type: PRIMITIVE_LINES,
			base: 0,
			count: lines.length,
			indexed: true
		};
		this.indexBuffer[RENDERSTYLE_WIREFRAME] = wireBuffer;
	}

}

const primitiveUv1Padding = 4.0 / 64;
const primitiveUv1PaddingScale = 1.0 - primitiveUv1Padding * 2;
const shapePrimitives = [];

function calculateNormals(positions, indices) {
	const triangleCount = indices.length / 3;
	const vertexCount = positions.length / 3;
	const p1 = new Vec3();
	const p2 = new Vec3();
	const p3 = new Vec3();
	const p1p2 = new Vec3();
	const p1p3 = new Vec3();
	const faceNormal = new Vec3();
	const normals = [];

	for (let i = 0; i < positions.length; i++) {
		normals[i] = 0;
	}

	for (let i = 0; i < triangleCount; i++) {
		const i1 = indices[i * 3];
		const i2 = indices[i * 3 + 1];
		const i3 = indices[i * 3 + 2];
		p1.set(positions[i1 * 3], positions[i1 * 3 + 1], positions[i1 * 3 + 2]);
		p2.set(positions[i2 * 3], positions[i2 * 3 + 1], positions[i2 * 3 + 2]);
		p3.set(positions[i3 * 3], positions[i3 * 3 + 1], positions[i3 * 3 + 2]);
		p1p2.sub2(p2, p1);
		p1p3.sub2(p3, p1);
		faceNormal.cross(p1p2, p1p3).normalize();
		normals[i1 * 3] += faceNormal.x;
		normals[i1 * 3 + 1] += faceNormal.y;
		normals[i1 * 3 + 2] += faceNormal.z;
		normals[i2 * 3] += faceNormal.x;
		normals[i2 * 3 + 1] += faceNormal.y;
		normals[i2 * 3 + 2] += faceNormal.z;
		normals[i3 * 3] += faceNormal.x;
		normals[i3 * 3 + 1] += faceNormal.y;
		normals[i3 * 3 + 2] += faceNormal.z;
	}

	for (let i = 0; i < vertexCount; i++) {
		const nx = normals[i * 3];
		const ny = normals[i * 3 + 1];
		const nz = normals[i * 3 + 2];
		const invLen = 1 / Math.sqrt(nx * nx + ny * ny + nz * nz);
		normals[i * 3] *= invLen;
		normals[i * 3 + 1] *= invLen;
		normals[i * 3 + 2] *= invLen;
	}

	return normals;
}

function calculateTangents(positions, normals, uvs, indices) {
	const triangleCount = indices.length / 3;
	const vertexCount = positions.length / 3;
	const v1 = new Vec3();
	const v2 = new Vec3();
	const v3 = new Vec3();
	const w1 = new Vec2();
	const w2 = new Vec2();
	const w3 = new Vec2();
	const sdir = new Vec3();
	const tdir = new Vec3();
	const tan1 = new Float32Array(vertexCount * 3);
	const tan2 = new Float32Array(vertexCount * 3);
	const tangents = [];

	for (let i = 0; i < triangleCount; i++) {
		const i1 = indices[i * 3];
		const i2 = indices[i * 3 + 1];
		const i3 = indices[i * 3 + 2];
		v1.set(positions[i1 * 3], positions[i1 * 3 + 1], positions[i1 * 3 + 2]);
		v2.set(positions[i2 * 3], positions[i2 * 3 + 1], positions[i2 * 3 + 2]);
		v3.set(positions[i3 * 3], positions[i3 * 3 + 1], positions[i3 * 3 + 2]);
		w1.set(uvs[i1 * 2], uvs[i1 * 2 + 1]);
		w2.set(uvs[i2 * 2], uvs[i2 * 2 + 1]);
		w3.set(uvs[i3 * 2], uvs[i3 * 2 + 1]);
		const x1 = v2.x - v1.x;
		const x2 = v3.x - v1.x;
		const y1 = v2.y - v1.y;
		const y2 = v3.y - v1.y;
		const z1 = v2.z - v1.z;
		const z2 = v3.z - v1.z;
		const s1 = w2.x - w1.x;
		const s2 = w3.x - w1.x;

		const _t = w2.y - w1.y;

		const _t2 = w3.y - w1.y;

		const area = s1 * _t2 - s2 * _t;

		if (area === 0) {
			sdir.set(0, 1, 0);
			tdir.set(1, 0, 0);
		} else {
			const r = 1 / area;
			sdir.set((_t2 * x1 - _t * x2) * r, (_t2 * y1 - _t * y2) * r, (_t2 * z1 - _t * z2) * r);
			tdir.set((s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r, (s1 * z2 - s2 * z1) * r);
		}

		tan1[i1 * 3 + 0] += sdir.x;
		tan1[i1 * 3 + 1] += sdir.y;
		tan1[i1 * 3 + 2] += sdir.z;
		tan1[i2 * 3 + 0] += sdir.x;
		tan1[i2 * 3 + 1] += sdir.y;
		tan1[i2 * 3 + 2] += sdir.z;
		tan1[i3 * 3 + 0] += sdir.x;
		tan1[i3 * 3 + 1] += sdir.y;
		tan1[i3 * 3 + 2] += sdir.z;
		tan2[i1 * 3 + 0] += tdir.x;
		tan2[i1 * 3 + 1] += tdir.y;
		tan2[i1 * 3 + 2] += tdir.z;
		tan2[i2 * 3 + 0] += tdir.x;
		tan2[i2 * 3 + 1] += tdir.y;
		tan2[i2 * 3 + 2] += tdir.z;
		tan2[i3 * 3 + 0] += tdir.x;
		tan2[i3 * 3 + 1] += tdir.y;
		tan2[i3 * 3 + 2] += tdir.z;
	}

	const t1 = new Vec3();
	const t2 = new Vec3();
	const n = new Vec3();
	const temp = new Vec3();

	for (let i = 0; i < vertexCount; i++) {
		n.set(normals[i * 3], normals[i * 3 + 1], normals[i * 3 + 2]);
		t1.set(tan1[i * 3], tan1[i * 3 + 1], tan1[i * 3 + 2]);
		t2.set(tan2[i * 3], tan2[i * 3 + 1], tan2[i * 3 + 2]);
		const ndott = n.dot(t1);
		temp.copy(n).mulScalar(ndott);
		temp.sub2(t1, temp).normalize();
		tangents[i * 4] = temp.x;
		tangents[i * 4 + 1] = temp.y;
		tangents[i * 4 + 2] = temp.z;
		temp.cross(n, t1);
		tangents[i * 4 + 3] = temp.dot(t2) < 0.0 ? -1.0 : 1.0;
	}

	return tangents;
}

function createMesh$1(device, positions, opts) {
	const mesh = new Mesh(device);
	mesh.setPositions(positions);

	if (opts) {
		if (opts.normals) {
			mesh.setNormals(opts.normals);
		}

		if (opts.tangents) {
			mesh.setVertexStream(SEMANTIC_TANGENT, opts.tangents, 4);
		}

		if (opts.colors) {
			mesh.setColors32(opts.colors);
		}

		if (opts.uvs) {
			mesh.setUvs(0, opts.uvs);
		}

		if (opts.uvs1) {
			mesh.setUvs(1, opts.uvs1);
		}

		if (opts.blendIndices) {
			mesh.setVertexStream(SEMANTIC_BLENDINDICES, opts.blendIndices, 4, opts.blendIndices.length / 4, TYPE_UINT8);
		}

		if (opts.blendWeights) {
			mesh.setVertexStream(SEMANTIC_BLENDWEIGHT, opts.blendWeights, 4);
		}

		if (opts.indices) {
			mesh.setIndices(opts.indices);
		}
	}

	mesh.update();
	return mesh;
}

function createTorus(device, opts) {
	const rc = opts && opts.tubeRadius !== undefined ? opts.tubeRadius : 0.2;
	const rt = opts && opts.ringRadius !== undefined ? opts.ringRadius : 0.3;
	const segments = opts && opts.segments !== undefined ? opts.segments : 30;
	const sides = opts && opts.sides !== undefined ? opts.sides : 20;
	const calcTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;
	const positions = [];
	const normals = [];
	const uvs = [];
	const indices = [];

	for (let i = 0; i <= sides; i++) {
		for (let j = 0; j <= segments; j++) {
			const x = Math.cos(2 * Math.PI * j / segments) * (rt + rc * Math.cos(2 * Math.PI * i / sides));
			const y = Math.sin(2 * Math.PI * i / sides) * rc;
			const z = Math.sin(2 * Math.PI * j / segments) * (rt + rc * Math.cos(2 * Math.PI * i / sides));
			const nx = Math.cos(2 * Math.PI * j / segments) * Math.cos(2 * Math.PI * i / sides);
			const ny = Math.sin(2 * Math.PI * i / sides);
			const nz = Math.sin(2 * Math.PI * j / segments) * Math.cos(2 * Math.PI * i / sides);
			const u = i / sides;
			const v = 1 - j / segments;
			positions.push(x, y, z);
			normals.push(nx, ny, nz);
			uvs.push(u, 1.0 - v);

			if (i < sides && j < segments) {
				const first = i * (segments + 1) + j;
				const second = (i + 1) * (segments + 1) + j;
				const third = i * (segments + 1) + (j + 1);
				const fourth = (i + 1) * (segments + 1) + (j + 1);
				indices.push(first, second, third);
				indices.push(second, fourth, third);
			}
		}
	}

	const options = {
		normals: normals,
		uvs: uvs,
		indices: indices
	};

	if (calcTangents) {
		options.tangents = calculateTangents(positions, normals, uvs, indices);
	}

	return createMesh$1(device, positions, options);
}

function _createConeData(baseRadius, peakRadius, height, heightSegments, capSegments, roundedCaps) {
	const pos = new Vec3();
	const bottomToTop = new Vec3();
	const norm = new Vec3();
	const top = new Vec3();
	const bottom = new Vec3();
	const tangent = new Vec3();
	const positions = [];
	const normals = [];
	const uvs = [];
	const uvs1 = [];
	const indices = [];
	let offset;

	if (height > 0) {
		for (let i = 0; i <= heightSegments; i++) {
			for (let j = 0; j <= capSegments; j++) {
				const theta = j / capSegments * 2 * Math.PI - Math.PI;
				const sinTheta = Math.sin(theta);
				const cosTheta = Math.cos(theta);
				bottom.set(sinTheta * baseRadius, -height / 2, cosTheta * baseRadius);
				top.set(sinTheta * peakRadius, height / 2, cosTheta * peakRadius);
				pos.lerp(bottom, top, i / heightSegments);
				bottomToTop.sub2(top, bottom).normalize();
				tangent.set(cosTheta, 0, -sinTheta);
				norm.cross(tangent, bottomToTop).normalize();
				positions.push(pos.x, pos.y, pos.z);
				normals.push(norm.x, norm.y, norm.z);
				let u = j / capSegments;
				let v = i / heightSegments;
				uvs.push(u, 1 - v);
				const _v = v;
				v = u;
				u = _v;
				u = u * primitiveUv1PaddingScale + primitiveUv1Padding;
				v = v * primitiveUv1PaddingScale + primitiveUv1Padding;
				u /= 3;
				uvs1.push(u, 1 - v);

				if (i < heightSegments && j < capSegments) {
					const first = i * (capSegments + 1) + j;
					const second = i * (capSegments + 1) + (j + 1);
					const third = (i + 1) * (capSegments + 1) + j;
					const fourth = (i + 1) * (capSegments + 1) + (j + 1);
					indices.push(first, second, third);
					indices.push(second, fourth, third);
				}
			}
		}
	}

	if (roundedCaps) {
		const latitudeBands = Math.floor(capSegments / 2);
		const longitudeBands = capSegments;
		const capOffset = height / 2;

		for (let lat = 0; lat <= latitudeBands; lat++) {
			const theta = lat * Math.PI * 0.5 / latitudeBands;
			const sinTheta = Math.sin(theta);
			const cosTheta = Math.cos(theta);

			for (let lon = 0; lon <= longitudeBands; lon++) {
				const phi = lon * 2 * Math.PI / longitudeBands - Math.PI / 2;
				const sinPhi = Math.sin(phi);
				const cosPhi = Math.cos(phi);
				const x = cosPhi * sinTheta;
				const y = cosTheta;
				const z = sinPhi * sinTheta;
				let u = 1 - lon / longitudeBands;
				let v = 1 - lat / latitudeBands;
				positions.push(x * peakRadius, y * peakRadius + capOffset, z * peakRadius);
				normals.push(x, y, z);
				uvs.push(u, 1 - v);
				u = u * primitiveUv1PaddingScale + primitiveUv1Padding;
				v = v * primitiveUv1PaddingScale + primitiveUv1Padding;
				u /= 3;
				v /= 3;
				u += 1.0 / 3;
				uvs1.push(u, 1 - v);
			}
		}

		offset = (heightSegments + 1) * (capSegments + 1);

		for (let lat = 0; lat < latitudeBands; ++lat) {
			for (let lon = 0; lon < longitudeBands; ++lon) {
				const first = lat * (longitudeBands + 1) + lon;
				const second = first + longitudeBands + 1;
				indices.push(offset + first + 1, offset + second, offset + first);
				indices.push(offset + first + 1, offset + second + 1, offset + second);
			}
		}

		for (let lat = 0; lat <= latitudeBands; lat++) {
			const theta = Math.PI * 0.5 + lat * Math.PI * 0.5 / latitudeBands;
			const sinTheta = Math.sin(theta);
			const cosTheta = Math.cos(theta);

			for (let lon = 0; lon <= longitudeBands; lon++) {
				const phi = lon * 2 * Math.PI / longitudeBands - Math.PI / 2;
				const sinPhi = Math.sin(phi);
				const cosPhi = Math.cos(phi);
				const x = cosPhi * sinTheta;
				const y = cosTheta;
				const z = sinPhi * sinTheta;
				let u = 1 - lon / longitudeBands;
				let v = 1 - lat / latitudeBands;
				positions.push(x * peakRadius, y * peakRadius - capOffset, z * peakRadius);
				normals.push(x, y, z);
				uvs.push(u, 1 - v);
				u = u * primitiveUv1PaddingScale + primitiveUv1Padding;
				v = v * primitiveUv1PaddingScale + primitiveUv1Padding;
				u /= 3;
				v /= 3;
				u += 2.0 / 3;
				uvs1.push(u, 1 - v);
			}
		}

		offset = (heightSegments + 1) * (capSegments + 1) + (longitudeBands + 1) * (latitudeBands + 1);

		for (let lat = 0; lat < latitudeBands; ++lat) {
			for (let lon = 0; lon < longitudeBands; ++lon) {
				const first = lat * (longitudeBands + 1) + lon;
				const second = first + longitudeBands + 1;
				indices.push(offset + first + 1, offset + second, offset + first);
				indices.push(offset + first + 1, offset + second + 1, offset + second);
			}
		}
	} else {
		offset = (heightSegments + 1) * (capSegments + 1);

		if (baseRadius > 0) {
			for (let i = 0; i < capSegments; i++) {
				const theta = i / capSegments * 2 * Math.PI;
				const x = Math.sin(theta);
				const y = -height / 2;
				const z = Math.cos(theta);
				let u = 1 - (x + 1) / 2;
				let v = (z + 1) / 2;
				positions.push(x * baseRadius, y, z * baseRadius);
				normals.push(0, -1, 0);
				uvs.push(u, 1 - v);
				u = u * primitiveUv1PaddingScale + primitiveUv1Padding;
				v = v * primitiveUv1PaddingScale + primitiveUv1Padding;
				u /= 3;
				v /= 3;
				u += 1 / 3;
				uvs1.push(u, 1 - v);

				if (i > 1) {
					indices.push(offset, offset + i, offset + i - 1);
				}
			}
		}

		offset += capSegments;

		if (peakRadius > 0) {
			for (let i = 0; i < capSegments; i++) {
				const theta = i / capSegments * 2 * Math.PI;
				const x = Math.sin(theta);
				const y = height / 2;
				const z = Math.cos(theta);
				let u = 1 - (x + 1) / 2;
				let v = (z + 1) / 2;
				positions.push(x * peakRadius, y, z * peakRadius);
				normals.push(0, 1, 0);
				uvs.push(u, 1 - v);
				u = u * primitiveUv1PaddingScale + primitiveUv1Padding;
				v = v * primitiveUv1PaddingScale + primitiveUv1Padding;
				u /= 3;
				v /= 3;
				u += 2 / 3;
				uvs1.push(u, 1 - v);

				if (i > 1) {
					indices.push(offset, offset + i - 1, offset + i);
				}
			}
		}
	}

	return {
		positions: positions,
		normals: normals,
		uvs: uvs,
		uvs1: uvs1,
		indices: indices
	};
}

function createCylinder(device, opts) {
	let radius = opts && (opts.radius || opts.baseRadius);
	radius = radius !== undefined ? radius : 0.5;
	const height = opts && opts.height !== undefined ? opts.height : 1.0;
	const heightSegments = opts && opts.heightSegments !== undefined ? opts.heightSegments : 5;
	const capSegments = opts && opts.capSegments !== undefined ? opts.capSegments : 20;
	const calcTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;

	const options = _createConeData(radius, radius, height, heightSegments, capSegments, false);

	if (calcTangents) {
		options.tangents = calculateTangents(options.positions, options.normals, options.uvs, options.indices);
	}

	return createMesh$1(device, options.positions, options);
}

function createCapsule(device, opts) {
	const radius = opts && opts.radius !== undefined ? opts.radius : 0.3;
	const height = opts && opts.height !== undefined ? opts.height : 1.0;
	const heightSegments = opts && opts.heightSegments !== undefined ? opts.heightSegments : 1;
	const sides = opts && opts.sides !== undefined ? opts.sides : 20;
	const calcTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;

	const options = _createConeData(radius, radius, height - 2 * radius, heightSegments, sides, true);

	if (calcTangents) {
		options.tangents = calculateTangents(options.positions, options.normals, options.uvs, options.indices);
	}

	return createMesh$1(device, options.positions, options);
}

function createCone(device, opts) {
	const baseRadius = opts && opts.baseRadius !== undefined ? opts.baseRadius : 0.5;
	const peakRadius = opts && opts.peakRadius !== undefined ? opts.peakRadius : 0.0;
	const height = opts && opts.height !== undefined ? opts.height : 1.0;
	const heightSegments = opts && opts.heightSegments !== undefined ? opts.heightSegments : 5;
	const capSegments = opts && opts.capSegments !== undefined ? opts.capSegments : 18;
	const calcTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;

	const options = _createConeData(baseRadius, peakRadius, height, heightSegments, capSegments, false);

	if (calcTangents) {
		options.tangents = calculateTangents(options.positions, options.normals, options.uvs, options.indices);
	}

	return createMesh$1(device, options.positions, options);
}

function createSphere(device, opts) {
	const radius = opts && opts.radius !== undefined ? opts.radius : 0.5;
	const latitudeBands = opts && opts.latitudeBands !== undefined ? opts.latitudeBands : 16;
	const longitudeBands = opts && opts.longitudeBands !== undefined ? opts.longitudeBands : 16;
	const calcTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;
	const positions = [];
	const normals = [];
	const uvs = [];
	const indices = [];

	for (let lat = 0; lat <= latitudeBands; lat++) {
		const theta = lat * Math.PI / latitudeBands;
		const sinTheta = Math.sin(theta);
		const cosTheta = Math.cos(theta);

		for (let lon = 0; lon <= longitudeBands; lon++) {
			const phi = lon * 2 * Math.PI / longitudeBands - Math.PI / 2;
			const sinPhi = Math.sin(phi);
			const cosPhi = Math.cos(phi);
			const x = cosPhi * sinTheta;
			const y = cosTheta;
			const z = sinPhi * sinTheta;
			const u = 1 - lon / longitudeBands;
			const v = 1 - lat / latitudeBands;
			positions.push(x * radius, y * radius, z * radius);
			normals.push(x, y, z);
			uvs.push(u, 1 - v);
		}
	}

	for (let lat = 0; lat < latitudeBands; ++lat) {
		for (let lon = 0; lon < longitudeBands; ++lon) {
			const first = lat * (longitudeBands + 1) + lon;
			const second = first + longitudeBands + 1;
			indices.push(first + 1, second, first);
			indices.push(first + 1, second + 1, second);
		}
	}

	const options = {
		normals: normals,
		uvs: uvs,
		uvs1: uvs,
		indices: indices
	};

	if (calcTangents) {
		options.tangents = calculateTangents(positions, normals, uvs, indices);
	}

	return createMesh$1(device, positions, options);
}

function createPlane(device, opts) {
	const he = opts && opts.halfExtents !== undefined ? opts.halfExtents : new Vec2(0.5, 0.5);
	const ws = opts && opts.widthSegments !== undefined ? opts.widthSegments : 5;
	const ls = opts && opts.lengthSegments !== undefined ? opts.lengthSegments : 5;
	const calcTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;
	const positions = [];
	const normals = [];
	const uvs = [];
	const indices = [];
	let vcounter = 0;

	for (let i = 0; i <= ws; i++) {
		for (let j = 0; j <= ls; j++) {
			const x = -he.x + 2 * he.x * i / ws;
			const y = 0.0;
			const z = -(-he.y + 2 * he.y * j / ls);
			const u = i / ws;
			const v = j / ls;
			positions.push(x, y, z);
			normals.push(0, 1, 0);
			uvs.push(u, 1 - v);

			if (i < ws && j < ls) {
				indices.push(vcounter + ls + 1, vcounter + 1, vcounter);
				indices.push(vcounter + ls + 1, vcounter + ls + 2, vcounter + 1);
			}

			vcounter++;
		}
	}

	const options = {
		normals: normals,
		uvs: uvs,
		uvs1: uvs,
		indices: indices
	};

	if (calcTangents) {
		options.tangents = calculateTangents(positions, normals, uvs, indices);
	}

	return createMesh$1(device, positions, options);
}

function createBox(device, opts) {
	const he = opts && opts.halfExtents !== undefined ? opts.halfExtents : new Vec3(0.5, 0.5, 0.5);
	const ws = opts && opts.widthSegments !== undefined ? opts.widthSegments : 1;
	const ls = opts && opts.lengthSegments !== undefined ? opts.lengthSegments : 1;
	const hs = opts && opts.heightSegments !== undefined ? opts.heightSegments : 1;
	const calcTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;
	const corners = [new Vec3(-he.x, -he.y, he.z), new Vec3(he.x, -he.y, he.z), new Vec3(he.x, he.y, he.z), new Vec3(-he.x, he.y, he.z), new Vec3(he.x, -he.y, -he.z), new Vec3(-he.x, -he.y, -he.z), new Vec3(-he.x, he.y, -he.z), new Vec3(he.x, he.y, -he.z)];
	const faceAxes = [[0, 1, 3], [4, 5, 7], [3, 2, 6], [1, 0, 4], [1, 4, 2], [5, 0, 6]];
	const faceNormals = [[0, 0, 1], [0, 0, -1], [0, 1, 0], [0, -1, 0], [1, 0, 0], [-1, 0, 0]];
	const sides = {
		FRONT: 0,
		BACK: 1,
		TOP: 2,
		BOTTOM: 3,
		RIGHT: 4,
		LEFT: 5
	};
	const positions = [];
	const normals = [];
	const uvs = [];
	const uvs1 = [];
	const indices = [];
	let vcounter = 0;

	const generateFace = (side, uSegments, vSegments) => {
		const temp1 = new Vec3();
		const temp2 = new Vec3();
		const temp3 = new Vec3();
		const r = new Vec3();

		for (let i = 0; i <= uSegments; i++) {
			for (let j = 0; j <= vSegments; j++) {
				temp1.lerp(corners[faceAxes[side][0]], corners[faceAxes[side][1]], i / uSegments);
				temp2.lerp(corners[faceAxes[side][0]], corners[faceAxes[side][2]], j / vSegments);
				temp3.sub2(temp2, corners[faceAxes[side][0]]);
				r.add2(temp1, temp3);
				let u = i / uSegments;
				let v = j / vSegments;
				positions.push(r.x, r.y, r.z);
				normals.push(faceNormals[side][0], faceNormals[side][1], faceNormals[side][2]);
				uvs.push(u, 1 - v);
				u = u * primitiveUv1PaddingScale + primitiveUv1Padding;
				v = v * primitiveUv1PaddingScale + primitiveUv1Padding;
				u /= 3;
				v /= 3;
				u += side % 3 / 3;
				v += Math.floor(side / 3) / 3;
				uvs1.push(u, 1 - v);

				if (i < uSegments && j < vSegments) {
					indices.push(vcounter + vSegments + 1, vcounter + 1, vcounter);
					indices.push(vcounter + vSegments + 1, vcounter + vSegments + 2, vcounter + 1);
				}

				vcounter++;
			}
		}
	};

	generateFace(sides.FRONT, ws, hs);
	generateFace(sides.BACK, ws, hs);
	generateFace(sides.TOP, ws, ls);
	generateFace(sides.BOTTOM, ws, ls);
	generateFace(sides.RIGHT, ls, hs);
	generateFace(sides.LEFT, ls, hs);
	const options = {
		normals: normals,
		uvs: uvs,
		uvs1: uvs1,
		indices: indices
	};

	if (calcTangents) {
		options.tangents = calculateTangents(positions, normals, uvs, indices);
	}

	return createMesh$1(device, positions, options);
}

function getShapePrimitive(device, type) {
	let primData = null;

	for (let i = 0; i < shapePrimitives.length; i++) {
		if (shapePrimitives[i].type === type && shapePrimitives[i].device === device) {
			primData = shapePrimitives[i].primData;
		}
	}

	if (!primData) {
		let mesh, area;

		switch (type) {
			case 'box':
				mesh = createBox(device, {
					halfExtents: new Vec3(0.5, 0.5, 0.5)
				});
				area = {
					x: 2,
					y: 2,
					z: 2,
					uv: 2.0 / 3
				};
				break;

			case 'capsule':
				mesh = createCapsule(device, {
					radius: 0.5,
					height: 2
				});
				area = {
					x: Math.PI * 2,
					y: Math.PI,
					z: Math.PI * 2,
					uv: 1.0 / 3 + 1.0 / 3 / 3 * 2
				};
				break;

			case 'cone':
				mesh = createCone(device, {
					baseRadius: 0.5,
					peakRadius: 0,
					height: 1
				});
				area = {
					x: 2.54,
					y: 2.54,
					z: 2.54,
					uv: 1.0 / 3 + 1.0 / 3 / 3
				};
				break;

			case 'cylinder':
				mesh = createCylinder(device, {
					radius: 0.5,
					height: 1
				});
				area = {
					x: Math.PI,
					y: 0.79 * 2,
					z: Math.PI,
					uv: 1.0 / 3 + 1.0 / 3 / 3 * 2
				};
				break;

			case 'plane':
				mesh = createPlane(device, {
					halfExtents: new Vec2(0.5, 0.5),
					widthSegments: 1,
					lengthSegments: 1
				});
				area = {
					x: 0,
					y: 1,
					z: 0,
					uv: 1
				};
				break;

			case 'sphere':
				mesh = createSphere(device, {
					radius: 0.5
				});
				area = {
					x: Math.PI,
					y: Math.PI,
					z: Math.PI,
					uv: 1
				};
				break;

			default:
				throw new Error("Invalid primitive type: " + type);
		}

		mesh.incRefCount();
		primData = {
			mesh: mesh,
			area: area
		};
		shapePrimitives.push({
			type: type,
			device: device,
			primData: primData
		});
	}

	return primData;
}

class BasicMaterial extends Material {
	constructor() {
		super();
		this.color = new Color(1, 1, 1, 1);
		this.colorUniform = new Float32Array(4);
		this.colorMap = null;
		this.vertexColors = false;
	}

	copy(source) {
		super.copy(source);
		this.color.copy(source.color);
		this.colorMap = source.colorMap;
		this.vertexColors = source.vertexColors;
		return this;
	}

	updateUniforms(device, scene) {
		this.clearParameters();
		this.colorUniform[0] = this.color.r;
		this.colorUniform[1] = this.color.g;
		this.colorUniform[2] = this.color.b;
		this.colorUniform[3] = this.color.a;
		this.setParameter('uColor', this.colorUniform);

		if (this.colorMap) {
			this.setParameter('texture_diffuseMap', this.colorMap);
		}
	}

	updateShader(device, scene, objDefs, staticLightList, pass, sortedLights) {
		const options = {
			skin: objDefs && (objDefs & SHADERDEF_SKIN) !== 0,
			screenSpace: objDefs && (objDefs & SHADERDEF_SCREENSPACE) !== 0,
			useInstancing: objDefs && (objDefs & SHADERDEF_INSTANCING) !== 0,
			useMorphPosition: objDefs && (objDefs & SHADERDEF_MORPH_POSITION) !== 0,
			useMorphNormal: objDefs && (objDefs & SHADERDEF_MORPH_NORMAL) !== 0,
			useMorphTextureBased: objDefs && (objDefs & SHADERDEF_MORPH_TEXTURE_BASED) !== 0,
			vertexColors: this.vertexColors,
			diffuseMap: !!this.colorMap,
			pass: pass
		};
		const library = device.getProgramLibrary();
		this.shader = library.getProgram('basic', options);
	}

}

class Batch {
	constructor(meshInstances, dynamic, batchGroupId) {
		this.origMeshInstances = meshInstances;
		this._aabb = new BoundingBox();
		this.meshInstance = null;
		this.dynamic = dynamic;
		this.batchGroupId = batchGroupId;
	}

	destroy(scene, layers) {
		if (this.meshInstance) {
			this.removeFromLayers(scene, layers);
			this.meshInstance.destroy();
		}
	}

	addToLayers(scene, layers) {
		for (let i = 0; i < layers.length; i++) {
			const layer = scene.layers.getLayerById(layers[i]);

			if (layer) {
				layer.addMeshInstances([this.meshInstance]);
			}
		}
	}

	removeFromLayers(scene, layers) {
		for (let i = 0; i < layers.length; i++) {
			const layer = scene.layers.getLayerById(layers[i]);

			if (layer) {
				layer.removeMeshInstances([this.meshInstance]);
			}
		}
	}

	updateBoundingBox() {
		this._aabb.copy(this.origMeshInstances[0].aabb);

		for (let i = 1; i < this.origMeshInstances.length; i++) {
			this._aabb.add(this.origMeshInstances[i].aabb);
		}

		this.meshInstance.aabb = this._aabb;
		this.meshInstance._aabbVer = 0;
	}

}

class BatchGroup {
	constructor(id, name, dynamic, maxAabbSize, layers = [LAYERID_WORLD]) {
		this.dynamic = dynamic;
		this.maxAabbSize = maxAabbSize;
		this.id = id;
		this.name = name;
		this.layers = layers;
		this._ui = false;
		this._sprite = false;
		this._obj = {
			model: [],
			element: [],
			sprite: [],
			render: []
		};
	}

}

BatchGroup.MODEL = 'model';
BatchGroup.ELEMENT = 'element';
BatchGroup.SPRITE = 'sprite';
BatchGroup.RENDER = 'render';

const _invMatrix = new Mat4();

class SkinInstance {
	constructor(skin) {
		this.bones = void 0;
		this._dirty = true;
		this._rootBone = null;
		this._skinUpdateIndex = -1;
		this._updateBeforeCull = true;

		if (skin) {
			this.initSkin(skin);
		}
	}

	set rootBone(rootBone) {
		this._rootBone = rootBone;
	}

	get rootBone() {
		return this._rootBone;
	}

	init(device, numBones) {
		if (device.supportsBoneTextures) {
			const numPixels = numBones * 3;
			let width = Math.ceil(Math.sqrt(numPixels));
			width = math.roundUp(width, 3);
			const height = Math.ceil(numPixels / width);
			this.boneTexture = new Texture(device, {
				width: width,
				height: height,
				format: PIXELFORMAT_RGBA32F,
				mipmaps: false,
				minFilter: FILTER_NEAREST,
				magFilter: FILTER_NEAREST
			});
			this.boneTexture.name = 'skin';
			this.matrixPalette = this.boneTexture.lock();
		} else {
			this.matrixPalette = new Float32Array(numBones * 12);
		}
	}

	destroy() {
		if (this.boneTexture) {
			this.boneTexture.destroy();
			this.boneTexture = null;
		}
	}

	resolve(rootBone, entity) {
		this.rootBone = rootBone;
		const skin = this.skin;
		const bones = [];

		for (let j = 0; j < skin.boneNames.length; j++) {
			const boneName = skin.boneNames[j];
			let bone = rootBone.findByName(boneName);

			if (!bone) {
				bone = entity;
			}

			bones.push(bone);
		}

		this.bones = bones;
	}

	initSkin(skin) {
		this.skin = skin;
		this.bones = [];
		const numBones = skin.inverseBindPose.length;
		this.init(skin.device, numBones);
		this.matrices = [];

		for (let i = 0; i < numBones; i++) {
			this.matrices[i] = new Mat4();
		}
	}

	uploadBones(device) {
		if (device.supportsBoneTextures) {
			this.boneTexture.lock();
			this.boneTexture.unlock();
		}
	}

	_updateMatrices(rootNode, skinUpdateIndex) {
		if (this._skinUpdateIndex !== skinUpdateIndex) {
			this._skinUpdateIndex = skinUpdateIndex;

			_invMatrix.copy(rootNode.getWorldTransform()).invert();

			for (let i = this.bones.length - 1; i >= 0; i--) {
				this.matrices[i].mulAffine2(_invMatrix, this.bones[i].getWorldTransform());
				this.matrices[i].mulAffine2(this.matrices[i], this.skin.inverseBindPose[i]);
			}
		}
	}

	updateMatrices(rootNode, skinUpdateIndex) {
		if (this._updateBeforeCull) {
			this._updateMatrices(rootNode, skinUpdateIndex);
		}
	}

	updateMatrixPalette(rootNode, skinUpdateIndex) {
		this._updateMatrices(rootNode, skinUpdateIndex);

		const mp = this.matrixPalette;
		const count = this.bones.length;

		for (let i = 0; i < count; i++) {
			const pe = this.matrices[i].data;
			const base = i * 12;
			mp[base] = pe[0];
			mp[base + 1] = pe[4];
			mp[base + 2] = pe[8];
			mp[base + 3] = pe[12];
			mp[base + 4] = pe[1];
			mp[base + 5] = pe[5];
			mp[base + 6] = pe[9];
			mp[base + 7] = pe[13];
			mp[base + 8] = pe[2];
			mp[base + 9] = pe[6];
			mp[base + 10] = pe[10];
			mp[base + 11] = pe[14];
		}

		this.uploadBones(this.skin.device);
	}

}

class SkinBatchInstance extends SkinInstance {
	constructor(device, nodes, rootNode) {
		super();
		const numBones = nodes.length;
		this.init(device, numBones);
		this.device = device;
		this.rootNode = rootNode;
		this.bones = nodes;
	}

	updateMatrices(rootNode, skinUpdateIndex) {}

	updateMatrixPalette(rootNode, skinUpdateIndex) {
		const mp = this.matrixPalette;
		const count = this.bones.length;

		for (let i = 0; i < count; i++) {
			const pe = this.bones[i].getWorldTransform().data;
			const base = i * 12;
			mp[base] = pe[0];
			mp[base + 1] = pe[4];
			mp[base + 2] = pe[8];
			mp[base + 3] = pe[12];
			mp[base + 4] = pe[1];
			mp[base + 5] = pe[5];
			mp[base + 6] = pe[9];
			mp[base + 7] = pe[13];
			mp[base + 8] = pe[2];
			mp[base + 9] = pe[6];
			mp[base + 10] = pe[10];
			mp[base + 11] = pe[14];
		}

		this.uploadBones(this.device);
	}

}

class RefCountedCache {
	constructor() {
		this.cache = new Map();
	}

	destroy() {
		this.cache.forEach((refCount, object) => {
			object.destroy();
		});
		this.cache.clear();
	}

	incRef(object) {
		const refCount = (this.cache.get(object) || 0) + 1;
		this.cache.set(object, refCount);
	}

	decRef(object) {
		if (object) {
			let refCount = this.cache.get(object);

			if (refCount) {
				refCount--;

				if (refCount === 0) {
					this.cache.delete(object);
					object.destroy();
				} else {
					this.cache.set(object, refCount);
				}
			}
		}
	}

}

class LightmapCache {
	static incRef(texture) {
		this.cache.incRef(texture);
	}

	static decRef(texture) {
		this.cache.decRef(texture);
	}

	static destroy() {
		this.cache.destroy();
	}

}

LightmapCache.cache = new RefCountedCache();

const _tmpAabb = new BoundingBox();

const _tempBoneAabb = new BoundingBox();

const _tempSphere = new BoundingSphere();

const _meshSet = new Set();

class InstancingData {
	constructor(numObjects) {
		this.count = numObjects;
		this.vertexBuffer = null;
	}

}

class Command {
	constructor(layer, blendType, command) {
		this._key = [];
		this._key[SORTKEY_FORWARD] = getKey(layer, blendType, true, 0);
		this.command = command;
	}

	set key(val) {
		this._key[SORTKEY_FORWARD] = val;
	}

	get key() {
		return this._key[SORTKEY_FORWARD];
	}

}

class MeshInstance {
	constructor(mesh, material, node = null) {
		if (mesh instanceof GraphNode) {
			const temp = mesh;
			mesh = material;
			material = node;
			node = temp;
		}

		this._key = [0, 0];
		this._shader = [null, null, null];
		this.isStatic = false;
		this._staticLightList = null;
		this._staticSource = null;
		this.node = node;
		this._mesh = mesh;
		mesh.incRefCount();
		this.material = material;
		this._shaderDefs = MASK_AFFECT_DYNAMIC << 16;
		this._shaderDefs |= mesh.vertexBuffer.format.hasUv0 ? SHADERDEF_UV0 : 0;
		this._shaderDefs |= mesh.vertexBuffer.format.hasUv1 ? SHADERDEF_UV1 : 0;
		this._shaderDefs |= mesh.vertexBuffer.format.hasColor ? SHADERDEF_VCOLOR : 0;
		this._shaderDefs |= mesh.vertexBuffer.format.hasTangents ? SHADERDEF_TANGENTS : 0;
		this._lightHash = 0;
		this.visible = true;
		this.layer = LAYER_WORLD;
		this._renderStyle = RENDERSTYLE_SOLID;
		this.castShadow = false;
		this._receiveShadow = true;
		this._screenSpace = false;
		this._noDepthDrawGl1 = false;
		this.cull = true;
		this.pick = true;
		this._updateAabb = true;
		this._updateAabbFunc = null;
		this._calculateSortDistance = null;
		this.updateKey();
		this._skinInstance = null;
		this._morphInstance = null;
		this.instancingData = null;
		this._customAabb = null;
		this.aabb = new BoundingBox();
		this._aabbVer = -1;
		this.drawOrder = 0;
		this.visibleThisFrame = 0;
		this.isVisibleFunc = null;
		this.parameters = {};
		this.stencilFront = null;
		this.stencilBack = null;
		this.flipFaces = false;
	}

	set renderStyle(renderStyle) {
		this._renderStyle = renderStyle;
		this.mesh.prepareRenderState(renderStyle);
	}

	get renderStyle() {
		return this._renderStyle;
	}

	set mesh(mesh) {
		if (mesh === this._mesh) return;

		if (this._mesh) {
			this._mesh.decRefCount();
		}

		this._mesh = mesh;

		if (mesh) {
			mesh.incRefCount();
		}
	}

	get mesh() {
		return this._mesh;
	}

	set aabb(aabb) {
		this._aabb = aabb;
	}

	get aabb() {
		if (!this._updateAabb) {
			return this._aabb;
		}

		if (this._updateAabbFunc) {
			return this._updateAabbFunc(this._aabb);
		}

		let localAabb = this._customAabb;
		let toWorldSpace = !!localAabb;

		if (!localAabb) {
			localAabb = _tmpAabb;

			if (this.skinInstance) {
				if (!this.mesh.boneAabb) {
					const morphTargets = this._morphInstance ? this._morphInstance.morph._targets : null;

					this.mesh._initBoneAabbs(morphTargets);
				}

				const boneUsed = this.mesh.boneUsed;
				let first = true;

				for (let i = 0; i < this.mesh.boneAabb.length; i++) {
					if (boneUsed[i]) {
						_tempBoneAabb.setFromTransformedAabb(this.mesh.boneAabb[i], this.skinInstance.matrices[i]);

						if (first) {
							first = false;
							localAabb.center.copy(_tempBoneAabb.center);
							localAabb.halfExtents.copy(_tempBoneAabb.halfExtents);
						} else {
							localAabb.add(_tempBoneAabb);
						}
					}
				}

				toWorldSpace = true;
			} else if (this.node._aabbVer !== this._aabbVer) {
				if (this.mesh) {
					localAabb.center.copy(this.mesh.aabb.center);
					localAabb.halfExtents.copy(this.mesh.aabb.halfExtents);
				} else {
					localAabb.center.set(0, 0, 0);
					localAabb.halfExtents.set(0, 0, 0);
				}

				if (this.mesh && this.mesh.morph) {
					localAabb._expand(this.mesh.morph.aabb.getMin(), this.mesh.morph.aabb.getMax());
				}

				toWorldSpace = true;
				this._aabbVer = this.node._aabbVer;
			}
		}

		if (toWorldSpace) {
			this._aabb.setFromTransformedAabb(localAabb, this.node.getWorldTransform());
		}

		return this._aabb;
	}

	set material(material) {
		for (let i = 0; i < this._shader.length; i++) {
			this._shader[i] = null;
		}

		const prevMat = this._material;

		if (prevMat) {
			prevMat.removeMeshInstanceRef(this);
		}

		this._material = material;

		if (this._material) {
			this._material.addMeshInstanceRef(this);

			this.updateKey();
			const prevBlend = prevMat && prevMat.blendType !== BLEND_NONE;
			const thisBlend = this._material.blendType !== BLEND_NONE;

			if (prevBlend !== thisBlend) {
				let scene = this._material._scene;
				if (!scene && prevMat && prevMat._scene) scene = prevMat._scene;

				if (scene) {
					scene.layers._dirtyBlend = true;
				} else {
					this._material._dirtyBlend = true;
				}
			}
		}
	}

	get material() {
		return this._material;
	}

	set layer(layer) {
		this._layer = layer;
		this.updateKey();
	}

	get layer() {
		return this._layer;
	}

	set calculateSortDistance(calculateSortDistance) {
		this._calculateSortDistance = calculateSortDistance;
	}

	get calculateSortDistance() {
		return this._calculateSortDistance;
	}

	set receiveShadow(val) {
		this._receiveShadow = val;
		this._shaderDefs = val ? this._shaderDefs & ~SHADERDEF_NOSHADOW : this._shaderDefs | SHADERDEF_NOSHADOW;
		this._shader[SHADER_FORWARD] = null;
		this._shader[SHADER_FORWARDHDR] = null;
	}

	get receiveShadow() {
		return this._receiveShadow;
	}

	set skinInstance(val) {
		this._skinInstance = val;
		this._shaderDefs = val ? this._shaderDefs | SHADERDEF_SKIN : this._shaderDefs & ~SHADERDEF_SKIN;

		for (let i = 0; i < this._shader.length; i++) {
			this._shader[i] = null;
		}

		this._setupSkinUpdate();
	}

	get skinInstance() {
		return this._skinInstance;
	}

	set morphInstance(val) {
		this._morphInstance = val;

		if (this._morphInstance) {
			this._morphInstance.meshInstance = this;
		}

		this._shaderDefs = val && val.morph.useTextureMorph ? this._shaderDefs | SHADERDEF_MORPH_TEXTURE_BASED : this._shaderDefs & ~SHADERDEF_MORPH_TEXTURE_BASED;
		this._shaderDefs = val && val.morph.morphPositions ? this._shaderDefs | SHADERDEF_MORPH_POSITION : this._shaderDefs & ~SHADERDEF_MORPH_POSITION;
		this._shaderDefs = val && val.morph.morphNormals ? this._shaderDefs | SHADERDEF_MORPH_NORMAL : this._shaderDefs & ~SHADERDEF_MORPH_NORMAL;

		for (let i = 0; i < this._shader.length; i++) {
			this._shader[i] = null;
		}
	}

	get morphInstance() {
		return this._morphInstance;
	}

	set screenSpace(val) {
		this._screenSpace = val;
		this._shaderDefs = val ? this._shaderDefs | SHADERDEF_SCREENSPACE : this._shaderDefs & ~SHADERDEF_SCREENSPACE;
		this._shader[SHADER_FORWARD] = null;
	}

	get screenSpace() {
		return this._screenSpace;
	}

	set key(val) {
		this._key[SORTKEY_FORWARD] = val;
	}

	get key() {
		return this._key[SORTKEY_FORWARD];
	}

	set mask(val) {
		const toggles = this._shaderDefs & 0x0000FFFF;
		this._shaderDefs = toggles | val << 16;
		this._shader[SHADER_FORWARD] = null;
		this._shader[SHADER_FORWARDHDR] = null;
	}

	get mask() {
		return this._shaderDefs >> 16;
	}

	set instancingCount(value) {
		if (this.instancingData) this.instancingData.count = value;
	}

	get instancingCount() {
		return this.instancingData ? this.instancingData.count : 0;
	}

	destroy() {
		const mesh = this.mesh;

		if (mesh) {
			this.mesh = null;

			if (mesh.refCount < 1) {
				mesh.destroy();
			}
		}

		this.setRealtimeLightmap(MeshInstance.lightmapParamNames[0], null);
		this.setRealtimeLightmap(MeshInstance.lightmapParamNames[1], null);

		if (this._skinInstance) {
			this._skinInstance.destroy();

			this._skinInstance = null;
		}

		if (this.morphInstance) {
			this.morphInstance.destroy();
			this.morphInstance = null;
		}

		this.material = null;
	}

	static _prepareRenderStyleForArray(meshInstances, renderStyle) {
		if (meshInstances) {
			for (let i = 0; i < meshInstances.length; i++) {
				meshInstances[i]._renderStyle = renderStyle;
				const mesh = meshInstances[i].mesh;

				if (!_meshSet.has(mesh)) {
					_meshSet.add(mesh);

					mesh.prepareRenderState(renderStyle);
				}
			}

			_meshSet.clear();
		}
	}

	_isVisible(camera) {
		if (this.visible) {
			if (this.isVisibleFunc) {
				return this.isVisibleFunc(camera);
			}

			_tempSphere.center = this.aabb.center;
			_tempSphere.radius = this._aabb.halfExtents.length();
			return camera.frustum.containsSphere(_tempSphere);
		}

		return false;
	}

	updateKey() {
		const material = this.material;
		this._key[SORTKEY_FORWARD] = getKey(this.layer, material.alphaToCoverage || material.alphaTest ? BLEND_NORMAL : material.blendType, false, material.id);
	}

	setInstancing(vertexBuffer) {
		if (vertexBuffer) {
			this.instancingData = new InstancingData(vertexBuffer.numVertices);
			this.instancingData.vertexBuffer = vertexBuffer;
			vertexBuffer.instancing = true;
			this.cull = false;
		} else {
			this.instancingData = null;
			this.cull = true;
		}
	}

	clearParameters() {
		this.parameters = {};
	}

	getParameters() {
		return this.parameters;
	}

	getParameter(name) {
		return this.parameters[name];
	}

	setParameter(name, data, passFlags = -262141) {
		if (data === undefined && typeof name === 'object') {
			const uniformObject = name;

			if (uniformObject.length) {
				for (let i = 0; i < uniformObject.length; i++) {
					this.setParameter(uniformObject[i]);
				}

				return;
			}

			name = uniformObject.name;
			data = uniformObject.value;
		}

		const param = this.parameters[name];

		if (param) {
			param.data = data;
			param.passFlags = passFlags;
		} else {
			this.parameters[name] = {
				scopeId: null,
				data: data,
				passFlags: passFlags
			};
		}
	}

	setRealtimeLightmap(name, texture) {
		const old = this.getParameter(name);
		if (old === texture) return;

		if (old) {
			LightmapCache.decRef(old.data);
		}

		if (texture) {
			LightmapCache.incRef(texture);
			this.setParameter(name, texture);
		} else {
			this.deleteParameter(name);
		}
	}

	deleteParameter(name) {
		if (this.parameters[name]) {
			delete this.parameters[name];
		}
	}

	setParameters(device, passFlag) {
		const parameters = this.parameters;

		for (const paramName in parameters) {
			const parameter = parameters[paramName];

			if (parameter.passFlags & passFlag) {
				if (!parameter.scopeId) {
					parameter.scopeId = device.scope.resolve(paramName);
				}

				parameter.scopeId.setValue(parameter.data);
			}
		}
	}

	setLightmapped(value) {
		if (value) {
			this.mask = (this.mask | MASK_AFFECT_LIGHTMAPPED) & ~(MASK_AFFECT_DYNAMIC | MASK_BAKE);
		} else {
			this.setRealtimeLightmap(MeshInstance.lightmapParamNames[0], null);
			this.setRealtimeLightmap(MeshInstance.lightmapParamNames[1], null);
			this._shaderDefs &= ~(SHADERDEF_LM | SHADERDEF_DIRLM | SHADERDEF_LMAMBIENT);
			this.mask = (this.mask | MASK_AFFECT_DYNAMIC) & ~(MASK_AFFECT_LIGHTMAPPED | MASK_BAKE);
		}
	}

	setCustomAabb(aabb) {
		if (aabb) {
			if (this._customAabb) {
				this._customAabb.copy(aabb);
			} else {
				this._customAabb = aabb.clone();
			}
		} else {
			this._customAabb = null;
			this._aabbVer = -1;
		}

		this._setupSkinUpdate();
	}

	_setupSkinUpdate() {
		if (this._skinInstance) {
			this._skinInstance._updateBeforeCull = !this._customAabb;
		}
	}

}

MeshInstance.lightmapParamNames = ["texture_lightMap", "texture_dirLightMap"];

function getKey(layer, blendType, isCommand, materialId) {
	return (layer & 0x0f) << 27 | (blendType === BLEND_NONE ? 1 : 0) << 26 | (isCommand ? 1 : 0) << 25 | (materialId & 0x1ffffff) << 0;
}

function paramsIdentical(a, b) {
	if (a && !b) return false;
	if (!a && b) return false;
	a = a.data;
	b = b.data;
	if (a === b) return true;

	if (a instanceof Float32Array && b instanceof Float32Array) {
		if (a.length !== b.length) return false;

		for (let i = 0; i < a.length; i++) {
			if (a[i] !== b[i]) return false;
		}

		return true;
	}

	return false;
}

function equalParamSets(params1, params2) {
	for (const param in params1) {
		if (params1.hasOwnProperty(param) && !paramsIdentical(params1[param], params2[param])) return false;
	}

	for (const param in params2) {
		if (params2.hasOwnProperty(param) && !paramsIdentical(params2[param], params1[param])) return false;
	}

	return true;
}

function equalLightLists(lightList1, lightList2) {
	for (let k = 0; k < lightList1.length; k++) {
		if (lightList2.indexOf(lightList1[k]) < 0) return false;
	}

	for (let k = 0; k < lightList2.length; k++) {
		if (lightList1.indexOf(lightList2[k]) < 0) return false;
	}

	return true;
}

const mat3 = new Mat3();
const worldMatX$1 = new Vec3();
const worldMatY$1 = new Vec3();
const worldMatZ$1 = new Vec3();

function getScaleSign(mi) {
	const wt = mi.node.worldTransform;
	wt.getX(worldMatX$1);
	wt.getY(worldMatY$1);
	wt.getZ(worldMatZ$1);
	worldMatX$1.cross(worldMatX$1, worldMatY$1);
	return worldMatX$1.dot(worldMatZ$1) >= 0 ? 1 : -1;
}

class BatchManager {
	constructor(device, root, scene) {
		this.device = device;
		this.rootNode = root;
		this.scene = scene;
		this._init = false;
		this._batchGroups = {};
		this._batchGroupCounter = 0;
		this._batchList = [];
		this._dirtyGroups = [];
	}

	destroy() {
		this.device = null;
		this.rootNode = null;
		this.scene = null;
		this._batchGroups = {};
		this._batchList = [];
		this._dirtyGroups = [];
	}

	addGroup(name, dynamic, maxAabbSize, id, layers) {
		if (id === undefined) {
			id = this._batchGroupCounter;
			this._batchGroupCounter++;
		}

		if (this._batchGroups[id]) {
			return;
		}

		const group = new BatchGroup(id, name, dynamic, maxAabbSize, layers);
		this._batchGroups[id] = group;
		return group;
	}

	removeGroup(id) {
		if (!this._batchGroups[id]) {
			return;
		}

		const newBatchList = [];

		for (let i = 0; i < this._batchList.length; i++) {
			if (this._batchList[i].batchGroupId === id) {
				this.destroyBatch(this._batchList[i]);
			} else {
				newBatchList.push(this._batchList[i]);
			}
		}

		this._batchList = newBatchList;

		this._removeModelsFromBatchGroup(this.rootNode, id);

		delete this._batchGroups[id];
	}

	markGroupDirty(id) {
		if (this._dirtyGroups.indexOf(id) < 0) {
			this._dirtyGroups.push(id);
		}
	}

	getGroupByName(name) {
		const groups = this._batchGroups;

		for (const group in groups) {
			if (!groups.hasOwnProperty(group)) continue;

			if (groups[group].name === name) {
				return groups[group];
			}
		}

		return null;
	}

	getBatches(batchGroupId) {
		const results = [];
		const len = this._batchList.length;

		for (let i = 0; i < len; i++) {
			const batch = this._batchList[i];

			if (batch.batchGroupId === batchGroupId) {
				results.push(batch);
			}
		}

		return results;
	}

	_removeModelsFromBatchGroup(node, id) {
		if (!node.enabled) return;

		if (node.model && node.model.batchGroupId === id) {
			node.model.batchGroupId = -1;
		}

		if (node.render && node.render.batchGroupId === id) {
			node.render.batchGroupId = -1;
		}

		if (node.element && node.element.batchGroupId === id) {
			node.element.batchGroupId = -1;
		}

		if (node.sprite && node.sprite.batchGroupId === id) {
			node.sprite.batchGroupId = -1;
		}

		for (let i = 0; i < node._children.length; i++) {
			this._removeModelsFromBatchGroup(node._children[i], id);
		}
	}

	insert(type, groupId, node) {
		const group = this._batchGroups[groupId];

		if (group) {
			if (group._obj[type].indexOf(node) < 0) {
				group._obj[type].push(node);

				this.markGroupDirty(groupId);
			}
		}
	}

	remove(type, groupId, node) {
		const group = this._batchGroups[groupId];

		if (group) {
			const idx = group._obj[type].indexOf(node);

			if (idx >= 0) {
				group._obj[type].splice(idx, 1);

				this.markGroupDirty(groupId);
			}
		}
	}

	_extractRender(node, arr, group, groupMeshInstances) {
		if (node.render) {
			if (node.render.isStatic) {
				const drawCalls = this.scene.drawCalls;
				const nodeMeshInstances = node.render.meshInstances;

				for (let i = 0; i < drawCalls.length; i++) {
					if (!drawCalls[i]._staticSource) continue;
					if (nodeMeshInstances.indexOf(drawCalls[i]._staticSource) < 0) continue;
					arr.push(drawCalls[i]);
				}

				for (let i = 0; i < nodeMeshInstances.length; i++) {
					if (drawCalls.indexOf(nodeMeshInstances[i]) >= 0) {
						arr.push(nodeMeshInstances[i]);
					}
				}
			} else {
				arr = groupMeshInstances[node.render.batchGroupId] = arr.concat(node.render.meshInstances);
			}

			node.render.removeFromLayers();
		}

		return arr;
	}

	_extractModel(node, arr, group, groupMeshInstances) {
		if (node.model && node.model.model) {
			if (node.model.isStatic) {
				const drawCalls = this.scene.drawCalls;
				const nodeMeshInstances = node.model.meshInstances;

				for (let i = 0; i < drawCalls.length; i++) {
					if (!drawCalls[i]._staticSource) continue;
					if (nodeMeshInstances.indexOf(drawCalls[i]._staticSource) < 0) continue;
					arr.push(drawCalls[i]);
				}

				for (let i = 0; i < nodeMeshInstances.length; i++) {
					if (drawCalls.indexOf(nodeMeshInstances[i]) >= 0) {
						arr.push(nodeMeshInstances[i]);
					}
				}
			} else {
				arr = groupMeshInstances[node.model.batchGroupId] = arr.concat(node.model.meshInstances);
			}

			node.model.removeModelFromLayers();
		}

		return arr;
	}

	_extractElement(node, arr, group) {
		if (!node.element) return;
		let valid = false;

		if (node.element._text && node.element._text._model.meshInstances.length > 0) {
			arr.push(node.element._text._model.meshInstances[0]);
			node.element.removeModelFromLayers(node.element._text._model);
			valid = true;
		} else if (node.element._image) {
			arr.push(node.element._image._renderable.meshInstance);
			node.element.removeModelFromLayers(node.element._image._renderable.model);

			if (node.element._image._renderable.unmaskMeshInstance) {
				arr.push(node.element._image._renderable.unmaskMeshInstance);

				if (!node.element._image._renderable.unmaskMeshInstance.stencilFront || !node.element._image._renderable.unmaskMeshInstance.stencilBack) {
					node.element._dirtifyMask();

					node.element._onPrerender();
				}
			}

			valid = true;
		}

		if (valid) {
			group._ui = true;
		}
	}

	_collectAndRemoveMeshInstances(groupMeshInstances, groupIds) {
		for (let g = 0; g < groupIds.length; g++) {
			const id = groupIds[g];
			const group = this._batchGroups[id];
			if (!group) continue;
			let arr = groupMeshInstances[id];
			if (!arr) arr = groupMeshInstances[id] = [];

			for (let m = 0; m < group._obj.model.length; m++) {
				arr = this._extractModel(group._obj.model[m], arr, group, groupMeshInstances);
			}

			for (let r = 0; r < group._obj.render.length; r++) {
				arr = this._extractRender(group._obj.render[r], arr, group, groupMeshInstances);
			}

			for (let e = 0; e < group._obj.element.length; e++) {
				this._extractElement(group._obj.element[e], arr, group);
			}

			for (let s = 0; s < group._obj.sprite.length; s++) {
				const node = group._obj.sprite[s];

				if (node.sprite && node.sprite._meshInstance && (group.dynamic || node.sprite.sprite._renderMode === SPRITE_RENDERMODE_SIMPLE)) {
					arr.push(node.sprite._meshInstance);
					node.sprite.removeModelFromLayers();
					group._sprite = true;
					node.sprite._batchGroup = group;
				}
			}
		}
	}

	generate(groupIds) {
		const groupMeshInstances = {};

		if (!groupIds) {
			groupIds = Object.keys(this._batchGroups);
		}

		const newBatchList = [];

		for (let i = 0; i < this._batchList.length; i++) {
			if (groupIds.indexOf(this._batchList[i].batchGroupId) < 0) {
				newBatchList.push(this._batchList[i]);
				continue;
			}

			this.destroyBatch(this._batchList[i]);
		}

		this._batchList = newBatchList;

		this._collectAndRemoveMeshInstances(groupMeshInstances, groupIds);

		if (groupIds === this._dirtyGroups) {
			this._dirtyGroups.length = 0;
		} else {
			const newDirtyGroups = [];

			for (let i = 0; i < this._dirtyGroups.length; i++) {
				if (groupIds.indexOf(this._dirtyGroups[i]) < 0) newDirtyGroups.push(this._dirtyGroups[i]);
			}

			this._dirtyGroups = newDirtyGroups;
		}

		let group, lists, groupData, batch;

		for (const groupId in groupMeshInstances) {
			if (!groupMeshInstances.hasOwnProperty(groupId)) continue;
			group = groupMeshInstances[groupId];
			groupData = this._batchGroups[groupId];

			if (!groupData) {
				continue;
			}

			lists = this.prepare(group, groupData.dynamic, groupData.maxAabbSize, groupData._ui || groupData._sprite);

			for (let i = 0; i < lists.length; i++) {
				batch = this.create(lists[i], groupData.dynamic, parseInt(groupId, 10));

				if (batch) {
					batch.addToLayers(this.scene, groupData.layers);
				}
			}
		}
	}

	prepare(meshInstances, dynamic, maxAabbSize = Number.POSITIVE_INFINITY, translucent) {
		if (meshInstances.length === 0) return [];
		const halfMaxAabbSize = maxAabbSize * 0.5;
		const maxInstanceCount = this.device.supportsBoneTextures ? 1024 : this.device.boneLimit;
		const maxNumVertices = this.device.extUintElement ? 0xffffffff : 0xffff;
		const aabb = new BoundingBox();
		const testAabb = new BoundingBox();
		let skipTranslucentAabb = null;
		let sf;
		const lists = [];
		let j = 0;

		if (translucent) {
			meshInstances.sort(function (a, b) {
				return a.drawOrder - b.drawOrder;
			});
		}

		let meshInstancesLeftA = meshInstances;
		let meshInstancesLeftB;
		const skipMesh = translucent ? function (mi) {
			if (skipTranslucentAabb) {
				skipTranslucentAabb.add(mi.aabb);
			} else {
				skipTranslucentAabb = mi.aabb.clone();
			}

			meshInstancesLeftB.push(mi);
		} : function (mi) {
			meshInstancesLeftB.push(mi);
		};

		while (meshInstancesLeftA.length > 0) {
			lists[j] = [meshInstancesLeftA[0]];
			meshInstancesLeftB = [];
			const material = meshInstancesLeftA[0].material;
			const layer = meshInstancesLeftA[0].layer;
			const defs = meshInstancesLeftA[0]._shaderDefs;
			const params = meshInstancesLeftA[0].parameters;
			const stencil = meshInstancesLeftA[0].stencilFront;
			const lightList = meshInstancesLeftA[0]._staticLightList;
			let vertCount = meshInstancesLeftA[0].mesh.vertexBuffer.getNumVertices();
			const drawOrder = meshInstancesLeftA[0].drawOrder;
			aabb.copy(meshInstancesLeftA[0].aabb);
			const scaleSign = getScaleSign(meshInstancesLeftA[0]);
			const vertexFormatBatchingHash = meshInstancesLeftA[0].mesh.vertexBuffer.format.batchingHash;
			const indexed = meshInstancesLeftA[0].mesh.primitive[0].indexed;
			skipTranslucentAabb = null;

			for (let i = 1; i < meshInstancesLeftA.length; i++) {
				const mi = meshInstancesLeftA[i];

				if (dynamic && lists[j].length >= maxInstanceCount) {
					meshInstancesLeftB = meshInstancesLeftB.concat(meshInstancesLeftA.slice(i));
					break;
				}

				if (material !== mi.material || layer !== mi.layer || vertexFormatBatchingHash !== mi.mesh.vertexBuffer.format.batchingHash || indexed !== mi.mesh.primitive[0].indexed || defs !== mi._shaderDefs || vertCount + mi.mesh.vertexBuffer.getNumVertices() > maxNumVertices) {
					skipMesh(mi);
					continue;
				}

				testAabb.copy(aabb);
				testAabb.add(mi.aabb);

				if (testAabb.halfExtents.x > halfMaxAabbSize || testAabb.halfExtents.y > halfMaxAabbSize || testAabb.halfExtents.z > halfMaxAabbSize) {
					skipMesh(mi);
					continue;
				}

				if (stencil) {
					if (!(sf = mi.stencilFront) || stencil.func !== sf.func || stencil.zpass !== sf.zpass) {
						skipMesh(mi);
						continue;
					}
				}

				if (scaleSign !== getScaleSign(mi)) {
					skipMesh(mi);
					continue;
				}

				if (!equalParamSets(params, mi.parameters)) {
					skipMesh(mi);
					continue;
				}

				const staticLights = mi._staticLightList;

				if (lightList && staticLights) {
					if (!equalLightLists(lightList, staticLights)) {
						skipMesh(mi);
						continue;
					}
				} else if (lightList || staticLights) {
					skipMesh(mi);
					continue;
				}

				if (translucent && skipTranslucentAabb && skipTranslucentAabb.intersects(mi.aabb) && mi.drawOrder !== drawOrder) {
					skipMesh(mi);
					continue;
				}

				aabb.add(mi.aabb);
				vertCount += mi.mesh.vertexBuffer.getNumVertices();
				lists[j].push(mi);
			}

			j++;
			meshInstancesLeftA = meshInstancesLeftB;
		}

		return lists;
	}

	collectBatchedMeshData(meshInstances, dynamic) {
		let streams = null;
		let batchNumVerts = 0;
		let batchNumIndices = 0;
		let material = null;

		for (let i = 0; i < meshInstances.length; i++) {
			if (meshInstances[i].visible) {
				const mesh = meshInstances[i].mesh;
				const numVerts = mesh.vertexBuffer.numVertices;
				batchNumVerts += numVerts;
				batchNumIndices += mesh.primitive[0].indexed ? mesh.primitive[0].count : mesh.primitive[0].type === PRIMITIVE_TRIFAN && mesh.primitive[0].count === 4 ? 6 : 0;

				if (!streams) {
					material = meshInstances[i].material;
					streams = {};
					const elems = mesh.vertexBuffer.format.elements;

					for (let j = 0; j < elems.length; j++) {
						const semantic = elems[j].name;
						streams[semantic] = {
							numComponents: elems[j].numComponents,
							dataType: elems[j].dataType,
							normalize: elems[j].normalize,
							count: 0
						};
					}

					if (dynamic) {
						streams[SEMANTIC_BLENDINDICES] = {
							numComponents: 1,
							dataType: TYPE_FLOAT32,
							normalize: false,
							count: 0
						};
					}
				}
			}
		}

		return {
			streams: streams,
			batchNumVerts: batchNumVerts,
			batchNumIndices: batchNumIndices,
			material: material
		};
	}

	create(meshInstances, dynamic, batchGroupId) {
		if (!this._init) {
			const boneLimit = "#define BONE_LIMIT " + this.device.getBoneLimit() + "\n";
			this.transformVS = boneLimit + "#define DYNAMICBATCH\n" + shaderChunks.transformVS;
			this.skinTexVS = shaderChunks.skinBatchTexVS;
			this.skinConstVS = shaderChunks.skinBatchConstVS;
			this.vertexFormats = {};
			this._init = true;
		}

		let stream = null;
		let semantic;
		let mesh, numVerts;
		let batch = null;
		const batchData = this.collectBatchedMeshData(meshInstances, dynamic);

		if (batchData.streams) {
			const streams = batchData.streams;
			let material = batchData.material;
			const batchNumVerts = batchData.batchNumVerts;
			const batchNumIndices = batchData.batchNumIndices;
			batch = new Batch(meshInstances, dynamic, batchGroupId);

			this._batchList.push(batch);

			let indexBase, numIndices, indexData;
			let verticesOffset = 0;
			let indexOffset = 0;
			let transform;
			const vec = new Vec3();
			const indexArrayType = batchNumVerts <= 0xffff ? Uint16Array : Uint32Array;
			const indices = new indexArrayType(batchNumIndices);

			for (semantic in streams) {
				stream = streams[semantic];
				stream.typeArrayType = typedArrayTypes[stream.dataType];
				stream.elementByteSize = typedArrayTypesByteSize[stream.dataType];
				stream.buffer = new stream.typeArrayType(batchNumVerts * stream.numComponents);
			}

			for (let i = 0; i < meshInstances.length; i++) {
				if (!meshInstances[i].visible) continue;
				mesh = meshInstances[i].mesh;
				numVerts = mesh.vertexBuffer.numVertices;

				if (!dynamic) {
					transform = meshInstances[i].node.getWorldTransform();
				}

				for (semantic in streams) {
					if (semantic !== SEMANTIC_BLENDINDICES) {
						stream = streams[semantic];
						const subarray = new stream.typeArrayType(stream.buffer.buffer, stream.elementByteSize * stream.count);
						const totalComponents = mesh.getVertexStream(semantic, subarray) * stream.numComponents;
						stream.count += totalComponents;

						if (!dynamic && stream.numComponents >= 3) {
							if (semantic === SEMANTIC_POSITION) {
								for (let j = 0; j < totalComponents; j += stream.numComponents) {
									vec.set(subarray[j], subarray[j + 1], subarray[j + 2]);
									transform.transformPoint(vec, vec);
									subarray[j] = vec.x;
									subarray[j + 1] = vec.y;
									subarray[j + 2] = vec.z;
								}
							} else if (semantic === SEMANTIC_NORMAL || semantic === SEMANTIC_TANGENT) {
								transform.invertTo3x3(mat3);
								mat3.transpose();

								for (let j = 0; j < totalComponents; j += stream.numComponents) {
									vec.set(subarray[j], subarray[j + 1], subarray[j + 2]);
									mat3.transformVector(vec, vec);
									subarray[j] = vec.x;
									subarray[j + 1] = vec.y;
									subarray[j + 2] = vec.z;
								}
							}
						}
					}
				}

				if (dynamic) {
					stream = streams[SEMANTIC_BLENDINDICES];

					for (let j = 0; j < numVerts; j++) stream.buffer[stream.count++] = i;
				}

				if (mesh.primitive[0].indexed) {
					indexBase = mesh.primitive[0].base;
					numIndices = mesh.primitive[0].count;
					const srcFormat = mesh.indexBuffer[0].getFormat();
					indexData = new typedArrayIndexFormats[srcFormat](mesh.indexBuffer[0].storage);
				} else if (mesh.primitive[0].type === PRIMITIVE_TRIFAN && mesh.primitive[0].count === 4) {
					indexBase = 0;
					numIndices = 6;
					indexData = [0, 1, 3, 2, 3, 1];
				} else {
					numIndices = 0;
					continue;
				}

				for (let j = 0; j < numIndices; j++) {
					indices[j + indexOffset] = indexData[indexBase + j] + verticesOffset;
				}

				indexOffset += numIndices;
				verticesOffset += numVerts;
			}

			mesh = new Mesh(this.device);

			for (semantic in streams) {
				stream = streams[semantic];
				mesh.setVertexStream(semantic, stream.buffer, stream.numComponents, undefined, stream.dataType, stream.normalize);
			}

			if (indices.length > 0) mesh.setIndices(indices);
			mesh.update(PRIMITIVE_TRIANGLES, false);

			if (dynamic) {
				material = material.clone();
				material.chunks.transformVS = this.transformVS;
				material.chunks.skinTexVS = this.skinTexVS;
				material.chunks.skinConstVS = this.skinConstVS;
				material.update();
			}

			const meshInstance = new MeshInstance(mesh, material, this.rootNode);
			meshInstance.castShadow = batch.origMeshInstances[0].castShadow;
			meshInstance.parameters = batch.origMeshInstances[0].parameters;
			meshInstance.isStatic = batch.origMeshInstances[0].isStatic;
			meshInstance.layer = batch.origMeshInstances[0].layer;
			meshInstance._staticLightList = batch.origMeshInstances[0]._staticLightList;
			meshInstance._shaderDefs = batch.origMeshInstances[0]._shaderDefs;
			meshInstance.cull = batch.origMeshInstances[0].cull;
			const batchGroup = this._batchGroups[batchGroupId];
			if (batchGroup && batchGroup._ui) meshInstance.cull = false;

			if (dynamic) {
				const nodes = [];

				for (let i = 0; i < batch.origMeshInstances.length; i++) {
					nodes.push(batch.origMeshInstances[i].node);
				}

				meshInstance.skinInstance = new SkinBatchInstance(this.device, nodes, this.rootNode);
			}

			meshInstance._updateAabb = false;
			meshInstance.drawOrder = batch.origMeshInstances[0].drawOrder;
			meshInstance.stencilFront = batch.origMeshInstances[0].stencilFront;
			meshInstance.stencilBack = batch.origMeshInstances[0].stencilBack;
			meshInstance.flipFaces = getScaleSign(batch.origMeshInstances[0]) < 0;
			meshInstance.castShadow = batch.origMeshInstances[0].castShadow;
			batch.meshInstance = meshInstance;
			batch.updateBoundingBox();
		}

		return batch;
	}

	updateAll() {
		if (this._dirtyGroups.length > 0) {
			this.generate(this._dirtyGroups);
		}

		for (let i = 0; i < this._batchList.length; i++) {
			if (!this._batchList[i].dynamic) continue;

			this._batchList[i].updateBoundingBox();
		}
	}

	clone(batch, clonedMeshInstances) {
		const batch2 = new Batch(clonedMeshInstances, batch.dynamic, batch.batchGroupId);

		this._batchList.push(batch2);

		const nodes = [];

		for (let i = 0; i < clonedMeshInstances.length; i++) {
			nodes.push(clonedMeshInstances[i].node);
		}

		batch2.meshInstance = new MeshInstance(batch.meshInstance.mesh, batch.meshInstance.material, batch.meshInstance.node);
		batch2.meshInstance._updateAabb = false;
		batch2.meshInstance.parameters = clonedMeshInstances[0].parameters;
		batch2.meshInstance.isStatic = clonedMeshInstances[0].isStatic;
		batch2.meshInstance.cull = clonedMeshInstances[0].cull;
		batch2.meshInstance.layer = clonedMeshInstances[0].layer;
		batch2.meshInstance._staticLightList = clonedMeshInstances[0]._staticLightList;

		if (batch.dynamic) {
			batch2.meshInstance.skinInstance = new SkinBatchInstance(this.device, nodes, this.rootNode);
		}

		batch2.meshInstance.castShadow = batch.meshInstance.castShadow;
		batch2.meshInstance._shader = batch.meshInstance._shader;
		batch2.meshInstance.castShadow = batch.meshInstance.castShadow;
		return batch2;
	}

	destroyBatch(batch) {
		batch.destroy(this.scene, this._batchGroups[batch.batchGroupId].layers);
	}

}

const tempVec3 = new Vec3();
const tempMin3 = new Vec3();
const tempMax3 = new Vec3();
const tempBox = new BoundingBox();
const epsilon = 0.000001;

class ClusterLight {
	constructor() {
		this.light = null;
		this.min = new Vec3();
		this.max = new Vec3();
	}

}

class WorldClusters {
	constructor(device) {
		this.device = device;
		this.name = "Untitled";
		this.reportCount = 0;
		this.boundsMin = new Vec3();
		this.boundsMax = new Vec3();
		this.boundsDelta = new Vec3();
		this._cells = new Vec3(1, 1, 1);
		this._cellsLimit = new Vec3();
		this.cells = this._cells;
		this._maxCellLightCount = 0;
		this._pixelsPerCellCount = 0;
		this.maxCellLightCount = 4;
		this._maxAttenuation = 0;
		this._maxColorValue = 0;
		this._usedLights = [];

		this._usedLights.push(new ClusterLight());

		this.lightsBuffer = new LightsBuffer(device);
		this.registerUniforms(device);
	}

	set maxCellLightCount(count) {
		const maxCellLightCount = math.roundUp(count, 4);

		if (maxCellLightCount !== this._maxCellLightCount) {
			this._maxCellLightCount = maxCellLightCount;
			this._pixelsPerCellCount = this._maxCellLightCount / 4;
			this._cellsDirty = true;
		}
	}

	get maxCellLightCount() {
		return this._maxCellLightCount;
	}

	set cells(value) {
		tempVec3.copy(value).floor();

		if (!this._cells.equals(tempVec3)) {
			this._cells.copy(tempVec3);

			this._cellsLimit.copy(tempVec3).sub(Vec3.ONE);

			this._cellsDirty = true;
		}
	}

	get cells() {
		return this._cells;
	}

	destroy() {
		this.lightsBuffer.destroy();
		this.releaseClusterTexture();
	}

	releaseClusterTexture() {
		if (this.clusterTexture) {
			this.clusterTexture.destroy();
			this.clusterTexture = null;
		}
	}

	registerUniforms(device) {
		this._clusterWorldTextureId = device.scope.resolve("clusterWorldTexture");
		this._clusterPixelsPerCellId = device.scope.resolve("clusterPixelsPerCell");
		this._clusterTextureSizeId = device.scope.resolve("clusterTextureSize");
		this._clusterTextureSizeData = new Float32Array(3);
		this._clusterBoundsMinId = device.scope.resolve("clusterBoundsMin");
		this._clusterBoundsMinData = new Float32Array(3);
		this._clusterBoundsDeltaId = device.scope.resolve("clusterBoundsDelta");
		this._clusterBoundsDeltaData = new Float32Array(3);
		this._clusterCellsCountByBoundsSizeId = device.scope.resolve("clusterCellsCountByBoundsSize");
		this._clusterCellsCountByBoundsSizeData = new Float32Array(3);
		this._clusterCellsDotId = device.scope.resolve("clusterCellsDot");
		this._clusterCellsDotData = new Float32Array(3);
		this._clusterCellsMaxId = device.scope.resolve("clusterCellsMax");
		this._clusterCellsMaxData = new Float32Array(3);
		this._clusterCompressionLimit0Id = device.scope.resolve("clusterCompressionLimit0");
		this._clusterCompressionLimit0Data = new Float32Array(2);
	}

	updateParams(lightingParams) {
		if (lightingParams) {
			this.cells = lightingParams.cells;
			this.maxCellLightCount = lightingParams.maxLightsPerCell;
			this.lightsBuffer.cookiesEnabled = lightingParams.cookiesEnabled;
			this.lightsBuffer.shadowsEnabled = lightingParams.shadowsEnabled;
			this.lightsBuffer.areaLightsEnabled = lightingParams.areaLightsEnabled;
		}
	}

	updateCells() {
		if (this._cellsDirty) {
			this._cellsDirty = false;
			const cx = this._cells.x;
			const cy = this._cells.y;
			const cz = this._cells.z;
			const numCells = cx * cy * cz;
			const totalPixels = this._pixelsPerCellCount * numCells;
			let width = Math.ceil(Math.sqrt(totalPixels));
			width = math.roundUp(width, this._pixelsPerCellCount);
			const height = Math.ceil(totalPixels / width);
			this._clusterCellsMaxData[0] = cx;
			this._clusterCellsMaxData[1] = cy;
			this._clusterCellsMaxData[2] = cz;
			this._clusterCellsDotData[0] = this._pixelsPerCellCount;
			this._clusterCellsDotData[1] = cx * cz * this._pixelsPerCellCount;
			this._clusterCellsDotData[2] = cx * this._pixelsPerCellCount;
			this.clusters = new Uint8ClampedArray(4 * totalPixels);
			this.counts = new Int32Array(numCells);
			this._clusterTextureSizeData[0] = width;
			this._clusterTextureSizeData[1] = 1.0 / width;
			this._clusterTextureSizeData[2] = 1.0 / height;
			this.releaseClusterTexture();
			this.clusterTexture = LightsBuffer.createTexture(this.device, width, height, PIXELFORMAT_R8_G8_B8_A8, "ClusterTexture");
		}
	}

	uploadTextures() {
		this.clusterTexture.lock().set(this.clusters);
		this.clusterTexture.unlock();
		this.lightsBuffer.uploadTextures();
	}

	updateUniforms() {
		this.lightsBuffer.updateUniforms();

		this._clusterWorldTextureId.setValue(this.clusterTexture);

		const boundsDelta = this.boundsDelta;
		this._clusterCellsCountByBoundsSizeData[0] = this._cells.x / boundsDelta.x;
		this._clusterCellsCountByBoundsSizeData[1] = this._cells.y / boundsDelta.y;
		this._clusterCellsCountByBoundsSizeData[2] = this._cells.z / boundsDelta.z;

		this._clusterCellsCountByBoundsSizeId.setValue(this._clusterCellsCountByBoundsSizeData);

		this._clusterBoundsMinData[0] = this.boundsMin.x;
		this._clusterBoundsMinData[1] = this.boundsMin.y;
		this._clusterBoundsMinData[2] = this.boundsMin.z;
		this._clusterBoundsDeltaData[0] = boundsDelta.x;
		this._clusterBoundsDeltaData[1] = boundsDelta.y;
		this._clusterBoundsDeltaData[2] = boundsDelta.z;
		this._clusterCompressionLimit0Data[0] = this._maxAttenuation;
		this._clusterCompressionLimit0Data[1] = this._maxColorValue;

		this._clusterPixelsPerCellId.setValue(this._pixelsPerCellCount);

		this._clusterTextureSizeId.setValue(this._clusterTextureSizeData);

		this._clusterBoundsMinId.setValue(this._clusterBoundsMinData);

		this._clusterBoundsDeltaId.setValue(this._clusterBoundsDeltaData);

		this._clusterCellsDotId.setValue(this._clusterCellsDotData);

		this._clusterCellsMaxId.setValue(this._clusterCellsMaxData);

		this._clusterCompressionLimit0Id.setValue(this._clusterCompressionLimit0Data);
	}

	evalLightCellMinMax(clusteredLight, min, max) {
		min.copy(clusteredLight.min);
		min.sub(this.boundsMin);
		min.div(this.boundsDelta);
		min.mul2(min, this.cells);
		min.floor();
		max.copy(clusteredLight.max);
		max.sub(this.boundsMin);
		max.div(this.boundsDelta);
		max.mul2(max, this.cells);
		max.ceil();
		min.max(Vec3.ZERO);
		max.min(this._cellsLimit);
	}

	collectLights(lights) {
		const maxLights = this.lightsBuffer.maxLights;
		const usedLights = this._usedLights;
		let lightIndex = 1;

		for (let i = 0; i < lights.length; i++) {
			const light = lights[i];
			const runtimeLight = !!(light.mask & (MASK_AFFECT_DYNAMIC | MASK_AFFECT_LIGHTMAPPED));

			if (light.enabled && light.type !== LIGHTTYPE_DIRECTIONAL && light.visibleThisFrame && light.intensity > 0 && runtimeLight) {
				if (lightIndex < maxLights) {
					let clusteredLight;

					if (lightIndex < usedLights.length) {
						clusteredLight = usedLights[lightIndex];
					} else {
						clusteredLight = new ClusterLight();
						usedLights.push(clusteredLight);
					}

					clusteredLight.light = light;
					light.getBoundingBox(tempBox);
					clusteredLight.min.copy(tempBox.getMin());
					clusteredLight.max.copy(tempBox.getMax());
					lightIndex++;
				} else {
					console.warn(`Clustered lighting: more than ${maxLights - 1} lights in the frame, ignoring some.`);
					break;
				}
			}
		}

		usedLights.length = lightIndex;
	}

	evaluateBounds() {
		const usedLights = this._usedLights;
		const min = this.boundsMin;
		const max = this.boundsMax;

		if (usedLights.length > 1) {
			min.copy(usedLights[1].min);
			max.copy(usedLights[1].max);

			for (let i = 2; i < usedLights.length; i++) {
				min.min(usedLights[i].min);
				max.max(usedLights[i].max);
			}
		} else {
			min.set(0, 0, 0);
			max.set(1, 1, 1);
		}

		this.boundsDelta.sub2(max, min);
		this.lightsBuffer.setBounds(min, this.boundsDelta);
	}

	evaluateCompressionLimits(gammaCorrection) {
		let maxAttenuation = 0;
		let maxColorValue = 0;
		const usedLights = this._usedLights;

		for (let i = 1; i < usedLights.length; i++) {
			const light = usedLights[i].light;
			maxAttenuation = Math.max(light.attenuationEnd, maxAttenuation);
			const color = gammaCorrection ? light._linearFinalColor : light._finalColor;
			maxColorValue = Math.max(color[0], maxColorValue);
			maxColorValue = Math.max(color[1], maxColorValue);
			maxColorValue = Math.max(color[2], maxColorValue);
		}

		this._maxAttenuation = maxAttenuation + epsilon;
		this._maxColorValue = maxColorValue + epsilon;
		this.lightsBuffer.setCompressionRanges(this._maxAttenuation, this._maxColorValue);
	}

	updateClusters(gammaCorrection) {
		this.counts.fill(0);
		this.clusters.fill(0);
		const divX = this._cells.x;
		const divZ = this._cells.z;
		const counts = this.counts;
		const limit = this._maxCellLightCount;
		const clusters = this.clusters;
		const pixelsPerCellCount = this._pixelsPerCellCount;
		const usedLights = this._usedLights;

		for (let i = 1; i < usedLights.length; i++) {
			const clusteredLight = usedLights[i];
			const light = clusteredLight.light;
			this.lightsBuffer.addLightData(light, i, gammaCorrection);
			this.evalLightCellMinMax(clusteredLight, tempMin3, tempMax3);
			const xStart = tempMin3.x;
			const xEnd = tempMax3.x;
			const yStart = tempMin3.y;
			const yEnd = tempMax3.y;
			const zStart = tempMin3.z;
			const zEnd = tempMax3.z;

			for (let x = xStart; x <= xEnd; x++) {
				for (let z = zStart; z <= zEnd; z++) {
					for (let y = yStart; y <= yEnd; y++) {
						const clusterIndex = x + divX * (z + y * divZ);
						const count = counts[clusterIndex];

						if (count < limit) {
							clusters[pixelsPerCellCount * clusterIndex * 4 + count] = i;
							counts[clusterIndex] = count + 1;
						}
					}
				}
			}
		}
	}

	update(lights, gammaCorrection, lightingParams) {
		this.updateParams(lightingParams);
		this.updateCells();
		this.collectLights(lights);
		this.evaluateBounds();
		this.evaluateCompressionLimits(gammaCorrection);
		this.updateClusters(gammaCorrection);
		this.uploadTextures();
	}

	activate() {
		this.updateUniforms();
	}

}

const textureBlitVertexShader = `
		attribute vec2 vertex_position;
		varying vec2 uv0;
		void main(void) {
				gl_Position = vec4(vertex_position, 0.5, 1.0);
				uv0 = vertex_position.xy * 0.5 + 0.5;
		}`;
const textureBlitFragmentShader = `
		varying vec2 uv0;
		uniform sampler2D blitTexture;
		void main(void) {
				gl_FragColor = texture2D(blitTexture, uv0);
		}`;
const textureCubeBlitFragmentShader = `
		varying vec2 uv0;
		uniform samplerCube blitTexture;
		uniform mat4 invViewProj;
		void main(void) {
				vec4 projPos = vec4(uv0 * 2.0 - 1.0, 0.5, 1.0);
				vec4 worldPos = invViewProj * projPos;
				gl_FragColor = textureCube(blitTexture, worldPos.xyz);
		}`;

const _viewport$1 = new Vec4();

class CookieRenderer {
	constructor(device, lightTextureAtlas) {
		this.device = device;
		this.lightTextureAtlas = lightTextureAtlas;
		this.blitShader2d = null;
		this.blitShaderCube = null;
		this.blitTextureId = null;
		this.invViewProjId = null;
	}

	destroy() {}

	getShader(shader, fragment) {
		if (!this[shader]) this[shader] = createShaderFromCode(this.device, textureBlitVertexShader, fragment, `cookie_renderer_${shader}`);
		if (!this.blitTextureId) this.blitTextureId = this.device.scope.resolve("blitTexture");
		if (!this.invViewProjId) this.invViewProjId = this.device.scope.resolve("invViewProj");
		return this[shader];
	}

	get shader2d() {
		return this.getShader("blitShader2d", textureBlitFragmentShader);
	}

	get shaderCube() {
		return this.getShader("blitShaderCube", textureCubeBlitFragmentShader);
	}

	static createTexture(device, resolution) {
		const texture = new Texture(device, {
			name: "CookieAtlas",
			width: resolution,
			height: resolution,
			format: PIXELFORMAT_R8_G8_B8_A8,
			cubemap: false,
			mipmaps: false,
			minFilter: FILTER_NEAREST,
			magFilter: FILTER_NEAREST,
			addressU: ADDRESS_CLAMP_TO_EDGE,
			addressV: ADDRESS_CLAMP_TO_EDGE
		});
		return texture;
	}

	initInvViewProjMatrices() {
		if (!CookieRenderer._invViewProjMatrices) {
			CookieRenderer._invViewProjMatrices = [];

			for (let face = 0; face < 6; face++) {
				const camera = LightCamera.create(null, LIGHTTYPE_OMNI, face);
				const projMat = camera.projectionMatrix;
				const viewMat = camera.node.getLocalTransform().clone().invert();
				CookieRenderer._invViewProjMatrices[face] = new Mat4().mul2(projMat, viewMat).invert();
			}
		}
	}

	render(light, renderTarget) {
		if (light.enabled && light.cookie && light.visibleThisFrame) {
			const faceCount = light.numShadowFaces;
			const shader = faceCount > 1 ? this.shaderCube : this.shader2d;
			const device = this.device;

			if (faceCount > 1) {
				this.initInvViewProjMatrices();
			}

			this.blitTextureId.setValue(light.cookie);

			for (let face = 0; face < faceCount; face++) {
				_viewport$1.copy(light.atlasViewport);

				if (faceCount > 1) {
					const smallSize = _viewport$1.z / 3;
					const offset = this.lightTextureAtlas.cubeSlotsOffsets[face];
					_viewport$1.x += smallSize * offset.x;
					_viewport$1.y += smallSize * offset.y;
					_viewport$1.z = smallSize;
					_viewport$1.w = smallSize;
					this.invViewProjId.setValue(CookieRenderer._invViewProjMatrices[face].data);
				}

				_viewport$1.mulScalar(renderTarget.colorBuffer.width);

				drawQuadWithShader(device, renderTarget, shader, _viewport$1);
			}
		}
	}

}

CookieRenderer._invViewProjMatrices = null;

class ShadowMap {
	constructor(texture, targets) {
		this.texture = texture;
		this.cached = false;
		this.renderTargets = targets;
	}

	destroy() {
		if (this.texture) {
			this.texture.destroy();
			this.texture = null;
		}

		const targets = this.renderTargets;

		for (let i = 0; i < targets.length; i++) {
			targets[i].destroy();
		}

		this.renderTargets.length = 0;
	}

	static getShadowFormat(device, shadowType) {
		if (shadowType === SHADOW_VSM32) {
			return PIXELFORMAT_RGBA32F;
		} else if (shadowType === SHADOW_VSM16) {
			return PIXELFORMAT_RGBA16F;
		} else if (shadowType === SHADOW_PCF5) {
			return PIXELFORMAT_DEPTH;
		} else if (shadowType === SHADOW_PCF3 && device.webgl2) {
			return PIXELFORMAT_DEPTH;
		}

		return PIXELFORMAT_R8_G8_B8_A8;
	}

	static getShadowFiltering(device, shadowType) {
		if (shadowType === SHADOW_PCF3 && !device.webgl2) {
			return FILTER_NEAREST;
		} else if (shadowType === SHADOW_VSM32) {
			return device.extTextureFloatLinear ? FILTER_LINEAR : FILTER_NEAREST;
		} else if (shadowType === SHADOW_VSM16) {
			return device.extTextureHalfFloatLinear ? FILTER_LINEAR : FILTER_NEAREST;
		}

		return FILTER_LINEAR;
	}

	static create(device, light) {
		let shadowMap = null;

		if (light._type === LIGHTTYPE_OMNI) {
			shadowMap = this.createCubemap(device, light._shadowResolution);
		} else {
			shadowMap = this.create2dMap(device, light._shadowResolution, light._shadowType);
		}

		return shadowMap;
	}

	static createAtlas(device, resolution, shadowType) {
		const shadowMap = this.create2dMap(device, resolution, shadowType);
		const targets = shadowMap.renderTargets;
		const rt = targets[0];

		for (let i = 0; i < 5; i++) {
			targets.push(rt);
		}

		return shadowMap;
	}

	static create2dMap(device, size, shadowType) {
		const format = this.getShadowFormat(device, shadowType);
		const filter = this.getShadowFiltering(device, shadowType);
		const texture = new Texture(device, {
			format: format,
			width: size,
			height: size,
			mipmaps: false,
			minFilter: filter,
			magFilter: filter,
			addressU: ADDRESS_CLAMP_TO_EDGE,
			addressV: ADDRESS_CLAMP_TO_EDGE
		});
		texture.name = 'ShadowMap2D';
		let target = null;

		if (shadowType === SHADOW_PCF5 || shadowType === SHADOW_PCF3 && device.webgl2) {
			texture.compareOnRead = true;
			texture.compareFunc = FUNC_LESS;
			target = new RenderTarget({
				depthBuffer: texture
			});
		} else {
			target = new RenderTarget({
				colorBuffer: texture,
				depth: true
			});
		}

		return new ShadowMap(texture, [target]);
	}

	static createCubemap(device, size) {
		const cubemap = new Texture(device, {
			format: PIXELFORMAT_R8_G8_B8_A8,
			width: size,
			height: size,
			cubemap: true,
			mipmaps: false,
			minFilter: FILTER_NEAREST,
			magFilter: FILTER_NEAREST,
			addressU: ADDRESS_CLAMP_TO_EDGE,
			addressV: ADDRESS_CLAMP_TO_EDGE
		});
		cubemap.name = 'ShadowMapCube';
		const targets = [];

		for (let i = 0; i < 6; i++) {
			const target = new RenderTarget({
				colorBuffer: cubemap,
				face: i,
				depth: true
			});
			targets.push(target);
		}

		return new ShadowMap(cubemap, targets);
	}

}

const _tempArray = [];
const _tempArray2 = [];

const _viewport = new Vec4();

const _scissor = new Vec4();

class Slot {
	constructor(rect) {
		this.size = Math.floor(rect.w * 1024);
		this.used = false;
		this.lightId = -1;
		this.rect = rect;
	}

}

class LightTextureAtlas {
	constructor(device) {
		this.device = device;
		this.version = 1;
		this.shadowAtlasResolution = 2048;
		this.shadowAtlas = null;
		this.shadowEdgePixels = 3;
		this.cookieAtlasResolution = 2048;
		this.cookieAtlas = null;
		this.cookieRenderTarget = null;
		this.slots = [];
		this.atlasSplit = [];
		this.cubeSlotsOffsets = [new Vec2(0, 0), new Vec2(0, 1), new Vec2(1, 0), new Vec2(1, 1), new Vec2(2, 0), new Vec2(2, 1)];
		this.scissorVec = new Vec4();
		this.allocateShadowAtlas(1);
		this.allocateCookieAtlas(1);
		this.allocateUniforms();
	}

	destroy() {
		this.destroyShadowAtlas();
		this.destroyCookieAtlas();
	}

	destroyShadowAtlas() {
		if (this.shadowAtlas) {
			this.shadowAtlas.destroy();
			this.shadowAtlas = null;
		}
	}

	destroyCookieAtlas() {
		if (this.cookieAtlas) {
			this.cookieAtlas.destroy();
			this.cookieAtlas = null;
		}

		if (this.cookieRenderTarget) {
			this.cookieRenderTarget.destroy();
			this.cookieRenderTarget = null;
		}
	}

	allocateShadowAtlas(resolution) {
		if (!this.shadowAtlas || this.shadowAtlas.texture.width !== resolution) {
			this.version++;
			this.destroyShadowAtlas();
			this.shadowAtlas = ShadowMap.createAtlas(this.device, resolution, SHADOW_PCF3);
			this.shadowAtlas.cached = true;
			const scissorOffset = 4 / this.shadowAtlasResolution;
			this.scissorVec.set(scissorOffset, scissorOffset, -2 * scissorOffset, -2 * scissorOffset);
		}
	}

	allocateCookieAtlas(resolution) {
		if (!this.cookieAtlas || this.cookieAtlas.width !== resolution) {
			this.version++;
			this.destroyCookieAtlas();
			this.cookieAtlas = CookieRenderer.createTexture(this.device, resolution);
			this.cookieRenderTarget = new RenderTarget({
				colorBuffer: this.cookieAtlas,
				depth: false,
				flipY: true
			});
		}
	}

	allocateUniforms() {
		this._shadowAtlasTextureId = this.device.scope.resolve("shadowAtlasTexture");
		this._shadowAtlasParamsId = this.device.scope.resolve("shadowAtlasParams");
		this._shadowAtlasParams = new Float32Array(2);
		this._cookieAtlasTextureId = this.device.scope.resolve("cookieAtlasTexture");
	}

	updateUniforms() {
		const isShadowFilterPcf = true;
		const rt = this.shadowAtlas.renderTargets[0];
		const shadowBuffer = this.device.webgl2 && isShadowFilterPcf ? rt.depthBuffer : rt.colorBuffer;

		this._shadowAtlasTextureId.setValue(shadowBuffer);

		this._shadowAtlasParams[0] = this.shadowAtlasResolution;
		this._shadowAtlasParams[1] = this.shadowEdgePixels;

		this._shadowAtlasParamsId.setValue(this._shadowAtlasParams);

		this._cookieAtlasTextureId.setValue(this.cookieAtlas);
	}

	subdivide(numLights, lightingParams) {
		let atlasSplit = lightingParams.atlasSplit;

		if (!atlasSplit) {
			const gridSize = Math.ceil(Math.sqrt(numLights));
			atlasSplit = _tempArray2;
			atlasSplit[0] = gridSize;
			atlasSplit.length = 1;
		}

		const arraysEqual = (a, b) => a.length === b.length && a.every((v, i) => v === b[i]);

		if (!arraysEqual(atlasSplit, this.atlasSplit)) {
			this.version++;
			this.slots.length = 0;
			this.atlasSplit.length = 0;
			this.atlasSplit.push(...atlasSplit);
			const splitCount = this.atlasSplit[0];

			if (splitCount > 1) {
				const invSize = 1 / splitCount;

				for (let i = 0; i < splitCount; i++) {
					for (let j = 0; j < splitCount; j++) {
						const rect = new Vec4(i * invSize, j * invSize, invSize, invSize);
						const nextLevelSplit = this.atlasSplit[1 + i * splitCount + j];

						if (nextLevelSplit > 1) {
							for (let x = 0; x < nextLevelSplit; x++) {
								for (let y = 0; y < nextLevelSplit; y++) {
									const invSizeNext = invSize / nextLevelSplit;
									const rectNext = new Vec4(rect.x + x * invSizeNext, rect.y + y * invSizeNext, invSizeNext, invSizeNext);
									this.slots.push(new Slot(rectNext));
								}
							}
						} else {
							this.slots.push(new Slot(rect));
						}
					}
				}
			} else {
				this.slots.push(new Slot(new Vec4(0, 0, 1, 1)));
			}

			this.slots.sort((a, b) => {
				return b.size - a.size;
			});
		}
	}

	collectLights(spotLights, omniLights, lightingParams) {
		const cookiesEnabled = lightingParams.cookiesEnabled;
		const shadowsEnabled = lightingParams.shadowsEnabled;
		let needsShadowAtlas = false;
		let needsCookieAtlas = false;
		const lights = _tempArray;
		lights.length = 0;

		const processLights = list => {
			for (let i = 0; i < list.length; i++) {
				const light = list[i];

				if (light.visibleThisFrame) {
					const lightShadow = shadowsEnabled && light.castShadows;
					const lightCookie = cookiesEnabled && !!light.cookie;
					needsShadowAtlas || (needsShadowAtlas = lightShadow);
					needsCookieAtlas || (needsCookieAtlas = lightCookie);

					if (lightShadow || lightCookie) {
						lights.push(light);
					}
				}
			}
		};

		if (cookiesEnabled || shadowsEnabled) {
			processLights(spotLights);
			processLights(omniLights);
		}

		lights.sort((a, b) => {
			return b.maxScreenSize - a.maxScreenSize;
		});

		if (needsShadowAtlas) {
			this.allocateShadowAtlas(this.shadowAtlasResolution);
		}

		if (needsCookieAtlas) {
			this.allocateCookieAtlas(this.cookieAtlasResolution);
		}

		if (needsShadowAtlas || needsCookieAtlas) {
			this.subdivide(lights.length, lightingParams);
		}

		return lights;
	}

	setupSlot(light, rect) {
		light.atlasViewport.copy(rect);
		const faceCount = light.numShadowFaces;

		for (let face = 0; face < faceCount; face++) {
			if (light.castShadows || light._cookie) {
				_viewport.copy(rect);

				_scissor.copy(rect);

				if (light._type === LIGHTTYPE_SPOT) {
					_viewport.add(this.scissorVec);
				}

				if (light._type === LIGHTTYPE_OMNI) {
					const smallSize = _viewport.z / 3;
					const offset = this.cubeSlotsOffsets[face];
					_viewport.x += smallSize * offset.x;
					_viewport.y += smallSize * offset.y;
					_viewport.z = smallSize;
					_viewport.w = smallSize;

					_scissor.copy(_viewport);
				}

				if (light.castShadows) {
					const lightRenderData = light.getRenderData(null, face);
					lightRenderData.shadowViewport.copy(_viewport);
					lightRenderData.shadowScissor.copy(_scissor);
				}
			}
		}
	}

	assignSlot(light, slotIndex, slotReassigned) {
		light.atlasViewportAllocated = true;
		const slot = this.slots[slotIndex];
		slot.lightId = light.id;
		slot.used = true;

		if (slotReassigned) {
			light.atlasSlotUpdated = true;
			light.atlasVersion = this.version;
			light.atlasSlotIndex = slotIndex;
		}
	}

	update(spotLights, omniLights, lightingParams) {
		this.shadowAtlasResolution = lightingParams.shadowAtlasResolution;
		this.cookieAtlasResolution = lightingParams.cookieAtlasResolution;
		const lights = this.collectLights(spotLights, omniLights, lightingParams);

		if (lights.length > 0) {
			const slots = this.slots;

			for (let i = 0; i < slots.length; i++) {
				slots[i].used = false;
			}

			const assignCount = Math.min(lights.length, slots.length);

			for (let i = 0; i < assignCount; i++) {
				const light = lights[i];
				if (light.castShadows) light._shadowMap = this.shadowAtlas;
				const previousSlot = slots[light.atlasSlotIndex];

				if (light.atlasVersion === this.version && light.id === (previousSlot == null ? void 0 : previousSlot.lightId)) {
					const _previousSlot = slots[light.atlasSlotIndex];

					if (_previousSlot.size === slots[i].size && !_previousSlot.used) {
						this.assignSlot(light, light.atlasSlotIndex, false);
					}
				}
			}

			let usedCount = 0;

			for (let i = 0; i < assignCount; i++) {
				while (usedCount < slots.length && slots[usedCount].used) usedCount++;

				const light = lights[i];

				if (!light.atlasViewportAllocated) {
					this.assignSlot(light, usedCount, true);
				}

				const slot = slots[light.atlasSlotIndex];
				this.setupSlot(light, slot.rect);
			}
		}

		this.updateUniforms();
	}

}

class ShadowMapCache {
	constructor() {
		this.shadowMapCache = new Map();
	}

	destroy() {
		this.clear();
		this.shadowMapCache = null;
	}

	clear() {
		this.shadowMapCache.forEach(shadowMaps => {
			shadowMaps.forEach(shadowMap => {
				shadowMap.destroy();
			});
		});
		this.shadowMapCache.clear();
	}

	getKey(light) {
		const isCubeMap = light._type === LIGHTTYPE_OMNI;
		const shadowType = light._shadowType;
		const resolution = light._shadowResolution;
		return `${isCubeMap}-${shadowType}-${resolution}`;
	}

	get(device, light) {
		const key = this.getKey(light);
		const shadowMaps = this.shadowMapCache.get(key);

		if (shadowMaps && shadowMaps.length) {
			return shadowMaps.pop();
		}

		const shadowMap = ShadowMap.create(device, light);
		shadowMap.cached = true;
		return shadowMap;
	}

	add(light, shadowMap) {
		const key = this.getKey(light);
		const shadowMaps = this.shadowMapCache.get(key);

		if (shadowMaps) {
			shadowMaps.push(shadowMap);
		} else {
			this.shadowMapCache.set(key, [shadowMap]);
		}
	}

}

const aabbPoints = [new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3()];
const _depthRange = {
	min: 0,
	max: 0
};

function getDepthRange(cameraViewMatrix, aabbMin, aabbMax) {
	aabbPoints[0].x = aabbPoints[1].x = aabbPoints[2].x = aabbPoints[3].x = aabbMin.x;
	aabbPoints[1].y = aabbPoints[3].y = aabbPoints[7].y = aabbPoints[5].y = aabbMin.y;
	aabbPoints[2].z = aabbPoints[3].z = aabbPoints[6].z = aabbPoints[7].z = aabbMin.z;
	aabbPoints[4].x = aabbPoints[5].x = aabbPoints[6].x = aabbPoints[7].x = aabbMax.x;
	aabbPoints[0].y = aabbPoints[2].y = aabbPoints[4].y = aabbPoints[6].y = aabbMax.y;
	aabbPoints[0].z = aabbPoints[1].z = aabbPoints[4].z = aabbPoints[5].z = aabbMax.z;
	let minz = 9999999999;
	let maxz = -9999999999;

	for (let i = 0; i < 8; ++i) {
		cameraViewMatrix.transformPoint(aabbPoints[i], aabbPoints[i]);
		const z = aabbPoints[i].z;
		if (z < minz) minz = z;
		if (z > maxz) maxz = z;
	}

	_depthRange.min = minz;
	_depthRange.max = maxz;
	return _depthRange;
}

function gauss(x, sigma) {
	return Math.exp(-(x * x) / (2.0 * sigma * sigma));
}

const maxBlurSize = 25;

function gaussWeights(kernelSize) {
	if (kernelSize > maxBlurSize) {
		kernelSize = maxBlurSize;
	}

	const sigma = (kernelSize - 1) / (2 * 3);
	const halfWidth = (kernelSize - 1) * 0.5;
	const values = new Array(kernelSize);
	let sum = 0.0;

	for (let i = 0; i < kernelSize; ++i) {
		values[i] = gauss(i - halfWidth, sigma);
		sum += values[i];
	}

	for (let i = 0; i < kernelSize; ++i) {
		values[i] /= sum;
	}

	return values;
}

const visibleSceneAabb = new BoundingBox();
const shadowCamView = new Mat4();
const shadowCamViewProj = new Mat4();
const pixelOffset = new Float32Array(2);
const blurScissorRect = {
	x: 1,
	y: 1,
	z: 0,
	w: 0
};
const opChanId = {
	r: 1,
	g: 2,
	b: 3,
	a: 4
};
const center = new Vec3();
const viewportMatrix = new Mat4();

function getDepthKey(meshInstance) {
	const material = meshInstance.material;
	const x = meshInstance.skinInstance ? 10 : 0;
	let y = 0;

	if (material.opacityMap) {
		const opChan = material.opacityMapChannel;

		if (opChan) {
			y = opChanId[opChan];
		}
	}

	return x + y;
}

class ShadowRenderer {
	constructor(forwardRenderer, lightTextureAtlas) {
		this.device = forwardRenderer.device;
		this.forwardRenderer = forwardRenderer;
		this.lightTextureAtlas = lightTextureAtlas;
		const scope = this.device.scope;
		this.polygonOffsetId = scope.resolve("polygonOffset");
		this.polygonOffset = new Float32Array(2);
		this.sourceId = scope.resolve("source");
		this.pixelOffsetId = scope.resolve("pixelOffset");
		this.weightId = scope.resolve("weight[0]");
		this.blurVsmShaderCode = [shaderChunks.blurVSMPS, "#define GAUSS\n" + shaderChunks.blurVSMPS];
		const packed = "#define PACKED\n";
		this.blurPackedVsmShaderCode = [packed + this.blurVsmShaderCode[0], packed + this.blurVsmShaderCode[1]];
		this.blurVsmShader = [{}, {}];
		this.blurPackedVsmShader = [{}, {}];
		this.blurVsmWeights = {};
		this.shadowMapLightRadiusId = scope.resolve('light_radius');
		this.shadowMapCache = new ShadowMapCache();
	}

	destroy() {
		this.shadowMapCache.destroy();
		this.shadowMapCache = null;
	}

	static createShadowCamera(device, shadowType, type, face) {
		const shadowCam = LightCamera.create("ShadowCamera", type, face);

		if (shadowType >= SHADOW_VSM8 && shadowType <= SHADOW_VSM32) {
			shadowCam.clearColor = new Color(0, 0, 0, 0);
		} else {
			shadowCam.clearColor = new Color(1, 1, 1, 1);
		}

		shadowCam.clearDepthBuffer = true;
		shadowCam.clearStencilBuffer = false;
		return shadowCam;
	}

	static setShadowCameraSettings(shadowCam, device, shadowType, type, isClustered) {
		let hwPcf = shadowType === SHADOW_PCF5 || shadowType === SHADOW_PCF3 && device.webgl2;

		if (type === LIGHTTYPE_OMNI && !isClustered) {
			hwPcf = false;
		}

		shadowCam.clearColorBuffer = !hwPcf;
	}

	cullShadowCasters(meshInstances, visible, camera) {
		let count = 0;
		const numInstances = meshInstances.length;

		for (let i = 0; i < numInstances; i++) {
			const meshInstance = meshInstances[i];

			if (!meshInstance.cull || meshInstance._isVisible(camera)) {
				meshInstance.visibleThisFrame = true;
				visible[count] = meshInstance;
				count++;
			}
		}

		visible.length = count;
		visible.sort(this.forwardRenderer.depthSortCompare);
	}

	cullLocal(light, drawCalls) {
		const isClustered = this.forwardRenderer.scene.clusteredLightingEnabled;
		light.visibleThisFrame = true;

		if (!isClustered) {
			if (!light._shadowMap) {
				light._shadowMap = ShadowMap.create(this.device, light);
			}
		}

		const type = light._type;
		const faceCount = type === LIGHTTYPE_SPOT ? 1 : 6;

		for (let face = 0; face < faceCount; face++) {
			const lightRenderData = light.getRenderData(null, face);
			const shadowCam = lightRenderData.shadowCamera;
			shadowCam.nearClip = light.attenuationEnd / 1000;
			shadowCam.farClip = light.attenuationEnd;
			const shadowCamNode = shadowCam._node;
			const lightNode = light._node;
			shadowCamNode.setPosition(lightNode.getPosition());

			if (type === LIGHTTYPE_SPOT) {
				shadowCam.fov = light._outerConeAngle * 2;
				shadowCamNode.setRotation(lightNode.getRotation());
				shadowCamNode.rotateLocal(-90, 0, 0);
			} else if (type === LIGHTTYPE_OMNI) {
				if (isClustered) {
					const tileSize = this.lightTextureAtlas.shadowAtlasResolution * light.atlasViewport.z / 3;
					const texelSize = 2 / tileSize;
					const filterSize = texelSize * this.lightTextureAtlas.shadowEdgePixels;
					shadowCam.fov = Math.atan(1 + filterSize) * math.RAD_TO_DEG * 2;
				} else {
					shadowCam.fov = 90;
				}
			}

			this.forwardRenderer.updateCameraFrustum(shadowCam);
			this.cullShadowCasters(drawCalls, lightRenderData.visibleCasters, shadowCam);
		}
	}

	generateSplitDistances(light, nearDist, farDist) {
		light._shadowCascadeDistances.fill(farDist);

		for (let i = 1; i < light.numCascades; i++) {
			const fraction = i / light.numCascades;
			const linearDist = nearDist + (farDist - nearDist) * fraction;
			const logDist = nearDist * (farDist / nearDist) ** fraction;
			const dist = math.lerp(linearDist, logDist, light.cascadeDistribution);
			light._shadowCascadeDistances[i - 1] = dist;
		}
	}

	cullDirectional(light, drawCalls, camera) {
		light.visibleThisFrame = true;

		if (!light._shadowMap) {
			light._shadowMap = ShadowMap.create(this.device, light);
		}

		const nearDist = camera._nearClip;
		this.generateSplitDistances(light, nearDist, light.shadowDistance);

		for (let cascade = 0; cascade < light.numCascades; cascade++) {
			const lightRenderData = light.getRenderData(camera, cascade);
			const shadowCam = lightRenderData.shadowCamera;
			shadowCam.renderTarget = light._shadowMap.renderTargets[0];
			lightRenderData.shadowViewport.copy(light.cascades[cascade]);
			lightRenderData.shadowScissor.copy(light.cascades[cascade]);
			const shadowCamNode = shadowCam._node;
			const lightNode = light._node;
			shadowCamNode.setPosition(lightNode.getPosition());
			shadowCamNode.setRotation(lightNode.getRotation());
			shadowCamNode.rotateLocal(-90, 0, 0);
			const frustumNearDist = cascade === 0 ? nearDist : light._shadowCascadeDistances[cascade - 1];
			const frustumFarDist = light._shadowCascadeDistances[cascade];
			const frustumPoints = Frustum.getPoints(camera, frustumNearDist, frustumFarDist);
			center.set(0, 0, 0);
			const cameraWorldMat = camera.node.getWorldTransform();

			for (let i = 0; i < 8; i++) {
				cameraWorldMat.transformPoint(frustumPoints[i], frustumPoints[i]);
				center.add(frustumPoints[i]);
			}

			center.mulScalar(1 / 8);
			let radius = 0;

			for (let i = 0; i < 8; i++) {
				const dist = frustumPoints[i].sub(center).length();
				if (dist > radius) radius = dist;
			}

			const right = shadowCamNode.right;
			const up = shadowCamNode.up;
			const lightDir = shadowCamNode.forward;
			const sizeRatio = 0.25 * light._shadowResolution / radius;
			const x = Math.ceil(center.dot(up) * sizeRatio) / sizeRatio;
			const y = Math.ceil(center.dot(right) * sizeRatio) / sizeRatio;
			const scaledUp = up.mulScalar(x);
			const scaledRight = right.mulScalar(y);
			const dot = center.dot(lightDir);
			const scaledDir = lightDir.mulScalar(dot);
			center.add2(scaledUp, scaledRight).add(scaledDir);
			shadowCamNode.setPosition(center);
			shadowCamNode.translateLocal(0, 0, 1000000);
			shadowCam.nearClip = 0;
			shadowCam.farClip = 2000000;
			shadowCam.orthoHeight = radius;
			this.forwardRenderer.updateCameraFrustum(shadowCam);
			this.cullShadowCasters(drawCalls, lightRenderData.visibleCasters, shadowCam);
			let emptyAabb = true;
			const visibleCasters = lightRenderData.visibleCasters;

			for (let i = 0; i < visibleCasters.length; i++) {
				const meshInstance = visibleCasters[i];

				if (emptyAabb) {
					emptyAabb = false;
					visibleSceneAabb.copy(meshInstance.aabb);
				} else {
					visibleSceneAabb.add(meshInstance.aabb);
				}
			}

			shadowCamView.copy(shadowCamNode.getWorldTransform()).invert();
			const depthRange = getDepthRange(shadowCamView, visibleSceneAabb.getMin(), visibleSceneAabb.getMax());
			shadowCamNode.translateLocal(0, 0, depthRange.max + 0.1);
			shadowCam.farClip = depthRange.max - depthRange.min + 0.2;
		}
	}

	setupRenderState(device, light) {
		const isClustered = this.forwardRenderer.scene.clusteredLightingEnabled;

		if (device.webgl2) {
			if (light._type === LIGHTTYPE_OMNI && !isClustered) {
				device.setDepthBias(false);
			} else {
				device.setDepthBias(true);
				device.setDepthBiasValues(light.shadowBias * -1000.0, light.shadowBias * -1000.0);
			}
		} else if (device.extStandardDerivatives) {
			if (light._type === LIGHTTYPE_OMNI) {
				this.polygonOffset[0] = 0;
				this.polygonOffset[1] = 0;
				this.polygonOffsetId.setValue(this.polygonOffset);
			} else {
				this.polygonOffset[0] = light.shadowBias * -1000.0;
				this.polygonOffset[1] = light.shadowBias * -1000.0;
				this.polygonOffsetId.setValue(this.polygonOffset);
			}
		}

		device.setBlending(false);
		device.setDepthWrite(true);
		device.setDepthTest(true);
		device.setDepthFunc(FUNC_LESSEQUAL);
		const useShadowSampler = isClustered ? light._isPcf && device.webgl2 : light._isPcf && device.webgl2 && light._type !== LIGHTTYPE_OMNI;

		if (useShadowSampler) {
			device.setColorWrite(false, false, false, false);
		} else {
			device.setColorWrite(true, true, true, true);
		}
	}

	restoreRenderState(device) {
		if (device.webgl2) {
			device.setDepthBias(false);
		} else if (device.extStandardDerivatives) {
			this.polygonOffset[0] = 0;
			this.polygonOffset[1] = 0;
			this.polygonOffsetId.setValue(this.polygonOffset);
		}
	}

	dispatchUniforms(light, shadowCam, lightRenderData, face) {
		const shadowCamNode = shadowCam._node;

		if (light._type !== LIGHTTYPE_DIRECTIONAL) {
			this.forwardRenderer.dispatchViewPos(shadowCamNode.getPosition());
			this.shadowMapLightRadiusId.setValue(light.attenuationEnd);
		}

		shadowCamView.setTRS(shadowCamNode.getPosition(), shadowCamNode.getRotation(), Vec3.ONE).invert();
		shadowCamViewProj.mul2(shadowCam.projectionMatrix, shadowCamView);
		const rectViewport = lightRenderData.shadowViewport;
		shadowCam.rect = rectViewport;
		shadowCam.scissorRect = lightRenderData.shadowScissor;
		viewportMatrix.setViewport(rectViewport.x, rectViewport.y, rectViewport.z, rectViewport.w);
		lightRenderData.shadowMatrix.mul2(viewportMatrix, shadowCamViewProj);

		if (light._type === LIGHTTYPE_DIRECTIONAL) {
			light._shadowMatrixPalette.set(lightRenderData.shadowMatrix.data, face * 16);
		}
	}

	submitCasters(visibleCasters, light) {
		const device = this.device;
		const forwardRenderer = this.forwardRenderer;
		const shadowPass = 1 << SHADER_SHADOW;
		const shadowType = light._shadowType;
		const smode = shadowType + light._type * SHADOW_COUNT;
		const count = visibleCasters.length;

		for (let i = 0; i < count; i++) {
			const meshInstance = visibleCasters[i];
			const mesh = meshInstance.mesh;
			const material = meshInstance.material;
			forwardRenderer.setBaseConstants(device, material);
			forwardRenderer.setSkinning(device, meshInstance, material);

			if (material.dirty) {
				material.updateUniforms(device, forwardRenderer.scene);
				material.dirty = false;
			}

			if (material.chunks) {
				forwardRenderer.setCullMode(true, false, meshInstance);
				material.setParameters(device);
				meshInstance.setParameters(device, shadowPass);
			}

			let shadowShader = meshInstance._shader[SHADER_SHADOW + smode];

			if (!shadowShader) {
				forwardRenderer.updateShader(meshInstance, meshInstance._shaderDefs, null, SHADER_SHADOW + smode);
				shadowShader = meshInstance._shader[SHADER_SHADOW + smode];
				meshInstance._key[SORTKEY_DEPTH] = getDepthKey(meshInstance);
			}

			device.setShader(shadowShader);
			forwardRenderer.setVertexBuffers(device, mesh);
			forwardRenderer.setMorphing(device, meshInstance.morphInstance);
			const style = meshInstance.renderStyle;
			device.setIndexBuffer(mesh.indexBuffer[style]);
			forwardRenderer.drawInstance(device, meshInstance, mesh, style);
			forwardRenderer._shadowDrawCalls++;
		}
	}

	render(light, camera) {
		if (light.enabled && light.castShadows && light.shadowUpdateMode !== SHADOWUPDATE_NONE && light.visibleThisFrame) {
			const device = this.device;

			if (light.shadowUpdateMode === SHADOWUPDATE_THISFRAME) {
				light.shadowUpdateMode = SHADOWUPDATE_NONE;
			}

			const type = light._type;
			const shadowType = light._shadowType;
			const faceCount = light.numShadowFaces;
			const forwardRenderer = this.forwardRenderer;
			forwardRenderer._shadowMapUpdates += faceCount;
			const isClustered = forwardRenderer.scene.clusteredLightingEnabled;
			this.setupRenderState(device, light);

			for (let face = 0; face < faceCount; face++) {
				const lightRenderData = light.getRenderData(type === LIGHTTYPE_DIRECTIONAL ? camera : null, face);
				const shadowCam = lightRenderData.shadowCamera;
				ShadowRenderer.setShadowCameraSettings(shadowCam, device, shadowType, type, isClustered);
				const renderTargetIndex = type === LIGHTTYPE_DIRECTIONAL ? 0 : face;
				shadowCam.renderTarget = light._shadowMap.renderTargets[renderTargetIndex];
				this.dispatchUniforms(light, shadowCam, lightRenderData, face);
				forwardRenderer.setCamera(shadowCam, shadowCam.renderTarget, true);
				this.submitCasters(lightRenderData.visibleCasters, light);
			}

			if (light._isVsm && light._vsmBlurSize > 1) {
				const _isClustered = this.forwardRenderer.scene.clusteredLightingEnabled;

				if (!_isClustered || type === LIGHTTYPE_DIRECTIONAL) {
					this.applyVsmBlur(light, camera);
				}
			}

			this.restoreRenderState(device);
		}
	}

	getVsmBlurShader(isVsm8, blurMode, filterSize) {
		let blurShader = (isVsm8 ? this.blurPackedVsmShader : this.blurVsmShader)[blurMode][filterSize];

		if (!blurShader) {
			this.blurVsmWeights[filterSize] = gaussWeights(filterSize);
			const blurVS = shaderChunks.fullscreenQuadVS;
			let blurFS = "#define SAMPLES " + filterSize + "\n";

			if (isVsm8) {
				blurFS += this.blurPackedVsmShaderCode[blurMode];
			} else {
				blurFS += this.blurVsmShaderCode[blurMode];
			}

			const blurShaderName = "blurVsm" + blurMode + "" + filterSize + "" + isVsm8;
			blurShader = createShaderFromCode(this.device, blurVS, blurFS, blurShaderName);

			if (isVsm8) {
				this.blurPackedVsmShader[blurMode][filterSize] = blurShader;
			} else {
				this.blurVsmShader[blurMode][filterSize] = blurShader;
			}
		}

		return blurShader;
	}

	applyVsmBlur(light, camera) {
		const device = this.device;
		const lightRenderData = light.getRenderData(light._type === LIGHTTYPE_DIRECTIONAL ? camera : null, 0);
		const shadowCam = lightRenderData.shadowCamera;
		const origShadowMap = shadowCam.renderTarget;
		const tempShadowMap = this.shadowMapCache.get(device, light);
		const tempRt = tempShadowMap.renderTargets[0];
		const isVsm8 = light._shadowType === SHADOW_VSM8;
		const blurMode = light.vsmBlurMode;
		const filterSize = light._vsmBlurSize;
		const blurShader = this.getVsmBlurShader(isVsm8, blurMode, filterSize);
		blurScissorRect.z = light._shadowResolution - 2;
		blurScissorRect.w = blurScissorRect.z;
		this.sourceId.setValue(origShadowMap.colorBuffer);
		pixelOffset[0] = 1 / light._shadowResolution;
		pixelOffset[1] = 0;
		this.pixelOffsetId.setValue(pixelOffset);
		if (blurMode === BLUR_GAUSSIAN) this.weightId.setValue(this.blurVsmWeights[filterSize]);
		drawQuadWithShader(device, tempRt, blurShader, null, blurScissorRect);
		this.sourceId.setValue(tempRt.colorBuffer);
		pixelOffset[1] = pixelOffset[0];
		pixelOffset[0] = 0;
		this.pixelOffsetId.setValue(pixelOffset);
		drawQuadWithShader(device, origShadowMap, blurShader, null, blurScissorRect);
		this.shadowMapCache.add(light, tempShadowMap);
	}

}

const tempSphere$2 = new BoundingSphere();

class StaticMeshes {
	static lightCompare(lightA, lightB) {
		return lightA.key - lightB.key;
	}

	static prepare(device, scene, meshInstances, lights) {
		const drawCalls = meshInstances;
		const drawCallsCount = drawCalls.length;
		const newDrawCalls = [];
		const minVec = new Vec3();
		const maxVec = new Vec3();
		const localLightBounds = new BoundingBox();
		const invMatrix = new Mat4();
		const triLightComb = [];
		const lightAabb = [];
		const triBounds = [];
		const staticLights = [];

		for (let i = 0; i < drawCallsCount; i++) {
			const drawCall = drawCalls[i];

			if (!drawCall.isStatic) {
				newDrawCalls.push(drawCall);
			} else {
				const aabb = drawCall.aabb;
				staticLights.length = 0;

				for (let lightTypePass = LIGHTTYPE_OMNI; lightTypePass <= LIGHTTYPE_SPOT; lightTypePass++) {
					for (let j = 0; j < lights.length; j++) {
						const light = lights[j];
						if (light._type !== lightTypePass) continue;

						if (light.enabled) {
							if (light.mask & drawCall.mask) {
								if (light.isStatic) {
									if (!lightAabb[j]) {
										lightAabb[j] = new BoundingBox();

										light._node.getWorldTransform();

										light.getBoundingSphere(tempSphere$2);
										lightAabb[j].center.copy(tempSphere$2.center);
										lightAabb[j].halfExtents.set(tempSphere$2.radius, tempSphere$2.radius, tempSphere$2.radius);
									}

									if (!lightAabb[j].intersects(aabb)) continue;
									staticLights.push(j);
								}
							}
						}
					}
				}

				if (staticLights.length === 0) {
					newDrawCalls.push(drawCall);
					continue;
				}

				const mesh = drawCall.mesh;
				const vertexBuffer = mesh.vertexBuffer;
				const indexBuffer = mesh.indexBuffer[drawCall.renderStyle];
				const indices = indexBuffer.bytesPerIndex === 2 ? new Uint16Array(indexBuffer.lock()) : new Uint32Array(indexBuffer.lock());
				const numTris = mesh.primitive[drawCall.renderStyle].count / 3;
				const baseIndex = mesh.primitive[drawCall.renderStyle].base;
				const elems = vertexBuffer.format.elements;
				const vertSize = vertexBuffer.format.size / 4;
				const verts = new Float32Array(vertexBuffer.storage);
				let offsetP;

				for (let k = 0; k < elems.length; k++) {
					if (elems[k].name === SEMANTIC_POSITION) {
						offsetP = elems[k].offset / 4;
					}
				}

				triLightComb.length = numTris;

				for (let k = 0; k < numTris; k++) {
					triLightComb[k] = 0;
				}

				let triLightCombUsed = false;
				triBounds.length = numTris * 6;

				for (let k = 0; k < numTris; k++) {
					let minx = Number.MAX_VALUE;
					let miny = Number.MAX_VALUE;
					let minz = Number.MAX_VALUE;
					let maxx = -Number.MAX_VALUE;
					let maxy = -Number.MAX_VALUE;
					let maxz = -Number.MAX_VALUE;

					for (let v = 0; v < 3; v++) {
						let _index = indices[k * 3 + v + baseIndex];
						_index = _index * vertSize + offsetP;
						const _x = verts[_index];
						const _y = verts[_index + 1];
						const _z = verts[_index + 2];
						if (_x < minx) minx = _x;
						if (_y < miny) miny = _y;
						if (_z < minz) minz = _z;
						if (_x > maxx) maxx = _x;
						if (_y > maxy) maxy = _y;
						if (_z > maxz) maxz = _z;
					}

					const index = k * 6;
					triBounds[index] = minx;
					triBounds[index + 1] = miny;
					triBounds[index + 2] = minz;
					triBounds[index + 3] = maxx;
					triBounds[index + 4] = maxy;
					triBounds[index + 5] = maxz;
				}

				for (let s = 0; s < staticLights.length; s++) {
					const j = staticLights[s];
					invMatrix.copy(drawCall.node.worldTransform).invert();
					localLightBounds.setFromTransformedAabb(lightAabb[j], invMatrix);
					const minv = localLightBounds.getMin();
					const maxv = localLightBounds.getMax();
					const bit = 1 << s;

					for (let k = 0; k < numTris; k++) {
						const index = k * 6;

						if (triBounds[index] <= maxv.x && triBounds[index + 3] >= minv.x && triBounds[index + 1] <= maxv.y && triBounds[index + 4] >= minv.y && triBounds[index + 2] <= maxv.z && triBounds[index + 5] >= minv.z) {
							triLightComb[k] |= bit;
							triLightCombUsed = true;
						}
					}
				}

				if (triLightCombUsed) {
					const combIndices = {};

					for (let k = 0; k < numTris; k++) {
						const j = k * 3 + baseIndex;
						const combIbName = triLightComb[k];
						if (!combIndices[combIbName]) combIndices[combIbName] = [];
						const combIb = combIndices[combIbName];
						combIb.push(indices[j]);
						combIb.push(indices[j + 1]);
						combIb.push(indices[j + 2]);
					}

					for (const combIbName in combIndices) {
						const combIb = combIndices[combIbName];
						const ib = new IndexBuffer(device, indexBuffer.format, combIb.length, indexBuffer.usage);
						const ib2 = ib.bytesPerIndex === 2 ? new Uint16Array(ib.lock()) : new Uint32Array(ib.lock());
						ib2.set(combIb);
						ib.unlock();
						let minx = Number.MAX_VALUE;
						let miny = Number.MAX_VALUE;
						let minz = Number.MAX_VALUE;
						let maxx = -Number.MAX_VALUE;
						let maxy = -Number.MAX_VALUE;
						let maxz = -Number.MAX_VALUE;

						for (let k = 0; k < combIb.length; k++) {
							const index = combIb[k];
							const _x = verts[index * vertSize + offsetP];
							const _y = verts[index * vertSize + offsetP + 1];
							const _z = verts[index * vertSize + offsetP + 2];
							if (_x < minx) minx = _x;
							if (_y < miny) miny = _y;
							if (_z < minz) minz = _z;
							if (_x > maxx) maxx = _x;
							if (_y > maxy) maxy = _y;
							if (_z > maxz) maxz = _z;
						}

						minVec.set(minx, miny, minz);
						maxVec.set(maxx, maxy, maxz);
						const chunkAabb = new BoundingBox();
						chunkAabb.setMinMax(minVec, maxVec);
						const mesh2 = new Mesh(device);
						mesh2.vertexBuffer = vertexBuffer;
						mesh2.indexBuffer[0] = ib;
						mesh2.primitive[0].type = PRIMITIVE_TRIANGLES;
						mesh2.primitive[0].base = 0;
						mesh2.primitive[0].count = combIb.length;
						mesh2.primitive[0].indexed = true;
						mesh2.aabb = chunkAabb;
						const instance = new MeshInstance(mesh2, drawCall.material, drawCall.node);
						instance.isStatic = drawCall.isStatic;
						instance.visible = drawCall.visible;
						instance.layer = drawCall.layer;
						instance.castShadow = drawCall.castShadow;
						instance._receiveShadow = drawCall._receiveShadow;
						instance.cull = drawCall.cull;
						instance.pick = drawCall.pick;
						instance.mask = drawCall.mask;
						instance.parameters = drawCall.parameters;
						instance._shaderDefs = drawCall._shaderDefs;
						instance._staticSource = drawCall;

						if (drawCall._staticLightList) {
							instance._staticLightList = drawCall._staticLightList;
						} else {
							instance._staticLightList = [];
						}

						for (let k = 0; k < staticLights.length; k++) {
							const bit = 1 << k;

							if (combIbName & bit) {
								const lht = lights[staticLights[k]];

								if (instance._staticLightList.indexOf(lht) < 0) {
									instance._staticLightList.push(lht);
								}
							}
						}

						instance._staticLightList.sort(StaticMeshes.lightCompare);

						newDrawCalls.push(instance);
					}
				} else {
					newDrawCalls.push(drawCall);
				}
			}
		}

		meshInstances.length = newDrawCalls.length;

		for (let i = 0; i < newDrawCalls.length; i++) {
			meshInstances[i] = newDrawCalls[i];
		}
	}

	static revert(meshInstances) {
		const drawCalls = meshInstances;
		const drawCallsCount = drawCalls.length;
		const newDrawCalls = [];
		let prevStaticSource;

		for (let i = 0; i < drawCallsCount; i++) {
			const drawCall = drawCalls[i];

			if (drawCall._staticSource) {
				if (drawCall._staticSource !== prevStaticSource) {
					newDrawCalls.push(drawCall._staticSource);
					prevStaticSource = drawCall._staticSource;
				}
			} else {
				newDrawCalls.push(drawCall);
			}
		}

		meshInstances.length = newDrawCalls.length;

		for (let i = 0; i < newDrawCalls.length; i++) {
			meshInstances[i] = newDrawCalls[i];
		}
	}

}

new Vec3(1, 1, 1);
new Vec3(40, 0, 0);

const viewInvMat = new Mat4();
const viewMat = new Mat4();
const viewMat3 = new Mat3();
const viewProjMat = new Mat4();
let projMat;
const flipYMat = new Mat4().setScale(1, -1, 1);
const flippedViewProjMat = new Mat4();
const flippedSkyboxProjMat = new Mat4();
const viewInvL = new Mat4();
const viewInvR = new Mat4();
const viewL = new Mat4();
const viewR = new Mat4();
const viewPosL = new Vec3();
const viewPosR = new Vec3();
let projL, projR;
const viewMat3L = new Mat3();
const viewMat3R = new Mat3();
const viewProjMatL = new Mat4();
const viewProjMatR = new Mat4();
const worldMatX = new Vec3();
const worldMatY = new Vec3();
const worldMatZ = new Vec3();
const tempSphere$1 = new BoundingSphere();
const boneTextureSize = [0, 0, 0, 0];
let boneTexture, instancingData, modelMatrix, normalMatrix;
let keyA$1, keyB$1;
let _skinUpdateIndex = 0;
const _drawCallList = {
	drawCalls: [],
	isNewMaterial: [],
	lightMaskChanged: []
};

const _tempMaterialSet = new Set();

class ForwardRenderer {
	constructor(graphicsDevice) {
		this.device = graphicsDevice;
		this.scene = null;
		this._shadowDrawCalls = 0;
		this._forwardDrawCalls = 0;
		this._skinDrawCalls = 0;
		this._numDrawCallsCulled = 0;
		this._instancedDrawCalls = 0;
		this._camerasRendered = 0;
		this._materialSwitches = 0;
		this._shadowMapUpdates = 0;
		this._shadowMapTime = 0;
		this._depthMapTime = 0;
		this._forwardTime = 0;
		this._cullTime = 0;
		this._sortTime = 0;
		this._skinTime = 0;
		this._morphTime = 0;
		this._layerCompositionUpdateTime = 0;
		this._lightClustersTime = 0;
		this._lightClusters = 0;
		const device = this.device;
		this.library = device.getProgramLibrary();
		this.lightTextureAtlas = new LightTextureAtlas(device);
		this._shadowRenderer = new ShadowRenderer(this, this.lightTextureAtlas);
		this._cookieRenderer = new CookieRenderer(device, this.lightTextureAtlas);
		const scope = device.scope;
		this.projId = scope.resolve('matrix_projection');
		this.projSkyboxId = scope.resolve('matrix_projectionSkybox');
		this.viewId = scope.resolve('matrix_view');
		this.viewId3 = scope.resolve('matrix_view3');
		this.viewInvId = scope.resolve('matrix_viewInverse');
		this.viewProjId = scope.resolve('matrix_viewProjection');
		this.viewPos = new Float32Array(3);
		this.viewPosId = scope.resolve('view_position');
		this.nearClipId = scope.resolve('camera_near');
		this.farClipId = scope.resolve('camera_far');
		this.cameraParamsId = scope.resolve('camera_params');
		this.tbnBasis = scope.resolve('tbnBasis');
		this.fogColorId = scope.resolve('fog_color');
		this.fogStartId = scope.resolve('fog_start');
		this.fogEndId = scope.resolve('fog_end');
		this.fogDensityId = scope.resolve('fog_density');
		this.modelMatrixId = scope.resolve('matrix_model');
		this.normalMatrixId = scope.resolve('matrix_normal');
		this.poseMatrixId = scope.resolve('matrix_pose[0]');
		this.boneTextureId = scope.resolve('texture_poseMap');
		this.boneTextureSizeId = scope.resolve('texture_poseMapSize');
		this.morphWeightsA = scope.resolve('morph_weights_a');
		this.morphWeightsB = scope.resolve('morph_weights_b');
		this.morphPositionTex = scope.resolve('morphPositionTex');
		this.morphNormalTex = scope.resolve('morphNormalTex');
		this.morphTexParams = scope.resolve('morph_tex_params');
		this.alphaTestId = scope.resolve('alpha_ref');
		this.opacityMapId = scope.resolve('texture_opacityMap');
		this.ambientId = scope.resolve("light_globalAmbient");
		this.exposureId = scope.resolve("exposure");
		this.skyboxIntensityId = scope.resolve("skyboxIntensity");
		this.lightColorId = [];
		this.lightDir = [];
		this.lightDirId = [];
		this.lightShadowMapId = [];
		this.lightShadowMatrixId = [];
		this.lightShadowParamsId = [];
		this.lightRadiusId = [];
		this.lightPos = [];
		this.lightPosId = [];
		this.lightWidth = [];
		this.lightWidthId = [];
		this.lightHeight = [];
		this.lightHeightId = [];
		this.lightInAngleId = [];
		this.lightOutAngleId = [];
		this.lightCookieId = [];
		this.lightCookieIntId = [];
		this.lightCookieMatrixId = [];
		this.lightCookieOffsetId = [];
		this.shadowMatrixPaletteId = [];
		this.shadowCascadeDistancesId = [];
		this.shadowCascadeCountId = [];
		this.depthMapId = scope.resolve('uDepthMap');
		this.screenSizeId = scope.resolve('uScreenSize');
		this._screenSize = new Float32Array(4);
		this.twoSidedLightingNegScaleFactorId = scope.resolve("twoSidedLightingNegScaleFactor");
		this.fogColor = new Float32Array(3);
		this.ambientColor = new Float32Array(3);
		this.cameraParams = new Float32Array(4);
	}

	destroy() {
		this._shadowRenderer.destroy();

		this._shadowRenderer = null;

		this._cookieRenderer.destroy();

		this._cookieRenderer = null;
		this.lightTextureAtlas.destroy();
		this.lightTextureAtlas = null;
	}

	sortCompare(drawCallA, drawCallB) {
		if (drawCallA.layer === drawCallB.layer) {
			if (drawCallA.drawOrder && drawCallB.drawOrder) {
				return drawCallA.drawOrder - drawCallB.drawOrder;
			} else if (drawCallA.zdist && drawCallB.zdist) {
				return drawCallB.zdist - drawCallA.zdist;
			} else if (drawCallA.zdist2 && drawCallB.zdist2) {
				return drawCallA.zdist2 - drawCallB.zdist2;
			}
		}

		return drawCallB._key[SORTKEY_FORWARD] - drawCallA._key[SORTKEY_FORWARD];
	}

	sortCompareMesh(drawCallA, drawCallB) {
		if (drawCallA.layer === drawCallB.layer) {
			if (drawCallA.drawOrder && drawCallB.drawOrder) {
				return drawCallA.drawOrder - drawCallB.drawOrder;
			} else if (drawCallA.zdist && drawCallB.zdist) {
				return drawCallB.zdist - drawCallA.zdist;
			}
		}

		keyA$1 = drawCallA._key[SORTKEY_FORWARD];
		keyB$1 = drawCallB._key[SORTKEY_FORWARD];

		if (keyA$1 === keyB$1 && drawCallA.mesh && drawCallB.mesh) {
			return drawCallB.mesh.id - drawCallA.mesh.id;
		}

		return keyB$1 - keyA$1;
	}

	depthSortCompare(drawCallA, drawCallB) {
		keyA$1 = drawCallA._key[SORTKEY_DEPTH];
		keyB$1 = drawCallB._key[SORTKEY_DEPTH];

		if (keyA$1 === keyB$1 && drawCallA.mesh && drawCallB.mesh) {
			return drawCallB.mesh.id - drawCallA.mesh.id;
		}

		return keyB$1 - keyA$1;
	}

	updateCameraFrustum(camera) {
		if (camera.vrDisplay && camera.vrDisplay.presenting) {
			projMat = camera.vrDisplay.combinedProj;
			const parent = camera._node.parent;

			if (parent) {
				viewMat.copy(parent.getWorldTransform()).mul(camera.vrDisplay.combinedViewInv).invert();
			} else {
				viewMat.copy(camera.vrDisplay.combinedView);
			}

			viewInvMat.copy(viewMat).invert();
			this.viewInvId.setValue(viewInvMat.data);
			viewProjMat.mul2(projMat, viewMat);
			camera.frustum.setFromMat4(viewProjMat);
		} else if (camera.xr && camera.xr.views.length) {
			const view = camera.xr.views[0];
			viewProjMat.mul2(view.projMat, view.viewOffMat);
			camera.frustum.setFromMat4(viewProjMat);
			return;
		}

		projMat = camera.projectionMatrix;

		if (camera.calculateProjection) {
			camera.calculateProjection(projMat, VIEW_CENTER);
		}

		if (camera.calculateTransform) {
			camera.calculateTransform(viewInvMat, VIEW_CENTER);
		} else {
			const pos = camera._node.getPosition();

			const rot = camera._node.getRotation();

			viewInvMat.setTRS(pos, rot, Vec3.ONE);
			this.viewInvId.setValue(viewInvMat.data);
		}

		viewMat.copy(viewInvMat).invert();
		viewProjMat.mul2(projMat, viewMat);
		camera.frustum.setFromMat4(viewProjMat);
	}

	setCamera(camera, target, clear) {
		const vrDisplay = camera.vrDisplay;
		let transform;

		if (vrDisplay && vrDisplay.presenting) {
			projL = vrDisplay.leftProj;
			projR = vrDisplay.rightProj;
			projMat = vrDisplay.combinedProj;

			if (camera.calculateProjection) {
				camera.calculateProjection(projL, VIEW_LEFT);
				camera.calculateProjection(projR, VIEW_RIGHT);
				camera.calculateProjection(projMat, VIEW_CENTER);
			}

			if (camera.calculateTransform) {
				camera.calculateTransform(viewInvL, VIEW_LEFT);
				camera.calculateTransform(viewInvR, VIEW_RIGHT);
				camera.calculateTransform(viewInvMat, VIEW_CENTER);
				viewL.copy(viewInvL).invert();
				viewR.copy(viewInvR).invert();
				viewMat.copy(viewInvMat).invert();
			} else {
				const parent = camera._node.parent;

				if (parent) {
					transform = parent.getWorldTransform();
					viewInvL.mul2(transform, vrDisplay.leftViewInv);
					viewInvR.mul2(transform, vrDisplay.rightViewInv);
					viewL.copy(viewInvL).invert();
					viewR.copy(viewInvR).invert();
					viewMat.copy(parent.getWorldTransform()).mul(vrDisplay.combinedViewInv).invert();
				} else {
					viewInvL.copy(vrDisplay.leftViewInv);
					viewInvR.copy(vrDisplay.rightViewInv);
					viewL.copy(vrDisplay.leftView);
					viewR.copy(vrDisplay.rightView);
					viewMat.copy(vrDisplay.combinedView);
				}
			}

			viewMat3L.setFromMat4(viewL);
			viewMat3R.setFromMat4(viewR);
			viewProjMatL.mul2(projL, viewL);
			viewProjMatR.mul2(projR, viewR);
			viewPosL.x = viewInvL.data[12];
			viewPosL.y = viewInvL.data[13];
			viewPosL.z = viewInvL.data[14];
			viewPosR.x = viewInvR.data[12];
			viewPosR.y = viewInvR.data[13];
			viewPosR.z = viewInvR.data[14];
			viewProjMat.mul2(projMat, viewMat);
			camera.frustum.setFromMat4(viewProjMat);
		} else if (camera.xr && camera.xr.session) {
			const parent = camera._node.parent;
			if (parent) transform = parent.getWorldTransform();
			const views = camera.xr.views;

			for (let v = 0; v < views.length; v++) {
				const view = views[v];

				if (parent) {
					view.viewInvOffMat.mul2(transform, view.viewInvMat);
					view.viewOffMat.copy(view.viewInvOffMat).invert();
				} else {
					view.viewInvOffMat.copy(view.viewInvMat);
					view.viewOffMat.copy(view.viewMat);
				}

				view.viewMat3.setFromMat4(view.viewOffMat);
				view.projViewOffMat.mul2(view.projMat, view.viewOffMat);
				view.position[0] = view.viewInvOffMat.data[12];
				view.position[1] = view.viewInvOffMat.data[13];
				view.position[2] = view.viewInvOffMat.data[14];
				camera.frustum.setFromMat4(view.projViewOffMat);
			}
		} else {
			projMat = camera.projectionMatrix;

			if (camera.calculateProjection) {
				camera.calculateProjection(projMat, VIEW_CENTER);
			}

			this.projId.setValue(projMat.data);
			this.projSkyboxId.setValue(camera.getProjectionMatrixSkybox().data);

			if (camera.calculateTransform) {
				camera.calculateTransform(viewInvMat, VIEW_CENTER);
			} else {
				const pos = camera._node.getPosition();

				const rot = camera._node.getRotation();

				viewInvMat.setTRS(pos, rot, Vec3.ONE);
			}

			this.viewInvId.setValue(viewInvMat.data);
			viewMat.copy(viewInvMat).invert();
			this.viewId.setValue(viewMat.data);
			viewMat3.setFromMat4(viewMat);
			this.viewId3.setValue(viewMat3.data);
			viewProjMat.mul2(projMat, viewMat);

			if (target && target.flipY) {
				flippedViewProjMat.mul2(flipYMat, viewProjMat);
				flippedSkyboxProjMat.mul2(flipYMat, camera.getProjectionMatrixSkybox());
				this.viewProjId.setValue(flippedViewProjMat.data);
				this.projSkyboxId.setValue(flippedSkyboxProjMat.data);
			} else {
				this.viewProjId.setValue(viewProjMat.data);
				this.projSkyboxId.setValue(camera.getProjectionMatrixSkybox().data);
			}

			this.dispatchViewPos(camera._node.getPosition());
			camera.frustum.setFromMat4(viewProjMat);
		}

		this.tbnBasis.setValue(target && target.flipY ? -1 : 1);
		this.nearClipId.setValue(camera._nearClip);
		this.farClipId.setValue(camera._farClip);
		const n = camera._nearClip;
		const f = camera._farClip;
		this.cameraParams[0] = 1 / f;
		this.cameraParams[1] = f;
		this.cameraParams[2] = (1 - f / n) * 0.5;
		this.cameraParams[3] = (1 + f / n) * 0.5;
		this.cameraParamsId.setValue(this.cameraParams);
		this.clearView(camera, target, clear, false);
	}

	clearView(camera, target, clear, forceWrite, options) {
		const device = this.device;
		device.setRenderTarget(target);
		device.updateBegin();

		if (forceWrite) {
			device.setColorWrite(true, true, true, true);
			device.setDepthWrite(true);
		}

		const pixelWidth = target ? target.width : device.width;
		const pixelHeight = target ? target.height : device.height;
		const rect = camera.rect;
		let x = Math.floor(rect.x * pixelWidth);
		let y = Math.floor(rect.y * pixelHeight);
		let w = Math.floor(rect.z * pixelWidth);
		let h = Math.floor(rect.w * pixelHeight);
		device.setViewport(x, y, w, h);

		if (camera._scissorRectClear) {
			const scissorRect = camera.scissorRect;
			x = Math.floor(scissorRect.x * pixelWidth);
			y = Math.floor(scissorRect.y * pixelHeight);
			w = Math.floor(scissorRect.z * pixelWidth);
			h = Math.floor(scissorRect.w * pixelHeight);
		}

		device.setScissor(x, y, w, h);

		if (clear) {
			if (!options) options = camera._clearOptions;
			device.clear(options ? options : {
				color: [camera._clearColor.r, camera._clearColor.g, camera._clearColor.b, camera._clearColor.a],
				depth: camera._clearDepth,
				flags: (camera._clearColorBuffer ? CLEARFLAG_COLOR : 0) | (camera._clearDepthBuffer ? CLEARFLAG_DEPTH : 0) | (camera._clearStencilBuffer ? CLEARFLAG_STENCIL : 0),
				stencil: camera._clearStencil
			});
		}
	}

	dispatchGlobalLights(scene) {
		this.ambientColor[0] = scene.ambientLight.r;
		this.ambientColor[1] = scene.ambientLight.g;
		this.ambientColor[2] = scene.ambientLight.b;

		if (scene.gammaCorrection) {
			for (let i = 0; i < 3; i++) {
				this.ambientColor[i] = Math.pow(this.ambientColor[i], 2.2);
			}
		}

		this.ambientId.setValue(this.ambientColor);
		this.exposureId.setValue(scene.exposure);
		if (scene.skyboxModel) this.skyboxIntensityId.setValue(scene.skyboxIntensity);
	}

	_resolveLight(scope, i) {
		const light = "light" + i;
		this.lightColorId[i] = scope.resolve(light + "_color");
		this.lightDir[i] = new Float32Array(3);
		this.lightDirId[i] = scope.resolve(light + "_direction");
		this.lightShadowMapId[i] = scope.resolve(light + "_shadowMap");
		this.lightShadowMatrixId[i] = scope.resolve(light + "_shadowMatrix");
		this.lightShadowParamsId[i] = scope.resolve(light + "_shadowParams");
		this.lightRadiusId[i] = scope.resolve(light + "_radius");
		this.lightPos[i] = new Float32Array(3);
		this.lightPosId[i] = scope.resolve(light + "_position");
		this.lightWidth[i] = new Float32Array(3);
		this.lightWidthId[i] = scope.resolve(light + "_halfWidth");
		this.lightHeight[i] = new Float32Array(3);
		this.lightHeightId[i] = scope.resolve(light + "_halfHeight");
		this.lightInAngleId[i] = scope.resolve(light + "_innerConeAngle");
		this.lightOutAngleId[i] = scope.resolve(light + "_outerConeAngle");
		this.lightCookieId[i] = scope.resolve(light + "_cookie");
		this.lightCookieIntId[i] = scope.resolve(light + "_cookieIntensity");
		this.lightCookieMatrixId[i] = scope.resolve(light + "_cookieMatrix");
		this.lightCookieOffsetId[i] = scope.resolve(light + "_cookieOffset");
		this.shadowMatrixPaletteId[i] = scope.resolve(light + "_shadowMatrixPalette[0]");
		this.shadowCascadeDistancesId[i] = scope.resolve(light + "_shadowCascadeDistances[0]");
		this.shadowCascadeCountId[i] = scope.resolve(light + "_shadowCascadeCount");
	}

	setLTCDirectionalLight(wtm, cnt, dir, campos, far) {
		this.lightPos[cnt][0] = campos.x - dir.x * far;
		this.lightPos[cnt][1] = campos.y - dir.y * far;
		this.lightPos[cnt][2] = campos.z - dir.z * far;
		this.lightPosId[cnt].setValue(this.lightPos[cnt]);
		const hWidth = wtm.transformVector(new Vec3(-0.5, 0, 0));
		this.lightWidth[cnt][0] = hWidth.x * far;
		this.lightWidth[cnt][1] = hWidth.y * far;
		this.lightWidth[cnt][2] = hWidth.z * far;
		this.lightWidthId[cnt].setValue(this.lightWidth[cnt]);
		const hHeight = wtm.transformVector(new Vec3(0, 0, 0.5));
		this.lightHeight[cnt][0] = hHeight.x * far;
		this.lightHeight[cnt][1] = hHeight.y * far;
		this.lightHeight[cnt][2] = hHeight.z * far;
		this.lightHeightId[cnt].setValue(this.lightHeight[cnt]);
	}

	dispatchDirectLights(dirs, scene, mask, camera) {
		let cnt = 0;
		const scope = this.device.scope;

		for (let i = 0; i < dirs.length; i++) {
			if (!(dirs[i].mask & mask)) continue;
			const directional = dirs[i];

			const wtm = directional._node.getWorldTransform();

			if (!this.lightColorId[cnt]) {
				this._resolveLight(scope, cnt);
			}

			this.lightColorId[cnt].setValue(scene.gammaCorrection ? directional._linearFinalColor : directional._finalColor);
			wtm.getY(directional._direction).mulScalar(-1);

			directional._direction.normalize();

			this.lightDir[cnt][0] = directional._direction.x;
			this.lightDir[cnt][1] = directional._direction.y;
			this.lightDir[cnt][2] = directional._direction.z;
			this.lightDirId[cnt].setValue(this.lightDir[cnt]);

			if (directional.shape !== LIGHTSHAPE_PUNCTUAL) {
				this.setLTCDirectionalLight(wtm, cnt, directional._direction, camera._node.getPosition(), camera.farClip);
			}

			if (directional.castShadows) {
				const lightRenderData = directional.getRenderData(camera, 0);

				const biases = directional._getUniformBiasValues(lightRenderData);

				this.lightShadowMapId[cnt].setValue(lightRenderData.shadowBuffer);
				this.lightShadowMatrixId[cnt].setValue(lightRenderData.shadowMatrix.data);
				this.shadowMatrixPaletteId[cnt].setValue(directional._shadowMatrixPalette);
				this.shadowCascadeDistancesId[cnt].setValue(directional._shadowCascadeDistances);
				this.shadowCascadeCountId[cnt].setValue(directional.numCascades);
				const params = directional._shadowRenderParams;
				params.length = 3;
				params[0] = directional._shadowResolution;
				params[1] = biases.normalBias;
				params[2] = biases.bias;
				this.lightShadowParamsId[cnt].setValue(params);
			}

			cnt++;
		}

		return cnt;
	}

	setLTCPositionalLight(wtm, cnt) {
		const hWidth = wtm.transformVector(new Vec3(-0.5, 0, 0));
		this.lightWidth[cnt][0] = hWidth.x;
		this.lightWidth[cnt][1] = hWidth.y;
		this.lightWidth[cnt][2] = hWidth.z;
		this.lightWidthId[cnt].setValue(this.lightWidth[cnt]);
		const hHeight = wtm.transformVector(new Vec3(0, 0, 0.5));
		this.lightHeight[cnt][0] = hHeight.x;
		this.lightHeight[cnt][1] = hHeight.y;
		this.lightHeight[cnt][2] = hHeight.z;
		this.lightHeightId[cnt].setValue(this.lightHeight[cnt]);
	}

	dispatchOmniLight(scene, scope, omni, cnt) {
		const wtm = omni._node.getWorldTransform();

		if (!this.lightColorId[cnt]) {
			this._resolveLight(scope, cnt);
		}

		this.lightRadiusId[cnt].setValue(omni.attenuationEnd);
		this.lightColorId[cnt].setValue(scene.gammaCorrection ? omni._linearFinalColor : omni._finalColor);
		wtm.getTranslation(omni._position);
		this.lightPos[cnt][0] = omni._position.x;
		this.lightPos[cnt][1] = omni._position.y;
		this.lightPos[cnt][2] = omni._position.z;
		this.lightPosId[cnt].setValue(this.lightPos[cnt]);

		if (omni.shape !== LIGHTSHAPE_PUNCTUAL) {
			this.setLTCPositionalLight(wtm, cnt);
		}

		if (omni.castShadows) {
			const lightRenderData = omni.getRenderData(null, 0);
			this.lightShadowMapId[cnt].setValue(lightRenderData.shadowBuffer);

			const biases = omni._getUniformBiasValues(lightRenderData);

			const params = omni._shadowRenderParams;
			params.length = 4;
			params[0] = omni._shadowResolution;
			params[1] = biases.normalBias;
			params[2] = biases.bias;
			params[3] = 1.0 / omni.attenuationEnd;
			this.lightShadowParamsId[cnt].setValue(params);
		}

		if (omni._cookie) {
			this.lightCookieId[cnt].setValue(omni._cookie);
			this.lightShadowMatrixId[cnt].setValue(wtm.data);
			this.lightCookieIntId[cnt].setValue(omni.cookieIntensity);
		}
	}

	dispatchSpotLight(scene, scope, spot, cnt) {
		const wtm = spot._node.getWorldTransform();

		if (!this.lightColorId[cnt]) {
			this._resolveLight(scope, cnt);
		}

		this.lightInAngleId[cnt].setValue(spot._innerConeAngleCos);
		this.lightOutAngleId[cnt].setValue(spot._outerConeAngleCos);
		this.lightRadiusId[cnt].setValue(spot.attenuationEnd);
		this.lightColorId[cnt].setValue(scene.gammaCorrection ? spot._linearFinalColor : spot._finalColor);
		wtm.getTranslation(spot._position);
		this.lightPos[cnt][0] = spot._position.x;
		this.lightPos[cnt][1] = spot._position.y;
		this.lightPos[cnt][2] = spot._position.z;
		this.lightPosId[cnt].setValue(this.lightPos[cnt]);

		if (spot.shape !== LIGHTSHAPE_PUNCTUAL) {
			this.setLTCPositionalLight(wtm, cnt);
		}

		wtm.getY(spot._direction).mulScalar(-1);

		spot._direction.normalize();

		this.lightDir[cnt][0] = spot._direction.x;
		this.lightDir[cnt][1] = spot._direction.y;
		this.lightDir[cnt][2] = spot._direction.z;
		this.lightDirId[cnt].setValue(this.lightDir[cnt]);

		if (spot.castShadows) {
			const lightRenderData = spot.getRenderData(null, 0);
			this.lightShadowMapId[cnt].setValue(lightRenderData.shadowBuffer);
			this.lightShadowMatrixId[cnt].setValue(lightRenderData.shadowMatrix.data);

			const biases = spot._getUniformBiasValues(lightRenderData);

			const params = spot._shadowRenderParams;
			params.length = 4;
			params[0] = spot._shadowResolution;
			params[1] = biases.normalBias;
			params[2] = biases.bias;
			params[3] = 1.0 / spot.attenuationEnd;
			this.lightShadowParamsId[cnt].setValue(params);
		}

		if (spot._cookie) {
			if (!spot.castShadows) {
				const cookieMatrix = LightCamera.evalSpotCookieMatrix(spot);
				this.lightShadowMatrixId[cnt].setValue(cookieMatrix.data);
			}

			this.lightCookieId[cnt].setValue(spot._cookie);
			this.lightCookieIntId[cnt].setValue(spot.cookieIntensity);

			if (spot._cookieTransform) {
				spot._cookieTransformUniform[0] = spot._cookieTransform.x;
				spot._cookieTransformUniform[1] = spot._cookieTransform.y;
				spot._cookieTransformUniform[2] = spot._cookieTransform.z;
				spot._cookieTransformUniform[3] = spot._cookieTransform.w;
				this.lightCookieMatrixId[cnt].setValue(spot._cookieTransformUniform);
				spot._cookieOffsetUniform[0] = spot._cookieOffset.x;
				spot._cookieOffsetUniform[1] = spot._cookieOffset.y;
				this.lightCookieOffsetId[cnt].setValue(spot._cookieOffsetUniform);
			}
		}
	}

	dispatchLocalLights(sortedLights, scene, mask, usedDirLights, staticLightList) {
		let cnt = usedDirLights;
		const scope = this.device.scope;
		const omnis = sortedLights[LIGHTTYPE_OMNI];
		const numOmnis = omnis.length;

		for (let i = 0; i < numOmnis; i++) {
			const omni = omnis[i];
			if (!(omni.mask & mask)) continue;
			if (omni.isStatic) continue;
			this.dispatchOmniLight(scene, scope, omni, cnt);
			cnt++;
		}

		let staticId = 0;

		if (staticLightList) {
			let omni = staticLightList[staticId];

			while (omni && omni._type === LIGHTTYPE_OMNI) {
				this.dispatchOmniLight(scene, scope, omni, cnt);
				cnt++;
				staticId++;
				omni = staticLightList[staticId];
			}
		}

		const spts = sortedLights[LIGHTTYPE_SPOT];
		const numSpts = spts.length;

		for (let i = 0; i < numSpts; i++) {
			const spot = spts[i];
			if (!(spot.mask & mask)) continue;
			if (spot.isStatic) continue;
			this.dispatchSpotLight(scene, scope, spot, cnt);
			cnt++;
		}

		if (staticLightList) {
			let spot = staticLightList[staticId];

			while (spot && spot._type === LIGHTTYPE_SPOT) {
				this.dispatchSpotLight(scene, scope, spot, cnt);
				cnt++;
				staticId++;
				spot = staticLightList[staticId];
			}
		}
	}

	cull(camera, drawCalls, visibleList) {
		let visibleLength = 0;
		const drawCallsCount = drawCalls.length;
		const cullingMask = camera.cullingMask || 0xFFFFFFFF;

		if (!camera.frustumCulling) {
			for (let i = 0; i < drawCallsCount; i++) {
				const drawCall = drawCalls[i];
				if (!drawCall.visible && !drawCall.command) continue;
				if (drawCall.mask && (drawCall.mask & cullingMask) === 0) continue;
				visibleList[visibleLength] = drawCall;
				visibleLength++;
				drawCall.visibleThisFrame = true;
			}

			return visibleLength;
		}

		for (let i = 0; i < drawCallsCount; i++) {
			const drawCall = drawCalls[i];

			if (!drawCall.command) {
				if (!drawCall.visible) continue;
				let visible = true;
				if (drawCall.mask && (drawCall.mask & cullingMask) === 0) continue;

				if (drawCall.cull) {
					visible = drawCall._isVisible(camera);
				}

				if (visible) {
					visibleList[visibleLength] = drawCall;
					visibleLength++;
					drawCall.visibleThisFrame = true;
				}
			} else {
				visibleList[visibleLength] = drawCall;
				visibleLength++;
				drawCall.visibleThisFrame = true;
			}
		}

		return visibleLength;
	}

	cullLights(camera, lights) {
		const clusteredLightingEnabled = this.scene.clusteredLightingEnabled;

		for (let i = 0; i < lights.length; i++) {
			const light = lights[i];

			if (light.enabled) {
				if (light._type !== LIGHTTYPE_DIRECTIONAL) {
					light.getBoundingSphere(tempSphere$1);

					if (camera.frustum.containsSphere(tempSphere$1)) {
						light.visibleThisFrame = true;
						const screenSize = camera.getScreenSize(tempSphere$1);
						light.maxScreenSize = Math.max(light.maxScreenSize, screenSize);
					} else {
						if (!clusteredLightingEnabled) {
							if (light.castShadows && !light.shadowMap) {
								light.visibleThisFrame = true;
							}
						}
					}
				}
			}
		}
	}

	updateCpuSkinMatrices(drawCalls) {
		_skinUpdateIndex++;
		const drawCallsCount = drawCalls.length;
		if (drawCallsCount === 0) return;

		for (let i = 0; i < drawCallsCount; i++) {
			const si = drawCalls[i].skinInstance;

			if (si) {
				si.updateMatrices(drawCalls[i].node, _skinUpdateIndex);
				si._dirty = true;
			}
		}
	}

	updateGpuSkinMatrices(drawCalls) {
		const drawCallsCount = drawCalls.length;

		for (let i = 0; i < drawCallsCount; i++) {
			if (!drawCalls[i].visibleThisFrame) continue;
			const skin = drawCalls[i].skinInstance;

			if (skin) {
				if (skin._dirty) {
					skin.updateMatrixPalette(drawCalls[i].node, _skinUpdateIndex);
					skin._dirty = false;
				}
			}
		}
	}

	updateMorphing(drawCalls) {
		const drawCallsCount = drawCalls.length;

		for (let i = 0; i < drawCallsCount; i++) {
			const morphInst = drawCalls[i].morphInstance;

			if (morphInst && morphInst._dirty && drawCalls[i].visibleThisFrame) {
				morphInst.update();
			}
		}
	}

	setBaseConstants(device, material) {
		device.setCullMode(material.cull);

		if (material.opacityMap) {
			this.opacityMapId.setValue(material.opacityMap);
			this.alphaTestId.setValue(material.alphaTest);
		}
	}

	setSkinning(device, meshInstance, material) {
		if (meshInstance.skinInstance) {
			this._skinDrawCalls++;

			if (device.supportsBoneTextures) {
				boneTexture = meshInstance.skinInstance.boneTexture;
				this.boneTextureId.setValue(boneTexture);
				boneTextureSize[0] = boneTexture.width;
				boneTextureSize[1] = boneTexture.height;
				boneTextureSize[2] = 1.0 / boneTexture.width;
				boneTextureSize[3] = 1.0 / boneTexture.height;
				this.boneTextureSizeId.setValue(boneTextureSize);
			} else {
				this.poseMatrixId.setValue(meshInstance.skinInstance.matrixPalette);
			}
		}
	}

	drawInstance(device, meshInstance, mesh, style, normal) {
		instancingData = meshInstance.instancingData;

		if (instancingData) {
			if (instancingData.count > 0) {
				this._instancedDrawCalls++;
				device.setVertexBuffer(instancingData.vertexBuffer);
				device.draw(mesh.primitive[style], instancingData.count);
			}
		} else {
			modelMatrix = meshInstance.node.worldTransform;
			this.modelMatrixId.setValue(modelMatrix.data);

			if (normal) {
				normalMatrix = meshInstance.node.normalMatrix;

				if (meshInstance.node._dirtyNormal) {
					modelMatrix.invertTo3x3(normalMatrix);
					normalMatrix.transpose();
					meshInstance.node._dirtyNormal = false;
				}

				this.normalMatrixId.setValue(normalMatrix.data);
			}

			device.draw(mesh.primitive[style]);
		}
	}

	drawInstance2(device, meshInstance, mesh, style) {
		instancingData = meshInstance.instancingData;

		if (instancingData) {
			if (instancingData.count > 0) {
				this._instancedDrawCalls++;
				device.draw(mesh.primitive[style], instancingData.count, true);
			}
		} else {
			device.draw(mesh.primitive[style], undefined, true);
		}
	}

	renderShadows(lights, camera) {
		const isClustered = this.scene.clusteredLightingEnabled;
		const device = this.device;
		device.grabPassAvailable = false;

		for (let i = 0; i < lights.length; i++) {
			const light = lights[i];

			if (isClustered && light._type !== LIGHTTYPE_DIRECTIONAL) {
				if (!light.atlasViewportAllocated) {
					continue;
				}

				if (light.atlasSlotUpdated && light.shadowUpdateMode === SHADOWUPDATE_NONE) {
					light.shadowUpdateMode = SHADOWUPDATE_THISFRAME;
				}
			}

			this._shadowRenderer.render(light, camera);
		}

		device.grabPassAvailable = true;
	}

	renderCookies(lights) {
		const cookieRenderTarget = this.lightTextureAtlas.cookieRenderTarget;

		for (let i = 0; i < lights.length; i++) {
			const light = lights[i];
			if (!light.atlasViewportAllocated) continue;
			if (!light.atlasSlotUpdated) continue;

			this._cookieRenderer.render(light, cookieRenderTarget);
		}
	}

	updateShader(meshInstance, objDefs, staticLightList, pass, sortedLights) {
		meshInstance.material._scene = this.scene;

		if (meshInstance.material._dirtyBlend) {
			this.scene.layers._dirtyBlend = true;
		}

		meshInstance.material.updateShader(this.device, this.scene, objDefs, staticLightList, pass, sortedLights);
		meshInstance._shader[pass] = meshInstance.material.shader;
	}

	setCullMode(cullFaces, flip, drawCall) {
		const material = drawCall.material;
		let mode = CULLFACE_NONE;

		if (cullFaces) {
			let flipFaces = 1;

			if (material.cull > CULLFACE_NONE && material.cull < CULLFACE_FRONTANDBACK) {
				if (drawCall.flipFaces) flipFaces *= -1;
				if (flip) flipFaces *= -1;
				const wt = drawCall.node.worldTransform;
				wt.getX(worldMatX);
				wt.getY(worldMatY);
				wt.getZ(worldMatZ);
				worldMatX.cross(worldMatX, worldMatY);

				if (worldMatX.dot(worldMatZ) < 0) {
					flipFaces *= -1;
				}
			}

			if (flipFaces < 0) {
				mode = material.cull === CULLFACE_FRONT ? CULLFACE_BACK : CULLFACE_FRONT;
			} else {
				mode = material.cull;
			}
		}

		this.device.setCullMode(mode);

		if (mode === CULLFACE_NONE && material.cull === CULLFACE_NONE) {
			const wt2 = drawCall.node.worldTransform;
			wt2.getX(worldMatX);
			wt2.getY(worldMatY);
			wt2.getZ(worldMatZ);
			worldMatX.cross(worldMatX, worldMatY);

			if (worldMatX.dot(worldMatZ) < 0) {
				this.twoSidedLightingNegScaleFactorId.setValue(-1.0);
			} else {
				this.twoSidedLightingNegScaleFactorId.setValue(1.0);
			}
		}
	}

	setVertexBuffers(device, mesh) {
		device.setVertexBuffer(mesh.vertexBuffer);
	}

	setMorphing(device, morphInstance) {
		if (morphInstance) {
			if (morphInstance.morph.useTextureMorph) {
				device.setVertexBuffer(morphInstance.morph.vertexBufferIds);
				this.morphPositionTex.setValue(morphInstance.texturePositions);
				this.morphNormalTex.setValue(morphInstance.textureNormals);
				this.morphTexParams.setValue(morphInstance._textureParams);
			} else {
				for (let t = 0; t < morphInstance._activeVertexBuffers.length; t++) {
					const vb = morphInstance._activeVertexBuffers[t];

					if (vb) {
						const semantic = SEMANTIC_ATTR + (t + 8);
						vb.format.elements[0].name = semantic;
						vb.format.elements[0].scopeId = device.scope.resolve(semantic);
						vb.format.update();
						device.setVertexBuffer(vb);
					}
				}

				this.morphWeightsA.setValue(morphInstance._shaderMorphWeightsA);
				this.morphWeightsB.setValue(morphInstance._shaderMorphWeightsB);
			}
		}
	}

	dispatchViewPos(position) {
		const vp = this.viewPos;
		vp[0] = position.x;
		vp[1] = position.y;
		vp[2] = position.z;
		this.viewPosId.setValue(vp);
	}

	renderForwardPrepareMaterials(camera, drawCalls, drawCallsCount, sortedLights, cullingMask, layer, pass) {
		const addCall = (drawCall, isNewMaterial, lightMaskChanged) => {
			_drawCallList.drawCalls.push(drawCall);

			_drawCallList.isNewMaterial.push(isNewMaterial);

			_drawCallList.lightMaskChanged.push(lightMaskChanged);
		};

		_drawCallList.drawCalls.length = 0;
		_drawCallList.isNewMaterial.length = 0;
		_drawCallList.lightMaskChanged.length = 0;
		const device = this.device;
		const scene = this.scene;
		const lightHash = layer ? layer._lightHash : 0;
		let prevMaterial = null,
				prevObjDefs,
				prevStatic,
				prevLightMask;

		for (let i = 0; i < drawCallsCount; i++) {
			const drawCall = drawCalls[i];
			if (cullingMask && drawCall.mask && !(cullingMask & drawCall.mask)) continue;

			if (drawCall.command) {
				addCall(drawCall, false, false);
			} else {
				if (!drawCall.material) drawCall.material = getDefaultMaterial(device);
				const material = drawCall.material;
				const objDefs = drawCall._shaderDefs;
				const lightMask = drawCall.mask;

				if (material && material === prevMaterial && objDefs !== prevObjDefs) {
					prevMaterial = null;
				}

				if (drawCall.isStatic || prevStatic) {
					prevMaterial = null;
				}

				if (material !== prevMaterial) {
					this._materialSwitches++;

					if (material.dirty) {
						material.updateUniforms(device, scene);
						material.dirty = false;
					}

					if (!drawCall._shader[pass] || drawCall._shaderDefs !== objDefs || drawCall._lightHash !== lightHash) {
						if (!drawCall.isStatic) {
							const variantKey = pass + "_" + objDefs + "_" + lightHash;
							drawCall._shader[pass] = material.variants[variantKey];

							if (!drawCall._shader[pass]) {
								this.updateShader(drawCall, objDefs, null, pass, sortedLights);
								material.variants[variantKey] = drawCall._shader[pass];
							}
						} else {
							this.updateShader(drawCall, objDefs, drawCall._staticLightList, pass, sortedLights);
						}

						drawCall._shaderDefs = objDefs;
						drawCall._lightHash = lightHash;
					}
				}

				addCall(drawCall, material !== prevMaterial, !prevMaterial || lightMask !== prevLightMask);
				prevMaterial = material;
				prevObjDefs = objDefs;
				prevLightMask = lightMask;
				prevStatic = drawCall.isStatic;
			}
		}

		return _drawCallList;
	}

	renderForward(camera, allDrawCalls, allDrawCallsCount, sortedLights, pass, cullingMask, drawCallback, layer, flipFaces) {
		const device = this.device;
		const scene = this.scene;
		const vrDisplay = camera.vrDisplay;
		const passFlag = 1 << pass;
		const halfWidth = device.width * 0.5;
		const preparedCalls = this.renderForwardPrepareMaterials(camera, allDrawCalls, allDrawCallsCount, sortedLights, cullingMask, layer, pass);
		const preparedCallsCount = preparedCalls.drawCalls.length;

		for (let i = 0; i < preparedCallsCount; i++) {
			const drawCall = preparedCalls.drawCalls[i];

			if (drawCall.command) {
				drawCall.command();
			} else {
				const newMaterial = preparedCalls.isNewMaterial[i];
				const lightMaskChanged = preparedCalls.lightMaskChanged[i];
				const material = drawCall.material;
				drawCall._shaderDefs;
				const lightMask = drawCall.mask;

				if (newMaterial) {
					const shader = drawCall._shader[pass];

					if (!shader.failed && !device.setShader(shader)) ;

					material.setParameters(device);

					if (lightMaskChanged) {
						const usedDirLights = this.dispatchDirectLights(sortedLights[LIGHTTYPE_DIRECTIONAL], scene, lightMask, camera);
						this.dispatchLocalLights(sortedLights, scene, lightMask, usedDirLights, drawCall._staticLightList);
					}

					this.alphaTestId.setValue(material.alphaTest);
					device.setBlending(material.blend);

					if (material.blend) {
						if (material.separateAlphaBlend) {
							device.setBlendFunctionSeparate(material.blendSrc, material.blendDst, material.blendSrcAlpha, material.blendDstAlpha);
							device.setBlendEquationSeparate(material.blendEquation, material.blendAlphaEquation);
						} else {
							device.setBlendFunction(material.blendSrc, material.blendDst);
							device.setBlendEquation(material.blendEquation);
						}
					}

					device.setColorWrite(material.redWrite, material.greenWrite, material.blueWrite, material.alphaWrite);
					device.setDepthWrite(material.depthWrite);

					if (material.depthWrite && !material.depthTest) {
						device.setDepthFunc(FUNC_ALWAYS);
						device.setDepthTest(true);
					} else {
						device.setDepthFunc(FUNC_LESSEQUAL);
						device.setDepthTest(material.depthTest);
					}

					device.setAlphaToCoverage(material.alphaToCoverage);

					if (material.depthBias || material.slopeDepthBias) {
						device.setDepthBias(true);
						device.setDepthBiasValues(material.depthBias, material.slopeDepthBias);
					} else {
						device.setDepthBias(false);
					}
				}

				this.setCullMode(camera._cullFaces, flipFaces, drawCall);
				const stencilFront = drawCall.stencilFront || material.stencilFront;
				const stencilBack = drawCall.stencilBack || material.stencilBack;

				if (stencilFront || stencilBack) {
					device.setStencilTest(true);

					if (stencilFront === stencilBack) {
						device.setStencilFunc(stencilFront.func, stencilFront.ref, stencilFront.readMask);
						device.setStencilOperation(stencilFront.fail, stencilFront.zfail, stencilFront.zpass, stencilFront.writeMask);
					} else {
						if (stencilFront) {
							device.setStencilFuncFront(stencilFront.func, stencilFront.ref, stencilFront.readMask);
							device.setStencilOperationFront(stencilFront.fail, stencilFront.zfail, stencilFront.zpass, stencilFront.writeMask);
						} else {
							device.setStencilFuncFront(FUNC_ALWAYS, 0, 0xFF);
							device.setStencilOperationFront(STENCILOP_KEEP, STENCILOP_KEEP, STENCILOP_KEEP, 0xFF);
						}

						if (stencilBack) {
							device.setStencilFuncBack(stencilBack.func, stencilBack.ref, stencilBack.readMask);
							device.setStencilOperationBack(stencilBack.fail, stencilBack.zfail, stencilBack.zpass, stencilBack.writeMask);
						} else {
							device.setStencilFuncBack(FUNC_ALWAYS, 0, 0xFF);
							device.setStencilOperationBack(STENCILOP_KEEP, STENCILOP_KEEP, STENCILOP_KEEP, 0xFF);
						}
					}
				} else {
					device.setStencilTest(false);
				}

				const mesh = drawCall.mesh;
				drawCall.setParameters(device, passFlag);
				this.setVertexBuffers(device, mesh);
				this.setMorphing(device, drawCall.morphInstance);
				this.setSkinning(device, drawCall, material);
				const style = drawCall.renderStyle;
				device.setIndexBuffer(mesh.indexBuffer[style]);

				if (drawCallback) {
					drawCallback(drawCall, i);
				}

				if (vrDisplay && vrDisplay.presenting) {
					device.setViewport(0, 0, halfWidth, device.height);
					this.projId.setValue(projL.data);
					this.projSkyboxId.setValue(projL.data);
					this.viewInvId.setValue(viewInvL.data);
					this.viewId.setValue(viewL.data);
					this.viewId3.setValue(viewMat3L.data);
					this.viewProjId.setValue(viewProjMatL.data);
					this.dispatchViewPos(viewPosL);
					this.drawInstance(device, drawCall, mesh, style, true);
					this._forwardDrawCalls++;
					device.setViewport(halfWidth, 0, halfWidth, device.height);
					this.projId.setValue(projR.data);
					this.projSkyboxId.setValue(projR.data);
					this.viewInvId.setValue(viewInvR.data);
					this.viewId.setValue(viewR.data);
					this.viewId3.setValue(viewMat3R.data);
					this.viewProjId.setValue(viewProjMatR.data);
					this.dispatchViewPos(viewPosR);
					this.drawInstance2(device, drawCall, mesh, style);
					this._forwardDrawCalls++;
				} else if (camera.xr && camera.xr.session && camera.xr.views.length) {
					const views = camera.xr.views;

					for (let v = 0; v < views.length; v++) {
						const view = views[v];
						device.setViewport(view.viewport.x, view.viewport.y, view.viewport.z, view.viewport.w);
						this.projId.setValue(view.projMat.data);
						this.projSkyboxId.setValue(view.projMat.data);
						this.viewId.setValue(view.viewOffMat.data);
						this.viewInvId.setValue(view.viewInvOffMat.data);
						this.viewId3.setValue(view.viewMat3.data);
						this.viewProjId.setValue(view.projViewOffMat.data);
						this.viewPosId.setValue(view.position);

						if (v === 0) {
							this.drawInstance(device, drawCall, mesh, style, true);
						} else {
							this.drawInstance2(device, drawCall, mesh, style);
						}

						this._forwardDrawCalls++;
					}
				} else {
					this.drawInstance(device, drawCall, mesh, style, true);
					this._forwardDrawCalls++;
				}

				if (i < preparedCallsCount - 1 && !preparedCalls.isNewMaterial[i + 1]) {
					material.setParameters(device, drawCall.parameters);
				}
			}
		}

		device.updateEnd();
		_drawCallList.length = 0;
	}

	updateShaders(drawCalls, onlyLitShaders) {
		const count = drawCalls.length;

		for (let i = 0; i < count; i++) {
			const mat = drawCalls[i].material;

			if (mat) {
				if (!_tempMaterialSet.has(mat)) {
					_tempMaterialSet.add(mat);

					if (mat.updateShader !== Material.prototype.updateShader) {
						if (onlyLitShaders) {
							if (!mat.useLighting || mat.emitter && !mat.emitter.lighting) continue;
						}

						mat.clearVariants();
						mat.shader = null;
					}
				}
			}
		}

		_tempMaterialSet.clear();
	}

	beginFrame(comp, lightsChanged) {
		const meshInstances = comp._meshInstances;
		const scene = this.scene;

		if (scene.updateShaders || lightsChanged) {
			const onlyLitShaders = !scene.updateShaders && lightsChanged;
			this.updateShaders(meshInstances, onlyLitShaders);
			scene.updateShaders = false;
			scene._shaderVersion++;
		}

		this.updateCpuSkinMatrices(meshInstances);
		const miCount = meshInstances.length;

		for (let i = 0; i < miCount; i++) {
			meshInstances[i].visibleThisFrame = false;
		}

		const lights = comp._lights;
		const lightCount = lights.length;

		for (let i = 0; i < lightCount; i++) {
			lights[i].beginFrame();
		}
	}

	beginLayers(comp) {
		const len = comp.layerList.length;

		for (let i = 0; i < len; i++) {
			comp.layerList[i]._postRenderCounter = 0;
		}

		const scene = this.scene;
		const shaderVersion = scene._shaderVersion;

		for (let i = 0; i < len; i++) {
			const layer = comp.layerList[i];
			layer._shaderVersion = shaderVersion;
			layer._preRenderCalledForCameras = 0;
			layer._postRenderCalledForCameras = 0;
			const transparent = comp.subLayerList[i];

			if (transparent) {
				layer._postRenderCounter |= 2;
			} else {
				layer._postRenderCounter |= 1;
			}

			layer._postRenderCounterMax = layer._postRenderCounter;

			for (let j = 0; j < layer.cameras.length; j++) {
				layer.instances.prepare(j);
			}

			if (layer._needsStaticPrepare && layer._staticLightHash && !this.scene.clusteredLightingEnabled) {
				if (layer._staticPrepareDone) {
					StaticMeshes.revert(layer.opaqueMeshInstances);
					StaticMeshes.revert(layer.transparentMeshInstances);
				}

				StaticMeshes.prepare(this.device, scene, layer.opaqueMeshInstances, layer._lights);
				StaticMeshes.prepare(this.device, scene, layer.transparentMeshInstances, layer._lights);
				comp._dirty = true;
				scene.updateShaders = true;
				layer._needsStaticPrepare = false;
				layer._staticPrepareDone = true;
			}
		}
	}

	gpuUpdate(drawCalls) {
		this.updateGpuSkinMatrices(drawCalls);
		this.updateMorphing(drawCalls);
	}

	setSceneConstants() {
		const scene = this.scene;
		this.dispatchGlobalLights(scene);

		if (scene.fog !== FOG_NONE) {
			this.fogColor[0] = scene.fogColor.r;
			this.fogColor[1] = scene.fogColor.g;
			this.fogColor[2] = scene.fogColor.b;

			if (scene.gammaCorrection) {
				for (let i = 0; i < 3; i++) {
					this.fogColor[i] = Math.pow(this.fogColor[i], 2.2);
				}
			}

			this.fogColorId.setValue(this.fogColor);

			if (scene.fog === FOG_LINEAR) {
				this.fogStartId.setValue(scene.fogStart);
				this.fogEndId.setValue(scene.fogEnd);
			} else {
				this.fogDensityId.setValue(scene.fogDensity);
			}
		}

		const device = this.device;
		this._screenSize[0] = device.width;
		this._screenSize[1] = device.height;
		this._screenSize[2] = 1 / device.width;
		this._screenSize[3] = 1 / device.height;
		this.screenSizeId.setValue(this._screenSize);
	}

	updateLightStats(comp, compUpdatedFlags) {}

	cullShadowmaps(comp) {
		for (let i = 0; i < comp._lights.length; i++) {
			const light = comp._lights[i];

			if (light._type !== LIGHTTYPE_DIRECTIONAL) {
				if (light.visibleThisFrame && light.castShadows && light.shadowUpdateMode !== SHADOWUPDATE_NONE) {
					const casters = comp._lightCompositionData[i].shadowCastersList;

					this._shadowRenderer.cullLocal(light, casters);
				}
			}
		}

		const renderActions = comp._renderActions;

		for (let i = 0; i < renderActions.length; i++) {
			const renderAction = renderActions[i];
			const count = renderAction.directionalLightsIndices.length;

			for (let j = 0; j < count; j++) {
				const lightIndex = renderAction.directionalLightsIndices[j];
				const light = comp._lights[lightIndex];
				const casters = comp._lightCompositionData[lightIndex].shadowCastersList;

				this._shadowRenderer.cullDirectional(light, casters, renderAction.camera.camera);
			}
		}
	}

	cullComposition(comp) {
		const renderActions = comp._renderActions;

		for (let i = 0; i < renderActions.length; i++) {
			const renderAction = renderActions[i];
			const layerIndex = renderAction.layerIndex;
			const layer = comp.layerList[layerIndex];
			if (!layer.enabled || !comp.subLayerEnabled[layerIndex]) continue;
			const transparent = comp.subLayerList[layerIndex];
			const cameraPass = renderAction.cameraIndex;
			const camera = layer.cameras[cameraPass];

			if (camera) {
				camera.frameBegin(renderAction.renderTarget);

				if (renderAction.firstCameraUse) {
					this.updateCameraFrustum(camera.camera);
					this._camerasRendered++;
				}

				this.cullLights(camera.camera, layer._lights);
				const objects = layer.instances;
				const visible = transparent ? objects.visibleTransparent[cameraPass] : objects.visibleOpaque[cameraPass];

				if (!visible.done) {
					if (layer.onPreCull) {
						layer.onPreCull(cameraPass);
					}

					const drawCalls = transparent ? layer.transparentMeshInstances : layer.opaqueMeshInstances;
					visible.length = this.cull(camera.camera, drawCalls, visible.list);
					visible.done = true;

					if (layer.onPostCull) {
						layer.onPostCull(cameraPass);
					}
				}

				camera.frameEnd();
			}
		}

		this.cullShadowmaps(comp);
	}

	updateLightTextureAtlas(comp) {
		this.lightTextureAtlas.update(comp._splitLights[LIGHTTYPE_SPOT], comp._splitLights[LIGHTTYPE_OMNI], this.scene.lighting);
	}

	updateClusters(comp) {
		for (let i = 0; i < comp._worldClusters.length; i++) {
			const cluster = comp._worldClusters[i];
			cluster.update(comp._lights, this.scene.gammaCorrection, this.scene.lighting);
		}
	}

	renderComposition(comp) {
		const device = this.device;
		const clusteredLightingEnabled = this.scene.clusteredLightingEnabled;

		this.scene._updateSkybox(this.device);

		this.beginLayers(comp);

		const updated = comp._update(device, clusteredLightingEnabled);

		const lightsChanged = (updated & COMPUPDATED_LIGHTS) !== 0;
		this.updateLightStats(comp, updated);
		this.beginFrame(comp, lightsChanged);
		this.setSceneConstants();
		this.cullComposition(comp);
		this.gpuUpdate(comp._meshInstances);

		if (clusteredLightingEnabled) {
			this.updateLightTextureAtlas(comp);

			if (this.scene.lighting.cookiesEnabled) {
				this.renderCookies(comp._splitLights[LIGHTTYPE_SPOT]);
				this.renderCookies(comp._splitLights[LIGHTTYPE_OMNI]);
			}
		}

		if (!clusteredLightingEnabled || clusteredLightingEnabled && this.scene.lighting.shadowsEnabled) {
			this.renderShadows(comp._splitLights[LIGHTTYPE_SPOT]);
			this.renderShadows(comp._splitLights[LIGHTTYPE_OMNI]);
		}

		if (clusteredLightingEnabled) {
			this.updateClusters(comp);
		}
		let clustersDebugRendered = false;
		const renderActions = comp._renderActions;

		for (let i = 0; i < renderActions.length; i++) {
			const renderAction = renderActions[i];
			const layerIndex = renderAction.layerIndex;
			const layer = comp.layerList[layerIndex];
			const transparent = comp.subLayerList[layerIndex];
			const cameraPass = renderAction.cameraIndex;
			const camera = layer.cameras[cameraPass];

			if (renderAction.directionalLights.length > 0) {
				this.renderShadows(renderAction.directionalLights, camera.camera);
			}

			if (!layer.enabled || !comp.subLayerEnabled[layerIndex]) {
				continue;
			}

			if (camera) {
				camera.frameBegin(renderAction.renderTarget);

				if (renderAction.firstCameraUse && camera.onPreRender) {
					camera.onPreRender();
				}
			}

			if (!transparent && layer.onPreRenderOpaque) {
				layer.onPreRenderOpaque(cameraPass);
			} else if (transparent && layer.onPreRenderTransparent) {
				layer.onPreRenderTransparent(cameraPass);
			}

			if (!(layer._preRenderCalledForCameras & 1 << cameraPass)) {
				if (layer.onPreRender) {
					layer.onPreRender(cameraPass);
				}

				layer._preRenderCalledForCameras |= 1 << cameraPass;
			}

			if (camera) {
				var _renderAction$renderT;

				if (renderAction.clearColor || renderAction.clearDepth || renderAction.clearStencil) {
					const backupColor = camera.camera._clearColorBuffer;
					const backupDepth = camera.camera._clearDepthBuffer;
					const backupStencil = camera.camera._clearStencilBuffer;
					camera.camera._clearColorBuffer = renderAction.clearColor;
					camera.camera._clearDepthBuffer = renderAction.clearDepth;
					camera.camera._clearStencilBuffer = renderAction.clearStencil;
					this.clearView(camera.camera, renderAction.renderTarget, true, true);
					camera.camera._clearColorBuffer = backupColor;
					camera.camera._clearDepthBuffer = backupDepth;
					camera.camera._clearStencilBuffer = backupStencil;
				}

				layer._sortVisible(transparent, camera.camera.node, cameraPass);

				const objects = layer.instances;
				const visible = transparent ? objects.visibleTransparent[cameraPass] : objects.visibleOpaque[cameraPass];
				this.scene.immediate.onPreRenderLayer(layer, visible, transparent);
				this.scene._activeCamera = camera.camera;
				this.setCamera(camera.camera, renderAction.renderTarget);

				if (clusteredLightingEnabled && renderAction.lightClusters) {
					renderAction.lightClusters.activate(this.lightTextureAtlas);

					if (!clustersDebugRendered && this.scene.lighting.debugLayer === layer.id) {
						clustersDebugRendered = true;
					}
				}

				const flipFaces = !!(camera.camera._flipFaces ^ (renderAction == null ? void 0 : (_renderAction$renderT = renderAction.renderTarget) == null ? void 0 : _renderAction$renderT.flipY));
				const draws = this._forwardDrawCalls;
				this.renderForward(camera.camera, visible.list, visible.length, layer._splitLights, layer.shaderPass, layer.cullingMask, layer.onDrawCall, layer, flipFaces);
				layer._forwardDrawCalls += this._forwardDrawCalls - draws;
				device.setColorWrite(true, true, true, true);
				device.setStencilTest(false);
				device.setAlphaToCoverage(false);
				device.setDepthBias(false);
				camera.frameEnd();

				if (renderAction.lastCameraUse && camera.onPostRender) {
					camera.onPostRender();
				}

				if (renderAction.triggerPostprocess && camera.onPostprocessing) {
					camera.onPostprocessing();
				}
			}

			if (!transparent && layer.onPostRenderOpaque) {
				layer.onPostRenderOpaque(cameraPass);
			} else if (transparent && layer.onPostRenderTransparent) {
				layer.onPostRenderTransparent(cameraPass);
			}

			if (layer.onPostRender && !(layer._postRenderCalledForCameras & 1 << cameraPass)) {
				layer._postRenderCounter &= ~(transparent ? 2 : 1);

				if (layer._postRenderCounter === 0) {
					layer.onPostRender(cameraPass);
					layer._postRenderCalledForCameras |= 1 << cameraPass;
					layer._postRenderCounter = layer._postRenderCounterMax;
				}
			}
		}
	}

}

let keyA, keyB, sortPos, sortDir;

function sortManual(drawCallA, drawCallB) {
	return drawCallA.drawOrder - drawCallB.drawOrder;
}

function sortMaterialMesh(drawCallA, drawCallB) {
	keyA = drawCallA._key[SORTKEY_FORWARD];
	keyB = drawCallB._key[SORTKEY_FORWARD];

	if (keyA === keyB && drawCallA.mesh && drawCallB.mesh) {
		return drawCallB.mesh.id - drawCallA.mesh.id;
	}

	return keyB - keyA;
}

function sortBackToFront(drawCallA, drawCallB) {
	return drawCallB.zdist - drawCallA.zdist;
}

function sortFrontToBack(drawCallA, drawCallB) {
	return drawCallA.zdist - drawCallB.zdist;
}

const sortCallbacks = [null, sortManual, sortMaterialMesh, sortBackToFront, sortFrontToBack];

function sortLights(lightA, lightB) {
	return lightB.key - lightA.key;
}

let layerCounter = 0;

class VisibleInstanceList {
	constructor() {
		this.list = [];
		this.length = 0;
		this.done = false;
	}

}

class InstanceList {
	constructor() {
		this.opaqueMeshInstances = [];
		this.transparentMeshInstances = [];
		this.shadowCasters = [];
		this.visibleOpaque = [];
		this.visibleTransparent = [];
	}

	prepare(index) {
		if (!this.visibleOpaque[index]) {
			this.visibleOpaque[index] = new VisibleInstanceList();
		}

		if (!this.visibleTransparent[index]) {
			this.visibleTransparent[index] = new VisibleInstanceList();
		}

		this.visibleOpaque[index].done = false;
		this.visibleTransparent[index].done = false;
	}

	delete(index) {
		if (index < this.visibleOpaque.length) {
			this.visibleOpaque.splice(index, 1);
		}

		if (index < this.visibleTransparent.length) {
			this.visibleTransparent.splice(index, 1);
		}
	}

}

class Layer {
	constructor(options = {}) {
		this.name = void 0;

		if (options.id !== undefined) {
			this.id = options.id;
			layerCounter = Math.max(this.id + 1, layerCounter);
		} else {
			this.id = layerCounter++;
		}

		this.name = options.name;
		this._enabled = options.enabled === undefined ? true : options.enabled;
		this._refCounter = this._enabled ? 1 : 0;
		this.opaqueSortMode = options.opaqueSortMode === undefined ? SORTMODE_MATERIALMESH : options.opaqueSortMode;
		this.transparentSortMode = options.transparentSortMode === undefined ? SORTMODE_BACK2FRONT : options.transparentSortMode;
		this.renderTarget = options.renderTarget;
		this.shaderPass = options.shaderPass === undefined ? SHADER_FORWARD : options.shaderPass;
		this.passThrough = options.passThrough === undefined ? false : options.passThrough;
		this._clearColorBuffer = options.clearColorBuffer ? options.clearColorBuffer : false;
		this._clearDepthBuffer = options.clearDepthBuffer ? options.clearDepthBuffer : false;
		this._clearStencilBuffer = options.clearStencilBuffer ? options.clearStencilBuffer : false;
		this.onPreCull = options.onPreCull;
		this.onPreRender = options.onPreRender;
		this.onPreRenderOpaque = options.onPreRenderOpaque;
		this.onPreRenderTransparent = options.onPreRenderTransparent;
		this.onPostCull = options.onPostCull;
		this.onPostRender = options.onPostRender;
		this.onPostRenderOpaque = options.onPostRenderOpaque;
		this.onPostRenderTransparent = options.onPostRenderTransparent;
		this.onDrawCall = options.onDrawCall;
		this.onEnable = options.onEnable;
		this.onDisable = options.onDisable;

		if (this._enabled && this.onEnable) {
			this.onEnable();
		}

		this.layerReference = options.layerReference;
		this.instances = options.layerReference ? options.layerReference.instances : new InstanceList();
		this.cullingMask = options.cullingMask ? options.cullingMask : 0xFFFFFFFF;
		this.opaqueMeshInstances = this.instances.opaqueMeshInstances;
		this.transparentMeshInstances = this.instances.transparentMeshInstances;
		this.shadowCasters = this.instances.shadowCasters;
		this.customSortCallback = null;
		this.customCalculateSortValues = null;
		this._lights = [];
		this._lightsSet = new Set();
		this._clusteredLightsSet = new Set();
		this._splitLights = [[], [], []];
		this.cameras = [];
		this._dirty = false;
		this._dirtyLights = false;
		this._dirtyCameras = false;
		this._lightHash = 0;
		this._staticLightHash = 0;
		this._needsStaticPrepare = true;
		this._staticPrepareDone = false;
		this._shaderVersion = -1;
		this._lightCube = null;
	}

	set renderTarget(rt) {
		this._renderTarget = rt;
		this._dirtyCameras = true;
	}

	get renderTarget() {
		return this._renderTarget;
	}

	set enabled(val) {
		if (val !== this._enabled) {
			this._enabled = val;

			if (val) {
				this.incrementCounter();
				if (this.onEnable) this.onEnable();
			} else {
				this.decrementCounter();
				if (this.onDisable) this.onDisable();
			}
		}
	}

	get enabled() {
		return this._enabled;
	}

	set clearColor(val) {
		this._clearColor.copy(val);
	}

	get clearColor() {
		return this._clearColor;
	}

	set clearColorBuffer(val) {
		this._clearColorBuffer = val;
		this._dirtyCameras = true;
	}

	get clearColorBuffer() {
		return this._clearColorBuffer;
	}

	set clearDepthBuffer(val) {
		this._clearDepthBuffer = val;
		this._dirtyCameras = true;
	}

	get clearDepthBuffer() {
		return this._clearDepthBuffer;
	}

	set clearStencilBuffer(val) {
		this._clearStencilBuffer = val;
		this._dirtyCameras = true;
	}

	get clearStencilBuffer() {
		return this._clearStencilBuffer;
	}

	incrementCounter() {
		if (this._refCounter === 0) {
			this._enabled = true;
			if (this.onEnable) this.onEnable();
		}

		this._refCounter++;
	}

	decrementCounter() {
		if (this._refCounter === 1) {
			this._enabled = false;
			if (this.onDisable) this.onDisable();
		} else if (this._refCounter === 0) {
			return;
		}

		this._refCounter--;
	}

	addMeshInstances(meshInstances, skipShadowCasters) {
		const sceneShaderVer = this._shaderVersion;
		const casters = this.shadowCasters;

		for (let i = 0; i < meshInstances.length; i++) {
			const m = meshInstances[i];
			const mat = m.material;
			const arr = mat.blendType === BLEND_NONE ? this.opaqueMeshInstances : this.transparentMeshInstances;

			if (this.opaqueMeshInstances.indexOf(m) < 0 && this.transparentMeshInstances.indexOf(m) < 0) {
				arr.push(m);
			}

			if (!skipShadowCasters && m.castShadow && casters.indexOf(m) < 0) casters.push(m);

			if (!this.passThrough && sceneShaderVer >= 0 && mat._shaderVersion !== sceneShaderVer) {
				if (mat.updateShader !== Material.prototype.updateShader) {
					mat.clearVariants();
					mat.shader = null;
				}

				mat._shaderVersion = sceneShaderVer;
			}
		}

		if (!this.passThrough) this._dirty = true;
	}

	removeMeshInstanceFromArray(m, arr) {
		let spliceOffset = -1;
		let spliceCount = 0;
		const len = arr.length;

		for (let j = 0; j < len; j++) {
			const drawCall = arr[j];

			if (drawCall === m) {
				spliceOffset = j;
				spliceCount = 1;
				break;
			}

			if (drawCall._staticSource === m) {
				if (spliceOffset < 0) spliceOffset = j;
				spliceCount++;
			} else if (spliceOffset >= 0) {
				break;
			}
		}

		if (spliceOffset >= 0) {
			arr.splice(spliceOffset, spliceCount);
		}
	}

	removeMeshInstances(meshInstances, skipShadowCasters) {
		const opaque = this.opaqueMeshInstances;
		const transparent = this.transparentMeshInstances;
		const casters = this.shadowCasters;

		for (let i = 0; i < meshInstances.length; i++) {
			const m = meshInstances[i];
			this.removeMeshInstanceFromArray(m, opaque);
			this.removeMeshInstanceFromArray(m, transparent);

			if (!skipShadowCasters) {
				const j = casters.indexOf(m);
				if (j >= 0) casters.splice(j, 1);
			}
		}

		this._dirty = true;
	}

	clearMeshInstances(skipShadowCasters) {
		if (this.opaqueMeshInstances.length === 0 && this.transparentMeshInstances.length === 0) {
			if (skipShadowCasters || this.shadowCasters.length === 0) return;
		}

		this.opaqueMeshInstances.length = 0;
		this.transparentMeshInstances.length = 0;
		if (!skipShadowCasters) this.shadowCasters.length = 0;
		if (!this.passThrough) this._dirty = true;
	}

	addLight(light) {
		const l = light.light;

		if (!this._lightsSet.has(l)) {
			this._lightsSet.add(l);

			if (l.type !== LIGHTTYPE_DIRECTIONAL) {
				this._clusteredLightsSet.add(l);
			}

			this._lights.push(l);

			this._dirtyLights = true;

			this._generateLightHash();
		}
	}

	removeLight(light) {
		const l = light.light;

		if (this._lightsSet.has(l)) {
			this._lightsSet.delete(l);

			if (l.type !== LIGHTTYPE_DIRECTIONAL) {
				this._clusteredLightsSet.delete(l);
			}

			this._lights.splice(this._lights.indexOf(l), 1);

			this._dirtyLights = true;

			this._generateLightHash();
		}
	}

	clearLights() {
		this._lightsSet.clear();

		this._clusteredLightsSet.clear();

		this._lights.length = 0;
		this._dirtyLights = true;
	}

	get clusteredLightsSet() {
		return this._clusteredLightsSet;
	}

	addShadowCasters(meshInstances) {
		const arr = this.shadowCasters;

		for (let i = 0; i < meshInstances.length; i++) {
			const m = meshInstances[i];
			if (!m.castShadow) continue;
			if (arr.indexOf(m) < 0) arr.push(m);
		}

		this._dirtyLights = true;
	}

	removeShadowCasters(meshInstances) {
		const arr = this.shadowCasters;

		for (let i = 0; i < meshInstances.length; i++) {
			const id = arr.indexOf(meshInstances[i]);
			if (id >= 0) arr.splice(id, 1);
		}

		this._dirtyLights = true;
	}

	_generateLightHash() {
		if (this._lights.length > 0) {
			this._lights.sort(sortLights);

			let str = "";
			let strStatic = "";

			for (let i = 0; i < this._lights.length; i++) {
				if (this._lights[i].isStatic) {
					strStatic += this._lights[i].key;
				} else {
					str += this._lights[i].key;
				}
			}

			if (str.length === 0) {
				this._lightHash = 0;
			} else {
				this._lightHash = hashCode(str);
			}

			if (strStatic.length === 0) {
				this._staticLightHash = 0;
			} else {
				this._staticLightHash = hashCode(strStatic);
			}
		} else {
			this._lightHash = 0;
			this._staticLightHash = 0;
		}
	}

	addCamera(camera) {
		if (this.cameras.indexOf(camera) >= 0) return;
		this.cameras.push(camera);
		this._dirtyCameras = true;
	}

	removeCamera(camera) {
		const index = this.cameras.indexOf(camera);

		if (index >= 0) {
			this.cameras.splice(index, 1);
			this._dirtyCameras = true;
			this.instances.delete(index);
		}
	}

	clearCameras() {
		this.cameras.length = 0;
		this._dirtyCameras = true;
	}

	_calculateSortDistances(drawCalls, drawCallsCount, camPos, camFwd) {
		for (let i = 0; i < drawCallsCount; i++) {
			const drawCall = drawCalls[i];
			if (drawCall.command) continue;
			if (drawCall.layer <= LAYER_FX) continue;

			if (drawCall.calculateSortDistance) {
				drawCall.zdist = drawCall.calculateSortDistance(drawCall, camPos, camFwd);
				continue;
			}

			const meshPos = drawCall.aabb.center;
			const tempx = meshPos.x - camPos.x;
			const tempy = meshPos.y - camPos.y;
			const tempz = meshPos.z - camPos.z;
			drawCall.zdist = tempx * camFwd.x + tempy * camFwd.y + tempz * camFwd.z;
		}
	}

	_sortVisible(transparent, cameraNode, cameraPass) {
		const objects = this.instances;
		const sortMode = transparent ? this.transparentSortMode : this.opaqueSortMode;
		if (sortMode === SORTMODE_NONE) return;
		const visible = transparent ? objects.visibleTransparent[cameraPass] : objects.visibleOpaque[cameraPass];

		if (sortMode === SORTMODE_CUSTOM) {
			sortPos = cameraNode.getPosition();
			sortDir = cameraNode.forward;

			if (this.customCalculateSortValues) {
				this.customCalculateSortValues(visible.list, visible.length, sortPos, sortDir);
			}

			if (visible.list.length !== visible.length) {
				visible.list.length = visible.length;
			}

			if (this.customSortCallback) {
				visible.list.sort(this.customSortCallback);
			}
		} else {
			if (sortMode === SORTMODE_BACK2FRONT || sortMode === SORTMODE_FRONT2BACK) {
				sortPos = cameraNode.getPosition();
				sortDir = cameraNode.forward;

				this._calculateSortDistances(visible.list, visible.length, sortPos, sortDir);
			}

			if (visible.list.length !== visible.length) {
				visible.list.length = visible.length;
			}

			visible.list.sort(sortCallbacks[sortMode]);
		}
	}

}

const set = {
	equals: function (set1, set2) {
		if (set1.size !== set2.size) {
			return false;
		}

		for (const item of set1) {
			if (!set2.has(item)) {
				return false;
			}
		}

		return true;
	}
};

const cmpPriority = (a, b) => a.priority - b.priority;

const sortPriority = arr => arr.sort(cmpPriority);

class RenderAction {
	constructor() {
		this.layerIndex = 0;
		this.cameraIndex = 0;
		this.camera = null;
		this.renderTarget = null;
		this.lightClusters = null;
		this.clearColor = false;
		this.clearDepth = false;
		this.clearStencil = false;
		this.triggerPostprocess = false;
		this.firstCameraUse = false;
		this.lastCameraUse = false;
		this.directionalLightsSet = new Set();
		this.directionalLights = [];
		this.directionalLightsIndices = [];
	}

	reset() {
		this.lightClusters = null;
		this.directionalLightsSet.clear();
		this.directionalLights.length = 0;
		this.directionalLightsIndices.length = 0;
	}

	collectDirectionalLights(cameraLayers, dirLights, allLights) {
		this.directionalLightsSet.clear();
		this.directionalLights.length = 0;
		this.directionalLightsIndices.length = 0;

		for (let i = 0; i < dirLights.length; i++) {
			const light = dirLights[i];

			if (light.castShadows) {
				for (let l = 0; l < cameraLayers.length; l++) {
					if (cameraLayers[l]._splitLights[LIGHTTYPE_DIRECTIONAL].indexOf(light) >= 0) {
						if (!this.directionalLightsSet.has(light)) {
							this.directionalLightsSet.add(light);
							this.directionalLights.push(light);
							const lightIndex = allLights.indexOf(light);
							this.directionalLightsIndices.push(lightIndex);
						}
					}
				}
			}
		}
	}

}

class LightCompositionData {
	constructor() {
		this.shadowCastersSet = new Set();
		this.shadowCastersList = [];
	}

	clearShadowCasters() {
		this.shadowCastersSet.clear();
		this.shadowCastersList.length = 0;
	}

	addShadowCasters(casters) {
		for (let i = 0; i < casters.length; i++) {
			const item = casters[i];

			if (!this.shadowCastersSet.has(item)) {
				this.shadowCastersSet.add(item);
				this.shadowCastersList.push(item);
			}
		}
	}

}

const tempSet$1 = new Set();
const tempClusterArray = [];

class LayerComposition extends EventHandler {
	constructor(name = "Untitled") {
		super();
		this.name = name;
		this.logRenderActions = false;
		this.layerList = [];
		this.subLayerList = [];
		this.subLayerEnabled = [];
		this._opaqueOrder = {};
		this._transparentOrder = {};
		this._dirty = false;
		this._dirtyBlend = false;
		this._dirtyLights = false;
		this._dirtyCameras = false;
		this._meshInstances = [];
		this._meshInstancesSet = new Set();
		this._lights = [];
		this._lightsMap = new Map();
		this._lightCompositionData = [];
		this._splitLights = [[], [], []];
		this.cameras = [];
		this._renderActions = [];
		this._worldClusters = [];
		this._emptyWorldClusters = null;
	}

	destroy() {
		if (this._emptyWorldClusters) {
			this._emptyWorldClusters.destroy();

			this._emptyWorldClusters = null;
		}

		this._worldClusters.forEach(cluster => {
			cluster.destroy();
		});

		this._worldClusters = null;
	}

	getEmptyWorldClusters(device) {
		if (!this._emptyWorldClusters) {
			this._emptyWorldClusters = new WorldClusters(device);
			this._emptyWorldClusters.name = "ClusterEmpty";

			this._emptyWorldClusters.update([], false, null);
		}

		return this._emptyWorldClusters;
	}

	_splitLightsArray(target) {
		const lights = target._lights;
		target._splitLights[LIGHTTYPE_DIRECTIONAL].length = 0;
		target._splitLights[LIGHTTYPE_OMNI].length = 0;
		target._splitLights[LIGHTTYPE_SPOT].length = 0;

		for (let i = 0; i < lights.length; i++) {
			const light = lights[i];

			if (light.enabled) {
				target._splitLights[light._type].push(light);
			}
		}
	}

	_update(device, clusteredLightingEnabled = false) {
		const len = this.layerList.length;
		let result = 0;

		if (!this._dirty || !this._dirtyLights || !this._dirtyCameras) {
			for (let i = 0; i < len; i++) {
				const layer = this.layerList[i];

				if (layer._dirty) {
					this._dirty = true;
				}

				if (layer._dirtyLights) {
					this._dirtyLights = true;
				}

				if (layer._dirtyCameras) {
					this._dirtyCameras = true;
				}
			}
		}

		function addUniqueMeshInstance(destArray, destSet, srcArray) {
			let dirtyBlend = false;
			const srcLen = srcArray.length;

			for (let s = 0; s < srcLen; s++) {
				const meshInst = srcArray[s];

				if (!destSet.has(meshInst)) {
					destSet.add(meshInst);
					destArray.push(meshInst);
					const material = meshInst.material;

					if (material && material._dirtyBlend) {
						dirtyBlend = true;
						material._dirtyBlend = false;
					}
				}
			}

			return dirtyBlend;
		}

		if (this._dirty) {
			result |= COMPUPDATED_INSTANCES;
			this._meshInstances.length = 0;

			this._meshInstancesSet.clear();

			for (let i = 0; i < len; i++) {
				const layer = this.layerList[i];

				if (!layer.passThrough) {
					this._dirtyBlend = addUniqueMeshInstance(this._meshInstances, this._meshInstancesSet, layer.opaqueMeshInstances) || this._dirtyBlend;
					this._dirtyBlend = addUniqueMeshInstance(this._meshInstances, this._meshInstancesSet, layer.transparentMeshInstances) || this._dirtyBlend;
				}

				layer._dirty = false;
			}

			this._dirty = false;
		}

		function moveByBlendType(dest, src, moveTransparent) {
			for (let s = 0; s < src.length;) {
				var _src$s$material;

				if (((_src$s$material = src[s].material) == null ? void 0 : _src$s$material.transparent) === moveTransparent) {
					dest.push(src[s]);
					src[s] = src[src.length - 1];
					src.length--;
				} else {
					s++;
				}
			}
		}

		if (this._dirtyBlend) {
			result |= COMPUPDATED_BLEND;

			for (let i = 0; i < len; i++) {
				const layer = this.layerList[i];

				if (!layer.passThrough) {
					moveByBlendType(layer.opaqueMeshInstances, layer.transparentMeshInstances, false);
					moveByBlendType(layer.transparentMeshInstances, layer.opaqueMeshInstances, true);
				}
			}

			this._dirtyBlend = false;
		}

		if (this._dirtyLights) {
			result |= COMPUPDATED_LIGHTS;
			this._dirtyLights = false;
			this.updateLights();
		}

		if (result) {
			this.updateShadowCasters();
		}

		if (this._dirtyCameras || result & COMPUPDATED_LIGHTS) {
			this._dirtyCameras = false;
			result |= COMPUPDATED_CAMERAS;
			this.cameras.length = 0;

			for (let i = 0; i < len; i++) {
				const layer = this.layerList[i];
				layer._dirtyCameras = false;

				for (let j = 0; j < layer.cameras.length; j++) {
					const camera = layer.cameras[j];
					const index = this.cameras.indexOf(camera);

					if (index < 0) {
						this.cameras.push(camera);
					}
				}
			}

			if (this.cameras.length > 1) {
				sortPriority(this.cameras);
			}

			const cameraLayers = [];
			let renderActionCount = 0;

			for (let i = 0; i < this.cameras.length; i++) {
				const camera = this.cameras[i];
				cameraLayers.length = 0;
				let cameraFirstRenderAction = true;
				const cameraFirstRenderActionIndex = renderActionCount;
				let lastRenderAction = null;
				let postProcessMarked = false;

				for (let j = 0; j < len; j++) {
					const layer = this.layerList[j];

					if (layer) {
						if (layer.cameras.length > 0) {
							if (camera.layers.indexOf(layer.id) >= 0) {
								cameraLayers.push(layer);

								if (!postProcessMarked && layer.id === camera.disablePostEffectsLayer) {
									postProcessMarked = true;

									if (lastRenderAction) {
										lastRenderAction.triggerPostprocess = true;
									}
								}

								const cameraIndex = layer.cameras.indexOf(camera);

								if (cameraIndex >= 0) {
									lastRenderAction = this.addRenderAction(this._renderActions, renderActionCount, layer, j, cameraIndex, cameraFirstRenderAction, postProcessMarked);
									renderActionCount++;
									cameraFirstRenderAction = false;
								}
							}
						}
					}
				}

				if (cameraFirstRenderActionIndex < renderActionCount) {
					this._renderActions[cameraFirstRenderActionIndex].collectDirectionalLights(cameraLayers, this._splitLights[LIGHTTYPE_DIRECTIONAL], this._lights);

					lastRenderAction.lastCameraUse = true;
				}

				if (!postProcessMarked && lastRenderAction) {
					lastRenderAction.triggerPostprocess = true;
				}

				if (camera.renderTarget && camera.postEffectsEnabled) {
					this.propagateRenderTarget(cameraFirstRenderActionIndex - 1, camera);
				}
			}

			this._renderActions.length = renderActionCount;

			if (clusteredLightingEnabled) {
				this.allocateLightClusters(device);
			}
		}

		if (result & COMPUPDATED_LIGHTS || result & COMPUPDATED_CAMERAS) {
			this._logRenderActions();
		}

		return result;
	}

	updateShadowCasters() {
		const lightCount = this._lights.length;

		for (let i = 0; i < lightCount; i++) {
			this._lightCompositionData[i].clearShadowCasters();
		}

		const len = this.layerList.length;

		for (let i = 0; i < len; i++) {
			const layer = this.layerList[i];

			if (!tempSet$1.has(layer)) {
				tempSet$1.add(layer);
				const lights = layer._lights;

				for (let j = 0; j < lights.length; j++) {
					if (lights[j].castShadows) {
						const lightIndex = this._lightsMap.get(lights[j]);

						const lightCompData = this._lightCompositionData[lightIndex];
						lightCompData.addShadowCasters(layer.shadowCasters);
					}
				}
			}
		}

		tempSet$1.clear();
	}

	updateLights() {
		this._lights.length = 0;

		this._lightsMap.clear();

		const count = this.layerList.length;

		for (let i = 0; i < count; i++) {
			const layer = this.layerList[i];

			if (!tempSet$1.has(layer)) {
				tempSet$1.add(layer);
				const lights = layer._lights;

				for (let j = 0; j < lights.length; j++) {
					const light = lights[j];

					let lightIndex = this._lightsMap.get(light);

					if (lightIndex === undefined) {
						lightIndex = this._lights.length;

						this._lightsMap.set(light, lightIndex);

						this._lights.push(light);

						let lightCompData = this._lightCompositionData[lightIndex];

						if (!lightCompData) {
							lightCompData = new LightCompositionData();
							this._lightCompositionData[lightIndex] = lightCompData;
						}
					}
				}
			}

			this._splitLightsArray(layer);

			layer._dirtyLights = false;
		}

		tempSet$1.clear();

		this._splitLightsArray(this);

		const lightCount = this._lights.length;
		this._lightCompositionData.length = lightCount;
	}

	findCompatibleCluster(layer, renderActionCount) {
		for (let i = 0; i < renderActionCount; i++) {
			const ra = this._renderActions[i];
			const raLayer = this.layerList[ra.layerIndex];

			if (layer === raLayer) {
				return ra.lightClusters;
			}

			if (ra.lightClusters) {
				if (set.equals(layer._clusteredLightsSet, raLayer._clusteredLightsSet)) {
					return ra.lightClusters;
				}
			}
		}

		return null;
	}

	allocateLightClusters(device) {
		tempClusterArray.push(...this._worldClusters);
		this._worldClusters.length = 0;
		const count = this._renderActions.length;

		for (let i = 0; i < count; i++) {
			const ra = this._renderActions[i];
			const layer = this.layerList[ra.layerIndex];

			if (layer._clusteredLightsSet.size) {
				const transparent = this.subLayerList[ra.layerIndex];
				const meshInstances = transparent ? layer.transparentMeshInstances : layer.opaqueMeshInstances;

				if (meshInstances.length) {
					let clusters = this.findCompatibleCluster(layer, i);

					if (!clusters) {
						if (tempClusterArray.length) {
							clusters = tempClusterArray.pop();
						}

						if (!clusters) {
							clusters = new WorldClusters(device);
						}

						clusters.name = "Cluster-" + this._worldClusters.length;

						this._worldClusters.push(clusters);
					}

					ra.lightClusters = clusters;
				}
			}

			if (!ra.lightClusters) {
				ra.lightClusters = this.getEmptyWorldClusters(device);
			}
		}

		tempClusterArray.forEach(item => {
			item.destroy();
		});
		tempClusterArray.length = 0;
	}

	addRenderAction(renderActions, renderActionIndex, layer, layerIndex, cameraIndex, cameraFirstRenderAction, postProcessMarked) {
		let renderAction = renderActions[renderActionIndex];

		if (!renderAction) {
			renderAction = renderActions[renderActionIndex] = new RenderAction();
		}

		let rt = layer.renderTarget;
		const camera = layer.cameras[cameraIndex];

		if (camera && camera.renderTarget) {
			if (layer.id !== LAYERID_DEPTH) {
				rt = camera.renderTarget;
			}
		}

		let used = false;

		for (let i = renderActionIndex - 1; i >= 0; i--) {
			if (renderActions[i].camera === camera && renderActions[i].renderTarget === rt) {
				used = true;
				break;
			}
		}

		const needsClear = cameraFirstRenderAction || !used;
		let clearColor = needsClear ? camera.clearColorBuffer : false;
		let clearDepth = needsClear ? camera.clearDepthBuffer : false;
		let clearStencil = needsClear ? camera.clearStencilBuffer : false;
		clearColor |= layer.clearColorBuffer;
		clearDepth |= layer.clearDepthBuffer;
		clearStencil |= layer.clearStencilBuffer;

		if (postProcessMarked && camera.postEffectsEnabled) {
			rt = null;
		}

		renderAction.reset();
		renderAction.triggerPostprocess = false;
		renderAction.layerIndex = layerIndex;
		renderAction.cameraIndex = cameraIndex;
		renderAction.camera = camera;
		renderAction.renderTarget = rt;
		renderAction.clearColor = clearColor;
		renderAction.clearDepth = clearDepth;
		renderAction.clearStencil = clearStencil;
		renderAction.firstCameraUse = cameraFirstRenderAction;
		renderAction.lastCameraUse = false;
		return renderAction;
	}

	propagateRenderTarget(startIndex, fromCamera) {
		for (let a = startIndex; a >= 0; a--) {
			const ra = this._renderActions[a];
			const layer = this.layerList[ra.layerIndex];

			if (ra.renderTarget && layer.id !== LAYERID_DEPTH) {
				break;
			}

			if (layer.id === LAYERID_DEPTH) {
				continue;
			}

			const thisCamera = ra == null ? void 0 : ra.camera.camera;

			if (thisCamera) {
				if (!fromCamera.camera.rect.equals(thisCamera.rect) || !fromCamera.camera.scissorRect.equals(thisCamera.scissorRect)) {
					break;
				}
			}

			ra.renderTarget = fromCamera.renderTarget;
		}
	}

	_logRenderActions() {}

	_isLayerAdded(layer) {
		if (this.layerList.indexOf(layer) >= 0) {
			return true;
		}

		return false;
	}

	_isSublayerAdded(layer, transparent) {
		for (let i = 0; i < this.layerList.length; i++) {
			if (this.layerList[i] === layer && this.subLayerList[i] === transparent) {
				return true;
			}
		}

		return false;
	}

	push(layer) {
		if (this._isLayerAdded(layer)) return;
		this.layerList.push(layer);
		this.layerList.push(layer);
		this._opaqueOrder[layer.id] = this.subLayerList.push(false) - 1;
		this._transparentOrder[layer.id] = this.subLayerList.push(true) - 1;
		this.subLayerEnabled.push(true);
		this.subLayerEnabled.push(true);
		this._dirty = true;
		this._dirtyLights = true;
		this._dirtyCameras = true;
		this.fire("add", layer);
	}

	insert(layer, index) {
		if (this._isLayerAdded(layer)) return;
		this.layerList.splice(index, 0, layer, layer);
		this.subLayerList.splice(index, 0, false, true);
		const count = this.layerList.length;

		this._updateOpaqueOrder(index, count - 1);

		this._updateTransparentOrder(index, count - 1);

		this.subLayerEnabled.splice(index, 0, true, true);
		this._dirty = true;
		this._dirtyLights = true;
		this._dirtyCameras = true;
		this.fire("add", layer);
	}

	remove(layer) {
		let id = this.layerList.indexOf(layer);
		delete this._opaqueOrder[id];
		delete this._transparentOrder[id];

		while (id >= 0) {
			this.layerList.splice(id, 1);
			this.subLayerList.splice(id, 1);
			this.subLayerEnabled.splice(id, 1);
			id = this.layerList.indexOf(layer);
			this._dirty = true;
			this._dirtyLights = true;
			this._dirtyCameras = true;
			this.fire("remove", layer);
		}

		const count = this.layerList.length;

		this._updateOpaqueOrder(0, count - 1);

		this._updateTransparentOrder(0, count - 1);
	}

	pushOpaque(layer) {
		if (this._isSublayerAdded(layer, false)) return;
		this.layerList.push(layer);
		this._opaqueOrder[layer.id] = this.subLayerList.push(false) - 1;
		this.subLayerEnabled.push(true);
		this._dirty = true;
		this._dirtyLights = true;
		this._dirtyCameras = true;
		this.fire("add", layer);
	}

	insertOpaque(layer, index) {
		if (this._isSublayerAdded(layer, false)) return;
		this.layerList.splice(index, 0, layer);
		this.subLayerList.splice(index, 0, false);
		const count = this.subLayerList.length;

		this._updateOpaqueOrder(index, count - 1);

		this.subLayerEnabled.splice(index, 0, true);
		this._dirty = true;
		this._dirtyLights = true;
		this._dirtyCameras = true;
		this.fire("add", layer);
	}

	removeOpaque(layer) {
		for (let i = 0, len = this.layerList.length; i < len; i++) {
			if (this.layerList[i] === layer && !this.subLayerList[i]) {
				this.layerList.splice(i, 1);
				this.subLayerList.splice(i, 1);
				len--;

				this._updateOpaqueOrder(i, len - 1);

				this.subLayerEnabled.splice(i, 1);
				this._dirty = true;
				this._dirtyLights = true;
				this._dirtyCameras = true;

				if (this.layerList.indexOf(layer) < 0) {
					this.fire("remove", layer);
				}

				return;
			}
		}
	}

	pushTransparent(layer) {
		if (this._isSublayerAdded(layer, true)) return;
		this.layerList.push(layer);
		this._transparentOrder[layer.id] = this.subLayerList.push(true) - 1;
		this.subLayerEnabled.push(true);
		this._dirty = true;
		this._dirtyLights = true;
		this._dirtyCameras = true;
		this.fire("add", layer);
	}

	insertTransparent(layer, index) {
		if (this._isSublayerAdded(layer, true)) return;
		this.layerList.splice(index, 0, layer);
		this.subLayerList.splice(index, 0, true);
		const count = this.subLayerList.length;

		this._updateTransparentOrder(index, count - 1);

		this.subLayerEnabled.splice(index, 0, true);
		this._dirty = true;
		this._dirtyLights = true;
		this._dirtyCameras = true;
		this.fire("add", layer);
	}

	removeTransparent(layer) {
		for (let i = 0, len = this.layerList.length; i < len; i++) {
			if (this.layerList[i] === layer && this.subLayerList[i]) {
				this.layerList.splice(i, 1);
				this.subLayerList.splice(i, 1);
				len--;

				this._updateTransparentOrder(i, len - 1);

				this.subLayerEnabled.splice(i, 1);
				this._dirty = true;
				this._dirtyLights = true;
				this._dirtyCameras = true;

				if (this.layerList.indexOf(layer) < 0) {
					this.fire("remove", layer);
				}

				return;
			}
		}
	}

	_getSublayerIndex(layer, transparent) {
		let id = this.layerList.indexOf(layer);
		if (id < 0) return -1;

		if (this.subLayerList[id] !== transparent) {
			id = this.layerList.indexOf(layer, id + 1);
			if (id < 0) return -1;

			if (this.subLayerList[id] !== transparent) {
				return -1;
			}
		}

		return id;
	}

	getOpaqueIndex(layer) {
		return this._getSublayerIndex(layer, false);
	}

	getTransparentIndex(layer) {
		return this._getSublayerIndex(layer, true);
	}

	getLayerById(id) {
		for (let i = 0; i < this.layerList.length; i++) {
			if (this.layerList[i].id === id) return this.layerList[i];
		}

		return null;
	}

	getLayerByName(name) {
		for (let i = 0; i < this.layerList.length; i++) {
			if (this.layerList[i].name === name) return this.layerList[i];
		}

		return null;
	}

	_updateOpaqueOrder(startIndex, endIndex) {
		for (let i = startIndex; i <= endIndex; i++) {
			if (this.subLayerList[i] === false) {
				this._opaqueOrder[this.layerList[i].id] = i;
			}
		}
	}

	_updateTransparentOrder(startIndex, endIndex) {
		for (let i = startIndex; i <= endIndex; i++) {
			if (this.subLayerList[i] === true) {
				this._transparentOrder[this.layerList[i].id] = i;
			}
		}
	}

	_sortLayersDescending(layersA, layersB, order) {
		let topLayerA = -1;
		let topLayerB = -1;

		for (let i = 0, len = layersA.length; i < len; i++) {
			const id = layersA[i];

			if (order.hasOwnProperty(id)) {
				topLayerA = Math.max(topLayerA, order[id]);
			}
		}

		for (let i = 0, len = layersB.length; i < len; i++) {
			const id = layersB[i];

			if (order.hasOwnProperty(id)) {
				topLayerB = Math.max(topLayerB, order[id]);
			}
		}

		if (topLayerA === -1 && topLayerB !== -1) {
			return 1;
		} else if (topLayerB === -1 && topLayerA !== -1) {
			return -1;
		}

		return topLayerB - topLayerA;
	}

	sortTransparentLayers(layersA, layersB) {
		return this._sortLayersDescending(layersA, layersB, this._transparentOrder);
	}

	sortOpaqueLayers(layersA, layersB) {
		return this._sortLayersDescending(layersA, layersB, this._opaqueOrder);
	}

}

const spotCenter = new Vec3();
const spotEndPoint = new Vec3();
const tmpVec = new Vec3();
const tmpBiases = {
	bias: 0,
	normalBias: 0
};
const chanId = {
	r: 0,
	g: 1,
	b: 2,
	a: 3
};
const directionalCascades = [[new Vec4(0, 0, 1, 1)], [new Vec4(0, 0, 0.5, 0.5), new Vec4(0, 0.5, 0.5, 0.5)], [new Vec4(0, 0, 0.5, 0.5), new Vec4(0, 0.5, 0.5, 0.5), new Vec4(0.5, 0, 0.5, 0.5)], [new Vec4(0, 0, 0.5, 0.5), new Vec4(0, 0.5, 0.5, 0.5), new Vec4(0.5, 0, 0.5, 0.5), new Vec4(0.5, 0.5, 0.5, 0.5)]];
let id = 0;

class LightRenderData {
	constructor(device, camera, face, light) {
		this.light = light;
		this.camera = camera;
		this.shadowCamera = ShadowRenderer.createShadowCamera(device, light._shadowType, light._type, face);
		this.shadowMatrix = new Mat4();
		this.shadowViewport = new Vec4(0, 0, 1, 1);
		this.shadowScissor = new Vec4(0, 0, 1, 1);
		this.face = face;
		this.visibleCasters = [];
	}

	get shadowBuffer() {
		const rt = this.shadowCamera.renderTarget;

		if (rt) {
			const light = this.light;

			if (light._type === LIGHTTYPE_OMNI) {
				return rt.colorBuffer;
			}

			return light._isPcf && light.device.webgl2 ? rt.depthBuffer : rt.colorBuffer;
		}

		return null;
	}

}

class Light {
	constructor(graphicsDevice) {
		this.device = graphicsDevice;
		this.id = id++;
		this._type = LIGHTTYPE_DIRECTIONAL;
		this._color = new Color(0.8, 0.8, 0.8);
		this._intensity = 1;
		this._castShadows = false;
		this._enabled = false;
		this.mask = MASK_AFFECT_DYNAMIC;
		this.isStatic = false;
		this.key = 0;
		this.bakeDir = true;
		this.bakeNumSamples = 1;
		this.bakeArea = 0;
		this.attenuationStart = 10;
		this.attenuationEnd = 10;
		this._falloffMode = LIGHTFALLOFF_LINEAR;
		this._shadowType = SHADOW_PCF3;
		this._vsmBlurSize = 11;
		this.vsmBlurMode = BLUR_GAUSSIAN;
		this.vsmBias = 0.01 * 0.25;
		this._cookie = null;
		this.cookieIntensity = 1;
		this._cookieFalloff = true;
		this._cookieChannel = "rgb";
		this._cookieTransform = null;
		this._cookieTransformUniform = new Float32Array(4);
		this._cookieOffset = null;
		this._cookieOffsetUniform = new Float32Array(2);
		this._cookieTransformSet = false;
		this._cookieOffsetSet = false;
		this._innerConeAngle = 40;
		this._outerConeAngle = 45;
		this.cascades = null;
		this._shadowMatrixPalette = null;
		this._shadowCascadeDistances = null;
		this.numCascades = 1;
		this.cascadeDistribution = 0.5;
		this._shape = LIGHTSHAPE_PUNCTUAL;
		this._finalColor = new Float32Array([0.8, 0.8, 0.8]);
		const c = Math.pow(this._finalColor[0], 2.2);
		this._linearFinalColor = new Float32Array([c, c, c]);
		this._position = new Vec3(0, 0, 0);
		this._direction = new Vec3(0, 0, 0);
		this._innerConeAngleCos = Math.cos(this._innerConeAngle * Math.PI / 180);
		this._outerConeAngleCos = Math.cos(this._outerConeAngle * Math.PI / 180);
		this._shadowMap = null;
		this._shadowRenderParams = [];
		this.shadowDistance = 40;
		this._shadowResolution = 1024;
		this.shadowBias = -0.0005;
		this._normalOffsetBias = 0.0;
		this.shadowUpdateMode = SHADOWUPDATE_REALTIME;
		this._isVsm = false;
		this._isPcf = true;
		this._cookieMatrix = null;
		this._atlasViewport = null;
		this.atlasViewportAllocated = false;
		this.atlasVersion = 0;
		this.atlasSlotIndex = 0;
		this.atlasSlotUpdated = false;
		this._scene = null;
		this._node = null;
		this._renderData = [];
		this.visibleThisFrame = false;
		this.maxScreenSize = 0;
	}

	destroy() {
		this._destroyShadowMap();

		this._renderData = null;
	}

	set numCascades(value) {
		if (!this.cascades || this.numCascades != value) {
			this.cascades = directionalCascades[value - 1];
			this._shadowMatrixPalette = new Float32Array(4 * 16);
			this._shadowCascadeDistances = new Float32Array(4);

			this._destroyShadowMap();

			this.updateKey();
		}
	}

	get numCascades() {
		return this.cascades.length;
	}

	set shadowMap(shadowMap) {
		if (this._shadowMap !== shadowMap) {
			this._destroyShadowMap();

			this._shadowMap = shadowMap;
		}
	}

	get shadowMap() {
		return this._shadowMap;
	}

	get numShadowFaces() {
		const type = this._type;

		if (type === LIGHTTYPE_DIRECTIONAL) {
			return this.numCascades;
		} else if (type === LIGHTTYPE_OMNI) {
			return 6;
		}

		return 1;
	}

	set type(value) {
		if (this._type === value) return;
		this._type = value;

		this._destroyShadowMap();

		this.updateKey();
		const stype = this._shadowType;
		this._shadowType = null;
		this.shadowType = stype;
	}

	get type() {
		return this._type;
	}

	set shape(value) {
		if (this._shape === value) return;
		this._shape = value;

		this._destroyShadowMap();

		this.updateKey();
		const stype = this._shadowType;
		this._shadowType = null;
		this.shadowType = stype;
	}

	get shape() {
		return this._shape;
	}

	set shadowType(value) {
		if (this._shadowType === value) return;
		const device = this.device;
		if (this._type === LIGHTTYPE_OMNI) value = SHADOW_PCF3;

		if (value === SHADOW_PCF5 && !device.webgl2) {
			value = SHADOW_PCF3;
		}

		if (value === SHADOW_VSM32 && !device.textureFloatRenderable) value = SHADOW_VSM16;
		if (value === SHADOW_VSM16 && !device.textureHalfFloatRenderable) value = SHADOW_VSM8;
		this._isVsm = value >= SHADOW_VSM8 && value <= SHADOW_VSM32;
		this._isPcf = value === SHADOW_PCF5 || value === SHADOW_PCF3;
		this._shadowType = value;

		this._destroyShadowMap();

		this.updateKey();
	}

	get shadowType() {
		return this._shadowType;
	}

	set enabled(value) {
		if (this._enabled !== value) {
			this._enabled = value;
			this.layersDirty();
		}
	}

	get enabled() {
		return this._enabled;
	}

	set castShadows(value) {
		if (this._castShadows !== value) {
			this._castShadows = value;

			this._destroyShadowMap();

			this.layersDirty();
			this.updateKey();
		}
	}

	get castShadows() {
		return this._castShadows && this.mask !== MASK_BAKE && this.mask !== 0;
	}

	set shadowResolution(value) {
		if (this._shadowResolution !== value) {
			if (this._type === LIGHTTYPE_OMNI) {
				value = Math.min(value, this.device.maxCubeMapSize);
			} else {
				value = Math.min(value, this.device.maxTextureSize);
			}

			this._shadowResolution = value;

			this._destroyShadowMap();
		}
	}

	get shadowResolution() {
		return this._shadowResolution;
	}

	set vsmBlurSize(value) {
		if (this._vsmBlurSize === value) return;
		if (value % 2 === 0) value++;
		this._vsmBlurSize = value;
	}

	get vsmBlurSize() {
		return this._vsmBlurSize;
	}

	set normalOffsetBias(value) {
		if (this._normalOffsetBias === value) return;

		if (!this._normalOffsetBias && value || this._normalOffsetBias && !value) {
			this.updateKey();
		}

		this._normalOffsetBias = value;
	}

	get normalOffsetBias() {
		return this._normalOffsetBias;
	}

	set falloffMode(value) {
		if (this._falloffMode === value) return;
		this._falloffMode = value;
		this.updateKey();
	}

	get falloffMode() {
		return this._falloffMode;
	}

	set innerConeAngle(value) {
		if (this._innerConeAngle === value) return;
		this._innerConeAngle = value;
		this._innerConeAngleCos = Math.cos(value * Math.PI / 180);
	}

	get innerConeAngle() {
		return this._innerConeAngle;
	}

	set outerConeAngle(value) {
		if (this._outerConeAngle === value) return;
		this._outerConeAngle = value;
		this._outerConeAngleCos = Math.cos(value * Math.PI / 180);
	}

	get outerConeAngle() {
		return this._outerConeAngle;
	}

	set intensity(value) {
		if (this._intensity !== value) {
			this._intensity = value;

			this._updateFinalColor();
		}
	}

	get intensity() {
		return this._intensity;
	}

	get cookieMatrix() {
		if (!this._cookieMatrix) {
			this._cookieMatrix = new Mat4();
		}

		return this._cookieMatrix;
	}

	get atlasViewport() {
		if (!this._atlasViewport) {
			this._atlasViewport = new Vec4(0, 0, 1, 1);
		}

		return this._atlasViewport;
	}

	set cookie(value) {
		if (this._cookie === value) return;
		this._cookie = value;
		this.updateKey();
	}

	get cookie() {
		return this._cookie;
	}

	set cookieFalloff(value) {
		if (this._cookieFalloff === value) return;
		this._cookieFalloff = value;
		this.updateKey();
	}

	get cookieFalloff() {
		return this._cookieFalloff;
	}

	set cookieChannel(value) {
		if (this._cookieChannel === value) return;

		if (value.length < 3) {
			const chr = value.charAt(value.length - 1);
			const addLen = 3 - value.length;

			for (let i = 0; i < addLen; i++) value += chr;
		}

		this._cookieChannel = value;
		this.updateKey();
	}

	get cookieChannel() {
		return this._cookieChannel;
	}

	set cookieTransform(value) {
		if (this._cookieTransform === value) return;
		this._cookieTransform = value;
		this._cookieTransformSet = !!value;

		if (value && !this._cookieOffset) {
			this.cookieOffset = new Vec2();
			this._cookieOffsetSet = false;
		}

		this.updateKey();
	}

	get cookieTransform() {
		return this._cookieTransform;
	}

	set cookieOffset(value) {
		if (this._cookieOffset === value) return;
		const xformNew = !!(this._cookieTransformSet || value);

		if (xformNew && !value && this._cookieOffset) {
			this._cookieOffset.set(0, 0);
		} else {
			this._cookieOffset = value;
		}

		this._cookieOffsetSet = !!value;

		if (value && !this._cookieTransform) {
			this.cookieTransform = new Vec4(1, 1, 0, 0);
			this._cookieTransformSet = false;
		}

		this.updateKey();
	}

	get cookieOffset() {
		return this._cookieOffset;
	}

	beginFrame() {
		this.visibleThisFrame = this._type === LIGHTTYPE_DIRECTIONAL && this._enabled;
		this.maxScreenSize = 0;
		this.atlasViewportAllocated = false;
		this.atlasSlotUpdated = false;
	}

	_destroyShadowMap() {
		if (this._renderData) {
			this._renderData.length = 0;
		}

		if (this._shadowMap) {
			if (!this._shadowMap.cached) {
				this._shadowMap.destroy();
			}

			this._shadowMap = null;
		}

		if (this.shadowUpdateMode === SHADOWUPDATE_NONE) {
			this.shadowUpdateMode = SHADOWUPDATE_THISFRAME;
		}
	}

	getRenderData(camera, face) {
		for (let i = 0; i < this._renderData.length; i++) {
			const current = this._renderData[i];

			if (current.camera === camera && current.face === face) {
				return current;
			}
		}

		const rd = new LightRenderData(this.device, camera, face, this);

		this._renderData.push(rd);

		return rd;
	}

	clone() {
		const clone = new Light(this.device);
		clone.type = this._type;
		clone.setColor(this._color);
		clone.intensity = this._intensity;
		clone.castShadows = this.castShadows;
		clone._enabled = this._enabled;
		clone.attenuationStart = this.attenuationStart;
		clone.attenuationEnd = this.attenuationEnd;
		clone.falloffMode = this._falloffMode;
		clone.shadowType = this._shadowType;
		clone.vsmBlurSize = this._vsmBlurSize;
		clone.vsmBlurMode = this.vsmBlurMode;
		clone.vsmBias = this.vsmBias;
		clone.shadowUpdateMode = this.shadowUpdateMode;
		clone.mask = this.mask;
		clone.innerConeAngle = this._innerConeAngle;
		clone.outerConeAngle = this._outerConeAngle;
		clone.numCascades = this.numCascades;
		clone.cascadeDistribution = this.cascadeDistribution;
		clone.shape = this._shape;
		clone.shadowBias = this.shadowBias;
		clone.normalOffsetBias = this._normalOffsetBias;
		clone.shadowResolution = this._shadowResolution;
		clone.shadowDistance = this.shadowDistance;
		return clone;
	}

	_getUniformBiasValues(lightRenderData) {
		const farClip = lightRenderData.shadowCamera._farClip;

		switch (this._type) {
			case LIGHTTYPE_OMNI:
				tmpBiases.bias = this.shadowBias;
				tmpBiases.normalBias = this._normalOffsetBias;
				break;

			case LIGHTTYPE_SPOT:
				if (this._isVsm) {
					tmpBiases.bias = -0.00001 * 20;
				} else {
					tmpBiases.bias = this.shadowBias * 20;
					if (!this.device.webgl2 && this.device.extStandardDerivatives) tmpBiases.bias *= -100;
				}

				tmpBiases.normalBias = this._isVsm ? this.vsmBias / (this.attenuationEnd / 7.0) : this._normalOffsetBias;
				break;

			case LIGHTTYPE_DIRECTIONAL:
				if (this._isVsm) {
					tmpBiases.bias = -0.00001 * 20;
				} else {
					tmpBiases.bias = this.shadowBias / farClip * 100;
					if (!this.device.webgl2 && this.device.extStandardDerivatives) tmpBiases.bias *= -100;
				}

				tmpBiases.normalBias = this._isVsm ? this.vsmBias / (farClip / 7.0) : this._normalOffsetBias;
				break;
		}

		return tmpBiases;
	}

	getColor() {
		return this._color;
	}

	getBoundingSphere(sphere) {
		if (this._type === LIGHTTYPE_SPOT) {
			const range = this.attenuationEnd;
			const angle = this._outerConeAngle;
			const f = Math.cos(angle * math.DEG_TO_RAD);
			const node = this._node;
			spotCenter.copy(node.up);
			spotCenter.mulScalar(-range * 0.5 * f);
			spotCenter.add(node.getPosition());
			sphere.center = spotCenter;
			spotEndPoint.copy(node.up);
			spotEndPoint.mulScalar(-range);
			tmpVec.copy(node.right);
			tmpVec.mulScalar(Math.sin(angle * math.DEG_TO_RAD) * range);
			spotEndPoint.add(tmpVec);
			sphere.radius = spotEndPoint.length() * 0.5;
		} else if (this._type === LIGHTTYPE_OMNI) {
			sphere.center = this._node.getPosition();
			sphere.radius = this.attenuationEnd;
		}
	}

	getBoundingBox(box) {
		if (this._type === LIGHTTYPE_SPOT) {
			const range = this.attenuationEnd;
			const angle = this._outerConeAngle;
			const node = this._node;
			const scl = Math.abs(Math.sin(angle * math.DEG_TO_RAD) * range);
			box.center.set(0, -range * 0.5, 0);
			box.halfExtents.set(scl, range * 0.5, scl);
			box.setFromTransformedAabb(box, node.getWorldTransform(), true);
		} else if (this._type === LIGHTTYPE_OMNI) {
			box.center.copy(this._node.getPosition());
			box.halfExtents.set(this.attenuationEnd, this.attenuationEnd, this.attenuationEnd);
		}
	}

	_updateFinalColor() {
		const color = this._color;
		const r = color.r;
		const g = color.g;
		const b = color.b;
		const i = this._intensity;
		const finalColor = this._finalColor;
		const linearFinalColor = this._linearFinalColor;
		finalColor[0] = r * i;
		finalColor[1] = g * i;
		finalColor[2] = b * i;

		if (i >= 1) {
			linearFinalColor[0] = Math.pow(r, 2.2) * i;
			linearFinalColor[1] = Math.pow(g, 2.2) * i;
			linearFinalColor[2] = Math.pow(b, 2.2) * i;
		} else {
			linearFinalColor[0] = Math.pow(finalColor[0], 2.2);
			linearFinalColor[1] = Math.pow(finalColor[1], 2.2);
			linearFinalColor[2] = Math.pow(finalColor[2], 2.2);
		}
	}

	setColor() {
		if (arguments.length === 1) {
			this._color.set(arguments[0].r, arguments[0].g, arguments[0].b);
		} else if (arguments.length === 3) {
			this._color.set(arguments[0], arguments[1], arguments[2]);
		}

		this._updateFinalColor();
	}

	updateShadow() {
		if (this.shadowUpdateMode !== SHADOWUPDATE_REALTIME) {
			this.shadowUpdateMode = SHADOWUPDATE_THISFRAME;
		}
	}

	layersDirty() {
		var _this$_scene;

		if ((_this$_scene = this._scene) != null && _this$_scene.layers) {
			this._scene.layers._dirtyLights = true;
		}
	}

	updateKey() {
		let key = this._type << 29 | (this._castShadows ? 1 : 0) << 28 | this._shadowType << 25 | this._falloffMode << 23 | (this._normalOffsetBias !== 0.0 ? 1 : 0) << 22 | (this._cookie ? 1 : 0) << 21 | (this._cookieFalloff ? 1 : 0) << 20 | chanId[this._cookieChannel.charAt(0)] << 18 | (this._cookieTransform ? 1 : 0) << 12 | this._shape << 10 | this.numCascades - 1 << 8;

		if (this._cookieChannel.length === 3) {
			key |= chanId[this._cookieChannel.charAt(1)] << 16;
			key |= chanId[this._cookieChannel.charAt(2)] << 14;
		}

		if (key !== this.key && this._scene !== null) {
			this.layersDirty();
		}

		this.key = key;
	}

}

class LightingParams {
	constructor(supportsAreaLights, maxTextureSize, dirtyLightsFnc) {
		this._maxTextureSize = maxTextureSize;
		this._supportsAreaLights = supportsAreaLights;
		this._dirtyLightsFnc = dirtyLightsFnc;
		this._areaLightsEnabled = false;
		this._cells = new Vec3(10, 3, 10);
		this._maxLightsPerCell = 255;
		this._shadowsEnabled = true;
		this._shadowType = SHADOW_PCF3;
		this._shadowAtlasResolution = 2048;
		this._cookiesEnabled = false;
		this._cookieAtlasResolution = 2048;
		this.atlasSplit = null;
		this.debugLayer = undefined;
	}

	set cells(value) {
		this._cells.copy(value);
	}

	get cells() {
		return this._cells;
	}

	set maxLightsPerCell(value) {
		this._maxLightsPerCell = math.clamp(value, 1, 255);
	}

	get maxLightsPerCell() {
		return this._maxLightsPerCell;
	}

	set cookieAtlasResolution(value) {
		this._cookieAtlasResolution = math.clamp(value, 32, this._maxTextureSize);
	}

	get cookieAtlasResolution() {
		return this._cookieAtlasResolution;
	}

	set shadowAtlasResolution(value) {
		this._shadowAtlasResolution = math.clamp(value, 32, this._maxTextureSize);
	}

	get shadowAtlasResolution() {
		return this._shadowAtlasResolution;
	}

	set shadowType(value) {
		if (this._shadowType !== value) {
			this._shadowType = value;

			this._dirtyLightsFnc();
		}
	}

	get shadowType() {
		return this._shadowType;
	}

	set cookiesEnabled(value) {
		if (this._cookiesEnabled !== value) {
			this._cookiesEnabled = value;

			this._dirtyLightsFnc();
		}
	}

	get cookiesEnabled() {
		return this._cookiesEnabled;
	}

	set areaLightsEnabled(value) {
		if (this._supportsAreaLights) {
			if (this._areaLightsEnabled !== value) {
				this._areaLightsEnabled = value;

				this._dirtyLightsFnc();
			}
		}
	}

	get areaLightsEnabled() {
		return this._areaLightsEnabled;
	}

	set shadowsEnabled(value) {
		if (this._shadowsEnabled !== value) {
			this._shadowsEnabled = value;

			this._dirtyLightsFnc();
		}
	}

	get shadowsEnabled() {
		return this._shadowsEnabled;
	}

}

const tempSphere = new BoundingSphere();

class BakeLight {
	constructor(scene, light) {
		this.scene = scene;
		this.light = light;
		this.store();
		light.numCascades = 1;

		if (light.type !== LIGHTTYPE_DIRECTIONAL) {
			light._node.getWorldTransform();

			light.getBoundingSphere(tempSphere);
			this.lightBounds = new BoundingBox();
			this.lightBounds.center.copy(tempSphere.center);
			this.lightBounds.halfExtents.set(tempSphere.radius, tempSphere.radius, tempSphere.radius);
		}
	}

	store() {
		this.mask = this.light.mask;
		this.shadowUpdateMode = this.light.shadowUpdateMode;
		this.enabled = this.light.enabled;
		this.intensity = this.light.intensity;
		this.rotation = this.light._node.getLocalRotation().clone();
		this.numCascades = this.light.numCascades;
	}

	restore() {
		const light = this.light;
		light.mask = this.mask;
		light.shadowUpdateMode = this.shadowUpdateMode;
		light.enabled = this.enabled;
		light.intensity = this.intensity;

		light._node.setLocalRotation(this.rotation);

		light.numCascades = this.numCascades;
	}

	startBake() {
		this.light.enabled = true;

		this.light._destroyShadowMap();
	}

	endBake(shadowMapCache) {
		const light = this.light;
		light.enabled = false;

		if (light.shadowMap) {
			if (light.shadowMap.cached) shadowMapCache.add(light, light.shadowMap);
			light.shadowMap = null;
		}
	}

}

const _tempPoint$1 = new Vec2();

class BakeLightSimple extends BakeLight {
	get numVirtualLights() {
		if (this.light.type === LIGHTTYPE_DIRECTIONAL) {
			return this.light.bakeNumSamples;
		}

		return 1;
	}

	prepareVirtualLight(index, numVirtualLights) {
		const light = this.light;

		light._node.setLocalRotation(this.rotation);

		if (index > 0) {
			const directionalSpreadAngle = light.bakeArea;
			random.circlePointDeterministic(_tempPoint$1, index, numVirtualLights);

			_tempPoint$1.mulScalar(directionalSpreadAngle * 0.5);

			light._node.rotateLocal(_tempPoint$1.x, 0, _tempPoint$1.y);
		}

		light._node.getWorldTransform();

		const gamma = this.scene.gammaCorrection ? 2.2 : 1;
		const linearIntensity = Math.pow(this.intensity, gamma);
		light.intensity = Math.pow(linearIntensity / numVirtualLights, 1 / gamma);
	}

}

class AreaLightLuts {
	static createTexture(device, format, size) {
		const tex = new Texture(device, {
			width: size,
			height: size,
			format: format,
			addressU: ADDRESS_CLAMP_TO_EDGE,
			addressV: ADDRESS_CLAMP_TO_EDGE,
			type: TEXTURETYPE_DEFAULT,
			magFilter: FILTER_LINEAR,
			minFilter: FILTER_NEAREST,
			anisotropy: 1
		});
		tex.name = 'AreaLightLUT';
		return tex;
	}

	static setUniforms(device, texture1, texture2) {
		device.scope.resolve('areaLightsLutTex1').setValue(texture1);
		device.scope.resolve('areaLightsLutTex2').setValue(texture2);
	}

	static createPlaceholder(device) {
		const texture = AreaLightLuts.createTexture(device, PIXELFORMAT_R8_G8_B8_A8, 2);
		const pixels = texture.lock();
		pixels.fill(0);
		texture.unlock();
		AreaLightLuts.setUniforms(device, texture, texture);
	}

	static set(device, resource) {
		function buildTexture(device, data, format) {
			const texture = AreaLightLuts.createTexture(device, format, 64);
			texture.lock().set(data);
			texture.unlock();
			texture.upload();
			return texture;
		}

		function offsetScale(data, offset, scale) {
			const count = data.length;
			const ret = new Float32Array(count);

			for (let i = 0; i < count; i++) {
				const n = i % 4;
				ret[i] = (data[i] + offset[n]) * scale[n];
			}

			return ret;
		}

		function convertToHalfFloat(data) {
			const count = data.length;
			const ret = new Uint16Array(count);
			const float2Half = FloatPacking.float2Half;

			for (let i = 0; i < count; i++) {
				ret[i] = float2Half(data[i]);
			}

			return ret;
		}

		function convertToUint(data) {
			const count = data.length;
			const ret = new Uint8ClampedArray(count);

			for (let i = 0; i < count; i++) {
				ret[i] = data[i] * 255;
			}

			return ret;
		}

		const versions = new Int16Array(resource, 0, 2);
		const majorVersion = versions[0];
		const minorVersion = versions[1];

		if (majorVersion !== 0 || minorVersion !== 1) ; else {
			const srcData1 = new Float32Array(resource, 4, 16384);
			const srcData2 = new Float32Array(resource, 4 + 16384 * 4, 16384);
			let data1, data2;
			const format = device.areaLightLutFormat;

			if (format === PIXELFORMAT_RGBA32F) {
				data1 = srcData1;
				data2 = srcData2;
			} else if (format === PIXELFORMAT_RGBA16F) {
				data1 = convertToHalfFloat(srcData1);
				data2 = convertToHalfFloat(srcData2);
			} else {
				const o1 = [0.0, 0.2976, 0.01381, 0.0];
				const s1 = [0.999, 3.08737, 1.6546, 0.603249];
				const o2 = [-0.306897, 0.0, 0.0, 0.0];
				const s2 = [1.442787, 1.0, 1.0, 1.0];
				data1 = convertToUint(offsetScale(srcData1, o1, s1));
				data2 = convertToUint(offsetScale(srcData2, o2, s2));
			}

			const tex1 = buildTexture(device, data1, format);
			const tex2 = buildTexture(device, data2, format);
			AreaLightLuts.setUniforms(device, tex1, tex2);
		}
	}

}

const _floatRounding = 0.2;

class Morph extends RefCountedObject {
	constructor(targets, graphicsDevice) {
		super();
		this.device = graphicsDevice || getApplication().graphicsDevice;
		this._targets = targets;

		if (this.device.supportsMorphTargetTexturesCore) {
			if (this.device.extTextureHalfFloat && this.device.textureHalfFloatRenderable) {
				this._renderTextureFormat = Morph.FORMAT_HALF_FLOAT;
			} else if (this.device.extTextureFloat && this.device.textureFloatRenderable) {
				this._renderTextureFormat = Morph.FORMAT_FLOAT;
			}

			if (this.device.extTextureHalfFloat && this.device.textureHalfFloatUpdatable) {
				this._textureFormat = Morph.FORMAT_HALF_FLOAT;
			} else if (this.device.extTextureFloat) {
				this._textureFormat = Morph.FORMAT_FLOAT;
			}

			if (this._renderTextureFormat !== undefined && this._textureFormat !== undefined) {
				this._useTextureMorph = true;
			}
		}

		this._init();

		this._updateMorphFlags();

		this._calculateAabb();
	}

	get morphPositions() {
		return this._morphPositions;
	}

	get morphNormals() {
		return this._morphNormals;
	}

	get maxActiveTargets() {
		if (this._useTextureMorph) return this._targets.length;
		return this._morphPositions && this._morphNormals ? 4 : 8;
	}

	get useTextureMorph() {
		return this._useTextureMorph;
	}

	_init() {
		if (this._useTextureMorph) {
			this._useTextureMorph = this._initTextureBased();
		}

		if (!this._useTextureMorph) {
			for (let i = 0; i < this._targets.length; i++) {
				this._targets[i]._initVertexBuffers(this.device);
			}
		}

		for (let i = 0; i < this._targets.length; i++) {
			this._targets[i]._postInit();
		}
	}

	_initTextureBased() {
		const deltaArrays = [],
					deltaInfos = [];

		for (let i = 0; i < this._targets.length; i++) {
			const target = this._targets[i];

			if (target.options.deltaPositions) {
				deltaArrays.push(target.options.deltaPositions);
				deltaInfos.push({
					target: target,
					name: 'texturePositions'
				});
			}

			if (target.options.deltaNormals) {
				deltaArrays.push(target.options.deltaNormals);
				deltaInfos.push({
					target: target,
					name: 'textureNormals'
				});
			}
		}

		const ids = [],
					usedDataIndices = [];
		let freeIndex = 1;
		const dataCount = deltaArrays[0].length;

		for (let v = 0; v < dataCount; v += 3) {
			let vertexUsed = false;

			for (let i = 0; i < deltaArrays.length; i++) {
				const data = deltaArrays[i];

				if (data[v] !== 0 || data[v + 1] !== 0 || data[v + 2] !== 0) {
					vertexUsed = true;
					break;
				}
			}

			if (vertexUsed) {
				ids.push(freeIndex + _floatRounding);
				usedDataIndices.push(v / 3);
				freeIndex++;
			} else {
				ids.push(0 + _floatRounding);
			}
		}

		const maxTextureSize = Math.min(this.device.maxTextureSize, 4096);
		let morphTextureWidth = Math.ceil(Math.sqrt(freeIndex));
		morphTextureWidth = Math.min(morphTextureWidth, maxTextureSize);
		const morphTextureHeight = Math.ceil(freeIndex / morphTextureWidth);

		if (morphTextureHeight > maxTextureSize) {
			return false;
		}

		this.morphTextureWidth = morphTextureWidth;
		this.morphTextureHeight = morphTextureHeight;
		let halfFloat = false;
		let numComponents = 3;
		const float2Half = FloatPacking.float2Half;

		if (this._textureFormat === Morph.FORMAT_HALF_FLOAT) {
			halfFloat = true;
			numComponents = 4;
		}

		const arraySize = this.morphTextureWidth * this.morphTextureHeight * numComponents;
		const packedDeltas = halfFloat ? new Uint16Array(arraySize) : new Float32Array(arraySize);

		for (let i = 0; i < deltaArrays.length; i++) {
			const data = deltaArrays[i];

			for (let v = 0; v < usedDataIndices.length; v++) {
				const index = usedDataIndices[v];

				if (halfFloat) {
					packedDeltas[v * numComponents + numComponents] = float2Half(data[index * 3]);
					packedDeltas[v * numComponents + numComponents + 1] = float2Half(data[index * 3 + 1]);
					packedDeltas[v * numComponents + numComponents + 2] = float2Half(data[index * 3 + 2]);
				} else {
					packedDeltas[v * numComponents + numComponents] = data[index * 3];
					packedDeltas[v * numComponents + numComponents + 1] = data[index * 3 + 1];
					packedDeltas[v * numComponents + numComponents + 2] = data[index * 3 + 2];
				}
			}

			const target = deltaInfos[i].target;
			const format = this._textureFormat === Morph.FORMAT_FLOAT ? PIXELFORMAT_RGB32F : PIXELFORMAT_RGBA16F;

			target._setTexture(deltaInfos[i].name, this._createTexture("MorphTarget", format, packedDeltas));
		}

		const formatDesc = [{
			semantic: SEMANTIC_ATTR15,
			components: 1,
			type: TYPE_FLOAT32
		}];
		this.vertexBufferIds = new VertexBuffer(this.device, new VertexFormat(this.device, formatDesc), ids.length, BUFFER_STATIC, new Float32Array(ids));
		return true;
	}

	destroy() {
		if (this.vertexBufferIds) {
			this.vertexBufferIds.destroy();
			this.vertexBufferIds = null;
		}

		for (let i = 0; i < this._targets.length; i++) {
			this._targets[i].destroy();
		}

		this._targets.length = 0;
	}

	get targets() {
		return this._targets;
	}

	_updateMorphFlags() {
		this._morphPositions = false;
		this._morphNormals = false;

		for (let i = 0; i < this._targets.length; i++) {
			const target = this._targets[i];

			if (target.morphPositions) {
				this._morphPositions = true;
			}

			if (target.morphNormals) {
				this._morphNormals = true;
			}
		}
	}

	_calculateAabb() {
		const min = new Vec3();
		const max = new Vec3();

		for (let i = 0; i < this._targets.length; i++) {
			const targetAabb = this._targets[i].aabb;
			min.min(targetAabb.getMin());
			max.max(targetAabb.getMax());
		}

		this.aabb = new BoundingBox();
		this.aabb.setMinMax(min, max);
	}

	_createTexture(name, format, pixelData) {
		const texture = new Texture(this.device, {
			width: this.morphTextureWidth,
			height: this.morphTextureHeight,
			format: format,
			cubemap: false,
			mipmaps: false,
			minFilter: FILTER_NEAREST,
			magFilter: FILTER_NEAREST,
			addressU: ADDRESS_CLAMP_TO_EDGE,
			addressV: ADDRESS_CLAMP_TO_EDGE
		});
		texture.name = name;

		if (pixelData) {
			texture.lock().set(pixelData);
			texture.unlock();
		}

		return texture;
	}

}

Morph.FORMAT_FLOAT = 0;
Morph.FORMAT_HALF_FLOAT = 1;

const textureMorphVertexShader = `
		attribute vec2 vertex_position;
		varying vec2 uv0;
		void main(void) {
				gl_Position = vec4(vertex_position, 0.5, 1.0);
				uv0 = vertex_position.xy * 0.5 + 0.5;
		}
		`;

class MorphInstance {
	constructor(morph) {
		this.morph = morph;
		morph.incRefCount();
		this.device = morph.device;
		this.meshInstance = null;
		this._weights = [];

		for (let v = 0; v < morph._targets.length; v++) {
			this.setWeight(v, morph._targets[v].defaultWeight);
		}

		this._activeTargets = [];

		if (morph.useTextureMorph) {
			this.shaderCache = {};
			this.maxSubmitCount = this.device.maxTextures;
			this._shaderMorphWeights = new Float32Array(this.maxSubmitCount);

			const createRT = (name, textureVar) => {
				const format = morph._renderTextureFormat === Morph.FORMAT_FLOAT ? PIXELFORMAT_RGBA32F : PIXELFORMAT_RGBA16F;
				this[textureVar] = morph._createTexture(name, format);
				return new RenderTarget({
					colorBuffer: this[textureVar],
					depth: false
				});
			};

			if (morph.morphPositions) {
				this.rtPositions = createRT("MorphRTPos", "texturePositions");
			}

			if (morph.morphNormals) {
				this.rtNormals = createRT("MorphRTNrm", "textureNormals");
			}

			this._textureParams = new Float32Array([morph.morphTextureWidth, morph.morphTextureHeight, 1 / morph.morphTextureWidth, 1 / morph.morphTextureHeight]);

			for (let i = 0; i < this.maxSubmitCount; i++) {
				this["morphBlendTex" + i] = this.device.scope.resolve("morphBlendTex" + i);
			}

			this.morphFactor = this.device.scope.resolve("morphFactor[0]");
			this.zeroTextures = false;
		} else {
			this.maxSubmitCount = 8;
			this._shaderMorphWeights = new Float32Array(this.maxSubmitCount);
			this._shaderMorphWeightsA = new Float32Array(this._shaderMorphWeights.buffer, 0, 4);
			this._shaderMorphWeightsB = new Float32Array(this._shaderMorphWeights.buffer, 4 * 4, 4);
			this._activeVertexBuffers = new Array(this.maxSubmitCount);
		}
	}

	destroy() {
		this.meshInstance = null;
		this.shader = null;
		const morph = this.morph;

		if (morph) {
			this.morph = null;
			morph.decRefCount();

			if (morph.refCount < 1) {
				morph.destroy();
			}
		}

		if (this.rtPositions) {
			this.rtPositions.destroy();
			this.rtPositions = null;
		}

		if (this.texturePositions) {
			this.texturePositions.destroy();
			this.texturePositions = null;
		}

		if (this.rtNormals) {
			this.rtNormals.destroy();
			this.rtNormals = null;
		}

		if (this.textureNormals) {
			this.textureNormals.destroy();
			this.textureNormals = null;
		}
	}

	clone() {
		const clone = new MorphInstance(this.morph);
		return clone;
	}

	getWeight(index) {
		return this._weights[index];
	}

	setWeight(index, weight) {
		this._weights[index] = weight;
		this._dirty = true;
	}

	_getFragmentShader(numTextures) {
		let fragmentShader = '';

		if (numTextures > 0) {
			fragmentShader += 'varying vec2 uv0;\n' + 'uniform highp float morphFactor[' + numTextures + '];\n';
		}

		for (let i = 0; i < numTextures; i++) {
			fragmentShader += 'uniform highp sampler2D morphBlendTex' + i + ';\n';
		}

		fragmentShader += 'void main (void) {\n' + '		highp vec4 color = vec4(0, 0, 0, 1);\n';

		for (let i = 0; i < numTextures; i++) {
			fragmentShader += '		color.xyz += morphFactor[' + i + '] * texture2D(morphBlendTex' + i + ', uv0).xyz;\n';
		}

		fragmentShader += '		gl_FragColor = color;\n' + '}\n';
		return fragmentShader;
	}

	_getShader(count) {
		let shader = this.shaderCache[count];

		if (!shader) {
			const fs = this._getFragmentShader(count);

			shader = createShaderFromCode(this.device, textureMorphVertexShader, fs, "textureMorph" + count);
			this.shaderCache[count] = shader;
		}

		return shader;
	}

	_updateTextureRenderTarget(renderTarget, srcTextureName) {
		const device = this.device;

		const submitBatch = (usedCount, blending) => {
			this.morphFactor.setValue(this._shaderMorphWeights);
			device.setBlending(blending);

			if (blending) {
				device.setBlendFunction(BLENDMODE_ONE, BLENDMODE_ONE);
				device.setBlendEquation(BLENDEQUATION_ADD);
			}

			const shader = this._getShader(usedCount);

			drawQuadWithShader(device, renderTarget, shader, undefined, undefined, blending);
		};

		let usedCount = 0;
		let blending = false;
		const count = this._activeTargets.length;

		for (let i = 0; i < count; i++) {
			const activeTarget = this._activeTargets[i];
			const tex = activeTarget.target[srcTextureName];

			if (tex) {
				this["morphBlendTex" + usedCount].setValue(tex);
				this._shaderMorphWeights[usedCount] = activeTarget.weight;
				usedCount++;

				if (usedCount >= this.maxSubmitCount) {
					submitBatch(usedCount, blending);
					usedCount = 0;
					blending = true;
				}
			}
		}

		if (usedCount > 0 || count === 0 && !this.zeroTextures) {
			submitBatch(usedCount, blending);
		}
	}

	_updateTextureMorph() {
		this.device;

		if (this._activeTargets.length > 0 || !this.zeroTextures) {
			this._updateTextureRenderTarget(this.rtPositions, 'texturePositions');

			this._updateTextureRenderTarget(this.rtNormals, 'textureNormals');

			this.zeroTextures = this._activeTargets.length === 0;
		}
	}

	_updateVertexMorph() {
		const count = this.maxSubmitCount;

		for (let i = 0; i < count; i++) {
			this._shaderMorphWeights[i] = 0;
			this._activeVertexBuffers[i] = null;
		}

		let posIndex = 0;
		let nrmIndex = this.morph.morphPositions ? 4 : 0;

		for (let i = 0; i < this._activeTargets.length; i++) {
			const target = this._activeTargets[i].target;

			if (target._vertexBufferPositions) {
				this._activeVertexBuffers[posIndex] = target._vertexBufferPositions;
				this._shaderMorphWeights[posIndex] = this._activeTargets[i].weight;
				posIndex++;
			}

			if (target._vertexBufferNormals) {
				this._activeVertexBuffers[nrmIndex] = target._vertexBufferNormals;
				this._shaderMorphWeights[nrmIndex] = this._activeTargets[i].weight;
				nrmIndex++;
			}
		}
	}

	update() {
		this._dirty = false;
		const targets = this.morph._targets;
		let activeCount = 0;
		const epsilon = 0.00001;

		for (let i = 0; i < targets.length; i++) {
			const absWeight = Math.abs(this.getWeight(i));

			if (absWeight > epsilon) {
				if (this._activeTargets.length <= activeCount) {
					this._activeTargets[activeCount] = {};
				}

				const activeTarget = this._activeTargets[activeCount++];
				activeTarget.absWeight = absWeight;
				activeTarget.weight = this.getWeight(i);
				activeTarget.target = targets[i];
			}
		}

		this._activeTargets.length = activeCount;
		const maxActiveTargets = this.morph.maxActiveTargets;

		if (this._activeTargets.length > maxActiveTargets) {
			this._activeTargets.sort(function (l, r) {
				return l.absWeight < r.absWeight ? 1 : r.absWeight < l.absWeight ? -1 : 0;
			});

			this._activeTargets.length = maxActiveTargets;
		}

		if (this.morph.useTextureMorph) {
			this._updateTextureMorph();
		} else {
			this._updateVertexMorph();
		}
	}

}

class Model {
	constructor() {
		this.graph = null;
		this.meshInstances = [];
		this.skinInstances = [];
		this.morphInstances = [];
		this.cameras = [];
		this.lights = [];
		this._shadersVersion = 0;
		this._immutable = false;
	}

	getGraph() {
		return this.graph;
	}

	setGraph(graph) {
		this.graph = graph;
	}

	getCameras() {
		return this.cameras;
	}

	setCameras(cameras) {
		this.cameras = cameras;
	}

	getLights() {
		return this.lights;
	}

	setLights(lights) {
		this.lights = lights;
	}

	getMaterials() {
		const materials = [];

		for (let i = 0; i < this.meshInstances.length; i++) {
			const meshInstance = this.meshInstances[i];

			if (materials.indexOf(meshInstance.material) === -1) {
				materials.push(meshInstance.material);
			}
		}

		return materials;
	}

	clone() {
		const srcNodes = [];
		const cloneNodes = [];

		const _duplicate = function _duplicate(node) {
			const newNode = node.clone();
			srcNodes.push(node);
			cloneNodes.push(newNode);

			for (let idx = 0; idx < node._children.length; idx++) {
				newNode.addChild(_duplicate(node._children[idx]));
			}

			return newNode;
		};

		const cloneGraph = _duplicate(this.graph);

		const cloneMeshInstances = [];
		const cloneSkinInstances = [];
		const cloneMorphInstances = [];

		for (let i = 0; i < this.skinInstances.length; i++) {
			const skin = this.skinInstances[i].skin;
			const cloneSkinInstance = new SkinInstance(skin);
			const bones = [];

			for (let j = 0; j < skin.boneNames.length; j++) {
				const boneName = skin.boneNames[j];
				const bone = cloneGraph.findByName(boneName);
				bones.push(bone);
			}

			cloneSkinInstance.bones = bones;
			cloneSkinInstances.push(cloneSkinInstance);
		}

		for (let i = 0; i < this.morphInstances.length; i++) {
			const morph = this.morphInstances[i].morph;
			const cloneMorphInstance = new MorphInstance(morph);
			cloneMorphInstances.push(cloneMorphInstance);
		}

		for (let i = 0; i < this.meshInstances.length; i++) {
			const meshInstance = this.meshInstances[i];
			const nodeIndex = srcNodes.indexOf(meshInstance.node);
			const cloneMeshInstance = new MeshInstance(meshInstance.mesh, meshInstance.material, cloneNodes[nodeIndex]);

			if (meshInstance.skinInstance) {
				const skinInstanceIndex = this.skinInstances.indexOf(meshInstance.skinInstance);
				cloneMeshInstance.skinInstance = cloneSkinInstances[skinInstanceIndex];
			}

			if (meshInstance.morphInstance) {
				const morphInstanceIndex = this.morphInstances.indexOf(meshInstance.morphInstance);
				cloneMeshInstance.morphInstance = cloneMorphInstances[morphInstanceIndex];
			}

			cloneMeshInstances.push(cloneMeshInstance);
		}

		const clone = new Model();
		clone.graph = cloneGraph;
		clone.meshInstances = cloneMeshInstances;
		clone.skinInstances = cloneSkinInstances;
		clone.morphInstances = cloneMorphInstances;
		clone.getGraph().syncHierarchy();
		return clone;
	}

	destroy() {
		const meshInstances = this.meshInstances;

		for (let i = 0; i < meshInstances.length; i++) {
			meshInstances[i].destroy();
		}

		this.meshInstances.length = 0;
	}

	generateWireframe() {
		MeshInstance._prepareRenderStyleForArray(this.meshInstances, RENDERSTYLE_WIREFRAME);
	}

}

const identityGraphNode = new GraphNode();
identityGraphNode.worldTransform = Mat4.IDENTITY;
identityGraphNode._dirtyWorld = identityGraphNode._dirtyNormal = false;

class ImmediateBatch {
	constructor(device, material, layer) {
		this.material = material;
		this.layer = layer;
		this.positions = [];
		this.colors = [];
		this.mesh = new Mesh(device);
		this.meshInstance = null;
	}

	addLines(positions, color) {
		const destPos = this.positions;
		const count = positions.length;

		for (let i = 0; i < count; i++) {
			const pos = positions[i];
			destPos.push(pos.x, pos.y, pos.z);
		}

		const destCol = this.colors;

		if (color.length) {
			for (let i = 0; i < count; i++) {
				const col = color[i];
				destCol.push(col.r, col.g, col.b, col.a);
			}
		} else {
			for (let i = 0; i < count; i++) {
				destCol.push(color.r, color.g, color.b, color.a);
			}
		}
	}

	addLinesArrays(positions, color) {
		this.positions.push(...positions);
		const destCol = this.colors;

		if (color.length) {
			destCol.push(...color);
		} else {
			const count = positions.length / 3;

			for (let i = 0; i < count; i++) {
				destCol.push(color.r, color.g, color.b, color.a);
			}
		}
	}

	onPreRender(visibleList, transparent) {
		if (this.positions.length > 0 && this.material.transparent === transparent) {
			this.mesh.setPositions(this.positions);
			this.mesh.setColors(this.colors);
			this.mesh.update(PRIMITIVE_LINES, false);

			if (!this.meshInstance) {
				this.meshInstance = new MeshInstance(this.mesh, this.material, identityGraphNode);
			}

			this.positions.length = 0;
			this.colors.length = 0;
			visibleList.list.push(this.meshInstance);
			visibleList.length++;
		}
	}

}

class ImmediateBatches {
	constructor(device) {
		this.device = device;
		this.map = new Map();
	}

	getBatch(material, layer) {
		let batch = this.map.get(material);

		if (!batch) {
			batch = new ImmediateBatch(this.device, material, layer);
			this.map.set(material, batch);
		}

		return batch;
	}

	onPreRender(visibleList, transparent) {
		this.map.forEach(batch => {
			batch.onPreRender(visibleList, transparent);
		});
	}

}

const tempPoints = [];

class Immediate {
	constructor(device) {
		this.device = device;
		this.quadMesh = null;
		this.textureShader = null;
		this.depthTextureShader = null;
		this.cubeLocalPos = null;
		this.cubeWorldPos = null;
		this.batchesMap = new Map();
		this.allBatches = new Set();
		this.updatedLayers = new Set();
		this._materialDepth = null;
		this._materialNoDepth = null;
		this.layerMeshInstances = new Map();
	}

	createMaterial(depthTest) {
		const material = new BasicMaterial();
		material.vertexColors = true;
		material.blend = true;
		material.blendType = BLEND_NORMAL;
		material.depthTest = depthTest;
		material.update();
		return material;
	}

	get materialDepth() {
		if (!this._materialDepth) {
			this._materialDepth = this.createMaterial(true);
		}

		return this._materialDepth;
	}

	get materialNoDepth() {
		if (!this._materialNoDepth) {
			this._materialNoDepth = this.createMaterial(false);
		}

		return this._materialNoDepth;
	}

	getBatch(layer, depthTest) {
		let batches = this.batchesMap.get(layer);

		if (!batches) {
			batches = new ImmediateBatches(this.device);
			this.batchesMap.set(layer, batches);
		}

		this.allBatches.add(batches);
		const material = depthTest ? this.materialDepth : this.materialNoDepth;
		return batches.getBatch(material, layer);
	}

	static getTextureVS() {
		return `
						attribute vec2 aPosition;
						uniform mat4 matrix_model;
						varying vec2 uv0;
						void main(void) {
								gl_Position = matrix_model * vec4(aPosition, 0, 1);
								uv0 = aPosition.xy + 0.5;
						}
				`;
	}

	getTextureShader() {
		if (!this.textureShader) {
			const shaderDefinition = {
				attributes: {
					aPosition: SEMANTIC_POSITION
				},
				vshader: Immediate.getTextureVS(),
				fshader: `
										precision lowp float;
										varying vec2 uv0;
										uniform sampler2D colorMap;
										void main (void) {
												gl_FragColor = vec4(texture2D(colorMap, uv0).xyz, 1);
										}
								`
			};
			this.textureShader = new Shader(this.device, shaderDefinition);
		}

		return this.textureShader;
	}

	getDepthTextureShader() {
		if (!this.depthTextureShader) {
			const gl2 = this.device.webgl2 ? "#define GL2" : "";
			const shaderDefinition = {
				attributes: {
					aPosition: SEMANTIC_POSITION
				},
				vshader: Immediate.getTextureVS(),
				fshader: `
										precision ${this.device.precision} float;
										${gl2}
										${shaderChunks.screenDepthPS}
										varying vec2 uv0;
										void main() {
												float depth = getLinearScreenDepth(uv0) * camera_params.x;
												gl_FragColor = vec4(vec3(depth), 1.0);
										}
										`
			};
			this.depthTextureShader = new Shader(this.device, shaderDefinition);
		}

		return this.depthTextureShader;
	}

	getQuadMesh() {
		if (!this.quadMesh) {
			this.quadMesh = new Mesh(this.device);
			this.quadMesh.setPositions([-0.5, -0.5, 0, 0.5, -0.5, 0, -0.5, 0.5, 0, 0.5, 0.5, 0]);
			this.quadMesh.update(PRIMITIVE_TRISTRIP);
		}

		return this.quadMesh;
	}

	drawMesh(material, matrix, mesh, meshInstance, layer) {
		if (!meshInstance) {
			const graphNode = this.getGraphNode(matrix);
			meshInstance = new MeshInstance(mesh, material, graphNode);
		}

		let layerMeshInstances = this.layerMeshInstances.get(layer);

		if (!layerMeshInstances) {
			layerMeshInstances = [];
			this.layerMeshInstances.set(layer, layerMeshInstances);
		}

		layerMeshInstances.push(meshInstance);
	}

	drawWireAlignedBox(min, max, color, depthTest, layer) {
		tempPoints.push(min.x, min.y, min.z, min.x, max.y, min.z, min.x, max.y, min.z, max.x, max.y, min.z, max.x, max.y, min.z, max.x, min.y, min.z, max.x, min.y, min.z, min.x, min.y, min.z, min.x, min.y, max.z, min.x, max.y, max.z, min.x, max.y, max.z, max.x, max.y, max.z, max.x, max.y, max.z, max.x, min.y, max.z, max.x, min.y, max.z, min.x, min.y, max.z, min.x, min.y, min.z, min.x, min.y, max.z, min.x, max.y, min.z, min.x, max.y, max.z, max.x, max.y, min.z, max.x, max.y, max.z, max.x, min.y, min.z, max.x, min.y, max.z);
		const batch = this.getBatch(layer, depthTest);
		batch.addLinesArrays(tempPoints, color);
		tempPoints.length = 0;
	}

	drawWireSphere(center, radius, color, numSegments, depthTest, layer) {
		const step = 2 * Math.PI / numSegments;
		let angle = 0;

		for (let i = 0; i < numSegments; i++) {
			const sin0 = Math.sin(angle);
			const cos0 = Math.cos(angle);
			angle += step;
			const sin1 = Math.sin(angle);
			const cos1 = Math.cos(angle);
			tempPoints.push(center.x + radius * sin0, center.y, center.z + radius * cos0);
			tempPoints.push(center.x + radius * sin1, center.y, center.z + radius * cos1);
			tempPoints.push(center.x + radius * sin0, center.y + radius * cos0, center.z);
			tempPoints.push(center.x + radius * sin1, center.y + radius * cos1, center.z);
			tempPoints.push(center.x, center.y + radius * sin0, center.z + radius * cos0);
			tempPoints.push(center.x, center.y + radius * sin1, center.z + radius * cos1);
		}

		const batch = this.getBatch(layer, depthTest);
		batch.addLinesArrays(tempPoints, color);
		tempPoints.length = 0;
	}

	getGraphNode(matrix) {
		const graphNode = new GraphNode();
		graphNode.worldTransform = matrix;
		graphNode._dirtyWorld = graphNode._dirtyNormal = false;
		return graphNode;
	}

	onPreRenderLayer(layer, visibleList, transparent) {
		this.batchesMap.forEach((batches, batchLayer) => {
			if (batchLayer === layer) {
				batches.onPreRender(visibleList, transparent);
			}
		});

		if (!this.updatedLayers.has(layer)) {
			this.updatedLayers.add(layer);
			const meshInstances = this.layerMeshInstances.get(layer);

			if (meshInstances) {
				for (let i = 0; i < meshInstances.length; i++) {
					visibleList.list[visibleList.length + i] = meshInstances[i];
				}

				visibleList.length += meshInstances.length;
				meshInstances.length = 0;
			}
		}
	}

	onPostRender() {
		this.allBatches.clear();
		this.updatedLayers.clear();
	}

}

class Scene extends EventHandler {
	constructor(graphicsDevice) {
		super();
		this.ambientBake = false;
		this.ambientBakeOcclusionBrightness = 0;
		this.ambientBakeOcclusionContrast = 0;
		this.ambientLight = new Color(0, 0, 0);
		this.exposure = 1;
		this.fogColor = new Color(0, 0, 0);
		this.fogDensity = 0;
		this.fogEnd = 1000;
		this.fogStart = 1;
		this.lightmapSizeMultiplier = 1;
		this.lightmapMaxResolution = 2048;
		this.lightmapMode = BAKE_COLORDIR;
		this.lightmapFilterEnabled = false;
		this.root = null;
		this.device = graphicsDevice || getApplication().graphicsDevice;
		this._gravity = new Vec3(0, -9.8, 0);
		this._layers = null;
		this._fog = FOG_NONE;
		this._gammaCorrection = GAMMA_SRGB;
		this._toneMapping = 0;
		this._skyboxCubeMap = null;
		this._prefilteredCubemaps = [null, null, null, null, null, null];
		this._envAtlas = null;
		this._internalEnvAtlas = null;
		this.skyboxModel = null;
		this._skyboxIntensity = 1;
		this._skyboxMip = 0;
		this._skyboxRotation = new Quat();
		this._skyboxRotationMat3 = null;
		this._skyboxRotationMat4 = null;
		this._ambientBakeNumSamples = 1;
		this._ambientBakeSpherePart = 0.4;
		this._lightmapFilterRange = 10;
		this._lightmapFilterSmoothness = 0.2;
		this._clusteredLightingEnabled = false;
		this._lightingParams = new LightingParams(this.device.supportsAreaLights, this.device.maxTextureSize, () => {
			this._layers._dirtyLights = true;
		});
		this._stats = {
			meshInstances: 0,
			lights: 0,
			dynamicLights: 0,
			bakedLights: 0,
			lastStaticPrepareFullTime: 0,
			lastStaticPrepareSearchTime: 0,
			lastStaticPrepareWriteTime: 0,
			lastStaticPrepareTriAabbTime: 0,
			lastStaticPrepareCombineTime: 0,
			updateShadersTime: 0
		};
		this.updateShaders = true;
		this._shaderVersion = 0;
		this._statsUpdated = false;
		this._models = [];
		this.immediate = new Immediate(this.device);
	}

	get defaultDrawLayer() {
		return this.layers.getLayerById(LAYERID_IMMEDIATE);
	}

	set ambientBakeNumSamples(value) {
		this._ambientBakeNumSamples = math.clamp(Math.floor(value), 1, 255);
	}

	get ambientBakeNumSamples() {
		return this._ambientBakeNumSamples;
	}

	set ambientBakeSpherePart(value) {
		this._ambientBakeSpherePart = math.clamp(value, 0.001, 1);
	}

	get ambientBakeSpherePart() {
		return this._ambientBakeSpherePart;
	}

	set clusteredLightingEnabled(value) {
		if (this._clusteredLightingEnabled && !value) {
			console.error("Turning off enabled clustered lighting is not currently supported");
			return;
		}

		this._clusteredLightingEnabled = value;
	}

	get clusteredLightingEnabled() {
		return this._clusteredLightingEnabled;
	}

	set drawCalls(value) {}

	get drawCalls() {
		let drawCalls = this.layers._meshInstances;

		if (!drawCalls.length) {
			this.layers._update(this.device, this.clusteredLightingEnabled);

			drawCalls = this.layers._meshInstances;
		}

		return drawCalls;
	}

	set envAtlas(value) {
		if (value !== this._envAtlas) {
			this._envAtlas = value;
			this.updateShaders = true;
		}
	}

	get envAtlas() {
		return this._envAtlas;
	}

	set fog(type) {
		if (type !== this._fog) {
			this._fog = type;
			this.updateShaders = true;
		}
	}

	get fog() {
		return this._fog;
	}

	set gammaCorrection(value) {
		if (value !== this._gammaCorrection) {
			this._gammaCorrection = value;
			this.updateShaders = true;
		}
	}

	get gammaCorrection() {
		return this._gammaCorrection;
	}

	set layers(layers) {
		const prev = this._layers;
		this._layers = layers;
		this.fire("set:layers", prev, layers);
	}

	get layers() {
		return this._layers;
	}

	get lighting() {
		return this._lightingParams;
	}

	set lightmapFilterRange(value) {
		this._lightmapFilterRange = Math.max(value, 0.001);
	}

	get lightmapFilterRange() {
		return this._lightmapFilterRange;
	}

	set lightmapFilterSmoothness(value) {
		this._lightmapFilterSmoothness = Math.max(value, 0.001);
	}

	get lightmapFilterSmoothness() {
		return this._lightmapFilterSmoothness;
	}

	set prefilteredCubemaps(value) {
		const cubemaps = this._prefilteredCubemaps;
		value = value || [];
		let changed = false;
		let complete = true;

		for (let i = 0; i < 6; ++i) {
			const v = value[i] || null;

			if (cubemaps[i] !== v) {
				cubemaps[i] = v;
				changed = true;
			}

			complete = complete && !!cubemaps[i];
		}

		if (changed) {
			this._resetSkyboxModel();

			if (complete) {
				this._internalEnvAtlas = EnvLighting.generatePrefilteredAtlas(cubemaps, {
					target: this._internalEnvAtlas
				});

				if (!this._envAtlas) {
					this.envAtlas = this._internalEnvAtlas;
				}
			} else if (this._internalEnvAtlas) {
				if (this._envAtlas === this._internalEnvAtlas) {
					this.envAtlas = null;
				}

				this._internalEnvAtlas.destroy();

				this._internalEnvAtlas = null;
			}
		}
	}

	get prefilteredCubemaps() {
		return this._prefilteredCubemaps;
	}

	set skybox(value) {
		if (value !== this._skyboxCubeMap) {
			this._skyboxCubeMap = value;

			this._resetSkyboxModel();
		}
	}

	get skybox() {
		return this._skyboxCubeMap;
	}

	set skyboxIntensity(value) {
		if (value !== this._skyboxIntensity) {
			this._skyboxIntensity = value;

			this._resetSkyboxModel();
		}
	}

	get skyboxIntensity() {
		return this._skyboxIntensity;
	}

	set skyboxMip(value) {
		if (value !== this._skyboxMip) {
			this._skyboxMip = value;

			this._resetSkyboxModel();
		}
	}

	get skyboxMip() {
		return this._skyboxMip;
	}

	set skyboxRotation(value) {
		if (!this._skyboxRotation.equals(value)) {
			this._skyboxRotation.copy(value);

			this._resetSkyboxModel();
		}
	}

	get skyboxRotation() {
		return this._skyboxRotation;
	}

	set toneMapping(value) {
		if (value !== this._toneMapping) {
			this._toneMapping = value;
			this.updateShaders = true;
		}
	}

	get toneMapping() {
		return this._toneMapping;
	}

	destroy() {
		this._resetSkyboxModel();

		this.root = null;
		this.off();
	}

	drawLine(start, end, color = Color.WHITE, depthTest = true, layer = this.defaultDrawLayer) {
		const batch = this.immediate.getBatch(layer, depthTest);
		batch.addLines([start, end], [color, color]);
	}

	drawLines(positions, colors, depthTest = true, layer = this.defaultDrawLayer) {
		const batch = this.immediate.getBatch(layer, depthTest);
		batch.addLines(positions, colors);
	}

	drawLineArrays(positions, colors, depthTest = true, layer = this.defaultDrawLayer) {
		const batch = this.immediate.getBatch(layer, depthTest);
		batch.addLinesArrays(positions, colors);
	}

	applySettings(settings) {
		const physics = settings.physics;
		const render = settings.render;

		this._gravity.set(physics.gravity[0], physics.gravity[1], physics.gravity[2]);

		this.ambientLight.set(render.global_ambient[0], render.global_ambient[1], render.global_ambient[2]);
		this._fog = render.fog;
		this.fogColor.set(render.fog_color[0], render.fog_color[1], render.fog_color[2]);
		this.fogStart = render.fog_start;
		this.fogEnd = render.fog_end;
		this.fogDensity = render.fog_density;
		this._gammaCorrection = render.gamma_correction;
		this._toneMapping = render.tonemapping;
		this.lightmapSizeMultiplier = render.lightmapSizeMultiplier;
		this.lightmapMaxResolution = render.lightmapMaxResolution;
		this.lightmapMode = render.lightmapMode;
		this.exposure = render.exposure;
		this._skyboxIntensity = render.skyboxIntensity === undefined ? 1 : render.skyboxIntensity;
		this._skyboxMip = render.skyboxMip === undefined ? 0 : render.skyboxMip;

		if (render.skyboxRotation) {
			this._skyboxRotation.setFromEulerAngles(render.skyboxRotation[0], render.skyboxRotation[1], render.skyboxRotation[2]);
		}

		['lightmapFilterEnabled', 'lightmapFilterRange', 'lightmapFilterSmoothness', 'ambientBake', 'ambientBakeNumSamples', 'ambientBakeSpherePart', 'ambientBakeOcclusionBrightness', 'ambientBakeOcclusionContrast'].forEach(setting => {
			if (render.hasOwnProperty(setting)) {
				this[setting] = render[setting];
			}
		});

		this._resetSkyboxModel();
	}

	_getSkyboxTex() {
		const cubemaps = this._prefilteredCubemaps;

		if (this._skyboxMip) {
			const skyboxMapping = [0, 1, 3, 4, 5, 6];
			return cubemaps[skyboxMapping[this._skyboxMip]] || this._envAtlas || cubemaps[0] || this._skyboxCubeMap;
		}

		return this._skyboxCubeMap || cubemaps[0] || this._envAtlas;
	}

	_updateSkybox(device) {
		if (this.skyboxModel) {
			return;
		}

		const skyboxTex = this._getSkyboxTex();

		if (!skyboxTex) {
			return;
		}

		const material = new Material();
		const scene = this;

		material.updateShader = function (dev, sc, defs, staticLightList, pass) {
			const library = device.getProgramLibrary();

			if (skyboxTex.cubemap) {
				this.shader = library.getProgram('skybox', {
					type: 'cubemap',
					rgbm: skyboxTex.type === TEXTURETYPE_RGBM,
					hdr: skyboxTex.type === TEXTURETYPE_RGBM || skyboxTex.format === PIXELFORMAT_RGBA32F,
					useIntensity: scene.skyboxIntensity !== 1,
					mip: skyboxTex.fixCubemapSeams ? scene.skyboxMip : 0,
					fixSeams: skyboxTex.fixCubemapSeams,
					gamma: pass === SHADER_FORWARDHDR ? scene.gammaCorrection ? GAMMA_SRGBHDR : GAMMA_NONE : scene.gammaCorrection,
					toneMapping: pass === SHADER_FORWARDHDR ? TONEMAP_LINEAR : scene.toneMapping
				});
			} else {
				this.shader = library.getProgram('skybox', {
					type: 'envAtlas',
					encoding: skyboxTex.encoding,
					useIntensity: scene.skyboxIntensity !== 1,
					gamma: pass === SHADER_FORWARDHDR ? scene.gammaCorrection ? GAMMA_SRGBHDR : GAMMA_NONE : scene.gammaCorrection,
					toneMapping: pass === SHADER_FORWARDHDR ? TONEMAP_LINEAR : scene.toneMapping
				});
			}
		};

		material.updateShader();

		if (skyboxTex.cubemap) {
			material.setParameter("texture_cubeMap", skyboxTex);
		} else {
			material.setParameter("texture_envAtlas", skyboxTex);
			material.setParameter("mipLevel", this._skyboxMip);
		}

		if (!this.skyboxRotation.equals(Quat.IDENTITY)) {
			if (!this._skyboxRotationMat4) this._skyboxRotationMat4 = new Mat4();
			if (!this._skyboxRotationMat3) this._skyboxRotationMat3 = new Mat3();

			this._skyboxRotationMat4.setTRS(Vec3.ZERO, this._skyboxRotation, Vec3.ONE);

			this._skyboxRotationMat4.invertTo3x3(this._skyboxRotationMat3);

			material.setParameter("cubeMapRotationMatrix", this._skyboxRotationMat3.data);
		} else {
			material.setParameter("cubeMapRotationMatrix", Mat3.IDENTITY.data);
		}

		material.cull = CULLFACE_FRONT;
		material.depthWrite = false;
		const skyLayer = this.layers.getLayerById(LAYERID_SKYBOX);

		if (skyLayer) {
			const node = new GraphNode("Skybox");
			const mesh = createBox(device);
			const meshInstance = new MeshInstance(mesh, material, node);
			meshInstance.cull = false;
			meshInstance._noDepthDrawGl1 = true;
			meshInstance.pick = false;
			const model = new Model();
			model.graph = node;
			model.meshInstances = [meshInstance];
			this.skyboxModel = model;
			skyLayer.addMeshInstances(model.meshInstances);
			this.skyLayer = skyLayer;
			this.fire("set:skybox", skyboxTex);
		}
	}

	_resetSkyboxModel() {
		if (this.skyboxModel) {
			this.skyLayer.removeMeshInstances(this.skyboxModel.meshInstances);
			this.skyboxModel.destroy();
		}

		this.skyboxModel = null;
		this.updateShaders = true;
	}

	setSkybox(cubemaps) {
		if (!cubemaps) {
			this.skybox = null;
			this.prefilteredCubemaps = [null, null, null, null, null, null];
		} else {
			this.skybox = cubemaps[0] || null;
			this.prefilteredCubemaps = cubemaps.slice(1);
		}
	}

	addModel(model) {
		if (this.containsModel(model)) return;
		const layer = this.layers.getLayerById(LAYERID_WORLD);
		if (!layer) return;
		layer.addMeshInstances(model.meshInstances);

		this._models.push(model);
	}

	addShadowCaster(model) {
		const layer = this.layers.getLayerById(LAYERID_WORLD);
		if (!layer) return;
		layer.addShadowCasters(model.meshInstances);
	}

	removeModel(model) {
		const index = this._models.indexOf(model);

		if (index !== -1) {
			const layer = this.layers.getLayerById(LAYERID_WORLD);
			if (!layer) return;
			layer.removeMeshInstances(model.meshInstances);

			this._models.splice(index, 1);
		}
	}

	removeShadowCasters(model) {
		const layer = this.layers.getLayerById(LAYERID_WORLD);
		if (!layer) return;
		layer.removeShadowCasters(model.meshInstances);
	}

	containsModel(model) {
		return this._models.indexOf(model) >= 0;
	}

	getModels(model) {
		return this._models;
	}

}

function hasAudioContext() {
	return !!(typeof AudioContext !== 'undefined' || typeof webkitAudioContext !== 'undefined');
}

class Channel {
	constructor(manager, sound, options = {}) {
		this.volume = options.volume === undefined ? 1 : options.volume;
		this.loop = options.loop === undefined ? false : options.loop;
		this.pitch = options.pitch === undefined ? 1 : options.pitch;
		this.sound = sound;
		this.paused = false;
		this.suspended = false;
		this.manager = manager;
		this.source = null;

		if (hasAudioContext()) {
			this.startTime = 0;
			this.startOffset = 0;
			const context = manager.context;
			this.gain = context.createGain();
		} else if (sound.audio) {
			this.source = sound.audio.cloneNode(false);
			this.source.pause();
		}
	}

	getVolume() {
		return this.volume;
	}

	getLoop() {
		return this.loop;
	}

	setLoop(loop) {
		this.loop = loop;

		if (this.source) {
			this.source.loop = loop;
		}
	}

	getPitch() {
		return this.pitch;
	}

	onManagerVolumeChange() {
		this.setVolume(this.getVolume());
	}

	onManagerSuspend() {
		if (this.isPlaying() && !this.suspended) {
			this.suspended = true;
			this.pause();
		}
	}

	onManagerResume() {
		if (this.suspended) {
			this.suspended = false;
			this.unpause();
		}
	}

	play() {
		if (this.source) {
			throw new Error('Call stop() before calling play()');
		}

		this._createSource();

		if (!this.source) {
			return;
		}

		this.startTime = this.manager.context.currentTime;
		this.source.start(0, this.startOffset % this.source.buffer.duration);
		this.setVolume(this.volume);
		this.setLoop(this.loop);
		this.setPitch(this.pitch);
		this.manager.on('volumechange', this.onManagerVolumeChange, this);
		this.manager.on('suspend', this.onManagerSuspend, this);
		this.manager.on('resume', this.onManagerResume, this);
		if (this.manager.suspended) this.onManagerSuspend();
	}

	pause() {
		if (this.source) {
			this.paused = true;
			this.startOffset += this.manager.context.currentTime - this.startTime;
			this.source.stop(0);
			this.source = null;
		}
	}

	unpause() {
		if (this.source || !this.paused) {
			console.warn('Call pause() before unpausing.');
			return;
		}

		this._createSource();

		if (!this.source) {
			return;
		}

		this.startTime = this.manager.context.currentTime;
		this.source.start(0, this.startOffset % this.source.buffer.duration);
		this.setVolume(this.volume);
		this.setLoop(this.loop);
		this.setPitch(this.pitch);
		this.paused = false;
	}

	stop() {
		if (this.source) {
			this.source.stop(0);
			this.source = null;
		}

		this.manager.off('volumechange', this.onManagerVolumeChange, this);
		this.manager.off('suspend', this.onManagerSuspend, this);
		this.manager.off('resume', this.onManagerResume, this);
	}

	setVolume(volume) {
		volume = math.clamp(volume, 0, 1);
		this.volume = volume;

		if (this.gain) {
			this.gain.gain.value = volume * this.manager.volume;
		}
	}

	setPitch(pitch) {
		this.pitch = pitch;

		if (this.source) {
			this.source.playbackRate.value = pitch;
		}
	}

	isPlaying() {
		return !this.paused && this.source.playbackState === this.source.PLAYING_STATE;
	}

	getDuration() {
		return this.source ? this.source.buffer.duration : 0;
	}

	_createSource() {
		const context = this.manager.context;

		if (this.sound.buffer) {
			this.source = context.createBufferSource();
			this.source.buffer = this.sound.buffer;
			this.source.connect(this.gain);
			this.gain.connect(context.destination);

			if (!this.loop) {
				this.source.onended = this.pause.bind(this);
			}
		}
	}

}

if (!hasAudioContext()) {
	Object.assign(Channel.prototype, {
		play: function () {
			if (this.source) {
				this.paused = false;
				this.setVolume(this.volume);
				this.setLoop(this.loop);
				this.setPitch(this.pitch);
				this.source.play();
			}

			this.manager.on('volumechange', this.onManagerVolumeChange, this);
			this.manager.on('suspend', this.onManagerSuspend, this);
			this.manager.on('resume', this.onManagerResume, this);
			if (this.manager.suspended) this.onManagerSuspend();
		},
		pause: function () {
			if (this.source) {
				this.paused = true;
				this.source.pause();
			}
		},
		unpause: function () {
			if (this.source) {
				this.paused = false;
				this.source.play();
			}
		},
		stop: function () {
			if (this.source) {
				this.source.pause();
			}

			this.manager.off('volumechange', this.onManagerVolumeChange, this);
			this.manager.off('suspend', this.onManagerSuspend, this);
			this.manager.off('resume', this.onManagerResume, this);
		},
		setVolume: function (volume) {
			volume = math.clamp(volume, 0, 1);
			this.volume = volume;

			if (this.source) {
				this.source.volume = volume * this.manager.volume;
			}
		},
		setPitch: function (pitch) {
			this.pitch = pitch;

			if (this.source) {
				this.source.playbackRate = pitch;
			}
		},
		getDuration: function () {
			return this.source && !isNaN(this.source.duration) ? this.source.duration : 0;
		},
		isPlaying: function () {
			return !this.source.paused;
		}
	});
}

const DISTANCE_LINEAR = 'linear';
const DISTANCE_INVERSE = 'inverse';
const DISTANCE_EXPONENTIAL = 'exponential';

const MAX_DISTANCE$1 = 10000;

class Channel3d extends Channel {
	constructor(manager, sound, options) {
		super(manager, sound, options);
		this.position = new Vec3();
		this.velocity = new Vec3();

		if (hasAudioContext()) {
			this.panner = manager.context.createPanner();
		} else {
			this.maxDistance = MAX_DISTANCE$1;
			this.minDistance = 1;
			this.rollOffFactor = 1;
			this.distanceModel = DISTANCE_INVERSE;
		}
	}

	getPosition() {
		return this.position;
	}

	getVelocity() {
		return this.velocity;
	}

	setPosition(position) {
		this.position.copy(position);
		this.panner.positionX.value = position.x;
		this.panner.positionY.value = position.y;
		this.panner.positionZ.value = position.z;
	}

	setVelocity(velocity) {
		this.velocity.copy(velocity);
		this.panner.setVelocity(velocity.x, velocity.y, velocity.z);
	}

	getMaxDistance() {
		return this.panner.maxDistance;
	}

	setMaxDistance(max) {
		this.panner.maxDistance = max;
	}

	getMinDistance() {
		return this.panner.refDistance;
	}

	setMinDistance(min) {
		this.panner.refDistance = min;
	}

	getRollOffFactor() {
		return this.panner.rolloffFactor;
	}

	setRollOffFactor(factor) {
		this.panner.rolloffFactor = factor;
	}

	getDistanceModel() {
		return this.panner.distanceModel;
	}

	setDistanceModel(distanceModel) {
		this.panner.distanceModel = distanceModel;
	}

	_createSource() {
		const context = this.manager.context;
		this.source = context.createBufferSource();
		this.source.buffer = this.sound.buffer;
		this.source.connect(this.panner);
		this.panner.connect(this.gain);
		this.gain.connect(context.destination);

		if (!this.loop) {
			this.source.onended = this.pause.bind(this);
		}
	}

}

if (!hasAudioContext()) {
	let offset = new Vec3();

	const fallOff = function fallOff(posOne, posTwo, refDistance, maxDistance, rolloffFactor, distanceModel) {
		offset = offset.sub2(posOne, posTwo);
		const distance = offset.length();

		if (distance < refDistance) {
			return 1;
		} else if (distance > maxDistance) {
			return 0;
		}

		let result = 0;

		if (distanceModel === DISTANCE_LINEAR) {
			result = 1 - rolloffFactor * (distance - refDistance) / (maxDistance - refDistance);
		} else if (distanceModel === DISTANCE_INVERSE) {
			result = refDistance / (refDistance + rolloffFactor * (distance - refDistance));
		} else if (distanceModel === DISTANCE_EXPONENTIAL) {
			result = Math.pow(distance / refDistance, -rolloffFactor);
		}

		return math.clamp(result, 0, 1);
	};

	Object.assign(Channel3d.prototype, {
		setPosition: function (position) {
			this.position.copy(position);

			if (this.source) {
				const listener = this.manager.listener;
				const lpos = listener.getPosition();
				const factor = fallOff(lpos, this.position, this.minDistance, this.maxDistance, this.rollOffFactor, this.distanceModel);
				const v = this.getVolume();
				this.source.volume = v * factor;
			}
		},
		setVelocity: function (velocity) {
			this.velocity.copy(velocity);
		},
		getMaxDistance: function () {
			return this.maxDistance;
		},
		setMaxDistance: function (max) {
			this.maxDistance = max;
		},
		getMinDistance: function () {
			return this.minDistance;
		},
		setMinDistance: function (min) {
			this.minDistance = min;
		},
		getRollOffFactor: function () {
			return this.rollOffFactor;
		},
		setRollOffFactor: function (factor) {
			this.rollOffFactor = factor;
		},
		getDistanceModel: function () {
			return this.distanceModel;
		},
		setDistanceModel: function (distanceModel) {
			this.distanceModel = distanceModel;
		}
	});
}

class Listener {
	constructor(manager) {
		this._manager = manager;
		this.position = new Vec3();
		this.velocity = new Vec3();
		this.orientation = new Mat4();
	}

	getPosition() {
		return this.position;
	}

	setPosition(position) {
		this.position.copy(position);
		const listener = this.listener;

		if (listener) {
			listener.positionX.value = position.x;
			listener.positionY.value = position.y;
			listener.positionZ.value = position.z;
		}
	}

	getVelocity() {
		return this.velocity;
	}

	setVelocity(velocity) {
		this.velocity.copy(velocity);
		const listener = this.listener;

		if (listener) {
			listener.positionX.value = velocity.x;
			listener.positionY.value = velocity.y;
			listener.positionZ.value = velocity.z;
		}
	}

	setOrientation(orientation) {
		this.orientation.copy(orientation);
		const listener = this.listener;

		if (listener) {
			const m = orientation.data;
			listener.forwardX.value = -m[8];
			listener.forwardY.value = -m[9];
			listener.forwardZ.value = -m[10];
			listener.upX.value = m[4];
			listener.upY.value = m[5];
			listener.upZ.value = m[6];
		}
	}

	getOrientation() {
		return this.orientation;
	}

	get listener() {
		const context = this._manager.context;
		return context ? context.listener : null;
	}

}

const CONTEXT_STATE_NOT_CREATED = 'not created';
const CONTEXT_STATE_RUNNING = 'running';
const CONTEXT_STATE_SUSPENDED = 'suspended';
const CONTEXT_STATE_INTERRUPTED = 'interrupted';
const USER_INPUT_EVENTS = ['click', 'contextmenu', 'auxclick', 'dblclick', 'mousedown', 'mouseup', 'pointerup', 'touchend', 'keydown', 'keyup'];

class SoundManager extends EventHandler {
	constructor(options) {
		super();
		this._context = null;
		this._state = CONTEXT_STATE_NOT_CREATED;
		this._forceWebAudioApi = options.forceWebAudioApi;
		this._resumeContext = null;
		this._resumeContextAttached = false;
		this._unlock = null;
		this._unlockAttached = false;

		if (hasAudioContext() || this._forceWebAudioApi) {
			this._addAudioContextUserInteractionListeners();
		} else {
			console.warn('No support for 3D audio found');
		}

		this.listener = new Listener(this);
		this._volume = 1;
		this.suspended = false;
	}

	set volume(volume) {
		volume = math.clamp(volume, 0, 1);
		this._volume = volume;
		this.fire('volumechange', volume);
	}

	get volume() {
		return this._volume;
	}

	get context() {
		if (!this._context) {
			if (hasAudioContext() || this._forceWebAudioApi) {
				if (typeof AudioContext !== 'undefined') {
					this._context = new AudioContext();
				} else if (typeof webkitAudioContext !== 'undefined') {
					this._context = new webkitAudioContext();
				}

				if (this._context) {
					this._state = this._context.state;

					this._context.onstatechange = () => {
						if (!this._context) return;

						if (this._state === CONTEXT_STATE_INTERRUPTED || this._state === CONTEXT_STATE_SUSPENDED) {
							this._safelyResumeContext();
						}

						this._state = this._context.state;
					};
				}
			}
		}

		return this._context;
	}

	suspend() {
		this.suspended = true;
		this.fire('suspend');
	}

	resume() {
		this.suspended = false;
		this.fire('resume');

		if (this.context && (this._state === CONTEXT_STATE_INTERRUPTED || this._state === CONTEXT_STATE_SUSPENDED)) {
			this._safelyResumeContext();
		}
	}

	destroy() {
		if (this._resumeContext && this._resumeContextAttached) {
			USER_INPUT_EVENTS.forEach(eventName => {
				window.removeEventListener(eventName, this._resumeContext);
			});
		}

		if (this._unlock && this._unlockAttached) {
			window.removeEventListener('touchend', this._unlock);
		}

		this.fire('destroy');

		if (this._context && this._context.close) {
			this._context.close();

			this._context = null;
		}
	}

	playSound(sound, options = {}) {
		let channel = null;

		if (Channel) {
			channel = new Channel(this, sound, options);
			channel.play();
		}

		return channel;
	}

	playSound3d(sound, position, options = {}) {
		let channel = null;

		if (Channel3d) {
			channel = new Channel3d(this, sound, options);
			channel.setPosition(position);

			if (options.volume) {
				channel.setVolume(options.volume);
			}

			if (options.loop) {
				channel.setLoop(options.loop);
			}

			if (options.maxDistance) {
				channel.setMaxDistance(options.maxDistance);
			}

			if (options.minDistance) {
				channel.setMinDistance(options.minDistance);
			}

			if (options.rollOffFactor) {
				channel.setRollOffFactor(options.rollOffFactor);
			}

			if (options.distanceModel) {
				channel.setDistanceModel(options.distanceModel);
			}

			channel.play();
		}

		return channel;
	}

	_safelyResumeContext() {
		if (!this._context) return;

		this._context.resume().then(() => {
			if (this._context.state !== CONTEXT_STATE_RUNNING) {
				this._addAudioContextUserInteractionListeners();
			}
		}).catch(() => {
			this._addAudioContextUserInteractionListeners();
		});
	}

	_addAudioContextUserInteractionListeners() {
		if (!this._resumeContext) {
			this._resumeContext = () => {
				if (!this.context || this.context.state === CONTEXT_STATE_RUNNING) {
					USER_INPUT_EVENTS.forEach(eventName => {
						window.removeEventListener(eventName, this._resumeContext);
					});
					this._resumeContextAttached = false;
				} else {
					this.context.resume();
				}
			};
		}

		if (!this._resumeContextAttached) {
			USER_INPUT_EVENTS.forEach(eventName => {
				window.addEventListener(eventName, this._resumeContext);
			});
			this._resumeContextAttached = true;
		}

		if (platform.ios) {
			if (!this._unlock) {
				this._unlock = () => {
					window.removeEventListener('touchend', this._unlock);
					this._unlockAttached = false;
					const context = this.context;

					if (context) {
						const buffer = context.createBuffer(1, 1, 44100);
						const source = context.createBufferSource();
						source.buffer = buffer;
						source.connect(context.destination);
						source.start(0);
						source.disconnect();
					}
				};
			}

			if (!this._unlockAttached) {
				window.addEventListener('touchend', this._unlock);
				this._unlockAttached = true;
			}
		}
	}

}

class Key {
	constructor(time, position, rotation, scale) {
		this.time = time;
		this.position = position;
		this.rotation = rotation;
		this.scale = scale;
	}

}

class Node {
	constructor() {
		this._name = "";
		this._keys = [];
	}

}

class Animation {
	constructor() {
		this.name = '';
		this.duration = 0;
		this._nodes = [];
		this._nodeDict = {};
	}

	getNode(name) {
		return this._nodeDict[name];
	}

	addNode(node) {
		this._nodes.push(node);

		this._nodeDict[node._name] = node;
	}

	get nodes() {
		return this._nodes;
	}

}

class MorphTarget {
	constructor(options) {
		if (arguments.length === 2) {
			options = arguments[1];
		}

		this.options = options;
		this._name = options.name;
		this._defaultWeight = options.defaultWeight || 0;
		this.aabb = options.aabb;

		if (!this.aabb) {
			this.aabb = new BoundingBox();
			if (options.deltaPositions) this.aabb.compute(options.deltaPositions);
		}

		this.deltaPositions = options.deltaPositions;
	}

	get name() {
		return this._name;
	}

	get defaultWeight() {
		return this._defaultWeight;
	}

	get morphPositions() {
		return !!this._vertexBufferPositions || !!this.texturePositions;
	}

	get morphNormals() {
		return !!this._vertexBufferNormals || !!this.textureNormals;
	}

	_postInit() {
		this.options = null;
	}

	_initVertexBuffers(graphicsDevice) {
		const options = this.options;
		this._vertexBufferPositions = this._createVertexBuffer(graphicsDevice, options.deltaPositions, options.deltaPositionsType);
		this._vertexBufferNormals = this._createVertexBuffer(graphicsDevice, options.deltaNormals, options.deltaNormalsType);

		if (this._vertexBufferPositions) {
			this.deltaPositions = this._vertexBufferPositions.lock();
		}
	}

	_createVertexBuffer(device, data, dataType = TYPE_FLOAT32) {
		if (data) {
			const formatDesc = [{
				semantic: SEMANTIC_ATTR0,
				components: 3,
				type: dataType
			}];
			return new VertexBuffer(device, new VertexFormat(device, formatDesc), data.length / 3, BUFFER_STATIC, data);
		}

		return null;
	}

	_setTexture(name, texture) {
		this[name] = texture;
	}

	destroy() {
		if (this._vertexBufferPositions) {
			this._vertexBufferPositions.destroy();

			this._vertexBufferPositions = null;
		}

		if (this._vertexBufferNormals) {
			this._vertexBufferNormals.destroy();

			this._vertexBufferNormals = null;
		}

		if (this.texturePositions) {
			this.texturePositions.destroy();
			this.texturePositions = null;
		}

		if (this.textureNormals) {
			this.textureNormals.destroy();
			this.textureNormals = null;
		}
	}

}

class Skin {
	constructor(graphicsDevice, ibp, boneNames) {
		this.device = graphicsDevice;
		this.inverseBindPose = ibp;
		this.boneNames = boneNames;
	}

}

class Render extends EventHandler {
	constructor() {
		super();
		this._meshes = null;
	}

	set meshes(value) {
		this.decRefMeshes();
		this._meshes = value;
		this.incRefMeshes();
		this.fire('set:meshes', value);
	}

	get meshes() {
		return this._meshes;
	}

	destroy() {
		this.meshes = null;
	}

	decRefMeshes() {
		if (this._meshes) {
			const count = this._meshes.length;

			for (let i = 0; i < count; i++) {
				const mesh = this._meshes[i];

				if (mesh) {
					mesh.decRefCount();

					if (mesh.refCount < 1) {
						mesh.destroy();
						this._meshes[i] = null;
					}
				}
			}
		}
	}

	incRefMeshes() {
		if (this._meshes) {
			const count = this._meshes.length;

			for (let i = 0; i < count; i++) {
				if (this._meshes[i]) {
					this._meshes[i].incRefCount();
				}
			}
		}
	}

}

class AnimCurve {
	constructor(paths, input, output, interpolation) {
		this._paths = paths;
		this._input = input;
		this._output = output;
		this._interpolation = interpolation;
	}

	get paths() {
		return this._paths;
	}

	get input() {
		return this._input;
	}

	get output() {
		return this._output;
	}

	get interpolation() {
		return this._interpolation;
	}

}

class AnimData {
	constructor(components, data) {
		this._components = components;
		this._data = data;
	}

	get components() {
		return this._components;
	}

	get data() {
		return this._data;
	}

}

class AnimEvents {
	constructor(events) {
		this._events = [...events];

		this._events.sort((a, b) => a.time - b.time);
	}

	get events() {
		return this._events;
	}

}

class AnimTrack {
	constructor(name, duration, inputs, outputs, curves, animEvents = new AnimEvents([])) {
		this._name = name;
		this._duration = duration;
		this._inputs = inputs;
		this._outputs = outputs;
		this._curves = curves;
		this._animEvents = animEvents;
	}

	get name() {
		return this._name;
	}

	get duration() {
		return this._duration;
	}

	get inputs() {
		return this._inputs;
	}

	get outputs() {
		return this._outputs;
	}

	get curves() {
		return this._curves;
	}

	set events(animEvents) {
		this._animEvents = animEvents;
	}

	get events() {
		return this._animEvents.events;
	}

	eval(time, snapshot) {
		snapshot._time = time;
		const inputs = this._inputs;
		const outputs = this._outputs;
		const curves = this._curves;
		const cache = snapshot._cache;
		const results = snapshot._results;

		for (let i = 0; i < inputs.length; ++i) {
			cache[i].update(time, inputs[i]._data);
		}

		for (let i = 0; i < curves.length; ++i) {
			const curve = curves[i];
			const output = outputs[curve._output];
			const result = results[i];

			cache[curve._input].eval(result, curve._interpolation, output);
		}
	}

}

const INTERPOLATION_STEP = 0;
const INTERPOLATION_LINEAR = 1;
const INTERPOLATION_CUBIC = 2;

const DEFAULT_LOCALE = 'en-US';
const DEFAULT_LOCALE_FALLBACKS = {
	'en': 'en-US',
	'es': 'en-ES',
	'zh': 'zh-CN',
	'zh-HK': 'zh-TW',
	'zh-TW': 'zh-HK',
	'zh-MO': 'zh-HK',
	'fr': 'fr-FR',
	'de': 'de-DE',
	'it': 'it-IT',
	'ru': 'ru-RU',
	'ja': 'ja-JP'
};

const PLURALS = {};

function definePluralFn(locales, fn) {
	for (let i = 0, len = locales.length; i < len; i++) {
		PLURALS[locales[i]] = fn;
	}
}

function getLang(locale) {
	const idx = locale.indexOf('-');

	if (idx !== -1) {
		return locale.substring(0, idx);
	}

	return locale;
}

function replaceLang(locale, desiredLang) {
	const idx = locale.indexOf('-');

	if (idx !== -1) {
		return desiredLang + locale.substring(idx);
	}

	return desiredLang;
}

function findAvailableLocale(desiredLocale, availableLocales) {
	if (availableLocales[desiredLocale]) {
		return desiredLocale;
	}

	let fallback = DEFAULT_LOCALE_FALLBACKS[desiredLocale];

	if (fallback && availableLocales[fallback]) {
		return fallback;
	}

	const lang = getLang(desiredLocale);
	fallback = DEFAULT_LOCALE_FALLBACKS[lang];

	if (availableLocales[fallback]) {
		return fallback;
	}

	if (availableLocales[lang]) {
		return lang;
	}

	return DEFAULT_LOCALE;
}

definePluralFn(['ja', 'ko', 'th', 'vi', 'zh', 'id'], function (n) {
	return 0;
});
definePluralFn(['fa', 'hi'], function (n) {
	if (n >= 0 && n <= 1) {
		return 0;
	}

	return 1;
});
definePluralFn(['fr', 'pt'], function (n) {
	if (n >= 0 && n < 2) {
		return 0;
	}

	return 1;
});
definePluralFn(['da'], function (n) {
	if (n === 1 || !Number.isInteger(n) && n >= 0 && n <= 1) {
		return 0;
	}

	return 1;
});
definePluralFn(['de', 'en', 'it', 'el', 'es', 'tr', 'fi', 'sv', 'nb', 'no', 'ur'], function (n) {
	if (n === 1) {
		return 0;
	}

	return 1;
});
definePluralFn(['ru', 'uk'], function (n) {
	if (Number.isInteger(n)) {
		const mod10 = n % 10;
		const mod100 = n % 100;

		if (mod10 === 1 && mod100 !== 11) {
			return 0;
		} else if (mod10 >= 2 && mod10 <= 4 && (mod100 < 12 || mod100 > 14)) {
			return 1;
		} else if (mod10 === 0 || mod10 >= 5 && mod10 <= 9 || mod100 >= 11 && mod100 <= 14) {
			return 2;
		}
	}

	return 3;
});
definePluralFn(['pl'], function (n) {
	if (Number.isInteger(n)) {
		if (n === 1) {
			return 0;
		}

		const mod10 = n % 10;
		const mod100 = n % 100;

		if (mod10 >= 2 && mod10 <= 4 && (mod100 < 12 || mod100 > 14)) {
			return 1;
		} else if (mod10 >= 0 && mod10 <= 1 || mod10 >= 5 && mod10 <= 9 || mod100 >= 12 && mod100 <= 14) {
			return 2;
		}
	}

	return 3;
});
definePluralFn(['ar'], function (n) {
	if (n === 0) {
		return 0;
	} else if (n === 1) {
		return 1;
	} else if (n === 2) {
		return 2;
	}

	if (Number.isInteger(n)) {
		const mod100 = n % 100;

		if (mod100 >= 3 && mod100 <= 10) {
			return 3;
		} else if (mod100 >= 11 && mod100 <= 99) {
			return 4;
		}
	}

	return 5;
});
const DEFAULT_PLURAL_FN = PLURALS[getLang(DEFAULT_LOCALE)];

function getPluralFn(lang) {
	return PLURALS[lang] || DEFAULT_PLURAL_FN;
}

const ABSOLUTE_URL = new RegExp('^' + '\\s*' + '(?:' + '(?:' + '[a-z]+[a-z0-9\\-\\+\\.]*' + ':' + ')?' + '//' + '|' + 'data:' + '|blob:' + ')', 'i');
const ASSET_ANIMATION = 'animation';
const ASSET_AUDIO = 'audio';
const ASSET_IMAGE = 'image';
const ASSET_JSON = 'json';
const ASSET_MODEL = 'model';
const ASSET_MATERIAL = 'material';
const ASSET_TEXT = 'text';
const ASSET_TEXTURE = 'texture';
const ASSET_CUBEMAP = 'cubemap';
const ASSET_SHADER = 'shader';
const ASSET_CSS = 'css';
const ASSET_HTML = 'html';
const ASSET_SCRIPT = 'script';
const ASSET_CONTAINER = 'container';

class AssetFile {
	constructor(url, filename, hash, size, opt, contents) {
		this.url = url || '';
		this.filename = filename || '';
		this.hash = hash === undefined ? null : hash;
		this.size = size === undefined ? null : size;
		this.opt = opt === undefined ? null : opt;
		this.contents = contents || null;
	}

	equals(other) {
		return this.url === other.url && this.filename === other.filename && this.hash === other.hash && this.size === other.size && this.opt === other.opt && this.contents === other.contents;
	}

}

let assetIdCounter = -1;
const VARIANT_SUPPORT = {
	pvr: 'extCompressedTexturePVRTC',
	dxt: 'extCompressedTextureS3TC',
	etc2: 'extCompressedTextureETC',
	etc1: 'extCompressedTextureETC1',
	basis: 'canvas'
};
const VARIANT_DEFAULT_PRIORITY = ['pvr', 'dxt', 'etc2', 'etc1', 'basis'];

class Asset extends EventHandler {
	constructor(name, type, file, data, options) {
		super();
		this._id = assetIdCounter--;
		this.name = name || '';
		this.type = type;
		this.tags = new Tags(this);
		this._preload = false;
		this._file = null;
		this._data = data || {};
		this.options = options || {};
		this._resources = [];
		this._i18n = {};
		this.loaded = false;
		this.loading = false;
		this.registry = null;
		if (file) this.file = file;
	}

	set id(value) {
		this._id = value;
	}

	get id() {
		return this._id;
	}

	set file(value) {
		if (value && value.variants && ['texture', 'textureatlas', 'bundle'].indexOf(this.type) !== -1) {
			var _this$registry, _this$registry$_loade;

			const app = ((_this$registry = this.registry) == null ? void 0 : (_this$registry$_loade = _this$registry._loader) == null ? void 0 : _this$registry$_loade._app) || getApplication();
			const device = app == null ? void 0 : app.graphicsDevice;

			if (device) {
				for (let i = 0, len = VARIANT_DEFAULT_PRIORITY.length; i < len; i++) {
					const variant = VARIANT_DEFAULT_PRIORITY[i];

					if (value.variants[variant] && device[VARIANT_SUPPORT[variant]]) {
						value = value.variants[variant];
						break;
					}

					if (app.enableBundles) {
						const bundles = app.bundles.listBundlesForAsset(this);

						if (bundles && bundles.find(b => {
							var _b$file;

							return b == null ? void 0 : (_b$file = b.file) == null ? void 0 : _b$file.variants[variant];
						})) {
							break;
						}
					}
				}
			}
		}

		const oldFile = this._file;
		const newFile = value ? new AssetFile(value.url, value.filename, value.hash, value.size, value.opt, value.contents) : null;

		if (!!newFile !== !!oldFile || newFile && !newFile.equals(oldFile)) {
			this._file = newFile;
			this.fire('change', this, 'file', newFile, oldFile);
			this.reload();
		}
	}

	get file() {
		return this._file;
	}

	set data(value) {
		const old = this._data;
		this._data = value;

		if (value !== old) {
			this.fire('change', this, 'data', value, old);
			if (this.loaded) this.registry._loader.patch(this, this.registry);
		}
	}

	get data() {
		return this._data;
	}

	set resource(value) {
		const _old = this._resources[0];
		this._resources[0] = value;
		this.fire('change', this, 'resource', value, _old);
	}

	get resource() {
		return this._resources[0];
	}

	set resources(value) {
		const _old = this._resources;
		this._resources = value;
		this.fire('change', this, 'resources', value, _old);
	}

	get resources() {
		return this._resources;
	}

	set preload(value) {
		value = !!value;
		if (this._preload === value) return;
		this._preload = value;
		if (this._preload && !this.loaded && !this.loading && this.registry) this.registry.load(this);
	}

	get preload() {
		return this._preload;
	}

	set loadFaces(value) {
		value = !!value;

		if (!this.hasOwnProperty('_loadFaces') || value !== this._loadFaces) {
			this._loadFaces = value;
			if (this.loaded) this.registry._loader.patch(this, this.registry);
		}
	}

	get loadFaces() {
		return this._loadFaces;
	}

	getFileUrl() {
		const file = this.file;
		if (!file || !file.url) return null;
		let url = file.url;
		if (this.registry && this.registry.prefix && !ABSOLUTE_URL.test(url)) url = this.registry.prefix + url;

		if (this.type !== 'script' && file.hash) {
			const separator = url.indexOf('?') !== -1 ? '&' : '?';
			url += separator + 't=' + file.hash;
		}

		return url;
	}

	getAbsoluteUrl(relativePath) {
		if (relativePath.startsWith('blob:') || relativePath.startsWith('data:')) {
			return relativePath;
		}

		const base = path.getDirectory(this.file.url);
		return path.join(base, relativePath);
	}

	getLocalizedAssetId(locale) {
		locale = findAvailableLocale(locale, this._i18n);
		return this._i18n[locale] || null;
	}

	addLocalizedAssetId(locale, assetId) {
		this._i18n[locale] = assetId;
		this.fire('add:localized', locale, assetId);
	}

	removeLocalizedAssetId(locale) {
		const assetId = this._i18n[locale];

		if (assetId) {
			delete this._i18n[locale];
			this.fire('remove:localized', locale, assetId);
		}
	}

	ready(callback, scope) {
		scope = scope || this;

		if (this.resource) {
			callback.call(scope, this);
		} else {
			this.once("load", function (asset) {
				callback.call(scope, asset);
			});
		}
	}

	reload() {
		if (this.loaded) {
			this.loaded = false;
			this.registry.load(this);
		}
	}

	unload() {
		if (!this.loaded && this._resources.length === 0) return;
		this.fire('unload', this);
		this.registry.fire('unload:' + this.id, this);
		const old = this._resources;
		this.resources = [];
		this.loaded = false;

		if (this.file) {
			this.registry._loader.clearCache(this.getFileUrl(), this.type);
		}

		for (let i = 0; i < old.length; ++i) {
			const resource = old[i];

			if (resource && resource.destroy) {
				resource.destroy();
			}
		}
	}

	static fetchArrayBuffer(loadUrl, callback, asset, maxRetries = 0) {
		var _asset$file;

		if (asset != null && (_asset$file = asset.file) != null && _asset$file.contents) {
			setTimeout(() => {
				callback(null, asset.file.contents);
			});
		} else {
			http.get(loadUrl, {
				cache: true,
				responseType: 'arraybuffer',
				retry: maxRetries > 0,
				maxRetries: maxRetries
			}, callback);
		}
	}

}

class SkinInstanceCachedObject extends RefCountedObject {
	constructor(skin, skinInstance) {
		super();
		this.skin = skin;
		this.skinInstance = skinInstance;
	}

}

class SkinInstanceCache {
	static createCachedSkinInstance(skin, rootBone, entity) {
		let skinInst = SkinInstanceCache.getCachedSkinInstance(skin, rootBone);

		if (!skinInst) {
			skinInst = new SkinInstance(skin);
			skinInst.resolve(rootBone, entity);
			SkinInstanceCache.addCachedSkinInstance(skin, rootBone, skinInst);
		}

		return skinInst;
	}

	static getCachedSkinInstance(skin, rootBone) {
		let skinInstance = null;

		const cachedObjArray = SkinInstanceCache._skinInstanceCache.get(rootBone);

		if (cachedObjArray) {
			const cachedObj = cachedObjArray.find(element => element.skin === skin);

			if (cachedObj) {
				cachedObj.incRefCount();
				skinInstance = cachedObj.skinInstance;
			}
		}

		return skinInstance;
	}

	static addCachedSkinInstance(skin, rootBone, skinInstance) {
		let cachedObjArray = SkinInstanceCache._skinInstanceCache.get(rootBone);

		if (!cachedObjArray) {
			cachedObjArray = [];

			SkinInstanceCache._skinInstanceCache.set(rootBone, cachedObjArray);
		}

		let cachedObj = cachedObjArray.find(element => element.skin === skin);

		if (!cachedObj) {
			cachedObj = new SkinInstanceCachedObject(skin, skinInstance);
			cachedObjArray.push(cachedObj);
		}

		cachedObj.incRefCount();
	}

	static removeCachedSkinInstance(skinInstance) {
		if (skinInstance) {
			const rootBone = skinInstance.rootBone;

			if (rootBone) {
				const cachedObjArray = SkinInstanceCache._skinInstanceCache.get(rootBone);

				if (cachedObjArray) {
					const cachedObjIndex = cachedObjArray.findIndex(element => element.skinInstance === skinInstance);

					if (cachedObjIndex >= 0) {
						const cachedObj = cachedObjArray[cachedObjIndex];
						cachedObj.decRefCount();

						if (cachedObj.refCount === 0) {
							cachedObjArray.splice(cachedObjIndex, 1);

							if (!cachedObjArray.length) {
								SkinInstanceCache._skinInstanceCache.delete(rootBone);
							}

							if (skinInstance) {
								skinInstance.destroy();
								cachedObj.skinInstance = null;
							}
						}
					}
				}
			}
		}
	}

}

SkinInstanceCache._skinInstanceCache = new Map();

class GlbContainerResource {
	constructor(data, asset, assets, defaultMaterial) {
		const createAsset = function createAsset(type, resource, index) {
			const subAsset = GlbContainerResource.createAsset(asset.name, type, resource, index);
			assets.add(subAsset);
			return subAsset;
		};

		const renders = [];

		for (let i = 0; i < data.renders.length; ++i) {
			renders.push(createAsset('render', data.renders[i], i));
		}

		const materials = [];

		for (let i = 0; i < data.materials.length; ++i) {
			materials.push(createAsset('material', data.materials[i], i));
		}

		const animations = [];

		for (let i = 0; i < data.animations.length; ++i) {
			animations.push(createAsset('animation', data.animations[i], i));
		}

		this.data = data;
		this._model = null;
		this._assetName = asset.name;
		this._assets = assets;
		this._defaultMaterial = defaultMaterial;
		this.renders = renders;
		this.materials = materials;
		this.textures = data.textures;
		this.animations = animations;
	}

	get model() {
		if (!this._model) {
			const model = GlbContainerResource.createModel(this.data, this._defaultMaterial);
			const modelAsset = GlbContainerResource.createAsset(this._assetName, 'model', model, 0);

			this._assets.add(modelAsset);

			this._model = modelAsset;
		}

		return this._model;
	}

	static createAsset(assetName, type, resource, index) {
		const subAsset = new Asset(assetName + '/' + type + '/' + index, type, {
			url: ''
		});
		subAsset.resource = resource;
		subAsset.loaded = true;
		return subAsset;
	}

	instantiateModelEntity(options) {
		const entity = new Entity();
		entity.addComponent("model", Object.assign({
			type: "asset",
			asset: this.model
		}, options));
		return entity;
	}

	instantiateRenderEntity(options) {
		const defaultMaterial = this._defaultMaterial;
		const skinnedMeshInstances = [];

		const createMeshInstance = function createMeshInstance(root, entity, mesh, materials, skins, gltfNode) {
			const material = mesh.materialIndex === undefined ? defaultMaterial : materials[mesh.materialIndex];
			const meshInstance = new MeshInstance(mesh, material);

			if (mesh.morph) {
				meshInstance.morphInstance = new MorphInstance(mesh.morph);
			}

			if (gltfNode.hasOwnProperty('skin')) {
				skinnedMeshInstances.push({
					meshInstance: meshInstance,
					rootBone: root,
					entity: entity
				});
			}

			return meshInstance;
		};

		const cloneHierarchy = (root, node, glb) => {
			const entity = new Entity();

			node._cloneInternal(entity);

			if (!root) root = entity;
			let attachedMi = null;
			let renderAsset = null;

			for (let i = 0; i < glb.nodes.length; i++) {
				const glbNode = glb.nodes[i];

				if (glbNode === node) {
					const gltfNode = glb.gltf.nodes[i];

					if (gltfNode.hasOwnProperty('mesh')) {
						const meshGroup = glb.renders[gltfNode.mesh].meshes;
						renderAsset = this.renders[gltfNode.mesh];

						for (var mi = 0; mi < meshGroup.length; mi++) {
							const mesh = meshGroup[mi];

							if (mesh) {
								const cloneMi = createMeshInstance(root, entity, mesh, glb.materials, glb.skins, gltfNode);

								if (!attachedMi) {
									attachedMi = [];
								}

								attachedMi.push(cloneMi);
							}
						}
					}

					if (glb.lights) {
						const lightEntity = glb.lights.get(gltfNode);

						if (lightEntity) {
							entity.addChild(lightEntity.clone());
						}
					}

					if (glb.cameras) {
						const cameraEntity = glb.cameras.get(gltfNode);

						if (cameraEntity) {
							cameraEntity.camera.system.cloneComponent(cameraEntity, entity);
						}
					}
				}
			}

			if (attachedMi) {
				entity.addComponent("render", Object.assign({
					type: "asset",
					meshInstances: attachedMi,
					rootBone: root
				}, options));
				entity.render.assignAsset(renderAsset);
			}

			const children = node.children;

			for (let i = 0; i < children.length; i++) {
				const childClone = cloneHierarchy(root, children[i], glb);
				entity.addChild(childClone);
			}

			return entity;
		};

		const sceneClones = [];

		for (const scene of this.data.scenes) {
			sceneClones.push(cloneHierarchy(null, scene, this.data));
		}

		skinnedMeshInstances.forEach(data => {
			data.meshInstance.skinInstance = SkinInstanceCache.createCachedSkinInstance(data.meshInstance.mesh.skin, data.rootBone, data.entity);
		});
		return GlbContainerResource.createSceneHierarchy(sceneClones, "Entity");
	}

	static createSceneHierarchy(sceneNodes, nodeType) {
		let root = null;

		if (sceneNodes.length === 1) {
			root = sceneNodes[0];
		} else {
			root = new nodeType('SceneGroup');

			for (const scene of sceneNodes) {
				root.addChild(scene);
			}
		}

		return root;
	}

	static createModel(glb, defaultMaterial) {
		const createMeshInstance = function createMeshInstance(model, mesh, skins, skinInstances, materials, node, gltfNode) {
			const material = mesh.materialIndex === undefined ? defaultMaterial : materials[mesh.materialIndex];
			const meshInstance = new MeshInstance(mesh, material, node);

			if (mesh.morph) {
				const morphInstance = new MorphInstance(mesh.morph);
				meshInstance.morphInstance = morphInstance;
				model.morphInstances.push(morphInstance);
			}

			if (gltfNode.hasOwnProperty('skin')) {
				const skinIndex = gltfNode.skin;
				const skin = skins[skinIndex];
				mesh.skin = skin;
				const skinInstance = skinInstances[skinIndex];
				meshInstance.skinInstance = skinInstance;
				model.skinInstances.push(skinInstance);
			}

			model.meshInstances.push(meshInstance);
		};

		const model = new Model();
		const skinInstances = [];

		for (const skin of glb.skins) {
			const skinInstance = new SkinInstance(skin);
			skinInstance.bones = skin.bones;
			skinInstances.push(skinInstance);
		}

		model.graph = GlbContainerResource.createSceneHierarchy(glb.scenes, "GraphNode");

		for (let i = 0; i < glb.nodes.length; i++) {
			const node = glb.nodes[i];

			if (node.root === model.graph) {
				const gltfNode = glb.gltf.nodes[i];

				if (gltfNode.hasOwnProperty('mesh')) {
					const meshGroup = glb.renders[gltfNode.mesh].meshes;

					for (var mi = 0; mi < meshGroup.length; mi++) {
						const mesh = meshGroup[mi];

						if (mesh) {
							createMeshInstance(model, mesh, glb.skins, skinInstances, glb.materials, node, gltfNode);
						}
					}
				}
			}
		}

		return model;
	}

	destroy() {
		const registry = this._assets;

		const destroyAsset = function destroyAsset(asset) {
			registry.remove(asset);
			asset.unload();
		};

		const destroyAssets = function destroyAssets(assets) {
			assets.forEach(function (asset) {
				destroyAsset(asset);
			});
		};

		if (this.animations) {
			destroyAssets(this.animations);
			this.animations = null;
		}

		if (this.textures) {
			destroyAssets(this.textures);
			this.textures = null;
		}

		if (this.materials) {
			destroyAssets(this.materials);
			this.materials = null;
		}

		if (this.renders) {
			destroyAssets(this.renders);
			this.renders = null;
		}

		if (this._model) {
			destroyAsset(this._model);
			this._model = null;
		}

		this.data = null;
		this.assets = null;
	}

}

class GlbResources {
	constructor(gltf) {
		this.gltf = gltf;
		this.nodes = null;
		this.scenes = null;
		this.animations = null;
		this.textures = null;
		this.materials = null;
		this.renders = null;
		this.skins = null;
		this.lights = null;
		this.cameras = null;
	}

	destroy() {
		if (this.renders) {
			this.renders.forEach(render => {
				render.meshes = null;
			});
		}
	}

}

const isDataURI = function isDataURI(uri) {
	return /^data:.*,.*$/i.test(uri);
};

const getDataURIMimeType = function getDataURIMimeType(uri) {
	return uri.substring(uri.indexOf(":") + 1, uri.indexOf(";"));
};

const getNumComponents = function getNumComponents(accessorType) {
	switch (accessorType) {
		case 'SCALAR':
			return 1;

		case 'VEC2':
			return 2;

		case 'VEC3':
			return 3;

		case 'VEC4':
			return 4;

		case 'MAT2':
			return 4;

		case 'MAT3':
			return 9;

		case 'MAT4':
			return 16;

		default:
			return 3;
	}
};

const getComponentType = function getComponentType(componentType) {
	switch (componentType) {
		case 5120:
			return TYPE_INT8;

		case 5121:
			return TYPE_UINT8;

		case 5122:
			return TYPE_INT16;

		case 5123:
			return TYPE_UINT16;

		case 5124:
			return TYPE_INT32;

		case 5125:
			return TYPE_UINT32;

		case 5126:
			return TYPE_FLOAT32;

		default:
			return 0;
	}
};

const getComponentSizeInBytes = function getComponentSizeInBytes(componentType) {
	switch (componentType) {
		case 5120:
			return 1;

		case 5121:
			return 1;

		case 5122:
			return 2;

		case 5123:
			return 2;

		case 5124:
			return 4;

		case 5125:
			return 4;

		case 5126:
			return 4;

		default:
			return 0;
	}
};

const getComponentDataType = function getComponentDataType(componentType) {
	switch (componentType) {
		case 5120:
			return Int8Array;

		case 5121:
			return Uint8Array;

		case 5122:
			return Int16Array;

		case 5123:
			return Uint16Array;

		case 5124:
			return Int32Array;

		case 5125:
			return Uint32Array;

		case 5126:
			return Float32Array;

		default:
			return null;
	}
};

const gltfToEngineSemanticMap = {
	'POSITION': SEMANTIC_POSITION,
	'NORMAL': SEMANTIC_NORMAL,
	'TANGENT': SEMANTIC_TANGENT,
	'COLOR_0': SEMANTIC_COLOR,
	'JOINTS_0': SEMANTIC_BLENDINDICES,
	'WEIGHTS_0': SEMANTIC_BLENDWEIGHT,
	'TEXCOORD_0': SEMANTIC_TEXCOORD0,
	'TEXCOORD_1': SEMANTIC_TEXCOORD1,
	'TEXCOORD_2': SEMANTIC_TEXCOORD2,
	'TEXCOORD_3': SEMANTIC_TEXCOORD3,
	'TEXCOORD_4': SEMANTIC_TEXCOORD4,
	'TEXCOORD_5': SEMANTIC_TEXCOORD5,
	'TEXCOORD_6': SEMANTIC_TEXCOORD6,
	'TEXCOORD_7': SEMANTIC_TEXCOORD7
};

const getDequantizeFunc = srcType => {
	switch (srcType) {
		case TYPE_INT8:
			return x => Math.max(x / 127.0, -1.0);

		case TYPE_UINT8:
			return x => x / 255.0;

		case TYPE_INT16:
			return x => Math.max(x / 32767.0, -1.0);

		case TYPE_UINT16:
			return x => x / 65535.0;

		default:
			return x => x;
	}
};

const dequantizeArray = function dequantizeArray(dstArray, srcArray, srcType) {
	const convFunc = getDequantizeFunc(srcType);
	const len = srcArray.length;

	for (let i = 0; i < len; ++i) {
		dstArray[i] = convFunc(srcArray[i]);
	}

	return dstArray;
};

const getAccessorData = function getAccessorData(gltfAccessor, bufferViews, flatten = false) {
	const numComponents = getNumComponents(gltfAccessor.type);
	const dataType = getComponentDataType(gltfAccessor.componentType);

	if (!dataType) {
		return null;
	}

	const bufferView = bufferViews[gltfAccessor.bufferView];
	let result;

	if (gltfAccessor.sparse) {
		const sparse = gltfAccessor.sparse;
		const indicesAccessor = {
			count: sparse.count,
			type: "SCALAR"
		};
		const indices = getAccessorData(Object.assign(indicesAccessor, sparse.indices), bufferViews, true);
		const valuesAccessor = {
			count: sparse.count,
			type: gltfAccessor.scalar,
			componentType: gltfAccessor.componentType
		};
		const values = getAccessorData(Object.assign(valuesAccessor, sparse.values), bufferViews, true);

		if (gltfAccessor.hasOwnProperty('bufferView')) {
			const baseAccessor = {
				bufferView: gltfAccessor.bufferView,
				byteOffset: gltfAccessor.byteOffset,
				componentType: gltfAccessor.componentType,
				count: gltfAccessor.count,
				type: gltfAccessor.type
			};
			result = getAccessorData(baseAccessor, bufferViews, true).slice();
		} else {
			result = new dataType(gltfAccessor.count * numComponents);
		}

		for (let i = 0; i < sparse.count; ++i) {
			const targetIndex = indices[i];

			for (let j = 0; j < numComponents; ++j) {
				result[targetIndex * numComponents + j] = values[i * numComponents + j];
			}
		}
	} else if (flatten && bufferView.hasOwnProperty('byteStride')) {
		const bytesPerElement = numComponents * dataType.BYTES_PER_ELEMENT;
		const storage = new ArrayBuffer(gltfAccessor.count * bytesPerElement);
		const tmpArray = new Uint8Array(storage);
		let dstOffset = 0;

		for (let i = 0; i < gltfAccessor.count; ++i) {
			let srcOffset = (gltfAccessor.byteOffset || 0) + i * bufferView.byteStride;

			for (let b = 0; b < bytesPerElement; ++b) {
				tmpArray[dstOffset++] = bufferView[srcOffset++];
			}
		}

		result = new dataType(storage);
	} else {
		result = new dataType(bufferView.buffer, bufferView.byteOffset + (gltfAccessor.byteOffset || 0), gltfAccessor.count * numComponents);
	}

	return result;
};

const getAccessorDataFloat32 = function getAccessorDataFloat32(gltfAccessor, bufferViews) {
	const data = getAccessorData(gltfAccessor, bufferViews, true);

	if (data instanceof Float32Array || !gltfAccessor.normalized) {
		return data;
	}

	const float32Data = new Float32Array(data.length);
	dequantizeArray(float32Data, data, getComponentType(gltfAccessor.componentType));
	return float32Data;
};

const getAccessorBoundingBox = function getAccessorBoundingBox(gltfAccessor) {
	let min = gltfAccessor.min;
	let max = gltfAccessor.max;

	if (!min || !max) {
		return null;
	}

	if (gltfAccessor.normalized) {
		const ctype = getComponentType(gltfAccessor.componentType);
		min = dequantizeArray([], min, ctype);
		max = dequantizeArray([], max, ctype);
	}

	return new BoundingBox(new Vec3((max[0] + min[0]) * 0.5, (max[1] + min[1]) * 0.5, (max[2] + min[2]) * 0.5), new Vec3((max[0] - min[0]) * 0.5, (max[1] - min[1]) * 0.5, (max[2] - min[2]) * 0.5));
};

const getPrimitiveType = function getPrimitiveType(primitive) {
	if (!primitive.hasOwnProperty('mode')) {
		return PRIMITIVE_TRIANGLES;
	}

	switch (primitive.mode) {
		case 0:
			return PRIMITIVE_POINTS;

		case 1:
			return PRIMITIVE_LINES;

		case 2:
			return PRIMITIVE_LINELOOP;

		case 3:
			return PRIMITIVE_LINESTRIP;

		case 4:
			return PRIMITIVE_TRIANGLES;

		case 5:
			return PRIMITIVE_TRISTRIP;

		case 6:
			return PRIMITIVE_TRIFAN;

		default:
			return PRIMITIVE_TRIANGLES;
	}
};

const generateIndices = function generateIndices(numVertices) {
	const dummyIndices = new Uint16Array(numVertices);

	for (let i = 0; i < numVertices; i++) {
		dummyIndices[i] = i;
	}

	return dummyIndices;
};

const generateNormals = function generateNormals(sourceDesc, indices) {
	const p = sourceDesc[SEMANTIC_POSITION];

	if (!p || p.components !== 3) {
		return;
	}

	let positions;

	if (p.size !== p.stride) {
		const srcStride = p.stride / typedArrayTypesByteSize[p.type];
		const src = new typedArrayTypes[p.type](p.buffer, p.offset, p.count * srcStride);
		positions = new typedArrayTypes[p.type](p.count * 3);

		for (let i = 0; i < p.count; ++i) {
			positions[i * 3 + 0] = src[i * srcStride + 0];
			positions[i * 3 + 1] = src[i * srcStride + 1];
			positions[i * 3 + 2] = src[i * srcStride + 2];
		}
	} else {
		positions = new typedArrayTypes[p.type](p.buffer, p.offset, p.count * 3);
	}

	const numVertices = p.count;

	if (!indices) {
		indices = generateIndices(numVertices);
	}

	const normalsTemp = calculateNormals(positions, indices);
	const normals = new Float32Array(normalsTemp.length);
	normals.set(normalsTemp);
	sourceDesc[SEMANTIC_NORMAL] = {
		buffer: normals.buffer,
		size: 12,
		offset: 0,
		stride: 12,
		count: numVertices,
		components: 3,
		type: TYPE_FLOAT32
	};
};

const flipTexCoordVs = function flipTexCoordVs(vertexBuffer) {
	let i, j;
	const floatOffsets = [];
	const shortOffsets = [];
	const byteOffsets = [];

	for (i = 0; i < vertexBuffer.format.elements.length; ++i) {
		const element = vertexBuffer.format.elements[i];

		if (element.name === SEMANTIC_TEXCOORD0 || element.name === SEMANTIC_TEXCOORD1) {
			switch (element.dataType) {
				case TYPE_FLOAT32:
					floatOffsets.push({
						offset: element.offset / 4 + 1,
						stride: element.stride / 4
					});
					break;

				case TYPE_UINT16:
					shortOffsets.push({
						offset: element.offset / 2 + 1,
						stride: element.stride / 2
					});
					break;

				case TYPE_UINT8:
					byteOffsets.push({
						offset: element.offset + 1,
						stride: element.stride
					});
					break;
			}
		}
	}

	const flip = function flip(offsets, type, one) {
		const typedArray = new type(vertexBuffer.storage);

		for (i = 0; i < offsets.length; ++i) {
			let index = offsets[i].offset;
			const stride = offsets[i].stride;

			for (j = 0; j < vertexBuffer.numVertices; ++j) {
				typedArray[index] = one - typedArray[index];
				index += stride;
			}
		}
	};

	if (floatOffsets.length > 0) {
		flip(floatOffsets, Float32Array, 1.0);
	}

	if (shortOffsets.length > 0) {
		flip(shortOffsets, Uint16Array, 65535);
	}

	if (byteOffsets.length > 0) {
		flip(byteOffsets, Uint8Array, 255);
	}
};

const cloneTexture = function cloneTexture(texture) {
	const shallowCopyLevels = function shallowCopyLevels(texture) {
		const result = [];

		for (let mip = 0; mip < texture._levels.length; ++mip) {
			let level = [];

			if (texture.cubemap) {
				for (let face = 0; face < 6; ++face) {
					level.push(texture._levels[mip][face]);
				}
			} else {
				level = texture._levels[mip];
			}

			result.push(level);
		}

		return result;
	};

	const result = new Texture(texture.device, texture);
	result._levels = shallowCopyLevels(texture);
	return result;
};

const cloneTextureAsset = function cloneTextureAsset(src) {
	const result = new Asset(src.name + '_clone', src.type, src.file, src.data, src.options);
	result.loaded = true;
	result.resource = cloneTexture(src.resource);
	src.registry.add(result);
	return result;
};

const createVertexBufferInternal = function createVertexBufferInternal(device, sourceDesc, flipV) {
	const positionDesc = sourceDesc[SEMANTIC_POSITION];

	if (!positionDesc) {
		return null;
	}

	const numVertices = positionDesc.count;
	const vertexDesc = [];

	for (const semantic in sourceDesc) {
		if (sourceDesc.hasOwnProperty(semantic)) {
			vertexDesc.push({
				semantic: semantic,
				components: sourceDesc[semantic].components,
				type: sourceDesc[semantic].type,
				normalize: !!sourceDesc[semantic].normalize
			});
		}
	}

	const elementOrder = [SEMANTIC_POSITION, SEMANTIC_NORMAL, SEMANTIC_TANGENT, SEMANTIC_COLOR, SEMANTIC_BLENDINDICES, SEMANTIC_BLENDWEIGHT, SEMANTIC_TEXCOORD0, SEMANTIC_TEXCOORD1];
	vertexDesc.sort(function (lhs, rhs) {
		const lhsOrder = elementOrder.indexOf(lhs.semantic);
		const rhsOrder = elementOrder.indexOf(rhs.semantic);
		return lhsOrder < rhsOrder ? -1 : rhsOrder < lhsOrder ? 1 : 0;
	});
	let i, j, k;
	let source, target, sourceOffset;
	const vertexFormat = new VertexFormat(device, vertexDesc);
	let isCorrectlyInterleaved = true;

	for (i = 0; i < vertexFormat.elements.length; ++i) {
		target = vertexFormat.elements[i];
		source = sourceDesc[target.name];
		sourceOffset = source.offset - positionDesc.offset;

		if (source.buffer !== positionDesc.buffer || source.stride !== target.stride || source.size !== target.size || sourceOffset !== target.offset) {
			isCorrectlyInterleaved = false;
			break;
		}
	}

	const vertexBuffer = new VertexBuffer(device, vertexFormat, numVertices, BUFFER_STATIC);
	const vertexData = vertexBuffer.lock();
	const targetArray = new Uint32Array(vertexData);
	let sourceArray;

	if (isCorrectlyInterleaved) {
		sourceArray = new Uint32Array(positionDesc.buffer, positionDesc.offset, numVertices * vertexBuffer.format.size / 4);
		targetArray.set(sourceArray);
	} else {
		let targetStride, sourceStride;

		for (i = 0; i < vertexBuffer.format.elements.length; ++i) {
			target = vertexBuffer.format.elements[i];
			targetStride = target.stride / 4;
			source = sourceDesc[target.name];
			sourceStride = source.stride / 4;
			sourceArray = new Uint32Array(source.buffer, source.offset, (source.count - 1) * sourceStride + (source.size + 3) / 4);
			let src = 0;
			let dst = target.offset / 4;
			const kend = Math.floor((source.size + 3) / 4);

			for (j = 0; j < numVertices; ++j) {
				for (k = 0; k < kend; ++k) {
					targetArray[dst + k] = sourceArray[src + k];
				}

				src += sourceStride;
				dst += targetStride;
			}
		}
	}

	if (flipV) {
		flipTexCoordVs(vertexBuffer);
	}

	vertexBuffer.unlock();
	return vertexBuffer;
};

const createVertexBuffer = function createVertexBuffer(device, attributes, indices, accessors, bufferViews, flipV, vertexBufferDict) {
	const useAttributes = {};
	const attribIds = [];

	for (const attrib in attributes) {
		if (attributes.hasOwnProperty(attrib) && gltfToEngineSemanticMap.hasOwnProperty(attrib)) {
			useAttributes[attrib] = attributes[attrib];
			attribIds.push(attrib + ":" + attributes[attrib]);
		}
	}

	attribIds.sort();
	const vbKey = attribIds.join();
	let vb = vertexBufferDict[vbKey];

	if (!vb) {
		const sourceDesc = {};

		for (const attrib in useAttributes) {
			const accessor = accessors[attributes[attrib]];
			const accessorData = getAccessorData(accessor, bufferViews);
			const bufferView = bufferViews[accessor.bufferView];
			const semantic = gltfToEngineSemanticMap[attrib];
			const size = getNumComponents(accessor.type) * getComponentSizeInBytes(accessor.componentType);
			const stride = bufferView.hasOwnProperty('byteStride') ? bufferView.byteStride : size;
			sourceDesc[semantic] = {
				buffer: accessorData.buffer,
				size: size,
				offset: accessorData.byteOffset,
				stride: stride,
				count: accessor.count,
				components: getNumComponents(accessor.type),
				type: getComponentType(accessor.componentType),
				normalize: accessor.normalized
			};
		}

		if (!sourceDesc.hasOwnProperty(SEMANTIC_NORMAL)) {
			generateNormals(sourceDesc, indices);
		}

		vb = createVertexBufferInternal(device, sourceDesc, flipV);
		vertexBufferDict[vbKey] = vb;
	}

	return vb;
};

const createVertexBufferDraco = function createVertexBufferDraco(device, outputGeometry, extDraco, decoder, decoderModule, indices, flipV) {
	const numPoints = outputGeometry.num_points();

	const extractDracoAttributeInfo = function extractDracoAttributeInfo(uniqueId) {
		const attribute = decoder.GetAttributeByUniqueId(outputGeometry, uniqueId);
		const numValues = numPoints * attribute.num_components();
		const dracoFormat = attribute.data_type();
		let ptr, values, componentSizeInBytes, storageType;

		switch (dracoFormat) {
			case decoderModule.DT_UINT8:
				storageType = TYPE_UINT8;
				componentSizeInBytes = 1;
				ptr = decoderModule._malloc(numValues * componentSizeInBytes);
				decoder.GetAttributeDataArrayForAllPoints(outputGeometry, attribute, decoderModule.DT_UINT8, numValues * componentSizeInBytes, ptr);
				values = new Uint8Array(decoderModule.HEAPU8.buffer, ptr, numValues).slice();
				break;

			case decoderModule.DT_UINT16:
				storageType = TYPE_UINT16;
				componentSizeInBytes = 2;
				ptr = decoderModule._malloc(numValues * componentSizeInBytes);
				decoder.GetAttributeDataArrayForAllPoints(outputGeometry, attribute, decoderModule.DT_UINT16, numValues * componentSizeInBytes, ptr);
				values = new Uint16Array(decoderModule.HEAPU16.buffer, ptr, numValues).slice();
				break;

			case decoderModule.DT_FLOAT32:
			default:
				storageType = TYPE_FLOAT32;
				componentSizeInBytes = 4;
				ptr = decoderModule._malloc(numValues * componentSizeInBytes);
				decoder.GetAttributeDataArrayForAllPoints(outputGeometry, attribute, decoderModule.DT_FLOAT32, numValues * componentSizeInBytes, ptr);
				values = new Float32Array(decoderModule.HEAPF32.buffer, ptr, numValues).slice();
				break;
		}

		decoderModule._free(ptr);

		return {
			values: values,
			numComponents: attribute.num_components(),
			componentSizeInBytes: componentSizeInBytes,
			storageType: storageType,
			normalized: attribute.normalized()
		};
	};

	const sourceDesc = {};
	const attributes = extDraco.attributes;

	for (const attrib in attributes) {
		if (attributes.hasOwnProperty(attrib) && gltfToEngineSemanticMap.hasOwnProperty(attrib)) {
			const semantic = gltfToEngineSemanticMap[attrib];
			const attributeInfo = extractDracoAttributeInfo(attributes[attrib]);
			const size = attributeInfo.numComponents * attributeInfo.componentSizeInBytes;
			sourceDesc[semantic] = {
				values: attributeInfo.values,
				buffer: attributeInfo.values.buffer,
				size: size,
				offset: 0,
				stride: size,
				count: numPoints,
				components: attributeInfo.numComponents,
				type: attributeInfo.storageType,
				normalize: attributeInfo.normalized
			};
		}
	}

	if (!sourceDesc.hasOwnProperty(SEMANTIC_NORMAL)) {
		generateNormals(sourceDesc, indices);
	}

	return createVertexBufferInternal(device, sourceDesc, flipV);
};

const createSkin = function createSkin(device, gltfSkin, accessors, bufferViews, nodes, glbSkins) {
	let i, j, bindMatrix;
	const joints = gltfSkin.joints;
	const numJoints = joints.length;
	const ibp = [];

	if (gltfSkin.hasOwnProperty('inverseBindMatrices')) {
		const inverseBindMatrices = gltfSkin.inverseBindMatrices;
		const ibmData = getAccessorData(accessors[inverseBindMatrices], bufferViews, true);
		const ibmValues = [];

		for (i = 0; i < numJoints; i++) {
			for (j = 0; j < 16; j++) {
				ibmValues[j] = ibmData[i * 16 + j];
			}

			bindMatrix = new Mat4();
			bindMatrix.set(ibmValues);
			ibp.push(bindMatrix);
		}
	} else {
		for (i = 0; i < numJoints; i++) {
			bindMatrix = new Mat4();
			ibp.push(bindMatrix);
		}
	}

	const boneNames = [];

	for (i = 0; i < numJoints; i++) {
		boneNames[i] = nodes[joints[i]].name;
	}

	const key = boneNames.join("#");
	let skin = glbSkins.get(key);

	if (!skin) {
		skin = new Skin(device, ibp, boneNames);
		glbSkins.set(key, skin);
	}

	return skin;
};

const tempMat = new Mat4();
const tempVec$1 = new Vec3();

const createMesh = function createMesh(device, gltfMesh, accessors, bufferViews, callback, flipV, vertexBufferDict) {
	const meshes = [];
	gltfMesh.primitives.forEach(function (primitive) {
		let primitiveType, vertexBuffer, numIndices;
		let indices = null;
		let canUseMorph = true;

		if (primitive.hasOwnProperty('extensions')) {
			const extensions = primitive.extensions;

			if (extensions.hasOwnProperty('KHR_draco_mesh_compression')) {
				const decoderModule = window.DracoDecoderModule;

				if (decoderModule) {
					const extDraco = extensions.KHR_draco_mesh_compression;

					if (extDraco.hasOwnProperty('attributes')) {
						const uint8Buffer = bufferViews[extDraco.bufferView];
						const buffer = new decoderModule.DecoderBuffer();
						buffer.Init(uint8Buffer, uint8Buffer.length);
						const decoder = new decoderModule.Decoder();
						const geometryType = decoder.GetEncodedGeometryType(buffer);
						let outputGeometry, status;

						switch (geometryType) {
							case decoderModule.POINT_CLOUD:
								primitiveType = PRIMITIVE_POINTS;
								outputGeometry = new decoderModule.PointCloud();
								status = decoder.DecodeBufferToPointCloud(buffer, outputGeometry);
								break;

							case decoderModule.TRIANGULAR_MESH:
								primitiveType = PRIMITIVE_TRIANGLES;
								outputGeometry = new decoderModule.Mesh();
								status = decoder.DecodeBufferToMesh(buffer, outputGeometry);
								break;

							case decoderModule.INVALID_GEOMETRY_TYPE:
						}

						if (!status || !status.ok() || outputGeometry.ptr == 0) {
							callback("Failed to decode draco compressed asset: " + (status ? status.error_msg() : 'Mesh asset - invalid draco compressed geometry type: ' + geometryType));
							return;
						}

						const numFaces = outputGeometry.num_faces();

						if (geometryType === decoderModule.TRIANGULAR_MESH) {
							const bit32 = outputGeometry.num_points() > 65535;
							numIndices = numFaces * 3;
							const dataSize = numIndices * (bit32 ? 4 : 2);

							const ptr = decoderModule._malloc(dataSize);

							if (bit32) {
								decoder.GetTrianglesUInt32Array(outputGeometry, dataSize, ptr);
								indices = new Uint32Array(decoderModule.HEAPU32.buffer, ptr, numIndices).slice();
							} else {
								decoder.GetTrianglesUInt16Array(outputGeometry, dataSize, ptr);
								indices = new Uint16Array(decoderModule.HEAPU16.buffer, ptr, numIndices).slice();
							}

							decoderModule._free(ptr);
						}

						vertexBuffer = createVertexBufferDraco(device, outputGeometry, extDraco, decoder, decoderModule, indices, flipV);
						decoderModule.destroy(outputGeometry);
						decoderModule.destroy(decoder);
						decoderModule.destroy(buffer);
						canUseMorph = false;
					}
				}
			}
		}

		if (!vertexBuffer) {
			indices = primitive.hasOwnProperty('indices') ? getAccessorData(accessors[primitive.indices], bufferViews, true) : null;
			vertexBuffer = createVertexBuffer(device, primitive.attributes, indices, accessors, bufferViews, flipV, vertexBufferDict);
			primitiveType = getPrimitiveType(primitive);
		}

		let mesh = null;

		if (vertexBuffer) {
			mesh = new Mesh(device);
			mesh.vertexBuffer = vertexBuffer;
			mesh.primitive[0].type = primitiveType;
			mesh.primitive[0].base = 0;
			mesh.primitive[0].indexed = indices !== null;

			if (indices !== null) {
				let indexFormat;

				if (indices instanceof Uint8Array) {
					indexFormat = INDEXFORMAT_UINT8;
				} else if (indices instanceof Uint16Array) {
					indexFormat = INDEXFORMAT_UINT16;
				} else {
					indexFormat = INDEXFORMAT_UINT32;
				}

				if (indexFormat === INDEXFORMAT_UINT32 && !device.extUintElement) {
					indexFormat = INDEXFORMAT_UINT16;
					indices = new Uint16Array(indices);
				}

				const indexBuffer = new IndexBuffer(device, indexFormat, indices.length, BUFFER_STATIC, indices);
				mesh.indexBuffer[0] = indexBuffer;
				mesh.primitive[0].count = indices.length;
			} else {
				mesh.primitive[0].count = vertexBuffer.numVertices;
			}

			mesh.materialIndex = primitive.material;
			let accessor = accessors[primitive.attributes.POSITION];
			mesh.aabb = getAccessorBoundingBox(accessor);

			if (canUseMorph && primitive.hasOwnProperty('targets')) {
				const targets = [];
				primitive.targets.forEach(function (target, index) {
					const options = {};

					if (target.hasOwnProperty('POSITION')) {
						accessor = accessors[target.POSITION];
						options.deltaPositions = getAccessorDataFloat32(accessor, bufferViews);
						options.deltaPositionsType = TYPE_FLOAT32;
						options.aabb = getAccessorBoundingBox(accessor);
					}

					if (target.hasOwnProperty('NORMAL')) {
						accessor = accessors[target.NORMAL];
						options.deltaNormals = getAccessorDataFloat32(accessor, bufferViews);
						options.deltaNormalsType = TYPE_FLOAT32;
					}

					if (gltfMesh.hasOwnProperty('extras') && gltfMesh.extras.hasOwnProperty('targetNames')) {
						options.name = gltfMesh.extras.targetNames[index];
					} else {
						options.name = index.toString(10);
					}

					if (gltfMesh.hasOwnProperty('weights')) {
						options.defaultWeight = gltfMesh.weights[index];
					}

					targets.push(new MorphTarget(options));
				});
				mesh.morph = new Morph(targets, device);
			}
		}

		meshes.push(mesh);
	});
	return meshes;
};

const createMaterial = function createMaterial(gltfMaterial, textures, flipV) {
	const glossChunk = ["#ifdef MAPFLOAT", "uniform float material_shininess;", "#endif", "", "#ifdef MAPTEXTURE", "uniform sampler2D texture_glossMap;", "#endif", "", "void getGlossiness() {", "		dGlossiness = 1.0;", "", "#ifdef MAPFLOAT", "		dGlossiness *= material_shininess;", "#endif", "", "#ifdef MAPTEXTURE", "		dGlossiness *= texture2D(texture_glossMap, $UV).$CH;", "#endif", "", "#ifdef MAPVERTEX", "		dGlossiness *= saturate(vVertexColor.$VC);", "#endif", "", "		dGlossiness = 1.0 - dGlossiness;", "", "		dGlossiness += 0.0000001;", "}"].join('\n');
	const specularChunk = ["#ifdef MAPCOLOR", "uniform vec3 material_specular;", "#endif", "", "#ifdef MAPTEXTURE", "uniform sampler2D texture_specularMap;", "#endif", "", "void getSpecularity() {", "		dSpecularity = vec3(1.0);", "", "		#ifdef MAPCOLOR", "				dSpecularity *= material_specular;", "		#endif", "", "		#ifdef MAPTEXTURE", "				vec3 srgb = texture2D(texture_specularMap, $UV).$CH;", "				dSpecularity *= vec3(pow(srgb.r, 2.2), pow(srgb.g, 2.2), pow(srgb.b, 2.2));", "		#endif", "", "		#ifdef MAPVERTEX", "				dSpecularity *= saturate(vVertexColor.$VC);", "		#endif", "}"].join('\n');
	const clearCoatGlossChunk = ["#ifdef MAPFLOAT", "uniform float material_clearCoatGlossiness;", "#endif", "", "#ifdef MAPTEXTURE", "uniform sampler2D texture_clearCoatGlossMap;", "#endif", "", "void getClearCoatGlossiness() {", "		ccGlossiness = 1.0;", "", "#ifdef MAPFLOAT", "		ccGlossiness *= material_clearCoatGlossiness;", "#endif", "", "#ifdef MAPTEXTURE", "		ccGlossiness *= texture2D(texture_clearCoatGlossMap, $UV).$CH;", "#endif", "", "#ifdef MAPVERTEX", "		ccGlossiness *= saturate(vVertexColor.$VC);", "#endif", "", "		ccGlossiness = 1.0 - ccGlossiness;", "", "		ccGlossiness += 0.0000001;", "}"].join('\n');
	const zeros = [0, 0];
	const ones = [1, 1];

	const extractTextureTransform = function extractTextureTransform(source, material, maps) {
		var _source$extensions;

		let map;
		const texCoord = source.texCoord;

		if (texCoord) {
			for (map = 0; map < maps.length; ++map) {
				material[maps[map] + 'MapUv'] = texCoord;
			}
		}

		const textureTransform = (_source$extensions = source.extensions) == null ? void 0 : _source$extensions.KHR_texture_transform;

		if (textureTransform) {
			const offset = textureTransform.offset || zeros;
			const scale = textureTransform.scale || ones;
			const rotation = textureTransform.rotation ? -textureTransform.rotation * math.RAD_TO_DEG : 0;
			const tilingVec = new Vec2(scale[0], scale[1]);
			const offsetVec = new Vec2(offset[0], 1.0 - scale[1] - offset[1]);

			for (map = 0; map < maps.length; ++map) {
				material[`${maps[map]}MapTiling`] = tilingVec;
				material[`${maps[map]}MapOffset`] = offsetVec;
				material[`${maps[map]}MapRotation`] = rotation;
			}
		}
	};

	const material = new StandardMaterial();
	material.occludeSpecular = true;
	material.diffuseTint = true;
	material.diffuseVertexColor = true;
	material.specularTint = true;
	material.specularVertexColor = true;

	if (gltfMaterial.hasOwnProperty('name')) {
		material.name = gltfMaterial.name;
	}

	let color, texture;

	if (gltfMaterial.hasOwnProperty('extensions') && gltfMaterial.extensions.hasOwnProperty('KHR_materials_pbrSpecularGlossiness')) {
		const specData = gltfMaterial.extensions.KHR_materials_pbrSpecularGlossiness;

		if (specData.hasOwnProperty('diffuseFactor')) {
			color = specData.diffuseFactor;
			material.diffuse.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
			material.opacity = color[3];
		} else {
			material.diffuse.set(1, 1, 1);
			material.opacity = 1;
		}

		if (specData.hasOwnProperty('diffuseTexture')) {
			const diffuseTexture = specData.diffuseTexture;
			texture = textures[diffuseTexture.index];
			material.diffuseMap = texture;
			material.diffuseMapChannel = 'rgb';
			material.opacityMap = texture;
			material.opacityMapChannel = 'a';
			extractTextureTransform(diffuseTexture, material, ['diffuse', 'opacity']);
		}

		material.useMetalness = false;

		if (specData.hasOwnProperty('specularFactor')) {
			color = specData.specularFactor;
			material.specular.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
		} else {
			material.specular.set(1, 1, 1);
		}

		if (specData.hasOwnProperty('glossinessFactor')) {
			material.shininess = 100 * specData.glossinessFactor;
		} else {
			material.shininess = 100;
		}

		if (specData.hasOwnProperty('specularGlossinessTexture')) {
			const specularGlossinessTexture = specData.specularGlossinessTexture;
			material.specularMap = material.glossMap = textures[specularGlossinessTexture.index];
			material.specularMapChannel = 'rgb';
			material.glossMapChannel = 'a';
			extractTextureTransform(specularGlossinessTexture, material, ['gloss', 'metalness']);
		}

		material.chunks.specularPS = specularChunk;
	} else if (gltfMaterial.hasOwnProperty('pbrMetallicRoughness')) {
		const pbrData = gltfMaterial.pbrMetallicRoughness;

		if (pbrData.hasOwnProperty('baseColorFactor')) {
			color = pbrData.baseColorFactor;
			material.diffuse.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
			material.opacity = color[3];
		} else {
			material.diffuse.set(1, 1, 1);
			material.opacity = 1;
		}

		if (pbrData.hasOwnProperty('baseColorTexture')) {
			const baseColorTexture = pbrData.baseColorTexture;
			texture = textures[baseColorTexture.index];
			material.diffuseMap = texture;
			material.diffuseMapChannel = 'rgb';
			material.opacityMap = texture;
			material.opacityMapChannel = 'a';
			extractTextureTransform(baseColorTexture, material, ['diffuse', 'opacity']);
		}

		material.useMetalness = true;

		if (pbrData.hasOwnProperty('metallicFactor')) {
			material.metalness = pbrData.metallicFactor;
		} else {
			material.metalness = 1;
		}

		if (pbrData.hasOwnProperty('roughnessFactor')) {
			material.shininess = 100 * pbrData.roughnessFactor;
		} else {
			material.shininess = 100;
		}

		if (pbrData.hasOwnProperty('metallicRoughnessTexture')) {
			const metallicRoughnessTexture = pbrData.metallicRoughnessTexture;
			material.metalnessMap = material.glossMap = textures[metallicRoughnessTexture.index];
			material.metalnessMapChannel = 'b';
			material.glossMapChannel = 'g';
			extractTextureTransform(metallicRoughnessTexture, material, ['gloss', 'metalness']);
		}

		material.chunks.glossPS = glossChunk;
	}

	if (gltfMaterial.hasOwnProperty('normalTexture')) {
		const normalTexture = gltfMaterial.normalTexture;
		material.normalMap = textures[normalTexture.index];
		extractTextureTransform(normalTexture, material, ['normal']);

		if (normalTexture.hasOwnProperty('scale')) {
			material.bumpiness = normalTexture.scale;
		}
	}

	if (gltfMaterial.hasOwnProperty('occlusionTexture')) {
		const occlusionTexture = gltfMaterial.occlusionTexture;
		material.aoMap = textures[occlusionTexture.index];
		material.aoMapChannel = 'r';
		extractTextureTransform(occlusionTexture, material, ['ao']);
	}

	if (gltfMaterial.hasOwnProperty('emissiveFactor')) {
		color = gltfMaterial.emissiveFactor;
		material.emissive.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
		material.emissiveTint = true;
	} else {
		material.emissive.set(0, 0, 0);
		material.emissiveTint = false;
	}

	if (gltfMaterial.hasOwnProperty('emissiveTexture')) {
		const emissiveTexture = gltfMaterial.emissiveTexture;
		material.emissiveMap = textures[emissiveTexture.index];
		extractTextureTransform(emissiveTexture, material, ['emissive']);
	}

	if (gltfMaterial.hasOwnProperty('alphaMode')) {
		switch (gltfMaterial.alphaMode) {
			case 'MASK':
				material.blendType = BLEND_NONE;

				if (gltfMaterial.hasOwnProperty('alphaCutoff')) {
					material.alphaTest = gltfMaterial.alphaCutoff;
				} else {
					material.alphaTest = 0.5;
				}

				break;

			case 'BLEND':
				material.blendType = BLEND_NORMAL;
				break;

			default:
			case 'OPAQUE':
				material.blendType = BLEND_NONE;
				break;
		}
	} else {
		material.blendType = BLEND_NONE;
	}

	if (gltfMaterial.hasOwnProperty('doubleSided')) {
		material.twoSidedLighting = gltfMaterial.doubleSided;
		material.cull = gltfMaterial.doubleSided ? CULLFACE_NONE : CULLFACE_BACK;
	} else {
		material.twoSidedLighting = false;
		material.cull = CULLFACE_BACK;
	}

	if (gltfMaterial.hasOwnProperty('extensions') && gltfMaterial.extensions.hasOwnProperty('KHR_materials_clearcoat')) {
		const ccData = gltfMaterial.extensions.KHR_materials_clearcoat;

		if (ccData.hasOwnProperty('clearcoatFactor')) {
			material.clearCoat = ccData.clearcoatFactor * 0.25;
		} else {
			material.clearCoat = 0;
		}

		if (ccData.hasOwnProperty('clearcoatTexture')) {
			const clearcoatTexture = ccData.clearcoatTexture;
			material.clearCoatMap = textures[clearcoatTexture.index];
			material.clearCoatMapChannel = 'r';
			extractTextureTransform(clearcoatTexture, material, ['clearCoat']);
		}

		if (ccData.hasOwnProperty('clearcoatRoughnessFactor')) {
			material.clearCoatGlossiness = ccData.clearcoatRoughnessFactor;
		} else {
			material.clearCoatGlossiness = 0;
		}

		if (ccData.hasOwnProperty('clearcoatRoughnessTexture')) {
			const clearcoatRoughnessTexture = ccData.clearcoatRoughnessTexture;
			material.clearCoatGlossMap = textures[clearcoatRoughnessTexture.index];
			material.clearCoatGlossMapChannel = 'g';
			extractTextureTransform(clearcoatRoughnessTexture, material, ['clearCoatGloss']);
		}

		if (ccData.hasOwnProperty('clearcoatNormalTexture')) {
			const clearcoatNormalTexture = ccData.clearcoatNormalTexture;
			material.clearCoatNormalMap = textures[clearcoatNormalTexture.index];
			extractTextureTransform(clearcoatNormalTexture, material, ['clearCoatNormal']);

			if (clearcoatNormalTexture.hasOwnProperty('scale')) {
				material.clearCoatBumpiness = clearcoatNormalTexture.scale;
			}
		}

		material.chunks.clearCoatGlossPS = clearCoatGlossChunk;
	}

	if (gltfMaterial.hasOwnProperty('extensions') && gltfMaterial.extensions.hasOwnProperty('KHR_materials_unlit')) {
		material.useLighting = false;
		material.emissive.copy(material.diffuse);
		material.emissiveTint = material.diffuseTint;
		material.emissiveMap = material.diffuseMap;
		material.emissiveMapUv = material.diffuseMapUv;
		material.emissiveMapTiling.copy(material.diffuseMapTiling);
		material.emissiveMapOffset.copy(material.diffuseMapOffset);
		material.emissiveMapChannel = material.diffuseMapChannel;
		material.emissiveVertexColor = material.diffuseVertexColor;
		material.emissiveVertexColorChannel = material.diffuseVertexColorChannel;
		material.diffuse.set(0, 0, 0);
		material.diffuseTint = false;
		material.diffuseMap = null;
		material.diffuseVertexColor = false;
	}

	material.update();
	return material;
};

const createAnimation = function createAnimation(gltfAnimation, animationIndex, gltfAccessors, bufferViews, nodes) {
	const createAnimData = function createAnimData(gltfAccessor) {
		return new AnimData(getNumComponents(gltfAccessor.type), getAccessorDataFloat32(gltfAccessor, bufferViews));
	};

	const interpMap = {
		"STEP": INTERPOLATION_STEP,
		"LINEAR": INTERPOLATION_LINEAR,
		"CUBICSPLINE": INTERPOLATION_CUBIC
	};
	const inputMap = {};
	const inputs = [];
	const outputMap = {};
	const outputs = [];
	const curves = [];
	let i;

	for (i = 0; i < gltfAnimation.samplers.length; ++i) {
		const sampler = gltfAnimation.samplers[i];

		if (!inputMap.hasOwnProperty(sampler.input)) {
			inputMap[sampler.input] = inputs.length;
			inputs.push(createAnimData(gltfAccessors[sampler.input]));
		}

		if (!outputMap.hasOwnProperty(sampler.output)) {
			outputMap[sampler.output] = outputs.length;
			outputs.push(createAnimData(gltfAccessors[sampler.output]));
		}

		const interpolation = sampler.hasOwnProperty('interpolation') && interpMap.hasOwnProperty(sampler.interpolation) ? interpMap[sampler.interpolation] : INTERPOLATION_LINEAR;
		curves.push(new AnimCurve([], inputMap[sampler.input], outputMap[sampler.output], interpolation));
	}

	const quatArrays = [];
	const transformSchema = {
		'translation': 'localPosition',
		'rotation': 'localRotation',
		'scale': 'localScale',
		'weights': 'weights'
	};

	const constructNodePath = node => {
		const path = [];

		while (node) {
			path.unshift(node.name);
			node = node.parent;
		}

		return path;
	};

	for (i = 0; i < gltfAnimation.channels.length; ++i) {
		const channel = gltfAnimation.channels[i];
		const target = channel.target;
		const curve = curves[channel.sampler];
		const node = nodes[target.node];
		const entityPath = constructNodePath(node);

		curve._paths.push({
			entityPath: entityPath,
			component: 'graph',
			propertyPath: [transformSchema[target.path]]
		});

		if (target.path.startsWith('rotation') && curve.interpolation !== INTERPOLATION_CUBIC) {
			quatArrays.push(curve.output);
		} else if (target.path.startsWith('weights')) {
			outputs[curve.output]._components = outputs[curve.output].data.length / inputs[curve.input].data.length;
		}
	}

	quatArrays.sort();
	let prevIndex = null;
	let data;

	for (i = 0; i < quatArrays.length; ++i) {
		const index = quatArrays[i];

		if (i === 0 || index !== prevIndex) {
			data = outputs[index];

			if (data.components === 4) {
				const d = data.data;
				const len = d.length - 4;

				for (let j = 0; j < len; j += 4) {
					const dp = d[j + 0] * d[j + 4] + d[j + 1] * d[j + 5] + d[j + 2] * d[j + 6] + d[j + 3] * d[j + 7];

					if (dp < 0) {
						d[j + 4] *= -1;
						d[j + 5] *= -1;
						d[j + 6] *= -1;
						d[j + 7] *= -1;
					}
				}
			}

			prevIndex = index;
		}
	}

	let duration = 0;

	for (i = 0; i < inputs.length; i++) {
		data = inputs[i]._data;
		duration = Math.max(duration, data.length === 0 ? 0 : data[data.length - 1]);
	}

	return new AnimTrack(gltfAnimation.hasOwnProperty('name') ? gltfAnimation.name : "animation_" + animationIndex, duration, inputs, outputs, curves);
};

const createNode = function createNode(gltfNode, nodeIndex) {
	const entity = new GraphNode();

	if (gltfNode.hasOwnProperty('name') && gltfNode.name.length > 0) {
		entity.name = gltfNode.name;
	} else {
		entity.name = "node_" + nodeIndex;
	}

	if (gltfNode.hasOwnProperty('matrix')) {
		tempMat.data.set(gltfNode.matrix);
		tempMat.getTranslation(tempVec$1);
		entity.setLocalPosition(tempVec$1);
		tempMat.getEulerAngles(tempVec$1);
		entity.setLocalEulerAngles(tempVec$1);
		tempMat.getScale(tempVec$1);
		entity.setLocalScale(tempVec$1);
	}

	if (gltfNode.hasOwnProperty('rotation')) {
		const r = gltfNode.rotation;
		entity.setLocalRotation(r[0], r[1], r[2], r[3]);
	}

	if (gltfNode.hasOwnProperty('translation')) {
		const t = gltfNode.translation;
		entity.setLocalPosition(t[0], t[1], t[2]);
	}

	if (gltfNode.hasOwnProperty('scale')) {
		const s = gltfNode.scale;
		entity.setLocalScale(s[0], s[1], s[2]);
	}

	return entity;
};

const createCamera = function createCamera(gltfCamera, node) {
	const projection = gltfCamera.type === "orthographic" ? PROJECTION_ORTHOGRAPHIC : PROJECTION_PERSPECTIVE;
	const gltfProperties = projection === PROJECTION_ORTHOGRAPHIC ? gltfCamera.orthographic : gltfCamera.perspective;
	const componentData = {
		enabled: false,
		projection: projection,
		nearClip: gltfProperties.znear,
		aspectRatioMode: ASPECT_AUTO
	};

	if (gltfProperties.zfar) {
		componentData.farClip = gltfProperties.zfar;
	}

	if (projection === PROJECTION_ORTHOGRAPHIC) {
		componentData.orthoHeight = 0.5 * gltfProperties.ymag;

		if (gltfProperties.ymag) {
			componentData.aspectRatioMode = ASPECT_MANUAL;
			componentData.aspectRatio = gltfProperties.xmag / gltfProperties.ymag;
		}
	} else {
		componentData.fov = gltfProperties.yfov * math.RAD_TO_DEG;

		if (gltfProperties.aspectRatio) {
			componentData.aspectRatioMode = ASPECT_MANUAL;
			componentData.aspectRatio = gltfProperties.aspectRatio;
		}
	}

	const cameraEntity = new Entity(gltfCamera.name);
	cameraEntity.addComponent("camera", componentData);
	return cameraEntity;
};

const createLight = function createLight(gltfLight, node) {
	const lightProps = {
		enabled: false,
		type: gltfLight.type === "point" ? "omni" : gltfLight.type,
		color: gltfLight.hasOwnProperty('color') ? new Color(gltfLight.color) : Color.WHITE,
		range: gltfLight.hasOwnProperty('range') ? gltfLight.range : 9999,
		falloffMode: LIGHTFALLOFF_INVERSESQUARED,
		intensity: gltfLight.hasOwnProperty('intensity') ? math.clamp(gltfLight.intensity, 0, 2) : 1
	};

	if (gltfLight.hasOwnProperty('spot')) {
		lightProps.innerConeAngle = gltfLight.spot.hasOwnProperty('innerConeAngle') ? gltfLight.spot.innerConeAngle * math.RAD_TO_DEG : 0;
		lightProps.outerConeAngle = gltfLight.spot.hasOwnProperty('outerConeAngle') ? gltfLight.spot.outerConeAngle * math.RAD_TO_DEG : Math.PI / 4;
	}

	const lightEntity = new Entity(node.name);
	lightEntity.rotateLocal(90, 0, 0);
	lightEntity.addComponent("light", lightProps);
	return lightEntity;
};

const createSkins = function createSkins(device, gltf, nodes, bufferViews) {
	if (!gltf.hasOwnProperty('skins') || gltf.skins.length === 0) {
		return [];
	}

	const glbSkins = new Map();
	return gltf.skins.map(function (gltfSkin) {
		return createSkin(device, gltfSkin, gltf.accessors, bufferViews, nodes, glbSkins);
	});
};

const createMeshes = function createMeshes(device, gltf, bufferViews, callback, flipV) {
	if (!gltf.hasOwnProperty('meshes') || gltf.meshes.length === 0 || !gltf.hasOwnProperty('accessors') || gltf.accessors.length === 0 || !gltf.hasOwnProperty('bufferViews') || gltf.bufferViews.length === 0) {
		return [];
	}

	const vertexBufferDict = {};
	return gltf.meshes.map(function (gltfMesh) {
		return createMesh(device, gltfMesh, gltf.accessors, bufferViews, callback, flipV, vertexBufferDict);
	});
};

const createMaterials = function createMaterials(gltf, textures, options, flipV) {
	if (!gltf.hasOwnProperty('materials') || gltf.materials.length === 0) {
		return [];
	}

	const preprocess = options && options.material && options.material.preprocess;
	const process = options && options.material && options.material.process || createMaterial;
	const postprocess = options && options.material && options.material.postprocess;
	return gltf.materials.map(function (gltfMaterial) {
		if (preprocess) {
			preprocess(gltfMaterial);
		}

		const material = process(gltfMaterial, textures, flipV);

		if (postprocess) {
			postprocess(gltfMaterial, material);
		}

		return material;
	});
};

const createAnimations = function createAnimations(gltf, nodes, bufferViews, options) {
	if (!gltf.hasOwnProperty('animations') || gltf.animations.length === 0) {
		return [];
	}

	const preprocess = options && options.animation && options.animation.preprocess;
	const postprocess = options && options.animation && options.animation.postprocess;
	return gltf.animations.map(function (gltfAnimation, index) {
		if (preprocess) {
			preprocess(gltfAnimation);
		}

		const animation = createAnimation(gltfAnimation, index, gltf.accessors, bufferViews, nodes);

		if (postprocess) {
			postprocess(gltfAnimation, animation);
		}

		return animation;
	});
};

const createNodes = function createNodes(gltf, options) {
	if (!gltf.hasOwnProperty('nodes') || gltf.nodes.length === 0) {
		return [];
	}

	const preprocess = options && options.node && options.node.preprocess;
	const process = options && options.node && options.node.process || createNode;
	const postprocess = options && options.node && options.node.postprocess;
	const nodes = gltf.nodes.map(function (gltfNode, index) {
		if (preprocess) {
			preprocess(gltfNode);
		}

		const node = process(gltfNode, index);

		if (postprocess) {
			postprocess(gltfNode, node);
		}

		return node;
	});

	for (let i = 0; i < gltf.nodes.length; ++i) {
		const gltfNode = gltf.nodes[i];

		if (gltfNode.hasOwnProperty('children')) {
			const parent = nodes[i];
			const uniqueNames = {};

			for (let j = 0; j < gltfNode.children.length; ++j) {
				const child = nodes[gltfNode.children[j]];

				if (!child.parent) {
					if (uniqueNames.hasOwnProperty(child.name)) {
						child.name += uniqueNames[child.name]++;
					} else {
						uniqueNames[child.name] = 1;
					}

					parent.addChild(child);
				}
			}
		}
	}

	return nodes;
};

const createScenes = function createScenes(gltf, nodes) {
	var _gltf$scenes$0$nodes;

	const scenes = [];
	const count = gltf.scenes.length;

	if (count === 1 && ((_gltf$scenes$0$nodes = gltf.scenes[0].nodes) == null ? void 0 : _gltf$scenes$0$nodes.length) === 1) {
		const nodeIndex = gltf.scenes[0].nodes[0];
		scenes.push(nodes[nodeIndex]);
	} else {
		for (let i = 0; i < count; i++) {
			const scene = gltf.scenes[i];

			if (scene.nodes) {
				const sceneRoot = new GraphNode(scene.name);

				for (let n = 0; n < scene.nodes.length; n++) {
					const childNode = nodes[scene.nodes[n]];
					sceneRoot.addChild(childNode);
				}

				scenes.push(sceneRoot);
			}
		}
	}

	return scenes;
};

const createCameras = function createCameras(gltf, nodes, options) {
	let cameras = null;

	if (gltf.hasOwnProperty('nodes') && gltf.hasOwnProperty('cameras') && gltf.cameras.length > 0) {
		const preprocess = options && options.camera && options.camera.preprocess;
		const process = options && options.camera && options.camera.process || createCamera;
		const postprocess = options && options.camera && options.camera.postprocess;
		gltf.nodes.forEach(function (gltfNode, nodeIndex) {
			if (gltfNode.hasOwnProperty('camera')) {
				const gltfCamera = gltf.cameras[gltfNode.camera];

				if (gltfCamera) {
					if (preprocess) {
						preprocess(gltfCamera);
					}

					const camera = process(gltfCamera, nodes[nodeIndex]);

					if (postprocess) {
						postprocess(gltfCamera, camera);
					}

					if (camera) {
						if (!cameras) cameras = new Map();
						cameras.set(gltfNode, camera);
					}
				}
			}
		});
	}

	return cameras;
};

const createLights = function createLights(gltf, nodes, options) {
	let lights = null;

	if (gltf.hasOwnProperty('nodes') && gltf.hasOwnProperty('extensions') && gltf.extensions.hasOwnProperty('KHR_lights_punctual') && gltf.extensions.KHR_lights_punctual.hasOwnProperty('lights')) {
		const gltfLights = gltf.extensions.KHR_lights_punctual.lights;

		if (gltfLights.length) {
			const preprocess = options && options.light && options.light.preprocess;
			const process = options && options.light && options.light.process || createLight;
			const postprocess = options && options.light && options.light.postprocess;
			gltf.nodes.forEach(function (gltfNode, nodeIndex) {
				if (gltfNode.hasOwnProperty('extensions') && gltfNode.extensions.hasOwnProperty('KHR_lights_punctual') && gltfNode.extensions.KHR_lights_punctual.hasOwnProperty('light')) {
					const lightIndex = gltfNode.extensions.KHR_lights_punctual.light;
					const gltfLight = gltfLights[lightIndex];

					if (gltfLight) {
						if (preprocess) {
							preprocess(gltfLight);
						}

						const light = process(gltfLight, nodes[nodeIndex]);

						if (postprocess) {
							postprocess(gltfLight, light);
						}

						if (light) {
							if (!lights) lights = new Map();
							lights.set(gltfNode, light);
						}
					}
				}
			});
		}
	}

	return lights;
};

const linkSkins = function linkSkins(gltf, renders, skins) {
	gltf.nodes.forEach(gltfNode => {
		if (gltfNode.hasOwnProperty('mesh') && gltfNode.hasOwnProperty('skin')) {
			const meshGroup = renders[gltfNode.mesh].meshes;
			meshGroup.forEach(mesh => {
				mesh.skin = skins[gltfNode.skin];
			});
		}
	});
};

const createResources = function createResources(device, gltf, bufferViews, textureAssets, options, callback) {
	const preprocess = options && options.global && options.global.preprocess;
	const postprocess = options && options.global && options.global.postprocess;

	if (preprocess) {
		preprocess(gltf);
	}

	const flipV = gltf.asset && gltf.asset.generator === 'PlayCanvas';
	const nodes = createNodes(gltf, options);
	const scenes = createScenes(gltf, nodes);
	const lights = createLights(gltf, nodes, options);
	const cameras = createCameras(gltf, nodes, options);
	const animations = createAnimations(gltf, nodes, bufferViews, options);
	const materials = createMaterials(gltf, textureAssets.map(function (textureAsset) {
		return textureAsset.resource;
	}), options, flipV);
	const meshes = createMeshes(device, gltf, bufferViews, callback, flipV);
	const skins = createSkins(device, gltf, nodes, bufferViews);
	const renders = [];

	for (let i = 0; i < meshes.length; i++) {
		renders[i] = new Render();
		renders[i].meshes = meshes[i];
	}

	linkSkins(gltf, renders, skins);
	const result = new GlbResources(gltf);
	result.nodes = nodes;
	result.scenes = scenes;
	result.animations = animations;
	result.textures = textureAssets;
	result.materials = materials;
	result.renders = renders;
	result.skins = skins;
	result.lights = lights;
	result.cameras = cameras;

	if (postprocess) {
		postprocess(gltf, result);
	}

	callback(null, result);
};

const applySampler = function applySampler(texture, gltfSampler) {
	const getFilter = function getFilter(filter, defaultValue) {
		switch (filter) {
			case 9728:
				return FILTER_NEAREST;

			case 9729:
				return FILTER_LINEAR;

			case 9984:
				return FILTER_NEAREST_MIPMAP_NEAREST;

			case 9985:
				return FILTER_LINEAR_MIPMAP_NEAREST;

			case 9986:
				return FILTER_NEAREST_MIPMAP_LINEAR;

			case 9987:
				return FILTER_LINEAR_MIPMAP_LINEAR;

			default:
				return defaultValue;
		}
	};

	const getWrap = function getWrap(wrap, defaultValue) {
		switch (wrap) {
			case 33071:
				return ADDRESS_CLAMP_TO_EDGE;

			case 33648:
				return ADDRESS_MIRRORED_REPEAT;

			case 10497:
				return ADDRESS_REPEAT;

			default:
				return defaultValue;
		}
	};

	if (texture) {
		gltfSampler = gltfSampler || {};
		texture.minFilter = getFilter(gltfSampler.minFilter, FILTER_LINEAR_MIPMAP_LINEAR);
		texture.magFilter = getFilter(gltfSampler.magFilter, FILTER_LINEAR);
		texture.addressU = getWrap(gltfSampler.wrapS, ADDRESS_REPEAT);
		texture.addressV = getWrap(gltfSampler.wrapT, ADDRESS_REPEAT);
	}
};

let gltfTextureUniqueId = 0;

const loadImageAsync = function loadImageAsync(gltfImage, index, bufferViews, urlBase, registry, options, callback) {
	const preprocess = options && options.image && options.image.preprocess;

	const processAsync = options && options.image && options.image.processAsync || function (gltfImage, callback) {
		callback(null, null);
	};

	const postprocess = options && options.image && options.image.postprocess;

	const onLoad = function onLoad(textureAsset) {
		if (postprocess) {
			postprocess(gltfImage, textureAsset);
		}

		callback(null, textureAsset);
	};

	const mimeTypeFileExtensions = {
		'image/png': 'png',
		'image/jpeg': 'jpg',
		'image/basis': 'basis',
		'image/ktx': 'ktx',
		'image/ktx2': 'ktx2',
		'image/vnd-ms.dds': 'dds'
	};

	const loadTexture = function loadTexture(url, bufferView, mimeType, options) {
		const name = (gltfImage.name || 'gltf-texture') + '-' + gltfTextureUniqueId++;
		const file = {
			url: url || name
		};

		if (bufferView) {
			file.contents = bufferView.slice(0).buffer;
		}

		if (mimeType) {
			const extension = mimeTypeFileExtensions[mimeType];

			if (extension) {
				file.filename = file.url + '.' + extension;
			}
		}

		const asset = new Asset(name, 'texture', file, null, options);
		asset.on('load', onLoad);
		asset.on('error', callback);
		registry.add(asset);
		registry.load(asset);
	};

	if (preprocess) {
		preprocess(gltfImage);
	}

	processAsync(gltfImage, function (err, textureAsset) {
		if (err) {
			callback(err);
		} else if (textureAsset) {
			onLoad(textureAsset);
		} else {
			if (gltfImage.hasOwnProperty('uri')) {
				if (isDataURI(gltfImage.uri)) {
					loadTexture(gltfImage.uri, null, getDataURIMimeType(gltfImage.uri), null);
				} else {
					loadTexture(path.join(urlBase, gltfImage.uri), null, null, {
						crossOrigin: "anonymous"
					});
				}
			} else if (gltfImage.hasOwnProperty('bufferView') && gltfImage.hasOwnProperty('mimeType')) {
				loadTexture(null, bufferViews[gltfImage.bufferView], gltfImage.mimeType, null);
			} else {
				callback("Invalid image found in gltf (neither uri or bufferView found). index=" + index);
			}
		}
	});
};

const loadTexturesAsync = function loadTexturesAsync(gltf, bufferViews, urlBase, registry, options, callback) {
	if (!gltf.hasOwnProperty('images') || gltf.images.length === 0 || !gltf.hasOwnProperty('textures') || gltf.textures.length === 0) {
		callback(null, []);
		return;
	}

	const preprocess = options && options.texture && options.texture.preprocess;

	const processAsync = options && options.texture && options.texture.processAsync || function (gltfTexture, gltfImages, callback) {
		callback(null, null);
	};

	const postprocess = options && options.texture && options.texture.postprocess;
	const assets = [];
	const textures = [];
	let remaining = gltf.textures.length;

	const onLoad = function onLoad(textureIndex, imageIndex) {
		if (!textures[imageIndex]) {
			textures[imageIndex] = [];
		}

		textures[imageIndex].push(textureIndex);

		if (--remaining === 0) {
			const result = [];
			textures.forEach(function (textureList, imageIndex) {
				textureList.forEach(function (textureIndex, index) {
					const textureAsset = index === 0 ? assets[imageIndex] : cloneTextureAsset(assets[imageIndex]);
					applySampler(textureAsset.resource, (gltf.samplers || [])[gltf.textures[textureIndex].sampler]);
					result[textureIndex] = textureAsset;

					if (postprocess) {
						postprocess(gltf.textures[textureIndex], textureAsset);
					}
				});
			});
			callback(null, result);
		}
	};

	for (let i = 0; i < gltf.textures.length; ++i) {
		const gltfTexture = gltf.textures[i];

		if (preprocess) {
			preprocess(gltfTexture);
		}

		processAsync(gltfTexture, gltf.images, function (i, gltfTexture, err, gltfImageIndex) {
			if (err) {
				callback(err);
			} else {
				if (gltfImageIndex === undefined || gltfImageIndex === null) {
					var _gltfTexture$extensio, _gltfTexture$extensio2;

					gltfImageIndex = gltfTexture == null ? void 0 : (_gltfTexture$extensio = gltfTexture.extensions) == null ? void 0 : (_gltfTexture$extensio2 = _gltfTexture$extensio.KHR_texture_basisu) == null ? void 0 : _gltfTexture$extensio2.source;

					if (gltfImageIndex === undefined) {
						gltfImageIndex = gltfTexture.source;
					}
				}

				if (assets[gltfImageIndex]) {
					onLoad(i, gltfImageIndex);
				} else {
					const gltfImage = gltf.images[gltfImageIndex];
					loadImageAsync(gltfImage, i, bufferViews, urlBase, registry, options, function (err, textureAsset) {
						if (err) {
							callback(err);
						} else {
							assets[gltfImageIndex] = textureAsset;
							onLoad(i, gltfImageIndex);
						}
					});
				}
			}
		}.bind(null, i, gltfTexture));
	}
};

const loadBuffersAsync = function loadBuffersAsync(gltf, binaryChunk, urlBase, options, callback) {
	const result = [];

	if (!gltf.buffers || gltf.buffers.length === 0) {
		callback(null, result);
		return;
	}

	const preprocess = options && options.buffer && options.buffer.preprocess;

	const processAsync = options && options.buffer && options.buffer.processAsync || function (gltfBuffer, callback) {
		callback(null, null);
	};

	const postprocess = options && options.buffer && options.buffer.postprocess;
	let remaining = gltf.buffers.length;

	const onLoad = function onLoad(index, buffer) {
		result[index] = buffer;

		if (postprocess) {
			postprocess(gltf.buffers[index], buffer);
		}

		if (--remaining === 0) {
			callback(null, result);
		}
	};

	for (let i = 0; i < gltf.buffers.length; ++i) {
		const gltfBuffer = gltf.buffers[i];

		if (preprocess) {
			preprocess(gltfBuffer);
		}

		processAsync(gltfBuffer, function (i, gltfBuffer, err, arrayBuffer) {
			if (err) {
				callback(err);
			} else if (arrayBuffer) {
				onLoad(i, new Uint8Array(arrayBuffer));
			} else {
				if (gltfBuffer.hasOwnProperty('uri')) {
					if (isDataURI(gltfBuffer.uri)) {
						const byteString = atob(gltfBuffer.uri.split(',')[1]);
						const binaryArray = new Uint8Array(byteString.length);

						for (let j = 0; j < byteString.length; j++) {
							binaryArray[j] = byteString.charCodeAt(j);
						}

						onLoad(i, binaryArray);
					} else {
						http.get(path.join(urlBase, gltfBuffer.uri), {
							cache: true,
							responseType: 'arraybuffer',
							retry: false
						}, function (i, err, result) {
							if (err) {
								callback(err);
							} else {
								onLoad(i, new Uint8Array(result));
							}
						}.bind(null, i));
					}
				} else {
					onLoad(i, binaryChunk);
				}
			}
		}.bind(null, i, gltfBuffer));
	}
};

const parseGltf = function parseGltf(gltfChunk, callback) {
	const decodeBinaryUtf8 = function decodeBinaryUtf8(array) {
		if (typeof TextDecoder !== 'undefined') {
			return new TextDecoder().decode(array);
		}

		let str = "";

		for (let i = 0; i < array.length; i++) {
			str += String.fromCharCode(array[i]);
		}

		return decodeURIComponent(escape(str));
	};

	const gltf = JSON.parse(decodeBinaryUtf8(gltfChunk));

	if (gltf.asset && gltf.asset.version && parseFloat(gltf.asset.version) < 2) {
		callback(`Invalid gltf version. Expected version 2.0 or above but found version '${gltf.asset.version}'.`);
		return;
	}

	callback(null, gltf);
};

const parseGlb = function parseGlb(glbData, callback) {
	const data = glbData instanceof ArrayBuffer ? new DataView(glbData) : new DataView(glbData.buffer, glbData.byteOffset, glbData.byteLength);
	const magic = data.getUint32(0, true);
	const version = data.getUint32(4, true);
	const length = data.getUint32(8, true);

	if (magic !== 0x46546C67) {
		callback("Invalid magic number found in glb header. Expected 0x46546C67, found 0x" + magic.toString(16));
		return;
	}

	if (version !== 2) {
		callback("Invalid version number found in glb header. Expected 2, found " + version);
		return;
	}

	if (length <= 0 || length > data.byteLength) {
		callback("Invalid length found in glb header. Found " + length);
		return;
	}

	const chunks = [];
	let offset = 12;

	while (offset < length) {
		const chunkLength = data.getUint32(offset, true);

		if (offset + chunkLength + 8 > data.byteLength) {
			throw new Error("Invalid chunk length found in glb. Found " + chunkLength);
		}

		const chunkType = data.getUint32(offset + 4, true);
		const chunkData = new Uint8Array(data.buffer, data.byteOffset + offset + 8, chunkLength);
		chunks.push({
			length: chunkLength,
			type: chunkType,
			data: chunkData
		});
		offset += chunkLength + 8;
	}

	if (chunks.length !== 1 && chunks.length !== 2) {
		callback("Invalid number of chunks found in glb file.");
		return;
	}

	if (chunks[0].type !== 0x4E4F534A) {
		callback("Invalid chunk type found in glb file. Expected 0x4E4F534A, found 0x" + chunks[0].type.toString(16));
		return;
	}

	if (chunks.length > 1 && chunks[1].type !== 0x004E4942) {
		callback("Invalid chunk type found in glb file. Expected 0x004E4942, found 0x" + chunks[1].type.toString(16));
		return;
	}

	callback(null, {
		gltfChunk: chunks[0].data,
		binaryChunk: chunks.length === 2 ? chunks[1].data : null
	});
};

const parseChunk = function parseChunk(filename, data, callback) {
	if (filename && filename.toLowerCase().endsWith('.glb')) {
		parseGlb(data, callback);
	} else {
		callback(null, {
			gltfChunk: data,
			binaryChunk: null
		});
	}
};

const parseBufferViewsAsync = function parseBufferViewsAsync(gltf, buffers, options, callback) {
	const result = [];
	const preprocess = options && options.bufferView && options.bufferView.preprocess;

	const processAsync = options && options.bufferView && options.bufferView.processAsync || function (gltfBufferView, buffers, callback) {
		callback(null, null);
	};

	const postprocess = options && options.bufferView && options.bufferView.postprocess;
	let remaining = gltf.bufferViews ? gltf.bufferViews.length : 0;

	if (!remaining) {
		callback(null, null);
		return;
	}

	const onLoad = function onLoad(index, bufferView) {
		const gltfBufferView = gltf.bufferViews[index];

		if (gltfBufferView.hasOwnProperty('byteStride')) {
			bufferView.byteStride = gltfBufferView.byteStride;
		}

		result[index] = bufferView;

		if (postprocess) {
			postprocess(gltfBufferView, bufferView);
		}

		if (--remaining === 0) {
			callback(null, result);
		}
	};

	for (let i = 0; i < gltf.bufferViews.length; ++i) {
		const gltfBufferView = gltf.bufferViews[i];

		if (preprocess) {
			preprocess(gltfBufferView);
		}

		processAsync(gltfBufferView, buffers, function (i, gltfBufferView, err, result) {
			if (err) {
				callback(err);
			} else if (result) {
				onLoad(i, result);
			} else {
				const buffer = buffers[gltfBufferView.buffer];
				const typedArray = new Uint8Array(buffer.buffer, buffer.byteOffset + (gltfBufferView.byteOffset || 0), gltfBufferView.byteLength);
				onLoad(i, typedArray);
			}
		}.bind(null, i, gltfBufferView));
	}
};

class GlbParser {
	static parseAsync(filename, urlBase, data, device, registry, options, callback) {
		parseChunk(filename, data, function (err, chunks) {
			if (err) {
				callback(err);
				return;
			}

			parseGltf(chunks.gltfChunk, function (err, gltf) {
				if (err) {
					callback(err);
					return;
				}

				loadBuffersAsync(gltf, chunks.binaryChunk, urlBase, options, function (err, buffers) {
					if (err) {
						callback(err);
						return;
					}

					parseBufferViewsAsync(gltf, buffers, options, function (err, bufferViews) {
						if (err) {
							callback(err);
							return;
						}

						loadTexturesAsync(gltf, bufferViews, urlBase, registry, options, function (err, textureAssets) {
							if (err) {
								callback(err);
								return;
							}

							createResources(device, gltf, bufferViews, textureAssets, options, callback);
						});
					});
				});
			});
		});
	}

	static parse(filename, data, device, options) {
		let result = null;
		options = options || {};
		parseChunk(filename, data, function (err, chunks) {
			if (err) {
				console.error(err);
			} else {
				parseGltf(chunks.gltfChunk, function (err, gltf) {
					if (err) {
						console.error(err);
					} else {
						parseBufferViewsAsync(gltf, [chunks.binaryChunk], options, function (err, bufferViews) {
							if (err) {
								console.error(err);
							} else {
								createResources(device, gltf, bufferViews, [], options, function (err, result_) {
									if (err) {
										console.error(err);
									} else {
										result = result_;
									}
								});
							}
						});
					}
				});
			}
		});
		return result;
	}

	constructor(device, assets, maxRetries) {
		this._device = device;
		this._assets = assets;
		this._defaultMaterial = getDefaultMaterial(device);
		this._maxRetries = maxRetries;
	}

	_getUrlWithoutParams(url) {
		return url.indexOf('?') >= 0 ? url.split('?')[0] : url;
	}

	load(url, callback, asset) {
		Asset.fetchArrayBuffer(url.load, (err, result) => {
			if (err) {
				callback(err);
			} else {
				GlbParser.parseAsync(this._getUrlWithoutParams(url.original), path.extractPath(url.load), result, this._device, asset.registry, asset.options, (err, result) => {
					if (err) {
						callback(err);
					} else {
						callback(null, new GlbContainerResource(result, asset, this._assets, this._defaultMaterial));
					}
				});
			}
		}, asset, this._maxRetries);
	}

	open(url, data, asset) {
		return data;
	}

	patch(asset, assets) {}

}

class AnimationHandler {
	constructor() {
		this.maxRetries = 0;
	}

	load(url, callback) {
		if (typeof url === 'string') {
			url = {
				load: url,
				original: url
			};
		}

		const options = {
			retry: this.maxRetries > 0,
			maxRetries: this.maxRetries
		};

		if (url.load.startsWith('blob:') || url.load.startsWith('data:')) {
			if (path.getExtension(url.original).toLowerCase() === '.glb') {
				options.responseType = Http.ResponseType.ARRAY_BUFFER;
			} else {
				options.responseType = Http.ResponseType.JSON;
			}
		}

		http.get(url.load, options, function (err, response) {
			if (err) {
				callback(`Error loading animation resource: ${url.original} [${err}]`);
			} else {
				callback(null, response);
			}
		});
	}

	open(url, data) {
		if (path.getExtension(url).toLowerCase() === '.glb') {
			const glbResources = GlbParser.parse("filename.glb", data, null);

			if (glbResources) {
				const animations = glbResources.animations;
				glbResources.destroy();
				return animations;
			}

			return null;
		}

		return this["_parseAnimationV" + data.animation.version](data);
	}

	patch(asset, assets) {}

	_parseAnimationV3(data) {
		const animData = data.animation;
		const anim = new Animation();
		anim.name = animData.name;
		anim.duration = animData.duration;

		for (let i = 0; i < animData.nodes.length; i++) {
			const node = new Node();
			const n = animData.nodes[i];
			node._name = n.name;

			for (let j = 0; j < n.keys.length; j++) {
				const k = n.keys[j];
				const t = k.time;
				const p = k.pos;
				const r = k.rot;
				const s = k.scale;
				const pos = new Vec3(p[0], p[1], p[2]);
				const rot = new Quat().setFromEulerAngles(r[0], r[1], r[2]);
				const scl = new Vec3(s[0], s[1], s[2]);
				const key = new Key(t, pos, rot, scl);

				node._keys.push(key);
			}

			anim.addNode(node);
		}

		return anim;
	}

	_parseAnimationV4(data) {
		const animData = data.animation;
		const anim = new Animation();
		anim.name = animData.name;
		anim.duration = animData.duration;

		for (let i = 0; i < animData.nodes.length; i++) {
			const node = new Node();
			const n = animData.nodes[i];
			node._name = n.name;
			const defPos = n.defaults.p;
			const defRot = n.defaults.r;
			const defScl = n.defaults.s;

			for (let j = 0; j < n.keys.length; j++) {
				const k = n.keys[j];
				const t = k.t;
				const p = defPos ? defPos : k.p;
				const r = defRot ? defRot : k.r;
				const s = defScl ? defScl : k.s;
				const pos = new Vec3(p[0], p[1], p[2]);
				const rot = new Quat().setFromEulerAngles(r[0], r[1], r[2]);
				const scl = new Vec3(s[0], s[1], s[2]);
				const key = new Key(t, pos, rot, scl);

				node._keys.push(key);
			}

			anim.addNode(node);
		}

		return anim;
	}

}

class AnimClipHandler {
	constructor() {
		this.maxRetries = 0;
	}

	load(url, callback) {
		if (typeof url === 'string') {
			url = {
				load: url,
				original: url
			};
		}

		const options = {
			retry: this.maxRetries > 0,
			maxRetries: this.maxRetries
		};

		if (url.load.startsWith('blob:')) {
			options.responseType = Http.ResponseType.JSON;
		}

		http.get(url.load, options, function (err, response) {
			if (err) {
				callback(`Error loading animation clip resource: ${url.original} [${err}]`);
			} else {
				callback(null, response);
			}
		});
	}

	open(url, data) {
		const name = data.name;
		const duration = data.duration;
		const inputs = data.inputs.map(function (input) {
			return new AnimData(1, input);
		});
		const outputs = data.outputs.map(function (output) {
			return new AnimData(output.components, output.data);
		});
		const curves = data.curves.map(function (curve) {
			return new AnimCurve([curve.path], curve.inputIndex, curve.outputIndex, curve.interpolation);
		});
		return new AnimTrack(name, duration, inputs, outputs, curves);
	}

	patch(asset, assets) {}

}

class AnimStateGraph {
	constructor(data) {
		this._layers = [];
		this._parameters = {};

		if (!Array.isArray(data.layers)) {
			for (const layerId in data.layers) {
				const dataLayer = data.layers[layerId];
				const layer = {
					name: dataLayer.name,
					blendType: dataLayer.blendType,
					weight: dataLayer.weight,
					states: [],
					transitions: []
				};

				for (let i = 0; i < dataLayer.states.length; i++) {
					layer.states.push(data.states[dataLayer.states[i]]);
				}

				for (let i = 0; i < dataLayer.transitions.length; i++) {
					const dataLayerTransition = data.transitions[dataLayer.transitions[i]];

					if (dataLayerTransition.conditions && !Array.isArray(dataLayerTransition.conditions)) {
						const conditionKeys = Object.keys(dataLayerTransition.conditions);
						const conditions = [];

						for (let j = 0; j < conditionKeys.length; j++) {
							const condition = dataLayerTransition.conditions[conditionKeys[j]];

							if (condition.parameterName) {
								conditions.push(condition);
							}
						}

						dataLayerTransition.conditions = conditions;
					}

					if (Number.isInteger(dataLayerTransition.from)) {
						dataLayerTransition.from = data.states[dataLayerTransition.from].name;
					}

					if (Number.isInteger(dataLayerTransition.to)) {
						dataLayerTransition.to = data.states[dataLayerTransition.to].name;
					}

					layer.transitions.push(dataLayerTransition);
				}

				this._layers.push(layer);
			}
		} else {
			this._layers = data.layers;
		}

		for (const paramId in data.parameters) {
			const param = data.parameters[paramId];
			this._parameters[param.name] = {
				type: param.type,
				value: param.value
			};
		}
	}

	get parameters() {
		return Object.assign({}, this._parameters);
	}

	get layers() {
		return this._layers;
	}

}

class AnimStateGraphHandler {
	constructor() {
		this.maxRetries = 0;
	}

	load(url, callback) {
		if (typeof url === 'string') {
			url = {
				load: url,
				original: url
			};
		}

		const options = {
			retry: this.maxRetries > 0,
			maxRetries: this.maxRetries
		};

		if (url.load.startsWith('blob:')) {
			options.responseType = Http.ResponseType.JSON;
		}

		http.get(url.load, options, function (err, response) {
			if (err) {
				callback(`Error loading animation state graph resource: ${url.original} [${err}]`);
			} else {
				callback(null, response);
			}
		});
	}

	open(url, data) {
		return new AnimStateGraph(data);
	}

	patch(asset, assets) {}

}

class Sound {
	constructor(resource) {
		this.audio = void 0;
		this.buffer = void 0;

		if (resource instanceof Audio) {
			this.audio = resource;
		} else {
			this.buffer = resource;
		}
	}

	get duration() {
		let duration = 0;

		if (this.buffer) {
			duration = this.buffer.duration;
		} else if (this.audio) {
			duration = this.audio.duration;
		}

		return duration || 0;
	}

}

const ie = function () {
	if (typeof window === 'undefined') {
		return false;
	}

	const ua = window.navigator.userAgent;
	const msie = ua.indexOf('MSIE ');

	if (msie > 0) {
		return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
	}

	const trident = ua.indexOf('Trident/');

	if (trident > 0) {
		const rv = ua.indexOf('rv:');
		return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
	}

	return false;
}();

const toMIME = {
	'.ogg': 'audio/ogg',
	'.mp3': 'audio/mpeg',
	'.wav': 'audio/x-wav',
	'.mp4a': 'audio/mp4',
	'.m4a': 'audio/mp4',
	'.mp4': 'audio/mp4',
	'.aac': 'audio/aac'
};

class AudioHandler {
	constructor(manager) {
		this.manager = manager;
		this.maxRetries = 0;
	}

	_isSupported(url) {
		const ext = path.getExtension(url);

		if (toMIME[ext]) {
			return true;
		}

		return false;
	}

	load(url, callback) {
		if (typeof url === 'string') {
			url = {
				load: url,
				original: url
			};
		}

		const success = function success(resource) {
			callback(null, new Sound(resource));
		};

		const error = function error(err) {
			let msg = 'Error loading audio url: ' + url.original;

			if (err) {
				msg += ': ' + (err.message || err);
			}

			console.warn(msg);
			callback(msg);
		};

		if (this._createSound) {
			if (!this._isSupported(url.original)) {
				error(`Audio format for ${url.original} not supported`);
				return;
			}

			this._createSound(url.load, success, error);
		} else {
			error(null);
		}
	}

	open(url, data) {
		return data;
	}

	patch(asset, assets) {}

	_createSound(url, success, error) {
		if (hasAudioContext()) {
			const manager = this.manager;

			if (!manager.context) {
				error('Audio manager has no audio context');
				return;
			}

			const options = {
				retry: this.maxRetries > 0,
				maxRetries: this.maxRetries
			};

			if (url.startsWith('blob:') || url.startsWith('data:')) {
				options.responseType = Http.ResponseType.ARRAY_BUFFER;
			}

			http.get(url, options, function (err, response) {
				if (err) {
					error(err);
					return;
				}

				manager.context.decodeAudioData(response, success, error);
			});
		} else {
			let audio = null;

			try {
				audio = new Audio();
			} catch (e) {
				error("No support for Audio element");
				return;
			}

			if (ie) {
				document.body.appendChild(audio);
			}

			const onReady = function onReady() {
				audio.removeEventListener('canplaythrough', onReady);

				if (ie) {
					document.body.removeChild(audio);
				}

				success(audio);
			};

			audio.onerror = function () {
				audio.onerror = null;

				if (ie) {
					document.body.removeChild(audio);
				}

				error();
			};

			audio.addEventListener('canplaythrough', onReady);
			audio.src = url;
		}
	}

}

class BinaryHandler {
	constructor() {
		this.maxRetries = 0;
	}

	load(url, callback) {
		if (typeof url === 'string') {
			url = {
				load: url,
				original: url
			};
		}

		http.get(url.load, {
			responseType: Http.ResponseType.ARRAY_BUFFER,
			retry: this.maxRetries > 0,
			maxRetries: this.maxRetries
		}, function (err, response) {
			if (!err) {
				callback(null, response);
			} else {
				callback(`Error loading binary resource: ${url.original} [${err}]`);
			}
		});
	}

	open(url, data) {
		return data;
	}

	patch(asset, assets) {}

}

class Bundle {
	constructor(files) {
		this._blobUrls = {};

		for (let i = 0, len = files.length; i < len; i++) {
			if (files[i].url) {
				this._blobUrls[files[i].name] = files[i].url;
			}
		}
	}

	hasBlobUrl(url) {
		return !!this._blobUrls[url];
	}

	getBlobUrl(url) {
		return this._blobUrls[url];
	}

	destroy() {
		for (const key in this._blobUrls) {
			URL.revokeObjectURL(this._blobUrls[key]);
		}

		this._blobUrls = null;
	}

}

let Untar;

function UntarScope(isWorker) {
	let utfDecoder;
	let asciiDecoder;

	if (typeof TextDecoder !== 'undefined') {
		try {
			utfDecoder = new TextDecoder('utf-8');
			asciiDecoder = new TextDecoder('windows-1252');
		} catch (e) {
			console.warn('TextDecoder not supported - pc.Untar module will not work');
		}
	} else {
		console.warn('TextDecoder not supported - pc.Untar module will not work');
	}

	function PaxHeader(fields) {
		this._fields = fields;
	}

	PaxHeader.parse = function (buffer, start, length) {
		const paxArray = new Uint8Array(buffer, start, length);
		let bytesRead = 0;
		const fields = [];

		while (bytesRead < length) {
			let spaceIndex;

			for (spaceIndex = bytesRead; spaceIndex < length; spaceIndex++) {
				if (paxArray[spaceIndex] === 0x20) break;
			}

			if (spaceIndex >= length) {
				throw new Error('Invalid PAX header data format.');
			}

			const fieldLength = parseInt(utfDecoder.decode(new Uint8Array(buffer, start + bytesRead, spaceIndex - bytesRead)), 10);
			const fieldText = utfDecoder.decode(new Uint8Array(buffer, start + spaceIndex + 1, fieldLength - (spaceIndex - bytesRead) - 2));
			const field = fieldText.split('=');

			if (field.length !== 2) {
				throw new Error('Invalid PAX header data format.');
			}

			if (field[1].length === 0) {
				field[1] = null;
			}

			fields.push({
				name: field[0],
				value: field[1]
			});
			bytesRead += fieldLength;
		}

		return new PaxHeader(fields);
	};

	PaxHeader.prototype.applyHeader = function (file) {
		for (let i = 0; i < this._fields.length; i++) {
			let fieldName = this._fields[i].name;
			const fieldValue = this._fields[i].value;

			if (fieldName === 'path') {
				fieldName = 'name';
			}

			if (fieldValue === null) {
				delete file[fieldName];
			} else {
				file[fieldName] = fieldValue;
			}
		}
	};

	function UntarInternal(arrayBuffer) {
		this._arrayBuffer = arrayBuffer || new ArrayBuffer(0);
		this._bufferView = new DataView(this._arrayBuffer);
		this._globalPaxHeader = null;
		this._paxHeader = null;
		this._bytesRead = 0;
	}

	if (!isWorker) {
		Untar = UntarInternal;
	}

	UntarInternal.prototype._hasNext = function () {
		return this._bytesRead + 4 < this._arrayBuffer.byteLength && this._bufferView.getUint32(this._bytesRead) !== 0;
	};

	UntarInternal.prototype._readNextFile = function () {
		const headersDataView = new DataView(this._arrayBuffer, this._bytesRead, 512);
		const headers = asciiDecoder.decode(headersDataView);
		this._bytesRead += 512;
		let name = headers.substr(0, 100).replace(/\0/g, '');
		const ustarFormat = headers.substr(257, 6);
		const size = parseInt(headers.substr(124, 12), 8);
		const type = headers.substr(156, 1);
		const start = this._bytesRead;
		let url = null;
		let normalFile = false;

		switch (type) {
			case "0":
			case "":
				normalFile = true;

				if (!isWorker) {
					const blob = new Blob([this._arrayBuffer.slice(this._bytesRead, this._bytesRead + size)]);
					url = URL.createObjectURL(blob);
				}

				break;

			case "g":
				this._globalPaxHeader = PaxHeader.parse(this._arrayBuffer, this._bytesRead, size);
				break;

			case "x":
				this._paxHeader = PaxHeader.parse(this._arrayBuffer, this._bytesRead, size);
				break;
		}

		this._bytesRead += size;
		const remainder = size % 512;

		if (remainder !== 0) {
			this._bytesRead += 512 - remainder;
		}

		if (!normalFile) {
			return null;
		}

		if (ustarFormat.indexOf("ustar") !== -1) {
			const namePrefix = headers.substr(345, 155).replace(/\0/g, '');

			if (namePrefix.length > 0) {
				name = namePrefix.trim() + name.trim();
			}
		}

		const file = {
			name: name,
			start: start,
			size: size,
			url: url
		};

		if (this._globalPaxHeader) {
			this._globalPaxHeader.applyHeader(file);
		}

		if (this._paxHeader) {
			this._paxHeader.applyHeader(file);

			this._paxHeader = null;
		}

		return file;
	};

	UntarInternal.prototype.untar = function (filenamePrefix) {
		if (!utfDecoder) {
			console.error('Cannot untar because TextDecoder interface is not available for this platform.');
			return [];
		}

		const files = [];

		while (this._hasNext()) {
			const file = this._readNextFile();

			if (!file) continue;

			if (filenamePrefix && file.name) {
				file.name = filenamePrefix + file.name;
			}

			files.push(file);
		}

		return files;
	};

	if (isWorker) {
		self.onmessage = function (e) {
			const id = e.data.id;

			try {
				const archive = new UntarInternal(e.data.arrayBuffer);
				const files = archive.untar(e.data.prefix);
				postMessage({
					id: id,
					files: files,
					arrayBuffer: e.data.arrayBuffer
				}, [e.data.arrayBuffer]);
			} catch (err) {
				postMessage({
					id: id,
					error: err.toString()
				});
			}
		};
	}
}

let workerUrl = null;

function getWorkerUrl() {
	if (!workerUrl) {
		const code = '(' + UntarScope.toString() + ')(true)\n\n';
		const blob = new Blob([code], {
			type: 'application/javascript'
		});
		workerUrl = URL.createObjectURL(blob);
	}

	return workerUrl;
}

class UntarWorker {
	constructor(filenamePrefix) {
		this._requestId = 0;
		this._pendingRequests = {};
		this._filenamePrefix = filenamePrefix;
		this._worker = new Worker(getWorkerUrl());

		this._worker.addEventListener('message', this._onMessage.bind(this));
	}

	_onMessage(e) {
		const id = e.data.id;
		if (!this._pendingRequests[id]) return;
		const callback = this._pendingRequests[id];
		delete this._pendingRequests[id];

		if (e.data.error) {
			callback(e.data.error);
		} else {
			const arrayBuffer = e.data.arrayBuffer;

			for (let i = 0, len = e.data.files.length; i < len; i++) {
				const file = e.data.files[i];
				const blob = new Blob([arrayBuffer.slice(file.start, file.start + file.size)]);
				file.url = URL.createObjectURL(blob);
			}

			callback(null, e.data.files);
		}
	}

	untar(arrayBuffer, callback) {
		const id = this._requestId++;
		this._pendingRequests[id] = callback;

		this._worker.postMessage({
			id: id,
			prefix: this._filenamePrefix,
			arrayBuffer: arrayBuffer
		}, [arrayBuffer]);
	}

	hasPendingRequests() {
		return Object.keys(this._pendingRequests).length > 0;
	}

	destroy() {
		if (this._worker) {
			this._worker.terminate();

			this._worker = null;
			this._pendingRequests = null;
		}
	}

}

UntarScope();

class BundleHandler {
	constructor(assets) {
		this._assets = assets;
		this._worker = null;
		this.maxRetries = 0;
	}

	load(url, callback) {
		if (typeof url === 'string') {
			url = {
				load: url,
				original: url
			};
		}

		const self = this;
		http.get(url.load, {
			responseType: Http.ResponseType.ARRAY_BUFFER,
			retry: this.maxRetries > 0,
			maxRetries: this.maxRetries
		}, function (err, response) {
			if (!err) {
				try {
					self._untar(response, callback);
				} catch (ex) {
					callback("Error loading bundle resource " + url.original + ": " + ex);
				}
			} else {
				callback("Error loading bundle resource " + url.original + ": " + err);
			}
		});
	}

	_untar(response, callback) {
		const self = this;

		if (platform.workers) {
			if (!self._worker) {
				self._worker = new UntarWorker(self._assets.prefix);
			}

			self._worker.untar(response, function (err, files) {
				callback(err, files);

				if (!self._worker.hasPendingRequests()) {
					self._worker.destroy();

					self._worker = null;
				}
			});
		} else {
			const archive = new Untar(response);
			const files = archive.untar(self._assets.prefix);
			callback(null, files);
		}
	}

	open(url, data) {
		return new Bundle(data);
	}

	patch(asset, assets) {}

}

class ContainerResource {
	instantiateModelEntity(options) {
		return null;
	}

	instantiateRenderEntity(options) {
		return null;
	}

}

class ContainerHandler {
	constructor(device, assets) {
		this.glbParser = new GlbParser(device, assets, 0);
		this.parsers = {};
	}

	_getUrlWithoutParams(url) {
		return url.indexOf('?') >= 0 ? url.split('?')[0] : url;
	}

	_getParser(url) {
		const ext = url ? path.getExtension(this._getUrlWithoutParams(url)).toLowerCase().replace('.', '') : null;
		return this.parsers[ext] || this.glbParser;
	}

	load(url, callback, asset) {
		if (typeof url === 'string') {
			url = {
				load: url,
				original: url
			};
		}

		this._getParser(url.original).load(url, callback, asset);
	}

	open(url, data, asset) {
		return this._getParser(url).open(url, data, asset);
	}

	patch(asset, assets) {}

}

class CssHandler {
	constructor() {
		this.maxRetries = 0;
	}

	load(url, callback) {
		if (typeof url === 'string') {
			url = {
				load: url,
				original: url
			};
		}

		http.get(url.load, {
			retry: this.maxRetries > 0,
			maxRetries: this.maxRetries
		}, function (err, response) {
			if (!err) {
				callback(null, response);
			} else {
				callback(`Error loading css resource: ${url.original} [${err}]`);
			}
		});
	}

	open(url, data) {
		return data;
	}

	patch(asset, assets) {}

}

function createStyle(cssString) {
	const result = document.createElement('style');
	result.type = 'text/css';

	if (result.styleSheet) {
		result.styleSheet.cssText = cssString;
	} else {
		result.appendChild(document.createTextNode(cssString));
	}

	return result;
}

class CubemapHandler {
	constructor(device, assets, loader) {
		this._device = device;
		this._registry = assets;
		this._loader = loader;
	}

	load(url, callback, asset) {
		this.loadAssets(asset, callback);
	}

	open(url, data, asset) {
		return asset ? asset.resource : null;
	}

	patch(asset, registry) {
		this.loadAssets(asset, function (err, result) {
			if (err) {
				registry.fire('error', asset);
				registry.fire('error:' + asset.id, err, asset);
				asset.fire('error', asset);
			}
		});
	}

	getAssetIds(cubemapAsset) {
		const result = [];
		result[0] = cubemapAsset.file;

		if ((cubemapAsset.loadFaces || !cubemapAsset.file) && cubemapAsset.data && cubemapAsset.data.textures) {
			for (let i = 0; i < 6; ++i) {
				result[i + 1] = cubemapAsset.data.textures[i];
			}
		} else {
			result[1] = result[2] = result[3] = result[4] = result[5] = result[6] = null;
		}

		return result;
	}

	compareAssetIds(assetIdA, assetIdB) {
		if (assetIdA && assetIdB) {
			if (parseInt(assetIdA, 10) === assetIdA || typeof assetIdA === "string") {
				return assetIdA === assetIdB;
			}

			return assetIdA.url === assetIdB.url;
		}

		return assetIdA !== null === (assetIdB !== null);
	}

	update(cubemapAsset, assetIds, assets) {
		const assetData = cubemapAsset.data || {};
		const oldAssets = cubemapAsset._handlerState.assets;
		const oldResources = cubemapAsset._resources;
		let tex, mip, i;
		const resources = [null, null, null, null, null, null, null];

		const getType = function getType() {
			if (assetData.hasOwnProperty('type')) {
				return assetData.type;
			}

			if (assetData.hasOwnProperty('rgbm')) {
				return assetData.rgbm ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT;
			}

			return null;
		};

		if (!cubemapAsset.loaded || assets[0] !== oldAssets[0]) {
			if (assets[0]) {
				tex = assets[0].resource;

				for (i = 0; i < 6; ++i) {
					resources[i + 1] = new Texture(this._device, {
						name: cubemapAsset.name + '_prelitCubemap' + (tex.width >> i),
						cubemap: true,
						type: getType() || tex.type,
						width: tex.width >> i,
						height: tex.height >> i,
						format: tex.format,
						levels: [tex._levels[i]],
						fixCubemapSeams: true,
						addressU: ADDRESS_CLAMP_TO_EDGE,
						addressV: ADDRESS_CLAMP_TO_EDGE,
						mipmaps: i === 0
					});
				}
			}
		} else {
			resources[1] = oldResources[1] || null;
			resources[2] = oldResources[2] || null;
			resources[3] = oldResources[3] || null;
			resources[4] = oldResources[4] || null;
			resources[5] = oldResources[5] || null;
			resources[6] = oldResources[6] || null;
		}

		const faceAssets = assets.slice(1);

		if (!cubemapAsset.loaded || !this.cmpArrays(faceAssets, oldAssets.slice(1))) {
			if (faceAssets.indexOf(null) === -1) {
				const faceTextures = faceAssets.map(function (asset) {
					return asset.resource;
				});
				const faceLevels = [];

				for (mip = 0; mip < faceTextures[0]._levels.length; ++mip) {
					faceLevels.push(faceTextures.map(function (faceTexture) {
						return faceTexture._levels[mip];
					}));
				}

				const faces = new Texture(this._device, {
					name: cubemapAsset.name + '_faces',
					cubemap: true,
					type: getType() || faceTextures[0].type,
					width: faceTextures[0].width,
					height: faceTextures[0].height,
					format: faceTextures[0].format,
					levels: faceLevels,
					minFilter: assetData.hasOwnProperty('minFilter') ? assetData.minFilter : faceTextures[0].minFilter,
					magFilter: assetData.hasOwnProperty('magFilter') ? assetData.magFilter : faceTextures[0].magFilter,
					anisotropy: assetData.hasOwnProperty('anisotropy') ? assetData.anisotropy : 1,
					addressU: ADDRESS_CLAMP_TO_EDGE,
					addressV: ADDRESS_CLAMP_TO_EDGE,
					fixCubemapSeams: !!assets[0]
				});
				resources[0] = faces;
			}
		} else {
			resources[0] = oldResources[0] || null;
		}

		if (!this.cmpArrays(resources, oldResources)) {
			cubemapAsset.resources = resources;
			cubemapAsset._handlerState.assetIds = assetIds;
			cubemapAsset._handlerState.assets = assets;

			for (i = 0; i < oldResources.length; ++i) {
				if (oldResources[i] !== null && resources.indexOf(oldResources[i]) === -1) {
					oldResources[i].destroy();
				}
			}
		}

		for (i = 0; i < oldAssets.length; ++i) {
			if (oldAssets[i] !== null && assets.indexOf(oldAssets[i]) === -1) {
				oldAssets[i].unload();
			}
		}
	}

	cmpArrays(arr1, arr2) {
		if (arr1.length !== arr2.length) {
			return false;
		}

		for (let i = 0; i < arr1.length; ++i) {
			if (arr1[i] !== arr2[i]) {
				return false;
			}
		}

		return true;
	}

	resolveId(value) {
		const valueInt = parseInt(value, 10);
		return valueInt === value || valueInt.toString() === value ? valueInt : value;
	}

	loadAssets(cubemapAsset, callback) {
		if (!cubemapAsset.hasOwnProperty('_handlerState')) {
			cubemapAsset._handlerState = {
				assetIds: [null, null, null, null, null, null, null],
				assets: [null, null, null, null, null, null, null]
			};
		}

		const self = this;
		const assetIds = self.getAssetIds(cubemapAsset);
		const assets = [null, null, null, null, null, null, null];
		const loadedAssetIds = cubemapAsset._handlerState.assetIds;
		const loadedAssets = cubemapAsset._handlerState.assets;
		const registry = self._registry;
		let awaiting = 7;

		const onLoad = function onLoad(index, asset) {
			assets[index] = asset;
			awaiting--;

			if (awaiting === 0) {
				self.update(cubemapAsset, assetIds, assets);
				callback(null, cubemapAsset.resources);
			}
		};

		const onError = function onError(index, err, asset) {
			callback(err);
		};

		const processTexAsset = function processTexAsset(index, texAsset) {
			if (texAsset.loaded) {
				onLoad(index, texAsset);
			} else {
				registry.once('load:' + texAsset.id, onLoad.bind(self, index));
				registry.once('error:' + texAsset.id, onError.bind(self, index));

				if (!texAsset.loading) {
					registry.load(texAsset);
				}
			}
		};

		let texAsset;

		for (let i = 0; i < 7; ++i) {
			const assetId = this.resolveId(assetIds[i]);

			if (!assetId) {
				onLoad(i, null);
			} else if (self.compareAssetIds(assetId, loadedAssetIds[i])) {
				onLoad(i, loadedAssets[i]);
			} else if (parseInt(assetId, 10) === assetId) {
				texAsset = registry.get(assetId);

				if (texAsset) {
					processTexAsset(i, texAsset);
				} else {
					setTimeout(function (index, assetId_) {
						const texAsset = registry.get(assetId_);

						if (texAsset) {
							processTexAsset(index, texAsset);
						} else {
							onError(index, "failed to find dependent cubemap asset=" + assetId_);
						}
					}.bind(null, i, assetId));
				}
			} else {
				const file = typeof assetId === "string" ? {
					url: assetId,
					filename: assetId
				} : assetId;
				texAsset = new Asset(cubemapAsset.name + "_part_" + i, "texture", file);
				registry.add(texAsset);
				registry.once('load:' + texAsset.id, onLoad.bind(self, i));
				registry.once('error:' + texAsset.id, onError.bind(self, i));
				registry.load(texAsset);
			}
		}
	}

}

class FolderHandler {
	load(url, callback) {
		callback(null, null);
	}

	open(url, data) {
		return data;
	}

}

const FONT_MSDF = 'msdf';
const FONT_BITMAP = 'bitmap';

class Font {
	constructor(textures, data) {
		this.type = data ? data.type || FONT_MSDF : FONT_MSDF;
		this.em = 1;
		this.textures = textures;
		this.intensity = 0.0;
		this._data = null;
		this.data = data;
	}

	set data(value) {
		this._data = value;
		if (!value) return;

		if (this._data.intensity !== undefined) {
			this.intensity = this._data.intensity;
		}

		if (!this._data.info) this._data.info = {};

		if (!this._data.version || this._data.version < 2) {
			this._data.info.maps = [{
				width: this._data.info.width,
				height: this._data.info.height
			}];

			if (this._data.chars) {
				for (const key in this._data.chars) {
					this._data.chars[key].map = 0;
				}
			}
		}
	}

	get data() {
		return this._data;
	}

}

function upgradeDataSchema(data) {
	if (data.version < 3) {
		if (data.version < 2) {
			data.info.maps = data.info.maps || [{
				width: data.info.width,
				height: data.info.height
			}];
		}

		data.chars = Object.keys(data.chars || {}).reduce(function (newChars, key) {
			const existing = data.chars[key];
			const newKey = existing.letter !== undefined ? existing.letter : string.fromCodePoint(key);

			if (data.version < 2) {
				existing.map = existing.map || 0;
			}

			newChars[newKey] = existing;
			return newChars;
		}, {});
		data.version = 3;
	}

	return data;
}

class FontHandler {
	constructor(loader) {
		this._loader = loader;
		this.maxRetries = 0;
	}

	load(url, callback, asset) {
		if (typeof url === 'string') {
			url = {
				load: url,
				original: url
			};
		}

		const self = this;

		if (path.getExtension(url.original) === '.json') {
			http.get(url.load, {
				retry: this.maxRetries > 0,
				maxRetries: this.maxRetries
			}, function (err, response) {
				if (!err) {
					const data = upgradeDataSchema(response);

					self._loadTextures(url.load.replace('.json', '.png'), data, function (err, textures) {
						if (err) return callback(err);
						callback(null, {
							data: data,
							textures: textures
						});
					});
				} else {
					callback(`Error loading font resource: ${url.original} [${err}]`);
				}
			});
		} else {
			if (asset && asset.data) {
				asset.data = upgradeDataSchema(asset.data);
			}

			this._loadTextures(url.load, asset && asset.data, callback);
		}
	}

	_loadTextures(url, data, callback) {
		const numTextures = data.info.maps.length;
		let numLoaded = 0;
		let error = null;
		const textures = new Array(numTextures);
		const loader = this._loader;

		const loadTexture = function loadTexture(index) {
			const onLoaded = function onLoaded(err, texture) {
				if (error) return;

				if (err) {
					error = err;
					return callback(err);
				}

				texture.upload();
				textures[index] = texture;
				numLoaded++;

				if (numLoaded === numTextures) {
					callback(null, textures);
				}
			};

			if (index === 0) {
				loader.load(url, "texture", onLoaded);
			} else {
				loader.load(url.replace('.png', index + '.png'), "texture", onLoaded);
			}
		};

		for (let i = 0; i < numTextures; i++) loadTexture(i);
	}

	open(url, data, asset) {
		let font;

		if (data.textures) {
			font = new Font(data.textures, data.data);
		} else {
			font = new Font(data, null);
		}

		return font;
	}

	patch(asset, assets) {
		const font = asset.resource;

		if (!font.data && asset.data) {
			font.data = asset.data;
		} else if (!asset.data && font.data) {
			asset.data = font.data;
		}

		if (asset.data) {
			asset.data = upgradeDataSchema(asset.data);
		}
	}

}

const CompressUtils = {
	setCompressedPRS: function (entity, data, compressed) {
		const a = compressed.singleVecs;
		let b, i;
		const v = data.___1;

		if (!v) {
			b = compressed.tripleVecs;
			i = data.___2;
		}

		let n = v ? v[0] : b[i];
		entity.setLocalPosition(a[n], a[n + 1], a[n + 2]);
		n = v ? v[1] : b[i + 1];
		entity.setLocalEulerAngles(a[n], a[n + 1], a[n + 2]);
		n = v ? v[2] : b[i + 2];
		entity.setLocalScale(a[n], a[n + 1], a[n + 2]);
	},
	oneCharToKey: function (s, data) {
		const i = s.charCodeAt(0) - data.fieldFirstCode;
		return data.fieldArray[i];
	},
	multCharToKey: function (s, data) {
		let ind = 0;

		for (let i = 0; i < s.length; i++) {
			ind = ind * data.fieldCodeBase + s.charCodeAt(i) - data.fieldFirstCode;
		}

		return data.fieldArray[ind];
	}
};

class Decompress {
	constructor(node, data) {
		this._node = node;
		this._data = data;
	}

	run() {
		const type = Object.prototype.toString.call(this._node);

		if (type === '[object Object]') {
			this._handleMap();
		} else if (type === '[object Array]') {
			this._handleArray();
		} else {
			this._result = this._node;
		}

		return this._result;
	}

	_handleMap() {
		this._result = {};
		const a = Object.keys(this._node);
		a.forEach(this._handleKey, this);
	}

	_handleKey(origKey) {
		let newKey = origKey;
		const len = origKey.length;

		if (len === 1) {
			newKey = CompressUtils.oneCharToKey(origKey, this._data);
		} else if (len === 2) {
			newKey = CompressUtils.multCharToKey(origKey, this._data);
		}

		this._result[newKey] = new Decompress(this._node[origKey], this._data).run();
	}

	_handleArray() {
		this._result = [];

		this._node.forEach(this._handleArElt, this);
	}

	_handleArElt(elt) {
		const v = new Decompress(elt, this._data).run();

		this._result.push(v);
	}

}

class SceneParser {
	constructor(app, isTemplate) {
		this._app = app;
		this._isTemplate = isTemplate;
	}

	parse(data) {
		const entities = {};
		let parent = null;
		const compressed = data.compressedFormat;

		if (compressed && !data.entDecompressed) {
			data.entDecompressed = true;
			data.entities = new Decompress(data.entities, compressed).run();
		}

		for (const id in data.entities) {
			const curData = data.entities[id];

			const curEnt = this._createEntity(curData, compressed);

			entities[id] = curEnt;

			if (curData.parent === null) {
				parent = curEnt;
			}
		}

		for (const id in data.entities) {
			const curEnt = entities[id];
			const children = data.entities[id].children;
			const len = children.length;

			for (let i = 0; i < len; i++) {
				const childEnt = entities[children[i]];

				if (childEnt) {
					curEnt.addChild(childEnt);
				}
			}
		}

		this._openComponentData(parent, data.entities);

		return parent;
	}

	_createEntity(data, compressed) {
		const entity = new Entity(data.name, this._app);
		entity.setGuid(data.resource_id);

		this._setPosRotScale(entity, data, compressed);

		entity._enabled = data.enabled !== undefined ? data.enabled : true;

		if (this._isTemplate) {
			entity._template = true;
		} else {
			entity._enabledInHierarchy = entity._enabled;
		}

		entity.template = data.template;

		if (data.tags) {
			for (let i = 0; i < data.tags.length; i++) {
				entity.tags.add(data.tags[i]);
			}
		}

		if (data.labels) {
			data.labels.forEach(function (label) {
				entity.addLabel(label);
			});
		}

		return entity;
	}

	_setPosRotScale(entity, data, compressed) {
		if (compressed) {
			CompressUtils.setCompressedPRS(entity, data, compressed);
		} else {
			const p = data.position;
			const r = data.rotation;
			const s = data.scale;
			entity.setLocalPosition(p[0], p[1], p[2]);
			entity.setLocalEulerAngles(r[0], r[1], r[2]);
			entity.setLocalScale(s[0], s[1], s[2]);
		}
	}

	_openComponentData(entity, entities) {
		const systemsList = this._app.systems.list;
		let len = systemsList.length;
		const entityData = entities[entity.getGuid()];

		for (let i = 0; i < len; i++) {
			const system = systemsList[i];
			const componentData = entityData.components[system.id];

			if (componentData) {
				system.addComponent(entity, componentData);
			}
		}

		len = entityData.children.length;
		const children = entity._children;

		for (let i = 0; i < len; i++) {
			children[i] = this._openComponentData(children[i], entities);
		}

		return entity;
	}

}

const SceneUtils = {
	load: function (url, maxRetries, callback) {
		if (typeof url === 'string') {
			url = {
				load: url,
				original: url
			};
		}

		http.get(url.load, {
			retry: maxRetries > 0,
			maxRetries: maxRetries
		}, function (err, response) {
			if (!err) {
				callback(err, response);
			} else {
				let errMsg = 'Error while loading scene JSON ' + url.original;

				if (err.message) {
					errMsg += ': ' + err.message;

					if (err.stack) {
						errMsg += '\n' + err.stack;
					}
				} else {
					errMsg += ': ' + err;
				}

				callback(errMsg);
			}
		});
	}
};

class HierarchyHandler {
	constructor(app) {
		this._app = app;
		this.maxRetries = 0;
	}

	load(url, callback) {
		SceneUtils.load(url, this.maxRetries, callback);
	}

	open(url, data) {
		this._app.systems.script.preloading = true;
		const parser = new SceneParser(this._app, false);
		const parent = parser.parse(data);
		this._app.systems.script.preloading = false;
		return parent;
	}

}

class HtmlHandler {
	constructor() {
		this.maxRetries = 0;
	}

	load(url, callback) {
		if (typeof url === 'string') {
			url = {
				load: url,
				original: url
			};
		}

		http.get(url.load, {
			retry: this.maxRetries > 0,
			maxRetries: this.maxRetries
		}, function (err, response) {
			if (!err) {
				callback(null, response);
			} else {
				callback(`Error loading html resource: ${url.original} [${err}]`);
			}
		});
	}

	open(url, data) {
		return data;
	}

	patch(asset, assets) {}

}

class JsonHandler {
	constructor() {
		this.maxRetries = 0;
	}

	load(url, callback) {
		if (typeof url === 'string') {
			url = {
				load: url,
				original: url
			};
		}

		const options = {
			retry: this.maxRetries > 0,
			maxRetries: this.maxRetries
		};

		if (url.load.startsWith('blob:')) {
			options.responseType = Http.ResponseType.JSON;
		}

		http.get(url.load, options, function (err, response) {
			if (!err) {
				callback(null, response);
			} else {
				callback(`Error loading JSON resource: ${url.original} [${err}]`);
			}
		});
	}

	open(url, data) {
		return data;
	}

	patch(asset, assets) {}

}

class AssetReference {
	constructor(propertyName, parent, registry, callbacks, scope) {
		this.propertyName = propertyName;
		this.parent = parent;
		this._scope = scope;
		this._registry = registry;
		this.id = null;
		this.url = null;
		this.asset = null;
		this._onAssetLoad = callbacks.load;
		this._onAssetAdd = callbacks.add;
		this._onAssetRemove = callbacks.remove;
		this._onAssetUnload = callbacks.unload;
	}

	set id(value) {
		if (this.url) throw Error("Can't set id and url");

		this._unbind();

		this._id = value;
		this.asset = this._registry.get(this._id);

		this._bind();
	}

	get id() {
		return this._id;
	}

	set url(value) {
		if (this.id) throw Error("Can't set id and url");

		this._unbind();

		this._url = value;
		this.asset = this._registry.getByUrl(this._url);

		this._bind();
	}

	get url() {
		return this._url;
	}

	_bind() {
		if (this.id) {
			if (this._onAssetLoad) this._registry.on("load:" + this.id, this._onLoad, this);
			if (this._onAssetAdd) this._registry.once("add:" + this.id, this._onAdd, this);
			if (this._onAssetRemove) this._registry.on("remove:" + this.id, this._onRemove, this);
			if (this._onAssetUnload) this._registry.on("unload:" + this.id, this._onUnload, this);
		}

		if (this.url) {
			if (this._onAssetLoad) this._registry.on("load:url:" + this.url, this._onLoad, this);
			if (this._onAssetAdd) this._registry.once("add:url:" + this.url, this._onAdd, this);
			if (this._onAssetRemove) this._registry.on("remove:url:" + this.url, this._onRemove, this);
		}
	}

	_unbind() {
		if (this.id) {
			if (this._onAssetLoad) this._registry.off('load:' + this.id, this._onLoad, this);
			if (this._onAssetAdd) this._registry.off('add:' + this.id, this._onAdd, this);
			if (this._onAssetRemove) this._registry.off('remove:' + this.id, this._onRemove, this);
			if (this._onAssetUnload) this._registry.off("unload:" + this.id, this._onUnload, this);
		}

		if (this.url) {
			if (this._onAssetLoad) this._registry.off('load:' + this.url, this._onLoad, this);
			if (this._onAssetAdd) this._registry.off('add:' + this.url, this._onAdd, this);
			if (this._onAssetRemove) this._registry.off('remove:' + this.url, this._onRemove, this);
		}
	}

	_onLoad(asset) {
		this._onAssetLoad.call(this._scope, this.propertyName, this.parent, asset);
	}

	_onAdd(asset) {
		this.asset = asset;

		this._onAssetAdd.call(this._scope, this.propertyName, this.parent, asset);
	}

	_onRemove(asset) {
		this._onAssetRemove.call(this._scope, this.propertyName, this.parent, asset);

		this.asset = null;
	}

	_onUnload(asset) {
		this._onAssetUnload.call(this._scope, this.propertyName, this.parent, asset);
	}

}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

class StandardMaterialValidator {
	constructor() {
		this.removeInvalid = true;
		this.valid = true;
		this.enumValidators = {
			occludeSpecular: this._createEnumValidator([SPECOCC_NONE, SPECOCC_AO, SPECOCC_GLOSSDEPENDENT]),
			cull: this._createEnumValidator([CULLFACE_NONE, CULLFACE_BACK, CULLFACE_FRONT, CULLFACE_FRONTANDBACK]),
			blendType: this._createEnumValidator([BLEND_SUBTRACTIVE, BLEND_ADDITIVE, BLEND_NORMAL, BLEND_NONE, BLEND_PREMULTIPLIED, BLEND_MULTIPLICATIVE, BLEND_ADDITIVEALPHA, BLEND_MULTIPLICATIVE2X, BLEND_SCREEN, BLEND_MIN, BLEND_MAX]),
			shadingModel: this._createEnumValidator([SPECULAR_PHONG, SPECULAR_BLINN])
		};
	}

	setInvalid(key, data) {
		this.valid = false;

		if (this.removeInvalid) {
			delete data[key];
		}
	}

	validate(data) {
		const TYPES = standardMaterialParameterTypes;
		const pathMapping = data.mappingFormat === "path";

		for (const key in data) {
			const type = TYPES[key];

			if (!type) {
				this.valid = false;
				continue;
			}

			if (type.startsWith("enum")) {
				const enumType = type.split(":")[1];

				if (this.enumValidators[enumType]) {
					if (!this.enumValidators[enumType](data[key])) {
						this.setInvalid(key, data);
					}
				}
			} else if (type === 'number') {
				if (typeof data[key] !== 'number') {
					this.setInvalid(key, data);
				}
			} else if (type === 'boolean') {
				if (typeof data[key] !== 'boolean') {
					this.setInvalid(key, data);
				}
			} else if (type === 'string') {
				if (typeof data[key] !== 'string') {
					this.setInvalid(key, data);
				}
			} else if (type === 'vec2') {
				if (!(data[key] instanceof Array && data[key].length === 2)) {
					this.setInvalid(key, data);
				}
			} else if (type === 'rgb') {
				if (!(data[key] instanceof Array && data[key].length === 3)) {
					this.setInvalid(key, data);
				}
			} else if (type === 'texture') {
				if (!pathMapping) {
					if (!(typeof data[key] === 'number' || data[key] === null)) {
						if (!(data[key] instanceof Texture)) {
							this.setInvalid(key, data);
						}
					}
				} else {
					if (!(typeof data[key] === 'string' || data[key] === null)) {
						if (!(data[key] instanceof Texture)) {
							this.setInvalid(key, data);
						}
					}
				}
			} else if (type === 'boundingbox') {
				if (!(data[key].center && data[key].center instanceof Array && data[key].center.length === 3)) {
					this.setInvalid(key, data);
				}

				if (!(data[key].halfExtents && data[key].halfExtents instanceof Array && data[key].halfExtents.length === 3)) {
					this.setInvalid(key, data);
				}
			} else if (type === 'cubemap') {
				if (!(typeof data[key] === 'number' || data[key] === null || data[key] === undefined)) {
					if (!(data[key] instanceof Texture && data[key].cubemap)) {
						this.setInvalid(key, data);
					}
				}
			} else if (type === 'chunks') {
				const chunkNames = Object.keys(data[key]);

				for (let i = 0; i < chunkNames.length; i++) {
					if (typeof data[key][chunkNames[i]] !== 'string') {
						this.setInvalid(chunkNames[i], data[key]);
					}
				}
			} else {
				console.error("Unknown material type: " + type);
			}
		}

		data.validated = true;
		return this.valid;
	}

	_createEnumValidator(values) {
		return function (value) {
			return values.indexOf(value) >= 0;
		};
	}

}

class JsonStandardMaterialParser {
	constructor() {
		this._validator = null;
	}

	parse(input) {
		const migrated = this.migrate(input);

		const validated = this._validate(migrated);

		const material = new StandardMaterial();
		this.initialize(material, validated);
		return material;
	}

	initialize(material, data) {
		if (!data.validated) {
			data = this._validate(data);
		}

		if (data.chunks) {
			material.chunks = _extends({}, data.chunks);
		}

		for (const key in data) {
			const type = standardMaterialParameterTypes[key];
			const value = data[key];

			if (type === 'vec2') {
				material[key] = new Vec2(value[0], value[1]);
			} else if (type === 'rgb') {
				material[key] = new Color(value[0], value[1], value[2]);
			} else if (type === 'texture') {
				if (value instanceof Texture) {
					material[key] = value;
				} else if (!(material[key] instanceof Texture && typeof value === 'number' && value > 0)) {
					material[key] = null;
				}
			} else if (type === 'cubemap') {
				if (value instanceof Texture) {
					material[key] = value;
				} else if (!(material[key] instanceof Texture && typeof value === 'number' && value > 0)) {
					material[key] = null;
				}

				if (key === 'cubeMap' && !value) {
					material.prefilteredCubemaps = null;
				}
			} else if (type === 'boundingbox') {
				const center = new Vec3(value.center[0], value.center[1], value.center[2]);
				const halfExtents = new Vec3(value.halfExtents[0], value.halfExtents[1], value.halfExtents[2]);
				material[key] = new BoundingBox(center, halfExtents);
			} else {
				material[key] = data[key];
			}
		}

		material.update();
	}

	migrate(data) {
		if (data.shadingModel === undefined) {
			if (data.shader === 'blinn') {
				data.shadingModel = SPECULAR_BLINN;
			} else {
				data.shadingModel = SPECULAR_PHONG;
			}
		}

		if (data.shader) delete data.shader;

		if (data.mapping_format) {
			data.mappingFormat = data.mapping_format;
			delete data.mapping_format;
		}

		let i;
		const RENAMED_PROPERTIES = [["bumpMapFactor", "bumpiness"], ["aoUvSet", "aoMapUv"], ["aoMapVertexColor", "aoVertexColor"], ["diffuseMapVertexColor", "diffuseVertexColor"], ["emissiveMapVertexColor", "emissiveVertexColor"], ["specularMapVertexColor", "specularVertexColor"], ["metalnessMapVertexColor", "metalnessVertexColor"], ["opacityMapVertexColor", "opacityVertexColor"], ["glossMapVertexColor", "glossVertexColor"], ["lightMapVertexColor", "lightVertexColor"], ["diffuseMapTint", "diffuseTint"], ["specularMapTint", "specularTint"], ["emissiveMapTint", "emissiveTint"], ["metalnessMapTint", "metalnessTint"]];

		for (i = 0; i < RENAMED_PROPERTIES.length; i++) {
			const _old = RENAMED_PROPERTIES[i][0];
			const _new = RENAMED_PROPERTIES[i][1];

			if (data[_old] !== undefined && !(data[_new] !== undefined)) {
				data[_new] = data[_old];
				delete data[_old];
			}
		}

		const DEPRECATED_PROPERTIES = ['fresnelFactor', 'shadowSampleType'];

		for (i = 0; i < DEPRECATED_PROPERTIES.length; i++) {
			const name = DEPRECATED_PROPERTIES[i];

			if (data.hasOwnProperty(name)) {
				delete data[name];
			}
		}

		return data;
	}

	_validate(data) {
		if (!data.validated) {
			if (!this._validator) {
				this._validator = new StandardMaterialValidator();
			}

			this._validator.validate(data);
		}

		return data;
	}

}

const PLACEHOLDER_MAP = {
	aoMap: 'white',
	diffuseMap: 'gray',
	specularMap: 'gray',
	metalnessMap: 'black',
	glossMap: 'gray',
	emissiveMap: 'gray',
	normalMap: 'normal',
	heightMap: 'gray',
	opacityMap: 'gray',
	sphereMap: 'gray',
	lightMap: 'white'
};

class MaterialHandler {
	constructor(app) {
		this._assets = app.assets;
		this._device = app.graphicsDevice;
		this._placeholderTextures = null;
		this._parser = new JsonStandardMaterialParser();
		this.maxRetries = 0;
	}

	load(url, callback) {
		if (typeof url === 'string') {
			url = {
				load: url,
				original: url
			};
		}

		http.get(url.load, {
			retry: this.maxRetries > 0,
			maxRetries: this.maxRetries
		}, function (err, response) {
			if (!err) {
				if (callback) {
					response._engine = true;
					callback(null, response);
				}
			} else {
				if (callback) {
					callback(`Error loading material: ${url.original} [${err}]`);
				}
			}
		});
	}

	open(url, data) {
		const material = this._parser.parse(data);

		if (data._engine) {
			material._data = data;
			delete data._engine;
		}

		return material;
	}

	_createPlaceholders() {
		this._placeholderTextures = {};
		const textures = {
			white: [255, 255, 255, 255],
			gray: [128, 128, 128, 255],
			black: [0, 0, 0, 255],
			normal: [128, 128, 255, 255]
		};

		for (const key in textures) {
			if (!textures.hasOwnProperty(key)) continue;
			this._placeholderTextures[key] = new Texture(this._device, {
				width: 2,
				height: 2,
				format: PIXELFORMAT_R8_G8_B8_A8
			});
			this._placeholderTextures[key].name = 'placeholder';

			const pixels = this._placeholderTextures[key].lock();

			for (let i = 0; i < 4; i++) {
				for (let c = 0; c < 4; c++) {
					pixels[i * 4 + c] = textures[key][c];
				}
			}

			this._placeholderTextures[key].unlock();
		}
	}

	patch(asset, assets) {
		if (asset.resource._data) {
			asset._data = asset.resource._data;
			delete asset.resource._data;
		}

		asset.data.name = asset.name;
		asset.resource.name = asset.name;

		this._bindAndAssignAssets(asset, assets);

		asset.off('unload', this._onAssetUnload, this);
		asset.on('unload', this._onAssetUnload, this);
	}

	_onAssetUnload(asset) {
		delete asset.data.parameters;
		delete asset.data.chunks;
		delete asset.data.name;
	}

	_assignTexture(parameterName, materialAsset, texture) {
		materialAsset.resource[parameterName] = texture;
	}

	_getPlaceholderTexture(parameterName) {
		if (!this._placeholderTextures) {
			this._createPlaceholders();
		}

		const placeholder = PLACEHOLDER_MAP[parameterName];
		const texture = this._placeholderTextures[placeholder];
		return texture;
	}

	_assignPlaceholderTexture(parameterName, materialAsset) {
		materialAsset.resource[parameterName] = this._getPlaceholderTexture(parameterName, materialAsset);
	}

	_onTextureLoad(parameterName, materialAsset, textureAsset) {
		this._assignTexture(parameterName, materialAsset, textureAsset.resource);

		materialAsset.resource.update();
	}

	_onTextureAdd(parameterName, materialAsset, textureAsset) {
		this._assets.load(textureAsset);
	}

	_onTextureRemoveOrUnload(parameterName, materialAsset, textureAsset) {
		const material = materialAsset.resource;

		if (material) {
			if (materialAsset.resource[parameterName] === textureAsset.resource) {
				this._assignPlaceholderTexture(parameterName, materialAsset);

				material.update();
			}
		}
	}

	_assignCubemap(parameterName, materialAsset, textures) {
		materialAsset.resource[parameterName] = textures[0];

		if (parameterName === 'cubeMap') {
			materialAsset.resource.prefilteredCubemaps = textures.slice(1);
		}
	}

	_onCubemapLoad(parameterName, materialAsset, cubemapAsset) {
		this._assignCubemap(parameterName, materialAsset, cubemapAsset.resources);

		this._parser.initialize(materialAsset.resource, materialAsset.data);
	}

	_onCubemapAdd(parameterName, materialAsset, cubemapAsset) {
		if (materialAsset.data.shadingModel === SPECULAR_PHONG) {
			materialAsset.loadFaces = true;
		}

		this._assets.load(cubemapAsset);
	}

	_onCubemapRemoveOrUnload(parameterName, materialAsset, cubemapAsset) {
		const material = materialAsset.resource;

		if (materialAsset.data.prefilteredCubeMap128 === cubemapAsset.resources[1]) {
			this._assignCubemap(parameterName, materialAsset, [null, null, null, null, null, null, null]);

			material.update();
		}
	}

	_bindAndAssignAssets(materialAsset, assets) {
		const data = this._parser.migrate(materialAsset.data);

		const material = materialAsset.resource;
		const pathMapping = data.mappingFormat === "path";
		const TEXTURES = standardMaterialTextureParameters;
		let i, name, assetReference;

		for (i = 0; i < TEXTURES.length; i++) {
			name = TEXTURES[i];
			assetReference = material._assetReferences[name];
			const dataAssetId = data[name];
			const materialTexture = material[name];

			const isPlaceHolderTexture = materialTexture === this._getPlaceholderTexture(name, materialAsset);

			const dataValidated = data.validated;

			if (dataAssetId && (!materialTexture || !dataValidated || isPlaceHolderTexture)) {
				if (!assetReference) {
					assetReference = new AssetReference(name, materialAsset, assets, {
						load: this._onTextureLoad,
						add: this._onTextureAdd,
						remove: this._onTextureRemoveOrUnload,
						unload: this._onTextureRemoveOrUnload
					}, this);
					material._assetReferences[name] = assetReference;
				}

				if (pathMapping) {
					assetReference.url = materialAsset.getAbsoluteUrl(dataAssetId);
				} else {
					assetReference.id = dataAssetId;
				}

				if (assetReference.asset) {
					if (assetReference.asset.resource) {
						this._assignTexture(name, materialAsset, assetReference.asset.resource);
					} else {
						this._assignPlaceholderTexture(name, materialAsset);
					}

					assets.load(assetReference.asset);
				}
			} else {
				if (assetReference) {
					if (pathMapping) {
						assetReference.url = null;
					} else {
						assetReference.id = null;
					}
				}
			}
		}

		const CUBEMAPS = standardMaterialCubemapParameters;

		for (i = 0; i < CUBEMAPS.length; i++) {
			name = CUBEMAPS[i];
			assetReference = material._assetReferences[name];

			if (data[name] && !materialAsset.data.prefilteredCubeMap128) {
				if (!assetReference) {
					assetReference = new AssetReference(name, materialAsset, assets, {
						load: this._onCubemapLoad,
						add: this._onCubemapAdd,
						remove: this._onCubemapRemoveOrUnload,
						unload: this._onCubemapRemoveOrUnload
					}, this);
					material._assetReferences[name] = assetReference;
				}

				if (pathMapping) {
					assetReference.url = data[name];
				} else {
					assetReference.id = data[name];
				}

				if (assetReference.asset) {
					if (assetReference.asset.loaded) {
						this._assignCubemap(name, materialAsset, assetReference.asset.resources);
					}

					assets.load(assetReference.asset);
				}
			}
		}

		this._parser.initialize(material, data);
	}

}

class GlbModelParser {
	constructor(device, defaultMaterial) {
		this._device = device;
		this._defaultMaterial = defaultMaterial;
	}

	parse(data) {
		const glbResources = GlbParser.parse("filename.glb", data, this._device);

		if (glbResources) {
			const model = GlbContainerResource.createModel(glbResources, this._defaultMaterial);
			glbResources.destroy();
			return model;
		}

		return null;
	}

}

class PartitionedVertex {
	constructor() {
		this.index = 0;
		this.boneIndices = [0, 0, 0, 0];
	}

}

class SkinPartition {
	constructor() {
		this.partition = 0;
		this.vertexStart = 0;
		this.vertexCount = 0;
		this.indexStart = 0;
		this.indexCount = 0;
		this.boneIndices = [];
		this.vertices = [];
		this.indices = [];
		this.indexMap = {};
		this.originalMesh = null;
	}

	addVertex(vertex, idx, vertexArray) {
		let remappedIndex = -1;

		if (this.indexMap[idx] !== undefined) {
			remappedIndex = this.indexMap[idx];
			this.indices.push(remappedIndex);
		} else {
			for (let influence = 0; influence < 4; influence++) {
				if (vertexArray.blendWeight.data[idx * 4 + influence] === 0) continue;
				const originalBoneIndex = vertexArray.blendIndices.data[vertex.index * 4 + influence];
				vertex.boneIndices[influence] = this.getBoneRemap(originalBoneIndex);
			}

			remappedIndex = this.vertices.length;
			this.indices.push(remappedIndex);
			this.vertices.push(vertex);
			this.indexMap[idx] = remappedIndex;
		}
	}

	addPrimitive(vertices, vertexIndices, vertexArray, boneLimit) {
		const bonesToAdd = [];
		let bonesToAddCount = 0;
		const vertexCount = vertices.length;

		for (let i = 0; i < vertexCount; i++) {
			const vertex = vertices[i];
			const idx = vertex.index;

			for (let influence = 0; influence < 4; influence++) {
				if (vertexArray.blendWeight.data[idx * 4 + influence] > 0) {
					const boneIndex = vertexArray.blendIndices.data[idx * 4 + influence];
					let needToAdd = true;

					for (let j = 0; j < bonesToAddCount; j++) {
						if (bonesToAdd[j] === boneIndex) {
							needToAdd = false;
							break;
						}
					}

					if (needToAdd) {
						bonesToAdd[bonesToAddCount] = boneIndex;
						const boneRemap = this.getBoneRemap(boneIndex);
						bonesToAddCount += boneRemap === -1 ? 1 : 0;
					}
				}
			}
		}

		if (this.boneIndices.length + bonesToAddCount > boneLimit) {
			return false;
		}

		for (let i = 0; i < bonesToAddCount; i++) {
			this.boneIndices.push(bonesToAdd[i]);
		}

		for (let i = 0; i < vertexCount; i++) {
			this.addVertex(vertices[i], vertexIndices[i], vertexArray);
		}

		return true;
	}

	getBoneRemap(boneIndex) {
		for (let i = 0; i < this.boneIndices.length; i++) {
			if (this.boneIndices[i] === boneIndex) {
				return i;
			}
		}

		return -1;
	}

}

function indicesToReferences(model) {
	const vertices = model.vertices;
	const skins = model.skins;
	const meshes = model.meshes;
	const meshInstances = model.meshInstances;

	for (let i = 0; i < meshes.length; i++) {
		meshes[i].vertices = vertices[meshes[i].vertices];

		if (meshes[i].skin !== undefined) {
			meshes[i].skin = skins[meshes[i].skin];
		}
	}

	for (let i = 0; i < meshInstances.length; i++) {
		meshInstances[i].mesh = meshes[meshInstances[i].mesh];
	}
}

function referencesToIndices(model) {
	const vertices = model.vertices;
	const skins = model.skins;
	const meshes = model.meshes;
	const meshInstances = model.meshInstances;

	for (let i = 0; i < meshes.length; i++) {
		meshes[i].vertices = vertices.indexOf(meshes[i].vertices);

		if (meshes[i].skin !== undefined) {
			meshes[i].skin = skins.indexOf(meshes[i].skin);
		}
	}

	for (let i = 0; i < meshInstances.length; i++) {
		meshInstances[i].mesh = meshes.indexOf(meshInstances[i].mesh);
	}
}

function partitionSkin(model, materialMappings, boneLimit) {
	let i, j, k, index;
	indicesToReferences(model);
	const vertexArrays = model.vertices;
	const skins = model.skins;
	let mesh;
	const meshes = model.meshes;
	const meshInstances = model.meshInstances;

	const getVertex = function getVertex(idx) {
		const vert = new PartitionedVertex();
		vert.index = idx;
		return vert;
	};

	for (i = skins.length - 1; i >= 0; i--) {
		if (skins[i].boneNames.length > boneLimit) {
			const skin = skins.splice(i, 1)[0];
			const meshesToSplit = [];

			for (j = 0; j < meshes.length; j++) {
				if (meshes[j].skin === skin) {
					meshesToSplit.push(meshes[j]);
				}
			}

			for (j = 0; j < meshesToSplit.length; j++) {
				index = meshes.indexOf(meshesToSplit[j]);

				if (index !== -1) {
					meshes.splice(index, 1);
				}
			}

			if (meshesToSplit.length === 0) {
				throw new Error('partitionSkin: There should be at least one mesh that references a skin');
			}

			const vertexArray = meshesToSplit[0].vertices;

			for (j = 1; j < meshesToSplit.length; j++) {
				if (meshesToSplit[j].vertices !== vertexArray) {
					throw new Error('partitionSkin: All meshes that share a skin should also share the same vertex buffer');
				}
			}

			let partition;
			const partitions = [];
			const primitiveVertices = [];
			const primitiveIndices = [];
			let basePartition = 0;

			for (j = 0; j < meshesToSplit.length; j++) {
				mesh = meshesToSplit[j];
				const indices = mesh.indices;

				for (let iIndex = mesh.base; iIndex < mesh.base + mesh.count;) {
					index = indices[iIndex++];
					primitiveVertices[0] = getVertex(index);
					primitiveIndices[0] = index;
					index = indices[iIndex++];
					primitiveVertices[1] = getVertex(index);
					primitiveIndices[1] = index;
					index = indices[iIndex++];
					primitiveVertices[2] = getVertex(index);
					primitiveIndices[2] = index;
					let added = false;

					for (let iBonePartition = basePartition; iBonePartition < partitions.length; iBonePartition++) {
						partition = partitions[iBonePartition];

						if (partition.addPrimitive(primitiveVertices, primitiveIndices, vertexArray, boneLimit)) {
							added = true;
							break;
						}
					}

					if (!added) {
						partition = new SkinPartition();
						partition.originalMesh = mesh;
						partition.addPrimitive(primitiveVertices, primitiveIndices, vertexArray, boneLimit);
						partitions.push(partition);
					}
				}

				basePartition = partitions.length;
			}

			const partitionedVertices = [];
			const partitionedIndices = [];

			for (j = 0; j < partitions.length; j++) {
				partition = partitions[j];

				if (partition.vertices.length && partition.indices.length) {
					const vertexStart = partitionedVertices.length;
					const vertexCount = partition.vertices.length;
					const indexStart = partitionedIndices.length;
					const indexCount = partition.indices.length;
					partition.partition = j;
					partition.vertexStart = vertexStart;
					partition.vertexCount = vertexCount;
					partition.indexStart = indexStart;
					partition.indexCount = indexCount;
					let iSour;
					let iDest;
					iSour = 0;
					iDest = vertexStart;

					while (iSour < vertexCount) {
						partitionedVertices[iDest++] = partition.vertices[iSour++];
					}

					iSour = 0;
					iDest = indexStart;

					while (iSour < indexCount) {
						partitionedIndices[iDest++] = partition.indices[iSour++] + vertexStart;
					}
				}
			}

			const splitSkins = [];

			for (j = 0; j < partitions.length; j++) {
				partition = partitions[j];
				const ibp = [];
				const boneNames = [];

				for (k = 0; k < partition.boneIndices.length; k++) {
					ibp.push(skin.inverseBindMatrices[partition.boneIndices[k]]);
					boneNames.push(skin.boneNames[partition.boneIndices[k]]);
				}

				const splitSkin = {
					inverseBindMatrices: ibp,
					boneNames: boneNames
				};
				splitSkins.push(splitSkin);
				skins.push(splitSkin);
			}

			let attrib, attribName, data, components;
			const splitVertexArray = {};

			for (attribName in vertexArray) {
				splitVertexArray[attribName] = {
					components: vertexArray[attribName].components,
					data: [],
					type: vertexArray[attribName].type
				};
			}

			for (attribName in vertexArray) {
				if (attribName === 'blendIndices') {
					const dstBoneIndices = splitVertexArray[attribName].data;

					for (j = 0; j < partitionedVertices.length; j++) {
						const srcBoneIndices = partitionedVertices[j].boneIndices;
						dstBoneIndices.push(srcBoneIndices[0], srcBoneIndices[1], srcBoneIndices[2], srcBoneIndices[3]);
					}
				} else {
					attrib = vertexArray[attribName];
					data = attrib.data;
					components = attrib.components;

					for (j = 0; j < partitionedVertices.length; j++) {
						index = partitionedVertices[j].index;

						for (k = 0; k < components; k++) {
							splitVertexArray[attribName].data.push(data[index * components + k]);
						}
					}
				}
			}

			vertexArrays[vertexArrays.indexOf(vertexArray)] = splitVertexArray;

			for (j = 0; j < partitions.length; j++) {
				partition = partitions[j];
				mesh = {
					aabb: {
						min: [0, 0, 0],
						max: [0, 0, 0]
					},
					vertices: splitVertexArray,
					skin: splitSkins[j],
					indices: partitionedIndices.splice(0, partition.indexCount),
					type: 'triangles',
					base: 0,
					count: partition.indexCount
				};
				meshes.push(mesh);

				for (k = meshInstances.length - 1; k >= 0; k--) {
					if (meshInstances[k].mesh === partition.originalMesh) {
						meshInstances.push({
							mesh: mesh,
							node: meshInstances[k].node
						});

						if (materialMappings) {
							materialMappings.push({
								material: materialMappings[k].material,
								path: materialMappings[k].path
							});
						}
					}
				}
			}

			for (j = 0; j < partitions.length; j++) {
				partition = partitions[j];

				for (k = meshInstances.length - 1; k >= 0; k--) {
					if (meshInstances[k].mesh === partition.originalMesh) {
						meshInstances.splice(k, 1);

						if (materialMappings) {
							materialMappings.splice(k, 1);
						}
					}
				}
			}
		}
	}

	referencesToIndices(model);
}

const JSON_PRIMITIVE_TYPE = {
	"points": PRIMITIVE_POINTS,
	"lines": PRIMITIVE_LINES,
	"lineloop": PRIMITIVE_LINELOOP,
	"linestrip": PRIMITIVE_LINESTRIP,
	"triangles": PRIMITIVE_TRIANGLES,
	"trianglestrip": PRIMITIVE_TRISTRIP,
	"trianglefan": PRIMITIVE_TRIFAN
};
const JSON_VERTEX_ELEMENT_TYPE = {
	"int8": TYPE_INT8,
	"uint8": TYPE_UINT8,
	"int16": TYPE_INT16,
	"uint16": TYPE_UINT16,
	"int32": TYPE_INT32,
	"uint32": TYPE_UINT32,
	"float32": TYPE_FLOAT32
};

class JsonModelParser {
	constructor(device, defaultMaterial) {
		this._device = device;
		this._defaultMaterial = defaultMaterial;
	}

	parse(data) {
		const modelData = data.model;

		if (!modelData) {
			return null;
		}

		if (modelData.version <= 1) {
			return null;
		}

		const nodes = this._parseNodes(data);

		const skins = this._parseSkins(data, nodes);

		const vertexBuffers = this._parseVertexBuffers(data);

		const indices = this._parseIndexBuffers(data, vertexBuffers);

		const morphs = this._parseMorphs(data, nodes, vertexBuffers);

		const meshes = this._parseMeshes(data, skins.skins, morphs.morphs, vertexBuffers, indices.buffer, indices.data);

		const meshInstances = this._parseMeshInstances(data, nodes, meshes, skins.skins, skins.instances, morphs.morphs, morphs.instances);

		const model = new Model();
		model.graph = nodes[0];
		model.meshInstances = meshInstances;
		model.skinInstances = skins.instances;
		model.morphInstances = morphs.instances;
		model.getGraph().syncHierarchy();
		return model;
	}

	_parseNodes(data) {
		const modelData = data.model;
		const nodes = [];
		let i;

		for (i = 0; i < modelData.nodes.length; i++) {
			const nodeData = modelData.nodes[i];
			const node = new GraphNode(nodeData.name);
			node.setLocalPosition(nodeData.position[0], nodeData.position[1], nodeData.position[2]);
			node.setLocalEulerAngles(nodeData.rotation[0], nodeData.rotation[1], nodeData.rotation[2]);
			node.setLocalScale(nodeData.scale[0], nodeData.scale[1], nodeData.scale[2]);
			node.scaleCompensation = !!nodeData.scaleCompensation;
			nodes.push(node);
		}

		for (i = 1; i < modelData.parents.length; i++) {
			nodes[modelData.parents[i]].addChild(nodes[i]);
		}

		return nodes;
	}

	_parseSkins(data, nodes) {
		const modelData = data.model;
		const skins = [];
		const skinInstances = [];
		let i, j;

		if (!this._device.supportsBoneTextures && modelData.skins.length > 0) {
			const boneLimit = this._device.getBoneLimit();

			partitionSkin(modelData, null, boneLimit);
		}

		for (i = 0; i < modelData.skins.length; i++) {
			const skinData = modelData.skins[i];
			const inverseBindMatrices = [];

			for (j = 0; j < skinData.inverseBindMatrices.length; j++) {
				const ibm = skinData.inverseBindMatrices[j];
				inverseBindMatrices[j] = new Mat4().set(ibm);
			}

			const skin = new Skin(this._device, inverseBindMatrices, skinData.boneNames);
			skins.push(skin);
			const skinInstance = new SkinInstance(skin);
			const bones = [];

			for (j = 0; j < skin.boneNames.length; j++) {
				const boneName = skin.boneNames[j];
				const bone = nodes[0].findByName(boneName);
				bones.push(bone);
			}

			skinInstance.bones = bones;
			skinInstances.push(skinInstance);
		}

		return {
			skins: skins,
			instances: skinInstances
		};
	}

	_getMorphVertexCount(modelData, morphIndex, vertexBuffers) {
		for (let i = 0; i < modelData.meshes.length; i++) {
			const meshData = modelData.meshes[i];

			if (meshData.morph === morphIndex) {
				const vertexBuffer = vertexBuffers[meshData.vertices];
				return vertexBuffer.numVertices;
			}
		}

		return undefined;
	}

	_parseMorphs(data, nodes, vertexBuffers) {
		const modelData = data.model;
		const morphs = [];
		const morphInstances = [];
		let i, j, vertexCount;
		let targets, morphTarget, morphTargetArray;

		if (modelData.morphs) {
			const sparseToFull = function sparseToFull(data, indices, totalCount) {
				const full = new Float32Array(totalCount * 3);

				for (let s = 0; s < indices.length; s++) {
					const dstIndex = indices[s] * 3;
					full[dstIndex] = data[s * 3];
					full[dstIndex + 1] = data[s * 3 + 1];
					full[dstIndex + 2] = data[s * 3 + 2];
				}

				return full;
			};

			for (i = 0; i < modelData.morphs.length; i++) {
				targets = modelData.morphs[i].targets;
				morphTargetArray = [];
				vertexCount = this._getMorphVertexCount(modelData, i, vertexBuffers);

				for (j = 0; j < targets.length; j++) {
					const targetAabb = targets[j].aabb;
					const min = targetAabb.min;
					const max = targetAabb.max;
					const aabb = new BoundingBox(new Vec3((max[0] + min[0]) * 0.5, (max[1] + min[1]) * 0.5, (max[2] + min[2]) * 0.5), new Vec3((max[0] - min[0]) * 0.5, (max[1] - min[1]) * 0.5, (max[2] - min[2]) * 0.5));
					const indices = targets[j].indices;
					let deltaPositions = targets[j].deltaPositions;
					let deltaNormals = targets[j].deltaNormals;

					if (indices) {
						deltaPositions = sparseToFull(deltaPositions, indices, vertexCount);
						deltaNormals = sparseToFull(deltaNormals, indices, vertexCount);
					}

					morphTarget = new MorphTarget({
						deltaPositions: deltaPositions,
						deltaNormals: deltaNormals,
						name: targets[j].name,
						aabb: aabb
					});
					morphTargetArray.push(morphTarget);
				}

				const morph = new Morph(morphTargetArray, this._device);
				morphs.push(morph);
				const morphInstance = new MorphInstance(morph);
				morphInstances.push(morphInstance);
			}
		}

		return {
			morphs: morphs,
			instances: morphInstances
		};
	}

	_parseVertexBuffers(data) {
		const modelData = data.model;
		const vertexBuffers = [];
		const attributeMap = {
			position: SEMANTIC_POSITION,
			normal: SEMANTIC_NORMAL,
			tangent: SEMANTIC_TANGENT,
			blendWeight: SEMANTIC_BLENDWEIGHT,
			blendIndices: SEMANTIC_BLENDINDICES,
			color: SEMANTIC_COLOR,
			texCoord0: SEMANTIC_TEXCOORD0,
			texCoord1: SEMANTIC_TEXCOORD1,
			texCoord2: SEMANTIC_TEXCOORD2,
			texCoord3: SEMANTIC_TEXCOORD3,
			texCoord4: SEMANTIC_TEXCOORD4,
			texCoord5: SEMANTIC_TEXCOORD5,
			texCoord6: SEMANTIC_TEXCOORD6,
			texCoord7: SEMANTIC_TEXCOORD7
		};

		for (let i = 0; i < modelData.vertices.length; i++) {
			const vertexData = modelData.vertices[i];
			const formatDesc = [];

			for (const attributeName in vertexData) {
				const attribute = vertexData[attributeName];
				formatDesc.push({
					semantic: attributeMap[attributeName],
					components: attribute.components,
					type: JSON_VERTEX_ELEMENT_TYPE[attribute.type],
					normalize: attributeMap[attributeName] === SEMANTIC_COLOR
				});
			}

			const vertexFormat = new VertexFormat(this._device, formatDesc);
			const numVertices = vertexData.position.data.length / vertexData.position.components;
			const vertexBuffer = new VertexBuffer(this._device, vertexFormat, numVertices);
			const iterator = new VertexIterator(vertexBuffer);

			for (let j = 0; j < numVertices; j++) {
				for (const attributeName in vertexData) {
					const attribute = vertexData[attributeName];

					switch (attribute.components) {
						case 1:
							iterator.element[attributeMap[attributeName]].set(attribute.data[j]);
							break;

						case 2:
							iterator.element[attributeMap[attributeName]].set(attribute.data[j * 2], 1.0 - attribute.data[j * 2 + 1]);
							break;

						case 3:
							iterator.element[attributeMap[attributeName]].set(attribute.data[j * 3], attribute.data[j * 3 + 1], attribute.data[j * 3 + 2]);
							break;

						case 4:
							iterator.element[attributeMap[attributeName]].set(attribute.data[j * 4], attribute.data[j * 4 + 1], attribute.data[j * 4 + 2], attribute.data[j * 4 + 3]);
							break;
					}
				}

				iterator.next();
			}

			iterator.end();
			vertexBuffers.push(vertexBuffer);
		}

		return vertexBuffers;
	}

	_parseIndexBuffers(data, vertexBuffers) {
		const modelData = data.model;
		let indexBuffer = null;
		let indexData = null;
		let i;
		let numIndices = 0;

		for (i = 0; i < modelData.meshes.length; i++) {
			const meshData = modelData.meshes[i];

			if (meshData.indices !== undefined) {
				numIndices += meshData.indices.length;
			}
		}

		let maxVerts = 0;

		for (i = 0; i < vertexBuffers.length; i++) {
			maxVerts = Math.max(maxVerts, vertexBuffers[i].numVertices);
		}

		if (numIndices > 0) {
			if (maxVerts > 0xFFFF && this._device.extUintElement) {
				indexBuffer = new IndexBuffer(this._device, INDEXFORMAT_UINT32, numIndices);
				indexData = new Uint32Array(indexBuffer.lock());
			} else {
				indexBuffer = new IndexBuffer(this._device, INDEXFORMAT_UINT16, numIndices);
				indexData = new Uint16Array(indexBuffer.lock());
			}
		}

		return {
			buffer: indexBuffer,
			data: indexData
		};
	}

	_parseMeshes(data, skins, morphs, vertexBuffers, indexBuffer, indexData) {
		const modelData = data.model;
		const meshes = [];
		let indexBase = 0;

		for (let i = 0; i < modelData.meshes.length; i++) {
			const meshData = modelData.meshes[i];
			const meshAabb = meshData.aabb;
			const min = meshAabb.min;
			const max = meshAabb.max;
			const aabb = new BoundingBox(new Vec3((max[0] + min[0]) * 0.5, (max[1] + min[1]) * 0.5, (max[2] + min[2]) * 0.5), new Vec3((max[0] - min[0]) * 0.5, (max[1] - min[1]) * 0.5, (max[2] - min[2]) * 0.5));
			const indexed = meshData.indices !== undefined;
			const mesh = new Mesh(this._device);
			mesh.vertexBuffer = vertexBuffers[meshData.vertices];
			mesh.indexBuffer[0] = indexed ? indexBuffer : null;
			mesh.primitive[0].type = JSON_PRIMITIVE_TYPE[meshData.type];
			mesh.primitive[0].base = indexed ? meshData.base + indexBase : meshData.base;
			mesh.primitive[0].count = meshData.count;
			mesh.primitive[0].indexed = indexed;
			mesh.skin = meshData.skin !== undefined ? skins[meshData.skin] : null;
			mesh.morph = meshData.morph !== undefined ? morphs[meshData.morph] : null;
			mesh.aabb = aabb;

			if (indexed) {
				indexData.set(meshData.indices, indexBase);
				indexBase += meshData.indices.length;
			}

			meshes.push(mesh);
		}

		if (indexBuffer !== null) {
			indexBuffer.unlock();
		}

		return meshes;
	}

	_parseMeshInstances(data, nodes, meshes, skins, skinInstances, morphs, morphInstances) {
		const modelData = data.model;
		const meshInstances = [];
		let i;

		for (i = 0; i < modelData.meshInstances.length; i++) {
			const meshInstanceData = modelData.meshInstances[i];
			const node = nodes[meshInstanceData.node];
			const mesh = meshes[meshInstanceData.mesh];
			const meshInstance = new MeshInstance(mesh, this._defaultMaterial, node);

			if (mesh.skin) {
				const skinIndex = skins.indexOf(mesh.skin);
				meshInstance.skinInstance = skinInstances[skinIndex];
			}

			if (mesh.morph) {
				const morphIndex = morphs.indexOf(mesh.morph);
				meshInstance.morphInstance = morphInstances[morphIndex];
			}

			meshInstances.push(meshInstance);
		}

		return meshInstances;
	}

}

class ModelHandler {
	constructor(device) {
		this._device = device;
		this._parsers = [];
		this._defaultMaterial = getDefaultMaterial(device);
		this.maxRetries = 0;
		this.addParser(new JsonModelParser(this._device, this._defaultMaterial), function (url, data) {
			return path.getExtension(url) === '.json';
		});
		this.addParser(new GlbModelParser(this._device, this._defaultMaterial), function (url, data) {
			return path.getExtension(url) === '.glb';
		});
	}

	load(url, callback) {
		if (typeof url === 'string') {
			url = {
				load: url,
				original: url
			};
		}

		const options = {
			retry: this.maxRetries > 0,
			maxRetries: this.maxRetries
		};

		if (url.load.startsWith('blob:') || url.load.startsWith('data:')) {
			if (path.getExtension(url.original).toLowerCase() === '.glb') {
				options.responseType = Http.ResponseType.ARRAY_BUFFER;
			} else {
				options.responseType = Http.ResponseType.JSON;
			}
		}

		http.get(url.load, options, function (err, response) {
			if (!callback) return;

			if (!err) {
				callback(null, response);
			} else {
				callback(`Error loading model: ${url.original} [${err}]`);
			}
		});
	}

	open(url, data) {
		for (let i = 0; i < this._parsers.length; i++) {
			const p = this._parsers[i];

			if (p.decider(url, data)) {
				return p.parser.parse(data);
			}
		}

		return null;
	}

	patch(asset, assets) {
		if (!asset.resource) return;
		const data = asset.data;
		const self = this;
		asset.resource.meshInstances.forEach(function (meshInstance, i) {
			if (data.mapping) {
				const handleMaterial = function handleMaterial(asset) {
					if (asset.resource) {
						meshInstance.material = asset.resource;
					} else {
						asset.once('load', handleMaterial);
						assets.load(asset);
					}

					asset.once('remove', function (asset) {
						if (meshInstance.material === asset.resource) {
							meshInstance.material = self._defaultMaterial;
						}
					});
				};

				if (!data.mapping[i]) {
					meshInstance.material = self._defaultMaterial;
					return;
				}

				const id = data.mapping[i].material;
				const url = data.mapping[i].path;
				let material;

				if (id !== undefined) {
					if (!id) {
						meshInstance.material = self._defaultMaterial;
					} else {
						material = assets.get(id);

						if (material) {
							handleMaterial(material);
						} else {
							assets.once('add:' + id, handleMaterial);
						}
					}
				} else if (url) {
					const path = asset.getAbsoluteUrl(data.mapping[i].path);
					material = assets.getByUrl(path);

					if (material) {
						handleMaterial(material);
					} else {
						assets.once('add:url:' + path, handleMaterial);
					}
				}
			}
		});
	}

	addParser(parser, decider) {
		this._parsers.push({
			parser: parser,
			decider: decider
		});
	}

}

function onContainerAssetLoaded(containerAsset) {
	const renderAsset = this;
	if (!renderAsset.resource) return;
	const containerResource = containerAsset.resource;
	const render = containerResource.renders && containerResource.renders[renderAsset.data.renderIndex];

	if (render) {
		renderAsset.resource.meshes = render.resource.meshes;
	}
}

function onContainerAssetAdded(containerAsset) {
	const renderAsset = this;
	renderAsset.registry.off('load:' + containerAsset.id, onContainerAssetLoaded, renderAsset);
	renderAsset.registry.on('load:' + containerAsset.id, onContainerAssetLoaded, renderAsset);
	renderAsset.registry.off('remove:' + containerAsset.id, onContainerAssetRemoved, renderAsset);
	renderAsset.registry.once('remove:' + containerAsset.id, onContainerAssetRemoved, renderAsset);

	if (!containerAsset.resource) {
		renderAsset.registry.load(containerAsset);
	} else {
		onContainerAssetLoaded.call(renderAsset, containerAsset);
	}
}

function onContainerAssetRemoved(containerAsset) {
	const renderAsset = this;
	renderAsset.registry.off('load:' + containerAsset.id, onContainerAssetLoaded, renderAsset);

	if (renderAsset.resource) {
		renderAsset.resource.destroy();
	}
}

class RenderHandler {
	constructor(assets) {
		this._registry = assets;
	}

	load(url, callback, asset) {}

	open(url, data) {
		return new Render();
	}

	patch(asset, registry) {
		if (!asset.data.containerAsset) return;
		const containerAsset = registry.get(asset.data.containerAsset);

		if (!containerAsset) {
			registry.once('add:' + asset.data.containerAsset, onContainerAssetAdded, asset);
			return;
		}

		onContainerAssetAdded.call(asset, containerAsset);
	}

}

class ResourceLoader {
	constructor(app) {
		this._handlers = {};
		this._requests = {};
		this._cache = {};
		this._app = app;
	}

	addHandler(type, handler) {
		this._handlers[type] = handler;
		handler._loader = this;
	}

	removeHandler(type) {
		delete this._handlers[type];
	}

	getHandler(type) {
		return this._handlers[type];
	}

	load(url, type, callback, asset) {
		const handler = this._handlers[type];

		if (!handler) {
			const err = "No handler for asset type: " + type;
			callback(err);
			return;
		}

		if (!url) {
			this._loadNull(handler, callback, asset);

			return;
		}

		const key = url + type;

		if (this._cache[key] !== undefined) {
			callback(null, this._cache[key]);
		} else if (this._requests[key]) {
			this._requests[key].push(callback);
		} else {
			this._requests[key] = [callback];
			const self = this;

			const handleLoad = function handleLoad(err, urlObj) {
				if (err) {
					self._onFailure(key, err);

					return;
				}

				handler.load(urlObj, function (err, data, extra) {
					if (!self._requests[key]) {
						return;
					}

					if (err) {
						self._onFailure(key, err);

						return;
					}

					try {
						self._onSuccess(key, handler.open(urlObj.original, data, asset), extra);
					} catch (e) {
						self._onFailure(key, e);
					}
				}, asset);
			};

			const normalizedUrl = url.split('?')[0];

			if (this._app.enableBundles && this._app.bundles.hasUrl(normalizedUrl)) {
				if (!this._app.bundles.canLoadUrl(normalizedUrl)) {
					handleLoad(`Bundle for ${url} not loaded yet`);
					return;
				}

				this._app.bundles.loadUrl(normalizedUrl, function (err, fileUrlFromBundle) {
					handleLoad(err, {
						load: fileUrlFromBundle,
						original: normalizedUrl
					});
				});
			} else {
				handleLoad(null, {
					load: url,
					original: asset && asset.file.filename || url
				});
			}
		}
	}

	_loadNull(handler, callback, asset) {
		const onLoad = function onLoad(err, data, extra) {
			if (err) {
				callback(err);
			} else {
				try {
					callback(null, handler.open(null, data, asset), extra);
				} catch (e) {
					callback(e);
				}
			}
		};

		handler.load(null, onLoad, asset);
	}

	_onSuccess(key, result, extra) {
		this._cache[key] = result;

		for (let i = 0; i < this._requests[key].length; i++) {
			this._requests[key][i](null, result, extra);
		}

		delete this._requests[key];
	}

	_onFailure(key, err) {
		console.error(err);

		if (this._requests[key]) {
			for (let i = 0; i < this._requests[key].length; i++) {
				this._requests[key][i](err);
			}

			delete this._requests[key];
		}
	}

	open(type, data) {
		const handler = this._handlers[type];

		if (!handler) {
			console.warn("No resource handler found for: " + type);
			return data;
		}

		return handler.open(null, data);
	}

	patch(asset, assets) {
		const handler = this._handlers[asset.type];

		if (!handler) {
			console.warn("No resource handler found for: " + asset.type);
			return;
		}

		if (handler.patch) {
			handler.patch(asset, assets);
		}
	}

	clearCache(url, type) {
		delete this._cache[url + type];
	}

	getFromCache(url, type) {
		if (this._cache[url + type]) {
			return this._cache[url + type];
		}
	}

	enableRetry(maxRetries = 5) {
		maxRetries = Math.max(0, maxRetries) || 0;

		for (const key in this._handlers) {
			this._handlers[key].maxRetries = maxRetries;
		}
	}

	disableRetry() {
		for (const key in this._handlers) {
			this._handlers[key].maxRetries = 0;
		}
	}

	destroy() {
		this._handlers = {};
		this._requests = {};
		this._cache = {};
	}

}

class SceneHandler {
	constructor(app) {
		this._app = app;
		this.maxRetries = 0;
	}

	load(url, callback) {
		SceneUtils.load(url, this.maxRetries, callback);
	}

	open(url, data) {
		this._app.systems.script.preloading = true;
		const parser = new SceneParser(this._app, false);
		const parent = parser.parse(data);
		const scene = this._app.scene;
		scene.root = parent;

		this._app.applySceneSettings(data.settings);

		this._app.systems.script.preloading = false;
		return scene;
	}

	patch(asset, assets) {}

}

let _legacy = false;
let _createdLoadingScreen = false;
const script = {
	app: null,
	create: function (name, callback) {
		if (!_legacy) return;
		const ScriptType = callback(script.app);
		ScriptType._pcScriptName = name;

		ScriptHandler._push(ScriptType);

		this.fire("created", name, callback);
	},
	attribute: function (name, type, defaultValue, options) {},
	createLoadingScreen: function (callback) {
		if (_createdLoadingScreen) return;
		_createdLoadingScreen = true;
		const app = getApplication();
		callback(app);
	}
};
Object.defineProperty(script, 'legacy', {
	get: function () {
		return _legacy;
	},
	set: function (value) {
		_legacy = value;
	}
});
events.attach(script);

class ScriptHandler {
	constructor(app) {
		this._app = app;
		this._scripts = {};
		this._cache = {};
	}

	static _push(Type) {
		if (script.legacy && ScriptHandler._types.length > 0) {
			console.assert("Script Ordering Error. Contact support@playcanvas.com");
		} else {
			ScriptHandler._types.push(Type);
		}
	}

	load(url, callback) {
		if (typeof url === 'string') {
			url = {
				load: url,
				original: url
			};
		}

		const self = this;
		script.app = this._app;

		this._loadScript(url.load, (err, url, extra) => {
			if (!err) {
				if (script.legacy) {
					let Type = null;

					if (ScriptHandler._types.length) {
						Type = ScriptHandler._types.pop();
					}

					if (Type) {
						this._scripts[url] = Type;
					} else {
						Type = null;
					}

					callback(null, Type, extra);
				} else {
					const obj = {};

					for (let i = 0; i < ScriptHandler._types.length; i++) obj[ScriptHandler._types[i].name] = ScriptHandler._types[i];

					ScriptHandler._types.length = 0;
					callback(null, obj, extra);
					delete self._loader._cache[url + 'script'];
				}
			} else {
				callback(err);
			}
		});
	}

	open(url, data) {
		return data;
	}

	patch(asset, assets) {}

	_loadScript(url, callback) {
		const head = document.head;
		const element = document.createElement('script');
		this._cache[url] = element;
		element.async = false;
		element.addEventListener('error', function (e) {
			callback(`Script: ${e.target.src} failed to load`);
		}, false);
		let done = false;

		element.onload = element.onreadystatechange = function () {
			if (!done && (!this.readyState || this.readyState === "loaded" || this.readyState === "complete")) {
				done = true;
				callback(null, url, element);
			}
		};

		element.src = url;
		head.appendChild(element);
	}

}

ScriptHandler._types = [];

class ShaderHandler {
	constructor() {
		this.maxRetries = 0;
	}

	load(url, callback) {
		if (typeof url === 'string') {
			url = {
				load: url,
				original: url
			};
		}

		http.get(url.load, {
			retry: this.maxRetries > 0,
			maxRetries: this.maxRetries
		}, function (err, response) {
			if (!err) {
				callback(null, response);
			} else {
				callback(`Error loading shader resource: ${url.original} [${err}]`);
			}
		});
	}

	open(url, data) {
		return data;
	}

	patch(asset, assets) {}

}

const spriteNormals = [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1];
const spriteIndices = [0, 1, 3, 2, 3, 1];

class Sprite extends EventHandler {
	constructor(device, options) {
		super();
		this._device = device;
		this._pixelsPerUnit = options && options.pixelsPerUnit !== undefined ? options.pixelsPerUnit : 1;
		this._renderMode = options && options.renderMode !== undefined ? options.renderMode : SPRITE_RENDERMODE_SIMPLE;
		this._atlas = options && options.atlas !== undefined ? options.atlas : null;
		this._frameKeys = options && options.frameKeys !== undefined ? options.frameKeys : null;
		this._meshes = [];
		this._updatingProperties = false;
		this._meshesDirty = false;

		if (this._atlas && this._frameKeys) {
			this._createMeshes();
		}
	}

	set frameKeys(value) {
		this._frameKeys = value;

		if (this._atlas && this._frameKeys) {
			if (this._updatingProperties) {
				this._meshesDirty = true;
			} else {
				this._createMeshes();
			}
		}

		this.fire('set:frameKeys', value);
	}

	get frameKeys() {
		return this._frameKeys;
	}

	set atlas(value) {
		if (value === this._atlas) return;

		if (this._atlas) {
			this._atlas.off('set:frames', this._onSetFrames, this);

			this._atlas.off('set:frame', this._onFrameChanged, this);

			this._atlas.off('remove:frame', this._onFrameRemoved, this);
		}

		this._atlas = value;

		if (this._atlas && this._frameKeys) {
			this._atlas.on('set:frames', this._onSetFrames, this);

			this._atlas.on('set:frame', this._onFrameChanged, this);

			this._atlas.on('remove:frame', this._onFrameRemoved, this);

			if (this._updatingProperties) {
				this._meshesDirty = true;
			} else {
				this._createMeshes();
			}
		}

		this.fire('set:atlas', value);
	}

	get atlas() {
		return this._atlas;
	}

	set pixelsPerUnit(value) {
		if (this._pixelsPerUnit === value) return;
		this._pixelsPerUnit = value;
		this.fire('set:pixelsPerUnit', value);

		if (this._atlas && this._frameKeys && this.renderMode === SPRITE_RENDERMODE_SIMPLE) {
			if (this._updatingProperties) {
				this._meshesDirty = true;
			} else {
				this._createMeshes();
			}
		}
	}

	get pixelsPerUnit() {
		return this._pixelsPerUnit;
	}

	set renderMode(value) {
		if (this._renderMode === value) return;
		const prev = this._renderMode;
		this._renderMode = value;
		this.fire('set:renderMode', value);

		if (prev === SPRITE_RENDERMODE_SIMPLE || value === SPRITE_RENDERMODE_SIMPLE) {
			if (this._atlas && this._frameKeys) {
				if (this._updatingProperties) {
					this._meshesDirty = true;
				} else {
					this._createMeshes();
				}
			}
		}
	}

	get renderMode() {
		return this._renderMode;
	}

	get meshes() {
		return this._meshes;
	}

	_createMeshes() {
		const len = this._meshes.length;

		for (let i = 0; i < len; i++) {
			const mesh = this._meshes[i];

			if (mesh) {
				mesh.destroy();
			}
		}

		const count = this._frameKeys.length;
		this._meshes = new Array(count);
		const createMeshFunc = this.renderMode === SPRITE_RENDERMODE_SLICED || this._renderMode === SPRITE_RENDERMODE_TILED ? this._create9SliceMesh : this._createSimpleMesh;

		for (let i = 0; i < count; i++) {
			const frame = this._atlas.frames[this._frameKeys[i]];
			this._meshes[i] = frame ? createMeshFunc.call(this, frame) : null;
		}

		this.fire('set:meshes');
	}

	_createSimpleMesh(frame) {
		const rect = frame.rect;
		const texWidth = this._atlas.texture.width;
		const texHeight = this._atlas.texture.height;
		const w = rect.z / this._pixelsPerUnit;
		const h = rect.w / this._pixelsPerUnit;
		const hp = frame.pivot.x;
		const vp = frame.pivot.y;
		const positions = [-hp * w, -vp * h, 0, (1 - hp) * w, -vp * h, 0, (1 - hp) * w, (1 - vp) * h, 0, -hp * w, (1 - vp) * h, 0];
		const lu = rect.x / texWidth;
		const bv = 1.0 - rect.y / texHeight;
		const ru = (rect.x + rect.z) / texWidth;
		const tv = 1.0 - (rect.y + rect.w) / texHeight;
		const uvs = [lu, bv, ru, bv, ru, tv, lu, tv];
		const mesh = createMesh$1(this._device, positions, {
			uvs: uvs,
			normals: spriteNormals,
			indices: spriteIndices
		});
		return mesh;
	}

	_create9SliceMesh() {
		const he = Vec2.ONE;
		const ws = 3;
		const ls = 3;
		const positions = [];
		const normals = [];
		const uvs = [];
		const indices = [];
		let vcounter = 0;

		for (let i = 0; i <= ws; i++) {
			const u = i === 0 || i === ws ? 0 : 1;

			for (let j = 0; j <= ls; j++) {
				const x = -he.x + 2.0 * he.x * (i <= 1 ? 0 : 3) / ws;
				const y = 0.0;
				const z = -(-he.y + 2.0 * he.y * (j <= 1 ? 0 : 3) / ls);
				const v = j === 0 || j === ls ? 0 : 1;
				positions.push(-x, y, z);
				normals.push(0.0, 1.0, 0.0);
				uvs.push(u, v);

				if (i < ws && j < ls) {
					indices.push(vcounter + ls + 1, vcounter + 1, vcounter);
					indices.push(vcounter + ls + 1, vcounter + ls + 2, vcounter + 1);
				}

				vcounter++;
			}
		}

		const options = {
			normals: normals,
			uvs: uvs,
			indices: indices
		};
		return createMesh$1(this._device, positions, options);
	}

	_onSetFrames(frames) {
		if (this._updatingProperties) {
			this._meshesDirty = true;
		} else {
			this._createMeshes();
		}
	}

	_onFrameChanged(frameKey, frame) {
		const idx = this._frameKeys.indexOf(frameKey);

		if (idx < 0) return;

		if (frame) {
			if (this.renderMode === SPRITE_RENDERMODE_SIMPLE) {
				this._meshes[idx] = this._createSimpleMesh(frame);
			}
		} else {
			this._meshes[idx] = null;
		}

		this.fire('set:meshes');
	}

	_onFrameRemoved(frameKey) {
		const idx = this._frameKeys.indexOf(frameKey);

		if (idx < 0) return;
		this._meshes[idx] = null;
		this.fire('set:meshes');
	}

	startUpdate() {
		this._updatingProperties = true;
		this._meshesDirty = false;
	}

	endUpdate() {
		this._updatingProperties = false;

		if (this._meshesDirty && this._atlas && this._frameKeys) {
			this._createMeshes();
		}

		this._meshesDirty = false;
	}

	destroy() {
		for (const mesh of this._meshes) {
			if (mesh) mesh.destroy();
		}

		this._meshes.length = 0;
	}

}

function onTextureAtlasLoaded(atlasAsset) {
	const spriteAsset = this;

	if (spriteAsset.resource) {
		spriteAsset.resource.atlas = atlasAsset.resource;
	}
}

function onTextureAtlasAdded(atlasAsset) {
	const spriteAsset = this;
	spriteAsset.registry.load(atlasAsset);
}

class SpriteHandler {
	constructor(assets, device) {
		this._assets = assets;
		this._device = device;
		this.maxRetries = 0;
	}

	load(url, callback) {
		if (typeof url === 'string') {
			url = {
				load: url,
				original: url
			};
		}

		if (path.getExtension(url.original) === '.json') {
			http.get(url.load, {
				retry: this.maxRetries > 0,
				maxRetries: this.maxRetries
			}, function (err, response) {
				if (!err) {
					callback(null, response);
				} else {
					callback(err);
				}
			});
		}
	}

	open(url, data) {
		const sprite = new Sprite(this._device);

		if (url) {
			sprite.__data = data;
		}

		return sprite;
	}

	patch(asset, assets) {
		const sprite = asset.resource;

		if (sprite.__data) {
			asset.data.pixelsPerUnit = sprite.__data.pixelsPerUnit;
			asset.data.renderMode = sprite.__data.renderMode;
			asset.data.frameKeys = sprite.__data.frameKeys;

			if (sprite.__data.textureAtlasAsset) {
				const atlas = assets.getByUrl(sprite.__data.textureAtlasAsset);

				if (atlas) {
					asset.data.textureAtlasAsset = atlas.id;
				} else {
					console.warn("Could not find textureatlas with url: " + sprite.__data.textureAtlasAsset);
				}
			}
		}

		sprite.startUpdate();
		sprite.renderMode = asset.data.renderMode;
		sprite.pixelsPerUnit = asset.data.pixelsPerUnit;
		sprite.frameKeys = asset.data.frameKeys;

		this._updateAtlas(asset);

		sprite.endUpdate();
		asset.off('change', this._onAssetChange, this);
		asset.on('change', this._onAssetChange, this);
	}

	_updateAtlas(asset) {
		const sprite = asset.resource;

		if (!asset.data.textureAtlasAsset) {
			sprite.atlas = null;
			return;
		}

		this._assets.off('load:' + asset.data.textureAtlasAsset, onTextureAtlasLoaded, asset);

		this._assets.on('load:' + asset.data.textureAtlasAsset, onTextureAtlasLoaded, asset);

		const atlasAsset = this._assets.get(asset.data.textureAtlasAsset);

		if (atlasAsset && atlasAsset.resource) {
			sprite.atlas = atlasAsset.resource;
		} else {
			if (!atlasAsset) {
				this._assets.off('add:' + asset.data.textureAtlasAsset, onTextureAtlasAdded, asset);

				this._assets.on('add:' + asset.data.textureAtlasAsset, onTextureAtlasAdded, asset);
			} else {
				this._assets.load(atlasAsset);
			}
		}
	}

	_onAssetChange(asset, attribute, value, oldValue) {
		if (attribute === 'data') {
			if (value && value.textureAtlasAsset && oldValue && value.textureAtlasAsset !== oldValue.textureAtlasAsset) {
				this._assets.off('load:' + oldValue.textureAtlasAsset, onTextureAtlasLoaded, asset);

				this._assets.off('add:' + oldValue.textureAtlasAsset, onTextureAtlasAdded, asset);
			}
		}
	}

}

class Template {
	constructor(app, data) {
		this._app = app;
		this._data = data;
		this._templateRoot = null;
	}

	instantiate() {
		if (!this._templateRoot) {
			this._parseTemplate();
		}

		return this._templateRoot.clone();
	}

	_parseTemplate() {
		const parser = new SceneParser(this._app, true);
		this._templateRoot = parser.parse(this._data);
	}

}

class TemplateHandler {
	constructor(app) {
		this._app = app;
		this.maxRetries = 0;
	}

	load(url, callback) {
		if (typeof url === 'string') {
			url = {
				load: url,
				original: url
			};
		}

		const options = {
			retry: this.maxRetries > 0,
			maxRetries: this.maxRetries
		};
		http.get(url.load, options, function (err, response) {
			if (err) {
				callback("Error requesting template: " + url.original);
			} else {
				callback(err, response);
			}
		});
	}

	open(url, data) {
		return new Template(this._app, data);
	}

}

class TextHandler {
	constructor() {
		this.maxRetries = 0;
	}

	load(url, callback) {
		if (typeof url === 'string') {
			url = {
				load: url,
				original: url
			};
		}

		http.get(url.load, {
			retry: this.maxRetries > 0,
			maxRetries: this.maxRetries
		}, function (err, response) {
			if (!err) {
				callback(null, response);
			} else {
				callback(`Error loading text resource: ${url.original} [${err}]`);
			}
		});
	}

	open(url, data) {
		return data;
	}

	patch(asset, assets) {}

}

class TextureAtlas extends EventHandler {
	constructor() {
		super();
		this._texture = null;
		this._frames = null;
	}

	set texture(value) {
		this._texture = value;
		this.fire('set:texture', value);
	}

	get texture() {
		return this._texture;
	}

	set frames(value) {
		this._frames = value;
		this.fire('set:frames', value);
	}

	get frames() {
		return this._frames;
	}

	setFrame(key, data) {
		let frame = this._frames[key];

		if (!frame) {
			frame = {
				rect: data.rect.clone(),
				pivot: data.pivot.clone(),
				border: data.border.clone()
			};
			this._frames[key] = frame;
		} else {
			frame.rect.copy(data.rect);
			frame.pivot.copy(data.pivot);
			frame.border.copy(data.border);
		}

		this.fire('set:frame', key.toString(), frame);
	}

	removeFrame(key) {
		const frame = this._frames[key];

		if (frame) {
			delete this._frames[key];
			this.fire('remove:frame', key.toString(), frame);
		}
	}

	destroy() {
		if (this._texture) {
			this._texture.destroy();
		}
	}

}

const JSON_ADDRESS_MODE$1 = {
	"repeat": ADDRESS_REPEAT,
	"clamp": ADDRESS_CLAMP_TO_EDGE,
	"mirror": ADDRESS_MIRRORED_REPEAT
};
const JSON_FILTER_MODE$1 = {
	"nearest": FILTER_NEAREST,
	"linear": FILTER_LINEAR,
	"nearest_mip_nearest": FILTER_NEAREST_MIPMAP_NEAREST,
	"linear_mip_nearest": FILTER_LINEAR_MIPMAP_NEAREST,
	"nearest_mip_linear": FILTER_NEAREST_MIPMAP_LINEAR,
	"linear_mip_linear": FILTER_LINEAR_MIPMAP_LINEAR
};
const regexFrame = /^data\.frames\.(\d+)$/;

class TextureAtlasHandler {
	constructor(loader) {
		this._loader = loader;
		this.maxRetries = 0;
	}

	load(url, callback) {
		if (typeof url === 'string') {
			url = {
				load: url,
				original: url
			};
		}

		const self = this;

		const handler = this._loader.getHandler("texture");

		if (path.getExtension(url.original) === '.json') {
			http.get(url.load, {
				retry: this.maxRetries > 0,
				maxRetries: this.maxRetries
			}, function (err, response) {
				if (!err) {
					const textureUrl = url.original.replace('.json', '.png');

					self._loader.load(textureUrl, "texture", function (err, texture) {
						if (err) {
							callback(err);
						} else {
							callback(null, {
								data: response,
								texture: texture
							});
						}
					});
				} else {
					callback(err);
				}
			});
		} else {
			return handler.load(url, callback);
		}
	}

	open(url, data) {
		const resource = new TextureAtlas();

		if (data.texture && data.data) {
			resource.texture = data.texture;
			resource.__data = data.data;
		} else {
			const handler = this._loader.getHandler("texture");

			const texture = handler.open(url, data);
			if (!texture) return null;
			resource.texture = texture;
		}

		return resource;
	}

	patch(asset, assets) {
		if (asset.resource.__data) {
			if (asset.resource.__data.minfilter !== undefined) asset.data.minfilter = asset.resource.__data.minfilter;
			if (asset.resource.__data.magfilter !== undefined) asset.data.magfilter = asset.resource.__data.magfilter;
			if (asset.resource.__data.addressu !== undefined) asset.data.addressu = asset.resource.__data.addressu;
			if (asset.resource.__data.addressv !== undefined) asset.data.addressv = asset.resource.__data.addressv;
			if (asset.resource.__data.mipmaps !== undefined) asset.data.mipmaps = asset.resource.__data.mipmaps;
			if (asset.resource.__data.anisotropy !== undefined) asset.data.anisotropy = asset.resource.__data.anisotropy;
			if (asset.resource.__data.rgbm !== undefined) asset.data.rgbm = !!asset.resource.__data.rgbm;
			asset.data.frames = asset.resource.__data.frames;
			delete asset.resource.__data;
		}

		const texture = asset.resource.texture;

		if (texture) {
			texture.name = asset.name;
			if (asset.data.hasOwnProperty('minfilter') && texture.minFilter !== JSON_FILTER_MODE$1[asset.data.minfilter]) texture.minFilter = JSON_FILTER_MODE$1[asset.data.minfilter];
			if (asset.data.hasOwnProperty('magfilter') && texture.magFilter !== JSON_FILTER_MODE$1[asset.data.magfilter]) texture.magFilter = JSON_FILTER_MODE$1[asset.data.magfilter];
			if (asset.data.hasOwnProperty('addressu') && texture.addressU !== JSON_ADDRESS_MODE$1[asset.data.addressu]) texture.addressU = JSON_ADDRESS_MODE$1[asset.data.addressu];
			if (asset.data.hasOwnProperty('addressv') && texture.addressV !== JSON_ADDRESS_MODE$1[asset.data.addressv]) texture.addressV = JSON_ADDRESS_MODE$1[asset.data.addressv];
			if (asset.data.hasOwnProperty('mipmaps') && texture.mipmaps !== asset.data.mipmaps) texture.mipmaps = asset.data.mipmaps;
			if (asset.data.hasOwnProperty('anisotropy') && texture.anisotropy !== asset.data.anisotropy) texture.anisotropy = asset.data.anisotropy;

			if (asset.data.hasOwnProperty('rgbm')) {
				const type = asset.data.rgbm ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT;

				if (texture.type !== type) {
					texture.type = type;
				}
			}
		}

		asset.resource.texture = texture;
		const frames = {};

		for (const key in asset.data.frames) {
			const frame = asset.data.frames[key];
			frames[key] = {
				rect: new Vec4(frame.rect),
				pivot: new Vec2(frame.pivot),
				border: new Vec4(frame.border)
			};
		}

		asset.resource.frames = frames;
		asset.off('change', this._onAssetChange, this);
		asset.on('change', this._onAssetChange, this);
	}

	_onAssetChange(asset, attribute, value) {
		let frame;

		if (attribute === 'data' || attribute === 'data.frames') {
			const frames = {};

			for (const key in value.frames) {
				frame = value.frames[key];
				frames[key] = {
					rect: new Vec4(frame.rect),
					pivot: new Vec2(frame.pivot),
					border: new Vec4(frame.border)
				};
			}

			asset.resource.frames = frames;
		} else {
			const match = attribute.match(regexFrame);

			if (match) {
				const frameKey = match[1];

				if (value) {
					if (!asset.resource.frames[frameKey]) {
						asset.resource.frames[frameKey] = {
							rect: new Vec4(value.rect),
							pivot: new Vec2(value.pivot),
							border: new Vec4(value.border)
						};
					} else {
						frame = asset.resource.frames[frameKey];
						frame.rect.set(value.rect[0], value.rect[1], value.rect[2], value.rect[3]);
						frame.pivot.set(value.pivot[0], value.pivot[1]);
						frame.border.set(value.border[0], value.border[1], value.border[2], value.border[3]);
					}

					asset.resource.fire('set:frame', frameKey, asset.resource.frames[frameKey]);
				} else {
					if (asset.resource.frames[frameKey]) {
						delete asset.resource.frames[frameKey];
						asset.resource.fire('remove:frame', frameKey);
					}
				}
			}
		}
	}

}

function BasisWorker() {
	const BASIS_FORMAT = {
		cTFETC1: 0,
		cTFETC2: 1,
		cTFBC1: 2,
		cTFBC3: 3,
		cTFPVRTC1_4_RGB: 8,
		cTFPVRTC1_4_RGBA: 9,
		cTFASTC_4x4: 10,
		cTFATC_RGB: 11,
		cTFATC_RGBA_INTERPOLATED_ALPHA: 12,
		cTFRGBA32: 13,
		cTFRGB565: 14,
		cTFRGBA4444: 16
	};
	const opaqueMapping = {
		astc: BASIS_FORMAT.cTFASTC_4x4,
		dxt: BASIS_FORMAT.cTFBC1,
		etc1: BASIS_FORMAT.cTFETC1,
		etc2: BASIS_FORMAT.cTFETC1,
		pvr: BASIS_FORMAT.cTFPVRTC1_4_RGB,
		atc: BASIS_FORMAT.cTFATC_RGB,
		none: BASIS_FORMAT.cTFRGB565
	};
	const alphaMapping = {
		astc: BASIS_FORMAT.cTFASTC_4x4,
		dxt: BASIS_FORMAT.cTFBC3,
		etc1: BASIS_FORMAT.cTFRGBA4444,
		etc2: BASIS_FORMAT.cTFETC2,
		pvr: BASIS_FORMAT.cTFPVRTC1_4_RGBA,
		atc: BASIS_FORMAT.cTFATC_RGBA_INTERPOLATED_ALPHA,
		none: BASIS_FORMAT.cTFRGBA4444
	};
	const PIXEL_FORMAT = {
		ETC1: 21,
		ETC2_RGB: 22,
		ETC2_RGBA: 23,
		DXT1: 8,
		DXT5: 10,
		PVRTC_4BPP_RGB_1: 26,
		PVRTC_4BPP_RGBA_1: 27,
		ASTC_4x4: 28,
		ATC_RGB: 29,
		ATC_RGBA: 30,
		R8_G8_B8_A8: 7,
		R5_G6_B5: 3,
		R4_G4_B4_A4: 5
	};

	const basisToEngineMapping = (basisFormat, deviceDetails) => {
		switch (basisFormat) {
			case BASIS_FORMAT.cTFETC1:
				return deviceDetails.formats.etc1 ? PIXEL_FORMAT.ETC1 : PIXEL_FORMAT.ETC2_RGB;

			case BASIS_FORMAT.cTFETC2:
				return PIXEL_FORMAT.ETC2_RGBA;

			case BASIS_FORMAT.cTFBC1:
				return PIXEL_FORMAT.DXT1;

			case BASIS_FORMAT.cTFBC3:
				return PIXEL_FORMAT.DXT5;

			case BASIS_FORMAT.cTFPVRTC1_4_RGB:
				return PIXEL_FORMAT.PVRTC_4BPP_RGB_1;

			case BASIS_FORMAT.cTFPVRTC1_4_RGBA:
				return PIXEL_FORMAT.PVRTC_4BPP_RGBA_1;

			case BASIS_FORMAT.cTFASTC_4x4:
				return PIXEL_FORMAT.ASTC_4x4;

			case BASIS_FORMAT.cTFATC_RGB:
				return PIXEL_FORMAT.ATC_RGB;

			case BASIS_FORMAT.cTFATC_RGBA_INTERPOLATED_ALPHA:
				return PIXEL_FORMAT.ATC_RGBA;

			case BASIS_FORMAT.cTFRGBA32:
				return PIXEL_FORMAT.R8_G8_B8_A8;

			case BASIS_FORMAT.cTFRGB565:
				return PIXEL_FORMAT.R5_G6_B5;

			case BASIS_FORMAT.cTFRGBA4444:
				return PIXEL_FORMAT.R4_G4_B4_A4;
		}
	};

	const unswizzleGGGR = data => {
		const genB = function genB(R, G) {
			const r = R * (2.0 / 255.0) - 1.0;
			const g = G * (2.0 / 255.0) - 1.0;
			const b = Math.sqrt(1.0 - Math.min(1.0, r * r + g * g));
			return Math.max(0, Math.min(255, Math.floor((b + 1.0) * 0.5 * 255.0)));
		};

		for (let offset = 0; offset < data.length; offset += 4) {
			const R = data[offset + 3];
			const G = data[offset + 1];
			data[offset + 0] = R;
			data[offset + 2] = genB(R, G);
			data[offset + 3] = 255;
		}

		return data;
	};

	const pack565 = data => {
		const result = new Uint16Array(data.length / 4);

		for (let offset = 0; offset < data.length; offset += 4) {
			const R = data[offset + 0];
			const G = data[offset + 1];
			const B = data[offset + 2];
			result[offset / 4] = (R & 0xf8) << 8 | (G & 0xfc) << 3 | B >> 3;
		}

		return result;
	};

	const isPOT = (width, height) => {
		return (width & width - 1) === 0 && (height & height - 1) === 0;
	};

	const performanceNow = () => {
		return typeof performance !== 'undefined' ? performance.now() : 0;
	};

	let basis;
	let rgbPriority;
	let rgbaPriority;

	const chooseTargetFormat = (deviceDetails, hasAlpha, isUASTC) => {
		if (isUASTC) {
			if (deviceDetails.formats.astc) {
				return 'astc';
			}
		} else {
			if (hasAlpha) {
				if (deviceDetails.formats.etc2) {
					return 'etc2';
				}
			} else {
				if (deviceDetails.formats.etc1 || deviceDetails.formats.etc2) {
					return 'etc1';
				}
			}
		}

		const testInOrder = priority => {
			for (let i = 0; i < priority.length; ++i) {
				const format = priority[i];

				if (deviceDetails.formats[format]) {
					return format;
				}
			}

			return 'none';
		};

		return testInOrder(hasAlpha ? rgbaPriority : rgbPriority);
	};

	const dimensionsValid = (width, height, format, webgl2) => {
		switch (format) {
			case BASIS_FORMAT.cTFETC1:
			case BASIS_FORMAT.cTFETC2:
				return true;

			case BASIS_FORMAT.cTFBC1:
			case BASIS_FORMAT.cTFBC3:
				return (width & 0x3) === 0 && (height & 0x3) === 0;

			case BASIS_FORMAT.cTFPVRTC1_4_RGB:
			case BASIS_FORMAT.cTFPVRTC1_4_RGBA:
				return isPOT(width, height) && (width === height || webgl2);

			case BASIS_FORMAT.cTFASTC_4x4:
				return true;

			case BASIS_FORMAT.cTFATC_RGB:
			case BASIS_FORMAT.cTFATC_RGBA_INTERPOLATED_ALPHA:
				return true;
		}
	};

	const transcodeKTX2 = (url, data, options) => {
		if (!basis.KTX2File) {
			throw new Error('Basis transcoder module does not include support for KTX2.');
		}

		const funcStart = performanceNow();
		const basisFile = new basis.KTX2File(new Uint8Array(data));
		const width = basisFile.getWidth();
		const height = basisFile.getHeight();
		const levels = basisFile.getLevels();
		const hasAlpha = !!basisFile.getHasAlpha();
		const isUASTC = basisFile.isUASTC && basisFile.isUASTC();

		if (!width || !height || !levels) {
			basisFile.close();
			basisFile.delete();
			throw new Error(`Invalid image dimensions url=${url} width=${width} height=${height} levels=${levels}`);
		}

		const format = chooseTargetFormat(options.deviceDetails, hasAlpha, isUASTC);
		const unswizzle = !!options.isGGGR && format === 'pvr';
		let basisFormat;

		if (unswizzle) {
			basisFormat = BASIS_FORMAT.cTFRGBA32;
		} else {
			basisFormat = hasAlpha ? alphaMapping[format] : opaqueMapping[format];

			if (!dimensionsValid(width, height, basisFormat, options.deviceDetails.webgl2)) {
				basisFormat = hasAlpha ? BASIS_FORMAT.cTFRGBA32 : BASIS_FORMAT.cTFRGB565;
			}
		}

		if (!basisFile.startTranscoding()) {
			basisFile.close();
			basisFile.delete();
			throw new Error('Failed to start transcoding url=' + url);
		}

		let i;
		const levelData = [];

		for (let mip = 0; mip < levels; ++mip) {
			const dstSize = basisFile.getImageTranscodedSizeInBytes(mip, 0, 0, basisFormat);
			const dst = new Uint8Array(dstSize);

			if (!basisFile.transcodeImage(dst, mip, 0, 0, basisFormat, 0, -1, -1)) {
				basisFile.close();
				basisFile.delete();
				throw new Error('Failed to transcode image url=' + url);
			}

			const is16BitFormat = basisFormat === BASIS_FORMAT.cTFRGB565 || basisFormat === BASIS_FORMAT.cTFRGBA4444;
			levelData.push(is16BitFormat ? new Uint16Array(dst.buffer) : dst);
		}

		basisFile.close();
		basisFile.delete();

		if (unswizzle) {
			basisFormat = BASIS_FORMAT.cTFRGB565;

			for (i = 0; i < levelData.length; ++i) {
				levelData[i] = pack565(unswizzleGGGR(levelData[i]));
			}
		}

		return {
			format: basisToEngineMapping(basisFormat, options.deviceDetails),
			width: width,
			height: height,
			levels: levelData,
			cubemap: false,
			transcodeTime: performanceNow() - funcStart,
			url: url,
			unswizzledGGGR: unswizzle
		};
	};

	const transcodeBasis = (url, data, options) => {
		const funcStart = performanceNow();
		const basisFile = new basis.BasisFile(new Uint8Array(data));
		const width = basisFile.getImageWidth(0, 0);
		const height = basisFile.getImageHeight(0, 0);
		const images = basisFile.getNumImages();
		const levels = basisFile.getNumLevels(0);
		const hasAlpha = !!basisFile.getHasAlpha();
		const isUASTC = basisFile.isUASTC && basisFile.isUASTC();

		if (!width || !height || !images || !levels) {
			basisFile.close();
			basisFile.delete();
			throw new Error(`Invalid image dimensions url=${url} width=${width} height=${height} images=${images} levels=${levels}`);
		}

		const format = chooseTargetFormat(options.deviceDetails, hasAlpha, isUASTC);
		const unswizzle = !!options.isGGGR && format === 'pvr';
		let basisFormat;

		if (unswizzle) {
			basisFormat = BASIS_FORMAT.cTFRGBA32;
		} else {
			basisFormat = hasAlpha ? alphaMapping[format] : opaqueMapping[format];

			if (!dimensionsValid(width, height, basisFormat, options.deviceDetails.webgl2)) {
				basisFormat = hasAlpha ? BASIS_FORMAT.cTFRGBA32 : BASIS_FORMAT.cTFRGB565;
			}
		}

		if (!basisFile.startTranscoding()) {
			basisFile.close();
			basisFile.delete();
			throw new Error('Failed to start transcoding url=' + url);
		}

		let i;
		const levelData = [];

		for (let mip = 0; mip < levels; ++mip) {
			const dstSize = basisFile.getImageTranscodedSizeInBytes(0, mip, basisFormat);
			const dst = new Uint8Array(dstSize);

			if (!basisFile.transcodeImage(dst, 0, mip, basisFormat, 0, 0)) {
				basisFile.close();
				basisFile.delete();
				throw new Error('Failed to transcode image url=' + url);
			}

			const is16BitFormat = basisFormat === BASIS_FORMAT.cTFRGB565 || basisFormat === BASIS_FORMAT.cTFRGBA4444;
			levelData.push(is16BitFormat ? new Uint16Array(dst.buffer) : dst);
		}

		basisFile.close();
		basisFile.delete();

		if (unswizzle) {
			basisFormat = BASIS_FORMAT.cTFRGB565;

			for (i = 0; i < levelData.length; ++i) {
				levelData[i] = pack565(unswizzleGGGR(levelData[i]));
			}
		}

		return {
			format: basisToEngineMapping(basisFormat, options.deviceDetails),
			width: width,
			height: height,
			levels: levelData,
			cubemap: false,
			transcodeTime: performanceNow() - funcStart,
			url: url,
			unswizzledGGGR: unswizzle
		};
	};

	const transcode = (url, data, options) => {
		return options.isKTX2 ? transcodeKTX2(url, data, options) : transcodeBasis(url, data, options);
	};

	const workerTranscode = (url, data, options) => {
		try {
			const result = transcode(url, data, options);
			result.levels = result.levels.map(v => v.buffer);
			self.postMessage({
				url: url,
				data: result
			}, result.levels);
		} catch (err) {
			self.postMessage({
				url: url,
				err: err
			}, null);
		}
	};

	const workerInit = (config, callback) => {
		self.importScripts(config.basisUrl);

		const instantiateWasmFunc = (imports, successCallback) => {
			WebAssembly.instantiate(config.module, imports).then(result => {
				successCallback(result);
			}).catch(reason => {
				console.error('instantiate failed + ' + reason);
			});
			return {};
		};

		self.BASIS(config.module ? {
			instantiateWasm: instantiateWasmFunc
		} : null).then(instance => {
			instance.initializeBasis();
			basis = instance;
			rgbPriority = config.rgbPriority;
			rgbaPriority = config.rgbaPriority;
			callback(null);
		});
	};

	const queue = [];

	self.onmessage = message => {
		const data = message.data;

		switch (data.type) {
			case 'init':
				workerInit(data.config, () => {
					for (let i = 0; i < queue.length; ++i) {
						workerTranscode(queue[i].url, queue[i].data, queue[i].options);
					}

					queue.length = 0;
				});
				break;

			case 'transcode':
				if (basis) {
					workerTranscode(data.url, data.data, data.options);
				} else {
					queue.push(data);
				}

				break;
		}
	};
}

const getCompressionFormats = device => {
	return {
		astc: !!device.extCompressedTextureASTC,
		atc: !!device.extCompressedTextureATC,
		dxt: !!device.extCompressedTextureS3TC,
		etc1: !!device.extCompressedTextureETC1,
		etc2: !!device.extCompressedTextureETC,
		pvr: !!device.extCompressedTexturePVRTC
	};
};

const prepareWorkerModules = (config, callback) => {
	const getWorkerBlob = () => {
		const code = '(' + BasisWorker.toString() + ')()\n\n';
		return new Blob([code], {
			type: 'application/javascript'
		});
	};

	const wasmSupported = () => {
		try {
			if (typeof WebAssembly === "object" && typeof WebAssembly.instantiate === "function") {
				const module = new WebAssembly.Module(Uint8Array.of(0x0, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00));
				if (module instanceof WebAssembly.Module) return new WebAssembly.Instance(module) instanceof WebAssembly.Instance;
			}
		} catch (e) {}

		return false;
	};

	const sendResponse = (basisCode, module) => {
		callback(null, {
			workerUrl: URL.createObjectURL(getWorkerBlob()),
			basisUrl: URL.createObjectURL(basisCode),
			module: module,
			rgbPriority: config.rgbPriority,
			rgbaPriority: config.rgbaPriority
		});
	};

	if (config.glueUrl && config.wasmUrl && wasmSupported()) {
		let basisCode = null;
		let module = null;
		http.get(config.glueUrl, {
			responseType: 'blob'
		}, (err, response) => {
			if (err) {
				callback(err);
			} else {
				if (module) {
					sendResponse(response, module);
				} else {
					basisCode = response;
				}
			}
		});
		const fetchPromise = fetch(config.wasmUrl);

		const compileManual = () => {
			fetchPromise.then(result => result.arrayBuffer()).then(buffer => WebAssembly.compile(buffer)).then(module_ => {
				if (basisCode) {
					sendResponse(basisCode, module_);
				} else {
					module = module_;
				}
			}).catch(err => {
				callback(err, null);
			});
		};

		if (WebAssembly.compileStreaming) {
			WebAssembly.compileStreaming(fetchPromise).then(module_ => {
				if (basisCode) {
					sendResponse(basisCode, module_);
				} else {
					module = module_;
				}
			}).catch(err => {
				compileManual();
			});
		} else {
			compileManual();
		}
	} else {
		http.get(config.fallbackUrl, {
			responseType: 'blob'
		}, (err, response) => {
			if (err) {
				callback(err, null);
			} else {
				sendResponse(response, null);
			}
		});
	}
};

class BasisQueue {
	constructor() {
		this.callbacks = {};
		this.queue = [];
		this.clients = [];
	}

	enqueueJob(url, data, callback, options) {
		if (this.callbacks.hasOwnProperty(url)) {
			this.callbacks[url].push(callback);
		} else {
			this.callbacks[url] = [callback];
			const job = {
				url: url,
				data: data,
				options: options
			};

			if (this.clients.length > 0) {
				this.clients.shift().run(job);
			} else {
				this.queue.push(job);
			}
		}
	}

	enqueueClient(client) {
		if (this.queue.length > 0) {
			client.run(this.queue.shift());
		} else {
			this.clients.push(client);
		}
	}

	handleResponse(url, err, data) {
		const callback = this.callbacks[url];

		if (err) {
			for (let i = 0; i < callback.length; ++i) {
				callback[i](err);
			}
		} else {
			if (data.format === PIXELFORMAT_R5_G6_B5 || data.format === PIXELFORMAT_R4_G4_B4_A4) {
				data.levels = data.levels.map(function (v) {
					return new Uint16Array(v);
				});
			} else {
				data.levels = data.levels.map(function (v) {
					return new Uint8Array(v);
				});
			}

			for (let i = 0; i < callback.length; ++i) {
				callback[i](null, data);
			}
		}

		delete this.callbacks[url];
	}

}

class BasisClient {
	constructor(queue, config, eager) {
		this.queue = queue;
		this.worker = new Worker(config.workerUrl);
		this.worker.addEventListener('message', message => {
			const data = message.data;
			this.queue.handleResponse(data.url, data.err, data.data);

			if (!this.eager) {
				this.queue.enqueueClient(this);
			}
		});
		this.worker.postMessage({
			type: 'init',
			config: config
		});
		this.eager = eager;
	}

	run(job) {
		const transfer = [];

		if (job.data instanceof ArrayBuffer) {
			transfer.push(job.data);
		}

		this.worker.postMessage({
			type: 'transcode',
			url: job.url,
			format: job.format,
			data: job.data,
			options: job.options
		}, transfer);

		if (this.eager) {
			this.queue.enqueueClient(this);
		}
	}

}

const defaultNumWorkers = 1;
const defaultRgbPriority = ['etc1', 'etc2', 'astc', 'dxt', 'pvr', 'atc'];
const defaultRgbaPriority = ['astc', 'dxt', 'etc2', 'pvr', 'atc'];
const queue = new BasisQueue();
let lazyConfig = null;
let initializing = false;

function basisInitialize(config) {
	if (initializing) {
		return;
	}

	if (!config) {
		config = lazyConfig || {};
	} else if (config.lazyInit) {
		lazyConfig = config;
		return;
	}

	if (!config.glueUrl || !config.wasmUrl || !config.fallbackUrl) {
		const modules = (window.config ? window.config.wasmModules : window.PRELOAD_MODULES) || [];
		const wasmModule = modules.find(function (m) {
			return m.moduleName === 'BASIS';
		});

		if (wasmModule) {
			const urlBase = window.ASSET_PREFIX || "";

			if (!config.glueUrl) {
				config.glueUrl = urlBase + wasmModule.glueUrl;
			}

			if (!config.wasmUrl) {
				config.wasmUrl = urlBase + wasmModule.wasmUrl;
			}

			if (!config.fallbackUrl) {
				config.fallbackUrl = urlBase + wasmModule.fallbackUrl;
			}
		}
	}

	if (config.glueUrl || config.wasmUrl || config.fallbackUrl) {
		initializing = true;
		const numWorkers = Math.max(1, Math.min(16, config.numWorkers || defaultNumWorkers));
		const eagerWorkers = config.numWorkers === 1 || (config.hasOwnProperty('eagerWorkers') ? config.eagerWorkers : true);
		config.rgbPriority = config.rgbPriority || defaultRgbPriority;
		config.rgbaPriority = config.rgbaPriority || defaultRgbaPriority;
		prepareWorkerModules(config, (err, clientConfig) => {
			if (err) {
				console.error(`failed to initialize basis worker: ${err}`);
			} else {
				for (let i = 0; i < numWorkers; ++i) {
					queue.enqueueClient(new BasisClient(queue, clientConfig, eagerWorkers));
				}
			}
		});
	}
}

let deviceDetails = null;

function basisTranscode(device, url, data, callback, options) {
	basisInitialize();

	if (!deviceDetails) {
		deviceDetails = {
			webgl2: device.webgl2,
			formats: getCompressionFormats(device)
		};
	}

	queue.enqueueJob(url, data, callback, {
		deviceDetails: deviceDetails,
		isGGGR: !!(options != null && options.isGGGR),
		isKTX2: !!(options != null && options.isKTX2)
	});
	return initializing;
}

class BasisParser {
	constructor(registry, device) {
		this.device = device;
		this.maxRetries = 0;
	}

	load(url, callback, asset) {
		const device = this.device;

		const transcode = data => {
			var _asset$file, _asset$file$variants, _asset$file$variants$;

			const basisModuleFound = basisTranscode(device, url.load, data, callback, {
				isGGGR: ((asset == null ? void 0 : (_asset$file = asset.file) == null ? void 0 : (_asset$file$variants = _asset$file.variants) == null ? void 0 : (_asset$file$variants$ = _asset$file$variants.basis) == null ? void 0 : _asset$file$variants$.opt) & 8) !== 0
			});

			if (!basisModuleFound) {
				callback(`Basis module not found. Asset '${asset.name}' basis texture variant will not be loaded.`);
			}
		};

		Asset.fetchArrayBuffer(url.load, (err, result) => {
			if (err) {
				callback(err);
			} else {
				transcode(result);
			}
		}, asset, this.maxRetries);
	}

	open(url, data, device) {
		const texture = new Texture(device, {
			name: url,
			addressU: data.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
			addressV: data.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
			width: data.width,
			height: data.height,
			format: data.format,
			cubemap: data.cubemap,
			levels: data.levels
		});
		texture.upload();
		return texture;
	}

}

class ImgParser {
	constructor(registry) {
		this.crossOrigin = registry.prefix ? 'anonymous' : null;
		this.maxRetries = 0;
		this.useImageBitmap = false  ;
	}

	load(url, callback, asset) {
		var _asset$file;

		const hasContents = !!(asset != null && (_asset$file = asset.file) != null && _asset$file.contents);

		if (hasContents) {
			url = {
				load: URL.createObjectURL(new Blob([asset.file.contents])),
				original: url.original
			};
		}

		const handler = (err, result) => {
			if (hasContents) {
				URL.revokeObjectURL(url.load);
			}

			callback(err, result);
		};

		let crossOrigin;

		if (asset && asset.options && asset.options.hasOwnProperty('crossOrigin')) {
			crossOrigin = asset.options.crossOrigin;
		} else if (ABSOLUTE_URL.test(url.load)) {
			crossOrigin = this.crossOrigin;
		}

		if (this.useImageBitmap) {
			this._loadImageBitmap(url.load, url.original, crossOrigin, handler);
		} else {
			this._loadImage(url.load, url.original, crossOrigin, handler);
		}
	}

	open(url, data, device) {
		const ext = path.getExtension(url).toLowerCase();
		const format = ext === ".jpg" || ext === ".jpeg" ? PIXELFORMAT_R8_G8_B8 : PIXELFORMAT_R8_G8_B8_A8;
		const texture = new Texture(device, {
			name: url,
			width: data.width,
			height: data.height,
			format: format
		});
		texture.setSource(data);
		return texture;
	}

	_loadImage(url, originalUrl, crossOrigin, callback) {
		const image = new Image();

		if (crossOrigin) {
			image.crossOrigin = crossOrigin;
		}

		let retries = 0;
		const maxRetries = this.maxRetries;
		let retryTimeout;

		image.onload = function () {
			callback(null, image);
		};

		image.onerror = function () {
			if (retryTimeout) return;

			if (maxRetries > 0 && ++retries <= maxRetries) {
				const retryDelay = Math.pow(2, retries) * 100;
				console.log(`Error loading Texture from: '${originalUrl}' - Retrying in ${retryDelay}ms...`);
				const idx = url.indexOf('?');
				const separator = idx >= 0 ? '&' : '?';
				retryTimeout = setTimeout(function () {
					image.src = url + separator + 'retry=' + Date.now();
					retryTimeout = null;
				}, retryDelay);
			} else {
				callback(`Error loading Texture from: '${originalUrl}'`);
			}
		};

		image.src = url;
	}

	_loadImageBitmap(url, originalUrl, crossOrigin, callback) {
		const options = {
			cache: true,
			responseType: "blob",
			retry: this.maxRetries > 0,
			maxRetries: this.maxRetries
		};
		http.get(url, options, function (err, blob) {
			if (err) {
				callback(err);
			} else {
				createImageBitmap(blob, {
					premultiplyAlpha: 'none'
				}).then(function (imageBitmap) {
					callback(null, imageBitmap);
				}).catch(function (e) {
					callback(e);
				});
			}
		});
	}

}

const IDENTIFIER = [0x58544BAB, 0xBB313120, 0x0A1A0A0D];
const KNOWN_FORMATS = {
	0x83F0: PIXELFORMAT_DXT1,
	0x83F2: PIXELFORMAT_DXT3,
	0x83F3: PIXELFORMAT_DXT5,
	0x8D64: PIXELFORMAT_ETC1,
	0x9274: PIXELFORMAT_ETC2_RGB,
	0x9278: PIXELFORMAT_ETC2_RGBA,
	0x8C00: PIXELFORMAT_PVRTC_4BPP_RGB_1,
	0x8C01: PIXELFORMAT_PVRTC_2BPP_RGB_1,
	0x8C02: PIXELFORMAT_PVRTC_4BPP_RGBA_1,
	0x8C03: PIXELFORMAT_PVRTC_2BPP_RGBA_1,
	0x8051: PIXELFORMAT_R8_G8_B8,
	0x8058: PIXELFORMAT_R8_G8_B8_A8,
	0x8C41: PIXELFORMAT_SRGB,
	0x8C43: PIXELFORMAT_SRGBA,
	0x8C3A: PIXELFORMAT_111110F,
	0x881B: PIXELFORMAT_RGB16F,
	0x881A: PIXELFORMAT_RGBA16F
};

function createContainer(pixelFormat, buffer, byteOffset, byteSize) {
	return pixelFormat === PIXELFORMAT_111110F ? new Uint32Array(buffer, byteOffset, byteSize / 4) : new Uint8Array(buffer, byteOffset, byteSize);
}

class KtxParser {
	constructor(registry) {
		this.maxRetries = 0;
	}

	load(url, callback, asset) {
		Asset.fetchArrayBuffer(url.load, callback, asset, this.maxRetries);
	}

	open(url, data, device) {
		const textureData = this.parse(data);

		if (!textureData) {
			return null;
		}

		const texture = new Texture(device, {
			name: url,
			addressU: textureData.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
			addressV: textureData.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
			width: textureData.width,
			height: textureData.height,
			format: textureData.format,
			cubemap: textureData.cubemap,
			levels: textureData.levels
		});
		texture.upload();
		return texture;
	}

	parse(data) {
		const dataU32 = new Uint32Array(data);

		if (IDENTIFIER[0] !== dataU32[0] || IDENTIFIER[1] !== dataU32[1] || IDENTIFIER[2] !== dataU32[2]) {
			return null;
		}

		const header = {
			endianness: dataU32[3],
			glType: dataU32[4],
			glTypeSize: dataU32[5],
			glFormat: dataU32[6],
			glInternalFormat: dataU32[7],
			glBaseInternalFormat: dataU32[8],
			pixelWidth: dataU32[9],
			pixelHeight: dataU32[10],
			pixelDepth: dataU32[11],
			numberOfArrayElements: dataU32[12],
			numberOfFaces: dataU32[13],
			numberOfMipmapLevels: dataU32[14],
			bytesOfKeyValueData: dataU32[15]
		};

		if (header.pixelDepth > 1) {
			return null;
		}

		if (header.numberOfArrayElements !== 0) {
			return null;
		}

		const format = KNOWN_FORMATS[header.glInternalFormat];

		if (format === undefined) {
			return null;
		}

		let offset = 16 + header.bytesOfKeyValueData / 4;
		const isCubemap = header.numberOfFaces > 1;
		const levels = [];

		for (let mipmapLevel = 0; mipmapLevel < (header.numberOfMipmapLevels || 1); mipmapLevel++) {
			const imageSizeInBytes = dataU32[offset++];

			if (isCubemap) {
				levels.push([]);
			}

			const target = isCubemap ? levels[mipmapLevel] : levels;

			for (let face = 0; face < (isCubemap ? 6 : 1); ++face) {
				target.push(createContainer(format, data, offset * 4, imageSizeInBytes));
				offset += imageSizeInBytes + 3 >> 2;
			}
		}

		return {
			format: format,
			width: header.pixelWidth,
			height: header.pixelHeight,
			levels: levels,
			cubemap: isCubemap
		};
	}

}

const KHRConstants = {
	KHR_DF_MODEL_ETC1S: 163,
	KHR_DF_MODEL_UASTC: 166
};

class Ktx2Parser {
	constructor(registry, device) {
		this.maxRetries = 0;
		this.device = device;
	}

	load(url, callback, asset) {
		Asset.fetchArrayBuffer(url.load, (err, result) => {
			if (err) {
				callback(err, result);
			} else {
				this.parse(result, url, callback, asset);
			}
		}, asset, this.maxRetries);
	}

	open(url, data, device) {
		const texture = new Texture(device, {
			name: url,
			addressU: data.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
			addressV: data.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
			width: data.width,
			height: data.height,
			format: data.format,
			cubemap: data.cubemap,
			levels: data.levels
		});
		texture.upload();
		return texture;
	}

	parse(arraybuffer, url, callback, asset) {
		const rs = new ReadStream(arraybuffer);
		const magic = [rs.readU32be(), rs.readU32be(), rs.readU32be()];

		if (magic[0] !== 0xAB4B5458 || magic[1] !== 0x203230BB || magic[2] !== 0x0D0A1A0A) {
			return null;
		}

		const header = {
			vkFormat: rs.readU32(),
			typeSize: rs.readU32(),
			pixelWidth: rs.readU32(),
			pixelHeight: rs.readU32(),
			pixelDepth: rs.readU32(),
			layerCount: rs.readU32(),
			faceCount: rs.readU32(),
			levelCount: rs.readU32(),
			supercompressionScheme: rs.readU32()
		};
		const index = {
			dfdByteOffset: rs.readU32(),
			dfdByteLength: rs.readU32(),
			kvdByteOffset: rs.readU32(),
			kvdByteLength: rs.readU32(),
			sgdByteOffset: rs.readU64(),
			sgdByteLength: rs.readU64()
		};
		const levels = [];

		for (let i = 0; i < Math.max(1, header.levelCount); ++i) {
			levels.push({
				byteOffset: rs.readU64(),
				byteLength: rs.readU64(),
				uncompressedByteLength: rs.readU64()
			});
		}

		const dfdTotalSize = rs.readU32();

		if (dfdTotalSize !== index.kvdByteOffset - index.dfdByteOffset) {
			return null;
		}

		rs.skip(8);
		const colorModel = rs.readU8();
		rs.skip(index.dfdByteLength - 9);
		rs.skip(index.kvdByteLength);

		if (header.supercompressionScheme === 1 || colorModel === KHRConstants.KHR_DF_MODEL_UASTC) {
			var _asset$file, _asset$file$variants, _asset$file$variants$;

			const basisModuleFound = basisTranscode(this.device, url.load, arraybuffer, callback, {
				isGGGR: ((asset == null ? void 0 : (_asset$file = asset.file) == null ? void 0 : (_asset$file$variants = _asset$file.variants) == null ? void 0 : (_asset$file$variants$ = _asset$file$variants.basis) == null ? void 0 : _asset$file$variants$.opt) & 8) !== 0,
				isKTX2: true
			});

			if (!basisModuleFound) {
				callback('Basis module not found. Asset "' + asset.name + '" basis texture variant will not be loaded.');
			}
		} else {
			callback('unsupported KTX2 pixel format');
		}
	}

}

class DdsParser {
	constructor(registry) {
		this.maxRetries = 0;
	}

	load(url, callback, asset) {
		Asset.fetchArrayBuffer(url.load, callback, asset, this.maxRetries);
	}

	open(url, data, device) {
		const header = new Uint32Array(data, 0, 128 / 4);
		const width = header[4];
		const height = header[3];
		const mips = Math.max(header[7], 1);
		const isFourCc = header[20] === 4;
		const fcc = header[21];
		const bpp = header[22];
		const isCubemap = header[28] === 65024;
		const FCC_DXT1 = 827611204;
		const FCC_DXT5 = 894720068;
		const FCC_FP16 = 113;
		const FCC_FP32 = 116;
		const FCC_ETC1 = 826496069;
		const FCC_PVRTC_2BPP_RGB_1 = 825438800;
		const FCC_PVRTC_2BPP_RGBA_1 = 825504336;
		const FCC_PVRTC_4BPP_RGB_1 = 825439312;
		const FCC_PVRTC_4BPP_RGBA_1 = 825504848;
		let compressed = false;
		let etc1 = false;
		let pvrtc2 = false;
		let pvrtc4 = false;
		let format = null;
		let componentSize = 1;
		let texture;

		if (isFourCc) {
			if (fcc === FCC_DXT1) {
				format = PIXELFORMAT_DXT1;
				compressed = true;
			} else if (fcc === FCC_DXT5) {
				format = PIXELFORMAT_DXT5;
				compressed = true;
			} else if (fcc === FCC_FP16) {
				format = PIXELFORMAT_RGBA16F;
				componentSize = 2;
			} else if (fcc === FCC_FP32) {
				format = PIXELFORMAT_RGBA32F;
				componentSize = 4;
			} else if (fcc === FCC_ETC1) {
				format = PIXELFORMAT_ETC1;
				compressed = true;
				etc1 = true;
			} else if (fcc === FCC_PVRTC_2BPP_RGB_1 || fcc === FCC_PVRTC_2BPP_RGBA_1) {
				format = fcc === FCC_PVRTC_2BPP_RGB_1 ? PIXELFORMAT_PVRTC_2BPP_RGB_1 : PIXELFORMAT_PVRTC_2BPP_RGBA_1;
				compressed = true;
				pvrtc2 = true;
			} else if (fcc === FCC_PVRTC_4BPP_RGB_1 || fcc === FCC_PVRTC_4BPP_RGBA_1) {
				format = fcc === FCC_PVRTC_4BPP_RGB_1 ? PIXELFORMAT_PVRTC_4BPP_RGB_1 : PIXELFORMAT_PVRTC_4BPP_RGBA_1;
				compressed = true;
				pvrtc4 = true;
			}
		} else {
			if (bpp === 32) {
				format = PIXELFORMAT_R8_G8_B8_A8;
			}
		}

		if (!format) {
			texture = new Texture(device, {
				width: 4,
				height: 4,
				format: PIXELFORMAT_R8_G8_B8
			});
			texture.name = 'dds-legacy-empty';
			return texture;
		}

		texture = new Texture(device, {
			name: url,
			addressU: isCubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
			addressV: isCubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
			width: width,
			height: height,
			format: format,
			cubemap: isCubemap,
			mipmaps: mips > 1
		});
		let offset = 128;
		const faces = isCubemap ? 6 : 1;
		let mipSize;
		const DXT_BLOCK_WIDTH = 4;
		const DXT_BLOCK_HEIGHT = 4;
		const blockSize = fcc === FCC_DXT1 ? 8 : 16;
		let numBlocksAcross, numBlocksDown, numBlocks;

		for (let face = 0; face < faces; face++) {
			let mipWidth = width;
			let mipHeight = height;

			for (let i = 0; i < mips; i++) {
				if (compressed) {
					if (etc1) {
						mipSize = Math.floor((mipWidth + 3) / 4) * Math.floor((mipHeight + 3) / 4) * 8;
					} else if (pvrtc2) {
						mipSize = Math.max(mipWidth, 16) * Math.max(mipHeight, 8) / 4;
					} else if (pvrtc4) {
						mipSize = Math.max(mipWidth, 8) * Math.max(mipHeight, 8) / 2;
					} else {
						numBlocksAcross = Math.floor((mipWidth + DXT_BLOCK_WIDTH - 1) / DXT_BLOCK_WIDTH);
						numBlocksDown = Math.floor((mipHeight + DXT_BLOCK_HEIGHT - 1) / DXT_BLOCK_HEIGHT);
						numBlocks = numBlocksAcross * numBlocksDown;
						mipSize = numBlocks * blockSize;
					}
				} else {
					mipSize = mipWidth * mipHeight * 4;
				}

				const mipBuff = format === PIXELFORMAT_RGBA32F ? new Float32Array(data, offset, mipSize) : format === PIXELFORMAT_RGBA16F ? new Uint16Array(data, offset, mipSize) : new Uint8Array(data, offset, mipSize);

				if (!isCubemap) {
					texture._levels[i] = mipBuff;
				} else {
					if (!texture._levels[i]) texture._levels[i] = [];
					texture._levels[i][face] = mipBuff;
				}

				offset += mipSize * componentSize;
				mipWidth = Math.max(mipWidth * 0.5, 1);
				mipHeight = Math.max(mipHeight * 0.5, 1);
			}
		}

		texture.upload();
		return texture;
	}

}

class HdrParser {
	constructor(registry) {
		this.maxRetries = 0;
	}

	load(url, callback, asset) {
		Asset.fetchArrayBuffer(url.load, callback, asset, this.maxRetries);
	}

	open(url, data, device) {
		const textureData = this.parse(data);

		if (!textureData) {
			return null;
		}

		const texture = new Texture(device, {
			name: url,
			addressU: ADDRESS_REPEAT,
			addressV: ADDRESS_CLAMP_TO_EDGE,
			minFilter: FILTER_NEAREST_MIPMAP_NEAREST,
			magFilter: FILTER_NEAREST,
			width: textureData.width,
			height: textureData.height,
			levels: textureData.levels,
			format: PIXELFORMAT_R8_G8_B8_A8,
			type: TEXTURETYPE_RGBE,
			mipmaps: false
		});
		texture.upload();
		return texture;
	}

	parse(data) {
		const readStream = new ReadStream(data);
		const magic = readStream.readLine();

		if (!magic.startsWith('#?RADIANCE')) {
			return null;
		}

		const variables = {};

		while (true) {
			const line = readStream.readLine();

			if (line.length === 0) {
				break;
			} else {
				const parts = line.split('=');

				if (parts.length === 2) {
					variables[parts[0]] = parts[1];
				}
			}
		}

		if (!variables.hasOwnProperty('FORMAT')) {
			return null;
		}

		const resolution = readStream.readLine().split(' ');

		if (resolution.length !== 4) {
			return null;
		}

		const height = parseInt(resolution[1], 10);
		const width = parseInt(resolution[3], 10);

		const pixels = this._readPixels(readStream, width, height, resolution[0] === '-Y');

		if (!pixels) {
			return null;
		}

		return {
			width: width,
			height: height,
			levels: [pixels]
		};
	}

	_readPixels(readStream, width, height, flipY) {
		if (width < 8 || width > 0x7fff) {
			return this._readPixelsFlat(readStream, width, height);
		}

		const rgbe = [0, 0, 0, 0];
		readStream.readArray(rgbe);

		if (rgbe[0] !== 2 || rgbe[1] !== 2 || (rgbe[2] & 0x80) !== 0) {
			readStream.skip(-4);
			return this._readPixelsFlat(readStream, width, height);
		}

		const buffer = new ArrayBuffer(width * height * 4);
		const view = new Uint8Array(buffer);
		let scanstart = flipY ? 0 : width * 4 * (height - 1);
		let x, y, i, channel, count, value;

		for (y = 0; y < height; ++y) {
			if (y) {
				readStream.readArray(rgbe);
			}

			if ((rgbe[2] << 8) + rgbe[3] !== width) {
				return null;
			}

			for (channel = 0; channel < 4; ++channel) {
				x = 0;

				while (x < width) {
					count = readStream.readU8();

					if (count > 128) {
						count -= 128;

						if (x + count > width) {
							return null;
						}

						value = readStream.readU8();

						for (i = 0; i < count; ++i) {
							view[scanstart + channel + 4 * x++] = value;
						}
					} else {
						if (count === 0 || x + count > width) {
							return null;
						}

						for (i = 0; i < count; ++i) {
							view[scanstart + channel + 4 * x++] = readStream.readU8();
						}
					}
				}
			}

			scanstart += width * 4 * (flipY ? 1 : -1);
		}

		return view;
	}

	_readPixelsFlat(readStream, width, height) {
		return readStream.remainingBytes === width * height * 4 ? new Uint8Array(readStream.arraybuffer, readStream.offset) : null;
	}

}

const JSON_ADDRESS_MODE = {
	"repeat": ADDRESS_REPEAT,
	"clamp": ADDRESS_CLAMP_TO_EDGE,
	"mirror": ADDRESS_MIRRORED_REPEAT
};
const JSON_FILTER_MODE = {
	"nearest": FILTER_NEAREST,
	"linear": FILTER_LINEAR,
	"nearest_mip_nearest": FILTER_NEAREST_MIPMAP_NEAREST,
	"linear_mip_nearest": FILTER_LINEAR_MIPMAP_NEAREST,
	"nearest_mip_linear": FILTER_NEAREST_MIPMAP_LINEAR,
	"linear_mip_linear": FILTER_LINEAR_MIPMAP_LINEAR
};
const JSON_TEXTURE_TYPE = {
	"default": TEXTURETYPE_DEFAULT,
	"rgbm": TEXTURETYPE_RGBM,
	"rgbe": TEXTURETYPE_RGBE,
	"swizzleGGGR": TEXTURETYPE_SWIZZLEGGGR
};

class TextureParser {
	load(url, callback, asset) {
		throw new Error('not implemented');
	}

	open(url, data, device) {
		throw new Error('not implemented');
	}

}

const _completePartialMipmapChain = function _completePartialMipmapChain(texture) {
	const requiredMipLevels = Math.log2(Math.max(texture._width, texture._height)) + 1;

	const isHtmlElement = function isHtmlElement(object) {
		return object instanceof HTMLCanvasElement || object instanceof HTMLImageElement || object instanceof HTMLVideoElement;
	};

	if (!(texture._format === PIXELFORMAT_R8_G8_B8_A8 || texture._format === PIXELFORMAT_RGBA32F) || texture._volume || texture._compressed || texture._levels.length === 1 || texture._levels.length === requiredMipLevels || isHtmlElement(texture._cubemap ? texture._levels[0][0] : texture._levels[0])) {
		return;
	}

	const downsample = function downsample(width, height, data) {
		const sampledWidth = Math.max(1, width >> 1);
		const sampledHeight = Math.max(1, height >> 1);
		const sampledData = new data.constructor(sampledWidth * sampledHeight * 4);
		const xs = Math.floor(width / sampledWidth);
		const ys = Math.floor(height / sampledHeight);
		const xsys = xs * ys;

		for (let y = 0; y < sampledHeight; ++y) {
			for (let x = 0; x < sampledWidth; ++x) {
				for (let e = 0; e < 4; ++e) {
					let sum = 0;

					for (let sy = 0; sy < ys; ++sy) {
						for (let sx = 0; sx < xs; ++sx) {
							sum += data[(x * xs + sx + (y * ys + sy) * width) * 4 + e];
						}
					}

					sampledData[(x + y * sampledWidth) * 4 + e] = sum / xsys;
				}
			}
		}

		return sampledData;
	};

	for (let level = texture._levels.length; level < requiredMipLevels; ++level) {
		const width = Math.max(1, texture._width >> level - 1);
		const height = Math.max(1, texture._height >> level - 1);

		if (texture._cubemap) {
			const mips = [];

			for (let face = 0; face < 6; ++face) {
				mips.push(downsample(width, height, texture._levels[level - 1][face]));
			}

			texture._levels.push(mips);
		} else {
			texture._levels.push(downsample(width, height, texture._levels[level - 1]));
		}
	}

	texture._levelsUpdated = texture._cubemap ? [[true, true, true, true, true, true]] : [true];
};

class TextureHandler {
	constructor(device, assets, loader) {
		this._device = device;
		this._assets = assets;
		this._loader = loader;
		this.imgParser = new ImgParser(assets);
		this.parsers = {
			dds: new DdsParser(assets),
			ktx: new KtxParser(assets),
			ktx2: new Ktx2Parser(assets, device),
			basis: new BasisParser(assets, device),
			hdr: new HdrParser(assets)
		};
	}

	set crossOrigin(value) {
		this.imgParser.crossOrigin = value;
	}

	get crossOrigin() {
		return this.imgParser.crossOrigin;
	}

	set maxRetries(value) {
		this.imgParser.maxRetries = value;

		for (const parser in this.parsers) {
			if (this.parsers.hasOwnProperty(parser)) {
				this.parsers[parser].maxRetries = value;
			}
		}
	}

	get maxRetries() {
		return this.imgParser.maxRetries;
	}

	_getUrlWithoutParams(url) {
		return url.indexOf('?') >= 0 ? url.split('?')[0] : url;
	}

	_getParser(url) {
		const ext = path.getExtension(this._getUrlWithoutParams(url)).toLowerCase().replace('.', '');
		return this.parsers[ext] || this.imgParser;
	}

	load(url, callback, asset) {
		if (typeof url === 'string') {
			url = {
				load: url,
				original: url
			};
		}

		this._getParser(url.original).load(url, callback, asset);
	}

	open(url, data, asset) {
		if (!url) return;

		let texture = this._getParser(url).open(url, data, this._device);

		if (texture === null) {
			texture = new Texture(this._device, {
				width: 4,
				height: 4,
				format: PIXELFORMAT_R8_G8_B8
			});
		} else {
			_completePartialMipmapChain(texture);

			if (data.unswizzledGGGR) {
				asset.file.variants.basis.opt &= ~8;
			}
		}

		return texture;
	}

	patch(asset, assets) {
		const texture = asset.resource;

		if (!texture) {
			return;
		}

		if (asset.name && asset.name.length > 0) {
			texture.name = asset.name;
		}

		const assetData = asset.data;

		if (assetData.hasOwnProperty('minfilter')) {
			texture.minFilter = JSON_FILTER_MODE[assetData.minfilter];
		}

		if (assetData.hasOwnProperty('magfilter')) {
			texture.magFilter = JSON_FILTER_MODE[assetData.magfilter];
		}

		if (!texture.cubemap) {
			if (assetData.hasOwnProperty('addressu')) {
				texture.addressU = JSON_ADDRESS_MODE[assetData.addressu];
			}

			if (assetData.hasOwnProperty('addressv')) {
				texture.addressV = JSON_ADDRESS_MODE[assetData.addressv];
			}
		}

		if (assetData.hasOwnProperty('mipmaps')) {
			texture.mipmaps = assetData.mipmaps;
		}

		if (assetData.hasOwnProperty('anisotropy')) {
			texture.anisotropy = assetData.anisotropy;
		}

		if (assetData.hasOwnProperty('flipY')) {
			texture.flipY = !!assetData.flipY;
		}

		if (assetData.hasOwnProperty('type')) {
			texture.type = JSON_TEXTURE_TYPE[assetData.type];
		} else if (assetData.hasOwnProperty('rgbm') && assetData.rgbm) {
			texture.type = TEXTURETYPE_RGBM;
		} else if (asset.file && (asset.file.opt & 8) !== 0) {
			texture.type = TEXTURETYPE_SWIZZLEGGGR;
		}
	}

}

class TagsCache {
	constructor(key = null) {
		this._index = {};
		this._key = key;
	}

	addItem(item) {
		const tags = item.tags._list;

		for (const tag of tags) this.add(tag, item);
	}

	removeItem(item) {
		const tags = item.tags._list;

		for (const tag of tags) this.remove(tag, item);
	}

	add(tag, item) {
		if (this._index[tag] && this._index[tag].list.indexOf(item) !== -1) return;

		if (!this._index[tag]) {
			this._index[tag] = {
				list: []
			};
			if (this._key) this._index[tag].keys = {};
		}

		this._index[tag].list.push(item);

		if (this._key) this._index[tag].keys[item[this._key]] = item;
	}

	remove(tag, item) {
		if (!this._index[tag]) return;

		if (this._key) {
			if (!this._index[tag].keys[item[this._key]]) return;
		}

		const ind = this._index[tag].list.indexOf(item);

		if (ind === -1) return;

		this._index[tag].list.splice(ind, 1);

		if (this._key) delete this._index[tag].keys[item[this._key]];
		if (this._index[tag].list.length === 0) delete this._index[tag];
	}

	find(args) {
		const index = {};
		const items = [];
		let item, tag, tags, tagsRest, missingIndex;

		const sort = (a, b) => {
			return this._index[a].list.length - this._index[b].list.length;
		};

		for (let i = 0; i < args.length; i++) {
			tag = args[i];

			if (tag instanceof Array) {
				if (tag.length === 0) continue;

				if (tag.length === 1) {
					tag = tag[0];
				} else {
					missingIndex = false;

					for (let t = 0; t < tag.length; t++) {
						if (!this._index[tag[t]]) {
							missingIndex = true;
							break;
						}
					}

					if (missingIndex) continue;
					tags = tag.slice(0).sort(sort);
					tagsRest = tags.slice(1);
					if (tagsRest.length === 1) tagsRest = tagsRest[0];

					for (let n = 0; n < this._index[tags[0]].list.length; n++) {
						item = this._index[tags[0]].list[n];

						if ((this._key ? !index[item[this._key]] : items.indexOf(item) === -1) && item.tags.has(tagsRest)) {
							if (this._key) index[item[this._key]] = true;
							items.push(item);
						}
					}

					continue;
				}
			}

			if (tag && typeof tag === 'string' && this._index[tag]) {
				for (let n = 0; n < this._index[tag].list.length; n++) {
					item = this._index[tag].list[n];

					if (this._key) {
						if (!index[item[this._key]]) {
							index[item[this._key]] = true;
							items.push(item);
						}
					} else if (items.indexOf(item) === -1) {
						items.push(item);
					}
				}
			}
		}

		return items;
	}

}

class AssetRegistry extends EventHandler {
	constructor(loader) {
		super();
		this._loader = loader;
		this._assets = [];
		this._cache = {};
		this._names = {};
		this._tags = new TagsCache('_id');
		this._urls = {};
		this.prefix = null;
	}

	list(filters) {
		filters = filters || {};
		return this._assets.filter(asset => {
			let include = true;

			if (filters.preload !== undefined) {
				include = asset.preload === filters.preload;
			}

			return include;
		});
	}

	add(asset) {
		const index = this._assets.push(asset) - 1;
		let url;
		this._cache[asset.id] = index;
		if (!this._names[asset.name]) this._names[asset.name] = [];

		this._names[asset.name].push(index);

		if (asset.file) {
			url = asset.file.url;
			this._urls[url] = index;
		}

		asset.registry = this;

		this._tags.addItem(asset);

		asset.tags.on('add', this._onTagAdd, this);
		asset.tags.on('remove', this._onTagRemove, this);
		this.fire("add", asset);
		this.fire("add:" + asset.id, asset);
		if (url) this.fire("add:url:" + url, asset);
		if (asset.preload) this.load(asset);
	}

	remove(asset) {
		const idx = this._cache[asset.id];
		const url = asset.file ? asset.file.url : null;

		if (idx !== undefined) {
			this._assets.splice(idx, 1);

			delete this._cache[asset.id];
			this._names = {};
			this._urls = [];

			for (let i = 0, l = this._assets.length; i < l; i++) {
				const a = this._assets[i];
				this._cache[a.id] = i;

				if (!this._names[a.name]) {
					this._names[a.name] = [];
				}

				this._names[a.name].push(i);

				if (a.file) {
					this._urls[a.file.url] = i;
				}
			}

			this._tags.removeItem(asset);

			asset.tags.off('add', this._onTagAdd, this);
			asset.tags.off('remove', this._onTagRemove, this);
			asset.fire("remove", asset);
			this.fire("remove", asset);
			this.fire("remove:" + asset.id, asset);
			if (url) this.fire("remove:url:" + url, asset);
			return true;
		}

		return false;
	}

	get(id) {
		const idx = this._cache[id];
		return this._assets[idx];
	}

	getByUrl(url) {
		const idx = this._urls[url];
		return this._assets[idx];
	}

	load(asset) {
		if (asset.loading || asset.loaded) {
			return;
		}

		const file = asset.file;

		const _opened = resource => {
			if (resource instanceof Array) {
				asset.resources = resource;
			} else {
				asset.resource = resource;
			}

			this._loader.patch(asset, this);

			this.fire("load", asset);
			this.fire("load:" + asset.id, asset);
			if (file && file.url) this.fire("load:url:" + file.url, asset);
			asset.fire("load", asset);
		};

		const _loaded = (err, resource, extra) => {
			asset.loaded = true;
			asset.loading = false;

			if (err) {
				this.fire("error", err, asset);
				this.fire("error:" + asset.id, err, asset);
				asset.fire("error", err, asset);
			} else {
				if (!script.legacy && asset.type === 'script') {
					const handler = this._loader.getHandler('script');

					if (handler._cache[asset.id] && handler._cache[asset.id].parentNode === document.head) {
						document.head.removeChild(handler._cache[asset.id]);
					}

					handler._cache[asset.id] = extra;
				}

				_opened(resource);
			}
		};

		if (file || asset.type === 'cubemap') {
			this.fire("load:start", asset);
			this.fire("load:" + asset.id + ":start", asset);
			asset.loading = true;

			this._loader.load(asset.getFileUrl(), asset.type, _loaded, asset);
		} else {
			const resource = this._loader.open(asset.type, asset.data);

			asset.loaded = true;

			_opened(resource);
		}
	}

	loadFromUrl(url, type, callback) {
		this.loadFromUrlAndFilename(url, null, type, callback);
	}

	loadFromUrlAndFilename(url, filename, type, callback) {
		const name = path.getBasename(filename || url);
		const file = {
			filename: filename || name,
			url: url
		};
		let asset = this.getByUrl(url);

		if (!asset) {
			asset = new Asset(name, type, file);
			this.add(asset);
		} else if (asset.loaded) {
			callback(asset.loadFromUrlError || null, asset);
			return;
		}

		const startLoad = asset => {
			asset.once("load", loadedAsset => {
				if (type === 'material') {
					this._loadTextures(loadedAsset, (err, textures) => {
						callback(err, loadedAsset);
					});
				} else {
					callback(null, loadedAsset);
				}
			});
			asset.once("error", err => {
				if (err) {
					this.loadFromUrlError = err;
				}

				callback(err, asset);
			});
			this.load(asset);
		};

		if (asset.resource) {
			callback(null, asset);
		} else if (type === 'model') {
			this._loadModel(asset, startLoad);
		} else {
			startLoad(asset);
		}
	}

	_loadModel(modelAsset, continuation) {
		const url = modelAsset.getFileUrl();
		const ext = path.getExtension(url);

		if (ext === '.json' || ext === '.glb') {
			const dir = path.getDirectory(url);
			const basename = path.getBasename(url);
			const mappingUrl = path.join(dir, basename.replace(ext, ".mapping.json"));

			this._loader.load(mappingUrl, 'json', (err, data) => {
				if (err) {
					modelAsset.data = {
						mapping: []
					};
					continuation(modelAsset);
				} else {
					this._loadMaterials(modelAsset, data, (e, materials) => {
						modelAsset.data = data;
						continuation(modelAsset);
					});
				}
			});
		} else {
			continuation(modelAsset);
		}
	}

	_loadMaterials(modelAsset, mapping, callback) {
		const materials = [];
		let count = 0;

		const onMaterialLoaded = (err, materialAsset) => {
			this._loadTextures(materialAsset, (err, textures) => {
				materials.push(materialAsset);

				if (materials.length === count) {
					callback(null, materials);
				}
			});
		};

		for (let i = 0; i < mapping.mapping.length; i++) {
			const path = mapping.mapping[i].path;

			if (path) {
				count++;
				const url = modelAsset.getAbsoluteUrl(path);
				this.loadFromUrl(url, "material", onMaterialLoaded);
			}
		}

		if (count === 0) {
			callback(null, materials);
		}
	}

	_loadTextures(materialAsset, callback) {
		const textures = [];
		let count = 0;
		const data = materialAsset.data;

		if (data.mappingFormat !== 'path') {
			callback(null, textures);
			return;
		}

		const onTextureLoaded = (err, texture) => {
			if (err) console.error(err);
			textures.push(texture);

			if (textures.length === count) {
				callback(null, textures);
			}
		};

		const texParams = standardMaterialTextureParameters;

		for (let i = 0; i < texParams.length; i++) {
			const path = data[texParams[i]];

			if (path && typeof path === 'string') {
				count++;
				const url = materialAsset.getAbsoluteUrl(path);
				this.loadFromUrl(url, "texture", onTextureLoaded);
			}
		}

		if (count === 0) {
			callback(null, textures);
		}
	}

	findAll(name, type) {
		const idxs = this._names[name];

		if (idxs) {
			const assets = idxs.map(idx => {
				return this._assets[idx];
			});

			if (type) {
				return assets.filter(asset => {
					return asset.type === type;
				});
			}

			return assets;
		}

		return [];
	}

	_onTagAdd(tag, asset) {
		this._tags.add(tag, asset);
	}

	_onTagRemove(tag, asset) {
		this._tags.remove(tag, asset);
	}

	findByTag() {
		return this._tags.find(arguments);
	}

	filter(callback) {
		return this._assets.filter(asset => callback(asset));
	}

	find(name, type) {
		const asset = this.findAll(name, type);
		return asset.length > 0 ? asset[0] : null;
	}

}

class BundleRegistry {
	constructor(assets) {
		this._assets = assets;
		this._bundleAssets = {};
		this._assetsInBundles = {};
		this._urlsInBundles = {};
		this._fileRequests = {};

		this._assets.on('add', this._onAssetAdded, this);

		this._assets.on('remove', this._onAssetRemoved, this);
	}

	_onAssetAdded(asset) {
		if (asset.type === 'bundle') {
			this._bundleAssets[asset.id] = asset;

			this._registerBundleEventListeners(asset.id);

			for (let i = 0, len = asset.data.assets.length; i < len; i++) {
				this._indexAssetInBundle(asset.data.assets[i], asset);
			}
		} else {
			if (this._assetsInBundles[asset.id]) {
				this._indexAssetFileUrls(asset);
			}
		}
	}

	_registerBundleEventListeners(bundleAssetId) {
		this._assets.on('load:' + bundleAssetId, this._onBundleLoaded, this);

		this._assets.on('error:' + bundleAssetId, this._onBundleError, this);
	}

	_unregisterBundleEventListeners(bundleAssetId) {
		this._assets.off('load:' + bundleAssetId, this._onBundleLoaded, this);

		this._assets.off('error:' + bundleAssetId, this._onBundleError, this);
	}

	_indexAssetInBundle(assetId, bundleAsset) {
		if (!this._assetsInBundles[assetId]) {
			this._assetsInBundles[assetId] = [bundleAsset];
		} else {
			const bundles = this._assetsInBundles[assetId];
			const idx = bundles.indexOf(bundleAsset);

			if (idx === -1) {
				bundles.push(bundleAsset);
			}
		}

		const asset = this._assets.get(assetId);

		if (asset) {
			this._indexAssetFileUrls(asset);
		}
	}

	_indexAssetFileUrls(asset) {
		const urls = this._getAssetFileUrls(asset);

		if (!urls) return;

		for (let i = 0, len = urls.length; i < len; i++) {
			const url = urls[i];
			this._urlsInBundles[url] = this._assetsInBundles[asset.id];
		}
	}

	_getAssetFileUrls(asset) {
		let url = asset.getFileUrl();
		if (!url) return null;
		url = this._normalizeUrl(url);
		const urls = [url];

		if (asset.type === 'font') {
			const numFiles = asset.data.info.maps.length;

			for (let i = 1; i < numFiles; i++) {
				urls.push(url.replace('.png', i + '.png'));
			}
		}

		return urls;
	}

	_normalizeUrl(url) {
		return url && url.split('?')[0];
	}

	_onAssetRemoved(asset) {
		if (asset.type === 'bundle') {
			delete this._bundleAssets[asset.id];

			this._unregisterBundleEventListeners(asset.id);

			for (const id in this._assetsInBundles) {
				const array = this._assetsInBundles[id];
				const idx = array.indexOf(asset);

				if (idx !== -1) {
					array.splice(idx, 1);

					if (!array.length) {
						delete this._assetsInBundles[id];

						for (const url in this._urlsInBundles) {
							if (this._urlsInBundles[url] === array) {
								delete this._urlsInBundles[url];
							}
						}
					}
				}
			}

			this._onBundleError(`Bundle ${asset.id} was removed`, asset);
		} else if (this._assetsInBundles[asset.id]) {
			delete this._assetsInBundles[asset.id];

			const urls = this._getAssetFileUrls(asset);

			for (let i = 0, len = urls.length; i < len; i++) {
				delete this._urlsInBundles[urls[i]];
			}
		}
	}

	_onBundleLoaded(bundleAsset) {
		if (!bundleAsset.resource) {
			this._onBundleError(`Bundle ${bundleAsset.id} failed to load`, bundleAsset);

			return;
		}

		requestAnimationFrame(() => {
			if (!this._fileRequests) {
				return;
			}

			for (const url in this._fileRequests) {
				const bundles = this._urlsInBundles[url];
				if (!bundles || bundles.indexOf(bundleAsset) === -1) continue;
				const decodedUrl = decodeURIComponent(url);
				let err = null;

				if (!bundleAsset.resource.hasBlobUrl(decodedUrl)) {
					err = `Bundle ${bundleAsset.id} does not contain URL ${url}`;
				}

				const requests = this._fileRequests[url];

				for (let i = 0, len = requests.length; i < len; i++) {
					if (err) {
						requests[i](err);
					} else {
						requests[i](null, bundleAsset.resource.getBlobUrl(decodedUrl));
					}
				}

				delete this._fileRequests[url];
			}
		});
	}

	_onBundleError(err, bundleAsset) {
		for (const url in this._fileRequests) {
			const bundle = this._findLoadedOrLoadingBundleForUrl(url);

			if (!bundle) {
				const requests = this._fileRequests[url];

				for (let i = 0, len = requests.length; i < len; i++) {
					requests[i](err);
				}

				delete this._fileRequests[url];
			}
		}
	}

	_findLoadedOrLoadingBundleForUrl(url) {
		const bundles = this._urlsInBundles[url];
		if (!bundles) return null;
		const len = bundles.length;

		for (let i = 0; i < len; i++) {
			if (bundles[i].loaded && bundles[i].resource) {
				return bundles[i];
			}
		}

		for (let i = 0; i < len; i++) {
			if (bundles[i].loading) {
				return bundles[i];
			}
		}

		return null;
	}

	listBundlesForAsset(asset) {
		return this._assetsInBundles[asset.id] || null;
	}

	list() {
		const result = [];

		for (const id in this._bundleAssets) {
			result.push(this._bundleAssets[id]);
		}

		return result;
	}

	hasUrl(url) {
		return !!this._urlsInBundles[url];
	}

	canLoadUrl(url) {
		return !!this._findLoadedOrLoadingBundleForUrl(url);
	}

	loadUrl(url, callback) {
		const bundle = this._findLoadedOrLoadingBundleForUrl(url);

		if (!bundle) {
			callback(`URL ${url} not found in any bundles`);
			return;
		}

		if (bundle.loaded) {
			const decodedUrl = decodeURIComponent(url);

			if (!bundle.resource.hasBlobUrl(decodedUrl)) {
				callback(`Bundle ${bundle.id} does not contain URL ${url}`);
				return;
			}

			callback(null, bundle.resource.getBlobUrl(decodedUrl));
		} else if (this._fileRequests.hasOwnProperty(url)) {
			this._fileRequests[url].push(callback);
		} else {
			this._fileRequests[url] = [callback];
		}
	}

	destroy() {
		this._assets.off('add', this._onAssetAdded, this);

		this._assets.off('remove', this._onAssetRemoved, this);

		for (const id in this._bundleAssets) {
			this._unregisterBundleEventListeners(id);
		}

		this._assets = null;
		this._bundleAssets = null;
		this._assetsInBundles = null;
		this._urlsInBundles = null;
		this._fileRequests = null;
	}

}

const components = ['x', 'y', 'z', 'w'];
const vecLookup = [undefined, undefined, Vec2, Vec3, Vec4];

function rawToValue(app, args, value, old) {
	switch (args.type) {
		case 'boolean':
			return !!value;

		case 'number':
			if (typeof value === 'number') {
				return value;
			} else if (typeof value === 'string') {
				const v = parseInt(value, 10);
				if (isNaN(v)) return null;
				return v;
			} else if (typeof value === 'boolean') {
				return 0 + value;
			}

			return null;

		case 'json':
			{
				const result = {};

				if (Array.isArray(args.schema)) {
					if (!value || typeof value !== 'object') {
						value = {};
					}

					for (let i = 0; i < args.schema.length; i++) {
						const field = args.schema[i];
						if (!field.name) continue;

						if (field.array) {
							result[field.name] = [];
							const arr = Array.isArray(value[field.name]) ? value[field.name] : [];

							for (let j = 0; j < arr.length; j++) {
								result[field.name].push(rawToValue(app, field, arr[j]));
							}
						} else {
							const val = value.hasOwnProperty(field.name) ? value[field.name] : field.default;
							result[field.name] = rawToValue(app, field, val);
						}
					}
				}

				return result;
			}

		case 'asset':
			if (value instanceof Asset) {
				return value;
			} else if (typeof value === 'number') {
				return app.assets.get(value) || null;
			} else if (typeof value === 'string') {
				return app.assets.get(parseInt(value, 10)) || null;
			}

			return null;

		case 'entity':
			if (value instanceof GraphNode) {
				return value;
			} else if (typeof value === 'string') {
				return app.getEntityFromIndex(value);
			}

			return null;

		case 'rgb':
		case 'rgba':
			if (value instanceof Color) {
				if (old instanceof Color) {
					old.copy(value);
					return old;
				}

				return value.clone();
			} else if (value instanceof Array && value.length >= 3 && value.length <= 4) {
				for (let i = 0; i < value.length; i++) {
					if (typeof value[i] !== 'number') return null;
				}

				if (!old) old = new Color();
				old.r = value[0];
				old.g = value[1];
				old.b = value[2];
				old.a = value.length === 3 ? 1 : value[3];
				return old;
			} else if (typeof value === 'string' && /#([0-9abcdef]{2}){3,4}/i.test(value)) {
				if (!old) old = new Color();
				old.fromString(value);
				return old;
			}

			return null;

		case 'vec2':
		case 'vec3':
		case 'vec4':
			{
				const len = parseInt(args.type.slice(3), 10);
				const vecType = vecLookup[len];

				if (value instanceof vecType) {
					if (old instanceof vecType) {
						old.copy(value);
						return old;
					}

					return value.clone();
				} else if (value instanceof Array && value.length === len) {
					for (let i = 0; i < value.length; i++) {
						if (typeof value[i] !== 'number') return null;
					}

					if (!old) old = new vecType();

					for (let i = 0; i < len; i++) old[components[i]] = value[i];

					return old;
				}

				return null;
			}

		case 'curve':
			if (value) {
				let curve;

				if (value instanceof Curve || value instanceof CurveSet) {
					curve = value.clone();
				} else {
					const CurveType = value.keys[0] instanceof Array ? CurveSet : Curve;
					curve = new CurveType(value.keys);
					curve.type = value.type;
				}

				return curve;
			}

			break;
	}

	return value;
}

class ScriptAttributes {
	constructor(scriptType) {
		this.scriptType = scriptType;
		this.index = {};
	}

	add(name, args) {
		if (this.index[name]) {
			return;
		} else if (ScriptAttributes.reservedNames.has(name)) {
			return;
		}

		this.index[name] = args;
		Object.defineProperty(this.scriptType.prototype, name, {
			get: function () {
				return this.__attributes[name];
			},
			set: function (raw) {
				const evt = 'attr';
				const evtName = 'attr:' + name;
				const old = this.__attributes[name];
				let oldCopy = old;

				if (old && args.type !== 'json' && old.clone) {
					if (this._callbacks[evt] || this._callbacks[evtName]) {
						oldCopy = old.clone();
					}
				}

				if (args.array) {
					this.__attributes[name] = [];

					if (raw) {
						for (let i = 0, len = raw.length; i < len; i++) {
							this.__attributes[name].push(rawToValue(this.app, args, raw[i], old ? old[i] : null));
						}
					}
				} else {
					this.__attributes[name] = rawToValue(this.app, args, raw, old);
				}

				this.fire(evt, name, this.__attributes[name], oldCopy);
				this.fire(evtName, this.__attributes[name], oldCopy);
			}
		});
	}

	remove(name) {
		if (!this.index[name]) return false;
		delete this.index[name];
		delete this.scriptType.prototype[name];
		return true;
	}

	has(name) {
		return !!this.index[name];
	}

	get(name) {
		return this.index[name] || null;
	}

}

ScriptAttributes.reservedNames = new Set(['app', 'entity', 'enabled', '_enabled', '_enabledOld', '_destroyed', '__attributes', '__attributesRaw', '__scriptType', '__executionOrder', '_callbacks', 'has', 'get', 'on', 'off', 'fire', 'once', 'hasEvent']);

class Component extends EventHandler {
	constructor(system, entity) {
		super();
		this.system = void 0;
		this.entity = void 0;
		this.system = system;
		this.entity = entity;

		if (this.system.schema && !this._accessorsBuilt) {
			this.buildAccessors(this.system.schema);
		}

		this.on("set", function (name, oldValue, newValue) {
			this.fire("set_" + name, name, oldValue, newValue);
		});
		this.on('set_enabled', this.onSetEnabled, this);
	}

	static _buildAccessors(obj, schema) {
		schema.forEach(function (descriptor) {
			const name = typeof descriptor === 'object' ? descriptor.name : descriptor;
			Object.defineProperty(obj, name, {
				get: function () {
					return this.data[name];
				},
				set: function (value) {
					const data = this.data;
					const oldValue = data[name];
					data[name] = value;
					this.fire('set', name, oldValue, value);
				},
				configurable: true
			});
		});
		obj._accessorsBuilt = true;
	}

	buildAccessors(schema) {
		Component._buildAccessors(this, schema);
	}

	onSetEnabled(name, oldValue, newValue) {
		if (oldValue !== newValue) {
			if (this.entity.enabled) {
				if (newValue) {
					this.onEnable();
				} else {
					this.onDisable();
				}
			}
		}
	}

	onEnable() {}

	onDisable() {}

	onPostStateChange() {}

	get data() {
		const record = this.system.store[this.entity.getGuid()];
		return record ? record.data : null;
	}

}

class ScriptComponent extends Component {
	constructor(system, entity) {
		super(system, entity);
		this._scripts = [];
		this._updateList = new SortedLoopArray({
			sortBy: '__executionOrder'
		});
		this._postUpdateList = new SortedLoopArray({
			sortBy: '__executionOrder'
		});
		this._scriptsIndex = {};
		this._destroyedScripts = [];
		this._destroyed = false;
		this._scriptsData = null;
		this._oldState = true;
		this._enabled = true;
		this._beingEnabled = false;
		this._isLoopingThroughScripts = false;
		this._executionOrder = -1;
		this.on('set_enabled', this._onSetEnabled, this);
	}

	set enabled(value) {
		const oldValue = this._enabled;
		this._enabled = value;
		this.fire('set', 'enabled', oldValue, value);
	}

	get enabled() {
		return this._enabled;
	}

	set scripts(value) {
		this._scriptsData = value;

		for (const key in value) {
			if (!value.hasOwnProperty(key)) continue;
			const script = this._scriptsIndex[key];

			if (script) {
				if (typeof value[key].enabled === 'boolean') script.enabled = !!value[key].enabled;

				if (typeof value[key].attributes === 'object') {
					for (const attr in value[key].attributes) {
						if (ScriptAttributes.reservedNames.has(attr)) continue;

						if (!script.__attributes.hasOwnProperty(attr)) {
							const scriptType = this.system.app.scripts.get(key);
							if (scriptType) scriptType.attributes.add(attr, {});
						}

						script[attr] = value[key].attributes[attr];
					}
				}
			} else {
				console.log(this.order);
			}
		}
	}

	get scripts() {
		return this._scripts;
	}

	onEnable() {
		this._beingEnabled = true;

		this._checkState();

		if (!this.entity._beingEnabled) {
			this.onPostStateChange();
		}

		this._beingEnabled = false;
	}

	onDisable() {
		this._checkState();
	}

	onPostStateChange() {
		const wasLooping = this._beginLooping();

		for (let i = 0, len = this.scripts.length; i < len; i++) {
			const script = this.scripts[i];

			if (script._initialized && !script._postInitialized && script.enabled) {
				script._postInitialized = true;
				if (script.postInitialize) this._scriptMethod(script, ScriptComponent.scriptMethods.postInitialize);
			}
		}

		this._endLooping(wasLooping);
	}

	_beginLooping() {
		const looping = this._isLoopingThroughScripts;
		this._isLoopingThroughScripts = true;
		return looping;
	}

	_endLooping(wasLoopingBefore) {
		this._isLoopingThroughScripts = wasLoopingBefore;

		if (!this._isLoopingThroughScripts) {
			this._removeDestroyedScripts();
		}
	}

	_onSetEnabled(prop, old, value) {
		this._beingEnabled = true;

		this._checkState();

		this._beingEnabled = false;
	}

	_checkState() {
		const state = this.enabled && this.entity.enabled;
		if (state === this._oldState) return;
		this._oldState = state;
		this.fire(state ? 'enable' : 'disable');
		this.fire('state', state);

		if (state) {
			this.system._addComponentToEnabled(this);
		} else {
			this.system._removeComponentFromEnabled(this);
		}

		const wasLooping = this._beginLooping();

		for (let i = 0, len = this.scripts.length; i < len; i++) {
			const script = this.scripts[i];
			script.enabled = script._enabled;
		}

		this._endLooping(wasLooping);
	}

	_onBeforeRemove() {
		this.fire('remove');

		const wasLooping = this._beginLooping();

		for (let i = 0; i < this.scripts.length; i++) {
			const script = this.scripts[i];
			if (!script) continue;
			this.destroy(script.__scriptType.__name);
		}

		this._endLooping(wasLooping);
	}

	_removeDestroyedScripts() {
		const len = this._destroyedScripts.length;
		if (!len) return;

		for (let i = 0; i < len; i++) {
			const script = this._destroyedScripts[i];

			this._removeScriptInstance(script);
		}

		this._destroyedScripts.length = 0;

		this._resetExecutionOrder(0, this._scripts.length);
	}

	_onInitializeAttributes() {
		for (let i = 0, len = this.scripts.length; i < len; i++) this.scripts[i].__initializeAttributes();
	}

	_scriptMethod(script, method, arg) {
		script[method](arg);
	}

	_onInitialize() {
		const scripts = this._scripts;

		const wasLooping = this._beginLooping();

		for (let i = 0, len = scripts.length; i < len; i++) {
			const script = scripts[i];

			if (!script._initialized && script.enabled) {
				script._initialized = true;
				if (script.initialize) this._scriptMethod(script, ScriptComponent.scriptMethods.initialize);
			}
		}

		this._endLooping(wasLooping);
	}

	_onPostInitialize() {
		this.onPostStateChange();
	}

	_onUpdate(dt) {
		const list = this._updateList;
		if (!list.length) return;

		const wasLooping = this._beginLooping();

		for (list.loopIndex = 0; list.loopIndex < list.length; list.loopIndex++) {
			const script = list.items[list.loopIndex];

			if (script.enabled) {
				this._scriptMethod(script, ScriptComponent.scriptMethods.update, dt);
			}
		}

		this._endLooping(wasLooping);
	}

	_onPostUpdate(dt) {
		const list = this._postUpdateList;
		if (!list.length) return;

		const wasLooping = this._beginLooping();

		for (list.loopIndex = 0; list.loopIndex < list.length; list.loopIndex++) {
			const script = list.items[list.loopIndex];

			if (script.enabled) {
				this._scriptMethod(script, ScriptComponent.scriptMethods.postUpdate, dt);
			}
		}

		this._endLooping(wasLooping);
	}

	_insertScriptInstance(scriptInstance, index, scriptsLength) {
		if (index === -1) {
			this._scripts.push(scriptInstance);

			scriptInstance.__executionOrder = scriptsLength;

			if (scriptInstance.update) {
				this._updateList.append(scriptInstance);
			}

			if (scriptInstance.postUpdate) {
				this._postUpdateList.append(scriptInstance);
			}
		} else {
			this._scripts.splice(index, 0, scriptInstance);

			scriptInstance.__executionOrder = index;

			this._resetExecutionOrder(index + 1, scriptsLength + 1);

			if (scriptInstance.update) {
				this._updateList.insert(scriptInstance);
			}

			if (scriptInstance.postUpdate) {
				this._postUpdateList.insert(scriptInstance);
			}
		}
	}

	_removeScriptInstance(scriptInstance) {
		const idx = this._scripts.indexOf(scriptInstance);

		if (idx === -1) return idx;

		this._scripts.splice(idx, 1);

		if (scriptInstance.update) {
			this._updateList.remove(scriptInstance);
		}

		if (scriptInstance.postUpdate) {
			this._postUpdateList.remove(scriptInstance);
		}

		return idx;
	}

	_resetExecutionOrder(startIndex, scriptsLength) {
		for (let i = startIndex; i < scriptsLength; i++) {
			this._scripts[i].__executionOrder = i;
		}
	}

	_resolveEntityScriptAttribute(attribute, attributeName, oldValue, useGuid, newAttributes, duplicatedIdsMap) {
		if (attribute.array) {
			const len = oldValue.length;

			if (!len) {
				return;
			}

			const newGuidArray = oldValue.slice();

			for (let i = 0; i < len; i++) {
				const guid = newGuidArray[i] instanceof Entity ? newGuidArray[i].getGuid() : newGuidArray[i];

				if (duplicatedIdsMap[guid]) {
					newGuidArray[i] = useGuid ? duplicatedIdsMap[guid].getGuid() : duplicatedIdsMap[guid];
				}
			}

			newAttributes[attributeName] = newGuidArray;
		} else {
			if (oldValue instanceof Entity) {
				oldValue = oldValue.getGuid();
			} else if (typeof oldValue !== 'string') {
				return;
			}

			if (duplicatedIdsMap[oldValue]) {
				newAttributes[attributeName] = duplicatedIdsMap[oldValue];
			}
		}
	}

	has(nameOrType) {
		if (typeof nameOrType === 'string') {
			return !!this._scriptsIndex[nameOrType];
		}

		if (!nameOrType) return false;
		const scriptType = nameOrType;
		const scriptName = scriptType.__name;
		const scriptData = this._scriptsIndex[scriptName];
		const scriptInstance = scriptData && scriptData.instance;
		return scriptInstance instanceof scriptType;
	}

	get(nameOrType) {
		if (typeof nameOrType === 'string') {
			const data = this._scriptsIndex[nameOrType];
			return data ? data.instance : null;
		}

		if (!nameOrType) return null;
		const scriptType = nameOrType;
		const scriptName = scriptType.__name;
		const scriptData = this._scriptsIndex[scriptName];
		const scriptInstance = scriptData && scriptData.instance;
		return scriptInstance instanceof scriptType ? scriptInstance : null;
	}

	create(nameOrType, args = {}) {
		const self = this;
		let scriptType = nameOrType;
		let scriptName = nameOrType;

		if (typeof scriptType === 'string') {
			scriptType = this.system.app.scripts.get(scriptType);
		} else if (scriptType) {
			scriptName = scriptType.__name;
		}

		if (scriptType) {
			if (!this._scriptsIndex[scriptName] || !this._scriptsIndex[scriptName].instance) {
				const scriptInstance = new scriptType({
					app: this.system.app,
					entity: this.entity,
					enabled: args.hasOwnProperty('enabled') ? args.enabled : true,
					attributes: args.attributes
				});
				const len = this._scripts.length;
				let ind = -1;
				if (typeof args.ind === 'number' && args.ind !== -1 && len > args.ind) ind = args.ind;

				this._insertScriptInstance(scriptInstance, ind, len);

				this._scriptsIndex[scriptName] = {
					instance: scriptInstance,
					onSwap: function () {
						self.swap(scriptName);
					}
				};
				this[scriptName] = scriptInstance;
				if (!args.preloading) scriptInstance.__initializeAttributes();
				this.fire('create', scriptName, scriptInstance);
				this.fire('create:' + scriptName, scriptInstance);
				this.system.app.scripts.on('swap:' + scriptName, this._scriptsIndex[scriptName].onSwap);

				if (!args.preloading) {
					if (scriptInstance.enabled && !scriptInstance._initialized) {
						scriptInstance._initialized = true;
						if (scriptInstance.initialize) this._scriptMethod(scriptInstance, ScriptComponent.scriptMethods.initialize);
					}

					if (scriptInstance.enabled && !scriptInstance._postInitialized) {
						scriptInstance._postInitialized = true;
						if (scriptInstance.postInitialize) this._scriptMethod(scriptInstance, ScriptComponent.scriptMethods.postInitialize);
					}
				}

				return scriptInstance;
			}
		} else {
			this._scriptsIndex[scriptName] = {
				awaiting: true,
				ind: this._scripts.length
			};
		}

		return null;
	}

	destroy(nameOrType) {
		let scriptName = nameOrType;
		let scriptType = nameOrType;

		if (typeof scriptType === 'string') {
			scriptType = this.system.app.scripts.get(scriptType);
		} else if (scriptType) {
			scriptName = scriptType.__name;
		}

		const scriptData = this._scriptsIndex[scriptName];
		delete this._scriptsIndex[scriptName];
		if (!scriptData) return false;
		const scriptInstance = scriptData.instance;

		if (scriptInstance && !scriptInstance._destroyed) {
			scriptInstance.enabled = false;
			scriptInstance._destroyed = true;

			if (!this._isLoopingThroughScripts) {
				const ind = this._removeScriptInstance(scriptInstance);

				if (ind >= 0) {
					this._resetExecutionOrder(ind, this._scripts.length);
				}
			} else {
				this._destroyedScripts.push(scriptInstance);
			}
		}

		this.system.app.scripts.off('swap:' + scriptName, scriptData.onSwap);
		delete this[scriptName];
		this.fire('destroy', scriptName, scriptInstance || null);
		this.fire('destroy:' + scriptName, scriptInstance || null);
		if (scriptInstance) scriptInstance.fire('destroy');
		return true;
	}

	swap(nameOrType) {
		let scriptName = nameOrType;
		let scriptType = nameOrType;

		if (typeof scriptType === 'string') {
			scriptType = this.system.app.scripts.get(scriptType);
		} else if (scriptType) {
			scriptName = scriptType.__name;
		}

		const old = this._scriptsIndex[scriptName];
		if (!old || !old.instance) return false;
		const scriptInstanceOld = old.instance;

		const ind = this._scripts.indexOf(scriptInstanceOld);

		const scriptInstance = new scriptType({
			app: this.system.app,
			entity: this.entity,
			enabled: scriptInstanceOld.enabled,
			attributes: scriptInstanceOld.__attributes
		});
		if (!scriptInstance.swap) return false;

		scriptInstance.__initializeAttributes();

		this._scripts[ind] = scriptInstance;
		this._scriptsIndex[scriptName].instance = scriptInstance;
		this[scriptName] = scriptInstance;
		scriptInstance.__executionOrder = ind;

		if (scriptInstanceOld.update) {
			this._updateList.remove(scriptInstanceOld);
		}

		if (scriptInstanceOld.postUpdate) {
			this._postUpdateList.remove(scriptInstanceOld);
		}

		if (scriptInstance.update) {
			this._updateList.insert(scriptInstance);
		}

		if (scriptInstance.postUpdate) {
			this._postUpdateList.insert(scriptInstance);
		}

		this._scriptMethod(scriptInstance, ScriptComponent.scriptMethods.swap, scriptInstanceOld);

		this.fire('swap', scriptName, scriptInstance);
		this.fire('swap:' + scriptName, scriptInstance);
		return true;
	}

	resolveDuplicatedEntityReferenceProperties(oldScriptComponent, duplicatedIdsMap) {
		const newScriptComponent = this.entity.script;

		for (const scriptName in oldScriptComponent._scriptsIndex) {
			const scriptType = this.system.app.scripts.get(scriptName);

			if (!scriptType) {
				continue;
			}

			const script = oldScriptComponent._scriptsIndex[scriptName];

			if (!script || !script.instance) {
				continue;
			}

			const newAttributesRaw = newScriptComponent[scriptName].__attributesRaw;
			const newAttributes = newScriptComponent[scriptName].__attributes;

			if (!newAttributesRaw && !newAttributes) {
				continue;
			}

			const useGuid = !!newAttributesRaw;
			const oldAttributes = script.instance.__attributes;

			for (const attributeName in oldAttributes) {
				if (!oldAttributes[attributeName]) {
					continue;
				}

				const attribute = scriptType.attributes.get(attributeName);

				if (!attribute) {
					continue;
				}

				if (attribute.type === 'entity') {
					this._resolveEntityScriptAttribute(attribute, attributeName, oldAttributes[attributeName], useGuid, newAttributesRaw || newAttributes, duplicatedIdsMap);
				} else if (attribute.type === 'json' && Array.isArray(attribute.schema)) {
					const oldValue = oldAttributes[attributeName];
					const newJsonValue = newAttributesRaw ? newAttributesRaw[attributeName] : newAttributes[attributeName];

					for (let i = 0; i < attribute.schema.length; i++) {
						const field = attribute.schema[i];

						if (field.type !== 'entity') {
							continue;
						}

						if (attribute.array) {
							for (let j = 0; j < oldValue.length; j++) {
								this._resolveEntityScriptAttribute(field, field.name, oldValue[j][field.name], useGuid, newJsonValue[j], duplicatedIdsMap);
							}
						} else {
							this._resolveEntityScriptAttribute(field, field.name, oldValue[field.name], useGuid, newJsonValue, duplicatedIdsMap);
						}
					}
				}
			}
		}
	}

	move(nameOrType, ind) {
		const len = this._scripts.length;
		if (ind >= len || ind < 0) return false;
		let scriptType = nameOrType;
		let scriptName = nameOrType;

		if (typeof scriptName !== 'string') {
			scriptName = nameOrType.__name;
		} else {
			scriptType = null;
		}

		const scriptData = this._scriptsIndex[scriptName];
		if (!scriptData || !scriptData.instance) return false;
		const scriptInstance = scriptData.instance;
		if (scriptType && !(scriptInstance instanceof scriptType)) return false;

		const indOld = this._scripts.indexOf(scriptInstance);

		if (indOld === -1 || indOld === ind) return false;

		this._scripts.splice(ind, 0, this._scripts.splice(indOld, 1)[0]);

		this._resetExecutionOrder(0, len);

		this._updateList.sort();

		this._postUpdateList.sort();

		this.fire('move', scriptName, scriptInstance, ind, indOld);
		this.fire('move:' + scriptName, scriptInstance, ind, indOld);
		return true;
	}

}

ScriptComponent.scriptMethods = {
	initialize: 'initialize',
	postInitialize: 'postInitialize',
	update: 'update',
	postUpdate: 'postUpdate',
	swap: 'swap'
};

const funcNameRegex = new RegExp('^\\s*function(?:\\s|\\s*\\/\\*.*\\*\\/\\s*)+([^\\(\\s\\/]*)\\s*');

class ScriptType extends EventHandler {
	constructor(args) {
		super();
		this.app = void 0;
		this.entity = void 0;
		this._enabled = void 0;
		this._enabledOld = void 0;
		this._initialized = void 0;
		this._postInitialized = void 0;
		this.__destroyed = void 0;
		this.__attributes = void 0;
		this.__attributesRaw = void 0;
		this.__scriptType = void 0;
		this.__executionOrder = void 0;
		this.initScriptType(args);
	}

	set enabled(value) {
		this._enabled = !!value;
		if (this.enabled === this._enabledOld) return;
		this._enabledOld = this.enabled;
		this.fire(this.enabled ? 'enable' : 'disable');
		this.fire('state', this.enabled);

		if (!this._initialized && this.enabled) {
			this._initialized = true;

			this.__initializeAttributes(true);

			if (this.initialize) this.entity.script._scriptMethod(this, ScriptComponent.scriptMethods.initialize);
		}

		if (this._initialized && !this._postInitialized && this.enabled && !this.entity.script._beingEnabled) {
			this._postInitialized = true;
			if (this.postInitialize) this.entity.script._scriptMethod(this, ScriptComponent.scriptMethods.postInitialize);
		}
	}

	get enabled() {
		return this._enabled && !this._destroyed && this.entity.script.enabled && this.entity.enabled;
	}

	initScriptType(args) {
		const script = this.constructor;
		this.app = args.app;
		this.entity = args.entity;
		this._enabled = typeof args.enabled === 'boolean' ? args.enabled : true;
		this._enabledOld = this.enabled;
		this.__destroyed = false;
		this.__attributes = {};
		this.__attributesRaw = args.attributes || {};
		this.__scriptType = script;
		this.__executionOrder = -1;
	}

	static __getScriptName(constructorFn) {
		if (typeof constructorFn !== 'function') return undefined;
		if ('name' in Function.prototype) return constructorFn.name;
		if (constructorFn === Function || constructorFn === Function.prototype.constructor) return 'Function';
		const match = ("" + constructorFn).match(funcNameRegex);
		return match ? match[1] : undefined;
	}

	static get scriptName() {
		return this.__name;
	}

	static get attributes() {
		if (!this.hasOwnProperty('__attributes')) this.__attributes = new ScriptAttributes(this);
		return this.__attributes;
	}

	__initializeAttributes(force) {
		if (!force && !this.__attributesRaw) return;

		for (const key in this.__scriptType.attributes.index) {
			if (this.__attributesRaw && this.__attributesRaw.hasOwnProperty(key)) {
				this[key] = this.__attributesRaw[key];
			} else if (!this.__attributes.hasOwnProperty(key)) {
				if (this.__scriptType.attributes.index[key].hasOwnProperty('default')) {
					this[key] = this.__scriptType.attributes.index[key].default;
				} else {
					this[key] = null;
				}
			}
		}

		this.__attributesRaw = null;
	}

	static extend(methods) {
		for (const key in methods) {
			if (!methods.hasOwnProperty(key)) continue;
			this.prototype[key] = methods[key];
		}
	}

}

ScriptType.__name = null;

class ScriptRegistry extends EventHandler {
	constructor(app) {
		super();
		this.app = app;
		this._scripts = {};
		this._list = [];
	}

	destroy() {
		this.app = null;
		this.off();
	}

	add(script) {
		const scriptName = script.__name;

		if (this._scripts.hasOwnProperty(scriptName)) {
			setTimeout(() => {
				if (script.prototype.swap) {
					const old = this._scripts[scriptName];

					const ind = this._list.indexOf(old);

					this._list[ind] = script;
					this._scripts[scriptName] = script;
					this.fire('swap', scriptName, script);
					this.fire('swap:' + scriptName, script);
				} else {
					console.warn(`script registry already has '${scriptName}' script, define 'swap' method for new script type to enable code hot swapping`);
				}
			});
			return false;
		}

		this._scripts[scriptName] = script;

		this._list.push(script);

		this.fire('add', scriptName, script);
		this.fire('add:' + scriptName, script);
		setTimeout(() => {
			if (!this._scripts.hasOwnProperty(scriptName)) return;

			if (!this.app || !this.app.systems || !this.app.systems.script) {
				return;
			}

			const components = this.app.systems.script._components;
			let attributes;
			const scriptInstances = [];
			const scriptInstancesInitialized = [];

			for (components.loopIndex = 0; components.loopIndex < components.length; components.loopIndex++) {
				const component = components.items[components.loopIndex];

				if (component._scriptsIndex[scriptName] && component._scriptsIndex[scriptName].awaiting) {
					if (component._scriptsData && component._scriptsData[scriptName]) attributes = component._scriptsData[scriptName].attributes;
					const scriptInstance = component.create(scriptName, {
						preloading: true,
						ind: component._scriptsIndex[scriptName].ind,
						attributes: attributes
					});
					if (scriptInstance) scriptInstances.push(scriptInstance);
				}
			}

			for (let i = 0; i < scriptInstances.length; i++) scriptInstances[i].__initializeAttributes();

			for (let i = 0; i < scriptInstances.length; i++) {
				if (scriptInstances[i].enabled) {
					scriptInstances[i]._initialized = true;
					scriptInstancesInitialized.push(scriptInstances[i]);
					if (scriptInstances[i].initialize) scriptInstances[i].initialize();
				}
			}

			for (let i = 0; i < scriptInstancesInitialized.length; i++) {
				if (!scriptInstancesInitialized[i].enabled || scriptInstancesInitialized[i]._postInitialized) {
					continue;
				}

				scriptInstancesInitialized[i]._postInitialized = true;
				if (scriptInstancesInitialized[i].postInitialize) scriptInstancesInitialized[i].postInitialize();
			}
		});
		return true;
	}

	remove(nameOrType) {
		let scriptType = nameOrType;
		let scriptName = nameOrType;

		if (typeof scriptName !== 'string') {
			scriptName = scriptType.__name;
		} else {
			scriptType = this.get(scriptName);
		}

		if (this.get(scriptName) !== scriptType) return false;
		delete this._scripts[scriptName];

		const ind = this._list.indexOf(scriptType);

		this._list.splice(ind, 1);

		this.fire('remove', scriptName, scriptType);
		this.fire('remove:' + scriptName, scriptType);
		return true;
	}

	get(name) {
		return this._scripts[name] || null;
	}

	has(nameOrType) {
		if (typeof nameOrType === 'string') {
			return this._scripts.hasOwnProperty(nameOrType);
		}

		if (!nameOrType) return false;
		const scriptName = nameOrType.__name;
		return this._scripts[scriptName] === nameOrType;
	}

	list() {
		return this._list;
	}

}

class I18nParser {
	_validate(data) {
		if (!data.header) {
			throw new Error('pc.I18n#addData: Missing "header" field');
		}

		if (!data.header.version) {
			throw new Error('pc.I18n#addData: Missing "header.version" field');
		}

		if (data.header.version !== 1) {
			throw new Error('pc.I18n#addData: Invalid "header.version" field');
		}

		if (!data.data) {
			throw new Error('pc.I18n#addData: Missing "data" field');
		} else if (!Array.isArray(data.data)) {
			throw new Error('pc.I18n#addData: "data" field must be an array');
		}

		for (let i = 0, len = data.data.length; i < len; i++) {
			const entry = data.data[i];

			if (!entry.info) {
				throw new Error(`pc.I18n#addData: missing "data[${i}].info" field`);
			}

			if (!entry.info.locale) {
				throw new Error(`pc.I18n#addData: missing "data[${i}].info.locale" field`);
			}

			if (typeof entry.info.locale !== 'string') {
				throw new Error(`pc.I18n#addData: "data[${i}].info.locale" must be a string`);
			}

			if (!entry.messages) {
				throw new Error(`pc.I18n#addData: missing "data[${i}].messages" field`);
			}
		}
	}

	parse(data) {
		return data.data;
	}

}

class I18n extends EventHandler {
	constructor(app) {
		super();
		this.locale = DEFAULT_LOCALE;
		this._translations = {};
		this._availableLangs = {};
		this._app = app;
		this._assets = [];
		this._parser = new I18nParser();
	}

	set assets(value) {
		const index = {};

		for (let _i = 0, len = value.length; _i < len; _i++) {
			const id = value[_i] instanceof Asset ? value[_i].id : value[_i];
			index[id] = true;
		}

		let i = this._assets.length;

		while (i--) {
			const id = this._assets[i];

			if (!index[id]) {
				this._app.assets.off('add:' + id, this._onAssetAdd, this);

				const asset = this._app.assets.get(id);

				if (asset) {
					this._onAssetRemove(asset);
				}

				this._assets.splice(i, 1);
			}
		}

		for (const id in index) {
			const idNum = parseInt(id, 10);
			if (this._assets.indexOf(idNum) !== -1) continue;

			this._assets.push(idNum);

			const asset = this._app.assets.get(idNum);

			if (!asset) {
				this._app.assets.once('add:' + idNum, this._onAssetAdd, this);
			} else {
				this._onAssetAdd(asset);
			}
		}
	}

	get assets() {
		return this._assets;
	}

	set locale(value) {
		if (this._locale === value) {
			return;
		}

		let lang = getLang(value);

		if (lang === 'in') {
			lang = 'id';
			value = replaceLang(value, lang);

			if (this._locale === value) {
				return;
			}
		}

		const old = this._locale;
		this._locale = value;
		this._lang = lang;
		this._pluralFn = getPluralFn(this._lang);
		this.fire('set:locale', value, old);
	}

	get locale() {
		return this._locale;
	}

	static findAvailableLocale(desiredLocale, availableLocales) {
		return findAvailableLocale(desiredLocale, availableLocales);
	}

	findAvailableLocale(desiredLocale) {
		if (this._translations[desiredLocale]) {
			return desiredLocale;
		}

		const lang = getLang(desiredLocale);
		return this._findFallbackLocale(desiredLocale, lang);
	}

	getText(key, locale) {
		let result = key;
		let lang;

		if (!locale) {
			locale = this._locale;
			lang = this._lang;
		}

		let translations = this._translations[locale];

		if (!translations) {
			if (!lang) {
				lang = getLang(locale);
			}

			locale = this._findFallbackLocale(locale, lang);
			translations = this._translations[locale];
		}

		if (translations && translations.hasOwnProperty(key)) {
			result = translations[key];

			if (Array.isArray(result)) {
				result = result[0];
			}

			if (result === null || result === undefined) {
				result = key;
			}
		}

		return result;
	}

	getPluralText(key, n, locale) {
		let result = key;
		let lang;
		let pluralFn;

		if (!locale) {
			locale = this._locale;
			lang = this._lang;
			pluralFn = this._pluralFn;
		} else {
			lang = getLang(locale);
			pluralFn = getPluralFn(lang);
		}

		let translations = this._translations[locale];

		if (!translations) {
			locale = this._findFallbackLocale(locale, lang);
			lang = getLang(locale);
			pluralFn = getPluralFn(lang);
			translations = this._translations[locale];
		}

		if (translations && translations[key] && pluralFn) {
			const index = pluralFn(n);
			result = translations[key][index];

			if (result === null || result === undefined) {
				result = key;
			}
		}

		return result;
	}

	addData(data) {
		let parsed;

		try {
			parsed = this._parser.parse(data);
		} catch (err) {
			console.error(err);
			return;
		}

		for (let i = 0, len = parsed.length; i < len; i++) {
			const entry = parsed[i];
			const locale = entry.info.locale;
			const messages = entry.messages;

			if (!this._translations[locale]) {
				this._translations[locale] = {};
				const lang = getLang(locale);

				if (!this._availableLangs[lang]) {
					this._availableLangs[lang] = locale;
				}
			}

			Object.assign(this._translations[locale], messages);
			this.fire('data:add', locale, messages);
		}
	}

	removeData(data) {
		let parsed;

		try {
			parsed = this._parser.parse(data);
		} catch (err) {
			console.error(err);
			return;
		}

		for (let i = 0, len = parsed.length; i < len; i++) {
			const entry = parsed[i];
			const locale = entry.info.locale;
			const translations = this._translations[locale];
			if (!translations) continue;
			const messages = entry.messages;

			for (const key in messages) {
				delete translations[key];
			}

			if (Object.keys(translations).length === 0) {
				delete this._translations[locale];
				delete this._availableLangs[getLang(locale)];
			}

			this.fire('data:remove', locale, messages);
		}
	}

	destroy() {
		this._translations = null;
		this._availableLangs = null;
		this._assets = null;
		this._parser = null;
		this.off();
	}

	_findFallbackLocale(locale, lang) {
		let result = DEFAULT_LOCALE_FALLBACKS[locale];

		if (result && this._translations[result]) {
			return result;
		}

		result = DEFAULT_LOCALE_FALLBACKS[lang];

		if (result && this._translations[result]) {
			return result;
		}

		result = this._availableLangs[lang];

		if (result && this._translations[result]) {
			return result;
		}

		return DEFAULT_LOCALE;
	}

	_onAssetAdd(asset) {
		asset.on('load', this._onAssetLoad, this);
		asset.on('change', this._onAssetChange, this);
		asset.on('remove', this._onAssetRemove, this);
		asset.on('unload', this._onAssetUnload, this);

		if (asset.resource) {
			this._onAssetLoad(asset);
		}
	}

	_onAssetLoad(asset) {
		this.addData(asset.resource);
	}

	_onAssetChange(asset) {
		if (asset.resource) {
			this.addData(asset.resource);
		}
	}

	_onAssetRemove(asset) {
		asset.off('load', this._onAssetLoad, this);
		asset.off('change', this._onAssetChange, this);
		asset.off('remove', this._onAssetRemove, this);
		asset.off('unload', this._onAssetUnload, this);

		if (asset.resource) {
			this.removeData(asset.resource);
		}

		this._app.assets.once('add:' + asset.id, this._onAssetAdd, this);
	}

	_onAssetUnload(asset) {
		if (asset.resource) {
			this.removeData(asset.resource);
		}
	}

}

const FILLMODE_NONE = 'NONE';
const FILLMODE_FILL_WINDOW = 'FILL_WINDOW';
const FILLMODE_KEEP_ASPECT = 'KEEP_ASPECT';
const RESOLUTION_AUTO = 'AUTO';
const RESOLUTION_FIXED = 'FIXED';

class VrDisplay extends EventHandler {
	constructor(app, display) {
		super();
		this.id = void 0;
		this.display = void 0;
		this.presenting = false;
		this._app = app;
		this._device = app.graphicsDevice;
		this.id = display.displayId;
		this._frameData = null;

		if (window.VRFrameData) {
			this._frameData = new window.VRFrameData();
		}

		this.display = display;
		this._camera = null;
		this.sitToStandInv = new Mat4();
		this.leftView = new Mat4();
		this.leftProj = new Mat4();
		this.leftViewInv = new Mat4();
		this.leftPos = new Vec3();
		this.rightView = new Mat4();
		this.rightProj = new Mat4();
		this.rightViewInv = new Mat4();
		this.rightPos = new Vec3();
		this.combinedPos = new Vec3();
		this.combinedView = new Mat4();
		this.combinedProj = new Mat4();
		this.combinedViewInv = new Mat4();
		this.combinedFov = 0;
		this.combinedAspect = 0;

		this._presentChange = event => {
			let display;

			if (event.display) {
				display = event.display;
			} else if (event.detail && event.detail.display) {
				display = event.detail.display;
			} else if (event.detail && event.detail.vrdisplay) {
				display = event.detail.vrdisplay;
			} else {
				display = this.display;
			}

			if (display === this.display) {
				this.presenting = this.display && this.display.isPresenting;

				if (this.presenting) {
					const leftEye = this.display.getEyeParameters("left");
					const rightEye = this.display.getEyeParameters("right");
					const w = Math.max(leftEye.renderWidth, rightEye.renderWidth) * 2;
					const h = Math.max(leftEye.renderHeight, rightEye.renderHeight);

					this._app.graphicsDevice.setResolution(w, h);

					this._app._allowResize = false;
				} else {
					this._app.setCanvasResolution(RESOLUTION_AUTO);

					this._app._allowResize = true;
				}

				this.fire('beforepresentchange', this);
				this.fire('presentchange', this);
			}
		};

		window.addEventListener('vrdisplaypresentchange', this._presentChange, false);
	}

	destroy() {
		window.removeEventListener('vrdisplaypresentchange', this._presentChange);
		if (this._camera) this._camera.vrDisplay = null;
		this._camera = null;
	}

	poll() {
		if (this.display) {
			this.display.getFrameData(this._frameData);
			this.leftProj.data = this._frameData.leftProjectionMatrix;
			this.rightProj.data = this._frameData.rightProjectionMatrix;
			const stage = this.display.stageParameters;

			if (stage) {
				this.sitToStandInv.set(stage.sittingToStandingTransform).invert();
				this.combinedView.set(this._frameData.leftViewMatrix);
				this.leftView.mul2(this.combinedView, this.sitToStandInv);
				this.combinedView.set(this._frameData.rightViewMatrix);
				this.rightView.mul2(this.combinedView, this.sitToStandInv);
			} else {
				this.leftView.set(this._frameData.leftViewMatrix);
				this.rightView.set(this._frameData.rightViewMatrix);
			}

			let nx = this.leftProj.data[3] + this.leftProj.data[0];
			let nz = this.leftProj.data[11] + this.leftProj.data[8];
			let l = 1.0 / Math.sqrt(nx * nx + nz * nz);
			nx *= l;
			nz *= l;
			let maxFov = -Math.atan2(nz, nx);
			nx = this.rightProj.data[3] + this.rightProj.data[0];
			nz = this.rightProj.data[11] + this.rightProj.data[8];
			l = 1.0 / Math.sqrt(nx * nx + nz * nz);
			nx *= l;
			nz *= l;
			maxFov = Math.max(maxFov, -Math.atan2(nz, nx));
			maxFov *= 2.0;
			this.combinedFov = maxFov;
			const aspect = this.rightProj.data[5] / this.rightProj.data[0];
			this.combinedAspect = aspect;
			const view = this.combinedView;
			view.copy(this.leftView);
			view.invert();
			this.leftViewInv.copy(view);
			const pos = this.combinedPos;
			pos.x = this.leftPos.x = view.data[12];
			pos.y = this.leftPos.y = view.data[13];
			pos.z = this.leftPos.z = view.data[14];
			view.copy(this.rightView);
			view.invert();
			this.rightViewInv.copy(view);
			const deltaX = pos.x - view.data[12];
			const deltaY = pos.y - view.data[13];
			const deltaZ = pos.z - view.data[14];
			const dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ);
			this.rightPos.x = view.data[12];
			this.rightPos.y = view.data[13];
			this.rightPos.z = view.data[14];
			pos.x += view.data[12];
			pos.y += view.data[13];
			pos.z += view.data[14];
			pos.x *= 0.5;
			pos.y *= 0.5;
			pos.z *= 0.5;
			const b = Math.PI * 0.5;
			const c = maxFov * 0.5;
			const a = Math.PI - (b + c);
			const offset = dist * 0.5 * Math.sin(a);
			const fwdX = view.data[8];
			const fwdY = view.data[9];
			const fwdZ = view.data[10];
			view.data[12] = pos.x + fwdX * offset;
			view.data[13] = pos.y + fwdY * offset;
			view.data[14] = pos.z + fwdZ * offset;
			this.combinedViewInv.copy(view);
			view.invert();
			this.combinedProj.setPerspective(maxFov * math.RAD_TO_DEG, aspect, this.display.depthNear + offset, this.display.depthFar + offset, true);
		}
	}

	requestPresent(callback) {
		if (!this.display) {
			if (callback) callback(new Error("No VrDisplay to requestPresent"));
			return;
		}

		if (this.presenting) {
			if (callback) callback(new Error("VrDisplay already presenting"));
			return;
		}

		this.display.requestPresent([{
			source: this._device.canvas
		}]).then(function () {
			if (callback) callback();
		}, function (err) {
			if (callback) callback(err);
		});
	}

	exitPresent(callback) {
		if (!this.display) {
			if (callback) callback(new Error("No VrDisplay to exitPresent"));
		}

		if (!this.presenting) {
			if (callback) callback(new Error("VrDisplay not presenting"));
			return;
		}

		this.display.exitPresent().then(function () {
			if (callback) callback();
		}, function () {
			if (callback) callback(new Error("exitPresent failed"));
		});
	}

	requestAnimationFrame(fn) {
		if (this.display) this.display.requestAnimationFrame(fn);
	}

	submitFrame() {
		if (this.display) this.display.submitFrame();
	}

	reset() {
		if (this.display) this.display.resetPose();
	}

	setClipPlanes(n, f) {
		if (this.display) {
			this.display.depthNear = n;
			this.display.depthFar = f;
		}
	}

	getFrameData() {
		if (this.display) return this._frameData;
	}

	get capabilities() {
		if (this.display) return this.display.capabilities;
		return {};
	}

}

class VrManager extends EventHandler {
	constructor(app) {
		super();
		this.displays = [];
		this.display = null;
		this.isSupported = void 0;
		this._index = {};
		this._app = app;
		this.isSupported = VrManager.isSupported;
		this._onDisplayConnect = this._onDisplayConnect.bind(this);
		this._onDisplayDisconnect = this._onDisplayDisconnect.bind(this);

		this._attach();

		this._getDisplays((err, displays) => {
			if (err) {
				this.fire('error', err);
			} else {
				for (let i = 0; i < displays.length; i++) {
					this._addDisplay(displays[i]);
				}

				this.fire('ready', this.displays);
			}
		});
	}

	_attach() {
		window.addEventListener('vrdisplayconnect', this._onDisplayConnect);
		window.addEventListener('vrdisplaydisconnect', this._onDisplayDisconnect);
	}

	_detach() {
		window.removeEventListener('vrdisplayconnect', this._onDisplayConnect);
		window.removeEventListener('vrdisplaydisconnect', this._onDisplayDisconnect);
	}

	destroy() {
		this._detach();
	}

	poll() {
		const l = this.displays.length;
		if (!l) return;

		for (let i = 0; i < l; i++) {
			if (this.displays[i]._camera) this.displays[i].poll();
		}
	}

	_getDisplays(callback) {
		if (navigator.getVRDisplays) {
			navigator.getVRDisplays().then(function (displays) {
				if (callback) callback(null, displays);
			});
		} else {
			if (callback) callback(new Error('WebVR not supported'));
		}
	}

	_addDisplay(vrDisplay) {
		if (this._index[vrDisplay.displayId]) return;
		const display = new VrDisplay(this._app, vrDisplay);
		this._index[display.id] = display;
		this.displays.push(display);
		if (!this.display) this.display = display;
		this.fire('displayconnect', display);
	}

	_onDisplayConnect(e) {
		if (e.detail && e.detail.display) {
			this._addDisplay(e.detail.display);
		} else {
			this._addDisplay(e.display);
		}
	}

	_onDisplayDisconnect(e) {
		let id;

		if (e.detail && e.detail.display) {
			id = e.detail.display.displayId;
		} else {
			id = e.display.displayId;
		}

		const display = this._index[id];
		if (!display) return;
		display.destroy();
		delete this._index[display.id];
		const ind = this.displays.indexOf(display);
		this.displays.splice(ind, 1);

		if (this.display === display) {
			if (this.displays.length) {
				this.display = this.displays[0];
			} else {
				this.display = null;
			}
		}

		this.fire('displaydisconnect', display);
	}

}

VrManager.isSupported = typeof navigator !== 'undefined' ? !!navigator.getVRDisplays : false;

const XRTYPE_INLINE = 'inline';
const XRTYPE_VR = 'immersive-vr';
const XRTYPE_AR = 'immersive-ar';
const XRSPACE_VIEWER = 'viewer';
const XRSPACE_LOCAL = 'local';
const XRSPACE_LOCALFLOOR = 'local-floor';
const XRSPACE_BOUNDEDFLOOR = 'bounded-floor';
const XRSPACE_UNBOUNDED = 'unbounded';
const XRTARGETRAY_GAZE = 'gaze';
const XRTARGETRAY_SCREEN = 'screen';
const XRTARGETRAY_POINTER = 'tracked-pointer';
const XRHAND_NONE = 'none';
const XRHAND_LEFT = 'left';
const XRHAND_RIGHT = 'right';
const XRTRACKABLE_POINT = 'point';
const XRTRACKABLE_PLANE = 'plane';
const XRTRACKABLE_MESH = 'mesh';
const XRDEPTHSENSINGUSAGE_CPU = 'cpu-optimized';
const XRDEPTHSENSINGUSAGE_GPU = 'gpu-optimized';
const XRDEPTHSENSINGFORMAT_L8A8 = 'luminance-alpha';
const XRDEPTHSENSINGFORMAT_F32 = 'float32';

const poolVec3 = [];
const poolQuat = [];

class XrHitTestSource extends EventHandler {
	constructor(manager, xrHitTestSource, transient) {
		super();
		this.manager = void 0;
		this._xrHitTestSource = void 0;
		this._transient = void 0;
		this.manager = manager;
		this._xrHitTestSource = xrHitTestSource;
		this._transient = transient;
	}

	remove() {
		if (!this._xrHitTestSource) return;
		const sources = this.manager.hitTest.sources;
		const ind = sources.indexOf(this);
		if (ind !== -1) sources.splice(ind, 1);
		this.onStop();
	}

	onStop() {
		this._xrHitTestSource.cancel();

		this._xrHitTestSource = null;
		this.fire('remove');
		this.manager.hitTest.fire('remove', this);
	}

	update(frame) {
		if (this._transient) {
			const transientResults = frame.getHitTestResultsForTransientInput(this._xrHitTestSource);

			for (let i = 0; i < transientResults.length; i++) {
				const transientResult = transientResults[i];
				let inputSource;
				if (transientResult.inputSource) inputSource = this.manager.input._getByInputSource(transientResult.inputSource);
				this.updateHitResults(transientResult.results, inputSource);
			}
		} else {
			this.updateHitResults(frame.getHitTestResults(this._xrHitTestSource));
		}
	}

	updateHitResults(results, inputSource) {
		for (let i = 0; i < results.length; i++) {
			const pose = results[i].getPose(this.manager._referenceSpace);
			let position = poolVec3.pop();
			if (!position) position = new Vec3();
			position.copy(pose.transform.position);
			let rotation = poolQuat.pop();
			if (!rotation) rotation = new Quat();
			rotation.copy(pose.transform.orientation);
			this.fire('result', position, rotation, inputSource);
			this.manager.hitTest.fire('result', this, position, rotation, inputSource);
			poolVec3.push(position);
			poolQuat.push(rotation);
		}
	}

}

class XrHitTest extends EventHandler {
	constructor(manager) {
		super();
		this.manager = void 0;
		this._supported = platform.browser && !!(window.XRSession && window.XRSession.prototype.requestHitTestSource);
		this._session = null;
		this.sources = [];
		this.manager = manager;

		if (this._supported) {
			this.manager.on('start', this._onSessionStart, this);
			this.manager.on('end', this._onSessionEnd, this);
		}
	}

	_onSessionStart() {
		if (this.manager.type !== XRTYPE_AR) return;
		this._session = this.manager.session;
	}

	_onSessionEnd() {
		if (!this._session) return;
		this._session = null;

		for (let i = 0; i < this.sources.length; i++) {
			this.sources[i].onStop();
		}

		this.sources = [];
	}

	isAvailable(callback, fireError) {
		let err;
		if (!this._supported) err = new Error('XR HitTest is not supported');
		if (!this._session) err = new Error('XR Session is not started (1)');
		if (this.manager.type !== XRTYPE_AR) err = new Error('XR HitTest is available only for AR');

		if (err) {
			if (callback) callback(err);
			if (fireError) fireError.fire('error', err);
			return false;
		}

		return true;
	}

	start(options = {}) {
		if (!this.isAvailable(options.callback, this)) return;
		if (!options.profile && !options.spaceType) options.spaceType = XRSPACE_VIEWER;
		let xrRay;
		const offsetRay = options.offsetRay;
		if (offsetRay) xrRay = new XRRay(new DOMPoint(offsetRay.origin.x, offsetRay.origin.y, offsetRay.origin.z), new DOMPoint(offsetRay.direction.x, offsetRay.direction.y, offsetRay.direction.z));
		const callback = options.callback;

		if (options.spaceType) {
			this._session.requestReferenceSpace(options.spaceType).then(referenceSpace => {
				if (!this._session) {
					const err = new Error('XR Session is not started (2)');
					if (callback) callback(err);
					this.fire('error', err);
					return;
				}

				this._session.requestHitTestSource({
					space: referenceSpace,
					entityTypes: options.entityTypes || undefined,
					offsetRay: xrRay
				}).then(xrHitTestSource => {
					this._onHitTestSource(xrHitTestSource, false, callback);
				}).catch(ex => {
					if (callback) callback(ex);
					this.fire('error', ex);
				});
			}).catch(ex => {
				if (callback) callback(ex);
				this.fire('error', ex);
			});
		} else {
			this._session.requestHitTestSourceForTransientInput({
				profile: options.profile,
				entityTypes: options.entityTypes || undefined,
				offsetRay: xrRay
			}).then(xrHitTestSource => {
				this._onHitTestSource(xrHitTestSource, true, callback);
			}).catch(ex => {
				if (callback) callback(ex);
				this.fire('error', ex);
			});
		}
	}

	_onHitTestSource(xrHitTestSource, transient, callback) {
		if (!this._session) {
			xrHitTestSource.cancel();
			const err = new Error('XR Session is not started (3)');
			if (callback) callback(err);
			this.fire('error', err);
			return;
		}

		const hitTestSource = new XrHitTestSource(this.manager, xrHitTestSource, transient);
		this.sources.push(hitTestSource);
		if (callback) callback(null, hitTestSource);
		this.fire('add', hitTestSource);
	}

	update(frame) {
		for (let i = 0; i < this.sources.length; i++) {
			this.sources[i].update(frame);
		}
	}

	get supported() {
		return this._supported;
	}

}

class XrFinger {
	constructor(index, hand) {
		this._index = void 0;
		this._hand = void 0;
		this._joints = [];
		this._tip = null;
		this._index = index;
		this._hand = hand;

		this._hand._fingers.push(this);
	}

	get index() {
		return this._index;
	}

	get hand() {
		return this._hand;
	}

	get joints() {
		return this._joints;
	}

	get tip() {
		return this._tip;
	}

}

const tipJointIds = platform.browser && window.XRHand ? ['thumb-tip', 'index-finger-tip', 'middle-finger-tip', 'ring-finger-tip', 'pinky-finger-tip'] : [];
const tipJointIdsIndex = {};

for (let i = 0; i < tipJointIds.length; i++) {
	tipJointIdsIndex[tipJointIds[i]] = true;
}

class XrJoint {
	constructor(index, id, hand, finger = null) {
		this._index = void 0;
		this._id = void 0;
		this._hand = void 0;
		this._finger = void 0;
		this._wrist = void 0;
		this._tip = void 0;
		this._radius = null;
		this._localTransform = new Mat4();
		this._worldTransform = new Mat4();
		this._localPosition = new Vec3();
		this._localRotation = new Quat();
		this._position = new Vec3();
		this._rotation = new Quat();
		this._dirtyLocal = true;
		this._index = index;
		this._id = id;
		this._hand = hand;
		this._finger = finger;
		this._wrist = id === 'wrist';
		this._tip = this._finger && !!tipJointIdsIndex[id];
	}

	update(pose) {
		this._dirtyLocal = true;
		this._radius = pose.radius;

		this._localPosition.copy(pose.transform.position);

		this._localRotation.copy(pose.transform.orientation);
	}

	_updateTransforms() {
		if (this._dirtyLocal) {
			this._dirtyLocal = false;

			this._localTransform.setTRS(this._localPosition, this._localRotation, Vec3.ONE);
		}

		const manager = this._hand._manager;
		const parent = manager.camera.parent;

		if (parent) {
			this._worldTransform.mul2(parent.getWorldTransform(), this._localTransform);
		} else {
			this._worldTransform.copy(this._localTransform);
		}
	}

	getPosition() {
		this._updateTransforms();

		this._worldTransform.getTranslation(this._position);

		return this._position;
	}

	getRotation() {
		this._updateTransforms();

		this._rotation.setFromMat4(this._worldTransform);

		return this._rotation;
	}

	get index() {
		return this._index;
	}

	get hand() {
		return this._hand;
	}

	get finger() {
		return this._finger;
	}

	get wrist() {
		return this._wrist;
	}

	get tip() {
		return this._tip;
	}

	get radius() {
		return this._radius || 0.005;
	}

}

let fingerJointIds = [];
const vecA$2 = new Vec3();
const vecB$2 = new Vec3();
const vecC = new Vec3();

if (platform.browser && window.XRHand) {
	fingerJointIds = [['thumb-metacarpal', 'thumb-phalanx-proximal', 'thumb-phalanx-distal', 'thumb-tip'], ['index-finger-metacarpal', 'index-finger-phalanx-proximal', 'index-finger-phalanx-intermediate', 'index-finger-phalanx-distal', 'index-finger-tip'], ['middle-finger-metacarpal', 'middle-finger-phalanx-proximal', 'middle-finger-phalanx-intermediate', 'middle-finger-phalanx-distal', 'middle-finger-tip'], ['ring-finger-metacarpal', 'ring-finger-phalanx-proximal', 'ring-finger-phalanx-intermediate', 'ring-finger-phalanx-distal', 'ring-finger-tip'], ['pinky-finger-metacarpal', 'pinky-finger-phalanx-proximal', 'pinky-finger-phalanx-intermediate', 'pinky-finger-phalanx-distal', 'pinky-finger-tip']];
}

class XrHand extends EventHandler {
	constructor(inputSource) {
		super();
		this._manager = void 0;
		this._inputSource = void 0;
		this._tracking = false;
		this._fingers = [];
		this._joints = [];
		this._jointsById = {};
		this._tips = [];
		this._wrist = null;
		const xrHand = inputSource._xrInputSource.hand;
		this._manager = inputSource._manager;
		this._inputSource = inputSource;

		if (xrHand.get('wrist')) {
			const joint = new XrJoint(0, 'wrist', this, null);
			this._wrist = joint;

			this._joints.push(joint);

			this._jointsById.wrist = joint;
		}

		for (let f = 0; f < fingerJointIds.length; f++) {
			const finger = new XrFinger(f, this);

			for (let j = 0; j < fingerJointIds[f].length; j++) {
				const jointId = fingerJointIds[f][j];
				if (!xrHand.get(jointId)) continue;
				const joint = new XrJoint(j, jointId, this, finger);

				this._joints.push(joint);

				this._jointsById[jointId] = joint;

				if (joint.tip) {
					this._tips.push(joint);

					finger._tip = joint;
				}

				finger._joints.push(joint);
			}
		}
	}

	update(frame) {
		const xrInputSource = this._inputSource._xrInputSource;

		for (let j = 0; j < this._joints.length; j++) {
			const joint = this._joints[j];
			const jointSpace = xrInputSource.hand.get(joint._id);

			if (jointSpace) {
				let pose;
				if (frame.session.visibilityState !== 'hidden') pose = frame.getJointPose(jointSpace, this._manager._referenceSpace);

				if (pose) {
					joint.update(pose);

					if (joint.wrist && !this._tracking) {
						this._tracking = true;
						this.fire('tracking');
					}
				} else if (joint.wrist) {
					if (this._tracking) {
						this._tracking = false;
						this.fire('trackinglost');
					}

					break;
				}
			}
		}

		const j1 = this._jointsById['thumb-metacarpal'];
		const j4 = this._jointsById['thumb-tip'];
		const j6 = this._jointsById['index-finger-phalanx-proximal'];
		const j9 = this._jointsById['index-finger-tip'];
		const j16 = this._jointsById['ring-finger-phalanx-proximal'];
		const j21 = this._jointsById['pinky-finger-phalanx-proximal'];

		if (j1 && j4 && j6 && j9 && j16 && j21) {
			this._inputSource._dirtyRay = true;

			this._inputSource._rayLocal.origin.lerp(j4._localPosition, j9._localPosition, 0.5);

			let jointL = j1;
			let jointR = j21;

			if (this._inputSource.handedness === XRHAND_LEFT) {
				const t = jointL;
				jointL = jointR;
				jointR = t;
			}

			vecA$2.sub2(jointL._localPosition, this._wrist._localPosition);
			vecB$2.sub2(jointR._localPosition, this._wrist._localPosition);
			vecC.cross(vecA$2, vecB$2).normalize();
			vecA$2.lerp(j6._localPosition, j16._localPosition, 0.5);
			vecA$2.sub(this._wrist._localPosition).normalize();

			this._inputSource._rayLocal.direction.lerp(vecC, vecA$2, 0.5).normalize();
		}

		const squeezing = this._fingerIsClosed(1) && this._fingerIsClosed(2) && this._fingerIsClosed(3) && this._fingerIsClosed(4);

		if (squeezing) {
			if (!this._inputSource._squeezing) {
				this._inputSource._squeezing = true;

				this._inputSource.fire('squeezestart');

				this._manager.input.fire('squeezestart', this._inputSource);
			}
		} else {
			if (this._inputSource._squeezing) {
				this._inputSource._squeezing = false;

				this._inputSource.fire('squeeze');

				this._manager.input.fire('squeeze', this._inputSource);

				this._inputSource.fire('squeezeend');

				this._manager.input.fire('squeezeend', this._inputSource);
			}
		}
	}

	_fingerIsClosed(index) {
		const finger = this._fingers[index];
		vecA$2.sub2(finger.joints[0]._localPosition, finger.joints[1]._localPosition).normalize();
		vecB$2.sub2(finger.joints[2]._localPosition, finger.joints[3]._localPosition).normalize();
		return vecA$2.dot(vecB$2) < -0.8;
	}

	getJointById(id) {
		return this._jointsById[id] || null;
	}

	get fingers() {
		return this._fingers;
	}

	get joints() {
		return this._joints;
	}

	get tips() {
		return this._tips;
	}

	get wrist() {
		return this._wrist;
	}

	get tracking() {
		return this._tracking;
	}

}

const quat$1 = new Quat();
let ids$1 = 0;

class XrInputSource extends EventHandler {
	constructor(manager, xrInputSource) {
		super();
		this._id = void 0;
		this._manager = void 0;
		this._xrInputSource = void 0;
		this._ray = new Ray();
		this._rayLocal = new Ray();
		this._grip = false;
		this._hand = null;
		this._localTransform = null;
		this._worldTransform = null;
		this._position = new Vec3();
		this._rotation = new Quat();
		this._localPosition = null;
		this._localRotation = null;
		this._dirtyLocal = true;
		this._dirtyRay = false;
		this._selecting = false;
		this._squeezing = false;
		this._elementInput = true;
		this._elementEntity = null;
		this._hitTestSources = [];
		this._id = ++ids$1;
		this._manager = manager;
		this._xrInputSource = xrInputSource;
		if (xrInputSource.hand) this._hand = new XrHand(this);
	}

	get id() {
		return this._id;
	}

	get inputSource() {
		return this._xrInputSource;
	}

	get targetRayMode() {
		return this._xrInputSource.targetRayMode;
	}

	get handedness() {
		return this._xrInputSource.handedness;
	}

	get profiles() {
		return this._xrInputSource.profiles;
	}

	get grip() {
		return this._grip;
	}

	get hand() {
		return this._hand;
	}

	get gamepad() {
		return this._xrInputSource.gamepad || null;
	}

	get selecting() {
		return this._selecting;
	}

	get squeezing() {
		return this._squeezing;
	}

	set elementInput(value) {
		if (this._elementInput === value) return;
		this._elementInput = value;
		if (!this._elementInput) this._elementEntity = null;
	}

	get elementInput() {
		return this._elementInput;
	}

	get elementEntity() {
		return this._elementEntity;
	}

	get hitTestSources() {
		return this._hitTestSources;
	}

	update(frame) {
		if (this._hand) {
			this._hand.update(frame);
		} else {
			if (this._xrInputSource.gripSpace) {
				const gripPose = frame.getPose(this._xrInputSource.gripSpace, this._manager._referenceSpace);

				if (gripPose) {
					if (!this._grip) {
						this._grip = true;
						this._localTransform = new Mat4();
						this._worldTransform = new Mat4();
						this._localPosition = new Vec3();
						this._localRotation = new Quat();
					}

					this._dirtyLocal = true;

					this._localPosition.copy(gripPose.transform.position);

					this._localRotation.copy(gripPose.transform.orientation);
				}
			}

			const targetRayPose = frame.getPose(this._xrInputSource.targetRaySpace, this._manager._referenceSpace);

			if (targetRayPose) {
				this._dirtyRay = true;

				this._rayLocal.origin.copy(targetRayPose.transform.position);

				this._rayLocal.direction.set(0, 0, -1);

				quat$1.copy(targetRayPose.transform.orientation);
				quat$1.transformVector(this._rayLocal.direction, this._rayLocal.direction);
			}
		}
	}

	_updateTransforms() {
		if (this._dirtyLocal) {
			this._dirtyLocal = false;

			this._localTransform.setTRS(this._localPosition, this._localRotation, Vec3.ONE);
		}

		const parent = this._manager.camera.parent;

		if (parent) {
			this._worldTransform.mul2(parent.getWorldTransform(), this._localTransform);
		} else {
			this._worldTransform.copy(this._localTransform);
		}
	}

	_updateRayTransforms() {
		const dirty = this._dirtyRay;
		this._dirtyRay = false;
		const parent = this._manager.camera.parent;

		if (parent) {
			const parentTransform = this._manager.camera.parent.getWorldTransform();

			parentTransform.getTranslation(this._position);

			this._rotation.setFromMat4(parentTransform);

			this._rotation.transformVector(this._rayLocal.origin, this._ray.origin);

			this._ray.origin.add(this._position);

			this._rotation.transformVector(this._rayLocal.direction, this._ray.direction);
		} else if (dirty) {
			this._ray.origin.copy(this._rayLocal.origin);

			this._ray.direction.copy(this._rayLocal.direction);
		}
	}

	getPosition() {
		if (!this._position) return null;

		this._updateTransforms();

		this._worldTransform.getTranslation(this._position);

		return this._position;
	}

	getLocalPosition() {
		return this._localPosition;
	}

	getRotation() {
		if (!this._rotation) return null;

		this._updateTransforms();

		this._rotation.setFromMat4(this._worldTransform);

		return this._rotation;
	}

	getLocalRotation() {
		return this._localRotation;
	}

	getOrigin() {
		this._updateRayTransforms();

		return this._ray.origin;
	}

	getDirection() {
		this._updateRayTransforms();

		return this._ray.direction;
	}

	hitTestStart(options = {}) {
		options.profile = this._xrInputSource.profiles[0];
		const callback = options.callback;

		options.callback = (err, hitTestSource) => {
			if (hitTestSource) this.onHitTestSourceAdd(hitTestSource);
			if (callback) callback(err, hitTestSource);
		};

		this._manager.hitTest.start(options);
	}

	onHitTestSourceAdd(hitTestSource) {
		this._hitTestSources.push(hitTestSource);

		this.fire('hittest:add', hitTestSource);
		hitTestSource.on('result', function (position, rotation, inputSource) {
			if (inputSource !== this) return;
			this.fire('hittest:result', hitTestSource, position, rotation);
		}, this);
		hitTestSource.once('remove', function () {
			this.onHitTestSourceRemove(hitTestSource);
			this.fire('hittest:remove', hitTestSource);
		}, this);
	}

	onHitTestSourceRemove(hitTestSource) {
		const ind = this._hitTestSources.indexOf(hitTestSource);

		if (ind !== -1) this._hitTestSources.splice(ind, 1);
	}

}

class XrInput extends EventHandler {
	constructor(manager) {
		super();
		this.manager = void 0;
		this._inputSources = [];
		this._onInputSourcesChangeEvt = void 0;
		this.manager = manager;

		this._onInputSourcesChangeEvt = evt => {
			this._onInputSourcesChange(evt);
		};

		this.manager.on('start', this._onSessionStart, this);
		this.manager.on('end', this._onSessionEnd, this);
	}

	_onSessionStart() {
		const session = this.manager.session;
		session.addEventListener('inputsourceschange', this._onInputSourcesChangeEvt);
		session.addEventListener('select', evt => {
			const inputSource = this._getByInputSource(evt.inputSource);

			inputSource.update(evt.frame);
			inputSource.fire('select', evt);
			this.fire('select', inputSource, evt);
		});
		session.addEventListener('selectstart', evt => {
			const inputSource = this._getByInputSource(evt.inputSource);

			inputSource.update(evt.frame);
			inputSource._selecting = true;
			inputSource.fire('selectstart', evt);
			this.fire('selectstart', inputSource, evt);
		});
		session.addEventListener('selectend', evt => {
			const inputSource = this._getByInputSource(evt.inputSource);

			inputSource.update(evt.frame);
			inputSource._selecting = false;
			inputSource.fire('selectend', evt);
			this.fire('selectend', inputSource, evt);
		});
		session.addEventListener('squeeze', evt => {
			const inputSource = this._getByInputSource(evt.inputSource);

			inputSource.update(evt.frame);
			inputSource.fire('squeeze', evt);
			this.fire('squeeze', inputSource, evt);
		});
		session.addEventListener('squeezestart', evt => {
			const inputSource = this._getByInputSource(evt.inputSource);

			inputSource.update(evt.frame);
			inputSource._squeezing = true;
			inputSource.fire('squeezestart', evt);
			this.fire('squeezestart', inputSource, evt);
		});
		session.addEventListener('squeezeend', evt => {
			const inputSource = this._getByInputSource(evt.inputSource);

			inputSource.update(evt.frame);
			inputSource._squeezing = false;
			inputSource.fire('squeezeend', evt);
			this.fire('squeezeend', inputSource, evt);
		});
		const inputSources = session.inputSources;

		for (let i = 0; i < inputSources.length; i++) {
			this._addInputSource(inputSources[i]);
		}
	}

	_onSessionEnd() {
		let i = this._inputSources.length;

		while (i--) {
			const inputSource = this._inputSources[i];

			this._inputSources.splice(i, 1);

			inputSource.fire('remove');
			this.fire('remove', inputSource);
		}

		const session = this.manager.session;
		session.removeEventListener('inputsourceschange', this._onInputSourcesChangeEvt);
	}

	_onInputSourcesChange(evt) {
		for (let i = 0; i < evt.removed.length; i++) {
			this._removeInputSource(evt.removed[i]);
		}

		for (let i = 0; i < evt.added.length; i++) {
			this._addInputSource(evt.added[i]);
		}
	}

	_getByInputSource(xrInputSource) {
		for (let i = 0; i < this._inputSources.length; i++) {
			if (this._inputSources[i].inputSource === xrInputSource) {
				return this._inputSources[i];
			}
		}

		return null;
	}

	_addInputSource(xrInputSource) {
		if (this._getByInputSource(xrInputSource)) return;
		const inputSource = new XrInputSource(this.manager, xrInputSource);

		this._inputSources.push(inputSource);

		this.fire('add', inputSource);
	}

	_removeInputSource(xrInputSource) {
		for (let i = 0; i < this._inputSources.length; i++) {
			if (this._inputSources[i].inputSource !== xrInputSource) continue;
			const inputSource = this._inputSources[i];

			this._inputSources.splice(i, 1);

			let h = inputSource.hitTestSources.length;

			while (h--) {
				inputSource.hitTestSources[h].remove();
			}

			inputSource.fire('remove');
			this.fire('remove', inputSource);
			return;
		}
	}

	update(frame) {
		for (let i = 0; i < this._inputSources.length; i++) {
			this._inputSources[i].update(frame);
		}
	}

	get inputSources() {
		return this._inputSources;
	}

}

const vec3A = new Vec3();
const vec3B = new Vec3();
const mat4A = new Mat4();
const mat4B = new Mat4();

class XrLightEstimation extends EventHandler {
	constructor(manager) {
		super();
		this._manager = void 0;
		this._supported = false;
		this._available = false;
		this._lightProbeRequested = false;
		this._lightProbe = null;
		this._intensity = 0;
		this._rotation = new Quat();
		this._color = new Color();
		this._sphericalHarmonics = new Float32Array(27);
		this._manager = manager;

		this._manager.on('start', this._onSessionStart, this);

		this._manager.on('end', this._onSessionEnd, this);
	}

	_onSessionStart() {
		const supported = !!this._manager.session.requestLightProbe;
		if (!supported) return;
		this._supported = true;
	}

	_onSessionEnd() {
		this._supported = false;
		this._available = false;
		this._lightProbeRequested = false;
		this._lightProbe = null;
	}

	start() {
		let err;
		if (!this._manager.session) err = new Error('XR session is not running');
		if (!err && this._manager.type !== XRTYPE_AR) err = new Error('XR session type is not AR');
		if (!err && !this._supported) err = new Error('light-estimation is not supported');
		if (!err && this._lightProbe || this._lightProbeRequested) err = new Error('light estimation is already requested');

		if (err) {
			this.fire('error', err);
			return;
		}

		this._lightProbeRequested = true;

		this._manager.session.requestLightProbe().then(lightProbe => {
			const wasRequested = this._lightProbeRequested;
			this._lightProbeRequested = false;

			if (this._manager.active) {
				if (wasRequested) {
					this._lightProbe = lightProbe;
				}
			} else {
				this.fire('error', new Error('XR session is not active'));
			}
		}).catch(ex => {
			this._lightProbeRequested = false;
			this.fire('error', ex);
		});
	}

	end() {
		this._lightProbeRequested = false;
		this._lightProbe = null;
		this._available = false;
	}

	update(frame) {
		if (!this._lightProbe) return;
		const lightEstimate = frame.getLightEstimate(this._lightProbe);
		if (!lightEstimate) return;

		if (!this._available) {
			this._available = true;
			this.fire('available');
		}

		const pli = lightEstimate.primaryLightIntensity;
		this._intensity = Math.max(1.0, Math.max(pli.x, Math.max(pli.y, pli.z)));
		vec3A.copy(pli).mulScalar(1 / this._intensity);

		this._color.set(vec3A.x, vec3A.y, vec3A.z);

		vec3A.set(0, 0, 0);
		vec3B.copy(lightEstimate.primaryLightDirection);
		mat4A.setLookAt(vec3B, vec3A, Vec3.UP);
		mat4B.setFromAxisAngle(Vec3.RIGHT, 90);
		mat4A.mul(mat4B);

		this._rotation.setFromMat4(mat4A);

		this._sphericalHarmonics.set(lightEstimate.sphericalHarmonicsCoefficients);
	}

	get supported() {
		return this._supported;
	}

	get available() {
		return this._available;
	}

	get intensity() {
		return this._available ? this._intensity : null;
	}

	get color() {
		return this._available ? this._color : null;
	}

	get rotation() {
		return this._available ? this._rotation : null;
	}

	get sphericalHarmonics() {
		return this._available ? this._sphericalHarmonics : null;
	}

}

class XrTrackedImage extends EventHandler {
	constructor(image, width) {
		super();
		this._image = void 0;
		this._width = void 0;
		this._bitmap = null;
		this._measuredWidth = 0;
		this._trackable = false;
		this._tracking = false;
		this._emulated = false;
		this._pose = null;
		this._position = new Vec3();
		this._rotation = new Quat();
		this._image = image;
		this._width = width;
	}

	get image() {
		return this._image;
	}

	set width(value) {
		this._width = value;
	}

	get width() {
		return this._width;
	}

	get trackable() {
		return this._trackable;
	}

	get tracking() {
		return this._tracking;
	}

	get emulated() {
		return this._emulated;
	}

	prepare() {
		if (this._bitmap) {
			return {
				image: this._bitmap,
				widthInMeters: this._width
			};
		}

		return createImageBitmap(this._image).then(bitmap => {
			this._bitmap = bitmap;
			return {
				image: this._bitmap,
				widthInMeters: this._width
			};
		});
	}

	destroy() {
		this._image = null;
		this._pose = null;

		if (this._bitmap) {
			this._bitmap.close();

			this._bitmap = null;
		}
	}

	getPosition() {
		if (this._pose) this._position.copy(this._pose.transform.position);
		return this._position;
	}

	getRotation() {
		if (this._pose) this._rotation.copy(this._pose.transform.orientation);
		return this._rotation;
	}

}

class XrImageTracking extends EventHandler {
	constructor(manager) {
		super();
		this._manager = void 0;
		this._supported = platform.browser && !!window.XRImageTrackingResult;
		this._available = false;
		this._images = [];
		this._manager = manager;

		if (this._supported) {
			this._manager.on('start', this._onSessionStart, this);

			this._manager.on('end', this._onSessionEnd, this);
		}
	}

	add(image, width) {
		if (!this._supported || this._manager.active) return null;
		const trackedImage = new XrTrackedImage(image, width);

		this._images.push(trackedImage);

		return trackedImage;
	}

	remove(trackedImage) {
		if (this._manager.active) return;

		const ind = this._images.indexOf(trackedImage);

		if (ind !== -1) {
			trackedImage.destroy();

			this._images.splice(ind, 1);
		}
	}

	_onSessionStart() {
		this._manager.session.getTrackedImageScores().then(images => {
			this._available = true;

			for (let i = 0; i < images.length; i++) {
				this._images[i]._trackable = images[i] === 'trackable';
			}
		}).catch(err => {
			this._available = false;
			this.fire('error', err);
		});
	}

	_onSessionEnd() {
		this._available = false;

		for (let i = 0; i < this._images.length; i++) {
			const image = this._images[i];
			image._pose = null;
			image._measuredWidth = 0;

			if (image._tracking) {
				image._tracking = false;
				image.fire('untracked');
			}
		}
	}

	prepareImages(callback) {
		if (this._images.length) {
			Promise.all(this._images.map(function (trackedImage) {
				return trackedImage.prepare();
			})).then(function (bitmaps) {
				callback(null, bitmaps);
			}).catch(function (err) {
				callback(err, null);
			});
		} else {
			callback(null, null);
		}
	}

	update(frame) {
		if (!this._available) return;
		const results = frame.getImageTrackingResults();
		const index = {};

		for (let i = 0; i < results.length; i++) {
			index[results[i].index] = results[i];
			const trackedImage = this._images[results[i].index];
			trackedImage._emulated = results[i].trackingState === 'emulated';
			trackedImage._measuredWidth = results[i].measuredWidthInMeters;
			trackedImage._pose = frame.getPose(results[i].imageSpace, this._manager._referenceSpace);
		}

		for (let i = 0; i < this._images.length; i++) {
			if (this._images[i]._tracking && !index[i]) {
				this._images[i]._tracking = false;

				this._images[i].fire('untracked');
			} else if (!this._images[i]._tracking && index[i]) {
				this._images[i]._tracking = true;

				this._images[i].fire('tracked');
			}
		}
	}

	get supported() {
		return this._supported;
	}

	get available() {
		return this._available;
	}

	get images() {
		return this._images;
	}

}

class XrDomOverlay {
	constructor(manager) {
		this._manager = void 0;
		this._supported = platform.browser && !!window.XRDOMOverlayState;
		this._root = null;
		this._manager = manager;
	}

	get supported() {
		return this._supported;
	}

	get available() {
		return this._supported && this._manager.active && this._manager._session.domOverlayState !== null;
	}

	get state() {
		if (!this._supported || !this._manager.active || !this._manager._session.domOverlayState) return null;
		return this._manager._session.domOverlayState.type;
	}

	set root(value) {
		if (!this._supported || this._manager.active) return;
		this._root = value;
	}

	get root() {
		return this._root;
	}

}

class XrDepthSensing extends EventHandler {
	constructor(manager) {
		super();
		this._manager = void 0;
		this._available = false;
		this._depthInfoCpu = null;
		this._depthInfoGpu = null;
		this._usage = null;
		this._dataFormat = null;
		this._matrixDirty = false;
		this._matrix = new Mat4();
		this._emptyBuffer = new Uint8Array(32);
		this._depthBuffer = null;
		this._texture = void 0;
		this._manager = manager;
		this._texture = new Texture(this._manager.app.graphicsDevice, {
			format: PIXELFORMAT_L8_A8,
			mipmaps: false,
			addressU: ADDRESS_CLAMP_TO_EDGE,
			addressV: ADDRESS_CLAMP_TO_EDGE,
			minFilter: FILTER_LINEAR,
			magFilter: FILTER_LINEAR
		});

		if (this.supported) {
			this._manager.on('start', this._onSessionStart, this);

			this._manager.on('end', this._onSessionEnd, this);
		}
	}

	_onSessionStart() {
		const session = this._manager.session;

		try {
			this._usage = session.depthUsage;
			this._dataFormat = session.depthDataFormat;
		} catch (ex) {
			this._usage = null;
			this._dataFormat = null;
			this._available = false;
			this.fire('error', ex);
		}
	}

	_onSessionEnd() {
		this._depthInfoCpu = null;
		this._depthInfoGpu = null;
		this._usage = null;
		this._dataFormat = null;

		if (this._available) {
			this._available = false;
			this.fire('unavailable');
		}

		this._depthBuffer = null;
		this._texture._width = 4;
		this._texture._height = 4;
		this._texture._levels[0] = this._emptyBuffer;

		this._texture.upload();
	}

	_updateTexture() {
		const depthInfo = this._depthInfoCpu || this._depthInfoGpu;

		if (depthInfo) {
			let resized = false;

			if (depthInfo.width !== this._texture.width || depthInfo.height !== this._texture.height) {
				this._texture._width = depthInfo.width;
				this._texture._height = depthInfo.height;
				this._matrixDirty = true;
				resized = true;
			}

			if (this._depthInfoCpu) {
				const dataBuffer = this._depthInfoCpu.data;
				this._depthBuffer = new Uint8Array(dataBuffer);
				this._texture._levels[0] = this._depthBuffer;

				this._texture.upload();
			} else if (this._depthInfoGpu) {
				this._texture._levels[0] = this._depthInfoGpu.texture;

				this._texture.upload();
			}

			if (resized) this.fire('resize', depthInfo.width, depthInfo.height);
		} else if (this._depthBuffer) {
			this._depthBuffer = null;
			this._texture._width = 4;
			this._texture._height = 4;
			this._texture._levels[0] = this._emptyBuffer;

			this._texture.upload();
		}
	}

	update(frame, view) {
		if (!this._usage) return;
		let depthInfoCpu = null;
		let depthInfoGpu = null;

		if (this._usage === XRDEPTHSENSINGUSAGE_CPU && view) {
			depthInfoCpu = frame.getDepthInformation(view);
		} else if (this._usage === XRDEPTHSENSINGUSAGE_GPU && view) {
			depthInfoGpu = frame.getDepthInformation(view);
		}

		if (this._depthInfoCpu && !depthInfoCpu || !this._depthInfoCpu && depthInfoCpu || this.depthInfoGpu && !depthInfoGpu || !this._depthInfoGpu && depthInfoGpu) {
			this._matrixDirty = true;
		}

		this._depthInfoCpu = depthInfoCpu;
		this._depthInfoGpu = depthInfoGpu;

		this._updateTexture();

		if (this._matrixDirty) {
			this._matrixDirty = false;
			const depthInfo = this._depthInfoCpu || this._depthInfoGpu;

			if (depthInfo) {
				this._matrix.data.set(depthInfo.normDepthBufferFromNormView.matrix);
			} else {
				this._matrix.setIdentity();
			}
		}

		if ((this._depthInfoCpu || this._depthInfoGpu) && !this._available) {
			this._available = true;
			this.fire('available');
		} else if (!this._depthInfoCpu && !this._depthInfoGpu && this._available) {
			this._available = false;
			this.fire('unavailable');
		}
	}

	getDepth(u, v) {
		if (!this._depthInfoCpu) return null;
		return this._depthInfoCpu.getDepthInMeters(u, v);
	}

	get supported() {
		return platform.browser && !!window.XRDepthInformation;
	}

	get available() {
		return this._available;
	}

	get usage() {
		return this._usage;
	}

	get dataFormat() {
		return this._dataFormat;
	}

	get width() {
		const depthInfo = this._depthInfoCpu || this._depthInfoGpu;
		return depthInfo && depthInfo.width || 0;
	}

	get height() {
		const depthInfo = this._depthInfoCpu || this._depthInfoGpu;
		return depthInfo && depthInfo.height || 0;
	}

	get texture() {
		return this._texture;
	}

	get uvMatrix() {
		return this._matrix;
	}

	get rawValueToMeters() {
		const depthInfo = this._depthInfoCpu || this._depthInfoGpu;
		return depthInfo && depthInfo.rawValueToMeters || 0;
	}

}

let ids = 0;

class XrPlane extends EventHandler {
	constructor(planeDetection, xrPlane) {
		super();
		this._id = void 0;
		this._planeDetection = void 0;
		this._xrPlane = void 0;
		this._lastChangedTime = void 0;
		this._orientation = void 0;
		this._position = new Vec3();
		this._rotation = new Quat();
		this._id = ++ids;
		this._planeDetection = planeDetection;
		this._xrPlane = xrPlane;
		this._lastChangedTime = xrPlane.lastChangedTime;
		this._orientation = xrPlane.orientation;
	}

	destroy() {
		this.fire('remove');
	}

	update(frame) {
		const manager = this._planeDetection._manager;
		const pose = frame.getPose(this._xrPlane.planeSpace, manager._referenceSpace);

		if (pose) {
			this._position.copy(pose.transform.position);

			this._rotation.copy(pose.transform.orientation);
		}

		if (this._lastChangedTime !== this._xrPlane.lastChangedTime) {
			this._lastChangedTime = this._xrPlane.lastChangedTime;
			this.fire('change');
		}
	}

	getPosition() {
		return this._position;
	}

	getRotation() {
		return this._rotation;
	}

	get id() {
		return this._id;
	}

	get orientation() {
		return this._orientation;
	}

	get points() {
		return this._xrPlane.polygon;
	}

}

class XrPlaneDetection extends EventHandler {
	constructor(manager) {
		super();
		this._manager = void 0;
		this._supported = platform.browser && !!window.XRPlane;
		this._available = false;
		this._planesIndex = new Map();
		this._planes = null;
		this._manager = manager;

		if (this._supported) {
			this._manager.on('end', this._onSessionEnd, this);
		}
	}

	_onSessionEnd() {
		if (this._planes) {
			for (let i = 0; i < this._planes.length; i++) {
				this._planes[i].destroy();
			}
		}

		this._planesIndex.clear();

		this._planes = null;

		if (this._available) {
			this._available = false;
			this.fire('unavailable');
		}
	}

	update(frame) {
		let detectedPlanes;

		if (!this._available) {
			try {
				detectedPlanes = frame.detectedPlanes;
				this._planes = [];
				this._available = true;
				this.fire('available');
			} catch (ex) {
				return;
			}
		} else {
			detectedPlanes = frame.detectedPlanes;
		}

		for (const [xrPlane, plane] of this._planesIndex) {
			if (detectedPlanes.has(xrPlane)) continue;

			this._planesIndex.delete(xrPlane);

			this._planes.splice(this._planes.indexOf(plane), 1);

			plane.destroy();
			this.fire('remove', plane);
		}

		for (const xrPlane of detectedPlanes) {
			let plane = this._planesIndex.get(xrPlane);

			if (!plane) {
				plane = new XrPlane(this, xrPlane);

				this._planesIndex.set(xrPlane, plane);

				this._planes.push(plane);

				plane.update(frame);
				this.fire('add', plane);
			} else {
				plane.update(frame);
			}
		}
	}

	get supported() {
		return this._supported;
	}

	get available() {
		return this._available;
	}

	get planes() {
		return this._planes;
	}

}

class XrManager extends EventHandler {
	constructor(app) {
		super();
		this.app = void 0;
		this._supported = platform.browser && !!navigator.xr;
		this._available = {};
		this._type = null;
		this._spaceType = null;
		this._session = null;
		this._baseLayer = null;
		this._referenceSpace = null;
		this.depthSensing = void 0;
		this.domOverlay = void 0;
		this.hitTest = void 0;
		this.imageTracking = void 0;
		this.planeDetection = void 0;
		this.input = void 0;
		this.lightEstimation = void 0;
		this._camera = null;
		this.views = [];
		this.viewsPool = [];
		this._localPosition = new Vec3();
		this._localRotation = new Quat();
		this._depthNear = 0.1;
		this._depthFar = 1000;
		this._width = 0;
		this._height = 0;
		this.app = app;
		this._available[XRTYPE_INLINE] = false;
		this._available[XRTYPE_VR] = false;
		this._available[XRTYPE_AR] = false;
		this.depthSensing = new XrDepthSensing(this);
		this.domOverlay = new XrDomOverlay(this);
		this.hitTest = new XrHitTest(this);
		this.imageTracking = new XrImageTracking(this);
		this.planeDetection = new XrPlaneDetection(this);
		this.input = new XrInput(this);
		this.lightEstimation = new XrLightEstimation(this);

		if (this._supported) {
			navigator.xr.addEventListener('devicechange', () => {
				this._deviceAvailabilityCheck();
			});

			this._deviceAvailabilityCheck();
		}
	}

	start(camera, type, spaceType, options) {
		let callback = options;
		if (typeof options === 'object') callback = options.callback;

		if (!this._available[type]) {
			if (callback) callback(new Error('XR is not available'));
			return;
		}

		if (this._session) {
			if (callback) callback(new Error('XR session is already started'));
			return;
		}

		this._camera = camera;
		this._camera.camera.xr = this;
		this._type = type;
		this._spaceType = spaceType;

		this._setClipPlanes(camera.nearClip, camera.farClip);

		const opts = {
			requiredFeatures: [spaceType],
			optionalFeatures: []
		};

		if (type === XRTYPE_AR) {
			opts.optionalFeatures.push('light-estimation');
			opts.optionalFeatures.push('hit-test');

			if (options) {
				if (options.imageTracking && this.imageTracking.supported) opts.optionalFeatures.push('image-tracking');
				if (options.planeDetection) opts.optionalFeatures.push('plane-detection');
			}

			if (this.domOverlay.supported && this.domOverlay.root) {
				opts.optionalFeatures.push('dom-overlay');
				opts.domOverlay = {
					root: this.domOverlay.root
				};
			}

			if (options && options.depthSensing && this.depthSensing.supported) {
				opts.optionalFeatures.push('depth-sensing');
				const usagePreference = [XRDEPTHSENSINGUSAGE_CPU];
				const dataFormatPreference = [XRDEPTHSENSINGFORMAT_L8A8];

				if (options.depthSensing.usagePreference) {
					const ind = usagePreference.indexOf(options.depthSensing.usagePreference);
					if (ind !== -1) usagePreference.splice(ind, 1);
					usagePreference.unshift(options.depthSensing.usagePreference);
				}

				if (options.depthSensing.dataFormatPreference) {
					const ind = dataFormatPreference.indexOf(options.depthSensing.dataFormatPreference);
					if (ind !== -1) dataFormatPreference.splice(ind, 1);
					dataFormatPreference.unshift(options.depthSensing.dataFormatPreference);
				}

				opts.depthSensing = {
					usagePreference: usagePreference,
					dataFormatPreference: dataFormatPreference
				};
			}
		} else if (type === XRTYPE_VR) {
			opts.optionalFeatures.push('hand-tracking');
		}

		if (options && options.optionalFeatures) opts.optionalFeatures = opts.optionalFeatures.concat(options.optionalFeatures);

		if (this.imageTracking.supported && this.imageTracking.images.length) {
			this.imageTracking.prepareImages((err, trackedImages) => {
				if (err) {
					if (callback) callback(err);
					this.fire('error', err);
					return;
				}

				if (trackedImages !== null) opts.trackedImages = trackedImages;

				this._onStartOptionsReady(type, spaceType, opts, callback);
			});
		} else {
			this._onStartOptionsReady(type, spaceType, opts, callback);
		}
	}

	_onStartOptionsReady(type, spaceType, options, callback) {
		navigator.xr.requestSession(type, options).then(session => {
			this._onSessionStart(session, spaceType, callback);
		}).catch(ex => {
			this._camera.camera.xr = null;
			this._camera = null;
			this._type = null;
			this._spaceType = null;
			if (callback) callback(ex);
			this.fire('error', ex);
		});
	}

	end(callback) {
		if (!this._session) {
			if (callback) callback(new Error('XR Session is not initialized'));
			return;
		}

		if (callback) this.once('end', callback);

		this._session.end();
	}

	isAvailable(type) {
		return this._available[type];
	}

	_deviceAvailabilityCheck() {
		for (const key in this._available) {
			this._sessionSupportCheck(key);
		}
	}

	_sessionSupportCheck(type) {
		navigator.xr.isSessionSupported(type).then(available => {
			if (this._available[type] === available) return;
			this._available[type] = available;
			this.fire('available', type, available);
			this.fire('available:' + type, available);
		}).catch(ex => {
			this.fire('error', ex);
		});
	}

	_onSessionStart(session, spaceType, callback) {
		let failed = false;
		this._session = session;

		const onVisibilityChange = () => {
			this.fire('visibility:change', session.visibilityState);
		};

		const onClipPlanesChange = () => {
			this._setClipPlanes(this._camera.nearClip, this._camera.farClip);
		};

		const onEnd = () => {
			this._session = null;
			this._referenceSpace = null;
			this.views = [];
			this._width = 0;
			this._height = 0;
			this._type = null;
			this._spaceType = null;

			if (this._camera) {
				this._camera.off('set_nearClip', onClipPlanesChange);

				this._camera.off('set_farClip', onClipPlanesChange);

				this._camera.camera.xr = null;
				this._camera = null;
			}

			session.removeEventListener('end', onEnd);
			session.removeEventListener('visibilitychange', onVisibilityChange);
			if (!failed) this.fire('end');
			this.app.tick();
		};

		session.addEventListener('end', onEnd);
		session.addEventListener('visibilitychange', onVisibilityChange);

		this._camera.on('set_nearClip', onClipPlanesChange);

		this._camera.on('set_farClip', onClipPlanesChange);

		this._baseLayer = new XRWebGLLayer(session, this.app.graphicsDevice.gl, {
			alpha: true,
			depth: true,
			stencil: true
		});
		session.updateRenderState({
			baseLayer: this._baseLayer,
			depthNear: this._depthNear,
			depthFar: this._depthFar
		});
		session.requestReferenceSpace(spaceType).then(referenceSpace => {
			this._referenceSpace = referenceSpace;
			this.app.tick();
			if (callback) callback(null);
			this.fire('start');
		}).catch(ex => {
			failed = true;
			session.end();
			if (callback) callback(ex);
			this.fire('error', ex);
		});
	}

	_setClipPlanes(near, far) {
		if (this._depthNear === near && this._depthFar === far) return;
		this._depthNear = near;
		this._depthFar = far;
		if (!this._session) return;

		this._session.updateRenderState({
			depthNear: this._depthNear,
			depthFar: this._depthFar
		});
	}

	update(frame) {
		if (!this._session) return;
		const width = frame.session.renderState.baseLayer.framebufferWidth;
		const height = frame.session.renderState.baseLayer.framebufferHeight;

		if (this._width !== width || this._height !== height) {
			this._width = width;
			this._height = height;
			this.app.graphicsDevice.setResolution(width, height);
		}

		const pose = frame.getViewerPose(this._referenceSpace);
		const lengthNew = pose ? pose.views.length : 0;

		if (lengthNew > this.views.length) {
			for (let i = 0; i <= lengthNew - this.views.length; i++) {
				let view = this.viewsPool.pop();

				if (!view) {
					view = {
						viewport: new Vec4(),
						projMat: new Mat4(),
						viewMat: new Mat4(),
						viewOffMat: new Mat4(),
						viewInvMat: new Mat4(),
						viewInvOffMat: new Mat4(),
						projViewOffMat: new Mat4(),
						viewMat3: new Mat3(),
						position: new Float32Array(3),
						rotation: new Quat()
					};
				}

				this.views.push(view);
			}
		} else if (lengthNew <= this.views.length) {
			for (let i = 0; i < this.views.length - lengthNew; i++) {
				this.viewsPool.push(this.views.pop());
			}
		}

		if (pose) {
			const posePosition = pose.transform.position;
			const poseOrientation = pose.transform.orientation;

			this._localPosition.set(posePosition.x, posePosition.y, posePosition.z);

			this._localRotation.set(poseOrientation.x, poseOrientation.y, poseOrientation.z, poseOrientation.w);

			const layer = frame.session.renderState.baseLayer;

			for (let i = 0; i < pose.views.length; i++) {
				const viewRaw = pose.views[i];
				const view = this.views[i];
				const viewport = layer.getViewport(viewRaw);
				view.viewport.x = viewport.x;
				view.viewport.y = viewport.y;
				view.viewport.z = viewport.width;
				view.viewport.w = viewport.height;
				view.projMat.set(viewRaw.projectionMatrix);
				view.viewMat.set(viewRaw.transform.inverse.matrix);
				view.viewInvMat.set(viewRaw.transform.matrix);
			}
		}

		this._camera.camera._node.setLocalPosition(this._localPosition);

		this._camera.camera._node.setLocalRotation(this._localRotation);

		this.input.update(frame);

		if (this._type === XRTYPE_AR) {
			if (this.hitTest.supported) this.hitTest.update(frame);
			if (this.lightEstimation.supported) this.lightEstimation.update(frame);
			if (this.depthSensing.supported) this.depthSensing.update(frame, pose && pose.views[0]);
			if (this.imageTracking.supported) this.imageTracking.update(frame);
			if (this.planeDetection.supported) this.planeDetection.update(frame);
		}

		this.fire('update', frame);
	}

	get supported() {
		return this._supported;
	}

	get active() {
		return !!this._session;
	}

	get type() {
		return this._type;
	}

	get spaceType() {
		return this._spaceType;
	}

	get session() {
		return this._session;
	}

	get camera() {
		return this._camera ? this._camera.entity : null;
	}

	get visibilityState() {
		if (!this._session) return null;
		return this._session.visibilityState;
	}

}

class ComponentSystem extends EventHandler {
	constructor(app) {
		super();
		this.app = app;
		this.store = {};
		this.schema = [];
	}

	addComponent(entity, data = {}) {
		const component = new this.ComponentType(this, entity);
		const componentData = new this.DataType();
		this.store[entity.getGuid()] = {
			entity: entity,
			data: componentData
		};
		entity[this.id] = component;
		entity.c[this.id] = component;
		this.initializeComponentData(component, data, []);
		this.fire('add', entity, component);
		return component;
	}

	removeComponent(entity) {
		const record = this.store[entity.getGuid()];
		const component = entity.c[this.id];
		this.fire('beforeremove', entity, component);
		delete this.store[entity.getGuid()];
		entity[this.id] = undefined;
		delete entity.c[this.id];
		this.fire('remove', entity, record.data);
	}

	cloneComponent(entity, clone) {
		const src = this.store[entity.getGuid()];
		return this.addComponent(clone, src.data);
	}

	initializeComponentData(component, data = {}, properties) {
		for (let i = 0, len = properties.length; i < len; i++) {
			const descriptor = properties[i];
			let name, type;

			if (typeof descriptor === 'object') {
				name = descriptor.name;
				type = descriptor.type;
			} else {
				name = descriptor;
				type = undefined;
			}

			let value = data[name];

			if (value !== undefined) {
				if (type !== undefined) {
					value = convertValue(value, type);
				}

				component[name] = value;
			} else {
				component[name] = component.data[name];
			}
		}

		if (component.enabled && component.entity.enabled) {
			component.onEnable();
		}
	}

	getPropertiesOfType(type) {
		const matchingProperties = [];
		const schema = this.schema || [];
		schema.forEach(function (descriptor) {
			if (descriptor && typeof descriptor === 'object' && descriptor.type === type) {
				matchingProperties.push(descriptor);
			}
		});
		return matchingProperties;
	}

	destroy() {
		this.off();
	}

}

function convertValue(value, type) {
	if (!value) {
		return value;
	}

	switch (type) {
		case 'rgb':
			if (value instanceof Color) {
				return value.clone();
			}

			return new Color(value[0], value[1], value[2]);

		case 'rgba':
			if (value instanceof Color) {
				return value.clone();
			}

			return new Color(value[0], value[1], value[2], value[3]);

		case 'vec2':
			if (value instanceof Vec2) {
				return value.clone();
			}

			return new Vec2(value[0], value[1]);

		case 'vec3':
			if (value instanceof Vec3) {
				return value.clone();
			}

			return new Vec3(value[0], value[1], value[2]);

		case 'vec4':
			if (value instanceof Vec4) {
				return value.clone();
			}

			return new Vec4(value[0], value[1], value[2], value[3]);

		case 'boolean':
		case 'number':
		case 'string':
			return value;

		case 'entity':
			return value;

		default:
			throw new Error('Could not convert unhandled type: ' + type);
	}
}

class AnimCache {
	constructor() {
		this._left = Infinity;
		this._right = -Infinity;
		this._len = 0;
		this._recip = 0;
		this._p0 = 0;
		this._p1 = 0;
		this._t = 0;
		this._hermite = {
			valid: false,
			p0: 0,
			m0: 0,
			p1: 0,
			m1: 0
		};
	}

	update(time, input) {
		if (time < this._left || time >= this._right) {
			const len = input.length;

			if (!len) {
				this._left = -Infinity;
				this._right = Infinity;
				this._len = 0;
				this._recip = 0;
				this._p0 = this._p1 = 0;
			} else {
				if (time < input[0]) {
					this._left = -Infinity;
					this._right = input[0];
					this._len = 0;
					this._recip = 0;
					this._p0 = this._p1 = 0;
				} else if (time >= input[len - 1]) {
					this._left = input[len - 1];
					this._right = Infinity;
					this._len = 0;
					this._recip = 0;
					this._p0 = this._p1 = len - 1;
				} else {
					const index = this._findKey(time, input);

					this._left = input[index];
					this._right = input[index + 1];
					this._len = this._right - this._left;
					const diff = 1.0 / this._len;
					this._recip = isFinite(diff) ? diff : 0;
					this._p0 = index;
					this._p1 = index + 1;
				}
			}
		}

		this._t = this._recip === 0 ? 0 : (time - this._left) * this._recip;
		this._hermite.valid = false;
	}

	_findKey(time, input) {
		let index = 0;

		while (time >= input[index + 1]) {
			index++;
		}

		return index;
	}

	eval(result, interpolation, output) {
		const data = output._data;
		const comp = output._components;
		const idx0 = this._p0 * comp;

		if (interpolation === INTERPOLATION_STEP) {
			for (let i = 0; i < comp; ++i) {
				result[i] = data[idx0 + i];
			}
		} else {
			const t = this._t;
			const idx1 = this._p1 * comp;

			switch (interpolation) {
				case INTERPOLATION_LINEAR:
					for (let i = 0; i < comp; ++i) {
						result[i] = math.lerp(data[idx0 + i], data[idx1 + i], t);
					}

					break;

				case INTERPOLATION_CUBIC:
					{
						const hermite = this._hermite;

						if (!hermite.valid) {
							const t2 = t * t;
							const twot = t + t;
							const omt = 1 - t;
							const omt2 = omt * omt;
							hermite.valid = true;
							hermite.p0 = (1 + twot) * omt2;
							hermite.m0 = t * omt2;
							hermite.p1 = t2 * (3 - twot);
							hermite.m1 = t2 * (t - 1);
						}

						const p0 = (this._p0 * 3 + 1) * comp;
						const m0 = (this._p0 * 3 + 2) * comp;
						const p1 = (this._p1 * 3 + 1) * comp;
						const m1 = (this._p1 * 3 + 0) * comp;

						for (let i = 0; i < comp; ++i) {
							result[i] = hermite.p0 * data[p0 + i] + hermite.m0 * data[m0 + i] * this._len + hermite.p1 * data[p1 + i] + hermite.m1 * data[m1 + i] * this._len;
						}

						break;
					}
			}
		}
	}

}

class AnimSnapshot {
	constructor(animTrack) {
		this._name = animTrack.name + 'Snapshot';
		this._time = -1;
		this._cache = [];
		this._results = [];

		for (let i = 0; i < animTrack._inputs.length; ++i) {
			this._cache[i] = new AnimCache();
		}

		const curves = animTrack._curves;
		const outputs = animTrack._outputs;

		for (let i = 0; i < curves.length; ++i) {
			const curve = curves[i];
			const output = outputs[curve._output];
			const storage = [];

			for (let j = 0; j < output._components; ++j) {
				storage[j] = 0;
			}

			this._results[i] = storage;
		}
	}

}

class AnimClip {
	constructor(track, time, speed, playing, loop, eventHandler) {
		this._name = track.name;
		this._track = track;
		this._snapshot = new AnimSnapshot(track);
		this._playing = playing;
		this._time = time;
		this._speed = speed;
		this._loop = loop;
		this._blendWeight = 1.0;
		this._blendOrder = 0.0;
		this._eventHandler = eventHandler;
		this._eventCursor = 0;

		while (this._track.events[this._eventCursor] && this._track.events[this._eventCursor].time < this.time) {
			this._eventCursor++;
		}
	}

	set name(name) {
		this._name = name;
	}

	get name() {
		return this._name;
	}

	get track() {
		return this._track;
	}

	get snapshot() {
		return this._snapshot;
	}

	set time(time) {
		this._time = time;
	}

	get time() {
		return this._time;
	}

	set speed(speed) {
		this._speed = speed;
	}

	get speed() {
		return this._speed;
	}

	set loop(loop) {
		this._loop = loop;
	}

	get loop() {
		return this._loop;
	}

	set blendWeight(blendWeight) {
		this._blendWeight = blendWeight;
	}

	get blendWeight() {
		return this._blendWeight;
	}

	set blendOrder(blendOrder) {
		this._blendOrder = blendOrder;
	}

	get blendOrder() {
		return this._blendOrder;
	}

	set eventCursor(value) {
		this._eventCursor = value;
	}

	get eventCursor() {
		return this._eventCursor;
	}

	activeEventsForFrame(frameStartTime, frameEndTime) {
		if (frameStartTime === 0) {
			this.eventCursor = 0;
		}

		let clippedFrameDuration;

		if (frameEndTime > this.track.duration) {
			clippedFrameDuration = frameEndTime - this.track.duration;
			frameEndTime = this.track.duration;
		}

		while (this.track.events[this.eventCursor] && this.track.events[this.eventCursor].time >= frameStartTime && (frameEndTime === this.track.duration ? this.track.events[this.eventCursor].time <= frameEndTime : this.track.events[this.eventCursor].time < frameEndTime)) {
			const event = this.track.events[this.eventCursor];

			this._eventHandler.fire(event.name, _extends({
				track: this.track
			}, event));

			this.eventCursor++;
		}

		if (Number.isFinite(clippedFrameDuration)) {
			this.activeEventsForFrame(0, clippedFrameDuration);
		}
	}

	_update(deltaTime) {
		if (this._playing) {
			let time = this._time;
			const duration = this._track.duration;
			const speed = this._speed;
			const loop = this._loop;

			if (this._track.events.length > 0 && duration > 0) {
				this.activeEventsForFrame(time, time + speed * deltaTime);
			}

			time += speed * deltaTime;

			if (speed >= 0) {
				if (time > duration) {
					if (loop) {
						time = time % duration || 0;
					} else {
						time = this._track.duration;
						this.pause();
					}
				}
			} else {
				if (time < 0) {
					if (loop) {
						time = duration + (time % duration || 0);
					} else {
						time = 0;
						this.pause();
					}
				}
			}

			this._time = time;
		}

		if (this._time !== this._snapshot._time) {
			this._track.eval(this._time, this._snapshot);
		}
	}

	play() {
		this._playing = true;
		this._time = 0;
	}

	stop() {
		this._playing = false;
		this._time = 0;
	}

	pause() {
		this._playing = false;
	}

	resume() {
		this._playing = true;
	}

	reset() {
		this._time = 0;
	}

}

const ANIM_INTERRUPTION_NONE = 'NONE';
const ANIM_INTERRUPTION_PREV = 'PREV_STATE';
const ANIM_INTERRUPTION_NEXT = 'NEXT_STATE';
const ANIM_INTERRUPTION_PREV_NEXT = 'PREV_STATE_NEXT_STATE';
const ANIM_INTERRUPTION_NEXT_PREV = 'NEXT_STATE_PREV_STATE';
const ANIM_GREATER_THAN = 'GREATER_THAN';
const ANIM_LESS_THAN = 'LESS_THAN';
const ANIM_GREATER_THAN_EQUAL_TO = 'GREATER_THAN_EQUAL_TO';
const ANIM_LESS_THAN_EQUAL_TO = 'LESS_THAN_EQUAL_TO';
const ANIM_EQUAL_TO = 'EQUAL_TO';
const ANIM_NOT_EQUAL_TO = 'NOT_EQUAL_TO';
const ANIM_PARAMETER_INTEGER = 'INTEGER';
const ANIM_PARAMETER_FLOAT = 'FLOAT';
const ANIM_PARAMETER_BOOLEAN = 'BOOLEAN';
const ANIM_PARAMETER_TRIGGER = 'TRIGGER';
const ANIM_BLEND_1D = '1D';
const ANIM_BLEND_2D_DIRECTIONAL = '2D_DIRECTIONAL';
const ANIM_BLEND_2D_CARTESIAN = '2D_CARTESIAN';
const ANIM_BLEND_DIRECT = 'DIRECT';
const ANIM_STATE_START = 'START';
const ANIM_STATE_END = 'END';
const ANIM_STATE_ANY = 'ANY';
const ANIM_CONTROL_STATES = [ANIM_STATE_START, ANIM_STATE_END, ANIM_STATE_ANY];
const ANIM_LAYER_OVERWRITE = 'OVERWRITE';
const ANIM_LAYER_ADDITIVE = 'ADDITIVE';

class AnimTargetValue {
	constructor(component, type) {
		this._component = component;
		this.mask = new Int8Array(component.layers.length);
		this.weights = new Float32Array(component.layers.length);
		this.totalWeight = 0;
		this.counter = 0;
		this.layerCounter = 0;
		this.valueType = type;
		this.dirty = true;
		this.value = [0, 0, 0, 1];
	}

	getWeight(index) {
		if (this.dirty) this.updateWeights();

		if (this.totalWeight === 0 || !this.mask[index]) {
			return 0;
		}

		return this.weights[index] / this.totalWeight;
	}

	setMask(index, value) {
		this.mask[index] = value;

		if (this._component.layers[index].blendType === ANIM_LAYER_OVERWRITE) {
			this.mask = this.mask.fill(0, 0, index);
		}

		this.dirty = true;
	}

	updateWeights() {
		this.totalWeight = 0;

		for (let i = 0; i < this.weights.length; i++) {
			this.weights[i] = this._component.layers[i].weight;
			this.totalWeight += this.mask[i] * this.weights[i];
		}

		this.dirty = false;
	}

	updateValue(index, value) {
		if (this.counter === 0) {
			this.value[0] = 0;
			this.value[1] = 0;
			this.value[2] = 0;
			this.value[3] = 1;
		}

		if (!this.mask[index]) return;

		if (this.counter === 0) {
			AnimEvaluator._set(this.value, value, this.valueType);
		} else {
			AnimEvaluator._blend(this.value, value, this.getWeight(index), this.valueType);
		}
	}

}

AnimTargetValue.TYPE_QUAT = 'quaternion';
AnimTargetValue.TYPE_VEC3 = 'vector3';

class AnimEvaluator {
	constructor(binder) {
		this._binder = binder;
		this._clips = [];
		this._inputs = [];
		this._outputs = [];
		this._targets = {};
	}

	get clips() {
		return this._clips;
	}

	static _dot(a, b) {
		const len = a.length;
		let result = 0;

		for (let i = 0; i < len; ++i) {
			result += a[i] * b[i];
		}

		return result;
	}

	static _normalize(a) {
		let l = AnimEvaluator._dot(a, a);

		if (l > 0) {
			l = 1.0 / Math.sqrt(l);
			const len = a.length;

			for (let i = 0; i < len; ++i) {
				a[i] *= l;
			}
		}
	}

	static _set(a, b, type) {
		const len = a.length;

		if (type === 'quaternion') {
			let l = AnimEvaluator._dot(b, b);

			if (l > 0) {
				l = 1.0 / Math.sqrt(l);
			}

			for (let i = 0; i < len; ++i) {
				a[i] = b[i] * l;
			}
		} else {
			for (let i = 0; i < len; ++i) {
				a[i] = b[i];
			}
		}
	}

	static _blendVec(a, b, t) {
		const it = 1.0 - t;
		const len = a.length;

		for (let i = 0; i < len; ++i) {
			a[i] = a[i] * it + b[i] * t;
		}
	}

	static _blendQuat(a, b, t) {
		const len = a.length;
		const it = 1.0 - t;

		if (AnimEvaluator._dot(a, b) < 0) {
			t = -t;
		}

		for (let i = 0; i < len; ++i) {
			a[i] = a[i] * it + b[i] * t;
		}

		AnimEvaluator._normalize(a);
	}

	static _blend(a, b, t, type) {
		if (type === 'quaternion') {
			AnimEvaluator._blendQuat(a, b, t);
		} else {
			AnimEvaluator._blendVec(a, b, t);
		}
	}

	static _stableSort(a, lessFunc) {
		const len = a.length;

		for (let i = 0; i < len - 1; ++i) {
			for (let j = i + 1; j < len; ++j) {
				if (lessFunc(a[j], a[i])) {
					const tmp = a[i];
					a[i] = a[j];
					a[j] = tmp;
				}
			}
		}
	}

	addClip(clip) {
		const targets = this._targets;
		const binder = this._binder;
		const curves = clip.track.curves;
		const snapshot = clip.snapshot;
		const inputs = [];
		const outputs = [];

		for (let i = 0; i < curves.length; ++i) {
			const curve = curves[i];
			const paths = curve.paths;

			for (let j = 0; j < paths.length; ++j) {
				const path = paths[j];
				const resolved = binder.resolve(path);
				let target = targets[resolved && resolved.targetPath || null];

				if (!target && resolved) {
					target = {
						target: resolved,
						value: [],
						curves: 0,
						blendCounter: 0
					};

					for (let k = 0; k < target.target.components; ++k) {
						target.value.push(0);
					}

					targets[resolved.targetPath] = target;

					if (binder.animComponent) {
						if (!binder.animComponent.targets[resolved.targetPath]) {
							let type;

							if (resolved.targetPath.substring(resolved.targetPath.length - 13) === 'localRotation') {
								type = AnimTargetValue.TYPE_QUAT;
							} else {
								type = AnimTargetValue.TYPE_VEC3;
							}

							binder.animComponent.targets[resolved.targetPath] = new AnimTargetValue(binder.animComponent, type);
						}

						binder.animComponent.targets[resolved.targetPath].layerCounter++;
						binder.animComponent.targets[resolved.targetPath].setMask(binder.layerIndex, 1);
					}
				}

				if (target) {
					target.curves++;
					inputs.push(snapshot._results[i]);
					outputs.push(target);
				}
			}
		}

		this._clips.push(clip);

		this._inputs.push(inputs);

		this._outputs.push(outputs);
	}

	removeClip(index) {
		const targets = this._targets;
		const binder = this._binder;
		const clips = this._clips;
		const clip = clips[index];
		const curves = clip.track.curves;

		for (let i = 0; i < curves.length; ++i) {
			const curve = curves[i];
			const paths = curve.paths;

			for (let j = 0; j < paths.length; ++j) {
				const path = paths[j];

				const target = this._binder.resolve(path);

				if (target) {
					target.curves--;

					if (target.curves === 0) {
						binder.unresolve(path);
						delete targets[target.targetPath];

						if (binder.animComponent) {
							binder.animComponent.targets[target.targetPath].layerCounter--;
						}
					}
				}
			}
		}

		clips.splice(index, 1);

		this._inputs.splice(index, 1);

		this._outputs.splice(index, 1);
	}

	removeClips() {
		while (this._clips.length > 0) {
			this.removeClip(0);
		}
	}

	findClip(name) {
		const clips = this._clips;

		for (let i = 0; i < clips.length; ++i) {
			const clip = clips[i];

			if (clip.name === name) {
				return clip;
			}
		}

		return null;
	}

	rebind() {
		this._binder.rebind();

		this._targets = {};
		const clips = [...this.clips];
		this.removeClips();
		clips.forEach(clip => {
			this.addClip(clip);
		});
	}

	assignMask(mask) {
		return this._binder.assignMask(mask);
	}

	update(deltaTime) {
		const clips = this._clips;
		const order = clips.map(function (c, i) {
			return i;
		});

		AnimEvaluator._stableSort(order, function (a, b) {
			return clips[a].blendOrder < clips[b].blendOrder;
		});

		for (let i = 0; i < order.length; ++i) {
			const index = order[i];
			const clip = clips[index];
			const inputs = this._inputs[index];
			const outputs = this._outputs[index];
			const blendWeight = clip.blendWeight;

			if (blendWeight > 0.0) {
				clip._update(deltaTime);
			}

			let input;
			let output;
			let value;

			if (blendWeight >= 1.0) {
				for (let j = 0; j < inputs.length; ++j) {
					input = inputs[j];
					output = outputs[j];
					value = output.value;

					AnimEvaluator._set(value, input, output.target.type);

					output.blendCounter++;
				}
			} else if (blendWeight > 0.0) {
				for (let j = 0; j < inputs.length; ++j) {
					input = inputs[j];
					output = outputs[j];
					value = output.value;

					if (output.blendCounter === 0) {
						AnimEvaluator._set(value, input, output.target.type);
					} else {
						AnimEvaluator._blend(value, input, blendWeight, output.target.type);
					}

					output.blendCounter++;
				}
			}
		}

		const targets = this._targets;
		const binder = this._binder;

		for (const path in targets) {
			if (targets.hasOwnProperty(path)) {
				const target = targets[path];

				if (binder.animComponent && target.target.isTransform) {
					const animTarget = binder.animComponent.targets[path];

					if (animTarget.counter === animTarget.layerCounter) {
						animTarget.counter = 0;
					}

					animTarget.updateValue(binder.layerIndex, target.value);
					target.target.func(animTarget.value);
					animTarget.counter++;
				} else {
					target.target.func(target.value);
				}

				target.blendCounter = 0;
			}
		}

		binder.update(deltaTime);
	}

}

class AnimBinder {
	static joinPath(pathSegments, character) {
		character = character || '.';

		const escape = function escape(string) {
			return string.replace(/\\/g, '\\\\').replace(new RegExp('\\' + character, 'g'), '\\' + character);
		};

		return pathSegments.map(escape).join(character);
	}

	static splitPath(path, character) {
		character = character || '.';
		const result = [];
		let curr = "";
		let i = 0;

		while (i < path.length) {
			let c = path[i++];

			if (c === '\\' && i < path.length) {
				c = path[i++];

				if (c === '\\' || c === character) {
					curr += c;
				} else {
					curr += '\\' + c;
				}
			} else if (c === character) {
				result.push(curr);
				curr = '';
			} else {
				curr += c;
			}
		}

		if (curr.length > 0) {
			result.push(curr);
		}

		return result;
	}

	static encode(entityPath, component, propertyPath) {
		return `${Array.isArray(entityPath) ? entityPath.join('/') : entityPath}/${component}/${Array.isArray(propertyPath) ? propertyPath.join('/') : propertyPath}`;
	}

	resolve(path) {
		return null;
	}

	unresolve(path) {}

	update(deltaTime) {}

}

class AnimTarget {
	constructor(func, type, components, targetPath) {
		this._func = func;
		this._type = type;
		this._components = components;
		this._targetPath = targetPath;
		this._isTransform = this._targetPath.substring(this._targetPath.length - 13) === 'localRotation' || this._targetPath.substring(this._targetPath.length - 13) === 'localPosition' || this._targetPath.substring(this._targetPath.length - 10) === 'localScale';
	}

	get func() {
		return this._func;
	}

	get type() {
		return this._type;
	}

	get components() {
		return this._components;
	}

	get targetPath() {
		return this._targetPath;
	}

	get isTransform() {
		return this._isTransform;
	}

}

class DefaultAnimBinder {
	constructor(graph) {
		this._isPathInMask = (path, checkMaskValue) => {
			const maskItem = this._mask[path];
			if (!maskItem) return false;else if (maskItem.children || checkMaskValue && maskItem.value !== false) return true;
			return false;
		};

		this.graph = graph;
		if (!graph) return;
		this._mask = null;
		const nodes = {};

		const flatten = function flatten(node) {
			nodes[node.name] = node;

			for (let i = 0; i < node.children.length; ++i) {
				flatten(node.children[i]);
			}
		};

		flatten(graph);
		this.nodes = nodes;
		this.targetCache = {};

		const findMeshInstances = function findMeshInstances(node) {
			let object = node;

			while (object && !(object instanceof Entity)) {
				object = object.parent;
			}

			let meshInstances;

			if (object) {
				if (object.render) {
					meshInstances = object.render.meshInstances;
				} else if (object.model) {
					meshInstances = object.model.meshInstances;
				}
			}

			return meshInstances;
		};

		this.nodeCounts = {};
		this.activeNodes = [];
		this.handlers = {
			'localPosition': function (node) {
				const object = node.localPosition;

				const func = function func(value) {
					object.set(...value);
				};

				return DefaultAnimBinder.createAnimTarget(func, 'vector', 3, node, 'localPosition');
			},
			'localRotation': function (node) {
				const object = node.localRotation;

				const func = function func(value) {
					object.set(...value);
				};

				return DefaultAnimBinder.createAnimTarget(func, 'quaternion', 4, node, 'localRotation');
			},
			'localScale': function (node) {
				const object = node.localScale;

				const func = function func(value) {
					object.set(...value);
				};

				return DefaultAnimBinder.createAnimTarget(func, 'vector', 3, node, 'localScale');
			},
			'weights': function (node) {
				const meshInstances = findMeshInstances(node);

				if (meshInstances) {
					const morphInstances = [];

					for (let i = 0; i < meshInstances.length; ++i) {
						if (meshInstances[i].node.name === node.name && meshInstances[i].morphInstance) {
							morphInstances.push(meshInstances[i].morphInstance);
						}
					}

					if (morphInstances.length > 0) {
						const func = function func(value) {
							for (let i = 0; i < value.length; ++i) {
								for (let j = 0; j < morphInstances.length; j++) {
									morphInstances[j].setWeight(i, value[i]);
								}
							}
						};

						return DefaultAnimBinder.createAnimTarget(func, 'vector', morphInstances[0].morph._targets.length, node, 'weights');
					}
				}

				return null;
			},
			'materialTexture': (node, textureName) => {
				const meshInstances = findMeshInstances(node);

				if (meshInstances) {
					let meshInstance;

					for (let i = 0; i < meshInstances.length; ++i) {
						if (meshInstances[i].node.name === node.name) {
							meshInstance = meshInstances[i];
							break;
						}
					}

					if (meshInstance) {
						const func = value => {
							const textureAsset = this.animComponent.system.app.assets.get(value[0]);

							if (textureAsset && textureAsset.resource && textureAsset.type === 'texture') {
								meshInstance.material[textureName] = textureAsset.resource;
								meshInstance.material.update();
							}
						};

						return DefaultAnimBinder.createAnimTarget(func, 'vector', 1, node, 'materialTexture', 'material');
					}
				}

				return null;
			}
		};
	}

	_isPathActive(path) {
		if (!this._mask) return true;
		const rootNodeNames = [path.entityPath[0], this.graph.name];

		for (let j = 0; j < rootNodeNames.length; ++j) {
			let currEntityPath = rootNodeNames[j];
			if (this._isPathInMask(currEntityPath, path.entityPath.length === 1)) return true;

			for (let i = 1; i < path.entityPath.length; i++) {
				currEntityPath += '/' + path.entityPath[i];
				if (this._isPathInMask(currEntityPath, i === path.entityPath.length - 1)) return true;
			}
		}

		return false;
	}

	findNode(path) {
		if (!this._isPathActive(path)) {
			return null;
		}

		let node;

		if (this.graph) {
			node = this.graph.findByPath(path.entityPath);
		}

		if (!node) {
			node = this.nodes[path.entityPath[path.entityPath.length - 1] || ""];
		}

		return node;
	}

	static createAnimTarget(func, type, valueCount, node, propertyPath, componentType) {
		const targetPath = AnimBinder.encode(node.path, componentType ? componentType : 'entity', propertyPath);
		return new AnimTarget(func, type, valueCount, targetPath);
	}

	resolve(path) {
		const encodedPath = AnimBinder.encode(path.entityPath, path.component, path.propertyPath);
		let target = this.targetCache[encodedPath];
		if (target) return target;
		const node = this.findNode(path);

		if (!node) {
			return null;
		}

		const handler = this.handlers[path.propertyPath];

		if (!handler) {
			return null;
		}

		target = handler(node);

		if (!target) {
			return null;
		}

		this.targetCache[encodedPath] = target;

		if (!this.nodeCounts[node.path]) {
			this.activeNodes.push(node);
			this.nodeCounts[node.path] = 1;
		} else {
			this.nodeCounts[node.path]++;
		}

		return target;
	}

	unresolve(path) {
		if (path.component !== 'graph') return;
		const node = this.nodes[path.entityPath[path.entityPath.length - 1] || ""];
		this.nodeCounts[node.path]--;

		if (this.nodeCounts[node.path] === 0) {
			const activeNodes = this.activeNodes;
			const i = activeNodes.indexOf(node.node);
			const len = activeNodes.length;

			if (i < len - 1) {
				activeNodes[i] = activeNodes[len - 1];
			}

			activeNodes.pop();
		}
	}

	update(deltaTime) {
		const activeNodes = this.activeNodes;

		for (let i = 0; i < activeNodes.length; ++i) {
			activeNodes[i]._dirtifyLocal();
		}
	}

	assignMask(mask) {
		if (mask !== this._mask) {
			this._mask = mask;
			return true;
		}

		return false;
	}

}

class InterpolatedKey {
	constructor() {
		this._written = false;
		this._name = "";
		this._keyFrames = [];
		this._quat = new Quat();
		this._pos = new Vec3();
		this._scale = new Vec3();
		this._targetNode = null;
	}

	getTarget() {
		return this._targetNode;
	}

	setTarget(node) {
		this._targetNode = node;
	}

}

class Skeleton {
	constructor(graph) {
		this.looping = true;
		this._animation = null;
		this._time = 0;
		this._interpolatedKeys = [];
		this._interpolatedKeyDict = {};
		this._currKeyIndices = {};
		this.graph = null;

		const addInterpolatedKeys = node => {
			const interpKey = new InterpolatedKey();
			interpKey._name = node.name;

			this._interpolatedKeys.push(interpKey);

			this._interpolatedKeyDict[node.name] = interpKey;
			this._currKeyIndices[node.name] = 0;

			for (let i = 0; i < node._children.length; i++) addInterpolatedKeys(node._children[i]);
		};

		addInterpolatedKeys(graph);
	}

	set animation(value) {
		this._animation = value;
		this.currentTime = 0;
	}

	get animation() {
		return this._animation;
	}

	set currentTime(value) {
		this._time = value;
		const numNodes = this._interpolatedKeys.length;

		for (let i = 0; i < numNodes; i++) {
			const node = this._interpolatedKeys[i];
			const nodeName = node._name;
			this._currKeyIndices[nodeName] = 0;
		}

		this.addTime(0);
		this.updateGraph();
	}

	get currentTime() {
		return this._time;
	}

	get numNodes() {
		return this._interpolatedKeys.length;
	}

	addTime(delta) {
		if (this._animation !== null) {
			const nodes = this._animation._nodes;
			const duration = this._animation.duration;

			if (this._time === duration && !this.looping) {
				return;
			}

			this._time += delta;

			if (this._time > duration) {
				this._time = this.looping ? 0.0 : duration;

				for (let i = 0; i < nodes.length; i++) {
					const node = nodes[i];
					const nodeName = node._name;
					this._currKeyIndices[nodeName] = 0;
				}
			} else if (this._time < 0) {
				this._time = this.looping ? duration : 0.0;

				for (let i = 0; i < nodes.length; i++) {
					const node = nodes[i];
					const nodeName = node._name;
					this._currKeyIndices[nodeName] = node._keys.length - 2;
				}
			}

			const offset = delta >= 0 ? 1 : -1;

			for (let i = 0; i < nodes.length; i++) {
				const node = nodes[i];
				const nodeName = node._name;
				const keys = node._keys;
				const interpKey = this._interpolatedKeyDict[nodeName];

				if (interpKey === undefined) {
					continue;
				}

				let foundKey = false;

				if (keys.length !== 1) {
					for (let currKeyIndex = this._currKeyIndices[nodeName]; currKeyIndex < keys.length - 1 && currKeyIndex >= 0; currKeyIndex += offset) {
						const k1 = keys[currKeyIndex];
						const k2 = keys[currKeyIndex + 1];

						if (k1.time <= this._time && k2.time >= this._time) {
							const alpha = (this._time - k1.time) / (k2.time - k1.time);

							interpKey._pos.lerp(k1.position, k2.position, alpha);

							interpKey._quat.slerp(k1.rotation, k2.rotation, alpha);

							interpKey._scale.lerp(k1.scale, k2.scale, alpha);

							interpKey._written = true;
							this._currKeyIndices[nodeName] = currKeyIndex;
							foundKey = true;
							break;
						}
					}
				}

				if (keys.length === 1 || !foundKey && this._time === 0.0 && this.looping) {
					interpKey._pos.copy(keys[0].position);

					interpKey._quat.copy(keys[0].rotation);

					interpKey._scale.copy(keys[0].scale);

					interpKey._written = true;
				}
			}
		}
	}

	blend(skel1, skel2, alpha) {
		const numNodes = this._interpolatedKeys.length;

		for (let i = 0; i < numNodes; i++) {
			const key1 = skel1._interpolatedKeys[i];
			const key2 = skel2._interpolatedKeys[i];
			const dstKey = this._interpolatedKeys[i];

			if (key1._written && key2._written) {
				dstKey._quat.slerp(key1._quat, skel2._interpolatedKeys[i]._quat, alpha);

				dstKey._pos.lerp(key1._pos, skel2._interpolatedKeys[i]._pos, alpha);

				dstKey._scale.lerp(key1._scale, key2._scale, alpha);

				dstKey._written = true;
			} else if (key1._written) {
				dstKey._quat.copy(key1._quat);

				dstKey._pos.copy(key1._pos);

				dstKey._scale.copy(key1._scale);

				dstKey._written = true;
			} else if (key2._written) {
				dstKey._quat.copy(key2._quat);

				dstKey._pos.copy(key2._pos);

				dstKey._scale.copy(key2._scale);

				dstKey._written = true;
			}
		}
	}

	setGraph(graph) {
		this.graph = graph;

		if (graph) {
			for (let i = 0; i < this._interpolatedKeys.length; i++) {
				const interpKey = this._interpolatedKeys[i];
				const graphNode = graph.findByName(interpKey._name);

				this._interpolatedKeys[i].setTarget(graphNode);
			}
		} else {
			for (let i = 0; i < this._interpolatedKeys.length; i++) {
				this._interpolatedKeys[i].setTarget(null);
			}
		}
	}

	updateGraph() {
		if (this.graph) {
			for (let i = 0; i < this._interpolatedKeys.length; i++) {
				const interpKey = this._interpolatedKeys[i];

				if (interpKey._written) {
					const transform = interpKey.getTarget();
					transform.localPosition.copy(interpKey._pos);
					transform.localRotation.copy(interpKey._quat);
					transform.localScale.copy(interpKey._scale);
					if (!transform._dirtyLocal) transform._dirtifyLocal();
					interpKey._written = false;
				}
			}
		}
	}

}

class AnimationComponent extends Component {
	constructor(system, entity) {
		super(system, entity);
		this.animationsIndex = {};
		this.on('set_animations', this.onSetAnimations, this);
		this.on('set_assets', this.onSetAssets, this);
		this.on('set_loop', this.onSetLoop, this);
	}

	set currentTime(currentTime) {
		const data = this.data;

		if (data.skeleton) {
			const skeleton = data.skeleton;
			skeleton.currentTime = currentTime;
			skeleton.addTime(0);
			skeleton.updateGraph();
		}

		if (data.animEvaluator) {
			const animEvaluator = data.animEvaluator;

			for (let i = 0; i < animEvaluator.clips.length; ++i) {
				animEvaluator.clips[i].time = currentTime;
			}
		}
	}

	get currentTime() {
		const data = this.data;

		if (data.skeleton) {
			return this.data.skeleton._time;
		}

		if (data.animEvaluator) {
			const clips = data.animEvaluator.clips;

			if (clips.length > 0) {
				return clips[clips.length - 1].time;
			}
		}

		return 0;
	}

	get duration() {
		return this.data.animations[this.data.currAnim].duration;
	}

	play(name, blendTime = 0) {
		if (!this.enabled || !this.entity.enabled) {
			return;
		}

		const data = this.data;

		if (!data.animations[name]) {
			return;
		}

		data.prevAnim = data.currAnim;
		data.currAnim = name;

		if (data.model) {
			if (!data.skeleton && !data.animEvaluator) {
				this._createAnimationController();
			}

			const prevAnim = data.animations[data.prevAnim];
			const currAnim = data.animations[data.currAnim];
			data.blending = blendTime > 0 && data.prevAnim;

			if (data.blending) {
				data.blend = 0;
				data.blendSpeed = 1.0 / blendTime;
			}

			if (data.skeleton) {
				if (data.blending) {
					data.fromSkel.animation = prevAnim;
					data.fromSkel.addTime(data.skeleton._time);
					data.toSkel.animation = currAnim;
				} else {
					data.skeleton.animation = currAnim;
				}
			}

			if (data.animEvaluator) {
				const animEvaluator = data.animEvaluator;

				if (data.blending) {
					while (animEvaluator.clips.length > 1) {
						animEvaluator.removeClip(0);
					}
				} else {
					data.animEvaluator.removeClips();
				}

				const clip = new AnimClip(data.animations[data.currAnim], 0, 1.0, true, data.loop);
				clip.name = data.currAnim;
				clip.blendWeight = data.blending ? 0 : 1;
				clip.reset();
				data.animEvaluator.addClip(clip);
			}
		}

		data.playing = true;
	}

	getAnimation(name) {
		return this.data.animations[name];
	}

	setModel(model) {
		const data = this.data;

		if (model !== data.model) {
			this._resetAnimationController();

			data.model = model;

			if (data.animations && data.currAnim && data.animations[data.currAnim]) {
				this.play(data.currAnim);
			}
		}
	}

	_resetAnimationController() {
		const data = this.data;
		data.skeleton = null;
		data.fromSkel = null;
		data.toSkel = null;
		data.animEvaluator = null;
	}

	_createAnimationController() {
		const data = this.data;
		const model = data.model;
		const animations = data.animations;
		let hasJson = false;
		let hasGlb = false;

		for (const animation in animations) {
			if (animations.hasOwnProperty(animation)) {
				const anim = animations[animation];

				if (anim.constructor === AnimTrack) {
					hasGlb = true;
				} else {
					hasJson = true;
				}
			}
		}

		const graph = model.getGraph();

		if (hasJson) {
			data.fromSkel = new Skeleton(graph);
			data.toSkel = new Skeleton(graph);
			data.skeleton = new Skeleton(graph);
			data.skeleton.looping = data.loop;
			data.skeleton.setGraph(graph);
		} else if (hasGlb) {
			data.animEvaluator = new AnimEvaluator(new DefaultAnimBinder(this.entity));
		}
	}

	loadAnimationAssets(ids) {
		if (!ids || !ids.length) return;
		const assets = this.system.app.assets;

		const onAssetReady = asset => {
			if (asset.resources.length > 1) {
				for (let i = 0; i < asset.resources.length; i++) {
					this.animations[asset.resources[i].name] = asset.resources[i];
					this.animationsIndex[asset.id] = asset.resources[i].name;
				}
			} else {
				this.animations[asset.name] = asset.resource;
				this.animationsIndex[asset.id] = asset.name;
			}

			this.animations = this.animations;
		};

		const onAssetAdd = asset => {
			asset.off('change', this.onAssetChanged, this);
			asset.on('change', this.onAssetChanged, this);
			asset.off('remove', this.onAssetRemoved, this);
			asset.on('remove', this.onAssetRemoved, this);

			if (asset.resource) {
				onAssetReady(asset);
			} else {
				asset.once('load', onAssetReady, this);
				if (this.enabled && this.entity.enabled) assets.load(asset);
			}
		};

		for (let i = 0, l = ids.length; i < l; i++) {
			const asset = assets.get(ids[i]);

			if (asset) {
				onAssetAdd(asset);
			} else {
				assets.on('add:' + ids[i], onAssetAdd);
			}
		}
	}

	onAssetChanged(asset, attribute, newValue, oldValue) {
		if (attribute === 'resource' || attribute === 'resources') {
			if (attribute === 'resources' && newValue && newValue.length === 0) {
				newValue = null;
			}

			if (newValue) {
				let restarted = false;

				if (newValue.length > 1) {
					if (oldValue && oldValue.length > 1) {
						for (let i = 0; i < oldValue.length; i++) {
							delete this.animations[oldValue[i].name];
						}
					} else {
						delete this.animations[asset.name];
					}

					restarted = false;

					for (let i = 0; i < newValue.length; i++) {
						this.animations[newValue[i].name] = newValue[i];

						if (!restarted && this.data.currAnim === newValue[i].name) {
							if (this.data.playing && this.data.enabled && this.entity.enabled) {
								restarted = true;
								this.play(newValue[i].name);
							}
						}
					}

					if (!restarted) {
						this._stopCurrentAnimation();

						this.onSetAnimations();
					}
				} else {
					if (oldValue && oldValue.length > 1) {
						for (let i = 0; i < oldValue.length; i++) {
							delete this.animations[oldValue[i].name];
						}
					}

					this.animations[asset.name] = newValue[0] || newValue;
					restarted = false;

					if (this.data.currAnim === asset.name) {
						if (this.data.playing && this.data.enabled && this.entity.enabled) {
							restarted = true;
							this.play(asset.name);
						}
					}

					if (!restarted) {
						this._stopCurrentAnimation();

						this.onSetAnimations();
					}
				}

				this.animationsIndex[asset.id] = asset.name;
			} else {
				if (oldValue.length > 1) {
					for (let i = 0; i < oldValue.length; i++) {
						delete this.animations[oldValue[i].name];

						if (this.data.currAnim === oldValue[i].name) {
							this._stopCurrentAnimation();
						}
					}
				} else {
					delete this.animations[asset.name];

					if (this.data.currAnim === asset.name) {
						this._stopCurrentAnimation();
					}
				}

				delete this.animationsIndex[asset.id];
			}
		}
	}

	onAssetRemoved(asset) {
		asset.off('remove', this.onAssetRemoved, this);

		if (this.animations) {
			if (asset.resources.length > 1) {
				for (let i = 0; i < asset.resources.length; i++) {
					delete this.animations[asset.resources[i].name];
					if (this.data.currAnim === asset.resources[i].name) this._stopCurrentAnimation();
				}
			} else {
				delete this.animations[asset.name];
				if (this.data.currAnim === asset.name) this._stopCurrentAnimation();
			}

			delete this.animationsIndex[asset.id];
		}
	}

	_stopCurrentAnimation() {
		const data = this.data;
		data.currAnim = null;
		data.playing = false;

		if (data.skeleton) {
			data.skeleton.currentTime = 0;
			data.skeleton.animation = null;
		}

		if (data.animEvaluator) {
			for (let i = 0; i < data.animEvaluator.clips.length; ++i) {
				data.animEvaluator.clips[i].stop();
			}

			data.animEvaluator.update(0);
			data.animEvaluator.removeClips();
		}
	}

	onSetAnimations(name, oldValue, newValue) {
		const data = this.data;
		const modelComponent = this.entity.model;

		if (modelComponent) {
			const m = modelComponent.model;

			if (m && m !== data.model) {
				this.setModel(m);
			}
		}

		if (!data.currAnim && data.activate && data.enabled && this.entity.enabled) {
			const animationNames = Object.keys(data.animations);

			if (animationNames.length > 0) {
				this.play(animationNames[0]);
			}
		}
	}

	onSetAssets(name, oldValue, newValue) {
		if (oldValue && oldValue.length) {
			for (let i = 0; i < oldValue.length; i++) {
				if (oldValue[i]) {
					const asset = this.system.app.assets.get(oldValue[i]);

					if (asset) {
						asset.off('change', this.onAssetChanged, this);
						asset.off('remove', this.onAssetRemoved, this);
						const animName = this.animationsIndex[asset.id];
						if (this.data.currAnim === animName) this._stopCurrentAnimation();
						delete this.animations[animName];
						delete this.animationsIndex[asset.id];
					}
				}
			}
		}

		const ids = newValue.map(value => {
			return value instanceof Asset ? value.id : value;
		});
		this.loadAnimationAssets(ids);
	}

	onSetLoop(name, oldValue, newValue) {
		const data = this.data;

		if (data.skeleton) {
			data.skeleton.looping = data.loop;
		}

		if (data.animEvaluator) {
			for (let i = 0; i < data.animEvaluator.clips.length; ++i) {
				data.animEvaluator.clips[i].loop = data.loop;
			}
		}
	}

	onEnable() {
		super.onEnable();
		const data = this.data;
		const assets = data.assets;
		const registry = this.system.app.assets;

		if (assets) {
			for (let i = 0, len = assets.length; i < len; i++) {
				let asset = assets[i];
				if (!(asset instanceof Asset)) asset = registry.get(asset);
				if (asset && !asset.resource) registry.load(asset);
			}
		}

		if (data.activate && !data.currAnim) {
			const animationNames = Object.keys(data.animations);

			if (animationNames.length > 0) {
				this.play(animationNames[0]);
			}
		}
	}

	onBeforeRemove() {
		for (let i = 0; i < this.assets.length; i++) {
			let asset = this.assets[i];

			if (typeof asset === 'number') {
				asset = this.system.app.assets.get(asset);
			}

			if (!asset) continue;
			asset.off('change', this.onAssetChanged, this);
			asset.off('remove', this.onAssetRemoved, this);
		}

		const data = this.data;
		delete data.animation;
		delete data.skeleton;
		delete data.fromSkel;
		delete data.toSkel;
		delete data.animEvaluator;
	}

}

class AnimationComponentData {
	constructor() {
		this.assets = [];
		this.speed = 1.0;
		this.loop = true;
		this.activate = true;
		this.enabled = true;
		this.animations = {};
		this.model = null;
		this.prevAnim = null;
		this.currAnim = null;
		this.blending = false;
		this.blend = 0;
		this.blendSpeed = 0;
		this.playing = false;
		this.skeleton = null;
		this.fromSkel = null;
		this.toSkel = null;
		this.animEvaluator = null;
	}

}

const _schema$l = ['enabled', 'assets', 'speed', 'loop', 'activate', 'animations', 'skeleton', 'model', 'prevAnim', 'currAnim', 'fromSkel', 'toSkel', 'blending', 'blendTimeRemaining', 'playing'];

class AnimationComponentSystem extends ComponentSystem {
	constructor(app) {
		super(app);
		this.id = 'animation';
		this.ComponentType = AnimationComponent;
		this.DataType = AnimationComponentData;
		this.schema = _schema$l;
		this.on('beforeremove', this.onBeforeRemove, this);
		this.app.systems.on('update', this.onUpdate, this);
	}

	initializeComponentData(component, data, properties) {
		properties = ['activate', 'enabled', 'loop', 'speed', 'assets'];
		super.initializeComponentData(component, data, properties);
	}

	cloneComponent(entity, clone) {
		this.addComponent(clone, {});
		clone.animation.assets = entity.animation.assets.slice();
		clone.animation.data.speed = entity.animation.speed;
		clone.animation.data.loop = entity.animation.loop;
		clone.animation.data.activate = entity.animation.activate;
		clone.animation.data.enabled = entity.animation.enabled;
		const clonedAnimations = {};
		const animations = entity.animation.animations;

		for (const key in animations) {
			if (animations.hasOwnProperty(key)) {
				clonedAnimations[key] = animations[key];
			}
		}

		clone.animation.animations = clonedAnimations;
		const clonedAnimationsIndex = {};
		const animationsIndex = entity.animation.animationsIndex;

		for (const key in animationsIndex) {
			if (animationsIndex.hasOwnProperty(key)) {
				clonedAnimationsIndex[key] = animationsIndex[key];
			}
		}

		clone.animation.animationsIndex = clonedAnimationsIndex;
		return clone.animation;
	}

	onBeforeRemove(entity, component) {
		component.onBeforeRemove();
	}

	onUpdate(dt) {
		const components = this.store;

		for (const id in components) {
			if (components.hasOwnProperty(id)) {
				const component = components[id];
				const componentData = component.data;

				if (componentData.enabled && component.entity.enabled) {
					if (componentData.blending) {
						componentData.blend += dt * componentData.blendSpeed;

						if (componentData.blend >= 1.0) {
							componentData.blend = 1.0;
						}
					}

					if (componentData.playing) {
						const skeleton = componentData.skeleton;

						if (skeleton !== null && componentData.model !== null) {
							if (componentData.blending) {
								skeleton.blend(componentData.fromSkel, componentData.toSkel, componentData.blend);
							} else {
								const delta = dt * componentData.speed;
								skeleton.addTime(delta);

								if (componentData.speed > 0 && skeleton._time === skeleton._animation.duration && !componentData.loop) {
									componentData.playing = false;
								} else if (componentData.speed < 0 && skeleton._time === 0 && !componentData.loop) {
									componentData.playing = false;
								}
							}

							if (componentData.blending && componentData.blend === 1.0) {
								skeleton.animation = componentData.toSkel._animation;
							}

							skeleton.updateGraph();
						}
					}

					const animEvaluator = componentData.animEvaluator;

					if (animEvaluator) {
						for (let i = 0; i < animEvaluator.clips.length; ++i) {
							const clip = animEvaluator.clips[i];
							clip.speed = componentData.speed;

							if (!componentData.playing) {
								clip.pause();
							} else {
								clip.resume();
							}
						}

						if (componentData.blending && animEvaluator.clips.length > 1) {
							animEvaluator.clips[1].blendWeight = componentData.blend;
						}

						animEvaluator.update(dt);
					}

					if (componentData.blending && componentData.blend === 1.0) {
						componentData.blending = false;
					}
				}
			}
		}
	}

	destroy() {
		super.destroy();
		this.app.systems.off('update', this.onUpdate, this);
	}

}

Component._buildAccessors(AnimationComponent.prototype, _schema$l);

class AnimNode {
	constructor(state, parent, name, point, speed = 1) {
		this._state = state;
		this._parent = parent;
		this._name = name;

		if (Array.isArray(point)) {
			this._point = new Vec2(point[0], point[1]);
			this._pointLength = this._point.length();
		} else {
			this._point = point;
			this._pointLength = point;
		}

		this._speed = speed;
		this._weightedSpeed = 1.0;
		this._weight = 1.0;
		this._animTrack = null;
	}

	get parent() {
		return this._parent;
	}

	get name() {
		return this._name;
	}

	get path() {
		return this._parent ? this._parent.path + '.' + this._name : this._name;
	}

	get point() {
		return this._point;
	}

	get pointLength() {
		return this._pointLength;
	}

	set weight(value) {
		this._weight = value;
	}

	get weight() {
		return this._parent ? this._parent.weight * this._weight : this._weight;
	}

	get normalizedWeight() {
		const totalWeight = this._state.totalWeight;
		if (totalWeight === 0.0) return 0.0;
		return this.weight / totalWeight;
	}

	get speed() {
		return this._weightedSpeed * this._speed;
	}

	get absoluteSpeed() {
		return Math.abs(this._speed);
	}

	set weightedSpeed(weightedSpeed) {
		this._weightedSpeed = weightedSpeed;
	}

	get weightedSpeed() {
		return this._weightedSpeed;
	}

	set animTrack(value) {
		this._animTrack = value;
	}

	get animTrack() {
		return this._animTrack;
	}

}

class AnimBlendTree extends AnimNode {
	constructor(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter) {
		super(state, parent, name, point);
		this._parameters = parameters;
		this._parameterValues = new Array(parameters.length);
		this._children = [];
		this._findParameter = findParameter;
		this._syncAnimations = syncAnimations !== false;
		this._pointCache = {};

		for (let i = 0; i < children.length; i++) {
			const child = children[i];

			if (child.children) {
				this._children.push(createTree(child.type, this, null, name, 1.0, child.parameter ? [child.parameter] : child.parameters, child.children, createTree, findParameter));
			} else {
				this._children.push(new AnimNode(state, this, child.name, child.point, child.speed));
			}
		}
	}

	get weight() {
		this.calculateWeights();
		return this._parent ? this._parent.weight * this._weight : this._weight;
	}

	get syncAnimations() {
		return this._syncAnimations;
	}

	getChild(name) {
		for (let i = 0; i < this._children.length; i++) {
			if (this._children[i].name === name) return this._children[i];
		}

		return null;
	}

	updateParameterValues() {
		let paramsEqual = true;

		for (let i = 0; i < this._parameterValues.length; i++) {
			const updatedParameter = this._findParameter(this._parameters[i]).value;

			if (this._parameterValues[i] !== updatedParameter) {
				this._parameterValues[i] = updatedParameter;
				paramsEqual = false;
			}
		}

		return paramsEqual;
	}

	getNodeWeightedDuration(i) {
		return this._children[i].animTrack.duration / this._children[i].speedMultiplier * this._children[i].weight;
	}

	getNodeCount() {
		let count = 0;

		for (let i = 0; i < this._children.length; i++) {
			const child = this._children[i];

			if (child.constructor === AnimBlendTree) {
				count += this._children[i].getNodeCount();
			} else {
				count++;
			}
		}

		return count;
	}

}

class AnimBlendTree1D extends AnimBlendTree {
	constructor(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter) {
		children.sort((a, b) => a.point - b.point);
		super(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);
	}

	calculateWeights() {
		if (this.updateParameterValues()) return;
		let weightedDurationSum = 0.0;
		this._children[0].weight = 0.0;

		for (let i = 0; i < this._children.length; i++) {
			const c1 = this._children[i];

			if (i !== this._children.length - 1) {
				const c2 = this._children[i + 1];

				if (c1.point === c2.point) {
					c1.weight = 0.5;
					c2.weight = 0.5;
				} else if (math.between(this._parameterValues[0], c1.point, c2.point, true)) {
					const child2Distance = Math.abs(c1.point - c2.point);
					const parameterDistance = Math.abs(c1.point - this._parameterValues[0]);
					const weight = (child2Distance - parameterDistance) / child2Distance;
					c1.weight = weight;
					c2.weight = 1.0 - weight;
				} else {
					c2.weight = 0.0;
				}
			}

			if (this._syncAnimations) {
				weightedDurationSum += c1.animTrack.duration / c1.absoluteSpeed * c1.weight;
			}
		}

		if (this._syncAnimations) {
			for (let i = 0; i < this._children.length; i++) {
				const child = this._children[i];
				child.weightedSpeed = child.animTrack.duration / child.absoluteSpeed / weightedDurationSum;
			}
		}
	}

}

class AnimBlendTreeCartesian2D extends AnimBlendTree {
	pointDistanceCache(i, j) {
		const pointKey = `${i}${j}`;

		if (!this._pointCache[pointKey]) {
			this._pointCache[pointKey] = this._children[j].point.clone().sub(this._children[i].point);
		}

		return this._pointCache[pointKey];
	}

	calculateWeights() {
		if (this.updateParameterValues()) return;
		let weightSum, weightedDurationSum;

		AnimBlendTreeCartesian2D._p.set(...this._parameterValues);

		weightSum = 0.0;
		weightedDurationSum = 0.0;

		for (let i = 0; i < this._children.length; i++) {
			const child = this._children[i];
			const pi = child.point;

			AnimBlendTreeCartesian2D._pip.set(AnimBlendTreeCartesian2D._p.x, AnimBlendTreeCartesian2D._p.y).sub(pi);

			let minj = Number.MAX_VALUE;

			for (let j = 0; j < this._children.length; j++) {
				if (i === j) continue;
				const pipj = this.pointDistanceCache(i, j);
				const result = math.clamp(1.0 - AnimBlendTreeCartesian2D._pip.dot(pipj) / pipj.lengthSq(), 0.0, 1.0);
				if (result < minj) minj = result;
			}

			child.weight = minj;
			weightSum += minj;

			if (this._syncAnimations) {
				weightedDurationSum += child.animTrack.duration / child.absoluteSpeed * child.weight;
			}
		}

		for (let i = 0; i < this._children.length; i++) {
			const child = this._children[i];
			child.weight = child._weight / weightSum;

			if (this._syncAnimations) {
				child.weightedSpeed = child.animTrack.duration / child.absoluteSpeed / weightedDurationSum;
			}
		}
	}

}

AnimBlendTreeCartesian2D._p = new Vec2();
AnimBlendTreeCartesian2D._pip = new Vec2();

class AnimBlendTreeDirectional2D extends AnimBlendTree {
	pointCache(i, j) {
		const pointKey = `${i}${j}`;

		if (!this._pointCache[pointKey]) {
			this._pointCache[pointKey] = new Vec2((this._children[j].pointLength - this._children[i].pointLength) / ((this._children[j].pointLength + this._children[i].pointLength) / 2), Vec2.angleRad(this._children[i].point, this._children[j].point) * 2.0);
		}

		return this._pointCache[pointKey];
	}

	calculateWeights() {
		if (this.updateParameterValues()) return;
		let weightSum, weightedDurationSum;

		AnimBlendTreeDirectional2D._p.set(...this._parameterValues);

		const pLength = AnimBlendTreeDirectional2D._p.length();

		weightSum = 0.0;
		weightedDurationSum = 0.0;

		for (let i = 0; i < this._children.length; i++) {
			const child = this._children[i];
			const pi = child.point;
			const piLength = child.pointLength;
			let minj = Number.MAX_VALUE;

			for (let j = 0; j < this._children.length; j++) {
				if (i === j) continue;
				const pipj = this.pointCache(i, j);
				const pjLength = this._children[j].pointLength;

				AnimBlendTreeDirectional2D._pip.set((pLength - piLength) / ((pjLength + piLength) / 2), Vec2.angleRad(pi, AnimBlendTreeDirectional2D._p) * 2.0);

				const result = math.clamp(1.0 - Math.abs(AnimBlendTreeDirectional2D._pip.dot(pipj) / pipj.lengthSq()), 0.0, 1.0);
				if (result < minj) minj = result;
			}

			child.weight = minj;
			weightSum += minj;

			if (this._syncAnimations) {
				weightedDurationSum += child.animTrack.duration / child.absoluteSpeed * child.weight;
			}
		}

		for (let i = 0; i < this._children.length; i++) {
			const child = this._children[i];
			child.weight = child._weight / weightSum;

			if (this._syncAnimations) {
				const weightedChildDuration = child.animTrack.duration / weightedDurationSum * weightSum;
				child.weightedSpeed = child.absoluteSpeed * weightedChildDuration;
			}
		}
	}

}

AnimBlendTreeDirectional2D._p = new Vec2();
AnimBlendTreeDirectional2D._pip = new Vec2();

class AnimBlendTreeDirect extends AnimBlendTree {
	calculateWeights() {
		if (this.updateParameterValues()) return;
		let weightSum = 0.0;
		let weightedDurationSum = 0.0;

		for (let i = 0; i < this._children.length; i++) {
			weightSum += Math.max(this._parameterValues[i], 0.0);

			if (this._syncAnimations) {
				const child = this._children[i];
				weightedDurationSum += child.animTrack.duration / child.absoluteSpeed * child.weight;
			}
		}

		for (let i = 0; i < this._children.length; i++) {
			const child = this._children[i];
			child.weight = Math.max(this._parameterValues[i], 0.0) / weightSum;

			if (this._syncAnimations) {
				child.weightedSpeed = child.animTrack.duration / child.absoluteSpeed / weightedDurationSum;
			}
		}
	}

}

class AnimState {
	constructor(controller, name, speed, loop, blendTree) {
		this._controller = controller;
		this._name = name;
		this._animations = {};
		this._animationList = [];
		this._speed = speed || 1.0;
		this._loop = loop === undefined ? true : loop;

		const findParameter = this._controller.findParameter.bind(this._controller);

		if (blendTree) {
			this._blendTree = this._createTree(blendTree.type, this, null, name, 1.0, blendTree.parameter ? [blendTree.parameter] : blendTree.parameters, blendTree.children, blendTree.syncAnimations, this._createTree, findParameter);
		} else {
			this._blendTree = new AnimNode(this, null, name, 1.0, speed);
		}
	}

	_createTree(type, state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter) {
		switch (type) {
			case ANIM_BLEND_1D:
				return new AnimBlendTree1D(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);

			case ANIM_BLEND_2D_CARTESIAN:
				return new AnimBlendTreeCartesian2D(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);

			case ANIM_BLEND_2D_DIRECTIONAL:
				return new AnimBlendTreeDirectional2D(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);

			case ANIM_BLEND_DIRECT:
				return new AnimBlendTreeDirect(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);
		}
	}

	_getNodeFromPath(path) {
		let currNode = this._blendTree;

		for (let i = 1; i < path.length; i++) {
			currNode = currNode.getChild(path[i]);
		}

		return currNode;
	}

	addAnimation(path, animTrack) {
		const pathString = path.join('.');

		const indexOfAnimation = this._animationList.findIndex(function (animation) {
			return animation.path === pathString;
		});

		if (indexOfAnimation >= 0) {
			this._animationList[indexOfAnimation].animTrack = animTrack;
		} else {
			const node = this._getNodeFromPath(path);

			node.animTrack = animTrack;

			this._animationList.push(node);
		}
	}

	get name() {
		return this._name;
	}

	set animations(value) {
		this._animationList = value;
	}

	get animations() {
		return this._animationList;
	}

	set speed(value) {
		this._speed = value;
	}

	get speed() {
		return this._speed;
	}

	set loop(value) {
		this._loop = value;
	}

	get loop() {
		return this._loop;
	}

	get nodeCount() {
		if (!this._blendTree || this._blendTree.constructor === AnimNode) return 1;
		return this._blendTree.getNodeCount();
	}

	get playable() {
		return ANIM_CONTROL_STATES.indexOf(this.name) !== -1 || this.animations.length === this.nodeCount;
	}

	get looping() {
		if (this.animations.length > 0) {
			const trackClipName = this.name + '.' + this.animations[0].animTrack.name;

			const trackClip = this._controller.animEvaluator.findClip(trackClipName);

			if (trackClip) {
				return trackClip.loop;
			}
		}

		return false;
	}

	get totalWeight() {
		let sum = 0;

		for (let i = 0; i < this.animations.length; i++) {
			sum += this.animations[i].weight;
		}

		return sum;
	}

	get timelineDuration() {
		let duration = 0;

		for (let i = 0; i < this.animations.length; i++) {
			const animation = this.animations[i];

			if (animation.animTrack.duration > duration) {
				duration = animation.animTrack.duration;
			}
		}

		return duration;
	}

}

class AnimTransition {
	constructor({
		from,
		to,
		time = 0,
		priority = 0,
		conditions = [],
		exitTime = null,
		transitionOffset = null,
		interruptionSource = ANIM_INTERRUPTION_NONE
	}) {
		this._from = from;
		this._to = to;
		this._time = time;
		this._priority = priority;
		this._conditions = conditions;
		this._exitTime = exitTime;
		this._transitionOffset = transitionOffset;
		this._interruptionSource = interruptionSource;
	}

	get from() {
		return this._from;
	}

	set to(value) {
		this._to = value;
	}

	get to() {
		return this._to;
	}

	get time() {
		return this._time;
	}

	get priority() {
		return this._priority;
	}

	get conditions() {
		return this._conditions;
	}

	get exitTime() {
		return this._exitTime;
	}

	get transitionOffset() {
		return this._transitionOffset;
	}

	get interruptionSource() {
		return this._interruptionSource;
	}

	get hasExitTime() {
		return !!this.exitTime;
	}

}

class AnimController {
	constructor(animEvaluator, states, transitions, parameters, activate, eventHandler, consumedTriggers) {
		this._animEvaluator = animEvaluator;
		this._states = {};
		this._stateNames = [];
		this._eventHandler = eventHandler;
		this._consumedTriggers = consumedTriggers;

		for (let i = 0; i < states.length; i++) {
			this._states[states[i].name] = new AnimState(this, states[i].name, states[i].speed, states[i].loop, states[i].blendTree);

			this._stateNames.push(states[i].name);
		}

		this._transitions = transitions.map(transition => {
			return new AnimTransition(_extends({}, transition));
		});
		this._findTransitionsFromStateCache = {};
		this._findTransitionsBetweenStatesCache = {};
		this._parameters = parameters;
		this._previousStateName = null;
		this._activeStateName = ANIM_STATE_START;
		this._playing = false;
		this._activate = activate;
		this._currTransitionTime = 1.0;
		this._totalTransitionTime = 1.0;
		this._isTransitioning = false;
		this._transitionInterruptionSource = ANIM_INTERRUPTION_NONE;
		this._transitionPreviousStates = [];
		this._timeInState = 0;
		this._timeInStateBefore = 0;
	}

	get animEvaluator() {
		return this._animEvaluator;
	}

	set activeState(stateName) {
		this._activeStateName = stateName;
	}

	get activeState() {
		return this._findState(this._activeStateName);
	}

	get activeStateName() {
		return this._activeStateName;
	}

	get activeStateAnimations() {
		return this.activeState.animations;
	}

	set previousState(stateName) {
		this._previousStateName = stateName;
	}

	get previousState() {
		return this._findState(this._previousStateName);
	}

	get previousStateName() {
		return this._previousStateName;
	}

	get playable() {
		let playable = true;

		for (let i = 0; i < this._stateNames.length; i++) {
			if (!this._states[this._stateNames[i]].playable) {
				playable = false;
			}
		}

		return playable;
	}

	set playing(value) {
		this._playing = value;
	}

	get playing() {
		return this._playing;
	}

	get activeStateProgress() {
		return this._getActiveStateProgressForTime(this._timeInState);
	}

	get activeStateDuration() {
		if (this.activeStateName === ANIM_STATE_START || this.activeStateName === ANIM_STATE_END) return 0.0;
		let maxDuration = 0.0;

		for (let i = 0; i < this.activeStateAnimations.length; i++) {
			const activeClip = this._animEvaluator.findClip(this.activeStateAnimations[i].name);

			if (activeClip) {
				maxDuration = Math.max(maxDuration, activeClip.track.duration);
			}
		}

		return maxDuration;
	}

	set activeStateCurrentTime(time) {
		this._timeInStateBefore = time;
		this._timeInState = time;

		for (let i = 0; i < this.activeStateAnimations.length; i++) {
			const clip = this.animEvaluator.findClip(this.activeStateAnimations[i].name);

			if (clip) {
				clip.time = time;
			}
		}
	}

	get activeStateCurrentTime() {
		return this._timeInState;
	}

	get transitioning() {
		return this._isTransitioning;
	}

	get transitionProgress() {
		return this._currTransitionTime / this._totalTransitionTime;
	}

	get states() {
		return this._stateNames;
	}

	assignMask(mask) {
		return this._animEvaluator.assignMask(mask);
	}

	_findState(stateName) {
		return this._states[stateName];
	}

	_getActiveStateProgressForTime(time) {
		if (this.activeStateName === ANIM_STATE_START || this.activeStateName === ANIM_STATE_END || this.activeStateName === ANIM_STATE_ANY) return 1.0;

		const activeClip = this._animEvaluator.findClip(this.activeStateAnimations[0].name);

		if (activeClip) {
			return time / activeClip.track.duration;
		}

		return null;
	}

	_findTransitionsFromState(stateName) {
		let transitions = this._findTransitionsFromStateCache[stateName];

		if (!transitions) {
			transitions = this._transitions.filter(function (transition) {
				return transition.from === stateName;
			});
			sortPriority(transitions);
			this._findTransitionsFromStateCache[stateName] = transitions;
		}

		return transitions;
	}

	_findTransitionsBetweenStates(sourceStateName, destinationStateName) {
		let transitions = this._findTransitionsBetweenStatesCache[sourceStateName + '->' + destinationStateName];

		if (!transitions) {
			transitions = this._transitions.filter(function (transition) {
				return transition.from === sourceStateName && transition.to === destinationStateName;
			});
			sortPriority(transitions);
			this._findTransitionsBetweenStatesCache[sourceStateName + '->' + destinationStateName] = transitions;
		}

		return transitions;
	}

	_transitionHasConditionsMet(transition) {
		const conditions = transition.conditions;

		for (let i = 0; i < conditions.length; i++) {
			const condition = conditions[i];
			const parameter = this.findParameter(condition.parameterName);

			switch (condition.predicate) {
				case ANIM_GREATER_THAN:
					if (!(parameter.value > condition.value)) return false;
					break;

				case ANIM_LESS_THAN:
					if (!(parameter.value < condition.value)) return false;
					break;

				case ANIM_GREATER_THAN_EQUAL_TO:
					if (!(parameter.value >= condition.value)) return false;
					break;

				case ANIM_LESS_THAN_EQUAL_TO:
					if (!(parameter.value <= condition.value)) return false;
					break;

				case ANIM_EQUAL_TO:
					if (!(parameter.value === condition.value)) return false;
					break;

				case ANIM_NOT_EQUAL_TO:
					if (!(parameter.value !== condition.value)) return false;
					break;
			}
		}

		return true;
	}

	_findTransition(from, to) {
		let transitions = [];

		if (from && to) {
			transitions = transitions.concat(this._findTransitionsBetweenStates(from, to));
		} else {
			if (!this._isTransitioning) {
				transitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));
				transitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));
			} else {
				switch (this._transitionInterruptionSource) {
					case ANIM_INTERRUPTION_PREV:
						transitions = transitions.concat(this._findTransitionsFromState(this._previousStateName));
						transitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));
						break;

					case ANIM_INTERRUPTION_NEXT:
						transitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));
						transitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));
						break;

					case ANIM_INTERRUPTION_PREV_NEXT:
						transitions = transitions.concat(this._findTransitionsFromState(this._previousStateName));
						transitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));
						transitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));
						break;

					case ANIM_INTERRUPTION_NEXT_PREV:
						transitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));
						transitions = transitions.concat(this._findTransitionsFromState(this._previousStateName));
						transitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));
						break;
				}
			}
		}

		transitions = transitions.filter(transition => {
			if (transition.to === this.activeStateName) {
				return false;
			}

			if (transition.hasExitTime) {
				let progressBefore = this._getActiveStateProgressForTime(this._timeInStateBefore);

				let progress = this._getActiveStateProgressForTime(this._timeInState);

				if (transition.exitTime < 1.0 && this.activeState.loop) {
					progressBefore -= Math.floor(progressBefore);
					progress -= Math.floor(progress);
				}

				if (!(transition.exitTime > progressBefore && transition.exitTime <= progress)) {
					return null;
				}
			}

			return this._transitionHasConditionsMet(transition);
		});

		if (transitions.length > 0) {
			const transition = transitions[0];

			if (transition.to === ANIM_STATE_END) {
				const startTransition = this._findTransitionsFromState(ANIM_STATE_START)[0];

				transition.to = startTransition.to;
			}

			return transition;
		}

		return null;
	}

	updateStateFromTransition(transition) {
		let state;
		let animation;
		let clip;
		this.previousState = transition.from ? this.activeStateName : null;
		this.activeState = transition.to;

		for (let i = 0; i < transition.conditions.length; i++) {
			const condition = transition.conditions[i];
			const parameter = this.findParameter(condition.parameterName);

			if (parameter.type === ANIM_PARAMETER_TRIGGER) {
				this._consumedTriggers.add(condition.parameterName);
			}
		}

		if (this.previousState) {
			if (!this._isTransitioning) {
				this._transitionPreviousStates = [];
			}

			this._transitionPreviousStates.push({
				name: this._previousStateName,
				weight: 1
			});

			const interpolatedTime = Math.min(this._totalTransitionTime !== 0 ? this._currTransitionTime / this._totalTransitionTime : 1, 1.0);

			for (let i = 0; i < this._transitionPreviousStates.length; i++) {
				if (!this._isTransitioning) {
					this._transitionPreviousStates[i].weight = 1.0;
				} else if (i !== this._transitionPreviousStates.length - 1) {
					this._transitionPreviousStates[i].weight *= 1.0 - interpolatedTime;
				} else {
					this._transitionPreviousStates[i].weight = interpolatedTime;
				}

				state = this._findState(this._transitionPreviousStates[i].name);

				for (let j = 0; j < state.animations.length; j++) {
					animation = state.animations[j];
					clip = this._animEvaluator.findClip(animation.name + '.previous.' + i);

					if (!clip) {
						clip = this._animEvaluator.findClip(animation.name);
						clip.name = animation.name + '.previous.' + i;
					}

					if (i !== this._transitionPreviousStates.length - 1) {
						clip.pause();
					}
				}
			}
		}

		this._isTransitioning = true;
		this._totalTransitionTime = transition.time;
		this._currTransitionTime = 0;
		this._transitionInterruptionSource = transition.interruptionSource;
		const activeState = this.activeState;
		const hasTransitionOffset = transition.transitionOffset && transition.transitionOffset > 0.0 && transition.transitionOffset < 1.0;
		let timeInState = 0;
		let timeInStateBefore = 0;

		if (hasTransitionOffset) {
			const offsetTime = activeState.timelineDuration * transition.transitionOffset;
			timeInState = offsetTime;
			timeInStateBefore = offsetTime;
		}

		this._timeInState = timeInState;
		this._timeInStateBefore = timeInStateBefore;

		for (let i = 0; i < activeState.animations.length; i++) {
			clip = this._animEvaluator.findClip(activeState.animations[i].name);

			if (!clip) {
				const speed = Number.isFinite(activeState.animations[i].speed) ? activeState.animations[i].speed : activeState.speed;
				clip = new AnimClip(activeState.animations[i].animTrack, this._timeInState, speed, true, activeState.loop, this._eventHandler);
				clip.name = activeState.animations[i].name;

				this._animEvaluator.addClip(clip);
			} else {
				clip.reset();
			}

			if (transition.time > 0) {
				clip.blendWeight = 0.0;
			} else {
				clip.blendWeight = activeState.animations[i].normalizedWeight;
			}

			clip.play();

			if (hasTransitionOffset) {
				clip.time = activeState.timelineDuration * transition.transitionOffset;
			} else {
				const startTime = activeState.speed >= 0 ? 0 : this.activeStateDuration;
				clip.time = startTime;
			}
		}
	}

	_transitionToState(newStateName) {
		if (!this._findState(newStateName)) {
			return;
		}

		let transition = this._findTransition(this._activeStateName, newStateName);

		if (!transition) {
			this._animEvaluator.removeClips();

			transition = new AnimTransition({
				from: null,
				to: newStateName
			});
		}

		this.updateStateFromTransition(transition);
	}

	assignAnimation(pathString, animTrack, speed, loop) {
		const path = pathString.split('.');

		let state = this._findState(path[0]);

		if (!state) {
			state = new AnimState(this, path[0], 1.0);
			this._states[path[0]] = state;

			this._stateNames.push(path[0]);
		}

		state.addAnimation(path, animTrack);

		if (speed !== undefined) {
			state.speed = speed;
		}

		if (loop !== undefined) {
			state.loop = loop;
		}

		if (!this._playing && this._activate && this.playable) {
			this.play();
		}
	}

	removeNodeAnimations(nodeName) {
		if (ANIM_CONTROL_STATES.indexOf(nodeName) !== -1) {
			return;
		}

		const state = this._findState(nodeName);

		if (!state) {
			return;
		}

		state.animations = [];
		return true;
	}

	play(stateName) {
		if (stateName) {
			this._transitionToState(stateName);
		}

		this._playing = true;
	}

	pause() {
		this._playing = false;
	}

	reset() {
		this._previousStateName = null;
		this._activeStateName = ANIM_STATE_START;
		this._playing = false;
		this._currTransitionTime = 1.0;
		this._totalTransitionTime = 1.0;
		this._isTransitioning = false;
		this._timeInState = 0;
		this._timeInStateBefore = 0;

		this._animEvaluator.removeClips();
	}

	rebind() {
		this._animEvaluator.rebind();
	}

	update(dt) {
		if (!this._playing) {
			return;
		}

		let state;
		let animation;
		let clip;
		this._timeInStateBefore = this._timeInState;
		this._timeInState += dt;

		const transition = this._findTransition(this._activeStateName);

		if (transition) this.updateStateFromTransition(transition);

		if (this._isTransitioning) {
			this._currTransitionTime += dt;

			if (this._currTransitionTime <= this._totalTransitionTime) {
				const interpolatedTime = this._totalTransitionTime !== 0 ? this._currTransitionTime / this._totalTransitionTime : 1;

				for (let i = 0; i < this._transitionPreviousStates.length; i++) {
					state = this._findState(this._transitionPreviousStates[i].name);
					const stateWeight = this._transitionPreviousStates[i].weight;

					for (let j = 0; j < state.animations.length; j++) {
						animation = state.animations[j];
						clip = this._animEvaluator.findClip(animation.name + '.previous.' + i);

						if (clip) {
							clip.blendWeight = (1.0 - interpolatedTime) * animation.normalizedWeight * stateWeight;
						}
					}
				}

				state = this.activeState;

				for (let i = 0; i < state.animations.length; i++) {
					animation = state.animations[i];
					this._animEvaluator.findClip(animation.name).blendWeight = interpolatedTime * animation.normalizedWeight;
				}
			} else {
				this._isTransitioning = false;
				const activeClips = this.activeStateAnimations.length;
				const totalClips = this._animEvaluator.clips.length;

				for (let i = 0; i < totalClips - activeClips; i++) {
					this._animEvaluator.removeClip(0);
				}

				this._transitionPreviousStates = [];
				state = this.activeState;

				for (let i = 0; i < state.animations.length; i++) {
					animation = state.animations[i];
					clip = this._animEvaluator.findClip(animation.name);

					if (clip) {
						clip.blendWeight = animation.normalizedWeight;
					}
				}
			}
		} else {
			if (this.activeState._blendTree.constructor !== AnimNode) {
				state = this.activeState;

				for (let i = 0; i < state.animations.length; i++) {
					animation = state.animations[i];
					clip = this._animEvaluator.findClip(animation.name);

					if (clip) {
						clip.blendWeight = animation.normalizedWeight;

						if (animation.parent.syncAnimations) {
							clip.speed = animation.speed;
						}
					}
				}
			}
		}

		this._animEvaluator.update(dt);
	}

	findParameter(name) {
		return this._parameters[name];
	}

}

const v2 = new Vec2();
const v3 = new Vec3();
const v4 = new Vec4();
const c = new Color();
const q = new Quat();

class AnimComponentBinder extends DefaultAnimBinder {
	constructor(animComponent, graph, layerName, mask, layerIndex) {
		super(graph);
		this.animComponent = animComponent;
		this._mask = mask;
		this.layerName = layerName;
		this.layerIndex = layerIndex;
	}

	static _packFloat(values) {
		return values[0];
	}

	static _packBoolean(values) {
		return !!values[0];
	}

	static _packVec2(values) {
		v2.x = values[0];
		v2.y = values[1];
		return v2;
	}

	static _packVec3(values) {
		v3.x = values[0];
		v3.y = values[1];
		v3.z = values[2];
		return v3;
	}

	static _packVec4(values) {
		v4.x = values[0];
		v4.y = values[1];
		v4.z = values[2];
		v4.w = values[3];
		return v4;
	}

	static _packColor(values) {
		c.r = values[0];
		c.g = values[1];
		c.b = values[2];
		c.a = values[3];
		return c;
	}

	static _packQuat(values) {
		q.x = values[0];
		q.y = values[1];
		q.z = values[2];
		q.w = values[3];
		return q;
	}

	resolve(path) {
		const encodedPath = AnimBinder.encode(path.entityPath, path.component, path.propertyPath);
		let target = this.targetCache[encodedPath];
		if (target) return target;
		let entity;
		let propertyComponent;
		let targetPath;

		switch (path.component) {
			case 'entity':
				entity = this._getEntityFromHierarchy(path.entityPath);
				targetPath = AnimBinder.encode(entity.path, 'entity', path.propertyPath);
				propertyComponent = entity;
				break;

			case 'graph':
				propertyComponent = this.findNode(path);
				if (!propertyComponent) return null;
				targetPath = AnimBinder.encode(propertyComponent.path, 'graph', path.propertyPath);
				break;

			default:
				entity = this._getEntityFromHierarchy(path.entityPath);
				propertyComponent = entity.findComponent(path.component);
				if (!propertyComponent) return null;
				targetPath = AnimBinder.encode(entity.path, path.component, path.propertyPath);
				break;
		}

		target = this._createAnimTargetForProperty(propertyComponent, path.propertyPath, targetPath);
		this.targetCache[encodedPath] = target;
		return target;
	}

	update(deltaTime) {
		const activeNodes = this.activeNodes;

		if (activeNodes) {
			for (let i = 0; i < activeNodes.length; i++) {
				activeNodes[i]._dirtifyLocal();
			}
		}
	}

	_getEntityFromHierarchy(entityHierarchy) {
		if (!this.animComponent.entity.name === entityHierarchy[0]) {
			return null;
		}

		const currEntity = this.animComponent.entity;

		if (entityHierarchy.length === 1) {
			return currEntity;
		}

		return currEntity._parent.findByPath(entityHierarchy);
	}

	_resolvePath(object, path, resolveLeaf) {
		const steps = path.length - (resolveLeaf ? 0 : 1);

		for (let i = 0; i < steps; i++) {
			object = object[path[i]];
		}

		return object;
	}

	_setter(object, path, packFunc) {
		const obj = this._resolvePath(object, path);

		const key = path[path.length - 1];
		const setterFunc = "set" + key.substring(0, 1).toUpperCase() + key.substring(1);

		if (obj[setterFunc]) {
			const func = obj[setterFunc].bind(obj);
			return function (values) {
				func(packFunc(values));
			};
		}

		const prop = obj[key];

		if (typeof prop === 'object' && prop.hasOwnProperty('copy')) {
			return function (values) {
				prop.copy(packFunc(values));
			};
		}

		if ([Vec2, Vec3, Vec4, Color, Quat].indexOf(obj.constructor) !== -1 && path.length > 1) {
			const parent = path.length > 2 ? this._resolvePath(object, path.slice(0, -1)) : object;
			const objKey = path[path.length - 2];
			return function (values) {
				obj[key] = packFunc(values);
				parent[objKey] = obj;
			};
		}

		return function (values) {
			obj[key] = packFunc(values);
		};
	}

	_createAnimTargetForProperty(propertyComponent, propertyHierarchy, targetPath) {
		if (this.handlers && propertyHierarchy[0] === 'weights') {
			return this.handlers.weights(propertyComponent);
		} else if (this.handlers && propertyHierarchy[0] === 'material' && propertyHierarchy.length === 2) {
			const materialPropertyName = propertyHierarchy[1];

			if (materialPropertyName.endsWith('Map')) {
				return this.handlers.materialTexture(propertyComponent, materialPropertyName);
			}
		}

		const property = this._resolvePath(propertyComponent, propertyHierarchy, true);

		if (typeof property === 'undefined') return null;
		let setter;
		let animDataType;
		let animDataComponents;

		if (typeof property === 'number') {
			setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packFloat);
			animDataType = 'vector';
			animDataComponents = 1;
		} else if (typeof property === 'boolean') {
			setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packBoolean);
			animDataType = 'vector';
			animDataComponents = 1;
		} else if (typeof property === 'object') {
			switch (property.constructor) {
				case Vec2:
					setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packVec2);
					animDataType = 'vector';
					animDataComponents = 2;
					break;

				case Vec3:
					setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packVec3);
					animDataType = 'vector';
					animDataComponents = 3;
					break;

				case Vec4:
					setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packVec4);
					animDataType = 'vector';
					animDataComponents = 4;
					break;

				case Color:
					setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packColor);
					animDataType = 'vector';
					animDataComponents = 4;
					break;

				case Quat:
					setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packQuat);
					animDataType = 'quaternion';
					animDataComponents = 4;
					break;

				default:
					return null;
			}
		}

		if (propertyHierarchy.indexOf('material') !== -1) {
			return new AnimTarget(function (values) {
				setter(values);
				propertyComponent.material.update();
			}, animDataType, animDataComponents, targetPath);
		}

		return new AnimTarget(setter, animDataType, animDataComponents, targetPath);
	}

	rebind() {
		this.targetCache = {};

		if (this.animComponent.rootBone) {
			this.graph = this.animComponent.rootBone;
		} else {
			this.graph = this.animComponent.entity;
		}

		const nodes = {};

		const flatten = function flatten(node) {
			nodes[node.name] = node;

			for (let i = 0; i < node.children.length; ++i) {
				flatten(node.children[i]);
			}
		};

		flatten(this.graph);
		this.nodes = nodes;
	}

}

class AnimComponentLayer {
	constructor(name, controller, component, weight = 1, blendType = ANIM_LAYER_OVERWRITE) {
		this._name = name;
		this._controller = controller;
		this._component = component;
		this._weight = weight;
		this._blendType = blendType;
		this._mask = null;
	}

	get name() {
		return this._name;
	}

	set playing(value) {
		this._controller.playing = value;
	}

	get playing() {
		return this._controller.playing;
	}

	get playable() {
		return this._controller.playable;
	}

	get activeState() {
		return this._controller.activeStateName;
	}

	get previousState() {
		return this._controller.previousStateName;
	}

	get activeStateProgress() {
		return this._controller.activeStateProgress;
	}

	get activeStateDuration() {
		return this._controller.activeStateDuration;
	}

	set activeStateCurrentTime(time) {
		const controller = this._controller;
		const layerPlaying = controller.playing;
		controller.playing = true;
		controller.activeStateCurrentTime = time;

		if (!layerPlaying) {
			controller.update(0);
		}

		controller.playing = layerPlaying;
	}

	get activeStateCurrentTime() {
		return this._controller.activeStateCurrentTime;
	}

	get transitioning() {
		return this._controller.transitioning;
	}

	get transitionProgress() {
		if (this.transitioning) {
			return this._controller.transitionProgress;
		}

		return null;
	}

	get states() {
		return this._controller.states;
	}

	set weight(value) {
		this._weight = value;

		this._component.dirtifyTargets();
	}

	get weight() {
		return this._weight;
	}

	set blendType(value) {
		if (value !== this._blendType) {
			this._blendType = value;

			this._component.rebind();
		}
	}

	get blendType() {
		return this._blendType;
	}

	set mask(value) {
		if (this._controller.assignMask(value)) {
			this._component.rebind();
		}

		this._mask = value;
	}

	get mask() {
		return this._mask;
	}

	play(name) {
		this._controller.play(name);
	}

	pause() {
		this._controller.pause();
	}

	reset() {
		this._controller.reset();
	}

	rebind() {
		this._controller.rebind();
	}

	update(dt) {
		this._controller.update(dt);
	}

	assignMask(mask) {
		if (this._controller.assignMask(mask)) {
			this._component.rebind();
		}

		this._mask = mask;
	}

	assignAnimation(nodePath, animTrack, speed, loop) {
		if (animTrack.constructor !== AnimTrack) {
			return;
		}

		this._controller.assignAnimation(nodePath, animTrack, speed, loop);

		if (this._controller._transitions.length === 0) {
			this._controller._transitions.push(new AnimTransition({
				from: 'START',
				to: nodePath
			}));
		}

		if (this._component.activate && this._component.playable) {
			this._component.playing = true;
		}
	}

	removeNodeAnimations(nodeName) {
		if (this._controller.removeNodeAnimations(nodeName)) {
			this._component.playing = false;
		}
	}

	getAnimationAsset(stateName) {
		return this._component.animationAssets[`${this.name}:${stateName}`];
	}

	transition(to, time = 0, transitionOffset = null) {
		this._controller.updateStateFromTransition(new AnimTransition({
			from: this._controller.activeStateName,
			to,
			time,
			transitionOffset
		}));
	}

}

class AnimComponent extends Component {
	constructor(system, entity) {
		super(system, entity);
		this._stateGraphAsset = null;
		this._animationAssets = {};
		this._speed = 1.0;
		this._activate = true;
		this._playing = false;
		this._rootBone = null;
		this._stateGraph = null;
		this._layers = [];
		this._layerIndices = {};
		this._parameters = {};
		this._targets = {};
		this._consumedTriggers = new Set();
	}

	set stateGraphAsset(value) {
		if (value === null) {
			this.removeStateGraph();
			return;
		}

		if (this._stateGraphAsset) {
			const stateGraphAsset = this.system.app.assets.get(this._stateGraphAsset);
			stateGraphAsset.off('change', this._onStateGraphAssetChangeEvent, this);
		}

		let _id;

		let _asset;

		if (value instanceof Asset) {
			_id = value.id;
			_asset = this.system.app.assets.get(_id);

			if (!_asset) {
				this.system.app.assets.add(value);
				_asset = this.system.app.assets.get(_id);
			}
		} else {
			_id = value;
			_asset = this.system.app.assets.get(_id);
		}

		if (!_asset || this._stateGraphAsset === _id) {
			return;
		}

		if (_asset.resource) {
			this._stateGraph = _asset.resource;
			this.loadStateGraph(this._stateGraph);

			_asset.on('change', this._onStateGraphAssetChangeEvent, this);
		} else {
			_asset.once('load', asset => {
				this._stateGraph = asset.resource;
				this.loadStateGraph(this._stateGraph);
			});

			_asset.on('change', this._onStateGraphAssetChangeEvent, this);

			this.system.app.assets.load(_asset);
		}

		this._stateGraphAsset = _id;
	}

	get stateGraphAsset() {
		return this._stateGraphAsset;
	}

	set animationAssets(value) {
		this._animationAssets = value;
		this.loadAnimationAssets();
	}

	get animationAssets() {
		return this._animationAssets;
	}

	set speed(value) {
		this._speed = value;
	}

	get speed() {
		return this._speed;
	}

	set activate(value) {
		this._activate = value;
	}

	get activate() {
		return this._activate;
	}

	set playing(value) {
		this._playing = value;
	}

	get playing() {
		return this._playing;
	}

	set rootBone(value) {
		if (typeof value === 'string') {
			const entity = this.entity.root.findByGuid(value);
			this._rootBone = entity;
		} else if (value instanceof Entity) {
			this._rootBone = value;
		} else {
			this._rootBone = null;
		}

		this.rebind();
	}

	get rootBone() {
		return this._rootBone;
	}

	set stateGraph(value) {
		this._stateGraph = value;
	}

	get stateGraph() {
		return this._stateGraph;
	}

	get layers() {
		return this._layers;
	}

	set layerIndices(value) {
		this._layerIndices = value;
	}

	get layerIndices() {
		return this._layerIndices;
	}

	set parameters(value) {
		this._parameters = value;
	}

	get parameters() {
		return this._parameters;
	}

	set targets(value) {
		this._targets = value;
	}

	get targets() {
		return this._targets;
	}

	get playable() {
		for (let i = 0; i < this._layers.length; i++) {
			if (!this._layers[i].playable) {
				return false;
			}
		}

		return true;
	}

	get baseLayer() {
		if (this._layers.length > 0) {
			return this._layers[0];
		}

		return null;
	}

	_onStateGraphAssetChangeEvent(asset) {
		const prevAnimationAssets = this.animationAssets;
		const prevMasks = this.layers.map(layer => layer.mask);
		this.removeStateGraph();
		this._stateGraph = new AnimStateGraph(asset._data);
		this.loadStateGraph(this._stateGraph);
		this.animationAssets = prevAnimationAssets;
		this.loadAnimationAssets();
		this.layers.forEach((layer, i) => {
			layer.mask = prevMasks[i];
		});
		this.rebind();
	}

	dirtifyTargets() {
		const targets = Object.values(this._targets);

		for (let i = 0; i < targets.length; i++) {
			targets[i].dirty = true;
		}
	}

	_addLayer({
		name,
		states,
		transitions,
		weight,
		mask,
		blendType
	}) {
		let graph;

		if (this.rootBone) {
			graph = this.rootBone;
		} else {
			graph = this.entity;
		}

		const layerIndex = this._layers.length;
		const animBinder = new AnimComponentBinder(this, graph, name, mask, layerIndex);
		const animEvaluator = new AnimEvaluator(animBinder);
		const controller = new AnimController(animEvaluator, states, transitions, this._parameters, this._activate, this, this._consumedTriggers);

		this._layers.push(new AnimComponentLayer(name, controller, this, weight, blendType));

		this._layerIndices[name] = layerIndex;
		return this._layers[layerIndex];
	}

	addLayer(name, weight, mask, blendType) {
		const layer = this.findAnimationLayer(name);
		if (layer) return layer;
		const states = [{
			"name": "START",
			"speed": 1
		}];
		const transitions = [];
		return this._addLayer({
			name,
			states,
			transitions,
			weight,
			mask,
			blendType
		});
	}

	loadStateGraph(stateGraph) {
		this._stateGraph = stateGraph;
		this._parameters = {};
		const paramKeys = Object.keys(stateGraph.parameters);

		for (let i = 0; i < paramKeys.length; i++) {
			const paramKey = paramKeys[i];
			this._parameters[paramKey] = {
				type: stateGraph.parameters[paramKey].type,
				value: stateGraph.parameters[paramKey].value
			};
		}

		this._layers = [];

		for (let i = 0; i < stateGraph.layers.length; i++) {
			const layer = stateGraph.layers[i];

			this._addLayer.bind(this)(_extends({}, layer));
		}

		this.setupAnimationAssets();
	}

	setupAnimationAssets() {
		for (let i = 0; i < this._layers.length; i++) {
			const layer = this._layers[i];
			const layerName = layer.name;

			for (let j = 0; j < layer.states.length; j++) {
				const stateName = layer.states[j];

				if (ANIM_CONTROL_STATES.indexOf(stateName) === -1) {
					const stateKey = layerName + ':' + stateName;

					if (!this._animationAssets[stateKey]) {
						this._animationAssets[stateKey] = {
							asset: null
						};
					}
				}
			}
		}

		this.loadAnimationAssets();
	}

	loadAnimationAssets() {
		for (let i = 0; i < this._layers.length; i++) {
			const layer = this._layers[i];

			for (let j = 0; j < layer.states.length; j++) {
				const stateName = layer.states[j];
				if (ANIM_CONTROL_STATES.indexOf(stateName) !== -1) continue;
				const animationAsset = this._animationAssets[layer.name + ':' + stateName];

				if (!animationAsset || !animationAsset.asset) {
					this.removeNodeAnimations(stateName, layer.name);
					continue;
				}

				const assetId = animationAsset.asset;
				const asset = this.system.app.assets.get(assetId);

				if (asset) {
					if (asset.resource) {
						this.onAnimationAssetLoaded(layer.name, stateName, asset);
					} else {
						asset.once('load', function (layerName, stateName) {
							return function (asset) {
								this.onAnimationAssetLoaded(layerName, stateName, asset);
							}.bind(this);
						}.bind(this)(layer.name, stateName));
						this.system.app.assets.load(asset);
					}
				}
			}
		}
	}

	onAnimationAssetLoaded(layerName, stateName, asset) {
		const animTrack = asset.resource;

		if (asset.data.events) {
			animTrack.events = new AnimEvents(Object.values(asset.data.events));
		}

		this.findAnimationLayer(layerName).assignAnimation(stateName, asset.resource);
	}

	removeStateGraph() {
		this._stateGraph = null;
		this._stateGraphAsset = null;
		this._animationAssets = {};
		this._layers = [];
		this._layerIndices = {};
		this._parameters = {};
		this._playing = false;
	}

	resetStateGraph() {
		if (this.stateGraphAsset) {
			const stateGraph = this.system.app.assets.get(this.stateGraphAsset).resource;
			this.loadStateGraph(stateGraph);
		} else {
			this.removeStateGraph();
		}
	}

	reset() {
		this._parameters = Object.assign({}, this._stateGraph.parameters);

		for (let i = 0; i < this._layers.length; i++) {
			const layerPlaying = this._layers[i].playing;

			this._layers[i].reset();

			this._layers[i].playing = layerPlaying;
		}
	}

	rebind() {
		this._targets = {};

		for (let i = 0; i < this._layers.length; i++) {
			this._layers[i].rebind();
		}
	}

	findAnimationLayer(name) {
		const layerIndex = this._layerIndices[name];
		return this._layers[layerIndex] || null;
	}

	addAnimationState(nodeName, animTrack, speed = 1, loop = true, layerName = 'Base') {
		if (!this._stateGraph) {
			this.loadStateGraph(new AnimStateGraph({
				"layers": [{
					"name": layerName,
					"states": [{
						"name": "START",
						"speed": 1
					}, {
						"name": nodeName,
						"speed": speed,
						"loop": loop,
						"defaultState": true
					}],
					"transitions": [{
						"from": 'START',
						"to": nodeName
					}]
				}],
				"parameters": {}
			}));
		}

		const layer = this.findAnimationLayer(layerName);

		if (layer) {
			layer.assignAnimation(nodeName, animTrack, speed, loop);
		} else {
			var _this$addLayer;

			(_this$addLayer = this.addLayer(layerName)) == null ? void 0 : _this$addLayer.assignAnimation(nodeName, animTrack, speed, loop);
		}
	}

	assignAnimation(nodePath, animTrack, layerName, speed = 1, loop = true) {
		if (!this._stateGraph && nodePath.indexOf('.') === -1) {
			this.loadStateGraph(new AnimStateGraph({
				"layers": [{
					"name": "Base",
					"states": [{
						"name": "START",
						"speed": 1
					}, {
						"name": nodePath,
						"speed": speed,
						"loop": loop,
						"defaultState": true
					}],
					"transitions": [{
						"from": 'START',
						"to": nodePath
					}]
				}],
				"parameters": {}
			}));
			this.baseLayer.assignAnimation(nodePath, animTrack);
			return;
		}

		const layer = layerName ? this.findAnimationLayer(layerName) : this.baseLayer;

		if (!layer) {
			return;
		}

		layer.assignAnimation(nodePath, animTrack, speed, loop);
	}

	removeNodeAnimations(nodeName, layerName) {
		const layer = layerName ? this.findAnimationLayer(layerName) : this.baseLayer;

		if (!layer) {
			return;
		}

		layer.removeNodeAnimations(nodeName);
	}

	getParameterValue(name, type) {
		const param = this._parameters[name];

		if (param && param.type === type) {
			return param.value;
		}
	}

	setParameterValue(name, type, value) {
		const param = this._parameters[name];

		if (param && param.type === type) {
			param.value = value;
			return;
		}
	}

	getFloat(name) {
		return this.getParameterValue(name, ANIM_PARAMETER_FLOAT);
	}

	setFloat(name, value) {
		this.setParameterValue(name, ANIM_PARAMETER_FLOAT, value);
	}

	getInteger(name) {
		return this.getParameterValue(name, ANIM_PARAMETER_INTEGER);
	}

	setInteger(name, value) {
		if (typeof value === 'number' && value % 1 === 0) {
			this.setParameterValue(name, ANIM_PARAMETER_INTEGER, value);
		}
	}

	getBoolean(name) {
		return this.getParameterValue(name, ANIM_PARAMETER_BOOLEAN);
	}

	setBoolean(name, value) {
		this.setParameterValue(name, ANIM_PARAMETER_BOOLEAN, !!value);
	}

	getTrigger(name) {
		return this.getParameterValue(name, ANIM_PARAMETER_TRIGGER);
	}

	setTrigger(name, singleFrame = false) {
		this.setParameterValue(name, ANIM_PARAMETER_TRIGGER, true);

		if (singleFrame) {
			this._consumedTriggers.add(name);
		}
	}

	resetTrigger(name) {
		this.setParameterValue(name, ANIM_PARAMETER_TRIGGER, false);
	}

	onBeforeRemove() {
		if (Number.isFinite(this._stateGraphAsset)) {
			const stateGraphAsset = this.system.app.assets.get(this._stateGraphAsset);
			stateGraphAsset.off('change', this._onStateGraphAssetChangeEvent, this);
		}
	}

	update(dt) {
		for (let i = 0; i < this.layers.length; i++) {
			this.layers[i].update(dt * this.speed);
		}

		this._consumedTriggers.forEach(trigger => {
			this.parameters[trigger].value = false;
		});

		this._consumedTriggers.clear();
	}

	resolveDuplicatedEntityReferenceProperties(oldAnim, duplicatedIdsMap) {
		if (oldAnim.rootBone && duplicatedIdsMap[oldAnim.rootBone.getGuid()]) {
			this.rootBone = duplicatedIdsMap[oldAnim.rootBone.getGuid()];
		} else {
			this.rebind();
		}
	}

}

class AnimComponentData {
	constructor() {
		this.enabled = true;
	}

}

const _schema$k = ['enabled'];

class AnimComponentSystem extends ComponentSystem {
	constructor(app) {
		super(app);
		this.id = 'anim';
		this.ComponentType = AnimComponent;
		this.DataType = AnimComponentData;
		this.schema = _schema$k;
		this.on('beforeremove', this.onBeforeRemove, this);
		this.app.systems.on('animationUpdate', this.onAnimationUpdate, this);
	}

	initializeComponentData(component, data, properties) {
		super.initializeComponentData(component, data, _schema$k);
		const complexProperties = ['animationAssets', 'stateGraph', 'layers', 'masks'];
		Object.keys(data).forEach(key => {
			if (complexProperties.includes(key)) return;
			component[key] = data[key];
		});

		if (data.stateGraph) {
			component.stateGraph = data.stateGraph;
			component.loadStateGraph(component.stateGraph);
		}

		if (data.layers) {
			data.layers.forEach((layer, i) => {
				layer._controller.states.forEach(stateKey => {
					layer._controller._states[stateKey]._animationList.forEach(node => {
						component.layers[i].assignAnimation(node.name, node.animTrack);
					});
				});
			});
		} else if (data.animationAssets) {
			component.animationAssets = Object.assign(component.animationAssets, data.animationAssets);
		}

		if (data.masks) {
			Object.keys(data.masks).forEach(key => {
				if (component.layers[key]) {
					const maskData = data.masks[key].mask;
					const mask = {};
					Object.keys(maskData).forEach(maskKey => {
						mask[decodeURI(maskKey)] = maskData[maskKey];
					});
					component.layers[key].mask = mask;
				}
			});
		}
	}

	onAnimationUpdate(dt) {
		const components = this.store;

		for (const id in components) {
			if (components.hasOwnProperty(id)) {
				const component = components[id].entity.anim;
				const componentData = component.data;

				if (componentData.enabled && component.entity.enabled && component.playing) {
					component.update(dt);
				}
			}
		}
	}

	cloneComponent(entity, clone) {
		let masks;

		if (!entity.anim.rootBone || entity.anim.rootBone === entity) {
			masks = {};
			entity.anim.layers.forEach((layer, i) => {
				if (layer.mask) {
					const mask = {};
					Object.keys(layer.mask).forEach(path => {
						const pathArr = path.split('/');
						pathArr.shift();
						const clonePath = [clone.name, ...pathArr].join('/');
						mask[clonePath] = layer.mask[path];
					});
					masks[i] = {
						mask
					};
				}
			});
		}

		const data = {
			stateGraphAsset: entity.anim.stateGraphAsset,
			animationAssets: entity.anim.animationAssets,
			speed: entity.anim.speed,
			activate: entity.anim.activate,
			playing: entity.anim.playing,
			rootBone: entity.anim.rootBone,
			stateGraph: entity.anim.stateGraph,
			layers: entity.anim.layers,
			layerIndices: entity.anim.layerIndices,
			parameters: entity.anim.parameters,
			masks
		};
		return this.addComponent(clone, data);
	}

	onBeforeRemove(entity, component) {
		component.onBeforeRemove();
	}

	destroy() {
		super.destroy();
		this.app.systems.off('animationUpdate', this.onAnimationUpdate, this);
	}

}

Component._buildAccessors(AnimComponent.prototype, _schema$k);

class AudioListenerComponent extends Component {
	constructor(system, entity) {
		super(system, entity);
	}

	setCurrentListener() {
		if (this.enabled && this.entity.audiolistener && this.entity.enabled) {
			this.system.current = this.entity;
			const position = this.system.current.getPosition();
			this.system.manager.listener.setPosition(position);
		}
	}

	onEnable() {
		this.setCurrentListener();
	}

	onDisable() {
		if (this.system.current === this.entity) {
			this.system.current = null;
		}
	}

}

class AudioListenerComponentData {
	constructor() {
		this.enabled = true;
	}

}

const _schema$j = ['enabled'];

class AudioListenerComponentSystem extends ComponentSystem {
	constructor(app, manager) {
		super(app);
		this.id = "audiolistener";
		this.ComponentType = AudioListenerComponent;
		this.DataType = AudioListenerComponentData;
		this.schema = _schema$j;
		this.manager = manager;
		this.current = null;
		this.app.systems.on('update', this.onUpdate, this);
	}

	initializeComponentData(component, data, properties) {
		properties = ['enabled'];
		super.initializeComponentData(component, data, properties);
	}

	onUpdate(dt) {
		if (this.current) {
			const position = this.current.getPosition();
			this.manager.listener.setPosition(position);
			const wtm = this.current.getWorldTransform();
			this.manager.listener.setOrientation(wtm);
		}
	}

	destroy() {
		super.destroy();
		this.app.systems.off('update', this.onUpdate, this);
	}

}

Component._buildAccessors(AudioListenerComponent.prototype, _schema$j);

class AudioSourceComponent extends Component {
	constructor(system, entity) {
		super(system, entity);
		this.on("set_assets", this.onSetAssets, this);
		this.on("set_loop", this.onSetLoop, this);
		this.on("set_volume", this.onSetVolume, this);
		this.on("set_pitch", this.onSetPitch, this);
		this.on("set_minDistance", this.onSetMinDistance, this);
		this.on("set_maxDistance", this.onSetMaxDistance, this);
		this.on("set_rollOffFactor", this.onSetRollOffFactor, this);
		this.on("set_distanceModel", this.onSetDistanceModel, this);
		this.on("set_3d", this.onSet3d, this);
	}

	play(name) {
		if (!this.enabled || !this.entity.enabled) {
			return;
		}

		if (this.channel) {
			this.stop();
		}

		let channel;
		const componentData = this.data;

		if (componentData.sources[name]) {
			if (!componentData['3d']) {
				channel = this.system.manager.playSound(componentData.sources[name], componentData);
				componentData.currentSource = name;
				componentData.channel = channel;
			} else {
				const pos = this.entity.getPosition();
				channel = this.system.manager.playSound3d(componentData.sources[name], pos, componentData);
				componentData.currentSource = name;
				componentData.channel = channel;
			}
		}
	}

	pause() {
		if (this.channel) {
			this.channel.pause();
		}
	}

	unpause() {
		if (this.channel && this.channel.paused) {
			this.channel.unpause();
		}
	}

	stop() {
		if (this.channel) {
			this.channel.stop();
			this.channel = null;
		}
	}

	onSetAssets(name, oldValue, newValue) {
		const newAssets = [];
		const len = newValue.length;

		if (oldValue && oldValue.length) {
			for (let i = 0; i < oldValue.length; i++) {
				if (oldValue[i]) {
					const asset = this.system.app.assets.get(oldValue[i]);

					if (asset) {
						asset.off('change', this.onAssetChanged, this);
						asset.off('remove', this.onAssetRemoved, this);

						if (this.currentSource === asset.name) {
							this.stop();
						}
					}
				}
			}
		}

		if (len) {
			for (let i = 0; i < len; i++) {
				if (oldValue.indexOf(newValue[i]) < 0) {
					if (newValue[i] instanceof Asset) {
						newAssets.push(newValue[i].id);
					} else {
						newAssets.push(newValue[i]);
					}
				}
			}
		}

		if (!this.system._inTools && newAssets.length) {
			this.loadAudioSourceAssets(newAssets);
		}
	}

	onAssetChanged(asset, attribute, newValue, oldValue) {
		if (attribute === 'resource') {
			const sources = this.data.sources;

			if (sources) {
				this.data.sources[asset.name] = newValue;

				if (this.data.currentSource === asset.name) {
					if (this.channel) {
						if (this.channel.paused) {
							this.play(asset.name);
							this.pause();
						} else {
							this.play(asset.name);
						}
					}
				}
			}
		}
	}

	onAssetRemoved(asset) {
		asset.off('remove', this.onAssetRemoved, this);

		if (this.data.sources[asset.name]) {
			delete this.data.sources[asset.name];

			if (this.data.currentSource === asset.name) {
				this.stop();
				this.data.currentSource = null;
			}
		}
	}

	onSetLoop(name, oldValue, newValue) {
		if (oldValue !== newValue) {
			if (this.channel) {
				this.channel.setLoop(newValue);
			}
		}
	}

	onSetVolume(name, oldValue, newValue) {
		if (oldValue !== newValue) {
			if (this.channel) {
				this.channel.setVolume(newValue);
			}
		}
	}

	onSetPitch(name, oldValue, newValue) {
		if (oldValue !== newValue) {
			if (this.channel) {
				this.channel.setPitch(newValue);
			}
		}
	}

	onSetMaxDistance(name, oldValue, newValue) {
		if (oldValue !== newValue) {
			if (this.channel instanceof Channel3d) {
				this.channel.setMaxDistance(newValue);
			}
		}
	}

	onSetMinDistance(name, oldValue, newValue) {
		if (oldValue !== newValue) {
			if (this.channel instanceof Channel3d) {
				this.channel.setMinDistance(newValue);
			}
		}
	}

	onSetRollOffFactor(name, oldValue, newValue) {
		if (oldValue !== newValue) {
			if (this.channel instanceof Channel3d) {
				this.channel.setRollOffFactor(newValue);
			}
		}
	}

	onSetDistanceModel(name, oldValue, newValue) {
		if (oldValue !== newValue) {
			if (this.channel instanceof Channel3d) {
				this.channel.setDistanceModel(newValue);
			}
		}
	}

	onSet3d(name, oldValue, newValue) {
		if (oldValue !== newValue) {
			if (this.system.initialized && this.currentSource) {
				let paused = false;
				let suspended = false;

				if (this.channel) {
					paused = this.channel.paused;
					suspended = this.channel.suspended;
				}

				this.play(this.currentSource);

				if (this.channel) {
					this.channel.paused = paused;
					this.channel.suspended = suspended;
				}
			}
		}
	}

	onEnable() {
		const assets = this.data.assets;

		if (assets) {
			const registry = this.system.app.assets;

			for (let i = 0, len = assets.length; i < len; i++) {
				let asset = assets[i];
				if (!(asset instanceof Asset)) asset = registry.get(asset);

				if (asset && !asset.resource) {
					registry.load(asset);
				}
			}
		}

		if (this.system.initialized) {
			if (this.data.activate && !this.channel) {
				this.play(this.currentSource);
			} else {
				this.unpause();
			}
		}
	}

	onDisable() {
		this.pause();
	}

	loadAudioSourceAssets(ids) {
		const assets = ids.map(id => {
			return this.system.app.assets.get(id);
		});
		const sources = {};
		let currentSource = null;
		let count = assets.length;

		const _error = e => {
			count--;
		};

		const _done = () => {
			this.data.sources = sources;
			this.data.currentSource = currentSource;

			if (this.enabled && this.activate && currentSource) {
				this.onEnable();
			}
		};

		assets.forEach((asset, index) => {
			if (asset) {
				currentSource = currentSource || asset.name;
				asset.off('change', this.onAssetChanged, this);
				asset.on('change', this.onAssetChanged, this);
				asset.off('remove', this.onAssetRemoved, this);
				asset.on('remove', this.onAssetRemoved, this);
				asset.off('error', _error, this);
				asset.on('error', _error, this);
				asset.ready(asset => {
					sources[asset.name] = asset.resource;
					count--;

					if (count === 0) {
						_done();
					}
				});
				if (!asset.resource && this.enabled && this.entity.enabled) this.system.app.assets.load(asset);
			} else {
				count--;

				if (count === 0) {
					_done();
				}

				this.system.app.assets.on("add:" + ids[index], asset => {
					asset.ready(asset => {
						this.data.sources[asset.name] = asset.resource;
					});
					if (!asset.resource) this.system.app.assets.load(asset);
				});
			}
		});
	}

}

class AudioSourceComponentData {
	constructor() {
		this.enabled = true;
		this.assets = [];
		this.activate = true;
		this.volume = 1;
		this.pitch = 1;
		this.loop = false;
		this['3d'] = true;
		this.minDistance = 1;
		this.maxDistance = 10000;
		this.rollOffFactor = 1;
		this.distanceModel = DISTANCE_INVERSE;
		this.paused = true;
		this.sources = {};
		this.currentSource = null;
		this.channel = null;
	}

}

const _schema$i = ['enabled', 'assets', 'volume', 'pitch', 'loop', 'activate', '3d', 'minDistance', 'maxDistance', 'rollOffFactor', 'distanceModel', 'sources', 'currentSource', 'channel'];

class AudioSourceComponentSystem extends ComponentSystem {
	constructor(app, manager) {
		super(app);
		this.id = "audiosource";
		this.ComponentType = AudioSourceComponent;
		this.DataType = AudioSourceComponentData;
		this.schema = _schema$i;
		this.manager = manager;
		this.initialized = false;
		this.app.systems.on('initialize', this.onInitialize, this);
		this.app.systems.on('update', this.onUpdate, this);
		this.on('remove', this.onRemove, this);
	}

	initializeComponentData(component, data, properties) {
		properties = ['activate', 'volume', 'pitch', 'loop', '3d', 'minDistance', 'maxDistance', 'rollOffFactor', 'distanceModel', 'enabled', 'assets'];
		super.initializeComponentData(component, data, properties);
		component.paused = !(component.enabled && component.activate);
	}

	onInitialize(root) {
		if (root.audiosource && root.enabled && root.audiosource.enabled && root.audiosource.activate) {
			root.audiosource.play(root.audiosource.currentSource);
		}

		const children = root._children;

		for (let i = 0, len = children.length; i < len; i++) {
			if (children[i] instanceof Entity) {
				this.onInitialize(children[i]);
			}
		}

		this.initialized = true;
	}

	onUpdate(dt) {
		const components = this.store;

		for (const id in components) {
			if (components.hasOwnProperty(id)) {
				const component = components[id];
				const entity = component.entity;
				const componentData = component.data;

				if (componentData.enabled && entity.enabled && componentData.channel instanceof Channel3d) {
					const pos = entity.getPosition();
					componentData.channel.setPosition(pos);
				}
			}
		}
	}

	onRemove(entity, data) {
		if (data.channel) {
			data.channel.stop();
			data.channel = null;
		}
	}

	setVolume(volume) {
		this.manager.setVolume(volume);
	}

	destroy() {
		super.destroy();
		this.app.systems.off('initialize', this.onInitialize, this);
		this.app.systems.off('update', this.onUpdate, this);
	}

}

Component._buildAccessors(AudioSourceComponent.prototype, _schema$i);

class EntityReference extends EventHandler {
	constructor(parentComponent, entityPropertyName, eventConfig) {
		super();

		if (!parentComponent || !(parentComponent instanceof Component)) {
			throw new Error('The parentComponent argument is required and must be a Component');
		} else if (!entityPropertyName || typeof entityPropertyName !== 'string') {
			throw new Error('The propertyName argument is required and must be a string');
		} else if (eventConfig && typeof eventConfig !== 'object') {
			throw new Error('If provided, the eventConfig argument must be an object');
		}

		this._parentComponent = parentComponent;
		this._entityPropertyName = entityPropertyName;
		this._entity = null;
		this._app = parentComponent.system.app;

		this._configureEventListeners(eventConfig || {}, {
			'entity#destroy': this._onEntityDestroy
		});

		this._toggleLifecycleListeners('on');
	}

	_configureEventListeners(externalEventConfig, internalEventConfig) {
		const externalEventListenerConfigs = this._parseEventListenerConfig(externalEventConfig, 'external', this._parentComponent);

		const internalEventListenerConfigs = this._parseEventListenerConfig(internalEventConfig, 'internal', this);

		this._eventListenerConfigs = externalEventListenerConfigs.concat(internalEventListenerConfigs);
		this._listenerStatusFlags = {};
		this._gainListeners = {};
		this._loseListeners = {};
	}

	_parseEventListenerConfig(eventConfig, prefix, scope) {
		return Object.keys(eventConfig).map(function (listenerDescription, index) {
			const listenerDescriptionParts = listenerDescription.split('#');
			const sourceName = listenerDescriptionParts[0];
			const eventName = listenerDescriptionParts[1];
			const callback = eventConfig[listenerDescription];

			if (listenerDescriptionParts.length !== 2 || typeof sourceName !== 'string' || sourceName.length === 0 || typeof eventName !== 'string' || eventName.length === 0) {
				throw new Error('Invalid event listener description: `' + listenerDescription + '`');
			}

			if (typeof callback !== 'function') {
				throw new Error('Invalid or missing callback for event listener `' + listenerDescription + '`');
			}

			return {
				id: prefix + '_' + index + '_' + listenerDescription,
				sourceName: sourceName,
				eventName: eventName,
				callback: callback,
				scope: scope
			};
		}, this);
	}

	_toggleLifecycleListeners(onOrOff) {
		this._parentComponent[onOrOff]('set_' + this._entityPropertyName, this._onSetEntity, this);

		this._parentComponent.system[onOrOff]('beforeremove', this._onParentComponentRemove, this);

		this._app.systems[onOrOff]('postPostInitialize', this._updateEntityReference, this);

		this._app[onOrOff]('tools:sceneloaded', this._onSceneLoaded, this);

		const allComponentSystems = [];

		for (let i = 0; i < this._eventListenerConfigs.length; ++i) {
			const config = this._eventListenerConfigs[i];
			const componentSystem = this._app.systems[config.sourceName];

			if (componentSystem) {
				if (allComponentSystems.indexOf(componentSystem) === -1) {
					allComponentSystems.push(componentSystem);
				}

				if (componentSystem && config.eventName === 'gain') {
					this._gainListeners[config.sourceName] = config;
				}

				if (componentSystem && config.eventName === 'lose') {
					this._loseListeners[config.sourceName] = config;
				}
			}
		}

		for (let i = 0; i < allComponentSystems.length; ++i) {
			allComponentSystems[i][onOrOff]('add', this._onComponentAdd, this);
			allComponentSystems[i][onOrOff]('beforeremove', this._onComponentRemove, this);
		}
	}

	_onSetEntity(name, oldValue, newValue) {
		if (newValue instanceof Entity) {
			this._updateEntityReference();
		} else {
			if (newValue !== null && newValue !== undefined && typeof newValue !== 'string') {
				console.warn("Entity field `" + this._entityPropertyName + "` was set to unexpected type '" + typeof newValue + "'");
				return;
			}

			if (oldValue !== newValue) {
				this._updateEntityReference();
			}
		}
	}

	onParentComponentEnable() {
		if (!this._entity) {
			this._updateEntityReference();
		}
	}

	_onSceneLoaded() {
		this._updateEntityReference();
	}

	_updateEntityReference() {
		let nextEntityGuid = this._parentComponent.data[this._entityPropertyName];
		let nextEntity;

		if (nextEntityGuid instanceof Entity) {
			nextEntity = nextEntityGuid;
			nextEntityGuid = nextEntity.getGuid();
			this._parentComponent.data[this._entityPropertyName] = nextEntityGuid;
		} else {
			const root = this._parentComponent.system.app.root;

			const isOnSceneGraph = this._parentComponent.entity.isDescendantOf(root);

			nextEntity = isOnSceneGraph && nextEntityGuid ? root.findByGuid(nextEntityGuid) : null;
		}

		const hasChanged = this._entity !== nextEntity;

		if (hasChanged) {
			if (this._entity) {
				this._onBeforeEntityChange();
			}

			this._entity = nextEntity;

			if (this._entity) {
				this._onAfterEntityChange();
			}

			this.fire('set:entity', this._entity);
		}
	}

	_onBeforeEntityChange() {
		this._toggleEntityListeners('off');

		this._callAllGainOrLoseListeners(this._loseListeners);
	}

	_onAfterEntityChange() {
		this._toggleEntityListeners('on');

		this._callAllGainOrLoseListeners(this._gainListeners);
	}

	_onComponentAdd(entity, component) {
		const componentName = component.system.id;

		if (entity === this._entity) {
			this._callGainOrLoseListener(componentName, this._gainListeners);

			this._toggleComponentListeners('on', componentName);
		}
	}

	_onComponentRemove(entity, component) {
		const componentName = component.system.id;

		if (entity === this._entity) {
			this._callGainOrLoseListener(componentName, this._loseListeners);

			this._toggleComponentListeners('off', componentName, true);
		}
	}

	_callAllGainOrLoseListeners(listenerMap) {
		for (const componentName in this._entity.c) {
			this._callGainOrLoseListener(componentName, listenerMap);
		}
	}

	_callGainOrLoseListener(componentName, listenerMap) {
		if (this._entity.c.hasOwnProperty(componentName) && listenerMap[componentName]) {
			const config = listenerMap[componentName];
			config.callback.call(config.scope);
		}
	}

	_toggleEntityListeners(onOrOff, isDestroying) {
		if (this._entity) {
			for (let i = 0; i < this._eventListenerConfigs.length; ++i) {
				this._safeToggleListener(onOrOff, this._eventListenerConfigs[i], isDestroying);
			}
		}
	}

	_toggleComponentListeners(onOrOff, componentName, isDestroying) {
		for (let i = 0; i < this._eventListenerConfigs.length; ++i) {
			const config = this._eventListenerConfigs[i];

			if (config.sourceName === componentName) {
				this._safeToggleListener(onOrOff, config, isDestroying);
			}
		}
	}

	_safeToggleListener(onOrOff, config, isDestroying) {
		const isAdding = onOrOff === 'on';

		if (isAdding && this._listenerStatusFlags[config.id]) {
			return;
		}

		const source = this._getEventSource(config.sourceName, isDestroying);

		if (source) {
			source[onOrOff](config.eventName, config.callback, config.scope);
			this._listenerStatusFlags[config.id] = isAdding;
		}
	}

	_getEventSource(sourceName, isDestroying) {
		if (sourceName === 'entity') {
			return this._entity;
		}

		const component = this._entity[sourceName];

		if (component) {
			return component;
		}

		if (!isDestroying) {
			console.warn('Entity has no component with name ' + sourceName);
		}

		return null;
	}

	_onEntityDestroy(entity) {
		if (this._entity === entity) {
			this._toggleEntityListeners('off', true);

			this._entity = null;
		}
	}

	_onParentComponentRemove(entity, component) {
		if (component === this._parentComponent) {
			this._toggleLifecycleListeners('off');

			this._toggleEntityListeners('off', true);
		}
	}

	hasComponent(componentName) {
		return this._entity && this._entity.c ? !!this._entity.c[componentName] : false;
	}

	get entity() {
		return this._entity;
	}

}

const BUTTON_TRANSITION_MODE_TINT = 0;
const BUTTON_TRANSITION_MODE_SPRITE_CHANGE = 1;

const ELEMENTTYPE_GROUP = 'group';
const ELEMENTTYPE_IMAGE = 'image';
const ELEMENTTYPE_TEXT = 'text';

const VisualState = {
	DEFAULT: 'DEFAULT',
	HOVER: 'HOVER',
	PRESSED: 'PRESSED',
	INACTIVE: 'INACTIVE'
};
const STATES_TO_TINT_NAMES = {};
STATES_TO_TINT_NAMES[VisualState.DEFAULT] = '_defaultTint';
STATES_TO_TINT_NAMES[VisualState.HOVER] = 'hoverTint';
STATES_TO_TINT_NAMES[VisualState.PRESSED] = 'pressedTint';
STATES_TO_TINT_NAMES[VisualState.INACTIVE] = 'inactiveTint';
const STATES_TO_SPRITE_ASSET_NAMES = {};
STATES_TO_SPRITE_ASSET_NAMES[VisualState.DEFAULT] = '_defaultSpriteAsset';
STATES_TO_SPRITE_ASSET_NAMES[VisualState.HOVER] = 'hoverSpriteAsset';
STATES_TO_SPRITE_ASSET_NAMES[VisualState.PRESSED] = 'pressedSpriteAsset';
STATES_TO_SPRITE_ASSET_NAMES[VisualState.INACTIVE] = 'inactiveSpriteAsset';
const STATES_TO_SPRITE_FRAME_NAMES = {};
STATES_TO_SPRITE_FRAME_NAMES[VisualState.DEFAULT] = '_defaultSpriteFrame';
STATES_TO_SPRITE_FRAME_NAMES[VisualState.HOVER] = 'hoverSpriteFrame';
STATES_TO_SPRITE_FRAME_NAMES[VisualState.PRESSED] = 'pressedSpriteFrame';
STATES_TO_SPRITE_FRAME_NAMES[VisualState.INACTIVE] = 'inactiveSpriteFrame';

class ButtonComponent extends Component {
	constructor(system, entity) {
		super(system, entity);
		this._visualState = VisualState.DEFAULT;
		this._isHovering = false;
		this._hoveringCounter = 0;
		this._isPressed = false;
		this._defaultTint = new Color(1, 1, 1, 1);
		this._defaultSpriteAsset = null;
		this._defaultSpriteFrame = 0;
		this._imageReference = new EntityReference(this, 'imageEntity', {
			'element#gain': this._onImageElementGain,
			'element#lose': this._onImageElementLose,
			'element#set:color': this._onSetColor,
			'element#set:opacity': this._onSetOpacity,
			'element#set:spriteAsset': this._onSetSpriteAsset,
			'element#set:spriteFrame': this._onSetSpriteFrame
		});

		this._toggleLifecycleListeners('on', system);
	}

	_toggleLifecycleListeners(onOrOff, system) {
		this[onOrOff]('set_active', this._onSetActive, this);
		this[onOrOff]('set_transitionMode', this._onSetTransitionMode, this);
		this[onOrOff]('set_hoverTint', this._onSetTransitionValue, this);
		this[onOrOff]('set_pressedTint', this._onSetTransitionValue, this);
		this[onOrOff]('set_inactiveTint', this._onSetTransitionValue, this);
		this[onOrOff]('set_hoverSpriteAsset', this._onSetTransitionValue, this);
		this[onOrOff]('set_hoverSpriteFrame', this._onSetTransitionValue, this);
		this[onOrOff]('set_pressedSpriteAsset', this._onSetTransitionValue, this);
		this[onOrOff]('set_pressedSpriteFrame', this._onSetTransitionValue, this);
		this[onOrOff]('set_inactiveSpriteAsset', this._onSetTransitionValue, this);
		this[onOrOff]('set_inactiveSpriteFrame', this._onSetTransitionValue, this);
		system.app.systems.element[onOrOff]('add', this._onElementComponentAdd, this);
		system.app.systems.element[onOrOff]('beforeremove', this._onElementComponentRemove, this);
	}

	_onSetActive(name, oldValue, newValue) {
		if (oldValue !== newValue) {
			this._updateVisualState();
		}
	}

	_onSetTransitionMode(name, oldValue, newValue) {
		if (oldValue !== newValue) {
			this._cancelTween();

			this._resetToDefaultVisualState(oldValue);

			this._forceReapplyVisualState();
		}
	}

	_onSetTransitionValue(name, oldValue, newValue) {
		if (oldValue !== newValue) {
			this._forceReapplyVisualState();
		}
	}

	_onElementComponentRemove(entity) {
		if (this.entity === entity) {
			this._toggleHitElementListeners('off');
		}
	}

	_onElementComponentAdd(entity) {
		if (this.entity === entity) {
			this._toggleHitElementListeners('on');
		}
	}

	_onImageElementLose() {
		this._cancelTween();

		this._resetToDefaultVisualState(this.transitionMode);
	}

	_onImageElementGain() {
		this._storeDefaultVisualState();

		this._forceReapplyVisualState();
	}

	_toggleHitElementListeners(onOrOff) {
		if (this.entity.element) {
			const isAdding = onOrOff === 'on';

			if (isAdding && this._hasHitElementListeners) {
				return;
			}

			this.entity.element[onOrOff]('mouseenter', this._onMouseEnter, this);
			this.entity.element[onOrOff]('mouseleave', this._onMouseLeave, this);
			this.entity.element[onOrOff]('mousedown', this._onMouseDown, this);
			this.entity.element[onOrOff]('mouseup', this._onMouseUp, this);
			this.entity.element[onOrOff]('touchstart', this._onTouchStart, this);
			this.entity.element[onOrOff]('touchend', this._onTouchEnd, this);
			this.entity.element[onOrOff]('touchleave', this._onTouchLeave, this);
			this.entity.element[onOrOff]('touchcancel', this._onTouchCancel, this);
			this.entity.element[onOrOff]('selectstart', this._onSelectStart, this);
			this.entity.element[onOrOff]('selectend', this._onSelectEnd, this);
			this.entity.element[onOrOff]('selectenter', this._onSelectEnter, this);
			this.entity.element[onOrOff]('selectleave', this._onSelectLeave, this);
			this.entity.element[onOrOff]('click', this._onClick, this);
			this._hasHitElementListeners = isAdding;
		}
	}

	_storeDefaultVisualState() {
		if (this._imageReference.hasComponent('element')) {
			const element = this._imageReference.entity.element;

			if (element.type !== ELEMENTTYPE_GROUP) {
				this._storeDefaultColor(element.color);

				this._storeDefaultOpacity(element.opacity);

				this._storeDefaultSpriteAsset(element.spriteAsset);

				this._storeDefaultSpriteFrame(element.spriteFrame);
			}
		}
	}

	_storeDefaultColor(color) {
		this._defaultTint.r = color.r;
		this._defaultTint.g = color.g;
		this._defaultTint.b = color.b;
	}

	_storeDefaultOpacity(opacity) {
		this._defaultTint.a = opacity;
	}

	_storeDefaultSpriteAsset(spriteAsset) {
		this._defaultSpriteAsset = spriteAsset;
	}

	_storeDefaultSpriteFrame(spriteFrame) {
		this._defaultSpriteFrame = spriteFrame;
	}

	_onSetColor(color) {
		if (!this._isApplyingTint) {
			this._storeDefaultColor(color);

			this._forceReapplyVisualState();
		}
	}

	_onSetOpacity(opacity) {
		if (!this._isApplyingTint) {
			this._storeDefaultOpacity(opacity);

			this._forceReapplyVisualState();
		}
	}

	_onSetSpriteAsset(spriteAsset) {
		if (!this._isApplyingSprite) {
			this._storeDefaultSpriteAsset(spriteAsset);

			this._forceReapplyVisualState();
		}
	}

	_onSetSpriteFrame(spriteFrame) {
		if (!this._isApplyingSprite) {
			this._storeDefaultSpriteFrame(spriteFrame);

			this._forceReapplyVisualState();
		}
	}

	_onMouseEnter(event) {
		this._isHovering = true;

		this._updateVisualState();

		this._fireIfActive('mouseenter', event);
	}

	_onMouseLeave(event) {
		this._isHovering = false;
		this._isPressed = false;

		this._updateVisualState();

		this._fireIfActive('mouseleave', event);
	}

	_onMouseDown(event) {
		this._isPressed = true;

		this._updateVisualState();

		this._fireIfActive('mousedown', event);
	}

	_onMouseUp(event) {
		this._isPressed = false;

		this._updateVisualState();

		this._fireIfActive('mouseup', event);
	}

	_onTouchStart(event) {
		this._isPressed = true;

		this._updateVisualState();

		this._fireIfActive('touchstart', event);
	}

	_onTouchEnd(event) {
		event.event.preventDefault();
		this._isPressed = false;

		this._updateVisualState();

		this._fireIfActive('touchend', event);
	}

	_onTouchLeave(event) {
		this._isPressed = false;

		this._updateVisualState();

		this._fireIfActive('touchleave', event);
	}

	_onTouchCancel(event) {
		this._isPressed = false;

		this._updateVisualState();

		this._fireIfActive('touchcancel', event);
	}

	_onSelectStart(event) {
		this._isPressed = true;

		this._updateVisualState();

		this._fireIfActive('selectstart', event);
	}

	_onSelectEnd(event) {
		this._isPressed = false;

		this._updateVisualState();

		this._fireIfActive('selectend', event);
	}

	_onSelectEnter(event) {
		this._hoveringCounter++;

		if (this._hoveringCounter === 1) {
			this._isHovering = true;

			this._updateVisualState();
		}

		this._fireIfActive('selectenter', event);
	}

	_onSelectLeave(event) {
		this._hoveringCounter--;

		if (this._hoveringCounter === 0) {
			this._isHovering = false;
			this._isPressed = false;

			this._updateVisualState();
		}

		this._fireIfActive('selectleave', event);
	}

	_onClick(event) {
		this._fireIfActive('click', event);
	}

	_fireIfActive(name, event) {
		if (this.data.active) {
			this.fire(name, event);
		}
	}

	_updateVisualState(force) {
		const oldVisualState = this._visualState;

		const newVisualState = this._determineVisualState();

		if ((oldVisualState !== newVisualState || force) && this.enabled) {
			this._visualState = newVisualState;

			if (oldVisualState === VisualState.HOVER) {
				this._fireIfActive('hoverend');
			}

			if (oldVisualState === VisualState.PRESSED) {
				this._fireIfActive('pressedend');
			}

			if (newVisualState === VisualState.HOVER) {
				this._fireIfActive('hoverstart');
			}

			if (newVisualState === VisualState.PRESSED) {
				this._fireIfActive('pressedstart');
			}

			switch (this.transitionMode) {
				case BUTTON_TRANSITION_MODE_TINT:
					{
						const tintName = STATES_TO_TINT_NAMES[this._visualState];
						const tintColor = this[tintName];

						this._applyTint(tintColor);

						break;
					}

				case BUTTON_TRANSITION_MODE_SPRITE_CHANGE:
					{
						const spriteAssetName = STATES_TO_SPRITE_ASSET_NAMES[this._visualState];
						const spriteFrameName = STATES_TO_SPRITE_FRAME_NAMES[this._visualState];
						const spriteAsset = this[spriteAssetName];
						const spriteFrame = this[spriteFrameName];

						this._applySprite(spriteAsset, spriteFrame);

						break;
					}
			}
		}
	}

	_forceReapplyVisualState() {
		this._updateVisualState(true);
	}

	_resetToDefaultVisualState(transitionMode) {
		if (this._imageReference.hasComponent('element')) {
			switch (transitionMode) {
				case BUTTON_TRANSITION_MODE_TINT:
					this._cancelTween();

					this._applyTintImmediately(this._defaultTint);

					break;

				case BUTTON_TRANSITION_MODE_SPRITE_CHANGE:
					this._applySprite(this._defaultSpriteAsset, this._defaultSpriteFrame);

					break;
			}
		}
	}

	_determineVisualState() {
		if (!this.active) {
			return VisualState.INACTIVE;
		} else if (this._isPressed) {
			return VisualState.PRESSED;
		} else if (this._isHovering) {
			return VisualState.HOVER;
		}

		return VisualState.DEFAULT;
	}

	_applySprite(spriteAsset, spriteFrame) {
		spriteFrame = spriteFrame || 0;

		if (this._imageReference.hasComponent('element')) {
			this._isApplyingSprite = true;

			if (this._imageReference.entity.element.spriteAsset !== spriteAsset) {
				this._imageReference.entity.element.spriteAsset = spriteAsset;
			}

			if (this._imageReference.entity.element.spriteFrame !== spriteFrame) {
				this._imageReference.entity.element.spriteFrame = spriteFrame;
			}

			this._isApplyingSprite = false;
		}
	}

	_applyTint(tintColor) {
		this._cancelTween();

		if (this.fadeDuration === 0) {
			this._applyTintImmediately(tintColor);
		} else {
			this._applyTintWithTween(tintColor);
		}
	}

	_applyTintImmediately(tintColor) {
		if (!tintColor || !this._imageReference.hasComponent('element') || this._imageReference.entity.element.type === ELEMENTTYPE_GROUP) return;
		const color3 = toColor3(tintColor);
		this._isApplyingTint = true;
		if (!color3.equals(this._imageReference.entity.element.color)) this._imageReference.entity.element.color = color3;
		if (this._imageReference.entity.element.opacity != tintColor.a) this._imageReference.entity.element.opacity = tintColor.a;
		this._isApplyingTint = false;
	}

	_applyTintWithTween(tintColor) {
		if (!tintColor || !this._imageReference.hasComponent('element') || this._imageReference.entity.element.type === ELEMENTTYPE_GROUP) return;
		const color3 = toColor3(tintColor);
		const color = this._imageReference.entity.element.color;
		const opacity = this._imageReference.entity.element.opacity;
		if (color3.equals(color) && tintColor.a == opacity) return;
		this._tweenInfo = {
			startTime: now(),
			from: new Color(color.r, color.g, color.b, opacity),
			to: tintColor.clone(),
			lerpColor: new Color()
		};
	}

	_updateTintTween() {
		const elapsedTime = now() - this._tweenInfo.startTime;

		let elapsedProportion = this.fadeDuration === 0 ? 1 : elapsedTime / this.fadeDuration;
		elapsedProportion = math.clamp(elapsedProportion, 0, 1);

		if (Math.abs(elapsedProportion - 1) > 1e-5) {
			const lerpColor = this._tweenInfo.lerpColor;
			lerpColor.lerp(this._tweenInfo.from, this._tweenInfo.to, elapsedProportion);

			this._applyTintImmediately(new Color(lerpColor.r, lerpColor.g, lerpColor.b, lerpColor.a));
		} else {
			this._applyTintImmediately(this._tweenInfo.to);

			this._cancelTween();
		}
	}

	_cancelTween() {
		delete this._tweenInfo;
	}

	onUpdate() {
		if (this._tweenInfo) {
			this._updateTintTween();
		}
	}

	onEnable() {
		this._isHovering = false;
		this._hoveringCounter = 0;
		this._isPressed = false;

		this._imageReference.onParentComponentEnable();

		this._toggleHitElementListeners('on');

		this._forceReapplyVisualState();
	}

	onDisable() {
		this._toggleHitElementListeners('off');

		this._resetToDefaultVisualState(this.transitionMode);
	}

	onRemove() {
		this._toggleLifecycleListeners('off', this.system);

		this.onDisable();
	}

}

function toColor3(color4) {
	return new Color(color4.r, color4.g, color4.b);
}

class ButtonComponentData {
	constructor() {
		this.enabled = true;
		this.active = true;
		this.imageEntity = null;
		this.hitPadding = new Vec4();
		this.transitionMode = BUTTON_TRANSITION_MODE_TINT;
		this.hoverTint = new Color(0.75, 0.75, 0.75);
		this.pressedTint = new Color(0.5, 0.5, 0.5);
		this.inactiveTint = new Color(0.25, 0.25, 0.25);
		this.fadeDuration = 0;
		this.hoverSpriteAsset = null;
		this.hoverSpriteFrame = 0;
		this.pressedSpriteAsset = null;
		this.pressedSpriteFrame = 0;
		this.inactiveSpriteAsset = null;
		this.inactiveSpriteFrame = 0;
	}

}

const _schema$h = ['enabled', 'active', {
	name: 'imageEntity',
	type: 'entity'
}, {
	name: 'hitPadding',
	type: 'vec4'
}, 'transitionMode', {
	name: 'hoverTint',
	type: 'rgba'
}, {
	name: 'pressedTint',
	type: 'rgba'
}, {
	name: 'inactiveTint',
	type: 'rgba'
}, 'fadeDuration', 'hoverSpriteAsset', 'hoverSpriteFrame', 'pressedSpriteAsset', 'pressedSpriteFrame', 'inactiveSpriteAsset', 'inactiveSpriteFrame'];

class ButtonComponentSystem extends ComponentSystem {
	constructor(app) {
		super(app);
		this.id = 'button';
		this.ComponentType = ButtonComponent;
		this.DataType = ButtonComponentData;
		this.schema = _schema$h;
		this.on('beforeremove', this._onRemoveComponent, this);
		this.app.systems.on('update', this.onUpdate, this);
	}

	initializeComponentData(component, data, properties) {
		super.initializeComponentData(component, data, _schema$h);
	}

	onUpdate(dt) {
		const components = this.store;

		for (const id in components) {
			const entity = components[id].entity;
			const component = entity.button;

			if (component.enabled && entity.enabled) {
				component.onUpdate();
			}
		}
	}

	_onRemoveComponent(entity, component) {
		component.onRemove();
	}

	destroy() {
		super.destroy();
		this.app.systems.off('update', this.onUpdate, this);
	}

}

Component._buildAccessors(ButtonComponent.prototype, _schema$h);

let depthLayer$1;

class PostEffect {
	constructor(effect, inputTarget) {
		this.effect = effect;
		this.inputTarget = inputTarget;
		this.outputTarget = null;
		this.name = effect.constructor.name;
	}

}

class PostEffectQueue {
	constructor(app, camera) {
		this.app = app;
		this.camera = camera;
		this.destinationRenderTarget = null;
		this.effects = [];
		this.enabled = false;
		this.depthTarget = null;
		this.renderTargetScale = 1;
		this.resizeTimeout = null;
		this.resizeLast = 0;

		this._resizeTimeoutCallback = () => {
			this.resizeRenderTargets();
		};

		camera.on('set:rect', this.onCameraRectChanged, this);
	}

	_allocateColorBuffer(format, name) {
		const rect = this.camera.rect;
		const width = Math.floor(rect.z * this.app.graphicsDevice.width * this.renderTargetScale);
		const height = Math.floor(rect.w * this.app.graphicsDevice.height * this.renderTargetScale);
		const colorBuffer = new Texture(this.app.graphicsDevice, {
			name: name,
			format: format,
			width: width,
			height: height,
			mipmaps: false,
			minFilter: FILTER_NEAREST,
			magFilter: FILTER_NEAREST,
			addressU: ADDRESS_CLAMP_TO_EDGE,
			addressV: ADDRESS_CLAMP_TO_EDGE
		});
		return colorBuffer;
	}

	_createOffscreenTarget(useDepth, hdr) {
		const device = this.app.graphicsDevice;
		const format = hdr ? device.getHdrFormat() : PIXELFORMAT_R8_G8_B8_A8;
		const name = this.camera.entity.name + '-posteffect-' + this.effects.length;

		const colorBuffer = this._allocateColorBuffer(format, name);

		const useStencil = this.app.graphicsDevice.supportsStencil;
		const samples = useDepth ? device.samples : 1;
		return new RenderTarget({
			colorBuffer: colorBuffer,
			depth: useDepth,
			stencil: useStencil,
			samples: samples
		});
	}

	_resizeOffscreenTarget(rt) {
		const format = rt.colorBuffer.format;
		const name = rt.colorBuffer.name;
		rt.destroyFrameBuffers();
		rt.destroyTextureBuffers();
		rt._colorBuffer = this._allocateColorBuffer(format, name);
	}

	_destroyOffscreenTarget(rt) {
		rt.destroyTextureBuffers();
		rt.destroy();
	}

	setRenderTargetScale(scale) {
		this.renderTargetScale = scale;
		this.resizeRenderTargets();
	}

	addEffect(effect) {
		const effects = this.effects;
		const isFirstEffect = effects.length === 0;

		const inputTarget = this._createOffscreenTarget(isFirstEffect, effect.hdr);

		const newEntry = new PostEffect(effect, inputTarget);
		effects.push(newEntry);
		this._sourceTarget = newEntry.inputTarget;

		if (effects.length > 1) {
			effects[effects.length - 2].outputTarget = newEntry.inputTarget;
		}

		this._newPostEffect = effect;

		if (effect.needsDepthBuffer) {
			this._requestDepthMap();
		}

		this.enable();
		this._newPostEffect = undefined;
	}

	removeEffect(effect) {
		let index = -1;

		for (let i = 0, len = this.effects.length; i < len; i++) {
			if (this.effects[i].effect === effect) {
				index = i;
				break;
			}
		}

		if (index >= 0) {
			if (index > 0) {
				this.effects[index - 1].outputTarget = index + 1 < this.effects.length ? this.effects[index + 1].inputTarget : null;
			} else {
				if (this.effects.length > 1) {
					if (!this.effects[1].inputTarget._depth) {
						this._destroyOffscreenTarget(this.effects[1].inputTarget);

						this.effects[1].inputTarget = this._createOffscreenTarget(true, this.effects[1].hdr);
						this._sourceTarget = this.effects[1].inputTarget;
					}

					this.camera.renderTarget = this.effects[1].inputTarget;
				}
			}

			this._destroyOffscreenTarget(this.effects[index].inputTarget);

			this.effects.splice(index, 1);
		}

		if (this.enabled) {
			if (effect.needsDepthBuffer) {
				this._releaseDepthMap();
			}
		}

		if (this.effects.length === 0) {
			this.disable();
		}
	}

	_requestDepthMaps() {
		for (let i = 0, len = this.effects.length; i < len; i++) {
			const effect = this.effects[i].effect;
			if (this._newPostEffect === effect) continue;

			if (effect.needsDepthBuffer) {
				this._requestDepthMap();
			}
		}
	}

	_releaseDepthMaps() {
		for (let i = 0, len = this.effects.length; i < len; i++) {
			const effect = this.effects[i].effect;

			if (effect.needsDepthBuffer) {
				this._releaseDepthMap();
			}
		}
	}

	_requestDepthMap() {
		if (!depthLayer$1) depthLayer$1 = this.app.scene.layers.getLayerById(LAYERID_DEPTH);
		if (depthLayer$1) depthLayer$1.incrementCounter();
	}

	_releaseDepthMap() {
		if (depthLayer$1) depthLayer$1.decrementCounter();
	}

	destroy() {
		for (let i = 0, len = this.effects.length; i < len; i++) {
			this.effects[i].inputTarget.destroy();
		}

		this.effects.length = 0;
		this.disable();
	}

	enable() {
		if (!this.enabled && this.effects.length) {
			this.enabled = true;

			this._requestDepthMaps();

			this.app.graphicsDevice.on('resizecanvas', this._onCanvasResized, this);
			this.destinationRenderTarget = this.camera.renderTarget;
			this.camera.renderTarget = this.effects[0].inputTarget;

			this.camera.onPostprocessing = () => {
				if (this.enabled) {
					let rect = null;
					const len = this.effects.length;

					if (len) {
						for (let i = 0; i < len; i++) {
							const fx = this.effects[i];
							let destTarget = fx.outputTarget;

							if (i === len - 1) {
								rect = this.camera.rect;

								if (this.destinationRenderTarget) {
									destTarget = this.destinationRenderTarget;
								}
							}

							fx.effect.render(fx.inputTarget, destTarget, rect);
						}
					}
				}
			};
		}
	}

	disable() {
		if (this.enabled) {
			this.enabled = false;
			this.app.graphicsDevice.off('resizecanvas', this._onCanvasResized, this);

			this._releaseDepthMaps();

			this._destroyOffscreenTarget(this._sourceTarget);

			this.camera.renderTarget = null;
			this.camera.onPostprocessing = null;
		}
	}

	_onCanvasResized(width, height) {
		const rect = this.camera.rect;
		const device = this.app.graphicsDevice;
		this.camera.camera.aspectRatio = device.width * rect.z / (device.height * rect.w);
		if (this.resizeTimeout) return;

		if (now() - this.resizeLast > 100) {
			this.resizeRenderTargets();
		} else {
			this.resizeTimeout = setTimeout(this._resizeTimeoutCallback, 100);
		}
	}

	resizeRenderTargets() {
		if (this.resizeTimeout) {
			clearTimeout(this.resizeTimeout);
			this.resizeTimeout = null;
		}

		this.resizeLast = now();
		const rect = this.camera.rect;
		const desiredWidth = Math.floor(rect.z * this.app.graphicsDevice.width * this.renderTargetScale);
		const desiredHeight = Math.floor(rect.w * this.app.graphicsDevice.height * this.renderTargetScale);
		const effects = this.effects;

		for (let i = 0, len = effects.length; i < len; i++) {
			const fx = effects[i];

			if (fx.inputTarget.width !== desiredWidth || fx.inputTarget.height !== desiredHeight) {
				this._resizeOffscreenTarget(fx.inputTarget);
			}
		}
	}

	onCameraRectChanged(name, oldValue, newValue) {
		if (this.enabled) {
			this.resizeRenderTargets();
		}
	}

}

const properties$1 = [{
	name: 'aspectRatio',
	readonly: false
}, {
	name: 'aspectRatioMode',
	readonly: false
}, {
	name: 'calculateProjection',
	readonly: false
}, {
	name: 'calculateTransform',
	readonly: false
}, {
	name: 'clearColor',
	readonly: false
}, {
	name: 'cullFaces',
	readonly: false
}, {
	name: 'farClip',
	readonly: false
}, {
	name: 'flipFaces',
	readonly: false
}, {
	name: 'fov',
	readonly: false
}, {
	name: 'frustumCulling',
	readonly: false
}, {
	name: 'horizontalFov',
	readonly: false
}, {
	name: 'nearClip',
	readonly: false
}, {
	name: 'orthoHeight',
	readonly: false
}, {
	name: 'projection',
	readonly: false
}, {
	name: 'scissorRect',
	readonly: false
}, {
	name: 'vrDisplay',
	readonly: false
}];

class CameraComponent extends Component {
	constructor(system, entity) {
		super(system, entity);
		this.onPostprocessing = null;
		this.onPreRender = null;
		this.onPostRender = null;
		this._camera = new Camera();
		this._camera.node = entity;
		this._priority = 0;
		this._disablePostEffectsLayer = LAYERID_UI;
		this._postEffects = new PostEffectQueue(system.app, this);
	}

	get camera() {
		return this._camera;
	}

	set clearColorBuffer(value) {
		this._camera.clearColorBuffer = value;
		this.dirtyLayerCompositionCameras();
	}

	get clearColorBuffer() {
		return this._camera.clearColorBuffer;
	}

	set clearDepthBuffer(value) {
		this._camera.clearDepthBuffer = value;
		this.dirtyLayerCompositionCameras();
	}

	get clearDepthBuffer() {
		return this._camera.clearDepthBuffer;
	}

	set clearStencilBuffer(value) {
		this._camera.clearStencilBuffer = value;
		this.dirtyLayerCompositionCameras();
	}

	get clearStencilBuffer() {
		return this._camera.clearStencilBuffer;
	}

	set disablePostEffectsLayer(layer) {
		this._disablePostEffectsLayer = layer;
		this.dirtyLayerCompositionCameras();
	}

	get disablePostEffectsLayer() {
		return this._disablePostEffectsLayer;
	}

	get frustum() {
		return this._camera.frustum;
	}

	set layers(newValue) {
		const layers = this._camera.layers;

		for (let i = 0; i < layers.length; i++) {
			const layer = this.system.app.scene.layers.getLayerById(layers[i]);
			if (!layer) continue;
			layer.removeCamera(this);
		}

		this._camera.layers = newValue;
		if (!this.enabled || !this.entity.enabled) return;

		for (let i = 0; i < newValue.length; i++) {
			const layer = this.system.app.scene.layers.getLayerById(newValue[i]);
			if (!layer) continue;
			layer.addCamera(this);
		}
	}

	get layers() {
		return this._camera.layers;
	}

	get postEffectsEnabled() {
		return this._postEffects.enabled;
	}

	get postEffects() {
		return this._postEffects;
	}

	set priority(newValue) {
		this._priority = newValue;
		this.dirtyLayerCompositionCameras();
	}

	get priority() {
		return this._priority;
	}

	get projectionMatrix() {
		return this._camera.projectionMatrix;
	}

	set rect(value) {
		this._camera.rect = value;
		this.fire('set:rect', this._camera.rect);
	}

	get rect() {
		return this._camera.rect;
	}

	set renderTarget(value) {
		this._camera.renderTarget = value;
		this.dirtyLayerCompositionCameras();
	}

	get renderTarget() {
		return this._camera.renderTarget;
	}

	get viewMatrix() {
		return this._camera.viewMatrix;
	}

	dirtyLayerCompositionCameras() {
		const layerComp = this.system.app.scene.layers;
		layerComp._dirtyCameras = true;
	}

	screenToWorld(screenx, screeny, cameraz, worldCoord) {
		const device = this.system.app.graphicsDevice;
		const w = device.clientRect.width;
		const h = device.clientRect.height;
		return this._camera.screenToWorld(screenx, screeny, cameraz, w, h, worldCoord);
	}

	worldToScreen(worldCoord, screenCoord) {
		const device = this.system.app.graphicsDevice;
		const w = device.clientRect.width;
		const h = device.clientRect.height;
		return this._camera.worldToScreen(worldCoord, w, h, screenCoord);
	}

	onAppPrerender() {
		this._camera._viewMatDirty = true;
		this._camera._viewProjMatDirty = true;
	}

	addCameraToLayers() {
		const layers = this.layers;

		for (let i = 0; i < layers.length; i++) {
			const layer = this.system.app.scene.layers.getLayerById(layers[i]);

			if (layer) {
				layer.addCamera(this);
			}
		}
	}

	removeCameraFromLayers() {
		const layers = this.layers;

		for (let i = 0; i < layers.length; i++) {
			const layer = this.system.app.scene.layers.getLayerById(layers[i]);

			if (layer) {
				layer.removeCamera(this);
			}
		}
	}

	onLayersChanged(oldComp, newComp) {
		this.addCameraToLayers();
		oldComp.off("add", this.onLayerAdded, this);
		oldComp.off("remove", this.onLayerRemoved, this);
		newComp.on("add", this.onLayerAdded, this);
		newComp.on("remove", this.onLayerRemoved, this);
	}

	onLayerAdded(layer) {
		const index = this.layers.indexOf(layer.id);
		if (index < 0) return;
		layer.addCamera(this);
	}

	onLayerRemoved(layer) {
		const index = this.layers.indexOf(layer.id);
		if (index < 0) return;
		layer.removeCamera(this);
	}

	onEnable() {
		const system = this.system;
		const scene = system.app.scene;
		const layers = scene.layers;
		system.addCamera(this);
		scene.on("set:layers", this.onLayersChanged, this);

		if (layers) {
			layers.on("add", this.onLayerAdded, this);
			layers.on("remove", this.onLayerRemoved, this);
		}

		if (this.enabled && this.entity.enabled) {
			this.addCameraToLayers();
		}

		this.postEffects.enable();
	}

	onDisable() {
		const system = this.system;
		const scene = system.app.scene;
		const layers = scene.layers;
		this.postEffects.disable();
		this.removeCameraFromLayers();
		scene.off("set:layers", this.onLayersChanged, this);

		if (layers) {
			layers.off("add", this.onLayerAdded, this);
			layers.off("remove", this.onLayerRemoved, this);
		}

		system.removeCamera(this);
	}

	onRemove() {
		this.onDisable();
		this.off();
	}

	calculateAspectRatio(rt) {
		const src = rt ? rt : this.system.app.graphicsDevice;
		const rect = this.rect;
		return src.width * rect.z / (src.height * rect.w);
	}

	frameBegin(rt) {
		if (this.aspectRatioMode === ASPECT_AUTO) {
			this.aspectRatio = this.calculateAspectRatio(rt);
		}
	}

	frameEnd() {}

	enterVr(display, callback) {
		if (display instanceof Function && !callback) {
			callback = display;
			display = null;
		}

		if (!this.system.app.vr) {
			callback("VrManager not created. Enable VR in project settings.");
			return;
		}

		if (!display) {
			display = this.system.app.vr.display;
		}

		if (display) {
			const self = this;

			if (display.capabilities.canPresent) {
				display.requestPresent(function (err) {
					if (!err) {
						self.vrDisplay = display;
						self.vrDisplay.once('beforepresentchange', function (display) {
							if (!display.presenting) {
								self.vrDisplay = null;
							}
						});
					}

					callback(err);
				});
			} else {
				self.vrDisplay = display;
				callback();
			}
		} else {
			callback("No pc.VrDisplay to present");
		}
	}

	exitVr(callback) {
		if (this.vrDisplay) {
			if (this.vrDisplay.capabilities.canPresent) {
				const display = this.vrDisplay;
				this.vrDisplay = null;
				display.exitPresent(callback);
			} else {
				this.vrDisplay = null;
				callback();
			}
		} else {
			callback("Not presenting VR");
		}
	}

	startXr(type, spaceType, options) {
		this.system.app.xr.start(this, type, spaceType, options);
	}

	endXr(callback) {
		if (!this._camera.xr) {
			if (callback) callback(new Error("Camera is not in XR"));
			return;
		}

		this._camera.xr.end(callback);
	}

	copy(source) {
		properties$1.forEach(property => {
			if (!property.readonly) {
				const name = property.name;
				this[name] = source[name];
			}
		});
		this.clearColorBuffer = source.clearColorBuffer;
		this.clearDepthBuffer = source.clearDepthBuffer;
		this.clearStencilBuffer = source.clearStencilBuffer;
		this.disablePostEffectsLayer = source.disablePostEffectsLayer;
		this.layers = source.layers;
		this.priority = source.priority;
		this.renderTarget = source.renderTarget;
		this.rect = source.rect;
	}

}

properties$1.forEach(function (property) {
	const name = property.name;
	const options = {};

	options.get = function () {
		return this._camera[name];
	};

	if (!property.readonly) {
		options.set = function (newValue) {
			this._camera[name] = newValue;
		};
	}

	Object.defineProperty(CameraComponent.prototype, name, options);
});

class CameraComponentData {
	constructor() {
		this.enabled = true;
	}

}

const _schema$g = ['enabled'];

class CameraComponentSystem extends ComponentSystem {
	constructor(app) {
		super(app);
		this.cameras = [];
		this.id = 'camera';
		this.ComponentType = CameraComponent;
		this.DataType = CameraComponentData;
		this.schema = _schema$g;
		this.on('beforeremove', this.onBeforeRemove, this);
		this.app.on('prerender', this.onAppPrerender, this);
		this.app.systems.on('update', this.onUpdate, this);
	}

	initializeComponentData(component, data, properties) {
		properties = ['aspectRatio', 'aspectRatioMode', 'calculateProjection', 'calculateTransform', 'clearColor', 'clearColorBuffer', 'clearDepthBuffer', 'clearStencilBuffer', 'cullFaces', 'farClip', 'flipFaces', 'fov', 'frustumCulling', 'horizontalFov', 'layers', 'renderTarget', 'nearClip', 'orthoHeight', 'projection', 'priority', 'rect', 'scissorRect'];

		for (let i = 0; i < properties.length; i++) {
			const property = properties[i];

			if (data.hasOwnProperty(property)) {
				const value = data[property];

				switch (property) {
					case 'rect':
					case 'scissorRect':
						if (Array.isArray(value)) {
							component[property] = new Vec4(value[0], value[1], value[2], value[3]);
						} else {
							component[property] = value;
						}

						break;

					case 'clearColor':
						if (Array.isArray(value)) {
							component[property] = new Color(value[0], value[1], value[2], value[3]);
						} else {
							component[property] = value;
						}

						break;

					default:
						component[property] = value;
						break;
				}
			}
		}

		super.initializeComponentData(component, data, ['enabled']);
	}

	cloneComponent(entity, clone) {
		const c = entity.camera;
		return this.addComponent(clone, {
			aspectRatio: c.aspectRatio,
			aspectRatioMode: c.aspectRatioMode,
			calculateProjection: c.calculateProjection,
			calculateTransform: c.calculateTransform,
			clearColor: c.clearColor,
			clearColorBuffer: c.clearColorBuffer,
			clearDepthBuffer: c.clearDepthBuffer,
			clearStencilBuffer: c.clearStencilBuffer,
			cullFaces: c.cullFaces,
			enabled: c.enabled,
			farClip: c.farClip,
			flipFaces: c.flipFaces,
			fov: c.fov,
			frustumCulling: c.frustumCulling,
			horizontalFov: c.horizontalFov,
			layers: c.layers,
			renderTarget: c.renderTarget,
			nearClip: c.nearClip,
			orthoHeight: c.orthoHeight,
			projection: c.projection,
			priority: c.priority,
			rect: c.rect,
			scissorRect: c.scissorRect
		});
	}

	onBeforeRemove(entity, component) {
		this.removeCamera(component);
	}

	onUpdate(dt) {
		if (this.app.vr) {
			const components = this.store;

			for (const id in components) {
				const component = components[id];

				if (component.data.enabled && component.entity.enabled) {
					const cameraComponent = component.entity.camera;
					const vrDisplay = cameraComponent.vrDisplay;

					if (vrDisplay) {
						vrDisplay.setClipPlanes(cameraComponent.nearClip, cameraComponent.farClip);

						if (component.entity) {
							component.entity.localTransform.copy(vrDisplay.combinedViewInv);
							component.entity._dirtyLocal = false;

							component.entity._dirtifyWorld();
						}
					}
				}
			}
		}
	}

	onAppPrerender() {
		for (let i = 0, len = this.cameras.length; i < len; i++) {
			this.cameras[i].onAppPrerender();
		}
	}

	addCamera(camera) {
		this.cameras.push(camera);
		sortPriority(this.cameras);
	}

	removeCamera(camera) {
		const index = this.cameras.indexOf(camera);

		if (index >= 0) {
			this.cameras.splice(index, 1);
			sortPriority(this.cameras);
		}
	}

	destroy() {
		super.destroy();
		this.app.systems.off('update', this.onUpdate, this);
	}

}

Component._buildAccessors(CameraComponent.prototype, _schema$g);

class CollisionComponent extends Component {
	constructor(system, entity) {
		super(system, entity);
		this._compoundParent = null;
		this.entity.on('insert', this._onInsert, this);
		this.on('set_type', this.onSetType, this);
		this.on('set_halfExtents', this.onSetHalfExtents, this);
		this.on('set_radius', this.onSetRadius, this);
		this.on('set_height', this.onSetHeight, this);
		this.on('set_axis', this.onSetAxis, this);
		this.on("set_asset", this.onSetAsset, this);
		this.on("set_renderAsset", this.onSetRenderAsset, this);
		this.on("set_model", this.onSetModel, this);
		this.on("set_render", this.onSetRender, this);
	}

	onSetType(name, oldValue, newValue) {
		if (oldValue !== newValue) {
			this.system.changeType(this, oldValue, newValue);
		}
	}

	onSetHalfExtents(name, oldValue, newValue) {
		const t = this.data.type;

		if (this.data.initialized && t === 'box') {
			this.system.recreatePhysicalShapes(this);
		}
	}

	onSetRadius(name, oldValue, newValue) {
		const t = this.data.type;

		if (this.data.initialized && (t === 'sphere' || t === 'capsule' || t === 'cylinder' || t === 'cone')) {
			this.system.recreatePhysicalShapes(this);
		}
	}

	onSetHeight(name, oldValue, newValue) {
		const t = this.data.type;

		if (this.data.initialized && (t === 'capsule' || t === 'cylinder' || t === 'cone')) {
			this.system.recreatePhysicalShapes(this);
		}
	}

	onSetAxis(name, oldValue, newValue) {
		const t = this.data.type;

		if (this.data.initialized && (t === 'capsule' || t === 'cylinder' || t === 'cone')) {
			this.system.recreatePhysicalShapes(this);
		}
	}

	onSetAsset(name, oldValue, newValue) {
		const assets = this.system.app.assets;

		if (oldValue) {
			const asset = assets.get(oldValue);

			if (asset) {
				asset.off('remove', this.onAssetRemoved, this);
			}
		}

		if (newValue) {
			if (newValue instanceof Asset) {
				this.data.asset = newValue.id;
			}

			const asset = assets.get(this.data.asset);

			if (asset) {
				asset.off('remove', this.onAssetRemoved, this);
				asset.on('remove', this.onAssetRemoved, this);
			}
		}

		if (this.data.initialized && this.data.type === 'mesh') {
			if (!newValue) {
				this.data.model = null;
			}

			this.system.recreatePhysicalShapes(this);
		}
	}

	onSetRenderAsset(name, oldValue, newValue) {
		const assets = this.system.app.assets;

		if (oldValue) {
			const asset = assets.get(oldValue);

			if (asset) {
				asset.off('remove', this.onRenderAssetRemoved, this);
			}
		}

		if (newValue) {
			if (newValue instanceof Asset) {
				this.data.renderAsset = newValue.id;
			}

			const asset = assets.get(this.data.renderAsset);

			if (asset) {
				asset.off('remove', this.onRenderAssetRemoved, this);
				asset.on('remove', this.onRenderAssetRemoved, this);
			}
		}

		if (this.data.initialized && this.data.type === 'mesh') {
			if (!newValue) {
				this.data.render = null;
			}

			this.system.recreatePhysicalShapes(this);
		}
	}

	onSetModel(name, oldValue, newValue) {
		if (this.data.initialized && this.data.type === 'mesh') {
			this.system.implementations.mesh.doRecreatePhysicalShape(this);
		}
	}

	onSetRender(name, oldValue, newValue) {
		this.onSetModel(name, oldValue, newValue);
	}

	onAssetRemoved(asset) {
		asset.off('remove', this.onAssetRemoved, this);

		if (this.data.asset === asset.id) {
			this.asset = null;
		}
	}

	onRenderAssetRemoved(asset) {
		asset.off('remove', this.onRenderAssetRemoved, this);

		if (this.data.renderAsset === asset.id) {
			this.renderAsset = null;
		}
	}

	_getCompoundChildShapeIndex(shape) {
		const compound = this.data.shape;
		const shapes = compound.getNumChildShapes();

		for (let i = 0; i < shapes; i++) {
			const childShape = compound.getChildShape(i);

			if (childShape.ptr === shape.ptr) {
				return i;
			}
		}

		return null;
	}

	_onInsert(parent) {
		if (typeof Ammo === 'undefined') return;

		if (this._compoundParent) {
			this.system.recreatePhysicalShapes(this);
		} else if (!this.entity.rigidbody) {
			let ancestor = this.entity.parent;

			while (ancestor) {
				if (ancestor.collision && ancestor.collision.type === 'compound') {
					if (ancestor.collision.shape.getNumChildShapes() === 0) {
						this.system.recreatePhysicalShapes(ancestor.collision);
					} else {
						this.system.recreatePhysicalShapes(this);
					}

					break;
				}

				ancestor = ancestor.parent;
			}
		}
	}

	_updateCompound() {
		const entity = this.entity;

		if (entity._dirtyWorld) {
			let dirty = entity._dirtyLocal;
			let parent = entity;

			while (parent && !dirty) {
				if (parent.collision && parent.collision === this._compoundParent) break;
				if (parent._dirtyLocal) dirty = true;
				parent = parent.parent;
			}

			if (dirty) {
				entity.forEach(this.system.implementations.compound._updateEachDescendantTransform, entity);
				const bodyComponent = this._compoundParent.entity.rigidbody;
				if (bodyComponent) bodyComponent.activate();
			}
		}
	}

	onEnable() {
		if (this.data.type === 'mesh' && (this.data.asset || this.data.renderAsset) && this.data.initialized) {
			const asset = this.system.app.assets.get(this.data.asset || this.data.renderAsset);

			if (asset && (!asset.resource || !this.data.shape)) {
				this.system.recreatePhysicalShapes(this);
				return;
			}
		}

		if (this.entity.rigidbody) {
			if (this.entity.rigidbody.enabled) {
				this.entity.rigidbody.enableSimulation();
			}
		} else if (this._compoundParent && this !== this._compoundParent) {
			if (this._compoundParent.shape.getNumChildShapes() === 0) {
				this.system.recreatePhysicalShapes(this._compoundParent);
			} else {
				const transform = this.system._getNodeTransform(this.entity, this._compoundParent.entity);

				this._compoundParent.shape.addChildShape(transform, this.data.shape);

				Ammo.destroy(transform);
				if (this._compoundParent.entity.rigidbody) this._compoundParent.entity.rigidbody.activate();
			}
		} else if (this.entity.trigger) {
			this.entity.trigger.enable();
		}
	}

	onDisable() {
		if (this.entity.rigidbody) {
			this.entity.rigidbody.disableSimulation();
		} else if (this._compoundParent && this !== this._compoundParent) {
			if (!this._compoundParent.entity._destroying) {
				this.system._removeCompoundChild(this._compoundParent, this.data.shape);

				if (this._compoundParent.entity.rigidbody) this._compoundParent.entity.rigidbody.activate();
			}
		} else if (this.entity.trigger) {
			this.entity.trigger.disable();
		}
	}

	onBeforeRemove() {
		if (this.asset) {
			this.asset = null;
		}

		if (this.renderAsset) {
			this.renderAsset = null;
		}

		this.entity.off('insert', this._onInsert, this);
		this.off();
	}

}

class CollisionComponentData {
	constructor() {
		this.enabled = true;
		this.type = 'box';
		this.halfExtents = new Vec3(0.5, 0.5, 0.5);
		this.radius = 0.5;
		this.axis = 1;
		this.height = 2;
		this.asset = null;
		this.renderAsset = null;
		this.shape = null;
		this.model = null;
		this.render = null;
		this.initialized = false;
	}

}

const BODYTYPE_STATIC = 'static';
const BODYTYPE_DYNAMIC = 'dynamic';
const BODYTYPE_KINEMATIC = 'kinematic';
const BODYFLAG_STATIC_OBJECT = 1;
const BODYFLAG_KINEMATIC_OBJECT = 2;
const BODYFLAG_NORESPONSE_OBJECT = 4;
const BODYSTATE_ACTIVE_TAG = 1;
const BODYSTATE_ISLAND_SLEEPING = 2;
const BODYSTATE_WANTS_DEACTIVATION = 3;
const BODYSTATE_DISABLE_DEACTIVATION = 4;
const BODYSTATE_DISABLE_SIMULATION = 5;
const BODYGROUP_NONE = 0;
const BODYGROUP_DEFAULT = 1;
const BODYGROUP_DYNAMIC = 1;
const BODYGROUP_STATIC = 2;
const BODYGROUP_KINEMATIC = 4;
const BODYGROUP_ENGINE_1 = 8;
const BODYGROUP_TRIGGER = 16;
const BODYGROUP_ENGINE_2 = 32;
const BODYGROUP_ENGINE_3 = 64;
const BODYGROUP_USER_1 = 128;
const BODYGROUP_USER_2 = 256;
const BODYGROUP_USER_3 = 512;
const BODYGROUP_USER_4 = 1024;
const BODYGROUP_USER_5 = 2048;
const BODYGROUP_USER_6 = 4096;
const BODYGROUP_USER_7 = 8192;
const BODYGROUP_USER_8 = 16384;
const BODYMASK_NONE = 0;
const BODYMASK_ALL = 65535;
const BODYMASK_STATIC = 2;
const BODYMASK_NOT_STATIC = 65535 ^ 2;
const BODYMASK_NOT_STATIC_KINEMATIC = 65535 ^ (2 | 4);

let ammoVec1$1, ammoQuat$1, ammoTransform$1;

class Trigger {
	constructor(app, component, data) {
		this.entity = component.entity;
		this.component = component;
		this.app = app;

		if (typeof Ammo !== 'undefined' && !ammoVec1$1) {
			ammoVec1$1 = new Ammo.btVector3();
			ammoQuat$1 = new Ammo.btQuaternion();
			ammoTransform$1 = new Ammo.btTransform();
		}

		this.initialize(data);
	}

	initialize(data) {
		const entity = this.entity;
		const shape = data.shape;

		if (shape && typeof Ammo !== 'undefined') {
			if (entity.trigger) {
				entity.trigger.destroy();
			}

			const mass = 1;
			const pos = entity.getPosition();
			const rot = entity.getRotation();
			ammoVec1$1.setValue(pos.x, pos.y, pos.z);
			ammoQuat$1.setValue(rot.x, rot.y, rot.z, rot.w);
			ammoTransform$1.setOrigin(ammoVec1$1);
			ammoTransform$1.setRotation(ammoQuat$1);
			const body = this.app.systems.rigidbody.createBody(mass, shape, ammoTransform$1);
			body.setRestitution(0);
			body.setFriction(0);
			body.setDamping(0, 0);
			ammoVec1$1.setValue(0, 0, 0);
			body.setLinearFactor(ammoVec1$1);
			body.setAngularFactor(ammoVec1$1);
			body.setCollisionFlags(body.getCollisionFlags() | BODYFLAG_NORESPONSE_OBJECT);
			body.entity = entity;
			this.body = body;

			if (this.component.enabled && entity.enabled) {
				this.enable();
			}
		}
	}

	destroy() {
		const body = this.body;
		if (!body) return;
		this.disable();
		this.app.systems.rigidbody.destroyBody(body);
	}

	_getEntityTransform(transform) {
		const pos = this.entity.getPosition();
		const rot = this.entity.getRotation();
		ammoVec1$1.setValue(pos.x, pos.y, pos.z);
		ammoQuat$1.setValue(rot.x, rot.y, rot.z, rot.w);
		transform.setOrigin(ammoVec1$1);
		transform.setRotation(ammoQuat$1);
	}

	updateTransform() {
		this._getEntityTransform(ammoTransform$1);

		const body = this.body;
		body.setWorldTransform(ammoTransform$1);
		body.activate();
	}

	enable() {
		const body = this.body;
		if (!body) return;
		const systems = this.app.systems;
		systems.rigidbody.addBody(body, BODYGROUP_TRIGGER, BODYMASK_NOT_STATIC ^ BODYGROUP_TRIGGER);

		systems.rigidbody._triggers.push(this);

		body.forceActivationState(BODYSTATE_ACTIVE_TAG);
		this.updateTransform();
	}

	disable() {
		const body = this.body;
		if (!body) return;
		const systems = this.app.systems;

		const idx = systems.rigidbody._triggers.indexOf(this);

		if (idx > -1) {
			systems.rigidbody._triggers.splice(idx, 1);
		}

		systems.rigidbody.removeBody(body);
		body.forceActivationState(BODYSTATE_DISABLE_SIMULATION);
	}

}

const mat4 = new Mat4();
const vec3 = new Vec3();
const quat = new Quat();
const tempGraphNode = new GraphNode();
const _schema$f = ['enabled', 'type', 'halfExtents', 'radius', 'axis', 'height', 'asset', 'renderAsset', 'shape', 'model', 'render'];

class CollisionSystemImpl {
	constructor(system) {
		this.system = system;
	}

	beforeInitialize(component, data) {
		data.shape = null;
		data.model = new Model();
		data.model.graph = new GraphNode();
	}

	afterInitialize(component, data) {
		this.recreatePhysicalShapes(component);
		component.data.initialized = true;
	}

	reset(component, data) {
		this.beforeInitialize(component, data);
		this.afterInitialize(component, data);
	}

	recreatePhysicalShapes(component) {
		const entity = component.entity;
		const data = component.data;

		if (typeof Ammo !== 'undefined') {
			if (entity.trigger) {
				entity.trigger.destroy();
				delete entity.trigger;
			}

			if (data.shape) {
				if (component._compoundParent) {
					this.system._removeCompoundChild(component._compoundParent, data.shape);

					if (component._compoundParent.entity.rigidbody) component._compoundParent.entity.rigidbody.activate();
				}

				Ammo.destroy(data.shape);
				data.shape = null;
			}

			data.shape = this.createPhysicalShape(component.entity, data);
			const firstCompoundChild = !component._compoundParent;

			if (data.type === 'compound' && (!component._compoundParent || component === component._compoundParent)) {
				component._compoundParent = component;
				entity.forEach(this._addEachDescendant, component);
			} else if (data.type !== 'compound') {
				if (component._compoundParent && component === component._compoundParent) {
					entity.forEach(this.system.implementations.compound._updateEachDescendant, component);
				}

				if (!component.rigidbody) {
					component._compoundParent = null;
					let parent = entity.parent;

					while (parent) {
						if (parent.collision && parent.collision.type === 'compound') {
							component._compoundParent = parent.collision;
							break;
						}

						parent = parent.parent;
					}
				}
			}

			if (component._compoundParent) {
				if (component !== component._compoundParent) {
					if (firstCompoundChild && component._compoundParent.shape.getNumChildShapes() === 0) {
						this.system.recreatePhysicalShapes(component._compoundParent);
					} else {
						this.system.updateCompoundChildTransform(entity);
						if (component._compoundParent.entity.rigidbody) component._compoundParent.entity.rigidbody.activate();
					}
				}
			}

			if (entity.rigidbody) {
				entity.rigidbody.disableSimulation();
				entity.rigidbody.createBody();

				if (entity.enabled && entity.rigidbody.enabled) {
					entity.rigidbody.enableSimulation();
				}
			} else if (!component._compoundParent) {
				if (!entity.trigger) {
					entity.trigger = new Trigger(this.system.app, component, data);
				} else {
					entity.trigger.initialize(data);
				}
			}
		}
	}

	createPhysicalShape(entity, data) {
		return undefined;
	}

	updateTransform(component, position, rotation, scale) {
		if (component.entity.trigger) {
			component.entity.trigger.updateTransform();
		}
	}

	beforeRemove(entity, component) {
		if (component.data.shape) {
			if (component._compoundParent && !component._compoundParent.entity._destroying) {
				this.system._removeCompoundChild(component._compoundParent, component.data.shape);

				if (component._compoundParent.entity.rigidbody) component._compoundParent.entity.rigidbody.activate();
			}

			component._compoundParent = null;
			Ammo.destroy(component.data.shape);
			component.data.shape = null;
		}
	}

	remove(entity, data) {
		const app = this.system.app;

		if (entity.rigidbody && entity.rigidbody.body) {
			entity.rigidbody.disableSimulation();
		}

		if (entity.trigger) {
			entity.trigger.destroy();
			delete entity.trigger;
		}

		if (app.scene.containsModel(data.model)) {
			app.root.removeChild(data.model.graph);
			app.scene.removeModel(data.model);
		}
	}

	clone(entity, clone) {
		const src = this.system.store[entity.getGuid()];
		const data = {
			enabled: src.data.enabled,
			type: src.data.type,
			halfExtents: [src.data.halfExtents.x, src.data.halfExtents.y, src.data.halfExtents.z],
			radius: src.data.radius,
			axis: src.data.axis,
			height: src.data.height,
			asset: src.data.asset,
			renderAsset: src.data.renderAsset,
			model: src.data.model,
			render: src.data.render
		};
		return this.system.addComponent(clone, data);
	}

}

class CollisionBoxSystemImpl extends CollisionSystemImpl {
	createPhysicalShape(entity, data) {
		if (typeof Ammo !== 'undefined') {
			const he = data.halfExtents;
			const ammoHe = new Ammo.btVector3(he ? he.x : 0.5, he ? he.y : 0.5, he ? he.z : 0.5);
			const shape = new Ammo.btBoxShape(ammoHe);
			Ammo.destroy(ammoHe);
			return shape;
		}

		return undefined;
	}

}

class CollisionSphereSystemImpl extends CollisionSystemImpl {
	createPhysicalShape(entity, data) {
		if (typeof Ammo !== 'undefined') {
			return new Ammo.btSphereShape(data.radius);
		}

		return undefined;
	}

}

class CollisionCapsuleSystemImpl extends CollisionSystemImpl {
	createPhysicalShape(entity, data) {
		const axis = data.axis !== undefined ? data.axis : 1;
		const radius = data.radius || 0.5;
		const height = Math.max((data.height || 2) - 2 * radius, 0);
		let shape = null;

		if (typeof Ammo !== 'undefined') {
			switch (axis) {
				case 0:
					shape = new Ammo.btCapsuleShapeX(radius, height);
					break;

				case 1:
					shape = new Ammo.btCapsuleShape(radius, height);
					break;

				case 2:
					shape = new Ammo.btCapsuleShapeZ(radius, height);
					break;
			}
		}

		return shape;
	}

}

class CollisionCylinderSystemImpl extends CollisionSystemImpl {
	createPhysicalShape(entity, data) {
		const axis = data.axis !== undefined ? data.axis : 1;
		const radius = data.radius !== undefined ? data.radius : 0.5;
		const height = data.height !== undefined ? data.height : 1;
		let halfExtents = null;
		let shape = null;

		if (typeof Ammo !== 'undefined') {
			switch (axis) {
				case 0:
					halfExtents = new Ammo.btVector3(height * 0.5, radius, radius);
					shape = new Ammo.btCylinderShapeX(halfExtents);
					break;

				case 1:
					halfExtents = new Ammo.btVector3(radius, height * 0.5, radius);
					shape = new Ammo.btCylinderShape(halfExtents);
					break;

				case 2:
					halfExtents = new Ammo.btVector3(radius, radius, height * 0.5);
					shape = new Ammo.btCylinderShapeZ(halfExtents);
					break;
			}
		}

		if (halfExtents) Ammo.destroy(halfExtents);
		return shape;
	}

}

class CollisionConeSystemImpl extends CollisionSystemImpl {
	createPhysicalShape(entity, data) {
		const axis = data.axis !== undefined ? data.axis : 1;
		const radius = data.radius !== undefined ? data.radius : 0.5;
		const height = data.height !== undefined ? data.height : 1;
		let shape = null;

		if (typeof Ammo !== 'undefined') {
			switch (axis) {
				case 0:
					shape = new Ammo.btConeShapeX(radius, height);
					break;

				case 1:
					shape = new Ammo.btConeShape(radius, height);
					break;

				case 2:
					shape = new Ammo.btConeShapeZ(radius, height);
					break;
			}
		}

		return shape;
	}

}

class CollisionMeshSystemImpl extends CollisionSystemImpl {
	beforeInitialize(component, data) {}

	createAmmoMesh(mesh, node, shape) {
		let triMesh;

		if (this.system._triMeshCache[mesh.id]) {
			triMesh = this.system._triMeshCache[mesh.id];
		} else {
			const vb = mesh.vertexBuffer;
			const format = vb.getFormat();
			let stride;
			let positions;

			for (let i = 0; i < format.elements.length; i++) {
				const element = format.elements[i];

				if (element.name === SEMANTIC_POSITION) {
					positions = new Float32Array(vb.lock(), element.offset);
					stride = element.stride / 4;
					break;
				}
			}

			const indices = [];
			mesh.getIndices(indices);
			const numTriangles = mesh.primitive[0].count / 3;
			const v1 = new Ammo.btVector3();
			const v2 = new Ammo.btVector3();
			const v3 = new Ammo.btVector3();
			let i1, i2, i3;
			const base = mesh.primitive[0].base;
			triMesh = new Ammo.btTriangleMesh();
			this.system._triMeshCache[mesh.id] = triMesh;

			for (let i = 0; i < numTriangles; i++) {
				i1 = indices[base + i * 3] * stride;
				i2 = indices[base + i * 3 + 1] * stride;
				i3 = indices[base + i * 3 + 2] * stride;
				v1.setValue(positions[i1], positions[i1 + 1], positions[i1 + 2]);
				v2.setValue(positions[i2], positions[i2 + 1], positions[i2 + 2]);
				v3.setValue(positions[i3], positions[i3 + 1], positions[i3 + 2]);
				triMesh.addTriangle(v1, v2, v3, true);
			}

			Ammo.destroy(v1);
			Ammo.destroy(v2);
			Ammo.destroy(v3);
		}

		const useQuantizedAabbCompression = true;
		const triMeshShape = new Ammo.btBvhTriangleMeshShape(triMesh, useQuantizedAabbCompression);

		const scaling = this.system._getNodeScaling(node);

		triMeshShape.setLocalScaling(scaling);
		Ammo.destroy(scaling);

		const transform = this.system._getNodeTransform(node);

		shape.addChildShape(transform, triMeshShape);
		Ammo.destroy(transform);
	}

	createPhysicalShape(entity, data) {
		if (typeof Ammo === 'undefined') return;

		if (data.model || data.render) {
			const shape = new Ammo.btCompoundShape();

			if (data.model) {
				const meshInstances = data.model.meshInstances;

				for (let i = 0; i < meshInstances.length; i++) {
					this.createAmmoMesh(meshInstances[i].mesh, meshInstances[i].node, shape);
				}
			} else if (data.render) {
				const meshes = data.render.meshes;

				for (let i = 0; i < meshes.length; i++) {
					this.createAmmoMesh(meshes[i], tempGraphNode, shape);
				}
			}

			const entityTransform = entity.getWorldTransform();
			const scale = entityTransform.getScale();
			const vec = new Ammo.btVector3(scale.x, scale.y, scale.z);
			shape.setLocalScaling(vec);
			Ammo.destroy(vec);
			return shape;
		}
	}

	recreatePhysicalShapes(component) {
		const data = component.data;

		if (data.renderAsset || data.asset) {
			if (component.enabled && component.entity.enabled) {
				this.loadAsset(component, data.renderAsset || data.asset, data.renderAsset ? 'render' : 'model');
				return;
			}
		}

		this.doRecreatePhysicalShape(component);
	}

	loadAsset(component, id, property) {
		const data = component.data;
		const assets = this.system.app.assets;
		const asset = assets.get(id);

		if (asset) {
			asset.ready(asset => {
				data[property] = asset.resource;
				this.doRecreatePhysicalShape(component);
			});
			assets.load(asset);
		} else {
			assets.once("add:" + id, asset => {
				asset.ready(asset => {
					data[property] = asset.resource;
					this.doRecreatePhysicalShape(component);
				});
				assets.load(asset);
			});
		}
	}

	doRecreatePhysicalShape(component) {
		const entity = component.entity;
		const data = component.data;

		if (data.model || data.render) {
			this.destroyShape(data);
			data.shape = this.createPhysicalShape(entity, data);

			if (entity.rigidbody) {
				entity.rigidbody.disableSimulation();
				entity.rigidbody.createBody();

				if (entity.enabled && entity.rigidbody.enabled) {
					entity.rigidbody.enableSimulation();
				}
			} else {
				if (!entity.trigger) {
					entity.trigger = new Trigger(this.system.app, component, data);
				} else {
					entity.trigger.initialize(data);
				}
			}
		} else {
			this.beforeRemove(entity, component);
			this.remove(entity, data);
		}
	}

	updateTransform(component, position, rotation, scale) {
		if (component.shape) {
			const entityTransform = component.entity.getWorldTransform();
			const worldScale = entityTransform.getScale();
			const previousScale = component.shape.getLocalScaling();

			if (worldScale.x !== previousScale.x() || worldScale.y !== previousScale.y() || worldScale.z !== previousScale.z()) {
				this.doRecreatePhysicalShape(component);
			}
		}

		super.updateTransform(component, position, rotation, scale);
	}

	destroyShape(data) {
		if (!data.shape) return;
		const numShapes = data.shape.getNumChildShapes();

		for (let i = 0; i < numShapes; i++) {
			const shape = data.shape.getChildShape(i);
			Ammo.destroy(shape);
		}

		Ammo.destroy(data.shape);
		data.shape = null;
	}

	remove(entity, data) {
		this.destroyShape(data);
		super.remove(entity, data);
	}

}

class CollisionCompoundSystemImpl extends CollisionSystemImpl {
	createPhysicalShape(entity, data) {
		if (typeof Ammo !== 'undefined') {
			return new Ammo.btCompoundShape();
		}

		return undefined;
	}

	_addEachDescendant(entity) {
		if (!entity.collision || entity.rigidbody) return;
		entity.collision._compoundParent = this;

		if (entity !== this.entity) {
			entity.collision.system.recreatePhysicalShapes(entity.collision);
		}
	}

	_updateEachDescendant(entity) {
		if (!entity.collision) return;
		if (entity.collision._compoundParent !== this) return;
		entity.collision._compoundParent = null;

		if (entity !== this.entity && !entity.rigidbody) {
			entity.collision.system.recreatePhysicalShapes(entity.collision);
		}
	}

	_updateEachDescendantTransform(entity) {
		if (!entity.collision || entity.collision._compoundParent !== this.collision._compoundParent) return;
		this.collision.system.updateCompoundChildTransform(entity);
	}

}

class CollisionComponentSystem extends ComponentSystem {
	constructor(app) {
		super(app);
		this.id = "collision";
		this.ComponentType = CollisionComponent;
		this.DataType = CollisionComponentData;
		this.schema = _schema$f;
		this.implementations = {};
		this._triMeshCache = {};
		this.on('beforeremove', this.onBeforeRemove, this);
		this.on('remove', this.onRemove, this);
	}

	initializeComponentData(component, _data, properties) {
		properties = ['type', 'halfExtents', 'radius', 'axis', 'height', 'shape', 'model', 'asset', 'render', 'renderAsset', 'enabled'];
		const data = {};

		for (let i = 0, len = properties.length; i < len; i++) {
			const property = properties[i];
			data[property] = _data[property];
		}

		let idx;

		if (_data.hasOwnProperty('asset')) {
			idx = properties.indexOf('model');

			if (idx !== -1) {
				properties.splice(idx, 1);
			}

			idx = properties.indexOf('render');

			if (idx !== -1) {
				properties.splice(idx, 1);
			}
		} else if (_data.hasOwnProperty('model')) {
			idx = properties.indexOf('asset');

			if (idx !== -1) {
				properties.splice(idx, 1);
			}
		}

		if (!data.type) {
			data.type = component.data.type;
		}

		component.data.type = data.type;

		if (data.halfExtents && Array.isArray(data.halfExtents)) {
			data.halfExtents = new Vec3(data.halfExtents[0], data.halfExtents[1], data.halfExtents[2]);
		}

		const impl = this._createImplementation(data.type);

		impl.beforeInitialize(component, data);
		super.initializeComponentData(component, data, properties);
		impl.afterInitialize(component, data);
	}

	_createImplementation(type) {
		if (this.implementations[type] === undefined) {
			let impl;

			switch (type) {
				case 'box':
					impl = new CollisionBoxSystemImpl(this);
					break;

				case 'sphere':
					impl = new CollisionSphereSystemImpl(this);
					break;

				case 'capsule':
					impl = new CollisionCapsuleSystemImpl(this);
					break;

				case 'cylinder':
					impl = new CollisionCylinderSystemImpl(this);
					break;

				case 'cone':
					impl = new CollisionConeSystemImpl(this);
					break;

				case 'mesh':
					impl = new CollisionMeshSystemImpl(this);
					break;

				case 'compound':
					impl = new CollisionCompoundSystemImpl(this);
					break;
			}

			this.implementations[type] = impl;
		}

		return this.implementations[type];
	}

	_getImplementation(entity) {
		return this.implementations[entity.collision.data.type];
	}

	cloneComponent(entity, clone) {
		return this._getImplementation(entity).clone(entity, clone);
	}

	onBeforeRemove(entity, component) {
		this.implementations[component.data.type].beforeRemove(entity, component);
		component.onBeforeRemove();
	}

	onRemove(entity, data) {
		this.implementations[data.type].remove(entity, data);
	}

	updateCompoundChildTransform(entity) {
		this._removeCompoundChild(entity.collision._compoundParent, entity.collision.data.shape);

		if (entity.enabled && entity.collision.enabled) {
			const transform = this._getNodeTransform(entity, entity.collision._compoundParent.entity);

			entity.collision._compoundParent.shape.addChildShape(transform, entity.collision.data.shape);

			Ammo.destroy(transform);
		}
	}

	_removeCompoundChild(collision, shape) {
		if (collision.shape.removeChildShape) {
			collision.shape.removeChildShape(shape);
		} else {
			const ind = collision._getCompoundChildShapeIndex(shape);

			if (ind !== null) {
				collision.shape.removeChildShapeByIndex(ind);
			}
		}
	}

	onTransformChanged(component, position, rotation, scale) {
		this.implementations[component.data.type].updateTransform(component, position, rotation, scale);
	}

	changeType(component, previousType, newType) {
		this.implementations[previousType].beforeRemove(component.entity, component);
		this.implementations[previousType].remove(component.entity, component.data);

		this._createImplementation(newType).reset(component, component.data);
	}

	recreatePhysicalShapes(component) {
		this.implementations[component.data.type].recreatePhysicalShapes(component);
	}

	_calculateNodeRelativeTransform(node, relative) {
		if (node === relative) {
			const scale = node.getWorldTransform().getScale();
			mat4.setScale(scale.x, scale.y, scale.z);
		} else {
			this._calculateNodeRelativeTransform(node.parent, relative);

			mat4.mul(node.getLocalTransform());
		}
	}

	_getNodeScaling(node) {
		const wtm = node.getWorldTransform();
		const scl = wtm.getScale();
		return new Ammo.btVector3(scl.x, scl.y, scl.z);
	}

	_getNodeTransform(node, relative) {
		let pos, rot;

		if (relative) {
			this._calculateNodeRelativeTransform(node, relative);

			pos = vec3;
			rot = quat;
			mat4.getTranslation(pos);
			rot.setFromMat4(mat4);
		} else {
			pos = node.getPosition();
			rot = node.getRotation();
		}

		const transform = new Ammo.btTransform();
		transform.setIdentity();
		const origin = transform.getOrigin();
		origin.setValue(pos.x, pos.y, pos.z);
		const ammoQuat = new Ammo.btQuaternion();
		ammoQuat.setValue(rot.x, rot.y, rot.z, rot.w);
		transform.setRotation(ammoQuat);
		Ammo.destroy(ammoQuat);
		Ammo.destroy(origin);
		return transform;
	}

	destroy() {
		for (const key in this._triMeshCache) {
			Ammo.destroy(this._triMeshCache[key]);
		}

		this._triMeshCache = null;
		super.destroy();
	}

}

Component._buildAccessors(CollisionComponent.prototype, _schema$f);

class ComponentSystemRegistry extends EventHandler {
	constructor() {
		super();
		this.anim = void 0;
		this.animation = void 0;
		this.audiolistener = void 0;
		this.audiosource = void 0;
		this.button = void 0;
		this.camera = void 0;
		this.collision = void 0;
		this.element = void 0;
		this.joint = void 0;
		this.layoutchild = void 0;
		this.layoutgroup = void 0;
		this.light = void 0;
		this.model = void 0;
		this.particlesystem = void 0;
		this.render = void 0;
		this.rigidbody = void 0;
		this.screen = void 0;
		this.script = void 0;
		this.scrollbar = void 0;
		this.scrollview = void 0;
		this.sound = void 0;
		this.sprite = void 0;
		this.zone = void 0;
		this.list = [];
	}

	add(system) {
		const id = system.id;

		if (this[id]) {
			throw new Error(`ComponentSystem name '${id}' already registered or not allowed`);
		}

		this[id] = system;
		this.list.push(system);
	}

	remove(system) {
		const id = system.id;

		if (!this[id]) {
			throw new Error(`No ComponentSystem named '${id}' registered`);
		}

		delete this[id];
		const index = this.list.indexOf(this[id]);

		if (index !== -1) {
			this.list.splice(index, 1);
		}
	}

	destroy() {
		this.off();

		for (let i = 0; i < this.list.length; i++) {
			this.list[i].destroy();
		}
	}

}

class StencilParameters {
	constructor(options) {
		this.func = options.func === undefined ? FUNC_ALWAYS : options.func;
		this.ref = options.ref || 0;
		this.readMask = options.readMask === undefined ? 0xFF : options.readMask;
		this.writeMask = options.writeMask === undefined ? 0xFF : options.writeMask;
		this.fail = options.fail || STENCILOP_KEEP;
		this.zfail = options.zfail || STENCILOP_KEEP;
		this.zpass = options.zpass || STENCILOP_KEEP;
	}

	clone() {
		return new StencilParameters({
			func: this.func,
			ref: this.ref,
			readMask: this.readMask,
			writeMask: this.writeMask,
			fail: this.fail,
			zfail: this.zfail,
			zpass: this.zpass
		});
	}

}

class ImageRenderable {
	constructor(entity, mesh, material) {
		this._entity = entity;
		this._element = entity.element;
		this.model = new Model();
		this.node = new GraphNode();
		this.model.graph = this.node;
		this.mesh = mesh;
		this.meshInstance = new MeshInstance(this.mesh, material, this.node);
		this.meshInstance.name = 'ImageElement: ' + entity.name;
		this.meshInstance.castShadow = false;
		this.meshInstance.receiveShadow = false;
		this._meshDirty = false;
		this.model.meshInstances.push(this.meshInstance);

		this._entity.addChild(this.model.graph);

		this.model._entity = this._entity;
		this.unmaskMeshInstance = null;
	}

	destroy() {
		this.setMaterial(null);

		this._element.removeModelFromLayers(this.model);

		this.model.destroy();
		this.model = null;
		this.node = null;
		this.mesh = null;
		this.meshInstance = null;
		this._entity = null;
		this._element = null;
	}

	setMesh(mesh) {
		if (!this.meshInstance) return;
		this.mesh = mesh;
		this.meshInstance.mesh = mesh;
		this.meshInstance.visible = !!mesh;

		if (this.unmaskMeshInstance) {
			this.unmaskMeshInstance.mesh = mesh;
		}

		this.forceUpdateAabb();
	}

	setMask(mask) {
		if (!this.meshInstance) return;

		if (mask) {
			this.unmaskMeshInstance = new MeshInstance(this.mesh, this.meshInstance.material, this.node);
			this.unmaskMeshInstance.name = 'Unmask: ' + this._entity.name;
			this.unmaskMeshInstance.castShadow = false;
			this.unmaskMeshInstance.receiveShadow = false;
			this.unmaskMeshInstance.pick = false;
			this.model.meshInstances.push(this.unmaskMeshInstance);

			for (const name in this.meshInstance.parameters) {
				this.unmaskMeshInstance.setParameter(name, this.meshInstance.parameters[name].data);
			}
		} else {
			const idx = this.model.meshInstances.indexOf(this.unmaskMeshInstance);

			if (idx >= 0) {
				this.model.meshInstances.splice(idx, 1);
			}

			this.unmaskMeshInstance = null;
		}

		if (this._entity.enabled && this._element.enabled) {
			this._element.removeModelFromLayers(this.model);

			this._element.addModelToLayers(this.model);
		}
	}

	setMaterial(material) {
		if (!this.meshInstance) return;
		this.meshInstance.material = material;

		if (this.unmaskMeshInstance) {
			this.unmaskMeshInstance.material = material;
		}
	}

	setParameter(name, value) {
		if (!this.meshInstance) return;
		this.meshInstance.setParameter(name, value);

		if (this.unmaskMeshInstance) {
			this.unmaskMeshInstance.setParameter(name, value);
		}
	}

	deleteParameter(name) {
		if (!this.meshInstance) return;
		this.meshInstance.deleteParameter(name);

		if (this.unmaskMeshInstance) {
			this.unmaskMeshInstance.deleteParameter(name);
		}
	}

	setUnmaskDrawOrder() {
		if (!this.meshInstance) return;

		const getLastChild = function getLastChild(e) {
			let last;
			const c = e.children;
			const l = c.length;

			if (l) {
				for (let i = 0; i < l; i++) {
					if (c[i].element) {
						last = c[i];
					}
				}

				if (!last) return null;
				const child = getLastChild(last);

				if (child) {
					return child;
				}

				return last;
			}

			return null;
		};

		if (this.unmaskMeshInstance) {
			const lastChild = getLastChild(this._entity);

			if (lastChild && lastChild.element) {
				this.unmaskMeshInstance.drawOrder = lastChild.element.drawOrder + lastChild.element.getMaskOffset();
			} else {
				this.unmaskMeshInstance.drawOrder = this.meshInstance.drawOrder + this._element.getMaskOffset();
			}
		}
	}

	setDrawOrder(drawOrder) {
		if (!this.meshInstance) return;
		this.meshInstance.drawOrder = drawOrder;
	}

	setCull(cull) {
		if (!this.meshInstance) return;
		const element = this._element;
		let visibleFn = null;

		if (cull && element._isScreenCulled()) {
			visibleFn = function (camera) {
				return element.isVisibleForCamera(camera);
			};
		}

		this.meshInstance.cull = cull;
		this.meshInstance.isVisibleFunc = visibleFn;

		if (this.unmaskMeshInstance) {
			this.unmaskMeshInstance.cull = cull;
			this.unmaskMeshInstance.isVisibleFunc = visibleFn;
		}
	}

	setScreenSpace(screenSpace) {
		if (!this.meshInstance) return;
		this.meshInstance.screenSpace = screenSpace;

		if (this.unmaskMeshInstance) {
			this.unmaskMeshInstance.screenSpace = screenSpace;
		}
	}

	setLayer(layer) {
		if (!this.meshInstance) return;
		this.meshInstance.layer = layer;

		if (this.unmaskMeshInstance) {
			this.unmaskMeshInstance.layer = layer;
		}
	}

	forceUpdateAabb(mask) {
		if (!this.meshInstance) return;
		this.meshInstance._aabbVer = -1;

		if (this.unmaskMeshInstance) {
			this.unmaskMeshInstance._aabbVer = -1;
		}
	}

	setAabbFunc(fn) {
		if (!this.meshInstance) return;
		this.meshInstance._updateAabbFunc = fn;

		if (this.unmaskMeshInstance) {
			this.unmaskMeshInstance._updateAabbFunc = fn;
		}
	}

}

class ImageElement {
	constructor(element) {
		this._element = element;
		this._entity = element.entity;
		this._system = element.system;
		this._textureAsset = null;
		this._texture = null;
		this._materialAsset = null;
		this._material = null;
		this._spriteAsset = null;
		this._sprite = null;
		this._spriteFrame = 0;
		this._pixelsPerUnit = null;
		this._rect = new Vec4(0, 0, 1, 1);
		this._mask = false;
		this._maskRef = 0;
		this._outerScale = new Vec2();
		this._outerScaleUniform = new Float32Array(2);
		this._innerOffset = new Vec4();
		this._innerOffsetUniform = new Float32Array(4);
		this._atlasRect = new Vec4();
		this._atlasRectUniform = new Float32Array(4);
		this._defaultMesh = this._createMesh();
		this._renderable = new ImageRenderable(this._entity, this._defaultMesh, this._material);
		this._color = new Color(1, 1, 1, 1);
		this._colorUniform = new Float32Array([1, 1, 1]);

		this._renderable.setParameter('material_emissive', this._colorUniform);

		this._renderable.setParameter('material_opacity', 1);

		this._updateAabbFunc = this._updateAabb.bind(this);

		this._onScreenChange(this._element.screen);

		this._element.on('resize', this._onParentResizeOrPivotChange, this);

		this._element.on('set:pivot', this._onParentResizeOrPivotChange, this);

		this._element.on('screen:set:screenspace', this._onScreenSpaceChange, this);

		this._element.on('set:screen', this._onScreenChange, this);

		this._element.on('set:draworder', this._onDrawOrderChange, this);

		this._element.on('screen:set:resolution', this._onResolutionChange, this);
	}

	destroy() {
		this.textureAsset = null;
		this.spriteAsset = null;
		this.materialAsset = null;

		this._renderable.setMesh(this._defaultMesh);

		this._renderable.destroy();

		this._defaultMesh = null;

		this._element.off('resize', this._onParentResizeOrPivotChange, this);

		this._element.off('set:pivot', this._onParentResizeOrPivotChange, this);

		this._element.off('screen:set:screenspace', this._onScreenSpaceChange, this);

		this._element.off('set:screen', this._onScreenChange, this);

		this._element.off('set:draworder', this._onDrawOrderChange, this);

		this._element.off('screen:set:resolution', this._onResolutionChange, this);
	}

	_onResolutionChange(res) {}

	_onParentResizeOrPivotChange() {
		if (this._renderable.mesh) {
			this._updateMesh(this._renderable.mesh);
		}
	}

	_onScreenSpaceChange(value) {
		this._updateMaterial(value);
	}

	_onScreenChange(screen, previous) {
		if (screen) {
			this._updateMaterial(screen.screen.screenSpace);
		} else {
			this._updateMaterial(false);
		}
	}

	_onDrawOrderChange(order) {
		this._renderable.setDrawOrder(order);

		if (this.mask && this._element.screen) {
			this._element.screen.screen.once('syncdraworder', function () {
				this._renderable.setUnmaskDrawOrder();
			}, this);
		}
	}

	_hasUserMaterial() {
		return !!this._materialAsset || !!this._material && this._system.defaultImageMaterials.indexOf(this._material) === -1;
	}

	_use9Slicing() {
		return this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED);
	}

	_updateMaterial(screenSpace) {
		const mask = !!this._mask;
		const nineSliced = !!(this.sprite && this.sprite.renderMode === SPRITE_RENDERMODE_SLICED);
		const nineTiled = !!(this.sprite && this.sprite.renderMode === SPRITE_RENDERMODE_TILED);

		if (!this._hasUserMaterial()) {
			this._material = this._system.getImageElementMaterial(screenSpace, mask, nineSliced, nineTiled);
		}

		if (this._renderable) {
			this._renderable.setCull(true);

			this._renderable.setMaterial(this._material);

			this._renderable.setScreenSpace(screenSpace);

			this._renderable.setLayer(screenSpace ? LAYER_HUD : LAYER_WORLD);
		}
	}

	_createMesh() {
		const element = this._element;
		const w = element.calculatedWidth;
		const h = element.calculatedHeight;
		const r = this._rect;
		const vertexData = new ArrayBuffer(4 * 8 * 4);
		const vertexDataF32 = new Float32Array(vertexData);
		vertexDataF32[5] = 1;
		vertexDataF32[6] = r.x;
		vertexDataF32[7] = 1.0 - r.y;
		vertexDataF32[8] = w;
		vertexDataF32[13] = 1;
		vertexDataF32[14] = r.x + r.z;
		vertexDataF32[15] = 1.0 - r.y;
		vertexDataF32[16] = w;
		vertexDataF32[17] = h;
		vertexDataF32[21] = 1;
		vertexDataF32[22] = r.x + r.z;
		vertexDataF32[23] = 1.0 - (r.y + r.w);
		vertexDataF32[25] = h;
		vertexDataF32[29] = 1;
		vertexDataF32[30] = r.x;
		vertexDataF32[31] = 1.0 - (r.y + r.w);
		const vertexDesc = [{
			semantic: SEMANTIC_POSITION,
			components: 3,
			type: TYPE_FLOAT32
		}, {
			semantic: SEMANTIC_NORMAL,
			components: 3,
			type: TYPE_FLOAT32
		}, {
			semantic: SEMANTIC_TEXCOORD0,
			components: 2,
			type: TYPE_FLOAT32
		}];
		const device = this._system.app.graphicsDevice;
		const vertexFormat = new VertexFormat(device, vertexDesc);
		const vertexBuffer = new VertexBuffer(device, vertexFormat, 4, BUFFER_STATIC, vertexData);
		const mesh = new Mesh(device);
		mesh.vertexBuffer = vertexBuffer;
		mesh.primitive[0].type = PRIMITIVE_TRIFAN;
		mesh.primitive[0].base = 0;
		mesh.primitive[0].count = 4;
		mesh.primitive[0].indexed = false;
		mesh.aabb.setMinMax(Vec3.ZERO, new Vec3(w, h, 0));

		this._updateMesh(mesh);

		return mesh;
	}

	_updateMesh(mesh) {
		const element = this._element;
		const w = element.calculatedWidth;
		const h = element.calculatedHeight;

		const screenSpace = element._isScreenSpace();

		this._updateMaterial(screenSpace);

		if (this._renderable) this._renderable.forceUpdateAabb();

		if (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED)) {
			const frameData = this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]];
			const borderWidthScale = 2 / frameData.rect.z;
			const borderHeightScale = 2 / frameData.rect.w;

			this._innerOffset.set(frameData.border.x * borderWidthScale, frameData.border.y * borderHeightScale, frameData.border.z * borderWidthScale, frameData.border.w * borderHeightScale);

			const tex = this.sprite.atlas.texture;

			this._atlasRect.set(frameData.rect.x / tex.width, frameData.rect.y / tex.height, frameData.rect.z / tex.width, frameData.rect.w / tex.height);

			const ppu = this._pixelsPerUnit !== null ? this._pixelsPerUnit : this.sprite.pixelsPerUnit;
			const scaleMulX = frameData.rect.z / ppu;
			const scaleMulY = frameData.rect.w / ppu;

			this._outerScale.set(Math.max(w, this._innerOffset.x * scaleMulX), Math.max(h, this._innerOffset.y * scaleMulY));

			let scaleX = scaleMulX;
			let scaleY = scaleMulY;
			this._outerScale.x /= scaleMulX;
			this._outerScale.y /= scaleMulY;
			scaleX *= math.clamp(w / (this._innerOffset.x * scaleMulX), 0.0001, 1);
			scaleY *= math.clamp(h / (this._innerOffset.y * scaleMulY), 0.0001, 1);

			if (this._renderable) {
				this._innerOffsetUniform[0] = this._innerOffset.x;
				this._innerOffsetUniform[1] = this._innerOffset.y;
				this._innerOffsetUniform[2] = this._innerOffset.z;
				this._innerOffsetUniform[3] = this._innerOffset.w;

				this._renderable.setParameter('innerOffset', this._innerOffsetUniform);

				this._atlasRectUniform[0] = this._atlasRect.x;
				this._atlasRectUniform[1] = this._atlasRect.y;
				this._atlasRectUniform[2] = this._atlasRect.z;
				this._atlasRectUniform[3] = this._atlasRect.w;

				this._renderable.setParameter('atlasRect', this._atlasRectUniform);

				this._outerScaleUniform[0] = this._outerScale.x;
				this._outerScaleUniform[1] = this._outerScale.y;

				this._renderable.setParameter('outerScale', this._outerScaleUniform);

				this._renderable.setAabbFunc(this._updateAabbFunc);

				this._renderable.node.setLocalScale(scaleX, scaleY, 1);

				this._renderable.node.setLocalPosition((0.5 - element.pivot.x) * w, (0.5 - element.pivot.y) * h, 0);
			}
		} else {
			const vb = mesh.vertexBuffer;
			const vertexDataF32 = new Float32Array(vb.lock());
			const hp = element.pivot.x;
			const vp = element.pivot.y;
			vertexDataF32[0] = 0 - hp * w;
			vertexDataF32[1] = 0 - vp * h;
			vertexDataF32[8] = w - hp * w;
			vertexDataF32[9] = 0 - vp * h;
			vertexDataF32[16] = w - hp * w;
			vertexDataF32[17] = h - vp * h;
			vertexDataF32[24] = 0 - hp * w;
			vertexDataF32[25] = h - vp * h;
			let atlasTextureWidth = 1;
			let atlasTextureHeight = 1;
			let rect = this._rect;

			if (this._sprite && this._sprite.frameKeys[this._spriteFrame] && this._sprite.atlas) {
				const frame = this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]];

				if (frame) {
					rect = frame.rect;
					atlasTextureWidth = this._sprite.atlas.texture.width;
					atlasTextureHeight = this._sprite.atlas.texture.height;
				}
			}

			vertexDataF32[6] = rect.x / atlasTextureWidth;
			vertexDataF32[7] = 1.0 - rect.y / atlasTextureHeight;
			vertexDataF32[14] = (rect.x + rect.z) / atlasTextureWidth;
			vertexDataF32[15] = 1.0 - rect.y / atlasTextureHeight;
			vertexDataF32[22] = (rect.x + rect.z) / atlasTextureWidth;
			vertexDataF32[23] = 1.0 - (rect.y + rect.w) / atlasTextureHeight;
			vertexDataF32[30] = rect.x / atlasTextureWidth;
			vertexDataF32[31] = 1.0 - (rect.y + rect.w) / atlasTextureHeight;
			vb.unlock();
			const min = new Vec3(0 - hp * w, 0 - vp * h, 0);
			const max = new Vec3(w - hp * w, h - vp * h, 0);
			mesh.aabb.setMinMax(min, max);

			if (this._renderable) {
				this._renderable.node.setLocalScale(1, 1, 1);

				this._renderable.node.setLocalPosition(0, 0, 0);

				this._renderable.setAabbFunc(null);
			}
		}

		this._meshDirty = false;
	}

	_updateSprite() {
		let nineSlice = false;
		let mesh = null;

		if (this._sprite && this._sprite.atlas) {
			mesh = this._sprite.meshes[this.spriteFrame];
			nineSlice = this._sprite.renderMode === SPRITE_RENDERMODE_SLICED || this._sprite.renderMode === SPRITE_RENDERMODE_TILED;
		}

		this.mesh = nineSlice ? mesh : this._defaultMesh;

		if (this.mesh) {
			if (!this._element._beingInitialized) {
				this._updateMesh(this.mesh);
			} else {
				this._meshDirty = true;
			}
		}
	}

	_updateAabb(aabb) {
		aabb.center.set(0, 0, 0);
		aabb.halfExtents.set(this._outerScale.x * 0.5, this._outerScale.y * 0.5, 0.001);
		aabb.setFromTransformedAabb(aabb, this._renderable.node.getWorldTransform());
		return aabb;
	}

	_toggleMask() {
		this._element._dirtifyMask();

		const screenSpace = this._element._isScreenSpace();

		this._updateMaterial(screenSpace);

		this._renderable.setMask(!!this._mask);
	}

	_onMaterialLoad(asset) {
		this.material = asset.resource;
	}

	_onMaterialAdded(asset) {
		this._system.app.assets.off('add:' + asset.id, this._onMaterialAdded, this);

		if (this._materialAsset === asset.id) {
			this._bindMaterialAsset(asset);
		}
	}

	_bindMaterialAsset(asset) {
		if (!this._entity.enabled) return;
		asset.on("load", this._onMaterialLoad, this);
		asset.on("change", this._onMaterialChange, this);
		asset.on("remove", this._onMaterialRemove, this);

		if (asset.resource) {
			this._onMaterialLoad(asset);
		} else {
			this._system.app.assets.load(asset);
		}
	}

	_unbindMaterialAsset(asset) {
		asset.off("load", this._onMaterialLoad, this);
		asset.off("change", this._onMaterialChange, this);
		asset.off("remove", this._onMaterialRemove, this);
	}

	_onMaterialChange() {}

	_onMaterialRemove() {}

	_onTextureAdded(asset) {
		this._system.app.assets.off('add:' + asset.id, this._onTextureAdded, this);

		if (this._textureAsset === asset.id) {
			this._bindTextureAsset(asset);
		}
	}

	_bindTextureAsset(asset) {
		if (!this._entity.enabled) return;
		asset.on("load", this._onTextureLoad, this);
		asset.on("change", this._onTextureChange, this);
		asset.on("remove", this._onTextureRemove, this);

		if (asset.resource) {
			this._onTextureLoad(asset);
		} else {
			this._system.app.assets.load(asset);
		}
	}

	_unbindTextureAsset(asset) {
		asset.off("load", this._onTextureLoad, this);
		asset.off("change", this._onTextureChange, this);
		asset.off("remove", this._onTextureRemove, this);
	}

	_onTextureLoad(asset) {
		this.texture = asset.resource;
	}

	_onTextureChange(asset) {}

	_onTextureRemove(asset) {}

	_onSpriteAssetAdded(asset) {
		this._system.app.assets.off('add:' + asset.id, this._onSpriteAssetAdded, this);

		if (this._spriteAsset === asset.id) {
			this._bindSpriteAsset(asset);
		}
	}

	_bindSpriteAsset(asset) {
		if (!this._entity.enabled) return;
		asset.on("load", this._onSpriteAssetLoad, this);
		asset.on("change", this._onSpriteAssetChange, this);
		asset.on("remove", this._onSpriteAssetRemove, this);

		if (asset.resource) {
			this._onSpriteAssetLoad(asset);
		} else {
			this._system.app.assets.load(asset);
		}
	}

	_unbindSpriteAsset(asset) {
		asset.off("load", this._onSpriteAssetLoad, this);
		asset.off("change", this._onSpriteAssetChange, this);
		asset.off("remove", this._onSpriteAssetRemove, this);

		if (asset.data.textureAtlasAsset) {
			this._system.app.assets.off("load:" + asset.data.textureAtlasAsset, this._onTextureAtlasLoad, this);
		}
	}

	_onSpriteAssetLoad(asset) {
		if (!asset || !asset.resource) {
			this.sprite = null;
		} else {
			if (!asset.resource.atlas) {
				const atlasAssetId = asset.data.textureAtlasAsset;

				if (atlasAssetId) {
					const assets = this._system.app.assets;
					assets.off('load:' + atlasAssetId, this._onTextureAtlasLoad, this);
					assets.once('load:' + atlasAssetId, this._onTextureAtlasLoad, this);
				}
			} else {
				this.sprite = asset.resource;
			}
		}
	}

	_onSpriteAssetChange(asset) {
		this._onSpriteAssetLoad(asset);
	}

	_onSpriteAssetRemove(asset) {}

	_bindSprite(sprite) {
		sprite.on('set:meshes', this._onSpriteMeshesChange, this);
		sprite.on('set:pixelsPerUnit', this._onSpritePpuChange, this);
		sprite.on('set:atlas', this._onAtlasTextureChange, this);

		if (sprite.atlas) {
			sprite.atlas.on('set:texture', this._onAtlasTextureChange, this);
		}
	}

	_unbindSprite(sprite) {
		sprite.off('set:meshes', this._onSpriteMeshesChange, this);
		sprite.off('set:pixelsPerUnit', this._onSpritePpuChange, this);
		sprite.off('set:atlas', this._onAtlasTextureChange, this);

		if (sprite.atlas) {
			sprite.atlas.off('set:texture', this._onAtlasTextureChange, this);
		}
	}

	_onSpriteMeshesChange() {
		if (this._sprite) {
			this._spriteFrame = math.clamp(this._spriteFrame, 0, this._sprite.frameKeys.length - 1);
		}

		this._updateSprite();
	}

	_onSpritePpuChange() {
		if (this.sprite.renderMode !== SPRITE_RENDERMODE_SIMPLE && this._pixelsPerUnit === null) {
			this._updateSprite();
		}
	}

	_onAtlasTextureChange() {
		if (this.sprite && this.sprite.atlas && this.sprite.atlas.texture) {
			this._renderable.setParameter('texture_emissiveMap', this._sprite.atlas.texture);

			this._renderable.setParameter('texture_opacityMap', this._sprite.atlas.texture);
		} else {
			this._renderable.deleteParameter('texture_emissiveMap');

			this._renderable.deleteParameter('texture_opacityMap');
		}
	}

	_onTextureAtlasLoad(atlasAsset) {
		const spriteAsset = this._spriteAsset;

		if (spriteAsset instanceof Asset) {
			this._onSpriteAssetLoad(spriteAsset);
		} else {
			this._onSpriteAssetLoad(this._system.app.assets.get(spriteAsset));
		}
	}

	onEnable() {
		if (this._materialAsset) {
			const asset = this._system.app.assets.get(this._materialAsset);

			if (asset && asset.resource !== this._material) {
				this._bindMaterialAsset(asset);
			}
		}

		if (this._textureAsset) {
			const asset = this._system.app.assets.get(this._textureAsset);

			if (asset && asset.resource !== this._texture) {
				this._bindTextureAsset(asset);
			}
		}

		if (this._spriteAsset) {
			const asset = this._system.app.assets.get(this._spriteAsset);

			if (asset && asset.resource !== this._sprite) {
				this._bindSpriteAsset(asset);
			}
		}

		this._element.addModelToLayers(this._renderable.model);
	}

	onDisable() {
		this._element.removeModelFromLayers(this._renderable.model);
	}

	_setStencil(stencilParams) {
		this._renderable.meshInstance.stencilFront = stencilParams;
		this._renderable.meshInstance.stencilBack = stencilParams;
		let ref = 0;

		if (this._element.maskedBy) {
			ref = this._element.maskedBy.element._image._maskRef;
		}

		if (this._renderable.unmaskMeshInstance) {
			const sp = new StencilParameters({
				ref: ref + 1,
				func: FUNC_EQUAL,
				zpass: STENCILOP_DECREMENT
			});
			this._renderable.unmaskMeshInstance.stencilFront = sp;
			this._renderable.unmaskMeshInstance.stencilBack = sp;
		}
	}

	set color(value) {
		const r = value.r;
		const g = value.g;
		const b = value.b;

		if (this._color.r !== r || this._color.g !== g || this._color.b !== b) {
			this._color.r = r;
			this._color.g = g;
			this._color.b = b;
			this._colorUniform[0] = r;
			this._colorUniform[1] = g;
			this._colorUniform[2] = b;

			this._renderable.setParameter('material_emissive', this._colorUniform);
		}

		if (this._element) {
			this._element.fire('set:color', this._color);
		}
	}

	get color() {
		return this._color;
	}

	set opacity(value) {
		if (value !== this._color.a) {
			this._color.a = value;

			this._renderable.setParameter('material_opacity', value);
		}

		if (this._element) {
			this._element.fire('set:opacity', value);
		}
	}

	get opacity() {
		return this._color.a;
	}

	set rect(value) {
		let x, y, z, w;

		if (value instanceof Vec4) {
			x = value.x;
			y = value.y;
			z = value.z;
			w = value.w;
		} else {
			x = value[0];
			y = value[1];
			z = value[2];
			w = value[3];
		}

		if (x === this._rect.x && y === this._rect.y && z === this._rect.z && w === this._rect.w) {
			return;
		}

		this._rect.set(x, y, z, w);

		if (this._renderable.mesh) {
			if (!this._element._beingInitialized) {
				this._updateMesh(this._renderable.mesh);
			} else {
				this._meshDirty = true;
			}
		}
	}

	get rect() {
		return this._rect;
	}

	set material(value) {
		if (this._material === value) return;

		if (!value) {
			const screenSpace = this._element._isScreenSpace();

			if (this.mask) {
				value = screenSpace ? this._system.defaultScreenSpaceImageMaskMaterial : this._system.defaultImageMaskMaterial;
			} else {
				value = screenSpace ? this._system.defaultScreenSpaceImageMaterial : this._system.defaultImageMaterial;
			}
		}

		this._material = value;

		if (value) {
			this._renderable.setMaterial(value);

			if (this._hasUserMaterial()) {
				this._renderable.deleteParameter('material_opacity');

				this._renderable.deleteParameter('material_emissive');
			} else {
				this._colorUniform[0] = this._color.r;
				this._colorUniform[1] = this._color.g;
				this._colorUniform[2] = this._color.b;

				this._renderable.setParameter('material_emissive', this._colorUniform);

				this._renderable.setParameter('material_opacity', this._color.a);
			}
		}
	}

	get material() {
		return this._material;
	}

	set materialAsset(value) {
		const assets = this._system.app.assets;
		let _id = value;

		if (value instanceof Asset) {
			_id = value.id;
		}

		if (this._materialAsset !== _id) {
			if (this._materialAsset) {
				assets.off('add:' + this._materialAsset, this._onMaterialAdded, this);

				const _prev = assets.get(this._materialAsset);

				if (_prev) {
					_prev.off("load", this._onMaterialLoad, this);

					_prev.off("change", this._onMaterialChange, this);

					_prev.off("remove", this._onMaterialRemove, this);
				}
			}

			this._materialAsset = _id;

			if (this._materialAsset) {
				const asset = assets.get(this._materialAsset);

				if (!asset) {
					this.material = null;
					assets.on('add:' + this._materialAsset, this._onMaterialAdded, this);
				} else {
					this._bindMaterialAsset(asset);
				}
			} else {
				this.material = null;
			}
		}
	}

	get materialAsset() {
		return this._materialAsset;
	}

	set texture(value) {
		if (this._texture === value) return;

		if (this._textureAsset) {
			const textureAsset = this._system.app.assets.get(this._textureAsset);

			if (textureAsset && textureAsset.resource !== value) {
				this.textureAsset = null;
			}
		}

		this._texture = value;

		if (value) {
			if (this._spriteAsset) {
				this.spriteAsset = null;
			}

			this._renderable.setParameter("texture_emissiveMap", this._texture);

			this._renderable.setParameter("texture_opacityMap", this._texture);

			this._colorUniform[0] = this._color.r;
			this._colorUniform[1] = this._color.g;
			this._colorUniform[2] = this._color.b;

			this._renderable.setParameter("material_emissive", this._colorUniform);

			this._renderable.setParameter("material_opacity", this._color.a);
		} else {
			this._renderable.deleteParameter("texture_emissiveMap");

			this._renderable.deleteParameter("texture_opacityMap");
		}
	}

	get texture() {
		return this._texture;
	}

	set textureAsset(value) {
		const assets = this._system.app.assets;
		let _id = value;

		if (value instanceof Asset) {
			_id = value.id;
		}

		if (this._textureAsset !== _id) {
			if (this._textureAsset) {
				assets.off('add:' + this._textureAsset, this._onTextureAdded, this);

				const _prev = assets.get(this._textureAsset);

				if (_prev) {
					_prev.off("load", this._onTextureLoad, this);

					_prev.off("change", this._onTextureChange, this);

					_prev.off("remove", this._onTextureRemove, this);
				}
			}

			this._textureAsset = _id;

			if (this._textureAsset) {
				const asset = assets.get(this._textureAsset);

				if (!asset) {
					this.texture = null;
					assets.on('add:' + this._textureAsset, this._onTextureAdded, this);
				} else {
					this._bindTextureAsset(asset);
				}
			} else {
				this.texture = null;
			}
		}
	}

	get textureAsset() {
		return this._textureAsset;
	}

	set spriteAsset(value) {
		const assets = this._system.app.assets;
		let _id = value;

		if (value instanceof Asset) {
			_id = value.id;
		}

		if (this._spriteAsset !== _id) {
			if (this._spriteAsset) {
				assets.off('add:' + this._spriteAsset, this._onSpriteAssetAdded, this);

				const _prev = assets.get(this._spriteAsset);

				if (_prev) {
					this._unbindSpriteAsset(_prev);
				}
			}

			this._spriteAsset = _id;

			if (this._spriteAsset) {
				const asset = assets.get(this._spriteAsset);

				if (!asset) {
					this.sprite = null;
					assets.on('add:' + this._spriteAsset, this._onSpriteAssetAdded, this);
				} else {
					this._bindSpriteAsset(asset);
				}
			} else {
				this.sprite = null;
			}
		}

		if (this._element) {
			this._element.fire('set:spriteAsset', _id);
		}
	}

	get spriteAsset() {
		return this._spriteAsset;
	}

	set sprite(value) {
		if (this._sprite === value) return;

		if (this._sprite) {
			this._unbindSprite(this._sprite);
		}

		if (this._spriteAsset) {
			const spriteAsset = this._system.app.assets.get(this._spriteAsset);

			if (spriteAsset && spriteAsset.resource !== value) {
				this.spriteAsset = null;
			}
		}

		this._sprite = value;

		if (this._sprite) {
			this._bindSprite(this._sprite);

			if (this._textureAsset) {
				this.textureAsset = null;
			}
		}

		if (this._sprite && this._sprite.atlas && this._sprite.atlas.texture) {
			this._renderable.setParameter("texture_emissiveMap", this._sprite.atlas.texture);

			this._renderable.setParameter("texture_opacityMap", this._sprite.atlas.texture);
		} else {
			this._renderable.deleteParameter("texture_emissiveMap");

			this._renderable.deleteParameter("texture_opacityMap");
		}

		if (this._sprite) {
			this._spriteFrame = math.clamp(this._spriteFrame, 0, this._sprite.frameKeys.length - 1);
		}

		this._updateSprite();
	}

	get sprite() {
		return this._sprite;
	}

	set spriteFrame(value) {
		const oldValue = this._spriteFrame;

		if (this._sprite) {
			this._spriteFrame = math.clamp(value, 0, this._sprite.frameKeys.length - 1);
		} else {
			this._spriteFrame = value;
		}

		if (this._spriteFrame !== oldValue) {
			this._updateSprite();
		}

		if (this._element) {
			this._element.fire('set:spriteFrame', value);
		}
	}

	get spriteFrame() {
		return this._spriteFrame;
	}

	set mesh(value) {
		this._renderable.setMesh(value);

		if (this._defaultMesh === value) {
			this._renderable.setAabbFunc(null);
		} else {
			this._renderable.setAabbFunc(this._updateAabbFunc);
		}
	}

	get mesh() {
		return this._renderable.mesh;
	}

	set mask(value) {
		if (this._mask !== value) {
			this._mask = value;

			this._toggleMask();
		}
	}

	get mask() {
		return this._mask;
	}

	set pixelsPerUnit(value) {
		if (this._pixelsPerUnit === value) return;
		this._pixelsPerUnit = value;

		if (this._sprite && (this._sprite.renderMode === SPRITE_RENDERMODE_SLICED || this._sprite.renderMode === SPRITE_RENDERMODE_TILED)) {
			this._updateSprite();
		}
	}

	get pixelsPerUnit() {
		return this._pixelsPerUnit;
	}

	get aabb() {
		if (this._renderable.meshInstance) {
			return this._renderable.meshInstance.aabb;
		}

		return null;
	}

}

class LocalizedAsset extends EventHandler {
	constructor(app) {
		super();
		this._app = app;
		app.i18n.on('set:locale', this._onSetLocale, this);
		this._autoLoad = false;
		this._disableLocalization = false;
		this._defaultAsset = null;
		this._localizedAsset = null;
	}

	set defaultAsset(value) {
		const id = value instanceof Asset ? value.id : value;
		if (this._defaultAsset === id) return;

		if (this._defaultAsset) {
			this._unbindDefaultAsset();
		}

		this._defaultAsset = id;

		if (this._defaultAsset) {
			this._bindDefaultAsset();
		}

		this._onSetLocale(this._app.i18n.locale);
	}

	get defaultAsset() {
		return this._defaultAsset;
	}

	set localizedAsset(value) {
		const id = value instanceof Asset ? value.id : value;

		if (this._localizedAsset === id) {
			return;
		}

		if (this._localizedAsset) {
			this._app.assets.off('add:' + this._localizedAsset, this._onLocalizedAssetAdd, this);

			this._unbindLocalizedAsset();

			this._localizedAsset = null;
		}

		this._localizedAsset = id;

		if (this._localizedAsset) {
			const asset = this._app.assets.get(this._localizedAsset);

			if (!asset) {
				this._app.assets.once('add:' + this._localizedAsset, this._onLocalizedAssetAdd, this);
			} else {
				this._bindLocalizedAsset();
			}
		}
	}

	get localizedAsset() {
		return this._localizedAsset;
	}

	set autoLoad(value) {
		if (this._autoLoad === value) return;
		this._autoLoad = value;

		if (this._autoLoad && this._localizedAsset) {
			this._unbindLocalizedAsset();

			this._bindLocalizedAsset();
		}
	}

	get autoLoad() {
		return this._autoLoad;
	}

	set disableLocalization(value) {
		if (this._disableLocalization === value) return;
		this._disableLocalization = value;

		this._onSetLocale(this._app.i18n.locale);
	}

	get disableLocalization() {
		return this._disableLocalization;
	}

	_bindDefaultAsset() {
		const asset = this._app.assets.get(this._defaultAsset);

		if (!asset) {
			this._app.assets.once('add:' + this._defaultAsset, this._onDefaultAssetAdd, this);
		} else {
			this._onDefaultAssetAdd(asset);
		}
	}

	_unbindDefaultAsset() {
		if (!this._defaultAsset) return;

		this._app.assets.off('add:' + this._defaultAsset, this._onDefaultAssetAdd, this);

		const asset = this._app.assets.get(this._defaultAsset);

		if (!asset) return;
		asset.off('add:localized', this._onLocaleAdd, this);
		asset.off('remove:localized', this._onLocaleRemove, this);
		asset.off('remove', this._onDefaultAssetRemove, this);
	}

	_onDefaultAssetAdd(asset) {
		if (this._defaultAsset !== asset.id) return;
		asset.on('add:localized', this._onLocaleAdd, this);
		asset.on('remove:localized', this._onLocaleRemove, this);
		asset.once('remove', this._onDefaultAssetRemove, this);
	}

	_onDefaultAssetRemove(asset) {
		if (this._defaultAsset !== asset.id) return;
		asset.off('add:localized', this._onLocaleAdd, this);
		asset.off('remove:localized', this._onLocaleAdd, this);

		this._app.assets.once('add:' + this._defaultAsset, this._onDefaultAssetAdd, this);
	}

	_bindLocalizedAsset() {
		if (!this._autoLoad) return;

		const asset = this._app.assets.get(this._localizedAsset);

		if (!asset) return;
		asset.on("load", this._onLocalizedAssetLoad, this);
		asset.on("change", this._onLocalizedAssetChange, this);
		asset.on("remove", this._onLocalizedAssetRemove, this);

		if (asset.resource) {
			this._onLocalizedAssetLoad(asset);
		} else {
			this._app.assets.load(asset);
		}
	}

	_unbindLocalizedAsset() {
		const asset = this._app.assets.get(this._localizedAsset);

		if (!asset) return;
		asset.off("load", this._onLocalizedAssetLoad, this);
		asset.off("change", this._onLocalizedAssetChange, this);
		asset.off("remove", this._onLocalizedAssetRemove, this);
	}

	_onLocalizedAssetAdd(asset) {
		if (this._localizedAsset !== asset.id) return;

		this._bindLocalizedAsset();
	}

	_onLocalizedAssetLoad(asset) {
		this.fire('load', asset);
	}

	_onLocalizedAssetChange(asset, name, newValue, oldValue) {
		this.fire('change', asset, name, newValue, oldValue);
	}

	_onLocalizedAssetRemove(asset) {
		if (this._localizedAsset === asset.id) {
			this.localizedAsset = this._defaultAsset;
		}

		this.fire('remove', asset);
	}

	_onLocaleAdd(locale, assetId) {
		if (this._app.i18n.locale !== locale) return;

		this._onSetLocale(locale);
	}

	_onLocaleRemove(locale, assetId) {
		if (this._app.i18n.locale !== locale) return;

		this._onSetLocale(locale);
	}

	_onSetLocale(locale) {
		if (!this._defaultAsset) {
			this.localizedAsset = null;
			return;
		}

		const asset = this._app.assets.get(this._defaultAsset);

		if (!asset || this._disableLocalization) {
			this.localizedAsset = this._defaultAsset;
			return;
		}

		const localizedAssetId = asset.getLocalizedAssetId(locale);

		if (!localizedAssetId) {
			this.localizedAsset = this._defaultAsset;
			return;
		}

		this.localizedAsset = localizedAssetId;
	}

	destroy() {
		this.defaultAsset = null;

		this._app.i18n.off('set:locale', this._onSetLocale, this);

		this.off();
	}

}

const EOF_TOKEN = 0;
const ERROR_TOKEN = 1;
const TEXT_TOKEN = 2;
const OPEN_BRACKET_TOKEN = 3;
const CLOSE_BRACKET_TOKEN = 4;
const EQUALS_TOKEN = 5;
const STRING_TOKEN = 6;
const IDENTIFIER_TOKEN = 7;
const WHITESPACE_TOKEN = 8;
const WHITESPACE_CHARS = " \t\n\r\v\f";
const IDENTIFIER_REGEX = /[A-Z|a-z|0-9|_|-|/]/;

class Scanner {
	constructor(symbols) {
		this._symbols = symbols;
		this._index = 0;
		this._last = 0;
		this._cur = this._symbols.length > 0 ? this._symbols[0] : null;
		this._buf = [];
		this._mode = "text";
		this._error = null;
	}

	read() {
		let token = this._read();

		while (token === WHITESPACE_TOKEN) {
			token = this._read();
		}

		if (token !== EOF_TOKEN && token !== ERROR_TOKEN) {
			this._last = this._index;
		}

		return token;
	}

	buf() {
		return this._buf;
	}

	last() {
		return this._last;
	}

	error() {
		return this._error;
	}

	debugPrint() {
		const tokenStrings = ["EOF", "ERROR", "TEXT", "OPEN_BRACKET", "CLOSE_BRACKET", "EQUALS", "STRING", "IDENTIFIER", "WHITESPACE"];
		let token = this.read();
		let result = "";

		while (true) {
			result += (result.length > 0 ? "\n" : "") + tokenStrings[token] + " '" + this.buf().join("") + "'";

			if (token === EOF_TOKEN || token === ERROR_TOKEN) {
				break;
			}

			token = this.read();
		}

		return result;
	}

	_read() {
		this._buf = [];

		if (this._eof()) {
			return EOF_TOKEN;
		}

		return this._mode === "text" ? this._text() : this._tag();
	}

	_text() {
		while (true) {
			switch (this._cur) {
				case null:
					return this._buf.length > 0 ? TEXT_TOKEN : EOF_TOKEN;

				case "[":
					this._mode = "tag";
					return this._buf.length > 0 ? TEXT_TOKEN : this._tag();

				case "\\":
					this._next();

					switch (this._cur) {
						case "[":
							this._store();

							break;

						default:
							this._output("\\");

							break;
					}

					break;

				default:
					this._store();

					break;
			}
		}
	}

	_tag() {
		switch (this._cur) {
			case null:
				this._error = "unexpected end of input reading tag";
				return ERROR_TOKEN;

			case "[":
				this._store();

				return OPEN_BRACKET_TOKEN;

			case "]":
				this._store();

				this._mode = "text";
				return CLOSE_BRACKET_TOKEN;

			case "=":
				this._store();

				return EQUALS_TOKEN;

			case " ":
			case "\t":
			case "\n":
			case "\r":
			case "\v":
			case "\f":
				return this._whitespace();

			case "\"":
				return this._string();

			default:
				if (!this._isIdentifierSymbol(this._cur)) {
					this._error = "unrecognized character";
					return ERROR_TOKEN;
				}

				return this._identifier();
		}
	}

	_whitespace() {
		this._store();

		while (WHITESPACE_CHARS.indexOf(this._cur) !== -1) {
			this._store();
		}

		return WHITESPACE_TOKEN;
	}

	_string() {
		this._next();

		while (true) {
			switch (this._cur) {
				case null:
					this._error = "unexpected end of input reading string";
					return ERROR_TOKEN;

				case "\"":
					this._next();

					return STRING_TOKEN;

				default:
					this._store();

					break;
			}
		}
	}

	_identifier() {
		this._store();

		while (this._cur !== null && this._isIdentifierSymbol(this._cur)) {
			this._store();
		}

		return IDENTIFIER_TOKEN;
	}

	_isIdentifierSymbol(s) {
		return s.length === 1 && s.match(IDENTIFIER_REGEX) !== null;
	}

	_eof() {
		return this._cur === null;
	}

	_next() {
		if (!this._eof()) {
			this._index++;
			this._cur = this._index < this._symbols.length ? this._symbols[this._index] : null;
		}

		return this._cur;
	}

	_store() {
		this._buf.push(this._cur);

		return this._next();
	}

	_output(c) {
		this._buf.push(c);
	}

}

class Parser {
	constructor(symbols) {
		this._scanner = new Scanner(symbols);
		this._error = null;
	}

	parse(symbols, tags) {
		while (true) {
			const token = this._scanner.read();

			switch (token) {
				case EOF_TOKEN:
					return true;

				case ERROR_TOKEN:
					return false;

				case TEXT_TOKEN:
					Array.prototype.push.apply(symbols, this._scanner.buf());
					break;

				case OPEN_BRACKET_TOKEN:
					if (!this._parseTag(symbols, tags)) {
						return false;
					}

					break;

				default:
					return false;
			}
		}
	}

	error() {
		return "Error evaluating markup at #" + this._scanner.last().toString() + " (" + (this._scanner.error() || this._error) + ")";
	}

	_parseTag(symbols, tags) {
		let token = this._scanner.read();

		if (token !== IDENTIFIER_TOKEN) {
			this._error = "expected identifier";
			return false;
		}

		const name = this._scanner.buf().join("");

		if (name[0] === "/") {
			for (let index = tags.length - 1; index >= 0; --index) {
				if (name === "/" + tags[index].name && tags[index].end === null) {
					tags[index].end = symbols.length;
					token = this._scanner.read();

					if (token !== CLOSE_BRACKET_TOKEN) {
						this._error = "expected close bracket";
						return false;
					}

					return true;
				}
			}

			this._error = "failed to find matching tag";
			return false;
		}

		const tag = {
			name: name,
			value: null,
			attributes: {},
			start: symbols.length,
			end: null
		};
		token = this._scanner.read();

		if (token === EQUALS_TOKEN) {
			token = this._scanner.read();

			if (token !== STRING_TOKEN) {
				this._error = "expected string";
				return false;
			}

			tag.value = this._scanner.buf().join("");
			token = this._scanner.read();
		}

		while (true) {
			switch (token) {
				case CLOSE_BRACKET_TOKEN:
					tags.push(tag);
					return true;

				case IDENTIFIER_TOKEN:
					{
						const identifier = this._scanner.buf().join("");

						token = this._scanner.read();

						if (token !== EQUALS_TOKEN) {
							this._error = "expected equals";
							return false;
						}

						token = this._scanner.read();

						if (token !== STRING_TOKEN) {
							this._error = "expected string";
							return false;
						}

						const value = this._scanner.buf().join("");

						tag.attributes[identifier] = value;
						break;
					}

				default:
					this._error = "expected close bracket or identifier";
					return false;
			}

			token = this._scanner.read();
		}
	}

}

function merge(target, source) {
	for (const key in source) {
		if (!source.hasOwnProperty(key)) {
			continue;
		}

		const value = source[key];

		if (value instanceof Object) {
			if (!target.hasOwnProperty(key)) {
				target[key] = {};
			}

			merge(target[key], source[key]);
		} else {
			target[key] = value;
		}
	}
}

function combineTags(tags) {
	if (tags.length === 0) {
		return null;
	}

	const result = {};

	for (let index = 0; index < tags.length; ++index) {
		const tag = tags[index];
		const tmp = {};
		tmp[tag.name] = {
			value: tag.value,
			attributes: tag.attributes
		};
		merge(result, tmp);
	}

	return result;
}

function resolveMarkupTags(tags, numSymbols) {
	if (tags.length === 0) {
		return null;
	}

	const edges = {};

	for (let index = 0; index < tags.length; ++index) {
		const tag = tags[index];

		if (!edges.hasOwnProperty(tag.start)) {
			edges[tag.start] = {
				open: [tag],
				close: null
			};
		} else {
			if (edges[tag.start].open === null) {
				edges[tag.start].open = [tag];
			} else {
				edges[tag.start].open.push(tag);
			}
		}

		if (!edges.hasOwnProperty(tag.end)) {
			edges[tag.end] = {
				open: null,
				close: [tag]
			};
		} else {
			if (edges[tag.end].close === null) {
				edges[tag.end].close = [tag];
			} else {
				edges[tag.end].close.push(tag);
			}
		}
	}

	let tagStack = [];

	function removeTags(tags) {
		tagStack = tagStack.filter(function (tag) {
			return tags.find(function (t) {
				return t === tag;
			}) === undefined;
		});
	}

	function addTags(tags) {
		for (let index = 0; index < tags.length; ++index) {
			tagStack.push(tags[index]);
		}
	}

	const edgeKeys = Object.keys(edges).sort(function (a, b) {
		return a - b;
	});
	const resolvedTags = [];

	for (let index = 0; index < edgeKeys.length; ++index) {
		const edge = edges[edgeKeys[index]];

		if (edge.close !== null) {
			removeTags(edge.close);
		}

		if (edge.open !== null) {
			addTags(edge.open);
		}

		resolvedTags.push({
			start: edgeKeys[index],
			tags: combineTags(tagStack)
		});
	}

	const result = [];
	let prevTag = null;

	for (let index = 0; index < resolvedTags.length; ++index) {
		const resolvedTag = resolvedTags[index];

		while (result.length < resolvedTag.start) {
			result.push(prevTag ? prevTag.tags : null);
		}

		prevTag = resolvedTag;
	}

	while (result.length < numSymbols) {
		result.push(null);
	}

	return result;
}

function evaluateMarkup(symbols) {
	const parser = new Parser(symbols);
	const stripped_symbols = [];
	const tags = [];

	if (!parser.parse(stripped_symbols, tags)) {
		console.warn(parser.error());
		return {
			symbols: symbols,
			tags: null
		};
	}

	const invalidTag = tags.find(function (t) {
		return t.end === null;
	});

	if (invalidTag) {
		console.warn(`Markup error: found unclosed tag='${invalidTag.name}'`);
		return {
			symbols: symbols,
			tags: null
		};
	}

	const resolved_tags = resolveMarkupTags(tags, stripped_symbols.length);
	return {
		symbols: stripped_symbols,
		tags: resolved_tags
	};
}

class Markup {
	static evaluate(symbols) {
		return evaluateMarkup(symbols);
	}

}

class MeshInfo {
	constructor() {
		this.count = 0;
		this.quad = 0;
		this.lines = {};
		this.positions = [];
		this.normals = [];
		this.uvs = [];
		this.colors = [];
		this.indices = [];
		this.meshInstance = null;
	}

}

const LINE_BREAK_CHAR = /^[\r\n]$/;
const WHITESPACE_CHAR = /^[ \t]$/;
const WORD_BOUNDARY_CHAR = /^[ \t\-]|[\u200b]$/;
const ALPHANUMERIC_CHAR = /^[a-z0-9]$/i;
const CJK_CHAR = /^[\u1100-\u11ff]|[\u3000-\u9fff]|[\ua960-\ua97f]|[\uac00-\ud7ff]$/;
const NO_LINE_BREAK_CJK_CHAR = /^[]$/;
const CONTROL_CHARS = ['\u200B', '\u061C', '\u200E', '\u200F', '\u202A', '\u202B', '\u202C', '\u202D', '\u202E', '\u2066', '\u2067', '\u2068', '\u2069'];
const CONTROL_GLYPH_DATA = {
	width: 0,
	height: 0,
	xadvance: 0,
	xoffset: 0,
	yoffset: 0
};

class TextElement {
	constructor(element) {
		this._element = element;
		this._system = element.system;
		this._entity = element.entity;
		this._text = "";
		this._symbols = [];
		this._colorPalette = [];
		this._symbolColors = null;
		this._i18nKey = null;
		this._fontAsset = new LocalizedAsset(this._system.app);
		this._fontAsset.disableLocalization = true;

		this._fontAsset.on('load', this._onFontLoad, this);

		this._fontAsset.on('change', this._onFontChange, this);

		this._fontAsset.on('remove', this._onFontRemove, this);

		this._font = null;
		this._color = new Color(1, 1, 1, 1);
		this._colorUniform = new Float32Array(3);
		this._spacing = 1;
		this._fontSize = 32;
		this._fontMinY = 0;
		this._fontMaxY = 0;
		this._originalFontSize = 32;
		this._maxFontSize = 32;
		this._minFontSize = 8;
		this._autoFitWidth = false;
		this._autoFitHeight = false;
		this._maxLines = -1;
		this._lineHeight = 32;
		this._scaledLineHeight = 32;
		this._wrapLines = false;
		this._drawOrder = 0;
		this._alignment = new Vec2(0.5, 0.5);
		this._autoWidth = true;
		this._autoHeight = true;
		this.width = 0;
		this.height = 0;
		this._node = new GraphNode();
		this._model = new Model();
		this._model.graph = this._node;

		this._entity.addChild(this._node);

		this._meshInfo = [];
		this._material = null;
		this._aabbDirty = true;
		this._aabb = new BoundingBox();
		this._noResize = false;
		this._currentMaterialType = null;
		this._maskedMaterialSrc = null;
		this._rtlReorder = false;
		this._unicodeConverter = false;
		this._rtl = false;
		this._outlineColor = new Color(0, 0, 0, 1);
		this._outlineColorUniform = new Float32Array(4);
		this._outlineThicknessScale = 0.2;
		this._outlineThickness = 0.0;
		this._shadowColor = new Color(0, 0, 0, 1);
		this._shadowColorUniform = new Float32Array(4);
		this._shadowOffsetScale = 0.005;
		this._shadowOffset = new Vec2(0, 0);
		this._shadowOffsetUniform = new Float32Array(2);
		this._enableMarkup = false;

		this._onScreenChange(this._element.screen);

		element.on('resize', this._onParentResize, this);
		element.on('set:screen', this._onScreenChange, this);
		element.on('screen:set:screenspace', this._onScreenSpaceChange, this);
		element.on('set:draworder', this._onDrawOrderChange, this);
		element.on('set:pivot', this._onPivotChange, this);

		this._system.app.i18n.on('set:locale', this._onLocaleSet, this);

		this._system.app.i18n.on('data:add', this._onLocalizationData, this);

		this._system.app.i18n.on('data:remove', this._onLocalizationData, this);

		this._rangeStart = 0;
		this._rangeEnd = 0;
	}

	destroy() {
		this._setMaterial(null);

		if (this._model) {
			this._element.removeModelFromLayers(this._model);

			this._model.destroy();

			this._model = null;
		}

		this._fontAsset.destroy();

		this.font = null;

		this._element.off('resize', this._onParentResize, this);

		this._element.off('set:screen', this._onScreenChange, this);

		this._element.off('screen:set:screenspace', this._onScreenSpaceChange, this);

		this._element.off('set:draworder', this._onDrawOrderChange, this);

		this._element.off('set:pivot', this._onPivotChange, this);

		this._system.app.i18n.off('set:locale', this._onLocaleSet, this);

		this._system.app.i18n.off('data:add', this._onLocalizationData, this);

		this._system.app.i18n.off('data:remove', this._onLocalizationData, this);
	}

	_onParentResize(width, height) {
		if (this._noResize) return;
		if (this._font) this._updateText();
	}

	_onScreenChange(screen) {
		if (screen) {
			this._updateMaterial(screen.screen.screenSpace);
		} else {
			this._updateMaterial(false);
		}
	}

	_onScreenSpaceChange(value) {
		this._updateMaterial(value);
	}

	_onDrawOrderChange(order) {
		this._drawOrder = order;

		if (this._model) {
			for (let i = 0, len = this._model.meshInstances.length; i < len; i++) {
				this._model.meshInstances[i].drawOrder = order;
			}
		}
	}

	_onPivotChange(pivot) {
		if (this._font) this._updateText();
	}

	_onLocaleSet(locale) {
		if (!this._i18nKey) return;

		if (this.fontAsset) {
			const asset = this._system.app.assets.get(this.fontAsset);

			if (!asset || !asset.resource || asset.resource !== this._font) {
				this.font = null;
			}
		}

		this._resetLocalizedText();
	}

	_onLocalizationData(locale, messages) {
		if (this._i18nKey && messages[this._i18nKey]) {
			this._resetLocalizedText();
		}
	}

	_resetLocalizedText() {
		this._setText(this._system.app.i18n.getText(this._i18nKey));
	}

	_setText(text) {
		if (this.unicodeConverter) {
			const unicodeConverterFunc = this._system.getUnicodeConverter();

			if (unicodeConverterFunc) {
				text = unicodeConverterFunc(text);
			} else {
				console.warn('Element created with unicodeConverter option but no unicodeConverter function registered');
			}
		}

		if (this._text !== text) {
			if (this._font) {
				this._updateText(text);
			}

			this._text = text;
		}
	}

	_updateText(text) {
		let tags;
		if (text === undefined) text = this._text;
		this._symbols = string.getSymbols(text.normalize ? text.normalize('NFC') : text);

		if (this._symbols.length === 0) {
			this._symbols = [" "];
		}

		if (this._enableMarkup) {
			const results = Markup.evaluate(this._symbols);
			this._symbols = results.symbols;
			tags = results.tags;
		}

		if (this._rtlReorder) {
			const rtlReorderFunc = this._system.app.systems.element.getRtlReorder();

			if (rtlReorderFunc) {
				const results = rtlReorderFunc(this._symbols);
				this._rtl = results.rtl;
				this._symbols = results.mapping.map(function (v) {
					return this._symbols[v];
				}, this);

				if (tags) {
					tags = results.mapping.map(function (v) {
						return tags[v];
					});
				}
			} else {
				console.warn('Element created with rtlReorder option but no rtlReorder function registered');
			}
		} else {
			this._rtl = false;
		}

		if (tags) {
			const paletteMap = {};
			this._colorPalette = [Math.round(this._color.r * 255), Math.round(this._color.g * 255), Math.round(this._color.b * 255)];
			this._symbolColors = [];
			paletteMap[this._color.toString(false).toLowerCase()] = 0;

			for (let i = 0, len = this._symbols.length; i < len; ++i) {
				const tag = tags[i];
				let color = 0;

				if (tag && tag.color && tag.color.value) {
					const c = tag.color.value;

					if (c.length === 7 && c[0] === "#") {
						const hex = c.substring(1).toLowerCase();

						if (paletteMap.hasOwnProperty(hex)) {
							color = paletteMap[hex];
						} else {
							if (/^([0-9a-f]{2}){3}$/.test(hex)) {
								color = this._colorPalette.length / 3;
								paletteMap[hex] = color;

								this._colorPalette.push(parseInt(hex.substring(0, 2), 16));

								this._colorPalette.push(parseInt(hex.substring(2, 4), 16));

								this._colorPalette.push(parseInt(hex.substring(4, 6), 16));
							}
						}
					}
				}

				this._symbolColors.push(color);
			}
		} else {
			this._colorPalette = [];
			this._symbolColors = null;
		}

		const charactersPerTexture = this._calculateCharsPerTexture();

		let removedModel = false;
		const element = this._element;

		const screenSpace = element._isScreenSpace();

		const screenCulled = element._isScreenCulled();

		const visibleFn = function visibleFn(camera) {
			return element.isVisibleForCamera(camera);
		};

		for (let i = 0, len = this._meshInfo.length; i < len; i++) {
			const l = charactersPerTexture[i] || 0;
			const meshInfo = this._meshInfo[i];

			if (meshInfo.count !== l) {
				if (!removedModel) {
					element.removeModelFromLayers(this._model);
					removedModel = true;
				}

				meshInfo.count = l;
				meshInfo.positions.length = meshInfo.normals.length = l * 3 * 4;
				meshInfo.indices.length = l * 3 * 2;
				meshInfo.uvs.length = l * 2 * 4;
				meshInfo.colors.length = l * 4 * 4;

				if (meshInfo.meshInstance) {
					this._removeMeshInstance(meshInfo.meshInstance);
				}

				if (l === 0) {
					meshInfo.meshInstance = null;
					continue;
				}

				for (let v = 0; v < l; v++) {
					meshInfo.indices[v * 3 * 2 + 0] = v * 4;
					meshInfo.indices[v * 3 * 2 + 1] = v * 4 + 1;
					meshInfo.indices[v * 3 * 2 + 2] = v * 4 + 3;
					meshInfo.indices[v * 3 * 2 + 3] = v * 4 + 2;
					meshInfo.indices[v * 3 * 2 + 4] = v * 4 + 3;
					meshInfo.indices[v * 3 * 2 + 5] = v * 4 + 1;
					meshInfo.normals[v * 4 * 3 + 0] = 0;
					meshInfo.normals[v * 4 * 3 + 1] = 0;
					meshInfo.normals[v * 4 * 3 + 2] = -1;
					meshInfo.normals[v * 4 * 3 + 3] = 0;
					meshInfo.normals[v * 4 * 3 + 4] = 0;
					meshInfo.normals[v * 4 * 3 + 5] = -1;
					meshInfo.normals[v * 4 * 3 + 6] = 0;
					meshInfo.normals[v * 4 * 3 + 7] = 0;
					meshInfo.normals[v * 4 * 3 + 8] = -1;
					meshInfo.normals[v * 4 * 3 + 9] = 0;
					meshInfo.normals[v * 4 * 3 + 10] = 0;
					meshInfo.normals[v * 4 * 3 + 11] = -1;
				}

				const mesh = createMesh$1(this._system.app.graphicsDevice, meshInfo.positions, {
					uvs: meshInfo.uvs,
					normals: meshInfo.normals,
					colors: meshInfo.colors,
					indices: meshInfo.indices
				});
				const mi = new MeshInstance(mesh, this._material, this._node);
				mi.name = "Text Element: " + this._entity.name;
				mi.castShadow = false;
				mi.receiveShadow = false;
				mi.cull = !screenSpace;
				mi.screenSpace = screenSpace;
				mi.drawOrder = this._drawOrder;

				if (screenCulled) {
					mi.cull = true;
					mi.isVisibleFunc = visibleFn;
				}

				this._setTextureParams(mi, this._font.textures[i]);

				if (this._symbolColors) {
					this._colorUniform[0] = 1;
					this._colorUniform[1] = 1;
					this._colorUniform[2] = 1;
				} else {
					this._colorUniform[0] = this._color.r;
					this._colorUniform[1] = this._color.g;
					this._colorUniform[2] = this._color.b;
				}

				mi.setParameter("material_emissive", this._colorUniform);
				mi.setParameter("material_opacity", this._color.a);
				mi.setParameter("font_sdfIntensity", this._font.intensity);
				mi.setParameter("font_pxrange", this._getPxRange(this._font));
				mi.setParameter("font_textureWidth", this._font.data.info.maps[i].width);
				this._outlineColorUniform[0] = this._outlineColor.r;
				this._outlineColorUniform[1] = this._outlineColor.g;
				this._outlineColorUniform[2] = this._outlineColor.b;
				this._outlineColorUniform[3] = this._outlineColor.a;
				mi.setParameter("outline_color", this._outlineColorUniform);
				mi.setParameter("outline_thickness", this._outlineThicknessScale * this._outlineThickness);
				this._shadowColorUniform[0] = this._shadowColor.r;
				this._shadowColorUniform[1] = this._shadowColor.g;
				this._shadowColorUniform[2] = this._shadowColor.b;
				this._shadowColorUniform[3] = this._shadowColor.a;
				mi.setParameter("shadow_color", this._shadowColorUniform);
				const ratio = -this._font.data.info.maps[i].width / this._font.data.info.maps[i].height;
				this._shadowOffsetUniform[0] = this._shadowOffsetScale * this._shadowOffset.x;
				this._shadowOffsetUniform[1] = ratio * this._shadowOffsetScale * this._shadowOffset.y;
				mi.setParameter("shadow_offset", this._shadowOffsetUniform);
				meshInfo.meshInstance = mi;

				this._model.meshInstances.push(mi);
			}
		}

		if (this._element.maskedBy) {
			this._element._setMaskedBy(this._element.maskedBy);
		}

		if (removedModel && this._element.enabled && this._entity.enabled) {
			this._element.addModelToLayers(this._model);
		}

		this._updateMeshes();

		this._rangeStart = 0;
		this._rangeEnd = this._symbols.length;

		this._updateRenderRange();
	}

	_removeMeshInstance(meshInstance) {
		meshInstance.destroy();

		const idx = this._model.meshInstances.indexOf(meshInstance);

		if (idx !== -1) this._model.meshInstances.splice(idx, 1);
	}

	_setMaterial(material) {
		this._material = material;

		if (this._model) {
			for (let i = 0, len = this._model.meshInstances.length; i < len; i++) {
				const mi = this._model.meshInstances[i];
				mi.material = material;
			}
		}
	}

	_updateMaterial(screenSpace) {
		const element = this._element;

		const screenCulled = element._isScreenCulled();

		const visibleFn = function visibleFn(camera) {
			return element.isVisibleForCamera(camera);
		};

		const msdf = this._font && this._font.type === FONT_MSDF;
		this._material = this._system.getTextElementMaterial(screenSpace, msdf);

		if (this._model) {
			for (let i = 0, len = this._model.meshInstances.length; i < len; i++) {
				const mi = this._model.meshInstances[i];
				mi.cull = !screenSpace;
				mi.material = this._material;
				mi.screenSpace = screenSpace;

				if (screenCulled) {
					mi.cull = true;
					mi.isVisibleFunc = visibleFn;
				} else {
					mi.isVisibleFunc = null;
				}
			}
		}
	}

	_isWordBoundary(char) {
		return WORD_BOUNDARY_CHAR.test(char);
	}

	_isValidNextChar(nextchar) {
		return nextchar !== null && !NO_LINE_BREAK_CJK_CHAR.test(nextchar);
	}

	_isNextCJKBoundary(char, nextchar) {
		return CJK_CHAR.test(char) && (WORD_BOUNDARY_CHAR.test(nextchar) || ALPHANUMERIC_CHAR.test(nextchar));
	}

	_isNextCJKWholeWord(nextchar) {
		return CJK_CHAR.test(nextchar);
	}

	_updateMeshes() {
		const json = this._font.data;
		const self = this;
		const minFont = Math.min(this._minFontSize, this._maxFontSize);
		const maxFont = this._maxFontSize;

		const autoFit = this._shouldAutoFit();

		if (autoFit) {
			this._fontSize = this._maxFontSize;
		}

		const MAGIC = 32;
		const l = this._symbols.length;
		let _x = 0;
		let _y = 0;
		let _z = 0;
		let _xMinusTrailingWhitespace = 0;
		let lines = 1;
		let wordStartX = 0;
		let wordStartIndex = 0;
		let lineStartIndex = 0;
		let numWordsThisLine = 0;
		let numCharsThisLine = 0;
		let numBreaksThisLine = 0;
		const splitHorizontalAnchors = Math.abs(this._element.anchor.x - this._element.anchor.z) >= 0.0001;
		let maxLineWidth = this._element.calculatedWidth;

		if (this.autoWidth && !splitHorizontalAnchors || !this._wrapLines) {
			maxLineWidth = Number.POSITIVE_INFINITY;
		}

		let fontMinY = 0;
		let fontMaxY = 0;
		let char, data, quad, nextchar;

		function breakLine(symbols, lineBreakIndex, lineBreakX) {
			self._lineWidths.push(Math.abs(lineBreakX));

			const sliceStart = lineStartIndex > lineBreakIndex ? lineBreakIndex + 1 : lineStartIndex;
			const sliceEnd = lineStartIndex > lineBreakIndex ? lineStartIndex + 1 : lineBreakIndex;
			const chars = symbols.slice(sliceStart, sliceEnd);

			if (numBreaksThisLine) {
				let i = chars.length;

				while (i-- && numBreaksThisLine > 0) {
					if (LINE_BREAK_CHAR.test(chars[i])) {
						chars.splice(i, 1);
						numBreaksThisLine--;
					}
				}
			}

			self._lineContents.push(chars.join(''));

			_x = 0;
			_y -= self._scaledLineHeight;
			lines++;
			numWordsThisLine = 0;
			numCharsThisLine = 0;
			numBreaksThisLine = 0;
			wordStartX = 0;
			lineStartIndex = lineBreakIndex;
		}

		let retryUpdateMeshes = true;

		while (retryUpdateMeshes) {
			retryUpdateMeshes = false;

			if (autoFit) {
				this._scaledLineHeight = this._lineHeight * this._fontSize / (this._maxFontSize || 0.0001);
			} else {
				this._scaledLineHeight = this._lineHeight;
			}

			this.width = 0;
			this.height = 0;
			this._lineWidths = [];
			this._lineContents = [];
			_x = 0;
			_y = 0;
			_z = 0;
			_xMinusTrailingWhitespace = 0;
			lines = 1;
			wordStartX = 0;
			wordStartIndex = 0;
			lineStartIndex = 0;
			numWordsThisLine = 0;
			numCharsThisLine = 0;
			numBreaksThisLine = 0;
			const scale = this._fontSize / MAGIC;
			fontMinY = this._fontMinY * scale;
			fontMaxY = this._fontMaxY * scale;

			for (let i = 0; i < this._meshInfo.length; i++) {
				this._meshInfo[i].quad = 0;
				this._meshInfo[i].lines = {};
			}

			let color_r = 255;
			let color_g = 255;
			let color_b = 255;

			for (let i = 0; i < l; i++) {
				char = this._symbols[i];
				nextchar = i + 1 >= l ? null : this._symbols[i + 1];
				const isLineBreak = LINE_BREAK_CHAR.test(char);

				if (isLineBreak) {
					numBreaksThisLine++;

					if (!this._wrapLines || this._maxLines < 0 || lines < this._maxLines) {
						breakLine(this._symbols, i, _xMinusTrailingWhitespace);
						wordStartIndex = i + 1;
						lineStartIndex = i + 1;
					}

					continue;
				}

				let x = 0;
				let y = 0;
				let advance = 0;
				let quadsize = 1;
				let dataScale, size;
				data = json.chars[char];

				if (!data) {
					if (CONTROL_CHARS.indexOf(char) !== -1) {
						data = CONTROL_GLYPH_DATA;
					} else {
						if (json.chars[' ']) {
							data = json.chars[' '];
						} else {
							for (const key in json.chars) {
								data = json.chars[key];
								break;
							}
						}
					}
				}

				if (data) {
					let kerning = 0;

					if (numCharsThisLine > 0) {
						const kernTable = this._font.data.kerning;

						if (kernTable) {
							const kernLeft = kernTable[string.getCodePoint(this._symbols[i - 1]) || 0];

							if (kernLeft) {
								kerning = kernLeft[string.getCodePoint(this._symbols[i]) || 0] || 0;
							}
						}
					}

					dataScale = data.scale || 1;
					size = (data.width + data.height) / 2;
					quadsize = scale * size / dataScale;
					advance = (data.xadvance + kerning) * scale;
					x = (data.xoffset - kerning) * scale;
					y = data.yoffset * scale;
				} else {
					console.error(`Couldn't substitute missing character: '${char}'`);
				}

				const isWhitespace = WHITESPACE_CHAR.test(char);
				const meshInfo = this._meshInfo[data && data.map || 0];
				const candidateLineWidth = _x + this._spacing * advance;

				if (candidateLineWidth > maxLineWidth && numCharsThisLine > 0 && !isWhitespace) {
					if (this._maxLines < 0 || lines < this._maxLines) {
						if (numWordsThisLine === 0) {
							wordStartIndex = i;
							breakLine(this._symbols, i, _xMinusTrailingWhitespace);
						} else {
							const backtrack = Math.max(i - wordStartIndex, 0);

							if (this._meshInfo.length <= 1) {
								meshInfo.lines[lines - 1] -= backtrack;
								meshInfo.quad -= backtrack;
							} else {
								const backtrackStart = wordStartIndex;
								const backtrackEnd = i;

								for (let j = backtrackStart; j < backtrackEnd; j++) {
									const backChar = this._symbols[j];
									const backCharData = json.chars[backChar];
									const backMeshInfo = this._meshInfo[backCharData && backCharData.map || 0];
									backMeshInfo.lines[lines - 1] -= 1;
									backMeshInfo.quad -= 1;
								}
							}

							i -= backtrack + 1;
							breakLine(this._symbols, wordStartIndex, wordStartX);
							continue;
						}
					}
				}

				quad = meshInfo.quad;
				meshInfo.lines[lines - 1] = quad;
				let left = _x - x;
				let right = left + quadsize;
				const bottom = _y - y;
				const top = bottom + quadsize;

				if (this._rtl) {
					const shift = quadsize - x - this._spacing * advance - x;
					left -= shift;
					right -= shift;
				}

				meshInfo.positions[quad * 4 * 3 + 0] = left;
				meshInfo.positions[quad * 4 * 3 + 1] = bottom;
				meshInfo.positions[quad * 4 * 3 + 2] = _z;
				meshInfo.positions[quad * 4 * 3 + 3] = right;
				meshInfo.positions[quad * 4 * 3 + 4] = bottom;
				meshInfo.positions[quad * 4 * 3 + 5] = _z;
				meshInfo.positions[quad * 4 * 3 + 6] = right;
				meshInfo.positions[quad * 4 * 3 + 7] = top;
				meshInfo.positions[quad * 4 * 3 + 8] = _z;
				meshInfo.positions[quad * 4 * 3 + 9] = left;
				meshInfo.positions[quad * 4 * 3 + 10] = top;
				meshInfo.positions[quad * 4 * 3 + 11] = _z;
				this.width = Math.max(this.width, candidateLineWidth);
				let fontSize;

				if (this._shouldAutoFitWidth() && this.width > this._element.calculatedWidth) {
					fontSize = Math.floor(this._element.fontSize * this._element.calculatedWidth / (this.width || 0.0001));
					fontSize = math.clamp(fontSize, minFont, maxFont);

					if (fontSize !== this._element.fontSize) {
						this._fontSize = fontSize;
						retryUpdateMeshes = true;
						break;
					}
				}

				this.height = Math.max(this.height, fontMaxY - (_y + fontMinY));

				if (this._shouldAutoFitHeight() && this.height > this._element.calculatedHeight) {
					fontSize = math.clamp(this._fontSize - 1, minFont, maxFont);

					if (fontSize !== this._element.fontSize) {
						this._fontSize = fontSize;
						retryUpdateMeshes = true;
						break;
					}
				}

				_x += this._spacing * advance;

				if (!isWhitespace) {
					_xMinusTrailingWhitespace = _x;
				}

				if (this._isWordBoundary(char) || this._isValidNextChar(nextchar) && (this._isNextCJKBoundary(char, nextchar) || this._isNextCJKWholeWord(nextchar))) {
					numWordsThisLine++;
					wordStartX = _xMinusTrailingWhitespace;
					wordStartIndex = i + 1;
				}

				numCharsThisLine++;

				const uv = this._getUv(char);

				meshInfo.uvs[quad * 4 * 2 + 0] = uv[0];
				meshInfo.uvs[quad * 4 * 2 + 1] = 1.0 - uv[1];
				meshInfo.uvs[quad * 4 * 2 + 2] = uv[2];
				meshInfo.uvs[quad * 4 * 2 + 3] = 1.0 - uv[1];
				meshInfo.uvs[quad * 4 * 2 + 4] = uv[2];
				meshInfo.uvs[quad * 4 * 2 + 5] = 1.0 - uv[3];
				meshInfo.uvs[quad * 4 * 2 + 6] = uv[0];
				meshInfo.uvs[quad * 4 * 2 + 7] = 1.0 - uv[3];

				if (this._symbolColors) {
					const colorIdx = this._symbolColors[i] * 3;
					color_r = this._colorPalette[colorIdx];
					color_g = this._colorPalette[colorIdx + 1];
					color_b = this._colorPalette[colorIdx + 2];
				}

				meshInfo.colors[quad * 4 * 4 + 0] = color_r;
				meshInfo.colors[quad * 4 * 4 + 1] = color_g;
				meshInfo.colors[quad * 4 * 4 + 2] = color_b;
				meshInfo.colors[quad * 4 * 4 + 3] = 255;
				meshInfo.colors[quad * 4 * 4 + 4] = color_r;
				meshInfo.colors[quad * 4 * 4 + 5] = color_g;
				meshInfo.colors[quad * 4 * 4 + 6] = color_b;
				meshInfo.colors[quad * 4 * 4 + 7] = 255;
				meshInfo.colors[quad * 4 * 4 + 8] = color_r;
				meshInfo.colors[quad * 4 * 4 + 9] = color_g;
				meshInfo.colors[quad * 4 * 4 + 10] = color_b;
				meshInfo.colors[quad * 4 * 4 + 11] = 255;
				meshInfo.colors[quad * 4 * 4 + 12] = color_r;
				meshInfo.colors[quad * 4 * 4 + 13] = color_g;
				meshInfo.colors[quad * 4 * 4 + 14] = color_b;
				meshInfo.colors[quad * 4 * 4 + 15] = 255;
				meshInfo.quad++;
			}

			if (retryUpdateMeshes) {
				continue;
			}

			if (lineStartIndex < l) {
				breakLine(this._symbols, l, _x);
			}
		}

		this._noResize = true;
		this.autoWidth = this._autoWidth;
		this.autoHeight = this._autoHeight;
		this._noResize = false;
		const hp = this._element.pivot.x;
		const vp = this._element.pivot.y;
		const ha = this._alignment.x;
		const va = this._alignment.y;

		for (let i = 0; i < this._meshInfo.length; i++) {
			if (this._meshInfo[i].count === 0) continue;
			let prevQuad = 0;

			for (const line in this._meshInfo[i].lines) {
				const index = this._meshInfo[i].lines[line];

				const lw = this._lineWidths[parseInt(line, 10)];

				const hoffset = -hp * this._element.calculatedWidth + ha * (this._element.calculatedWidth - lw) * (this._rtl ? -1 : 1);
				const voffset = (1 - vp) * this._element.calculatedHeight - fontMaxY - (1 - va) * (this._element.calculatedHeight - this.height);

				for (let _quad = prevQuad; _quad <= index; _quad++) {
					this._meshInfo[i].positions[_quad * 4 * 3] += hoffset;
					this._meshInfo[i].positions[_quad * 4 * 3 + 3] += hoffset;
					this._meshInfo[i].positions[_quad * 4 * 3 + 6] += hoffset;
					this._meshInfo[i].positions[_quad * 4 * 3 + 9] += hoffset;
					this._meshInfo[i].positions[_quad * 4 * 3 + 1] += voffset;
					this._meshInfo[i].positions[_quad * 4 * 3 + 4] += voffset;
					this._meshInfo[i].positions[_quad * 4 * 3 + 7] += voffset;
					this._meshInfo[i].positions[_quad * 4 * 3 + 10] += voffset;
				}

				if (this._rtl) {
					for (let _quad2 = prevQuad; _quad2 <= index; _quad2++) {
						const idx = _quad2 * 4 * 3;

						for (let vert = 0; vert < 4; ++vert) {
							this._meshInfo[i].positions[idx + vert * 3] = this._element.calculatedWidth - this._meshInfo[i].positions[idx + vert * 3] + hoffset * 2;
						}

						const tmp0 = this._meshInfo[i].positions[idx + 3];
						const tmp1 = this._meshInfo[i].positions[idx + 6];
						this._meshInfo[i].positions[idx + 3] = this._meshInfo[i].positions[idx + 0];
						this._meshInfo[i].positions[idx + 6] = this._meshInfo[i].positions[idx + 9];
						this._meshInfo[i].positions[idx + 0] = tmp0;
						this._meshInfo[i].positions[idx + 9] = tmp1;
					}
				}

				prevQuad = index + 1;
			}

			const numVertices = this._meshInfo[i].count * 4;
			const vertMax = this._meshInfo[i].quad * 4;
			const it = new VertexIterator(this._meshInfo[i].meshInstance.mesh.vertexBuffer);

			for (let v = 0; v < numVertices; v++) {
				if (v >= vertMax) {
					it.element[SEMANTIC_POSITION].set(0, 0, 0);
					it.element[SEMANTIC_TEXCOORD0].set(0, 0);
					it.element[SEMANTIC_COLOR].set(0, 0, 0, 0);
				} else {
					it.element[SEMANTIC_POSITION].set(this._meshInfo[i].positions[v * 3 + 0], this._meshInfo[i].positions[v * 3 + 1], this._meshInfo[i].positions[v * 3 + 2]);
					it.element[SEMANTIC_TEXCOORD0].set(this._meshInfo[i].uvs[v * 2 + 0], this._meshInfo[i].uvs[v * 2 + 1]);
					it.element[SEMANTIC_COLOR].set(this._meshInfo[i].colors[v * 4 + 0], this._meshInfo[i].colors[v * 4 + 1], this._meshInfo[i].colors[v * 4 + 2], this._meshInfo[i].colors[v * 4 + 3]);
				}

				it.next();
			}

			it.end();

			this._meshInfo[i].meshInstance.mesh.aabb.compute(this._meshInfo[i].positions);

			this._meshInfo[i].meshInstance._aabbVer = -1;
		}

		this._aabbDirty = true;
	}

	_onFontRender() {
		this.font = this._font;
	}

	_onFontLoad(asset) {
		if (this.font !== asset.resource) {
			this.font = asset.resource;
		}
	}

	_onFontChange(asset, name, _new, _old) {
		if (name === 'data') {
			this._font.data = _new;
			const maps = this._font.data.info.maps.length;

			for (let i = 0; i < maps; i++) {
				if (!this._meshInfo[i]) continue;
				const mi = this._meshInfo[i].meshInstance;

				if (mi) {
					mi.setParameter("font_sdfIntensity", this._font.intensity);
					mi.setParameter("font_pxrange", this._getPxRange(this._font));
					mi.setParameter("font_textureWidth", this._font.data.info.maps[i].width);
				}
			}
		}
	}

	_onFontRemove(asset) {}

	_setTextureParams(mi, texture) {
		if (this._font) {
			if (this._font.type === FONT_MSDF) {
				mi.deleteParameter("texture_emissiveMap");
				mi.deleteParameter("texture_opacityMap");
				mi.setParameter("texture_msdfMap", texture);
			} else if (this._font.type === FONT_BITMAP) {
				mi.deleteParameter("texture_msdfMap");
				mi.setParameter("texture_emissiveMap", texture);
				mi.setParameter("texture_opacityMap", texture);
			}
		}
	}

	_getPxRange(font) {
		const keys = Object.keys(this._font.data.chars);

		for (let i = 0; i < keys.length; i++) {
			const char = this._font.data.chars[keys[i]];

			if (char.range) {
				return (char.scale || 1) * char.range;
			}
		}

		return 2;
	}

	_getUv(char) {
		const data = this._font.data;

		if (!data.chars[char]) {
			const space = ' ';

			if (data.chars[space]) {
				return this._getUv(space);
			}

			return [0, 0, 0, 0];
		}

		const map = data.chars[char].map;
		const width = data.info.maps[map].width;
		const height = data.info.maps[map].height;
		const x = data.chars[char].x;
		const y = data.chars[char].y;
		const x1 = x;
		const y1 = y;
		const x2 = x + data.chars[char].width;
		const y2 = y - data.chars[char].height;
		const edge = 1 - data.chars[char].height / height;
		return [x1 / width, edge - y1 / height, x2 / width, edge - y2 / height];
	}

	onEnable() {
		this._fontAsset.autoLoad = true;

		if (this._model) {
			this._element.addModelToLayers(this._model);
		}
	}

	onDisable() {
		this._fontAsset.autoLoad = false;

		if (this._model) {
			this._element.removeModelFromLayers(this._model);
		}
	}

	_setStencil(stencilParams) {
		if (this._model) {
			const instances = this._model.meshInstances;

			for (let i = 0; i < instances.length; i++) {
				instances[i].stencilFront = stencilParams;
				instances[i].stencilBack = stencilParams;
			}
		}
	}

	_shouldAutoFitWidth() {
		return this._autoFitWidth && !this._autoWidth;
	}

	_shouldAutoFitHeight() {
		return this._autoFitHeight && !this._autoHeight;
	}

	_shouldAutoFit() {
		return this._autoFitWidth && !this._autoWidth || this._autoFitHeight && !this._autoHeight;
	}

	_calculateCharsPerTexture(symbolIndex) {
		const charactersPerTexture = {};

		if (symbolIndex === undefined) {
			symbolIndex = this._symbols.length;
		}

		for (let i = 0, len = symbolIndex; i < len; i++) {
			const char = this._symbols[i];
			let info = this._font.data.chars[char];

			if (!info) {
				info = this._font.data.chars[' '];

				if (!info) {
					info = this._font.data.chars[Object.keys(this._font.data.chars)[0]];
				}
			}

			const map = info.map;

			if (!charactersPerTexture[map]) {
				charactersPerTexture[map] = 1;
			} else {
				charactersPerTexture[map]++;
			}
		}

		return charactersPerTexture;
	}

	_updateRenderRange() {
		const startChars = this._rangeStart === 0 ? 0 : this._calculateCharsPerTexture(this._rangeStart);
		const endChars = this._rangeEnd === 0 ? 0 : this._calculateCharsPerTexture(this._rangeEnd);

		for (let i = 0, len = this._meshInfo.length; i < len; i++) {
			const start = startChars[i] || 0;
			const end = endChars[i] || 0;
			const instance = this._meshInfo[i].meshInstance;

			if (instance) {
				const mesh = instance.mesh;

				if (mesh) {
					mesh.primitive[0].base = start * 3 * 2;
					mesh.primitive[0].count = (end - start) * 3 * 2;
				}
			}
		}
	}

	set text(value) {
		this._i18nKey = null;
		const str = value != null && value.toString() || "";

		this._setText(str);
	}

	get text() {
		return this._text;
	}

	set key(value) {
		const str = value !== null ? value.toString() : null;

		if (this._i18nKey === str) {
			return;
		}

		this._i18nKey = str;

		if (str) {
			this._fontAsset.disableLocalization = false;

			this._resetLocalizedText();
		} else {
			this._fontAsset.disableLocalization = true;
		}
	}

	get key() {
		return this._i18nKey;
	}

	set color(value) {
		const r = value.r;
		const g = value.g;
		const b = value.b;

		if (this._color.r !== r || this._color.g !== g || this._color.b !== b) {
			this._color.r = r;
			this._color.g = g;
			this._color.b = b;

			if (this._symbolColors) {
				if (this._font) {
					this._updateText();
				}
			} else {
				this._colorUniform[0] = this._color.r;
				this._colorUniform[1] = this._color.g;
				this._colorUniform[2] = this._color.b;

				for (let i = 0, len = this._model.meshInstances.length; i < len; i++) {
					const mi = this._model.meshInstances[i];
					mi.setParameter('material_emissive', this._colorUniform);
				}
			}
		}

		if (this._element) {
			this._element.fire('set:color', this._color);
		}
	}

	get color() {
		return this._color;
	}

	set opacity(value) {
		if (this._color.a !== value) {
			this._color.a = value;

			if (this._model) {
				for (let i = 0, len = this._model.meshInstances.length; i < len; i++) {
					const mi = this._model.meshInstances[i];
					mi.setParameter('material_opacity', value);
				}
			}
		}

		if (this._element) {
			this._element.fire('set:opacity', value);
		}
	}

	get opacity() {
		return this._color.a;
	}

	set lineHeight(value) {
		const _prev = this._lineHeight;
		this._lineHeight = value;
		this._scaledLineHeight = value;

		if (_prev !== value && this._font) {
			this._updateText();
		}
	}

	get lineHeight() {
		return this._lineHeight;
	}

	set wrapLines(value) {
		const _prev = this._wrapLines;
		this._wrapLines = value;

		if (_prev !== value && this._font) {
			this._updateText();
		}
	}

	get wrapLines() {
		return this._wrapLines;
	}

	get lines() {
		return this._lineContents;
	}

	set spacing(value) {
		const _prev = this._spacing;
		this._spacing = value;

		if (_prev !== value && this._font) {
			this._updateText();
		}
	}

	get spacing() {
		return this._spacing;
	}

	set fontSize(value) {
		const _prev = this._fontSize;
		this._fontSize = value;
		this._originalFontSize = value;

		if (_prev !== value && this._font) {
			this._updateText();
		}
	}

	get fontSize() {
		return this._fontSize;
	}

	set fontAsset(value) {
		this._fontAsset.defaultAsset = value;
	}

	get fontAsset() {
		return this._fontAsset.localizedAsset;
	}

	set font(value) {
		let previousFontType;

		if (this._font) {
			previousFontType = this._font.type;
			if (this._font.off) this._font.off('render', this._onFontRender, this);
		}

		this._font = value;
		this._fontMinY = 0;
		this._fontMaxY = 0;
		if (!value) return;
		const json = this._font.data;

		for (const charId in json.chars) {
			const data = json.chars[charId];

			if (data.bounds) {
				this._fontMinY = Math.min(this._fontMinY, data.bounds[1]);
				this._fontMaxY = Math.max(this._fontMaxY, data.bounds[3]);
			}
		}

		if (this._font.on) this._font.on('render', this._onFontRender, this);

		if (this._fontAsset.localizedAsset) {
			const asset = this._system.app.assets.get(this._fontAsset.localizedAsset);

			if (asset.resource !== this._font) {
				this._fontAsset.defaultAsset = null;
			}
		}

		if (value.type !== previousFontType) {
			const screenSpace = this._element._isScreenSpace();

			this._updateMaterial(screenSpace);
		}

		for (let i = 0, len = this._font.textures.length; i < len; i++) {
			if (!this._meshInfo[i]) {
				this._meshInfo[i] = new MeshInfo();
			} else {
				const mi = this._meshInfo[i].meshInstance;

				if (mi) {
					mi.setParameter("font_sdfIntensity", this._font.intensity);
					mi.setParameter("font_pxrange", this._getPxRange(this._font));
					mi.setParameter("font_textureWidth", this._font.data.info.maps[i].width);

					this._setTextureParams(mi, this._font.textures[i]);
				}
			}
		}

		let removedModel = false;

		for (let i = this._font.textures.length; i < this._meshInfo.length; i++) {
			if (this._meshInfo[i].meshInstance) {
				if (!removedModel) {
					this._element.removeModelFromLayers(this._model);

					removedModel = true;
				}

				this._removeMeshInstance(this._meshInfo[i].meshInstance);
			}
		}

		if (this._meshInfo.length > this._font.textures.length) this._meshInfo.length = this._font.textures.length;

		this._updateText();
	}

	get font() {
		return this._font;
	}

	set alignment(value) {
		if (value instanceof Vec2) {
			this._alignment.set(value.x, value.y);
		} else {
			this._alignment.set(value[0], value[1]);
		}

		if (this._font) this._updateText();
	}

	get alignment() {
		return this._alignment;
	}

	set autoWidth(value) {
		const old = this._autoWidth;
		this._autoWidth = value;

		if (value && Math.abs(this._element.anchor.x - this._element.anchor.z) < 0.0001) {
			this._element.width = this.width;
		}

		if (old !== value) {
			const newFontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;

			if (newFontSize !== this._fontSize) {
				this._fontSize = newFontSize;

				if (this._font) {
					this._updateText();
				}
			}
		}
	}

	get autoWidth() {
		return this._autoWidth;
	}

	set autoHeight(value) {
		const old = this._autoHeight;
		this._autoHeight = value;

		if (value && Math.abs(this._element.anchor.y - this._element.anchor.w) < 0.0001) {
			this._element.height = this.height;
		}

		if (old !== value) {
			const newFontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;

			if (newFontSize !== this._fontSize) {
				this._fontSize = newFontSize;

				if (this._font) {
					this._updateText();
				}
			}
		}
	}

	get autoHeight() {
		return this._autoHeight;
	}

	set rtlReorder(value) {
		if (this._rtlReorder !== value) {
			this._rtlReorder = value;

			if (this._font) {
				this._updateText();
			}
		}
	}

	get rtlReorder() {
		return this._rtlReorder;
	}

	set unicodeConverter(value) {
		if (this._unicodeConverter !== value) {
			this._unicodeConverter = value;

			this._setText(this._text);
		}
	}

	get unicodeConverter() {
		return this._unicodeConverter;
	}

	get aabb() {
		if (this._aabbDirty) {
			let initialized = false;

			for (let i = 0; i < this._meshInfo.length; i++) {
				if (!this._meshInfo[i].meshInstance) continue;

				if (!initialized) {
					this._aabb.copy(this._meshInfo[i].meshInstance.aabb);

					initialized = true;
				} else {
					this._aabb.add(this._meshInfo[i].meshInstance.aabb);
				}
			}

			this._aabbDirty = false;
		}

		return this._aabb;
	}

	set outlineColor(value) {
		const r = value instanceof Color ? value.r : value[0];
		const g = value instanceof Color ? value.g : value[1];
		const b = value instanceof Color ? value.b : value[2];
		const a = value instanceof Color ? value.a : value[3];

		if (this._outlineColor.r === r && this._outlineColor.g === g && this._outlineColor.b === b && this._outlineColor.a === a) {
			return;
		}

		this._outlineColor.r = r;
		this._outlineColor.g = g;
		this._outlineColor.b = b;
		this._outlineColor.a = a;

		if (this._model) {
			this._outlineColorUniform[0] = this._outlineColor.r;
			this._outlineColorUniform[1] = this._outlineColor.g;
			this._outlineColorUniform[2] = this._outlineColor.b;
			this._outlineColorUniform[3] = this._outlineColor.a;

			for (let i = 0, len = this._model.meshInstances.length; i < len; i++) {
				const mi = this._model.meshInstances[i];
				mi.setParameter("outline_color", this._outlineColorUniform);
			}
		}
	}

	get outlineColor() {
		return this._outlineColor;
	}

	set outlineThickness(value) {
		const _prev = this._outlineThickness;
		this._outlineThickness = value;

		if (_prev !== value && this._font) {
			if (this._model) {
				for (let i = 0, len = this._model.meshInstances.length; i < len; i++) {
					const mi = this._model.meshInstances[i];
					mi.setParameter("outline_thickness", this._outlineThicknessScale * this._outlineThickness);
				}
			}
		}
	}

	get outlineThickness() {
		return this._outlineThickness;
	}

	set shadowColor(value) {
		const r = value instanceof Color ? value.r : value[0];
		const g = value instanceof Color ? value.g : value[1];
		const b = value instanceof Color ? value.b : value[2];
		const a = value instanceof Color ? value.a : value[3];

		if (this._shadowColor.r === r && this._shadowColor.g === g && this._shadowColor.b === b && this._shadowColor.a === a) {
			return;
		}

		this._shadowColor.r = r;
		this._shadowColor.g = g;
		this._shadowColor.b = b;
		this._shadowColor.a = a;

		if (this._model) {
			this._shadowColorUniform[0] = this._shadowColor.r;
			this._shadowColorUniform[1] = this._shadowColor.g;
			this._shadowColorUniform[2] = this._shadowColor.b;
			this._shadowColorUniform[3] = this._shadowColor.a;

			for (let i = 0, len = this._model.meshInstances.length; i < len; i++) {
				const mi = this._model.meshInstances[i];
				mi.setParameter("shadow_color", this._shadowColorUniform);
			}
		}
	}

	get shadowColor() {
		return this._shadowColor;
	}

	set shadowOffset(value) {
		const x = value instanceof Vec2 ? value.x : value[0],
					y = value instanceof Vec2 ? value.y : value[1];

		if (this._shadowOffset.x === x && this._shadowOffset.y === y) {
			return;
		}

		this._shadowOffset.set(x, y);

		if (this._font && this._model) {
			for (let i = 0, len = this._model.meshInstances.length; i < len; i++) {
				const ratio = -this._font.data.info.maps[i].width / this._font.data.info.maps[i].height;
				this._shadowOffsetUniform[0] = this._shadowOffsetScale * this._shadowOffset.x;
				this._shadowOffsetUniform[1] = ratio * this._shadowOffsetScale * this._shadowOffset.y;
				const mi = this._model.meshInstances[i];
				mi.setParameter("shadow_offset", this._shadowOffsetUniform);
			}
		}
	}

	get shadowOffset() {
		return this._shadowOffset;
	}

	set minFontSize(value) {
		if (this._minFontSize === value) return;
		this._minFontSize = value;

		if (this.font && this._shouldAutoFit()) {
			this._updateText();
		}
	}

	get minFontSize() {
		return this._minFontSize;
	}

	set maxFontSize(value) {
		if (this._maxFontSize === value) return;
		this._maxFontSize = value;

		if (this.font && this._shouldAutoFit()) {
			this._updateText();
		}
	}

	get maxFontSize() {
		return this._maxFontSize;
	}

	set autoFitWidth(value) {
		if (this._autoFitWidth === value) return;
		this._autoFitWidth = value;
		this._fontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;

		if (this.font) {
			this._updateText();
		}
	}

	get autoFitWidth() {
		return this._autoFitWidth;
	}

	set autoFitHeight(value) {
		if (this._autoFitHeight === value) return;
		this._autoFitHeight = value;
		this._fontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;

		if (this.font) {
			this._updateText();
		}
	}

	get autoFitHeight() {
		return this._autoFitHeight;
	}

	set maxLines(value) {
		if (this._maxLines === value) return;
		if (value === null && this._maxLines === -1) return;
		this._maxLines = value === null ? -1 : value;

		if (this.font && this._wrapLines) {
			this._updateText();
		}
	}

	get maxLines() {
		return this._maxLines;
	}

	set enableMarkup(value) {
		value = !!value;
		if (this._enableMarkup === value) return;
		this._enableMarkup = value;

		if (this.font) {
			this._updateText();
		}
	}

	get enableMarkup() {
		return this._enableMarkup;
	}

	get symbols() {
		return this._symbols;
	}

	get symbolColors() {
		if (this._symbolColors === null) {
			return null;
		}

		return this._symbolColors.map(function (c) {
			return this._colorPalette.slice(c * 3, c * 3 + 3);
		}, this);
	}

	get rtl() {
		return this._rtl;
	}

	set rangeStart(rangeStart) {
		rangeStart = Math.max(0, Math.min(rangeStart, this._symbols.length));

		if (rangeStart !== this._rangeStart) {
			this._rangeStart = rangeStart;

			this._updateRenderRange();
		}
	}

	get rangeStart() {
		return this._rangeStart;
	}

	set rangeEnd(rangeEnd) {
		rangeEnd = Math.max(this._rangeStart, Math.min(rangeEnd, this._symbols.length));

		if (rangeEnd !== this._rangeEnd) {
			this._rangeEnd = rangeEnd;

			this._updateRenderRange();
		}
	}

	get rangeEnd() {
		return this._rangeEnd;
	}

}

const position = new Vec3();
const invParentWtm = new Mat4();
const vecA$1 = new Vec3();
const vecB$1 = new Vec3();
const matA = new Mat4();
const matB = new Mat4();
const matC = new Mat4();
const matD = new Mat4();

class ElementComponent extends Component {
	constructor(system, entity) {
		super(system, entity);
		this._beingInitialized = false;
		this._anchor = new Vec4();
		this._localAnchor = new Vec4();
		this._pivot = new Vec2();
		this._width = this._calculatedWidth = 32;
		this._height = this._calculatedHeight = 32;
		this._margin = new Vec4(0, 0, -32, -32);
		this._modelTransform = new Mat4();
		this._screenToWorld = new Mat4();
		this._anchorTransform = new Mat4();
		this._anchorDirty = true;
		this._parentWorldTransform = new Mat4();
		this._screenTransform = new Mat4();
		this._screenCorners = [new Vec3(), new Vec3(), new Vec3(), new Vec3()];
		this._canvasCorners = [new Vec2(), new Vec2(), new Vec2(), new Vec2()];
		this._worldCorners = [new Vec3(), new Vec3(), new Vec3(), new Vec3()];
		this._cornersDirty = true;
		this._canvasCornersDirty = true;
		this._worldCornersDirty = true;
		this.entity.on('insert', this._onInsert, this);

		this._patch();

		this.screen = null;
		this._type = ELEMENTTYPE_GROUP;
		this._image = null;
		this._text = null;
		this._group = null;
		this._drawOrder = 0;
		this._useInput = false;
		this._layers = [LAYERID_UI];
		this._addedModels = [];
		this._batchGroupId = -1;
		this._offsetReadAt = 0;
		this._maskOffset = 0.5;
		this._maskedBy = null;
	}

	get _absLeft() {
		return this._localAnchor.x + this._margin.x;
	}

	get _absRight() {
		return this._localAnchor.z - this._margin.z;
	}

	get _absTop() {
		return this._localAnchor.w - this._margin.w;
	}

	get _absBottom() {
		return this._localAnchor.y + this._margin.y;
	}

	get _hasSplitAnchorsX() {
		return Math.abs(this._anchor.x - this._anchor.z) > 0.001;
	}

	get _hasSplitAnchorsY() {
		return Math.abs(this._anchor.y - this._anchor.w) > 0.001;
	}

	get aabb() {
		if (this._image) return this._image.aabb;
		if (this._text) return this._text.aabb;
		return null;
	}

	set anchor(value) {
		if (value instanceof Vec4) {
			this._anchor.set(value.x, value.y, value.z, value.w);
		} else {
			this._anchor.set(value[0], value[1], value[2], value[3]);
		}

		if (!this.entity._parent && !this.screen) {
			this._calculateLocalAnchors();
		} else {
			this._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY);
		}

		this._anchorDirty = true;
		if (!this.entity._dirtyLocal) this.entity._dirtifyLocal();
		this.fire('set:anchor', this._anchor);
	}

	get anchor() {
		return this._anchor;
	}

	set batchGroupId(value) {
		if (this._batchGroupId === value) return;

		if (this.entity.enabled && this._batchGroupId >= 0) {
			this.system.app.batcher.remove(BatchGroup.ELEMENT, this.batchGroupId, this.entity);
		}

		if (this.entity.enabled && value >= 0) {
			this.system.app.batcher.insert(BatchGroup.ELEMENT, value, this.entity);
		}

		if (value < 0 && this._batchGroupId >= 0 && this.enabled && this.entity.enabled) {
			if (this._image && this._image._renderable.model) {
				this.addModelToLayers(this._image._renderable.model);
			} else if (this._text && this._text._model) {
				this.addModelToLayers(this._text._model);
			}
		}

		this._batchGroupId = value;
	}

	get batchGroupId() {
		return this._batchGroupId;
	}

	set bottom(value) {
		this._margin.y = value;
		const p = this.entity.getLocalPosition();
		const wt = this._absTop;
		const wb = this._localAnchor.y + value;

		this._setHeight(wt - wb);

		p.y = value + this._calculatedHeight * this._pivot.y;
		this.entity.setLocalPosition(p);
	}

	get bottom() {
		return this._margin.y;
	}

	set calculatedWidth(value) {
		this._setCalculatedWidth(value, true);
	}

	get calculatedWidth() {
		return this._calculatedWidth;
	}

	set calculatedHeight(value) {
		this._setCalculatedHeight(value, true);
	}

	get calculatedHeight() {
		return this._calculatedHeight;
	}

	get canvasCorners() {
		if (!this._canvasCornersDirty || !this.screen || !this.screen.screen.screenSpace) return this._canvasCorners;
		const device = this.system.app.graphicsDevice;
		const screenCorners = this.screenCorners;
		const sx = device.canvas.clientWidth / device.width;
		const sy = device.canvas.clientHeight / device.height;

		for (let i = 0; i < 4; i++) {
			this._canvasCorners[i].set(screenCorners[i].x * sx, (device.height - screenCorners[i].y) * sy);
		}

		this._canvasCornersDirty = false;
		return this._canvasCorners;
	}

	set drawOrder(value) {
		let priority = 0;

		if (this.screen) {
			priority = this.screen.screen.priority;
		}

		if (value > 0xFFFFFF) {
			value = 0xFFFFFF;
		}

		this._drawOrder = (priority << 24) + value;
		this.fire('set:draworder', this._drawOrder);
	}

	get drawOrder() {
		return this._drawOrder;
	}

	set height(value) {
		this._height = value;

		if (!this._hasSplitAnchorsY) {
			this._setCalculatedHeight(value, true);
		}

		this.fire('set:height', this._height);
	}

	get height() {
		return this._height;
	}

	set layers(value) {
		if (this._addedModels.length) {
			for (let i = 0; i < this._layers.length; i++) {
				const layer = this.system.app.scene.layers.getLayerById(this._layers[i]);

				if (layer) {
					for (let j = 0; j < this._addedModels.length; j++) {
						layer.removeMeshInstances(this._addedModels[j].meshInstances);
					}
				}
			}
		}

		this._layers = value;
		if (!this.enabled || !this.entity.enabled || !this._addedModels.length) return;

		for (let i = 0; i < this._layers.length; i++) {
			const layer = this.system.app.scene.layers.getLayerById(this._layers[i]);

			if (layer) {
				for (let j = 0; j < this._addedModels.length; j++) {
					layer.addMeshInstances(this._addedModels[j].meshInstances);
				}
			}
		}
	}

	get layers() {
		return this._layers;
	}

	set left(value) {
		this._margin.x = value;
		const p = this.entity.getLocalPosition();
		const wr = this._absRight;
		const wl = this._localAnchor.x + value;

		this._setWidth(wr - wl);

		p.x = value + this._calculatedWidth * this._pivot.x;
		this.entity.setLocalPosition(p);
	}

	get left() {
		return this._margin.x;
	}

	set margin(value) {
		this._margin.copy(value);

		this._calculateSize(true, true);

		this.fire('set:margin', this._margin);
	}

	get margin() {
		return this._margin;
	}

	get maskedBy() {
		return this._maskedBy;
	}

	set pivot(value) {
		const prevX = this._pivot.x;
		const prevY = this._pivot.y;

		if (value instanceof Vec2) {
			this._pivot.set(value.x, value.y);
		} else {
			this._pivot.set(value[0], value[1]);
		}

		const mx = this._margin.x + this._margin.z;
		const dx = this._pivot.x - prevX;
		this._margin.x += mx * dx;
		this._margin.z -= mx * dx;
		const my = this._margin.y + this._margin.w;
		const dy = this._pivot.y - prevY;
		this._margin.y += my * dy;
		this._margin.w -= my * dy;
		this._anchorDirty = true;
		this._cornersDirty = true;
		this._worldCornersDirty = true;

		this._calculateSize(false, false);

		this._flagChildrenAsDirty();

		this.fire('set:pivot', this._pivot);
	}

	get pivot() {
		return this._pivot;
	}

	set right(value) {
		this._margin.z = value;
		const p = this.entity.getLocalPosition();
		const wl = this._absLeft;
		const wr = this._localAnchor.z - value;

		this._setWidth(wr - wl);

		p.x = this._localAnchor.z - this._localAnchor.x - value - this._calculatedWidth * (1 - this._pivot.x);
		this.entity.setLocalPosition(p);
	}

	get right() {
		return this._margin.z;
	}

	get screenCorners() {
		if (!this._cornersDirty || !this.screen) return this._screenCorners;
		const parentBottomLeft = this.entity.parent && this.entity.parent.element && this.entity.parent.element.screenCorners[0];

		this._screenCorners[0].set(this._absLeft, this._absBottom, 0);

		this._screenCorners[1].set(this._absRight, this._absBottom, 0);

		this._screenCorners[2].set(this._absRight, this._absTop, 0);

		this._screenCorners[3].set(this._absLeft, this._absTop, 0);

		const screenSpace = this.screen.screen.screenSpace;

		for (let i = 0; i < 4; i++) {
			this._screenTransform.transformPoint(this._screenCorners[i], this._screenCorners[i]);

			if (screenSpace) this._screenCorners[i].mulScalar(this.screen.screen.scale);

			if (parentBottomLeft) {
				this._screenCorners[i].add(parentBottomLeft);
			}
		}

		this._cornersDirty = false;
		this._canvasCornersDirty = true;
		this._worldCornersDirty = true;
		return this._screenCorners;
	}

	get textWidth() {
		return this._text ? this._text.width : 0;
	}

	get textHeight() {
		return this._text ? this._text.height : 0;
	}

	set top(value) {
		this._margin.w = value;
		const p = this.entity.getLocalPosition();
		const wb = this._absBottom;
		const wt = this._localAnchor.w - value;

		this._setHeight(wt - wb);

		p.y = this._localAnchor.w - this._localAnchor.y - value - this._calculatedHeight * (1 - this._pivot.y);
		this.entity.setLocalPosition(p);
	}

	get top() {
		return this._margin.w;
	}

	set type(value) {
		if (value !== this._type) {
			this._type = value;

			if (this._image) {
				this._image.destroy();

				this._image = null;
			}

			if (this._text) {
				this._text.destroy();

				this._text = null;
			}

			if (value === ELEMENTTYPE_IMAGE) {
				this._image = new ImageElement(this);
			} else if (value === ELEMENTTYPE_TEXT) {
				this._text = new TextElement(this);
			}
		}
	}

	get type() {
		return this._type;
	}

	set useInput(value) {
		if (this._useInput === value) return;
		this._useInput = value;

		if (this.system.app.elementInput) {
			if (value) {
				if (this.enabled && this.entity.enabled) {
					this.system.app.elementInput.addElement(this);
				}
			} else {
				this.system.app.elementInput.removeElement(this);
			}
		} else {
			if (this._useInput === true) {
				console.warn("Elements will not get any input events because this.system.app.elementInput is not created");
			}
		}

		this.fire('set:useInput', value);
	}

	get useInput() {
		return this._useInput;
	}

	set width(value) {
		this._width = value;

		if (!this._hasSplitAnchorsX) {
			this._setCalculatedWidth(value, true);
		}

		this.fire('set:width', this._width);
	}

	get width() {
		return this._width;
	}

	get worldCorners() {
		if (!this._worldCornersDirty) {
			return this._worldCorners;
		}

		if (this.screen) {
			const screenCorners = this.screenCorners;

			if (!this.screen.screen.screenSpace) {
				matA.copy(this.screen.screen._screenMatrix);
				matA.data[13] = -matA.data[13];
				matA.mul2(this.screen.getWorldTransform(), matA);

				for (let i = 0; i < 4; i++) {
					matA.transformPoint(screenCorners[i], this._worldCorners[i]);
				}
			}
		} else {
			const localPos = this.entity.getLocalPosition();
			matA.setTranslate(-localPos.x, -localPos.y, -localPos.z);
			matB.setTRS(Vec3.ZERO, this.entity.getLocalRotation(), this.entity.getLocalScale());
			matC.setTranslate(localPos.x, localPos.y, localPos.z);
			const entity = this.entity.parent ? this.entity.parent : this.entity;
			matD.copy(entity.getWorldTransform());
			matD.mul(matC).mul(matB).mul(matA);
			vecA$1.set(localPos.x - this.pivot.x * this.calculatedWidth, localPos.y - this.pivot.y * this.calculatedHeight, localPos.z);
			matD.transformPoint(vecA$1, this._worldCorners[0]);
			vecA$1.set(localPos.x + (1 - this.pivot.x) * this.calculatedWidth, localPos.y - this.pivot.y * this.calculatedHeight, localPos.z);
			matD.transformPoint(vecA$1, this._worldCorners[1]);
			vecA$1.set(localPos.x + (1 - this.pivot.x) * this.calculatedWidth, localPos.y + (1 - this.pivot.y) * this.calculatedHeight, localPos.z);
			matD.transformPoint(vecA$1, this._worldCorners[2]);
			vecA$1.set(localPos.x - this.pivot.x * this.calculatedWidth, localPos.y + (1 - this.pivot.y) * this.calculatedHeight, localPos.z);
			matD.transformPoint(vecA$1, this._worldCorners[3]);
		}

		this._worldCornersDirty = false;
		return this._worldCorners;
	}

	_patch() {
		this.entity._sync = this._sync;
		this.entity.setPosition = this._setPosition;
		this.entity.setLocalPosition = this._setLocalPosition;
	}

	_unpatch() {
		this.entity._sync = Entity.prototype._sync;
		this.entity.setPosition = Entity.prototype.setPosition;
		this.entity.setLocalPosition = Entity.prototype.setLocalPosition;
	}

	_setPosition(x, y, z) {
		if (!this.element.screen) return Entity.prototype.setPosition.call(this, x, y, z);

		if (x instanceof Vec3) {
			position.copy(x);
		} else {
			position.set(x, y, z);
		}

		this.getWorldTransform();
		invParentWtm.copy(this.element._screenToWorld).invert();
		invParentWtm.transformPoint(position, this.localPosition);
		if (!this._dirtyLocal) this._dirtifyLocal();
	}

	_setLocalPosition(x, y, z) {
		if (x instanceof Vec3) {
			this.localPosition.copy(x);
		} else {
			this.localPosition.set(x, y, z);
		}

		const element = this.element;
		const p = this.localPosition;
		const pvt = element._pivot;
		element._margin.x = p.x - element._calculatedWidth * pvt.x;
		element._margin.z = element._localAnchor.z - element._localAnchor.x - element._calculatedWidth - element._margin.x;
		element._margin.y = p.y - element._calculatedHeight * pvt.y;
		element._margin.w = element._localAnchor.w - element._localAnchor.y - element._calculatedHeight - element._margin.y;
		if (!this._dirtyLocal) this._dirtifyLocal();
	}

	_sync() {
		const element = this.element;
		const screen = element.screen;

		if (screen) {
			if (element._anchorDirty) {
				let resx = 0;
				let resy = 0;
				let px = 0;
				let py = 1;

				if (this._parent && this._parent.element) {
					resx = this._parent.element.calculatedWidth;
					resy = this._parent.element.calculatedHeight;
					px = this._parent.element.pivot.x;
					py = this._parent.element.pivot.y;
				} else {
					const resolution = screen.screen.resolution;
					resx = resolution.x / screen.screen.scale;
					resy = resolution.y / screen.screen.scale;
				}

				element._anchorTransform.setTranslate(resx * (element.anchor.x - px), -(resy * (py - element.anchor.y)), 0);

				element._anchorDirty = false;

				element._calculateLocalAnchors();
			}

			if (element._sizeDirty) {
				element._calculateSize(false, false);
			}
		}

		if (this._dirtyLocal) {
			this.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale);
			const p = this.localPosition;
			const pvt = element._pivot;
			element._margin.x = p.x - element._calculatedWidth * pvt.x;
			element._margin.z = element._localAnchor.z - element._localAnchor.x - element._calculatedWidth - element._margin.x;
			element._margin.y = p.y - element._calculatedHeight * pvt.y;
			element._margin.w = element._localAnchor.w - element._localAnchor.y - element._calculatedHeight - element._margin.y;
			this._dirtyLocal = false;
		}

		if (!screen) {
			if (this._dirtyWorld) {
				element._cornersDirty = true;
				element._canvasCornersDirty = true;
				element._worldCornersDirty = true;
			}

			return Entity.prototype._sync.call(this);
		}

		if (this._dirtyWorld) {
			if (this._parent === null) {
				this.worldTransform.copy(this.localTransform);
			} else {
				if (this._parent.element) {
					element._screenToWorld.mul2(this._parent.element._modelTransform, element._anchorTransform);
				} else {
					element._screenToWorld.copy(element._anchorTransform);
				}

				element._modelTransform.mul2(element._screenToWorld, this.localTransform);

				if (screen) {
					element._screenToWorld.mul2(screen.screen._screenMatrix, element._screenToWorld);

					if (!screen.screen.screenSpace) {
						element._screenToWorld.mul2(screen.worldTransform, element._screenToWorld);
					}

					this.worldTransform.mul2(element._screenToWorld, this.localTransform);
					const parentWorldTransform = element._parentWorldTransform;
					parentWorldTransform.setIdentity();
					const parent = this._parent;

					if (parent && parent.element && parent !== screen) {
						matA.setTRS(Vec3.ZERO, parent.getLocalRotation(), parent.getLocalScale());
						parentWorldTransform.mul2(parent.element._parentWorldTransform, matA);
					}

					const depthOffset = vecA$1;
					depthOffset.set(0, 0, this.localPosition.z);
					const pivotOffset = vecB$1;
					pivotOffset.set(element._absLeft + element._pivot.x * element.calculatedWidth, element._absBottom + element._pivot.y * element.calculatedHeight, 0);
					matA.setTranslate(-pivotOffset.x, -pivotOffset.y, -pivotOffset.z);
					matB.setTRS(depthOffset, this.getLocalRotation(), this.getLocalScale());
					matC.setTranslate(pivotOffset.x, pivotOffset.y, pivotOffset.z);

					element._screenTransform.mul2(element._parentWorldTransform, matC).mul(matB).mul(matA);

					element._cornersDirty = true;
					element._canvasCornersDirty = true;
					element._worldCornersDirty = true;
				} else {
					this.worldTransform.copy(element._modelTransform);
				}
			}

			this._dirtyWorld = false;
		}
	}

	_onInsert(parent) {
		const result = this._parseUpToScreen();

		this.entity._dirtifyWorld();

		this._updateScreen(result.screen);

		this._dirtifyMask();
	}

	_dirtifyMask() {
		let current = this.entity;

		while (current) {
			const next = current.parent;

			if ((next === null || next.screen) && current.element) {
				if (!this.system._prerender || !this.system._prerender.length) {
					this.system._prerender = [];
					this.system.app.once('prerender', this._onPrerender, this);
				}

				const i = this.system._prerender.indexOf(this.entity);

				if (i >= 0) {
					this.system._prerender.splice(i, 1);
				}

				const j = this.system._prerender.indexOf(current);

				if (j < 0) {
					this.system._prerender.push(current);
				}
			}

			current = next;
		}
	}

	_onPrerender() {
		for (let i = 0; i < this.system._prerender.length; i++) {
			const mask = this.system._prerender[i];

			if (mask.element) {
				const depth = 1;
				mask.element.syncMask(depth);
			}
		}

		this.system._prerender.length = 0;
	}

	_bindScreen(screen) {
		screen._bindElement(this);
	}

	_unbindScreen(screen) {
		screen._unbindElement(this);
	}

	_updateScreen(screen) {
		if (this.screen && this.screen !== screen) {
			this._unbindScreen(this.screen.screen);
		}

		const previousScreen = this.screen;
		this.screen = screen;

		if (this.screen) {
			this._bindScreen(this.screen.screen);
		}

		this._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY);

		this.fire('set:screen', this.screen, previousScreen);
		this._anchorDirty = true;
		const children = this.entity.children;

		for (let i = 0, l = children.length; i < l; i++) {
			if (children[i].element) children[i].element._updateScreen(screen);
		}

		if (this.screen) this.screen.screen.syncDrawOrder();
	}

	syncMask(depth) {
		const result = this._parseUpToScreen();

		this._updateMask(result.mask, depth);
	}

	_setMaskedBy(mask) {
		const renderableElement = this._image || this._text;

		if (mask) {
			const ref = mask.element._image._maskRef;
			const sp = new StencilParameters({
				ref: ref,
				func: FUNC_EQUAL
			});

			if (renderableElement && renderableElement._setStencil) {
				renderableElement._setStencil(sp);
			}

			this._maskedBy = mask;
		} else {
			if (renderableElement && renderableElement._setStencil) {
				renderableElement._setStencil(null);
			}

			this._maskedBy = null;
		}
	}

	_updateMask(currentMask, depth) {
		if (currentMask) {
			this._setMaskedBy(currentMask);

			if (this.mask) {
				const ref = currentMask.element._image._maskRef;
				const sp = new StencilParameters({
					ref: ref,
					func: FUNC_EQUAL,
					zpass: STENCILOP_INCREMENT
				});

				this._image._setStencil(sp);

				this._image._maskRef = depth;
				depth++;
				currentMask = this.entity;
			}

			const children = this.entity.children;

			for (let i = 0, l = children.length; i < l; i++) {
				if (children[i].element) {
					children[i].element._updateMask(currentMask, depth);
				}
			}

			if (this.mask) depth--;
		} else {
			this._setMaskedBy(null);

			if (this.mask) {
				const sp = new StencilParameters({
					ref: depth,
					func: FUNC_ALWAYS,
					zpass: STENCILOP_REPLACE
				});

				this._image._setStencil(sp);

				this._image._maskRef = depth;
				depth++;
				currentMask = this.entity;
			}

			const children = this.entity.children;

			for (let i = 0, l = children.length; i < l; i++) {
				if (children[i].element) {
					children[i].element._updateMask(currentMask, depth);
				}
			}

			if (this.mask) depth--;
		}
	}

	_parseUpToScreen() {
		const result = {
			screen: null,
			mask: null
		};
		let parent = this.entity._parent;

		while (parent && !parent.screen) {
			if (parent.element && parent.element.mask) {
				if (!result.mask) result.mask = parent;
			}

			parent = parent.parent;
		}

		if (parent && parent.screen) result.screen = parent;
		return result;
	}

	_onScreenResize(res) {
		this._anchorDirty = true;
		this._cornersDirty = true;
		this._worldCornersDirty = true;

		this._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY);

		this.fire('screen:set:resolution', res);
	}

	_onScreenSpaceChange() {
		this.fire('screen:set:screenspace', this.screen.screen.screenSpace);
	}

	_onScreenRemove() {
		if (this.screen) {
			if (this.screen._destroying) {
				this.screen = null;
			} else {
				this._updateScreen(null);
			}
		}
	}

	_calculateLocalAnchors() {
		let resx = 1000;
		let resy = 1000;
		const parent = this.entity._parent;

		if (parent && parent.element) {
			resx = parent.element.calculatedWidth;
			resy = parent.element.calculatedHeight;
		} else if (this.screen) {
			const res = this.screen.screen.resolution;
			const scale = this.screen.screen.scale;
			resx = res.x / scale;
			resy = res.y / scale;
		}

		this._localAnchor.set(this._anchor.x * resx, this._anchor.y * resy, this._anchor.z * resx, this._anchor.w * resy);
	}

	getOffsetPosition(x, y) {
		const p = this.entity.getLocalPosition().clone();
		p.x += x;
		p.y += y;

		this._screenToWorld.transformPoint(p, p);

		return p;
	}

	onLayersChanged(oldComp, newComp) {
		this.addModelToLayers(this._image ? this._image._renderable.model : this._text._model);
		oldComp.off("add", this.onLayerAdded, this);
		oldComp.off("remove", this.onLayerRemoved, this);
		newComp.on("add", this.onLayerAdded, this);
		newComp.on("remove", this.onLayerRemoved, this);
	}

	onLayerAdded(layer) {
		const index = this.layers.indexOf(layer.id);
		if (index < 0) return;

		if (this._image) {
			layer.addMeshInstances(this._image._renderable.model.meshInstances);
		} else if (this._text) {
			layer.addMeshInstances(this._text._model.meshInstances);
		}
	}

	onLayerRemoved(layer) {
		const index = this.layers.indexOf(layer.id);
		if (index < 0) return;

		if (this._image) {
			layer.removeMeshInstances(this._image._renderable.model.meshInstances);
		} else if (this._text) {
			layer.removeMeshInstances(this._text._model.meshInstances);
		}
	}

	onEnable() {
		if (this._image) this._image.onEnable();
		if (this._text) this._text.onEnable();
		if (this._group) this._group.onEnable();

		if (this.useInput && this.system.app.elementInput) {
			this.system.app.elementInput.addElement(this);
		}

		this.system.app.scene.on("set:layers", this.onLayersChanged, this);

		if (this.system.app.scene.layers) {
			this.system.app.scene.layers.on("add", this.onLayerAdded, this);
			this.system.app.scene.layers.on("remove", this.onLayerRemoved, this);
		}

		if (this._batchGroupId >= 0) {
			this.system.app.batcher.insert(BatchGroup.ELEMENT, this.batchGroupId, this.entity);
		}

		this.fire("enableelement");
	}

	onDisable() {
		this.system.app.scene.off("set:layers", this.onLayersChanged, this);

		if (this.system.app.scene.layers) {
			this.system.app.scene.layers.off("add", this.onLayerAdded, this);
			this.system.app.scene.layers.off("remove", this.onLayerRemoved, this);
		}

		if (this._image) this._image.onDisable();
		if (this._text) this._text.onDisable();
		if (this._group) this._group.onDisable();

		if (this.system.app.elementInput && this.useInput) {
			this.system.app.elementInput.removeElement(this);
		}

		if (this._batchGroupId >= 0) {
			this.system.app.batcher.remove(BatchGroup.ELEMENT, this.batchGroupId, this.entity);
		}

		this.fire("disableelement");
	}

	onRemove() {
		this.entity.off('insert', this._onInsert, this);

		this._unpatch();

		if (this._image) this._image.destroy();
		if (this._text) this._text.destroy();

		if (this.system.app.elementInput && this.useInput) {
			this.system.app.elementInput.removeElement(this);
		}

		if (this.screen && this.screen.screen) {
			this._unbindScreen(this.screen.screen);

			this.screen.screen.syncDrawOrder();
		}

		this.off();
	}

	_calculateSize(propagateCalculatedWidth, propagateCalculatedHeight) {
		if (!this.entity._parent && !this.screen) return;

		this._calculateLocalAnchors();

		const newWidth = this._absRight - this._absLeft;
		const newHeight = this._absTop - this._absBottom;

		if (propagateCalculatedWidth) {
			this._setWidth(newWidth);
		} else {
			this._setCalculatedWidth(newWidth, false);
		}

		if (propagateCalculatedHeight) {
			this._setHeight(newHeight);
		} else {
			this._setCalculatedHeight(newHeight, false);
		}

		const p = this.entity.getLocalPosition();
		p.x = this._margin.x + this._calculatedWidth * this._pivot.x;
		p.y = this._margin.y + this._calculatedHeight * this._pivot.y;
		this.entity.setLocalPosition(p);
		this._sizeDirty = false;
	}

	_setWidth(w) {
		this._width = w;

		this._setCalculatedWidth(w, false);

		this.fire('set:width', this._width);
	}

	_setHeight(h) {
		this._height = h;

		this._setCalculatedHeight(h, false);

		this.fire('set:height', this._height);
	}

	_setCalculatedWidth(value, updateMargins) {
		if (Math.abs(value - this._calculatedWidth) <= 1e-4) return;
		this._calculatedWidth = value;

		this.entity._dirtifyLocal();

		if (updateMargins) {
			const p = this.entity.getLocalPosition();
			const pvt = this._pivot;
			this._margin.x = p.x - this._calculatedWidth * pvt.x;
			this._margin.z = this._localAnchor.z - this._localAnchor.x - this._calculatedWidth - this._margin.x;
		}

		this._flagChildrenAsDirty();

		this.fire('set:calculatedWidth', this._calculatedWidth);
		this.fire('resize', this._calculatedWidth, this._calculatedHeight);
	}

	_setCalculatedHeight(value, updateMargins) {
		if (Math.abs(value - this._calculatedHeight) <= 1e-4) return;
		this._calculatedHeight = value;

		this.entity._dirtifyLocal();

		if (updateMargins) {
			const p = this.entity.getLocalPosition();
			const pvt = this._pivot;
			this._margin.y = p.y - this._calculatedHeight * pvt.y;
			this._margin.w = this._localAnchor.w - this._localAnchor.y - this._calculatedHeight - this._margin.y;
		}

		this._flagChildrenAsDirty();

		this.fire('set:calculatedHeight', this._calculatedHeight);
		this.fire('resize', this._calculatedWidth, this._calculatedHeight);
	}

	_flagChildrenAsDirty() {
		const c = this.entity._children;

		for (let i = 0, l = c.length; i < l; i++) {
			if (c[i].element) {
				c[i].element._anchorDirty = true;
				c[i].element._sizeDirty = true;
			}
		}
	}

	addModelToLayers(model) {
		this._addedModels.push(model);

		for (let i = 0; i < this.layers.length; i++) {
			const layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
			if (!layer) continue;
			layer.addMeshInstances(model.meshInstances);
		}
	}

	removeModelFromLayers(model) {
		const idx = this._addedModels.indexOf(model);

		if (idx >= 0) {
			this._addedModels.splice(idx, 1);
		}

		for (let i = 0; i < this.layers.length; i++) {
			const layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
			if (!layer) continue;
			layer.removeMeshInstances(model.meshInstances);
		}
	}

	getMaskOffset() {
		const frame = this.system.app.frame;

		if (this._offsetReadAt !== frame) {
			this._maskOffset = 0.5;
			this._offsetReadAt = frame;
		}

		const mo = this._maskOffset;
		this._maskOffset -= 0.001;
		return mo;
	}

	isVisibleForCamera(camera) {
		let clipL, clipR, clipT, clipB;

		if (this.maskedBy) {
			const corners = this.maskedBy.element.screenCorners;
			clipL = Math.min(Math.min(corners[0].x, corners[1].x), Math.min(corners[2].x, corners[3].x));
			clipR = Math.max(Math.max(corners[0].x, corners[1].x), Math.max(corners[2].x, corners[3].x));
			clipB = Math.min(Math.min(corners[0].y, corners[1].y), Math.min(corners[2].y, corners[3].y));
			clipT = Math.max(Math.max(corners[0].y, corners[1].y), Math.max(corners[2].y, corners[3].y));
		} else {
			const sw = this.system.app.graphicsDevice.width;
			const sh = this.system.app.graphicsDevice.height;
			const cameraWidth = camera._rect.z * sw;
			const cameraHeight = camera._rect.w * sh;
			clipL = camera._rect.x * sw;
			clipR = clipL + cameraWidth;
			clipT = (1 - camera._rect.y) * sh;
			clipB = clipT - cameraHeight;
		}

		const hitCorners = this.screenCorners;
		const left = Math.min(Math.min(hitCorners[0].x, hitCorners[1].x), Math.min(hitCorners[2].x, hitCorners[3].x));
		const right = Math.max(Math.max(hitCorners[0].x, hitCorners[1].x), Math.max(hitCorners[2].x, hitCorners[3].x));
		const bottom = Math.min(Math.min(hitCorners[0].y, hitCorners[1].y), Math.min(hitCorners[2].y, hitCorners[3].y));
		const top = Math.max(Math.max(hitCorners[0].y, hitCorners[1].y), Math.max(hitCorners[2].y, hitCorners[3].y));

		if (right < clipL || left > clipR || bottom > clipT || top < clipB) {
			return false;
		}

		return true;
	}

	_isScreenSpace() {
		if (this.screen && this.screen.screen) {
			return this.screen.screen.screenSpace;
		}

		return false;
	}

	_isScreenCulled() {
		if (this.screen && this.screen.screen) {
			return this.screen.screen.cull;
		}

		return false;
	}

}

function _define(name) {
	Object.defineProperty(ElementComponent.prototype, name, {
		get: function () {
			if (this._text) {
				return this._text[name];
			} else if (this._image) {
				return this._image[name];
			}

			return null;
		},
		set: function (value) {
			if (this._text) {
				this._text[name] = value;
			} else if (this._image) {
				this._image[name] = value;
			}
		}
	});
}

_define("fontSize");

_define("minFontSize");

_define("maxFontSize");

_define("maxLines");

_define("autoFitWidth");

_define("autoFitHeight");

_define("color");

_define("font");

_define("fontAsset");

_define("spacing");

_define("lineHeight");

_define("wrapLines");

_define("lines");

_define("alignment");

_define("autoWidth");

_define("autoHeight");

_define("rtlReorder");

_define("unicodeConverter");

_define("text");

_define("key");

_define("texture");

_define("textureAsset");

_define("material");

_define("materialAsset");

_define("sprite");

_define("spriteAsset");

_define("spriteFrame");

_define("pixelsPerUnit");

_define("opacity");

_define("rect");

_define("mask");

_define("outlineColor");

_define("outlineThickness");

_define("shadowColor");

_define("shadowOffset");

_define("enableMarkup");

_define("rangeStart");

_define("rangeEnd");

class ElementComponentData {
	constructor() {
		this.enabled = true;
	}

}

const _schema$e = ['enabled'];

class ElementComponentSystem extends ComponentSystem {
	constructor(app) {
		super(app);
		this.id = 'element';
		this.ComponentType = ElementComponent;
		this.DataType = ElementComponentData;
		this.schema = _schema$e;
		this._unicodeConverter = null;
		this._rtlReorder = null;
		this._defaultTexture = new Texture(app.graphicsDevice, {
			width: 1,
			height: 1,
			format: PIXELFORMAT_R8_G8_B8_A8
		});
		this._defaultTexture.name = 'element-system';

		const pixels = this._defaultTexture.lock();

		const pixelData = new Uint8Array(4);
		pixelData[0] = 255.0;
		pixelData[1] = 255.0;
		pixelData[2] = 255.0;
		pixelData[3] = 255.0;
		pixels.set(pixelData);

		this._defaultTexture.unlock();

		this.defaultImageMaterial = null;
		this.defaultImage9SlicedMaterial = null;
		this.defaultImage9TiledMaterial = null;
		this.defaultImageMaskMaterial = null;
		this.defaultImage9SlicedMaskMaterial = null;
		this.defaultImage9TiledMaskMaterial = null;
		this.defaultScreenSpaceImageMaterial = null;
		this.defaultScreenSpaceImage9SlicedMaterial = null;
		this.defaultScreenSpaceImage9TiledMaterial = null;
		this.defaultScreenSpaceImageMask9SlicedMaterial = null;
		this.defaultScreenSpaceImageMask9TiledMaterial = null;
		this.defaultScreenSpaceImageMaskMaterial = null;
		this.defaultTextMaterial = null;
		this.defaultBitmapTextMaterial = null;
		this.defaultScreenSpaceTextMaterial = null;
		this.defaultScreenSpaceBitmapTextMaterial = null;
		this.defaultImageMaterials = [];
		this.on('beforeremove', this.onRemoveComponent, this);
	}

	destroy() {
		super.destroy();

		this._defaultTexture.destroy();
	}

	initializeComponentData(component, data, properties) {
		component._beingInitialized = true;

		if (data.anchor !== undefined) {
			if (data.anchor instanceof Vec4) {
				component.anchor.copy(data.anchor);
			} else {
				component.anchor.set(data.anchor[0], data.anchor[1], data.anchor[2], data.anchor[3]);
			}
		}

		if (data.pivot !== undefined) {
			if (data.pivot instanceof Vec2) {
				component.pivot.copy(data.pivot);
			} else {
				component.pivot.set(data.pivot[0], data.pivot[1]);
			}
		}

		const splitHorAnchors = Math.abs(component.anchor.x - component.anchor.z) > 0.001;
		const splitVerAnchors = Math.abs(component.anchor.y - component.anchor.w) > 0.001;
		let _marginChange = false;
		let color;

		if (data.margin !== undefined) {
			if (data.margin instanceof Vec4) {
				component.margin.copy(data.margin);
			} else {
				component._margin.set(data.margin[0], data.margin[1], data.margin[2], data.margin[3]);
			}

			_marginChange = true;
		}

		if (data.left !== undefined) {
			component._margin.x = data.left;
			_marginChange = true;
		}

		if (data.bottom !== undefined) {
			component._margin.y = data.bottom;
			_marginChange = true;
		}

		if (data.right !== undefined) {
			component._margin.z = data.right;
			_marginChange = true;
		}

		if (data.top !== undefined) {
			component._margin.w = data.top;
			_marginChange = true;
		}

		if (_marginChange) {
			component.margin = component._margin;
		}

		let shouldForceSetAnchor = false;

		if (data.width !== undefined && !splitHorAnchors) {
			component.width = data.width;
		} else if (splitHorAnchors) {
			shouldForceSetAnchor = true;
		}

		if (data.height !== undefined && !splitVerAnchors) {
			component.height = data.height;
		} else if (splitVerAnchors) {
			shouldForceSetAnchor = true;
		}

		if (shouldForceSetAnchor) {
			component.anchor = component.anchor;
		}

		if (data.enabled !== undefined) {
			component.enabled = data.enabled;
		}

		if (data.useInput !== undefined) {
			component.useInput = data.useInput;
		}

		component.batchGroupId = data.batchGroupId === undefined || data.batchGroupId === null ? -1 : data.batchGroupId;

		if (data.layers && Array.isArray(data.layers)) {
			component.layers = data.layers.slice(0);
		}

		if (data.type !== undefined) {
			component.type = data.type;
		}

		if (component.type === ELEMENTTYPE_IMAGE) {
			if (data.rect !== undefined) {
				component.rect = data.rect;
			}

			if (data.color !== undefined) {
				color = data.color;

				if (!(color instanceof Color)) {
					color = new Color(data.color[0], data.color[1], data.color[2]);
				}

				component.color = color;
			}

			if (data.opacity !== undefined) component.opacity = data.opacity;
			if (data.textureAsset !== undefined) component.textureAsset = data.textureAsset;
			if (data.texture) component.texture = data.texture;
			if (data.spriteAsset !== undefined) component.spriteAsset = data.spriteAsset;
			if (data.sprite) component.sprite = data.sprite;
			if (data.spriteFrame !== undefined) component.spriteFrame = data.spriteFrame;
			if (data.pixelsPerUnit !== undefined && data.pixelsPerUnit !== null) component.pixelsPerUnit = data.pixelsPerUnit;
			if (data.materialAsset !== undefined) component.materialAsset = data.materialAsset;
			if (data.material) component.material = data.material;

			if (data.mask !== undefined) {
				component.mask = data.mask;
			}
		} else if (component.type === ELEMENTTYPE_TEXT) {
			if (data.autoWidth !== undefined) component.autoWidth = data.autoWidth;
			if (data.autoHeight !== undefined) component.autoHeight = data.autoHeight;
			if (data.rtlReorder !== undefined) component.rtlReorder = data.rtlReorder;
			if (data.unicodeConverter !== undefined) component.unicodeConverter = data.unicodeConverter;

			if (data.text !== null && data.text !== undefined) {
				component.text = data.text;
			} else if (data.key !== null && data.key !== undefined) {
				component.key = data.key;
			}

			if (data.color !== undefined) {
				color = data.color;

				if (!(color instanceof Color)) {
					color = new Color(color[0], color[1], color[2]);
				}

				component.color = color;
			}

			if (data.opacity !== undefined) {
				component.opacity = data.opacity;
			}

			if (data.spacing !== undefined) component.spacing = data.spacing;

			if (data.fontSize !== undefined) {
				component.fontSize = data.fontSize;
				if (!data.lineHeight) component.lineHeight = data.fontSize;
			}

			if (data.lineHeight !== undefined) component.lineHeight = data.lineHeight;
			if (data.maxLines !== undefined) component.maxLines = data.maxLines;
			if (data.wrapLines !== undefined) component.wrapLines = data.wrapLines;
			if (data.minFontSize !== undefined) component.minFontSize = data.minFontSize;
			if (data.maxFontSize !== undefined) component.maxFontSize = data.maxFontSize;
			if (data.autoFitWidth) component.autoFitWidth = data.autoFitWidth;
			if (data.autoFitHeight) component.autoFitHeight = data.autoFitHeight;
			if (data.fontAsset !== undefined) component.fontAsset = data.fontAsset;
			if (data.font !== undefined) component.font = data.font;
			if (data.alignment !== undefined) component.alignment = data.alignment;
			if (data.outlineColor !== undefined) component.outlineColor = data.outlineColor;
			if (data.outlineThickness !== undefined) component.outlineThickness = data.outlineThickness;
			if (data.shadowColor !== undefined) component.shadowColor = data.shadowColor;
			if (data.shadowOffset !== undefined) component.shadowOffset = data.shadowOffset;
			if (data.enableMarkup !== undefined) component.enableMarkup = data.enableMarkup;
		}

		const result = component._parseUpToScreen();

		if (result.screen) {
			component._updateScreen(result.screen);
		}

		super.initializeComponentData(component, data, properties);
		component._beingInitialized = false;

		if (component.type === ELEMENTTYPE_IMAGE && component._image._meshDirty) {
			component._image._updateMesh(component._image.mesh);
		}
	}

	onRemoveComponent(entity, component) {
		component.onRemove();
	}

	cloneComponent(entity, clone) {
		const source = entity.element;
		const data = {
			enabled: source.enabled,
			width: source.width,
			height: source.height,
			anchor: source.anchor.clone(),
			pivot: source.pivot.clone(),
			margin: source.margin.clone(),
			alignment: source.alignment && source.alignment.clone() || source.alignment,
			autoWidth: source.autoWidth,
			autoHeight: source.autoHeight,
			type: source.type,
			rect: source.rect && source.rect.clone() || source.rect,
			rtlReorder: source.rtlReorder,
			unicodeConverter: source.unicodeConverter,
			materialAsset: source.materialAsset,
			material: source.material,
			color: source.color && source.color.clone() || source.color,
			opacity: source.opacity,
			textureAsset: source.textureAsset,
			texture: source.texture,
			spriteAsset: source.spriteAsset,
			sprite: source.sprite,
			spriteFrame: source.spriteFrame,
			pixelsPerUnit: source.pixelsPerUnit,
			spacing: source.spacing,
			lineHeight: source.lineHeight,
			wrapLines: source.wrapLines,
			layers: source.layers,
			fontSize: source.fontSize,
			minFontSize: source.minFontSize,
			maxFontSize: source.maxFontSize,
			autoFitWidth: source.autoFitWidth,
			autoFitHeight: source.autoFitHeight,
			maxLines: source.maxLines,
			fontAsset: source.fontAsset,
			font: source.font,
			useInput: source.useInput,
			batchGroupId: source.batchGroupId,
			mask: source.mask,
			outlineColor: source.outlineColor && source.outlineColor.clone() || source.outlineColor,
			outlineThickness: source.outlineThickness,
			shadowColor: source.shadowColor && source.shadowColor.clone() || source.shadowColor,
			shadowOffset: source.shadowOffset && source.shadowOffset.clone() || source.shadowOffset,
			enableMarkup: source.enableMarkup
		};

		if (source.key !== undefined && source.key !== null) {
			data.key = source.key;
		} else {
			data.text = source.text;
		}

		return this.addComponent(clone, data);
	}

	getTextElementMaterial(screenSpace, msdf) {
		if (screenSpace) {
			if (msdf) {
				if (!this.defaultScreenSpaceTextMaterial) {
					this.defaultScreenSpaceTextMaterial = new StandardMaterial();
					this.defaultScreenSpaceTextMaterial.name = "defaultScreenSpaceTextMaterial";
					this.defaultScreenSpaceTextMaterial.msdfMap = this._defaultTexture;
					this.defaultScreenSpaceTextMaterial.useLighting = false;
					this.defaultScreenSpaceTextMaterial.useGammaTonemap = false;
					this.defaultScreenSpaceTextMaterial.useFog = false;
					this.defaultScreenSpaceTextMaterial.useSkybox = false;
					this.defaultScreenSpaceTextMaterial.diffuse.set(0, 0, 0);
					this.defaultScreenSpaceTextMaterial.emissive.set(1, 1, 1);
					this.defaultScreenSpaceTextMaterial.opacity = 0.5;
					this.defaultScreenSpaceTextMaterial.blendType = BLEND_PREMULTIPLIED;
					this.defaultScreenSpaceTextMaterial.depthWrite = false;
					this.defaultScreenSpaceTextMaterial.depthTest = false;
					this.defaultScreenSpaceTextMaterial.emissiveVertexColor = true;
					this.defaultScreenSpaceTextMaterial.update();
				}

				return this.defaultScreenSpaceTextMaterial;
			}

			if (!this.defaultScreenSpaceBitmapTextMaterial) {
				this.defaultScreenSpaceBitmapTextMaterial = new StandardMaterial();
				this.defaultScreenSpaceBitmapTextMaterial.name = "defaultScreenSpaceBitmapTextMaterial";
				this.defaultScreenSpaceBitmapTextMaterial.emissive.set(0.5, 0.5, 0.5);
				this.defaultScreenSpaceBitmapTextMaterial.emissiveMap = this._defaultTexture;
				this.defaultScreenSpaceBitmapTextMaterial.emissiveTint = true;
				this.defaultScreenSpaceBitmapTextMaterial.opacity = 0.5;
				this.defaultScreenSpaceBitmapTextMaterial.opacityMap = this._defaultTexture;
				this.defaultScreenSpaceBitmapTextMaterial.opacityMapChannel = 'a';
				this.defaultScreenSpaceBitmapTextMaterial.useLighting = false;
				this.defaultScreenSpaceBitmapTextMaterial.useGammaTonemap = false;
				this.defaultScreenSpaceBitmapTextMaterial.useFog = false;
				this.defaultScreenSpaceBitmapTextMaterial.useSkybox = false;
				this.defaultScreenSpaceBitmapTextMaterial.diffuse.set(0, 0, 0);
				this.defaultScreenSpaceBitmapTextMaterial.blendType = BLEND_PREMULTIPLIED;
				this.defaultScreenSpaceBitmapTextMaterial.depthWrite = false;
				this.defaultScreenSpaceBitmapTextMaterial.depthTest = false;
				this.defaultScreenSpaceBitmapTextMaterial.emissiveVertexColor = true;
				this.defaultScreenSpaceBitmapTextMaterial.update();
			}

			return this.defaultScreenSpaceBitmapTextMaterial;
		}

		if (msdf) {
			if (!this.defaultTextMaterial) {
				this.defaultTextMaterial = new StandardMaterial();
				this.defaultTextMaterial.name = "defaultTextMaterial";
				this.defaultTextMaterial.msdfMap = this._defaultTexture;
				this.defaultTextMaterial.useLighting = false;
				this.defaultTextMaterial.useGammaTonemap = false;
				this.defaultTextMaterial.useFog = false;
				this.defaultTextMaterial.useSkybox = false;
				this.defaultTextMaterial.diffuse.set(0, 0, 0);
				this.defaultTextMaterial.emissive.set(1, 1, 1);
				this.defaultTextMaterial.opacity = 0.5;
				this.defaultTextMaterial.blendType = BLEND_PREMULTIPLIED;
				this.defaultTextMaterial.depthWrite = false;
				this.defaultTextMaterial.emissiveVertexColor = true;
				this.defaultTextMaterial.update();
			}

			return this.defaultTextMaterial;
		}

		if (!this.defaultBitmapTextMaterial) {
			this.defaultBitmapTextMaterial = new StandardMaterial();
			this.defaultBitmapTextMaterial.name = "defaultBitmapTextMaterial";
			this.defaultBitmapTextMaterial.emissive.set(0.5, 0.5, 0.5);
			this.defaultBitmapTextMaterial.emissiveTint = true;
			this.defaultBitmapTextMaterial.emissiveMap = this._defaultTexture;
			this.defaultBitmapTextMaterial.opacity = 0.5;
			this.defaultBitmapTextMaterial.opacityMap = this._defaultTexture;
			this.defaultBitmapTextMaterial.opacityMapChannel = 'a';
			this.defaultBitmapTextMaterial.useLighting = false;
			this.defaultBitmapTextMaterial.useGammaTonemap = false;
			this.defaultBitmapTextMaterial.useFog = false;
			this.defaultBitmapTextMaterial.useSkybox = false;
			this.defaultBitmapTextMaterial.diffuse.set(0, 0, 0);
			this.defaultBitmapTextMaterial.blendType = BLEND_PREMULTIPLIED;
			this.defaultBitmapTextMaterial.depthWrite = false;
			this.defaultBitmapTextMaterial.emissiveVertexColor = true;
			this.defaultBitmapTextMaterial.update();
		}

		return this.defaultBitmapTextMaterial;
	}

	_createBaseImageMaterial() {
		const material = new StandardMaterial();
		material.diffuse.set(0, 0, 0);
		material.emissive.set(0.5, 0.5, 0.5);
		material.emissiveMap = this._defaultTexture;
		material.emissiveTint = true;
		material.opacityMap = this._defaultTexture;
		material.opacityMapChannel = "a";
		material.opacityTint = true;
		material.opacity = 0;
		material.useLighting = false;
		material.useGammaTonemap = false;
		material.useFog = false;
		material.useSkybox = false;
		material.blendType = BLEND_PREMULTIPLIED;
		material.depthWrite = false;
		return material;
	}

	getImageElementMaterial(screenSpace, mask, nineSliced, nineSliceTiled) {
		if (screenSpace) {
			if (mask) {
				if (nineSliced) {
					if (!this.defaultScreenSpaceImageMask9SlicedMaterial) {
						this.defaultScreenSpaceImageMask9SlicedMaterial = this._createBaseImageMaterial();
						this.defaultScreenSpaceImageMask9SlicedMaterial.name = "defaultScreenSpaceImageMask9SlicedMaterial";
						this.defaultScreenSpaceImageMask9SlicedMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;
						this.defaultScreenSpaceImageMask9SlicedMaterial.depthTest = false;
						this.defaultScreenSpaceImageMask9SlicedMaterial.alphaTest = 1;
						this.defaultScreenSpaceImageMask9SlicedMaterial.redWrite = false;
						this.defaultScreenSpaceImageMask9SlicedMaterial.greenWrite = false;
						this.defaultScreenSpaceImageMask9SlicedMaterial.blueWrite = false;
						this.defaultScreenSpaceImageMask9SlicedMaterial.alphaWrite = false;
						this.defaultScreenSpaceImageMask9SlicedMaterial.update();
						this.defaultImageMaterials.push(this.defaultScreenSpaceImageMask9SlicedMaterial);
					}

					return this.defaultScreenSpaceImageMask9SlicedMaterial;
				} else if (nineSliceTiled) {
					if (!this.defaultScreenSpaceImageMask9TiledMaterial) {
						this.defaultScreenSpaceImageMask9TiledMaterial = this.defaultScreenSpaceImage9TiledMaterial.clone();
						this.defaultScreenSpaceImageMask9TiledMaterial.name = "defaultScreenSpaceImageMask9TiledMaterial";
						this.defaultScreenSpaceImageMask9TiledMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;
						this.defaultScreenSpaceImageMask9TiledMaterial.depthTest = false;
						this.defaultScreenSpaceImageMask9TiledMaterial.alphaTest = 1;
						this.defaultScreenSpaceImageMask9TiledMaterial.redWrite = false;
						this.defaultScreenSpaceImageMask9TiledMaterial.greenWrite = false;
						this.defaultScreenSpaceImageMask9TiledMaterial.blueWrite = false;
						this.defaultScreenSpaceImageMask9TiledMaterial.alphaWrite = false;
						this.defaultScreenSpaceImageMask9TiledMaterial.update();
						this.defaultImageMaterials.push(this.defaultScreenSpaceImageMask9TiledMaterial);
					}

					return this.defaultScreenSpaceImageMask9TiledMaterial;
				} else {
					if (!this.defaultScreenSpaceImageMaskMaterial) {
						this.defaultScreenSpaceImageMaskMaterial = this._createBaseImageMaterial();
						this.defaultScreenSpaceImageMaskMaterial.name = "defaultScreenSpaceImageMaskMaterial";
						this.defaultScreenSpaceImageMaskMaterial.depthTest = false;
						this.defaultScreenSpaceImageMaskMaterial.alphaTest = 1;
						this.defaultScreenSpaceImageMaskMaterial.redWrite = false;
						this.defaultScreenSpaceImageMaskMaterial.greenWrite = false;
						this.defaultScreenSpaceImageMaskMaterial.blueWrite = false;
						this.defaultScreenSpaceImageMaskMaterial.alphaWrite = false;
						this.defaultScreenSpaceImageMaskMaterial.update();
						this.defaultImageMaterials.push(this.defaultScreenSpaceImageMaskMaterial);
					}

					return this.defaultScreenSpaceImageMaskMaterial;
				}
			} else {
				if (nineSliced) {
					if (!this.defaultScreenSpaceImage9SlicedMaterial) {
						this.defaultScreenSpaceImage9SlicedMaterial = this._createBaseImageMaterial();
						this.defaultScreenSpaceImage9SlicedMaterial.name = "defaultScreenSpaceImage9SlicedMaterial";
						this.defaultScreenSpaceImage9SlicedMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;
						this.defaultScreenSpaceImage9SlicedMaterial.depthTest = false;
						this.defaultScreenSpaceImage9SlicedMaterial.update();
						this.defaultImageMaterials.push(this.defaultScreenSpaceImage9SlicedMaterial);
					}

					return this.defaultScreenSpaceImage9SlicedMaterial;
				} else if (nineSliceTiled) {
					if (!this.defaultScreenSpaceImage9TiledMaterial) {
						this.defaultScreenSpaceImage9TiledMaterial = this._createBaseImageMaterial();
						this.defaultScreenSpaceImage9TiledMaterial.name = "defaultScreenSpaceImage9TiledMaterial";
						this.defaultScreenSpaceImage9TiledMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;
						this.defaultScreenSpaceImage9TiledMaterial.depthTest = false;
						this.defaultScreenSpaceImage9TiledMaterial.update();
						this.defaultImageMaterials.push(this.defaultScreenSpaceImage9TiledMaterial);
					}

					return this.defaultScreenSpaceImage9TiledMaterial;
				} else {
					if (!this.defaultScreenSpaceImageMaterial) {
						this.defaultScreenSpaceImageMaterial = this._createBaseImageMaterial();
						this.defaultScreenSpaceImageMaterial.name = "defaultScreenSpaceImageMaterial";
						this.defaultScreenSpaceImageMaterial.depthTest = false;
						this.defaultScreenSpaceImageMaterial.update();
						this.defaultImageMaterials.push(this.defaultScreenSpaceImageMaterial);
					}

					return this.defaultScreenSpaceImageMaterial;
				}
			}
		} else {
			if (mask) {
				if (nineSliced) {
					if (!this.defaultImage9SlicedMaskMaterial) {
						this.defaultImage9SlicedMaskMaterial = this._createBaseImageMaterial();
						this.defaultImage9SlicedMaskMaterial.name = "defaultImage9SlicedMaskMaterial";
						this.defaultImage9SlicedMaskMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;
						this.defaultImage9SlicedMaskMaterial.alphaTest = 1;
						this.defaultImage9SlicedMaskMaterial.redWrite = false;
						this.defaultImage9SlicedMaskMaterial.greenWrite = false;
						this.defaultImage9SlicedMaskMaterial.blueWrite = false;
						this.defaultImage9SlicedMaskMaterial.alphaWrite = false;
						this.defaultImage9SlicedMaskMaterial.update();
						this.defaultImageMaterials.push(this.defaultImage9SlicedMaskMaterial);
					}

					return this.defaultImage9SlicedMaskMaterial;
				} else if (nineSliceTiled) {
					if (!this.defaultImage9TiledMaskMaterial) {
						this.defaultImage9TiledMaskMaterial = this._createBaseImageMaterial();
						this.defaultImage9TiledMaskMaterial.name = "defaultImage9TiledMaskMaterial";
						this.defaultImage9TiledMaskMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;
						this.defaultImage9TiledMaskMaterial.alphaTest = 1;
						this.defaultImage9TiledMaskMaterial.redWrite = false;
						this.defaultImage9TiledMaskMaterial.greenWrite = false;
						this.defaultImage9TiledMaskMaterial.blueWrite = false;
						this.defaultImage9TiledMaskMaterial.alphaWrite = false;
						this.defaultImage9TiledMaskMaterial.update();
						this.defaultImageMaterials.push(this.defaultImage9TiledMaskMaterial);
					}

					return this.defaultImage9TiledMaskMaterial;
				} else {
					if (!this.defaultImageMaskMaterial) {
						this.defaultImageMaskMaterial = this._createBaseImageMaterial();
						this.defaultImageMaskMaterial.name = "defaultImageMaskMaterial";
						this.defaultImageMaskMaterial.alphaTest = 1;
						this.defaultImageMaskMaterial.redWrite = false;
						this.defaultImageMaskMaterial.greenWrite = false;
						this.defaultImageMaskMaterial.blueWrite = false;
						this.defaultImageMaskMaterial.alphaWrite = false;
						this.defaultImageMaskMaterial.update();
						this.defaultImageMaterials.push(this.defaultImageMaskMaterial);
					}

					return this.defaultImageMaskMaterial;
				}
			} else {
				if (nineSliced) {
					if (!this.defaultImage9SlicedMaterial) {
						this.defaultImage9SlicedMaterial = this._createBaseImageMaterial();
						this.defaultImage9SlicedMaterial.name = "defaultImage9SlicedMaterial";
						this.defaultImage9SlicedMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;
						this.defaultImage9SlicedMaterial.update();
						this.defaultImageMaterials.push(this.defaultImage9SlicedMaterial);
					}

					return this.defaultImage9SlicedMaterial;
				} else if (nineSliceTiled) {
					if (!this.defaultImage9TiledMaterial) {
						this.defaultImage9TiledMaterial = this._createBaseImageMaterial();
						this.defaultImage9TiledMaterial.name = "defaultImage9TiledMaterial";
						this.defaultImage9TiledMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;
						this.defaultImage9TiledMaterial.update();
						this.defaultImageMaterials.push(this.defaultImage9TiledMaterial);
					}

					return this.defaultImage9TiledMaterial;
				} else {
					if (!this.defaultImageMaterial) {
						this.defaultImageMaterial = this._createBaseImageMaterial();
						this.defaultImageMaterial.name = "defaultImageMaterial";
						this.defaultImageMaterial.update();
						this.defaultImageMaterials.push(this.defaultImageMaterial);
					}

					return this.defaultImageMaterial;
				}
			}
		}
	}

	registerUnicodeConverter(func) {
		this._unicodeConverter = func;
	}

	registerRtlReorder(func) {
		this._rtlReorder = func;
	}

	getUnicodeConverter() {
		return this._unicodeConverter;
	}

	getRtlReorder() {
		return this._rtlReorder;
	}

}

Component._buildAccessors(ElementComponent.prototype, _schema$e);

const MOTION_FREE = 'free';
const MOTION_LIMITED = 'limited';
const MOTION_LOCKED = 'locked';

const properties = ['angularDampingX', 'angularDampingY', 'angularDampingZ', 'angularEquilibriumX', 'angularEquilibriumY', 'angularEquilibriumZ', 'angularLimitsX', 'angularLimitsY', 'angularLimitsZ', 'angularMotionX', 'angularMotionY', 'angularMotionZ', 'angularSpringX', 'angularSpringY', 'angularSpringZ', 'angularStiffnessX', 'angularStiffnessY', 'angularStiffnessZ', 'breakForce', 'enableCollision', 'enabled', 'entityA', 'entityB', 'linearDampingX', 'linearDampingY', 'linearDampingZ', 'linearEquilibriumX', 'linearEquilibriumY', 'linearEquilibriumZ', 'linearLimitsX', 'linearLimitsY', 'linearLimitsZ', 'linearMotionX', 'linearMotionY', 'linearMotionZ', 'linearSpringX', 'linearSpringY', 'linearSpringZ', 'linearStiffnessX', 'linearStiffnessY', 'linearStiffnessZ'];

class JointComponent extends Component {
	constructor(system, entity) {
		super(system, entity);
		this._constraint = null;
		this._entityA = null;
		this._entityB = null;
		this._breakForce = 3.4e+38;
		this._enableCollision = true;
		this._linearMotionX = MOTION_LOCKED;
		this._linearLimitsX = new Vec2(0, 0);
		this._linearSpringX = false;
		this._linearStiffnessX = 0;
		this._linearDampingX = 1;
		this._linearEquilibriumX = 0;
		this._linearMotionY = MOTION_LOCKED;
		this._linearLimitsY = new Vec2(0, 0);
		this._linearSpringY = false;
		this._linearStiffnessY = 0;
		this._linearDampingY = 1;
		this._linearEquilibriumY = 0;
		this._linearMotionZ = MOTION_LOCKED;
		this._linearLimitsZ = new Vec2(0, 0);
		this._linearSpringZ = false;
		this._linearStiffnessZ = 0;
		this._linearDampingZ = 1;
		this._linearEquilibriumZ = 0;
		this._angularMotionX = MOTION_LOCKED;
		this._angularLimitsX = new Vec2(0, 0);
		this._angularSpringX = false;
		this._angularStiffnessX = 0;
		this._angularDampingX = 1;
		this._angularEquilibriumX = 0;
		this._angularMotionY = MOTION_LOCKED;
		this._angularLimitsY = new Vec2(0, 0);
		this._angularSpringY = false;
		this._angularStiffnessY = 0;
		this._angularDampingY = 1;
		this._angularEquilibriumY = 0;
		this._angularMotionZ = MOTION_LOCKED;
		this._angularLimitsZ = new Vec2(0, 0);
		this._angularSpringZ = false;
		this._angularEquilibriumZ = 0;
		this._angularDampingZ = 1;
		this._angularStiffnessZ = 0;
		this.on('set_enabled', this._onSetEnabled, this);
	}

	set entityA(body) {
		this._destroyConstraint();

		this._entityA = body;

		this._createConstraint();
	}

	get entityA() {
		return this._entityA;
	}

	set entityB(body) {
		this._destroyConstraint();

		this._entityB = body;

		this._createConstraint();
	}

	get entityB() {
		return this._entityB;
	}

	set breakForce(force) {
		if (this._constraint && this._breakForce !== force) {
			this._constraint.setBreakingImpulseThreshold(force);

			this._breakForce = force;
		}
	}

	get breakForce() {
		return this._breakForce;
	}

	set enableCollision(enableCollision) {
		this._destroyConstraint();

		this._enableCollision = enableCollision;

		this._createConstraint();
	}

	get enableCollision() {
		return this._enableCollision;
	}

	set angularLimitsX(limits) {
		if (!this._angularLimitsX.equals(limits)) {
			this._angularLimitsX.copy(limits);

			this._updateAngularLimits();
		}
	}

	get angularLimitsX() {
		return this._angularLimitsX;
	}

	set angularMotionX(value) {
		if (this._angularMotionX !== value) {
			this._angularMotionX = value;

			this._updateAngularLimits();
		}
	}

	get angularMotionX() {
		return this._angularMotionX;
	}

	set angularLimitsY(limits) {
		if (!this._angularLimitsY.equals(limits)) {
			this._angularLimitsY.copy(limits);

			this._updateAngularLimits();
		}
	}

	get angularLimitsY() {
		return this._angularLimitsY;
	}

	set angularMotionY(value) {
		if (this._angularMotionY !== value) {
			this._angularMotionY = value;

			this._updateAngularLimits();
		}
	}

	get angularMotionY() {
		return this._angularMotionY;
	}

	set angularLimitsZ(limits) {
		if (!this._angularLimitsZ.equals(limits)) {
			this._angularLimitsZ.copy(limits);

			this._updateAngularLimits();
		}
	}

	get angularLimitsZ() {
		return this._angularLimitsZ;
	}

	set angularMotionZ(value) {
		if (this._angularMotionZ !== value) {
			this._angularMotionZ = value;

			this._updateAngularLimits();
		}
	}

	get angularMotionZ() {
		return this._angularMotionZ;
	}

	set linearLimitsX(limits) {
		if (!this._linearLimitsX.equals(limits)) {
			this._linearLimitsX.copy(limits);

			this._updateLinearLimits();
		}
	}

	get linearLimitsX() {
		return this._linearLimitsX;
	}

	set linearMotionX(value) {
		if (this._linearMotionX !== value) {
			this._linearMotionX = value;

			this._updateLinearLimits();
		}
	}

	get linearMotionX() {
		return this._linearMotionX;
	}

	set linearLimitsY(limits) {
		if (!this._linearLimitsY.equals(limits)) {
			this._linearLimitsY.copy(limits);

			this._updateLinearLimits();
		}
	}

	get linearLimitsY() {
		return this._linearLimitsY;
	}

	set linearMotionY(value) {
		if (this._linearMotionY !== value) {
			this._linearMotionY = value;

			this._updateLinearLimits();
		}
	}

	get linearMotionY() {
		return this._linearMotionY;
	}

	set linearLimitsZ(limits) {
		if (!this._linearLimitsZ.equals(limits)) {
			this._linearLimitsZ.copy(limits);

			this._updateLinearLimits();
		}
	}

	get linearLimitsZ() {
		return this._linearLimitsZ;
	}

	set linearMotionZ(value) {
		if (this._linearMotionZ !== value) {
			this._linearMotionZ = value;

			this._updateLinearLimits();
		}
	}

	get linearMotionZ() {
		return this._linearMotionZ;
	}

	_convertTransform(pcTransform, ammoTransform) {
		const pos = pcTransform.getTranslation();
		const rot = new Quat();
		rot.setFromMat4(pcTransform);
		const ammoVec = new Ammo.btVector3(pos.x, pos.y, pos.z);
		const ammoQuat = new Ammo.btQuaternion(rot.x, rot.y, rot.z, rot.w);
		ammoTransform.setOrigin(ammoVec);
		ammoTransform.setRotation(ammoQuat);
		Ammo.destroy(ammoVec);
		Ammo.destroy(ammoQuat);
	}

	_updateAngularLimits() {
		const constraint = this._constraint;

		if (constraint) {
			let lx, ly, lz, ux, uy, uz;

			if (this._angularMotionX === MOTION_LIMITED) {
				lx = this._angularLimitsX.x * math.DEG_TO_RAD;
				ux = this._angularLimitsX.y * math.DEG_TO_RAD;
			} else if (this._angularMotionX === MOTION_FREE) {
				lx = 1;
				ux = 0;
			} else {
				lx = ux = 0;
			}

			if (this._angularMotionY === MOTION_LIMITED) {
				ly = this._angularLimitsY.x * math.DEG_TO_RAD;
				uy = this._angularLimitsY.y * math.DEG_TO_RAD;
			} else if (this._angularMotionY === MOTION_FREE) {
				ly = 1;
				uy = 0;
			} else {
				ly = uy = 0;
			}

			if (this._angularMotionZ === MOTION_LIMITED) {
				lz = this._angularLimitsZ.x * math.DEG_TO_RAD;
				uz = this._angularLimitsZ.y * math.DEG_TO_RAD;
			} else if (this._angularMotionZ === MOTION_FREE) {
				lz = 1;
				uz = 0;
			} else {
				lz = uz = 0;
			}

			const limits = new Ammo.btVector3(lx, ly, lz);
			constraint.setAngularLowerLimit(limits);
			limits.setValue(ux, uy, uz);
			constraint.setAngularUpperLimit(limits);
			Ammo.destroy(limits);
		}
	}

	_updateLinearLimits() {
		const constraint = this._constraint;

		if (constraint) {
			let lx, ly, lz, ux, uy, uz;

			if (this._linearMotionX === MOTION_LIMITED) {
				lx = this._linearLimitsX.x;
				ux = this._linearLimitsX.y;
			} else if (this._linearMotionX === MOTION_FREE) {
				lx = 1;
				ux = 0;
			} else {
				lx = ux = 0;
			}

			if (this._linearMotionY === MOTION_LIMITED) {
				ly = this._linearLimitsY.x;
				uy = this._linearLimitsY.y;
			} else if (this._linearMotionY === MOTION_FREE) {
				ly = 1;
				uy = 0;
			} else {
				ly = uy = 0;
			}

			if (this._linearMotionZ === MOTION_LIMITED) {
				lz = this._linearLimitsZ.x;
				uz = this._linearLimitsZ.y;
			} else if (this._linearMotionZ === MOTION_FREE) {
				lz = 1;
				uz = 0;
			} else {
				lz = uz = 0;
			}

			const limits = new Ammo.btVector3(lx, ly, lz);
			constraint.setLinearLowerLimit(limits);
			limits.setValue(ux, uy, uz);
			constraint.setLinearUpperLimit(limits);
			Ammo.destroy(limits);
		}
	}

	_createConstraint() {
		if (this._entityA && this._entityA.rigidbody) {
			this._destroyConstraint();

			const mat = new Mat4();
			const bodyA = this._entityA.rigidbody.body;
			bodyA.activate();
			const jointWtm = this.entity.getWorldTransform();

			const entityAWtm = this._entityA.getWorldTransform();

			const invEntityAWtm = entityAWtm.clone().invert();
			mat.mul2(invEntityAWtm, jointWtm);
			const frameA = new Ammo.btTransform();

			this._convertTransform(mat, frameA);

			if (this._entityB && this._entityB.rigidbody) {
				const bodyB = this._entityB.rigidbody.body;
				bodyB.activate();

				const entityBWtm = this._entityB.getWorldTransform();

				const invEntityBWtm = entityBWtm.clone().invert();
				mat.mul2(invEntityBWtm, jointWtm);
				const frameB = new Ammo.btTransform();

				this._convertTransform(mat, frameB);

				this._constraint = new Ammo.btGeneric6DofSpringConstraint(bodyA, bodyB, frameA, frameB, !this._enableCollision);
				Ammo.destroy(frameB);
			} else {
				this._constraint = new Ammo.btGeneric6DofSpringConstraint(bodyA, frameA, !this._enableCollision);
			}

			Ammo.destroy(frameA);
			const axis = ['X', 'Y', 'Z', 'X', 'Y', 'Z'];

			for (let i = 0; i < 6; i++) {
				const type = i < 3 ? '_linear' : '_angular';

				this._constraint.enableSpring(i, this[type + 'Spring' + axis[i]]);

				this._constraint.setDamping(i, this[type + 'Damping' + axis[i]]);

				this._constraint.setEquilibriumPoint(i, this[type + 'Equilibrium' + axis[i]]);

				this._constraint.setStiffness(i, this[type + 'Stiffness' + axis[i]]);
			}

			this._constraint.setBreakingImpulseThreshold(this._breakForce);

			this._updateLinearLimits();

			this._updateAngularLimits();

			const app = this.system.app;
			const dynamicsWorld = app.systems.rigidbody.dynamicsWorld;
			dynamicsWorld.addConstraint(this._constraint, !this._enableCollision);
		}
	}

	_destroyConstraint() {
		if (this._constraint) {
			const app = this.system.app;
			const dynamicsWorld = app.systems.rigidbody.dynamicsWorld;
			dynamicsWorld.removeConstraint(this._constraint);
			Ammo.destroy(this._constraint);
			this._constraint = null;
		}
	}

	initFromData(data) {
		for (const prop of properties) {
			if (data.hasOwnProperty(prop)) {
				if (data[prop] instanceof Vec2) {
					this['_' + prop].copy(data[prop]);
				} else {
					this['_' + prop] = data[prop];
				}
			}
		}

		this._createConstraint();
	}

	onEnable() {
		this._createConstraint();
	}

	onDisable() {
		this._destroyConstraint();
	}

	_onSetEnabled(prop, old, value) {}

	_onBeforeRemove() {
		this.fire('remove');
	}

}

const functionMap = {
	Damping: 'setDamping',
	Equilibrium: 'setEquilibriumPoint',
	Spring: 'enableSpring',
	Stiffness: 'setStiffness'
};
['linear', 'angular'].forEach(type => {
	['Damping', 'Equilibrium', 'Spring', 'Stiffness'].forEach(name => {
		['X', 'Y', 'Z'].forEach(axis => {
			const prop = type + name + axis;
			const propInternal = '_' + prop;
			let index = type === 'linear' ? 0 : 3;
			if (axis === 'Y') index += 1;
			if (axis === 'Z') index += 2;
			Object.defineProperty(JointComponent.prototype, prop, {
				get: function () {
					return this[propInternal];
				},
				set: function (value) {
					if (this[propInternal] !== value) {
						this[propInternal] = value;

						this._constraint[functionMap[name]](index, value);
					}
				}
			});
		});
	});
});

class JointComponentData {
	constructor() {
		this.enabled = true;
	}

}

const _schema$d = ['enabled'];

class JointComponentSystem extends ComponentSystem {
	constructor(app) {
		super(app);
		this.id = 'joint';
		this.app = app;
		this.ComponentType = JointComponent;
		this.DataType = JointComponentData;
		this.schema = _schema$d;
	}

	initializeComponentData(component, data, properties) {
		component.initFromData(data);
	}

}

Component._buildAccessors(JointComponent.prototype, _schema$d);

class LayoutChildComponent extends Component {
	constructor(system, entity) {
		super(system, entity);
		this._minWidth = 0;
		this._minHeight = 0;
		this._maxWidth = null;
		this._maxHeight = null;
		this._fitWidthProportion = 0;
		this._fitHeightProportion = 0;
		this._excludeFromLayout = false;
	}

	set minWidth(value) {
		if (value !== this._minWidth) {
			this._minWidth = value;
			this.fire('resize');
		}
	}

	get minWidth() {
		return this._minWidth;
	}

	set minHeight(value) {
		if (value !== this._minHeight) {
			this._minHeight = value;
			this.fire('resize');
		}
	}

	get minHeight() {
		return this._minHeight;
	}

	set maxWidth(value) {
		if (value !== this._maxWidth) {
			this._maxWidth = value;
			this.fire('resize');
		}
	}

	get maxWidth() {
		return this._maxWidth;
	}

	set maxHeight(value) {
		if (value !== this._maxHeight) {
			this._maxHeight = value;
			this.fire('resize');
		}
	}

	get maxHeight() {
		return this._maxHeight;
	}

	set fitWidthProportion(value) {
		if (value !== this._fitWidthProportion) {
			this._fitWidthProportion = value;
			this.fire('resize');
		}
	}

	get fitWidthProportion() {
		return this._fitWidthProportion;
	}

	set fitHeightProportion(value) {
		if (value !== this._fitHeightProportion) {
			this._fitHeightProportion = value;
			this.fire('resize');
		}
	}

	get fitHeightProportion() {
		return this._fitHeightProportion;
	}

	set excludeFromLayout(value) {
		if (value !== this._excludeFromLayout) {
			this._excludeFromLayout = value;
			this.fire('resize');
		}
	}

	get excludeFromLayout() {
		return this._excludeFromLayout;
	}

}

class LayoutChildComponentData {
	constructor() {
		this.enabled = true;
	}

}

const _schema$c = ['enabled'];

class LayoutChildComponentSystem extends ComponentSystem {
	constructor(app) {
		super(app);
		this.id = 'layoutchild';
		this.ComponentType = LayoutChildComponent;
		this.DataType = LayoutChildComponentData;
		this.schema = _schema$c;
	}

	initializeComponentData(component, data, properties) {
		if (data.enabled !== undefined) component.enabled = data.enabled;
		if (data.minWidth !== undefined) component.minWidth = data.minWidth;
		if (data.minHeight !== undefined) component.minHeight = data.minHeight;
		if (data.maxWidth !== undefined) component.maxWidth = data.maxWidth;
		if (data.maxHeight !== undefined) component.maxHeight = data.maxHeight;
		if (data.fitWidthProportion !== undefined) component.fitWidthProportion = data.fitWidthProportion;
		if (data.fitHeightProportion !== undefined) component.fitHeightProportion = data.fitHeightProportion;
		if (data.excludeFromLayout !== undefined) component.excludeFromLayout = data.excludeFromLayout;
		super.initializeComponentData(component, data, properties);
	}

	cloneComponent(entity, clone) {
		const layoutChild = entity.layoutchild;
		return this.addComponent(clone, {
			enabled: layoutChild.enabled,
			minWidth: layoutChild.minWidth,
			minHeight: layoutChild.minHeight,
			maxWidth: layoutChild.maxWidth,
			maxHeight: layoutChild.maxHeight,
			fitWidthProportion: layoutChild.fitWidthProportion,
			fitHeightProportion: layoutChild.fitHeightProportion,
			excludeFromLayout: layoutChild.excludeFromLayout
		});
	}

}

Component._buildAccessors(LayoutChildComponent.prototype, _schema$c);

const FITTING_NONE = 0;
const FITTING_STRETCH = 1;
const FITTING_SHRINK = 2;
const FITTING_BOTH = 3;

const AXIS_MAPPINGS = {};
AXIS_MAPPINGS[ORIENTATION_HORIZONTAL] = {
	axis: 'x',
	size: 'width',
	calculatedSize: 'calculatedWidth',
	minSize: 'minWidth',
	maxSize: 'maxWidth',
	fitting: 'widthFitting',
	fittingProportion: 'fitWidthProportion'
};
AXIS_MAPPINGS[ORIENTATION_VERTICAL] = {
	axis: 'y',
	size: 'height',
	calculatedSize: 'calculatedHeight',
	minSize: 'minHeight',
	maxSize: 'maxHeight',
	fitting: 'heightFitting',
	fittingProportion: 'fitHeightProportion'
};
const OPPOSITE_ORIENTATION = {};
OPPOSITE_ORIENTATION[ORIENTATION_HORIZONTAL] = ORIENTATION_VERTICAL;
OPPOSITE_ORIENTATION[ORIENTATION_VERTICAL] = ORIENTATION_HORIZONTAL;
const PROPERTY_DEFAULTS = {
	minWidth: 0,
	minHeight: 0,
	maxWidth: Number.POSITIVE_INFINITY,
	maxHeight: Number.POSITIVE_INFINITY,
	width: null,
	height: null,
	fitWidthProportion: 0,
	fitHeightProportion: 0
};
const FITTING_ACTION = {
	NONE: 'NONE',
	APPLY_STRETCHING: 'APPLY_STRETCHING',
	APPLY_SHRINKING: 'APPLY_SHRINKING'
};
const availableSpace = new Vec2();

function createCalculator(orientation) {
	let options;
	const a = AXIS_MAPPINGS[orientation];
	const b = AXIS_MAPPINGS[OPPOSITE_ORIENTATION[orientation]];

	function minExtentA(element, size) {
		return -size[a.size] * element.pivot[a.axis];
	}

	function minExtentB(element, size) {
		return -size[b.size] * element.pivot[b.axis];
	}

	function maxExtentA(element, size) {
		return size[a.size] * (1 - element.pivot[a.axis]);
	}

	function calculateAll(allElements, layoutOptions) {
		allElements = allElements.filter(shouldIncludeInLayout);
		options = layoutOptions;
		availableSpace.x = options.containerSize.x - options.padding.x - options.padding.z;
		availableSpace.y = options.containerSize.y - options.padding.y - options.padding.w;
		resetAnchors(allElements);
		const lines = reverseLinesIfRequired(splitLines(allElements));
		const sizes = calculateSizesOnAxisB(lines, calculateSizesOnAxisA(lines));
		const positions = calculateBasePositions(lines, sizes);
		applyAlignmentAndPadding(lines, sizes, positions);
		applySizesAndPositions(lines, sizes, positions);
		return createLayoutInfo(lines);
	}

	function shouldIncludeInLayout(element) {
		const layoutChildComponent = element.entity.layoutchild;
		return !layoutChildComponent || !layoutChildComponent.enabled || !layoutChildComponent.excludeFromLayout;
	}

	function resetAnchors(allElements) {
		for (let i = 0; i < allElements.length; ++i) {
			const element = allElements[i];
			const anchor = element.anchor;

			if (anchor.x !== 0 || anchor.y !== 0 || anchor.z !== 0 || anchor.w !== 0) {
				element.anchor = Vec4.ZERO;
			}
		}
	}

	function splitLines(allElements) {
		if (!options.wrap) {
			return [allElements];
		}

		const lines = [[]];
		const sizes = getElementSizeProperties(allElements);
		let runningSize = 0;
		const allowOverrun = options[a.fitting] === FITTING_SHRINK;

		for (let i = 0; i < allElements.length; ++i) {
			if (lines[lines.length - 1].length > 0) {
				runningSize += options.spacing[a.axis];
			}

			const idealElementSize = sizes[i][a.size];
			runningSize += idealElementSize;

			if (!allowOverrun && runningSize > availableSpace[a.axis] && lines[lines.length - 1].length !== 0) {
				runningSize = idealElementSize;
				lines.push([]);
			}

			lines[lines.length - 1].push(allElements[i]);

			if (allowOverrun && runningSize > availableSpace[a.axis] && i !== allElements.length - 1) {
				runningSize = 0;
				lines.push([]);
			}
		}

		return lines;
	}

	function reverseLinesIfRequired(lines) {
		const reverseAxisA = options.orientation === ORIENTATION_HORIZONTAL && options.reverseX || options.orientation === ORIENTATION_VERTICAL && options.reverseY;
		const reverseAxisB = options.orientation === ORIENTATION_HORIZONTAL && options.reverseY || options.orientation === ORIENTATION_VERTICAL && options.reverseX;

		if (reverseAxisA) {
			for (let lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
				if (reverseAxisA) {
					lines[lineIndex].reverse();
				}
			}
		}

		if (reverseAxisB) {
			lines.reverse();
		}

		return lines;
	}

	function calculateSizesOnAxisA(lines) {
		const sizesAllLines = [];

		for (let lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
			const line = lines[lineIndex];
			const sizesThisLine = getElementSizeProperties(line);
			const idealRequiredSpace = calculateTotalSpace(sizesThisLine, a);
			const fittingAction = determineFittingAction(options[a.fitting], idealRequiredSpace, availableSpace[a.axis]);

			if (fittingAction === FITTING_ACTION.APPLY_STRETCHING) {
				stretchSizesToFitContainer(sizesThisLine, idealRequiredSpace, a);
			} else if (fittingAction === FITTING_ACTION.APPLY_SHRINKING) {
				shrinkSizesToFitContainer(sizesThisLine, idealRequiredSpace, a);
			}

			sizesAllLines.push(sizesThisLine);
		}

		return sizesAllLines;
	}

	function calculateSizesOnAxisB(lines, sizesAllLines) {
		const largestElementsForEachLine = [];
		const largestSizesForEachLine = [];

		for (let lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
			const line = lines[lineIndex];
			line.largestElement = null;
			line.largestSize = {
				width: Number.NEGATIVE_INFINITY,
				height: Number.NEGATIVE_INFINITY
			};

			for (let elementIndex = 0; elementIndex < line.length; ++elementIndex) {
				const sizesThisElement = sizesAllLines[lineIndex][elementIndex];

				if (sizesThisElement[b.size] > line.largestSize[b.size]) {
					line.largestElement = line[elementIndex];
					line.largestSize = sizesThisElement;
				}
			}

			largestElementsForEachLine.push(line.largestElement);
			largestSizesForEachLine.push(line.largestSize);
		}

		const idealRequiredSpace = calculateTotalSpace(largestSizesForEachLine, b);
		const fittingAction = determineFittingAction(options[b.fitting], idealRequiredSpace, availableSpace[b.axis]);

		if (fittingAction === FITTING_ACTION.APPLY_STRETCHING) {
			stretchSizesToFitContainer(largestSizesForEachLine, idealRequiredSpace, b);
		} else if (fittingAction === FITTING_ACTION.APPLY_SHRINKING) {
			shrinkSizesToFitContainer(largestSizesForEachLine, idealRequiredSpace, b);
		}

		for (let lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
			const line = lines[lineIndex];

			for (let elementIndex = 0; elementIndex < line.length; ++elementIndex) {
				const sizesForThisElement = sizesAllLines[lineIndex][elementIndex];
				const currentSize = sizesForThisElement[b.size];
				const availableSize = lines.length === 1 ? availableSpace[b.axis] : line.largestSize[b.size];
				const elementFittingAction = determineFittingAction(options[b.fitting], currentSize, availableSize);

				if (elementFittingAction === FITTING_ACTION.APPLY_STRETCHING) {
					sizesForThisElement[b.size] = Math.min(availableSize, sizesForThisElement[b.maxSize]);
				} else if (elementFittingAction === FITTING_ACTION.APPLY_SHRINKING) {
					sizesForThisElement[b.size] = Math.max(availableSize, sizesForThisElement[b.minSize]);
				}
			}
		}

		return sizesAllLines;
	}

	function determineFittingAction(fittingMode, currentSize, availableSize) {
		switch (fittingMode) {
			case FITTING_NONE:
				return FITTING_ACTION.NONE;

			case FITTING_STRETCH:
				if (currentSize < availableSize) {
					return FITTING_ACTION.APPLY_STRETCHING;
				}

				return FITTING_ACTION.NONE;

			case FITTING_SHRINK:
				if (currentSize >= availableSize) {
					return FITTING_ACTION.APPLY_SHRINKING;
				}

				return FITTING_ACTION.NONE;

			case FITTING_BOTH:
				if (currentSize < availableSize) {
					return FITTING_ACTION.APPLY_STRETCHING;
				}

				return FITTING_ACTION.APPLY_SHRINKING;

			default:
				throw new Error(`Unrecognized fitting mode: ${fittingMode}`);
		}
	}

	function calculateTotalSpace(sizes, axis) {
		const totalSizes = sumValues(sizes, axis.size);
		const totalSpacing = (sizes.length - 1) * options.spacing[axis.axis];
		return totalSizes + totalSpacing;
	}

	function stretchSizesToFitContainer(sizesThisLine, idealRequiredSpace, axis) {
		const ascendingMaxSizeOrder = getTraversalOrder(sizesThisLine, axis.maxSize);
		const fittingProportions = getNormalizedValues(sizesThisLine, axis.fittingProportion);
		const fittingProportionSums = createSumArray(fittingProportions, ascendingMaxSizeOrder);
		let remainingUndershoot = availableSpace[axis.axis] - idealRequiredSpace;

		for (let i = 0; i < sizesThisLine.length; ++i) {
			const index = ascendingMaxSizeOrder[i];
			const targetIncrease = calculateAdjustment(index, remainingUndershoot, fittingProportions, fittingProportionSums);
			const targetSize = sizesThisLine[index][axis.size] + targetIncrease;
			const maxSize = sizesThisLine[index][axis.maxSize];
			const actualSize = Math.min(targetSize, maxSize);
			sizesThisLine[index][axis.size] = actualSize;
			const actualIncrease = Math.max(targetSize - actualSize, 0);
			const appliedIncrease = targetIncrease - actualIncrease;
			remainingUndershoot -= appliedIncrease;
		}
	}

	function shrinkSizesToFitContainer(sizesThisLine, idealRequiredSpace, axis) {
		const descendingMinSizeOrder = getTraversalOrder(sizesThisLine, axis.minSize, true);
		const fittingProportions = getNormalizedValues(sizesThisLine, axis.fittingProportion);
		const inverseFittingProportions = invertNormalizedValues(fittingProportions);
		const inverseFittingProportionSums = createSumArray(inverseFittingProportions, descendingMinSizeOrder);
		let remainingOvershoot = idealRequiredSpace - availableSpace[axis.axis];

		for (let i = 0; i < sizesThisLine.length; ++i) {
			const index = descendingMinSizeOrder[i];
			const targetReduction = calculateAdjustment(index, remainingOvershoot, inverseFittingProportions, inverseFittingProportionSums);
			const targetSize = sizesThisLine[index][axis.size] - targetReduction;
			const minSize = sizesThisLine[index][axis.minSize];
			const actualSize = Math.max(targetSize, minSize);
			sizesThisLine[index][axis.size] = actualSize;
			const actualReduction = Math.max(actualSize - targetSize, 0);
			const appliedReduction = targetReduction - actualReduction;
			remainingOvershoot -= appliedReduction;
		}
	}

	function calculateAdjustment(index, remainingAdjustment, fittingProportions, fittingProportionSums) {
		const proportion = fittingProportions[index];
		const sumOfRemainingProportions = fittingProportionSums[index];

		if (Math.abs(proportion) < 1e-5 && Math.abs(sumOfRemainingProportions) < 1e-5) {
			return remainingAdjustment;
		}

		return remainingAdjustment * proportion / sumOfRemainingProportions;
	}

	function calculateBasePositions(lines, sizes) {
		const cursor = {};
		cursor[a.axis] = 0;
		cursor[b.axis] = 0;
		lines[a.size] = Number.NEGATIVE_INFINITY;
		const positionsAllLines = [];

		for (let lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
			const line = lines[lineIndex];

			if (line.length === 0) {
				positionsAllLines.push([]);
				continue;
			}

			const positionsThisLine = [];
			const sizesThisLine = sizes[lineIndex];

			for (let elementIndex = 0; elementIndex < line.length; ++elementIndex) {
				const element = line[elementIndex];
				const sizesThisElement = sizesThisLine[elementIndex];
				cursor[b.axis] -= minExtentB(element, sizesThisElement);
				cursor[a.axis] -= minExtentA(element, sizesThisElement);
				positionsThisLine[elementIndex] = {};
				positionsThisLine[elementIndex][a.axis] = cursor[a.axis];
				positionsThisLine[elementIndex][b.axis] = cursor[b.axis];
				cursor[b.axis] += minExtentB(element, sizesThisElement);
				cursor[a.axis] += maxExtentA(element, sizesThisElement) + options.spacing[a.axis];
			}

			line[a.size] = cursor[a.axis] - options.spacing[a.axis];
			line[b.size] = line.largestSize[b.size];
			lines[a.size] = Math.max(lines[a.size], line[a.size]);
			cursor[a.axis] = 0;
			cursor[b.axis] += line[b.size] + options.spacing[b.axis];
			positionsAllLines.push(positionsThisLine);
		}

		lines[b.size] = cursor[b.axis] - options.spacing[b.axis];
		return positionsAllLines;
	}

	function applyAlignmentAndPadding(lines, sizes, positions) {
		const alignmentA = options.alignment[a.axis];
		const alignmentB = options.alignment[b.axis];
		const paddingA = options.padding[a.axis];
		const paddingB = options.padding[b.axis];

		for (let lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
			const line = lines[lineIndex];
			const sizesThisLine = sizes[lineIndex];
			const positionsThisLine = positions[lineIndex];
			const axisAOffset = (availableSpace[a.axis] - line[a.size]) * alignmentA + paddingA;
			const axisBOffset = (availableSpace[b.axis] - lines[b.size]) * alignmentB + paddingB;

			for (let elementIndex = 0; elementIndex < line.length; ++elementIndex) {
				const withinLineAxisBOffset = (line[b.size] - sizesThisLine[elementIndex][b.size]) * options.alignment[b.axis];
				positionsThisLine[elementIndex][a.axis] += axisAOffset;
				positionsThisLine[elementIndex][b.axis] += axisBOffset + withinLineAxisBOffset;
			}
		}
	}

	function applySizesAndPositions(lines, sizes, positions) {
		for (let lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
			const line = lines[lineIndex];
			const sizesThisLine = sizes[lineIndex];
			const positionsThisLine = positions[lineIndex];

			for (let elementIndex = 0; elementIndex < line.length; ++elementIndex) {
				const element = line[elementIndex];
				element[a.calculatedSize] = sizesThisLine[elementIndex][a.size];
				element[b.calculatedSize] = sizesThisLine[elementIndex][b.size];

				if (options.orientation === ORIENTATION_HORIZONTAL) {
					element.entity.setLocalPosition(positionsThisLine[elementIndex][a.axis], positionsThisLine[elementIndex][b.axis], element.entity.getLocalPosition().z);
				} else {
					element.entity.setLocalPosition(positionsThisLine[elementIndex][b.axis], positionsThisLine[elementIndex][a.axis], element.entity.getLocalPosition().z);
				}
			}
		}
	}

	function createLayoutInfo(lines) {
		const layoutWidth = lines.width;
		const layoutHeight = lines.height;
		const xOffset = (availableSpace.x - layoutWidth) * options.alignment.x + options.padding.x;
		const yOffset = (availableSpace.y - layoutHeight) * options.alignment.y + options.padding.y;
		return {
			bounds: new Vec4(xOffset, yOffset, layoutWidth, layoutHeight)
		};
	}

	function getElementSizeProperties(elements) {
		const sizeProperties = [];

		for (let i = 0; i < elements.length; ++i) {
			const element = elements[i];
			const minWidth = Math.max(getProperty(element, 'minWidth'), 0);
			const minHeight = Math.max(getProperty(element, 'minHeight'), 0);
			const maxWidth = Math.max(getProperty(element, 'maxWidth'), minWidth);
			const maxHeight = Math.max(getProperty(element, 'maxHeight'), minHeight);
			const width = clamp(getProperty(element, 'width'), minWidth, maxWidth);
			const height = clamp(getProperty(element, 'height'), minHeight, maxHeight);
			const fitWidthProportion = getProperty(element, 'fitWidthProportion');
			const fitHeightProportion = getProperty(element, 'fitHeightProportion');
			sizeProperties.push({
				minWidth: minWidth,
				minHeight: minHeight,
				maxWidth: maxWidth,
				maxHeight: maxHeight,
				width: width,
				height: height,
				fitWidthProportion: fitWidthProportion,
				fitHeightProportion: fitHeightProportion
			});
		}

		return sizeProperties;
	}

	function getProperty(element, propertyName) {
		const layoutChildComponent = element.entity.layoutchild;

		if (layoutChildComponent && layoutChildComponent.enabled && layoutChildComponent[propertyName] !== undefined && layoutChildComponent[propertyName] !== null) {
			return layoutChildComponent[propertyName];
		} else if (element[propertyName] !== undefined) {
			return element[propertyName];
		}

		return PROPERTY_DEFAULTS[propertyName];
	}

	function clamp(value, min, max) {
		return Math.min(Math.max(value, min), max);
	}

	function sumValues(items, propertyName) {
		return items.reduce(function (accumulator, current) {
			return accumulator + current[propertyName];
		}, 0);
	}

	function getNormalizedValues(items, propertyName) {
		const sum = sumValues(items, propertyName);
		const normalizedValues = [];
		const numItems = items.length;

		if (sum === 0) {
			for (let i = 0; i < numItems; ++i) {
				normalizedValues.push(1 / numItems);
			}
		} else {
			for (let i = 0; i < numItems; ++i) {
				normalizedValues.push(items[i][propertyName] / sum);
			}
		}

		return normalizedValues;
	}

	function invertNormalizedValues(values) {
		if (values.length === 1) {
			return [1];
		}

		const invertedValues = [];
		const numValues = values.length;

		for (let i = 0; i < numValues; ++i) {
			invertedValues.push((1 - values[i]) / (numValues - 1));
		}

		return invertedValues;
	}

	function getTraversalOrder(items, orderBy, descending) {
		items.forEach(assignIndex);
		return items.slice().sort(function (itemA, itemB) {
			return descending ? itemB[orderBy] - itemA[orderBy] : itemA[orderBy] - itemB[orderBy];
		}).map(getIndex);
	}

	function assignIndex(item, index) {
		item.index = index;
	}

	function getIndex(item) {
		return item.index;
	}

	function createSumArray(values, order) {
		const sumArray = [];
		sumArray[order[values.length - 1]] = values[order[values.length - 1]];

		for (let i = values.length - 2; i >= 0; --i) {
			sumArray[order[i]] = sumArray[order[i + 1]] + values[order[i]];
		}

		return sumArray;
	}

	return calculateAll;
}

const CALCULATE_FNS = {};
CALCULATE_FNS[ORIENTATION_HORIZONTAL] = createCalculator(ORIENTATION_HORIZONTAL);
CALCULATE_FNS[ORIENTATION_VERTICAL] = createCalculator(ORIENTATION_VERTICAL);

class LayoutCalculator {
	calculateLayout(elements, options) {
		const calculateFn = CALCULATE_FNS[options.orientation];

		if (!calculateFn) {
			throw new Error('Unrecognized orientation value: ' + options.orientation);
		} else {
			return calculateFn(elements, options);
		}
	}

}

function getElement(entity) {
	return entity.element;
}

function isEnabledAndHasEnabledElement(entity) {
	return entity.enabled && entity.element && entity.element.enabled;
}

class LayoutGroupComponent extends Component {
	constructor(system, entity) {
		super(system, entity);
		this._orientation = ORIENTATION_HORIZONTAL;
		this._reverseX = false;
		this._reverseY = true;
		this._alignment = new Vec2(0, 1);
		this._padding = new Vec4();
		this._spacing = new Vec2();
		this._widthFitting = FITTING_NONE;
		this._heightFitting = FITTING_NONE;
		this._wrap = false;
		this._layoutCalculator = new LayoutCalculator();

		this._listenForReflowEvents(this.entity, 'on');

		this.entity.children.forEach(child => {
			this._listenForReflowEvents(child, 'on');
		});
		this.entity.on('childinsert', this._onChildInsert, this);
		this.entity.on('childremove', this._onChildRemove, this);
		system.app.systems.element.on('add', this._onElementOrLayoutComponentAdd, this);
		system.app.systems.element.on('beforeremove', this._onElementOrLayoutComponentRemove, this);
		system.app.systems.layoutchild.on('add', this._onElementOrLayoutComponentAdd, this);
		system.app.systems.layoutchild.on('beforeremove', this._onElementOrLayoutComponentRemove, this);
	}

	set orientation(value) {
		if (value !== this._orientation) {
			this._orientation = value;

			this._scheduleReflow();
		}
	}

	get orientation() {
		return this._orientation;
	}

	set reverseX(value) {
		if (value !== this._reverseX) {
			this._reverseX = value;

			this._scheduleReflow();
		}
	}

	get reverseX() {
		return this._reverseX;
	}

	set reverseY(value) {
		if (value !== this._reverseY) {
			this._reverseY = value;

			this._scheduleReflow();
		}
	}

	get reverseY() {
		return this._reverseY;
	}

	set alignment(value) {
		if (!value.equals(this._alignment)) {
			this._alignment.copy(value);

			this._scheduleReflow();
		}
	}

	get alignment() {
		return this._alignment;
	}

	set padding(value) {
		if (!value.equals(this._padding)) {
			this._padding.copy(value);

			this._scheduleReflow();
		}
	}

	get padding() {
		return this._padding;
	}

	set spacing(value) {
		if (!value.equals(this._spacing)) {
			this._spacing.copy(value);

			this._scheduleReflow();
		}
	}

	get spacing() {
		return this._spacing;
	}

	set widthFitting(value) {
		if (value !== this._widthFitting) {
			this._widthFitting = value;

			this._scheduleReflow();
		}
	}

	get widthFitting() {
		return this._widthFitting;
	}

	set heightFitting(value) {
		if (value !== this._heightFitting) {
			this._heightFitting = value;

			this._scheduleReflow();
		}
	}

	get heightFitting() {
		return this._heightFitting;
	}

	set wrap(value) {
		if (value !== this._wrap) {
			this._wrap = value;

			this._scheduleReflow();
		}
	}

	get wrap() {
		return this._wrap;
	}

	_isSelfOrChild(entity) {
		return entity === this.entity || this.entity.children.indexOf(entity) !== -1;
	}

	_listenForReflowEvents(target, onOff) {
		if (target.element) {
			target.element[onOff]('enableelement', this._scheduleReflow, this);
			target.element[onOff]('disableelement', this._scheduleReflow, this);
			target.element[onOff]('resize', this._scheduleReflow, this);
			target.element[onOff]('set:pivot', this._scheduleReflow, this);
		}

		if (target.layoutchild) {
			target.layoutchild[onOff]('set_enabled', this._scheduleReflow, this);
			target.layoutchild[onOff]('resize', this._scheduleReflow, this);
		}
	}

	_onElementOrLayoutComponentAdd(entity) {
		if (this._isSelfOrChild(entity)) {
			this._listenForReflowEvents(entity, 'on');

			this._scheduleReflow();
		}
	}

	_onElementOrLayoutComponentRemove(entity) {
		if (this._isSelfOrChild(entity)) {
			this._listenForReflowEvents(entity, 'off');

			this._scheduleReflow();
		}
	}

	_onChildInsert(child) {
		this._listenForReflowEvents(child, 'on');

		this._scheduleReflow();
	}

	_onChildRemove(child) {
		this._listenForReflowEvents(child, 'off');

		this._scheduleReflow();
	}

	_scheduleReflow() {
		if (this.enabled && this.entity && this.entity.enabled && !this._isPerformingReflow) {
			this.system.scheduleReflow(this);
		}
	}

	reflow() {
		const container = getElement(this.entity);
		const elements = this.entity.children.filter(isEnabledAndHasEnabledElement).map(getElement);

		if (!container || elements.length === 0) {
			return;
		}

		const containerWidth = Math.max(container.calculatedWidth, 0);
		const containerHeight = Math.max(container.calculatedHeight, 0);
		const options = {
			orientation: this._orientation,
			reverseX: this._reverseX,
			reverseY: this._reverseY,
			alignment: this._alignment,
			padding: this._padding,
			spacing: this._spacing,
			widthFitting: this._widthFitting,
			heightFitting: this._heightFitting,
			wrap: this._wrap,
			containerSize: new Vec2(containerWidth, containerHeight)
		};
		this._isPerformingReflow = true;

		const layoutInfo = this._layoutCalculator.calculateLayout(elements, options);

		this._isPerformingReflow = false;
		this.fire('reflow', layoutInfo);
	}

	onEnable() {
		this._scheduleReflow();
	}

	onRemove() {
		this.entity.off('childinsert', this._onChildInsert, this);
		this.entity.off('childremove', this._onChildRemove, this);

		this._listenForReflowEvents(this.entity, 'off');

		this.entity.children.forEach(child => {
			this._listenForReflowEvents(child, 'off');
		});
		this.system.app.systems.element.off('add', this._onElementOrLayoutComponentAdd, this);
		this.system.app.systems.element.off('beforeremove', this._onElementOrLayoutComponentRemove, this);
		this.system.app.systems.layoutchild.off('add', this._onElementOrLayoutComponentAdd, this);
		this.system.app.systems.layoutchild.off('beforeremove', this._onElementOrLayoutComponentRemove, this);
	}

}

class LayoutGroupComponentData {
	constructor() {
		this.enabled = true;
	}

}

const _schema$b = ['enabled'];
const MAX_ITERATIONS = 100;

class LayoutGroupComponentSystem extends ComponentSystem {
	constructor(app) {
		super(app);
		this.id = 'layoutgroup';
		this.ComponentType = LayoutGroupComponent;
		this.DataType = LayoutGroupComponentData;
		this.schema = _schema$b;
		this._reflowQueue = [];
		this.on('beforeremove', this._onRemoveComponent, this);
		this.app.systems.on('postUpdate', this._onPostUpdate, this);
	}

	initializeComponentData(component, data, properties) {
		if (data.enabled !== undefined) component.enabled = data.enabled;
		if (data.orientation !== undefined) component.orientation = data.orientation;
		if (data.reverseX !== undefined) component.reverseX = data.reverseX;
		if (data.reverseY !== undefined) component.reverseY = data.reverseY;

		if (data.alignment !== undefined) {
			component.alignment = Array.isArray(data.alignment) ? new Vec2(data.alignment) : data.alignment;
		}

		if (data.padding !== undefined) {
			component.padding = Array.isArray(data.padding) ? new Vec4(data.padding) : data.padding;
		}

		if (data.spacing !== undefined) {
			component.spacing = Array.isArray(data.spacing) ? new Vec2(data.spacing) : data.spacing;
		}

		if (data.widthFitting !== undefined) component.widthFitting = data.widthFitting;
		if (data.heightFitting !== undefined) component.heightFitting = data.heightFitting;
		if (data.wrap !== undefined) component.wrap = data.wrap;
		super.initializeComponentData(component, data, properties);
	}

	cloneComponent(entity, clone) {
		const layoutGroup = entity.layoutgroup;
		return this.addComponent(clone, {
			enabled: layoutGroup.enabled,
			orientation: layoutGroup.orientation,
			reverseX: layoutGroup.reverseX,
			reverseY: layoutGroup.reverseY,
			alignment: layoutGroup.alignment,
			padding: layoutGroup.padding,
			spacing: layoutGroup.spacing,
			widthFitting: layoutGroup.widthFitting,
			heightFitting: layoutGroup.heightFitting,
			wrap: layoutGroup.wrap
		});
	}

	scheduleReflow(component) {
		if (this._reflowQueue.indexOf(component) === -1) {
			this._reflowQueue.push(component);
		}
	}

	_onPostUpdate() {
		this._processReflowQueue();
	}

	_processReflowQueue() {
		if (this._reflowQueue.length === 0) {
			return;
		}

		let iterationCount = 0;

		while (this._reflowQueue.length > 0) {
			const queue = this._reflowQueue.slice();

			this._reflowQueue.length = 0;
			queue.sort(function (componentA, componentB) {
				return componentA.entity.graphDepth - componentB.entity.graphDepth;
			});

			for (let i = 0; i < queue.length; ++i) {
				queue[i].reflow();
			}

			if (++iterationCount >= MAX_ITERATIONS) {
				console.warn('Max reflow iterations limit reached, bailing.');
				break;
			}
		}
	}

	_onRemoveComponent(entity, component) {
		component.onRemove();
	}

	destroy() {
		super.destroy();
		this.app.systems.off('postUpdate', this._onPostUpdate, this);
	}

}

Component._buildAccessors(LayoutGroupComponent.prototype, _schema$b);

const _lightProps = [];
const _lightPropsDefault = [];

class LightComponent extends Component {
	constructor(system, entity) {
		super(system, entity);
		this._cookieAsset = null;
		this._cookieAssetId = null;
		this._cookieAssetAdd = false;
		this._cookieMatrix = null;
	}

	addLightToLayers() {
		for (let i = 0; i < this.layers.length; i++) {
			const layer = this.system.app.scene.layers.getLayerById(this.layers[i]);

			if (layer) {
				layer.addLight(this);
			}
		}
	}

	removeLightFromLayers() {
		for (let i = 0; i < this.layers.length; i++) {
			const layer = this.system.app.scene.layers.getLayerById(this.layers[i]);

			if (layer) {
				layer.removeLight(this);
			}
		}
	}

	onLayersChanged(oldComp, newComp) {
		if (this.enabled && this.entity.enabled) {
			this.addLightToLayers();
		}

		oldComp.off("add", this.onLayerAdded, this);
		oldComp.off("remove", this.onLayerRemoved, this);
		newComp.on("add", this.onLayerAdded, this);
		newComp.on("remove", this.onLayerRemoved, this);
	}

	onLayerAdded(layer) {
		const index = this.layers.indexOf(layer.id);

		if (index >= 0 && this.enabled && this.entity.enabled) {
			layer.addLight(this);
		}
	}

	onLayerRemoved(layer) {
		const index = this.layers.indexOf(layer.id);

		if (index >= 0) {
			layer.removeLight(this);
		}
	}

	refreshProperties() {
		for (let i = 0; i < _lightProps.length; i++) {
			const name = _lightProps[i];
			this[name] = this[name];
		}

		if (this.enabled && this.entity.enabled) this.onEnable();
	}

	updateShadow() {
		this.light.updateShadow();
	}

	onCookieAssetSet() {
		let forceLoad = false;

		if (this._cookieAsset.type === 'cubemap' && !this._cookieAsset.loadFaces) {
			this._cookieAsset.loadFaces = true;
			forceLoad = true;
		}

		if (!this._cookieAsset.resource || forceLoad) this.system.app.assets.load(this._cookieAsset);
		if (this._cookieAsset.resource) this.onCookieAssetLoad();
	}

	onCookieAssetAdd(asset) {
		if (this._cookieAssetId !== asset.id) return;
		this._cookieAsset = asset;
		if (this.light.enabled) this.onCookieAssetSet();

		this._cookieAsset.on('load', this.onCookieAssetLoad, this);

		this._cookieAsset.on('remove', this.onCookieAssetRemove, this);
	}

	onCookieAssetLoad() {
		if (!this._cookieAsset || !this._cookieAsset.resource) return;
		this.cookie = this._cookieAsset.resource;
	}

	onCookieAssetRemove() {
		if (!this._cookieAssetId) return;

		if (this._cookieAssetAdd) {
			this.system.app.assets.off('add:' + this._cookieAssetId, this.onCookieAssetAdd, this);
			this._cookieAssetAdd = false;
		}

		if (this._cookieAsset) {
			this._cookieAsset.off('load', this.onCookieAssetLoad, this);

			this._cookieAsset.off('remove', this.onCookieAssetRemove, this);

			this._cookieAsset = null;
		}

		this.cookie = null;
	}

	onEnable() {
		this.light.enabled = true;
		this.system.app.scene.on("set:layers", this.onLayersChanged, this);

		if (this.system.app.scene.layers) {
			this.system.app.scene.layers.on("add", this.onLayerAdded, this);
			this.system.app.scene.layers.on("remove", this.onLayerRemoved, this);
		}

		if (this.enabled && this.entity.enabled) {
			this.addLightToLayers();
		}

		if (this._cookieAsset && !this.cookie) this.onCookieAssetSet();
	}

	onDisable() {
		this.light.enabled = false;
		this.system.app.scene.off("set:layers", this.onLayersChanged, this);

		if (this.system.app.scene.layers) {
			this.system.app.scene.layers.off("add", this.onLayerAdded, this);
			this.system.app.scene.layers.off("remove", this.onLayerRemoved, this);
		}

		this.removeLightFromLayers();
	}

	onRemove() {
		this.onDisable();
		this.light.destroy();
		this.cookieAsset = null;
	}

}

function _defineProperty(name, defaultValue, setFunc, skipEqualsCheck) {
	const c = LightComponent.prototype;

	_lightProps.push(name);

	_lightPropsDefault.push(defaultValue);

	Object.defineProperty(c, name, {
		get: function () {
			return this.data[name];
		},
		set: function (value) {
			const data = this.data;
			const oldValue = data[name];
			if (!skipEqualsCheck && oldValue === value) return;
			data[name] = value;
			if (setFunc) setFunc.call(this, value, oldValue);
		},
		configurable: true
	});
}

function _defineProps() {
	_defineProperty("enabled", true, function (newValue, oldValue) {
		this.onSetEnabled(null, oldValue, newValue);
	});

	_defineProperty("light", null);

	_defineProperty("type", 'directional', function (newValue, oldValue) {
		this.system.changeType(this, oldValue, newValue);
		this.refreshProperties();
	});

	_defineProperty("color", new Color(1, 1, 1), function (newValue, oldValue) {
		this.light.setColor(newValue);
	}, true);

	_defineProperty("intensity", 1, function (newValue, oldValue) {
		this.light.intensity = newValue;
	});

	_defineProperty("shape", LIGHTSHAPE_PUNCTUAL, function (newValue, oldValue) {
		this.light.shape = newValue;
	});

	_defineProperty("castShadows", false, function (newValue, oldValue) {
		this.light.castShadows = newValue;
	});

	_defineProperty("shadowDistance", 40, function (newValue, oldValue) {
		this.light.shadowDistance = newValue;
	});

	_defineProperty("shadowResolution", 1024, function (newValue, oldValue) {
		this.light.shadowResolution = newValue;
	});

	_defineProperty("shadowBias", 0.05, function (newValue, oldValue) {
		this.light.shadowBias = -0.01 * math.clamp(newValue, 0, 1);
	});

	_defineProperty("numCascades", 1, function (newValue, oldValue) {
		this.light.numCascades = math.clamp(Math.floor(newValue), 1, 4);
	});

	_defineProperty("bakeNumSamples", 1, function (newValue, oldValue) {
		this.light.bakeNumSamples = math.clamp(Math.floor(newValue), 1, 255);
	});

	_defineProperty("bakeArea", 0, function (newValue, oldValue) {
		this.light.bakeArea = math.clamp(newValue, 0, 180);
	});

	_defineProperty("cascadeDistribution", 0.5, function (newValue, oldValue) {
		this.light.cascadeDistribution = math.clamp(newValue, 0, 1);
	});

	_defineProperty("normalOffsetBias", 0, function (newValue, oldValue) {
		this.light.normalOffsetBias = math.clamp(newValue, 0, 1);
	});

	_defineProperty("range", 10, function (newValue, oldValue) {
		this.light.attenuationEnd = newValue;
	});

	_defineProperty("innerConeAngle", 40, function (newValue, oldValue) {
		this.light.innerConeAngle = newValue;
	});

	_defineProperty("outerConeAngle", 45, function (newValue, oldValue) {
		this.light.outerConeAngle = newValue;
	});

	_defineProperty("falloffMode", LIGHTFALLOFF_LINEAR, function (newValue, oldValue) {
		this.light.falloffMode = newValue;
	});

	_defineProperty("shadowType", SHADOW_PCF3, function (newValue, oldValue) {
		this.light.shadowType = newValue;
	});

	_defineProperty("vsmBlurSize", 11, function (newValue, oldValue) {
		this.light.vsmBlurSize = newValue;
	});

	_defineProperty("vsmBlurMode", BLUR_GAUSSIAN, function (newValue, oldValue) {
		this.light.vsmBlurMode = newValue;
	});

	_defineProperty("vsmBias", 0.01 * 0.25, function (newValue, oldValue) {
		this.light.vsmBias = math.clamp(newValue, 0, 1);
	});

	_defineProperty("cookieAsset", null, function (newValue, oldValue) {
		if (this._cookieAssetId && (newValue instanceof Asset && newValue.id === this._cookieAssetId || newValue === this._cookieAssetId)) return;
		this.onCookieAssetRemove();
		this._cookieAssetId = null;

		if (newValue instanceof Asset) {
			this.data.cookieAsset = newValue.id;
			this._cookieAssetId = newValue.id;
			this.onCookieAssetAdd(newValue);
		} else if (typeof newValue === 'number') {
			this._cookieAssetId = newValue;
			const asset = this.system.app.assets.get(newValue);

			if (asset) {
				this.onCookieAssetAdd(asset);
			} else {
				this._cookieAssetAdd = true;
				this.system.app.assets.on('add:' + this._cookieAssetId, this.onCookieAssetAdd, this);
			}
		}
	});

	_defineProperty("cookie", null, function (newValue, oldValue) {
		this.light.cookie = newValue;
	});

	_defineProperty("cookieIntensity", 1, function (newValue, oldValue) {
		this.light.cookieIntensity = math.clamp(newValue, 0, 1);
	});

	_defineProperty("cookieFalloff", true, function (newValue, oldValue) {
		this.light.cookieFalloff = newValue;
	});

	_defineProperty("cookieChannel", "rgb", function (newValue, oldValue) {
		this.light.cookieChannel = newValue;
	});

	_defineProperty("cookieAngle", 0, function (newValue, oldValue) {
		if (newValue !== 0 || this.cookieScale !== null) {
			if (!this._cookieMatrix) this._cookieMatrix = new Vec4();
			let scx = 1;
			let scy = 1;

			if (this.cookieScale) {
				scx = this.cookieScale.x;
				scy = this.cookieScale.y;
			}

			const c = Math.cos(newValue * math.DEG_TO_RAD);
			const s = Math.sin(newValue * math.DEG_TO_RAD);

			this._cookieMatrix.set(c / scx, -s / scx, s / scy, c / scy);

			this.light.cookieTransform = this._cookieMatrix;
		} else {
			this.light.cookieTransform = null;
		}
	});

	_defineProperty("cookieScale", null, function (newValue, oldValue) {
		if (newValue !== null || this.cookieAngle !== 0) {
			if (!this._cookieMatrix) this._cookieMatrix = new Vec4();
			const scx = newValue.x;
			const scy = newValue.y;
			const c = Math.cos(this.cookieAngle * math.DEG_TO_RAD);
			const s = Math.sin(this.cookieAngle * math.DEG_TO_RAD);

			this._cookieMatrix.set(c / scx, -s / scx, s / scy, c / scy);

			this.light.cookieTransform = this._cookieMatrix;
		} else {
			this.light.cookieTransform = null;
		}
	}, true);

	_defineProperty("cookieOffset", null, function (newValue, oldValue) {
		this.light.cookieOffset = newValue;
	}, true);

	_defineProperty("shadowUpdateMode", SHADOWUPDATE_REALTIME, function (newValue, oldValue) {
		this.light.shadowUpdateMode = newValue;
	}, true);

	_defineProperty("mask", 1, function (newValue, oldValue) {
		this.light.mask = newValue;
	});

	_defineProperty("affectDynamic", true, function (newValue, oldValue) {
		if (newValue) {
			this.light.mask |= MASK_AFFECT_DYNAMIC;
		} else {
			this.light.mask &= ~MASK_AFFECT_DYNAMIC;
		}

		this.light.layersDirty();
	});

	_defineProperty("affectLightmapped", false, function (newValue, oldValue) {
		if (newValue) {
			this.light.mask |= MASK_AFFECT_LIGHTMAPPED;
			if (this.bake) this.light.mask &= ~MASK_BAKE;
		} else {
			this.light.mask &= ~MASK_AFFECT_LIGHTMAPPED;
			if (this.bake) this.light.mask |= MASK_BAKE;
		}
	});

	_defineProperty("bake", false, function (newValue, oldValue) {
		if (newValue) {
			this.light.mask |= MASK_BAKE;
			if (this.affectLightmapped) this.light.mask &= ~MASK_AFFECT_LIGHTMAPPED;
		} else {
			this.light.mask &= ~MASK_BAKE;
			if (this.affectLightmapped) this.light.mask |= MASK_AFFECT_LIGHTMAPPED;
		}

		this.light.layersDirty();
	});

	_defineProperty("bakeDir", true, function (newValue, oldValue) {
		this.light.bakeDir = newValue;
	});

	_defineProperty("isStatic", false, function (newValue, oldValue) {
		this.light.isStatic = newValue;
	});

	_defineProperty("layers", [LAYERID_WORLD], function (newValue, oldValue) {
		for (let i = 0; i < oldValue.length; i++) {
			const layer = this.system.app.scene.layers.getLayerById(oldValue[i]);
			if (!layer) continue;
			layer.removeLight(this);
		}

		for (let i = 0; i < newValue.length; i++) {
			const layer = this.system.app.scene.layers.getLayerById(newValue[i]);
			if (!layer) continue;

			if (this.enabled && this.entity.enabled) {
				layer.addLight(this);
			}
		}
	});
}

_defineProps();

class LightComponentData {
	constructor() {
		const _props = _lightProps;
		const _propsDefault = _lightPropsDefault;

		for (let i = 0; i < _props.length; i++) {
			const value = _propsDefault[i];

			if (value && value.clone) {
				this[_props[i]] = value.clone();
			} else {
				this[_props[i]] = value;
			}
		}
	}

}

const lightTypes = {
	'directional': LIGHTTYPE_DIRECTIONAL,
	'omni': LIGHTTYPE_OMNI,
	'point': LIGHTTYPE_OMNI,
	'spot': LIGHTTYPE_SPOT
};

class LightComponentSystem extends ComponentSystem {
	constructor(app) {
		super(app);
		this.id = 'light';
		this.ComponentType = LightComponent;
		this.DataType = LightComponentData;
		this.on('beforeremove', this._onRemoveComponent, this);
	}

	initializeComponentData(component, _data) {
		const properties = _lightProps;
		const data = {};

		for (let i = 0, len = properties.length; i < len; i++) {
			const property = properties[i];
			data[property] = _data[property];
		}

		if (!data.type) data.type = component.data.type;
		component.data.type = data.type;

		if (data.layers && Array.isArray(data.layers)) {
			data.layers = data.layers.slice(0);
		}

		if (data.color && Array.isArray(data.color)) data.color = new Color(data.color[0], data.color[1], data.color[2]);
		if (data.cookieOffset && data.cookieOffset instanceof Array) data.cookieOffset = new Vec2(data.cookieOffset[0], data.cookieOffset[1]);
		if (data.cookieScale && data.cookieScale instanceof Array) data.cookieScale = new Vec2(data.cookieScale[0], data.cookieScale[1]);

		if (data.enable) {
			console.warn("WARNING: enable: Property is deprecated. Set enabled property instead.");
			data.enabled = data.enable;
		}

		if (!data.shape) {
			data.shape = LIGHTSHAPE_PUNCTUAL;
		}

		const light = new Light(this.app.graphicsDevice);
		light.type = lightTypes[data.type];
		light._node = component.entity;
		light._scene = this.app.scene;
		component.data.light = light;
		super.initializeComponentData(component, data, properties);
	}

	_onRemoveComponent(entity, component) {
		component.onRemove();
	}

	cloneComponent(entity, clone) {
		const light = entity.light;
		const data = [];
		let name;
		const _props = _lightProps;

		for (let i = 0; i < _props.length; i++) {
			name = _props[i];
			if (name === "light") continue;

			if (light[name] && light[name].clone) {
				data[name] = light[name].clone();
			} else {
				data[name] = light[name];
			}
		}

		return this.addComponent(clone, data);
	}

	changeType(component, oldValue, newValue) {
		if (oldValue !== newValue) {
			component.light.type = lightTypes[newValue];
		}
	}

}

class ModelComponent extends Component {
	constructor(system, entity) {
		super(system, entity);
		this._type = 'asset';
		this._asset = null;
		this._model = null;
		this._mapping = {};
		this._castShadows = true;
		this._receiveShadows = true;
		this._materialAsset = null;
		this._material = void 0;
		this._castShadowsLightmap = true;
		this._lightmapped = false;
		this._lightmapSizeMultiplier = 1;
		this._isStatic = false;
		this._layers = [LAYERID_WORLD];
		this._batchGroupId = -1;
		this._customAabb = null;
		this._area = null;
		this._materialEvents = null;
		this._clonedModel = false;
		this._material = system.defaultMaterial;
		entity.on('remove', this.onRemoveChild, this);
		entity.on('removehierarchy', this.onRemoveChild, this);
		entity.on('insert', this.onInsertChild, this);
		entity.on('inserthierarchy', this.onInsertChild, this);
	}

	set meshInstances(value) {
		if (!this._model) return;
		this._model.meshInstances = value;
	}

	get meshInstances() {
		if (!this._model) return null;
		return this._model.meshInstances;
	}

	set customAabb(value) {
		this._customAabb = value;

		if (this._model) {
			const mi = this._model.meshInstances;

			if (mi) {
				for (let i = 0; i < mi.length; i++) {
					mi[i].setCustomAabb(this._customAabb);
				}
			}
		}
	}

	get customAabb() {
		return this._customAabb;
	}

	set type(value) {
		if (this._type === value) return;
		this._area = null;
		this._type = value;

		if (value === 'asset') {
			if (this._asset !== null) {
				this._bindModelAsset(this._asset);
			} else {
				this.model = null;
			}
		} else {
			const primData = getShapePrimitive(this.system.app.graphicsDevice, value);
			this._area = primData.area;
			const mesh = primData.mesh;
			const node = new GraphNode();
			const model = new Model();
			model.graph = node;
			model.meshInstances = [new MeshInstance(mesh, this._material, node)];
			this.model = model;
			this._asset = null;
		}
	}

	get type() {
		return this._type;
	}

	set asset(value) {
		const assets = this.system.app.assets;
		let _id = value;

		if (value instanceof Asset) {
			_id = value.id;
		}

		if (this._asset !== _id) {
			if (this._asset) {
				assets.off('add:' + this._asset, this._onModelAssetAdded, this);

				const _prev = assets.get(this._asset);

				if (_prev) {
					this._unbindModelAsset(_prev);
				}
			}

			this._asset = _id;

			if (this._asset) {
				const asset = assets.get(this._asset);

				if (!asset) {
					this.model = null;
					assets.on('add:' + this._asset, this._onModelAssetAdded, this);
				} else {
					this._bindModelAsset(asset);
				}
			} else {
				this.model = null;
			}
		}
	}

	get asset() {
		return this._asset;
	}

	set model(value) {
		if (this._model === value) return;

		if (value && value._immutable) {
			return;
		}

		if (this._model) {
			this._model._immutable = false;
			this.removeModelFromLayers();
			this.entity.removeChild(this._model.getGraph());
			delete this._model._entity;

			if (this._clonedModel) {
				this._model.destroy();

				this._clonedModel = false;
			}
		}

		this._model = value;

		if (this._model) {
			this._model._immutable = true;
			const meshInstances = this._model.meshInstances;

			for (let i = 0; i < meshInstances.length; i++) {
				meshInstances[i].castShadow = this._castShadows;
				meshInstances[i].receiveShadow = this._receiveShadows;
				meshInstances[i].isStatic = this._isStatic;
				meshInstances[i].setCustomAabb(this._customAabb);
			}

			this.lightmapped = this._lightmapped;
			this.entity.addChild(this._model.graph);

			if (this.enabled && this.entity.enabled) {
				this.addModelToLayers();
			}

			this._model._entity = this.entity;
			if (this.entity.animation) this.entity.animation.setModel(this._model);

			if (this.entity.anim) {
				if (this.entity.anim.playing) {
					this.entity.anim.rebind();
				} else {
					this.entity.anim.resetStateGraph();
				}
			}

			if (this.type === 'asset') {
				this.mapping = this._mapping;
			} else {
				this._unsetMaterialEvents();
			}
		}
	}

	get model() {
		return this._model;
	}

	set lightmapped(value) {
		if (value !== this._lightmapped) {
			this._lightmapped = value;

			if (this._model) {
				const mi = this._model.meshInstances;

				for (let i = 0; i < mi.length; i++) {
					mi[i].setLightmapped(value);
				}
			}
		}
	}

	get lightmapped() {
		return this._lightmapped;
	}

	set castShadows(value) {
		if (this._castShadows === value) return;
		const model = this._model;

		if (model) {
			const layers = this.layers;
			const scene = this.system.app.scene;

			if (this._castShadows && !value) {
				for (let i = 0; i < layers.length; i++) {
					const layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
					if (!layer) continue;
					layer.removeShadowCasters(model.meshInstances);
				}
			}

			const meshInstances = model.meshInstances;

			for (let i = 0; i < meshInstances.length; i++) {
				meshInstances[i].castShadow = value;
			}

			if (!this._castShadows && value) {
				for (let i = 0; i < layers.length; i++) {
					const layer = scene.layers.getLayerById(layers[i]);
					if (!layer) continue;
					layer.addShadowCasters(model.meshInstances);
				}
			}
		}

		this._castShadows = value;
	}

	get castShadows() {
		return this._castShadows;
	}

	set receiveShadows(value) {
		if (this._receiveShadows === value) return;
		this._receiveShadows = value;

		if (this._model) {
			const meshInstances = this._model.meshInstances;

			for (let i = 0, len = meshInstances.length; i < len; i++) {
				meshInstances[i].receiveShadow = value;
			}
		}
	}

	get receiveShadows() {
		return this._receiveShadows;
	}

	set castShadowsLightmap(value) {
		this._castShadowsLightmap = value;
	}

	get castShadowsLightmap() {
		return this._castShadowsLightmap;
	}

	set lightmapSizeMultiplier(value) {
		this._lightmapSizeMultiplier = value;
	}

	get lightmapSizeMultiplier() {
		return this._lightmapSizeMultiplier;
	}

	set isStatic(value) {
		if (this._isStatic === value) return;
		this._isStatic = value;

		if (this._model) {
			const rcv = this._model.meshInstances;

			for (let i = 0; i < rcv.length; i++) {
				const m = rcv[i];
				m.isStatic = value;
			}
		}
	}

	get isStatic() {
		return this._isStatic;
	}

	set layers(value) {
		const layers = this.system.app.scene.layers;

		if (this.meshInstances) {
			for (let i = 0; i < this._layers.length; i++) {
				const layer = layers.getLayerById(this._layers[i]);
				if (!layer) continue;
				layer.removeMeshInstances(this.meshInstances);
			}
		}

		this._layers.length = 0;

		for (let i = 0; i < value.length; i++) {
			this._layers[i] = value[i];
		}

		if (!this.enabled || !this.entity.enabled || !this.meshInstances) return;

		for (let i = 0; i < this._layers.length; i++) {
			const layer = layers.getLayerById(this._layers[i]);
			if (!layer) continue;
			layer.addMeshInstances(this.meshInstances);
		}
	}

	get layers() {
		return this._layers;
	}

	set batchGroupId(value) {
		if (this._batchGroupId === value) return;
		const batcher = this.system.app.batcher;

		if (this.entity.enabled && this._batchGroupId >= 0) {
			batcher.remove(BatchGroup.MODEL, this.batchGroupId, this.entity);
		}

		if (this.entity.enabled && value >= 0) {
			batcher.insert(BatchGroup.MODEL, value, this.entity);
		}

		if (value < 0 && this._batchGroupId >= 0 && this.enabled && this.entity.enabled) {
			this.addModelToLayers();
		}

		this._batchGroupId = value;
	}

	get batchGroupId() {
		return this._batchGroupId;
	}

	set materialAsset(value) {
		let _id = value;

		if (value instanceof Asset) {
			_id = value.id;
		}

		const assets = this.system.app.assets;

		if (_id !== this._materialAsset) {
			if (this._materialAsset) {
				assets.off('add:' + this._materialAsset, this._onMaterialAssetAdd, this);

				const _prev = assets.get(this._materialAsset);

				if (_prev) {
					this._unbindMaterialAsset(_prev);
				}
			}

			this._materialAsset = _id;

			if (this._materialAsset) {
				const asset = assets.get(this._materialAsset);

				if (!asset) {
					this._setMaterial(this.system.defaultMaterial);

					assets.on('add:' + this._materialAsset, this._onMaterialAssetAdd, this);
				} else {
					this._bindMaterialAsset(asset);
				}
			} else {
				this._setMaterial(this.system.defaultMaterial);
			}
		}
	}

	get materialAsset() {
		return this._materialAsset;
	}

	set material(value) {
		if (this._material === value) return;
		this.materialAsset = null;

		this._setMaterial(value);
	}

	get material() {
		return this._material;
	}

	set mapping(value) {
		if (this._type !== 'asset') return;

		this._unsetMaterialEvents();

		if (!value) value = {};
		this._mapping = value;
		if (!this._model) return;
		const meshInstances = this._model.meshInstances;
		const modelAsset = this.asset ? this.system.app.assets.get(this.asset) : null;
		const assetMapping = modelAsset ? modelAsset.data.mapping : null;
		let asset = null;

		for (let i = 0, len = meshInstances.length; i < len; i++) {
			if (value[i] !== undefined) {
				if (value[i]) {
					asset = this.system.app.assets.get(value[i]);

					this._loadAndSetMeshInstanceMaterial(asset, meshInstances[i], i);
				} else {
					meshInstances[i].material = this.system.defaultMaterial;
				}
			} else if (assetMapping) {
				if (assetMapping[i] && (assetMapping[i].material || assetMapping[i].path)) {
					if (assetMapping[i].material !== undefined) {
						asset = this.system.app.assets.get(assetMapping[i].material);
					} else if (assetMapping[i].path !== undefined) {
						const url = this._getMaterialAssetUrl(assetMapping[i].path);

						if (url) {
							asset = this.system.app.assets.getByUrl(url);
						}
					}

					this._loadAndSetMeshInstanceMaterial(asset, meshInstances[i], i);
				} else {
					meshInstances[i].material = this.system.defaultMaterial;
				}
			}
		}
	}

	get mapping() {
		return this._mapping;
	}

	addModelToLayers() {
		const layers = this.system.app.scene.layers;

		for (let i = 0; i < this._layers.length; i++) {
			const layer = layers.getLayerById(this._layers[i]);

			if (layer) {
				layer.addMeshInstances(this.meshInstances);
			}
		}
	}

	removeModelFromLayers() {
		const layers = this.system.app.scene.layers;

		for (let i = 0; i < this._layers.length; i++) {
			const layer = layers.getLayerById(this._layers[i]);
			if (!layer) continue;
			layer.removeMeshInstances(this.meshInstances);
		}
	}

	onRemoveChild() {
		if (this._model) this.removeModelFromLayers();
	}

	onInsertChild() {
		if (this._model && this.enabled && this.entity.enabled) this.addModelToLayers();
	}

	onRemove() {
		this.asset = null;
		this.model = null;
		this.materialAsset = null;

		this._unsetMaterialEvents();

		this.entity.off('remove', this.onRemoveChild, this);
		this.entity.off('insert', this.onInsertChild, this);
	}

	onLayersChanged(oldComp, newComp) {
		this.addModelToLayers();
		oldComp.off("add", this.onLayerAdded, this);
		oldComp.off("remove", this.onLayerRemoved, this);
		newComp.on("add", this.onLayerAdded, this);
		newComp.on("remove", this.onLayerRemoved, this);
	}

	onLayerAdded(layer) {
		const index = this.layers.indexOf(layer.id);
		if (index < 0) return;
		layer.addMeshInstances(this.meshInstances);
	}

	onLayerRemoved(layer) {
		const index = this.layers.indexOf(layer.id);
		if (index < 0) return;
		layer.removeMeshInstances(this.meshInstances);
	}

	_setMaterialEvent(index, event, id, handler) {
		const evt = event + ':' + id;
		this.system.app.assets.on(evt, handler, this);
		if (!this._materialEvents) this._materialEvents = [];
		if (!this._materialEvents[index]) this._materialEvents[index] = {};
		this._materialEvents[index][evt] = {
			id: id,
			handler: handler
		};
	}

	_unsetMaterialEvents() {
		const assets = this.system.app.assets;
		const events = this._materialEvents;
		if (!events) return;

		for (let i = 0, len = events.length; i < len; i++) {
			if (!events[i]) continue;
			const evt = events[i];

			for (const key in evt) {
				assets.off(key, evt[key].handler, this);
			}
		}

		this._materialEvents = null;
	}

	_getAssetByIdOrPath(idOrPath) {
		let asset = null;
		const isPath = isNaN(parseInt(idOrPath, 10));

		if (!isPath) {
			asset = this.system.app.assets.get(idOrPath);
		} else if (this.asset) {
			const url = this._getMaterialAssetUrl(idOrPath);

			if (url) asset = this.system.app.assets.getByUrl(url);
		}

		return asset;
	}

	_getMaterialAssetUrl(path) {
		if (!this.asset) return null;
		const modelAsset = this.system.app.assets.get(this.asset);
		return modelAsset ? modelAsset.getAbsoluteUrl(path) : null;
	}

	_loadAndSetMeshInstanceMaterial(materialAsset, meshInstance, index) {
		const assets = this.system.app.assets;
		if (!materialAsset) return;

		if (materialAsset.resource) {
			meshInstance.material = materialAsset.resource;

			this._setMaterialEvent(index, 'remove', materialAsset.id, function () {
				meshInstance.material = this.system.defaultMaterial;
			});
		} else {
			this._setMaterialEvent(index, 'load', materialAsset.id, function (asset) {
				meshInstance.material = asset.resource;

				this._setMaterialEvent(index, 'remove', materialAsset.id, function () {
					meshInstance.material = this.system.defaultMaterial;
				});
			});

			if (this.enabled && this.entity.enabled) assets.load(materialAsset);
		}
	}

	onEnable() {
		const app = this.system.app;
		const scene = app.scene;
		scene.on("set:layers", this.onLayersChanged, this);

		if (scene.layers) {
			scene.layers.on("add", this.onLayerAdded, this);
			scene.layers.on("remove", this.onLayerRemoved, this);
		}

		const isAsset = this._type === 'asset';
		let asset;

		if (this._model) {
			this.addModelToLayers();
		} else if (isAsset && this._asset) {
			asset = app.assets.get(this._asset);

			if (asset && asset.resource !== this._model) {
				this._bindModelAsset(asset);
			}
		}

		if (this._materialAsset) {
			asset = app.assets.get(this._materialAsset);

			if (asset && asset.resource !== this._material) {
				this._bindMaterialAsset(asset);
			}
		}

		if (isAsset) {
			if (this._mapping) {
				for (const index in this._mapping) {
					if (this._mapping[index]) {
						asset = this._getAssetByIdOrPath(this._mapping[index]);

						if (asset && !asset.resource) {
							app.assets.load(asset);
						}
					}
				}
			}
		}

		if (this._batchGroupId >= 0) {
			app.batcher.insert(BatchGroup.MODEL, this.batchGroupId, this.entity);
		}
	}

	onDisable() {
		const app = this.system.app;
		const scene = app.scene;
		scene.off("set:layers", this.onLayersChanged, this);

		if (scene.layers) {
			scene.layers.off("add", this.onLayerAdded, this);
			scene.layers.off("remove", this.onLayerRemoved, this);
		}

		if (this._batchGroupId >= 0) {
			app.batcher.remove(BatchGroup.MODEL, this.batchGroupId, this.entity);
		}

		if (this._model) {
			this.removeModelFromLayers();
		}
	}

	hide() {
		if (this._model) {
			const instances = this._model.meshInstances;

			for (let i = 0, l = instances.length; i < l; i++) {
				instances[i].visible = false;
			}
		}
	}

	show() {
		if (this._model) {
			const instances = this._model.meshInstances;

			for (let i = 0, l = instances.length; i < l; i++) {
				instances[i].visible = true;
			}
		}
	}

	_bindMaterialAsset(asset) {
		asset.on('load', this._onMaterialAssetLoad, this);
		asset.on('unload', this._onMaterialAssetUnload, this);
		asset.on('remove', this._onMaterialAssetRemove, this);
		asset.on('change', this._onMaterialAssetChange, this);

		if (asset.resource) {
			this._onMaterialAssetLoad(asset);
		} else {
			if (!this.enabled || !this.entity.enabled) return;
			this.system.app.assets.load(asset);
		}
	}

	_unbindMaterialAsset(asset) {
		asset.off('load', this._onMaterialAssetLoad, this);
		asset.off('unload', this._onMaterialAssetUnload, this);
		asset.off('remove', this._onMaterialAssetRemove, this);
		asset.off('change', this._onMaterialAssetChange, this);
	}

	_onMaterialAssetAdd(asset) {
		this.system.app.assets.off('add:' + asset.id, this._onMaterialAssetAdd, this);

		if (this._materialAsset === asset.id) {
			this._bindMaterialAsset(asset);
		}
	}

	_onMaterialAssetLoad(asset) {
		this._setMaterial(asset.resource);
	}

	_onMaterialAssetUnload(asset) {
		this._setMaterial(this.system.defaultMaterial);
	}

	_onMaterialAssetRemove(asset) {
		this._onMaterialAssetUnload(asset);
	}

	_onMaterialAssetChange(asset) {}

	_bindModelAsset(asset) {
		this._unbindModelAsset(asset);

		asset.on('load', this._onModelAssetLoad, this);
		asset.on('unload', this._onModelAssetUnload, this);
		asset.on('change', this._onModelAssetChange, this);
		asset.on('remove', this._onModelAssetRemove, this);

		if (asset.resource) {
			this._onModelAssetLoad(asset);
		} else {
			if (!this.enabled || !this.entity.enabled) return;
			this.system.app.assets.load(asset);
		}
	}

	_unbindModelAsset(asset) {
		asset.off('load', this._onModelAssetLoad, this);
		asset.off('unload', this._onModelAssetUnload, this);
		asset.off('change', this._onModelAssetChange, this);
		asset.off('remove', this._onModelAssetRemove, this);
	}

	_onModelAssetAdded(asset) {
		this.system.app.assets.off('add:' + asset.id, this._onModelAssetAdded, this);

		if (asset.id === this._asset) {
			this._bindModelAsset(asset);
		}
	}

	_onModelAssetLoad(asset) {
		this.model = asset.resource.clone();
		this._clonedModel = true;
	}

	_onModelAssetUnload(asset) {
		this.model = null;
	}

	_onModelAssetChange(asset, attr, _new, _old) {
		if (attr === 'data') {
			this.mapping = this._mapping;
		}
	}

	_onModelAssetRemove(asset) {
		this.model = null;
	}

	_setMaterial(material) {
		if (this._material === material) return;
		this._material = material;
		const model = this._model;

		if (model && this._type !== 'asset') {
			const meshInstances = model.meshInstances;

			for (let i = 0, len = meshInstances.length; i < len; i++) {
				meshInstances[i].material = material;
			}
		}
	}

}

class ModelComponentData {
	constructor() {
		this.enabled = true;
	}

}

const _schema$a = ['enabled'];

class ModelComponentSystem extends ComponentSystem {
	constructor(app) {
		super(app);
		this.id = 'model';
		this.ComponentType = ModelComponent;
		this.DataType = ModelComponentData;
		this.schema = _schema$a;
		this.defaultMaterial = getDefaultMaterial(app.graphicsDevice);
		this.on('beforeremove', this.onRemove, this);
	}

	initializeComponentData(component, _data, properties) {
		properties = ['material', 'materialAsset', 'asset', 'castShadows', 'receiveShadows', 'castShadowsLightmap', 'lightmapped', 'lightmapSizeMultiplier', 'type', 'mapping', 'layers', 'isStatic', 'batchGroupId'];

		if (_data.batchGroupId === null || _data.batchGroupId === undefined) {
			_data.batchGroupId = -1;
		}

		if (_data.layers && _data.layers.length) {
			_data.layers = _data.layers.slice(0);
		}

		for (let i = 0; i < properties.length; i++) {
			if (_data.hasOwnProperty(properties[i])) {
				component[properties[i]] = _data[properties[i]];
			}
		}

		if (_data.aabbCenter && _data.aabbHalfExtents) {
			component.customAabb = new BoundingBox(new Vec3(_data.aabbCenter), new Vec3(_data.aabbHalfExtents));
		}

		super.initializeComponentData(component, _data, ['enabled']);
	}

	cloneComponent(entity, clone) {
		const data = {
			type: entity.model.type,
			asset: entity.model.asset,
			castShadows: entity.model.castShadows,
			receiveShadows: entity.model.receiveShadows,
			castShadowsLightmap: entity.model.castShadowsLightmap,
			lightmapped: entity.model.lightmapped,
			lightmapSizeMultiplier: entity.model.lightmapSizeMultiplier,
			isStatic: entity.model.isStatic,
			enabled: entity.model.enabled,
			layers: entity.model.layers,
			batchGroupId: entity.model.batchGroupId,
			mapping: extend({}, entity.model.mapping)
		};
		let materialAsset = entity.model.materialAsset;

		if (!(materialAsset instanceof Asset) && materialAsset != null) {
			materialAsset = this.app.assets.get(materialAsset);
		}

		const material = entity.model.material;

		if (!material || material === this.defaultMaterial || !materialAsset || material === materialAsset.resource) {
			data.materialAsset = materialAsset;
		}

		const component = this.addComponent(clone, data);

		if (entity.model.model && entity.model.type === 'asset' && !entity.model.asset) {
			component.model = entity.model.model.clone();
			component._clonedModel = true;
		}

		if (!data.materialAsset) component.material = material;

		if (entity.model.model) {
			const meshInstances = entity.model.model.meshInstances;
			const meshInstancesClone = component.model.meshInstances;

			for (let i = 0; i < meshInstances.length; i++) {
				meshInstancesClone[i].mask = meshInstances[i].mask;
				meshInstancesClone[i].material = meshInstances[i].material;
				meshInstancesClone[i].layer = meshInstances[i].layer;
				meshInstancesClone[i].receiveShadow = meshInstances[i].receiveShadow;
			}
		}

		if (entity.model.customAabb) {
			component.customAabb = entity.model.customAabb.clone();
		}

		return component;
	}

	onRemove(entity, component) {
		component.onRemove();
	}

}

Component._buildAccessors(ModelComponent.prototype, _schema$a);

class RenderComponent extends Component {
	constructor(system, entity) {
		super(system, entity);
		this._type = 'asset';
		this._castShadows = true;
		this._receiveShadows = true;
		this._castShadowsLightmap = true;
		this._lightmapped = false;
		this._lightmapSizeMultiplier = 1;
		this._isStatic = false;
		this._batchGroupId = -1;
		this._layers = [LAYERID_WORLD];
		this._renderStyle = RENDERSTYLE_SOLID;
		this._meshInstances = [];
		this._customAabb = null;
		this._area = null;
		this._assetReference = [];
		this._materialReferences = [];
		this._material = void 0;
		this._rootBone = void 0;
		this._rootBone = new EntityReference(this, 'rootBone');

		this._rootBone.on('set:entity', this._onSetRootBone, this);

		this._assetReference = new AssetReference('asset', this, system.app.assets, {
			add: this._onRenderAssetAdded,
			load: this._onRenderAssetLoad,
			remove: this._onRenderAssetRemove,
			unload: this._onRenderAssetUnload
		}, this);
		this._material = system.defaultMaterial;
		entity.on('remove', this.onRemoveChild, this);
		entity.on('removehierarchy', this.onRemoveChild, this);
		entity.on('insert', this.onInsertChild, this);
		entity.on('inserthierarchy', this.onInsertChild, this);
	}

	set renderStyle(renderStyle) {
		if (this._renderStyle !== renderStyle) {
			this._renderStyle = renderStyle;

			MeshInstance._prepareRenderStyleForArray(this._meshInstances, renderStyle);
		}
	}

	get renderStyle() {
		return this._renderStyle;
	}

	set customAabb(value) {
		this._customAabb = value;
		const mi = this._meshInstances;

		if (mi) {
			for (let i = 0; i < mi.length; i++) {
				mi[i].setCustomAabb(this._customAabb);
			}
		}
	}

	get customAabb() {
		return this._customAabb;
	}

	set type(value) {
		if (this._type !== value) {
			this._area = null;
			this._type = value;
			this.destroyMeshInstances();

			if (value !== 'asset') {
				let material = this._material;

				if (!material || material === this.system.defaultMaterial) {
					material = this._materialReferences[0] && this._materialReferences[0].asset && this._materialReferences[0].asset.resource;
				}

				const primData = getShapePrimitive(this.system.app.graphicsDevice, value);
				this._area = primData.area;
				this.meshInstances = [new MeshInstance(primData.mesh, material || this.system.defaultMaterial, this.entity)];
			}
		}
	}

	get type() {
		return this._type;
	}

	set meshInstances(value) {
		this.destroyMeshInstances();
		this._meshInstances = value;

		if (this._meshInstances) {
			const mi = this._meshInstances;

			for (let i = 0; i < mi.length; i++) {
				if (!mi[i].node) {
					mi[i].node = this.entity;
				}

				mi[i].castShadow = this._castShadows;
				mi[i].receiveShadow = this._receiveShadows;
				mi[i].isStatic = this._isStatic;
				mi[i].renderStyle = this._renderStyle;
				mi[i].setLightmapped(this._lightmapped);
				mi[i].setCustomAabb(this._customAabb);
			}

			if (this.enabled && this.entity.enabled) {
				this.addToLayers();
			}
		}
	}

	get meshInstances() {
		return this._meshInstances;
	}

	set lightmapped(value) {
		if (value !== this._lightmapped) {
			this._lightmapped = value;
			const mi = this._meshInstances;

			if (mi) {
				for (let i = 0; i < mi.length; i++) {
					mi[i].setLightmapped(value);
				}
			}
		}
	}

	get lightmapped() {
		return this._lightmapped;
	}

	set castShadows(value) {
		if (this._castShadows !== value) {
			const mi = this._meshInstances;

			if (mi) {
				const layers = this.layers;
				const scene = this.system.app.scene;

				if (this._castShadows && !value) {
					for (let i = 0; i < layers.length; i++) {
						const layer = scene.layers.getLayerById(this.layers[i]);

						if (layer) {
							layer.removeShadowCasters(mi);
						}
					}
				}

				for (let i = 0; i < mi.length; i++) {
					mi[i].castShadow = value;
				}

				if (!this._castShadows && value) {
					for (let i = 0; i < layers.length; i++) {
						const layer = scene.layers.getLayerById(layers[i]);

						if (layer) {
							layer.addShadowCasters(mi);
						}
					}
				}
			}

			this._castShadows = value;
		}
	}

	get castShadows() {
		return this._castShadows;
	}

	set receiveShadows(value) {
		if (this._receiveShadows !== value) {
			this._receiveShadows = value;
			const mi = this._meshInstances;

			if (mi) {
				for (let i = 0; i < mi.length; i++) {
					mi[i].receiveShadow = value;
				}
			}
		}
	}

	get receiveShadows() {
		return this._receiveShadows;
	}

	set castShadowsLightmap(value) {
		this._castShadowsLightmap = value;
	}

	get castShadowsLightmap() {
		return this._castShadowsLightmap;
	}

	set lightmapSizeMultiplier(value) {
		this._lightmapSizeMultiplier = value;
	}

	get lightmapSizeMultiplier() {
		return this._lightmapSizeMultiplier;
	}

	set isStatic(value) {
		if (this._isStatic !== value) {
			this._isStatic = value;
			const mi = this._meshInstances;

			if (mi) {
				for (let i = 0; i < mi.length; i++) {
					mi[i].isStatic = value;
				}
			}
		}
	}

	get isStatic() {
		return this._isStatic;
	}

	set layers(value) {
		const layers = this.system.app.scene.layers;
		let layer;

		if (this._meshInstances) {
			for (let i = 0; i < this._layers.length; i++) {
				layer = layers.getLayerById(this._layers[i]);

				if (layer) {
					layer.removeMeshInstances(this._meshInstances);
				}
			}
		}

		this._layers.length = 0;

		for (let i = 0; i < value.length; i++) {
			this._layers[i] = value[i];
		}

		if (!this.enabled || !this.entity.enabled || !this._meshInstances) return;

		for (let i = 0; i < this._layers.length; i++) {
			layer = layers.getLayerById(this._layers[i]);

			if (layer) {
				layer.addMeshInstances(this._meshInstances);
			}
		}
	}

	get layers() {
		return this._layers;
	}

	set batchGroupId(value) {
		if (this._batchGroupId !== value) {
			const batcher = this.system.app.batcher;

			if (this.entity.enabled && this._batchGroupId >= 0) {
				batcher.remove(BatchGroup.RENDER, this.batchGroupId, this.entity);
			}

			if (this.entity.enabled && value >= 0) {
				batcher.insert(BatchGroup.RENDER, value, this.entity);
			}

			if (value < 0 && this._batchGroupId >= 0 && this.enabled && this.entity.enabled) {
				this.addToLayers();
			}

			this._batchGroupId = value;
		}
	}

	get batchGroupId() {
		return this._batchGroupId;
	}

	set material(value) {
		if (this._material !== value) {
			this._material = value;

			if (this._meshInstances && this._type !== 'asset') {
				for (let i = 0; i < this._meshInstances.length; i++) {
					this._meshInstances[i].material = value;
				}
			}
		}
	}

	get material() {
		return this._material;
	}

	set materialAssets(value = []) {
		if (this._materialReferences.length > value.length) {
			for (let i = value.length; i < this._materialReferences.length; i++) {
				this._materialReferences[i].id = null;
			}

			this._materialReferences.length = value.length;
		}

		for (let i = 0; i < value.length; i++) {
			if (!this._materialReferences[i]) {
				this._materialReferences.push(new AssetReference(i, this, this.system.app.assets, {
					add: this._onMaterialAdded,
					load: this._onMaterialLoad,
					remove: this._onMaterialRemove,
					unload: this._onMaterialUnload
				}, this));
			}

			if (value[i]) {
				const id = value[i] instanceof Asset ? value[i].id : value[i];

				if (this._materialReferences[i].id !== id) {
					this._materialReferences[i].id = id;
				}

				if (this._materialReferences[i].asset) {
					this._onMaterialAdded(i, this, this._materialReferences[i].asset);
				}
			} else {
				this._materialReferences[i].id = null;

				if (this._meshInstances[i]) {
					this._meshInstances[i].material = this.system.defaultMaterial;
				}
			}
		}
	}

	get materialAssets() {
		return this._materialReferences.map(function (ref) {
			return ref.id;
		});
	}

	set asset(value) {
		const id = value instanceof Asset ? value.id : value;
		if (this._assetReference.id === id) return;

		if (this._assetReference.asset && this._assetReference.asset.resource) {
			this._onRenderAssetRemove();
		}

		this._assetReference.id = id;

		if (this._assetReference.asset) {
			this._onRenderAssetAdded();
		}
	}

	get asset() {
		return this._assetReference.id;
	}

	assignAsset(asset) {
		const id = asset instanceof Asset ? asset.id : asset;
		this._assetReference.id = id;
	}

	_onSetRootBone(entity) {
		if (entity) {
			this._onRootBoneChanged();
		}
	}

	_onRootBoneChanged() {
		this._clearSkinInstances();

		if (this.enabled && this.entity.enabled) {
			this._cloneSkinInstances();
		}
	}

	destroyMeshInstances() {
		const meshInstances = this._meshInstances;

		if (meshInstances) {
			this.removeFromLayers();

			this._clearSkinInstances();

			for (let i = 0; i < meshInstances.length; i++) {
				meshInstances[i].destroy();
			}

			this._meshInstances.length = 0;
		}
	}

	addToLayers() {
		const layers = this.system.app.scene.layers;

		for (let i = 0; i < this._layers.length; i++) {
			const layer = layers.getLayerById(this._layers[i]);

			if (layer) {
				layer.addMeshInstances(this._meshInstances);
			}
		}
	}

	removeFromLayers() {
		if (this._meshInstances && this._meshInstances.length) {
			const layers = this.system.app.scene.layers;

			for (let i = 0; i < this._layers.length; i++) {
				const layer = layers.getLayerById(this._layers[i]);

				if (layer) {
					layer.removeMeshInstances(this._meshInstances);
				}
			}
		}
	}

	onRemoveChild() {
		this.removeFromLayers();
	}

	onInsertChild() {
		if (this._meshInstances && this.enabled && this.entity.enabled) {
			this.addToLayers();
		}
	}

	onRemove() {
		this.destroyMeshInstances();
		this.asset = null;
		this.materialAsset = null;
		this.entity.off('remove', this.onRemoveChild, this);
		this.entity.off('insert', this.onInsertChild, this);
	}

	onLayersChanged(oldComp, newComp) {
		this.addToLayers();
		oldComp.off("add", this.onLayerAdded, this);
		oldComp.off("remove", this.onLayerRemoved, this);
		newComp.on("add", this.onLayerAdded, this);
		newComp.on("remove", this.onLayerRemoved, this);
	}

	onLayerAdded(layer) {
		const index = this.layers.indexOf(layer.id);
		if (index < 0) return;
		layer.addMeshInstances(this._meshInstances);
	}

	onLayerRemoved(layer) {
		const index = this.layers.indexOf(layer.id);
		if (index < 0) return;
		layer.removeMeshInstances(this._meshInstances);
	}

	onEnable() {
		const app = this.system.app;
		const scene = app.scene;

		this._rootBone.onParentComponentEnable();

		this._cloneSkinInstances();

		scene.on("set:layers", this.onLayersChanged, this);

		if (scene.layers) {
			scene.layers.on("add", this.onLayerAdded, this);
			scene.layers.on("remove", this.onLayerRemoved, this);
		}

		const isAsset = this._type === 'asset';

		if (this._meshInstances && this._meshInstances.length) {
			this.addToLayers();
		} else if (isAsset && this.asset) {
			this._onRenderAssetAdded();
		}

		for (let i = 0; i < this._materialReferences.length; i++) {
			if (this._materialReferences[i].asset) {
				this.system.app.assets.load(this._materialReferences[i].asset);
			}
		}

		if (this._batchGroupId >= 0) {
			app.batcher.insert(BatchGroup.RENDER, this.batchGroupId, this.entity);
		}
	}

	onDisable() {
		const app = this.system.app;
		const scene = app.scene;
		scene.off("set:layers", this.onLayersChanged, this);

		if (scene.layers) {
			scene.layers.off("add", this.onLayerAdded, this);
			scene.layers.off("remove", this.onLayerRemoved, this);
		}

		if (this._batchGroupId >= 0) {
			app.batcher.remove(BatchGroup.RENDER, this.batchGroupId, this.entity);
		}

		this.removeFromLayers();
	}

	hide() {
		if (this._meshInstances) {
			for (let i = 0; i < this._meshInstances.length; i++) {
				this._meshInstances[i].visible = false;
			}
		}
	}

	show() {
		if (this._meshInstances) {
			for (let i = 0; i < this._meshInstances.length; i++) {
				this._meshInstances[i].visible = true;
			}
		}
	}

	_onRenderAssetAdded() {
		if (!this._assetReference.asset) return;

		if (this._assetReference.asset.resource) {
			this._onRenderAssetLoad();
		} else if (this.enabled && this.entity.enabled) {
			this.system.app.assets.load(this._assetReference.asset);
		}
	}

	_onRenderAssetLoad() {
		this.destroyMeshInstances();

		if (this._assetReference.asset) {
			const render = this._assetReference.asset.resource;
			render.off('set:meshes', this._onSetMeshes, this);
			render.on('set:meshes', this._onSetMeshes, this);

			if (render.meshes) {
				this._onSetMeshes(render.meshes);
			}
		}
	}

	_onSetMeshes(meshes) {
		this._cloneMeshes(meshes);
	}

	_clearSkinInstances() {
		for (let i = 0; i < this._meshInstances.length; i++) {
			const meshInstance = this._meshInstances[i];
			SkinInstanceCache.removeCachedSkinInstance(meshInstance.skinInstance);
			meshInstance.skinInstance = null;
		}
	}

	_cloneSkinInstances() {
		if (this._meshInstances.length && this._rootBone.entity instanceof GraphNode) {
			for (let i = 0; i < this._meshInstances.length; i++) {
				const meshInstance = this._meshInstances[i];
				const mesh = meshInstance.mesh;

				if (mesh.skin && !mesh.skinInstance) {
					meshInstance.skinInstance = SkinInstanceCache.createCachedSkinInstance(mesh.skin, this._rootBone.entity, this.entity);
				}
			}
		}
	}

	_cloneMeshes(meshes) {
		if (meshes && meshes.length) {
			const meshInstances = [];

			for (let i = 0; i < meshes.length; i++) {
				const mesh = meshes[i];
				const material = this._materialReferences[i] && this._materialReferences[i].asset && this._materialReferences[i].asset.resource;
				const meshInst = new MeshInstance(mesh, material || this.system.defaultMaterial, this.entity);
				meshInstances.push(meshInst);

				if (mesh.morph) {
					meshInst.morphInstance = new MorphInstance(mesh.morph);
				}
			}

			this.meshInstances = meshInstances;

			this._cloneSkinInstances();
		}
	}

	_onRenderAssetUnload() {
		if (this._type === 'asset') {
			this.destroyMeshInstances();
		}
	}

	_onRenderAssetRemove() {
		if (this._assetReference.asset && this._assetReference.asset.resource) {
			this._assetReference.asset.resource.off('set:meshes', this._onSetMeshes, this);
		}

		this._onRenderAssetUnload();
	}

	_onMaterialAdded(index, component, asset) {
		if (asset.resource) {
			this._onMaterialLoad(index, component, asset);
		} else {
			if (this.enabled && this.entity.enabled) {
				this.system.app.assets.load(asset);
			}
		}
	}

	_updateMainMaterial(index, material) {
		if (index === 0) {
			this.material = material;
		}
	}

	_onMaterialLoad(index, component, asset) {
		if (this._meshInstances[index]) {
			this._meshInstances[index].material = asset.resource;
		}

		this._updateMainMaterial(index, asset.resource);
	}

	_onMaterialRemove(index, component, asset) {
		if (this._meshInstances[index]) {
			this._meshInstances[index].material = this.system.defaultMaterial;
		}

		this._updateMainMaterial(index, this.system.defaultMaterial);
	}

	_onMaterialUnload(index, component, asset) {
		if (this._meshInstances[index]) {
			this._meshInstances[index].material = this.system.defaultMaterial;
		}

		this._updateMainMaterial(index, this.system.defaultMaterial);
	}

	resolveDuplicatedEntityReferenceProperties(oldRender, duplicatedIdsMap) {
		if (oldRender.rootBone && duplicatedIdsMap[oldRender.rootBone]) {
			this.rootBone = duplicatedIdsMap[oldRender.rootBone];
		}

		this._clearSkinInstances();
	}

}

class RenderComponentData {
	constructor() {
		this.enabled = true;
		this.rootBone = null;
	}

}

const _schema$9 = [{
	name: 'rootBone',
	type: 'entity'
}, 'enabled'];
const _properties = ['material', 'meshInstances', 'asset', 'materialAssets', 'castShadows', 'receiveShadows', 'castShadowsLightmap', 'lightmapped', 'lightmapSizeMultiplier', 'renderStyle', 'type', 'layers', 'isStatic', 'batchGroupId'];

class RenderComponentSystem extends ComponentSystem {
	constructor(app) {
		super(app);
		this.id = 'render';
		this.ComponentType = RenderComponent;
		this.DataType = RenderComponentData;
		this.schema = _schema$9;
		this.defaultMaterial = getDefaultMaterial(app.graphicsDevice);
		this.on('beforeremove', this.onRemove, this);
	}

	initializeComponentData(component, _data, properties) {
		if (_data.batchGroupId === null || _data.batchGroupId === undefined) {
			_data.batchGroupId = -1;
		}

		if (_data.layers && _data.layers.length) {
			_data.layers = _data.layers.slice(0);
		}

		for (let i = 0; i < _properties.length; i++) {
			if (_data.hasOwnProperty(_properties[i])) {
				component[_properties[i]] = _data[_properties[i]];
			}
		}

		if (_data.aabbCenter && _data.aabbHalfExtents) {
			component.customAabb = new BoundingBox(new Vec3(_data.aabbCenter), new Vec3(_data.aabbHalfExtents));
		}

		super.initializeComponentData(component, _data, _schema$9);
	}

	cloneComponent(entity, clone) {
		const data = {};

		for (let i = 0; i < _properties.length; i++) {
			data[_properties[i]] = entity.render[_properties[i]];
		}

		data.enabled = entity.render.enabled;
		delete data.meshInstances;
		const component = this.addComponent(clone, data);
		const srcMeshInstances = entity.render.meshInstances;
		const meshes = srcMeshInstances.map(mi => mi.mesh);

		component._onSetMeshes(meshes);

		for (let m = 0; m < srcMeshInstances.length; m++) {
			component.meshInstances[m].material = srcMeshInstances[m].material;
		}

		if (entity.render.customAabb) {
			component.customAabb = entity.render.customAabb.clone();
		}

		return component;
	}

	onRemove(entity, component) {
		component.onRemove();
	}

}

Component._buildAccessors(RenderComponent.prototype, _schema$9);

let nonUniformScale;
let uniformScale = 1;
const particleTexChannels$1 = 4;
const rotMat = new Mat4();
const rotMatInv = new Mat4();
const randomPosTformed = new Vec3();
const randomPos = new Vec3();
const rndFactor3Vec = new Vec3();
const particlePosPrev = new Vec3();
const velocityVec = new Vec3();
const localVelocityVec = new Vec3();
const velocityVec2 = new Vec3();
const localVelocityVec2 = new Vec3();
const radialVelocityVec = new Vec3();
const particlePos = new Vec3();
const particleFinalPos = new Vec3();
const moveDirVec = new Vec3();
const tmpVec3$1 = new Vec3();

function frac(f) {
	return f - Math.floor(f);
}

function saturate$1(x) {
	return Math.max(Math.min(x, 1), 0);
}

function glMod(x, y) {
	return x - y * Math.floor(x / y);
}

function encodeFloatRGBA(v) {
	let encX = frac(v);
	let encY = frac(255.0 * v);
	let encZ = frac(65025.0 * v);
	let encW = frac(160581375.0 * v);
	encX -= encY / 255.0;
	encY -= encZ / 255.0;
	encZ -= encW / 255.0;
	encW -= encW / 255.0;
	return [encX, encY, encZ, encW];
}

function encodeFloatRG(v) {
	let encX = frac(v);
	let encY = frac(255.0 * v);
	encX -= encY / 255.0;
	encY -= encY / 255.0;
	return [encX, encY];
}

class ParticleCPUUpdater {
	constructor(emitter) {
		this._emitter = emitter;
	}

	calcSpawnPosition(particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, i) {
		const emitter = this._emitter;
		const rX = Math.random();
		const rY = Math.random();
		const rZ = Math.random();
		const rW = Math.random();

		if (emitter.useCpu) {
			particleTex[i * particleTexChannels$1 + 0 + emitter.numParticlesPot * 2 * particleTexChannels$1] = rX;
			particleTex[i * particleTexChannels$1 + 1 + emitter.numParticlesPot * 2 * particleTexChannels$1] = rY;
			particleTex[i * particleTexChannels$1 + 2 + emitter.numParticlesPot * 2 * particleTexChannels$1] = rZ;
		}

		randomPos.x = rX - 0.5;
		randomPos.y = rY - 0.5;
		randomPos.z = rZ - 0.5;

		if (emitter.emitterShape === EMITTERSHAPE_BOX) {
			const max = Math.max(Math.abs(randomPos.x), Math.max(Math.abs(randomPos.y), Math.abs(randomPos.z)));
			const edgeX = max + (0.5 - max) * extentsInnerRatioUniform[0];
			const edgeY = max + (0.5 - max) * extentsInnerRatioUniform[1];
			const edgeZ = max + (0.5 - max) * extentsInnerRatioUniform[2];
			randomPos.x = edgeX * (max === Math.abs(randomPos.x) ? Math.sign(randomPos.x) : 2 * randomPos.x);
			randomPos.y = edgeY * (max === Math.abs(randomPos.y) ? Math.sign(randomPos.y) : 2 * randomPos.y);
			randomPos.z = edgeZ * (max === Math.abs(randomPos.z) ? Math.sign(randomPos.z) : 2 * randomPos.z);
			if (!emitter.localSpace) randomPosTformed.copy(emitterPos).add(spawnMatrix.transformPoint(randomPos));else randomPosTformed.copy(spawnMatrix.transformPoint(randomPos));
		} else {
			randomPos.normalize();
			const spawnBoundsSphereInnerRatio = emitter.emitterRadius === 0 ? 0 : emitter.emitterRadiusInner / emitter.emitterRadius;
			const r = rW * (1.0 - spawnBoundsSphereInnerRatio) + spawnBoundsSphereInnerRatio;
			if (!emitter.localSpace) randomPosTformed.copy(emitterPos).add(randomPos.mulScalar(r * emitter.emitterRadius));else randomPosTformed.copy(randomPos.mulScalar(r * emitter.emitterRadius));
		}

		const particleRate = math.lerp(emitter.rate, emitter.rate2, rX);
		let startSpawnTime = -particleRate * i;

		if (emitter.pack8) {
			const packX = (randomPosTformed.x - emitter.worldBounds.center.x) / emitter.worldBoundsSize.x + 0.5;
			const packY = (randomPosTformed.y - emitter.worldBounds.center.y) / emitter.worldBoundsSize.y + 0.5;
			const packZ = (randomPosTformed.z - emitter.worldBounds.center.z) / emitter.worldBoundsSize.z + 0.5;
			let packA = math.lerp(emitter.startAngle * math.DEG_TO_RAD, emitter.startAngle2 * math.DEG_TO_RAD, rX);
			packA = packA % (Math.PI * 2) / (Math.PI * 2);
			const rg0 = encodeFloatRG(packX);
			particleTex[i * particleTexChannels$1] = rg0[0];
			particleTex[i * particleTexChannels$1 + 1] = rg0[1];
			const ba0 = encodeFloatRG(packY);
			particleTex[i * particleTexChannels$1 + 2] = ba0[0];
			particleTex[i * particleTexChannels$1 + 3] = ba0[1];
			const rg1 = encodeFloatRG(packZ);
			particleTex[i * particleTexChannels$1 + 0 + emitter.numParticlesPot * particleTexChannels$1] = rg1[0];
			particleTex[i * particleTexChannels$1 + 1 + emitter.numParticlesPot * particleTexChannels$1] = rg1[1];
			const ba1 = encodeFloatRG(packA);
			particleTex[i * particleTexChannels$1 + 2 + emitter.numParticlesPot * particleTexChannels$1] = ba1[0];
			particleTex[i * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1] = ba1[1];
			const a2 = 1.0;
			particleTex[i * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1 * 2] = a2;
			const maxNegLife = Math.max(emitter.lifetime, (emitter.numParticles - 1.0) * Math.max(emitter.rate, emitter.rate2));
			const maxPosLife = emitter.lifetime + 1.0;
			startSpawnTime = (startSpawnTime + maxNegLife) / (maxNegLife + maxPosLife);
			const rgba3 = encodeFloatRGBA(startSpawnTime);
			particleTex[i * particleTexChannels$1 + 0 + emitter.numParticlesPot * particleTexChannels$1 * 3] = rgba3[0];
			particleTex[i * particleTexChannels$1 + 1 + emitter.numParticlesPot * particleTexChannels$1 * 3] = rgba3[1];
			particleTex[i * particleTexChannels$1 + 2 + emitter.numParticlesPot * particleTexChannels$1 * 3] = rgba3[2];
			particleTex[i * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1 * 3] = rgba3[3];
		} else {
			particleTex[i * particleTexChannels$1] = randomPosTformed.x;
			particleTex[i * particleTexChannels$1 + 1] = randomPosTformed.y;
			particleTex[i * particleTexChannels$1 + 2] = randomPosTformed.z;
			particleTex[i * particleTexChannels$1 + 3] = math.lerp(emitter.startAngle * math.DEG_TO_RAD, emitter.startAngle2 * math.DEG_TO_RAD, rX);
			particleTex[i * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1] = startSpawnTime;
		}
	}

	update(data, vbToSort, particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, delta, isOnStop) {
		let a, b, c;
		const emitter = this._emitter;

		if (emitter.meshInstance.node) {
			const fullMat = emitter.meshInstance.node.worldTransform;

			for (let j = 0; j < 12; j++) {
				rotMat.data[j] = fullMat.data[j];
			}

			rotMatInv.copy(rotMat);
			rotMatInv.invert();
			nonUniformScale = emitter.meshInstance.node.localScale;
			uniformScale = Math.max(Math.max(nonUniformScale.x, nonUniformScale.y), nonUniformScale.z);
		}

		emitterPos = emitter.meshInstance.node === null || emitter.localSpace ? Vec3.ZERO : emitter.meshInstance.node.getPosition();
		const posCam = emitter.camera ? emitter.camera._node.getPosition() : Vec3.ZERO;
		const vertSize = !emitter.useMesh ? 15 : 17;
		let cf, cc;
		let rotSpeed, rotSpeed2, scale2, alpha, alpha2, radialSpeed, radialSpeed2;
		const precision1 = emitter.precision - 1;

		for (let i = 0; i < emitter.numParticles; i++) {
			const id = Math.floor(emitter.vbCPU[i * emitter.numParticleVerts * (emitter.useMesh ? 6 : 4) + 3]);
			const rndFactor = particleTex[id * particleTexChannels$1 + 0 + emitter.numParticlesPot * 2 * particleTexChannels$1];
			rndFactor3Vec.x = rndFactor;
			rndFactor3Vec.y = particleTex[id * particleTexChannels$1 + 1 + emitter.numParticlesPot * 2 * particleTexChannels$1];
			rndFactor3Vec.z = particleTex[id * particleTexChannels$1 + 2 + emitter.numParticlesPot * 2 * particleTexChannels$1];
			const particleRate = emitter.rate + (emitter.rate2 - emitter.rate) * rndFactor;
			const particleLifetime = emitter.lifetime;
			let life = particleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1] + delta;
			const nlife = saturate$1(life / particleLifetime);
			let scale = 0;
			let alphaDiv = 0;
			const angle = 0;
			const respawn = life - delta <= 0.0 || life >= particleLifetime;

			if (respawn) {
				this.calcSpawnPosition(particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, id);
			}

			let particleEnabled = life > 0.0 && life < particleLifetime;

			if (particleEnabled) {
				c = nlife * precision1;
				cf = Math.floor(c);
				cc = Math.ceil(c);
				c %= 1;
				a = emitter.qRotSpeed[cf];
				b = emitter.qRotSpeed[cc];
				rotSpeed = a + (b - a) * c;
				a = emitter.qRotSpeed2[cf];
				b = emitter.qRotSpeed2[cc];
				rotSpeed2 = a + (b - a) * c;
				a = emitter.qScale[cf];
				b = emitter.qScale[cc];
				scale = a + (b - a) * c;
				a = emitter.qScale2[cf];
				b = emitter.qScale2[cc];
				scale2 = a + (b - a) * c;
				a = emitter.qAlpha[cf];
				b = emitter.qAlpha[cc];
				alpha = a + (b - a) * c;
				a = emitter.qAlpha2[cf];
				b = emitter.qAlpha2[cc];
				alpha2 = a + (b - a) * c;
				a = emitter.qRadialSpeed[cf];
				b = emitter.qRadialSpeed[cc];
				radialSpeed = a + (b - a) * c;
				a = emitter.qRadialSpeed2[cf];
				b = emitter.qRadialSpeed2[cc];
				radialSpeed2 = a + (b - a) * c;
				radialSpeed += (radialSpeed2 - radialSpeed) * (rndFactor * 100.0 % 1.0);
				particlePosPrev.x = particleTex[id * particleTexChannels$1];
				particlePosPrev.y = particleTex[id * particleTexChannels$1 + 1];
				particlePosPrev.z = particleTex[id * particleTexChannels$1 + 2];
				if (!emitter.localSpace) radialVelocityVec.copy(particlePosPrev).sub(emitterPos);else radialVelocityVec.copy(particlePosPrev);
				radialVelocityVec.normalize().mulScalar(radialSpeed);
				cf *= 3;
				cc *= 3;
				a = emitter.qLocalVelocity[cf];
				b = emitter.qLocalVelocity[cc];
				localVelocityVec.x = a + (b - a) * c;
				a = emitter.qLocalVelocity[cf + 1];
				b = emitter.qLocalVelocity[cc + 1];
				localVelocityVec.y = a + (b - a) * c;
				a = emitter.qLocalVelocity[cf + 2];
				b = emitter.qLocalVelocity[cc + 2];
				localVelocityVec.z = a + (b - a) * c;
				a = emitter.qLocalVelocity2[cf];
				b = emitter.qLocalVelocity2[cc];
				localVelocityVec2.x = a + (b - a) * c;
				a = emitter.qLocalVelocity2[cf + 1];
				b = emitter.qLocalVelocity2[cc + 1];
				localVelocityVec2.y = a + (b - a) * c;
				a = emitter.qLocalVelocity2[cf + 2];
				b = emitter.qLocalVelocity2[cc + 2];
				localVelocityVec2.z = a + (b - a) * c;
				a = emitter.qVelocity[cf];
				b = emitter.qVelocity[cc];
				velocityVec.x = a + (b - a) * c;
				a = emitter.qVelocity[cf + 1];
				b = emitter.qVelocity[cc + 1];
				velocityVec.y = a + (b - a) * c;
				a = emitter.qVelocity[cf + 2];
				b = emitter.qVelocity[cc + 2];
				velocityVec.z = a + (b - a) * c;
				a = emitter.qVelocity2[cf];
				b = emitter.qVelocity2[cc];
				velocityVec2.x = a + (b - a) * c;
				a = emitter.qVelocity2[cf + 1];
				b = emitter.qVelocity2[cc + 1];
				velocityVec2.y = a + (b - a) * c;
				a = emitter.qVelocity2[cf + 2];
				b = emitter.qVelocity2[cc + 2];
				velocityVec2.z = a + (b - a) * c;
				localVelocityVec.x += (localVelocityVec2.x - localVelocityVec.x) * rndFactor3Vec.x;
				localVelocityVec.y += (localVelocityVec2.y - localVelocityVec.y) * rndFactor3Vec.y;
				localVelocityVec.z += (localVelocityVec2.z - localVelocityVec.z) * rndFactor3Vec.z;

				if (emitter.initialVelocity > 0) {
					if (emitter.emitterShape === EMITTERSHAPE_SPHERE) {
						randomPos.copy(rndFactor3Vec).mulScalar(2).sub(Vec3.ONE).normalize();
						localVelocityVec.add(randomPos.mulScalar(emitter.initialVelocity));
					} else {
						localVelocityVec.add(Vec3.FORWARD.mulScalar(emitter.initialVelocity));
					}
				}

				velocityVec.x += (velocityVec2.x - velocityVec.x) * rndFactor3Vec.x;
				velocityVec.y += (velocityVec2.y - velocityVec.y) * rndFactor3Vec.y;
				velocityVec.z += (velocityVec2.z - velocityVec.z) * rndFactor3Vec.z;
				rotSpeed += (rotSpeed2 - rotSpeed) * rndFactor3Vec.y;
				scale = (scale + (scale2 - scale) * (rndFactor * 10000.0 % 1.0)) * uniformScale;
				alphaDiv = (alpha2 - alpha) * (rndFactor * 1000.0 % 1.0);

				if (emitter.meshInstance.node) {
					if (!emitter.localSpace) {
						rotMat.transformPoint(localVelocityVec, localVelocityVec);
					} else {
						localVelocityVec.x /= nonUniformScale.x;
						localVelocityVec.y /= nonUniformScale.y;
						localVelocityVec.z /= nonUniformScale.z;
					}
				}

				if (!emitter.localSpace) {
					localVelocityVec.add(velocityVec.mul(nonUniformScale));
					localVelocityVec.add(radialVelocityVec.mul(nonUniformScale));
				} else {
					rotMatInv.transformPoint(velocityVec, velocityVec);
					localVelocityVec.add(velocityVec).add(radialVelocityVec);
				}

				moveDirVec.copy(localVelocityVec);
				particlePos.copy(particlePosPrev).add(localVelocityVec.mulScalar(delta));
				particleFinalPos.copy(particlePos);
				particleTex[id * particleTexChannels$1] = particleFinalPos.x;
				particleTex[id * particleTexChannels$1 + 1] = particleFinalPos.y;
				particleTex[id * particleTexChannels$1 + 2] = particleFinalPos.z;
				particleTex[id * particleTexChannels$1 + 3] += rotSpeed * delta;

				if (emitter.wrap && emitter.wrapBounds) {
					if (!emitter.localSpace) particleFinalPos.sub(emitterPos);
					particleFinalPos.x = glMod(particleFinalPos.x, emitter.wrapBounds.x) - emitter.wrapBounds.x * 0.5;
					particleFinalPos.y = glMod(particleFinalPos.y, emitter.wrapBounds.y) - emitter.wrapBounds.y * 0.5;
					particleFinalPos.z = glMod(particleFinalPos.z, emitter.wrapBounds.z) - emitter.wrapBounds.z * 0.5;
					if (!emitter.localSpace) particleFinalPos.add(emitterPos);
				}

				if (emitter.sort > 0) {
					if (emitter.sort === 1) {
						tmpVec3$1.copy(particleFinalPos).sub(posCam);
						emitter.particleDistance[id] = -(tmpVec3$1.x * tmpVec3$1.x + tmpVec3$1.y * tmpVec3$1.y + tmpVec3$1.z * tmpVec3$1.z);
					} else if (emitter.sort === 2) {
						emitter.particleDistance[id] = life;
					} else if (emitter.sort === 3) {
						emitter.particleDistance[id] = -life;
					}
				}
			}

			if (isOnStop) {
				if (life < 0) {
					particleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * 2 * particleTexChannels$1] = -1;
				}
			} else {
				if (life >= particleLifetime) {
					life -= Math.max(particleLifetime, (emitter.numParticles - 1) * particleRate);
					particleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * 2 * particleTexChannels$1] = emitter.loop ? 1 : -1;
				}

				if (life < 0 && emitter.loop) {
					particleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * 2 * particleTexChannels$1] = 1;
				}
			}

			if (particleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * 2 * particleTexChannels$1] < 0) particleEnabled = false;
			particleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1] = life;

			for (let v = 0; v < emitter.numParticleVerts; v++) {
				const vbOffset = (i * emitter.numParticleVerts + v) * (emitter.useMesh ? 6 : 4);
				let quadX = emitter.vbCPU[vbOffset];
				let quadY = emitter.vbCPU[vbOffset + 1];
				let quadZ = emitter.vbCPU[vbOffset + 2];

				if (!particleEnabled) {
					quadX = quadY = quadZ = 0;
				}

				const w = i * emitter.numParticleVerts * vertSize + v * vertSize;
				data[w] = particleFinalPos.x;
				data[w + 1] = particleFinalPos.y;
				data[w + 2] = particleFinalPos.z;
				data[w + 3] = nlife;
				data[w + 4] = emitter.alignToMotion ? angle : particleTex[id * particleTexChannels$1 + 3];
				data[w + 5] = scale;
				data[w + 6] = alphaDiv;
				data[w + 7] = moveDirVec.x;
				data[w + 8] = quadX;
				data[w + 9] = quadY;
				data[w + 10] = quadZ;
				data[w + 11] = moveDirVec.y;
				data[w + 12] = id;
				data[w + 13] = moveDirVec.z;
				data[w + 14] = emitter.vbCPU[vbOffset + 3];

				if (emitter.useMesh) {
					data[w + 15] = emitter.vbCPU[vbOffset + 4];
					data[w + 16] = emitter.vbCPU[vbOffset + 5];
				}
			}
		}

		if (emitter.sort > PARTICLESORT_NONE && emitter.camera) {
			const vbStride = emitter.useMesh ? 6 : 4;
			const particleDistance = emitter.particleDistance;

			for (let i = 0; i < emitter.numParticles; i++) {
				vbToSort[i][0] = i;
				vbToSort[i][1] = particleDistance[Math.floor(emitter.vbCPU[i * emitter.numParticleVerts * vbStride + 3])];
			}

			emitter.vbOld.set(emitter.vbCPU);
			vbToSort.sort(function (p1, p2) {
				return p1[1] - p2[1];
			});

			for (let i = 0; i < emitter.numParticles; i++) {
				const src = vbToSort[i][0] * emitter.numParticleVerts * vbStride;
				const dest = i * emitter.numParticleVerts * vbStride;

				for (let j = 0; j < emitter.numParticleVerts * vbStride; j++) {
					emitter.vbCPU[dest + j] = emitter.vbOld[src + j];
				}
			}
		}
	}

}

const spawnMatrix3 = new Mat3();
const emitterMatrix3 = new Mat3();
const emitterMatrix3Inv = new Mat3();

class ParticleGPUUpdater {
	constructor(emitter, gd) {
		this._emitter = emitter;
		this.frameRandomUniform = new Float32Array(3);
		this.emitterPosUniform = new Float32Array(3);
		this.emitterScaleUniform = new Float32Array([1, 1, 1]);
		this.worldBoundsMulUniform = new Float32Array(3);
		this.worldBoundsAddUniform = new Float32Array(3);
		this.inBoundsSizeUniform = new Float32Array(3);
		this.inBoundsCenterUniform = new Float32Array(3);
		this.constantParticleTexIN = gd.scope.resolve("particleTexIN");
		this.constantParticleTexOUT = gd.scope.resolve("particleTexOUT");
		this.constantEmitterPos = gd.scope.resolve("emitterPos");
		this.constantEmitterScale = gd.scope.resolve("emitterScale");
		this.constantSpawnBounds = gd.scope.resolve("spawnBounds");
		this.constantSpawnPosInnerRatio = gd.scope.resolve("spawnPosInnerRatio");
		this.constantSpawnBoundsSphere = gd.scope.resolve("spawnBoundsSphere");
		this.constantSpawnBoundsSphereInnerRatio = gd.scope.resolve("spawnBoundsSphereInnerRatio");
		this.constantInitialVelocity = gd.scope.resolve("initialVelocity");
		this.constantFrameRandom = gd.scope.resolve("frameRandom");
		this.constantDelta = gd.scope.resolve("delta");
		this.constantRate = gd.scope.resolve("rate");
		this.constantRateDiv = gd.scope.resolve("rateDiv");
		this.constantLifetime = gd.scope.resolve("lifetime");
		this.constantGraphSampleSize = gd.scope.resolve("graphSampleSize");
		this.constantGraphNumSamples = gd.scope.resolve("graphNumSamples");
		this.constantInternalTex0 = gd.scope.resolve("internalTex0");
		this.constantInternalTex1 = gd.scope.resolve("internalTex1");
		this.constantInternalTex2 = gd.scope.resolve("internalTex2");
		this.constantInternalTex3 = gd.scope.resolve("internalTex3");
		this.constantEmitterMatrix = gd.scope.resolve("emitterMatrix");
		this.constantEmitterMatrixInv = gd.scope.resolve("emitterMatrixInv");
		this.constantNumParticles = gd.scope.resolve("numParticles");
		this.constantNumParticlesPot = gd.scope.resolve("numParticlesPot");
		this.constantLocalVelocityDivMult = gd.scope.resolve("localVelocityDivMult");
		this.constantVelocityDivMult = gd.scope.resolve("velocityDivMult");
		this.constantRotSpeedDivMult = gd.scope.resolve("rotSpeedDivMult");
		this.constantSeed = gd.scope.resolve("seed");
		this.constantStartAngle = gd.scope.resolve("startAngle");
		this.constantStartAngle2 = gd.scope.resolve("startAngle2");
		this.constantOutBoundsMul = gd.scope.resolve("outBoundsMul");
		this.constantOutBoundsAdd = gd.scope.resolve("outBoundsAdd");
		this.constantInBoundsSize = gd.scope.resolve("inBoundsSize");
		this.constantInBoundsCenter = gd.scope.resolve("inBoundsCenter");
		this.constantMaxVel = gd.scope.resolve("maxVel");
		this.constantFaceTangent = gd.scope.resolve("faceTangent");
		this.constantFaceBinorm = gd.scope.resolve("faceBinorm");
	}

	_setInputBounds() {
		this.inBoundsSizeUniform[0] = this._emitter.prevWorldBoundsSize.x;
		this.inBoundsSizeUniform[1] = this._emitter.prevWorldBoundsSize.y;
		this.inBoundsSizeUniform[2] = this._emitter.prevWorldBoundsSize.z;
		this.constantInBoundsSize.setValue(this.inBoundsSizeUniform);
		this.inBoundsCenterUniform[0] = this._emitter.prevWorldBoundsCenter.x;
		this.inBoundsCenterUniform[1] = this._emitter.prevWorldBoundsCenter.y;
		this.inBoundsCenterUniform[2] = this._emitter.prevWorldBoundsCenter.z;
		this.constantInBoundsCenter.setValue(this.inBoundsCenterUniform);
	}

	randomize() {
		this.frameRandomUniform[0] = Math.random();
		this.frameRandomUniform[1] = Math.random();
		this.frameRandomUniform[2] = Math.random();
	}

	update(device, spawnMatrix, extentsInnerRatioUniform, delta, isOnStop) {
		const emitter = this._emitter;
		device.setBlending(false);
		device.setColorWrite(true, true, true, true);
		device.setCullMode(CULLFACE_NONE);
		device.setDepthTest(false);
		device.setDepthWrite(false);
		this.randomize();
		this.constantGraphSampleSize.setValue(1.0 / emitter.precision);
		this.constantGraphNumSamples.setValue(emitter.precision);
		this.constantNumParticles.setValue(emitter.numParticles);
		this.constantNumParticlesPot.setValue(emitter.numParticlesPot);
		this.constantInternalTex0.setValue(emitter.internalTex0);
		this.constantInternalTex1.setValue(emitter.internalTex1);
		this.constantInternalTex2.setValue(emitter.internalTex2);
		this.constantInternalTex3.setValue(emitter.internalTex3);
		const node = emitter.meshInstance.node;
		const emitterScale = node === null ? Vec3.ONE : node.localScale;

		if (emitter.pack8) {
			this.worldBoundsMulUniform[0] = emitter.worldBoundsMul.x;
			this.worldBoundsMulUniform[1] = emitter.worldBoundsMul.y;
			this.worldBoundsMulUniform[2] = emitter.worldBoundsMul.z;
			this.constantOutBoundsMul.setValue(this.worldBoundsMulUniform);
			this.worldBoundsAddUniform[0] = emitter.worldBoundsAdd.x;
			this.worldBoundsAddUniform[1] = emitter.worldBoundsAdd.y;
			this.worldBoundsAddUniform[2] = emitter.worldBoundsAdd.z;
			this.constantOutBoundsAdd.setValue(this.worldBoundsAddUniform);

			this._setInputBounds();

			let maxVel = emitter.maxVel * Math.max(Math.max(emitterScale.x, emitterScale.y), emitterScale.z);
			maxVel = Math.max(maxVel, 1);
			this.constantMaxVel.setValue(maxVel);
		}

		const emitterPos = node === null || emitter.localSpace ? Vec3.ZERO : node.getPosition();
		const emitterMatrix = node === null ? Mat4.IDENTITY : node.getWorldTransform();

		if (emitter.emitterShape === EMITTERSHAPE_BOX) {
			spawnMatrix3.setFromMat4(spawnMatrix);
			this.constantSpawnBounds.setValue(spawnMatrix3.data);
			this.constantSpawnPosInnerRatio.setValue(extentsInnerRatioUniform);
		} else {
			this.constantSpawnBoundsSphere.setValue(emitter.emitterRadius);
			this.constantSpawnBoundsSphereInnerRatio.setValue(emitter.emitterRadius === 0 ? 0 : emitter.emitterRadiusInner / emitter.emitterRadius);
		}

		this.constantInitialVelocity.setValue(emitter.initialVelocity);
		emitterMatrix3.setFromMat4(emitterMatrix);
		emitterMatrix.invertTo3x3(emitterMatrix3Inv);
		this.emitterPosUniform[0] = emitterPos.x;
		this.emitterPosUniform[1] = emitterPos.y;
		this.emitterPosUniform[2] = emitterPos.z;
		this.constantEmitterPos.setValue(this.emitterPosUniform);
		this.constantFrameRandom.setValue(this.frameRandomUniform);
		this.constantDelta.setValue(delta);
		this.constantRate.setValue(emitter.rate);
		this.constantRateDiv.setValue(emitter.rate2 - emitter.rate);
		this.constantStartAngle.setValue(emitter.startAngle * math.DEG_TO_RAD);
		this.constantStartAngle2.setValue(emitter.startAngle2 * math.DEG_TO_RAD);
		this.constantSeed.setValue(emitter.seed);
		this.constantLifetime.setValue(emitter.lifetime);
		this.emitterScaleUniform[0] = emitterScale.x;
		this.emitterScaleUniform[1] = emitterScale.y;
		this.emitterScaleUniform[2] = emitterScale.z;
		this.constantEmitterScale.setValue(this.emitterScaleUniform);
		this.constantEmitterMatrix.setValue(emitterMatrix3.data);
		this.constantEmitterMatrixInv.setValue(emitterMatrix3Inv.data);
		this.constantLocalVelocityDivMult.setValue(emitter.localVelocityUMax);
		this.constantVelocityDivMult.setValue(emitter.velocityUMax);
		this.constantRotSpeedDivMult.setValue(emitter.rotSpeedUMax[0]);
		let texIN = emitter.swapTex ? emitter.particleTexOUT : emitter.particleTexIN;
		texIN = emitter.beenReset ? emitter.particleTexStart : texIN;
		const texOUT = emitter.swapTex ? emitter.particleTexIN : emitter.particleTexOUT;
		this.constantParticleTexIN.setValue(texIN);
		drawQuadWithShader(device, emitter.swapTex ? emitter.rtParticleTexIN : emitter.rtParticleTexOUT, !isOnStop ? emitter.loop ? emitter.shaderParticleUpdateRespawn : emitter.shaderParticleUpdateNoRespawn : emitter.shaderParticleUpdateOnStop);
		emitter.material.setParameter("particleTexOUT", texIN);
		emitter.material.setParameter("particleTexIN", texOUT);
		emitter.beenReset = false;
		emitter.swapTex = !emitter.swapTex;
		device.setDepthTest(true);
		device.setDepthWrite(true);
		emitter.prevWorldBoundsSize.copy(emitter.worldBoundsSize);
		emitter.prevWorldBoundsCenter.copy(emitter.worldBounds.center);
		if (emitter.pack8) this._setInputBounds();
	}

}

const particleVerts = [[-1, -1], [1, -1], [1, 1], [-1, 1]];

function _createTexture(device, width, height, pixelData, format = PIXELFORMAT_RGBA32F, mult8Bit, filter) {
	let mipFilter = FILTER_NEAREST;
	if (filter && format === PIXELFORMAT_R8_G8_B8_A8) mipFilter = FILTER_LINEAR;
	const texture = new Texture(device, {
		width: width,
		height: height,
		format: format,
		cubemap: false,
		mipmaps: false,
		minFilter: mipFilter,
		magFilter: mipFilter,
		addressU: ADDRESS_CLAMP_TO_EDGE,
		addressV: ADDRESS_CLAMP_TO_EDGE
	});
	texture.name = "PSTexture";
	const pixels = texture.lock();

	if (format === PIXELFORMAT_R8_G8_B8_A8) {
		const temp = new Uint8Array(pixelData.length);

		for (let i = 0; i < pixelData.length; i++) {
			temp[i] = pixelData[i] * mult8Bit * 255;
		}

		pixelData = temp;
	}

	pixels.set(pixelData);
	texture.unlock();
	return texture;
}

function saturate(x) {
	return Math.max(Math.min(x, 1), 0);
}

const default0Curve = new Curve([0, 0, 1, 0]);
const default1Curve = new Curve([0, 1, 1, 1]);
const default0Curve3 = new CurveSet([0, 0, 1, 0], [0, 0, 1, 0], [0, 0, 1, 0]);
const default1Curve3 = new CurveSet([0, 1, 1, 1], [0, 1, 1, 1], [0, 1, 1, 1]);
let particleTexHeight = 2;
const particleTexChannels = 4;
const extentsInnerRatioUniform = new Float32Array(3);
const spawnMatrix = new Mat4();
const tmpVec3 = new Vec3();
const bMin = new Vec3();
const bMax = new Vec3();
let setPropertyTarget;
let setPropertyOptions;

function setProperty(pName, defaultVal) {
	if (setPropertyOptions[pName] !== undefined && setPropertyOptions[pName] !== null) {
		setPropertyTarget[pName] = setPropertyOptions[pName];
	} else {
		setPropertyTarget[pName] = defaultVal;
	}
}

function pack3NFloats(a, b, c) {
	const packed = a * 255 << 16 | b * 255 << 8 | c * 255;
	return packed / (1 << 24);
}

function packTextureXYZ_NXYZ(qXYZ, qXYZ2) {
	const num = qXYZ.length / 3;
	const colors = new Array(num * 4);

	for (let i = 0; i < num; i++) {
		colors[i * 4] = qXYZ[i * 3];
		colors[i * 4 + 1] = qXYZ[i * 3 + 1];
		colors[i * 4 + 2] = qXYZ[i * 3 + 2];
		colors[i * 4 + 3] = pack3NFloats(qXYZ2[i * 3], qXYZ2[i * 3 + 1], qXYZ2[i * 3 + 2]);
	}

	return colors;
}

function packTextureRGBA(qRGB, qA) {
	const colors = new Array(qA.length * 4);

	for (let i = 0; i < qA.length; i++) {
		colors[i * 4] = qRGB[i * 3];
		colors[i * 4 + 1] = qRGB[i * 3 + 1];
		colors[i * 4 + 2] = qRGB[i * 3 + 2];
		colors[i * 4 + 3] = qA[i];
	}

	return colors;
}

function packTexture5Floats(qA, qB, qC, qD, qE) {
	const colors = new Array(qA.length * 4);

	for (let i = 0; i < qA.length; i++) {
		colors[i * 4] = qA[i];
		colors[i * 4 + 1] = qB[i];
		colors[i * 4 + 2] = 0;
		colors[i * 4 + 3] = pack3NFloats(qC[i], qD[i], qE[i]);
	}

	return colors;
}

function packTexture2Floats(qA, qB) {
	const colors = new Array(qA.length * 4);

	for (let i = 0; i < qA.length; i++) {
		colors[i * 4] = qA[i];
		colors[i * 4 + 1] = qB[i];
		colors[i * 4 + 2] = 0;
		colors[i * 4 + 3] = 0;
	}

	return colors;
}

function calcEndTime(emitter) {
	const interval = Math.max(emitter.rate, emitter.rate2) * emitter.numParticles + emitter.lifetime;
	return Date.now() + interval * 1000;
}

function subGraph(A, B) {
	const r = new Float32Array(A.length);

	for (let i = 0; i < A.length; i++) {
		r[i] = A[i] - B[i];
	}

	return r;
}

function maxUnsignedGraphValue(A, outUMax) {
	const chans = outUMax.length;
	const values = A.length / chans;

	for (let i = 0; i < values; i++) {
		for (let j = 0; j < chans; j++) {
			const a = Math.abs(A[i * chans + j]);
			outUMax[j] = Math.max(outUMax[j], a);
		}
	}
}

function normalizeGraph(A, uMax) {
	const chans = uMax.length;
	const values = A.length / chans;

	for (let i = 0; i < values; i++) {
		for (let j = 0; j < chans; j++) {
			A[i * chans + j] /= uMax[j] === 0 ? 1 : uMax[j];
			A[i * chans + j] *= 0.5;
			A[i * chans + j] += 0.5;
		}
	}
}

function divGraphFrom2Curves(curve1, curve2, outUMax) {
	const sub = subGraph(curve2, curve1);
	maxUnsignedGraphValue(sub, outUMax);
	normalizeGraph(sub, outUMax);
	return sub;
}

const particleEmitterDeviceCache = new DeviceCache();

class ParticleEmitter {
	constructor(graphicsDevice, options) {
		this.graphicsDevice = graphicsDevice;
		const gd = graphicsDevice;
		const precision = 32;
		this.precision = precision;
		this._addTimeTime = 0;
		setPropertyTarget = this;
		setPropertyOptions = options;
		setProperty("numParticles", 1);

		if (this.numParticles > graphicsDevice.maxTextureSize) {
			this.numParticles = graphicsDevice.maxTextureSize;
		}

		setProperty("rate", 1);
		setProperty("rate2", this.rate);
		setProperty("lifetime", 50);
		setProperty("emitterExtents", new Vec3(0, 0, 0));
		setProperty("emitterExtentsInner", new Vec3(0, 0, 0));
		setProperty("emitterRadius", 0);
		setProperty("emitterRadiusInner", 0);
		setProperty("emitterShape", EMITTERSHAPE_BOX);
		setProperty("initialVelocity", 1);
		setProperty("wrap", false);
		setProperty("localSpace", false);
		setProperty("screenSpace", false);
		setProperty("wrapBounds", null);
		setProperty("colorMap", this.defaultParamTexture);
		setProperty("normalMap", null);
		setProperty("loop", true);
		setProperty("preWarm", false);
		setProperty("sort", PARTICLESORT_NONE);
		setProperty("mode", PARTICLEMODE_GPU);
		setProperty("scene", null);
		setProperty("lighting", false);
		setProperty("halfLambert", false);
		setProperty("intensity", 1.0);
		setProperty("stretch", 0.0);
		setProperty("alignToMotion", false);
		setProperty("depthSoftening", 0);
		setProperty("mesh", null);
		setProperty("particleNormal", new Vec3(0, 1, 0));
		setProperty("orientation", PARTICLEORIENTATION_SCREEN);
		setProperty("depthWrite", false);
		setProperty("noFog", false);
		setProperty("blendType", BLEND_NORMAL);
		setProperty("node", null);
		setProperty("startAngle", 0);
		setProperty("startAngle2", this.startAngle);
		setProperty("animTilesX", 1);
		setProperty("animTilesY", 1);
		setProperty("animStartFrame", 0);
		setProperty("animNumFrames", 1);
		setProperty("animNumAnimations", 1);
		setProperty("animIndex", 0);
		setProperty("randomizeAnimIndex", false);
		setProperty("animSpeed", 1);
		setProperty("animLoop", true);
		this._gpuUpdater = new ParticleGPUUpdater(this, gd);
		this._cpuUpdater = new ParticleCPUUpdater(this);
		this.constantLightCube = gd.scope.resolve("lightCube[0]");
		this.emitterPosUniform = new Float32Array(3);
		this.wrapBoundsUniform = new Float32Array(3);
		this.emitterScaleUniform = new Float32Array([1, 1, 1]);
		setProperty("colorGraph", default1Curve3);
		setProperty("colorGraph2", this.colorGraph);
		setProperty("scaleGraph", default1Curve);
		setProperty("scaleGraph2", this.scaleGraph);
		setProperty("alphaGraph", default1Curve);
		setProperty("alphaGraph2", this.alphaGraph);
		setProperty("localVelocityGraph", default0Curve3);
		setProperty("localVelocityGraph2", this.localVelocityGraph);
		setProperty("velocityGraph", default0Curve3);
		setProperty("velocityGraph2", this.velocityGraph);
		setProperty("rotationSpeedGraph", default0Curve);
		setProperty("rotationSpeedGraph2", this.rotationSpeedGraph);
		setProperty("radialSpeedGraph", default0Curve);
		setProperty("radialSpeedGraph2", this.radialSpeedGraph);
		this.lightCube = new Float32Array(6 * 3);
		this.lightCubeDir = new Array(6);
		this.lightCubeDir[0] = new Vec3(-1, 0, 0);
		this.lightCubeDir[1] = new Vec3(1, 0, 0);
		this.lightCubeDir[2] = new Vec3(0, -1, 0);
		this.lightCubeDir[3] = new Vec3(0, 1, 0);
		this.lightCubeDir[4] = new Vec3(0, 0, -1);
		this.lightCubeDir[5] = new Vec3(0, 0, 1);
		this.animTilesParams = new Float32Array(2);
		this.animParams = new Float32Array(4);
		this.animIndexParams = new Float32Array(2);
		this.internalTex0 = null;
		this.internalTex1 = null;
		this.internalTex2 = null;
		this.colorParam = null;
		this.vbToSort = null;
		this.vbOld = null;
		this.particleDistance = null;
		this.camera = null;
		this.swapTex = false;
		this.useMesh = true;
		this.useCpu = false;
		this.pack8 = true;
		this.localBounds = new BoundingBox();
		this.worldBoundsNoTrail = new BoundingBox();
		this.worldBoundsTrail = [new BoundingBox(), new BoundingBox()];
		this.worldBounds = new BoundingBox();
		this.worldBoundsSize = new Vec3();
		this.prevWorldBoundsSize = new Vec3();
		this.prevWorldBoundsCenter = new Vec3();
		this.prevEmitterExtents = this.emitterExtents;
		this.prevEmitterRadius = this.emitterRadius;
		this.worldBoundsMul = new Vec3();
		this.worldBoundsAdd = new Vec3();
		this.timeToSwitchBounds = 0;
		this.shaderParticleUpdateRespawn = null;
		this.shaderParticleUpdateNoRespawn = null;
		this.shaderParticleUpdateOnStop = null;
		this.numParticleVerts = 0;
		this.numParticleIndices = 0;
		this.material = null;
		this.meshInstance = null;
		this.drawOrder = 0;
		this.seed = Math.random();
		this.fixedTimeStep = 1.0 / 60;
		this.maxSubSteps = 10;
		this.simTime = 0;
		this.simTimeTotal = 0;
		this.beenReset = false;
		this._layer = null;
		this.rebuild();
	}

	get defaultParamTexture() {
		return particleEmitterDeviceCache.get(this.graphicsDevice, () => {
			const resolution = 16;
			const centerPoint = resolution * 0.5 + 0.5;
			const dtex = new Float32Array(resolution * resolution * 4);

			for (let y = 0; y < resolution; y++) {
				for (let x = 0; x < resolution; x++) {
					const xgrad = x + 1 - centerPoint;
					const ygrad = y + 1 - centerPoint;
					const c = saturate(1 - saturate(Math.sqrt(xgrad * xgrad + ygrad * ygrad) / resolution) - 0.5);
					const p = y * resolution + x;
					dtex[p * 4] = 1;
					dtex[p * 4 + 1] = 1;
					dtex[p * 4 + 2] = 1;
					dtex[p * 4 + 3] = c;
				}
			}

			const texture = _createTexture(this.graphicsDevice, resolution, resolution, dtex, PIXELFORMAT_R8_G8_B8_A8, 1.0, true);

			texture.minFilter = FILTER_LINEAR;
			texture.magFilter = FILTER_LINEAR;
			return texture;
		});
	}

	onChangeCamera() {
		this.regenShader();
		this.resetMaterial();
	}

	calculateBoundsMad() {
		this.worldBoundsMul.x = 1.0 / this.worldBoundsSize.x;
		this.worldBoundsMul.y = 1.0 / this.worldBoundsSize.y;
		this.worldBoundsMul.z = 1.0 / this.worldBoundsSize.z;
		this.worldBoundsAdd.copy(this.worldBounds.center).mul(this.worldBoundsMul).mulScalar(-1);
		this.worldBoundsAdd.x += 0.5;
		this.worldBoundsAdd.y += 0.5;
		this.worldBoundsAdd.z += 0.5;
	}

	calculateWorldBounds() {
		if (!this.node) return;
		this.prevWorldBoundsSize.copy(this.worldBoundsSize);
		this.prevWorldBoundsCenter.copy(this.worldBounds.center);

		if (!this.useCpu) {
			let recalculateLocalBounds = false;

			if (this.emitterShape === EMITTERSHAPE_BOX) {
				recalculateLocalBounds = !this.emitterExtents.equals(this.prevEmitterExtents);
			} else {
				recalculateLocalBounds = !(this.emitterRadius === this.prevEmitterRadius);
			}

			if (recalculateLocalBounds) {
				this.calculateLocalBounds();
			}
		}

		const nodeWT = this.node.getWorldTransform();

		if (this.localSpace) {
			this.worldBoundsNoTrail.copy(this.localBounds);
		} else {
			this.worldBoundsNoTrail.setFromTransformedAabb(this.localBounds, nodeWT);
		}

		this.worldBoundsTrail[0].add(this.worldBoundsNoTrail);
		this.worldBoundsTrail[1].add(this.worldBoundsNoTrail);
		const now = this.simTimeTotal;

		if (now >= this.timeToSwitchBounds) {
			this.worldBoundsTrail[0].copy(this.worldBoundsTrail[1]);
			this.worldBoundsTrail[1].copy(this.worldBoundsNoTrail);
			this.timeToSwitchBounds = now + this.lifetime;
		}

		this.worldBounds.copy(this.worldBoundsTrail[0]);
		this.worldBoundsSize.copy(this.worldBounds.halfExtents).mulScalar(2);

		if (this.localSpace) {
			this.meshInstance.aabb.setFromTransformedAabb(this.worldBounds, nodeWT);
			this.meshInstance.mesh.aabb.setFromTransformedAabb(this.worldBounds, nodeWT);
		} else {
			this.meshInstance.aabb.copy(this.worldBounds);
			this.meshInstance.mesh.aabb.copy(this.worldBounds);
		}

		this.meshInstance._aabbVer = 1 - this.meshInstance._aabbVer;
		if (this.pack8) this.calculateBoundsMad();
	}

	resetWorldBounds() {
		if (!this.node) return;
		this.worldBoundsNoTrail.setFromTransformedAabb(this.localBounds, this.localSpace ? Mat4.IDENTITY : this.node.getWorldTransform());
		this.worldBoundsTrail[0].copy(this.worldBoundsNoTrail);
		this.worldBoundsTrail[1].copy(this.worldBoundsNoTrail);
		this.worldBounds.copy(this.worldBoundsTrail[0]);
		this.worldBoundsSize.copy(this.worldBounds.halfExtents).mulScalar(2);
		this.prevWorldBoundsSize.copy(this.worldBoundsSize);
		this.prevWorldBoundsCenter.copy(this.worldBounds.center);
		this.simTimeTotal = 0;
		this.timeToSwitchBounds = 0;
	}

	calculateLocalBounds() {
		let minx = Number.MAX_VALUE;
		let miny = Number.MAX_VALUE;
		let minz = Number.MAX_VALUE;
		let maxx = -Number.MAX_VALUE;
		let maxy = -Number.MAX_VALUE;
		let maxz = -Number.MAX_VALUE;
		let maxR = 0;
		let maxScale = 0;
		const stepWeight = this.lifetime / this.precision;
		const wVels = [this.qVelocity, this.qVelocity2];
		const lVels = [this.qLocalVelocity, this.qLocalVelocity2];
		const accumX = [0, 0];
		const accumY = [0, 0];
		const accumZ = [0, 0];
		const accumR = [0, 0];
		const accumW = [0, 0];
		let x, y, z;

		for (let i = 0; i < this.precision + 1; i++) {
			const index = Math.min(i, this.precision - 1);

			for (let j = 0; j < 2; j++) {
				x = lVels[j][index * 3 + 0] * stepWeight + accumX[j];
				y = lVels[j][index * 3 + 1] * stepWeight + accumY[j];
				z = lVels[j][index * 3 + 2] * stepWeight + accumZ[j];
				minx = Math.min(x, minx);
				miny = Math.min(y, miny);
				minz = Math.min(z, minz);
				maxx = Math.max(x, maxx);
				maxy = Math.max(y, maxy);
				maxz = Math.max(z, maxz);
				accumX[j] = x;
				accumY[j] = y;
				accumZ[j] = z;
			}

			for (let j = 0; j < 2; j++) {
				accumW[j] += stepWeight * Math.sqrt(wVels[j][index * 3 + 0] * wVels[j][index * 3 + 0] + wVels[j][index * 3 + 1] * wVels[j][index * 3 + 1] + wVels[j][index * 3 + 2] * wVels[j][index * 3 + 2]);
			}

			accumR[0] += this.qRadialSpeed[index] * stepWeight;
			accumR[1] += this.qRadialSpeed2[index] * stepWeight;
			maxR = Math.max(maxR, Math.max(Math.abs(accumR[0]), Math.abs(accumR[1])));
			maxScale = Math.max(maxScale, this.qScale[index]);
		}

		if (this.emitterShape === EMITTERSHAPE_BOX) {
			x = this.emitterExtents.x * 0.5;
			y = this.emitterExtents.y * 0.5;
			z = this.emitterExtents.z * 0.5;
		} else {
			x = this.emitterRadius;
			y = this.emitterRadius;
			z = this.emitterRadius;
		}

		const w = Math.max(accumW[0], accumW[1]);
		bMin.x = minx - maxScale - x - maxR - w;
		bMin.y = miny - maxScale - y - maxR - w;
		bMin.z = minz - maxScale - z - maxR - w;
		bMax.x = maxx + maxScale + x + maxR + w;
		bMax.y = maxy + maxScale + y + maxR + w;
		bMax.z = maxz + maxScale + z + maxR + w;
		this.localBounds.setMinMax(bMin, bMax);
	}

	rebuild() {
		const gd = this.graphicsDevice;
		if (this.colorMap === null) this.colorMap = this.defaultParamTexture;
		this.spawnBounds = this.emitterShape === EMITTERSHAPE_BOX ? this.emitterExtents : this.emitterRadius;
		this.useCpu = this.useCpu || this.sort > PARTICLESORT_NONE || gd.maxVertexTextures <= 1 || gd.fragmentUniformsCount < 64 || gd.forceCpuParticles || !gd.extTextureFloat;

		this._destroyResources();

		this.pack8 = (this.pack8 || !gd.textureFloatRenderable) && !this.useCpu;
		particleTexHeight = this.useCpu || this.pack8 ? 4 : 2;
		this.useMesh = false;

		if (this.mesh) {
			const totalVertCount = this.numParticles * this.mesh.vertexBuffer.numVertices;

			if (totalVertCount > 65535) ; else {
				this.useMesh = true;
			}
		}

		this.numParticlesPot = math.nextPowerOfTwo(this.numParticles);
		this.rebuildGraphs();
		this.calculateLocalBounds();
		this.resetWorldBounds();

		if (this.node) {
			this.worldBounds.setFromTransformedAabb(this.localBounds, this.localSpace ? Mat4.IDENTITY : this.node.getWorldTransform());
			this.worldBoundsTrail[0].copy(this.worldBounds);
			this.worldBoundsTrail[1].copy(this.worldBounds);
			this.worldBoundsSize.copy(this.worldBounds.halfExtents).mulScalar(2);
			this.prevWorldBoundsSize.copy(this.worldBoundsSize);
			this.prevWorldBoundsCenter.copy(this.worldBounds.center);
			if (this.pack8) this.calculateBoundsMad();
		}

		this.vbToSort = new Array(this.numParticles);

		for (let iSort = 0; iSort < this.numParticles; iSort++) this.vbToSort[iSort] = [0, 0];

		this.particleDistance = new Float32Array(this.numParticles);

		this._gpuUpdater.randomize();

		this.particleTex = new Float32Array(this.numParticlesPot * particleTexHeight * particleTexChannels);
		const emitterPos = this.node === null || this.localSpace ? Vec3.ZERO : this.node.getPosition();

		if (this.emitterShape === EMITTERSHAPE_BOX) {
			if (this.node === null || this.localSpace) {
				spawnMatrix.setTRS(Vec3.ZERO, Quat.IDENTITY, this.spawnBounds);
			} else {
				spawnMatrix.setTRS(Vec3.ZERO, this.node.getRotation(), tmpVec3.copy(this.spawnBounds).mul(this.node.localScale));
			}

			extentsInnerRatioUniform[0] = this.emitterExtents.x !== 0 ? this.emitterExtentsInner.x / this.emitterExtents.x : 0;
			extentsInnerRatioUniform[1] = this.emitterExtents.y !== 0 ? this.emitterExtentsInner.y / this.emitterExtents.y : 0;
			extentsInnerRatioUniform[2] = this.emitterExtents.z !== 0 ? this.emitterExtentsInner.z / this.emitterExtents.z : 0;
		}

		for (let i = 0; i < this.numParticles; i++) {
			this._cpuUpdater.calcSpawnPosition(this.particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, i);

			if (this.useCpu) this.particleTex[i * particleTexChannels + 3 + this.numParticlesPot * 2 * particleTexChannels] = 1;
		}

		this.particleTexStart = new Float32Array(this.numParticlesPot * particleTexHeight * particleTexChannels);

		for (let i = 0; i < this.particleTexStart.length; i++) {
			this.particleTexStart[i] = this.particleTex[i];
		}

		if (!this.useCpu) {
			if (this.pack8) {
				this.particleTexIN = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex, PIXELFORMAT_R8_G8_B8_A8, 1, false);
				this.particleTexOUT = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex, PIXELFORMAT_R8_G8_B8_A8, 1, false);
				this.particleTexStart = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTexStart, PIXELFORMAT_R8_G8_B8_A8, 1, false);
			} else {
				this.particleTexIN = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex);
				this.particleTexOUT = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex);
				this.particleTexStart = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTexStart);
			}

			this.rtParticleTexIN = new RenderTarget({
				colorBuffer: this.particleTexIN,
				depth: false
			});
			this.rtParticleTexOUT = new RenderTarget({
				colorBuffer: this.particleTexOUT,
				depth: false
			});
			this.swapTex = false;
		}

		const shaderCodeStart = (this.localSpace ? '#define LOCAL_SPACE\n' : '') + shaderChunks.particleUpdaterInitPS + (this.pack8 ? shaderChunks.particleInputRgba8PS + shaderChunks.particleOutputRgba8PS : shaderChunks.particleInputFloatPS + shaderChunks.particleOutputFloatPS) + (this.emitterShape === EMITTERSHAPE_BOX ? shaderChunks.particleUpdaterAABBPS : shaderChunks.particleUpdaterSpherePS) + shaderChunks.particleUpdaterStartPS;
		const shaderCodeRespawn = shaderCodeStart + shaderChunks.particleUpdaterRespawnPS + shaderChunks.particleUpdaterEndPS;
		const shaderCodeNoRespawn = shaderCodeStart + shaderChunks.particleUpdaterNoRespawnPS + shaderChunks.particleUpdaterEndPS;
		const shaderCodeOnStop = shaderCodeStart + shaderChunks.particleUpdaterOnStopPS + shaderChunks.particleUpdaterEndPS;
		const params = this.emitterShape + "" + this.pack8 + "" + this.localSpace;
		this.shaderParticleUpdateRespawn = createShaderFromCode(gd, shaderChunks.fullscreenQuadVS, shaderCodeRespawn, "fsQuad0" + params);
		this.shaderParticleUpdateNoRespawn = createShaderFromCode(gd, shaderChunks.fullscreenQuadVS, shaderCodeNoRespawn, "fsQuad1" + params);
		this.shaderParticleUpdateOnStop = createShaderFromCode(gd, shaderChunks.fullscreenQuadVS, shaderCodeOnStop, "fsQuad2" + params);
		this.numParticleVerts = this.useMesh ? this.mesh.vertexBuffer.numVertices : 4;
		this.numParticleIndices = this.useMesh ? this.mesh.indexBuffer[0].numIndices : 6;

		this._allocate(this.numParticles);

		const mesh = new Mesh(gd);
		mesh.vertexBuffer = this.vertexBuffer;
		mesh.indexBuffer[0] = this.indexBuffer;
		mesh.primitive[0].type = PRIMITIVE_TRIANGLES;
		mesh.primitive[0].base = 0;
		mesh.primitive[0].count = this.numParticles * this.numParticleIndices;
		mesh.primitive[0].indexed = true;
		this.material = new Material();
		this.material.name = this.node.name;
		this.material.cull = CULLFACE_NONE;
		this.material.alphaWrite = false;
		this.material.blend = true;
		this.material.blendType = this.blendType;
		this.material.depthWrite = this.depthWrite;
		this.material.emitter = this;
		this.regenShader();
		this.resetMaterial();
		const wasVisible = this.meshInstance ? this.meshInstance.visible : true;
		this.meshInstance = new MeshInstance(mesh, this.material, this.node);
		this.meshInstance.pick = false;
		this.meshInstance.updateKey();
		this.meshInstance.cull = true;
		this.meshInstance._noDepthDrawGl1 = true;

		if (this.localSpace) {
			this.meshInstance.aabb.setFromTransformedAabb(this.worldBounds, this.node.getWorldTransform());
		} else {
			this.meshInstance.aabb.copy(this.worldBounds);
		}

		this.meshInstance._updateAabb = false;
		this.meshInstance.visible = wasVisible;

		this._initializeTextures();

		this.resetTime();
		this.addTime(0, false);
		if (this.preWarm) this.prewarm(this.lifetime);
	}

	_isAnimated() {
		return this.animNumFrames >= 1 && (this.animTilesX > 1 || this.animTilesY > 1) && (this.colorMap && this.colorMap !== this.defaultParamTexture || this.normalMap);
	}

	rebuildGraphs() {
		const precision = this.precision;
		const gd = this.graphicsDevice;
		this.qLocalVelocity = this.localVelocityGraph.quantize(precision);
		this.qVelocity = this.velocityGraph.quantize(precision);
		this.qColor = this.colorGraph.quantizeClamped(precision, 0, 1);
		this.qRotSpeed = this.rotationSpeedGraph.quantize(precision);
		this.qScale = this.scaleGraph.quantize(precision);
		this.qAlpha = this.alphaGraph.quantize(precision);
		this.qRadialSpeed = this.radialSpeedGraph.quantize(precision);
		this.qLocalVelocity2 = this.localVelocityGraph2.quantize(precision);
		this.qVelocity2 = this.velocityGraph2.quantize(precision);
		this.qColor2 = this.colorGraph2.quantizeClamped(precision, 0, 1);
		this.qRotSpeed2 = this.rotationSpeedGraph2.quantize(precision);
		this.qScale2 = this.scaleGraph2.quantize(precision);
		this.qAlpha2 = this.alphaGraph2.quantize(precision);
		this.qRadialSpeed2 = this.radialSpeedGraph2.quantize(precision);

		for (let i = 0; i < precision; i++) {
			this.qRotSpeed[i] *= math.DEG_TO_RAD;
			this.qRotSpeed2[i] *= math.DEG_TO_RAD;
		}

		this.localVelocityUMax = new Float32Array(3);
		this.velocityUMax = new Float32Array(3);
		this.colorUMax = new Float32Array(3);
		this.rotSpeedUMax = [0];
		this.scaleUMax = [0];
		this.alphaUMax = [0];
		this.radialSpeedUMax = [0];
		this.qLocalVelocityDiv = divGraphFrom2Curves(this.qLocalVelocity, this.qLocalVelocity2, this.localVelocityUMax);
		this.qVelocityDiv = divGraphFrom2Curves(this.qVelocity, this.qVelocity2, this.velocityUMax);
		this.qColorDiv = divGraphFrom2Curves(this.qColor, this.qColor2, this.colorUMax);
		this.qRotSpeedDiv = divGraphFrom2Curves(this.qRotSpeed, this.qRotSpeed2, this.rotSpeedUMax);
		this.qScaleDiv = divGraphFrom2Curves(this.qScale, this.qScale2, this.scaleUMax);
		this.qAlphaDiv = divGraphFrom2Curves(this.qAlpha, this.qAlpha2, this.alphaUMax);
		this.qRadialSpeedDiv = divGraphFrom2Curves(this.qRadialSpeed, this.qRadialSpeed2, this.radialSpeedUMax);

		if (this.pack8) {
			const umax = [0, 0, 0];
			maxUnsignedGraphValue(this.qVelocity, umax);
			const umax2 = [0, 0, 0];
			maxUnsignedGraphValue(this.qVelocity2, umax2);
			const lumax = [0, 0, 0];
			maxUnsignedGraphValue(this.qLocalVelocity, lumax);
			const lumax2 = [0, 0, 0];
			maxUnsignedGraphValue(this.qLocalVelocity2, lumax2);
			const rumax = [0];
			maxUnsignedGraphValue(this.qRadialSpeed, rumax);
			const rumax2 = [0];
			maxUnsignedGraphValue(this.qRadialSpeed2, rumax2);
			let maxVel = Math.max(umax[0], umax2[0]);
			maxVel = Math.max(maxVel, umax[1]);
			maxVel = Math.max(maxVel, umax2[1]);
			maxVel = Math.max(maxVel, umax[2]);
			maxVel = Math.max(maxVel, umax2[2]);
			let lmaxVel = Math.max(lumax[0], lumax2[0]);
			lmaxVel = Math.max(lmaxVel, lumax[1]);
			lmaxVel = Math.max(lmaxVel, lumax2[1]);
			lmaxVel = Math.max(lmaxVel, lumax[2]);
			lmaxVel = Math.max(lmaxVel, lumax2[2]);
			const maxRad = Math.max(rumax[0], rumax2[0]);
			this.maxVel = maxVel + lmaxVel + maxRad;
		}

		if (!this.useCpu) {
			this.internalTex0 = _createTexture(gd, precision, 1, packTextureXYZ_NXYZ(this.qLocalVelocity, this.qLocalVelocityDiv));
			this.internalTex1 = _createTexture(gd, precision, 1, packTextureXYZ_NXYZ(this.qVelocity, this.qVelocityDiv));
			this.internalTex2 = _createTexture(gd, precision, 1, packTexture5Floats(this.qRotSpeed, this.qScale, this.qScaleDiv, this.qRotSpeedDiv, this.qAlphaDiv));
			this.internalTex3 = _createTexture(gd, precision, 1, packTexture2Floats(this.qRadialSpeed, this.qRadialSpeedDiv));
		}

		this.colorParam = _createTexture(gd, precision, 1, packTextureRGBA(this.qColor, this.qAlpha), PIXELFORMAT_R8_G8_B8_A8, 1.0, true);
	}

	_initializeTextures() {
		if (this.colorMap) {
			this.material.setParameter('colorMap', this.colorMap);

			if (this.lighting && this.normalMap) {
				this.material.setParameter('normalMap', this.normalMap);
			}
		}
	}

	regenShader() {
		const programLib = this.graphicsDevice.getProgramLibrary();
		const hasNormal = this.normalMap !== null;
		this.normalOption = 0;

		if (this.lighting) {
			this.normalOption = hasNormal ? 2 : 1;
		}

		this.material.updateShader = function () {
			if (this.emitter.scene) {
				if (this.emitter.camera !== this.emitter.scene._activeCamera) {
					this.emitter.camera = this.emitter.scene._activeCamera;
					this.emitter.onChangeCamera();
				}
			}

			const inTools = this.emitter.inTools;
			const shader = programLib.getProgram("particle", {
				useCpu: this.emitter.useCpu,
				normal: this.emitter.normalOption,
				halflambert: this.emitter.halfLambert,
				stretch: this.emitter.stretch,
				alignToMotion: this.emitter.alignToMotion,
				soft: this.emitter.depthSoftening,
				mesh: this.emitter.useMesh,
				gamma: this.emitter.scene ? this.emitter.scene.gammaCorrection : 0,
				toneMap: this.emitter.scene ? this.emitter.scene.toneMapping : 0,
				fog: this.emitter.scene && !this.emitter.noFog ? this.emitter.scene.fog : "none",
				wrap: this.emitter.wrap && this.emitter.wrapBounds,
				localSpace: this.emitter.localSpace,
				screenSpace: inTools ? false : this.emitter.screenSpace,
				blend: this.blendType,
				animTex: this.emitter._isAnimated(),
				animTexLoop: this.emitter.animLoop,
				pack8: this.emitter.pack8,
				customFace: this.emitter.orientation !== PARTICLEORIENTATION_SCREEN
			});
			this.shader = shader;
		};

		this.material.updateShader();
	}

	resetMaterial() {
		const material = this.material;
		material.setParameter('stretch', this.stretch);

		if (this._isAnimated()) {
			material.setParameter('animTexTilesParams', this.animTilesParams);
			material.setParameter('animTexParams', this.animParams);
			material.setParameter('animTexIndexParams', this.animIndexParams);
		}

		material.setParameter('colorMult', this.intensity);

		if (!this.useCpu) {
			material.setParameter('internalTex0', this.internalTex0);
			material.setParameter('internalTex1', this.internalTex1);
			material.setParameter('internalTex2', this.internalTex2);
			material.setParameter('internalTex3', this.internalTex3);
		}

		material.setParameter('colorParam', this.colorParam);
		material.setParameter('numParticles', this.numParticles);
		material.setParameter('numParticlesPot', this.numParticlesPot);
		material.setParameter('lifetime', this.lifetime);
		material.setParameter('rate', this.rate);
		material.setParameter('rateDiv', this.rate2 - this.rate);
		material.setParameter('seed', this.seed);
		material.setParameter('scaleDivMult', this.scaleUMax[0]);
		material.setParameter('alphaDivMult', this.alphaUMax[0]);
		material.setParameter('radialSpeedDivMult', this.radialSpeedUMax[0]);
		material.setParameter("graphNumSamples", this.precision);
		material.setParameter("graphSampleSize", 1.0 / this.precision);
		material.setParameter("emitterScale", new Float32Array([1, 1, 1]));

		if (this.pack8) {
			this._gpuUpdater._setInputBounds();

			material.setParameter("inBoundsSize", this._gpuUpdater.inBoundsSizeUniform);
			material.setParameter("inBoundsCenter", this._gpuUpdater.inBoundsCenterUniform);
			material.setParameter("maxVel", this.maxVel);
		}

		if (this.wrap && this.wrapBounds) {
			this.wrapBoundsUniform[0] = this.wrapBounds.x;
			this.wrapBoundsUniform[1] = this.wrapBounds.y;
			this.wrapBoundsUniform[2] = this.wrapBounds.z;
			material.setParameter('wrapBounds', this.wrapBoundsUniform);
		}

		if (this.colorMap) {
			material.setParameter('colorMap', this.colorMap);
		}

		if (this.lighting) {
			if (this.normalMap) {
				material.setParameter('normalMap', this.normalMap);
			}
		}

		if (this.depthSoftening > 0) {
			material.setParameter('softening', 1.0 / (this.depthSoftening * this.depthSoftening * 100));
		}

		if (this.stretch > 0.0) material.cull = CULLFACE_NONE;

		this._compParticleFaceParams();
	}

	_compParticleFaceParams() {
		let tangent, binormal;

		if (this.orientation === PARTICLEORIENTATION_SCREEN) {
			tangent = new Float32Array([1, 0, 0]);
			binormal = new Float32Array([0, 0, 1]);
		} else {
			let n;

			if (this.orientation === PARTICLEORIENTATION_WORLD) {
				n = this.particleNormal.normalize();
			} else {
				const emitterMat = this.node === null ? Mat4.IDENTITY : this.node.getWorldTransform();
				n = emitterMat.transformVector(this.particleNormal).normalize();
			}

			const t = new Vec3(1, 0, 0);
			if (Math.abs(t.dot(n)) === 1) t.set(0, 0, 1);
			const b = new Vec3().cross(n, t).normalize();
			t.cross(b, n).normalize();
			tangent = new Float32Array([t.x, t.y, t.z]);
			binormal = new Float32Array([b.x, b.y, b.z]);
		}

		this.material.setParameter("faceTangent", tangent);
		this.material.setParameter("faceBinorm", binormal);
	}

	_allocate(numParticles) {
		const psysVertCount = numParticles * this.numParticleVerts;
		const psysIndexCount = numParticles * this.numParticleIndices;

		if (this.vertexBuffer === undefined || this.vertexBuffer.getNumVertices() !== psysVertCount) {
			if (!this.useCpu) {
				const elements = [{
					semantic: SEMANTIC_ATTR0,
					components: 4,
					type: TYPE_FLOAT32
				}];

				if (this.useMesh) {
					elements.push({
						semantic: SEMANTIC_ATTR1,
						components: 2,
						type: TYPE_FLOAT32
					});
				}

				const particleFormat = new VertexFormat(this.graphicsDevice, elements);
				this.vertexBuffer = new VertexBuffer(this.graphicsDevice, particleFormat, psysVertCount, BUFFER_DYNAMIC);
				this.indexBuffer = new IndexBuffer(this.graphicsDevice, INDEXFORMAT_UINT16, psysIndexCount);
			} else {
				const elements = [{
					semantic: SEMANTIC_ATTR0,
					components: 4,
					type: TYPE_FLOAT32
				}, {
					semantic: SEMANTIC_ATTR1,
					components: 4,
					type: TYPE_FLOAT32
				}, {
					semantic: SEMANTIC_ATTR2,
					components: 4,
					type: TYPE_FLOAT32
				}, {
					semantic: SEMANTIC_ATTR3,
					components: 1,
					type: TYPE_FLOAT32
				}, {
					semantic: SEMANTIC_ATTR4,
					components: this.useMesh ? 4 : 2,
					type: TYPE_FLOAT32
				}];
				const particleFormat = new VertexFormat(this.graphicsDevice, elements);
				this.vertexBuffer = new VertexBuffer(this.graphicsDevice, particleFormat, psysVertCount, BUFFER_DYNAMIC);
				this.indexBuffer = new IndexBuffer(this.graphicsDevice, INDEXFORMAT_UINT16, psysIndexCount);
			}

			const data = new Float32Array(this.vertexBuffer.lock());
			let meshData, stride, texCoordOffset;

			if (this.useMesh) {
				meshData = new Float32Array(this.mesh.vertexBuffer.lock());
				stride = meshData.length / this.mesh.vertexBuffer.numVertices;

				for (let elem = 0; elem < this.mesh.vertexBuffer.format.elements.length; elem++) {
					if (this.mesh.vertexBuffer.format.elements[elem].name === SEMANTIC_TEXCOORD0) {
						texCoordOffset = this.mesh.vertexBuffer.format.elements[elem].offset / 4;
						break;
					}
				}
			}

			for (let i = 0; i < psysVertCount; i++) {
				const id = Math.floor(i / this.numParticleVerts);

				if (!this.useMesh) {
					const vertID = i % 4;
					data[i * 4] = particleVerts[vertID][0];
					data[i * 4 + 1] = particleVerts[vertID][1];
					data[i * 4 + 2] = 0;
					data[i * 4 + 3] = id;
				} else {
					const vert = i % this.numParticleVerts;
					data[i * 6] = meshData[vert * stride];
					data[i * 6 + 1] = meshData[vert * stride + 1];
					data[i * 6 + 2] = meshData[vert * stride + 2];
					data[i * 6 + 3] = id;
					data[i * 6 + 4] = meshData[vert * stride + texCoordOffset + 0];
					data[i * 6 + 5] = 1.0 - meshData[vert * stride + texCoordOffset + 1];
				}
			}

			if (this.useCpu) {
				this.vbCPU = new Float32Array(data);
				this.vbOld = new Float32Array(this.vbCPU.length);
			}

			this.vertexBuffer.unlock();

			if (this.useMesh) {
				this.mesh.vertexBuffer.unlock();
			}

			let dst = 0;
			const indices = new Uint16Array(this.indexBuffer.lock());
			if (this.useMesh) meshData = new Uint16Array(this.mesh.indexBuffer[0].lock());

			for (let i = 0; i < numParticles; i++) {
				if (!this.useMesh) {
					const baseIndex = i * 4;
					indices[dst++] = baseIndex;
					indices[dst++] = baseIndex + 1;
					indices[dst++] = baseIndex + 2;
					indices[dst++] = baseIndex;
					indices[dst++] = baseIndex + 2;
					indices[dst++] = baseIndex + 3;
				} else {
					for (let j = 0; j < this.numParticleIndices; j++) {
						indices[i * this.numParticleIndices + j] = meshData[j] + i * this.numParticleVerts;
					}
				}
			}

			this.indexBuffer.unlock();
			if (this.useMesh) this.mesh.indexBuffer[0].unlock();
		}
	}

	reset() {
		this.beenReset = true;
		this.seed = Math.random();
		this.material.setParameter('seed', this.seed);

		if (this.useCpu) {
			for (let i = 0; i < this.particleTexStart.length; i++) {
				this.particleTex[i] = this.particleTexStart[i];
			}
		} else {
			this._initializeTextures();
		}

		this.resetWorldBounds();
		this.resetTime();
		const origLoop = this.loop;
		this.loop = true;
		this.addTime(0, false);
		this.loop = origLoop;

		if (this.preWarm) {
			this.prewarm(this.lifetime);
		}
	}

	prewarm(time) {
		const lifetimeFraction = time / this.lifetime;
		const iterations = Math.min(Math.floor(lifetimeFraction * this.precision), this.precision);
		const stepDelta = time / iterations;

		for (let i = 0; i < iterations; i++) {
			this.addTime(stepDelta, false);
		}
	}

	resetTime() {
		this.endTime = calcEndTime(this);
	}

	finishFrame() {
		if (this.useCpu) this.vertexBuffer.unlock();
	}

	addTime(delta, isOnStop) {
		const device = this.graphicsDevice;
		this.simTimeTotal += delta;
		this.calculateWorldBounds();

		if (this._isAnimated()) {
			const tilesParams = this.animTilesParams;
			tilesParams[0] = 1.0 / this.animTilesX;
			tilesParams[1] = 1.0 / this.animTilesY;
			const params = this.animParams;
			params[0] = this.animStartFrame;
			params[1] = this.animNumFrames * this.animSpeed;
			params[2] = this.animNumFrames - 1;
			params[3] = this.animNumAnimations - 1;
			const animIndexParams = this.animIndexParams;
			animIndexParams[0] = this.animIndex;
			animIndexParams[1] = this.randomizeAnimIndex;
		}

		if (this.scene) {
			if (this.camera !== this.scene._activeCamera) {
				this.camera = this.scene._activeCamera;
				this.onChangeCamera();
			}
		}

		if (this.emitterShape === EMITTERSHAPE_BOX) {
			extentsInnerRatioUniform[0] = this.emitterExtents.x !== 0 ? this.emitterExtentsInner.x / this.emitterExtents.x : 0;
			extentsInnerRatioUniform[1] = this.emitterExtents.y !== 0 ? this.emitterExtentsInner.y / this.emitterExtents.y : 0;
			extentsInnerRatioUniform[2] = this.emitterExtents.z !== 0 ? this.emitterExtentsInner.z / this.emitterExtents.z : 0;

			if (this.meshInstance.node === null) {
				spawnMatrix.setTRS(Vec3.ZERO, Quat.IDENTITY, this.emitterExtents);
			} else {
				spawnMatrix.setTRS(Vec3.ZERO, this.meshInstance.node.getRotation(), tmpVec3.copy(this.emitterExtents).mul(this.meshInstance.node.localScale));
			}
		}

		let emitterPos;
		const emitterScale = this.meshInstance.node === null ? Vec3.ONE : this.meshInstance.node.localScale;
		this.emitterScaleUniform[0] = emitterScale.x;
		this.emitterScaleUniform[1] = emitterScale.y;
		this.emitterScaleUniform[2] = emitterScale.z;
		this.material.setParameter("emitterScale", this.emitterScaleUniform);

		if (this.localSpace && this.meshInstance.node) {
			emitterPos = this.meshInstance.node.getPosition();
			this.emitterPosUniform[0] = emitterPos.x;
			this.emitterPosUniform[1] = emitterPos.y;
			this.emitterPosUniform[2] = emitterPos.z;
			this.material.setParameter("emitterPos", this.emitterPosUniform);
		}

		this._compParticleFaceParams();

		if (!this.useCpu) {
			this._gpuUpdater.update(device, spawnMatrix, extentsInnerRatioUniform, delta, isOnStop);
		} else {
			const data = new Float32Array(this.vertexBuffer.lock());

			this._cpuUpdater.update(data, this.vbToSort, this.particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, delta, isOnStop);
		}

		if (!this.loop) {
			if (Date.now() > this.endTime) {
				if (this.onFinished) this.onFinished();
				this.meshInstance.visible = false;
			}
		}

		if (this.meshInstance) {
			this.meshInstance.drawOrder = this.drawOrder;
		}
	}

	_destroyResources() {
		if (this.particleTexIN) {
			this.particleTexIN.destroy();
			this.particleTexIN = null;
		}

		if (this.particleTexOUT) {
			this.particleTexOUT.destroy();
			this.particleTexOUT = null;
		}

		if (this.particleTexStart && this.particleTexStart.destroy) {
			this.particleTexStart.destroy();
			this.particleTexStart = null;
		}

		if (this.rtParticleTexIN) {
			this.rtParticleTexIN.destroy();
			this.rtParticleTexIN = null;
		}

		if (this.rtParticleTexOUT) {
			this.rtParticleTexOUT.destroy();
			this.rtParticleTexOUT = null;
		}

		if (this.internalTex0) {
			this.internalTex0.destroy();
			this.internalTex0 = null;
		}

		if (this.internalTex1) {
			this.internalTex1.destroy();
			this.internalTex1 = null;
		}

		if (this.internalTex2) {
			this.internalTex2.destroy();
			this.internalTex2 = null;
		}

		if (this.internalTex3) {
			this.internalTex3.destroy();
			this.internalTex3 = null;
		}

		if (this.colorParam) {
			this.colorParam.destroy();
			this.colorParam = null;
		}

		if (this.vertexBuffer) {
			this.vertexBuffer.destroy();
			this.vertexBuffer = undefined;
		}

		if (this.indexBuffer) {
			this.indexBuffer.destroy();
			this.indexBuffer = undefined;
		}

		if (this.material) {
			this.material.destroy();
			this.material = null;
		}
	}

	destroy() {
		this.camera = null;

		this._destroyResources();
	}

}

const SIMPLE_PROPERTIES = ['emitterExtents', 'emitterRadius', 'emitterExtentsInner', 'emitterRadiusInner', 'loop', 'initialVelocity', 'animSpeed', 'normalMap', 'particleNormal'];
const COMPLEX_PROPERTIES = ['numParticles', 'lifetime', 'rate', 'rate2', 'startAngle', 'startAngle2', 'lighting', 'halfLambert', 'intensity', 'wrap', 'wrapBounds', 'depthWrite', 'noFog', 'sort', 'stretch', 'alignToMotion', 'preWarm', 'emitterShape', 'animTilesX', 'animTilesY', 'animStartFrame', 'animNumFrames', 'animNumAnimations', 'animIndex', 'randomizeAnimIndex', 'animLoop', 'colorMap', 'localSpace', 'screenSpace', 'orientation'];
const GRAPH_PROPERTIES = ['scaleGraph', 'scaleGraph2', 'colorGraph', 'colorGraph2', 'alphaGraph', 'alphaGraph2', 'velocityGraph', 'velocityGraph2', 'localVelocityGraph', 'localVelocityGraph2', 'rotationSpeedGraph', 'rotationSpeedGraph2', 'radialSpeedGraph', 'radialSpeedGraph2'];
const ASSET_PROPERTIES = ['colorMapAsset', 'normalMapAsset', 'meshAsset', 'renderAsset'];
let depthLayer;

class ParticleSystemComponent extends Component {
	constructor(system, entity) {
		super(system, entity);
		this._requestedDepth = false;
		this._drawOrder = 0;
		this.on("set_colorMapAsset", this.onSetColorMapAsset, this);
		this.on("set_normalMapAsset", this.onSetNormalMapAsset, this);
		this.on("set_meshAsset", this.onSetMeshAsset, this);
		this.on("set_mesh", this.onSetMesh, this);
		this.on("set_renderAsset", this.onSetRenderAsset, this);
		this.on("set_loop", this.onSetLoop, this);
		this.on("set_blendType", this.onSetBlendType, this);
		this.on("set_depthSoftening", this.onSetDepthSoftening, this);
		this.on("set_layers", this.onSetLayers, this);
		SIMPLE_PROPERTIES.forEach(prop => {
			this.on(`set_${prop}`, this.onSetSimpleProperty, this);
		});
		COMPLEX_PROPERTIES.forEach(prop => {
			this.on(`set_${prop}`, this.onSetComplexProperty, this);
		});
		GRAPH_PROPERTIES.forEach(prop => {
			this.on(`set_${prop}`, this.onSetGraphProperty, this);
		});
	}

	set drawOrder(drawOrder) {
		this._drawOrder = drawOrder;

		if (this.emitter) {
			this.emitter.drawOrder = drawOrder;
		}
	}

	get drawOrder() {
		return this._drawOrder;
	}

	addMeshInstanceToLayers() {
		if (!this.emitter) return;

		for (let i = 0; i < this.layers.length; i++) {
			const layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
			if (!layer) continue;
			layer.addMeshInstances([this.emitter.meshInstance]);
			this.emitter._layer = layer;
		}
	}

	removeMeshInstanceFromLayers() {
		if (!this.emitter) return;

		for (let i = 0; i < this.layers.length; i++) {
			const layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
			if (!layer) continue;
			layer.removeMeshInstances([this.emitter.meshInstance]);
		}
	}

	onSetLayers(name, oldValue, newValue) {
		if (!this.emitter) return;

		for (let i = 0; i < oldValue.length; i++) {
			const layer = this.system.app.scene.layers.getLayerById(oldValue[i]);
			if (!layer) continue;
			layer.removeMeshInstances([this.emitter.meshInstance]);
		}

		if (!this.enabled || !this.entity.enabled) return;

		for (let i = 0; i < newValue.length; i++) {
			const layer = this.system.app.scene.layers.getLayerById(newValue[i]);
			if (!layer) continue;
			layer.addMeshInstances([this.emitter.meshInstance]);
		}
	}

	onLayersChanged(oldComp, newComp) {
		this.addMeshInstanceToLayers();
		oldComp.off("add", this.onLayerAdded, this);
		oldComp.off("remove", this.onLayerRemoved, this);
		newComp.on("add", this.onLayerAdded, this);
		newComp.on("remove", this.onLayerRemoved, this);
	}

	onLayerAdded(layer) {
		if (!this.emitter) return;
		const index = this.layers.indexOf(layer.id);
		if (index < 0) return;
		layer.addMeshInstances([this.emitter.meshInstance]);
	}

	onLayerRemoved(layer) {
		if (!this.emitter) return;
		const index = this.layers.indexOf(layer.id);
		if (index < 0) return;
		layer.removeMeshInstances([this.emitter.meshInstance]);
	}

	_bindColorMapAsset(asset) {
		asset.on('load', this._onColorMapAssetLoad, this);
		asset.on('unload', this._onColorMapAssetUnload, this);
		asset.on('remove', this._onColorMapAssetRemove, this);
		asset.on('change', this._onColorMapAssetChange, this);

		if (asset.resource) {
			this._onColorMapAssetLoad(asset);
		} else {
			if (!this.enabled || !this.entity.enabled) return;
			this.system.app.assets.load(asset);
		}
	}

	_unbindColorMapAsset(asset) {
		asset.off('load', this._onColorMapAssetLoad, this);
		asset.off('unload', this._onColorMapAssetUnload, this);
		asset.off('remove', this._onColorMapAssetRemove, this);
		asset.off('change', this._onColorMapAssetChange, this);
	}

	_onColorMapAssetLoad(asset) {
		this.colorMap = asset.resource;
	}

	_onColorMapAssetUnload(asset) {
		this.colorMap = null;
	}

	_onColorMapAssetRemove(asset) {
		this._onColorMapAssetUnload(asset);
	}

	_onColorMapAssetChange(asset) {}

	onSetColorMapAsset(name, oldValue, newValue) {
		const assets = this.system.app.assets;

		if (oldValue) {
			const asset = assets.get(oldValue);

			if (asset) {
				this._unbindColorMapAsset(asset);
			}
		}

		if (newValue) {
			if (newValue instanceof Asset) {
				this.data.colorMapAsset = newValue.id;
				newValue = newValue.id;
			}

			const asset = assets.get(newValue);

			if (asset) {
				this._bindColorMapAsset(asset);
			} else {
				assets.once("add:" + newValue, asset => {
					this._bindColorMapAsset(asset);
				});
			}
		} else {
			this.colorMap = null;
		}
	}

	_bindNormalMapAsset(asset) {
		asset.on('load', this._onNormalMapAssetLoad, this);
		asset.on('unload', this._onNormalMapAssetUnload, this);
		asset.on('remove', this._onNormalMapAssetRemove, this);
		asset.on('change', this._onNormalMapAssetChange, this);

		if (asset.resource) {
			this._onNormalMapAssetLoad(asset);
		} else {
			if (!this.enabled || !this.entity.enabled) return;
			this.system.app.assets.load(asset);
		}
	}

	_unbindNormalMapAsset(asset) {
		asset.off('load', this._onNormalMapAssetLoad, this);
		asset.off('unload', this._onNormalMapAssetUnload, this);
		asset.off('remove', this._onNormalMapAssetRemove, this);
		asset.off('change', this._onNormalMapAssetChange, this);
	}

	_onNormalMapAssetLoad(asset) {
		this.normalMap = asset.resource;
	}

	_onNormalMapAssetUnload(asset) {
		this.normalMap = null;
	}

	_onNormalMapAssetRemove(asset) {
		this._onNormalMapAssetUnload(asset);
	}

	_onNormalMapAssetChange(asset) {}

	onSetNormalMapAsset(name, oldValue, newValue) {
		const assets = this.system.app.assets;

		if (oldValue) {
			const asset = assets.get(oldValue);

			if (asset) {
				this._unbindNormalMapAsset(asset);
			}
		}

		if (newValue) {
			if (newValue instanceof Asset) {
				this.data.normalMapAsset = newValue.id;
				newValue = newValue.id;
			}

			const asset = assets.get(newValue);

			if (asset) {
				this._bindNormalMapAsset(asset);
			} else {
				assets.once("add:" + newValue, asset => {
					this._bindNormalMapAsset(asset);
				});
			}
		} else {
			this.normalMap = null;
		}
	}

	_bindMeshAsset(asset) {
		asset.on('load', this._onMeshAssetLoad, this);
		asset.on('unload', this._onMeshAssetUnload, this);
		asset.on('remove', this._onMeshAssetRemove, this);
		asset.on('change', this._onMeshAssetChange, this);

		if (asset.resource) {
			this._onMeshAssetLoad(asset);
		} else {
			if (!this.enabled || !this.entity.enabled) return;
			this.system.app.assets.load(asset);
		}
	}

	_unbindMeshAsset(asset) {
		asset.off('load', this._onMeshAssetLoad, this);
		asset.off('unload', this._onMeshAssetUnload, this);
		asset.off('remove', this._onMeshAssetRemove, this);
		asset.off('change', this._onMeshAssetChange, this);
	}

	_onMeshAssetLoad(asset) {
		this._onMeshChanged(asset.resource);
	}

	_onMeshAssetUnload(asset) {
		this.mesh = null;
	}

	_onMeshAssetRemove(asset) {
		this._onMeshAssetUnload(asset);
	}

	_onMeshAssetChange(asset) {}

	onSetMeshAsset(name, oldValue, newValue) {
		const assets = this.system.app.assets;

		if (oldValue) {
			const asset = assets.get(oldValue);

			if (asset) {
				this._unbindMeshAsset(asset);
			}
		}

		if (newValue) {
			if (newValue instanceof Asset) {
				this.data.meshAsset = newValue.id;
				newValue = newValue.id;
			}

			const asset = assets.get(newValue);

			if (asset) {
				this._bindMeshAsset(asset);
			}
		} else {
			this._onMeshChanged(null);
		}
	}

	onSetMesh(name, oldValue, newValue) {
		if (!newValue || newValue instanceof Asset || typeof newValue === 'number') {
			this.meshAsset = newValue;
		} else {
			this._onMeshChanged(newValue);
		}
	}

	_onMeshChanged(mesh) {
		if (mesh && !(mesh instanceof Mesh)) {
			if (mesh.meshInstances[0]) {
				mesh = mesh.meshInstances[0].mesh;
			} else {
				mesh = null;
			}
		}

		this.data.mesh = mesh;

		if (this.emitter) {
			this.emitter.mesh = mesh;
			this.emitter.resetMaterial();
			this.rebuild();
		}
	}

	onSetRenderAsset(name, oldValue, newValue) {
		const assets = this.system.app.assets;

		if (oldValue) {
			const asset = assets.get(oldValue);

			if (asset) {
				this._unbindRenderAsset(asset);
			}
		}

		if (newValue) {
			if (newValue instanceof Asset) {
				this.data.renderAsset = newValue.id;
				newValue = newValue.id;
			}

			const asset = assets.get(newValue);

			if (asset) {
				this._bindRenderAsset(asset);
			}
		} else {
			this._onRenderChanged(null);
		}
	}

	_bindRenderAsset(asset) {
		asset.on('load', this._onRenderAssetLoad, this);
		asset.on('unload', this._onRenderAssetUnload, this);
		asset.on('remove', this._onRenderAssetRemove, this);

		if (asset.resource) {
			this._onRenderAssetLoad(asset);
		} else {
			if (!this.enabled || !this.entity.enabled) return;
			this.system.app.assets.load(asset);
		}
	}

	_unbindRenderAsset(asset) {
		asset.off('load', this._onRenderAssetLoad, this);
		asset.off('unload', this._onRenderAssetUnload, this);
		asset.off('remove', this._onRenderAssetRemove, this);

		if (asset.resource) {
			asset.resource.off('set:meshes', this._onRenderSetMeshes, this);
		}
	}

	_onRenderAssetLoad(asset) {
		this._onRenderChanged(asset.resource);
	}

	_onRenderAssetUnload(asset) {
		this._onRenderChanged(null);
	}

	_onRenderAssetRemove(asset) {
		this._onRenderAssetUnload(asset);
	}

	_onRenderChanged(render) {
		if (!render) {
			this._onMeshChanged(null);

			return;
		}

		render.off('set:meshes', this._onRenderSetMeshes, this);
		render.on('set:meshes', this._onRenderSetMeshes, this);

		if (render.meshes) {
			this._onRenderSetMeshes(render.meshes);
		}
	}

	_onRenderSetMeshes(meshes) {
		this._onMeshChanged(meshes && meshes[0]);
	}

	onSetLoop(name, oldValue, newValue) {
		if (this.emitter) {
			this.emitter[name] = newValue;
			this.emitter.resetTime();
		}
	}

	onSetBlendType(name, oldValue, newValue) {
		if (this.emitter) {
			this.emitter[name] = newValue;
			this.emitter.material.blendType = newValue;
			this.emitter.resetMaterial();
			this.rebuild();
		}
	}

	_requestDepth() {
		if (this._requestedDepth) return;
		if (!depthLayer) depthLayer = this.system.app.scene.layers.getLayerById(LAYERID_DEPTH);

		if (depthLayer) {
			depthLayer.incrementCounter();
			this._requestedDepth = true;
		}
	}

	_releaseDepth() {
		if (!this._requestedDepth) return;

		if (depthLayer) {
			depthLayer.decrementCounter();
			this._requestedDepth = false;
		}
	}

	onSetDepthSoftening(name, oldValue, newValue) {
		if (oldValue !== newValue) {
			if (newValue) {
				if (this.enabled && this.entity.enabled) this._requestDepth();
				if (this.emitter) this.emitter[name] = newValue;
			} else {
				if (this.enabled && this.entity.enabled) this._releaseDepth();
				if (this.emitter) this.emitter[name] = newValue;
			}

			if (this.emitter) {
				this.reset();
				this.emitter.resetMaterial();
				this.rebuild();
			}
		}
	}

	onSetSimpleProperty(name, oldValue, newValue) {
		if (this.emitter) {
			this.emitter[name] = newValue;
			this.emitter.resetMaterial();
		}
	}

	onSetComplexProperty(name, oldValue, newValue) {
		if (this.emitter) {
			this.emitter[name] = newValue;
			this.emitter.resetMaterial();
			this.rebuild();
			this.reset();
		}
	}

	onSetGraphProperty(name, oldValue, newValue) {
		if (this.emitter) {
			this.emitter[name] = newValue;
			this.emitter.rebuildGraphs();
			this.emitter.resetMaterial();
		}
	}

	onEnable() {
		const data = this.data;

		for (let i = 0, len = ASSET_PROPERTIES.length; i < len; i++) {
			let asset = data[ASSET_PROPERTIES[i]];

			if (asset) {
				if (!(asset instanceof Asset)) {
					const id = parseInt(asset, 10);

					if (id >= 0) {
						asset = this.system.app.assets.get(asset);
					} else {
						continue;
					}
				}

				if (asset && !asset.resource) {
					this.system.app.assets.load(asset);
				}
			}
		}

		if (!this.emitter) {
			let mesh = data.mesh;
			if (!(mesh instanceof Mesh)) mesh = null;
			this.emitter = new ParticleEmitter(this.system.app.graphicsDevice, {
				numParticles: data.numParticles,
				emitterExtents: data.emitterExtents,
				emitterExtentsInner: data.emitterExtentsInner,
				emitterRadius: data.emitterRadius,
				emitterRadiusInner: data.emitterRadiusInner,
				emitterShape: data.emitterShape,
				initialVelocity: data.initialVelocity,
				wrap: data.wrap,
				localSpace: data.localSpace,
				screenSpace: data.screenSpace,
				wrapBounds: data.wrapBounds,
				lifetime: data.lifetime,
				rate: data.rate,
				rate2: data.rate2,
				orientation: data.orientation,
				particleNormal: data.particleNormal,
				animTilesX: data.animTilesX,
				animTilesY: data.animTilesY,
				animStartFrame: data.animStartFrame,
				animNumFrames: data.animNumFrames,
				animNumAnimations: data.animNumAnimations,
				animIndex: data.animIndex,
				randomizeAnimIndex: data.randomizeAnimIndex,
				animSpeed: data.animSpeed,
				animLoop: data.animLoop,
				startAngle: data.startAngle,
				startAngle2: data.startAngle2,
				scaleGraph: data.scaleGraph,
				scaleGraph2: data.scaleGraph2,
				colorGraph: data.colorGraph,
				colorGraph2: data.colorGraph2,
				alphaGraph: data.alphaGraph,
				alphaGraph2: data.alphaGraph2,
				localVelocityGraph: data.localVelocityGraph,
				localVelocityGraph2: data.localVelocityGraph2,
				velocityGraph: data.velocityGraph,
				velocityGraph2: data.velocityGraph2,
				rotationSpeedGraph: data.rotationSpeedGraph,
				rotationSpeedGraph2: data.rotationSpeedGraph2,
				radialSpeedGraph: data.radialSpeedGraph,
				radialSpeedGraph2: data.radialSpeedGraph2,
				colorMap: data.colorMap,
				normalMap: data.normalMap,
				loop: data.loop,
				preWarm: data.preWarm,
				sort: data.sort,
				stretch: data.stretch,
				alignToMotion: data.alignToMotion,
				lighting: data.lighting,
				halfLambert: data.halfLambert,
				intensity: data.intensity,
				depthSoftening: data.depthSoftening,
				scene: this.system.app.scene,
				mesh: mesh,
				depthWrite: data.depthWrite,
				noFog: data.noFog,
				node: this.entity,
				blendType: data.blendType
			});
			this.emitter.meshInstance.node = this.entity;
			this.emitter.drawOrder = this.drawOrder;

			if (!data.autoPlay) {
				this.pause();
				this.emitter.meshInstance.visible = false;
			}
		}

		if (this.emitter.colorMap) {
			this.addMeshInstanceToLayers();
		}

		this.system.app.scene.on("set:layers", this.onLayersChanged, this);

		if (this.system.app.scene.layers) {
			this.system.app.scene.layers.on("add", this.onLayerAdded, this);
			this.system.app.scene.layers.on("remove", this.onLayerRemoved, this);
		}

		if (this.enabled && this.entity.enabled && data.depthSoftening) {
			this._requestDepth();
		}
	}

	onDisable() {
		this.system.app.scene.off("set:layers", this.onLayersChanged, this);

		if (this.system.app.scene.layers) {
			this.system.app.scene.layers.off("add", this.onLayerAdded, this);
			this.system.app.scene.layers.off("remove", this.onLayerRemoved, this);
		}

		if (this.emitter) {
			this.removeMeshInstanceFromLayers();
			if (this.data.depthSoftening) this._releaseDepth();
			this.emitter.camera = null;
		}
	}

	onBeforeRemove() {
		if (this.enabled) {
			this.enabled = false;
		}

		if (this.emitter) {
			this.emitter.destroy();
			this.emitter = null;
		}

		for (let i = 0; i < ASSET_PROPERTIES.length; i++) {
			const prop = ASSET_PROPERTIES[i];

			if (this.data[prop]) {
				this[prop] = null;
			}
		}

		this.off();
	}

	reset() {
		if (this.emitter) {
			this.emitter.reset();
		}
	}

	stop() {
		if (this.emitter) {
			this.emitter.loop = false;
			this.emitter.resetTime();
			this.emitter.addTime(0, true);
		}
	}

	pause() {
		this.data.paused = true;
	}

	unpause() {
		this.data.paused = false;
	}

	play() {
		this.data.paused = false;

		if (this.emitter) {
			this.emitter.meshInstance.visible = true;
			this.emitter.loop = this.data.loop;
			this.emitter.resetTime();
		}
	}

	isPlaying() {
		if (this.data.paused) {
			return false;
		}

		if (this.emitter && this.emitter.loop) {
			return true;
		}

		return Date.now() <= this.emitter.endTime;
	}

	rebuild() {
		const enabled = this.enabled;
		this.enabled = false;

		if (this.emitter) {
			this.emitter.rebuild();
			this.emitter.meshInstance.node = this.entity;
		}

		this.enabled = enabled;
	}

}

class ParticleSystemComponentData {
	constructor() {
		this.numParticles = 1;
		this.rate = 1;
		this.rate2 = null;
		this.startAngle = 0;
		this.startAngle2 = null;
		this.lifetime = 50;
		this.emitterExtents = new Vec3();
		this.emitterExtentsInner = new Vec3();
		this.emitterRadius = 0;
		this.emitterRadiusInner = 0;
		this.emitterShape = EMITTERSHAPE_BOX;
		this.initialVelocity = 0;
		this.wrapBounds = new Vec3();
		this.localSpace = false;
		this.screenSpace = false;
		this.colorMap = null;
		this.colorMapAsset = null;
		this.normalMap = null;
		this.normalMapAsset = null;
		this.loop = true;
		this.preWarm = false;
		this.sort = 0;
		this.mode = PARTICLEMODE_GPU;
		this.scene = null;
		this.lighting = false;
		this.halfLambert = false;
		this.intensity = 1;
		this.stretch = 0.0;
		this.alignToMotion = false;
		this.depthSoftening = 0;
		this.meshAsset = null;
		this.mesh = null;
		this.depthWrite = false;
		this.noFog = false;
		this.orientation = PARTICLEORIENTATION_SCREEN;
		this.particleNormal = new Vec3(0, 1, 0);
		this.animTilesX = 1;
		this.animTilesY = 1;
		this.animStartFrame = 0;
		this.animNumFrames = 1;
		this.animNumAnimations = 1;
		this.animIndex = 0;
		this.randomizeAnimIndex = false;
		this.animSpeed = 1;
		this.animLoop = true;
		this.scaleGraph = null;
		this.scaleGraph2 = null;
		this.colorGraph = null;
		this.colorGraph2 = null;
		this.alphaGraph = null;
		this.alphaGraph2 = null;
		this.localVelocityGraph = null;
		this.localVelocityGraph2 = null;
		this.velocityGraph = null;
		this.velocityGraph2 = null;
		this.rotationSpeedGraph = null;
		this.rotationSpeedGraph2 = null;
		this.radialSpeedGraph = null;
		this.radialSpeedGraph2 = null;
		this.blendType = BLEND_NORMAL;
		this.enabled = true;
		this.paused = false;
		this.autoPlay = true;
		this.layers = [LAYERID_WORLD];
	}

}

const _schema$8 = ['enabled', 'autoPlay', 'numParticles', 'lifetime', 'rate', 'rate2', 'startAngle', 'startAngle2', 'loop', 'preWarm', 'lighting', 'halfLambert', 'intensity', 'depthWrite', 'noFog', 'depthSoftening', 'sort', 'blendType', 'stretch', 'alignToMotion', 'emitterShape', 'emitterExtents', 'emitterExtentsInner', 'emitterRadius', 'emitterRadiusInner', 'initialVelocity', 'wrap', 'wrapBounds', 'localSpace', 'screenSpace', 'colorMapAsset', 'normalMapAsset', 'mesh', 'meshAsset', 'renderAsset', 'orientation', 'particleNormal', 'localVelocityGraph', 'localVelocityGraph2', 'velocityGraph', 'velocityGraph2', 'rotationSpeedGraph', 'rotationSpeedGraph2', 'radialSpeedGraph', 'radialSpeedGraph2', 'scaleGraph', 'scaleGraph2', 'colorGraph', 'colorGraph2', 'alphaGraph', 'alphaGraph2', 'colorMap', 'normalMap', 'animTilesX', 'animTilesY', 'animStartFrame', 'animNumFrames', 'animNumAnimations', 'animIndex', 'randomizeAnimIndex', 'animSpeed', 'animLoop', 'layers'];

class ParticleSystemComponentSystem extends ComponentSystem {
	constructor(app) {
		super(app);
		this.id = 'particlesystem';
		this.ComponentType = ParticleSystemComponent;
		this.DataType = ParticleSystemComponentData;
		this.schema = _schema$8;
		this.propertyTypes = {
			emitterExtents: 'vec3',
			emitterExtentsInner: 'vec3',
			particleNormal: 'vec3',
			wrapBounds: 'vec3',
			localVelocityGraph: 'curveset',
			localVelocityGraph2: 'curveset',
			velocityGraph: 'curveset',
			velocityGraph2: 'curveset',
			colorGraph: 'curveset',
			colorGraph2: 'curveset',
			alphaGraph: 'curve',
			alphaGraph2: 'curve',
			rotationSpeedGraph: 'curve',
			rotationSpeedGraph2: 'curve',
			radialSpeedGraph: 'curve',
			radialSpeedGraph2: 'curve',
			scaleGraph: 'curve',
			scaleGraph2: 'curve'
		};
		this.on('beforeremove', this.onBeforeRemove, this);
		this.app.systems.on('update', this.onUpdate, this);
	}

	initializeComponentData(component, _data, properties) {
		const data = {};
		properties = [];
		const types = this.propertyTypes;

		if (_data.mesh instanceof Asset || typeof _data.mesh === 'number') {
			_data.meshAsset = _data.mesh;
			delete _data.mesh;
		}

		for (const prop in _data) {
			if (_data.hasOwnProperty(prop)) {
				properties.push(prop);
				data[prop] = _data[prop];
			}

			if (types[prop] === 'vec3') {
				if (Array.isArray(data[prop])) {
					data[prop] = new Vec3(data[prop][0], data[prop][1], data[prop][2]);
				}
			} else if (types[prop] === 'curve') {
				if (!(data[prop] instanceof Curve)) {
					const t = data[prop].type;
					data[prop] = new Curve(data[prop].keys);
					data[prop].type = t;
				}
			} else if (types[prop] === 'curveset') {
				if (!(data[prop] instanceof CurveSet)) {
					const t = data[prop].type;
					data[prop] = new CurveSet(data[prop].keys);
					data[prop].type = t;
				}
			}

			if (data.layers && Array.isArray(data.layers)) {
				data.layers = data.layers.slice(0);
			}
		}

		super.initializeComponentData(component, data, properties);
	}

	cloneComponent(entity, clone) {
		const source = entity.particlesystem.data;
		const schema = this.schema;
		const data = {};

		for (let i = 0, len = schema.length; i < len; i++) {
			const prop = schema[i];
			let sourceProp = source[prop];

			if (sourceProp instanceof Vec3 || sourceProp instanceof Curve || sourceProp instanceof CurveSet) {
				sourceProp = sourceProp.clone();
				data[prop] = sourceProp;
			} else if (prop === "layers") {
				data.layers = source.layers.slice(0);
			} else {
				if (sourceProp !== null && sourceProp !== undefined) {
					data[prop] = sourceProp;
				}
			}
		}

		return this.addComponent(clone, data);
	}

	onUpdate(dt) {
		const components = this.store;
		let numSteps;
		const stats = this.app.stats.particles;

		for (const id in components) {
			if (components.hasOwnProperty(id)) {
				const component = components[id];
				const entity = component.entity;
				const data = component.data;

				if (data.enabled && entity.enabled) {
					const emitter = entity.particlesystem.emitter;
					if (!emitter.meshInstance.visible) continue;

					if (emitter.lighting) {
						const layers = data.layers;
						let lightCube;

						for (let i = 0; i < layers.length; i++) {
							const layer = this.app.scene.layers.getLayerById(layers[i]);
							if (!layer) continue;

							if (!layer._lightCube) {
								layer._lightCube = new Float32Array(6 * 3);
							}

							lightCube = layer._lightCube;

							for (let j = 0; j < 6; j++) {
								lightCube[j * 3] = this.app.scene.ambientLight.r;
								lightCube[j * 3 + 1] = this.app.scene.ambientLight.g;
								lightCube[j * 3 + 2] = this.app.scene.ambientLight.b;
							}

							const dirs = layer._splitLights[LIGHTTYPE_DIRECTIONAL];

							for (let j = 0; j < dirs.length; j++) {
								for (let c = 0; c < 6; c++) {
									const weight = Math.max(emitter.lightCubeDir[c].dot(dirs[j]._direction), 0) * dirs[j]._intensity;

									lightCube[c * 3] += dirs[j]._color.r * weight;
									lightCube[c * 3 + 1] += dirs[j]._color.g * weight;
									lightCube[c * 3 + 2] += dirs[j]._color.b * weight;
								}
							}
						}

						emitter.constantLightCube.setValue(lightCube);
					}

					if (!data.paused) {
						emitter.simTime += dt;

						if (emitter.simTime > emitter.fixedTimeStep) {
							numSteps = Math.floor(emitter.simTime / emitter.fixedTimeStep);
							emitter.simTime -= numSteps * emitter.fixedTimeStep;
						}

						if (numSteps) {
							numSteps = Math.min(numSteps, emitter.maxSubSteps);

							for (let i = 0; i < numSteps; i++) {
								emitter.addTime(emitter.fixedTimeStep, false);
							}

							stats._updatesPerFrame += numSteps;
							stats._frameTime += emitter._addTimeTime;
							emitter._addTimeTime = 0;
						}

						emitter.finishFrame();
					}
				}
			}
		}
	}

	onBeforeRemove(entity, component) {
		component.onBeforeRemove();
	}

	destroy() {
		super.destroy();
		this.app.systems.off('update', this.onUpdate, this);
	}

}

Component._buildAccessors(ParticleSystemComponent.prototype, _schema$8);

class ObjectPool {
	constructor(constructorFunc, size) {
		this._constructor = constructorFunc;
		this._pool = [];
		this._count = 0;

		this._resize(size);
	}

	_resize(size) {
		if (size > this._pool.length) {
			for (let i = this._pool.length; i < size; i++) {
				this._pool[i] = new this._constructor();
			}
		}
	}

	allocate() {
		if (this._count >= this._pool.length) {
			this._resize(this._pool.length * 2);
		}

		return this._pool[this._count++];
	}

	freeAll() {
		this._count = 0;
	}

}

let ammoTransform;
let ammoVec1, ammoVec2, ammoQuat, ammoOrigin;

class RigidBodyComponent extends Component {
	constructor(system, entity) {
		super(system, entity);
		this._angularDamping = 0;
		this._angularFactor = new Vec3(1, 1, 1);
		this._angularVelocity = new Vec3();
		this._body = null;
		this._friction = 0.5;
		this._group = BODYGROUP_STATIC;
		this._linearDamping = 0;
		this._linearFactor = new Vec3(1, 1, 1);
		this._linearVelocity = new Vec3();
		this._mask = BODYMASK_NOT_STATIC;
		this._mass = 1;
		this._restitution = 0;
		this._rollingFriction = 0;
		this._simulationEnabled = false;
		this._type = BODYTYPE_STATIC;
	}

	static onLibraryLoaded() {
		if (typeof Ammo !== 'undefined' && !ammoTransform) {
			ammoTransform = new Ammo.btTransform();
			ammoVec1 = new Ammo.btVector3();
			ammoVec2 = new Ammo.btVector3();
			ammoQuat = new Ammo.btQuaternion();
			ammoOrigin = new Ammo.btVector3(0, 0, 0);
		}
	}

	set angularDamping(damping) {
		if (this._angularDamping !== damping) {
			this._angularDamping = damping;

			if (this._body) {
				this._body.setDamping(this._linearDamping, damping);
			}
		}
	}

	get angularDamping() {
		return this._angularDamping;
	}

	set angularFactor(factor) {
		if (!this._angularFactor.equals(factor)) {
			this._angularFactor.copy(factor);

			if (this._body && this._type === BODYTYPE_DYNAMIC) {
				ammoVec1.setValue(factor.x, factor.y, factor.z);

				this._body.setAngularFactor(ammoVec1);
			}
		}
	}

	get angularFactor() {
		return this._angularFactor;
	}

	set angularVelocity(velocity) {
		if (this._body && this._type === BODYTYPE_DYNAMIC) {
			this._body.activate();

			ammoVec1.setValue(velocity.x, velocity.y, velocity.z);

			this._body.setAngularVelocity(ammoVec1);

			this._angularVelocity.copy(velocity);
		}
	}

	get angularVelocity() {
		if (this._body && this._type === BODYTYPE_DYNAMIC) {
			const velocity = this._body.getAngularVelocity();

			this._angularVelocity.set(velocity.x(), velocity.y(), velocity.z());
		}

		return this._angularVelocity;
	}

	set body(body) {
		if (this._body !== body) {
			this._body = body;

			if (body && this._simulationEnabled) {
				body.activate();
			}
		}
	}

	get body() {
		return this._body;
	}

	set friction(friction) {
		if (this._friction !== friction) {
			this._friction = friction;

			if (this._body) {
				this._body.setFriction(friction);
			}
		}
	}

	get friction() {
		return this._friction;
	}

	set group(group) {
		if (this._group !== group) {
			this._group = group;

			if (this.enabled && this.entity.enabled) {
				this.disableSimulation();
				this.enableSimulation();
			}
		}
	}

	get group() {
		return this._group;
	}

	set linearDamping(damping) {
		if (this._linearDamping !== damping) {
			this._linearDamping = damping;

			if (this._body) {
				this._body.setDamping(damping, this._angularDamping);
			}
		}
	}

	get linearDamping() {
		return this._linearDamping;
	}

	set linearFactor(factor) {
		if (!this._linearFactor.equals(factor)) {
			this._linearFactor.copy(factor);

			if (this._body && this._type === BODYTYPE_DYNAMIC) {
				ammoVec1.setValue(factor.x, factor.y, factor.z);

				this._body.setLinearFactor(ammoVec1);
			}
		}
	}

	get linearFactor() {
		return this._linearFactor;
	}

	set linearVelocity(velocity) {
		if (this._body && this._type === BODYTYPE_DYNAMIC) {
			this._body.activate();

			ammoVec1.setValue(velocity.x, velocity.y, velocity.z);

			this._body.setLinearVelocity(ammoVec1);

			this._linearVelocity.copy(velocity);
		}
	}

	get linearVelocity() {
		if (this._body && this._type === BODYTYPE_DYNAMIC) {
			const velocity = this._body.getLinearVelocity();

			this._linearVelocity.set(velocity.x(), velocity.y(), velocity.z());
		}

		return this._linearVelocity;
	}

	set mask(mask) {
		if (this._mask !== mask) {
			this._mask = mask;

			if (this.enabled && this.entity.enabled) {
				this.disableSimulation();
				this.enableSimulation();
			}
		}
	}

	get mask() {
		return this._mask;
	}

	set mass(mass) {
		if (this._mass !== mass) {
			this._mass = mass;

			if (this._body && this._type === BODYTYPE_DYNAMIC) {
				const enabled = this.enabled && this.entity.enabled;

				if (enabled) {
					this.disableSimulation();
				}

				this._body.getCollisionShape().calculateLocalInertia(mass, ammoVec1);

				this._body.setMassProps(mass, ammoVec1);

				this._body.updateInertiaTensor();

				if (enabled) {
					this.enableSimulation();
				}
			}
		}
	}

	get mass() {
		return this._mass;
	}

	set restitution(restitution) {
		if (this._restitution !== restitution) {
			this._restitution = restitution;

			if (this._body) {
				this._body.setRestitution(restitution);
			}
		}
	}

	get restitution() {
		return this._restitution;
	}

	set rollingFriction(friction) {
		if (this._rollingFriction !== friction) {
			this._rollingFriction = friction;

			if (this._body) {
				this._body.setRollingFriction(friction);
			}
		}
	}

	get rollingFriction() {
		return this._rollingFriction;
	}

	set type(type) {
		if (this._type !== type) {
			this._type = type;
			this.disableSimulation();

			switch (type) {
				case BODYTYPE_DYNAMIC:
					this._group = BODYGROUP_DYNAMIC;
					this._mask = BODYMASK_ALL;
					break;

				case BODYTYPE_KINEMATIC:
					this._group = BODYGROUP_KINEMATIC;
					this._mask = BODYMASK_ALL;
					break;

				case BODYTYPE_STATIC:
				default:
					this._group = BODYGROUP_STATIC;
					this._mask = BODYMASK_NOT_STATIC;
					break;
			}

			this.createBody();
		}
	}

	get type() {
		return this._type;
	}

	createBody() {
		const entity = this.entity;
		let shape;

		if (entity.collision) {
			shape = entity.collision.shape;

			if (entity.trigger) {
				entity.trigger.destroy();
				delete entity.trigger;
			}
		}

		if (shape) {
			if (this._body) this.system.onRemove(entity, this);
			const mass = this._type === BODYTYPE_DYNAMIC ? this._mass : 0;

			this._getEntityTransform(ammoTransform);

			const body = this.system.createBody(mass, shape, ammoTransform);
			body.setRestitution(this._restitution);
			body.setFriction(this._friction);
			body.setRollingFriction(this._rollingFriction);
			body.setDamping(this._linearDamping, this._angularDamping);

			if (this._type === BODYTYPE_DYNAMIC) {
				const linearFactor = this._linearFactor;
				ammoVec1.setValue(linearFactor.x, linearFactor.y, linearFactor.z);
				body.setLinearFactor(ammoVec1);
				const angularFactor = this._angularFactor;
				ammoVec1.setValue(angularFactor.x, angularFactor.y, angularFactor.z);
				body.setAngularFactor(ammoVec1);
			} else if (this._type === BODYTYPE_KINEMATIC) {
				body.setCollisionFlags(body.getCollisionFlags() | BODYFLAG_KINEMATIC_OBJECT);
				body.setActivationState(BODYSTATE_DISABLE_DEACTIVATION);
			}

			body.entity = entity;
			this.body = body;

			if (this.enabled && entity.enabled) {
				this.enableSimulation();
			}
		}
	}

	isActive() {
		return this._body ? this._body.isActive() : false;
	}

	activate() {
		if (this._body) {
			this._body.activate();
		}
	}

	enableSimulation() {
		const entity = this.entity;

		if (entity.collision && entity.collision.enabled && !this._simulationEnabled) {
			const body = this._body;

			if (body) {
				this.system.addBody(body, this._group, this._mask);

				switch (this._type) {
					case BODYTYPE_DYNAMIC:
						this.system._dynamic.push(this);

						body.forceActivationState(BODYSTATE_ACTIVE_TAG);
						this.syncEntityToBody();
						break;

					case BODYTYPE_KINEMATIC:
						this.system._kinematic.push(this);

						body.forceActivationState(BODYSTATE_DISABLE_DEACTIVATION);
						break;

					case BODYTYPE_STATIC:
						body.forceActivationState(BODYSTATE_ACTIVE_TAG);
						this.syncEntityToBody();
						break;
				}

				if (entity.collision.type === 'compound') {
					this.system._compounds.push(entity.collision);
				}

				body.activate();
				this._simulationEnabled = true;
			}
		}
	}

	disableSimulation() {
		const body = this._body;

		if (body && this._simulationEnabled) {
			const system = this.system;

			let idx = system._compounds.indexOf(this.entity.collision);

			if (idx > -1) {
				system._compounds.splice(idx, 1);
			}

			idx = system._dynamic.indexOf(this);

			if (idx > -1) {
				system._dynamic.splice(idx, 1);
			}

			idx = system._kinematic.indexOf(this);

			if (idx > -1) {
				system._kinematic.splice(idx, 1);
			}

			system.removeBody(body);
			body.forceActivationState(BODYSTATE_DISABLE_SIMULATION);
			this._simulationEnabled = false;
		}
	}

	applyForce() {
		let x, y, z;
		let px, py, pz;

		switch (arguments.length) {
			case 1:
				x = arguments[0].x;
				y = arguments[0].y;
				z = arguments[0].z;
				break;

			case 2:
				x = arguments[0].x;
				y = arguments[0].y;
				z = arguments[0].z;
				px = arguments[1].x;
				py = arguments[1].y;
				pz = arguments[1].z;
				break;

			case 3:
				x = arguments[0];
				y = arguments[1];
				z = arguments[2];
				break;

			case 6:
				x = arguments[0];
				y = arguments[1];
				z = arguments[2];
				px = arguments[3];
				py = arguments[4];
				pz = arguments[5];
				break;
		}

		const body = this._body;

		if (body) {
			body.activate();
			ammoVec1.setValue(x, y, z);

			if (px !== undefined) {
				ammoVec2.setValue(px, py, pz);
				body.applyForce(ammoVec1, ammoVec2);
			} else {
				body.applyForce(ammoVec1, ammoOrigin);
			}
		}
	}

	applyTorque() {
		let x, y, z;

		switch (arguments.length) {
			case 1:
				x = arguments[0].x;
				y = arguments[0].y;
				z = arguments[0].z;
				break;

			case 3:
				x = arguments[0];
				y = arguments[1];
				z = arguments[2];
				break;

			default:
				return;
		}

		const body = this._body;

		if (body) {
			body.activate();
			ammoVec1.setValue(x, y, z);
			body.applyTorque(ammoVec1);
		}
	}

	applyImpulse() {
		let x, y, z;
		let px, py, pz;

		switch (arguments.length) {
			case 1:
				x = arguments[0].x;
				y = arguments[0].y;
				z = arguments[0].z;
				break;

			case 2:
				x = arguments[0].x;
				y = arguments[0].y;
				z = arguments[0].z;
				px = arguments[1].x;
				py = arguments[1].y;
				pz = arguments[1].z;
				break;

			case 3:
				x = arguments[0];
				y = arguments[1];
				z = arguments[2];
				break;

			case 6:
				x = arguments[0];
				y = arguments[1];
				z = arguments[2];
				px = arguments[3];
				py = arguments[4];
				pz = arguments[5];
				break;

			default:
				return;
		}

		const body = this._body;

		if (body) {
			body.activate();
			ammoVec1.setValue(x, y, z);

			if (px !== undefined) {
				ammoVec2.setValue(px, py, pz);
				body.applyImpulse(ammoVec1, ammoVec2);
			} else {
				body.applyImpulse(ammoVec1, ammoOrigin);
			}
		}
	}

	applyTorqueImpulse() {
		let x, y, z;

		switch (arguments.length) {
			case 1:
				x = arguments[0].x;
				y = arguments[0].y;
				z = arguments[0].z;
				break;

			case 3:
				x = arguments[0];
				y = arguments[1];
				z = arguments[2];
				break;

			default:
				return;
		}

		const body = this._body;

		if (body) {
			body.activate();
			ammoVec1.setValue(x, y, z);
			body.applyTorqueImpulse(ammoVec1);
		}
	}

	isStatic() {
		return this._type === BODYTYPE_STATIC;
	}

	isStaticOrKinematic() {
		return this._type === BODYTYPE_STATIC || this._type === BODYTYPE_KINEMATIC;
	}

	isKinematic() {
		return this._type === BODYTYPE_KINEMATIC;
	}

	_getEntityTransform(transform) {
		const entity = this.entity;
		const pos = entity.getPosition();
		const rot = entity.getRotation();
		ammoVec1.setValue(pos.x, pos.y, pos.z);
		ammoQuat.setValue(rot.x, rot.y, rot.z, rot.w);
		transform.setOrigin(ammoVec1);
		transform.setRotation(ammoQuat);
	}

	syncEntityToBody() {
		const body = this._body;

		if (body) {
			this._getEntityTransform(ammoTransform);

			body.setWorldTransform(ammoTransform);

			if (this._type === BODYTYPE_KINEMATIC) {
				const motionState = body.getMotionState();

				if (motionState) {
					motionState.setWorldTransform(ammoTransform);
				}
			}

			body.activate();
		}
	}

	_updateDynamic() {
		const body = this._body;

		if (body.isActive()) {
			const motionState = body.getMotionState();

			if (motionState) {
				motionState.getWorldTransform(ammoTransform);
				const p = ammoTransform.getOrigin();
				const q = ammoTransform.getRotation();
				this.entity.setPosition(p.x(), p.y(), p.z());
				this.entity.setRotation(q.x(), q.y(), q.z(), q.w());
			}
		}
	}

	_updateKinematic() {
		const motionState = this._body.getMotionState();

		if (motionState) {
			this._getEntityTransform(ammoTransform);

			motionState.setWorldTransform(ammoTransform);
		}
	}

	teleport() {
		if (arguments.length < 3) {
			if (arguments[0]) {
				this.entity.setPosition(arguments[0]);
			}

			if (arguments[1]) {
				if (arguments[1] instanceof Quat) {
					this.entity.setRotation(arguments[1]);
				} else {
					this.entity.setEulerAngles(arguments[1]);
				}
			}
		} else {
			if (arguments.length === 6) {
				this.entity.setEulerAngles(arguments[3], arguments[4], arguments[5]);
			}

			this.entity.setPosition(arguments[0], arguments[1], arguments[2]);
		}

		this.syncEntityToBody();
	}

	onEnable() {
		if (!this._body) {
			this.createBody();
		}

		this.enableSimulation();
	}

	onDisable() {
		this.disableSimulation();
	}

}

class RigidBodyComponentData {
	constructor() {
		this.enabled = true;
	}

}

let ammoRayStart, ammoRayEnd;

class RaycastResult {
	constructor(entity, point, normal) {
		this.entity = entity;
		this.point = point;
		this.normal = normal;
	}

}

class SingleContactResult {
	constructor(a, b, contactPoint) {
		if (arguments.length === 0) {
			this.a = null;
			this.b = null;
			this.impulse = 0;
			this.localPointA = new Vec3();
			this.localPointB = new Vec3();
			this.pointA = new Vec3();
			this.pointB = new Vec3();
			this.normal = new Vec3();
		} else {
			this.a = a;
			this.b = b;
			this.impulse = contactPoint.impulse;
			this.localPointA = contactPoint.localPoint;
			this.localPointB = contactPoint.localPointOther;
			this.pointA = contactPoint.point;
			this.pointB = contactPoint.pointOther;
			this.normal = contactPoint.normal;
		}
	}

}

class ContactPoint {
	constructor(localPoint = new Vec3(), localPointOther = new Vec3(), point = new Vec3(), pointOther = new Vec3(), normal = new Vec3(), impulse = 0) {
		this.localPoint = localPoint;
		this.localPointOther = localPointOther;
		this.point = point;
		this.pointOther = pointOther;
		this.normal = normal;
		this.impulse = impulse;
	}

}

class ContactResult {
	constructor(other, contacts) {
		this.other = other;
		this.contacts = contacts;
	}

}

const _schema$7 = ['enabled'];

class RigidBodyComponentSystem extends ComponentSystem {
	constructor(app) {
		super(app);
		this.maxSubSteps = 10;
		this.fixedTimeStep = 1 / 60;
		this.gravity = new Vec3(0, -9.81, 0);
		this._dynamic = [];
		this._kinematic = [];
		this._triggers = [];
		this._compounds = [];
		this.id = 'rigidbody';
		this._stats = app.stats.frame;
		this.ComponentType = RigidBodyComponent;
		this.DataType = RigidBodyComponentData;
		this.contactPointPool = null;
		this.contactResultPool = null;
		this.singleContactResultPool = null;
		this.schema = _schema$7;
		this.collisions = {};
		this.frameCollisions = {};
		this.on('beforeremove', this.onBeforeRemove, this);
		this.on('remove', this.onRemove, this);
	}

	onLibraryLoaded() {
		if (typeof Ammo !== 'undefined') {
			this.collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
			this.dispatcher = new Ammo.btCollisionDispatcher(this.collisionConfiguration);
			this.overlappingPairCache = new Ammo.btDbvtBroadphase();
			this.solver = new Ammo.btSequentialImpulseConstraintSolver();
			this.dynamicsWorld = new Ammo.btDiscreteDynamicsWorld(this.dispatcher, this.overlappingPairCache, this.solver, this.collisionConfiguration);

			if (this.dynamicsWorld.setInternalTickCallback) {
				const checkForCollisionsPointer = Ammo.addFunction(this._checkForCollisions.bind(this), 'vif');
				this.dynamicsWorld.setInternalTickCallback(checkForCollisionsPointer);
			}

			ammoRayStart = new Ammo.btVector3();
			ammoRayEnd = new Ammo.btVector3();
			RigidBodyComponent.onLibraryLoaded();
			this.contactPointPool = new ObjectPool(ContactPoint, 1);
			this.contactResultPool = new ObjectPool(ContactResult, 1);
			this.singleContactResultPool = new ObjectPool(SingleContactResult, 1);
			this.app.systems.on('update', this.onUpdate, this);
		} else {
			this.app.systems.off('update', this.onUpdate, this);
		}
	}

	initializeComponentData(component, data, properties) {
		const props = ['mass', 'linearDamping', 'angularDamping', 'linearFactor', 'angularFactor', 'friction', 'rollingFriction', 'restitution', 'type', 'group', 'mask'];

		for (const property of props) {
			if (data.hasOwnProperty(property)) {
				const value = data[property];

				if (Array.isArray(value)) {
					component[property] = new Vec3(value[0], value[1], value[2]);
				} else {
					component[property] = value;
				}
			}
		}

		super.initializeComponentData(component, data, ['enabled']);
	}

	cloneComponent(entity, clone) {
		const rigidbody = entity.rigidbody;
		const data = {
			enabled: rigidbody.enabled,
			mass: rigidbody.mass,
			linearDamping: rigidbody.linearDamping,
			angularDamping: rigidbody.angularDamping,
			linearFactor: [rigidbody.linearFactor.x, rigidbody.linearFactor.y, rigidbody.linearFactor.z],
			angularFactor: [rigidbody.angularFactor.x, rigidbody.angularFactor.y, rigidbody.angularFactor.z],
			friction: rigidbody.friction,
			rollingFriction: rigidbody.rollingFriction,
			restitution: rigidbody.restitution,
			type: rigidbody.type,
			group: rigidbody.group,
			mask: rigidbody.mask
		};
		return this.addComponent(clone, data);
	}

	onBeforeRemove(entity, component) {
		if (component.enabled) {
			component.enabled = false;
		}
	}

	onRemove(entity, component) {
		const body = component.body;

		if (body) {
			this.removeBody(body);
			this.destroyBody(body);
			component.body = null;
		}
	}

	addBody(body, group, mask) {
		if (group !== undefined && mask !== undefined) {
			this.dynamicsWorld.addRigidBody(body, group, mask);
		} else {
			this.dynamicsWorld.addRigidBody(body);
		}
	}

	removeBody(body) {
		this.dynamicsWorld.removeRigidBody(body);
	}

	createBody(mass, shape, transform) {
		const localInertia = new Ammo.btVector3(0, 0, 0);

		if (mass !== 0) {
			shape.calculateLocalInertia(mass, localInertia);
		}

		const motionState = new Ammo.btDefaultMotionState(transform);
		const bodyInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);
		const body = new Ammo.btRigidBody(bodyInfo);
		Ammo.destroy(bodyInfo);
		Ammo.destroy(localInertia);
		return body;
	}

	destroyBody(body) {
		const motionState = body.getMotionState();

		if (motionState) {
			Ammo.destroy(motionState);
		}

		Ammo.destroy(body);
	}

	raycastFirst(start, end) {
		let result = null;
		ammoRayStart.setValue(start.x, start.y, start.z);
		ammoRayEnd.setValue(end.x, end.y, end.z);
		const rayCallback = new Ammo.ClosestRayResultCallback(ammoRayStart, ammoRayEnd);
		this.dynamicsWorld.rayTest(ammoRayStart, ammoRayEnd, rayCallback);

		if (rayCallback.hasHit()) {
			const collisionObj = rayCallback.get_m_collisionObject();
			const body = Ammo.castObject(collisionObj, Ammo.btRigidBody);

			if (body) {
				const point = rayCallback.get_m_hitPointWorld();
				const normal = rayCallback.get_m_hitNormalWorld();
				result = new RaycastResult(body.entity, new Vec3(point.x(), point.y(), point.z()), new Vec3(normal.x(), normal.y(), normal.z()));

				if (arguments.length > 2) {
					const callback = arguments[2];
					callback(result);
				}
			}
		}

		Ammo.destroy(rayCallback);
		return result;
	}

	raycastAll(start, end) {
		const results = [];
		ammoRayStart.setValue(start.x, start.y, start.z);
		ammoRayEnd.setValue(end.x, end.y, end.z);
		const rayCallback = new Ammo.AllHitsRayResultCallback(ammoRayStart, ammoRayEnd);
		this.dynamicsWorld.rayTest(ammoRayStart, ammoRayEnd, rayCallback);

		if (rayCallback.hasHit()) {
			const collisionObjs = rayCallback.get_m_collisionObjects();
			const points = rayCallback.get_m_hitPointWorld();
			const normals = rayCallback.get_m_hitNormalWorld();
			const numHits = collisionObjs.size();

			for (let i = 0; i < numHits; i++) {
				const body = Ammo.castObject(collisionObjs.at(i), Ammo.btRigidBody);

				if (body) {
					const point = points.at(i);
					const normal = normals.at(i);
					const result = new RaycastResult(body.entity, new Vec3(point.x(), point.y(), point.z()), new Vec3(normal.x(), normal.y(), normal.z()));
					results.push(result);
				}
			}
		}

		Ammo.destroy(rayCallback);
		return results;
	}

	_storeCollision(entity, other) {
		let isNewCollision = false;
		const guid = entity.getGuid();
		this.collisions[guid] = this.collisions[guid] || {
			others: [],
			entity: entity
		};

		if (this.collisions[guid].others.indexOf(other) < 0) {
			this.collisions[guid].others.push(other);
			isNewCollision = true;
		}

		this.frameCollisions[guid] = this.frameCollisions[guid] || {
			others: [],
			entity: entity
		};
		this.frameCollisions[guid].others.push(other);
		return isNewCollision;
	}

	_createContactPointFromAmmo(contactPoint) {
		const localPointA = contactPoint.get_m_localPointA();
		const localPointB = contactPoint.get_m_localPointB();
		const positionWorldOnA = contactPoint.getPositionWorldOnA();
		const positionWorldOnB = contactPoint.getPositionWorldOnB();
		const normalWorldOnB = contactPoint.get_m_normalWorldOnB();
		const contact = this.contactPointPool.allocate();
		contact.localPoint.set(localPointA.x(), localPointA.y(), localPointA.z());
		contact.localPointOther.set(localPointB.x(), localPointB.y(), localPointB.z());
		contact.point.set(positionWorldOnA.x(), positionWorldOnA.y(), positionWorldOnA.z());
		contact.pointOther.set(positionWorldOnB.x(), positionWorldOnB.y(), positionWorldOnB.z());
		contact.normal.set(normalWorldOnB.x(), normalWorldOnB.y(), normalWorldOnB.z());
		contact.impulse = contactPoint.getAppliedImpulse();
		return contact;
	}

	_createReverseContactPointFromAmmo(contactPoint) {
		const localPointA = contactPoint.get_m_localPointA();
		const localPointB = contactPoint.get_m_localPointB();
		const positionWorldOnA = contactPoint.getPositionWorldOnA();
		const positionWorldOnB = contactPoint.getPositionWorldOnB();
		const normalWorldOnB = contactPoint.get_m_normalWorldOnB();
		const contact = this.contactPointPool.allocate();
		contact.localPointOther.set(localPointA.x(), localPointA.y(), localPointA.z());
		contact.localPoint.set(localPointB.x(), localPointB.y(), localPointB.z());
		contact.pointOther.set(positionWorldOnA.x(), positionWorldOnA.y(), positionWorldOnA.z());
		contact.point.set(positionWorldOnB.x(), positionWorldOnB.y(), positionWorldOnB.z());
		contact.normal.set(normalWorldOnB.x(), normalWorldOnB.y(), normalWorldOnB.z());
		contact.impulse = contactPoint.getAppliedImpulse();
		return contact;
	}

	_createSingleContactResult(a, b, contactPoint) {
		const result = this.singleContactResultPool.allocate();
		result.a = a;
		result.b = b;
		result.localPointA = contactPoint.localPoint;
		result.localPointB = contactPoint.localPointOther;
		result.pointA = contactPoint.point;
		result.pointB = contactPoint.pointOther;
		result.normal = contactPoint.normal;
		result.impulse = contactPoint.impulse;
		return result;
	}

	_createContactResult(other, contacts) {
		const result = this.contactResultPool.allocate();
		result.other = other;
		result.contacts = contacts;
		return result;
	}

	_cleanOldCollisions() {
		for (const guid in this.collisions) {
			if (this.collisions.hasOwnProperty(guid)) {
				const frameCollision = this.frameCollisions[guid];
				const collision = this.collisions[guid];
				const entity = collision.entity;
				const entityCollision = entity.collision;
				const entityRigidbody = entity.rigidbody;
				const others = collision.others;
				const length = others.length;
				let i = length;

				while (i--) {
					const other = others[i];

					if (!frameCollision || frameCollision.others.indexOf(other) < 0) {
						others.splice(i, 1);

						if (entity.trigger) {
							if (entityCollision) {
								entityCollision.fire("triggerleave", other);
							}

							if (other.rigidbody) {
								other.rigidbody.fire('triggerleave', entity);
							}
						} else if (!other.trigger) {
							if (entityRigidbody) {
								entityRigidbody.fire("collisionend", other);
							}

							if (entityCollision) {
								entityCollision.fire("collisionend", other);
							}
						}
					}
				}

				if (others.length === 0) {
					delete this.collisions[guid];
				}
			}
		}
	}

	_hasContactEvent(entity) {
		const c = entity.collision;

		if (c && (c.hasEvent("collisionstart") || c.hasEvent("collisionend") || c.hasEvent("contact"))) {
			return true;
		}

		const r = entity.rigidbody;
		return r && (r.hasEvent("collisionstart") || r.hasEvent("collisionend") || r.hasEvent("contact"));
	}

	_checkForCollisions(world, timeStep) {
		const dynamicsWorld = Ammo.wrapPointer(world, Ammo.btDynamicsWorld);
		const dispatcher = dynamicsWorld.getDispatcher();
		const numManifolds = dispatcher.getNumManifolds();
		this.frameCollisions = {};

		for (let i = 0; i < numManifolds; i++) {
			const manifold = dispatcher.getManifoldByIndexInternal(i);
			const body0 = manifold.getBody0();
			const body1 = manifold.getBody1();
			const wb0 = Ammo.castObject(body0, Ammo.btRigidBody);
			const wb1 = Ammo.castObject(body1, Ammo.btRigidBody);
			const e0 = wb0.entity;
			const e1 = wb1.entity;

			if (!e0 || !e1) {
				continue;
			}

			const flags0 = wb0.getCollisionFlags();
			const flags1 = wb1.getCollisionFlags();
			const numContacts = manifold.getNumContacts();
			const forwardContacts = [];
			const reverseContacts = [];
			let newCollision;

			if (numContacts > 0) {
				if (flags0 & BODYFLAG_NORESPONSE_OBJECT || flags1 & BODYFLAG_NORESPONSE_OBJECT) {
					const e0Events = e0.collision && (e0.collision.hasEvent("triggerenter") || e0.collision.hasEvent("triggerleave"));
					const e1Events = e1.collision && (e1.collision.hasEvent("triggerenter") || e1.collision.hasEvent("triggerleave"));
					const e0BodyEvents = e0.rigidbody && (e0.rigidbody.hasEvent("triggerenter") || e0.rigidbody.hasEvent("triggerleave"));
					const e1BodyEvents = e1.rigidbody && (e1.rigidbody.hasEvent("triggerenter") || e1.rigidbody.hasEvent("triggerleave"));

					if (e0Events) {
						newCollision = this._storeCollision(e0, e1);

						if (newCollision && !(flags1 & BODYFLAG_NORESPONSE_OBJECT)) {
							e0.collision.fire("triggerenter", e1);
						}
					}

					if (e1Events) {
						newCollision = this._storeCollision(e1, e0);

						if (newCollision && !(flags0 & BODYFLAG_NORESPONSE_OBJECT)) {
							e1.collision.fire("triggerenter", e0);
						}
					}

					if (e0BodyEvents) {
						if (!newCollision) {
							newCollision = this._storeCollision(e1, e0);
						}

						if (newCollision) {
							e0.rigidbody.fire("triggerenter", e1);
						}
					}

					if (e1BodyEvents) {
						if (!newCollision) {
							newCollision = this._storeCollision(e0, e1);
						}

						if (newCollision) {
							e1.rigidbody.fire("triggerenter", e0);
						}
					}
				} else {
					const e0Events = this._hasContactEvent(e0);

					const e1Events = this._hasContactEvent(e1);

					const globalEvents = this.hasEvent("contact");

					if (globalEvents || e0Events || e1Events) {
						for (let j = 0; j < numContacts; j++) {
							const btContactPoint = manifold.getContactPoint(j);

							const contactPoint = this._createContactPointFromAmmo(btContactPoint);

							if (e0Events || e1Events) {
								forwardContacts.push(contactPoint);

								const reverseContactPoint = this._createReverseContactPointFromAmmo(btContactPoint);

								reverseContacts.push(reverseContactPoint);
							}

							if (globalEvents) {
								const result = this._createSingleContactResult(e0, e1, contactPoint);

								this.fire("contact", result);
							}
						}

						if (e0Events) {
							const forwardResult = this._createContactResult(e1, forwardContacts);

							newCollision = this._storeCollision(e0, e1);

							if (e0.collision) {
								e0.collision.fire("contact", forwardResult);

								if (newCollision) {
									e0.collision.fire("collisionstart", forwardResult);
								}
							}

							if (e0.rigidbody) {
								e0.rigidbody.fire("contact", forwardResult);

								if (newCollision) {
									e0.rigidbody.fire("collisionstart", forwardResult);
								}
							}
						}

						if (e1Events) {
							const reverseResult = this._createContactResult(e0, reverseContacts);

							newCollision = this._storeCollision(e1, e0);

							if (e1.collision) {
								e1.collision.fire("contact", reverseResult);

								if (newCollision) {
									e1.collision.fire("collisionstart", reverseResult);
								}
							}

							if (e1.rigidbody) {
								e1.rigidbody.fire("contact", reverseResult);

								if (newCollision) {
									e1.rigidbody.fire("collisionstart", reverseResult);
								}
							}
						}
					}
				}
			}
		}

		this._cleanOldCollisions();

		this.contactPointPool.freeAll();
		this.contactResultPool.freeAll();
		this.singleContactResultPool.freeAll();
	}

	onUpdate(dt) {
		let i, len;
		const gravity = this.dynamicsWorld.getGravity();

		if (gravity.x() !== this.gravity.x || gravity.y() !== this.gravity.y || gravity.z() !== this.gravity.z) {
			gravity.setValue(this.gravity.x, this.gravity.y, this.gravity.z);
			this.dynamicsWorld.setGravity(gravity);
		}

		const triggers = this._triggers;

		for (i = 0, len = triggers.length; i < len; i++) {
			triggers[i].updateTransform();
		}

		const compounds = this._compounds;

		for (i = 0, len = compounds.length; i < len; i++) {
			compounds[i]._updateCompound();
		}

		const kinematic = this._kinematic;

		for (i = 0, len = kinematic.length; i < len; i++) {
			kinematic[i]._updateKinematic();
		}

		this.dynamicsWorld.stepSimulation(dt, this.maxSubSteps, this.fixedTimeStep);
		const dynamic = this._dynamic;

		for (i = 0, len = dynamic.length; i < len; i++) {
			dynamic[i]._updateDynamic();
		}

		if (!this.dynamicsWorld.setInternalTickCallback) this._checkForCollisions(Ammo.getPointer(this.dynamicsWorld), dt);
	}

	destroy() {
		super.destroy();
		this.app.systems.off('update', this.onUpdate, this);

		if (typeof Ammo !== 'undefined') {
			Ammo.destroy(this.dynamicsWorld);
			Ammo.destroy(this.solver);
			Ammo.destroy(this.overlappingPairCache);
			Ammo.destroy(this.dispatcher);
			Ammo.destroy(this.collisionConfiguration);
			this.dynamicsWorld = null;
			this.solver = null;
			this.overlappingPairCache = null;
			this.dispatcher = null;
			this.collisionConfiguration = null;
		}
	}

}

Component._buildAccessors(RigidBodyComponent.prototype, _schema$7);

const SCALEMODE_NONE = "none";
const SCALEMODE_BLEND = "blend";

const _transform = new Mat4();

class ScreenComponent extends Component {
	constructor(system, entity) {
		super(system, entity);
		this._resolution = new Vec2(640, 320);
		this._referenceResolution = new Vec2(640, 320);
		this._scaleMode = SCALEMODE_NONE;
		this.scale = 1;
		this._scaleBlend = 0.5;
		this._priority = 0;
		this._screenSpace = false;
		this.cull = this._screenSpace;
		this._screenMatrix = new Mat4();
		this._elements = new Set();
		system.app.graphicsDevice.on("resizecanvas", this._onResize, this);
	}

	syncDrawOrder() {
		this.system.queueDrawOrderSync(this.entity.getGuid(), this._processDrawOrderSync, this);
	}

	_recurseDrawOrderSync(e, i) {
		if (!(e instanceof Entity)) {
			return i;
		}

		if (e.element) {
			const prevDrawOrder = e.element.drawOrder;
			e.element.drawOrder = i++;

			if (e.element._batchGroupId >= 0 && prevDrawOrder !== e.element.drawOrder) {
				this.system.app.batcher.markGroupDirty(e.element._batchGroupId);
			}
		}

		if (e.particlesystem) {
			e.particlesystem.drawOrder = i++;
		}

		const children = e.children;

		for (let j = 0; j < children.length; j++) {
			i = this._recurseDrawOrderSync(children[j], i);
		}

		return i;
	}

	_processDrawOrderSync() {
		const i = 1;

		this._recurseDrawOrderSync(this.entity, i);

		this.fire('syncdraworder');
	}

	_calcProjectionMatrix() {
		const w = this._resolution.x / this.scale;
		const h = this._resolution.y / this.scale;
		const left = 0;
		const right = w;
		const bottom = -h;
		const top = 0;
		const near = 1;
		const far = -1;

		this._screenMatrix.setOrtho(left, right, bottom, top, near, far);

		if (!this._screenSpace) {
			_transform.setScale(0.5 * w, 0.5 * h, 1);

			this._screenMatrix.mul2(_transform, this._screenMatrix);
		}
	}

	_updateScale() {
		this.scale = this._calcScale(this._resolution, this.referenceResolution);
	}

	_calcScale(resolution, referenceResolution) {
		const lx = Math.log2(resolution.x / referenceResolution.x);
		const ly = Math.log2(resolution.y / referenceResolution.y);
		return Math.pow(2, lx * (1 - this._scaleBlend) + ly * this._scaleBlend);
	}

	_onResize(width, height) {
		if (this._screenSpace) {
			this._resolution.set(width, height);

			this.resolution = this._resolution;
		}
	}

	_bindElement(element) {
		this._elements.add(element);
	}

	_unbindElement(element) {
		this._elements.delete(element);
	}

	onRemove() {
		this.system.app.graphicsDevice.off("resizecanvas", this._onResize, this);
		this.fire('remove');

		this._elements.forEach(element => element._onScreenRemove());

		this._elements.clear();

		this.off();
	}

	set resolution(value) {
		if (!this._screenSpace) {
			this._resolution.set(value.x, value.y);
		} else {
			this._resolution.set(this.system.app.graphicsDevice.width, this.system.app.graphicsDevice.height);
		}

		this._updateScale();

		this._calcProjectionMatrix();

		if (!this.entity._dirtyLocal) this.entity._dirtifyLocal();
		this.fire("set:resolution", this._resolution);

		this._elements.forEach(element => element._onScreenResize(this._resolution));
	}

	get resolution() {
		return this._resolution;
	}

	set referenceResolution(value) {
		this._referenceResolution.set(value.x, value.y);

		this._updateScale();

		this._calcProjectionMatrix();

		if (!this.entity._dirtyLocal) this.entity._dirtifyLocal();
		this.fire("set:referenceresolution", this._resolution);

		this._elements.forEach(element => element._onScreenResize(this._resolution));
	}

	get referenceResolution() {
		if (this._scaleMode === SCALEMODE_NONE) {
			return this._resolution;
		}

		return this._referenceResolution;
	}

	set screenSpace(value) {
		this._screenSpace = value;

		if (this._screenSpace) {
			this._resolution.set(this.system.app.graphicsDevice.width, this.system.app.graphicsDevice.height);
		}

		this.resolution = this._resolution;
		if (!this.entity._dirtyLocal) this.entity._dirtifyLocal();
		this.fire('set:screenspace', this._screenSpace);

		this._elements.forEach(element => element._onScreenSpaceChange());
	}

	get screenSpace() {
		return this._screenSpace;
	}

	set scaleMode(value) {
		if (value !== SCALEMODE_NONE && value !== SCALEMODE_BLEND) {
			value = SCALEMODE_NONE;
		}

		if (!this._screenSpace && value !== SCALEMODE_NONE) {
			value = SCALEMODE_NONE;
		}

		this._scaleMode = value;
		this.resolution = this._resolution;
		this.fire("set:scalemode", this._scaleMode);
	}

	get scaleMode() {
		return this._scaleMode;
	}

	set scaleBlend(value) {
		this._scaleBlend = value;

		this._updateScale();

		this._calcProjectionMatrix();

		if (!this.entity._dirtyLocal) this.entity._dirtifyLocal();
		this.fire("set:scaleblend", this._scaleBlend);

		this._elements.forEach(element => element._onScreenResize(this._resolution));
	}

	get scaleBlend() {
		return this._scaleBlend;
	}

	set priority(value) {
		if (value > 0xFF) {
			value = 0xFF;
		}

		this._priority = value;
	}

	get priority() {
		return this._priority;
	}

}

class ScreenComponentData {
	constructor() {
		this.enabled = true;
	}

}

const _schema$6 = ['enabled'];

class ScreenComponentSystem extends ComponentSystem {
	constructor(app) {
		super(app);
		this.id = 'screen';
		this.ComponentType = ScreenComponent;
		this.DataType = ScreenComponentData;
		this.schema = _schema$6;
		this.windowResolution = new Vec2();
		this._drawOrderSyncQueue = new IndexedList();
		this.app.graphicsDevice.on("resizecanvas", this._onResize, this);
		this.app.systems.on('update', this._onUpdate, this);
		this.on('beforeremove', this.onRemoveComponent, this);
	}

	initializeComponentData(component, data, properties) {
		if (data.priority !== undefined) component.priority = data.priority;
		if (data.screenSpace !== undefined) component.screenSpace = data.screenSpace;
		component.cull = component.screenSpace;
		if (data.scaleMode !== undefined) component.scaleMode = data.scaleMode;
		if (data.scaleBlend !== undefined) component.scaleBlend = data.scaleBlend;

		if (data.resolution !== undefined) {
			if (data.resolution instanceof Vec2) {
				component._resolution.copy(data.resolution);
			} else {
				component._resolution.set(data.resolution[0], data.resolution[1]);
			}

			component.resolution = component._resolution;
		}

		if (data.referenceResolution !== undefined) {
			if (data.referenceResolution instanceof Vec2) {
				component._referenceResolution.copy(data.referenceResolution);
			} else {
				component._referenceResolution.set(data.referenceResolution[0], data.referenceResolution[1]);
			}

			component.referenceResolution = component._referenceResolution;
		}

		component.syncDrawOrder();
		super.initializeComponentData(component, data, properties);
	}

	destroy() {
		super.destroy();
		this.app.graphicsDevice.off("resizecanvas", this._onResize, this);
		this.app.systems.off('update', this._onUpdate, this);
	}

	_onUpdate(dt) {
		const components = this.store;

		for (const id in components) {
			if (components[id].entity.screen.update) components[id].entity.screen.update(dt);
		}
	}

	_onResize(width, height) {
		this.windowResolution.x = width;
		this.windowResolution.y = height;
	}

	cloneComponent(entity, clone) {
		const screen = entity.screen;
		return this.addComponent(clone, {
			enabled: screen.enabled,
			screenSpace: screen.screenSpace,
			scaleMode: screen.scaleMode,
			resolution: screen.resolution.clone(),
			referenceResolution: screen.referenceResolution.clone()
		});
	}

	onRemoveComponent(entity, component) {
		component.onRemove();
	}

	processDrawOrderSyncQueue() {
		const list = this._drawOrderSyncQueue.list();

		for (let i = 0; i < list.length; i++) {
			const item = list[i];
			item.callback.call(item.scope);
		}

		this._drawOrderSyncQueue.clear();
	}

	queueDrawOrderSync(id, fn, scope) {
		if (!this._drawOrderSyncQueue.list().length) {
			this.app.once('prerender', this.processDrawOrderSyncQueue, this);
		}

		if (!this._drawOrderSyncQueue.has(id)) {
			this._drawOrderSyncQueue.push(id, {
				callback: fn,
				scope: scope
			});
		}
	}

}

Component._buildAccessors(ScreenComponent.prototype, _schema$6);

class ScriptComponentData {
	constructor() {
		this.enabled = true;
	}

}

const METHOD_INITIALIZE_ATTRIBUTES = '_onInitializeAttributes';
const METHOD_INITIALIZE = '_onInitialize';
const METHOD_POST_INITIALIZE = '_onPostInitialize';
const METHOD_UPDATE = '_onUpdate';
const METHOD_POST_UPDATE = '_onPostUpdate';
let executionOrderCounter = 0;

class ScriptComponentSystem extends ComponentSystem {
	constructor(app) {
		super(app);
		this.id = 'script';
		this.ComponentType = ScriptComponent;
		this.DataType = ScriptComponentData;
		this._components = new SortedLoopArray({
			sortBy: '_executionOrder'
		});
		this._enabledComponents = new SortedLoopArray({
			sortBy: '_executionOrder'
		});
		this.preloading = true;
		this.on('beforeremove', this._onBeforeRemove, this);
		this.app.systems.on('initialize', this._onInitialize, this);
		this.app.systems.on('postInitialize', this._onPostInitialize, this);
		this.app.systems.on('update', this._onUpdate, this);
		this.app.systems.on('postUpdate', this._onPostUpdate, this);
	}

	initializeComponentData(component, data) {
		component._executionOrder = executionOrderCounter++;

		this._components.append(component);

		if (executionOrderCounter > Number.MAX_SAFE_INTEGER) {
			this._resetExecutionOrder();
		}

		component.enabled = data.hasOwnProperty('enabled') ? !!data.enabled : true;

		if (component.enabled && component.entity.enabled) {
			this._enabledComponents.append(component);
		}

		if (data.hasOwnProperty('order') && data.hasOwnProperty('scripts')) {
			component._scriptsData = data.scripts;

			for (let i = 0; i < data.order.length; i++) {
				component.create(data.order[i], {
					enabled: data.scripts[data.order[i]].enabled,
					attributes: data.scripts[data.order[i]].attributes,
					preloading: this.preloading
				});
			}
		}
	}

	cloneComponent(entity, clone) {
		const order = [];
		const scripts = {};

		for (let i = 0; i < entity.script._scripts.length; i++) {
			const scriptInstance = entity.script._scripts[i];
			const scriptName = scriptInstance.__scriptType.__name;
			order.push(scriptName);
			const attributes = {};

			for (const key in scriptInstance.__attributes) attributes[key] = scriptInstance.__attributes[key];

			scripts[scriptName] = {
				enabled: scriptInstance._enabled,
				attributes: attributes
			};
		}

		for (const key in entity.script._scriptsIndex) {
			if (key.awaiting) {
				order.splice(key.ind, 0, key);
			}
		}

		const data = {
			enabled: entity.script.enabled,
			order: order,
			scripts: scripts
		};
		return this.addComponent(clone, data);
	}

	_resetExecutionOrder() {
		executionOrderCounter = 0;

		for (let i = 0, len = this._components.length; i < len; i++) {
			this._components.items[i]._executionOrder = executionOrderCounter++;
		}
	}

	_callComponentMethod(components, name, dt) {
		for (components.loopIndex = 0; components.loopIndex < components.length; components.loopIndex++) {
			components.items[components.loopIndex][name](dt);
		}
	}

	_onInitialize() {
		this.preloading = false;

		this._callComponentMethod(this._components, METHOD_INITIALIZE_ATTRIBUTES);

		this._callComponentMethod(this._enabledComponents, METHOD_INITIALIZE);
	}

	_onPostInitialize() {
		this._callComponentMethod(this._enabledComponents, METHOD_POST_INITIALIZE);
	}

	_onUpdate(dt) {
		this._callComponentMethod(this._enabledComponents, METHOD_UPDATE, dt);
	}

	_onPostUpdate(dt) {
		this._callComponentMethod(this._enabledComponents, METHOD_POST_UPDATE, dt);
	}

	_addComponentToEnabled(component) {
		this._enabledComponents.insert(component);
	}

	_removeComponentFromEnabled(component) {
		this._enabledComponents.remove(component);
	}

	_onBeforeRemove(entity, component) {
		const ind = this._components.items.indexOf(component);

		if (ind >= 0) {
			component._onBeforeRemove();
		}

		this._removeComponentFromEnabled(component);

		this._components.remove(component);
	}

	destroy() {
		super.destroy();
		this.app.systems.off('initialize', this._onInitialize, this);
		this.app.systems.off('postInitialize', this._onPostInitialize, this);
		this.app.systems.off('update', this._onUpdate, this);
		this.app.systems.off('postUpdate', this._onPostUpdate, this);
	}

}

class ScriptLegacyComponent extends Component {
	constructor(system, entity) {
		super(system, entity);
		this.on("set_scripts", this.onSetScripts, this);
	}

	send(name, functionName) {
		const args = Array.prototype.slice.call(arguments, 2);
		const instances = this.entity.script.instances;
		let fn;

		if (instances && instances[name]) {
			fn = instances[name].instance[functionName];

			if (fn) {
				return fn.apply(instances[name].instance, args);
			}
		}
	}

	onEnable() {
		if (this.data.areScriptsLoaded && !this.system.preloading) {
			if (!this.data.initialized) {
				this.system._initializeScriptComponent(this);
			} else {
				this.system._enableScriptComponent(this);
			}

			if (!this.data.postInitialized) {
				this.system._postInitializeScriptComponent(this);
			}
		}
	}

	onDisable() {
		this.system._disableScriptComponent(this);
	}

	onSetScripts(name, oldValue, newValue) {
		if (!this.system._inTools || this.runInTools) {
			if (this._updateScriptAttributes(oldValue, newValue)) {
				return;
			}

			if (this.enabled) {
				this.system._disableScriptComponent(this);
			}

			this.system._destroyScriptComponent(this);

			this.data.areScriptsLoaded = false;
			const scripts = newValue;
			const urls = scripts.map(function (s) {
				return s.url;
			});

			if (this._loadFromCache(urls)) {
				return;
			}

			this._loadScripts(urls);
		}
	}

	_updateScriptAttributes(oldValue, newValue) {
		let onlyUpdateAttributes = true;

		if (oldValue.length !== newValue.length) {
			onlyUpdateAttributes = false;
		} else {
			for (let i = 0, len = newValue.length; i < len; i++) {
				if (oldValue[i].url !== newValue[i].url) {
					onlyUpdateAttributes = false;
					break;
				}
			}
		}

		if (onlyUpdateAttributes) {
			for (const key in this.instances) {
				if (this.instances.hasOwnProperty(key)) {
					this.system._updateAccessors(this.entity, this.instances[key]);
				}
			}
		}

		return onlyUpdateAttributes;
	}

	_loadFromCache(urls) {
		const cached = [];
		const prefix = this.system.app._scriptPrefix || "";
		const regex = /^http(s)?:\/\//i;

		for (let i = 0, len = urls.length; i < len; i++) {
			let url = urls[i];

			if (!regex.test(url)) {
				url = path.join(prefix, url);
			}

			const type = this.system.app.loader.getFromCache(url, 'script');

			if (!type) {
				return false;
			}

			cached.push(type);
		}

		for (let i = 0, len = cached.length; i < len; i++) {
			const ScriptType = cached[i];

			if (ScriptType === true) {
				continue;
			}

			if (ScriptType && this.entity.script) {
				if (!this.entity.script.instances[ScriptType._pcScriptName]) {
					const instance = new ScriptType(this.entity);

					this.system._preRegisterInstance(this.entity, urls[i], ScriptType._pcScriptName, instance);
				}
			}
		}

		if (this.data) {
			this.data.areScriptsLoaded = true;
		}

		if (!this.system.preloading) {
			this.system.onInitialize(this.entity);
			this.system.onPostInitialize(this.entity);
		}

		return true;
	}

	_loadScripts(urls) {
		let count = urls.length;
		const prefix = this.system.app._scriptPrefix || "";
		urls.forEach(url => {
			let _url = null;
			let _unprefixed = null;

			if (url.toLowerCase().startsWith("http://") || url.toLowerCase().startsWith("https://")) {
				_unprefixed = url;
				_url = url;
			} else {
				_unprefixed = url;
				_url = path.join(prefix, url);
			}

			this.system.app.loader.load(_url, "script", (err, ScriptType) => {
				count--;

				if (!err) {
					if (ScriptType && this.entity.script) {
						if (!this.entity.script.instances[ScriptType._pcScriptName]) {
							const instance = new ScriptType(this.entity);

							this.system._preRegisterInstance(this.entity, _unprefixed, ScriptType._pcScriptName, instance);
						}
					}
				} else {
					console.error(err);
				}

				if (count === 0) {
					this.data.areScriptsLoaded = true;

					if (!this.system.preloading) {
						this.system.onInitialize(this.entity);
						this.system.onPostInitialize(this.entity);
					}
				}
			});
		});
	}

}

class ScriptLegacyComponentData {
	constructor() {
		this.scripts = [];
		this.enabled = true;
		this.instances = {};
		this._instances = {};
		this.runInTools = false;
		this.attributes = {};
		this.initialized = false;
		this.postInitialized = false;
		this.areScriptsLoaded = false;
	}

}

const _schema$5 = ['enabled', 'scripts', 'instances', 'runInTools'];
const INITIALIZE = "initialize";
const POST_INITIALIZE = "postInitialize";
const UPDATE = "update";
const POST_UPDATE = "postUpdate";
const FIXED_UPDATE = "fixedUpdate";
const TOOLS_UPDATE = "toolsUpdate";
const ON_ENABLE = 'onEnable';
const ON_DISABLE = 'onDisable';

class ScriptLegacyComponentSystem extends ComponentSystem {
	constructor(app) {
		super(app);
		this.id = 'script';
		this.ComponentType = ScriptLegacyComponent;
		this.DataType = ScriptLegacyComponentData;
		this.schema = _schema$5;
		this.preloading = false;
		this.instancesWithUpdate = [];
		this.instancesWithFixedUpdate = [];
		this.instancesWithPostUpdate = [];
		this.instancesWithToolsUpdate = [];
		this.on('beforeremove', this.onBeforeRemove, this);
		this.app.systems.on(INITIALIZE, this.onInitialize, this);
		this.app.systems.on(POST_INITIALIZE, this.onPostInitialize, this);
		this.app.systems.on(UPDATE, this.onUpdate, this);
		this.app.systems.on(FIXED_UPDATE, this.onFixedUpdate, this);
		this.app.systems.on(POST_UPDATE, this.onPostUpdate, this);
		this.app.systems.on(TOOLS_UPDATE, this.onToolsUpdate, this);
	}

	initializeComponentData(component, data, properties) {
		properties = ['runInTools', 'enabled', 'scripts'];

		if (data.scripts && data.scripts.length) {
			data.scripts.forEach(function (script) {
				if (script.attributes && Array.isArray(script.attributes)) {
					const dict = {};

					for (let i = 0; i < script.attributes.length; i++) {
						dict[script.attributes[i].name] = script.attributes[i];
					}

					script.attributes = dict;
				}
			});
		}

		super.initializeComponentData(component, data, properties);
	}

	cloneComponent(entity, clone) {
		const src = this.store[entity.getGuid()];
		const data = {
			runInTools: src.data.runInTools,
			scripts: [],
			enabled: src.data.enabled
		};
		const scripts = src.data.scripts;

		for (let i = 0, len = scripts.length; i < len; i++) {
			const attributes = scripts[i].attributes;

			if (attributes) {
				delete scripts[i].attributes;
			}

			data.scripts.push(extend({}, scripts[i]));

			if (attributes) {
				data.scripts[i].attributes = this._cloneAttributes(attributes);
				scripts[i].attributes = attributes;
			}
		}

		return this.addComponent(clone, data);
	}

	onBeforeRemove(entity, component) {
		if (component.enabled) {
			this._disableScriptComponent(component);
		}

		this._destroyScriptComponent(component);
	}

	onInitialize(root) {
		this._registerInstances(root);

		if (root.enabled) {
			if (root.script && root.script.enabled) {
				this._initializeScriptComponent(root.script);
			}

			const children = root._children;

			for (let i = 0, len = children.length; i < len; i++) {
				if (children[i] instanceof Entity) {
					this.onInitialize(children[i]);
				}
			}
		}
	}

	onPostInitialize(root) {
		if (root.enabled) {
			if (root.script && root.script.enabled) {
				this._postInitializeScriptComponent(root.script);
			}

			const children = root._children;

			for (let i = 0, len = children.length; i < len; i++) {
				if (children[i] instanceof Entity) {
					this.onPostInitialize(children[i]);
				}
			}
		}
	}

	_callInstancesMethod(script, method) {
		const instances = script.data.instances;

		for (const name in instances) {
			if (instances.hasOwnProperty(name)) {
				const instance = instances[name].instance;

				if (instance[method]) {
					instance[method]();
				}
			}
		}
	}

	_initializeScriptComponent(script) {
		this._callInstancesMethod(script, INITIALIZE);

		script.data.initialized = true;

		if (script.enabled && script.entity.enabled) {
			this._enableScriptComponent(script);
		}
	}

	_enableScriptComponent(script) {
		this._callInstancesMethod(script, ON_ENABLE);
	}

	_disableScriptComponent(script) {
		this._callInstancesMethod(script, ON_DISABLE);
	}

	_destroyScriptComponent(script) {
		const instances = script.data.instances;

		for (const name in instances) {
			if (instances.hasOwnProperty(name)) {
				const instance = instances[name].instance;

				if (instance.destroy) {
					instance.destroy();
				}

				if (instance.update) {
					const index = this.instancesWithUpdate.indexOf(instance);

					if (index >= 0) {
						this.instancesWithUpdate.splice(index, 1);
					}
				}

				if (instance.fixedUpdate) {
					const index = this.instancesWithFixedUpdate.indexOf(instance);

					if (index >= 0) {
						this.instancesWithFixedUpdate.splice(index, 1);
					}
				}

				if (instance.postUpdate) {
					const index = this.instancesWithPostUpdate.indexOf(instance);

					if (index >= 0) {
						this.instancesWithPostUpdate.splice(index, 1);
					}
				}

				if (instance.toolsUpdate) {
					const index = this.instancesWithToolsUpdate.indexOf(instance);

					if (index >= 0) {
						this.instancesWithToolsUpdate.splice(index, 1);
					}
				}

				if (script.instances[name].instance === script[name]) {
					delete script[name];
				}

				delete script.instances[name];
			}
		}
	}

	_postInitializeScriptComponent(script) {
		this._callInstancesMethod(script, POST_INITIALIZE);

		script.data.postInitialized = true;
	}

	_updateInstances(method, updateList, dt) {
		for (let i = 0, len = updateList.length; i < len; i++) {
			const item = updateList[i];

			if (item && item.entity && item.entity.enabled && item.entity.script.enabled) {
				item[method](dt);
			}
		}
	}

	onUpdate(dt) {
		this._updateInstances(UPDATE, this.instancesWithUpdate, dt);
	}

	onFixedUpdate(dt) {
		this._updateInstances(FIXED_UPDATE, this.instancesWithFixedUpdate, dt);
	}

	onPostUpdate(dt) {
		this._updateInstances(POST_UPDATE, this.instancesWithPostUpdate, dt);
	}

	onToolsUpdate(dt) {
		this._updateInstances(TOOLS_UPDATE, this.instancesWithToolsUpdate, dt);
	}

	broadcast(name, functionName) {
		const args = Array.prototype.slice.call(arguments, 2);
		const dataStore = this.store;

		for (const id in dataStore) {
			if (dataStore.hasOwnProperty(id)) {
				const data = dataStore[id].data;

				if (data.instances[name]) {
					const fn = data.instances[name].instance[functionName];

					if (fn) {
						fn.apply(data.instances[name].instance, args);
					}
				}
			}
		}
	}

	_preRegisterInstance(entity, url, name, instance) {
		if (entity.script) {
			entity.script.data._instances = entity.script.data._instances || {};

			if (entity.script.data._instances[name]) {
				throw Error(`Script name collision '${name}'. Scripts from '${url}' and '${entity.script.data._instances[name].url}' {${entity.getGuid()}}`);
			}

			entity.script.data._instances[name] = {
				url: url,
				name: name,
				instance: instance
			};
		}
	}

	_registerInstances(entity) {
		if (entity.script) {
			if (entity.script.data._instances) {
				entity.script.instances = entity.script.data._instances;

				for (const instanceName in entity.script.instances) {
					const preRegistered = entity.script.instances[instanceName];
					const instance = preRegistered.instance;
					events.attach(instance);

					if (instance.update) {
						this.instancesWithUpdate.push(instance);
					}

					if (instance.fixedUpdate) {
						this.instancesWithFixedUpdate.push(instance);
					}

					if (instance.postUpdate) {
						this.instancesWithPostUpdate.push(instance);
					}

					if (instance.toolsUpdate) {
						this.instancesWithToolsUpdate.push(instance);
					}

					if (entity.script.scripts) {
						this._createAccessors(entity, preRegistered);
					}

					if (entity.script[instanceName]) {
						throw Error(`Script with name '${instanceName}' is already attached to Script Component`);
					} else {
						entity.script[instanceName] = instance;
					}
				}

				delete entity.script.data._instances;
			}
		}

		const children = entity._children;

		for (let i = 0, len = children.length; i < len; i++) {
			if (children[i] instanceof Entity) {
				this._registerInstances(children[i]);
			}
		}
	}

	_cloneAttributes(attributes) {
		const result = {};

		for (const key in attributes) {
			if (!attributes.hasOwnProperty(key)) continue;

			if (attributes[key].type !== 'entity') {
				result[key] = extend({}, attributes[key]);
			} else {
				const val = attributes[key].value;
				delete attributes[key].value;
				result[key] = extend({}, attributes[key]);
				result[key].value = val;
				attributes[key].value = val;
			}
		}

		return result;
	}

	_createAccessors(entity, instance) {
		const len = entity.script.scripts.length;
		const url = instance.url;

		for (let i = 0; i < len; i++) {
			const script = entity.script.scripts[i];

			if (script.url === url) {
				const attributes = script.attributes;

				if (script.name && attributes) {
					for (const key in attributes) {
						if (attributes.hasOwnProperty(key)) {
							this._createAccessor(attributes[key], instance);
						}
					}

					entity.script.data.attributes[script.name] = this._cloneAttributes(attributes);
				}

				break;
			}
		}
	}

	_createAccessor(attribute, instance) {
		const self = this;
		attribute = {
			name: attribute.name,
			value: attribute.value,
			type: attribute.type
		};

		this._convertAttributeValue(attribute);

		Object.defineProperty(instance.instance, attribute.name, {
			get: function () {
				return attribute.value;
			},
			set: function (value) {
				const oldValue = attribute.value;
				attribute.value = value;

				self._convertAttributeValue(attribute);

				instance.instance.fire("set", attribute.name, oldValue, attribute.value);
			},
			configurable: true
		});
	}

	_updateAccessors(entity, instance) {
		const len = entity.script.scripts.length;
		const url = instance.url;

		for (let i = 0; i < len; i++) {
			const scriptComponent = entity.script;
			const script = scriptComponent.scripts[i];

			if (script.url === url) {
				const name = script.name;
				const attributes = script.attributes;

				if (name) {
					if (attributes) {
						for (const key in attributes) {
							if (attributes.hasOwnProperty(key)) {
								this._createAccessor(attributes[key], instance);
							}
						}
					}

					const previousAttributes = scriptComponent.data.attributes[name];

					if (previousAttributes) {
						for (const key in previousAttributes) {
							const oldAttribute = previousAttributes[key];

							if (!(key in attributes)) {
								delete instance.instance[oldAttribute.name];
							} else {
								if (attributes[key].value !== oldAttribute.value) {
									if (instance.instance.onAttributeChanged) {
										instance.instance.onAttributeChanged(oldAttribute.name, oldAttribute.value, attributes[key].value);
									}
								}
							}
						}
					}

					if (attributes) {
						scriptComponent.data.attributes[name] = this._cloneAttributes(attributes);
					} else {
						delete scriptComponent.data.attributes[name];
					}
				}

				break;
			}
		}
	}

	_convertAttributeValue(attribute) {
		if (attribute.type === 'rgb' || attribute.type === 'rgba') {
			if (Array.isArray(attribute.value)) {
				attribute.value = attribute.value.length === 3 ? new Color(attribute.value[0], attribute.value[1], attribute.value[2]) : new Color(attribute.value[0], attribute.value[1], attribute.value[2], attribute.value[3]);
			}
		} else if (attribute.type === 'vec2') {
			if (Array.isArray(attribute.value)) attribute.value = new Vec2(attribute.value[0], attribute.value[1]);
		} else if (attribute.type === 'vec3' || attribute.type === 'vector') {
			if (Array.isArray(attribute.value)) attribute.value = new Vec3(attribute.value[0], attribute.value[1], attribute.value[2]);
		} else if (attribute.type === 'vec4') {
			if (Array.isArray(attribute.value)) attribute.value = new Vec4(attribute.value[0], attribute.value[1], attribute.value[2], attribute.value[3]);
		} else if (attribute.type === 'entity') {
			if (attribute.value !== null && typeof attribute.value === 'string') attribute.value = this.app.root.findByGuid(attribute.value);
		} else if (attribute.type === 'curve' || attribute.type === 'colorcurve') {
			const curveType = attribute.value.keys[0] instanceof Array ? CurveSet : Curve;
			attribute.value = new curveType(attribute.value.keys);
			attribute.value.type = attribute.value.type;
		}
	}

	destroy() {
		super.destroy();
		this.app.systems.off(INITIALIZE, this.onInitialize, this);
		this.app.systems.off(POST_INITIALIZE, this.onPostInitialize, this);
		this.app.systems.off(UPDATE, this.onUpdate, this);
		this.app.systems.off(FIXED_UPDATE, this.onFixedUpdate, this);
		this.app.systems.off(POST_UPDATE, this.onPostUpdate, this);
		this.app.systems.off(TOOLS_UPDATE, this.onToolsUpdate, this);
	}

}

Component._buildAccessors(ScriptLegacyComponent.prototype, _schema$5);

const _inputScreenPosition = new Vec2();

const _inputWorldPosition = new Vec3();

const _rayOrigin = new Vec3();

const _rayDirection = new Vec3();

const _planeOrigin = new Vec3();

const _planeNormal = new Vec3();

const _entityRotation = new Quat();

const OPPOSITE_AXIS = {
	x: 'y',
	y: 'x'
};

class ElementDragHelper extends EventHandler {
	constructor(element, axis) {
		super();

		if (!element || !(element instanceof ElementComponent)) {
			throw new Error('Element was null or not an ElementComponent');
		}

		if (axis && axis !== 'x' && axis !== 'y') {
			throw new Error('Unrecognized axis: ' + axis);
		}

		this._element = element;
		this._app = element.system.app;
		this._axis = axis || null;
		this._enabled = true;
		this._dragScale = new Vec3();
		this._dragStartMousePosition = new Vec3();
		this._dragStartHandlePosition = new Vec3();
		this._deltaMousePosition = new Vec3();
		this._deltaHandlePosition = new Vec3();
		this._isDragging = false;

		this._toggleLifecycleListeners('on');
	}

	_toggleLifecycleListeners(onOrOff) {
		this._element[onOrOff]('mousedown', this._onMouseDownOrTouchStart, this);

		this._element[onOrOff]('touchstart', this._onMouseDownOrTouchStart, this);
	}

	_toggleDragListeners(onOrOff) {
		const isOn = onOrOff === 'on';
		const addOrRemoveEventListener = isOn ? 'addEventListener' : 'removeEventListener';

		if (this._hasDragListeners && isOn) {
			return;
		}

		if (!this._handleMouseUpOrTouchEnd) {
			this._handleMouseUpOrTouchEnd = this._onMouseUpOrTouchEnd.bind(this);
		}

		if (this._app.mouse) {
			this._app.mouse[onOrOff]('mousemove', this._onMove, this);

			window[addOrRemoveEventListener]('mouseup', this._handleMouseUpOrTouchEnd, false);
		}

		if (platform.touch) {
			this._app.touch[onOrOff]('touchmove', this._onMove, this);

			window[addOrRemoveEventListener]('touchend', this._handleMouseUpOrTouchEnd, false);
			window[addOrRemoveEventListener]('touchcancel', this._handleMouseUpOrTouchEnd, false);
		}

		this._hasDragListeners = isOn;
	}

	_onMouseDownOrTouchStart(event) {
		if (this._element && !this._isDragging && this.enabled) {
			this._dragCamera = event.camera;

			this._calculateDragScale();

			const currentMousePosition = this._screenToLocal(event);

			if (currentMousePosition) {
				this._toggleDragListeners('on');

				this._isDragging = true;

				this._dragStartMousePosition.copy(currentMousePosition);

				this._dragStartHandlePosition.copy(this._element.entity.getLocalPosition());

				this.fire('drag:start');
			}
		}
	}

	_onMouseUpOrTouchEnd() {
		if (this._isDragging) {
			this._isDragging = false;

			this._toggleDragListeners('off');

			this.fire('drag:end');
		}
	}

	_screenToLocal(event) {
		this._determineInputPosition(event);

		this._chooseRayOriginAndDirection();

		_planeOrigin.copy(this._element.entity.getPosition());

		_planeNormal.copy(this._element.entity.forward).mulScalar(-1);

		const denominator = _planeNormal.dot(_rayDirection);

		if (Math.abs(denominator) > 0) {
			const rayOriginToPlaneOrigin = _planeOrigin.sub(_rayOrigin);

			const collisionDistance = rayOriginToPlaneOrigin.dot(_planeNormal) / denominator;

			const position = _rayOrigin.add(_rayDirection.mulScalar(collisionDistance));

			_entityRotation.copy(this._element.entity.getRotation()).invert().transformVector(position, position);

			position.mul(this._dragScale);
			return position;
		}

		return null;
	}

	_determineInputPosition(event) {
		const devicePixelRatio = this._app.graphicsDevice.maxPixelRatio;

		if (typeof event.x !== 'undefined' && typeof event.y !== 'undefined') {
			_inputScreenPosition.x = event.x * devicePixelRatio;
			_inputScreenPosition.y = event.y * devicePixelRatio;
		} else if (event.changedTouches) {
			_inputScreenPosition.x = event.changedTouches[0].x * devicePixelRatio;
			_inputScreenPosition.y = event.changedTouches[0].y * devicePixelRatio;
		} else {
			console.warn('Could not determine position from input event');
		}
	}

	_chooseRayOriginAndDirection() {
		if (this._element.screen && this._element.screen.screen.screenSpace) {
			_rayOrigin.set(_inputScreenPosition.x, -_inputScreenPosition.y, 0);

			_rayDirection.set(0, 0, -1);
		} else {
			_inputWorldPosition.copy(this._dragCamera.screenToWorld(_inputScreenPosition.x, _inputScreenPosition.y, 1));

			_rayOrigin.copy(this._dragCamera.entity.getPosition());

			_rayDirection.copy(_inputWorldPosition).sub(_rayOrigin).normalize();
		}
	}

	_calculateDragScale() {
		let current = this._element.entity.parent;
		const screen = this._element.screen && this._element.screen.screen;
		const isWithin2DScreen = screen && screen.screenSpace;
		const screenScale = isWithin2DScreen ? screen.scale : 1;
		const dragScale = this._dragScale;
		dragScale.set(screenScale, screenScale, screenScale);

		while (current) {
			dragScale.mul(current.getLocalScale());
			current = current.parent;

			if (isWithin2DScreen && current.screen) {
				break;
			}
		}

		dragScale.x = 1 / dragScale.x;
		dragScale.y = 1 / dragScale.y;
		dragScale.z = 1 / dragScale.z;
	}

	_onMove(event) {
		if (this._element && this._isDragging && this.enabled && this._element.enabled && this._element.entity.enabled) {
			const currentMousePosition = this._screenToLocal(event);

			if (this._dragStartMousePosition && currentMousePosition) {
				this._deltaMousePosition.copy(currentMousePosition).sub(this._dragStartMousePosition);

				this._deltaHandlePosition.copy(this._dragStartHandlePosition).add(this._deltaMousePosition);

				if (this._axis) {
					const currentPosition = this._element.entity.getLocalPosition();

					const constrainedAxis = OPPOSITE_AXIS[this._axis];
					this._deltaHandlePosition[constrainedAxis] = currentPosition[constrainedAxis];
				}

				this._element.entity.setLocalPosition(this._deltaHandlePosition);

				this.fire('drag:move', this._deltaHandlePosition);
			}
		}
	}

	destroy() {
		this._toggleLifecycleListeners('off');

		this._toggleDragListeners('off');
	}

	set enabled(value) {
		this._enabled = value;
	}

	get enabled() {
		return this._enabled;
	}

	get isDragging() {
		return this._isDragging;
	}

}

const SCROLL_MODE_CLAMP = 0;
const SCROLL_MODE_BOUNCE = 1;
const SCROLL_MODE_INFINITE = 2;
const SCROLLBAR_VISIBILITY_SHOW_ALWAYS = 0;
const SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED = 1;

const ACTION_MOUSE = 'mouse';
const ACTION_KEYBOARD = 'keyboard';
const ACTION_GAMEPAD = 'gamepad';
const AXIS_MOUSE_X = 'mousex';
const AXIS_MOUSE_Y = 'mousey';
const AXIS_PAD_L_X = 'padlx';
const AXIS_PAD_L_Y = 'padly';
const AXIS_PAD_R_X = 'padrx';
const AXIS_PAD_R_Y = 'padry';
const AXIS_KEY = 'key';
const EVENT_KEYDOWN = 'keydown';
const EVENT_KEYUP = 'keyup';
const EVENT_MOUSEDOWN = "mousedown";
const EVENT_MOUSEMOVE = "mousemove";
const EVENT_MOUSEUP = "mouseup";
const EVENT_MOUSEWHEEL = "mousewheel";
const EVENT_TOUCHSTART = 'touchstart';
const EVENT_TOUCHEND = 'touchend';
const EVENT_TOUCHMOVE = 'touchmove';
const EVENT_TOUCHCANCEL = 'touchcancel';
const EVENT_SELECT = 'select';
const EVENT_SELECTSTART = 'selectstart';
const EVENT_SELECTEND = 'selectend';
const KEY_BACKSPACE = 8;
const KEY_TAB = 9;
const KEY_RETURN = 13;
const KEY_ENTER = 13;
const KEY_SHIFT = 16;
const KEY_CONTROL = 17;
const KEY_ALT = 18;
const KEY_PAUSE = 19;
const KEY_CAPS_LOCK = 20;
const KEY_ESCAPE = 27;
const KEY_SPACE = 32;
const KEY_PAGE_UP = 33;
const KEY_PAGE_DOWN = 34;
const KEY_END = 35;
const KEY_HOME = 36;
const KEY_LEFT = 37;
const KEY_UP = 38;
const KEY_RIGHT = 39;
const KEY_DOWN = 40;
const KEY_PRINT_SCREEN = 44;
const KEY_INSERT = 45;
const KEY_DELETE = 46;
const KEY_0 = 48;
const KEY_1 = 49;
const KEY_2 = 50;
const KEY_3 = 51;
const KEY_4 = 52;
const KEY_5 = 53;
const KEY_6 = 54;
const KEY_7 = 55;
const KEY_8 = 56;
const KEY_9 = 57;
const KEY_SEMICOLON = 59;
const KEY_EQUAL = 61;
const KEY_A = 65;
const KEY_B = 66;
const KEY_C = 67;
const KEY_D = 68;
const KEY_E = 69;
const KEY_F = 70;
const KEY_G = 71;
const KEY_H = 72;
const KEY_I = 73;
const KEY_J = 74;
const KEY_K = 75;
const KEY_L = 76;
const KEY_M = 77;
const KEY_N = 78;
const KEY_O = 79;
const KEY_P = 80;
const KEY_Q = 81;
const KEY_R = 82;
const KEY_S = 83;
const KEY_T = 84;
const KEY_U = 85;
const KEY_V = 86;
const KEY_W = 87;
const KEY_X = 88;
const KEY_Y = 89;
const KEY_Z = 90;
const KEY_WINDOWS = 91;
const KEY_CONTEXT_MENU = 93;
const KEY_NUMPAD_0 = 96;
const KEY_NUMPAD_1 = 97;
const KEY_NUMPAD_2 = 98;
const KEY_NUMPAD_3 = 99;
const KEY_NUMPAD_4 = 100;
const KEY_NUMPAD_5 = 101;
const KEY_NUMPAD_6 = 102;
const KEY_NUMPAD_7 = 103;
const KEY_NUMPAD_8 = 104;
const KEY_NUMPAD_9 = 105;
const KEY_MULTIPLY = 106;
const KEY_ADD = 107;
const KEY_SEPARATOR = 108;
const KEY_SUBTRACT = 109;
const KEY_DECIMAL = 110;
const KEY_DIVIDE = 111;
const KEY_F1 = 112;
const KEY_F2 = 113;
const KEY_F3 = 114;
const KEY_F4 = 115;
const KEY_F5 = 116;
const KEY_F6 = 117;
const KEY_F7 = 118;
const KEY_F8 = 119;
const KEY_F9 = 120;
const KEY_F10 = 121;
const KEY_F11 = 122;
const KEY_F12 = 123;
const KEY_COMMA = 188;
const KEY_PERIOD = 190;
const KEY_SLASH = 191;
const KEY_OPEN_BRACKET = 219;
const KEY_BACK_SLASH = 220;
const KEY_CLOSE_BRACKET = 221;
const KEY_META = 224;
const MOUSEBUTTON_NONE = -1;
const MOUSEBUTTON_LEFT = 0;
const MOUSEBUTTON_MIDDLE = 1;
const MOUSEBUTTON_RIGHT = 2;
const PAD_1 = 0;
const PAD_2 = 1;
const PAD_3 = 2;
const PAD_4 = 3;
const PAD_FACE_1 = 0;
const PAD_FACE_2 = 1;
const PAD_FACE_3 = 2;
const PAD_FACE_4 = 3;
const PAD_L_SHOULDER_1 = 4;
const PAD_R_SHOULDER_1 = 5;
const PAD_L_SHOULDER_2 = 6;
const PAD_R_SHOULDER_2 = 7;
const PAD_SELECT = 8;
const PAD_START = 9;
const PAD_L_STICK_BUTTON = 10;
const PAD_R_STICK_BUTTON = 11;
const PAD_UP = 12;
const PAD_DOWN = 13;
const PAD_LEFT = 14;
const PAD_RIGHT = 15;
const PAD_VENDOR = 16;
const PAD_L_STICK_X = 0;
const PAD_L_STICK_Y = 1;
const PAD_R_STICK_X = 2;
const PAD_R_STICK_Y = 3;

const _tempScrollValue = new Vec2();

class ScrollViewComponent extends Component {
	constructor(system, entity) {
		super(system, entity);
		this._viewportReference = new EntityReference(this, 'viewportEntity', {
			'element#gain': this._onViewportElementGain,
			'element#resize': this._onSetContentOrViewportSize
		});
		this._contentReference = new EntityReference(this, 'contentEntity', {
			'element#gain': this._onContentElementGain,
			'element#lose': this._onContentElementLose,
			'element#resize': this._onSetContentOrViewportSize
		});
		this._scrollbarUpdateFlags = {};
		this._scrollbarReferences = {};
		this._scrollbarReferences[ORIENTATION_HORIZONTAL] = new EntityReference(this, 'horizontalScrollbarEntity', {
			'scrollbar#set:value': this._onSetHorizontalScrollbarValue,
			'scrollbar#gain': this._onHorizontalScrollbarGain
		});
		this._scrollbarReferences[ORIENTATION_VERTICAL] = new EntityReference(this, 'verticalScrollbarEntity', {
			'scrollbar#set:value': this._onSetVerticalScrollbarValue,
			'scrollbar#gain': this._onVerticalScrollbarGain
		});
		this._prevContentSizes = {};
		this._prevContentSizes[ORIENTATION_HORIZONTAL] = null;
		this._prevContentSizes[ORIENTATION_VERTICAL] = null;
		this._scroll = new Vec2();
		this._velocity = new Vec3();
		this._dragStartPosition = new Vec3();
		this._disabledContentInput = false;
		this._disabledContentInputEntities = [];

		this._toggleLifecycleListeners('on', system);

		this._toggleElementListeners('on');
	}

	_toggleLifecycleListeners(onOrOff, system) {
		this[onOrOff]('set_horizontal', this._onSetHorizontalScrollingEnabled, this);
		this[onOrOff]('set_vertical', this._onSetVerticalScrollingEnabled, this);
		system.app.systems.element[onOrOff]('add', this._onElementComponentAdd, this);
		system.app.systems.element[onOrOff]('beforeremove', this._onElementComponentRemove, this);
	}

	_toggleElementListeners(onOrOff) {
		if (this.entity.element) {
			if (onOrOff === 'on' && this._hasElementListeners) {
				return;
			}

			this.entity.element[onOrOff]('resize', this._onSetContentOrViewportSize, this);
			this.entity.element[onOrOff](EVENT_MOUSEWHEEL, this._onMouseWheel, this);
			this._hasElementListeners = onOrOff === 'on';
		}
	}

	_onElementComponentAdd(entity) {
		if (this.entity === entity) {
			this._toggleElementListeners('on');
		}
	}

	_onElementComponentRemove(entity) {
		if (this.entity === entity) {
			this._toggleElementListeners('off');
		}
	}

	_onViewportElementGain() {
		this._syncAll();
	}

	_onContentElementGain() {
		this._destroyDragHelper();

		this._contentDragHelper = new ElementDragHelper(this._contentReference.entity.element);

		this._contentDragHelper.on('drag:start', this._onContentDragStart, this);

		this._contentDragHelper.on('drag:end', this._onContentDragEnd, this);

		this._contentDragHelper.on('drag:move', this._onContentDragMove, this);

		this._prevContentSizes[ORIENTATION_HORIZONTAL] = null;
		this._prevContentSizes[ORIENTATION_VERTICAL] = null;

		this._syncAll();
	}

	_onContentElementLose() {
		this._destroyDragHelper();
	}

	_onContentDragStart() {
		if (this._contentReference.entity && this.enabled && this.entity.enabled) {
			this._dragStartPosition.copy(this._contentReference.entity.getLocalPosition());
		}
	}

	_onContentDragEnd() {
		this._prevContentDragPosition = null;

		this._enableContentInput();
	}

	_onContentDragMove(position) {
		if (this._contentReference.entity && this.enabled && this.entity.enabled) {
			this._wasDragged = true;

			this._setScrollFromContentPosition(position);

			this._setVelocityFromContentPositionDelta(position);

			if (!this._disabledContentInput) {
				const dx = position.x - this._dragStartPosition.x;
				const dy = position.y - this._dragStartPosition.y;

				if (Math.abs(dx) > this.dragThreshold || Math.abs(dy) > this.dragThreshold) {
					this._disableContentInput();
				}
			}
		}
	}

	_onSetContentOrViewportSize() {
		this._syncAll();
	}

	_onSetHorizontalScrollbarValue(scrollValueX) {
		if (!this._scrollbarUpdateFlags[ORIENTATION_HORIZONTAL] && this.enabled && this.entity.enabled) {
			this._onSetScroll(scrollValueX, null);
		}
	}

	_onSetVerticalScrollbarValue(scrollValueY) {
		if (!this._scrollbarUpdateFlags[ORIENTATION_VERTICAL] && this.enabled && this.entity.enabled) {
			this._onSetScroll(null, scrollValueY);
		}
	}

	_onSetHorizontalScrollingEnabled() {
		this._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);
	}

	_onSetVerticalScrollingEnabled() {
		this._syncScrollbarEnabledState(ORIENTATION_VERTICAL);
	}

	_onHorizontalScrollbarGain() {
		this._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);

		this._syncScrollbarPosition(ORIENTATION_HORIZONTAL);
	}

	_onVerticalScrollbarGain() {
		this._syncScrollbarEnabledState(ORIENTATION_VERTICAL);

		this._syncScrollbarPosition(ORIENTATION_VERTICAL);
	}

	_onSetScroll(x, y, resetVelocity) {
		if (resetVelocity !== false) {
			this._velocity.set(0, 0, 0);
		}

		let hasChanged = false;
		hasChanged |= this._updateAxis(x, 'x', ORIENTATION_HORIZONTAL);
		hasChanged |= this._updateAxis(y, 'y', ORIENTATION_VERTICAL);

		if (hasChanged) {
			this.fire('set:scroll', this._scroll);
		}
	}

	_updateAxis(scrollValue, axis, orientation) {
		const hasChanged = scrollValue !== null && Math.abs(scrollValue - this._scroll[axis]) > 1e-5;

		if (hasChanged || this._isDragging() || scrollValue === 0) {
			this._scroll[axis] = this._determineNewScrollValue(scrollValue, axis, orientation);

			this._syncContentPosition(orientation);

			this._syncScrollbarPosition(orientation);
		}

		return hasChanged;
	}

	_determineNewScrollValue(scrollValue, axis, orientation) {
		if (!this._getScrollingEnabled(orientation)) {
			return this._scroll[axis];
		}

		switch (this.scrollMode) {
			case SCROLL_MODE_CLAMP:
				return math.clamp(scrollValue, 0, this._getMaxScrollValue(orientation));

			case SCROLL_MODE_BOUNCE:
				this._setVelocityFromOvershoot(scrollValue, axis, orientation);

				return scrollValue;

			case SCROLL_MODE_INFINITE:
				return scrollValue;

			default:
				console.warn('Unhandled scroll mode:' + this.scrollMode);
				return scrollValue;
		}
	}

	_syncAll() {
		this._syncContentPosition(ORIENTATION_HORIZONTAL);

		this._syncContentPosition(ORIENTATION_VERTICAL);

		this._syncScrollbarPosition(ORIENTATION_HORIZONTAL);

		this._syncScrollbarPosition(ORIENTATION_VERTICAL);

		this._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);

		this._syncScrollbarEnabledState(ORIENTATION_VERTICAL);
	}

	_syncContentPosition(orientation) {
		const axis = this._getAxis(orientation);

		const sign = this._getSign(orientation);

		const contentEntity = this._contentReference.entity;

		if (contentEntity) {
			const prevContentSize = this._prevContentSizes[orientation];

			const currContentSize = this._getContentSize(orientation);

			if (prevContentSize !== null && Math.abs(prevContentSize - currContentSize) > 1e-4) {
				const prevMaxOffset = this._getMaxOffset(orientation, prevContentSize);

				const currMaxOffset = this._getMaxOffset(orientation, currContentSize);

				if (currMaxOffset === 0) {
					this._scroll[axis] = 1;
				} else {
					this._scroll[axis] = math.clamp(this._scroll[axis] * prevMaxOffset / currMaxOffset, 0, 1);
				}
			}

			const offset = this._scroll[axis] * this._getMaxOffset(orientation);

			const contentPosition = contentEntity.getLocalPosition();
			contentPosition[axis] = offset * sign;
			contentEntity.setLocalPosition(contentPosition);
			this._prevContentSizes[orientation] = currContentSize;
		}
	}

	_syncScrollbarPosition(orientation) {
		const axis = this._getAxis(orientation);

		const scrollbarEntity = this._scrollbarReferences[orientation].entity;

		if (scrollbarEntity && scrollbarEntity.scrollbar) {
			this._scrollbarUpdateFlags[orientation] = true;
			scrollbarEntity.scrollbar.value = this._scroll[axis];
			scrollbarEntity.scrollbar.handleSize = this._getScrollbarHandleSize(axis, orientation);
			this._scrollbarUpdateFlags[orientation] = false;
		}
	}

	_syncScrollbarEnabledState(orientation) {
		const entity = this._scrollbarReferences[orientation].entity;

		if (entity) {
			const isScrollingEnabled = this._getScrollingEnabled(orientation);

			const requestedVisibility = this._getScrollbarVisibility(orientation);

			switch (requestedVisibility) {
				case SCROLLBAR_VISIBILITY_SHOW_ALWAYS:
					entity.enabled = isScrollingEnabled;
					return;

				case SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED:
					entity.enabled = isScrollingEnabled && this._contentIsLargerThanViewport(orientation);
					return;

				default:
					console.warn('Unhandled scrollbar visibility:' + requestedVisibility);
					entity.enabled = isScrollingEnabled;
			}
		}
	}

	_contentIsLargerThanViewport(orientation) {
		return this._getContentSize(orientation) > this._getViewportSize(orientation);
	}

	_contentPositionToScrollValue(contentPosition) {
		const maxOffsetH = this._getMaxOffset(ORIENTATION_HORIZONTAL);

		const maxOffsetV = this._getMaxOffset(ORIENTATION_VERTICAL);

		if (maxOffsetH === 0) {
			_tempScrollValue.x = 0;
		} else {
			_tempScrollValue.x = contentPosition.x / maxOffsetH;
		}

		if (maxOffsetV === 0) {
			_tempScrollValue.y = 0;
		} else {
			_tempScrollValue.y = contentPosition.y / -maxOffsetV;
		}

		return _tempScrollValue;
	}

	_getMaxOffset(orientation, contentSize) {
		contentSize = contentSize === undefined ? this._getContentSize(orientation) : contentSize;

		const viewportSize = this._getViewportSize(orientation);

		if (contentSize < viewportSize) {
			return -this._getViewportSize(orientation);
		}

		return viewportSize - contentSize;
	}

	_getMaxScrollValue(orientation) {
		return this._contentIsLargerThanViewport(orientation) ? 1 : 0;
	}

	_getScrollbarHandleSize(axis, orientation) {
		const viewportSize = this._getViewportSize(orientation);

		const contentSize = this._getContentSize(orientation);

		if (Math.abs(contentSize) < 0.001) {
			return 1;
		}

		const handleSize = Math.min(viewportSize / contentSize, 1);

		const overshoot = this._toOvershoot(this._scroll[axis], orientation);

		if (overshoot === 0) {
			return handleSize;
		}

		return handleSize / (1 + Math.abs(overshoot));
	}

	_getViewportSize(orientation) {
		return this._getSize(orientation, this._viewportReference);
	}

	_getContentSize(orientation) {
		return this._getSize(orientation, this._contentReference);
	}

	_getSize(orientation, entityReference) {
		if (entityReference.entity && entityReference.entity.element) {
			return entityReference.entity.element[this._getCalculatedDimension(orientation)];
		}

		return 0;
	}

	_getScrollingEnabled(orientation) {
		if (orientation === ORIENTATION_HORIZONTAL) {
			return this.horizontal;
		} else if (orientation === ORIENTATION_VERTICAL) {
			return this.vertical;
		}

		console.warn('Unrecognized orientation: ' + orientation);
	}

	_getScrollbarVisibility(orientation) {
		if (orientation === ORIENTATION_HORIZONTAL) {
			return this.horizontalScrollbarVisibility;
		} else if (orientation === ORIENTATION_VERTICAL) {
			return this.verticalScrollbarVisibility;
		}

		console.warn('Unrecognized orientation: ' + orientation);
	}

	_getSign(orientation) {
		return orientation === ORIENTATION_HORIZONTAL ? 1 : -1;
	}

	_getAxis(orientation) {
		return orientation === ORIENTATION_HORIZONTAL ? 'x' : 'y';
	}

	_getCalculatedDimension(orientation) {
		return orientation === ORIENTATION_HORIZONTAL ? 'calculatedWidth' : 'calculatedHeight';
	}

	_destroyDragHelper() {
		if (this._contentDragHelper) {
			this._contentDragHelper.destroy();
		}
	}

	onUpdate() {
		if (this._contentReference.entity) {
			this._updateVelocity();

			this._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);

			this._syncScrollbarEnabledState(ORIENTATION_VERTICAL);
		}
	}

	_updateVelocity() {
		if (!this._isDragging()) {
			if (this.scrollMode === SCROLL_MODE_BOUNCE) {
				if (this._hasOvershoot('x', ORIENTATION_HORIZONTAL)) {
					this._setVelocityFromOvershoot(this.scroll.x, 'x', ORIENTATION_HORIZONTAL);
				}

				if (this._hasOvershoot('y', ORIENTATION_VERTICAL)) {
					this._setVelocityFromOvershoot(this.scroll.y, 'y', ORIENTATION_VERTICAL);
				}
			}

			if (Math.abs(this._velocity.x) > 1e-4 || Math.abs(this._velocity.y) > 1e-4) {
				const position = this._contentReference.entity.getLocalPosition();

				position.x += this._velocity.x;
				position.y += this._velocity.y;

				this._contentReference.entity.setLocalPosition(position);

				this._setScrollFromContentPosition(position);
			}

			this._velocity.x *= 1 - this.friction;
			this._velocity.y *= 1 - this.friction;
		}
	}

	_hasOvershoot(axis, orientation) {
		return Math.abs(this._toOvershoot(this.scroll[axis], orientation)) > 0.001;
	}

	_toOvershoot(scrollValue, orientation) {
		const maxScrollValue = this._getMaxScrollValue(orientation);

		if (scrollValue < 0) {
			return scrollValue;
		} else if (scrollValue > maxScrollValue) {
			return scrollValue - maxScrollValue;
		}

		return 0;
	}

	_setVelocityFromOvershoot(scrollValue, axis, orientation) {
		const overshootValue = this._toOvershoot(scrollValue, orientation);

		const overshootPixels = overshootValue * this._getMaxOffset(orientation) * this._getSign(orientation);

		if (Math.abs(overshootPixels) > 0) {
			this._velocity[axis] = -overshootPixels / (this.bounceAmount * 50 + 1);
		}
	}

	_setVelocityFromContentPositionDelta(position) {
		if (this._prevContentDragPosition) {
			this._velocity.sub2(position, this._prevContentDragPosition);

			this._prevContentDragPosition.copy(position);
		} else {
			this._velocity.set(0, 0, 0);

			this._prevContentDragPosition = position.clone();
		}
	}

	_setScrollFromContentPosition(position) {
		let scrollValue = this._contentPositionToScrollValue(position);

		if (this._isDragging()) {
			scrollValue = this._applyScrollValueTension(scrollValue);
		}

		this._onSetScroll(scrollValue.x, scrollValue.y, false);
	}

	_applyScrollValueTension(scrollValue) {
		const factor = 1;

		let max = this._getMaxScrollValue(ORIENTATION_HORIZONTAL);

		let overshoot = this._toOvershoot(scrollValue.x, ORIENTATION_HORIZONTAL);

		if (overshoot > 0) {
			scrollValue.x = max + factor * Math.log10(1 + overshoot);
		} else if (overshoot < 0) {
			scrollValue.x = -factor * Math.log10(1 - overshoot);
		}

		max = this._getMaxScrollValue(ORIENTATION_VERTICAL);
		overshoot = this._toOvershoot(scrollValue.y, ORIENTATION_VERTICAL);

		if (overshoot > 0) {
			scrollValue.y = max + factor * Math.log10(1 + overshoot);
		} else if (overshoot < 0) {
			scrollValue.y = -factor * Math.log10(1 - overshoot);
		}

		return scrollValue;
	}

	_isDragging() {
		return this._contentDragHelper && this._contentDragHelper.isDragging;
	}

	_setScrollbarComponentsEnabled(enabled) {
		if (this._scrollbarReferences[ORIENTATION_HORIZONTAL].hasComponent('scrollbar')) {
			this._scrollbarReferences[ORIENTATION_HORIZONTAL].entity.scrollbar.enabled = enabled;
		}

		if (this._scrollbarReferences[ORIENTATION_VERTICAL].hasComponent('scrollbar')) {
			this._scrollbarReferences[ORIENTATION_VERTICAL].entity.scrollbar.enabled = enabled;
		}
	}

	_setContentDraggingEnabled(enabled) {
		if (this._contentDragHelper) {
			this._contentDragHelper.enabled = enabled;
		}
	}

	_onMouseWheel(event) {
		if (this.useMouseWheel) {
			const wheelEvent = event.event;
			const normalizedDeltaX = wheelEvent.deltaX / this._contentReference.entity.element.calculatedWidth * this.mouseWheelSensitivity.x;
			const normalizedDeltaY = wheelEvent.deltaY / this._contentReference.entity.element.calculatedHeight * this.mouseWheelSensitivity.y;
			const scrollX = math.clamp(this._scroll.x + normalizedDeltaX, 0, this._getMaxScrollValue(ORIENTATION_HORIZONTAL));
			const scrollY = math.clamp(this._scroll.y + normalizedDeltaY, 0, this._getMaxScrollValue(ORIENTATION_VERTICAL));
			this.scroll = new Vec2(scrollX, scrollY);
		}
	}

	_enableContentInput() {
		while (this._disabledContentInputEntities.length) {
			const e = this._disabledContentInputEntities.pop();

			if (e.element) {
				e.element.useInput = true;
			}
		}

		this._disabledContentInput = false;
	}

	_disableContentInput() {
		const _disableInput = e => {
			if (e.element && e.element.useInput) {
				this._disabledContentInputEntities.push(e);

				e.element.useInput = false;
			}

			const children = e.children;

			for (let i = 0, l = children.length; i < l; i++) {
				_disableInput(children[i]);
			}
		};

		const contentEntity = this._contentReference.entity;

		if (contentEntity) {
			const children = contentEntity.children;

			for (let i = 0, l = children.length; i < l; i++) {
				_disableInput(children[i]);
			}
		}

		this._disabledContentInput = true;
	}

	onEnable() {
		this._viewportReference.onParentComponentEnable();

		this._contentReference.onParentComponentEnable();

		this._scrollbarReferences[ORIENTATION_HORIZONTAL].onParentComponentEnable();

		this._scrollbarReferences[ORIENTATION_VERTICAL].onParentComponentEnable();

		this._setScrollbarComponentsEnabled(true);

		this._setContentDraggingEnabled(true);

		this._syncAll();
	}

	onDisable() {
		this._setScrollbarComponentsEnabled(false);

		this._setContentDraggingEnabled(false);
	}

	onRemove() {
		this._toggleLifecycleListeners('off', this.system);

		this._toggleElementListeners('off');

		this._destroyDragHelper();
	}

	set scroll(value) {
		this._onSetScroll(value.x, value.y);
	}

	get scroll() {
		return this._scroll;
	}

}

class ScrollViewComponentData {
	constructor() {
		this.enabled = true;
	}

}

const _schema$4 = [{
	name: 'enabled',
	type: 'boolean'
}, {
	name: 'horizontal',
	type: 'boolean'
}, {
	name: 'vertical',
	type: 'boolean'
}, {
	name: 'scrollMode',
	type: 'number'
}, {
	name: 'bounceAmount',
	type: 'number'
}, {
	name: 'friction',
	type: 'number'
}, {
	name: 'dragThreshold',
	type: 'number'
}, {
	name: 'useMouseWheel',
	type: 'boolean'
}, {
	name: 'mouseWheelSensitivity',
	type: 'vec2'
}, {
	name: 'horizontalScrollbarVisibility',
	type: 'number'
}, {
	name: 'verticalScrollbarVisibility',
	type: 'number'
}, {
	name: 'viewportEntity',
	type: 'entity'
}, {
	name: 'contentEntity',
	type: 'entity'
}, {
	name: 'horizontalScrollbarEntity',
	type: 'entity'
}, {
	name: 'verticalScrollbarEntity',
	type: 'entity'
}];
const DEFAULT_DRAG_THRESHOLD = 10;

class ScrollViewComponentSystem extends ComponentSystem {
	constructor(app) {
		super(app);
		this.id = 'scrollview';
		this.ComponentType = ScrollViewComponent;
		this.DataType = ScrollViewComponentData;
		this.schema = _schema$4;
		this.on('beforeremove', this._onRemoveComponent, this);
		this.app.systems.on('update', this.onUpdate, this);
	}

	initializeComponentData(component, data, properties) {
		if (data.dragThreshold === undefined) {
			data.dragThreshold = DEFAULT_DRAG_THRESHOLD;
		}

		if (data.useMouseWheel === undefined) {
			data.useMouseWheel = true;
		}

		if (data.mouseWheelSensitivity === undefined) {
			data.mouseWheelSensitivity = new Vec2(1, 1);
		}

		super.initializeComponentData(component, data, _schema$4);
	}

	onUpdate(dt) {
		const components = this.store;

		for (const id in components) {
			const entity = components[id].entity;
			const component = entity.scrollview;

			if (component.enabled && entity.enabled) {
				component.onUpdate();
			}
		}
	}

	_onRemoveComponent(entity, component) {
		component.onRemove();
	}

	destroy() {
		super.destroy();
		this.app.systems.off('update', this.onUpdate, this);
	}

}

Component._buildAccessors(ScrollViewComponent.prototype, _schema$4);

class ScrollbarComponent extends Component {
	constructor(system, entity) {
		super(system, entity);
		this._handleReference = new EntityReference(this, 'handleEntity', {
			'element#gain': this._onHandleElementGain,
			'element#lose': this._onHandleElementLose,
			'element#set:anchor': this._onSetHandleAlignment,
			'element#set:margin': this._onSetHandleAlignment,
			'element#set:pivot': this._onSetHandleAlignment
		});

		this._toggleLifecycleListeners('on');
	}

	_toggleLifecycleListeners(onOrOff) {
		this[onOrOff]('set_value', this._onSetValue, this);
		this[onOrOff]('set_handleSize', this._onSetHandleSize, this);
		this[onOrOff]('set_orientation', this._onSetOrientation, this);
	}

	_onHandleElementGain() {
		this._destroyDragHelper();

		this._handleDragHelper = new ElementDragHelper(this._handleReference.entity.element, this._getAxis());

		this._handleDragHelper.on('drag:move', this._onHandleDrag, this);

		this._updateHandlePositionAndSize();
	}

	_onHandleElementLose() {
		this._destroyDragHelper();
	}

	_onHandleDrag(position) {
		if (this._handleReference.entity && this.enabled && this.entity.enabled) {
			this.value = this._handlePositionToScrollValue(position[this._getAxis()]);
		}
	}

	_onSetValue(name, oldValue, newValue) {
		if (Math.abs(newValue - oldValue) > 1e-5) {
			this.data.value = math.clamp(newValue, 0, 1);

			this._updateHandlePositionAndSize();

			this.fire('set:value', this.data.value);
		}
	}

	_onSetHandleSize(name, oldValue, newValue) {
		if (Math.abs(newValue - oldValue) > 1e-5) {
			this.data.handleSize = math.clamp(newValue, 0, 1);

			this._updateHandlePositionAndSize();
		}
	}

	_onSetHandleAlignment() {
		this._updateHandlePositionAndSize();
	}

	_onSetOrientation(name, oldValue, newValue) {
		if (newValue !== oldValue && this._handleReference.hasComponent('element')) {
			this._handleReference.entity.element[this._getOppositeDimension()] = 0;
		}
	}

	_updateHandlePositionAndSize() {
		const handleEntity = this._handleReference.entity;
		const handleElement = handleEntity && handleEntity.element;

		if (handleEntity) {
			const position = handleEntity.getLocalPosition();
			position[this._getAxis()] = this._getHandlePosition();

			this._handleReference.entity.setLocalPosition(position);
		}

		if (handleElement) {
			handleElement[this._getDimension()] = this._getHandleLength();
		}
	}

	_handlePositionToScrollValue(handlePosition) {
		return handlePosition * this._getSign() / this._getUsableTrackLength();
	}

	_scrollValueToHandlePosition(value) {
		return value * this._getSign() * this._getUsableTrackLength();
	}

	_getUsableTrackLength() {
		return Math.max(this._getTrackLength() - this._getHandleLength(), 0.001);
	}

	_getTrackLength() {
		if (this.entity.element) {
			return this.orientation === ORIENTATION_HORIZONTAL ? this.entity.element.calculatedWidth : this.entity.element.calculatedHeight;
		}

		return 0;
	}

	_getHandleLength() {
		return this._getTrackLength() * this.handleSize;
	}

	_getHandlePosition() {
		return this._scrollValueToHandlePosition(this.value);
	}

	_getSign() {
		return this.orientation === ORIENTATION_HORIZONTAL ? 1 : -1;
	}

	_getAxis() {
		return this.orientation === ORIENTATION_HORIZONTAL ? 'x' : 'y';
	}

	_getDimension() {
		return this.orientation === ORIENTATION_HORIZONTAL ? 'width' : 'height';
	}

	_getOppositeDimension() {
		return this.orientation === ORIENTATION_HORIZONTAL ? 'height' : 'width';
	}

	_destroyDragHelper() {
		if (this._handleDragHelper) {
			this._handleDragHelper.destroy();
		}
	}

	_setHandleDraggingEnabled(enabled) {
		if (this._handleDragHelper) {
			this._handleDragHelper.enabled = enabled;
		}
	}

	onEnable() {
		this._handleReference.onParentComponentEnable();

		this._setHandleDraggingEnabled(true);
	}

	onDisable() {
		this._setHandleDraggingEnabled(false);
	}

	onRemove() {
		this._destroyDragHelper();

		this._toggleLifecycleListeners('off');
	}

}

class ScrollbarComponentData {
	constructor() {
		this.enabled = true;
	}

}

const _schema$3 = [{
	name: 'enabled',
	type: 'boolean'
}, {
	name: 'orientation',
	type: 'number'
}, {
	name: 'value',
	type: 'number'
}, {
	name: 'handleSize',
	type: 'number'
}, {
	name: 'handleEntity',
	type: 'entity'
}];

class ScrollbarComponentSystem extends ComponentSystem {
	constructor(app) {
		super(app);
		this.id = 'scrollbar';
		this.ComponentType = ScrollbarComponent;
		this.DataType = ScrollbarComponentData;
		this.schema = _schema$3;
		this.on('beforeremove', this._onRemoveComponent, this);
	}

	initializeComponentData(component, data, properties) {
		super.initializeComponentData(component, data, _schema$3);
	}

	_onRemoveComponent(entity, component) {
		component.onRemove();
	}

}

Component._buildAccessors(ScrollbarComponent.prototype, _schema$3);

const STATE_PLAYING = 0;
const STATE_PAUSED = 1;
const STATE_STOPPED = 2;

function capTime(time, duration) {
	return time % duration || 0;
}

class SoundInstance extends EventHandler {
	constructor(manager, sound, options) {
		super();
		this.source = null;
		this._manager = manager;
		this._volume = options.volume !== undefined ? math.clamp(Number(options.volume) || 0, 0, 1) : 1;
		this._pitch = options.pitch !== undefined ? Math.max(0.01, Number(options.pitch) || 0) : 1;
		this._loop = !!(options.loop !== undefined ? options.loop : false);
		this._sound = sound;
		this._state = STATE_STOPPED;
		this._suspended = false;
		this._suspendEndEvent = false;
		this._suspendInstanceEvents = false;
		this._playWhenLoaded = true;
		this._startTime = Math.max(0, Number(options.startTime) || 0);
		this._duration = Math.max(0, Number(options.duration) || 0);
		this._startOffset = null;
		this._onPlayCallback = options.onPlay;
		this._onPauseCallback = options.onPause;
		this._onResumeCallback = options.onResume;
		this._onStopCallback = options.onStop;
		this._onEndCallback = options.onEnd;

		if (hasAudioContext()) {
			this._startedAt = 0;
			this._currentTime = 0;
			this._currentOffset = 0;
			this._inputNode = null;
			this._connectorNode = null;
			this._firstNode = null;
			this._lastNode = null;

			this._initializeNodes();

			this._endedHandler = this._onEnded.bind(this);
		} else {
			this._isReady = false;
			this._loadedMetadataHandler = this._onLoadedMetadata.bind(this);
			this._timeUpdateHandler = this._onTimeUpdate.bind(this);
			this._endedHandler = this._onEnded.bind(this);

			this._createSource();
		}
	}

	set currentTime(value) {
		if (value < 0) return;

		if (this._state === STATE_PLAYING) {
			const suspend = this._suspendInstanceEvents;
			this._suspendInstanceEvents = true;
			this.stop();
			this._startOffset = value;
			this.play();
			this._suspendInstanceEvents = suspend;
		} else {
			this._startOffset = value;
			this._currentTime = value;
		}
	}

	get currentTime() {
		if (this._startOffset !== null) {
			return this._startOffset;
		}

		if (this._state === STATE_PAUSED) {
			return this._currentTime;
		}

		if (this._state === STATE_STOPPED || !this.source) {
			return 0;
		}

		this._updateCurrentTime();

		return this._currentTime;
	}

	set duration(value) {
		this._duration = Math.max(0, Number(value) || 0);
		const isPlaying = this._state === STATE_PLAYING;
		this.stop();

		if (isPlaying) {
			this.play();
		}
	}

	get duration() {
		if (!this._sound) {
			return 0;
		}

		if (this._duration) {
			return capTime(this._duration, this._sound.duration);
		}

		return this._sound.duration;
	}

	get isPaused() {
		return this._state === STATE_PAUSED;
	}

	get isPlaying() {
		return this._state === STATE_PLAYING;
	}

	get isStopped() {
		return this._state === STATE_STOPPED;
	}

	get isSuspended() {
		return this._suspended;
	}

	set loop(value) {
		this._loop = !!value;

		if (this.source) {
			this.source.loop = this._loop;
		}
	}

	get loop() {
		return this._loop;
	}

	set pitch(pitch) {
		this._currentOffset = this.currentTime;
		this._startedAt = this._manager.context.currentTime;
		this._pitch = Math.max(Number(pitch) || 0, 0.01);

		if (this.source) {
			this.source.playbackRate.value = this._pitch;
		}
	}

	get pitch() {
		return this._pitch;
	}

	set sound(value) {
		this._sound = value;

		if (this._state !== STATE_STOPPED) {
			this.stop();
		} else {
			this._createSource();
		}
	}

	get sound() {
		return this._sound;
	}

	set startTime(value) {
		this._startTime = Math.max(0, Number(value) || 0);
		const isPlaying = this._state === STATE_PLAYING;
		this.stop();

		if (isPlaying) {
			this.play();
		}
	}

	get startTime() {
		return this._startTime;
	}

	set volume(volume) {
		volume = math.clamp(volume, 0, 1);
		this._volume = volume;

		if (this.gain) {
			this.gain.gain.value = volume * this._manager.volume;
		}
	}

	get volume() {
		return this._volume;
	}

	_onPlay() {
		this.fire('play');
		if (this._onPlayCallback) this._onPlayCallback(this);
	}

	_onPause() {
		this.fire('pause');
		if (this._onPauseCallback) this._onPauseCallback(this);
	}

	_onResume() {
		this.fire('resume');
		if (this._onResumeCallback) this._onResumeCallback(this);
	}

	_onStop() {
		this.fire('stop');
		if (this._onStopCallback) this._onStopCallback(this);
	}

	_onEnded() {
		if (this._suspendEndEvent) {
			this._suspendEndEvent = false;
			return;
		}

		this.fire('end');
		if (this._onEndCallback) this._onEndCallback(this);
		this.stop();
	}

	_onManagerVolumeChange() {
		this.volume = this._volume;
	}

	_onManagerSuspend() {
		if (this._state === STATE_PLAYING && !this._suspended) {
			this._suspended = true;
			this.pause();
		}
	}

	_onManagerResume() {
		if (this._suspended) {
			this._suspended = false;
			this.resume();
		}
	}

	_initializeNodes() {
		this.gain = this._manager.context.createGain();
		this._inputNode = this.gain;
		this._connectorNode = this.gain;

		this._connectorNode.connect(this._manager.context.destination);
	}

	play() {
		if (this._state !== STATE_STOPPED) {
			this.stop();
		}

		if (!this.source) {
			this._createSource();
		}

		let offset = capTime(this._startOffset, this.duration);
		offset = capTime(this._startTime + offset, this._sound.duration);
		this._startOffset = null;

		if (this._duration) {
			this.source.start(0, offset, this._duration);
		} else {
			this.source.start(0, offset);
		}

		this._startedAt = this._manager.context.currentTime;
		this._currentTime = 0;
		this._currentOffset = offset;
		this._state = STATE_PLAYING;
		this._playWhenLoaded = false;
		this.volume = this._volume;
		this.loop = this._loop;
		this.pitch = this._pitch;

		this._manager.on('volumechange', this._onManagerVolumeChange, this);

		this._manager.on('suspend', this._onManagerSuspend, this);

		this._manager.on('resume', this._onManagerResume, this);

		this._manager.on('destroy', this._onManagerDestroy, this);

		if (this._manager.suspended) {
			this._onManagerSuspend();
		}

		if (!this._suspendInstanceEvents) this._onPlay();
		return true;
	}

	pause() {
		this._playWhenLoaded = false;
		if (this._state !== STATE_PLAYING || !this.source) return false;

		this._updateCurrentTime();

		this._state = STATE_PAUSED;
		this._suspendEndEvent = true;
		this.source.stop(0);
		this.source = null;
		this._startOffset = null;
		if (!this._suspendInstanceEvents) this._onPause();
		return true;
	}

	resume() {
		if (this._state !== STATE_PAUSED) {
			return false;
		}

		if (!this.source) {
			this._createSource();
		}

		let offset = this.currentTime;

		if (this._startOffset !== null) {
			offset = capTime(this._startOffset, this.duration);
			offset = capTime(this._startTime + offset, this._sound.duration);
			this._startOffset = null;
		}

		if (this._duration) {
			this.source.start(0, offset, this._duration);
		} else {
			this.source.start(0, offset);
		}

		this._state = STATE_PLAYING;
		this._startedAt = this._manager.context.currentTime;
		this._currentOffset = offset;
		this.volume = this._volume;
		this.loop = this._loop;
		this.pitch = this._pitch;
		this._playWhenLoaded = false;
		if (!this._suspendInstanceEvents) this._onResume();
		return true;
	}

	stop() {
		this._playWhenLoaded = false;
		if (this._state === STATE_STOPPED || !this.source) return false;

		this._manager.off('volumechange', this._onManagerVolumeChange, this);

		this._manager.off('suspend', this._onManagerSuspend, this);

		this._manager.off('resume', this._onManagerResume, this);

		this._manager.off('destroy', this._onManagerDestroy, this);

		this._startedAt = 0;
		this._currentTime = 0;
		this._currentOffset = 0;
		this._startOffset = null;
		this._suspendEndEvent = true;

		if (this._state === STATE_PLAYING) {
			this.source.stop(0);
		}

		this.source = null;
		this._state = STATE_STOPPED;
		if (!this._suspendInstanceEvents) this._onStop();
		return true;
	}

	setExternalNodes(firstNode, lastNode) {
		if (!firstNode) {
			console.error('The firstNode must be a valid Audio Node');
			return;
		}

		if (!lastNode) {
			lastNode = firstNode;
		}

		const speakers = this._manager.context.destination;

		if (this._firstNode !== firstNode) {
			if (this._firstNode) {
				this._connectorNode.disconnect(this._firstNode);
			} else {
				this._connectorNode.disconnect(speakers);
			}

			this._firstNode = firstNode;

			this._connectorNode.connect(firstNode);
		}

		if (this._lastNode !== lastNode) {
			if (this._lastNode) {
				this._lastNode.disconnect(speakers);
			}

			this._lastNode = lastNode;

			this._lastNode.connect(speakers);
		}
	}

	clearExternalNodes() {
		const speakers = this._manager.context.destination;

		if (this._firstNode) {
			this._connectorNode.disconnect(this._firstNode);

			this._firstNode = null;
		}

		if (this._lastNode) {
			this._lastNode.disconnect(speakers);

			this._lastNode = null;
		}

		this._connectorNode.connect(speakers);
	}

	getExternalNodes() {
		return [this._firstNode, this._lastNode];
	}

	_createSource() {
		if (!this._sound) {
			return null;
		}

		const context = this._manager.context;

		if (this._sound.buffer) {
			this.source = context.createBufferSource();
			this.source.buffer = this._sound.buffer;
			this.source.connect(this._inputNode);
			this.source.onended = this._endedHandler;
			this.source.loopStart = capTime(this._startTime, this.source.buffer.duration);

			if (this._duration) {
				this.source.loopEnd = Math.max(this.source.loopStart, capTime(this._startTime + this._duration, this.source.buffer.duration));
			}
		}

		return this.source;
	}

	_updateCurrentTime() {
		this._currentTime = capTime((this._manager.context.currentTime - this._startedAt) * this._pitch + this._currentOffset, this.duration);
	}

	_onManagerDestroy() {
		if (this.source && this._state === STATE_PLAYING) {
			this.source.stop(0);
			this.source = null;
		}
	}

}

if (!hasAudioContext()) {
	Object.assign(SoundInstance.prototype, {
		play: function () {
			if (this._state !== STATE_STOPPED) {
				this.stop();
			}

			if (!this.source) {
				if (!this._createSource()) {
					return false;
				}
			}

			this.volume = this._volume;
			this.pitch = this._pitch;
			this.loop = this._loop;
			this.source.play();
			this._state = STATE_PLAYING;
			this._playWhenLoaded = false;

			this._manager.on('volumechange', this._onManagerVolumeChange, this);

			this._manager.on('suspend', this._onManagerSuspend, this);

			this._manager.on('resume', this._onManagerResume, this);

			this._manager.on('destroy', this._onManagerDestroy, this);

			if (this._manager.suspended) this._onManagerSuspend();
			if (!this._suspendInstanceEvents) this._onPlay();
			return true;
		},
		pause: function () {
			if (!this.source || this._state !== STATE_PLAYING) return false;
			this._suspendEndEvent = true;
			this.source.pause();
			this._playWhenLoaded = false;
			this._state = STATE_PAUSED;
			this._startOffset = null;
			if (!this._suspendInstanceEvents) this._onPause();
			return true;
		},
		resume: function () {
			if (!this.source || this._state !== STATE_PAUSED) return false;
			this._state = STATE_PLAYING;
			this._playWhenLoaded = false;

			if (this.source.paused) {
				this.source.play();
				if (!this._suspendInstanceEvents) this._onResume();
			}

			return true;
		},
		stop: function () {
			if (!this.source || this._state === STATE_STOPPED) return false;

			this._manager.off('volumechange', this._onManagerVolumeChange, this);

			this._manager.off('suspend', this._onManagerSuspend, this);

			this._manager.off('resume', this._onManagerResume, this);

			this._manager.off('destroy', this._onManagerDestroy, this);

			this._suspendEndEvent = true;
			this.source.pause();
			this._playWhenLoaded = false;
			this._state = STATE_STOPPED;
			this._startOffset = null;
			if (!this._suspendInstanceEvents) this._onStop();
			return true;
		},
		setExternalNodes: function () {},
		clearExternalNodes: function () {},
		getExternalNodes: function () {
			return [null, null];
		},
		_onLoadedMetadata: function () {
			this.source.removeEventListener('loadedmetadata', this._loadedMetadataHandler);
			this._isReady = true;
			let offset = capTime(this._startOffset, this.duration);
			offset = capTime(this._startTime + offset, this._sound.duration);
			this._startOffset = null;
			this.source.currentTime = offset;
		},
		_createSource: function () {
			if (this._sound && this._sound.audio) {
				this._isReady = false;
				this.source = this._sound.audio.cloneNode(true);
				this.source.addEventListener('loadedmetadata', this._loadedMetadataHandler);
				this.source.addEventListener('timeupdate', this._timeUpdateHandler);
				this.source.onended = this._endedHandler;
			}

			return this.source;
		},
		_onTimeUpdate: function () {
			if (!this._duration) return;

			if (this.source.currentTime > capTime(this._startTime + this._duration, this.source.duration)) {
				if (this.loop) {
					this.source.currentTime = capTime(this._startTime, this.source.duration);
				} else {
					this.source.removeEventListener('timeupdate', this._timeUpdateHandler);
					this.source.pause();

					this._onEnded();
				}
			}
		},
		_onManagerDestroy: function () {
			if (this.source) {
				this.source.pause();
			}
		}
	});
	Object.defineProperty(SoundInstance.prototype, 'volume', {
		get: function () {
			return this._volume;
		},
		set: function (volume) {
			volume = math.clamp(volume, 0, 1);
			this._volume = volume;

			if (this.source) {
				this.source.volume = volume * this._manager.volume;
			}
		}
	});
	Object.defineProperty(SoundInstance.prototype, 'pitch', {
		get: function () {
			return this._pitch;
		},
		set: function (pitch) {
			this._pitch = Math.max(Number(pitch) || 0, 0.01);

			if (this.source) {
				this.source.playbackRate = this._pitch;
			}
		}
	});
	Object.defineProperty(SoundInstance.prototype, 'sound', {
		get: function () {
			return this._sound;
		},
		set: function (value) {
			this.stop();
			this._sound = value;
		}
	});
	Object.defineProperty(SoundInstance.prototype, 'currentTime', {
		get: function () {
			if (this._startOffset !== null) {
				return this._startOffset;
			}

			if (this._state === STATE_STOPPED || !this.source) {
				return 0;
			}

			return this.source.currentTime - this._startTime;
		},
		set: function (value) {
			if (value < 0) return;
			this._startOffset = value;

			if (this.source && this._isReady) {
				this.source.currentTime = capTime(this._startTime + capTime(value, this.duration), this._sound.duration);
				this._startOffset = null;
			}
		}
	});
}

const MAX_DISTANCE = 10000;

class SoundInstance3d extends SoundInstance {
	constructor(manager, sound, options = {}) {
		super(manager, sound, options);
		this._position = new Vec3();
		this._velocity = new Vec3();
		if (options.position) this.position = options.position;
		if (options.velocity) this.velocity = options.velocity;
		this.maxDistance = options.maxDistance !== undefined ? Number(options.maxDistance) : MAX_DISTANCE;
		this.refDistance = options.refDistance !== undefined ? Number(options.refDistance) : 1;
		this.rollOffFactor = options.rollOffFactor !== undefined ? Number(options.rollOffFactor) : 1;
		this.distanceModel = options.distanceModel !== undefined ? options.distanceModel : DISTANCE_LINEAR;
	}

	_initializeNodes() {
		this.gain = this._manager.context.createGain();
		this.panner = this._manager.context.createPanner();
		this.panner.connect(this.gain);
		this._inputNode = this.panner;
		this._connectorNode = this.gain;

		this._connectorNode.connect(this._manager.context.destination);
	}

	set position(value) {
		this._position.copy(value);

		this.panner.positionX.value = value.x;
		this.panner.positionY.value = value.y;
		this.panner.positionZ.value = value.z;
	}

	get position() {
		return this._position;
	}

	set velocity(velocity) {
		this._velocity.copy(velocity);

		this.panner.setVelocity(velocity.x, velocity.y, velocity.z);
	}

	get velocity() {
		return this._velocity;
	}

	set maxDistance(value) {
		this.panner.maxDistance = value;
	}

	get maxDistance() {
		return this.panner.maxDistance;
	}

	set refDistance(value) {
		this.panner.refDistance = value;
	}

	get refDistance() {
		return this.panner.refDistance;
	}

	set rollOffFactor(value) {
		this.panner.rolloffFactor = value;
	}

	get rollOffFactor() {
		return this.panner.rolloffFactor;
	}

	set distanceModel(value) {
		this.panner.distanceModel = value;
	}

	get distanceModel() {
		return this.panner.distanceModel;
	}

}

if (!hasAudioContext()) {
	let offset = new Vec3();

	const fallOff = function fallOff(posOne, posTwo, refDistance, maxDistance, rollOffFactor, distanceModel) {
		offset = offset.sub2(posOne, posTwo);
		const distance = offset.length();

		if (distance < refDistance) {
			return 1;
		} else if (distance > maxDistance) {
			return 0;
		}

		let result = 0;

		if (distanceModel === DISTANCE_LINEAR) {
			result = 1 - rollOffFactor * (distance - refDistance) / (maxDistance - refDistance);
		} else if (distanceModel === DISTANCE_INVERSE) {
			result = refDistance / (refDistance + rollOffFactor * (distance - refDistance));
		} else if (distanceModel === DISTANCE_EXPONENTIAL) {
			result = Math.pow(distance / refDistance, -rollOffFactor);
		}

		return math.clamp(result, 0, 1);
	};

	Object.defineProperty(SoundInstance3d.prototype, 'position', {
		get: function () {
			return this._position;
		},
		set: function (position) {
			this._position.copy(position);

			if (this.source) {
				const listener = this._manager.listener;
				const lpos = listener.getPosition();
				const factor = fallOff(lpos, this._position, this.refDistance, this.maxDistance, this.rollOffFactor, this.distanceModel);
				const v = this.volume;
				this.source.volume = v * factor * this._manager.volume;
			}
		}
	});
	Object.defineProperty(SoundInstance3d.prototype, 'velocity', {
		get: function () {
			return this._velocity;
		},
		set: function (velocity) {
			this._velocity.copy(velocity);
		}
	});
	Object.defineProperty(SoundInstance3d.prototype, 'maxDistance', {
		get: function () {
			return this._maxDistance;
		},
		set: function (value) {
			this._maxDistance = value;
		}
	});
	Object.defineProperty(SoundInstance3d.prototype, 'refDistance', {
		get: function () {
			return this._refDistance;
		},
		set: function (value) {
			this._refDistance = value;
		}
	});
	Object.defineProperty(SoundInstance3d.prototype, 'rollOffFactor', {
		get: function () {
			return this._rollOffFactor;
		},
		set: function (value) {
			this._rollOffFactor = value;
		}
	});
	Object.defineProperty(SoundInstance3d.prototype, 'distanceModel', {
		get: function () {
			return this._distanceModel;
		},
		set: function (value) {
			this._distanceModel = value;
		}
	});
}

const instanceOptions = {
	volume: 0,
	pitch: 0,
	loop: false,
	startTime: 0,
	duration: 0,
	position: new Vec3(),
	maxDistance: 0,
	refDistance: 0,
	rollOffFactor: 0,
	distanceModel: 0,
	onPlay: null,
	onPause: null,
	onResume: null,
	onStop: null,
	onEnd: null
};

class SoundSlot extends EventHandler {
	constructor(component, name = 'Untitled', options = {}) {
		super();
		this.name = void 0;
		this.instances = [];
		this._component = component;
		this._assets = component.system.app.assets;
		this._manager = component.system.manager;
		this.name = name;
		this._volume = options.volume !== undefined ? math.clamp(Number(options.volume) || 0, 0, 1) : 1;
		this._pitch = options.pitch !== undefined ? Math.max(0.01, Number(options.pitch) || 0) : 1;
		this._loop = !!(options.loop !== undefined ? options.loop : false);
		this._duration = options.duration > 0 ? options.duration : null;
		this._startTime = Math.max(0, Number(options.startTime) || 0);
		this._overlap = !!options.overlap;
		this._autoPlay = !!options.autoPlay;
		this._firstNode = null;
		this._lastNode = null;
		this._asset = options.asset;

		if (this._asset instanceof Asset) {
			this._asset = this._asset.id;
		}

		this._onInstancePlayHandler = this._onInstancePlay.bind(this);
		this._onInstancePauseHandler = this._onInstancePause.bind(this);
		this._onInstanceResumeHandler = this._onInstanceResume.bind(this);
		this._onInstanceStopHandler = this._onInstanceStop.bind(this);
		this._onInstanceEndHandler = this._onInstanceEnd.bind(this);
	}

	play() {
		if (!this.overlap) {
			this.stop();
		}

		if (!this.isLoaded && !this._hasAsset()) {
			return;
		}

		const instance = this._createInstance();

		this.instances.push(instance);

		if (!this.isLoaded) {
			const onLoad = function onLoad(sound) {
				const playWhenLoaded = instance._playWhenLoaded;
				instance.sound = sound;

				if (playWhenLoaded) {
					instance.play();
				}
			};

			this.off('load', onLoad);
			this.once('load', onLoad);
			this.load();
		} else {
			instance.play();
		}

		return instance;
	}

	pause() {
		let paused = false;
		const instances = this.instances;

		for (let i = 0, len = instances.length; i < len; i++) {
			if (instances[i].pause()) {
				paused = true;
			}
		}

		return paused;
	}

	resume() {
		let resumed = false;
		const instances = this.instances;

		for (let i = 0, len = instances.length; i < len; i++) {
			if (instances[i].resume()) resumed = true;
		}

		return resumed;
	}

	stop() {
		let stopped = false;
		const instances = this.instances;
		let i = instances.length;

		while (i--) {
			instances[i].stop();
			stopped = true;
		}

		instances.length = 0;
		return stopped;
	}

	load() {
		if (!this._hasAsset()) return;

		const asset = this._assets.get(this._asset);

		if (!asset) {
			this._assets.off('add:' + this._asset, this._onAssetAdd, this);

			this._assets.once('add:' + this._asset, this._onAssetAdd, this);

			return;
		}

		asset.off('remove', this._onAssetRemoved, this);
		asset.on('remove', this._onAssetRemoved, this);

		if (!asset.resource) {
			asset.off('load', this._onAssetLoad, this);
			asset.once('load', this._onAssetLoad, this);

			this._assets.load(asset);

			return;
		}

		this.fire('load', asset.resource);
	}

	setExternalNodes(firstNode, lastNode) {
		if (!firstNode) {
			console.error('The firstNode must have a valid AudioNode');
			return;
		}

		if (!lastNode) {
			lastNode = firstNode;
		}

		this._firstNode = firstNode;
		this._lastNode = lastNode;

		if (!this._overlap) {
			const instances = this.instances;

			for (let i = 0, len = instances.length; i < len; i++) {
				instances[i].setExternalNodes(firstNode, lastNode);
			}
		}
	}

	clearExternalNodes() {
		this._firstNode = null;
		this._lastNode = null;

		if (!this._overlap) {
			const instances = this.instances;

			for (let i = 0, len = instances.length; i < len; i++) {
				instances[i].clearExternalNodes();
			}
		}
	}

	getExternalNodes() {
		return [this._firstNode, this._lastNode];
	}

	_hasAsset() {
		return this._asset != null;
	}

	_createInstance() {
		let instance = null;
		const component = this._component;
		let sound = null;

		if (this._hasAsset()) {
			const asset = this._assets.get(this._asset);

			if (asset) {
				sound = asset.resource;
			}
		}

		const data = instanceOptions;
		data.volume = this._volume * component.volume;
		data.pitch = this._pitch * component.pitch;
		data.loop = this._loop;
		data.startTime = this._startTime;
		data.duration = this._duration;
		data.onPlay = this._onInstancePlayHandler;
		data.onPause = this._onInstancePauseHandler;
		data.onResume = this._onInstanceResumeHandler;
		data.onStop = this._onInstanceStopHandler;
		data.onEnd = this._onInstanceEndHandler;

		if (component.positional) {
			data.position.copy(component.entity.getPosition());
			data.maxDistance = component.maxDistance;
			data.refDistance = component.refDistance;
			data.rollOffFactor = component.rollOffFactor;
			data.distanceModel = component.distanceModel;
			instance = new SoundInstance3d(this._manager, sound, data);
		} else {
			instance = new SoundInstance(this._manager, sound, data);
		}

		if (this._firstNode) {
			instance.setExternalNodes(this._firstNode, this._lastNode);
		}

		return instance;
	}

	_onInstancePlay(instance) {
		this.fire('play', instance);

		this._component.fire('play', this, instance);
	}

	_onInstancePause(instance) {
		this.fire('pause', instance);

		this._component.fire('pause', this, instance);
	}

	_onInstanceResume(instance) {
		this.fire('resume', instance);

		this._component.fire('resume', this, instance);
	}

	_onInstanceStop(instance) {
		const idx = this.instances.indexOf(instance);

		if (idx !== -1) {
			this.instances.splice(idx, 1);
		}

		this.fire('stop', instance);

		this._component.fire('stop', this, instance);
	}

	_onInstanceEnd(instance) {
		const idx = this.instances.indexOf(instance);

		if (idx !== -1) {
			this.instances.splice(idx, 1);
		}

		this.fire('end', instance);

		this._component.fire('end', this, instance);
	}

	_onAssetAdd(asset) {
		this.load();
	}

	_onAssetLoad(asset) {
		this.load();
	}

	_onAssetRemoved(asset) {
		asset.off('remove', this._onAssetRemoved, this);

		this._assets.off('add:' + asset.id, this._onAssetAdd, this);

		this.stop();
	}

	updatePosition(position) {
		const instances = this.instances;

		for (let i = 0, len = instances.length; i < len; i++) {
			instances[i].position = position;
		}
	}

	set asset(value) {
		const old = this._asset;

		if (old) {
			this._assets.off('add:' + old, this._onAssetAdd, this);

			const oldAsset = this._assets.get(old);

			if (oldAsset) {
				oldAsset.off('remove', this._onAssetRemoved, this);
			}
		}

		this._asset = value;

		if (this._asset instanceof Asset) {
			this._asset = this._asset.id;
		}

		if (this._hasAsset() && this._component.enabled && this._component.entity.enabled) {
			this.load();
		}
	}

	get asset() {
		return this._asset;
	}

	set autoPlay(value) {
		this._autoPlay = !!value;
	}

	get autoPlay() {
		return this._autoPlay;
	}

	set duration(value) {
		this._duration = Math.max(0, Number(value) || 0) || null;

		if (!this._overlap) {
			const instances = this.instances;

			for (let i = 0, len = instances.length; i < len; i++) {
				instances[i].duration = this._duration;
			}
		}
	}

	get duration() {
		let assetDuration = 0;

		if (this._hasAsset()) {
			const asset = this._assets.get(this._asset);

			assetDuration = asset != null && asset.resource ? asset.resource.duration : 0;
		}

		if (this._duration != null) {
			return this._duration % (assetDuration || 1);
		}

		return assetDuration;
	}

	get isLoaded() {
		if (this._hasAsset()) {
			const asset = this._assets.get(this._asset);

			if (asset) {
				return !!asset.resource;
			}
		}

		return false;
	}

	get isPaused() {
		const instances = this.instances;
		const len = instances.length;
		if (len === 0) return false;

		for (let i = 0; i < len; i++) {
			if (!instances[i].isPaused) return false;
		}

		return true;
	}

	get isPlaying() {
		const instances = this.instances;

		for (let i = 0, len = instances.length; i < len; i++) {
			if (instances[i].isPlaying) return true;
		}

		return false;
	}

	get isStopped() {
		const instances = this.instances;

		for (let i = 0, len = instances.length; i < len; i++) {
			if (!instances[i].isStopped) return false;
		}

		return true;
	}

	set loop(value) {
		this._loop = !!value;
		const instances = this.instances;

		for (let i = 0, len = instances.length; i < len; i++) {
			instances[i].loop = this._loop;
		}
	}

	get loop() {
		return this._loop;
	}

	set overlap(value) {
		this._overlap = !!value;
	}

	get overlap() {
		return this._overlap;
	}

	set pitch(value) {
		this._pitch = Math.max(Number(value) || 0, 0.01);

		if (!this._overlap) {
			const instances = this.instances;

			for (let i = 0, len = instances.length; i < len; i++) {
				instances[i].pitch = this.pitch * this._component.pitch;
			}
		}
	}

	get pitch() {
		return this._pitch;
	}

	set startTime(value) {
		this._startTime = Math.max(0, Number(value) || 0);

		if (!this._overlap) {
			const instances = this.instances;

			for (let i = 0, len = instances.length; i < len; i++) {
				instances[i].startTime = this._startTime;
			}
		}
	}

	get startTime() {
		return this._startTime;
	}

	set volume(value) {
		this._volume = math.clamp(Number(value) || 0, 0, 1);

		if (!this._overlap) {
			const instances = this.instances;

			for (let i = 0, len = instances.length; i < len; i++) {
				instances[i].volume = this._volume * this._component.volume;
			}
		}
	}

	get volume() {
		return this._volume;
	}

}

class SoundComponent extends Component {
	constructor(system, entity) {
		super(system, entity);
		this._volume = 1;
		this._pitch = 1;
		this._positional = true;
		this._refDistance = 1;
		this._maxDistance = 10000;
		this._rollOffFactor = 1;
		this._distanceModel = DISTANCE_LINEAR;
		this._slots = {};
		this._playingBeforeDisable = {};
	}

	_updateSoundInstances(property, value, isFactor) {
		const slots = this._slots;

		for (const key in slots) {
			const slot = slots[key];

			if (!slot.overlap) {
				const instances = slot.instances;

				for (let i = 0, len = instances.length; i < len; i++) {
					instances[i][property] = isFactor ? slot[property] * value : value;
				}
			}
		}
	}

	set distanceModel(value) {
		this._distanceModel = value;

		this._updateSoundInstances('distanceModel', value, false);
	}

	get distanceModel() {
		return this._distanceModel;
	}

	set maxDistance(value) {
		this._maxDistance = value;

		this._updateSoundInstances('maxDistance', value, false);
	}

	get maxDistance() {
		return this._maxDistance;
	}

	set refDistance(value) {
		this._refDistance = value;

		this._updateSoundInstances('refDistance', value, false);
	}

	get refDistance() {
		return this._refDistance;
	}

	set rollOffFactor(value) {
		this._rollOffFactor = value;

		this._updateSoundInstances('rollOffFactor', value, false);
	}

	get rollOffFactor() {
		return this._rollOffFactor;
	}

	set pitch(value) {
		this._pitch = value;

		this._updateSoundInstances('pitch', value, true);
	}

	get pitch() {
		return this._pitch;
	}

	set volume(value) {
		this._volume = value;

		this._updateSoundInstances('volume', value, true);
	}

	get volume() {
		return this._volume;
	}

	set positional(newValue) {
		this._positional = newValue;
		const slots = this._slots;

		for (const key in slots) {
			const slot = slots[key];

			if (!slot.overlap) {
				const instances = slot.instances;
				const oldLength = instances.length;

				for (let i = oldLength - 1; i >= 0; i--) {
					const isPlaying = instances[i].isPlaying || instances[i].isSuspended;
					const currentTime = instances[i].currentTime;
					if (isPlaying) instances[i].stop();

					const instance = slot._createInstance();

					if (isPlaying) {
						instance.play();
						instance.currentTime = currentTime;
					}

					instances.push(instance);
				}
			}
		}
	}

	get positional() {
		return this._positional;
	}

	set slots(newValue) {
		const oldValue = this._slots;

		if (oldValue) {
			for (const key in oldValue) {
				oldValue[key].stop();
			}
		}

		const slots = {};

		for (const key in newValue) {
			if (!(newValue[key] instanceof SoundSlot)) {
				if (newValue[key].name) {
					slots[newValue[key].name] = new SoundSlot(this, newValue[key].name, newValue[key]);
				}
			} else {
				slots[newValue[key].name] = newValue[key];
			}
		}

		this._slots = slots;
		if (this.enabled && this.entity.enabled) this.onEnable();
	}

	get slots() {
		return this._slots;
	}

	onEnable() {
		if (this.system._inTools) {
			return;
		}

		const slots = this._slots;
		const playingBeforeDisable = this._playingBeforeDisable;

		for (const key in slots) {
			const slot = slots[key];

			if (slot.autoPlay && slot.isStopped) {
				slot.play();
			} else if (playingBeforeDisable[key]) {
				slot.resume();
			} else if (!slot.isLoaded) {
				slot.load();
			}
		}
	}

	onDisable() {
		const slots = this._slots;
		const playingBeforeDisable = {};

		for (const key in slots) {
			if (!slots[key].overlap) {
				if (slots[key].isPlaying) {
					slots[key].pause();
					playingBeforeDisable[key] = true;
				}
			}
		}

		this._playingBeforeDisable = playingBeforeDisable;
	}

	onRemove() {
		this.off();
	}

	addSlot(name, options) {
		const slots = this._slots;

		if (slots[name]) {
			return null;
		}

		const slot = new SoundSlot(this, name, options);
		slots[name] = slot;

		if (slot.autoPlay && this.enabled && this.entity.enabled) {
			slot.play();
		}

		return slot;
	}

	removeSlot(name) {
		const slots = this._slots;

		if (slots[name]) {
			slots[name].stop();
			delete slots[name];
		}
	}

	slot(name) {
		return this._slots[name];
	}

	play(name) {
		if (!this.enabled || !this.entity.enabled) {
			return null;
		}

		const slot = this._slots[name];

		if (!slot) {
			return null;
		}

		return slot.play();
	}

	pause(name) {
		const slots = this._slots;

		if (name) {
			const slot = slots[name];

			if (!slot) {
				return;
			}

			slot.pause();
		} else {
			for (const key in slots) {
				slots[key].pause();
			}
		}
	}

	resume(name) {
		const slots = this._slots;

		if (name) {
			const slot = slots[name];

			if (!slot) {
				return;
			}

			if (slot.isPaused) {
				slot.resume();
			}
		} else {
			for (const key in slots) {
				slots[key].resume();
			}
		}
	}

	stop(name) {
		const slots = this._slots;

		if (name) {
			const slot = slots[name];

			if (!slot) {
				return;
			}

			slot.stop();
		} else {
			for (const key in slots) {
				slots[key].stop();
			}
		}
	}

}

class SoundComponentData {
	constructor() {
		this.enabled = true;
	}

}

const _schema$2 = ['enabled'];

class SoundComponentSystem extends ComponentSystem {
	constructor(app, manager) {
		super(app);
		this.id = "sound";
		this.ComponentType = SoundComponent;
		this.DataType = SoundComponentData;
		this.schema = _schema$2;
		this.manager = manager;
		this.app.systems.on('update', this.onUpdate, this);
		this.on('beforeremove', this.onBeforeRemove, this);
	}

	set volume(volume) {
		this.manager.volume = volume;
	}

	get volume() {
		return this.manager.volume;
	}

	get context() {
		if (!hasAudioContext()) {
			return null;
		}

		return this.manager.context;
	}

	initializeComponentData(component, data, properties) {
		properties = ['volume', 'pitch', 'positional', 'refDistance', 'maxDistance', 'rollOffFactor', 'distanceModel', 'slots'];

		for (let i = 0; i < properties.length; i++) {
			if (data.hasOwnProperty(properties[i])) {
				component[properties[i]] = data[properties[i]];
			}
		}

		super.initializeComponentData(component, data, ['enabled']);
	}

	cloneComponent(entity, clone) {
		const srcComponent = entity.sound;
		const srcSlots = srcComponent.slots;
		const slots = {};

		for (const key in srcSlots) {
			const srcSlot = srcSlots[key];
			slots[key] = {
				name: srcSlot.name,
				volume: srcSlot.volume,
				pitch: srcSlot.pitch,
				loop: srcSlot.loop,
				duration: srcSlot.duration,
				startTime: srcSlot.startTime,
				overlap: srcSlot.overlap,
				autoPlay: srcSlot.autoPlay,
				asset: srcSlot.asset
			};
		}

		const cloneData = {
			distanceModel: srcComponent.distanceModel,
			enabled: srcComponent.enabled,
			maxDistance: srcComponent.maxDistance,
			pitch: srcComponent.pitch,
			positional: srcComponent.positional,
			refDistance: srcComponent.refDistance,
			rollOffFactor: srcComponent.rollOffFactor,
			slots: slots,
			volume: srcComponent.volume
		};
		return this.addComponent(clone, cloneData);
	}

	onUpdate(dt) {
		const store = this.store;

		for (const id in store) {
			if (store.hasOwnProperty(id)) {
				const item = store[id];
				const entity = item.entity;

				if (entity.enabled) {
					const component = entity.sound;

					if (component.enabled && component.positional) {
						const position = entity.getPosition();
						const slots = component.slots;

						for (const key in slots) {
							slots[key].updatePosition(position);
						}
					}
				}
			}
		}
	}

	onBeforeRemove(entity, component) {
		const slots = component.slots;

		for (const key in slots) {
			if (!slots[key].overlap) {
				slots[key].stop();
			}
		}

		component.onRemove();
	}

	destroy() {
		super.destroy();
		this.app.systems.off('update', this.onUpdate, this);
	}

}

Component._buildAccessors(SoundComponent.prototype, _schema$2);

const SPRITETYPE_SIMPLE = 'simple';
const SPRITETYPE_ANIMATED = 'animated';

class SpriteAnimationClip extends EventHandler {
	constructor(component, data) {
		super();
		this._component = component;
		this._frame = 0;
		this._sprite = null;
		this._spriteAsset = null;
		this.spriteAsset = data.spriteAsset;
		this.name = data.name;
		this.fps = data.fps || 0;
		this.loop = data.loop || false;
		this._playing = false;
		this._paused = false;
		this._time = 0;
	}

	get duration() {
		if (this._sprite) {
			const fps = this.fps || Number.MIN_VALUE;
			return this._sprite.frameKeys.length / Math.abs(fps);
		}

		return 0;
	}

	set frame(value) {
		this._setFrame(value);

		const fps = this.fps || Number.MIN_VALUE;

		this._setTime(this._frame / fps);
	}

	get frame() {
		return this._frame;
	}

	get isPaused() {
		return this._paused;
	}

	get isPlaying() {
		return this._playing;
	}

	set sprite(value) {
		if (this._sprite) {
			this._sprite.off('set:meshes', this._onSpriteMeshesChange, this);

			this._sprite.off('set:pixelsPerUnit', this._onSpritePpuChanged, this);

			this._sprite.off('set:atlas', this._onSpriteMeshesChange, this);

			if (this._sprite.atlas) {
				this._sprite.atlas.off('set:texture', this._onSpriteMeshesChange, this);
			}
		}

		this._sprite = value;

		if (this._sprite) {
			this._sprite.on('set:meshes', this._onSpriteMeshesChange, this);

			this._sprite.on('set:pixelsPerUnit', this._onSpritePpuChanged, this);

			this._sprite.on('set:atlas', this._onSpriteMeshesChange, this);

			if (this._sprite.atlas) {
				this._sprite.atlas.on('set:texture', this._onSpriteMeshesChange, this);
			}
		}

		if (this._component.currentClip === this) {
			let mi;

			if (!value || !value.atlas) {
				mi = this._component._meshInstance;

				if (mi) {
					mi.deleteParameter('texture_emissiveMap');
					mi.deleteParameter('texture_opacityMap');
				}

				this._component._hideModel();
			} else {
				if (value.atlas.texture) {
					mi = this._component._meshInstance;

					if (mi) {
						mi.setParameter('texture_emissiveMap', value.atlas.texture);
						mi.setParameter('texture_opacityMap', value.atlas.texture);
					}

					if (this._component.enabled && this._component.entity.enabled) {
						this._component._showModel();
					}
				}

				if (this.time && this.fps) {
					this.time = this.time;
				} else {
					this.frame = this.frame;
				}
			}
		}
	}

	get sprite() {
		return this._sprite;
	}

	set spriteAsset(value) {
		const assets = this._component.system.app.assets;
		let id = value;

		if (value instanceof Asset) {
			id = value.id;
		}

		if (this._spriteAsset !== id) {
			if (this._spriteAsset) {
				const prev = assets.get(this._spriteAsset);

				if (prev) {
					this._unbindSpriteAsset(prev);
				}
			}

			this._spriteAsset = id;

			if (this._spriteAsset) {
				const asset = assets.get(this._spriteAsset);

				if (!asset) {
					this.sprite = null;
					assets.on('add:' + this._spriteAsset, this._onSpriteAssetAdded, this);
				} else {
					this._bindSpriteAsset(asset);
				}
			} else {
				this.sprite = null;
			}
		}
	}

	get spriteAsset() {
		return this._spriteAsset;
	}

	set time(value) {
		this._setTime(value);

		if (this._sprite) {
			this.frame = Math.min(this._sprite.frameKeys.length - 1, Math.floor(this._time * Math.abs(this.fps)));
		} else {
			this.frame = 0;
		}
	}

	get time() {
		return this._time;
	}

	_onSpriteAssetAdded(asset) {
		this._component.system.app.assets.off('add:' + asset.id, this._onSpriteAssetAdded, this);

		if (this._spriteAsset === asset.id) {
			this._bindSpriteAsset(asset);
		}
	}

	_bindSpriteAsset(asset) {
		asset.on("load", this._onSpriteAssetLoad, this);
		asset.on("remove", this._onSpriteAssetRemove, this);

		if (asset.resource) {
			this._onSpriteAssetLoad(asset);
		} else {
			this._component.system.app.assets.load(asset);
		}
	}

	_unbindSpriteAsset(asset) {
		asset.off("load", this._onSpriteAssetLoad, this);
		asset.off("remove", this._onSpriteAssetRemove, this);

		if (asset.resource && asset.resource.atlas) {
			this._component.system.app.assets.off('load:' + asset.data.textureAtlasAsset, this._onTextureAtlasLoad, this);
		}
	}

	_onSpriteAssetLoad(asset) {
		if (!asset.resource) {
			this.sprite = null;
		} else {
			if (!asset.resource.atlas) {
				const atlasAssetId = asset.data.textureAtlasAsset;
				const assets = this._component.system.app.assets;
				assets.off('load:' + atlasAssetId, this._onTextureAtlasLoad, this);
				assets.once('load:' + atlasAssetId, this._onTextureAtlasLoad, this);
			} else {
				this.sprite = asset.resource;
			}
		}
	}

	_onTextureAtlasLoad(atlasAsset) {
		const spriteAsset = this._spriteAsset;

		if (spriteAsset instanceof Asset) {
			this._onSpriteAssetLoad(spriteAsset);
		} else {
			this._onSpriteAssetLoad(this._component.system.app.assets.get(spriteAsset));
		}
	}

	_onSpriteAssetRemove(asset) {
		this.sprite = null;
	}

	_onSpriteMeshesChange() {
		if (this._component.currentClip === this) {
			this._component._showFrame(this.frame);
		}
	}

	_onSpritePpuChanged() {
		if (this._component.currentClip === this) {
			if (this.sprite.renderMode !== SPRITE_RENDERMODE_SIMPLE) {
				this._component._showFrame(this.frame);
			}
		}
	}

	_update(dt) {
		if (this.fps === 0) return;
		if (!this._playing || this._paused || !this._sprite) return;
		const dir = this.fps < 0 ? -1 : 1;
		const time = this._time + dt * this._component.speed * dir;
		const duration = this.duration;
		const end = time > duration || time < 0;

		this._setTime(time);

		let frame = this.frame;

		if (this._sprite) {
			frame = Math.floor(this._sprite.frameKeys.length * this._time / duration);
		} else {
			frame = 0;
		}

		if (frame !== this._frame) {
			this._setFrame(frame);
		}

		if (end) {
			if (this.loop) {
				this.fire('loop');

				this._component.fire('loop', this);
			} else {
				this._playing = false;
				this._paused = false;
				this.fire('end');

				this._component.fire('end', this);
			}
		}
	}

	_setTime(value) {
		this._time = value;
		const duration = this.duration;

		if (this._time < 0) {
			if (this.loop) {
				this._time = this._time % duration + duration;
			} else {
				this._time = 0;
			}
		} else if (this._time > duration) {
			if (this.loop) {
				this._time %= duration;
			} else {
				this._time = duration;
			}
		}
	}

	_setFrame(value) {
		if (this._sprite) {
			this._frame = math.clamp(value, 0, this._sprite.frameKeys.length - 1);
		} else {
			this._frame = value;
		}

		if (this._component.currentClip === this) {
			this._component._showFrame(this._frame);
		}
	}

	_destroy() {
		if (this._sprite) {
			this.sprite = null;
		}

		if (this._spriteAsset) {
			this.spriteAsset = null;
		}
	}

	play() {
		if (this._playing) return;
		this._playing = true;
		this._paused = false;
		this.frame = 0;
		this.fire('play');

		this._component.fire('play', this);
	}

	pause() {
		if (!this._playing || this._paused) return;
		this._paused = true;
		this.fire('pause');

		this._component.fire('pause', this);
	}

	resume() {
		if (!this._paused) return;
		this._paused = false;
		this.fire('resume');

		this._component.fire('resume', this);
	}

	stop() {
		if (!this._playing) return;
		this._playing = false;
		this._paused = false;
		this._time = 0;
		this.frame = 0;
		this.fire('stop');

		this._component.fire('stop', this);
	}

}

const PARAM_EMISSIVE_MAP = 'texture_emissiveMap';
const PARAM_OPACITY_MAP = 'texture_opacityMap';
const PARAM_EMISSIVE = 'material_emissive';
const PARAM_OPACITY = 'material_opacity';
const PARAM_INNER_OFFSET = 'innerOffset';
const PARAM_OUTER_SCALE = 'outerScale';
const PARAM_ATLAS_RECT = 'atlasRect';

class SpriteComponent extends Component {
	constructor(system, entity) {
		super(system, entity);
		this._type = SPRITETYPE_SIMPLE;
		this._material = system.defaultMaterial;
		this._color = new Color(1, 1, 1, 1);
		this._colorUniform = new Float32Array(3);
		this._speed = 1;
		this._flipX = false;
		this._flipY = false;
		this._width = 1;
		this._height = 1;
		this._drawOrder = 0;
		this._layers = [LAYERID_WORLD];
		this._outerScale = new Vec2(1, 1);
		this._outerScaleUniform = new Float32Array(2);
		this._innerOffset = new Vec4();
		this._innerOffsetUniform = new Float32Array(4);
		this._atlasRect = new Vec4();
		this._atlasRectUniform = new Float32Array(4);
		this._batchGroupId = -1;
		this._batchGroup = null;
		this._node = new GraphNode();
		this._model = new Model();
		this._model.graph = this._node;
		this._meshInstance = null;
		entity.addChild(this._model.graph);
		this._model._entity = entity;
		this._updateAabbFunc = this._updateAabb.bind(this);
		this._addedModel = false;
		this._autoPlayClip = null;
		this._clips = {};
		this._defaultClip = new SpriteAnimationClip(this, {
			name: this.entity.name,
			fps: 0,
			loop: false,
			spriteAsset: null
		});
		this._currentClip = this._defaultClip;
	}

	set type(value) {
		if (this._type === value) return;
		this._type = value;

		if (this._type === SPRITETYPE_SIMPLE) {
			this.stop();
			this._currentClip = this._defaultClip;

			if (this.enabled && this.entity.enabled) {
				this._currentClip.frame = this.frame;

				if (this._currentClip.sprite) {
					this._showModel();
				} else {
					this._hideModel();
				}
			}
		} else if (this._type === SPRITETYPE_ANIMATED) {
			this.stop();

			if (this._autoPlayClip) {
				this._tryAutoPlay();
			}

			if (this._currentClip && this._currentClip.isPlaying && this.enabled && this.entity.enabled) {
				this._showModel();
			} else {
				this._hideModel();
			}
		}
	}

	get type() {
		return this._type;
	}

	set frame(value) {
		this._currentClip.frame = value;
	}

	get frame() {
		return this._currentClip.frame;
	}

	set spriteAsset(value) {
		this._defaultClip.spriteAsset = value;
	}

	get spriteAsset() {
		return this._defaultClip._spriteAsset;
	}

	set sprite(value) {
		this._currentClip.sprite = value;
	}

	get sprite() {
		return this._currentClip.sprite;
	}

	set material(value) {
		this._material = value;

		if (this._meshInstance) {
			this._meshInstance.material = value;
		}
	}

	get material() {
		return this._material;
	}

	set color(value) {
		this._color.r = value.r;
		this._color.g = value.g;
		this._color.b = value.b;

		if (this._meshInstance) {
			this._colorUniform[0] = this._color.r;
			this._colorUniform[1] = this._color.g;
			this._colorUniform[2] = this._color.b;

			this._meshInstance.setParameter(PARAM_EMISSIVE, this._colorUniform);
		}
	}

	get color() {
		return this._color;
	}

	set opacity(value) {
		this._color.a = value;

		if (this._meshInstance) {
			this._meshInstance.setParameter(PARAM_OPACITY, value);
		}
	}

	get opacity() {
		return this._color.a;
	}

	set clips(value) {
		if (!value) {
			for (const name in this._clips) {
				this.removeClip(name);
			}

			return;
		}

		for (const name in this._clips) {
			let found = false;

			for (const key in value) {
				if (value[key].name === name) {
					found = true;
					this._clips[name].fps = value[key].fps;
					this._clips[name].loop = value[key].loop;

					if (value[key].hasOwnProperty('sprite')) {
						this._clips[name].sprite = value[key].sprite;
					} else if (value[key].hasOwnProperty('spriteAsset')) {
						this._clips[name].spriteAsset = value[key].spriteAsset;
					}

					break;
				}
			}

			if (!found) {
				this.removeClip(name);
			}
		}

		for (const key in value) {
			if (this._clips[value[key].name]) continue;
			this.addClip(value[key]);
		}

		if (this._autoPlayClip) {
			this._tryAutoPlay();
		}

		if (!this._currentClip || !this._currentClip.sprite) {
			this._hideModel();
		}
	}

	get clips() {
		return this._clips;
	}

	get currentClip() {
		return this._currentClip;
	}

	set speed(value) {
		this._speed = value;
	}

	get speed() {
		return this._speed;
	}

	set flipX(value) {
		if (this._flipX === value) return;
		this._flipX = value;

		this._updateTransform();
	}

	get flipX() {
		return this._flipX;
	}

	set flipY(value) {
		if (this._flipY === value) return;
		this._flipY = value;

		this._updateTransform();
	}

	get flipY() {
		return this._flipY;
	}

	set width(value) {
		if (value === this._width) return;
		this._width = value;
		this._outerScale.x = this._width;

		if (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_TILED || this.sprite.renderMode === SPRITE_RENDERMODE_SLICED)) {
			this._updateTransform();
		}
	}

	get width() {
		return this._width;
	}

	set height(value) {
		if (value === this._height) return;
		this._height = value;
		this._outerScale.y = this.height;

		if (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_TILED || this.sprite.renderMode === SPRITE_RENDERMODE_SLICED)) {
			this._updateTransform();
		}
	}

	get height() {
		return this._height;
	}

	set batchGroupId(value) {
		if (this._batchGroupId === value) return;
		const prev = this._batchGroupId;
		this._batchGroupId = value;

		if (this.entity.enabled && prev >= 0) {
			this.system.app.batcher.remove(BatchGroup.SPRITE, prev, this.entity);
		}

		if (this.entity.enabled && value >= 0) {
			this.system.app.batcher.insert(BatchGroup.SPRITE, value, this.entity);
		} else {
			if (prev >= 0) {
				if (this._currentClip && this._currentClip.sprite && this.enabled && this.entity.enabled) {
					this._showModel();
				}
			}
		}
	}

	get batchGroupId() {
		return this._batchGroupId;
	}

	set autoPlayClip(value) {
		this._autoPlayClip = value instanceof SpriteAnimationClip ? value.name : value;

		this._tryAutoPlay();
	}

	get autoPlayClip() {
		return this._autoPlayClip;
	}

	set drawOrder(value) {
		this._drawOrder = value;

		if (this._meshInstance) {
			this._meshInstance.drawOrder = value;
		}
	}

	get drawOrder() {
		return this._drawOrder;
	}

	set layers(value) {
		if (this._addedModel) {
			this._hideModel();
		}

		this._layers = value;

		if (!this._meshInstance) {
			return;
		}

		if (this.enabled && this.entity.enabled) {
			this._showModel();
		}
	}

	get layers() {
		return this._layers;
	}

	get aabb() {
		if (this._meshInstance) {
			return this._meshInstance.aabb;
		}

		return null;
	}

	onEnable() {
		const app = this.system.app;
		const scene = app.scene;
		scene.on("set:layers", this._onLayersChanged, this);

		if (scene.layers) {
			scene.layers.on("add", this._onLayerAdded, this);
			scene.layers.on("remove", this._onLayerRemoved, this);
		}

		this._showModel();

		if (this._autoPlayClip) this._tryAutoPlay();

		if (this._batchGroupId >= 0) {
			app.batcher.insert(BatchGroup.SPRITE, this._batchGroupId, this.entity);
		}
	}

	onDisable() {
		const app = this.system.app;
		const scene = app.scene;
		scene.off("set:layers", this._onLayersChanged, this);

		if (scene.layers) {
			scene.layers.off("add", this._onLayerAdded, this);
			scene.layers.off("remove", this._onLayerRemoved, this);
		}

		this.stop();

		this._hideModel();

		if (this._batchGroupId >= 0) {
			app.batcher.remove(BatchGroup.SPRITE, this._batchGroupId, this.entity);
		}
	}

	onDestroy() {
		this._currentClip = null;

		if (this._defaultClip) {
			this._defaultClip._destroy();

			this._defaultClip = null;
		}

		for (const key in this._clips) {
			this._clips[key]._destroy();
		}

		this._clips = null;

		this._hideModel();

		this._model = null;

		if (this._node) {
			if (this._node.parent) this._node.parent.removeChild(this._node);
			this._node = null;
		}

		if (this._meshInstance) {
			this._meshInstance.material = null;
			this._meshInstance.mesh = null;
			this._meshInstance = null;
		}
	}

	_showModel() {
		if (this._addedModel) return;
		if (!this._meshInstance) return;
		const meshInstances = [this._meshInstance];

		for (let i = 0, len = this._layers.length; i < len; i++) {
			const layer = this.system.app.scene.layers.getLayerById(this._layers[i]);

			if (layer) {
				layer.addMeshInstances(meshInstances);
			}
		}

		this._addedModel = true;
	}

	_hideModel() {
		if (!this._addedModel || !this._meshInstance) return;
		const meshInstances = [this._meshInstance];

		for (let i = 0, len = this._layers.length; i < len; i++) {
			const layer = this.system.app.scene.layers.getLayerById(this._layers[i]);

			if (layer) {
				layer.removeMeshInstances(meshInstances);
			}
		}

		this._addedModel = false;
	}

	_showFrame(frame) {
		if (!this.sprite) return;
		const mesh = this.sprite.meshes[frame];

		if (!mesh) {
			if (this._meshInstance) {
				this._meshInstance.mesh = null;
				this._meshInstance.visible = false;
			}

			return;
		}

		let material;

		if (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED) {
			material = this.system.default9SlicedMaterialSlicedMode;
		} else if (this.sprite.renderMode === SPRITE_RENDERMODE_TILED) {
			material = this.system.default9SlicedMaterialTiledMode;
		} else {
			material = this.system.defaultMaterial;
		}

		if (!this._meshInstance) {
			this._meshInstance = new MeshInstance(mesh, this._material, this._node);
			this._meshInstance.castShadow = false;
			this._meshInstance.receiveShadow = false;
			this._meshInstance.drawOrder = this._drawOrder;

			this._model.meshInstances.push(this._meshInstance);

			this._colorUniform[0] = this._color.r;
			this._colorUniform[1] = this._color.g;
			this._colorUniform[2] = this._color.b;

			this._meshInstance.setParameter(PARAM_EMISSIVE, this._colorUniform);

			this._meshInstance.setParameter(PARAM_OPACITY, this._color.a);

			if (this.enabled && this.entity.enabled) {
				this._showModel();
			}
		}

		if (this._meshInstance.material !== material) {
			this._meshInstance.material = material;
		}

		if (this._meshInstance.mesh !== mesh) {
			this._meshInstance.mesh = mesh;
			this._meshInstance.visible = true;
			this._meshInstance._aabbVer = -1;
		}

		if (this.sprite.atlas && this.sprite.atlas.texture) {
			this._meshInstance.setParameter(PARAM_EMISSIVE_MAP, this.sprite.atlas.texture);

			this._meshInstance.setParameter(PARAM_OPACITY_MAP, this.sprite.atlas.texture);
		} else {
			this._meshInstance.deleteParameter(PARAM_EMISSIVE_MAP);

			this._meshInstance.deleteParameter(PARAM_OPACITY_MAP);
		}

		if (this.sprite.atlas && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED)) {
			this._meshInstance._updateAabbFunc = this._updateAabbFunc;
			const frameData = this.sprite.atlas.frames[this.sprite.frameKeys[frame]];

			if (frameData) {
				const borderWidthScale = 2 / frameData.rect.z;
				const borderHeightScale = 2 / frameData.rect.w;

				this._innerOffset.set(frameData.border.x * borderWidthScale, frameData.border.y * borderHeightScale, frameData.border.z * borderWidthScale, frameData.border.w * borderHeightScale);

				const tex = this.sprite.atlas.texture;

				this._atlasRect.set(frameData.rect.x / tex.width, frameData.rect.y / tex.height, frameData.rect.z / tex.width, frameData.rect.w / tex.height);
			} else {
				this._innerOffset.set(0, 0, 0, 0);
			}

			this._innerOffsetUniform[0] = this._innerOffset.x;
			this._innerOffsetUniform[1] = this._innerOffset.y;
			this._innerOffsetUniform[2] = this._innerOffset.z;
			this._innerOffsetUniform[3] = this._innerOffset.w;

			this._meshInstance.setParameter(PARAM_INNER_OFFSET, this._innerOffsetUniform);

			this._atlasRectUniform[0] = this._atlasRect.x;
			this._atlasRectUniform[1] = this._atlasRect.y;
			this._atlasRectUniform[2] = this._atlasRect.z;
			this._atlasRectUniform[3] = this._atlasRect.w;

			this._meshInstance.setParameter(PARAM_ATLAS_RECT, this._atlasRectUniform);
		} else {
			this._meshInstance._updateAabbFunc = null;
		}

		this._updateTransform();
	}

	_updateTransform() {
		let scaleX = this.flipX ? -1 : 1;
		let scaleY = this.flipY ? -1 : 1;
		let posX = 0;
		let posY = 0;

		if (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED)) {
			let w = 1;
			let h = 1;

			if (this.sprite.atlas) {
				const frameData = this.sprite.atlas.frames[this.sprite.frameKeys[this.frame]];

				if (frameData) {
					w = frameData.rect.z;
					h = frameData.rect.w;
					posX = (0.5 - frameData.pivot.x) * this._width;
					posY = (0.5 - frameData.pivot.y) * this._height;
				}
			}

			const scaleMulX = w / this.sprite.pixelsPerUnit;
			const scaleMulY = h / this.sprite.pixelsPerUnit;

			this._outerScale.set(Math.max(this._width, this._innerOffset.x * scaleMulX), Math.max(this._height, this._innerOffset.y * scaleMulY));

			scaleX *= scaleMulX;
			scaleY *= scaleMulY;
			this._outerScale.x /= scaleMulX;
			this._outerScale.y /= scaleMulY;
			scaleX *= math.clamp(this._width / (this._innerOffset.x * scaleMulX), 0.0001, 1);
			scaleY *= math.clamp(this._height / (this._innerOffset.y * scaleMulY), 0.0001, 1);

			if (this._meshInstance) {
				this._outerScaleUniform[0] = this._outerScale.x;
				this._outerScaleUniform[1] = this._outerScale.y;

				this._meshInstance.setParameter(PARAM_OUTER_SCALE, this._outerScaleUniform);
			}
		}

		this._node.setLocalScale(scaleX, scaleY, 1);

		this._node.setLocalPosition(posX, posY, 0);
	}

	_updateAabb(aabb) {
		aabb.center.set(0, 0, 0);
		aabb.halfExtents.set(this._outerScale.x * 0.5, this._outerScale.y * 0.5, 0.001);
		aabb.setFromTransformedAabb(aabb, this._node.getWorldTransform());
		return aabb;
	}

	_tryAutoPlay() {
		if (!this._autoPlayClip) return;
		if (this.type !== SPRITETYPE_ANIMATED) return;
		const clip = this._clips[this._autoPlayClip];

		if (clip && !clip.isPlaying && (!this._currentClip || !this._currentClip.isPlaying)) {
			if (this.enabled && this.entity.enabled) {
				this.play(clip.name);
			}
		}
	}

	_onLayersChanged(oldComp, newComp) {
		oldComp.off("add", this.onLayerAdded, this);
		oldComp.off("remove", this.onLayerRemoved, this);
		newComp.on("add", this.onLayerAdded, this);
		newComp.on("remove", this.onLayerRemoved, this);

		if (this.enabled && this.entity.enabled) {
			this._showModel();
		}
	}

	_onLayerAdded(layer) {
		const index = this.layers.indexOf(layer.id);
		if (index < 0) return;

		if (this._addedModel && this.enabled && this.entity.enabled && this._meshInstance) {
			layer.addMeshInstances([this._meshInstance]);
		}
	}

	_onLayerRemoved(layer) {
		if (!this._meshInstance) return;
		const index = this.layers.indexOf(layer.id);
		if (index < 0) return;
		layer.removeMeshInstances([this._meshInstance]);
	}

	removeModelFromLayers() {
		for (let i = 0; i < this.layers.length; i++) {
			const layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
			if (!layer) continue;
			layer.removeMeshInstances([this._meshInstance]);
		}
	}

	addClip(data) {
		const clip = new SpriteAnimationClip(this, {
			name: data.name,
			fps: data.fps,
			loop: data.loop,
			spriteAsset: data.spriteAsset
		});
		this._clips[data.name] = clip;
		if (clip.name && clip.name === this._autoPlayClip) this._tryAutoPlay();
		return clip;
	}

	removeClip(name) {
		delete this._clips[name];
	}

	clip(name) {
		return this._clips[name];
	}

	play(name) {
		const clip = this._clips[name];
		const current = this._currentClip;

		if (current && current !== clip) {
			current._playing = false;
		}

		this._currentClip = clip;

		if (this._currentClip) {
			this._currentClip = clip;

			this._currentClip.play();
		}

		return clip;
	}

	pause() {
		if (this._currentClip === this._defaultClip) return;

		if (this._currentClip.isPlaying) {
			this._currentClip.pause();
		}
	}

	resume() {
		if (this._currentClip === this._defaultClip) return;

		if (this._currentClip.isPaused) {
			this._currentClip.resume();
		}
	}

	stop() {
		if (this._currentClip === this._defaultClip) return;

		this._currentClip.stop();
	}

}

class SpriteComponentData {
	constructor() {
		this.enabled = true;
	}

}

const _schema$1 = ['enabled'];

class SpriteComponentSystem extends ComponentSystem {
	constructor(app) {
		super(app);
		this.id = 'sprite';
		this.ComponentType = SpriteComponent;
		this.DataType = SpriteComponentData;
		this.schema = _schema$1;
		this._defaultTexture = null;
		this._defaultMaterial = null;
		this._default9SlicedMaterialSlicedMode = null;
		this._default9SlicedMaterialTiledMode = null;
		this.app.systems.on('update', this.onUpdate, this);
		this.on('beforeremove', this.onBeforeRemove, this);
	}

	set defaultMaterial(material) {
		this._defaultMaterial = material;
	}

	get defaultMaterial() {
		if (!this._defaultMaterial) {
			const texture = new Texture(this.app.graphicsDevice, {
				width: 1,
				height: 1,
				format: PIXELFORMAT_R8_G8_B8_A8
			});
			const pixels = new Uint8Array(texture.lock());
			pixels[0] = pixels[1] = pixels[2] = pixels[3] = 255;
			texture.name = 'sprite';
			texture.unlock();
			const material = new StandardMaterial();
			material.diffuse.set(0, 0, 0);
			material.emissive.set(0.5, 0.5, 0.5);
			material.emissiveMap = texture;
			material.emissiveMapTint = true;
			material.opacityMap = texture;
			material.opacityMapChannel = "a";
			material.opacityTint = true;
			material.opacity = 0;
			material.useLighting = false;
			material.useGammaTonemap = false;
			material.useFog = false;
			material.useSkybox = false;
			material.blendType = BLEND_PREMULTIPLIED;
			material.depthWrite = false;
			material.pixelSnap = false;
			material.cull = CULLFACE_NONE;
			material.update();
			this._defaultTexture = texture;
			this._defaultMaterial = material;
		}

		return this._defaultMaterial;
	}

	set default9SlicedMaterialSlicedMode(material) {
		this._default9SlicedMaterialSlicedMode = material;
	}

	get default9SlicedMaterialSlicedMode() {
		if (!this._default9SlicedMaterialSlicedMode) {
			const material = this.defaultMaterial.clone();
			material.nineSlicedMode = SPRITE_RENDERMODE_SLICED;
			material.update();
			this._default9SlicedMaterialSlicedMode = material;
		}

		return this._default9SlicedMaterialSlicedMode;
	}

	set default9SlicedMaterialTiledMode(material) {
		this._default9SlicedMaterialTiledMode = material;
	}

	get default9SlicedMaterialTiledMode() {
		if (!this._default9SlicedMaterialTiledMode) {
			const material = this.defaultMaterial.clone();
			material.nineSlicedMode = SPRITE_RENDERMODE_TILED;
			material.update();
			this._default9SlicedMaterialTiledMode = material;
		}

		return this._default9SlicedMaterialTiledMode;
	}

	destroy() {
		super.destroy();
		this.app.systems.off('update', this.onUpdate, this);

		if (this._defaultTexture) {
			this._defaultTexture.destroy();

			this._defaultTexture = null;
		}
	}

	initializeComponentData(component, data, properties) {
		if (data.enabled !== undefined) {
			component.enabled = data.enabled;
		}

		component.type = data.type;

		if (data.layers && Array.isArray(data.layers)) {
			component.layers = data.layers.slice(0);
		}

		if (data.drawOrder !== undefined) {
			component.drawOrder = data.drawOrder;
		}

		if (data.color !== undefined) {
			if (data.color instanceof Color) {
				component.color.set(data.color.r, data.color.g, data.color.b, data.opacity !== undefined ? data.opacity : 1);
			} else {
				component.color.set(data.color[0], data.color[1], data.color[2], data.opacity !== undefined ? data.opacity : 1);
			}

			component.color = component.color;
		}

		if (data.opacity !== undefined) {
			component.opacity = data.opacity;
		}

		if (data.flipX !== undefined) {
			component.flipX = data.flipX;
		}

		if (data.flipY !== undefined) {
			component.flipY = data.flipY;
		}

		if (data.width !== undefined) {
			component.width = data.width;
		}

		if (data.height !== undefined) {
			component.height = data.height;
		}

		if (data.spriteAsset !== undefined) {
			component.spriteAsset = data.spriteAsset;
		}

		if (data.sprite) {
			component.sprite = data.sprite;
		}

		if (data.frame !== undefined) {
			component.frame = data.frame;
		}

		if (data.clips) {
			for (const name in data.clips) {
				component.addClip(data.clips[name]);
			}
		}

		if (data.speed !== undefined) {
			component.speed = data.speed;
		}

		if (data.autoPlayClip) {
			component.autoPlayClip = data.autoPlayClip;
		}

		component.batchGroupId = data.batchGroupId === undefined || data.batchGroupId === null ? -1 : data.batchGroupId;
		super.initializeComponentData(component, data, properties);
	}

	cloneComponent(entity, clone) {
		const source = entity.sprite;
		return this.addComponent(clone, {
			enabled: source.enabled,
			type: source.type,
			spriteAsset: source.spriteAsset,
			sprite: source.sprite,
			frame: source.frame,
			color: source.color.clone(),
			opacity: source.opacity,
			flipX: source.flipX,
			flipY: source.flipY,
			speed: source.speed,
			clips: source.clips,
			autoPlayClip: source.autoPlayClip,
			batchGroupId: source.batchGroupId,
			drawOrder: source.drawOrder,
			layers: source.layers.slice(0)
		});
	}

	onUpdate(dt) {
		const components = this.store;

		for (const id in components) {
			if (components.hasOwnProperty(id)) {
				const component = components[id];

				if (component.data.enabled && component.entity.enabled) {
					const sprite = component.entity.sprite;

					if (sprite._currentClip) {
						sprite._currentClip._update(dt);
					}
				}
			}
		}
	}

	onBeforeRemove(entity, component) {
		component.onDestroy();
	}

}

Component._buildAccessors(SpriteComponent.prototype, _schema$1);

class ZoneComponent extends Component {
	constructor(system, entity) {
		super(system, entity);
		this._oldState = true;
		this._size = new Vec3();
		this.on('set_enabled', this._onSetEnabled, this);
	}

	set size(data) {
		if (data instanceof Vec3) {
			this._size.copy(data);
		} else if (data instanceof Array && data.length >= 3) {
			this.size.set(data[0], data[1], data[2]);
		}
	}

	get size() {
		return this._size;
	}

	onEnable() {
		this._checkState();
	}

	onDisable() {
		this._checkState();
	}

	_onSetEnabled(prop, old, value) {
		this._checkState();
	}

	_checkState() {
		const state = this.enabled && this.entity.enabled;
		if (state === this._oldState) return;
		this._oldState = state;
		this.fire('enable');
		this.fire('state', this.enabled);
	}

	_onBeforeRemove() {
		this.fire('remove');
	}

}

class ZoneComponentData {
	constructor() {
		this.enabled = true;
	}

}

const _schema = ['enabled'];

class ZoneComponentSystem extends ComponentSystem {
	constructor(app) {
		super(app);
		this.id = 'zone';
		this.ComponentType = ZoneComponent;
		this.DataType = ZoneComponentData;
		this.schema = _schema;
		this.on('beforeremove', this._onBeforeRemove, this);
	}

	initializeComponentData(component, data, properties) {
		component.enabled = data.hasOwnProperty('enabled') ? !!data.enabled : true;

		if (data.size) {
			if (data.size instanceof Vec3) {
				component.size.copy(data.size);
			} else if (data.size instanceof Array && data.size.length >= 3) {
				component.size.set(data.size[0], data.size[1], data.size[2]);
			}
		}
	}

	cloneComponent(entity, clone) {
		const data = {
			size: entity.zone.size
		};
		return this.addComponent(clone, data);
	}

	_onBeforeRemove(entity, component) {
		component._onBeforeRemove();
	}

}

Component._buildAccessors(ZoneComponent.prototype, _schema);

class ApplicationStats {
	constructor(device) {
		this.frame = {
			fps: 0,
			ms: 0,
			dt: 0,
			updateStart: 0,
			updateTime: 0,
			renderStart: 0,
			renderTime: 0,
			physicsStart: 0,
			physicsTime: 0,
			cullTime: 0,
			sortTime: 0,
			skinTime: 0,
			morphTime: 0,
			instancingTime: 0,
			triangles: 0,
			otherPrimitives: 0,
			shaders: 0,
			materials: 0,
			cameras: 0,
			shadowMapUpdates: 0,
			shadowMapTime: 0,
			depthMapTime: 0,
			forwardTime: 0,
			lightClustersTime: 0,
			lightClusters: 0,
			_timeToCountFrames: 0,
			_fpsAccum: 0
		};
		this.drawCalls = {
			forward: 0,
			depth: 0,
			shadow: 0,
			immediate: 0,
			misc: 0,
			total: 0,
			skinned: 0,
			instanced: 0,
			removedByInstancing: 0
		};
		this.misc = {
			renderTargetCreationTime: 0
		};
		this.particles = {
			updatesPerFrame: 0,
			_updatesPerFrame: 0,
			frameTime: 0,
			_frameTime: 0
		};
		this.shaders = device._shaderStats;
		this.vram = device._vram;
		Object.defineProperty(this.vram, 'totalUsed', {
			get: function () {
				return this.tex + this.vb + this.ib;
			}
		});
		Object.defineProperty(this.vram, 'geom', {
			get: function () {
				return this.vb + this.ib;
			}
		});
	}

	get scene() {
		return getApplication().scene._stats;
	}

	get lightmapper() {
		return getApplication().lightmapper.stats;
	}

	get batcher() {
		return getApplication().batcher._stats;
	}

}

class SceneRegistryItem {
	constructor(name, url) {
		this.name = name;
		this.url = url;
		this.data = null;
		this._loading = false;
		this._onLoadedCallbacks = [];
	}

	get loaded() {
		return !!this.data;
	}

	get loading() {
		return this._loading;
	}

}

class SceneRegistry {
	constructor(app) {
		this._app = app;
		this._list = [];
		this._index = {};
		this._urlIndex = {};
	}

	destroy() {
		this._app = null;
	}

	list() {
		return this._list;
	}

	add(name, url) {
		if (this._index.hasOwnProperty(name)) {
			return false;
		}

		const item = new SceneRegistryItem(name, url);

		const i = this._list.push(item);

		this._index[item.name] = i - 1;
		this._urlIndex[item.url] = i - 1;
		return true;
	}

	find(name) {
		if (this._index.hasOwnProperty(name)) {
			return this._list[this._index[name]];
		}

		return null;
	}

	findByUrl(url) {
		if (this._urlIndex.hasOwnProperty(url)) {
			return this._list[this._urlIndex[url]];
		}

		return null;
	}

	remove(name) {
		if (this._index.hasOwnProperty(name)) {
			const idx = this._index[name];
			let item = this._list[idx];
			delete this._urlIndex[item.url];
			delete this._index[name];

			this._list.splice(idx, 1);

			for (let i = 0; i < this._list.length; i++) {
				item = this._list[i];
				this._index[item.name] = i;
				this._urlIndex[item.url] = i;
			}
		}
	}

	_loadSceneData(sceneItem, storeInCache, callback) {
		let url = sceneItem;

		if (sceneItem instanceof SceneRegistryItem) {
			url = sceneItem.url;
		} else {
			sceneItem = this.findByUrl(url);

			if (!sceneItem) {
				sceneItem = new SceneRegistryItem('Untitled', url);
			}
		}

		if (!sceneItem.url) {
			callback("URL or SceneRegistryItem is null when loading a scene");
			return;
		}

		if (sceneItem.loaded) {
			callback(null, sceneItem);
			return;
		}

		const handler = this._app.loader.getHandler("hierarchy");

		if (this._app.assets && this._app.assets.prefix && !ABSOLUTE_URL.test(url)) {
			url = path.join(this._app.assets.prefix, url);
		}

		sceneItem._onLoadedCallbacks.push(callback);

		if (!sceneItem._loading) {
			handler.load(url, function (err, data) {
				sceneItem.data = data;
				sceneItem._loading = false;

				for (let i = 0; i < sceneItem._onLoadedCallbacks.length; i++) {
					sceneItem._onLoadedCallbacks[i](err, sceneItem);
				}

				if (!storeInCache) {
					sceneItem.data = null;
				}

				sceneItem._onLoadedCallbacks.length = 0;
			});
		}

		sceneItem._loading = true;
	}

	loadSceneData(sceneItem, callback) {
		this._loadSceneData(sceneItem, true, callback);
	}

	unloadSceneData(sceneItem) {
		if (typeof sceneItem === 'string') {
			sceneItem = this.findByUrl(sceneItem);
		}

		if (sceneItem) {
			sceneItem.data = null;
		}
	}

	loadSceneHierarchy(sceneItem, callback) {
		const self = this;

		const handler = this._app.loader.getHandler("hierarchy");

		this._loadSceneData(sceneItem, false, function (err, sceneItem) {
			if (err) {
				if (callback) callback(err);
				return;
			}

			const url = sceneItem.url;
			const data = sceneItem.data;

			const _loaded = function _loaded() {
				self._app.systems.script.preloading = true;
				const entity = handler.open(url, data);
				self._app.systems.script.preloading = false;

				self._app.loader.clearCache(url, "hierarchy");

				self._app.root.addChild(entity);

				self._app.systems.fire('initialize', entity);

				self._app.systems.fire('postInitialize', entity);

				self._app.systems.fire('postPostInitialize', entity);

				if (callback) callback(err, entity);
			};

			self._app._preloadScripts(data, _loaded);
		});
	}

	loadSceneSettings(sceneItem, callback) {
		const self = this;

		this._loadSceneData(sceneItem, false, function (err, sceneItem) {
			if (!err) {
				self._app.applySceneSettings(sceneItem.data.settings);

				if (callback) {
					callback(null);
				}
			} else {
				if (callback) {
					callback(err);
				}
			}
		});
	}

	loadScene(url, callback) {
		const self = this;

		const handler = this._app.loader.getHandler("scene");

		if (this._app.assets && this._app.assets.prefix && !ABSOLUTE_URL.test(url)) {
			url = path.join(this._app.assets.prefix, url);
		}

		handler.load(url, function (err, data) {
			if (!err) {
				const _loaded = function _loaded() {
					self._app.systems.script.preloading = true;
					const scene = handler.open(url, data);
					const sceneItem = self.findByUrl(url);

					if (sceneItem && !sceneItem.loaded) {
						sceneItem.data = data;
					}

					self._app.systems.script.preloading = false;

					self._app.loader.clearCache(url, "scene");

					self._app.loader.patch({
						resource: scene,
						type: "scene"
					}, self._app.assets);

					self._app.root.addChild(scene.root);

					if (self._app.systems.rigidbody && typeof Ammo !== 'undefined') {
						self._app.systems.rigidbody.gravity.set(scene._gravity.x, scene._gravity.y, scene._gravity.z);
					}

					if (callback) {
						callback(null, scene);
					}
				};

				self._app._preloadScripts(data, _loaded);
			} else {
				if (callback) {
					callback(err);
				}
			}
		});
	}

}

class SceneDepth {
	constructor(application) {
		this.application = application;
		this.device = application.graphicsDevice;
		this.clearOptions = null;
		this.layer = null;
		this.init();
	}

	allocateTexture(device, name, format) {
		const texture = new Texture(device, {
			format: format,
			width: device.width,
			height: device.height,
			mipmaps: false,
			minFilter: FILTER_NEAREST,
			magFilter: FILTER_NEAREST,
			addressU: ADDRESS_CLAMP_TO_EDGE,
			addressV: ADDRESS_CLAMP_TO_EDGE
		});
		texture.name = name;
		device.scope.resolve("uDepthMap").setValue(texture);
		return texture;
	}

	allocateRenderTarget(renderTarget, device, name, format, isDepth) {
		const buffer = this.allocateTexture(device, name, format);

		if (renderTarget) {
			renderTarget.destroyFrameBuffers();

			if (isDepth) {
				renderTarget._depthBuffer = buffer;
			} else {
				renderTarget._colorBuffer = buffer;
			}
		} else {
			renderTarget = new RenderTarget({
				colorBuffer: isDepth ? null : buffer,
				depthBuffer: isDepth ? buffer : null,
				depth: !isDepth,
				stencil: device.supportsStencil,
				autoResolve: false
			});
		}

		return renderTarget;
	}

	releaseRenderTarget(rt) {
		if (rt) {
			rt.destroyTextureBuffers();
			rt.destroy();
		}
	}

	initWebGl2() {
		const app = this.application;
		const self = this;
		this.clearOptions = {
			flags: 0
		};
		this.layer = new Layer({
			enabled: false,
			name: "Depth",
			id: LAYERID_DEPTH,
			onEnable: function () {
				self.releaseRenderTarget(this.renderTarget);
				this.renderTarget = self.allocateRenderTarget(this.renderTarget, app.graphicsDevice, "rt-depth2", PIXELFORMAT_DEPTHSTENCIL, true);
			},
			onDisable: function () {
				self.releaseRenderTarget(this.renderTarget);
				this.renderTarget = null;
			},
			onPreRenderOpaque: function (cameraPass) {
				const gl = app.graphicsDevice.gl;
				this.srcFbo = gl.getParameter(gl.FRAMEBUFFER_BINDING);

				if (this.renderTarget.width !== app.graphicsDevice.width || this.renderTarget.height !== app.graphicsDevice.height) {
					this.onEnable();
				}

				this.oldClear = this.cameras[cameraPass].camera._clearOptions;
				this.cameras[cameraPass].camera._clearOptions = self.clearOptions;
			},
			onPostRenderOpaque: function (cameraPass) {
				if (this.renderTarget) {
					this.cameras[cameraPass].camera._clearOptions = this.oldClear;
					app.graphicsDevice.setRenderTarget(this.renderTarget);
					app.graphicsDevice.updateBegin();
					const gl = app.graphicsDevice.gl;
					gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this.srcFbo);
					gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.renderTarget._glFrameBuffer);
					gl.blitFramebuffer(0, 0, this.renderTarget.width, this.renderTarget.height, 0, 0, this.renderTarget.width, this.renderTarget.height, gl.DEPTH_BUFFER_BIT, gl.NEAREST);
				}
			}
		});
	}

	initWebGl1() {
		const app = this.application;
		const self = this;
		this.clearOptions = {
			color: [254.0 / 255, 254.0 / 255, 254.0 / 255, 254.0 / 255],
			depth: 1.0,
			flags: CLEARFLAG_COLOR | CLEARFLAG_DEPTH
		};
		this.layer = new Layer({
			enabled: false,
			name: "Depth",
			id: LAYERID_DEPTH,
			shaderPass: SHADER_DEPTH,
			onEnable: function () {
				self.releaseRenderTarget(this.renderTarget);
				this.renderTarget = self.allocateRenderTarget(this.renderTarget, app.graphicsDevice, "rt-depth1", PIXELFORMAT_R8_G8_B8_A8, false);
			},
			onDisable: function () {
				self.releaseRenderTarget(this.renderTarget);
				this.renderTarget = null;
			},
			onPostCull: function (cameraPass) {
				const visibleObjects = this.instances.visibleOpaque[cameraPass];
				const visibleList = visibleObjects.list;
				const layerComposition = app.scene.layers;
				const subLayerEnabled = layerComposition.subLayerEnabled;
				const isTransparent = layerComposition.subLayerList;
				const rt = app.scene.layers.getLayerById(LAYERID_WORLD).renderTarget;
				const cam = this.cameras[cameraPass];
				let visibleLength = 0;
				const layers = layerComposition.layerList;

				for (let i = 0; i < layers.length; i++) {
					const layer = layers[i];
					if (layer === this) break;
					if (layer.renderTarget !== rt || !layer.enabled || !subLayerEnabled[i]) continue;
					const layerCamId = layer.cameras.indexOf(cam);
					if (layerCamId < 0) continue;
					const transparent = isTransparent[i];
					let layerVisibleList = transparent ? layer.instances.visibleTransparent[layerCamId] : layer.instances.visibleOpaque[layerCamId];
					const layerVisibleListLength = layerVisibleList.length;
					layerVisibleList = layerVisibleList.list;

					for (let j = 0; j < layerVisibleListLength; j++) {
						const drawCall = layerVisibleList[j];

						if (drawCall.material && drawCall.material.depthWrite && !drawCall._noDepthDrawGl1) {
							visibleList[visibleLength] = drawCall;
							visibleLength++;
						}
					}
				}

				visibleObjects.length = visibleLength;
			},
			onPreRenderOpaque: function (cameraPass) {
				if (this.renderTarget.width !== app.graphicsDevice.width || this.renderTarget.height !== app.graphicsDevice.height) {
					this.onEnable();
				}

				this.oldClear = this.cameras[cameraPass].camera._clearOptions;
				this.cameras[cameraPass].camera._clearOptions = self.clearOptions;
			},
			onDrawCall: function () {
				app.graphicsDevice.setColorWrite(true, true, true, true);
			},
			onPostRenderOpaque: function (cameraPass) {
				if (!this.renderTarget) return;
				this.cameras[cameraPass].camera._clearOptions = this.oldClear;
			}
		});
	}

	init() {
		if (this.device.webgl2) {
			this.initWebGl2();
		} else {
			this.initWebGl1();
		}
	}

	patch(layer) {
		layer.onEnable = this.layer.onEnable;
		layer.onDisable = this.layer.onDisable;
		layer.onPreRenderOpaque = this.layer.onPreRenderOpaque;
		layer.onPostRenderOpaque = this.layer.onPostRenderOpaque;
		layer.shaderPass = this.layer.shaderPass;
		layer.onPostCull = this.layer.onPostCull;
		layer.onDrawCall = this.layer.onDrawCall;
	}

}

class Progress {
	constructor(length) {
		this.length = length;
		this.count = 0;
	}

	inc() {
		this.count++;
	}

	done() {
		return this.count === this.length;
	}

}

let app = null;

class Application extends EventHandler {
	constructor(canvas, options = {}) {
		super();
		Application._applications[canvas.id] = this;
		setApplication(this);
		app = this;
		this._destroyRequested = false;
		this._inFrameUpdate = false;
		this._time = 0;
		this.timeScale = 1;
		this.maxDeltaTime = 0.1;
		this.frame = 0;
		this.autoRender = true;
		this.renderNextFrame = false;
		this.useLegacyScriptAttributeCloning = script.legacy;
		this._librariesLoaded = false;
		this._fillMode = FILLMODE_KEEP_ASPECT;
		this._resolutionMode = RESOLUTION_FIXED;
		this._allowResize = true;
		this.context = this;
		if (!options.graphicsDeviceOptions) options.graphicsDeviceOptions = {};

		if (platform.browser && !!navigator.xr) {
			options.graphicsDeviceOptions.xrCompatible = true;
		}

		options.graphicsDeviceOptions.alpha = options.graphicsDeviceOptions.alpha || false;
		this.graphicsDevice = new WebglGraphicsDevice(canvas, options.graphicsDeviceOptions);

		this._initDefaultMaterial();

		this.stats = new ApplicationStats(this.graphicsDevice);
		this._soundManager = new SoundManager(options);
		this.loader = new ResourceLoader(this);
		LightsBuffer.init(this.graphicsDevice);
		this._entityIndex = {};
		this.scene = new Scene(this.graphicsDevice);

		this._registerSceneImmediate(this.scene);

		this.root = new Entity();
		this.root._enabledInHierarchy = true;
		this.assets = new AssetRegistry(this.loader);
		if (options.assetPrefix) this.assets.prefix = options.assetPrefix;
		this.bundles = new BundleRegistry(this.assets);
		this.enableBundles = typeof TextDecoder !== 'undefined';
		this.scriptsOrder = options.scriptsOrder || [];
		this.scripts = new ScriptRegistry(this);
		this.i18n = new I18n(this);
		this.scenes = new SceneRegistry(this);
		const self = this;
		this.defaultLayerWorld = new Layer({
			name: "World",
			id: LAYERID_WORLD
		});
		this.sceneDepth = new SceneDepth(this);
		this.defaultLayerDepth = this.sceneDepth.layer;
		this.defaultLayerSkybox = new Layer({
			enabled: true,
			name: "Skybox",
			id: LAYERID_SKYBOX,
			opaqueSortMode: SORTMODE_NONE
		});
		this.defaultLayerUi = new Layer({
			enabled: true,
			name: "UI",
			id: LAYERID_UI,
			transparentSortMode: SORTMODE_MANUAL,
			passThrough: false
		});
		this.defaultLayerImmediate = new Layer({
			enabled: true,
			name: "Immediate",
			id: LAYERID_IMMEDIATE,
			opaqueSortMode: SORTMODE_NONE,
			passThrough: true
		});
		const defaultLayerComposition = new LayerComposition("default");
		defaultLayerComposition.pushOpaque(this.defaultLayerWorld);
		defaultLayerComposition.pushOpaque(this.defaultLayerDepth);
		defaultLayerComposition.pushOpaque(this.defaultLayerSkybox);
		defaultLayerComposition.pushTransparent(this.defaultLayerWorld);
		defaultLayerComposition.pushOpaque(this.defaultLayerImmediate);
		defaultLayerComposition.pushTransparent(this.defaultLayerImmediate);
		defaultLayerComposition.pushTransparent(this.defaultLayerUi);
		this.scene.layers = defaultLayerComposition;
		this.scene.on('set:layers', function (oldComp, newComp) {
			const list = newComp.layerList;
			let layer;

			for (let i = 0; i < list.length; i++) {
				layer = list[i];

				switch (layer.id) {
					case LAYERID_DEPTH:
						self.sceneDepth.patch(layer);
						break;

					case LAYERID_UI:
						layer.passThrough = self.defaultLayerUi.passThrough;
						break;

					case LAYERID_IMMEDIATE:
						layer.passThrough = self.defaultLayerImmediate.passThrough;
						break;
				}
			}
		});
		AreaLightLuts.createPlaceholder(this.graphicsDevice);
		this.renderer = new ForwardRenderer(this.graphicsDevice);
		this.renderer.scene = this.scene;
		this.lightmapper = new Lightmapper(this.graphicsDevice, this.root, this.scene, this.renderer, this.assets);
		this.once('prerender', this._firstBake, this);
		this.batcher = new BatchManager(this.graphicsDevice, this.root, this.scene);
		this.once('prerender', this._firstBatch, this);
		this.keyboard = options.keyboard || null;
		this.mouse = options.mouse || null;
		this.touch = options.touch || null;
		this.gamepads = options.gamepads || null;
		this.elementInput = options.elementInput || null;
		if (this.elementInput) this.elementInput.app = this;
		this.vr = null;
		this.xr = new XrManager(this);
		if (this.elementInput) this.elementInput.attachSelectEvents();
		this._inTools = false;
		this._skyboxAsset = null;
		this._scriptPrefix = options.scriptPrefix || '';

		if (this.enableBundles) {
			this.loader.addHandler("bundle", new BundleHandler(this.assets));
		}

		this.loader.addHandler("animation", new AnimationHandler());
		this.loader.addHandler("animclip", new AnimClipHandler());
		this.loader.addHandler("animstategraph", new AnimStateGraphHandler());
		this.loader.addHandler("model", new ModelHandler(this.graphicsDevice));
		this.loader.addHandler("render", new RenderHandler(this.assets));
		this.loader.addHandler("material", new MaterialHandler(this));
		this.loader.addHandler("texture", new TextureHandler(this.graphicsDevice, this.assets, this.loader));
		this.loader.addHandler("text", new TextHandler());
		this.loader.addHandler("json", new JsonHandler());
		this.loader.addHandler("audio", new AudioHandler(this._soundManager));
		this.loader.addHandler("script", new ScriptHandler(this));
		this.loader.addHandler("scene", new SceneHandler(this));
		this.loader.addHandler("cubemap", new CubemapHandler(this.graphicsDevice, this.assets, this.loader));
		this.loader.addHandler("html", new HtmlHandler());
		this.loader.addHandler("css", new CssHandler());
		this.loader.addHandler("shader", new ShaderHandler());
		this.loader.addHandler("hierarchy", new HierarchyHandler(this));
		this.loader.addHandler("folder", new FolderHandler());
		this.loader.addHandler("font", new FontHandler(this.loader));
		this.loader.addHandler("binary", new BinaryHandler());
		this.loader.addHandler("textureatlas", new TextureAtlasHandler(this.loader));
		this.loader.addHandler("sprite", new SpriteHandler(this.assets, this.graphicsDevice));
		this.loader.addHandler("template", new TemplateHandler(this));
		this.loader.addHandler("container", new ContainerHandler(this.graphicsDevice, this.assets));
		this.systems = new ComponentSystemRegistry();
		this.systems.add(new RigidBodyComponentSystem(this));
		this.systems.add(new CollisionComponentSystem(this));
		this.systems.add(new JointComponentSystem(this));
		this.systems.add(new AnimationComponentSystem(this));
		this.systems.add(new AnimComponentSystem(this));
		this.systems.add(new ModelComponentSystem(this));
		this.systems.add(new RenderComponentSystem(this));
		this.systems.add(new CameraComponentSystem(this));
		this.systems.add(new LightComponentSystem(this));

		if (script.legacy) {
			this.systems.add(new ScriptLegacyComponentSystem(this));
		} else {
			this.systems.add(new ScriptComponentSystem(this));
		}

		this.systems.add(new AudioSourceComponentSystem(this, this._soundManager));
		this.systems.add(new SoundComponentSystem(this, this._soundManager));
		this.systems.add(new AudioListenerComponentSystem(this, this._soundManager));
		this.systems.add(new ParticleSystemComponentSystem(this));
		this.systems.add(new ScreenComponentSystem(this));
		this.systems.add(new ElementComponentSystem(this));
		this.systems.add(new ButtonComponentSystem(this));
		this.systems.add(new ScrollViewComponentSystem(this));
		this.systems.add(new ScrollbarComponentSystem(this));
		this.systems.add(new SpriteComponentSystem(this));
		this.systems.add(new LayoutGroupComponentSystem(this));
		this.systems.add(new LayoutChildComponentSystem(this));
		this.systems.add(new ZoneComponentSystem(this));
		this._visibilityChangeHandler = this.onVisibilityChange.bind(this);

		if (typeof document !== 'undefined') {
			if (document.hidden !== undefined) {
				this._hiddenAttr = 'hidden';
				document.addEventListener('visibilitychange', this._visibilityChangeHandler, false);
			} else if (document.mozHidden !== undefined) {
				this._hiddenAttr = 'mozHidden';
				document.addEventListener('mozvisibilitychange', this._visibilityChangeHandler, false);
			} else if (document.msHidden !== undefined) {
				this._hiddenAttr = 'msHidden';
				document.addEventListener('msvisibilitychange', this._visibilityChangeHandler, false);
			} else if (document.webkitHidden !== undefined) {
				this._hiddenAttr = 'webkitHidden';
				document.addEventListener('webkitvisibilitychange', this._visibilityChangeHandler, false);
			}
		}

		this.tick = makeTick(this);
	}

	static getApplication(id) {
		return id ? Application._applications[id] : getApplication();
	}

	_initDefaultMaterial() {
		const material = new StandardMaterial();
		material.name = "Default Material";
		material.shadingModel = SPECULAR_BLINN;
		setDefaultMaterial(this.graphicsDevice, material);
	}

	get fillMode() {
		return this._fillMode;
	}

	get resolutionMode() {
		return this._resolutionMode;
	}

	configure(url, callback) {
		http.get(url, (err, response) => {
			if (err) {
				callback(err);
				return;
			}

			const props = response.application_properties;
			const scenes = response.scenes;
			const assets = response.assets;

			this._parseApplicationProperties(props, err => {
				this._parseScenes(scenes);

				this._parseAssets(assets);

				if (!err) {
					callback(null);
				} else {
					callback(err);
				}
			});
		});
	}

	preload(callback) {
		this.fire("preload:start");
		const assets = this.assets.list({
			preload: true
		});
		const progress = new Progress(assets.length);
		let _done = false;

		const done = () => {
			if (!this.graphicsDevice) {
				return;
			}

			if (!_done && progress.done()) {
				_done = true;
				this.fire("preload:end");
				callback();
			}
		};

		const total = assets.length;

		if (progress.length) {
			const onAssetLoad = asset => {
				progress.inc();
				this.fire('preload:progress', progress.count / total);
				if (progress.done()) done();
			};

			const onAssetError = (err, asset) => {
				progress.inc();
				this.fire('preload:progress', progress.count / total);
				if (progress.done()) done();
			};

			for (let i = 0; i < assets.length; i++) {
				if (!assets[i].loaded) {
					assets[i].once('load', onAssetLoad);
					assets[i].once('error', onAssetError);
					this.assets.load(assets[i]);
				} else {
					progress.inc();
					this.fire("preload:progress", progress.count / total);
					if (progress.done()) done();
				}
			}
		} else {
			done();
		}
	}

	_preloadScripts(sceneData, callback) {
		if (!script.legacy) {
			callback();
			return;
		}

		this.systems.script.preloading = true;

		const scripts = this._getScriptReferences(sceneData);

		const l = scripts.length;
		const progress = new Progress(l);
		const regex = /^http(s)?:\/\//;

		if (l) {
			const onLoad = (err, ScriptType) => {
				if (err) console.error(err);
				progress.inc();

				if (progress.done()) {
					this.systems.script.preloading = false;
					callback();
				}
			};

			for (let i = 0; i < l; i++) {
				let scriptUrl = scripts[i];
				if (!regex.test(scriptUrl.toLowerCase()) && this._scriptPrefix) scriptUrl = path.join(self._scriptPrefix, scripts[i]);
				this.loader.load(scriptUrl, 'script', onLoad);
			}
		} else {
			this.systems.script.preloading = false;
			callback();
		}
	}

	_handleAreaLightDataProperty(prop) {
		const asset = this.assets.get(prop);

		if (asset) {
			this.setAreaLightLuts(asset);
		} else {
			this.assets.once('add:' + prop, this.setAreaLightLuts, this);
		}
	}

	_parseApplicationProperties(props, callback) {
		if (typeof props.maxAssetRetries === 'number' && props.maxAssetRetries > 0) {
			this.loader.enableRetry(props.maxAssetRetries);
		}

		if (!props.useDevicePixelRatio) props.useDevicePixelRatio = props.use_device_pixel_ratio;
		if (!props.resolutionMode) props.resolutionMode = props.resolution_mode;
		if (!props.fillMode) props.fillMode = props.fill_mode;
		this._width = props.width;
		this._height = props.height;

		if (props.useDevicePixelRatio) {
			this.graphicsDevice.maxPixelRatio = window.devicePixelRatio;
		}

		this.setCanvasResolution(props.resolutionMode, this._width, this._height);
		this.setCanvasFillMode(props.fillMode, this._width, this._height);

		if (props.layers && props.layerOrder) {
			const composition = new LayerComposition("application");
			const layers = {};

			for (const key in props.layers) {
				const data = props.layers[key];
				data.id = parseInt(key, 10);
				data.enabled = data.id !== LAYERID_DEPTH;
				layers[key] = new Layer(data);
			}

			for (let i = 0, len = props.layerOrder.length; i < len; i++) {
				const sublayer = props.layerOrder[i];
				const layer = layers[sublayer.layer];
				if (!layer) continue;

				if (sublayer.transparent) {
					composition.pushTransparent(layer);
				} else {
					composition.pushOpaque(layer);
				}

				composition.subLayerEnabled[i] = sublayer.enabled;
			}

			this.scene.layers = composition;
		}

		if (props.batchGroups) {
			for (let i = 0, len = props.batchGroups.length; i < len; i++) {
				const grp = props.batchGroups[i];
				this.batcher.addGroup(grp.name, grp.dynamic, grp.maxAabbSize, grp.id, grp.layers);
			}
		}

		if (props.i18nAssets) {
			this.i18n.assets = props.i18nAssets;
		}

		if (props.areaLightDataAsset) {
			this._handleAreaLightDataProperty(props.areaLightDataAsset);
		}

		this._loadLibraries(props.libraries, callback);
	}

	_loadLibraries(urls, callback) {
		const len = urls.length;
		let count = len;
		const regex = /^http(s)?:\/\//;

		if (len) {
			const onLoad = (err, script) => {
				count--;

				if (err) {
					callback(err);
				} else if (count === 0) {
					this.onLibrariesLoaded();
					callback(null);
				}
			};

			for (let i = 0; i < len; ++i) {
				let url = urls[i];
				if (!regex.test(url.toLowerCase()) && this._scriptPrefix) url = path.join(this._scriptPrefix, url);
				this.loader.load(url, 'script', onLoad);
			}
		} else {
			this.onLibrariesLoaded();
			callback(null);
		}
	}

	_parseScenes(scenes) {
		if (!scenes) return;

		for (let i = 0; i < scenes.length; i++) {
			this.scenes.add(scenes[i].name, scenes[i].url);
		}
	}

	_parseAssets(assets) {
		const list = [];
		const scriptsIndex = {};
		const bundlesIndex = {};

		if (!script.legacy) {
			for (let i = 0; i < this.scriptsOrder.length; i++) {
				const id = this.scriptsOrder[i];
				if (!assets[id]) continue;
				scriptsIndex[id] = true;
				list.push(assets[id]);
			}

			if (this.enableBundles) {
				for (const id in assets) {
					if (assets[id].type === 'bundle') {
						bundlesIndex[id] = true;
						list.push(assets[id]);
					}
				}
			}

			for (const id in assets) {
				if (scriptsIndex[id] || bundlesIndex[id]) continue;
				list.push(assets[id]);
			}
		} else {
			if (this.enableBundles) {
				for (const id in assets) {
					if (assets[id].type === 'bundle') {
						bundlesIndex[id] = true;
						list.push(assets[id]);
					}
				}
			}

			for (const id in assets) {
				if (bundlesIndex[id]) continue;
				list.push(assets[id]);
			}
		}

		for (let i = 0; i < list.length; i++) {
			const data = list[i];
			const asset = new Asset(data.name, data.type, data.file, data.data);
			asset.id = parseInt(data.id, 10);
			asset.preload = data.preload ? data.preload : false;
			asset.loaded = data.type === 'script' && data.data && data.data.loadingType > 0;
			asset.tags.add(data.tags);

			if (data.i18n) {
				for (const locale in data.i18n) {
					asset.addLocalizedAssetId(locale, data.i18n[locale]);
				}
			}

			this.assets.add(asset);
		}
	}

	_getScriptReferences(scene) {
		let priorityScripts = [];

		if (scene.settings.priority_scripts) {
			priorityScripts = scene.settings.priority_scripts;
		}

		const _scripts = [];
		const _index = {};

		for (let i = 0; i < priorityScripts.length; i++) {
			_scripts.push(priorityScripts[i]);

			_index[priorityScripts[i]] = true;
		}

		const entities = scene.entities;

		for (const key in entities) {
			if (!entities[key].components.script) {
				continue;
			}

			const scripts = entities[key].components.script.scripts;

			for (let i = 0; i < scripts.length; i++) {
				if (_index[scripts[i].url]) continue;

				_scripts.push(scripts[i].url);

				_index[scripts[i].url] = true;
			}
		}

		return _scripts;
	}

	start() {
		this.frame = 0;
		this.fire("start", {
			timestamp: now(),
			target: this
		});

		if (!this._librariesLoaded) {
			this.onLibrariesLoaded();
		}

		this.systems.fire('initialize', this.root);
		this.fire('initialize');
		this.systems.fire('postInitialize', this.root);
		this.systems.fire('postPostInitialize', this.root);
		this.fire('postinitialize');
		this.tick();
	}

	inputUpdate(dt) {
		if (this.controller) {
			this.controller.update(dt);
		}

		if (this.mouse) {
			this.mouse.update(dt);
		}

		if (this.keyboard) {
			this.keyboard.update(dt);
		}

		if (this.gamepads) {
			this.gamepads.update(dt);
		}
	}

	update(dt) {
		this.frame++;
		this.graphicsDevice.updateClientRect();
		if (this.vr) this.vr.poll();
		if (script.legacy) this.systems.fire('fixedUpdate', 1.0 / 60.0);
		this.systems.fire(this._inTools ? 'toolsUpdate' : 'update', dt);
		this.systems.fire('animationUpdate', dt);
		this.systems.fire('postUpdate', dt);
		this.fire("update", dt);
		this.inputUpdate(dt);
	}

	render() {
		this.fire('prerender');
		this.root.syncHierarchy();
		this.batcher.updateAll();
		this.renderer.renderComposition(this.scene.layers);
		this.fire('postrender');
	}

	_fillFrameStatsBasic(now, dt, ms) {
		const stats = this.stats.frame;
		stats.dt = dt;
		stats.ms = ms;

		if (now > stats._timeToCountFrames) {
			stats.fps = stats._fpsAccum;
			stats._fpsAccum = 0;
			stats._timeToCountFrames = now + 1000;
		} else {
			stats._fpsAccum++;
		}

		this.stats.drawCalls.total = this.graphicsDevice._drawCallsPerFrame;
		this.graphicsDevice._drawCallsPerFrame = 0;
	}

	_fillFrameStats() {
		let stats = this.stats.frame;
		stats.cameras = this.renderer._camerasRendered;
		stats.materials = this.renderer._materialSwitches;
		stats.shaders = this.graphicsDevice._shaderSwitchesPerFrame;
		stats.shadowMapUpdates = this.renderer._shadowMapUpdates;
		stats.shadowMapTime = this.renderer._shadowMapTime;
		stats.depthMapTime = this.renderer._depthMapTime;
		stats.forwardTime = this.renderer._forwardTime;
		const prims = this.graphicsDevice._primsPerFrame;
		stats.triangles = prims[PRIMITIVE_TRIANGLES] / 3 + Math.max(prims[PRIMITIVE_TRISTRIP] - 2, 0) + Math.max(prims[PRIMITIVE_TRIFAN] - 2, 0);
		stats.cullTime = this.renderer._cullTime;
		stats.sortTime = this.renderer._sortTime;
		stats.skinTime = this.renderer._skinTime;
		stats.morphTime = this.renderer._morphTime;
		stats.lightClusters = this.renderer._lightClusters;
		stats.lightClustersTime = this.renderer._lightClustersTime;
		stats.otherPrimitives = 0;

		for (let i = 0; i < prims.length; i++) {
			if (i < PRIMITIVE_TRIANGLES) {
				stats.otherPrimitives += prims[i];
			}

			prims[i] = 0;
		}

		this.renderer._camerasRendered = 0;
		this.renderer._materialSwitches = 0;
		this.renderer._shadowMapUpdates = 0;
		this.graphicsDevice._shaderSwitchesPerFrame = 0;
		this.renderer._cullTime = 0;
		this.renderer._layerCompositionUpdateTime = 0;
		this.renderer._lightClustersTime = 0;
		this.renderer._sortTime = 0;
		this.renderer._skinTime = 0;
		this.renderer._morphTime = 0;
		this.renderer._shadowMapTime = 0;
		this.renderer._depthMapTime = 0;
		this.renderer._forwardTime = 0;
		stats = this.stats.drawCalls;
		stats.forward = this.renderer._forwardDrawCalls;
		stats.culled = this.renderer._numDrawCallsCulled;
		stats.depth = 0;
		stats.shadow = this.renderer._shadowDrawCalls;
		stats.skinned = this.renderer._skinDrawCalls;
		stats.immediate = 0;
		stats.instanced = 0;
		stats.removedByInstancing = 0;
		stats.misc = stats.total - (stats.forward + stats.shadow);
		this.renderer._depthDrawCalls = 0;
		this.renderer._shadowDrawCalls = 0;
		this.renderer._forwardDrawCalls = 0;
		this.renderer._numDrawCallsCulled = 0;
		this.renderer._skinDrawCalls = 0;
		this.renderer._immediateRendered = 0;
		this.renderer._instancedDrawCalls = 0;
		this.stats.misc.renderTargetCreationTime = this.graphicsDevice.renderTargetCreationTime;
		stats = this.stats.particles;
		stats.updatesPerFrame = stats._updatesPerFrame;
		stats.frameTime = stats._frameTime;
		stats._updatesPerFrame = 0;
		stats._frameTime = 0;
	}

	setCanvasFillMode(mode, width, height) {
		this._fillMode = mode;
		this.resizeCanvas(width, height);
	}

	setCanvasResolution(mode, width, height) {
		this._resolutionMode = mode;

		if (mode === RESOLUTION_AUTO && width === undefined) {
			width = this.graphicsDevice.canvas.clientWidth;
			height = this.graphicsDevice.canvas.clientHeight;
		}

		this.graphicsDevice.resizeCanvas(width, height);
	}

	isHidden() {
		return document[this._hiddenAttr];
	}

	onVisibilityChange() {
		if (this.isHidden()) {
			this._soundManager.suspend();
		} else {
			this._soundManager.resume();
		}
	}

	resizeCanvas(width, height) {
		if (!this._allowResize) return;
		if (this.xr && this.xr.session) return;
		const windowWidth = window.innerWidth;
		const windowHeight = window.innerHeight;

		if (this._fillMode === FILLMODE_KEEP_ASPECT) {
			const r = this.graphicsDevice.canvas.width / this.graphicsDevice.canvas.height;
			const winR = windowWidth / windowHeight;

			if (r > winR) {
				width = windowWidth;
				height = width / r;
			} else {
				height = windowHeight;
				width = height * r;
			}
		} else if (this._fillMode === FILLMODE_FILL_WINDOW) {
			width = windowWidth;
			height = windowHeight;
		}

		this.graphicsDevice.canvas.style.width = width + 'px';
		this.graphicsDevice.canvas.style.height = height + 'px';
		this.updateCanvasSize();
		return {
			width: width,
			height: height
		};
	}

	updateCanvasSize() {
		if (!this._allowResize || this.xr.active) {
			return;
		}

		if (this._resolutionMode === RESOLUTION_AUTO) {
			const canvas = this.graphicsDevice.canvas;
			this.graphicsDevice.resizeCanvas(canvas.clientWidth, canvas.clientHeight);
		}
	}

	onLibrariesLoaded() {
		this._librariesLoaded = true;
		this.systems.rigidbody.onLibraryLoaded();
	}

	applySceneSettings(settings) {
		let asset;

		if (this.systems.rigidbody && typeof Ammo !== 'undefined') {
			const gravity = settings.physics.gravity;
			this.systems.rigidbody.gravity.set(gravity[0], gravity[1], gravity[2]);
		}

		this.scene.applySettings(settings);

		if (settings.render.hasOwnProperty('skybox')) {
			if (settings.render.skybox) {
				asset = this.assets.get(settings.render.skybox);

				if (asset) {
					this.setSkybox(asset);
				} else {
					this.assets.once('add:' + settings.render.skybox, this.setSkybox, this);
				}
			} else {
				this.setSkybox(null);
			}
		}
	}

	setAreaLightLuts(asset) {
		if (asset) {
			const device = this.graphicsDevice;
			asset.ready(asset => {
				AreaLightLuts.set(device, asset.resource);
			});
			this.assets.load(asset);
		}
	}

	setSkybox(asset) {
		if (asset !== this._skyboxAsset) {
			const onSkyboxRemoved = () => {
				this.setSkybox(null);
			};

			const onSkyboxChanged = () => {
				this.scene.setSkybox(this._skyboxAsset ? this._skyboxAsset.resources : null);
			};

			if (this._skyboxAsset) {
				this.assets.off('load:' + this._skyboxAsset.id, onSkyboxChanged, this);
				this.assets.off('remove:' + this._skyboxAsset.id, onSkyboxRemoved, this);

				this._skyboxAsset.off('change', onSkyboxChanged, this);
			}

			this._skyboxAsset = asset;

			if (this._skyboxAsset) {
				this.assets.on('load:' + this._skyboxAsset.id, onSkyboxChanged, this);
				this.assets.once('remove:' + this._skyboxAsset.id, onSkyboxRemoved, this);

				this._skyboxAsset.on('change', onSkyboxChanged, this);

				if (this.scene.skyboxMip === 0 && !this._skyboxAsset.loadFaces) {
					this._skyboxAsset.loadFaces = true;
				}

				this.assets.load(this._skyboxAsset);
			}

			onSkyboxChanged();
		}
	}

	enableVr() {
		if (!this.vr) {
			this.vr = new VrManager(this);
		}
	}

	disableVr() {
		if (this.vr) {
			this.vr.destroy();
			this.vr = null;
		}
	}

	_firstBake() {
		this.lightmapper.bake(null, this.scene.lightmapMode);
	}

	_firstBatch() {
		this.batcher.generate();
	}

	_processTimestamp(timestamp) {
		return timestamp;
	}

	drawLine(start, end, color, depthTest, layer) {
		this.scene.drawLine(start, end, color, depthTest, layer);
	}

	drawLines(positions, colors, depthTest = true, layer = this.scene.defaultDrawLayer) {
		this.scene.drawLines(positions, colors, depthTest, layer);
	}

	drawLineArrays(positions, colors, depthTest = true, layer = this.scene.defaultDrawLayer) {
		this.scene.drawLineArrays(positions, colors, depthTest, layer);
	}

	drawWireSphere(center, radius, color = Color.WHITE, segments = 20, depthTest = true, layer = this.scene.defaultDrawLayer) {
		this.scene.immediate.drawWireSphere(center, radius, color, segments, depthTest, layer);
	}

	drawWireAlignedBox(minPoint, maxPoint, color = Color.WHITE, depthTest = true, layer = this.scene.defaultDrawLayer) {
		this.scene.immediate.drawWireAlignedBox(minPoint, maxPoint, color, depthTest, layer);
	}

	drawMeshInstance(meshInstance, layer = this.scene.defaultDrawLayer) {
		this.scene.immediate.drawMesh(null, null, null, meshInstance, layer);
	}

	drawMesh(mesh, material, matrix, layer = this.scene.defaultDrawLayer) {
		this.scene.immediate.drawMesh(material, matrix, mesh, null, layer);
	}

	drawQuad(matrix, material, layer = this.scene.defaultDrawLayer) {
		this.scene.immediate.drawMesh(material, matrix, this.scene.immediate.getQuadMesh(), null, layer);
	}

	drawTexture(x, y, width, height, texture, material, layer = this.scene.defaultDrawLayer) {
		const matrix = new Mat4();
		matrix.setTRS(new Vec3(x, y, 0.0), Quat.IDENTITY, new Vec3(width, height, 0.0));

		if (!material) {
			material = new Material();
			material.setParameter("colorMap", texture);
			material.shader = this.scene.immediate.getTextureShader();
			material.update();
		}

		this.drawQuad(matrix, material, layer);
	}

	drawDepthTexture(x, y, width, height, layer = this.scene.defaultDrawLayer) {
		const material = new Material();
		material.shader = this.scene.immediate.getDepthTextureShader();
		material.update();
		this.drawTexture(x, y, width, height, null, material, layer);
	}

	destroy() {
		if (this._inFrameUpdate) {
			this._destroyRequested = true;
			return;
		}

		const canvasId = this.graphicsDevice.canvas.id;
		this.off('librariesloaded');

		if (typeof document !== 'undefined') {
			document.removeEventListener('visibilitychange', this._visibilityChangeHandler, false);
			document.removeEventListener('mozvisibilitychange', this._visibilityChangeHandler, false);
			document.removeEventListener('msvisibilitychange', this._visibilityChangeHandler, false);
			document.removeEventListener('webkitvisibilitychange', this._visibilityChangeHandler, false);
		}

		this._visibilityChangeHandler = null;
		this.root.destroy();
		this.root = null;

		if (this.mouse) {
			this.mouse.off();
			this.mouse.detach();
			this.mouse = null;
		}

		if (this.keyboard) {
			this.keyboard.off();
			this.keyboard.detach();
			this.keyboard = null;
		}

		if (this.touch) {
			this.touch.off();
			this.touch.detach();
			this.touch = null;
		}

		if (this.elementInput) {
			this.elementInput.detach();
			this.elementInput = null;
		}

		if (this.controller) {
			this.controller = null;
		}

		this.systems.destroy();

		if (this.scene.layers) {
			this.scene.layers.destroy();
		}

		const assets = this.assets.list();

		for (let i = 0; i < assets.length; i++) {
			assets[i].unload();
			assets[i].off();
		}

		this.assets.off();
		this.bundles.destroy();
		this.bundles = null;
		this.i18n.destroy();
		this.i18n = null;

		for (const key in this.loader.getHandler('script')._cache) {
			const element = this.loader.getHandler('script')._cache[key];

			const parent = element.parentNode;
			if (parent) parent.removeChild(element);
		}

		this.loader.getHandler('script')._cache = {};
		this.loader.destroy();
		this.loader = null;
		this.scene.destroy();
		this.scene = null;
		this.systems = null;
		this.context = null;
		this.scripts.destroy();
		this.scripts = null;
		this.scenes.destroy();
		this.scenes = null;
		this.lightmapper.destroy();
		this.lightmapper = null;
		this.batcher.destroy();
		this.batcher = null;
		this._entityIndex = {};
		this.defaultLayerDepth.onPreRenderOpaque = null;
		this.defaultLayerDepth.onPostRenderOpaque = null;
		this.defaultLayerDepth.onDisable = null;
		this.defaultLayerDepth.onEnable = null;
		this.defaultLayerDepth = null;
		this.defaultLayerWorld = null;

		if (this.vr) {
			this.vr.destroy();
			this.vr = null;
		}

		this.xr.end();
		this.renderer.destroy();
		this.renderer = null;
		this.graphicsDevice.destroy();
		this.graphicsDevice = null;
		this.tick = null;
		this.off();

		if (this._soundManager) {
			this._soundManager.destroy();

			this._soundManager = null;
		}

		script.app = null;
		Application._applications[canvasId] = null;

		if (getApplication() === this) {
			setApplication(null);
		}
	}

	getEntityFromIndex(guid) {
		return this._entityIndex[guid];
	}

	_registerSceneImmediate(scene) {
		this.on('postrender', scene.immediate.onPostRender, scene.immediate);
	}

}

Application._applications = {};
const _frameEndData = {};

const makeTick = function makeTick(_app) {
	const application = _app;
	let frameRequest;
	return function (timestamp, frame) {
		if (!application.graphicsDevice) return;
		setApplication(application);

		if (frameRequest) {
			window.cancelAnimationFrame(frameRequest);
			frameRequest = null;
		}

		app = application;
		const currentTime = application._processTimestamp(timestamp) || now();
		const ms = currentTime - (application._time || currentTime);
		let dt = ms / 1000.0;
		dt = math.clamp(dt, 0, application.maxDeltaTime);
		dt *= application.timeScale;
		application._time = currentTime;

		if (application.vr && application.vr.display) {
			frameRequest = application.vr.display.requestAnimationFrame(application.tick);
		} else if (application.xr.session) {
			frameRequest = application.xr.session.requestAnimationFrame(application.tick);
		} else {
			frameRequest = platform.browser ? window.requestAnimationFrame(application.tick) : null;
		}

		if (application.graphicsDevice.contextLost) return;

		application._fillFrameStatsBasic(currentTime, dt, ms);

		application._inFrameUpdate = true;
		application.fire("frameupdate", ms);

		if (frame) {
			application.xr.update(frame);
			application.graphicsDevice.defaultFramebuffer = frame.session.renderState.baseLayer.framebuffer;
		} else {
			application.graphicsDevice.defaultFramebuffer = null;
		}

		application.update(dt);
		application.fire("framerender");

		if (application.autoRender || application.renderNextFrame) {
			application.updateCanvasSize();
			application.render();
			application.renderNextFrame = false;
		}

		_frameEndData.timestamp = now();
		_frameEndData.target = application;
		application.fire("frameend", _frameEndData);
		application.fire("frameEnd", _frameEndData);

		if (application.vr && application.vr.display && application.vr.display.presenting) {
			application.vr.display.submitFrame();
		}

		application._inFrameUpdate = false;

		if (application._destroyRequested) {
			application.destroy();
		}
	};
};

const _enableList = [];

class Entity extends GraphNode {
	constructor(name, app) {
		super(name);
		this.anim = void 0;
		this.animation = void 0;
		this.audiolistener = void 0;
		this.button = void 0;
		this.camera = void 0;
		this.collision = void 0;
		this.element = void 0;
		this.layoutchild = void 0;
		this.layoutgroup = void 0;
		this.light = void 0;
		this.model = void 0;
		this.particlesystem = void 0;
		this.render = void 0;
		this.rigidbody = void 0;
		this.screen = void 0;
		this.script = void 0;
		this.scrollbar = void 0;
		this.scrollview = void 0;
		this.sound = void 0;
		this.sprite = void 0;
		this.c = {};
		this._app = void 0;
		this._destroying = false;
		this._guid = null;
		this._template = false;
		if (name instanceof Application) app = name;

		if (!app) {
			app = Application.getApplication();

			if (!app) {
				throw new Error("Couldn't find current application");
			}
		}

		this._app = app;
	}

	addComponent(type, data) {
		const system = this._app.systems[type];

		if (!system) {
			return null;
		}

		if (this.c[type]) {
			return null;
		}

		return system.addComponent(this, data);
	}

	removeComponent(type) {
		const system = this._app.systems[type];

		if (!system) {
			return;
		}

		if (!this.c[type]) {
			return;
		}

		system.removeComponent(this);
	}

	findComponent(type) {
		const entity = this.findOne(function (node) {
			return node.c && node.c[type];
		});
		return entity && entity.c[type];
	}

	findComponents(type) {
		const entities = this.find(function (node) {
			return node.c && node.c[type];
		});
		return entities.map(function (entity) {
			return entity.c[type];
		});
	}

	getGuid() {
		if (!this._guid) {
			this.setGuid(guid.create());
		}

		return this._guid;
	}

	setGuid(guid) {
		const index = this._app._entityIndex;

		if (this._guid) {
			delete index[this._guid];
		}

		this._guid = guid;
		index[this._guid] = this;
	}

	_notifyHierarchyStateChanged(node, enabled) {
		let enableFirst = false;
		if (node === this && _enableList.length === 0) enableFirst = true;
		node._beingEnabled = true;

		node._onHierarchyStateChanged(enabled);

		if (node._onHierarchyStatePostChanged) _enableList.push(node);
		const c = node._children;

		for (let i = 0, len = c.length; i < len; i++) {
			if (c[i]._enabled) this._notifyHierarchyStateChanged(c[i], enabled);
		}

		node._beingEnabled = false;

		if (enableFirst) {
			for (let i = 0; i < _enableList.length; i++) {
				_enableList[i]._onHierarchyStatePostChanged();
			}

			_enableList.length = 0;
		}
	}

	_onHierarchyStateChanged(enabled) {
		super._onHierarchyStateChanged(enabled);

		const components = this.c;

		for (const type in components) {
			if (components.hasOwnProperty(type)) {
				const component = components[type];

				if (component.enabled) {
					if (enabled) {
						component.onEnable();
					} else {
						component.onDisable();
					}
				}
			}
		}
	}

	_onHierarchyStatePostChanged() {
		const components = this.c;

		for (const type in components) {
			if (components.hasOwnProperty(type)) components[type].onPostStateChange();
		}
	}

	findByGuid(guid) {
		if (this._guid === guid) return this;
		const e = this._app._entityIndex[guid];

		if (e && (e === this || e.isDescendantOf(this))) {
			return e;
		}

		return null;
	}

	destroy() {
		this._destroying = true;

		for (const name in this.c) {
			this.c[name].enabled = false;
		}

		for (const name in this.c) {
			this.c[name].system.removeComponent(this);
		}

		if (this._parent) this._parent.removeChild(this);
		const children = this._children;
		let child = children.shift();

		while (child) {
			if (child instanceof Entity) {
				child.destroy();
			}

			child._parent = null;
			child = children.shift();
		}

		this.fire('destroy', this);
		this.off();

		if (this._guid) {
			delete this._app._entityIndex[this._guid];
		}

		this._destroying = false;
	}

	clone() {
		const duplicatedIdsMap = {};

		const clone = this._cloneRecursively(duplicatedIdsMap);

		duplicatedIdsMap[this.getGuid()] = clone;
		resolveDuplicatedEntityReferenceProperties(this, this, clone, duplicatedIdsMap);
		return clone;
	}

	_cloneRecursively(duplicatedIdsMap) {
		const clone = new Entity(this._app);

		super._cloneInternal(clone);

		for (const type in this.c) {
			const component = this.c[type];
			component.system.cloneComponent(this, clone);
		}

		for (let i = 0; i < this._children.length; i++) {
			const oldChild = this._children[i];

			if (oldChild instanceof Entity) {
				const newChild = oldChild._cloneRecursively(duplicatedIdsMap);

				clone.addChild(newChild);
				duplicatedIdsMap[oldChild.getGuid()] = newChild;
			}
		}

		return clone;
	}

}

function resolveDuplicatedEntityReferenceProperties(oldSubtreeRoot, oldEntity, newEntity, duplicatedIdsMap) {
	if (oldEntity instanceof Entity) {
		const components = oldEntity.c;

		for (const componentName in components) {
			const component = components[componentName];
			const entityProperties = component.system.getPropertiesOfType('entity');

			for (let i = 0, len = entityProperties.length; i < len; i++) {
				const propertyDescriptor = entityProperties[i];
				const propertyName = propertyDescriptor.name;
				const oldEntityReferenceId = component[propertyName];
				const entityIsWithinOldSubtree = !!oldSubtreeRoot.findByGuid(oldEntityReferenceId);

				if (entityIsWithinOldSubtree) {
					const newEntityReferenceId = duplicatedIdsMap[oldEntityReferenceId].getGuid();

					if (newEntityReferenceId) {
						newEntity.c[componentName][propertyName] = newEntityReferenceId;
					}
				}
			}
		}

		if (components.script && !newEntity._app.useLegacyScriptAttributeCloning) {
			newEntity.script.resolveDuplicatedEntityReferenceProperties(components.script, duplicatedIdsMap);
		}

		if (components.render) {
			newEntity.render.resolveDuplicatedEntityReferenceProperties(components.render, duplicatedIdsMap);
		}

		if (components.anim) {
			newEntity.anim.resolveDuplicatedEntityReferenceProperties(components.anim, duplicatedIdsMap);
		}

		const _old = oldEntity.children.filter(function (e) {
			return e instanceof Entity;
		});

		const _new = newEntity.children.filter(function (e) {
			return e instanceof Entity;
		});

		for (let i = 0, len = _old.length; i < len; i++) {
			resolveDuplicatedEntityReferenceProperties(oldSubtreeRoot, _old[i], _new[i], duplicatedIdsMap);
		}
	}
}

const _tempPoint = new Vec3();

class BakeLightAmbient extends BakeLight {
	constructor(scene) {
		const lightEntity = new Entity("AmbientLight");
		lightEntity.addComponent("light", {
			type: "directional",
			affectDynamic: true,
			affectLightmapped: false,
			bake: true,
			bakeNumSamples: scene.ambientBakeNumSamples,
			castShadows: true,
			normalOffsetBias: 0.05,
			shadowBias: 0.2,
			shadowDistance: 1,
			shadowResolution: 2048,
			shadowType: SHADOW_PCF3,
			color: Color.WHITE,
			intensity: 1,
			bakeDir: false
		});
		super(scene, lightEntity.light.light);
	}

	get numVirtualLights() {
		return this.light.bakeNumSamples;
	}

	prepareVirtualLight(index, numVirtualLights) {
		random.spherePointDeterministic(_tempPoint, index, numVirtualLights, 0, this.scene.ambientBakeSpherePart);

		this.light._node.lookAt(_tempPoint.mulScalar(-1));

		this.light._node.rotateLocal(90, 0, 0);

		const gamma = this.scene.gammaCorrection ? 2.2 : 1;
		const fullIntensity = 2 * Math.PI * this.scene.ambientBakeSpherePart;
		const linearIntensity = Math.pow(fullIntensity, gamma);
		this.light.intensity = Math.pow(linearIntensity / numVirtualLights, 1 / gamma);
	}

}

class BakeMeshNode {
	constructor(node, meshInstances = null) {
		this.node = node;
		this.component = node.render || node.model;
		meshInstances = meshInstances || this.component.meshInstances;
		this.store();
		this.meshInstances = meshInstances;
		this.bounds = null;
		this.renderTargets = [];
	}

	store() {
		this.castShadows = this.component.castShadows;
	}

	restore() {
		this.component.castShadows = this.castShadows;
	}

}

const DENOISE_FILTER_SIZE = 15;

class LightmapFilters {
	constructor(device) {
		this.device = device;
		this.shaderDilate = createShaderFromCode(device, shaderChunks.fullscreenQuadVS, shaderChunks.dilatePS, "lmDilate");
		this.constantTexSource = device.scope.resolve("source");
		this.constantPixelOffset = device.scope.resolve("pixelOffset");
		this.pixelOffset = new Float32Array(2);
		this.shaderDenoise = null;
		this.sigmas = null;
		this.constantSigmas = null;
		this.kernel = null;
	}

	setSourceTexture(texture) {
		this.constantTexSource.setValue(texture);
	}

	prepare(textureWidth, textureHeight) {
		this.pixelOffset[0] = 1 / textureWidth;
		this.pixelOffset[1] = 1 / textureHeight;
		this.constantPixelOffset.setValue(this.pixelOffset);
	}

	prepareDenoise(filterRange, filterSmoothness) {
		if (!this.shaderDenoise) {
			this.shaderDenoise = createShaderFromCode(this.device, shaderChunks.fullscreenQuadVS, shaderChunks.bilateralDeNoisePS, "lmBilateralDeNoise");
			this.sigmas = new Float32Array(2);
			this.constantSigmas = this.device.scope.resolve("sigmas");
			this.constantKernel = this.device.scope.resolve("kernel[0]");
			this.bZnorm = this.device.scope.resolve("bZnorm");
		}

		this.sigmas[0] = filterRange;
		this.sigmas[1] = filterSmoothness;
		this.constantSigmas.setValue(this.sigmas);
		this.evaluateDenoiseUniforms(filterRange, filterSmoothness);
	}

	evaluateDenoiseUniforms(filterRange, filterSmoothness) {
		function normpdf(x, sigma) {
			return 0.39894 * Math.exp(-0.5 * x * x / (sigma * sigma)) / sigma;
		}

		this.kernel = this.kernel || new Float32Array(DENOISE_FILTER_SIZE);
		const kernel = this.kernel;
		const kSize = Math.floor((DENOISE_FILTER_SIZE - 1) / 2);

		for (let j = 0; j <= kSize; ++j) {
			const value = normpdf(j, filterRange);
			kernel[kSize + j] = value;
			kernel[kSize - j] = value;
		}

		this.constantKernel.setValue(this.kernel);
		const bZnorm = 1 / normpdf(0.0, filterSmoothness);
		this.bZnorm.setValue(bZnorm);
	}

}

const MAX_LIGHTMAP_SIZE = 2048;
const PASS_COLOR = 0;
const PASS_DIR = 1;
const tempVec = new Vec3();

class Lightmapper {
	constructor(device, root, scene, renderer, assets) {
		this.device = device;
		this.root = root;
		this.scene = scene;
		this.renderer = renderer;
		this.assets = assets;
		this.shadowMapCache = renderer._shadowRenderer.shadowMapCache;
		this._tempSet = new Set();
		this._initCalled = false;
		this.passMaterials = [];
		this.ambientAOMaterial = null;
		this.fog = "";
		this.ambientLight = new Color();
		this.renderTargets = new Map();
		this.stats = {
			renderPasses: 0,
			lightmapCount: 0,
			totalRenderTime: 0,
			forwardTime: 0,
			fboTime: 0,
			shadowMapTime: 0,
			compileTime: 0,
			shadersLinked: 0
		};
	}

	destroy() {
		LightmapCache.decRef(this.blackTex);
		this.blackTex = null;
		LightmapCache.destroy();
		this.device = null;
		this.root = null;
		this.scene = null;
		this.renderer = null;
		this.assets = null;
	}

	initBake(device) {
		if (!this._initCalled) {
			this._initCalled = true;
			this.lightmapFilters = new LightmapFilters(device);
			this.constantBakeDir = device.scope.resolve("bakeDir");
			this.materials = [];
			this.blackTex = new Texture(this.device, {
				width: 4,
				height: 4,
				format: PIXELFORMAT_R8_G8_B8_A8,
				type: TEXTURETYPE_RGBM
			});
			this.blackTex.name = 'lightmapBlack';
			LightmapCache.incRef(this.blackTex);
			const camera = new Camera();
			camera.clearColor.set(0, 0, 0, 0);
			camera.clearColorBuffer = true;
			camera.clearDepthBuffer = false;
			camera.clearStencilBuffer = false;
			camera.frustumCulling = false;
			camera.projection = PROJECTION_ORTHOGRAPHIC;
			camera.aspectRatio = 1;
			camera.node = new GraphNode();
			this.camera = camera;
		}

		if (this.scene.clusteredLightingEnabled) {
			const lightingParams = new LightingParams(device.supportsAreaLights, device.maxTextureSize, () => {});
			this.lightingParams = lightingParams;
			const srcParams = this.scene.lighting;
			lightingParams.shadowsEnabled = srcParams.shadowsEnabled;
			lightingParams.shadowAtlasResolution = srcParams.shadowAtlasResolution;
			lightingParams.cookiesEnabled = srcParams.cookiesEnabled;
			lightingParams.cookieAtlasResolution = srcParams.cookieAtlasResolution;
			lightingParams.areaLightsEnabled = srcParams.areaLightsEnabled;
			lightingParams.cells = new Vec3(3, 3, 3);
			lightingParams.maxLightsPerCell = 4;
			this.worldClusters = new WorldClusters(device);
			this.worldClusters.name = "ClusterLightmapper";
		}
	}

	finishBake(bakeNodes) {
		this.materials = [];

		function destroyRT(rt) {
			LightmapCache.decRef(rt.colorBuffer);
			rt.destroy();
		}

		this.renderTargets.forEach(rt => {
			destroyRT(rt);
		});
		this.renderTargets.clear();
		bakeNodes.forEach(node => {
			node.renderTargets.forEach(rt => {
				destroyRT(rt);
			});
			node.renderTargets.length = 0;
		});
		this.ambientAOMaterial = null;

		if (this.worldClusters) {
			this.worldClusters.destroy();
			this.worldClusters = null;
		}
	}

	createMaterialForPass(device, scene, pass, addAmbient) {
		const material = new StandardMaterial();
		material.name = `lmMaterial-pass:${pass}-ambient:${addAmbient}`;
		material.chunks.transformVS = "#define UV1LAYOUT\n" + shaderChunks.transformVS;

		if (pass === PASS_COLOR) {
			let bakeLmEndChunk = shaderChunks.bakeLmEndPS;

			if (addAmbient) {
				bakeLmEndChunk = `
										dDiffuseLight = ((dDiffuseLight - 0.5) * max(${scene.ambientBakeOcclusionContrast.toFixed(1)} + 1.0, 0.0)) + 0.5;
										dDiffuseLight += vec3(${scene.ambientBakeOcclusionBrightness.toFixed(1)});
										dDiffuseLight = saturate(dDiffuseLight);
										dDiffuseLight *= dAmbientLight;
								` + bakeLmEndChunk;
			} else {
				material.ambient = new Color(0, 0, 0);
				material.ambientTint = true;
			}

			material.chunks.endPS = bakeLmEndChunk;
			material.lightMap = this.blackTex;
		} else {
			material.chunks.basePS = shaderChunks.basePS + "\nuniform sampler2D texture_dirLightMap;\nuniform float bakeDir;\n";
			material.chunks.endPS = shaderChunks.bakeDirLmEndPS;
		}

		material.chunks.outputAlphaPS = "\n";
		material.chunks.outputAlphaOpaquePS = "\n";
		material.chunks.outputAlphaPremulPS = "\n";
		material.cull = CULLFACE_NONE;
		material.forceUv1 = true;
		material.update();
		material.updateShader(device, scene);
		return material;
	}

	createMaterials(device, scene, passCount) {
		for (let pass = 0; pass < passCount; pass++) {
			if (!this.passMaterials[pass]) {
				this.passMaterials[pass] = this.createMaterialForPass(device, scene, pass, false);
			}
		}

		if (!this.ambientAOMaterial) {
			this.ambientAOMaterial = this.createMaterialForPass(device, scene, 0, true);

			this.ambientAOMaterial.onUpdateShader = function (options) {
				options.lightMapWithoutAmbient = true;
				options.separateAmbient = true;
				return options;
			};
		}
	}

	createTexture(size, type, name) {
		const tex = new Texture(this.device, {
			width: size,
			height: size,
			format: PIXELFORMAT_R8_G8_B8_A8,
			mipmaps: false,
			type: type,
			minFilter: FILTER_NEAREST,
			magFilter: FILTER_NEAREST,
			addressU: ADDRESS_CLAMP_TO_EDGE,
			addressV: ADDRESS_CLAMP_TO_EDGE
		});
		tex.name = name;
		return tex;
	}

	collectModels(node, bakeNodes, allNodes) {
		var _node$model, _node$model2, _node$render;

		if (!node.enabled) return;
		let meshInstances;

		if ((_node$model = node.model) != null && _node$model.model && (_node$model2 = node.model) != null && _node$model2.enabled) {
			if (allNodes) allNodes.push(new BakeMeshNode(node));

			if (node.model.lightmapped) {
				if (bakeNodes) {
					meshInstances = node.model.model.meshInstances;
				}
			}
		}

		if ((_node$render = node.render) != null && _node$render.enabled) {
			if (allNodes) allNodes.push(new BakeMeshNode(node));

			if (node.render.lightmapped) {
				if (bakeNodes) {
					meshInstances = node.render.meshInstances;
				}
			}
		}

		if (meshInstances) {
			let hasUv1 = true;

			for (let i = 0; i < meshInstances.length; i++) {
				if (!meshInstances[i].mesh.vertexBuffer.format.hasUv1) {
					hasUv1 = false;
					break;
				}
			}

			if (hasUv1) {
				const notInstancedMeshInstances = [];

				for (let i = 0; i < meshInstances.length; i++) {
					const mesh = meshInstances[i].mesh;

					if (this._tempSet.has(mesh)) {
						bakeNodes.push(new BakeMeshNode(node, [meshInstances[i]]));
					} else {
						notInstancedMeshInstances.push(meshInstances[i]);
					}

					this._tempSet.add(mesh);
				}

				this._tempSet.clear();

				if (notInstancedMeshInstances.length > 0) {
					bakeNodes.push(new BakeMeshNode(node, notInstancedMeshInstances));
				}
			}
		}

		for (let i = 0; i < node._children.length; i++) {
			this.collectModels(node._children[i], bakeNodes, allNodes);
		}
	}

	prepareShadowCasters(nodes) {
		const casters = [];

		for (let n = 0; n < nodes.length; n++) {
			const component = nodes[n].component;
			component.castShadows = component.castShadowsLightmap;

			if (component.castShadowsLightmap) {
				const meshes = nodes[n].meshInstances;

				for (let i = 0; i < meshes.length; i++) {
					meshes[i].visibleThisFrame = true;
					casters.push(meshes[i]);
				}
			}
		}

		return casters;
	}

	updateTransforms(nodes) {
		for (let i = 0; i < nodes.length; i++) {
			const meshInstances = nodes[i].meshInstances;

			for (let j = 0; j < meshInstances.length; j++) {
				meshInstances[j].node.getWorldTransform();
			}
		}
	}

	calculateLightmapSize(node) {
		let data;
		const sizeMult = this.scene.lightmapSizeMultiplier || 16;
		const scale = tempVec;
		let srcArea, lightmapSizeMultiplier;

		if (node.model) {
			lightmapSizeMultiplier = node.model.lightmapSizeMultiplier;

			if (node.model.asset) {
				data = this.assets.get(node.model.asset).data;

				if (data.area) {
					srcArea = data.area;
				}
			} else if (node.model._area) {
				data = node.model;

				if (data._area) {
					srcArea = data._area;
				}
			}
		} else if (node.render) {
			lightmapSizeMultiplier = node.render.lightmapSizeMultiplier;

			if (node.render.type !== 'asset') {
				if (node.render._area) {
					data = node.render;

					if (data._area) {
						srcArea = data._area;
					}
				}
			}
		}

		const area = {
			x: 1,
			y: 1,
			z: 1,
			uv: 1
		};

		if (srcArea) {
			area.x = srcArea.x;
			area.y = srcArea.y;
			area.z = srcArea.z;
			area.uv = srcArea.uv;
		}

		const areaMult = lightmapSizeMultiplier || 1;
		area.x *= areaMult;
		area.y *= areaMult;
		area.z *= areaMult;
		const component = node.render || node.model;
		const bounds = this.computeNodeBounds(component.meshInstances);
		scale.copy(bounds.halfExtents);
		let totalArea = area.x * scale.y * scale.z + area.y * scale.x * scale.z + area.z * scale.x * scale.y;
		totalArea /= area.uv;
		totalArea = Math.sqrt(totalArea);
		const lightmapSize = Math.min(math.nextPowerOfTwo(totalArea * sizeMult), this.scene.lightmapMaxResolution || MAX_LIGHTMAP_SIZE);
		return lightmapSize;
	}

	setLightmapping(nodes, value, passCount, shaderDefs) {
		for (let i = 0; i < nodes.length; i++) {
			const node = nodes[i];
			const meshInstances = node.meshInstances;

			for (let j = 0; j < meshInstances.length; j++) {
				const meshInstance = meshInstances[j];
				meshInstance.setLightmapped(value);

				if (value) {
					if (shaderDefs) {
						meshInstance._shaderDefs |= shaderDefs;
					}

					meshInstance.mask = MASK_AFFECT_LIGHTMAPPED;

					for (let pass = 0; pass < passCount; pass++) {
						const tex = node.renderTargets[pass].colorBuffer;
						tex.minFilter = FILTER_LINEAR;
						tex.magFilter = FILTER_LINEAR;
						meshInstance.setRealtimeLightmap(MeshInstance.lightmapParamNames[pass], tex);
					}
				}
			}
		}
	}

	bake(nodes, mode = BAKE_COLORDIR) {
		const device = this.device;
		const startTime = now();

		this.scene._updateSkybox(device);

		this.stats.renderPasses = 0;
		this.stats.shadowMapTime = 0;
		this.stats.forwardTime = 0;
		const startShaders = device._shaderStats.linked;
		const startFboTime = device._renderTargetCreationTime;
		const startCompileTime = device._shaderStats.compileTime;
		const bakeNodes = [];
		const allNodes = [];

		if (nodes) {
			for (let i = 0; i < nodes.length; i++) {
				this.collectModels(nodes[i], bakeNodes, null);
			}

			this.collectModels(this.root, null, allNodes);
		} else {
			this.collectModels(this.root, bakeNodes, allNodes);
		}

		if (bakeNodes.length > 0) {
			const passCount = mode === BAKE_COLORDIR ? 2 : 1;
			this.setLightmapping(bakeNodes, false, passCount);
			this.initBake(device);
			this.bakeInternal(passCount, bakeNodes, allNodes);
			let shaderDefs = SHADERDEF_LM;

			if (mode === BAKE_COLORDIR) {
				shaderDefs |= SHADERDEF_DIRLM;
			}

			if (this.scene.ambientBake) {
				shaderDefs |= SHADERDEF_LMAMBIENT;
			}

			this.setLightmapping(bakeNodes, true, passCount, shaderDefs);
			this.finishBake(bakeNodes);
		}

		const nowTime = now();
		this.stats.totalRenderTime = nowTime - startTime;
		this.stats.shadersLinked = device._shaderStats.linked - startShaders;
		this.stats.compileTime = device._shaderStats.compileTime - startCompileTime;
		this.stats.fboTime = device._renderTargetCreationTime - startFboTime;
		this.stats.lightmapCount = bakeNodes.length;
	}

	allocateTextures(bakeNodes, passCount) {
		for (let i = 0; i < bakeNodes.length; i++) {
			const bakeNode = bakeNodes[i];
			const size = this.calculateLightmapSize(bakeNode.node);

			for (let pass = 0; pass < passCount; pass++) {
				const tex = this.createTexture(size, TEXTURETYPE_DEFAULT, "lightmapper_lightmap_" + i);
				LightmapCache.incRef(tex);
				bakeNode.renderTargets[pass] = new RenderTarget({
					colorBuffer: tex,
					depth: false
				});
			}

			if (!this.renderTargets.has(size)) {
				const tex = this.createTexture(size, TEXTURETYPE_DEFAULT, "lightmapper_temp_lightmap_" + size);
				LightmapCache.incRef(tex);
				this.renderTargets.set(size, new RenderTarget({
					colorBuffer: tex,
					depth: false
				}));
			}
		}
	}

	prepareLightsToBake(layerComposition, allLights, bakeLights) {
		if (this.scene.ambientBake) {
			const ambientLight = new BakeLightAmbient(this.scene);
			bakeLights.push(ambientLight);
		}

		const sceneLights = layerComposition._lights;

		for (let i = 0; i < sceneLights.length; i++) {
			const light = sceneLights[i];
			const bakeLight = new BakeLightSimple(this.scene, light);
			allLights.push(bakeLight);

			if (light.enabled && (light.mask & MASK_BAKE) !== 0) {
				light.isStatic = false;
				light.mask = 0xFFFFFFFF;
				light.shadowUpdateMode = light.type === LIGHTTYPE_DIRECTIONAL ? SHADOWUPDATE_REALTIME : SHADOWUPDATE_THISFRAME;
				bakeLights.push(bakeLight);
			}
		}

		bakeLights.sort();
	}

	restoreLights(allLights) {
		for (let i = 0; i < allLights.length; i++) {
			allLights[i].restore();
		}
	}

	setupScene() {
		this.revertStatic = false;

		if (this.scene._needsStaticPrepare) {
			this.scene._needsStaticPrepare = false;
			this.revertStatic = true;
		}

		this.fog = this.scene.fog;
		this.ambientLight.copy(this.scene.ambientLight);
		this.scene.fog = FOG_NONE;

		if (!this.scene.ambientBake) {
			this.scene.ambientLight.set(0, 0, 0);
		}

		this.renderer.setSceneConstants();
	}

	restoreScene() {
		this.scene.fog = this.fog;
		this.scene.ambientLight.copy(this.ambientLight);

		if (this.revertStatic) {
			this.scene._needsStaticPrepare = true;
		}
	}

	computeNodeBounds(meshInstances) {
		const bounds = new BoundingBox();

		if (meshInstances.length > 0) {
			bounds.copy(meshInstances[0].aabb);

			for (let m = 1; m < meshInstances.length; m++) {
				bounds.add(meshInstances[m].aabb);
			}
		}

		return bounds;
	}

	computeNodesBounds(nodes) {
		for (let i = 0; i < nodes.length; i++) {
			const meshInstances = nodes[i].meshInstances;
			nodes[i].bounds = this.computeNodeBounds(meshInstances);
		}
	}

	computeBounds(meshInstances) {
		const bounds = new BoundingBox();

		for (let i = 0; i < meshInstances.length; i++) {
			bounds.copy(meshInstances[0].aabb);

			for (let m = 1; m < meshInstances.length; m++) {
				bounds.add(meshInstances[m].aabb);
			}
		}

		return bounds;
	}

	backupMaterials(meshInstances) {
		for (let i = 0; i < meshInstances.length; i++) {
			this.materials[i] = meshInstances[i].material;
		}
	}

	restoreMaterials(meshInstances) {
		for (let i = 0; i < meshInstances.length; i++) {
			meshInstances[i].material = this.materials[i];
		}
	}

	lightCameraPrepare(device, bakeLight) {
		const light = bakeLight.light;
		let shadowCam;

		if (light.type === LIGHTTYPE_SPOT) {
			const lightRenderData = light.getRenderData(null, 0);
			shadowCam = lightRenderData.shadowCamera;

			shadowCam._node.setPosition(light._node.getPosition());

			shadowCam._node.setRotation(light._node.getRotation());

			shadowCam._node.rotateLocal(-90, 0, 0);

			shadowCam.projection = PROJECTION_PERSPECTIVE;
			shadowCam.nearClip = light.attenuationEnd / 1000;
			shadowCam.farClip = light.attenuationEnd;
			shadowCam.aspectRatio = 1;
			shadowCam.fov = light._outerConeAngle * 2;
			this.renderer.updateCameraFrustum(shadowCam);
		}

		return shadowCam;
	}

	lightCameraPrepareAndCull(bakeLight, bakeNode, shadowCam, casterBounds) {
		const light = bakeLight.light;
		let lightAffectsNode = true;

		if (light.type === LIGHTTYPE_DIRECTIONAL) {
			tempVec.copy(casterBounds.center);
			tempVec.y += casterBounds.halfExtents.y;
			this.camera.node.setPosition(tempVec);
			this.camera.node.setEulerAngles(-90, 0, 0);
			this.camera.nearClip = 0;
			this.camera.farClip = casterBounds.halfExtents.y * 2;
			const frustumSize = Math.max(casterBounds.halfExtents.x, casterBounds.halfExtents.z);
			this.camera.orthoHeight = frustumSize;
		} else {
			if (!bakeLight.lightBounds.intersects(bakeNode.bounds)) {
				lightAffectsNode = false;
			}
		}

		if (light.type === LIGHTTYPE_SPOT) {
			let nodeVisible = false;
			const meshInstances = bakeNode.meshInstances;

			for (let i = 0; i < meshInstances.length; i++) {
				if (meshInstances[i]._isVisible(shadowCam)) {
					nodeVisible = true;
					break;
				}
			}

			if (!nodeVisible) {
				lightAffectsNode = false;
			}
		}

		return lightAffectsNode;
	}

	setupLightArray(lightArray, light) {
		lightArray[LIGHTTYPE_DIRECTIONAL].length = 0;
		lightArray[LIGHTTYPE_OMNI].length = 0;
		lightArray[LIGHTTYPE_SPOT].length = 0;
		lightArray[light.type][0] = light;
		light.visibleThisFrame = true;
	}

	renderShadowMap(shadowMapRendered, casters, lightArray, bakeLight) {
		const light = bakeLight.light;

		if (!shadowMapRendered && light.castShadows) {
			if (!light.shadowMap && !this.scene.clusteredLightingEnabled) {
				light.shadowMap = this.shadowMapCache.get(this.device, light);
			}

			if (light.type === LIGHTTYPE_DIRECTIONAL) {
				this.renderer._shadowRenderer.cullDirectional(light, casters, this.camera);
			} else {
				this.renderer._shadowRenderer.cullLocal(light, casters);
			}

			this.renderer.renderShadows(lightArray[light.type], this.camera);
		}

		return true;
	}

	postprocessTextures(device, bakeNodes, passCount) {
		const numDilates2x = 1;
		const dilateShader = this.lightmapFilters.shaderDilate;
		const filterLightmap = this.scene.lightmapFilterEnabled;

		if (filterLightmap) {
			this.lightmapFilters.prepareDenoise(this.scene.lightmapFilterRange, this.scene.lightmapFilterSmoothness);
		}

		for (let node = 0; node < bakeNodes.length; node++) {
			const bakeNode = bakeNodes[node];

			for (let pass = 0; pass < passCount; pass++) {
				const nodeRT = bakeNode.renderTargets[pass];
				const lightmap = nodeRT.colorBuffer;
				const tempRT = this.renderTargets.get(lightmap.width);
				const tempTex = tempRT.colorBuffer;
				this.lightmapFilters.prepare(lightmap.width, lightmap.height);

				for (let i = 0; i < numDilates2x; i++) {
					this.lightmapFilters.setSourceTexture(lightmap);
					const bilateralFilterEnabled = filterLightmap && pass === 0 && i === 0;
					drawQuadWithShader(device, tempRT, bilateralFilterEnabled ? this.lightmapFilters.shaderDenoise : dilateShader);
					this.lightmapFilters.setSourceTexture(tempTex);
					drawQuadWithShader(device, nodeRT, dilateShader);
				}
			}
		}
	}

	bakeInternal(passCount, bakeNodes, allNodes) {
		const scene = this.scene;
		const device = this.device;
		const clusteredLightingEnabled = scene.clusteredLightingEnabled;
		this.createMaterials(device, scene, passCount);
		this.setupScene();

		scene.layers._update();

		this.computeNodesBounds(bakeNodes);
		this.allocateTextures(bakeNodes, passCount);
		const allLights = [],
					bakeLights = [];
		this.prepareLightsToBake(scene.layers, allLights, bakeLights);
		this.updateTransforms(allNodes);
		const casters = this.prepareShadowCasters(allNodes);
		this.renderer.updateCpuSkinMatrices(casters);
		this.renderer.gpuUpdate(casters);
		const casterBounds = this.computeBounds(casters);
		let i, j, rcv, m;

		for (i = 0; i < bakeNodes.length; i++) {
			const bakeNode = bakeNodes[i];
			rcv = bakeNode.meshInstances;

			for (j = 0; j < rcv.length; j++) {
				m = rcv[j];
				m.setLightmapped(false);
				m.mask = MASK_BAKE;
				m.setRealtimeLightmap(MeshInstance.lightmapParamNames[0], m.material.lightMap ? m.material.lightMap : this.blackTex);
				m.setRealtimeLightmap(MeshInstance.lightmapParamNames[1], this.blackTex);
			}
		}

		for (j = 0; j < bakeLights.length; j++) {
			bakeLights[j].light.enabled = false;
		}

		const lightArray = [[], [], []];
		let pass, node;
		let shadersUpdatedOn1stPass = false;

		for (i = 0; i < bakeLights.length; i++) {
			const bakeLight = bakeLights[i];
			const isAmbientLight = bakeLight instanceof BakeLightAmbient;
			let numVirtualLights = bakeLight.numVirtualLights;

			if (passCount > 1 && numVirtualLights > 1 && bakeLight.light.bakeDir) {
				numVirtualLights = 1;
			}

			for (let virtualLightIndex = 0; virtualLightIndex < numVirtualLights; virtualLightIndex++) {
				if (numVirtualLights > 1) {
					bakeLight.prepareVirtualLight(virtualLightIndex, numVirtualLights);
				}

				bakeLight.startBake();
				let shadowMapRendered = false;
				const shadowCam = this.lightCameraPrepare(device, bakeLight);

				for (node = 0; node < bakeNodes.length; node++) {
					const bakeNode = bakeNodes[node];
					rcv = bakeNode.meshInstances;
					const lightAffectsNode = this.lightCameraPrepareAndCull(bakeLight, bakeNode, shadowCam, casterBounds);

					if (!lightAffectsNode) {
						continue;
					}

					this.setupLightArray(lightArray, bakeLight.light);

					if (clusteredLightingEnabled) {
						this.renderer.lightTextureAtlas.update(lightArray[LIGHTTYPE_SPOT], lightArray[LIGHTTYPE_OMNI], this.lightingParams);
					}

					shadowMapRendered = this.renderShadowMap(shadowMapRendered, casters, lightArray, bakeLight);

					if (clusteredLightingEnabled) {
						const clusterLights = lightArray[LIGHTTYPE_SPOT].concat(lightArray[LIGHTTYPE_OMNI]);
						this.worldClusters.update(clusterLights, this.scene.gammaCorrection, this.lightingParams);
					}

					this.backupMaterials(rcv);

					for (pass = 0; pass < passCount; pass++) {
						if (pass > 0 && virtualLightIndex > 0) {
							break;
						}

						if (isAmbientLight && pass > 0) {
							break;
						}

						const nodeRT = bakeNode.renderTargets[pass];
						const lightmapSize = bakeNode.renderTargets[pass].colorBuffer.width;
						const tempRT = this.renderTargets.get(lightmapSize);
						const tempTex = tempRT.colorBuffer;

						if (pass === 0) {
							shadersUpdatedOn1stPass = scene.updateShaders;
						} else if (shadersUpdatedOn1stPass) {
							scene.updateShaders = true;
						}

						let passMaterial = this.passMaterials[pass];

						if (isAmbientLight) {
							const lastVirtualLightForPass = virtualLightIndex + 1 === numVirtualLights;

							if (lastVirtualLightForPass && pass === 0) {
								passMaterial = this.ambientAOMaterial;
							}
						}

						for (j = 0; j < rcv.length; j++) {
							rcv[j].material = passMaterial;
						}

						this.renderer.updateShaders(rcv);
						this.renderer.setCamera(this.camera, tempRT, true);

						if (pass === PASS_DIR) {
							this.constantBakeDir.setValue(bakeLight.light.bakeDir ? 1 : 0);
						}

						if (clusteredLightingEnabled) {
							this.worldClusters.activate(this.renderer.lightTextureAtlas);
						}

						this.renderer._forwardTime = 0;
						this.renderer._shadowMapTime = 0;
						this.renderer.renderForward(this.camera, rcv, rcv.length, lightArray, SHADER_FORWARDHDR);
						bakeNode.renderTargets[pass] = tempRT;
						this.renderTargets.set(lightmapSize, nodeRT);

						for (j = 0; j < rcv.length; j++) {
							m = rcv[j];
							m.setRealtimeLightmap(MeshInstance.lightmapParamNames[pass], tempTex);
							m._shaderDefs |= SHADERDEF_LM;
						}
					}

					this.restoreMaterials(rcv);
				}

				bakeLight.endBake(this.shadowMapCache);
			}
		}

		this.postprocessTextures(device, bakeNodes, passCount);

		for (node = 0; node < allNodes.length; node++) {
			allNodes[node].restore();
		}

		this.restoreLights(allLights);
		this.restoreScene();

		if (!clusteredLightingEnabled) {
			this.shadowMapCache.clear();
		}
	}

}

const tempSet = new Set();
const clearDepthOptions = {
	depth: 1.0,
	flags: CLEARFLAG_DEPTH
};

class Picker {
	constructor(app, width, height) {
		if (app instanceof GraphicsDevice) {
			app = getApplication();
		}

		this.app = app;
		this.device = app.graphicsDevice;
		this.pickColor = new Float32Array(4);
		this.pickColor[3] = 1;
		this.mapping = [];
		this.cameraEntity = null;
		this.layer = null;
		this.layerComp = null;
		this.initLayerComposition();
		this._renderTarget = null;
		const device = this.device;
		this.clearDepthCommand = new Command(0, 0, function () {
			device.clear(clearDepthOptions);
		});
		this.width = 0;
		this.height = 0;
		this.resize(width, height);
	}

	getSelection(x, y, width, height) {
		const device = this.device;

		if (typeof x === 'object') {
			const rect = x;
			x = rect.x;
			y = rect.y;
			width = rect.width;
			height = rect.height;
		} else {
			y = this.renderTarget.height - (y + (height || 1));
		}

		x = Math.floor(x);
		y = Math.floor(y);
		width = Math.floor(Math.max(width || 1, 1));
		height = Math.floor(Math.max(height || 1, 1));
		const origRenderTarget = device.renderTarget;
		device.setRenderTarget(this.renderTarget);
		device.updateBegin();
		const pixels = new Uint8Array(4 * width * height);
		device.readPixels(x, y, width, height, pixels);
		device.updateEnd();
		device.setRenderTarget(origRenderTarget);
		const mapping = this.mapping;

		for (let i = 0; i < width * height; i++) {
			const r = pixels[4 * i + 0];
			const g = pixels[4 * i + 1];
			const b = pixels[4 * i + 2];
			const index = r << 16 | g << 8 | b;

			if (index !== 0xffffff) {
				tempSet.add(mapping[index]);
			}
		}

		const selection = [];
		tempSet.forEach(meshInstance => selection.push(meshInstance));
		tempSet.clear();
		return selection;
	}

	allocateRenderTarget() {
		const colorBuffer = new Texture(this.device, {
			format: PIXELFORMAT_R8_G8_B8_A8,
			width: this.width,
			height: this.height,
			mipmaps: false,
			minFilter: FILTER_NEAREST,
			magFilter: FILTER_NEAREST,
			addressU: ADDRESS_CLAMP_TO_EDGE,
			addressV: ADDRESS_CLAMP_TO_EDGE
		});
		colorBuffer.name = 'pick';
		this.renderTarget = new RenderTarget({
			colorBuffer: colorBuffer,
			depth: true
		});
	}

	releaseRenderTarget() {
		this.cameraEntity.camera.renderTarget = null;

		if (this._renderTarget) {
			this._renderTarget._colorBuffer.destroy();

			this._renderTarget.destroy();

			this._renderTarget = null;
		}
	}

	initLayerComposition() {
		const device = this.device;
		const self = this;
		const pickColorId = device.scope.resolve('uColor');
		this.cameraEntity = new Entity();
		this.cameraEntity.addComponent("camera");
		this.layer = new Layer({
			name: "Picker",
			shaderPass: SHADER_PICK,
			opaqueSortMode: SORTMODE_NONE,
			onDrawCall: function (meshInstance, index) {
				self.pickColor[0] = (index >> 16 & 0xff) / 255;
				self.pickColor[1] = (index >> 8 & 0xff) / 255;
				self.pickColor[2] = (index & 0xff) / 255;
				pickColorId.setValue(self.pickColor);
				device.setBlending(false);
				self.mapping[index] = meshInstance;
			}
		});
		this.layer.addCamera(this.cameraEntity.camera);
		this.layerComp = new LayerComposition("picker");
		this.layerComp.pushOpaque(this.layer);
	}

	prepare(camera, scene, layers) {
		if (camera instanceof Camera) {
			camera = camera.node.camera;
		}

		if (layers instanceof Layer) {
			layers = [layers];
		}

		this.layer.clearMeshInstances();
		const destMeshInstances = this.layer.opaqueMeshInstances;
		const srcLayers = scene.layers.layerList;
		const subLayerEnabled = scene.layers.subLayerEnabled;
		const isTransparent = scene.layers.subLayerList;

		for (let i = 0; i < srcLayers.length; i++) {
			const srcLayer = srcLayers[i];

			if (layers && layers.indexOf(srcLayer) < 0) {
				continue;
			}

			if (srcLayer.enabled && subLayerEnabled[i]) {
				const layerCamId = srcLayer.cameras.indexOf(camera);

				if (layerCamId >= 0) {
					if (srcLayer._clearDepthBuffer) {
						destMeshInstances.push(this.clearDepthCommand);
					}

					const meshInstances = isTransparent[i] ? srcLayer.instances.transparentMeshInstances : srcLayer.instances.opaqueMeshInstances;

					for (let j = 0; j < meshInstances.length; j++) {
						const meshInstance = meshInstances[j];

						if (meshInstance.pick) {
							destMeshInstances.push(meshInstance);
						}
					}
				}
			}
		}

		if (!this.renderTarget || this.width !== this.renderTarget.width || this.height !== this.renderTarget.height) {
			this.releaseRenderTarget();
			this.allocateRenderTarget();
		}

		this.updateCamera(camera);
		this.mapping.length = 0;
		this.app.renderer.renderComposition(this.layerComp);
	}

	updateCamera(srcCamera) {
		this.cameraEntity.copy(srcCamera.entity);
		this.cameraEntity.name = "PickerCamera";
		const destCamera = this.cameraEntity.camera;
		destCamera.copy(srcCamera);
		destCamera.clearColorBuffer = true;
		destCamera.clearDepthBuffer = true;
		destCamera.clearStencilBuffer = true;
		destCamera.clearColor = Color.WHITE;
		destCamera.renderTarget = this.renderTarget;
		this.layer.clearCameras();
		this.layer.addCamera(destCamera);
		destCamera.layers = [this.layer.id];
	}

	resize(width, height) {
		this.width = Math.floor(width);
		this.height = Math.floor(height);
	}

}

const MAX_TEXTURE_SIZE = 4096;
const DEFAULT_TEXTURE_SIZE = 512;

class CanvasFont extends EventHandler {
	constructor(app, options = {}) {
		super();
		this.type = "bitmap";
		this.app = app;
		this.intensity = 0;
		this.fontWeight = options.fontWeight || 'normal';
		this.fontSize = parseInt(options.fontSize, 10);
		this.glyphSize = this.fontSize;
		this.fontName = options.fontName || 'Arial';
		this.color = options.color || new Color(1, 1, 1);
		this.padding = options.padding || 0;
		const w = options.width > MAX_TEXTURE_SIZE ? MAX_TEXTURE_SIZE : options.width || DEFAULT_TEXTURE_SIZE;
		const h = options.height > MAX_TEXTURE_SIZE ? MAX_TEXTURE_SIZE : options.height || DEFAULT_TEXTURE_SIZE;
		const canvas = document.createElement('canvas');
		canvas.height = h;
		canvas.width = w;
		const texture = new Texture(this.app.graphicsDevice, {
			name: 'font',
			format: PIXELFORMAT_R8_G8_B8_A8,
			minFilter: FILTER_LINEAR_MIPMAP_LINEAR,
			magFilter: FILTER_LINEAR,
			addressU: ADDRESS_CLAMP_TO_EDGE,
			addressV: ADDRESS_CLAMP_TO_EDGE,
			mipmaps: true
		});
		texture.setSource(canvas);
		this.textures = [texture];
		this.chars = "";
		this.data = {};
	}

	createTextures(text) {
		const _chars = this._normalizeCharsSet(text);

		if (_chars.length !== this.chars.length) {
			this._renderAtlas(_chars);

			return;
		}

		for (let i = 0; i < _chars.length; i++) {
			if (_chars[i] !== this.chars[i]) {
				this._renderAtlas(_chars);

				return;
			}
		}
	}

	updateTextures(text) {
		const _chars = this._normalizeCharsSet(text);

		const newCharsSet = [];

		for (let i = 0; i < _chars.length; i++) {
			const char = _chars[i];

			if (!this.data.chars[char]) {
				newCharsSet.push(char);
			}
		}

		if (newCharsSet.length > 0) {
			this._renderAtlas(this.chars.concat(newCharsSet));
		}
	}

	destroy() {
		for (let i = 0; i < this.textures.length; i++) {
			this.textures[i].destroy();
		}

		this.chars = null;
		this.color = null;
		this.data = null;
		this.fontName = null;
		this.fontSize = null;
		this.glyphSize = null;
		this.intensity = null;
		this.textures = null;
		this.type = null;
		this.fontWeight = null;
	}

	_getAndClearContext(canvas, clearColor) {
		const w = canvas.width;
		const h = canvas.height;
		const ctx = canvas.getContext('2d', {
			alpha: true
		});
		ctx.clearRect(0, 0, w, h);
		ctx.fillStyle = clearColor;
		ctx.fillRect(0, 0, w, h);
		return ctx;
	}

	_colorToRgbString(color, alpha) {
		let str;
		const r = Math.round(255 * color.r);
		const g = Math.round(255 * color.g);
		const b = Math.round(255 * color.b);

		if (alpha) {
			str = `rgba(${r}, ${g}, ${b}, ${color.a})`;
		} else {
			str = `rgb(${r}, ${g}, ${b})`;
		}

		return str;
	}

	renderCharacter(context, char, x, y, color) {
		context.fillStyle = color;
		context.fillText(char, x, y);
	}

	_renderAtlas(charsArray) {
		this.chars = charsArray;
		let numTextures = 1;
		let canvas = this.textures[numTextures - 1].getSource();
		const w = canvas.width;
		const h = canvas.height;

		const color = this._colorToRgbString(this.color, false);

		const a = this.color.a;
		this.color.a = 1 / 255;

		const transparent = this._colorToRgbString(this.color, true);

		this.color.a = a;
		const TEXT_ALIGN = 'center';
		const TEXT_BASELINE = 'alphabetic';

		let ctx = this._getAndClearContext(canvas, transparent);

		ctx.font = this.fontWeight + ' ' + this.fontSize.toString() + 'px ' + this.fontName;
		ctx.textAlign = TEXT_ALIGN;
		ctx.textBaseline = TEXT_BASELINE;
		this.data = this._createJson(this.chars, this.fontName, w, h);
		const symbols = string.getSymbols(this.chars.join(''));
		const prevNumTextures = this.textures.length;
		let maxHeight = 0;
		let maxDescent = 0;
		const metrics = {};

		for (let i = 0; i < symbols.length; i++) {
			const ch = symbols[i];
			metrics[ch] = this._getTextMetrics(ch);
			maxHeight = Math.max(maxHeight, metrics[ch].height);
			maxDescent = Math.max(maxDescent, metrics[ch].descent);
		}

		this.glyphSize = Math.max(this.glyphSize, maxHeight);
		const sx = this.glyphSize + this.padding * 2;
		const sy = this.glyphSize + this.padding * 2;

		const _xOffset = this.glyphSize / 2 + this.padding;

		const _yOffset = sy - maxDescent - this.padding;

		let _x = 0;
		let _y = 0;

		for (let i = 0; i < symbols.length; i++) {
			const ch = symbols[i];
			const code = string.getCodePoint(symbols[i]);
			let fs = this.fontSize;
			ctx.font = this.fontWeight + ' ' + fs.toString() + 'px ' + this.fontName;
			ctx.textAlign = TEXT_ALIGN;
			ctx.textBaseline = TEXT_BASELINE;
			let width = ctx.measureText(ch).width;

			if (width > fs) {
				fs = this.fontSize * this.fontSize / width;
				ctx.font = this.fontWeight + ' ' + fs.toString() + 'px ' + this.fontName;
				width = this.fontSize;
			}

			this.renderCharacter(ctx, ch, _x + _xOffset, _y + _yOffset, color);
			const xoffset = this.padding + (this.glyphSize - width) / 2;
			const yoffset = -this.padding + metrics[ch].descent - maxDescent;
			const xadvance = width;

			this._addChar(this.data, ch, code, _x, _y, sx, sy, xoffset, yoffset, xadvance, numTextures - 1, w, h);

			_x += sx;

			if (_x + sx > w) {
				_x = 0;
				_y += sy;

				if (_y + sy > h) {
					this.textures[numTextures - 1].upload();
					numTextures++;
					_y = 0;

					if (numTextures > prevNumTextures) {
						canvas = document.createElement('canvas');
						canvas.height = h;
						canvas.width = w;
						ctx = this._getAndClearContext(canvas, transparent);
						const texture = new Texture(this.app.graphicsDevice, {
							format: PIXELFORMAT_R8_G8_B8_A8,
							mipmaps: true
						});
						texture.name = 'font-atlas';
						texture.setSource(canvas);
						texture.minFilter = FILTER_LINEAR_MIPMAP_LINEAR;
						texture.magFilter = FILTER_LINEAR;
						texture.addressU = ADDRESS_CLAMP_TO_EDGE;
						texture.addressV = ADDRESS_CLAMP_TO_EDGE;
						this.textures.push(texture);
					} else {
						canvas = this.textures[numTextures - 1].getSource();
						ctx = this._getAndClearContext(canvas, transparent);
					}
				}
			}
		}

		this.textures[numTextures - 1].upload();

		if (numTextures < prevNumTextures) {
			for (let i = numTextures; i < prevNumTextures; i++) {
				this.textures[i].destroy();
			}

			this.textures.splice(numTextures);
		}

		this.fire("render");
	}

	_createJson(chars, fontName, width, height) {
		const base = {
			"version": 3,
			"intensity": this.intensity,
			"info": {
				"face": fontName,
				"width": width,
				"height": height,
				"maps": [{
					"width": width,
					"height": height
				}]
			},
			"chars": {}
		};
		return base;
	}

	_addChar(json, char, charCode, x, y, w, h, xoffset, yoffset, xadvance, mapNum, mapW, mapH) {
		if (json.info.maps.length < mapNum + 1) {
			json.info.maps.push({
				"width": mapW,
				"height": mapH
			});
		}

		const scale = this.fontSize / 32;
		json.chars[char] = {
			"id": charCode,
			"letter": char,
			"x": x,
			"y": y,
			"width": w,
			"height": h,
			"xadvance": xadvance / scale,
			"xoffset": xoffset / scale,
			"yoffset": (yoffset + this.padding) / scale,
			"scale": scale,
			"range": 1,
			"map": mapNum,
			"bounds": [0, 0, w / scale, h / scale]
		};
	}

	_normalizeCharsSet(text) {
		const unicodeConverterFunc = this.app.systems.element.getUnicodeConverter();

		if (unicodeConverterFunc) {
			text = unicodeConverterFunc(text);
		}

		const set = {};
		const symbols = string.getSymbols(text);

		for (let i = 0; i < symbols.length; i++) {
			const ch = symbols[i];
			if (set[ch]) continue;
			set[ch] = ch;
		}

		const chars = Object.keys(set);
		return chars.sort();
	}

	_getTextMetrics(text) {
		const textSpan = document.createElement('span');
		textSpan.id = 'content-span';
		textSpan.innerHTML = text;
		const block = document.createElement("div");
		block.id = 'content-block';
		block.style.display = 'inline-block';
		block.style.width = '1px';
		block.style.height = '0px';
		const div = document.createElement('div');
		div.appendChild(textSpan);
		div.appendChild(block);
		div.style.font = this.fontSize + 'px ' + this.fontName;
		const body = document.body;
		body.appendChild(div);
		let ascent = -1;
		let descent = -1;
		let height = -1;

		try {
			block.style['vertical-align'] = 'baseline';
			ascent = block.offsetTop - textSpan.offsetTop;
			block.style['vertical-align'] = 'bottom';
			height = block.offsetTop - textSpan.offsetTop;
			descent = height - ascent;
		} finally {
			document.body.removeChild(div);
		}

		return {
			ascent: ascent,
			descent: descent,
			height: height
		};
	}

}

class ResourceHandler {
	load(url, callback, asset) {
		throw new Error('not implemented');
	}

	open(url, data, asset) {
		throw new Error('not implemented');
	}

	patch(asset, assets) {}

}

class SceneSettingsHandler {
	constructor(app) {
		this._app = app;
		this.maxRetries = 0;
	}

	load(url, callback) {
		SceneUtils.load(url, this.maxRetries, callback);
	}

	open(url, data) {
		return data.settings;
	}

}

const reservedScriptNames = new Set(['system', 'entity', 'create', 'destroy', 'swap', 'move', 'scripts', '_scripts', '_scriptsIndex', '_scriptsData', 'enabled', '_oldState', 'onEnable', 'onDisable', 'onPostStateChange', '_onSetEnabled', '_checkState', '_onBeforeRemove', '_onInitializeAttributes', '_onInitialize', '_onPostInitialize', '_onUpdate', '_onPostUpdate', '_callbacks', 'has', 'get', 'on', 'off', 'fire', 'once', 'hasEvent']);

function createScript(name, app) {
	if (script.legacy) {
		return null;
	}

	if (reservedScriptNames.has(name)) throw new Error(`script name: '${name}' is reserved, please change script name`);

	const scriptType = function scriptType(args) {
		EventHandler.prototype.initEventHandler.call(this);
		ScriptType.prototype.initScriptType.call(this, args);
	};

	scriptType.prototype = Object.create(ScriptType.prototype);
	scriptType.prototype.constructor = scriptType;
	scriptType.extend = ScriptType.extend;
	scriptType.attributes = new ScriptAttributes(scriptType);
	registerScript(scriptType, name, app);
	return scriptType;
}

const reservedAttributes = {};
ScriptAttributes.reservedNames.forEach((value, value2, set) => {
	reservedAttributes[value] = 1;
});
createScript.reservedAttributes = reservedAttributes;

function registerScript(script, name, app) {
	if (script.legacy) {
		return;
	}

	if (typeof script !== 'function') throw new Error(`script class: '${script}' must be a constructor function (i.e. class).`);
	if (!(script.prototype instanceof ScriptType)) throw new Error(`script class: '${ScriptType.__getScriptName(script)}' does not extend pc.ScriptType.`);
	name = name || script.__name || ScriptType.__getScriptName(script);
	if (reservedScriptNames.has(name)) throw new Error(`script name: '${name}' is reserved, please change script name`);
	script.__name = name;
	const registry = app ? app.scripts : Application.getApplication().scripts;
	registry.add(script);

	ScriptHandler._push(script);
}

class KeyboardEvent {
	constructor(keyboard, event) {
		if (event) {
			this.key = event.keyCode;
			this.element = event.target;
			this.event = event;
		} else {
			this.key = null;
			this.element = null;
			this.event = null;
		}
	}

}

const _keyboardEvent = new KeyboardEvent();

function makeKeyboardEvent(event) {
	_keyboardEvent.key = event.keyCode;
	_keyboardEvent.element = event.target;
	_keyboardEvent.event = event;
	return _keyboardEvent;
}

function toKeyCode(s) {
	if (typeof s === "string") {
		return s.toUpperCase().charCodeAt(0);
	}

	return s;
}

const _keyCodeToKeyIdentifier = {
	'9': 'Tab',
	'13': 'Enter',
	'16': 'Shift',
	'17': 'Control',
	'18': 'Alt',
	'27': 'Escape',
	'37': 'Left',
	'38': 'Up',
	'39': 'Right',
	'40': 'Down',
	'46': 'Delete',
	'91': 'Win'
};

class Keyboard extends EventHandler {
	constructor(element, options = {}) {
		super();
		this._element = null;
		this._keyDownHandler = this._handleKeyDown.bind(this);
		this._keyUpHandler = this._handleKeyUp.bind(this);
		this._keyPressHandler = this._handleKeyPress.bind(this);
		this._visibilityChangeHandler = this._handleVisibilityChange.bind(this);
		this._windowBlurHandler = this._handleWindowBlur.bind(this);
		this._keymap = {};
		this._lastmap = {};

		if (element) {
			this.attach(element);
		}

		this.preventDefault = options.preventDefault || false;
		this.stopPropagation = options.stopPropagation || false;
	}

	attach(element) {
		if (this._element) {
			this.detach();
		}

		this._element = element;

		this._element.addEventListener("keydown", this._keyDownHandler, false);

		this._element.addEventListener("keypress", this._keyPressHandler, false);

		this._element.addEventListener("keyup", this._keyUpHandler, false);

		document.addEventListener('visibilitychange', this._visibilityChangeHandler, false);
		window.addEventListener('blur', this._windowBlurHandler, false);
	}

	detach() {
		if (!this._element) {
			return;
		}

		this._element.removeEventListener("keydown", this._keyDownHandler);

		this._element.removeEventListener("keypress", this._keyPressHandler);

		this._element.removeEventListener("keyup", this._keyUpHandler);

		this._element = null;
		document.removeEventListener('visibilitychange', this._visibilityChangeHandler, false);
		window.removeEventListener('blur', this._windowBlurHandler, false);
	}

	toKeyIdentifier(keyCode) {
		keyCode = toKeyCode(keyCode);

		const id = _keyCodeToKeyIdentifier[keyCode.toString()];

		if (id) {
			return id;
		}

		let hex = keyCode.toString(16).toUpperCase();
		const length = hex.length;

		for (let count = 0; count < 4 - length; count++) {
			hex = '0' + hex;
		}

		return 'U+' + hex;
	}

	_handleKeyDown(event) {
		const code = event.keyCode || event.charCode;
		if (code === undefined) return;
		const id = this.toKeyIdentifier(code);
		this._keymap[id] = true;
		this.fire("keydown", makeKeyboardEvent(event));

		if (this.preventDefault) {
			event.preventDefault();
		}

		if (this.stopPropagation) {
			event.stopPropagation();
		}
	}

	_handleKeyUp(event) {
		const code = event.keyCode || event.charCode;
		if (code === undefined) return;
		const id = this.toKeyIdentifier(code);
		delete this._keymap[id];
		this.fire("keyup", makeKeyboardEvent(event));

		if (this.preventDefault) {
			event.preventDefault();
		}

		if (this.stopPropagation) {
			event.stopPropagation();
		}
	}

	_handleKeyPress(event) {
		this.fire("keypress", makeKeyboardEvent(event));

		if (this.preventDefault) {
			event.preventDefault();
		}

		if (this.stopPropagation) {
			event.stopPropagation();
		}
	}

	_handleVisibilityChange() {
		if (document.visibilityState === 'hidden') {
			this._handleWindowBlur();
		}
	}

	_handleWindowBlur() {
		this._keymap = {};
		this._lastmap = {};
	}

	update() {
		for (const prop in this._lastmap) {
			delete this._lastmap[prop];
		}

		for (const prop in this._keymap) {
			if (this._keymap.hasOwnProperty(prop)) {
				this._lastmap[prop] = this._keymap[prop];
			}
		}
	}

	isPressed(key) {
		const keyCode = toKeyCode(key);
		const id = this.toKeyIdentifier(keyCode);
		return !!this._keymap[id];
	}

	wasPressed(key) {
		const keyCode = toKeyCode(key);
		const id = this.toKeyIdentifier(keyCode);
		return !!this._keymap[id] && !!!this._lastmap[id];
	}

	wasReleased(key) {
		const keyCode = toKeyCode(key);
		const id = this.toKeyIdentifier(keyCode);
		return !!!this._keymap[id] && !!this._lastmap[id];
	}

}

function isMousePointerLocked() {
	return !!(document.pointerLockElement || document.mozPointerLockElement || document.webkitPointerLockElement);
}

class MouseEvent {
	constructor(mouse, event) {
		let coords = {
			x: 0,
			y: 0
		};

		if (event) {
			if (event instanceof MouseEvent) {
				throw Error("Expected MouseEvent");
			}

			coords = mouse._getTargetCoords(event);
		} else {
			event = {};
		}

		if (coords) {
			this.x = coords.x;
			this.y = coords.y;
		} else if (isMousePointerLocked()) {
			this.x = 0;
			this.y = 0;
		} else {
			return;
		}

		this.wheelDelta = 0;

		if (event.type === 'wheel') {
			if (event.deltaY > 0) {
				this.wheelDelta = 1;
			} else if (event.deltaY < 0) {
				this.wheelDelta = -1;
			}
		}

		if (isMousePointerLocked()) {
			this.dx = event.movementX || event.webkitMovementX || event.mozMovementX || 0;
			this.dy = event.movementY || event.webkitMovementY || event.mozMovementY || 0;
		} else {
			this.dx = this.x - mouse._lastX;
			this.dy = this.y - mouse._lastY;
		}

		if (event.type === 'mousedown' || event.type === 'mouseup') {
			this.button = event.button;
		} else {
			this.button = MOUSEBUTTON_NONE;
		}

		this.buttons = mouse._buttons.slice(0);
		this.element = event.target;
		this.ctrlKey = event.ctrlKey || false;
		this.altKey = event.altKey || false;
		this.shiftKey = event.shiftKey || false;
		this.metaKey = event.metaKey || false;
		this.event = event;
	}

}

class Mouse extends EventHandler {
	constructor(element) {
		super();
		this._lastX = 0;
		this._lastY = 0;
		this._buttons = [false, false, false];
		this._lastbuttons = [false, false, false];
		this._upHandler = this._handleUp.bind(this);
		this._downHandler = this._handleDown.bind(this);
		this._moveHandler = this._handleMove.bind(this);
		this._wheelHandler = this._handleWheel.bind(this);

		this._contextMenuHandler = event => {
			event.preventDefault();
		};

		this._target = null;
		this._attached = false;
		this.attach(element);
	}

	static isPointerLocked() {
		return isMousePointerLocked();
	}

	attach(element) {
		this._target = element;
		if (this._attached) return;
		this._attached = true;
		const opts = platform.passiveEvents ? {
			passive: false
		} : false;
		window.addEventListener("mouseup", this._upHandler, opts);
		window.addEventListener("mousedown", this._downHandler, opts);
		window.addEventListener("mousemove", this._moveHandler, opts);
		window.addEventListener("wheel", this._wheelHandler, opts);
	}

	detach() {
		if (!this._attached) return;
		this._attached = false;
		this._target = null;
		const opts = platform.passiveEvents ? {
			passive: false
		} : false;
		window.removeEventListener("mouseup", this._upHandler, opts);
		window.removeEventListener("mousedown", this._downHandler, opts);
		window.removeEventListener("mousemove", this._moveHandler, opts);
		window.removeEventListener("wheel", this._wheelHandler, opts);
	}

	disableContextMenu() {
		if (!this._target) return;

		this._target.addEventListener("contextmenu", this._contextMenuHandler);
	}

	enableContextMenu() {
		if (!this._target) return;

		this._target.removeEventListener("contextmenu", this._contextMenuHandler);
	}

	enablePointerLock(success, error) {
		if (!document.body.requestPointerLock) {
			if (error) error();
			return;
		}

		const s = () => {
			success();
			document.removeEventListener('pointerlockchange', s);
		};

		const e = () => {
			error();
			document.removeEventListener('pointerlockerror', e);
		};

		if (success) {
			document.addEventListener('pointerlockchange', s, false);
		}

		if (error) {
			document.addEventListener('pointerlockerror', e, false);
		}

		document.body.requestPointerLock();
	}

	disablePointerLock(success) {
		if (!document.exitPointerLock) {
			return;
		}

		const s = () => {
			success();
			document.removeEventListener('pointerlockchange', s);
		};

		if (success) {
			document.addEventListener('pointerlockchange', s, false);
		}

		document.exitPointerLock();
	}

	update() {
		this._lastbuttons[0] = this._buttons[0];
		this._lastbuttons[1] = this._buttons[1];
		this._lastbuttons[2] = this._buttons[2];
	}

	isPressed(button) {
		return this._buttons[button];
	}

	wasPressed(button) {
		return this._buttons[button] && !this._lastbuttons[button];
	}

	wasReleased(button) {
		return !this._buttons[button] && this._lastbuttons[button];
	}

	_handleUp(event) {
		this._buttons[event.button] = false;
		const e = new MouseEvent(this, event);
		if (!e.event) return;
		this.fire(EVENT_MOUSEUP, e);
	}

	_handleDown(event) {
		this._buttons[event.button] = true;
		const e = new MouseEvent(this, event);
		if (!e.event) return;
		this.fire(EVENT_MOUSEDOWN, e);
	}

	_handleMove(event) {
		const e = new MouseEvent(this, event);
		if (!e.event) return;
		this.fire(EVENT_MOUSEMOVE, e);
		this._lastX = e.x;
		this._lastY = e.y;
	}

	_handleWheel(event) {
		const e = new MouseEvent(this, event);
		if (!e.event) return;
		this.fire(EVENT_MOUSEWHEEL, e);
	}

	_getTargetCoords(event) {
		const rect = this._target.getBoundingClientRect();

		const left = Math.floor(rect.left);
		const top = Math.floor(rect.top);

		if (event.clientX < left || event.clientX >= left + this._target.clientWidth || event.clientY < top || event.clientY >= top + this._target.clientHeight) {
			return null;
		}

		return {
			x: event.clientX - left,
			y: event.clientY - top
		};
	}

}

class Controller {
	constructor(element, options = {}) {
		this._keyboard = options.keyboard || null;
		this._mouse = options.mouse || null;
		this._gamepads = options.gamepads || null;
		this._element = null;
		this._actions = {};
		this._axes = {};
		this._axesValues = {};

		if (element) {
			this.attach(element);
		}
	}

	attach(element) {
		this._element = element;

		if (this._keyboard) {
			this._keyboard.attach(element);
		}

		if (this._mouse) {
			this._mouse.attach(element);
		}
	}

	detach() {
		if (this._keyboard) {
			this._keyboard.detach();
		}

		if (this._mouse) {
			this._mouse.detach();
		}

		this._element = null;
	}

	disableContextMenu() {
		if (!this._mouse) {
			this._enableMouse();
		}

		this._mouse.disableContextMenu();
	}

	enableContextMenu() {
		if (!this._mouse) {
			this._enableMouse();
		}

		this._mouse.enableContextMenu();
	}

	update(dt) {
		if (this._keyboard) {
			this._keyboard.update(dt);
		}

		if (this._mouse) {
			this._mouse.update(dt);
		}

		if (this._gamepads) {
			this._gamepads.update(dt);
		}

		this._axesValues = {};

		for (const key in this._axes) {
			this._axesValues[key] = [];
		}
	}

	registerKeys(action, keys) {
		if (!this._keyboard) {
			this._enableKeyboard();
		}

		if (this._actions[action]) {
			throw new Error(`Action: ${action} already registered`);
		}

		if (keys === undefined) {
			throw new Error("Invalid button");
		}

		if (!keys.length) {
			keys = [keys];
		}

		if (this._actions[action]) {
			this._actions[action].push({
				type: ACTION_KEYBOARD,
				keys: keys
			});
		} else {
			this._actions[action] = [{
				type: ACTION_KEYBOARD,
				keys: keys
			}];
		}
	}

	registerMouse(action, button) {
		if (!this._mouse) {
			this._enableMouse();
		}

		if (button === undefined) {
			throw new Error('Invalid button');
		}

		if (this._actions[action]) {
			this._actions[action].push({
				type: ACTION_MOUSE,
				button: button
			});
		} else {
			this._actions[action] = [{
				type: ACTION_MOUSE,
				button: -button
			}];
		}
	}

	registerPadButton(action, pad, button) {
		if (button === undefined) {
			throw new Error('Invalid button');
		}

		if (this._actions[action]) {
			this._actions[action].push({
				type: ACTION_GAMEPAD,
				button: button,
				pad: pad
			});
		} else {
			this._actions[action] = [{
				type: ACTION_GAMEPAD,
				button: button,
				pad: pad
			}];
		}
	}

	registerAxis(options) {
		const name = options.name;

		if (!this._axes[name]) {
			this._axes[name] = [];
		}

		const i = this._axes[name].push(name);

		options = options || {};
		options.pad = options.pad || PAD_1;

		const bind = function bind(controller, source, value, key) {
			switch (source) {
				case 'mousex':
					controller._mouse.on(EVENT_MOUSEMOVE, function (e) {
						controller._axesValues[name][i] = e.dx / 10;
					});

					break;

				case 'mousey':
					controller._mouse.on(EVENT_MOUSEMOVE, function (e) {
						controller._axesValues[name][i] = e.dy / 10;
					});

					break;

				case 'key':
					controller._axes[name].push(function () {
						return controller._keyboard.isPressed(key) ? value : 0;
					});

					break;

				case 'padrx':
					controller._axes[name].push(function () {
						return controller._gamepads.getAxis(options.pad, PAD_R_STICK_X);
					});

					break;

				case 'padry':
					controller._axes[name].push(function () {
						return controller._gamepads.getAxis(options.pad, PAD_R_STICK_Y);
					});

					break;

				case 'padlx':
					controller._axes[name].push(function () {
						return controller._gamepads.getAxis(options.pad, PAD_L_STICK_X);
					});

					break;

				case 'padly':
					controller._axes[name].push(function () {
						return controller._gamepads.getAxis(options.pad, PAD_L_STICK_Y);
					});

					break;

				default:
					throw new Error('Unknown axis');
			}
		};

		bind(this, options.positive, 1, options.positiveKey);

		if (options.negativeKey || options.negative !== options.positive) {
			bind(this, options.negative, -1, options.negativeKey);
		}
	}

	isPressed(actionName) {
		if (!this._actions[actionName]) {
			return false;
		}

		const length = this._actions[actionName].length;

		for (let index = 0; index < length; ++index) {
			const action = this._actions[actionName][index];

			switch (action.type) {
				case ACTION_KEYBOARD:
					if (this._keyboard) {
						const len = action.keys.length;

						for (let i = 0; i < len; i++) {
							if (this._keyboard.isPressed(action.keys[i])) {
								return true;
							}
						}
					}

					break;

				case ACTION_MOUSE:
					if (this._mouse && this._mouse.isPressed(action.button)) {
						return true;
					}

					break;

				case ACTION_GAMEPAD:
					if (this._gamepads && this._gamepads.isPressed(action.pad, action.button)) {
						return true;
					}

					break;
			}
		}

		return false;
	}

	wasPressed(actionName) {
		if (!this._actions[actionName]) {
			return false;
		}

		const length = this._actions[actionName].length;

		for (let index = 0; index < length; ++index) {
			const action = this._actions[actionName][index];

			switch (action.type) {
				case ACTION_KEYBOARD:
					if (this._keyboard) {
						const len = action.keys.length;

						for (let i = 0; i < len; i++) {
							if (this._keyboard.wasPressed(action.keys[i])) {
								return true;
							}
						}
					}

					break;

				case ACTION_MOUSE:
					if (this._mouse && this._mouse.wasPressed(action.button)) {
						return true;
					}

					break;

				case ACTION_GAMEPAD:
					if (this._gamepads && this._gamepads.wasPressed(action.pad, action.button)) {
						return true;
					}

					break;
			}
		}

		return false;
	}

	getAxis(name) {
		let value = 0;

		if (this._axes[name]) {
			const len = this._axes[name].length;

			for (let i = 0; i < len; i++) {
				if (type(this._axes[name][i]) === 'function') {
					const v = this._axes[name][i]();

					if (Math.abs(v) > Math.abs(value)) {
						value = v;
					}
				} else if (this._axesValues[name]) {
					if (Math.abs(this._axesValues[name][i]) > Math.abs(value)) {
						value = this._axesValues[name][i];
					}
				}
			}
		}

		return value;
	}

	_enableMouse() {
		this._mouse = new Mouse();

		if (!this._element) {
			throw new Error("Controller must be attached to an Element");
		}

		this._mouse.attach(this._element);
	}

	_enableKeyboard() {
		this._keyboard = new Keyboard();

		if (!this._element) {
			throw new Error("Controller must be attached to an Element");
		}

		this._keyboard.attach(this._element);
	}

}

let targetX, targetY;
const vecA = new Vec3();
const vecB = new Vec3();
const rayA = new Ray();
const rayB = new Ray();
const rayC = new Ray();
rayA.end = new Vec3();
rayB.end = new Vec3();
rayC.end = new Vec3();

const _pq = new Vec3();

const _pa = new Vec3();

const _pb = new Vec3();

const _pc = new Vec3();

const _pd = new Vec3();

const _m = new Vec3();

const _au = new Vec3();

const _bv = new Vec3();

const _cw = new Vec3();

const _ir = new Vec3();

const _sct = new Vec3();

const _accumulatedScale = new Vec3();

const _paddingTop = new Vec3();

const _paddingBottom = new Vec3();

const _paddingLeft = new Vec3();

const _paddingRight = new Vec3();

const _cornerBottomLeft = new Vec3();

const _cornerBottomRight = new Vec3();

const _cornerTopRight = new Vec3();

const _cornerTopLeft = new Vec3();

const ZERO_VEC4 = new Vec4();

function scalarTriple(p1, p2, p3) {
	return _sct.cross(p1, p2).dot(p3);
}

function intersectLineQuad(p, q, corners) {
	_pq.sub2(q, p);

	_pa.sub2(corners[0], p);

	_pb.sub2(corners[1], p);

	_pc.sub2(corners[2], p);

	_m.cross(_pc, _pq);

	let v = _pa.dot(_m);

	let u;
	let w;

	if (v >= 0) {
		u = -_pb.dot(_m);
		if (u < 0) return -1;
		w = scalarTriple(_pq, _pb, _pa);
		if (w < 0) return -1;
		const denom = 1.0 / (u + v + w);

		_au.copy(corners[0]).mulScalar(u * denom);

		_bv.copy(corners[1]).mulScalar(v * denom);

		_cw.copy(corners[2]).mulScalar(w * denom);

		_ir.copy(_au).add(_bv).add(_cw);
	} else {
		_pd.sub2(corners[3], p);

		u = _pd.dot(_m);
		if (u < 0) return -1;
		w = scalarTriple(_pq, _pa, _pd);
		if (w < 0) return -1;
		v = -v;
		const denom = 1.0 / (u + v + w);

		_au.copy(corners[0]).mulScalar(u * denom);

		_bv.copy(corners[3]).mulScalar(v * denom);

		_cw.copy(corners[2]).mulScalar(w * denom);

		_ir.copy(_au).add(_bv).add(_cw);
	}

	if (_pq.sub2(corners[0], corners[2]).lengthSq() < 0.0001 * 0.0001) return -1;
	if (_pq.sub2(corners[1], corners[3]).lengthSq() < 0.0001 * 0.0001) return -1;
	return _ir.sub(p).lengthSq();
}

class ElementInputEvent {
	constructor(event, element, camera) {
		this.event = event;
		this.element = element;
		this.camera = camera;
		this._stopPropagation = false;
	}

	stopPropagation() {
		this._stopPropagation = true;

		if (this.event) {
			this.event.stopImmediatePropagation();
			this.event.stopPropagation();
		}
	}

}

class ElementMouseEvent extends ElementInputEvent {
	constructor(event, element, camera, x, y, lastX, lastY) {
		super(event, element, camera);
		this.x = x;
		this.y = y;
		this.ctrlKey = event.ctrlKey || false;
		this.altKey = event.altKey || false;
		this.shiftKey = event.shiftKey || false;
		this.metaKey = event.metaKey || false;
		this.button = event.button;

		if (Mouse.isPointerLocked()) {
			this.dx = event.movementX || event.webkitMovementX || event.mozMovementX || 0;
			this.dy = event.movementY || event.webkitMovementY || event.mozMovementY || 0;
		} else {
			this.dx = x - lastX;
			this.dy = y - lastY;
		}

		this.wheelDelta = 0;

		if (event.type === 'wheel') {
			if (event.deltaY > 0) {
				this.wheelDelta = 1;
			} else if (event.deltaY < 0) {
				this.wheelDelta = -1;
			}
		}
	}

}

class ElementTouchEvent extends ElementInputEvent {
	constructor(event, element, camera, x, y, touch) {
		super(event, element, camera);
		this.touches = event.touches;
		this.changedTouches = event.changedTouches;
		this.x = x;
		this.y = y;
		this.touch = touch;
	}

}

class ElementSelectEvent extends ElementInputEvent {
	constructor(event, element, camera, inputSource) {
		super(event, element, camera);
		this.inputSource = inputSource;
	}

}

class ElementInput {
	constructor(domElement, options) {
		this._app = null;
		this._attached = false;
		this._target = null;
		this._enabled = true;
		this._lastX = 0;
		this._lastY = 0;
		this._upHandler = this._handleUp.bind(this);
		this._downHandler = this._handleDown.bind(this);
		this._moveHandler = this._handleMove.bind(this);
		this._wheelHandler = this._handleWheel.bind(this);
		this._touchstartHandler = this._handleTouchStart.bind(this);
		this._touchendHandler = this._handleTouchEnd.bind(this);
		this._touchcancelHandler = this._touchendHandler;
		this._touchmoveHandler = this._handleTouchMove.bind(this);
		this._sortHandler = this._sortElements.bind(this);
		this._elements = [];
		this._hoveredElement = null;
		this._pressedElement = null;
		this._touchedElements = {};
		this._touchesForWhichTouchLeaveHasFired = {};
		this._selectedElements = {};
		this._selectedPressedElements = {};
		this._useMouse = !options || options.useMouse !== false;
		this._useTouch = !options || options.useTouch !== false;
		this._useXr = !options || options.useXr !== false;
		this._selectEventsAttached = false;
		if (platform.touch) this._clickedEntities = {};
		this.attach(domElement);
	}

	set enabled(value) {
		this._enabled = value;
	}

	get enabled() {
		return this._enabled;
	}

	set app(value) {
		this._app = value;
	}

	get app() {
		return this._app || getApplication();
	}

	attach(domElement) {
		if (this._attached) {
			this._attached = false;
			this.detach();
		}

		this._target = domElement;
		this._attached = true;
		const opts = platform.passiveEvents ? {
			passive: true
		} : false;

		if (this._useMouse) {
			window.addEventListener('mouseup', this._upHandler, opts);
			window.addEventListener('mousedown', this._downHandler, opts);
			window.addEventListener('mousemove', this._moveHandler, opts);
			window.addEventListener('wheel', this._wheelHandler, opts);
		}

		if (this._useTouch && platform.touch) {
			this._target.addEventListener('touchstart', this._touchstartHandler, opts);

			this._target.addEventListener('touchend', this._touchendHandler, false);

			this._target.addEventListener('touchmove', this._touchmoveHandler, false);

			this._target.addEventListener('touchcancel', this._touchcancelHandler, false);
		}

		this.attachSelectEvents();
	}

	attachSelectEvents() {
		if (!this._selectEventsAttached && this._useXr && this.app && this.app.xr && this.app.xr.supported) {
			if (!this._clickedEntities) this._clickedEntities = {};
			this._selectEventsAttached = true;
			this.app.xr.on('start', this._onXrStart, this);
		}
	}

	detach() {
		if (!this._attached) return;
		this._attached = false;
		const opts = platform.passiveEvents ? {
			passive: true
		} : false;

		if (this._useMouse) {
			window.removeEventListener('mouseup', this._upHandler, opts);
			window.removeEventListener('mousedown', this._downHandler, opts);
			window.removeEventListener('mousemove', this._moveHandler, opts);
			window.removeEventListener('wheel', this._wheelHandler, opts);
		}

		if (this._useTouch) {
			this._target.removeEventListener('touchstart', this._touchstartHandler, opts);

			this._target.removeEventListener('touchend', this._touchendHandler, false);

			this._target.removeEventListener('touchmove', this._touchmoveHandler, false);

			this._target.removeEventListener('touchcancel', this._touchcancelHandler, false);
		}

		if (this._selectEventsAttached) {
			this._selectEventsAttached = false;
			this.app.xr.off('start', this._onXrStart, this);
			this.app.xr.off('end', this._onXrEnd, this);
			this.app.xr.off('update', this._onXrUpdate, this);
			this.app.xr.input.off('selectstart', this._onSelectStart, this);
			this.app.xr.input.off('selectend', this._onSelectEnd, this);
			this.app.xr.input.off('remove', this._onXrInputRemove, this);
		}

		this._target = null;
	}

	addElement(element) {
		if (this._elements.indexOf(element) === -1) this._elements.push(element);
	}

	removeElement(element) {
		const idx = this._elements.indexOf(element);

		if (idx !== -1) this._elements.splice(idx, 1);
	}

	_handleUp(event) {
		if (!this._enabled) return;
		if (Mouse.isPointerLocked()) return;

		this._calcMouseCoords(event);

		if (targetX === null) return;

		this._onElementMouseEvent('mouseup', event);
	}

	_handleDown(event) {
		if (!this._enabled) return;
		if (Mouse.isPointerLocked()) return;

		this._calcMouseCoords(event);

		if (targetX === null) return;

		this._onElementMouseEvent('mousedown', event);
	}

	_handleMove(event) {
		if (!this._enabled) return;

		this._calcMouseCoords(event);

		if (targetX === null) return;

		this._onElementMouseEvent('mousemove', event);

		this._lastX = targetX;
		this._lastY = targetY;
	}

	_handleWheel(event) {
		if (!this._enabled) return;

		this._calcMouseCoords(event);

		if (targetX === null) return;

		this._onElementMouseEvent('mousewheel', event);
	}

	_determineTouchedElements(event) {
		const touchedElements = {};
		const cameras = this.app.systems.camera.cameras;

		for (let i = cameras.length - 1; i >= 0; i--) {
			const camera = cameras[i];
			let done = 0;
			const len = event.changedTouches.length;

			for (let j = 0; j < len; j++) {
				if (touchedElements[event.changedTouches[j].identifier]) {
					done++;
					continue;
				}

				const coords = this._calcTouchCoords(event.changedTouches[j]);

				const element = this._getTargetElement(camera, coords.x, coords.y);

				if (element) {
					done++;
					touchedElements[event.changedTouches[j].identifier] = {
						element: element,
						camera: camera,
						x: coords.x,
						y: coords.y
					};
				}
			}

			if (done === len) {
				break;
			}
		}

		return touchedElements;
	}

	_handleTouchStart(event) {
		if (!this._enabled) return;

		const newTouchedElements = this._determineTouchedElements(event);

		for (let i = 0, len = event.changedTouches.length; i < len; i++) {
			const touch = event.changedTouches[i];
			const newTouchInfo = newTouchedElements[touch.identifier];
			const oldTouchInfo = this._touchedElements[touch.identifier];

			if (newTouchInfo && (!oldTouchInfo || newTouchInfo.element !== oldTouchInfo.element)) {
				this._fireEvent(event.type, new ElementTouchEvent(event, newTouchInfo.element, newTouchInfo.camera, newTouchInfo.x, newTouchInfo.y, touch));

				this._touchesForWhichTouchLeaveHasFired[touch.identifier] = false;
			}
		}

		for (const touchId in newTouchedElements) {
			this._touchedElements[touchId] = newTouchedElements[touchId];
		}
	}

	_handleTouchEnd(event) {
		if (!this._enabled) return;
		const cameras = this.app.systems.camera.cameras;

		for (const key in this._clickedEntities) {
			delete this._clickedEntities[key];
		}

		for (let i = 0, len = event.changedTouches.length; i < len; i++) {
			const touch = event.changedTouches[i];
			const touchInfo = this._touchedElements[touch.identifier];
			if (!touchInfo) continue;
			const element = touchInfo.element;
			const camera = touchInfo.camera;
			const x = touchInfo.x;
			const y = touchInfo.y;
			delete this._touchedElements[touch.identifier];
			delete this._touchesForWhichTouchLeaveHasFired[touch.identifier];

			this._fireEvent(event.type, new ElementTouchEvent(event, element, camera, x, y, touch));

			if (event.touches.length === 0) {
				const coords = this._calcTouchCoords(touch);

				for (let c = cameras.length - 1; c >= 0; c--) {
					const hovered = this._getTargetElement(cameras[c], coords.x, coords.y);

					if (hovered === element) {
						if (!this._clickedEntities[element.entity.getGuid()]) {
							this._fireEvent('click', new ElementTouchEvent(event, element, camera, x, y, touch));

							this._clickedEntities[element.entity.getGuid()] = true;
						}
					}
				}
			}
		}
	}

	_handleTouchMove(event) {
		event.preventDefault();
		if (!this._enabled) return;

		const newTouchedElements = this._determineTouchedElements(event);

		for (let i = 0, len = event.changedTouches.length; i < len; i++) {
			const touch = event.changedTouches[i];
			const newTouchInfo = newTouchedElements[touch.identifier];
			const oldTouchInfo = this._touchedElements[touch.identifier];

			if (oldTouchInfo) {
				const coords = this._calcTouchCoords(touch);

				if ((!newTouchInfo || newTouchInfo.element !== oldTouchInfo.element) && !this._touchesForWhichTouchLeaveHasFired[touch.identifier]) {
					this._fireEvent('touchleave', new ElementTouchEvent(event, oldTouchInfo.element, oldTouchInfo.camera, coords.x, coords.y, touch));

					this._touchesForWhichTouchLeaveHasFired[touch.identifier] = true;
				}

				this._fireEvent('touchmove', new ElementTouchEvent(event, oldTouchInfo.element, oldTouchInfo.camera, coords.x, coords.y, touch));
			}
		}
	}

	_onElementMouseEvent(eventType, event) {
		let element;
		const hovered = this._hoveredElement;
		this._hoveredElement = null;
		const cameras = this.app.systems.camera.cameras;
		let camera;

		for (let i = cameras.length - 1; i >= 0; i--) {
			camera = cameras[i];
			element = this._getTargetElement(camera, targetX, targetY);
			if (element) break;
		}

		if (element) {
			this._fireEvent(eventType, new ElementMouseEvent(event, element, camera, targetX, targetY, this._lastX, this._lastY));

			this._hoveredElement = element;

			if (eventType === 'mousedown') {
				this._pressedElement = element;
			}
		}

		if (hovered !== this._hoveredElement) {
			if (hovered) {
				this._fireEvent('mouseleave', new ElementMouseEvent(event, hovered, camera, targetX, targetY, this._lastX, this._lastY));
			}

			if (this._hoveredElement) {
				this._fireEvent('mouseenter', new ElementMouseEvent(event, this._hoveredElement, camera, targetX, targetY, this._lastX, this._lastY));
			}
		}

		if (eventType === 'mouseup' && this._pressedElement) {
			if (this._pressedElement === this._hoveredElement) {
				this._pressedElement = null;

				if (!this._clickedEntities || !this._clickedEntities[this._hoveredElement.entity.getGuid()]) {
					this._fireEvent('click', new ElementMouseEvent(event, this._hoveredElement, camera, targetX, targetY, this._lastX, this._lastY));
				}
			} else {
				this._pressedElement = null;
			}
		}
	}

	_onXrStart() {
		this.app.xr.on('end', this._onXrEnd, this);
		this.app.xr.on('update', this._onXrUpdate, this);
		this.app.xr.input.on('selectstart', this._onSelectStart, this);
		this.app.xr.input.on('selectend', this._onSelectEnd, this);
		this.app.xr.input.on('remove', this._onXrInputRemove, this);
	}

	_onXrEnd() {
		this.app.xr.off('update', this._onXrUpdate, this);
		this.app.xr.input.off('selectstart', this._onSelectStart, this);
		this.app.xr.input.off('selectend', this._onSelectEnd, this);
		this.app.xr.input.off('remove', this._onXrInputRemove, this);
	}

	_onXrUpdate() {
		if (!this._enabled) return;
		const inputSources = this.app.xr.input.inputSources;

		for (let i = 0; i < inputSources.length; i++) {
			this._onElementSelectEvent('selectmove', inputSources[i], null);
		}
	}

	_onXrInputRemove(inputSource) {
		const hovered = this._selectedElements[inputSource.id];

		if (hovered) {
			inputSource._elementEntity = null;

			this._fireEvent('selectleave', new ElementSelectEvent(null, hovered, null, inputSource));
		}

		delete this._selectedElements[inputSource.id];
		delete this._selectedPressedElements[inputSource.id];
	}

	_onSelectStart(inputSource, event) {
		if (!this._enabled) return;

		this._onElementSelectEvent('selectstart', inputSource, event);
	}

	_onSelectEnd(inputSource, event) {
		if (!this._enabled) return;

		this._onElementSelectEvent('selectend', inputSource, event);
	}

	_onElementSelectEvent(eventType, inputSource, event) {
		let element;
		const hoveredBefore = this._selectedElements[inputSource.id];
		let hoveredNow;
		const cameras = this.app.systems.camera.cameras;
		let camera;

		if (inputSource.elementInput) {
			rayC.set(inputSource.getOrigin(), inputSource.getDirection());

			for (let i = cameras.length - 1; i >= 0; i--) {
				camera = cameras[i];
				element = this._getTargetElementByRay(rayC, camera);
				if (element) break;
			}
		}

		inputSource._elementEntity = element || null;

		if (element) {
			this._selectedElements[inputSource.id] = element;
			hoveredNow = element;
		} else {
			delete this._selectedElements[inputSource.id];
		}

		if (hoveredBefore !== hoveredNow) {
			if (hoveredBefore) this._fireEvent('selectleave', new ElementSelectEvent(event, hoveredBefore, camera, inputSource));
			if (hoveredNow) this._fireEvent('selectenter', new ElementSelectEvent(event, hoveredNow, camera, inputSource));
		}

		if (eventType === 'selectstart') {
			this._selectedPressedElements[inputSource.id] = hoveredNow;
			if (hoveredNow) this._fireEvent('selectstart', new ElementSelectEvent(event, hoveredNow, camera, inputSource));
		}

		const pressed = this._selectedPressedElements[inputSource.id];

		if (!inputSource.elementInput && pressed) {
			delete this._selectedPressedElements[inputSource.id];
			if (hoveredBefore) this._fireEvent('selectend', new ElementSelectEvent(event, hoveredBefore, camera, inputSource));
		}

		if (eventType === 'selectend' && inputSource.elementInput) {
			delete this._selectedPressedElements[inputSource.id];
			if (hoveredBefore) this._fireEvent('selectend', new ElementSelectEvent(event, hoveredBefore, camera, inputSource));

			if (pressed && pressed === hoveredBefore) {
				this._fireEvent('click', new ElementSelectEvent(event, pressed, camera, inputSource));
			}
		}
	}

	_fireEvent(name, evt) {
		let element = evt.element;

		while (true) {
			element.fire(name, evt);
			if (evt._stopPropagation) break;
			if (!element.entity.parent) break;
			element = element.entity.parent.element;
			if (!element) break;
		}
	}

	_calcMouseCoords(event) {
		const rect = this._target.getBoundingClientRect();

		const left = Math.floor(rect.left);
		const top = Math.floor(rect.top);

		if (event.clientX < left || event.clientX >= left + this._target.clientWidth || event.clientY < top || event.clientY >= top + this._target.clientHeight) {
			targetX = null;
			targetY = null;
		} else {
			targetX = event.clientX - left;
			targetY = event.clientY - top;
		}
	}

	_calcTouchCoords(touch) {
		let totalOffsetX = 0;
		let totalOffsetY = 0;
		let target = touch.target;

		while (!(target instanceof HTMLElement)) {
			target = target.parentNode;
		}

		let currentElement = target;

		do {
			totalOffsetX += currentElement.offsetLeft - currentElement.scrollLeft;
			totalOffsetY += currentElement.offsetTop - currentElement.scrollTop;
			currentElement = currentElement.offsetParent;
		} while (currentElement);

		return {
			x: touch.pageX - totalOffsetX,
			y: touch.pageY - totalOffsetY
		};
	}

	_sortElements(a, b) {
		const layerOrder = this.app.scene.layers.sortTransparentLayers(a.layers, b.layers);
		if (layerOrder !== 0) return layerOrder;
		if (a.screen && !b.screen) return -1;
		if (!a.screen && b.screen) return 1;
		if (!a.screen && !b.screen) return 0;
		if (a.screen.screen.screenSpace && !b.screen.screen.screenSpace) return -1;
		if (b.screen.screen.screenSpace && !a.screen.screen.screenSpace) return 1;
		return b.drawOrder - a.drawOrder;
	}

	_getTargetElement(camera, x, y) {
		let result = null;
		let closestDistance3d = Infinity;

		this._elements.sort(this._sortHandler);

		let rayScreen, ray3d;

		for (let i = 0, len = this._elements.length; i < len; i++) {
			const element = this._elements[i];

			if (element.screen && element.screen.screen.screenSpace) {
				if (rayScreen === undefined) {
					rayScreen = this._calculateRayScreen(x, y, camera, rayA) ? rayA : null;
				}

				if (!rayScreen) continue;

				const currentDistance = this._checkElement(rayScreen, element, true);

				if (currentDistance >= 0) {
					result = element;
					break;
				}
			} else {
				if (ray3d === undefined) {
					ray3d = this._calculateRay3d(x, y, camera, rayB) ? rayB : null;
				}

				if (!ray3d) continue;

				const currentDistance = this._checkElement(ray3d, element, false);

				if (currentDistance >= 0) {
					if (currentDistance < closestDistance3d) {
						result = element;
						closestDistance3d = currentDistance;
					}

					if (element.screen) {
						result = element;
						break;
					}
				}
			}
		}

		return result;
	}

	_getTargetElementByRay(ray, camera) {
		let result = null;
		rayA.origin.copy(ray.origin);
		rayA.direction.copy(ray.direction);
		rayA.end.copy(rayA.direction).mulScalar(camera.farClip * 2).add(rayA.origin);

		this._elements.sort(this._sortHandler);

		for (let i = 0, len = this._elements.length; i < len; i++) {
			const element = this._elements[i];

			if (!element.screen || !element.screen.screen.screenSpace) {
				if (this._checkElement(rayA, element, false) >= 0) {
					result = element;
					break;
				}
			}
		}

		return result;
	}

	_buildHitCorners(element, screenOrWorldCorners, scaleX, scaleY, scaleZ) {
		let hitCorners = screenOrWorldCorners;
		const button = element.entity && element.entity.button;

		if (button) {
			const hitPadding = element.entity.button.hitPadding || ZERO_VEC4;

			_paddingTop.copy(element.entity.up);

			_paddingBottom.copy(_paddingTop).mulScalar(-1);

			_paddingRight.copy(element.entity.right);

			_paddingLeft.copy(_paddingRight).mulScalar(-1);

			_paddingTop.mulScalar(hitPadding.w * scaleY);

			_paddingBottom.mulScalar(hitPadding.y * scaleY);

			_paddingRight.mulScalar(hitPadding.z * scaleX);

			_paddingLeft.mulScalar(hitPadding.x * scaleX);

			_cornerBottomLeft.copy(hitCorners[0]).add(_paddingBottom).add(_paddingLeft);

			_cornerBottomRight.copy(hitCorners[1]).add(_paddingBottom).add(_paddingRight);

			_cornerTopRight.copy(hitCorners[2]).add(_paddingTop).add(_paddingRight);

			_cornerTopLeft.copy(hitCorners[3]).add(_paddingTop).add(_paddingLeft);

			hitCorners = [_cornerBottomLeft, _cornerBottomRight, _cornerTopRight, _cornerTopLeft];
		}

		if (scaleX < 0) {
			const left = hitCorners[2].x;
			const right = hitCorners[0].x;
			hitCorners[0].x = left;
			hitCorners[1].x = right;
			hitCorners[2].x = right;
			hitCorners[3].x = left;
		}

		if (scaleY < 0) {
			const bottom = hitCorners[2].y;
			const top = hitCorners[0].y;
			hitCorners[0].y = bottom;
			hitCorners[1].y = bottom;
			hitCorners[2].y = top;
			hitCorners[3].y = top;
		}

		if (scaleZ < 0) {
			const x = hitCorners[2].x;
			const y = hitCorners[2].y;
			const z = hitCorners[2].z;
			hitCorners[2].x = hitCorners[0].x;
			hitCorners[2].y = hitCorners[0].y;
			hitCorners[2].z = hitCorners[0].z;
			hitCorners[0].x = x;
			hitCorners[0].y = y;
			hitCorners[0].z = z;
		}

		return hitCorners;
	}

	_calculateScaleToScreen(element) {
		let current = element.entity;
		const screenScale = element.screen.screen.scale;

		_accumulatedScale.set(screenScale, screenScale, screenScale);

		while (current && !current.screen) {
			_accumulatedScale.mul(current.getLocalScale());

			current = current.parent;
		}

		return _accumulatedScale;
	}

	_calculateScaleToWorld(element) {
		let current = element.entity;

		_accumulatedScale.set(1, 1, 1);

		while (current) {
			_accumulatedScale.mul(current.getLocalScale());

			current = current.parent;
		}

		return _accumulatedScale;
	}

	_calculateRayScreen(x, y, camera, ray) {
		const sw = this.app.graphicsDevice.width;
		const sh = this.app.graphicsDevice.height;
		const cameraWidth = camera.rect.z * sw;
		const cameraHeight = camera.rect.w * sh;
		const cameraLeft = camera.rect.x * sw;
		const cameraRight = cameraLeft + cameraWidth;
		const cameraBottom = (1 - camera.rect.y) * sh;
		const cameraTop = cameraBottom - cameraHeight;

		let _x = x * sw / this._target.clientWidth;

		let _y = y * sh / this._target.clientHeight;

		if (_x >= cameraLeft && _x <= cameraRight && _y <= cameraBottom && _y >= cameraTop) {
			_x = sw * (_x - cameraLeft) / cameraWidth;
			_y = sh * (_y - cameraTop) / cameraHeight;
			_y = sh - _y;
			ray.origin.set(_x, _y, 1);
			ray.direction.set(0, 0, -1);
			ray.end.copy(ray.direction).mulScalar(2).add(ray.origin);
			return true;
		}

		return false;
	}

	_calculateRay3d(x, y, camera, ray) {
		const sw = this._target.clientWidth;
		const sh = this._target.clientHeight;
		const cameraWidth = camera.rect.z * sw;
		const cameraHeight = camera.rect.w * sh;
		const cameraLeft = camera.rect.x * sw;
		const cameraRight = cameraLeft + cameraWidth;
		const cameraBottom = (1 - camera.rect.y) * sh;
		const cameraTop = cameraBottom - cameraHeight;
		let _x = x;
		let _y = y;

		if (x >= cameraLeft && x <= cameraRight && y <= cameraBottom && _y >= cameraTop) {
			_x = sw * (_x - cameraLeft) / cameraWidth;
			_y = sh * (_y - cameraTop) / cameraHeight;
			camera.screenToWorld(_x, _y, camera.nearClip, vecA);
			camera.screenToWorld(_x, _y, camera.farClip, vecB);
			ray.origin.copy(vecA);
			ray.direction.set(0, 0, -1);
			ray.end.copy(vecB);
			return true;
		}

		return false;
	}

	_checkElement(ray, element, screen) {
		if (element.maskedBy) {
			if (this._checkElement(ray, element.maskedBy.element, screen) < 0) {
				return -1;
			}
		}

		let scale;

		if (screen) {
			scale = this._calculateScaleToScreen(element);
		} else {
			scale = this._calculateScaleToWorld(element);
		}

		const corners = this._buildHitCorners(element, screen ? element.screenCorners : element.worldCorners, scale.x, scale.y, scale.z);

		return intersectLineQuad(ray.origin, ray.end, corners);
	}

}

const MAPS = {
	DEFAULT: {
		buttons: ['PAD_FACE_1', 'PAD_FACE_2', 'PAD_FACE_3', 'PAD_FACE_4', 'PAD_L_SHOULDER_1', 'PAD_R_SHOULDER_1', 'PAD_L_SHOULDER_2', 'PAD_R_SHOULDER_2', 'PAD_SELECT', 'PAD_START', 'PAD_L_STICK_BUTTON', 'PAD_R_STICK_BUTTON', 'PAD_UP', 'PAD_DOWN', 'PAD_LEFT', 'PAD_RIGHT', 'PAD_VENDOR'],
		axes: ['PAD_L_STICK_X', 'PAD_L_STICK_Y', 'PAD_R_STICK_X', 'PAD_R_STICK_Y']
	},
	PS3: {
		buttons: ['PAD_FACE_1', 'PAD_FACE_2', 'PAD_FACE_4', 'PAD_FACE_3', 'PAD_L_SHOULDER_1', 'PAD_R_SHOULDER_1', 'PAD_L_SHOULDER_2', 'PAD_R_SHOULDER_2', 'PAD_SELECT', 'PAD_START', 'PAD_L_STICK_BUTTON', 'PAD_R_STICK_BUTTON', 'PAD_UP', 'PAD_DOWN', 'PAD_LEFT', 'PAD_RIGHT', 'PAD_VENDOR'],
		axes: ['PAD_L_STICK_X', 'PAD_L_STICK_Y', 'PAD_R_STICK_X', 'PAD_R_STICK_Y']
	}
};
const PRODUCT_CODES = {
	'Product: 0268': 'PS3'
};

class GamePads {
	constructor() {
		this.gamepadsSupported = !!navigator.getGamepads || !!navigator.webkitGetGamepads;
		this.current = [];
		this.previous = [];
		this.deadZone = 0.25;
	}

	update() {
		for (let i = 0, l = this.current.length; i < l; i++) {
			const buttons = this.current[i].pad.buttons;
			const buttonsLen = buttons.length;

			for (let j = 0; j < buttonsLen; j++) {
				if (this.previous[i] === undefined) {
					this.previous[i] = [];
				}

				this.previous[i][j] = buttons[j].pressed;
			}
		}

		this.poll(this.current);
	}

	poll(pads = []) {
		if (pads.length > 0) {
			pads.length = 0;
		}

		if (this.gamepadsSupported) {
			const padDevices = navigator.getGamepads ? navigator.getGamepads() : navigator.webkitGetGamepads();

			for (let i = 0, len = padDevices.length; i < len; i++) {
				if (padDevices[i]) {
					pads.push({
						map: this.getMap(padDevices[i]),
						pad: padDevices[i]
					});
				}
			}
		}

		return pads;
	}

	getMap(pad) {
		for (const code in PRODUCT_CODES) {
			if (pad.id.indexOf(code) >= 0) {
				return MAPS[PRODUCT_CODES[code]];
			}
		}

		return MAPS.DEFAULT;
	}

	isPressed(index, button) {
		if (!this.current[index]) {
			return false;
		}

		const key = this.current[index].map.buttons[button];
		return this.current[index].pad.buttons[pc[key]].pressed;
	}

	wasPressed(index, button) {
		if (!this.current[index]) {
			return false;
		}

		const key = this.current[index].map.buttons[button];
		const i = pc[key];
		return this.current[index].pad.buttons[i].pressed && !(this.previous[index] && this.previous[index][i]);
	}

	wasReleased(index, button) {
		if (!this.current[index]) {
			return false;
		}

		const key = this.current[index].map.buttons[button];
		const i = pc[key];
		return !this.current[index].pad.buttons[i].pressed && this.previous[index] && this.previous[index][i];
	}

	getAxis(index, axes) {
		if (!this.current[index]) {
			return 0;
		}

		const key = this.current[index].map.axes[axes];
		let value = this.current[index].pad.axes[pc[key]];

		if (Math.abs(value) < this.deadZone) {
			value = 0;
		}

		return value;
	}

}

function getTouchTargetCoords(touch) {
	let totalOffsetX = 0;
	let totalOffsetY = 0;
	let target = touch.target;

	while (!(target instanceof HTMLElement)) {
		target = target.parentNode;
	}

	let currentElement = target;

	do {
		totalOffsetX += currentElement.offsetLeft - currentElement.scrollLeft;
		totalOffsetY += currentElement.offsetTop - currentElement.scrollTop;
		currentElement = currentElement.offsetParent;
	} while (currentElement);

	return {
		x: touch.pageX - totalOffsetX,
		y: touch.pageY - totalOffsetY
	};
}

class Touch {
	constructor(touch) {
		const coords = getTouchTargetCoords(touch);
		this.id = touch.identifier;
		this.x = coords.x;
		this.y = coords.y;
		this.target = touch.target;
		this.touch = touch;
	}

}

class TouchEvent {
	constructor(device, event) {
		this.element = event.target;
		this.event = event;
		this.touches = [];
		this.changedTouches = [];

		if (event) {
			for (let i = 0, l = event.touches.length; i < l; i++) {
				this.touches.push(new Touch(event.touches[i]));
			}

			for (let i = 0, l = event.changedTouches.length; i < l; i++) {
				this.changedTouches.push(new Touch(event.changedTouches[i]));
			}
		}
	}

	getTouchById(id, list) {
		for (let i = 0, l = list.length; i < l; i++) {
			if (list[i].id === id) {
				return list[i];
			}
		}

		return null;
	}

}

class TouchDevice extends EventHandler {
	constructor(element) {
		super();
		this._element = null;
		this._startHandler = this._handleTouchStart.bind(this);
		this._endHandler = this._handleTouchEnd.bind(this);
		this._moveHandler = this._handleTouchMove.bind(this);
		this._cancelHandler = this._handleTouchCancel.bind(this);
		this.attach(element);
	}

	attach(element) {
		if (this._element) {
			this.detach();
		}

		this._element = element;

		this._element.addEventListener('touchstart', this._startHandler, false);

		this._element.addEventListener('touchend', this._endHandler, false);

		this._element.addEventListener('touchmove', this._moveHandler, false);

		this._element.addEventListener('touchcancel', this._cancelHandler, false);
	}

	detach() {
		if (this._element) {
			this._element.removeEventListener('touchstart', this._startHandler, false);

			this._element.removeEventListener('touchend', this._endHandler, false);

			this._element.removeEventListener('touchmove', this._moveHandler, false);

			this._element.removeEventListener('touchcancel', this._cancelHandler, false);
		}

		this._element = null;
	}

	_handleTouchStart(e) {
		this.fire('touchstart', new TouchEvent(this, e));
	}

	_handleTouchEnd(e) {
		this.fire('touchend', new TouchEvent(this, e));
	}

	_handleTouchMove(e) {
		e.preventDefault();
		this.fire('touchmove', new TouchEvent(this, e));
	}

	_handleTouchCancel(e) {
		this.fire('touchcancel', new TouchEvent(this, e));
	}

}

const log = {
	write: function (text) {
		console.log(text);
	},
	open: function () {
		log.write("Powered by PlayCanvas " + version + " " + revision);
	},
	info: function (text) {
		console.info("INFO:		" + text);
	},
	debug: function (text) {
		console.debug("DEBUG:	 " + text);
	},
	error: function (text) {
		console.error("ERROR:	 " + text);
	},
	warning: function (text) {
		console.warn("WARNING: " + text);
	},
	alert: function (text) {
		log.write("ALERT:	 " + text);
		alert(text);
	},
	assert: function (condition, text) {
		if (condition === false) {
			log.write("ASSERT:	" + text);
		}
	}
};

string.endsWith = function (s, subs) {
	return s.endsWith(subs);
};

string.startsWith = function (s, subs) {
	return s.startsWith(subs);
};

const time = {
	now: now,
	Timer: Timer
};
Object.defineProperty(Color.prototype, "data", {
	get: function () {
		if (!this._data) {
			this._data = new Float32Array(4);
		}

		this._data[0] = this.r;
		this._data[1] = this.g;
		this._data[2] = this.b;
		this._data[3] = this.a;
		return this._data;
	}
});
Object.defineProperty(Color.prototype, "data3", {
	get: function () {
		if (!this._data3) {
			this._data3 = new Float32Array(3);
		}

		this._data3[0] = this.r;
		this._data3[1] = this.g;
		this._data3[2] = this.b;
		return this._data3;
	}
});
function inherits(Self, Super) {
	const Temp = function Temp() {};

	const Func = function Func(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {
		Super.call(this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
		Self.call(this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
	};

	Func._super = Super.prototype;
	Temp.prototype = Super.prototype;
	Func.prototype = new Temp();
	return Func;
}
function makeArray(arr) {
	return Array.prototype.slice.call(arr);
}
math.INV_LOG2 = Math.LOG2E;
math.intToBytes = math.intToBytes32;
math.bytesToInt = math.bytesToInt32;
Object.defineProperty(Vec2.prototype, "data", {
	get: function () {
		if (!this._data) {
			this._data = new Float32Array(2);
		}

		this._data[0] = this.x;
		this._data[1] = this.y;
		return this._data;
	}
});
Vec2.prototype.scale = Vec2.prototype.mulScalar;
Object.defineProperty(Vec3.prototype, "data", {
	get: function () {
		if (!this._data) {
			this._data = new Float32Array(3);
		}

		this._data[0] = this.x;
		this._data[1] = this.y;
		this._data[2] = this.z;
		return this._data;
	}
});
Vec3.prototype.scale = Vec3.prototype.mulScalar;
Object.defineProperty(Vec4.prototype, "data", {
	get: function () {
		if (!this._data) {
			this._data = new Float32Array(4);
		}

		this._data[0] = this.x;
		this._data[1] = this.y;
		this._data[2] = this.z;
		this._data[3] = this.w;
		return this._data;
	}
});
Vec4.prototype.scale = Vec4.prototype.mulScalar;
const shape = {
	Aabb: BoundingBox,
	Sphere: BoundingSphere,
	Plane: Plane
};
BoundingSphere.prototype.intersectRay = BoundingSphere.prototype.intersectsRay;

Frustum.prototype.update = function (projectionMatrix, viewMatrix) {
	const viewProj = new Mat4();
	viewProj.mul2(projectionMatrix, viewMatrix);
	this.setFromMat4(viewProj);
};

const ELEMENTTYPE_INT8 = TYPE_INT8;
const ELEMENTTYPE_UINT8 = TYPE_UINT8;
const ELEMENTTYPE_INT16 = TYPE_INT16;
const ELEMENTTYPE_UINT16 = TYPE_UINT16;
const ELEMENTTYPE_INT32 = TYPE_INT32;
const ELEMENTTYPE_UINT32 = TYPE_UINT32;
const ELEMENTTYPE_FLOAT32 = TYPE_FLOAT32;
function UnsupportedBrowserError(message) {
	this.name = "UnsupportedBrowserError";
	this.message = message || "";
}
UnsupportedBrowserError.prototype = Error.prototype;
function ContextCreationError(message) {
	this.name = "ContextCreationError";
	this.message = message || "";
}
ContextCreationError.prototype = Error.prototype;
const gfx = {
	ADDRESS_CLAMP_TO_EDGE: ADDRESS_CLAMP_TO_EDGE,
	ADDRESS_MIRRORED_REPEAT: ADDRESS_MIRRORED_REPEAT,
	ADDRESS_REPEAT: ADDRESS_REPEAT,
	BLENDMODE_ZERO: BLENDMODE_ZERO,
	BLENDMODE_ONE: BLENDMODE_ONE,
	BLENDMODE_SRC_COLOR: BLENDMODE_SRC_COLOR,
	BLENDMODE_ONE_MINUS_SRC_COLOR: BLENDMODE_ONE_MINUS_SRC_COLOR,
	BLENDMODE_DST_COLOR: BLENDMODE_DST_COLOR,
	BLENDMODE_ONE_MINUS_DST_COLOR: BLENDMODE_ONE_MINUS_DST_COLOR,
	BLENDMODE_SRC_ALPHA: BLENDMODE_SRC_ALPHA,
	BLENDMODE_SRC_ALPHA_SATURATE: BLENDMODE_SRC_ALPHA_SATURATE,
	BLENDMODE_ONE_MINUS_SRC_ALPHA: BLENDMODE_ONE_MINUS_SRC_ALPHA,
	BLENDMODE_DST_ALPHA: BLENDMODE_DST_ALPHA,
	BLENDMODE_ONE_MINUS_DST_ALPHA: BLENDMODE_ONE_MINUS_DST_ALPHA,
	BUFFER_STATIC: BUFFER_STATIC,
	BUFFER_DYNAMIC: BUFFER_DYNAMIC,
	BUFFER_STREAM: BUFFER_STREAM,
	CULLFACE_NONE: CULLFACE_NONE,
	CULLFACE_BACK: CULLFACE_BACK,
	CULLFACE_FRONT: CULLFACE_FRONT,
	CULLFACE_FRONTANDBACK: CULLFACE_FRONTANDBACK,
	ELEMENTTYPE_INT8: TYPE_INT8,
	ELEMENTTYPE_UINT8: TYPE_UINT8,
	ELEMENTTYPE_INT16: TYPE_INT16,
	ELEMENTTYPE_UINT16: TYPE_UINT16,
	ELEMENTTYPE_INT32: TYPE_INT32,
	ELEMENTTYPE_UINT32: TYPE_UINT32,
	ELEMENTTYPE_FLOAT32: TYPE_FLOAT32,
	FILTER_NEAREST: FILTER_NEAREST,
	FILTER_LINEAR: FILTER_LINEAR,
	FILTER_NEAREST_MIPMAP_NEAREST: FILTER_NEAREST_MIPMAP_NEAREST,
	FILTER_NEAREST_MIPMAP_LINEAR: FILTER_NEAREST_MIPMAP_LINEAR,
	FILTER_LINEAR_MIPMAP_NEAREST: FILTER_LINEAR_MIPMAP_NEAREST,
	FILTER_LINEAR_MIPMAP_LINEAR: FILTER_LINEAR_MIPMAP_LINEAR,
	INDEXFORMAT_UINT8: INDEXFORMAT_UINT8,
	INDEXFORMAT_UINT16: INDEXFORMAT_UINT16,
	INDEXFORMAT_UINT32: INDEXFORMAT_UINT32,
	PIXELFORMAT_R5_G6_B5: PIXELFORMAT_R5_G6_B5,
	PIXELFORMAT_R8_G8_B8: PIXELFORMAT_R8_G8_B8,
	PIXELFORMAT_R8_G8_B8_A8: PIXELFORMAT_R8_G8_B8_A8,
	PRIMITIVE_POINTS: PRIMITIVE_POINTS,
	PRIMITIVE_LINES: PRIMITIVE_LINES,
	PRIMITIVE_LINELOOP: PRIMITIVE_LINELOOP,
	PRIMITIVE_LINESTRIP: PRIMITIVE_LINESTRIP,
	PRIMITIVE_TRIANGLES: PRIMITIVE_TRIANGLES,
	PRIMITIVE_TRISTRIP: PRIMITIVE_TRISTRIP,
	PRIMITIVE_TRIFAN: PRIMITIVE_TRIFAN,
	SEMANTIC_POSITION: SEMANTIC_POSITION,
	SEMANTIC_NORMAL: SEMANTIC_NORMAL,
	SEMANTIC_COLOR: SEMANTIC_COLOR,
	SEMANTIC_TEXCOORD: SEMANTIC_TEXCOORD,
	SEMANTIC_TEXCOORD0: SEMANTIC_TEXCOORD0,
	SEMANTIC_TEXCOORD1: SEMANTIC_TEXCOORD1,
	SEMANTIC_ATTR0: SEMANTIC_ATTR0,
	SEMANTIC_ATTR1: SEMANTIC_ATTR1,
	SEMANTIC_ATTR2: SEMANTIC_ATTR2,
	SEMANTIC_ATTR3: SEMANTIC_ATTR3,
	TEXTURELOCK_READ: TEXTURELOCK_READ,
	TEXTURELOCK_WRITE: TEXTURELOCK_WRITE,
	drawQuadWithShader: drawQuadWithShader,
	programlib: programlib,
	shaderChunks: shaderChunks,
	ContextCreationError: ContextCreationError,
	Device: GraphicsDevice,
	IndexBuffer: IndexBuffer,
	ProgramLibrary: ProgramLibrary,
	RenderTarget: RenderTarget,
	ScopeId: ScopeId,
	Shader: Shader,
	ShaderInput: ShaderInput,
	Texture: Texture,
	UnsupportedBrowserError: UnsupportedBrowserError,
	VertexBuffer: VertexBuffer,
	VertexFormat: VertexFormat,
	VertexIterator: VertexIterator
};
const posteffect = {
	createFullscreenQuad: createFullscreenQuad,
	drawFullscreenQuad: drawFullscreenQuad,
	PostEffect: PostEffect$1,
	PostEffectQueue: PostEffectQueue
};
Object.defineProperty(shaderChunks, "transformSkinnedVS", {
	get: function () {
		return "#define SKIN\n" + shaderChunks.transformVS;
	}
});
const deprecatedChunks = {
	'ambientPrefilteredCube.frag': 'ambientEnv.frag',
	'ambientPrefilteredCubeLod.frag': 'ambientEnv.frag',
	'dpAtlasQuad.frag': null,
	'genParaboloid.frag': null,
	'prefilterCubemap.frag': null,
	'reflectionDpAtlas.frag': 'reflectionEnv.frag',
	'reflectionPrefilteredCube.frag': 'reflectionEnv.frag',
	'reflectionPrefilteredCubeLod.frag': 'reflectionEnv.frag'
};
Object.keys(deprecatedChunks).forEach(chunkName => {
	deprecatedChunks[chunkName];
	Object.defineProperty(shaderChunks, chunkName, {
		get: function () {
			return null;
		},
		set: function () {}
	});
});

VertexFormat.prototype.update = function () {};

Object.defineProperties(Texture.prototype, {
	rgbm: {
		get: function () {
			return this.type === TEXTURETYPE_RGBM;
		},
		set: function (rgbm) {
			this.type = rgbm ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT;
		}
	},
	swizzleGGGR: {
		get: function () {
			return this.type === TEXTURETYPE_SWIZZLEGGGR;
		},
		set: function (swizzleGGGR) {
			this.type = swizzleGGGR ? TEXTURETYPE_SWIZZLEGGGR : TEXTURETYPE_DEFAULT;
		}
	}
});
const PhongMaterial = StandardMaterial;
const scene = {
	partitionSkin: partitionSkin,
	procedural: {
		calculateTangents: calculateTangents,
		createMesh: createMesh$1,
		createTorus: createTorus,
		createCylinder: createCylinder,
		createCapsule: createCapsule,
		createCone: createCone,
		createSphere: createSphere,
		createPlane: createPlane,
		createBox: createBox
	},
	BasicMaterial: BasicMaterial,
	Command: Command,
	ForwardRenderer: ForwardRenderer,
	GraphNode: GraphNode,
	Material: Material,
	Mesh: Mesh,
	MeshInstance: MeshInstance,
	Model: Model,
	ParticleEmitter: ParticleEmitter,
	PhongMaterial: StandardMaterial,
	Picker: Picker,
	Projection: {
		ORTHOGRAPHIC: PROJECTION_ORTHOGRAPHIC,
		PERSPECTIVE: PROJECTION_PERSPECTIVE
	},
	Scene: Scene,
	Skin: Skin,
	SkinInstance: SkinInstance
};
Object.defineProperty(Scene.prototype, 'defaultMaterial', {
	get: function () {
		return getDefaultMaterial(getApplication().graphicsDevice);
	}
});
['128', '64', '32', '16', '8', '4'].forEach((size, index) => {
	Object.defineProperty(Scene.prototype, `skyboxPrefiltered${size}`, {
		get: function () {
			return this._prefilteredCubemaps[index];
		},
		set: function (value) {
			this._prefilteredCubemaps[index] = value;
			this.updateShaders = true;
		}
	});
});
Object.defineProperty(Batch.prototype, 'model', {
	get: function () {
		return null;
	}
});

MeshInstance.prototype.syncAabb = function () {};

Morph.prototype.getTarget = function (index) {
	return this.targets[index];
};

GraphNode.prototype._dirtify = function (local) {
	if (local) this._dirtifyLocal();else this._dirtifyWorld();
};

GraphNode.prototype.addLabel = function (label) {
	this._labels[label] = true;
};

GraphNode.prototype.getLabels = function () {
	return Object.keys(this._labels);
};

GraphNode.prototype.hasLabel = function (label) {
	return !!this._labels[label];
};

GraphNode.prototype.removeLabel = function (label) {
	delete this._labels[label];
};

GraphNode.prototype.findByLabel = function (label, results = []) {
	if (this.hasLabel(label)) {
		results.push(this);
	}

	for (let i = 0; i < this._children.length; ++i) {
		results = this._children[i].findByLabel(label, results);
	}

	return results;
};

GraphNode.prototype.getChildren = function () {
	return this.children;
};

GraphNode.prototype.getName = function () {
	return this.name;
};

GraphNode.prototype.getPath = function () {
	return this.path;
};

GraphNode.prototype.getRoot = function () {
	return this.root;
};

GraphNode.prototype.getParent = function () {
	return this.parent;
};

GraphNode.prototype.setName = function (name) {
	this.name = name;
};

Material.prototype.getName = function () {
	return this.name;
};

Material.prototype.setName = function (name) {
	this.name = name;
};

Material.prototype.getShader = function () {
	return this.shader;
};

Material.prototype.setShader = function (shader) {
	this.shader = shader;
};

function _defineAlias(newName, oldName) {
	Object.defineProperty(StandardMaterial.prototype, oldName, {
		get: function () {
			return this[newName];
		},
		set: function (value) {
			this[newName] = value;
		}
	});
}

_defineAlias("diffuseTint", "diffuseMapTint");

_defineAlias("specularTint", "specularMapTint");

_defineAlias("emissiveTint", "emissiveMapTint");

_defineAlias("aoVertexColor", "aoMapVertexColor");

_defineAlias("diffuseVertexColor", "diffuseMapVertexColor");

_defineAlias("specularVertexColor", "specularMapVertexColor");

_defineAlias("emissiveVertexColor", "emissiveMapVertexColor");

_defineAlias("metalnessVertexColor", "metalnessMapVertexColor");

_defineAlias("glossVertexColor", "glossMapVertexColor");

_defineAlias("opacityVertexColor", "opacityMapVertexColor");

_defineAlias("lightVertexColor", "lightMapVertexColor");

const anim = {
	Animation: Animation,
	Key: Key,
	Node: Node,
	Skeleton: Skeleton
};

Animation.prototype.getDuration = function () {
	return this.duration;
};

Animation.prototype.getName = function () {
	return this.name;
};

Animation.prototype.getNodes = function () {
	return this.nodes;
};

Animation.prototype.setDuration = function (duration) {
	this.duration = duration;
};

Animation.prototype.setName = function (name) {
	this.name = name;
};

Skeleton.prototype.getAnimation = function () {
	return this.animation;
};

Skeleton.prototype.getCurrentTime = function () {
	return this.currentTime;
};

Skeleton.prototype.getLooping = function () {
	return this.looping;
};

Skeleton.prototype.getNumNodes = function () {
	return this.numNodes;
};

Skeleton.prototype.setAnimation = function (animation) {
	this.animation = animation;
};

Skeleton.prototype.setCurrentTime = function (time) {
	this.currentTime = time;
};

Skeleton.prototype.setLooping = function (looping) {
	this.looping = looping;
};

const audio = {
	AudioManager: SoundManager,
	Channel: Channel,
	Channel3d: Channel3d,
	Listener: Listener,
	Sound: Sound
};

SoundManager.prototype.getListener = function () {
	return this.listener;
};

SoundManager.prototype.getVolume = function () {
	return this.volume;
};

SoundManager.prototype.setVolume = function (volume) {
	this.volume = volume;
};

const asset = {
	ASSET_ANIMATION: 'animation',
	ASSET_AUDIO: 'audio',
	ASSET_IMAGE: 'image',
	ASSET_JSON: 'json',
	ASSET_MODEL: 'model',
	ASSET_MATERIAL: 'material',
	ASSET_TEXT: 'text',
	ASSET_TEXTURE: 'texture',
	ASSET_CUBEMAP: 'cubemap',
	ASSET_SCRIPT: 'script'
};

AssetRegistry.prototype.getAssetById = function (id) {
	return this.get(id);
};

Object.defineProperty(XrInputSource.prototype, 'ray', {
	get: function () {
		return this._rayLocal;
	}
});
Object.defineProperty(XrInputSource.prototype, 'position', {
	get: function () {
		return this._localPosition;
	}
});
Object.defineProperty(XrInputSource.prototype, 'rotation', {
	get: function () {
		return this._localRotation;
	}
});
const input = {
	getTouchTargetCoords: getTouchTargetCoords,
	Controller: Controller,
	GamePads: GamePads,
	Keyboard: Keyboard,
	KeyboardEvent: KeyboardEvent,
	Mouse: Mouse,
	MouseEvent: MouseEvent,
	Touch: Touch,
	TouchDevice: TouchDevice,
	TouchEvent: TouchEvent
};
Object.defineProperty(ElementInput.prototype, 'wheel', {
	get: function () {
		return this.wheelDelta * -2;
	}
});
Object.defineProperty(MouseEvent.prototype, 'wheel', {
	get: function () {
		return this.wheelDelta * -2;
	}
});
const RIGIDBODY_TYPE_STATIC = BODYTYPE_STATIC;
const RIGIDBODY_TYPE_DYNAMIC = BODYTYPE_DYNAMIC;
const RIGIDBODY_TYPE_KINEMATIC = BODYTYPE_KINEMATIC;
const RIGIDBODY_CF_STATIC_OBJECT = BODYFLAG_STATIC_OBJECT;
const RIGIDBODY_CF_KINEMATIC_OBJECT = BODYFLAG_KINEMATIC_OBJECT;
const RIGIDBODY_CF_NORESPONSE_OBJECT = BODYFLAG_NORESPONSE_OBJECT;
const RIGIDBODY_ACTIVE_TAG = BODYSTATE_ACTIVE_TAG;
const RIGIDBODY_ISLAND_SLEEPING = BODYSTATE_ISLAND_SLEEPING;
const RIGIDBODY_WANTS_DEACTIVATION = BODYSTATE_WANTS_DEACTIVATION;
const RIGIDBODY_DISABLE_DEACTIVATION = BODYSTATE_DISABLE_DEACTIVATION;
const RIGIDBODY_DISABLE_SIMULATION = BODYSTATE_DISABLE_SIMULATION;
const fw = {
	Application: Application,
	Component: Component,
	ComponentSystem: ComponentSystem,
	Entity: Entity,
	FillMode: {
		NONE: FILLMODE_NONE,
		FILL_WINDOW: FILLMODE_FILL_WINDOW,
		KEEP_ASPECT: FILLMODE_KEEP_ASPECT
	},
	ResolutionMode: {
		AUTO: RESOLUTION_AUTO,
		FIXED: RESOLUTION_FIXED
	}
};

Application.prototype.isFullscreen = function () {
	return !!document.fullscreenElement;
};

Application.prototype.enableFullscreen = function (element, success, error) {
	element = element || this.graphicsDevice.canvas;

	const s = function s() {
		success();
		document.removeEventListener('fullscreenchange', s);
	};

	const e = function e() {
		error();
		document.removeEventListener('fullscreenerror', e);
	};

	if (success) {
		document.addEventListener('fullscreenchange', s, false);
	}

	if (error) {
		document.addEventListener('fullscreenerror', e, false);
	}

	if (element.requestFullscreen) {
		element.requestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
	} else {
		error();
	}
};

Application.prototype.disableFullscreen = function (success) {
	const s = function s() {
		success();
		document.removeEventListener('fullscreenchange', s);
	};

	if (success) {
		document.addEventListener('fullscreenchange', s, false);
	}

	document.exitFullscreen();
};

Application.prototype.getSceneUrl = function (name) {
	const entry = this.scenes.find(name);

	if (entry) {
		return entry.url;
	}

	return null;
};

Application.prototype.loadScene = function (url, callback) {
	this.scenes.loadScene(url, callback);
};

Application.prototype.loadSceneHierarchy = function (url, callback) {
	this.scenes.loadSceneHierarchy(url, callback);
};

Application.prototype.loadSceneSettings = function (url, callback) {
	this.scenes.loadSceneSettings(url, callback);
};

Application.prototype.renderMeshInstance = function (meshInstance, options) {
	const layer = options != null && options.layer ? options.layer : this.scene.defaultDrawLayer;
	this.scene.immediate.drawMesh(null, null, null, meshInstance, layer);
};

Application.prototype.renderMesh = function (mesh, material, matrix, options) {
	const layer = options != null && options.layer ? options.layer : this.scene.defaultDrawLayer;
	this.scene.immediate.drawMesh(material, matrix, mesh, null, layer);
};

Application.prototype._addLines = function (positions, colors, options) {
	const layer = options && options.layer ? options.layer : this.scene.layers.getLayerById(LAYERID_IMMEDIATE);
	const depthTest = options && options.depthTest !== undefined ? options.depthTest : true;
	const batch = this.scene.immediate.getBatch(layer, depthTest);
	batch.addLines(positions, colors);
};

Application.prototype.renderLine = function (start, end, color) {
	let endColor = color;
	let options;
	const arg3 = arguments[3];
	const arg4 = arguments[4];

	if (arg3 instanceof Color) {
		endColor = arg3;

		if (typeof arg4 === 'number') {
			if (arg4 === LINEBATCH_OVERLAY) {
				options = {
					layer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),
					depthTest: false
				};
			} else {
				options = {
					layer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),
					depthTest: true
				};
			}
		} else {
			options = arg4;
		}
	} else if (typeof arg3 === 'number') {
		endColor = color;

		if (arg3 === LINEBATCH_OVERLAY) {
			options = {
				layer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),
				depthTest: false
			};
		} else {
			options = {
				layer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),
				depthTest: true
			};
		}
	} else if (arg3) {
		options = arg3;
	}

	this._addLines([start, end], [color, endColor], options);
};

Application.prototype.renderLines = function (position, color, options) {
	if (!options) {
		options = {
			layer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),
			depthTest: true
		};
	} else if (typeof options === 'number') {
		if (options === LINEBATCH_OVERLAY) {
			options = {
				layer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),
				depthTest: false
			};
		} else {
			options = {
				layer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),
				depthTest: true
			};
		}
	}

	const multiColor = !!color.length;

	if (multiColor) {
		if (position.length !== color.length) {
			console.error("renderLines: position/color arrays have different lengths");
			return;
		}
	}

	if (position.length % 2 !== 0) {
		console.error("renderLines: array length is not divisible by 2");
		return;
	}

	this._addLines(position, color, options);
};

Object.defineProperty(CameraComponent.prototype, "node", {
	get: function () {
		return this.entity;
	}
});
Object.defineProperty(LightComponent.prototype, "enable", {
	get: function () {
		return this.enabled;
	},
	set: function (value) {
		this.enabled = value;
	}
});

ModelComponent.prototype.setVisible = function (visible) {
	this.enabled = visible;
};

Object.defineProperty(ModelComponent.prototype, "aabb", {
	get: function () {
		return null;
	},
	set: function (type) {}
});
Object.defineProperty(RenderComponent.prototype, "aabb", {
	get: function () {
		return null;
	},
	set: function (type) {}
});
Object.defineProperty(RigidBodyComponent.prototype, "bodyType", {
	get: function () {
		return this.type;
	},
	set: function (type) {
		this.type = type;
	}
});

RigidBodyComponent.prototype.syncBodyToEntity = function () {
	this._updateDynamic();
};

RigidBodyComponentSystem.prototype.setGravity = function () {
	if (arguments.length === 1) {
		this.gravity.copy(arguments[0]);
	} else {
		this.gravity.set(arguments[0], arguments[1], arguments[2]);
	}
};

function basisSetDownloadConfig(glueUrl, wasmUrl, fallbackUrl) {
	basisInitialize({
		glueUrl: glueUrl,
		wasmUrl: wasmUrl,
		fallbackUrl: fallbackUrl,
		lazyInit: true
	});
}
function prefilterCubemap(options) {}
class AssetListLoader extends EventHandler {
	constructor(assetList, assetRegistry) {
		super();
		this._assets = [];
		this._registry = assetRegistry;
		this._loaded = false;
		this._count = 0;
		this._total = 0;
		this._failed = [];
		this._waitingAssets = [];

		if (assetList.length && assetList[0] instanceof Asset) {
			this._assets = assetList;
		} else {
			for (let i = 0; i < assetList.length; i++) {
				const asset = assetRegistry.get(assetList[i]);

				if (asset) {
					this._assets.push(asset);
				} else {
					this._waitForAsset(assetList[i]);

					this._total++;
				}
			}
		}
	}

	destroy() {
		this._registry.off("load", this._onLoad);

		this._registry.off("error", this._onError);

		this._waitingAssets.forEach(id => {
			this._registry.off("add:" + id, this._onAddAsset);
		});

		this.off("progress");
		this.off("load");
	}

	load(done, scope) {
		this._count = 0;
		this._failed = [];
		this._callback = done;
		this._scope = scope;

		this._registry.on("load", this._onLoad, this);

		this._registry.on("error", this._onError, this);

		for (let i = 0, l = this._assets.length; i < l; i++) {
			const asset = this._assets[i];

			if (!asset.loading && !asset.loaded) {
				this._registry.load(asset);

				this._total++;
			}
		}
	}

	ready(done, scope) {
		scope = scope || this;

		if (this._loaded) {
			done.call(scope, this._assets);
		} else {
			this.once("load", function (assets) {
				done.call(scope, assets);
			});
		}
	}

	_loadingComplete() {
		this._loaded = true;

		this._registry.off("load", this._onLoad, this);

		this._registry.off("error", this._onError, this);

		if (this._failed && this._failed.length) {
			if (this._callback) {
				this._callback.call(this._scope, "Failed to load some assets", this._failed);
			}

			this.fire("error", this._failed);
		} else {
			if (this._callback) {
				this._callback.call(this._scope);
			}

			this.fire("load", this._assets);
		}
	}

	_onLoad(asset) {
		if (this._assets.indexOf(asset) >= 0) {
			this._count++;
			this.fire("progress", asset);
		}

		if (this._count === this._total) {
			setTimeout(() => {
				this._loadingComplete(this._failed);
			}, 0);
		}
	}

	_onError(err, asset) {
		if (this._assets.indexOf(asset) >= 0) {
			this._count++;

			this._failed.push(asset);
		}

		if (this._count === this._total) {
			setTimeout(() => {
				this._loadingComplete(this._failed);
			}, 0);
		}
	}

	_onAddAsset(asset) {
		const index = this._waitingAssets.indexOf(asset);

		if (index >= 0) {
			this._waitingAssets.splice(index, 1);
		}

		this._assets.push(asset);

		for (let i = 0, l = this._assets.length; i < l; i++) {
			asset = this._assets[i];

			if (!asset.loading && !asset.loaded) {
				this._registry.load(asset);
			}
		}
	}

	_waitForAsset(assetId) {
		this._waitingAssets.push(assetId);

		this._registry.once('add:' + assetId, this._onAddAsset, this);
	}

}

export { ABSOLUTE_URL, ACTION_GAMEPAD, ACTION_KEYBOARD, ACTION_MOUSE, ADDRESS_CLAMP_TO_EDGE, ADDRESS_MIRRORED_REPEAT, ADDRESS_REPEAT, ANIM_BLEND_1D, ANIM_BLEND_2D_CARTESIAN, ANIM_BLEND_2D_DIRECTIONAL, ANIM_BLEND_DIRECT, ANIM_CONTROL_STATES, ANIM_EQUAL_TO, ANIM_GREATER_THAN, ANIM_GREATER_THAN_EQUAL_TO, ANIM_INTERRUPTION_NEXT, ANIM_INTERRUPTION_NEXT_PREV, ANIM_INTERRUPTION_NONE, ANIM_INTERRUPTION_PREV, ANIM_INTERRUPTION_PREV_NEXT, ANIM_LAYER_ADDITIVE, ANIM_LAYER_OVERWRITE, ANIM_LESS_THAN, ANIM_LESS_THAN_EQUAL_TO, ANIM_NOT_EQUAL_TO, ANIM_PARAMETER_BOOLEAN, ANIM_PARAMETER_FLOAT, ANIM_PARAMETER_INTEGER, ANIM_PARAMETER_TRIGGER, ANIM_STATE_ANY, ANIM_STATE_END, ANIM_STATE_START, ASPECT_AUTO, ASPECT_MANUAL, ASSET_ANIMATION, ASSET_AUDIO, ASSET_CONTAINER, ASSET_CSS, ASSET_CUBEMAP, ASSET_HTML, ASSET_IMAGE, ASSET_JSON, ASSET_MATERIAL, ASSET_MODEL, ASSET_SCRIPT, ASSET_SHADER, ASSET_TEXT, ASSET_TEXTURE, AXIS_KEY, AXIS_MOUSE_X, AXIS_MOUSE_Y, AXIS_PAD_L_X, AXIS_PAD_L_Y, AXIS_PAD_R_X, AXIS_PAD_R_Y, AnimBinder, AnimClip, AnimClipHandler, AnimComponent, AnimComponentLayer, AnimComponentSystem, AnimController, AnimCurve, AnimData, AnimEvaluator, AnimEvents, AnimSnapshot, AnimStateGraph, AnimStateGraphHandler, AnimTarget, AnimTrack, Animation, AnimationComponent, AnimationComponentSystem, AnimationHandler, Application, Asset, AssetListLoader, AssetReference, AssetRegistry, AudioHandler, AudioListenerComponent, AudioListenerComponentSystem, AudioSourceComponent, AudioSourceComponentSystem, BAKE_COLOR, BAKE_COLORDIR, BLENDEQUATION_ADD, BLENDEQUATION_MAX, BLENDEQUATION_MIN, BLENDEQUATION_REVERSE_SUBTRACT, BLENDEQUATION_SUBTRACT, BLENDMODE_DST_ALPHA, BLENDMODE_DST_COLOR, BLENDMODE_ONE, BLENDMODE_ONE_MINUS_DST_ALPHA, BLENDMODE_ONE_MINUS_DST_COLOR, BLENDMODE_ONE_MINUS_SRC_ALPHA, BLENDMODE_ONE_MINUS_SRC_COLOR, BLENDMODE_SRC_ALPHA, BLENDMODE_SRC_ALPHA_SATURATE, BLENDMODE_SRC_COLOR, BLENDMODE_ZERO, BLEND_ADDITIVE, BLEND_ADDITIVEALPHA, BLEND_MAX, BLEND_MIN, BLEND_MULTIPLICATIVE, BLEND_MULTIPLICATIVE2X, BLEND_NONE, BLEND_NORMAL, BLEND_PREMULTIPLIED, BLEND_SCREEN, BLEND_SUBTRACTIVE, BLUR_BOX, BLUR_GAUSSIAN, BODYFLAG_KINEMATIC_OBJECT, BODYFLAG_NORESPONSE_OBJECT, BODYFLAG_STATIC_OBJECT, BODYGROUP_DEFAULT, BODYGROUP_DYNAMIC, BODYGROUP_ENGINE_1, BODYGROUP_ENGINE_2, BODYGROUP_ENGINE_3, BODYGROUP_KINEMATIC, BODYGROUP_NONE, BODYGROUP_STATIC, BODYGROUP_TRIGGER, BODYGROUP_USER_1, BODYGROUP_USER_2, BODYGROUP_USER_3, BODYGROUP_USER_4, BODYGROUP_USER_5, BODYGROUP_USER_6, BODYGROUP_USER_7, BODYGROUP_USER_8, BODYMASK_ALL, BODYMASK_NONE, BODYMASK_NOT_STATIC, BODYMASK_NOT_STATIC_KINEMATIC, BODYMASK_STATIC, BODYSTATE_ACTIVE_TAG, BODYSTATE_DISABLE_DEACTIVATION, BODYSTATE_DISABLE_SIMULATION, BODYSTATE_ISLAND_SLEEPING, BODYSTATE_WANTS_DEACTIVATION, BODYTYPE_DYNAMIC, BODYTYPE_KINEMATIC, BODYTYPE_STATIC, BUFFER_DYNAMIC, BUFFER_GPUDYNAMIC, BUFFER_STATIC, BUFFER_STREAM, BUTTON_TRANSITION_MODE_SPRITE_CHANGE, BUTTON_TRANSITION_MODE_TINT, BasicMaterial, Batch, BatchGroup, BatchManager, BinaryHandler, BoundingBox, BoundingSphere, Bundle, BundleHandler, BundleRegistry, ButtonComponent, ButtonComponentSystem, CLEARFLAG_COLOR, CLEARFLAG_DEPTH, CLEARFLAG_STENCIL, COMPUPDATED_BLEND, COMPUPDATED_CAMERAS, COMPUPDATED_INSTANCES, COMPUPDATED_LIGHTS, CUBEFACE_NEGX, CUBEFACE_NEGY, CUBEFACE_NEGZ, CUBEFACE_POSX, CUBEFACE_POSY, CUBEFACE_POSZ, CUBEPROJ_BOX, CUBEPROJ_NONE, CULLFACE_BACK, CULLFACE_FRONT, CULLFACE_FRONTANDBACK, CULLFACE_NONE, CURVE_CARDINAL, CURVE_CATMULL, CURVE_LINEAR, CURVE_SMOOTHSTEP, CURVE_SPLINE, CURVE_STEP, Camera, CameraComponent, CameraComponentSystem, CanvasFont, CollisionComponent, CollisionComponentSystem, Color, Command, Component, ComponentSystem, ComponentSystemRegistry, ContactPoint, ContactResult, ContainerHandler, ContainerResource, ContextCreationError, Controller, CssHandler, CubemapHandler, Curve, CurveSet, DETAILMODE_ADD, DETAILMODE_MAX, DETAILMODE_MIN, DETAILMODE_MUL, DETAILMODE_OVERLAY, DETAILMODE_SCREEN, DISTANCE_EXPONENTIAL, DISTANCE_INVERSE, DISTANCE_LINEAR, DefaultAnimBinder, ELEMENTTYPE_FLOAT32, ELEMENTTYPE_GROUP, ELEMENTTYPE_IMAGE, ELEMENTTYPE_INT16, ELEMENTTYPE_INT32, ELEMENTTYPE_INT8, ELEMENTTYPE_TEXT, ELEMENTTYPE_UINT16, ELEMENTTYPE_UINT32, ELEMENTTYPE_UINT8, EMITTERSHAPE_BOX, EMITTERSHAPE_SPHERE, EVENT_KEYDOWN, EVENT_KEYUP, EVENT_MOUSEDOWN, EVENT_MOUSEMOVE, EVENT_MOUSEUP, EVENT_MOUSEWHEEL, EVENT_SELECT, EVENT_SELECTEND, EVENT_SELECTSTART, EVENT_TOUCHCANCEL, EVENT_TOUCHEND, EVENT_TOUCHMOVE, EVENT_TOUCHSTART, ElementComponent, ElementComponentSystem, ElementDragHelper, ElementInput, ElementInputEvent, ElementMouseEvent, ElementSelectEvent, ElementTouchEvent, Entity, EntityReference, EnvLighting, EventHandler, FILLMODE_FILL_WINDOW, FILLMODE_KEEP_ASPECT, FILLMODE_NONE, FILTER_LINEAR, FILTER_LINEAR_MIPMAP_LINEAR, FILTER_LINEAR_MIPMAP_NEAREST, FILTER_NEAREST, FILTER_NEAREST_MIPMAP_LINEAR, FILTER_NEAREST_MIPMAP_NEAREST, FITTING_BOTH, FITTING_NONE, FITTING_SHRINK, FITTING_STRETCH, FOG_EXP, FOG_EXP2, FOG_LINEAR, FOG_NONE, FONT_BITMAP, FONT_MSDF, FRESNEL_NONE, FRESNEL_SCHLICK, FUNC_ALWAYS, FUNC_EQUAL, FUNC_GREATER, FUNC_GREATEREQUAL, FUNC_LESS, FUNC_LESSEQUAL, FUNC_NEVER, FUNC_NOTEQUAL, FolderHandler, Font, FontHandler, ForwardRenderer, Frustum, GAMMA_NONE, GAMMA_SRGB, GAMMA_SRGBFAST, GAMMA_SRGBHDR, GamePads, GraphNode, GraphicsDevice, HierarchyHandler, HtmlHandler, Http, I18n, INDEXFORMAT_UINT16, INDEXFORMAT_UINT32, INDEXFORMAT_UINT8, INTERPOLATION_CUBIC, INTERPOLATION_LINEAR, INTERPOLATION_STEP, ImageElement, IndexBuffer, IndexedList, JointComponent, JointComponentSystem, JsonHandler, JsonStandardMaterialParser, KEY_0, KEY_1, KEY_2, KEY_3, KEY_4, KEY_5, KEY_6, KEY_7, KEY_8, KEY_9, KEY_A, KEY_ADD, KEY_ALT, KEY_B, KEY_BACKSPACE, KEY_BACK_SLASH, KEY_C, KEY_CAPS_LOCK, KEY_CLOSE_BRACKET, KEY_COMMA, KEY_CONTEXT_MENU, KEY_CONTROL, KEY_D, KEY_DECIMAL, KEY_DELETE, KEY_DIVIDE, KEY_DOWN, KEY_E, KEY_END, KEY_ENTER, KEY_EQUAL, KEY_ESCAPE, KEY_F, KEY_F1, KEY_F10, KEY_F11, KEY_F12, KEY_F2, KEY_F3, KEY_F4, KEY_F5, KEY_F6, KEY_F7, KEY_F8, KEY_F9, KEY_G, KEY_H, KEY_HOME, KEY_I, KEY_INSERT, KEY_J, KEY_K, KEY_L, KEY_LEFT, KEY_M, KEY_META, KEY_MULTIPLY, KEY_N, KEY_NUMPAD_0, KEY_NUMPAD_1, KEY_NUMPAD_2, KEY_NUMPAD_3, KEY_NUMPAD_4, KEY_NUMPAD_5, KEY_NUMPAD_6, KEY_NUMPAD_7, KEY_NUMPAD_8, KEY_NUMPAD_9, KEY_O, KEY_OPEN_BRACKET, KEY_P, KEY_PAGE_DOWN, KEY_PAGE_UP, KEY_PAUSE, KEY_PERIOD, KEY_PRINT_SCREEN, KEY_Q, KEY_R, KEY_RETURN, KEY_RIGHT, KEY_S, KEY_SEMICOLON, KEY_SEPARATOR, KEY_SHIFT, KEY_SLASH, KEY_SPACE, KEY_SUBTRACT, KEY_T, KEY_TAB, KEY_U, KEY_UP, KEY_V, KEY_W, KEY_WINDOWS, KEY_X, KEY_Y, KEY_Z, Key, Keyboard, KeyboardEvent, LAYERID_DEPTH, LAYERID_IMMEDIATE, LAYERID_SKYBOX, LAYERID_UI, LAYERID_WORLD, LAYER_FX, LAYER_GIZMO, LAYER_HUD, LAYER_WORLD, LIGHTFALLOFF_INVERSESQUARED, LIGHTFALLOFF_LINEAR, LIGHTSHAPE_DISK, LIGHTSHAPE_PUNCTUAL, LIGHTSHAPE_RECT, LIGHTSHAPE_SPHERE, LIGHTTYPE_DIRECTIONAL, LIGHTTYPE_OMNI, LIGHTTYPE_POINT, LIGHTTYPE_SPOT, LINEBATCH_GIZMO, LINEBATCH_OVERLAY, LINEBATCH_WORLD, Layer, LayerComposition, LayoutCalculator, LayoutChildComponent, LayoutChildComponentSystem, LayoutGroupComponent, LayoutGroupComponentSystem, Light, LightComponent, LightComponentSystem, LightingParams, Lightmapper, LocalizedAsset, MASK_AFFECT_DYNAMIC, MASK_AFFECT_LIGHTMAPPED, MASK_BAKE, MOTION_FREE, MOTION_LIMITED, MOTION_LOCKED, MOUSEBUTTON_LEFT, MOUSEBUTTON_MIDDLE, MOUSEBUTTON_NONE, MOUSEBUTTON_RIGHT, Mat3, Mat4, Material, MaterialHandler, Mesh, MeshInstance, Model, ModelComponent, ModelComponentSystem, ModelHandler, Morph, MorphInstance, MorphTarget, Mouse, MouseEvent, Node, ORIENTATION_HORIZONTAL, ORIENTATION_VERTICAL, OrientedBox, PAD_1, PAD_2, PAD_3, PAD_4, PAD_DOWN, PAD_FACE_1, PAD_FACE_2, PAD_FACE_3, PAD_FACE_4, PAD_LEFT, PAD_L_SHOULDER_1, PAD_L_SHOULDER_2, PAD_L_STICK_BUTTON, PAD_L_STICK_X, PAD_L_STICK_Y, PAD_RIGHT, PAD_R_SHOULDER_1, PAD_R_SHOULDER_2, PAD_R_STICK_BUTTON, PAD_R_STICK_X, PAD_R_STICK_Y, PAD_SELECT, PAD_START, PAD_UP, PAD_VENDOR, PARTICLEMODE_CPU, PARTICLEMODE_GPU, PARTICLEORIENTATION_EMITTER, PARTICLEORIENTATION_SCREEN, PARTICLEORIENTATION_WORLD, PARTICLESORT_DISTANCE, PARTICLESORT_NEWER_FIRST, PARTICLESORT_NONE, PARTICLESORT_OLDER_FIRST, PIXELFORMAT_111110F, PIXELFORMAT_A8, PIXELFORMAT_ASTC_4x4, PIXELFORMAT_ATC_RGB, PIXELFORMAT_ATC_RGBA, PIXELFORMAT_DEPTH, PIXELFORMAT_DEPTHSTENCIL, PIXELFORMAT_DXT1, PIXELFORMAT_DXT3, PIXELFORMAT_DXT5, PIXELFORMAT_ETC1, PIXELFORMAT_ETC2_RGB, PIXELFORMAT_ETC2_RGBA, PIXELFORMAT_L8, PIXELFORMAT_L8_A8, PIXELFORMAT_PVRTC_2BPP_RGBA_1, PIXELFORMAT_PVRTC_2BPP_RGB_1, PIXELFORMAT_PVRTC_4BPP_RGBA_1, PIXELFORMAT_PVRTC_4BPP_RGB_1, PIXELFORMAT_R32F, PIXELFORMAT_R4_G4_B4_A4, PIXELFORMAT_R5_G5_B5_A1, PIXELFORMAT_R5_G6_B5, PIXELFORMAT_R8_G8_B8, PIXELFORMAT_R8_G8_B8_A8, PIXELFORMAT_RGB16F, PIXELFORMAT_RGB32F, PIXELFORMAT_RGBA16F, PIXELFORMAT_RGBA32F, PIXELFORMAT_SRGB, PIXELFORMAT_SRGBA, PRIMITIVE_LINELOOP, PRIMITIVE_LINES, PRIMITIVE_LINESTRIP, PRIMITIVE_POINTS, PRIMITIVE_TRIANGLES, PRIMITIVE_TRIFAN, PRIMITIVE_TRISTRIP, PROJECTION_ORTHOGRAPHIC, PROJECTION_PERSPECTIVE, ParticleEmitter, ParticleSystemComponent, ParticleSystemComponentSystem, PhongMaterial, Picker, Plane, PostEffect$1 as PostEffect, PostEffectQueue, ProgramLibrary, Quat, RENDERSTYLE_POINTS, RENDERSTYLE_SOLID, RENDERSTYLE_WIREFRAME, RESOLUTION_AUTO, RESOLUTION_FIXED, RIGIDBODY_ACTIVE_TAG, RIGIDBODY_CF_KINEMATIC_OBJECT, RIGIDBODY_CF_NORESPONSE_OBJECT, RIGIDBODY_CF_STATIC_OBJECT, RIGIDBODY_DISABLE_DEACTIVATION, RIGIDBODY_DISABLE_SIMULATION, RIGIDBODY_ISLAND_SLEEPING, RIGIDBODY_TYPE_DYNAMIC, RIGIDBODY_TYPE_KINEMATIC, RIGIDBODY_TYPE_STATIC, RIGIDBODY_WANTS_DEACTIVATION, Ray, RaycastResult, ReadStream, RenderComponent, RenderComponentSystem, RenderHandler, RenderTarget, ResourceHandler, ResourceLoader, RigidBodyComponent, RigidBodyComponentSystem, SCALEMODE_BLEND, SCALEMODE_NONE, SCROLLBAR_VISIBILITY_SHOW_ALWAYS, SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED, SCROLL_MODE_BOUNCE, SCROLL_MODE_CLAMP, SCROLL_MODE_INFINITE, SEMANTIC_ATTR, SEMANTIC_ATTR0, SEMANTIC_ATTR1, SEMANTIC_ATTR10, SEMANTIC_ATTR11, SEMANTIC_ATTR12, SEMANTIC_ATTR13, SEMANTIC_ATTR14, SEMANTIC_ATTR15, SEMANTIC_ATTR2, SEMANTIC_ATTR3, SEMANTIC_ATTR4, SEMANTIC_ATTR5, SEMANTIC_ATTR6, SEMANTIC_ATTR7, SEMANTIC_ATTR8, SEMANTIC_ATTR9, SEMANTIC_BLENDINDICES, SEMANTIC_BLENDWEIGHT, SEMANTIC_COLOR, SEMANTIC_NORMAL, SEMANTIC_POSITION, SEMANTIC_TANGENT, SEMANTIC_TEXCOORD, SEMANTIC_TEXCOORD0, SEMANTIC_TEXCOORD1, SEMANTIC_TEXCOORD2, SEMANTIC_TEXCOORD3, SEMANTIC_TEXCOORD4, SEMANTIC_TEXCOORD5, SEMANTIC_TEXCOORD6, SEMANTIC_TEXCOORD7, SHADERDEF_DIRLM, SHADERDEF_INSTANCING, SHADERDEF_LM, SHADERDEF_LMAMBIENT, SHADERDEF_MORPH_NORMAL, SHADERDEF_MORPH_POSITION, SHADERDEF_MORPH_TEXTURE_BASED, SHADERDEF_NOSHADOW, SHADERDEF_SCREENSPACE, SHADERDEF_SKIN, SHADERDEF_TANGENTS, SHADERDEF_UV0, SHADERDEF_UV1, SHADERDEF_VCOLOR, SHADERTAG_MATERIAL, SHADER_DEPTH, SHADER_FORWARD, SHADER_FORWARDHDR, SHADER_PICK, SHADER_SHADOW, SHADOWUPDATE_NONE, SHADOWUPDATE_REALTIME, SHADOWUPDATE_THISFRAME, SHADOW_COUNT, SHADOW_DEPTH, SHADOW_PCF1, SHADOW_PCF3, SHADOW_PCF5, SHADOW_VSM16, SHADOW_VSM32, SHADOW_VSM8, SORTKEY_DEPTH, SORTKEY_FORWARD, SORTMODE_BACK2FRONT, SORTMODE_CUSTOM, SORTMODE_FRONT2BACK, SORTMODE_MANUAL, SORTMODE_MATERIALMESH, SORTMODE_NONE, SPECOCC_AO, SPECOCC_GLOSSDEPENDENT, SPECOCC_NONE, SPECULAR_BLINN, SPECULAR_PHONG, SPRITETYPE_ANIMATED, SPRITETYPE_SIMPLE, SPRITE_RENDERMODE_SIMPLE, SPRITE_RENDERMODE_SLICED, SPRITE_RENDERMODE_TILED, STENCILOP_DECREMENT, STENCILOP_DECREMENTWRAP, STENCILOP_INCREMENT, STENCILOP_INCREMENTWRAP, STENCILOP_INVERT, STENCILOP_KEEP, STENCILOP_REPLACE, STENCILOP_ZERO, Scene, SceneHandler, SceneRegistry, SceneRegistryItem, SceneSettingsHandler, ScopeId, ScopeSpace, ScreenComponent, ScreenComponentSystem, ScriptAttributes, ScriptComponent, ScriptComponentSystem, ScriptHandler, ScriptLegacyComponent, ScriptLegacyComponentSystem, ScriptRegistry, ScriptType, ScrollViewComponent, ScrollViewComponentSystem, ScrollbarComponent, ScrollbarComponentSystem, Shader, ShaderHandler, SingleContactResult, Skeleton, Skin, SkinBatchInstance, SkinInstance, SortedLoopArray, Sound, SoundComponent, SoundComponentSystem, SoundInstance, SoundInstance3d, SoundManager, SoundSlot, Sprite, SpriteAnimationClip, SpriteComponent, SpriteComponentSystem, SpriteHandler, StandardMaterial, StencilParameters, TEXHINT_ASSET, TEXHINT_LIGHTMAP, TEXHINT_NONE, TEXHINT_SHADOWMAP, TEXTURELOCK_READ, TEXTURELOCK_WRITE, TEXTUREPROJECTION_CUBE, TEXTUREPROJECTION_EQUIRECT, TEXTUREPROJECTION_NONE, TEXTUREPROJECTION_OCTAHEDRAL, TEXTURETYPE_DEFAULT, TEXTURETYPE_RGBE, TEXTURETYPE_RGBM, TEXTURETYPE_SWIZZLEGGGR, TONEMAP_ACES, TONEMAP_ACES2, TONEMAP_FILMIC, TONEMAP_HEJL, TONEMAP_LINEAR, TYPE_FLOAT32, TYPE_INT16, TYPE_INT32, TYPE_INT8, TYPE_UINT16, TYPE_UINT32, TYPE_UINT8, Tags, Template, TemplateHandler, TextElement, TextHandler, Texture, TextureAtlas, TextureAtlasHandler, TextureHandler, TextureParser, Timer, Touch, TouchDevice, TouchEvent, TransformFeedback, UNIFORMTYPE_BOOL, UNIFORMTYPE_BVEC2, UNIFORMTYPE_BVEC3, UNIFORMTYPE_BVEC4, UNIFORMTYPE_FLOAT, UNIFORMTYPE_FLOATARRAY, UNIFORMTYPE_INT, UNIFORMTYPE_IVEC2, UNIFORMTYPE_IVEC3, UNIFORMTYPE_IVEC4, UNIFORMTYPE_MAT2, UNIFORMTYPE_MAT3, UNIFORMTYPE_MAT4, UNIFORMTYPE_TEXTURE2D, UNIFORMTYPE_TEXTURE2D_SHADOW, UNIFORMTYPE_TEXTURE3D, UNIFORMTYPE_TEXTURECUBE, UNIFORMTYPE_TEXTURECUBE_SHADOW, UNIFORMTYPE_VEC2, UNIFORMTYPE_VEC2ARRAY, UNIFORMTYPE_VEC3, UNIFORMTYPE_VEC3ARRAY, UNIFORMTYPE_VEC4, UNIFORMTYPE_VEC4ARRAY, URI, UnsupportedBrowserError, VIEW_CENTER, VIEW_LEFT, VIEW_RIGHT, Vec2, Vec3, Vec4, VertexBuffer, VertexFormat, VertexIterator, VrDisplay, VrManager, WebglGraphicsDevice, WorldClusters, XRDEPTHSENSINGFORMAT_F32, XRDEPTHSENSINGFORMAT_L8A8, XRDEPTHSENSINGUSAGE_CPU, XRDEPTHSENSINGUSAGE_GPU, XRHAND_LEFT, XRHAND_NONE, XRHAND_RIGHT, XRSPACE_BOUNDEDFLOOR, XRSPACE_LOCAL, XRSPACE_LOCALFLOOR, XRSPACE_UNBOUNDED, XRSPACE_VIEWER, XRTARGETRAY_GAZE, XRTARGETRAY_POINTER, XRTARGETRAY_SCREEN, XRTRACKABLE_MESH, XRTRACKABLE_PLANE, XRTRACKABLE_POINT, XRTYPE_AR, XRTYPE_INLINE, XRTYPE_VR, XrDepthSensing, XrDomOverlay, XrHitTest, XrHitTestSource, XrImageTracking, XrInput, XrInputSource, XrLightEstimation, XrManager, XrPlane, XrPlaneDetection, XrTrackedImage, ZoneComponent, ZoneComponentSystem, anim, app, apps, asset, audio, basisInitialize, basisSetDownloadConfig, basisTranscode, calculateNormals, calculateTangents, common, config, createBox, createCapsule, createCone, createCylinder, createMesh$1 as createMesh, createPlane, createScript, createSphere, createStyle, createTorus, createURI, data, drawFullscreenQuad, drawQuadWithShader, drawTexture, events, extend, fw, getTouchTargetCoords, gfx, guid, http, inherits, input, isDefined, log, makeArray, math, now, path, platform, posteffect, prefilterCubemap, programlib, registerScript, reprojectTexture, revision, scene, script, semanticToLocation, shFromCubemap, shaderChunks, shadowTypeToString, shape, string, time, type, typedArrayIndexFormats, typedArrayIndexFormatsByteSize, typedArrayToType, typedArrayTypes, typedArrayTypesByteSize, version };
