import"../../core/debug.js";import{math as e}from"../../core/math/math.js";import{ShadowMap as s}from"./shadow-map.js";import{LIGHTTYPE_SPOT as t,LIGHTTYPE_OMNI as r}from"../constants.js";import{RenderPass as a}from"../../platform/graphics/render-pass.js";class o{constructor(e,s){this.shadowLights=[],this.renderer=void 0,this.shadowRenderer=void 0,this.device=void 0,this.renderer=e,this.shadowRenderer=s,this.device=e.device}cull(a,o){const n=this.renderer.scene.clusteredLightingEnabled;a.visibleThisFrame=!0,n||a._shadowMap||(a._shadowMap=s.create(this.device,a));const d=a._type,i=d===t?1:6;for(let s=0;s<i;s++){const i=a.getRenderData(null,s),h=i.shadowCamera;h.nearClip=a.attenuationEnd/1e3,h.farClip=a.attenuationEnd;const l=h._node,c=a._node;if(l.setPosition(c.getPosition()),d===t)h.fov=2*a._outerConeAngle,l.setRotation(c.getRotation()),l.rotateLocal(-90,0,0);else if(d===r)if(n){const s=2/(this.shadowRenderer.lightTextureAtlas.shadowAtlasResolution*a.atlasViewport.z/3)*this.shadowRenderer.lightTextureAtlas.shadowEdgePixels;h.fov=Math.atan(1+s)*e.RAD_TO_DEG*2}else h.fov=90;this.renderer.updateCameraFrustum(h),this.shadowRenderer.cullShadowCasters(o,i.visibleCasters,h)}}prepareLights(e,s){let t;for(let r=0;r<s.length;r++){const a=s[r];if(this.shadowRenderer.needsShadowRendering(a)&&a.atlasViewportAllocated){e.push(a);for(let e=0;e<a.numShadowFaces;e++)t=this.shadowRenderer.prepareFace(a,null,e)}}return t}prepareClusteredRenderPass(e,s,t){const r=this.shadowLights,a=this.prepareLights(r,s),o=this.prepareLights(r,t),n=null!=a?a:o,d=r.length;d&&(this.shadowRenderer.setupRenderPass(e,n,!1),e.execute=()=>{for(let e=0;e<d;e++){const s=r[e];for(let e=0;e<s.numShadowFaces;e++)this.shadowRenderer.renderFace(s,null,e,!0)}r.length=0})}setupNonClusteredFaceRenderPass(e,s,t,r){const o=this.shadowRenderer.prepareFace(s,null,t),n=new a(this.device,(()=>{this.shadowRenderer.renderFace(s,null,t,!1)}));this.shadowRenderer.setupRenderPass(n,o,!0),r&&(n.after=()=>{this.shadowRenderer.renderVsm(s,o)}),e.addRenderPass(n)}buildNonClusteredRenderPasses(e,s,t){for(let t=0;t<s.length;t++){const r=s[t];this.shadowRenderer.needsShadowRendering(r)&&this.setupNonClusteredFaceRenderPass(e,r,0,!0)}for(let s=0;s<t.length;s++){const r=t[s];if(this.shadowRenderer.needsShadowRendering(r)){const s=r.numShadowFaces;for(let t=0;t<s;t++)this.setupNonClusteredFaceRenderPass(e,r,t,!1)}}}}export{o as ShadowRendererLocal};
