import{PRIMITIVE_TRISTRIP as t}from"../../platform/graphics/constants.js";import{BLEND_NORMAL as e}from"../constants.js";import{GraphNode as r}from"../graph-node.js";import{Mesh as a}from"../mesh.js";import{MeshInstance as s}from"../mesh-instance.js";import{BasicMaterial as h}from"../materials/basic-material.js";import{createShaderFromCode as i}from"../shader-lib/utils.js";import{shaderChunks as n}from"../shader-lib/chunks/chunks.js";import{ImmediateBatches as o}from"./immediate-batches.js";const l=[];class d{constructor(t){this.device=t,this.quadMesh=null,this.textureShader=null,this.depthTextureShader=null,this.cubeLocalPos=null,this.cubeWorldPos=null,this.batchesMap=new Map,this.allBatches=new Set,this.updatedLayers=new Set,this._materialDepth=null,this._materialNoDepth=null,this.layerMeshInstances=new Map}createMaterial(t){const r=new h;return r.vertexColors=!0,r.blendType=e,r.depthTest=t,r.update(),r}get materialDepth(){return this._materialDepth||(this._materialDepth=this.createMaterial(!0)),this._materialDepth}get materialNoDepth(){return this._materialNoDepth||(this._materialNoDepth=this.createMaterial(!1)),this._materialNoDepth}getBatch(t,e){let r=this.batchesMap.get(t);r||(r=new o(this.device),this.batchesMap.set(t,r)),this.allBatches.add(r);const a=e?this.materialDepth:this.materialNoDepth;return r.getBatch(a,t)}getShader(t,e){if(!this[t]){const r="\n\t\t\t\t\t\t\t\tattribute vec2 vertex_position;\n\t\t\t\t\t\t\t\tuniform mat4 matrix_model;\n\t\t\t\t\t\t\t\tvarying vec2 uv0;\n\t\t\t\t\t\t\t\tvoid main(void) {\n\t\t\t\t\t\t\t\t\t\tgl_Position = matrix_model * vec4(vertex_position, 0, 1);\n\t\t\t\t\t\t\t\t\t\tuv0 = vertex_position.xy + 0.5;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t";this[t]=i(this.device,r,e,`DebugShader:${t}`)}return this[t]}getTextureShader(){return this.getShader("textureShader","\n\t\t\t\t\t\tvarying vec2 uv0;\n\t\t\t\t\t\tuniform sampler2D colorMap;\n\t\t\t\t\t\tvoid main (void) {\n\t\t\t\t\t\t\t\tgl_FragColor = vec4(texture2D(colorMap, uv0).xyz, 1);\n\t\t\t\t\t\t}\n\t\t\t\t")}getUnfilterableTextureShader(){return this.getShader("textureShaderUnfilterable","\n\t\t\t\t\t\tvarying vec2 uv0;\n\t\t\t\t\t\tuniform highp sampler2D colorMap;\n\t\t\t\t\t\tvoid main (void) {\n\t\t\t\t\t\t\t\tivec2 uv = ivec2(uv0 * textureSize(colorMap, 0));\n\t\t\t\t\t\t\t\tgl_FragColor = vec4(texelFetch(colorMap, uv, 0).xyz, 1);\n\t\t\t\t\t\t}\n\t\t\t\t")}getDepthTextureShader(){return this.getShader("depthTextureShader",`\n\t\t\t\t\t\t${n.screenDepthPS}\n\t\t\t\t\t\tvarying vec2 uv0;\n\t\t\t\t\t\tvoid main() {\n\t\t\t\t\t\t\t\tfloat depth = getLinearScreenDepth(uv0) * camera_params.x;\n\t\t\t\t\t\t\t\tgl_FragColor = vec4(vec3(depth), 1.0);\n\t\t\t\t\t\t}\n\t\t\t\t`)}getQuadMesh(){return this.quadMesh||(this.quadMesh=new a(this.device),this.quadMesh.setPositions([-.5,-.5,0,.5,-.5,0,-.5,.5,0,.5,.5,0]),this.quadMesh.update(t)),this.quadMesh}drawMesh(t,e,r,a,h){if(!a){const h=this.getGraphNode(e);a=new s(r,t,h)}let i=this.layerMeshInstances.get(h);i||(i=[],this.layerMeshInstances.set(h,i)),i.push(a)}drawWireAlignedBox(t,e,r,a,s){l.push(t.x,t.y,t.z,t.x,e.y,t.z,t.x,e.y,t.z,e.x,e.y,t.z,e.x,e.y,t.z,e.x,t.y,t.z,e.x,t.y,t.z,t.x,t.y,t.z,t.x,t.y,e.z,t.x,e.y,e.z,t.x,e.y,e.z,e.x,e.y,e.z,e.x,e.y,e.z,e.x,t.y,e.z,e.x,t.y,e.z,t.x,t.y,e.z,t.x,t.y,t.z,t.x,t.y,e.z,t.x,e.y,t.z,t.x,e.y,e.z,e.x,e.y,t.z,e.x,e.y,e.z,e.x,t.y,t.z,e.x,t.y,e.z);this.getBatch(s,a).addLinesArrays(l,r),l.length=0}drawWireSphere(t,e,r,a,s,h){const i=2*Math.PI/a;let n=0;for(let r=0;r<a;r++){const r=Math.sin(n),a=Math.cos(n);n+=i;const s=Math.sin(n),h=Math.cos(n);l.push(t.x+e*r,t.y,t.z+e*a),l.push(t.x+e*s,t.y,t.z+e*h),l.push(t.x+e*r,t.y+e*a,t.z),l.push(t.x+e*s,t.y+e*h,t.z),l.push(t.x,t.y+e*r,t.z+e*a),l.push(t.x,t.y+e*s,t.z+e*h)}this.getBatch(h,s).addLinesArrays(l,r),l.length=0}getGraphNode(t){const e=new r("ImmediateDebug");return e.worldTransform=t,e._dirtyWorld=e._dirtyNormal=!1,e}onPreRenderLayer(t,e,r){if(this.batchesMap.forEach(((a,s)=>{s===t&&a.onPreRender(e,r)})),!this.updatedLayers.has(t)){this.updatedLayers.add(t);const r=this.layerMeshInstances.get(t);if(r){for(let t=0;t<r.length;t++)e.list[e.length+t]=r[t];e.length+=r.length,r.length=0}}}onPostRender(){this.allBatches.clear(),this.updatedLayers.clear()}}export{d as Immediate};
