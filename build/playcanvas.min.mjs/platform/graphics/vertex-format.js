import"../../core/debug.js";import{hashCode as t}from"../../core/hash.js";import{math as e}from"../../core/math/math.js";import{typedArrayTypesByteSize as s,SEMANTIC_TEXCOORD0 as n,SEMANTIC_TEXCOORD1 as i,SEMANTIC_COLOR as a,SEMANTIC_TANGENT as o,SEMANTIC_ATTR12 as h,TYPE_FLOAT32 as r,SEMANTIC_ATTR13 as m,SEMANTIC_ATTR14 as c,SEMANTIC_ATTR15 as l}from"./constants.js";class p{constructor(t,h,r){this.device=t,this._elements=[],this.hasUv0=!1,this.hasUv1=!1,this.hasColor=!1,this.hasTangents=!1,this.verticesByteSize=0,this.vertexCount=r,this.interleaved=void 0===r,this.instancing=!1,this.size=h.reduce(((t,e)=>t+4*Math.ceil(e.components*s[e.type]/4)),0);let m,c=0;for(let t=0,p=h.length;t<p;t++){var l;const p=h[t];m=p.components*s[p.type],r&&(c=e.roundUp(c,m));const u={name:p.semantic,offset:r?c:p.hasOwnProperty("offset")?p.offset:c,stride:r?m:p.hasOwnProperty("stride")?p.stride:this.size,dataType:p.type,numComponents:p.components,normalize:null!=(l=p.normalize)&&l,size:m};this._elements.push(u),c+=r?m*r:4*Math.ceil(m/4),p.semantic===n?this.hasUv0=!0:p.semantic===i?this.hasUv1=!0:p.semantic===a?this.hasColor=!0:p.semantic===o&&(this.hasTangents=!0)}r&&(this.verticesByteSize=c),this._evaluateHash()}get elements(){return this._elements}static getDefaultInstancingFormat(t){return p._defaultInstancingFormat||(p._defaultInstancingFormat=new p(t,[{semantic:h,components:4,type:r},{semantic:m,components:4,type:r},{semantic:c,components:4,type:r},{semantic:l,components:4,type:r}])),p._defaultInstancingFormat}update(){this._evaluateHash()}_evaluateHash(){let e;const s=[];let n;const i=[],a=this._elements.length;for(let t=0;t<a;t++){const a=this._elements[t];e=a.name,e+=a.dataType,e+=a.numComponents,e+=a.normalize,s.push(e),n=e,n+=a.offset,n+=a.stride,n+=a.size,i.push(n)}s.sort(),this.batchingHash=t(s.join()),this.renderingHashString=i.join("_"),this.renderingHash=t(this.renderingHashString)}}p._defaultInstancingFormat=null;export{p as VertexFormat};
