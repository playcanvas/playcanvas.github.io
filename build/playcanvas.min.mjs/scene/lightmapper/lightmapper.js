import{now as e}from"../../core/time.js";import"../../core/tracing.js";import{math as t}from"../../math/math.js";import{Color as s}from"../../math/color.js";import{Vec3 as a}from"../../math/vec3.js";import{BoundingBox as r}from"../../shape/bounding-box.js";import{PIXELFORMAT_R8_G8_B8_A8 as i,TEXTURETYPE_RGBM as n,CHUNKAPI_1_55 as h,CULLFACE_NONE as o,FILTER_NEAREST as l,ADDRESS_CLAMP_TO_EDGE as c,FILTER_LINEAR as m,TEXTURETYPE_DEFAULT as d}from"../../graphics/constants.js";import{shaderChunks as p}from"../../graphics/program-lib/chunks/chunks.js";import{shaderChunksLightmapper as g}from"../../graphics/program-lib/chunks/chunks-lightmapper.js";import{drawQuadWithShader as u}from"../../graphics/simple-post-effect.js";import{RenderTarget as f}from"../../graphics/render-target.js";import{Texture as b}from"../../graphics/texture.js";import{MeshInstance as w}from"../mesh-instance.js";import{LightingParams as k}from"../lighting/lighting-params.js";import{WorldClusters as T}from"../lighting/world-clusters.js";import{PROJECTION_ORTHOGRAPHIC as S,MASK_AFFECT_LIGHTMAPPED as M,BAKE_COLORDIR as L,MASK_BAKE as _,LIGHTTYPE_DIRECTIONAL as x,SHADOWUPDATE_REALTIME as C,SHADOWUPDATE_THISFRAME as B,FOG_NONE as y,LIGHTTYPE_SPOT as P,PROJECTION_PERSPECTIVE as A,LIGHTTYPE_OMNI as j,SHADER_FORWARDHDR as v,SHADERDEF_LM as R,SHADERDEF_DIRLM as E,SHADERDEF_LMAMBIENT as F}from"../constants.js";import{Camera as D}from"../camera.js";import{GraphNode as z}from"../graph-node.js";import{StandardMaterial as I}from"../materials/standard-material.js";import{BakeLightSimple as O}from"./bake-light-simple.js";import{BakeLightAmbient as N}from"./bake-light-ambient.js";import{BakeMeshNode as V}from"./bake-mesh-node.js";import{LightmapCache as U}from"./lightmap-cache.js";import{LightmapFilters as $}from"./lightmap-filters.js";const q=new a;class W{constructor(e,t,a,r,i){this.device=e,this.root=t,this.scene=a,this.renderer=r,this.assets=i,this.shadowMapCache=r._shadowRenderer.shadowMapCache,this._tempSet=new Set,this._initCalled=!1,this.passMaterials=[],this.ambientAOMaterial=null,this.fog="",this.ambientLight=new s,this.renderTargets=new Map,this.stats={renderPasses:0,lightmapCount:0,totalRenderTime:0,forwardTime:0,fboTime:0,shadowMapTime:0,compileTime:0,shadersLinked:0}}destroy(){U.decRef(this.blackTex),this.blackTex=null,U.destroy(),this.device=null,this.root=null,this.scene=null,this.renderer=null,this.assets=null}initBake(e){if(!this._initCalled){this._initCalled=!0,this.lightmapFilters=new $(e),this.constantBakeDir=e.scope.resolve("bakeDir"),this.materials=[],this.blackTex=new b(this.device,{width:4,height:4,format:i,type:n,name:"lightmapBlack"}),U.incRef(this.blackTex);const t=new D;t.clearColor.set(0,0,0,0),t.clearColorBuffer=!0,t.clearDepthBuffer=!1,t.clearStencilBuffer=!1,t.frustumCulling=!1,t.projection=S,t.aspectRatio=1,t.node=new z,this.camera=t}if(this.scene.clusteredLightingEnabled){const t=new k(e.supportsAreaLights,e.maxTextureSize,(()=>{}));this.lightingParams=t;const s=this.scene.lighting;t.shadowsEnabled=s.shadowsEnabled,t.shadowAtlasResolution=s.shadowAtlasResolution,t.cookiesEnabled=s.cookiesEnabled,t.cookieAtlasResolution=s.cookieAtlasResolution,t.areaLightsEnabled=s.areaLightsEnabled,t.cells=new a(3,3,3),t.maxLightsPerCell=4,this.worldClusters=new T(e),this.worldClusters.name="ClusterLightmapper"}}finishBake(e){function t(e){U.decRef(e.colorBuffer),e.destroy()}this.materials=[],this.renderTargets.forEach((e=>{t(e)})),this.renderTargets.clear(),e.forEach((e=>{e.renderTargets.forEach((e=>{t(e)})),e.renderTargets.length=0})),this.ambientAOMaterial=null,this.worldClusters&&(this.worldClusters.destroy(),this.worldClusters=null)}createMaterialForPass(e,t,a,r){const i=new I;if(i.name=`lmMaterial-pass:${a}-ambient:${r}`,i.chunks.APIVersion=h,i.chunks.transformVS="#define UV1LAYOUT\n"+p.transformVS,0===a){let e=g.bakeLmEndPS;r?e=`\n                    dDiffuseLight = ((dDiffuseLight - 0.5) * max(${t.ambientBakeOcclusionContrast.toFixed(1)} + 1.0, 0.0)) + 0.5;\n                    dDiffuseLight += vec3(${t.ambientBakeOcclusionBrightness.toFixed(1)});\n                    dDiffuseLight = saturate(dDiffuseLight);\n                    dDiffuseLight *= dAmbientLight;\n                `+e:(i.ambient=new s(0,0,0),i.ambientTint=!0),i.chunks.endPS=e,i.lightMap=this.blackTex}else i.chunks.basePS=p.basePS+"\nuniform sampler2D texture_dirLightMap;\nuniform float bakeDir;\n",i.chunks.endPS=g.bakeDirLmEndPS;return i.chunks.outputAlphaPS="\n",i.chunks.outputAlphaOpaquePS="\n",i.chunks.outputAlphaPremulPS="\n",i.cull=o,i.forceUv1=!0,i.update(),i}createMaterials(e,t,s){for(let a=0;a<s;a++)this.passMaterials[a]||(this.passMaterials[a]=this.createMaterialForPass(e,t,a,!1));this.ambientAOMaterial||(this.ambientAOMaterial=this.createMaterialForPass(e,t,0,!0),this.ambientAOMaterial.onUpdateShader=function(e){return e.lightMapWithoutAmbient=!0,e.separateAmbient=!0,e})}createTexture(e,t,s){return new b(this.device,{width:e,height:e,format:i,mipmaps:!1,type:t,minFilter:l,magFilter:l,addressU:c,addressV:c,name:s})}collectModels(e,t,s){var a,r,i;if(!e.enabled)return;let n;if(null!=(a=e.model)&&a.model&&null!=(r=e.model)&&r.enabled&&(s&&s.push(new V(e)),e.model.lightmapped&&t&&(n=e.model.model.meshInstances)),null!=(i=e.render)&&i.enabled&&(s&&s.push(new V(e)),e.render.lightmapped&&t&&(n=e.render.meshInstances)),n){let s=!0;for(let e=0;e<n.length;e++)if(!n[e].mesh.vertexBuffer.format.hasUv1){s=!1;break}if(s){const s=[];for(let a=0;a<n.length;a++){const r=n[a].mesh;this._tempSet.has(r)?t.push(new V(e,[n[a]])):s.push(n[a]),this._tempSet.add(r)}this._tempSet.clear(),s.length>0&&t.push(new V(e,s))}}for(let a=0;a<e._children.length;a++)this.collectModels(e._children[a],t,s)}prepareShadowCasters(e){const t=[];for(let s=0;s<e.length;s++){const a=e[s].component;if(a.castShadows=a.castShadowsLightmap,a.castShadowsLightmap){const a=e[s].meshInstances;for(let e=0;e<a.length;e++)a[e].visibleThisFrame=!0,t.push(a[e])}}return t}updateTransforms(e){for(let t=0;t<e.length;t++){const s=e[t].meshInstances;for(let e=0;e<s.length;e++)s[e].node.getWorldTransform()}}calculateLightmapSize(e){let s;const a=this.scene.lightmapSizeMultiplier||16,r=q;let i,n;e.model?(n=e.model.lightmapSizeMultiplier,e.model.asset?(s=this.assets.get(e.model.asset).data,s.area&&(i=s.area)):e.model._area&&(s=e.model,s._area&&(i=s._area))):e.render&&(n=e.render.lightmapSizeMultiplier,"asset"!==e.render.type&&e.render._area&&(s=e.render,s._area&&(i=s._area)));const h={x:1,y:1,z:1,uv:1};i&&(h.x=i.x,h.y=i.y,h.z=i.z,h.uv=i.uv);const o=n||1;h.x*=o,h.y*=o,h.z*=o;const l=e.render||e.model,c=this.computeNodeBounds(l.meshInstances);r.copy(c.halfExtents);let m=h.x*r.y*r.z+h.y*r.x*r.z+h.z*r.x*r.y;m/=h.uv,m=Math.sqrt(m);return Math.min(t.nextPowerOfTwo(m*a),this.scene.lightmapMaxResolution||2048)}setLightmapping(e,t,s,a){for(let r=0;r<e.length;r++){const i=e[r],n=i.meshInstances;for(let e=0;e<n.length;e++){const r=n[e];if(r.setLightmapped(t),t){a&&(r._shaderDefs|=a),r.mask=M;for(let e=0;e<s;e++){const t=i.renderTargets[e].colorBuffer;t.minFilter=m,t.magFilter=m,r.setRealtimeLightmap(w.lightmapParamNames[e],t)}}}}}bake(t,s=L){const a=this.device,r=e();this.scene._updateSky(a),this.stats.renderPasses=0,this.stats.shadowMapTime=0,this.stats.forwardTime=0;const i=a._shaderStats.linked,n=a._renderTargetCreationTime,h=a._shaderStats.compileTime,o=[],l=[];if(t){for(let e=0;e<t.length;e++)this.collectModels(t[e],o,null);this.collectModels(this.root,null,l)}else this.collectModels(this.root,o,l);if(o.length>0){const e=s===L?2:1;this.setLightmapping(o,!1,e),this.initBake(a),this.bakeInternal(e,o,l);let t=R;s===L&&(t|=E),this.scene.ambientBake&&(t|=F),this.setLightmapping(o,!0,e,t),this.finishBake(o)}const c=e();this.stats.totalRenderTime=c-r,this.stats.shadersLinked=a._shaderStats.linked-i,this.stats.compileTime=a._shaderStats.compileTime-h,this.stats.fboTime=a._renderTargetCreationTime-n,this.stats.lightmapCount=o.length}allocateTextures(e,t){for(let s=0;s<e.length;s++){const a=e[s],r=this.calculateLightmapSize(a.node);for(let e=0;e<t;e++){const t=this.createTexture(r,d,"lightmapper_lightmap_"+s);U.incRef(t),a.renderTargets[e]=new f({colorBuffer:t,depth:!1})}if(!this.renderTargets.has(r)){const e=this.createTexture(r,d,"lightmapper_temp_lightmap_"+r);U.incRef(e),this.renderTargets.set(r,new f({colorBuffer:e,depth:!1}))}}}prepareLightsToBake(e,t,s){if(this.scene.ambientBake){const e=new N(this.scene);s.push(e)}const a=e._lights;for(let e=0;e<a.length;e++){const r=a[e],i=new O(this.scene,r);t.push(i),r.enabled&&0!=(r.mask&_)&&(r.isStatic=!1,r.mask=4294967295,r.shadowUpdateMode=r.type===x?C:B,s.push(i))}s.sort()}restoreLights(e){for(let t=0;t<e.length;t++)e[t].restore()}setupScene(){this.revertStatic=!1,this.scene._needsStaticPrepare&&(this.scene._needsStaticPrepare=!1,this.revertStatic=!0),this.fog=this.scene.fog,this.ambientLight.copy(this.scene.ambientLight),this.scene.fog=y,this.scene.ambientBake||this.scene.ambientLight.set(0,0,0),this.renderer.setSceneConstants()}restoreScene(){this.scene.fog=this.fog,this.scene.ambientLight.copy(this.ambientLight),this.revertStatic&&(this.scene._needsStaticPrepare=!0)}computeNodeBounds(e){const t=new r;if(e.length>0){t.copy(e[0].aabb);for(let s=1;s<e.length;s++)t.add(e[s].aabb)}return t}computeNodesBounds(e){for(let t=0;t<e.length;t++){const s=e[t].meshInstances;e[t].bounds=this.computeNodeBounds(s)}}computeBounds(e){const t=new r;for(let s=0;s<e.length;s++){t.copy(e[0].aabb);for(let s=1;s<e.length;s++)t.add(e[s].aabb)}return t}backupMaterials(e){for(let t=0;t<e.length;t++)this.materials[t]=e[t].material}restoreMaterials(e){for(let t=0;t<e.length;t++)e[t].material=this.materials[t]}lightCameraPrepare(e,t){const s=t.light;let a;if(s.type===P){a=s.getRenderData(null,0).shadowCamera,a._node.setPosition(s._node.getPosition()),a._node.setRotation(s._node.getRotation()),a._node.rotateLocal(-90,0,0),a.projection=A,a.nearClip=s.attenuationEnd/1e3,a.farClip=s.attenuationEnd,a.aspectRatio=1,a.fov=2*s._outerConeAngle,this.renderer.updateCameraFrustum(a)}return a}lightCameraPrepareAndCull(e,t,s,a){const r=e.light;let i=!0;if(r.type===x){q.copy(a.center),q.y+=a.halfExtents.y,this.camera.node.setPosition(q),this.camera.node.setEulerAngles(-90,0,0),this.camera.nearClip=0,this.camera.farClip=2*a.halfExtents.y;const e=Math.max(a.halfExtents.x,a.halfExtents.z);this.camera.orthoHeight=e}else e.lightBounds.intersects(t.bounds)||(i=!1);if(r.type===P){let e=!1;const a=t.meshInstances;for(let t=0;t<a.length;t++)if(a[t]._isVisible(s)){e=!0;break}e||(i=!1)}return i}setupLightArray(e,t){e[x].length=0,e[j].length=0,e[P].length=0,e[t.type][0]=t,t.visibleThisFrame=!0}renderShadowMap(e,t,s,a){const r=a.light;return!e&&r.castShadows&&(r.shadowMap||this.scene.clusteredLightingEnabled||(r.shadowMap=this.shadowMapCache.get(this.device,r)),r.type===x?this.renderer._shadowRenderer.cullDirectional(r,t,this.camera):this.renderer._shadowRenderer.cullLocal(r,t),this.renderer.renderShadows(s[r.type],this.camera)),!0}postprocessTextures(e,t,s){const a=this.lightmapFilters.shaderDilate,r=this.scene.lightmapFilterEnabled;r&&this.lightmapFilters.prepareDenoise(this.scene.lightmapFilterRange,this.scene.lightmapFilterSmoothness);for(let i=0;i<t.length;i++){const n=t[i];for(let t=0;t<s;t++){const s=n.renderTargets[t],i=s.colorBuffer,h=this.renderTargets.get(i.width),o=h.colorBuffer;this.lightmapFilters.prepare(i.width,i.height);for(let n=0;n<1;n++){this.lightmapFilters.setSourceTexture(i);u(e,h,r&&0===t&&0===n?this.lightmapFilters.shaderDenoise:a),this.lightmapFilters.setSourceTexture(o),u(e,s,a)}}}}bakeInternal(e,t,s){const a=this.scene,r=this.device,i=a.clusteredLightingEnabled;this.createMaterials(r,a,e),this.setupScene(),a.layers._update(),this.computeNodesBounds(t),this.allocateTextures(t,e);const n=[],h=[];this.prepareLightsToBake(a.layers,n,h),this.updateTransforms(s);const o=this.prepareShadowCasters(s);this.renderer.updateCpuSkinMatrices(o),this.renderer.gpuUpdate(o);const l=this.computeBounds(o);let c,m,d,p;for(c=0;c<t.length;c++){for(d=t[c].meshInstances,m=0;m<d.length;m++)p=d[m],p.setLightmapped(!1),p.mask=_,p.setRealtimeLightmap(w.lightmapParamNames[0],p.material.lightMap?p.material.lightMap:this.blackTex),p.setRealtimeLightmap(w.lightmapParamNames[1],this.blackTex)}for(m=0;m<h.length;m++)h[m].light.enabled=!1;const g=[[],[],[]];let u,f,b=!1;for(c=0;c<h.length;c++){const s=h[c],n=s instanceof N;let k=s.numVirtualLights;e>1&&k>1&&s.light.bakeDir&&(k=1);for(let h=0;h<k;h++){k>1&&s.prepareVirtualLight(h,k),s.startBake();let c=!1;const T=this.lightCameraPrepare(r,s);for(f=0;f<t.length;f++){const S=t[f];d=S.meshInstances;if(this.lightCameraPrepareAndCull(s,S,T,l)){if(this.setupLightArray(g,s.light),i&&this.renderer.lightTextureAtlas.update(g[P],g[j],this.lightingParams),c=this.renderShadowMap(c,o,g,s),i){const e=g[P].concat(g[j]);this.worldClusters.update(e,this.scene.gammaCorrection,this.lightingParams)}for(this.backupMaterials(d),u=0;u<e&&!(u>0&&h>0)&&!(n&&u>0);u++){const e=S.renderTargets[u],t=S.renderTargets[u].colorBuffer.width,o=this.renderTargets.get(t),l=o.colorBuffer;0===u?b=a.updateShaders:b&&(a.updateShaders=!0);let c=this.passMaterials[u];if(n){h+1===k&&0===u&&(c=this.ambientAOMaterial)}for(m=0;m<d.length;m++)d[m].material=c;for(this.renderer.updateShaders(d),this.renderer.setCamera(this.camera,o,!0),1===u&&this.constantBakeDir.setValue(s.light.bakeDir?1:0),i&&this.worldClusters.activate(this.renderer.lightTextureAtlas),this.renderer._forwardTime=0,this.renderer._shadowMapTime=0,this.renderer.renderForward(this.camera,d,d.length,g,v),r.updateEnd(),S.renderTargets[u]=o,this.renderTargets.set(t,e),m=0;m<d.length;m++)p=d[m],p.setRealtimeLightmap(w.lightmapParamNames[u],l),p._shaderDefs|=R}this.restoreMaterials(d)}}s.endBake(this.shadowMapCache)}}for(this.postprocessTextures(r,t,e),f=0;f<s.length;f++)s[f].restore();this.restoreLights(n),this.restoreScene(),i||this.shadowMapCache.clear()}}export{W as Lightmapper};
