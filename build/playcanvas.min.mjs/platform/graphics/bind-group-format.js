import"../../core/tracing.js";import{TEXTUREDIMENSION_2D as t,SAMPLETYPE_FLOAT as e,TEXTUREDIMENSION_CUBE as s,TEXTUREDIMENSION_3D as r}from"./constants.js";let i=0;const o={[t]:"texture2D",[s]:"textureCube",[r]:"texture3D"};class a{constructor(t,e){this.name=t,this.visibility=e}}class n{constructor(s,r,i=t,o=e){this.scopeId=void 0,this.name=s,this.visibility=r,this.textureDimension=i,this.sampleType=o}}class m{constructor(t,e=[],s=[]){this.id=i++,this.device=t,this.bufferFormats=e,this.bufferFormatsMap=new Map,e.forEach(((t,e)=>this.bufferFormatsMap.set(t.name,e))),this.textureFormats=s;const r=t.scope;this.textureFormatsMap=new Map,s.forEach(((t,e)=>{this.textureFormatsMap.set(t.name,e),t.scopeId=r.resolve(t.name)})),this.impl=t.createBindGroupFormatImpl(this)}destroy(){this.impl.destroy()}getTexture(t){const e=this.textureFormatsMap.get(t);return void 0!==e?this.textureFormats[e]:null}getShaderDeclarationTextures(t){let e="",s=this.bufferFormats.length;return this.textureFormats.forEach((r=>{const i=o[r.textureDimension];e+=`layout(set = ${t}, binding = ${s++}) uniform ${i} ${r.name};\nlayout(set = ${t}, binding = ${s++}) uniform sampler ${r.name}_sampler;\n`})),e}loseContext(){}}export{a as BindBufferFormat,m as BindGroupFormat,n as BindTextureFormat};
