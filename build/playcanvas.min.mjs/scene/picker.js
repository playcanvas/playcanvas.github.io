import{Color as e}from"../math/color.js";import{PIXELFORMAT_R8_G8_B8_A8 as t,FILTER_NEAREST as r,ADDRESS_CLAMP_TO_EDGE as a,CLEARFLAG_DEPTH as i}from"../graphics/constants.js";import{GraphicsDevice as s}from"../graphics/graphics-device.js";import{RenderTarget as o}from"../graphics/render-target.js";import{Texture as n}from"../graphics/texture.js";import{SHADER_PICK as h,SORTMODE_NONE as c}from"./constants.js";import{Camera as l}from"./camera.js";import{Command as m}from"./mesh-instance.js";import{Layer as p}from"./layer.js";import{LayerComposition as d}from"./composition/layer-composition.js";import{getApplication as g}from"../framework/globals.js";import{Entity as f}from"../framework/entity.js";import"../core/tracing.js";const y=new Set,u={depth:1,flags:i};class C{constructor(e,t,r){e instanceof s&&(e=g()),this.app=e,this.device=e.graphicsDevice,this.pickColor=new Float32Array(4),this.pickColor[3]=1,this.mapping=[],this.cameraEntity=null,this.layer=null,this.layerComp=null,this.initLayerComposition(),this._renderTarget=null;const a=this.device;this.clearDepthCommand=new m(0,0,(function(){a.clear(u)})),this.width=0,this.height=0,this.resize(t,r)}getSelection(e,t,r,a){const i=this.device;if("object"==typeof e){const i=e;e=i.x,t=i.y,r=i.width,a=i.height}else t=this.renderTarget.height-(t+(a||1));e=Math.floor(e),t=Math.floor(t),r=Math.floor(Math.max(r||1,1)),a=Math.floor(Math.max(a||1,1));const s=i.renderTarget;i.setRenderTarget(this.renderTarget),i.updateBegin();const o=new Uint8Array(4*r*a);i.readPixels(e,t,r,a,o),i.updateEnd(),i.setRenderTarget(s);const n=this.mapping;for(let e=0;e<r*a;e++){const t=o[4*e+0]<<16|o[4*e+1]<<8|o[4*e+2];16777215!==t&&y.add(n[t])}const h=[];return y.forEach((e=>h.push(e))),y.clear(),h}allocateRenderTarget(){const e=new n(this.device,{format:t,width:this.width,height:this.height,mipmaps:!1,minFilter:r,magFilter:r,addressU:a,addressV:a,name:"pick"});this.renderTarget=new o({colorBuffer:e,depth:!0})}releaseRenderTarget(){this.cameraEntity.camera.renderTarget=null,this._renderTarget&&(this._renderTarget.destroyTextureBuffers(),this._renderTarget.destroy(),this._renderTarget=null)}initLayerComposition(){const e=this.device,t=this,r=e.scope.resolve("uColor");this.cameraEntity=new f,this.cameraEntity.addComponent("camera"),this.layer=new p({name:"Picker",shaderPass:h,opaqueSortMode:c,onDrawCall:function(a,i){t.pickColor[0]=(i>>16&255)/255,t.pickColor[1]=(i>>8&255)/255,t.pickColor[2]=(255&i)/255,r.setValue(t.pickColor),e.setBlending(!1),t.mapping[i]=a}}),this.layer.addCamera(this.cameraEntity.camera),this.layerComp=new d("picker"),this.layerComp.pushOpaque(this.layer)}prepare(e,t,r){e instanceof l&&(e=e.node.camera),r instanceof p&&(r=[r]),this.layer.clearMeshInstances();const a=this.layer.opaqueMeshInstances,i=t.layers.layerList,s=t.layers.subLayerEnabled,o=t.layers.subLayerList;for(let t=0;t<i.length;t++){const n=i[t];if(!(r&&r.indexOf(n)<0)&&(n.enabled&&s[t])){if(n.cameras.indexOf(e)>=0){n._clearDepthBuffer&&a.push(this.clearDepthCommand);const e=o[t]?n.instances.transparentMeshInstances:n.instances.opaqueMeshInstances;for(let t=0;t<e.length;t++){const r=e[t];r.pick&&a.push(r)}}}}this.renderTarget&&this.width===this.renderTarget.width&&this.height===this.renderTarget.height||(this.releaseRenderTarget(),this.allocateRenderTarget()),this.updateCamera(e),this.mapping.length=0,this.app.renderComposition(this.layerComp)}updateCamera(t){this.cameraEntity.copy(t.entity),this.cameraEntity.name="PickerCamera";const r=this.cameraEntity.camera;r.copy(t),r.clearColorBuffer=!0,r.clearDepthBuffer=!0,r.clearStencilBuffer=!0,r.clearColor=e.WHITE,r.renderTarget=this.renderTarget,this.layer.clearCameras(),this.layer.addCamera(r),r.layers=[this.layer.id]}resize(e,t){this.width=Math.floor(e),this.height=Math.floor(t)}}export{C as Picker};
