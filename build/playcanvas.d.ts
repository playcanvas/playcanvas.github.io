/**
 * Logs a frame number.
 *
 * @type {string}
 */
declare const TRACEID_RENDER_FRAME: string;
/**
 * Logs basic information about generated render passes.
 *
 * @type {string}
 */
declare const TRACEID_RENDER_PASS: string;
/**
 * Logs additional detail for render passes.
 *
 * @type {string}
 */
declare const TRACEID_RENDER_PASS_DETAIL: string;
/**
 * Logs render actions created by the layer composition. Only executes when the
 * layer composition changes.
 *
 * @type {string}
 */
declare const TRACEID_RENDER_ACTION: string;
/**
 * Logs the allocation of render targets.
 *
 * @type {string}
 */
declare const TRACEID_RENDER_TARGET_ALLOC: string;
/**
 * Logs the allocation of textures.
 *
 * @type {string}
 */
declare const TRACEID_TEXTURE_ALLOC: string;
/**
 * Logs the creation of shaders.
 *
 * @type {string}
 */
declare const TRACEID_SHADER_ALLOC: string;

/**
 * A linear interpolation scheme.
 *
 * @type {number}
 */
declare const CURVE_LINEAR: number;
/**
 * A smooth step interpolation scheme.
 *
 * @type {number}
 */
declare const CURVE_SMOOTHSTEP: number;
/**
 * A Catmull-Rom spline interpolation scheme. This interpolation scheme is deprecated. Use
 * CURVE_SPLINE instead.
 *
 * @type {number}
 * @deprecated
 * @ignore
 */
declare const CURVE_CATMULL: number;
/**
 * A cardinal spline interpolation scheme. This interpolation scheme is deprecated. Use
 * CURVE_SPLINE instead.
 *
 * @type {number}
 * @deprecated
 * @ignore
 */
declare const CURVE_CARDINAL: number;
/**
 * Cardinal spline interpolation scheme. For Catmull-Rom, specify curve tension 0.5.
 *
 * @type {number}
 */
declare const CURVE_SPLINE: number;
/**
 * A stepped interpolator, free from the shackles of blending.
 *
 * @type {number}
 */
declare const CURVE_STEP: number;

/**
 * Ignores the integer part of texture coordinates, using only the fractional part.
 *
 * @type {number}
 */
declare const ADDRESS_REPEAT: number;
/**
 * Clamps texture coordinate to the range 0 to 1.
 *
 * @type {number}
 */
declare const ADDRESS_CLAMP_TO_EDGE: number;
/**
 * Texture coordinate to be set to the fractional part if the integer part is even. If the integer
 * part is odd, then the texture coordinate is set to 1 minus the fractional part.
 *
 * @type {number}
 */
declare const ADDRESS_MIRRORED_REPEAT: number;
/**
 * Multiply all fragment components by zero.
 *
 * @type {number}
 */
declare const BLENDMODE_ZERO: number;
/**
 * Multiply all fragment components by one.
 *
 * @type {number}
 */
declare const BLENDMODE_ONE: number;
/**
 * Multiply all fragment components by the components of the source fragment.
 *
 * @type {number}
 */
declare const BLENDMODE_SRC_COLOR: number;
/**
 * Multiply all fragment components by one minus the components of the source fragment.
 *
 * @type {number}
 */
declare const BLENDMODE_ONE_MINUS_SRC_COLOR: number;
/**
 * Multiply all fragment components by the components of the destination fragment.
 *
 * @type {number}
 */
declare const BLENDMODE_DST_COLOR: number;
/**
 * Multiply all fragment components by one minus the components of the destination fragment.
 *
 * @type {number}
 */
declare const BLENDMODE_ONE_MINUS_DST_COLOR: number;
/**
 * Multiply all fragment components by the alpha value of the source fragment.
 *
 * @type {number}
 */
declare const BLENDMODE_SRC_ALPHA: number;
/**
 * Multiply all fragment components by the alpha value of the source fragment.
 *
 * @type {number}
 */
declare const BLENDMODE_SRC_ALPHA_SATURATE: number;
/**
 * Multiply all fragment components by one minus the alpha value of the source fragment.
 *
 * @type {number}
 */
declare const BLENDMODE_ONE_MINUS_SRC_ALPHA: number;
/**
 * Multiply all fragment components by the alpha value of the destination fragment.
 *
 * @type {number}
 */
declare const BLENDMODE_DST_ALPHA: number;
/**
 * Multiply all fragment components by one minus the alpha value of the destination fragment.
 *
 * @type {number}
 */
declare const BLENDMODE_ONE_MINUS_DST_ALPHA: number;
/**
 * Multiplies all colors by a constant color.
 *
 * @type {number}
 */
declare const BLENDMODE_CONSTANT_COLOR: number;
/**
 * Multiplies all colors by 1 minus a constant color.
 *
 * @type {number}
 */
declare const BLENDMODE_ONE_MINUS_CONSTANT_COLOR: number;
/**
 * Multiplies all colors by a constant alpha value.
 *
 * @type {number}
 */
declare const BLENDMODE_CONSTANT_ALPHA: number;
/**
 * Multiplies all colors by 1 minus a constant alpha value.
 *
 * @type {number}
 */
declare const BLENDMODE_ONE_MINUS_CONSTANT_ALPHA: number;
/**
 * Add the results of the source and destination fragment multiplies.
 *
 * @type {number}
 */
declare const BLENDEQUATION_ADD: number;
/**
 * Subtract the results of the source and destination fragment multiplies.
 *
 * @type {number}
 */
declare const BLENDEQUATION_SUBTRACT: number;
/**
 * Reverse and subtract the results of the source and destination fragment multiplies.
 *
 * @type {number}
 */
declare const BLENDEQUATION_REVERSE_SUBTRACT: number;
/**
 * Use the smallest value. Check app.graphicsDevice.extBlendMinmax for support.
 *
 * @type {number}
 */
declare const BLENDEQUATION_MIN: number;
/**
 * Use the largest value. Check app.graphicsDevice.extBlendMinmax for support.
 *
 * @type {number}
 */
declare const BLENDEQUATION_MAX: number;
/**
 * The data store contents will be modified once and used many times.
 *
 * @type {number}
 */
declare const BUFFER_STATIC: number;
/**
 * The data store contents will be modified repeatedly and used many times.
 *
 * @type {number}
 */
declare const BUFFER_DYNAMIC: number;
/**
 * The data store contents will be modified once and used at most a few times.
 *
 * @type {number}
 */
declare const BUFFER_STREAM: number;
/**
 * The data store contents will be modified repeatedly on the GPU and used many times. Optimal for
 * transform feedback usage (WebGL2 only).
 *
 * @type {number}
 */
declare const BUFFER_GPUDYNAMIC: number;
/**
 * Clear the color buffer.
 *
 * @type {number}
 */
declare const CLEARFLAG_COLOR: number;
/**
 * Clear the depth buffer.
 *
 * @type {number}
 */
declare const CLEARFLAG_DEPTH: number;
/**
 * Clear the stencil buffer.
 *
 * @type {number}
 */
declare const CLEARFLAG_STENCIL: number;
/**
 * The positive X face of a cubemap.
 *
 * @type {number}
 */
declare const CUBEFACE_POSX: number;
/**
 * The negative X face of a cubemap.
 *
 * @type {number}
 */
declare const CUBEFACE_NEGX: number;
/**
 * The positive Y face of a cubemap.
 *
 * @type {number}
 */
declare const CUBEFACE_POSY: number;
/**
 * The negative Y face of a cubemap.
 *
 * @type {number}
 */
declare const CUBEFACE_NEGY: number;
/**
 * The positive Z face of a cubemap.
 *
 * @type {number}
 */
declare const CUBEFACE_POSZ: number;
/**
 * The negative Z face of a cubemap.
 *
 * @type {number}
 */
declare const CUBEFACE_NEGZ: number;
/**
 * No triangles are culled.
 *
 * @type {number}
 */
declare const CULLFACE_NONE: number;
/**
 * Triangles facing away from the view direction are culled.
 *
 * @type {number}
 */
declare const CULLFACE_BACK: number;
/**
 * Triangles facing the view direction are culled.
 *
 * @type {number}
 */
declare const CULLFACE_FRONT: number;
/**
 * Triangles are culled regardless of their orientation with respect to the view direction. Note
 * that point or line primitives are unaffected by this render state.
 *
 * @type {number}
 */
declare const CULLFACE_FRONTANDBACK: number;
/**
 * Point sample filtering.
 *
 * @type {number}
 */
declare const FILTER_NEAREST: number;
/**
 * Bilinear filtering.
 *
 * @type {number}
 */
declare const FILTER_LINEAR: number;
/**
 * Use the nearest neighbor in the nearest mipmap level.
 *
 * @type {number}
 */
declare const FILTER_NEAREST_MIPMAP_NEAREST: number;
/**
 * Linearly interpolate in the nearest mipmap level.
 *
 * @type {number}
 */
declare const FILTER_NEAREST_MIPMAP_LINEAR: number;
/**
 * Use the nearest neighbor after linearly interpolating between mipmap levels.
 *
 * @type {number}
 */
declare const FILTER_LINEAR_MIPMAP_NEAREST: number;
/**
 * Linearly interpolate both the mipmap levels and between texels.
 *
 * @type {number}
 */
declare const FILTER_LINEAR_MIPMAP_LINEAR: number;
/**
 * Never pass.
 *
 * @type {number}
 */
declare const FUNC_NEVER: number;
/**
 * Pass if (ref & mask) < (stencil & mask).
 *
 * @type {number}
 */
declare const FUNC_LESS: number;
/**
 * Pass if (ref & mask) == (stencil & mask).
 *
 * @type {number}
 */
declare const FUNC_EQUAL: number;
/**
 * Pass if (ref & mask) <= (stencil & mask).
 *
 * @type {number}
 */
declare const FUNC_LESSEQUAL: number;
/**
 * Pass if (ref & mask) > (stencil & mask).
 *
 * @type {number}
 */
declare const FUNC_GREATER: number;
/**
 * Pass if (ref & mask) != (stencil & mask).
 *
 * @type {number}
 */
declare const FUNC_NOTEQUAL: number;
/**
 * Pass if (ref & mask) >= (stencil & mask).
 *
 * @type {number}
 */
declare const FUNC_GREATEREQUAL: number;
/**
 * Always pass.
 *
 * @type {number}
 */
declare const FUNC_ALWAYS: number;
/**
 * 8-bit unsigned vertex indices (0 to 255).
 *
 * @type {number}
 */
declare const INDEXFORMAT_UINT8: number;
/**
 * 16-bit unsigned vertex indices (0 to 65,535).
 *
 * @type {number}
 */
declare const INDEXFORMAT_UINT16: number;
/**
 * 32-bit unsigned vertex indices (0 to 4,294,967,295).
 *
 * @type {number}
 */
declare const INDEXFORMAT_UINT32: number;
/**
 * 8-bit alpha.
 *
 * @type {number}
 */
declare const PIXELFORMAT_A8: number;
/**
 * 8-bit luminance.
 *
 * @type {number}
 */
declare const PIXELFORMAT_L8: number;
/**
 * 8-bit luminance with 8-bit alpha.
 *
 * @type {number}
 */
declare const PIXELFORMAT_L8_A8: number;
/**
 * 16-bit RGB (5-bits for red channel, 6 for green and 5 for blue).
 *
 * @type {number}
 */
declare const PIXELFORMAT_R5_G6_B5: number;
/**
 * 16-bit RGBA (5-bits for red channel, 5 for green, 5 for blue with 1-bit alpha).
 *
 * @type {number}
 */
declare const PIXELFORMAT_R5_G5_B5_A1: number;
/**
 * 16-bit RGBA (4-bits for red channel, 4 for green, 4 for blue with 4-bit alpha).
 *
 * @type {number}
 */
declare const PIXELFORMAT_R4_G4_B4_A4: number;
/**
 * 24-bit RGB (8-bits for red channel, 8 for green and 8 for blue).
 *
 * @type {number}
 */
declare const PIXELFORMAT_R8_G8_B8: number;
/**
 * 32-bit RGBA (8-bits for red channel, 8 for green, 8 for blue with 8-bit alpha).
 *
 * @type {number}
 */
declare const PIXELFORMAT_R8_G8_B8_A8: number;
/**
 * Block compressed format storing 16 input pixels in 64 bits of output, consisting of two 16-bit
 * RGB 5:6:5 color values and a 4x4 two bit lookup table.
 *
 * @type {number}
 */
declare const PIXELFORMAT_DXT1: number;
/**
 * Block compressed format storing 16 input pixels (corresponding to a 4x4 pixel block) into 128
 * bits of output, consisting of 64 bits of alpha channel data (4 bits for each pixel) followed by
 * 64 bits of color data; encoded the same way as DXT1.
 *
 * @type {number}
 */
declare const PIXELFORMAT_DXT3: number;
/**
 * Block compressed format storing 16 input pixels into 128 bits of output, consisting of 64 bits
 * of alpha channel data (two 8 bit alpha values and a 4x4 3 bit lookup table) followed by 64 bits
 * of color data (encoded the same way as DXT1).
 *
 * @type {number}
 */
declare const PIXELFORMAT_DXT5: number;
/**
 * 16-bit floating point RGB (16-bit float for each red, green and blue channels).
 *
 * @type {number}
 */
declare const PIXELFORMAT_RGB16F: number;
/**
 * 16-bit floating point RGBA (16-bit float for each red, green, blue and alpha channels).
 *
 * @type {number}
 */
declare const PIXELFORMAT_RGBA16F: number;
/**
 * 32-bit floating point RGB (32-bit float for each red, green and blue channels).
 *
 * @type {number}
 */
declare const PIXELFORMAT_RGB32F: number;
/**
 * 32-bit floating point RGBA (32-bit float for each red, green, blue and alpha channels).
 *
 * @type {number}
 */
declare const PIXELFORMAT_RGBA32F: number;
/**
 * 32-bit floating point single channel format (WebGL2 only).
 *
 * @type {number}
 */
declare const PIXELFORMAT_R32F: number;
/**
 * A readable depth buffer format.
 *
 * @type {number}
 */
declare const PIXELFORMAT_DEPTH: number;
/**
 * A readable depth/stencil buffer format (WebGL2 only).
 *
 * @type {number}
 */
declare const PIXELFORMAT_DEPTHSTENCIL: number;
/**
 * A floating-point color-only format with 11 bits for red and green channels and 10 bits for the
 * blue channel (WebGL2 only).
 *
 * @type {number}
 */
declare const PIXELFORMAT_111110F: number;
/**
 * Color-only sRGB format (WebGL2 only).
 *
 * @type {number}
 */
declare const PIXELFORMAT_SRGB: number;
/**
 * Color sRGB format with additional alpha channel (WebGL2 only).
 *
 * @type {number}
 */
declare const PIXELFORMAT_SRGBA: number;
/**
 * ETC1 compressed format.
 *
 * @type {number}
 */
declare const PIXELFORMAT_ETC1: number;
/**
 * ETC2 (RGB) compressed format.
 *
 * @type {number}
 */
declare const PIXELFORMAT_ETC2_RGB: number;
/**
 * ETC2 (RGBA) compressed format.
 *
 * @type {number}
 */
declare const PIXELFORMAT_ETC2_RGBA: number;
/**
 * PVRTC (2BPP RGB) compressed format.
 *
 * @type {number}
 */
declare const PIXELFORMAT_PVRTC_2BPP_RGB_1: number;
/**
 * PVRTC (2BPP RGBA) compressed format.
 *
 * @type {number}
 */
declare const PIXELFORMAT_PVRTC_2BPP_RGBA_1: number;
/**
 * PVRTC (4BPP RGB) compressed format.
 *
 * @type {number}
 */
declare const PIXELFORMAT_PVRTC_4BPP_RGB_1: number;
/**
 * PVRTC (4BPP RGBA) compressed format.
 *
 * @type {number}
 */
declare const PIXELFORMAT_PVRTC_4BPP_RGBA_1: number;
/**
 * ATC compressed format with alpha channel in blocks of 4x4.
 *
 * @type {number}
 */
declare const PIXELFORMAT_ASTC_4x4: number;
/**
 * ATC compressed format with no alpha channel.
 *
 * @type {number}
 */
declare const PIXELFORMAT_ATC_RGB: number;
/**
 * ATC compressed format with alpha channel.
 *
 * @type {number}
 */
declare const PIXELFORMAT_ATC_RGBA: number;
/**
 * List of distinct points.
 *
 * @type {number}
 */
declare const PRIMITIVE_POINTS: number;
/**
 * Discrete list of line segments.
 *
 * @type {number}
 */
declare const PRIMITIVE_LINES: number;
/**
 * List of points that are linked sequentially by line segments, with a closing line segment
 * between the last and first points.
 *
 * @type {number}
 */
declare const PRIMITIVE_LINELOOP: number;
/**
 * List of points that are linked sequentially by line segments.
 *
 * @type {number}
 */
declare const PRIMITIVE_LINESTRIP: number;
/**
 * Discrete list of triangles.
 *
 * @type {number}
 */
declare const PRIMITIVE_TRIANGLES: number;
/**
 * Connected strip of triangles where a specified vertex forms a triangle using the previous two.
 *
 * @type {number}
 */
declare const PRIMITIVE_TRISTRIP: number;
/**
 * Connected fan of triangles where the first vertex forms triangles with the following pairs of vertices.
 *
 * @type {number}
 */
declare const PRIMITIVE_TRIFAN: number;
/**
 * Vertex attribute to be treated as a position.
 *
 * @type {string}
 */
declare const SEMANTIC_POSITION: string;
/**
 * Vertex attribute to be treated as a normal.
 *
 * @type {string}
 */
declare const SEMANTIC_NORMAL: string;
/**
 * Vertex attribute to be treated as a tangent.
 *
 * @type {string}
 */
declare const SEMANTIC_TANGENT: string;
/**
 * Vertex attribute to be treated as skin blend weights.
 *
 * @type {string}
 */
declare const SEMANTIC_BLENDWEIGHT: string;
/**
 * Vertex attribute to be treated as skin blend indices.
 *
 * @type {string}
 */
declare const SEMANTIC_BLENDINDICES: string;
/**
 * Vertex attribute to be treated as a color.
 *
 * @type {string}
 */
declare const SEMANTIC_COLOR: string;
declare const SEMANTIC_TEXCOORD: "TEXCOORD";
/**
 * Vertex attribute to be treated as a texture coordinate (set 0).
 *
 * @type {string}
 */
declare const SEMANTIC_TEXCOORD0: string;
/**
 * Vertex attribute to be treated as a texture coordinate (set 1).
 *
 * @type {string}
 */
declare const SEMANTIC_TEXCOORD1: string;
/**
 * Vertex attribute to be treated as a texture coordinate (set 2).
 *
 * @type {string}
 */
declare const SEMANTIC_TEXCOORD2: string;
/**
 * Vertex attribute to be treated as a texture coordinate (set 3).
 *
 * @type {string}
 */
declare const SEMANTIC_TEXCOORD3: string;
/**
 * Vertex attribute to be treated as a texture coordinate (set 4).
 *
 * @type {string}
 */
declare const SEMANTIC_TEXCOORD4: string;
/**
 * Vertex attribute to be treated as a texture coordinate (set 5).
 *
 * @type {string}
 */
declare const SEMANTIC_TEXCOORD5: string;
/**
 * Vertex attribute to be treated as a texture coordinate (set 6).
 *
 * @type {string}
 */
declare const SEMANTIC_TEXCOORD6: string;
/**
 * Vertex attribute to be treated as a texture coordinate (set 7).
 *
 * @type {string}
 */
declare const SEMANTIC_TEXCOORD7: string;
declare const SEMANTIC_ATTR: "ATTR";
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 */
declare const SEMANTIC_ATTR0: string;
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 */
declare const SEMANTIC_ATTR1: string;
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 */
declare const SEMANTIC_ATTR2: string;
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 */
declare const SEMANTIC_ATTR3: string;
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 */
declare const SEMANTIC_ATTR4: string;
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 */
declare const SEMANTIC_ATTR5: string;
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 */
declare const SEMANTIC_ATTR6: string;
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 */
declare const SEMANTIC_ATTR7: string;
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 */
declare const SEMANTIC_ATTR8: string;
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 */
declare const SEMANTIC_ATTR9: string;
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 */
declare const SEMANTIC_ATTR10: string;
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 */
declare const SEMANTIC_ATTR11: string;
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 */
declare const SEMANTIC_ATTR12: string;
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 */
declare const SEMANTIC_ATTR13: string;
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 */
declare const SEMANTIC_ATTR14: string;
/**
 * Vertex attribute with a user defined semantic.
 *
 * @type {string}
 */
declare const SEMANTIC_ATTR15: string;
declare const SHADERTAG_MATERIAL: 1;
/**
 * Don't change the stencil buffer value.
 *
 * @type {number}
 */
declare const STENCILOP_KEEP: number;
/**
 * Set value to zero.
 *
 * @type {number}
 */
declare const STENCILOP_ZERO: number;
/**
 * Replace value with the reference value (see {@link GraphicsDevice#setStencilFunc}).
 *
 * @type {number}
 */
declare const STENCILOP_REPLACE: number;
/**
 * Increment the value.
 *
 * @type {number}
 */
declare const STENCILOP_INCREMENT: number;
/**
 * Increment the value but wrap it to zero when it's larger than a maximum representable value.
 *
 * @type {number}
 */
declare const STENCILOP_INCREMENTWRAP: number;
/**
 * Decrement the value.
 *
 * @type {number}
 */
declare const STENCILOP_DECREMENT: number;
/**
 * Decrement the value but wrap it to a maximum representable value if the current value is 0.
 *
 * @type {number}
 */
declare const STENCILOP_DECREMENTWRAP: number;
/**
 * Invert the value bitwise.
 *
 * @type {number}
 */
declare const STENCILOP_INVERT: number;
/**
 * Read only. Any changes to the locked mip level's pixels will not update the texture.
 *
 * @type {number}
 */
declare const TEXTURELOCK_READ: number;
/**
 * Write only. The contents of the specified mip level will be entirely replaced.
 *
 * @type {number}
 */
declare const TEXTURELOCK_WRITE: number;
/**
 * Texture is a default type.
 *
 * @type {string}
 */
declare const TEXTURETYPE_DEFAULT: string;
/**
 * Texture stores high dynamic range data in RGBM format.
 *
 * @type {string}
 */
declare const TEXTURETYPE_RGBM: string;
/**
 * Texture stores high dynamic range data in RGBE format.
 *
 * @type {string}
 */
declare const TEXTURETYPE_RGBE: string;
/**
 * Texture stores normalmap data swizzled in GGGR format. This is used for tangent space normal
 * maps. The R component is stored in alpha and G is stored in RGB. This packing can result in
 * higher quality when the texture data is compressed.
 *
 * @type {string}
 */
declare const TEXTURETYPE_SWIZZLEGGGR: string;
declare const TEXHINT_NONE: 0;
declare const TEXHINT_SHADOWMAP: 1;
declare const TEXHINT_ASSET: 2;
declare const TEXHINT_LIGHTMAP: 3;
/**
 * Texture data is not stored a specific projection format.
 *
 * @type {string}
 */
declare const TEXTUREPROJECTION_NONE: string;
/**
 * Texture data is stored in cubemap projection format.
 *
 * @type {string}
 */
declare const TEXTUREPROJECTION_CUBE: string;
/**
 * Texture data is stored in equirectangular projection format.
 *
 * @type {string}
 */
declare const TEXTUREPROJECTION_EQUIRECT: string;
/**
 * Texture data is stored in octahedral projection format.
 *
 * @type {string}
 */
declare const TEXTUREPROJECTION_OCTAHEDRAL: string;
/**
 * Signed byte vertex element type.
 *
 * @type {number}
 */
declare const TYPE_INT8: number;
/**
 * Unsigned byte vertex element type.
 *
 * @type {number}
 */
declare const TYPE_UINT8: number;
/**
 * Signed short vertex element type.
 *
 * @type {number}
 */
declare const TYPE_INT16: number;
/**
 * Unsigned short vertex element type.
 *
 * @type {number}
 */
declare const TYPE_UINT16: number;
/**
 * Signed integer vertex element type.
 *
 * @type {number}
 */
declare const TYPE_INT32: number;
/**
 * Unsigned integer vertex element type.
 *
 * @type {number}
 */
declare const TYPE_UINT32: number;
/**
 * Floating point vertex element type.
 *
 * @type {number}
 */
declare const TYPE_FLOAT32: number;
declare const UNIFORMTYPE_BOOL: 0;
declare const UNIFORMTYPE_INT: 1;
declare const UNIFORMTYPE_FLOAT: 2;
declare const UNIFORMTYPE_VEC2: 3;
declare const UNIFORMTYPE_VEC3: 4;
declare const UNIFORMTYPE_VEC4: 5;
declare const UNIFORMTYPE_IVEC2: 6;
declare const UNIFORMTYPE_IVEC3: 7;
declare const UNIFORMTYPE_IVEC4: 8;
declare const UNIFORMTYPE_BVEC2: 9;
declare const UNIFORMTYPE_BVEC3: 10;
declare const UNIFORMTYPE_BVEC4: 11;
declare const UNIFORMTYPE_MAT2: 12;
declare const UNIFORMTYPE_MAT3: 13;
declare const UNIFORMTYPE_MAT4: 14;
declare const UNIFORMTYPE_TEXTURE2D: 15;
declare const UNIFORMTYPE_TEXTURECUBE: 16;
declare const UNIFORMTYPE_FLOATARRAY: 17;
declare const UNIFORMTYPE_TEXTURE2D_SHADOW: 18;
declare const UNIFORMTYPE_TEXTURECUBE_SHADOW: 19;
declare const UNIFORMTYPE_TEXTURE3D: 20;
declare const UNIFORMTYPE_VEC2ARRAY: 21;
declare const UNIFORMTYPE_VEC3ARRAY: 22;
declare const UNIFORMTYPE_VEC4ARRAY: 23;
declare const uniformTypeToName: string[];
declare const SHADERSTAGE_VERTEX: 1;
declare const SHADERSTAGE_FRAGMENT: 2;
declare const SHADERSTAGE_COMPUTE: 4;
declare const BINDGROUP_VIEW: 0;
declare const BINDGROUP_MESH: 1;
declare const bindGroupNames: string[];
declare const typedArrayTypes: (Int8ArrayConstructor | Uint8ArrayConstructor | Int16ArrayConstructor | Uint16ArrayConstructor | Int32ArrayConstructor | Uint32ArrayConstructor | Float32ArrayConstructor)[];
declare const typedArrayTypesByteSize: number[];
declare namespace typedArrayToType {
    export { TYPE_INT8 as Int8Array };
    export { TYPE_UINT8 as Uint8Array };
    export { TYPE_INT16 as Int16Array };
    export { TYPE_UINT16 as Uint16Array };
    export { TYPE_INT32 as Int32Array };
    export { TYPE_UINT32 as Uint32Array };
    export { TYPE_FLOAT32 as Float32Array };
}
declare const typedArrayIndexFormats: (Uint8ArrayConstructor | Uint16ArrayConstructor | Uint32ArrayConstructor)[];
declare const typedArrayIndexFormatsByteSize: number[];
/**
 * Map of engine semantics into location on device in range 0..15 (note - semantics mapping to the
 * same location cannot be used at the same time) organized in a way that ATTR0-ATTR7 do not
 * overlap with common important semantics.
 *
 * @type {object}
 * @ignore
 */
declare const semanticToLocation: object;
/**
 * Chunk API versions
 *
 * @type {string}
 */
declare const CHUNKAPI_1_51: string;
declare const CHUNKAPI_1_55: "1.55";

/**
 * Subtract the color of the source fragment from the destination fragment and write the result to
 * the frame buffer.
 *
 * @type {number}
 */
declare const BLEND_SUBTRACTIVE: number;
/**
 * Add the color of the source fragment to the destination fragment and write the result to the
 * frame buffer.
 *
 * @type {number}
 */
declare const BLEND_ADDITIVE: number;
/**
 * Enable simple translucency for materials such as glass. This is equivalent to enabling a source
 * blend mode of {@link BLENDMODE_SRC_ALPHA} and a destination blend mode of
 * {@link BLENDMODE_ONE_MINUS_SRC_ALPHA}.
 *
 * @type {number}
 */
declare const BLEND_NORMAL: number;
/**
 * Disable blending.
 *
 * @type {number}
 */
declare const BLEND_NONE: number;
/**
 * Similar to {@link BLEND_NORMAL} expect the source fragment is assumed to have already been
 * multiplied by the source alpha value.
 *
 * @type {number}
 */
declare const BLEND_PREMULTIPLIED: number;
/**
 * Multiply the color of the source fragment by the color of the destination fragment and write the
 * result to the frame buffer.
 *
 * @type {number}
 */
declare const BLEND_MULTIPLICATIVE: number;
/**
 * Same as {@link BLEND_ADDITIVE} except the source RGB is multiplied by the source alpha.
 *
 * @type {number}
 */
declare const BLEND_ADDITIVEALPHA: number;
/**
 * Multiplies colors and doubles the result.
 *
 * @type {number}
 */
declare const BLEND_MULTIPLICATIVE2X: number;
/**
 * Softer version of additive.
 *
 * @type {number}
 */
declare const BLEND_SCREEN: number;
/**
 * Minimum color. Check app.graphicsDevice.extBlendMinmax for support.
 *
 * @type {number}
 */
declare const BLEND_MIN: number;
/**
 * Maximum color. Check app.graphicsDevice.extBlendMinmax for support.
 *
 * @type {number}
 */
declare const BLEND_MAX: number;
/**
 * No fog is applied to the scene.
 *
 * @type {string}
 */
declare const FOG_NONE: string;
/**
 * Fog rises linearly from zero to 1 between a start and end depth.
 *
 * @type {string}
 */
declare const FOG_LINEAR: string;
/**
 * Fog rises according to an exponential curve controlled by a density value.
 *
 * @type {string}
 */
declare const FOG_EXP: string;
/**
 * Fog rises according to an exponential curve controlled by a density value.
 *
 * @type {string}
 */
declare const FOG_EXP2: string;
/**
 * No Fresnel.
 *
 * @type {number}
 */
declare const FRESNEL_NONE: number;
/**
 * Schlick's approximation of Fresnel.
 *
 * @type {number}
 */
declare const FRESNEL_SCHLICK: number;
declare const LAYER_HUD: 0;
declare const LAYER_GIZMO: 1;
declare const LAYER_FX: 2;
declare const LAYER_WORLD: 15;
/**
 * The world layer.
 *
 * @type {number}
 */
declare const LAYERID_WORLD: number;
/**
 * The depth layer.
 *
 * @type {number}
 */
declare const LAYERID_DEPTH: number;
/**
 * The skybox layer.
 *
 * @type {number}
 */
declare const LAYERID_SKYBOX: number;
/**
 * The immediate layer.
 *
 * @type {number}
 */
declare const LAYERID_IMMEDIATE: number;
/**
 * The UI layer.
 *
 * @type {number}
 */
declare const LAYERID_UI: number;
/**
 * Directional (global) light source.
 *
 * @type {number}
 */
declare const LIGHTTYPE_DIRECTIONAL: number;
/**
 * Omni-directional (local) light source.
 *
 * @type {number}
 */
declare const LIGHTTYPE_OMNI: number;
/**
 * Point (local) light source.
 *
 * @type {number}
 * @ignore
 */
declare const LIGHTTYPE_POINT: number;
/**
 * Spot (local) light source.
 *
 * @type {number}
 */
declare const LIGHTTYPE_SPOT: number;
declare const LIGHTTYPE_COUNT: 3;
/**
 * Infinitesimally small point light source shape.
 *
 * @type {number}
 */
declare const LIGHTSHAPE_PUNCTUAL: number;
/**
 * Rectangle shape of light source.
 *
 * @type {number}
 */
declare const LIGHTSHAPE_RECT: number;
/**
 * Disk shape of light source.
 *
 * @type {number}
 */
declare const LIGHTSHAPE_DISK: number;
/**
 * Sphere shape of light source.
 *
 * @type {number}
 */
declare const LIGHTSHAPE_SPHERE: number;
/**
 * Linear distance falloff model for light attenuation.
 *
 * @type {number}
 */
declare const LIGHTFALLOFF_LINEAR: number;
/**
 * Inverse squared distance falloff model for light attenuation.
 *
 * @type {number}
 */
declare const LIGHTFALLOFF_INVERSESQUARED: number;
/**
 * Render depth (color-packed on WebGL 1.0), can be used for PCF 3x3 sampling.
 *
 * @type {number}
 */
declare const SHADOW_PCF3: number;
declare const SHADOW_DEPTH: 0;
/**
 * Render packed variance shadow map. All shadow receivers must also cast shadows for this mode to
 * work correctly.
 *
 * @type {number}
 */
declare const SHADOW_VSM8: number;
/**
 * Render 16-bit exponential variance shadow map. Requires OES_texture_half_float extension. Falls
 * back to {@link SHADOW_VSM8}, if not supported.
 *
 * @type {number}
 */
declare const SHADOW_VSM16: number;
/**
 * Render 32-bit exponential variance shadow map. Requires OES_texture_float extension. Falls back
 * to {@link SHADOW_VSM16}, if not supported.
 *
 * @type {number}
 */
declare const SHADOW_VSM32: number;
/**
 * Render depth buffer only, can be used for hardware-accelerated PCF 5x5 sampling. Requires
 * WebGL 2. Falls back to {@link SHADOW_PCF3} on WebGL 1.
 *
 * @type {number}
 */
declare const SHADOW_PCF5: number;
/**
 * Render depth (color-packed on WebGL 1.0), can be used for PCF 1x1 sampling.
 *
 * @type {number}
 */
declare const SHADOW_PCF1: number;
declare const SHADOW_COUNT: 6;
/**
 * map of engine SHADOW__*** to a string representation
 *
 * @type {object}
 * @ignore
 */
declare const shadowTypeToString: object;
/**
 * Box filter.
 *
 * @type {number}
 */
declare const BLUR_BOX: number;
/**
 * Gaussian filter. May look smoother than box, but requires more samples.
 *
 * @type {number}
 */
declare const BLUR_GAUSSIAN: number;
/**
 * No sorting, particles are drawn in arbitrary order. Can be simulated on GPU.
 *
 * @type {number}
 */
declare const PARTICLESORT_NONE: number;
/**
 * Sorting based on distance to the camera. CPU only.
 *
 * @type {number}
 */
declare const PARTICLESORT_DISTANCE: number;
/**
 * Newer particles are drawn first. CPU only.
 *
 * @type {number}
 */
declare const PARTICLESORT_NEWER_FIRST: number;
/**
 * Older particles are drawn first. CPU only.
 *
 * @type {number}
 */
declare const PARTICLESORT_OLDER_FIRST: number;
declare const PARTICLEMODE_GPU: 0;
declare const PARTICLEMODE_CPU: 1;
/**
 * Box shape parameterized by emitterExtents. Initial velocity is directed towards local Z axis.
 *
 * @type {number}
 */
declare const EMITTERSHAPE_BOX: number;
/**
 * Sphere shape parameterized by emitterRadius. Initial velocity is directed outwards from the
 * center.
 *
 * @type {number}
 */
declare const EMITTERSHAPE_SPHERE: number;
/**
 * Particles are facing camera.
 *
 * @type {number}
 */
declare const PARTICLEORIENTATION_SCREEN: number;
/**
 * User defines world space normal (particleNormal) to set planes orientation.
 *
 * @type {number}
 */
declare const PARTICLEORIENTATION_WORLD: number;
/**
 * Similar to previous, but the normal is affected by emitter(entity) transformation.
 *
 * @type {number}
 */
declare const PARTICLEORIENTATION_EMITTER: number;
/**
 * A perspective camera projection where the frustum shape is essentially pyramidal.
 *
 * @type {number}
 */
declare const PROJECTION_PERSPECTIVE: number;
/**
 * An orthographic camera projection where the frustum shape is essentially a cuboid.
 *
 * @type {number}
 */
declare const PROJECTION_ORTHOGRAPHIC: number;
/**
 * Render mesh instance as solid geometry.
 *
 * @type {number}
 */
declare const RENDERSTYLE_SOLID: number;
/**
 * Render mesh instance as wireframe.
 *
 * @type {number}
 */
declare const RENDERSTYLE_WIREFRAME: number;
/**
 * Render mesh instance as points.
 *
 * @type {number}
 */
declare const RENDERSTYLE_POINTS: number;
/**
 * The cube map is treated as if it is infinitely far away.
 *
 * @type {number}
 */
declare const CUBEPROJ_NONE: number;
/**
 * The cube map is box-projected based on a world space axis-aligned bounding box.
 *
 * @type {number}
 */
declare const CUBEPROJ_BOX: number;
/**
 * Phong without energy conservation. You should only use it as a backwards compatibility with
 * older projects.
 *
 * @type {number}
 */
declare const SPECULAR_PHONG: number;
/**
 * Energy-conserving Blinn-Phong.
 *
 * @type {number}
 */
declare const SPECULAR_BLINN: number;
/**
 * Multiply together the primary and secondary colors.
 *
 * @type {string}
 */
declare const DETAILMODE_MUL: string;
/**
 * Add together the primary and secondary colors.
 *
 * @type {string}
 */
declare const DETAILMODE_ADD: string;
/**
 * Softer version of {@link DETAILMODE_ADD}.
 *
 * @name DETAILMODE_SCREEN
 */
declare const DETAILMODE_SCREEN: "screen";
/**
 * Multiplies or screens the colors, depending on the primary color.
 *
 * @type {string}
 */
declare const DETAILMODE_OVERLAY: string;
/**
 * Select whichever of the primary and secondary colors is darker, component-wise.
 *
 * @type {string}
 */
declare const DETAILMODE_MIN: string;
/**
 * Select whichever of the primary and secondary colors is lighter, component-wise.
 *
 * @type {string}
 */
declare const DETAILMODE_MAX: string;
/**
 * No gamma correction.
 *
 * @type {number}
 */
declare const GAMMA_NONE: number;
/**
 * Apply sRGB gamma correction.
 *
 * @type {number}
 */
declare const GAMMA_SRGB: number;
/**
 * Apply sRGB (fast) gamma correction.
 *
 * @type {number}
 * @deprecated
 * @ignore
 */
declare const GAMMA_SRGBFAST: number;
/**
 * Apply sRGB (HDR) gamma correction.
 *
 * @type {number}
 */
declare const GAMMA_SRGBHDR: number;
/**
 * Linear tonemapping.
 *
 * @type {number}
 */
declare const TONEMAP_LINEAR: number;
/**
 * Filmic tonemapping curve.
 *
 * @type {number}
 */
declare const TONEMAP_FILMIC: number;
/**
 * Hejl filmic tonemapping curve.
 *
 * @type {number}
 */
declare const TONEMAP_HEJL: number;
/**
 * ACES filmic tonemapping curve.
 *
 * @type {number}
 */
declare const TONEMAP_ACES: number;
/**
 * ACES v2 filmic tonemapping curve.
 *
 * @type {number}
 */
declare const TONEMAP_ACES2: number;
/**
 * No specular occlusion.
 *
 * @type {number}
 */
declare const SPECOCC_NONE: number;
/**
 * Use AO directly to occlude specular.
 *
 * @type {number}
 */
declare const SPECOCC_AO: number;
/**
 * Modify AO based on material glossiness/view angle to occlude specular.
 *
 * @type {number}
 */
declare const SPECOCC_GLOSSDEPENDENT: number;
declare const SHADERDEF_NOSHADOW: 1;
declare const SHADERDEF_SKIN: 2;
declare const SHADERDEF_UV0: 4;
declare const SHADERDEF_UV1: 8;
declare const SHADERDEF_VCOLOR: 16;
declare const SHADERDEF_INSTANCING: 32;
declare const SHADERDEF_LM: 64;
declare const SHADERDEF_DIRLM: 128;
declare const SHADERDEF_SCREENSPACE: 256;
declare const SHADERDEF_TANGENTS: 512;
declare const SHADERDEF_MORPH_POSITION: 1024;
declare const SHADERDEF_MORPH_NORMAL: 2048;
declare const SHADERDEF_MORPH_TEXTURE_BASED: 4096;
declare const SHADERDEF_LMAMBIENT: 8192;
declare const LINEBATCH_WORLD: 0;
declare const LINEBATCH_OVERLAY: 1;
declare const LINEBATCH_GIZMO: 2;
/**
 * The shadow map is not to be updated.
 *
 * @type {number}
 */
declare const SHADOWUPDATE_NONE: number;
/**
 * The shadow map is regenerated this frame and not on subsequent frames.
 *
 * @type {number}
 */
declare const SHADOWUPDATE_THISFRAME: number;
/**
 * The shadow map is regenerated every frame.
 *
 * @type {number}
 */
declare const SHADOWUPDATE_REALTIME: number;
declare const SORTKEY_FORWARD: 0;
declare const SORTKEY_DEPTH: 1;
declare const MASK_AFFECT_DYNAMIC: 1;
declare const MASK_AFFECT_LIGHTMAPPED: 2;
declare const MASK_BAKE: 4;
/**
 * Render shaded materials with gamma correction and tonemapping.
 *
 * @type {number}
 */
declare const SHADER_FORWARD: number;
/**
 * Render shaded materials without gamma correction and tonemapping.
 *
 * @type {number}
 */
declare const SHADER_FORWARDHDR: number;
/**
 * Render RGBA-encoded depth value.
 *
 * @type {number}
 */
declare const SHADER_DEPTH: number;
declare const SHADER_PICK: 3;
declare const SHADER_SHADOW: 4;
/**
 * Shader that performs forward rendering.
 *
 * @type {string}
 */
declare const SHADERTYPE_FORWARD: string;
/**
 * Shader that performs depth rendering.
 *
 * @type {string}
 */
declare const SHADERTYPE_DEPTH: string;
/**
 * Shader used for picking.
 *
 * @type {string}
 */
declare const SHADERTYPE_PICK: string;
/**
 * Shader used for rendering shadow textures.
 *
 * @type {string}
 */
declare const SHADERTYPE_SHADOW: string;
/**
 * This mode renders a sprite as a simple quad.
 *
 * @type {number}
 */
declare const SPRITE_RENDERMODE_SIMPLE: number;
/**
 * This mode renders a sprite using 9-slicing in 'sliced' mode. Sliced mode stretches the top and
 * bottom regions of the sprite horizontally, the left and right regions vertically and the middle
 * region both horizontally and vertically.
 *
 * @type {number}
 */
declare const SPRITE_RENDERMODE_SLICED: number;
/**
 * This mode renders a sprite using 9-slicing in 'tiled' mode. Tiled mode tiles the top and bottom
 * regions of the sprite horizontally, the left and right regions vertically and the middle region
 * both horizontally and vertically.
 *
 * @type {number}
 */
declare const SPRITE_RENDERMODE_TILED: number;
/**
 * Single color lightmap.
 *
 * @type {number}
 */
declare const BAKE_COLOR: number;
/**
 * Single color lightmap + dominant light direction (used for bump/specular).
 *
 * @type {number}
 */
declare const BAKE_COLORDIR: number;
/**
 * Center of view.
 *
 * @type {number}
 */
declare const VIEW_CENTER: number;
/**
 * Left of view. Only used in stereo rendering.
 *
 * @type {number}
 */
declare const VIEW_LEFT: number;
/**
 * Right of view. Only used in stereo rendering.
 *
 * @type {number}
 */
declare const VIEW_RIGHT: number;
/**
 * No sorting is applied. Mesh instances are rendered in the same order they were added to a layer.
 *
 * @type {number}
 */
declare const SORTMODE_NONE: number;
/**
 * Mesh instances are sorted based on {@link MeshInstance#drawOrder}.
 *
 * @type {number}
 */
declare const SORTMODE_MANUAL: number;
/**
 * Mesh instances are sorted to minimize switching between materials and meshes to improve
 * rendering performance.
 *
 * @type {number}
 */
declare const SORTMODE_MATERIALMESH: number;
/**
 * Mesh instances are sorted back to front. This is the way to properly render many
 * semi-transparent objects on different depth, one is blended on top of another.
 *
 * @type {number}
 */
declare const SORTMODE_BACK2FRONT: number;
/**
 * Mesh instances are sorted front to back. Depending on GPU and the scene, this option may give
 * better performance than {@link SORTMODE_MATERIALMESH} due to reduced overdraw.
 *
 * @type {number}
 */
declare const SORTMODE_FRONT2BACK: number;
/**
 * Provide custom functions for sorting drawcalls and calculating distance.
 *
 * @type {number}
 * @ignore
 */
declare const SORTMODE_CUSTOM: number;
declare const COMPUPDATED_INSTANCES: 1;
declare const COMPUPDATED_LIGHTS: 2;
declare const COMPUPDATED_CAMERAS: 4;
declare const COMPUPDATED_BLEND: 8;
/**
 * Automatically set aspect ratio to current render target's width divided by height.
 *
 * @type {number}
 */
declare const ASPECT_AUTO: number;
/**
 * Use the manual aspect ratio value.
 *
 * @type {number}
 */
declare const ASPECT_MANUAL: number;
/**
 * Horizontal orientation.
 *
 * @type {number}
 */
declare const ORIENTATION_HORIZONTAL: number;
/**
 * Vertical orientation.
 *
 * @type {number}
 */
declare const ORIENTATION_VERTICAL: number;

/**
 * A stepped interpolation scheme.
 *
 * @type {number}
 * @ignore
 */
declare const INTERPOLATION_STEP: number;
/**
 * A linear interpolation scheme.
 *
 * @type {number}
 * @ignore
 */
declare const INTERPOLATION_LINEAR: number;
/**
 * A cubic spline interpolation scheme.
 *
 * @type {number}
 * @ignore
 */
declare const INTERPOLATION_CUBIC: number;

/**
 * Used to set the anim state graph transition interruption source to no state.
 *
 * @type {string}
 */
declare const ANIM_INTERRUPTION_NONE: string;
/**
 * Used to set the anim state graph transition interruption source as the previous state only.
 *
 * @type {string}
 */
declare const ANIM_INTERRUPTION_PREV: string;
/**
 * Used to set the anim state graph transition interruption source as the next state only.
 *
 * @type {string}
 */
declare const ANIM_INTERRUPTION_NEXT: string;
/**
 * Used to set the anim state graph transition interruption sources as the previous state followed
 * by the next state.
 *
 * @type {string}
 */
declare const ANIM_INTERRUPTION_PREV_NEXT: string;
/**
 * Used to set the anim state graph transition interruption sources as the next state followed by
 * the previous state.
 *
 * @type {string}
 */
declare const ANIM_INTERRUPTION_NEXT_PREV: string;
/**
 * Used to set an anim state graph transition condition predicate as '>'.
 *
 * @type {string}
 */
declare const ANIM_GREATER_THAN: string;
/**
 * Used to set an anim state graph transition condition predicate as '<'.
 *
 * @type {string}
 */
declare const ANIM_LESS_THAN: string;
/**
 * Used to set an anim state graph transition condition predicate as '>='.
 *
 * @type {string}
 */
declare const ANIM_GREATER_THAN_EQUAL_TO: string;
/**
 * Used to set an anim state graph transition condition predicate as '<='.
 *
 * @type {string}
 */
declare const ANIM_LESS_THAN_EQUAL_TO: string;
/**
 * Used to set an anim state graph transition condition predicate as '==='.
 *
 * @type {string}
 */
declare const ANIM_EQUAL_TO: string;
/**
 * Used to set an anim state graph transition condition predicate as '!=='.
 *
 * @type {string}
 */
declare const ANIM_NOT_EQUAL_TO: string;
/**
 * Used to set an anim state graph parameter as type integer.
 *
 * @type {string}
 */
declare const ANIM_PARAMETER_INTEGER: string;
/**
 * Used to set an anim state graph parameter as type float.
 *
 * @type {string}
 */
declare const ANIM_PARAMETER_FLOAT: string;
/**
 * Used to set an anim state graph parameter as type boolean.
 *
 * @type {string}
 */
declare const ANIM_PARAMETER_BOOLEAN: string;
/**
 * Used to set an anim state graph parameter as type trigger.
 *
 * @type {string}
 */
declare const ANIM_PARAMETER_TRIGGER: string;
/**
 * @type {string}
 */
declare const ANIM_BLEND_1D: string;
/**
 * @type {string}
 */
declare const ANIM_BLEND_2D_DIRECTIONAL: string;
/**
 * @type {string}
 */
declare const ANIM_BLEND_2D_CARTESIAN: string;
/**
 * @type {string}
 */
declare const ANIM_BLEND_DIRECT: string;
/**
 * The starting state in an anim state graph layer.
 *
 * @type {string}
 */
declare const ANIM_STATE_START: string;
/**
 * The ending state in an anim state graph layer.
 *
 * @type {string}
 */
declare const ANIM_STATE_END: string;
/**
 * Used to indicate any state in an anim state graph layer.
 *
 * @type {string}
 */
declare const ANIM_STATE_ANY: string;
declare const ANIM_CONTROL_STATES: string[];
/**
 * Used to indicate that a layers animations should overwrite all previous layers.
 *
 * @type {string}
 */
declare const ANIM_LAYER_OVERWRITE: string;
/**
 * Used to indicate that a layers animations should blend additively with previous layers.
 *
 * @type {string}
 */
declare const ANIM_LAYER_ADDITIVE: string;

declare const FONT_MSDF: "msdf";
declare const FONT_BITMAP: "bitmap";

/**
 * Linear distance model.
 *
 * @type {string}
 */
declare const DISTANCE_LINEAR: string;
/**
 * Inverse distance model.
 *
 * @type {string}
 */
declare const DISTANCE_INVERSE: string;
/**
 * Exponential distance model.
 *
 * @type {string}
 */
declare const DISTANCE_EXPONENTIAL: string;

declare const ABSOLUTE_URL: RegExp;
/**
 * Asset type name for animation.
 *
 * @type {string}
 */
declare const ASSET_ANIMATION: string;
/**
 * Asset type name for audio.
 *
 * @type {string}
 */
declare const ASSET_AUDIO: string;
/**
 * Asset type name for image.
 *
 * @type {string}
 */
declare const ASSET_IMAGE: string;
/**
 * Asset type name for json.
 *
 * @type {string}
 */
declare const ASSET_JSON: string;
/**
 * Asset type name for model.
 *
 * @type {string}
 */
declare const ASSET_MODEL: string;
/**
 * Asset type name for material.
 *
 * @type {string}
 */
declare const ASSET_MATERIAL: string;
/**
 * Asset type name for text.
 *
 * @type {string}
 */
declare const ASSET_TEXT: string;
/**
 * Asset type name for texture.
 *
 * @type {string}
 */
declare const ASSET_TEXTURE: string;
/**
 * Asset type name for cubemap.
 *
 * @type {string}
 */
declare const ASSET_CUBEMAP: string;
/**
 * Asset type name for shader.
 *
 * @type {string}
 */
declare const ASSET_SHADER: string;
/**
 * Asset type name for CSS.
 *
 * @type {string}
 */
declare const ASSET_CSS: string;
/**
 * Asset type name for HTML.
 *
 * @type {string}
 */
declare const ASSET_HTML: string;
/**
 * Asset type name for script.
 *
 * @type {string}
 */
declare const ASSET_SCRIPT: string;
/**
 * Asset type name for a container.
 *
 * @type {string}
 */
declare const ASSET_CONTAINER: string;

declare const ACTION_MOUSE: "mouse";
declare const ACTION_KEYBOARD: "keyboard";
declare const ACTION_GAMEPAD: "gamepad";
declare const AXIS_MOUSE_X: "mousex";
declare const AXIS_MOUSE_Y: "mousey";
declare const AXIS_PAD_L_X: "padlx";
declare const AXIS_PAD_L_Y: "padly";
declare const AXIS_PAD_R_X: "padrx";
declare const AXIS_PAD_R_Y: "padry";
declare const AXIS_KEY: "key";
/**
 * Name of event fired when a key is pressed.
 *
 * @type {string}
 */
declare const EVENT_KEYDOWN: string;
/**
 * Name of event fired when a key is released.
 *
 * @type {string}
 */
declare const EVENT_KEYUP: string;
/**
 * Name of event fired when a mouse button is pressed.
 *
 * @type {string}
 */
declare const EVENT_MOUSEDOWN: string;
/**
 * Name of event fired when the mouse is moved.
 *
 * @type {string}
 */
declare const EVENT_MOUSEMOVE: string;
/**
 * Name of event fired when a mouse button is released.
 *
 * @type {string}
 */
declare const EVENT_MOUSEUP: string;
/**
 * Name of event fired when the mouse wheel is rotated.
 *
 * @type {string}
 */
declare const EVENT_MOUSEWHEEL: string;
/**
 * Name of event fired when a new touch occurs. For example, a finger is placed on the device.
 *
 * @type {string}
 */
declare const EVENT_TOUCHSTART: string;
/**
 * Name of event fired when touch ends. For example, a finger is lifted off the device.
 *
 * @type {string}
 */
declare const EVENT_TOUCHEND: string;
/**
 * Name of event fired when a touch moves.
 *
 * @type {string}
 */
declare const EVENT_TOUCHMOVE: string;
/**
 * Name of event fired when a touch point is interrupted in some way. The exact reasons for
 * canceling a touch can vary from device to device. For example, a modal alert pops up during the
 * interaction; the touch point leaves the document area, or there are more touch points than the
 * device supports, in which case the earliest touch point is canceled.
 *
 * @type {string}
 */
declare const EVENT_TOUCHCANCEL: string;
/**
 * Name of event fired when a new xr select occurs. For example, primary trigger was pressed.
 *
 * @type {string}
 */
declare const EVENT_SELECT: string;
/**
 * Name of event fired when a new xr select starts. For example, primary trigger is now pressed.
 *
 * @type {string}
 */
declare const EVENT_SELECTSTART: string;
/**
 * Name of event fired when xr select ends. For example, a primary trigger is now released.
 *
 * @type {string}
 */
declare const EVENT_SELECTEND: string;
/**
 * @type {number}
 */
declare const KEY_BACKSPACE: number;
/**
 * @type {number}
 */
declare const KEY_TAB: number;
/**
 * @type {number}
 */
declare const KEY_RETURN: number;
/**
 * @type {number}
 */
declare const KEY_ENTER: number;
/**
 * @type {number}
 */
declare const KEY_SHIFT: number;
/**
 * @type {number}
 */
declare const KEY_CONTROL: number;
/**
 * @type {number}
 */
declare const KEY_ALT: number;
/**
 * @type {number}
 */
declare const KEY_PAUSE: number;
/**
 * @type {number}
 */
declare const KEY_CAPS_LOCK: number;
/**
 * @type {number}
 */
declare const KEY_ESCAPE: number;
/**
 * @type {number}
 */
declare const KEY_SPACE: number;
/**
 * @type {number}
 */
declare const KEY_PAGE_UP: number;
/**
 * @type {number}
 */
declare const KEY_PAGE_DOWN: number;
/**
 * @type {number}
 */
declare const KEY_END: number;
/**
 * @type {number}
 */
declare const KEY_HOME: number;
/**
 * @type {number}
 */
declare const KEY_LEFT: number;
/**
 * @type {number}
 */
declare const KEY_UP: number;
/**
 * @type {number}
 */
declare const KEY_RIGHT: number;
/**
 * @type {number}
 */
declare const KEY_DOWN: number;
/**
 * @type {number}
 */
declare const KEY_PRINT_SCREEN: number;
/**
 * @type {number}
 */
declare const KEY_INSERT: number;
/**
 * @type {number}
 */
declare const KEY_DELETE: number;
/**
 * @type {number}
 */
declare const KEY_0: number;
/**
 * @type {number}
 */
declare const KEY_1: number;
/**
 * @type {number}
 */
declare const KEY_2: number;
/**
 * @type {number}
 */
declare const KEY_3: number;
/**
 * @type {number}
 */
declare const KEY_4: number;
/**
 * @type {number}
 */
declare const KEY_5: number;
/**
 * @type {number}
 */
declare const KEY_6: number;
/**
 * @type {number}
 */
declare const KEY_7: number;
/**
 * @type {number}
 */
declare const KEY_8: number;
/**
 * @type {number}
 */
declare const KEY_9: number;
/**
 * @type {number}
 */
declare const KEY_SEMICOLON: number;
/**
 * @type {number}
 */
declare const KEY_EQUAL: number;
/**
 * @type {number}
 */
declare const KEY_A: number;
/**
 * @type {number}
 */
declare const KEY_B: number;
/**
 * @type {number}
 */
declare const KEY_C: number;
/**
 * @type {number}
 */
declare const KEY_D: number;
/**
 * @type {number}
 */
declare const KEY_E: number;
/**
 * @type {number}
 */
declare const KEY_F: number;
/**
 * @type {number}
 */
declare const KEY_G: number;
/**
 * @type {number}
 */
declare const KEY_H: number;
/**
 * @type {number}
 */
declare const KEY_I: number;
/**
 * @type {number}
 */
declare const KEY_J: number;
/**
 * @type {number}
 */
declare const KEY_K: number;
/**
 * @type {number}
 */
declare const KEY_L: number;
/**
 * @type {number}
 */
declare const KEY_M: number;
/**
 * @type {number}
 */
declare const KEY_N: number;
/**
 * @type {number}
 */
declare const KEY_O: number;
/**
 * @type {number}
 */
declare const KEY_P: number;
/**
 * @type {number}
 */
declare const KEY_Q: number;
/**
 * @type {number}
 */
declare const KEY_R: number;
/**
 * @type {number}
 */
declare const KEY_S: number;
/**
 * @type {number}
 */
declare const KEY_T: number;
/**
 * @type {number}
 */
declare const KEY_U: number;
/**
 * @type {number}
 */
declare const KEY_V: number;
/**
 * @type {number}
 */
declare const KEY_W: number;
/**
 * @type {number}
 */
declare const KEY_X: number;
/**
 * @type {number}
 */
declare const KEY_Y: number;
/**
 * @type {number}
 */
declare const KEY_Z: number;
/**
 * @type {number}
 */
declare const KEY_WINDOWS: number;
/**
 * @type {number}
 */
declare const KEY_CONTEXT_MENU: number;
/**
 * @type {number}
 */
declare const KEY_NUMPAD_0: number;
/**
 * @type {number}
 */
declare const KEY_NUMPAD_1: number;
/**
 * @type {number}
 */
declare const KEY_NUMPAD_2: number;
/**
 * @type {number}
 */
declare const KEY_NUMPAD_3: number;
/**
 * @type {number}
 */
declare const KEY_NUMPAD_4: number;
/**
 * @type {number}
 */
declare const KEY_NUMPAD_5: number;
/**
 * @type {number}
 */
declare const KEY_NUMPAD_6: number;
/**
 * @type {number}
 */
declare const KEY_NUMPAD_7: number;
/**
 * @type {number}
 */
declare const KEY_NUMPAD_8: number;
/**
 * @type {number}
 */
declare const KEY_NUMPAD_9: number;
/**
 * @type {number}
 */
declare const KEY_MULTIPLY: number;
/**
 * @type {number}
 */
declare const KEY_ADD: number;
/**
 * @type {number}
 */
declare const KEY_SEPARATOR: number;
/**
 * @type {number}
 */
declare const KEY_SUBTRACT: number;
/**
 * @type {number}
 */
declare const KEY_DECIMAL: number;
/**
 * @type {number}
 */
declare const KEY_DIVIDE: number;
/**
 * @type {number}
 */
declare const KEY_F1: number;
/**
 * @type {number}
 */
declare const KEY_F2: number;
/**
 * @type {number}
 */
declare const KEY_F3: number;
/**
 * @type {number}
 */
declare const KEY_F4: number;
/**
 * @type {number}
 */
declare const KEY_F5: number;
/**
 * @type {number}
 */
declare const KEY_F6: number;
/**
 * @type {number}
 */
declare const KEY_F7: number;
/**
 * @type {number}
 */
declare const KEY_F8: number;
/**
 * @type {number}
 */
declare const KEY_F9: number;
/**
 * @type {number}
 */
declare const KEY_F10: number;
/**
 * @type {number}
 */
declare const KEY_F11: number;
/**
 * @type {number}
 */
declare const KEY_F12: number;
/**
 * @type {number}
 */
declare const KEY_COMMA: number;
/**
 * @type {number}
 */
declare const KEY_PERIOD: number;
/**
 * @type {number}
 */
declare const KEY_SLASH: number;
/**
 * @type {number}
 */
declare const KEY_OPEN_BRACKET: number;
/**
 * @type {number}
 */
declare const KEY_BACK_SLASH: number;
/**
 * @type {number}
 */
declare const KEY_CLOSE_BRACKET: number;
/**
 * @type {number}
 */
declare const KEY_META: number;
/**
 * No mouse buttons pressed.
 *
 * @type {number}
 */
declare const MOUSEBUTTON_NONE: number;
/**
 * The left mouse button.
 *
 * @type {number}
 */
declare const MOUSEBUTTON_LEFT: number;
/**
 * The middle mouse button.
 *
 * @type {number}
 */
declare const MOUSEBUTTON_MIDDLE: number;
/**
 * The right mouse button.
 *
 * @type {number}
 */
declare const MOUSEBUTTON_RIGHT: number;
/**
 * Index for pad 1.
 *
 * @type {number}
 */
declare const PAD_1: number;
/**
 * Index for pad 2.
 *
 * @type {number}
 */
declare const PAD_2: number;
/**
 * Index for pad 3.
 *
 * @type {number}
 */
declare const PAD_3: number;
/**
 * Index for pad 4.
 *
 * @type {number}
 */
declare const PAD_4: number;
/**
 * The first face button, from bottom going clockwise.
 *
 * @type {number}
 */
declare const PAD_FACE_1: number;
/**
 * The second face button, from bottom going clockwise.
 *
 * @type {number}
 */
declare const PAD_FACE_2: number;
/**
 * The third face button, from bottom going clockwise.
 *
 * @type {number}
 */
declare const PAD_FACE_3: number;
/**
 * The fourth face button, from bottom going clockwise.
 *
 * @type {number}
 */
declare const PAD_FACE_4: number;
/**
 * The first shoulder button on the left.
 *
 * @type {number}
 */
declare const PAD_L_SHOULDER_1: number;
/**
 * The first shoulder button on the right.
 *
 * @type {number}
 */
declare const PAD_R_SHOULDER_1: number;
/**
 * The second shoulder button on the left.
 *
 * @type {number}
 */
declare const PAD_L_SHOULDER_2: number;
/**
 * The second shoulder button on the right.
 *
 * @type {number}
 */
declare const PAD_R_SHOULDER_2: number;
/**
 * The select button.
 *
 * @type {number}
 */
declare const PAD_SELECT: number;
/**
 * The start button.
 *
 * @type {number}
 */
declare const PAD_START: number;
/**
 * The button when depressing the left analogue stick.
 *
 * @type {number}
 */
declare const PAD_L_STICK_BUTTON: number;
/**
 * The button when depressing the right analogue stick.
 *
 * @type {number}
 */
declare const PAD_R_STICK_BUTTON: number;
/**
 * Direction pad up.
 *
 * @type {number}
 */
declare const PAD_UP: number;
/**
 * Direction pad down.
 *
 * @type {number}
 */
declare const PAD_DOWN: number;
/**
 * Direction pad left.
 *
 * @type {number}
 */
declare const PAD_LEFT: number;
/**
 * Direction pad right.
 *
 * @type {number}
 */
declare const PAD_RIGHT: number;
/**
 * Vendor specific button.
 *
 * @type {number}
 */
declare const PAD_VENDOR: number;
/**
 * Horizontal axis on the left analogue stick.
 *
 * @type {number}
 */
declare const PAD_L_STICK_X: number;
/**
 * Vertical axis on the left analogue stick.
 *
 * @type {number}
 */
declare const PAD_L_STICK_Y: number;
/**
 * Horizontal axis on the right analogue stick.
 *
 * @type {number}
 */
declare const PAD_R_STICK_X: number;
/**
 * Vertical axis on the right analogue stick.
 *
 * @type {number}
 */
declare const PAD_R_STICK_Y: number;

/**
 * When resizing the window the size of the canvas will not change.
 *
 * @type {string}
 */
declare const FILLMODE_NONE: string;
/**
 * When resizing the window the size of the canvas will change to fill the window exactly.
 *
 * @type {string}
 */
declare const FILLMODE_FILL_WINDOW: string;
/**
 * When resizing the window the size of the canvas will change to fill the window as best it can,
 * while maintaining the same aspect ratio.
 *
 * @type {string}
 */
declare const FILLMODE_KEEP_ASPECT: string;
/**
 * When the canvas is resized the resolution of the canvas will change to match the size of the
 * canvas.
 *
 * @type {string}
 */
declare const RESOLUTION_AUTO: string;
/**
 * When the canvas is resized the resolution of the canvas will remain at the same value and the
 * output will just be scaled to fit the canvas.
 *
 * @type {string}
 */
declare const RESOLUTION_FIXED: string;

/**
 * Specifies different color tints for the hover, pressed and inactive states.
 *
 * @type {number}
 */
declare const BUTTON_TRANSITION_MODE_TINT: number;
/**
 * Specifies different sprites for the hover, pressed and inactive states.
 *
 * @type {number}
 */
declare const BUTTON_TRANSITION_MODE_SPRITE_CHANGE: number;

/**
 * A {@link ElementComponent} that contains child {@link ElementComponent}s.
 *
 * @type {string}
 */
declare const ELEMENTTYPE_GROUP: string;
/**
 * A {@link ElementComponent} that displays an image.
 *
 * @type {string}
 */
declare const ELEMENTTYPE_IMAGE: string;
/**
 * A {@link ElementComponent} that displays text.
 *
 * @type {string}
 */
declare const ELEMENTTYPE_TEXT: string;
/**
 * Fit the content exactly to Element's bounding box.
 *
 * @type {string}
 */
declare const FITMODE_STRETCH: string;
/**
 * Fit the content within the Element's bounding box while preserving its Aspect Ratio.
 *
 * @type {string}
 */
declare const FITMODE_CONTAIN: string;
/**
 * Fit the content to cover the entire Element's bounding box while preserving its Aspect Ratio.
 *
 * @type {string}
 */
declare const FITMODE_COVER: string;

/**
 * Specified degree of freedom has free movement.
 *
 * @type {string}
 * @ignore
 */
declare const MOTION_FREE: string;
/**
 * Specified degree of freedom has limited movement.
 *
 * @type {string}
 * @ignore
 */
declare const MOTION_LIMITED: string;
/**
 * Specified degree of freedom is locked and allows no movement.
 *
 * @type {string}
 * @ignore
 */
declare const MOTION_LOCKED: string;

/**
 * Disable all fitting logic.
 *
 * @type {number}
 */
declare const FITTING_NONE: number;
/**
 * Stretch child elements to fit the parent container.
 *
 * @type {number}
 */
declare const FITTING_STRETCH: number;
/**
 * Shrink child elements to fit the parent container.
 *
 * @type {number}
 */
declare const FITTING_SHRINK: number;
/**
 * Apply both STRETCH and SHRINK fitting logic where applicable.
 *
 * @type {number}
 */
declare const FITTING_BOTH: number;

/**
 * Rigid body has infinite mass and cannot move.
 *
 * @type {string}
 */
declare const BODYTYPE_STATIC: string;
/**
 * Rigid body is simulated according to applied forces.
 *
 * @type {string}
 */
declare const BODYTYPE_DYNAMIC: string;
/**
 * Rigid body has infinite mass and does not respond to forces but can still be moved by setting
 * their velocity or position.
 *
 * @type {string}
 */
declare const BODYTYPE_KINEMATIC: string;
declare const BODYFLAG_STATIC_OBJECT: 1;
declare const BODYFLAG_KINEMATIC_OBJECT: 2;
declare const BODYFLAG_NORESPONSE_OBJECT: 4;
declare const BODYSTATE_ACTIVE_TAG: 1;
declare const BODYSTATE_ISLAND_SLEEPING: 2;
declare const BODYSTATE_WANTS_DEACTIVATION: 3;
declare const BODYSTATE_DISABLE_DEACTIVATION: 4;
declare const BODYSTATE_DISABLE_SIMULATION: 5;
declare const BODYGROUP_NONE: 0;
declare const BODYGROUP_DEFAULT: 1;
declare const BODYGROUP_DYNAMIC: 1;
declare const BODYGROUP_STATIC: 2;
declare const BODYGROUP_KINEMATIC: 4;
declare const BODYGROUP_ENGINE_1: 8;
declare const BODYGROUP_TRIGGER: 16;
declare const BODYGROUP_ENGINE_2: 32;
declare const BODYGROUP_ENGINE_3: 64;
declare const BODYGROUP_USER_1: 128;
declare const BODYGROUP_USER_2: 256;
declare const BODYGROUP_USER_3: 512;
declare const BODYGROUP_USER_4: 1024;
declare const BODYGROUP_USER_5: 2048;
declare const BODYGROUP_USER_6: 4096;
declare const BODYGROUP_USER_7: 8192;
declare const BODYGROUP_USER_8: 16384;
declare const BODYMASK_NONE: 0;
declare const BODYMASK_ALL: 65535;
declare const BODYMASK_STATIC: 2;
declare const BODYMASK_NOT_STATIC: number;
declare const BODYMASK_NOT_STATIC_KINEMATIC: number;

/**
 * Always use the application's resolution as the resolution for the {@link ScreenComponent}.
 *
 * @type {string}
 */
declare const SCALEMODE_NONE: string;
/**
 * Scale the {@link ScreenComponent} when the application's resolution is different than the
 * ScreenComponent's referenceResolution.
 *
 * @type {string}
 */
declare const SCALEMODE_BLEND: string;

/**
 * Content does not scroll any further than its bounds.
 *
 * @type {number}
 */
declare const SCROLL_MODE_CLAMP: number;
/**
 * Content scrolls past its bounds and then gently bounces back.
 *
 * @type {number}
 */
declare const SCROLL_MODE_BOUNCE: number;
/**
 * Content can scroll forever.
 *
 * @type {number}
 */
declare const SCROLL_MODE_INFINITE: number;
/**
 * The scrollbar will be visible all the time.
 *
 * @type {number}
 */
declare const SCROLLBAR_VISIBILITY_SHOW_ALWAYS: number;
/**
 * The scrollbar will be visible only when content exceeds the size of the viewport.
 *
 * @type {number}
 */
declare const SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED: number;

/**
 * A {@link SpriteComponent} that displays a single frame from a sprite asset.
 *
 * @type {string}
 */
declare const SPRITETYPE_SIMPLE: string;
/**
 * A {@link SpriteComponent} that renders sprite animations.
 *
 * @type {string}
 */
declare const SPRITETYPE_ANIMATED: string;

/**
 * Inline - always available type of session. It has limited features availability and is rendered
 * into HTML element.
 *
 * @type {string}
 */
declare const XRTYPE_INLINE: string;
/**
 * Immersive VR - session that provides exclusive access to VR device with best available tracking
 * features.
 *
 * @type {string}
 */
declare const XRTYPE_VR: string;
/**
 * Immersive AR - session that provides exclusive access to VR/AR device that is intended to be
 * blended with real-world environment.
 *
 * @type {string}
 */
declare const XRTYPE_AR: string;
/**
 * Viewer - always supported space with some basic tracking capabilities.
 *
 * @type {string}
 */
declare const XRSPACE_VIEWER: string;
/**
 * Local - represents a tracking space with a native origin near the viewer at the time of
 * creation. The exact position and orientation will be initialized based on the conventions of the
 * underlying platform. When using this reference space the user is not expected to move beyond
 * their initial position much, if at all, and tracking is optimized for that purpose. For devices
 * with 6DoF tracking, local reference spaces should emphasize keeping the origin stable relative
 * to the user's environment.
 *
 * @type {string}
 */
declare const XRSPACE_LOCAL: string;
/**
 * Local Floor - represents a tracking space with a native origin at the floor in a safe position
 * for the user to stand. The y axis equals 0 at floor level, with the x and z position and
 * orientation initialized based on the conventions of the underlying platform. Floor level value
 * might be estimated by the underlying platform. When using this reference space, the user is not
 * expected to move beyond their initial position much, if at all, and tracking is optimized for
 * that purpose. For devices with 6DoF tracking, local-floor reference spaces should emphasize
 * keeping the origin stable relative to the user's environment.
 *
 * @type {string}
 */
declare const XRSPACE_LOCALFLOOR: string;
/**
 * Bounded Floor - represents a tracking space with its native origin at the floor, where the user
 * is expected to move within a pre-established boundary. Tracking in a bounded-floor reference
 * space is optimized for keeping the native origin and bounds geometry stable relative to the
 * user's environment.
 *
 * @type {string}
 */
declare const XRSPACE_BOUNDEDFLOOR: string;
/**
 * Unbounded - represents a tracking space where the user is expected to move freely around their
 * environment, potentially even long distances from their starting point. Tracking in an unbounded
 * reference space is optimized for stability around the user's current position, and as such the
 * native origin may drift over time.
 *
 * @type {string}
 */
declare const XRSPACE_UNBOUNDED: string;
/**
 * Gaze - indicates the target ray will originate at the viewer and follow the direction it is
 * facing. This is commonly referred to as a "gaze input" device in the context of head-mounted
 * displays.
 *
 * @type {string}
 */
declare const XRTARGETRAY_GAZE: string;
/**
 * Screen - indicates that the input source was an interaction with the canvas element associated
 * with an inline session's output context, such as a mouse click or touch event.
 *
 * @type {string}
 */
declare const XRTARGETRAY_SCREEN: string;
/**
 * Tracked Pointer - indicates that the target ray originates from either a handheld device or
 * other hand-tracking mechanism and represents that the user is using their hands or the held
 * device for pointing.
 *
 * @type {string}
 */
declare const XRTARGETRAY_POINTER: string;
/**
 * None - input source is not meant to be held in hands.
 *
 * @type {string}
 */
declare const XRHAND_NONE: string;
/**
 * Left - indicates that input source is meant to be held in left hand.
 *
 * @type {string}
 */
declare const XRHAND_LEFT: string;
/**
 * Right - indicates that input source is meant to be held in right hand.
 *
 * @type {string}
 */
declare const XRHAND_RIGHT: string;
/**
 * Point - indicates that the hit test results will be computed based on the feature points
 * detected by the underlying Augmented Reality system.
 *
 * @type {string}
 */
declare const XRTRACKABLE_POINT: string;
/**
 * Plane - indicates that the hit test results will be computed based on the planes detected by the
 * underlying Augmented Reality system.
 *
 * @type {string}
 */
declare const XRTRACKABLE_PLANE: string;
/**
 * Mesh - indicates that the hit test results will be computed based on the meshes detected by the
 * underlying Augmented Reality system.
 *
 * @type {string}
 */
declare const XRTRACKABLE_MESH: string;
/**
 * CPU - indicates that depth sensing preferred usage is CPU. This usage path is guaranteed to be
 * supported.
 *
 * @type {string}
 */
declare const XRDEPTHSENSINGUSAGE_CPU: string;
/**
 * GPU - indicates that depth sensing preferred usage is GPU.
 *
 * @type {string}
 */
declare const XRDEPTHSENSINGUSAGE_GPU: string;
/**
 * Luminance Alpha - indicates that depth sensing preferred raw data format is Luminance Alpha.
 * This format is guaranteed to be supported.
 *
 * @type {string}
 */
declare const XRDEPTHSENSINGFORMAT_L8A8: string;
/**
 * Float 32 - indicates that depth sensing preferred raw data format is Float 32.
 *
 * @type {string}
 */
declare const XRDEPTHSENSINGFORMAT_F32: string;

/**
 * Get current time in milliseconds. Use it to measure time difference. Reference time may differ
 * on different platforms.
 *
 * @returns {number} The time in milliseconds.
 * @ignore
 */
declare const now: any;
/**
 * A Timer counts milliseconds from when start() is called until when stop() is called.
 *
 * @ignore
 */
declare class Timer {
    _isRunning: boolean;
    _a: number;
    _b: number;
    /**
     * Start the timer.
     */
    start(): void;
    /**
     * Stop the timer.
     */
    stop(): void;
    /**
     * Get the number of milliseconds that passed between start() and stop() being called.
     *
     * @returns {number} The elapsed milliseconds.
     */
    getMilliseconds(): number;
}

/**
 * 3-dimensional vector.
 */
declare class Vec3 {
    /**
     * A constant vector set to [0, 0, 0].
     *
     * @type {Vec3}
     * @readonly
     */
    static readonly ZERO: Vec3;
    /**
     * A constant vector set to [1, 1, 1].
     *
     * @type {Vec3}
     * @readonly
     */
    static readonly ONE: Vec3;
    /**
     * A constant vector set to [0, 1, 0].
     *
     * @type {Vec3}
     * @readonly
     */
    static readonly UP: Vec3;
    /**
     * A constant vector set to [0, -1, 0].
     *
     * @type {Vec3}
     * @readonly
     */
    static readonly DOWN: Vec3;
    /**
     * A constant vector set to [1, 0, 0].
     *
     * @type {Vec3}
     * @readonly
     */
    static readonly RIGHT: Vec3;
    /**
     * A constant vector set to [-1, 0, 0].
     *
     * @type {Vec3}
     * @readonly
     */
    static readonly LEFT: Vec3;
    /**
     * A constant vector set to [0, 0, -1].
     *
     * @type {Vec3}
     * @readonly
     */
    static readonly FORWARD: Vec3;
    /**
     * A constant vector set to [0, 0, 1].
     *
     * @type {Vec3}
     * @readonly
     */
    static readonly BACK: Vec3;
    /**
     * Creates a new Vec3 object.
     *
     * @param {number|number[]} [x] - The x value. Defaults to 0. If x is an array of length 3, the
     * array will be used to populate all components.
     * @param {number} [y] - The y value. Defaults to 0.
     * @param {number} [z] - The z value. Defaults to 0.
     * @example
     * var v = new pc.Vec3(1, 2, 3);
     */
    constructor(x?: number | number[], y?: number, z?: number);
    /**
     * The first component of the vector.
     *
     * @type {number}
     */
    x: number;
    /**
     * The second component of the vector.
     *
     * @type {number}
     */
    y: number;
    /**
     * The third component of the vector.
     *
     * @type {number}
     */
    z: number;
    /**
     * Adds a 3-dimensional vector to another in place.
     *
     * @param {Vec3} rhs - The vector to add to the specified vector.
     * @returns {Vec3} Self for chaining.
     * @example
     * var a = new pc.Vec3(10, 10, 10);
     * var b = new pc.Vec3(20, 20, 20);
     *
     * a.add(b);
     *
     * // Outputs [30, 30, 30]
     * console.log("The result of the addition is: " + a.toString());
     */
    add(rhs: Vec3): Vec3;
    /**
     * Adds two 3-dimensional vectors together and returns the result.
     *
     * @param {Vec3} lhs - The first vector operand for the addition.
     * @param {Vec3} rhs - The second vector operand for the addition.
     * @returns {Vec3} Self for chaining.
     * @example
     * var a = new pc.Vec3(10, 10, 10);
     * var b = new pc.Vec3(20, 20, 20);
     * var r = new pc.Vec3();
     *
     * r.add2(a, b);
     * // Outputs [30, 30, 30]
     *
     * console.log("The result of the addition is: " + r.toString());
     */
    add2(lhs: Vec3, rhs: Vec3): Vec3;
    /**
     * Adds a number to each element of a vector.
     *
     * @param {number} scalar - The number to add.
     * @returns {Vec3} Self for chaining.
     * @example
     * var vec = new pc.Vec3(3, 4, 5);
     *
     * vec.addScalar(2);
     *
     * // Outputs [5, 6, 7]
     * console.log("The result of the addition is: " + vec.toString());
     */
    addScalar(scalar: number): Vec3;
    /**
     * Returns an identical copy of the specified 3-dimensional vector.
     *
     * @returns {this} A 3-dimensional vector containing the result of the cloning.
     * @example
     * var v = new pc.Vec3(10, 20, 30);
     * var vclone = v.clone();
     * console.log("The result of the cloning is: " + vclone.toString());
     */
    clone(): this;
    /**
     * Copies the contents of a source 3-dimensional vector to a destination 3-dimensional vector.
     *
     * @param {Vec3} rhs - A vector to copy to the specified vector.
     * @returns {Vec3} Self for chaining.
     * @example
     * var src = new pc.Vec3(10, 20, 30);
     * var dst = new pc.Vec3();
     *
     * dst.copy(src);
     *
     * console.log("The two vectors are " + (dst.equals(src) ? "equal" : "different"));
     */
    copy(rhs: Vec3): Vec3;
    /**
     * Returns the result of a cross product operation performed on the two specified 3-dimensional
     * vectors.
     *
     * @param {Vec3} lhs - The first 3-dimensional vector operand of the cross product.
     * @param {Vec3} rhs - The second 3-dimensional vector operand of the cross product.
     * @returns {Vec3} Self for chaining.
     * @example
     * var back = new pc.Vec3().cross(pc.Vec3.RIGHT, pc.Vec3.UP);
     *
     * // Prints the Z axis (i.e. [0, 0, 1])
     * console.log("The result of the cross product is: " + back.toString());
     */
    cross(lhs: Vec3, rhs: Vec3): Vec3;
    /**
     * Returns the distance between the two specified 3-dimensional vectors.
     *
     * @param {Vec3} rhs - The second 3-dimensional vector to test.
     * @returns {number} The distance between the two vectors.
     * @example
     * var v1 = new pc.Vec3(5, 10, 20);
     * var v2 = new pc.Vec3(10, 20, 40);
     * var d = v1.distance(v2);
     * console.log("The distance between v1 and v2 is: " + d);
     */
    distance(rhs: Vec3): number;
    /**
     * Divides a 3-dimensional vector by another in place.
     *
     * @param {Vec3} rhs - The vector to divide the specified vector by.
     * @returns {Vec3} Self for chaining.
     * @example
     * var a = new pc.Vec3(4, 9, 16);
     * var b = new pc.Vec3(2, 3, 4);
     *
     * a.div(b);
     *
     * // Outputs [2, 3, 4]
     * console.log("The result of the division is: " + a.toString());
     */
    div(rhs: Vec3): Vec3;
    /**
     * Divides one 3-dimensional vector by another and writes the result to the specified vector.
     *
     * @param {Vec3} lhs - The dividend vector (the vector being divided).
     * @param {Vec3} rhs - The divisor vector (the vector dividing the dividend).
     * @returns {Vec3} Self for chaining.
     * @example
     * var a = new pc.Vec3(4, 9, 16);
     * var b = new pc.Vec3(2, 3, 4);
     * var r = new pc.Vec3();
     *
     * r.div2(a, b);
     * // Outputs [2, 3, 4]
     *
     * console.log("The result of the division is: " + r.toString());
     */
    div2(lhs: Vec3, rhs: Vec3): Vec3;
    /**
     * Divides each element of a vector by a number.
     *
     * @param {number} scalar - The number to divide by.
     * @returns {Vec3} Self for chaining.
     * @example
     * var vec = new pc.Vec3(3, 6, 9);
     *
     * vec.divScalar(3);
     *
     * // Outputs [1, 2, 3]
     * console.log("The result of the division is: " + vec.toString());
     */
    divScalar(scalar: number): Vec3;
    /**
     * Returns the result of a dot product operation performed on the two specified 3-dimensional
     * vectors.
     *
     * @param {Vec3} rhs - The second 3-dimensional vector operand of the dot product.
     * @returns {number} The result of the dot product operation.
     * @example
     * var v1 = new pc.Vec3(5, 10, 20);
     * var v2 = new pc.Vec3(10, 20, 40);
     * var v1dotv2 = v1.dot(v2);
     * console.log("The result of the dot product is: " + v1dotv2);
     */
    dot(rhs: Vec3): number;
    /**
     * Reports whether two vectors are equal.
     *
     * @param {Vec3} rhs - The vector to compare to the specified vector.
     * @returns {boolean} True if the vectors are equal and false otherwise.
     * @example
     * var a = new pc.Vec3(1, 2, 3);
     * var b = new pc.Vec3(4, 5, 6);
     * console.log("The two vectors are " + (a.equals(b) ? "equal" : "different"));
     */
    equals(rhs: Vec3): boolean;
    /**
     * Returns the magnitude of the specified 3-dimensional vector.
     *
     * @returns {number} The magnitude of the specified 3-dimensional vector.
     * @example
     * var vec = new pc.Vec3(3, 4, 0);
     * var len = vec.length();
     * // Outputs 5
     * console.log("The length of the vector is: " + len);
     */
    length(): number;
    /**
     * Returns the magnitude squared of the specified 3-dimensional vector.
     *
     * @returns {number} The magnitude of the specified 3-dimensional vector.
     * @example
     * var vec = new pc.Vec3(3, 4, 0);
     * var len = vec.lengthSq();
     * // Outputs 25
     * console.log("The length squared of the vector is: " + len);
     */
    lengthSq(): number;
    /**
     * Returns the result of a linear interpolation between two specified 3-dimensional vectors.
     *
     * @param {Vec3} lhs - The 3-dimensional to interpolate from.
     * @param {Vec3} rhs - The 3-dimensional to interpolate to.
     * @param {number} alpha - The value controlling the point of interpolation. Between 0 and 1,
     * the linear interpolant will occur on a straight line between lhs and rhs. Outside of this
     * range, the linear interpolant will occur on a ray extrapolated from this line.
     * @returns {Vec3} Self for chaining.
     * @example
     * var a = new pc.Vec3(0, 0, 0);
     * var b = new pc.Vec3(10, 10, 10);
     * var r = new pc.Vec3();
     *
     * r.lerp(a, b, 0);   // r is equal to a
     * r.lerp(a, b, 0.5); // r is 5, 5, 5
     * r.lerp(a, b, 1);   // r is equal to b
     */
    lerp(lhs: Vec3, rhs: Vec3, alpha: number): Vec3;
    /**
     * Multiplies a 3-dimensional vector to another in place.
     *
     * @param {Vec3} rhs - The 3-dimensional vector used as the second multiplicand of the operation.
     * @returns {Vec3} Self for chaining.
     * @example
     * var a = new pc.Vec3(2, 3, 4);
     * var b = new pc.Vec3(4, 5, 6);
     *
     * a.mul(b);
     *
     * // Outputs 8, 15, 24
     * console.log("The result of the multiplication is: " + a.toString());
     */
    mul(rhs: Vec3): Vec3;
    /**
     * Returns the result of multiplying the specified 3-dimensional vectors together.
     *
     * @param {Vec3} lhs - The 3-dimensional vector used as the first multiplicand of the operation.
     * @param {Vec3} rhs - The 3-dimensional vector used as the second multiplicand of the operation.
     * @returns {Vec3} Self for chaining.
     * @example
     * var a = new pc.Vec3(2, 3, 4);
     * var b = new pc.Vec3(4, 5, 6);
     * var r = new pc.Vec3();
     *
     * r.mul2(a, b);
     *
     * // Outputs 8, 15, 24
     * console.log("The result of the multiplication is: " + r.toString());
     */
    mul2(lhs: Vec3, rhs: Vec3): Vec3;
    /**
     * Multiplies each element of a vector by a number.
     *
     * @param {number} scalar - The number to multiply by.
     * @returns {Vec3} Self for chaining.
     * @example
     * var vec = new pc.Vec3(3, 6, 9);
     *
     * vec.mulScalar(3);
     *
     * // Outputs [9, 18, 27]
     * console.log("The result of the multiplication is: " + vec.toString());
     */
    mulScalar(scalar: number): Vec3;
    /**
     * Returns this 3-dimensional vector converted to a unit vector in place. If the vector has a
     * length of zero, the vector's elements will be set to zero.
     *
     * @returns {Vec3} Self for chaining.
     * @example
     * var v = new pc.Vec3(25, 0, 0);
     *
     * v.normalize();
     *
     * // Outputs 1, 0, 0
     * console.log("The result of the vector normalization is: " + v.toString());
     */
    normalize(): Vec3;
    /**
     * Each element is set to the largest integer less than or equal to its value.
     *
     * @returns {Vec3} Self for chaining.
     */
    floor(): Vec3;
    /**
     * Each element is rounded up to the next largest integer.
     *
     * @returns {Vec3} Self for chaining.
     */
    ceil(): Vec3;
    /**
     * Each element is rounded up or down to the nearest integer.
     *
     * @returns {Vec3} Self for chaining.
     */
    round(): Vec3;
    /**
     * Each element is assigned a value from rhs parameter if it is smaller.
     *
     * @param {Vec3} rhs - The 3-dimensional vector used as the source of elements to compare to.
     * @returns {Vec3} Self for chaining.
     */
    min(rhs: Vec3): Vec3;
    /**
     * Each element is assigned a value from rhs parameter if it is larger.
     *
     * @param {Vec3} rhs - The 3-dimensional vector used as the source of elements to compare to.
     * @returns {Vec3} Self for chaining.
     */
    max(rhs: Vec3): Vec3;
    /**
     * Projects this 3-dimensional vector onto the specified vector.
     *
     * @param {Vec3} rhs - The vector onto which the original vector will be projected on.
     * @returns {Vec3} Self for chaining.
     * @example
     * var v = new pc.Vec3(5, 5, 5);
     * var normal = new pc.Vec3(1, 0, 0);
     *
     * v.project(normal);
     *
     * // Outputs 5, 0, 0
     * console.log("The result of the vector projection is: " + v.toString());
     */
    project(rhs: Vec3): Vec3;
    /**
     * Sets the specified 3-dimensional vector to the supplied numerical values.
     *
     * @param {number} x - The value to set on the first component of the vector.
     * @param {number} y - The value to set on the second component of the vector.
     * @param {number} z - The value to set on the third component of the vector.
     * @returns {Vec3} Self for chaining.
     * @example
     * var v = new pc.Vec3();
     * v.set(5, 10, 20);
     *
     * // Outputs 5, 10, 20
     * console.log("The result of the vector set is: " + v.toString());
     */
    set(x: number, y: number, z: number): Vec3;
    /**
     * Subtracts a 3-dimensional vector from another in place.
     *
     * @param {Vec3} rhs - The vector to add to the specified vector.
     * @returns {Vec3} Self for chaining.
     * @example
     * var a = new pc.Vec3(10, 10, 10);
     * var b = new pc.Vec3(20, 20, 20);
     *
     * a.sub(b);
     *
     * // Outputs [-10, -10, -10]
     * console.log("The result of the subtraction is: " + a.toString());
     */
    sub(rhs: Vec3): Vec3;
    /**
     * Subtracts two 3-dimensional vectors from one another and returns the result.
     *
     * @param {Vec3} lhs - The first vector operand for the addition.
     * @param {Vec3} rhs - The second vector operand for the addition.
     * @returns {Vec3} Self for chaining.
     * @example
     * var a = new pc.Vec3(10, 10, 10);
     * var b = new pc.Vec3(20, 20, 20);
     * var r = new pc.Vec3();
     *
     * r.sub2(a, b);
     *
     * // Outputs [-10, -10, -10]
     * console.log("The result of the subtraction is: " + r.toString());
     */
    sub2(lhs: Vec3, rhs: Vec3): Vec3;
    /**
     * Subtracts a number from each element of a vector.
     *
     * @param {number} scalar - The number to subtract.
     * @returns {Vec3} Self for chaining.
     * @example
     * var vec = new pc.Vec3(3, 4, 5);
     *
     * vec.subScalar(2);
     *
     * // Outputs [1, 2, 3]
     * console.log("The result of the subtraction is: " + vec.toString());
     */
    subScalar(scalar: number): Vec3;
    /**
     * Converts the vector to string form.
     *
     * @returns {string} The vector in string form.
     * @example
     * var v = new pc.Vec3(20, 10, 5);
     * // Outputs [20, 10, 5]
     * console.log(v.toString());
     */
    toString(): string;
}

/**
 * An infinite ray.
 */
declare class Ray {
    /**
     * Creates a new Ray instance. The ray is infinite, starting at a given origin and pointing in
     * a given direction.
     *
     * @param {Vec3} [origin] - The starting point of the ray. The constructor takes a reference of
     * this parameter. Defaults to the origin (0, 0, 0).
     * @param {Vec3} [direction] - The direction of the ray. The constructor takes a reference of
     * this parameter. Defaults to a direction down the world negative Z axis (0, 0, -1).
     * @example
     * // Create a new ray starting at the position of this entity and pointing down
     * // the entity's negative Z axis
     * var ray = new pc.Ray(this.entity.getPosition(), this.entity.forward);
     */
    constructor(origin?: Vec3, direction?: Vec3);
    /**
     * The starting point of the ray.
     *
     * @type {Vec3}
     */
    origin: Vec3;
    /**
     * The direction of the ray.
     *
     * @type {Vec3}
     */
    direction: Vec3;
    /**
     * Sets origin and direction to the supplied vector values.
     *
     * @param {Vec3} origin - The starting point of the ray.
     * @param {Vec3} direction - The direction of the ray.
     * @returns {Ray} Self for chaining.
     */
    set(origin: Vec3, direction: Vec3): Ray;
}


/**
 * A bounding sphere is a volume for facilitating fast intersection testing.
 */
declare class BoundingSphere {
    /**
     * Creates a new BoundingSphere instance.
     *
     * @param {Vec3} [center] - The world space coordinate marking the center of the sphere. The
     * constructor takes a reference of this parameter.
     * @param {number} [radius] - The radius of the bounding sphere. Defaults to 0.5.
     * @example
     * // Create a new bounding sphere centered on the origin with a radius of 0.5
     * var sphere = new pc.BoundingSphere();
     */
    constructor(center?: Vec3, radius?: number);
    /**
     * Center of sphere.
     *
     * @type {Vec3}
     */
    center: Vec3;
    /**
     * The radius of the bounding sphere.
     *
     * @type {number}
     */
    radius: number;
    containsPoint(point: any): boolean;
    /**
     * Test if a ray intersects with the sphere.
     *
     * @param {Ray} ray - Ray to test against (direction must be normalized).
     * @param {Vec3} [point] - If there is an intersection, the intersection point will be copied
     * into here.
     * @returns {boolean} True if there is an intersection.
     */
    intersectsRay(ray: Ray, point?: Vec3): boolean;
    /**
     * Test if a Bounding Sphere is overlapping, enveloping, or inside this Bounding Sphere.
     *
     * @param {BoundingSphere} sphere - Bounding Sphere to test.
     * @returns {boolean} True if the Bounding Sphere is overlapping, enveloping, or inside this Bounding Sphere and false otherwise.
     */
    intersectsBoundingSphere(sphere: BoundingSphere): boolean;
}


/** @typedef {import('./mat4.js').Mat4} Mat4 */
/**
 * A quaternion.
 */
declare class Quat {
    /**
     * A constant quaternion set to [0, 0, 0, 1] (the identity).
     *
     * @type {Quat}
     * @readonly
     */
    static readonly IDENTITY: Quat;
    /**
     * A constant quaternion set to [0, 0, 0, 0].
     *
     * @type {Quat}
     * @readonly
     */
    static readonly ZERO: Quat;
    /**
     * Create a new Quat instance.
     *
     * @param {number|number[]} [x] - The quaternion's x component. Defaults to 0. If x is an array
     * of length 4, the array will be used to populate all components.
     * @param {number} [y] - The quaternion's y component. Defaults to 0.
     * @param {number} [z] - The quaternion's z component. Defaults to 0.
     * @param {number} [w] - The quaternion's w component. Defaults to 1.
     */
    constructor(x?: number | number[], y?: number, z?: number, w?: number);
    /**
     * The x component of the quaternion.
     *
     * @type {number}
     */
    x: number;
    /**
     * The y component of the quaternion.
     *
     * @type {number}
     */
    y: number;
    /**
     * The z component of the quaternion.
     *
     * @type {number}
     */
    z: number;
    /**
     * The w component of the quaternion.
     *
     * @type {number}
     */
    w: number;
    /**
     * Returns an identical copy of the specified quaternion.
     *
     * @returns {this} A quaternion containing the result of the cloning.
     * @example
     * var q = new pc.Quat(-0.11, -0.15, -0.46, 0.87);
     * var qclone = q.clone();
     *
     * console.log("The result of the cloning is: " + q.toString());
     */
    clone(): this;
    conjugate(): Quat;
    /**
     * Copies the contents of a source quaternion to a destination quaternion.
     *
     * @param {Quat} rhs - The quaternion to be copied.
     * @returns {Quat} Self for chaining.
     * @example
     * var src = new pc.Quat();
     * var dst = new pc.Quat();
     * dst.copy(src, src);
     * console.log("The two quaternions are " + (src.equals(dst) ? "equal" : "different"));
     */
    copy(rhs: Quat): Quat;
    /**
     * Reports whether two quaternions are equal.
     *
     * @param {Quat} rhs - The quaternion to be compared against.
     * @returns {boolean} True if the quaternions are equal and false otherwise.
     * @example
     * var a = new pc.Quat();
     * var b = new pc.Quat();
     * console.log("The two quaternions are " + (a.equals(b) ? "equal" : "different"));
     */
    equals(rhs: Quat): boolean;
    /**
     * Gets the rotation axis and angle for a given quaternion. If a quaternion is created with
     * `setFromAxisAngle`, this method will return the same values as provided in the original
     * parameter list OR functionally equivalent values.
     *
     * @param {Vec3} axis - The 3-dimensional vector to receive the axis of rotation.
     * @returns {number} Angle, in degrees, of the rotation.
     * @example
     * var q = new pc.Quat();
     * q.setFromAxisAngle(new pc.Vec3(0, 1, 0), 90);
     * var v = new pc.Vec3();
     * var angle = q.getAxisAngle(v);
     * // Outputs 90
     * console.log(angle);
     * // Outputs [0, 1, 0]
     * console.log(v.toString());
     */
    getAxisAngle(axis: Vec3): number;
    /**
     * Converts the supplied quaternion to Euler angles.
     *
     * @param {Vec3} [eulers] - The 3-dimensional vector to receive the Euler angles.
     * @returns {Vec3} The 3-dimensional vector holding the Euler angles that
     * correspond to the supplied quaternion.
     */
    getEulerAngles(eulers?: Vec3): Vec3;
    /**
     * Generates the inverse of the specified quaternion.
     *
     * @returns {Quat} Self for chaining.
     * @example
     * // Create a quaternion rotated 180 degrees around the y-axis
     * var rot = new pc.Quat().setFromEulerAngles(0, 180, 0);
     *
     * // Invert in place
     * rot.invert();
     */
    invert(): Quat;
    /**
     * Returns the magnitude of the specified quaternion.
     *
     * @returns {number} The magnitude of the specified quaternion.
     * @example
     * var q = new pc.Quat(0, 0, 0, 5);
     * var len = q.length();
     * // Outputs 5
     * console.log("The length of the quaternion is: " + len);
     */
    length(): number;
    /**
     * Returns the magnitude squared of the specified quaternion.
     *
     * @returns {number} The magnitude of the specified quaternion.
     * @example
     * var q = new pc.Quat(3, 4, 0);
     * var lenSq = q.lengthSq();
     * // Outputs 25
     * console.log("The length squared of the quaternion is: " + lenSq);
     */
    lengthSq(): number;
    /**
     * Returns the result of multiplying the specified quaternions together.
     *
     * @param {Quat} rhs - The quaternion used as the second multiplicand of the operation.
     * @returns {Quat} Self for chaining.
     * @example
     * var a = new pc.Quat().setFromEulerAngles(0, 30, 0);
     * var b = new pc.Quat().setFromEulerAngles(0, 60, 0);
     *
     * // a becomes a 90 degree rotation around the Y axis
     * // In other words, a = a * b
     * a.mul(b);
     *
     * console.log("The result of the multiplication is: " + a.toString());
     */
    mul(rhs: Quat): Quat;
    /**
     * Returns the result of multiplying the specified quaternions together.
     *
     * @param {Quat} lhs - The quaternion used as the first multiplicand of the operation.
     * @param {Quat} rhs - The quaternion used as the second multiplicand of the operation.
     * @returns {Quat} Self for chaining.
     * @example
     * var a = new pc.Quat().setFromEulerAngles(0, 30, 0);
     * var b = new pc.Quat().setFromEulerAngles(0, 60, 0);
     * var r = new pc.Quat();
     *
     * // r is set to a 90 degree rotation around the Y axis
     * // In other words, r = a * b
     * r.mul2(a, b);
     *
     * console.log("The result of the multiplication is: " + r.toString());
     */
    mul2(lhs: Quat, rhs: Quat): Quat;
    /**
     * Returns the specified quaternion converted in place to a unit quaternion.
     *
     * @returns {Quat} The result of the normalization.
     * @example
     * var v = new pc.Quat(0, 0, 0, 5);
     *
     * v.normalize();
     *
     * // Outputs 0, 0, 0, 1
     * console.log("The result of the vector normalization is: " + v.toString());
     */
    normalize(): Quat;
    /**
     * Sets the specified quaternion to the supplied numerical values.
     *
     * @param {number} x - The x component of the quaternion.
     * @param {number} y - The y component of the quaternion.
     * @param {number} z - The z component of the quaternion.
     * @param {number} w - The w component of the quaternion.
     * @returns {Quat} Self for chaining.
     * @example
     * var q = new pc.Quat();
     * q.set(1, 0, 0, 0);
     *
     * // Outputs 1, 0, 0, 0
     * console.log("The result of the vector set is: " + q.toString());
     */
    set(x: number, y: number, z: number, w: number): Quat;
    /**
     * Sets a quaternion from an angular rotation around an axis.
     *
     * @param {Vec3} axis - World space axis around which to rotate.
     * @param {number} angle - Angle to rotate around the given axis in degrees.
     * @returns {Quat} Self for chaining.
     * @example
     * var q = new pc.Quat();
     * q.setFromAxisAngle(pc.Vec3.UP, 90);
     */
    setFromAxisAngle(axis: Vec3, angle: number): Quat;
    /**
     * Sets a quaternion from Euler angles specified in XYZ order.
     *
     * @param {number|Vec3} ex - Angle to rotate around X axis in degrees. If ex is a Vec3, the
     * three angles will be read from it instead.
     * @param {number} [ey] - Angle to rotate around Y axis in degrees.
     * @param {number} [ez] - Angle to rotate around Z axis in degrees.
     * @returns {Quat} Self for chaining.
     * @example
     * // Create a quaternion from 3 euler angles
     * var q = new pc.Quat();
     * q.setFromEulerAngles(45, 90, 180);
     *
     * // Create the same quaternion from a vector containing the same 3 euler angles
     * var v = new pc.Vec3(45, 90, 180);
     * var r = new pc.Quat();
     * r.setFromEulerAngles(v);
     */
    setFromEulerAngles(ex: number | Vec3, ey?: number, ez?: number): Quat;
    /**
     * Converts the specified 4x4 matrix to a quaternion. Note that since a quaternion is purely a
     * representation for orientation, only the translational part of the matrix is lost.
     *
     * @param {Mat4} m - The 4x4 matrix to convert.
     * @returns {Quat} Self for chaining.
     * @example
     * // Create a 4x4 rotation matrix of 180 degrees around the y-axis
     * var rot = new pc.Mat4().setFromAxisAngle(pc.Vec3.UP, 180);
     *
     * // Convert to a quaternion
     * var q = new pc.Quat().setFromMat4(rot);
     */
    setFromMat4(m: Mat4): Quat;
    /**
     * Performs a spherical interpolation between two quaternions. The result of the interpolation
     * is written to the quaternion calling the function.
     *
     * @param {Quat} lhs - The quaternion to interpolate from.
     * @param {Quat} rhs - The quaternion to interpolate to.
     * @param {number} alpha - The value controlling the interpolation in relation to the two input
     * quaternions. The value is in the range 0 to 1, 0 generating q1, 1 generating q2 and anything
     * in between generating a spherical interpolation between the two.
     * @returns {Quat} Self for chaining.
     * @example
     * var q1 = new pc.Quat(-0.11, -0.15, -0.46, 0.87);
     * var q2 = new pc.Quat(-0.21, -0.21, -0.67, 0.68);
     *
     * var result;
     * result = new pc.Quat().slerp(q1, q2, 0);   // Return q1
     * result = new pc.Quat().slerp(q1, q2, 0.5); // Return the midpoint interpolant
     * result = new pc.Quat().slerp(q1, q2, 1);   // Return q2
     */
    slerp(lhs: Quat, rhs: Quat, alpha: number): Quat;
    /**
     * Transforms a 3-dimensional vector by the specified quaternion.
     *
     * @param {Vec3} vec - The 3-dimensional vector to be transformed.
     * @param {Vec3} [res] - An optional 3-dimensional vector to receive the result of the transformation.
     * @returns {Vec3} The input vector v transformed by the current instance.
     * @example
     * // Create a 3-dimensional vector
     * var v = new pc.Vec3(1, 2, 3);
     *
     * // Create a 4x4 rotation matrix
     * var q = new pc.Quat().setFromEulerAngles(10, 20, 30);
     *
     * var tv = q.transformVector(v);
     */
    transformVector(vec: Vec3, res?: Vec3): Vec3;
    /**
     * Converts the quaternion to string form.
     *
     * @returns {string} The quaternion in string form.
     * @example
     * var v = new pc.Quat(0, 0, 0, 1);
     * // Outputs [0, 0, 0, 1]
     * console.log(v.toString());
     */
    toString(): string;
}

/**
 * A 4-dimensional vector.
 */
declare class Vec4 {
    /**
     * A constant vector set to [0, 0, 0, 0].
     *
     * @type {Vec4}
     * @readonly
     */
    static readonly ZERO: Vec4;
    /**
     * A constant vector set to [1, 1, 1, 1].
     *
     * @type {Vec4}
     * @readonly
     */
    static readonly ONE: Vec4;
    /**
     * Creates a new Vec4 object.
     *
     * @param {number|number[]} [x] - The x value. Defaults to 0. If x is an array of length 4, the
     * array will be used to populate all components.
     * @param {number} [y] - The y value. Defaults to 0.
     * @param {number} [z] - The z value. Defaults to 0.
     * @param {number} [w] - The w value. Defaults to 0.
     * @example
     * var v = new pc.Vec4(1, 2, 3, 4);
     */
    constructor(x?: number | number[], y?: number, z?: number, w?: number);
    /**
     * The first component of the vector.
     *
     * @type {number}
     */
    x: number;
    /**
     * The second component of the vector.
     *
     * @type {number}
     */
    y: number;
    /**
     * The third component of the vector.
     *
     * @type {number}
     */
    z: number;
    /**
     * The fourth component of the vector.
     *
     * @type {number}
     */
    w: number;
    /**
     * Adds a 4-dimensional vector to another in place.
     *
     * @param {Vec4} rhs - The vector to add to the specified vector.
     * @returns {Vec4} Self for chaining.
     * @example
     * var a = new pc.Vec4(10, 10, 10, 10);
     * var b = new pc.Vec4(20, 20, 20, 20);
     *
     * a.add(b);
     *
     * // Outputs [30, 30, 30]
     * console.log("The result of the addition is: " + a.toString());
     */
    add(rhs: Vec4): Vec4;
    /**
     * Adds two 4-dimensional vectors together and returns the result.
     *
     * @param {Vec4} lhs - The first vector operand for the addition.
     * @param {Vec4} rhs - The second vector operand for the addition.
     * @returns {Vec4} Self for chaining.
     * @example
     * var a = new pc.Vec4(10, 10, 10, 10);
     * var b = new pc.Vec4(20, 20, 20, 20);
     * var r = new pc.Vec4();
     *
     * r.add2(a, b);
     * // Outputs [30, 30, 30]
     *
     * console.log("The result of the addition is: " + r.toString());
     */
    add2(lhs: Vec4, rhs: Vec4): Vec4;
    /**
     * Adds a number to each element of a vector.
     *
     * @param {number} scalar - The number to add.
     * @returns {Vec4} Self for chaining.
     * @example
     * var vec = new pc.Vec4(3, 4, 5, 6);
     *
     * vec.addScalar(2);
     *
     * // Outputs [5, 6, 7, 8]
     * console.log("The result of the addition is: " + vec.toString());
     */
    addScalar(scalar: number): Vec4;
    /**
     * Returns an identical copy of the specified 4-dimensional vector.
     *
     * @returns {this} A 4-dimensional vector containing the result of the cloning.
     * @example
     * var v = new pc.Vec4(10, 20, 30, 40);
     * var vclone = v.clone();
     * console.log("The result of the cloning is: " + vclone.toString());
     */
    clone(): this;
    /**
     * Copies the contents of a source 4-dimensional vector to a destination 4-dimensional vector.
     *
     * @param {Vec4} rhs - A vector to copy to the specified vector.
     * @returns {Vec4} Self for chaining.
     * @example
     * var src = new pc.Vec4(10, 20, 30, 40);
     * var dst = new pc.Vec4();
     *
     * dst.copy(src);
     *
     * console.log("The two vectors are " + (dst.equals(src) ? "equal" : "different"));
     */
    copy(rhs: Vec4): Vec4;
    /**
     * Divides a 4-dimensional vector by another in place.
     *
     * @param {Vec4} rhs - The vector to divide the specified vector by.
     * @returns {Vec4} Self for chaining.
     * @example
     * var a = new pc.Vec4(4, 9, 16, 25);
     * var b = new pc.Vec4(2, 3, 4, 5);
     *
     * a.div(b);
     *
     * // Outputs [2, 3, 4, 5]
     * console.log("The result of the division is: " + a.toString());
     */
    div(rhs: Vec4): Vec4;
    /**
     * Divides one 4-dimensional vector by another and writes the result to the specified vector.
     *
     * @param {Vec4} lhs - The dividend vector (the vector being divided).
     * @param {Vec4} rhs - The divisor vector (the vector dividing the dividend).
     * @returns {Vec4} Self for chaining.
     * @example
     * var a = new pc.Vec4(4, 9, 16, 25);
     * var b = new pc.Vec4(2, 3, 4, 5);
     * var r = new pc.Vec4();
     *
     * r.div2(a, b);
     * // Outputs [2, 3, 4, 5]
     *
     * console.log("The result of the division is: " + r.toString());
     */
    div2(lhs: Vec4, rhs: Vec4): Vec4;
    /**
     * Divides each element of a vector by a number.
     *
     * @param {number} scalar - The number to divide by.
     * @returns {Vec4} Self for chaining.
     * @example
     * var vec = new pc.Vec4(3, 6, 9, 12);
     *
     * vec.divScalar(3);
     *
     * // Outputs [1, 2, 3, 4]
     * console.log("The result of the division is: " + vec.toString());
     */
    divScalar(scalar: number): Vec4;
    /**
     * Returns the result of a dot product operation performed on the two specified 4-dimensional
     * vectors.
     *
     * @param {Vec4} rhs - The second 4-dimensional vector operand of the dot product.
     * @returns {number} The result of the dot product operation.
     * @example
     * var v1 = new pc.Vec4(5, 10, 20, 40);
     * var v2 = new pc.Vec4(10, 20, 40, 80);
     * var v1dotv2 = v1.dot(v2);
     * console.log("The result of the dot product is: " + v1dotv2);
     */
    dot(rhs: Vec4): number;
    /**
     * Reports whether two vectors are equal.
     *
     * @param {Vec4} rhs - The vector to compare to the specified vector.
     * @returns {boolean} True if the vectors are equal and false otherwise.
     * @example
     * var a = new pc.Vec4(1, 2, 3, 4);
     * var b = new pc.Vec4(5, 6, 7, 8);
     * console.log("The two vectors are " + (a.equals(b) ? "equal" : "different"));
     */
    equals(rhs: Vec4): boolean;
    /**
     * Returns the magnitude of the specified 4-dimensional vector.
     *
     * @returns {number} The magnitude of the specified 4-dimensional vector.
     * @example
     * var vec = new pc.Vec4(3, 4, 0, 0);
     * var len = vec.length();
     * // Outputs 5
     * console.log("The length of the vector is: " + len);
     */
    length(): number;
    /**
     * Returns the magnitude squared of the specified 4-dimensional vector.
     *
     * @returns {number} The magnitude of the specified 4-dimensional vector.
     * @example
     * var vec = new pc.Vec4(3, 4, 0);
     * var len = vec.lengthSq();
     * // Outputs 25
     * console.log("The length squared of the vector is: " + len);
     */
    lengthSq(): number;
    /**
     * Returns the result of a linear interpolation between two specified 4-dimensional vectors.
     *
     * @param {Vec4} lhs - The 4-dimensional to interpolate from.
     * @param {Vec4} rhs - The 4-dimensional to interpolate to.
     * @param {number} alpha - The value controlling the point of interpolation. Between 0 and 1,
     * the linear interpolant will occur on a straight line between lhs and rhs. Outside of this
     * range, the linear interpolant will occur on a ray extrapolated from this line.
     * @returns {Vec4} Self for chaining.
     * @example
     * var a = new pc.Vec4(0, 0, 0, 0);
     * var b = new pc.Vec4(10, 10, 10, 10);
     * var r = new pc.Vec4();
     *
     * r.lerp(a, b, 0);   // r is equal to a
     * r.lerp(a, b, 0.5); // r is 5, 5, 5, 5
     * r.lerp(a, b, 1);   // r is equal to b
     */
    lerp(lhs: Vec4, rhs: Vec4, alpha: number): Vec4;
    /**
     * Multiplies a 4-dimensional vector to another in place.
     *
     * @param {Vec4} rhs - The 4-dimensional vector used as the second multiplicand of the operation.
     * @returns {Vec4} Self for chaining.
     * @example
     * var a = new pc.Vec4(2, 3, 4, 5);
     * var b = new pc.Vec4(4, 5, 6, 7);
     *
     * a.mul(b);
     *
     * // Outputs 8, 15, 24, 35
     * console.log("The result of the multiplication is: " + a.toString());
     */
    mul(rhs: Vec4): Vec4;
    /**
     * Returns the result of multiplying the specified 4-dimensional vectors together.
     *
     * @param {Vec4} lhs - The 4-dimensional vector used as the first multiplicand of the operation.
     * @param {Vec4} rhs - The 4-dimensional vector used as the second multiplicand of the operation.
     * @returns {Vec4} Self for chaining.
     * @example
     * var a = new pc.Vec4(2, 3, 4, 5);
     * var b = new pc.Vec4(4, 5, 6, 7);
     * var r = new pc.Vec4();
     *
     * r.mul2(a, b);
     *
     * // Outputs 8, 15, 24, 35
     * console.log("The result of the multiplication is: " + r.toString());
     */
    mul2(lhs: Vec4, rhs: Vec4): Vec4;
    /**
     * Multiplies each element of a vector by a number.
     *
     * @param {number} scalar - The number to multiply by.
     * @returns {Vec4} Self for chaining.
     * @example
     * var vec = new pc.Vec4(3, 6, 9, 12);
     *
     * vec.mulScalar(3);
     *
     * // Outputs [9, 18, 27, 36]
     * console.log("The result of the multiplication is: " + vec.toString());
     */
    mulScalar(scalar: number): Vec4;
    /**
     * Returns this 4-dimensional vector converted to a unit vector in place. If the vector has a
     * length of zero, the vector's elements will be set to zero.
     *
     * @returns {Vec4} Self for chaining.
     * @example
     * var v = new pc.Vec4(25, 0, 0, 0);
     *
     * v.normalize();
     *
     * // Outputs 1, 0, 0, 0
     * console.log("The result of the vector normalization is: " + v.toString());
     */
    normalize(): Vec4;
    /**
     * Each element is set to the largest integer less than or equal to its value.
     *
     * @returns {Vec4} Self for chaining.
     */
    floor(): Vec4;
    /**
     * Each element is rounded up to the next largest integer.
     *
     * @returns {Vec4} Self for chaining.
     */
    ceil(): Vec4;
    /**
     * Each element is rounded up or down to the nearest integer.
     *
     * @returns {Vec4} Self for chaining.
     */
    round(): Vec4;
    /**
     * Each element is assigned a value from rhs parameter if it is smaller.
     *
     * @param {Vec4} rhs - The 4-dimensional vector used as the source of elements to compare to.
     * @returns {Vec4} Self for chaining.
     */
    min(rhs: Vec4): Vec4;
    /**
     * Each element is assigned a value from rhs parameter if it is larger.
     *
     * @param {Vec4} rhs - The 4-dimensional vector used as the source of elements to compare to.
     * @returns {Vec4} Self for chaining.
     */
    max(rhs: Vec4): Vec4;
    /**
     * Sets the specified 4-dimensional vector to the supplied numerical values.
     *
     * @param {number} x - The value to set on the first component of the vector.
     * @param {number} y - The value to set on the second component of the vector.
     * @param {number} z - The value to set on the third component of the vector.
     * @param {number} w - The value to set on the fourth component of the vector.
     * @returns {Vec4} Self for chaining.
     * @example
     * var v = new pc.Vec4();
     * v.set(5, 10, 20, 40);
     *
     * // Outputs 5, 10, 20, 40
     * console.log("The result of the vector set is: " + v.toString());
     */
    set(x: number, y: number, z: number, w: number): Vec4;
    /**
     * Subtracts a 4-dimensional vector from another in place.
     *
     * @param {Vec4} rhs - The vector to add to the specified vector.
     * @returns {Vec4} Self for chaining.
     * @example
     * var a = new pc.Vec4(10, 10, 10, 10);
     * var b = new pc.Vec4(20, 20, 20, 20);
     *
     * a.sub(b);
     *
     * // Outputs [-10, -10, -10, -10]
     * console.log("The result of the subtraction is: " + a.toString());
     */
    sub(rhs: Vec4): Vec4;
    /**
     * Subtracts two 4-dimensional vectors from one another and returns the result.
     *
     * @param {Vec4} lhs - The first vector operand for the subtraction.
     * @param {Vec4} rhs - The second vector operand for the subtraction.
     * @returns {Vec4} Self for chaining.
     * @example
     * var a = new pc.Vec4(10, 10, 10, 10);
     * var b = new pc.Vec4(20, 20, 20, 20);
     * var r = new pc.Vec4();
     *
     * r.sub2(a, b);
     *
     * // Outputs [-10, -10, -10, -10]
     * console.log("The result of the subtraction is: " + r.toString());
     */
    sub2(lhs: Vec4, rhs: Vec4): Vec4;
    /**
     * Subtracts a number from each element of a vector.
     *
     * @param {number} scalar - The number to subtract.
     * @returns {Vec4} Self for chaining.
     * @example
     * var vec = new pc.Vec4(3, 4, 5, 6);
     *
     * vec.subScalar(2);
     *
     * // Outputs [1, 2, 3, 4]
     * console.log("The result of the subtraction is: " + vec.toString());
     */
    subScalar(scalar: number): Vec4;
    /**
     * Converts the vector to string form.
     *
     * @returns {string} The vector in string form.
     * @example
     * var v = new pc.Vec4(20, 10, 5, 0);
     * // Outputs [20, 10, 5, 0]
     * console.log(v.toString());
     */
    toString(): string;
}


/**
 * A 4x4 matrix.
 */
declare class Mat4 {
    static _getPerspectiveHalfSize(halfSize: any, fov: any, aspect: any, znear: any, fovIsHorizontal: any): void;
    /**
     * A constant matrix set to the identity.
     *
     * @type {Mat4}
     * @readonly
     */
    static readonly IDENTITY: Mat4;
    /**
     * A constant matrix with all elements set to 0.
     *
     * @type {Mat4}
     * @readonly
     */
    static readonly ZERO: Mat4;
    /**
     * Matrix elements in the form of a flat array.
     *
     * @type {Float32Array}
     */
    data: Float32Array;
    /**
     * Adds the specified 4x4 matrices together and stores the result in the current instance.
     *
     * @param {Mat4} lhs - The 4x4 matrix used as the first operand of the addition.
     * @param {Mat4} rhs - The 4x4 matrix used as the second operand of the addition.
     * @returns {Mat4} Self for chaining.
     * @example
     * var m = new pc.Mat4();
     *
     * m.add2(pc.Mat4.IDENTITY, pc.Mat4.ONE);
     *
     * console.log("The result of the addition is: " + m.toString());
     */
    add2(lhs: Mat4, rhs: Mat4): Mat4;
    /**
     * Adds the specified 4x4 matrix to the current instance.
     *
     * @param {Mat4} rhs - The 4x4 matrix used as the second operand of the addition.
     * @returns {Mat4} Self for chaining.
     * @example
     * var m = new pc.Mat4();
     *
     * m.add(pc.Mat4.ONE);
     *
     * console.log("The result of the addition is: " + m.toString());
     */
    add(rhs: Mat4): Mat4;
    /**
     * Creates a duplicate of the specified matrix.
     *
     * @returns {this} A duplicate matrix.
     * @example
     * var src = new pc.Mat4().setFromEulerAngles(10, 20, 30);
     * var dst = src.clone();
     * console.log("The two matrices are " + (src.equals(dst) ? "equal" : "different"));
     */
    clone(): this;
    /**
     * Copies the contents of a source 4x4 matrix to a destination 4x4 matrix.
     *
     * @param {Mat4} rhs - A 4x4 matrix to be copied.
     * @returns {Mat4} Self for chaining.
     * @example
     * var src = new pc.Mat4().setFromEulerAngles(10, 20, 30);
     * var dst = new pc.Mat4();
     * dst.copy(src);
     * console.log("The two matrices are " + (src.equals(dst) ? "equal" : "different"));
     */
    copy(rhs: Mat4): Mat4;
    /**
     * Reports whether two matrices are equal.
     *
     * @param {Mat4} rhs - The other matrix.
     * @returns {boolean} True if the matrices are equal and false otherwise.
     * @example
     * var a = new pc.Mat4().setFromEulerAngles(10, 20, 30);
     * var b = new pc.Mat4();
     * console.log("The two matrices are " + (a.equals(b) ? "equal" : "different"));
     */
    equals(rhs: Mat4): boolean;
    /**
     * Reports whether the specified matrix is the identity matrix.
     *
     * @returns {boolean} True if the matrix is identity and false otherwise.
     * @example
     * var m = new pc.Mat4();
     * console.log("The matrix is " + (m.isIdentity() ? "identity" : "not identity"));
     */
    isIdentity(): boolean;
    /**
     * Multiplies the specified 4x4 matrices together and stores the result in the current
     * instance.
     *
     * @param {Mat4} lhs - The 4x4 matrix used as the first multiplicand of the operation.
     * @param {Mat4} rhs - The 4x4 matrix used as the second multiplicand of the operation.
     * @returns {Mat4} Self for chaining.
     * @example
     * var a = new pc.Mat4().setFromEulerAngles(10, 20, 30);
     * var b = new pc.Mat4().setFromAxisAngle(pc.Vec3.UP, 180);
     * var r = new pc.Mat4();
     *
     * // r = a * b
     * r.mul2(a, b);
     *
     * console.log("The result of the multiplication is: " + r.toString());
     */
    mul2(lhs: Mat4, rhs: Mat4): Mat4;
    /**
     * Multiplies the specified 4x4 matrices together and stores the result in the current
     * instance. This function assumes the matrices are affine transformation matrices, where the
     * upper left 3x3 elements are a rotation matrix, and the bottom left 3 elements are
     * translation. The rightmost column is assumed to be [0, 0, 0, 1]. The parameters are not
     * verified to be in the expected format. This function is faster than general
     * {@link Mat4#mul2}.
     *
     * @param {Mat4} lhs - The affine transformation 4x4 matrix used as the first multiplicand of
     * the operation.
     * @param {Mat4} rhs - The affine transformation 4x4 matrix used as the second multiplicand of
     * the operation.
     * @returns {Mat4} Self for chaining.
     */
    mulAffine2(lhs: Mat4, rhs: Mat4): Mat4;
    /**
     * Multiplies the current instance by the specified 4x4 matrix.
     *
     * @param {Mat4} rhs - The 4x4 matrix used as the second multiplicand of the operation.
     * @returns {Mat4} Self for chaining.
     * @example
     * var a = new pc.Mat4().setFromEulerAngles(10, 20, 30);
     * var b = new pc.Mat4().setFromAxisAngle(pc.Vec3.UP, 180);
     *
     * // a = a * b
     * a.mul(b);
     *
     * console.log("The result of the multiplication is: " + a.toString());
     */
    mul(rhs: Mat4): Mat4;
    /**
     * Transforms a 3-dimensional point by a 4x4 matrix.
     *
     * @param {Vec3} vec - The 3-dimensional point to be transformed.
     * @param {Vec3} [res] - An optional 3-dimensional point to receive the result of the
     * transformation.
     * @returns {Vec3} The input point v transformed by the current instance.
     * @example
     * // Create a 3-dimensional point
     * var v = new pc.Vec3(1, 2, 3);
     *
     * // Create a 4x4 rotation matrix
     * var m = new pc.Mat4().setFromEulerAngles(10, 20, 30);
     *
     * var tv = m.transformPoint(v);
     */
    transformPoint(vec: Vec3, res?: Vec3): Vec3;
    /**
     * Transforms a 3-dimensional vector by a 4x4 matrix.
     *
     * @param {Vec3} vec - The 3-dimensional vector to be transformed.
     * @param {Vec3} [res] - An optional 3-dimensional vector to receive the result of the
     * transformation.
     * @returns {Vec3} The input vector v transformed by the current instance.
     * @example
     * // Create a 3-dimensional vector
     * var v = new pc.Vec3(1, 2, 3);
     *
     * // Create a 4x4 rotation matrix
     * var m = new pc.Mat4().setFromEulerAngles(10, 20, 30);
     *
     * var tv = m.transformVector(v);
     */
    transformVector(vec: Vec3, res?: Vec3): Vec3;
    /**
     * Transforms a 4-dimensional vector by a 4x4 matrix.
     *
     * @param {Vec4} vec - The 4-dimensional vector to be transformed.
     * @param {Vec4} [res] - An optional 4-dimensional vector to receive the result of the
     * transformation.
     * @returns {Vec4} The input vector v transformed by the current instance.
     * @example
     * // Create an input 4-dimensional vector
     * var v = new pc.Vec4(1, 2, 3, 4);
     *
     * // Create an output 4-dimensional vector
     * var result = new pc.Vec4();
     *
     * // Create a 4x4 rotation matrix
     * var m = new pc.Mat4().setFromEulerAngles(10, 20, 30);
     *
     * m.transformVec4(v, result);
     */
    transformVec4(vec: Vec4, res?: Vec4): Vec4;
    /**
     * Sets the specified matrix to a viewing matrix derived from an eye point, a target point and
     * an up vector. The matrix maps the target point to the negative z-axis and the eye point to
     * the origin, so that when you use a typical projection matrix, the center of the scene maps
     * to the center of the viewport. Similarly, the direction described by the up vector projected
     * onto the viewing plane is mapped to the positive y-axis so that it points upward in the
     * viewport. The up vector must not be parallel to the line of sight from the eye to the
     * reference point.
     *
     * @param {Vec3} position - 3-d vector holding view position.
     * @param {Vec3} target - 3-d vector holding reference point.
     * @param {Vec3} up - 3-d vector holding the up direction.
     * @returns {Mat4} Self for chaining.
     * @example
     * var position = new pc.Vec3(10, 10, 10);
     * var target = new pc.Vec3(0, 0, 0);
     * var up = new pc.Vec3(0, 1, 0);
     * var m = new pc.Mat4().setLookAt(position, target, up);
     */
    setLookAt(position: Vec3, target: Vec3, up: Vec3): Mat4;
    /**
     * Sets the specified matrix to a perspective projection matrix. The function's parameters
     * define the shape of a frustum.
     *
     * @param {number} left - The x-coordinate for the left edge of the camera's projection plane
     * in eye space.
     * @param {number} right - The x-coordinate for the right edge of the camera's projection plane
     * in eye space.
     * @param {number} bottom - The y-coordinate for the bottom edge of the camera's projection
     * plane in eye space.
     * @param {number} top - The y-coordinate for the top edge of the camera's projection plane in
     * eye space.
     * @param {number} znear - The near clip plane in eye coordinates.
     * @param {number} zfar - The far clip plane in eye coordinates.
     * @returns {Mat4} Self for chaining.
     * @example
     * // Create a 4x4 perspective projection matrix
     * var f = pc.Mat4().setFrustum(-2, 2, -1, 1, 1, 1000);
     * @ignore
     */
    setFrustum(left: number, right: number, bottom: number, top: number, znear: number, zfar: number): Mat4;
    /**
     * Sets the specified matrix to a perspective projection matrix. The function's parameters
     * define the shape of a frustum.
     *
     * @param {number} fov - The frustum's field of view in degrees. The fovIsHorizontal parameter
     * controls whether this is a vertical or horizontal field of view. By default, it's a vertical
     * field of view.
     * @param {number} aspect - The aspect ratio of the frustum's projection plane
     * (width / height).
     * @param {number} znear - The near clip plane in eye coordinates.
     * @param {number} zfar - The far clip plane in eye coordinates.
     * @param {boolean} [fovIsHorizontal=false] - Set to true to treat the fov as horizontal
     * (x-axis) and false for vertical (y-axis). Defaults to false.
     * @returns {Mat4} Self for chaining.
     * @example
     * // Create a 4x4 perspective projection matrix
     * var persp = pc.Mat4().setPerspective(45, 16 / 9, 1, 1000);
     */
    setPerspective(fov: number, aspect: number, znear: number, zfar: number, fovIsHorizontal?: boolean): Mat4;
    /**
     * Sets the specified matrix to an orthographic projection matrix. The function's parameters
     * define the shape of a cuboid-shaped frustum.
     *
     * @param {number} left - The x-coordinate for the left edge of the camera's projection plane
     * in eye space.
     * @param {number} right - The x-coordinate for the right edge of the camera's projection plane
     * in eye space.
     * @param {number} bottom - The y-coordinate for the bottom edge of the camera's projection
     * plane in eye space.
     * @param {number} top - The y-coordinate for the top edge of the camera's projection plane in
     * eye space.
     * @param {number} near - The near clip plane in eye coordinates.
     * @param {number} far - The far clip plane in eye coordinates.
     * @returns {Mat4} Self for chaining.
     * @example
     * // Create a 4x4 orthographic projection matrix
     * var ortho = pc.Mat4().ortho(-2, 2, -2, 2, 1, 1000);
     */
    setOrtho(left: number, right: number, bottom: number, top: number, near: number, far: number): Mat4;
    /**
     * Sets the specified matrix to a rotation matrix equivalent to a rotation around an axis. The
     * axis must be normalized (unit length) and the angle must be specified in degrees.
     *
     * @param {Vec3} axis - The normalized axis vector around which to rotate.
     * @param {number} angle - The angle of rotation in degrees.
     * @returns {Mat4} Self for chaining.
     * @example
     * // Create a 4x4 rotation matrix
     * var rm = new pc.Mat4().setFromAxisAngle(pc.Vec3.UP, 90);
     */
    setFromAxisAngle(axis: Vec3, angle: number): Mat4;
    /**
     * Sets the specified matrix to a translation matrix.
     *
     * @param {number} x - The x-component of the translation.
     * @param {number} y - The y-component of the translation.
     * @param {number} z - The z-component of the translation.
     * @returns {Mat4} Self for chaining.
     * @example
     * // Create a 4x4 translation matrix
     * var tm = new pc.Mat4().setTranslate(10, 10, 10);
     * @ignore
     */
    setTranslate(x: number, y: number, z: number): Mat4;
    /**
     * Sets the specified matrix to a scale matrix.
     *
     * @param {number} x - The x-component of the scale.
     * @param {number} y - The y-component of the scale.
     * @param {number} z - The z-component of the scale.
     * @returns {Mat4} Self for chaining.
     * @example
     * // Create a 4x4 scale matrix
     * var sm = new pc.Mat4().setScale(10, 10, 10);
     * @ignore
     */
    setScale(x: number, y: number, z: number): Mat4;
    /**
     * Sets the specified matrix to a matrix transforming a normalized view volume (in range of
     * -1 .. 1) to their position inside a viewport (in range of 0 .. 1). This encapsulates a
     * scaling to the size of the viewport and a translation to the position of the viewport.
     *
     * @param {number} x - The x-component of the position of the viewport (in 0..1 range).
     * @param {number} y - The y-component of the position of the viewport (in 0..1 range).
     * @param {number} width - The width of the viewport (in 0..1 range).
     * @param {number} height - The height of the viewport (in 0..1 range).
     * @returns {Mat4} Self for chaining.
     * @example
     * // Create a 4x4 viewport matrix which scales normalized view volume to full texture viewport
     * var vm = new pc.Mat4().setViewport(0, 0, 1, 1);
     * @ignore
     */
    setViewport(x: number, y: number, width: number, height: number): Mat4;
    /**
     * Sets the specified matrix to its inverse.
     *
     * @returns {Mat4} Self for chaining.
     * @example
     * // Create a 4x4 rotation matrix of 180 degrees around the y-axis
     * var rot = new pc.Mat4().setFromAxisAngle(pc.Vec3.UP, 180);
     *
     * // Invert in place
     * rot.invert();
     */
    invert(): Mat4;
    /**
     * Sets matrix data from an array.
     *
     * @param {number[]} src - Source array. Must have 16 values.
     * @returns {Mat4} Self for chaining.
     */
    set(src: number[]): Mat4;
    /**
     * Sets the specified matrix to the identity matrix.
     *
     * @returns {Mat4} Self for chaining.
     * @example
     * m.setIdentity();
     * console.log("The matrix is " + (m.isIdentity() ? "identity" : "not identity"));
     */
    setIdentity(): Mat4;
    /**
     * Sets the specified matrix to the concatenation of a translation, a quaternion rotation and a
     * scale.
     *
     * @param {Vec3} t - A 3-d vector translation.
     * @param {Quat} r - A quaternion rotation.
     * @param {Vec3} s - A 3-d vector scale.
     * @returns {Mat4} Self for chaining.
     * @example
     * var t = new pc.Vec3(10, 20, 30);
     * var r = new pc.Quat();
     * var s = new pc.Vec3(2, 2, 2);
     *
     * var m = new pc.Mat4();
     * m.setTRS(t, r, s);
     */
    setTRS(t: Vec3, r: Quat, s: Vec3): Mat4;
    /**
     * Sets the specified matrix to its transpose.
     *
     * @returns {Mat4} Self for chaining.
     * @example
     * var m = new pc.Mat4();
     *
     * // Transpose in place
     * m.transpose();
     */
    transpose(): Mat4;
    invertTo3x3(res: any): Mat4;
    /**
     * Extracts the translational component from the specified 4x4 matrix.
     *
     * @param {Vec3} [t] - The vector to receive the translation of the matrix.
     * @returns {Vec3} The translation of the specified 4x4 matrix.
     * @example
     * // Create a 4x4 matrix
     * var m = new pc.Mat4();
     *
     * // Query the z-axis component
     * var t = new pc.Vec3();
     * m.getTranslation(t);
     */
    getTranslation(t?: Vec3): Vec3;
    /**
     * Extracts the x-axis from the specified 4x4 matrix.
     *
     * @param {Vec3} [x] - The vector to receive the x axis of the matrix.
     * @returns {Vec3} The x-axis of the specified 4x4 matrix.
     * @example
     * // Create a 4x4 matrix
     * var m = new pc.Mat4();
     *
     * // Query the z-axis component
     * var x = new pc.Vec3();
     * m.getX(x);
     */
    getX(x?: Vec3): Vec3;
    /**
     * Extracts the y-axis from the specified 4x4 matrix.
     *
     * @param {Vec3} [y] - The vector to receive the y axis of the matrix.
     * @returns {Vec3} The y-axis of the specified 4x4 matrix.
     * @example
     * // Create a 4x4 matrix
     * var m = new pc.Mat4();
     *
     * // Query the z-axis component
     * var y = new pc.Vec3();
     * m.getY(y);
     */
    getY(y?: Vec3): Vec3;
    /**
     * Extracts the z-axis from the specified 4x4 matrix.
     *
     * @param {Vec3} [z] - The vector to receive the z axis of the matrix.
     * @returns {Vec3} The z-axis of the specified 4x4 matrix.
     * @example
     * // Create a 4x4 matrix
     * var m = new pc.Mat4();
     *
     * // Query the z-axis component
     * var z = new pc.Vec3();
     * m.getZ(z);
     */
    getZ(z?: Vec3): Vec3;
    /**
     * Extracts the scale component from the specified 4x4 matrix.
     *
     * @param {Vec3} [scale] - Vector to receive the scale.
     * @returns {Vec3} The scale in X, Y and Z of the specified 4x4 matrix.
     * @example
     * // Query the scale component
     * var scale = m.getScale();
     */
    getScale(scale?: Vec3): Vec3;
    /**
     * Sets the specified matrix to a rotation matrix defined by Euler angles. The Euler angles are
     * specified in XYZ order and in degrees.
     *
     * @param {number} ex - Angle to rotate around X axis in degrees.
     * @param {number} ey - Angle to rotate around Y axis in degrees.
     * @param {number} ez - Angle to rotate around Z axis in degrees.
     * @returns {Mat4} Self for chaining.
     * @example
     * var m = new pc.Mat4();
     * m.setFromEulerAngles(45, 90, 180);
     */
    setFromEulerAngles(ex: number, ey: number, ez: number): Mat4;
    /**
     * Extracts the Euler angles equivalent to the rotational portion of the specified matrix. The
     * returned Euler angles are in XYZ order an in degrees.
     *
     * @param {Vec3} [eulers] - A 3-d vector to receive the Euler angles.
     * @returns {Vec3} A 3-d vector containing the Euler angles.
     * @example
     * // Create a 4x4 rotation matrix of 45 degrees around the y-axis
     * var m = new pc.Mat4().setFromAxisAngle(pc.Vec3.UP, 45);
     *
     * var eulers = m.getEulerAngles();
     */
    getEulerAngles(eulers?: Vec3): Vec3;
    /**
     * Converts the specified matrix to string form.
     *
     * @returns {string} The matrix in string form.
     * @example
     * var m = new pc.Mat4();
     * // Outputs [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
     * console.log(m.toString());
     */
    toString(): string;
}




/**
 * Axis-Aligned Bounding Box.
 */
declare class BoundingBox {
    /**
     * Create a new BoundingBox instance. The bounding box is axis-aligned.
     *
     * @param {Vec3} [center] - Center of box. The constructor takes a reference of this parameter.
     * @param {Vec3} [halfExtents] - Half the distance across the box in each axis. The constructor
     * takes a reference of this parameter. Defaults to 0.5 on each axis.
     */
    constructor(center?: Vec3, halfExtents?: Vec3);
    /**
     * Center of box.
     *
     * @type {Vec3}
     */
    center: Vec3;
    /**
     * Half the distance across the box in each axis.
     *
     * @type {Vec3}
     */
    halfExtents: Vec3;
    /**
     * @type {Vec3}
     * @private
     */
    private _min;
    /**
     * @type {Vec3}
     * @private
     */
    private _max;
    /**
     * Combines two bounding boxes into one, enclosing both.
     *
     * @param {BoundingBox} other - Bounding box to add.
     */
    add(other: BoundingBox): void;
    /**
     * Copies the contents of a source AABB.
     *
     * @param {BoundingBox} src - The AABB to copy from.
     */
    copy(src: BoundingBox): void;
    /**
     * Returns a clone of the AABB.
     *
     * @returns {BoundingBox} A duplicate AABB.
     */
    clone(): BoundingBox;
    /**
     * Test whether two axis-aligned bounding boxes intersect.
     *
     * @param {BoundingBox} other - Bounding box to test against.
     * @returns {boolean} True if there is an intersection.
     */
    intersects(other: BoundingBox): boolean;
    _intersectsRay(ray: any, point: any): boolean;
    _fastIntersectsRay(ray: any): boolean;
    /**
     * Test if a ray intersects with the AABB.
     *
     * @param {Ray} ray - Ray to test against (direction must be normalized).
     * @param {Vec3} [point] - If there is an intersection, the intersection point will be copied into here.
     * @returns {boolean} True if there is an intersection.
     */
    intersectsRay(ray: Ray, point?: Vec3): boolean;
    /**
     * Sets the minimum and maximum corner of the AABB. Using this function is faster than
     * assigning min and max separately.
     *
     * @param {Vec3} min - The minimum corner of the AABB.
     * @param {Vec3} max - The maximum corner of the AABB.
     */
    setMinMax(min: Vec3, max: Vec3): void;
    /**
     * Return the minimum corner of the AABB.
     *
     * @returns {Vec3} Minimum corner.
     */
    getMin(): Vec3;
    /**
     * Return the maximum corner of the AABB.
     *
     * @returns {Vec3} Maximum corner.
     */
    getMax(): Vec3;
    /**
     * Test if a point is inside a AABB.
     *
     * @param {Vec3} point - Point to test.
     * @returns {boolean} True if the point is inside the AABB and false otherwise.
     */
    containsPoint(point: Vec3): boolean;
    /**
     * Set an AABB to enclose the specified AABB if it were to be transformed by the specified 4x4
     * matrix.
     *
     * @param {BoundingBox} aabb - Box to transform and enclose.
     * @param {Mat4} m - Transformation matrix to apply to source AABB.
     * @param {boolean} ignoreScale - If true is specified, a scale from the matrix is ignored. Defaults to false.
     */
    setFromTransformedAabb(aabb: BoundingBox, m: Mat4, ignoreScale?: boolean): void;
    /**
     * Compute the size of the AABB to encapsulate all specified vertices.
     *
     * @param {number[]|Float32Array} vertices - The vertices used to compute the new size for the
     * AABB.
     * @param {number} [numVerts] - Number of vertices to use from the beginning of vertices array.
     * All vertices are used if not specified.
     */
    compute(vertices: number[] | Float32Array, numVerts?: number): void;
    /**
     * Test if a Bounding Sphere is overlapping, enveloping, or inside this AABB.
     *
     * @param {BoundingSphere} sphere - Bounding Sphere to test.
     * @returns {boolean} True if the Bounding Sphere is overlapping, enveloping, or inside the
     * AABB and false otherwise.
     */
    intersectsBoundingSphere(sphere: BoundingSphere): boolean;
    _distanceToBoundingSphereSq(sphere: any): number;
    _expand(expandMin: any, expandMax: any): void;
}


/**
 * An infinite plane.
 *
 * @ignore
 */
declare class Plane {
    /**
     * Create a new Plane instance.
     *
     * @param {Vec3} [point] - Point position on the plane. The constructor takes a reference of
     * this parameter.
     * @param {Vec3} [normal] - Normal of the plane. The constructor takes a reference of this
     * parameter.
     */
    constructor(point?: Vec3, normal?: Vec3);
    normal: Vec3;
    point: Vec3;
    /**
     * Test if the plane intersects between two points.
     *
     * @param {Vec3} start - Start position of line.
     * @param {Vec3} end - End position of line.
     * @param {Vec3} [point] - If there is an intersection, the intersection point will be copied
     * into here.
     * @returns {boolean} True if there is an intersection.
     */
    intersectsLine(start: Vec3, end: Vec3, point?: Vec3): boolean;
    /**
     * Test if a ray intersects with the infinite plane.
     *
     * @param {Ray} ray - Ray to test against (direction must be normalized).
     * @param {Vec3} [point] - If there is an intersection, the intersection point will be copied
     * into here.
     * @returns {boolean} True if there is an intersection.
     */
    intersectsRay(ray: Ray, point?: Vec3): boolean;
}

declare function begin(): string;
declare function end(): string;
declare function dummyFragmentCode(): string;
declare function fogCode(value: any, chunks: any): any;
declare function gammaCode(value: any, chunks: any): any;
declare function precisionCode(device: any): string;
declare function skinCode(device: any, chunks: any): any;
declare function tonemapCode(value: any, chunks: any): any;
declare function versionCode(device: any): "" | "#version 300 es\n";


/**
 * A shader is a program that is responsible for rendering graphical primitives on a device's
 * graphics processor. The shader is generated from a shader definition. This shader definition
 * specifies the code for processing vertices and fragments processed by the GPU. The language of
 * the code is GLSL (or more specifically ESSL, the OpenGL ES Shading Language). The shader
 * definition also describes how the PlayCanvas engine should map vertex buffer elements onto the
 * attributes specified in the vertex shader code.
 */
declare class Shader {
    /**
     * Creates a new Shader instance.
     *
     * @param {GraphicsDevice} graphicsDevice - The graphics device used to manage this shader.
     * @param {object} definition - The shader definition from which to build the shader.
     * @param {string} [definition.name] - The name of the shader.
     * @param {Object<string, string>} definition.attributes - Object detailing the mapping of
     * vertex shader attribute names to semantics SEMANTIC_*. This enables the engine to match
     * vertex buffer data as inputs to the shader.
     * @param {string} definition.vshader - Vertex shader source (GLSL code).
     * @param {string} definition.fshader - Fragment shader source (GLSL code).
     * @param {boolean} [definition.useTransformFeedback] - Specifies that this shader outputs
     * post-VS data to a buffer.
     * @example
     * // Create a shader that renders primitives with a solid red color
     * var shaderDefinition = {
     *     attributes: {
     *         aPosition: pc.SEMANTIC_POSITION
     *     },
     *     vshader: [
     *         "attribute vec3 aPosition;",
     *         "",
     *         "void main(void)",
     *         "{",
     *         "    gl_Position = vec4(aPosition, 1.0);",
     *         "}"
     *     ].join("\n"),
     *     fshader: [
     *         "precision " + graphicsDevice.precision + " float;",
     *         "",
     *         "void main(void)",
     *         "{",
     *         "    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);",
     *         "}"
     *     ].join("\n")
     * };
     *
     * var shader = new pc.Shader(graphicsDevice, shaderDefinition);
     */
    constructor(graphicsDevice: GraphicsDevice, definition: {
        name?: string;
        attributes: {
            [x: string]: string;
        };
        vshader: string;
        fshader: string;
        useTransformFeedback?: boolean;
    });
    id: number;
    device: GraphicsDevice;
    definition: {
        name?: string;
        attributes: {
            [x: string]: string;
        };
        vshader: string;
        fshader: string;
        useTransformFeedback?: boolean;
    };
    name: string;
    impl: any;
    /**
     * Initialize a shader back to its default state.
     *
     * @private
     */
    private init;
    ready: boolean;
    failed: boolean;
    /**
     * Frees resources associated with this shader.
     */
    destroy(): void;
    /**
     * Called when the WebGL context was lost. It releases all context related resources.
     *
     * @ignore
     */
    loseContext(): void;
    restoreContext(): void;
}


/**
 * A render target is a rectangular rendering surface.
 */
declare class RenderTarget {
    /**
     * Creates a new RenderTarget instance. A color buffer or a depth buffer must be set.
     *
     * @param {object} options - Object for passing optional arguments.
     * @param {boolean} [options.autoResolve] - If samples > 1, enables or disables automatic MSAA
     * resolve after rendering to this RT (see {@link RenderTarget#resolve}). Defaults to true.
     * @param {Texture} [options.colorBuffer] - The texture that this render target will treat as a
     * rendering surface.
     * @param {boolean} [options.depth] - If set to true, depth buffer will be created. Defaults to
     * true. Ignored if depthBuffer is defined.
     * @param {Texture} [options.depthBuffer] - The texture that this render target will treat as a
     * depth/stencil surface (WebGL2 only). If set, the 'depth' and 'stencil' properties are
     * ignored. Texture must have {@link PIXELFORMAT_DEPTH} or {@link PIXELFORMAT_DEPTHSTENCIL}
     * format.
     * @param {number} [options.face] - If the colorBuffer parameter is a cubemap, use this option
     * to specify the face of the cubemap to render to. Can be:
     *
     * - {@link CUBEFACE_POSX}
     * - {@link CUBEFACE_NEGX}
     * - {@link CUBEFACE_POSY}
     * - {@link CUBEFACE_NEGY}
     * - {@link CUBEFACE_POSZ}
     * - {@link CUBEFACE_NEGZ}
     *
     * Defaults to {@link CUBEFACE_POSX}.
     * @param {boolean} [options.flipY] - When set to true the image will be flipped in Y. Default
     * is false.
     * @param {string} [options.name] - The name of the render target.
     * @param {number} [options.samples] - Number of hardware anti-aliasing samples (WebGL2 only).
     * Default is 1.
     * @param {boolean} [options.stencil] - If set to true, depth buffer will include stencil.
     * Defaults to false. Ignored if depthBuffer is defined or depth is false.
     * @example
     * // Create a 512x512x24-bit render target with a depth buffer
     * var colorBuffer = new pc.Texture(graphicsDevice, {
     *     width: 512,
     *     height: 512,
     *     format: pc.PIXELFORMAT_R8_G8_B8
     * });
     * var renderTarget = new pc.RenderTarget({
     *     colorBuffer: colorBuffer,
     *     depth: true
     * });
     *
     * // Set the render target on a camera component
     * camera.renderTarget = renderTarget;
     *
     * // Destroy render target at a later stage. Note that the color buffer needs
     * // to be destroyed separately.
     * renderTarget.colorBuffer.destroy();
     * renderTarget.destroy();
     * camera.renderTarget = null;
     */
    constructor(options: {
        autoResolve?: boolean;
        colorBuffer?: Texture;
        depth?: boolean;
        depthBuffer?: Texture;
        face?: number;
        flipY?: boolean;
        name?: string;
        samples?: number;
        stencil?: boolean;
    }, ...args: any[]);
    id: number;
    _colorBuffer: any;
    _depthBuffer: Texture;
    _face: number;
    _depth: boolean;
    _stencil: boolean;
    _device: any;
    _samples: number;
    autoResolve: boolean;
    name: any;
    flipY: boolean;
    impl: any;
    /**
     * Frees resources associated with this render target.
     */
    destroy(): void;
    /**
     * Free device resources associated with this render target.
     *
     * @ignore
     */
    destroyFrameBuffers(): void;
    /**
     * Free textures associated with this render target.
     *
     * @ignore
     */
    destroyTextureBuffers(): void;
    /**
     * Initialises the resources associated with this render target.
     *
     * @ignore
     */
    init(): void;
    /**
     * Called when the device context was lost. It releases all context related resources.
     *
     * @ignore
     */
    loseContext(): void;
    /**
     * If samples > 1, resolves the anti-aliased render target (WebGL2 only). When you're rendering
     * to an anti-aliased render target, pixels aren't written directly to the readable texture.
     * Instead, they're first written to a MSAA buffer, where each sample for each pixel is stored
     * independently. In order to read the results, you first need to 'resolve' the buffer - to
     * average all samples and create a simple texture with one color per pixel. This function
     * performs this averaging and updates the colorBuffer and the depthBuffer. If autoResolve is
     * set to true, the resolve will happen after every rendering to this render target, otherwise
     * you can do it manually, during the app update or inside a {@link Command}.
     *
     * @param {boolean} [color] - Resolve color buffer. Defaults to true.
     * @param {boolean} [depth] - Resolve depth buffer. Defaults to true if the render target has a
     * depth buffer.
     */
    resolve(color?: boolean, depth?: boolean): void;
    /**
     * Copies color and/or depth contents of source render target to this one. Formats, sizes and
     * anti-aliasing samples must match. Depth buffer can only be copied on WebGL 2.0.
     *
     * @param {RenderTarget} source - Source render target to copy from.
     * @param {boolean} [color] - If true will copy the color buffer. Defaults to false.
     * @param {boolean} [depth] - If true will copy the depth buffer. Defaults to false.
     * @returns {boolean} True if the copy was successful, false otherwise.
     */
    copy(source: RenderTarget, color?: boolean, depth?: boolean): boolean;
    /**
     * Number of antialiasing samples the render target uses.
     *
     * @type {number}
     */
    get samples(): number;
    /**
     * True if the render target contains the depth attachment.
     *
     * @type {boolean}
     */
    get depth(): boolean;
    /**
     * True if the render target contains the stencil attachment.
     *
     * @type {boolean}
     */
    get stencil(): boolean;
    /**
     * Color buffer set up on the render target.
     *
     * @type {Texture}
     */
    get colorBuffer(): Texture;
    /**
     * Depth buffer set up on the render target. Only available, if depthBuffer was set in
     * constructor. Not available if depth property was used instead.
     *
     * @type {Texture}
     */
    get depthBuffer(): Texture;
    /**
     * If the render target is bound to a cubemap, this property specifies which face of the
     * cubemap is rendered to. Can be:
     *
     * - {@link CUBEFACE_POSX}
     * - {@link CUBEFACE_NEGX}
     * - {@link CUBEFACE_POSY}
     * - {@link CUBEFACE_NEGY}
     * - {@link CUBEFACE_POSZ}
     * - {@link CUBEFACE_NEGZ}
     *
     * @type {number}
     */
    get face(): number;
    /**
     * Width of the render target in pixels.
     *
     * @type {number}
     */
    get width(): number;
    /**
     * Height of the render target in pixels.
     *
     * @type {number}
     */
    get height(): number;
}

/**
 * Callback used by {@link EventHandler } functions. Note the callback is limited to 8 arguments.
 */
export type HandleEventCallback = (arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any) => any;
/**
 * Callback used by {@link EventHandler} functions. Note the callback is limited to 8 arguments.
 *
 * @callback HandleEventCallback
 * @param {*} [arg1] - First argument that is passed from caller.
 * @param {*} [arg2] - Second argument that is passed from caller.
 * @param {*} [arg3] - Third argument that is passed from caller.
 * @param {*} [arg4] - Fourth argument that is passed from caller.
 * @param {*} [arg5] - Fifth argument that is passed from caller.
 * @param {*} [arg6] - Sixth argument that is passed from caller.
 * @param {*} [arg7] - Seventh argument that is passed from caller.
 * @param {*} [arg8] - Eighth argument that is passed from caller.
 */
/**
 * Abstract base class that implements functionality for event handling.
 */
declare class EventHandler {
    /**
     * @type {object}
     * @private
     */
    private _callbacks;
    /**
     * @type {object}
     * @private
     */
    private _callbackActive;
    /**
     * Reinitialize the event handler.
     *
     * @private
     */
    private initEventHandler;
    /**
     * Registers a new event handler.
     *
     * @param {string} name - Name of the event to bind the callback to.
     * @param {HandleEventCallback} callback - Function that is called when event is fired. Note
     * the callback is limited to 8 arguments.
     * @param {object} [scope] - Object to use as 'this' when the event is fired, defaults to
     * current this.
     * @param {boolean} [once=false] - If true, the callback will be unbound after being fired once.
     * @private
     */
    private _addCallback;
    /**
     * Attach an event handler to an event.
     *
     * @param {string} name - Name of the event to bind the callback to.
     * @param {HandleEventCallback} callback - Function that is called when event is fired. Note
     * the callback is limited to 8 arguments.
     * @param {object} [scope] - Object to use as 'this' when the event is fired, defaults to
     * current this.
     * @returns {EventHandler} Self for chaining.
     * @example
     * obj.on('test', function (a, b) {
     *     console.log(a + b);
     * });
     * obj.fire('test', 1, 2); // prints 3 to the console
     */
    on(name: string, callback: HandleEventCallback, scope?: object): EventHandler;
    /**
     * Detach an event handler from an event. If callback is not provided then all callbacks are
     * unbound from the event, if scope is not provided then all events with the callback will be
     * unbound.
     *
     * @param {string} [name] - Name of the event to unbind.
     * @param {HandleEventCallback} [callback] - Function to be unbound.
     * @param {object} [scope] - Scope that was used as the this when the event is fired.
     * @returns {EventHandler} Self for chaining.
     * @example
     * var handler = function () {
     * };
     * obj.on('test', handler);
     *
     * obj.off(); // Removes all events
     * obj.off('test'); // Removes all events called 'test'
     * obj.off('test', handler); // Removes all handler functions, called 'test'
     * obj.off('test', handler, this); // Removes all handler functions, called 'test' with scope this
     */
    off(name?: string, callback?: HandleEventCallback, scope?: object): EventHandler;
    /**
     * Fire an event, all additional arguments are passed on to the event listener.
     *
     * @param {string} name - Name of event to fire.
     * @param {*} [arg1] - First argument that is passed to the event handler.
     * @param {*} [arg2] - Second argument that is passed to the event handler.
     * @param {*} [arg3] - Third argument that is passed to the event handler.
     * @param {*} [arg4] - Fourth argument that is passed to the event handler.
     * @param {*} [arg5] - Fifth argument that is passed to the event handler.
     * @param {*} [arg6] - Sixth argument that is passed to the event handler.
     * @param {*} [arg7] - Seventh argument that is passed to the event handler.
     * @param {*} [arg8] - Eighth argument that is passed to the event handler.
     * @returns {EventHandler} Self for chaining.
     * @example
     * obj.fire('test', 'This is the message');
     */
    fire(name: string, arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any): EventHandler;
    /**
     * Attach an event handler to an event. This handler will be removed after being fired once.
     *
     * @param {string} name - Name of the event to bind the callback to.
     * @param {HandleEventCallback} callback - Function that is called when event is fired. Note
     * the callback is limited to 8 arguments.
     * @param {object} [scope] - Object to use as 'this' when the event is fired, defaults to
     * current this.
     * @returns {EventHandler} Self for chaining.
     * @example
     * obj.once('test', function (a, b) {
     *     console.log(a + b);
     * });
     * obj.fire('test', 1, 2); // prints 3 to the console
     * obj.fire('test', 1, 2); // not going to get handled
     */
    once(name: string, callback: HandleEventCallback, scope?: object): EventHandler;
    /**
     * Test if there are any handlers bound to an event name.
     *
     * @param {string} name - The name of the event to test.
     * @returns {boolean} True if the object has handlers bound to the specified event name.
     * @example
     * obj.on('test', function () { }); // bind an event to 'test'
     * obj.hasEvent('test'); // returns true
     * obj.hasEvent('hello'); // returns false
     */
    hasEvent(name: string): boolean;
}

declare class Version {
    globalId: number;
    revision: number;
    equals(other: any): boolean;
    copy(other: any): void;
    reset(): void;
}

declare class VersionedObject {
    version: Version;
    increment(): void;
}

/**
 * The scope for a variable.
 */
declare class ScopeId {
    /**
     * Create a new ScopeId instance.
     *
     * @param {string} name - The variable name.
     */
    constructor(name: string);
    /**
     * The variable name.
     *
     * @type {string}
     */
    name: string;
    value: any;
    versionObject: VersionedObject;
    /**
     * Set variable value.
     *
     * @param {*} value - The value.
     */
    setValue(value: any): void;
    /**
     * Get variable value.
     *
     * @returns {*} The value.
     */
    getValue(): any;
}

/**
 * The scope for variables.
 */
declare class ScopeSpace {
    /**
     * Create a new ScopeSpace instance.
     *
     * @param {string} name - The scope name.
     */
    constructor(name: string);
    /**
     * The scope name.
     *
     * @type {string}
     */
    name: string;
    variables: Map<any, any>;
    /**
     * Get (or create, if it doesn't already exist) a variable in the scope.
     *
     * @param {string} name - The variable name.
     * @returns {ScopeId} The variable instance.
     */
    resolve(name: string): ScopeId;
    /**
     * Clears value for any uniform with matching value (used to remove deleted textures).
     *
     * @param {*} value - The value to clear.
     * @ignore
     */
    removeValue(value: any): void;
}

/**
 * A class responsible for creation and caching of required shaders.
 * There is a two level cache. The first level generates the shader based on the provided options.
 * The second level processes this generated shader using processing options - in most cases
 * modifies it to support uniform buffers.
 *
 * @ignore
 */
declare class ProgramLibrary {
    constructor(device: any);
    /**
     * A cache of shaders processed using processing options.
     *
     * @type {Map<string, Shader>}
     */
    processedCache: Map<string, Shader>;
    _device: any;
    _cache: {};
    _generators: {};
    _isClearingCache: boolean;
    _precached: boolean;
    _programsCollection: any[];
    _defaultStdMatOption: {};
    _defaultStdMatOptionMin: {};
    register(name: any, generator: any): void;
    unregister(name: any): void;
    isRegistered(name: any): boolean;
    generateShader(generator: any, name: any, key: any, options: any): any;
    getProgram(name: any, options: any, processingOptions: any): Shader;
    storeNewProgram(name: any, options: any): void;
    dumpPrograms(): void;
    clearCache(): void;
    removeFromCache(shader: any): void;
    _getDefaultStdMatOptions(pass: any): {};
    precompile(cache: any): void;
}




/** @typedef {import('./render-target.js').RenderTarget} RenderTarget */
/** @typedef {import('./shader.js').Shader} Shader */
/** @typedef {import('./texture.js').Texture} Texture */
/**
 * The graphics device manages the underlying graphics context. It is responsible for submitting
 * render state changes and graphics primitives to the hardware. A graphics device is tied to a
 * specific canvas HTML element. It is valid to have more than one canvas element per page and
 * create a new graphics device against each.
 *
 * @augments EventHandler
 */
declare class GraphicsDevice extends EventHandler {
    constructor(canvas: any);
    /**
     * The canvas DOM element that provides the underlying WebGL context used by the graphics device.
     *
     * @type {HTMLCanvasElement}
     */
    canvas: HTMLCanvasElement;
    /**
     * The scope namespace for shader attributes and variables.
     *
     * @type {ScopeSpace}
     */
    scope: ScopeSpace;
    /**
     * The maximum supported texture anisotropy setting.
     *
     * @type {number}
     */
    maxAnisotropy: number;
    /**
     * The maximum supported dimension of a cube map.
     *
     * @type {number}
     */
    maxCubeMapSize: number;
    /**
     * The maximum supported dimension of a texture.
     *
     * @type {number}
     */
    maxTextureSize: number;
    /**
     * The maximum supported dimension of a 3D texture (any axis).
     *
     * @type {number}
     */
    maxVolumeSize: number;
    /**
     * The highest shader precision supported by this graphics device. Can be 'hiphp', 'mediump' or
     * 'lowp'.
     *
     * @type {string}
     */
    precision: string;
    /**
     * Currently active render target.
     *
     * @type {RenderTarget}
     * @ignore
     */
    renderTarget: RenderTarget;
    /** @type {boolean} */
    insideRenderPass: boolean;
    /**
     * True if hardware instancing is supported.
     *
     * @type {boolean}
     */
    supportsInstancing: boolean;
    /**
     * True if the device supports uniform buffers.
     *
     * @type {boolean}
     * @ignore
     */
    supportsUniformBuffers: boolean;
    /**
     * True if 32-bit floating-point textures can be used as a frame buffer.
     *
     * @type {boolean}
     */
    textureFloatRenderable: boolean;
    /**
     * True if 16-bit floating-point textures can be used as a frame buffer.
     *
     * @type {boolean}
     */
    textureHalfFloatRenderable: boolean;
    _width: number;
    _height: number;
    _maxPixelRatio: number;
    /** @type {Shader[]} */
    shaders: Shader[];
    buffers: any[];
    /** @type {Texture[]} */
    textures: Texture[];
    /** @type {RenderTarget[]} */
    targets: RenderTarget[];
    _vram: {
        texShadow: number;
        texAsset: number;
        texLightmap: number;
        tex: number;
        vb: number;
        ib: number;
        ub: number;
    };
    _shaderStats: {
        vsCompiled: number;
        fsCompiled: number;
        linked: number;
        materialShaders: number;
        compileTime: number;
    };
    _drawCallsPerFrame: number;
    _shaderSwitchesPerFrame: number;
    _primsPerFrame: number[];
    _renderTargetCreationTime: number;
    programLib: ProgramLibrary;
    /**
     * Fired when the canvas is resized.
     *
     * @event GraphicsDevice#resizecanvas
     * @param {number} width - The new width of the canvas in pixels.
     * @param {number} height - The new height of the canvas in pixels.
     */
    /**
     * Destroy the graphics device.
     */
    destroy(): void;
    postDestroy(): void;
    toJSON(key: any): any;
    initializeContextCaches(): void;
    indexBuffer: any;
    vertexBuffers: any[];
    shader: any;
    /**
     * Retrieves the program library assigned to the specified graphics device.
     *
     * @returns {ProgramLibrary} The program library assigned to the device.
     * @ignore
     */
    getProgramLibrary(): ProgramLibrary;
    /**
     * Assigns a program library to the specified device. By default, a graphics device is created
     * with a program library that manages all of the programs that are used to render any
     * graphical primitives. However, this function allows the user to replace the existing program
     * library with a new one.
     *
     * @param {ProgramLibrary} programLib - The program library to assign to the device.
     * @ignore
     */
    setProgramLibrary(programLib: ProgramLibrary): void;
    /**
     * Sets the specified render target on the device. If null is passed as a parameter, the back
     * buffer becomes the current target for all rendering operations.
     *
     * @param {RenderTarget} renderTarget - The render target to activate.
     * @example
     * // Set a render target to receive all rendering output
     * device.setRenderTarget(renderTarget);
     *
     * // Set the back buffer to receive all rendering output
     * device.setRenderTarget(null);
     */
    setRenderTarget(renderTarget: RenderTarget): void;
    /**
     * Queries the currently set render target on the device.
     *
     * @returns {RenderTarget} The current render target.
     * @example
     * // Get the current render target
     * var renderTarget = device.getRenderTarget();
     */
    getRenderTarget(): RenderTarget;
    /**
     * Reports whether a texture source is a canvas, image, video or ImageBitmap.
     *
     * @param {*} texture - Texture source data.
     * @returns {boolean} True if the texture is a canvas, image, video or ImageBitmap and false
     * otherwise.
     * @ignore
     */
    _isBrowserInterface(texture: any): boolean;
    /**
     * Sets the width and height of the canvas, then fires the `resizecanvas` event. Note that the
     * specified width and height values will be multiplied by the value of
     * {@link GraphicsDevice#maxPixelRatio} to give the final resultant width and height for the
     * canvas.
     *
     * @param {number} width - The new width of the canvas.
     * @param {number} height - The new height of the canvas.
     * @ignore
     */
    resizeCanvas(width: number, height: number): void;
    /**
     * Sets the width and height of the canvas, then fires the `resizecanvas` event. Note that the
     * value of {@link GraphicsDevice#maxPixelRatio} is ignored.
     *
     * @param {number} width - The new width of the canvas.
     * @param {number} height - The new height of the canvas.
     * @ignore
     */
    setResolution(width: number, height: number): void;
    updateClientRect(): void;
    clientRect: DOMRect;
    /**
     * Width of the back buffer in pixels.
     *
     * @type {number}
     */
    get width(): number;
    /**
     * Height of the back buffer in pixels.
     *
     * @type {number}
     */
    get height(): number;
    /**
     * Fullscreen mode.
     *
     * @type {boolean}
     */
    set fullscreen(arg: boolean);
    get fullscreen(): boolean;
    /**
     * Maximum pixel ratio.
     *
     * @type {number}
     */
    set maxPixelRatio(arg: number);
    get maxPixelRatio(): number;
}


/**
 * A texture is a container for texel data that can be utilized in a fragment shader. Typically,
 * the texel data represents an image that is mapped over geometry.
 */
declare class Texture {
    /**
     * Calculate the GPU memory required for a texture.
     *
     * @param {number} width - Texture's width.
     * @param {number} height - Texture's height.
     * @param {number} depth - Texture's depth.
     * @param {number} format - Texture's pixel format PIXELFORMAT_***.
     * @param {boolean} mipmaps - True if the texture includes mipmaps, false otherwise.
     * @param {boolean} cubemap - True is the texture is a cubemap, false otherwise.
     * @returns {number} The number of bytes of GPU memory required for the texture.
     * @ignore
     */
    static calcGpuSize(width: number, height: number, depth: number, format: number, mipmaps: boolean, cubemap: boolean): number;
    /**
     * Create a new Texture instance.
     *
     * @param {GraphicsDevice} graphicsDevice - The graphics device used to manage this texture.
     * @param {object} [options] - Object for passing optional arguments.
     * @param {string} [options.name] - The name of the texture.
     * @param {number} [options.width] - The width of the texture in pixels. Defaults to 4.
     * @param {number} [options.height] - The height of the texture in pixels. Defaults to 4.
     * @param {number} [options.depth] - The number of depth slices in a 3D texture (WebGL2 only).
     * Defaults to 1 (single 2D image).
     * @param {number} [options.format] - The pixel format of the texture. Can be:
     *
     * - {@link PIXELFORMAT_A8}
     * - {@link PIXELFORMAT_L8}
     * - {@link PIXELFORMAT_L8_A8}
     * - {@link PIXELFORMAT_R5_G6_B5}
     * - {@link PIXELFORMAT_R5_G5_B5_A1}
     * - {@link PIXELFORMAT_R4_G4_B4_A4}
     * - {@link PIXELFORMAT_R8_G8_B8}
     * - {@link PIXELFORMAT_R8_G8_B8_A8}
     * - {@link PIXELFORMAT_DXT1}
     * - {@link PIXELFORMAT_DXT3}
     * - {@link PIXELFORMAT_DXT5}
     * - {@link PIXELFORMAT_RGB16F}
     * - {@link PIXELFORMAT_RGBA16F}
     * - {@link PIXELFORMAT_RGB32F}
     * - {@link PIXELFORMAT_RGBA32F}
     * - {@link PIXELFORMAT_ETC1}
     * - {@link PIXELFORMAT_PVRTC_2BPP_RGB_1}
     * - {@link PIXELFORMAT_PVRTC_2BPP_RGBA_1}
     * - {@link PIXELFORMAT_PVRTC_4BPP_RGB_1}
     * - {@link PIXELFORMAT_PVRTC_4BPP_RGBA_1}
     * - {@link PIXELFORMAT_111110F}
     * - {@link PIXELFORMAT_ASTC_4x4}>/li>
     * - {@link PIXELFORMAT_ATC_RGB}
     * - {@link PIXELFORMAT_ATC_RGBA}
     *
     * Defaults to {@link PIXELFORMAT_R8_G8_B8_A8}.
     * @param {string} [options.projection] - The projection type of the texture, used when the
     * texture represents an environment. Can be:
     *
     * - {@link TEXTUREPROJECTION_NONE}
     * - {@link TEXTUREPROJECTION_CUBE}
     * - {@link TEXTUREPROJECTION_EQUIRECT}
     * - {@link TEXTUREPROJECTION_OCTAHEDRAL}
     *
     * Defaults to {@link TEXTUREPROJECTION_CUBE} if options.cubemap is specified, otherwise
     * {@link TEXTUREPROJECTION_NONE}.
     * @param {number} [options.minFilter] - The minification filter type to use. Defaults to
     * {@link FILTER_LINEAR_MIPMAP_LINEAR}.
     * @param {number} [options.magFilter] - The magnification filter type to use. Defaults to
     * {@link FILTER_LINEAR}.
     * @param {number} [options.anisotropy] - The level of anisotropic filtering to use. Defaults
     * to 1.
     * @param {number} [options.addressU] - The repeat mode to use in the U direction. Defaults to
     * {@link ADDRESS_REPEAT}.
     * @param {number} [options.addressV] - The repeat mode to use in the V direction. Defaults to
     * {@link ADDRESS_REPEAT}.
     * @param {number} [options.addressW] - The repeat mode to use in the W direction. Defaults to
     * {@link ADDRESS_REPEAT}.
     * @param {boolean} [options.mipmaps] - When enabled try to generate or use mipmaps for this
     * texture. Default is true.
     * @param {boolean} [options.cubemap] - Specifies whether the texture is to be a cubemap.
     * Defaults to false.
     * @param {boolean} [options.volume] - Specifies whether the texture is to be a 3D volume
     * (WebGL2 only). Defaults to false.
     * @param {string} [options.type] - Specifies the image type, see {@link TEXTURETYPE_DEFAULT}.
     * @param {boolean} [options.fixCubemapSeams] - Specifies whether this cubemap texture requires
     * special seam fixing shader code to look right. Defaults to false.
     * @param {boolean} [options.flipY] - Specifies whether the texture should be flipped in the
     * Y-direction. Only affects textures with a source that is an image, canvas or video element.
     * Does not affect cubemaps, compressed textures or textures set from raw pixel data. Defaults
     * to false.
     * @param {boolean} [options.premultiplyAlpha] - If true, the alpha channel of the texture (if
     * present) is multiplied into the color channels. Defaults to false.
     * @param {boolean} [options.compareOnRead] - When enabled, and if texture format is
     * {@link PIXELFORMAT_DEPTH} or {@link PIXELFORMAT_DEPTHSTENCIL}, hardware PCF is enabled for
     * this texture, and you can get filtered results of comparison using texture() in your shader
     * (WebGL2 only). Defaults to false.
     * @param {number} [options.compareFunc] - Comparison function when compareOnRead is enabled
     * (WebGL2 only). Can be:
     *
     * - {@link FUNC_LESS}
     * - {@link FUNC_LESSEQUAL}
     * - {@link FUNC_GREATER}
     * - {@link FUNC_GREATEREQUAL}
     * - {@link FUNC_EQUAL}
     * - {@link FUNC_NOTEQUAL}
     *
     * Defaults to {@link FUNC_LESS}.
     * @param {Uint8Array[]} [options.levels] - Array of Uint8Array.
     * @example
     * // Create a 8x8x24-bit texture
     * var texture = new pc.Texture(graphicsDevice, {
     *     width: 8,
     *     height: 8,
     *     format: pc.PIXELFORMAT_R8_G8_B8
     * });
     *
     * // Fill the texture with a gradient
     * var pixels = texture.lock();
     * var count = 0;
     * for (var i = 0; i < 8; i++) {
     *     for (var j = 0; j < 8; j++) {
     *         pixels[count++] = i * 32;
     *         pixels[count++] = j * 32;
     *         pixels[count++] = 255;
     *     }
     * }
     * texture.unlock();
     */
    constructor(graphicsDevice: GraphicsDevice, options?: {
        name?: string;
        width?: number;
        height?: number;
        depth?: number;
        format?: number;
        projection?: string;
        minFilter?: number;
        magFilter?: number;
        anisotropy?: number;
        addressU?: number;
        addressV?: number;
        addressW?: number;
        mipmaps?: boolean;
        cubemap?: boolean;
        volume?: boolean;
        type?: string;
        fixCubemapSeams?: boolean;
        flipY?: boolean;
        premultiplyAlpha?: boolean;
        compareOnRead?: boolean;
        compareFunc?: number;
        levels?: Uint8Array[];
    });
    id: number;
    device: GraphicsDevice;
    /**
     * The name of the texture. Defaults to null.
     *
     * @type {string}
     */
    name: string;
    _width: number;
    _height: number;
    _depth: number;
    _format: number;
    type: string;
    projection: string;
    _cubemap: boolean;
    _volume: boolean;
    fixCubemapSeams: boolean;
    _flipY: boolean;
    _premultiplyAlpha: boolean;
    _isRenderTarget: boolean;
    _mipmaps: any;
    _minFilter: number;
    _magFilter: number;
    _anisotropy: number;
    _addressU: number;
    _addressV: number;
    _addressW: number;
    _compareOnRead: boolean;
    _compareFunc: any;
    profilerHint: any;
    _levels: any[][] | Uint8Array[];
    _compressed: boolean;
    _invalid: boolean;
    _lockedLevel: number;
    _gpuSize: number;
    impl: any;
    /**
     * Frees resources associated with this texture.
     */
    destroy(): void;
    /**
     * Called when the rendering context was lost. It releases all context related resources.
     *
     * @ignore
     */
    loseContext(): void;
    /**
     * Updates vram size tracking for the texture, size can be positive to add or negative to subtract
     *
     * @ignore
     */
    adjustVramSizeTracking(vram: any, size: any): void;
    /**
     * The minification filter to be applied to the texture. Can be:
     *
     * - {@link FILTER_NEAREST}
     * - {@link FILTER_LINEAR}
     * - {@link FILTER_NEAREST_MIPMAP_NEAREST}
     * - {@link FILTER_NEAREST_MIPMAP_LINEAR}
     * - {@link FILTER_LINEAR_MIPMAP_NEAREST}
     * - {@link FILTER_LINEAR_MIPMAP_LINEAR}
     *
     * @type {number}
     */
    set minFilter(arg: number);
    get minFilter(): number;
    /**
     * The magnification filter to be applied to the texture. Can be:
     *
     * - {@link FILTER_NEAREST}
     * - {@link FILTER_LINEAR}
     *
     * @type {number}
     */
    set magFilter(arg: number);
    get magFilter(): number;
    /**
     * The addressing mode to be applied to the texture horizontally. Can be:
     *
     * - {@link ADDRESS_REPEAT}
     * - {@link ADDRESS_CLAMP_TO_EDGE}
     * - {@link ADDRESS_MIRRORED_REPEAT}
     *
     * @type {number}
     */
    set addressU(arg: number);
    get addressU(): number;
    /**
     * The addressing mode to be applied to the texture vertically. Can be:
     *
     * - {@link ADDRESS_REPEAT}
     * - {@link ADDRESS_CLAMP_TO_EDGE}
     * - {@link ADDRESS_MIRRORED_REPEAT}
     *
     * @type {number}
     */
    set addressV(arg: number);
    get addressV(): number;
    /**
     * The addressing mode to be applied to the 3D texture depth (WebGL2 only). Can be:
     *
     * - {@link ADDRESS_REPEAT}
     * - {@link ADDRESS_CLAMP_TO_EDGE}
     * - {@link ADDRESS_MIRRORED_REPEAT}
     *
     * @type {number}
     */
    set addressW(arg: number);
    get addressW(): number;
    /**
     * When enabled, and if texture format is {@link PIXELFORMAT_DEPTH} or
     * {@link PIXELFORMAT_DEPTHSTENCIL}, hardware PCF is enabled for this texture, and you can get
     * filtered results of comparison using texture() in your shader (WebGL2 only).
     *
     * @type {boolean}
     */
    set compareOnRead(arg: boolean);
    get compareOnRead(): boolean;
    /**
     * Comparison function when compareOnRead is enabled (WebGL2 only). Possible values:
     *
     * - {@link FUNC_LESS}
     * - {@link FUNC_LESSEQUAL}
     * - {@link FUNC_GREATER}
     * - {@link FUNC_GREATEREQUAL}
     * - {@link FUNC_EQUAL}
     * - {@link FUNC_NOTEQUAL}
     *
     * @type {number}
     */
    set compareFunc(arg: any);
    get compareFunc(): any;
    /**
     * Integer value specifying the level of anisotropic to apply to the texture ranging from 1 (no
     * anisotropic filtering) to the {@link GraphicsDevice} property maxAnisotropy.
     *
     * @type {number}
     */
    set anisotropy(arg: number);
    get anisotropy(): number;
    /**
     * Toggles automatic mipmap generation. Can't be used on non power of two textures.
     *
     * @type {boolean}
     * @ignore
     * @deprecated
     */
    set autoMipmap(arg: any);
    get autoMipmap(): any;
    /**
     * Defines if texture should generate/upload mipmaps if possible.
     *
     * @type {boolean}
     */
    set mipmaps(arg: any);
    get mipmaps(): any;
    _needsMipmapsUpload: any;
    /**
     * The width of the texture in pixels.
     *
     * @type {number}
     */
    get width(): number;
    /**
     * The height of the texture in pixels.
     *
     * @type {number}
     */
    get height(): number;
    /**
     * The number of depth slices in a 3D texture (WebGL2 only).
     *
     * @type {number}
     */
    get depth(): number;
    /**
     * The pixel format of the texture. Can be:
     *
     * - {@link PIXELFORMAT_A8}
     * - {@link PIXELFORMAT_L8}
     * - {@link PIXELFORMAT_L8_A8}
     * - {@link PIXELFORMAT_R5_G6_B5}
     * - {@link PIXELFORMAT_R5_G5_B5_A1}
     * - {@link PIXELFORMAT_R4_G4_B4_A4}
     * - {@link PIXELFORMAT_R8_G8_B8}
     * - {@link PIXELFORMAT_R8_G8_B8_A8}
     * - {@link PIXELFORMAT_DXT1}
     * - {@link PIXELFORMAT_DXT3}
     * - {@link PIXELFORMAT_DXT5}
     * - {@link PIXELFORMAT_RGB16F}
     * - {@link PIXELFORMAT_RGBA16F}
     * - {@link PIXELFORMAT_RGB32F}
     * - {@link PIXELFORMAT_RGBA32F}
     * - {@link PIXELFORMAT_ETC1}
     * - {@link PIXELFORMAT_PVRTC_2BPP_RGB_1}
     * - {@link PIXELFORMAT_PVRTC_2BPP_RGBA_1}
     * - {@link PIXELFORMAT_PVRTC_4BPP_RGB_1}
     * - {@link PIXELFORMAT_PVRTC_4BPP_RGBA_1}
     * - {@link PIXELFORMAT_111110F}
     * - {@link PIXELFORMAT_ASTC_4x4}>/li>
     * - {@link PIXELFORMAT_ATC_RGB}
     * - {@link PIXELFORMAT_ATC_RGBA}
     *
     * @type {number}
     */
    get format(): number;
    /**
     * Returns true if this texture is a cube map and false otherwise.
     *
     * @type {boolean}
     */
    get cubemap(): boolean;
    get gpuSize(): number;
    /**
     * Returns true if this texture is a 3D volume and false otherwise.
     *
     * @type {boolean}
     */
    get volume(): boolean;
    /**
     * Specifies whether the texture should be flipped in the Y-direction. Only affects textures
     * with a source that is an image, canvas or video element. Does not affect cubemaps,
     * compressed textures or textures set from raw pixel data. Defaults to true.
     *
     * @type {boolean}
     */
    set flipY(arg: boolean);
    get flipY(): boolean;
    _needsUpload: boolean;
    set premultiplyAlpha(arg: boolean);
    get premultiplyAlpha(): boolean;
    /**
     * Returns true if all dimensions of the texture are power of two, and false otherwise.
     *
     * @type {boolean}
     */
    get pot(): boolean;
    get encoding(): "srgb" | "linear" | "rgbm" | "rgbe";
    dirtyAll(): void;
    _levelsUpdated: boolean[] | boolean[][];
    _mipmapsUploaded: boolean;
    _parameterFlags: number;
    /**
     * Locks a miplevel of the texture, returning a typed array to be filled with pixel data.
     *
     * @param {object} [options] - Optional options object. Valid properties are as follows:
     * @param {number} [options.level] - The mip level to lock with 0 being the top level. Defaults
     * to 0.
     * @param {number} [options.face] - If the texture is a cubemap, this is the index of the face
     * to lock.
     * @param {number} [options.mode] - The lock mode. Can be:
     * - {@link TEXTURELOCK_READ}
     * - {@link TEXTURELOCK_WRITE}
     * Defaults to {@link TEXTURELOCK_WRITE}.
     * @returns {Uint8Array|Uint16Array|Float32Array} A typed array containing the pixel data of
     * the locked mip level.
     */
    lock(options?: {
        level?: number;
        face?: number;
        mode?: number;
    }): Uint8Array | Uint16Array | Float32Array;
    /**
     * Set the pixel data of the texture from a canvas, image, video DOM element. If the texture is
     * a cubemap, the supplied source must be an array of 6 canvases, images or videos.
     *
     * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement|HTMLCanvasElement[]|HTMLImageElement[]|HTMLVideoElement[]} source - A
     * canvas, image or video element, or an array of 6 canvas, image or video elements.
     * @param {number} [mipLevel] - A non-negative integer specifying the image level of detail.
     * Defaults to 0, which represents the base image source. A level value of N, that is greater
     * than 0, represents the image source for the Nth mipmap reduction level.
     */
    setSource(source: HTMLCanvasElement | HTMLImageElement | HTMLVideoElement | HTMLCanvasElement[] | HTMLImageElement[] | HTMLVideoElement[], mipLevel?: number): void;
    /**
     * Get the pixel data of the texture. If this is a cubemap then an array of 6 images will be
     * returned otherwise a single image.
     *
     * @param {number} [mipLevel] - A non-negative integer specifying the image level of detail.
     * Defaults to 0, which represents the base image source. A level value of N, that is greater
     * than 0, represents the image source for the Nth mipmap reduction level.
     * @returns {HTMLImageElement} The source image of this texture. Can be null if source not
     * assigned for specific image level.
     */
    getSource(mipLevel?: number): HTMLImageElement;
    /**
     * Unlocks the currently locked mip level and uploads it to VRAM.
     */
    unlock(): void;
    /**
     * Forces a reupload of the textures pixel data to graphics memory. Ordinarily, this function
     * is called by internally by {@link Texture#setSource} and {@link Texture#unlock}. However, it
     * still needs to be called explicitly in the case where an HTMLVideoElement is set as the
     * source of the texture.  Normally, this is done once every frame before video textured
     * geometry is rendered.
     */
    upload(): void;
    /**
     * Generate an in-memory DDS representation of this texture. Only works on RGBA8 textures.
     * Currently, only used by the Editor to write prefiltered cubemaps to DDS format.
     *
     * @returns {ArrayBuffer} Buffer containing the DDS data.
     * @ignore
     */
    getDds(): ArrayBuffer;
}






/**
 * Draws a screen-space quad using a specific shader. Mostly used by post-effects.
 *
 * @param {GraphicsDevice} device - The graphics device used to draw the quad.
 * @param {RenderTarget|undefined} target - The destination render target. If undefined, target is
 * the frame buffer.
 * @param {Shader} shader - The shader used for rendering the quad. Vertex shader should contain
 * `attribute vec2 vertex_position`.
 * @param {Vec4} [rect] - The viewport rectangle of the quad, in pixels. Defaults to fullscreen
 * (`0, 0, target.width, target.height`).
 * @param {Vec4} [scissorRect] - The scissor rectangle of the quad, in pixels. Defaults to
 * fullscreen (`0, 0, target.width, target.height`).
 * @param {boolean} [useBlend] - True to enable blending. Defaults to false, disabling blending.
 */
declare function drawQuadWithShader(device: GraphicsDevice, target: RenderTarget | undefined, shader: Shader, rect?: Vec4, scissorRect?: Vec4, useBlend?: boolean): void;
/**
 * Draws a texture in screen-space. Mostly used by post-effects.
 *
 * @param {GraphicsDevice} device - The graphics device used to draw the texture.
 * @param {Texture} texture - The source texture to be drawn. Accessible as `uniform sampler2D
 * source` in shader.
 * @param {RenderTarget} [target] - The destination render target. Defaults to the frame buffer.
 * @param {Shader} [shader] - The shader used for rendering the texture. Defaults to {@link GraphicsDevice#getCopyShader}.
 * @param {Vec4} [rect] - The viewport rectangle to use for the texture, in pixels. Defaults to
 * fullscreen (`0, 0, target.width, target.height`).
 * @param {Vec4} [scissorRect] - The scissor rectangle to use for the texture, in pixels. Defaults
 * to fullscreen (`0, 0, target.width, target.height`).
 * @param {boolean} [useBlend] - True to enable blending. Defaults to false, disabling blending.
 */
declare function drawTexture(device: GraphicsDevice, texture: Texture, target?: RenderTarget, shader?: Shader, rect?: Vec4, scissorRect?: Vec4, useBlend?: boolean): void;

/**
 * @static
 * @readonly
 * @type {object}
 * @name shaderChunks
 * @description Object containing all default shader chunks used by shader generators.
 */
declare const shaderChunks: object;


/** @typedef {import('./graphics-device.js').GraphicsDevice} GraphicsDevice */
/**
 * An index buffer stores index values into a {@link VertexBuffer}. Indexed graphical primitives
 * can normally utilize less memory that unindexed primitives (if vertices are shared).
 *
 * Typically, index buffers are set on {@link Mesh} objects.
 */
declare class IndexBuffer {
    /**
     * Create a new IndexBuffer instance.
     *
     * @param {GraphicsDevice} graphicsDevice - The graphics device used to manage this index
     * buffer.
     * @param {number} format - The type of each index to be stored in the index buffer. Can be:
     *
     * - {@link INDEXFORMAT_UINT8}
     * - {@link INDEXFORMAT_UINT16}
     * - {@link INDEXFORMAT_UINT32}
     * @param {number} numIndices - The number of indices to be stored in the index buffer.
     * @param {number} [usage] - The usage type of the vertex buffer. Can be:
     *
     * - {@link BUFFER_DYNAMIC}
     * - {@link BUFFER_STATIC}
     * - {@link BUFFER_STREAM}
     *
     * Defaults to {@link BUFFER_STATIC}.
     * @param {ArrayBuffer} [initialData] - Initial data. If left unspecified, the index buffer
     * will be initialized to zeros.
     * @example
     * // Create an index buffer holding 3 16-bit indices. The buffer is marked as
     * // static, hinting that the buffer will never be modified.
     * var indices = new UInt16Array([0, 1, 2]);
     * var indexBuffer = new pc.IndexBuffer(graphicsDevice,
     *                                      pc.INDEXFORMAT_UINT16,
     *                                      3,
     *                                      pc.BUFFER_STATIC,
     *                                      indices);
     */
    constructor(graphicsDevice: GraphicsDevice, format: number, numIndices: number, usage?: number, initialData?: ArrayBuffer);
    device: GraphicsDevice;
    format: number;
    numIndices: number;
    usage: number;
    impl: any;
    bytesPerIndex: number;
    numBytes: number;
    storage: ArrayBuffer;
    /**
     * Frees resources associated with this index buffer.
     */
    destroy(): void;
    /**
     * Called when the rendering context was lost. It releases all context related resources.
     *
     * @ignore
     */
    loseContext(): void;
    /**
     * Returns the data format of the specified index buffer.
     *
     * @returns {number} The data format of the specified index buffer. Can be:
     *
     * - {@link INDEXFORMAT_UINT8}
     * - {@link INDEXFORMAT_UINT16}
     * - {@link INDEXFORMAT_UINT32}
     */
    getFormat(): number;
    /**
     * Returns the number of indices stored in the specified index buffer.
     *
     * @returns {number} The number of indices stored in the specified index buffer.
     */
    getNumIndices(): number;
    /**
     * Gives access to the block of memory that stores the buffer's indices.
     *
     * @returns {ArrayBuffer} A contiguous block of memory where index data can be written to.
     */
    lock(): ArrayBuffer;
    /**
     * Signals that the block of memory returned by a call to the lock function is ready to be
     * given to the graphics hardware. Only unlocked index buffers can be set on the currently
     * active device.
     */
    unlock(): void;
    /**
     * Set preallocated data on the index buffer.
     *
     * @param {ArrayBuffer} data - The index data to set.
     * @returns {boolean} True if the data was set successfully, false otherwise.
     * @ignore
     */
    setData(data: ArrayBuffer): boolean;
    /**
     * Get the appropriate typed array from an index buffer.
     *
     * @returns {Uint8Array|Uint16Array|Uint32Array} The typed array containing the index data.
     * @private
     */
    private _lockTypedArray;
    /**
     * Copies the specified number of elements from data into index buffer. Optimized for
     * performance from both typed array as well as array.
     *
     * @param {Uint8Array|Uint16Array|Uint32Array|number[]} data - The data to write.
     * @param {number} count - The number of indices to write.
     * @ignore
     */
    writeData(data: Uint8Array | Uint16Array | Uint32Array | number[], count: number): void;
    /**
     * Copies index data from index buffer into provided data array.
     *
     * @param {Uint8Array|Uint16Array|Uint32Array|number[]} data - The data array to write to.
     * @returns {number} The number of indices read.
     * @ignore
     */
    readData(data: Uint8Array | Uint16Array | Uint32Array | number[]): number;
}


/** @typedef {import('./graphics-device.js').GraphicsDevice} GraphicsDevice */
/**
 * Representation of a shader uniform.
 *
 * @ignore
 */
declare class ShaderInput {
    /**
     * Create a new ShaderInput instance.
     *
     * @param {GraphicsDevice} graphicsDevice - The graphics device used to manage this shader input.
     * @param {string} name - The name of the shader input.
     * @param {number} type - The type of the shader input.
     * @param {number | WebGLUniformLocation} locationId - The location id of the shader input.
     */
    constructor(graphicsDevice: GraphicsDevice, name: string, type: number, locationId: number | WebGLUniformLocation);
    locationId: number | WebGLUniformLocation;
    scopeId: ScopeId;
    version: Version;
    dataType: number;
    value: any[];
    array: any[];
}


/** @typedef {import('./graphics-device.js').GraphicsDevice} GraphicsDevice */
/**
 * A vertex format is a descriptor that defines the layout of vertex data inside a
 * {@link VertexBuffer}.
 *
 * @property {object[]} elements The vertex attribute elements.
 * @property {string} elements[].name The meaning of the vertex element. This is used to link the
 * vertex data to a shader input. Can be:
 *
 * - {@link SEMANTIC_POSITION}
 * - {@link SEMANTIC_NORMAL}
 * - {@link SEMANTIC_TANGENT}
 * - {@link SEMANTIC_BLENDWEIGHT}
 * - {@link SEMANTIC_BLENDINDICES}
 * - {@link SEMANTIC_COLOR}
 * - {@link SEMANTIC_TEXCOORD0}
 * - {@link SEMANTIC_TEXCOORD1}
 * - {@link SEMANTIC_TEXCOORD2}
 * - {@link SEMANTIC_TEXCOORD3}
 * - {@link SEMANTIC_TEXCOORD4}
 * - {@link SEMANTIC_TEXCOORD5}
 * - {@link SEMANTIC_TEXCOORD6}
 * - {@link SEMANTIC_TEXCOORD7}
 *
 * If vertex data has a meaning other that one of those listed above, use the user-defined
 * semantics: {@link SEMANTIC_ATTR0} to {@link SEMANTIC_ATTR15}.
 * @property {number} elements[].numComponents The number of components of the vertex attribute.
 * Can be 1, 2, 3 or 4.
 * @property {number} elements[].dataType The data type of the attribute. Can be:
 *
 * - {@link TYPE_INT8}
 * - {@link TYPE_UINT8}
 * - {@link TYPE_INT16}
 * - {@link TYPE_UINT16}
 * - {@link TYPE_INT32}
 * - {@link TYPE_UINT32}
 * - {@link TYPE_FLOAT32}
 * @property {boolean} elements[].normalize If true, vertex attribute data will be mapped from a 0
 * to 255 range down to 0 to 1 when fed to a shader. If false, vertex attribute data is left
 * unchanged. If this property is unspecified, false is assumed.
 * @property {number} elements[].offset The number of initial bytes at the start of a vertex that
 * are not relevant to this attribute.
 * @property {number} elements[].stride The number of total bytes that are between the start of one
 * vertex, and the start of the next.
 * @property {number} elements[].size The size of the attribute in bytes.
 */
declare class VertexFormat {
    /**
     * @type {VertexFormat}
     * @private
     */
    private static _defaultInstancingFormat;
    /**
     * The {@link VertexFormat} used to store matrices of type {@link Mat4} for hardware instancing.
     *
     * @type {VertexFormat}
     */
    static get defaultInstancingFormat(): VertexFormat;
    /**
     * Create a new VertexFormat instance.
     *
     * @param {GraphicsDevice} graphicsDevice - The graphics device used to manage this vertex format.
     * @param {object[]} description - An array of vertex attribute descriptions.
     * @param {string} description[].semantic - The meaning of the vertex element. This is used to link
     * the vertex data to a shader input. Can be:
     *
     * - {@link SEMANTIC_POSITION}
     * - {@link SEMANTIC_NORMAL}
     * - {@link SEMANTIC_TANGENT}
     * - {@link SEMANTIC_BLENDWEIGHT}
     * - {@link SEMANTIC_BLENDINDICES}
     * - {@link SEMANTIC_COLOR}
     * - {@link SEMANTIC_TEXCOORD0}
     * - {@link SEMANTIC_TEXCOORD1}
     * - {@link SEMANTIC_TEXCOORD2}
     * - {@link SEMANTIC_TEXCOORD3}
     * - {@link SEMANTIC_TEXCOORD4}
     * - {@link SEMANTIC_TEXCOORD5}
     * - {@link SEMANTIC_TEXCOORD6}
     * - {@link SEMANTIC_TEXCOORD7}
     *
     * If vertex data has a meaning other that one of those listed above, use the user-defined
     * semantics: {@link SEMANTIC_ATTR0} to {@link SEMANTIC_ATTR15}.
     * @param {number} description[].components - The number of components of the vertex attribute.
     * Can be 1, 2, 3 or 4.
     * @param {number} description[].type - The data type of the attribute. Can be:
     *
     * - {@link TYPE_INT8}
     * - {@link TYPE_UINT8}
     * - {@link TYPE_INT16}
     * - {@link TYPE_UINT16}
     * - {@link TYPE_INT32}
     * - {@link TYPE_UINT32}
     * - {@link TYPE_FLOAT32}
     *
     * @param {boolean} [description[].normalize] - If true, vertex attribute data will be mapped
     * from a 0 to 255 range down to 0 to 1 when fed to a shader. If false, vertex attribute data
     * is left unchanged. If this property is unspecified, false is assumed.
     * @param {number} [vertexCount] - When specified, vertex format will be set up for
     * non-interleaved format with a specified number of vertices. (example: PPPPNNNNCCCC), where
     * arrays of individual attributes will be stored one right after the other (subject to
     * alignment requirements). Note that in this case, the format depends on the number of
     * vertices, and needs to change when the number of vertices changes. When not specified,
     * vertex format will be interleaved. (example: PNCPNCPNCPNC).
     * @example
     * // Specify 3-component positions (x, y, z)
     * var vertexFormat = new pc.VertexFormat(graphicsDevice, [
     *     { semantic: pc.SEMANTIC_POSITION, components: 3, type: pc.TYPE_FLOAT32 }
     * ]);
     * @example
     * // Specify 2-component positions (x, y), a texture coordinate (u, v) and a vertex color (r, g, b, a)
     * var vertexFormat = new pc.VertexFormat(graphicsDevice, [
     *     { semantic: pc.SEMANTIC_POSITION, components: 2, type: pc.TYPE_FLOAT32 },
     *     { semantic: pc.SEMANTIC_TEXCOORD0, components: 2, type: pc.TYPE_FLOAT32 },
     *     { semantic: pc.SEMANTIC_COLOR, components: 4, type: pc.TYPE_UINT8, normalize: true }
     * ]);
     */
    constructor(graphicsDevice: GraphicsDevice, description: {
        semantic: string;
        components: number;
        type: number;
        normalize?: boolean;
    }[], vertexCount?: number);
    _elements: {
        name: string;
        offset: any;
        stride: any;
        dataType: number;
        numComponents: number;
        normalize: boolean;
        size: number;
    }[];
    hasUv0: boolean;
    hasUv1: boolean;
    hasColor: boolean;
    hasTangents: boolean;
    verticesByteSize: number;
    vertexCount: number;
    interleaved: boolean;
    size: number;
    get elements(): {
        name: string;
        offset: any;
        stride: any;
        dataType: number;
        numComponents: number;
        normalize: boolean;
        size: number;
    }[];
    /**
     * Evaluates hash values for the format allowing fast compare of batching / rendering compatibility.
     *
     * @private
     */
    private _evaluateHash;
    batchingHash: number;
    renderingingHashString: string;
    renderingingHash: number;
}



/**
 * A vertex buffer is the mechanism via which the application specifies vertex data to the graphics
 * hardware.
 */
declare class VertexBuffer {
    /**
     * Create a new VertexBuffer instance.
     *
     * @param {GraphicsDevice} graphicsDevice - The graphics device used to manage this vertex
     * buffer.
     * @param {VertexFormat} format - The vertex format of this vertex buffer.
     * @param {number} numVertices - The number of vertices that this vertex buffer will hold.
     * @param {number} [usage] - The usage type of the vertex buffer (see BUFFER_*). Defaults to BUFFER_STATIC.
     * @param {ArrayBuffer} [initialData] - Initial data.
     */
    constructor(graphicsDevice: GraphicsDevice, format: VertexFormat, numVertices: number, usage?: number, initialData?: ArrayBuffer);
    device: GraphicsDevice;
    format: VertexFormat;
    numVertices: number;
    usage: number;
    id: number;
    impl: any;
    instancing: boolean;
    numBytes: number;
    storage: ArrayBuffer;
    /**
     * Frees resources associated with this vertex buffer.
     */
    destroy(): void;
    /**
     * Called when the rendering context was lost. It releases all context related resources.
     *
     * @ignore
     */
    loseContext(): void;
    /**
     * Returns the data format of the specified vertex buffer.
     *
     * @returns {VertexFormat} The data format of the specified vertex buffer.
     */
    getFormat(): VertexFormat;
    /**
     * Returns the usage type of the specified vertex buffer. This indicates whether the buffer can
     * be modified once and used many times {@link BUFFER_STATIC}, modified repeatedly and used
     * many times {@link BUFFER_DYNAMIC} or modified once and used at most a few times
     * {@link BUFFER_STREAM}.
     *
     * @returns {number} The usage type of the vertex buffer (see BUFFER_*).
     */
    getUsage(): number;
    /**
     * Returns the number of vertices stored in the specified vertex buffer.
     *
     * @returns {number} The number of vertices stored in the vertex buffer.
     */
    getNumVertices(): number;
    /**
     * Returns a mapped memory block representing the content of the vertex buffer.
     *
     * @returns {ArrayBuffer} An array containing the byte data stored in the vertex buffer.
     */
    lock(): ArrayBuffer;
    /**
     * Notifies the graphics engine that the client side copy of the vertex buffer's memory can be
     * returned to the control of the graphics driver.
     */
    unlock(): void;
    /**
     * Copies data into vertex buffer's memory.
     *
     * @param {ArrayBuffer} [data] - Source data to copy.
     * @returns {boolean} True if function finished successfully, false otherwise.
     */
    setData(data?: ArrayBuffer): boolean;
}




/**
 * A vertex iterator simplifies the process of writing vertex data to a vertex buffer.
 */
declare class VertexIterator {
    /**
     * Create a new VertexIterator instance.
     *
     * @param {VertexBuffer} vertexBuffer - The vertex buffer to be iterated.
     */
    constructor(vertexBuffer: VertexBuffer);
    vertexBuffer: VertexBuffer;
    vertexFormatSize: number;
    buffer: ArrayBuffer;
    accessors: VertexIteratorAccessor[];
    /**
     * The vertex buffer elements.
     *
     * @type {Object<string, VertexIteratorAccessor>}
     */
    element: {
        [x: string]: VertexIteratorAccessor;
    };
    /**
     * Moves the vertex iterator on to the next vertex.
     *
     * @param {number} [count] - Optional number of steps to move on when calling next. Defaults to
     * 1.
     * @example
     * var iterator = new pc.VertexIterator(vertexBuffer);
     * iterator.element[pc.SEMANTIC_POSITION].set(-0.9, -0.9, 0.0);
     * iterator.element[pc.SEMANTIC_COLOR].set(255, 0, 0, 255);
     * iterator.next();
     * iterator.element[pc.SEMANTIC_POSITION].set(0.9, -0.9, 0.0);
     * iterator.element[pc.SEMANTIC_COLOR].set(0, 255, 0, 255);
     * iterator.next();
     * iterator.element[pc.SEMANTIC_POSITION].set(0.0, 0.9, 0.0);
     * iterator.element[pc.SEMANTIC_COLOR].set(0, 0, 255, 255);
     * iterator.end();
     */
    next(count?: number): void;
    /**
     * Notifies the vertex buffer being iterated that writes are complete. Internally the vertex
     * buffer is unlocked and vertex data is uploaded to video memory.
     *
     * @example
     * var iterator = new pc.VertexIterator(vertexBuffer);
     * iterator.element[pc.SEMANTIC_POSITION].set(-0.9, -0.9, 0.0);
     * iterator.element[pc.SEMANTIC_COLOR].set(255, 0, 0, 255);
     * iterator.next();
     * iterator.element[pc.SEMANTIC_POSITION].set(0.9, -0.9, 0.0);
     * iterator.element[pc.SEMANTIC_COLOR].set(0, 255, 0, 255);
     * iterator.next();
     * iterator.element[pc.SEMANTIC_POSITION].set(0.0, 0.9, 0.0);
     * iterator.element[pc.SEMANTIC_COLOR].set(0, 0, 255, 255);
     * iterator.end();
     */
    end(): void;
    /**
     * Copies data for specified semantic into vertex buffer. Works with both interleaved (slower)
     * and non-interleaved (fast) vertex buffers.
     *
     * @param {string} semantic - The semantic of the vertex element to set.
     * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} data - The data to set.
     * @param {number} numVertices - The number of vertices to write.
     * @ignore
     */
    writeData(semantic: string, data: number[] | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array, numVertices: number): void;
    /**
     * Function to extract elements of a specified semantic from vertex buffer into flat array
     * (data). Works with both interleaved (slower) and non-interleaved (fast) vertex buffers.
     * Returns number of vertices. Note: when data is a typed array and is smaller than needed,
     * only part of the data gets copied out (typed arrays ignore read/write out of range).
     *
     * @param {string} semantic - The semantic of the vertex element to read.
     * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} data - The
     * array to receive the data.
     * @returns {number} The number of vertices read.
     * @ignore
     */
    readData(semantic: string, data: number[] | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array): number;
}
/**
 * Helps with accessing a specific vertex attribute.
 */
declare class VertexIteratorAccessor {
    /**
     * Create a new VertexIteratorAccessor instance.
     *
     * @param {ArrayBuffer} buffer - The vertex buffer containing the attribute to be accessed.
     * @param {object} vertexElement - The vertex attribute to be accessed.
     * @param {string} vertexElement.name - The meaning of the vertex element. This is used to link
     * the vertex data to a shader input. Can be:
     *
     * - {@link SEMANTIC_POSITION}
     * - {@link SEMANTIC_NORMAL}
     * - {@link SEMANTIC_TANGENT}
     * - {@link SEMANTIC_BLENDWEIGHT}
     * - {@link SEMANTIC_BLENDINDICES}
     * - {@link SEMANTIC_COLOR}
     * - {@link SEMANTIC_TEXCOORD0}
     * - {@link SEMANTIC_TEXCOORD1}
     * - {@link SEMANTIC_TEXCOORD2}
     * - {@link SEMANTIC_TEXCOORD3}
     * - {@link SEMANTIC_TEXCOORD4}
     * - {@link SEMANTIC_TEXCOORD5}
     * - {@link SEMANTIC_TEXCOORD6}
     * - {@link SEMANTIC_TEXCOORD7}
     *
     * If vertex data has a meaning other that one of those listed above, use the user-defined
     * semantics: {@link SEMANTIC_ATTR0} to {@link SEMANTIC_ATTR15}.
     * @param {number} vertexElement.numComponents - The number of components of the vertex
     * attribute. Can be 1, 2, 3 or 4.
     * @param {number} vertexElement.dataType - The data type of the attribute. Can be:
     *
     * - {@link TYPE_INT8}
     * - {@link TYPE_UINT8}
     * - {@link TYPE_INT16}
     * - {@link TYPE_UINT16}
     * - {@link TYPE_INT32}
     * - {@link TYPE_UINT32}
     * - {@link TYPE_FLOAT32}
     * @param {boolean} vertexElement.normalize - If true, vertex attribute data will be mapped
     * from a 0 to 255 range down to 0 to 1 when fed to a shader. If false, vertex attribute data
     * is left unchanged. If this property is unspecified, false is assumed.
     * @param {number} vertexElement.offset - The number of initial bytes at the start of a vertex
     * that are not relevant to this attribute.
     * @param {number} vertexElement.stride - The number of total bytes that are between the start
     * of one vertex, and the start of the next.
     * @param {ScopeId} vertexElement.scopeId - The shader input variable corresponding to the
     * attribute.
     * @param {number} vertexElement.size - The size of the attribute in bytes.
     * @param {VertexFormat} vertexFormat - A vertex format that defines the layout of vertex data
     * inside the buffer.
     */
    constructor(buffer: ArrayBuffer, vertexElement: {
        name: string;
        numComponents: number;
        dataType: number;
        normalize: boolean;
        offset: number;
        stride: number;
        scopeId: ScopeId;
        size: number;
    }, vertexFormat: VertexFormat);
    index: number;
    numComponents: number;
    array: Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array;
    stride: number;
    /**
     * Set all the attribute components at the iterator's current index.
     *
     * @param {number} a - The first component value.
     * @param {number} [b] - The second component value (if applicable).
     * @param {number} [c] - The third component value (if applicable).
     * @param {number} [d] - The fourth component value (if applicable).
     */
    set(a: number, b?: number, c?: number, d?: number): void;
    /**
     * Read attribute components to an output array.
     *
     * @param {number} offset - The component offset at which to read data from the buffer. Will be
     * used instead of the iterator's current index.
     * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} outputArray - The output array to write data into.
     * @param {number} outputIndex - The output index at which to write into the output array.
     */
    getToArray(offset: number, outputArray: number[] | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array, outputIndex: number): void;
    /**
     * Write attribute components from an input array.
     *
     * @param {number} index - The starting index at which to write data into the buffer. Will be
     * used instead of the iterator's current index.
     * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} inputArray - The input array to read data from.
     * @param {number} inputIndex - The input index at which to read from the input array.
     */
    setFromArray(index: number, inputArray: number[] | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array, inputIndex: number): void;
    /**
     * Get a attribute component at the iterator's current index.
     *
     * @param {number} offset - The component offset. Should be either 0, 1, 2, or 3.
     * @returns {number} The value of a attribute component.
     */
    get(offset: number): number;
}





/**
 * Create a vertex buffer with 4 vertices representing a fullscreen quad.
 *
 * @param {GraphicsDevice} device - The graphics device.
 * @returns {VertexBuffer} - The fullscreen quad vertex buffer.
 * @ignore
 */
declare function createFullscreenQuad(device: GraphicsDevice): VertexBuffer;
/**
 * Draw a screen-space rectangle in a render target. Primarily meant to be used in custom post
 * effects based on {@link PostEffect}.
 *
 * @param {GraphicsDevice} device - The graphics device of the application.
 * @param {RenderTarget} target - The output render target.
 * @param {VertexBuffer} vertexBuffer - The vertex buffer for the rectangle mesh. When calling from
 * a custom post effect, pass the field {@link PostEffect#vertexBuffer}.
 * @param {Shader} shader - The shader to be used for drawing the rectangle. When calling from a
 * custom post effect, pass the field {@link PostEffect#shader}.
 * @param {Vec4} [rect] - The normalized screen-space position (rect.x, rect.y) and size (rect.z,
 * rect.w) of the rectangle. Default is [0, 0, 1, 1].
 */
declare function drawFullscreenQuad(device: GraphicsDevice, target: RenderTarget, vertexBuffer: VertexBuffer, shader: Shader, rect?: Vec4): void;
/**
 * Base class for all post effects. Post effects take a a render target as input apply effects to
 * it and then render the result to an output render target or the screen if no output is
 * specified.
 */
declare class PostEffect$1 {
    /**
     * Create a new PostEffect instance.
     *
     * @param {GraphicsDevice} graphicsDevice - The graphics device of the application.
     */
    constructor(graphicsDevice: GraphicsDevice);
    /**
     * The graphics device of the application.
     *
     * @type {GraphicsDevice}
     */
    device: GraphicsDevice;
    /**
     * The shader definition for the fullscreen quad. Needs to be set by the custom post effect
     * (default is null). Used when calling {@link drawFullscreenQuad}.
     *
     * @type {Shader|null}
     */
    shader: Shader | null;
    /**
     * The vertex buffer for the fullscreen quad. Used when calling {@link drawFullscreenQuad}.
     *
     * @type {VertexBuffer}
     */
    vertexBuffer: VertexBuffer;
    /**
     * The property that should to be set to `true` (by the custom post effect) if a depth map
     * is necessary (default is false).
     *
     * @type {boolean}
     */
    needsDepthBuffer: boolean;
    depthMap: any;
    /**
     * Render the post effect using the specified inputTarget to the specified outputTarget.
     *
     * @param {RenderTarget} inputTarget - The input render target.
     * @param {RenderTarget} outputTarget - The output render target. If null then this will be the
     * screen.
     * @param {Vec4} [rect] - The rect of the current camera. If not specified, it will default to
     * [0, 0, 1, 1].
     */
    render(inputTarget: RenderTarget, outputTarget: RenderTarget, rect?: Vec4): void;
}


/** @typedef {import('./manager.js').SoundManager} SoundManager */
/**
 * Represents an audio listener - used internally.
 *
 * @ignore
 */
declare class Listener {
    /**
     * Create a new listener instance.
     *
     * @param {SoundManager} manager - The sound manager.
     */
    constructor(manager: SoundManager);
    /**
     * @type {SoundManager}
     * @private
     */
    private _manager;
    /**
     * @type {Vec3}
     * @private
     */
    private position;
    /**
     * @type {Vec3}
     * @private
     */
    private velocity;
    /**
     * @type {Mat4}
     * @private
     */
    private orientation;
    /**
     * Get the position of the listener.
     *
     * @returns {Vec3} The position of the listener.
     */
    getPosition(): Vec3;
    /**
     * Set the position of the listener.
     *
     * @param {Vec3} position - The new position of the listener.
     */
    setPosition(position: Vec3): void;
    /**
     * Get the velocity of the listener.
     *
     * @returns {Vec3} The velocity of the listener.
     * @deprecated
     */
    getVelocity(): Vec3;
    /**
     * Set the velocity of the listener.
     *
     * @param {Vec3} velocity - The new velocity of the listener.
     * @deprecated
     */
    setVelocity(velocity: Vec3): void;
    /**
     * Set the orientation matrix of the listener.
     *
     * @param {Mat4} orientation - The new orientation matrix of the listener.
     */
    setOrientation(orientation: Mat4): void;
    /**
     * Get the orientation matrix of the listener.
     *
     * @returns {Mat4} The orientation matrix of the listener.
     */
    getOrientation(): Mat4;
    /**
     * Get the listener.
     *
     * @type {AudioListener|null}
     */
    get listener(): AudioListener;
}

/**
 * The SoundManager is used to load and play audio. It also applies system-wide settings like
 * global volume, suspend and resume.
 *
 * @augments EventHandler
 */
declare class SoundManager extends EventHandler {
    /**
     * Create a new SoundManager instance.
     *
     * @param {object} [options] - Options options object.
     * @param {boolean} [options.forceWebAudioApi] - Always use the Web Audio API, even if check
     * indicates that it is not available.
     */
    constructor(options?: {
        forceWebAudioApi?: boolean;
    });
    /**
     * @type {AudioContext}
     * @private
     */
    private _context;
    /**
     * The current state of the underlying AudioContext.
     *
     * @type {string}
     * @private
     */
    private _state;
    /**
     * @type {boolean}
     * @private
     */
    private _forceWebAudioApi;
    _resumeContext: any;
    _resumeContextAttached: boolean;
    _unlock: any;
    _unlockAttached: boolean;
    listener: Listener;
    _volume: number;
    suspended: boolean;
    /**
     * Global volume for the manager. All {@link SoundInstance}s will scale their volume with this
     * volume. Valid between [0, 1].
     *
     * @type {number}
     */
    set volume(arg: number);
    get volume(): number;
    /**
     * Get the Web Audio API context.
     *
     * @type {AudioContext}
     * @ignore
     */
    get context(): AudioContext;
    suspend(): void;
    resume(): void;
    destroy(): void;
    /**
     * Create a new {@link Channel} and begin playback of the sound.
     *
     * @param {Sound} sound - The Sound object to play.
     * @param {object} options - Optional options object.
     * @param {number} [options.volume] - The volume to playback at, between 0 and 1.
     * @param {boolean} [options.loop] - Whether to loop the sound when it reaches the end.
     * @returns {Channel} The channel playing the sound.
     * @private
     */
    private playSound;
    /**
     * Create a new {@link Channel3d} and begin playback of the sound at the position specified.
     *
     * @param {Sound} sound - The Sound object to play.
     * @param {Vec3} position - The position of the sound in 3D space.
     * @param {object} options - Optional options object.
     * @param {number} [options.volume] - The volume to playback at, between 0 and 1.
     * @param {boolean} [options.loop] - Whether to loop the sound when it reaches the end.
     * @returns {Channel3d} The 3D channel playing the sound.
     * @private
     */
    private playSound3d;
    /**
     * Attempt to resume the AudioContext, but safely handle failure scenarios.
     * When the browser window loses focus (i.e. switching tab, hiding the app on mobile, etc),
     * the AudioContext state will be set to 'interrupted' (on iOS Safari) or 'suspended' (on other
     * browsers), and 'resume' must be expliclty called. However, the Auto-Play policy might block
     * the AudioContext from running - in those cases, we need to add the interaction listeners,
     * making the AudioContext be resumed later.
     *
     * @private
     */
    private _safelyResumeContext;
    /**
     * Add the necessary Window EventListeners for resuming the AudioContext to comply with auto-play policies.
     * For more info, https://developers.google.com/web/updates/2018/11/web-audio-autoplay.
     *
     * @private
     */
    private _addAudioContextUserInteractionListeners;
}



/** @typedef {import('./system.js').ComponentSystem} ComponentSystem */
/** @typedef {import('../entity.js').Entity} Entity */
/**
 * Components are used to attach functionality on a {@link Entity}. Components can receive update
 * events each frame, and expose properties to the PlayCanvas Editor.
 *
 * @property {boolean} enabled Enables or disables the component.
 * @augments EventHandler
 */
declare class Component extends EventHandler {
    static _buildAccessors(obj: any, schema: any): void;
    /**
     * Base constructor for a Component.
     *
     * @param {ComponentSystem} system - The ComponentSystem used to create this Component.
     * @param {Entity} entity - The Entity that this Component is attached to.
     */
    constructor(system: ComponentSystem, entity: Entity);

    set enabled(arg: boolean);
    get enabled(): boolean;

    /**
     * The ComponentSystem used to create this Component.
     *
     * @type {ComponentSystem}
     * @ignore
     */
    system: ComponentSystem;
    /**
     * The Entity that this Component is attached to.
     *
     * @type {Entity}
     * @ignore
     */
    entity: Entity;
    buildAccessors(schema: any): void;
    onSetEnabled(name: any, oldValue: any, newValue: any): void;
    onEnable(): void;
    onDisable(): void;
    onPostStateChange(): void;
    /**
     * Access the component data directly. Usually you should access the data properties via the
     * individual properties as modifying this data directly will not fire 'set' events.
     *
     * @type {*}
     * @ignore
     */
    get data(): any;
}




/** @typedef {import('../app-base.js').AppBase} AppBase */
/** @typedef {import('./component.js').Component} Component */
/** @typedef {import('../entity.js').Entity} Entity */
/**
 * Component Systems contain the logic and functionality to update all Components of a particular
 * type.
 *
 * @augments EventHandler
 */
declare class ComponentSystem extends EventHandler {
    /**
     * Create a new ComponentSystem instance.
     *
     * @param {AppBase} app - The application managing this system.
     */
    constructor(app: AppBase);
    app: AppBase;
    store: {};
    schema: any[];
    /**
     * Create new {@link Component} and component data instances and attach them to the entity.
     *
     * @param {Entity} entity - The Entity to attach this component to.
     * @param {object} [data] - The source data with which to create the component.
     * @returns {Component} Returns a Component of type defined by the component system.
     * @example
     * var entity = new pc.Entity(app);
     * app.systems.model.addComponent(entity, { type: 'box' });
     * // entity.model is now set to a pc.ModelComponent
     * @ignore
     */
    addComponent(entity: Entity, data?: object): Component;
    /**
     * Remove the {@link Component} from the entity and delete the associated component data.
     *
     * @param {Entity} entity - The entity to remove the component from.
     * @example
     * app.systems.model.removeComponent(entity);
     * // entity.model === undefined
     * @ignore
     */
    removeComponent(entity: Entity): void;
    /**
     * Create a clone of component. This creates a copy of all component data variables.
     *
     * @param {Entity} entity - The entity to clone the component from.
     * @param {Entity} clone - The entity to clone the component into.
     * @returns {Component} The newly cloned component.
     * @ignore
     */
    cloneComponent(entity: Entity, clone: Entity): Component;
    /**
     * Called during {@link ComponentSystem#addComponent} to initialize the component data in the
     * store. This can be overridden by derived Component Systems and either called by the derived
     * System or replaced entirely.
     *
     * @param {Component} component - The component being initialized.
     * @param {object} data - The data block used to initialize the component.
     * @param {Array<string | {name: string, type: string}>} properties - The array of property descriptors for the component.
     * A descriptor can be either a plain property name, or an object specifying the name and type.
     * @ignore
     */
    initializeComponentData(component: Component, data: object, properties: Array<string | {
        name: string;
        type: string;
    }>): void;
    /**
     * Searches the component schema for properties that match the specified type.
     *
     * @param {string} type - The type to search for.
     * @returns {string[]|object[]} An array of property descriptors matching the specified type.
     * @ignore
     */
    getPropertiesOfType(type: string): string[] | object[];
    destroy(): void;
}

declare class SpriteComponentData {
    enabled: boolean;
}

/**
 * Manages creation of {@link SpriteComponent}s.
 *
 * @augments ComponentSystem
 */
declare class SpriteComponentSystem extends ComponentSystem {
    id: string;
    ComponentType: typeof SpriteComponent;
    DataType: typeof SpriteComponentData;
    schema: string[];
    _defaultTexture: Texture;
    _defaultMaterial: any;
    _default9SlicedMaterialSlicedMode: any;
    _default9SlicedMaterialTiledMode: any;
    set defaultMaterial(arg: any);
    get defaultMaterial(): any;
    set default9SlicedMaterialSlicedMode(arg: any);
    get default9SlicedMaterialSlicedMode(): any;
    set default9SlicedMaterialTiledMode(arg: any);
    get default9SlicedMaterialTiledMode(): any;
    initializeComponentData(component: any, data: any, properties: any): void;
    cloneComponent(entity: any, clone: any): Component;
    onUpdate(dt: any): void;
    onBeforeRemove(entity: any, component: any): void;
}

declare class TagsCache {
    constructor(key?: any);
    _index: {};
    _key: any;
    addItem(item: any): void;
    removeItem(item: any): void;
    add(tag: any, item: any): void;
    remove(tag: any, item: any): void;
    find(args: any): any[];
}


/**
 * Callback used by {@link AssetRegistryfilter } to filter assets.
 */
export type FilterAssetCallback = (asset: Asset) => boolean;
/**
 * Callback used by {@link AssetRegistryloadFromUrl } and called when an asset is loaded (or an
 * error occurs).
 */
export type LoadAssetCallback = (err: string | null, asset?: Asset) => any;
/** @typedef {import('../resources/loader.js').ResourceLoader} ResourceLoader */
/**
 * Callback used by {@link AssetRegistry#filter} to filter assets.
 *
 * @callback FilterAssetCallback
 * @param {Asset} asset - The current asset to filter.
 * @returns {boolean} Return `true` to include asset to result list.
 */
/**
 * Callback used by {@link AssetRegistry#loadFromUrl} and called when an asset is loaded (or an
 * error occurs).
 *
 * @callback LoadAssetCallback
 * @param {string|null} err - The error message is null if no errors were encountered.
 * @param {Asset} [asset] - The loaded asset if no errors were encountered.
 */
/**
 * Container for all assets that are available to this application. Note that PlayCanvas scripts
 * are provided with an AssetRegistry instance as `app.assets`.
 *
 * @augments EventHandler
 */
declare class AssetRegistry extends EventHandler {
    /**
     * Create an instance of an AssetRegistry.
     *
     * @param {ResourceLoader} loader - The ResourceLoader used to load the asset files.
     */
    constructor(loader: ResourceLoader);
    _loader: ResourceLoader;
    _assets: any[];
    _cache: {};
    _names: {};
    _tags: TagsCache;
    _urls: {};
    /**
     * A URL prefix that will be added to all asset loading requests.
     *
     * @type {string}
     */
    prefix: string;
    /**
     * Fired when an asset completes loading.
     *
     * @event AssetRegistry#load
     * @param {Asset} asset - The asset that has just loaded.
     * @example
     * app.assets.on("load", function (asset) {
     *     console.log("asset loaded: " + asset.name);
     * });
     */
    /**
     * Fired when an asset completes loading.
     *
     * @event AssetRegistry#load:[id]
     * @param {Asset} asset - The asset that has just loaded.
     * @example
     * var id = 123456;
     * var asset = app.assets.get(id);
     * app.assets.on("load:" + id, function (asset) {
     *     console.log("asset loaded: " + asset.name);
     * });
     * app.assets.load(asset);
     */
    /**
     * Fired when an asset completes loading.
     *
     * @event AssetRegistry#load:url:[url]
     * @param {Asset} asset - The asset that has just loaded.
     * @example
     * var id = 123456;
     * var asset = app.assets.get(id);
     * app.assets.on("load:url:" + asset.file.url, function (asset) {
     *     console.log("asset loaded: " + asset.name);
     * });
     * app.assets.load(asset);
     */
    /**
     * Fired when an asset is added to the registry.
     *
     * @event AssetRegistry#add
     * @param {Asset} asset - The asset that was added.
     * @example
     * app.assets.on("add", function (asset) {
     *     console.log("New asset added: " + asset.name);
     * });
     */
    /**
     * Fired when an asset is added to the registry.
     *
     * @event AssetRegistry#add:[id]
     * @param {Asset} asset - The asset that was added.
     * @example
     * var id = 123456;
     * app.assets.on("add:" + id, function (asset) {
     *     console.log("Asset 123456 loaded");
     * });
     */
    /**
     * Fired when an asset is added to the registry.
     *
     * @event AssetRegistry#add:url:[url]
     * @param {Asset} asset - The asset that was added.
     */
    /**
     * Fired when an asset is removed from the registry.
     *
     * @event AssetRegistry#remove
     * @param {Asset} asset - The asset that was removed.
     * @example
     * app.assets.on("remove", function (asset) {
     *     console.log("Asset removed: " + asset.name);
     * });
     */
    /**
     * Fired when an asset is removed from the registry.
     *
     * @event AssetRegistry#remove:[id]
     * @param {Asset} asset - The asset that was removed.
     * @example
     * var id = 123456;
     * app.assets.on("remove:" + id, function (asset) {
     *     console.log("Asset removed: " + asset.name);
     * });
     */
    /**
     * Fired when an asset is removed from the registry.
     *
     * @event AssetRegistry#remove:url:[url]
     * @param {Asset} asset - The asset that was removed.
     */
    /**
     * Fired when an error occurs during asset loading.
     *
     * @event AssetRegistry#error
     * @param {string} err - The error message.
     * @param {Asset} asset - The asset that generated the error.
     * @example
     * var id = 123456;
     * var asset = app.assets.get(id);
     * app.assets.on("error", function (err, asset) {
     *     console.error(err);
     * });
     * app.assets.load(asset);
     */
    /**
     * Fired when an error occurs during asset loading.
     *
     * @event AssetRegistry#error:[id]
     * @param {Asset} asset - The asset that generated the error.
     * @example
     * var id = 123456;
     * var asset = app.assets.get(id);
     * app.assets.on("error:" + id, function (err, asset) {
     *     console.error(err);
     * });
     * app.assets.load(asset);
     */
    /**
     * Create a filtered list of assets from the registry.
     *
     * @param {object} filters - Properties to filter on, currently supports: 'preload: true|false'.
     * @returns {Asset[]} The filtered list of assets.
     */
    list(filters: object): Asset[];
    /**
     * Add an asset to the registry.
     *
     * @param {Asset} asset - The asset to add.
     * @example
     * var asset = new pc.Asset("My Asset", "texture", {
     *     url: "../path/to/image.jpg"
     * });
     * app.assets.add(asset);
     */
    add(asset: Asset): void;
    /**
     * Remove an asset from the registry.
     *
     * @param {Asset} asset - The asset to remove.
     * @returns {boolean} True if the asset was successfully removed and false otherwise.
     * @example
     * var asset = app.assets.get(100);
     * app.assets.remove(asset);
     */
    remove(asset: Asset): boolean;
    /**
     * Retrieve an asset from the registry by its id field.
     *
     * @param {number} id - The id of the asset to get.
     * @returns {Asset} The asset.
     * @example
     * var asset = app.assets.get(100);
     */
    get(id: number): Asset;
    /**
     * Retrieve an asset from the registry by its file's URL field.
     *
     * @param {string} url - The url of the asset to get.
     * @returns {Asset} The asset.
     * @example
     * var asset = app.assets.getByUrl("../path/to/image.jpg");
     */
    getByUrl(url: string): Asset;
    /**
     * Load the asset's file from a remote source. Listen for "load" events on the asset to find
     * out when it is loaded.
     *
     * @param {Asset} asset - The asset to load.
     * @example
     * // load some assets
     * var assetsToLoad = [
     *     app.assets.find("My Asset"),
     *     app.assets.find("Another Asset")
     * ];
     * var count = 0;
     * assetsToLoad.forEach(function (assetToLoad) {
     *     assetToLoad.ready(function (asset) {
     *         count++;
     *         if (count === assetsToLoad.length) {
     *             // done
     *         }
     *     });
     *     app.assets.load(assetToLoad);
     * });
     */
    load(asset: Asset): void;
    /**
     * Use this to load and create an asset if you don't have assets created. Usually you would
     * only use this if you are not integrated with the PlayCanvas Editor.
     *
     * @param {string} url - The url to load.
     * @param {string} type - The type of asset to load.
     * @param {LoadAssetCallback} callback - Function called when asset is loaded, passed (err,
     * asset), where err is null if no errors were encountered.
     * @example
     * app.assets.loadFromUrl("../path/to/texture.jpg", "texture", function (err, asset) {
     *     var texture = asset.resource;
     * });
     */
    loadFromUrl(url: string, type: string, callback: LoadAssetCallback): void;
    /**
     * Use this to load and create an asset when both the URL and filename are required. For
     * example, use this function when loading BLOB assets, where the URL does not adequately
     * identify the file.
     *
     * @param {string} url - The url to load.
     * @param {string} filename - The filename of the asset to load.
     * @param {string} type - The type of asset to load.
     * @param {LoadAssetCallback} callback - Function called when asset is loaded, passed (err,
     * asset), where err is null if no errors were encountered.
     * @example
     * var file = magicallyAttainAFile();
     * app.assets.loadFromUrlAndFilename(URL.createObjectURL(file), "texture.png", "texture", function (err, asset) {
     *     var texture = asset.resource;
     * });
     */
    loadFromUrlAndFilename(url: string, filename: string, type: string, callback: LoadAssetCallback): void;
    loadFromUrlError: any;
    _loadModel(modelAsset: any, continuation: any): void;
    _loadMaterials(modelAsset: any, mapping: any, callback: any): void;
    _loadTextures(materialAsset: any, callback: any): void;
    /**
     * Return all Assets with the specified name and type found in the registry.
     *
     * @param {string} name - The name of the Assets to find.
     * @param {string} [type] - The type of the Assets to find.
     * @returns {Asset[]} A list of all Assets found.
     * @example
     * var assets = app.assets.findAll("myTextureAsset", "texture");
     * console.log("Found " + assets.length + " assets called " + name);
     */
    findAll(name: string, type?: string): Asset[];
    _onTagAdd(tag: any, asset: any): void;
    _onTagRemove(tag: any, asset: any): void;
    /**
     * Return all Assets that satisfy the search query. Query can be simply a string, or comma
     * separated strings, to have inclusive results of assets that match at least one query. A
     * query that consists of an array of tags can be used to match assets that have each tag of
     * array.
     *
     * @param {...*} query - Name of a tag or array of tags.
     * @returns {Asset[]} A list of all Assets matched query.
     * @example
     * var assets = app.assets.findByTag("level-1");
     * // returns all assets that tagged by `level-1`
     * @example
     * var assets = app.assets.findByTag("level-1", "level-2");
     * // returns all assets that tagged by `level-1` OR `level-2`
     * @example
     * var assets = app.assets.findByTag(["level-1", "monster"]);
     * // returns all assets that tagged by `level-1` AND `monster`
     * @example
     * var assets = app.assets.findByTag(["level-1", "monster"], ["level-2", "monster"]);
     * // returns all assets that tagged by (`level-1` AND `monster`) OR (`level-2` AND `monster`)
     */
    findByTag(...args: any[]): Asset[];
    /**
     * Return all Assets that satisfy a filter callback.
     *
     * @param {FilterAssetCallback} callback - The callback function that is used to filter assets.
     * Return `true` to include an asset in the returned array.
     * @returns {Asset[]} A list of all Assets found.
     * @example
     * var assets = app.assets.filter(function (asset) {
     *     return asset.name.indexOf('monster') !== -1;
     * });
     * console.log("Found " + assets.length + " assets, where names contains 'monster'");
     */
    filter(callback: FilterAssetCallback): Asset[];
    /**
     * Return the first Asset with the specified name and type found in the registry.
     *
     * @param {string} name - The name of the Asset to find.
     * @param {string} [type] - The type of the Asset to find.
     * @returns {Asset|null} A single Asset or null if no Asset is found.
     * @example
     * var asset = app.assets.find("myTextureAsset", "texture");
     */
    find(name: string, type?: string): Asset | null;
}



/**
 * Callback used by {@link ResourceHandlerload } when a resource is loaded (or an error occurs).
 */
export type ResourceHandlerCallback = (err: string | null, response?: any) => any;
/** @typedef {import('../asset/asset.js').Asset} Asset */
/** @typedef {import('../asset/asset-registry.js').AssetRegistry} AssetRegistry */
/**
 * Callback used by {@link ResourceHandler#load} when a resource is loaded (or an error occurs).
 *
 * @callback ResourceHandlerCallback
 * @param {string|null} err - The error message in the case where the load fails.
 * @param {*} [response] - The raw data that has been successfully loaded.
 */
/**
 * @interface
 * @name ResourceHandler
 * @description Interface for ResourceHandlers used by {@link ResourceLoader}.
 */
interface ResourceHandler {
    /**
     * @function
     * @name ResourceHandler#load
     * @description Load a resource from a remote URL. When loaded (or failed),
     * use the callback to return an the raw resource data (or error).
     * @param {string|object} url - Either the URL of the resource to load or a structure containing the
     * load and original URL.
     * @param {string} [url.load] - The URL to be used for loading the resource.
     * @param {string} [url.original] - The original URL to be used for identifying the resource
     * format. This is necessary when loading, for example from blob.
     * @param {ResourceHandlerCallback} callback - The callback used when the resource is loaded or an error occurs.
     * @param {Asset} [asset] - Optional asset that is passed by ResourceLoader.
     */
    load(url: string | object, callback: ResourceHandlerCallback, asset?: Asset): void;
    /**
     * @function
     * @name ResourceHandler#open
     * @description Convert raw resource data into a resource instance. E.g. Take 3D model format JSON and return a {@link Model}.
     * @param {string} url - The URL of the resource to open.
     * @param {*} data - The raw resource data passed by callback from {@link ResourceHandler#load}.
     * @param {Asset} [asset] - Optional asset that is passed by ResourceLoader.
     * @returns {*} The parsed resource data.
     */
    open(url: string, data: any, asset?: Asset): any;
    /**
     * @function
     * @name ResourceHandler#[patch]
     * @description Optional function to perform any operations on a resource, that requires a dependency on its asset data
     * or any other asset data.
     * @param {Asset} asset - The asset to patch.
     * @param {AssetRegistry} assets - The asset registry.
     */
    patch?(asset: Asset, assets: AssetRegistry): void;
}





/**
 * Callback used by {@link ResourceLoaderload } when a resource is loaded (or an error occurs).
 */
export type ResourceLoaderCallback = (err: string | null, resource?: any) => any;
/** @typedef {import('../asset/asset.js').Asset} Asset */
/** @typedef {import('../asset/asset-registry.js').AssetRegistry} AssetRegistry */
/** @typedef {import('../framework/app-base.js').AppBase} AppBase */
/** @typedef {import('./handler.js').ResourceHandler} ResourceHandler */
/**
 * Callback used by {@link ResourceLoader#load} when a resource is loaded (or an error occurs).
 *
 * @callback ResourceLoaderCallback
 * @param {string|null} err - The error message in the case where the load fails.
 * @param {*} [resource] - The resource that has been successfully loaded.
 */
/**
 * Load resource data, potentially from remote sources. Caches resource on load to prevent multiple
 * requests. Add ResourceHandlers to handle different types of resources.
 */
declare class ResourceLoader {
    /**
     * Create a new ResourceLoader instance.
     *
     * @param {AppBase} app - The application.
     */
    constructor(app: AppBase);
    _handlers: {};
    _requests: {};
    _cache: {};
    _app: AppBase;
    /**
     * Add a {@link ResourceHandler} for a resource type. Handler should support at least `load()`
     * and `open()`. Handlers can optionally support patch(asset, assets) to handle dependencies on
     * other assets.
     *
     * @param {string} type - The name of the resource type that the handler will be registered
     * with. Can be:
     *
     * - {@link ASSET_ANIMATION}
     * - {@link ASSET_AUDIO}
     * - {@link ASSET_IMAGE}
     * - {@link ASSET_JSON}
     * - {@link ASSET_MODEL}
     * - {@link ASSET_MATERIAL}
     * - {@link ASSET_TEXT}
     * - {@link ASSET_TEXTURE}
     * - {@link ASSET_CUBEMAP}
     * - {@link ASSET_SHADER}
     * - {@link ASSET_CSS}
     * - {@link ASSET_HTML}
     * - {@link ASSET_SCRIPT}
     * - {@link ASSET_CONTAINER}
     *
     * @param {ResourceHandler} handler - An instance of a resource handler supporting at least
     * `load()` and `open()`.
     * @example
     * var loader = new ResourceLoader();
     * loader.addHandler("json", new pc.JsonHandler());
     */
    addHandler(type: string, handler: ResourceHandler): void;
    /**
     * Remove a {@link ResourceHandler} for a resource type.
     *
     * @param {string} type - The name of the type that the handler will be removed.
     */
    removeHandler(type: string): void;
    /**
     * Get a {@link ResourceHandler} for a resource type.
     *
     * @param {string} type - The name of the resource type that the handler is registered with.
     * @returns {ResourceHandler} The registered handler.
     */
    getHandler(type: string): ResourceHandler;
    /**
     * Make a request for a resource from a remote URL. Parse the returned data using the handler
     * for the specified type. When loaded and parsed, use the callback to return an instance of
     * the resource.
     *
     * @param {string} url - The URL of the resource to load.
     * @param {string} type - The type of resource expected.
     * @param {ResourceLoaderCallback} callback - The callback used when the resource is loaded or
     * an error occurs. Passed (err, resource) where err is null if there are no errors.
     * @param {Asset} [asset] - Optional asset that is passed into handler
     * @example
     * app.loader.load("../path/to/texture.png", "texture", function (err, texture) {
     *     // use texture here
     * });
     */
    load(url: string, type: string, callback: ResourceLoaderCallback, asset?: Asset): void;
    _loadNull(handler: any, callback: any, asset: any): void;
    _onSuccess(key: any, result: any, extra: any): void;
    _onFailure(key: any, err: any): void;
    /**
     * Convert raw resource data into a resource instance. E.g. Take 3D model format JSON and
     * return a {@link Model}.
     *
     * @param {string} type - The type of resource.
     * @param {*} data - The raw resource data.
     * @returns {*} The parsed resource data.
     */
    open(type: string, data: any): any;
    /**
     * Perform any operations on a resource, that requires a dependency on its asset data or any
     * other asset data.
     *
     * @param {Asset} asset - The asset to patch.
     * @param {AssetRegistry} assets - The asset registry.
     */
    patch(asset: Asset, assets: AssetRegistry): void;
    /**
     * Remove resource from cache.
     *
     * @param {string} url - The URL of the resource.
     * @param {string} type - The type of resource.
     */
    clearCache(url: string, type: string): void;
    /**
     * Check cache for resource from a URL. If present, return the cached value.
     *
     * @param {string} url - The URL of the resource to get from the cache.
     * @param {string} type - The type of the resource.
     * @returns {*} The resource loaded from the cache.
     */
    getFromCache(url: string, type: string): any;
    /**
     * Enables retrying of failed requests when loading assets.
     *
     * @param {number} maxRetries - The maximum number of times to retry loading an asset. Defaults
     * to 5.
     * @ignore
     */
    enableRetry(maxRetries?: number): void;
    /**
     * Disables retrying of failed requests when loading assets.
     *
     * @ignore
     */
    disableRetry(): void;
    /**
     * Destroys the resource loader.
     */
    destroy(): void;
}

/**
 * Set of tag names. Tags are automatically available on {@link Entity} and {@link Asset} as `tags`
 * field.
 *
 * @augments EventHandler
 */
declare class Tags extends EventHandler {
    /**
     * Create an instance of a Tags.
     *
     * @param {object} [parent] - Parent object who tags belong to.
     */
    constructor(parent?: object);
    _index: {};
    _list: any[];
    _parent: any;
    /**
     * @event Tags#add
     * @param {string} tag - Name of a tag added to a set.
     * @param {object} parent - Parent object who tags belong to.
     */
    /**
     * @event Tags#remove
     * @param {string} tag - Name of a tag removed from a set.
     * @param {object} parent - Parent object who tags belong to.
     */
    /**
     * Fires when tags have been added or removed. It will fire once on bulk changes, while
     * `add`/`remove` will fire on each tag operation.
     *
     * @event Tags#change
     * @param {object} [parent] - Parent object who tags belong to.
     */
    /**
     * Add a tag, duplicates are ignored. Can be array or comma separated arguments for multiple tags.
     *
     * @param {...*} name - Name of a tag, or array of tags.
     * @returns {boolean} True if any tag were added.
     * @example
     * tags.add('level-1');
     * @example
     * tags.add('ui', 'settings');
     * @example
     * tags.add(['level-2', 'mob']);
     */
    add(...args: any[]): boolean;
    /**
     * Remove tag.
     *
     * @param {...*} name - Name of a tag or array of tags.
     * @returns {boolean} True if any tag were removed.
     * @example
     * tags.remove('level-1');
     * @example
     * tags.remove('ui', 'settings');
     * @example
     * tags.remove(['level-2', 'mob']);
     */
    remove(...args: any[]): boolean;
    /**
     * Remove all tags.
     *
     * @example
     * tags.clear();
     */
    clear(): void;
    /**
     * Check if tags satisfy filters. Filters can be provided by simple name of tag, as well as by
     * array of tags. When an array is provided it will check if tags contain each tag within the
     * array. If any of comma separated argument is satisfied, then it will return true. Any number
     * of combinations are valid, and order is irrelevant.
     *
     * @param {...*} query - Name of a tag or array of tags.
     * @returns {boolean} True if filters are satisfied.
     * @example
     * tags.has('player'); // player
     * @example
     * tags.has('mob', 'player'); // player OR mob
     * @example
     * tags.has(['level-1', 'mob']); // monster AND level-1
     * @example
     * tags.has(['ui', 'settings'], ['ui', 'levels']); // (ui AND settings) OR (ui AND levels)
     */
    has(...args: any[]): boolean;
    /**
     * @param {string[]|string[][]} tags - Array of tags.
     * @returns {boolean} True if the supplied tags are present.
     * @private
     */
    private _has;
    /**
     * Returns immutable array of tags.
     *
     * @returns {string[]} Copy of tags array.
     */
    list(): string[];
    /**
     * @param {IArguments} args - Arguments to process.
     * @param {boolean} [flat] - If true, will flatten array of tags. Defaults to false.
     * @returns {string[]|string[][]} Array of tags.
     * @private
     */
    private _processArguments;
    /**
     * Number of tags in set.
     *
     * @type {number}
     */
    get size(): number;
}



/**
 * Callback used by {@link Assetready } and called when an asset is ready.
 */
export type AssetReadyCallback = (asset: Asset) => any;
/**
 * Callback used by {@link Asset#ready} and called when an asset is ready.
 *
 * @callback AssetReadyCallback
 * @param {Asset} asset - The ready asset.
 */
/**
 * An asset record of a file or data resource that can be loaded by the engine. The asset contains
 * four important fields:
 *
 * - `file`: contains the details of a file (filename, url) which contains the resource data, e.g.
 * an image file for a texture asset.
 * - `data`: contains a JSON blob which contains either the resource data for the asset (e.g.
 * material data) or additional data for the file (e.g. material mappings for a model).
 * - `options`: contains a JSON blob with handler-specific load options.
 * - `resource`: contains the final resource when it is loaded. (e.g. a {@link StandardMaterial} or
 * a {@link Texture}).
 *
 * See the {@link AssetRegistry} for details on loading resources from assets.
 *
 * @augments EventHandler
 */
declare class Asset extends EventHandler {
    /**
     * Helper function to resolve asset file data and return the contents as an ArrayBuffer. If the
     * asset file contents are present, that is returned. Otherwise the file data is be downloaded
     * via http.
     *
     * @param {string} loadUrl - The URL as passed into the handler
     * @param {ResourceLoaderCallback} callback - The callback function to receive results.
     * @param {Asset} [asset] - The asset
     * @param {number} maxRetries - Number of retries if http download is required
     * @ignore
     */
    static fetchArrayBuffer(loadUrl: string, callback: ResourceLoaderCallback, asset?: Asset, maxRetries?: number): void;
    /**
     * Create a new Asset record. Generally, Assets are created in the loading process and you
     * won't need to create them by hand.
     *
     * @param {string} name - A non-unique but human-readable name which can be later used to
     * retrieve the asset.
     * @param {string} type - Type of asset. One of ["animation", "audio", "binary", "container",
     * "cubemap", "css", "font", "json", "html", "material", "model", "script", "shader", "sprite",
     * "template", text", "texture"]
     * @param {object} [file] - Details about the file the asset is made from. At the least must
     * contain the 'url' field. For assets that don't contain file data use null.
     * @param {string} [file.url] - The URL of the resource file that contains the asset data.
     * @param {string} [file.filename] - The filename of the resource file or null if no filename
     * was set (e.g from using {@link AssetRegistry#loadFromUrl}).
     * @param {number} [file.size] - The size of the resource file or null if no size was set
     * (e.g. from using {@link AssetRegistry#loadFromUrl}).
     * @param {string} [file.hash] - The MD5 hash of the resource file data and the Asset data
     * field or null if hash was set (e.g from using {@link AssetRegistry#loadFromUrl}).
     * @param {ArrayBuffer} [file.contents] - Optional file contents. This is faster than wrapping
     * the data in a (base64 encoded) blob. Currently only used by container assets.
     * @param {object|string} [data] - JSON object or string with additional data about the asset.
     * (e.g. for texture and model assets) or contains the asset data itself (e.g. in the case of
     * materials).
     * @param {object} [options] - The asset handler options. For container options see
     * {@link ContainerHandler}.
     * @param {boolean} [options.crossOrigin] - For use with texture resources. For
     * browser-supported image formats only, enable cross origin.
     * @example
     * var asset = new pc.Asset("a texture", "texture", {
     *     url: "http://example.com/my/assets/here/texture.png"
     * });
     */
    constructor(name: string, type: string, file?: {
        url?: string;
        filename?: string;
        size?: number;
        hash?: string;
        contents?: ArrayBuffer;
    }, data?: object | string, options?: {
        crossOrigin?: boolean;
    });
    _id: number;
    /**
     * The name of the asset.
     *
     * @type {string}
     */
    name: string;
    /**
     * The type of the asset. One of ["animation", "audio", "binary", "container", "cubemap",
     * "css", "font", "json", "html", "material", "model", "render", "script", "shader", "sprite",
     * "template", "text", "texture"]
     *
     * @type {("animation"|"audio"|"binary"|"container"|"cubemap"|"css"|"font"|"json"|"html"|"material"|"model"|"render"|"script"|"shader"|"sprite"|"template"|"text"|"texture")}
     */
    type: ("animation" | "audio" | "binary" | "container" | "cubemap" | "css" | "font" | "json" | "html" | "material" | "model" | "render" | "script" | "shader" | "sprite" | "template" | "text" | "texture");
    /**
     * Asset tags. Enables finding of assets by tags using the {@link AssetRegistry#findByTag} method.
     *
     * @type {Tags}
     */
    tags: Tags;
    _preload: boolean;
    _file: any;
    _data: any;
    /**
     * Optional JSON data that contains the asset handler options.
     *
     * @type {object}
     */
    options: object;
    _resources: any[];
    _i18n: {};
    /**
     * True if the asset has finished attempting to load the resource. It is not guaranteed
     * that the resources are available as there could have been a network error.
     *
     * @type {boolean}
     */
    loaded: boolean;
    /**
     * True if the resource is currently being loaded.
     *
     * @type {boolean}
     */
    loading: boolean;
    /**
     * The asset registry that this Asset belongs to.
     *
     * @type {AssetRegistry}
     */
    registry: AssetRegistry;
    /**
     * The file details or null if no file.
     *
     * @type {object}
     */
    set file(arg: any);
    get file(): any;
    /**
     * Fired when the asset has completed loading.
     *
     * @event Asset#load
     * @param {Asset} asset - The asset that was loaded.
     */
    /**
     * Fired just before the asset unloads the resource. This allows for the opportunity to prepare
     * for an asset that will be unloaded. E.g. Changing the texture of a model to a default before
     * the one it was using is unloaded.
     *
     * @event Asset#unload
     * @param {Asset} asset - The asset that is due to be unloaded.
     */
    /**
     * Fired when the asset is removed from the asset registry.
     *
     * @event Asset#remove
     * @param {Asset} asset - The asset that was removed.
     */
    /**
     * Fired if the asset encounters an error while loading.
     *
     * @event Asset#error
     * @param {string} err - The error message.
     * @param {Asset} asset - The asset that generated the error.
     */
    /**
     * Fired when one of the asset properties `file`, `data`, `resource` or `resources` is changed.
     *
     * @event Asset#change
     * @param {Asset} asset - The asset that was loaded.
     * @param {string} property - The name of the property that changed.
     * @param {*} value - The new property value.
     * @param {*} oldValue - The old property value.
     */
    /**
     * Fired when we add a new localized asset id to the asset.
     *
     * @event Asset#add:localized
     * @param {string} locale - The locale.
     * @param {number} assetId - The asset id we added.
     */
    /**
     * Fired when we remove a localized asset id from the asset.
     *
     * @event Asset#remove:localized
     * @param {string} locale - The locale.
     * @param {number} assetId - The asset id we removed.
     */
    /**
     * The asset id.
     *
     * @type {number}
     */
    set id(arg: number);
    get id(): number;
    /**
     * Optional JSON data that contains either the complete resource data. (e.g. in the case of a
     * material) or additional data (e.g. in the case of a model it contains mappings from mesh to
     * material).
     *
     * @type {object}
     */
    set data(arg: any);
    get data(): any;
    /**
     * A reference to the resource when the asset is loaded. e.g. a {@link Texture} or a {@link Model}.
     *
     * @type {object}
     */
    set resource(arg: any);
    get resource(): any;
    /**
     * A reference to the resources of the asset when it's loaded. An asset can hold more runtime
     * resources than one e.g. cubemaps.
     *
     * @type {object[]}
     */
    set resources(arg: any[]);
    get resources(): any[];
    /**
     * If true the asset will be loaded during the preload phase of application set up.
     *
     * @type {boolean}
     */
    set preload(arg: boolean);
    get preload(): boolean;
    set loadFaces(arg: any);
    get loadFaces(): any;
    _loadFaces: any;
    /**
     * Return the URL required to fetch the file for this asset.
     *
     * @returns {string|null} The URL. Returns null if the asset has no associated file.
     * @example
     * var assets = app.assets.find("My Image", "texture");
     * var img = "&lt;img src='" + assets[0].getFileUrl() + "'&gt;";
     */
    getFileUrl(): string | null;
    /**
     * Construct an asset URL from this asset's location and a relative path. If the relativePath
     * is a blob or Base64 URI, then return that instead.
     *
     * @param {string} relativePath - The relative path to be concatenated to this asset's base url.
     * @returns {string} Resulting URL of the asset.
     * @ignore
     */
    getAbsoluteUrl(relativePath: string): string;
    /**
     * Returns the asset id of the asset that corresponds to the specified locale.
     *
     * @param {string} locale - The desired locale e.g. Ar-AR.
     * @returns {number} An asset id or null if there is no asset specified for the desired locale.
     * @ignore
     */
    getLocalizedAssetId(locale: string): number;
    /**
     * Adds a replacement asset id for the specified locale. When the locale in
     * {@link Application#i18n} changes then references to this asset will be replaced with the
     * specified asset id. (Currently only supported by the {@link ElementComponent}).
     *
     * @param {string} locale - The locale e.g. Ar-AR.
     * @param {number} assetId - The asset id.
     * @ignore
     */
    addLocalizedAssetId(locale: string, assetId: number): void;
    /**
     * Removes a localized asset.
     *
     * @param {string} locale - The locale e.g. Ar-AR.
     * @ignore
     */
    removeLocalizedAssetId(locale: string): void;
    /**
     * Take a callback which is called as soon as the asset is loaded. If the asset is already
     * loaded the callback is called straight away.
     *
     * @param {AssetReadyCallback} callback - The function called when the asset is ready. Passed
     * the (asset) arguments.
     * @param {object} [scope] - Scope object to use when calling the callback.
     * @example
     * var asset = app.assets.find("My Asset");
     * asset.ready(function (asset) {
     *   // asset loaded
     * });
     * app.assets.load(asset);
     */
    ready(callback: AssetReadyCallback, scope?: object): void;
    reload(): void;
    /**
     * Destroys the associated resource and marks asset as unloaded.
     *
     * @example
     * var asset = app.assets.find("My Asset");
     * asset.unload();
     * // asset.resource is null
     */
    unload(): void;
}

/**
 * Representation of an RGBA color.
 */
declare class Color {
    /**
     * A constant color set to black [0, 0, 0, 1].
     *
     * @type {Color}
     * @readonly
     */
    static readonly BLACK: Color;
    /**
     * A constant color set to blue [0, 0, 1, 1].
     *
     * @type {Color}
     * @readonly
     */
    static readonly BLUE: Color;
    /**
     * A constant color set to cyan [0, 1, 1, 1].
     *
     * @type {Color}
     * @readonly
     */
    static readonly CYAN: Color;
    /**
     * A constant color set to gray [0.5, 0.5, 0.5, 1].
     *
     * @type {Color}
     * @readonly
     */
    static readonly GRAY: Color;
    /**
     * A constant color set to green [0, 1, 0, 1].
     *
     * @type {Color}
     * @readonly
     */
    static readonly GREEN: Color;
    /**
     * A constant color set to magenta [1, 0, 1, 1].
     *
     * @type {Color}
     * @readonly
     */
    static readonly MAGENTA: Color;
    /**
     * A constant color set to red [1, 0, 0, 1].
     *
     * @type {Color}
     * @readonly
     */
    static readonly RED: Color;
    /**
     * A constant color set to white [1, 1, 1, 1].
     *
     * @type {Color}
     * @readonly
     */
    static readonly WHITE: Color;
    /**
     * A constant color set to yellow [1, 1, 0, 1].
     *
     * @type {Color}
     * @readonly
     */
    static readonly YELLOW: Color;
    /**
     * Create a new Color object.
     *
     * @param {number|number[]} [r] - The value of the red component (0-1). Defaults to 0. If r is
     * an array of length 3 or 4, the array will be used to populate all components.
     * @param {number} [g] - The value of the green component (0-1). Defaults to 0.
     * @param {number} [b] - The value of the blue component (0-1). Defaults to 0.
     * @param {number} [a] - The value of the alpha component (0-1). Defaults to 1.
     */
    constructor(r?: number | number[], g?: number, b?: number, a?: number);
    /**
     * The red component of the color.
     *
     * @type {number}
     */
    r: number;
    /**
     * The green component of the color.
     *
     * @type {number}
     */
    g: number;
    /**
     * The blue component of the color.
     *
     * @type {number}
     */
    b: number;
    /**
     * The alpha component of the color.
     *
     * @type {number}
     */
    a: number;
    /**
     * Returns a clone of the specified color.
     *
     * @returns {this} A duplicate color object.
     */
    clone(): this;
    /**
     * Copies the contents of a source color to a destination color.
     *
     * @param {Color} rhs - A color to copy to the specified color.
     * @returns {Color} Self for chaining.
     * @example
     * var src = new pc.Color(1, 0, 0, 1);
     * var dst = new pc.Color();
     *
     * dst.copy(src);
     *
     * console.log("The two colors are " + (dst.equals(src) ? "equal" : "different"));
     */
    copy(rhs: Color): Color;
    /**
     * Reports whether two colors are equal.
     *
     * @param {Color} rhs - The color to compare to the specified color.
     * @returns {boolean} True if the colors are equal and false otherwise.
     * @example
     * var a = new pc.Color(1, 0, 0, 1);
     * var b = new pc.Color(1, 1, 0, 1);
     * console.log("The two colors are " + (a.equals(b) ? "equal" : "different"));
     */
    equals(rhs: Color): boolean;
    /**
     * Assign values to the color components, including alpha.
     *
     * @param {number} r - The value for red (0-1).
     * @param {number} g - The value for blue (0-1).
     * @param {number} b - The value for green (0-1).
     * @param {number} [a] - The value for the alpha (0-1), defaults to 1.
     * @returns {Color} Self for chaining.
     */
    set(r: number, g: number, b: number, a?: number): Color;
    /**
     * Returns the result of a linear interpolation between two specified colors.
     *
     * @param {Color} lhs - The color to interpolate from.
     * @param {Color} rhs - The color to interpolate to.
     * @param {number} alpha - The value controlling the point of interpolation. Between 0 and 1,
     * the linear interpolant will occur on a straight line between lhs and rhs. Outside of this
     * range, the linear interpolant will occur on a ray extrapolated from this line.
     * @returns {Color} Self for chaining.
     * @example
     * var a = new pc.Color(0, 0, 0);
     * var b = new pc.Color(1, 1, 0.5);
     * var r = new pc.Color();
     *
     * r.lerp(a, b, 0);   // r is equal to a
     * r.lerp(a, b, 0.5); // r is 0.5, 0.5, 0.25
     * r.lerp(a, b, 1);   // r is equal to b
     */
    lerp(lhs: Color, rhs: Color, alpha: number): Color;
    /**
     * Set the values of the color from a string representation '#11223344' or '#112233'.
     *
     * @param {string} hex - A string representation in the format '#RRGGBBAA' or '#RRGGBB'. Where
     * RR, GG, BB, AA are red, green, blue and alpha values. This is the same format used in
     * HTML/CSS.
     * @returns {Color} Self for chaining.
     */
    fromString(hex: string): Color;
    /**
     * Converts the color to string form. The format is '#RRGGBBAA', where RR, GG, BB, AA are the
     * red, green, blue and alpha values. When the alpha value is not included (the default), this
     * is the same format as used in HTML/CSS.
     *
     * @param {boolean} alpha - If true, the output string will include the alpha value.
     * @returns {string} The color in string form.
     * @example
     * var c = new pc.Color(1, 1, 1);
     * // Outputs #ffffffff
     * console.log(c.toString());
     */
    toString(alpha: boolean): string;
}

/**
 * A 2-dimensional vector.
 */
declare class Vec2 {
    /**
     * Calculates the angle between two Vec2's in radians.
     *
     * @param {Vec2} lhs - The first vector operand for the calculation.
     * @param {Vec2} rhs - The second vector operand for the calculation.
     * @returns {number} The calculated angle in radians.
     * @ignore
     */
    static angleRad(lhs: Vec2, rhs: Vec2): number;
    /**
     * A constant vector set to [0, 0].
     *
     * @type {Vec2}
     * @readonly
     */
    static readonly ZERO: Vec2;
    /**
     * A constant vector set to [1, 1].
     *
     * @type {Vec2}
     * @readonly
     */
    static readonly ONE: Vec2;
    /**
     * A constant vector set to [0, 1].
     *
     * @type {Vec2}
     * @readonly
     */
    static readonly UP: Vec2;
    /**
     * A constant vector set to [0, -1].
     *
     * @type {Vec2}
     * @readonly
     */
    static readonly DOWN: Vec2;
    /**
     * A constant vector set to [1, 0].
     *
     * @type {Vec2}
     * @readonly
     */
    static readonly RIGHT: Vec2;
    /**
     * A constant vector set to [-1, 0].
     *
     * @type {Vec2}
     * @readonly
     */
    static readonly LEFT: Vec2;
    /**
     * Create a new Vec2 instance.
     *
     * @param {number|number[]} [x] - The x value. Defaults to 0. If x is an array of length 2, the
     * array will be used to populate all components.
     * @param {number} [y] - The y value. Defaults to 0.
     * @example
     * var v = new pc.Vec2(1, 2);
     */
    constructor(x?: number | number[], y?: number);
    /**
     * The first component of the vector.
     *
     * @type {number}
     */
    x: number;
    /**
     * The second component of the vector.
     *
     * @type {number}
     */
    y: number;
    /**
     * Adds a 2-dimensional vector to another in place.
     *
     * @param {Vec2} rhs - The vector to add to the specified vector.
     * @returns {Vec2} Self for chaining.
     * @example
     * var a = new pc.Vec2(10, 10);
     * var b = new pc.Vec2(20, 20);
     *
     * a.add(b);
     *
     * // Outputs [30, 30]
     * console.log("The result of the addition is: " + a.toString());
     */
    add(rhs: Vec2): Vec2;
    /**
     * Adds two 2-dimensional vectors together and returns the result.
     *
     * @param {Vec2} lhs - The first vector operand for the addition.
     * @param {Vec2} rhs - The second vector operand for the addition.
     * @returns {Vec2} Self for chaining.
     * @example
     * var a = new pc.Vec2(10, 10);
     * var b = new pc.Vec2(20, 20);
     * var r = new pc.Vec2();
     *
     * r.add2(a, b);
     * // Outputs [30, 30]
     *
     * console.log("The result of the addition is: " + r.toString());
     */
    add2(lhs: Vec2, rhs: Vec2): Vec2;
    /**
     * Adds a number to each element of a vector.
     *
     * @param {number} scalar - The number to add.
     * @returns {Vec2} Self for chaining.
     * @example
     * var vec = new pc.Vec2(3, 4);
     *
     * vec.addScalar(2);
     *
     * // Outputs [5, 6]
     * console.log("The result of the addition is: " + vec.toString());
     */
    addScalar(scalar: number): Vec2;
    /**
     * Returns an identical copy of the specified 2-dimensional vector.
     *
     * @returns {this} A 2-dimensional vector containing the result of the cloning.
     * @example
     * var v = new pc.Vec2(10, 20);
     * var vclone = v.clone();
     * console.log("The result of the cloning is: " + vclone.toString());
     */
    clone(): this;
    /**
     * Copies the contents of a source 2-dimensional vector to a destination 2-dimensional vector.
     *
     * @param {Vec2} rhs - A vector to copy to the specified vector.
     * @returns {Vec2} Self for chaining.
     * @example
     * var src = new pc.Vec2(10, 20);
     * var dst = new pc.Vec2();
     *
     * dst.copy(src);
     *
     * console.log("The two vectors are " + (dst.equals(src) ? "equal" : "different"));
     */
    copy(rhs: Vec2): Vec2;
    /**
     * Returns the result of a cross product operation performed on the two specified 2-dimensional
     * vectors.
     *
     * @param {Vec2} rhs - The second 2-dimensional vector operand of the cross product.
     * @returns {number} The cross product of the two vectors.
     * @example
     * var right = new pc.Vec2(1, 0);
     * var up = new pc.Vec2(0, 1);
     * var crossProduct = right.cross(up);
     *
     * // Prints 1
     * console.log("The result of the cross product is: " + crossProduct);
     */
    cross(rhs: Vec2): number;
    /**
     * Returns the distance between the two specified 2-dimensional vectors.
     *
     * @param {Vec2} rhs - The second 2-dimensional vector to test.
     * @returns {number} The distance between the two vectors.
     * @example
     * var v1 = new pc.Vec2(5, 10);
     * var v2 = new pc.Vec2(10, 20);
     * var d = v1.distance(v2);
     * console.log("The distance between v1 and v2 is: " + d);
     */
    distance(rhs: Vec2): number;
    /**
     * Divides a 2-dimensional vector by another in place.
     *
     * @param {Vec2} rhs - The vector to divide the specified vector by.
     * @returns {Vec2} Self for chaining.
     * @example
     * var a = new pc.Vec2(4, 9);
     * var b = new pc.Vec2(2, 3);
     *
     * a.div(b);
     *
     * // Outputs [2, 3]
     * console.log("The result of the division is: " + a.toString());
     */
    div(rhs: Vec2): Vec2;
    /**
     * Divides one 2-dimensional vector by another and writes the result to the specified vector.
     *
     * @param {Vec2} lhs - The dividend vector (the vector being divided).
     * @param {Vec2} rhs - The divisor vector (the vector dividing the dividend).
     * @returns {Vec2} Self for chaining.
     * @example
     * var a = new pc.Vec2(4, 9);
     * var b = new pc.Vec2(2, 3);
     * var r = new pc.Vec2();
     *
     * r.div2(a, b);
     * // Outputs [2, 3]
     *
     * console.log("The result of the division is: " + r.toString());
     */
    div2(lhs: Vec2, rhs: Vec2): Vec2;
    /**
     * Divides each element of a vector by a number.
     *
     * @param {number} scalar - The number to divide by.
     * @returns {Vec2} Self for chaining.
     * @example
     * var vec = new pc.Vec2(3, 6);
     *
     * vec.divScalar(3);
     *
     * // Outputs [1, 2]
     * console.log("The result of the division is: " + vec.toString());
     */
    divScalar(scalar: number): Vec2;
    /**
     * Returns the result of a dot product operation performed on the two specified 2-dimensional
     * vectors.
     *
     * @param {Vec2} rhs - The second 2-dimensional vector operand of the dot product.
     * @returns {number} The result of the dot product operation.
     * @example
     * var v1 = new pc.Vec2(5, 10);
     * var v2 = new pc.Vec2(10, 20);
     * var v1dotv2 = v1.dot(v2);
     * console.log("The result of the dot product is: " + v1dotv2);
     */
    dot(rhs: Vec2): number;
    /**
     * Reports whether two vectors are equal.
     *
     * @param {Vec2} rhs - The vector to compare to the specified vector.
     * @returns {boolean} True if the vectors are equal and false otherwise.
     * @example
     * var a = new pc.Vec2(1, 2);
     * var b = new pc.Vec2(4, 5);
     * console.log("The two vectors are " + (a.equals(b) ? "equal" : "different"));
     */
    equals(rhs: Vec2): boolean;
    /**
     * Returns the magnitude of the specified 2-dimensional vector.
     *
     * @returns {number} The magnitude of the specified 2-dimensional vector.
     * @example
     * var vec = new pc.Vec2(3, 4);
     * var len = vec.length();
     * // Outputs 5
     * console.log("The length of the vector is: " + len);
     */
    length(): number;
    /**
     * Returns the magnitude squared of the specified 2-dimensional vector.
     *
     * @returns {number} The magnitude of the specified 2-dimensional vector.
     * @example
     * var vec = new pc.Vec2(3, 4);
     * var len = vec.lengthSq();
     * // Outputs 25
     * console.log("The length squared of the vector is: " + len);
     */
    lengthSq(): number;
    /**
     * Returns the result of a linear interpolation between two specified 2-dimensional vectors.
     *
     * @param {Vec2} lhs - The 2-dimensional to interpolate from.
     * @param {Vec2} rhs - The 2-dimensional to interpolate to.
     * @param {number} alpha - The value controlling the point of interpolation. Between 0 and 1,
     * the linear interpolant will occur on a straight line between lhs and rhs. Outside of this
     * range, the linear interpolant will occur on a ray extrapolated from this line.
     * @returns {Vec2} Self for chaining.
     * @example
     * var a = new pc.Vec2(0, 0);
     * var b = new pc.Vec2(10, 10);
     * var r = new pc.Vec2();
     *
     * r.lerp(a, b, 0);   // r is equal to a
     * r.lerp(a, b, 0.5); // r is 5, 5
     * r.lerp(a, b, 1);   // r is equal to b
     */
    lerp(lhs: Vec2, rhs: Vec2, alpha: number): Vec2;
    /**
     * Multiplies a 2-dimensional vector to another in place.
     *
     * @param {Vec2} rhs - The 2-dimensional vector used as the second multiplicand of the operation.
     * @returns {Vec2} Self for chaining.
     * @example
     * var a = new pc.Vec2(2, 3);
     * var b = new pc.Vec2(4, 5);
     *
     * a.mul(b);
     *
     * // Outputs 8, 15
     * console.log("The result of the multiplication is: " + a.toString());
     */
    mul(rhs: Vec2): Vec2;
    /**
     * Returns the result of multiplying the specified 2-dimensional vectors together.
     *
     * @param {Vec2} lhs - The 2-dimensional vector used as the first multiplicand of the operation.
     * @param {Vec2} rhs - The 2-dimensional vector used as the second multiplicand of the operation.
     * @returns {Vec2} Self for chaining.
     * @example
     * var a = new pc.Vec2(2, 3);
     * var b = new pc.Vec2(4, 5);
     * var r = new pc.Vec2();
     *
     * r.mul2(a, b);
     *
     * // Outputs 8, 15
     * console.log("The result of the multiplication is: " + r.toString());
     */
    mul2(lhs: Vec2, rhs: Vec2): Vec2;
    /**
     * Multiplies each element of a vector by a number.
     *
     * @param {number} scalar - The number to multiply by.
     * @returns {Vec2} Self for chaining.
     * @example
     * var vec = new pc.Vec2(3, 6);
     *
     * vec.mulScalar(3);
     *
     * // Outputs [9, 18]
     * console.log("The result of the multiplication is: " + vec.toString());
     */
    mulScalar(scalar: number): Vec2;
    /**
     * Returns this 2-dimensional vector converted to a unit vector in place. If the vector has a
     * length of zero, the vector's elements will be set to zero.
     *
     * @returns {Vec2} Self for chaining.
     * @example
     * var v = new pc.Vec2(25, 0);
     *
     * v.normalize();
     *
     * // Outputs 1, 0
     * console.log("The result of the vector normalization is: " + v.toString());
     */
    normalize(): Vec2;
    /**
     * Each element is set to the largest integer less than or equal to its value.
     *
     * @returns {Vec2} Self for chaining.
     */
    floor(): Vec2;
    /**
     * Each element is rounded up to the next largest integer.
     *
     * @returns {Vec2} Self for chaining.
     */
    ceil(): Vec2;
    /**
     * Each element is rounded up or down to the nearest integer.
     *
     * @returns {Vec2} Self for chaining.
     */
    round(): Vec2;
    /**
     * Each element is assigned a value from rhs parameter if it is smaller.
     *
     * @param {Vec2} rhs - The 2-dimensional vector used as the source of elements to compare to.
     * @returns {Vec2} Self for chaining.
     */
    min(rhs: Vec2): Vec2;
    /**
     * Each element is assigned a value from rhs parameter if it is larger.
     *
     * @param {Vec2} rhs - The 2-dimensional vector used as the source of elements to compare to.
     * @returns {Vec2} Self for chaining.
     */
    max(rhs: Vec2): Vec2;
    /**
     * Sets the specified 2-dimensional vector to the supplied numerical values.
     *
     * @param {number} x - The value to set on the first component of the vector.
     * @param {number} y - The value to set on the second component of the vector.
     * @returns {Vec2} Self for chaining.
     * @example
     * var v = new pc.Vec2();
     * v.set(5, 10);
     *
     * // Outputs 5, 10
     * console.log("The result of the vector set is: " + v.toString());
     */
    set(x: number, y: number): Vec2;
    /**
     * Subtracts a 2-dimensional vector from another in place.
     *
     * @param {Vec2} rhs - The vector to add to the specified vector.
     * @returns {Vec2} Self for chaining.
     * @example
     * var a = new pc.Vec2(10, 10);
     * var b = new pc.Vec2(20, 20);
     *
     * a.sub(b);
     *
     * // Outputs [-10, -10]
     * console.log("The result of the subtraction is: " + a.toString());
     */
    sub(rhs: Vec2): Vec2;
    /**
     * Subtracts two 2-dimensional vectors from one another and returns the result.
     *
     * @param {Vec2} lhs - The first vector operand for the addition.
     * @param {Vec2} rhs - The second vector operand for the addition.
     * @returns {Vec2} Self for chaining.
     * @example
     * var a = new pc.Vec2(10, 10);
     * var b = new pc.Vec2(20, 20);
     * var r = new pc.Vec2();
     *
     * r.sub2(a, b);
     *
     * // Outputs [-10, -10]
     * console.log("The result of the subtraction is: " + r.toString());
     */
    sub2(lhs: Vec2, rhs: Vec2): Vec2;
    /**
     * Subtracts a number from each element of a vector.
     *
     * @param {number} scalar - The number to subtract.
     * @returns {Vec2} Self for chaining.
     * @example
     * var vec = new pc.Vec2(3, 4);
     *
     * vec.subScalar(2);
     *
     * // Outputs [1, 2]
     * console.log("The result of the subtraction is: " + vec.toString());
     */
    subScalar(scalar: number): Vec2;
    /**
     * Converts the vector to string form.
     *
     * @returns {string} The vector in string form.
     * @example
     * var v = new pc.Vec2(20, 10);
     * // Outputs [20, 10]
     * console.log(v.toString());
     */
    toString(): string;
}

/**
 * Callback used by {@link GraphNodefind } and {@link GraphNodefindOne } to search through a graph
 * node and all of its descendants.
 */
export type FindNodeCallback = (node: GraphNode) => boolean;
/**
 * Callback used by {@link GraphNodeforEach } to iterate through a graph node and all of its
 * descendants.
 */
export type ForEachNodeCallback = (node: GraphNode) => any;
/**
 * Callback used by {@link GraphNode#find} and {@link GraphNode#findOne} to search through a graph
 * node and all of its descendants.
 *
 * @callback FindNodeCallback
 * @param {GraphNode} node - The current graph node.
 * @returns {boolean} Returning `true` will result in that node being returned from
 * {@link GraphNode#find} or {@link GraphNode#findOne}.
 */
/**
 * Callback used by {@link GraphNode#forEach} to iterate through a graph node and all of its
 * descendants.
 *
 * @callback ForEachNodeCallback
 * @param {GraphNode} node - The current graph node.
 */
/**
 * A hierarchical scene node.
 *
 * @augments EventHandler
 */
declare class GraphNode extends EventHandler {
    /**
     * Create a new GraphNode instance.
     *
     * @param {string} [name] - The non-unique name of a graph node. Defaults to 'Untitled'.
     */
    constructor(name?: string);
    /**
     * The non-unique name of a graph node. Defaults to 'Untitled'.
     *
     * @type {string}
     */
    name: string;
    /**
     * Interface for tagging graph nodes. Tag based searches can be performed using the
     * {@link GraphNode#findByTag} function.
     *
     * @type {Tags}
     */
    tags: Tags;
    /** @private */
    private _labels;
    /**
     * @type {Vec3}
     * @private
     */
    private localPosition;
    /**
     * @type {Quat}
     * @private
     */
    private localRotation;
    /**
     * @type {Vec3}
     * @private
     */
    private localScale;
    /**
     * @type {Vec3}
     * @private
     */
    private localEulerAngles;
    /**
     * @type {Vec3}
     * @private
     */
    private position;
    /**
     * @type {Quat}
     * @private
     */
    private rotation;
    /**
     * @type {Vec3}
     * @private
     */
    private eulerAngles;
    /**
     * @type {Vec3|null}
     * @private
     */
    private _scale;
    /**
     * @type {Mat4}
     * @private
     */
    private localTransform;
    /**
     * @type {boolean}
     * @private
     */
    private _dirtyLocal;
    /**
     * @type {number}
     * @private
     */
    private _aabbVer;
    /**
     * Marks the node to ignore hierarchy sync entirely (including children nodes). The engine
     * code automatically freezes and unfreezes objects whenever required. Segregating dynamic
     * and stationary nodes into subhierarchies allows to reduce sync time significantly.
     *
     * @type {boolean}
     * @private
     */
    private _frozen;
    /**
     * @type {Mat4}
     * @private
     */
    private worldTransform;
    /**
     * @type {boolean}
     * @private
     */
    private _dirtyWorld;
    /**
     * @type {Mat3}
     * @private
     */
    private normalMatrix;
    /**
     * @type {boolean}
     * @private
     */
    private _dirtyNormal;
    /**
     * @type {Vec3|null}
     * @private
     */
    private _right;
    /**
     * @type {Vec3|null}
     * @private
     */
    private _up;
    /**
     * @type {Vec3|null}
     * @private
     */
    private _forward;
    /**
     * @type {GraphNode|null}
     * @private
     */
    private _parent;
    /**
     * @type {GraphNode[]}
     * @private
     */
    private _children;
    /**
     * @type {number}
     * @private
     */
    private _graphDepth;
    /**
     * Represents enabled state of the entity. If the entity is disabled, the entity including
     * all children are excluded from updates.
     *
     * @type {boolean}
     * @private
     */
    private _enabled;
    /**
     * Represents enabled state of the entity in the hierarchy. It's true only if this entity
     * and all parent entities all the way to the scene's root are enabled.
     *
     * @type {boolean}
     * @private
     */
    private _enabledInHierarchy;
    /**
     * @type {boolean}
     * @ignore
     */
    scaleCompensation: boolean;
    /**
     * The normalized local space X-axis vector of the graph node in world space.
     *
     * @type {Vec3}
     */
    get right(): Vec3;
    /**
     * The normalized local space Y-axis vector of the graph node in world space.
     *
     * @type {Vec3}
     */
    get up(): Vec3;
    /**
     * The normalized local space negative Z-axis vector of the graph node in world space.
     *
     * @type {Vec3}
     */
    get forward(): Vec3;
    /**
     * Enable or disable a GraphNode. If one of the GraphNode's parents is disabled there will be
     * no other side effects. If all the parents are enabled then the new value will activate or
     * deactivate all the enabled children of the GraphNode.
     *
     * @type {boolean}
     */
    set enabled(arg: boolean);
    get enabled(): boolean;
    /**
     * A read-only property to get a parent graph node.
     *
     * @type {GraphNode|null}
     */
    get parent(): GraphNode;
    /**
     * A read-only property to get the path of the graph node relative to the root of the hierarchy.
     *
     * @type {string}
     */
    get path(): string;
    /**
     * A read-only property to get highest graph node from current node.
     *
     * @type {GraphNode}
     */
    get root(): GraphNode;
    /**
     * A read-only property to get the children of this graph node.
     *
     * @type {GraphNode[]}
     */
    get children(): GraphNode[];
    /**
     * A read-only property to get the depth of this child within the graph. Note that for
     * performance reasons this is only recalculated when a node is added to a new parent, i.e. It
     * is not recalculated when a node is simply removed from the graph.
     *
     * @type {number}
     */
    get graphDepth(): number;
    /**
     * @param {GraphNode} node - Graph node to update.
     * @param {boolean} enabled - True if enabled in the hierarchy, false if disabled.
     * @private
     */
    private _notifyHierarchyStateChanged;
    /**
     * Called when the enabled flag of the entity or one of its parents changes.
     *
     * @param {boolean} enabled - True if enabled in the hierarchy, false if disabled.
     * @private
     */
    private _onHierarchyStateChanged;
    /**
     * @param {this} clone - The cloned graph node to copy into.
     * @private
     */
    private _cloneInternal;
    /**
     * Clone a graph node.
     *
     * @returns {this} A clone of the specified graph node.
     */
    clone(): this;
    /**
     * Copy a graph node.
     *
     * @param {GraphNode} source - The graph node to copy.
     * @returns {GraphNode} The destination graph node.
     * @ignore
     */
    copy(source: GraphNode): GraphNode;
    /**
     * Search the graph node and all of its descendants for the nodes that satisfy some search
     * criteria.
     *
     * @param {FindNodeCallback|string} attr - This can either be a function or a string. If it's a
     * function, it is executed for each descendant node to test if node satisfies the search
     * logic. Returning true from the function will include the node into the results. If it's a
     * string then it represents the name of a field or a method of the node. If this is the name
     * of a field then the value passed as the second argument will be checked for equality. If
     * this is the name of a function then the return value of the function will be checked for
     * equality against the valued passed as the second argument to this function.
     * @param {object} [value] - If the first argument (attr) is a property name then this value
     * will be checked against the value of the property.
     * @returns {GraphNode[]} The array of graph nodes that match the search criteria.
     * @example
     * // Finds all nodes that have a model component and have `door` in their lower-cased name
     * var doors = house.find(function (node) {
     *     return node.model && node.name.toLowerCase().indexOf('door') !== -1;
     * });
     * @example
     * // Finds all nodes that have the name property set to 'Test'
     * var entities = parent.find('name', 'Test');
     */
    find(attr: FindNodeCallback | string, value?: object): GraphNode[];
    /**
     * Search the graph node and all of its descendants for the first node that satisfies some
     * search criteria.
     *
     * @param {FindNodeCallback|string} attr - This can either be a function or a string. If it's a
     * function, it is executed for each descendant node to test if node satisfies the search
     * logic. Returning true from the function will result in that node being returned from
     * findOne. If it's a string then it represents the name of a field or a method of the node. If
     * this is the name of a field then the value passed as the second argument will be checked for
     * equality. If this is the name of a function then the return value of the function will be
     * checked for equality against the valued passed as the second argument to this function.
     * @param {object} [value] - If the first argument (attr) is a property name then this value
     * will be checked against the value of the property.
     * @returns {GraphNode|null} A graph node that match the search criteria. Returns null if no
     * node is found.
     * @example
     * // Find the first node that is called `head` and has a model component
     * var head = player.findOne(function (node) {
     *     return node.model && node.name === 'head';
     * });
     * @example
     * // Finds the first node that has the name property set to 'Test'
     * var node = parent.findOne('name', 'Test');
     */
    findOne(attr: FindNodeCallback | string, value?: object): GraphNode | null;
    /**
     * Return all graph nodes that satisfy the search query. Query can be simply a string, or comma
     * separated strings, to have inclusive results of assets that match at least one query. A
     * query that consists of an array of tags can be used to match graph nodes that have each tag
     * of array.
     *
     * @param {...*} query - Name of a tag or array of tags.
     * @returns {GraphNode[]} A list of all graph nodes that match the query.
     * @example
     * // Return all graph nodes that tagged by `animal`
     * var animals = node.findByTag("animal");
     * @example
     * // Return all graph nodes that tagged by `bird` OR `mammal`
     * var birdsAndMammals = node.findByTag("bird", "mammal");
     * @example
     * // Return all assets that tagged by `carnivore` AND `mammal`
     * var meatEatingMammals = node.findByTag(["carnivore", "mammal"]);
     * @example
     * // Return all assets that tagged by (`carnivore` AND `mammal`) OR (`carnivore` AND `reptile`)
     * var meatEatingMammalsAndReptiles = node.findByTag(["carnivore", "mammal"], ["carnivore", "reptile"]);
     */
    findByTag(...args: any[]): GraphNode[];
    /**
     * Get the first node found in the graph with the name. The search is depth first.
     *
     * @param {string} name - The name of the graph.
     * @returns {GraphNode|null} The first node to be found matching the supplied name. Returns
     * null if no node is found.
     */
    findByName(name: string): GraphNode | null;
    /**
     * Get the first node found in the graph by its full path in the graph. The full path has this
     * form 'parent/child/sub-child'. The search is depth first.
     *
     * @param {string|string[]} path - The full path of the {@link GraphNode} as either a string or
     * array of {@link GraphNode} names.
     * @returns {GraphNode|null} The first node to be found matching the supplied path. Returns
     * null if no node is found.
     * @example
     * // String form
     * var grandchild = this.entity.findByPath('child/grandchild');
     * @example
     * // Array form
     * var grandchild = this.entity.findByPath(['child', 'grandchild']);
     */
    findByPath(path: string | string[]): GraphNode | null;
    /**
     * Executes a provided function once on this graph node and all of its descendants.
     *
     * @param {ForEachNodeCallback} callback - The function to execute on the graph node and each
     * descendant.
     * @param {object} [thisArg] - Optional value to use as this when executing callback function.
     * @example
     * // Log the path and name of each node in descendant tree starting with "parent"
     * parent.forEach(function (node) {
     *     console.log(node.path + "/" + node.name);
     * });
     */
    forEach(callback: ForEachNodeCallback, thisArg?: object): void;
    /**
     * Check if node is descendant of another node.
     *
     * @param {GraphNode} node - Potential ancestor of node.
     * @returns {boolean} If node is descendant of another node.
     * @example
     * if (roof.isDescendantOf(house)) {
     *     // roof is descendant of house entity
     * }
     */
    isDescendantOf(node: GraphNode): boolean;
    /**
     * Check if node is ancestor for another node.
     *
     * @param {GraphNode} node - Potential descendant of node.
     * @returns {boolean} If node is ancestor for another node.
     * @example
     * if (body.isAncestorOf(foot)) {
     *     // foot is within body's hierarchy
     * }
     */
    isAncestorOf(node: GraphNode): boolean;
    /**
     * Get the world space rotation for the specified GraphNode in Euler angle form. The rotation
     * is returned as euler angles in a {@link Vec3}. The value returned by this function should be
     * considered read-only. In order to set the world-space rotation of the graph node, use
     * {@link GraphNode#setEulerAngles}.
     *
     * @returns {Vec3} The world space rotation of the graph node in Euler angle form.
     * @example
     * var angles = this.entity.getEulerAngles();
     * angles.y = 180; // rotate the entity around Y by 180 degrees
     * this.entity.setEulerAngles(angles);
     */
    getEulerAngles(): Vec3;
    /**
     * Get the rotation in local space for the specified GraphNode. The rotation is returned as
     * euler angles in a {@link Vec3}. The returned vector should be considered read-only. To
     * update the local rotation, use {@link GraphNode#setLocalEulerAngles}.
     *
     * @returns {Vec3} The local space rotation of the graph node as euler angles in XYZ order.
     * @example
     * var angles = this.entity.getLocalEulerAngles();
     * angles.y = 180;
     * this.entity.setLocalEulerAngles(angles);
     */
    getLocalEulerAngles(): Vec3;
    /**
     * Get the position in local space for the specified GraphNode. The position is returned as a
     * {@link Vec3}. The returned vector should be considered read-only. To update the local
     * position, use {@link GraphNode#setLocalPosition}.
     *
     * @returns {Vec3} The local space position of the graph node.
     * @example
     * var position = this.entity.getLocalPosition();
     * position.x += 1; // move the entity 1 unit along x.
     * this.entity.setLocalPosition(position);
     */
    getLocalPosition(): Vec3;
    /**
     * Get the rotation in local space for the specified GraphNode. The rotation is returned as a
     * {@link Quat}. The returned quaternion should be considered read-only. To update the local
     * rotation, use {@link GraphNode#setLocalRotation}.
     *
     * @returns {Quat} The local space rotation of the graph node as a quaternion.
     * @example
     * var rotation = this.entity.getLocalRotation();
     */
    getLocalRotation(): Quat;
    /**
     * Get the scale in local space for the specified GraphNode. The scale is returned as a
     * {@link Vec3}. The returned vector should be considered read-only. To update the local scale,
     * use {@link GraphNode#setLocalScale}.
     *
     * @returns {Vec3} The local space scale of the graph node.
     * @example
     * var scale = this.entity.getLocalScale();
     * scale.x = 100;
     * this.entity.setLocalScale(scale);
     */
    getLocalScale(): Vec3;
    /**
     * Get the local transform matrix for this graph node. This matrix is the transform relative to
     * the node's parent's world transformation matrix.
     *
     * @returns {Mat4} The node's local transformation matrix.
     * @example
     * var transform = this.entity.getLocalTransform();
     */
    getLocalTransform(): Mat4;
    /**
     * Get the world space position for the specified GraphNode. The position is returned as a
     * {@link Vec3}. The value returned by this function should be considered read-only. In order
     * to set the world-space position of the graph node, use {@link GraphNode#setPosition}.
     *
     * @returns {Vec3} The world space position of the graph node.
     * @example
     * var position = this.entity.getPosition();
     * position.x = 10;
     * this.entity.setPosition(position);
     */
    getPosition(): Vec3;
    /**
     * Get the world space rotation for the specified GraphNode. The rotation is returned as a
     * {@link Quat}. The value returned by this function should be considered read-only. In order
     * to set the world-space rotation of the graph node, use {@link GraphNode#setRotation}.
     *
     * @returns {Quat} The world space rotation of the graph node as a quaternion.
     * @example
     * var rotation = this.entity.getRotation();
     */
    getRotation(): Quat;
    /**
     * Get the world space scale for the specified GraphNode. The returned value will only be
     * correct for graph nodes that have a non-skewed world transform (a skew can be introduced by
     * the compounding of rotations and scales higher in the graph node hierarchy). The scale is
     * returned as a {@link Vec3}. The value returned by this function should be considered
     * read-only. Note that it is not possible to set the world space scale of a graph node
     * directly.
     *
     * @returns {Vec3} The world space scale of the graph node.
     * @example
     * var scale = this.entity.getScale();
     * @ignore
     */
    getScale(): Vec3;
    /**
     * Get the world transformation matrix for this graph node.
     *
     * @returns {Mat4} The node's world transformation matrix.
     * @example
     * var transform = this.entity.getWorldTransform();
     */
    getWorldTransform(): Mat4;
    /**
     * Remove graph node from current parent and add as child to new parent.
     *
     * @param {GraphNode} parent - New parent to attach graph node to.
     * @param {number} [index] - The child index where the child node should be placed.
     */
    reparent(parent: GraphNode, index?: number): void;
    /**
     * Sets the local-space rotation of the specified graph node using euler angles. Eulers are
     * interpreted in XYZ order. Eulers must be specified in degrees. This function has two valid
     * signatures: you can either pass a 3D vector or 3 numbers to specify the local-space euler
     * rotation.
     *
     * @param {Vec3|number} x - 3-dimensional vector holding eulers or rotation around local-space
     * x-axis in degrees.
     * @param {number} [y] - Rotation around local-space y-axis in degrees.
     * @param {number} [z] - Rotation around local-space z-axis in degrees.
     * @example
     * // Set rotation of 90 degrees around y-axis via 3 numbers
     * this.entity.setLocalEulerAngles(0, 90, 0);
     * @example
     * // Set rotation of 90 degrees around y-axis via a vector
     * var angles = new pc.Vec3(0, 90, 0);
     * this.entity.setLocalEulerAngles(angles);
     */
    setLocalEulerAngles(x: Vec3 | number, y?: number, z?: number): void;
    /**
     * Sets the local-space position of the specified graph node. This function has two valid
     * signatures: you can either pass a 3D vector or 3 numbers to specify the local-space
     * position.
     *
     * @param {Vec3|number} x - 3-dimensional vector holding local-space position or
     * x-coordinate of local-space position.
     * @param {number} [y] - Y-coordinate of local-space position.
     * @param {number} [z] - Z-coordinate of local-space position.
     * @example
     * // Set via 3 numbers
     * this.entity.setLocalPosition(0, 10, 0);
     * @example
     * // Set via vector
     * var pos = new pc.Vec3(0, 10, 0);
     * this.entity.setLocalPosition(pos);
     */
    setLocalPosition(x: Vec3 | number, y?: number, z?: number): void;
    /**
     * Sets the local-space rotation of the specified graph node. This function has two valid
     * signatures: you can either pass a quaternion or 3 numbers to specify the local-space
     * rotation.
     *
     * @param {Quat|number} x - Quaternion holding local-space rotation or x-component of
     * local-space quaternion rotation.
     * @param {number} [y] - Y-component of local-space quaternion rotation.
     * @param {number} [z] - Z-component of local-space quaternion rotation.
     * @param {number} [w] - W-component of local-space quaternion rotation.
     * @example
     * // Set via 4 numbers
     * this.entity.setLocalRotation(0, 0, 0, 1);
     * @example
     * // Set via quaternion
     * var q = pc.Quat();
     * this.entity.setLocalRotation(q);
     */
    setLocalRotation(x: Quat | number, y?: number, z?: number, w?: number): void;
    /**
     * Sets the local-space scale factor of the specified graph node. This function has two valid
     * signatures: you can either pass a 3D vector or 3 numbers to specify the local-space scale.
     *
     * @param {Vec3|number} x - 3-dimensional vector holding local-space scale or x-coordinate
     * of local-space scale.
     * @param {number} [y] - Y-coordinate of local-space scale.
     * @param {number} [z] - Z-coordinate of local-space scale.
     * @example
     * // Set via 3 numbers
     * this.entity.setLocalScale(10, 10, 10);
     * @example
     * // Set via vector
     * var scale = new pc.Vec3(10, 10, 10);
     * this.entity.setLocalScale(scale);
     */
    setLocalScale(x: Vec3 | number, y?: number, z?: number): void;
    /** @private */
    private _dirtifyLocal;
    /** @private */
    private _unfreezeParentToRoot;
    /** @private */
    private _dirtifyWorld;
    /** @private */
    private _dirtifyWorldInternal;
    /**
     * Sets the world-space position of the specified graph node. This function has two valid
     * signatures: you can either pass a 3D vector or 3 numbers to specify the world-space
     * position.
     *
     * @param {Vec3|number} x - 3-dimensional vector holding world-space position or
     * x-coordinate of world-space position.
     * @param {number} [y] - Y-coordinate of world-space position.
     * @param {number} [z] - Z-coordinate of world-space position.
     * @example
     * // Set via 3 numbers
     * this.entity.setPosition(0, 10, 0);
     * @example
     * // Set via vector
     * var position = new pc.Vec3(0, 10, 0);
     * this.entity.setPosition(position);
     */
    setPosition(x: Vec3 | number, y?: number, z?: number): void;
    /**
     * Sets the world-space rotation of the specified graph node. This function has two valid
     * signatures: you can either pass a quaternion or 3 numbers to specify the world-space
     * rotation.
     *
     * @param {Quat|number} x - Quaternion holding world-space rotation or x-component of
     * world-space quaternion rotation.
     * @param {number} [y] - Y-component of world-space quaternion rotation.
     * @param {number} [z] - Z-component of world-space quaternion rotation.
     * @param {number} [w] - W-component of world-space quaternion rotation.
     * @example
     * // Set via 4 numbers
     * this.entity.setRotation(0, 0, 0, 1);
     * @example
     * // Set via quaternion
     * var q = pc.Quat();
     * this.entity.setRotation(q);
     */
    setRotation(x: Quat | number, y?: number, z?: number, w?: number): void;
    /**
     * Sets the world-space rotation of the specified graph node using euler angles. Eulers are
     * interpreted in XYZ order. Eulers must be specified in degrees. This function has two valid
     * signatures: you can either pass a 3D vector or 3 numbers to specify the world-space euler
     * rotation.
     *
     * @param {Vec3|number} x - 3-dimensional vector holding eulers or rotation around world-space
     * x-axis in degrees.
     * @param {number} [y] - Rotation around world-space y-axis in degrees.
     * @param {number} [z] - Rotation around world-space z-axis in degrees.
     * @example
     * // Set rotation of 90 degrees around world-space y-axis via 3 numbers
     * this.entity.setEulerAngles(0, 90, 0);
     * @example
     * // Set rotation of 90 degrees around world-space y-axis via a vector
     * var angles = new pc.Vec3(0, 90, 0);
     * this.entity.setEulerAngles(angles);
     */
    setEulerAngles(x: Vec3 | number, y?: number, z?: number): void;
    /**
     * Add a new child to the child list and update the parent value of the child node.
     * If the node already had a parent, it is removed from its child list.
     *
     * @param {GraphNode} node - The new child to add.
     * @example
     * var e = new pc.Entity(app);
     * this.entity.addChild(e);
     */
    addChild(node: GraphNode): void;
    /**
     * Add a child to this node, maintaining the child's transform in world space.
     * If the node already had a parent, it is removed from its child list.
     *
     * @param {GraphNode} node - The child to add.
     * @example
     * var e = new pc.Entity(app);
     * this.entity.addChildAndSaveTransform(e);
     * @ignore
     */
    addChildAndSaveTransform(node: GraphNode): void;
    /**
     * Insert a new child to the child list at the specified index and update the parent value of
     * the child node. If the node already had a parent, it is removed from its child list.
     *
     * @param {GraphNode} node - The new child to insert.
     * @param {number} index - The index in the child list of the parent where the new node will be
     * inserted.
     * @example
     * var e = new pc.Entity(app);
     * this.entity.insertChild(e, 1);
     */
    insertChild(node: GraphNode, index: number): void;
    /**
     * Prepares node for being inserted to a parent node, and removes it from the previous parent.
     *
     * @param {GraphNode} node - The node being inserted.
     * @private
     */
    private _prepareInsertChild;
    /**
     * Fires an event on all children of the node. The event `name` is fired on the first (root)
     * node only. The event `nameHierarchy` is fired for all children.
     *
     * @param {string} name - The name of the event to fire on the root.
     * @param {string} nameHierarchy - The name of the event to fire for all descendants.
     * @param {GraphNode} parent - The parent of the node being added/removed from the hierarchy.
     * @private
     */
    private _fireOnHierarchy;
    /**
     * Called when a node is inserted into a node's child list.
     *
     * @param {GraphNode} node - The node that was inserted.
     * @private
     */
    private _onInsertChild;
    /**
     * Recurse the hierarchy and update the graph depth at each node.
     *
     * @private
     */
    private _updateGraphDepth;
    /**
     * Remove the node from the child list and update the parent value of the child.
     *
     * @param {GraphNode} child - The node to remove.
     * @example
     * var child = this.entity.children[0];
     * this.entity.removeChild(child);
     */
    removeChild(child: GraphNode): void;
    _sync(): void;
    /**
     * Updates the world transformation matrices at this node and all of its descendants.
     *
     * @ignore
     */
    syncHierarchy(): void;
    /**
     * Reorients the graph node so that the negative z-axis points towards the target. This
     * function has two valid signatures. Either pass 3D vectors for the look at coordinate and up
     * vector, or pass numbers to represent the vectors.
     *
     * @param {Vec3|number} x - If passing a 3D vector, this is the world-space coordinate to look at.
     * Otherwise, it is the x-component of the world-space coordinate to look at.
     * @param {Vec3|number} [y] - If passing a 3D vector, this is the world-space up vector for look at
     * transform. Otherwise, it is the y-component of the world-space coordinate to look at.
     * @param {number} [z] - Z-component of the world-space coordinate to look at.
     * @param {number} [ux=0] - X-component of the up vector for the look at transform.
     * @param {number} [uy=1] - Y-component of the up vector for the look at transform.
     * @param {number} [uz=0] - Z-component of the up vector for the look at transform.
     * @example
     * // Look at another entity, using the (default) positive y-axis for up
     * var position = otherEntity.getPosition();
     * this.entity.lookAt(position);
     * @example
     * // Look at another entity, using the negative world y-axis for up
     * var position = otherEntity.getPosition();
     * this.entity.lookAt(position, pc.Vec3.DOWN);
     * @example
     * // Look at the world space origin, using the (default) positive y-axis for up
     * this.entity.lookAt(0, 0, 0);
     * @example
     * // Look at world-space coordinate [10, 10, 10], using the negative world y-axis for up
     * this.entity.lookAt(10, 10, 10, 0, -1, 0);
     */
    lookAt(x: Vec3 | number, y?: Vec3 | number, z?: number, ux?: number, uy?: number, uz?: number): void;
    /**
     * Translates the graph node in world-space by the specified translation vector. This function
     * has two valid signatures: you can either pass a 3D vector or 3 numbers to specify the
     * world-space translation.
     *
     * @param {Vec3|number} x - 3-dimensional vector holding world-space translation or
     * x-coordinate of world-space translation.
     * @param {number} [y] - Y-coordinate of world-space translation.
     * @param {number} [z] - Z-coordinate of world-space translation.
     * @example
     * // Translate via 3 numbers
     * this.entity.translate(10, 0, 0);
     * @example
     * // Translate via vector
     * var t = new pc.Vec3(10, 0, 0);
     * this.entity.translate(t);
     */
    translate(x: Vec3 | number, y?: number, z?: number): void;
    /**
     * Translates the graph node in local-space by the specified translation vector. This function
     * has two valid signatures: you can either pass a 3D vector or 3 numbers to specify the
     * local-space translation.
     *
     * @param {Vec3|number} x - 3-dimensional vector holding local-space translation or
     * x-coordinate of local-space translation.
     * @param {number} [y] - Y-coordinate of local-space translation.
     * @param {number} [z] - Z-coordinate of local-space translation.
     * @example
     * // Translate via 3 numbers
     * this.entity.translateLocal(10, 0, 0);
     * @example
     * // Translate via vector
     * var t = new pc.Vec3(10, 0, 0);
     * this.entity.translateLocal(t);
     */
    translateLocal(x: Vec3 | number, y?: number, z?: number): void;
    /**
     * Rotates the graph node in world-space by the specified Euler angles. Eulers are specified in
     * degrees in XYZ order. This function has two valid signatures: you can either pass a 3D
     * vector or 3 numbers to specify the world-space rotation.
     *
     * @param {Vec3|number} x - 3-dimensional vector holding world-space rotation or
     * rotation around world-space x-axis in degrees.
     * @param {number} [y] - Rotation around world-space y-axis in degrees.
     * @param {number} [z] - Rotation around world-space z-axis in degrees.
     * @example
     * // Rotate via 3 numbers
     * this.entity.rotate(0, 90, 0);
     * @example
     * // Rotate via vector
     * var r = new pc.Vec3(0, 90, 0);
     * this.entity.rotate(r);
     */
    rotate(x: Vec3 | number, y?: number, z?: number): void;
    /**
     * Rotates the graph node in local-space by the specified Euler angles. Eulers are specified in
     * degrees in XYZ order. This function has two valid signatures: you can either pass a 3D
     * vector or 3 numbers to specify the local-space rotation.
     *
     * @param {Vec3|number} x - 3-dimensional vector holding local-space rotation or
     * rotation around local-space x-axis in degrees.
     * @param {number} [y] - Rotation around local-space y-axis in degrees.
     * @param {number} [z] - Rotation around local-space z-axis in degrees.
     * @example
     * // Rotate via 3 numbers
     * this.entity.rotateLocal(0, 90, 0);
     * @example
     * // Rotate via vector
     * var r = new pc.Vec3(0, 90, 0);
     * this.entity.rotateLocal(r);
     */
    rotateLocal(x: Vec3 | number, y?: number, z?: number): void;
}



/** @typedef {import('../graphics/graphics-device.js').GraphicsDevice} GraphicsDevice */
/** @typedef {import('../math/mat4.js').Mat4} Mat4 */
/**
 * A skin contains data about the bones in a hierarchy that drive a skinned mesh animation.
 * Specifically, the skin stores the bone name and inverse bind matrix and for each bone. Inverse
 * bind matrices are instrumental in the mathematics of vertex skinning.
 */
declare class Skin {
    /**
     * Create a new Skin instance.
     *
     * @param {GraphicsDevice} graphicsDevice - The graphics device used to manage this skin.
     * @param {Mat4[]} ibp - The array of inverse bind matrices.
     * @param {string[]} boneNames - The array of bone names for the bones referenced by this skin.
     */
    constructor(graphicsDevice: GraphicsDevice, ibp: Mat4[], boneNames: string[]);
    device: GraphicsDevice;
    inverseBindPose: Mat4[];
    boneNames: string[];
}



/**
 * A skin instance is responsible for generating the matrix palette that is used to skin vertices
 * from object space to world space.
 */
declare class SkinInstance {
    /**
     * Create a new SkinInstance instance.
     *
     * @param {Skin} skin - The skin that will provide the inverse bind pose matrices to generate
     * the final matrix palette.
     */
    constructor(skin: Skin);
    /**
     * An array of nodes representing each bone in this skin instance.
     *
     * @type {GraphNode[]}
     */
    bones: GraphNode[];
    _dirty: boolean;
    _rootBone: any;
    _skinUpdateIndex: number;
    _updateBeforeCull: boolean;
    set rootBone(arg: any);
    get rootBone(): any;
    init(device: any, numBones: any): void;
    boneTexture: Texture;
    matrixPalette: Uint8Array | Uint16Array | Float32Array;
    destroy(): void;
    resolve(rootBone: any, entity: any): void;
    initSkin(skin: any): void;
    skin: any;
    matrices: any[];
    uploadBones(device: any): void;
    _updateMatrices(rootNode: any, skinUpdateIndex: any): void;
    updateMatrices(rootNode: any, skinUpdateIndex: any): void;
    updateMatrixPalette(rootNode: any, skinUpdateIndex: any): void;
}

/**
 * A Morph Target (also known as Blend Shape) contains deformation data to apply to existing mesh.
 * Multiple morph targets can be blended together on a mesh. This is useful for effects that are
 * hard to achieve with conventional animation and skinning.
 */
declare class MorphTarget {
    /**
     * Create a new MorphTarget instance.
     *
     * @param {object} options - Object for passing optional arguments.
     * @param {ArrayBuffer} options.deltaPositions - An array of 3-dimensional vertex position
     * offsets.
     * @param {number} options.deltaPositionsType - A format to store position offsets inside
     * {@link VertexBuffer}. Defaults to {@link TYPE_FLOAT32} if not provided.
     * @param {ArrayBuffer} [options.deltaNormals] - An array of 3-dimensional vertex normal
     * offsets.
     * @param {number} options.deltaNormalsType - A format to store normal offsets inside
     * {@link VertexBuffer}. Defaults to {@link TYPE_FLOAT32} if not provided.
     * @param {string} [options.name] - Name.
     * @param {BoundingBox} [options.aabb] - Bounding box. Will be automatically generated, if
     * undefined.
     * @param {number} [options.defaultWeight] - Default blend weight to use for this morph target.
     */
    constructor(options: {
        deltaPositions: ArrayBuffer;
        deltaPositionsType: number;
        deltaNormals?: ArrayBuffer;
        deltaNormalsType: number;
        name?: string;
        aabb?: BoundingBox;
        defaultWeight?: number;
    }, ...args: any[]);
    options: {
        deltaPositions: ArrayBuffer;
        deltaPositionsType: number;
        deltaNormals?: ArrayBuffer;
        deltaNormalsType: number;
        name?: string;
        aabb?: BoundingBox;
        defaultWeight?: number;
    };
    _name: string;
    _defaultWeight: number;
    aabb: BoundingBox;
    deltaPositions: ArrayBuffer;
    /**
     * The name of the morph target.
     *
     * @type {string}
     */
    get name(): string;
    /**
     * The default weight of the morph target.
     *
     * @type {number}
     */
    get defaultWeight(): number;
    get morphPositions(): boolean;
    get morphNormals(): boolean;
    _postInit(): void;
    _initVertexBuffers(graphicsDevice: any): void;
    _vertexBufferPositions: VertexBuffer;
    _vertexBufferNormals: VertexBuffer;
    _createVertexBuffer(device: any, data: any, dataType?: number): VertexBuffer;
    _setTexture(name: any, texture: any): void;
    destroy(): void;
    texturePositions: any;
    textureNormals: any;
}

/**
 * Base class that implements reference counting for objects.
 *
 * @ignore
 */
declare class RefCountedObject {
    /**
     * @type {number}
     * @private
     */
    private _refCount;
    /**
     * Increments the reference counter.
     */
    incRefCount(): void;
    /**
     * Decrements the reference counter.
     */
    decRefCount(): void;
    /**
     * The current reference count.
     *
     * @type {number}
     */
    get refCount(): number;
}



/**
 * Contains a list of {@link MorphTarget}, a combined delta AABB and some associated data.
 */
declare class Morph extends RefCountedObject {
    static FORMAT_FLOAT: number;
    static FORMAT_HALF_FLOAT: number;
    /**
     * Create a new Morph instance.
     *
     * @param {MorphTarget[]} targets - A list of morph targets.
     * @param {GraphicsDevice} graphicsDevice - The graphics device used to manage this morph
     * target. If it is not provided, a device is obtained from the {@link Application}.
     */
    constructor(targets: MorphTarget[], graphicsDevice: GraphicsDevice);
    device: any;
    _targets: MorphTarget[];
    _renderTextureFormat: number;
    _textureFormat: number;
    _useTextureMorph: boolean;
    get morphPositions(): boolean;
    get morphNormals(): boolean;
    get maxActiveTargets(): number;
    get useTextureMorph(): boolean;
    _init(): void;
    _initTextureBased(): boolean;
    morphTextureWidth: number;
    morphTextureHeight: number;
    vertexBufferIds: VertexBuffer;
    /**
     * Frees video memory allocated by this object.
     */
    destroy(): void;
    /**
     * The array of morph targets.
     *
     * @type {MorphTarget[]}
     */
    get targets(): MorphTarget[];
    _updateMorphFlags(): void;
    _morphPositions: boolean;
    _morphNormals: boolean;
    _calculateAabb(): void;
    aabb: BoundingBox;
    _createTexture(name: any, format: any, pixelData: any): Texture;
}


/**
 * An instance of {@link Morph}. Contains weights to assign to every {@link MorphTarget}, manages
 * selection of active morph targets.
 */
declare class MorphInstance {
    /**
     * Create a new MorphInstance instance.
     *
     * @param {Morph} morph - The {@link Morph} to instance.
     */
    constructor(morph: Morph);
    /**
     * The morph with its targets, which is being instanced.
     *
     * @type {Morph}
     */
    morph: Morph;
    device: any;
    /**
     * The mesh instance this morph instance controls the morphing of.
     *
     * @type {MeshInstance}
     */
    meshInstance: MeshInstance;
    _weights: any[];
    _weightMap: Map<any, any>;
    _activeTargets: any[];
    shaderCache: {};
    maxSubmitCount: any;
    _shaderMorphWeights: Float32Array;
    rtPositions: RenderTarget;
    rtNormals: RenderTarget;
    _textureParams: Float32Array;
    morphFactor: any;
    zeroTextures: boolean;
    _shaderMorphWeightsA: Float32Array;
    _shaderMorphWeightsB: Float32Array;
    _activeVertexBuffers: any[];
    /**
     * Frees video memory allocated by this object.
     */
    destroy(): void;
    shader: any;
    texturePositions: any;
    textureNormals: any;
    /**
     * Clones a MorphInstance. The returned clone uses the same {@link Morph} and weights are set
     * to defaults.
     *
     * @returns {MorphInstance} A clone of the specified MorphInstance.
     */
    clone(): MorphInstance;
    _getWeightIndex(key: any): any;
    /**
     * Gets current weight of the specified morph target.
     *
     * @param {string|number} key - An identifier for the morph target. Either the weight index or the weight name
     * @returns {number} Weight.
     */
    getWeight(key: string | number): number;
    /**
     * Sets weight of the specified morph target.
     *
     * @param {string|number} key - An identifier for the morph target. Either the weight index or the weight name
     * @param {number} weight - Weight.
     */
    setWeight(key: string | number, weight: number): void;
    _dirty: boolean;
    /**
     * Generate fragment shader to blend a number of textures using specified weights.
     *
     * @param {number} numTextures - Number of textures to blend.
     * @returns {string} Fragment shader.
     * @private
     */
    private _getFragmentShader;
    /**
     * Create complete shader for texture based morphing.
     *
     * @param {number} count - Number of textures to blend.
     * @returns {Shader} Shader.
     * @private
     */
    private _getShader;
    _updateTextureRenderTarget(renderTarget: any, srcTextureName: any): void;
    _updateTextureMorph(): void;
    _updateVertexMorph(): void;
    /**
     * Selects active morph targets and prepares morph for rendering. Called automatically by
     * renderer.
     */
    update(): void;
}

/**
 * A light.
 *
 * @ignore
 */
declare class Light {
    constructor(graphicsDevice: any);
    device: any;
    id: number;
    _type: number;
    _color: Color;
    _intensity: number;
    _castShadows: boolean;
    _enabled: boolean;
    mask: number;
    isStatic: boolean;
    key: number;
    bakeDir: boolean;
    bakeNumSamples: number;
    bakeArea: number;
    attenuationStart: number;
    attenuationEnd: number;
    _falloffMode: number;
    _shadowType: number;
    _vsmBlurSize: number;
    vsmBlurMode: number;
    vsmBias: number;
    _cookie: any;
    cookieIntensity: number;
    _cookieFalloff: boolean;
    _cookieChannel: string;
    _cookieTransform: any;
    _cookieTransformUniform: Float32Array;
    _cookieOffset: any;
    _cookieOffsetUniform: Float32Array;
    _cookieTransformSet: boolean;
    _cookieOffsetSet: boolean;
    _innerConeAngle: number;
    _outerConeAngle: number;
    cascades: any;
    _shadowMatrixPalette: Float32Array;
    _shadowCascadeDistances: Float32Array;
    set numCascades(arg: any);
    get numCascades(): any;
    cascadeDistribution: number;
    _shape: number;
    _finalColor: Float32Array;
    _linearFinalColor: Float32Array;
    _position: Vec3;
    _direction: Vec3;
    _innerConeAngleCos: number;
    _outerConeAngleCos: number;
    _shadowMap: any;
    _shadowRenderParams: any[];
    shadowDistance: number;
    _shadowResolution: number;
    shadowBias: number;
    shadowIntensity: number;
    _normalOffsetBias: number;
    shadowUpdateMode: number;
    _isVsm: boolean;
    _isPcf: boolean;
    _cookieMatrix: Mat4;
    _atlasViewport: Vec4;
    atlasViewportAllocated: boolean;
    atlasVersion: number;
    atlasSlotIndex: number;
    atlasSlotUpdated: boolean;
    _scene: any;
    _node: any;
    _renderData: any[];
    visibleThisFrame: boolean;
    maxScreenSize: number;
    destroy(): void;
    set shadowMap(arg: any);
    get shadowMap(): any;
    get numShadowFaces(): any;
    set type(arg: number);
    get type(): number;
    set shadowType(arg: number);
    get shadowType(): number;
    set shape(arg: number);
    get shape(): number;
    set enabled(arg: boolean);
    get enabled(): boolean;
    set castShadows(arg: boolean);
    get castShadows(): boolean;
    set shadowResolution(arg: number);
    get shadowResolution(): number;
    set vsmBlurSize(arg: number);
    get vsmBlurSize(): number;
    set normalOffsetBias(arg: number);
    get normalOffsetBias(): number;
    set falloffMode(arg: number);
    get falloffMode(): number;
    set innerConeAngle(arg: number);
    get innerConeAngle(): number;
    set outerConeAngle(arg: number);
    get outerConeAngle(): number;
    set intensity(arg: number);
    get intensity(): number;
    get cookieMatrix(): Mat4;
    get atlasViewport(): Vec4;
    set cookie(arg: any);
    get cookie(): any;
    set cookieFalloff(arg: boolean);
    get cookieFalloff(): boolean;
    set cookieChannel(arg: string);
    get cookieChannel(): string;
    set cookieTransform(arg: any);
    get cookieTransform(): any;
    set cookieOffset(arg: any);
    get cookieOffset(): any;
    beginFrame(): void;
    _destroyShadowMap(): void;
    getRenderData(camera: any, face: any): any;
    /**
     * Duplicates a light node but does not 'deep copy' the hierarchy.
     *
     * @returns {Light} A cloned Light.
     */
    clone(): Light;
    _getUniformBiasValues(lightRenderData: any): {
        bias: number;
        normalBias: number;
    };
    getColor(): Color;
    getBoundingSphere(sphere: any): void;
    getBoundingBox(box: any): void;
    _updateFinalColor(): void;
    setColor(...args: any[]): void;
    updateShadow(): void;
    layersDirty(): void;
    updateKey(): void;
}

declare class LightComponentData {
}

/**
 * A Light Component is used to dynamically light the scene.
 *
 * @augments ComponentSystem
 */
declare class LightComponentSystem extends ComponentSystem {
    id: string;
    ComponentType: typeof LightComponent;
    DataType: typeof LightComponentData;
    initializeComponentData(component: any, _data: any): void;
    _onRemoveComponent(entity: any, component: any): void;
    cloneComponent(entity: any, clone: any): Component;
    changeType(component: any, oldValue: any, newValue: any): void;
}




/**
 * The Light Component enables the Entity to light the scene. There are three types of light:
 * directional, omni and spot. Directional lights are global in that they are considered to be
 * infinitely far away and light the entire scene. Omni and spot lights are local in that they have
 * a position and a range. A spot light is a specialization of an omni light where light is emitted
 * in a cone rather than in all directions. Lights also have the ability to cast shadows to add
 * realism to your scenes.
 *
 * ```javascript
 * // Add a pc.LightComponent to an entity
 * var entity = new pc.Entity();
 * entity.addComponent('light', {
 *     type: "omni",
 *     color: new pc.Color(1, 0, 0),
 *     range: 10
 * });
 *
 * // Get the pc.LightComponent on an entity
 * var lightComponent = entity.light;
 *
 * // Update a property on a light component
 * entity.light.range = 20;
 * ```
 *
 * @property {string} type The type of light. Can be:
 *
 * - "directional": A light that is infinitely far away and lights the entire scene from one
 * direction.
 * - "omni": An omni-directional light that illuminates in all directions from the light source.
 * - "spot": An omni-directional light but is bounded by a cone.
 *
 * Defaults to "directional".
 * @property {Color} color The Color of the light. The alpha component of the color is ignored.
 * Defaults to white (1, 1, 1).
 * @property {number} intensity The brightness of the light. Defaults to 1.
 * @property {number} shape The light source shape. Can be:
 *
 * - {@link pc.LIGHTSHAPE_PUNCTUAL}: Infinitesimally small point.
 * - {@link pc.LIGHTSHAPE_RECT}: Rectangle shape.
 * - {@link pc.LIGHTSHAPE_DISK}: Disk shape.
 * - {@link pc.LIGHTSHAPE_SPHERE}: Sphere shape.
 *
 * Defaults to pc.LIGHTSHAPE_PUNCTUAL.
 * @property {boolean} castShadows If enabled the light will cast shadows. Defaults to false.
 * @property {number} shadowDistance The distance from the viewpoint beyond which shadows are no
 * longer rendered. Affects directional lights only. Defaults to 40.
 * @property {number} shadowIntensity The intensity of the shadow darkening, 1 being shadows are entirely black.
 * Defaults to 1.
 * @property {number} shadowResolution The size of the texture used for the shadow map. Valid sizes
 * are 64, 128, 256, 512, 1024, 2048. Defaults to 1024.
 * @property {number} shadowBias The depth bias for tuning the appearance of the shadow mapping
 * generated by this light. Valid range is 0 to 1. Defaults to 0.05.
 * @property {number} numCascades Number of shadow cascades. Can be 1, 2, 3 or 4. Defaults to 1,
 * representing no cascades.
 * @property {number} cascadeDistribution The distribution of subdivision of the camera frustum for
 * individual shadow cascades. Only used if {@link LightComponent#numCascades} is larger than 1.
 * Can be a value in range of 0 and 1. Value of 0 represents a linear distribution, value of 1
 * represents a logarithmic distribution. Defaults to 0.5. Larger value increases the resolution of
 * the shadows in the near distance.
 * @property {number} normalOffsetBias Normal offset depth bias. Valid range is 0 to 1. Defaults to
 * 0.
 * @property {number} range The range of the light. Affects omni and spot lights only. Defaults to
 * 10.
 * @property {number} innerConeAngle The angle at which the spotlight cone starts to fade off. The
 * angle is specified in degrees. Affects spot lights only. Defaults to 40.
 * @property {number} outerConeAngle The angle at which the spotlight cone has faded to nothing.
 * The angle is specified in degrees. Affects spot lights only. Defaults to 45.
 * @property {number} falloffMode Controls the rate at which a light attenuates from its position.
 * Can be:
 *
 * - {@link LIGHTFALLOFF_LINEAR}: Linear.
 * - {@link LIGHTFALLOFF_INVERSESQUARED}: Inverse squared.
 *
 * Affects omni and spot lights only. Defaults to {@link LIGHTFALLOFF_LINEAR}.
 * @property {number} mask Defines a mask to determine which {@link MeshInstance}s are lit by this
 * light. Defaults to 1.
 * @property {boolean} affectDynamic If enabled the light will affect non-lightmapped objects.
 * @property {boolean} affectLightmapped If enabled the light will affect lightmapped objects.
 * @property {boolean} bake If enabled the light will be rendered into lightmaps.
 * @property {number} bakeNumSamples If bake is true, this specifies the number of samples used to
 * bake this light into the lightmap. Defaults to 1. Maximum value is 255.
 * @property {number} bakeArea If bake is true and the light type is {@link LIGHTTYPE_DIRECTIONAL},
 * this specifies the penumbra angle in degrees, allowing a soft shadow boundary. Defaults to 0.
 * @property {boolean} bakeDir If enabled and bake=true, the light's direction will contribute to
 * directional lightmaps. Be aware, that directional lightmap is an approximation and can only hold
 * single direction per pixel. Intersecting multiple lights with bakeDir=true may lead to incorrect
 * look of specular/bump-mapping in the area of intersection. The error is not always visible
 * though, and highly scene-dependent.
 * @property {number} shadowUpdateMode Tells the renderer how often shadows must be updated for
 * this light. Can be:
 *
 * - {@link SHADOWUPDATE_NONE}: Don't render shadows.
 * - {@link SHADOWUPDATE_THISFRAME}: Render shadows only once (then automatically switches to
 * {@link SHADOWUPDATE_NONE}.
 * - {@link SHADOWUPDATE_REALTIME}: Render shadows every frame (default).
 * @property {number} shadowType Type of shadows being rendered by this light. Options:
 *
 * - {@link SHADOW_PCF3}: Render depth (color-packed on WebGL 1.0), can be used for PCF 3x3
 * sampling.
 * - {@link SHADOW_VSM8}: Render packed variance shadow map. All shadow receivers must also cast
 * shadows for this mode to work correctly.
 * - {@link SHADOW_VSM16}: Render 16-bit exponential variance shadow map. Requires
 * OES_texture_half_float extension. Falls back to {@link SHADOW_VSM8}, if not supported.
 * - {@link SHADOW_VSM32}: Render 32-bit exponential variance shadow map. Requires
 * OES_texture_float extension. Falls back to {@link SHADOW_VSM16}, if not supported.
 * - {@link SHADOW_PCF5}: Render depth buffer only, can be used for hardware-accelerated PCF 5x5
 * sampling. Requires WebGL2. Falls back to {@link SHADOW_PCF3} on WebGL 1.0.
 * @property {number} vsmBlurMode Blurring mode for variance shadow maps. Can be:
 *
 * - {@link BLUR_BOX}: Box filter.
 * - {@link BLUR_GAUSSIAN}: Gaussian filter. May look smoother than box, but requires more samples.
 * @property {number} vsmBlurSize Number of samples used for blurring a variance shadow map. Only
 * uneven numbers work, even are incremented. Minimum value is 1, maximum is 25. Defaults to 11.
 * @property {number} cookieAsset Asset that has texture that will be assigned to cookie internally
 * once asset resource is available.
 * @property {Texture} cookie Projection texture. Must be 2D for spot and cubemap for omni light
 * (ignored if incorrect type is used).
 * @property {number} cookieIntensity Projection texture intensity (default is 1).
 * @property {boolean} cookieFalloff Toggle normal spotlight falloff when projection texture is
 * used. When set to false, spotlight will work like a pure texture projector (only fading with
 * distance). Default is false.
 * @property {string} cookieChannel Color channels of the projection texture to use. Can be "r",
 * "g", "b", "a", "rgb".
 * @property {number} cookieAngle Angle for spotlight cookie rotation.
 * @property {Vec2} cookieScale Spotlight cookie scale.
 * @property {Vec2} cookieOffset Spotlight cookie position offset.
 * @property {boolean} isStatic Mark light as non-movable (optimization).
 * @property {number[]} layers An array of layer IDs ({@link Layer#id}) to which this light should
 * belong. Don't push/pop/splice or modify this array, if you want to change it - set a new one
 * instead.
 * @augments Component
 */
declare class LightComponent extends Component {
    /**
     * Creates a new LightComponent instance.
     *
     * @param {LightComponentSystem} system - The ComponentSystem that created this Component.
     * @param {Entity} entity - The Entity that this Component is attached to.
     */
    constructor(system: LightComponentSystem, entity: Entity);

    set affectDynamic(arg: boolean);
    get affectDynamic(): boolean;

    set affectLightmapped(arg: boolean);
    get affectLightmapped(): boolean;

    set bake(arg: boolean);
    get bake(): boolean;

    set bakeArea(arg: number);
    get bakeArea(): number;

    set bakeDir(arg: boolean);
    get bakeDir(): boolean;

    set bakeNumSamples(arg: number);
    get bakeNumSamples(): number;

    set cascadeDistribution(arg: number);
    get cascadeDistribution(): number;

    set castShadows(arg: boolean);
    get castShadows(): boolean;

    set color(arg: Color);
    get color(): Color;

    set cookieAngle(arg: number);
    get cookieAngle(): number;

    set cookieChannel(arg: string);
    get cookieChannel(): string;

    set cookieFalloff(arg: boolean);
    get cookieFalloff(): boolean;

    set cookieIntensity(arg: number);
    get cookieIntensity(): number;

    set cookieOffset(arg: Vec2);
    get cookieOffset(): Vec2;

    set cookieScale(arg: Vec2);
    get cookieScale(): Vec2;

    set falloffMode(arg: number);
    get falloffMode(): number;

    set innerConeAngle(arg: number);
    get innerConeAngle(): number;

    set intensity(arg: number);
    get intensity(): number;

    set isStatic(arg: boolean);
    get isStatic(): boolean;

    set layers(arg: number[]);
    get layers(): number[];

    set mask(arg: number);
    get mask(): number;

    set normalOffsetBias(arg: number);
    get normalOffsetBias(): number;

    set numCascades(arg: number);
    get numCascades(): number;

    set outerConeAngle(arg: number);
    get outerConeAngle(): number;

    set range(arg: number);
    get range(): number;

    set shadowBias(arg: number);
    get shadowBias(): number;

    set shadowDistance(arg: number);
    get shadowDistance(): number;

    set shadowIntensity(arg: number);
    get shadowIntensity(): number;

    set shadowResolution(arg: number);
    get shadowResolution(): number;

    set shadowType(arg: number);
    get shadowType(): number;

    set shadowUpdateMode(arg: number);
    get shadowUpdateMode(): number;

    set shape(arg: number);
    get shape(): number;

    set type(arg: string);
    get type(): string;

    set vsmBlurMode(arg: number);
    get vsmBlurMode(): number;

    set vsmBlurSize(arg: number);
    get vsmBlurSize(): number;

    _cookieAsset: any;
    _cookieAssetId: any;
    _cookieAssetAdd: boolean;
    _cookieMatrix: any;
    addLightToLayers(): void;
    removeLightFromLayers(): void;
    onLayersChanged(oldComp: any, newComp: any): void;
    onLayerAdded(layer: any): void;
    onLayerRemoved(layer: any): void;
    refreshProperties(): void;
    updateShadow(): void;
    onCookieAssetSet(): void;
    onCookieAssetAdd(asset: any): void;
    onCookieAssetLoad(): void;
    cookie: any;
    onCookieAssetRemove(): void;
    onRemove(): void;
    cookieAsset: any;
}






/**
 * A Layer represents a renderable subset of the scene. It can contain a list of mesh instances,
 * lights and cameras, their render settings and also defines custom callbacks before, after or
 * during rendering. Layers are organized inside {@link LayerComposition} in a desired order.
 */
declare class Layer {
    /**
     * Create a new Layer instance.
     *
     * @param {object} options - Object for passing optional arguments. These arguments are the
     * same as properties of the Layer.
     */
    constructor(options?: object);
    /**
     * A unique ID of the layer. Layer IDs are stored inside {@link ModelComponent#layers},
     * {@link RenderComponent#layers}, {@link CameraComponent#layers},
     * {@link LightComponent#layers} and {@link ElementComponent#layers} instead of names.
     * Can be used in {@link LayerComposition#getLayerById}.
     *
     * @type {number}
     */
    id: number;
    /**
     * Name of the layer. Can be used in {@link LayerComposition#getLayerByName}.
     *
     * @type {string}
     */
    name: string;
    /**
     * @type {boolean}
     * @private
     */
    private _enabled;
    /**
     * @type {number}
     * @private
     */
    private _refCounter;
    /**
     * Defines the method used for sorting opaque (that is, not semi-transparent) mesh
     * instances before rendering. Can be:
     *
     * - {@link SORTMODE_NONE}
     * - {@link SORTMODE_MANUAL}
     * - {@link SORTMODE_MATERIALMESH}
     * - {@link SORTMODE_BACK2FRONT}
     * - {@link SORTMODE_FRONT2BACK}
     *
     * Defaults to {@link SORTMODE_MATERIALMESH}.
     *
     * @type {number}
     */
    opaqueSortMode: number;
    /**
     * Defines the method used for sorting semi-transparent mesh instances before rendering. Can be:
     *
     * - {@link SORTMODE_NONE}
     * - {@link SORTMODE_MANUAL}
     * - {@link SORTMODE_MATERIALMESH}
     * - {@link SORTMODE_BACK2FRONT}
     * - {@link SORTMODE_FRONT2BACK}
     *
     * Defaults to {@link SORTMODE_BACK2FRONT}.
     *
     * @type {number}
     */
    transparentSortMode: number;
    /**
     * @type {RenderTarget}
     * @ignore
     */
    set renderTarget(arg: RenderTarget);
    get renderTarget(): RenderTarget;
    /**
     * A type of shader to use during rendering. Possible values are:
     *
     * - {@link SHADER_FORWARD}
     * - {@link SHADER_FORWARDHDR}
     * - {@link SHADER_DEPTH}
     * - Your own custom value. Should be in 19 - 31 range. Use {@link StandardMaterial#onUpdateShader}
     * to apply shader modifications based on this value.
     *
     * Defaults to {@link SHADER_FORWARD}.
     *
     * @type {number}
     */
    shaderPass: number;
    /**
     * Tells that this layer is simple and needs to just render a bunch of mesh instances
     * without lighting, skinning and morphing (faster). Used for UI and Gizmo layers (the
     * layer doesn't use lights, shadows, culling, etc).
     *
     * @type {boolean}
     */
    passThrough: boolean;
    /**
     * @type {boolean}
     * @private
     */
    private _clearColorBuffer;
    /**
     * @type {boolean}
     * @private
     */
    private _clearDepthBuffer;
    /**
     * @type {boolean}
     * @private
     */
    private _clearStencilBuffer;
    /**
     * Custom function that is called before visibility culling is performed for this layer.
     * Useful, for example, if you want to modify camera projection while still using the same
     * camera and make frustum culling work correctly with it (see
     * {@link CameraComponent#calculateTransform} and {@link CameraComponent#calculateProjection}).
     * This function will receive camera index as the only argument. You can get the actual
     * camera being used by looking up {@link LayerComposition#cameras} with this index.
     *
     * @type {Function}
     */
    onPreCull: Function;
    /**
     * Custom function that is called before this layer is rendered. Useful, for example, for
     * reacting on screen size changes. This function is called before the first occurrence of
     * this layer in {@link LayerComposition}. It will receive camera index as the only
     * argument. You can get the actual camera being used by looking up
     * {@link LayerComposition#cameras} with this index.
     *
     * @type {Function}
     */
    onPreRender: Function;
    /**
     * Custom function that is called before opaque mesh instances (not semi-transparent) in
     * this layer are rendered. This function will receive camera index as the only argument.
     * You can get the actual camera being used by looking up {@link LayerComposition#cameras}
     * with this index.
     *
     * @type {Function}
     */
    onPreRenderOpaque: Function;
    /**
     * Custom function that is called before semi-transparent mesh instances in this layer are
     * rendered. This function will receive camera index as the only argument. You can get the
     * actual camera being used by looking up {@link LayerComposition#cameras} with this index.
     *
     * @type {Function}
     */
    onPreRenderTransparent: Function;
    /**
     * Custom function that is called after visibility culling is performed for this layer.
     * Useful for reverting changes done in {@link Layer#onPreCull} and determining final mesh
     * instance visibility (see {@link MeshInstance#visibleThisFrame}). This function will
     * receive camera index as the only argument. You can get the actual camera being used by
     * looking up {@link LayerComposition#cameras} with this index.
     *
     * @type {Function}
     */
    onPostCull: Function;
    /**
     * Custom function that is called after this layer is rendered. Useful to revert changes
     * made in {@link Layer#onPreRender}. This function is called after the last occurrence of this
     * layer in {@link LayerComposition}. It will receive camera index as the only argument.
     * You can get the actual camera being used by looking up {@link LayerComposition#cameras}
     * with this index.
     *
     * @type {Function}
     */
    onPostRender: Function;
    /**
     * Custom function that is called after opaque mesh instances (not semi-transparent) in
     * this layer are rendered. This function will receive camera index as the only argument.
     * You can get the actual camera being used by looking up {@link LayerComposition#cameras}
     * with this index.
     *
     * @type {Function}
     */
    onPostRenderOpaque: Function;
    /**
     * Custom function that is called after semi-transparent mesh instances in this layer are
     * rendered. This function will receive camera index as the only argument. You can get the
     * actual camera being used by looking up {@link LayerComposition#cameras} with this index.
     *
     * @type {Function}
     */
    onPostRenderTransparent: Function;
    /**
     * Custom function that is called before every mesh instance in this layer is rendered. It
     * is not recommended to set this function when rendering many objects every frame due to
     * performance reasons.
     *
     * @type {Function}
     */
    onDrawCall: Function;
    /**
     * Custom function that is called after the layer has been enabled. This happens when:
     *
     * - The layer is created with {@link Layer#enabled} set to true (which is the default value).
     * - {@link Layer#enabled} was changed from false to true
     * - {@link Layer#incrementCounter} was called and incremented the counter above zero.
     *
     * Useful for allocating resources this layer will use (e.g. creating render targets).
     *
     * @type {Function}
     */
    onEnable: Function;
    /**
     * Custom function that is called after the layer has been disabled. This happens when:
     *
     * - {@link Layer#enabled} was changed from true to false
     * - {@link Layer#decrementCounter} was called and set the counter to zero.
     *
     * @type {Function}
     */
    onDisable: Function;
    /**
     * Make this layer render the same mesh instances that another layer does instead of having
     * its own mesh instance list. Both layers must share cameras. Frustum culling is only
     * performed for one layer. Useful for rendering multiple passes using different shaders.
     *
     * @type {Layer}
     */
    layerReference: Layer;
    /**
     * @type {InstanceList}
     * @ignore
     */
    instances: InstanceList;
    /**
     * Visibility bit mask that interacts with {@link MeshInstance#mask}. Especially useful
     * when combined with layerReference, allowing for the filtering of some objects, while
     * sharing their list and culling.
     *
     * @type {number}
     */
    cullingMask: number;
    /**
     * @type {MeshInstance[]}
     * @ignore
     */
    opaqueMeshInstances: MeshInstance[];
    /**
     * @type {MeshInstance[]}
     * @ignore
     */
    transparentMeshInstances: MeshInstance[];
    /**
     * @type {MeshInstance[]}
     * @ignore
     */
    shadowCasters: MeshInstance[];
    /**
     * @type {Function|null}
     * @ignore
     */
    customSortCallback: Function | null;
    /**
     * @type {Function|null}
     * @ignore
     */
    customCalculateSortValues: Function | null;
    /**
     * @type {Light[]}
     * @private
     */
    private _lights;
    /**
     * @type {Set<Light>}
     * @private
     */
    private _lightsSet;
    /**
     * Set of light used by clustered lighting (omni and spot, but no directional).
     *
     * @type {Set<Light>}
     * @private
     */
    private _clusteredLightsSet;
    /**
     * Lights separated by light type.
     *
     * @type {Light[][]}
     * @ignore
     */
    _splitLights: Light[][];
    /**
     * @type {CameraComponent[]}
     * @ignore
     */
    cameras: CameraComponent[];
    _dirty: boolean;
    _dirtyLights: boolean;
    _dirtyCameras: boolean;
    _lightHash: number;
    _staticLightHash: number;
    _needsStaticPrepare: boolean;
    _staticPrepareDone: boolean;
    skipRenderAfter: number;
    _skipRenderCounter: number;
    _renderTime: number;
    _forwardDrawCalls: number;
    _shadowDrawCalls: number;
    _shaderVersion: number;
    /**
     * @type {Float32Array}
     * @ignore
     */
    _lightCube: Float32Array;
    /**
     * True if the layer contains omni or spot lights
     *
     * @type {boolean}
     * @ignore
     */
    get hasClusteredLights(): boolean;
    /**
     * @type {RenderTarget}
     * @private
     */
    private _renderTarget;
    /**
     * Enable the layer. Disabled layers are skipped. Defaults to true.
     *
     * @type {boolean}
     */
    set enabled(arg: boolean);
    get enabled(): boolean;
    /**
     * If true, the camera will clear the color buffer when it renders this layer.
     *
     * @type {boolean}
     */
    set clearColorBuffer(arg: boolean);
    get clearColorBuffer(): boolean;
    /**
     * If true, the camera will clear the depth buffer when it renders this layer.
     *
     * @type {boolean}
     */
    set clearDepthBuffer(arg: boolean);
    get clearDepthBuffer(): boolean;
    /**
     * If true, the camera will clear the stencil buffer when it renders this layer.
     *
     * @type {boolean}
     */
    set clearStencilBuffer(arg: boolean);
    get clearStencilBuffer(): boolean;
    /**
     * Returns lights used by clustered lighting in a set.
     *
     * @type {Set<Light>}
     * @ignore
     */
    get clusteredLightsSet(): Set<Light>;
    /**
     * Increments the usage counter of this layer. By default, layers are created with counter set
     * to 1 (if {@link Layer.enabled} is true) or 0 (if it was false). Incrementing the counter
     * from 0 to 1 will enable the layer and call {@link Layer.onEnable}. Use this function to
     * "subscribe" multiple effects to the same layer. For example, if the layer is used to render
     * a reflection texture which is used by 2 mirrors, then each mirror can call this function
     * when visible and {@link Layer.decrementCounter} if invisible. In such case the reflection
     * texture won't be updated, when there is nothing to use it, saving performance.
     *
     * @ignore
     */
    incrementCounter(): void;
    /**
     * Decrements the usage counter of this layer. Decrementing the counter from 1 to 0 will
     * disable the layer and call {@link Layer.onDisable}. See {@link Layer#incrementCounter} for
     * more details.
     *
     * @ignore
     */
    decrementCounter(): void;
    /**
     * Adds an array of mesh instances to this layer.
     *1
     *
     * @param {MeshInstance[]} meshInstances - Array of {@link MeshInstance}.
     * @param {boolean} [skipShadowCasters] - Set it to true if you don't want these mesh instances
     * to cast shadows in this layer.
     */
    addMeshInstances(meshInstances: MeshInstance[], skipShadowCasters?: boolean): void;
    /**
     * Internal function to remove a mesh instance from an array.
     *
     * @param {MeshInstance} m - Mesh instance to remove.
     * @param {MeshInstance[]} arr - Array of mesh instances to remove from.
     * @private
     */
    private removeMeshInstanceFromArray;
    /**
     * Removes multiple mesh instances from this layer.
     *
     * @param {MeshInstance[]} meshInstances - Array of {@link MeshInstance}. If they were added to
     * this layer, they will be removed.
     * @param {boolean} [skipShadowCasters] - Set it to true if you want to still cast shadows from
     * removed mesh instances or if they never did cast shadows before.
     */
    removeMeshInstances(meshInstances: MeshInstance[], skipShadowCasters?: boolean): void;
    /**
     * Removes all mesh instances from this layer.
     *
     * @param {boolean} [skipShadowCasters] - Set it to true if you want to still cast shadows from
     * removed mesh instances or if they never did cast shadows before.
     */
    clearMeshInstances(skipShadowCasters?: boolean): void;
    /**
     * Adds a light to this layer.
     *
     * @param {LightComponent} light - A {@link LightComponent}.
     */
    addLight(light: LightComponent): void;
    /**
     * Removes a light from this layer.
     *
     * @param {LightComponent} light - A {@link LightComponent}.
     */
    removeLight(light: LightComponent): void;
    /**
     * Removes all lights from this layer.
     */
    clearLights(): void;
    /**
     * Adds an array of mesh instances to this layer, but only as shadow casters (they will not be
     * rendered anywhere, but only cast shadows on other objects).
     *
     * @param {MeshInstance[]} meshInstances - Array of {@link MeshInstance}.
     */
    addShadowCasters(meshInstances: MeshInstance[]): void;
    /**
     * Removes multiple mesh instances from the shadow casters list of this layer, meaning they
     * will stop casting shadows.
     *
     * @param {MeshInstance[]} meshInstances - Array of {@link MeshInstance}. If they were added to
     * this layer, they will be removed.
     */
    removeShadowCasters(meshInstances: MeshInstance[]): void;
    /** @private */
    private _generateLightHash;
    /**
     * Adds a camera to this layer.
     *
     * @param {CameraComponent} camera - A {@link CameraComponent}.
     */
    addCamera(camera: CameraComponent): void;
    /**
     * Removes a camera from this layer.
     *
     * @param {CameraComponent} camera - A {@link CameraComponent}.
     */
    removeCamera(camera: CameraComponent): void;
    /**
     * Removes all cameras from this layer.
     */
    clearCameras(): void;
    /**
     * @param {MeshInstance[]} drawCalls - Array of mesh instances.
     * @param {number} drawCallsCount - Number of mesh instances.
     * @param {Vec3} camPos - Camera position.
     * @param {Vec3} camFwd - Camera forward vector.
     * @private
     */
    private _calculateSortDistances;
    /**
     * @param {boolean} transparent - True if transparent sorting should be used.
     * @param {GraphNode} cameraNode - Graph node that the camera is attached to.
     * @param {number} cameraPass - Camera pass.
     * @ignore
     */
    _sortVisible(transparent: boolean, cameraNode: GraphNode, cameraPass: number): void;
}
declare class InstanceList {
    opaqueMeshInstances: any[];
    transparentMeshInstances: any[];
    shadowCasters: any[];
    visibleOpaque: any[];
    visibleTransparent: any[];
    prepare(index: any): void;
    delete(index: any): void;
}


/** @typedef {import('./graphics-device.js').GraphicsDevice} GraphicsDevice */
/**
 * @ignore
 */
declare class BindBufferFormat {
    constructor(name: any, visibility: any);
    /** @type {string} */
    name: string;
    visibility: any;
}
/**
 * @ignore
 */
declare class BindTextureFormat {
    constructor(name: any, visibility: any);
    /** @type {string} */
    name: string;
    visibility: any;
}
/**
 * @ignore
 */
declare class BindGroupFormat {
    /**
     * @param {GraphicsDevice} graphicsDevice - The graphics device used to manage this vertex format.
     * @param {BindBufferFormat[]} bufferFormats -
     * @param {BindTextureFormat[]} textureFormats -
     */
    constructor(graphicsDevice: GraphicsDevice, bufferFormats: BindBufferFormat[], textureFormats: BindTextureFormat[]);
    /** @type {GraphicsDevice} */
    device: GraphicsDevice;
    /** @type {BindBufferFormat[]} */
    bufferFormats: BindBufferFormat[];
    /** @type {Map<string, number>} */
    bufferFormatsMap: Map<string, number>;
    /** @type {BindTextureFormat[]} */
    textureFormats: BindTextureFormat[];
    /** @type {Map<string, number>} */
    textureFormatsMap: Map<string, number>;
    impl: any;
    /**
     * Frees resources associated with this bind group.
     */
    destroy(): void;
    /**
     * Returns format of texture with specified name.
     *
     * @param {string} name - The name of the texture slot.
     * @returns {BindTextureFormat} - The format.
     */
    getTexture(name: string): BindTextureFormat;
    getShaderDeclarationTextures(bindGroup: any): string;
    loseContext(): void;
}




/**
 * A bind group represents an collection of {@link UniformBuffer} and {@link Texture} instance,
 * which can be bind on a GPU for rendering.
 *
 * @ignore
 */
declare class BindGroup {
    /**
     * Create a new Bind Group.
     *
     * @param {GraphicsDevice} graphicsDevice - The graphics device used to manage this uniform buffer.
     * @param {BindGroupFormat} format - Format of the bind group.
     */
    constructor(graphicsDevice: GraphicsDevice, format: BindGroupFormat);
    device: GraphicsDevice;
    format: BindGroupFormat;
    dirty: boolean;
    impl: any;
    textures: any[];
    uniformBuffers: any[];
    /**
     * Assign a uniform buffer to a slot.
     *
     * @param {*} name - The name of the uniform buffer slot
     * @param {*} uniformBuffer - The Uniform buffer to assign to the slot.
     */
    setUniformBuffer(name: any, uniformBuffer: any): void;
    /**
     * Assign a texture to a slot.
     *
     * @param {string} name - The name of the texture slot.
     * @param {Texture} texture - Texture to assign to the slot.
     */
    setTexture(name: string, texture: Texture): void;
    /**
     * Frees resources associated with this bind group.
     */
    destroy(): void;
    /**
     * Applies any changes made to the bind group's properties.
     */
    update(): void;
}

/**
 * A class storing description of an individual uniform, stored inside a uniform buffer.
 *
 * @ignore
 */
declare class UniformFormat {
    constructor(name: any, type: any);
    /** @type {string} */
    name: string;
    /** @type {number} */
    type: number;
    /** @type {number} */
    byteSize: number;
    /**
     * Index of the uniform in an array of 32bit values (Float32Array and similar)
     *
     * @type {number}
     */
    offset: number;
}
/**
 * A descriptor that defines the layout of of data inside the {@link UniformBuffer}.
 *
 * @ignore
 */
declare class UniformBufferFormat {
    /**
     * Create a new UniformBufferFormat instance.
     *
     * @param {UniformFormat[]} uniforms - An array of uniforms to be stored in the buffer
     */
    constructor(uniforms: UniformFormat[]);
    /** @type {number} */
    byteSize: number;
    /** @type {Map<string,UniformFormat>} */
    map: Map<string, UniformFormat>;
    /** @type {UniformFormat[]} */
    uniforms: UniformFormat[];
    /**
     * Returns format of a uniform with specified name.
     *
     * @param {string} name - The name of the uniform.
     * @returns {UniformFormat} - The format of the uniform.
     */
    get(name: string): UniformFormat;
    getShaderDeclaration(bindGroup: any, bindIndex: any): string;
}



/** @typedef {import('./graphics-device.js').GraphicsDevice} GraphicsDevice */
/** @typedef {import('./uniform-buffer-format.js').UniformBufferFormat} UniformBufferFormat */
/**
 * A uniform buffer represents a GPU memory buffer storing the uniforms.
 *
 * @ignore
 */
declare class UniformBuffer {
    /**
     * Create a new UniformBuffer instance.
     *
     * @param {GraphicsDevice} graphicsDevice - The graphics device used to manage this uniform buffer.
     * @param {UniformBufferFormat} format - Format of the uniform buffer
     */
    constructor(graphicsDevice: GraphicsDevice, format: UniformBufferFormat);
    device: GraphicsDevice;
    format: UniformBufferFormat;
    impl: any;
    storage: ArrayBuffer;
    storageFloat32: Float32Array;
    /**
     * Frees resources associated with this uniform buffer.
     */
    destroy(): void;
    /**
     * Called when the rendering context was lost. It releases all context related resources.
     *
     * @ignore
     */
    loseContext(): void;
    set(name: any, value: any): void;
    update(): void;
}





/** @typedef {import('../../graphics/uniform-buffer.js').UniformBuffer} UniformBuffer */
/** @typedef {import('../../graphics/bind-group.js').BindGroup} BindGroup */
/** @typedef {import('../../graphics/render-target.js').RenderTarget} RenderTarget */
/** @typedef {import('./layer-composition.js').LayerComposition} LayerComposition */
/**
 * Class representing an entry in the final order of rendering of cameras and layers in the engine
 * this is populated at runtime based on LayerComposition
 *
 * @ignore
 */
declare class RenderAction {
    layerIndex: number;
    cameraIndex: number;
    camera: any;
    /**
     * render target this render action renders to (taken from either camera or layer)
     *
     * @type {RenderTarget|null}
     */
    renderTarget: RenderTarget | null;
    lightClusters: any;
    clearColor: boolean;
    clearDepth: boolean;
    clearStencil: boolean;
    triggerPostprocess: boolean;
    firstCameraUse: boolean;
    lastCameraUse: boolean;
    directionalLightsSet: Set<any>;
    directionalLights: any[];
    directionalLightsIndices: any[];
    /** @type {Array<UniformBuffer>} */
    viewUniformBuffers: Array<UniformBuffer>;
    /** @type {Array<BindGroup>} */
    viewBindGroups: Array<BindGroup>;
    destroy(): void;
    get hasDirectionalShadowLights(): boolean;
    reset(): void;
    /**
     * @param {LayerComposition} layerComposition - The layer composition.
     * @returns {boolean} - True if the layer / sublayer referenced by the render action is enabled
     */
    isLayerEnabled(layerComposition: LayerComposition): boolean;
    collectDirectionalLights(cameraLayers: any, dirLights: any, allLights: any): void;
}

declare class LightsBuffer {
    static FORMAT_FLOAT: number;
    static FORMAT_8BIT: number;
    static lightTextureFormat: number;
    static shaderDefines: string;
    static initShaderDefines(): void;
    static buildShaderDefines(object: any, prefix: any): string;
    static init(device: any): void;
    static createTexture(device: any, width: any, height: any, format: any, name: any): Texture;
    constructor(device: any);
    device: any;
    cookiesEnabled: boolean;
    shadowsEnabled: boolean;
    areaLightsEnabled: boolean;
    maxLights: number;
    lights8: Uint8ClampedArray;
    lightsTexture8: Texture;
    _lightsTexture8Id: any;
    lightsFloat: Float32Array;
    lightsTextureFloat: Texture;
    _lightsTextureFloatId: any;
    _lightsTextureInvSizeId: any;
    _lightsTextureInvSizeData: Float32Array;
    invMaxColorValue: number;
    invMaxAttenuation: number;
    boundsMin: Vec3;
    boundsDelta: Vec3;
    destroy(): void;
    setCompressionRanges(maxAttenuation: any, maxColorValue: any): void;
    setBounds(min: any, delta: any): void;
    uploadTextures(): void;
    updateUniforms(): void;
    getSpotDirection(direction: any, spot: any): void;
    getLightAreaSizes(light: any): Float32Array;
    addLightDataFlags(data8: any, index: any, light: any, isSpot: any, castShadows: any, shadowIntensity: any): void;
    addLightDataColor(data8: any, index: any, light: any, gammaCorrection: any, isCookie: any): void;
    addLightDataSpotAngles(data8: any, index: any, light: any): void;
    addLightDataShadowBias(data8: any, index: any, light: any): void;
    addLightDataPositionRange(data8: any, index: any, light: any, pos: any): void;
    addLightDataSpotDirection(data8: any, index: any, light: any): void;
    addLightDataLightProjMatrix(data8: any, index: any, lightProjectionMatrix: any): void;
    addLightDataCookies(data8: any, index: any, light: any): void;
    addLightAtlasViewport(data8: any, index: any, atlasViewport: any): void;
    addLightAreaSizes(data8: any, index: any, light: any): void;
    addLightData(light: any, lightIndex: any, gammaCorrection: any): void;
}

declare class WorldClusters {
    constructor(device: any);
    device: any;
    name: string;
    reportCount: number;
    boundsMin: Vec3;
    boundsMax: Vec3;
    boundsDelta: Vec3;
    _cells: Vec3;
    _cellsLimit: Vec3;
    set cells(arg: Vec3);
    get cells(): Vec3;
    _maxCellLightCount: number;
    _pixelsPerCellCount: number;
    set maxCellLightCount(arg: number);
    get maxCellLightCount(): number;
    _maxAttenuation: number;
    _maxColorValue: number;
    _usedLights: ClusterLight[];
    lightsBuffer: LightsBuffer;
    _cellsDirty: boolean;
    destroy(): void;
    releaseClusterTexture(): void;
    clusterTexture: Texture;
    registerUniforms(device: any): void;
    _clusterWorldTextureId: any;
    _clusterPixelsPerCellId: any;
    _clusterTextureSizeId: any;
    _clusterTextureSizeData: Float32Array;
    _clusterBoundsMinId: any;
    _clusterBoundsMinData: Float32Array;
    _clusterBoundsDeltaId: any;
    _clusterBoundsDeltaData: Float32Array;
    _clusterCellsCountByBoundsSizeId: any;
    _clusterCellsCountByBoundsSizeData: Float32Array;
    _clusterCellsDotId: any;
    _clusterCellsDotData: Float32Array;
    _clusterCellsMaxId: any;
    _clusterCellsMaxData: Float32Array;
    _clusterCompressionLimit0Id: any;
    _clusterCompressionLimit0Data: Float32Array;
    updateParams(lightingParams: any): void;
    updateCells(): void;
    clusters: Uint8ClampedArray;
    counts: Int32Array;
    uploadTextures(): void;
    updateUniforms(): void;
    evalLightCellMinMax(clusteredLight: any, min: any, max: any): void;
    collectLights(lights: any): void;
    evaluateBounds(): void;
    evaluateCompressionLimits(gammaCorrection: any): void;
    updateClusters(gammaCorrection: any): void;
    update(lights: any, gammaCorrection: any, lightingParams: any): void;
    activate(): void;
}

declare class ClusterLight {
    light: any;
    min: Vec3;
    max: Vec3;
}



/**
 * Layer Composition is a collection of {@link Layer} that is fed to {@link Scene#layers} to define
 * rendering order.
 *
 * @augments EventHandler
 */
declare class LayerComposition extends EventHandler {
    /**
     * Create a new layer composition.
     *
     * @param {string} [name] - Optional non-unique name of the layer composition. Defaults to
     * "Untitled" if not specified.
     */
    constructor(name?: string);
    name: string;
    /**
     * A read-only array of {@link Layer} sorted in the order they will be rendered.
     *
     * @type {Layer[]}
     */
    layerList: Layer[];
    /**
     * A read-only array of boolean values, matching {@link Layer#layerList}. True means only
     * semi-transparent objects are rendered, and false means opaque.
     *
     * @type {boolean[]}
     */
    subLayerList: boolean[];
    /**
     * A read-only array of boolean values, matching {@link Layer#layerList}. True means the
     * layer is rendered, false means it's skipped.
     *
     * @type {boolean[]}
     */
    subLayerEnabled: boolean[];
    _opaqueOrder: {};
    _transparentOrder: {};
    _dirty: boolean;
    _dirtyBlend: boolean;
    _dirtyLights: boolean;
    _dirtyCameras: boolean;
    _meshInstances: any[];
    _meshInstancesSet: Set<any>;
    _lights: any[];
    _lightsMap: Map<any, any>;
    _lightCompositionData: any[];
    _splitLights: any[][];
    /**
     * A read-only array of {@link CameraComponent} that can be used during rendering. e.g.
     * Inside {@link Layer#onPreCull}, {@link Layer#onPostCull}, {@link Layer#onPreRender},
     * {@link Layer#onPostRender}.
     *
     * @type {CameraComponent[]}
     */
    cameras: CameraComponent[];
    /**
     * The actual rendering sequence, generated based on layers and cameras
     *
     * @type {RenderAction[]}
     * @ignore
     */
    _renderActions: RenderAction[];
    _worldClusters: any[];
    _emptyWorldClusters: WorldClusters;
    destroy(): void;
    getEmptyWorldClusters(device: any): WorldClusters;
    _splitLightsArray(target: any): void;
    _update(device: any, clusteredLightingEnabled?: boolean): number;
    updateShadowCasters(): void;
    updateLights(): void;
    findCompatibleCluster(layer: any, renderActionCount: any, emptyWorldClusters: any): any;
    allocateLightClusters(device: any): void;
    addRenderAction(renderActions: any, renderActionIndex: any, layer: any, layerIndex: any, cameraIndex: any, cameraFirstRenderAction: any, postProcessMarked: any): RenderAction;
    propagateRenderTarget(startIndex: any, fromCamera: any): void;
    _logRenderActions(): void;
    _isLayerAdded(layer: any): boolean;
    _isSublayerAdded(layer: any, transparent: any): boolean;
    /**
     * Adds a layer (both opaque and semi-transparent parts) to the end of the {@link Layer#layerList}.
     *
     * @param {Layer} layer - A {@link Layer} to add.
     */
    push(layer: Layer): void;
    /**
     * Inserts a layer (both opaque and semi-transparent parts) at the chosen index in the
     * {@link Layer#layerList}.
     *
     * @param {Layer} layer - A {@link Layer} to add.
     * @param {number} index - Insertion position.
     */
    insert(layer: Layer, index: number): void;
    /**
     * Removes a layer (both opaque and semi-transparent parts) from {@link Layer#layerList}.
     *
     * @param {Layer} layer - A {@link Layer} to remove.
     */
    remove(layer: Layer): void;
    /**
     * Adds part of the layer with opaque (non semi-transparent) objects to the end of the
     * {@link Layer#layerList}.
     *
     * @param {Layer} layer - A {@link Layer} to add.
     */
    pushOpaque(layer: Layer): void;
    /**
     * Inserts an opaque part of the layer (non semi-transparent mesh instances) at the chosen
     * index in the {@link Layer#layerList}.
     *
     * @param {Layer} layer - A {@link Layer} to add.
     * @param {number} index - Insertion position.
     */
    insertOpaque(layer: Layer, index: number): void;
    /**
     * Removes an opaque part of the layer (non semi-transparent mesh instances) from
     * {@link Layer#layerList}.
     *
     * @param {Layer} layer - A {@link Layer} to remove.
     */
    removeOpaque(layer: Layer): void;
    /**
     * Adds part of the layer with semi-transparent objects to the end of the {@link Layer#layerList}.
     *
     * @param {Layer} layer - A {@link Layer} to add.
     */
    pushTransparent(layer: Layer): void;
    /**
     * Inserts a semi-transparent part of the layer at the chosen index in the {@link Layer#layerList}.
     *
     * @param {Layer} layer - A {@link Layer} to add.
     * @param {number} index - Insertion position.
     */
    insertTransparent(layer: Layer, index: number): void;
    /**
     * Removes a transparent part of the layer from {@link Layer#layerList}.
     *
     * @param {Layer} layer - A {@link Layer} to remove.
     */
    removeTransparent(layer: Layer): void;
    _getSublayerIndex(layer: any, transparent: any): number;
    /**
     * Gets index of the opaque part of the supplied layer in the {@link Layer#layerList}.
     *
     * @param {Layer} layer - A {@link Layer} to find index of.
     * @returns {number} The index of the opaque part of the specified layer.
     */
    getOpaqueIndex(layer: Layer): number;
    /**
     * Gets index of the semi-transparent part of the supplied layer in the {@link Layer#layerList}.
     *
     * @param {Layer} layer - A {@link Layer} to find index of.
     * @returns {number} The index of the semi-transparent part of the specified layer.
     */
    getTransparentIndex(layer: Layer): number;
    /**
     * Finds a layer inside this composition by its ID. Null is returned, if nothing is found.
     *
     * @param {number} id - An ID of the layer to find.
     * @returns {Layer|null} The layer corresponding to the specified ID. Returns null if layer is
     * not found.
     */
    getLayerById(id: number): Layer | null;
    /**
     * Finds a layer inside this composition by its name. Null is returned, if nothing is found.
     *
     * @param {string} name - The name of the layer to find.
     * @returns {Layer|null} The layer corresponding to the specified name. Returns null if layer
     * is not found.
     */
    getLayerByName(name: string): Layer | null;
    _updateOpaqueOrder(startIndex: any, endIndex: any): void;
    _updateTransparentOrder(startIndex: any, endIndex: any): void;
    _sortLayersDescending(layersA: any, layersB: any, order: any): number;
    /**
     * Used to determine which array of layers has any transparent sublayer that is on top of all
     * the transparent sublayers in the other array.
     *
     * @param {number[]} layersA - IDs of layers.
     * @param {number[]} layersB - IDs of layers.
     * @returns {number} Returns a negative number if any of the transparent sublayers in layersA
     * is on top of all the transparent sublayers in layersB, or a positive number if any of the
     * transparent sublayers in layersB is on top of all the transparent sublayers in layersA, or 0
     * otherwise.
     * @private
     */
    private sortTransparentLayers;
    /**
     * Used to determine which array of layers has any opaque sublayer that is on top of all the
     * opaque sublayers in the other array.
     *
     * @param {number[]} layersA - IDs of layers.
     * @param {number[]} layersB - IDs of layers.
     * @returns {number} Returns a negative number if any of the opaque sublayers in layersA is on
     * top of all the opaque sublayers in layersB, or a positive number if any of the opaque
     * sublayers in layersB is on top of all the opaque sublayers in layersA, or 0 otherwise.
     * @private
     */
    private sortOpaqueLayers;
}


/** @typedef {import('./mat4.js').Mat4} Mat4 */
/**
 * A 3x3 matrix.
 */
declare class Mat3 {
    /**
     * A constant matrix set to the identity.
     *
     * @type {Mat3}
     * @readonly
     */
    static readonly IDENTITY: Mat3;
    /**
     * A constant matrix with all elements set to 0.
     *
     * @type {Mat3}
     * @readonly
     */
    static readonly ZERO: Mat3;
    /**
     * Matrix elements in the form of a flat array.
     *
     * @type {Float32Array}
     */
    data: Float32Array;
    /**
     * Creates a duplicate of the specified matrix.
     *
     * @returns {this} A duplicate matrix.
     * @example
     * var src = new pc.Mat3().translate(10, 20, 30);
     * var dst = src.clone();
     * console.log("The two matrices are " + (src.equals(dst) ? "equal" : "different"));
     */
    clone(): this;
    /**
     * Copies the contents of a source 3x3 matrix to a destination 3x3 matrix.
     *
     * @param {Mat3} rhs - A 3x3 matrix to be copied.
     * @returns {Mat3} Self for chaining.
     * @example
     * var src = new pc.Mat3().translate(10, 20, 30);
     * var dst = new pc.Mat3();
     * dst.copy(src);
     * console.log("The two matrices are " + (src.equals(dst) ? "equal" : "different"));
     */
    copy(rhs: Mat3): Mat3;
    /**
     * Copies the contents of a source array[9] to a destination 3x3 matrix.
     *
     * @param {number[]} src - An array[9] to be copied.
     * @returns {Mat3} Self for chaining.
     * @example
     * var dst = new pc.Mat3();
     * dst.set([0, 1, 2, 3, 4, 5, 6, 7, 8]);
     */
    set(src: number[]): Mat3;
    /**
     * Reports whether two matrices are equal.
     *
     * @param {Mat3} rhs - The other matrix.
     * @returns {boolean} True if the matrices are equal and false otherwise.
     * @example
     * var a = new pc.Mat3().translate(10, 20, 30);
     * var b = new pc.Mat3();
     * console.log("The two matrices are " + (a.equals(b) ? "equal" : "different"));
     */
    equals(rhs: Mat3): boolean;
    /**
     * Reports whether the specified matrix is the identity matrix.
     *
     * @returns {boolean} True if the matrix is identity and false otherwise.
     * @example
     * var m = new pc.Mat3();
     * console.log("The matrix is " + (m.isIdentity() ? "identity" : "not identity"));
     */
    isIdentity(): boolean;
    /**
     * Sets the matrix to the identity matrix.
     *
     * @returns {Mat3} Self for chaining.
     * @example
     * m.setIdentity();
     * console.log("The matrix is " + (m.isIdentity() ? "identity" : "not identity"));
     */
    setIdentity(): Mat3;
    /**
     * Converts the matrix to string form.
     *
     * @returns {string} The matrix in string form.
     * @example
     * var m = new pc.Mat3();
     * // Outputs [1, 0, 0, 0, 1, 0, 0, 0, 1]
     * console.log(m.toString());
     */
    toString(): string;
    /**
     * Generates the transpose of the specified 3x3 matrix.
     *
     * @returns {Mat3} Self for chaining.
     * @example
     * var m = new pc.Mat3();
     *
     * // Transpose in place
     * m.transpose();
     */
    transpose(): Mat3;
    /**
     * Converts the specified 4x4 matrix to a Mat3.
     *
     * @param {Mat4} m - The 4x4 matrix to convert.
     * @returns {Mat3} Self for chaining.
     */
    setFromMat4(m: Mat4): Mat3;
    /**
     * Transforms a 3-dimensional vector by a 3x3 matrix.
     *
     * @param {Vec3} vec - The 3-dimensional vector to be transformed.
     * @param {Vec3} [res] - An optional 3-dimensional vector to receive the result of the
     * transformation.
     * @returns {Vec3} The input vector v transformed by the current instance.
     */
    transformVector(vec: Vec3, res?: Vec3): Vec3;
}




/**
 * A visual representation of the sky.
 *
 * @ignore
 */
declare class Sky {
    /**
     * @param {GraphicsDevice} device - The graphics device.
     * @param {Scene} scene - The scene owning the sky.
     * @param {Texture} texture - The texture of the sky.
     */
    constructor(device: GraphicsDevice, scene: Scene, texture: Texture);
    /**
     * Mesh instance representing the visuals of the sky.
     *
     * @type {MeshInstance};
     */
    meshInstance: MeshInstance;
    /** @type {Mat3} */
    _rotationMat3: Mat3;
    skyLayer: Layer;
    destroy(): void;
}

declare class LightingParams {
    constructor(supportsAreaLights: any, maxTextureSize: any, dirtyLightsFnc: any);
    _maxTextureSize: any;
    _supportsAreaLights: any;
    _dirtyLightsFnc: any;
    _areaLightsEnabled: boolean;
    _cells: Vec3;
    _maxLightsPerCell: number;
    _shadowsEnabled: boolean;
    _shadowType: number;
    _shadowAtlasResolution: number;
    _cookiesEnabled: boolean;
    _cookieAtlasResolution: number;
    atlasSplit: any;
    debugLayer: any;
    set cells(arg: Vec3);
    get cells(): Vec3;
    set maxLightsPerCell(arg: number);
    get maxLightsPerCell(): number;
    set cookieAtlasResolution(arg: number);
    get cookieAtlasResolution(): number;
    set shadowAtlasResolution(arg: number);
    get shadowAtlasResolution(): number;
    set shadowType(arg: number);
    get shadowType(): number;
    set cookiesEnabled(arg: boolean);
    get cookiesEnabled(): boolean;
    set areaLightsEnabled(arg: boolean);
    get areaLightsEnabled(): boolean;
    set shadowsEnabled(arg: boolean);
    get shadowsEnabled(): boolean;
}



/**
 * A graphical primitive. The mesh is defined by a {@link VertexBuffer} and an optional
 * {@link IndexBuffer}. It also contains a primitive definition which controls the type of the
 * primitive and the portion of the vertex or index buffer to use.
 *
 * ## Mesh APIs
 * There are two ways a mesh can be generated or updated.
 *
 * ### Simple Mesh API
 * {@link Mesh} class provides interfaces such as {@link Mesh#setPositions} and {@link Mesh#setUvs}
 * that provide a simple way to provide vertex and index data for the Mesh, and hiding the
 * complexity of creating the {@link VertexFormat}. This is the recommended interface to use.
 *
 * A simple example which creates a Mesh with 3 vertices, containing position coordinates only, to
 * form a single triangle.
 *
 * ```javascript
 * var mesh = new pc.Mesh(device);
 * var positions = [
 *     0, 0, 0, // pos 0
 *     1, 0, 0, // pos 1
 *     1, 1, 0  // pos 2
 * ];
 * mesh.setPositions(positions);
 * mesh.update();
 * ```
 *
 * An example which creates a Mesh with 4 vertices, containing position and uv coordinates in
 * channel 0, and an index buffer to form two triangles. Float32Array is used for positions and uvs.
 *
 * ```javascript
 * var mesh = new pc.Mesh(device);
 * var positions = new Float32Array([
 *     0, 0, 0, // pos 0
 *     1, 0, 0, // pos 1
 *     1, 1, 0, // pos 2
 *     0, 1, 0  // pos 3
 * ]);
 * var uvs = new Float32Array([
 *     0, 0, // uv 0
 *     1, 0, // uv 1
 *     1, 1, // uv 2
 *     0, 1  // uv 3
 * ]);
 * var indices = [
 *     0, 1, 2, // triangle 0
 *     0, 2, 3  // triangle 1
 * ];
 * mesh.setPositions(positions);
 * mesh.setUvs(0, uvs);
 * mesh.setIndices(indices);
 * mesh.update();
 * ```
 *
 * This example demonstrates that vertex attributes such as position and normals, and also indices
 * can be provided using Arrays ([]) and also Typed Arrays (Float32Array and similar). Note that
 * typed arrays have higher performance, and are generally recommended for per-frame operations or
 * larger meshes, but their construction using new operator is costly operation. If you only need
 * to operate on a small number of vertices or indices, consider using Arrays to avoid the overhead
 * associated with allocating Typed Arrays.
 *
 * Follow these links for more complex examples showing the functionality.
 *
 * - {@link http://playcanvas.github.io/#graphics/mesh-decals}
 * - {@link http://playcanvas.github.io/#graphics/mesh-deformation}
 * - {@link http://playcanvas.github.io/#graphics/mesh-generation}
 * - {@link http://playcanvas.github.io/#graphics/point-cloud-simulation}
 *
 * ### Update Vertex and Index buffers
 * This allows greater flexibility, but is more complex to use. It allows more advanced setups, for
 * example sharing a Vertex or Index Buffer between multiple meshes. See {@link VertexBuffer},
 * {@link IndexBuffer} and {@link VertexFormat} for details.
 */
declare class Mesh extends RefCountedObject {
    /**
     * Create a new Mesh instance.
     *
     * @param {GraphicsDevice} [graphicsDevice] - The graphics device used to manage this mesh. If
     * it is not provided, a device is obtained from the {@link Application}.
     */
    constructor(graphicsDevice?: GraphicsDevice);
    id: number;
    device: any;
    /**
     * The vertex buffer holding the vertex data of the mesh.
     *
     * @type {VertexBuffer}
     */
    vertexBuffer: VertexBuffer;
    /**
     * An array of index buffers. For unindexed meshes, this array can be empty. The first
     * index buffer in the array is used by {@link MeshInstance}s with a renderStyle property
     * set to {@link RENDERSTYLE_SOLID}. The second index buffer in the array is used if
     * renderStyle is set to {@link RENDERSTYLE_WIREFRAME}.
     *
     * @type {IndexBuffer[]}
     */
    indexBuffer: IndexBuffer[];
    /**
     * Array of primitive objects defining how vertex (and index) data in the mesh should be
     * interpreted by the graphics device.
     *
     * - `type` is the type of primitive to render. Can be:
     *
     *   - {@link PRIMITIVE_POINTS}
     *   - {@link PRIMITIVE_LINES}
     *   - {@link PRIMITIVE_LINELOOP}
     *   - {@link PRIMITIVE_LINESTRIP}
     *   - {@link PRIMITIVE_TRIANGLES}
     *   - {@link PRIMITIVE_TRISTRIP}
     *   - {@link PRIMITIVE_TRIFAN}
     *
     * - `base` is the offset of the first index or vertex to dispatch in the draw call.
     * - `count` is the number of indices or vertices to dispatch in the draw call.
     * - `indexed` specifies whether to interpret the primitive as indexed, thereby using the
     * currently set index buffer.
     *
     * @type {Array.<{type: number, base: number, count: number, indexed: boolean|undefined}>}
     */
    primitive: {
        type: number;
        base: number;
        count: number;
        indexed: boolean | undefined;
    }[];
    /**
     * The skin data (if any) that drives skinned mesh animations for this mesh.
     *
     * @type {Skin|null}
     */
    skin: Skin | null;
    _morph: any;
    _geometryData: GeometryData;
    _aabb: BoundingBox;
    boneAabb: any[];
    /**
     * The morph data (if any) that drives morph target animations for this mesh.
     *
     * @type {Morph|null}
     */
    set morph(arg: any);
    get morph(): any;
    /**
     * The axis-aligned bounding box for the object space vertices of this mesh.
     *
     * @type {BoundingBox}
     */
    set aabb(arg: BoundingBox);
    get aabb(): BoundingBox;
    /**
     * Destroys {@link VertexBuffer} and {@link IndexBuffer} associate with the mesh. This is
     * normally called by {@link Model#destroy} and does not need to be called manually.
     */
    destroy(): void;
    _destroyIndexBuffer(index: any): void;
    _initBoneAabbs(morphTargets: any): void;
    boneUsed: any[];
    _initGeometryData(): void;
    /**
     * Clears the mesh of existing vertices and indices and resets the {@link VertexFormat}
     * associated with the mesh. This call is typically followed by calls to methods such as
     * {@link Mesh#setPositions}, {@link Mesh#setVertexStream} or {@link Mesh#setIndices} and
     * finally {@link Mesh#update} to rebuild the mesh, allowing different {@link VertexFormat}.
     *
     * @param {boolean} [verticesDynamic] - Indicates the {@link VertexBuffer} should be created
     * with {@link BUFFER_DYNAMIC} usage. If not specified, {@link BUFFER_STATIC} is used.
     * @param {boolean} [indicesDynamic] - Indicates the {@link IndexBuffer} should be created with
     * {@link BUFFER_DYNAMIC} usage. If not specified, {@link BUFFER_STATIC} is used.
     * @param {number} [maxVertices] - A {@link VertexBuffer} will be allocated with at least
     * maxVertices, allowing additional vertices to be added to it without the allocation. If no
     * value is provided, a size to fit the provided vertices will be allocated.
     * @param {number} [maxIndices] - An {@link IndexBuffer} will be allocated with at least
     * maxIndices, allowing additional indices to be added to it without the allocation. If no
     * value is provided, a size to fit the provided indices will be allocated.
     */
    clear(verticesDynamic?: boolean, indicesDynamic?: boolean, maxVertices?: number, maxIndices?: number): void;
    /**
     * Sets the vertex data for any supported semantic.
     *
     * @param {string} semantic - The meaning of the vertex element. For supported semantics, see
     * SEMANTIC_* in {@link VertexFormat}.
     * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} data - Vertex
     * data for the specified semantic.
     * @param {number} componentCount - The number of values that form a single Vertex element. For
     * example when setting a 3D position represented by 3 numbers per vertex, number 3 should be
     * specified.
     * @param {number} [numVertices] - The number of vertices to be used from data array. If not
     * provided, the whole data array is used. This allows to use only part of the data array.
     * @param {number} [dataType] - The format of data when stored in the {@link VertexBuffer}, see
     * TYPE_* in {@link VertexFormat}. When not specified, {@link TYPE_FLOAT32} is used.
     * @param {boolean} [dataTypeNormalize] - If true, vertex attribute data will be mapped from a
     * 0 to 255 range down to 0 to 1 when fed to a shader. If false, vertex attribute data is left
     * unchanged. If this property is unspecified, false is assumed.
     */
    setVertexStream(semantic: string, data: number[] | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array, componentCount: number, numVertices?: number, dataType?: number, dataTypeNormalize?: boolean): void;
    /**
     * Gets the vertex data corresponding to a semantic.
     *
     * @param {string} semantic - The semantic of the vertex element to get. For supported
     * semantics, see SEMANTIC_* in {@link VertexFormat}.
     * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} data - An
     * array to populate with the vertex data. When typed array is supplied, enough space needs to
     * be reserved, otherwise only partial data is copied.
     * @returns {number} Returns the number of vertices populated.
     */
    getVertexStream(semantic: string, data: number[] | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array): number;
    /**
     * Sets the vertex positions array. Vertices are stored using {@link TYPE_FLOAT32} format.
     *
     * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} positions - Vertex
     * data containing positions.
     * @param {number} [componentCount] - The number of values that form a single position element.
     * Defaults to 3 if not specified, corresponding to x, y and z coordinates.
     * @param {number} [numVertices] - The number of vertices to be used from data array. If not
     * provided, the whole data array is used. This allows to use only part of the data array.
     */
    setPositions(positions: number[] | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array, componentCount?: number, numVertices?: number): void;
    /**
     * Sets the vertex normals array. Normals are stored using {@link TYPE_FLOAT32} format.
     *
     * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} normals - Vertex
     * data containing normals.
     * @param {number} [componentCount] - The number of values that form a single normal element.
     * Defaults to 3 if not specified, corresponding to x, y and z direction.
     * @param {number} [numVertices] - The number of vertices to be used from data array. If not
     * provided, the whole data array is used. This allows to use only part of the data array.
     */
    setNormals(normals: number[] | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array, componentCount?: number, numVertices?: number): void;
    /**
     * Sets the vertex uv array. Uvs are stored using {@link TYPE_FLOAT32} format.
     *
     * @param {number} channel - The uv channel in [0..7] range.
     * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} uvs - Vertex
     * data containing uv-coordinates.
     * @param {number} [componentCount] - The number of values that form a single uv element.
     * Defaults to 2 if not specified, corresponding to u and v coordinates.
     * @param {number} [numVertices] - The number of vertices to be used from data array. If not
     * provided, the whole data array is used. This allows to use only part of the data array.
     */
    setUvs(channel: number, uvs: number[] | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array, componentCount?: number, numVertices?: number): void;
    /**
     * Sets the vertex color array. Colors are stored using {@link TYPE_FLOAT32} format, which is
     * useful for HDR colors.
     *
     * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} colors - Vertex
     * data containing colors.
     * @param {number} [componentCount] - The number of values that form a single color element.
     * Defaults to 4 if not specified, corresponding to r, g, b and a.
     * @param {number} [numVertices] - The number of vertices to be used from data array. If not
     * provided, the whole data array is used. This allows to use only part of the data array.
     */
    setColors(colors: number[] | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array, componentCount?: number, numVertices?: number): void;
    /**
     * Sets the vertex color array. Colors are stored using {@link TYPE_UINT8} format, which is
     * useful for LDR colors. Values in the array are expected in [0..255] range, and are mapped to
     * [0..1] range in the shader.
     *
     * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} colors - Vertex
     * data containing colors. The array is expected to contain 4 components per vertex,
     * corresponding to r, g, b and a.
     * @param {number} [numVertices] - The number of vertices to be used from data array. If not
     * provided, the whole data array is used. This allows to use only part of the data array.
     */
    setColors32(colors: number[] | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array, numVertices?: number): void;
    /**
     * Sets the index array. Indices are stored using 16-bit format by default, unless more than
     * 65535 vertices are specified, in which case 32-bit format is used.
     *
     * @param {number[]|Uint8Array|Uint16Array|Uint32Array} indices - The array of indices that
     * define primitives (lines, triangles, etc.).
     * @param {number} [numIndices] - The number of indices to be used from data array. If not
     * provided, the whole data array is used. This allows to use only part of the data array.
     */
    setIndices(indices: number[] | Uint8Array | Uint16Array | Uint32Array, numIndices?: number): void;
    /**
     * Gets the vertex positions data.
     *
     * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} positions - An
     * array to populate with the vertex data. When typed array is supplied, enough space needs to
     * be reserved, otherwise only partial data is copied.
     * @returns {number} Returns the number of vertices populated.
     */
    getPositions(positions: number[] | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array): number;
    /**
     * Gets the vertex normals data.
     *
     * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} normals - An
     * array to populate with the vertex data. When typed array is supplied, enough space needs to
     * be reserved, otherwise only partial data is copied.
     * @returns {number} Returns the number of vertices populated.
     */
    getNormals(normals: number[] | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array): number;
    /**
     * Gets the vertex uv data.
     *
     * @param {number} channel - The uv channel in [0..7] range.
     * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} uvs - An
     * array to populate with the vertex data. When typed array is supplied, enough space needs to
     * be reserved, otherwise only partial data is copied.
     * @returns {number} Returns the number of vertices populated.
     */
    getUvs(channel: number, uvs: number[] | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array): number;
    /**
     * Gets the vertex color data.
     *
     * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} colors - An
     * array to populate with the vertex data. When typed array is supplied, enough space needs to
     * be reserved, otherwise only partial data is copied.
     * @returns {number} Returns the number of vertices populated.
     */
    getColors(colors: number[] | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array): number;
    /**
     * Gets the index data.
     *
     * @param {number[]|Uint8Array|Uint16Array|Uint32Array} indices - An array to populate with the
     * index data. When a typed array is supplied, enough space needs to be reserved, otherwise
     * only partial data is copied.
     * @returns {number} Returns the number of indices populated.
     */
    getIndices(indices: number[] | Uint8Array | Uint16Array | Uint32Array): number;
    /**
     * Applies any changes to vertex stream and indices to mesh. This allocates or reallocates
     * {@link vertexBuffer} or {@link IndexBuffer} to fit all provided vertices and indices, and
     * fills them with data.
     *
     * @param {number} [primitiveType] - The type of primitive to render.  Can be:
     *
     * - {@link PRIMITIVE_POINTS}
     * - {@link PRIMITIVE_LINES}
     * - {@link PRIMITIVE_LINELOOP}
     * - {@link PRIMITIVE_LINESTRIP}
     * - {@link PRIMITIVE_TRIANGLES}
     * - {@link PRIMITIVE_TRISTRIP}
     * - {@link PRIMITIVE_TRIFAN}
     *
     * Defaults to {@link PRIMITIVE_TRIANGLES} if unspecified.
     * @param {boolean} [updateBoundingBox] - True to update bounding box. Bounding box is updated
     * only if positions were set since last time update was called, and componentCount for
     * position was 3, otherwise bounding box is not updated. See {@link Mesh#setPositions}.
     * Defaults to true if unspecified. Set this to false to avoid update of the bounding box and
     * use aabb property to set it instead.
     */
    update(primitiveType?: number, updateBoundingBox?: boolean): void;
    _buildVertexFormat(vertexCount: any): VertexFormat;
    _updateVertexBuffer(): void;
    _updateIndexBuffer(): void;
    prepareRenderState(renderStyle: any): void;
    updateRenderStates(): void;
    generateWireframe(): void;
}

declare class GeometryData {
    static DEFAULT_COMPONENTS_POSITION: number;
    static DEFAULT_COMPONENTS_NORMAL: number;
    static DEFAULT_COMPONENTS_UV: number;
    static DEFAULT_COMPONENTS_COLORS: number;
    initDefaults(): void;
    recreate: boolean;
    verticesUsage: number;
    indicesUsage: number;
    maxVertices: number;
    maxIndices: number;
    vertexCount: any;
    indexCount: number;
    vertexStreamsUpdated: boolean;
    indexStreamUpdated: boolean;
    vertexStreamDictionary: {};
    indices: any;
    _changeVertexCount(count: any, semantic: any): void;
}


/** @typedef {import('../../graphics/texture.js').Texture} Texture */
/**
 * A BasicMaterial is for rendering unlit geometry, either using a constant color or a color map
 * modulated with a color.
 *
 * @augments Material
 */
declare class BasicMaterial extends Material {
    /**
     * The flat color of the material (RGBA, where each component is 0 to 1).
     *
     * @type {Color}
     */
    color: Color;
    colorUniform: Float32Array;
    /**
     * The color map of the material (default is null). If specified, the color map is
     * modulated by the color property.
     *
     * @type {Texture|null}
     */
    colorMap: Texture | null;
    vertexColors: boolean;
    /**
     * Copy a `BasicMaterial`.
     *
     * @param {BasicMaterial} source - The material to copy from.
     * @returns {BasicMaterial} The destination material.
     */
    copy(source: BasicMaterial): BasicMaterial;
}

declare class Immediate {
    static getTextureVS(): string;
    constructor(device: any);
    device: any;
    quadMesh: Mesh;
    textureShader: Shader;
    depthTextureShader: Shader;
    cubeLocalPos: any;
    cubeWorldPos: any;
    batchesMap: Map<any, any>;
    allBatches: Set<any>;
    updatedLayers: Set<any>;
    _materialDepth: BasicMaterial;
    _materialNoDepth: BasicMaterial;
    layerMeshInstances: Map<any, any>;
    createMaterial(depthTest: any): BasicMaterial;
    get materialDepth(): BasicMaterial;
    get materialNoDepth(): BasicMaterial;
    getBatch(layer: any, depthTest: any): any;
    getTextureShader(): Shader;
    getDepthTextureShader(): Shader;
    getQuadMesh(): Mesh;
    drawMesh(material: any, matrix: any, mesh: any, meshInstance: any, layer: any): void;
    drawWireAlignedBox(min: any, max: any, color: any, depthTest: any, layer: any): void;
    drawWireSphere(center: any, radius: any, color: any, numSegments: any, depthTest: any, layer: any): void;
    getGraphNode(matrix: any): GraphNode;
    onPreRenderLayer(layer: any, visibleList: any, transparent: any): void;
    onPostRender(): void;
}




/** @typedef {import('../framework/entity.js').Entity} Entity */
/** @typedef {import('../graphics/graphics-device.js').GraphicsDevice} GraphicsDevice */
/** @typedef {import('../graphics/texture.js').Texture} Texture */
/** @typedef {import('./composition/layer-composition.js').LayerComposition} LayerComposition */
/** @typedef {import('./layer.js').Layer} Layer */
/**
 * A scene is graphical representation of an environment. It manages the scene hierarchy, all
 * graphical objects, lights, and scene-wide properties.
 *
 * @augments EventHandler
 */
declare class Scene extends EventHandler {
    /**
     * Create a new Scene instance.
     *
     * @param {GraphicsDevice} graphicsDevice - The graphics device used to manage this scene.
     * @hideconstructor
     */
    constructor(graphicsDevice: GraphicsDevice);
    /**
     * If enabled, the ambient lighting will be baked into lightmaps. This will be either the
     * {@link Scene#skybox} if set up, otherwise {@link Scene#ambientLight}. Defaults to false.
     *
     * @type {boolean}
     */
    ambientBake: boolean;
    /**
     * If {@link Scene#ambientBake} is true, this specifies the brightness of ambient occlusion.
     * Typical range is -1 to 1. Defaults to 0, representing no change to brightness.
     *
     * @type {number}
     */
    ambientBakeOcclusionBrightness: number;
    /**
     * If {@link Scene#ambientBake} is true, this specifies the contrast of ambient occlusion.
     * Typical range is -1 to 1. Defaults to 0, representing no change to contrast.
     *
     * @type {number}
     */
    ambientBakeOcclusionContrast: number;
    /**
     * The color of the scene's ambient light. Defaults to black (0, 0, 0).
     *
     * @type {Color}
     */
    ambientLight: Color;
    /**
     * The exposure value tweaks the overall brightness of the scene. Defaults to 1.
     *
     * @type {number}
     */
    exposure: number;
    /**
     * The color of the fog (if enabled). Defaults to black (0, 0, 0).
     *
     * @type {Color}
     */
    fogColor: Color;
    /**
     * The density of the fog (if enabled). This property is only valid if the fog property is set
     * to {@link FOG_EXP} or {@link FOG_EXP2}. Defaults to 0.
     *
     * @type {number}
     */
    fogDensity: number;
    /**
     * The distance from the viewpoint where linear fog reaches its maximum. This property is only
     * valid if the fog property is set to {@link FOG_LINEAR}. Defaults to 1000.
     *
     * @type {number}
     */
    fogEnd: number;
    /**
     * The distance from the viewpoint where linear fog begins. This property is only valid if the
     * fog property is set to {@link FOG_LINEAR}. Defaults to 1.
     *
     * @type {number}
     */
    fogStart: number;
    /**
     * The lightmap resolution multiplier. Defaults to 1.
     *
     * @type {number}
     */
    lightmapSizeMultiplier: number;
    /**
     * The maximum lightmap resolution. Defaults to 2048.
     *
     * @type {number}
     */
    lightmapMaxResolution: number;
    /**
     * The lightmap baking mode. Can be:
     *
     * - {@link BAKE_COLOR}: single color lightmap
     * - {@link BAKE_COLORDIR}: single color lightmap + dominant light direction (used for bump or
     * specular). Only lights with bakeDir=true will be used for generating the dominant light
     * direction.
     *
     * Defaults to {@link BAKE_COLORDIR}.
     *
     * @type {number}
     */
    lightmapMode: number;
    /**
     * Enables bilateral filter on runtime baked color lightmaps, which removes the noise and
     * banding while preserving the edges. Defaults to false. Note that the filtering takes place
     * in the image space of the lightmap, and it does not filter across lightmap UV space seams,
     * often making the seams more visible. It's important to balance the strength of the filter
     * with number of samples used for lightmap baking to limit the visible artifacts.
     *
     * @type {boolean}
     */
    lightmapFilterEnabled: boolean;
    /**
     * The root entity of the scene, which is usually the only child to the {@link Application}
     * root entity.
     *
     * @type {Entity}
     */
    root: Entity;
    /**
     * The sky of the scene.
     *
     * @type {Sky}
     * @ignore
     */
    sky: Sky;
    device: any;
    _gravity: Vec3;
    /**
     * @type {LayerComposition}
     * @private
     */
    private _layers;
    _fog: string;
    _gammaCorrection: number;
    _toneMapping: number;
    /**
     * The skybox cubemap as set by user (gets used when skyboxMip === 0)
     *
     * @type {Texture}
     * @private
     */
    private _skyboxCubeMap;
    /**
     * Array of 6 prefiltered lighting data cubemaps.
     *
     * @type {Texture[]}
     * @private
     */
    private _prefilteredCubemaps;
    /**
     * Environment lighting atlas
     *
     * @type {Texture}
     * @private
     */
    private _envAtlas;
    _internalEnvAtlas: any;
    _skyboxIntensity: number;
    _skyboxMip: number;
    _skyboxRotation: Quat;
    _skyboxRotationMat3: any;
    _skyboxRotationMat4: any;
    _ambientBakeNumSamples: number;
    _ambientBakeSpherePart: number;
    _lightmapFilterRange: number;
    _lightmapFilterSmoothness: number;
    _clusteredLightingEnabled: boolean;
    _lightingParams: LightingParams;
    _stats: {
        meshInstances: number;
        lights: number;
        dynamicLights: number;
        bakedLights: number;
        lastStaticPrepareFullTime: number;
        lastStaticPrepareSearchTime: number;
        lastStaticPrepareWriteTime: number;
        lastStaticPrepareTriAabbTime: number;
        lastStaticPrepareCombineTime: number;
        updateShadersTime: number;
    };
    /**
     * This flag indicates changes were made to the scene which may require recompilation of
     * shaders that reference global settings.
     *
     * @type {boolean}
     * @ignore
     */
    updateShaders: boolean;
    _shaderVersion: number;
    _statsUpdated: boolean;
    immediate: Immediate;
    /**
     * Fired when the skybox is set.
     *
     * @event Scene#set:skybox
     * @param {Texture} usedTex - Previously used cubemap texture. New is in the {@link Scene#skybox}.
     */
    /**
     * Fired when the layer composition is set. Use this event to add callbacks or advanced
     * properties to your layers.
     *
     * @event Scene#set:layers
     * @param {LayerComposition} oldComp - Previously used {@link LayerComposition}.
     * @param {LayerComposition} newComp - Newly set {@link LayerComposition}.
     * @example
     * this.app.scene.on('set:layers', function (oldComp, newComp) {
     *     var list = newComp.layerList;
     *     var layer;
     *     for (var i = 0; i < list.length; i++) {
     *         layer = list[i];
     *         switch (layer.name) {
     *             case 'MyLayer':
     *                 layer.onEnable = myOnEnableFunction;
     *                 layer.onDisable = myOnDisableFunction;
     *                 break;
     *             case 'MyOtherLayer':
     *                 layer.shaderPass = myShaderPass;
     *                 break;
     *         }
     *     }
     * });
     */
    /**
     * Returns the default layer used by the immediate drawing functions.
     *
     * @type {Layer}
     * @private
     */
    private get defaultDrawLayer();
    /**
     * If {@link Scene#ambientBake} is true, this specifies the number of samples used to bake the
     * ambient light into the lightmap. Defaults to 1. Maximum value is 255.
     *
     * @type {number}
     */
    set ambientBakeNumSamples(arg: number);
    get ambientBakeNumSamples(): number;
    /**
     * If {@link Scene#ambientBake} is true, this specifies a part of the sphere which represents
     * the source of ambient light. The valid range is 0..1, representing a part of the sphere from
     * top to the bottom. A value of 0.5 represents the upper hemisphere. A value of 1 represents a
     * full sphere. Defaults to 0.4, which is a smaller upper hemisphere as this requires fewer
     * samples to bake.
     *
     * @type {number}
     */
    set ambientBakeSpherePart(arg: number);
    get ambientBakeSpherePart(): number;
    set clusteredLightingEnabled(arg: boolean);
    get clusteredLightingEnabled(): boolean;
    /**
     * List of all active composition mesh instances. Only for backwards compatibility.
     * TODO: BatchManager is using it - perhaps that could be refactored
     *
     * @type {MeshInstance[]}
     * @private
     */
    private set drawCalls(arg);
    private get drawCalls();
    /**
     * The environment lighting atlas.
     *
     * @type {Texture}
     */
    set envAtlas(arg: Texture);
    get envAtlas(): Texture;
    /**
     * The type of fog used by the scene. Can be:
     *
     * - {@link FOG_NONE}
     * - {@link FOG_LINEAR}
     * - {@link FOG_EXP}
     * - {@link FOG_EXP2}
     *
     * Defaults to {@link FOG_NONE}.
     *
     * @type {string}
     */
    set fog(arg: string);
    get fog(): string;
    /**
     * The gamma correction to apply when rendering the scene. Can be:
     *
     * - {@link GAMMA_NONE}
     * - {@link GAMMA_SRGB}
     *
     * Defaults to {@link GAMMA_SRGB}.
     *
     * @type {number}
     */
    set gammaCorrection(arg: number);
    get gammaCorrection(): number;
    /**
     * A {@link LayerComposition} that defines rendering order of this scene.
     *
     * @type {LayerComposition}
     */
    set layers(arg: LayerComposition);
    get layers(): LayerComposition;
    get lighting(): LightingParams;
    /**
     * A range parameter of the bilateral filter. It's used when {@link Scene#lightmapFilterEnabled}
     * is enabled. Larger value applies more widespread blur. This needs to be a positive non-zero
     * value. Defaults to 10.
     *
     * @type {number}
     */
    set lightmapFilterRange(arg: number);
    get lightmapFilterRange(): number;
    /**
     * A spatial parameter of the bilateral filter. It's used when {@link Scene#lightmapFilterEnabled}
     * is enabled. Larger value blurs less similar colors. This needs to be a positive non-zero
     * value. Defaults to 0.2.
     *
     * @type {number}
     */
    set lightmapFilterSmoothness(arg: number);
    get lightmapFilterSmoothness(): number;
    /**
     * Set of 6 prefiltered cubemaps.
     *
     * @type {Texture[]}
     */
    set prefilteredCubemaps(arg: Texture[]);
    get prefilteredCubemaps(): Texture[];
    /**
     * The base cubemap texture used as the scene's skybox, if mip level is 0. Defaults to null.
     *
     * @type {Texture}
     */
    set skybox(arg: Texture);
    get skybox(): Texture;
    /**
     * Multiplier for skybox intensity. Defaults to 1.
     *
     * @type {number}
     */
    set skyboxIntensity(arg: number);
    get skyboxIntensity(): number;
    /**
     * The mip level of the skybox to be displayed. Only valid for prefiltered cubemap skyboxes.
     * Defaults to 0 (base level).
     *
     * @type {number}
     */
    set skyboxMip(arg: number);
    get skyboxMip(): number;
    /**
     * The rotation of the skybox to be displayed. Defaults to {@link Quat.IDENTITY}.
     *
     * @type {Quat}
     */
    set skyboxRotation(arg: Quat);
    get skyboxRotation(): Quat;
    /**
     * The tonemapping transform to apply when writing fragments to the frame buffer. Can be:
     *
     * - {@link TONEMAP_LINEAR}
     * - {@link TONEMAP_FILMIC}
     * - {@link TONEMAP_HEJL}
     * - {@link TONEMAP_ACES}
     *
     * Defaults to {@link TONEMAP_LINEAR}.
     *
     * @type {number}
     */
    set toneMapping(arg: number);
    get toneMapping(): number;
    destroy(): void;
    drawLine(start: any, end: any, color?: Color, depthTest?: boolean, layer?: Layer): void;
    drawLines(positions: any, colors: any, depthTest?: boolean, layer?: Layer): void;
    drawLineArrays(positions: any, colors: any, depthTest?: boolean, layer?: Layer): void;
    applySettings(settings: any): void;
    _getSkyboxTex(): Texture;
    _updateSky(device: any): void;
    _resetSky(): void;
    /**
     * Sets the cubemap for the scene skybox.
     *
     * @param {Texture[]} [cubemaps] - An array of cubemaps corresponding to the skybox at
     * different mip levels. If undefined, scene will remove skybox. Cubemap array should be of
     * size 7, with the first element (index 0) corresponding to the base cubemap (mip level 0)
     * with original resolution. Each remaining element (index 1-6) corresponds to a fixed
     * prefiltered resolution (128x128, 64x64, 32x32, 16x16, 8x8, 4x4).
     */
    setSkybox(cubemaps?: Texture[]): void;
}









declare class Command {
    constructor(layer: any, blendType: any, command: any);
    _key: number[];
    command: any;
    set key(arg: number);
    get key(): number;
}
/**
 * Callback used by {@link Layer} to calculate the "sort distance" for a {@link MeshInstance},
 * which determines its place in the render order.
 *
 * @callback CalculateSortDistanceCallback
 * @param {MeshInstance} meshInstance - The mesh instance.
 * @param {Vec3} cameraPosition - The position of the camera.
 * @param {Vec3} cameraForward - The forward vector of the camera.
 */
/**
 * An instance of a {@link Mesh}. A single mesh can be referenced by many mesh instances that can
 * have different transforms and materials.
 */
declare class MeshInstance {
    static lightmapParamNames: string[];
    static _prepareRenderStyleForArray(meshInstances: any, renderStyle: any): void;
    /**
     * Create a new MeshInstance instance.
     *
     * @param {Mesh} mesh - The graphics mesh to instance.
     * @param {Material} material - The material to use for this mesh instance.
     * @param {GraphNode} [node] - The graph node defining the transform for this instance. This
     * parameter is optional when used with {@link RenderComponent} and will use the node the
     * component is attached to.
     * @example
     * // Create a mesh instance pointing to a 1x1x1 'cube' mesh
     * var mesh = pc.createBox(graphicsDevice);
     * var material = new pc.StandardMaterial();
     *
     * var meshInstance = new pc.MeshInstance(mesh, material);
     *
     * var entity = new pc.Entity();
     * entity.addComponent('render', {
     *     meshInstances: [meshInstance]
     * });
     *
     * // Add the entity to the scene hierarchy
     * this.app.scene.root.addChild(entity);
     */
    constructor(mesh: Mesh, material: Material, node?: GraphNode);
    /**
     * @type {Material}
     * @private
     */
    private _material;
    /**
     * An array of shaders used by the mesh instance, indexed by the shader pass constant (SHADER_FORWARD..)
     *
     * @type {Array<Shader>}
     * @ignore
     */
    _shader: Array<Shader>;
    _key: number[];
    isStatic: boolean;
    _staticLightList: any;
    _staticSource: any;
    /**
     * The graph node defining the transform for this instance.
     *
     * @type {GraphNode}
     */
    node: GraphNode;
    _mesh: Mesh;
    /**
     * The material used by this mesh instance.
     *
     * @type {Material}
     */
    set material(arg: Material);
    get material(): Material;
    _shaderDefs: number;
    _lightHash: number;
    /**
     * Enable rendering for this mesh instance. Use visible property to enable/disable
     * rendering without overhead of removing from scene. But note that the mesh instance is
     * still in the hierarchy and still in the draw call list.
     *
     * @type {boolean}
     */
    visible: boolean;
    set layer(arg: any);
    get layer(): any;
    /** @private */
    private _renderStyle;
    castShadow: boolean;
    _receiveShadow: boolean;
    _screenSpace: boolean;
    _noDepthDrawGl1: boolean;
    /**
     * Controls whether the mesh instance can be culled by frustum culling
     * ({@link CameraComponent#frustumCulling}).
     *
     * @type {boolean}
     */
    cull: boolean;
    /**
     * True if the mesh instance is pickable by the {@link Picker}. Defaults to true.
     *
     * @type {boolean}
     * @ignore
     */
    pick: boolean;
    _updateAabb: boolean;
    _updateAabbFunc: any;
    _calculateSortDistance: any;
    /**
     * @type {SkinInstance}
     * @private
     */
    private _skinInstance;
    /**
     * @type {MorphInstance}
     * @private
     */
    private _morphInstance;
    instancingData: InstancingData;
    /**
     * @type {BoundingBox}
     * @private
     */
    private _customAabb;
    /**
     * The world space axis-aligned bounding box for this mesh instance.
     *
     * @type {BoundingBox}
     */
    set aabb(arg: any);
    get aabb(): any;
    _aabbVer: number;
    /**
     * Use this value to affect rendering order of mesh instances. Only used when mesh
     * instances are added to a {@link Layer} with {@link Layer#opaqueSortMode} or
     * {@link Layer#transparentSortMode} (depending on the material) set to
     * {@link SORTMODE_MANUAL}.
     *
     * @type {number}
     */
    drawOrder: number;
    /**
     * Read this value in {@link Layer#onPostCull} to determine if the object is actually going
     * to be rendered.
     *
     * @type {boolean}
     */
    visibleThisFrame: boolean;
    isVisibleFunc: any;
    parameters: {};
    stencilFront: any;
    stencilBack: any;
    flipFaces: boolean;
    /**
     * The render style of the mesh instance. Can be:
     *
     * - {@link RENDERSTYLE_SOLID}
     * - {@link RENDERSTYLE_WIREFRAME}
     * - {@link RENDERSTYLE_POINTS}
     *
     * Defaults to {@link RENDERSTYLE_SOLID}.
     *
     * @type {number}
     */
    set renderStyle(arg: number);
    get renderStyle(): number;
    /**
     * The graphics mesh being instanced.
     *
     * @type {Mesh}
     */
    set mesh(arg: Mesh);
    get mesh(): Mesh;
    _aabb: any;
    /**
     * Clear the internal shader array.
     *
     * @ignore
     */
    clearShaders(): void;
    _layer: any;
    /**
     * In some circumstances mesh instances are sorted by a distance calculation to determine their
     * rendering order. Set this callback to override the default distance calculation, which gives
     * the dot product of the camera forward vector and the vector between the camera position and
     * the center of the mesh instance's axis-aligned bounding box. This option can be particularly
     * useful for rendering transparent meshes in a better order than default.
     *
     * @type {CalculateSortDistanceCallback}
     */
    set calculateSortDistance(arg: any);
    get calculateSortDistance(): any;
    set receiveShadow(arg: boolean);
    get receiveShadow(): boolean;
    /**
     * The skin instance managing skinning of this mesh instance, or null if skinning is not used.
     *
     * @type {SkinInstance}
     */
    set skinInstance(arg: SkinInstance);
    get skinInstance(): SkinInstance;
    /**
     * The morph instance managing morphing of this mesh instance, or null if morphing is not used.
     *
     * @type {MorphInstance}
     */
    set morphInstance(arg: MorphInstance);
    get morphInstance(): MorphInstance;
    set screenSpace(arg: boolean);
    get screenSpace(): boolean;
    set key(arg: number);
    get key(): number;
    /**
     * Mask controlling which {@link LightComponent}s light this mesh instance, which
     * {@link CameraComponent} sees it and in which {@link Layer} it is rendered. Defaults to 1.
     *
     * @type {number}
     */
    set mask(arg: number);
    get mask(): number;
    /**
     * Number of instances when using hardware instancing to render the mesh.
     *
     * @type {number}
     */
    set instancingCount(arg: number);
    get instancingCount(): number;
    destroy(): void;
    _isVisible(camera: any): any;
    updateKey(): void;
    /**
     * Sets up {@link MeshInstance} to be rendered using Hardware Instancing.
     *
     * @param {VertexBuffer|null} vertexBuffer - Vertex buffer to hold per-instance vertex data
     * (usually world matrices). Pass null to turn off hardware instancing.
     */
    setInstancing(vertexBuffer: VertexBuffer | null): void;
    /**
     * Obtain a shader variant required to render the mesh instance within specified pass.
     *
     * @param {Scene} scene - The scene.
     * @param {number} pass - The render pass.
     * @param {any} staticLightList - List of static lights.
     * @param {any} sortedLights - Array of arrays of lights.
     * @param {UniformBufferFormat} viewUniformFormat - THe format of the view uniform buffer.
     * @param {BindGroupFormat} viewBindGroupFormat - The format of the view bind group.
     * @ignore
     */
    updatePassShader(scene: Scene, pass: number, staticLightList: any, sortedLights: any, viewUniformFormat: UniformBufferFormat, viewBindGroupFormat: BindGroupFormat): void;
    clearParameters(): void;
    getParameters(): {};
    /**
     * Retrieves the specified shader parameter from a mesh instance.
     *
     * @param {string} name - The name of the parameter to query.
     * @returns {object} The named parameter.
     */
    getParameter(name: string): object;
    /**
     * Sets a shader parameter on a mesh instance. Note that this parameter will take precedence
     * over parameter of the same name if set on Material this mesh instance uses for rendering.
     *
     * @param {string} name - The name of the parameter to set.
     * @param {number|number[]|Texture} data - The value for the specified parameter.
     * @param {number} [passFlags] - Mask describing which passes the material should be included
     * in.
     */
    setParameter(name: string, data: number | number[] | Texture, passFlags?: number): void;
    setRealtimeLightmap(name: any, texture: any): void;
    /**
     * Deletes a shader parameter on a mesh instance.
     *
     * @param {string} name - The name of the parameter to delete.
     */
    deleteParameter(name: string): void;
    setParameters(device: any, passFlag: any): void;
    setLightmapped(value: any): void;
    setCustomAabb(aabb: any): void;
    _setupSkinUpdate(): void;
}

/**
 * Internal data structure used to store data used by hardware instancing.
 *
 * @ignore
 */
declare class InstancingData {
    /**
     * @param {number} numObjects - The number of objects instanced.
     */
    constructor(numObjects: number);
    /** @type {VertexBuffer|null} */
    vertexBuffer: VertexBuffer | null;
    count: number;
}



/**
 * A material determines how a particular mesh instance is rendered. It specifies the shader and
 * render state that is set before the mesh instance is submitted to the graphics device.
 *
 * @property {number} alphaTest The alpha test reference value to control which fragments are
 * written to the currently active render target based on alpha value. All fragments with an alpha
 * value of less than the alphaTest reference value will be discarded. alphaTest defaults to 0 (all
 * fragments pass).
 * @property {boolean} alphaToCoverage Enables or disables alpha to coverage (WebGL2 only). When
 * enabled, and if hardware anti-aliasing is on, limited order-independent transparency can be
 * achieved. Quality depends on the number of MSAA samples of the current render target.
 * It can nicely soften edges of otherwise sharp alpha cutouts, but isn't recommended for large
 * area semi-transparent surfaces. Note, that you don't need to enable blending to make alpha to
 * coverage work. It will work without it, just like alphaTest.
 * @property {boolean} alphaWrite If true, the alpha component of fragments generated by the shader
 * of this material is written to the color buffer of the currently active render target. If false,
 * the alpha component will not be written. Defaults to true.
 * @property {number} blendType Controls how primitives are blended when being written to the
 * currently active render target. Can be:
 *
 * - {@link BLEND_SUBTRACTIVE}: Subtract the color of the source fragment from the destination
 * fragment and write the result to the frame buffer.
 * - {@link BLEND_ADDITIVE}: Add the color of the source fragment to the destination fragment and
 * write the result to the frame buffer.
 * - {@link BLEND_NORMAL}: Enable simple translucency for materials such as glass. This is
 * equivalent to enabling a source blend mode of {@link BLENDMODE_SRC_ALPHA} and a destination
 * blend mode of {@link BLENDMODE_ONE_MINUS_SRC_ALPHA}.
 * - {@link BLEND_NONE}: Disable blending.
 * - {@link BLEND_PREMULTIPLIED}: Similar to {@link BLEND_NORMAL} expect the source fragment is
 * assumed to have already been multiplied by the source alpha value.
 * - {@link BLEND_MULTIPLICATIVE}: Multiply the color of the source fragment by the color of the
 * destination fragment and write the result to the frame buffer.
 * - {@link BLEND_ADDITIVEALPHA}: Same as {@link BLEND_ADDITIVE} except the source RGB is
 * multiplied by the source alpha.
 * - {@link BLEND_MULTIPLICATIVE2X}: Multiplies colors and doubles the result.
 * - {@link BLEND_SCREEN}: Softer version of additive.
 * - {@link BLEND_MIN}: Minimum color. Check app.graphicsDevice.extBlendMinmax for support.
 * - {@link BLEND_MAX}: Maximum color. Check app.graphicsDevice.extBlendMinmax for support.
 *
 * Defaults to {@link BLEND_NONE}.
 * @property {boolean} blueWrite If true, the blue component of fragments generated by the shader
 * of this material is written to the color buffer of the currently active render target. If false,
 * the blue component will not be written. Defaults to true.
 * @property {number} cull Controls how triangles are culled based on their face direction with
 * respect to the viewpoint. Can be:
 *
 * - {@link CULLFACE_NONE}: Do not cull triangles based on face direction.
 * - {@link CULLFACE_BACK}: Cull the back faces of triangles (do not render triangles facing away
 * from the view point).
 * - {@link CULLFACE_FRONT}: Cull the front faces of triangles (do not render triangles facing
 * towards the view point).
 * - {@link CULLFACE_FRONTANDBACK}: Cull both front and back faces (triangles will not be
 * rendered).
 *
 * Defaults to {@link CULLFACE_BACK}.
 * @property {boolean} depthTest If true, fragments generated by the shader of this material are
 * only written to the current render target if they pass the depth test. If false, fragments
 * generated by the shader of this material are written to the current render target regardless of
 * what is in the depth buffer. Defaults to true.
 * @property {number} depthFunc Controls how the depth of new fragments is compared against the
 * current depth contained in the depth buffer. Can be:
 *
 * - {@link FUNC_NEVER}: don't draw
 * - {@link FUNC_LESS}: draw if new depth < depth buffer
 * - {@link FUNC_EQUAL}: draw if new depth == depth buffer
 * - {@link FUNC_LESSEQUAL}: draw if new depth <= depth buffer
 * - {@link FUNC_GREATER}: draw if new depth > depth buffer
 * - {@link FUNC_NOTEQUAL}: draw if new depth != depth buffer
 * - {@link FUNC_GREATEREQUAL}: draw if new depth >= depth buffer
 * - {@link FUNC_ALWAYS}: always draw
 *
 * Defaults to {@link FUNC_LESSEQUAL}.
 * @property {boolean} depthWrite If true, fragments generated by the shader of this material write
 * a depth value to the depth buffer of the currently active render target. If false, no depth
 * value is written. Defaults to true.
 * @property {boolean} greenWrite If true, the green component of fragments generated by the shader
 * of this material is written to the color buffer of the currently active render target. If false,
 * the green component will not be written. Defaults to true.
 * @property {string} name The name of the material.
 * @property {boolean} redWrite If true, the red component of fragments generated by the shader of
 * this material is written to the color buffer of the currently active render target. If false,
 * the red component will not be written. Defaults to true.
 * @property {Shader|null} shader The shader used by this material to render mesh instances
 * (default is null).
 * @property {StencilParameters|null} stencilFront Stencil parameters for front faces (default is
 * null).
 * @property {StencilParameters|null} stencilBack Stencil parameters for back faces (default is
 * null).
 * @property {number} depthBias Offsets the output depth buffer value. Useful for decals to prevent
 * z-fighting.
 * @property {number} slopeDepthBias Same as {@link Material#depthBias}, but also depends on the
 * slope of the triangle relative to the camera.
 */
declare class Material {
    /**
     * A shader used to render the material. Note that this is used only by materials where the user
     * specifies the shader. Most material types generate multiple shader variants, and do not set this.
     *
     * @type {Shader}
     * @private
     */
    private _shader;
    /**
     * The mesh instances referencing this material
     *
     * @type {MeshInstance[]}
     * @private
     */
    private meshInstances;
    name: string;
    id: number;
    variants: {};
    parameters: {};
    alphaTest: number;
    alphaToCoverage: boolean;
    blend: boolean;
    blendSrc: number;
    blendDst: number;
    blendEquation: number;
    separateAlphaBlend: boolean;
    blendSrcAlpha: number;
    blendDstAlpha: number;
    blendAlphaEquation: number;
    cull: number;
    depthTest: boolean;
    depthFunc: number;
    depthWrite: boolean;
    stencilFront: any;
    stencilBack: any;
    depthBias: number;
    slopeDepthBias: number;
    redWrite: boolean;
    greenWrite: boolean;
    blueWrite: boolean;
    alphaWrite: boolean;
    _shaderVersion: number;
    _scene: any;
    _dirtyBlend: boolean;
    dirty: boolean;
    set shader(arg: Shader);
    get shader(): Shader;
    get transparent(): boolean;
    set blendType(arg: number);
    get blendType(): number;
    /**
     * Copy a material.
     *
     * @param {Material} source - The material to copy.
     * @returns {Material} The destination material.
     */
    copy(source: Material): Material;
    /**
     * Clone a material.
     *
     * @returns {this} A newly cloned material.
     */
    clone(): this;
    _updateMeshInstanceKeys(): void;
    updateUniforms(device: any, scene: any): void;
    getShaderVariant(device: any, scene: any, objDefs: any, staticLightList: any, pass: any, sortedLights: any, viewUniformFormat: any, viewBindGroupFormat: any): any;
    /**
     * Applies any changes made to the material's properties.
     */
    update(): void;
    clearParameters(): void;
    getParameters(): {};
    clearVariants(): void;
    /**
     * Retrieves the specified shader parameter from a material.
     *
     * @param {string} name - The name of the parameter to query.
     * @returns {object} The named parameter.
     */
    getParameter(name: string): object;
    /**
     * Sets a shader parameter on a material.
     *
     * @param {string} name - The name of the parameter to set.
     * @param {number|number[]|Float32Array|Texture} data - The value for the specified parameter.
     */
    setParameter(name: string, data: number | number[] | Float32Array | Texture): void;
    /**
     * Deletes a shader parameter on a material.
     *
     * @param {string} name - The name of the parameter to delete.
     */
    deleteParameter(name: string): void;
    setParameters(device: any, names: any): void;
    /**
     * Removes this material from the scene and possibly frees up memory from its shaders (if there
     * are no other materials using it).
     */
    destroy(): void;
    /**
     * Registers mesh instance as referencing the material.
     *
     * @param {MeshInstance} meshInstance - The mesh instance to de-register.
     * @ignore
     */
    addMeshInstanceRef(meshInstance: MeshInstance): void;
    /**
     * De-registers mesh instance as referencing the material.
     *
     * @param {MeshInstance} meshInstance - The mesh instance to de-register.
     * @ignore
     */
    removeMeshInstanceRef(meshInstance: MeshInstance): void;
}


/** @typedef {import('./graph-node.js').GraphNode} GraphNode */
/**
 * A model is a graphical object that can be added to or removed from a scene. It contains a
 * hierarchy and any number of mesh instances.
 */
declare class Model {
    /**
     * The root node of the model's graph node hierarchy.
     *
     * @type {GraphNode}
     */
    graph: GraphNode;
    /**
     * An array of MeshInstances contained in this model.
     *
     * @type {MeshInstance[]}
     */
    meshInstances: MeshInstance[];
    /**
     * An array of SkinInstances contained in this model.
     *
     * @type {SkinInstance[]}
     */
    skinInstances: SkinInstance[];
    /**
     * An array of MorphInstances contained in this model.
     *
     * @type {MorphInstance[]}
     */
    morphInstances: MorphInstance[];
    cameras: any[];
    lights: any[];
    _shadersVersion: number;
    _immutable: boolean;
    getGraph(): GraphNode;
    setGraph(graph: any): void;
    getCameras(): any[];
    setCameras(cameras: any): void;
    getLights(): any[];
    setLights(lights: any): void;
    getMaterials(): Material[];
    /**
     * Clones a model. The returned model has a newly created hierarchy and mesh instances, but
     * meshes are shared between the clone and the specified model.
     *
     * @returns {Model} A clone of the specified model.
     * @example
     * var clonedModel = model.clone();
     */
    clone(): Model;
    /**
     * Destroys skinning texture and possibly deletes vertex/index buffers of a model. Mesh is
     * reference-counted, so buffers are only deleted if all models with referencing mesh instances
     * were deleted. That means all in-scene models + the "base" one (asset.resource) which is
     * created when the model is parsed. It is recommended to use asset.unload() instead, which
     * will also remove the model from the scene.
     */
    destroy(): void;
    /**
     * Generates the necessary internal data for a model to be renderable as wireframe. Once this
     * function has been called, any mesh instance in the model can have its renderStyle property
     * set to {@link RENDERSTYLE_WIREFRAME}.
     *
     * @example
     * model.generateWireframe();
     * for (var i = 0; i < model.meshInstances.length; i++) {
     *     model.meshInstances[i].renderStyle = pc.RENDERSTYLE_WIREFRAME;
     * }
     */
    generateWireframe(): void;
}



/** @typedef {import('../math/vec2.js').Vec2} Vec2 */
/** @typedef {import('../math/vec4.js').Vec4} Vec4 */
/** @typedef {import('../graphics/texture.js').Texture} Texture */
/**
 * A TextureAtlas contains a number of frames from a texture. Each frame defines a region in a
 * texture. The TextureAtlas is referenced by {@link Sprite}s.
 *
 * @augments EventHandler
 */
declare class TextureAtlas extends EventHandler {
    /**
     * @type {Texture}
     * @private
     */
    private _texture;
    /**
     * @type {object}
     * @private
     */
    private _frames;
    /**
     * The texture used by the atlas.
     *
     * @type {Texture}
     */
    set texture(arg: Texture);
    get texture(): Texture;
    /**
     * Contains frames which define portions of the texture atlas.
     *
     * @type {object}
     */
    set frames(arg: any);
    get frames(): any;
    /**
     * Set a new frame in the texture atlas.
     *
     * @param {string} key - The key of the frame.
     * @param {object} data - The properties of the frame.
     * @param {Vec4} data.rect - The u, v, width, height properties of the frame in pixels.
     * @param {Vec2} data.pivot - The pivot of the frame - values are between 0-1.
     * @param {Vec4} data.border - The border of the frame for 9-slicing. Values are ordered as
     * follows: left, bottom, right, top border in pixels.
     * @example
     * atlas.setFrame('1', {
     *     rect: new pc.Vec4(0, 0, 128, 128),
     *     pivot: new pc.Vec2(0.5, 0.5),
     *     border: new pc.Vec4(5, 5, 5, 5)
     * });
     */
    setFrame(key: string, data: {
        rect: Vec4;
        pivot: Vec2;
        border: Vec4;
    }): void;
    /**
     * Removes a frame from the texture atlas.
     *
     * @param {string} key - The key of the frame.
     * @example
     * atlas.removeFrame('1');
     */
    removeFrame(key: string): void;
    /**
     * Free up the underlying texture owned by the atlas.
     */
    destroy(): void;
}



/**
 * A Sprite contains references to one or more frames of a {@link TextureAtlas}. It can be used by
 * the {@link SpriteComponent} or the {@link ElementComponent} to render a single frame or a sprite
 * animation.
 *
 * @augments EventHandler
 */
declare class Sprite extends EventHandler {
    /**
     * Create a new Sprite instance.
     *
     * @param {GraphicsDevice} device - The graphics device of the application.
     * @param {object} [options] - Options for creating the Sprite.
     * @param {number} [options.pixelsPerUnit] - The number of pixels that map to one PlayCanvas
     * unit. Defaults to 1.
     * @param {number} [options.renderMode] - The rendering mode of the sprite. Can be:
     *
     * - {@link SPRITE_RENDERMODE_SIMPLE}
     * - {@link SPRITE_RENDERMODE_SLICED}
     * - {@link SPRITE_RENDERMODE_TILED}
     *
     * Defaults to {@link SPRITE_RENDERMODE_SIMPLE}.
     * @param {TextureAtlas} [options.atlas] - The texture atlas. Defaults to null.
     * @param {string[]} [options.frameKeys] - The keys of the frames in the sprite atlas that this
     * sprite is using. Defaults to null.
     */
    constructor(device: GraphicsDevice, options?: {
        pixelsPerUnit?: number;
        renderMode?: number;
        atlas?: TextureAtlas;
        frameKeys?: string[];
    });
    _device: GraphicsDevice;
    _pixelsPerUnit: number;
    _renderMode: number;
    _atlas: TextureAtlas;
    _frameKeys: string[];
    _meshes: any[];
    _updatingProperties: boolean;
    _meshesDirty: boolean;
    /**
     * The keys of the frames in the sprite atlas that this sprite is using.
     *
     * @type {string[]}
     */
    set frameKeys(arg: string[]);
    get frameKeys(): string[];
    /**
     * The texture atlas.
     *
     * @type {TextureAtlas}
     */
    set atlas(arg: TextureAtlas);
    get atlas(): TextureAtlas;
    /**
     * The number of pixels that map to one PlayCanvas unit.
     *
     * @type {number}
     */
    set pixelsPerUnit(arg: number);
    get pixelsPerUnit(): number;
    /**
     * The rendering mode of the sprite. Can be:
     *
     * - {@link SPRITE_RENDERMODE_SIMPLE}
     * - {@link SPRITE_RENDERMODE_SLICED}
     * - {@link SPRITE_RENDERMODE_TILED}
     *
     * @type {number}
     */
    set renderMode(arg: number);
    get renderMode(): number;
    /**
     * An array that contains a mesh for each frame.
     *
     * @type {Mesh[]}
     */
    get meshes(): Mesh[];
    _createMeshes(): void;
    _createSimpleMesh(frame: any): Mesh;
    _create9SliceMesh(): Mesh;
    _onSetFrames(frames: any): void;
    _onFrameChanged(frameKey: any, frame: any): void;
    _onFrameRemoved(frameKey: any): void;
    startUpdate(): void;
    endUpdate(): void;
    /**
     * Free up the meshes created by the sprite.
     */
    destroy(): void;
}


/** @typedef {import('../../../scene/sprite.js').Sprite} Sprite */
/** @typedef {import('./component.js').SpriteComponent} SpriteComponent */
/**
 * Handles playing of sprite animations and loading of relevant sprite assets.
 *
 * @augments EventHandler
 */
declare class SpriteAnimationClip extends EventHandler {
    /**
     * Create a new SpriteAnimationClip instance.
     *
     * @param {SpriteComponent} component - The sprite component managing this clip.
     * @param {object} data - Data for the new animation clip.
     * @param {number} [data.fps] - Frames per second for the animation clip.
     * @param {boolean} [data.loop] - Whether to loop the animation clip.
     * @param {string} [data.name] - The name of the new animation clip.
     * @param {number} [data.spriteAsset] - The id of the sprite asset that this clip will play.
     */
    constructor(component: SpriteComponent, data: {
        fps?: number;
        loop?: boolean;
        name?: string;
        spriteAsset?: number;
    });
    _component: SpriteComponent;
    _frame: number;
    _sprite: any;
    _spriteAsset: any;
    /**
     * The id of the sprite asset used to play the animation.
     *
     * @type {number}
     */
    set spriteAsset(arg: any);
    get spriteAsset(): any;
    name: string;
    fps: number;
    loop: boolean;
    _playing: boolean;
    _paused: boolean;
    _time: number;
    /**
     * Fired when the clip starts playing.
     *
     * @event SpriteAnimationClip#play
     */
    /**
     * Fired when the clip is paused.
     *
     * @event SpriteAnimationClip#pause
     */
    /**
     * Fired when the clip is resumed.
     *
     * @event SpriteAnimationClip#resume
     */
    /**
     * Fired when the clip is stopped.
     *
     * @event SpriteAnimationClip#stop
     */
    /**
     * Fired when the clip stops playing because it reached its ending.
     *
     * @event SpriteAnimationClip#end
     */
    /**
     * Fired when the clip reached the end of its current loop.
     *
     * @event SpriteAnimationClip#loop
     */
    /**
     * The total duration of the animation in seconds.
     *
     * @type {number}
     */
    get duration(): number;
    /**
     * The index of the frame of the {@link Sprite} currently being rendered.
     *
     * @type {number}
     */
    set frame(arg: number);
    get frame(): number;
    /**
     * Whether the animation is currently paused.
     *
     * @type {boolean}
     */
    get isPaused(): boolean;
    /**
     * Whether the animation is currently playing.
     *
     * @type {boolean}
     */
    get isPlaying(): boolean;
    /**
     * The current sprite used to play the animation.
     *
     * @type {Sprite}
     */
    set sprite(arg: any);
    get sprite(): any;
    /**
     * The current time of the animation in seconds.
     *
     * @type {number}
     */
    set time(arg: number);
    get time(): number;
    _onSpriteAssetAdded(asset: any): void;
    _bindSpriteAsset(asset: any): void;
    _unbindSpriteAsset(asset: any): void;
    _onSpriteAssetLoad(asset: any): void;
    _onTextureAtlasLoad(atlasAsset: any): void;
    _onSpriteAssetRemove(asset: any): void;
    _onSpriteMeshesChange(): void;
    _onSpritePpuChanged(): void;
    /**
     * Advances the animation, looping if necessary.
     *
     * @param {number} dt - The delta time.
     * @private
     */
    private _update;
    _setTime(value: any): void;
    _setFrame(value: any): void;
    _destroy(): void;
    /**
     * Plays the animation. If it's already playing then this does nothing.
     */
    play(): void;
    /**
     * Pauses the animation.
     */
    pause(): void;
    /**
     * Resumes the paused animation.
     */
    resume(): void;
    /**
     * Stops the animation and resets the animation to the first frame.
     */
    stop(): void;
}




/**
 * Enables an Entity to render a simple static sprite or sprite animations.
 *
 * @augments Component
 */
declare class SpriteComponent extends Component {
    /**
     * Create a new SpriteComponent instance.
     *
     * @param {SpriteComponentSystem} system - The ComponentSystem that created this Component.
     * @param {Entity} entity - The Entity that this Component is attached to.
     */
    constructor(system: SpriteComponentSystem, entity: Entity);
    _type: string;
    _material: any;
    _color: Color;
    _colorUniform: Float32Array;
    _speed: number;
    _flipX: boolean;
    _flipY: boolean;
    _width: number;
    _height: number;
    _drawOrder: number;
    _layers: number[];
    _outerScale: Vec2;
    _outerScaleUniform: Float32Array;
    _innerOffset: Vec4;
    _innerOffsetUniform: Float32Array;
    _atlasRect: Vec4;
    _atlasRectUniform: Float32Array;
    _batchGroupId: number;
    _batchGroup: any;
    _node: GraphNode;
    _model: Model;
    _meshInstance: MeshInstance;
    _updateAabbFunc: any;
    _addedModel: boolean;
    _autoPlayClip: any;
    /**
     * Dictionary of sprite animation clips.
     *
     * @type {Object<string, SpriteAnimationClip>}
     * @private
     */
    private _clips;
    _defaultClip: SpriteAnimationClip;
    /**
     * The sprite animation clip currently playing.
     *
     * @type {SpriteAnimationClip}
     * @private
     */
    private _currentClip;
    /**
     * Fired when an animation clip starts playing.
     *
     * @event SpriteComponent#play
     * @param {SpriteAnimationClip} clip - The clip that started playing.
     */
    /**
     * Fired when an animation clip is paused.
     *
     * @event SpriteComponent#pause
     * @param {SpriteAnimationClip} clip - The clip that was paused.
     */
    /**
     * Fired when an animation clip is resumed.
     *
     * @event SpriteComponent#resume
     * @param {SpriteAnimationClip} clip - The clip that was resumed.
     */
    /**
     * Fired when an animation clip is stopped.
     *
     * @event SpriteComponent#stop
     * @param {SpriteAnimationClip} clip - The clip that was stopped.
     */
    /**
     * Fired when an animation clip stops playing because it reached its ending.
     *
     * @event SpriteComponent#end
     * @param {SpriteAnimationClip} clip - The clip that ended.
     */
    /**
     * Fired when an animation clip reached the end of its current loop.
     *
     * @event SpriteComponent#loop
     * @param {SpriteAnimationClip} clip - The clip.
     */
    /**
     * The type of the SpriteComponent. Can be:
     *
     * - {@link SPRITETYPE_SIMPLE}: The component renders a single frame from a sprite asset.
     * - {@link SPRITETYPE_ANIMATED}: The component can play sprite animation clips.
     *
     * Defaults to {@link SPRITETYPE_SIMPLE}.
     *
     * @type {string}
     */
    set type(arg: string);
    get type(): string;
    /**
     * The frame counter of the sprite. Specifies which frame from the current sprite asset to
     * render.
     *
     * @type {number}
     */
    set frame(arg: number);
    get frame(): number;
    /**
     * The asset id or the {@link Asset} of the sprite to render. Only works for
     * {@link SPRITETYPE_SIMPLE} sprites.
     *
     * @type {number|Asset}
     */
    set spriteAsset(arg: any);
    get spriteAsset(): any;
    /**
     * The current sprite.
     *
     * @type {Sprite}
     */
    set sprite(arg: any);
    get sprite(): any;
    set material(arg: any);
    get material(): any;
    /**
     * The color tint of the sprite.
     *
     * @type {Color}
     */
    set color(arg: Color);
    get color(): Color;
    /**
     * The opacity of the sprite.
     *
     * @type {number}
     */
    set opacity(arg: number);
    get opacity(): number;
    /**
     * A dictionary that contains {@link SpriteAnimationClip}s.
     *
     * @type {Object<string, SpriteAnimationClip>}
     */
    set clips(arg: {
        [x: string]: SpriteAnimationClip;
    });
    get clips(): {
        [x: string]: SpriteAnimationClip;
    };
    /**
     * The current clip being played.
     *
     * @type {SpriteAnimationClip}
     */
    get currentClip(): SpriteAnimationClip;
    /**
     * A global speed modifier used when playing sprite animation clips.
     *
     * @type {number}
     */
    set speed(arg: number);
    get speed(): number;
    /**
     * Flip the X axis when rendering a sprite.
     *
     * @type {boolean}
     */
    set flipX(arg: boolean);
    get flipX(): boolean;
    /**
     * Flip the Y axis when rendering a sprite.
     *
     * @type {boolean}
     */
    set flipY(arg: boolean);
    get flipY(): boolean;
    /**
     * The width of the sprite when rendering using 9-Slicing. The width and height are only used
     * when the render mode of the sprite asset is Sliced or Tiled.
     *
     * @type {number}
     */
    set width(arg: number);
    get width(): number;
    /**
     * The height of the sprite when rendering using 9-Slicing. The width and height are only used
     * when the render mode of the sprite asset is Sliced or Tiled.
     *
     * @type {number}
     */
    set height(arg: number);
    get height(): number;
    /**
     * Assign sprite to a specific batch group (see {@link BatchGroup}). Default is -1 (no group).
     *
     * @type {number}
     */
    set batchGroupId(arg: number);
    get batchGroupId(): number;
    /**
     * The name of the clip to play automatically when the component is enabled and the clip exists.
     *
     * @type {string}
     */
    set autoPlayClip(arg: any);
    get autoPlayClip(): any;
    /**
     * The draw order of the component. A higher value means that the component will be rendered on
     * top of other components in the same layer. This is not used unless the layer's sort order is
     * set to {@link SORTMODE_MANUAL}.
     *
     * @type {number}
     */
    set drawOrder(arg: number);
    get drawOrder(): number;
    /**
     * An array of layer IDs ({@link Layer#id}) to which this sprite should belong.
     *
     * @type {number[]}
     */
    set layers(arg: number[]);
    get layers(): number[];
    get aabb(): any;
    onDestroy(): void;
    _showModel(): void;
    _hideModel(): void;
    _showFrame(frame: any): void;
    _updateTransform(): void;
    _updateAabb(aabb: any): any;
    _tryAutoPlay(): void;
    _onLayersChanged(oldComp: any, newComp: any): void;
    _onLayerAdded(layer: any): void;
    _onLayerRemoved(layer: any): void;
    removeModelFromLayers(): void;
    /**
     * Creates and adds a new {@link SpriteAnimationClip} to the component's clips.
     *
     * @param {object} data - Data for the new animation clip.
     * @param {string} [data.name] - The name of the new animation clip.
     * @param {number} [data.fps] - Frames per second for the animation clip.
     * @param {boolean} [data.loop] - Whether to loop the animation clip.
     * @param {number|Asset} [data.spriteAsset] - The asset id or the {@link Asset} of the sprite
     * that this clip will play.
     * @returns {SpriteAnimationClip} The new clip that was added.
     */
    addClip(data: {
        name?: string;
        fps?: number;
        loop?: boolean;
        spriteAsset?: number | Asset;
    }): SpriteAnimationClip;
    /**
     * Removes a clip by name.
     *
     * @param {string} name - The name of the animation clip to remove.
     */
    removeClip(name: string): void;
    /**
     * Get an animation clip by name.
     *
     * @param {string} name - The name of the clip.
     * @returns {SpriteAnimationClip} The clip.
     */
    clip(name: string): SpriteAnimationClip;
    /**
     * Plays a sprite animation clip by name. If the animation clip is already playing then this
     * will do nothing.
     *
     * @param {string} name - The name of the clip to play.
     * @returns {SpriteAnimationClip} The clip that started playing.
     */
    play(name: string): SpriteAnimationClip;
    /**
     * Pauses the current animation clip.
     */
    pause(): void;
    /**
     * Resumes the current paused animation clip.
     */
    resume(): void;
    /**
     * Stops the current animation clip and resets it to the first frame.
     */
    stop(): void;
}

declare class SoundComponentData {
    enabled: boolean;
}


/**
 * Manages creation of {@link SoundComponent}s.
 *
 * @augments ComponentSystem
 * @ignore
 */
declare class SoundComponentSystem extends ComponentSystem {
    id: string;
    ComponentType: typeof SoundComponent;
    DataType: typeof SoundComponentData;
    schema: string[];
    /**
     * Gets / sets the sound manager.
     *
     * @type {SoundManager}
     */
    manager: SoundManager;
    /**
     * Sets / gets the volume for the entire Sound system. All sounds will have their volume
     * multiplied by this value. Valid between [0, 1].
     *
     * @type {number}
     */
    set volume(arg: number);
    get volume(): number;
    /**
     * Gets the AudioContext currently used by the sound manager. Requires Web Audio API support.
     * Returns null if the device does not support the Web Audio API.
     *
     * @type {AudioContext|null}
     */
    get context(): AudioContext;
    initializeComponentData(component: any, data: any, properties: any): void;
    cloneComponent(entity: any, clone: any): Component;
    onUpdate(dt: any): void;
    onBeforeRemove(entity: any, component: any): void;
}

/**
 * Represents the resource of an audio asset.
 */
declare class Sound {
    /**
     * Create a new Sound instance.
     *
     * @param {HTMLAudioElement|AudioBuffer} resource - If the Web Audio API is supported, pass an
     * AudioBuffer object, otherwise an Audio object.
     */
    constructor(resource: HTMLAudioElement | AudioBuffer);
    /**
     * If the Web Audio API is not supported this contains the audio data.
     *
     * @type {HTMLAudioElement}
     */
    audio: HTMLAudioElement;
    /**
     * If the Web Audio API is supported this contains the audio data.
     *
     * @type {AudioBuffer}
     */
    buffer: AudioBuffer;
    /**
     * Gets the duration of the sound. If the sound is not loaded it returns 0.
     *
     * @type {number}
     */
    get duration(): number;
}



/**
 * A SoundInstance plays a {@link Sound}.
 *
 * @augments EventHandler
 */
declare class SoundInstance extends EventHandler {
    /**
     * Create a new SoundInstance instance.
     *
     * @param {SoundManager} manager - The sound manager.
     * @param {Sound} sound - The sound to play.
     * @param {object} options - Options for the instance.
     * @param {number} [options.volume=1] - The playback volume, between 0 and 1.
     * @param {number} [options.pitch=1] - The relative pitch, default of 1, plays at normal pitch.
     * @param {boolean} [options.loop=false] - Whether the sound should loop when it reaches the
     * end or not.
     * @param {number} [options.startTime=0] - The time from which the playback will start in
     * seconds. Default is 0 to start at the beginning.
     * @param {number} [options.duration=0] - The total time after the startTime in seconds when
     * playback will stop or restart if loop is true.
     * @param {Function} [options.onPlay=null] - Function called when the instance starts playing.
     * @param {Function} [options.onPause=null] - Function called when the instance is paused.
     * @param {Function} [options.onResume=null] - Function called when the instance is resumed.
     * @param {Function} [options.onStop=null] - Function called when the instance is stopped.
     * @param {Function} [options.onEnd=null] - Function called when the instance ends.
     */
    constructor(manager: SoundManager, sound: Sound, options: {
        volume?: number;
        pitch?: number;
        loop?: boolean;
        startTime?: number;
        duration?: number;
        onPlay?: Function;
        onPause?: Function;
        onResume?: Function;
        onStop?: Function;
        onEnd?: Function;
    });
    /**
     * Gets the source that plays the sound resource. If the Web Audio API is not supported the
     * type of source is [Audio](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio).
     * Source is only available after calling play.
     *
     * @type {AudioBufferSourceNode}
     */
    source: AudioBufferSourceNode;
    /**
     * @type {SoundManager}
     * @private
     */
    private _manager;
    /**
     * @type {number}
     * @private
     */
    private _volume;
    /**
     * @type {number}
     * @private
     */
    private _pitch;
    /**
     * @type {boolean}
     * @private
     */
    private _loop;
    /**
     * @type {Sound}
     * @private
     */
    private _sound;
    /**
     * Start at 'stopped'.
     *
     * @type {number}
     * @private
     */
    private _state;
    /**
     * True if the manager was suspended.
     *
     * @type {boolean}
     * @private
     */
    private _suspended;
    /**
     * Greater than 0 if we want to suspend the event handled to the 'onended' event.
     * When an 'onended' event is suspended, this counter is decremented by 1.
     * When a future 'onended' event is to be suspended, this counter is incremented by 1.
     *
     * @type {number}
     * @private
     */
    private _suspendEndEvent;
    /**
     * True if we want to suspend firing instance events.
     *
     * @type {boolean}
     * @private
     */
    private _suspendInstanceEvents;
    /**
     * If true then the instance will start playing its source when its created.
     *
     * @type {boolean}
     * @private
     */
    private _playWhenLoaded;
    /**
     * @type {number}
     * @private
     */
    private _startTime;
    /**
     * @type {number}
     * @private
     */
    private _duration;
    /**
     * @type {number|null}
     * @private
     */
    private _startOffset;
    /** @private */
    private _onPlayCallback;
    /** @private */
    private _onPauseCallback;
    /** @private */
    private _onResumeCallback;
    /** @private */
    private _onStopCallback;
    /** @private */
    private _onEndCallback;
    /**
     * @type {number}
     * @private
     */
    private _startedAt;
    /**
     * Manually keep track of the playback position because the Web Audio API does not
     * provide a way to do this accurately if the playbackRate is not 1.
     *
     * @type {number}
     * @private
     */
    private _currentTime;
    /**
     * @type {number}
     * @private
     */
    private _currentOffset;
    /**
     * The input node is the one that is connected to the source.
     *
     * @type {AudioNode|null}
     * @private
     */
    private _inputNode;
    /**
     * The connected node is the one that is connected to the destination (speakers). Any
     * external nodes will be connected to this node.
     *
     * @type {AudioNode|null}
     * @private
     */
    private _connectorNode;
    /**
     * The first external node set by a user.
     *
     * @type {AudioNode|null}
     * @private
     */
    private _firstNode;
    /**
     * The last external node set by a user.
     *
     * @type {AudioNode|null}
     * @private
     */
    private _lastNode;
    /** @private */
    private _endedHandler;
    /** @private */
    private _isReady;
    /** @private */
    private _loadedMetadataHandler;
    /** @private */
    private _timeUpdateHandler;
    /**
     * Fired when the instance starts playing its source.
     *
     * @event SoundInstance#play
     */
    /**
     * Fired when the instance is paused.
     *
     * @event SoundInstance#pause
     */
    /**
     * Fired when the instance is resumed.
     *
     * @event SoundInstance#resume
     */
    /**
     * Fired when the instance is stopped.
     *
     * @event SoundInstance#stop
     */
    /**
     * Fired when the sound currently played by the instance ends.
     *
     * @event SoundInstance#end
     */
    /**
     * Gets or sets the current time of the sound that is playing. If the value provided is bigger
     * than the duration of the instance it will wrap from the beginning.
     *
     * @type {number}
     */
    set currentTime(arg: number);
    get currentTime(): number;
    /**
     * The duration of the sound that the instance will play starting from startTime.
     *
     * @type {number}
     */
    set duration(arg: number);
    get duration(): number;
    /**
     * Returns true if the instance is currently paused.
     *
     * @type {boolean}
     */
    get isPaused(): boolean;
    /**
     * Returns true if the instance is currently playing.
     *
     * @type {boolean}
     */
    get isPlaying(): boolean;
    /**
     * Returns true if the instance is currently stopped.
     *
     * @type {boolean}
     */
    get isStopped(): boolean;
    /**
     * Returns true if the instance is currently suspended because the window is not focused.
     *
     * @type {boolean}
     */
    get isSuspended(): boolean;
    /**
     * If true the instance will restart when it finishes playing.
     *
     * @type {boolean}
     */
    set loop(arg: boolean);
    get loop(): boolean;
    /**
     * The pitch modifier to play the sound with. Must be larger than 0.01.
     *
     * @type {number}
     */
    set pitch(arg: number);
    get pitch(): number;
    /**
     * The sound resource that the instance will play.
     *
     * @type {Sound}
     */
    set sound(arg: Sound);
    get sound(): Sound;
    /**
     * The start time from which the sound will start playing.
     *
     * @type {number}
     */
    set startTime(arg: number);
    get startTime(): number;
    /**
     * The volume modifier to play the sound with. In range 0-1.
     *
     * @type {number}
     */
    set volume(arg: number);
    get volume(): number;
    /** @private */
    private _onPlay;
    /** @private */
    private _onPause;
    /** @private */
    private _onResume;
    /** @private */
    private _onStop;
    /** @private */
    private _onEnded;
    /**
     * Handle the manager's 'volumechange' event.
     *
     * @private
     */
    private _onManagerVolumeChange;
    /**
     * Handle the manager's 'suspend' event.
     *
     * @private
     */
    private _onManagerSuspend;
    /**
     * Handle the manager's 'resume' event.
     *
     * @private
     */
    private _onManagerResume;
    /**
     * Creates internal audio nodes and connects them.
     *
     * @private
     */
    private _initializeNodes;
    gain: GainNode;
    /**
     * Begins playback of sound. If the sound is not loaded this will return false. If the sound is
     * already playing this will restart the sound.
     *
     * @returns {boolean} True if the sound was started.
     */
    play(): boolean;
    /**
     * Pauses playback of sound. Call resume() to resume playback from the same position.
     *
     * @returns {boolean} Returns true if the sound was paused.
     */
    pause(): boolean;
    /**
     * Resumes playback of the sound. Playback resumes at the point that the audio was paused.
     *
     * @returns {boolean} Returns true if the sound was resumed.
     */
    resume(): boolean;
    /**
     * Stops playback of sound. Calling play() again will restart playback from the beginning of
     * the sound.
     *
     * @returns {boolean} Returns true if the sound was stopped.
     */
    stop(): boolean;
    /**
     * Connects external Web Audio API nodes. You need to pass the first node of the node graph
     * that you created externally and the last node of that graph. The first node will be
     * connected to the audio source and the last node will be connected to the destination of the
     * AudioContext (e.g. speakers). Requires Web Audio API support.
     *
     * @param {AudioNode} firstNode - The first node that will be connected to the audio source of sound instances.
     * @param {AudioNode} [lastNode] - The last node that will be connected to the destination of the AudioContext.
     * If unspecified then the firstNode will be connected to the destination instead.
     * @example
     * var context = app.systems.sound.context;
     * var analyzer = context.createAnalyzer();
     * var distortion = context.createWaveShaper();
     * var filter = context.createBiquadFilter();
     * analyzer.connect(distortion);
     * distortion.connect(filter);
     * instance.setExternalNodes(analyzer, filter);
     */
    setExternalNodes(firstNode: AudioNode, lastNode?: AudioNode): void;
    /**
     * Clears any external nodes set by {@link SoundInstance#setExternalNodes}.
     */
    clearExternalNodes(): void;
    /**
     * Gets any external nodes set by {@link SoundInstance#setExternalNodes}.
     *
     * @returns {AudioNode[]} Returns an array that contains the two nodes set by
     * {@link SoundInstance#setExternalNodes}.
     */
    getExternalNodes(): AudioNode[];
    /**
     * Creates the source for the instance.
     *
     * @returns {AudioBufferSourceNode|null} Returns the created source or null if the sound
     * instance has no {@link Sound} associated with it.
     * @private
     */
    private _createSource;
    /**
     * Sets the current time taking into account the time the instance started playing, the current
     * pitch and the current time offset.
     *
     * @private
     */
    private _updateCurrentTime;
    /**
     * Handle the manager's 'destroy' event.
     *
     * @private
     */
    private _onManagerDestroy;
}


/**
 * The SoundSlot controls playback of an audio asset.
 *
 * @augments EventHandler
 */
declare class SoundSlot extends EventHandler {
    /**
     * Create a new SoundSlot.
     *
     * @param {SoundComponent} component - The Component that created this slot.
     * @param {string} [name] - The name of the slot. Defaults to 'Untitled'.
     * @param {object} [options] - Settings for the slot.
     * @param {number} [options.volume=1] - The playback volume, between 0 and 1.
     * @param {number} [options.pitch=1] - The relative pitch, default of 1, plays at normal pitch.
     * @param {boolean} [options.loop=false] - If true the sound will restart when it reaches the
     * end.
     * @param {number} [options.startTime=0] - The start time from which the sound will start
     * playing.
     * @param {number} [options.duration=null] - The duration of the sound that the slot will play
     * starting from startTime.
     * @param {boolean} [options.overlap=false] - If true then sounds played from slot will be
     * played independently of each other. Otherwise the slot will first stop the current sound
     * before starting the new one.
     * @param {boolean} [options.autoPlay=false] - If true the slot will start playing as soon as
     * its audio asset is loaded.
     * @param {number} [options.asset=null] - The asset id of the audio asset that is going to be
     * played by this slot.
     */
    constructor(component: SoundComponent, name?: string, options?: {
        volume?: number;
        pitch?: number;
        loop?: boolean;
        startTime?: number;
        duration?: number;
        overlap?: boolean;
        autoPlay?: boolean;
        asset?: number;
    });
    /**
     * The name of the slot.
     *
     * @type {string}
     */
    name: string;
    /**
     * An array that contains all the {@link SoundInstance}s currently being played by the slot.
     *
     * @type {SoundInstance[]}
     */
    instances: SoundInstance[];
    _component: SoundComponent;
    _assets: AssetRegistry;
    _manager: any;
    _volume: number;
    _pitch: number;
    _loop: boolean;
    _duration: number;
    _startTime: number;
    _overlap: boolean;
    _autoPlay: boolean;
    _firstNode: AudioNode;
    _lastNode: AudioNode;
    _asset: number;
    _onInstancePlayHandler: any;
    _onInstancePauseHandler: any;
    _onInstanceResumeHandler: any;
    _onInstanceStopHandler: any;
    _onInstanceEndHandler: any;
    /**
     * Fired when a sound instance starts playing.
     *
     * @event SoundSlot#play
     * @param {SoundInstance} instance - The instance that started playing.
     */
    /**
     * Fired when a sound instance is paused.
     *
     * @event SoundSlot#pause
     * @param {SoundInstance} instance - The instance that was paused created to play the sound.
     */
    /**
     * Fired when a sound instance is resumed.
     *
     * @event SoundSlot#resume
     * @param {SoundInstance} instance - The instance that was resumed.
     */
    /**
     * Fired when a sound instance is stopped.
     *
     * @event SoundSlot#stop
     * @param {SoundInstance} instance - The instance that was stopped.
     */
    /**
     * Fired when the asset assigned to the slot is loaded.
     *
     * @event SoundSlot#load
     * @param {Sound} sound - The sound resource that was loaded.
     */
    /**
     * Plays a sound. If {@link SoundSlot#overlap} is true the new sound instance will be played
     * independently of any other instances already playing. Otherwise existing sound instances
     * will stop before playing the new sound.
     *
     * @returns {SoundInstance} The new sound instance.
     */
    play(): SoundInstance;
    /**
     * Pauses all sound instances. To continue playback call {@link SoundSlot#resume}.
     *
     * @returns {boolean} True if the sound instances paused successfully, false otherwise.
     */
    pause(): boolean;
    /**
     * Resumes playback of all paused sound instances.
     *
     * @returns {boolean} True if any instances were resumed.
     */
    resume(): boolean;
    /**
     * Stops playback of all sound instances.
     *
     * @returns {boolean} True if any instances were stopped.
     */
    stop(): boolean;
    /**
     * Loads the asset assigned to this slot.
     */
    load(): void;
    /**
     * Connect external Web Audio API nodes. Any sound played by this slot will automatically
     * attach the specified nodes to the source that plays the sound. You need to pass the first
     * node of the node graph that you created externally and the last node of that graph. The
     * first node will be connected to the audio source and the last node will be connected to the
     * destination of the AudioContext (e.g. speakers).
     *
     * @param {AudioNode} firstNode - The first node that will be connected to the audio source of
     * sound instances.
     * @param {AudioNode} [lastNode] - The last node that will be connected to the destination of
     * the AudioContext. If unspecified then the firstNode will be connected to the destination
     * instead.
     * @example
     * var context = app.systems.sound.context;
     * var analyzer = context.createAnalyzer();
     * var distortion = context.createWaveShaper();
     * var filter = context.createBiquadFilter();
     * analyzer.connect(distortion);
     * distortion.connect(filter);
     * slot.setExternalNodes(analyzer, filter);
     */
    setExternalNodes(firstNode: AudioNode, lastNode?: AudioNode): void;
    /**
     * Clears any external nodes set by {@link SoundSlot#setExternalNodes}.
     */
    clearExternalNodes(): void;
    /**
     * Gets an array that contains the two external nodes set by {@link SoundSlot#setExternalNodes}.
     *
     * @returns {AudioNode[]} An array of 2 elements that contains the first and last nodes set by
     * {@link SoundSlot#setExternalNodes}.
     */
    getExternalNodes(): AudioNode[];
    /**
     * Reports whether an asset is set on this slot.
     *
     * @returns {boolean} Returns true if the slot has an asset assigned.
     * @private
     */
    private _hasAsset;
    /**
     * Creates a new {@link SoundInstance} with the properties of the slot.
     *
     * @returns {SoundInstance} The new instance.
     * @private
     */
    private _createInstance;
    _onInstancePlay(instance: any): void;
    _onInstancePause(instance: any): void;
    _onInstanceResume(instance: any): void;
    _onInstanceStop(instance: any): void;
    _onInstanceEnd(instance: any): void;
    _onAssetAdd(asset: any): void;
    _onAssetLoad(asset: any): void;
    _onAssetRemoved(asset: any): void;
    updatePosition(position: any): void;
    /**
     * The asset id.
     *
     * @type {number|null}
     */
    set asset(arg: number);
    get asset(): number;
    /**
     * If true the slot will begin playing as soon as it is loaded.
     *
     * @type {boolean}
     */
    set autoPlay(arg: boolean);
    get autoPlay(): boolean;
    /**
     * The duration of the sound that the slot will play starting from startTime.
     *
     * @type {number}
     */
    set duration(arg: number);
    get duration(): number;
    /**
     * Returns true if the asset of the slot is loaded.
     *
     * @type {boolean}
     */
    get isLoaded(): boolean;
    /**
     * Returns true if the slot is currently paused.
     *
     * @type {boolean}
     */
    get isPaused(): boolean;
    /**
     * Returns true if the slot is currently playing.
     *
     * @type {boolean}
     */
    get isPlaying(): boolean;
    /**
     * Returns true if the slot is currently stopped.
     *
     * @type {boolean}
     */
    get isStopped(): boolean;
    /**
     * If true the slot will restart when it finishes playing.
     *
     * @type {boolean}
     */
    set loop(arg: boolean);
    get loop(): boolean;
    /**
     * If true then sounds played from slot will be played independently of each other. Otherwise
     * the slot will first stop the current sound before starting the new one.
     *
     * @type {boolean}
     */
    set overlap(arg: boolean);
    get overlap(): boolean;
    /**
     * The pitch modifier to play the sound with. Must be larger than 0.01.
     *
     * @type {number}
     */
    set pitch(arg: number);
    get pitch(): number;
    /**
     * The start time from which the sound will start playing.
     *
     * @type {number}
     */
    set startTime(arg: number);
    get startTime(): number;
    /**
     * The volume modifier to play the sound with. In range 0-1.
     *
     * @type {number}
     */
    set volume(arg: number);
    get volume(): number;
}




/** @typedef {import('../../entity.js').Entity} Entity */
/** @typedef {import('../../../sound/instance.js').SoundInstance} SoundInstance */
/** @typedef {import('./system.js').SoundComponentSystem} SoundComponentSystem */
/**
 * The Sound Component controls playback of {@link Sound}s.
 *
 * @augments Component
 */
declare class SoundComponent extends Component {
    /**
     * Create a new Sound Component.
     *
     * @param {SoundComponentSystem} system - The ComponentSystem that created this component.
     * @param {Entity} entity - The entity that the Component is attached to.
     */
    constructor(system: SoundComponentSystem, entity: Entity);
    /** @private */
    private _volume;
    /** @private */
    private _pitch;
    /** @private */
    private _positional;
    /** @private */
    private _refDistance;
    /** @private */
    private _maxDistance;
    /** @private */
    private _rollOffFactor;
    /** @private */
    private _distanceModel;
    /**
     * @type {Object<string, SoundSlot>}
     * @private
     */
    private _slots;
    /** @private */
    private _playingBeforeDisable;
    /**
     * Fired when a sound instance starts playing.
     *
     * @event SoundComponent#play
     * @param {SoundSlot} slot - The slot whose instance started playing.
     * @param {SoundInstance} instance - The instance that started playing.
     */
    /**
     * Fired when a sound instance is paused.
     *
     * @event SoundComponent#pause
     * @param {SoundSlot} slot - The slot whose instance was paused.
     * @param {SoundInstance} instance - The instance that was paused created to play the sound.
     */
    /**
     * Fired when a sound instance is resumed.
     *
     * @event SoundComponent#resume
     * @param {SoundSlot} slot - The slot whose instance was resumed.
     * @param {SoundInstance} instance - The instance that was resumed.
     */
    /**
     * Fired when a sound instance is stopped.
     *
     * @event SoundComponent#stop
     * @param {SoundSlot} slot - The slot whose instance was stopped.
     * @param {SoundInstance} instance - The instance that was stopped.
     */
    /**
     * Fired when a sound instance stops playing because it reached its ending.
     *
     * @event SoundComponent#end
     * @param {SoundSlot} slot - The slot whose instance ended.
     * @param {SoundInstance} instance - The instance that ended.
     */
    /**
     * Update the specified property on all sound instances.
     *
     * @param {string} property - The name of the SoundInstance property to update.
     * @param {string|number} value - The value to set the property to.
     * @param {boolean} isFactor - True if the value is a factor of the slot property or false
     * if it is an absolute value.
     * @private
     */
    private _updateSoundInstances;
    /**
     * Determines which algorithm to use to reduce the volume of the sound as it moves away from
     * the listener. Can be:
     *
     * - {@link DISTANCE_LINEAR}
     * - {@link DISTANCE_INVERSE}
     * - {@link DISTANCE_EXPONENTIAL}
     *
     * Defaults to {@link DISTANCE_LINEAR}.
     *
     * @type {string}
     */
    set distanceModel(arg: string);
    get distanceModel(): string;
    /**
     * The maximum distance from the listener at which audio falloff stops. Note the volume of the
     * audio is not 0 after this distance, but just doesn't fall off anymore. Defaults to 10000.
     *
     * @type {number}
     */
    set maxDistance(arg: number);
    get maxDistance(): number;
    /**
     * The reference distance for reducing volume as the sound source moves further from the
     * listener. Defaults to 1.
     *
     * @type {number}
     */
    set refDistance(arg: number);
    get refDistance(): number;
    /**
     * The factor used in the falloff equation. Defaults to 1.
     *
     * @type {number}
     */
    set rollOffFactor(arg: number);
    get rollOffFactor(): number;
    /**
     * The pitch modifier to play the audio with. Must be larger than 0.01. Defaults to 1.
     *
     * @type {number}
     */
    set pitch(arg: number);
    get pitch(): number;
    /**
     * The volume modifier to play the audio with. In range 0-1. Defaults to 1.
     *
     * @type {number}
     */
    set volume(arg: number);
    get volume(): number;
    /**
     * If true the audio will play back at the location of the Entity in space, so the audio will
     * be affected by the position of the {@link AudioListenerComponent}. Defaults to true.
     *
     * @type {boolean}
     */
    set positional(arg: boolean);
    get positional(): boolean;
    /**
     * A dictionary that contains the {@link SoundSlot}s managed by this SoundComponent.
     *
     * @type {Object<string, SoundSlot>}
     */
    set slots(arg: {
        [x: string]: SoundSlot;
    });
    get slots(): {
        [x: string]: SoundSlot;
    };
    onRemove(): void;
    /**
     * Creates a new {@link SoundSlot} with the specified name.
     *
     * @param {string} name - The name of the slot.
     * @param {object} [options] - Settings for the slot.
     * @param {number} [options.volume=1] - The playback volume, between 0 and 1.
     * @param {number} [options.pitch=1] - The relative pitch, default of 1, plays at normal pitch.
     * @param {boolean} [options.loop=false] - If true the sound will restart when it reaches the end.
     * @param {number} [options.startTime=0] - The start time from which the sound will start playing.
     * @param {number} [options.duration=null] - The duration of the sound that the slot will play
     * starting from startTime.
     * @param {boolean} [options.overlap=false] - If true then sounds played from slot will be
     * played independently of each other. Otherwise the slot will first stop the current sound
     * before starting the new one.
     * @param {boolean} [options.autoPlay=false] - If true the slot will start playing as soon as
     * its audio asset is loaded.
     * @param {number} [options.asset=null] - The asset id of the audio asset that is going to be
     * played by this slot.
     * @returns {SoundSlot|null} The new slot or null if the slot already exists.
     * @example
     * // get an asset by id
     * var asset = app.assets.get(10);
     * // add a slot
     * this.entity.sound.addSlot('beep', {
     *     asset: asset
     * });
     * // play
     * this.entity.sound.play('beep');
     */
    addSlot(name: string, options?: {
        volume?: number;
        pitch?: number;
        loop?: boolean;
        startTime?: number;
        duration?: number;
        overlap?: boolean;
        autoPlay?: boolean;
        asset?: number;
    }): SoundSlot | null;
    /**
     * Removes the {@link SoundSlot} with the specified name.
     *
     * @param {string} name - The name of the slot.
     * @example
     * // remove a slot called 'beep'
     * this.entity.sound.removeSlot('beep');
     */
    removeSlot(name: string): void;
    /**
     * Returns the slot with the specified name.
     *
     * @param {string} name - The name of the slot.
     * @returns {SoundSlot|undefined} The slot.
     * @example
     * // get a slot and set its volume
     * this.entity.sound.slot('beep').volume = 0.5;
     *
     */
    slot(name: string): SoundSlot | undefined;
    /**
     * Begins playing the sound slot with the specified name. The slot will restart playing if it
     * is already playing unless the overlap field is true in which case a new sound will be
     * created and played.
     *
     * @param {string} name - The name of the {@link SoundSlot} to play.
     * @returns {SoundInstance|null} The sound instance that will be played. Returns null if the
     * component or its parent entity is disabled or if the SoundComponent has no slot with the
     * specified name.
     * @example
     * // get asset by id
     * var asset = app.assets.get(10);
     * // create a slot and play it
     * this.entity.sound.addSlot('beep', {
     *     asset: asset
     * });
     * this.entity.sound.play('beep');
     */
    play(name: string): SoundInstance | null;
    /**
     * Pauses playback of the slot with the specified name. If the name is undefined then all slots
     * currently played will be paused. The slots can be resumed by calling {@link SoundComponent#resume}.
     *
     * @param {string} [name] - The name of the slot to pause. Leave undefined to pause everything.
     * @example
     * // pause all sounds
     * this.entity.sound.pause();
     * // pause a specific sound
     * this.entity.sound.pause('beep');
     */
    pause(name?: string): void;
    /**
     * Resumes playback of the sound slot with the specified name if it's paused. If no name is
     * specified all slots will be resumed.
     *
     * @param {string} [name] - The name of the slot to resume. Leave undefined to resume everything.
     * @example
     * // resume all sounds
     * this.entity.sound.resume();
     * // resume a specific sound
     * this.entity.sound.resume('beep');
     */
    resume(name?: string): void;
    /**
     * Stops playback of the sound slot with the specified name if it's paused. If no name is
     * specified all slots will be stopped.
     *
     * @param {string} [name] - The name of the slot to stop. Leave undefined to stop everything.
     * @example
     * // stop all sounds
     * this.entity.sound.stop();
     * // stop a specific sound
     * this.entity.sound.stop('beep');
     */
    stop(name?: string): void;
}

declare class ScrollViewComponentData {
    enabled: boolean;
}

/**
 * Manages creation of {@link ScrollViewComponent}s.
 *
 * @augments ComponentSystem
 */
declare class ScrollViewComponentSystem extends ComponentSystem {
    id: string;
    ComponentType: typeof ScrollViewComponent;
    DataType: typeof ScrollViewComponentData;
    schema: {
        name: string;
        type: string;
    }[];
    initializeComponentData(component: any, data: any, properties: any): void;
    onUpdate(dt: any): void;
    _onRemoveComponent(entity: any, component: any): void;
}

/**
 * An EntityReference can be used in scenarios where a component has one or more properties that
 * refer to entities in the scene graph. Using an EntityReference simplifies the job of dealing
 * with the presence or non-presence of the underlying entity and its components, especially when
 * it comes to dealing with the runtime addition or removal of components, and addition/removal of
 * associated event listeners.
 *
 * ## Usage Scenario ##
 *
 * Imagine that you're creating a Checkbox component, which has a reference to an entity
 * representing the checkmark/tickmark that is rendered in the Checkbox. The reference is modeled
 * as an entity guid property on the Checkbox component, called simply 'checkmark'. We have to
 * implement a basic piece of functionality whereby when the 'checkmark' entity reference is set,
 * the Checkbox component must toggle the tint of an ImageElementComponent present on the checkmark
 * entity to indicate whether the Checkbox is currently in the active or inactive state.
 *
 * Without using an EntityReference, the Checkbox component must implement some or all of the
 * following:
 *
 * - Listen for its 'checkmark' property being set to a valid guid, and retrieve a reference to the
 *   entity associated with this guid whenever it changes (i.e. via `app.root.findByGuid()`).
 * - Once a valid entity is received, check to see whether it has already has an
 *   ImageElementComponent or not:
 *   - If it has one, proceed to set the tint of the ImageElementComponent based on whether the
 *     Checkbox is currently active or inactive.
 *   - If it doesn't have one, add a listener to wait for the addition of an ImageElementComponent,
 *     and then apply the tint once one becomes present.
 * - If the checkmark entity is then reassigned (such as if the user reassigns the field in the
 *   editor, or if this is done at runtime via a script), a well-behaved Checkbox component must
 *   also undo the tinting so that no lasting effect is applied to the old entity.
 * - If the checkmark entity's ImageElementComponent is removed and then another
 *   ImageElementComponent is added, the Checkbox component must handle this in order to re-apply
 *   the tint.
 * - To prevent memory leaks, the Checkbox component must also make sure to correctly remove
 *   listeners in each of the following scenarios:
 *   - Destruction of the Checkbox component.
 *   - Reassignment of the checkmark entity.
 *   - Removal of the ImageElementComponent.
 * - It must also be careful not to double-add listeners in any of the above code paths, to avoid
 *   various forms of undesirable behavior.
 *
 * If the Checkbox component becomes more complicated and has multiple entity reference properties,
 * all of the above must be done correctly for each entity. Similarly, if it depends on multiple
 * different component types being present on the entities it has references to, it must correctly
 * handle the presence and non-presence of each of these components in the various possible
 * sequences of addition and removal. In addition to generating a lot of boilerplate, it's also
 * very easy for subtle mistakes to be made that lead to memory leaks, null reference errors or
 * visual bugs.
 *
 * By using an EntityReference, all of the above can be reduced to the following:
 *
 * ```javascript
 * function CheckboxComponent() {
 *    this._checkmarkReference = new pc.EntityReference(this, 'checkmark', {
 *        'element#gain': this._onCheckmarkImageElementGain,
 *        'element#lose': this._onCheckmarkImageElementLose
 *    });
 * }
 * ```
 *
 * Using the above code snippet, the `_onCheckmarkImageElementGain()` listener will be called
 * in either of the following scenarios:
 *
 * 1. A checkmark entity is assigned and already has an ElementComponent.
 * 2. A checkmark entity is assigned that does not have an ElementComponent, but one is added
 * later.
 *
 * Similarly, the `_onCheckmarkImageElementLose()` listener will be called in either of the
 * following scenarios:
 *
 * 1. An ElementComponent is removed from the checkmark entity.
 * 2. The checkmark entity is re-assigned (i.e. to another entity), or nullified. In this
 * scenario the callback will only be called if the entity actually had an ElementComponent.
 *
 * ## Event String Format ##
 *
 * The event string (i.e. "element#gain" in the above examples) is of the format
 * `sourceName#eventName`, and is defined as follows:
 *
 * - `sourceName`: May be any component name, or the special string "entity", which refers to the
 * entity itself.
 * - `eventName`: May be the name of any event dispatched by the relevant component or entity, as
 * well as the special strings "gain" or "lose".
 *
 * Some examples are as follows:
 *
 * ```javascript
 * "entity#destroy"    // Called when the entity managed by the entity reference is destroyed.
 * "element#set:width" // Called when the width of an ElementComponent is set.
 * ```
 *
 * When the entity reference changes to another entity (or null) the set:entity event is fired.
 *
 * ## Ownership and Destruction ##
 *
 * The lifetime of an ElementReference is tied to the parent component that instantiated it. This
 * coupling is indicated by the provision of the `this` keyword to the ElementReference's
 * constructor in the above examples (i.e. `new pc.EntityReference(this, ...`).
 *
 * Any event listeners managed by the ElementReference are automatically cleaned up when the parent
 * component is removed or the parent component's entity is destroyed – as such you should never
 * have to worry about dangling listeners.
 *
 * Additionally, any callbacks listed in the event config will automatically be called in the scope
 * of the parent component – you should never have to worry about manually calling
 * `Function.bind()`.
 *
 * @augments EventHandler
 * @ignore
 */
declare class EntityReference extends EventHandler {
    /**
     * Helper class used for managing component properties that represent entity references.
     *
     * @param {Component} parentComponent - A reference to the parent component that owns this
     * entity reference.
     * @param {string} entityPropertyName - The name of the component property that contains the
     * entity guid.
     * @param {Object<string, Function>} [eventConfig] - A map of event listener configurations.
     */
    constructor(parentComponent: Component, entityPropertyName: string, eventConfig?: {
        [x: string]: Function;
    });
    _parentComponent: Component;
    _entityPropertyName: string;
    _entity: Entity;
    _app: AppBase;
    _configureEventListeners(externalEventConfig: any, internalEventConfig: any): void;
    _eventListenerConfigs: {
        id: string;
        sourceName: string;
        eventName: string;
        callback: any;
        scope: any;
    }[];
    _listenerStatusFlags: {};
    _gainListeners: {};
    _loseListeners: {};
    _parseEventListenerConfig(eventConfig: any, prefix: any, scope: any): {
        id: string;
        sourceName: string;
        eventName: string;
        callback: any;
        scope: any;
    }[];
    _toggleLifecycleListeners(onOrOff: any): void;
    _onSetEntity(name: any, oldValue: any, newValue: any): void;
    /**
     * Must be called from the parent component's onEnable() method in order for entity references
     * to be correctly resolved when {@link Entity#clone} is called.
     *
     * @private
     */
    private onParentComponentEnable;
    _onSceneLoaded(): void;
    _updateEntityReference(): void;
    _onBeforeEntityChange(): void;
    _onAfterEntityChange(): void;
    _onComponentAdd(entity: any, component: any): void;
    _onComponentRemove(entity: any, component: any): void;
    _callAllGainOrLoseListeners(listenerMap: any): void;
    _callGainOrLoseListener(componentName: any, listenerMap: any): void;
    _toggleEntityListeners(onOrOff: any, isDestroying: any): void;
    _toggleComponentListeners(onOrOff: any, componentName: any, isDestroying: any): void;
    _safeToggleListener(onOrOff: any, config: any, isDestroying: any): void;
    _getEventSource(sourceName: any, isDestroying: any): any;
    _onEntityDestroy(entity: any): void;
    _onParentComponentRemove(entity: any, component: any): void;
    /**
     * Convenience method indicating whether the entity exists and has a component of the provided
     * type.
     *
     * @param {string} componentName - Name of the component.
     * @returns {boolean} True if the entity exists and has a component of the provided type.
     */
    hasComponent(componentName: string): boolean;
    /**
     * A reference to the entity, if present.
     *
     * @type {Entity}
     */
    get entity(): Entity;
}

declare class ElementComponentData {
    enabled: boolean;
}

declare class StandardMaterialOptionsBuilder {
    _mapXForms: any[];
    updateMinRef(options: any, scene: any, stdMat: any, objDefs: any, staticLightList: any, pass: any, sortedLights: any): void;
    updateRef(options: any, scene: any, stdMat: any, objDefs: any, staticLightList: any, pass: any, sortedLights: any): void;
    _updateSharedOptions(options: any, scene: any, stdMat: any, objDefs: any, pass: any): void;
    _updateUVOptions(options: any, stdMat: any, objDefs: any, minimalOptions: any): void;
    _updateMinOptions(options: any, stdMat: any): void;
    _updateMaterialOptions(options: any, stdMat: any): void;
    _updateEnvOptions(options: any, stdMat: any, scene: any): void;
    _updateLightOptions(options: any, stdMat: any, objDefs: any, sortedLights: any, staticLightList: any): void;
    _updateTexOptions(options: any, stdMat: any, p: any, hasUv0: any, hasUv1: any, hasVcolor: any, minimalOptions: any): void;
    _collectLights(lType: any, lights: any, lightsFiltered: any, mask: any, staticLightList: any): void;
    _getMapTransformID(xform: any, uv: any): any;
}



/**
 * Callback used by {@link StandardMaterialonUpdateShader }.
 */
export type UpdateShaderCallback = (options: any) => any;
/**
 * Callback used by {@link StandardMaterial#onUpdateShader}.
 *
 * @callback UpdateShaderCallback
 * @param {*} options - An object with shader generator settings (based on current material and
 * scene properties), that you can change and then return. Properties of the object passed into
 * this function are documented in {@link StandardMaterial#onUpdateShader}.
 * @returns {*} Returned settings will be used by the shader.
 */
/**
 * A Standard material is the main, general purpose material that is most often used for rendering.
 * It can approximate a wide variety of surface types and can simulate dynamic reflected light.
 * Most maps can use 3 types of input values in any combination: constant (color or number), mesh
 * vertex colors and a texture. All enabled inputs are multiplied together.
 *
 * @property {Color} ambient The ambient color of the material. This color value is 3-component
 * (RGB), where each component is between 0 and 1.
 * @property {Color} diffuse The diffuse color of the material. This color value is 3-component
 * (RGB), where each component is between 0 and 1. Defines basic surface color (aka albedo).
 * @property {boolean} diffuseTint Multiply main (primary) diffuse map and/or diffuse vertex color
 * by the constant diffuse value.
 * @property {Texture|null} diffuseMap The main (primary) diffuse map of the material (default is
 * null).
 * @property {number} diffuseMapUv Main (primary) diffuse map UV channel.
 * @property {Vec2} diffuseMapTiling Controls the 2D tiling of the main (primary) diffuse map.
 * @property {Vec2} diffuseMapOffset Controls the 2D offset of the main (primary) diffuse map. Each
 * component is between 0 and 1.
 * @property {number} diffuseMapRotation Controls the 2D rotation (in degrees) of the main
 * (primary) diffuse map.
 * @property {string} diffuseMapChannel Color channels of the main (primary) diffuse map to use.
 * Can be "r", "g", "b", "a", "rgb" or any swizzled combination.
 * @property {boolean} diffuseVertexColor Use mesh vertex colors for diffuse. If diffuseMap or are
 * diffuseTint are set, they'll be multiplied by vertex colors.
 * @property {string} diffuseVertexColorChannel Vertex color channels to use for diffuse. Can be
 * "r", "g", "b", "a", "rgb" or any swizzled combination.
 * @property {Texture|null} diffuseDetailMap The detail (secondary) diffuse map of the material
 * (default is null). Will only be used if main (primary) diffuse map is non-null.
 * @property {number} diffuseDetailMapUv Detail (secondary) diffuse map UV channel.
 * @property {Vec2} diffuseDetailMapTiling Controls the 2D tiling of the detail (secondary) diffuse
 * map.
 * @property {Vec2} diffuseDetailMapOffset Controls the 2D offset of the detail (secondary) diffuse
 * map. Each component is between 0 and 1.
 * @property {number} diffuseDetailMapRotation Controls the 2D rotation (in degrees) of the main
 * (secondary) diffuse map.
 * @property {string} diffuseDetailMapChannel Color channels of the detail (secondary) diffuse map
 * to use. Can be "r", "g", "b", "a", "rgb" or any swizzled combination.
 * @property {string} diffuseDetailMode Determines how the main (primary) and detail (secondary)
 * diffuse maps are blended together. Can be:
 *
 * - {@link DETAILMODE_MUL}: Multiply together the primary and secondary colors.
 * - {@link DETAILMODE_ADD}: Add together the primary and secondary colors.
 * - {@link DETAILMODE_SCREEN}: Softer version of {@link DETAILMODE_ADD}.
 * - {@link DETAILMODE_OVERLAY}: Multiplies or screens the colors, depending on the primary color.
 * - {@link DETAILMODE_MIN}: Select whichever of the primary and secondary colors is darker,
 * component-wise.
 * - {@link DETAILMODE_MAX}: Select whichever of the primary and secondary colors is lighter,
 * component-wise.
 *
 * Defaults to {@link DETAILMODE_MUL}.
 * @property {Color} specular The specular color of the material. This color value is 3-component
 * (RGB), where each component is between 0 and 1. Defines surface reflection/specular color.
 * Affects specular intensity and tint.
 * @property {boolean} specularTint Multiply specular map and/or specular vertex color by the
 * constant specular value.
 * @property {Texture|null} specularMap The specular map of the material (default is null).
 * @property {number} specularMapUv Specular map UV channel.
 * @property {Vec2} specularMapTiling Controls the 2D tiling of the specular map.
 * @property {Vec2} specularMapOffset Controls the 2D offset of the specular map. Each component is
 * between 0 and 1.
 * @property {number} specularMapRotation Controls the 2D rotation (in degrees) of the specular map.
 * @property {string} specularMapChannel Color channels of the specular map to use. Can be "r", "g",
 * "b", "a", "rgb" or any swizzled combination.
 * @property {boolean} specularVertexColor Use mesh vertex colors for specular. If specularMap or
 * are specularTint are set, they'll be multiplied by vertex colors.
 * @property {string} specularVertexColorChannel Vertex color channels to use for specular. Can be
 * "r", "g", "b", "a", "rgb" or any swizzled combination.
 * @property {number} specularityFactor The factor of specular intensity, used to weight the fresnel and specularity. Default is 1.0.
 * @property {Texture|null} specularityFactorMap The factor of specularity as a texture (default is null).
 * @property {number} specularityMapUv Specularity factor map UV channel.
 * @property {Vec2} specularityMapTiling Controls the 2D tiling of the specularity factor map.
 * @property {Vec2} specularityMapOffset Controls the 2D offset of the specularity factor map. Each component is
 * between 0 and 1.
 * @property {number} specularityMapRotation Controls the 2D rotation (in degrees) of the specularity factor map.
 * @property {string} specularityFactorMapChannel The channel used by the specularity factor texture to sample from (default is 'a').
 * @property {boolean} enableGGXSpecular Enables GGX specular. Also enables
 * {@link StandardMaterial#anisotropy}  parameter to set material anisotropy.
 * @property {number} anisotropy Defines amount of anisotropy. Requires
 * {@link StandardMaterial#enableGGXSpecular} is set to true.
 *
 * - When anisotropy == 0, specular is isotropic.
 * - When anisotropy < 0, anisotropy direction aligns with the tangent, and specular anisotropy
 * increases as the anisotropy value decreases to minimum of -1.
 * - When anisotropy > 0, anisotropy direction aligns with the bi-normal, and specular anisotropy
 * increases as anisotropy value increases to maximum of 1.
 *
 * @property {number} clearCoat Defines intensity of clear coat layer from 0 to 1. Clear coat layer
 * is disabled when clearCoat == 0. Default value is 0 (disabled).
 * @property {Texture|null} clearCoatMap Monochrome clear coat intensity map (default is null). If
 * specified, will be multiplied by normalized 'clearCoat' value and/or vertex colors.
 * @property {number} clearCoatMapUv Clear coat intensity map UV channel.
 * @property {Vec2} clearCoatMapTiling Controls the 2D tiling of the clear coat intensity map.
 * @property {Vec2} clearCoatMapOffset Controls the 2D offset of the clear coat intensity map. Each
 * component is between 0 and 1.
 * @property {number} clearCoatMapRotation Controls the 2D rotation (in degrees) of the clear coat
 * intensity map.
 * @property {string} clearCoatMapChannel Color channel of the clear coat intensity map to use. Can
 * be "r", "g", "b" or "a".
 * @property {boolean} clearCoatVertexColor Use mesh vertex colors for clear coat intensity. If
 * clearCoatMap is set, it'll be multiplied by vertex colors.
 * @property {string} clearCoatVertexColorChannel Vertex color channel to use for clear coat
 * intensity. Can be "r", "g", "b" or "a".
 * @property {number} clearCoatGlossiness Defines the clear coat glossiness of the clear coat layer
 * from 0 (rough) to 1 (mirror).
 * @property {Texture|null} clearCoatGlossMap Monochrome clear coat glossiness map (default is
 * null). If specified, will be multiplied by normalized 'clearCoatGlossiness' value and/or vertex
 * colors.
 * @property {number} clearCoatGlossMapUv Clear coat gloss map UV channel.
 * @property {Vec2} clearCoatGlossMapTiling Controls the 2D tiling of the clear coat gloss map.
 * @property {Vec2} clearCoatGlossMapOffset Controls the 2D offset of the clear coat gloss map.
 * Each component is between 0 and 1.
 * @property {number} clearCoatGlossMapRotation Controls the 2D rotation (in degrees) of the clear
 * coat gloss map.
 * @property {string} clearCoatGlossMapChannel Color channel of the clear coat gloss map to use.
 * Can be "r", "g", "b" or "a".
 * @property {boolean} clearCoatGlossVertexColor Use mesh vertex colors for clear coat glossiness.
 * If clearCoatGlossMap is set, it'll be multiplied by vertex colors.
 * @property {string} clearCoatGlossVertexColorChannel Vertex color channel to use for clear coat
 * glossiness. Can be "r", "g", "b" or "a".
 * @property {Texture|null} clearCoatNormalMap The clear coat normal map of the material (default
 * is null). The texture must contains normalized, tangent space normals.
 * @property {number} clearCoatNormalMapUv Clear coat normal map UV channel.
 * @property {Vec2} clearCoatNormalMapTiling Controls the 2D tiling of the main clear coat normal
 * map.
 * @property {Vec2} clearCoatNormalMapOffset Controls the 2D offset of the main clear coat normal
 * map. Each component is between 0 and 1.
 * @property {number} clearCoatNormalMapRotation Controls the 2D rotation (in degrees) of the main
 * clear coat map.
 * @property {number} clearCoatBumpiness The bumpiness of the clear coat layer. This value scales
 * the assigned main clear coat normal map. It should be normally between 0 (no bump mapping) and 1
 * (full bump mapping), but can be set to e.g. 2 to give even more pronounced bump effect.
 * @property {boolean} useMetalness Use metalness properties instead of specular. When enabled,
 * diffuse colors also affect specular instead of the dedicated specular map. This can be used as
 * alternative to specular color to save space. With metaless == 0, the pixel is assumed to be
 * dielectric, and diffuse color is used as normal. With metaless == 1, the pixel is fully
 * metallic, and diffuse color is used as specular color instead.
 * @property {boolean} useMetalnessSpecularColor When metalness is enabled, use the specular map to apply color tint to specular reflections
 * at direct angles.
 * @property {number} metalness Defines how much the surface is metallic. From 0 (dielectric) to 1
 * (metal).
 * @property {Texture|null} metalnessMap Monochrome metalness map (default is null).
 * @property {number} metalnessMapUv Metalness map UV channel.
 * @property {Vec2} metalnessMapTiling Controls the 2D tiling of the metalness map.
 * @property {Vec2} metalnessMapOffset Controls the 2D offset of the metalness map. Each component
 * is between 0 and 1.
 * @property {number} metalnessMapRotation Controls the 2D rotation (in degrees) of the metalness
 * map.
 * @property {string} metalnessMapChannel Color channel of the metalness map to use. Can be "r",
 * "g", "b" or "a".
 * @property {boolean} metalnessVertexColor Use mesh vertex colors for metalness. If metalnessMap
 * is set, it'll be multiplied by vertex colors.
 * @property {string} metalnessVertexColorChannel Vertex color channel to use for metalness. Can be
 * "r", "g", "b" or "a".
 * @property {number} shininess Defines glossiness of the material from 0 (rough) to 100 (shiny
 * mirror). A higher shininess value results in a more focused specular highlight. Glossiness map/
 * vertex colors are always multiplied by this value (normalized to 0 - 1 range), or it is used
 * directly as constant output.
 * @property {Texture|null} glossMap Glossiness map (default is null). If specified, will be
 * multiplied by normalized 'shininess' value and/or vertex colors.
 * @property {number} glossMapUv Gloss map UV channel.
 * @property {string} glossMapChannel Color channel of the gloss map to use. Can be "r", "g", "b"
 * or "a".
 * @property {Vec2} glossMapTiling Controls the 2D tiling of the gloss map.
 * @property {Vec2} glossMapOffset Controls the 2D offset of the gloss map. Each component is
 * between 0 and 1.
 * @property {number} glossMapRotation Controls the 2D rotation (in degrees) of the gloss map.
 * @property {boolean} glossVertexColor Use mesh vertex colors for glossiness. If glossMap is set,
 * it'll be multiplied by vertex colors.
 * @property {string} glossVertexColorChannel Vertex color channel to use for glossiness. Can be
 * "r", "g", "b" or "a".
 * @property {number} refraction Defines the visibility of refraction. Material can refract the
 * same cube map as used for reflections.
 * @property {Texture|null} refractionMap The map of the refraction visibility.
 * @property {number} refractionMapUv Refraction map UV channel.
 * @property {Vec2} refractionMapTiling Controls the 2D tiling of the refraction map.
 * @property {Vec2} refractionMapOffset Controls the 2D offset of the refraction map. Each component is
 * between 0 and 1.
 * @property {number} refractionMapRotation Controls the 2D rotation (in degrees) of the emissive
 * map.
 * @property {string} refractionMapChannel Color channels of the refraction map to use. Can be "r",
 * "g", "b", "a", "rgb" or any swizzled combination.
 * @property {number} refractionIndex Defines the index of refraction, i.e. The amount of
 * distortion. The value is calculated as (outerIor / surfaceIor), where inputs are measured
 * indices of refraction, the one around the object and the one of its own surface. In most
 * situations outer medium is air, so outerIor will be approximately 1. Then you only need to do
 * (1.0 / surfaceIor).
 * @property {Color} emissive The emissive color of the material. This color value is 3-component
 * (RGB), where each component is between 0 and 1.
 * @property {boolean} emissiveTint Multiply emissive map and/or emissive vertex color by the
 * constant emissive value.
 * @property {Texture|null} emissiveMap The emissive map of the material (default is null). Can be
 * HDR.
 * @property {number} emissiveIntensity Emissive color multiplier.
 * @property {number} emissiveMapUv Emissive map UV channel.
 * @property {Vec2} emissiveMapTiling Controls the 2D tiling of the emissive map.
 * @property {Vec2} emissiveMapOffset Controls the 2D offset of the emissive map. Each component is
 * between 0 and 1.
 * @property {number} emissiveMapRotation Controls the 2D rotation (in degrees) of the emissive
 * map.
 * @property {string} emissiveMapChannel Color channels of the emissive map to use. Can be "r",
 * "g", "b", "a", "rgb" or any swizzled combination.
 * @property {boolean} emissiveVertexColor Use mesh vertex colors for emission. If emissiveMap or
 * emissiveTint are set, they'll be multiplied by vertex colors.
 * @property {string} emissiveVertexColorChannel Vertex color channels to use for emission. Can be
 * "r", "g", "b", "a", "rgb" or any swizzled combination.
 * @property {number} opacity The opacity of the material. This value can be between 0 and 1, where
 * 0 is fully transparent and 1 is fully opaque. If you want the material to be semi-transparent
 * you also need to set the {@link Material#blendType} to {@link BLEND_NORMAL},
 * {@link BLEND_ADDITIVE} or any other mode. Also note that for most semi-transparent objects you
 * want {@link Material#depthWrite} to be false, otherwise they can fully occlude objects behind
 * them.
 * @property {Texture|null} opacityMap The opacity map of the material (default is null).
 * @property {number} opacityMapUv Opacity map UV channel.
 * @property {string} opacityMapChannel Color channel of the opacity map to use. Can be "r", "g",
 * "b" or "a".
 * @property {Vec2} opacityMapTiling Controls the 2D tiling of the opacity map.
 * @property {Vec2} opacityMapOffset Controls the 2D offset of the opacity map. Each component is
 * between 0 and 1.
 * @property {number} opacityMapRotation Controls the 2D rotation (in degrees) of the opacity map.
 * @property {boolean} opacityVertexColor Use mesh vertex colors for opacity. If opacityMap is set,
 * it'll be multiplied by vertex colors.
 * @property {string} opacityVertexColorChannel Vertex color channels to use for opacity. Can be
 * "r", "g", "b" or "a".
 * @property {boolean} opacityFadesSpecular used to specify whether specular and reflections are
 * faded out using {@link StandardMaterial#opacity}. Default is true. When set to false use
 * {@link Material#alphaFade} to fade out materials.
 * @property {number} alphaFade used to fade out materials when
 * {@link StandardMaterial#opacityFadesSpecular} is set to false.
 * @property {Texture|null} normalMap The main (primary) normal map of the material (default is
 * null). The texture must contains normalized, tangent space normals.
 * @property {number} normalMapUv Main (primary) normal map UV channel.
 * @property {Vec2} normalMapTiling Controls the 2D tiling of the main (primary) normal map.
 * @property {Vec2} normalMapOffset Controls the 2D offset of the main (primary) normal map. Each
 * component is between 0 and 1.
 * @property {number} normalMapRotation Controls the 2D rotation (in degrees) of the main (primary)
 * normal map.
 * @property {number} bumpiness The bumpiness of the material. This value scales the assigned main
 * (primary) normal map. It should be normally between 0 (no bump mapping) and 1 (full bump
 * mapping), but can be set to e.g. 2 to give even more pronounced bump effect.
 * @property {Texture|null} normalDetailMap The detail (secondary) normal map of the material
 * (default is null). Will only be used if main (primary) normal map is non-null.
 * @property {number} normalDetailMapUv Detail (secondary) normal map UV channel.
 * @property {Vec2} normalDetailMapTiling Controls the 2D tiling of the detail (secondary) normal
 * map.
 * @property {Vec2} normalDetailMapOffset Controls the 2D offset of the detail (secondary) normal
 * map. Each component is between 0 and 1.
 * @property {number} normalDetailMapRotation Controls the 2D rotation (in degrees) of the detail
 * (secondary) normal map.
 * @property {number} normalDetailMapBumpiness The bumpiness of the material. This value scales the
 * assigned detail (secondary) normal map. It should be normally between 0 (no bump mapping) and 1
 * (full bump mapping), but can be set to e.g. 2 to give even more pronounced bump effect.
 * @property {Texture|null} heightMap The height map of the material (default is null). Used for a
 * view-dependent parallax effect. The texture must represent the height of the surface where
 * darker pixels are lower and lighter pixels are higher. It is recommended to use it together with
 * a normal map.
 * @property {number} heightMapUv Height map UV channel.
 * @property {string} heightMapChannel Color channel of the height map to use. Can be "r", "g", "b"
 * or "a".
 * @property {Vec2} heightMapTiling Controls the 2D tiling of the height map.
 * @property {Vec2} heightMapOffset Controls the 2D offset of the height map. Each component is
 * between 0 and 1.
 * @property {number} heightMapRotation Controls the 2D rotation (in degrees) of the height map.
 * @property {number} heightMapFactor Height map multiplier. Affects the strength of the parallax
 * effect.
 * @property {Texture|null} envAtlas The prefiltered environment lighting atlas (default is null).
 * This setting overrides cubeMap and sphereMap and will replace the scene lighting environment.
 * @property {Texture|null} cubeMap The cubic environment map of the material (default is null).
 * This setting overrides sphereMap and will replace the scene lighting environment.
 * @property {Texture|null} sphereMap The spherical environment map of the material (default is
 * null). This will replace the scene lighting environment.
 * @property {number} cubeMapProjection The type of projection applied to the cubeMap property:
 * - {@link CUBEPROJ_NONE}: The cube map is treated as if it is infinitely far away.
 * - {@link CUBEPROJ_BOX}: Box-projection based on a world space axis-aligned bounding box.
 * Defaults to {@link CUBEPROJ_NONE}.
 * @property {BoundingBox} cubeMapProjectionBox The world space axis-aligned bounding box defining
 * the box-projection used for the cubeMap property. Only used when cubeMapProjection is set to
 * {@link CUBEPROJ_BOX}.
 * @property {number} reflectivity Environment map intensity.
 * @property {Texture|null} lightMap A custom lightmap of the material (default is null). Lightmaps
 * are textures that contain pre-rendered lighting. Can be HDR.
 * @property {number} lightMapUv Lightmap UV channel
 * @property {string} lightMapChannel Color channels of the lightmap to use. Can be "r", "g", "b",
 * "a", "rgb" or any swizzled combination.
 * @property {Vec2} lightMapTiling Controls the 2D tiling of the lightmap.
 * @property {Vec2} lightMapOffset Controls the 2D offset of the lightmap. Each component is
 * between 0 and 1.
 * @property {number} lightMapRotation Controls the 2D rotation (in degrees) of the lightmap.
 * @property {boolean} lightVertexColor Use baked vertex lighting. If lightMap is set, it'll be
 * multiplied by vertex colors.
 * @property {string} lightVertexColorChannel Vertex color channels to use for baked lighting. Can
 * be "r", "g", "b", "a", "rgb" or any swizzled combination.
 * @property {boolean} ambientTint Enables scene ambient multiplication by material ambient color.
 * @property {Texture|null} aoMap Baked ambient occlusion (AO) map (default is null). Modulates
 * ambient color.
 * @property {number} aoMapUv AO map UV channel
 * @property {string} aoMapChannel Color channel of the AO map to use. Can be "r", "g", "b" or "a".
 * @property {Vec2} aoMapTiling Controls the 2D tiling of the AO map.
 * @property {Vec2} aoMapOffset Controls the 2D offset of the AO map. Each component is between 0
 * and 1.
 * @property {number} aoMapRotation Controls the 2D rotation (in degrees) of the AO map.
 * @property {boolean} aoVertexColor Use mesh vertex colors for AO. If aoMap is set, it'll be
 * multiplied by vertex colors.
 * @property {string} aoVertexColorChannel Vertex color channels to use for AO. Can be "r", "g",
 * "b" or "a".
 * @property {number} occludeSpecular Uses ambient occlusion to darken specular/reflection. It's a
 * hack, because real specular occlusion is view-dependent. However, it can be better than nothing.
 *
 * - {@link SPECOCC_NONE}: No specular occlusion
 * - {@link SPECOCC_AO}: Use AO directly to occlude specular.
 * - {@link SPECOCC_GLOSSDEPENDENT}: Modify AO based on material glossiness/view angle to occlude
 * specular.
 *
 * @property {number} occludeSpecularIntensity Controls visibility of specular occlusion.
 * @property {boolean} occludeDirect Tells if AO should darken directional lighting. Defaults to
 * false.
 * @property {boolean} conserveEnergy Defines how diffuse and specular components are combined when
 * Fresnel is on. It is recommended that you leave this option enabled, although you may want to
 * disable it in case when all reflection comes only from a few light sources, and you don't use an
 * environment map, therefore having mostly black reflection.
 * @property {number} shadingModel Defines the shading model.
 * - {@link SPECULAR_PHONG}: Phong without energy conservation. You should only use it as a
 * backwards compatibility with older projects.
 * - {@link SPECULAR_BLINN}: Energy-conserving Blinn-Phong.
 * @property {number} fresnelModel Defines the formula used for Fresnel effect.
 * As a side-effect, enabling any Fresnel model changes the way diffuse and reflection components
 * are combined. When Fresnel is off, legacy non energy-conserving combining is used. When it is
 * on, combining behavior is defined by conserveEnergy parameter.
 *
 * - {@link FRESNEL_NONE}: No Fresnel.
 * - {@link FRESNEL_SCHLICK}: Schlick's approximation of Fresnel (recommended). Parameterized by
 * specular color.
 *
 * @property {boolean} useFog Apply fogging (as configured in scene settings)
 * @property {boolean} useLighting Apply lighting
 * @property {boolean} useSkybox Apply scene skybox as prefiltered environment map
 * @property {boolean} useGammaTonemap Apply gamma correction and tonemapping (as configured in
 * scene settings).
 * @property {boolean} pixelSnap Align vertices to pixel coordinates when rendering. Useful for
 * pixel perfect 2D graphics.
 * @property {boolean} twoSidedLighting Calculate proper normals (and therefore lighting) on
 * backfaces.
 * @property {UpdateShaderCallback} onUpdateShader A custom function that will be called after all
 * shader generator properties are collected and before shader code is generated. This function
 * will receive an object with shader generator settings (based on current material and scene
 * properties), that you can change and then return. Returned value will be used instead. This is
 * mostly useful when rendering the same set of objects, but with different shader variations based
 * on the same material. For example, you may wish to render a depth or normal pass using textures
 * assigned to the material, a reflection pass with simpler shaders and so on. Properties of the
 * object passed into this function are:
 *
 * - pass: value of {@link Layer#shaderPass} of the Layer being rendered.
 * - chunks: Object containing custom shader chunks that will replace default ones.
 * - customFragmentShader: Completely replace fragment shader with this code.
 * - forceUv1: if UV1 (second set of texture coordinates) is required in the shader. Will be
 * declared as "vUv1" and passed to the fragment shader.
 * - fog: the type of fog being applied in the shader. See {@link Scene#fog} for the list of
 * possible values.
 * - gamma: the type of gamma correction being applied in the shader. See
 * {@link Scene#gammaCorrection} for the list of possible values.
 * - toneMap: the type of tone mapping being applied in the shader. See {@link Scene#toneMapping}
 * for the list of possible values.
 * - ambientTint: the value of {@link StandardMaterial#ambientTint}.
 * - conserveEnergy: the value of {@link StandardMaterial#conserveEnergy}.
 * - occludeSpecular: the value of {@link StandardMaterial#occludeSpecular}.
 * - occludeDirect: the value of {@link StandardMaterial#occludeDirect}.
 * - shadingModel: the value of {@link StandardMaterial#shadingModel}.
 * - fresnelModel: the value of {@link StandardMaterial#fresnelModel}.
 * - cubeMapProjection: the value of {@link StandardMaterial#cubeMapProjection}.
 * - useMetalness: the value of {@link StandardMaterial#useMetalness}.
 * - blendType: the value of {@link Material#blendType}.
 * - twoSidedLighting: the value of {@link Material#twoSidedLighting}.
 * - diffuseTint: defines if {@link StandardMaterial#diffuse} constant should affect diffuse color.
 * - specularTint: defines if {@link StandardMaterial#specular} constant should affect specular
 * color.
 * - metalnessTint: defines if {@link StandardMaterial#metalness} constant should affect metalness
 * value.
 * - glossTint: defines if {@link StandardMaterial#shininess} constant should affect glossiness
 * value.
 * - emissiveTint: defines if {@link StandardMaterial#emissive} constant should affect emission
 * value.
 * - opacityTint: defines if {@link StandardMaterial#opacity} constant should affect opacity value.
 * - occludeSpecularFloat: defines if {@link StandardMaterial#occludeSpecularIntensity} constant
 * should affect specular occlusion.
 * - alphaTest: enable alpha testing. See {@link Material#alphaTest}.
 * - alphaToCoverage: enable alpha to coverage. See {@link Material#alphaToCoverage}.
 * - opacityFadesSpecular: enable specular fade. See {@link Material#opacityFadesSpecular}.
 * - alphaFade: fade value. See {@link Material#alphaFade}.
 * - sphereMap: if {@link StandardMaterial#sphereMap} is used.
 * - cubeMap: if {@link StandardMaterial#cubeMap} is used.
 * - ambientSH: if ambient spherical harmonics are used. Ambient SH replace prefiltered cubemap
 * ambient on certain platform (mostly Android) for performance reasons.
 * - useSpecular: if any specular or reflections are needed at all.
 * - fixSeams: if cubemaps require seam fixing (see {@link Texture#options.fixCubemapSeams}).
 * - emissiveEncoding: how emissiveMap is encoded. This value is based on Texture#encoding.
 * - lightMapEncoding: how lightMap is encoded. This value is based on on Texture#encoding.
 * - useRgbm: if decodeRGBM() function is needed in the shader at all.
 * - packedNormal: if normal map contains X in RGB, Y in Alpha, and Z must be reconstructed.
 * - forceFragmentPrecision: Override fragment shader numeric precision. Can be "lowp", "mediump",
 * "highp" or null to use default.
 * - fastTbn: Use slightly cheaper normal mapping code (skip tangent space normalization). Can look
 * buggy sometimes.
 * - refraction: if refraction is used.
 * - skyboxIntensity: if reflected skybox intensity should be modulated.
 * - useCubeMapRotation: if cube map rotation is enabled.
 * - useInstancing: if hardware instancing compatible shader should be generated. Transform is read
 * from per-instance {@link VertexBuffer} instead of shader's uniforms.
 * - useMorphPosition: if morphing code should be generated to morph positions.
 * - useMorphNormal: if morphing code should be generated to morph normals.
 * - reflectionSource: one of "envAtlas", "cubeMap", "sphereMap"
 * - reflectionEncoding: one of null, "rgbm", "rgbe", "linear", "srgb"
 * - ambientSource: one of "ambientSH", "envAtlas", "constant"
 * - ambientEncoding: one of null, "rgbm", "rgbe", "linear", "srgb"
 * @augments Material
 */
declare class StandardMaterial extends Material {
    static TEXTURE_PARAMETERS: any[];
    static CUBEMAP_PARAMETERS: any[];
    _dirtyShader: boolean;
    _assetReferences: {};
    _activeParams: Set<any>;
    _activeLightingParams: Set<any>;
    shaderOptBuilder: StandardMaterialOptionsBuilder;
    reset(): void;

    set alphaFade(arg: boolean);
    get alphaFade(): boolean;

    set ambient(arg: Color);
    get ambient(): Color;

    set ambientTint(arg: boolean);
    get ambientTint(): boolean;

    set anisotropy(arg: number);
    get anisotropy(): number;

    set aoMap(arg: Texture|null);
    get aoMap(): Texture|null;

    set aoMapChannel(arg: string);
    get aoMapChannel(): string;

    set aoMapOffset(arg: Vec2);
    get aoMapOffset(): Vec2;

    set aoMapRotation(arg: number);
    get aoMapRotation(): number;

    set aoMapTiling(arg: Vec2);
    get aoMapTiling(): Vec2;

    set aoMapUv(arg: number);
    get aoMapUv(): number;

    set aoVertexColor(arg: boolean);
    get aoVertexColor(): boolean;

    set aoVertexColorChannel(arg: string);
    get aoVertexColorChannel(): string;

    set bumpiness(arg: number);
    get bumpiness(): number;

    set clearCoat(arg: number);
    get clearCoat(): number;

    set clearCoatBumpiness(arg: number);
    get clearCoatBumpiness(): number;

    set clearCoatGlossMap(arg: Texture|null);
    get clearCoatGlossMap(): Texture|null;

    set clearCoatGlossMapChannel(arg: string);
    get clearCoatGlossMapChannel(): string;

    set clearCoatGlossMapOffset(arg: Vec2);
    get clearCoatGlossMapOffset(): Vec2;

    set clearCoatGlossMapRotation(arg: number);
    get clearCoatGlossMapRotation(): number;

    set clearCoatGlossMapTiling(arg: Vec2);
    get clearCoatGlossMapTiling(): Vec2;

    set clearCoatGlossMapUv(arg: number);
    get clearCoatGlossMapUv(): number;

    set clearCoatGlossVertexColor(arg: boolean);
    get clearCoatGlossVertexColor(): boolean;

    set clearCoatGlossVertexColorChannel(arg: string);
    get clearCoatGlossVertexColorChannel(): string;

    set clearCoatGlossiness(arg: number);
    get clearCoatGlossiness(): number;

    set clearCoatMap(arg: Texture|null);
    get clearCoatMap(): Texture|null;

    set clearCoatMapChannel(arg: string);
    get clearCoatMapChannel(): string;

    set clearCoatMapOffset(arg: Vec2);
    get clearCoatMapOffset(): Vec2;

    set clearCoatMapRotation(arg: number);
    get clearCoatMapRotation(): number;

    set clearCoatMapTiling(arg: Vec2);
    get clearCoatMapTiling(): Vec2;

    set clearCoatMapUv(arg: number);
    get clearCoatMapUv(): number;

    set clearCoatNormalMap(arg: Texture|null);
    get clearCoatNormalMap(): Texture|null;

    set clearCoatNormalMapOffset(arg: Vec2);
    get clearCoatNormalMapOffset(): Vec2;

    set clearCoatNormalMapRotation(arg: number);
    get clearCoatNormalMapRotation(): number;

    set clearCoatNormalMapTiling(arg: Vec2);
    get clearCoatNormalMapTiling(): Vec2;

    set clearCoatNormalMapUv(arg: number);
    get clearCoatNormalMapUv(): number;

    set clearCoatVertexColor(arg: boolean);
    get clearCoatVertexColor(): boolean;

    set clearCoatVertexColorChannel(arg: string);
    get clearCoatVertexColorChannel(): string;

    set conserveEnergy(arg: boolean);
    get conserveEnergy(): boolean;

    set cubeMap(arg: Texture|null);
    get cubeMap(): Texture|null;

    set cubeMapProjection(arg: number);
    get cubeMapProjection(): number;

    set cubeMapProjectionBox(arg: BoundingBox);
    get cubeMapProjectionBox(): BoundingBox;

    set diffuse(arg: Color);
    get diffuse(): Color;

    set diffuseDetailMap(arg: Texture|null);
    get diffuseDetailMap(): Texture|null;

    set diffuseDetailMapChannel(arg: string);
    get diffuseDetailMapChannel(): string;

    set diffuseDetailMapOffset(arg: Vec2);
    get diffuseDetailMapOffset(): Vec2;

    set diffuseDetailMapRotation(arg: number);
    get diffuseDetailMapRotation(): number;

    set diffuseDetailMapTiling(arg: Vec2);
    get diffuseDetailMapTiling(): Vec2;

    set diffuseDetailMapUv(arg: number);
    get diffuseDetailMapUv(): number;

    set diffuseDetailMode(arg: string);
    get diffuseDetailMode(): string;

    set diffuseMap(arg: Texture|null);
    get diffuseMap(): Texture|null;

    set diffuseMapChannel(arg: string);
    get diffuseMapChannel(): string;

    set diffuseMapOffset(arg: Vec2);
    get diffuseMapOffset(): Vec2;

    set diffuseMapRotation(arg: number);
    get diffuseMapRotation(): number;

    set diffuseMapTiling(arg: Vec2);
    get diffuseMapTiling(): Vec2;

    set diffuseMapUv(arg: number);
    get diffuseMapUv(): number;

    set diffuseTint(arg: boolean);
    get diffuseTint(): boolean;

    set diffuseVertexColor(arg: boolean);
    get diffuseVertexColor(): boolean;

    set diffuseVertexColorChannel(arg: string);
    get diffuseVertexColorChannel(): string;

    set emissive(arg: Color);
    get emissive(): Color;

    set emissiveIntensity(arg: number);
    get emissiveIntensity(): number;

    set emissiveMap(arg: Texture|null);
    get emissiveMap(): Texture|null;

    set emissiveMapChannel(arg: string);
    get emissiveMapChannel(): string;

    set emissiveMapOffset(arg: Vec2);
    get emissiveMapOffset(): Vec2;

    set emissiveMapRotation(arg: number);
    get emissiveMapRotation(): number;

    set emissiveMapTiling(arg: Vec2);
    get emissiveMapTiling(): Vec2;

    set emissiveMapUv(arg: number);
    get emissiveMapUv(): number;

    set emissiveTint(arg: boolean);
    get emissiveTint(): boolean;

    set emissiveVertexColor(arg: boolean);
    get emissiveVertexColor(): boolean;

    set emissiveVertexColorChannel(arg: string);
    get emissiveVertexColorChannel(): string;

    set enableGGXSpecular(arg: boolean);
    get enableGGXSpecular(): boolean;

    set fresnelModel(arg: number);
    get fresnelModel(): number;

    set glossMap(arg: Texture|null);
    get glossMap(): Texture|null;

    set glossMapChannel(arg: string);
    get glossMapChannel(): string;

    set glossMapOffset(arg: Vec2);
    get glossMapOffset(): Vec2;

    set glossMapRotation(arg: number);
    get glossMapRotation(): number;

    set glossMapTiling(arg: Vec2);
    get glossMapTiling(): Vec2;

    set glossMapUv(arg: number);
    get glossMapUv(): number;

    set glossVertexColor(arg: boolean);
    get glossVertexColor(): boolean;

    set glossVertexColorChannel(arg: string);
    get glossVertexColorChannel(): string;

    set heightMap(arg: Texture|null);
    get heightMap(): Texture|null;

    set heightMapChannel(arg: string);
    get heightMapChannel(): string;

    set heightMapFactor(arg: number);
    get heightMapFactor(): number;

    set heightMapOffset(arg: Vec2);
    get heightMapOffset(): Vec2;

    set heightMapRotation(arg: number);
    get heightMapRotation(): number;

    set heightMapTiling(arg: Vec2);
    get heightMapTiling(): Vec2;

    set heightMapUv(arg: number);
    get heightMapUv(): number;

    set lightMap(arg: Texture|null);
    get lightMap(): Texture|null;

    set lightMapChannel(arg: string);
    get lightMapChannel(): string;

    set lightMapOffset(arg: Vec2);
    get lightMapOffset(): Vec2;

    set lightMapRotation(arg: number);
    get lightMapRotation(): number;

    set lightMapTiling(arg: Vec2);
    get lightMapTiling(): Vec2;

    set lightMapUv(arg: number);
    get lightMapUv(): number;

    set lightVertexColor(arg: boolean);
    get lightVertexColor(): boolean;

    set lightVertexColorChannel(arg: string);
    get lightVertexColorChannel(): string;

    set metalness(arg: number);
    get metalness(): number;

    set metalnessMap(arg: Texture|null);
    get metalnessMap(): Texture|null;

    set metalnessMapChannel(arg: string);
    get metalnessMapChannel(): string;

    set metalnessMapOffset(arg: Vec2);
    get metalnessMapOffset(): Vec2;

    set metalnessMapRotation(arg: number);
    get metalnessMapRotation(): number;

    set metalnessMapTiling(arg: Vec2);
    get metalnessMapTiling(): Vec2;

    set metalnessMapUv(arg: number);
    get metalnessMapUv(): number;

    set metalnessVertexColor(arg: boolean);
    get metalnessVertexColor(): boolean;

    set metalnessVertexColorChannel(arg: string);
    get metalnessVertexColorChannel(): string;

    set normalDetailMap(arg: Texture|null);
    get normalDetailMap(): Texture|null;

    set normalDetailMapBumpiness(arg: number);
    get normalDetailMapBumpiness(): number;

    set normalDetailMapOffset(arg: Vec2);
    get normalDetailMapOffset(): Vec2;

    set normalDetailMapRotation(arg: number);
    get normalDetailMapRotation(): number;

    set normalDetailMapTiling(arg: Vec2);
    get normalDetailMapTiling(): Vec2;

    set normalDetailMapUv(arg: number);
    get normalDetailMapUv(): number;

    set normalMap(arg: Texture|null);
    get normalMap(): Texture|null;

    set normalMapOffset(arg: Vec2);
    get normalMapOffset(): Vec2;

    set normalMapRotation(arg: number);
    get normalMapRotation(): number;

    set normalMapTiling(arg: Vec2);
    get normalMapTiling(): Vec2;

    set normalMapUv(arg: number);
    get normalMapUv(): number;

    set occludeDirect(arg: number);
    get occludeDirect(): number;

    set occludeSpecular(arg: number);
    get occludeSpecular(): number;

    set occludeSpecularIntensity(arg: number);
    get occludeSpecularIntensity(): number;

    set onUpdateShader(arg: UpdateShaderCallback);
    get onUpdateShader(): UpdateShaderCallback;

    set opacity(arg: number);
    get opacity(): number;

    set opacityFadesSpecular(arg: boolean);
    get opacityFadesSpecular(): boolean;

    set opacityMap(arg: Texture|null);
    get opacityMap(): Texture|null;

    set opacityMapChannel(arg: string);
    get opacityMapChannel(): string;

    set opacityMapOffset(arg: Vec2);
    get opacityMapOffset(): Vec2;

    set opacityMapRotation(arg: number);
    get opacityMapRotation(): number;

    set opacityMapTiling(arg: Vec2);
    get opacityMapTiling(): Vec2;

    set opacityMapUv(arg: number);
    get opacityMapUv(): number;

    set opacityVertexColor(arg: boolean);
    get opacityVertexColor(): boolean;

    set opacityVertexColorChannel(arg: string);
    get opacityVertexColorChannel(): string;

    set pixelSnap(arg: boolean);
    get pixelSnap(): boolean;

    set reflectivity(arg: number);
    get reflectivity(): number;

    set refraction(arg: number);
    get refraction(): number;

    set refractionIndex(arg: number);
    get refractionIndex(): number;

    set shadingModel(arg: number);
    get shadingModel(): number;

    set shininess(arg: number);
    get shininess(): number;

    set specular(arg: Color);
    get specular(): Color;

    set specularMap(arg: Texture|null);
    get specularMap(): Texture|null;

    set specularMapChannel(arg: string);
    get specularMapChannel(): string;

    set specularMapOffset(arg: Vec2);
    get specularMapOffset(): Vec2;

    set specularMapRotation(arg: number);
    get specularMapRotation(): number;

    set specularMapTiling(arg: Vec2);
    get specularMapTiling(): Vec2;

    set specularMapUv(arg: number);
    get specularMapUv(): number;

    set specularTint(arg: boolean);
    get specularTint(): boolean;

    set specularVertexColor(arg: boolean);
    get specularVertexColor(): boolean;

    set specularVertexColorChannel(arg: string);
    get specularVertexColorChannel(): string;

    set specularityFactor(arg: number);
    get specularityFactor(): number;

    set specularityFactorMap(arg: Texture|null);
    get specularityFactorMap(): Texture|null;

    set specularityFactorMapChannel(arg: string);
    get specularityFactorMapChannel(): string;

    set specularityFactorMapOffset(arg: Vec2);
    get specularityFactorMapOffset(): Vec2;

    set specularityFactorMapRotation(arg: number);
    get specularityFactorMapRotation(): number;

    set specularityFactorMapTiling(arg: Vec2);
    get specularityFactorMapTiling(): Vec2;

    set specularityFactorMapUv(arg: number);
    get specularityFactorMapUv(): number;

    set sphereMap(arg: Texture|null);
    get sphereMap(): Texture|null;

    set twoSidedLighting(arg: boolean);
    get twoSidedLighting(): boolean;

    set useFog(arg: boolean);
    get useFog(): boolean;

    set useGammaTonemap(arg: boolean);
    get useGammaTonemap(): boolean;

    set useLighting(arg: boolean);
    get useLighting(): boolean;

    set useMetalness(arg: boolean);
    get useMetalness(): boolean;

    set useSkybox(arg: boolean);
    get useSkybox(): boolean;

    /**
     * @type {Object<string, string>}
     * @private
     */
    private _chunks;
    _uniformCache: {};
    set shader(arg: any);
    get shader(): any;
    /**
     * Object containing custom shader chunks that will replace default ones.
     *
     * @type {Object<string, string>}
     */
    set chunks(arg: {
        [x: string]: string;
    });
    get chunks(): {
        [x: string]: string;
    };
    /**
     * Copy a `StandardMaterial`.
     *
     * @param {StandardMaterial} source - The material to copy from.
     * @returns {StandardMaterial} The destination material.
     */
    copy(source: StandardMaterial): StandardMaterial;
    _setParameter(name: any, value: any): void;
    _setParameters(parameters: any): void;
    _processParameters(paramsName: any): void;
    _updateMap(p: any): void;
    _allocUniform(name: any, allocFunc: any): any;
    getUniform(name: any, device: any, scene: any): any;
    updateEnvUniforms(device: any, scene: any): void;
}

/**
 * Manages creation of {@link ElementComponent}s.
 *
 * @augments ComponentSystem
 */
declare class ElementComponentSystem extends ComponentSystem {
    id: string;
    ComponentType: typeof ElementComponent;
    DataType: typeof ElementComponentData;
    schema: string[];
    _unicodeConverter: any;
    _rtlReorder: any;
    _defaultTexture: Texture;
    defaultImageMaterial: StandardMaterial;
    defaultImage9SlicedMaterial: StandardMaterial;
    defaultImage9TiledMaterial: StandardMaterial;
    defaultImageMaskMaterial: StandardMaterial;
    defaultImage9SlicedMaskMaterial: StandardMaterial;
    defaultImage9TiledMaskMaterial: StandardMaterial;
    defaultScreenSpaceImageMaterial: StandardMaterial;
    defaultScreenSpaceImage9SlicedMaterial: StandardMaterial;
    defaultScreenSpaceImage9TiledMaterial: StandardMaterial;
    defaultScreenSpaceImageMask9SlicedMaterial: StandardMaterial;
    defaultScreenSpaceImageMask9TiledMaterial: StandardMaterial;
    defaultScreenSpaceImageMaskMaterial: StandardMaterial;
    _defaultTextMaterials: {};
    defaultImageMaterials: any[];
    initializeComponentData(component: any, data: any, properties: any): void;
    onRemoveComponent(entity: any, component: any): void;
    cloneComponent(entity: any, clone: any): Component;
    getTextElementMaterial(screenSpace: any, msdf: any, textAttibutes: any): any;
    _createBaseImageMaterial(): StandardMaterial;
    getImageElementMaterial(screenSpace: any, mask: any, nineSliced: any, nineSliceTiled: any): StandardMaterial;
    registerUnicodeConverter(func: any): void;
    registerRtlReorder(func: any): void;
    getUnicodeConverter(): any;
    getRtlReorder(): any;
}


/** @typedef {import('../graphics/texture.js').Texture} Texture */
/**
 * Represents the resource of a font asset.
 */
declare class Font {
    /**
     * Create a new Font instance.
     *
     * @param {Texture[]} textures - The font textures.
     * @param {object} data - The font data.
     */
    constructor(textures: Texture[], data: object);
    type: any;
    em: number;
    /**
     * The font textures.
     *
     * @type {Texture[]}
     */
    textures: Texture[];
    /**
     * The font intensity.
     *
     * @type {number}
     */
    intensity: number;
    _data: any;
    set data(arg: any);
    get data(): any;
}


/**
 * Represents the resource of a canvas font asset.
 *
 * @augments EventHandler
 * @ignore
 */
declare class CanvasFont extends EventHandler {
    /**
     * Create a new CanvasFont instance.
     *
     * @param {AppBase} app - The application.
     * @param {object} options - The font options.
     * @param {string} [options.fontName] - The name of the font. CSS font names are supported.
     * Defaults to 'Arial'.
     * @param {string} [options.fontWeight] - The weight of the font, e.g. 'normal', 'bold'.
     * Defaults to 'normal'.
     * @param {number} [options.fontSize] - The font size in pixels. Defaults to 32.
     * @param {Color} [options.color] - The font color.Defaults to white.
     * @param {number} [options.width] - The width of each texture atlas. Defaults to 512.
     * @param {number} [options.height] - The height of each texture atlas. Defaults to 512.
     * @param {number} [options.padding] - Amount of glyph padding in pixels that is added to each
     * glyph in the atlas. Defaults to 0.
     */
    constructor(app: AppBase, options?: {
        fontName?: string;
        fontWeight?: string;
        fontSize?: number;
        color?: Color;
        width?: number;
        height?: number;
        padding?: number;
    });
    type: string;
    app: AppBase;
    intensity: number;
    fontWeight: string;
    fontSize: number;
    glyphSize: number;
    fontName: string;
    color: Color;
    padding: number;
    textures: Texture[];
    chars: string;
    data: {};
    /**
     * Render the necessary textures for all characters in a string to be used for the canvas font.
     *
     * @param {string} text - The list of characters to render into the texture atlas.
     */
    createTextures(text: string): void;
    /**
     * Update the list of characters to include in the atlas to include those provided and
     * re-render the texture atlas to include all the characters that have been supplied so far.
     *
     * @param {string} text - The list of characters to add to the texture atlas.
     */
    updateTextures(text: string): void;
    /**
     * Destroys the font. This also destroys the textures owned by the font.
     */
    destroy(): void;
    /**
     * @param {HTMLCanvasElement} canvas - The canvas used to render the font.
     * @param {string} clearColor - The color to clear the canvas with.
     * @returns {CanvasRenderingContext2D} - A 2D rendering contxt.
     * @private
     */
    private _getAndClearContext;
    /**
     * @param {Color} color - The color to covert.
     * @param {boolean} alpha - Whether to include the alpha channel.
     * @returns {string} The hex string for the color.
     * @private
     */
    private _colorToRgbString;
    /**
     * @param {CanvasRenderingContext2D} context - The canvas 2D context.
     * @param {string} char - The character to render.
     * @param {number} x - The x position to render the character at.
     * @param {number} y - The y position to render the character at.
     * @param {number} color - The color to render the character in.
     * @ignore
     */
    renderCharacter(context: CanvasRenderingContext2D, char: string, x: number, y: number, color: number): void;
    /**
     * Renders an array of characters into one or more textures atlases.
     *
     * @param {string[]} charsArray - The list of characters to render.
     * @private
     */
    private _renderAtlas;
    /**
     * @param {string[]} chars - A list of characters.
     * @param {string} fontName - The font name.
     * @param {number} width - The width of the texture atlas.
     * @param {number} height - The height of the texture atlas.
     * @returns {object} The font JSON object.
     * @private
     */
    private _createJson;
    /**
     * @param {object} json - Font data.
     * @param {string} char - The character to add.
     * @param {number} charCode - The code point number of the character to add.
     * @param {number} x - The x position of the character.
     * @param {number} y - The y position of the character.
     * @param {number} w - The width of the character.
     * @param {number} h - The height of the character.
     * @param {number} xoffset - The x offset of the character.
     * @param {number} yoffset - The y offset of the character.
     * @param {number} xadvance - The x advance of the character.
     * @param {number} mapNum - The map number of the character.
     * @param {number} mapW - The width of the map.
     * @param {number} mapH - The height of the map.
     * @private
     */
    private _addChar;
    /**
     * Take a unicode string and produce the set of characters used to create that string.
     * e.g. "abcabcabc" -> ['a', 'b', 'c']
     *
     * @param {string} text - The unicode string to process.
     * @returns {string[]} The set of characters used to create the string.
     * @private
     */
    private _normalizeCharsSet;
    /**
     * Calculate some metrics that aren't available via the browser API, notably character height
     * and descent size.
     *
     * @param {string} text - The text to measure.
     * @returns {{ascent: number, descent: number, height: number}} The metrics of the text.
     * @private
     */
    private _getTextMetrics;
}

declare class ImageElement {
    constructor(element: any);
    _element: any;
    _entity: any;
    _system: any;
    _textureAsset: any;
    _texture: any;
    _materialAsset: any;
    _material: any;
    _spriteAsset: any;
    _sprite: any;
    _spriteFrame: number;
    _pixelsPerUnit: any;
    _targetAspectRatio: number;
    _rect: Vec4;
    _mask: boolean;
    _maskRef: number;
    _outerScale: Vec2;
    _outerScaleUniform: Float32Array;
    _innerOffset: Vec4;
    _innerOffsetUniform: Float32Array;
    _atlasRect: Vec4;
    _atlasRectUniform: Float32Array;
    _defaultMesh: Mesh;
    _renderable: ImageRenderable;
    _color: Color;
    _colorUniform: Float32Array;
    _updateAabbFunc: any;
    destroy(): void;
    set textureAsset(arg: any);
    get textureAsset(): any;
    set spriteAsset(arg: any);
    get spriteAsset(): any;
    set materialAsset(arg: any);
    get materialAsset(): any;
    _onResolutionChange(res: any): void;
    _onParentResizeOrPivotChange(): void;
    _onScreenSpaceChange(value: any): void;
    _onScreenChange(screen: any, previous: any): void;
    _onDrawOrderChange(order: any): void;
    _hasUserMaterial(): boolean;
    _use9Slicing(): boolean;
    _updateMaterial(screenSpace: any): void;
    _createMesh(): Mesh;
    _updateMesh(mesh: any): void;
    _meshDirty: boolean;
    _updateSprite(): void;
    set mesh(arg: any);
    get mesh(): any;
    refreshMesh(): void;
    _updateAabb(aabb: any): any;
    _toggleMask(): void;
    _onMaterialLoad(asset: any): void;
    set material(arg: any);
    get material(): any;
    _onMaterialAdded(asset: any): void;
    _bindMaterialAsset(asset: any): void;
    _unbindMaterialAsset(asset: any): void;
    _onMaterialChange(): void;
    _onMaterialRemove(): void;
    _onTextureAdded(asset: any): void;
    _bindTextureAsset(asset: any): void;
    _unbindTextureAsset(asset: any): void;
    _onTextureLoad(asset: any): void;
    set texture(arg: any);
    get texture(): any;
    _onTextureChange(asset: any): void;
    _onTextureRemove(asset: any): void;
    _onSpriteAssetAdded(asset: any): void;
    _bindSpriteAsset(asset: any): void;
    _unbindSpriteAsset(asset: any): void;
    _onSpriteAssetLoad(asset: any): void;
    set sprite(arg: any);
    get sprite(): any;
    _onSpriteAssetChange(asset: any): void;
    _onSpriteAssetRemove(asset: any): void;
    _bindSprite(sprite: any): void;
    _unbindSprite(sprite: any): void;
    _onSpriteMeshesChange(): void;
    _onSpritePpuChange(): void;
    _onAtlasTextureChange(): void;
    _onTextureAtlasLoad(atlasAsset: any): void;
    onEnable(): void;
    onDisable(): void;
    _setStencil(stencilParams: any): void;
    set color(arg: Color);
    get color(): Color;
    set opacity(arg: number);
    get opacity(): number;
    set rect(arg: Vec4);
    get rect(): Vec4;
    set spriteFrame(arg: number);
    get spriteFrame(): number;
    set mask(arg: boolean);
    get mask(): boolean;
    set pixelsPerUnit(arg: any);
    get pixelsPerUnit(): any;
    get aabb(): any;
}

declare class ImageRenderable {
    constructor(entity: any, mesh: any, material: any);
    _entity: any;
    _element: any;
    model: Model;
    node: GraphNode;
    mesh: any;
    meshInstance: MeshInstance;
    _meshDirty: boolean;
    unmaskMeshInstance: MeshInstance;
    destroy(): void;
    setMesh(mesh: any): void;
    setMask(mask: any): void;
    setMaterial(material: any): void;
    setParameter(name: any, value: any): void;
    deleteParameter(name: any): void;
    setUnmaskDrawOrder(): void;
    setDrawOrder(drawOrder: any): void;
    setCull(cull: any): void;
    setScreenSpace(screenSpace: any): void;
    setLayer(layer: any): void;
    forceUpdateAabb(mask: any): void;
    setAabbFunc(fn: any): void;
}

declare class LocalizedAsset extends EventHandler {
    constructor(app: any);
    _app: any;
    _autoLoad: boolean;
    _disableLocalization: boolean;
    _defaultAsset: any;
    _localizedAsset: any;
    set defaultAsset(arg: any);
    get defaultAsset(): any;
    set localizedAsset(arg: any);
    get localizedAsset(): any;
    set autoLoad(arg: boolean);
    get autoLoad(): boolean;
    set disableLocalization(arg: boolean);
    get disableLocalization(): boolean;
    _bindDefaultAsset(): void;
    _unbindDefaultAsset(): void;
    _onDefaultAssetAdd(asset: any): void;
    _onDefaultAssetRemove(asset: any): void;
    _bindLocalizedAsset(): void;
    _unbindLocalizedAsset(): void;
    _onLocalizedAssetAdd(asset: any): void;
    _onLocalizedAssetLoad(asset: any): void;
    _onLocalizedAssetChange(asset: any, name: any, newValue: any, oldValue: any): void;
    _onLocalizedAssetRemove(asset: any): void;
    _onLocaleAdd(locale: any, assetId: any): void;
    _onLocaleRemove(locale: any, assetId: any): void;
    _onSetLocale(locale: any): void;
    destroy(): void;
}

declare class TextElement {
    constructor(element: any);
    _element: any;
    _system: any;
    _entity: any;
    _text: string;
    _symbols: any[];
    _colorPalette: any[];
    _outlinePalette: any[];
    _shadowPalette: any[];
    _symbolColors: any[];
    _symbolOutlineParams: any[];
    _symbolShadowParams: any[];
    _i18nKey: any;
    _fontAsset: LocalizedAsset;
    _font: any;
    _color: Color;
    _colorUniform: Float32Array;
    _spacing: number;
    _fontSize: number;
    _fontMinY: number;
    _fontMaxY: number;
    _originalFontSize: number;
    _maxFontSize: number;
    _minFontSize: number;
    _autoFitWidth: boolean;
    _autoFitHeight: boolean;
    _maxLines: number;
    _lineHeight: number;
    _scaledLineHeight: number;
    _wrapLines: boolean;
    _drawOrder: number;
    _alignment: Vec2;
    _autoWidth: boolean;
    _autoHeight: boolean;
    width: number;
    height: number;
    _node: GraphNode;
    _model: Model;
    _meshInfo: any[];
    _material: any;
    _aabbDirty: boolean;
    _aabb: BoundingBox;
    _noResize: boolean;
    _currentMaterialType: any;
    _maskedMaterialSrc: any;
    _rtlReorder: boolean;
    _unicodeConverter: boolean;
    _rtl: boolean;
    _outlineColor: Color;
    _outlineColorUniform: Float32Array;
    _outlineThicknessScale: number;
    _outlineThickness: number;
    _shadowColor: Color;
    _shadowColorUniform: Float32Array;
    _shadowOffsetScale: number;
    _shadowOffset: Vec2;
    _shadowOffsetUniform: Float32Array;
    _enableMarkup: boolean;
    _rangeStart: number;
    _rangeEnd: number;
    destroy(): void;
    set font(arg: any);
    get font(): any;
    _onParentResize(width: any, height: any): void;
    _onScreenChange(screen: any): void;
    _onScreenSpaceChange(value: any): void;
    _onDrawOrderChange(order: any): void;
    _onPivotChange(pivot: any): void;
    _onLocaleSet(locale: any): void;
    _onLocalizationData(locale: any, messages: any): void;
    _resetLocalizedText(): void;
    _setText(text: any): void;
    _updateText(text: any): void;
    _removeMeshInstance(meshInstance: any): void;
    _setMaterial(material: any): void;
    _updateMaterial(screenSpace: any): void;
    _updateMaterialEmissive(): void;
    _updateMaterialOutline(): void;
    _updateMaterialShadow(): void;
    _isWordBoundary(char: any): boolean;
    _isValidNextChar(nextchar: any): boolean;
    _isNextCJKBoundary(char: any, nextchar: any): boolean;
    _isNextCJKWholeWord(nextchar: any): boolean;
    _updateMeshes(): void;
    _lineWidths: any[];
    _lineContents: any[];
    set autoWidth(arg: boolean);
    get autoWidth(): boolean;
    set autoHeight(arg: boolean);
    get autoHeight(): boolean;
    _onFontRender(): void;
    _onFontLoad(asset: any): void;
    _onFontChange(asset: any, name: any, _new: any, _old: any): void;
    _onFontRemove(asset: any): void;
    _setTextureParams(mi: any, texture: any): void;
    _getPxRange(font: any): number;
    _getUv(char: any): any;
    onEnable(): void;
    onDisable(): void;
    _setStencil(stencilParams: any): void;
    _shouldAutoFitWidth(): boolean;
    _shouldAutoFitHeight(): boolean;
    _shouldAutoFit(): boolean;
    _calculateCharsPerTexture(symbolIndex: any): {};
    _updateRenderRange(): void;
    set text(arg: string);
    get text(): string;
    set key(arg: any);
    get key(): any;
    set color(arg: Color);
    get color(): Color;
    set opacity(arg: number);
    get opacity(): number;
    set lineHeight(arg: number);
    get lineHeight(): number;
    set wrapLines(arg: boolean);
    get wrapLines(): boolean;
    get lines(): any[];
    set spacing(arg: number);
    get spacing(): number;
    set fontSize(arg: number);
    get fontSize(): number;
    set fontAsset(arg: any);
    get fontAsset(): any;
    set alignment(arg: Vec2);
    get alignment(): Vec2;
    set rtlReorder(arg: boolean);
    get rtlReorder(): boolean;
    set unicodeConverter(arg: boolean);
    get unicodeConverter(): boolean;
    get aabb(): BoundingBox;
    set outlineColor(arg: Color);
    get outlineColor(): Color;
    set outlineThickness(arg: number);
    get outlineThickness(): number;
    set shadowColor(arg: Color);
    get shadowColor(): Color;
    set shadowOffset(arg: Vec2);
    get shadowOffset(): Vec2;
    set minFontSize(arg: number);
    get minFontSize(): number;
    set maxFontSize(arg: number);
    get maxFontSize(): number;
    set autoFitWidth(arg: boolean);
    get autoFitWidth(): boolean;
    set autoFitHeight(arg: boolean);
    get autoFitHeight(): boolean;
    set maxLines(arg: number);
    get maxLines(): number;
    set enableMarkup(arg: boolean);
    get enableMarkup(): boolean;
    get symbols(): any[];
    get symbolColors(): any[];
    get symbolOutlineParams(): any[];
    get symbolShadowParams(): any[];
    get rtl(): boolean;
    set rangeStart(arg: number);
    get rangeStart(): number;
    set rangeEnd(arg: number);
    get rangeEnd(): number;
}








/**
 * ElementComponents are used to construct user interfaces. An ElementComponent's [type](#type)
 * property can be configured in 3 main ways: as a text element, as an image element or as a group
 * element. If the ElementComponent has a {@link ScreenComponent} ancestor in the hierarchy, it
 * will be transformed with respect to the coordinate system of the screen. If there is no
 * {@link ScreenComponent} ancestor, the ElementComponent will be transformed like any other
 * entity.
 *
 * You should never need to use the ElementComponent constructor. To add an ElementComponent to a
 * {@link Entity}, use {@link Entity#addComponent}:
 *
 * ```javascript
 * // Add an element component to an entity with the default options
 * let entity = pc.Entity();
 * entity.addComponent("element"); // This defaults to a 'group' element
 * ```
 *
 * To create a simple text-based element:
 *
 * ```javascript
 * entity.addComponent("element", {
 *     anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5), // centered anchor
 *     fontAsset: fontAsset,
 *     fontSize: 128,
 *     pivot: new pc.Vec2(0.5, 0.5),            // centered pivot
 *     text: "Hello World!",
 *     type: pc.ELEMENTTYPE_TEXT
 * });
 * ```
 *
 * Once the ElementComponent is added to the entity, you can set and get any of its properties:
 *
 * ```javascript
 * entity.element.color = pc.Color.RED; // Set the element's color to red
 *
 * console.log(entity.element.color);   // Get the element's color and print it
 * ```
 *
 * Relevant 'Engine-only' examples:
 * - [Basic text rendering](http://playcanvas.github.io/#user-interface/text-basic)
 * - [Rendering text outlines](http://playcanvas.github.io/#user-interface/text-outline)
 * - [Adding drop shadows to text](http://playcanvas.github.io/#user-interface/text-drop-shadow)
 * - [Coloring text with markup](http://playcanvas.github.io/#user-interface/text-markup)
 * - [Wrapping text](http://playcanvas.github.io/#user-interface/text-wrap)
 * - [Typewriter text](http://playcanvas.github.io/#user-interface/text-typewriter)
 *
 * @property {Color} color The color of the image for {@link ELEMENTTYPE_IMAGE} types or the color
 * of the text for {@link ELEMENTTYPE_TEXT} types.
 * @property {number} opacity The opacity of the image for {@link ELEMENTTYPE_IMAGE} types or the
 * text for {@link ELEMENTTYPE_TEXT} types.
 * @property {Color} outlineColor The text outline effect color and opacity. Only works for
 * {@link ELEMENTTYPE_TEXT} types.
 * @property {number} outlineThickness The width of the text outline effect. Only works for
 * {@link ELEMENTTYPE_TEXT} types.
 * @property {Color} shadowColor The text shadow effect color and opacity. Only works for
 * {@link ELEMENTTYPE_TEXT} types.
 * @property {Vec2} shadowOffset The text shadow effect shift amount from original text. Only works
 * for {@link ELEMENTTYPE_TEXT} types.
 * @property {boolean} autoWidth Automatically set the width of the component to be the same as the
 * textWidth. Only works for {@link ELEMENTTYPE_TEXT} types.
 * @property {boolean} autoHeight Automatically set the height of the component to be the same as
 * the textHeight. Only works for {@link ELEMENTTYPE_TEXT} types.
 * @property {string} fitMode Set how the content should be fitted and preserve the aspect ratio of
 * the source texture or sprite. Only works for {@link ELEMENTTYPE_IMAGE} types.
 * @property {number} fontAsset The id of the font asset used for rendering the text. Only works
 * for {@link ELEMENTTYPE_TEXT} types.
 * @property {Font} font The font used for rendering the text. Only works for
 * {@link ELEMENTTYPE_TEXT} types.
 * @property {number} fontSize The size of the font. Only works for {@link ELEMENTTYPE_TEXT} types.
 * @property {boolean} autoFitWidth When true the font size and line height will scale so that the
 * text fits inside the width of the Element. The font size will be scaled between minFontSize and
 * maxFontSize. The value of autoFitWidth will be ignored if autoWidth is true.
 * @property {boolean} autoFitHeight When true the font size and line height will scale so that the
 * text fits inside the height of the Element. The font size will be scaled between minFontSize and
 * maxFontSize. The value of autoFitHeight will be ignored if autoHeight is true.
 * @property {number} minFontSize The minimum size that the font can scale to when autoFitWidth or
 * autoFitHeight are true.
 * @property {number} maxFontSize The maximum size that the font can scale to when autoFitWidth or
 * autoFitHeight are true.
 * @property {number} spacing The spacing between the letters of the text. Only works for
 * {@link ELEMENTTYPE_TEXT} types.
 * @property {number} lineHeight The height of each line of text. Only works for
 * {@link ELEMENTTYPE_TEXT} types.
 * @property {boolean} wrapLines Whether to automatically wrap lines based on the element width.
 * Only works for {@link ELEMENTTYPE_TEXT} types, and when autoWidth is set to false.
 * @property {number} maxLines The maximum number of lines that the Element can wrap to. Any
 * leftover text will be appended to the last line. Set this to null to allow unlimited lines.
 * @property {Vec2} alignment The horizontal and vertical alignment of the text. Values range from
 * 0 to 1 where [0,0] is the bottom left and [1,1] is the top right.  Only works for
 * {@link ELEMENTTYPE_TEXT} types.
 * @property {string} text The text to render. Only works for {@link ELEMENTTYPE_TEXT} types. To
 * override certain text styling properties on a per-character basis, the text can optionally
 * include markup tags contained within square brackets. Supported tags are:
 *
 * - `color` - override the element's `color` property. Examples:
 *   - `[color="#ff0000"]red text[/color]`
 *   - `[color="#00ff00"]green text[/color]`
 *   - `[color="#0000ff"]blue text[/color]`
 * - `outline` - override the element's `outlineColor` and `outlineThickness` properties. Example:
 *   - `[outline color="#ffffff" thickness="0.5"]text[/outline]`
 * - `shadow` - override the element's `shadowColor` and `shadowOffset` properties. Examples:
 *   - `[shadow color="#ffffff" offset="0.5"]text[/shadow]`
 *   - `[shadow color="#000000" offsetX="0.1" offsetY="0.2"]text[/shadow]`
 *
 * Note that markup tags are only processed if the text element's `enableMarkup` property is set to
 * true.
 * @property {string} key The localization key to use to get the localized text from
 * {@link Application#i18n}. Only works for {@link ELEMENTTYPE_TEXT} types.
 * @property {number} textureAsset The id of the texture asset to render. Only works for
 * {@link ELEMENTTYPE_IMAGE} types.
 * @property {Texture} texture The texture to render. Only works for {@link ELEMENTTYPE_IMAGE}
 * types.
 * @property {number} spriteAsset The id of the sprite asset to render. Only works for
 * {@link ELEMENTTYPE_IMAGE} types which can render either a texture or a sprite.
 * @property {Sprite} sprite The sprite to render. Only works for {@link ELEMENTTYPE_IMAGE} types
 * which can render either a texture or a sprite.
 * @property {number} spriteFrame The frame of the sprite to render. Only works for
 * {@link ELEMENTTYPE_IMAGE} types who have a sprite assigned.
 * @property {number} pixelsPerUnit The number of pixels that map to one PlayCanvas unit. Only
 * works for {@link ELEMENTTYPE_IMAGE} types who have a sliced sprite assigned.
 * @property {number} materialAsset The id of the material asset to use when rendering an image.
 * Only works for {@link ELEMENTTYPE_IMAGE} types.
 * @property {Material} material The material to use when rendering an image. Only works for
 * {@link ELEMENTTYPE_IMAGE} types.
 * @property {Vec4} rect Specifies which region of the texture to use in order to render an image.
 * Values range from 0 to 1 and indicate u, v, width, height. Only works for
 * {@link ELEMENTTYPE_IMAGE} types.
 * @property {boolean} rtlReorder Reorder the text for RTL languages using a function registered
 * by `app.systems.element.registerUnicodeConverter`.
 * @property {boolean} unicodeConverter Convert unicode characters using a function registered by
 * `app.systems.element.registerUnicodeConverter`.
 * @property {boolean} enableMarkup Flag for enabling markup processing. Only works for
 * {@link ELEMENTTYPE_TEXT} types. Defaults to false.
 * @property {number} rangeStart Index of the first character to render. Only works for
 * {@link ELEMENTTYPE_TEXT} types.
 * @property {number} rangeEnd Index of the last character to render. Only works for
 * {@link ELEMENTTYPE_TEXT} types.
 * @property {boolean} mask Switch Image Element into a mask. Masks do not render into the scene,
 * but instead limit child elements to only be rendered where this element is rendered.
 * @augments Component
 */
declare class ElementComponent extends Component {
    /**
     * Create a new ElementComponent instance.
     *
     * @param {ElementComponentSystem} system - The ComponentSystem that created this Component.
     * @param {Entity} entity - The Entity that this Component is attached to.
     */
    constructor(system: ElementComponentSystem, entity: Entity);

    set alignment(arg: Vec2);
    get alignment(): Vec2;

    set autoFitHeight(arg: boolean);
    get autoFitHeight(): boolean;

    set autoFitWidth(arg: boolean);
    get autoFitWidth(): boolean;

    set autoHeight(arg: boolean);
    get autoHeight(): boolean;

    set autoWidth(arg: boolean);
    get autoWidth(): boolean;

    set color(arg: Color);
    get color(): Color;

    set enableMarkup(arg: boolean);
    get enableMarkup(): boolean;

    set font(arg: Font|CanvasFont);
    get font(): Font|CanvasFont;

    set fontAsset(arg: number);
    get fontAsset(): number;

    set fontSize(arg: number);
    get fontSize(): number;

    set key(arg: string);
    get key(): string;

    set lineHeight(arg: number);
    get lineHeight(): number;

    set mask(arg: boolean);
    get mask(): boolean;

    set material(arg: Material);
    get material(): Material;

    set materialAsset(arg: number);
    get materialAsset(): number;

    set maxFontSize(arg: number);
    get maxFontSize(): number;

    set maxLines(arg: number);
    get maxLines(): number;

    set minFontSize(arg: number);
    get minFontSize(): number;

    set opacity(arg: number);
    get opacity(): number;

    set outlineColor(arg: Color);
    get outlineColor(): Color;

    set outlineThickness(arg: number);
    get outlineThickness(): number;

    set pixelsPerUnit(arg: number);
    get pixelsPerUnit(): number;

    set rangeEnd(arg: number);
    get rangeEnd(): number;

    set rangeStart(arg: number);
    get rangeStart(): number;

    set rect(arg: Vec4);
    get rect(): Vec4;

    set rtlReorder(arg: boolean);
    get rtlReorder(): boolean;

    set shadowColor(arg: Color);
    get shadowColor(): Color;

    set shadowOffset(arg: number);
    get shadowOffset(): number;

    set spacing(arg: number);
    get spacing(): number;

    set sprite(arg: Sprite);
    get sprite(): Sprite;

    set spriteAsset(arg: number);
    get spriteAsset(): number;

    set spriteFrame(arg: number);
    get spriteFrame(): number;

    set text(arg: string);
    get text(): string;

    set texture(arg: Texture);
    get texture(): Texture;

    set textureAsset(arg: number);
    get textureAsset(): number;

    set unicodeConverter(arg: boolean);
    get unicodeConverter(): boolean;

    set wrapLines(arg: boolean);
    get wrapLines(): boolean;

    _beingInitialized: boolean;
    _anchor: Vec4;
    _localAnchor: Vec4;
    _pivot: Vec2;
    _width: number;
    _calculatedWidth: number;
    _height: number;
    _calculatedHeight: number;
    _margin: Vec4;
    _modelTransform: Mat4;
    _screenToWorld: Mat4;
    _anchorTransform: Mat4;
    _anchorDirty: boolean;
    _parentWorldTransform: Mat4;
    _screenTransform: Mat4;
    _screenCorners: Vec3[];
    _canvasCorners: Vec2[];
    _worldCorners: Vec3[];
    _cornersDirty: boolean;
    _canvasCornersDirty: boolean;
    _worldCornersDirty: boolean;
    /**
     * The Entity with a {@link ScreenComponent} that this component belongs to. This is
     * automatically set when the component is a child of a ScreenComponent.
     *
     * @type {Entity|null}
     */
    screen: Entity | null;
    _type: string;
    _image: ImageElement;
    _text: TextElement;
    _group: any;
    _drawOrder: number;
    _fitMode: string;
    _useInput: boolean;
    _layers: number[];
    _addedModels: any[];
    _batchGroupId: number;
    _batchGroup: any;
    _offsetReadAt: number;
    _maskOffset: number;
    _maskedBy: any;
    /**
     * Fired when the mouse is pressed while the cursor is on the component. Only fired when
     * useInput is true.
     *
     * @event ElementComponent#mousedown
     * @param {ElementMouseEvent} event - The event.
     */
    /**
     * Fired when the mouse is released while the cursor is on the component. Only fired when
     * useInput is true.
     *
     * @event ElementComponent#mouseup
     * @param {ElementMouseEvent} event - The event.
     */
    /**
     * Fired when the mouse cursor enters the component. Only fired when useInput is true.
     *
     * @event ElementComponent#mouseenter
     * @param {ElementMouseEvent} event - The event.
     */
    /**
     * Fired when the mouse cursor leaves the component. Only fired when useInput is true.
     *
     * @event ElementComponent#mouseleave
     * @param {ElementMouseEvent} event - The event.
     */
    /**
     * Fired when the mouse cursor is moved on the component. Only fired when useInput is true.
     *
     * @event ElementComponent#mousemove
     * @param {ElementMouseEvent} event - The event.
     */
    /**
     * Fired when the mouse wheel is scrolled on the component. Only fired when useInput is true.
     *
     * @event ElementComponent#mousewheel
     * @param {ElementMouseEvent} event - The event.
     */
    /**
     * Fired when the mouse is pressed and released on the component or when a touch starts and
     * ends on the component. Only fired when useInput is true.
     *
     * @event ElementComponent#click
     * @param {ElementMouseEvent|ElementTouchEvent} event - The event.
     */
    /**
     * Fired when a touch starts on the component. Only fired when useInput is true.
     *
     * @event ElementComponent#touchstart
     * @param {ElementTouchEvent} event - The event.
     */
    /**
     * Fired when a touch ends on the component. Only fired when useInput is true.
     *
     * @event ElementComponent#touchend
     * @param {ElementTouchEvent} event - The event.
     */
    /**
     * Fired when a touch moves after it started touching the component. Only fired when useInput
     * is true.
     *
     * @event ElementComponent#touchmove
     * @param {ElementTouchEvent} event - The event.
     */
    /**
     * Fired when a touch is canceled on the component. Only fired when useInput is true.
     *
     * @event ElementComponent#touchcancel
     * @param {ElementTouchEvent} event - The event.
     */
    get _absLeft(): number;
    get _absRight(): number;
    get _absTop(): number;
    get _absBottom(): number;
    get _hasSplitAnchorsX(): boolean;
    get _hasSplitAnchorsY(): boolean;
    get aabb(): any;
    /**
     * Specifies where the left, bottom, right and top edges of the component are anchored relative
     * to its parent. Each value ranges from 0 to 1. e.g. a value of [0, 0, 0, 0] means that the
     * element will be anchored to the bottom left of its parent. A value of [1, 1, 1, 1] means it
     * will be anchored to the top right. A split anchor is when the left-right or top-bottom pairs
     * of the anchor are not equal. In that case the component will be resized to cover that entire
     * area. e.g. a value of [0, 0, 1, 1] will make the component resize exactly as its parent.
     *
     * @type {Vec4}
     */
    set anchor(arg: Vec4);
    get anchor(): Vec4;
    /**
     * Assign element to a specific batch group (see {@link BatchGroup}). Default is -1 (no group).
     *
     * @type {number}
     */
    set batchGroupId(arg: number);
    get batchGroupId(): number;
    /**
     * The distance from the bottom edge of the anchor. Can be used in combination with a split
     * anchor to make the component's top edge always be 'top' units away from the top.
     *
     * @type {number}
     */
    set bottom(arg: number);
    get bottom(): number;
    /**
     * The width at which the element will be rendered. In most cases this will be the same as
     * `width`. However, in some cases the engine may calculate a different width for the element,
     * such as when the element is under the control of a {@link LayoutGroupComponent}. In these
     * scenarios, `calculatedWidth` may be smaller or larger than the width that was set in the
     * editor.
     *
     * @type {number}
     */
    set calculatedWidth(arg: number);
    get calculatedWidth(): number;
    /**
     * The height at which the element will be rendered. In most cases this will be the same as
     * `height`. However, in some cases the engine may calculate a different height for the element,
     * such as when the element is under the control of a {@link LayoutGroupComponent}. In these
     * scenarios, `calculatedHeight` may be smaller or larger than the height that was set in the
     * editor.
     *
     * @type {number}
     */
    set calculatedHeight(arg: number);
    get calculatedHeight(): number;
    /**
     * An array of 4 {@link Vec2}s that represent the bottom left, bottom right, top right and top
     * left corners of the component in canvas pixels. Only works for screen space element
     * components.
     *
     * @type {Vec2[]}
     */
    get canvasCorners(): Vec2[];
    /**
     * The draw order of the component. A higher value means that the component will be rendered on
     * top of other components.
     *
     * @type {number}
     */
    set drawOrder(arg: number);
    get drawOrder(): number;
    /**
     * The height of the element as set in the editor. Note that in some cases this may not reflect
     * the true height at which the element is rendered, such as when the element is under the
     * control of a {@link LayoutGroupComponent}. See `calculatedHeight` in order to ensure you are
     * reading the true height at which the element will be rendered.
     *
     * @type {number}
     */
    set height(arg: number);
    get height(): number;
    /**
     * An array of layer IDs ({@link Layer#id}) to which this element should belong. Don't push,
     * pop, splice or modify this array, if you want to change it - set a new one instead.
     *
     * @type {number[]}
     */
    set layers(arg: number[]);
    get layers(): number[];
    /**
     * The distance from the left edge of the anchor. Can be used in combination with a split
     * anchor to make the component's left edge always be 'left' units away from the left.
     *
     * @type {number}
     */
    set left(arg: number);
    get left(): number;
    /**
     * The distance from the left, bottom, right and top edges of the anchor. For example if we are
     * using a split anchor like [0,0,1,1] and the margin is [0,0,0,0] then the component will be
     * the same width and height as its parent.
     *
     * @type {Vec4}
     */
    set margin(arg: Vec4);
    get margin(): Vec4;
    /**
     * Get the entity that is currently masking this element.
     *
     * @type {Entity}
     * @private
     */
    private get maskedBy();
    /**
     * The position of the pivot of the component relative to its anchor. Each value ranges from 0
     * to 1 where [0,0] is the bottom left and [1,1] is the top right.
     *
     * @type {Vec2}
     */
    set pivot(arg: Vec2);
    get pivot(): Vec2;
    /**
     * The distance from the right edge of the anchor. Can be used in combination with a split
     * anchor to make the component's right edge always be 'right' units away from the right.
     *
     * @type {number}
     */
    set right(arg: number);
    get right(): number;
    /**
     * An array of 4 {@link Vec3}s that represent the bottom left, bottom right, top right and top
     * left corners of the component relative to its parent {@link ScreenComponent}.
     *
     * @type {Vec3[]}
     */
    get screenCorners(): Vec3[];
    /**
     * The width of the text rendered by the component. Only works for {@link ELEMENTTYPE_TEXT} types.
     *
     * @type {number}
     */
    get textWidth(): number;
    /**
     * The height of the text rendered by the component. Only works for {@link ELEMENTTYPE_TEXT} types.
     *
     * @type {number}
     */
    get textHeight(): number;
    /**
     * The distance from the top edge of the anchor. Can be used in combination with a split anchor
     * to make the component's bottom edge always be 'bottom' units away from the bottom.
     *
     * @type {number}
     */
    set top(arg: number);
    get top(): number;
    /**
     * The type of the ElementComponent. Can be:
     *
     * - {@link ELEMENTTYPE_GROUP}: The component can be used as a layout mechanism to create groups of
     * ElementComponents e.g. panels.
     * - {@link ELEMENTTYPE_IMAGE}: The component will render an image
     * - {@link ELEMENTTYPE_TEXT}: The component will render text
     *
     * @type {string}
     */
    set type(arg: string);
    get type(): string;
    /**
     * If true then the component will receive Mouse or Touch input events.
     *
     * @type {boolean}
     */
    set useInput(arg: boolean);
    get useInput(): boolean;
    /**
     * Set how the content should be fitted and preserve the aspect ratio of the source texture or sprite.
     * Only works for {@link ELEMENTTYPE_IMAGE} types. Can be:
     *
     * - {@link FITMODE_STRETCH}: Fit the content exactly to Element's bounding box.
     * - {@link FITMODE_CONTAIN}: Fit the content within the Element's bounding box while preserving its Aspect Ratio.
     * - {@link FITMODE_COVER}: Fit the content to cover the entire Element's bounding box while preserving its Aspect Ratio.
     *
     * @type {string}
     */
    set fitMode(arg: string);
    get fitMode(): string;
    /**
     * The width of the element as set in the editor. Note that in some cases this may not reflect
     * the true width at which the element is rendered, such as when the element is under the
     * control of a {@link LayoutGroupComponent}. See `calculatedWidth` in order to ensure you are
     * reading the true width at which the element will be rendered.
     *
     * @type {number}
     */
    set width(arg: number);
    get width(): number;
    /**
     * An array of 4 {@link Vec3}s that represent the bottom left, bottom right, top right and top
     * left corners of the component in world space. Only works for 3D element components.
     *
     * @type {Vec3[]}
     */
    get worldCorners(): Vec3[];
    _patch(): void;
    _unpatch(): void;
    _setPosition(x: any, y: any, z: any): any;
    _setLocalPosition(x: any, y: any, z: any): void;
    _sync(): any;
    _dirtyLocal: boolean;
    _dirtyWorld: boolean;
    _onInsert(parent: any): void;
    _dirtifyMask(): void;
    _onPrerender(): void;
    _bindScreen(screen: any): void;
    _unbindScreen(screen: any): void;
    _updateScreen(screen: any): void;
    syncMask(depth: any): void;
    _setMaskedBy(mask: any): void;
    _updateMask(currentMask: any, depth: any): void;
    _parseUpToScreen(): {
        screen: any;
        mask: any;
    };
    _onScreenResize(res: any): void;
    _onScreenSpaceChange(): void;
    _onScreenRemove(): void;
    _calculateLocalAnchors(): void;
    getOffsetPosition(x: any, y: any): Vec3;
    onLayersChanged(oldComp: any, newComp: any): void;
    onLayerAdded(layer: any): void;
    onLayerRemoved(layer: any): void;
    onRemove(): void;
    _calculateSize(propagateCalculatedWidth: any, propagateCalculatedHeight: any): void;
    _sizeDirty: boolean;
    _setWidth(w: any): void;
    _setHeight(h: any): void;
    _setCalculatedWidth(value: any, updateMargins: any): void;
    _setCalculatedHeight(value: any, updateMargins: any): void;
    _flagChildrenAsDirty(): void;
    addModelToLayers(model: any): void;
    removeModelFromLayers(model: any): void;
    getMaskOffset(): number;
    isVisibleForCamera(camera: any): boolean;
    _isScreenSpace(): boolean;
    _isScreenCulled(): boolean;
    _dirtyBatch(): void;
}

/**
 * Helper class that makes it easy to create Elements that can be dragged by the mouse or touch.
 *
 * @augments EventHandler
 */
declare class ElementDragHelper extends EventHandler {
    /**
     * Create a new ElementDragHelper instance.
     *
     * @param {ElementComponent} element - The Element that should become draggable.
     * @param {string} [axis] - Optional axis to constrain to, either 'x', 'y' or null.
     */
    constructor(element: ElementComponent, axis?: string);
    _element: ElementComponent;
    _app: AppBase;
    _axis: string;
    _enabled: boolean;
    _dragScale: Vec3;
    _dragStartMousePosition: Vec3;
    _dragStartHandlePosition: Vec3;
    _deltaMousePosition: Vec3;
    _deltaHandlePosition: Vec3;
    _isDragging: boolean;
    /**
     * Fired when a new drag operation starts.
     *
     * @event ElementDragHelper#drag:start
     */
    /**
     * Fired when the current new drag operation ends.
     *
     * @event ElementDragHelper#drag:end
     */
    /**
     * Fired whenever the position of the dragged element changes.
     *
     * @event ElementDragHelper#drag:move
     * @param {Vec3} value - The current position.
     */
    _toggleLifecycleListeners(onOrOff: any): void;
    _toggleDragListeners(onOrOff: any): void;
    _handleMouseUpOrTouchEnd: any;
    _hasDragListeners: boolean;
    _onMouseDownOrTouchStart(event: any): void;
    _dragCamera: any;
    _onMouseUpOrTouchEnd(): void;
    _screenToLocal(event: any): Vec3;
    _determineInputPosition(event: any): void;
    _chooseRayOriginAndDirection(): void;
    _calculateDragScale(): void;
    _onMove(event: any): void;
    destroy(): void;
    set enabled(arg: boolean);
    get enabled(): boolean;
    get isDragging(): boolean;
}



/**
 * A ScrollViewComponent enables a group of entities to behave like a masked scrolling area, with
 * optional horizontal and vertical scroll bars.
 *
 * @property {boolean} horizontal Whether to enable horizontal scrolling.
 * @property {boolean} vertical Whether to enable vertical scrolling.
 * @property {number} scrollMode Specifies how the scroll view should behave when the user scrolls
 * past the end of the content. Modes are defined as follows:
 *
 * - {@link SCROLL_MODE_CLAMP}: Content does not scroll any further than its bounds.
 * - {@link SCROLL_MODE_BOUNCE}: Content scrolls past its bounds and then gently bounces back.
 * - {@link SCROLL_MODE_INFINITE}: Content can scroll forever.
 *
 * @property {number} bounceAmount Controls how far the content should move before bouncing back.
 * @property {number} friction Controls how freely the content should move if thrown, i.e. By
 * flicking on a phone or by flinging the scroll wheel on a mouse. A value of 1 means that content
 * will stop immediately; 0 means that content will continue moving forever (or until the bounds of
 * the content are reached, depending on the scrollMode).
 * @property {boolean} useMouseWheel Whether to use mouse wheel for scrolling (horizontally and
 * vertically).
 * @property {Vec2} mouseWheelSensitivity Mouse wheel horizontal and vertical sensitivity. Only
 * used if useMouseWheel is set. Setting a direction to 0 will disable mouse wheel scrolling in
 * that direction. 1 is a default sensitivity that is considered to feel good. The values can be
 * set higher or lower than 1 to tune the sensitivity. Defaults to [1, 1].
 * @property {number} horizontalScrollbarVisibility Controls whether the horizontal scrollbar
 * should be visible all the time, or only visible when the content exceeds the size of the
 * viewport.
 * @property {number} verticalScrollbarVisibility Controls whether the vertical scrollbar should be
 * visible all the time, or only visible when the content exceeds the size of the viewport.
 * @property {Entity} viewportEntity The entity to be used as the masked viewport area, within
 * which the content will scroll. This entity must have an ElementGroup component.
 * @property {Entity} contentEntity The entity which contains the scrolling content itself. This
 * entity must have an Element component.
 * @property {Entity} horizontalScrollbarEntity The entity to be used as the vertical scrollbar.
 * This entity must have a Scrollbar component.
 * @property {Entity} verticalScrollbarEntity The entity to be used as the vertical scrollbar. This
 * entity must have a Scrollbar component.
 * @augments Component
 */
declare class ScrollViewComponent extends Component {
    /**
     * Create a new ScrollViewComponent.
     *
     * @param {ScrollViewComponentSystem} system - The ComponentSystem that created this Component.
     * @param {Entity} entity - The Entity that this Component is attached to.
     */
    constructor(system: ScrollViewComponentSystem, entity: Entity);

    set bounceAmount(arg: number);
    get bounceAmount(): number;

    set contentEntity(arg: Entity);
    get contentEntity(): Entity;

    set friction(arg: number);
    get friction(): number;

    set horizontal(arg: boolean);
    get horizontal(): boolean;

    set horizontalScrollbarEntity(arg: Entity);
    get horizontalScrollbarEntity(): Entity;

    set horizontalScrollbarVisibility(arg: number);
    get horizontalScrollbarVisibility(): number;

    set mouseWheelSensitivity(arg: Vec2);
    get mouseWheelSensitivity(): Vec2;

    set scrollMode(arg: number);
    get scrollMode(): number;

    set useMouseWheel(arg: boolean);
    get useMouseWheel(): boolean;

    set vertical(arg: boolean);
    get vertical(): boolean;

    set verticalScrollbarEntity(arg: Entity);
    get verticalScrollbarEntity(): Entity;

    set verticalScrollbarVisibility(arg: number);
    get verticalScrollbarVisibility(): number;

    set viewportEntity(arg: Entity);
    get viewportEntity(): Entity;

    _viewportReference: EntityReference;
    _contentReference: EntityReference;
    _scrollbarUpdateFlags: {};
    _scrollbarReferences: {};
    _prevContentSizes: {};
    _scroll: Vec2;
    _velocity: Vec3;
    _dragStartPosition: Vec3;
    _disabledContentInput: boolean;
    _disabledContentInputEntities: any[];
    /**
     * Fired whenever the scroll position changes.
     *
     * @event ScrollViewComponent#set:scroll
     * @param {Vec2} scrollPosition - Horizontal and vertical scroll values in the range 0...1.
     */
    /**
     * @param {string} onOrOff - 'on' or 'off'.
     * @param {ScrollViewComponentSystem} system - The ComponentSystem that created this Component.
     * @private
     */
    private _toggleLifecycleListeners;
    /**
     * @param {string} onOrOff - 'on' or 'off'.
     * @private
     */
    private _toggleElementListeners;
    _hasElementListeners: boolean;
    _onElementComponentAdd(entity: any): void;
    _onElementComponentRemove(entity: any): void;
    _onViewportElementGain(): void;
    _onContentElementGain(): void;
    _contentDragHelper: ElementDragHelper;
    _onContentElementLose(): void;
    _onContentDragStart(): void;
    _onContentDragEnd(): void;
    _prevContentDragPosition: any;
    _onContentDragMove(position: any): void;
    _wasDragged: boolean;
    _onSetContentOrViewportSize(): void;
    _onSetHorizontalScrollbarValue(scrollValueX: any): void;
    _onSetVerticalScrollbarValue(scrollValueY: any): void;
    _onSetHorizontalScrollingEnabled(): void;
    _onSetVerticalScrollingEnabled(): void;
    _onHorizontalScrollbarGain(): void;
    _onVerticalScrollbarGain(): void;
    _onSetScroll(x: any, y: any, resetVelocity: any): void;
    _updateAxis(scrollValue: any, axis: any, orientation: any): boolean;
    _determineNewScrollValue(scrollValue: any, axis: any, orientation: any): any;
    _syncAll(): void;
    _syncContentPosition(orientation: any): void;
    _syncScrollbarPosition(orientation: any): void;
    _syncScrollbarEnabledState(orientation: any): void;
    _contentIsLargerThanViewport(orientation: any): boolean;
    _contentPositionToScrollValue(contentPosition: any): Vec2;
    _getMaxOffset(orientation: any, contentSize: any): number;
    _getMaxScrollValue(orientation: any): 1 | 0;
    _getScrollbarHandleSize(axis: any, orientation: any): number;
    _getViewportSize(orientation: any): any;
    _getContentSize(orientation: any): any;
    _getSize(orientation: any, entityReference: any): any;
    _getScrollingEnabled(orientation: any): any;
    _getScrollbarVisibility(orientation: any): any;
    _getSign(orientation: any): 1 | -1;
    _getAxis(orientation: any): "x" | "y";
    _getCalculatedDimension(orientation: any): "calculatedWidth" | "calculatedHeight";
    _destroyDragHelper(): void;
    onUpdate(): void;
    _updateVelocity(): void;
    _hasOvershoot(axis: any, orientation: any): boolean;
    _toOvershoot(scrollValue: any, orientation: any): any;
    _setVelocityFromOvershoot(scrollValue: any, axis: any, orientation: any): void;
    _setVelocityFromContentPositionDelta(position: any): void;
    _setScrollFromContentPosition(position: any): void;
    _applyScrollValueTension(scrollValue: any): any;
    _isDragging(): boolean;
    _setScrollbarComponentsEnabled(enabled: any): void;
    _setContentDraggingEnabled(enabled: any): void;
    _onMouseWheel(event: any): void;
    set scroll(arg: Vec2);
    get scroll(): Vec2;
    _enableContentInput(): void;
    _disableContentInput(): void;
    onRemove(): void;
}

declare class ScrollbarComponentData {
    enabled: boolean;
}

/**
 * Manages creation of {@link ScrollbarComponent}s.
 *
 * @augments ComponentSystem
 */
declare class ScrollbarComponentSystem extends ComponentSystem {
    id: string;
    ComponentType: typeof ScrollbarComponent;
    DataType: typeof ScrollbarComponentData;
    schema: {
        name: string;
        type: string;
    }[];
    initializeComponentData(component: any, data: any, properties: any): void;
    _onRemoveComponent(entity: any, component: any): void;
}



/** @typedef {import('../../entity.js').Entity} Entity */
/** @typedef {import('./system.js').ScrollbarComponentSystem} ScrollbarComponentSystem */
/**
 * A ScrollbarComponent enables a group of entities to behave like a draggable scrollbar.
 *
 * @property {number} orientation Whether the scrollbar moves horizontally or vertically. Can be:
 *
 * - {@link ORIENTATION_HORIZONTAL}: The scrollbar animates in the horizontal axis.
 * - {@link ORIENTATION_VERTICAL}: The scrollbar animates in the vertical axis.
 *
 * Defaults to {@link ORIENTATION_HORIZONTAL}.
 * @property {number} value The current position value of the scrollbar, in the range 0 to 1.
 * Defaults to 0.
 * @property {number} handleSize The size of the handle relative to the size of the track, in the
 * range 0 to 1. For a vertical scrollbar, a value of 1 means that the handle will take up the full
 * height of the track.
 * @property {Entity} handleEntity The entity to be used as the scrollbar handle. This entity must
 * have a Scrollbar component.
 * @augments Component
 */
declare class ScrollbarComponent extends Component {
    /**
     * Create a new ScrollbarComponent.
     *
     * @param {ScrollbarComponentSystem} system - The ComponentSystem that created this Component.
     * @param {Entity} entity - The Entity that this Component is attached to.
     */
    constructor(system: ScrollbarComponentSystem, entity: Entity);

    set handleEntity(arg: Entity);
    get handleEntity(): Entity;

    set handleSize(arg: number);
    get handleSize(): number;

    set orientation(arg: number);
    get orientation(): number;

    _handleReference: EntityReference;
    /**
     * Fired whenever the scroll value changes.
     *
     * @event ScrollbarComponent#set:value
     * @param {number} value - The current scroll value.
     */
    /**
     * @param {string} onOrOff - 'on' or 'off'.
     * @private
     */
    private _toggleLifecycleListeners;
    _onHandleElementGain(): void;
    _handleDragHelper: ElementDragHelper;
    _onHandleElementLose(): void;
    _onHandleDrag(position: any): void;
    value: number;
    _onSetValue(name: any, oldValue: any, newValue: any): void;
    _onSetHandleSize(name: any, oldValue: any, newValue: any): void;
    _onSetHandleAlignment(): void;
    _onSetOrientation(name: any, oldValue: any, newValue: any): void;
    _updateHandlePositionAndSize(): void;
    _handlePositionToScrollValue(handlePosition: any): number;
    _scrollValueToHandlePosition(value: any): number;
    _getUsableTrackLength(): number;
    _getTrackLength(): number;
    _getHandleLength(): number;
    _getHandlePosition(): number;
    _getSign(): 1 | -1;
    _getAxis(): "x" | "y";
    _getDimension(): "height" | "width";
    _getOppositeDimension(): "height" | "width";
    _destroyDragHelper(): void;
    _setHandleDraggingEnabled(enabled: any): void;
    onRemove(): void;
}

declare class ScriptComponentData {
    enabled: boolean;
}

/**
 * Helper class used to hold an array of items in a specific order. This array is safe to modify
 * while we loop through it. The class assumes that it holds objects that need to be sorted based
 * on one of their fields.
 *
 * @ignore
 */
declare class SortedLoopArray {
    /**
     * Create a new SortedLoopArray instance.
     *
     * @param {object} args - Arguments.
     * @param {string} args.sortBy - The name of the field that each element in the array is going
     * to be sorted by.
     * @example
     * var array = new pc.SortedLoopArray({ sortBy: 'priority' });
     * array.insert(item); // adds item to the right slot based on item.priority
     * array.append(item); // adds item to the end of the array
     * array.remove(item); // removes item from array
     * for (array.loopIndex = 0; array.loopIndex < array.length; array.loopIndex++) {
     *   // do things with array elements
     *   // safe to remove and add elements into the array while looping
     * }
     */
    constructor(args: {
        sortBy: string;
    });
    /**
     * The internal array that holds the actual array elements.
     *
     * @type {object[]}
     */
    items: object[];
    /**
     * The number of elements in the array.
     *
     * @type {number}
     */
    length: number;
    /**
     * The current index used to loop through the array. This gets modified if we add or remove
     * elements from the array while looping. See the example to see how to loop through this
     * array.
     *
     * @type {number}
     */
    loopIndex: number;
    _sortBy: string;
    _sortHandler: any;
    /**
     * Searches for the right spot to insert the specified item.
     *
     * @param {object} item - The item.
     * @returns {number} The index where to insert the item.
     * @private
     */
    private _binarySearch;
    _doSort(a: any, b: any): number;
    /**
     * Inserts the specified item into the array at the right index based on the 'sortBy' field
     * passed into the constructor. This also adjusts the loopIndex accordingly.
     *
     * @param {object} item - The item to insert.
     */
    insert(item: object): void;
    /**
     * Appends the specified item to the end of the array. Faster than insert() as it does not
     * binary search for the right index. This also adjusts the loopIndex accordingly.
     *
     * @param {object} item - The item to append.
     */
    append(item: object): void;
    /**
     * Removes the specified item from the array.
     *
     * @param {object} item - The item to remove.
     */
    remove(item: object): void;
    /**
     * Sorts elements in the array based on the 'sortBy' field passed into the constructor. This
     * also updates the loopIndex if we are currently looping.
     *
     * WARNING: Be careful if you are sorting while iterating because if after sorting the array
     * element that you are currently processing is moved behind other elements then you might end
     * up iterating over elements more than once!
     */
    sort(): void;
}

/**
 * Allows scripts to be attached to an Entity and executed.
 *
 * @augments ComponentSystem
 */
declare class ScriptComponentSystem extends ComponentSystem {
    id: string;
    ComponentType: typeof ScriptComponent;
    DataType: typeof ScriptComponentData;
    _components: SortedLoopArray;
    _enabledComponents: SortedLoopArray;
    preloading: boolean;
    initializeComponentData(component: any, data: any): void;
    cloneComponent(entity: any, clone: any): Component;
    _resetExecutionOrder(): void;
    _callComponentMethod(components: any, name: any, dt: any): void;
    _onInitialize(): void;
    _onPostInitialize(): void;
    _onUpdate(dt: any): void;
    _onPostUpdate(dt: any): void;
    _addComponentToEnabled(component: any): void;
    _removeComponentFromEnabled(component: any): void;
    _onBeforeRemove(entity: any, component: any): void;
}

/**
 * Container of Script Attribute definitions. Implements an interface to add/remove attributes and
 * store their definition for a {@link ScriptType}. Note: An instance of ScriptAttributes is
 * created automatically by each {@link ScriptType}.
 */
declare class ScriptAttributes {
    static reservedNames: Set<string>;
    /**
     * Create a new ScriptAttributes instance.
     *
     * @param {typeof ScriptType} scriptType - Script Type that attributes relate to.
     */
    constructor(scriptType: typeof ScriptType);
    scriptType: typeof ScriptType;
    index: {};
    /**
     * Add Attribute.
     *
     * @param {string} name - Name of an attribute.
     * @param {object} args - Object with Arguments for an attribute.
     * @param {("boolean"|"number"|"string"|"json"|"asset"|"entity"|"rgb"|"rgba"|"vec2"|"vec3"|"vec4"|"curve")} args.type - Type
     * of an attribute value.  Can be:
     *
     * - "asset"
     * - "boolean"
     * - "curve"
     * - "entity"
     * - "json"
     * - "number"
     * - "rgb"
     * - "rgba"
     * - "string"
     * - "vec2"
     * - "vec3"
     * - "vec4"
     *
     * @param {*} [args.default] - Default attribute value.
     * @param {string} [args.title] - Title for Editor's for field UI.
     * @param {string} [args.description] - Description for Editor's for field UI.
     * @param {string|string[]} [args.placeholder] - Placeholder for Editor's for field UI.
     * For multi-field types, such as vec2, vec3, and others use array of strings.
     * @param {boolean} [args.array] - If attribute can hold single or multiple values.
     * @param {number} [args.size] - If attribute is array, maximum number of values can be set.
     * @param {number} [args.min] - Minimum value for type 'number', if max and min defined, slider
     * will be rendered in Editor's UI.
     * @param {number} [args.max] - Maximum value for type 'number', if max and min defined, slider
     * will be rendered in Editor's UI.
     * @param {number} [args.precision] - Level of precision for field type 'number' with floating
     * values.
     * @param {number} [args.step] - Step value for type 'number'. The amount used to increment the
     * value when using the arrow keys in the Editor's UI.
     * @param {string} [args.assetType] - Name of asset type to be used in 'asset' type attribute
     * picker in Editor's UI, defaults to '*' (all).
     * @param {string[]} [args.curves] - List of names for Curves for field type 'curve'.
     * @param {string} [args.color] - String of color channels for Curves for field type 'curve',
     * can be any combination of `rgba` characters. Defining this property will render Gradient in
     * Editor's field UI.
     * @param {object[]} [args.enum] - List of fixed choices for field, defined as array of objects,
     * where key in object is a title of an option.
     * @param {object[]} [args.schema] - List of attributes for type 'json'. Each attribute
     * description is an object with the same properties as regular script attributes but with an
     * added 'name' field to specify the name of each attribute in the JSON.
     * @example
     * PlayerController.attributes.add('fullName', {
     *     type: 'string'
     * });
     * @example
     * PlayerController.attributes.add('speed', {
     *     type: 'number',
     *     title: 'Speed',
     *     placeholder: 'km/h',
     *     default: 22.2
     * });
     * @example
     * PlayerController.attributes.add('resolution', {
     *     type: 'number',
     *     default: 32,
     *     enum: [
     *         { '32x32': 32 },
     *         { '64x64': 64 },
     *         { '128x128': 128 }
     *     ]
     * });
     * @example
     * PlayerController.attributes.add('config', {
     *     type: 'json',
     *     schema: [{
     *         name: 'speed',
     *         type: 'number',
     *         title: 'Speed',
     *         placeholder: 'km/h',
     *         default: 22.2
     *     }, {
     *         name: 'resolution',
     *         type: 'number',
     *         default: 32,
     *         enum: [
     *             { '32x32': 32 },
     *             { '64x64': 64 },
     *             { '128x128': 128 }
     *         ]
     *     }]
     * });
     */
    add(name: string, args: {
        type: ("boolean" | "number" | "string" | "json" | "asset" | "entity" | "rgb" | "rgba" | "vec2" | "vec3" | "vec4" | "curve");
        default?: any;
        title?: string;
        description?: string;
        placeholder?: string | string[];
        array?: boolean;
        size?: number;
        min?: number;
        max?: number;
        precision?: number;
        step?: number;
        assetType?: string;
        curves?: string[];
        color?: string;
        enum?: object[];
        schema?: object[];
    }): void;
    /**
     * Remove Attribute.
     *
     * @param {string} name - Name of an attribute.
     * @returns {boolean} True if removed or false if not defined.
     * @example
     * PlayerController.attributes.remove('fullName');
     */
    remove(name: string): boolean;
    /**
     * Detect if Attribute is added.
     *
     * @param {string} name - Name of an attribute.
     * @returns {boolean} True if Attribute is defined.
     * @example
     * if (PlayerController.attributes.has('fullName')) {
     *     // attribute fullName is defined
     * }
     */
    has(name: string): boolean;
    /**
     * Get object with attribute arguments. Note: Changing argument properties will not affect
     * existing Script Instances.
     *
     * @param {string} name - Name of an attribute.
     * @returns {?object} Arguments with attribute properties.
     * @example
     * // changing default value for an attribute 'fullName'
     * var attr = PlayerController.attributes.get('fullName');
     * if (attr) attr.default = 'Unknown';
     */
    get(name: string): object | null;
}



/**
 * Represents the type of a script. It is returned by {@link createScript}. Also referred to as
 * Script Type.
 *
 * The type is to be extended using its JavaScript prototype. There is a list of methods that will
 * be executed by the engine on instances of this type, such as:
 *
 * - `initialize`
 * - `postInitialize`
 * - `update`
 * - `postUpdate`
 * - `swap`
 *
 * `initialize` and `postInitialize` - are called (if defined) when a script is about to run for
 * the first time - `postInitialize` will run after all `initialize` methods are executed in the
 * same tick or enabling chain of actions.
 *
 * `update` and `postUpdate` - are called (if defined) for enabled (running state) scripts on each
 * tick.
 *
 * `swap` - is called when a ScriptType that already exists in the registry gets redefined. If the
 * new ScriptType has a `swap` method in its prototype, then it will be executed to perform hot-
 * reload at runtime.
 *
 * @augments EventHandler
 */
declare class ScriptType extends EventHandler {
    /**
     * Name of a Script Type.
     *
     * @type {string}
     * @private
     */
    private static __name;
    /**
     * @param {*} constructorFn - The constructor function of the script type.
     * @returns {string} The script name.
     * @private
     */
    private static __getScriptName;
    /**
     * Name of a Script Type.
     *
     * @type {string|null}
     */
    static get scriptName(): string;
    /**
     * The interface to define attributes for Script Types. Refer to {@link ScriptAttributes}.
     *
     * @type {ScriptAttributes}
     * @example
     * var PlayerController = pc.createScript('playerController');
     *
     * PlayerController.attributes.add('speed', {
     *     type: 'number',
     *     title: 'Speed',
     *     placeholder: 'km/h',
     *     default: 22.2
     * });
     */
    static get attributes(): ScriptAttributes;
    /**
     * Shorthand function to extend Script Type prototype with list of methods.
     *
     * @param {object} methods - Object with methods, where key - is name of method, and value - is function.
     * @example
     * var PlayerController = pc.createScript('playerController');
     *
     * PlayerController.extend({
     *     initialize: function () {
     *         // called once on initialize
     *     },
     *     update: function (dt) {
     *         // called each tick
     *     }
     * });
     */
    static extend(methods: object): void;
    /**
     * Create a new ScriptType instance.
     *
     * @param {object} args - The input arguments object.
     * @param {AppBase} args.app - The {@link AppBase} that is running the script.
     * @param {Entity} args.entity - The {@link Entity} that the script is attached to.
     */
    constructor(args: {
        app: AppBase;
        entity: Entity;
    });
    /**
     * The {@link AppBase} that the instance of this type belongs to.
     *
     * @type {AppBase}
     */
    app: AppBase;
    /**
     * The {@link Entity} that the instance of this type belongs to.
     *
     * @type {Entity}
     */
    entity: Entity;
    /** @private */
    private _enabled;
    /** @private */
    private _enabledOld;
    /** @private */
    private _initialized;
    /** @private */
    private _postInitialized;
    /** @private */
    private __destroyed;
    /** @private */
    private __attributes;
    /** @private */
    private __attributesRaw;
    /** @private */
    private __scriptType;
    /**
     * The order in the script component that the methods of this script instance will run
     * relative to other script instances in the component.
     *
     * @type {number}
     * @private
     */
    private __executionOrder;
    /**
     * Fired when a script instance becomes enabled.
     *
     * @event ScriptType#enable
     * @example
     * PlayerController.prototype.initialize = function () {
     *     this.on('enable', function () {
     *         // Script Instance is now enabled
     *     });
     * };
     */
    /**
     * Fired when a script instance becomes disabled.
     *
     * @event ScriptType#disable
     * @example
     * PlayerController.prototype.initialize = function () {
     *     this.on('disable', function () {
     *         // Script Instance is now disabled
     *     });
     * };
     */
    /**
     * Fired when a script instance changes state to enabled or disabled.
     *
     * @event ScriptType#state
     * @param {boolean} enabled - True if now enabled, False if disabled.
     * @example
     * PlayerController.prototype.initialize = function () {
     *     this.on('state', function (enabled) {
     *         console.log('Script Instance is now ' + (enabled ? 'enabled' : 'disabled'));
     *     });
     * };
     */
    /**
     * Fired when a script instance is destroyed and removed from component.
     *
     * @event ScriptType#destroy
     * @example
     * PlayerController.prototype.initialize = function () {
     *     this.on('destroy', function () {
     *         // no more part of an entity
     *         // good place to cleanup entity from destroyed script
     *     });
     * };
     */
    /**
     * Fired when any script attribute has been changed.
     *
     * @event ScriptType#attr
     * @param {string} name - Name of attribute.
     * @param {object} value - New value.
     * @param {object} valueOld - Old value.
     * @example
     * PlayerController.prototype.initialize = function () {
     *     this.on('attr', function (name, value, valueOld) {
     *         console.log(name + ' been changed from ' + valueOld + ' to ' + value);
     *     });
     * };
     */
    /**
     * Fired when a specific script attribute has been changed.
     *
     * @event ScriptType#attr:[name]
     * @param {object} value - New value.
     * @param {object} valueOld - Old value.
     * @example
     * PlayerController.prototype.initialize = function () {
     *     this.on('attr:speed', function (value, valueOld) {
     *         console.log('speed been changed from ' + valueOld + ' to ' + value);
     *     });
     * };
     */
    /**
     * Fired when a script instance had an exception. The script instance will be automatically
     * disabled.
     *
     * @event ScriptType#error
     * @param {Error} err - Native JavaScript Error object with details of error.
     * @param {string} method - The method of the script instance that the exception originated from.
     * @example
     * PlayerController.prototype.initialize = function () {
     *     this.on('error', function (err, method) {
     *         // caught an exception
     *         console.log(err.stack);
     *     });
     * };
     */
    /**
     * True if the instance of this type is in running state. False when script is not running,
     * because the Entity or any of its parents are disabled or the {@link ScriptComponent} is
     * disabled or the Script Instance is disabled. When disabled no update methods will be called
     * on each tick. initialize and postInitialize methods will run once when the script instance
     * is in `enabled` state during app tick.
     *
     * @type {boolean}
     */
    set enabled(arg: boolean);
    get enabled(): boolean;

    /**
     * Called when script is about to run for the first time.
     */
    initialize?(): void;
    /**
     * Called after all initialize methods are executed in the same tick or enabling chain of actions.
     */
    postInitialize?(): void;
    /**
     * Called for enabled (running state) scripts on each tick.
     * @param dt - The delta time in seconds since the last frame.
     */
    update?(dt: number): void;
    /**
     * Called for enabled (running state) scripts on each tick, after update.
     * @param dt - The delta time in seconds since the last frame.
     */
    postUpdate?(dt: number): void;
    /**
     * Called when a ScriptType that already exists in the registry gets redefined. If the new
     * ScriptType has a `swap` method in its prototype, then it will be executed to perform
     * hot-reload at runtime.
     * @param old - Old instance of the scriptType to copy data to the new instance.
     */
    swap?(old: ScriptType): void;

    /**
     * @param {{entity: Entity, app: AppBase}} args - The entity and app.
     * @private
     */
    private initScriptType;
    /**
     * @param {boolean} [force] - Set to true to force initialization of the attributes.
     * @private
     */
    private __initializeAttributes;
}


/** @typedef {import('./system.js').ScriptComponentSystem} ScriptComponentSystem */
/**
 * The ScriptComponent allows you to extend the functionality of an Entity by attaching your own
 * Script Types defined in JavaScript files to be executed with access to the Entity. For more
 * details on scripting see [Scripting](https://developer.playcanvas.com/user-manual/scripting/).
 *
 * @augments Component
 */
declare class ScriptComponent extends Component {
    static scriptMethods: {
        initialize: string;
        postInitialize: string;
        update: string;
        postUpdate: string;
        swap: string;
    };
    /**
     * Create a new ScriptComponent instance.
     *
     * @param {ScriptComponentSystem} system - The ComponentSystem that created this Component.
     * @param {Entity} entity - The Entity that this Component is attached to.
     */
    constructor(system: ScriptComponentSystem, entity: Entity);
    /**
     * Holds all script instances for this component.
     *
     * @type {ScriptType[]}
     * @private
     */
    private _scripts;
    _updateList: SortedLoopArray;
    _postUpdateList: SortedLoopArray;
    _scriptsIndex: {};
    _destroyedScripts: any[];
    _destroyed: boolean;
    _scriptsData: ScriptType[];
    _oldState: boolean;
    _enabled: boolean;
    _beingEnabled: boolean;
    _isLoopingThroughScripts: boolean;
    _executionOrder: number;
    /**
     * Fired when Component becomes enabled. Note: this event does not take in account entity or
     * any of its parent enabled state.
     *
     * @event ScriptComponent#enable
     * @example
     * entity.script.on('enable', function () {
     *     // component is enabled
     * });
     */
    /**
     * Fired when Component becomes disabled. Note: this event does not take in account entity or
     * any of its parent enabled state.
     *
     * @event ScriptComponent#disable
     * @example
     * entity.script.on('disable', function () {
     *     // component is disabled
     * });
     */
    /**
     * Fired when Component changes state to enabled or disabled. Note: this event does not take in
     * account entity or any of its parent enabled state.
     *
     * @event ScriptComponent#state
     * @param {boolean} enabled - True if now enabled, False if disabled.
     * @example
     * entity.script.on('state', function (enabled) {
     *     // component changed state
     * });
     */
    /**
     * Fired when Component is removed from entity.
     *
     * @event ScriptComponent#remove
     * @example
     * entity.script.on('remove', function () {
     *     // entity has no more script component
     * });
     */
    /**
     * Fired when a script instance is created and attached to component.
     *
     * @event ScriptComponent#create
     * @param {string} name - The name of the Script Type.
     * @param {ScriptType} scriptInstance - The instance of the {@link ScriptType} that has been created.
     * @example
     * entity.script.on('create', function (name, scriptInstance) {
     *     // new script instance added to component
     * });
     */
    /**
     * Fired when a script instance is created and attached to component.
     *
     * @event ScriptComponent#create:[name]
     * @param {ScriptType} scriptInstance - The instance of the {@link ScriptType} that has been created.
     * @example
     * entity.script.on('create:playerController', function (scriptInstance) {
     *     // new script instance 'playerController' is added to component
     * });
     */
    /**
     * Fired when a script instance is destroyed and removed from component.
     *
     * @event ScriptComponent#destroy
     * @param {string} name - The name of the Script Type.
     * @param {ScriptType} scriptInstance - The instance of the {@link ScriptType} that has been destroyed.
     * @example
     * entity.script.on('destroy', function (name, scriptInstance) {
     *     // script instance has been destroyed and removed from component
     * });
     */
    /**
     * Fired when a script instance is destroyed and removed from component.
     *
     * @event ScriptComponent#destroy:[name]
     * @param {ScriptType} scriptInstance - The instance of the {@link ScriptType} that has been destroyed.
     * @example
     * entity.script.on('destroy:playerController', function (scriptInstance) {
     *     // script instance 'playerController' has been destroyed and removed from component
     * });
     */
    /**
     * Fired when a script instance is moved in component.
     *
     * @event ScriptComponent#move
     * @param {string} name - The name of the Script Type.
     * @param {ScriptType} scriptInstance - The instance of the {@link ScriptType} that has been moved.
     * @param {number} ind - New position index.
     * @param {number} indOld - Old position index.
     * @example
     * entity.script.on('move', function (name, scriptInstance, ind, indOld) {
     *     // script instance has been moved in component
     * });
     */
    /**
     * Fired when a script instance is moved in component.
     *
     * @event ScriptComponent#move:[name]
     * @param {ScriptType} scriptInstance - The instance of the {@link ScriptType} that has been moved.
     * @param {number} ind - New position index.
     * @param {number} indOld - Old position index.
     * @example
     * entity.script.on('move:playerController', function (scriptInstance, ind, indOld) {
     *     // script instance 'playerController' has been moved in component
     * });
     */
    /**
     * Fired when a script instance had an exception.
     *
     * @event ScriptComponent#error
     * @param {ScriptType} scriptInstance - The instance of the {@link ScriptType} that raised the exception.
     * @param {Error} err - Native JS Error object with details of an error.
     * @param {string} method - The method of the script instance that the exception originated from.
     * @example
     * entity.script.on('error', function (scriptInstance, err, method) {
     *     // script instance caught an exception
     * });
     */
    /**
     * An array of all script instances attached to an entity. This array is read-only and should
     * not be modified by developer.
     *
     * @type {ScriptType[]}
     */
    set scripts(arg: ScriptType[]);
    get scripts(): ScriptType[];
    set enabled(arg: boolean);
    get enabled(): boolean;
    _beginLooping(): boolean;
    _endLooping(wasLoopingBefore: any): void;
    _onSetEnabled(prop: any, old: any, value: any): void;
    _checkState(): void;
    _onBeforeRemove(): void;
    _removeDestroyedScripts(): void;
    _onInitializeAttributes(): void;
    _scriptMethod(script: any, method: any, arg: any): void;
    _onInitialize(): void;
    _onPostInitialize(): void;
    _onUpdate(dt: any): void;
    _onPostUpdate(dt: any): void;
    /**
     * Inserts script instance into the scripts array at the specified index. Also inserts the
     * script into the update list if it has an update method and the post update list if it has a
     * postUpdate method.
     *
     * @param {object} scriptInstance - The script instance.
     * @param {number} index - The index where to insert the script at. If -1, append it at the end.
     * @param {number} scriptsLength - The length of the scripts array.
     * @private
     */
    private _insertScriptInstance;
    _removeScriptInstance(scriptInstance: any): number;
    _resetExecutionOrder(startIndex: any, scriptsLength: any): void;
    _resolveEntityScriptAttribute(attribute: any, attributeName: any, oldValue: any, useGuid: any, newAttributes: any, duplicatedIdsMap: any): void;
    /**
     * Detect if script is attached to an entity.
     *
     * @param {string|typeof ScriptType} nameOrType - The name or type of {@link ScriptType}.
     * @returns {boolean} If script is attached to an entity.
     * @example
     * if (entity.script.has('playerController')) {
     *     // entity has script
     * }
     */
    has(nameOrType: string | typeof ScriptType): boolean;
    /**
     * Get a script instance (if attached).
     *
     * @param {string|typeof ScriptType} nameOrType - The name or type of {@link ScriptType}.
     * @returns {ScriptType|null} If script is attached, the instance is returned. Otherwise null
     * is returned.
     * @example
     * var controller = entity.script.get('playerController');
     */
    get(nameOrType: string | typeof ScriptType): ScriptType | null;
    /**
     * Create a script instance and attach to an entity script component.
     *
     * @param {string|typeof ScriptType} nameOrType - The name or type of {@link ScriptType}.
     * @param {object} [args] - Object with arguments for a script.
     * @param {boolean} [args.enabled] - If script instance is enabled after creation. Defaults to
     * true.
     * @param {object} [args.attributes] - Object with values for attributes (if any), where key is
     * name of an attribute.
     * @param {boolean} [args.preloading] - If script instance is created during preload. If true,
     * script and attributes must be initialized manually. Defaults to false.
     * @param {number} [args.ind] - The index where to insert the script instance at. Defaults to
     * -1, which means append it at the end.
     * @returns {ScriptType|null} Returns an instance of a {@link ScriptType} if successfully attached
     * to an entity, or null if it failed because a script with a same name has already been added
     * or if the {@link ScriptType} cannot be found by name in the {@link ScriptRegistry}.
     * @example
     * entity.script.create('playerController', {
     *     attributes: {
     *         speed: 4
     *     }
     * });
     */
    create(nameOrType: string | typeof ScriptType, args?: {
        enabled?: boolean;
        attributes?: object;
        preloading?: boolean;
        ind?: number;
    }): ScriptType | null;
    /**
     * Destroy the script instance that is attached to an entity.
     *
     * @param {string|typeof ScriptType} nameOrType - The name or type of {@link ScriptType}.
     * @returns {boolean} If it was successfully destroyed.
     * @example
     * entity.script.destroy('playerController');
     */
    destroy(nameOrType: string | typeof ScriptType): boolean;
    /**
     * Swap the script instance.
     *
     * @param {string|typeof ScriptType} nameOrType - The name or type of {@link ScriptType}.
     * @returns {boolean} If it was successfully swapped.
     * @private
     */
    private swap;
    /**
     * When an entity is cloned and it has entity script attributes that point to other entities in
     * the same subtree that is cloned, then we want the new script attributes to point at the
     * cloned entities. This method remaps the script attributes for this entity and it assumes
     * that this entity is the result of the clone operation.
     *
     * @param {ScriptComponent} oldScriptComponent - The source script component that belongs to
     * the entity that was being cloned.
     * @param {object} duplicatedIdsMap - A dictionary with guid-entity values that contains the
     * entities that were cloned.
     * @private
     */
    private resolveDuplicatedEntityReferenceProperties;
    /**
     * Move script instance to different position to alter update order of scripts within entity.
     *
     * @param {string|typeof ScriptType} nameOrType - The name or type of {@link ScriptType}.
     * @param {number} ind - New position index.
     * @returns {boolean} If it was successfully moved.
     * @example
     * entity.script.move('playerController', 0);
     */
    move(nameOrType: string | typeof ScriptType, ind: number): boolean;
}

declare class ScreenComponentData {
    enabled: boolean;
}

/**
 * A ordered list-type data structure that can provide item look up by key and can also return a list.
 *
 * @ignore
 */
declare class IndexedList {
    /**
     * @type {object[]}
     * @private
     */
    private _list;
    /**
     * @type {Object<string, number>}
     * @private
     */
    private _index;
    /**
     * Add a new item into the list with a index key.
     *
     * @param {string} key -  Key used to look up item in index.
     * @param {object} item - Item to be stored.
     */
    push(key: string, item: object): void;
    /**
     * Test whether a key has been added to the index.
     *
     * @param {string} key - The key to test.
     * @returns {boolean} Returns true if key is in the index, false if not.
     */
    has(key: string): boolean;
    /**
     * Return the item indexed by a key.
     *
     * @param {string} key - The key of the item to retrieve.
     * @returns {object|null} The item stored at key. Returns null if key is not in the index.
     */
    get(key: string): object | null;
    /**
     * Remove the item indexed by key from the list.
     *
     * @param {string} key - The key at which to remove the item.
     * @returns {boolean} Returns true if the key exists and an item was removed, returns false if
     * no item was removed.
     */
    remove(key: string): boolean;
    /**
     * Returns the list of items.
     *
     * @returns {object[]} The list of items.
     */
    list(): object[];
    /**
     * Remove all items from the list.
     */
    clear(): void;
}

/**
 * Manages creation of {@link ScreenComponent}s.
 *
 * @augments ComponentSystem
 */
declare class ScreenComponentSystem extends ComponentSystem {
    id: string;
    ComponentType: typeof ScreenComponent;
    DataType: typeof ScreenComponentData;
    schema: string[];
    windowResolution: Vec2;
    _drawOrderSyncQueue: IndexedList;
    initializeComponentData(component: any, data: any, properties: any): void;
    _onUpdate(dt: any): void;
    _onResize(width: any, height: any): void;
    cloneComponent(entity: any, clone: any): Component;
    onRemoveComponent(entity: any, component: any): void;
    processDrawOrderSyncQueue(): void;
    queueDrawOrderSync(id: any, fn: any, scope: any): void;
}


/**
 * A ScreenComponent enables the Entity to render child {@link ElementComponent}s using anchors and
 * positions in the ScreenComponent's space.
 *
 * @augments Component
 */
declare class ScreenComponent extends Component {
    /**
     * Create a new ScreenComponent.
     *
     * @param {ScreenComponentSystem} system - The ComponentSystem that created this Component.
     * @param {Entity} entity - The Entity that this Component is attached to.
     */
    constructor(system: ScreenComponentSystem, entity: Entity);
    _resolution: Vec2;
    _referenceResolution: Vec2;
    _scaleMode: string;
    scale: number;
    _scaleBlend: number;
    _priority: number;
    _screenSpace: boolean;
    /**
     * If true then elements inside this screen will be not be rendered when outside of the
     * screen (only valid when screenSpace is true).
     *
     * @type {boolean}
     */
    cull: boolean;
    _screenMatrix: Mat4;
    _elements: Set<any>;
    /**
     * Set the drawOrder of each child {@link ElementComponent} so that ElementComponents which are
     * last in the hierarchy are rendered on top. Draw Order sync is queued and will be updated by
     * the next update loop.
     */
    syncDrawOrder(): void;
    _recurseDrawOrderSync(e: any, i: any): any;
    _processDrawOrderSync(): void;
    _calcProjectionMatrix(): void;
    _updateScale(): void;
    _calcScale(resolution: any, referenceResolution: any): number;
    _onResize(width: any, height: any): void;
    /**
     * The width and height of the ScreenComponent. When screenSpace is true the resolution will
     * always be equal to {@link GraphicsDevice#width} x {@link GraphicsDevice#height}.
     *
     * @type {Vec2}
     */
    set resolution(arg: Vec2);
    get resolution(): Vec2;
    _bindElement(element: any): void;
    _unbindElement(element: any): void;
    onRemove(): void;
    /**
     * The resolution that the ScreenComponent is designed for. This is only taken into account
     * when screenSpace is true and scaleMode is {@link SCALEMODE_BLEND}. If the actual resolution
     * is different then the ScreenComponent will be scaled according to the scaleBlend value.
     *
     * @type {Vec2}
     */
    set referenceResolution(arg: Vec2);
    get referenceResolution(): Vec2;
    /**
     * If true then the ScreenComponent will render its child {@link ElementComponent}s in screen
     * space instead of world space. Enable this to create 2D user interfaces.
     *
     * @type {boolean}
     */
    set screenSpace(arg: boolean);
    get screenSpace(): boolean;
    /**
     * Can either be {@link SCALEMODE_NONE} or {@link SCALEMODE_BLEND}. See the description of
     * referenceResolution for more information.
     *
     * @type {string}
     */
    set scaleMode(arg: string);
    get scaleMode(): string;
    /**
     * A value between 0 and 1 that is used when scaleMode is equal to {@link SCALEMODE_BLEND}.
     * Scales the ScreenComponent with width as a reference (when value is 0), the height as a
     * reference (when value is 1) or anything in between.
     *
     * @type {number}
     */
    set scaleBlend(arg: number);
    get scaleBlend(): number;
    /**
     * Priority determines the order in which Screen components in the same layer are rendered.
     * Number must be an integer between 0 and 255. Priority is set into the top 8 bits of the
     * drawOrder property in an element.
     *
     * @type {number}
     */
    set priority(arg: number);
    get priority(): number;
}

declare class RigidBodyComponentData {
    enabled: boolean;
}

declare class ObjectPool {
    constructor(constructorFunc: any, size: any);
    _constructor: any;
    _pool: any[];
    _count: number;
    _resize(size: any): void;
    allocate(): any;
    freeAll(): void;
}


/**
 * Object holding the result of a contact between two Entities.
 */
declare class ContactPoint {
    /**
     * Create a new ContactPoint instance.
     *
     * @param {Vec3} [localPoint] - The point on the entity where the contact occurred, relative to
     * the entity.
     * @param {Vec3} [localPointOther] - The point on the other entity where the contact occurred,
     * relative to the other entity.
     * @param {Vec3} [point] - The point on the entity where the contact occurred, in world space.
     * @param {Vec3} [pointOther] - The point on the other entity where the contact occurred, in
     * world space.
     * @param {Vec3} [normal] - The normal vector of the contact on the other entity, in world
     * space.
     * @param {number} [impulse] - The total accumulated impulse applied by the constraint solver
     * during the last sub-step. Describes how hard two objects collide. Defaults to 0.
     * @hideconstructor
     */
    constructor(localPoint?: Vec3, localPointOther?: Vec3, point?: Vec3, pointOther?: Vec3, normal?: Vec3, impulse?: number);
    /**
     * The point on the entity where the contact occurred, relative to the entity.
     *
     * @type {Vec3}
     */
    localPoint: Vec3;
    /**
     * The point on the other entity where the contact occurred, relative to the other entity.
     *
     * @type {Vec3}
     */
    localPointOther: Vec3;
    /**
     * The point on the entity where the contact occurred, in world space.
     *
     * @type {Vec3}
     */
    point: Vec3;
    /**
     * The point on the other entity where the contact occurred, in world space.
     *
     * @type {Vec3}
     */
    pointOther: Vec3;
    /**
     * The normal vector of the contact on the other entity, in world space.
     *
     * @type {Vec3}
     */
    normal: Vec3;
    /**
     * The total accumulated impulse applied by the constraint solver during the last sub-step.
     * Describes how hard two objects collide.
     *
     * @type {number}
     */
    impulse: number;
}
/**
 * Object holding the result of a contact between two Entities.
 */
declare class ContactResult {
    /**
     * Create a new ContactResult instance.
     *
     * @param {Entity} other - The entity that was involved in the contact with this entity.
     * @param {ContactPoint[]} contacts - An array of ContactPoints with the other entity.
     * @hideconstructor
     */
    constructor(other: Entity, contacts: ContactPoint[]);
    /**
     * The entity that was involved in the contact with this entity.
     *
     * @type {Entity}
     */
    other: Entity;
    /**
     * An array of ContactPoints with the other entity.
     *
     * @type {ContactPoint[]}
     */
    contacts: ContactPoint[];
}
/**
 * Object holding the result of a successful raycast hit.
 */
declare class RaycastResult {
    /**
     * Create a new RaycastResult instance.
     *
     * @param {Entity} entity - The entity that was hit.
     * @param {Vec3} point - The point at which the ray hit the entity in world space.
     * @param {Vec3} normal - The normal vector of the surface where the ray hit in world space.
     * @hideconstructor
     */
    constructor(entity: Entity, point: Vec3, normal: Vec3);
    /**
     * The entity that was hit.
     *
     * @type {Entity}
     */
    entity: Entity;
    /**
     * The point at which the ray hit the entity in world space.
     *
     * @type {Vec3}
     */
    point: Vec3;
    /**
     * The normal vector of the surface where the ray hit in world space.
     *
     * @type {Vec3}
     */
    normal: Vec3;
}
/**
 * The RigidBodyComponentSystem maintains the dynamics world for simulating rigid bodies, it also
 * controls global values for the world such as gravity. Note: The RigidBodyComponentSystem is only
 * valid if 3D Physics is enabled in your application. You can enable this in the application
 * settings for your project.
 *
 * @augments ComponentSystem
 */
declare class RigidBodyComponentSystem extends ComponentSystem {
    /**
     * @type {number}
     * @ignore
     */
    maxSubSteps: number;
    /**
     * @type {number}
     * @ignore
     */
    fixedTimeStep: number;
    /**
     * The world space vector representing global gravity in the physics simulation. Defaults to
     * [0, -9.81, 0] which is an approximation of the gravitational force on Earth.
     *
     * @type {Vec3}
     */
    gravity: Vec3;
    /**
     * @type {RigidBodyComponent[]}
     * @private
     */
    private _dynamic;
    /**
     * @type {RigidBodyComponent[]}
     * @private
     */
    private _kinematic;
    /**
     * @type {RigidBodyComponent[]}
     * @private
     */
    private _triggers;
    /**
     * @type {RigidBodyComponent[]}
     * @private
     */
    private _compounds;
    id: string;
    _stats: {
        fps: number;
        ms: number;
        dt: number;
        updateStart: number;
        updateTime: number;
        renderStart: number;
        renderTime: number;
        physicsStart: number;
        physicsTime: number;
        cullTime: number;
        sortTime: number;
        skinTime: number;
        morphTime: number;
        instancingTime: number;
        triangles: number;
        otherPrimitives: number;
        shaders: number;
        materials: number;
        cameras: number;
        shadowMapUpdates: number;
        shadowMapTime: number;
        depthMapTime: number;
        forwardTime: number;
        /**
         * The entity that was hit.
         *
         * @type {Entity}
         */
        lightClustersTime: number;
        lightClusters: number;
        _timeToCountFrames: number;
        _fpsAccum: number;
    };
    ComponentType: typeof RigidBodyComponent;
    DataType: typeof RigidBodyComponentData;
    contactPointPool: ObjectPool;
    contactResultPool: ObjectPool;
    singleContactResultPool: ObjectPool;
    schema: string[];
    collisions: {};
    frameCollisions: {};
    /**
     * Fired when a contact occurs between two rigid bodies.
     *
     * @event RigidBodyComponentSystem#contact
     * @param {SingleContactResult} result - Details of the contact between the two bodies.
     */
    /**
     * Called once Ammo has been loaded. Responsible for creating the physics world.
     *
     * @ignore
     */
    onLibraryLoaded(): void;
    collisionConfiguration: any;
    dispatcher: any;
    overlappingPairCache: any;
    solver: any;
    dynamicsWorld: any;
    initializeComponentData(component: any, data: any, properties: any): void;
    cloneComponent(entity: any, clone: any): Component;
    onBeforeRemove(entity: any, component: any): void;
    onRemove(entity: any, component: any): void;
    addBody(body: any, group: any, mask: any): void;
    removeBody(body: any): void;
    createBody(mass: any, shape: any, transform: any): any;
    destroyBody(body: any): void;
    /**
     * Raycast the world and return the first entity the ray hits. Fire a ray into the world from
     * start to end, if the ray hits an entity with a collision component, it returns a
     * {@link RaycastResult}, otherwise returns null.
     *
     * @param {Vec3} start - The world space point where the ray starts.
     * @param {Vec3} end - The world space point where the ray ends.
     * @returns {RaycastResult} The result of the raycasting or null if there was no hit.
     */
    raycastFirst(start: Vec3, end: Vec3, ...args: any[]): RaycastResult;
    /**
     * Raycast the world and return all entities the ray hits. It returns an array of
     * {@link RaycastResult}, one for each hit. If no hits are detected, the returned array will be
     * of length 0.
     *
     * @param {Vec3} start - The world space point where the ray starts.
     * @param {Vec3} end - The world space point where the ray ends.
     * @returns {RaycastResult[]} An array of raycast hit results (0 length if there were no hits).
     */
    raycastAll(start: Vec3, end: Vec3): RaycastResult[];
    /**
     * Stores a collision between the entity and other in the contacts map and returns true if it
     * is a new collision.
     *
     * @param {Entity} entity - The entity.
     * @param {Entity} other - The entity that collides with the first entity.
     * @returns {boolean} True if this is a new collision, false otherwise.
     * @private
     */
    private _storeCollision;
    _createContactPointFromAmmo(contactPoint: any): any;
    _createReverseContactPointFromAmmo(contactPoint: any): any;
    _createSingleContactResult(a: any, b: any, contactPoint: any): any;
    _createContactResult(other: any, contacts: any): any;
    /**
     * Removes collisions that no longer exist from the collisions list and fires collisionend
     * events to the related entities.
     *
     * @private
     */
    private _cleanOldCollisions;
    /**
     * Returns true if the entity has a contact event attached and false otherwise.
     *
     * @param {object} entity - Entity to test.
     * @returns {boolean} True if the entity has a contact and false otherwise.
     * @private
     */
    private _hasContactEvent;
    /**
     * Checks for collisions and fires collision events.
     *
     * @param {number} world - The pointer to the dynamics world that invoked this callback.
     * @param {number} timeStep - The amount of simulation time processed in the last simulation tick.
     * @private
     */
    private _checkForCollisions;
    onUpdate(dt: any): void;
}
/**
 * Object holding the result of a contact between two rigid bodies.
 */
declare class SingleContactResult {
    /**
     * Create a new SingleContactResult instance.
     *
     * @param {Entity} a - The first entity involved in the contact.
     * @param {Entity} b - The second entity involved in the contact.
     * @param {ContactPoint} contactPoint - The contact point between the two entities.
     * @hideconstructor
     */
    constructor(a: Entity, b: Entity, contactPoint: ContactPoint, ...args: any[]);
    /**
     * The first entity involved in the contact.
     *
     * @type {Entity}
     */
    a: Entity;
    /**
     * The second entity involved in the contact.
     *
     * @type {Entity}
     */
    b: Entity;
    /**
     * The total accumulated impulse applied by the constraint solver during the last
     * sub-step. Describes how hard two bodies collided.
     *
     * @type {number}
     */
    impulse: number;
    /**
     * The point on Entity A where the contact occurred, relative to A.
     *
     * @type {Vec3}
     */
    localPointA: Vec3;
    /**
     * The point on Entity B where the contact occurred, relative to B.
     *
     * @type {Vec3}
     */
    localPointB: Vec3;
    /**
     * The point on Entity A where the contact occurred, in world space.
     *
     * @type {Vec3}
     */
    pointA: Vec3;
    /**
     * The point on Entity B where the contact occurred, in world space.
     *
     * @type {Vec3}
     */
    pointB: Vec3;
    /**
     * The normal vector of the contact on Entity B, in world space.
     *
     * @type {Vec3}
     */
    normal: Vec3;
}



/**
 * The rigidbody component, when combined with a {@link CollisionComponent}, allows your entities
 * to be simulated using realistic physics. A rigidbody component will fall under gravity and
 * collide with other rigid bodies. Using scripts, you can apply forces and impulses to rigid
 * bodies.
 *
 * You should never need to use the RigidBodyComponent constructor. To add an RigidBodyComponent to
 * a {@link Entity}, use {@link Entity#addComponent}:
 *
 * ```javascript
 * // Create a static 1x1x1 box-shaped rigid body
 * const entity = pc.Entity();
 * entity.addComponent("rigidbody"); // With no options specified, this defaults to a 'static' body
 * entity.addComponent("collision"); // With no options specified, this defaults to a 1x1x1 box shape
 * ```
 *
 * To create a dynamic sphere with mass of 10, do:
 *
 * ```javascript
 * const entity = pc.Entity();
 * entity.addComponent("rigidbody", {
 *     type: pc.BODYTYPE_DYNAMIC,
 *     mass: 10
 * });
 * entity.addComponent("collision", {
 *     type: "sphere"
 * });
 * ```
 *
 * Relevant 'Engine-only' examples:
 *
 * - [Falling shapes](http://playcanvas.github.io/#physics/falling-shapes)
 * - [Vehicle physics](http://playcanvas.github.io/#physics/vehicle)
 *
 * @augments Component
 */
declare class RigidBodyComponent extends Component {
    /**
     * Fired when a contact occurs between two rigid bodies.
     *
     * @event RigidBodyComponent#contact
     * @param {ContactResult} result - Details of the contact between the two rigid bodies.
     */
    /**
     * Fired when two rigid bodies start touching.
     *
     * @event RigidBodyComponent#collisionstart
     * @param {ContactResult} result - Details of the contact between the two rigid bodies.
     */
    /**
     * Fired when two rigid bodies stop touching.
     *
     * @event RigidBodyComponent#collisionend
     * @param {Entity} other - The {@link Entity} that stopped touching this rigid body.
     */
    /**
     * Fired when a rigid body enters a trigger volume.
     *
     * @event RigidBodyComponent#triggerenter
     * @param {Entity} other - The {@link Entity} with trigger volume that this rigid body entered.
     */
    /**
     * Fired when a rigid body exits a trigger volume.
     *
     * @event RigidBodyComponent#triggerleave
     * @param {Entity} other - The {@link Entity} with trigger volume that this rigid body exited.
     */
    static onLibraryLoaded(): void;
    /**
     * Create a new RigidBodyComponent instance.
     *
     * @param {RigidBodyComponentSystem} system - The ComponentSystem that created this component.
     * @param {Entity} entity - The entity this component is attached to.
     */
    constructor(system: RigidBodyComponentSystem, entity: Entity);
    _angularDamping: number;
    _angularFactor: Vec3;
    _angularVelocity: Vec3;
    _body: any;
    _friction: number;
    _group: number;
    _linearDamping: number;
    _linearFactor: Vec3;
    _linearVelocity: Vec3;
    _mask: number;
    _mass: number;
    _restitution: number;
    _rollingFriction: number;
    _simulationEnabled: boolean;
    _type: string;
    /**
     * Controls the rate at which a body loses angular velocity over time.
     *
     * @type {number}
     */
    set angularDamping(arg: number);
    get angularDamping(): number;
    /**
     * Scaling factor for angular movement of the body in each axis. Only valid for rigid bodies of
     * type {@link BODYTYPE_DYNAMIC}. Defaults to 1 in all axes (body can freely rotate).
     *
     * @type {Vec3}
     */
    set angularFactor(arg: Vec3);
    get angularFactor(): Vec3;
    /**
     * Defines the rotational speed of the body around each world axis.
     *
     * @type {Vec3}
     */
    set angularVelocity(arg: Vec3);
    get angularVelocity(): Vec3;
    set body(arg: any);
    get body(): any;
    /**
     * The friction value used when contacts occur between two bodies. A higher value indicates
     * more friction. Should be set in the range 0 to 1. Defaults to 0.5.
     *
     * @type {number}
     */
    set friction(arg: number);
    get friction(): number;
    /**
     * The collision group this body belongs to. Combine the group and the mask to prevent bodies
     * colliding with each other. Defaults to 1.
     *
     * @type {number}
     */
    set group(arg: number);
    get group(): number;
    /**
     * Controls the rate at which a body loses linear velocity over time. Defaults to 0.
     *
     * @type {number}
     */
    set linearDamping(arg: number);
    get linearDamping(): number;
    /**
     * Scaling factor for linear movement of the body in each axis. Only valid for rigid bodies of
     * type {@link BODYTYPE_DYNAMIC}. Defaults to 1 in all axes (body can freely move).
     *
     * @type {Vec3}
     */
    set linearFactor(arg: Vec3);
    get linearFactor(): Vec3;
    /**
     * Defines the speed of the body in a given direction.
     *
     * @type {Vec3}
     */
    set linearVelocity(arg: Vec3);
    get linearVelocity(): Vec3;
    /**
     * The collision mask sets which groups this body collides with. It is a bitfield of 16 bits,
     * the first 8 bits are reserved for engine use. Defaults to 65535.
     *
     * @type {number}
     */
    set mask(arg: number);
    get mask(): number;
    /**
     * The mass of the body. This is only relevant for {@link BODYTYPE_DYNAMIC} bodies, other types
     * have infinite mass. Defaults to 1.
     *
     * @type {number}
     */
    set mass(arg: number);
    get mass(): number;
    /**
     * Influences the amount of energy lost when two rigid bodies collide. The calculation
     * multiplies the restitution values for both colliding bodies. A multiplied value of 0 means
     * that all energy is lost in the collision while a value of 1 means that no energy is lost.
     * Should be set in the range 0 to 1. Defaults to 0.
     *
     * @type {number}
     */
    set restitution(arg: number);
    get restitution(): number;
    /**
     * Sets a torsional friction orthogonal to the contact point. Defaults to 0.
     *
     * @type {number}
     */
    set rollingFriction(arg: number);
    get rollingFriction(): number;
    /**
     * The rigid body type determines how the body is simulated. Can be:
     *
     * - {@link BODYTYPE_STATIC}: infinite mass and cannot move.
     * - {@link BODYTYPE_DYNAMIC}: simulated according to applied forces.
     * - {@link BODYTYPE_KINEMATIC}: infinite mass and does not respond to forces (can only be
     * moved by setting the position and rotation of component's {@link Entity}).
     *
     * Defaults to {@link BODYTYPE_STATIC}.
     *
     * @type {string}
     */
    set type(arg: string);
    get type(): string;
    /**
     * If the Entity has a Collision shape attached then create a rigid body using this shape. This
     * method destroys the existing body.
     *
     * @private
     */
    private createBody;
    /**
     * Returns true if the rigid body is currently actively being simulated. I.e. Not 'sleeping'.
     *
     * @returns {boolean} True if the body is active.
     */
    isActive(): boolean;
    /**
     * Forcibly activate the rigid body simulation. Only affects rigid bodies of type
     * {@link BODYTYPE_DYNAMIC}.
     */
    activate(): void;
    enableSimulation(): void;
    disableSimulation(): void;
    /**
     * Apply an force to the body at a point. By default, the force is applied at the origin of the
     * body. However, the force can be applied at an offset this point by specifying a world space
     * vector from the body's origin to the point of application. This function has two valid
     * signatures. You can either specify the force (and optional relative point) via 3D-vector or
     * numbers.
     *
     * @param {Vec3|number} x - A 3-dimensional vector representing the force in world-space or
     * the x-component of the force in world-space.
     * @param {Vec3|number} [y] - An optional 3-dimensional vector representing the relative point
     * at which to apply the impulse in world-space or the y-component of the force in world-space.
     * @param {number} [z] - The z-component of the force in world-space.
     * @param {number} [px] - The x-component of a world-space offset from the body's position
     * where the force is applied.
     * @param {number} [py] - The y-component of a world-space offset from the body's position
     * where the force is applied.
     * @param {number} [pz] - The z-component of a world-space offset from the body's position
     * where the force is applied.
     * @example
     * // Apply an approximation of gravity at the body's center
     * this.entity.rigidbody.applyForce(0, -10, 0);
     * @example
     * // Apply an approximation of gravity at 1 unit down the world Z from the center of the body
     * this.entity.rigidbody.applyForce(0, -10, 0, 0, 0, 1);
     * @example
     * // Apply a force at the body's center
     * // Calculate a force vector pointing in the world space direction of the entity
     * var force = this.entity.forward.clone().mulScalar(100);
     *
     * // Apply the force
     * this.entity.rigidbody.applyForce(force);
     * @example
     * // Apply a force at some relative offset from the body's center
     * // Calculate a force vector pointing in the world space direction of the entity
     * var force = this.entity.forward.clone().mulScalar(100);
     *
     * // Calculate the world space relative offset
     * var relativePos = new pc.Vec3();
     * var childEntity = this.entity.findByName('Engine');
     * relativePos.sub2(childEntity.getPosition(), this.entity.getPosition());
     *
     * // Apply the force
     * this.entity.rigidbody.applyForce(force, relativePos);
     */
    applyForce(...args: any[]): void;
    /**
     * Apply torque (rotational force) to the body. This function has two valid signatures. You can
     * either specify the torque force with a 3D-vector or with 3 numbers.
     *
     * @param {Vec3|number} x - A 3-dimensional vector representing the torque force in world-space
     * or the x-component of the torque force in world-space.
     * @param {number} [y] - The y-component of the torque force in world-space.
     * @param {number} [z] - The z-component of the torque force in world-space.
     * @example
     * // Apply via vector
     * var torque = new pc.Vec3(0, 10, 0);
     * entity.rigidbody.applyTorque(torque);
     * @example
     * // Apply via numbers
     * entity.rigidbody.applyTorque(0, 10, 0);
     */
    applyTorque(...args: any[]): void;
    /**
     * Apply an impulse (instantaneous change of velocity) to the body at a point. This function
     * has two valid signatures. You can either specify the impulse (and optional relative point)
     * via 3D-vector or numbers.
     *
     * @param {Vec3|number} x - A 3-dimensional vector representing the impulse in world-space or
     * the x-component of the impulse in world-space.
     * @param {Vec3|number} [y] - An optional 3-dimensional vector representing the relative point
     * at which to apply the impulse in the local-space of the entity or the y-component of the
     * impulse to apply in world-space.
     * @param {number} [z] - The z-component of the impulse to apply in world-space.
     * @param {number} [px=0] - The x-component of the point at which to apply the impulse in the
     * local-space of the entity.
     * @param {number} [py=0] - The y-component of the point at which to apply the impulse in the
     * local-space of the entity.
     * @param {number} [pz=0] - The z-component of the point at which to apply the impulse in the
     * local-space of the entity.
     * @example
     * // Apply an impulse along the world-space positive y-axis at the entity's position.
     * var impulse = new pc.Vec3(0, 10, 0);
     * entity.rigidbody.applyImpulse(impulse);
     * @example
     * // Apply an impulse along the world-space positive y-axis at 1 unit down the positive
     * // z-axis of the entity's local-space.
     * var impulse = new pc.Vec3(0, 10, 0);
     * var relativePoint = new pc.Vec3(0, 0, 1);
     * entity.rigidbody.applyImpulse(impulse, relativePoint);
     * @example
     * // Apply an impulse along the world-space positive y-axis at the entity's position.
     * entity.rigidbody.applyImpulse(0, 10, 0);
     * @example
     * // Apply an impulse along the world-space positive y-axis at 1 unit down the positive
     * // z-axis of the entity's local-space.
     * entity.rigidbody.applyImpulse(0, 10, 0, 0, 0, 1);
     */
    applyImpulse(...args: any[]): void;
    /**
     * Apply a torque impulse (rotational force applied instantaneously) to the body. This function
     * has two valid signatures. You can either specify the torque force with a 3D-vector or with 3
     * numbers.
     *
     * @param {Vec3|number} x - A 3-dimensional vector representing the torque impulse in
     * world-space or the x-component of the torque impulse in world-space.
     * @param {number} [y] - The y-component of the torque impulse in world-space.
     * @param {number} [z] - The z-component of the torque impulse in world-space.
     * @example
     * // Apply via vector
     * var torque = new pc.Vec3(0, 10, 0);
     * entity.rigidbody.applyTorqueImpulse(torque);
     * @example
     * // Apply via numbers
     * entity.rigidbody.applyTorqueImpulse(0, 10, 0);
     */
    applyTorqueImpulse(...args: any[]): void;
    /**
     * Returns true if the rigid body is of type {@link BODYTYPE_STATIC}.
     *
     * @returns {boolean} True if static.
     */
    isStatic(): boolean;
    /**
     * Returns true if the rigid body is of type {@link BODYTYPE_STATIC} or {@link BODYTYPE_KINEMATIC}.
     *
     * @returns {boolean} True if static or kinematic.
     */
    isStaticOrKinematic(): boolean;
    /**
     * Returns true if the rigid body is of type {@link BODYTYPE_KINEMATIC}.
     *
     * @returns {boolean} True if kinematic.
     */
    isKinematic(): boolean;
    /**
     * Writes an entity transform into an Ammo.btTransform but ignoring scale.
     *
     * @param {object} transform - The ammo transform to write the entity transform to.
     * @private
     */
    private _getEntityTransform;
    /**
     * Set the rigid body transform to be the same as the Entity transform. This must be called
     * after any Entity transformation functions (e.g. {@link Entity#setPosition}) are called in
     * order to update the rigid body to match the Entity.
     *
     * @private
     */
    private syncEntityToBody;
    /**
     * Sets an entity's transform to match that of the world transformation matrix of a dynamic
     * rigid body's motion state.
     *
     * @private
     */
    private _updateDynamic;
    /**
     * Writes the entity's world transformation matrix into the motion state of a kinematic body.
     *
     * @private
     */
    private _updateKinematic;
    /**
     * Teleport an entity to a new world-space position, optionally setting orientation. This
     * function should only be called for rigid bodies that are dynamic. This function has three
     * valid signatures. The first takes a 3-dimensional vector for the position and an optional
     * 3-dimensional vector for Euler rotation. The second takes a 3-dimensional vector for the
     * position and an optional quaternion for rotation. The third takes 3 numbers for the position
     * and an optional 3 numbers for Euler rotation.
     *
     * @param {Vec3|number} x - A 3-dimensional vector holding the new position or the new position
     * x-coordinate.
     * @param {Vec3|Quat|number} y - A 3-dimensional vector or quaternion holding the new rotation
     * or the new position y-coordinate.
     * @param {number} [z] - The new position z-coordinate.
     * @param {number} [rx] - The new Euler x-angle value.
     * @param {number} [ry] - The new Euler y-angle value.
     * @param {number} [rz] - The new Euler z-angle value.
     * @example
     * // Teleport the entity to the origin
     * entity.rigidbody.teleport(pc.Vec3.ZERO);
     * @example
     * // Teleport the entity to the origin
     * entity.rigidbody.teleport(0, 0, 0);
     * @example
     * // Teleport the entity to world-space coordinate [1, 2, 3] and reset orientation
     * var position = new pc.Vec3(1, 2, 3);
     * entity.rigidbody.teleport(position, pc.Vec3.ZERO);
     * @example
     * // Teleport the entity to world-space coordinate [1, 2, 3] and reset orientation
     * entity.rigidbody.teleport(1, 2, 3, 0, 0, 0);
     */
    teleport(...args: any[]): void;
}

declare class RenderComponentData {
    enabled: boolean;
    rootBone: any;
}

/**
 * Allows an Entity to render a mesh or a primitive shape like a box, capsule, sphere, cylinder,
 * cone etc.
 *
 * @augments ComponentSystem
 */
declare class RenderComponentSystem extends ComponentSystem {
    id: string;
    ComponentType: typeof RenderComponent;
    DataType: typeof RenderComponentData;
    schema: (string | {
        name: string;
        type: string;
    })[];
    defaultMaterial: StandardMaterial;
    initializeComponentData(component: any, _data: any, properties: any): void;
    cloneComponent(entity: any, clone: any): Component;
    onRemove(entity: any, component: any): void;
}



/** @typedef {import('../../../scene/materials/material.js').Material} Material */
/** @typedef {import('../../../shape/bounding-box.js').BoundingBox} BoundingBox */
/** @typedef {import('../../entity.js').Entity} Entity */
/** @typedef {import('./system.js').RenderComponentSystem} RenderComponentSystem */
/**
 * Enables an Entity to render a {@link Mesh} or a primitive shape. This component attaches
 * {@link MeshInstance} geometry to the Entity.
 *
 * @property {Entity} rootBone A reference to the entity to be used as the root bone for any
 * skinned meshes that are rendered by this component.
 * @augments Component
 */
declare class RenderComponent extends Component {
    /**
     * Create a new RenderComponent.
     *
     * @param {RenderComponentSystem} system - The ComponentSystem that created this Component.
     * @param {Entity} entity - The Entity that this Component is attached to.
     */
    constructor(system: RenderComponentSystem, entity: Entity);
    /** @private */
    private _type;
    /** @private */
    private _castShadows;
    /** @private */
    private _receiveShadows;
    /** @private */
    private _castShadowsLightmap;
    /** @private */
    private _lightmapped;
    /** @private */
    private _lightmapSizeMultiplier;
    /** @private */
    private _isStatic;
    /** @private */
    private _batchGroupId;
    /** @private */
    private _layers;
    /** @private */
    private _renderStyle;
    /**
     * @type {MeshInstance[]}
     * @private
     */
    private _meshInstances;
    /**
     * @type {BoundingBox|null}
     * @private
     */
    private _customAabb;
    /**
     * Used by lightmapper.
     *
     * @type {{x: number, y: number, z: number, uv: number}|null}
     * @ignore
     */
    _area: {
        x: number;
        y: number;
        z: number;
        uv: number;
    } | null;
    /**
     * @type {AssetReference}
     * @private
     */
    private _assetReference;
    /**
     * @type {AssetReference[]}
     * @private
     */
    private _materialReferences;
    /**
     * Material used to render meshes other than asset type. It gets priority when set to
     * something else than defaultMaterial, otherwise materialASsets[0] is used.
     *
     * @type {Material}
     * @private
     */
    private _material;
    /**
     * @type {EntityReference}
     * @private
     */
    private _rootBone;
    /**
     * Set rendering of all {@link MeshInstance}s to the specified render style. Can be:
     *
     * - {@link RENDERSTYLE_SOLID}
     * - {@link RENDERSTYLE_WIREFRAME}
     * - {@link RENDERSTYLE_POINTS}
     *
     * Defaults to {@link RENDERSTYLE_SOLID}.
     *
     * @type {number}
     */
    set renderStyle(arg: number);
    get renderStyle(): number;
    /**
     * If set, the object space bounding box is used as a bounding box for visibility culling of
     * attached mesh instances. This is an optimization, allowing oversized bounding box to be
     * specified for skinned characters in order to avoid per frame bounding box computations based
     * on bone positions.
     *
     * @type {BoundingBox}
     */
    set customAabb(arg: BoundingBox);
    get customAabb(): BoundingBox;
    /**
     * The type of the render. Can be one of the following:
     *
     * - "asset": The component will render a render asset
     * - "box": The component will render a box (1 unit in each dimension)
     * - "capsule": The component will render a capsule (radius 0.5, height 2)
     * - "cone": The component will render a cone (radius 0.5, height 1)
     * - "cylinder": The component will render a cylinder (radius 0.5, height 1)
     * - "plane": The component will render a plane (1 unit in each dimension)
     * - "sphere": The component will render a sphere (radius 0.5)
     * - "torus": The component will render a torus (tubeRadius: 0.2, ringRadius: 0.3)
     *
     * @type {string}
     */
    set type(arg: string);
    get type(): string;
    /**
     * An array of meshInstances contained in the component. If meshes are not set or loaded for
     * component it will return null.
     *
     * @type {MeshInstance[]}
     */
    set meshInstances(arg: MeshInstance[]);
    get meshInstances(): MeshInstance[];
    /**
     * If true, the meshes will be lightmapped after using lightmapper.bake().
     *
     * @type {boolean}
     */
    set lightmapped(arg: boolean);
    get lightmapped(): boolean;
    /**
     * If true, attached meshes will cast shadows for lights that have shadow casting enabled.
     *
     * @type {boolean}
     */
    set castShadows(arg: boolean);
    get castShadows(): boolean;
    /**
     * If true, shadows will be cast on attached meshes.
     *
     * @type {boolean}
     */
    set receiveShadows(arg: boolean);
    get receiveShadows(): boolean;
    /**
     * If true, the meshes will cast shadows when rendering lightmaps.
     *
     * @type {boolean}
     */
    set castShadowsLightmap(arg: boolean);
    get castShadowsLightmap(): boolean;
    /**
     * Lightmap resolution multiplier.
     *
     * @type {number}
     */
    set lightmapSizeMultiplier(arg: number);
    get lightmapSizeMultiplier(): number;
    /**
     * Mark meshes as non-movable (optimization).
     *
     * @type {boolean}
     */
    set isStatic(arg: boolean);
    get isStatic(): boolean;
    /**
     * An array of layer IDs ({@link Layer#id}) to which the meshes should belong. Don't push, pop,
     * splice or modify this array, if you want to change it - set a new one instead.
     *
     * @type {number[]}
     */
    set layers(arg: number[]);
    get layers(): number[];
    /**
     * Assign meshes to a specific batch group (see {@link BatchGroup}). Default is -1 (no group).
     *
     * @type {number}
     */
    set batchGroupId(arg: number);
    get batchGroupId(): number;
    /**
     * The material {@link Material} that will be used to render the meshes (not used on renders of
     * type 'asset').
     *
     * @type {Material}
     */
    set material(arg: Material);
    get material(): Material;
    /**
     * The material assets that will be used to render the meshes. Each material corresponds to the
     * respective mesh instance.
     *
     * @type {Asset[]|number[]}
     */
    set materialAssets(arg: any[]);
    get materialAssets(): any[];
    /**
     * The render asset for the render component (only applies to type 'asset') - can also be an
     * asset id.
     *
     * @type {Asset|number}
     */
    set asset(arg: any);
    get asset(): any;
    /**
     * Assign asset id to the component, without updating the component with the new asset.
     * This can be used to assign the asset id to already fully created component.
     *
     * @param {Asset|number} asset - The render asset or asset id to assign.
     * @ignore
     */
    assignAsset(asset: Asset | number): void;
    /**
     * @param {Entity} entity - The entity set as the root bone.
     * @private
     */
    private _onSetRootBone;
    /** @private */
    private _onRootBoneChanged;
    /** @private */
    private destroyMeshInstances;
    /** @private */
    private addToLayers;
    removeFromLayers(): void;
    /** @private */
    private onRemoveChild;
    /** @private */
    private onInsertChild;
    onRemove(): void;
    materialAsset: any;
    onLayersChanged(oldComp: any, newComp: any): void;
    onLayerAdded(layer: any): void;
    onLayerRemoved(layer: any): void;
    /**
     * Stop rendering {@link MeshInstance}s without removing them from the scene hierarchy. This
     * method sets the {@link MeshInstance#visible} property of every MeshInstance to false. Note,
     * this does not remove the mesh instances from the scene hierarchy or draw call list. So the
     * render component still incurs some CPU overhead.
     */
    hide(): void;
    /**
     * Enable rendering of the component's {@link MeshInstance}s if hidden using
     * {@link RenderComponent#hide}. This method sets the {@link MeshInstance#visible} property on
     * all mesh instances to true.
     */
    show(): void;
    _onRenderAssetAdded(): void;
    _onRenderAssetLoad(): void;
    _onSetMeshes(meshes: any): void;
    _clearSkinInstances(): void;
    _cloneSkinInstances(): void;
    _cloneMeshes(meshes: any): void;
    _onRenderAssetUnload(): void;
    _onRenderAssetRemove(): void;
    _onMaterialAdded(index: any, component: any, asset: any): void;
    _updateMainMaterial(index: any, material: any): void;
    _onMaterialLoad(index: any, component: any, asset: any): void;
    _onMaterialRemove(index: any, component: any, asset: any): void;
    _onMaterialUnload(index: any, component: any, asset: any): void;
    resolveDuplicatedEntityReferenceProperties(oldRender: any, duplicatedIdsMap: any): void;
    rootBone: any;
}

declare class ParticleSystemComponentData {
    numParticles: number;
    rate: number;
    rate2: any;
    startAngle: number;
    startAngle2: any;
    lifetime: number;
    emitterExtents: Vec3;
    emitterExtentsInner: Vec3;
    emitterRadius: number;
    emitterRadiusInner: number;
    emitterShape: number;
    initialVelocity: number;
    wrapBounds: Vec3;
    localSpace: boolean;
    screenSpace: boolean;
    colorMap: any;
    colorMapAsset: any;
    normalMap: any;
    normalMapAsset: any;
    loop: boolean;
    preWarm: boolean;
    sort: number;
    mode: number;
    scene: any;
    lighting: boolean;
    halfLambert: boolean;
    intensity: number;
    stretch: number;
    alignToMotion: boolean;
    depthSoftening: number;
    meshAsset: any;
    mesh: any;
    depthWrite: boolean;
    noFog: boolean;
    orientation: number;
    particleNormal: Vec3;
    animTilesX: number;
    animTilesY: number;
    animStartFrame: number;
    animNumFrames: number;
    animNumAnimations: number;
    animIndex: number;
    randomizeAnimIndex: boolean;
    animSpeed: number;
    animLoop: boolean;
    scaleGraph: any;
    scaleGraph2: any;
    colorGraph: any;
    colorGraph2: any;
    alphaGraph: any;
    alphaGraph2: any;
    localVelocityGraph: any;
    localVelocityGraph2: any;
    velocityGraph: any;
    velocityGraph2: any;
    rotationSpeedGraph: any;
    rotationSpeedGraph2: any;
    radialSpeedGraph: any;
    radialSpeedGraph2: any;
    blendType: number;
    enabled: boolean;
    paused: boolean;
    autoPlay: boolean;
    layers: number[];
}

/**
 * Allows an Entity to render a particle system.
 *
 * @augments ComponentSystem
 */
declare class ParticleSystemComponentSystem extends ComponentSystem {
    id: string;
    ComponentType: typeof ParticleSystemComponent;
    DataType: typeof ParticleSystemComponentData;
    schema: string[];
    propertyTypes: {
        emitterExtents: string;
        emitterExtentsInner: string;
        particleNormal: string;
        wrapBounds: string;
        localVelocityGraph: string;
        localVelocityGraph2: string;
        velocityGraph: string;
        velocityGraph2: string;
        colorGraph: string;
        colorGraph2: string;
        alphaGraph: string;
        alphaGraph2: string;
        rotationSpeedGraph: string;
        rotationSpeedGraph2: string;
        radialSpeedGraph: string;
        radialSpeedGraph2: string;
        scaleGraph: string;
        scaleGraph2: string;
    };
    initializeComponentData(component: any, _data: any, properties: any): void;
    cloneComponent(entity: any, clone: any): Component;
    onUpdate(dt: any): void;
    onBeforeRemove(entity: any, component: any): void;
}

/**
 * A curve is a collection of keys (time/value pairs). The shape of the curve is defined by its
 * type that specifies an interpolation scheme for the keys.
 */
declare class Curve {
    /**
     * Creates a new Curve instance.
     *
     * @param {number[]} [data] - An array of keys (pairs of numbers with the time first and value
     * second).
     * @example
     * var curve = new pc.Curve([
     *     0, 0,        // At 0 time, value of 0
     *     0.33, 2,     // At 0.33 time, value of 2
     *     0.66, 2.6,   // At 0.66 time, value of 2.6
     *     1, 3         // At 1 time, value of 3
     * ]);
     */
    constructor(data?: number[]);
    keys: number[][];
    /**
     * The curve interpolation scheme. Can be:
     *
     * - {@link CURVE_LINEAR}
     * - {@link CURVE_SMOOTHSTEP}
     * - {@link CURVE_SPLINE}
     * - {@link CURVE_STEP}
     *
     * Defaults to {@link CURVE_SMOOTHSTEP}.
     *
     * @type {number}
     */
    type: number;
    /**
     * Controls how {@link CURVE_SPLINE} tangents are calculated. Valid range is between 0 and
     * 1 where 0 results in a non-smooth curve (equivalent to linear interpolation) and 1
     * results in a very smooth curve. Use 0.5 for a Catmull-rom spline.
     *
     * @type {number}
     */
    tension: number;
    /**
     * @type {CurveEvaluator}
     * @private
     */
    private _eval;
    /**
     * Get the number of keys in the curve.
     *
     * @type {number}
     */
    get length(): number;
    /**
     * Add a new key to the curve.
     *
     * @param {number} time - Time to add new key.
     * @param {number} value - Value of new key.
     * @returns {number[]} [time, value] pair.
     */
    add(time: number, value: number): number[];
    /**
     * Return a specific key.
     *
     * @param {number} index - The index of the key to return.
     * @returns {number[]} The key at the specified index.
     */
    get(index: number): number[];
    /**
     * Sort keys by time.
     */
    sort(): void;
    /**
     * Returns the interpolated value of the curve at specified time.
     *
     * @param {number} time - The time at which to calculate the value.
     * @returns {number} The interpolated value.
     */
    value(time: number): number;
    closest(time: any): number[];
    /**
     * Returns a clone of the specified curve object.
     *
     * @returns {this} A clone of the specified curve.
     */
    clone(): this;
    /**
     * Sample the curve at regular intervals over the range [0..1].
     *
     * @param {number} precision - The number of samples to return.
     * @returns {Float32Array} The set of quantized values.
     * @ignore
     */
    quantize(precision: number): Float32Array;
    /**
     * Sample the curve at regular intervals over the range [0..1] and clamp the resulting samples
     * to [min..max].
     *
     * @param {number} precision - The number of samples to return.
     * @param {number} min - The minimum output value.
     * @param {number} max - The maximum output value.
     * @returns {Float32Array} The set of quantized values.
     * @ignore
     */
    quantizeClamped(precision: number, min: number, max: number): Float32Array;
}

/**
 * A curve set is a collection of curves.
 */
declare class CurveSet {
    /**
     * Creates a new CurveSet instance.
     *
     * @param {Array<number[]>} curveKeys - An array of arrays of keys (pairs of numbers with the
     * time first and value second).
     * @example
     * var curveSet = new pc.CurveSet([
     *     [
     *         0, 0,        // At 0 time, value of 0
     *         0.33, 2,     // At 0.33 time, value of 2
     *         0.66, 2.6,   // At 0.66 time, value of 2.6
     *         1, 3         // At 1 time, value of 3
     *     ],
     *     [
     *         0, 34,
     *         0.33, 35,
     *         0.66, 36,
     *         1, 37
     *     ]
     * ]);
     */
    constructor(...args: any[]);
    curves: Curve[];
    /**
     * @type {number}
     * @private
     */
    private _type;
    /**
     * The number of curves in the curve set.
     *
     * @type {number}
     */
    get length(): number;
    /**
     * The interpolation scheme applied to all curves in the curve set. Can be:
     *
     * - {@link CURVE_LINEAR}
     * - {@link CURVE_SMOOTHSTEP}
     * - {@link CURVE_SPLINE}
     * - {@link CURVE_STEP}
     *
     * Defaults to {@link CURVE_SMOOTHSTEP}.
     *
     * @type {number}
     */
    set type(arg: number);
    get type(): number;
    /**
     * Return a specific curve in the curve set.
     *
     * @param {number} index - The index of the curve to return.
     * @returns {Curve} The curve at the specified index.
     */
    get(index: number): Curve;
    /**
     * Returns the interpolated value of all curves in the curve set at the specified time.
     *
     * @param {number} time - The time at which to calculate the value.
     * @param {number[]} [result] - The interpolated curve values at the specified time. If this
     * parameter is not supplied, the function allocates a new array internally to return the
     * result.
     * @returns {number[]} The interpolated curve values at the specified time.
     */
    value(time: number, result?: number[]): number[];
    /**
     * Returns a clone of the specified curve set object.
     *
     * @returns {this} A clone of the specified curve set.
     */
    clone(): this;
    /**
     * Sample the curveset at regular intervals over the range [0..1].
     *
     * @param {number} precision - The number of samples to return.
     * @returns {Float32Array} The set of quantized values.
     * @ignore
     */
    quantize(precision: number): Float32Array;
    /**
     * Sample the curveset at regular intervals over the range [0..1] and clamp the result to min
     * and max.
     *
     * @param {number} precision - The number of samples to return.
     * @param {number} min - The minimum output value.
     * @param {number} max - The maximum output value.
     * @returns {Float32Array} The set of quantized values.
     * @ignore
     */
    quantizeClamped(precision: number, min: number, max: number): Float32Array;
}

declare class ParticleGPUUpdater {
    constructor(emitter: any, gd: any);
    _emitter: any;
    frameRandomUniform: Float32Array;
    emitterPosUniform: Float32Array;
    emitterScaleUniform: Float32Array;
    worldBoundsMulUniform: Float32Array;
    worldBoundsAddUniform: Float32Array;
    inBoundsSizeUniform: Float32Array;
    inBoundsCenterUniform: Float32Array;
    constantParticleTexIN: any;
    constantParticleTexOUT: any;
    constantEmitterPos: any;
    constantEmitterScale: any;
    constantSpawnBounds: any;
    constantSpawnPosInnerRatio: any;
    constantSpawnBoundsSphere: any;
    constantSpawnBoundsSphereInnerRatio: any;
    constantInitialVelocity: any;
    constantFrameRandom: any;
    constantDelta: any;
    constantRate: any;
    constantRateDiv: any;
    constantLifetime: any;
    constantGraphSampleSize: any;
    constantGraphNumSamples: any;
    constantInternalTex0: any;
    constantInternalTex1: any;
    constantInternalTex2: any;
    constantInternalTex3: any;
    constantEmitterMatrix: any;
    constantEmitterMatrixInv: any;
    constantNumParticles: any;
    constantNumParticlesPot: any;
    constantLocalVelocityDivMult: any;
    constantVelocityDivMult: any;
    constantRotSpeedDivMult: any;
    constantSeed: any;
    constantStartAngle: any;
    constantStartAngle2: any;
    constantOutBoundsMul: any;
    constantOutBoundsAdd: any;
    constantInBoundsSize: any;
    constantInBoundsCenter: any;
    constantMaxVel: any;
    constantFaceTangent: any;
    constantFaceBinorm: any;
    _setInputBounds(): void;
    randomize(): void;
    update(device: any, spawnMatrix: any, extentsInnerRatioUniform: any, delta: any, isOnStop: any): void;
}

declare class ParticleCPUUpdater {
    constructor(emitter: any);
    _emitter: any;
    calcSpawnPosition(particleTex: any, spawnMatrix: any, extentsInnerRatioUniform: any, emitterPos: any, i: any): void;
    update(data: any, vbToSort: any, particleTex: any, spawnMatrix: any, extentsInnerRatioUniform: any, emitterPos: any, delta: any, isOnStop: any): void;
}

declare class ParticleEmitter {
    constructor(graphicsDevice: any, options: any);
    graphicsDevice: any;
    precision: number;
    _addTimeTime: number;
    numParticles: any;
    _gpuUpdater: ParticleGPUUpdater;
    _cpuUpdater: ParticleCPUUpdater;
    constantLightCube: any;
    emitterPosUniform: Float32Array;
    wrapBoundsUniform: Float32Array;
    emitterScaleUniform: Float32Array;
    lightCube: Float32Array;
    lightCubeDir: any[];
    animTilesParams: Float32Array;
    animParams: Float32Array;
    animIndexParams: Float32Array;
    internalTex0: Texture;
    internalTex1: Texture;
    internalTex2: Texture;
    colorParam: Texture;
    vbToSort: any[];
    vbOld: Float32Array;
    particleDistance: Float32Array;
    camera: any;
    swapTex: boolean;
    useMesh: boolean;
    useCpu: boolean;
    pack8: boolean;
    localBounds: BoundingBox;
    worldBoundsNoTrail: BoundingBox;
    worldBoundsTrail: BoundingBox[];
    worldBounds: BoundingBox;
    worldBoundsSize: Vec3;
    prevWorldBoundsSize: Vec3;
    prevWorldBoundsCenter: Vec3;
    prevEmitterExtents: any;
    prevEmitterRadius: any;
    worldBoundsMul: Vec3;
    worldBoundsAdd: Vec3;
    timeToSwitchBounds: number;
    shaderParticleUpdateRespawn: Shader;
    shaderParticleUpdateNoRespawn: Shader;
    shaderParticleUpdateOnStop: Shader;
    numParticleVerts: number;
    numParticleIndices: number;
    material: Material;
    meshInstance: MeshInstance;
    drawOrder: number;
    seed: number;
    fixedTimeStep: number;
    maxSubSteps: number;
    simTime: number;
    simTimeTotal: number;
    beenReset: boolean;
    _layer: any;
    get defaultParamTexture(): any;
    onChangeCamera(): void;
    calculateBoundsMad(): void;
    calculateWorldBounds(): void;
    resetWorldBounds(): void;
    calculateLocalBounds(): void;
    rebuild(): void;
    colorMap: any;
    spawnBounds: any;
    numParticlesPot: number;
    particleTex: Float32Array;
    particleTexStart: any;
    particleTexIN: Texture;
    particleTexOUT: Texture;
    rtParticleTexIN: RenderTarget;
    rtParticleTexOUT: RenderTarget;
    _isAnimated(): any;
    rebuildGraphs(): void;
    qLocalVelocity: any;
    qVelocity: any;
    qColor: any;
    qRotSpeed: any;
    qScale: any;
    qAlpha: any;
    qRadialSpeed: any;
    qLocalVelocity2: any;
    qVelocity2: any;
    qColor2: any;
    qRotSpeed2: any;
    qScale2: any;
    qAlpha2: any;
    qRadialSpeed2: any;
    localVelocityUMax: Float32Array;
    velocityUMax: Float32Array;
    colorUMax: Float32Array;
    rotSpeedUMax: number[];
    scaleUMax: number[];
    alphaUMax: number[];
    radialSpeedUMax: number[];
    qLocalVelocityDiv: Float32Array;
    qVelocityDiv: Float32Array;
    qColorDiv: Float32Array;
    qRotSpeedDiv: Float32Array;
    qScaleDiv: Float32Array;
    qAlphaDiv: Float32Array;
    qRadialSpeedDiv: Float32Array;
    maxVel: number;
    internalTex3: Texture;
    _initializeTextures(): void;
    regenShader(): void;
    normalOption: number;
    resetMaterial(): void;
    _compParticleFaceParams(): void;
    _allocate(numParticles: any): void;
    vertexBuffer: VertexBuffer;
    indexBuffer: IndexBuffer;
    vbCPU: Float32Array;
    reset(): void;
    loop: any;
    prewarm(time: any): void;
    resetTime(): void;
    endTime: number;
    finishFrame(): void;
    addTime(delta: any, isOnStop: any): void;
    _destroyResources(): void;
    destroy(): void;
}






/**
 * Used to simulate particles and produce renderable particle mesh on either CPU or GPU. GPU
 * simulation is generally much faster than its CPU counterpart, because it avoids slow CPU-GPU
 * synchronization and takes advantage of many GPU cores. However, it requires client to support
 * reasonable uniform count, reading from multiple textures in vertex shader and OES_texture_float
 * extension, including rendering into float textures. Most mobile devices fail to satisfy these
 * requirements, so it's not recommended to simulate thousands of particles on them. GPU version
 * also can't sort particles, so enabling sorting forces CPU mode too. Particle rotation is
 * specified by a single angle parameter: default billboard particles rotate around camera facing
 * axis, while mesh particles rotate around 2 different view-independent axes. Most of the
 * simulation parameters are specified with {@link Curve} or {@link CurveSet}. Curves are
 * interpolated based on each particle's lifetime, therefore parameters are able to change over
 * time. Most of the curve parameters can also be specified by 2 minimum/maximum curves, this way
 * each particle will pick a random value in-between.
 *
 * @property {boolean} autoPlay Controls whether the particle system plays automatically on
 * creation. If set to false, it is necessary to call {@link ParticleSystemComponent#play} for the
 * particle system to play. Defaults to true.
 * @property {boolean} loop Enables or disables respawning of particles.
 * @property {boolean} preWarm If enabled, the particle system will be initialized as though it had
 * already completed a full cycle. This only works with looping particle systems.
 * @property {boolean} lighting If enabled, particles will be lit by ambient and directional
 * lights.
 * @property {boolean} halfLambert Enabling Half Lambert lighting avoids particles looking too flat
 * in shadowed areas. It is a completely non-physical lighting model but can give more pleasing
 * visual results.
 * @property {boolean} alignToMotion Orient particles in their direction of motion.
 * @property {boolean} depthWrite If enabled, the particles will write to the depth buffer. If
 * disabled, the depth buffer is left unchanged and particles will be guaranteed to overwrite one
 * another in the order in which they are rendered.
 * @property {boolean} noFog Disable fogging.
 * @property {boolean} localSpace Binds particles to emitter transformation rather then world
 * space.
 * @property {boolean} screenSpace Renders particles in 2D screen space. This needs to be set when
 * particle system is part of hierarchy with {@link ScreenComponent} as its ancestor, and allows
 * particle system to integrate with the rendering of {@link ElementComponent}s. Note that an
 * entity with ParticleSystem component cannot be parented directly to {@link ScreenComponent}, but
 * has to be a child of a {@link ElementComponent}, for example {@link LayoutGroupComponent}.
 * @property {number} numParticles Maximum number of simulated particles.
 * @property {number} rate Minimal interval in seconds between particle births.
 * @property {number} rate2 Maximal interval in seconds between particle births.
 * @property {number} startAngle Minimal initial Euler angle of a particle.
 * @property {number} startAngle2 Maximal initial Euler angle of a particle.
 * @property {number} lifetime The length of time in seconds between a particle's birth and its
 * death.
 * @property {number} stretch A value in world units that controls the amount by which particles
 * are stretched based on their velocity. Particles are stretched from their center towards their
 * previous position.
 * @property {number} intensity Color multiplier.
 * @property {boolean} animLoop Controls whether the sprite sheet animation plays once or loops
 * continuously.
 * @property {number} animTilesX Number of horizontal tiles in the sprite sheet.
 * @property {number} animTilesY Number of vertical tiles in the sprite sheet.
 * @property {number} animNumAnimations Number of sprite sheet animations contained within the
 * current sprite sheet. The number of animations multiplied by number of frames should be a value
 * less than animTilesX multiplied by animTilesY.
 * @property {number} animNumFrames Number of sprite sheet frames in the current sprite sheet
 * animation. The number of animations multiplied by number of frames should be a value less than
 * animTilesX multiplied by animTilesY.
 * @property {number} animStartFrame The sprite sheet frame that the animation should begin playing
 * from. Indexed from the start of the current animation.
 * @property {number} animIndex When animNumAnimations is greater than 1, the sprite sheet
 * animation index determines which animation the particle system should play.
 * @property {number} randomizeAnimIndex Each particle emitted by the system will play a random
 * animation from the sprite sheet, up to animNumAnimations.
 * @property {number} animSpeed Sprite sheet animation speed. 1 = particle lifetime, 2 = twice
 * during lifetime etc...
 * @property {number} depthSoftening Controls fading of particles near their intersections with
 * scene geometry. This effect, when it's non-zero, requires scene depth map to be rendered.
 * Multiple depth-dependent effects can share the same map, but if you only use it for particles,
 * bear in mind that it can double engine draw calls.
 * @property {number} initialVelocity Defines magnitude of the initial emitter velocity. Direction
 * is given by emitter shape.
 * @property {Vec3} emitterExtents (Only for EMITTERSHAPE_BOX) The extents of a local space
 * bounding box within which particles are spawned at random positions.
 * @property {Vec3} emitterExtentsInner (Only for EMITTERSHAPE_BOX) The exception of extents of a
 * local space bounding box within which particles are not spawned. Aligned to the center of
 * EmitterExtents.
 * @property {number} emitterRadius (Only for EMITTERSHAPE_SPHERE) The radius within which
 * particles are spawned at random positions.
 * @property {number} emitterRadiusInner (Only for EMITTERSHAPE_SPHERE) The inner radius within
 * which particles are not spawned.
 * @property {Vec3} wrapBounds The half extents of a world space box volume centered on the owner
 * entity's position. If a particle crosses the boundary of one side of the volume, it teleports to
 * the opposite side.
 * @property {Asset} colorMapAsset The {@link Asset} used to set the colorMap.
 * @property {Asset} normalMapAsset The {@link Asset} used to set the normalMap.
 * @property {Asset} meshAsset The {@link Asset} used to set the mesh.
 * @property {Asset} renderAsset The Render {@link Asset} used to set the mesh.
 * @property {Texture} colorMap The color map texture to apply to all particles in the system. If
 * no texture is assigned, a default spot texture is used.
 * @property {Texture} normalMap The normal map texture to apply to all particles in the system. If
 * no texture is assigned, an approximate spherical normal is calculated for each vertex.
 * @property {number} emitterShape Shape of the emitter. Defines the bounds inside which particles
 * are spawned. Also affects the direction of initial velocity.
 *
 * - {@link EMITTERSHAPE_BOX}: Box shape parameterized by emitterExtents. Initial velocity is
 * directed towards local Z axis.
 * - {@link EMITTERSHAPE_SPHERE}: Sphere shape parameterized by emitterRadius. Initial velocity is
 * directed outwards from the center.
 *
 * @property {number} sort Sorting mode. Forces CPU simulation, so be careful.
 *
 * - {@link PARTICLESORT_NONE}: No sorting, particles are drawn in arbitrary order. Can be
 * simulated on GPU.
 * - {@link PARTICLESORT_DISTANCE}: Sorting based on distance to the camera. CPU only.
 * - {@link PARTICLESORT_NEWER_FIRST}: Newer particles are drawn first. CPU only.
 * - {@link PARTICLESORT_OLDER_FIRST}: Older particles are drawn first. CPU only.
 *
 * @property {Mesh} mesh Triangular mesh to be used as a particle. Only first vertex/index buffer
 * is used. Vertex buffer must contain local position at first 3 floats of each vertex.
 * @property {number} blend Controls how particles are blended when being written to the currently
 * active render target. Can be:
 *
 * - {@link BLEND_SUBTRACTIVE}: Subtract the color of the source fragment from the destination
 * fragment and write the result to the frame buffer.
 * - {@link BLEND_ADDITIVE}: Add the color of the source fragment to the destination fragment and
 * write the result to the frame buffer.
 * - {@link BLEND_NORMAL}: Enable simple translucency for materials such as glass. This is
 * equivalent to enabling a source blend mode of {@link BLENDMODE_SRC_ALPHA} and a destination
 * blend mode of {@link BLENDMODE_ONE_MINUS_SRC_ALPHA}.
 * - {@link BLEND_NONE}: Disable blending.
 * - {@link BLEND_PREMULTIPLIED}: Similar to {@link BLEND_NORMAL} expect the source fragment is
 * assumed to have already been multiplied by the source alpha value.
 * - {@link BLEND_MULTIPLICATIVE}: Multiply the color of the source fragment by the color of the
 * destination fragment and write the result to the frame buffer.
 * - {@link BLEND_ADDITIVEALPHA}: Same as {@link BLEND_ADDITIVE} except the source RGB is
 * multiplied by the source alpha.
 *
 * @property {number} orientation Sorting mode. Forces CPU simulation, so be careful.
 *
 * - {@link PARTICLEORIENTATION_SCREEN}: Particles are facing camera.
 * - {@link PARTICLEORIENTATION_WORLD}: User defines world space normal (particleNormal) to set
 * planes orientation.
 * - {@link PARTICLEORIENTATION_EMITTER}: Similar to previous, but the normal is affected by
 * emitter (entity) transformation.
 *
 * @property {Vec3} particleNormal (Only for PARTICLEORIENTATION_WORLD and
 * PARTICLEORIENTATION_EMITTER) The exception of extents of a local space bounding box within which
 * particles are not spawned. Aligned to the center of EmitterExtents.
 * @property {CurveSet} localVelocityGraph Velocity relative to emitter over lifetime.
 * @property {CurveSet} localVelocityGraph2 If not null, particles pick random values between
 * localVelocityGraph and localVelocityGraph2.
 * @property {CurveSet} velocityGraph World-space velocity over lifetime.
 * @property {CurveSet} velocityGraph2 If not null, particles pick random values between
 * velocityGraph and velocityGraph2.
 * @property {CurveSet} colorGraph Color over lifetime.
 * @property {Curve} rotationSpeedGraph Rotation speed over lifetime.
 * @property {Curve} rotationSpeedGraph2 If not null, particles pick random values between
 * rotationSpeedGraph and rotationSpeedGraph2.
 * @property {Curve} radialSpeedGraph Radial speed over lifetime, velocity vector points from
 * emitter origin to particle pos.
 * @property {Curve} radialSpeedGraph2 If not null, particles pick random values between
 * radialSpeedGraph and radialSpeedGraph2.
 * @property {Curve} scaleGraph Scale over lifetime.
 * @property {Curve} scaleGraph2 If not null, particles pick random values between scaleGraph and
 * scaleGraph2.
 * @property {Curve} alphaGraph Alpha over lifetime.
 * @property {Curve} alphaGraph2 If not null, particles pick random values between alphaGraph and
 * alphaGraph2.
 * @property {number[]} layers An array of layer IDs ({@link Layer#id}) to which this particle
 * system should belong. Don't push/pop/splice or modify this array, if you want to change it - set
 * a new one instead.
 * @augments Component
 */
declare class ParticleSystemComponent extends Component {
    /**
     * Create a new ParticleSystemComponent.
     *
     * @param {ParticleSystemComponentSystem} system - The ComponentSystem that created this
     * Component.
     * @param {Entity} entity - The Entity this Component is attached to.
     */
    constructor(system: ParticleSystemComponentSystem, entity: Entity);

    set alignToMotion(arg: boolean);
    get alignToMotion(): boolean;

    set alphaGraph(arg: Curve);
    get alphaGraph(): Curve;

    set alphaGraph2(arg: Curve);
    get alphaGraph2(): Curve;

    set animIndex(arg: number);
    get animIndex(): number;

    set animLoop(arg: boolean);
    get animLoop(): boolean;

    set animNumAnimations(arg: number);
    get animNumAnimations(): number;

    set animNumFrames(arg: number);
    get animNumFrames(): number;

    set animSpeed(arg: number);
    get animSpeed(): number;

    set animStartFrame(arg: number);
    get animStartFrame(): number;

    set animTilesX(arg: number);
    get animTilesX(): number;

    set animTilesY(arg: number);
    get animTilesY(): number;

    set autoPlay(arg: boolean);
    get autoPlay(): boolean;

    set blend(arg: number);
    get blend(): number;

    set colorGraph(arg: CurveSet);
    get colorGraph(): CurveSet;

    set colorMapAsset(arg: Asset);
    get colorMapAsset(): Asset;

    set depthSoftening(arg: number);
    get depthSoftening(): number;

    set depthWrite(arg: boolean);
    get depthWrite(): boolean;

    set emitterExtents(arg: Vec3);
    get emitterExtents(): Vec3;

    set emitterExtentsInner(arg: Vec3);
    get emitterExtentsInner(): Vec3;

    set emitterRadius(arg: number);
    get emitterRadius(): number;

    set emitterRadiusInner(arg: number);
    get emitterRadiusInner(): number;

    set emitterShape(arg: number);
    get emitterShape(): number;

    set halfLambert(arg: boolean);
    get halfLambert(): boolean;

    set initialVelocity(arg: number);
    get initialVelocity(): number;

    set intensity(arg: number);
    get intensity(): number;

    set layers(arg: number[]);
    get layers(): number[];

    set lifetime(arg: number);
    get lifetime(): number;

    set lighting(arg: boolean);
    get lighting(): boolean;

    set localSpace(arg: boolean);
    get localSpace(): boolean;

    set localVelocityGraph(arg: CurveSet);
    get localVelocityGraph(): CurveSet;

    set localVelocityGraph2(arg: CurveSet);
    get localVelocityGraph2(): CurveSet;

    set loop(arg: boolean);
    get loop(): boolean;

    set noFog(arg: boolean);
    get noFog(): boolean;

    set normalMapAsset(arg: Asset);
    get normalMapAsset(): Asset;

    set numParticles(arg: number);
    get numParticles(): number;

    set orientation(arg: number);
    get orientation(): number;

    set particleNormal(arg: Vec3);
    get particleNormal(): Vec3;

    set preWarm(arg: boolean);
    get preWarm(): boolean;

    set radialSpeedGraph(arg: Curve);
    get radialSpeedGraph(): Curve;

    set radialSpeedGraph2(arg: Curve);
    get radialSpeedGraph2(): Curve;

    set randomizeAnimIndex(arg: number);
    get randomizeAnimIndex(): number;

    set rate(arg: number);
    get rate(): number;

    set rate2(arg: number);
    get rate2(): number;

    set renderAsset(arg: Asset);
    get renderAsset(): Asset;

    set rotationSpeedGraph(arg: Curve);
    get rotationSpeedGraph(): Curve;

    set rotationSpeedGraph2(arg: Curve);
    get rotationSpeedGraph2(): Curve;

    set scaleGraph(arg: Curve);
    get scaleGraph(): Curve;

    set scaleGraph2(arg: Curve);
    get scaleGraph2(): Curve;

    set screenSpace(arg: boolean);
    get screenSpace(): boolean;

    set sort(arg: number);
    get sort(): number;

    set startAngle(arg: number);
    get startAngle(): number;

    set startAngle2(arg: number);
    get startAngle2(): number;

    set stretch(arg: number);
    get stretch(): number;

    set velocityGraph(arg: CurveSet);
    get velocityGraph(): CurveSet;

    set velocityGraph2(arg: CurveSet);
    get velocityGraph2(): CurveSet;

    set wrapBounds(arg: Vec3);
    get wrapBounds(): Vec3;

    /** @private */
    private _requestedDepth;
    /** @private */
    private _drawOrder;
    set drawOrder(arg: number);
    get drawOrder(): number;
    addMeshInstanceToLayers(): void;
    removeMeshInstanceFromLayers(): void;
    onSetLayers(name: any, oldValue: any, newValue: any): void;
    onLayersChanged(oldComp: any, newComp: any): void;
    onLayerAdded(layer: any): void;
    onLayerRemoved(layer: any): void;
    _bindColorMapAsset(asset: any): void;
    _unbindColorMapAsset(asset: any): void;
    _onColorMapAssetLoad(asset: any): void;
    colorMap: any;
    _onColorMapAssetUnload(asset: any): void;
    _onColorMapAssetRemove(asset: any): void;
    _onColorMapAssetChange(asset: any): void;
    onSetColorMapAsset(name: any, oldValue: any, newValue: any): void;
    _bindNormalMapAsset(asset: any): void;
    _unbindNormalMapAsset(asset: any): void;
    _onNormalMapAssetLoad(asset: any): void;
    normalMap: any;
    _onNormalMapAssetUnload(asset: any): void;
    _onNormalMapAssetRemove(asset: any): void;
    _onNormalMapAssetChange(asset: any): void;
    onSetNormalMapAsset(name: any, oldValue: any, newValue: any): void;
    _bindMeshAsset(asset: any): void;
    _unbindMeshAsset(asset: any): void;
    _onMeshAssetLoad(asset: any): void;
    _onMeshAssetUnload(asset: any): void;
    mesh: any;
    _onMeshAssetRemove(asset: any): void;
    _onMeshAssetChange(asset: any): void;
    onSetMeshAsset(name: any, oldValue: any, newValue: any): void;
    onSetMesh(name: any, oldValue: any, newValue: any): void;
    meshAsset: any;
    _onMeshChanged(mesh: any): void;
    onSetRenderAsset(name: any, oldValue: any, newValue: any): void;
    _bindRenderAsset(asset: any): void;
    _unbindRenderAsset(asset: any): void;
    _onRenderAssetLoad(asset: any): void;
    _onRenderAssetUnload(asset: any): void;
    _onRenderAssetRemove(asset: any): void;
    _onRenderChanged(render: any): void;
    _onRenderSetMeshes(meshes: any): void;
    onSetLoop(name: any, oldValue: any, newValue: any): void;
    onSetBlendType(name: any, oldValue: any, newValue: any): void;
    _requestDepth(): void;
    _releaseDepth(): void;
    onSetDepthSoftening(name: any, oldValue: any, newValue: any): void;
    onSetSimpleProperty(name: any, oldValue: any, newValue: any): void;
    onSetComplexProperty(name: any, oldValue: any, newValue: any): void;
    onSetGraphProperty(name: any, oldValue: any, newValue: any): void;
    emitter: ParticleEmitter;
    onBeforeRemove(): void;
    
    /**
     * Resets particle state, doesn't affect playing.
     */
    reset(): void;
    /**
     * Disables the emission of new particles, lets existing to finish their simulation.
     */
    stop(): void;
    /**
     * Freezes the simulation.
     */
    pause(): void;
    /**
     * Unfreezes the simulation.
     */
    unpause(): void;
    /**
     * Enables/unfreezes the simulation.
     */
    play(): void;
    /**
     * Checks if simulation is in progress.
     *
     * @returns {boolean} True if the particle system is currently playing and false otherwise.
     */
    isPlaying(): boolean;
    /**
     * Rebuilds all data used by this particle system.
     *
     * @private
     */
    private rebuild;
}

declare class ModelComponentData {
    enabled: boolean;
}

/**
 * Allows an Entity to render a model or a primitive shape like a box, capsule, sphere, cylinder,
 * cone etc.
 *
 * @augments ComponentSystem
 */
declare class ModelComponentSystem extends ComponentSystem {
    id: string;
    ComponentType: typeof ModelComponent;
    DataType: typeof ModelComponentData;
    schema: string[];
    defaultMaterial: StandardMaterial;
    initializeComponentData(component: any, _data: any, properties: any): void;
    cloneComponent(entity: any, clone: any): Component;
    onRemove(entity: any, component: any): void;
}



/** @typedef {import('../../../scene/composition/layer-composition.js').LayerComposition} LayerComposition */
/** @typedef {import('../../../scene/materials/material.js').Material} Material */
/** @typedef {import('../../../shape/bounding-box.js').BoundingBox} BoundingBox */
/** @typedef {import('../../entity.js').Entity} Entity */
/** @typedef {import('./system.js').ModelComponentSystem} ModelComponentSystem */
/**
 * Enables an Entity to render a model or a primitive shape. This Component attaches additional
 * model geometry in to the scene graph below the Entity.
 *
 * @augments Component
 */
declare class ModelComponent extends Component {
    /**
     * Create a new ModelComponent instance.
     *
     * @param {ModelComponentSystem} system - The ComponentSystem that created this Component.
     * @param {Entity} entity - The Entity that this Component is attached to.
     */
    constructor(system: ModelComponentSystem, entity: Entity);
    /**
     * @type {string}
     * @private
     */
    private _type;
    /**
     * @type {Asset|number|null}
     * @private
     */
    private _asset;
    /**
     * @type {Model|null}
     * @private
     */
    private _model;
    /**
     * @type {Object<string, number>}
     * @private
     */
    private _mapping;
    /**
     * @type {boolean}
     * @private
     */
    private _castShadows;
    /**
     * @type {boolean}
     * @private
     */
    private _receiveShadows;
    /**
     * @type {Asset|number|null}
     * @private
     */
    private _materialAsset;
    /**
     * @type {Material}
     * @private
     */
    private _material;
    /**
     * @type {boolean}
     * @private
     */
    private _castShadowsLightmap;
    /**
     * @type {boolean}
     * @private
     */
    private _lightmapped;
    /**
     * @type {number}
     * @private
     */
    private _lightmapSizeMultiplier;
    /**
     * @type {boolean}
     * @private
     */
    private _isStatic;
    /**
     * @type {number[]}
     * @private
     */
    private _layers;
    /**
     * @type {number}
     * @private
     */
    private _batchGroupId;
    /**
     * @type {BoundingBox|null}
     * @private
     */
    private _customAabb;
    _area: any;
    _materialEvents: any;
    /**
     * @type {boolean}
     * @private
     */
    private _clonedModel;
    _batchGroup: any;
    /**
     * An array of meshInstances contained in the component's model. If model is not set or loaded
     * for component it will return null.
     *
     * @type {MeshInstance[]|null}
     */
    set meshInstances(arg: MeshInstance[]);
    get meshInstances(): MeshInstance[];
    /**
     * If set, the object space bounding box is used as a bounding box for visibility culling of
     * attached mesh instances. This is an optimization, allowing oversized bounding box to be
     * specified for skinned characters in order to avoid per frame bounding box computations based
     * on bone positions.
     *
     * @type {BoundingBox|null}
     */
    set customAabb(arg: BoundingBox);
    get customAabb(): BoundingBox;
    /**
     * The type of the model. Can be:
     *
     * - "asset": The component will render a model asset
     * - "box": The component will render a box (1 unit in each dimension)
     * - "capsule": The component will render a capsule (radius 0.5, height 2)
     * - "cone": The component will render a cone (radius 0.5, height 1)
     * - "cylinder": The component will render a cylinder (radius 0.5, height 1)
     * - "plane": The component will render a plane (1 unit in each dimension)
     * - "sphere": The component will render a sphere (radius 0.5)
     * - "torus": The component will render a torus (tubeRadius: 0.2, ringRadius: 0.3)
     *
     * @type {string}
     */
    set type(arg: string);
    get type(): string;
    /**
     * The model that is added to the scene graph. It can be not set or loaded, so will return null.
     *
     * @type {Model}
     */
    set model(arg: Model);
    get model(): Model;
    /**
     * The asset for the model (only applies to models of type 'asset') can also be an asset id.
     *
     * @type {Asset|number|null}
     */
    set asset(arg: number | Asset);
    get asset(): number | Asset;
    /**
     * If true, this model will be lightmapped after using lightmapper.bake().
     *
     * @type {boolean}
     */
    set lightmapped(arg: boolean);
    get lightmapped(): boolean;
    /**
     * A dictionary that holds material overrides for each mesh instance. Only applies to model
     * components of type 'asset'. The mapping contains pairs of mesh instance index - material
     * asset id.
     *
     * @type {Object<string, number>}
     */
    set mapping(arg: {
        [x: string]: number;
    });
    get mapping(): {
        [x: string]: number;
    };
    /**
     * If true, this model will cast shadows for lights that have shadow casting enabled.
     *
     * @type {boolean}
     */
    set castShadows(arg: boolean);
    get castShadows(): boolean;
    /**
     * If true, shadows will be cast on this model.
     *
     * @type {boolean}
     */
    set receiveShadows(arg: boolean);
    get receiveShadows(): boolean;
    /**
     * If true, this model will cast shadows when rendering lightmaps.
     *
     * @type {boolean}
     */
    set castShadowsLightmap(arg: boolean);
    get castShadowsLightmap(): boolean;
    /**
     * Lightmap resolution multiplier.
     *
     * @type {number}
     */
    set lightmapSizeMultiplier(arg: number);
    get lightmapSizeMultiplier(): number;
    /**
     * Mark model as non-movable (optimization).
     *
     * @type {boolean}
     */
    set isStatic(arg: boolean);
    get isStatic(): boolean;
    /**
     * An array of layer IDs ({@link Layer#id}) to which this model should belong. Don't push, pop,
     * splice or modify this array, if you want to change it - set a new one instead.
     *
     * @type {number[]}
     */
    set layers(arg: number[]);
    get layers(): number[];
    /**
     * Assign model to a specific batch group (see {@link BatchGroup}). Default is -1 (no group).
     *
     * @type {number}
     */
    set batchGroupId(arg: number);
    get batchGroupId(): number;
    /**
     * The material {@link Asset} that will be used to render the model (not used on models of type
     * 'asset').
     *
     * @type {Asset|number|null}
     */
    set materialAsset(arg: number | Asset);
    get materialAsset(): number | Asset;
    /**
     * The material {@link Material} that will be used to render the model (not used on models of
     * type 'asset').
     *
     * @type {Material}
     */
    set material(arg: Material);
    get material(): Material;
    addModelToLayers(): void;
    removeModelFromLayers(): void;
    onRemoveChild(): void;
    onInsertChild(): void;
    onRemove(): void;
    /**
     * @param {LayerComposition} oldComp - The old layer composition.
     * @param {LayerComposition} newComp - The new layer composition.
     * @private
     */
    private onLayersChanged;
    /**
     * @param {Layer} layer - The layer that was added.
     * @private
     */
    private onLayerAdded;
    /**
     * @param {Layer} layer - The layer that was removed.
     * @private
     */
    private onLayerRemoved;
    /**
     * @param {number} index - The index of the mesh instance.
     * @param {string} event - The event name.
     * @param {number} id - The asset id.
     * @param {*} handler - The handler function to be bound to the specified event.
     * @private
     */
    private _setMaterialEvent;
    /** @private */
    private _unsetMaterialEvents;
    /**
     * @param {string} idOrPath - The asset id or path.
     * @returns {Asset|null} The asset.
     * @private
     */
    private _getAssetByIdOrPath;
    /**
     * @param {string} path - The path of the model asset.
     * @returns {string|null} The model asset URL or null if the asset is not in the registry.
     * @private
     */
    private _getMaterialAssetUrl;
    /**
     * @param {Asset} materialAsset -The material asset to load.
     * @param {MeshInstance} meshInstance - The mesh instance to assign the material to.
     * @param {number} index - The index of the mesh instance.
     * @private
     */
    private _loadAndSetMeshInstanceMaterial;
    /**
     * Stop rendering model without removing it from the scene hierarchy. This method sets the
     * {@link MeshInstance#visible} property of every MeshInstance in the model to false Note, this
     * does not remove the model or mesh instances from the scene hierarchy or draw call list. So
     * the model component still incurs some CPU overhead.
     *
     * @example
     * this.timer = 0;
     * this.visible = true;
     * // ...
     * // blink model every 0.1 seconds
     * this.timer += dt;
     * if (this.timer > 0.1) {
     *     if (!this.visible) {
     *         this.entity.model.show();
     *         this.visible = true;
     *     } else {
     *         this.entity.model.hide();
     *         this.visible = false;
     *     }
     *     this.timer = 0;
     * }
     */
    hide(): void;
    /**
     * Enable rendering of the model if hidden using {@link ModelComponent#hide}. This method sets
     * all the {@link MeshInstance#visible} property on all mesh instances to true.
     */
    show(): void;
    /**
     * @param {Asset} asset - The material asset to bind events to.
     * @private
     */
    private _bindMaterialAsset;
    /**
     * @param {Asset} asset - The material asset to unbind events from.
     * @private
     */
    private _unbindMaterialAsset;
    /**
     * @param {Asset} asset - The material asset on which an asset add event has been fired.
     * @private
     */
    private _onMaterialAssetAdd;
    /**
     * @param {Asset} asset - The material asset on which an asset load event has been fired.
     * @private
     */
    private _onMaterialAssetLoad;
    /**
     * @param {Asset} asset - The material asset on which an asset unload event has been fired.
     * @private
     */
    private _onMaterialAssetUnload;
    /**
     * @param {Asset} asset - The material asset on which an asset remove event has been fired.
     * @private
     */
    private _onMaterialAssetRemove;
    /**
     * @param {Asset} asset - The material asset on which an asset change event has been fired.
     * @private
     */
    private _onMaterialAssetChange;
    /**
     * @param {Asset} asset - The model asset to bind events to.
     * @private
     */
    private _bindModelAsset;
    /**
     * @param {Asset} asset - The model asset to unbind events from.
     * @private
     */
    private _unbindModelAsset;
    /**
     * @param {Asset} asset - The model asset on which an asset add event has been fired.
     * @private
     */
    private _onModelAssetAdded;
    /**
     * @param {Asset} asset - The model asset on which an asset load event has been fired.
     * @private
     */
    private _onModelAssetLoad;
    /**
     * @param {Asset} asset - The model asset on which an asset unload event has been fired.
     * @private
     */
    private _onModelAssetUnload;
    /**
     * @param {Asset} asset - The model asset on which an asset change event has been fired.
     * @param {string} attr - The attribute that was changed.
     * @param {*} _new - The new value of the attribute.
     * @param {*} _old - The old value of the attribute.
     * @private
     */
    private _onModelAssetChange;
    /**
     * @param {Asset} asset - The model asset on which an asset remove event has been fired.
     * @private
     */
    private _onModelAssetRemove;
    /**
     * @param {Material} material - The material to be set.
     * @private
     */
    private _setMaterial;
}

declare class LayoutGroupComponentData {
    enabled: boolean;
}

/**
 * Manages creation of {@link LayoutGroupComponent}s.
 *
 * @augments ComponentSystem
 */
declare class LayoutGroupComponentSystem extends ComponentSystem {
    id: string;
    ComponentType: typeof LayoutGroupComponent;
    DataType: typeof LayoutGroupComponentData;
    schema: string[];
    _reflowQueue: any[];
    initializeComponentData(component: any, data: any, properties: any): void;
    cloneComponent(entity: any, clone: any): Component;
    scheduleReflow(component: any): void;
    _onPostUpdate(): void;
    _processReflowQueue(): void;
    _onRemoveComponent(entity: any, component: any): void;
}



/**
 * A LayoutGroupComponent enables the Entity to position and scale child {@link ElementComponent}s
 * according to configurable layout rules.
 *
 * @augments Component
 */
declare class LayoutGroupComponent extends Component {
    /**
     * Create a new LayoutGroupComponent instance.
     *
     * @param {LayoutGroupComponentSystem} system - The ComponentSystem that created this
     * Component.
     * @param {Entity} entity - The Entity that this Component is attached to.
     */
    constructor(system: LayoutGroupComponentSystem, entity: Entity);
    /** @private */
    private _orientation;
    /** @private */
    private _reverseX;
    /** @private */
    private _reverseY;
    /** @private */
    private _alignment;
    /** @private */
    private _padding;
    /** @private */
    private _spacing;
    /** @private */
    private _widthFitting;
    /** @private */
    private _heightFitting;
    /** @private */
    private _wrap;
    /** @private */
    private _layoutCalculator;
    /**
     * Whether the layout should run horizontally or vertically. Can be:
     *
     * - {@link ORIENTATION_HORIZONTAL}
     * - {@link ORIENTATION_VERTICAL}
     *
     * Defaults to {@link ORIENTATION_HORIZONTAL}.
     *
     * @type {number}
     */
    set orientation(arg: number);
    get orientation(): number;
    /**
     * Reverses the order of children along the x axis. Defaults to false.
     *
     * @type {boolean}
     */
    set reverseX(arg: boolean);
    get reverseX(): boolean;
    /**
     * Reverses the order of children along the y axis. Defaults to true.
     *
     * @type {boolean}
     */
    set reverseY(arg: boolean);
    get reverseY(): boolean;
    /**
     * Specifies the horizontal and vertical alignment of child elements. Values range from 0 to 1
     * where [0, 0] is the bottom left and [1, 1] is the top right. Defaults to [0, 1].
     *
     * @type {Vec2}
     */
    set alignment(arg: Vec2);
    get alignment(): Vec2;
    /**
     * Padding to be applied inside the container before positioning any children. Specified as
     * left, bottom, right and top values. Defaults to [0, 0, 0, 0] (no padding).
     *
     * @type {Vec4}
     */
    set padding(arg: Vec4);
    get padding(): Vec4;
    /**
     * Spacing to be applied between each child element. Defaults to [0, 0] (no spacing).
     *
     * @type {Vec2}
     */
    set spacing(arg: Vec2);
    get spacing(): Vec2;
    /**
     * Fitting logic to be applied when positioning and scaling child elements. Can be:
     *
     * - {@link FITTING_NONE}: Child elements will be rendered at their natural size.
     * - {@link FITTING_STRETCH}: When the natural size of all child elements does not fill the width
     * of the container, children will be stretched to fit. The rules for how each child will be
     * stretched are outlined below:
     *   1. Sum the {@link LayoutChildComponent#fitWidthProportion} values of each child and normalize
     * so that all values sum to 1.
     *   2. Apply the natural width of each child.
     *   3. If there is space remaining in the container, distribute it to each child based on the
     * normalized {@link LayoutChildComponent#fitWidthProportion} values, but do not exceed the
     * {@link LayoutChildComponent#maxWidth} of each child.
     * - {@link FITTING_SHRINK}: When the natural size of all child elements overflows the width of the
     * container, children will be shrunk to fit. The rules for how each child will be stretched are
     * outlined below:
     *   1. Sum the {@link LayoutChildComponent#fitWidthProportion} values of each child and normalize
     * so that all values sum to 1.
     *   2. Apply the natural width of each child.
     *   3. If the new total width of all children exceeds the available space of the container, reduce
     * each child's width proportionally based on the normalized {@link
     * LayoutChildComponent#fitWidthProportion} values, but do not exceed the {@link
     * LayoutChildComponent#minWidth} of each child.
     * - {@link FITTING_BOTH}: Applies both STRETCH and SHRINK logic as necessary.
     *
     * Defaults to {@link FITTING_NONE}.
     *
     * @type {number}
     */
    set widthFitting(arg: number);
    get widthFitting(): number;
    /**
     * Identical to {@link LayoutGroupComponent#widthFitting} but for the Y axis. Defaults to
     * {@link FITTING_NONE}.
     *
     * @type {number}
     */
    set heightFitting(arg: number);
    get heightFitting(): number;
    /**
     * Whether or not to wrap children onto a new row/column when the size of the container is
     * exceeded. Defaults to false, which means that children will be be rendered in a single row
     * (horizontal orientation) or column (vertical orientation). Note that setting wrap to true
     * makes it impossible for the {@link FITTING_BOTH} fitting mode to operate in any logical
     * manner. For this reason, when wrap is true, a {@link LayoutGroupComponent#widthFitting} or
     * {@link LayoutGroupComponent#heightFitting} mode of {@link FITTING_BOTH} will be coerced to
     * {@link FITTING_STRETCH}.
     *
     * @type {boolean}
     */
    set wrap(arg: boolean);
    get wrap(): boolean;
    _isSelfOrChild(entity: any): boolean;
    _listenForReflowEvents(target: any, onOff: any): void;
    _onElementOrLayoutComponentAdd(entity: any): void;
    _onElementOrLayoutComponentRemove(entity: any): void;
    _onChildInsert(child: any): void;
    _onChildRemove(child: any): void;
    _scheduleReflow(): void;
    reflow(): void;
    _isPerformingReflow: boolean;
    onRemove(): void;
}

declare class LayoutChildComponentData {
    enabled: boolean;
}

/**
 * Manages creation of {@link LayoutChildComponent}s.
 *
 * @augments ComponentSystem
 */
declare class LayoutChildComponentSystem extends ComponentSystem {
    id: string;
    ComponentType: typeof LayoutChildComponent;
    DataType: typeof LayoutChildComponentData;
    schema: string[];
    initializeComponentData(component: any, data: any, properties: any): void;
    cloneComponent(entity: any, clone: any): Component;
}



/** @typedef {import('../../entity.js').Entity} Entity */
/** @typedef {import('./system.js').LayoutChildComponentSystem} LayoutChildComponentSystem */
/**
 * A LayoutChildComponent enables the Entity to control the sizing applied to it by its parent
 * {@link LayoutGroupComponent}.
 *
 * @augments Component
 */
declare class LayoutChildComponent extends Component {
    /**
     * Create a new LayoutChildComponent.
     *
     * @param {LayoutChildComponentSystem} system - The ComponentSystem that created this
     * Component.
     * @param {Entity} entity - The Entity that this Component is attached to.
     */
    constructor(system: LayoutChildComponentSystem, entity: Entity);
    /** @private */
    private _minWidth;
    /** @private */
    private _minHeight;
    /** @private */
    private _maxWidth;
    /** @private */
    private _maxHeight;
    /** @private */
    private _fitWidthProportion;
    /** @private */
    private _fitHeightProportion;
    /** @private */
    private _excludeFromLayout;
    /**
     * The minimum width the element should be rendered at.
     *
     * @type {number}
     */
    set minWidth(arg: number);
    get minWidth(): number;
    /**
     * The minimum height the element should be rendered at.
     *
     * @type {number}
     */
    set minHeight(arg: number);
    get minHeight(): number;
    /**
     * The maximum width the element should be rendered at.
     *
     * @type {number|null}
     */
    set maxWidth(arg: any);
    get maxWidth(): any;
    /**
     * The maximum height the element should be rendered at.
     *
     * @type {number|null}
     */
    set maxHeight(arg: any);
    get maxHeight(): any;
    /**
     * The amount of additional horizontal space that the element should take up, if necessary to
     * satisfy a Stretch/Shrink fitting calculation. This is specified as a proportion, taking into
     * account the proportion values of other siblings.
     *
     * @type {number}
     */
    set fitWidthProportion(arg: number);
    get fitWidthProportion(): number;
    /**
     * The amount of additional vertical space that the element should take up, if necessary to
     * satisfy a Stretch/Shrink fitting calculation. This is specified as a proportion, taking into
     * account the proportion values of other siblings.
     *
     * @type {number}
     */
    set fitHeightProportion(arg: number);
    get fitHeightProportion(): number;
    /**
     * If set to true, the child will be excluded from all layout calculations.
     *
     * @type {boolean}
     */
    set excludeFromLayout(arg: boolean);
    get excludeFromLayout(): boolean;
}

declare class CollisionComponentData {
    enabled: boolean;
    type: string;
    halfExtents: Vec3;
    radius: number;
    axis: number;
    height: number;
    asset: any;
    renderAsset: any;
    shape: any;
    model: any;
    render: any;
    initialized: boolean;
}

/**
 * Manages creation of {@link CollisionComponent}s.
 *
 * @augments ComponentSystem
 */
declare class CollisionComponentSystem extends ComponentSystem {
    id: string;
    ComponentType: typeof CollisionComponent;
    DataType: typeof CollisionComponentData;
    schema: string[];
    implementations: {};
    _triMeshCache: {};
    initializeComponentData(component: any, _data: any, properties: any): void;
    _createImplementation(type: any): any;
    _getImplementation(entity: any): any;
    cloneComponent(entity: any, clone: any): any;
    onBeforeRemove(entity: any, component: any): void;
    onRemove(entity: any, data: any): void;
    updateCompoundChildTransform(entity: any): void;
    _removeCompoundChild(collision: any, shape: any): void;
    onTransformChanged(component: any, position: any, rotation: any, scale: any): void;
    changeType(component: any, previousType: any, newType: any): void;
    recreatePhysicalShapes(component: any): void;
    _calculateNodeRelativeTransform(node: any, relative: any): void;
    _getNodeScaling(node: any): any;
    _getNodeTransform(node: any, relative: any): any;
}





/** @typedef {import('../../../math/vec3.js').Vec3} Vec3 */
/** @typedef {import('../../../scene/model.js').Model} Model */
/** @typedef {import('../../entity.js').Entity} Entity */
/** @typedef {import('./system.js').CollisionComponentSystem} CollisionComponentSystem */
/**
 * A collision volume. Use this in conjunction with a {@link RigidBodyComponent} to make a
 * collision volume that can be simulated using the physics engine.
 *
 * If the {@link Entity} does not have a {@link RigidBodyComponent} then this collision volume will
 * act as a trigger volume. When an entity with a dynamic or kinematic body enters or leaves an
 * entity with a trigger volume, both entities will receive trigger events.
 *
 * The following table shows all the events that can be fired between two Entities:
 *
 * |                                       | Rigid Body (Static)                                                   | Rigid Body (Dynamic or Kinematic)                                     | Trigger Volume                                      |
 * | ------------------------------------- | --------------------------------------------------------------------- | --------------------------------------------------------------------- | --------------------------------------------------- |
 * | **Rigid Body (Static)**               |                                                                       | <ul><li>contact</li><li>collisionstart</li><li>collisionend</li></ul> |                                                     |
 * | **Rigid Body (Dynamic or Kinematic)** | <ul><li>contact</li><li>collisionstart</li><li>collisionend</li></ul> | <ul><li>contact</li><li>collisionstart</li><li>collisionend</li></ul> | <ul><li>triggerenter</li><li>triggerleave</li></ul> |
 * | **Trigger Volume**                    |                                                                       | <ul><li>triggerenter</li><li>triggerleave</li></ul>                   |                                                     |
 *
 * @property {string} type The type of the collision volume. Can be:
 *
 * - "box": A box-shaped collision volume.
 * - "capsule": A capsule-shaped collision volume.
 * - "compound": A compound shape. Any descendant entities with a collision component
 * of type box, capsule, cone, cylinder or sphere will be combined into a single, rigid
 * shape.
 * - "cone": A cone-shaped collision volume.
 * - "cylinder": A cylinder-shaped collision volume.
 * - "mesh": A collision volume that uses a model asset as its shape.
 * - "sphere": A sphere-shaped collision volume.
 *
 * Defaults to "box".
 * @property {Vec3} halfExtents The half-extents of the box-shaped collision volume in the x, y and
 * z axes. Defaults to [0.5, 0.5, 0.5].
 * @property {number} radius The radius of the sphere, capsule, cylinder or cone-shaped collision
 * volumes. Defaults to 0.5.
 * @property {number} axis The local space axis with which the capsule, cylinder or cone-shaped
 * collision volume's length is aligned. 0 for X, 1 for Y and 2 for Z. Defaults to 1 (Y-axis).
 * @property {number} height The total height of the capsule, cylinder or cone-shaped collision
 * volume from tip to tip. Defaults to 2.
 * @property {Asset|number} asset The asset for the model of the mesh collision volume - can also
 * be an asset id. Defaults to null.
 * @property {Asset|number} renderAsset The render asset of the mesh collision volume - can also be
 * an asset id. Defaults to null. If not set then the asset property will be checked instead.
 * @property {Model} model The model that is added to the scene graph for the mesh collision
 * volume.
 * @augments Component
 */
declare class CollisionComponent extends Component {
    /**
     * Create a new CollisionComponent.
     *
     * @param {CollisionComponentSystem} system - The ComponentSystem that created this Component.
     * @param {Entity} entity - The Entity that this Component is attached to.
     */
    constructor(system: CollisionComponentSystem, entity: Entity);

    set axis(arg: number);
    get axis(): number;

    set halfExtents(arg: Vec3);
    get halfExtents(): Vec3;

    set height(arg: number);
    get height(): number;

    set model(arg: Model|null);
    get model(): Model|null;

    set radius(arg: number);
    get radius(): number;

    set type(arg: string);
    get type(): string;

    /** @private */
    private _compoundParent;
    /**
     * The 'contact' event is fired when a contact occurs between two rigid bodies.
     *
     * @event CollisionComponent#contact
     * @param {ContactResult} result - Details of the contact between the two rigid bodies.
     */
    /**
     * Fired when two rigid bodies start touching.
     *
     * @event CollisionComponent#collisionstart
     * @param {ContactResult} result - Details of the contact between the two Entities.
     */
    /**
     * Fired two rigid-bodies stop touching.
     *
     * @event CollisionComponent#collisionend
     * @param {Entity} other - The {@link Entity} that stopped touching this collision volume.
     */
    /**
     * Fired when a rigid body enters a trigger volume.
     *
     * @event CollisionComponent#triggerenter
     * @param {Entity} other - The {@link Entity} that entered this collision volume.
     */
    /**
     * Fired when a rigid body exits a trigger volume.
     *
     * @event CollisionComponent#triggerleave
     * @param {Entity} other - The {@link Entity} that exited this collision volume.
     */
    /**
     * @param {string} name - Property name.
     * @param {*} oldValue - Previous value of the property.
     * @param {*} newValue - New value of the property.
     * @private
     */
    private onSetType;
    /**
     * @param {string} name - Property name.
     * @param {*} oldValue - Previous value of the property.
     * @param {*} newValue - New value of the property.
     * @private
     */
    private onSetHalfExtents;
    /**
     * @param {string} name - Property name.
     * @param {*} oldValue - Previous value of the property.
     * @param {*} newValue - New value of the property.
     * @private
     */
    private onSetRadius;
    /**
     * @param {string} name - Property name.
     * @param {*} oldValue - Previous value of the property.
     * @param {*} newValue - New value of the property.
     * @private
     */
    private onSetHeight;
    /**
     * @param {string} name - Property name.
     * @param {*} oldValue - Previous value of the property.
     * @param {*} newValue - New value of the property.
     * @private
     */
    private onSetAxis;
    /**
     * @param {string} name - Property name.
     * @param {*} oldValue - Previous value of the property.
     * @param {*} newValue - New value of the property.
     * @private
     */
    private onSetAsset;
    /**
     * @param {string} name - Property name.
     * @param {*} oldValue - Previous value of the property.
     * @param {*} newValue - New value of the property.
     * @private
     */
    private onSetRenderAsset;
    /**
     * @param {string} name - Property name.
     * @param {*} oldValue - Previous value of the property.
     * @param {*} newValue - New value of the property.
     * @private
     */
    private onSetModel;
    /**
     * @param {string} name - Property name.
     * @param {*} oldValue - Previous value of the property.
     * @param {*} newValue - New value of the property.
     * @private
     */
    private onSetRender;
    /**
     * @param {Asset} asset - Asset that was removed.
     * @private
     */
    private onAssetRemoved;
    asset: any;
    /**
     * @param {Asset} asset - Asset that was removed.
     * @private
     */
    private onRenderAssetRemoved;
    renderAsset: any;
    /**
     * @param {*} shape - Ammo shape.
     * @returns {number|null} The shape's index in the child array of the compound shape.
     * @private
     */
    private _getCompoundChildShapeIndex;
    /**
     * @param {GraphNode} parent - The parent node.
     * @private
     */
    private _onInsert;
    /** @private */
    private _updateCompound;
    /** @private */
    private onBeforeRemove;
}

declare class ButtonComponentData {
    enabled: boolean;
    active: boolean;
    imageEntity: any;
    hitPadding: Vec4;
    transitionMode: number;
    hoverTint: Color;
    pressedTint: Color;
    inactiveTint: Color;
    fadeDuration: number;
    hoverSpriteAsset: any;
    hoverSpriteFrame: number;
    pressedSpriteAsset: any;
    pressedSpriteFrame: number;
    inactiveSpriteAsset: any;
    inactiveSpriteFrame: number;
}

/**
 * Manages creation of {@link ButtonComponent}s.
 *
 * @augments ComponentSystem
 */
declare class ButtonComponentSystem extends ComponentSystem {
    id: string;
    ComponentType: typeof ButtonComponent;
    DataType: typeof ButtonComponentData;
    schema: (string | {
        name: string;
        type: string;
    })[];
    initializeComponentData(component: any, data: any, properties: any): void;
    onUpdate(dt: any): void;
    _onRemoveComponent(entity: any, component: any): void;
}





/**
 * A ButtonComponent enables a group of entities to behave like a button, with different visual
 * states for hover and press interactions.
 *
 * @property {boolean} active If set to false, the button will be visible but will not respond to hover or touch interactions.
 * @property {Entity} imageEntity A reference to the entity to be used as the button background. The entity must have an ImageElement component.
 * @property {Vec4} hitPadding Padding to be used in hit-test calculations. Can be used to expand the bounding box so that the button is easier to tap.
 * @property {number} transitionMode Controls how the button responds when the user hovers over it/presses it.
 * @property {Color} hoverTint Color to be used on the button image when the user hovers over it.
 * @property {Color} pressedTint Color to be used on the button image when the user presses it.
 * @property {Color} inactiveTint Color to be used on the button image when the button is not interactive.
 * @property {number} fadeDuration Duration to be used when fading between tints, in milliseconds.
 * @property {Asset} hoverSpriteAsset Sprite to be used as the button image when the user hovers over it.
 * @property {number} hoverSpriteFrame Frame to be used from the hover sprite.
 * @property {Asset} pressedSpriteAsset Sprite to be used as the button image when the user presses it.
 * @property {number} pressedSpriteFrame Frame to be used from the pressed sprite.
 * @property {Asset} inactiveSpriteAsset Sprite to be used as the button image when the button is not interactive.
 * @property {number} inactiveSpriteFrame Frame to be used from the inactive sprite.
 * @augments Component
 */
declare class ButtonComponent extends Component {
    /**
     * Create a new ButtonComponent instance.
     *
     * @param {ButtonComponentSystem} system - The ComponentSystem that created this Component.
     * @param {Entity} entity - The Entity that this Component is attached to.
     */
    constructor(system: ButtonComponentSystem, entity: Entity);

    set active(arg: boolean);
    get active(): boolean;

    set fadeDuration(arg: number);
    get fadeDuration(): number;

    set hitPadding(arg: Vec4);
    get hitPadding(): Vec4;

    set hoverSpriteAsset(arg: Asset);
    get hoverSpriteAsset(): Asset;

    set hoverSpriteFrame(arg: number);
    get hoverSpriteFrame(): number;

    set hoverTint(arg: Color);
    get hoverTint(): Color;

    set imageEntity(arg: Entity);
    get imageEntity(): Entity;

    set inactiveSpriteAsset(arg: Asset);
    get inactiveSpriteAsset(): Asset;

    set inactiveSpriteFrame(arg: number);
    get inactiveSpriteFrame(): number;

    set inactiveTint(arg: Color);
    get inactiveTint(): Color;

    set pressedSpriteAsset(arg: Asset);
    get pressedSpriteAsset(): Asset;

    set pressedSpriteFrame(arg: number);
    get pressedSpriteFrame(): number;

    set pressedTint(arg: Color);
    get pressedTint(): Color;

    set transitionMode(arg: number);
    get transitionMode(): number;

    _visualState: string;
    _isHovering: boolean;
    _hoveringCounter: number;
    _isPressed: boolean;
    _defaultTint: Color;
    _defaultSpriteAsset: any;
    _defaultSpriteFrame: number;
    _imageReference: EntityReference;
    _toggleLifecycleListeners(onOrOff: any, system: any): void;
    _onSetActive(name: any, oldValue: any, newValue: any): void;
    _onSetTransitionMode(name: any, oldValue: any, newValue: any): void;
    _onSetTransitionValue(name: any, oldValue: any, newValue: any): void;
    _onElementComponentRemove(entity: any): void;
    _onElementComponentAdd(entity: any): void;
    _onImageElementLose(): void;
    _onImageElementGain(): void;
    _toggleHitElementListeners(onOrOff: any): void;
    _hasHitElementListeners: boolean;
    _storeDefaultVisualState(): void;
    _storeDefaultColor(color: any): void;
    _storeDefaultOpacity(opacity: any): void;
    _storeDefaultSpriteAsset(spriteAsset: any): void;
    _storeDefaultSpriteFrame(spriteFrame: any): void;
    _onSetColor(color: any): void;
    _onSetOpacity(opacity: any): void;
    _onSetSpriteAsset(spriteAsset: any): void;
    _onSetSpriteFrame(spriteFrame: any): void;
    _onMouseEnter(event: any): void;
    _onMouseLeave(event: any): void;
    _onMouseDown(event: any): void;
    _onMouseUp(event: any): void;
    _onTouchStart(event: any): void;
    _onTouchEnd(event: any): void;
    _onTouchLeave(event: any): void;
    _onTouchCancel(event: any): void;
    _onSelectStart(event: any): void;
    _onSelectEnd(event: any): void;
    _onSelectEnter(event: any): void;
    _onSelectLeave(event: any): void;
    _onClick(event: any): void;
    _fireIfActive(name: any, event: any): void;
    _updateVisualState(force: any): void;
    _forceReapplyVisualState(): void;
    _resetToDefaultVisualState(transitionMode: any): void;
    _determineVisualState(): string;
    _applySprite(spriteAsset: any, spriteFrame: any): void;
    _isApplyingSprite: boolean;
    _applyTint(tintColor: any): void;
    _applyTintImmediately(tintColor: any): void;
    _isApplyingTint: boolean;
    _applyTintWithTween(tintColor: any): void;
    _tweenInfo: {
        startTime: any;
        from: Color;
        to: any;
        lerpColor: Color;
    };
    _updateTintTween(): void;
    _cancelTween(): void;
    onUpdate(): void;
    onRemove(): void;
}

declare class AudioListenerComponentData {
    enabled: boolean;
}

/**
 * Component System for adding and removing {@link AudioComponent} objects to Entities.
 *
 * @augments ComponentSystem
 * @ignore
 */
declare class AudioListenerComponentSystem extends ComponentSystem {
    id: string;
    ComponentType: typeof AudioListenerComponent;
    DataType: typeof AudioListenerComponentData;
    schema: string[];
    manager: SoundManager;
    current: any;
    initializeComponentData(component: any, data: any, properties: any): void;
    onUpdate(dt: any): void;
}



/** @typedef {import('../../entity.js').Entity} Entity */
/** @typedef {import('./system.js').AudioListenerComponentSystem} AudioListenerComponentSystem */
/**
 * Represents the audio listener in the 3D world, so that 3D positioned audio sources are heard
 * correctly.
 *
 * @augments Component
 */
declare class AudioListenerComponent extends Component {
    /**
     * Create a new AudioListenerComponent instance.
     *
     * @param {AudioListenerComponentSystem} system - The ComponentSystem that created this Component.
     * @param {Entity} entity - The Entity that this Component is attached to.
     */
    constructor(system: AudioListenerComponentSystem, entity: Entity);
    setCurrentListener(): void;
}

declare class AnimationComponentData {
    enabled: boolean;
}


/**
 * The AnimationComponentSystem manages creating and deleting AnimationComponents.
 *
 * @augments ComponentSystem
 */
declare class AnimationComponentSystem extends ComponentSystem {
    id: string;
    ComponentType: typeof AnimationComponent;
    DataType: typeof AnimationComponentData;
    schema: string[];
    /**
     * Called during {@link ComponentSystem#addComponent} to initialize the component data in the
     * store. This can be overridden by derived Component Systems and either called by the derived
     * System or replaced entirely.
     *
     * @param {AnimationComponent} component - The component being initialized.
     * @param {object} data - The data block used to initialize the component.
     * @param {Array<string | {name: string, type: string}>} properties - The array of property descriptors for the component.
     * A descriptor can be either a plain property name, or an object specifying the name and type.
     * @ignore
     */
    initializeComponentData(component: AnimationComponent, data: object, properties: Array<string | {
        name: string;
        type: string;
    }>): void;
    /**
     * Create a clone of component. This creates a copy of all component data variables.
     *
     * @param {Entity} entity - The entity to clone the component from.
     * @param {Entity} clone - The entity to clone the component into.
     * @returns {AnimationComponent} The newly cloned component.
     * @ignore
     */
    cloneComponent(entity: Entity, clone: Entity): AnimationComponent;
    /**
     * @param {Entity} entity - The entity having its component removed.
     * @param {AnimationComponent} component - The component being removed.
     * @private
     */
    private onBeforeRemove;
    /**
     * @param {number} dt - The time delta since the last frame.
     * @private
     */
    private onUpdate;
}

/**
 * An animation is a sequence of keyframe arrays which map to the nodes of a skeletal hierarchy. It
 * controls how the nodes of the hierarchy are transformed over time.
 */
declare class Animation {
    /**
     * Human-readable name of the animation.
     *
     * @type {string}
     */
    name: string;
    /**
     * Duration of the animation in seconds.
     *
     * @type {number}
     */
    duration: number;
    _nodes: any[];
    _nodeDict: {};
    /**
     * Gets a {@link Node} by name.
     *
     * @param {string} name - The name of the {@link Node}.
     * @returns {Node} The {@link Node} with the specified name.
     */
    getNode(name: string): Node$1;
    /**
     * Adds a node to the internal nodes array.
     *
     * @param {Node} node - The node to add.
     */
    addNode(node: Node$1): void;
    /**
     * A read-only property to get array of animation nodes.
     *
     * @type {Node[]}
     */
    get nodes(): Node$1[];
}
declare class Key {
    constructor(time: any, position: any, rotation: any, scale: any);
    time: any;
    position: any;
    rotation: any;
    scale: any;
}
/**
 * A animation node has a name and contains an array of keyframes.
 */
declare class Node$1 {
    _name: string;
    _keys: any[];
}

/**
 * Wraps a set of data used in animation.
 *
 * @ignore
 */
declare class AnimData {
    /**
     * Create a new animation AnimData instance.
     *
     * @param {number} components - Specifies how many components make up an element of data. For
     * example, specify 3 for a set of 3-dimensional vectors. The number of elements in data array
     * must be a multiple of components.
     * @param {Float32Array|number[]} data - The set of data.
     */
    constructor(components: number, data: Float32Array | number[]);
    _components: number;
    _data: number[] | Float32Array;
    /**
     * Gets the number of components that make up an element.
     *
     * @type {number}
     */
    get components(): number;
    /**
     * Gets the data.
     *
     * @type {Float32Array|number[]}
     */
    get data(): number[] | Float32Array;
}

/**
 * Animation curve links an input data set to an output data set and defines the interpolation
 * method to use.
 *
 * @ignore
 */
declare class AnimCurve {
    /**
     * Create a new animation curve.
     *
     * @param {string[]} paths - Array of path strings identifying the targets of this curve, for
     * example "rootNode.translation".
     * @param {number} input - Index of the curve which specifies the key data.
     * @param {number} output - Index of the curve which specifies the value data.
     * @param {number} interpolation - The interpolation method to use. One of the following:
     *
     * - {@link INTERPOLATION_STEP}
     * - {@link INTERPOLATION_LINEAR}
     * - {@link INTERPOLATION_CUBIC}
     */
    constructor(paths: string[], input: number, output: number, interpolation: number);
    _paths: string[];
    _input: number;
    _output: number;
    _interpolation: number;
    /**
     * The list of paths which identify targets of this curve.
     *
     * @type {string[]}
     */
    get paths(): string[];
    /**
     * The index of the AnimTrack input which contains the key data for this curve.
     *
     * @type {number}
     */
    get input(): number;
    /**
     * The index of the AnimTrack input which contains the key data for this curve.
     *
     * @type {number}
     */
    get output(): number;
    /**
     * The interpolation method used by this curve.
     *
     * @type {number}
     */
    get interpolation(): number;
}

/**
 * AnimEvents stores a sorted array of animation events which should fire sequentially during the
 * playback of an pc.AnimTrack.
 */
declare class AnimEvents {
    /**
     * Create a new AnimEvents instance.
     *
     * @param {object[]} events - An array of animation events.
     * @example
     * const events = new pc.AnimEvents([
     *     {
     *         name: 'my_event',
     *         time: 1.3, // given in seconds
     *         // any additional properties added are optional and will be available in the EventHandler callback's event object
     *         myProperty: 'test',
     *         myOtherProperty: true
     *     }
     * ]);
     * animTrack.events = events;
     */
    constructor(events: object[]);
    _events: any[];
    get events(): any[];
}



/** @typedef {import('./anim-curve.js').AnimCurve} AnimCurve */
/** @typedef {import('./anim-data.js').AnimData} AnimData */
/**
 * An AnimTrack stores the curve data necessary to animate a set of target nodes. It can be linked
 * to the nodes it should animate using the {@link AnimComponent#assignAnimation} method.
 */
declare class AnimTrack {
    /**
     * Create a new AnimTrack instance.
     *
     * @param {string} name - The track name.
     * @param {number} duration - The duration of the track in seconds.
     * @param {AnimData[]} inputs - List of curve key data.
     * @param {AnimData[]} outputs - List of curve value data.
     * @param {AnimCurve[]} curves - The list of curves.
     * @param {AnimEvents} animEvents - A sequence of animation events.
     * @hideconstructor
     */
    constructor(name: string, duration: number, inputs: AnimData[], outputs: AnimData[], curves: AnimCurve[], animEvents?: AnimEvents);
    _name: string;
    _duration: number;
    _inputs: AnimData[];
    _outputs: AnimData[];
    _curves: AnimCurve[];
    _animEvents: AnimEvents;
    /**
     * Gets the name of the AnimTrack.
     *
     * @type {string}
     */
    get name(): string;
    /**
     * Gets the duration of the AnimTrack.
     *
     * @type {number}
     */
    get duration(): number;
    /**
     * Gets the list of curve key data contained in the AnimTrack.
     *
     * @type {AnimData[]}
     */
    get inputs(): AnimData[];
    /**
     * Gets the list of curve values contained in the AnimTrack.
     *
     * @type {AnimData[]}
     */
    get outputs(): AnimData[];
    /**
     * Gets the list of curves contained in the AnimTrack.
     *
     * @type {AnimCurve[]}
     */
    get curves(): AnimCurve[];
    /**
     * The animation events that will fire during the playback of this anim track.
     *
     * @type {AnimEvents}
     */
    set events(arg: any[]);
    get events(): any[];
    eval(time: any, snapshot: any): void;
}

/**
 * Internal cache data for the evaluation of a single curve timeline.
 *
 * @ignore
 */
declare class AnimCache {
    _left: number;
    _right: number;
    _len: number;
    _recip: number;
    _p0: number;
    _p1: number;
    _t: number;
    _hermite: {
        valid: boolean;
        p0: number;
        m0: number;
        p1: number;
        m1: number;
    };
    update(time: any, input: any): void;
    _findKey(time: any, input: any): number;
    eval(result: any, interpolation: any, output: any): void;
}


/** @typedef {import('./anim-track.js').AnimTrack} AnimTrack */
/**
 * AnimSnapshot stores the state of an animation track at a particular time.
 *
 * @ignore
 */
declare class AnimSnapshot {
    /**
     * Create a new animation snapshot.
     *
     * @param {AnimTrack} animTrack - The source track.
     */
    constructor(animTrack: AnimTrack);
    _name: string;
    _time: number;
    _cache: AnimCache[];
    _results: number[][];
}



/** @typedef {import('./anim-track.js').AnimTrack} AnimTrack */
/** @typedef {import('../../core/event-handler.js').EventHandler} EventHandler */
/**
 * AnimClip wraps the running state of an animation track. It contains and update the animation
 * 'cursor' and performs looping logic.
 *
 * @ignore
 */
declare class AnimClip {
    /**
     * Create a new animation clip.
     *
     * @param {AnimTrack} track - The animation data.
     * @param {number} time - The initial time of the clip.
     * @param {number} speed - Speed of the animation playback.
     * @param {boolean} playing - true if the clip is playing and false otherwise.
     * @param {boolean} loop - Whether the clip should loop.
     * @param {EventHandler} [eventHandler] - The handler to call when an event is fired by the clip.
     */
    constructor(track: AnimTrack, time: number, speed: number, playing: boolean, loop: boolean, eventHandler?: EventHandler);
    _name: string;
    _track: AnimTrack;
    _snapshot: AnimSnapshot;
    _playing: boolean;
    _time: number;
    _speed: number;
    _loop: boolean;
    _blendWeight: number;
    _blendOrder: number;
    _eventHandler: EventHandler;
    _eventCursor: number;
    set name(arg: string);
    get name(): string;
    get track(): AnimTrack;
    get snapshot(): AnimSnapshot;
    set time(arg: number);
    get time(): number;
    set speed(arg: number);
    get speed(): number;
    set loop(arg: boolean);
    get loop(): boolean;
    set blendWeight(arg: number);
    get blendWeight(): number;
    set blendOrder(arg: number);
    get blendOrder(): number;
    set eventCursor(arg: number);
    get eventCursor(): number;
    activeEventsForFrame(frameStartTime: any, frameEndTime: any): void;
    _update(deltaTime: any): void;
    play(): void;
    stop(): void;
    pause(): void;
    resume(): void;
    reset(): void;
}

/**
 * Callback function that the {@link AnimEvaluator } uses to set final animation values. These
 * callbacks are stored in {@link AnimTarget } instances which are constructed by an
 * {@link AnimBinder }.
 */
type AnimSetter = (value: number[]) => any;
/**
 * Callback function that the {@link AnimEvaluator} uses to set final animation values. These
 * callbacks are stored in {@link AnimTarget} instances which are constructed by an
 * {@link AnimBinder}.
 *
 * @callback AnimSetter
 * @param {number[]} value - Updated animation value.
 * @ignore
 */
/**
 * Stores the information required by {@link AnimEvaluator} for updating a target value.
 *
 * @ignore
 */
declare class AnimTarget {
    /**
     * Create a new AnimTarget instance.
     *
     * @param {AnimSetter} func - This function will be called when a new animation value is output
     * by the {@link AnimEvaluator}.
     * @param {'vector'|'quaternion'} type - The type of animation data this target expects.
     * @param {number} components - The number of components on this target (this should ideally
     * match the number of components found on all attached animation curves).
     * @param {string} targetPath - The path to the target value.
     */
    constructor(func: AnimSetter, type: 'vector' | 'quaternion', components: number, targetPath: string);
    _set: any;
    _get: any;
    _type: "quaternion" | "vector";
    _components: number;
    _targetPath: string;
    _isTransform: boolean;
    get set(): any;
    get get(): any;
    get type(): "quaternion" | "vector";
    get components(): number;
    get targetPath(): string;
    get isTransform(): boolean;
}


/** @typedef {import('../evaluator/anim-target.js').AnimTarget} AnimTarget */
/**
 * This interface is used by {@link AnimEvaluator} to resolve unique animation target path strings
 * into instances of {@link AnimTarget}.
 *
 * @ignore
 */
declare class AnimBinder {
    static joinPath(pathSegments: any, character: any): any;
    static splitPath(path: any, character: any): string[];
    /**
     * Converts a locator array into its string version.
     *
     * @param {string|string[]} entityPath - The entity location in the scene defined as an array or
     * string path.
     * @param {string} component - The component of the entity the property is located under.
     * @param {string|string[]} propertyPath - The property location in the entity defined as an array
     * or string path.
     * @returns {string} The locator encoded as a string.
     * @example
     * // returns 'spotLight/light/color.r'
     * encode(['spotLight'], 'light', ['color', 'r']);
     */
    static encode(entityPath: string | string[], component: string, propertyPath: string | string[]): string;
    /**
     * Resolve the provided target path and return an instance of {@link AnimTarget} which will
     * handle setting the value, or return null if no such target exists.
     *
     * @param {string} path - The animation curve path to resolve.
     * @returns {AnimTarget|null} - Returns the target instance on success and null otherwise.
     */
    resolve(path: string): AnimTarget | null;
    /**
     * Called when the {@link AnimEvaluator} no longer has a curve driving the given key.
     *
     * @param {string} path - The animation curve path which is no longer driven.
     */
    unresolve(path: string): void;
    /**
     * Called by {@link AnimEvaluator} once a frame after animation updates are done.
     *
     * @param {number} deltaTime - Amount of time that passed in the current update.
     */
    update(deltaTime: number): void;
}



/** @typedef {import('../binder/anim-binder.js').AnimBinder} AnimBinder */
/** @typedef {import('./anim-clip.js').AnimClip} AnimClip */
/**
 * AnimEvaluator blends multiple sets of animation clips together.
 *
 * @ignore
 */
declare class AnimEvaluator {
    static _dot(a: any, b: any): number;
    static _normalize(a: any): void;
    static _set(a: any, b: any, type: any): void;
    static _blendVec(a: any, b: any, t: any, additive: any): void;
    static _blendQuat(a: any, b: any, t: any, additive: any): void;
    static _blend(a: any, b: any, t: any, type: any, additive: any): void;
    static _stableSort(a: any, lessFunc: any): void;
    /**
     * Create a new animation evaluator.
     *
     * @param {AnimBinder} binder - interface resolves curve paths to instances of {@link AnimTarget}.
     */
    constructor(binder: AnimBinder);
    _binder: AnimBinder;
    _clips: any[];
    _inputs: any[];
    _outputs: any[];
    _targets: {};
    /**
     * The list of animation clips.
     *
     * @type {AnimClip[]}
     */
    get clips(): AnimClip[];
    /**
     * Add a clip to the evaluator.
     *
     * @param {AnimClip} clip - The clip to add to the evaluator.
     */
    addClip(clip: AnimClip): void;
    /**
     * Remove a clip from the evaluator.
     *
     * @param {number} index - Index of the clip to remove.
     */
    removeClip(index: number): void;
    /**
     * Remove all clips from the evaluator.
     */
    removeClips(): void;
    /**
     * Returns the first clip which matches the given name, or null if no such clip was found.
     *
     * @param {string} name - Name of the clip to find.
     * @returns {AnimClip|null} - The clip with the given name or null if no such clip was found.
     */
    findClip(name: string): AnimClip | null;
    rebind(): void;
    assignMask(mask: any): any;
    /**
     * Evaluator frame update function. All the attached {@link AnimClip}s are evaluated, blended
     * and the results set on the {@link AnimTarget}.
     *
     * @param {number} deltaTime - The amount of time that has passed since the last update, in
     * seconds.
     */
    update(deltaTime: number): void;
}


/**
 * Represents a skeleton used to play animations.
 */
declare class Skeleton {
    /**
     * Create a new Skeleton instance.
     *
     * @param {GraphNode} graph - The root {@link GraphNode} of the skeleton.
     */
    constructor(graph: GraphNode);
    /**
     * Determines whether skeleton is looping its animation.
     *
     * @type {boolean}
     */
    looping: boolean;
    /**
     * @type {Animation}
     * @private
     */
    private _animation;
    _time: number;
    _interpolatedKeys: any[];
    _interpolatedKeyDict: {};
    _currKeyIndices: {};
    graph: GraphNode;
    /**
     * Animation currently assigned to skeleton.
     *
     * @type {Animation}
     */
    set animation(arg: Animation);
    get animation(): Animation;
    /**
     * Current time of currently active animation in seconds. This value is between zero and the
     * duration of the animation.
     *
     * @type {number}
     */
    set currentTime(arg: number);
    get currentTime(): number;
    /**
     * Read-only property that returns number of nodes of a skeleton.
     *
     * @type {number}
     */
    get numNodes(): number;
    /**
     * Progresses the animation assigned to the specified skeleton by the supplied time delta. If
     * the delta takes the animation passed its end point, if the skeleton is set to loop, the
     * animation will continue from the beginning. Otherwise, the animation's current time will
     * remain at its duration (i.e. the end).
     *
     * @param {number} delta - The time in seconds to progress the skeleton's animation.
     */
    addTime(delta: number): void;
    /**
     * Blends two skeletons together.
     *
     * @param {Skeleton} skel1 - Skeleton holding the first pose to be blended.
     * @param {Skeleton} skel2 - Skeleton holding the second pose to be blended.
     * @param {number} alpha - The value controlling the interpolation in relation to the two input
     * skeletons. The value is in the range 0 to 1, 0 generating skel1, 1 generating skel2 and
     * anything in between generating a spherical interpolation between the two.
     */
    blend(skel1: Skeleton, skel2: Skeleton, alpha: number): void;
    /**
     * Links a skeleton to a node hierarchy. The nodes animated skeleton are then subsequently used
     * to drive the local transformation matrices of the node hierarchy.
     *
     * @param {GraphNode} graph - The root node of the graph that the skeleton is to drive.
     */
    setGraph(graph: GraphNode): void;
    /**
     * Synchronizes the currently linked node hierarchy with the current state of the skeleton.
     * Internally, this function converts the interpolated keyframe at each node in the skeleton
     * into the local transformation matrix at each corresponding node in the linked node
     * hierarchy.
     */
    updateGraph(): void;
}





/** @typedef {import('../../../animation/animation.js').Animation} Animation */
/** @typedef {import('../../../scene/model.js').Model} Model */
/** @typedef {import('../../entity.js').Entity} Entity */
/** @typedef {import('./system.js').AnimationComponentSystem} AnimationComponentSystem */
/**
 * The Animation Component allows an Entity to playback animations on models.
 *
 * @augments Component
 */
declare class AnimationComponent extends Component {
    /**
     * Create a new AnimationComponent instance.
     *
     * @param {AnimationComponentSystem} system - The {@link ComponentSystem} that created this Component.
     * @param {Entity} entity - The Entity that this Component is attached to.
     */
    constructor(system: AnimationComponentSystem, entity: Entity);
    /**
     * @type {Object<string, Animation>}
     * @private
     */
    private _animations;
    /**
     * @type {Array.<number|Asset>}
     * @private
     */
    private _assets;
    /** @private */
    private _loop;
    /**
     * @type {AnimEvaluator|null}
     * @ignore
     */
    animEvaluator: AnimEvaluator | null;
    /**
     * @type {Model|null}
     * @ignore
     */
    model: Model | null;
    /**
     * Get the skeleton for the current model. If the model is loaded from glTF/glb, then the
     * skeleton is null.
     *
     * @type {Skeleton|null}
     */
    skeleton: Skeleton | null;
    /**
     * @type {Skeleton|null}
     * @ignore
     */
    fromSkel: Skeleton | null;
    /**
     * @type {Skeleton|null}
     * @ignore
     */
    toSkel: Skeleton | null;
    /**
     * @type {Object<string, string>}
     * @ignore
     */
    animationsIndex: {
        [x: string]: string;
    };
    /**
     * @type {string|null}
     * @private
     */
    private prevAnim;
    /**
     * @type {string|null}
     * @private
     */
    private currAnim;
    /** @private */
    private blend;
    /** @private */
    private blending;
    /** @private */
    private blendSpeed;
    /**
     * If true the first animation asset will begin playing when the scene is loaded.
     *
     * @type {boolean}
     */
    activate: boolean;
    /**
     * Speed multiplier for animation play back. 1 is playback at normal speed and 0 pauses the
     * animation.
     *
     * @type {number}
     */
    speed: number;
    /**
     * Get or set dictionary of animations by name.
     *
     * @type {Object<string, Animation>}
     */
    set animations(arg: {
        [x: string]: Animation;
    });
    get animations(): {
        [x: string]: Animation;
    };
    /**
     * The array of animation assets. Can also be an array of asset ids.
     *
     * @type {Array.<number|Asset>}
     */
    set assets(arg: (number | Asset)[]);
    get assets(): (number | Asset)[];
    /**
     * Get or set the current time position (in seconds) of the animation.
     *
     * @type {number}
     */
    set currentTime(arg: number);
    get currentTime(): number;
    /**
     * Get the duration in seconds of the current animation.
     *
     * @type {number}
     */
    get duration(): number;
    /**
     * If true the animation will restart from the beginning when it reaches the end.
     *
     * @type {boolean}
     */
    set loop(arg: boolean);
    get loop(): boolean;
    /**
     * Start playing an animation.
     *
     * @param {string} name - The name of the animation asset to begin playing.
     * @param {number} [blendTime] - The time in seconds to blend from the current
     * animation state to the start of the animation being set. Defaults to 0.
     */
    play(name: string, blendTime?: number): void;
    playing: boolean;
    /**
     * Return an animation.
     *
     * @param {string} name - The name of the animation asset.
     * @returns {Animation} An Animation.
     */
    getAnimation(name: string): Animation;
    /**
     * Set the model driven by this animation component.
     *
     * @param {Model} model - The model to set.
     * @ignore
     */
    setModel(model: Model): void;
    onSetAnimations(): void;
    /** @private */
    private _resetAnimationController;
    /** @private */
    private _createAnimationController;
    /**
     * @param {number[]} ids - Array of animation asset ids.
     * @private
     */
    private loadAnimationAssets;
    /**
     * Handle asset change events.
     *
     * @param {Asset} asset - The asset that changed.
     * @param {string} attribute - The name of the asset attribute that changed. Can be 'data',
     * 'file', 'resource' or 'resources'.
     * @param {*} newValue - The new value of the specified asset property.
     * @param {*} oldValue - The old value of the specified asset property.
     * @private
     */
    private onAssetChanged;
    /**
     * @param {Asset} asset - The asset that was removed.
     * @private
     */
    private onAssetRemoved;
    /** @private */
    private _stopCurrentAnimation;
    onBeforeRemove(): void;
    /**
     * Update the state of the component.
     *
     * @param {number} dt - The time delta.
     * @ignore
     */
    update(dt: number): void;
}

declare class AnimComponentData {
    enabled: boolean;
}

/**
 * The AnimComponentSystem manages creating and deleting AnimComponents.
 *
 * @augments ComponentSystem
 */
declare class AnimComponentSystem extends ComponentSystem {
    id: string;
    ComponentType: typeof AnimComponent;
    DataType: typeof AnimComponentData;
    schema: string[];
    initializeComponentData(component: any, data: any, properties: any): void;
    onAnimationUpdate(dt: any): void;
    cloneComponent(entity: any, clone: any): Component;
    onBeforeRemove(entity: any, component: any): void;
}



/** @typedef {import('./component.js').AnimComponent} AnimComponent */
/** @typedef {import('../../../asset/asset.js').Asset} Asset */
/**
 * The Anim Component Layer allows managers a single layer of the animation state graph.
 */
declare class AnimComponentLayer {
    /**
     * Create a new AnimComponentLayer instance.
     *
     * @param {string} name - The name of the layer.
     * @param {object} controller - The controller to manage this layers animations.
     * @param {AnimComponent} component - The component that this layer is a member of.
     * @param {number} [weight] - The weight of this layer. Defaults to 1.
     * @param {string} [blendType] - The blend type of this layer. Defaults to {@link ANIM_LAYER_OVERWRITE}.
     * @param {boolean} [normalizedWeight] - Whether the weight of this layer should be normalized using the total weight of all layers.
     */
    constructor(name: string, controller: object, component: AnimComponent, weight?: number, blendType?: string, normalizedWeight?: boolean);
    _name: string;
    _controller: any;
    _component: AnimComponent;
    _weight: number;
    _blendType: string;
    _normalizedWeight: boolean;
    _mask: any;
    _blendTime: number;
    _blendTimeElapsed: number;
    _startingWeight: number;
    _targetWeight: number;
    /**
     * Returns the name of the layer.
     *
     * @type {string}
     */
    get name(): string;
    /**
     * Whether this layer is currently playing.
     *
     * @type {string}
     */
    set playing(arg: any);
    get playing(): any;
    /**
     * Returns true if a state graph has been loaded and all states in the graph have been assigned
     * animation tracks.
     *
     * @type {string}
     */
    get playable(): string;
    /**
     * Returns the currently active state name.
     *
     * @type {string}
     */
    get activeState(): string;
    /**
     * Returns the previously active state name.
     *
     * @type {string}
     */
    get previousState(): string;
    /**
     * Returns the currently active states progress as a value normalized by the states animation
     * duration. Looped animations will return values greater than 1.
     *
     * @type {number}
     */
    get activeStateProgress(): number;
    /**
     * Returns the currently active states duration.
     *
     * @type {number}
     */
    get activeStateDuration(): number;
    /**
     * The active states time in seconds.
     *
     * @type {number}
     */
    set activeStateCurrentTime(arg: any);
    get activeStateCurrentTime(): any;
    /**
     * Returns whether the anim component layer is currently transitioning between states.
     *
     * @type {boolean}
     */
    get transitioning(): boolean;
    /**
     * If the anim component layer is currently transitioning between states, returns the progress.
     * Otherwise returns null.
     *
     * @type {number|null}
     */
    get transitionProgress(): number;
    /**
     * Lists all available states in this layers state graph.
     *
     * @type {string[]}
     */
    get states(): string[];
    /**
     * The blending weight of this layer. Used when calculating the value of properties that are
     * animated by more than one layer.
     *
     * @type {number}
     */
    set weight(arg: number);
    get weight(): number;
    set blendType(arg: string);
    get blendType(): string;
    /**
     * A mask of bones which should be animated or ignored by this layer.
     *
     * @type {object}
     * @example
     * entity.anim.baseLayer.mask = {
     *     // include the spine of the current model and all of its children
     *     "path/to/spine": {
     *         children: true
     *     },
     *     // include the hip of the current model but not all of its children
     *     "path/to/hip": true
     * };
     */
    set mask(arg: any);
    get mask(): any;
    /**
     * Start playing the animation in the current state.
     *
     * @param {string} [name] - If provided, will begin playing from the start of the state with
     * this name.
     */
    play(name?: string): void;
    /**
     * Pause the animation in the current state.
     */
    pause(): void;
    /**
     * Reset the animation component to its initial state, including all parameters. The system
     * will be paused.
     */
    reset(): void;
    /**
     * Rebind any animations in the layer to the currently present components and model of the anim
     * components entity.
     */
    rebind(): void;
    update(dt: any): void;
    /**
     * Blend from the current weight value to the provided weight value over a given amount of time.
     *
     * @param {number} weight - The new weight value to blend to.
     * @param {number} time - The duration of the blend in seconds.
     */
    blendToWeight(weight: number, time: number): void;
    /**
     * Add a mask to this layer.
     *
     * @param {object} [mask] - The mask to assign to the layer. If not provided the current mask
     * in the layer will be removed.
     * @example
     * entity.anim.baseLayer.assignMask({
     *     // include the spine of the current model and all of its children
     *     "path/to/spine": {
     *         children: true
     *     },
     *     // include the hip of the current model but not all of its children
     *     "path/to/hip": true
     * });
     * @ignore
     */
    assignMask(mask?: object): void;
    /**
     * Assigns an animation track to a state or blend tree node in the current graph. If a state
     * for the given nodePath doesn't exist, it will be created. If all states nodes are linked and
     * the {@link AnimComponent#activate} value was set to true then the component will begin
     * playing.
     *
     * @param {string} nodePath - Either the state name or the path to a blend tree node that this
     * animation should be associated with. Each section of a blend tree path is split using a
     * period (`.`) therefore state names should not include this character (e.g "MyStateName" or
     * "MyStateName.BlendTreeNode").
     * @param {object} animTrack - The animation track that will be assigned to this state and
     * played whenever this state is active.
     * @param {number} [speed] - Update the speed of the state you are assigning an animation to.
     * Defaults to 1.
     * @param {boolean} [loop] - Update the loop property of the state you are assigning an
     * animation to. Defaults to true.
     */
    assignAnimation(nodePath: string, animTrack: object, speed?: number, loop?: boolean): void;
    /**
     * Removes animations from a node in the loaded state graph.
     *
     * @param {string} nodeName - The name of the node that should have its animation tracks removed.
     */
    removeNodeAnimations(nodeName: string): void;
    /**
     * Returns the asset that is associated with the given state.
     *
     * @param {string} stateName - The name of the state to get the asset for.
     * @returns {Asset} The asset associated with the given state.
     */
    getAnimationAsset(stateName: string): Asset;
    /**
     * Transition to any state in the current layers graph. Transitions can be instant or take an
     * optional blend time.
     *
     * @param {string} to - The state that this transition will transition to.
     * @param {number} [time] - The duration of the transition in seconds. Defaults to 0.
     * @param {number} [transitionOffset] - If provided, the destination state will begin playing
     * its animation at this time. Given in normalized time, based on the states duration & must be
     * between 0 and 1. Defaults to null.
     */
    transition(to: string, time?: number, transitionOffset?: number): void;
}


/** @typedef {import('./system.js').AnimComponentSystem} AnimComponentSystem */
/**
 * The Anim Component allows an Entity to playback animations on models and entity properties.
 *
 * @augments Component
 */
declare class AnimComponent extends Component {
    /**
     * Create a new AnimComponent instance.
     *
     * @param {AnimComponentSystem} system - The {@link ComponentSystem} that created this
     * Component.
     * @param {Entity} entity - The Entity that this Component is attached to.
     */
    constructor(system: AnimComponentSystem, entity: Entity);
    _stateGraphAsset: any;
    _animationAssets: {};
    _speed: number;
    _activate: boolean;
    _playing: boolean;
    _rootBone: any;
    _stateGraph: any;
    _layers: any[];
    _layerIndices: {};
    _parameters: {};
    _targets: {};
    _consumedTriggers: Set<any>;
    _normalizeWeights: boolean;
    set stateGraphAsset(arg: any);
    get stateGraphAsset(): any;
    /**
     * If true the animation component will normalize the weights of its layers by their sum total.
     *
     * @type {boolean}
     */
    set normalizeWeights(arg: boolean);
    get normalizeWeights(): boolean;
    set animationAssets(arg: {});
    get animationAssets(): {};
    /**
     * Speed multiplier for animation play back speed. 1.0 is playback at normal speed, 0.0 pauses
     * the animation.
     *
     * @type {number}
     */
    set speed(arg: number);
    get speed(): number;
    /**
     * If true the first animation will begin playing when the scene is loaded.
     *
     * @type {boolean}
     */
    set activate(arg: boolean);
    get activate(): boolean;
    /**
     * Plays or pauses all animations in the component.
     *
     * @type {boolean}
     */
    set playing(arg: boolean);
    get playing(): boolean;
    /**
     * The entity that this anim component should use as the root of the animation hierarchy.
     *
     * @type {Entity}
     */
    set rootBone(arg: any);
    get rootBone(): any;
    set stateGraph(arg: any);
    get stateGraph(): any;
    /**
     * Returns the animation layers available in this anim component.
     *
     * @type {AnimComponentLayer[]}
     */
    get layers(): AnimComponentLayer[];
    set layerIndices(arg: {});
    get layerIndices(): {};
    set parameters(arg: {});
    get parameters(): {};
    set targets(arg: {});
    get targets(): {};
    /**
     * Returns whether all component layers are currently playable.
     *
     * @type {boolean}
     */
    get playable(): boolean;
    /**
     * Returns the base layer of the state graph.
     *
     * @type {AnimComponentLayer|null}
     */
    get baseLayer(): AnimComponentLayer;
    _onStateGraphAssetChangeEvent(asset: any): void;
    dirtifyTargets(): void;
    _addLayer({ name, states, transitions, weight, mask, blendType }: {
        name: any;
        states: any;
        transitions: any;
        weight: any;
        mask: any;
        blendType: any;
    }): any;
    /**
     * Adds a new anim component layer to the anim component.
     *
     * @param {string} name - The name of the layer to create.
     * @param {number} [weight] - The blending weight of the layer. Defaults to 1.
     * @param {object[]} [mask] - A list of paths to bones in the model which should be animated in
     * this layer. If omitted the full model is used. Defaults to null.
     * @param {string} [blendType] - Defines how properties animated by this layer blend with
     * animations of those properties in previous layers. Defaults to pc.ANIM_LAYER_OVERWRITE.
     * @returns {AnimComponentLayer} The created anim component layer.
     */
    addLayer(name: string, weight?: number, mask?: object[], blendType?: string): AnimComponentLayer;
    /**
     * Initializes component animation controllers using the provided state graph.
     *
     * @param {object} stateGraph - The state graph asset to load into the component. Contains the
     * states, transitions and parameters used to define a complete animation controller.
     * @example
     * entity.anim.loadStateGraph({
     *     "layers": [
     *         {
     *             "name": layerName,
     *             "states": [
     *                 {
     *                     "name": "START",
     *                     "speed": 1
     *                 },
     *                 {
     *                     "name": "Initial State",
     *                     "speed": speed,
     *                     "loop": loop,
     *                     "defaultState": true
     *                 }
     *             ],
     *             "transitions": [
     *                 {
     *                     "from": "START",
     *                     "to": "Initial State"
     *                 }
     *             ]
     *         }
     *     ],
     *     "parameters": {}
     * });
     */
    loadStateGraph(stateGraph: object): void;
    setupAnimationAssets(): void;
    loadAnimationAssets(): void;
    onAnimationAssetLoaded(layerName: any, stateName: any, asset: any): void;
    /**
     * Removes all layers from the anim component.
     */
    removeStateGraph(): void;
    /**
     * Reset all of the components layers and parameters to their initial states. If a layer was
     * playing before it will continue playing.
     */
    reset(): void;
    unbind(): void;
    /**
     * Rebind all of the components layers.
     */
    rebind(): void;
    /**
     * Finds a {@link AnimComponentLayer} in this component.
     *
     * @param {string} name - The name of the anim component layer to find.
     * @returns {AnimComponentLayer} Layer.
     */
    findAnimationLayer(name: string): AnimComponentLayer;
    addAnimationState(nodeName: any, animTrack: any, speed?: number, loop?: boolean, layerName?: string): void;
    /**
     * Associates an animation with a state or blend tree node in the loaded state graph. If all
     * states are linked and the {@link AnimComponent#activate} value was set to true then the
     * component will begin playing. If no state graph is loaded, a default state graph will be
     * created with a single state based on the provided nodePath parameter.
     *
     * @param {string} nodePath - Either the state name or the path to a blend tree node that this
     * animation should be associated with. Each section of a blend tree path is split using a
     * period (`.`) therefore state names should not include this character (e.g "MyStateName" or
     * "MyStateName.BlendTreeNode").
     * @param {object} animTrack - The animation track that will be assigned to this state and
     * played whenever this state is active.
     * @param {string} [layerName] - The name of the anim component layer to update. If omitted the
     * default layer is used. If no state graph has been previously loaded this parameter is
     * ignored.
     * @param {number} [speed] - Update the speed of the state you are assigning an animation to.
     * Defaults to 1.
     * @param {boolean} [loop] - Update the loop property of the state you are assigning an
     * animation to. Defaults to true.
     */
    assignAnimation(nodePath: string, animTrack: object, layerName?: string, speed?: number, loop?: boolean): void;
    /**
     * Removes animations from a node in the loaded state graph.
     *
     * @param {string} nodeName - The name of the node that should have its animation tracks removed.
     * @param {string} [layerName] - The name of the anim component layer to update. If omitted the
     * default layer is used.
     */
    removeNodeAnimations(nodeName: string, layerName?: string): void;
    getParameterValue(name: any, type: any): any;
    setParameterValue(name: any, type: any, value: any): void;
    /**
     * Returns a float parameter value by name.
     *
     * @param {string} name - The name of the float to return the value of.
     * @returns {number} A float.
     */
    getFloat(name: string): number;
    /**
     * Sets the value of a float parameter that was defined in the animation components state graph.
     *
     * @param {string} name - The name of the parameter to set.
     * @param {number} value - The new float value to set this parameter to.
     */
    setFloat(name: string, value: number): void;
    /**
     * Returns an integer parameter value by name.
     *
     * @param {string} name - The name of the integer to return the value of.
     * @returns {number} An integer.
     */
    getInteger(name: string): number;
    /**
     * Sets the value of an integer parameter that was defined in the animation components state
     * graph.
     *
     * @param {string} name - The name of the parameter to set.
     * @param {number} value - The new integer value to set this parameter to.
     */
    setInteger(name: string, value: number): void;
    /**
     * Returns a boolean parameter value by name.
     *
     * @param {string} name - The name of the boolean to return the value of.
     * @returns {boolean} A boolean.
     */
    getBoolean(name: string): boolean;
    /**
     * Sets the value of a boolean parameter that was defined in the animation components state
     * graph.
     *
     * @param {string} name - The name of the parameter to set.
     * @param {boolean} value - The new boolean value to set this parameter to.
     */
    setBoolean(name: string, value: boolean): void;
    /**
     * Returns a trigger parameter value by name.
     *
     * @param {string} name - The name of the trigger to return the value of.
     * @returns {boolean} A boolean.
     */
    getTrigger(name: string): boolean;
    /**
     * Sets the value of a trigger parameter that was defined in the animation components state
     * graph to true.
     *
     * @param {string} name - The name of the parameter to set.
     * @param {boolean} [singleFrame] - If true, this trigger will be set back to false at the end
     * of the animation update. Defaults to false.
     */
    setTrigger(name: string, singleFrame?: boolean): void;
    /**
     * Resets the value of a trigger parameter that was defined in the animation components state
     * graph to false.
     *
     * @param {string} name - The name of the parameter to set.
     */
    resetTrigger(name: string): void;
    onBeforeRemove(): void;
    update(dt: any): void;
    resolveDuplicatedEntityReferenceProperties(oldAnim: any, duplicatedIdsMap: any): void;
}






















/**
 * The Entity is the core primitive of a PlayCanvas game. Generally speaking an object in your game
 * will consist of an {@link Entity}, and a set of {@link Component}s which are managed by their
 * respective {@link ComponentSystem}s. One of those components maybe a {@link ScriptComponent}
 * which allows you to write custom code to attach to your Entity.
 *
 * The Entity uniquely identifies the object and also provides a transform for position and
 * orientation which it inherits from {@link GraphNode} so can be added into the scene graph. The
 * Component and ComponentSystem provide the logic to give an Entity a specific type of behavior.
 * e.g. the ability to render a model or play a sound. Components are specific to an instance of an
 * Entity and are attached (e.g. `this.entity.model`) ComponentSystems allow access to all Entities
 * and Components and are attached to the {@link AppBase}.
 *
 * @augments GraphNode
 */
declare class Entity extends GraphNode {
    /**
     * Create a new Entity.
     *
     * @param {string} [name] - The non-unique name of the entity, default is "Untitled".
     * @param {AppBase} [app] - The application the entity belongs to, default is the current application.
     * @example
     * var entity = new pc.Entity();
     *
     * // Add a Component to the Entity
     * entity.addComponent("camera", {
     *     fov: 45,
     *     nearClip: 1,
     *     farClip: 10000
     * });
     *
     * // Add the Entity into the scene graph
     * app.root.addChild(entity);
     *
     * // Move the entity
     * entity.translate(10, 0, 0);
     *
     * // Or translate it by setting its position directly
     * var p = entity.getPosition();
     * entity.setPosition(p.x + 10, p.y, p.z);
     *
     * // Change the entity's rotation in local space
     * var e = entity.getLocalEulerAngles();
     * entity.setLocalEulerAngles(e.x, e.y + 90, e.z);
     *
     * // Or use rotateLocal
     * entity.rotateLocal(0, 90, 0);
     */
    constructor(name?: string, app?: AppBase);
    /**
     * Gets the {@link AnimComponent} attached to this entity.
     *
     * @type {AnimComponent|undefined}
     * @readonly
     */
    readonly anim: AnimComponent | undefined;
    /**
     * Gets the {@link AnimationComponent} attached to this entity.
     *
     * @type {AnimationComponent|undefined}
     * @readonly
     */
    readonly animation: AnimationComponent | undefined;
    /**
     * Gets the {@link AudioListenerComponent} attached to this entity.
     *
     * @type {AudioListenerComponent|undefined}
     * @readonly
     */
    readonly audiolistener: AudioListenerComponent | undefined;
    /**
     * Gets the {@link ButtonComponent} attached to this entity.
     *
     * @type {ButtonComponent|undefined}
     * @readonly
     */
    readonly button: ButtonComponent | undefined;
    /**
     * Gets the {@link CameraComponent} attached to this entity.
     *
     * @type {CameraComponent|undefined}
     * @readonly
     */
    readonly camera: CameraComponent | undefined;
    /**
     * Gets the {@link CollisionComponent} attached to this entity.
     *
     * @type {CollisionComponent|undefined}
     * @readonly
     */
    readonly collision: CollisionComponent | undefined;
    /**
     * Gets the {@link ElementComponent} attached to this entity.
     *
     * @type {ElementComponent|undefined}
     * @readonly
     */
    readonly element: ElementComponent | undefined;
    /**
     * Gets the {@link LayoutChildComponent} attached to this entity.
     *
     * @type {LayoutChildComponent|undefined}
     * @readonly
     */
    readonly layoutchild: LayoutChildComponent | undefined;
    /**
     * Gets the {@link LayoutGroupComponent} attached to this entity.
     *
     * @type {LayoutGroupComponent|undefined}
     * @readonly
     */
    readonly layoutgroup: LayoutGroupComponent | undefined;
    /**
     * Gets the {@link LightComponent} attached to this entity.
     *
     * @type {LightComponent|undefined}
     * @readonly
     */
    readonly light: LightComponent | undefined;
    /**
     * Gets the {@link ModelComponent} attached to this entity.
     *
     * @type {ModelComponent|undefined}
     * @readonly
     */
    readonly model: ModelComponent | undefined;
    /**
     * Gets the {@link ParticleSystemComponent} attached to this entity.
     *
     * @type {ParticleSystemComponent|undefined}
     * @readonly
     */
    readonly particlesystem: ParticleSystemComponent | undefined;
    /**
     * Gets the {@link RenderComponent} attached to this entity.
     *
     * @type {RenderComponent|undefined}
     * @readonly
     */
    readonly render: RenderComponent | undefined;
    /**
     * Gets the {@link RigidBodyComponent} attached to this entity.
     *
     * @type {RigidBodyComponent|undefined}
     * @readonly
     */
    readonly rigidbody: RigidBodyComponent | undefined;
    /**
     * Gets the {@link ScreenComponent} attached to this entity.
     *
     * @type {ScreenComponent|undefined}
     * @readonly
     */
    readonly screen: ScreenComponent | undefined;
    /**
     * Gets the {@link ScriptComponent} attached to this entity.
     *
     * @type {ScriptComponent|undefined}
     * @readonly
     */
    readonly script: ScriptComponent | undefined;
    /**
     * Gets the {@link ScrollbarComponent} attached to this entity.
     *
     * @type {ScrollbarComponent|undefined}
     * @readonly
     */
    readonly scrollbar: ScrollbarComponent | undefined;
    /**
     * Gets the {@link ScrollViewComponent} attached to this entity.
     *
     * @type {ScrollViewComponent|undefined}
     * @readonly
     */
    readonly scrollview: ScrollViewComponent | undefined;
    /**
     * Gets the {@link SoundComponent} attached to this entity.
     *
     * @type {SoundComponent|undefined}
     * @readonly
     */
    readonly sound: SoundComponent | undefined;
    /**
     * Gets the {@link SpriteComponent} attached to this entity.
     *
     * @type {SpriteComponent|undefined}
     * @readonly
     */
    readonly sprite: SpriteComponent | undefined;
    /**
     * Component storage.
     *
     * @type {Object<string, Component>}
     * @ignore
     */
    c: {
        [x: string]: Component;
    };
    /**
     * @type {AppBase}
     * @private
     */
    private _app;
    /**
     * Used by component systems to speed up destruction.
     *
     * @type {boolean}
     * @ignore
     */
    _destroying: boolean;
    /**
     * @type {string|null}
     * @private
     */
    private _guid;
    /**
     * Used to differentiate between the entities of a template root instance, which have it set to
     * true, and the cloned instance entities (set to false).
     *
     * @type {boolean}
     * @ignore
     */
    _template: boolean;
    /**
     * Create a new component and add it to the entity. Use this to add functionality to the entity
     * like rendering a model, playing sounds and so on.
     *
     * @param {string} type - The name of the component to add. Valid strings are:
     *
     * - "anim" - see {@link AnimComponent}
     * - "animation" - see {@link AnimationComponent}
     * - "audiolistener" - see {@link AudioListenerComponent}
     * - "button" - see {@link ButtonComponent}
     * - "camera" - see {@link CameraComponent}
     * - "collision" - see {@link CollisionComponent}
     * - "element" - see {@link ElementComponent}
     * - "layoutchild" - see {@link LayoutChildComponent}
     * - "layoutgroup" - see {@link LayoutGroupComponent}
     * - "light" - see {@link LightComponent}
     * - "model" - see {@link ModelComponent}
     * - "particlesystem" - see {@link ParticleSystemComponent}
     * - "render" - see {@link RenderComponent}
     * - "rigidbody" - see {@link RigidBodyComponent}
     * - "screen" - see {@link ScreenComponent}
     * - "script" - see {@link ScriptComponent}
     * - "scrollbar" - see {@link ScrollbarComponent}
     * - "scrollview" - see {@link ScrollViewComponent}
     * - "sound" - see {@link SoundComponent}
     * - "sprite" - see {@link SpriteComponent}
     *
     * @param {object} [data] - The initialization data for the specific component type. Refer to
     * each specific component's API reference page for details on valid values for this parameter.
     * @returns {Component|null} The new Component that was attached to the entity or null if there
     * was an error.
     * @example
     * var entity = new pc.Entity();
     *
     * // Add a light component with default properties
     * entity.addComponent("light");
     *
     * // Add a camera component with some specified properties
     * entity.addComponent("camera", {
     *     fov: 45,
     *     clearColor: new pc.Color(1, 0, 0)
     * });
     */
    addComponent(type: string, data?: object): Component | null;
    /**
     * Remove a component from the Entity.
     *
     * @param {string} type - The name of the Component type.
     * @example
     * var entity = new pc.Entity();
     * entity.addComponent("light"); // add new light component
     *
     * entity.removeComponent("light"); // remove light component
     */
    removeComponent(type: string): void;
    /**
     * Search the entity and all of its descendants for the first component of specified type.
     *
     * @param {string} type - The name of the component type to retrieve.
     * @returns {Component} A component of specified type, if the entity or any of its descendants
     * has one. Returns undefined otherwise.
     * @example
     * // Get the first found light component in the hierarchy tree that starts with this entity
     * var light = entity.findComponent("light");
     */
    findComponent(type: string): Component;
    /**
     * Search the entity and all of its descendants for all components of specified type.
     *
     * @param {string} type - The name of the component type to retrieve.
     * @returns {Component[]} All components of specified type in the entity or any of its
     * descendants. Returns empty array if none found.
     * @example
     * // Get all light components in the hierarchy tree that starts with this entity
     * var lights = entity.findComponents("light");
     */
    findComponents(type: string): Component[];
    /**
     * Get the GUID value for this Entity.
     *
     * @returns {string} The GUID of the Entity.
     * @ignore
     */
    getGuid(): string;
    /**
     * Set the GUID value for this Entity. Note that it is unlikely that you should need to change
     * the GUID value of an Entity at run-time. Doing so will corrupt the graph this Entity is in.
     *
     * @param {string} guid - The GUID to assign to the Entity.
     * @ignore
     */
    setGuid(guid: string): void;
    /** @private */
    private _onHierarchyStatePostChanged;
    /**
     * Find a descendant of this entity with the GUID.
     *
     * @param {string} guid - The GUID to search for.
     * @returns {Entity|null} The entity with the matching GUID or null if no entity is found.
     */
    findByGuid(guid: string): Entity | null;
    /**
     * Remove all components from the Entity and detach it from the Entity hierarchy. Then
     * recursively destroy all ancestor Entities.
     *
     * @example
     * var firstChild = this.entity.children[0];
     * firstChild.destroy(); // delete child, all components and remove from hierarchy
     */
    destroy(): void;
    /**
     * Create a deep copy of the Entity. Duplicate the full Entity hierarchy, with all Components
     * and all descendants. Note, this Entity is not in the hierarchy and must be added manually.
     *
     * @returns {this} A new Entity which is a deep copy of the original.
     * @example
     * var e = this.entity.clone();
     *
     * // Add clone as a sibling to the original
     * this.entity.parent.addChild(e);
     */
    clone(): this;
    /**
     * @param {Object<string, Entity>} duplicatedIdsMap - A map of original entity GUIDs to cloned
     * entities.
     * @returns {this} A new Entity which is a deep copy of the original.
     * @private
     */
    private _cloneRecursively;
}


/** @typedef {import('./xr-manager.js').XrManager} XrManager */
/**
 * Depth Sensing provides depth information which is reconstructed using the underlying AR system.
 * It provides the ability to query depth values (CPU path) or access a depth texture (GPU path).
 * Depth information can be used (not limited to) for reconstructing real world geometry, virtual
 * object placement, occlusion of virtual objects by real world geometry and more.
 *
 * ```javascript
 * // CPU path
 * var depthSensing = app.xr.depthSensing;
 * if (depthSensing.available) {
 *     // get depth in the middle of the screen, value is in meters
 *     var depth = depthSensing.getDepth(depthSensing.width / 2, depthSensing.height / 2);
 * }
 * ```
 *
 * ```javascript
 * // GPU path, attaching texture to material
 * material.diffuseMap = depthSensing.texture;
 * material.setParameter('matrix_depth_uv', depthSensing.uvMatrix.data);
 * material.setParameter('depth_raw_to_meters', depthSensing.rawValueToMeters);
 * material.update();
 *
 * // update UV transformation matrix on depth texture resize
 * depthSensing.on('resize', function () {
 *     material.setParameter('matrix_depth_uv', depthSensing.uvMatrix.data);
 *     material.setParameter('depth_raw_to_meters', depthSensing.rawValueToMeters);
 * });
 * ```
 *
 * ```javascript
 * // GLSL shader to unpack depth texture
 * varying vec2 vUv0;
 *
 * uniform sampler2D texture_depthSensingMap;
 * uniform mat4 matrix_depth_uv;
 * uniform float depth_raw_to_meters;
 *
 * void main(void) {
 *     // transform UVs using depth matrix
 *     vec2 texCoord = (matrix_depth_uv * vec4(vUv0.xy, 0.0, 1.0)).xy;
 *
 *     // get luminance alpha components from depth texture
 *     vec2 packedDepth = texture2D(texture_depthSensingMap, texCoord).ra;
 *
 *     // unpack into single value in millimeters
 *     float depth = dot(packedDepth, vec2(255.0, 256.0 * 255.0)) * depth_raw_to_meters; // m
 *
 *     // normalize: 0m to 8m distance
 *     depth = min(depth / 8.0, 1.0); // 0..1 = 0..8
 *
 *     // paint scene from black to white based on distance
 *     gl_FragColor = vec4(depth, depth, depth, 1.0);
 * }
 * ```
 *
 * @augments EventHandler
 */
declare class XrDepthSensing extends EventHandler {
    /**
     * Create a new XrDepthSensing instance.
     *
     * @param {XrManager} manager - WebXR Manager.
     * @hideconstructor
     */
    constructor(manager: XrManager);
    /**
     * @type {XrManager}
     * @private
     */
    private _manager;
    /**
     * @type {boolean}
     * @private
     */
    private _available;
    /**
     * @type {XRCPUDepthInformation|null}
     * @private
     */
    private _depthInfoCpu;
    /**
     * @type {XRCPUDepthInformation|null}
     * @private
     */
    private _depthInfoGpu;
    /**
     * @type {string|null}
     * @private
     */
    private _usage;
    /**
     * @type {string|null}
     * @private
     */
    private _dataFormat;
    /**
     * @type {boolean}
     * @private
     */
    private _matrixDirty;
    /**
     * @type {Mat4}
     * @private
     */
    private _matrix;
    /**
     * @type {Uint8Array}
     * @private
     */
    private _emptyBuffer;
    /**
     * @type {Uint8Array|null}
     * @private
     */
    private _depthBuffer;
    /**
     * @type {Texture}
     * @private
     */
    private _texture;
    /**
     * Fired when depth sensing data becomes available.
     *
     * @event XrDepthSensing#available
     */
    /**
     * Fired when depth sensing data becomes unavailable.
     *
     * @event XrDepthSensing#unavailable
     */
    /**
     * Fired when the depth sensing texture been resized. The {@link XrDepthSensing#uvMatrix} needs
     * to be updated for relevant shaders.
     *
     * @event XrDepthSensing#resize
     * @param {number} width - The new width of the depth texture in pixels.
     * @param {number} height - The new height of the depth texture in pixels.
     * @example
     * depthSensing.on('resize', function () {
     *     material.setParameter('matrix_depth_uv', depthSensing.uvMatrix);
     * });
     */
    /** @ignore */
    destroy(): void;
    /** @private */
    private _onSessionStart;
    /** @private */
    private _onSessionEnd;
    /** @private */
    private _updateTexture;
    /**
     * @param {*} frame - XRFrame from requestAnimationFrame callback.
     * @param {*} view - First XRView of viewer XRPose.
     * @ignore
     */
    update(frame: any, view: any): void;
    /**
     * Get depth value from depth information in meters. UV is in range of 0..1, with origin in
     * top-left corner of a texture.
     *
     * @param {number} u - U coordinate of pixel in depth texture, which is in range from 0.0 to
     * 1.0 (left to right).
     * @param {number} v - V coordinate of pixel in depth texture, which is in range from 0.0 to
     * 1.0 (top to bottom).
     * @returns {number|null} Depth in meters or null if depth information is currently not
     * available.
     * @example
     * var depth = app.xr.depthSensing.getDepth(u, v);
     * if (depth !== null) {
     *     // depth in meters
     * }
     */
    getDepth(u: number, v: number): number | null;
    /**
     * True if Depth Sensing is supported.
     *
     * @type {boolean}
     */
    get supported(): boolean;
    /**
     * True if depth sensing information is available.
     *
     * @type {boolean}
     * @example
     * if (app.xr.depthSensing.available) {
     *     var depth = app.xr.depthSensing.getDepth(x, y);
     * }
     */
    get available(): boolean;
    /**
     * Whether the usage is CPU or GPU.
     *
     * @type {string}
     * @ignore
     */
    get usage(): string;
    /**
     * The depth sensing data format.
     *
     * @type {string}
     * @ignore
     */
    get dataFormat(): string;
    /**
     * Width of depth texture or 0 if not available.
     *
     * @type {number}
     */
    get width(): number;
    /**
     * Height of depth texture or 0 if not available.
     *
     * @type {number}
     */
    get height(): number;
    /**
     * Texture that contains packed depth information. The format of this texture is
     * {@link PIXELFORMAT_L8_A8}. It is UV transformed based on the underlying AR system which can
     * be normalized using {@link XrDepthSensing#uvMatrix}.
     *
     * @type {Texture}
     * @example
     * material.diffuseMap = depthSensing.texture;
     * @example
     * // GLSL shader to unpack depth texture
     * varying vec2 vUv0;
     *
     * uniform sampler2D texture_depthSensingMap;
     * uniform mat4 matrix_depth_uv;
     * uniform float depth_raw_to_meters;
     *
     * void main(void) {
     *     // transform UVs using depth matrix
     *     vec2 texCoord = (matrix_depth_uv * vec4(vUv0.xy, 0.0, 1.0)).xy;
     *
     *     // get luminance alpha components from depth texture
     *     vec2 packedDepth = texture2D(texture_depthSensingMap, texCoord).ra;
     *
     *     // unpack into single value in millimeters
     *     float depth = dot(packedDepth, vec2(255.0, 256.0 * 255.0)) * depth_raw_to_meters; // m
     *
     *     // normalize: 0m to 8m distance
     *     depth = min(depth / 8.0, 1.0); // 0..1 = 0m..8m
     *
     *     // paint scene from black to white based on distance
     *     gl_FragColor = vec4(depth, depth, depth, 1.0);
     * }
     */
    get texture(): Texture;
    /**
     * 4x4 matrix that should be used to transform depth texture UVs to normalized UVs in a shader.
     * It is updated when the depth texture is resized. Refer to {@link XrDepthSensing#resize}.
     *
     * @type {Mat4}
     * @example
     * material.setParameter('matrix_depth_uv', depthSensing.uvMatrix.data);
     */
    get uvMatrix(): Mat4;
    /**
     * Multiply this coefficient number by raw depth value to get depth in meters.
     *
     * @type {number}
     * @example
     * material.setParameter('depth_raw_to_meters', depthSensing.rawValueToMeters);
     */
    get rawValueToMeters(): number;
}


/** @typedef {import('./xr-manager.js').XrManager} XrManager */
/**
 * DOM Overlay provides the ability to use DOM elements as an overlay in a WebXR AR session. It
 * requires that the root DOM element is provided for session start. That way, input source select
 * events are first tested against DOM Elements and then propagated down to the XR Session. If this
 * propagation is not desirable, use the `beforexrselect` event on a DOM element and the
 * `preventDefault` function to stop propagation.
 *
 * ```javascript```
 * app.xr.domOverlay.root = element;
 * app.xr.start(camera, pc.XRTYPE_AR, pc.XRSPACE_LOCALFLOOR);
 * ```
 *
 * ```javascript
 * // Disable input source firing `select` event when some descendant element of DOM overlay root
 * // is touched/clicked. This is useful when the user interacts with UI elements and there should
 * // not be `select` events behind UI.
 * someElement.addEventListener('beforexrselect', function (evt) {
 *     evt.preventDefault();
 * });
 * ```
 */
declare class XrDomOverlay {
    /**
     * DOM Overlay provides the ability to use DOM elements as an overlay in a WebXR AR session. It
     * requires that the root DOM element is provided for session start. That way, input source
     * select events are first tested against DOM Elements and then propagated down to the XR
     * Session. If this propagation is not desirable, use the `beforexrselect` event on a DOM
     * element and the `preventDefault` function to stop propagation.
     *
     * @param {XrManager} manager - WebXR Manager.
     * @hideconstructor
     */
    constructor(manager: XrManager);
    /**
     * @type {XrManager}
     * @private
     */
    private _manager;
    /**
     * @type {boolean}
     * @private
     */
    private _supported;
    /**
     * @type {Element|null}
     * @private
     */
    private _root;
    /**
     * True if DOM Overlay is supported.
     *
     * @type {boolean}
     */
    get supported(): boolean;
    /**
     * True if DOM Overlay is available. It can only be available if it is supported, during a
     * valid WebXR session and if a valid root element is provided.
     *
     * @type {boolean}
     */
    get available(): boolean;
    /**
     * State of the DOM Overlay, which defines how the root DOM element is rendered. Possible
     * options:
     *
     * - screen: Screen - indicates that the DOM element is covering whole physical screen,
     * matching XR viewports.
     * - floating: Floating - indicates that the underlying platform renders the DOM element as
     * floating in space, which can move during the WebXR session or allow the application to move
     * the element.
     * - head-locked: Head Locked - indicates that the DOM element follows the user's head movement
     * consistently, appearing similar to a helmet heads-up display.
     *
     * @type {string|null}
     */
    get state(): string;
    /**
     * The DOM element to be used as the root for DOM Overlay. Can be changed only outside of an
     * active WebXR session.
     *
     * @type {Element|null}
     * @example
     * app.xr.domOverlay.root = element;
     * app.xr.start(camera, pc.XRTYPE_AR, pc.XRSPACE_LOCALFLOOR);
     */
    set root(arg: Element);
    get root(): Element;
}


/**
 * Represents XR hit test source, which provides access to hit results of real world geometry from
 * AR session.
 *
 * @augments EventHandler
 */
declare class XrHitTestSource extends EventHandler {
    /**
     * Create a new XrHitTestSource instance.
     *
     * @param {XrManager} manager - WebXR Manager.
     * @param {*} xrHitTestSource - XRHitTestSource object that is created by WebXR API.
     * @param {boolean} transient - True if XRHitTestSource created for input source profile.
     * @hideconstructor
     */
    constructor(manager: XrManager, xrHitTestSource: any, transient: boolean);
    /**
     * @type {XrManager}
     * @private
     */
    private manager;
    /**
     * @type {XRHitTestSource}
     * @private
     */
    private _xrHitTestSource;
    /**
     * @type {boolean}
     * @private
     */
    private _transient;
    /**
     * Fired when {@link XrHitTestSource} is removed.
     *
     * @event XrHitTestSource#remove
     * @example
     * hitTestSource.once('remove', function () {
     *     // hit test source has been removed
     * });
     */
    /**
     * Fired when hit test source receives new results. It provides transform information that
     * tries to match real world picked geometry.
     *
     * @event XrHitTestSource#result
     * @param {Vec3} position - Position of hit test.
     * @param {Quat} rotation - Rotation of hit test.
     * @param {XrInputSource|null} inputSource - If is transient hit test source, then it will
     * provide related input source.
     * @example
     * hitTestSource.on('result', function (position, rotation, inputSource) {
     *     target.setPosition(position);
     *     target.setRotation(rotation);
     * });
     */
    /**
     * Stop and remove hit test source.
     */
    remove(): void;
    /** @ignore */
    onStop(): void;
    /**
     * @param {*} frame - XRFrame from requestAnimationFrame callback.
     * @ignore
     */
    update(frame: any): void;
    /**
     * @param {XRTransientInputHitTestResult[]} results - Hit test results.
     * @param {XRHitTestSource} inputSource - Input source.
     * @private
     */
    private updateHitResults;
}



/**
 * Callback used by {@link XrHitTeststart } and {@link XrHitTeststartForInputSource }.
 */
export type XrHitTestStartCallback = (err: Error | null, hitTestSource: XrHitTestSource | null) => any;
/** @typedef {import('./xr-manager.js').XrManager} XrManager */
/** @typedef {import('../shape/ray.js').Ray} Ray */
/**
 * Callback used by {@link XrHitTest#start} and {@link XrHitTest#startForInputSource}.
 *
 * @callback XrHitTestStartCallback
 * @param {Error|null} err - The Error object if failed to create hit test source or null.
 * @param {XrHitTestSource|null} hitTestSource - Object that provides access to hit results against
 * real world geometry.
 */
/**
 * Hit Test provides ability to get position and rotation of ray intersecting point with
 * representation of real world geometry by underlying AR system.
 *
 * @augments EventHandler
 */
declare class XrHitTest extends EventHandler {
    /**
     * Create a new XrHitTest instance.
     *
     * @param {XrManager} manager - WebXR Manager.
     * @hideconstructor
     */
    constructor(manager: XrManager);
    /**
     * @type {XrManager}
     * @private
     */
    private manager;
    /**
     * @type {boolean}
     * @private
     */
    private _supported;
    /**
     * @type {XRSession}
     * @private
     */
    private _session;
    /**
     * List of active {@link XrHitTestSource}.
     *
     * @type {XrHitTestSource[]}
     */
    sources: XrHitTestSource[];
    /**
     * Fired when new {@link XrHitTestSource} is added to the list.
     *
     * @event XrHitTest#add
     * @param {XrHitTestSource} hitTestSource - Hit test source that has been added.
     * @example
     * app.xr.hitTest.on('add', function (hitTestSource) {
     *     // new hit test source is added
     * });
     */
    /**
     * Fired when {@link XrHitTestSource} is removed to the list.
     *
     * @event XrHitTest#remove
     * @param {XrHitTestSource} hitTestSource - Hit test source that has been removed.
     * @example
     * app.xr.hitTest.on('remove', function (hitTestSource) {
     *     // hit test source is removed
     * });
     */
    /**
     * Fired when hit test source receives new results. It provides transform information that
     * tries to match real world picked geometry.
     *
     * @event XrHitTest#result
     * @param {XrHitTestSource} hitTestSource - Hit test source that produced the hit result.
     * @param {Vec3} position - Position of hit test.
     * @param {Quat} rotation - Rotation of hit test.
     * @param {XrInputSource|null} inputSource - If is transient hit test source, then it will provide related input source.
     * @example
     * app.xr.hitTest.on('result', function (hitTestSource, position, rotation, inputSource) {
     *     target.setPosition(position);
     *     target.setRotation(rotation);
     * });
     */
    /**
     * Fired when failed create hit test source.
     *
     * @event XrHitTest#error
     * @param {Error} error - Error object related to failure of creating hit test source.
     */
    /** @private */
    private _onSessionStart;
    /** @private */
    private _onSessionEnd;
    /**
     * Checks if hit testing is available.
     *
     * @param {Function} callback - Error callback.
     * @param {*} fireError - Event handler on while to fire error event.
     * @returns {boolean} True if hit test is available.
     * @private
     */
    private isAvailable;
    /**
     * Attempts to start hit test with provided reference space.
     *
     * @param {object} [options] - Optional object for passing arguments.
     * @param {string} [options.spaceType] - Reference space type. Defaults to
     * {@link XRSPACE_VIEWER}. Can be one of the following:
     *
     * - {@link XRSPACE_VIEWER}: Viewer - hit test will be facing relative to viewers space.
     * - {@link XRSPACE_LOCAL}: Local - represents a tracking space with a native origin near the
     * viewer at the time of creation.
     * - {@link XRSPACE_LOCALFLOOR}: Local Floor - represents a tracking space with a native origin
     * at the floor in a safe position for the user to stand. The y axis equals 0 at floor level.
     * Floor level value might be estimated by the underlying platform.
     * - {@link XRSPACE_BOUNDEDFLOOR}: Bounded Floor - represents a tracking space with its native
     * origin at the floor, where the user is expected to move within a pre-established boundary.
     * - {@link XRSPACE_UNBOUNDED}: Unbounded - represents a tracking space where the user is
     * expected to move freely around their environment, potentially long distances from their
     * starting point.
     *
     * @param {string} [options.profile] - if hit test source meant to match input source instead
     * of reference space, then name of profile of the {@link XrInputSource} should be provided.
     * @param {string[]} [options.entityTypes] - Optional list of underlying entity types against
     * which hit tests will be performed. Defaults to [ {@link XRTRACKABLE_PLANE} ]. Can be any
     * combination of the following:
     *
     * - {@link XRTRACKABLE_POINT}: Point - indicates that the hit test results will be computed
     * based on the feature points detected by the underlying Augmented Reality system.
     * - {@link XRTRACKABLE_PLANE}: Plane - indicates that the hit test results will be computed
     * based on the planes detected by the underlying Augmented Reality system.
     * - {@link XRTRACKABLE_MESH}: Mesh - indicates that the hit test results will be computed
     * based on the meshes detected by the underlying Augmented Reality system.
     *
     * @param {Ray} [options.offsetRay] - Optional ray by which hit test ray can be offset.
     * @param {XrHitTestStartCallback} [options.callback] - Optional callback function called once
     * hit test source is created or failed.
     * @example
     * app.xr.hitTest.start({
     *     spaceType: pc.XRSPACE_VIEWER,
     *     callback: function (err, hitTestSource) {
     *         if (err) return;
     *         hitTestSource.on('result', function (position, rotation) {
     *             // position and rotation of hit test result
     *             // based on Ray facing forward from the Viewer reference space
     *         });
     *     }
     * });
     * @example
     * var ray = new pc.Ray(new pc.Vec3(0, 0, 0), new pc.Vec3(0, -1, 0));
     * app.xr.hitTest.start({
     *     spaceType: pc.XRSPACE_LOCAL,
     *     offsetRay: ray,
     *     callback: function (err, hitTestSource) {
     *         // hit test source that will sample real world geometry straight down
     *         // from the position where AR session started
     *     }
     * });
     * @example
     * app.xr.hitTest.start({
     *     profile: 'generic-touchscreen',
     *     callback: function (err, hitTestSource) {
     *         if (err) return;
     *         hitTestSource.on('result', function (position, rotation, inputSource) {
     *             // position and rotation of hit test result
     *             // that will be created from touch on mobile devices
     *         });
     *     }
     * });
     */
    start(options?: {
        spaceType?: string;
        profile?: string;
        entityTypes?: string[];
        offsetRay?: Ray;
        callback?: XrHitTestStartCallback;
    }): void;
    /**
     * @param {XRHitTestSource} xrHitTestSource - Hit test source.
     * @param {boolean} transient - True if hit test source is created from transient input source.
     * @param {Function} callback - Callback called once hit test source is created.
     * @private
     */
    private _onHitTestSource;
    /**
     * @param {*} frame - XRFrame from requestAnimationFrame callback.
     * @ignore
     */
    update(frame: any): void;
    /**
     * True if AR Hit Test is supported.
     *
     * @type {boolean}
     */
    get supported(): boolean;
}

/**
 * The tracked image interface that is created by the Image Tracking system and is provided as a
 * list from {@link XrImageTracking#images}. It contains information about the tracking state as
 * well as the position and rotation of the tracked image.
 *
 * @augments EventHandler
 */
declare class XrTrackedImage extends EventHandler {
    /**
     * The tracked image interface that is created by the Image Tracking system and is provided as
     * a list from {@link XrImageTracking#images}. It contains information about the tracking state
     * as well as the position and rotation of the tracked image.
     *
     * @param {HTMLCanvasElement|HTMLImageElement|SVGImageElement|HTMLVideoElement|Blob|ImageData|ImageBitmap} image - Image
     * that is matching the real world image as closely as possible. Resolution of images should be
     * at least 300x300. High resolution does NOT improve tracking performance. Color of image is
     * irrelevant, so grayscale images can be used. Images with too many geometric features or
     * repeating patterns will reduce tracking stability.
     * @param {number} width - Width (in meters) of image in real world. Providing this value as
     * close to the real value will improve tracking quality.
     * @hideconstructor
     */
    constructor(image: HTMLCanvasElement | HTMLImageElement | SVGImageElement | HTMLVideoElement | Blob | ImageData | ImageBitmap, width: number);
    /**
     * @type {HTMLCanvasElement|HTMLImageElement|SVGImageElement|HTMLVideoElement|Blob|ImageData|ImageBitmap}
     * @private
     */
    private _image;
    /**
     * @type {number}
     * @private
     */
    private _width;
    /**
     * @type {ImageBitmap|null}
     * @private
     */
    private _bitmap;
    /**
     * @type {number}
     * @ignore
     */
    _measuredWidth: number;
    /**
     * @type {boolean}
     * @private
     */
    private _trackable;
    /**
     * @type {boolean}
     * @private
     */
    private _tracking;
    /**
     * @type {boolean}
     * @private
     */
    private _emulated;
    /**
     * @type {*}
     * @ignore
     */
    _pose: any;
    /**
     * @type {Vec3}
     * @private
     */
    private _position;
    /**
     * @type {Quat}
     * @private
     */
    private _rotation;
    /**
     * Fired when image becomes actively tracked.
     *
     * @event XrTrackedImage#tracked
     */
    /**
     * Fired when image is no more actively tracked.
     *
     * @event XrTrackedImage#untracked
     */
    /**
     * Image that is used for tracking.
     *
     * @type {HTMLCanvasElement|HTMLImageElement|SVGImageElement|HTMLVideoElement|Blob|ImageData|ImageBitmap}
     */
    get image(): Blob | ImageBitmap | HTMLCanvasElement | HTMLImageElement | SVGImageElement | HTMLVideoElement | ImageData;
    /**
     * Width that is provided to assist tracking performance. This property can be updated only
     * when the AR session is not running.
     *
     * @type {number}
     */
    set width(arg: number);
    get width(): number;
    /**
     * True if image is trackable. A too small resolution or invalid images can be untrackable by
     * the underlying AR system.
     *
     * @type {boolean}
     */
    get trackable(): boolean;
    /**
     * True if image is in tracking state and being tracked in real world by the underlying AR
     * system.
     *
     * @type {boolean}
     */
    get tracking(): boolean;
    /**
     * True if image was recently tracked but currently is not actively tracked due to inability of
     * identifying the image by the underlying AR system. Position and rotation will be based on
     * the previously known transformation assuming the tracked image has not moved.
     *
     * @type {boolean}
     */
    get emulated(): boolean;
    /**
     * @returns {Promise<ImageBitmap>} Promise that resolves to an image bitmap.
     * @ignore
     */
    prepare(): Promise<ImageBitmap>;
    /**
     * Destroys the tracked image.
     *
     * @ignore
     */
    destroy(): void;
    /**
     * Get the position of the tracked image. The position is the most recent one based on the
     * tracked image state.
     *
     * @returns {Vec3} Position in world space.
     * @example
     * // update entity position to match tracked image position
     * entity.setPosition(trackedImage.getPosition());
     */
    getPosition(): Vec3;
    /**
     * Get the rotation of the tracked image. The rotation is the most recent based on the tracked
     * image state.
     *
     * @returns {Quat} Rotation in world space.
     * @example
     * // update entity rotation to match tracked image rotation
     * entity.setRotation(trackedImage.getRotation());
     */
    getRotation(): Quat;
}


/** @typedef {import('./xr-manager.js').XrManager} XrManager */
/**
 * Image Tracking provides the ability to track real world images by provided image samples and
 * their estimated sizes.
 *
 * @augments EventHandler
 */
declare class XrImageTracking extends EventHandler {
    /**
     * Image Tracking provides the ability to track real world images by provided image samples and
     * their estimate sizes.
     *
     * @param {XrManager} manager - WebXR Manager.
     * @hideconstructor
     */
    constructor(manager: XrManager);
    /**
     * @type {XrManager}
     * @private
     */
    private _manager;
    /**
     * @type {boolean}
     * @private
     */
    private _supported;
    /**
     * @type {boolean}
     * @private
     */
    private _available;
    /**
     * @type {XrTrackedImage[]}
     * @private
     */
    private _images;
    /**
     * Fired when the XR session is started, but image tracking failed to process the provided
     * images.
     *
     * @event XrImageTracking#error
     * @param {Error} error - Error object related to a failure of image tracking.
     */
    /**
     * Add an image for image tracking. A width can also be provided to help the underlying system
     * estimate the appropriate transformation. Modifying the tracked images list is only possible
     * before an AR session is started.
     *
     * @param {HTMLCanvasElement|HTMLImageElement|SVGImageElement|HTMLVideoElement|Blob|ImageData|ImageBitmap} image - Image
     * that is matching real world image as close as possible. Resolution of images should be at
     * least 300x300. High resolution does NOT improve tracking performance. Color of image is
     * irrelevant, so grayscale images can be used. Images with too many geometric features or
     * repeating patterns will reduce tracking stability.
     * @param {number} width - Width (in meters) of image in the real world. Providing this value
     * as close to the real value will improve tracking quality.
     * @returns {XrTrackedImage|null} Tracked image object that will contain tracking information.
     * Returns null if image tracking is not supported or if the XR manager is not active.
     * @example
     * // image with width of 20cm (0.2m)
     * app.xr.imageTracking.add(bookCoverImg, 0.2);
     */
    add(image: HTMLCanvasElement | HTMLImageElement | SVGImageElement | HTMLVideoElement | Blob | ImageData | ImageBitmap, width: number): XrTrackedImage | null;
    /**
     * Remove an image from image tracking.
     *
     * @param {XrTrackedImage} trackedImage - Tracked image to be removed. Modifying the tracked
     * images list is only possible before an AR session is started.
     */
    remove(trackedImage: XrTrackedImage): void;
    /** @private */
    private _onSessionStart;
    /** @private */
    private _onSessionEnd;
    /**
     * @param {Function} callback - Function to call when all images have been prepared as image
     * bitmaps.
     * @ignore
     */
    prepareImages(callback: Function): void;
    /**
     * @param {*} frame - XRFrame from requestAnimationFrame callback.
     * @ignore
     */
    update(frame: any): void;
    /**
     * True if Image Tracking is supported.
     *
     * @type {boolean}
     */
    get supported(): boolean;
    /**
     * True if Image Tracking is available. This property will be false if no images were provided
     * for the AR session or there was an error processing the provided images.
     *
     * @type {boolean}
     */
    get available(): boolean;
    /**
     * List of {@link XrTrackedImage} that contain tracking information.
     *
     * @type {XrTrackedImage[]}
     */
    get images(): XrTrackedImage[];
}


/**
 * Detected Plane instance that provides position, rotation and polygon points. Plane is a subject
 * to change during its lifetime.
 */
declare class XrPlane extends EventHandler {
    /**
     * Create a new XrPlane instance.
     *
     * @param {XrPlaneDetection} planeDetection - Plane detection system.
     * @param {*} xrPlane - XRPlane that is instantiated by WebXR system.
     * @hideconstructor
     */
    constructor(planeDetection: XrPlaneDetection, xrPlane: any);
    /**
     * @type {number}
     * @private
     */
    private _id;
    /**
     * @type {XrPlaneDetection}
     * @private
     */
    private _planeDetection;
    /**
     * @type {XRPlane}
     * @private
     */
    private _xrPlane;
    /**
     * @type {number}
     * @private
     */
    private _lastChangedTime;
    /**
     * @type {string}
     * @private
     */
    private _orientation;
    /**
     * @type {Vec3}
     * @private
     */
    private _position;
    /**
     * @type {Quat}
     * @private
     */
    private _rotation;
    /**
     * Fired when {@link XrPlane} is removed.
     *
     * @event XrPlane#remove
     * @example
     * plane.once('remove', function () {
     *     // plane is not available anymore
     * });
     */
    /**
     * Fired when {@link XrPlane} attributes such as: orientation and/or points have been changed.
     * Position and rotation can change at any time without triggering a `change` event.
     *
     * @event XrPlane#change
     * @example
     * plane.on('change', function () {
     *     // plane has been changed
     * });
     */
    /** @ignore */
    destroy(): void;
    /**
     * @param {*} frame - XRFrame from requestAnimationFrame callback.
     * @ignore
     */
    update(frame: any): void;
    /**
     * Get the world space position of a plane.
     *
     * @returns {Vec3} The world space position of a plane.
     */
    getPosition(): Vec3;
    /**
     * Get the world space rotation of a plane.
     *
     * @returns {Quat} The world space rotation of a plane.
     */
    getRotation(): Quat;
    /**
     * Unique identifier of a plane.
     *
     * @type {number}
     */
    get id(): number;
    /**
     * Plane's specific orientation (horizontal or vertical) or null if orientation is anything else.
     *
     * @type {string|null}
     */
    get orientation(): string;
    /**
     * Array of DOMPointReadOnly objects. DOMPointReadOnly is an object with `x y z` properties
     * that defines a local point of a plane's polygon.
     *
     * @type {object[]}
     * @example
     * // prepare reusable objects
     * var vecA = new pc.Vec3();
     * var vecB = new pc.Vec3();
     * var color = new pc.Color(1, 1, 1);
     *
     * // update Mat4 to plane position and rotation
     * transform.setTRS(plane.getPosition(), plane.getRotation(), pc.Vec3.ONE);
     *
     * // draw lines between points
     * for (var i = 0; i < plane.points.length; i++) {
     *     vecA.copy(plane.points[i]);
     *     vecB.copy(plane.points[(i + 1) % plane.points.length]);
     *
     *     // transform from planes local to world coords
     *     transform.transformPoint(vecA, vecA);
     *     transform.transformPoint(vecB, vecB);
     *
     *     // render line
     *     app.drawLine(vecA, vecB, color);
     * }
     */
    get points(): any[];
}


/** @typedef {import('./xr-manager.js').XrManager} XrManager */
/**
 * Plane Detection provides the ability to detect real world surfaces based on estimations of the
 * underlying AR system.
 *
 * ```javascript
 * // start session with plane detection enabled
 * app.xr.start(camera, pc.XRTYPE_VR, pc.XRSPACE_LOCALFLOOR, {
 *     planeDetection: true
 * });
 * ```
 *
 * ```javascript
 * app.xr.planeDetection.on('add', function (plane) {
 *     // new plane been added
 * });
 * ```
 */
declare class XrPlaneDetection extends EventHandler {
    /**
     * Create a new XrPlaneDetection instance.
     *
     * @param {XrManager} manager - WebXR Manager.
     * @hideconstructor
     */
    constructor(manager: XrManager);
    /**
     * @type {XrManager}
     * @private
     */
    private _manager;
    /**
     * @type {boolean}
     * @private
     */
    private _supported;
    /**
     * @type {boolean}
     * @private
     */
    private _available;
    /**
     * @type {Map<XRPlane, XrPlane>}
     * @private
     */
    private _planesIndex;
    /**
     * @type {XrPlane[]|null}
     * @private
     */
    private _planes;
    /**
     * Fired when plane detection becomes available.
     *
     * @event XrPlaneDetection#available
     */
    /**
     * Fired when plane detection becomes unavailable.
     *
     * @event XrPlaneDetection#unavailable
     */
    /**
     * Fired when new {@link XrPlane} is added to the list.
     *
     * @event XrPlaneDetection#add
     * @param {XrPlane} plane - Plane that has been added.
     * @example
     * app.xr.planeDetection.on('add', function (plane) {
     *     // new plane is added
     * });
     */
    /**
     * Fired when a {@link XrPlane} is removed from the list.
     *
     * @event XrPlaneDetection#remove
     * @param {XrPlane} plane - Plane that has been removed.
     * @example
     * app.xr.planeDetection.on('remove', function (plane) {
     *     // new plane is removed
     * });
     */
    /** @private */
    private _onSessionEnd;
    /**
     * @param {*} frame - XRFrame from requestAnimationFrame callback.
     * @ignore
     */
    update(frame: any): void;
    /**
     * True if Plane Detection is supported.
     *
     * @type {boolean}
     */
    get supported(): boolean;
    /**
     * True if Plane Detection is available. This property can be set to true only during a running
     * session.
     *
     * @type {boolean}
     */
    get available(): boolean;
    /**
     * Array of {@link XrPlane} instances that contain individual plane information, or null if
     * plane detection is not available.
     *
     * @type {XrPlane[]|null}
     */
    get planes(): XrPlane[];
}


/** @typedef {import('./xr-hand.js').XrHand} XrHand */
/** @typedef {import('./xr-joint.js').XrJoint} XrJoint */
/**
 * Represents finger with related joints and index.
 */
declare class XrFinger {
    /**
     * Create a new XrFinger instance.
     *
     * @param {number} index - Index of a finger.
     * @param {XrHand} hand - Hand that finger relates to.
     * @hideconstructor
     */
    constructor(index: number, hand: XrHand);
    /**
     * @type {number}
     * @private
     */
    private _index;
    /**
     * @type {XrHand}
     * @private
     */
    private _hand;
    /**
     * @type {XrJoint[]}
     * @private
     */
    private _joints;
    /**
     * @type {XrJoint|null}
     * @private
     */
    private _tip;
    /**
     * Index of a finger, numeration is: thumb, index, middle, ring, little.
     *
     * @type {number}
     */
    get index(): number;
    /**
     * Hand that finger relates to.
     *
     * @type {XrHand}
     */
    get hand(): XrHand;
    /**
     * List of joints that relates to this finger, starting from joint closest to wrist all the way
     * to the tip of a finger.
     *
     * @type {XrJoint[]}
     */
    get joints(): XrJoint[];
    /**
     * Tip of a finger, or null if not available.
     *
     * @type {XrJoint|null}
     */
    get tip(): XrJoint;
}



/**
 * Represents the joint of a finger.
 */
declare class XrJoint {
    /**
     * Create an XrJoint instance.
     *
     * @param {number} index - Index of a joint within a finger.
     * @param {string} id - Id of a joint based on WebXR Hand Input Specs.
     * @param {XrHand} hand - Hand that joint relates to.
     * @param {XrFinger} [finger] - Finger that joint is related to, can be null in case of wrist.
     * joint.
     * @hideconstructor
     */
    constructor(index: number, id: string, hand: XrHand, finger?: XrFinger);
    /**
     * @type {number}
     * @private
     */
    private _index;
    /**
     * @type {string}
     * @private
     */
    private _id;
    /**
     * @type {XrHand}
     * @private
     */
    private _hand;
    /**
     * @type {XrFinger}
     * @private
     */
    private _finger;
    /**
     * @type {boolean}
     * @private
     */
    private _wrist;
    /**
     * @type {boolean}
     * @private
     */
    private _tip;
    /**
     * @type {number}
     * @private
     */
    private _radius;
    /**
     * @type {Mat4}
     * @private
     */
    private _localTransform;
    /**
     * @type {Mat4}
     * @private
     */
    private _worldTransform;
    /**
     * @type {Vec3}
     * @private
     */
    private _localPosition;
    /**
     * @type {Quat}
     * @private
     */
    private _localRotation;
    /**
     * @type {Vec3}
     * @private
     */
    private _position;
    /**
     * @type {Quat}
     * @private
     */
    private _rotation;
    /**
     * @type {boolean}
     * @private
     */
    private _dirtyLocal;
    /**
     * @param {*} pose - XRJointPose of this joint.
     * @ignore
     */
    update(pose: any): void;
    /** @private */
    private _updateTransforms;
    /**
     * Get the world space position of a joint.
     *
     * @returns {Vec3} The world space position of a joint.
     */
    getPosition(): Vec3;
    /**
     * Get the world space rotation of a joint.
     *
     * @returns {Quat} The world space rotation of a joint.
     */
    getRotation(): Quat;
    /**
     * Index of a joint within a finger, starting from 0 (root of a finger) all the way to tip of
     * the finger.
     *
     * @type {number}
     */
    get index(): number;
    /**
     * Hand that joint relates to.
     *
     * @type {XrHand}
     */
    get hand(): XrHand;
    /**
     * Finger that joint relates to.
     *
     * @type {XrFinger|null}
     */
    get finger(): XrFinger;
    /**
     * True if joint is a wrist.
     *
     * @type {boolean}
     */
    get wrist(): boolean;
    /**
     * True if joint is a tip of a finger.
     *
     * @type {boolean}
     */
    get tip(): boolean;
    /**
     * The radius of a joint, which is a distance from joint to the edge of a skin.
     *
     * @type {number}
     */
    get radius(): number;
}


/**
 * Represents a hand with fingers and joints.
 *
 * @augments EventHandler
 */
declare class XrHand extends EventHandler {
    /**
     * Represents a hand with fingers and joints.
     *
     * @param {XrInputSource} inputSource - Input Source that hand is related to.
     * @hideconstructor
     */
    constructor(inputSource: XrInputSource);
    /**
     * @type {XrManager}
     * @private
     */
    private _manager;
    /**
     * @type {XrInputSource}
     * @private
     */
    private _inputSource;
    /**
     * @type {boolean}
     * @private
     */
    private _tracking;
    /**
     * @type {XrFinger[]}
     * @private
     */
    private _fingers;
    /**
     * @type {XrJoint[]}
     * @private
     */
    private _joints;
    /**
     * @type {Object<string, XrJoint>}
     * @private
     */
    private _jointsById;
    /**
     * @type {XrJoint[]}
     * @private
     */
    private _tips;
    /**
     * @type {XrJoint|null}
     * @private
     */
    private _wrist;
    /**
     * Fired when tracking becomes available.
     *
     * @event XrHand#tracking
     */
    /**
     * Fired when tracking is lost.
     *
     * @event XrHand#trackinglost
     */
    /**
     * @param {*} frame - XRFrame from requestAnimationFrame callback.
     * @ignore
     */
    update(frame: any): void;
    /**
     * @param {number} index - Finger index.
     * @returns {boolean} True if finger is closed and false otherwise.
     * @private
     */
    private _fingerIsClosed;
    /**
     * Returns joint by XRHand id from list in specs: https://immersive-web.github.io/webxr-hand-input/.
     *
     * @param {string} id - Id of a joint based on specs ID's in XRHand: https://immersive-web.github.io/webxr-hand-input/.
     * @returns {XrJoint|null} Joint or null if not available.
     */
    getJointById(id: string): XrJoint | null;
    /**
     * List of fingers of a hand.
     *
     * @type {XrFinger[]}
     */
    get fingers(): XrFinger[];
    /**
     * List of joints of hand.
     *
     * @type {XrJoint[]}
     */
    get joints(): XrJoint[];
    /**
     * List of joints that are fingertips.
     *
     * @type {XrJoint[]}
     */
    get tips(): XrJoint[];
    /**
     * Wrist of a hand, or null if it is not available by WebXR underlying system.
     *
     * @type {XrJoint|null}
     */
    get wrist(): XrJoint;
    /**
     * True if tracking is available, otherwise tracking might be lost.
     *
     * @type {boolean}
     */
    get tracking(): boolean;
}



/**
 * Represents XR input source, which is any input mechanism which allows the user to perform
 * targeted actions in the same virtual space as the viewer. Example XR input sources include, but
 * are not limited to, handheld controllers, optically tracked hands, and gaze-based input methods
 * that operate on the viewer's pose.
 *
 * @augments EventHandler
 */
declare class XrInputSource extends EventHandler {
    /**
     * Create a new XrInputSource instance.
     *
     * @param {XrManager} manager - WebXR Manager.
     * @param {*} xrInputSource - [XRInputSource](https://developer.mozilla.org/en-US/docs/Web/API/XRInputSource)
     * object that is created by WebXR API.
     * @hideconstructor
     */
    constructor(manager: XrManager, xrInputSource: any);
    /**
     * @type {number}
     * @private
     */
    private _id;
    /**
     * @type {XrManager}
     * @private
     */
    private _manager;
    /**
     * @type {XRInputSource}
     * @private
     */
    private _xrInputSource;
    /**
     * @type {Ray}
     * @private
     */
    private _ray;
    /**
     * @type {Ray}
     * @private
     */
    private _rayLocal;
    /**
     * @type {boolean}
     * @private
     */
    private _grip;
    /**
     * @type {XrHand}
     * @private
     */
    private _hand;
    /**
     * @type {Mat4|null}
     * @private
     */
    private _localTransform;
    /**
     * @type {Mat4|null}
     * @private
     */
    private _worldTransform;
    /**
     * @type {Vec3}
     * @private
     */
    private _position;
    /**
     * @type {Quat}
     * @private
     */
    private _rotation;
    /**
     * @type {Mat4|null}
     * @private
     */
    private _localPosition;
    /**
     * @type {Mat4|null}
     * @private
     */
    private _localRotation;
    /**
     * @type {boolean}
     * @private
     */
    private _dirtyLocal;
    /**
     * @type {boolean}
     * @private
     */
    private _dirtyRay;
    /**
     * @type {boolean}
     * @private
     */
    private _selecting;
    /**
     * @type {boolean}
     * @private
     */
    private _squeezing;
    /**
     * @type {boolean}
     * @private
     */
    private _elementInput;
    /**
     * @type {Entity|null}
     * @private
     */
    private _elementEntity;
    /**
     * @type {XrHitTestSource[]}
     * @private
     */
    private _hitTestSources;
    /**
     * Fired when {@link XrInputSource} is removed.
     *
     * @event XrInputSource#remove
     * @example
     * inputSource.once('remove', function () {
     *     // input source is not available anymore
     * });
     */
    /**
     * Fired when input source has triggered primary action. This could be pressing a trigger
     * button, or touching a screen.
     *
     * @event XrInputSource#select
     * @param {object} evt - XRInputSourceEvent event data from WebXR API.
     * @example
     * var ray = new pc.Ray();
     * inputSource.on('select', function (evt) {
     *     ray.set(inputSource.getOrigin(), inputSource.getDirection());
     *     if (obj.intersectsRay(ray)) {
     *         // selected an object with input source
     *     }
     * });
     */
    /**
     * Fired when input source has started to trigger primary action.
     *
     * @event XrInputSource#selectstart
     * @param {object} evt - XRInputSourceEvent event data from WebXR API.
     */
    /**
     * Fired when input source has ended triggering primary action.
     *
     * @event XrInputSource#selectend
     * @param {object} evt - XRInputSourceEvent event data from WebXR API.
     */
    /**
     * Fired when input source has triggered squeeze action. This is associated with "grabbing"
     * action on the controllers.
     *
     * @event XrInputSource#squeeze
     * @param {object} evt - XRInputSourceEvent event data from WebXR API.
     */
    /**
     * Fired when input source has started to trigger squeeze action.
     *
     * @event XrInputSource#squeezestart
     * @param {object} evt - XRInputSourceEvent event data from WebXR API.
     * @example
     * inputSource.on('squeezestart', function (evt) {
     *     if (obj.containsPoint(inputSource.getPosition())) {
     *         // grabbed an object
     *     }
     * });
     */
    /**
     * Fired when input source has ended triggering squeeze action.
     *
     * @event XrInputSource#squeezeend
     * @param {object} evt - XRInputSourceEvent event data from WebXR API.
     */
    /**
     * Fired when new {@link XrHitTestSource} is added to the input source.
     *
     * @event XrInputSource#hittest:add
     * @param {XrHitTestSource} hitTestSource - Hit test source that has been added.
     * @example
     * inputSource.on('hittest:add', function (hitTestSource) {
     *     // new hit test source is added
     * });
     */
    /**
     * Fired when {@link XrHitTestSource} is removed to the the input source.
     *
     * @event XrInputSource#hittest:remove
     * @param {XrHitTestSource} hitTestSource - Hit test source that has been removed.
     * @example
     * inputSource.on('remove', function (hitTestSource) {
     *     // hit test source is removed
     * });
     */
    /**
     * Fired when hit test source receives new results. It provides transform information that
     * tries to match real world picked geometry.
     *
     * @event XrInputSource#hittest:result
     * @param {XrHitTestSource} hitTestSource - Hit test source that produced the hit result.
     * @param {Vec3} position - Position of hit test.
     * @param {Quat} rotation - Rotation of hit test.
     * @example
     * inputSource.on('hittest:result', function (hitTestSource, position, rotation) {
     *     target.setPosition(position);
     *     target.setRotation(rotation);
     * });
     */
    /**
     * Unique number associated with instance of input source. Same physical devices when
     * reconnected will not share this ID.
     *
     * @type {number}
     */
    get id(): number;
    /**
     * XRInputSource object that is associated with this input source.
     *
     * @type {object}
     */
    get inputSource(): any;
    /**
     * Type of ray Input Device is based on. Can be one of the following:
     *
     * - {@link XRTARGETRAY_GAZE}: Gaze - indicates the target ray will originate at the viewer and
     * follow the direction it is facing. This is commonly referred to as a "gaze input" device in
     * the context of head-mounted displays.
     * - {@link XRTARGETRAY_SCREEN}: Screen - indicates that the input source was an interaction
     * with the canvas element associated with an inline session's output context, such as a mouse
     * click or touch event.
     * - {@link XRTARGETRAY_POINTER}: Tracked Pointer - indicates that the target ray originates
     * from either a handheld device or other hand-tracking mechanism and represents that the user
     * is using their hands or the held device for pointing.
     *
     * @type {string}
     */
    get targetRayMode(): string;
    /**
     * Describes which hand input source is associated with. Can be one of the following:
     *
     * - {@link XRHAND_NONE}: None - input source is not meant to be held in hands.
     * - {@link XRHAND_LEFT}: Left - indicates that input source is meant to be held in left hand.
     * - {@link XRHAND_RIGHT}: Right - indicates that input source is meant to be held in right
     * hand.
     *
     * @type {string}
     */
    get handedness(): string;
    /**
     * List of input profile names indicating both the preferred visual representation and behavior
     * of the input source.
     *
     * @type {string[]}
     */
    get profiles(): string[];
    /**
     * If input source can be held, then it will have node with its world transformation, that can
     * be used to position and rotate virtual joysticks based on it.
     *
     * @type {boolean}
     */
    get grip(): boolean;
    /**
     * If input source is a tracked hand, then it will point to {@link XrHand} otherwise it is
     * null.
     *
     * @type {XrHand|null}
     */
    get hand(): XrHand;
    /**
     * If input source has buttons, triggers, thumbstick or touchpad, then this object provides
     * access to its states.
     *
     * @type {Gamepad|null}
     */
    get gamepad(): Gamepad;
    /**
     * True if input source is in active primary action between selectstart and selectend events.
     *
     * @type {boolean}
     */
    get selecting(): boolean;
    /**
     * True if input source is in active squeeze action between squeezestart and squeezeend events.
     *
     * @type {boolean}
     */
    get squeezing(): boolean;
    /**
     * Set to true to allow input source to interact with Element components. Defaults to true.
     *
     * @type {boolean}
     */
    set elementInput(arg: boolean);
    get elementInput(): boolean;
    /**
     * If {@link XrInputSource#elementInput} is true, this property will hold entity with Element
     * component at which this input source is hovering, or null if not hovering over any element.
     *
     * @type {Entity|null}
     */
    get elementEntity(): Entity;
    /**
     * List of active {@link XrHitTestSource} instances created by this input source.
     *
     * @type {XrHitTestSource[]}
     */
    get hitTestSources(): XrHitTestSource[];
    /**
     * @param {*} frame - XRFrame from requestAnimationFrame callback.
     * @ignore
     */
    update(frame: any): void;
    /** @private */
    private _updateTransforms;
    /** @private */
    private _updateRayTransforms;
    /**
     * Get the world space position of input source if it is handheld ({@link XrInputSource#grip}
     * is true). Otherwise it will return null.
     *
     * @returns {Vec3|null} The world space position of handheld input source.
     */
    getPosition(): Vec3 | null;
    /**
     * Get the local space position of input source if it is handheld ({@link XrInputSource#grip}
     * is true). Local space is relative to parent of the XR camera. Otherwise it will return null.
     *
     * @returns {Vec3|null} The world space position of handheld input source.
     */
    getLocalPosition(): Vec3 | null;
    /**
     * Get the world space rotation of input source if it is handheld ({@link XrInputSource#grip}
     * is true). Otherwise it will return null.
     *
     * @returns {Quat|null} The world space rotation of handheld input source.
     */
    getRotation(): Quat | null;
    /**
     * Get the local space rotation of input source if it is handheld ({@link XrInputSource#grip}
     * is true). Local space is relative to parent of the XR camera. Otherwise it will return null.
     *
     * @returns {Vec3|null} The world space rotation of handheld input source.
     */
    getLocalRotation(): Vec3 | null;
    /**
     * Get the world space origin of input source ray.
     *
     * @returns {Vec3} The world space origin of input source ray.
     */
    getOrigin(): Vec3;
    /**
     * Get the world space direction of input source ray.
     *
     * @returns {Vec3} The world space direction of input source ray.
     */
    getDirection(): Vec3;
    /**
     * Attempts to start hit test source based on this input source.
     *
     * @param {object} [options] - Object for passing optional arguments.
     * @param {string[]} [options.entityTypes] - Optional list of underlying entity types against
     * which hit tests will be performed. Defaults to [ {@link XRTRACKABLE_PLANE} ]. Can be any
     * combination of the following:
     *
     * - {@link XRTRACKABLE_POINT}: Point - indicates that the hit test results will be computed
     * based on the feature points detected by the underlying Augmented Reality system.
     * - {@link XRTRACKABLE_PLANE}: Plane - indicates that the hit test results will be computed
     * based on the planes detected by the underlying Augmented Reality system.
     * - {@link XRTRACKABLE_MESH}: Mesh - indicates that the hit test results will be computed
     * based on the meshes detected by the underlying Augmented Reality system.
     *
     * @param {Ray} [options.offsetRay] - Optional ray by which hit test ray can be offset.
     * @param {XrHitTestStartCallback} [options.callback] - Optional callback function called once
     * hit test source is created or failed.
     * @example
     * app.xr.input.on('add', function (inputSource) {
     *     inputSource.hitTestStart({
     *         callback: function (err, hitTestSource) {
     *             if (err) return;
     *             hitTestSource.on('result', function (position, rotation) {
     *                 // position and rotation of hit test result
     *                 // that will be created from touch on mobile devices
     *             });
     *         }
     *     });
     * });
     */
    hitTestStart(options?: {
        entityTypes?: string[];
        offsetRay?: Ray;
        callback?: XrHitTestStartCallback;
    }): void;
    /**
     * @param {XrHitTestSource} hitTestSource - Hit test source to be added.
     * @private
     */
    private onHitTestSourceAdd;
    /**
     * @param {XrHitTestSource} hitTestSource - Hit test source to be removed.
     * @private
     */
    private onHitTestSourceRemove;
}


/** @typedef {import('./xr-manager.js').XrManager} XrManager */
/**
 * Provides access to input sources for WebXR.
 *
 * @augments EventHandler
 */
declare class XrInput extends EventHandler {
    /**
     * Create a new XrInput instance.
     *
     * @param {XrManager} manager - WebXR Manager.
     * @hideconstructor
     */
    constructor(manager: XrManager);
    /**
     * @type {XrManager}
     * @private
     */
    private manager;
    /**
     * @type {XrInputSource[]}
     * @private
     */
    private _inputSources;
    /**
     * @type {Function}
     * @private
     */
    private _onInputSourcesChangeEvt;
    /**
     * Fired when new {@link XrInputSource} is added to the list.
     *
     * @event XrInput#add
     * @param {XrInputSource} inputSource - Input source that has been added.
     * @example
     * app.xr.input.on('add', function (inputSource) {
     *     // new input source is added
     * });
     */
    /**
     * Fired when {@link XrInputSource} is removed to the list.
     *
     * @event XrInput#remove
     * @param {XrInputSource} inputSource - Input source that has been removed.
     * @example
     * app.xr.input.on('remove', function (inputSource) {
     *     // input source is removed
     * });
     */
    /**
     * Fired when {@link XrInputSource} has triggered primary action. This could be pressing a
     * trigger button, or touching a screen.
     *
     * @event XrInput#select
     * @param {XrInputSource} inputSource - Input source that triggered select event.
     * @param {object} evt - XRInputSourceEvent event data from WebXR API.
     * @example
     * var ray = new pc.Ray();
     * app.xr.input.on('select', function (inputSource, evt) {
     *     ray.set(inputSource.getOrigin(), inputSource.getDirection());
     *     if (obj.intersectsRay(ray)) {
     *         // selected an object with input source
     *     }
     * });
     */
    /**
     * Fired when {@link XrInputSource} has started to trigger primary action.
     *
     * @event XrInput#selectstart
     * @param {XrInputSource} inputSource - Input source that triggered selectstart event.
     * @param {object} evt - XRInputSourceEvent event data from WebXR API.
     */
    /**
     * Fired when {@link XrInputSource} has ended triggerring primary action.
     *
     * @event XrInput#selectend
     * @param {XrInputSource} inputSource - Input source that triggered selectend event.
     * @param {object} evt - XRInputSourceEvent event data from WebXR API.
     */
    /**
     * Fired when {@link XrInputSource} has triggered squeeze action. This is associated with
     * "grabbing" action on the controllers.
     *
     * @event XrInput#squeeze
     * @param {XrInputSource} inputSource - Input source that triggered squeeze event.
     * @param {object} evt - XRInputSourceEvent event data from WebXR API.
     */
    /**
     * Fired when {@link XrInputSource} has started to trigger sqeeze action.
     *
     * @event XrInput#squeezestart
     * @param {XrInputSource} inputSource - Input source that triggered squeezestart event.
     * @param {object} evt - XRInputSourceEvent event data from WebXR API.
     * @example
     * app.xr.input.on('squeezestart', function (inputSource, evt) {
     *     if (obj.containsPoint(inputSource.getPosition())) {
     *         // grabbed an object
     *     }
     * });
     */
    /**
     * Fired when {@link XrInputSource} has ended triggerring sqeeze action.
     *
     * @event XrInput#squeezeend
     * @param {XrInputSource} inputSource - Input source that triggered squeezeend event.
     * @param {object} evt - XRInputSourceEvent event data from WebXR API.
     */
    /** @private */
    private _onSessionStart;
    /** @private */
    private _onSessionEnd;
    /**
     * @param {XRInputSourcesChangeEvent} evt - WebXR input sources change event.
     * @private
     */
    private _onInputSourcesChange;
    /**
     * @param {XRInputSource} xrInputSource - Input source to search for.
     * @returns {XrInputSource|null} The input source that matches the given WebXR input source or
     * null if no match is found.
     * @private
     */
    private _getByInputSource;
    /**
     * @param {XRInputSource} xrInputSource - Input source to add.
     * @private
     */
    private _addInputSource;
    /**
     * @param {XRInputSource} xrInputSource - Input source to remove.
     * @private
     */
    private _removeInputSource;
    /**
     * @param {*} frame - XRFrame from requestAnimationFrame callback.
     * @ignore
     */
    update(frame: any): void;
    /**
     * List of active {@link XrInputSource} instances.
     *
     * @type {XrInputSource[]}
     */
    get inputSources(): XrInputSource[];
}


/**
 * Light Estimation provides illumination data from the real world, which is estimated by the
 * underlying AR system. It provides a reflection Cube Map, that represents the reflection
 * estimation from the viewer position. A more simplified approximation of light is provided by L2
 * Spherical Harmonics data. And the most simple level of light estimation is the most prominent
 * directional light, its rotation, intensity and color.
 *
 * @augments EventHandler
 */
declare class XrLightEstimation extends EventHandler {
    /**
     * Create a new XrLightEstimation instance.
     *
     * @param {XrManager} manager - WebXR Manager.
     * @hideconstructor
     */
    constructor(manager: XrManager);
    /**
     * @type {XrManager}
     * @private
     */
    private _manager;
    /**
     * @type {boolean}
     * @private
     */
    private _supported;
    /**
     * @type {boolean}
     * @private
     */
    private _available;
    /**
     * @type {boolean}
     * @private
     */
    private _lightProbeRequested;
    /**
     * @type {XRLightProbe|null}
     * @private
     */
    private _lightProbe;
    /**
     * @type {number}
     * @private
     */
    private _intensity;
    /**
     * @type {Quat}
     * @private
     */
    private _rotation;
    /**
     * @type {Color}
     * @private
     */
    private _color;
    /**
     * @type {Float32Array}
     * @private
     */
    private _sphericalHarmonics;
    /**
     * Fired when light estimation data becomes available.
     *
     * @event XrLightEstimation#available
     */
    /**
     * Fired when light estimation has failed to start.
     *
     * @event XrLightEstimation#error
     * @param {Error} error - Error object related to failure of light estimation start.
     * @example
     * app.xr.lightEstimation.on('error', function (ex) {
     *     // has failed to start
     * });
     */
    /** @private */
    private _onSessionStart;
    /** @private */
    private _onSessionEnd;
    /**
     * Start estimation of illumination data. Availability of such data will come later and an
     * `available` event will be fired. If it failed to start estimation, an `error` event will be
     * fired.
     *
     * @example
     * app.xr.on('start', function () {
     *     if (app.xr.lightEstimation.supported) {
     *         app.xr.lightEstimation.start();
     *     }
     * });
     */
    start(): void;
    /**
     * End estimation of illumination data.
     */
    end(): void;
    /**
     * @param {*} frame - XRFrame from requestAnimationFrame callback.
     * @ignore
     */
    update(frame: any): void;
    /**
     * True if Light Estimation is supported. This information is available only during an active AR
     * session.
     *
     * @type {boolean}
     */
    get supported(): boolean;
    /**
     * True if estimated light information is available.
     *
     * @type {boolean}
     * @example
     * if (app.xr.lightEstimation.available) {
     *     entity.light.intensity = app.xr.lightEstimation.intensity;
     * }
     */
    get available(): boolean;
    /**
     * Intensity of what is estimated to be the most prominent directional light. Or null if data
     * is not available.
     *
     * @type {number|null}
     */
    get intensity(): number;
    /**
     * Color of what is estimated to be the most prominent directional light. Or null if data is
     * not available.
     *
     * @type {Color|null}
     */
    get color(): Color;
    /**
     * Rotation of what is estimated to be the most prominent directional light. Or null if data is
     * not available.
     *
     * @type {Quat|null}
     */
    get rotation(): Quat;
    /**
     * Spherical harmonics coefficients of what is estimated to be the most prominent directional
     * light. Or null if data is not available.
     *
     * @type {Float32Array|null}
     * @ignore
     */
    get sphericalHarmonics(): Float32Array;
}



/**
 * Callback used by {@link XrManagerendXr } and {@link XrManagerstartXr }.
 */
export type XrErrorCallback = (err: Error | null) => any;
/** @typedef {import('../framework/components/camera/component.js').CameraComponent} CameraComponent */
/** @typedef {import('../framework/app-base.js').AppBase} AppBase */
/** @typedef {import('../framework/entity.js').Entity} Entity */
/**
 * Callback used by {@link XrManager#endXr} and {@link XrManager#startXr}.
 *
 * @callback XrErrorCallback
 * @param {Error|null} err - The Error object or null if operation was successful.
 */
/**
 * Manage and update XR session and its states.
 *
 * @augments EventHandler
 */
declare class XrManager extends EventHandler {
    /**
     * Create a new XrManager instance.
     *
     * @param {AppBase} app - The main application.
     * @hideconstructor
     */
    constructor(app: AppBase);
    /**
     * @type {AppBase}
     * @ignore
     */
    app: AppBase;
    /**
     * @type {boolean}
     * @private
     */
    private _supported;
    /**
     * @type {Object<string, boolean>}
     * @private
     */
    private _available;
    /**
     * @type {string|null}
     * @private
     */
    private _type;
    /**
     * @type {string|null}
     * @private
     */
    private _spaceType;
    /**
     * @type {XRSession|null}
     * @private
     */
    private _session;
    /**
     * @type {XRWebGLLayer|null}
     * @private
     */
    private _baseLayer;
    /**
     * @type {XRReferenceSpace|null}
     * @private
     */
    private _referenceSpace;
    /**
     * Provides access to depth sensing capabilities.
     *
     * @type {XrDepthSensing}
     * @ignore
     */
    depthSensing: XrDepthSensing;
    /**
     * Provides access to DOM overlay capabilities.
     *
     * @type {XrDomOverlay}
     * @ignore
     */
    domOverlay: XrDomOverlay;
    /**
     * Provides the ability to perform hit tests on the representation of real world geometry
     * of the underlying AR system.
     *
     * @type {XrHitTest}
     */
    hitTest: XrHitTest;
    /**
     * Provides access to image tracking capabilities.
     *
     * @type {XrImageTracking}
     * @ignore
     */
    imageTracking: XrImageTracking;
    /**
     * Provides access to plane detection capabilities.
     *
     * @type {XrPlaneDetection}
     * @ignore
     */
    planeDetection: XrPlaneDetection;
    /**
     * Provides access to Input Sources.
     *
     * @type {XrInput}
     */
    input: XrInput;
    /**
     * Provides access to light estimation capabilities.
     *
     * @type {XrLightEstimation}
     * @ignore
     */
    lightEstimation: XrLightEstimation;
    /**
     * @type {CameraComponent}
     * @private
     */
    private _camera;
    /**
     * @type {Array<*>}
     * @ignore
     */
    views: Array<any>;
    /**
     * @type {Array<*>}
     * @ignore
     */
    viewsPool: Array<any>;
    /**
     * @type {Vec3}
     * @private
     */
    private _localPosition;
    /**
     * @type {Quat}
     * @private
     */
    private _localRotation;
    /**
     * @type {number}
     * @private
     */
    private _depthNear;
    /**
     * @type {number}
     * @private
     */
    private _depthFar;
    /**
     * @type {number}
     * @private
     */
    private _width;
    /**
     * @type {number}
     * @private
     */
    private _height;
    /**
     * Fired when availability of specific XR type is changed.
     *
     * @event XrManager#available
     * @param {string} type - The session type that has changed availability.
     * @param {boolean} available - True if specified session type is now available.
     * @example
     * app.xr.on('available', function (type, available) {
     *     console.log('"' + type + '" XR session is now ' + (available ? 'available' : 'unavailable'));
     * });
     */
    /**
     * Fired when availability of specific XR type is changed.
     *
     * @event XrManager#available:[type]
     * @param {boolean} available - True if specified session type is now available.
     * @example
     * app.xr.on('available:' + pc.XRTYPE_VR, function (available) {
     *     console.log('Immersive VR session is now ' + (available ? 'available' : 'unavailable'));
     * });
     */
    /**
     * Fired when XR session is started.
     *
     * @event XrManager#start
     * @example
     * app.xr.on('start', function () {
     *     // XR session has started
     * });
     */
    /**
     * Fired when XR session is ended.
     *
     * @event XrManager#end
     * @example
     * app.xr.on('end', function () {
     *     // XR session has ended
     * });
     */
    /**
     * Fired when XR session is updated, providing relevant XRFrame object.
     *
     * @event XrManager#update
     * @param {object} frame - [XRFrame](https://developer.mozilla.org/en-US/docs/Web/API/XRFrame)
     * object that can be used for interfacing directly with WebXR APIs.
     * @example
     * app.xr.on('update', function (frame) {
     *
     * });
     */
    /**
     * Fired when XR session is failed to start or failed to check for session type support.
     *
     * @event XrManager#error
     * @param {Error} error - Error object related to failure of session start or check of session
     * type support.
     * @example
     * app.xr.on('error', function (ex) {
     *     // XR session has failed to start, or failed to check for session type support
     * });
     */
    /**
     * Destroys the XrManager instance.
     *
     * @ignore
     */
    destroy(): void;
    /**
     * Attempts to start XR session for provided {@link CameraComponent} and optionally fires
     * callback when session is created or failed to create. Integrated XR APIs need to be enabled
     * by providing relevant options.
     *
     * @param {CameraComponent} camera - It will be used to render XR session and manipulated based
     * on pose tracking.
     * @param {string} type - Session type. Can be one of the following:
     *
     * - {@link XRTYPE_INLINE}: Inline - always available type of session. It has limited features
     * availability and is rendered into HTML element.
     * - {@link XRTYPE_VR}: Immersive VR - session that provides exclusive access to VR device with
     * best available tracking features.
     * - {@link XRTYPE_AR}: Immersive AR - session that provides exclusive access to VR/AR device
     * that is intended to be blended with real-world environment.
     *
     * @param {string} spaceType - Reference space type. Can be one of the following:
     *
     * - {@link XRSPACE_VIEWER}: Viewer - always supported space with some basic tracking
     * capabilities.
     * - {@link XRSPACE_LOCAL}: Local - represents a tracking space with a native origin near the
     * viewer at the time of creation. It is meant for seated or basic local XR sessions.
     * - {@link XRSPACE_LOCALFLOOR}: Local Floor - represents a tracking space with a native origin
     * at the floor in a safe position for the user to stand. The y axis equals 0 at floor level.
     * Floor level value might be estimated by the underlying platform. It is meant for seated or
     * basic local XR sessions.
     * - {@link XRSPACE_BOUNDEDFLOOR}: Bounded Floor - represents a tracking space with its native
     * origin at the floor, where the user is expected to move within a pre-established boundary.
     * - {@link XRSPACE_UNBOUNDED}: Unbounded - represents a tracking space where the user is
     * expected to move freely around their environment, potentially long distances from their
     * starting point.
     *
     * @param {object} [options] - Object with additional options for XR session initialization.
     * @param {string[]} [options.optionalFeatures] - Optional features for XRSession start. It is
     * used for getting access to additional WebXR spec extensions.
     * @param {boolean} [options.imageTracking] - Set to true to attempt to enable
     * {@link XrImageTracking}.
     * @param {boolean} [options.planeDetection] - Set to true to attempt to enable
     * {@link XrPlaneDetection}.
     * @param {XrErrorCallback} [options.callback] - Optional callback function called once session
     * is started. The callback has one argument Error - it is null if successfully started XR
     * session.
     * @param {object} [options.depthSensing] - Optional object with depth sensing parameters to
     * attempt to enable {@link XrDepthSensing}.
     * @param {string} [options.depthSensing.usagePreference] - Optional usage preference for depth
     * sensing, can be 'cpu-optimized' or 'gpu-optimized' (XRDEPTHSENSINGUSAGE_*), defaults to
     * 'cpu-optimized'. Most preferred and supported will be chosen by the underlying depth sensing
     * system.
     * @param {string} [options.depthSensing.dataFormatPreference] - Optional data format
     * preference for depth sensing, can be 'luminance-alpha' or 'float32'
     * (XRDEPTHSENSINGFORMAT_*), defaults to 'luminance-alpha'. Most preferred and supported will
     * be chosen by the underlying depth sensing system.
     * @example
     * button.on('click', function () {
     *     app.xr.start(camera, pc.XRTYPE_VR, pc.XRSPACE_LOCALFLOOR);
     * });
     * @example
     * button.on('click', function () {
     *     app.xr.start(camera, pc.XRTYPE_AR, pc.XRSPACE_LOCALFLOOR, {
     *         depthSensing: { }
     *     });
     * });
     */
    start(camera: CameraComponent, type: string, spaceType: string, options?: {
        optionalFeatures?: string[];
        imageTracking?: boolean;
        planeDetection?: boolean;
        callback?: XrErrorCallback;
        depthSensing?: {
            usagePreference?: string;
            dataFormatPreference?: string;
        };
    }): void;
    /**
     * @param {string} type - Session type.
     * @param {string} spaceType - Reference space type.
     * @param {*} options - Session options.
     * @param {XrErrorCallback} callback - Error callback.
     * @private
     */
    private _onStartOptionsReady;
    /**
     * Attempts to end XR session and optionally fires callback when session is ended or failed to
     * end.
     *
     * @param {XrErrorCallback} [callback] - Optional callback function called once session is
     * started. The callback has one argument Error - it is null if successfully started XR
     * session.
     * @example
     * app.keyboard.on('keydown', function (evt) {
     *     if (evt.key === pc.KEY_ESCAPE && app.xr.active) {
     *         app.xr.end();
     *     }
     * });
     */
    end(callback?: XrErrorCallback): void;
    /**
     * Check if specific type of session is available.
     *
     * @param {string} type - Session type. Can be one of the following:
     *
     * - {@link XRTYPE_INLINE}: Inline - always available type of session. It has limited features
     * availability and is rendered into HTML element.
     * - {@link XRTYPE_VR}: Immersive VR - session that provides exclusive access to VR device with
     * best available tracking features.
     * - {@link XRTYPE_AR}: Immersive AR - session that provides exclusive access to VR/AR device
     * that is intended to be blended with real-world environment.
     *
     * @example
     * if (app.xr.isAvailable(pc.XRTYPE_VR)) {
     *     // VR is available
     * }
     * @returns {boolean} True if specified session type is available.
     */
    isAvailable(type: string): boolean;
    /** @private */
    private _deviceAvailabilityCheck;
    /**
     * @param {string} type - Session type.
     * @private
     */
    private _sessionSupportCheck;
    /**
     * @param {XRSession} session - XR session.
     * @param {string} spaceType - Space type to request for the session.
     * @param {Function} callback - Callback to call when session is started.
     * @private
     */
    private _onSessionStart;
    /**
     * @param {number} near - Near plane distance.
     * @param {number} far - Far plane distance.
     * @private
     */
    private _setClipPlanes;
    /**
     * @param {*} frame - XRFrame from requestAnimationFrame callback.
     * @ignore
     */
    update(frame: any): void;
    /**
     * True if XR is supported.
     *
     * @type {boolean}
     */
    get supported(): boolean;
    /**
     * True if XR session is running.
     *
     * @type {boolean}
     */
    get active(): boolean;
    /**
     * Returns type of currently running XR session or null if no session is running. Can be any of
     * XRTYPE_*.
     *
     * @type {string|null}
     */
    get type(): string;
    /**
     * Returns reference space type of currently running XR session or null if no session is
     * running. Can be any of XRSPACE_*.
     *
     * @type {string|null}
     */
    get spaceType(): string;
    /**
     * Provides access to XRSession of WebXR.
     *
     * @type {object|null}
     */
    get session(): any;
    /**
     * Active camera for which XR session is running or null.
     *
     * @type {Entity|null}
     */
    get camera(): Entity;
    /**
     * Indicates whether WebXR content is currently visible to the user, and if it is, whether it's
     * the primary focus. Can be 'hidden', 'visible' or 'visible-blurred'.
     *
     * @type {string}
     * @ignore
     */
    get visibilityState(): string;
}

/**
 * Holds mesh batching settings and a unique id. Created via {@link BatchManager#addGroup}.
 *
 * @property {boolean} dynamic Whether objects within this batch group should support transforming
 * at runtime.
 * @property {number} maxAabbSize Maximum size of any dimension of a bounding box around batched
 * objects. {@link BatchManager#prepare} will split objects into local groups based on this size.
 * @property {number} id Unique id. Can be assigned to model and element components.
 * @property {string} name Name of the group.
 * @property {number[]} [layers] Layer ID array. Default is [{@link LAYERID_WORLD}]. The whole
 * batch group will belong to these layers. Layers of source models will be ignored.
 */
declare class BatchGroup {
    static MODEL: string;
    static ELEMENT: string;
    static SPRITE: string;
    static RENDER: string;
    /**
     * Create a new BatchGroup instance.
     *
     * @param {number} id - Unique id. Can be assigned to model and element components.
     * @param {string} name - The name of the group.
     * @param {boolean} dynamic - Whether objects within this batch group should support
     * transforming at runtime.
     * @param {number} maxAabbSize - Maximum size of any dimension of a bounding box around batched
     * objects. {@link BatchManager#prepare} will split objects into local groups based on this
     * size.
     * @param {number[]} [layers] - Layer ID array. Default is [{@link LAYERID_WORLD}]. The whole
     * batch group will belong to these layers. Layers of source models will be ignored.
     */
    constructor(id: number, name: string, dynamic: boolean, maxAabbSize: number, layers?: number[]);
    dynamic: boolean;
    maxAabbSize: number;
    id: number;
    name: string;
    layers: number[];
    _ui: boolean;
    _sprite: boolean;
    _obj: {
        model: any[];
        element: any[];
        sprite: any[];
        render: any[];
    };
}


/** @typedef {import('../mesh-instance.js').MeshInstance} MeshInstance */
/**
 * Holds information about batched mesh instances. Created in {@link BatchManager#create}.
 *
 * @property {MeshInstance[]} origMeshInstances An array of original mesh instances, from which
 * this batch was generated.
 * @property {MeshInstance} meshInstance A single combined mesh instance, the result of batching.
 * @property {boolean} dynamic Whether this batch is dynamic (supports transforming mesh instances
 * at runtime).
 * @property {number} [batchGroupId] Link this batch to a specific batch group. This is done
 * automatically with default batches.
 */
declare class Batch {
    /**
     * Create a new Batch instance.
     *
     * @param {MeshInstance[]} meshInstances - The mesh instances to be batched.
     * @param {boolean} dynamic - Whether this batch is dynamic (supports transforming mesh instances at runtime).
     * @param {number} batchGroupId - Link this batch to a specific batch group. This is done automatically with default batches.
     */
    constructor(meshInstances: MeshInstance[], dynamic: boolean, batchGroupId: number);
    origMeshInstances: MeshInstance[];
    _aabb: BoundingBox;
    meshInstance: any;
    dynamic: boolean;
    batchGroupId: number;
    destroy(scene: any, layers: any): void;
    addToLayers(scene: any, layers: any): void;
    removeFromLayers(scene: any, layers: any): void;
    updateBoundingBox(): void;
}




/**
 * Glues many mesh instances into a single one for better performance.
 */
declare class BatchManager {
    /**
     * Create a new BatchManager instance.
     *
     * @param {GraphicsDevice} device - The graphics device used by the batch manager.
     * @param {Entity} root - The entity under which batched models are added.
     * @param {Scene} scene - The scene that the batch manager affects.
     */
    constructor(device: GraphicsDevice, root: Entity, scene: Scene);
    device: GraphicsDevice;
    rootNode: Entity;
    scene: Scene;
    _init: boolean;
    _batchGroups: {};
    _batchGroupCounter: number;
    _batchList: any[];
    _dirtyGroups: any[];
    _stats: {
        createTime: number;
        updateLastFrameTime: number;
    };
    destroy(): void;
    /**
     * Adds new global batch group.
     *
     * @param {string} name - Custom name.
     * @param {boolean} dynamic - Is this batch group dynamic? Will these objects move/rotate/scale
     * after being batched?
     * @param {number} maxAabbSize - Maximum size of any dimension of a bounding box around batched
     * objects.
     * {@link BatchManager#prepare} will split objects into local groups based on this size.
     * @param {number} [id] - Optional custom unique id for the group (will be generated
     * automatically otherwise).
     * @param {number[]} [layers] - Optional layer ID array. Default is [{@link LAYERID_WORLD}].
     * The whole batch group will belong to these layers. Layers of source models will be ignored.
     * @returns {BatchGroup} Group object.
     */
    addGroup(name: string, dynamic: boolean, maxAabbSize: number, id?: number, layers?: number[]): BatchGroup;
    /**
     * Remove global batch group by id. Note, this traverses the entire scene graph and clears the
     * batch group id from all components.
     *
     * @param {number} id - Batch Group ID.
     */
    removeGroup(id: number): void;
    /**
     * Mark a specific batch group as dirty. Dirty groups are re-batched before the next frame is
     * rendered. Note, re-batching a group is a potentially expensive operation.
     *
     * @param {number} id - Batch Group ID to mark as dirty.
     */
    markGroupDirty(id: number): void;
    /**
     * Retrieves a {@link BatchGroup} object with a corresponding name, if it exists, or null
     * otherwise.
     *
     * @param {string} name - Name.
     * @returns {BatchGroup|null} The batch group matching the name or null if not found.
     */
    getGroupByName(name: string): BatchGroup | null;
    /**
     * Return a list of all {@link Batch} objects that belong to the Batch Group supplied.
     *
     * @param {number} batchGroupId - The id of the batch group.
     * @returns {Batch[]} A list of batches that are used to render the batch group.
     * @private
     */
    private getBatches;
    _removeModelsFromBatchGroup(node: any, id: any): void;
    insert(type: any, groupId: any, node: any): void;
    remove(type: any, groupId: any, node: any): void;
    _extractRender(node: any, arr: any, group: any, groupMeshInstances: any): any;
    _extractModel(node: any, arr: any, group: any, groupMeshInstances: any): any;
    _extractElement(node: any, arr: any, group: any): void;
    _collectAndRemoveMeshInstances(groupMeshInstances: any, groupIds: any): void;
    /**
     * Destroys all batches and creates new based on scene models. Hides original models. Called by
     * engine automatically on app start, and if batchGroupIds on models are changed.
     *
     * @param {number[]} [groupIds] - Optional array of batch group IDs to update. Otherwise all
     * groups are updated.
     */
    generate(groupIds?: number[]): void;
    /**
     * Takes a list of mesh instances to be batched and sorts them into lists one for each draw
     * call. The input list will be split, if:
     *
     * - Mesh instances use different materials.
     * - Mesh instances have different parameters (e.g. lightmaps or static lights).
     * - Mesh instances have different shader defines (shadow receiving, being aligned to screen
     * space, etc).
     * - Too many vertices for a single batch (65535 is maximum).
     * - Too many instances for a single batch (hardware-dependent, expect 128 on low-end and 1024
     * on high-end).
     * - Bounding box of a batch is larger than maxAabbSize in any dimension.
     *
     * @param {MeshInstance[]} meshInstances - Input list of mesh instances
     * @param {boolean} dynamic - Are we preparing for a dynamic batch? Instance count will matter
     * then (otherwise not).
     * @param {number} maxAabbSize - Maximum size of any dimension of a bounding box around batched
     * objects.
     * @param {boolean} translucent - Are we batching UI elements or sprites
     * This is useful to keep a balance between the number of draw calls and the number of drawn
     * triangles, because smaller batches can be hidden when not visible in camera.
     * @returns {MeshInstance[][]} An array of arrays of mesh instances, each valid to pass to
     * {@link BatchManager#create}.
     */
    prepare(meshInstances: MeshInstance[], dynamic: boolean, maxAabbSize: number, translucent: boolean): MeshInstance[][];
    collectBatchedMeshData(meshInstances: any, dynamic: any): {
        streams: {};
        batchNumVerts: number;
        batchNumIndices: number;
        material: any;
    };
    /**
     * Takes a mesh instance list that has been prepared by {@link BatchManager#prepare}, and
     * returns a {@link Batch} object. This method assumes that all mesh instances provided can be
     * rendered in a single draw call.
     *
     * @param {MeshInstance[]} meshInstances - Input list of mesh instances.
     * @param {boolean} dynamic - Is it a static or dynamic batch? Will objects be transformed
     * after batching?
     * @param {number} [batchGroupId] - Link this batch to a specific batch group. This is done
     * automatically with default batches.
     * @returns {Batch} The resulting batch object.
     */
    create(meshInstances: MeshInstance[], dynamic: boolean, batchGroupId?: number): Batch;
    transformVS: string;
    skinTexVS: any;
    skinConstVS: any;
    vertexFormats: {};
    /**
     * Updates bounding boxes for all dynamic batches. Called automatically.
     *
     * @ignore
     */
    updateAll(): void;
    /**
     * Clones a batch. This method doesn't rebuild batch geometry, but only creates a new model and
     * batch objects, linked to different source mesh instances.
     *
     * @param {Batch} batch - A batch object.
     * @param {MeshInstance[]} clonedMeshInstances - New mesh instances.
     * @returns {Batch} New batch object.
     */
    clone(batch: Batch, clonedMeshInstances: MeshInstance[]): Batch;
    /**
     * Removes the batch model from all layers and destroys it.
     *
     * @param {Batch} batch - A batch object.
     * @private
     */
    private destroyBatch;
}

declare class ShadowMapCache {
    shadowMapCache: Map<any, any>;
    destroy(): void;
    clear(): void;
    getKey(light: any): string;
    get(device: any, light: any): any;
    add(light: any, shadowMap: any): void;
}



/**
 * A render pass represents a node in the frame graph, and encapsulates a system which
 * renders to a render target using an execution callback.
 *
 * @ignore
 */
declare class RenderPass {
    /**
     * Creates an instance of the RenderPass.
     *
     * @param {GraphicsDevice} graphicsDevice - The graphics device.
     * @param {Function} execute - Custom function that is called when the pass needs to be
     * rendered.
     */
    constructor(graphicsDevice: GraphicsDevice, execute: Function);
    /** @type {string} */
    name: string;
    /** @type {RenderTarget} */
    renderTarget: RenderTarget;
    /**
     * Number of samples. 0 if no render target, otherwise number of samples from the render target,
     * or the main framebuffer if render target is null.
     *
     * @type {number}
     */
    samples: number;
    /** @type {ColorAttachmentOps} */
    colorOps: ColorAttachmentOps;
    /** @type {DepthStencilAttachmentOps} */
    depthStencilOps: DepthStencilAttachmentOps;
    /**
     * If true, this pass might use dynamically rendered cubemaps. Use for a case where rendering to cubemap
     * faces is interleaved with rendering to shadows, to avoid generating cubemap mipmaps. This will likely
     * be retired when render target dependency tracking gets implemented.
     *
     * @type {boolean}
     */
    requiresCubemaps: boolean;
    /**
     * True if the render pass uses the full viewport / scissor for rendering into the render target.
     *
     * @type {boolean}
     */
    fullSizeClearRect: boolean;
    device: GraphicsDevice;
    /** @type {Function} */
    execute: Function;
    /**
     * @param {RenderTarget} renderTarget - The render target to render into (output). This function should be
     * called only for render passes which use render target, or passes which render directly into the default
     * framebuffer, in which case a null or undefined render target is expected.
     */
    init(renderTarget: RenderTarget): void;
    /**
     * Mark render pass as clearing the full color buffer.
     *
     * @param {Color} color - The color to clear to.
     */
    setClearColor(color: Color): void;
    /**
     * Mark render pass as clearing the full depth buffer.
     *
     * @param {number} depthValue - The depth value to clear to.
     */
    setClearDepth(depthValue: number): void;
    /**
     * Mark render pass as clearing the full stencil buffer.
     *
     * @param {number} stencilValue - The stencil value to clear to.
     */
    setClearStencil(stencilValue: number): void;
    /**
     * Render the render pass
     */
    render(): void;
}
/** @typedef {import('../graphics/render-target.js').RenderTarget} RenderTarget */
/** @typedef {import('../graphics/graphics-device.js').GraphicsDevice} GraphicsDevice */
declare class ColorAttachmentOps {
    /**
     * A color used to clear the color attachment when the clear is enabled.
     */
    clearValue: Color;
    /**
     * True if the attachment should be cleared before rendering, false to preserve
     * the existing content.
     */
    clear: boolean;
    /**
     * True if the attachment needs to be stored after the render pass. False
     * if it can be discarded.
     * Note: This relates to the surface that is getting rendered to, and can be either
     * single or multi-sampled. Further, if a multi-sampled surface is used, the resolve
     * flag further specifies if this gets resolved to a single-sampled surface. This
     * behavior matches the WebGPU specification.
     *
     * @type {boolean}
     */
    store: boolean;
    /**
     * True if the attachment needs to be resolved.
     *
     * @type {boolean}
     */
    resolve: boolean;
    /**
     * True if the attachment needs to have mipmaps generated.
     *
     * @type {boolean}
     */
    mipmaps: boolean;
}
declare class DepthStencilAttachmentOps {
    /**
     * A depth value used to clear the depth attachment when the clear is enabled.
     */
    clearDepthValue: number;
    /**
     * A stencil value used to clear the stencil attachment when the clear is enabled.
     */
    clearStencilValue: number;
    /**
     * True if the depth attachment should be cleared before rendering, false to preserve
     * the existing content.
     */
    clearDepth: boolean;
    /**
     * True if the stencil attachment should be cleared before rendering, false to preserve
     * the existing content.
     */
    clearStencil: boolean;
    /**
     * True if the depth attachment needs to be stored after the render pass. False
     * if it can be discarded.
     *
     * @type {boolean}
     */
    storeDepth: boolean;
    /**
     * True if the stencil attachment needs to be stored after the render pass. False
     * if it can be discarded.
     *
     * @type {boolean}
     */
    storeStencil: boolean;
}



/** @typedef {import('../graphics/render-pass.js').RenderPass} RenderPass */
/** @typedef {import('../graphics/render-target.js').RenderTarget} RenderTarget */
/** @typedef {import('../graphics/texture.js').Texture} Texture */
/**
 * A frame graph represents a single rendering frame as a sequence of render passes.
 *
 * @ignore
 */
declare class FrameGraph {
    /** @type {RenderPass[]} */
    renderPasses: RenderPass[];
    /**
     * Map used during frame graph compilation. It maps a render target to its previous occurrence.
     *
     *  @type {Map<RenderTarget, RenderPass>}
     */
    renderTargetMap: Map<RenderTarget, RenderPass>;
    /**
     * Add a render pass to the frame.
     *
     * @param {RenderPass} renderPass - The render pass to add.
     */
    addRenderPass(renderPass: RenderPass): void;
    reset(): void;
    compile(): void;
    render(): void;
    log(): void;
}



/**
 * A frustum is a shape that defines the viewing space of a camera. It can be used to determine
 * visibility of points and bounding spheres. Typically, you would not create a Frustum shape
 * directly, but instead query {@link CameraComponent#frustum}.
 */
declare class Frustum {
    static getPoints(camera: any, near: any, far: any): Vec3[];
    planes: any[][];
    /**
     * Updates the frustum shape based on the supplied 4x4 matrix.
     *
     * @param {Mat4} matrix - The matrix describing the shape of the frustum.
     * @example
     * // Create a perspective projection matrix
     * var projMat = pc.Mat4();
     * projMat.setPerspective(45, 16 / 9, 1, 1000);
     *
     * // Create a frustum shape that is represented by the matrix
     * var frustum = new pc.Frustum();
     * frustum.setFromMat4(projMat);
     */
    setFromMat4(matrix: Mat4): void;
    /**
     * Tests whether a point is inside the frustum. Note that points lying in a frustum plane are
     * considered to be outside the frustum.
     *
     * @param {Vec3} point - The point to test.
     * @returns {boolean} True if the point is inside the frustum, false otherwise.
     */
    containsPoint(point: Vec3): boolean;
    /**
     * Tests whether a bounding sphere intersects the frustum. If the sphere is outside the
     * frustum, zero is returned. If the sphere intersects the frustum, 1 is returned. If the
     * sphere is completely inside the frustum, 2 is returned. Note that a sphere touching a
     * frustum plane from the outside is considered to be outside the frustum.
     *
     * @param {BoundingSphere} sphere - The sphere to test.
     * @returns {number} 0 if the bounding sphere is outside the frustum, 1 if it intersects the
     * frustum and 2 if it is contained by the frustum.
     */
    containsSphere(sphere: BoundingSphere): number;
}

/**
 * A camera.
 *
 * @ignore
 */
declare class Camera {
    _aspectRatio: number;
    _aspectRatioMode: number;
    _calculateProjection: any;
    _calculateTransform: any;
    _clearColor: Color;
    _clearColorBuffer: boolean;
    _clearDepth: number;
    _clearDepthBuffer: boolean;
    _clearStencil: number;
    _clearStencilBuffer: boolean;
    _cullingMask: number;
    _cullFaces: boolean;
    _farClip: number;
    _flipFaces: boolean;
    _fov: number;
    _frustumCulling: boolean;
    _horizontalFov: boolean;
    _layers: number[];
    _nearClip: number;
    _node: any;
    _orthoHeight: number;
    _projection: number;
    _rect: Vec4;
    _renderTarget: any;
    _scissorRect: Vec4;
    _scissorRectClear: boolean;
    _projMat: Mat4;
    _projMatDirty: boolean;
    _projMatSkybox: Mat4;
    _viewMat: Mat4;
    _viewMatDirty: boolean;
    _viewProjMat: Mat4;
    _viewProjMatDirty: boolean;
    frustum: Frustum;
    /**
     * True if the camera clears the full render target. (viewport / scissor are full size)
     */
    get fullSizeClearRect(): boolean;
    set aspectRatio(arg: number);
    get aspectRatio(): number;
    set aspectRatioMode(arg: number);
    get aspectRatioMode(): number;
    set calculateProjection(arg: any);
    get calculateProjection(): any;
    set calculateTransform(arg: any);
    get calculateTransform(): any;
    set clearColor(arg: Color);
    get clearColor(): Color;
    set clearColorBuffer(arg: boolean);
    get clearColorBuffer(): boolean;
    set clearDepth(arg: number);
    get clearDepth(): number;
    set clearDepthBuffer(arg: boolean);
    get clearDepthBuffer(): boolean;
    set clearStencil(arg: number);
    get clearStencil(): number;
    set clearStencilBuffer(arg: boolean);
    get clearStencilBuffer(): boolean;
    set cullingMask(arg: number);
    get cullingMask(): number;
    set cullFaces(arg: boolean);
    get cullFaces(): boolean;
    set farClip(arg: number);
    get farClip(): number;
    set flipFaces(arg: boolean);
    get flipFaces(): boolean;
    set fov(arg: number);
    get fov(): number;
    set frustumCulling(arg: boolean);
    get frustumCulling(): boolean;
    set horizontalFov(arg: boolean);
    get horizontalFov(): boolean;
    set layers(arg: number[]);
    get layers(): number[];
    set nearClip(arg: number);
    get nearClip(): number;
    set node(arg: any);
    get node(): any;
    set orthoHeight(arg: number);
    get orthoHeight(): number;
    set projection(arg: number);
    get projection(): number;
    get projectionMatrix(): Mat4;
    set rect(arg: Vec4);
    get rect(): Vec4;
    set renderTarget(arg: any);
    get renderTarget(): any;
    set scissorRect(arg: Vec4);
    get scissorRect(): Vec4;
    get viewMatrix(): Mat4;
    /**
     * Creates a duplicate of the camera.
     *
     * @returns {Camera} A cloned Camera.
     */
    clone(): Camera;
    /**
     * Copies one camera to another.
     *
     * @param {Camera} other - Camera to copy.
     * @returns {Camera} Self for chaining.
     */
    copy(other: Camera): Camera;
    _updateViewProjMat(): void;
    /**
     * Convert a point from 3D world space to 2D canvas pixel space.
     *
     * @param {Vec3} worldCoord - The world space coordinate to transform.
     * @param {number} cw - The width of PlayCanvas' canvas element.
     * @param {number} ch - The height of PlayCanvas' canvas element.
     * @param {Vec3} [screenCoord] - 3D vector to receive screen coordinate result.
     * @returns {Vec3} The screen space coordinate.
     */
    worldToScreen(worldCoord: Vec3, cw: number, ch: number, screenCoord?: Vec3): Vec3;
    /**
     * Convert a point from 2D canvas pixel space to 3D world space.
     *
     * @param {number} x - X coordinate on PlayCanvas' canvas element.
     * @param {number} y - Y coordinate on PlayCanvas' canvas element.
     * @param {number} z - The distance from the camera in world space to create the new point.
     * @param {number} cw - The width of PlayCanvas' canvas element.
     * @param {number} ch - The height of PlayCanvas' canvas element.
     * @param {Vec3} [worldCoord] - 3D vector to receive world coordinate result.
     * @returns {Vec3} The world space coordinate.
     */
    screenToWorld(x: number, y: number, z: number, cw: number, ch: number, worldCoord?: Vec3): Vec3;
    _evaluateProjectionMatrix(): void;
    getProjectionMatrixSkybox(): Mat4;
    getScreenSize(sphere: any): number;
}

declare class ShadowMap {
    static getShadowFormat(device: any, shadowType: any): number;
    static getShadowFiltering(device: any, shadowType: any): number;
    static create(device: any, light: any): ShadowMap;
    static createAtlas(device: any, resolution: any, shadowType: any): ShadowMap;
    static create2dMap(device: any, size: any, shadowType: any): ShadowMap;
    static createCubemap(device: any, size: any): ShadowMap;
    constructor(texture: any, targets: any);
    texture: any;
    cached: boolean;
    renderTargets: any;
    destroy(): void;
}

declare class LightTextureAtlas {
    constructor(device: any);
    device: any;
    version: number;
    shadowAtlasResolution: number;
    shadowAtlas: ShadowMap;
    shadowEdgePixels: number;
    cookieAtlasResolution: number;
    cookieAtlas: Texture;
    cookieRenderTarget: RenderTarget;
    slots: any[];
    atlasSplit: any[];
    cubeSlotsOffsets: Vec2[];
    scissorVec: Vec4;
    destroy(): void;
    destroyShadowAtlas(): void;
    destroyCookieAtlas(): void;
    allocateShadowAtlas(resolution: any): void;
    allocateCookieAtlas(resolution: any): void;
    allocateUniforms(): void;
    _shadowAtlasTextureId: any;
    _shadowAtlasParamsId: any;
    _shadowAtlasParams: Float32Array;
    _cookieAtlasTextureId: any;
    updateUniforms(): void;
    subdivide(numLights: any, lightingParams: any): void;
    collectLights(spotLights: any, omniLights: any, lightingParams: any): any[];
    setupSlot(light: any, rect: any): void;
    assignSlot(light: any, slotIndex: any, slotReassigned: any): void;
    update(spotLights: any, omniLights: any, lightingParams: any): void;
}





/**
 * @ignore
 */
declare class ShadowRenderer {
    static createShadowCamera(device: any, shadowType: any, type: any, face: any): Camera;
    static setShadowCameraSettings(shadowCam: any, device: any, shadowType: any, type: any, isClustered: any): void;
    /**
     * @param {ForwardRenderer} forwardRenderer - The forward renderer.
     * @param {LightTextureAtlas} lightTextureAtlas - The shadow map atlas.
     */
    constructor(forwardRenderer: ForwardRenderer, lightTextureAtlas: LightTextureAtlas);
    device: GraphicsDevice;
    /** @type {ForwardRenderer} */
    forwardRenderer: ForwardRenderer;
    /** @type {LightTextureAtlas} */
    lightTextureAtlas: LightTextureAtlas;
    polygonOffsetId: ScopeId;
    polygonOffset: Float32Array;
    sourceId: ScopeId;
    pixelOffsetId: ScopeId;
    weightId: ScopeId;
    blurVsmShaderCode: any[];
    blurPackedVsmShaderCode: string[];
    blurVsmShader: {}[];
    blurPackedVsmShader: {}[];
    blurVsmWeights: {};
    shadowMapLightRadiusId: ScopeId;
    shadowMapCache: ShadowMapCache;
    destroy(): void;
    cullShadowCasters(meshInstances: any, visible: any, camera: any): void;
    cullLocal(light: any, drawCalls: any): void;
    generateSplitDistances(light: any, nearDist: any, farDist: any): void;
    cullDirectional(light: any, drawCalls: any, camera: any): void;
    setupRenderState(device: any, light: any): void;
    restoreRenderState(device: any): void;
    dispatchUniforms(light: any, shadowCam: any, lightRenderData: any, face: any): void;
    /**
     * @param {MeshInstance[]} visibleCasters - Visible mesh instances.
     * @param {Light} light - The light.
     */
    submitCasters(visibleCasters: MeshInstance[], light: Light): void;
    render(light: any, camera: any): void;
    getVsmBlurShader(isVsm8: any, blurMode: any, filterSize: any): any;
    applyVsmBlur(light: any, camera: any): void;
}

declare class CookieRenderer {
    static createTexture(device: any, resolution: any): Texture;
    static _invViewProjMatrices: any;
    constructor(device: any, lightTextureAtlas: any);
    device: any;
    lightTextureAtlas: any;
    blitShader2d: any;
    blitShaderCube: any;
    blitTextureId: any;
    invViewProjId: any;
    destroy(): void;
    getShader(shader: any, fragment: any): any;
    get shader2d(): any;
    get shaderCube(): any;
    initInvViewProjMatrices(): void;
    render(light: any, renderTarget: any): void;
}









/**
 * The forward renderer renders {@link Scene}s.
 *
 * @ignore
 */
declare class ForwardRenderer {
    static skipRenderCamera: any;
    static _skipRenderCounter: number;
    static skipRenderAfter: number;
    /**
     * Create a new ForwardRenderer instance.
     *
     * @param {GraphicsDevice} graphicsDevice - The graphics device used by the renderer.
     * @hideconstructor
     */
    constructor(graphicsDevice: GraphicsDevice);
    /** @type {boolean} */
    clustersDebugRendered: boolean;
    device: GraphicsDevice;
    /** @type {Scene|null} */
    scene: Scene | null;
    _shadowDrawCalls: number;
    _forwardDrawCalls: number;
    _skinDrawCalls: number;
    _numDrawCallsCulled: number;
    _instancedDrawCalls: number;
    _camerasRendered: number;
    _materialSwitches: number;
    _shadowMapUpdates: number;
    _shadowMapTime: number;
    _depthMapTime: number;
    _forwardTime: number;
    _cullTime: number;
    _sortTime: number;
    _skinTime: number;
    _morphTime: number;
    _layerCompositionUpdateTime: number;
    _lightClustersTime: number;
    _lightClusters: number;
    library: ProgramLibrary;
    lightTextureAtlas: LightTextureAtlas;
    _shadowRenderer: ShadowRenderer;
    _cookieRenderer: CookieRenderer;
    projId: ScopeId;
    projSkyboxId: ScopeId;
    viewId: ScopeId;
    viewId3: ScopeId;
    viewInvId: ScopeId;
    viewProjId: ScopeId;
    flipYId: ScopeId;
    viewPos: Float32Array;
    viewPosId: ScopeId;
    nearClipId: ScopeId;
    farClipId: ScopeId;
    cameraParamsId: ScopeId;
    tbnBasis: ScopeId;
    fogColorId: ScopeId;
    fogStartId: ScopeId;
    fogEndId: ScopeId;
    fogDensityId: ScopeId;
    modelMatrixId: ScopeId;
    normalMatrixId: ScopeId;
    poseMatrixId: ScopeId;
    boneTextureId: ScopeId;
    boneTextureSizeId: ScopeId;
    morphWeightsA: ScopeId;
    morphWeightsB: ScopeId;
    morphPositionTex: ScopeId;
    morphNormalTex: ScopeId;
    morphTexParams: ScopeId;
    alphaTestId: ScopeId;
    opacityMapId: ScopeId;
    ambientId: ScopeId;
    exposureId: ScopeId;
    skyboxIntensityId: ScopeId;
    lightColorId: any[];
    lightDir: any[];
    lightDirId: any[];
    lightShadowMapId: any[];
    lightShadowMatrixId: any[];
    lightShadowParamsId: any[];
    lightShadowIntensity: any[];
    lightRadiusId: any[];
    lightPos: any[];
    lightPosId: any[];
    lightWidth: any[];
    lightWidthId: any[];
    lightHeight: any[];
    lightHeightId: any[];
    lightInAngleId: any[];
    lightOutAngleId: any[];
    lightCookieId: any[];
    lightCookieIntId: any[];
    lightCookieMatrixId: any[];
    lightCookieOffsetId: any[];
    shadowMatrixPaletteId: any[];
    shadowCascadeDistancesId: any[];
    shadowCascadeCountId: any[];
    screenSizeId: ScopeId;
    _screenSize: Float32Array;
    twoSidedLightingNegScaleFactorId: ScopeId;
    fogColor: Float32Array;
    ambientColor: Float32Array;
    cameraParams: Float32Array;
    viewUniformFormat: UniformBufferFormat;
    viewBindGroupFormat: BindGroupFormat;
    destroy(): void;
    sortCompare(drawCallA: any, drawCallB: any): number;
    sortCompareMesh(drawCallA: any, drawCallB: any): number;
    depthSortCompare(drawCallA: any, drawCallB: any): number;
    updateCameraFrustum(camera: any): void;
    initViewBindGroupFormat(): void;
    setCameraUniforms(camera: any, target: any, renderAction: any): void;
    setCamera(camera: any, target: any, clear: any, renderAction?: any): void;
    setupViewUniformBuffers(renderAction: any, viewCount: any): void;
    /**
     * Set up the viewport and the scissor for camera rendering.
     *
     * @param {Camera} camera - The camera containing the viewport infomation.
     * @param {RenderTarget} [renderTarget] - The render target. NULL for the default one.
     */
    setupViewport(camera: Camera, renderTarget?: RenderTarget): void;
    /**
     * Clear the current render target, using currently set up viewport.
     *
     * @param {RenderAction} renderAction - Render action containing the clear flags.
     * @param {Camera} camera - Camera containing the clear values.
     */
    clear(renderAction: RenderAction, camera: Camera): void;
    clearView(camera: any, target: any, clear: any, forceWrite: any): void;
    /**
     * @param {Scene} scene - The scene.
     */
    dispatchGlobalLights(scene: Scene): void;
    _resolveLight(scope: any, i: any): void;
    setLTCDirectionalLight(wtm: any, cnt: any, dir: any, campos: any, far: any): void;
    dispatchDirectLights(dirs: any, scene: any, mask: any, camera: any): number;
    setLTCPositionalLight(wtm: any, cnt: any): void;
    dispatchOmniLight(scene: any, scope: any, omni: any, cnt: any): void;
    dispatchSpotLight(scene: any, scope: any, spot: any, cnt: any): void;
    dispatchLocalLights(sortedLights: any, scene: any, mask: any, usedDirLights: any, staticLightList: any): void;
    cull(camera: any, drawCalls: any, visibleList: any): number;
    cullLights(camera: any, lights: any): void;
    updateCpuSkinMatrices(drawCalls: any): void;
    updateGpuSkinMatrices(drawCalls: any): void;
    updateMorphing(drawCalls: any): void;
    setBaseConstants(device: any, material: any): void;
    setSkinning(device: any, meshInstance: any, material: any): void;
    drawInstance(device: any, meshInstance: any, mesh: any, style: any, normal: any): void;
    drawInstance2(device: any, meshInstance: any, mesh: any, style: any): void;
    renderShadows(lights: any, camera: any): void;
    renderCookies(lights: any): void;
    setCullMode(cullFaces: any, flip: any, drawCall: any): void;
    setVertexBuffers(device: any, mesh: any): void;
    setMorphing(device: any, morphInstance: any): void;
    dispatchViewPos(position: any): void;
    renderForwardPrepareMaterials(camera: any, drawCalls: any, drawCallsCount: any, sortedLights: any, cullingMask: any, layer: any, pass: any): {
        drawCalls: any[];
        isNewMaterial: any[];
        lightMaskChanged: any[];
    };
    renderForward(camera: any, allDrawCalls: any, allDrawCallsCount: any, sortedLights: any, pass: any, cullingMask: any, drawCallback: any, layer: any, flipFaces: any): void;
    /**
     * @param {MeshInstance[]} drawCalls - Mesh instances.
     * @param {boolean} onlyLitShaders - Limits the update to shaders affected by lighting.
     */
    updateShaders(drawCalls: MeshInstance[], onlyLitShaders: boolean): void;
    /**
     * @param {LayerComposition} comp - The layer composition to update.
     * @param {boolean} lightsChanged - True if lights of the composition has changed.
     */
    beginFrame(comp: LayerComposition, lightsChanged: boolean): void;
    /**
     * Updates the layer composition for rendering.
     *
     * @param {LayerComposition} comp - The layer composition to update.
     * @param {boolean} clusteredLightingEnabled - True if clustered lighting is enabled.
     * @returns {number} - Flags of what was updated
     * @ignore
     */
    updateLayerComposition(comp: LayerComposition, clusteredLightingEnabled: boolean): number;
    gpuUpdate(drawCalls: any): void;
    setSceneConstants(): void;
    /**
     * @param {LayerComposition} comp - The layer composition.
     * @param {number} compUpdatedFlags - Flags of what was updated.
     */
    updateLightStats(comp: LayerComposition, compUpdatedFlags: number): void;
    /**
     * Shadow map culling for directional and visible local lights
     * visible meshInstances are collected into light._renderData, and are marked as visible
     * for directional lights also shadow camera matrix is set up
     *
     * @param {LayerComposition} comp - The layer composition.
     */
    cullShadowmaps(comp: LayerComposition): void;
    /**
     * visibility culling of lights, meshInstances, shadows casters
     * Also applies meshInstance.visible and camera.cullingMask
     *
     * @param {LayerComposition} comp - The layer composition.
     */
    cullComposition(comp: LayerComposition): void;
    /**
     * @param {LayerComposition} comp - The layer composition.
     */
    updateLightTextureAtlas(comp: LayerComposition): void;
    /**
     * @param {LayerComposition} comp - The layer composition.
     */
    updateClusters(comp: LayerComposition): void;
    /**
     * Builds a frame graph for the rendering of the whole frame.
     *
     * @param {FrameGraph} frameGraph - The frame-graph that is built.
     * @param {LayerComposition} layerComposition - The layer composition used to build the frame graph.
     * @ignore
     */
    buildFrameGraph(frameGraph: FrameGraph, layerComposition: LayerComposition): void;
    /**
     * @param {FrameGraph} frameGraph - The frame graph
     * @param {LayerComposition} layerComposition - The layer composition.
     */
    addMainRenderPass(frameGraph: FrameGraph, layerComposition: LayerComposition, renderTarget: any, startIndex: any, endIndex: any, isGrabPass: any): void;
    /**
     * @param {LayerComposition} comp - The layer composition.
     */
    update(comp: LayerComposition): void;
    /**
     * Render pass for directional shadow maps of the camera.
     *
     * @param {RenderAction} renderAction - The render action.
     * @param {LayerComposition} layerComposition - The layer composition.
     * @ignore
     */
    renderPassDirectionalShadows(renderAction: RenderAction, layerComposition: LayerComposition): void;
    renderPassPostprocessing(renderAction: any, layerComposition: any): void;
    /**
     * Render pass representing the layer composition's render actions in the specified range.
     *
     * @param {LayerComposition} comp - the layer composition to render.
     * @ignore
     */
    renderPassRenderActions(comp: LayerComposition, range: any): void;
    /**
     * @param {LayerComposition} comp - The layer composition.
     * @param {RenderAction} renderAction - The render action.
     * @param {boolean} firstRenderAction - True if this is the first render action in the render pass.
     */
    renderRenderAction(comp: LayerComposition, renderAction: RenderAction, firstRenderAction: boolean): void;
}

declare class LightmapFilters {
    constructor(device: any);
    device: any;
    shaderDilate: Shader;
    constantTexSource: any;
    constantPixelOffset: any;
    pixelOffset: Float32Array;
    shaderDenoise: Shader;
    sigmas: Float32Array;
    constantSigmas: any;
    kernel: any;
    setSourceTexture(texture: any): void;
    prepare(textureWidth: any, textureHeight: any): void;
    prepareDenoise(filterRange: any, filterSmoothness: any): void;
    constantKernel: any;
    bZnorm: any;
    evaluateDenoiseUniforms(filterRange: any, filterSmoothness: any): void;
}






/**
 * The lightmapper is used to bake scene lights into textures.
 */
declare class Lightmapper {
    /**
     * Create a new Lightmapper instance.
     *
     * @param {GraphicsDevice} device - The graphics device used by the lightmapper.
     * @param {Entity} root - The root entity of the scene.
     * @param {Scene} scene - The scene to lightmap.
     * @param {ForwardRenderer} renderer - The renderer.
     * @param {AssetRegistry} assets - Registry of assets to lightmap.
     * @hideconstructor
     */
    constructor(device: GraphicsDevice, root: Entity, scene: Scene, renderer: ForwardRenderer, assets: AssetRegistry);
    device: GraphicsDevice;
    root: Entity;
    scene: Scene;
    renderer: ForwardRenderer;
    assets: AssetRegistry;
    shadowMapCache: ShadowMapCache;
    _tempSet: Set<any>;
    _initCalled: boolean;
    passMaterials: any[];
    ambientAOMaterial: StandardMaterial;
    fog: string;
    ambientLight: Color;
    renderTargets: Map<any, any>;
    stats: {
        renderPasses: number;
        lightmapCount: number;
        totalRenderTime: number;
        forwardTime: number;
        fboTime: number;
        shadowMapTime: number;
        compileTime: number;
        shadersLinked: number;
    };
    destroy(): void;
    blackTex: Texture;
    initBake(device: any): void;
    lightmapFilters: LightmapFilters;
    constantBakeDir: any;
    materials: any[];
    camera: Camera;
    lightingParams: LightingParams;
    worldClusters: WorldClusters;
    finishBake(bakeNodes: any): void;
    createMaterialForPass(device: any, scene: any, pass: any, addAmbient: any): StandardMaterial;
    createMaterials(device: any, scene: any, passCount: any): void;
    createTexture(size: any, type: any, name: any): Texture;
    collectModels(node: any, bakeNodes: any, allNodes: any): void;
    prepareShadowCasters(nodes: any): any[];
    updateTransforms(nodes: any): void;
    calculateLightmapSize(node: any): number;
    setLightmapping(nodes: any, value: any, passCount: any, shaderDefs: any): void;
    /**
     * Generates and applies the lightmaps.
     *
     * @param {Entity[]|null} nodes - An array of entities (with model or render components) to
     * render lightmaps for. If not supplied, the entire scene will be baked.
     * @param {number} [mode] - Baking mode. Can be:
     *
     * - {@link BAKE_COLOR}: single color lightmap
     * - {@link BAKE_COLORDIR}: single color lightmap + dominant light direction (used for
     * bump/specular)
     *
     * Only lights with bakeDir=true will be used for generating the dominant light direction.
     * Defaults to {@link BAKE_COLORDIR}.
     */
    bake(nodes: Entity[] | null, mode?: number): void;
    allocateTextures(bakeNodes: any, passCount: any): void;
    prepareLightsToBake(layerComposition: any, allLights: any, bakeLights: any): void;
    restoreLights(allLights: any): void;
    setupScene(): void;
    revertStatic: boolean;
    restoreScene(): void;
    computeNodeBounds(meshInstances: any): BoundingBox;
    computeNodesBounds(nodes: any): void;
    computeBounds(meshInstances: any): BoundingBox;
    backupMaterials(meshInstances: any): void;
    restoreMaterials(meshInstances: any): void;
    lightCameraPrepare(device: any, bakeLight: any): any;
    lightCameraPrepareAndCull(bakeLight: any, bakeNode: any, shadowCam: any, casterBounds: any): boolean;
    setupLightArray(lightArray: any, light: any): void;
    renderShadowMap(shadowMapRendered: any, casters: any, lightArray: any, bakeLight: any): boolean;
    postprocessTextures(device: any, bakeNodes: any, passCount: any): void;
    bakeInternal(passCount: any, bakeNodes: any, allNodes: any): void;
}

/**
 * Attach a TouchDevice to an element and it will receive and fire events when the element is
 * touched. See also {@link Touch} and {@link TouchEvent}.
 *
 * @augments EventHandler
 */
declare class TouchDevice extends EventHandler {
    /**
     * Create a new touch device and attach it to an element.
     *
     * @param {Element} element - The element to attach listen for events on.
     */
    constructor(element: Element);
    _element: Element;
    _startHandler: any;
    _endHandler: any;
    _moveHandler: any;
    _cancelHandler: any;
    /**
     * Attach a device to an element in the DOM. If the device is already attached to an element
     * this method will detach it first.
     *
     * @param {Element} element - The element to attach to.
     */
    attach(element: Element): void;
    /**
     * Detach a device from the element it is attached to.
     */
    detach(): void;
    _handleTouchStart(e: any): void;
    _handleTouchEnd(e: any): void;
    _handleTouchMove(e: any): void;
    _handleTouchCancel(e: any): void;
}

/**
 * Callback used by {@link MouseenablePointerLock } and {@link ApplicationdisablePointerLock }.
 */
export type LockMouseCallback = () => any;
/**
 * Callback used by {@link Mouse#enablePointerLock} and {@link Application#disablePointerLock}.
 *
 * @callback LockMouseCallback
 */
/**
 * A Mouse Device, bound to a DOM Element.
 *
 * @augments EventHandler
 */
declare class Mouse extends EventHandler {
    /**
     * Fired when the mouse is moved.
     *
     * @event Mouse#mousemove
     * @param {MouseEvent} event - The MouseEvent object.
     */
    /**
     * Fired when a mouse button is pressed.
     *
     * @event Mouse#mousedown
     * @param {MouseEvent} event - The MouseEvent object.
     */
    /**
     * Fired when a mouse button is released.
     *
     * @event Mouse#mouseup
     * @param {MouseEvent} event - The MouseEvent object.
     */
    /**
     * Fired when a mouse wheel is moved.
     *
     * @event Mouse#mousewheel
     * @param {MouseEvent} event - The MouseEvent object.
     */
    /**
     * Check if the mouse pointer has been locked, using {@link Mouse#enabledPointerLock}.
     *
     * @returns {boolean} True if locked.
     */
    static isPointerLocked(): boolean;
    /**
     * Create a new Mouse instance.
     *
     * @param {Element} [element] - The Element that the mouse events are attached to.
     */
    constructor(element?: Element);
    _lastX: number;
    _lastY: number;
    _buttons: boolean[];
    _lastbuttons: boolean[];
    _upHandler: any;
    _downHandler: any;
    _moveHandler: any;
    _wheelHandler: any;
    _contextMenuHandler: (event: any) => void;
    _target: Element;
    _attached: boolean;
    /**
     * Attach mouse events to an Element.
     *
     * @param {Element} element - The DOM element to attach the mouse to.
     */
    attach(element: Element): void;
    /**
     * Remove mouse events from the element that it is attached to.
     */
    detach(): void;
    /**
     * Disable the context menu usually activated with right-click.
     */
    disableContextMenu(): void;
    /**
     * Enable the context menu usually activated with right-click. This option is active by
     * default.
     */
    enableContextMenu(): void;
    /**
     * Request that the browser hides the mouse cursor and locks the mouse to the element. Allowing
     * raw access to mouse movement input without risking the mouse exiting the element. Notes:
     *
     * - In some browsers this will only work when the browser is running in fullscreen mode. See
     * {@link Application#enableFullscreen}
     * - Enabling pointer lock can only be initiated by a user action e.g. in the event handler for
     * a mouse or keyboard input.
     *
     * @param {LockMouseCallback} [success] - Function called if the request for mouse lock is
     * successful.
     * @param {LockMouseCallback} [error] - Function called if the request for mouse lock is
     * unsuccessful.
     */
    enablePointerLock(success?: LockMouseCallback, error?: LockMouseCallback): void;
    /**
     * Return control of the mouse cursor to the user.
     *
     * @param {LockMouseCallback} [success] - Function called when the mouse lock is disabled.
     */
    disablePointerLock(success?: LockMouseCallback): void;
    /**
     * Update method, should be called once per frame.
     */
    update(): void;
    /**
     * Returns true if the mouse button is currently pressed.
     *
     * @param {number} button - The mouse button to test. Can be:
     *
     * - {@link MOUSEBUTTON_LEFT}
     * - {@link MOUSEBUTTON_MIDDLE}
     * - {@link MOUSEBUTTON_RIGHT}
     *
     * @returns {boolean} True if the mouse button is current pressed.
     */
    isPressed(button: number): boolean;
    /**
     * Returns true if the mouse button was pressed this frame (since the last call to update).
     *
     * @param {number} button - The mouse button to test. Can be:
     *
     * - {@link MOUSEBUTTON_LEFT}
     * - {@link MOUSEBUTTON_MIDDLE}
     * - {@link MOUSEBUTTON_RIGHT}
     *
     * @returns {boolean} True if the mouse button was pressed since the last update.
     */
    wasPressed(button: number): boolean;
    /**
     * Returns true if the mouse button was released this frame (since the last call to update).
     *
     * @param {number} button - The mouse button to test. Can be:
     *
     * - {@link MOUSEBUTTON_LEFT}
     * - {@link MOUSEBUTTON_MIDDLE}
     * - {@link MOUSEBUTTON_RIGHT}
     *
     * @returns {boolean} True if the mouse button was released since the last update.
     */
    wasReleased(button: number): boolean;
    _handleUp(event: any): void;
    _handleDown(event: any): void;
    _handleMove(event: any): void;
    _handleWheel(event: any): void;
    _getTargetCoords(event: any): {
        x: number;
        y: number;
    };
}

/**
 * A Keyboard device bound to an Element. Allows you to detect the state of the key presses. Note
 * that the Keyboard object must be attached to an Element before it can detect any key presses.
 *
 * @augments EventHandler
 */
declare class Keyboard extends EventHandler {
    /**
     * Create a new Keyboard instance.
     *
     * @param {Element|Window} [element] - Element to attach Keyboard to. Note that elements like
     * &lt;div&gt; can't accept focus by default. To use keyboard events on an element like this it
     * must have a value of 'tabindex' e.g. tabindex="0". See
     * [here](http://www.w3.org/WAI/GL/WCAG20/WD-WCAG20-TECHS/SCR29.html) for more details.
     * @param {object} [options] - Optional options object.
     * @param {boolean} [options.preventDefault] - Call preventDefault() in key event handlers.
     * This stops the default action of the event occurring. e.g. Ctrl+T will not open a new
     * browser tab.
     * @param {boolean} [options.stopPropagation] - Call stopPropagation() in key event handlers.
     * This stops the event bubbling up the DOM so no parent handlers will be notified of the
     * event.
     * @example
     * // attach keyboard listeners to the window
     * var keyboard = new pc.Keyboard(window);
     */
    constructor(element?: Element | Window, options?: {
        preventDefault?: boolean;
        stopPropagation?: boolean;
    });
    _element: Element | Window;
    _keyDownHandler: any;
    _keyUpHandler: any;
    _keyPressHandler: any;
    _visibilityChangeHandler: any;
    _windowBlurHandler: any;
    _keymap: {};
    _lastmap: {};
    preventDefault: boolean;
    stopPropagation: boolean;
    /**
     * Fired when a key is pressed.
     *
     * @event Keyboard#keydown
     * @param {KeyboardEvent} event - The Keyboard event object. Note, this event is only valid for the current callback.
     * @example
     * var onKeyDown = function (e) {
     *     if (e.key === pc.KEY_SPACE) {
     *         // space key pressed
     *     }
     *     e.event.preventDefault(); // Use original browser event to prevent browser action.
     * };
     * app.keyboard.on("keydown", onKeyDown, this);
     */
    /**
     * Fired when a key is released.
     *
     * @event Keyboard#keyup
     * @param {KeyboardEvent} event - The Keyboard event object. Note, this event is only valid for the current callback.
     * @example
     * var onKeyUp = function (e) {
     *     if (e.key === pc.KEY_SPACE) {
     *         // space key released
     *     }
     *     e.event.preventDefault(); // Use original browser event to prevent browser action.
     * };
     * app.keyboard.on("keyup", onKeyUp, this);
     */
    /**
     * Attach the keyboard event handlers to an Element.
     *
     * @param {Element|Window} element - The element to listen for keyboard events on.
     */
    attach(element: Element | Window): void;
    /**
     * Detach the keyboard event handlers from the element it is attached to.
     */
    detach(): void;
    /**
     * Convert a key code into a key identifier.
     *
     * @param {number} keyCode - The key code.
     * @returns {string} The key identifier.
     * @private
     */
    private toKeyIdentifier;
    /**
     * Process the browser keydown event.
     *
     * @param {globalThis.KeyboardEvent} event - The browser keyboard event.
     * @private
     */
    private _handleKeyDown;
    /**
     * Process the browser keyup event.
     *
     * @param {globalThis.KeyboardEvent} event - The browser keyboard event.
     * @private
     */
    private _handleKeyUp;
    /**
     * Process the browser keypress event.
     *
     * @param {globalThis.KeyboardEvent} event - The browser keyboard event.
     * @private
     */
    private _handleKeyPress;
    /**
     * Handle the browser visibilitychange event.
     *
     * @private
     */
    private _handleVisibilityChange;
    /**
     * Handle the browser blur event.
     *
     * @private
     */
    private _handleWindowBlur;
    /**
     * Called once per frame to update internal state.
     *
     * @ignore
     */
    update(): void;
    /**
     * Return true if the key is currently down.
     *
     * @param {number} key - The keyCode of the key to test. See the KEY_* constants.
     * @returns {boolean} True if the key was pressed, false if not.
     */
    isPressed(key: number): boolean;
    /**
     * Returns true if the key was pressed since the last update.
     *
     * @param {number} key - The keyCode of the key to test. See the KEY_* constants.
     * @returns {boolean} True if the key was pressed.
     */
    wasPressed(key: number): boolean;
    /**
     * Returns true if the key was released since the last update.
     *
     * @param {number} key - The keyCode of the key to test. See the KEY_* constants.
     * @returns {boolean} True if the key was pressed.
     */
    wasReleased(key: number): boolean;
}

/**
 * Input handler for accessing GamePad input.
 */
declare class GamePads {
    gamepadsSupported: boolean;
    current: any[];
    previous: any[];
    deadZone: number;
    /**
     * Update the current and previous state of the gamepads. This must be called every frame for
     * `wasPressed` to work.
     */
    update(): void;
    /**
     * Poll for the latest data from the gamepad API.
     *
     * @param {object[]} [pads] - An optional array used to receive the gamepads mapping. This
     * array will be returned by this function.
     * @returns {object[]} An array of gamepads and mappings for the model of gamepad that is
     * attached.
     * @example
     * var gamepads = new pc.GamePads();
     * var pads = gamepads.poll();
     */
    poll(pads?: object[]): object[];
    getMap(pad: any): any;
    /**
     * Returns true if the button on the pad requested is pressed.
     *
     * @param {number} index - The index of the pad to check, use constants {@link PAD_1},
     * {@link PAD_2}, etc.
     * @param {number} button - The button to test, use constants {@link PAD_FACE_1}, etc.
     * @returns {boolean} True if the button is pressed.
     */
    isPressed(index: number, button: number): boolean;
    /**
     * Returns true if the button was pressed since the last frame.
     *
     * @param {number} index - The index of the pad to check, use constants {@link PAD_1},
     * {@link PAD_2}, etc.
     * @param {number} button - The button to test, use constants {@link PAD_FACE_1}, etc.
     * @returns {boolean} True if the button was pressed since the last frame.
     */
    wasPressed(index: number, button: number): boolean;
    /**
     * Returns true if the button was released since the last frame.
     *
     * @param {number} index - The index of the pad to check, use constants {@link PAD_1},
     * {@link PAD_2}, etc.
     * @param {number} button - The button to test, use constants {@link PAD_FACE_1}, etc.
     * @returns {boolean} True if the button was released since the last frame.
     */
    wasReleased(index: number, button: number): boolean;
    /**
     * Get the value of one of the analogue axes of the pad.
     *
     * @param {number} index - The index of the pad to check, use constants {@link PAD_1},
     * {@link PAD_2}, etc.
     * @param {number} axes - The axes to get the value of, use constants {@link PAD_L_STICK_X},
     * etc.
     * @returns {number} The value of the axis between -1 and 1.
     */
    getAxis(index: number, axes: number): number;
}




/**
 * Handles mouse and touch events for {@link ElementComponent}s. When input events occur on an
 * ElementComponent this fires the appropriate events on the ElementComponent.
 */
declare class ElementInput {
    /**
     * Create a new ElementInput instance.
     *
     * @param {Element} domElement - The DOM element.
     * @param {object} [options] - Optional arguments.
     * @param {boolean} [options.useMouse] - Whether to allow mouse input. Defaults to true.
     * @param {boolean} [options.useTouch] - Whether to allow touch input. Defaults to true.
     * @param {boolean} [options.useXr] - Whether to allow XR input sources. Defaults to true.
     */
    constructor(domElement: Element, options?: {
        useMouse?: boolean;
        useTouch?: boolean;
        useXr?: boolean;
    });
    _app: any;
    _attached: boolean;
    _target: Element;
    _enabled: boolean;
    _lastX: number;
    _lastY: number;
    _upHandler: any;
    _downHandler: any;
    _moveHandler: any;
    _wheelHandler: any;
    _touchstartHandler: any;
    _touchendHandler: any;
    _touchcancelHandler: any;
    _touchmoveHandler: any;
    _sortHandler: any;
    _elements: any[];
    _hoveredElement: any;
    _pressedElement: any;
    _touchedElements: {};
    _touchesForWhichTouchLeaveHasFired: {};
    _selectedElements: {};
    _selectedPressedElements: {};
    _useMouse: boolean;
    _useTouch: boolean;
    _useXr: boolean;
    _selectEventsAttached: boolean;
    _clickedEntities: {};
    set enabled(arg: boolean);
    get enabled(): boolean;
    set app(arg: any);
    get app(): any;
    /**
     * Attach mouse and touch events to a DOM element.
     *
     * @param {Element} domElement - The DOM element.
     */
    attach(domElement: Element): void;
    attachSelectEvents(): void;
    /**
     * Remove mouse and touch events from the DOM element that it is attached to.
     */
    detach(): void;
    /**
     * Add a {@link ElementComponent} to the internal list of ElementComponents that are being
     * checked for input.
     *
     * @param {ElementComponent} element - The ElementComponent.
     */
    addElement(element: ElementComponent): void;
    /**
     * Remove a {@link ElementComponent} from the internal list of ElementComponents that are being
     * checked for input.
     *
     * @param {ElementComponent} element - The ElementComponent.
     */
    removeElement(element: ElementComponent): void;
    _handleUp(event: any): void;
    _handleDown(event: any): void;
    _handleMove(event: any): void;
    _handleWheel(event: any): void;
    _determineTouchedElements(event: any): {};
    _handleTouchStart(event: any): void;
    _handleTouchEnd(event: any): void;
    _handleTouchMove(event: any): void;
    _onElementMouseEvent(eventType: any, event: any): void;
    _onXrStart(): void;
    _onXrEnd(): void;
    _onXrUpdate(): void;
    _onXrInputRemove(inputSource: any): void;
    _onSelectStart(inputSource: any, event: any): void;
    _onSelectEnd(inputSource: any, event: any): void;
    _onElementSelectEvent(eventType: any, inputSource: any, event: any): void;
    _fireEvent(name: any, evt: any): void;
    _calcMouseCoords(event: any): void;
    _calcTouchCoords(touch: any): {
        x: number;
        y: number;
    };
    _sortElements(a: any, b: any): any;
    _getTargetElement(camera: any, x: any, y: any): any;
    _getTargetElementByRay(ray: any, camera: any): any;
    _buildHitCorners(element: any, screenOrWorldCorners: any, scaleX: any, scaleY: any, scaleZ: any): any;
    _calculateScaleToScreen(element: any): Vec3;
    _calculateScaleToWorld(element: any): Vec3;
    _calculateRayScreen(x: any, y: any, camera: any, ray: any): boolean;
    _calculateRay3d(x: any, y: any, camera: any, ray: any): boolean;
    _checkElement(ray: any, element: any, screen: any): number;
}
/**
 * Represents an input event fired on a {@link ElementComponent}. When an event is raised on an
 * ElementComponent it bubbles up to its parent ElementComponents unless we call stopPropagation().
 */
declare class ElementInputEvent {
    /**
     * Create a new ElementInputEvent instance.
     *
     * @param {MouseEvent|TouchEvent} event - The MouseEvent or TouchEvent that was originally
     * raised.
     * @param {ElementComponent} element - The ElementComponent that this event was originally
     * raised on.
     * @param {CameraComponent} camera - The CameraComponent that this event was originally raised
     * via.
     */
    constructor(event: MouseEvent | TouchEvent, element: ElementComponent, camera: CameraComponent);
    /**
     * The MouseEvent or TouchEvent that was originally raised.
     *
     * @type {MouseEvent|TouchEvent}
     */
    event: MouseEvent | TouchEvent;
    /**
     * The ElementComponent that this event was originally raised on.
     *
     * @type {ElementComponent}
     */
    element: ElementComponent;
    /**
     * The CameraComponent that this event was originally raised via.
     *
     * @type {CameraComponent}
     */
    camera: CameraComponent;
    _stopPropagation: boolean;
    /**
     * Stop propagation of the event to parent {@link ElementComponent}s. This also stops
     * propagation of the event to other event listeners of the original DOM Event.
     */
    stopPropagation(): void;
}
/**
 * Represents a Mouse event fired on a {@link ElementComponent}.
 *
 * @augments ElementInputEvent
 */
declare class ElementMouseEvent extends ElementInputEvent {
    /**
     * Create an instance of an ElementMouseEvent.
     *
     * @param {MouseEvent} event - The MouseEvent that was originally raised.
     * @param {ElementComponent} element - The ElementComponent that this event was originally
     * raised on.
     * @param {CameraComponent} camera - The CameraComponent that this event was originally raised
     * via.
     * @param {number} x - The x coordinate.
     * @param {number} y - The y coordinate.
     * @param {number} lastX - The last x coordinate.
     * @param {number} lastY - The last y coordinate.
     */
    constructor(event: MouseEvent, element: ElementComponent, camera: CameraComponent, x: number, y: number, lastX: number, lastY: number);
    x: number;
    y: number;
    /**
     * Whether the ctrl key was pressed.
     *
     * @type {boolean}
     */
    ctrlKey: boolean;
    /**
     * Whether the alt key was pressed.
     *
     * @type {boolean}
     */
    altKey: boolean;
    /**
     * Whether the shift key was pressed.
     *
     * @type {boolean}
     */
    shiftKey: boolean;
    /**
     * Whether the meta key was pressed.
     *
     * @type {boolean}
     */
    metaKey: boolean;
    /**
     * The mouse button.
     *
     * @type {number}
     */
    button: number;
    /**
     * The amount of horizontal movement of the cursor.
     *
     * @type {number}
     */
    dx: number;
    /**
     * The amount of vertical movement of the cursor.
     *
     * @type {number}
     */
    dy: number;
    /**
     * The amount of the wheel movement.
     *
     * @type {number}
     */
    wheelDelta: number;
}
/**
 * Represents a XRInputSourceEvent fired on a {@link ElementComponent}.
 *
 * @augments ElementInputEvent
 */
declare class ElementSelectEvent extends ElementInputEvent {
    /**
     * Create an instance of a ElementSelectEvent.
     *
     * @param {object} event - The XRInputSourceEvent that was originally raised.
     * @param {ElementComponent} element - The ElementComponent that this event was originally
     * raised on.
     * @param {CameraComponent} camera - The CameraComponent that this event was originally raised
     * via.
     * @param {XrInputSource} inputSource - The XR input source that this event was originally
     * raised from.
     */
    constructor(event: object, element: ElementComponent, camera: CameraComponent, inputSource: XrInputSource);
    /**
     * The XR input source that this event was originally raised from.
     *
     * @type {XrInputSource}
     */
    inputSource: XrInputSource;
}
/**
 * Represents a TouchEvent fired on a {@link ElementComponent}.
 *
 * @augments ElementInputEvent
 */
declare class ElementTouchEvent extends ElementInputEvent {
    /**
     * Create an instance of an ElementTouchEvent.
     *
     * @param {TouchEvent} event - The TouchEvent that was originally raised.
     * @param {ElementComponent} element - The ElementComponent that this event was originally
     * raised on.
     * @param {CameraComponent} camera - The CameraComponent that this event was originally raised
     * via.
     * @param {number} x - The x coordinate of the touch that triggered the event.
     * @param {number} y - The y coordinate of the touch that triggered the event.
     * @param {Touch} touch - The touch object that triggered the event.
     */
    constructor(event: TouchEvent, element: ElementComponent, camera: CameraComponent, x: number, y: number, touch: Touch);
    /**
     * The Touch objects representing all current points of contact with the surface,
     * regardless of target or changed status.
     *
     * @type {Touch[]}
     */
    touches: Touch[];
    /**
     * The Touch objects representing individual points of contact whose states changed between
     * the previous touch event and this one.
     *
     * @type {Touch[]}
     */
    changedTouches: Touch[];
    x: number;
    y: number;
    /**
     * The touch object that triggered the event.
     *
     * @type {Touch}
     */
    touch: Touch;
}













/** @typedef {import('../resources/handler.js').ResourceHandler} ResourceHandler */
/** @typedef {import('../graphics/graphics-device.js').GraphicsDevice} GraphicsDevice */
/** @typedef {import('../input/element-input.js').ElementInput} ElementInput */
/** @typedef {import('../input/game-pads.js').GamePads} GamePads */
/** @typedef {import('../input/keyboard.js').Keyboard} Keyboard */
/** @typedef {import('../input/mouse.js').Mouse} Mouse */
/** @typedef {import('../input/touch-device.js').TouchDevice} TouchDevice */
/** @typedef {import('../sound/manager.js').SoundManager} SoundManager */
/** @typedef {import('../scene/lightmapper/lightmapper.js').Lightmapper} Lightmapper */
/** @typedef {import('../scene/batching/batch-manager.js').BatchManager} BatchManager */
/** @typedef {import('./components/system.js').ComponentSystem} ComponentSystem */
/** @typedef {import('../xr/xr-manager.js').XrManager} XrManager */
declare class AppOptions {
    /**
     * Input handler for {@link ElementComponent}s.
     *
     * @type {ElementInput}
     */
    elementInput: ElementInput;
    /**
     * Keyboard handler for input.
     *
     * @type {Keyboard}
     */
    keyboard: Keyboard;
    /**
     * Mouse handler for input.
     *
     * @type {Mouse}
     */
    mouse: Mouse;
    /**
     * TouchDevice handler for input.
     *
     * @type {TouchDevice}
     */
    touch: TouchDevice;
    /**
     * Gamepad handler for input.
     *
     * @type {GamePads}
     */
    gamepads: GamePads;
    /**
     * Prefix to apply to script urls before loading.
     *
     * @type {string}
     */
    scriptPrefix: string;
    /**
     * Prefix to apply to asset urls before loading.
     *
     * @type {string}
     */
    assetPrefix: string;
    /**
     * Scripts in order of loading first.
     *
     * @type {string[]}
     */
    scriptsOrder: string[];
    /**
     * The sound manager
     *
     * @type {SoundManager}
     */
    soundManager: SoundManager;
    /**
     * The graphics device.
     *
     * @type {GraphicsDevice}
     */
    graphicsDevice: GraphicsDevice;
    /**
     * The lightmapper.
     *
     * @type {Lightmapper}
     */
    lightmapper: Lightmapper;
    /**
     * The BatchManager.
     *
     * @type {BatchManager}
     */
    batchManager: BatchManager;
    /**
     * The XrManager.
     *
     * @type {XrManager}
     */
    xr: XrManager;
    /**
     * The component systems the app requires.
     *
     * @type {ComponentSystem[]}
     */
    componentSystems: ComponentSystem[];
    /**
     * The resource handlers the app requires.
     *
     * @type {ResourceHandler[]}
     */
    resourceHandlers: ResourceHandler[];
}


/** @typedef {import('../graphics/graphics-device.js').GraphicsDevice} GraphicsDevice */
/**
 * Records performance-related statistics related to the application.
 *
 * @ignore
 */
declare class ApplicationStats {
    /**
     * Create a new ApplicationStats instance.
     *
     * @param {GraphicsDevice} device - The graphics device.
     */
    constructor(device: GraphicsDevice);
    frame: {
        fps: number;
        ms: number;
        dt: number;
        updateStart: number;
        updateTime: number;
        renderStart: number;
        renderTime: number;
        physicsStart: number;
        physicsTime: number;
        cullTime: number;
        sortTime: number;
        skinTime: number;
        morphTime: number;
        instancingTime: number;
        triangles: number;
        otherPrimitives: number;
        shaders: number;
        materials: number;
        cameras: number;
        shadowMapUpdates: number;
        shadowMapTime: number;
        depthMapTime: number;
        forwardTime: number;
        lightClustersTime: number;
        lightClusters: number;
        _timeToCountFrames: number;
        _fpsAccum: number;
    };
    drawCalls: {
        forward: number;
        depth: number;
        shadow: number;
        immediate: number;
        misc: number;
        total: number;
        skinned: number;
        instanced: number;
        removedByInstancing: number;
    };
    misc: {
        renderTargetCreationTime: number;
    };
    particles: {
        updatesPerFrame: number;
        _updatesPerFrame: number;
        frameTime: number;
        _frameTime: number;
    };
    shaders: {
        vsCompiled: number;
        fsCompiled: number;
        linked: number;
        materialShaders: number;
        compileTime: number;
    };
    vram: {
        texShadow: number;
        texAsset: number;
        texLightmap: number;
        tex: number;
        vb: number;
        ib: number;
        ub: number;
    };
    get scene(): any;
    get lightmapper(): any;
    get batcher(): any;
}



/** @typedef {import('../asset/asset.js').Asset} Asset */
/** @typedef {import('../asset/asset-registry.js').AssetRegistry} AssetRegistry */
/**
 * Keeps track of which assets are in bundles and loads files from bundles.
 *
 * @ignore
 */
declare class BundleRegistry {
    /**
     * Create a new BundleRegistry instance.
     *
     * @param {AssetRegistry} assets - The asset registry.
     */
    constructor(assets: AssetRegistry);
    _assets: AssetRegistry;
    _bundleAssets: {};
    _assetsInBundles: {};
    _urlsInBundles: {};
    _fileRequests: {};
    _onAssetAdded(asset: any): void;
    _registerBundleEventListeners(bundleAssetId: any): void;
    _unregisterBundleEventListeners(bundleAssetId: any): void;
    _indexAssetInBundle(assetId: any, bundleAsset: any): void;
    _indexAssetFileUrls(asset: any): void;
    _getAssetFileUrls(asset: any): any[];
    _normalizeUrl(url: any): any;
    _onAssetRemoved(asset: any): void;
    _onBundleLoaded(bundleAsset: any): void;
    _onBundleError(err: any, bundleAsset: any): void;
    _findLoadedOrLoadingBundleForUrl(url: any): any;
    /**
     * Lists all of the available bundles that reference the specified asset id.
     *
     * @param {Asset} asset - The asset.
     * @returns {Asset[]} An array of bundle assets or null if the asset is not in any bundle.
     */
    listBundlesForAsset(asset: Asset): Asset[];
    /**
     * Lists all of the available bundles. This includes bundles that are not loaded.
     *
     * @returns {Asset[]} An array of bundle assets.
     */
    list(): Asset[];
    /**
     * Returns true if there is a bundle that contains the specified URL.
     *
     * @param {string} url - The url.
     * @returns {boolean} True or false.
     */
    hasUrl(url: string): boolean;
    /**
     * Returns true if there is a bundle that contains the specified URL and that bundle is either
     * loaded or currently being loaded.
     *
     * @param {string} url - The url.
     * @returns {boolean} True or false.
     */
    canLoadUrl(url: string): boolean;
    /**
     * Loads the specified file URL from a bundle that is either loaded or currently being loaded.
     *
     * @param {string} url - The URL. Make sure you are using a relative URL that does not contain
     * any query parameters.
     * @param {Function} callback - The callback is called when the file has been loaded or if an
     * error occurs. The callback expects the first argument to be the error message (if any) and
     * the second argument is the file blob URL.
     * @example
     * var url = asset.getFileUrl().split('?')[0]; // get normalized asset URL
     * this.app.bundles.loadFile(url, function (err, blobUrl) {
     *     // do something with the blob URL
     * });
     */
    loadUrl(url: string, callback: Function): void;
    /**
     * Destroys the registry, and releases its resources. Does not unload bundle assets as these
     * should be unloaded by the {@link AssetRegistry}.
     */
    destroy(): void;
}


/** @typedef {import('../framework/app-base.js').AppBase} AppBase */
/**
 * Container for all {@link ScriptType}s that are available to this application. Note that
 * PlayCanvas scripts can access the Script Registry from inside the application with
 * {@link AppBase#scripts}.
 *
 * @augments EventHandler
 */
declare class ScriptRegistry extends EventHandler {
    /**
     * Create a new ScriptRegistry instance.
     *
     * @param {AppBase} app - Application to attach registry to.
     */
    constructor(app: AppBase);
    app: AppBase;
    _scripts: {};
    _list: any[];
    destroy(): void;
    /**
     * Add {@link ScriptType} to registry. Note: when {@link createScript} is called, it will add
     * the {@link ScriptType} to the registry automatically. If a script already exists in
     * registry, and the new script has a `swap` method defined, it will perform code hot swapping
     * automatically in async manner.
     *
     * @param {typeof ScriptType} script - Script Type that is created using {@link createScript}.
     * @returns {boolean} True if added for the first time or false if script already exists.
     * @example
     * var PlayerController = pc.createScript('playerController');
     * // playerController Script Type will be added to pc.ScriptRegistry automatically
     * console.log(app.scripts.has('playerController')); // outputs true
     */
    add(script: typeof ScriptType): boolean;
    /**
     * Remove {@link ScriptType}.
     *
     * @param {string|typeof ScriptType} nameOrType - The name or type of {@link ScriptType}.
     * @returns {boolean} True if removed or False if already not in registry.
     * @example
     * app.scripts.remove('playerController');
     */
    remove(nameOrType: string | typeof ScriptType): boolean;
    /**
     * Get {@link ScriptType} by name.
     *
     * @param {string} name - Name of a {@link ScriptType}.
     * @returns {typeof ScriptType} The Script Type if it exists in the registry or null otherwise.
     * @example
     * var PlayerController = app.scripts.get('playerController');
     */
    get(name: string): typeof ScriptType;
    /**
     * Check if a {@link ScriptType} with the specified name is in the registry.
     *
     * @param {string|typeof ScriptType} nameOrType - The name or type of {@link ScriptType}.
     * @returns {boolean} True if {@link ScriptType} is in registry.
     * @example
     * if (app.scripts.has('playerController')) {
     *     // playerController is in pc.ScriptRegistry
     * }
     */
    has(nameOrType: string | typeof ScriptType): boolean;
    /**
     * Get list of all {@link ScriptType}s from registry.
     *
     * @returns {Array<typeof ScriptType>} list of all {@link ScriptType}s in registry.
     * @example
     * // logs array of all Script Type names available in registry
     * console.log(app.scripts.list().map(function (o) {
     *     return o.name;
     * }));
     */
    list(): Array<typeof ScriptType>;
}

declare class I18nParser {
    _validate(data: any): void;
    parse(data: any): any;
}


/**
 * Handles localization. Responsible for loading localization assets and returning translations for
 * a certain key. Can also handle plural forms. To override its default behavior define a different
 * implementation for {@link I18n#getText} and {@link I18n#getPluralText}.
 *
 * @augments EventHandler
 */
declare class I18n extends EventHandler {
    /**
     * Returns the first available locale based on the desired locale specified. First tries to
     * find the desired locale and then tries to find an alternative locale based on the language.
     *
     * @param {string} desiredLocale - The desired locale e.g. en-US.
     * @param {object} availableLocales - A dictionary where each key is an available locale.
     * @returns {string} The locale found or if no locale is available returns the default en-US
     * locale.
     * @example
     * // With a defined dictionary of locales
     * var availableLocales = { en: 'en-US', fr: 'fr-FR' };
     * var locale = pc.I18n.getText('en-US', availableLocales);
     * // returns 'en'
     * @ignore
     */
    static findAvailableLocale(desiredLocale: string, availableLocales: object): string;
    /**
     * Create a new I18n instance.
     *
     * @param {AppBase} app - The application.
     */
    constructor(app: AppBase);
    /**
     * The current locale for example "en-US". Changing the locale will raise an event which will
     * cause localized Text Elements to change language to the new locale.
     *
     * @type {string}
     */
    set locale(arg: any);
    get locale(): any;
    _translations: {};
    _availableLangs: {};
    _app: AppBase;
    _assets: any[];
    _parser: I18nParser;
    /**
     * An array of asset ids or assets that contain localization data in the expected format. I18n
     * will automatically load translations from these assets as the assets are loaded and it will
     * also automatically unload translations if the assets get removed or unloaded at runtime.
     *
     * @type {number[]|Asset[]}
     */
    set assets(arg: any[]);
    get assets(): any[];
    _locale: any;
    _lang: any;
    _pluralFn: any;
    /**
     * Returns the first available locale based on the desired locale specified. First tries to
     * find the desired locale in the loaded translations and then tries to find an alternative
     * locale based on the language.
     *
     * @param {string} desiredLocale - The desired locale e.g. en-US.
     * @returns {string} The locale found or if no locale is available returns the default en-US
     * locale.
     * @example
     * var locale = this.app.i18n.getText('en-US');
     */
    findAvailableLocale(desiredLocale: string): string;
    /**
     * Returns the translation for the specified key and locale. If the locale is not specified it
     * will use the current locale.
     *
     * @param {string} key - The localization key.
     * @param {string} [locale] - The desired locale.
     * @returns {string} The translated text. If no translations are found at all for the locale
     * then it will return the en-US translation. If no translation exists for that key then it will
     * return the localization key.
     * @example
     * var localized = this.app.i18n.getText('localization-key');
     * var localizedFrench = this.app.i18n.getText('localization-key', 'fr-FR');
     */
    getText(key: string, locale?: string): string;
    /**
     * Returns the pluralized translation for the specified key, number n and locale. If the locale
     * is not specified it will use the current locale.
     *
     * @param {string} key - The localization key.
     * @param {number} n - The number used to determine which plural form to use. E.g. For the
     * phrase "5 Apples" n equals 5.
     * @param {string} [locale] - The desired locale.
     * @returns {string} The translated text. If no translations are found at all for the locale
     * then it will return the en-US translation. If no translation exists for that key then it
     * will return the localization key.
     * @example
     * // manually replace {number} in the resulting translation with our number
     * var localized = this.app.i18n.getPluralText('{number} apples', number).replace("{number}", number);
     */
    getPluralText(key: string, n: number, locale?: string): string;
    /**
     * Adds localization data. If the locale and key for a translation already exists it will be
     * overwritten.
     *
     * @param {object} data - The localization data. See example for the expected format of the
     * data.
     * @example
     * this.app.i18n.addData({
     *     header: {
     *         version: 1
     *     },
     *     data: [{
     *         info: {
     *             locale: 'en-US'
     *         },
     *         messages: {
     *             "key": "translation",
     *             // The number of plural forms depends on the locale. See the manual for more information.
     *             "plural_key": ["one item", "more than one items"]
     *         }
     *     }, {
     *         info: {
     *             locale: 'fr-FR'
     *         },
     *         messages: {
     *             // ...
     *         }
     *     }]
     * });
     */
    addData(data: object): void;
    /**
     * Removes localization data.
     *
     * @param {object} data - The localization data. The data is expected to be in the same format
     * as {@link I18n#addData}.
     */
    removeData(data: object): void;
    /**
     * Frees up memory.
     */
    destroy(): void;
    _findFallbackLocale(locale: any, lang: any): any;
    _onAssetAdd(asset: any): void;
    _onAssetLoad(asset: any): void;
    _onAssetChange(asset: any): void;
    _onAssetRemove(asset: any): void;
    _onAssetUnload(asset: any): void;
}

/**
 * Item to be stored in the {@link SceneRegistry}.
 */
declare class SceneRegistryItem {
    /**
     * Creates a new SceneRegistryItem instance.
     *
     * @param {string} name - The name of the scene.
     * @param {string} url - The url of the scene file.
     */
    constructor(name: string, url: string);
    /**
     * The name of the scene.
     *
     * @type {string}
     */
    name: string;
    /**
     * The url of the scene file.
     *
     * @type {string}
     */
    url: string;
    data: any;
    _loading: boolean;
    _onLoadedCallbacks: any[];
    /**
     * Returns true if the scene data has loaded.
     *
     * @type {boolean}
     */
    get loaded(): boolean;
    /**
     * Returns true if the scene data is still being loaded.
     *
     * @type {boolean}
     */
    get loading(): boolean;
}



/**
 * Callback used by {@link SceneRegistryloadSceneHierarchy }.
 */
export type LoadHierarchyCallback = (err: string | null, entity?: Entity) => any;
/**
 * Callback used by {@link SceneRegistryloadSceneSettings }.
 */
export type LoadSettingsCallback = (err: string | null) => any;
/**
 * Callback used by {@link SceneRegistryloadScene }.
 */
export type LoadSceneCallback = (err: string | null, entity?: Entity) => any;
/**
 * Callback used by {@link SceneRegistryloadSceneData }.
 */
export type LoadSceneDataCallback = (err: string | null, sceneItem?: SceneRegistryItem) => any;
/** @typedef {import('./app-base.js').AppBase} AppBase */
/** @typedef {import('./entity.js').Entity} Entity */
/**
 * Callback used by {@link SceneRegistry#loadSceneHierarchy}.
 *
 * @callback LoadHierarchyCallback
 * @param {string|null} err - The error message in the case where the loading or parsing fails.
 * @param {Entity} [entity] - The loaded root entity if no errors were encountered.
 */
/**
 * Callback used by {@link SceneRegistry#loadSceneSettings}.
 *
 * @callback LoadSettingsCallback
 * @param {string|null} err - The error message in the case where the loading or parsing fails.
 */
/**
 * Callback used by {@link SceneRegistry#loadScene}.
 *
 * @callback LoadSceneCallback
 * @param {string|null} err - The error message in the case where the loading or parsing fails.
 * @param {Entity} [entity] - The loaded root entity if no errors were encountered.
 */
/**
 * Callback used by {@link SceneRegistry#loadSceneData}.
 *
 * @callback LoadSceneDataCallback
 * @param {string|null} err - The error message in the case where the loading or parsing fails.
 * @param {SceneRegistryItem} [sceneItem] - The scene registry item if no errors were encountered.
 */
/**
 * Container for storing and loading of scenes. An instance of the registry is created on the
 * {@link AppBase} object as {@link AppBase#scenes}.
 */
declare class SceneRegistry {
    /**
     * Create a new SceneRegistry instance.
     *
     * @param {AppBase} app - The application.
     */
    constructor(app: AppBase);
    _app: AppBase;
    _list: any[];
    _index: {};
    _urlIndex: {};
    destroy(): void;
    /**
     * Return the list of scene.
     *
     * @returns {SceneRegistryItem[]} All items in the registry.
     */
    list(): SceneRegistryItem[];
    /**
     * Add a new item to the scene registry.
     *
     * @param {string} name - The name of the scene.
     * @param {string} url -  The url of the scene file.
     * @returns {boolean} Returns true if the scene was successfully added to the registry, false otherwise.
     */
    add(name: string, url: string): boolean;
    /**
     * Find a Scene by name and return the {@link SceneRegistryItem}.
     *
     * @param {string} name - The name of the scene.
     * @returns {SceneRegistryItem|null} The stored data about a scene or null if no scene with
     * that name exists.
     */
    find(name: string): SceneRegistryItem | null;
    /**
     * Find a scene by the URL and return the {@link SceneRegistryItem}.
     *
     * @param {string} url - The URL to search by.
     * @returns {SceneRegistryItem|null} The stored data about a scene or null if no scene with
     * that URL exists.
     */
    findByUrl(url: string): SceneRegistryItem | null;
    /**
     * Remove an item from the scene registry.
     *
     * @param {string} name - The name of the scene.
     */
    remove(name: string): void;
    _loadSceneData(sceneItem: any, storeInCache: any, callback: any): void;
    /**
     * Loads and stores the scene data to reduce the number of the network requests when the same
     * scenes are loaded multiple times. Can also be used to load data before calling
     * {@link SceneRegistry#loadSceneHierarchy} and {@link SceneRegistry#loadSceneSettings} to make
     * scene loading quicker for the user.
     *
     * @param {SceneRegistryItem | string} sceneItem - The scene item (which can be found with
     * {@link SceneRegistry#find} or URL of the scene file. Usually this will be "scene_id.json".
     * @param {LoadSceneDataCallback} callback - The function to call after loading,
     * passed (err, sceneItem) where err is null if no errors occurred.
     * @example
     * var sceneItem = app.scenes.find("Scene Name");
     * app.scenes.loadSceneData(sceneItem, function (err, sceneItem) {
     *     if (err) {
     *         // error
     *     }
     * });
     */
    loadSceneData(sceneItem: SceneRegistryItem | string, callback: LoadSceneDataCallback): void;
    /**
     * Unloads scene data that has been loaded previously using {@link SceneRegistry#loadSceneData}.
     *
     * @param {SceneRegistryItem | string} sceneItem - The scene item (which can be found with
     * {@link SceneRegistry#find} or URL of the scene file. Usually this will be "scene_id.json".
     * @example
     * var sceneItem = app.scenes.find("Scene Name");
     * app.scenes.unloadSceneData(sceneItem);
     */
    unloadSceneData(sceneItem: SceneRegistryItem | string): void;
    /**
     * Load a scene file, create and initialize the Entity hierarchy and add the hierarchy to the
     * application root Entity.
     *
     * @param {SceneRegistryItem | string} sceneItem - The scene item (which can be found with
     * {@link SceneRegistry#find} or URL of the scene file. Usually this will be "scene_id.json".
     * @param {LoadHierarchyCallback} callback - The function to call after loading,
     * passed (err, entity) where err is null if no errors occurred.
     * @example
     * var sceneItem = app.scenes.find("Scene Name");
     * app.scenes.loadSceneHierarchy(sceneItem, function (err, entity) {
     *     if (!err) {
     *         var e = app.root.find("My New Entity");
     *     } else {
     *         // error
     *     }
     * });
     */
    loadSceneHierarchy(sceneItem: SceneRegistryItem | string, callback: LoadHierarchyCallback): void;
    /**
     * Load a scene file and apply the scene settings to the current scene.
     *
     * @param {SceneRegistryItem | string} sceneItem - The scene item (which can be found with
     * {@link SceneRegistry#find} or URL of the scene file. Usually this will be "scene_id.json".
     * @param {LoadSettingsCallback} callback - The function called after the settings
     * are applied. Passed (err) where err is null if no error occurred.
     * @example
     * var sceneItem = app.scenes.find("Scene Name");
     * app.scenes.loadSceneHierarchy(sceneItem, function (err, entity) {
     *     if (!err) {
     *         var e = app.root.find("My New Entity");
     *     } else {
     *         // error
     *     }
     * });
     */
    loadSceneSettings(sceneItem: SceneRegistryItem | string, callback: LoadSettingsCallback): void;
    /**
     * Load the scene hierarchy and scene settings. This is an internal method used by the
     * {@link AppBase}.
     *
     * @param {string} url - The URL of the scene file.
     * @param {LoadSceneCallback} callback - The function called after the settings are
     * applied. Passed (err, scene) where err is null if no error occurred and scene is the
     * {@link Scene}.
     */
    loadScene(url: string, callback: LoadSceneCallback): void;
}


/**
 * Internal class abstracting the access to the depth and color texture of the scene.
 * color frame buffer is copied to a texture
 * For webgl 2 devices, the depth buffer is copied to a texture
 * for webgl 1 devices, the scene's depth is rendered to a separate RGBA texture
 *
 * TODO: implement mipmapped color buffer support for WebGL 1 as well, which requires
 * the texture to be a power of two, by first downscaling the captured framebuffer
 * texture to smaller power of 2 texture, and then generate mipmaps and use it for rendering
 * TODO: or even better, implement blur filter to have smoother lower levels
 *
 * @ignore
 */
declare class SceneGrab {
    constructor(application: any);
    application: any;
    /** @type {GraphicsDevice} */
    device: GraphicsDevice;
    layer: Layer;
    colorFormat: number;
    setupUniform(device: any, depth: any, buffer: any): void;
    allocateTexture(device: any, name: any, format: any, isDepth: any, mipmaps: any): Texture;
    allocateRenderTarget(renderTarget: any, device: any, format: any, isDepth: any, mipmaps: any, isDepthUniforms: any): any;
    releaseRenderTarget(rt: any): void;
    initWebGl2(): void;
    initWebGl1(): void;
    patch(layer: any): void;
}



/** @typedef {import('../../entity.js').Entity} Entity */
/** @typedef {import('./system.js').ZoneComponentSystem} ZoneComponentSystem */
/**
 * The ZoneComponent allows you to define an area in world space of certain size. This can be used
 * in various ways, such as affecting audio reverb when {@link AudioListenerComponent} is within
 * zone. Or create culling system with portals between zones to hide whole indoor sections for
 * performance reasons. And many other possible options. Zones are building blocks and meant to be
 * used in many different ways.
 *
 * @augments Component
 * @ignore
 */
declare class ZoneComponent extends Component {
    /**
     * Create a new ZoneComponent instance.
     *
     * @param {ZoneComponentSystem} system - The ComponentSystem that created this Component.
     * @param {Entity} entity - The Entity that this Component is attached to.
     */
    constructor(system: ZoneComponentSystem, entity: Entity);
    _oldState: boolean;
    _size: Vec3;
    /**
     * Fired when Component becomes enabled. Note: this event does not take in account entity or
     * any of its parent enabled state.
     *
     * @event ZoneComponent#enable
     * @example
     * entity.zone.on('enable', function () {
     *     // component is enabled
     * });
     * @ignore
     */
    /**
     * Fired when Component becomes disabled. Note: this event does not take in account entity or
     * any of its parent enabled state.
     *
     * @event ZoneComponent#disable
     * @example
     * entity.zone.on('disable', function () {
     *     // component is disabled
     * });
     * @ignore
     */
    /**
     * Fired when Component changes state to enabled or disabled. Note: this event does not take in
     * account entity or any of its parent enabled state.
     *
     * @event ZoneComponent#state
     * @param {boolean} enabled - True if now enabled, False if disabled.
     * @example
     * entity.zone.on('state', function (enabled) {
     *     // component changed state
     * });
     * @ignore
     */
    /**
     * Fired when a zone is removed from an entity.
     *
     * @event ZoneComponent#remove
     * @example
     * entity.zone.on('remove', function () {
     *     // zone has been removed from an entity
     * });
     * @ignore
     */
    /**
     * The size of the axis-aligned box of this ZoneComponent.
     *
     * @type {Vec3}
     */
    set size(arg: Vec3);
    get size(): Vec3;
    _onSetEnabled(prop: any, old: any, value: any): void;
    _checkState(): void;
    _onBeforeRemove(): void;
}

declare class ZoneComponentData {
    enabled: boolean;
}

/**
 * Creates and manages {@link ZoneComponent} instances.
 *
 * @augments ComponentSystem
 * @ignore
 */
declare class ZoneComponentSystem extends ComponentSystem {
    id: string;
    ComponentType: typeof ZoneComponent;
    DataType: typeof ZoneComponentData;
    schema: string[];
    initializeComponentData(component: any, data: any, properties: any): void;
    cloneComponent(entity: any, clone: any): Component;
    _onBeforeRemove(entity: any, component: any): void;
}



/**
 * The JointComponent adds a physics joint constraint linking two rigid bodies.
 *
 * @augments Component
 * @ignore
 */
declare class JointComponent extends Component {
    /**
     * Create a new JointComponent instance.
     *
     * @param {JointComponentSystem} system - The ComponentSystem that created this Component.
     * @param {Entity} entity - The Entity that this Component is attached to.
     */
    constructor(system: JointComponentSystem, entity: Entity);
    _constraint: any;
    _entityA: any;
    _entityB: any;
    _breakForce: number;
    _enableCollision: boolean;
    _linearMotionX: string;
    _linearLimitsX: Vec2;
    _linearSpringX: boolean;
    _linearStiffnessX: number;
    _linearDampingX: number;
    _linearEquilibriumX: number;
    _linearMotionY: string;
    _linearLimitsY: Vec2;
    _linearSpringY: boolean;
    _linearStiffnessY: number;
    _linearDampingY: number;
    _linearEquilibriumY: number;
    _linearMotionZ: string;
    _linearLimitsZ: Vec2;
    _linearSpringZ: boolean;
    _linearStiffnessZ: number;
    _linearDampingZ: number;
    _linearEquilibriumZ: number;
    _angularMotionX: string;
    _angularLimitsX: Vec2;
    _angularSpringX: boolean;
    _angularStiffnessX: number;
    _angularDampingX: number;
    _angularEquilibriumX: number;
    _angularMotionY: string;
    _angularLimitsY: Vec2;
    _angularSpringY: boolean;
    _angularStiffnessY: number;
    _angularDampingY: number;
    _angularEquilibriumY: number;
    _angularMotionZ: string;
    _angularLimitsZ: Vec2;
    _angularSpringZ: boolean;
    _angularEquilibriumZ: number;
    _angularDampingZ: number;
    _angularStiffnessZ: number;
    set entityA(arg: any);
    get entityA(): any;
    set entityB(arg: any);
    get entityB(): any;
    set breakForce(arg: number);
    get breakForce(): number;
    set enableCollision(arg: boolean);
    get enableCollision(): boolean;
    set angularLimitsX(arg: Vec2);
    get angularLimitsX(): Vec2;
    set angularMotionX(arg: string);
    get angularMotionX(): string;
    set angularLimitsY(arg: Vec2);
    get angularLimitsY(): Vec2;
    set angularMotionY(arg: string);
    get angularMotionY(): string;
    set angularLimitsZ(arg: Vec2);
    get angularLimitsZ(): Vec2;
    set angularMotionZ(arg: string);
    get angularMotionZ(): string;
    set linearLimitsX(arg: Vec2);
    get linearLimitsX(): Vec2;
    set linearMotionX(arg: string);
    get linearMotionX(): string;
    set linearLimitsY(arg: Vec2);
    get linearLimitsY(): Vec2;
    set linearMotionY(arg: string);
    get linearMotionY(): string;
    set linearLimitsZ(arg: Vec2);
    get linearLimitsZ(): Vec2;
    set linearMotionZ(arg: string);
    get linearMotionZ(): string;
    _convertTransform(pcTransform: any, ammoTransform: any): void;
    _updateAngularLimits(): void;
    _updateLinearLimits(): void;
    _createConstraint(): void;
    _destroyConstraint(): void;
    initFromData(data: any): void;
    _onSetEnabled(prop: any, old: any, value: any): void;
    _onBeforeRemove(): void;
}

declare class JointComponentData {
    enabled: boolean;
}

/**
 * Creates and manages physics joint components.
 *
 * @augments ComponentSystem
 * @ignore
 */
declare class JointComponentSystem extends ComponentSystem {
    id: string;
    ComponentType: typeof JointComponent;
    DataType: typeof JointComponentData;
    schema: string[];
    initializeComponentData(component: any, data: any, properties: any): void;
}



/** @typedef {import('./system.js').AudioSourceComponentSystem} AudioSourceComponentSystem */
/** @typedef {import('../../entity.js').Entity} Entity */
/**
 * The AudioSource Component controls playback of an audio sample. This class will be deprecated
 * in favor of {@link SoundComponent}.
 *
 * @property {Asset[]} assets The list of audio assets - can also be an array of asset ids.
 * @property {boolean} activate If true the audio will begin playing as soon as the scene is
 * loaded.
 * @property {number} volume The volume modifier to play the audio with. In range 0-1.
 * @property {number} pitch The pitch modifier to play the audio with. Must be larger than 0.01.
 * @property {boolean} loop If true the audio will restart when it finishes playing.
 * @property {boolean} 3d If true the audio will play back at the location of the entity in space,
 * so the audio will be affect by the position of the {@link AudioListenerComponent}.
 * @property {string} distanceModel Determines which algorithm to use to reduce the volume of the
 * audio as it moves away from the listener. Can be:
 *
 * - "linear"
 * - "inverse"
 * - "exponential"
 *
 * Default is "inverse".
 * @property {number} minDistance The minimum distance from the listener at which audio falloff
 * begins.
 * @property {number} maxDistance The maximum distance from the listener at which audio falloff
 * stops. Note the volume of the audio is not 0 after this distance, but just doesn't fall off
 * anymore.
 * @property {number} rollOffFactor The factor used in the falloff equation.
 * @augments Component
 * @ignore
 */
declare class AudioSourceComponent extends Component {
    /**
     * Create a new AudioSource Component instance.
     *
     * @param {AudioSourceComponentSystem} system - The ComponentSystem that created
     * this component.
     * @param {Entity} entity - The entity that the Component is attached to.
     */
    constructor(system: AudioSourceComponentSystem, entity: Entity);
    /**
     * Begin playback of an audio asset in the component attached to an entity.
     *
     * @param {string} name - The name of the Asset to play.
     */
    play(name: string): void;
    /**
     * Pause playback of the audio that is playing on the Entity. Playback can be resumed by
     * calling {@link AudioSourceComponent#unpause}.
     */
    pause(): void;
    /**
     * Resume playback of the audio if paused. Playback is resumed at the time it was paused.
     */
    unpause(): void;
    /**
     * Stop playback on an Entity. Playback can not be resumed after being stopped.
     */
    stop(): void;
    channel: any;
    onSetAssets(name: any, oldValue: any, newValue: any): void;
    onAssetChanged(asset: any, attribute: any, newValue: any, oldValue: any): void;
    onAssetRemoved(asset: any): void;
    onSetLoop(name: any, oldValue: any, newValue: any): void;
    onSetVolume(name: any, oldValue: any, newValue: any): void;
    onSetPitch(name: any, oldValue: any, newValue: any): void;
    onSetMaxDistance(name: any, oldValue: any, newValue: any): void;
    onSetMinDistance(name: any, oldValue: any, newValue: any): void;
    onSetRollOffFactor(name: any, oldValue: any, newValue: any): void;
    onSetDistanceModel(name: any, oldValue: any, newValue: any): void;
    onSet3d(name: any, oldValue: any, newValue: any): void;
    loadAudioSourceAssets(ids: any): void;
}

declare class AudioSourceComponentData {
    enabled: boolean;
    assets: any[];
    activate: boolean;
    volume: number;
    pitch: number;
    loop: boolean;
    '3d': boolean;
    minDistance: number;
    maxDistance: number;
    rollOffFactor: number;
    distanceModel: string;
    paused: boolean;
    sources: {};
    currentSource: any;
    channel: any;
}

/**
 * Controls playback of an audio sample. This class will be deprecated in favor of
 * {@link SoundComponentSystem}.
 *
 * @augments ComponentSystem
 * @ignore
 */
declare class AudioSourceComponentSystem extends ComponentSystem {
    id: string;
    ComponentType: typeof AudioSourceComponent;
    DataType: typeof AudioSourceComponentData;
    schema: string[];
    manager: SoundManager;
    initialized: boolean;
    initializeComponentData(component: any, data: any, properties: any): void;
    onInitialize(root: any): void;
    onUpdate(dt: any): void;
    onRemove(entity: any, data: any): void;
    /**
     * Set the volume for the entire AudioSource system. All sources will have their volume
     * multiplied by this value.
     *
     * @param {number} volume - The value to set the volume to. Valid from 0 to 1.
     */
    setVolume(volume: number): void;
}
























/** @typedef {import('./anim/system.js').AnimComponentSystem} AnimComponentSystem */
/** @typedef {import('./animation/system.js').AnimationComponentSystem} AnimationComponentSystem */
/** @typedef {import('./audio-listener/system.js').AudioListenerComponentSystem} AudioListenerComponentSystem */
/** @typedef {import('./audio-source/system.js').AudioSourceComponentSystem} AudioSourceComponentSystem */
/** @typedef {import('./button/system.js').ButtonComponentSystem} ButtonComponentSystem */
/** @typedef {import('./camera/system.js').CameraComponentSystem} CameraComponentSystem */
/** @typedef {import('./collision/system.js').CollisionComponentSystem} CollisionComponentSystem */
/** @typedef {import('./element/system.js').ElementComponentSystem} ElementComponentSystem */
/** @typedef {import('./joint/system.js').JointComponentSystem} JointComponentSystem */
/** @typedef {import('./layout-child/system.js').LayoutChildComponentSystem} LayoutChildComponentSystem */
/** @typedef {import('./layout-group/system.js').LayoutGroupComponentSystem} LayoutGroupComponentSystem */
/** @typedef {import('./light/system.js').LightComponentSystem} LightComponentSystem */
/** @typedef {import('./model/system.js').ModelComponentSystem} ModelComponentSystem */
/** @typedef {import('./particle-system/system.js').ParticleSystemComponentSystem} ParticleSystemComponentSystem */
/** @typedef {import('./render/system.js').RenderComponentSystem} RenderComponentSystem */
/** @typedef {import('./rigid-body/system.js').RigidBodyComponentSystem} RigidBodyComponentSystem */
/** @typedef {import('./screen/system.js').ScreenComponentSystem} ScreenComponentSystem */
/** @typedef {import('./script/system.js').ScriptComponentSystem} ScriptComponentSystem */
/** @typedef {import('./scrollbar/system.js').ScrollbarComponentSystem} ScrollbarComponentSystem */
/** @typedef {import('./scroll-view/system.js').ScrollViewComponentSystem} ScrollViewComponentSystem */
/** @typedef {import('./sound/system.js').SoundComponentSystem} SoundComponentSystem */
/** @typedef {import('./sprite/system.js').SpriteComponentSystem} SpriteComponentSystem */
/** @typedef {import('./zone/system.js').ZoneComponentSystem} ZoneComponentSystem */
/**
 * Store, access and delete instances of the various ComponentSystems.
 */
declare class ComponentSystemRegistry extends EventHandler {
    /**
     * Gets the {@link AnimComponentSystem} from the registry.
     *
     * @type {AnimComponentSystem|undefined}
     * @readonly
     */
    readonly anim: AnimComponentSystem | undefined;
    /**
     * Gets the {@link AnimationComponentSystem} from the registry.
     *
     * @type {AnimationComponentSystem|undefined}
     * @readonly
     */
    readonly animation: AnimationComponentSystem | undefined;
    /**
     * Gets the {@link AudioListenerComponentSystem} from the registry.
     *
     * @type {AudioListenerComponentSystem|undefined}
     * @readonly
     */
    readonly audiolistener: AudioListenerComponentSystem | undefined;
    /**
     * Gets the {@link AudioSourceComponentSystem} from the registry.
     *
     * @type {AudioSourceComponentSystem|undefined}
     * @readonly
     * @ignore
     */
    readonly audiosource: AudioSourceComponentSystem | undefined;
    /**
     * Gets the {@link ButtonComponentSystem} from the registry.
     *
     * @type {ButtonComponentSystem|undefined}
     * @readonly
     */
    readonly button: ButtonComponentSystem | undefined;
    /**
     * Gets the {@link CameraComponentSystem} from the registry.
     *
     * @type {CameraComponentSystem|undefined}
     * @readonly
     */
    readonly camera: CameraComponentSystem | undefined;
    /**
     * Gets the {@link CollisionComponentSystem} from the registry.
     *
     * @type {CollisionComponentSystem|undefined}
     * @readonly
     */
    readonly collision: CollisionComponentSystem | undefined;
    /**
     * Gets the {@link ElementComponentSystem} from the registry.
     *
     * @type {ElementComponentSystem|undefined}
     * @readonly
     */
    readonly element: ElementComponentSystem | undefined;
    /**
     * Gets the {@link JointComponentSystem} from the registry.
     *
     * @type {JointComponentSystem|undefined}
     * @readonly
     * @ignore
     */
    readonly joint: JointComponentSystem | undefined;
    /**
     * Gets the {@link LayoutChildComponentSystem} from the registry.
     *
     * @type {LayoutChildComponentSystem|undefined}
     * @readonly
     */
    readonly layoutchild: LayoutChildComponentSystem | undefined;
    /**
     * Gets the {@link LayoutGroupComponentSystem} from the registry.
     *
     * @type {LayoutGroupComponentSystem|undefined}
     * @readonly
     */
    readonly layoutgroup: LayoutGroupComponentSystem | undefined;
    /**
     * Gets the {@link LightComponentSystem} from the registry.
     *
     * @type {LightComponentSystem|undefined}
     * @readonly
     */
    readonly light: LightComponentSystem | undefined;
    /**
     * Gets the {@link ModelComponentSystem} from the registry.
     *
     * @type {ModelComponentSystem|undefined}
     * @readonly
     */
    readonly model: ModelComponentSystem | undefined;
    /**
     * Gets the {@link ParticleSystemComponentSystem} from the registry.
     *
     * @type {ParticleSystemComponentSystem|undefined}
     * @readonly
     */
    readonly particlesystem: ParticleSystemComponentSystem | undefined;
    /**
     * Gets the {@link RenderComponentSystem} from the registry.
     *
     * @type {RenderComponentSystem|undefined}
     * @readonly
     */
    readonly render: RenderComponentSystem | undefined;
    /**
     * Gets the {@link RigidBodyComponentSystem} from the registry.
     *
     * @type {RigidBodyComponentSystem|undefined}
     * @readonly
     */
    readonly rigidbody: RigidBodyComponentSystem | undefined;
    /**
     * Gets the {@link ScreenComponentSystem} from the registry.
     *
     * @type {ScreenComponentSystem|undefined}
     * @readonly
     */
    readonly screen: ScreenComponentSystem | undefined;
    /**
     * Gets the {@link ScriptComponentSystem} from the registry.
     *
     * @type {ScriptComponentSystem|undefined}
     * @readonly
     */
    readonly script: ScriptComponentSystem | undefined;
    /**
     * Gets the {@link ScrollbarComponentSystem} from the registry.
     *
     * @type {ScrollbarComponentSystem|undefined}
     * @readonly
     */
    readonly scrollbar: ScrollbarComponentSystem | undefined;
    /**
     * Gets the {@link ScrollViewComponentSystem} from the registry.
     *
     * @type {ScrollViewComponentSystem|undefined}
     * @readonly
     */
    readonly scrollview: ScrollViewComponentSystem | undefined;
    /**
     * Gets the {@link SoundComponentSystem} from the registry.
     *
     * @type {SoundComponentSystem|undefined}
     * @readonly
     */
    readonly sound: SoundComponentSystem | undefined;
    /**
     * Gets the {@link SpriteComponentSystem} from the registry.
     *
     * @type {SpriteComponentSystem|undefined}
     * @readonly
     */
    readonly sprite: SpriteComponentSystem | undefined;
    /**
     * Gets the {@link ZoneComponentSystem} from the registry.
     *
     * @type {ZoneComponentSystem|undefined}
     * @readonly
     * @ignore
     */
    readonly zone: ZoneComponentSystem | undefined;
    list: any[];
    /**
     * Add a component system to the registry.
     *
     * @param {object} system - The {@link ComponentSystem} instance.
     * @ignore
     */
    add(system: object): void;
    /**
     * Remove a component system from the registry.
     *
     * @param {object} system - The {@link ComponentSystem} instance.
     * @ignore
     */
    remove(system: object): void;
    destroy(): void;
}














/**
 * Callback used by {@link AppBaseconfigure } when configuration file is loaded and parsed (or
 * an error occurs).
 */
export type ConfigureAppCallback = (err: string | null) => any;
/**
 * Callback used by {@link AppBasepreload } when all assets (marked as 'preload') are loaded.
 */
export type PreloadAppCallback = () => any;
/**
 * Callback used by {@link AppBasestart } and itself to request
 * the rendering of a new animation frame.
 */
export type MakeTickCallback = (timestamp?: number, frame?: any) => any;
/**
 * Callback used by {@link AppBase#configure} when configuration file is loaded and parsed (or
 * an error occurs).
 *
 * @callback ConfigureAppCallback
 * @param {string|null} err - The error message in the case where the loading or parsing fails.
 */
/**
 * Callback used by {@link AppBase#preload} when all assets (marked as 'preload') are loaded.
 *
 * @callback PreloadAppCallback
 */
declare let app: any;
/**
 * An Application represents and manages your PlayCanvas application. If you are developing using
 * the PlayCanvas Editor, the Application is created for you. You can access your Application
 * instance in your scripts. Below is a skeleton script which shows how you can access the
 * application 'app' property inside the initialize and update functions:
 *
 * ```javascript
 * // Editor example: accessing the pc.Application from a script
 * var MyScript = pc.createScript('myScript');
 *
 * MyScript.prototype.initialize = function() {
 *     // Every script instance has a property 'this.app' accessible in the initialize...
 *     var app = this.app;
 * };
 *
 * MyScript.prototype.update = function(dt) {
 *     // ...and update functions.
 *     var app = this.app;
 * };
 * ```
 *
 * If you are using the Engine without the Editor, you have to create the application instance
 * manually.
 *
 * @augments EventHandler
 */
declare class AppBase extends EventHandler {
    /**
     * @private
     * @static
     * @name app
     * @type {AppBase|undefined}
     * @description Gets the current application, if any.
     */
    private static _applications;
    /**
     * Get the current application. In the case where there are multiple running applications, the
     * function can get an application based on a supplied canvas id. This function is particularly
     * useful when the current Application is not readily available. For example, in the JavaScript
     * console of the browser's developer tools.
     *
     * @param {string} [id] - If defined, the returned application should use the canvas which has
     * this id. Otherwise current application will be returned.
     * @returns {AppBase|undefined} The running application, if any.
     * @example
     * var app = pc.AppBase.getApplication();
     */
    static getApplication(id?: string): AppBase | undefined;
    /**
     * Create a new AppBase instance.
     *
     * @param {Element} canvas - The canvas element.
     * @example
     * // Engine-only example: create the application manually
     * var options = new AppOptions();
     * var app = new pc.AppBase(canvas);
     * app.init(options);
     *
     * // Start the application's main loop
     * app.start();
     *
     * @hideconstructor
     */
    constructor(canvas: Element);
    /** @private */
    private _destroyRequested;
    /** @private */
    private _inFrameUpdate;
    /** @private */
    private _time;
    /**
     * Scales the global time delta. Defaults to 1.
     *
     * @type {number}
     * @example
     * // Set the app to run at half speed
     * this.app.timeScale = 0.5;
     */
    timeScale: number;
    /**
     * Clamps per-frame delta time to an upper bound. Useful since returning from a tab
     * deactivation can generate huge values for dt, which can adversely affect game state.
     * Defaults to 0.1 (seconds).
     *
     * @type {number}
     * @example
     * // Don't clamp inter-frame times of 200ms or less
     * this.app.maxDeltaTime = 0.2;
     */
    maxDeltaTime: number;
    /**
     * The total number of frames the application has updated since start() was called.
     *
     * @type {number}
     * @ignore
     */
    frame: number;
    /**
     * When true, the application's render function is called every frame. Setting autoRender
     * to false is useful to applications where the rendered image may often be unchanged over
     * time. This can heavily reduce the application's load on the CPU and GPU. Defaults to
     * true.
     *
     * @type {boolean}
     * @example
     * // Disable rendering every frame and only render on a keydown event
     * this.app.autoRender = false;
     * this.app.keyboard.on('keydown', function (event) {
     *     this.app.renderNextFrame = true;
     * }, this);
     */
    autoRender: boolean;
    /**
     * Set to true to render the scene on the next iteration of the main loop. This only has an
     * effect if {@link AppBase#autoRender} is set to false. The value of renderNextFrame
     * is set back to false again as soon as the scene has been rendered.
     *
     * @type {boolean}
     * @example
     * // Render the scene only while space key is pressed
     * if (this.app.keyboard.isPressed(pc.KEY_SPACE)) {
     *     this.app.renderNextFrame = true;
     * }
     */
    renderNextFrame: boolean;
    /**
     * Enable if you want entity type script attributes to not be re-mapped when an entity is
     * cloned.
     *
     * @type {boolean}
     * @ignore
     */
    useLegacyScriptAttributeCloning: boolean;
    _librariesLoaded: boolean;
    _fillMode: string;
    _resolutionMode: string;
    _allowResize: boolean;
    /**
     * For backwards compatibility with scripts 1.0.
     *
     * @type {AppBase}
     * @deprecated
     * @ignore
     */
    context: AppBase;
    /**
     * Initialize the app.
     *
     * @param {AppOptions} appOptions - Options specifying the init parameters for the app.
     */
    init(appOptions: AppOptions): void;
    /**
     * The graphics device used by the application.
     *
     * @type {GraphicsDevice}
     */
    graphicsDevice: GraphicsDevice;
    stats: ApplicationStats;
    /**
     * @type {SoundManager}
     * @private
     */
    private _soundManager;
    /**
     * The resource loader.
     *
     * @type {ResourceLoader}
     */
    loader: ResourceLoader;
    /**
     * Stores all entities that have been created for this app by guid.
     *
     * @type {Object<string, Entity>}
     * @ignore
     */
    _entityIndex: {
        [x: string]: Entity;
    };
    /**
     * The scene managed by the application.
     *
     * @type {Scene}
     * @example
     * // Set the tone mapping property of the application's scene
     * this.app.scene.toneMapping = pc.TONEMAP_FILMIC;
     */
    scene: Scene;
    /**
     * The root entity of the application.
     *
     * @type {Entity}
     * @example
     * // Return the first entity called 'Camera' in a depth-first search of the scene hierarchy
     * var camera = this.app.root.findByName('Camera');
     */
    root: Entity;
    /**
     * The asset registry managed by the application.
     *
     * @type {AssetRegistry}
     * @example
     * // Search the asset registry for all assets with the tag 'vehicle'
     * var vehicleAssets = this.app.assets.findByTag('vehicle');
     */
    assets: AssetRegistry;
    /**
     * @type {BundleRegistry}
     * @ignore
     */
    bundles: BundleRegistry;
    /**
     * Set this to false if you want to run without using bundles. We set it to true only if
     * TextDecoder is available because we currently rely on it for untarring.
     *
     * @type {boolean}
     * @ignore
     */
    enableBundles: boolean;
    scriptsOrder: string[];
    /**
     * The application's script registry.
     *
     * @type {ScriptRegistry}
     */
    scripts: ScriptRegistry;
    /**
     * Handles localization.
     *
     * @type {I18n}
     */
    i18n: I18n;
    /**
     * The scene registry managed by the application.
     *
     * @type {SceneRegistry}
     * @example
     * // Search the scene registry for a item with the name 'racetrack1'
     * var sceneItem = this.app.scenes.find('racetrack1');
     *
     * // Load the scene using the item's url
     * this.app.scenes.loadScene(sceneItem.url);
     */
    scenes: SceneRegistry;
    defaultLayerWorld: Layer;
    sceneGrab: SceneGrab;
    defaultLayerDepth: Layer;
    defaultLayerSkybox: Layer;
    defaultLayerUi: Layer;
    defaultLayerImmediate: Layer;
    /**
     * The forward renderer.
     *
     * @type {ForwardRenderer}
     * @ignore
     */
    renderer: ForwardRenderer;
    /**
     * The frame graph.
     *
     * @type {FrameGraph}
     * @ignore
     */
    frameGraph: FrameGraph;
    /**
     * The run-time lightmapper.
     *
     * @type {Lightmapper}
     */
    lightmapper: Lightmapper;
    /**
     * The application's batch manager.
     *
     * @type {BatchManager}
     */
    _batcher: BatchManager;
    /**
     * The keyboard device.
     *
     * @type {Keyboard}
     */
    keyboard: Keyboard;
    /**
     * The mouse device.
     *
     * @type {Mouse}
     */
    mouse: Mouse;
    /**
     * Used to get touch events input.
     *
     * @type {TouchDevice}
     */
    touch: TouchDevice;
    /**
     * Used to access GamePad input.
     *
     * @type {GamePads}
     */
    gamepads: GamePads;
    /**
     * Used to handle input for {@link ElementComponent}s.
     *
     * @type {ElementInput}
     */
    elementInput: ElementInput;
    /**
     * The XR Manager that provides ability to start VR/AR sessions.
     *
     * @type {XrManager}
     * @example
     * // check if VR is available
     * if (app.xr.isAvailable(pc.XRTYPE_VR)) {
     *     // VR is available
     * }
     */
    xr: XrManager;
    /**
     * @type {boolean}
     * @ignore
     */
    _inTools: boolean;
    /**
     * @type {Asset|null}
     * @private
     */
    private _skyboxAsset;
    /**
     * @type {string}
     * @ignore
     */
    _scriptPrefix: string;
    /**
     * The application's component system registry. The Application constructor adds the
     * following component systems to its component system registry:
     *
     * - anim ({@link AnimComponentSystem})
     * - animation ({@link AnimationComponentSystem})
     * - audiolistener ({@link AudioListenerComponentSystem})
     * - button ({@link ButtonComponentSystem})
     * - camera ({@link CameraComponentSystem})
     * - collision ({@link CollisionComponentSystem})
     * - element ({@link ElementComponentSystem})
     * - layoutchild ({@link LayoutChildComponentSystem})
     * - layoutgroup ({@link LayoutGroupComponentSystem})
     * - light ({@link LightComponentSystem})
     * - model ({@link ModelComponentSystem})
     * - particlesystem ({@link ParticleSystemComponentSystem})
     * - rigidbody ({@link RigidBodyComponentSystem})
     * - render ({@link RenderComponentSystem})
     * - screen ({@link ScreenComponentSystem})
     * - script ({@link ScriptComponentSystem})
     * - scrollbar ({@link ScrollbarComponentSystem})
     * - scrollview ({@link ScrollViewComponentSystem})
     * - sound ({@link SoundComponentSystem})
     * - sprite ({@link SpriteComponentSystem})
     *
     * @type {ComponentSystemRegistry}
     * @example
     * // Set global gravity to zero
     * this.app.systems.rigidbody.gravity.set(0, 0, 0);
     * @example
     * // Set the global sound volume to 50%
     * this.app.systems.sound.volume = 0.5;
     */
    systems: ComponentSystemRegistry;
    /** @private */
    private _visibilityChangeHandler;
    _hiddenAttr: string;
    tick: MakeTickCallback;
    /** @private */
    private _initDefaultMaterial;
    /**
     * @type {SoundManager}
     * @ignore
     */
    get soundManager(): SoundManager;
    /**
     * The application's batch manager. The batch manager is used to merge mesh instances in
     * the scene, which reduces the overall number of draw calls, thereby boosting performance.
     *
     * @type {BatchManager}
     */
    get batcher(): BatchManager;
    /**
     * The current fill mode of the canvas. Can be:
     *
     * - {@link FILLMODE_NONE}: the canvas will always match the size provided.
     * - {@link FILLMODE_FILL_WINDOW}: the canvas will simply fill the window, changing aspect ratio.
     * - {@link FILLMODE_KEEP_ASPECT}: the canvas will grow to fill the window as best it can while
     * maintaining the aspect ratio.
     *
     * @type {string}
     */
    get fillMode(): string;
    /**
     * The current resolution mode of the canvas, Can be:
     *
     * - {@link RESOLUTION_AUTO}: if width and height are not provided, canvas will be resized to
     * match canvas client size.
     * - {@link RESOLUTION_FIXED}: resolution of canvas will be fixed.
     *
     * @type {string}
     */
    get resolutionMode(): string;
    /**
     * Load the application configuration file and apply application properties and fill the asset
     * registry.
     *
     * @param {string} url - The URL of the configuration file to load.
     * @param {ConfigureAppCallback} callback - The Function called when the configuration file is
     * loaded and parsed (or an error occurs).
     */
    configure(url: string, callback: ConfigureAppCallback): void;
    /**
     * Load all assets in the asset registry that are marked as 'preload'.
     *
     * @param {PreloadAppCallback} callback - Function called when all assets are loaded.
     */
    preload(callback: PreloadAppCallback): void;
    _preloadScripts(sceneData: any, callback: any): void;
    _handleAreaLightDataProperty(prop: any): void;
    _parseApplicationProperties(props: any, callback: any): void;
    _width: any;
    _height: any;
    /**
     * @param {string[]} urls - List of URLs to load.
     * @param {Function} callback - Callback function.
     * @private
     */
    private _loadLibraries;
    /**
     * Insert scene name/urls into the registry.
     *
     * @param {*} scenes - Scenes to add to the scene registry.
     * @private
     */
    private _parseScenes;
    /**
     * Insert assets into registry.
     *
     * @param {*} assets - Assets to insert.
     * @private
     */
    private _parseAssets;
    /**
     * @param {Scene} scene - The scene.
     * @returns {Array} - The list of scripts that are referenced by the scene.
     * @private
     */
    private _getScriptReferences;
    /**
     * Start the application. This function does the following:
     *
     * 1. Fires an event on the application named 'start'
     * 2. Calls initialize for all components on entities in the hierarchy
     * 3. Fires an event on the application named 'initialize'
     * 4. Calls postInitialize for all components on entities in the hierarchy
     * 5. Fires an event on the application named 'postinitialize'
     * 6. Starts executing the main loop of the application
     *
     * This function is called internally by PlayCanvas applications made in the Editor but you
     * will need to call start yourself if you are using the engine stand-alone.
     *
     * @example
     * app.start();
     */
    start(): void;
    /**
     * Update all input devices managed by the application.
     *
     * @param {number} dt - The time in seconds since the last update.
     * @private
     */
    private inputUpdate;
    /**
     * Update the application. This function will call the update functions and then the postUpdate
     * functions of all enabled components. It will then update the current state of all connected
     * input devices. This function is called internally in the application's main loop and does
     * not need to be called explicitly.
     *
     * @param {number} dt - The time delta in seconds since the last frame.
     */
    update(dt: number): void;
    /**
     * Render the application's scene. More specifically, the scene's {@link LayerComposition} is
     * rendered. This function is called internally in the application's main loop and does not
     * need to be called explicitly.
     */
    render(): void;
    renderComposition(layerComposition: any): void;
    /**
     * @param {number} now - The timestamp passed to the requestAnimationFrame callback.
     * @param {number} dt - The time delta in seconds since the last frame. This is subject to the
     * application's time scale and max delta values.
     * @param {number} ms - The time in milliseconds since the last frame.
     * @private
     */
    private _fillFrameStatsBasic;
    /** @private */
    private _fillFrameStats;
    /**
     * Controls how the canvas fills the window and resizes when the window changes.
     *
     * @param {string} mode - The mode to use when setting the size of the canvas. Can be:
     *
     * - {@link FILLMODE_NONE}: the canvas will always match the size provided.
     * - {@link FILLMODE_FILL_WINDOW}: the canvas will simply fill the window, changing aspect ratio.
     * - {@link FILLMODE_KEEP_ASPECT}: the canvas will grow to fill the window as best it can while
     * maintaining the aspect ratio.
     *
     * @param {number} [width] - The width of the canvas (only used when mode is {@link FILLMODE_NONE}).
     * @param {number} [height] - The height of the canvas (only used when mode is {@link FILLMODE_NONE}).
     */
    setCanvasFillMode(mode: string, width?: number, height?: number): void;
    /**
     * Change the resolution of the canvas, and set the way it behaves when the window is resized.
     *
     * @param {string} mode - The mode to use when setting the resolution. Can be:
     *
     * - {@link RESOLUTION_AUTO}: if width and height are not provided, canvas will be resized to
     * match canvas client size.
     * - {@link RESOLUTION_FIXED}: resolution of canvas will be fixed.
     *
     * @param {number} [width] - The horizontal resolution, optional in AUTO mode, if not provided
     * canvas clientWidth is used.
     * @param {number} [height] - The vertical resolution, optional in AUTO mode, if not provided
     * canvas clientHeight is used.
     */
    setCanvasResolution(mode: string, width?: number, height?: number): void;
    /**
     * Queries the visibility of the window or tab in which the application is running.
     *
     * @returns {boolean} True if the application is not visible and false otherwise.
     */
    isHidden(): boolean;
    /**
     * Called when the visibility state of the current tab/window changes.
     *
     * @private
     */
    private onVisibilityChange;
    /**
     * Resize the application's canvas element in line with the current fill mode.
     *
     * - In {@link FILLMODE_KEEP_ASPECT} mode, the canvas will grow to fill the window as best it
     * can while maintaining the aspect ratio.
     * - In {@link FILLMODE_FILL_WINDOW} mode, the canvas will simply fill the window, changing
     * aspect ratio.
     * - In {@link FILLMODE_NONE} mode, the canvas will always match the size provided.
     *
     * @param {number} [width] - The width of the canvas. Only used if current fill mode is {@link FILLMODE_NONE}.
     * @param {number} [height] - The height of the canvas. Only used if current fill mode is {@link FILLMODE_NONE}.
     * @returns {object} A object containing the values calculated to use as width and height.
     */
    resizeCanvas(width?: number, height?: number): object;
    /**
     * Updates the {@link GraphicsDevice} canvas size to match the canvas size on the document
     * page. It is recommended to call this function when the canvas size changes (e.g on window
     * resize and orientation change events) so that the canvas resolution is immediately updated.
     */
    updateCanvasSize(): void;
    /**
     * Event handler called when all code libraries have been loaded. Code libraries are passed
     * into the constructor of the Application and the application won't start running or load
     * packs until all libraries have been loaded.
     *
     * @private
     */
    private onLibrariesLoaded;
    /**
     * Apply scene settings to the current scene. Useful when your scene settings are parsed or
     * generated from a non-URL source.
     *
     * @param {object} settings - The scene settings to be applied.
     * @param {object} settings.physics - The physics settings to be applied.
     * @param {number[]} settings.physics.gravity - The world space vector representing global
     * gravity in the physics simulation. Must be a fixed size array with three number elements,
     * corresponding to each axis [ X, Y, Z ].
     * @param {object} settings.render - The rendering settings to be applied.
     * @param {number[]} settings.render.global_ambient - The color of the scene's ambient light.
     * Must be a fixed size array with three number elements, corresponding to each color channel
     * [ R, G, B ].
     * @param {string} settings.render.fog - The type of fog used by the scene. Can be:
     *
     * - {@link FOG_NONE}
     * - {@link FOG_LINEAR}
     * - {@link FOG_EXP}
     * - {@link FOG_EXP2}
     *
     * @param {number[]} settings.render.fog_color - The color of the fog (if enabled). Must be a
     * fixed size array with three number elements, corresponding to each color channel [ R, G, B ].
     * @param {number} settings.render.fog_density - The density of the fog (if enabled). This
     * property is only valid if the fog property is set to {@link FOG_EXP} or {@link FOG_EXP2}.
     * @param {number} settings.render.fog_start - The distance from the viewpoint where linear fog
     * begins. This property is only valid if the fog property is set to {@link FOG_LINEAR}.
     * @param {number} settings.render.fog_end - The distance from the viewpoint where linear fog
     * reaches its maximum. This property is only valid if the fog property is set to {@link FOG_LINEAR}.
     * @param {number} settings.render.gamma_correction - The gamma correction to apply when
     * rendering the scene. Can be:
     *
     * - {@link GAMMA_NONE}
     * - {@link GAMMA_SRGB}
     *
     * @param {number} settings.render.tonemapping - The tonemapping transform to apply when
     * writing fragments to the frame buffer. Can be:
     *
     * - {@link TONEMAP_LINEAR}
     * - {@link TONEMAP_FILMIC}
     * - {@link TONEMAP_HEJL}
     * - {@link TONEMAP_ACES}
     *
     * @param {number} settings.render.exposure - The exposure value tweaks the overall brightness
     * of the scene.
     * @param {number|null} [settings.render.skybox] - The asset ID of the cube map texture to be
     * used as the scene's skybox. Defaults to null.
     * @param {number} settings.render.skyboxIntensity - Multiplier for skybox intensity.
     * @param {number} settings.render.skyboxMip - The mip level of the skybox to be displayed.
     * Only valid for prefiltered cubemap skyboxes.
     * @param {number[]} settings.render.skyboxRotation - Rotation of skybox.
     * @param {number} settings.render.lightmapSizeMultiplier - The lightmap resolution multiplier.
     * @param {number} settings.render.lightmapMaxResolution - The maximum lightmap resolution.
     * @param {number} settings.render.lightmapMode - The lightmap baking mode. Can be:
     *
     * - {@link BAKE_COLOR}: single color lightmap
     * - {@link BAKE_COLORDIR}: single color lightmap + dominant light direction (used for bump/specular)
     *
     * @param {boolean} settings.render.ambientBake - Enable baking ambient light into lightmaps.
     * @param {number} settings.render.ambientBakeNumSamples - Number of samples to use when baking ambient light.
     * @param {number} settings.render.ambientBakeSpherePart - How much of the sphere to include when baking ambient light.
     * @param {number} settings.render.ambientBakeOcclusionBrightness - Brighness of the baked ambient occlusion.
     * @param {number} settings.render.ambientBakeOcclusionContrast - Contrast of the baked ambient occlusion.
     *
     * Only lights with bakeDir=true will be used for generating the dominant light direction.
     * @example
     *
     * var settings = {
     *     physics: {
     *         gravity: [0, -9.8, 0]
     *     },
     *     render: {
     *         fog_end: 1000,
     *         tonemapping: 0,
     *         skybox: null,
     *         fog_density: 0.01,
     *         gamma_correction: 1,
     *         exposure: 1,
     *         fog_start: 1,
     *         global_ambient: [0, 0, 0],
     *         skyboxIntensity: 1,
     *         skyboxRotation: [0, 0, 0],
     *         fog_color: [0, 0, 0],
     *         lightmapMode: 1,
     *         fog: 'none',
     *         lightmapMaxResolution: 2048,
     *         skyboxMip: 2,
     *         lightmapSizeMultiplier: 16
     *     }
     * };
     * app.applySceneSettings(settings);
     */
    applySceneSettings(settings: {
        physics: {
            gravity: number[];
        };
        render: {
            global_ambient: number[];
            fog: string;
            fog_color: number[];
            fog_density: number;
            fog_start: number;
            fog_end: number;
            gamma_correction: number;
            tonemapping: number;
            exposure: number;
            skybox?: number | null;
            skyboxIntensity: number;
            skyboxMip: number;
            skyboxRotation: number[];
            lightmapSizeMultiplier: number;
            lightmapMaxResolution: number;
            lightmapMode: number;
            ambientBake: boolean;
            ambientBakeNumSamples: number;
            ambientBakeSpherePart: number;
            ambientBakeOcclusionBrightness: number;
            ambientBakeOcclusionContrast: number;
        };
    }): void;
    /**
     * Sets the area light LUT asset for this app.
     *
     * @param {Asset} asset - LUT asset of type `binary` to be set.
     */
    setAreaLightLuts(asset: Asset): void;
    /**
     * Sets the skybox asset to current scene, and subscribes to asset load/change events.
     *
     * @param {Asset} asset - Asset of type `skybox` to be set to, or null to remove skybox.
     */
    setSkybox(asset: Asset): void;
    /** @private */
    private _firstBake;
    /** @private */
    private _firstBatch;
    /**
     * Provide an opportunity to modify the timestamp supplied by requestAnimationFrame.
     *
     * @param {number} [timestamp] - The timestamp supplied by requestAnimationFrame.
     * @returns {number|undefined} The modified timestamp.
     * @ignore
     */
    _processTimestamp(timestamp?: number): number | undefined;
    /**
     * Draws a single line. Line start and end coordinates are specified in world-space. The line
     * will be flat-shaded with the specified color.
     *
     * @param {Vec3} start - The start world-space coordinate of the line.
     * @param {Vec3} end - The end world-space coordinate of the line.
     * @param {Color} [color] - The color of the line. It defaults to white if not specified.
     * @param {boolean} [depthTest] - Specifies if the line is depth tested against the depth
     * buffer. Defaults to true.
     * @param {Layer} [layer] - The layer to render the line into. Defaults to {@link LAYERID_IMMEDIATE}.
     * @example
     * // Render a 1-unit long white line
     * var start = new pc.Vec3(0, 0, 0);
     * var end = new pc.Vec3(1, 0, 0);
     * app.drawLine(start, end);
     * @example
     * // Render a 1-unit long red line which is not depth tested and renders on top of other geometry
     * var start = new pc.Vec3(0, 0, 0);
     * var end = new pc.Vec3(1, 0, 0);
     * app.drawLine(start, end, pc.Color.RED, false);
     * @example
     * // Render a 1-unit long white line into the world layer
     * var start = new pc.Vec3(0, 0, 0);
     * var end = new pc.Vec3(1, 0, 0);
     * var worldLayer = app.scene.layers.getLayerById(pc.LAYERID_WORLD);
     * app.drawLine(start, end, pc.Color.WHITE, true, worldLayer);
     */
    drawLine(start: Vec3, end: Vec3, color?: Color, depthTest?: boolean, layer?: Layer): void;
    /**
     * Renders an arbitrary number of discrete line segments. The lines are not connected by each
     * subsequent point in the array. Instead, they are individual segments specified by two
     * points. Therefore, the lengths of the supplied position and color arrays must be the same
     * and also must be a multiple of 2. The colors of the ends of each line segment will be
     * interpolated along the length of each line.
     *
     * @param {Vec3[]} positions - An array of points to draw lines between. The length of the
     * array must be a multiple of 2.
     * @param {Color[]} colors - An array of colors to color the lines. This must be the same
     * length as the position array. The length of the array must also be a multiple of 2.
     * @param {boolean} [depthTest] - Specifies if the lines are depth tested against the depth
     * buffer. Defaults to true.
     * @param {Layer} [layer] - The layer to render the lines into. Defaults to {@link LAYERID_IMMEDIATE}.
     * @example
     * // Render a single line, with unique colors for each point
     * var start = new pc.Vec3(0, 0, 0);
     * var end = new pc.Vec3(1, 0, 0);
     * app.drawLines([start, end], [pc.Color.RED, pc.Color.WHITE]);
     * @example
     * // Render 2 discrete line segments
     * var points = [
     *     // Line 1
     *     new pc.Vec3(0, 0, 0),
     *     new pc.Vec3(1, 0, 0),
     *     // Line 2
     *     new pc.Vec3(1, 1, 0),
     *     new pc.Vec3(1, 1, 1)
     * ];
     * var colors = [
     *     // Line 1
     *     pc.Color.RED,
     *     pc.Color.YELLOW,
     *     // Line 2
     *     pc.Color.CYAN,
     *     pc.Color.BLUE
     * ];
     * app.drawLines(points, colors);
     */
    drawLines(positions: Vec3[], colors: Color[], depthTest?: boolean, layer?: Layer): void;
    /**
     * Renders an arbitrary number of discrete line segments. The lines are not connected by each
     * subsequent point in the array. Instead, they are individual segments specified by two
     * points.
     *
     * @param {number[]} positions - An array of points to draw lines between. Each point is
     * represented by 3 numbers - x, y and z coordinate.
     * @param {number[]} colors - An array of colors to color the lines. This must be the same
     * length as the position array. The length of the array must also be a multiple of 2.
     * @param {boolean} [depthTest] - Specifies if the lines are depth tested against the depth
     * buffer. Defaults to true.
     * @param {Layer} [layer] - The layer to render the lines into. Defaults to {@link LAYERID_IMMEDIATE}.
     * @example
     * // Render 2 discrete line segments
     * var points = [
     *     // Line 1
     *     0, 0, 0,
     *     1, 0, 0,
     *     // Line 2
     *     1, 1, 0,
     *     1, 1, 1
     * ];
     * var colors = [
     *     // Line 1
     *     1, 0, 0, 1,  // red
     *     0, 1, 0, 1,  // green
     *     // Line 2
     *     0, 0, 1, 1,  // blue
     *     1, 1, 1, 1   // white
     * ];
     * app.drawLineArrays(points, colors);
     */
    drawLineArrays(positions: number[], colors: number[], depthTest?: boolean, layer?: Layer): void;
    /**
     * Draws a wireframe sphere with center, radius and color.
     *
     * @param {Vec3} center - The center of the sphere.
     * @param {number} radius - The radius of the sphere.
     * @param {Color} [color] - The color of the sphere. It defaults to white if not specified.
     * @param {number} [segments] - Number of line segments used to render the circles forming the
     * sphere. Defaults to 20.
     * @param {boolean} [depthTest] - Specifies if the sphere lines are depth tested against the
     * depth buffer. Defaults to true.
     * @param {Layer} [layer] - The layer to render the sphere into. Defaults to {@link LAYERID_IMMEDIATE}.
     * @example
     * // Render a red wire sphere with radius of 1
     * var center = new pc.Vec3(0, 0, 0);
     * app.drawWireSphere(center, 1.0, pc.Color.RED);
     * @ignore
     */
    drawWireSphere(center: Vec3, radius: number, color?: Color, segments?: number, depthTest?: boolean, layer?: Layer): void;
    /**
     * Draws a wireframe axis aligned box specified by min and max points and color.
     *
     * @param {Vec3} minPoint - The min corner point of the box.
     * @param {Vec3} maxPoint - The max corner point of the box.
     * @param {Color} [color] - The color of the sphere. It defaults to white if not specified.
     * @param {boolean} [depthTest] - Specifies if the sphere lines are depth tested against the
     * depth buffer. Defaults to true.
     * @param {Layer} [layer] - The layer to render the sphere into. Defaults to {@link LAYERID_IMMEDIATE}.
     * @example
     * // Render a red wire aligned box
     * var min = new pc.Vec3(-1, -1, -1);
     * var max = new pc.Vec3(1, 1, 1);
     * app.drawWireAlignedBox(min, max, pc.Color.RED);
     * @ignore
     */
    drawWireAlignedBox(minPoint: Vec3, maxPoint: Vec3, color?: Color, depthTest?: boolean, layer?: Layer): void;
    /**
     * Draw meshInstance at this frame
     *
     * @param {MeshInstance} meshInstance - The mesh instance to draw.
     * @param {Layer} [layer] - The layer to render the mesh instance into. Defaults to
     * {@link LAYERID_IMMEDIATE}.
     * @ignore
     */
    drawMeshInstance(meshInstance: MeshInstance, layer?: Layer): void;
    /**
     * Draw mesh at this frame.
     *
     * @param {Mesh} mesh - The mesh to draw.
     * @param {Material} material - The material to use to render the mesh.
     * @param {Mat4} matrix - The matrix to use to render the mesh.
     * @param {Layer} [layer] - The layer to render the mesh into. Defaults to {@link LAYERID_IMMEDIATE}.
     * @ignore
     */
    drawMesh(mesh: Mesh, material: Material, matrix: Mat4, layer?: Layer): void;
    /**
     * Draw quad of size [-0.5, 0.5] at this frame.
     *
     * @param {Mat4} matrix - The matrix to use to render the quad.
     * @param {Material} material - The material to use to render the quad.
     * @param {Layer} [layer] - The layer to render the quad into. Defaults to {@link LAYERID_IMMEDIATE}.
     * @ignore
     */
    drawQuad(matrix: Mat4, material: Material, layer?: Layer): void;
    /**
     * Draws a texture at [x, y] position on screen, with size [width, height]. The origin of the
     * screen is top-left [0, 0]. Coordinates and sizes are in projected space (-1 .. 1).
     *
     * @param {number} x - The x coordinate on the screen of the top left corner of the texture.
     * Should be in the range [-1, 1].
     * @param {number} y - The y coordinate on the screen of the top left corner of the texture.
     * Should be in the range [-1, 1].
     * @param {number} width - The width of the rectangle of the rendered texture. Should be in the
     * range [0, 2].
     * @param {number} height - The height of the rectangle of the rendered texture. Should be in
     * the range [0, 2].
     * @param {Texture} texture - The texture to render.
     * @param {Material} material - The material used when rendering the texture.
     * @param {Layer} [layer] - The layer to render the texture into. Defaults to {@link LAYERID_IMMEDIATE}.
     * @ignore
     */
    drawTexture(x: number, y: number, width: number, height: number, texture: Texture, material: Material, layer?: Layer): void;
    /**
     * Draws a depth texture at [x, y] position on screen, with size [width, height]. The origin of
     * the screen is top-left [0, 0]. Coordinates and sizes are in projected space (-1 .. 1).
     *
     * @param {number} x - The x coordinate on the screen of the top left corner of the texture.
     * Should be in the range [-1, 1].
     * @param {number} y - The y coordinate on the screen of the top left corner of the texture.
     * Should be in the range [-1, 1].
     * @param {number} width - The width of the rectangle of the rendered texture. Should be in the
     * range [0, 2].
     * @param {number} height - The height of the rectangle of the rendered texture. Should be in
     * the range [0, 2].
     * @param {Layer} [layer] - The layer to render the texture into. Defaults to {@link LAYERID_IMMEDIATE}.
     * @ignore
     */
    drawDepthTexture(x: number, y: number, width: number, height: number, layer?: Layer): void;
    /**
     * Destroys application and removes all event listeners at the end of the current engine frame
     * update. However, if called outside of the engine frame update, calling destroy() will
     * destroy the application immediately.
     *
     * @example
     * app.destroy();
     */
    destroy(): void;
    controller: any;
    /**
     * Get entity from the index by guid.
     *
     * @param {string} guid - The GUID to search for.
     * @returns {Entity} The Entity with the GUID or null.
     * @ignore
     */
    getEntityFromIndex(guid: string): Entity;
    /**
     * @param {Scene} scene - The scene.
     * @private
     */
    private _registerSceneImmediate;
}

declare class CameraComponentData {
    enabled: boolean;
}

/**
 * Used to add and remove {@link CameraComponent}s from Entities. It also holds an array of all
 * active cameras.
 *
 * @augments ComponentSystem
 */
declare class CameraComponentSystem extends ComponentSystem {
    /**
     * Holds all the active camera components.
     *
     * @type {CameraComponent[]}
     */
    cameras: CameraComponent[];
    id: string;
    ComponentType: typeof CameraComponent;
    DataType: typeof CameraComponentData;
    schema: string[];
    initializeComponentData(component: any, data: any, properties: any): void;
    cloneComponent(entity: any, clone: any): Component;
    onBeforeRemove(entity: any, component: any): void;
    onUpdate(dt: any): void;
    onAppPrerender(): void;
    addCamera(camera: any): void;
    removeCamera(camera: any): void;
}









/**
 * Callback used by {@link CameraComponentcalculateTransform } and {@link CameraComponentcalculateProjection }.
 */
export type CalculateMatrixCallback = (transformMatrix: Mat4, view: number) => any;
/**
 * Callback used by {@link CameraComponent#calculateTransform} and {@link CameraComponent#calculateProjection}.
 *
 * @callback CalculateMatrixCallback
 * @param {Mat4} transformMatrix - Output of the function.
 * @param {number} view - Type of view. Can be {@link VIEW_CENTER}, {@link VIEW_LEFT} or {@link VIEW_RIGHT}. Left and right are only used in stereo rendering.
 */
/**
 * The Camera Component enables an Entity to render the scene. A scene requires at least one
 * enabled camera component to be rendered. Note that multiple camera components can be enabled
 * simultaneously (for split-screen or offscreen rendering, for example).
 *
 * ```javascript
 * // Add a pc.CameraComponent to an entity
 * var entity = new pc.Entity();
 * entity.addComponent('camera', {
 *     nearClip: 1,
 *     farClip: 100,
 *     fov: 55
 * });
 *
 * // Get the pc.CameraComponent on an entity
 * var cameraComponent = entity.camera;
 *
 * // Update a property on a camera component
 * entity.camera.nearClip = 2;
 * ```
 *
 * @property {number} projection The type of projection used to render the camera. Can be:
 *
 * - {@link PROJECTION_PERSPECTIVE}: A perspective projection. The camera frustum
 * resembles a truncated pyramid.
 * - {@link PROJECTION_ORTHOGRAPHIC}: An orthographic projection. The camera
 * frustum is a cuboid.
 *
 * Defaults to {@link PROJECTION_PERSPECTIVE}.
 * @property {number} aspectRatio The aspect ratio (width divided by height) of the camera. If
 * aspectRatioMode is {@link ASPECT_AUTO}, then this value will be automatically calculated every
 * frame, and you can only read it. If it's ASPECT_MANUAL, you can set the value.
 * @property {number} aspectRatioMode The aspect ratio mode of the camera. Can be:
 *
 * - {@link ASPECT_AUTO}: aspect ratio will be calculated from the current render
 * target's width divided by height.
 * - {@link ASPECT_MANUAL}: use the aspectRatio value.
 *
 * Defaults to {@link ASPECT_AUTO}.
 * @property {Color} clearColor The color used to clear the canvas to before the camera starts to
 * render. Defaults to [0.75, 0.75, 0.75, 1].
 * @property {number} farClip The distance from the camera after which no rendering will take
 * place. Defaults to 1000.
 * @property {number} fov The field of view of the camera in degrees. Usually this is the Y-axis
 * field of view, see {@link CameraComponent#horizontalFov}. Used for
 * {@link PROJECTION_PERSPECTIVE} cameras only. Defaults to 45.
 * @property {boolean} horizontalFov Set which axis to use for the Field of View calculation.
 * Defaults to false.
 * @property {number} nearClip The distance from the camera before which no rendering will take
 * place. Defaults to 0.1.
 * @property {number} orthoHeight The half-height of the orthographic view window (in the Y-axis).
 * Used for {@link PROJECTION_ORTHOGRAPHIC} cameras only. Defaults to 10.
 * @property {Vec4} scissorRect Clips all pixels which are not in the rectangle. The order of the
 * values is [x, y, width, height]. Defaults to [0, 0, 1, 1].
 * @property {boolean} frustumCulling Controls the culling of mesh instances against the camera
 * frustum, i.e. if objects outside of camera should be omitted from rendering. If false, all mesh
 * instances in the scene are rendered by the camera, regardless of visibility. Defaults to false.
 * @property {CalculateMatrixCallback} calculateTransform Custom function you can provide to
 * calculate the camera transformation matrix manually. Can be used for complex effects like
 * reflections. Function is called using component's scope. Arguments:
 *
 * - {@link Mat4} transformMatrix: output of the function.
 * - view: Type of view. Can be {@link VIEW_CENTER}, {@link VIEW_LEFT} or {@link VIEW_RIGHT}.
 *
 * Left and right are only used in stereo rendering.
 * @property {CalculateMatrixCallback} calculateProjection Custom function you can provide to
 * calculate the camera projection matrix manually. Can be used for complex effects like doing
 * oblique projection. Function is called using component's scope. Arguments:
 *
 * - {@link Mat4} transformMatrix: output of the function
 * - view: Type of view. Can be {@link VIEW_CENTER}, {@link VIEW_LEFT} or {@link VIEW_RIGHT}.
 *
 * Left and right are only used in stereo rendering.
 * @property {boolean} cullFaces If true the camera will take material.cull into account. Otherwise
 * both front and back faces will be rendered. Defaults to true.
 * @property {boolean} flipFaces If true the camera will invert front and back faces. Can be useful
 * for reflection rendering. Defaults to false.
 * @augments Component
 */
declare class CameraComponent extends Component {
    /**
     * Create a new CameraComponent instance.
     *
     * @param {CameraComponentSystem} system - The ComponentSystem that created this Component.
     * @param {Entity} entity - The Entity that this Component is attached to.
     */
    constructor(system: CameraComponentSystem, entity: Entity);

    set aspectRatioMode(arg: number);
    get aspectRatioMode(): number;

    set calculateProjection(arg: CalculateMatrixCallback);
    get calculateProjection(): CalculateMatrixCallback;

    set calculateTransform(arg: CalculateMatrixCallback);
    get calculateTransform(): CalculateMatrixCallback;

    set clearColor(arg: Color);
    get clearColor(): Color;

    set cullFaces(arg: boolean);
    get cullFaces(): boolean;

    set farClip(arg: number);
    get farClip(): number;

    set flipFaces(arg: boolean);
    get flipFaces(): boolean;

    set fov(arg: number);
    get fov(): number;

    set frustumCulling(arg: boolean);
    get frustumCulling(): boolean;

    set horizontalFov(arg: boolean);
    get horizontalFov(): boolean;

    set nearClip(arg: number);
    get nearClip(): number;

    set orthoHeight(arg: number);
    get orthoHeight(): number;

    set projection(arg: number);
    get projection(): number;

    set scissorRect(arg: Vec4);
    get scissorRect(): Vec4;

    /**
     * Custom function that is called when postprocessing should execute.
     *
     * @type {Function}
     * @ignore
     */
    onPostprocessing: Function;
    /**
     * Custom function that is called before the camera renders the scene.
     *
     * @type {Function}
     */
    onPreRender: Function;
    /**
     * Custom function that is called after the camera renders the scene.
     *
     * @type {Function}
     */
    onPostRender: Function;
    /**
     * A counter of requests of depth map rendering.
     *
     * @type {number}
     * @private
     */
    private _renderSceneDepthMap;
    /**
     * A counter of requests of color map rendering.
     *
     * @type {number}
     * @private
     */
    private _renderSceneColorMap;
    _camera: Camera;
    _priority: number;
    _disablePostEffectsLayer: number;
    _postEffects: PostEffectQueue;
    /**
     * Queries the camera component's underlying Camera instance.
     *
     * @type {Camera}
     * @ignore
     */
    get camera(): Camera;
    /**
     * If true the camera will clear the color buffer to the color set in clearColor. Defaults to true.
     *
     * @type {boolean}
     */
    set clearColorBuffer(arg: boolean);
    get clearColorBuffer(): boolean;
    /**
     * If true the camera will clear the depth buffer. Defaults to true.
     *
     * @type {boolean}
     */
    set clearDepthBuffer(arg: boolean);
    get clearDepthBuffer(): boolean;
    /**
     * If true the camera will clear the stencil buffer. Defaults to true.
     *
     * @type {boolean}
     */
    set clearStencilBuffer(arg: boolean);
    get clearStencilBuffer(): boolean;
    /**
     * Layer ID of a layer on which the postprocessing of the camera stops being applied to.
     * Defaults to LAYERID_UI, which causes post processing to not be applied to UI layer and any
     * following layers for the camera. Set to undefined for post-processing to be applied to all
     * layers of the camera.
     *
     * @type {number}
     */
    set disablePostEffectsLayer(arg: number);
    get disablePostEffectsLayer(): number;
    _enableDepthLayer(value: any): boolean;
    /**
     * Request the scene to generate a texture containing the scene color map. Note that this call
     * is accummulative, and for each enable request, a disable request need to be called.
     *
     * @param {boolean} enabled - True to request the generation, false to disable it.
     */
    requestSceneColorMap(enabled: boolean): void;
    get renderSceneColorMap(): boolean;
    /**
     * Request the scene to generate a texture containing the scene depth map. Note that this call
     * is accummulative, and for each enable request, a disable request need to be called.
     *
     * @param {boolean} enabled - True to request the generation, false to disable it.
     */
    requestSceneDepthMap(enabled: boolean): void;
    get renderSceneDepthMap(): boolean;
    /**
     * Queries the camera's frustum shape.
     *
     * @type {Frustum}
     */
    get frustum(): Frustum;
    /**
     * An array of layer IDs ({@link Layer#id}) to which this camera should belong. Don't push,
     * pop, splice or modify this array, if you want to change it, set a new one instead. Defaults
     * to [LAYERID_WORLD, LAYERID_DEPTH, LAYERID_SKYBOX, LAYERID_UI, LAYERID_IMMEDIATE].
     *
     * @type {number[]}
     */
    set layers(arg: number[]);
    get layers(): number[];
    /**
     * The post effects queue for this camera. Use this to add or remove post effects from the camera.
     *
     * @type {PostEffectQueue}
     */
    get postEffectsEnabled(): PostEffectQueue;
    get postEffects(): PostEffectQueue;
    /**
     * Controls the order in which cameras are rendered. Cameras with smaller values for priority
     * are rendered first. Defaults to 0.
     *
     * @type {number}
     */
    set priority(arg: number);
    get priority(): number;
    /**
     * Queries the camera's projection matrix.
     *
     * @type {Mat4}
     */
    get projectionMatrix(): Mat4;
    /**
     * Controls where on the screen the camera will be rendered in normalized screen coordinates.
     * Defaults to [0, 0, 1, 1].
     *
     * @type {Vec4}
     */
    set rect(arg: Vec4);
    get rect(): Vec4;
    /**
     * Render target to which rendering of the cameras is performed. If not set, it will render
     * simply to the screen.
     *
     * @type {RenderTarget}
     */
    set renderTarget(arg: any);
    get renderTarget(): any;
    /**
     * Queries the camera's view matrix.
     *
     * @type {Mat4}
     */
    get viewMatrix(): Mat4;
    dirtyLayerCompositionCameras(): void;
    /**
     * Convert a point from 2D screen space to 3D world space.
     *
     * @param {number} screenx - X coordinate on PlayCanvas' canvas element. Should be in the range
     * 0 to `canvas.offsetWidth` of the application's canvas element.
     * @param {number} screeny - Y coordinate on PlayCanvas' canvas element. Should be in the range
     * 0 to `canvas.offsetHeight` of the application's canvas element.
     * @param {number} cameraz - The distance from the camera in world space to create the new
     * point.
     * @param {Vec3} [worldCoord] - 3D vector to receive world coordinate result.
     * @example
     * // Get the start and end points of a 3D ray fired from a screen click position
     * var start = entity.camera.screenToWorld(clickX, clickY, entity.camera.nearClip);
     * var end = entity.camera.screenToWorld(clickX, clickY, entity.camera.farClip);
     *
     * // Use the ray coordinates to perform a raycast
     * app.systems.rigidbody.raycastFirst(start, end, function (result) {
     *     console.log("Entity " + result.entity.name + " was selected");
     * });
     * @returns {Vec3} The world space coordinate.
     */
    screenToWorld(screenx: number, screeny: number, cameraz: number, worldCoord?: Vec3): Vec3;
    /**
     * Convert a point from 3D world space to 2D screen space.
     *
     * @param {Vec3} worldCoord - The world space coordinate.
     * @param {Vec3} [screenCoord] - 3D vector to receive screen coordinate result.
     * @returns {Vec3} The screen space coordinate.
     */
    worldToScreen(worldCoord: Vec3, screenCoord?: Vec3): Vec3;
    onAppPrerender(): void;
    addCameraToLayers(): void;
    removeCameraFromLayers(): void;
    onLayersChanged(oldComp: any, newComp: any): void;
    onLayerAdded(layer: any): void;
    onLayerRemoved(layer: any): void;
    onRemove(): void;
    /**
     * Calculates aspect ratio value for a given render target.
     *
     * @param {RenderTarget} [rt] - Optional render target. If unspecified, the backbuffer is used.
     * @returns {number} The aspect ratio of the render target (or backbuffer).
     */
    calculateAspectRatio(rt?: RenderTarget): number;
    /**
     * Prepare the camera for frame rendering.
     *
     * @param {RenderTarget} rt - Render target to which rendering will be performed. Will affect
     * camera's aspect ratio, if aspectRatioMode is {@link ASPECT_AUTO}.
     * @ignore
     */
    frameUpdate(rt: RenderTarget): void;
    aspectRatio: number;
    /**
     * Attempt to start XR session with this camera.
     *
     * @param {string} type - The type of session. Can be one of the following:
     *
     * - {@link XRTYPE_INLINE}: Inline - always available type of session. It has limited feature
     * availability and is rendered into HTML element.
     * - {@link XRTYPE_VR}: Immersive VR - session that provides exclusive access to the VR device
     * with the best available tracking features.
     * - {@link XRTYPE_AR}: Immersive AR - session that provides exclusive access to the VR/AR
     * device that is intended to be blended with the real-world environment.
     *
     * @param {string} spaceType - Reference space type. Can be one of the following:
     *
     * - {@link XRSPACE_VIEWER}: Viewer - always supported space with some basic tracking
     * capabilities.
     * - {@link XRSPACE_LOCAL}: Local - represents a tracking space with a native origin near the
     * viewer at the time of creation. It is meant for seated or basic local XR sessions.
     * - {@link XRSPACE_LOCALFLOOR}: Local Floor - represents a tracking space with a native origin
     * at the floor in a safe position for the user to stand. The y-axis equals 0 at floor level.
     * Floor level value might be estimated by the underlying platform. It is meant for seated or
     * basic local XR sessions.
     * - {@link XRSPACE_BOUNDEDFLOOR}: Bounded Floor - represents a tracking space with its native
     * origin at the floor, where the user is expected to move within a pre-established boundary.
     * - {@link XRSPACE_UNBOUNDED}: Unbounded - represents a tracking space where the user is
     * expected to move freely around their environment, potentially long distances from their
     * starting point.
     *
     * @param {object} [options] - Object with options for XR session initialization.
     * @param {string[]} [options.optionalFeatures] - Optional features for XRSession start. It is
     * used for getting access to additional WebXR spec extensions.
     * @param {boolean} [options.imageTracking] - Set to true to attempt to enable {@link XrImageTracking}.
     * @param {boolean} [options.planeDetection] - Set to true to attempt to enable {@link XrPlaneDetection}.
     * @param {XrErrorCallback} [options.callback] - Optional callback function called once the
     * session is started. The callback has one argument Error - it is null if the XR session
     * started successfully.
     * @param {object} [options.depthSensing] - Optional object with depth sensing parameters to
     * attempt to enable {@link XrDepthSensing}.
     * @param {string} [options.depthSensing.usagePreference] - Optional usage preference for depth
     * sensing, can be 'cpu-optimized' or 'gpu-optimized' (XRDEPTHSENSINGUSAGE_*), defaults to
     * 'cpu-optimized'. Most preferred and supported will be chosen by the underlying depth sensing
     * system.
     * @param {string} [options.depthSensing.dataFormatPreference] - Optional data format
     * preference for depth sensing. Can be 'luminance-alpha' or 'float32' (XRDEPTHSENSINGFORMAT_*),
     * defaults to 'luminance-alpha'. Most preferred and supported will be chosen by the underlying
     * depth sensing system.
     * @example
     * // On an entity with a camera component
     * this.entity.camera.startXr(pc.XRTYPE_VR, pc.XRSPACE_LOCAL, {
     *     callback: function (err) {
     *         if (err) {
     *             // failed to start XR session
     *         } else {
     *             // in XR
     *         }
     *     }
     * });
     */
    startXr(type: string, spaceType: string, options?: {
        optionalFeatures?: string[];
        imageTracking?: boolean;
        planeDetection?: boolean;
        callback?: XrErrorCallback;
        depthSensing?: {
            usagePreference?: string;
            dataFormatPreference?: string;
        };
    }): void;
    /**
     * Attempt to end XR session of this camera.
     *
     * @param {XrErrorCallback} [callback] - Optional callback function called once session is
     * ended. The callback has one argument Error - it is null if successfully ended XR session.
     * @example
     * // On an entity with a camera component
     * this.entity.camera.endXr(function (err) {
     *     // not anymore in XR
     * });
     */
    endXr(callback?: XrErrorCallback): void;
    copy(source: any): void;
}



/**
 * Used to manage multiple post effects for a camera.
 */
declare class PostEffectQueue {
    /**
     * Create a new PostEffectQueue instance.
     *
     * @param {AppBase} app - The application.
     * @param {CameraComponent} camera - The camera component.
     */
    constructor(app: AppBase, camera: CameraComponent);
    app: AppBase;
    camera: CameraComponent;
    /**
     * Render target where the postprocessed image needs to be rendered to. Defaults to null
     * which is main framebuffer.
     *
     * @type {RenderTarget}
     * @ignore
     */
    destinationRenderTarget: RenderTarget;
    /**
     * All of the post effects in the queue.
     *
     * @type {PostEffect[]}
     * @ignore
     */
    effects: PostEffect[];
    /**
     * If the queue is enabled it will render all of its effects, otherwise it will not render
     * anything.
     *
     * @type {boolean}
     * @ignore
     */
    enabled: boolean;
    depthTarget: any;
    /**
     * Allocate a color buffer texture.
     *
     * @param {number} format - The format of the color buffer.
     * @param {string} name - The name of the color buffer.
     * @returns {Texture} The color buffer texture.
     * @private
     */
    private _allocateColorBuffer;
    /**
     * Creates a render target with the dimensions of the canvas, with an optional depth buffer.
     *
     * @param {boolean} useDepth - Set to true to create a render target with a depth buffer.
     * @param {boolean} hdr - Use HDR render target format.
     * @returns {RenderTarget} The render target.
     * @private
     */
    private _createOffscreenTarget;
    _resizeOffscreenTarget(rt: any): void;
    _destroyOffscreenTarget(rt: any): void;
    /**
     * Adds a post effect to the queue. If the queue is disabled adding a post effect will
     * automatically enable the queue.
     *
     * @param {PostEffect} effect - The post effect to add to the queue.
     */
    addEffect(effect: PostEffect): void;
    _sourceTarget: any;
    _newPostEffect: PostEffect;
    /**
     * Removes a post effect from the queue. If the queue becomes empty it will be disabled
     * automatically.
     *
     * @param {PostEffect} effect - The post effect to remove.
     */
    removeEffect(effect: PostEffect): void;
    _requestDepthMaps(): void;
    _releaseDepthMaps(): void;
    _requestDepthMap(): void;
    _releaseDepthMap(): void;
    /**
     * Removes all the effects from the queue and disables it.
     */
    destroy(): void;
    /**
     * Enables the queue and all of its effects. If there are no effects then the queue will not be
     * enabled.
     */
    enable(): void;
    /**
     * Disables the queue and all of its effects.
     */
    disable(): void;
    /**
     * Handler called when the application's canvas element is resized.
     *
     * @param {number} width - The new width of the canvas.
     * @param {number} height - The new height of the canvas.
     * @private
     */
    private _onCanvasResized;
    resizeRenderTargets(): void;
    onCameraRectChanged(name: any, oldValue: any, newValue: any): void;
}

/** @typedef {import('../../app-base.js').AppBase} AppBase */
/** @typedef {import('./component.js').CameraComponent} CameraComponent */
declare class PostEffect {
    constructor(effect: any, inputTarget: any);
    effect: any;
    inputTarget: any;
    outputTarget: any;
    name: any;
}

declare function partitionSkin(model: any, materialMappings: any, boneLimit: any): void;


/**
 * Generates normal information from the specified positions and triangle indices. See
 * {@link createMesh}.
 *
 * @param {number[]} positions - An array of 3-dimensional vertex positions.
 * @param {number[]} indices - An array of triangle indices.
 * @returns {number[]} An array of 3-dimensional vertex normals.
 * @example
 * var normals = pc.calculateNormals(positions, indices);
 * var tangents = pc.calculateTangents(positions, normals, uvs, indices);
 * var mesh = pc.createMesh(positions, normals, tangents, uvs, indices);
 */
declare function calculateNormals(positions: number[], indices: number[]): number[];
/**
 * Generates tangent information from the specified positions, normals, texture coordinates and
 * triangle indices. See {@link createMesh}.
 *
 * @param {number[]} positions - An array of 3-dimensional vertex positions.
 * @param {number[]} normals - An array of 3-dimensional vertex normals.
 * @param {number[]} uvs - An array of 2-dimensional vertex texture coordinates.
 * @param {number[]} indices - An array of triangle indices.
 * @returns {number[]} An array of 3-dimensional vertex tangents.
 * @example
 * var tangents = pc.calculateTangents(positions, normals, uvs, indices);
 * var mesh = pc.createMesh(positions, normals, tangents, uvs, indices);
 */
declare function calculateTangents(positions: number[], normals: number[], uvs: number[], indices: number[]): number[];
/**
 * Creates a procedural box-shaped mesh.
 *
 * The size, shape and tesselation properties of the box can be controlled via function parameters.
 * By default, the function will create a box centered on the object space origin with a width,
 * length and height of 1.0 unit and 10 segments in either axis (50 triangles per face).
 *
 * Note that the box is created with UVs in the range of 0 to 1 on each face. Additionally, tangent
 * information is generated into the vertex buffer of the box's mesh.
 *
 * @param {GraphicsDevice} device - The graphics device used to manage the mesh.
 * @param {object} [opts] - An object that specifies optional inputs for the function as follows:
 * @param {Vec3} [opts.halfExtents] - The half dimensions of the box in each axis (defaults to
 * [0.5, 0.5, 0.5]).
 * @param {number} [opts.widthSegments] - The number of divisions along the X axis of the box
 * (defaults to 1).
 * @param {number} [opts.lengthSegments] - The number of divisions along the Z axis of the box
 * (defaults to 1).
 * @param {number} [opts.heightSegments] - The number of divisions along the Y axis of the box
 * (defaults to 1).
 * @param {boolean} [opts.calculateTangents] - Generate tangent information (defaults to false).
 * @returns {Mesh} A new box-shaped mesh.
 */
declare function createBox(device: GraphicsDevice, opts?: {
    halfExtents?: Vec3;
    widthSegments?: number;
    lengthSegments?: number;
    heightSegments?: number;
    calculateTangents?: boolean;
}): Mesh;
/**
 * Creates a procedural capsule-shaped mesh.
 *
 * The size, shape and tesselation properties of the capsule can be controlled via function
 * parameters. By default, the function will create a capsule standing vertically centered on the
 * XZ-plane with a radius of 0.25, a height of 1.0, 1 height segment and 10 cap segments.
 *
 * Note that the capsule is created with UVs in the range of 0 to 1. Additionally, tangent
 * information is generated into the vertex buffer of the capsule's mesh.
 *
 * @param {GraphicsDevice} device - The graphics device used to manage the mesh.
 * @param {object} [opts] - An object that specifies optional inputs for the function as follows:
 * @param {number} [opts.radius] - The radius of the tube forming the body of the capsule (defaults
 * to 0.3).
 * @param {number} [opts.height] - The length of the body of the capsule from tip to tip (defaults
 * to 1.0).
 * @param {number} [opts.heightSegments] - The number of divisions along the tubular length of the
 * capsule (defaults to 1).
 * @param {number} [opts.sides] - The number of divisions around the tubular body of the capsule
 * (defaults to 20).
 * @param {boolean} [opts.calculateTangents] - Generate tangent information (defaults to false).
 * @returns {Mesh} A new cylinder-shaped mesh.
 */
declare function createCapsule(device: GraphicsDevice, opts?: {
    radius?: number;
    height?: number;
    heightSegments?: number;
    sides?: number;
    calculateTangents?: boolean;
}): Mesh;
/**
 * Creates a procedural cone-shaped mesh.
 *
 * The size, shape and tesselation properties of the cone can be controlled via function
 * parameters. By default, the function will create a cone standing vertically centered on the
 * XZ-plane with a base radius of 0.5, a height of 1.0, 5 height segments and 20 cap segments.
 *
 * Note that the cone is created with UVs in the range of 0 to 1. Additionally, tangent information
 * is generated into the vertex buffer of the cone's mesh.
 *
 * @param {GraphicsDevice} device - The graphics device used to manage the mesh.
 * @param {object} [opts] - An object that specifies optional inputs for the function as follows:
 * @param {number} [opts.baseRadius] - The base radius of the cone (defaults to 0.5).
 * @param {number} [opts.peakRadius] - The peak radius of the cone (defaults to 0.0).
 * @param {number} [opts.height] - The length of the body of the cone (defaults to 1.0).
 * @param {number} [opts.heightSegments] - The number of divisions along the length of the cone
 * (defaults to 5).
 * @param {number} [opts.capSegments] - The number of divisions around the tubular body of the cone
 * (defaults to 18).
 * @param {boolean} [opts.calculateTangents] - Generate tangent information (defaults to false).
 * @returns {Mesh} A new cone-shaped mesh.
 */
declare function createCone(device: GraphicsDevice, opts?: {
    baseRadius?: number;
    peakRadius?: number;
    height?: number;
    heightSegments?: number;
    capSegments?: number;
    calculateTangents?: boolean;
}): Mesh;
/**
 * Creates a procedural cylinder-shaped mesh.
 *
 * The size, shape and tesselation properties of the cylinder can be controlled via function
 * parameters. By default, the function will create a cylinder standing vertically centered on the
 * XZ-plane with a radius of 0.5, a height of 1.0, 1 height segment and 20 cap segments.
 *
 * Note that the cylinder is created with UVs in the range of 0 to 1. Additionally, tangent
 * information is generated into the vertex buffer of the cylinder's mesh.
 *
 * @param {GraphicsDevice} device - The graphics device used to manage the mesh.
 * @param {object} [opts] - An object that specifies optional inputs for the function as follows:
 * @param {number} [opts.radius] - The radius of the tube forming the body of the cylinder (defaults to 0.5).
 * @param {number} [opts.height] - The length of the body of the cylinder (defaults to 1.0).
 * @param {number} [opts.heightSegments] - The number of divisions along the length of the cylinder (defaults to 5).
 * @param {number} [opts.capSegments] - The number of divisions around the tubular body of the cylinder (defaults to 20).
 * @param {boolean} [opts.calculateTangents] - Generate tangent information (defaults to false).
 * @returns {Mesh} A new cylinder-shaped mesh.
 */
declare function createCylinder(device: GraphicsDevice, opts?: {
    radius?: number;
    height?: number;
    heightSegments?: number;
    capSegments?: number;
    calculateTangents?: boolean;
}): Mesh;
/**
 * Creates a new mesh object from the supplied vertex information and topology.
 *
 * @param {GraphicsDevice} device - The graphics device used to manage the mesh.
 * @param {number[]} positions - An array of 3-dimensional vertex positions.
 * @param {object} [opts] - An object that specifies optional inputs for the function as follows:
 * @param {number[]} [opts.normals] - An array of 3-dimensional vertex normals.
 * @param {number[]} [opts.tangents] - An array of 3-dimensional vertex tangents.
 * @param {number[]} [opts.colors] - An array of 4-dimensional vertex colors where each component
 * is an integer in the range 0 to 255.
 * @param {number[]} [opts.uvs] - An array of 2-dimensional vertex texture coordinates.
 * @param {number[]} [opts.uvs1] - Same as opts.uvs, but for additional UV set
 * @param {number[]} [opts.blendIndices] - An array of 4-dimensional bone indices where each
 * component is an integer in the range 0 to 255.
 * @param {number[]} [opts.blendWeights] - An array of 4-dimensional bone weights where each
 * component is in the range 0 to 1 and the sum of the weights should equal 1.
 * @param {number[]} [opts.indices] - An array of triangle indices.
 * @returns {Mesh} A new Mesh constructed from the supplied vertex and triangle data.
 * @example
 * // Create a simple, indexed triangle (with texture coordinates and vertex normals)
 * var mesh = pc.createMesh(graphicsDevice, [0, 0, 0, 1, 0, 0, 0, 1, 0], {
 *     normals: [0, 0, 1, 0, 0, 1, 0, 0, 1],
 *     uvs: [0, 0, 1, 0, 0, 1],
 *     indices: [0, 1, 2]
 * });
 */
declare function createMesh(device: GraphicsDevice, positions: number[], opts?: {
    normals?: number[];
    tangents?: number[];
    colors?: number[];
    uvs?: number[];
    uvs1?: number[];
    blendIndices?: number[];
    blendWeights?: number[];
    indices?: number[];
}): Mesh;
/**
 * Creates a procedural plane-shaped mesh.
 *
 * The size and tesselation properties of the plane can be controlled via function parameters. By
 * default, the function will create a plane centered on the object space origin with a width and
 * length of 1.0 and 5 segments in either axis (50 triangles). The normal vector of the plane is
 * aligned along the positive Y axis.
 *
 * Note that the plane is created with UVs in the range of 0 to 1. Additionally, tangent
 * information is generated into the vertex buffer of the plane's mesh.
 *
 * @param {GraphicsDevice} device - The graphics device used to manage the mesh.
 * @param {object} [opts] - An object that specifies optional inputs for the function as follows:
 * @param {Vec2} [opts.halfExtents] - The half dimensions of the plane in the X and Z axes
 * (defaults to [0.5, 0.5]).
 * @param {number} [opts.widthSegments] - The number of divisions along the X axis of the plane
 * (defaults to 5).
 * @param {number} [opts.lengthSegments] - The number of divisions along the Z axis of the plane
 * (defaults to 5).
 * @param {boolean} [opts.calculateTangents] - Generate tangent information (defaults to false).
 * @returns {Mesh} A new plane-shaped mesh.
 */
declare function createPlane(device: GraphicsDevice, opts?: {
    halfExtents?: Vec2;
    widthSegments?: number;
    lengthSegments?: number;
    calculateTangents?: boolean;
}): Mesh;
/**
 * Creates a procedural sphere-shaped mesh.
 *
 * The size and tesselation properties of the sphere can be controlled via function parameters. By
 * default, the function will create a sphere centered on the object space origin with a radius of
 * 0.5 and 16 segments in both longitude and latitude.
 *
 * Note that the sphere is created with UVs in the range of 0 to 1. Additionally, tangent
 * information is generated into the vertex buffer of the sphere's mesh.
 *
 * @param {GraphicsDevice} device - The graphics device used to manage the mesh.
 * @param {object} [opts] - An object that specifies optional inputs for the function as follows:
 * @param {number} [opts.radius] - The radius of the sphere (defaults to 0.5).
 * @param {number} [opts.latitudeBands] - The number of divisions along the latitudinal axis of the
 * sphere (defaults to 16).
 * @param {number} [opts.longitudeBands] - The number of divisions along the longitudinal axis of
 * the sphere (defaults to 16).
 * @param {boolean} [opts.calculateTangents] - Generate tangent information (defaults to false).
 * @returns {Mesh} A new sphere-shaped mesh.
 */
declare function createSphere(device: GraphicsDevice, opts?: {
    radius?: number;
    latitudeBands?: number;
    longitudeBands?: number;
    calculateTangents?: boolean;
}): Mesh;
/**
 * Creates a procedural torus-shaped mesh.
 *
 * The size, shape and tesselation properties of the torus can be controlled via function
 * parameters. By default, the function will create a torus in the XZ-plane with a tube radius of
 * 0.2, a ring radius of 0.3, 20 segments and 30 sides.
 *
 * Note that the torus is created with UVs in the range of 0 to 1. Additionally, tangent
 * information is generated into the vertex buffer of the torus's mesh.
 *
 * @param {GraphicsDevice} device - The graphics device used to manage the mesh.
 * @param {object} [opts] - An object that specifies optional inputs for the function as follows:
 * @param {number} [opts.tubeRadius] - The radius of the tube forming the body of the torus
 * (defaults to 0.2).
 * @param {number} [opts.ringRadius] - The radius from the centre of the torus to the centre of the
 * tube (defaults to 0.3).
 * @param {number} [opts.segments] - The number of radial divisions forming cross-sections of the
 * torus ring (defaults to 20).
 * @param {number} [opts.sides] - The number of divisions around the tubular body of the torus ring
 * (defaults to 30).
 * @param {boolean} [opts.calculateTangents] - Generate tangent information (defaults to false).
 * @returns {Mesh} A new torus-shaped mesh.
 */
declare function createTorus(device: GraphicsDevice, opts?: {
    tubeRadius?: number;
    ringRadius?: number;
    segments?: number;
    sides?: number;
    calculateTangents?: boolean;
}): Mesh;





/**
 * Picker object used to select mesh instances from screen coordinates.
 *
 * @property {number} width Width of the pick buffer in pixels (read-only).
 * @property {number} height Height of the pick buffer in pixels (read-only).
 * @property {RenderTarget} renderTarget The render target used by the picker internally
 * (read-only).
 */
declare class Picker {
    /**
     * Create a new Picker instance.
     *
     * @param {AppBase} app - The application managing this picker instance.
     * @param {number} width - The width of the pick buffer in pixels.
     * @param {number} height - The height of the pick buffer in pixels.
     */
    constructor(app: AppBase, width: number, height: number);
    app: AppBase;
    device: GraphicsDevice;
    pickColor: Float32Array;
    mapping: any[];
    cameraEntity: Entity;
    layer: Layer;
    layerComp: LayerComposition;
    _renderTarget: any;
    clearDepthCommand: Command;
    width: number;
    height: number;
    /**
     * Return the list of mesh instances selected by the specified rectangle in the previously
     * prepared pick buffer.The rectangle using top-left coordinate system.
     *
     * @param {number} x - The left edge of the rectangle.
     * @param {number} y - The top edge of the rectangle.
     * @param {number} [width] - The width of the rectangle.
     * @param {number} [height] - The height of the rectangle.
     * @returns {MeshInstance[]} An array of mesh instances that are in the selection.
     * @example
     * // Get the selection at the point (10,20)
     * var selection = picker.getSelection(10, 20);
     * @example
     * // Get all models in rectangle with corners at (10,20) and (20,40)
     * var selection = picker.getSelection(10, 20, 10, 20);
     */
    getSelection(x: number, y: number, width?: number, height?: number): MeshInstance[];
    allocateRenderTarget(): void;
    renderTarget: RenderTarget;
    releaseRenderTarget(): void;
    initLayerComposition(): void;
    /**
     * Primes the pick buffer with a rendering of the specified models from the point of view of
     * the supplied camera. Once the pick buffer has been prepared, {@link Picker#getSelection} can
     * be called multiple times on the same picker object. Therefore, if the models or camera do
     * not change in any way, {@link Picker#prepare} does not need to be called again.
     *
     * @param {CameraComponent} camera - The camera component used to render the scene.
     * @param {Scene} scene - The scene containing the pickable mesh instances.
     * @param {Layer[]} [layers] - Layers from which objects will be picked. If not supplied, all layers of the specified camera will be used.
     */
    prepare(camera: CameraComponent, scene: Scene, layers?: Layer[]): void;
    updateCamera(srcCamera: any): void;
    /**
     * Sets the resolution of the pick buffer. The pick buffer resolution does not need to match
     * the resolution of the corresponding frame buffer use for general rendering of the 3D scene.
     * However, the lower the resolution of the pick buffer, the less accurate the selection
     * results returned by {@link Picker#getSelection}. On the other hand, smaller pick buffers
     * will yield greater performance, so there is a trade off.
     *
     * @param {number} width - The width of the pick buffer in pixels.
     * @param {number} height - The height of the pick buffer in pixels.
     */
    resize(width: number, height: number): void;
}



/** @typedef {import('../sound/sound.js').Sound} Sound */
/** @typedef {import('../sound/manager.js').SoundManager} SoundManager */
/**
 * A channel is created when the {@link SoundManager} begins playback of a {@link Sound}. Usually
 * created internally by {@link SoundManager#playSound} or {@link SoundManager#playSound3d}.
 * Developers usually won't have to create Channels manually.
 *
 * @ignore
 */
declare class Channel {
    /**
     * Create a new Channel instance.
     *
     * @param {SoundManager} manager - The SoundManager instance.
     * @param {Sound} sound - The sound to playback.
     * @param {object} [options] - Optional options object.
     * @param {number} [options.volume=1] - The playback volume, between 0 and 1.
     * @param {number} [options.pitch=1] - The relative pitch, default of 1, plays at normal pitch.
     * @param {boolean} [options.loop=false] - Whether the sound should loop when it reaches the
     * end or not.
     */
    constructor(manager: SoundManager, sound: Sound, options?: {
        volume?: number;
        pitch?: number;
        loop?: boolean;
    });
    volume: number;
    loop: boolean;
    pitch: number;
    sound: Sound;
    paused: boolean;
    suspended: boolean;
    manager: SoundManager;
    source: Node;
    startTime: number;
    startOffset: number;
    gain: GainNode;
    /**
     * Get the current value for the volume. Between 0 and 1.
     *
     * @returns {number} The volume of the channel.
     */
    getVolume(): number;
    /**
     * Get the current looping state of the Channel.
     *
     * @returns {boolean} The loop property for the channel.
     */
    getLoop(): boolean;
    /**
     * Enable/disable the loop property to make the sound restart from the beginning when it
     * reaches the end.
     *
     * @param {boolean} loop - True to loop the sound, false otherwise.
     */
    setLoop(loop: boolean): void;
    /**
     * Get the current pitch of the Channel.
     *
     * @returns {number} The pitch of the channel.
     */
    getPitch(): number;
    /**
     * Handle the manager's 'volumechange' event.
     */
    onManagerVolumeChange(): void;
    /**
     * Handle the manager's 'suspend' event.
     */
    onManagerSuspend(): void;
    /**
     * Handle the manager's 'resume' event.
     */
    onManagerResume(): void;
    /**
     * Begin playback of sound.
     */
    play(): void;
    /**
     * Pause playback of sound. Call unpause() to resume playback from the same position.
     */
    pause(): void;
    /**
     * Resume playback of the sound. Playback resumes at the point that the audio was paused.
     */
    unpause(): void;
    /**
     * Stop playback of sound. Calling play() again will restart playback from the beginning of the
     * sound.
     */
    stop(): void;
    /**
     * Set the volume of playback between 0 and 1.
     *
     * @param {number} volume - The volume of the sound. Will be clamped between 0 and 1.
     */
    setVolume(volume: number): void;
    setPitch(pitch: any): void;
    isPlaying(): boolean;
    getDuration(): any;
    _createSource(): void;
}

/**
 * 3D audio channel.
 *
 * @ignore
 */
declare class Channel3d extends Channel {
    position: Vec3;
    velocity: Vec3;
    panner: PannerNode;
    maxDistance: number;
    minDistance: number;
    rollOffFactor: number;
    distanceModel: string;
    getPosition(): Vec3;
    setPosition(position: any): void;
    getVelocity(): Vec3;
    setVelocity(velocity: any): void;
    getMaxDistance(): number;
    setMaxDistance(max: any): void;
    getMinDistance(): number;
    setMinDistance(min: any): void;
    getRollOffFactor(): number;
    setRollOffFactor(factor: any): void;
    getDistanceModel(): DistanceModelType;
    setDistanceModel(distanceModel: any): void;
}


/** @typedef {import('./touch-device.js').TouchDevice} TouchDevice */
/**
 * Similar to {@link getTargetCoords} for the MouseEvents. This function takes a browser Touch
 * object and returns the coordinates of the touch relative to the target element.
 *
 * @param {globalThis.Touch} touch - The browser Touch object.
 * @returns {object} The coordinates of the touch relative to the touch.target element. In the
 * format {x, y}.
 */
declare function getTouchTargetCoords(touch: globalThis.Touch): object;
/**
 * A instance of a single point touch on a {@link TouchDevice}.
 */
declare class Touch$1 {
    /**
     * Create a new Touch object from the browser Touch.
     *
     * @param {globalThis.Touch} touch - The browser Touch object.
     */
    constructor(touch: globalThis.Touch);
    /**
     * The identifier of the touch.
     *
     * @type {number}
     */
    id: number;
    /**
     * The x coordinate relative to the element that the TouchDevice is attached to.
     *
     * @type {number}
     */
    x: number;
    /**
     * The y coordinate relative to the element that the TouchDevice is attached to.
     *
     * @type {number}
     */
    y: number;
    /**
     * The target element of the touch event.
     *
     * @type {Element}
     */
    target: Element;
    /**
     * The original browser Touch object.
     *
     * @type {globalThis.Touch}
     */
    touch: globalThis.Touch;
}
/**
 * A Event corresponding to touchstart, touchend, touchmove or touchcancel. TouchEvent wraps the
 * standard browser event and provides lists of {@link Touch} objects.
 */
declare class TouchEvent$1 {
    /**
     * Create a new TouchEvent instance. It is created from an existing browser event.
     *
     * @param {TouchDevice} device - The source device of the touch events.
     * @param {globalThis.TouchEvent} event - The original browser TouchEvent.
     */
    constructor(device: TouchDevice, event: globalThis.TouchEvent);
    /**
     * The target Element that the event was fired from.
     *
     * @type {Element}
     */
    element: Element;
    /**
     * The original browser TouchEvent.
     *
     * @type {globalThis.TouchEvent}
     */
    event: globalThis.TouchEvent;
    /**
     * A list of all touches currently in contact with the device.
     *
     * @type {Touch[]}
     */
    touches: Touch$1[];
    /**
     * A list of touches that have changed since the last event.
     *
     * @type {Touch[]}
     */
    changedTouches: Touch$1[];
    /**
     * Get an event from one of the touch lists by the id. It is useful to access
     * touches by their id so that you can be sure you are referencing the same
     * touch.
     *
     * @param {number} id - The identifier of the touch.
     * @param {Touch[]|null} list - An array of touches to search.
     * @returns {Touch} The {@link Touch} object or null.
     */
    getTouchById(id: number, list: Touch$1[] | null): Touch$1;
}


/** @typedef {import('./game-pads.js').GamePads} GamePads */
/**
 * A general input handler which handles both mouse and keyboard input assigned to named actions.
 * This allows you to define input handlers separately to defining keyboard/mouse configurations.
 */
declare class Controller {
    /**
     * Create a new instance of a Controller.
     *
     * @param {Element} [element] - Element to attach Controller to.
     * @param {object} [options] - Optional arguments.
     * @param {Keyboard} [options.keyboard] - A Keyboard object to use.
     * @param {Mouse} [options.mouse] - A Mouse object to use.
     * @param {GamePads} [options.gamepads] - A Gamepads object to use.
     * @example
     * var c = new pc.Controller(document);
     *
     * // Register the "fire" action and assign it to both the Enter key and the Spacebar.
     * c.registerKeys("fire", [pc.KEY_ENTER, pc.KEY_SPACE]);
     */
    constructor(element?: Element, options?: {
        keyboard?: Keyboard;
        mouse?: Mouse;
        gamepads?: GamePads;
    });
    _keyboard: Keyboard;
    _mouse: Mouse;
    _gamepads: GamePads;
    _element: Element;
    _actions: {};
    _axes: {};
    _axesValues: {};
    /**
     * Attach Controller to an Element. This is required before you can monitor for key/mouse
     * inputs.
     *
     * @param {Element} element - The element to attach mouse and keyboard event handler too.
     */
    attach(element: Element): void;
    /**
     * Detach Controller from an Element. This should be done before the Controller is destroyed.
     */
    detach(): void;
    /**
     * Disable the context menu usually activated with the right mouse button.
     */
    disableContextMenu(): void;
    /**
     * Enable the context menu usually activated with the right mouse button. This is enabled by
     * default.
     */
    enableContextMenu(): void;
    /**
     * Update the Keyboard and Mouse handlers.
     *
     * @param {object} dt - The time since the last frame.
     */
    update(dt: object): void;
    /**
     * Create or update a action which is enabled when the supplied keys are pressed.
     *
     * @param {string} action - The name of the action.
     * @param {number[]} keys - A list of keycodes.
     */
    registerKeys(action: string, keys: number[]): void;
    /**
     * Create or update an action which is enabled when the supplied mouse button is pressed.
     *
     * @param {string} action - The name of the action.
     * @param {number} button - The mouse button.
     */
    registerMouse(action: string, button: number): void;
    /**
     * Create or update an action which is enabled when the gamepad button is pressed.
     *
     * @param {string} action - The name of the action.
     * @param {number} pad - The index of the pad to register (use {@link PAD_1}, etc).
     * @param {number} button - The pad button.
     */
    registerPadButton(action: string, pad: number, button: number): void;
    /**
     * Register an action against a controller axis.
     *
     * @param {object} [options] - Optional options object.
     * @param {number} [options.pad] - The index of the game pad to register for (use {@link PAD_1}, etc).
     */
    registerAxis(options?: {
        pad?: number;
    }): void;
    /**
     * Returns true if the current action is enabled.
     *
     * @param {string} actionName - The name of the action.
     * @returns {boolean} True if the action is enabled.
     */
    isPressed(actionName: string): boolean;
    /**
     * Returns true if the action was enabled this since the last update.
     *
     * @param {string} actionName - The name of the action.
     * @returns {boolean} True if the action was enabled this since the last update.
     */
    wasPressed(actionName: string): boolean;
    getAxis(name: any): number;
    _enableMouse(): void;
    _enableKeyboard(): void;
}


/** @typedef {import('./keyboard.js').Keyboard} Keyboard */
/**
 * The KeyboardEvent is passed into all event callbacks from the {@link Keyboard}. It corresponds
 * to a key press or release.
 */
declare class KeyboardEvent {
    /**
     * Create a new KeyboardEvent.
     *
     * @param {Keyboard} keyboard - The keyboard object which is firing the event.
     * @param {globalThis.KeyboardEvent} event - The original browser event that was fired.
     * @example
     * var onKeyDown = function (e) {
     *     if (e.key === pc.KEY_SPACE) {
     *         // space key pressed
     *     }
     *     e.event.preventDefault(); // Use original browser event to prevent browser action.
     * };
     * app.keyboard.on("keydown", onKeyDown, this);
     */
    constructor(keyboard: Keyboard, event: globalThis.KeyboardEvent);
    /**
     * The keyCode of the key that has changed. See the KEY_* constants.
     *
     * @type {number}
     */
    key: number;
    /**
     * The element that fired the keyboard event.
     *
     * @type {Element}
     */
    element: Element;
    /**
     * The original browser event which was fired.
     *
     * @type {globalThis.KeyboardEvent}
     */
    event: globalThis.KeyboardEvent;
}


/**
 * MouseEvent object that is passed to events 'mousemove', 'mouseup', 'mousedown' and 'mousewheel'.
 */
declare class MouseEvent$1 {
    /**
     * Create a new MouseEvent instance.
     *
     * @param {Mouse} mouse - The Mouse device that is firing this event.
     * @param {globalThis.MouseEvent} event - The original browser event that fired.
     */
    constructor(mouse: Mouse, event: globalThis.MouseEvent);
    /**
     * The x coordinate of the mouse pointer relative to the element {@link Mouse} is
     * attached to.
     *
     * @type {number}
     */
    x: number;
    /**
     * The y coordinate of the mouse pointer relative to the element {@link Mouse} is
     * attached to.
     *
     * @type {number}
     */
    y: number;
    /**
     * A value representing the amount the mouse wheel has moved, only valid for
     * {@link mousewheel} events.
     *
     * @type {number}
     */
    wheelDelta: number;
    /**
     * The change in x coordinate since the last mouse event.
     *
     * @type {number}
     */
    dx: number;
    /**
     * The change in y coordinate since the last mouse event.
     *
     * @type {number}
     */
    dy: number;
    /**
     * The mouse button associated with this event. Can be:
     *
     * - {@link MOUSEBUTTON_LEFT}
     * - {@link MOUSEBUTTON_MIDDLE}
     * - {@link MOUSEBUTTON_RIGHT}
     *
     * @type {number}
     */
    button: number;
    buttons: boolean[];
    /**
     * The element that the mouse was fired from.
     *
     * @type {Element}
     */
    element: Element;
    /**
     * True if the ctrl key was pressed when this event was fired.
     *
     * @type {boolean}
     */
    ctrlKey: boolean;
    /**
     * True if the alt key was pressed when this event was fired.
     *
     * @type {boolean}
     */
    altKey: boolean;
    /**
     * True if the shift key was pressed when this event was fired.
     *
     * @type {boolean}
     */
    shiftKey: boolean;
    /**
     * True if the meta key was pressed when this event was fired.
     *
     * @type {boolean}
     */
    metaKey: boolean;
    /**
     * The original browser event.
     *
     * @type {globalThis.MouseEvent}
     */
    event: globalThis.MouseEvent;
}

/**
 * A WebGL implementation of the Buffer.
 *
 * @ignore
 */
declare class WebglBuffer {
    bufferId: any;
    destroy(device: any): void;
    loseContext(): void;
    unlock(device: any, usage: any, target: any, storage: any): void;
}

/**
 * A WebGL implementation of the VertexBuffer.
 *
 * @ignore
 */
declare class WebglVertexBuffer extends WebglBuffer {
    vao: any;
    unlock(vertexBuffer: any): void;
}

/**
 * A WebGL implementation of the IndexBuffer.
 *
 * @ignore
 */
declare class WebglIndexBuffer extends WebglBuffer {
    constructor(indexBuffer: any);
    glFormat: any;
    unlock(indexBuffer: any): void;
}



/** @typedef {import('./webgl-graphics-device.js').WebglGraphicsDevice} WebglGraphicsDevice */
/** @typedef {import('../shader.js').Shader} Shader */
/**
 * A WebGL implementation of the Shader.
 *
 * @ignore
 */
declare class WebglShader {
    constructor(shader: any);
    uniforms: any[];
    samplers: any[];
    attributes: any[];
    glProgram: WebGLProgram;
    glVertexShader: WebGLShader;
    glFragmentShader: WebGLShader;
    /**
     * Free the WebGL resources associated with a shader.
     *
     * @param {Shader} shader - The shader to free.
     */
    destroy(shader: Shader): void;
    /**
     * Restore shader after the context has been obtained.
     *
     * @param {WebglGraphicsDevice} device - The graphics device.
     * @param {Shader} shader - The shader to restore.
     */
    restoreContext(device: WebglGraphicsDevice, shader: Shader): void;
    /**
     * Compile and link a shader program.
     *
     * @param {WebglGraphicsDevice} device - The graphics device.
     * @param {Shader} shader - The shader to compile.
     */
    compileAndLink(device: WebglGraphicsDevice, shader: Shader): void;
    /**
     * Compiles an individual shader.
     *
     * @param {WebglGraphicsDevice} device - The graphics device.
     * @param {string} src - The shader source code.
     * @param {boolean} isVertexShader - True if the shader is a vertex shader, false if it is a
     * fragment shader.
     * @returns {WebGLShader} The compiled shader.
     * @private
     */
    private _compileShaderSource;
    /**
     * Extract attribute and uniform information from a successfully linked shader.
     *
     * @param {WebglGraphicsDevice} device - The graphics device.
     * @param {Shader} shader - The shader to query.
     * @returns {boolean} True if the shader was successfully queried and false otherwise.
     */
    postLink(device: WebglGraphicsDevice, shader: Shader): boolean;
    /**
     * Check the compilation status of a shader.
     *
     * @param {WebglGraphicsDevice} device - The graphics device.
     * @param {Shader} shader - The shader to query.
     * @param {WebGLShader} glShader - The WebGL shader.
     * @param {string} source - The shader source code.
     * @param {string} shaderType - The shader type. Can be 'vertex' or 'fragment'.
     * @returns {boolean} True if the shader compiled successfully, false otherwise.
     * @private
     */
    private _isCompiled;
    /**
     * Truncate the WebGL shader compilation log to just include the error line plus the 5 lines
     * before and after it.
     *
     * @param {string} src - The shader source code.
     * @param {string} infoLog - The info log returned from WebGL on a failed shader compilation.
     * @returns {[string, {message?: string, line?: number, source?: string}]} A tuple where the first element is the 10 lines of code around the first
     * detected error, and the second element an object storing the error messsage, line number and
     * complete shader source.
     * @private
     */
    private _processError;
}

/**
 * A WebGL implementation of the Texture.
 *
 * @ignore
 */
declare class WebglTexture {
    _glTexture: any;
    _glTarget: any;
    _glFormat: any;
    _glInternalFormat: any;
    _glPixelType: any;
    destroy(device: any): void;
    loseContext(): void;
    initialize(device: any, texture: any): void;
    upload(device: any, texture: any): void;
}

/**
 * A WebGL implementation of the RenderTarget.
 *
 * @ignore
 */
declare class WebglRenderTarget {
    _glFrameBuffer: any;
    _glDepthBuffer: any;
    _glResolveFrameBuffer: any;
    _glMsaaColorBuffer: any;
    _glMsaaDepthBuffer: any;
    destroy(device: any): void;
    init(device: any, target: any): void;
    /**
     * Checks the completeness status of the currently bound WebGLFramebuffer object.
     *
     * @private
     */
    private _checkFbo;
    loseContext(): void;
    resolve(device: any, target: any, color: any, depth: any): void;
}





/**
 * The graphics device manages the underlying graphics context. It is responsible for submitting
 * render state changes and graphics primitives to the hardware. A graphics device is tied to a
 * specific canvas HTML element. It is valid to have more than one canvas element per page and
 * create a new graphics device against each.
 *
 * @augments GraphicsDevice
 */
declare class WebglGraphicsDevice extends GraphicsDevice {
    /**
     * Creates a new WebglGraphicsDevice instance.
     *
     * @param {HTMLCanvasElement} canvas - The canvas to which the graphics device will render.
     * @param {object} [options] - Options passed when creating the WebGL context.
     * @param {boolean} [options.alpha=true] - Boolean that indicates if the canvas contains an
     * alpha buffer.
     * @param {boolean} [options.depth=true] - Boolean that indicates that the drawing buffer is
     * requested to have a depth buffer of at least 16 bits.
     * @param {boolean} [options.stencil=false] - Boolean that indicates that the drawing buffer is
     * requested to have a stencil buffer of at least 8 bits.
     * @param {boolean} [options.antialias=true] - Boolean that indicates whether or not to perform
     * anti-aliasing if possible.
     * @param {boolean} [options.premultipliedAlpha=true] - Boolean that indicates that the page
     * compositor will assume the drawing buffer contains colors with pre-multiplied alpha.
     * @param {boolean} [options.preserveDrawingBuffer=false] - If the value is true the buffers
     * will not be cleared and will preserve their values until cleared or overwritten by the
     * author.
     * @param {'default'|'high-performance'|'low-power'} [options.powerPreference='default'] - A
     * hint to the user agent indicating what configuration of GPU is suitable for the WebGL
     * context. Possible values are:
     *
     * - 'default': Let the user agent decide which GPU configuration is most suitable. This is the
     * default value.
     * - 'high-performance': Prioritizes rendering performance over power consumption.
     * - 'low-power': Prioritizes power saving over rendering performance.
     *
     * @param {boolean} [options.failIfMajorPerformanceCaveat=false] - Boolean that indicates if a
     * context will be created if the system performance is low or if no hardware GPU is available.
     * @param {boolean} [options.preferWebGl2=true] - Boolean that indicates if a WebGl2 context
     * should be preferred.
     * @param {boolean} [options.desynchronized=false] - Boolean that hints the user agent to
     * reduce the latency by desynchronizing the canvas paint cycle from the event loop.
     * @param {boolean} [options.xrCompatible] - Boolean that hints to the user agent to use a
     * compatible graphics adapter for an immersive XR device.
     */
    constructor(canvas: HTMLCanvasElement, options?: {
        alpha?: boolean;
        depth?: boolean;
        stencil?: boolean;
        antialias?: boolean;
        premultipliedAlpha?: boolean;
        preserveDrawingBuffer?: boolean;
        powerPreference?: 'default' | 'high-performance' | 'low-power';
        failIfMajorPerformanceCaveat?: boolean;
        preferWebGl2?: boolean;
        desynchronized?: boolean;
        xrCompatible?: boolean;
    });
    /**
     * The WebGL context managed by the graphics device. The type could also technically be
     * `WebGLRenderingContext` if WebGL 2.0 is not available. But in order for IntelliSense to be
     * able to function for all WebGL calls in the codebase, we specify `WebGL2RenderingContext`
     * here instead.
     *
     * @type {WebGL2RenderingContext}
     * @ignore
     */
    gl: WebGL2RenderingContext;
    /**
     * True if the WebGL context of this device is using the WebGL 2.0 API. If false, WebGL 1.0 is
     * being used.
     *
     * @type {boolean}
     * @ignore
     */
    webgl2: boolean;
    defaultFramebuffer: any;
    defaultFramebufferAlpha: boolean;
    contextLost: boolean;
    _contextLostHandler: (event: any) => void;
    _contextRestoredHandler: () => void;
    forceDisableMultisampling: boolean;
    _tempEnableSafariTextureUnitWorkaround: boolean;
    _tempMacChromeBlitFramebufferWorkaround: boolean;
    defaultClearOptions: {
        color: number[];
        depth: number;
        stencil: number;
        flags: number;
    };
    glAddress: any[];
    glBlendEquation: any[];
    glBlendFunction: any[];
    glComparison: any[];
    glStencilOp: any[];
    glClearFlag: any[];
    glCull: any[];
    glFilter: any[];
    glPrimitive: any[];
    glType: any[];
    pcUniformType: {};
    targetToSlot: {};
    commitFunction: {}[];
    supportsBoneTextures: boolean;
    boneLimit: number;
    constantTexSource: ScopeId;
    textureBias: ScopeId;
    supportsMorphTargetTexturesCore: boolean;
    _textureFloatHighPrecision: boolean;
    _textureHalfFloatUpdatable: boolean;
    _spectorMarkers: any[];
    _spectorCurrentMarker: string;
    areaLightLutFormat: number;
    createVertexBufferImpl(vertexBuffer: any, format: any): WebglVertexBuffer;
    createIndexBufferImpl(indexBuffer: any): WebglIndexBuffer;
    createShaderImpl(shader: any): WebglShader;
    createTextureImpl(): WebglTexture;
    createRenderTargetImpl(renderTarget: any): WebglRenderTarget;
    updateMarker(): void;
    pushMarker(name: any): void;
    popMarker(): void;
    /**
     * Query the precision supported by ints and floats in vertex and fragment shaders. Note that
     * getShaderPrecisionFormat is not guaranteed to be present (such as some instances of the
     * default Android browser). In this case, assume highp is available.
     *
     * @returns {string} "highp", "mediump" or "lowp"
     * @ignore
     */
    getPrecision(): string;
    /**
     * Initialize the extensions provided by the WebGL context.
     *
     * @ignore
     */
    initializeExtensions(): void;
    extBlendMinmax: boolean | EXT_blend_minmax;
    extDrawBuffers: boolean | EXT_blend_minmax;
    extInstancing: boolean | EXT_blend_minmax;
    extStandardDerivatives: boolean | EXT_blend_minmax;
    extTextureFloat: boolean | EXT_blend_minmax;
    extTextureHalfFloat: boolean | EXT_blend_minmax;
    extTextureLod: boolean | EXT_blend_minmax;
    extUintElement: boolean | EXT_blend_minmax;
    extVertexArrayObject: boolean | EXT_blend_minmax;
    extColorBufferFloat: EXT_blend_minmax;
    extDisjointTimerQuery: EXT_blend_minmax;
    extDepthTexture: boolean | WEBGL_depth_texture;
    extDebugRendererInfo: EXT_blend_minmax;
    extTextureFloatLinear: EXT_blend_minmax;
    extTextureHalfFloatLinear: EXT_blend_minmax;
    extFloatBlend: EXT_blend_minmax;
    extTextureFilterAnisotropic: EXT_blend_minmax;
    extCompressedTextureETC1: EXT_blend_minmax;
    extCompressedTextureETC: EXT_blend_minmax;
    extCompressedTexturePVRTC: EXT_blend_minmax;
    extCompressedTextureS3TC: EXT_blend_minmax;
    extCompressedTextureATC: EXT_blend_minmax;
    extCompressedTextureASTC: EXT_blend_minmax;
    extParallelShaderCompile: EXT_blend_minmax;
    extColorBufferHalfFloat: EXT_blend_minmax;
    /**
     * Query the capabilities of the WebGL context.
     *
     * @ignore
     */
    initializeCapabilities(): void;
    maxPrecision: string;
    supportsMsaa: boolean;
    supportsStencil: boolean;
    maxRenderBufferSize: any;
    maxTextures: any;
    maxCombinedTextures: any;
    maxVertexTextures: any;
    vertexUniformsCount: any;
    fragmentUniformsCount: any;
    maxDrawBuffers: any;
    maxColorAttachments: any;
    unmaskedRenderer: any;
    unmaskedVendor: any;
    supportsGpuParticles: boolean;
    samples: any;
    maxSamples: any;
    supportsAreaLights: boolean;
    /**
     * Set the initial render state on the WebGL context.
     *
     * @ignore
     */
    initializeRenderState(): void;
    blending: any;
    blendSrc: any;
    blendDst: number;
    blendSrcAlpha: number;
    blendDstAlpha: number;
    separateAlphaBlend: boolean;
    blendEquation: any;
    blendAlphaEquation: number;
    separateAlphaEquation: boolean;
    blendColor: Color;
    writeRed: any;
    writeGreen: boolean;
    writeBlue: boolean;
    writeAlpha: boolean;
    cullMode: any;
    depthTest: any;
    depthFunc: any;
    depthWrite: any;
    stencil: any;
    stencilFuncFront: any;
    stencilFuncBack: any;
    stencilRefFront: number;
    stencilRefBack: number;
    stencilMaskFront: number;
    stencilMaskBack: number;
    stencilFailFront: any;
    stencilFailBack: any;
    stencilZfailFront: number;
    stencilZfailBack: number;
    stencilZpassFront: number;
    stencilZpassBack: number;
    stencilWriteMaskFront: any;
    stencilWriteMaskBack: any;
    alphaToCoverage: any;
    raster: any;
    depthBiasEnabled: any;
    clearDepth: any;
    clearColor: Color;
    clearStencil: any;
    vx: any;
    vy: number;
    vw: number;
    vh: number;
    sx: any;
    sy: number;
    sw: number;
    sh: number;
    unpackFlipY: any;
    unpackPremultiplyAlpha: any;
    vertexShaderCache: {};
    fragmentShaderCache: {};
    _vaoMap: Map<any, any>;
    boundVao: any;
    activeFramebuffer: any;
    feedback: WebGLTransformFeedback;
    transformFeedbackBuffer: any;
    textureUnit: any;
    textureUnits: any[];
    /**
     * Called when the WebGL context was lost. It releases all context related resources.
     *
     * @ignore
     */
    loseContext(): void;
    /**
     * Called when the WebGL context is restored. It reinitializes all context related resources.
     *
     * @ignore
     */
    restoreContext(): void;
    /**
     * Set the active rectangle for rendering on the specified device.
     *
     * @param {number} x - The pixel space x-coordinate of the bottom left corner of the viewport.
     * @param {number} y - The pixel space y-coordinate of the bottom left corner of the viewport.
     * @param {number} w - The width of the viewport in pixels.
     * @param {number} h - The height of the viewport in pixels.
     */
    setViewport(x: number, y: number, w: number, h: number): void;
    /**
     * Set the active scissor rectangle on the specified device.
     *
     * @param {number} x - The pixel space x-coordinate of the bottom left corner of the scissor rectangle.
     * @param {number} y - The pixel space y-coordinate of the bottom left corner of the scissor rectangle.
     * @param {number} w - The width of the scissor rectangle in pixels.
     * @param {number} h - The height of the scissor rectangle in pixels.
     */
    setScissor(x: number, y: number, w: number, h: number): void;
    /**
     * Binds the specified framebuffer object.
     *
     * @param {WebGLFramebuffer | null} fb - The framebuffer to bind.
     * @ignore
     */
    setFramebuffer(fb: WebGLFramebuffer | null): void;
    /**
     * Copies source render target into destination render target. Mostly used by post-effects.
     *
     * @param {RenderTarget} [source] - The source render target. Defaults to frame buffer.
     * @param {RenderTarget} [dest] - The destination render target. Defaults to frame buffer.
     * @param {boolean} [color] - If true will copy the color buffer. Defaults to false.
     * @param {boolean} [depth] - If true will copy the depth buffer. Defaults to false.
     * @returns {boolean} True if the copy was successful, false otherwise.
     */
    copyRenderTarget(source?: RenderTarget, dest?: RenderTarget, color?: boolean, depth?: boolean): boolean;
    renderTarget: any;
    /**
     * Initialize render target before it can be used.
     *
     * @param {RenderTarget} target - The render target to be initialized.
     * @ignore
     */
    initRenderTarget(target: RenderTarget): void;
    /**
     * Get copy shader for efficient rendering of fullscreen-quad with texture.
     *
     * @returns {Shader} The copy shader (based on `fullscreenQuadVS` and `outputTex2DPS` in
     * `shaderChunks`).
     * @ignore
     */
    getCopyShader(): Shader;
    _copyShader: Shader;
    /**
     * Start a render pass.
     *
     * @param {RenderPass} renderPass - The render pass to start.
     * @ignore
     */
    startPass(renderPass: RenderPass): void;
    /**
     * End a render pass.
     *
     * @param {RenderPass} renderPass - The render pass to end.
     * @ignore
     */
    endPass(renderPass: RenderPass): void;
    /**
     * Marks the beginning of a block of rendering. Internally, this function binds the render
     * target currently set on the device. This function should be matched with a call to
     * {@link GraphicsDevice#updateEnd}. Calls to {@link GraphicsDevice#updateBegin} and
     * {@link GraphicsDevice#updateEnd} must not be nested.
     *
     * @ignore
     */
    updateBegin(): void;
    /**
     * Marks the end of a block of rendering. This function should be called after a matching call
     * to {@link GraphicsDevice#updateBegin}. Calls to {@link GraphicsDevice#updateBegin} and
     * {@link GraphicsDevice#updateEnd} must not be nested.
     *
     * @ignore
     */
    updateEnd(): void;
    /**
     * Updates a texture's vertical flip.
     *
     * @param {boolean} flipY - True to flip the texture vertically.
     * @ignore
     */
    setUnpackFlipY(flipY: boolean): void;
    /**
     * Updates a texture to have its RGB channels premultiplied by its alpha channel or not.
     *
     * @param {boolean} premultiplyAlpha - True to premultiply the alpha channel against the RGB
     * channels.
     * @ignore
     */
    setUnpackPremultiplyAlpha(premultiplyAlpha: boolean): void;
    /**
     * Activate the specified texture unit.
     *
     * @param {number} textureUnit - The texture unit to activate.
     * @ignore
     */
    activeTexture(textureUnit: number): void;
    /**
     * If the texture is not already bound on the currently active texture unit, bind it.
     *
     * @param {Texture} texture - The texture to bind.
     * @ignore
     */
    bindTexture(texture: Texture): void;
    /**
     * If the texture is not bound on the specified texture unit, active the texture unit and bind
     * the texture to it.
     *
     * @param {Texture} texture - The texture to bind.
     * @param {number} textureUnit - The texture unit to activate and bind the texture to.
     * @ignore
     */
    bindTextureOnUnit(texture: Texture, textureUnit: number): void;
    /**
     * Update the texture parameters for a given texture if they have changed.
     *
     * @param {Texture} texture - The texture to update.
     * @ignore
     */
    setTextureParameters(texture: Texture): void;
    /**
     * Sets the specified texture on the specified texture unit.
     *
     * @param {Texture} texture - The texture to set.
     * @param {number} textureUnit - The texture unit to set the texture on.
     * @ignore
     */
    setTexture(texture: Texture, textureUnit: number): void;
    createVertexArray(vertexBuffers: any): any;
    unbindVertexArray(): void;
    setBuffers(): void;
    /**
     * Submits a graphical primitive to the hardware for immediate rendering.
     *
     * @param {object} primitive - Primitive object describing how to submit current vertex/index
     * buffers.
     * @param {number} primitive.type - The type of primitive to render. Can be:
     *
     * - {@link PRIMITIVE_POINTS}
     * - {@link PRIMITIVE_LINES}
     * - {@link PRIMITIVE_LINELOOP}
     * - {@link PRIMITIVE_LINESTRIP}
     * - {@link PRIMITIVE_TRIANGLES}
     * - {@link PRIMITIVE_TRISTRIP}
     * - {@link PRIMITIVE_TRIFAN}
     *
     * @param {number} primitive.base - The offset of the first index or vertex to dispatch in the
     * draw call.
     * @param {number} primitive.count - The number of indices or vertices to dispatch in the draw
     * call.
     * @param {boolean} [primitive.indexed] - True to interpret the primitive as indexed, thereby
     * using the currently set index buffer and false otherwise.
     * @param {number} [numInstances=1] - The number of instances to render when using
     * ANGLE_instanced_arrays. Defaults to 1.
     * @param {boolean} [keepBuffers] - Optionally keep the current set of vertex / index buffers /
     * VAO. This is used when rendering of multiple views, for example under WebXR.
     * @example
     * // Render a single, unindexed triangle
     * device.draw({
     *     type: pc.PRIMITIVE_TRIANGLES,
     *     base: 0,
     *     count: 3,
     *     indexed: false
     * });
     */
    draw(primitive: {
        type: number;
        base: number;
        count: number;
        indexed?: boolean;
    }, numInstances?: number, keepBuffers?: boolean): void;
    /**
     * Clears the frame buffer of the currently set render target.
     *
     * @param {object} [options] - Optional options object that controls the behavior of the clear
     * operation defined as follows:
     * @param {number[]} [options.color] - The color to clear the color buffer to in the range 0.0
     * to 1.0 for each component.
     * @param {number} [options.depth=1] - The depth value to clear the depth buffer to in the
     * range 0.0 to 1.0.
     * @param {number} [options.flags] - The buffers to clear (the types being color, depth and
     * stencil). Can be any bitwise combination of:
     *
     * - {@link CLEARFLAG_COLOR}
     * - {@link CLEARFLAG_DEPTH}
     * - {@link CLEARFLAG_STENCIL}
     *
     * @param {number} [options.stencil=0] - The stencil value to clear the stencil buffer to. Defaults to 0.
     * @example
     * // Clear color buffer to black and depth buffer to 1.0
     * device.clear();
     *
     * // Clear just the color buffer to red
     * device.clear({
     *     color: [1, 0, 0, 1],
     *     flags: pc.CLEARFLAG_COLOR
     * });
     *
     * // Clear color buffer to yellow and depth to 1.0
     * device.clear({
     *     color: [1, 1, 0, 1],
     *     depth: 1,
     *     flags: pc.CLEARFLAG_COLOR | pc.CLEARFLAG_DEPTH
     * });
     */
    clear(options?: {
        color?: number[];
        depth?: number;
        flags?: number;
        stencil?: number;
    }): void;
    /**
     * Reads a block of pixels from a specified rectangle of the current color framebuffer into an
     * ArrayBufferView object.
     *
     * @param {number} x - The x-coordinate of the rectangle's lower-left corner.
     * @param {number} y - The y-coordinate of the rectangle's lower-left corner.
     * @param {number} w - The width of the rectangle, in pixels.
     * @param {number} h - The height of the rectangle, in pixels.
     * @param {ArrayBufferView} pixels - The ArrayBufferView object that holds the returned pixel
     * data.
     * @ignore
     */
    readPixels(x: number, y: number, w: number, h: number, pixels: ArrayBufferView): void;
    /**
     * Set the depth value used when the depth buffer is cleared.
     *
     * @param {number} depth - The depth value to clear the depth buffer to in the range 0.0
     * to 1.0.
     * @ignore
     */
    setClearDepth(depth: number): void;
    /**
     * Set the clear color used when the frame buffer is cleared.
     *
     * @param {number} r - The red component of the color in the range 0.0 to 1.0.
     * @param {number} g - The green component of the color in the range 0.0 to 1.0.
     * @param {number} b - The blue component of the color in the range 0.0 to 1.0.
     * @param {number} a - The alpha component of the color in the range 0.0 to 1.0.
     * @ignore
     */
    setClearColor(r: number, g: number, b: number, a: number): void;
    /**
     * Set the stencil clear value used when the stencil buffer is cleared.
     *
     * @param {number} value - The stencil value to clear the stencil buffer to.
     */
    setClearStencil(value: number): void;
    /**
     * Queries whether depth testing is enabled.
     *
     * @returns {boolean} True if depth testing is enabled and false otherwise.
     * @example
     * var depthTest = device.getDepthTest();
     * console.log('Depth testing is ' + depthTest ? 'enabled' : 'disabled');
     */
    getDepthTest(): boolean;
    /**
     * Enables or disables depth testing of fragments. Once this state is set, it persists until it
     * is changed. By default, depth testing is enabled.
     *
     * @param {boolean} depthTest - True to enable depth testing and false otherwise.
     * @example
     * device.setDepthTest(true);
     */
    setDepthTest(depthTest: boolean): void;
    /**
     * Configures the depth test.
     *
     * @param {number} func - A function to compare a new depth value with an existing z-buffer
     * value and decide if to write a pixel. Can be:
     *
     * - {@link FUNC_NEVER}: don't draw
     * - {@link FUNC_LESS}: draw if new depth < depth buffer
     * - {@link FUNC_EQUAL}: draw if new depth == depth buffer
     * - {@link FUNC_LESSEQUAL}: draw if new depth <= depth buffer
     * - {@link FUNC_GREATER}: draw if new depth > depth buffer
     * - {@link FUNC_NOTEQUAL}: draw if new depth != depth buffer
     * - {@link FUNC_GREATEREQUAL}: draw if new depth >= depth buffer
     * - {@link FUNC_ALWAYS}: always draw
     */
    setDepthFunc(func: number): void;
    /**
     * Queries whether writes to the depth buffer are enabled.
     *
     * @returns {boolean} True if depth writing is enabled and false otherwise.
     * @example
     * var depthWrite = device.getDepthWrite();
     * console.log('Depth writing is ' + depthWrite ? 'enabled' : 'disabled');
     */
    getDepthWrite(): boolean;
    /**
     * Enables or disables writes to the depth buffer. Once this state is set, it persists until it
     * is changed. By default, depth writes are enabled.
     *
     * @param {boolean} writeDepth - True to enable depth writing and false otherwise.
     * @example
     * device.setDepthWrite(true);
     */
    setDepthWrite(writeDepth: boolean): void;
    /**
     * Enables or disables writes to the color buffer. Once this state is set, it persists until it
     * is changed. By default, color writes are enabled for all color channels.
     *
     * @param {boolean} writeRed - True to enable writing of the red channel and false otherwise.
     * @param {boolean} writeGreen - True to enable writing of the green channel and false otherwise.
     * @param {boolean} writeBlue - True to enable writing of the blue channel and false otherwise.
     * @param {boolean} writeAlpha - True to enable writing of the alpha channel and false otherwise.
     * @example
     * // Just write alpha into the frame buffer
     * device.setColorWrite(false, false, false, true);
     */
    setColorWrite(writeRed: boolean, writeGreen: boolean, writeBlue: boolean, writeAlpha: boolean): void;
    /**
     * Enables or disables alpha to coverage (WebGL2 only).
     *
     * @param {boolean} state - True to enable alpha to coverage and false to disable it.
     * @ignore
     */
    setAlphaToCoverage(state: boolean): void;
    /**
     * Sets the output vertex buffer. It will be written to by a shader with transform feedback
     * varyings.
     *
     * @param {VertexBuffer} tf - The output vertex buffer.
     * @ignore
     */
    setTransformFeedbackBuffer(tf: VertexBuffer): void;
    /**
     * Toggles the rasterization render state. Useful with transform feedback, when you only need
     * to process the data without drawing.
     *
     * @param {boolean} on - True to enable rasterization and false to disable it.
     * @ignore
     */
    setRaster(on: boolean): void;
    /**
     * Toggles the polygon offset render state.
     *
     * @param {boolean} on - True to enable polygon offset and false to disable it.
     * @ignore
     */
    setDepthBias(on: boolean): void;
    /**
     * Specifies the scale factor and units to calculate depth values. The offset is added before
     * the depth test is performed and before the value is written into the depth buffer.
     *
     * @param {number} constBias - The multiplier by which an implementation-specific value is
     * multiplied with to create a constant depth offset.
     * @param {number} slopeBias - The scale factor for the variable depth offset for each polygon.
     * @ignore
     */
    setDepthBiasValues(constBias: number, slopeBias: number): void;
    /**
     * Queries whether blending is enabled.
     *
     * @returns {boolean} True if blending is enabled and false otherwise.
     */
    getBlending(): boolean;
    /**
     * Enables or disables blending.
     *
     * @param {boolean} blending - True to enable blending and false to disable it.
     */
    setBlending(blending: boolean): void;
    /**
     * Enables or disables stencil test.
     *
     * @param {boolean} enable - True to enable stencil test and false to disable it.
     */
    setStencilTest(enable: boolean): void;
    /**
     * Configures stencil test for both front and back faces.
     *
     * @param {number} func - A comparison function that decides if the pixel should be written,
     * based on the current stencil buffer value, reference value, and mask value. Can be:
     *
     * - {@link FUNC_NEVER}: never pass
     * - {@link FUNC_LESS}: pass if (ref & mask) < (stencil & mask)
     * - {@link FUNC_EQUAL}: pass if (ref & mask) == (stencil & mask)
     * - {@link FUNC_LESSEQUAL}: pass if (ref & mask) <= (stencil & mask)
     * - {@link FUNC_GREATER}: pass if (ref & mask) > (stencil & mask)
     * - {@link FUNC_NOTEQUAL}: pass if (ref & mask) != (stencil & mask)
     * - {@link FUNC_GREATEREQUAL}: pass if (ref & mask) >= (stencil & mask)
     * - {@link FUNC_ALWAYS}: always pass
     *
     * @param {number} ref - Reference value used in comparison.
     * @param {number} mask - Mask applied to stencil buffer value and reference value before
     * comparison.
     */
    setStencilFunc(func: number, ref: number, mask: number): void;
    /**
     * Configures stencil test for front faces.
     *
     * @param {number} func - A comparison function that decides if the pixel should be written,
     * based on the current stencil buffer value, reference value, and mask value. Can be:
     *
     * - {@link FUNC_NEVER}: never pass
     * - {@link FUNC_LESS}: pass if (ref & mask) < (stencil & mask)
     * - {@link FUNC_EQUAL}: pass if (ref & mask) == (stencil & mask)
     * - {@link FUNC_LESSEQUAL}: pass if (ref & mask) <= (stencil & mask)
     * - {@link FUNC_GREATER}: pass if (ref & mask) > (stencil & mask)
     * - {@link FUNC_NOTEQUAL}: pass if (ref & mask) != (stencil & mask)
     * - {@link FUNC_GREATEREQUAL}: pass if (ref & mask) >= (stencil & mask)
     * - {@link FUNC_ALWAYS}: always pass
     *
     * @param {number} ref - Reference value used in comparison.
     * @param {number} mask - Mask applied to stencil buffer value and reference value before comparison.
     */
    setStencilFuncFront(func: number, ref: number, mask: number): void;
    /**
     * Configures stencil test for back faces.
     *
     * @param {number} func - A comparison function that decides if the pixel should be written,
     * based on the current stencil buffer value, reference value, and mask value. Can be:
     *
     * - {@link FUNC_NEVER}: never pass
     * - {@link FUNC_LESS}: pass if (ref & mask) < (stencil & mask)
     * - {@link FUNC_EQUAL}: pass if (ref & mask) == (stencil & mask)
     * - {@link FUNC_LESSEQUAL}: pass if (ref & mask) <= (stencil & mask)
     * - {@link FUNC_GREATER}: pass if (ref & mask) > (stencil & mask)
     * - {@link FUNC_NOTEQUAL}: pass if (ref & mask) != (stencil & mask)
     * - {@link FUNC_GREATEREQUAL}: pass if (ref & mask) >= (stencil & mask)
     * - {@link FUNC_ALWAYS}: always pass
     *
     * @param {number} ref - Reference value used in comparison.
     * @param {number} mask - Mask applied to stencil buffer value and reference value before comparison.
     */
    setStencilFuncBack(func: number, ref: number, mask: number): void;
    /**
     * Configures how stencil buffer values should be modified based on the result of depth/stencil
     * tests. Works for both front and back faces.
     *
     * @param {number} fail - Action to take if stencil test is failed. Can be:
     *
     * - {@link STENCILOP_KEEP}: don't change the stencil buffer value
     * - {@link STENCILOP_ZERO}: set value to zero
     * - {@link STENCILOP_REPLACE}: replace value with the reference value (see {@link GraphicsDevice#setStencilFunc})
     * - {@link STENCILOP_INCREMENT}: increment the value
     * - {@link STENCILOP_INCREMENTWRAP}: increment the value, but wrap it to zero when it's larger
     * than a maximum representable value
     * - {@link STENCILOP_DECREMENT}: decrement the value
     * - {@link STENCILOP_DECREMENTWRAP}: decrement the value, but wrap it to a maximum
     * representable value, if the current value is 0
     * - {@link STENCILOP_INVERT}: invert the value bitwise
     *
     * @param {number} zfail - Action to take if depth test is failed.  Accepts the same values as
     * `fail`.
     * @param {number} zpass - Action to take if both depth and stencil test are passed. Accepts
     * the same values as `fail`.
     * @param {number} writeMask - A bit mask applied to the reference value, when written.
     */
    setStencilOperation(fail: number, zfail: number, zpass: number, writeMask: number): void;
    /**
     * Configures how stencil buffer values should be modified based on the result of depth/stencil
     * tests. Works for front faces.
     *
     * @param {number} fail - Action to take if stencil test is failed. Can be:
     *
     * - {@link STENCILOP_KEEP}: don't change the stencil buffer value
     * - {@link STENCILOP_ZERO}: set value to zero
     * - {@link STENCILOP_REPLACE}: replace value with the reference value (see {@link GraphicsDevice#setStencilFunc})
     * - {@link STENCILOP_INCREMENT}: increment the value
     * - {@link STENCILOP_INCREMENTWRAP}: increment the value, but wrap it to zero when it's larger
     * than a maximum representable value
     * - {@link STENCILOP_DECREMENT}: decrement the value
     * - {@link STENCILOP_DECREMENTWRAP}: decrement the value, but wrap it to a maximum
     * representable value, if the current value is 0
     * - {@link STENCILOP_INVERT}: invert the value bitwise
     *
     * @param {number} zfail - Action to take if depth test is failed.  Accepts the same values as
     * `fail`.
     * @param {number} zpass - Action to take if both depth and stencil test are passed.  Accepts
     * the same values as `fail`.
     * @param {number} writeMask - A bit mask applied to the reference value, when written.
     */
    setStencilOperationFront(fail: number, zfail: number, zpass: number, writeMask: number): void;
    /**
     * Configures how stencil buffer values should be modified based on the result of depth/stencil
     * tests. Works for back faces.
     *
     * @param {number} fail - Action to take if stencil test is failed. Can be:
     *
     * - {@link STENCILOP_KEEP}: don't change the stencil buffer value
     * - {@link STENCILOP_ZERO}: set value to zero
     * - {@link STENCILOP_REPLACE}: replace value with the reference value (see {@link GraphicsDevice#setStencilFunc})
     * - {@link STENCILOP_INCREMENT}: increment the value
     * - {@link STENCILOP_INCREMENTWRAP}: increment the value, but wrap it to zero when it's larger
     * than a maximum representable value
     * - {@link STENCILOP_DECREMENT}: decrement the value
     * - {@link STENCILOP_DECREMENTWRAP}: decrement the value, but wrap it to a maximum
     * representable value, if the current value is 0
     * - {@link STENCILOP_INVERT}: invert the value bitwise
     *
     * @param {number} zfail - Action to take if depth test is failed. Accepts the same values as
     * `fail`.
     * @param {number} zpass - Action to take if both depth and stencil test are passed. Accepts
     * the same values as `fail`.
     * @param {number} writeMask - A bit mask applied to the reference value, when written.
     */
    setStencilOperationBack(fail: number, zfail: number, zpass: number, writeMask: number): void;
    /**
     * Configures blending operations. Both source and destination blend modes can take the
     * following values:
     *
     * - {@link BLENDMODE_ZERO}
     * - {@link BLENDMODE_ONE}
     * - {@link BLENDMODE_SRC_COLOR}
     * - {@link BLENDMODE_ONE_MINUS_SRC_COLOR}
     * - {@link BLENDMODE_DST_COLOR}
     * - {@link BLENDMODE_ONE_MINUS_DST_COLOR}
     * - {@link BLENDMODE_SRC_ALPHA}
     * - {@link BLENDMODE_SRC_ALPHA_SATURATE}
     * - {@link BLENDMODE_ONE_MINUS_SRC_ALPHA}
     * - {@link BLENDMODE_DST_ALPHA}
     * - {@link BLENDMODE_ONE_MINUS_DST_ALPHA}
     * - {@link BLENDMODE_CONSTANT_COLOR}
     * - {@link BLENDMODE_ONE_MINUS_CONSTANT_COLOR}
     * - {@link BLENDMODE_CONSTANT_ALPHA}
     * - {@link BLENDMODE_ONE_MINUS_CONSTANT_ALPHA}
     *
     * @param {number} blendSrc - The source blend function.
     * @param {number} blendDst - The destination blend function.
     */
    setBlendFunction(blendSrc: number, blendDst: number): void;
    /**
     * Configures blending operations. Both source and destination blend modes can take the
     * following values:
     *
     * - {@link BLENDMODE_ZERO}
     * - {@link BLENDMODE_ONE}
     * - {@link BLENDMODE_SRC_COLOR}
     * - {@link BLENDMODE_ONE_MINUS_SRC_COLOR}
     * - {@link BLENDMODE_DST_COLOR}
     * - {@link BLENDMODE_ONE_MINUS_DST_COLOR}
     * - {@link BLENDMODE_SRC_ALPHA}
     * - {@link BLENDMODE_SRC_ALPHA_SATURATE}
     * - {@link BLENDMODE_ONE_MINUS_SRC_ALPHA}
     * - {@link BLENDMODE_DST_ALPHA}
     * - {@link BLENDMODE_ONE_MINUS_DST_ALPHA}
     *
     * @param {number} blendSrc - The source blend function.
     * @param {number} blendDst - The destination blend function.
     * @param {number} blendSrcAlpha - The separate source blend function for the alpha channel.
     * @param {number} blendDstAlpha - The separate destination blend function for the alpha channel.
     */
    setBlendFunctionSeparate(blendSrc: number, blendDst: number, blendSrcAlpha: number, blendDstAlpha: number): void;
    /**
     * Configures the blending equation. The default blend equation is {@link BLENDEQUATION_ADD}.
     *
     * @param {number} blendEquation - The blend equation. Can be:
     *
     * - {@link BLENDEQUATION_ADD}
     * - {@link BLENDEQUATION_SUBTRACT}
     * - {@link BLENDEQUATION_REVERSE_SUBTRACT}
     * - {@link BLENDEQUATION_MIN}
     * - {@link BLENDEQUATION_MAX}
     *
     * Note that MIN and MAX modes require either EXT_blend_minmax or WebGL2 to work (check
     * device.extBlendMinmax).
     */
    setBlendEquation(blendEquation: number): void;
    /**
     * Configures the blending equation. The default blend equation is {@link BLENDEQUATION_ADD}.
     *
     * @param {number} blendEquation - The blend equation. Can be:
     *
     * - {@link BLENDEQUATION_ADD}
     * - {@link BLENDEQUATION_SUBTRACT}
     * - {@link BLENDEQUATION_REVERSE_SUBTRACT}
     * - {@link BLENDEQUATION_MIN}
     * - {@link BLENDEQUATION_MAX}
     *
     * Note that MIN and MAX modes require either EXT_blend_minmax or WebGL2 to work (check
     * device.extBlendMinmax).
     * @param {number} blendAlphaEquation - A separate blend equation for the alpha channel.
     * Accepts same values as `blendEquation`.
     */
    setBlendEquationSeparate(blendEquation: number, blendAlphaEquation: number): void;
    /**
     * Set the source and destination blending factors.
     *
     * @param {number} r - The red component in the range of 0 to 1. Default value is 0.
     * @param {number} g - The green component in the range of 0 to 1. Default value is 0.
     * @param {number} b - The blue component in the range of 0 to 1. Default value is 0.
     * @param {number} a - The alpha component in the range of 0 to 1. Default value is 0.
     * @ignore
     */
    setBlendColor(r: number, g: number, b: number, a: number): void;
    /**
     * Controls how triangles are culled based on their face direction. The default cull mode is
     * {@link CULLFACE_BACK}.
     *
     * @param {number} cullMode - The cull mode to set. Can be:
     *
     * - {@link CULLFACE_NONE}
     * - {@link CULLFACE_BACK}
     * - {@link CULLFACE_FRONT}
     * - {@link CULLFACE_FRONTANDBACK}
     */
    setCullMode(cullMode: number): void;
    cullFace: any;
    /**
     * Gets the current cull mode.
     *
     * @returns {number} The current cull mode.
     * @ignore
     */
    getCullMode(): number;
    /**
     * Sets the current index buffer on the graphics device. On subsequent calls to
     * {@link GraphicsDevice#draw}, the specified index buffer will be used to provide index data
     * for any indexed primitives.
     *
     * @param {IndexBuffer} indexBuffer - The index buffer to assign to the device.
     */
    setIndexBuffer(indexBuffer: IndexBuffer): void;
    /**
     * Sets the current vertex buffer on the graphics device. On subsequent calls to
     * {@link GraphicsDevice#draw}, the specified vertex buffer(s) will be used to provide vertex
     * data for any primitives.
     *
     * @param {VertexBuffer} vertexBuffer - The vertex buffer to assign to the device.
     */
    setVertexBuffer(vertexBuffer: VertexBuffer): void;
    /**
     * Sets the active shader to be used during subsequent draw calls.
     *
     * @param {Shader} shader - The shader to set to assign to the device.
     * @returns {boolean} True if the shader was successfully set, false otherwise.
     */
    setShader(shader: Shader): boolean;
    attributesInvalidated: boolean;
    /**
     * Get the supported HDR pixel format.
     * Note that for WebGL2, PIXELFORMAT_RGB16F and PIXELFORMAT_RGB32F are not renderable according to this:
     * https://developer.mozilla.org/en-US/docs/Web/API/EXT_color_buffer_float
     * For WebGL1, only PIXELFORMAT_RGBA16F and PIXELFORMAT_RGBA32F are tested for being renderable.
     *
     * @returns {number} The HDR pixel format.
     * @ignore
     */
    getHdrFormat(): number;
    /**
     * Queries the maximum number of bones that can be referenced by a shader. The shader
     * generators (programlib) use this number to specify the matrix array size of the uniform
     * 'matrix_pose[0]'. The value is calculated based on the number of available uniform vectors
     * available after subtracting the number taken by a typical heavyweight shader. If a different
     * number is required, it can be tuned via {@link GraphicsDevice#setBoneLimit}.
     *
     * @returns {number} The maximum number of bones that can be supported by the host hardware.
     * @ignore
     */
    getBoneLimit(): number;
    /**
     * Specifies the maximum number of bones that the device can support on the current hardware.
     * This function allows the default calculated value based on available vector uniforms to be
     * overridden.
     *
     * @param {number} maxBones - The maximum number of bones supported by the host hardware.
     * @ignore
     */
    setBoneLimit(maxBones: number): void;
    /**
     * Frees memory from all shaders ever allocated with this device.
     *
     * @ignore
     */
    clearShaderCache(): void;
    /**
     * Frees memory from all vertex array objects ever allocated with this device.
     *
     * @ignore
     */
    clearVertexArrayObjectCache(): void;
    /**
     * Removes a shader from the cache.
     *
     * @param {Shader} shader - The shader to remove from the cache.
     * @ignore
     */
    removeShaderFromCache(shader: Shader): void;
    /**
     * Check if high precision floating-point textures are supported.
     *
     * @type {boolean}
     */
    get textureFloatHighPrecision(): boolean;
    /**
     * Check if texture with half float format can be updated with data.
     *
     * @type {boolean}
     */
    get textureHalfFloatUpdatable(): boolean;
}






/** @typedef {import('../input/element-input.js').ElementInput} ElementInput */
/** @typedef {import('../input/game-pads.js').GamePads} GamePads */
/** @typedef {import('../input/keyboard.js').Keyboard} Keyboard */
/** @typedef {import('../input/mouse.js').Mouse} Mouse */
/** @typedef {import('../input/touch-device.js').TouchDevice} TouchDevice */
/**
 * An Application represents and manages your PlayCanvas application. If you are developing using
 * the PlayCanvas Editor, the Application is created for you. You can access your Application
 * instance in your scripts. Below is a skeleton script which shows how you can access the
 * application 'app' property inside the initialize and update functions:
 *
 * ```javascript
 * // Editor example: accessing the pc.Application from a script
 * var MyScript = pc.createScript('myScript');
 *
 * MyScript.prototype.initialize = function() {
 *     // Every script instance has a property 'this.app' accessible in the initialize...
 *     var app = this.app;
 * };
 *
 * MyScript.prototype.update = function(dt) {
 *     // ...and update functions.
 *     var app = this.app;
 * };
 * ```
 *
 * If you are using the Engine without the Editor, you have to create the application instance
 * manually.
 *
 * @augments AppBase
 */
declare class Application extends AppBase {
    /**
     * Create a new Application instance.
     *
     * @param {Element} canvas - The canvas element.
     * @param {object} [options] - The options object to configure the Application.
     * @param {ElementInput} [options.elementInput] - Input handler for {@link ElementComponent}s.
     * @param {Keyboard} [options.keyboard] - Keyboard handler for input.
     * @param {Mouse} [options.mouse] - Mouse handler for input.
     * @param {TouchDevice} [options.touch] - TouchDevice handler for input.
     * @param {GamePads} [options.gamepads] - Gamepad handler for input.
     * @param {string} [options.scriptPrefix] - Prefix to apply to script urls before loading.
     * @param {string} [options.assetPrefix] - Prefix to apply to asset urls before loading.
     * @param {object} [options.graphicsDeviceOptions] - Options object that is passed into the
     * {@link GraphicsDevice} constructor.
     * @param {string[]} [options.scriptsOrder] - Scripts in order of loading first.
     * @example
     * // Engine-only example: create the application manually
     * var app = new pc.Application(canvas, options);
     *
     * // Start the application's main loop
     * app.start();
     */
    constructor(canvas: Element, options?: {
        elementInput?: ElementInput;
        keyboard?: Keyboard;
        mouse?: Mouse;
        touch?: TouchDevice;
        gamepads?: GamePads;
        scriptPrefix?: string;
        assetPrefix?: string;
        graphicsDeviceOptions?: object;
        scriptsOrder?: string[];
    });
    createDevice(canvas: any, options: any): WebglGraphicsDevice;
    addComponentSystems(appOptions: any): void;
    addResourceHandles(appOptions: any): void;
}

declare function inherits(Self: any, Super: any): {
    (arg1: any, arg2: any, arg3: any, arg4: any, arg5: any, arg6: any, arg7: any, arg8: any): void;
    _super: any;
    prototype: any;
};
declare function makeArray(arr: any): any;
declare function UnsupportedBrowserError(message: any): void;
declare class UnsupportedBrowserError {
    constructor(message: any);
    name: string;
    message: any;
}
declare function ContextCreationError(message: any): void;
declare class ContextCreationError {
    constructor(message: any);
    name: string;
    message: any;
}
declare function basisSetDownloadConfig(glueUrl: any, wasmUrl: any, fallbackUrl: any): void;
declare function prefilterCubemap(options: any): void;
declare namespace log {
    function write(text: any): void;
    function open(): void;
    function info(text: any): void;
    function debug(text: any): void;
    function error(text: any): void;
    function warning(text: any): void;
    function alert(text: any): void;
    function assert(condition: any, text: any): void;
}
declare namespace time {
    export { now };
    export { Timer };
}
declare namespace shape {
    export { BoundingBox as Aabb };
    export { BoundingSphere as Sphere };
    export { Plane };
}
declare const ELEMENTTYPE_INT8: number;
declare const ELEMENTTYPE_UINT8: number;
declare const ELEMENTTYPE_INT16: number;
declare const ELEMENTTYPE_UINT16: number;
declare const ELEMENTTYPE_INT32: number;
declare const ELEMENTTYPE_UINT32: number;
declare const ELEMENTTYPE_FLOAT32: number;
declare namespace programlib {
    export { begin };
    export { dummyFragmentCode };
    export { end };
    export { fogCode };
    export { gammaCode };
    export { precisionCode };
    export { skinCode };
    export { tonemapCode };
    export { versionCode };
}
declare namespace gfx {
    export { ADDRESS_CLAMP_TO_EDGE };
    export { ADDRESS_MIRRORED_REPEAT };
    export { ADDRESS_REPEAT };
    export { BLENDMODE_ZERO };
    export { BLENDMODE_ONE };
    export { BLENDMODE_SRC_COLOR };
    export { BLENDMODE_ONE_MINUS_SRC_COLOR };
    export { BLENDMODE_DST_COLOR };
    export { BLENDMODE_ONE_MINUS_DST_COLOR };
    export { BLENDMODE_SRC_ALPHA };
    export { BLENDMODE_SRC_ALPHA_SATURATE };
    export { BLENDMODE_ONE_MINUS_SRC_ALPHA };
    export { BLENDMODE_DST_ALPHA };
    export { BLENDMODE_ONE_MINUS_DST_ALPHA };
    export { BUFFER_STATIC };
    export { BUFFER_DYNAMIC };
    export { BUFFER_STREAM };
    export { CULLFACE_NONE };
    export { CULLFACE_BACK };
    export { CULLFACE_FRONT };
    export { CULLFACE_FRONTANDBACK };
    export { TYPE_INT8 as ELEMENTTYPE_INT8 };
    export { TYPE_UINT8 as ELEMENTTYPE_UINT8 };
    export { TYPE_INT16 as ELEMENTTYPE_INT16 };
    export { TYPE_UINT16 as ELEMENTTYPE_UINT16 };
    export { TYPE_INT32 as ELEMENTTYPE_INT32 };
    export { TYPE_UINT32 as ELEMENTTYPE_UINT32 };
    export { TYPE_FLOAT32 as ELEMENTTYPE_FLOAT32 };
    export { FILTER_NEAREST };
    export { FILTER_LINEAR };
    export { FILTER_NEAREST_MIPMAP_NEAREST };
    export { FILTER_NEAREST_MIPMAP_LINEAR };
    export { FILTER_LINEAR_MIPMAP_NEAREST };
    export { FILTER_LINEAR_MIPMAP_LINEAR };
    export { INDEXFORMAT_UINT8 };
    export { INDEXFORMAT_UINT16 };
    export { INDEXFORMAT_UINT32 };
    export { PIXELFORMAT_R5_G6_B5 };
    export { PIXELFORMAT_R8_G8_B8 };
    export { PIXELFORMAT_R8_G8_B8_A8 };
    export { PRIMITIVE_POINTS };
    export { PRIMITIVE_LINES };
    export { PRIMITIVE_LINELOOP };
    export { PRIMITIVE_LINESTRIP };
    export { PRIMITIVE_TRIANGLES };
    export { PRIMITIVE_TRISTRIP };
    export { PRIMITIVE_TRIFAN };
    export { SEMANTIC_POSITION };
    export { SEMANTIC_NORMAL };
    export { SEMANTIC_COLOR };
    export { SEMANTIC_TEXCOORD };
    export { SEMANTIC_TEXCOORD0 };
    export { SEMANTIC_TEXCOORD1 };
    export { SEMANTIC_ATTR0 };
    export { SEMANTIC_ATTR1 };
    export { SEMANTIC_ATTR2 };
    export { SEMANTIC_ATTR3 };
    export { TEXTURELOCK_READ };
    export { TEXTURELOCK_WRITE };
    export { drawQuadWithShader };
    export { programlib };
    export { shaderChunks };
    export { ContextCreationError };
    export { GraphicsDevice as Device };
    export { IndexBuffer };
    export { ProgramLibrary };
    export { RenderTarget };
    export { ScopeId };
    export { Shader };
    export { ShaderInput };
    export { Texture };
    export { UnsupportedBrowserError };
    export { VertexBuffer };
    export { VertexFormat };
    export { VertexIterator };
}
declare namespace posteffect {
    export { createFullscreenQuad };
    export { drawFullscreenQuad };
    export { PostEffect$1 as PostEffect };
    export { PostEffectQueue };
}
declare const PhongMaterial: typeof StandardMaterial;
declare namespace scene {
    export { partitionSkin };
    export namespace procedural {
        export { calculateTangents };
        export { createMesh };
        export { createTorus };
        export { createCylinder };
        export { createCapsule };
        export { createCone };
        export { createSphere };
        export { createPlane };
        export { createBox };
    }
    export { BasicMaterial };
    export { Command };
    export { ForwardRenderer };
    export { GraphNode };
    export { Material };
    export { Mesh };
    export { MeshInstance };
    export { Model };
    export { ParticleEmitter };
    export { StandardMaterial as PhongMaterial };
    export { Picker };
    export namespace Projection {
        export { PROJECTION_ORTHOGRAPHIC as ORTHOGRAPHIC };
        export { PROJECTION_PERSPECTIVE as PERSPECTIVE };
    }
    export { Scene };
    export { Skin };
    export { SkinInstance };
}
declare namespace anim {
    export { Animation };
    export { Key };
    export { Node$1 as Node };
    export { Skeleton };
}
declare namespace audio {
    export { SoundManager as AudioManager };
    export { Channel };
    export { Channel3d };
    export { Listener };
    export { Sound };
}
declare namespace asset {
    const ASSET_ANIMATION: string;
    const ASSET_AUDIO: string;
    const ASSET_IMAGE: string;
    const ASSET_JSON: string;
    const ASSET_MODEL: string;
    const ASSET_MATERIAL: string;
    const ASSET_TEXT: string;
    const ASSET_TEXTURE: string;
    const ASSET_CUBEMAP: string;
    const ASSET_SCRIPT: string;
}
declare namespace input {
    export { getTouchTargetCoords };
    export { Controller };
    export { GamePads };
    export { Keyboard };
    export { KeyboardEvent };
    export { Mouse };
    export { MouseEvent$1 as MouseEvent };
    export { Touch$1 as Touch };
    export { TouchDevice };
    export { TouchEvent$1 as TouchEvent };
}
declare const RIGIDBODY_TYPE_STATIC: string;
declare const RIGIDBODY_TYPE_DYNAMIC: string;
declare const RIGIDBODY_TYPE_KINEMATIC: string;
declare const RIGIDBODY_CF_STATIC_OBJECT: 1;
declare const RIGIDBODY_CF_KINEMATIC_OBJECT: 2;
declare const RIGIDBODY_CF_NORESPONSE_OBJECT: 4;
declare const RIGIDBODY_ACTIVE_TAG: 1;
declare const RIGIDBODY_ISLAND_SLEEPING: 2;
declare const RIGIDBODY_WANTS_DEACTIVATION: 3;
declare const RIGIDBODY_DISABLE_DEACTIVATION: 4;
declare const RIGIDBODY_DISABLE_SIMULATION: 5;
declare namespace fw {
    export { Application };
    export { Component };
    export { ComponentSystem };
    export { Entity };
    export namespace FillMode {
        export { FILLMODE_NONE as NONE };
        export { FILLMODE_FILL_WINDOW as FILL_WINDOW };
        export { FILLMODE_KEEP_ASPECT as KEEP_ASPECT };
    }
    export namespace ResolutionMode {
        export { RESOLUTION_AUTO as AUTO };
        export { RESOLUTION_FIXED as FIXED };
    }
}

declare namespace events {
    function attach(target: any): any;
    const _addCallback: (name: string, callback: HandleEventCallback, scope?: any, once?: boolean) => void;
    const on: (name: string, callback: HandleEventCallback, scope?: any) => EventHandler;
    const off: (name?: string, callback?: HandleEventCallback, scope?: any) => EventHandler;
    const fire: (name: string, arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any, arg8?: any) => EventHandler;
    const once: (name: string, callback: HandleEventCallback, scope?: any) => EventHandler;
    const hasEvent: (name: string) => boolean;
}

declare namespace guid {
    function create(): string;
}

declare namespace path {
    const delimiter: string;
    function join(...args: string[]): string;
    function normalize(pathname: string): string;
    function split(pathname: string): string[];
    function getBasename(pathname: string): string;
    function getDirectory(pathname: string): string;
    function getExtension(pathname: string): string;
    function isRelativePath(pathname: string): boolean;
    function extractPath(pathname: string): string;
}

declare namespace platform {
    export { environment };
    export const global: object;
    export const browser: boolean;
    export { desktop };
    export { mobile };
    export { ios };
    export { android };
    export { windows };
    export { xbox };
    export { gamepads };
    export { touch };
    export { workers };
    export { passiveEvents };
}
declare const environment: "browser" | "node";
declare let desktop: boolean;
declare let mobile: boolean;
declare let ios: boolean;
declare let android: boolean;
declare let windows: boolean;
declare let xbox: boolean;
declare let gamepads: boolean;
declare let touch: boolean;
declare let workers: boolean;
declare let passiveEvents: boolean;

declare namespace string {
    export { ASCII_LOWERCASE };
    export { ASCII_UPPERCASE };
    export { ASCII_LETTERS };
    export function format(s: string, ...args: any[]): string;
    export function toBool(s: string, strict?: boolean): boolean;
    export function getCodePoint(string: string, i?: number): number;
    export function getCodePoints(string: string): number[];
    export function getSymbols(string: string): string[];
    export function fromCodePoint(...args: number[]): string;
}
declare const ASCII_LOWERCASE: "abcdefghijklmnopqrstuvwxyz";
declare const ASCII_UPPERCASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
declare const ASCII_LETTERS: string;

/**
 * Callback used by {@link ModulesetConfig }.
 */
export type ModuleErrorCallback = (error: string) => any;
/**
 * Callback used by {@link ModulegetInstance }.
 */
export type ModuleInstanceCallback = (moduleInstance: any) => any;
/**
 * Callback used by {@link Module#setConfig}.
 *
 * @callback ModuleErrorCallback
 * @param {string} error - If the instance fails to load this will contain a description of the error.
 */
/**
 * Callback used by {@link Module#getInstance}.
 *
 * @callback ModuleInstanceCallback
 * @param {any} moduleInstance - The module instance.
 */
/**
 * A pure static utility class which supports immediate and lazy loading of wasm modules.
 */
declare class WasmModule {
    /**
     * Set a wasm module's configuration.
     *
     * @param {string} moduleName - Name of the module.
     * @param {object} [config] - The configuration object.
     * @param {string} [config.glueUrl] - URL of glue script.
     * @param {string} [config.wasmUrl] - URL of the wasm script.
     * @param {string} [config.fallbackUrl] - URL of the fallback script to use when wasm modules
     * aren't supported.
     * @param {ModuleErrorCallback} [config.errorHandler] - Function to be called if the module fails
     * to download.
     */
    static setConfig(moduleName: string, config?: {
        glueUrl?: string;
        wasmUrl?: string;
        fallbackUrl?: string;
        errorHandler?: ModuleErrorCallback;
    }): void;
    /**
     * Get a wasm module instance. The instance will be created if necessary and returned
     * in the second parameter to callback.
     *
     * @param {string} moduleName - Name of the module.
     * @param {ModuleInstanceCallback} callback - The function called when the instance is
     * available.
     */
    static getInstance(moduleName: string, callback: ModuleInstanceCallback): void;
}

/**
 * Helper class for organized reading of memory.
 *
 * @ignore
 */
declare class ReadStream {
    constructor(arraybuffer: any);
    arraybuffer: any;
    dataView: DataView;
    offset: number;
    stack: any[];
    get remainingBytes(): number;
    reset(offset?: number): void;
    skip(bytes: any): void;
    align(bytes: any): void;
    _inc(amount: any): number;
    readChar(): string;
    readChars(numChars: any): string;
    readU8(): number;
    readU16(): number;
    readU32(): number;
    readU64(): number;
    readU32be(): number;
    readArray(result: any): void;
    readLine(): string;
}

/**
 * Log tracing functionality, allowing for tracing of the internal functionality of the engine.
 * Note that the trace logging only takes place in the debug build of the engine and is stripped
 * out in other builds.
 */
declare class Tracing {
    /**
     * Set storing the names of enabled trace channels.
     *
     * @type {Set<string>}
     * @private
     */
    private static _traceChannels;
    /**
     * Enable or disable a trace channel.
     *
     * @param {string} channel - Name of the trace channel. Can be:
     *
     * - {@link TRACEID_RENDER_FRAME}
     * - {@link TRACEID_RENDER_PASS}
     * - {@link TRACEID_RENDER_PASS_DETAIL}
     * - {@link TRACEID_RENDER_ACTION}
     * - {@link TRACEID_RENDER_TARGET_ALLOC}
     * - {@link TRACEID_TEXTURE_ALLOC}
     * - {@link TRACEID_SHADER_ALLOC}
     *
     * @param {boolean} enabled - New enabled state for the channel.
     */
    static set(channel: string, enabled?: boolean): void;
    /**
     * Test if the trace channel is enabled.
     *
     * @param {string} channel - Name of the trace channnel.
     * @returns {boolean} - True if the trace channel is enabled.
     */
    static get(channel: string): boolean;
}

declare namespace math {
    const DEG_TO_RAD: number;
    const RAD_TO_DEG: number;
    function clamp(value: number, min: number, max: number): number;
    function intToBytes24(i: number): number[];
    function intToBytes32(i: number): number[];
    function bytesToInt24(r: number, g: number, b: number): number;
    function bytesToInt32(r: number, g: number, b: number, a: number): number;
    function lerp(a: number, b: number, alpha: number): number;
    function lerpAngle(a: number, b: number, alpha: number): number;
    function powerOfTwo(x: number): boolean;
    function nextPowerOfTwo(val: number): number;
    function random(min: number, max: number): number;
    function smoothstep(min: number, max: number, x: number): number;
    function smootherstep(min: number, max: number, x: number): number;
    function roundUp(numToRound: number, multiple: number): number;
    function between(num: number, a: number, b: number, inclusive: boolean): boolean;
}

/**
 * Oriented Box.
 */
declare class OrientedBox {
    /**
     * Create a new OrientedBox instance.
     *
     * @param {Mat4} [worldTransform] - Transform that has the orientation and position of the box.
     * Scale is assumed to be one.
     * @param {Vec3} [halfExtents] - Half the distance across the box in each local axis. The
     * constructor takes a reference of this parameter.
     */
    constructor(worldTransform?: Mat4, halfExtents?: Vec3);
    halfExtents: Vec3;
    /**
     * @type {Mat4}
     * @private
     */
    private _modelTransform;
    /**
     * @type {Mat4}
     * @private
     */
    private _worldTransform;
    /**
     * @type {BoundingBox}
     * @private
     */
    private _aabb;
    /**
     * The world transform of the OBB.
     *
     * @type {Mat4}
     */
    set worldTransform(arg: Mat4);
    get worldTransform(): Mat4;
    /**
     * Test if a ray intersects with the OBB.
     *
     * @param {Ray} ray - Ray to test against (direction must be normalized).
     * @param {Vec3} [point] - If there is an intersection, the intersection point will be copied
     * into here.
     * @returns {boolean} True if there is an intersection.
     */
    intersectsRay(ray: Ray, point?: Vec3): boolean;
    /**
     * Test if a point is inside a OBB.
     *
     * @param {Vec3} point - Point to test.
     * @returns {boolean} True if the point is inside the OBB and false otherwise.
     */
    containsPoint(point: Vec3): boolean;
    /**
     * Test if a Bounding Sphere is overlapping, enveloping, or inside this OBB.
     *
     * @param {BoundingSphere} sphere - Bounding Sphere to test.
     * @returns {boolean} True if the Bounding Sphere is overlapping, enveloping or inside this OBB
     * and false otherwise.
     */
    intersectsBoundingSphere(sphere: BoundingSphere): boolean;
}

declare function shFromCubemap(device: any, source: any, dontFlipX: any): Float32Array;


/**
 * This function reprojects textures between cubemap, equirectangular and octahedral formats. The
 * function can read and write textures with pixel data in RGBE, RGBM, linear and sRGB formats.
 * When specularPower is specified it will perform a phong-weighted convolution of the source (for
 * generating a gloss maps).
 *
 * @param {Texture} source - The source texture.
 * @param {Texture} target - The target texture.
 * @param {object} [options] - The options object.
 * @param {number} [options.specularPower] - Optional specular power. When specular power is
 * specified, the source is convolved by a phong-weighted kernel raised to the specified power.
 * Otherwise the function performs a standard resample.
 * @param {number} [options.numSamples] - Optional number of samples (default is 1024).
 * @param {number} [options.face] - Optional cubemap face to update (default is update all faces).
 * @param {string} [options.distribution] - Specify convolution distribution - 'none', 'lambert',
 * 'phong', 'ggx'. Default depends on specularPower.
 * @param {Vec4} [options.rect] - Optional viewport rectangle.
 * @param {number} [options.seamPixels] - Optional number of seam pixels to render
 */
declare function reprojectTexture(source: Texture, target: Texture, options?: {
    specularPower?: number;
    numSamples?: number;
    face?: number;
    distribution?: string;
    rect?: Vec4;
    seamPixels?: number;
}, ...args: any[]): void;

/**
 * Helper functions to support prefiltering lighting data.
 *
 * @ignore
 */
declare class EnvLighting {
    /**
     * Generate a skybox cubemap in the correct pixel format from the source texture.
     *
     * @param {Texture} source - The source texture. This is either a 2d texture in equirect format
     * or a cubemap.
     * @param {number} [size] - Size of the resulting texture. Otherwise use automatic sizing.
     * @returns {Texture} The resulting cubemap.
     */
    static generateSkyboxCubemap(source: Texture, size?: number): Texture;
    /**
     * Create a texture in the format needed to precalculate lighting data.
     *
     * @param {Texture} source - The source texture. This is either a 2d texture in equirect format
     * or a cubemap.
     * @param {object} [options] - Specify generation options.
     * @param {Texture} [options.target] - The target texture. If one is not provided then a
     * new texture will be created and returned.
     * @param {number} [options.size] - Size of the lighting source cubemap texture. Only used
     * if target isn't specified. Defaults to 128.
     * @returns {Texture} The resulting cubemap.
     */
    static generateLightingSource(source: Texture, options?: {
        target?: Texture;
        size?: number;
    }): Texture;
    /**
     * Generate the environment lighting atlas containing prefiltered reflections and ambient.
     *
     * @param {Texture} source - The source lighting texture, generated by generateLightingSource.
     * @param {object} [options] - Specify prefilter options.
     * @param {Texture} [options.target] - The target texture. If one is not provided then a
     * new texture will be created and returned.
     * @param {number} [options.size] - Size of the target texture to create. Only used if
     * target isn't specified. Defaults to 512.
     * @param {number} [options.numReflectionSamples] - Number of samples to use when generating
     * rough reflections. Defaults to 1024.
     * @param {number} [options.numAmbientSamples] - Number of samples to use when generating ambient
     * lighting. Defaults to 2048.
     * @returns {Texture} The resulting atlas
     */
    static generateAtlas(source: Texture, options?: {
        target?: Texture;
        size?: number;
        numReflectionSamples?: number;
        numAmbientSamples?: number;
    }): Texture;
    /**
     * Generate the environment lighting atlas from prefiltered cubemap data.
     *
     * @param {Texture[]} sources - Array of 6 prefiltered textures.
     * @param {object} [options] - The options object
     * @param {Texture} [options.target] - The target texture. If one is not provided then a
     * new texture will be created and returned.
     * @param {number} [options.size] - Size of the target texture to create. Only used if
     * target isn't specified. Defaults to 512.
     * @param {boolean} [options.legacyAmbient] - Enable generating legacy ambient lighting.
     * Default is false.
     * @param {number} [options.numSamples] - Number of samples to use when generating ambient
     * lighting. Default is 2048.
     * @returns {Texture} The resulting atlas texture.
     */
    static generatePrefilteredAtlas(sources: Texture[], options?: {
        target?: Texture;
        size?: number;
        legacyAmbient?: boolean;
        numSamples?: number;
    }): Texture;
}



/** @typedef {import('./graphics-device.js').GraphicsDevice} GraphicsDevice */
/** @typedef {import('./shader.js').Shader} Shader */
/**
 * This object allows you to configure and use the transform feedback feature (WebGL2 only). How to
 * use:
 *
 * 1. First, check that you're on WebGL2, by looking at the `app.graphicsDevice.webgl2`` value.
 * 2. Define the outputs in your vertex shader. The syntax is `out vec3 out_vertex_position`,
 * note that there must be out_ in the name. You can then simply assign values to these outputs in
 * VS. The order and size of shader outputs must match the output buffer layout.
 * 3. Create the shader using `TransformFeedback.createShader(device, vsCode, yourShaderName)`.
 * 4. Create/acquire the input vertex buffer. Can be any VertexBuffer, either manually created, or
 * from a Mesh.
 * 5. Create the TransformFeedback object: `var tf = new TransformFeedback(inputBuffer)`. This
 * object will internally create an output buffer.
 * 6. Run the shader: `tf.process(shader)`. Shader will take the input buffer, process it and write
 * to the output buffer, then the input/output buffers will be automatically swapped, so you'll
 * immediately see the result.
 *
 * ```javascript
 * // *** shader asset ***
 * attribute vec3 vertex_position;
 * attribute vec3 vertex_normal;
 * attribute vec2 vertex_texCoord0;
 * out vec3 out_vertex_position;
 * out vec3 out_vertex_normal;
 * out vec2 out_vertex_texCoord0;
 * void main(void) {
 *     // read position and normal, write new position (push away)
 *     out_vertex_position = vertex_position + vertex_normal * 0.01;
 *     // pass other attributes unchanged
 *     out_vertex_normal = vertex_normal;
 *     out_vertex_texCoord0 = vertex_texCoord0;
 * }
 * ```
 *
 * ```javascript
 * // *** script asset ***
 * var TransformExample = pc.createScript('transformExample');
 *
 * // attribute that references shader asset and material
 * TransformExample.attributes.add('shaderCode', { type: 'asset', assetType: 'shader' });
 * TransformExample.attributes.add('material', { type: 'asset', assetType: 'material' });
 *
 * TransformExample.prototype.initialize = function() {
 *     var device = this.app.graphicsDevice;
 *     var mesh = pc.createTorus(device, { tubeRadius: 0.01, ringRadius: 3 });
 *     var meshInstance = new pc.MeshInstance(mesh, this.material.resource);
 *     var entity = new pc.Entity();
 *     entity.addComponent('render', {
 *         type: 'asset',
 *         meshInstances: [meshInstance]
 *     });
 *     app.root.addChild(entity);
 *
 *     // if webgl2 is not supported, transform-feedback is not available
 *     if (!device.webgl2) return;
 *     var inputBuffer = mesh.vertexBuffer;
 *     this.tf = new pc.TransformFeedback(inputBuffer);
 *     this.shader = pc.TransformFeedback.createShader(device, this.shaderCode.resource, "tfMoveUp");
 * };
 *
 * TransformExample.prototype.update = function(dt) {
 *     if (!this.app.graphicsDevice.webgl2) return;
 *     this.tf.process(this.shader);
 * };
 * ```
 */
declare class TransformFeedback {
    /**
     * Creates a transform feedback ready vertex shader from code.
     *
     * @param {GraphicsDevice} graphicsDevice - The graphics device used by the renderer.
     * @param {string} vsCode - Vertex shader code. Should contain output variables starting with "out_".
     * @param {string} name - Unique name for caching the shader.
     * @returns {Shader} A shader to use in the process() function.
     */
    static createShader(graphicsDevice: GraphicsDevice, vsCode: string, name: string): Shader;
    /**
     * Create a new TransformFeedback instance.
     *
     * @param {VertexBuffer} inputBuffer - The input vertex buffer.
     * @param {number} [usage] - The optional usage type of the output vertex buffer. Can be:
     *
     * - {@link BUFFER_STATIC}
     * - {@link BUFFER_DYNAMIC}
     * - {@link BUFFER_STREAM}
     * - {@link BUFFER_GPUDYNAMIC}
     *
     * Defaults to {@link BUFFER_GPUDYNAMIC} (which is recommended for continuous update).
     */
    constructor(inputBuffer: VertexBuffer, usage?: number);
    device: GraphicsDevice;
    _inputBuffer: VertexBuffer;
    _outputBuffer: VertexBuffer;
    /**
     * Destroys the transform feedback helper object.
     */
    destroy(): void;
    /**
     * Runs the specified shader on the input buffer, writes results into the new buffer, then
     * optionally swaps input/output.
     *
     * @param {Shader} shader - A vertex shader to run. Should be created with
     * {@link TransformFeedback.createShader}.
     * @param {boolean} [swap] - Swap input/output buffer data. Useful for continuous buffer
     * processing. Default is true.
     */
    process(shader: Shader, swap?: boolean): void;
    /**
     * The current input buffer.
     *
     * @type {VertexBuffer}
     */
    get inputBuffer(): VertexBuffer;
    /**
     * The current output buffer.
     *
     * @type {VertexBuffer}
     */
    get outputBuffer(): VertexBuffer;
}

declare class SkinBatchInstance extends SkinInstance {
    constructor(device: any, nodes: any, rootNode: any);
    device: any;
    rootNode: any;
    bones: any;
}

/**
 * Holds stencil test settings.
 *
 * @property {number} func Sets stencil test function. See {@link GraphicsDevice#setStencilFunc}.
 * @property {number} ref Sets stencil test reference value. See
 * {@link GraphicsDevice#setStencilFunc}.
 * @property {number} fail Sets operation to perform if stencil test is failed. See
 * {@link GraphicsDevice#setStencilOperation}.
 * @property {number} zfail Sets operation to perform if depth test is failed. See
 * {@link GraphicsDevice#setStencilOperation}.
 * @property {number} zpass Sets operation to perform if both stencil and depth test are passed.
 * See {@link GraphicsDevice#setStencilOperation}.
 * @property {number} readMask Sets stencil test reading mask. See
 * {@link GraphicsDevice#setStencilFunc}.
 * @property {number} writeMask Sets stencil test writing mask. See
 * {@link GraphicsDevice#setStencilOperation}.
 */
declare class StencilParameters {
    /**
     * Create a new StencilParameters instance.
     *
     * @param {object} options - Options object to configure the stencil parameters.
     */
    constructor(options: object);
    func: any;
    ref: any;
    readMask: any;
    writeMask: any;
    fail: any;
    zfail: any;
    zpass: any;
    clone(): StencilParameters;
}

/**
 * Implementation of {@link AnimBinder} for animating a skeleton in the graph-node hierarchy.
 *
 * @implements {AnimBinder}
 * @ignore
 */
declare class DefaultAnimBinder implements AnimBinder {
    static createAnimTarget(func: any, type: any, valueCount: any, node: any, propertyPath: any, componentType: any): AnimTarget;
    constructor(graph: any);
    graph: any;
    _mask: any;
    nodes: {};
    targetCache: {};
    visitedFallbackGraphPaths: {};
    nodeCounts: {};
    activeNodes: any[];
    handlers: {
        localPosition: (node: any) => AnimTarget;
        localRotation: (node: any) => AnimTarget;
        localScale: (node: any) => AnimTarget;
        weight: (node: any, weightName: any) => AnimTarget;
        materialTexture: (node: any, textureName: any) => AnimTarget;
    };
    _isPathInMask: (path: any, checkMaskValue: any) => boolean;
    _isPathActive(path: any): boolean;
    findNode(path: any): any;
    resolve(path: any): any;
    unresolve(path: any): void;
    update(deltaTime: any): void;
    assignMask(mask: any): boolean;
}

/**
 * AnimTransitions represent connections in the controllers state graph between AnimStates. During
 * each frame, the controller tests to see if any of the AnimTransitions have the current AnimState
 * as their source (from) state. If so and the AnimTransitions parameter based conditions are met,
 * the controller will transition to the destination state.
 *
 * @ignore
 */
declare class AnimTransition {
    /**
     * Create a new AnimTransition.
     *
     * @param {object} options - Options.
     * @param {string} options.from - The state that this transition will exit from.
     * @param {string} options.to - The state that this transition will transition to.
     * @param {number} options.time - The duration of the transition in seconds. Defaults to 0.
     * @param {number} options.priority - Used to sort all matching transitions in ascending order.
     * The first transition in the list will be selected. Defaults to 0.
     * @param {object[]} options.conditions - A list of conditions which must pass for this
     * transition to be used. Defaults to [].
     * @param {number} options.exitTime - If provided, this transition will only be active for the
     * exact frame during which the source states progress passes the time specified. Given as a
     * normalized value of the source states duration. Values less than 1 will be checked every
     * animation loop. Defaults to null.
     * @param {number} options.transitionOffset - If provided, the destination state will begin
     * playing its animation at this time. Given in normalized time, based on the state's duration
     * and must be between 0 and 1. Defaults to null.
     * @param {string} options.interruptionSource - Defines whether another transition can
     * interrupt this one and which of the current or previous states transitions can do so. One of
     * pc.ANIM_INTERRUPTION_*. Defaults to pc.ANIM_INTERRUPTION_NONE.
     */
    constructor({ from, to, time, priority, conditions, exitTime, transitionOffset, interruptionSource }: {
        from: string;
        to: string;
        time: number;
        priority: number;
        conditions: object[];
        exitTime: number;
        transitionOffset: number;
        interruptionSource: string;
    });
    _from: string;
    _to: string;
    _time: number;
    _priority: number;
    _conditions: any[];
    _exitTime: number;
    _transitionOffset: number;
    _interruptionSource: string;
    get from(): string;
    set to(arg: string);
    get to(): string;
    get time(): number;
    get priority(): number;
    get conditions(): any[];
    get exitTime(): number;
    get transitionOffset(): number;
    get interruptionSource(): string;
    get hasExitTime(): boolean;
}



/** @typedef {import('../../core/event-handler.js').EventHandler} EventHandler */
/** @typedef {import('../evaluator/anim-evaluator.js').AnimEvaluator} AnimEvaluator */
/**
 * The AnimController manages the animations for its entity, based on the provided state graph and
 * parameters. Its update method determines which state the controller should be in based on the
 * current time, parameters and available states / transitions. It also ensures the AnimEvaluator
 * is supplied with the correct animations, based on the currently active state.
 *
 * @ignore
 */
declare class AnimController {
    /**
     * Create a new AnimController.
     *
     * @param {AnimEvaluator} animEvaluator - The animation evaluator used to blend all current
     * playing animation keyframes and update the entities properties based on the current
     * animation values.
     * @param {object[]} states - The list of states used to form the controller state graph.
     * @param {object[]} transitions - The list of transitions used to form the controller state
     * graph.
     * @param {object[]} parameters - The anim components parameters.
     * @param {boolean} activate - Determines whether the anim controller should automatically play
     * once all {@link AnimNodes} are assigned animations.
     * @param {EventHandler} eventHandler - The event handler which should be notified with anim
     * events.
     * @param {Set} consumedTriggers - Used to set triggers back to their default state after they
     * have been consumed by a transition.
     */
    constructor(animEvaluator: AnimEvaluator, states: object[], transitions: object[], parameters: object[], activate: boolean, eventHandler: EventHandler, consumedTriggers: Set<any>);
    _animEvaluator: AnimEvaluator;
    _states: {};
    _stateNames: any[];
    _eventHandler: EventHandler;
    _consumedTriggers: Set<any>;
    _transitions: AnimTransition[];
    _findTransitionsFromStateCache: {};
    _findTransitionsBetweenStatesCache: {};
    _parameters: any[];
    _previousStateName: any;
    _activeStateName: string;
    _playing: boolean;
    _activate: boolean;
    _currTransitionTime: number;
    _totalTransitionTime: number;
    _isTransitioning: boolean;
    _transitionInterruptionSource: string;
    _transitionPreviousStates: any[];
    _timeInState: number;
    _timeInStateBefore: number;
    get animEvaluator(): AnimEvaluator;
    set activeState(arg: any);
    get activeState(): any;
    get activeStateName(): string;
    get activeStateAnimations(): any;
    set previousState(arg: any);
    get previousState(): any;
    get previousStateName(): any;
    get playable(): boolean;
    set playing(arg: boolean);
    get playing(): boolean;
    get activeStateProgress(): number;
    get activeStateDuration(): number;
    set activeStateCurrentTime(arg: number);
    get activeStateCurrentTime(): number;
    get transitioning(): boolean;
    get transitionProgress(): number;
    get states(): any[];
    assignMask(mask: any): any;
    _findState(stateName: any): any;
    _getActiveStateProgressForTime(time: any): number;
    _findTransitionsFromState(stateName: any): any;
    _findTransitionsBetweenStates(sourceStateName: any, destinationStateName: any): any;
    _transitionHasConditionsMet(transition: any): boolean;
    _findTransition(from: any, to: any): any;
    updateStateFromTransition(transition: any): void;
    _transitionToState(newStateName: any): void;
    assignAnimation(pathString: any, animTrack: any, speed: any, loop: any): void;
    removeNodeAnimations(nodeName: any): boolean;
    play(stateName: any): void;
    pause(): void;
    reset(): void;
    rebind(): void;
    update(dt: any): void;
    findParameter(name: any): any;
}

/**
 * An asset resource which represents an anim state graph. It can be loaded into an anim component using the {@link AnimComponent#loadStateGraph} method.
 *
 * ## Usage
 * Scripts can retrieve an AnimStateGraph instance from assets of type 'animstategraph'. An AnimStateGraph can then be loaded into an anim component as follows:
 * ```javascript
 * const animStateGraph = app.assets.get(ASSET_ID).resource;
 * const entity = new pc.Entity();
 * entity.addComponent('anim');
 * entity.anim.loadStateGraph(animStateGraph);
 * ```
 */
declare class AnimStateGraph {
    /**
     * Create an AnimStateGraph instance from JSON data.
     *
     * @param {object} data - The JSON data to create the AnimStateGraph from.
     * @hideconstructor
     */
    constructor(data: object);
    _layers: any;
    _parameters: {};
    get parameters(): {};
    get layers(): any;
}



/**
 * A SoundInstance3d plays a {@link Sound} in 3D.
 *
 * @augments SoundInstance
 */
declare class SoundInstance3d extends SoundInstance {
    /**
     * Create a new SoundInstance3d instance.
     *
     * @param {SoundManager} manager - The sound manager.
     * @param {Sound} sound - The sound to play.
     * @param {object} options - Options for the instance.
     * @param {number} [options.volume=1] - The playback volume, between 0 and 1.
     * @param {number} [options.pitch=1] - The relative pitch, default of 1, plays at normal pitch.
     * @param {boolean} [options.loop=false] - Whether the sound should loop when it reaches the
     * end or not.
     * @param {number} [options.startTime=0] - The time from which the playback will start. Default
     * is 0 to start at the beginning.
     * @param {number} [options.duration=null] - The total time after the startTime when playback
     * will stop or restart if loop is true.
     * @param {Vec3} [options.position=null] - The position of the sound in 3D space.
     * @param {string} [options.distanceModel=DISTANCE_LINEAR] - Determines which algorithm to use
     * to reduce the volume of the audio as it moves away from the listener. Can be:
     *
     * - {@link DISTANCE_LINEAR}
     * - {@link DISTANCE_INVERSE}
     * - {@link DISTANCE_EXPONENTIAL}
     *
     * Default is {@link DISTANCE_LINEAR}.
     * @param {number} [options.refDistance=1] - The reference distance for reducing volume as the
     * sound source moves further from the listener.
     * @param {number} [options.maxDistance=10000] - The maximum distance from the listener at which
     * audio falloff stops. Note the volume of the audio is not 0 after this distance, but just
     * doesn't fall off anymore.
     * @param {number} [options.rollOffFactor=1] - The factor used in the falloff equation.
     */
    constructor(manager: SoundManager, sound: Sound, options?: {
        volume?: number;
        pitch?: number;
        loop?: boolean;
        startTime?: number;
        duration?: number;
        position?: Vec3;
        distanceModel?: string;
        refDistance?: number;
        maxDistance?: number;
        rollOffFactor?: number;
    });
    /**
     * @type {Vec3}
     * @private
     */
    private _position;
    /**
     * @type {Vec3}
     * @private
     */
    private _velocity;
    /**
     * The position of the sound in 3D space.
     *
     * @type {Vec3}
     */
    set position(arg: Vec3);
    get position(): Vec3;
    /**
     * The maximum distance from the listener at which audio falloff stops. Note the volume of the
     * audio is not 0 after this distance, but just doesn't fall off anymore.
     *
     * @type {number}
     */
    set maxDistance(arg: number);
    get maxDistance(): number;
    /**
     * The reference distance for reducing volume as the sound source moves further from the
     * listener.
     *
     * @type {number}
     */
    set refDistance(arg: number);
    get refDistance(): number;
    /**
     * The factor used in the falloff equation.
     *
     * @type {number}
     */
    set rollOffFactor(arg: number);
    get rollOffFactor(): number;
    /**
     * Determines which algorithm to use to reduce the volume of the audio as it moves away from
     * the listener. Can be:
     *
     * - {@link DISTANCE_LINEAR}
     * - {@link DISTANCE_INVERSE}
     * - {@link DISTANCE_EXPONENTIAL}
     *
     * Default is {@link DISTANCE_LINEAR}.
     *
     * @type {string}
     */
    set distanceModel(arg: DistanceModelType);
    get distanceModel(): DistanceModelType;
    panner: PannerNode;
    /**
     * The velocity of the sound.
     *
     * @type {Vec3}
     * @deprecated
     * @ignore
     */
    set velocity(arg: Vec3);
    get velocity(): Vec3;
}

/**
 * Represents the resource of a Bundle Asset, which contains an index that maps URLs to blob URLs.
 *
 * @ignore
 */
declare class Bundle {
    /**
     * Create a new Bundle instance.
     *
     * @param {object[]} files - An array of objects that have a name field and contain a
     * getBlobUrl() function.
     */
    constructor(files: object[]);
    _blobUrls: {};
    /**
     * Returns true if the specified URL exists in the loaded bundle.
     *
     * @param {string} url - The original file URL. Make sure you have called decodeURIComponent on
     * the URL first.
     * @returns {boolean} True of false.
     */
    hasBlobUrl(url: string): boolean;
    /**
     * Returns a blob URL for the specified URL.
     *
     * @param {string} url - The original file URL. Make sure you have called decodeURIComponent on
     * the URL first.
     * @returns {string} A blob URL.
     */
    getBlobUrl(url: string): string;
    /**
     * Destroys the bundle and frees up blob URLs.
     */
    destroy(): void;
}


/** @typedef {import('./handler.js').ResourceHandler} ResourceHandler */
/**
 * Resource handler used for loading {@link AnimClip} resources.
 *
 * @implements {ResourceHandler}
 * @ignore
 */
declare class AnimClipHandler implements ResourceHandler {
    constructor(app: any);
    /**
     * Type of the resource the handler handles.
     *
     * @type {string}
     */
    handlerType: string;
    maxRetries: number;
    load(url: any, callback: any): void;
    open(url: any, data: any): AnimTrack;
    patch(asset: any, assets: any): void;
}


/** @typedef {import('./handler.js').ResourceHandler} ResourceHandler */
/**
 * Resource handler used for loading {@link AnimStateGraph} resources.
 *
 * @implements {ResourceHandler}
 * @ignore
 */
declare class AnimStateGraphHandler implements ResourceHandler {
    constructor(app: any);
    /**
     * Type of the resource the handler handles.
     *
     * @type {string}
     */
    handlerType: string;
    maxRetries: number;
    load(url: any, callback: any): void;
    open(url: any, data: any): AnimStateGraph;
    patch(asset: any, assets: any): void;
}


/** @typedef {import('./handler.js').ResourceHandler} ResourceHandler */
/**
 * Resource handler used for loading {@link Animation} resources.
 *
 * @implements {ResourceHandler}
 */
declare class AnimationHandler implements ResourceHandler {
    /** @hideconstructor */
    constructor(app: any);
    /**
     * Type of the resource the handler handles.
     *
     * @type {string}
     */
    handlerType: string;
    maxRetries: number;
    load(url: any, callback: any): void;
    open(url: any, data: any): any;
    patch(asset: any, assets: any): void;
    _parseAnimationV3(data: any): Animation;
    _parseAnimationV4(data: any): Animation;
}



/**
 * Resource handler used for loading {@link Sound} resources.
 *
 * @implements {ResourceHandler}
 */
declare class AudioHandler implements ResourceHandler {
    /**
     * Create a new AudioHandler instance.
     *
     * @param {AppBase} app - The running {@link AppBase}.
     * @hideconstructor
     */
    constructor(app: AppBase);
    /**
     * Type of the resource the handler handles.
     *
     * @type {string}
     */
    handlerType: string;
    manager: SoundManager;
    maxRetries: number;
    _isSupported(url: any): boolean;
    load(url: any, callback: any): void;
    open(url: any, data: any): any;
    patch(asset: any, assets: any): void;
    /**
     * Loads an audio asset using an AudioContext by URL and calls success or error with the
     * created resource or error respectively.
     *
     * @param {string} url - The url of the audio asset.
     * @param {Function} success - Function to be called if the audio asset was loaded or if we
     * just want to continue without errors even if the audio is not loaded.
     * @param {Function} error - Function to be called if there was an error while loading the
     * audio asset.
     * @private
     */
    private _createSound;
}

declare class BinaryHandler {
    constructor(app: any);
    /**
     * Type of the resource the handler handles.
     *
     * @type {string}
     */
    handlerType: string;
    maxRetries: number;
    load(url: any, callback: any): void;
    open(url: any, data: any): any;
    patch(asset: any, assets: any): void;
}



/** @typedef {import('../framework/app-base.js').AppBase} AppBase */
/** @typedef {import('./handler.js').ResourceHandler} ResourceHandler */
/**
 * Loads Bundle Assets.
 *
 * @implements {ResourceHandler}
 * @ignore
 */
declare class BundleHandler implements ResourceHandler {
    /**
     * Create a new BundleHandler instance.
     *
     * @param {AppBase} app - The running {@link AppBase}.
     * @hideconstructor
     */
    constructor(app: AppBase);
    /**
     * Type of the resource the handler handles.
     *
     * @type {string}
     */
    handlerType: string;
    _assets: AssetRegistry;
    _worker: any;
    maxRetries: number;
    load(url: any, callback: any): void;
    _untar(response: any, callback: any): void;
    open(url: any, data: any): Bundle;
    patch(asset: any, assets: any): void;
}



/** @typedef {import('./handler.js').ResourceHandler} ResourceHandler */
/** @typedef {import('../framework/app-base.js').AppBase} AppBase */
/**
 * Resource handler used for loading cubemap {@link Texture} resources.
 *
 * @implements {ResourceHandler}
 */
declare class CubemapHandler implements ResourceHandler {
    /**
     * Create a new CubemapHandler instance.
     *
     * @param {AppBase} app - The running {@link AppBase}.
     * @hideconstructor
     */
    constructor(app: AppBase);
    /**
     * Type of the resource the handler handles.
     *
     * @type {string}
     */
    handlerType: string;
    _device: GraphicsDevice;
    _registry: AssetRegistry;
    _loader: ResourceLoader;
    load(url: any, callback: any, asset: any): void;
    open(url: any, data: any, asset: any): any;
    patch(asset: any, registry: any): void;
    getAssetIds(cubemapAsset: any): any[];
    compareAssetIds(assetIdA: any, assetIdB: any): boolean;
    update(cubemapAsset: any, assetIds: any, assets: any): void;
    cmpArrays(arr1: any, arr2: any): boolean;
    resolveId(value: any): any;
    loadAssets(cubemapAsset: any, callback: any): void;
}

declare class FolderHandler {
    /**
     * Type of the resource the handler handles.
     *
     * @type {string}
     */
    handlerType: string;
    load(url: any, callback: any): void;
    open(url: any, data: any): any;
}



/**
 * Resource handler used for loading {@link Font} resources.
 *
 * @implements {ResourceHandler}
 */
declare class FontHandler implements ResourceHandler {
    /**
     * Create a new FontHandler instance.
     *
     * @param {AppBase} app - The running {@link AppBase}.
     * @hideconstructor
     */
    constructor(app: AppBase);
    /**
     * Type of the resource the handler handles.
     *
     * @type {string}
     */
    handlerType: string;
    _loader: ResourceLoader;
    maxRetries: number;
    load(url: any, callback: any, asset: any): void;
    _loadTextures(url: any, data: any, callback: any): void;
    open(url: any, data: any, asset: any): Font;
    patch(asset: any, assets: any): void;
}

declare class HierarchyHandler {
    constructor(app: any);
    /**
     * Type of the resource the handler handles.
     *
     * @type {string}
     */
    handlerType: string;
    _app: any;
    maxRetries: number;
    load(url: any, callback: any): void;
    open(url: any, data: any): Entity;
}

declare class HtmlHandler {
    constructor(app: any);
    /**
     * Type of the resource the handler handles.
     *
     * @type {string}
     */
    handlerType: string;
    maxRetries: number;
    load(url: any, callback: any): void;
    open(url: any, data: any): any;
    patch(asset: any, assets: any): void;
}

declare class JsonHandler {
    constructor(app: any);
    /**
     * Type of the resource the handler handles.
     *
     * @type {string}
     */
    handlerType: string;
    maxRetries: number;
    load(url: any, callback: any): void;
    open(url: any, data: any): any;
    patch(asset: any, assets: any): void;
}

declare class StandardMaterialValidator {
    removeInvalid: boolean;
    valid: boolean;
    enumValidators: {
        occludeSpecular: (value: any) => boolean;
        cull: (value: any) => boolean;
        blendType: (value: any) => boolean;
        depthFunc: (value: any) => boolean;
        shadingModel: (value: any) => boolean;
    };
    setInvalid(key: any, data: any): void;
    validate(data: any): boolean;
    _createEnumValidator(values: any): (value: any) => boolean;
}

/**
 * Convert incoming JSON data into a {@link StandardMaterial}.
 *
 * @ignore
 */
declare class JsonStandardMaterialParser {
    _validator: StandardMaterialValidator;
    parse(input: any): StandardMaterial;
    /**
     * Initialize material properties from the material data block e.g. Loading from server.
     *
     * @param {StandardMaterial} material - The material to be initialized.
     * @param {object} data - The data block that is used to initialize.
     */
    initialize(material: StandardMaterial, data: object): void;
    migrate(data: any): any;
    _validate(data: any): any;
}



/**
 * Resource handler used for loading {@link Material} resources.
 *
 * @implements {ResourceHandler}
 */
declare class MaterialHandler implements ResourceHandler {
    /**
     * Create a new MaterialHandler instance.
     *
     * @param {AppBase} app - The running {@link AppBase}.
     * @hideconstructor
     */
    constructor(app: AppBase);
    /**
     * Type of the resource the handler handles.
     *
     * @type {string}
     */
    handlerType: string;
    _assets: AssetRegistry;
    _device: GraphicsDevice;
    _placeholderTextures: {};
    _parser: JsonStandardMaterialParser;
    maxRetries: number;
    load(url: any, callback: any): void;
    open(url: any, data: any): StandardMaterial;
    _createPlaceholders(): void;
    patch(asset: any, assets: any): void;
    _onAssetUnload(asset: any): void;
    _assignTexture(parameterName: any, materialAsset: any, texture: any): void;
    _getPlaceholderTexture(parameterName: any): any;
    _assignPlaceholderTexture(parameterName: any, materialAsset: any): void;
    _onTextureLoad(parameterName: any, materialAsset: any, textureAsset: any): void;
    _onTextureAdd(parameterName: any, materialAsset: any, textureAsset: any): void;
    _onTextureRemoveOrUnload(parameterName: any, materialAsset: any, textureAsset: any): void;
    _assignCubemap(parameterName: any, materialAsset: any, textures: any): void;
    _onCubemapLoad(parameterName: any, materialAsset: any, cubemapAsset: any): void;
    _onCubemapAdd(parameterName: any, materialAsset: any, cubemapAsset: any): void;
    _onCubemapRemoveOrUnload(parameterName: any, materialAsset: any, cubemapAsset: any): void;
    _bindAndAssignAssets(materialAsset: any, assets: any): void;
}



/**
 * Callback used by {@link ModelHandleraddParser } to decide on which parser to use.
 */
export type AddParserCallback = (url: string, data: object) => boolean;
/** @typedef {import('../framework/app-base.js').AppBase} AppBase */
/** @typedef {import('./handler.js').ResourceHandler} ResourceHandler */
/**
 * Callback used by {@link ModelHandler#addParser} to decide on which parser to use.
 *
 * @callback AddParserCallback
 * @param {string} url - The resource url.
 * @param {object} data - The raw model data.
 * @returns {boolean} Return true if this parser should be used to parse the data into a
 * {@link Model}.
 */
/**
 * Resource handler used for loading {@link Model} resources.
 *
 * @implements {ResourceHandler}
 */
declare class ModelHandler implements ResourceHandler {
    /**
     * Create a new ModelHandler instance.
     *
     * @param {AppBase} app - The running {@link AppBase}.
     * @hideconstructor
     */
    constructor(app: AppBase);
    /**
     * Type of the resource the handler handles.
     *
     * @type {string}
     */
    handlerType: string;
    _device: GraphicsDevice;
    _parsers: any[];
    _defaultMaterial: StandardMaterial;
    maxRetries: number;
    load(url: any, callback: any): void;
    open(url: any, data: any): any;
    patch(asset: any, assets: any): void;
    /**
     * Add a parser that converts raw data into a {@link Model}. Default parser is for JSON models.
     *
     * @param {object} parser - See JsonModelParser for example.
     * @param {AddParserCallback} decider - Function that decides on which parser to use. Function
     * should take (url, data) arguments and return true if this parser should be used to parse the
     * data into a {@link Model}. The first parser to return true is used.
     */
    addParser(parser: object, decider: AddParserCallback): void;
}

/** @typedef {import('./mesh.js').Mesh} Mesh */
/**
 * A render contains an array of meshes that are referenced by a single hierarchy node in a GLB
 * model, and are accessible using {@link ContainerResource#renders} property. The render is the
 * resource of a Render Asset.
 *
 * @augments EventHandler
 * @ignore
 */
declare class Render extends EventHandler {
    /**
     * Meshes are reference counted, and this class owns the references and is responsible for
     * releasing the meshes when they are no longer referenced.
     *
     * @type {Mesh[]}
     * @private
     */
    private _meshes;
    /**
     * Fired when the meshes are set.
     *
     * @event Render#set:meshes
     * @param {Mesh[]} meshes - The meshes.
     * @ignore
     */
    /**
     * The meshes that the render contains.
     *
     * @type {Mesh[]}
     */
    set meshes(arg: Mesh[]);
    get meshes(): Mesh[];
    destroy(): void;
    decRefMeshes(): void;
    incRefMeshes(): void;
}



/**
 * Resource handler used for loading {@link Render} resources.
 *
 * @implements {ResourceHandler}
 */
declare class RenderHandler implements ResourceHandler {
    /**
     * Create a new RenderHandler instance.
     *
     * @param {AppBase} app - The running {@link AppBase}.
     * @hideconstructor
     */
    constructor(app: AppBase);
    /**
     * Type of the resource the handler handles.
     *
     * @type {string}
     */
    handlerType: string;
    _registry: AssetRegistry;
    load(url: any, callback: any, asset: any): void;
    open(url: any, data: any): Render;
    patch(asset: any, registry: any): void;
}



/** @typedef {import('../framework/app-base.js').AppBase} AppBase */
/** @typedef {import('./handler.js').ResourceHandler} ResourceHandler */
/**
 * Resource handler for loading JavaScript files dynamically.  Two types of JavaScript files can be
 * loaded, PlayCanvas scripts which contain calls to {@link createScript}, or regular JavaScript
 * files, such as third-party libraries.
 *
 * @implements {ResourceHandler}
 */
declare class ScriptHandler implements ResourceHandler {
    static _types: any[];
    static _push(Type: any): void;
    /**
     * Create a new ScriptHandler instance.
     *
     * @param {AppBase} app - The running {@link AppBase}.
     * @hideconstructor
     */
    constructor(app: AppBase);
    /**
     * Type of the resource the handler handles.
     *
     * @type {string}
     */
    handlerType: string;
    _app: AppBase;
    _scripts: {};
    _cache: {};
    load(url: any, callback: any): void;
    open(url: any, data: any): any;
    patch(asset: any, assets: any): void;
    _loadScript(url: any, callback: any): void;
}



/** @typedef {import('../framework/app-base.js').AppBase} AppBase */
/** @typedef {import('./handler.js').ResourceHandler} ResourceHandler */
/**
 * Resource handler used for loading {@link Scene} resources.
 *
 * @implements {ResourceHandler}
 */
declare class SceneHandler implements ResourceHandler {
    /**
     * Create a new SceneHandler instance.
     *
     * @param {AppBase} app - The running {@link AppBase}.
     * @hideconstructor
     */
    constructor(app: AppBase);
    /**
     * Type of the resource the handler handles.
     *
     * @type {string}
     */
    handlerType: string;
    _app: AppBase;
    maxRetries: number;
    load(url: any, callback: any): void;
    open(url: any, data: any): Scene;
    patch(asset: any, assets: any): void;
}

declare class SceneSettingsHandler {
    constructor(app: any);
    _app: any;
    maxRetries: number;
    load(url: any, callback: any): void;
    open(url: any, data: any): any;
}

declare class ShaderHandler {
    constructor(app: any);
    /**
     * Type of the resource the handler handles.
     *
     * @type {string}
     */
    handlerType: string;
    maxRetries: number;
    load(url: any, callback: any): void;
    open(url: any, data: any): any;
    patch(asset: any, assets: any): void;
}



/**
 * Resource handler used for loading {@link Sprite} resources.
 *
 * @implements {ResourceHandler}
 */
declare class SpriteHandler implements ResourceHandler {
    /**
     * Create a new SpriteHandler instance.
     *
     * @param {AppBase} app - The running {@link AppBase}.
     * @hideconstructor
     */
    constructor(app: AppBase);
    /**
     * Type of the resource the handler handles.
     *
     * @type {string}
     */
    handlerType: string;
    _assets: AssetRegistry;
    _device: GraphicsDevice;
    maxRetries: number;
    load(url: any, callback: any): void;
    open(url: any, data: any): Sprite;
    patch(asset: any, assets: any): void;
    _updateAtlas(asset: any): void;
    _onAssetChange(asset: any, attribute: any, value: any, oldValue: any): void;
}



/** @typedef {import('../framework/app-base.js').AppBase} AppBase */
/** @typedef {import('../framework/entity.js').Entity} Entity */
/**
 * Create a Template resource from raw database data.
 */
declare class Template {
    /**
     * Create a new Template instance.
     *
     * @param {AppBase} app - The application.
     * @param {object} data - Asset data from the database.
     */
    constructor(app: AppBase, data: object);
    _app: AppBase;
    _data: any;
    _templateRoot: Entity;
    /**
     * Create an instance of this template.
     *
     * @returns {Entity} The root entity of the created instance.
     */
    instantiate(): Entity;
    _parseTemplate(): void;
}

declare class TemplateHandler {
    constructor(app: any);
    /**
     * Type of the resource the handler handles.
     *
     * @type {string}
     */
    handlerType: string;
    _app: any;
    maxRetries: number;
    load(url: any, callback: any): void;
    open(url: any, data: any): Template;
}

declare class TextHandler {
    constructor(app: any);
    /**
     * Type of the resource the handler handles.
     *
     * @type {string}
     */
    handlerType: string;
    maxRetries: number;
    load(url: any, callback: any): void;
    open(url: any, data: any): any;
    patch(asset: any, assets: any): void;
}



/**
 * Resource handler used for loading {@link TextureAtlas} resources.
 *
 * @implements {ResourceHandler}
 */
declare class TextureAtlasHandler implements ResourceHandler {
    /**
     * Create a new TextureAtlasHandler instance.
     *
     * @param {AppBase} app - The running {@link AppBase}.
     * @hideconstructor
     */
    constructor(app: AppBase);
    /**
     * Type of the resource the handler handles.
     *
     * @type {string}
     */
    handlerType: string;
    _loader: ResourceLoader;
    maxRetries: number;
    load(url: any, callback: any): void;
    open(url: any, data: any): TextureAtlas;
    patch(asset: any, assets: any): void;
    _onAssetChange(asset: any, attribute: any, value: any): void;
}

/**
 * Used to load a group of assets and fires a callback when all assets are loaded.
 *
 * @augments EventHandler
 * @example
 *  const assets = [
 *      new Asset('model', 'container', { url: `http://example.com/asset.glb` }),
 *      new Asset('styling', 'css', { url: `http://example.com/asset.css` })
 *  ];
 *  const assetListLoader = new AssetListLoader(assets, app.assets);
 *  assetListLoader.load((err, failed) => {
 *      if (err) {
 *          console.error(`${failed.length} assets failed to load`);
 *      } else {
 *          console.log(`${assets.length} assets loaded`);
 *     }
 *  });
 */
declare class AssetListLoader extends EventHandler {
    /**
     * Create a new AssetListLoader using a list of assets to load and the asset registry used to load and manage them.
     *
     * @param {Asset[]|number[]} assetList - An array of {@link Asset} objects to load or an array of Asset IDs to load.
     * @param {AssetRegistry} assetRegistry - The application's asset registry.
     * @example
     * const assetListLoader = new pc.AssetListLoader([
     *     new pc.Asset("texture1", "texture", { url: 'http://example.com/my/assets/here/texture1.png') }),
     *     new pc.Asset("texture2", "texture", { url: 'http://example.com/my/assets/here/texture2.png') })
     * ], pc.app.assets);
     */
    constructor(assetList: Asset[] | number[], assetRegistry: AssetRegistry);
    _assets: Set<any>;
    _loadingAssets: Set<any>;
    _waitingAssets: Set<any>;
    _registry: AssetRegistry;
    _loading: boolean;
    _loaded: boolean;
    _failed: any[];
    /**
     * Removes all references to this asset list loader.
     */
    destroy(): void;
    _assetHasDependencies(asset: any): any;
    /**
     * Start loading asset list, call done() when all assets have loaded or failed to load.
     *
     * @param {Function} done - Callback called when all assets in the list are loaded. Passed (err, failed) where err is the undefined if no errors are encountered and failed contains a list of assets that failed to load.
     * @param {object} [scope] - Scope to use when calling callback.
     */
    load(done: Function, scope?: object): void;
    _callback: Function;
    _scope: any;
    /**
     * Sets a callback which will be called when all assets in the list have been loaded.
     *
     * @param {Function} done - Callback called when all assets in the list are loaded.
     * @param {object} [scope] - Scope to use when calling callback.
     */
    ready(done: Function, scope?: object): void;
    _loadingComplete(): void;
    _onLoad(asset: any): void;
    _onError(err: any, asset: any): void;
    _onAddAsset(asset: any): void;
    _waitForAsset(assetId: any): void;
}



/** @typedef {import('./asset.js').Asset} Asset */
/** @typedef {import('./asset-registry.js').AssetRegistry} AssetRegistry */
/**
 * An object that manages the case where an object holds a reference to an asset and needs to be
 * notified when changes occur in the asset. e.g. notifications include load, add and remove
 * events.
 */
declare class AssetReference {
    /**
     * Create a new AssetReference instance.
     *
     * @param {string} propertyName - The name of the property that the asset is stored under,
     * passed into callbacks to enable updating.
     * @param {Asset|object} parent - The parent object that contains the asset reference, passed
     * into callbacks to enable updating. Currently an asset, but could be component or other.
     * @param {AssetRegistry} registry - The asset registry that stores all assets.
     * @param {object} callbacks - A set of functions called when the asset state changes: load,
     * add, remove.
     * @param {object} [callbacks.load] - The function called when the asset loads
     * load(propertyName, parent, asset).
     * @param {object} [callbacks.add] - The function called when the asset is added to the
     * registry add(propertyName, parent, asset).
     * @param {object} [callbacks.remove] - The function called when the asset is remove from the
     * registry remove(propertyName, parent, asset).
     * @param {object} [callbacks.unload] - The function called when the asset is unloaded
     * unload(propertyName, parent, asset).
     * @param {object} [scope] - The scope to call the callbacks in.
     * @example
     * var reference = new pc.AssetReference('textureAsset', this, this.app.assets, {
     *     load: this.onTextureAssetLoad,
     *     add: this.onTextureAssetAdd,
     *     remove: this.onTextureAssetRemove
     * }, this);
     * reference.id = this.textureAsset.id;
     */
    constructor(propertyName: string, parent: Asset | object, registry: AssetRegistry, callbacks: {
        load?: object;
        add?: object;
        remove?: object;
        unload?: object;
    }, scope?: object);
    propertyName: string;
    parent: any;
    _scope: any;
    _registry: AssetRegistry;
    /**
     * Get or set the asset id which this references. One of either id or url must be set to
     * initialize an asset reference.
     *
     * @type {number}
     */
    set id(arg: any);
    get id(): any;
    /**
     * Get or set the asset url which this references. One of either id or url must be called to
     * initialize an asset reference.
     *
     * @type {string}
     */
    set url(arg: any);
    get url(): any;
    asset: any;
    _onAssetLoad: any;
    _onAssetAdd: any;
    _onAssetRemove: any;
    _onAssetUnload: any;
    _id: any;
    _url: any;
    _bind(): void;
    _unbind(): void;
    _onLoad(asset: any): void;
    _onAdd(asset: any): void;
    _onRemove(asset: any): void;
    _onUnload(asset: any): void;
}

declare namespace script {
    const legacy: boolean;
}

/**
 * Used to manage layout calculations for {@link LayoutGroupComponent}s.
 *
 * @ignore
 */
declare class LayoutCalculator {
    calculateLayout(elements: any, options: any): any;
}

declare class ScriptLegacyComponent extends Component {
    constructor(system: any, entity: any);
    send(name: any, functionName: any, ...args: any[]): any;
    onSetScripts(name: any, oldValue: any, newValue: any): void;
    _updateScriptAttributes(oldValue: any, newValue: any): boolean;
    _loadFromCache(urls: any): boolean;
    _loadScripts(urls: any): void;
}

declare class ScriptLegacyComponentData {
    scripts: any[];
    enabled: boolean;
    instances: {};
    _instances: {};
    runInTools: boolean;
    attributes: {};
    initialized: boolean;
    postInitialized: boolean;
    areScriptsLoaded: boolean;
}

declare class ScriptLegacyComponentSystem extends ComponentSystem {
    constructor(app: any);
    id: string;
    ComponentType: typeof ScriptLegacyComponent;
    DataType: typeof ScriptLegacyComponentData;
    schema: string[];
    preloading: boolean;
    instancesWithUpdate: any[];
    instancesWithFixedUpdate: any[];
    instancesWithPostUpdate: any[];
    instancesWithToolsUpdate: any[];
    initializeComponentData(component: any, data: any, properties: any): void;
    cloneComponent(entity: any, clone: any): Component;
    onBeforeRemove(entity: any, component: any): void;
    onInitialize(root: any): void;
    onPostInitialize(root: any): void;
    _callInstancesMethod(script: any, method: any): void;
    _initializeScriptComponent(script: any): void;
    _enableScriptComponent(script: any): void;
    _disableScriptComponent(script: any): void;
    _destroyScriptComponent(script: any): void;
    _postInitializeScriptComponent(script: any): void;
    _updateInstances(method: any, updateList: any, dt: any): void;
    onUpdate(dt: any): void;
    onFixedUpdate(dt: any): void;
    onPostUpdate(dt: any): void;
    onToolsUpdate(dt: any): void;
    broadcast(name: any, functionName: any, ...args: any[]): void;
    _preRegisterInstance(entity: any, url: any, name: any, instance: any): void;
    _registerInstances(entity: any): void;
    _cloneAttributes(attributes: any): {};
    _createAccessors(entity: any, instance: any): void;
    _createAccessor(attribute: any, instance: any): void;
    _updateAccessors(entity: any, instance: any): void;
    _convertAttributeValue(attribute: any): void;
}

declare const apps: {};
declare const common: {};
declare const config: {};
declare const data: {};
/**
 * Merge the contents of two objects into a single object.
 *
 * @param {object} target - The target object of the merge.
 * @param {object} ex - The object that is merged with target.
 * @returns {object} The target object.
 * @example
 * var A = {
 *     a: function () {
 *         console.log(this.a);
 *     }
 * };
 * var B = {
 *     b: function () {
 *         console.log(this.b);
 *     }
 * };
 *
 * pc.extend(A, B);
 * A.a();
 * // logs "a"
 * A.b();
 * // logs "b"
 * @ignore
 */
declare function extend(target: object, ex: object): object;
/**
 * Return true if the Object is not undefined.
 *
 * @param {object} o - The Object to test.
 * @returns {boolean} True if the Object is not undefined.
 * @ignore
 */
declare function isDefined(o: object): boolean;
declare const revision: "$_CURRENT_SDK_REVISION";
/**
 * Extended typeof() function, returns the type of the object.
 *
 * @param {object} obj - The object to get the type of.
 * @returns {string} The type string: "null", "undefined", "number", "string", "boolean", "array", "object", "function", "date", "regexp" or "float32array".
 * @ignore
 */
declare function type(obj: object): string;
/**
 * @name pc
 * @namespace
 * @description Root namespace for the PlayCanvas Engine.
 */
declare const version: "$_CURRENT_SDK_VERSION";

/**
 * Create a URI object from constituent parts.
 *
 * @param {object} options - Parts of the URI to build.
 * @param {string} [options.scheme] - The URI scheme (e.g. http).
 * @param {string} [options.authority] - The URI authority (e.g. `www.example.com`).
 * @param {string} [options.host] - Combination of scheme and authority (e.g. `http://www.example.com`).
 * @param {string} [options.path] - The URI path (e.g. /users/example).
 * @param {string} [options.hostpath] - Combination of scheme, authority and path (e.g. `http://www.example.com/users/example`).
 * @param {string} [options.query] - The query section, after the ?(e.g. `http://example.com?**key=value&another=123**`).
 * @param {string} [options.fragment] - The fragment section, after the # (e.g. `http://example.com#**fragment/data**`).
 * @returns {string} A URI string.
 * @ignore
 */
declare function createURI(options: {
    scheme?: string;
    authority?: string;
    host?: string;
    path?: string;
    hostpath?: string;
    query?: string;
    fragment?: string;
}): string;
/**
 * A URI object.
 *
 * @ignore
 */
declare class URI {
    /**
     * Create a new URI instance.
     *
     * @param {string} uri - URI string.
     */
    constructor(uri: string);
    /**
     * The scheme. (e.g. http).
     *
     * @type {string}
     */
    scheme: string;
    /**
     * The authority. (e.g. `www.example.com`).
     *
     * @type {string}
     */
    authority: string;
    /**
     * The path. (e.g. /users/example).
     *
     * @type {string}
     */
    path: string;
    /**
     * The query, the section after a ?. (e.g. search=value).
     *
     * @type {string}
     */
    query: string;
    /**
     * The fragment, the section after a #.
     *
     * @type {string}
     */
    fragment: string;
    /**
     * Convert URI back to string.
     *
     * @returns {string} The URI as a string.
     */
    toString(): string;
    /**
     * Returns the query parameters as an Object.
     *
     * @returns {object} The URI's query parameters converted to an Object.
     * @example
     * var s = "http://example.com?a=1&b=2&c=3";
     * var uri = new pc.URI(s);
     * var q = uri.getQuery();
     * console.log(q.a); // logs "1"
     * console.log(q.b); // logs "2"
     * console.log(q.c); // logs "3"
     */
    getQuery(): object;
    /**
     * Set the query section of the URI from a Object.
     *
     * @param {object} params - Key-Value pairs to encode into the query string.
     * @example
     * var s = "http://example.com";
     * var uri = new pc.URI(s);
     * uri.setQuery({
     *     "a": 1,
     *     "b": 2
     * });
     * console.log(uri.toString()); // logs "http://example.com?a=1&b=2
     */
    setQuery(params: object): void;
}

/**
 * Callback used by {@link Httpget }, {@link Httppost }, {@link Httpput }, {@link Httpdel }, and
 * {@link Httprequest }.
 */
export type HttpResponseCallback = (err: number | string | Error | null, response?: any) => any;
declare const http: Http;
/**
 * Callback used by {@link Http#get}, {@link Http#post}, {@link Http#put}, {@link Http#del}, and
 * {@link Http#request}.
 *
 * @callback HttpResponseCallback
 * @param {number|string|Error|null} err - The error code, message, or exception in the case where the request fails.
 * @param {*} [response] - The response data if no errors were encountered. (format depends on response type: text, Object, ArrayBuffer, XML).
 */
/**
 * Used to send and receive HTTP requests.
 */
declare class Http {
    static ContentType: {
        FORM_URLENCODED: string;
        GIF: string;
        JPEG: string;
        DDS: string;
        JSON: string;
        PNG: string;
        TEXT: string;
        XML: string;
        WAV: string;
        OGG: string;
        MP3: string;
        MP4: string;
        AAC: string;
        BIN: string;
        BASIS: string;
        GLB: string;
        OPUS: string;
    };
    static ResponseType: {
        TEXT: string;
        ARRAY_BUFFER: string;
        BLOB: string;
        DOCUMENT: string;
        JSON: string;
    };
    static binaryExtensions: string[];
    static retryDelay: number;
    /**
     * @function
     * @name Http#get
     * @description Perform an HTTP GET request to the given url.
     * @param {string} url - The URL to make the request to.
     * @param {HttpResponseCallback} callback - The callback used when the response has returned. Passed (err, data)
     * where data is the response (format depends on response type: text, Object, ArrayBuffer, XML) and
     * err is the error code.
     * @example
     * pc.http.get("http://example.com/", function (err, response) {
     *     console.log(response);
     * });
     * @returns {XMLHttpRequest} The request object.
     */
    /**
     * @function
     * @name Http#get
     * @variation 2
     * @description Perform an HTTP GET request to the given url with additional options such as headers, retries, credentials, etc.
     * @param {string} url - The URL to make the request to.
     * @param {object} options - Additional options.
     * @param {object} [options.headers] - HTTP headers to add to the request.
     * @param {boolean} [options.async] - Make the request asynchronously. Defaults to true.
     * @param {boolean} [options.cache] - If false, then add a timestamp to the request to prevent caching.
     * @param {boolean} [options.withCredentials] - Send cookies with this request. Defaults to false.
     * @param {string} [options.responseType] - Override the response type.
     * @param {Document|object} [options.postdata] - Data to send in the body of the request.
     * Some content types are handled automatically. If postdata is an XML Document, it is handled. If
     * the Content-Type header is set to 'application/json' then the postdata is JSON stringified.
     * Otherwise, by default, the data is sent as form-urlencoded.
     * @param {boolean} [options.retry] - If true then if the request fails it will be retried with an exponential backoff.
     * @param {number} [options.maxRetries] - If options.retry is true this specifies the maximum number of retries. Defaults to 5.
     * @param {number} [options.maxRetryDelay] - If options.retry is true this specifies the maximum amount of time to wait between retries in milliseconds. Defaults to 5000.
     * @param {HttpResponseCallback} callback - The callback used when the response has returned. Passed (err, data)
     * where data is the response (format depends on response type: text, Object, ArrayBuffer, XML) and
     * err is the error code.
     * @example
     * pc.http.get("http://example.com/", { "retry": true, "maxRetries": 5 }, function (err, response) {
     *     console.log(response);
     * });
     * @returns {XMLHttpRequest} The request object.
     */
    get(url: string, options: {
        headers?: object;
        async?: boolean;
        cache?: boolean;
        withCredentials?: boolean;
        responseType?: string;
        postdata?: Document | object;
        retry?: boolean;
        maxRetries?: number;
        maxRetryDelay?: number;
    }, callback: HttpResponseCallback): XMLHttpRequest;
    /**
     * @function
     * @name Http#post
     * @description Perform an HTTP POST request to the given url.
     * @param {string} url - The URL to make the request to.
     * @param {object} data - Data to send in the body of the request.
     * Some content types are handled automatically. If postdata is an XML Document, it is handled. If
     * the Content-Type header is set to 'application/json' then the postdata is JSON stringified.
     * Otherwise, by default, the data is sent as form-urlencoded.
     * @param {HttpResponseCallback} callback - The callback used when the response has returned. Passed (err, data)
     * where data is the response (format depends on response type: text, Object, ArrayBuffer, XML) and
     * err is the error code.
     * @example
     * pc.http.post("http://example.com/", { "name": "Alix" }, function (err, response) {
     *     console.log(response);
     * });
     * @returns {XMLHttpRequest} The request object.
     */
    /**
     * @function
     * @name Http#post
     * @variation 2
     * @description Perform an HTTP POST request to the given url with additional options such as headers, retries, credentials, etc.
     * @param {string} url - The URL to make the request to.
     * @param {object} data - Data to send in the body of the request.
     * Some content types are handled automatically. If postdata is an XML Document, it is handled. If
     * the Content-Type header is set to 'application/json' then the postdata is JSON stringified.
     * Otherwise, by default, the data is sent as form-urlencoded.
     * @param {object} options - Additional options.
     * @param {object} [options.headers] - HTTP headers to add to the request.
     * @param {boolean} [options.async] - Make the request asynchronously. Defaults to true.
     * @param {boolean} [options.cache] - If false, then add a timestamp to the request to prevent caching.
     * @param {boolean} [options.withCredentials] - Send cookies with this request. Defaults to false.
     * @param {string} [options.responseType] - Override the response type.
     * @param {boolean} [options.retry] - If true then if the request fails it will be retried with an exponential backoff.
     * @param {number} [options.maxRetries] - If options.retry is true this specifies the maximum number of retries. Defaults to 5.
     * @param {number} [options.maxRetryDelay] - If options.retry is true this specifies the maximum amount of time to wait between retries in milliseconds. Defaults to 5000.
     * @param {HttpResponseCallback} callback - The callback used when the response has returned. Passed (err, data)
     * where data is the response (format depends on response type: text, Object, ArrayBuffer, XML) and
     * err is the error code.
     * @example
     * pc.http.post("http://example.com/", { "name": "Alix" }, { "retry": true, "maxRetries": 5 }, function (err, response) {
     *     console.log(response);
     * });
     * @returns {XMLHttpRequest} The request object.
     */
    post(url: string, data: object, options: {
        headers?: object;
        async?: boolean;
        cache?: boolean;
        withCredentials?: boolean;
        responseType?: string;
        retry?: boolean;
        maxRetries?: number;
        maxRetryDelay?: number;
    }, callback: HttpResponseCallback): XMLHttpRequest;
    /**
     * @function
     * @name Http#put
     * @description Perform an HTTP PUT request to the given url.
     * @param {string} url - The URL to make the request to.
     * @param {Document|object} data - Data to send in the body of the request.
     * Some content types are handled automatically. If postdata is an XML Document, it is handled. If
     * the Content-Type header is set to 'application/json' then the postdata is JSON stringified.
     * Otherwise, by default, the data is sent as form-urlencoded.
     * @param {HttpResponseCallback} callback - The callback used when the response has returned. Passed (err, data)
     * where data is the response (format depends on response type: text, Object, ArrayBuffer, XML) and
     * err is the error code.
     * @example
     * pc.http.put("http://example.com/", { "name": "Alix" }, function (err, response) {
     *     console.log(response);
     * });
     * @returns {XMLHttpRequest} The request object.
     */
    /**
     * @function
     * @name Http#put
     * @variation 2
     * @description Perform an HTTP PUT request to the given url with additional options such as headers, retries, credentials, etc.
     * @param {string} url - The URL to make the request to.
     * @param {Document|object} data - Data to send in the body of the request.
     * Some content types are handled automatically. If postdata is an XML Document, it is handled. If
     * the Content-Type header is set to 'application/json' then the postdata is JSON stringified.
     * Otherwise, by default, the data is sent as form-urlencoded.
     * @param {object} options - Additional options.
     * @param {object} [options.headers] - HTTP headers to add to the request.
     * @param {boolean} [options.async] - Make the request asynchronously. Defaults to true.
     * @param {boolean} [options.cache] - If false, then add a timestamp to the request to prevent caching.
     * @param {boolean} [options.withCredentials] - Send cookies with this request. Defaults to false.
     * @param {string} [options.responseType] - Override the response type.
     * @param {boolean} [options.retry] - If true then if the request fails it will be retried with an exponential backoff.
     * @param {number} [options.maxRetries] - If options.retry is true this specifies the maximum number of retries. Defaults to 5.
     * @param {number} [options.maxRetryDelay] - If options.retry is true this specifies the maximum amount of time to wait between retries in milliseconds. Defaults to 5000.
     * @param {HttpResponseCallback} callback - The callback used when the response has returned. Passed (err, data)
     * where data is the response (format depends on response type: text, Object, ArrayBuffer, XML) and
     * err is the error code.
     * @example
     * pc.http.put("http://example.com/", { "name": "Alix" }, { "retry": true, "maxRetries": 5 }, function (err, response) {
     *     console.log(response);
     * });
     * @returns {XMLHttpRequest} The request object.
     */
    put(url: string, data: Document | object, options: {
        headers?: object;
        async?: boolean;
        cache?: boolean;
        withCredentials?: boolean;
        responseType?: string;
        retry?: boolean;
        maxRetries?: number;
        maxRetryDelay?: number;
    }, callback: HttpResponseCallback): XMLHttpRequest;
    /**
     * @function
     * @name Http#del
     * @description Perform an HTTP DELETE request to the given url.
     * @param {object} url - The URL to make the request to.
     * @param {HttpResponseCallback} callback - The callback used when the response has returned. Passed (err, data)
     * where data is the response (format depends on response type: text, Object, ArrayBuffer, XML) and
     * err is the error code.
     * @example
     * pc.http.del("http://example.com/", function (err, response) {
     *     console.log(response);
     * });
     * @returns {XMLHttpRequest} The request object.
     */
    /**
     * @function
     * @name Http#del
     * @variation 2
     * @description Perform an HTTP DELETE request to the given url with additional options such as headers, retries, credentials, etc.
     * @param {object} url - The URL to make the request to.
     * @param {object} options - Additional options.
     * @param {object} [options.headers] - HTTP headers to add to the request.
     * @param {boolean} [options.async] - Make the request asynchronously. Defaults to true.
     * @param {boolean} [options.cache] - If false, then add a timestamp to the request to prevent caching.
     * @param {boolean} [options.withCredentials] - Send cookies with this request. Defaults to false.
     * @param {string} [options.responseType] - Override the response type.
     * @param {Document|object} [options.postdata] - Data to send in the body of the request.
     * Some content types are handled automatically. If postdata is an XML Document, it is handled. If
     * the Content-Type header is set to 'application/json' then the postdata is JSON stringified.
     * Otherwise, by default, the data is sent as form-urlencoded.
     * @param {boolean} [options.retry] - If true then if the request fails it will be retried with an exponential backoff.
     * @param {number} [options.maxRetries] - If options.retry is true this specifies the maximum number of retries. Defaults to 5.
     * @param {number} [options.maxRetryDelay] - If options.retry is true this specifies the maximum amount of time to wait between retries in milliseconds. Defaults to 5000.
     * @param {HttpResponseCallback} callback - The callback used when the response has returned. Passed (err, data)
     * where data is the response (format depends on response type: text, Object, ArrayBuffer, XML) and
     * err is the error code.
     * @example
     * pc.http.del("http://example.com/", { "retry": true, "maxRetries": 5 }, function (err, response) {
     *     console.log(response);
     * });
     * @returns {XMLHttpRequest} The request object.
     */
    del(url: object, options: {
        headers?: object;
        async?: boolean;
        cache?: boolean;
        withCredentials?: boolean;
        responseType?: string;
        postdata?: Document | object;
        retry?: boolean;
        maxRetries?: number;
        maxRetryDelay?: number;
    }, callback: HttpResponseCallback): XMLHttpRequest;
    /**
     * @function
     * @name Http#request
     * @description Make a general purpose HTTP request.
     * @param {string} method - The HTTP method "GET", "POST", "PUT", "DELETE".
     * @param {string} url - The url to make the request to.
     * @param {HttpResponseCallback} callback - The callback used when the response has returned. Passed (err, data)
     * where data is the response (format depends on response type: text, Object, ArrayBuffer, XML) and
     * err is the error code.
     * @example
     * pc.http.request("get", "http://example.com/", function (err, response) {
     *     console.log(response);
     * });
     * @returns {XMLHttpRequest} The request object.
     */
    /**
     * @function
     * @name Http#request
     * @variation 2
     * @description Make a general purpose HTTP request with additional options such as headers, retries, credentials, etc.
     * @param {string} method - The HTTP method "GET", "POST", "PUT", "DELETE".
     * @param {string} url - The url to make the request to.
     * @param {object} options - Additional options.
     * @param {object} [options.headers] - HTTP headers to add to the request.
     * @param {boolean} [options.async] - Make the request asynchronously. Defaults to true.
     * @param {boolean} [options.cache] - If false, then add a timestamp to the request to prevent caching.
     * @param {boolean} [options.withCredentials] - Send cookies with this request. Defaults to false.
     * @param {boolean} [options.retry] - If true then if the request fails it will be retried with an exponential backoff.
     * @param {number} [options.maxRetries] - If options.retry is true this specifies the maximum number of retries. Defaults to 5.
     * @param {number} [options.maxRetryDelay] - If options.retry is true this specifies the maximum amount of time to wait between retries in milliseconds. Defaults to 5000.
     * @param {string} [options.responseType] - Override the response type.
     * @param {Document|object} [options.postdata] - Data to send in the body of the request.
     * Some content types are handled automatically. If postdata is an XML Document, it is handled. If
     * the Content-Type header is set to 'application/json' then the postdata is JSON stringified.
     * Otherwise, by default, the data is sent as form-urlencoded.
     * @param {HttpResponseCallback} callback - The callback used when the response has returned. Passed (err, data)
     * where data is the response (format depends on response type: text, Object, ArrayBuffer, XML) and
     * err is the error code.
     * @example
     * pc.http.request("get", "http://example.com/", { "retry": true, "maxRetries": 5 }, function (err, response) {
     *     console.log(response);
     * });
     * @returns {XMLHttpRequest} The request object.
     */
    request(method: string, url: string, options: {
        headers?: object;
        async?: boolean;
        cache?: boolean;
        withCredentials?: boolean;
        retry?: boolean;
        maxRetries?: number;
        maxRetryDelay?: number;
        responseType?: string;
        postdata?: Document | object;
    }, callback: HttpResponseCallback): XMLHttpRequest;
    _guessResponseType(url: any): string;
    _isBinaryContentType(contentType: any): boolean;
    _onReadyStateChange(method: any, url: any, options: any, xhr: any): void;
    _onSuccess(method: any, url: any, options: any, xhr: any): void;
    _onError(method: any, url: any, options: any, xhr: any): void;
}

/**
 * Create a shader from named shader chunks.
 *
 * @param {GraphicsDevice} device - The graphics device.
 * @param {string} vsName - The vertex shader chunk name.
 * @param {string} psName - The fragment shader chunk name.
 * @param {boolean} [useTransformFeedback] - Whether to use transform feedback. Defaults to false.
 * @returns {Shader} The newly created shader.
 */
declare function createShader(device: GraphicsDevice, vsName: string, psName: string, useTransformFeedback?: boolean): Shader;
/**
 * Create a shader from the supplied source code.
 *
 * @param {GraphicsDevice} device - The graphics device.
 * @param {string} vsCode - The vertex shader code.
 * @param {string} psCode - The fragment shader code.
 * @param {string} uName - Unique name for the shader.
 * @param {boolean} [useTransformFeedback] - Whether to use transform feedback. Defaults to false.
 * @param {string} [psPreamble] - An optional 'preamble' string for the fragment shader. Defaults
 * to ''.
 * @returns {Shader} The newly created shader.
 */
declare function createShaderFromCode(device: GraphicsDevice, vsCode: string, psCode: string, uName: string, useTransformFeedback?: boolean, psPreamble?: string): Shader;


/**
 * Initialize the Basis transcode worker.
 *
 * @param {object} [config] - The Basis configuration.
 * @param {string} [config.glueUrl] - URL of glue script.
 * @param {string} [config.wasmUrl] - URL of the wasm module.
 * @param {string} [config.fallbackUrl] - URL of the fallback script to use when wasm modules
 * aren't supported.
 * @param {boolean} [config.lazyInit] - Wait for first transcode request before initializing Basis
 * (default is false). Otherwise initialize Basis immediately.
 * @param {number} [config.numWorkers] - Number of workers to use for transcoding (default is 1).
 * While it is possible to improve transcode performance using multiple workers, this will likely
 * depend on the runtime platform. For example, desktop will likely benefit from more workers
 * compared to mobile. Also keep in mind that it takes time to initialize workers and increasing
 * this value could impact application startup time. Make sure to test your application performance
 * on all target platforms when changing this parameter.
 * @param {boolean} [config.eagerWorkers] - Use eager workers (default is true). When enabled, jobs
 * are assigned to workers immediately, independent of their work load. This can result in
 * unbalanced workloads, however there is no delay between jobs. If disabled, new jobs are assigned
 * to workers only when their previous job has completed. This will result in balanced workloads
 * across workers, however workers can be idle for a short time between jobs.
 * @param {string[]} [config.rgbPriority] - Array of texture compression formats in priority order
 * for textures without alpha. The supported compressed formats are: 'astc', 'atc', 'dxt', 'etc1',
 * 'etc2', 'pvr'.
 * @param {string[]} [config.rgbaPriority] - Array of texture compression formats in priority order
 * for textures with alpha. The supported compressed formats are: 'astc', 'atc', 'dxt', 'etc1',
 * 'etc2', 'pvr'.
 * @param {number} [config.maxRetries] - Number of http load retry attempts. Defaults to 5.
 */
declare function basisInitialize(config?: {
    glueUrl?: string;
    wasmUrl?: string;
    fallbackUrl?: string;
    lazyInit?: boolean;
    numWorkers?: number;
    eagerWorkers?: boolean;
    rgbPriority?: string[];
    rgbaPriority?: string[];
    maxRetries?: number;
}): void;
/**
 * Enqueue a blob of basis data for transcoding.
 *
 * @param {GraphicsDevice} device - The graphics device.
 * @param {string} url - URL of the basis file.
 * @param {object} data - The file data to transcode.
 * @param {Function} callback - Callback function to receive transcode result.
 * @param {object} [options] - Options structure
 * @param {boolean} [options.isGGGR] - Indicates this is a GGGR swizzled texture. Under some
 * circumstances the texture will be unswizzled during transcoding.
 * @param {boolean} [options.isKTX2] - Indicates the image is KTX2 format. Otherwise
 * basis format is assumed.
 * @returns {boolean} True if the basis worker was initialized and false otherwise.
 * @ignore
 */
declare function basisTranscode(device: GraphicsDevice, url: string, data: object, callback: Function, options?: {
    isGGGR?: boolean;
    isKTX2?: boolean;
}): boolean;

declare class GlbParser {
    static parseAsync(filename: any, urlBase: any, data: any, device: any, registry: any, options: any, callback: any): void;
    static parse(filename: any, data: any, device: any, options: any): any;
    constructor(device: any, assets: any, maxRetries: any);
    _device: any;
    _assets: any;
    _defaultMaterial: StandardMaterial;
    maxRetries: any;
    _getUrlWithoutParams(url: any): any;
    load(url: any, callback: any, asset: any): void;
    open(url: any, data: any, asset: any): any;
    patch(asset: any, assets: any): void;
}





/** @typedef {import('../framework/entity.js').Entity} Entity */
/** @typedef {import('../framework/app-base.js').AppBase} AppBase */
/** @typedef {import('./handler.js').ResourceHandler} ResourceHandler */
/** @typedef {import('./handler.js').ResourceHandlerCallback} ResourceHandlerCallback */
/**
 * @interface
 * @name ContainerResource
 * @description Container for a list of animations, textures, materials, renders and a model.
 */
declare class ContainerResource {
    /**
     * Instantiates an entity with a model component.
     *
     * @param {object} [options] - The initialization data for the model component type
     * {@link ModelComponent}.
     * @returns {Entity} A single entity with a model component. Model component internally
     * contains a hierarchy based on {@link GraphNode}.
     * @example
     * // load a glb file and instantiate an entity with a model component based on it
     * app.assets.loadFromUrl("statue.glb", "container", function (err, asset) {
     *     var entity = asset.resource.instantiateModelEntity({
     *         castShadows: true
     *     });
     *     app.root.addChild(entity);
     * });
     */
    instantiateModelEntity(options?: object): Entity;
    /**
     * Instantiates an entity with a render component.
     *
     * @param {object} [options] - The initialization data for the render component type
     * {@link RenderComponent}.
     * @returns {Entity} A hierarchy of entities with render components on entities containing
     * renderable geometry.
     * @example
     * // load a glb file and instantiate an entity with a render component based on it
     * app.assets.loadFromUrl("statue.glb", "container", function (err, asset) {
     *     var entity = asset.resource.instantiateRenderEntity({
     *         castShadows: true
     *     });
     *     app.root.addChild(entity);
     *
     *     // find all render components containing mesh instances, and change blend mode on their materials
     *     var renders = entity.findComponents("render");
     *     renders.forEach(function (render) {
     *         render.meshInstances.forEach(function (meshInstance) {
     *             meshInstance.material.blendType = pc.BLEND_MULTIPLICATIVE;
     *             meshInstance.material.update();
     *         });
     *     });
     * });
     */
    instantiateRenderEntity(options?: object): Entity;
}
/**
 * Loads files that contain multiple resources. For example glTF files can contain textures, models
 * and animations.
 *
 * For glTF files, the asset options object can be used to pass load time callbacks for handling
 * the various resources at different stages of loading. The table below lists the resource types
 * and the corresponding supported process functions.
 *
 * ```
 * |---------------------------------------------------------------------|
 * |  resource   |  preprocess |   process   |processAsync | postprocess |
 * |-------------+-------------+-------------+-------------+-------------|
 * | global      |      x      |             |             |      x      |
 * | node        |      x      |      x      |             |      x      |
 * | light       |      x      |      x      |             |      x      |
 * | camera      |      x      |      x      |             |      x      |
 * | animation   |      x      |             |             |      x      |
 * | material    |      x      |      x      |             |      x      |
 * | image       |      x      |             |      x      |      x      |
 * | texture     |      x      |             |      x      |      x      |
 * | buffer      |      x      |             |      x      |      x      |
 * | bufferView  |      x      |             |      x      |      x      |
 * |---------------------------------------------------------------------|
 * ```
 *
 * For example, to receive a texture preprocess callback:
 *
 * ```javascript
 * var containerAsset = new pc.Asset(filename, 'container', { url: url, filename: filename }, null, {
 *     texture: {
 *         preprocess(gltfTexture) { console.log("texture preprocess"); }
 *     },
 * });
 * ```
 *
 * @implements {ResourceHandler}
 */
declare class ContainerHandler implements ResourceHandler {
    /**
     * Create a new ContainerResource instance.
     *
     * @param {AppBase} app - The running {@link AppBase}.
     * @hideconstructor
     */
    constructor(app: AppBase);
    /**
     * Type of the resource the handler handles.
     *
     * @type {string}
     */
    handlerType: string;
    glbParser: GlbParser;
    parsers: {};
    set maxRetries(arg: any);
    get maxRetries(): any;
    /**
     * @param {string} url - The resource URL.
     * @returns {string} The URL with query parameters removed.
     * @private
     */
    private _getUrlWithoutParams;
    /**
     * @param {string} url - The resource URL.
     * @returns {*} A suitable parser to parse the resource.
     * @private
     */
    private _getParser;
    /**
     * @param {string|object} url - Either the URL of the resource to load or a structure
     * containing the load and original URL.
     * @param {string} [url.load] - The URL to be used for loading the resource.
     * @param {string} [url.original] - The original URL to be used for identifying the resource
     * format. This is necessary when loading, for example from blob.
     * @param {ResourceHandlerCallback} callback - The callback used when the resource is loaded or
     * an error occurs.
     * @param {Asset} [asset] - Optional asset that is passed by ResourceLoader.
     */
    load(url: string | object, callback: ResourceHandlerCallback, asset?: Asset): void;
    /**
     * @param {string} url - The URL of the resource to open.
     * @param {*} data - The raw resource data passed by callback from {@link ResourceHandler#load}.
     * @param {Asset} [asset] - Optional asset that is passed by ResourceLoader.
     * @returns {*} The parsed resource data.
     */
    open(url: string, data: any, asset?: Asset): any;
    /**
     * @param {Asset} asset - The asset to patch.
     * @param {AssetRegistry} assets - The asset registry.
     */
    patch(asset: Asset, assets: AssetRegistry): void;
}

/**
 * Creates a &lt;style&gt; DOM element from a string that contains CSS.
 *
 * @param {string} cssString - A string that contains valid CSS.
 * @returns {Element} The style DOM element.
 * @example
 * var css = 'body {height: 100;}';
 * var style = pc.createStyle(css);
 * document.head.appendChild(style);
 */
declare function createStyle(cssString: string): Element;
declare class CssHandler {
    constructor(app: any);
    /**
     * Type of the resource the handler handles.
     *
     * @type {string}
     */
    handlerType: string;
    maxRetries: number;
    load(url: any, callback: any): void;
    open(url: any, data: any): any;
    patch(asset: any, assets: any): void;
}


/** @typedef {import('../../texture.js').TextureParser} TextureParser */
/**
 * Parser for browser-supported image formats.
 *
 * @implements {TextureParser}
 * @ignore
 */
declare class ImgParser implements TextureParser {
    constructor(registry: any);
    crossOrigin: string;
    maxRetries: number;
    useImageBitmap: boolean;
    load(url: any, callback: any, asset: any): void;
    open(url: any, data: any, device: any): Texture;
    _loadImage(url: any, originalUrl: any, crossOrigin: any, callback: any): void;
    _loadImageBitmap(url: any, originalUrl: any, crossOrigin: any, callback: any): void;
}


/** @typedef {import('../../texture.js').TextureParser} TextureParser */
/**
 * Legacy texture parser for dds files.
 *
 * @implements {TextureParser}
 * @ignore
 */
declare class DdsParser implements TextureParser {
    constructor(registry: any);
    maxRetries: number;
    load(url: any, callback: any, asset: any): void;
    open(url: any, data: any, device: any): Texture;
}


/**
 * Texture parser for ktx files.
 *
 * @implements {TextureParser}
 * @ignore
 */
declare class KtxParser implements TextureParser {
    constructor(registry: any);
    maxRetries: number;
    load(url: any, callback: any, asset: any): void;
    open(url: any, data: any, device: any): Texture;
    parse(data: any): {
        format: any;
        width: number;
        height: number;
        levels: any[][];
        cubemap: boolean;
    };
}


/**
 * Texture parser for ktx2 files.
 *
 * @implements {TextureParser}
 * @ignore
 */
declare class Ktx2Parser implements TextureParser {
    constructor(registry: any, device: any);
    maxRetries: number;
    device: any;
    load(url: any, callback: any, asset: any): void;
    open(url: any, data: any, device: any): Texture;
    parse(arraybuffer: any, url: any, callback: any, asset: any): any;
}


/** @typedef {import('../../texture.js').TextureParser} TextureParser */
/**
 * Parser for basis files.
 *
 * @implements {TextureParser}
 * @ignore
 */
declare class BasisParser implements TextureParser {
    constructor(registry: any, device: any);
    device: any;
    maxRetries: number;
    load(url: any, callback: any, asset: any): void;
    open(url: any, data: any, device: any): Texture;
}


/** @typedef {import('../../texture.js').TextureParser} TextureParser */
/**
 * Texture parser for hdr files.
 *
 * @implements {TextureParser}
 * @ignore
 */
declare class HdrParser implements TextureParser {
    constructor(registry: any);
    maxRetries: number;
    load(url: any, callback: any, asset: any): void;
    open(url: any, data: any, device: any): Texture;
    parse(data: any): {
        width: number;
        height: number;
        levels: Uint8Array[];
    };
    _readPixels(readStream: any, width: any, height: any, flipY: any): Uint8Array;
    _readPixelsFlat(readStream: any, width: any, height: any): Uint8Array;
}





/**
 * Resource handler used for loading 2D and 3D {@link Texture} resources.
 *
 * @implements {ResourceHandler}
 */
declare class TextureHandler implements ResourceHandler {
    /**
     * Create a new TextureHandler instance.
     *
     * @param {AppBase} app - The running {@link AppBase}.
     * @hideconstructor
     */
    constructor(app: AppBase);
    /**
     * Type of the resource the handler handles.
     *
     * @type {string}
     */
    handlerType: string;
    _device: GraphicsDevice;
    _assets: AssetRegistry;
    _loader: ResourceLoader;
    imgParser: ImgParser;
    parsers: {
        dds: DdsParser;
        ktx: KtxParser;
        ktx2: Ktx2Parser;
        basis: BasisParser;
        hdr: HdrParser;
    };
    set crossOrigin(arg: string);
    get crossOrigin(): string;
    set maxRetries(arg: number);
    get maxRetries(): number;
    _getUrlWithoutParams(url: any): any;
    _getParser(url: any): any;
    load(url: any, callback: any, asset: any): void;
    open(url: any, data: any, asset: any): any;
    patch(asset: any, assets: any): void;
}
/**
 * @interface
 * @name TextureParser
 * @description Interface to a texture parser. Implementations of this interface handle the loading
 * and opening of texture assets.
 */
declare class TextureParser {
    /**
     * @function
     * @name TextureParser#load
     * @description Load the texture from the remote URL. When loaded (or failed),
     * use the callback to return an the raw resource data (or error).
     * @param {object} url - The URL of the resource to load.
     * @param {string} url.load - The URL to use for loading the resource.
     * @param {string} url.original - The original URL useful for identifying the resource type.
     * @param {ResourceHandlerCallback} callback - The callback used when the resource is loaded or an error occurs.
     * @param {Asset} [asset] - Optional asset that is passed by ResourceLoader.
     */
    load(url: {
        load: string;
        original: string;
    }, callback: ResourceHandlerCallback, asset?: Asset): void;
    /**
     * @function
     * @name TextureParser#open
     * @description Convert raw resource data into a resource instance. E.g. Take 3D model format JSON and return a {@link Model}.
     * @param {string} url - The URL of the resource to open.
     * @param {*} data - The raw resource data passed by callback from {@link ResourceHandler#load}.
     * @param {GraphicsDevice} device - The graphics device.
     * @returns {Texture} The parsed resource data.
     */
    open(url: string, data: any, device: GraphicsDevice): Texture;
}

/**
 * Create and register a new {@link ScriptType}. It returns new class type (constructor function),
 * which is auto-registered to {@link ScriptRegistry} using its name. This is the main interface to
 * create Script Types, to define custom logic using JavaScript, that is used to create interaction
 * for entities.
 *
 * @param {string} name - Unique Name of a Script Type. If a Script Type with the same name has
 * already been registered and the new one has a `swap` method defined in its prototype, then it
 * will perform hot swapping of existing Script Instances on entities using this new Script Type.
 * Note: There is a reserved list of names that cannot be used, such as list below as well as some
 * starting from `_` (underscore): system, entity, create, destroy, swap, move, scripts, onEnable,
 * onDisable, onPostStateChange, has, on, off, fire, once, hasEvent.
 * @param {AppBase} [app] - Optional application handler, to choose which {@link ScriptRegistry}
 * to add a script to. By default it will use `Application.getApplication()` to get current
 * {@link AppBase}.
 * @returns {typeof ScriptType|null} A class type (constructor function) that inherits {@link ScriptType},
 * which the developer is meant to further extend by adding attributes and prototype methods.
 * Returns null if there was an error.
 * @example
 * var Turning = pc.createScript('turn');
 *
 * // define `speed` attribute that is available in Editor UI
 * Turning.attributes.add('speed', {
 *     type: 'number',
 *     default: 180,
 *     placeholder: 'deg/s'
 * });
 *
 * // runs every tick
 * Turning.prototype.update = function (dt) {
 *     this.entity.rotate(0, this.speed * dt, 0);
 * };
 */
declare function createScript(name: string, app?: AppBase): typeof ScriptType | null;
declare namespace createScript {
    export { reservedAttributes };
}
/**
 * Register a existing class type as a Script Type to {@link ScriptRegistry}. Useful when defining
 * a ES6 script class that extends {@link ScriptType} (see example).
 *
 * @param {typeof ScriptType} script - The existing class type (constructor function) to be
 * registered as a Script Type. Class must extend {@link ScriptType} (see example). Please note: A
 * class created using {@link createScript} is auto-registered, and should therefore not be pass
 * into {@link registerScript} (which would result in swapping out all related script instances).
 * @param {string} [name] - Optional unique name of the Script Type. By default it will use the
 * same name as the existing class. If a Script Type with the same name has already been registered
 * and the new one has a `swap` method defined in its prototype, then it will perform hot swapping
 * of existing Script Instances on entities using this new Script Type. Note: There is a reserved
 * list of names that cannot be used, such as list below as well as some starting from `_`
 * (underscore): system, entity, create, destroy, swap, move, scripts, onEnable, onDisable,
 * onPostStateChange, has, on, off, fire, once, hasEvent.
 * @param {AppBase} [app] - Optional application handler, to choose which {@link ScriptRegistry}
 * to register the script type to. By default it will use `Application.getApplication()` to get
 * current {@link AppBase}.
 * @example
 * // define a ES6 script class
 * class PlayerController extends pc.ScriptType {
 *
 *     initialize() {
 *         // called once on initialize
 *     }
 *
 *     update(dt) {
 *         // called each tick
 *     }
 * }
 *
 * // register the class as a script
 * pc.registerScript(PlayerController);
 *
 * // declare script attributes (Must be after pc.registerScript())
 * PlayerController.attributes.add('attribute1', {type: 'number'});
 */
declare function registerScript(script: typeof ScriptType, name?: string, app?: AppBase): void;

declare const reservedAttributes: {};

export { ABSOLUTE_URL, ACTION_GAMEPAD, ACTION_KEYBOARD, ACTION_MOUSE, ADDRESS_CLAMP_TO_EDGE, ADDRESS_MIRRORED_REPEAT, ADDRESS_REPEAT, ANIM_BLEND_1D, ANIM_BLEND_2D_CARTESIAN, ANIM_BLEND_2D_DIRECTIONAL, ANIM_BLEND_DIRECT, ANIM_CONTROL_STATES, ANIM_EQUAL_TO, ANIM_GREATER_THAN, ANIM_GREATER_THAN_EQUAL_TO, ANIM_INTERRUPTION_NEXT, ANIM_INTERRUPTION_NEXT_PREV, ANIM_INTERRUPTION_NONE, ANIM_INTERRUPTION_PREV, ANIM_INTERRUPTION_PREV_NEXT, ANIM_LAYER_ADDITIVE, ANIM_LAYER_OVERWRITE, ANIM_LESS_THAN, ANIM_LESS_THAN_EQUAL_TO, ANIM_NOT_EQUAL_TO, ANIM_PARAMETER_BOOLEAN, ANIM_PARAMETER_FLOAT, ANIM_PARAMETER_INTEGER, ANIM_PARAMETER_TRIGGER, ANIM_STATE_ANY, ANIM_STATE_END, ANIM_STATE_START, ASPECT_AUTO, ASPECT_MANUAL, ASSET_ANIMATION, ASSET_AUDIO, ASSET_CONTAINER, ASSET_CSS, ASSET_CUBEMAP, ASSET_HTML, ASSET_IMAGE, ASSET_JSON, ASSET_MATERIAL, ASSET_MODEL, ASSET_SCRIPT, ASSET_SHADER, ASSET_TEXT, ASSET_TEXTURE, AXIS_KEY, AXIS_MOUSE_X, AXIS_MOUSE_Y, AXIS_PAD_L_X, AXIS_PAD_L_Y, AXIS_PAD_R_X, AXIS_PAD_R_Y, AnimBinder, AnimClip, AnimClipHandler, AnimComponent, AnimComponentLayer, AnimComponentSystem, AnimController, AnimCurve, AnimData, AnimEvaluator, AnimEvents, AnimSnapshot, AnimStateGraph, AnimStateGraphHandler, AnimTarget, AnimTrack, Animation, AnimationComponent, AnimationComponentSystem, AnimationHandler, AppBase, Application, Asset, AssetListLoader, AssetReference, AssetRegistry, AudioHandler, AudioListenerComponent, AudioListenerComponentSystem, AudioSourceComponent, AudioSourceComponentSystem, BAKE_COLOR, BAKE_COLORDIR, BINDGROUP_MESH, BINDGROUP_VIEW, BLENDEQUATION_ADD, BLENDEQUATION_MAX, BLENDEQUATION_MIN, BLENDEQUATION_REVERSE_SUBTRACT, BLENDEQUATION_SUBTRACT, BLENDMODE_CONSTANT_ALPHA, BLENDMODE_CONSTANT_COLOR, BLENDMODE_DST_ALPHA, BLENDMODE_DST_COLOR, BLENDMODE_ONE, BLENDMODE_ONE_MINUS_CONSTANT_ALPHA, BLENDMODE_ONE_MINUS_CONSTANT_COLOR, BLENDMODE_ONE_MINUS_DST_ALPHA, BLENDMODE_ONE_MINUS_DST_COLOR, BLENDMODE_ONE_MINUS_SRC_ALPHA, BLENDMODE_ONE_MINUS_SRC_COLOR, BLENDMODE_SRC_ALPHA, BLENDMODE_SRC_ALPHA_SATURATE, BLENDMODE_SRC_COLOR, BLENDMODE_ZERO, BLEND_ADDITIVE, BLEND_ADDITIVEALPHA, BLEND_MAX, BLEND_MIN, BLEND_MULTIPLICATIVE, BLEND_MULTIPLICATIVE2X, BLEND_NONE, BLEND_NORMAL, BLEND_PREMULTIPLIED, BLEND_SCREEN, BLEND_SUBTRACTIVE, BLUR_BOX, BLUR_GAUSSIAN, BODYFLAG_KINEMATIC_OBJECT, BODYFLAG_NORESPONSE_OBJECT, BODYFLAG_STATIC_OBJECT, BODYGROUP_DEFAULT, BODYGROUP_DYNAMIC, BODYGROUP_ENGINE_1, BODYGROUP_ENGINE_2, BODYGROUP_ENGINE_3, BODYGROUP_KINEMATIC, BODYGROUP_NONE, BODYGROUP_STATIC, BODYGROUP_TRIGGER, BODYGROUP_USER_1, BODYGROUP_USER_2, BODYGROUP_USER_3, BODYGROUP_USER_4, BODYGROUP_USER_5, BODYGROUP_USER_6, BODYGROUP_USER_7, BODYGROUP_USER_8, BODYMASK_ALL, BODYMASK_NONE, BODYMASK_NOT_STATIC, BODYMASK_NOT_STATIC_KINEMATIC, BODYMASK_STATIC, BODYSTATE_ACTIVE_TAG, BODYSTATE_DISABLE_DEACTIVATION, BODYSTATE_DISABLE_SIMULATION, BODYSTATE_ISLAND_SLEEPING, BODYSTATE_WANTS_DEACTIVATION, BODYTYPE_DYNAMIC, BODYTYPE_KINEMATIC, BODYTYPE_STATIC, BUFFER_DYNAMIC, BUFFER_GPUDYNAMIC, BUFFER_STATIC, BUFFER_STREAM, BUTTON_TRANSITION_MODE_SPRITE_CHANGE, BUTTON_TRANSITION_MODE_TINT, BasicMaterial, Batch, BatchGroup, BatchManager, BinaryHandler, BoundingBox, BoundingSphere, Bundle, BundleHandler, BundleRegistry, ButtonComponent, ButtonComponentSystem, CHUNKAPI_1_51, CHUNKAPI_1_55, CLEARFLAG_COLOR, CLEARFLAG_DEPTH, CLEARFLAG_STENCIL, COMPUPDATED_BLEND, COMPUPDATED_CAMERAS, COMPUPDATED_INSTANCES, COMPUPDATED_LIGHTS, CUBEFACE_NEGX, CUBEFACE_NEGY, CUBEFACE_NEGZ, CUBEFACE_POSX, CUBEFACE_POSY, CUBEFACE_POSZ, CUBEPROJ_BOX, CUBEPROJ_NONE, CULLFACE_BACK, CULLFACE_FRONT, CULLFACE_FRONTANDBACK, CULLFACE_NONE, CURVE_CARDINAL, CURVE_CATMULL, CURVE_LINEAR, CURVE_SMOOTHSTEP, CURVE_SPLINE, CURVE_STEP, Camera, CameraComponent, CameraComponentSystem, CanvasFont, CollisionComponent, CollisionComponentSystem, Color, Command, Component, ComponentSystem, ComponentSystemRegistry, ContactPoint, ContactResult, ContainerHandler, ContainerResource, ContextCreationError, Controller, CssHandler, CubemapHandler, Curve, CurveSet, DETAILMODE_ADD, DETAILMODE_MAX, DETAILMODE_MIN, DETAILMODE_MUL, DETAILMODE_OVERLAY, DETAILMODE_SCREEN, DISTANCE_EXPONENTIAL, DISTANCE_INVERSE, DISTANCE_LINEAR, DefaultAnimBinder, ELEMENTTYPE_FLOAT32, ELEMENTTYPE_GROUP, ELEMENTTYPE_IMAGE, ELEMENTTYPE_INT16, ELEMENTTYPE_INT32, ELEMENTTYPE_INT8, ELEMENTTYPE_TEXT, ELEMENTTYPE_UINT16, ELEMENTTYPE_UINT32, ELEMENTTYPE_UINT8, EMITTERSHAPE_BOX, EMITTERSHAPE_SPHERE, EVENT_KEYDOWN, EVENT_KEYUP, EVENT_MOUSEDOWN, EVENT_MOUSEMOVE, EVENT_MOUSEUP, EVENT_MOUSEWHEEL, EVENT_SELECT, EVENT_SELECTEND, EVENT_SELECTSTART, EVENT_TOUCHCANCEL, EVENT_TOUCHEND, EVENT_TOUCHMOVE, EVENT_TOUCHSTART, ElementComponent, ElementComponentSystem, ElementDragHelper, ElementInput, ElementInputEvent, ElementMouseEvent, ElementSelectEvent, ElementTouchEvent, Entity, EntityReference, EnvLighting, EventHandler, FILLMODE_FILL_WINDOW, FILLMODE_KEEP_ASPECT, FILLMODE_NONE, FILTER_LINEAR, FILTER_LINEAR_MIPMAP_LINEAR, FILTER_LINEAR_MIPMAP_NEAREST, FILTER_NEAREST, FILTER_NEAREST_MIPMAP_LINEAR, FILTER_NEAREST_MIPMAP_NEAREST, FITMODE_CONTAIN, FITMODE_COVER, FITMODE_STRETCH, FITTING_BOTH, FITTING_NONE, FITTING_SHRINK, FITTING_STRETCH, FOG_EXP, FOG_EXP2, FOG_LINEAR, FOG_NONE, FONT_BITMAP, FONT_MSDF, FRESNEL_NONE, FRESNEL_SCHLICK, FUNC_ALWAYS, FUNC_EQUAL, FUNC_GREATER, FUNC_GREATEREQUAL, FUNC_LESS, FUNC_LESSEQUAL, FUNC_NEVER, FUNC_NOTEQUAL, FolderHandler, Font, FontHandler, ForwardRenderer, Frustum, GAMMA_NONE, GAMMA_SRGB, GAMMA_SRGBFAST, GAMMA_SRGBHDR, GamePads, GraphNode, GraphicsDevice, HierarchyHandler, HtmlHandler, Http, I18n, INDEXFORMAT_UINT16, INDEXFORMAT_UINT32, INDEXFORMAT_UINT8, INTERPOLATION_CUBIC, INTERPOLATION_LINEAR, INTERPOLATION_STEP, ImageElement, IndexBuffer, IndexedList, JointComponent, JointComponentSystem, JsonHandler, JsonStandardMaterialParser, KEY_0, KEY_1, KEY_2, KEY_3, KEY_4, KEY_5, KEY_6, KEY_7, KEY_8, KEY_9, KEY_A, KEY_ADD, KEY_ALT, KEY_B, KEY_BACKSPACE, KEY_BACK_SLASH, KEY_C, KEY_CAPS_LOCK, KEY_CLOSE_BRACKET, KEY_COMMA, KEY_CONTEXT_MENU, KEY_CONTROL, KEY_D, KEY_DECIMAL, KEY_DELETE, KEY_DIVIDE, KEY_DOWN, KEY_E, KEY_END, KEY_ENTER, KEY_EQUAL, KEY_ESCAPE, KEY_F, KEY_F1, KEY_F10, KEY_F11, KEY_F12, KEY_F2, KEY_F3, KEY_F4, KEY_F5, KEY_F6, KEY_F7, KEY_F8, KEY_F9, KEY_G, KEY_H, KEY_HOME, KEY_I, KEY_INSERT, KEY_J, KEY_K, KEY_L, KEY_LEFT, KEY_M, KEY_META, KEY_MULTIPLY, KEY_N, KEY_NUMPAD_0, KEY_NUMPAD_1, KEY_NUMPAD_2, KEY_NUMPAD_3, KEY_NUMPAD_4, KEY_NUMPAD_5, KEY_NUMPAD_6, KEY_NUMPAD_7, KEY_NUMPAD_8, KEY_NUMPAD_9, KEY_O, KEY_OPEN_BRACKET, KEY_P, KEY_PAGE_DOWN, KEY_PAGE_UP, KEY_PAUSE, KEY_PERIOD, KEY_PRINT_SCREEN, KEY_Q, KEY_R, KEY_RETURN, KEY_RIGHT, KEY_S, KEY_SEMICOLON, KEY_SEPARATOR, KEY_SHIFT, KEY_SLASH, KEY_SPACE, KEY_SUBTRACT, KEY_T, KEY_TAB, KEY_U, KEY_UP, KEY_V, KEY_W, KEY_WINDOWS, KEY_X, KEY_Y, KEY_Z, Key, Keyboard, KeyboardEvent, LAYERID_DEPTH, LAYERID_IMMEDIATE, LAYERID_SKYBOX, LAYERID_UI, LAYERID_WORLD, LAYER_FX, LAYER_GIZMO, LAYER_HUD, LAYER_WORLD, LIGHTFALLOFF_INVERSESQUARED, LIGHTFALLOFF_LINEAR, LIGHTSHAPE_DISK, LIGHTSHAPE_PUNCTUAL, LIGHTSHAPE_RECT, LIGHTSHAPE_SPHERE, LIGHTTYPE_COUNT, LIGHTTYPE_DIRECTIONAL, LIGHTTYPE_OMNI, LIGHTTYPE_POINT, LIGHTTYPE_SPOT, LINEBATCH_GIZMO, LINEBATCH_OVERLAY, LINEBATCH_WORLD, Layer, LayerComposition, LayoutCalculator, LayoutChildComponent, LayoutChildComponentSystem, LayoutGroupComponent, LayoutGroupComponentSystem, Light, LightComponent, LightComponentSystem, LightingParams, Lightmapper, LocalizedAsset, MASK_AFFECT_DYNAMIC, MASK_AFFECT_LIGHTMAPPED, MASK_BAKE, MOTION_FREE, MOTION_LIMITED, MOTION_LOCKED, MOUSEBUTTON_LEFT, MOUSEBUTTON_MIDDLE, MOUSEBUTTON_NONE, MOUSEBUTTON_RIGHT, Mat3, Mat4, Material, MaterialHandler, Mesh, MeshInstance, Model, ModelComponent, ModelComponentSystem, ModelHandler, Morph, MorphInstance, MorphTarget, Mouse, MouseEvent$1 as MouseEvent, Node$1 as Node, ORIENTATION_HORIZONTAL, ORIENTATION_VERTICAL, OrientedBox, PAD_1, PAD_2, PAD_3, PAD_4, PAD_DOWN, PAD_FACE_1, PAD_FACE_2, PAD_FACE_3, PAD_FACE_4, PAD_LEFT, PAD_L_SHOULDER_1, PAD_L_SHOULDER_2, PAD_L_STICK_BUTTON, PAD_L_STICK_X, PAD_L_STICK_Y, PAD_RIGHT, PAD_R_SHOULDER_1, PAD_R_SHOULDER_2, PAD_R_STICK_BUTTON, PAD_R_STICK_X, PAD_R_STICK_Y, PAD_SELECT, PAD_START, PAD_UP, PAD_VENDOR, PARTICLEMODE_CPU, PARTICLEMODE_GPU, PARTICLEORIENTATION_EMITTER, PARTICLEORIENTATION_SCREEN, PARTICLEORIENTATION_WORLD, PARTICLESORT_DISTANCE, PARTICLESORT_NEWER_FIRST, PARTICLESORT_NONE, PARTICLESORT_OLDER_FIRST, PIXELFORMAT_111110F, PIXELFORMAT_A8, PIXELFORMAT_ASTC_4x4, PIXELFORMAT_ATC_RGB, PIXELFORMAT_ATC_RGBA, PIXELFORMAT_DEPTH, PIXELFORMAT_DEPTHSTENCIL, PIXELFORMAT_DXT1, PIXELFORMAT_DXT3, PIXELFORMAT_DXT5, PIXELFORMAT_ETC1, PIXELFORMAT_ETC2_RGB, PIXELFORMAT_ETC2_RGBA, PIXELFORMAT_L8, PIXELFORMAT_L8_A8, PIXELFORMAT_PVRTC_2BPP_RGBA_1, PIXELFORMAT_PVRTC_2BPP_RGB_1, PIXELFORMAT_PVRTC_4BPP_RGBA_1, PIXELFORMAT_PVRTC_4BPP_RGB_1, PIXELFORMAT_R32F, PIXELFORMAT_R4_G4_B4_A4, PIXELFORMAT_R5_G5_B5_A1, PIXELFORMAT_R5_G6_B5, PIXELFORMAT_R8_G8_B8, PIXELFORMAT_R8_G8_B8_A8, PIXELFORMAT_RGB16F, PIXELFORMAT_RGB32F, PIXELFORMAT_RGBA16F, PIXELFORMAT_RGBA32F, PIXELFORMAT_SRGB, PIXELFORMAT_SRGBA, PRIMITIVE_LINELOOP, PRIMITIVE_LINES, PRIMITIVE_LINESTRIP, PRIMITIVE_POINTS, PRIMITIVE_TRIANGLES, PRIMITIVE_TRIFAN, PRIMITIVE_TRISTRIP, PROJECTION_ORTHOGRAPHIC, PROJECTION_PERSPECTIVE, ParticleEmitter, ParticleSystemComponent, ParticleSystemComponentSystem, PhongMaterial, Picker, Plane, PostEffect$1 as PostEffect, PostEffectQueue, ProgramLibrary, Quat, RENDERSTYLE_POINTS, RENDERSTYLE_SOLID, RENDERSTYLE_WIREFRAME, RESOLUTION_AUTO, RESOLUTION_FIXED, RIGIDBODY_ACTIVE_TAG, RIGIDBODY_CF_KINEMATIC_OBJECT, RIGIDBODY_CF_NORESPONSE_OBJECT, RIGIDBODY_CF_STATIC_OBJECT, RIGIDBODY_DISABLE_DEACTIVATION, RIGIDBODY_DISABLE_SIMULATION, RIGIDBODY_ISLAND_SLEEPING, RIGIDBODY_TYPE_DYNAMIC, RIGIDBODY_TYPE_KINEMATIC, RIGIDBODY_TYPE_STATIC, RIGIDBODY_WANTS_DEACTIVATION, Ray, RaycastResult, ReadStream, RenderComponent, RenderComponentSystem, RenderHandler, RenderTarget, ResourceHandler, ResourceLoader, RigidBodyComponent, RigidBodyComponentSystem, SCALEMODE_BLEND, SCALEMODE_NONE, SCROLLBAR_VISIBILITY_SHOW_ALWAYS, SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED, SCROLL_MODE_BOUNCE, SCROLL_MODE_CLAMP, SCROLL_MODE_INFINITE, SEMANTIC_ATTR, SEMANTIC_ATTR0, SEMANTIC_ATTR1, SEMANTIC_ATTR10, SEMANTIC_ATTR11, SEMANTIC_ATTR12, SEMANTIC_ATTR13, SEMANTIC_ATTR14, SEMANTIC_ATTR15, SEMANTIC_ATTR2, SEMANTIC_ATTR3, SEMANTIC_ATTR4, SEMANTIC_ATTR5, SEMANTIC_ATTR6, SEMANTIC_ATTR7, SEMANTIC_ATTR8, SEMANTIC_ATTR9, SEMANTIC_BLENDINDICES, SEMANTIC_BLENDWEIGHT, SEMANTIC_COLOR, SEMANTIC_NORMAL, SEMANTIC_POSITION, SEMANTIC_TANGENT, SEMANTIC_TEXCOORD, SEMANTIC_TEXCOORD0, SEMANTIC_TEXCOORD1, SEMANTIC_TEXCOORD2, SEMANTIC_TEXCOORD3, SEMANTIC_TEXCOORD4, SEMANTIC_TEXCOORD5, SEMANTIC_TEXCOORD6, SEMANTIC_TEXCOORD7, SHADERDEF_DIRLM, SHADERDEF_INSTANCING, SHADERDEF_LM, SHADERDEF_LMAMBIENT, SHADERDEF_MORPH_NORMAL, SHADERDEF_MORPH_POSITION, SHADERDEF_MORPH_TEXTURE_BASED, SHADERDEF_NOSHADOW, SHADERDEF_SCREENSPACE, SHADERDEF_SKIN, SHADERDEF_TANGENTS, SHADERDEF_UV0, SHADERDEF_UV1, SHADERDEF_VCOLOR, SHADERSTAGE_COMPUTE, SHADERSTAGE_FRAGMENT, SHADERSTAGE_VERTEX, SHADERTAG_MATERIAL, SHADERTYPE_DEPTH, SHADERTYPE_FORWARD, SHADERTYPE_PICK, SHADERTYPE_SHADOW, SHADER_DEPTH, SHADER_FORWARD, SHADER_FORWARDHDR, SHADER_PICK, SHADER_SHADOW, SHADOWUPDATE_NONE, SHADOWUPDATE_REALTIME, SHADOWUPDATE_THISFRAME, SHADOW_COUNT, SHADOW_DEPTH, SHADOW_PCF1, SHADOW_PCF3, SHADOW_PCF5, SHADOW_VSM16, SHADOW_VSM32, SHADOW_VSM8, SORTKEY_DEPTH, SORTKEY_FORWARD, SORTMODE_BACK2FRONT, SORTMODE_CUSTOM, SORTMODE_FRONT2BACK, SORTMODE_MANUAL, SORTMODE_MATERIALMESH, SORTMODE_NONE, SPECOCC_AO, SPECOCC_GLOSSDEPENDENT, SPECOCC_NONE, SPECULAR_BLINN, SPECULAR_PHONG, SPRITETYPE_ANIMATED, SPRITETYPE_SIMPLE, SPRITE_RENDERMODE_SIMPLE, SPRITE_RENDERMODE_SLICED, SPRITE_RENDERMODE_TILED, STENCILOP_DECREMENT, STENCILOP_DECREMENTWRAP, STENCILOP_INCREMENT, STENCILOP_INCREMENTWRAP, STENCILOP_INVERT, STENCILOP_KEEP, STENCILOP_REPLACE, STENCILOP_ZERO, Scene, SceneHandler, SceneRegistry, SceneRegistryItem, SceneSettingsHandler, ScopeId, ScopeSpace, ScreenComponent, ScreenComponentSystem, ScriptAttributes, ScriptComponent, ScriptComponentSystem, ScriptHandler, ScriptLegacyComponent, ScriptLegacyComponentSystem, ScriptRegistry, ScriptType, ScrollViewComponent, ScrollViewComponentSystem, ScrollbarComponent, ScrollbarComponentSystem, Shader, ShaderHandler, SingleContactResult, Skeleton, Skin, SkinBatchInstance, SkinInstance, SortedLoopArray, Sound, SoundComponent, SoundComponentSystem, SoundInstance, SoundInstance3d, SoundManager, SoundSlot, Sprite, SpriteAnimationClip, SpriteComponent, SpriteComponentSystem, SpriteHandler, StandardMaterial as StandardMaterial, StencilParameters, TEXHINT_ASSET, TEXHINT_LIGHTMAP, TEXHINT_NONE, TEXHINT_SHADOWMAP, TEXTURELOCK_READ, TEXTURELOCK_WRITE, TEXTUREPROJECTION_CUBE, TEXTUREPROJECTION_EQUIRECT, TEXTUREPROJECTION_NONE, TEXTUREPROJECTION_OCTAHEDRAL, TEXTURETYPE_DEFAULT, TEXTURETYPE_RGBE, TEXTURETYPE_RGBM, TEXTURETYPE_SWIZZLEGGGR, TONEMAP_ACES, TONEMAP_ACES2, TONEMAP_FILMIC, TONEMAP_HEJL, TONEMAP_LINEAR, TRACEID_RENDER_ACTION, TRACEID_RENDER_FRAME, TRACEID_RENDER_PASS, TRACEID_RENDER_PASS_DETAIL, TRACEID_RENDER_TARGET_ALLOC, TRACEID_SHADER_ALLOC, TRACEID_TEXTURE_ALLOC, TYPE_FLOAT32, TYPE_INT16, TYPE_INT32, TYPE_INT8, TYPE_UINT16, TYPE_UINT32, TYPE_UINT8, Tags, Template, TemplateHandler, TextElement, TextHandler, Texture, TextureAtlas, TextureAtlasHandler, TextureHandler, TextureParser, Timer, Touch$1 as Touch, TouchDevice, TouchEvent$1 as TouchEvent, Tracing, TransformFeedback, UNIFORMTYPE_BOOL, UNIFORMTYPE_BVEC2, UNIFORMTYPE_BVEC3, UNIFORMTYPE_BVEC4, UNIFORMTYPE_FLOAT, UNIFORMTYPE_FLOATARRAY, UNIFORMTYPE_INT, UNIFORMTYPE_IVEC2, UNIFORMTYPE_IVEC3, UNIFORMTYPE_IVEC4, UNIFORMTYPE_MAT2, UNIFORMTYPE_MAT3, UNIFORMTYPE_MAT4, UNIFORMTYPE_TEXTURE2D, UNIFORMTYPE_TEXTURE2D_SHADOW, UNIFORMTYPE_TEXTURE3D, UNIFORMTYPE_TEXTURECUBE, UNIFORMTYPE_TEXTURECUBE_SHADOW, UNIFORMTYPE_VEC2, UNIFORMTYPE_VEC2ARRAY, UNIFORMTYPE_VEC3, UNIFORMTYPE_VEC3ARRAY, UNIFORMTYPE_VEC4, UNIFORMTYPE_VEC4ARRAY, URI, UnsupportedBrowserError, VIEW_CENTER, VIEW_LEFT, VIEW_RIGHT, Vec2, Vec3, Vec4, VertexBuffer, VertexFormat, VertexIterator, WasmModule, WebglGraphicsDevice, WorldClusters, XRDEPTHSENSINGFORMAT_F32, XRDEPTHSENSINGFORMAT_L8A8, XRDEPTHSENSINGUSAGE_CPU, XRDEPTHSENSINGUSAGE_GPU, XRHAND_LEFT, XRHAND_NONE, XRHAND_RIGHT, XRSPACE_BOUNDEDFLOOR, XRSPACE_LOCAL, XRSPACE_LOCALFLOOR, XRSPACE_UNBOUNDED, XRSPACE_VIEWER, XRTARGETRAY_GAZE, XRTARGETRAY_POINTER, XRTARGETRAY_SCREEN, XRTRACKABLE_MESH, XRTRACKABLE_PLANE, XRTRACKABLE_POINT, XRTYPE_AR, XRTYPE_INLINE, XRTYPE_VR, XrDepthSensing, XrDomOverlay, XrHitTest, XrHitTestSource, XrImageTracking, XrInput, XrInputSource, XrLightEstimation, XrManager, XrPlane, XrPlaneDetection, XrTrackedImage, ZoneComponent, ZoneComponentSystem, anim, app, apps, asset, audio, basisInitialize, basisSetDownloadConfig, basisTranscode, bindGroupNames, calculateNormals, calculateTangents, common, config, createBox, createCapsule, createCone, createCylinder, createMesh, createPlane, createScript, createShader, createShaderFromCode, createSphere, createStyle, createTorus, createURI, data, drawFullscreenQuad, drawQuadWithShader, drawTexture, events, extend, fw, getTouchTargetCoords, gfx, guid, http, inherits, input, isDefined, log, makeArray, math, now, path, platform, posteffect, prefilterCubemap, programlib, registerScript, reprojectTexture, revision, scene, script, semanticToLocation, shFromCubemap, shaderChunks, shadowTypeToString, shape, string, time, type, typedArrayIndexFormats, typedArrayIndexFormatsByteSize, typedArrayToType, typedArrayTypes, typedArrayTypesByteSize, uniformTypeToName, version };
export as namespace pc;
