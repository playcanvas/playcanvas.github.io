import"../../core/debug.js";import{CULLFACE_BACK as t,BLENDMODE_ONE as e,BLENDEQUATION_REVERSE_SUBTRACT as s,BLENDMODE_ZERO as r,BLENDEQUATION_ADD as a,BLENDMODE_SRC_ALPHA as i,BLENDMODE_ONE_MINUS_SRC_ALPHA as h,BLENDMODE_DST_COLOR as n,BLENDMODE_SRC_COLOR as l,BLENDMODE_ONE_MINUS_DST_COLOR as d,BLENDEQUATION_MIN as o,BLENDEQUATION_MAX as c}from"../../platform/graphics/constants.js";import{BlendState as p}from"../../platform/graphics/blend-state.js";import{DepthState as m}from"../../platform/graphics/depth-state.js";import{ShaderProcessorOptions as _}from"../../platform/graphics/shader-processor-options.js";import{BLEND_NONE as u,BLEND_NORMAL as S,BLEND_SUBTRACTIVE as b,BLEND_PREMULTIPLIED as g,BLEND_ADDITIVE as f,BLEND_ADDITIVEALPHA as y,BLEND_MULTIPLICATIVE2X as B,BLEND_SCREEN as W,BLEND_MULTIPLICATIVE as I,BLEND_MIN as v,BLEND_MAX as F}from"../constants.js";import{processShader as T}from"../shader-lib/utils.js";import{getDefaultMaterial as j}from"./default-material.js";const k=[];k[b]={src:e,dst:e,op:s},k[u]={src:e,dst:r,op:a},k[S]={src:i,dst:h,op:a},k[g]={src:e,dst:h,op:a},k[f]={src:e,dst:e,op:a},k[y]={src:i,dst:e,op:a},k[B]={src:n,dst:l,op:a},k[W]={src:d,dst:e,op:a},k[I]={src:n,dst:r,op:a},k[v]={src:e,dst:e,op:o},k[F]={src:e,dst:e,op:c};let D=0;class P{constructor(){this._shader=null,this.meshInstances=[],this.name="Untitled",this.id=D++,this.variants={},this.parameters={},this.alphaTest=0,this.alphaToCoverage=!1,this._blendState=new p,this._depthState=new m,this.cull=t,this.stencilFront=null,this.stencilBack=null,this.depthBias=0,this.slopeDepthBias=0,this._shaderVersion=0,this._scene=null,this._dirtyBlend=!1,this.dirty=!0}set redWrite(t){this._blendState.redWrite=t}get redWrite(){return this._blendState.redWrite}set greenWrite(t){this._blendState.greenWrite=t}get greenWrite(){return this._blendState.greenWrite}set blueWrite(t){this._blendState.blueWrite=t}get blueWrite(){return this._blendState.blueWrite}set alphaWrite(t){this._blendState.alphaWrite=t}get alphaWrite(){return this._blendState.alphaWrite}set shader(t){this._shader=t}get shader(){return this._shader}get transparent(){return this._blendState.blend}_markBlendDirty(){this._scene?this._scene.layers._dirtyBlend=!0:this._dirtyBlend=!0}set blendState(t){this._blendState.blend!==t.blend&&this._markBlendDirty(),this._blendState.copy(t)}get blendState(){return this._blendState}set blendType(t){const e=k[t];this._blendState.setColorBlend(e.op,e.src,e.dst),this._blendState.setAlphaBlend(e.op,e.src,e.dst);const s=t!==u;this._blendState.blend!==s&&(this._blendState.blend=s,this._markBlendDirty()),this._updateMeshInstanceKeys()}get blendType(){if(!this.transparent)return u;const{colorOp:t,colorSrcFactor:e,colorDstFactor:s,alphaOp:r,alphaSrcFactor:a,alphaDstFactor:i}=this._blendState;for(let h=0;h<k.length;h++){const n=k[h];if(n.src===e&&n.dst===s&&n.op===t&&n.src===a&&n.dst===i&&n.op===r)return h}return S}set depthState(t){this._depthState.copy(t)}get depthState(){return this._depthState}set depthTest(t){this._depthState.test=t}get depthTest(){return this._depthState.test}set depthFunc(t){this._depthState.func=t}get depthFunc(){return this._depthState.func}set depthWrite(t){this._depthState.write=t}get depthWrite(){return this._depthState.write}copy(t){var e;return this.name=t.name,this._shader=t._shader,this.alphaTest=t.alphaTest,this.alphaToCoverage=t.alphaToCoverage,this._blendState.copy(t._blendState),this._depthState.copy(t._depthState),this.cull=t.cull,this.depthBias=t.depthBias,this.slopeDepthBias=t.slopeDepthBias,this.stencilFront=null==(e=t.stencilFront)?void 0:e.clone(),t.stencilBack&&(this.stencilBack=t.stencilFront===t.stencilBack?this.stencilFront:t.stencilBack.clone()),this}clone(){return(new this.constructor).copy(this)}_updateMeshInstanceKeys(){const t=this.meshInstances;for(let e=0;e<t.length;e++)t[e].updateKey()}updateUniforms(t,e){}getShaderVariant(t,e,s,r,a,i,h,n,l){const d=new _(h,n,l);return T(this._shader,d)}update(){this.dirty=!0,this._shader&&(this._shader.failed=!1)}clearParameters(){this.parameters={}}getParameters(){return this.parameters}clearVariants(){this.variants={};const t=this.meshInstances,e=t.length;for(let s=0;s<e;s++)t[s].clearShaders()}getParameter(t){return this.parameters[t]}setParameter(t,e){if(void 0===e&&"object"==typeof t){const s=t;if(s.length){for(let t=0;t<s.length;t++)this.setParameter(s[t]);return}t=s.name,e=s.value}const s=this.parameters[t];s?s.data=e:this.parameters[t]={scopeId:null,data:e}}deleteParameter(t){this.parameters[t]&&delete this.parameters[t]}setParameters(t,e){const s=this.parameters;void 0===e&&(e=s);for(const r in e){const e=s[r];e&&(e.scopeId||(e.scopeId=t.scope.resolve(r)),e.scopeId.setValue(e.data))}}destroy(){this.variants={},this._shader=null;for(let t=0;t<this.meshInstances.length;t++){const e=this.meshInstances[t];if(e.clearShaders(),e._material=null,e.mesh){const t=j(e.mesh.device);this!==t&&(e.material=t)}}this.meshInstances.length=0}addMeshInstanceRef(t){this.meshInstances.push(t)}removeMeshInstanceRef(t){const e=this.meshInstances,s=e.indexOf(t);-1!==s&&e.splice(s,1)}}export{P as Material};
